
lwIP_NIOS_II_Example.elf:     file format elf32-littlenios2
lwIP_NIOS_II_Example.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00000020

Program Header:
    LOAD off    0x00001020 vaddr 0x00000020 paddr 0x00000020 align 2**12
         filesz 0x0003340c memsz 0x0003340c flags r-x
    LOAD off    0x0003442c vaddr 0x0003342c paddr 0x0003564c align 2**12
         filesz 0x00002220 memsz 0x00002220 flags rw-
    LOAD off    0x0003686c vaddr 0x0003786c paddr 0x0003786c align 2**12
         filesz 0x00000000 memsz 0x000499ac flags rw-
    LOAD off    0x00037000 vaddr 0x05000000 paddr 0x05000000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  05000000  05000000  00037000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .text         0002e2dc  00000020  00000020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00005130  0002e2fc  0002e2fc  0002f2fc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .rwdata       00002220  0003342c  0003564c  0003442c  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  4 .bss          000499ac  0003786c  0003786c  0003686c  2**2
                  ALLOC, SMALL_DATA
  5 .comment      00000023  00000000  00000000  00037020  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00001690  00000000  00000000  00037048  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0003f1e5  00000000  00000000  000386d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000dc8c  00000000  00000000  000778bd  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00012a0c  00000000  00000000  00085549  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000041d4  00000000  00000000  00097f58  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00008401  00000000  00000000  0009c12c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00014845  00000000  00000000  000a452d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_alt_sim_info 00000050  00000000  00000000  000b8d74  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000a98  00000000  00000000  000b8dc8  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .thread_model 00000003  00000000  00000000  000c0b75  2**0
                  CONTENTS, READONLY
 16 .cpu          00000003  00000000  00000000  000c0b78  2**0
                  CONTENTS, READONLY
 17 .qsys         00000001  00000000  00000000  000c0b7b  2**0
                  CONTENTS, READONLY
 18 .simulation_enabled 00000001  00000000  00000000  000c0b7c  2**0
                  CONTENTS, READONLY
 19 .sysid_hash   00000004  00000000  00000000  000c0b7d  2**0
                  CONTENTS, READONLY
 20 .sysid_base   00000004  00000000  00000000  000c0b81  2**0
                  CONTENTS, READONLY
 21 .sysid_time   00000004  00000000  00000000  000c0b85  2**0
                  CONTENTS, READONLY
 22 .stderr_dev   00000009  00000000  00000000  000c0b89  2**0
                  CONTENTS, READONLY
 23 .stdin_dev    00000009  00000000  00000000  000c0b92  2**0
                  CONTENTS, READONLY
 24 .stdout_dev   00000009  00000000  00000000  000c0b9b  2**0
                  CONTENTS, READONLY
 25 .sopc_system_name 0000000c  00000000  00000000  000c0ba4  2**0
                  CONTENTS, READONLY
 26 .quartus_project_dir 0000002e  00000000  00000000  000c0bb0  2**0
                  CONTENTS, READONLY
 27 .jdi          00005066  00000000  00000000  000c0bde  2**0
                  CONTENTS, READONLY
 28 .sopcinfo     001a200d  00000000  00000000  000c5c44  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
05000000 l    d  .entry	00000000 .entry
00000020 l    d  .text	00000000 .text
0002e2fc l    d  .rodata	00000000 .rodata
0003342c l    d  .rwdata	00000000 .rwdata
0003786c l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../lwIP_NIOS_II_Example_bsp/obj/HAL/src/crt0.o
00000098 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alteraTseEthernetif.c
0000009c l     F .text	00000064 low_level_init
00000100 l     F .text	00000234 low_level_input
00000000 l    df *ABS*	00000000 fs.c
0002e3b0 l     O .rodata	00000345 data_img_sics_gif
0002e6f5 l     O .rodata	00000298 data_404_html
0002e98d l     O .rodata	00000671 data_index_html
00000000 l    df *ABS*	00000000 fsdata.c
00000000 l    df *ABS*	00000000 httpd.c
00000624 l     F .text	00000040 conn_err
00000664 l     F .text	00000060 close_conn
000006c4 l     F .text	000000f4 send_data
000007b8 l     F .text	000000c4 http_poll
0000087c l     F .text	00000070 http_sent
000008ec l     F .text	0000024c http_recv
00000b38 l     F .text	00000100 http_accept
00000000 l    df *ABS*	00000000 lwip_tse_mac.c
00000000 l    df *ABS*	00000000 tse_my_system.c
00000000 l    df *ABS*	00000000 echo.c
00000000 l    df *ABS*	00000000 histogram.c
00000000 l    df *ABS*	00000000 api_lib.c
00000000 l    df *ABS*	00000000 api_msg.c
00000000 l    df *ABS*	00000000 err.c
00000000 l    df *ABS*	00000000 netbuf.c
00000000 l    df *ABS*	00000000 netdb.c
00000000 l    df *ABS*	00000000 netifapi.c
00000000 l    df *ABS*	00000000 sockets.c
00000000 l    df *ABS*	00000000 tcpip.c
00000000 l    df *ABS*	00000000 def.c
00000000 l    df *ABS*	00000000 dhcp.c
00001f80 l     F .text	00000080 dhcp_handle_nak
00003c80 l     F .text	00000058 dhcp_set_state
00003190 l     F .text	000001a0 dhcp_discover
00002000 l     F .text	00000098 dhcp_check
00002098 l     F .text	000000d0 dhcp_handle_offer
00002168 l     F .text	00000254 dhcp_select
00004cac l     F .text	000004d4 dhcp_create_msg
00003cd8 l     F .text	000000e4 dhcp_option
00003e58 l     F .text	000000d8 dhcp_option_short
00003f30 l     F .text	0000014c dhcp_option_long
00003dbc l     F .text	0000009c dhcp_option_byte
00005260 l     F .text	00000160 dhcp_option_trailer
00005180 l     F .text	000000e0 dhcp_delete_msg
00002738 l     F .text	00000078 dhcp_t2_timeout
000026c0 l     F .text	00000078 dhcp_t1_timeout
0000252c l     F .text	00000194 dhcp_timeout
00003330 l     F .text	00000280 dhcp_bind
00003700 l     F .text	00000150 dhcp_rebind
00003850 l     F .text	000001a4 dhcp_reboot
000027b0 l     F .text	000001fc dhcp_handle_ack
00004988 l     F .text	00000324 dhcp_recv
0000302c l     F .text	00000164 dhcp_decline
0000407c l     F .text	0000090c dhcp_parse_reply
000355cc l     O .rwdata	00000004 xid.3565
00000000 l    df *ABS*	00000000 dns.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 autoip.c
00000000 l    df *ABS*	00000000 icmp.c
000059f0 l     F .text	0000017c icmp_send_response
00000000 l    df *ABS*	00000000 igmp.c
00000000 l    df *ABS*	00000000 inet.c
00000000 l    df *ABS*	00000000 inet_chksum.c
00005b6c l     F .text	0000014c lwip_standard_chksum
00000000 l    df *ABS*	00000000 ip.c
00037878 l     O .bss	00000002 ip_id
00000000 l    df *ABS*	00000000 ip_addr.c
000388f0 l     O .bss	00000010 str.3022
00000000 l    df *ABS*	00000000 ip_frag.c
0003788c l     O .bss	00000004 reassdatagrams
00037890 l     O .bss	00000002 ip_reass_pbufcount
00007628 l     F .text	00000264 ip_reass_free_complete_datagram
00007abc l     F .text	00000090 ip_reass_dequeue_datagram
0000788c l     F .text	00000154 ip_reass_remove_oldest_datagram
000079e0 l     F .text	000000dc ip_reass_enqueue_new_datagram
00007b4c l     F .text	0000055c ip_reass_chain_frag_into_datagram_and_validate
00038900 l     O .bss	000005e0 buf
00000000 l    df *ABS*	00000000 mem.c
00037894 l     O .bss	00000004 ram
00037898 l     O .bss	00000004 ram_end
0003789c l     O .bss	00000004 lfree
00008864 l     F .text	000001f8 plug_holes
00000000 l    df *ABS*	00000000 memp.c
00038ee0 l     O .bss	00000024 memp_tab
0002fd80 l     O .rodata	00000012 memp_sizes
0002fd92 l     O .rodata	00000012 memp_num
00038f04 l     O .bss	0000cdcf memp_memory
00000000 l    df *ABS*	00000000 netif.c
000378a0 l     O .bss	00000001 netif_num
00000000 l    df *ABS*	00000000 pbuf.c
0000a050 l     F .text	00000024 pbuf_pool_is_empty
00000000 l    df *ABS*	00000000 raw.c
000378b0 l     O .bss	00000004 raw_pcbs
00000000 l    df *ABS*	00000000 asn1_dec.c
00000000 l    df *ABS*	00000000 asn1_enc.c
00000000 l    df *ABS*	00000000 mib2.c
00000000 l    df *ABS*	00000000 mib_structs.c
00000000 l    df *ABS*	00000000 msg_in.c
00000000 l    df *ABS*	00000000 msg_out.c
00000000 l    df *ABS*	00000000 stats.c
00000000 l    df *ABS*	00000000 sys.c
00000000 l    df *ABS*	00000000 tcp.c
000355d8 l     O .rwdata	00000002 tcp_port
000378b4 l     O .bss	00000001 tcp_timer
000378b5 l     O .bss	00000001 tcp_timer_ctr
0000bebc l     F .text	00000390 tcp_close_shutdown
0000cb30 l     F .text	000000e8 tcp_new_port
0000c6e8 l     F .text	00000030 tcp_accept_null
0000db78 l     F .text	000000d4 tcp_kill_prio
0000dc4c l     F .text	00000090 tcp_kill_timewait
000355e4 l     O .rwdata	00000004 iss.3697
00000000 l    df *ABS*	00000000 tcp_in.c
00045cd4 l     O .bss	00000010 inseg
000378d0 l     O .bss	00000004 tcphdr
000378d4 l     O .bss	00000004 iphdr
000378d8 l     O .bss	00000004 seqno
000378dc l     O .bss	00000004 ackno
000378e0 l     O .bss	00000001 flags
000378e2 l     O .bss	00000002 tcplen
000378e4 l     O .bss	00000001 recv_flags
000378e8 l     O .bss	00000004 recv_data
0000f434 l     F .text	00000138 tcp_timewait_input
0000f1a4 l     F .text	00000290 tcp_listen_input
0000f56c l     F .text	00000be8 tcp_process
00012154 l     F .text	000001f8 tcp_parseopt
00010328 l     F .text	00001e2c tcp_receive
00010154 l     F .text	000001d4 tcp_oos_insert_segment
00000000 l    df *ABS*	00000000 tcp_out.c
0001234c l     F .text	00000254 tcp_output_alloc_header
00012680 l     F .text	00000264 tcp_create_segment
000128e4 l     F .text	00000154 tcp_pbuf_prealloc
00012a38 l     F .text	000001b8 tcp_write_checks
00014298 l     F .text	000003d0 tcp_output_segment
00000000 l    df *ABS*	00000000 timers.c
00000000 l    df *ABS*	00000000 udp.c
000355e8 l     O .rwdata	00000002 udp_port
00015010 l     F .text	000000ac udp_new_port
00000000 l    df *ABS*	00000000 etharp.c
00045ce4 l     O .bss	000000c8 arp_table
000378f4 l     O .bss	00000001 etharp_cached_entry
00015e5c l     F .text	000000ec free_etharp_q
00015f48 l     F .text	00000098 etharp_free_entry
00016154 l     F .text	00000438 etharp_find_entry
0001658c l     F .text	000000c8 etharp_send_ip
00016654 l     F .text	00000224 etharp_update_arp_entry
00016a0c l     F .text	000000c8 etharp_ip_input
00016ad4 l     F .text	000003a4 etharp_arp_input
00016e78 l     F .text	00000158 etharp_output_to_arp_index
0001779c l     F .text	00000270 etharp_raw
00000000 l    df *ABS*	00000000 ethernetif.c
00000000 l    df *ABS*	00000000 auth.c
00000000 l    df *ABS*	00000000 chap.c
00000000 l    df *ABS*	00000000 chpms.c
00000000 l    df *ABS*	00000000 fsm.c
00000000 l    df *ABS*	00000000 ipcp.c
00000000 l    df *ABS*	00000000 lcp.c
00000000 l    df *ABS*	00000000 magic.c
00000000 l    df *ABS*	00000000 md5.c
00000000 l    df *ABS*	00000000 pap.c
00000000 l    df *ABS*	00000000 ppp.c
00000000 l    df *ABS*	00000000 ppp_oe.c
00000000 l    df *ABS*	00000000 randm.c
00000000 l    df *ABS*	00000000 vj.c
00000000 l    df *ABS*	00000000 slipif.c
00000000 l    df *ABS*	00000000 main.c
00045dac l     O .bss	00000018 lwipAlarm
000378f8 l     O .bss	00000004 lwipProcessTimerFlag
000378fc l     O .bss	00000004 lwipTicksPer250mS
00037900 l     O .bss	00000004 lwip250mStimer
00037904 l     O .bss	00000004 ip_zero.3932
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fp-bit.c
000180f4 l     F .text	00000354 _fpadd_parts
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 impure.c
0003366c l     O .rwdata	00000400 impure_data
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 vfprintf.c
0001989c l     F .text	00000034 __sprint_r
00031382 l     O .rodata	00000010 blanks.3515
00031392 l     O .rodata	00000010 zeroes.3516
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 dtoa.c
0001b9b8 l     F .text	00000208 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
0001d3f4 l     F .text	00000008 __fp_lock
0001d3fc l     F .text	00000008 __fp_unlock
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 locale.c
000313c4 l     O .rodata	00000030 lconv
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
0003150c l     O .rodata	0000000c p05.2435
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 s_isinfd.c
00000000 l    df *ABS*	00000000 s_isnand.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00021710 l     F .text	00000074 udivmodsi4
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_close.c
000219ac l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dev.c
00021ac4 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
00021af0 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_isatty.c
00021bec l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_load.c
00021cdc l     F .text	0000006c alt_load_section
00000000 l    df *ABS*	00000000 alt_lseek.c
00021dc8 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_read.c
00021fa0 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_remap_uncached.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
00035624 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_uncached_malloc.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
000224d8 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
00022614 l     F .text	00000038 alt_dev_reg
00034028 l     O .rwdata	0000009c vic_0
000340c4 l     O .rwdata	000000d8 ext_flash
0003419c l     O .rwdata	00001060 jtag_uart
000351fc l     O .rwdata	00000120 lcd
0003531c l     O .rwdata	00000030 sgdma_rx
0003534c l     O .rwdata	00000030 sgdma_tx
0003537c l     O .rwdata	000000c4 rs232
00035440 l     O .rwdata	000000c4 uart_0
00035504 l     O .rwdata	000000c4 uart_1
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash.c
000227c4 l     F .text	00000038 alt_flash_device_register
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_table.c
000235fc l     F .text	00000080 alt_read_16bit_query_entry
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
000246ac l     F .text	00000204 altera_avalon_jtag_uart_irq
000248b0 l     F .text	000000a4 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207.c
00035630 l     O .rwdata	00000004 colstart
00024f44 l     F .text	000000b4 lcd_write_command
00024ff8 l     F .text	000000d0 lcd_write_data
000250c8 l     F .text	000000cc lcd_clear_screen
00025194 l     F .text	000001ec lcd_repaint_screen
00025380 l     F .text	000000cc lcd_scroll_up
0002544c l     F .text	000002bc lcd_handle_escape
00025bec l     F .text	000000ac alt_lcd_16207_timeout
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_sgdma.c
00025e30 l     F .text	00000050 alt_get_errno
000269d4 l     F .text	000000e4 alt_avalon_sgdma_irq
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
00026b5c l     F .text	000000a0 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_timer_ts.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_vars.c
00000000 l    df *ABS*	00000000 altera_avalon_tse.c
00037947 l     O .bss	00000001 tse_system_count.3776
00037946 l     O .bss	00000001 is_init.3858
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
0002bf24 l     F .text	00000098 altera_avalon_uart_irq
0002bfbc l     F .text	000000d8 altera_avalon_uart_rxirq
0002c094 l     F .text	0000013c altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
0002c224 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
0002c4d0 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 altera_vic_irq_init.c
00033188 l     O .rodata	00000020 VEC_SIZE_ARRAY.1688
00000000 l    df *ABS*	00000000 altera_vic_isr_register.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0002cd34 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
0002d054 l     F .text	000000c0 alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
0002d18c l     F .text	00000050 alt_get_errno
0002d1dc l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_amd.c
0002d790 l     F .text	000000cc alt_write_word_amd
0002d674 l     F .text	0000011c alt_wait_for_command_to_complete_amd
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_intel.c
0002da44 l     F .text	0000017c alt_unlock_block_intel
0002dbc0 l     F .text	000000d4 alt_write_word_intel
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 ctype_.c
000332a9 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
00000000 l    df *ABS*	00000000 
0003787c g     O .bss	00000004 current_iphdr_src
00006110 g     F .text	00000044 inet_chksum
0000ba84 g     F .text	00000048 raw_bind
0001fb78 g     F .text	00000074 _mprec_log10
000080a8 g     F .text	000004b8 ip_reass
0002802c g     F .text	000000d8 alt_tse_get_mac_info
0000a5b8 g     F .text	00000284 pbuf_realloc
0001fc68 g     F .text	00000084 __any_on
00020834 g     F .text	00000064 _isatty_r
000313f4 g     O .rodata	00000028 __mprec_tinytens
00021ee8 g     F .text	00000078 alt_main
0002df5c g     F .text	00000094 strcpy
0000e39c g     F .text	00000030 tcp_next_iss
00019130 g     F .text	00000044 __ashldi3
000195d8 g     F .text	00000084 _puts_r
000230d4 g     F .text	00000040 alt_read_query_entry_32bit
00009fd8 g     F .text	00000078 pbuf_free_ooseq
0000c8f0 g     F .text	00000128 tcp_update_rcv_ann_wnd
00020898 g     F .text	0000006c _lseek_r
000378a4 g     O .bss	00000004 netif_list
0002288c g     F .text	000002ac alt_flash_cfi_write
00002a7c g     F .text	00000078 dhcp_cleanup
0002f020 g     O .rodata	00000010 file_index_html
0003564c g       *ABS*	00000000 __flash_rwdata_start
0002bc04 g     F .text	000000f0 marvell_cfg_rgmii
000214c4 g     F .text	0000005c __eqdf2
00014668 g     F .text	00000250 tcp_rst
0000b7e0 g     F .text	000000c8 pbuf_memfind
00029214 g     F .text	00000210 alt_tse_phy_print_profile
00081218 g       *ABS*	00000000 __alt_heap_start
0002b9a4 g     F .text	00000098 marvell_phy_cfg
00017a0c g     F .text	00000074 etharp_request
000193f0 g     F .text	0000003c printf
00002af4 g     F .text	00000248 dhcp_start
00025fa4 g     F .text	00000110 alt_avalon_sgdma_do_sync_transfer
0000dffc g     F .text	0000006c tcp_err
000355d0 g     O .rwdata	00000004 ip_addr_any
00005cb8 g     F .text	000001f8 inet_chksum_pseudo
00002ee8 g     F .text	000000a8 dhcp_network_changed
05000000 g       *ABS*	00000000 __alt_mem_sram
0002048c g     F .text	0000005c __sseek
0001d484 g     F .text	0000010c __sinit
00015d68 g     F .text	0000009c udp_remove
0001b6ec g     F .text	0000013c __swbuf_r
00006854 g     F .text	00000468 ip_output_if
0001e11c g     F .text	0000009c _setlocale_r
0001d410 g     F .text	00000064 __sfmoreglue
000097d4 g     F .text	000000f8 memp_free
00021f80 g     F .text	00000020 __malloc_unlock
0000aa34 g     F .text	000001cc pbuf_free
0000df24 g     F .text	0000006c tcp_recv
00028270 g     F .text	00000a74 getPHYSpeed
0000ac8c g     F .text	00000140 pbuf_cat
00081014 g     O .bss	00000034 alteraTseNetif
00026690 g     F .text	00000344 alt_avalon_sgdma_construct_descriptor_burst
00037940 g     O .bss	00000004 altera_avalon_timer_ts_freq
0001ec1c g     F .text	00000128 memmove
00006cbc g     F .text	000000ec ip_output
00016878 g     F .text	000000a0 etharp_cleanup_netif
000156f4 g     F .text	00000094 udp_sendto
0001d474 g     F .text	00000010 _cleanup
0001ed44 g     F .text	000000a8 _Balloc
00006f38 g     F .text	00000044 ipaddr_addr
00014c78 g     F .text	00000144 tcp_keepalive
00015fe0 g     F .text	00000174 etharp_tmr
0002ac18 g     F .text	000001bc alt_tse_phy_set_adv_1000
0003563c g     O .rwdata	00000001 max_mac_system
0000dcdc g     F .text	000001ec tcp_alloc
000272e4 g     F .text	000009fc alt_tse_system_add_sys
0002157c g     F .text	00000064 __gtdf2
00000000  w      *UND*	00000000 __errno
00015788 g     F .text	000002ec udp_sendto_if
00023260 g     F .text	0000004c alt_write_flash_command_32bit_device_16bit_mode
05000000 g     F .entry	0000001c __reset
0000def4 g     F .text	00000030 tcp_arg
0000196c g     F .text	000000d0 udpecho_recv
000378b6 g     O .bss	00000001 tcp_active_pcbs_changed
000378b8 g     O .bss	00000004 tcp_active_pcbs
00026200 g     F .text	00000074 alt_avalon_sgdma_construct_stream_to_mem_desc_burst
00000020 g       *ABS*	00000000 __flash_exceptions_start
000207cc g     F .text	00000068 _fstat_r
000378f0 g     O .bss	00000004 udp_pcbs
0003342c g     O .rwdata	00000240 tse_mac_device
00022d80 g     F .text	000002d8 alt_flash_program_block
00037924 g     O .bss	00000004 errno
00017a80 g     F .text	000002b0 ethernet_input
0000c2a8 g     F .text	000000f0 tcp_shutdown
0002b4ec g     F .text	000004b8 alt_tse_phy_set_common_speed
0000ac4c g     F .text	00000040 pbuf_ref
00081048 g     O .bss	00000020 pmac_groups
00009d74 g     F .text	00000044 netif_set_netmask
0003792c g     O .bss	00000004 alt_argv
0003d5c8 g       *ABS*	00000000 _gp
0000dafc g     F .text	0000007c tcp_recv_null
000224a8 g     F .text	00000030 usleep
00037880 g     O .bss	00000004 current_netif
00013510 g     F .text	0000041c tcp_enqueue_flags
0000c24c g     F .text	0000005c tcp_close
0000ca18 g     F .text	00000118 tcp_recved
00022450 g     F .text	00000058 alt_uncached_malloc
0000e118 g     F .text	000000dc tcp_pcb_purge
00026df0 g     F .text	00000060 tse_mac_initTransInfo2
00033ea8 g     O .rwdata	00000180 alt_fd_list
000073a0 g     F .text	0000003c ipaddr_ntoa
000355da g     O .rwdata	00000007 tcp_persist_backoff
0002c720 g       .text	00000000 VIC_0_VECTOR_TABLE
0002cedc g     F .text	00000090 alt_find_dev
000191f0 g     F .text	000000f8 memcpy
00008afc g     F .text	00000180 mem_free
0002705c g     F .text	00000054 tse_mac_setMIImode
000378bc g     O .bss	00000004 tcp_ticks
000378c0 g     O .bss	00000004 tcp_listen_pcbs
00028ce4 g     F .text	00000048 alt_tse_phy_rd_mdio_addr
000148b8 g     F .text	000000b4 tcp_rexmit_rto
0001d404 g     F .text	0000000c _cleanup_r
0002163c g     F .text	000000d4 __floatsidf
00026e50 g     F .text	000000e0 tse_mac_sTxWrite
0002d114 g     F .text	00000078 alt_io_redirect
0000dec8 g     F .text	0000002c tcp_new
000215e0 g     F .text	0000005c __ltdf2
00015cdc g     F .text	0000004c udp_disconnect
0000b204 g     F .text	0000019c pbuf_copy_partial
0002e2fc g       *ABS*	00000000 __DTOR_END__
0001965c g     F .text	00000014 puts
000039f4 g     F .text	000001a8 dhcp_release
0001fad4 g     F .text	000000a4 __ratio
000303f4 g     O .rodata	0000002c tcp_state_str
0000bcdc g     F .text	00000044 raw_send
00006154 g     F .text	0000010c inet_chksum_pbuf
0000b3a0 g     F .text	000001b8 pbuf_take
000262f0 g     F .text	00000088 alt_avalon_sgdma_construct_mem_to_stream_desc_burst
00024ab0 g     F .text	00000244 altera_avalon_jtag_uart_read
0002df34 g     F .text	00000014 malloc
000193c4 g     F .text	0000002c _printf_r
00037884 g     O .bss	00000004 current_iphdr_dest
00021830 g     F .text	00000008 __udivsi3
00045dec g     O .bss	00000100 tse
00021c3c g     F .text	000000a0 isatty
00027ce0 g     F .text	00000164 alt_tse_sys_enable_mdio_sharing
000053fc g     F .text	0000056c icmp_input
00031444 g     O .rodata	000000c8 __mprec_tens
00027fac g     F .text	00000080 alt_tse_get_mac_info_index
00045eec g     O .bss	0003a980 histcb_table
000098e8 g     F .text	00000104 netif_add
0001e1b8 g     F .text	0000000c __locale_charset
00018070 g     F .text	00000084 __fixunsdfsi
0000d9b8 g     F .text	00000050 tcp_segs_free
0002de5c g     F .text	0000008c alt_icache_flush
00037920 g     O .bss	00000004 __malloc_top_pad
00000590 g     F .text	00000094 fs_open
00035600 g     O .rwdata	00000004 __mb_cur_max
0001e1c4 g     F .text	0000000c _localeconv_r
00009bfc g     F .text	00000134 netif_set_ipaddr
0001f144 g     F .text	0000003c __i2b
0001dad8 g     F .text	000004e4 __sfvwrite_r
0002641c g     F .text	00000058 alt_avalon_sgdma_stop
00028d84 g     F .text	0000012c alt_tse_phy_wr_mdio_reg
0002034c g     F .text	00000064 _sbrk_r
0002d85c g     F .text	00000080 alt_program_intel
00029424 g     F .text	0000069c alt_tse_mac_group_init
00001b14 g     F .text	000000d8 init_hist
00012bf0 g     F .text	00000920 tcp_write
00000ca4 g     F .text	00000868 tse_mac_init
00016918 g     F .text	000000f4 etharp_find_addr
00020904 g     F .text	0000006c _read_r
0002ccf4 g     F .text	00000024 alt_dcache_flush
00001ae0 g     F .text	00000034 get_utm
00033a6c g     O .rwdata	0000000c __lc_ctype
0003561c g     O .rwdata	00000004 alt_max_fd
00023058 g     F .text	0000003c alt_read_query_entry_8bit
00018f18 g     F .text	00000104 __unpack_d
0002067c g     F .text	0000013c _fclose_r
0002d8dc g     F .text	00000168 alt_erase_block_intel
0000c55c g     F .text	0000018c tcp_bind
0001d3c4 g     F .text	00000030 fflush
0003791c g     O .bss	00000004 __malloc_max_sbrked_mem
000059ac g     F .text	00000044 icmp_time_exceeded
0000c528 g     F .text	00000034 tcp_abort
00001a3c g     F .text	000000a4 udpecho_init
00008560 g     F .text	00000304 ip_frag
00018448 g     F .text	00000054 __adddf3
0002f000 g     O .rodata	00000010 file_img_sics_gif
0001f848 g     F .text	00000148 __b2d
00020f38 g     F .text	0000058c __umoddi3
00021e18 g     F .text	000000d0 lseek
0000bb54 g     F .text	00000188 raw_sendto
00028f7c g     F .text	00000298 alt_tse_phy_add_profile_default
0002a680 g     F .text	00000598 alt_tse_phy_get_cap
000355f8 g     O .rwdata	00000004 _global_impure_ptr
0001fcec g     F .text	000005fc _realloc_r
00081218 g       *ABS*	00000000 __bss_end
00025e80 g     F .text	00000124 alt_avalon_sgdma_do_async_transfer
0002234c g     F .text	00000104 alt_tick
00020970 g     F .text	000005c8 __udivdi3
00003b9c g     F .text	000000e4 dhcp_stop
0002a520 g     F .text	00000160 alt_tse_phy_check_link
0003141c g     O .rodata	00000028 __mprec_bigtens
0001ef28 g     F .text	00000104 __s2b
00018acc g     F .text	0000011c __floatunsidf
0002bb20 g     F .text	000000e4 marvell_cfg_sgmii
0000af38 g     F .text	000002cc pbuf_copy
0002a35c g     F .text	000001c4 alt_tse_phy_restart_an
0001f5e8 g     F .text	00000058 __mcmp
0001496c g     F .text	000001e8 tcp_rexmit
0002be7c g     F .text	000000a8 altera_avalon_uart_init
00035648 g     O .rwdata	00000004 __ctype_ptr
0001d69c g     F .text	00000018 __fp_lock_all
00081068 g     O .bss	00000020 pphy_profiles
00009de0 g     F .text	00000090 netif_set_up
00022288 g     F .text	000000c4 alt_alarm_stop
02001000 g       *ABS*	00000000 __alt_mem_descriptor_memory
00030430 g     O .rodata	00000010 tcp_pcb_lists
00033e80 g     O .rwdata	00000028 alt_dev_null
00006e74 g     F .text	000000c4 ip4_addr_netmask_valid
000378c4 g     O .bss	00000004 tcp_tmp_pcb
0002a244 g     F .text	00000118 alt_tse_phy_init
00017d30 g     F .text	0000002c lwipAlarmCallback
00023560 g     F .text	0000009c alt_set_flash_algorithm_func
00026474 g     F .text	00000064 alt_avalon_sgdma_check_descriptor_status
0002cd18 g     F .text	0000001c alt_dcache_flush_all
0001f02c g     F .text	00000068 __hi0bits
000189f8 g     F .text	000000d4 __fixdfsi
00001658 g     F .text	00000170 tse_mac_raw_send
00008a5c g     F .text	000000a0 mem_init
0002c920 g       .text	00000000 alt_shadow_non_preemptive_interrupt
00023114 g     F .text	00000044 alt_write_flash_command_8bit_device_8bit_mode
000125a0 g     F .text	000000e0 tcp_send_fin
0003564c g       *ABS*	00000000 __ram_rwdata_end
00013a74 g     F .text	00000824 tcp_output
00035614 g     O .rwdata	00000008 alt_dev_list
00022528 g     F .text	000000ec write
00008c7c g     F .text	00000350 mem_trim
000265b0 g     F .text	00000080 alt_avalon_sgdma_enable_desc_poll
0001942c g     F .text	000000bc _putc_r
00026d9c g     F .text	00000028 alt_timestamp_freq
0003342c g       *ABS*	00000000 __ram_rodata_end
00021b40 g     F .text	000000ac fstat
000190ec g     F .text	00000044 __lshrdi3
000378ec g     O .bss	00000004 tcp_input_pcb
0000b94c g     F .text	00000138 raw_input
0002bcf4 g     F .text	00000078 DP83848C_link_status_read
0001392c g     F .text	00000148 tcp_send_empty_ack
000243b4 g     F .text	000000d4 alt_check_primary_table
00014b54 g     F .text	00000124 tcp_rexmit_fast
0001f360 g     F .text	0000012c __pow5mult
00037914 g     O .bss	00000004 __nlocale_changed
00021838 g     F .text	00000008 __umodsi3
00022bc4 g     F .text	00000064 alt_flash_cfi_read
000232f8 g     F .text	00000038 alt_write_native_8bit
00006f7c g     F .text	00000424 ipaddr_aton
00006da8 g     F .text	000000cc ip4_addr_isbroadcast
00009db8 g     F .text	00000028 netif_set_default
00015d28 g     F .text	00000040 udp_recv
00026274 g     F .text	0000007c alt_avalon_sgdma_construct_mem_to_stream_desc
00026378 g     F .text	00000050 alt_avalon_sgdma_register_callback
00081218 g       *ABS*	00000000 end
00023158 g     F .text	00000074 alt_write_flash_command_16bit_device_8bit_mode
00025708 g     F .text	000004e4 altera_avalon_lcd_16207_write
00000c38 g     F .text	0000006c httpd_init
00009e70 g     F .text	00000074 netif_set_down
0000a074 g     F .text	00000544 pbuf_alloc
00009ee4 g     F .text	000000a4 netif_set_link_up
0002c520 g     F .text	00000200 altera_avalon_uart_write
00027100 g     F .text	000001e4 alt_tse_phy_add_profile
0002367c g     F .text	000005c8 alt_read_cfi_table
000245ec g     F .text	000000c0 altera_avalon_jtag_uart_init
0002e2fc g       *ABS*	00000000 __CTOR_LIST__
02000000 g       *ABS*	00000000 __alt_stack_pointer
00026630 g     F .text	00000060 alt_avalon_sgdma_disable_desc_poll
00026bfc g     F .text	00000088 alt_avalon_timer_sc_init
0002bdcc g     F .text	00000060 altera_avalon_uart_write_fd
00018c48 g     F .text	000000ac __clzsi2
0002be2c g     F .text	00000050 altera_avalon_uart_close_fd
00024cf4 g     F .text	00000250 altera_avalon_jtag_uart_write
000260b4 g     F .text	00000070 alt_avalon_sgdma_construct_mem_to_mem_desc
000227fc g     F .text	00000090 alt_flash_cfi_init
0001d68c g     F .text	00000004 __sfp_lock_acquire
0001eb24 g     F .text	000000f8 memchr
000355d4 g     O .rwdata	00000004 ip_addr_broadcast
000198d0 g     F .text	00001df8 ___vfprintf_internal_r
0000758c g     F .text	0000009c ip_reass_tmr
000261a4 g     F .text	0000005c alt_avalon_sgdma_construct_stream_to_mem_desc
0002f010 g     O .rodata	00000010 file_404_html
0001d808 g     F .text	000002d0 _free_r
00015bd4 g     F .text	00000108 udp_connect
0002e120 g     F .text	000001a0 __call_exitprocs
00001e30 g     F .text	00000150 print_hist
00037888 g     O .bss	00000004 current_header
000015c4 g     F .text	00000094 tse_sgdmaRx_isr
00017fac g     F .text	000000c4 lwipProcessTimers
00037910 g     O .bss	00000004 __mlocale_changed
000017c8 g     F .text	000001a4 tse_mac_rcv
000099ec g     F .text	00000058 netif_set_addr
00002f90 g     F .text	0000009c dhcp_arp_reply
00035604 g     O .rwdata	00000004 __malloc_sbrk_base
00000020 g     F .text	0000007c _start
00037934 g     O .bss	00000004 _alt_tick_rate
0000b8a8 g     F .text	000000a4 pbuf_strstr
000264d8 g     F .text	00000050 alt_avalon_sgdma_open
000095f8 g     F .text	000001dc memp_malloc
0001f48c g     F .text	0000015c __lshift
00014dbc g     F .text	0000021c tcp_zero_window_probe
00037938 g     O .bss	00000004 _alt_nticks
00028eb0 g     F .text	000000cc alt_tse_phy_rd_mdio_reg
00021ff0 g     F .text	000000f0 read
0002268c g     F .text	00000138 alt_sys_init
00002470 g     F .text	000000bc dhcp_fine_tmr
0008086c g     O .bss	0000000a dhcp_rx_options_given
0002dff0 g     F .text	00000130 __register_exitproc
00037944 g     O .bss	00000001 phy_profile_count
000197a0 g     F .text	000000fc strncmp
00027f38 g     F .text	00000074 alt_tse_get_mac_group_index
00023094 g     F .text	00000040 alt_read_query_entry_16bit
00022140 g     F .text	00000040 alt_remap_uncached
000073dc g     F .text	000001b0 ipaddr_ntoa_r
0001f180 g     F .text	000001e0 __multiply
00024954 g     F .text	00000068 altera_avalon_jtag_uart_close
0003342c g       *ABS*	00000000 __ram_rwdata_start
0002e2fc g       *ABS*	00000000 __ram_rodata_start
00045dc4 g     O .bss	00000028 __malloc_current_mallinfo
000378c8 g     O .bss	00000004 tcp_bound_pcbs
0002339c g     F .text	000001c4 alt_set_flash_width_func
0001f990 g     F .text	00000144 __d2b
0000da08 g     F .text	00000058 tcp_seg_free
0000b6c0 g     F .text	00000120 pbuf_memcmp
00028d2c g     F .text	00000058 alt_tse_phy_wr_mdio_addr
00024488 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
0002dda8 g     F .text	000000b4 alt_get_fd
0002cbcc g     F .text	00000128 alt_busy_sleep
0001901c g     F .text	000000d0 __fpcmp_parts_d
0000be58 g     F .text	0000001c tcp_init
0000cc18 g     F .text	000002ac tcp_connect
00005eb0 g     F .text	00000260 inet_chksum_pseudo_partial
00020618 g     F .text	00000064 _close_r
00008fcc g     F .text	000003f8 mem_malloc
0002b1c4 g     F .text	00000328 alt_tse_phy_get_common_speed
0002d464 g     F .text	00000210 alt_erase_block_amd
00019174 g     F .text	0000007c memcmp
00024548 g     F .text	00000050 altera_avalon_jtag_uart_close_fd
00081218 g       *ABS*	00000000 __alt_stack_base
00024598 g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
00037945 g     O .bss	00000001 mac_group_count
00009f88 g     F .text	00000050 netif_set_link_down
000035b0 g     F .text	00000150 dhcp_renew
0001b844 g     F .text	00000174 __swsetup_r
00023c44 g     F .text	00000770 alt_read_cfi_width
0000150c g     F .text	000000b8 tse_sgdma_read_init
000187e0 g     F .text	000001b4 __divdf3
0001d590 g     F .text	000000fc __sfp
0001fbec g     F .text	0000007c __copybits
0000e3cc g     F .text	00000084 tcp_eff_send_mss
00033a78 g     O .rwdata	00000408 __malloc_av_
0001d698 g     F .text	00000004 __sinit_lock_release
000184fc g     F .text	000002e4 __muldf3
000203b0 g     F .text	00000054 __sread
00029ac0 g     F .text	0000041c alt_tse_mac_get_phy
0002dc94 g     F .text	00000114 alt_find_file
0002cd84 g     F .text	000000a0 alt_dev_llist_insert
00021f60 g     F .text	00000020 __malloc_lock
00022180 g     F .text	00000108 sbrk
000263c8 g     F .text	00000054 alt_avalon_sgdma_start
00002d3c g     F .text	000001ac dhcp_inform
0001d1dc g     F .text	000001e8 _fflush_r
000281e4 g     F .text	0000008c alt_tse_mac_set_duplex
0002055c g     F .text	000000bc _calloc_r
0000bacc g     F .text	00000048 raw_connect
00035640 g     O .rwdata	00000008 alt_flash_dev_list
00023218 g     F .text	00000048 alt_write_flash_command_16bit_device_16bit_mode
0003786c g       *ABS*	00000000 __bss_start
000192e8 g     F .text	000000dc memset
00017d5c g     F .text	00000250 main
00037930 g     O .bss	00000004 alt_envp
00037918 g     O .bss	00000004 __malloc_max_total_mem
000244e8 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
0001b828 g     F .text	0000001c __swbuf
00005968 g     F .text	00000044 icmp_dest_unreach
00025c98 g     F .text	00000138 altera_avalon_lcd_16207_init
00035634 g     O .rwdata	00000008 alt_sgdma_list
0000df90 g     F .text	0000006c tcp_sent
000204e8 g     F .text	00000008 __sclose
0000b610 g     F .text	000000b0 pbuf_get_at
02000000 g       *ABS*	00000000 __alt_heap_limit
000207b8 g     F .text	00000014 fclose
00037870 g     O .bss	00000004 printed_flg
00026c84 g     F .text	00000088 alt_timestamp_start
00081088 g     O .bss	00000190 _atexit0
0001bbc0 g     F .text	0000161c _dtoa_r
0001e3a0 g     F .text	00000784 _malloc_r
0000bdbc g     F .text	00000080 raw_new
00026fd4 g     F .text	00000088 tse_mac_SwReset
00000334 g     F .text	000000e4 ethernetif_input
00035620 g     O .rwdata	00000004 alt_errno
000232ac g     F .text	0000004c alt_write_flash_command_32bit_device_32bit_mode
0001dfbc g     F .text	000000a8 _fwalk
00022c28 g     F .text	00000158 alt_write_value_to_flash
00023330 g     F .text	00000038 alt_write_native_16bit
000194e8 g     F .text	000000f0 putc
00021784 g     F .text	00000050 __divsi3
00027e84 g     F .text	00000048 alt_tse_mac_set_common_speed
0000bd20 g     F .text	0000009c raw_remove
00031224 g     O .rodata	00000014 __thenan_df
0001d6cc g     F .text	0000013c _malloc_trim_r
0002e2fc g       *ABS*	00000000 __CTOR_END__
000378ac g     O .bss	00000001 pbuf_free_ooseq_pending
00015a74 g     F .text	00000160 udp_bind
00037948 g     O .bss	00000004 alt_vic_dev_list
0000be74 g     F .text	00000048 tcp_tmr
00017310 g     F .text	0000048c etharp_query
00019670 g     F .text	000000a4 strcmp
000053c0 g     F .text	0000003c lwip_init
0002e2fc g       *ABS*	00000000 __flash_rodata_start
0002e2fc g       *ABS*	00000000 __DTOR_LIST__
00016fd0 g     F .text	00000340 etharp_output
0003786c g     O .bss	00000004 measuring_flg
00021520 g     F .text	0000005c __nedf2
0002264c g     F .text	00000040 alt_irq_init
00027e44 g     F .text	00000040 alt_tse_mac_get_common_speed
000220e0 g     F .text	00000060 alt_release_fd
00009d30 g     F .text	00000044 netif_set_gw
00031238 g     O .rodata	00000100 __clz_tab
0000ac00 g     F .text	0000004c pbuf_clen
0003790c g     O .bss	00000004 _PathLocale
0002dee8 g     F .text	00000014 atexit
000204f0 g     F .text	0000006c _write_r
0000da60 g     F .text	00000034 tcp_setprio
000156a0 g     F .text	00000054 udp_send
0001e1d0 g     F .text	0000001c setlocale
0000b558 g     F .text	000000b8 pbuf_coalesce
0000bb14 g     F .text	00000040 raw_recv
00009a44 g     F .text	000000d8 netif_remove
000355fc g     O .rwdata	00000004 _impure_ptr
00037928 g     O .bss	00000004 alt_argc
0000cec4 g     F .text	000008ac tcp_slowtmr
0003793c g     O .bss	00000004 altera_avalon_timer_ts_base
0002ce80 g     F .text	0000005c _do_dtors
0002c938 g     F .text	0000013c alt_vic_irq_init
0001f7e8 g     F .text	00000060 __ulp
000202e8 g     F .text	00000038 __isinfd
0000e068 g     F .text	00000030 tcp_accept
0001d6b4 g     F .text	00000018 __fp_unlock_all
00025dd0 g     F .text	00000060 altera_avalon_lcd_16207_write_fd
00000418 g     F .text	00000178 ethernetif_init
0003560c g     O .rwdata	00000008 alt_fs_list
000231cc g     F .text	0000004c alt_write_flash_command_32bit_device_8bit_mode
00000020 g       *ABS*	00000000 __ram_exceptions_start
0001e1ec g     F .text	0000000c localeconv
00026d0c g     F .text	00000090 alt_timestamp
0a000000 g       *ABS*	00000000 __alt_mem_onchip_memory2
000355c8 g     O .rwdata	00000004 histid
000378cc g     O .bss	00000004 tcp_tw_pcbs
0002b01c g     F .text	000001a8 alt_tse_phy_set_adv_10
0002ca74 g     F .text	00000158 alt_ic_isr_register
000150bc g     F .text	000005e4 udp_input
0003564c g       *ABS*	00000000 _edata
0002bd6c g     F .text	00000060 altera_avalon_uart_read_fd
00081218 g       *ABS*	00000000 _end
0002cf6c g     F .text	00000068 alt_flash_open_dev
00029edc g     F .text	00000240 alt_tse_mac_associate_phy
000098cc g     F .text	0000001c netif_init
00001bec g     F .text	000000ac begin_measure
00000020 g       *ABS*	00000000 __ram_exceptions_end
000249bc g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
00006260 g     F .text	000000e8 ip_route
0003794c g     O .bss	00000fa4 histarea
0000c718 g     F .text	000001d8 tcp_listen_with_backlog
00080ef4 g     O .bss	0000011e lwip_stats
0000a83c g     F .text	000001f8 pbuf_header
000378a8 g     O .bss	00000004 netif_default
0000e1f4 g     F .text	000001a8 tcp_pcb_remove
00037908 g     O .bss	00000004 lwipStaticIp
00026528 g     F .text	00000088 alt_avalon_sgdma_construct_descriptor
00020404 g     F .text	00000088 __swrite
00035608 g     O .rwdata	00000004 __malloc_trim_threshold
0000adcc g     F .text	00000040 pbuf_chain
0002defc g     F .text	00000038 exit
0000c398 g     F .text	00000190 tcp_abandon
0000e450 g     F .text	0000003c tcp_debug_state_str
00014fd8 g     F .text	0000001c tcp_timer_needed
0001e064 g     F .text	000000b8 _fwalk_reent
0000943c g     F .text	000001bc memp_init
000029ac g     F .text	000000d0 dhcp_set_struct
0001f640 g     F .text	000001a8 __mdiff
000093c4 g     F .text	00000078 mem_calloc
0000d770 g     F .text	000000f8 tcp_fasttmr
0002cfd4 g     F .text	00000050 alt_flash_close_dev
000217d4 g     F .text	0000005c __modsi3
0000d868 g     F .text	00000150 tcp_process_refused_data
000270b0 g     F .text	00000050 tse_mac_setGMIImode
0002ba3c g     F .text	000000e4 marvell_cfg_gmii
02000000 g       *ABS*	00000000 __alt_data_end
0001d690 g     F .text	00000004 __sfp_lock_release
00000000 g       *ABS*	00000000 __alt_mem_sdram
0002a11c g     F .text	00000128 alt_tse_phy_cfg_pcs
00080878 g     O .bss	00000028 dhcp_rx_options_val
000331a8 g     O .rodata	00000101 _ctype_
04000000 g       *ABS*	00000000 __alt_mem_ext_flash
0002c1d0 g     F .text	00000054 altera_avalon_uart_close
0002e2c0 g     F .text	0000003c _exit
00020320 g     F .text	0000002c __isnand
000023bc g     F .text	000000b4 dhcp_coarse_tmr
00021840 g     F .text	0000016c alt_alarm_start
0000da94 g     F .text	00000068 tcp_seg_copy
00018be8 g     F .text	00000060 __muldi3
0001e1f8 g     F .text	000001a8 __smakebuf_r
00023368 g     F .text	00000034 alt_write_native_32bit
0000e098 g     F .text	00000080 tcp_poll
00019714 g     F .text	0000008c strlen
0002d2a8 g     F .text	00000154 open
00014ff4 g     F .text	0000001c udp_init
000808a0 g     O .bss	00000654 ram_heap
00018994 g     F .text	00000064 __gedf2
00015e04 g     F .text	00000058 udp_new
00022b38 g     F .text	0000008c alt_flash_cfi_get_info
0002d024 g     F .text	00000030 alt_icache_flush_all
00026f30 g     F .text	000000a4 tse_mac_aRxRead
000355ea g     O .rwdata	00000006 ethbroadcast
00030420 g     O .rodata	0000000d tcp_backoff
0001b6c8 g     F .text	00000024 __vfprintf_internal
0002c274 g     F .text	0000025c altera_avalon_uart_read
00037874 g     O .bss	00000004 timestamp_freq
00028104 g     F .text	000000e0 alt_tse_mac_set_speed
00026124 g     F .text	00000080 alt_avalon_sgdma_construct_mem_to_mem_desc_burst
0001849c g     F .text	00000060 __subdf3
0001f094 g     F .text	000000b0 __lo0bits
00035628 g     O .rwdata	00000008 alt_alarm_list
0002ce24 g     F .text	0000005c _do_ctors
0002add4 g     F .text	00000248 alt_tse_phy_set_adv_100
0000e48c g     F .text	00000d18 tcp_input
000219fc g     F .text	000000c8 close
0002d3fc g     F .text	00000068 alt_program_amd
00006348 g     F .text	0000050c ip_input
00021d48 g     F .text	00000080 alt_load
000355f0 g     O .rwdata	00000006 ethzero
00018cf4 g     F .text	00000224 __pack_d
0000be3c g     F .text	0000001c stats_init
00027ecc g     F .text	0000006c alt_tse_get_system_index
00026ab8 g     F .text	000000a4 alt_avalon_sgdma_init
0002df48 g     F .text	00000014 free
00009b1c g     F .text	000000e0 netif_find
0001d694 g     F .text	00000004 __sinit_lock_acquire
0001ee14 g     F .text	00000114 __multadd
0001edec g     F .text	00000028 _Bfree
00026dc4 g     F .text	0000002c no_printf
00001c98 g     F .text	00000198 end_measure
0000ae0c g     F .text	0000012c pbuf_dechain



Disassembly of section .entry:

05000000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && !defined(ALT_SIM_OPTIMIZE)
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
 5000000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
 5000004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
 5000008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
 500000c:	00bffd16 	blt	zero,r2,5000004 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 5000010:	00400034 	movhi	at,0
    ori r1, r1, %lo(_start)
 5000014:	08400814 	ori	at,at,32
    jmp r1
 5000018:	0800683a 	jmp	at
 500001c:	00000000 	call	0 <__alt_mem_sdram>

Disassembly of section .text:

00000020 <_start>:
     * writing zero to SSTATUS register and executing an ERET instruction
     * to set STATUS.CRS to 0.
     */
    
    /* Get the current register set number (STATUS.CRS). */
    rdctl r2, status
      20:	0005303a 	rdctl	r2,status
    andi r2, r2, NIOS2_STATUS_CRS_MSK
      24:	10bf000c 	andi	r2,r2,64512
    
    /* Skip switching register set if STATUS.CRS is 0.  */
    beq r2, zero, 0f
      28:	10000426 	beq	r2,zero,3c <_start+0x1c>

    /* Set SSTATUS to 0 to get to set SSTATUS.PRS to 0. */
    .set nobreak
    movui sstatus, 0
      2c:	07800014 	movui	ba,0
    .set break

    /* Switch to register set 0 and jump to label. */
    movhi ea, %hi(0f)
      30:	07400034 	movhi	ea,0
    ori ea, ea, %lo(0f)
      34:	ef400f14 	ori	ea,ea,60
    eret
      38:	ef80083a 	eret

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
      3c:	06c08034 	movhi	sp,512
    ori sp, sp, %lo(__alt_stack_pointer)
      40:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
      44:	068000f4 	movhi	gp,3
    ori gp, gp, %lo(_gp)
      48:	d6b57214 	ori	gp,gp,54728
    /* 
     * Setup registers in shadow register sets
     * from 1 to NIOS2_NUM_OF_SHADOW_REG_SETS.
     */

    movui r2, 0     /* Contains value written into STATUS */
      4c:	00800014 	movui	r2,0
    movui r3, NIOS2_NUM_OF_SHADOW_REG_SETS  /* counter */
      50:	00c00054 	movui	r3,1
    movhi r4, 1     /* Constant to increment STATUS.PRS */
      54:	01000074 	movhi	r4,1
    
.Linitialize_shadow_registers:
    /* Increment STATUS.PRS */
    add r2, r2, r4
      58:	1105883a 	add	r2,r2,r4
    wrctl status, r2
      5c:	1001703a 	wrctl	status,r2

    /* Clear r0 in the shadow register set (not done by hardware) */
    wrprs r0, r0
      60:	0000a03a 	wrprs	zero,zero

    /* Write the GP in previous register set */
    wrprs gp, gp
      64:	d034a03a 	wrprs	gp,gp
    wrprs r30, r0    /* ba */
    wrprs r31, r0    /* ra */
#endif /* NIOS2_ECC_PRESENT */

    /* Decrement shadow register set counter */
    addi r3, r3, -1
      68:	18ffffc4 	addi	r3,r3,-1

    /* Done if index is 0. */
    bne r3, zero, .Linitialize_shadow_registers
      6c:	183ffa1e 	bne	r3,zero,58 <_start+0x38>
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
      70:	008000f4 	movhi	r2,3
    ori r2, r2, %lo(__bss_start)
      74:	109e1b14 	ori	r2,r2,30828

    movhi r3, %hi(__bss_end)
      78:	00c00234 	movhi	r3,8
    ori r3, r3, %lo(__bss_end)
      7c:	18c48614 	ori	r3,r3,4632

    beq r2, r3, 1f
      80:	10c00326 	beq	r2,r3,90 <_start+0x70>

0:
    stw zero, (r2)
      84:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
      88:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
      8c:	10fffd36 	bltu	r2,r3,84 <_start+0x64>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
      90:	0021d480 	call	21d48 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
      94:	0021ee80 	call	21ee8 <alt_main>

00000098 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
      98:	003fff06 	br	98 <alt_after_alt_main>

0000009c <low_level_init>:
 * @param netif the already initialized lwip network interface structure
 *        for this ethernetif
 */
static void
low_level_init(struct netif *netif)
{
      9c:	defffc04 	addi	sp,sp,-16
      a0:	dfc00315 	stw	ra,12(sp)
      a4:	df000215 	stw	fp,8(sp)
      a8:	df000204 	addi	fp,sp,8
      ac:	e13fff15 	stw	r4,-4(fp)
  struct ethernetif *ethernetif = netif->state;
      b0:	e0bfff17 	ldw	r2,-4(fp)
      b4:	10800717 	ldw	r2,28(r2)
      b8:	e0bffe15 	stw	r2,-8(fp)
  
  /* set MAC hardware address length */
  netif->hwaddr_len = ETHARP_HWADDR_LEN;
      bc:	e0bfff17 	ldw	r2,-4(fp)
      c0:	00c00184 	movi	r3,6
      c4:	10c00985 	stb	r3,38(r2)

  /* maximum transfer unit */
  netif->mtu = 1500;
      c8:	e0bfff17 	ldw	r2,-4(fp)
      cc:	00c17704 	movi	r3,1500
      d0:	10c0090d 	sth	r3,36(r2)
  
  /* device capabilities */
  /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
      d4:	e0bfff17 	ldw	r2,-4(fp)
      d8:	00c00c84 	movi	r3,50
      dc:	10c00b45 	stb	r3,45(r2)
  
  tse_mac_init(0, ethernetif) != 0;
      e0:	0009883a 	mov	r4,zero
      e4:	e17ffe17 	ldw	r5,-8(fp)
      e8:	0000ca40 	call	ca4 <tse_mac_init>
}
      ec:	e037883a 	mov	sp,fp
      f0:	dfc00117 	ldw	ra,4(sp)
      f4:	df000017 	ldw	fp,0(sp)
      f8:	dec00204 	addi	sp,sp,8
      fc:	f800283a 	ret

00000100 <low_level_input>:
 * @return a pbuf filled with the received packet (including MAC header)
 *         NULL on memory error
 */
static struct pbuf *
low_level_input(struct netif *netif)
{
     100:	defff604 	addi	sp,sp,-40
     104:	dfc00915 	stw	ra,36(sp)
     108:	df000815 	stw	fp,32(sp)
     10c:	df000804 	addi	fp,sp,32
     110:	e13fff15 	stw	r4,-4(fp)
  struct ethernetif *ethernetif = netif->state;
     114:	e0bfff17 	ldw	r2,-4(fp)
     118:	10800717 	ldw	r2,28(r2)
     11c:	e0bff915 	stw	r2,-28(fp)
  struct pbuf *p, *nextPkt;
  u32_t cpu_sr;

    if(ethernetif->lwipRxCount == 0)
     120:	e0bff917 	ldw	r2,-28(fp)
     124:	10801517 	ldw	r2,84(r2)
     128:	1000021e 	bne	r2,zero,134 <low_level_input+0x34>
        return NULL;
     12c:	0005883a 	mov	r2,zero
     130:	00007b06 	br	320 <low_level_input+0x220>
    //  Dump current packet if there is no memory for the next packet.
    //  The lwipRxPbuf must contain pointers to pbufs at all times.
    nextPkt = pbuf_alloc(PBUF_RAW,  PBUF_POOL_BUFSIZE, PBUF_POOL);
     134:	010000c4 	movi	r4,3
     138:	01417b04 	movi	r5,1516
     13c:	018000c4 	movi	r6,3
     140:	000a0740 	call	a074 <pbuf_alloc>
     144:	e0bffa15 	stw	r2,-24(fp)
    if(nextPkt == NULL)
     148:	e0bffa17 	ldw	r2,-24(fp)
     14c:	1000121e 	bne	r2,zero,198 <low_level_input+0x98>
        {
        LINK_STATS_INC(link.memerr);
     150:	00800234 	movhi	r2,8
     154:	1083bd04 	addi	r2,r2,3828
     158:	1080030b 	ldhu	r2,12(r2)
     15c:	10800044 	addi	r2,r2,1
     160:	1007883a 	mov	r3,r2
     164:	00800234 	movhi	r2,8
     168:	1083bd04 	addi	r2,r2,3828
     16c:	10c0030d 	sth	r3,12(r2)
        LINK_STATS_INC(link.drop);
     170:	00800234 	movhi	r2,8
     174:	1083bd04 	addi	r2,r2,3828
     178:	1080018b 	ldhu	r2,6(r2)
     17c:	10800044 	addi	r2,r2,1
     180:	1007883a 	mov	r3,r2
     184:	00800234 	movhi	r2,8
     188:	1083bd04 	addi	r2,r2,3828
     18c:	10c0018d 	sth	r3,6(r2)
        return NULL;
     190:	0005883a 	mov	r2,zero
     194:	00006206 	br	320 <low_level_input+0x220>
        }
    nextPkt = (void *) alt_remap_uncached(nextPkt,sizeof *nextPkt);
     198:	e13ffa17 	ldw	r4,-24(fp)
     19c:	01400404 	movi	r5,16
     1a0:	00221400 	call	22140 <alt_remap_uncached>
     1a4:	e0bffa15 	stw	r2,-24(fp)
    nextPkt->payload = (void *) alt_remap_uncached(nextPkt->payload, PBUF_POOL_BUFSIZE);
     1a8:	e0bffa17 	ldw	r2,-24(fp)
     1ac:	10800117 	ldw	r2,4(r2)
     1b0:	1009883a 	mov	r4,r2
     1b4:	01417b04 	movi	r5,1516
     1b8:	00221400 	call	22140 <alt_remap_uncached>
     1bc:	e0fffa17 	ldw	r3,-24(fp)
     1c0:	18800115 	stw	r2,4(r3)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
     1c4:	0005303a 	rdctl	r2,status
     1c8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
     1cc:	e0fffc17 	ldw	r3,-16(fp)
     1d0:	00bfff84 	movi	r2,-2
     1d4:	1884703a 	and	r2,r3,r2
     1d8:	1001703a 	wrctl	status,r2
  
  return context;
     1dc:	e0bffc17 	ldw	r2,-16(fp)
    cpu_sr = alt_irq_disable_all();
     1e0:	e0bffb15 	stw	r2,-20(fp)
    --ethernetif->lwipRxCount;
     1e4:	e0bff917 	ldw	r2,-28(fp)
     1e8:	10801517 	ldw	r2,84(r2)
     1ec:	10ffffc4 	addi	r3,r2,-1
     1f0:	e0bff917 	ldw	r2,-28(fp)
     1f4:	10c01515 	stw	r3,84(r2)
    alt_irq_enable_all(cpu_sr);
     1f8:	e0bffb17 	ldw	r2,-20(fp)
     1fc:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
     200:	0005303a 	rdctl	r2,status
     204:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
     208:	e0fffe17 	ldw	r3,-8(fp)
     20c:	00bfff84 	movi	r2,-2
     210:	1884703a 	and	r2,r3,r2
     214:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
     218:	e0bffd17 	ldw	r2,-12(fp)
     21c:	1080004c 	andi	r2,r2,1
     220:	e0fffe17 	ldw	r3,-8(fp)
     224:	1884b03a 	or	r2,r3,r2
     228:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
     22c:	e0bffe17 	ldw	r2,-8(fp)
     230:	1001703a 	wrctl	status,r2
    p = ethernetif->lwipRxPbuf[ ethernetif->lwipRxIndex ];
     234:	e0bff917 	ldw	r2,-28(fp)
     238:	10801417 	ldw	r2,80(r2)
     23c:	e0fff917 	ldw	r3,-28(fp)
     240:	108001c4 	addi	r2,r2,7
     244:	1085883a 	add	r2,r2,r2
     248:	1085883a 	add	r2,r2,r2
     24c:	1885883a 	add	r2,r3,r2
     250:	10800017 	ldw	r2,0(r2)
     254:	e0bff815 	stw	r2,-32(fp)
    ethernetif->lwipRxPbuf[ ethernetif->lwipRxIndex ] = nextPkt;
     258:	e0bff917 	ldw	r2,-28(fp)
     25c:	10801417 	ldw	r2,80(r2)
     260:	e0fff917 	ldw	r3,-28(fp)
     264:	108001c4 	addi	r2,r2,7
     268:	1085883a 	add	r2,r2,r2
     26c:	1085883a 	add	r2,r2,r2
     270:	1885883a 	add	r2,r3,r2
     274:	e0fffa17 	ldw	r3,-24(fp)
     278:	10c00015 	stw	r3,0(r2)
    if(++ethernetif->lwipRxIndex >= LWIP_RX_ETH_BUFFER)
     27c:	e0bff917 	ldw	r2,-28(fp)
     280:	10801417 	ldw	r2,80(r2)
     284:	10c00044 	addi	r3,r2,1
     288:	e0bff917 	ldw	r2,-28(fp)
     28c:	10c01415 	stw	r3,80(r2)
     290:	e0bff917 	ldw	r2,-28(fp)
     294:	10801417 	ldw	r2,80(r2)
     298:	10800310 	cmplti	r2,r2,12
     29c:	1000021e 	bne	r2,zero,2a8 <low_level_input+0x1a8>
        ethernetif->lwipRxIndex = 0;
     2a0:	e0bff917 	ldw	r2,-28(fp)
     2a4:	10001415 	stw	zero,80(r2)
    LWIP_ASSERT("low_level_input: pbuf in rx buffer is NULL", p != NULL );
     2a8:	e0bff817 	ldw	r2,-32(fp)
     2ac:	1000091e 	bne	r2,zero,2d4 <low_level_input+0x1d4>
     2b0:	010000f4 	movhi	r4,3
     2b4:	2138bf04 	addi	r4,r4,-7428
     2b8:	014000f4 	movhi	r5,3
     2bc:	2978c904 	addi	r5,r5,-7388
     2c0:	01801e44 	movi	r6,121
     2c4:	01c000f4 	movhi	r7,3
     2c8:	39f8d404 	addi	r7,r7,-7344
     2cc:	00193f00 	call	193f0 <printf>
     2d0:	003fff06 	br	2d0 <low_level_input+0x1d0>
    LWIP_ASSERT("low_level_input: pbuf->len in rx buffer is 0", p->len != 0 );
     2d4:	e0bff817 	ldw	r2,-32(fp)
     2d8:	1080028b 	ldhu	r2,10(r2)
     2dc:	10bfffcc 	andi	r2,r2,65535
     2e0:	1000091e 	bne	r2,zero,308 <low_level_input+0x208>
     2e4:	010000f4 	movhi	r4,3
     2e8:	2138bf04 	addi	r4,r4,-7428
     2ec:	014000f4 	movhi	r5,3
     2f0:	2978dc04 	addi	r5,r5,-7312
     2f4:	01801e84 	movi	r6,122
     2f8:	01c000f4 	movhi	r7,3
     2fc:	39f8d404 	addi	r7,r7,-7344
     300:	00193f00 	call	193f0 <printf>
     304:	003fff06 	br	304 <low_level_input+0x204>
    if( p->len == 0 )
     308:	e0bff817 	ldw	r2,-32(fp)
     30c:	1080028b 	ldhu	r2,10(r2)
     310:	10bfffcc 	andi	r2,r2,65535
     314:	1000011e 	bne	r2,zero,31c <low_level_input+0x21c>
        p = NULL;
     318:	e03ff815 	stw	zero,-32(fp)
    return p;  
     31c:	e0bff817 	ldw	r2,-32(fp)
}
     320:	e037883a 	mov	sp,fp
     324:	dfc00117 	ldw	ra,4(sp)
     328:	df000017 	ldw	fp,0(sp)
     32c:	dec00204 	addi	sp,sp,8
     330:	f800283a 	ret

00000334 <ethernetif_input>:
 *
 * @param netif the lwip network interface structure for this ethernetif
 */
void
ethernetif_input(struct netif *netif)
{
     334:	defffa04 	addi	sp,sp,-24
     338:	dfc00515 	stw	ra,20(sp)
     33c:	df000415 	stw	fp,16(sp)
     340:	df000404 	addi	fp,sp,16
     344:	e13fff15 	stw	r4,-4(fp)
  struct ethernetif *ethernetif;
  struct eth_hdr *ethhdr;
  struct pbuf *p;

  ethernetif = netif->state;
     348:	e0bfff17 	ldw	r2,-4(fp)
     34c:	10800717 	ldw	r2,28(r2)
     350:	e0bffc15 	stw	r2,-16(fp)

  /* move received packet into a new pbuf */
  p = low_level_input(netif);
     354:	e13fff17 	ldw	r4,-4(fp)
     358:	00001000 	call	100 <low_level_input>
     35c:	e0bffd15 	stw	r2,-12(fp)
  /* no packet could be read, silently ignore this */
  if (p == NULL) return;
     360:	e0bffd17 	ldw	r2,-12(fp)
     364:	10002426 	beq	r2,zero,3f8 <ethernetif_input+0xc4>
  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = p->payload;
     368:	e0bffd17 	ldw	r2,-12(fp)
     36c:	10800117 	ldw	r2,4(r2)
     370:	e0bffe15 	stw	r2,-8(fp)

  switch (htons(ethhdr->type)) {
     374:	e0bffe17 	ldw	r2,-8(fp)
     378:	1080038b 	ldhu	r2,14(r2)
     37c:	10bfffcc 	andi	r2,r2,65535
     380:	1004d23a 	srli	r2,r2,8
     384:	10ffffcc 	andi	r3,r2,65535
     388:	e0bffe17 	ldw	r2,-8(fp)
     38c:	1080038b 	ldhu	r2,14(r2)
     390:	10bfffcc 	andi	r2,r2,65535
     394:	1004923a 	slli	r2,r2,8
     398:	10bfffcc 	andi	r2,r2,65535
     39c:	1884b03a 	or	r2,r3,r2
     3a0:	10c20020 	cmpeqi	r3,r2,2048
     3a4:	1800021e 	bne	r3,zero,3b0 <ethernetif_input+0x7c>
     3a8:	108201a0 	cmpeqi	r2,r2,2054
     3ac:	10000d26 	beq	r2,zero,3e4 <ethernetif_input+0xb0>
  /* PPPoE packet? */
  case ETHTYPE_PPPOEDISC:
  case ETHTYPE_PPPOE:
#endif /* PPPOE_SUPPORT */
    /* full packet send to tcpip_thread to process */
    if (netif->input(p, netif)!=ERR_OK)
     3b0:	e0bfff17 	ldw	r2,-4(fp)
     3b4:	10800417 	ldw	r2,16(r2)
     3b8:	e13ffd17 	ldw	r4,-12(fp)
     3bc:	e17fff17 	ldw	r5,-4(fp)
     3c0:	103ee83a 	callr	r2
     3c4:	10803fcc 	andi	r2,r2,255
     3c8:	1080201c 	xori	r2,r2,128
     3cc:	10bfe004 	addi	r2,r2,-128
     3d0:	10000b26 	beq	r2,zero,400 <ethernetif_input+0xcc>
     { LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
       pbuf_free(p);
     3d4:	e13ffd17 	ldw	r4,-12(fp)
     3d8:	000aa340 	call	aa34 <pbuf_free>
       p = NULL;
     3dc:	e03ffd15 	stw	zero,-12(fp)
     }
    break;
     3e0:	00000706 	br	400 <ethernetif_input+0xcc>

  default:
    pbuf_free(p);
     3e4:	e13ffd17 	ldw	r4,-12(fp)
     3e8:	000aa340 	call	aa34 <pbuf_free>
    p = NULL;
     3ec:	e03ffd15 	stw	zero,-12(fp)
    break;
     3f0:	0001883a 	nop
     3f4:	00000306 	br	404 <ethernetif_input+0xd0>
  ethernetif = netif->state;

  /* move received packet into a new pbuf */
  p = low_level_input(netif);
  /* no packet could be read, silently ignore this */
  if (p == NULL) return;
     3f8:	0001883a 	nop
     3fc:	00000106 	br	404 <ethernetif_input+0xd0>
    if (netif->input(p, netif)!=ERR_OK)
     { LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
       pbuf_free(p);
       p = NULL;
     }
    break;
     400:	0001883a 	nop
  default:
    pbuf_free(p);
    p = NULL;
    break;
  }
}
     404:	e037883a 	mov	sp,fp
     408:	dfc00117 	ldw	ra,4(sp)
     40c:	df000017 	ldw	fp,0(sp)
     410:	dec00204 	addi	sp,sp,8
     414:	f800283a 	ret

00000418 <ethernetif_init>:
 *         ERR_MEM if private data couldn't be allocated
 *         any other err_t on error
 */
err_t
ethernetif_init(struct netif *netif)
{
     418:	defffa04 	addi	sp,sp,-24
     41c:	dfc00515 	stw	ra,20(sp)
     420:	df000415 	stw	fp,16(sp)
     424:	df000404 	addi	fp,sp,16
     428:	e13fff15 	stw	r4,-4(fp)
  int idx;
  struct pbuf *p;
  struct ethernetif *ethernetif;
  err_t tse_mac_raw_send(struct netif *netif, struct pbuf *p);  

  LWIP_ASSERT("netif != NULL", (netif != NULL));
     42c:	e0bfff17 	ldw	r2,-4(fp)
     430:	1000091e 	bne	r2,zero,458 <ethernetif_init+0x40>
     434:	010000f4 	movhi	r4,3
     438:	2138bf04 	addi	r4,r4,-7428
     43c:	014000f4 	movhi	r5,3
     440:	2978e804 	addi	r5,r5,-7264
     444:	01803144 	movi	r6,197
     448:	01c000f4 	movhi	r7,3
     44c:	39f8d404 	addi	r7,r7,-7344
     450:	00193f00 	call	193f0 <printf>
     454:	003fff06 	br	454 <ethernetif_init+0x3c>
    
  ethernetif = mem_malloc(sizeof(struct ethernetif));
     458:	01001704 	movi	r4,92
     45c:	0008fcc0 	call	8fcc <mem_malloc>
     460:	e0bffd15 	stw	r2,-12(fp)
  if (ethernetif == NULL) {
     464:	e0bffd17 	ldw	r2,-12(fp)
     468:	1000021e 	bne	r2,zero,474 <ethernetif_init+0x5c>
    LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_init: out of memory\n"));
    return ERR_MEM;
     46c:	00bfffc4 	movi	r2,-1
     470:	00004206 	br	57c <ethernetif_init+0x164>
   * The last argument should be replaced with your link speed, in units
   * of bits per second.
   */
  NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, LINK_SPEED_OF_YOUR_NETIF_IN_BPS);

  netif->state = ethernetif;
     474:	e0bfff17 	ldw	r2,-4(fp)
     478:	e0fffd17 	ldw	r3,-12(fp)
     47c:	10c00715 	stw	r3,28(r2)
  netif->name[0] = IFNAME0;
     480:	e0bfff17 	ldw	r2,-4(fp)
     484:	00c01944 	movi	r3,101
     488:	10c00b85 	stb	r3,46(r2)
  netif->name[1] = IFNAME1;
     48c:	e0bfff17 	ldw	r2,-4(fp)
     490:	00c01b84 	movi	r3,110
     494:	10c00bc5 	stb	r3,47(r2)
  /* We directly use etharp_output() here to save a function call.
   * You can instead declare your own function an call etharp_output()
   * from it if you have to do some checks before sending (e.g. if link
   * is available...) */
  netif->output = etharp_output;
     498:	e0bfff17 	ldw	r2,-4(fp)
     49c:	00c00074 	movhi	r3,1
     4a0:	18dbf404 	addi	r3,r3,28624
     4a4:	10c00515 	stw	r3,20(r2)
  netif->linkoutput = tse_mac_raw_send;
     4a8:	e0bfff17 	ldw	r2,-4(fp)
     4ac:	00c00034 	movhi	r3,0
     4b0:	18c59604 	addi	r3,r3,5720
     4b4:	10c00615 	stw	r3,24(r2)
  
  ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
     4b8:	e0bfff17 	ldw	r2,-4(fp)
     4bc:	10c009c4 	addi	r3,r2,39
     4c0:	e0bffd17 	ldw	r2,-12(fp)
     4c4:	10c00015 	stw	r3,0(r2)
  
  /* initialize the rx buffer for access by the TSE ISR */
  for(idx = 0; idx < LWIP_RX_ETH_BUFFER; ++idx)
     4c8:	e03ffc15 	stw	zero,-16(fp)
     4cc:	00001f06 	br	54c <ethernetif_init+0x134>
    {
    p = pbuf_alloc(PBUF_RAW, PBUF_POOL_BUFSIZE, PBUF_POOL);
     4d0:	010000c4 	movi	r4,3
     4d4:	01417b04 	movi	r5,1516
     4d8:	018000c4 	movi	r6,3
     4dc:	000a0740 	call	a074 <pbuf_alloc>
     4e0:	e0bffe15 	stw	r2,-8(fp)
    if (p == NULL)
     4e4:	e0bffe17 	ldw	r2,-8(fp)
     4e8:	1000021e 	bne	r2,zero,4f4 <ethernetif_init+0xdc>
      return ERR_MEM;
     4ec:	00bfffc4 	movi	r2,-1
     4f0:	00002206 	br	57c <ethernetif_init+0x164>
    p = (void *) alt_remap_uncached(p,sizeof *p);
     4f4:	e13ffe17 	ldw	r4,-8(fp)
     4f8:	01400404 	movi	r5,16
     4fc:	00221400 	call	22140 <alt_remap_uncached>
     500:	e0bffe15 	stw	r2,-8(fp)
    p->payload = (void *) alt_remap_uncached(p->payload,PBUF_POOL_BUFSIZE);
     504:	e0bffe17 	ldw	r2,-8(fp)
     508:	10800117 	ldw	r2,4(r2)
     50c:	1009883a 	mov	r4,r2
     510:	01417b04 	movi	r5,1516
     514:	00221400 	call	22140 <alt_remap_uncached>
     518:	e0fffe17 	ldw	r3,-8(fp)
     51c:	18800115 	stw	r2,4(r3)
    ethernetif->lwipRxPbuf[idx] = p;
     520:	e0fffd17 	ldw	r3,-12(fp)
     524:	e0bffc17 	ldw	r2,-16(fp)
     528:	108001c4 	addi	r2,r2,7
     52c:	1085883a 	add	r2,r2,r2
     530:	1085883a 	add	r2,r2,r2
     534:	1885883a 	add	r2,r3,r2
     538:	e0fffe17 	ldw	r3,-8(fp)
     53c:	10c00015 	stw	r3,0(r2)
  netif->linkoutput = tse_mac_raw_send;
  
  ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  
  /* initialize the rx buffer for access by the TSE ISR */
  for(idx = 0; idx < LWIP_RX_ETH_BUFFER; ++idx)
     540:	e0bffc17 	ldw	r2,-16(fp)
     544:	10800044 	addi	r2,r2,1
     548:	e0bffc15 	stw	r2,-16(fp)
     54c:	e0bffc17 	ldw	r2,-16(fp)
     550:	10800310 	cmplti	r2,r2,12
     554:	103fde1e 	bne	r2,zero,4d0 <ethernetif_init+0xb8>
      return ERR_MEM;
    p = (void *) alt_remap_uncached(p,sizeof *p);
    p->payload = (void *) alt_remap_uncached(p->payload,PBUF_POOL_BUFSIZE);
    ethernetif->lwipRxPbuf[idx] = p;
    }
  ethernetif->lwipRxCount = 0;
     558:	e0bffd17 	ldw	r2,-12(fp)
     55c:	10001515 	stw	zero,84(r2)
  ethernetif->lwipRxIndex = 0;
     560:	e0bffd17 	ldw	r2,-12(fp)
     564:	10001415 	stw	zero,80(r2)
  ethernetif->lwipRxIndexIsr = 0;
     568:	e0bffd17 	ldw	r2,-12(fp)
     56c:	10001315 	stw	zero,76(r2)
                  
  /* initialize the low level hardware */
  low_level_init(netif);
     570:	e13fff17 	ldw	r4,-4(fp)
     574:	000009c0 	call	9c <low_level_init>
  return ERR_OK;
     578:	0005883a 	mov	r2,zero
}
     57c:	e037883a 	mov	sp,fp
     580:	dfc00117 	ldw	ra,4(sp)
     584:	df000017 	ldw	fp,0(sp)
     588:	dec00204 	addi	sp,sp,8
     58c:	f800283a 	ret

00000590 <fs_open>:


/*-----------------------------------------------------------------------------------*/
int
fs_open(const char *name, struct fs_file *file)
{
     590:	defffb04 	addi	sp,sp,-20
     594:	dfc00415 	stw	ra,16(sp)
     598:	df000315 	stw	fp,12(sp)
     59c:	df000304 	addi	fp,sp,12
     5a0:	e13ffe15 	stw	r4,-8(fp)
     5a4:	e17fff15 	stw	r5,-4(fp)
  const struct fsdata_file *f;

  for(f = FS_ROOT;
     5a8:	008000f4 	movhi	r2,3
     5ac:	10bc0804 	addi	r2,r2,-4064
     5b0:	e0bffd15 	stw	r2,-12(fp)
     5b4:	00001306 	br	604 <fs_open+0x74>
      f != NULL;
      f = f->next) {
    if (!strcmp(name, (const char*)f->name)) {
     5b8:	e0bffd17 	ldw	r2,-12(fp)
     5bc:	10800117 	ldw	r2,4(r2)
     5c0:	e13ffe17 	ldw	r4,-8(fp)
     5c4:	100b883a 	mov	r5,r2
     5c8:	00196700 	call	19670 <strcmp>
     5cc:	10000a1e 	bne	r2,zero,5f8 <fs_open+0x68>
      file->data = f->data;
     5d0:	e0bffd17 	ldw	r2,-12(fp)
     5d4:	10c00217 	ldw	r3,8(r2)
     5d8:	e0bfff17 	ldw	r2,-4(fp)
     5dc:	10c00015 	stw	r3,0(r2)
      file->len = f->len;
     5e0:	e0bffd17 	ldw	r2,-12(fp)
     5e4:	10c00317 	ldw	r3,12(r2)
     5e8:	e0bfff17 	ldw	r2,-4(fp)
     5ec:	10c00115 	stw	r3,4(r2)
      return 1;
     5f0:	00800044 	movi	r2,1
     5f4:	00000606 	br	610 <fs_open+0x80>
{
  const struct fsdata_file *f;

  for(f = FS_ROOT;
      f != NULL;
      f = f->next) {
     5f8:	e0bffd17 	ldw	r2,-12(fp)
     5fc:	10800017 	ldw	r2,0(r2)
     600:	e0bffd15 	stw	r2,-12(fp)
int
fs_open(const char *name, struct fs_file *file)
{
  const struct fsdata_file *f;

  for(f = FS_ROOT;
     604:	e0bffd17 	ldw	r2,-12(fp)
     608:	103feb1e 	bne	r2,zero,5b8 <fs_open+0x28>
      file->data = f->data;
      file->len = f->len;
      return 1;
    }
  }
  return 0;
     60c:	0005883a 	mov	r2,zero
}
     610:	e037883a 	mov	sp,fp
     614:	dfc00117 	ldw	ra,4(sp)
     618:	df000017 	ldw	fp,0(sp)
     61c:	dec00204 	addi	sp,sp,8
     620:	f800283a 	ret

00000624 <conn_err>:
};

/*-----------------------------------------------------------------------------------*/
static void
conn_err(void *arg, err_t err)
{
     624:	defffb04 	addi	sp,sp,-20
     628:	dfc00415 	stw	ra,16(sp)
     62c:	df000315 	stw	fp,12(sp)
     630:	df000304 	addi	fp,sp,12
     634:	e13ffe15 	stw	r4,-8(fp)
     638:	2805883a 	mov	r2,r5
     63c:	e0bfff05 	stb	r2,-4(fp)
  struct http_state *hs;

  LWIP_UNUSED_ARG(err);

  hs = arg;
     640:	e0bffe17 	ldw	r2,-8(fp)
     644:	e0bffd15 	stw	r2,-12(fp)
  mem_free(hs);
     648:	e13ffd17 	ldw	r4,-12(fp)
     64c:	0008afc0 	call	8afc <mem_free>
}
     650:	e037883a 	mov	sp,fp
     654:	dfc00117 	ldw	ra,4(sp)
     658:	df000017 	ldw	fp,0(sp)
     65c:	dec00204 	addi	sp,sp,8
     660:	f800283a 	ret

00000664 <close_conn>:
/*-----------------------------------------------------------------------------------*/
static void
close_conn(struct tcp_pcb *pcb, struct http_state *hs)
{
     664:	defffc04 	addi	sp,sp,-16
     668:	dfc00315 	stw	ra,12(sp)
     66c:	df000215 	stw	fp,8(sp)
     670:	df000204 	addi	fp,sp,8
     674:	e13ffe15 	stw	r4,-8(fp)
     678:	e17fff15 	stw	r5,-4(fp)
  tcp_arg(pcb, NULL);
     67c:	e13ffe17 	ldw	r4,-8(fp)
     680:	000b883a 	mov	r5,zero
     684:	000def40 	call	def4 <tcp_arg>
  tcp_sent(pcb, NULL);
     688:	e13ffe17 	ldw	r4,-8(fp)
     68c:	000b883a 	mov	r5,zero
     690:	000df900 	call	df90 <tcp_sent>
  tcp_recv(pcb, NULL);
     694:	e13ffe17 	ldw	r4,-8(fp)
     698:	000b883a 	mov	r5,zero
     69c:	000df240 	call	df24 <tcp_recv>
  mem_free(hs);
     6a0:	e13fff17 	ldw	r4,-4(fp)
     6a4:	0008afc0 	call	8afc <mem_free>
  tcp_close(pcb);
     6a8:	e13ffe17 	ldw	r4,-8(fp)
     6ac:	000c24c0 	call	c24c <tcp_close>
}
     6b0:	e037883a 	mov	sp,fp
     6b4:	dfc00117 	ldw	ra,4(sp)
     6b8:	df000017 	ldw	fp,0(sp)
     6bc:	dec00204 	addi	sp,sp,8
     6c0:	f800283a 	ret

000006c4 <send_data>:
/*-----------------------------------------------------------------------------------*/
static void
send_data(struct tcp_pcb *pcb, struct http_state *hs)
{
     6c4:	defffa04 	addi	sp,sp,-24
     6c8:	dfc00515 	stw	ra,20(sp)
     6cc:	df000415 	stw	fp,16(sp)
     6d0:	df000404 	addi	fp,sp,16
     6d4:	e13ffe15 	stw	r4,-8(fp)
     6d8:	e17fff15 	stw	r5,-4(fp)
  err_t err;
  u32_t len;

  /* We cannot send more data than space available in the send
     buffer. */     
  if (tcp_sndbuf(pcb) < hs->left) {
     6dc:	e0bffe17 	ldw	r2,-8(fp)
     6e0:	10801a8b 	ldhu	r2,106(r2)
     6e4:	10ffffcc 	andi	r3,r2,65535
     6e8:	e0bfff17 	ldw	r2,-4(fp)
     6ec:	10800017 	ldw	r2,0(r2)
     6f0:	1880052e 	bgeu	r3,r2,708 <send_data+0x44>
    len = tcp_sndbuf(pcb);
     6f4:	e0bffe17 	ldw	r2,-8(fp)
     6f8:	10801a8b 	ldhu	r2,106(r2)
     6fc:	10bfffcc 	andi	r2,r2,65535
     700:	e0bffc15 	stw	r2,-16(fp)
     704:	00000306 	br	714 <send_data+0x50>
  } else {
    len = hs->left;
     708:	e0bfff17 	ldw	r2,-4(fp)
     70c:	10800017 	ldw	r2,0(r2)
     710:	e0bffc15 	stw	r2,-16(fp)
    LWIP_ASSERT((len == hs->left), "hs->left did not fit into u16_t!");
  }

  do {
    err = tcp_write(pcb, hs->file, len, 0);
     714:	e0bfff17 	ldw	r2,-4(fp)
     718:	10c00117 	ldw	r3,4(r2)
     71c:	e0bffc17 	ldw	r2,-16(fp)
     720:	10bfffcc 	andi	r2,r2,65535
     724:	e13ffe17 	ldw	r4,-8(fp)
     728:	180b883a 	mov	r5,r3
     72c:	100d883a 	mov	r6,r2
     730:	000f883a 	mov	r7,zero
     734:	0012bf00 	call	12bf0 <tcp_write>
     738:	e0bffd05 	stb	r2,-12(fp)
    if (err == ERR_MEM) {
     73c:	e0bffd07 	ldb	r2,-12(fp)
     740:	10bfffd8 	cmpnei	r2,r2,-1
     744:	1000031e 	bne	r2,zero,754 <send_data+0x90>
      len /= 2;
     748:	e0bffc17 	ldw	r2,-16(fp)
     74c:	1004d07a 	srli	r2,r2,1
     750:	e0bffc15 	stw	r2,-16(fp)
    }
  } while (err == ERR_MEM && len > 1);  
     754:	e0bffd07 	ldb	r2,-12(fp)
     758:	10bfffd8 	cmpnei	r2,r2,-1
     75c:	1000031e 	bne	r2,zero,76c <send_data+0xa8>
     760:	e0bffc17 	ldw	r2,-16(fp)
     764:	108000a8 	cmpgeui	r2,r2,2
     768:	103fea1e 	bne	r2,zero,714 <send_data+0x50>
  
  if (err == ERR_OK) {
     76c:	e0bffd07 	ldb	r2,-12(fp)
     770:	10000c1e 	bne	r2,zero,7a4 <send_data+0xe0>
    hs->file += len;
     774:	e0bfff17 	ldw	r2,-4(fp)
     778:	10c00117 	ldw	r3,4(r2)
     77c:	e0bffc17 	ldw	r2,-16(fp)
     780:	1887883a 	add	r3,r3,r2
     784:	e0bfff17 	ldw	r2,-4(fp)
     788:	10c00115 	stw	r3,4(r2)
    hs->left -= len;
     78c:	e0bfff17 	ldw	r2,-4(fp)
     790:	10c00017 	ldw	r3,0(r2)
     794:	e0bffc17 	ldw	r2,-16(fp)
     798:	1887c83a 	sub	r3,r3,r2
     79c:	e0bfff17 	ldw	r2,-4(fp)
     7a0:	10c00015 	stw	r3,0(r2)
    /*  } else {
    printf("send_data: error %s len %d %d\n", lwip_strerr(err), len, tcp_sndbuf(pcb));*/
  }
}
     7a4:	e037883a 	mov	sp,fp
     7a8:	dfc00117 	ldw	ra,4(sp)
     7ac:	df000017 	ldw	fp,0(sp)
     7b0:	dec00204 	addi	sp,sp,8
     7b4:	f800283a 	ret

000007b8 <http_poll>:
/*-----------------------------------------------------------------------------------*/
static err_t
http_poll(void *arg, struct tcp_pcb *pcb)
{
     7b8:	defffb04 	addi	sp,sp,-20
     7bc:	dfc00415 	stw	ra,16(sp)
     7c0:	df000315 	stw	fp,12(sp)
     7c4:	df000304 	addi	fp,sp,12
     7c8:	e13ffe15 	stw	r4,-8(fp)
     7cc:	e17fff15 	stw	r5,-4(fp)
  struct http_state *hs;

  hs = arg;
     7d0:	e0bffe17 	ldw	r2,-8(fp)
     7d4:	e0bffd15 	stw	r2,-12(fp)
  
  /*  printf("Polll\n");*/
  if ((hs == NULL) && (pcb->state == ESTABLISHED)) {
     7d8:	e0bffd17 	ldw	r2,-12(fp)
     7dc:	1000081e 	bne	r2,zero,800 <http_poll+0x48>
     7e0:	e0bfff17 	ldw	r2,-4(fp)
     7e4:	10800617 	ldw	r2,24(r2)
     7e8:	10800118 	cmpnei	r2,r2,4
     7ec:	1000041e 	bne	r2,zero,800 <http_poll+0x48>
    /*    printf("Null, close\n");*/
    tcp_abort(pcb);
     7f0:	e13fff17 	ldw	r4,-4(fp)
     7f4:	000c5280 	call	c528 <tcp_abort>
    return ERR_ABRT;
     7f8:	00bffd84 	movi	r2,-10
     7fc:	00001a06 	br	868 <http_poll+0xb0>
  } else if (hs != NULL) {
     800:	e0bffd17 	ldw	r2,-12(fp)
     804:	10001726 	beq	r2,zero,864 <http_poll+0xac>
    ++hs->retries;
     808:	e0bffd17 	ldw	r2,-12(fp)
     80c:	10800203 	ldbu	r2,8(r2)
     810:	10800044 	addi	r2,r2,1
     814:	1007883a 	mov	r3,r2
     818:	e0bffd17 	ldw	r2,-12(fp)
     81c:	10c00205 	stb	r3,8(r2)
    if (hs->retries == 4) {
     820:	e0bffd17 	ldw	r2,-12(fp)
     824:	10800203 	ldbu	r2,8(r2)
     828:	10803fcc 	andi	r2,r2,255
     82c:	10800118 	cmpnei	r2,r2,4
     830:	1000091e 	bne	r2,zero,858 <http_poll+0xa0>
      tcp_arg(pcb, NULL);
     834:	e13fff17 	ldw	r4,-4(fp)
     838:	000b883a 	mov	r5,zero
     83c:	000def40 	call	def4 <tcp_arg>
      mem_free(hs);
     840:	e13ffd17 	ldw	r4,-12(fp)
     844:	0008afc0 	call	8afc <mem_free>
      tcp_abort(pcb);
     848:	e13fff17 	ldw	r4,-4(fp)
     84c:	000c5280 	call	c528 <tcp_abort>
      return ERR_ABRT;
     850:	00bffd84 	movi	r2,-10
     854:	00000406 	br	868 <http_poll+0xb0>
    }
    send_data(pcb, hs);
     858:	e13fff17 	ldw	r4,-4(fp)
     85c:	e17ffd17 	ldw	r5,-12(fp)
     860:	00006c40 	call	6c4 <send_data>
  }

  return ERR_OK;
     864:	0005883a 	mov	r2,zero
}
     868:	e037883a 	mov	sp,fp
     86c:	dfc00117 	ldw	ra,4(sp)
     870:	df000017 	ldw	fp,0(sp)
     874:	dec00204 	addi	sp,sp,8
     878:	f800283a 	ret

0000087c <http_sent>:
/*-----------------------------------------------------------------------------------*/
static err_t
http_sent(void *arg, struct tcp_pcb *pcb, u16_t len)
{
     87c:	defffa04 	addi	sp,sp,-24
     880:	dfc00515 	stw	ra,20(sp)
     884:	df000415 	stw	fp,16(sp)
     888:	df000404 	addi	fp,sp,16
     88c:	e13ffd15 	stw	r4,-12(fp)
     890:	e17ffe15 	stw	r5,-8(fp)
     894:	3005883a 	mov	r2,r6
     898:	e0bfff0d 	sth	r2,-4(fp)
  struct http_state *hs;

  LWIP_UNUSED_ARG(len);

  hs = arg;
     89c:	e0bffd17 	ldw	r2,-12(fp)
     8a0:	e0bffc15 	stw	r2,-16(fp)

  hs->retries = 0;
     8a4:	e0bffc17 	ldw	r2,-16(fp)
     8a8:	10000205 	stb	zero,8(r2)
  
  if (hs->left > 0) {    
     8ac:	e0bffc17 	ldw	r2,-16(fp)
     8b0:	10800017 	ldw	r2,0(r2)
     8b4:	10000426 	beq	r2,zero,8c8 <http_sent+0x4c>
    send_data(pcb, hs);
     8b8:	e13ffe17 	ldw	r4,-8(fp)
     8bc:	e17ffc17 	ldw	r5,-16(fp)
     8c0:	00006c40 	call	6c4 <send_data>
     8c4:	00000306 	br	8d4 <http_sent+0x58>
  } else {
    close_conn(pcb, hs);
     8c8:	e13ffe17 	ldw	r4,-8(fp)
     8cc:	e17ffc17 	ldw	r5,-16(fp)
     8d0:	00006640 	call	664 <close_conn>
  }

  return ERR_OK;
     8d4:	0005883a 	mov	r2,zero
}
     8d8:	e037883a 	mov	sp,fp
     8dc:	dfc00117 	ldw	ra,4(sp)
     8e0:	df000017 	ldw	fp,0(sp)
     8e4:	dec00204 	addi	sp,sp,8
     8e8:	f800283a 	ret

000008ec <http_recv>:
/*-----------------------------------------------------------------------------------*/
static err_t
http_recv(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
     8ec:	defff504 	addi	sp,sp,-44
     8f0:	dfc00a15 	stw	ra,40(sp)
     8f4:	df000915 	stw	fp,36(sp)
     8f8:	df000904 	addi	fp,sp,36
     8fc:	e13ffc15 	stw	r4,-16(fp)
     900:	e17ffd15 	stw	r5,-12(fp)
     904:	e1bffe15 	stw	r6,-8(fp)
     908:	3805883a 	mov	r2,r7
     90c:	e0bfff05 	stb	r2,-4(fp)
  int i;
  char *data;
  struct fs_file file;
  struct http_state *hs;

  hs = arg;
     910:	e0bffc17 	ldw	r2,-16(fp)
     914:	e0bff815 	stw	r2,-32(fp)

  if (err == ERR_OK && p != NULL) {
     918:	e0bfff07 	ldb	r2,-4(fp)
     91c:	1000791e 	bne	r2,zero,b04 <http_recv+0x218>
     920:	e0bffe17 	ldw	r2,-8(fp)
     924:	10007726 	beq	r2,zero,b04 <http_recv+0x218>

    /* Inform TCP that we have taken the data. */
    tcp_recved(pcb, p->tot_len);
     928:	e0bffe17 	ldw	r2,-8(fp)
     92c:	1080020b 	ldhu	r2,8(r2)
     930:	10bfffcc 	andi	r2,r2,65535
     934:	e13ffd17 	ldw	r4,-12(fp)
     938:	100b883a 	mov	r5,r2
     93c:	000ca180 	call	ca18 <tcp_recved>
    
    if (hs->file == NULL) {
     940:	e0bff817 	ldw	r2,-32(fp)
     944:	10800117 	ldw	r2,4(r2)
     948:	10006c1e 	bne	r2,zero,afc <http_recv+0x210>
      data = p->payload;
     94c:	e0bffe17 	ldw	r2,-8(fp)
     950:	10800117 	ldw	r2,4(r2)
     954:	e0bff915 	stw	r2,-28(fp)
      
      if (strncmp(data, "GET ", 4) == 0) {
     958:	e13ff917 	ldw	r4,-28(fp)
     95c:	014000f4 	movhi	r5,3
     960:	297c0c04 	addi	r5,r5,-4048
     964:	01800104 	movi	r6,4
     968:	00197a00 	call	197a0 <strncmp>
     96c:	10005d1e 	bne	r2,zero,ae4 <http_recv+0x1f8>
        for(i = 0; i < 40; i++) {
     970:	e03ff715 	stw	zero,-36(fp)
     974:	00002606 	br	a10 <http_recv+0x124>
          if (((char *)data + 4)[i] == ' ' ||
     978:	e0bff717 	ldw	r2,-36(fp)
     97c:	10800104 	addi	r2,r2,4
     980:	e0fff917 	ldw	r3,-28(fp)
     984:	1885883a 	add	r2,r3,r2
     988:	10800003 	ldbu	r2,0(r2)
     98c:	10803fcc 	andi	r2,r2,255
     990:	1080201c 	xori	r2,r2,128
     994:	10bfe004 	addi	r2,r2,-128
     998:	10800820 	cmpeqi	r2,r2,32
     99c:	1000141e 	bne	r2,zero,9f0 <http_recv+0x104>
             ((char *)data + 4)[i] == '\r' ||
     9a0:	e0bff717 	ldw	r2,-36(fp)
     9a4:	10800104 	addi	r2,r2,4
     9a8:	e0fff917 	ldw	r3,-28(fp)
     9ac:	1885883a 	add	r2,r3,r2
     9b0:	10800003 	ldbu	r2,0(r2)
    if (hs->file == NULL) {
      data = p->payload;
      
      if (strncmp(data, "GET ", 4) == 0) {
        for(i = 0; i < 40; i++) {
          if (((char *)data + 4)[i] == ' ' ||
     9b4:	10803fcc 	andi	r2,r2,255
     9b8:	1080201c 	xori	r2,r2,128
     9bc:	10bfe004 	addi	r2,r2,-128
     9c0:	10800360 	cmpeqi	r2,r2,13
     9c4:	10000a1e 	bne	r2,zero,9f0 <http_recv+0x104>
             ((char *)data + 4)[i] == '\r' ||
             ((char *)data + 4)[i] == '\n') {
     9c8:	e0bff717 	ldw	r2,-36(fp)
     9cc:	10800104 	addi	r2,r2,4
     9d0:	e0fff917 	ldw	r3,-28(fp)
     9d4:	1885883a 	add	r2,r3,r2
     9d8:	10800003 	ldbu	r2,0(r2)
      data = p->payload;
      
      if (strncmp(data, "GET ", 4) == 0) {
        for(i = 0; i < 40; i++) {
          if (((char *)data + 4)[i] == ' ' ||
             ((char *)data + 4)[i] == '\r' ||
     9dc:	10803fcc 	andi	r2,r2,255
     9e0:	1080201c 	xori	r2,r2,128
     9e4:	10bfe004 	addi	r2,r2,-128
     9e8:	10800298 	cmpnei	r2,r2,10
     9ec:	1000051e 	bne	r2,zero,a04 <http_recv+0x118>
             ((char *)data + 4)[i] == '\n') {
            ((char *)data + 4)[i] = 0;
     9f0:	e0bff717 	ldw	r2,-36(fp)
     9f4:	10800104 	addi	r2,r2,4
     9f8:	e0fff917 	ldw	r3,-28(fp)
     9fc:	1885883a 	add	r2,r3,r2
     a00:	10000005 	stb	zero,0(r2)
    
    if (hs->file == NULL) {
      data = p->payload;
      
      if (strncmp(data, "GET ", 4) == 0) {
        for(i = 0; i < 40; i++) {
     a04:	e0bff717 	ldw	r2,-36(fp)
     a08:	10800044 	addi	r2,r2,1
     a0c:	e0bff715 	stw	r2,-36(fp)
     a10:	e0bff717 	ldw	r2,-36(fp)
     a14:	10800a10 	cmplti	r2,r2,40
     a18:	103fd71e 	bne	r2,zero,978 <http_recv+0x8c>
             ((char *)data + 4)[i] == '\n') {
            ((char *)data + 4)[i] = 0;
          }
        }

        if (*(char *)(data + 4) == '/' &&
     a1c:	e0bff917 	ldw	r2,-28(fp)
     a20:	10800104 	addi	r2,r2,4
     a24:	10800003 	ldbu	r2,0(r2)
     a28:	10803fcc 	andi	r2,r2,255
     a2c:	1080201c 	xori	r2,r2,128
     a30:	10bfe004 	addi	r2,r2,-128
     a34:	10800bd8 	cmpnei	r2,r2,47
     a38:	10000d1e 	bne	r2,zero,a70 <http_recv+0x184>
           *(char *)(data + 5) == 0) {
     a3c:	e0bff917 	ldw	r2,-28(fp)
     a40:	10800144 	addi	r2,r2,5
     a44:	10800003 	ldbu	r2,0(r2)
             ((char *)data + 4)[i] == '\n') {
            ((char *)data + 4)[i] = 0;
          }
        }

        if (*(char *)(data + 4) == '/' &&
     a48:	10803fcc 	andi	r2,r2,255
     a4c:	1080201c 	xori	r2,r2,128
     a50:	10bfe004 	addi	r2,r2,-128
     a54:	1000061e 	bne	r2,zero,a70 <http_recv+0x184>
           *(char *)(data + 5) == 0) {
          fs_open("/index.html", &file);
     a58:	e0bffa04 	addi	r2,fp,-24
     a5c:	010000f4 	movhi	r4,3
     a60:	213c0e04 	addi	r4,r4,-4040
     a64:	100b883a 	mov	r5,r2
     a68:	00005900 	call	590 <fs_open>
     a6c:	00000c06 	br	aa0 <http_recv+0x1b4>
        } else if (!fs_open((char *)data + 4, &file)) {
     a70:	e0bff917 	ldw	r2,-28(fp)
     a74:	10c00104 	addi	r3,r2,4
     a78:	e0bffa04 	addi	r2,fp,-24
     a7c:	1809883a 	mov	r4,r3
     a80:	100b883a 	mov	r5,r2
     a84:	00005900 	call	590 <fs_open>
     a88:	1000051e 	bne	r2,zero,aa0 <http_recv+0x1b4>
          fs_open("/404.html", &file);
     a8c:	e0bffa04 	addi	r2,fp,-24
     a90:	010000f4 	movhi	r4,3
     a94:	213c1104 	addi	r4,r4,-4028
     a98:	100b883a 	mov	r5,r2
     a9c:	00005900 	call	590 <fs_open>
        }

        hs->file = file.data;
     aa0:	e0fffa17 	ldw	r3,-24(fp)
     aa4:	e0bff817 	ldw	r2,-32(fp)
     aa8:	10c00115 	stw	r3,4(r2)
        LWIP_ASSERT((file.len >= 0), "File length must be positive!");
        hs->left = file.len;
     aac:	e0bffb17 	ldw	r2,-20(fp)
     ab0:	1007883a 	mov	r3,r2
     ab4:	e0bff817 	ldw	r2,-32(fp)
     ab8:	10c00015 	stw	r3,0(r2)
        /* printf("data %p len %ld\n", hs->file, hs->left);*/

        pbuf_free(p);
     abc:	e13ffe17 	ldw	r4,-8(fp)
     ac0:	000aa340 	call	aa34 <pbuf_free>
        send_data(pcb, hs);
     ac4:	e13ffd17 	ldw	r4,-12(fp)
     ac8:	e17ff817 	ldw	r5,-32(fp)
     acc:	00006c40 	call	6c4 <send_data>

        /* Tell TCP that we wish be to informed of data that has been
           successfully sent by a call to the http_sent() function. */
        tcp_sent(pcb, http_sent);
     ad0:	e13ffd17 	ldw	r4,-12(fp)
     ad4:	01400034 	movhi	r5,0
     ad8:	29421f04 	addi	r5,r5,2172
     adc:	000df900 	call	df90 <tcp_sent>
     ae0:	00000806 	br	b04 <http_recv+0x218>
      } else {
        pbuf_free(p);
     ae4:	e13ffe17 	ldw	r4,-8(fp)
     ae8:	000aa340 	call	aa34 <pbuf_free>
        close_conn(pcb, hs);
     aec:	e13ffd17 	ldw	r4,-12(fp)
     af0:	e17ff817 	ldw	r5,-32(fp)
     af4:	00006640 	call	664 <close_conn>
     af8:	00000206 	br	b04 <http_recv+0x218>
      }
    } else {
      pbuf_free(p);
     afc:	e13ffe17 	ldw	r4,-8(fp)
     b00:	000aa340 	call	aa34 <pbuf_free>
    }
  }

  if (err == ERR_OK && p == NULL) {
     b04:	e0bfff07 	ldb	r2,-4(fp)
     b08:	1000051e 	bne	r2,zero,b20 <http_recv+0x234>
     b0c:	e0bffe17 	ldw	r2,-8(fp)
     b10:	1000031e 	bne	r2,zero,b20 <http_recv+0x234>
    close_conn(pcb, hs);
     b14:	e13ffd17 	ldw	r4,-12(fp)
     b18:	e17ff817 	ldw	r5,-32(fp)
     b1c:	00006640 	call	664 <close_conn>
  }
  return ERR_OK;
     b20:	0005883a 	mov	r2,zero
}
     b24:	e037883a 	mov	sp,fp
     b28:	dfc00117 	ldw	ra,4(sp)
     b2c:	df000017 	ldw	fp,0(sp)
     b30:	dec00204 	addi	sp,sp,8
     b34:	f800283a 	ret

00000b38 <http_accept>:
/*-----------------------------------------------------------------------------------*/
static err_t
http_accept(void *arg, struct tcp_pcb *pcb, err_t err)
{
     b38:	defff904 	addi	sp,sp,-28
     b3c:	dfc00615 	stw	ra,24(sp)
     b40:	df000515 	stw	fp,20(sp)
     b44:	df000504 	addi	fp,sp,20
     b48:	e13ffd15 	stw	r4,-12(fp)
     b4c:	e17ffe15 	stw	r5,-8(fp)
     b50:	3005883a 	mov	r2,r6
     b54:	e0bfff05 	stb	r2,-4(fp)
  struct http_state *hs;
  struct tcp_pcb_listen *lpcb = (struct tcp_pcb_listen*)arg;
     b58:	e0bffd17 	ldw	r2,-12(fp)
     b5c:	e0bffb15 	stw	r2,-20(fp)

  LWIP_UNUSED_ARG(err);

  /* Decrease the listen backlog counter */
  tcp_accepted(lpcb);
     b60:	e0bffb17 	ldw	r2,-20(fp)
     b64:	10800617 	ldw	r2,24(r2)
     b68:	10800060 	cmpeqi	r2,r2,1
     b6c:	1000091e 	bne	r2,zero,b94 <http_accept+0x5c>
     b70:	010000f4 	movhi	r4,3
     b74:	213c1404 	addi	r4,r4,-4016
     b78:	014000f4 	movhi	r5,3
     b7c:	297c1e04 	addi	r5,r5,-3976
     b80:	01803584 	movi	r6,214
     b84:	01c000f4 	movhi	r7,3
     b88:	39fc2a04 	addi	r7,r7,-3928
     b8c:	00193f00 	call	193f0 <printf>
     b90:	003fff06 	br	b90 <http_accept+0x58>

  tcp_setprio(pcb, TCP_PRIO_MIN);
     b94:	e13ffe17 	ldw	r4,-8(fp)
     b98:	01400044 	movi	r5,1
     b9c:	000da600 	call	da60 <tcp_setprio>
  
  /* Allocate memory for the structure that holds the state of the
     connection. */
  hs = (struct http_state *)mem_malloc(sizeof(struct http_state));
     ba0:	01000304 	movi	r4,12
     ba4:	0008fcc0 	call	8fcc <mem_malloc>
     ba8:	e0bffc15 	stw	r2,-16(fp)

  if (hs == NULL) {
     bac:	e0bffc17 	ldw	r2,-16(fp)
     bb0:	1000051e 	bne	r2,zero,bc8 <http_accept+0x90>
    printf("http_accept: Out of memory\n");
     bb4:	010000f4 	movhi	r4,3
     bb8:	213c2e04 	addi	r4,r4,-3912
     bbc:	001965c0 	call	1965c <puts>
    return ERR_MEM;
     bc0:	00bfffc4 	movi	r2,-1
     bc4:	00001706 	br	c24 <http_accept+0xec>
  }
  
  /* Initialize the structure. */
  hs->file = NULL;
     bc8:	e0bffc17 	ldw	r2,-16(fp)
     bcc:	10000115 	stw	zero,4(r2)
  hs->left = 0;
     bd0:	e0bffc17 	ldw	r2,-16(fp)
     bd4:	10000015 	stw	zero,0(r2)
  hs->retries = 0;
     bd8:	e0bffc17 	ldw	r2,-16(fp)
     bdc:	10000205 	stb	zero,8(r2)
  
  /* Tell TCP that this is the structure we wish to be passed for our
     callbacks. */
  tcp_arg(pcb, hs);
     be0:	e13ffe17 	ldw	r4,-8(fp)
     be4:	e17ffc17 	ldw	r5,-16(fp)
     be8:	000def40 	call	def4 <tcp_arg>

  /* Tell TCP that we wish to be informed of incoming data by a call
     to the http_recv() function. */
  tcp_recv(pcb, http_recv);
     bec:	e13ffe17 	ldw	r4,-8(fp)
     bf0:	01400034 	movhi	r5,0
     bf4:	29423b04 	addi	r5,r5,2284
     bf8:	000df240 	call	df24 <tcp_recv>

  tcp_err(pcb, conn_err);
     bfc:	e13ffe17 	ldw	r4,-8(fp)
     c00:	01400034 	movhi	r5,0
     c04:	29418904 	addi	r5,r5,1572
     c08:	000dffc0 	call	dffc <tcp_err>
  
  tcp_poll(pcb, http_poll, 4);
     c0c:	e13ffe17 	ldw	r4,-8(fp)
     c10:	01400034 	movhi	r5,0
     c14:	2941ee04 	addi	r5,r5,1976
     c18:	01800104 	movi	r6,4
     c1c:	000e0980 	call	e098 <tcp_poll>

  return ERR_OK;
     c20:	0005883a 	mov	r2,zero
}
     c24:	e037883a 	mov	sp,fp
     c28:	dfc00117 	ldw	ra,4(sp)
     c2c:	df000017 	ldw	fp,0(sp)
     c30:	dec00204 	addi	sp,sp,8
     c34:	f800283a 	ret

00000c38 <httpd_init>:
/*-----------------------------------------------------------------------------------*/
void
httpd_init(void)
{
     c38:	defffd04 	addi	sp,sp,-12
     c3c:	dfc00215 	stw	ra,8(sp)
     c40:	df000115 	stw	fp,4(sp)
     c44:	df000104 	addi	fp,sp,4
  struct tcp_pcb *pcb;

  pcb = tcp_new();
     c48:	000dec80 	call	dec8 <tcp_new>
     c4c:	e0bfff15 	stw	r2,-4(fp)
  tcp_bind(pcb, IP_ADDR_ANY, 80);
     c50:	e13fff17 	ldw	r4,-4(fp)
     c54:	014000f4 	movhi	r5,3
     c58:	29557404 	addi	r5,r5,21968
     c5c:	01801404 	movi	r6,80
     c60:	000c55c0 	call	c55c <tcp_bind>
  pcb = tcp_listen(pcb);
     c64:	e13fff17 	ldw	r4,-4(fp)
     c68:	01403fc4 	movi	r5,255
     c6c:	000c7180 	call	c718 <tcp_listen_with_backlog>
     c70:	e0bfff15 	stw	r2,-4(fp)
  tcp_arg(pcb, pcb);
     c74:	e13fff17 	ldw	r4,-4(fp)
     c78:	e17fff17 	ldw	r5,-4(fp)
     c7c:	000def40 	call	def4 <tcp_arg>
  tcp_accept(pcb, http_accept);
     c80:	e13fff17 	ldw	r4,-4(fp)
     c84:	01400034 	movhi	r5,0
     c88:	2942ce04 	addi	r5,r5,2872
     c8c:	000e0680 	call	e068 <tcp_accept>
}
     c90:	e037883a 	mov	sp,fp
     c94:	dfc00117 	ldw	ra,4(sp)
     c98:	df000017 	ldw	fp,0(sp)
     c9c:	dec00204 	addi	sp,sp,8
     ca0:	f800283a 	ret

00000ca4 <tse_mac_init>:
 * @API TYPE: Internal
 * @Param iface index of the NET structure associated with TSE instance
 * @Return 0 if ok, else -1 if error
 */
int tse_mac_init(int iface, struct ethernetif *ethernetif)
{
     ca4:	defff004 	addi	sp,sp,-64
     ca8:	dfc00f15 	stw	ra,60(sp)
     cac:	df000e15 	stw	fp,56(sp)
     cb0:	df000e04 	addi	fp,sp,56
     cb4:	e13ffe15 	stw	r4,-8(fp)
     cb8:	e17fff15 	stw	r5,-4(fp)
   int speed, duplex, result;
   int x;
   
   alt_sgdma_dev *sgdma_tx_dev;
   alt_sgdma_dev *sgdma_rx_dev;
   alt_tse_system_info* tse_hw = (alt_tse_system_info *) tse[iface].tse;
     cbc:	00c00134 	movhi	r3,4
     cc0:	18d77b04 	addi	r3,r3,24044
     cc4:	e0bffe17 	ldw	r2,-8(fp)
     cc8:	1004917a 	slli	r2,r2,5
     ccc:	1885883a 	add	r2,r3,r2
     cd0:	10800704 	addi	r2,r2,28
     cd4:	10800017 	ldw	r2,0(r2)
     cd8:	e0bff715 	stw	r2,-36(fp)
   np_tse_mac *mi_base;
   alt_tse_mac_info *pmac_info;
   
   dprintf(("[tse_mac_init]\n"));
     cdc:	010000f4 	movhi	r4,3
     ce0:	213c3504 	addi	r4,r4,-3884
     ce4:	001965c0 	call	1965c <puts>
#ifdef PRINTIF
   dprintf(("tse_mac_init %d\n", iface));
#endif    
   // These lines were done in prep_tse_mac 
   tse_hw = &tse_mac_device[iface];	
     ce8:	e0bffe17 	ldw	r2,-8(fp)
     cec:	10c01224 	muli	r3,r2,72
     cf0:	008000f4 	movhi	r2,3
     cf4:	108d0b04 	addi	r2,r2,13356
     cf8:	1885883a 	add	r2,r3,r2
     cfc:	e0bff715 	stw	r2,-36(fp)
   tse[iface].tse = tse_hw;
     d00:	00c00134 	movhi	r3,4
     d04:	18d77b04 	addi	r3,r3,24044
     d08:	e0bffe17 	ldw	r2,-8(fp)
     d0c:	1004917a 	slli	r2,r2,5
     d10:	1885883a 	add	r2,r3,r2
     d14:	10800704 	addi	r2,r2,28
     d18:	e0fff717 	ldw	r3,-36(fp)
     d1c:	10c00015 	stw	r3,0(r2)
	
   // Store ethernetif for access, and the tse in ethernetif for access in tse_mac_raw_send/tse_mac_rcv
   tse[iface].ethernetif = ethernetif;
     d20:	00c00134 	movhi	r3,4
     d24:	18d77b04 	addi	r3,r3,24044
     d28:	e0bffe17 	ldw	r2,-8(fp)
     d2c:	1004917a 	slli	r2,r2,5
     d30:	1885883a 	add	r2,r3,r2
     d34:	10800604 	addi	r2,r2,24
     d38:	e0ffff17 	ldw	r3,-4(fp)
     d3c:	10c00015 	stw	r3,0(r2)
   ethernetif->iface = iface;
     d40:	e0bfff17 	ldw	r2,-4(fp)
     d44:	e0fffe17 	ldw	r3,-8(fp)
     d48:	10c00115 	stw	r3,4(r2)
   ethernetif->tse_info = &tse[iface];
     d4c:	e0bffe17 	ldw	r2,-8(fp)
     d50:	1006917a 	slli	r3,r2,5
     d54:	00800134 	movhi	r2,4
     d58:	10977b04 	addi	r2,r2,24044
     d5c:	1887883a 	add	r3,r3,r2
     d60:	e0bfff17 	ldw	r2,-4(fp)
     d64:	10c01615 	stw	r3,88(r2)

   if (tse_hw->ext_desc_mem == 1)
     d68:	e0bff717 	ldw	r2,-36(fp)
     d6c:	10800783 	ldbu	r2,30(r2)
     d70:	10803fcc 	andi	r2,r2,255
     d74:	10800058 	cmpnei	r2,r2,1
     d78:	10000b1e 	bne	r2,zero,da8 <tse_mac_init+0x104>
      tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
     d7c:	e0bff717 	ldw	r2,-36(fp)
     d80:	10800817 	ldw	r2,32(r2)
     d84:	1007883a 	mov	r3,r2
     d88:	01000134 	movhi	r4,4
     d8c:	21177b04 	addi	r4,r4,24044
     d90:	e0bffe17 	ldw	r2,-8(fp)
     d94:	1004917a 	slli	r2,r2,5
     d98:	2085883a 	add	r2,r4,r2
     d9c:	10800504 	addi	r2,r2,20
     da0:	10c00015 	stw	r3,0(r2)
     da4:	00001206 	br	df0 <tse_mac_init+0x14c>
   else
      {
      unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
     da8:	01002804 	movi	r4,160
     dac:	00224500 	call	22450 <alt_uncached_malloc>
     db0:	e0bff615 	stw	r2,-40(fp)
    
      while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
     db4:	00000306 	br	dc4 <tse_mac_init+0x120>
         temp_desc++;
     db8:	e0bff617 	ldw	r2,-40(fp)
     dbc:	10800044 	addi	r2,r2,1
     dc0:	e0bff615 	stw	r2,-40(fp)
      tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
   else
      {
      unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
    
      while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
     dc4:	e0bff617 	ldw	r2,-40(fp)
     dc8:	108007cc 	andi	r2,r2,31
     dcc:	103ffa1e 	bne	r2,zero,db8 <tse_mac_init+0x114>
         temp_desc++;
      tse[iface].desc = (alt_sgdma_descriptor *) temp_desc;
     dd0:	00c00134 	movhi	r3,4
     dd4:	18d77b04 	addi	r3,r3,24044
     dd8:	e0bffe17 	ldw	r2,-8(fp)
     ddc:	1004917a 	slli	r2,r2,5
     de0:	1885883a 	add	r2,r3,r2
     de4:	10800504 	addi	r2,r2,20
     de8:	e0fff617 	ldw	r3,-40(fp)
     dec:	10c00015 	stw	r3,0(r2)
      }

   
   /* Get the Rx and Tx SGDMA addresses */
   sgdma_tx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_tx);
     df0:	e0bff717 	ldw	r2,-36(fp)
     df4:	10800517 	ldw	r2,20(r2)
     df8:	1009883a 	mov	r4,r2
     dfc:	00264d80 	call	264d8 <alt_avalon_sgdma_open>
     e00:	e0bff815 	stw	r2,-32(fp)
   if(!sgdma_tx_dev) 
     e04:	e0bff817 	ldw	r2,-32(fp)
     e08:	1000051e 	bne	r2,zero,e20 <tse_mac_init+0x17c>
      {
      dprintf(("[triple_speed_ethernet_init] Error opening TX SGDMA\n"));
     e0c:	010000f4 	movhi	r4,3
     e10:	213c3904 	addi	r4,r4,-3868
     e14:	001965c0 	call	1965c <puts>
      return ENP_RESOURCE;
     e18:	00bffa84 	movi	r2,-22
     e1c:	0001b606 	br	14f8 <tse_mac_init+0x854>
      }
  
   sgdma_rx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_rx);
     e20:	e0bff717 	ldw	r2,-36(fp)
     e24:	10800617 	ldw	r2,24(r2)
     e28:	1009883a 	mov	r4,r2
     e2c:	00264d80 	call	264d8 <alt_avalon_sgdma_open>
     e30:	e0bff915 	stw	r2,-28(fp)
   if(!sgdma_rx_dev) 
     e34:	e0bff917 	ldw	r2,-28(fp)
     e38:	1000051e 	bne	r2,zero,e50 <tse_mac_init+0x1ac>
      {
      dprintf(("[triple_speed_ethernet_init] Error opening RX SGDMA\n"));
     e3c:	010000f4 	movhi	r4,3
     e40:	213c4604 	addi	r4,r4,-3816
     e44:	001965c0 	call	1965c <puts>
      return ENP_RESOURCE;
     e48:	00bffa84 	movi	r2,-22
     e4c:	0001aa06 	br	14f8 <tse_mac_init+0x854>
      }


   /* Initialize mtip_mac_trans_info structure with values from <system.h>*/

   tse_mac_initTransInfo2(&tse[iface].mi, (int)tse_hw->tse_mac_base,
     e50:	e0bffe17 	ldw	r2,-8(fp)
     e54:	1006917a 	slli	r3,r2,5
     e58:	00800134 	movhi	r2,4
     e5c:	10977b04 	addi	r2,r2,24044
     e60:	1889883a 	add	r4,r3,r2
     e64:	e0bff717 	ldw	r2,-36(fp)
     e68:	11400017 	ldw	r5,0(r2)
     e6c:	e0fff817 	ldw	r3,-32(fp)
     e70:	e0bff917 	ldw	r2,-28(fp)
     e74:	d8000015 	stw	zero,0(sp)
     e78:	180d883a 	mov	r6,r3
     e7c:	100f883a 	mov	r7,r2
     e80:	0026df00 	call	26df0 <tse_mac_initTransInfo2>
                                   (unsigned int)sgdma_tx_dev,            
                                   (unsigned int)sgdma_rx_dev,
                                   0);
   mi_base = tse[iface].mi.base;
     e84:	00c00134 	movhi	r3,4
     e88:	18d77b04 	addi	r3,r3,24044
     e8c:	e0bffe17 	ldw	r2,-8(fp)
     e90:	1004917a 	slli	r2,r2,5
     e94:	1885883a 	add	r2,r3,r2
     e98:	10800017 	ldw	r2,0(r2)
     e9c:	e0bffa15 	stw	r2,-24(fp)

   IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base,ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
     ea0:	00c00134 	movhi	r3,4
     ea4:	18d77b04 	addi	r3,r3,24044
     ea8:	e0bffe17 	ldw	r2,-8(fp)
     eac:	1004917a 	slli	r2,r2,5
     eb0:	1885883a 	add	r2,r3,r2
     eb4:	10800204 	addi	r2,r2,8
     eb8:	10800017 	ldw	r2,0(r2)
     ebc:	10800317 	ldw	r2,12(r2)
     ec0:	10800404 	addi	r2,r2,16
     ec4:	00c00074 	movhi	r3,1
     ec8:	10c00035 	stwio	r3,0(r2)
   IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base, 0x0);
     ecc:	00c00134 	movhi	r3,4
     ed0:	18d77b04 	addi	r3,r3,24044
     ed4:	e0bffe17 	ldw	r2,-8(fp)
     ed8:	1004917a 	slli	r2,r2,5
     edc:	1885883a 	add	r2,r3,r2
     ee0:	10800204 	addi	r2,r2,8
     ee4:	10800017 	ldw	r2,0(r2)
     ee8:	10800317 	ldw	r2,12(r2)
     eec:	10800404 	addi	r2,r2,16
     ef0:	0007883a 	mov	r3,zero
     ef4:	10c00035 	stwio	r3,0(r2)
   
   /* reset the PHY if necessary */
   result = getPHYSpeed(tse[iface].mi.base);
     ef8:	00c00134 	movhi	r3,4
     efc:	18d77b04 	addi	r3,r3,24044
     f00:	e0bffe17 	ldw	r2,-8(fp)
     f04:	1004917a 	slli	r2,r2,5
     f08:	1885883a 	add	r2,r3,r2
     f0c:	10800017 	ldw	r2,0(r2)
     f10:	1009883a 	mov	r4,r2
     f14:	00282700 	call	28270 <getPHYSpeed>
     f18:	e0bffb15 	stw	r2,-20(fp)
   speed  = (result >> 1) & 0x07;
     f1c:	e0bffb17 	ldw	r2,-20(fp)
     f20:	1005d07a 	srai	r2,r2,1
     f24:	108001cc 	andi	r2,r2,7
     f28:	e0bffc15 	stw	r2,-16(fp)
   duplex = result & 0x01;
     f2c:	e0bffb17 	ldw	r2,-20(fp)
     f30:	1080004c 	andi	r2,r2,1
     f34:	e0bff415 	stw	r2,-48(fp)

   /* reset the mac */ 
   IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base,
     f38:	00c00134 	movhi	r3,4
     f3c:	18d77b04 	addi	r3,r3,24044
     f40:	e0bffe17 	ldw	r2,-8(fp)
     f44:	1004917a 	slli	r2,r2,5
     f48:	1885883a 	add	r2,r3,r2
     f4c:	10800017 	ldw	r2,0(r2)
     f50:	10800204 	addi	r2,r2,8
     f54:	00c800c4 	movi	r3,8195
     f58:	10c00035 	stwio	r3,0(r2)
                             mmac_cc_SW_RESET_mask | 
                             mmac_cc_TX_ENA_mask | 
                             mmac_cc_RX_ENA_mask);
  
   x=0;
     f5c:	e03ff515 	stw	zero,-44(fp)
   while(IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) & 
     f60:	00000706 	br	f80 <tse_mac_init+0x2dc>
         ALTERA_TSEMAC_CMD_SW_RESET_MSK) 
      {
      if( x++ > 10000 ) 
     f64:	e0bff517 	ldw	r2,-44(fp)
     f68:	1089c448 	cmpgei	r2,r2,10001
     f6c:	e0fff517 	ldw	r3,-44(fp)
     f70:	18c00044 	addi	r3,r3,1
     f74:	e0fff515 	stw	r3,-44(fp)
     f78:	10803fcc 	andi	r2,r2,255
     f7c:	10000b1e 	bne	r2,zero,fac <tse_mac_init+0x308>
                             mmac_cc_SW_RESET_mask | 
                             mmac_cc_TX_ENA_mask | 
                             mmac_cc_RX_ENA_mask);
  
   x=0;
   while(IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) & 
     f80:	00c00134 	movhi	r3,4
     f84:	18d77b04 	addi	r3,r3,24044
     f88:	e0bffe17 	ldw	r2,-8(fp)
     f8c:	1004917a 	slli	r2,r2,5
     f90:	1885883a 	add	r2,r3,r2
     f94:	10800017 	ldw	r2,0(r2)
     f98:	10800204 	addi	r2,r2,8
     f9c:	10800037 	ldwio	r2,0(r2)
     fa0:	1088000c 	andi	r2,r2,8192
     fa4:	103fef1e 	bne	r2,zero,f64 <tse_mac_init+0x2c0>
     fa8:	00000106 	br	fb0 <tse_mac_init+0x30c>
         ALTERA_TSEMAC_CMD_SW_RESET_MSK) 
      {
      if( x++ > 10000 ) 
         break;
     fac:	0001883a 	nop
      }
  
   if(x >= 10000)
     fb0:	e0bff517 	ldw	r2,-44(fp)
     fb4:	1089c410 	cmplti	r2,r2,10000
     fb8:	1000031e 	bne	r2,zero,fc8 <tse_mac_init+0x324>
      dprintf(("TSEMAC SW reset bit never cleared!\n"));
     fbc:	010000f4 	movhi	r4,3
     fc0:	213c5304 	addi	r4,r4,-3764
     fc4:	001965c0 	call	1965c <puts>

   dat = IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base);
     fc8:	00c00134 	movhi	r3,4
     fcc:	18d77b04 	addi	r3,r3,24044
     fd0:	e0bffe17 	ldw	r2,-8(fp)
     fd4:	1004917a 	slli	r2,r2,5
     fd8:	1885883a 	add	r2,r3,r2
     fdc:	10800017 	ldw	r2,0(r2)
     fe0:	10800204 	addi	r2,r2,8
     fe4:	10800037 	ldwio	r2,0(r2)
     fe8:	e0bff315 	stw	r2,-52(fp)
   if( (dat & 0x03) != 0 ) 
     fec:	e0bff317 	ldw	r2,-52(fp)
     ff0:	108000cc 	andi	r2,r2,3
     ff4:	10000526 	beq	r2,zero,100c <tse_mac_init+0x368>
      printf("WARN: RX/TX not disabled after reset... missing PHY clock? CMD_CONFIG=0x%08x\n", dat);
     ff8:	010000f4 	movhi	r4,3
     ffc:	213c5c04 	addi	r4,r4,-3728
    1000:	e17ff317 	ldw	r5,-52(fp)
    1004:	00193f00 	call	193f0 <printf>
    1008:	00000506 	br	1020 <tse_mac_init+0x37c>
   else
      printf("OK, x=%d, CMD_CONFIG=0x%08x\n", x, dat);
    100c:	010000f4 	movhi	r4,3
    1010:	213c7004 	addi	r4,r4,-3648
    1014:	e17ff517 	ldw	r5,-44(fp)
    1018:	e1bff317 	ldw	r6,-52(fp)
    101c:	00193f00 	call	193f0 <printf>
  
   /* Initialize MAC registers */
   IOWR_ALTERA_TSEMAC_FRM_LENGTH(mi_base, PBUF_POOL_BUFSIZE+ETH_PAD_SIZE); 
    1020:	e0bffa17 	ldw	r2,-24(fp)
    1024:	10800504 	addi	r2,r2,20
    1028:	00c17b84 	movi	r3,1518
    102c:	10c00035 	stwio	r3,0(r2)
   IOWR_ALTERA_TSEMAC_RX_ALMOST_EMPTY(mi_base, 8);
    1030:	e0bffa17 	ldw	r2,-24(fp)
    1034:	10800b04 	addi	r2,r2,44
    1038:	00c00204 	movi	r3,8
    103c:	10c00035 	stwio	r3,0(r2)
   IOWR_ALTERA_TSEMAC_RX_ALMOST_FULL(mi_base, 8);
    1040:	e0bffa17 	ldw	r2,-24(fp)
    1044:	10800c04 	addi	r2,r2,48
    1048:	00c00204 	movi	r3,8
    104c:	10c00035 	stwio	r3,0(r2)
   IOWR_ALTERA_TSEMAC_TX_ALMOST_EMPTY(mi_base, 8);
    1050:	e0bffa17 	ldw	r2,-24(fp)
    1054:	10800d04 	addi	r2,r2,52
    1058:	00c00204 	movi	r3,8
    105c:	10c00035 	stwio	r3,0(r2)
   IOWR_ALTERA_TSEMAC_TX_ALMOST_FULL(mi_base,  3);
    1060:	e0bffa17 	ldw	r2,-24(fp)
    1064:	10800e04 	addi	r2,r2,56
    1068:	00c000c4 	movi	r3,3
    106c:	10c00035 	stwio	r3,0(r2)
   IOWR_ALTERA_TSEMAC_TX_SECTION_EMPTY(mi_base, tse_hw->tse_tx_depth - 16); //1024/4;  
    1070:	e0bffa17 	ldw	r2,-24(fp)
    1074:	10800904 	addi	r2,r2,36
    1078:	e0fff717 	ldw	r3,-36(fp)
    107c:	18c0010b 	ldhu	r3,4(r3)
    1080:	18ffffcc 	andi	r3,r3,65535
    1084:	18fffc04 	addi	r3,r3,-16
    1088:	10c00035 	stwio	r3,0(r2)
   IOWR_ALTERA_TSEMAC_TX_SECTION_FULL(mi_base,  0); //32/4; // start transmit when there are 48 bytes
    108c:	e0bffa17 	ldw	r2,-24(fp)
    1090:	10800a04 	addi	r2,r2,40
    1094:	0007883a 	mov	r3,zero
    1098:	10c00035 	stwio	r3,0(r2)
   IOWR_ALTERA_TSEMAC_RX_SECTION_EMPTY(mi_base, tse_hw->tse_rx_depth - 16); //4000/4);
    109c:	e0bffa17 	ldw	r2,-24(fp)
    10a0:	10800704 	addi	r2,r2,28
    10a4:	e0fff717 	ldw	r3,-36(fp)
    10a8:	18c0018b 	ldhu	r3,6(r3)
    10ac:	18ffffcc 	andi	r3,r3,65535
    10b0:	18fffc04 	addi	r3,r3,-16
    10b4:	10c00035 	stwio	r3,0(r2)
   IOWR_ALTERA_TSEMAC_RX_SECTION_FULL(mi_base,  0);
    10b8:	e0bffa17 	ldw	r2,-24(fp)
    10bc:	10800804 	addi	r2,r2,32
    10c0:	0007883a 	mov	r3,zero
    10c4:	10c00035 	stwio	r3,0(r2)
   
   /* Enable TX shift 16 for removing two bytes from the start of all transmitted frames */
   IOWR_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK);
    10c8:	00c00134 	movhi	r3,4
    10cc:	18d77b04 	addi	r3,r3,24044
    10d0:	e0bffe17 	ldw	r2,-8(fp)
    10d4:	1004917a 	slli	r2,r2,5
    10d8:	1885883a 	add	r2,r3,r2
    10dc:	10800017 	ldw	r2,0(r2)
    10e0:	10803a04 	addi	r2,r2,232
    10e4:	00c00134 	movhi	r3,4
    10e8:	10c00035 	stwio	r3,0(r2)
 
   /*
    * check if the MAC supports the 16-bit shift option allowing us
    * to send BIASed frames without copying. Used by the send function later.
    */
   if((IORD_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK) == 0)
    10ec:	00c00134 	movhi	r3,4
    10f0:	18d77b04 	addi	r3,r3,24044
    10f4:	e0bffe17 	ldw	r2,-8(fp)
    10f8:	1004917a 	slli	r2,r2,5
    10fc:	1885883a 	add	r2,r3,r2
    1100:	10800017 	ldw	r2,0(r2)
    1104:	10803a04 	addi	r2,r2,232
    1108:	10800037 	ldwio	r2,0(r2)
    110c:	1080012c 	andhi	r2,r2,4
    1110:	1000041e 	bne	r2,zero,1124 <tse_mac_init+0x480>
      {
      dprintf(("[tse_mac_init] Error: Incompatible %d value with TX_CMD_STAT register return TxShift16 value. \n",ETH_PAD_SIZE));
    1114:	01000084 	movi	r4,2
    1118:	00193f00 	call	193f0 <printf>
      return ERR_IF;
    111c:	00bffc44 	movi	r2,-15
    1120:	0000f506 	br	14f8 <tse_mac_init+0x854>
      }
  
   /* Enable RX shift 16 for alignment of all received frames on 16-bit start address */
   IOWR_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK);
    1124:	00c00134 	movhi	r3,4
    1128:	18d77b04 	addi	r3,r3,24044
    112c:	e0bffe17 	ldw	r2,-8(fp)
    1130:	1004917a 	slli	r2,r2,5
    1134:	1885883a 	add	r2,r3,r2
    1138:	10800017 	ldw	r2,0(r2)
    113c:	10803b04 	addi	r2,r2,236
    1140:	00c08034 	movhi	r3,512
    1144:	10c00035 	stwio	r3,0(r2)
 
   /* check if the MAC supports the 16-bit shift option at the RX CMD STATUS Register  */ 
   if((IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK) == 0)
    1148:	00c00134 	movhi	r3,4
    114c:	18d77b04 	addi	r3,r3,24044
    1150:	e0bffe17 	ldw	r2,-8(fp)
    1154:	1004917a 	slli	r2,r2,5
    1158:	1885883a 	add	r2,r3,r2
    115c:	10800017 	ldw	r2,0(r2)
    1160:	10803b04 	addi	r2,r2,236
    1164:	10800037 	ldwio	r2,0(r2)
    1168:	1080802c 	andhi	r2,r2,512
    116c:	1000041e 	bne	r2,zero,1180 <tse_mac_init+0x4dc>
      {
      dprintf(("[tse_mac_init] Error: Incompatible %d value with RX_CMD_STAT register return RxShift16 value. \n",ETH_PAD_SIZE));
    1170:	01000084 	movi	r4,2
    1174:	00193f00 	call	193f0 <printf>
      return ERR_IF;
    1178:	00bffc44 	movi	r2,-15
    117c:	0000de06 	br	14f8 <tse_mac_init+0x854>
      }
   
   /* enable MAC */
   dat = ALTERA_TSEMAC_CMD_TX_ENA_MSK       |
    1180:	00810034 	movhi	r2,1024
    1184:	108080c4 	addi	r2,r2,515
    1188:	e0bff315 	stw	r2,-52(fp)
         ALTERA_TSEMAC_CMD_LOOPBACK_MSK     |     // promiscuous mode
#endif
         ALTERA_TSEMAC_CMD_TX_ADDR_INS_MSK  |
         ALTERA_TSEMAC_CMD_RX_ERR_DISC_MSK;  /* automatically discard frames with CRC errors */
    
   if((result & ALT_TSE_E_AN_NOT_COMPLETE) == 0) 
    118c:	e0bffb17 	ldw	r2,-20(fp)
    1190:	1080022c 	andhi	r2,r2,8
    1194:	1000461e 	bne	r2,zero,12b0 <tse_mac_init+0x60c>
      {
	  speed = (result >> 1) & 0x07;
    1198:	e0bffb17 	ldw	r2,-20(fp)
    119c:	1005d07a 	srai	r2,r2,1
    11a0:	108001cc 	andi	r2,r2,7
    11a4:	e0bffc15 	stw	r2,-16(fp)
	  duplex = result & 0x01;
    11a8:	e0bffb17 	ldw	r2,-20(fp)
    11ac:	1080004c 	andi	r2,r2,1
    11b0:	e0bff415 	stw	r2,-48(fp)
  
      /* 1000 Mbps */
      if(speed == 0x01)
    11b4:	e0bffc17 	ldw	r2,-16(fp)
    11b8:	10800058 	cmpnei	r2,r2,1
    11bc:	1000121e 	bne	r2,zero,1208 <tse_mac_init+0x564>
         {
         dat |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
    11c0:	e0bff317 	ldw	r2,-52(fp)
    11c4:	10800214 	ori	r2,r2,8
    11c8:	e0bff315 	stw	r2,-52(fp)
         dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
    11cc:	e0fff317 	ldw	r3,-52(fp)
    11d0:	00bf8034 	movhi	r2,65024
    11d4:	10bfffc4 	addi	r2,r2,-1
    11d8:	1884703a 	and	r2,r3,r2
    11dc:	e0bff315 	stw	r2,-52(fp)
         tse[iface].ethernetif->link_speed = 1000;
    11e0:	00c00134 	movhi	r3,4
    11e4:	18d77b04 	addi	r3,r3,24044
    11e8:	e0bffe17 	ldw	r2,-8(fp)
    11ec:	1004917a 	slli	r2,r2,5
    11f0:	1885883a 	add	r2,r3,r2
    11f4:	10800604 	addi	r2,r2,24
    11f8:	10800017 	ldw	r2,0(r2)
    11fc:	00c0fa04 	movi	r3,1000
    1200:	10c00315 	stw	r3,12(r2)
    1204:	00003306 	br	12d4 <tse_mac_init+0x630>
         }
      /* 100 Mbps */
      else if(speed == 0x02)
    1208:	e0bffc17 	ldw	r2,-16(fp)
    120c:	10800098 	cmpnei	r2,r2,2
    1210:	1000131e 	bne	r2,zero,1260 <tse_mac_init+0x5bc>
         {
         dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
    1214:	e0fff317 	ldw	r3,-52(fp)
    1218:	00bffdc4 	movi	r2,-9
    121c:	1884703a 	and	r2,r3,r2
    1220:	e0bff315 	stw	r2,-52(fp)
         dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
    1224:	e0fff317 	ldw	r3,-52(fp)
    1228:	00bf8034 	movhi	r2,65024
    122c:	10bfffc4 	addi	r2,r2,-1
    1230:	1884703a 	and	r2,r3,r2
    1234:	e0bff315 	stw	r2,-52(fp)
         tse[iface].ethernetif->link_speed = 100;
    1238:	00c00134 	movhi	r3,4
    123c:	18d77b04 	addi	r3,r3,24044
    1240:	e0bffe17 	ldw	r2,-8(fp)
    1244:	1004917a 	slli	r2,r2,5
    1248:	1885883a 	add	r2,r3,r2
    124c:	10800604 	addi	r2,r2,24
    1250:	10800017 	ldw	r2,0(r2)
    1254:	00c01904 	movi	r3,100
    1258:	10c00315 	stw	r3,12(r2)
    125c:	00001d06 	br	12d4 <tse_mac_init+0x630>
         }
      /* 10 Mbps */
      else if(speed == 0x04)
    1260:	e0bffc17 	ldw	r2,-16(fp)
    1264:	10800118 	cmpnei	r2,r2,4
    1268:	10001a1e 	bne	r2,zero,12d4 <tse_mac_init+0x630>
         {
         dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
    126c:	e0fff317 	ldw	r3,-52(fp)
    1270:	00bffdc4 	movi	r2,-9
    1274:	1884703a 	and	r2,r3,r2
    1278:	e0bff315 	stw	r2,-52(fp)
         dat |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
    127c:	e0bff317 	ldw	r2,-52(fp)
    1280:	10808034 	orhi	r2,r2,512
    1284:	e0bff315 	stw	r2,-52(fp)
         tse[iface].ethernetif->link_speed = 10;
    1288:	00c00134 	movhi	r3,4
    128c:	18d77b04 	addi	r3,r3,24044
    1290:	e0bffe17 	ldw	r2,-8(fp)
    1294:	1004917a 	slli	r2,r2,5
    1298:	1885883a 	add	r2,r3,r2
    129c:	10800604 	addi	r2,r2,24
    12a0:	10800017 	ldw	r2,0(r2)
    12a4:	00c00284 	movi	r3,10
    12a8:	10c00315 	stw	r3,12(r2)
    12ac:	00000906 	br	12d4 <tse_mac_init+0x630>
         }
      }
   /* default to 100 Mbps if returned invalid speed */
   else
      {
      dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
    12b0:	e0fff317 	ldw	r3,-52(fp)
    12b4:	00bffdc4 	movi	r2,-9
    12b8:	1884703a 	and	r2,r3,r2
    12bc:	e0bff315 	stw	r2,-52(fp)
      dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
    12c0:	e0fff317 	ldw	r3,-52(fp)
    12c4:	00bf8034 	movhi	r2,65024
    12c8:	10bfffc4 	addi	r2,r2,-1
    12cc:	1884703a 	and	r2,r3,r2
    12d0:	e0bff315 	stw	r2,-52(fp)
      }
  
   /* Half Duplex */
   if(duplex == TSE_PHY_DUPLEX_HALF)
    12d4:	e0bff417 	ldw	r2,-48(fp)
    12d8:	10000c1e 	bne	r2,zero,130c <tse_mac_init+0x668>
      {
      dat |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
    12dc:	e0bff317 	ldw	r2,-52(fp)
    12e0:	10810014 	ori	r2,r2,1024
    12e4:	e0bff315 	stw	r2,-52(fp)
      tse[iface].ethernetif->full_duplex = 0;
    12e8:	00c00134 	movhi	r3,4
    12ec:	18d77b04 	addi	r3,r3,24044
    12f0:	e0bffe17 	ldw	r2,-8(fp)
    12f4:	1004917a 	slli	r2,r2,5
    12f8:	1885883a 	add	r2,r3,r2
    12fc:	10800604 	addi	r2,r2,24
    1300:	10800017 	ldw	r2,0(r2)
    1304:	10000415 	stw	zero,16(r2)
    1308:	00000d06 	br	1340 <tse_mac_init+0x69c>
      }
   /* Full Duplex */
   else
      {
      dat &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
    130c:	e0fff317 	ldw	r3,-52(fp)
    1310:	00beffc4 	movi	r2,-1025
    1314:	1884703a 	and	r2,r3,r2
    1318:	e0bff315 	stw	r2,-52(fp)
      tse[iface].ethernetif->full_duplex = 1;
    131c:	00c00134 	movhi	r3,4
    1320:	18d77b04 	addi	r3,r3,24044
    1324:	e0bffe17 	ldw	r2,-8(fp)
    1328:	1004917a 	slli	r2,r2,5
    132c:	1885883a 	add	r2,r3,r2
    1330:	10800604 	addi	r2,r2,24
    1334:	10800017 	ldw	r2,0(r2)
    1338:	00c00044 	movi	r3,1
    133c:	10c00415 	stw	r3,16(r2)
      }
          
   IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base, dat);
    1340:	00c00134 	movhi	r3,4
    1344:	18d77b04 	addi	r3,r3,24044
    1348:	e0bffe17 	ldw	r2,-8(fp)
    134c:	1004917a 	slli	r2,r2,5
    1350:	1885883a 	add	r2,r3,r2
    1354:	10800017 	ldw	r2,0(r2)
    1358:	10800204 	addi	r2,r2,8
    135c:	e0fff317 	ldw	r3,-52(fp)
    1360:	10c00035 	stwio	r3,0(r2)
   printf("\nMAC post-initialization: CMD_CONFIG=0x%08x\n", 
    IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base));
    1364:	00c00134 	movhi	r3,4
    1368:	18d77b04 	addi	r3,r3,24044
    136c:	e0bffe17 	ldw	r2,-8(fp)
    1370:	1004917a 	slli	r2,r2,5
    1374:	1885883a 	add	r2,r3,r2
    1378:	10800017 	ldw	r2,0(r2)
      dat &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
      tse[iface].ethernetif->full_duplex = 1;
      }
          
   IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base, dat);
   printf("\nMAC post-initialization: CMD_CONFIG=0x%08x\n", 
    137c:	10800204 	addi	r2,r2,8
    1380:	10800037 	ldwio	r2,0(r2)
    1384:	010000f4 	movhi	r4,3
    1388:	213c7804 	addi	r4,r4,-3616
    138c:	100b883a 	mov	r5,r2
    1390:	00193f00 	call	193f0 <printf>
    IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base));
  
   /* Set the MAC address */
     IOWR_ALTERA_TSEMAC_MAC_0(mi_base,
    1394:	e0bffa17 	ldw	r2,-24(fp)
    1398:	10800304 	addi	r2,r2,12
    139c:	e0ffff17 	ldw	r3,-4(fp)
    13a0:	18c00017 	ldw	r3,0(r3)
    13a4:	18c00003 	ldbu	r3,0(r3)
    13a8:	19003fcc 	andi	r4,r3,255
    13ac:	e0ffff17 	ldw	r3,-4(fp)
    13b0:	18c00017 	ldw	r3,0(r3)
    13b4:	18c00043 	ldbu	r3,1(r3)
    13b8:	18c03fcc 	andi	r3,r3,255
    13bc:	1806923a 	slli	r3,r3,8
    13c0:	20c8b03a 	or	r4,r4,r3
    13c4:	e0ffff17 	ldw	r3,-4(fp)
    13c8:	18c00017 	ldw	r3,0(r3)
    13cc:	18c00083 	ldbu	r3,2(r3)
    13d0:	18c03fcc 	andi	r3,r3,255
    13d4:	1806943a 	slli	r3,r3,16
    13d8:	20c8b03a 	or	r4,r4,r3
    13dc:	e0ffff17 	ldw	r3,-4(fp)
    13e0:	18c00017 	ldw	r3,0(r3)
    13e4:	18c000c3 	ldbu	r3,3(r3)
    13e8:	18c03fcc 	andi	r3,r3,255
    13ec:	1806963a 	slli	r3,r3,24
    13f0:	20c6b03a 	or	r3,r4,r3
    13f4:	10c00035 	stwio	r3,0(r2)
                             ((int)((unsigned char) ethernetif->ethaddr->addr[0]) |
                              (int)((unsigned char) ethernetif->ethaddr->addr[1] <<  8) |
                              (int)((unsigned char) ethernetif->ethaddr->addr[2] << 16) |
                              (int)((unsigned char) ethernetif->ethaddr->addr[3] << 24)));

     IOWR_ALTERA_TSEMAC_MAC_1(mi_base,
    13f8:	e0bffa17 	ldw	r2,-24(fp)
    13fc:	10800404 	addi	r2,r2,16
    1400:	e0ffff17 	ldw	r3,-4(fp)
    1404:	18c00017 	ldw	r3,0(r3)
    1408:	18c00103 	ldbu	r3,4(r3)
    140c:	19003fcc 	andi	r4,r3,255
    1410:	e0ffff17 	ldw	r3,-4(fp)
    1414:	18c00017 	ldw	r3,0(r3)
    1418:	18c00143 	ldbu	r3,5(r3)
    141c:	18c03fcc 	andi	r3,r3,255
    1420:	1806923a 	slli	r3,r3,8
    1424:	20c6b03a 	or	r3,r4,r3
    1428:	18ffffcc 	andi	r3,r3,65535
    142c:	10c00035 	stwio	r3,0(r2)
                             (((int)((unsigned char) ethernetif->ethaddr->addr[4]) |
                               (int)((unsigned char) ethernetif->ethaddr->addr[5] <<  8)) & 0xFFFF));
                                
   alt_avalon_sgdma_register_callback(tse[iface].mi.rx_sgdma,
    1430:	00c00134 	movhi	r3,4
    1434:	18d77b04 	addi	r3,r3,24044
    1438:	e0bffe17 	ldw	r2,-8(fp)
    143c:	1004917a 	slli	r2,r2,5
    1440:	1885883a 	add	r2,r3,r2
    1444:	10800204 	addi	r2,r2,8
    1448:	10c00017 	ldw	r3,0(r2)
#ifndef ALTERA_TSE_IRQ_R
        (alt_avalon_sgdma_callback)&tse_sgdmaRx_isr,
#else
        (alt_avalon_sgdma_callback)&ALTERA_TSE_IRQ_R,
#endif
        (alt_u16)ALTERA_TSE_SGDMA_INTR_MASK,(void*)(&tse[iface]));
    144c:	e0bffe17 	ldw	r2,-8(fp)
    1450:	1008917a 	slli	r4,r2,5
    1454:	00800134 	movhi	r2,4
    1458:	10977b04 	addi	r2,r2,24044
    145c:	2085883a 	add	r2,r4,r2

     IOWR_ALTERA_TSEMAC_MAC_1(mi_base,
                             (((int)((unsigned char) ethernetif->ethaddr->addr[4]) |
                               (int)((unsigned char) ethernetif->ethaddr->addr[5] <<  8)) & 0xFFFF));
                                
   alt_avalon_sgdma_register_callback(tse[iface].mi.rx_sgdma,
    1460:	1809883a 	mov	r4,r3
    1464:	01400034 	movhi	r5,0
    1468:	29457104 	addi	r5,r5,5572
    146c:	01800604 	movi	r6,24
    1470:	100f883a 	mov	r7,r2
    1474:	00263780 	call	26378 <alt_avalon_sgdma_register_callback>
#else
        (alt_avalon_sgdma_callback)&ALTERA_TSE_IRQ_R,
#endif
        (alt_u16)ALTERA_TSE_SGDMA_INTR_MASK,(void*)(&tse[iface]));
    
   tse_sgdma_read_init(&tse[iface]);
    1478:	e0bffe17 	ldw	r2,-8(fp)
    147c:	1006917a 	slli	r3,r2,5
    1480:	00800134 	movhi	r2,4
    1484:	10977b04 	addi	r2,r2,24044
    1488:	1885883a 	add	r2,r3,r2
    148c:	1009883a 	mov	r4,r2
    1490:	000150c0 	call	150c <tse_sgdma_read_init>
   //tse_sgdma_write_init(&tse[iface]);
   

   pmac_info = alt_tse_get_mac_info(mi_base);
    1494:	e13ffa17 	ldw	r4,-24(fp)
    1498:	002802c0 	call	2802c <alt_tse_get_mac_info>
    149c:	e0bffd15 	stw	r2,-12(fp)
   alt_tse_phy_wr_mdio_addr(pmac_info->pphy_info, pmac_info->pphy_info->mdio_address);
    14a0:	e0bffd17 	ldw	r2,-12(fp)
    14a4:	10c00117 	ldw	r3,4(r2)
    14a8:	e0bffd17 	ldw	r2,-12(fp)
    14ac:	10800117 	ldw	r2,4(r2)
    14b0:	10800003 	ldbu	r2,0(r2)
    14b4:	10803fcc 	andi	r2,r2,255
    14b8:	1809883a 	mov	r4,r3
    14bc:	100b883a 	mov	r5,r2
    14c0:	0028d2c0 	call	28d2c <alt_tse_phy_wr_mdio_addr>
   ethernetif->link_alive = alt_tse_phy_rd_mdio_reg(pmac_info->pphy_info, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) != 0;
    14c4:	e0bffd17 	ldw	r2,-12(fp)
    14c8:	10800117 	ldw	r2,4(r2)
    14cc:	1009883a 	mov	r4,r2
    14d0:	01400044 	movi	r5,1
    14d4:	01800144 	movi	r6,5
    14d8:	01c00044 	movi	r7,1
    14dc:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
    14e0:	1004c03a 	cmpne	r2,r2,zero
    14e4:	10c03fcc 	andi	r3,r2,255
    14e8:	e0bfff17 	ldw	r2,-4(fp)
    14ec:	10c00215 	stw	r3,8(r2)
   //IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base,ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
   //IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base, 0x0);
   //IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma, 0xff);
   

   return ethernetif->link_alive;
    14f0:	e0bfff17 	ldw	r2,-4(fp)
    14f4:	10800217 	ldw	r2,8(r2)
}
    14f8:	e037883a 	mov	sp,fp
    14fc:	dfc00117 	ldw	ra,4(sp)
    1500:	df000017 	ldw	fp,0(sp)
    1504:	dec00204 	addi	sp,sp,8
    1508:	f800283a 	ret

0000150c <tse_sgdma_read_init>:
 * 
 * @API TYPE - Internal
 * @return SUCCESS on success 
 */
int tse_sgdma_read_init(lwip_tse_info* tse_ptr)
{     
    150c:	defffb04 	addi	sp,sp,-20
    1510:	dfc00415 	stw	ra,16(sp)
    1514:	df000315 	stw	fp,12(sp)
    1518:	df000304 	addi	fp,sp,12
    151c:	e13fff15 	stw	r4,-4(fp)
   struct ethernetif *ethernetif;
  
   ethernetif = tse_ptr->ethernetif;
    1520:	e0bfff17 	ldw	r2,-4(fp)
    1524:	10800617 	ldw	r2,24(r2)
    1528:	e0bffe15 	stw	r2,-8(fp)
  
   alt_avalon_sgdma_construct_stream_to_mem_desc(
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
    152c:	e0bfff17 	ldw	r2,-4(fp)
    1530:	10800517 	ldw	r2,20(r2)
{     
   struct ethernetif *ethernetif;
  
   ethernetif = tse_ptr->ethernetif;
  
   alt_avalon_sgdma_construct_stream_to_mem_desc(
    1534:	11001004 	addi	r4,r2,64
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST],  // pointer to "next"
    1538:	e0bfff17 	ldw	r2,-4(fp)
    153c:	10800517 	ldw	r2,20(r2)
{     
   struct ethernetif *ethernetif;
  
   ethernetif = tse_ptr->ethernetif;
  
   alt_avalon_sgdma_construct_stream_to_mem_desc(
    1540:	10c01804 	addi	r3,r2,96
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST],  // pointer to "next"
         (alt_u32 *) ethernetif->lwipRxPbuf[tse_ptr->ethernetif->lwipRxIndexIsr]->payload,          // starting write_address
    1544:	e0bfff17 	ldw	r2,-4(fp)
    1548:	10800617 	ldw	r2,24(r2)
    154c:	10801317 	ldw	r2,76(r2)
    1550:	e17ffe17 	ldw	r5,-8(fp)
    1554:	108001c4 	addi	r2,r2,7
    1558:	1085883a 	add	r2,r2,r2
    155c:	1085883a 	add	r2,r2,r2
    1560:	2885883a 	add	r2,r5,r2
    1564:	10800017 	ldw	r2,0(r2)
    1568:	10800117 	ldw	r2,4(r2)
{     
   struct ethernetif *ethernetif;
  
   ethernetif = tse_ptr->ethernetif;
  
   alt_avalon_sgdma_construct_stream_to_mem_desc(
    156c:	d8000015 	stw	zero,0(sp)
    1570:	180b883a 	mov	r5,r3
    1574:	100d883a 	mov	r6,r2
    1578:	000f883a 	mov	r7,zero
    157c:	00261a40 	call	261a4 <alt_avalon_sgdma_construct_stream_to_mem_desc>
         (alt_u32 *) ethernetif->lwipRxPbuf[tse_ptr->ethernetif->lwipRxIndexIsr]->payload,          // starting write_address
         0,                                  // read until EOP
         0);          // don't write to constant address


   printf("[tse_sgdma_read_init] RX descriptor chain desc (%d depth) created\n",0); 
    1580:	010000f4 	movhi	r4,3
    1584:	213c8404 	addi	r4,r4,-3568
    1588:	000b883a 	mov	r5,zero
    158c:	00193f00 	call	193f0 <printf>
   
   tse_mac_aRxRead( &tse_ptr->mi, &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
    1590:	e0ffff17 	ldw	r3,-4(fp)
    1594:	e0bfff17 	ldw	r2,-4(fp)
    1598:	10800517 	ldw	r2,20(r2)
    159c:	10801004 	addi	r2,r2,64
    15a0:	1809883a 	mov	r4,r3
    15a4:	100b883a 	mov	r5,r2
    15a8:	0026f300 	call	26f30 <tse_mac_aRxRead>
  
   return SUCCESS;
    15ac:	0005883a 	mov	r2,zero
}
    15b0:	e037883a 	mov	sp,fp
    15b4:	dfc00117 	ldw	ra,4(sp)
    15b8:	df000017 	ldw	fp,0(sp)
    15bc:	dec00204 	addi	sp,sp,8
    15c0:	f800283a 	ret

000015c4 <tse_sgdmaRx_isr>:
 * @API TYPE - callback
 * @param  context  - context of the TSE MAC instance
 * @param  intnum - temporary storage
 */
int tse_sgdmaRx_isr(void * context, u_long intnum)
{
    15c4:	defffb04 	addi	sp,sp,-20
    15c8:	dfc00415 	stw	ra,16(sp)
    15cc:	df000315 	stw	fp,12(sp)
    15d0:	df000304 	addi	fp,sp,12
    15d4:	e13ffe15 	stw	r4,-8(fp)
    15d8:	e17fff15 	stw	r5,-4(fp)
   lwip_tse_info* tse_ptr = (lwip_tse_info *) context;
    15dc:	e0bffe17 	ldw	r2,-8(fp)
    15e0:	e0bffd15 	stw	r2,-12(fp)

   IOWR_ALTERA_AVALON_SGDMA_CONTROL(&tse_ptr->mi.rx_sgdma->base,ALTERA_AVALON_SGDMA_CONTROL_CLEAR_INTERRUPT_MSK);
    15e4:	e0bffd17 	ldw	r2,-12(fp)
    15e8:	10800217 	ldw	r2,8(r2)
    15ec:	10800304 	addi	r2,r2,12
    15f0:	10800404 	addi	r2,r2,16
    15f4:	00e00034 	movhi	r3,32768
    15f8:	10c00035 	stwio	r3,0(r2)
   tse_mac_rcv(tse_ptr->ethernetif);    
    15fc:	e0bffd17 	ldw	r2,-12(fp)
    1600:	10800617 	ldw	r2,24(r2)
    1604:	1009883a 	mov	r4,r2
    1608:	00017c80 	call	17c8 <tse_mac_rcv>
   tse_mac_aRxRead( &tse_ptr->mi, &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
    160c:	e0fffd17 	ldw	r3,-12(fp)
    1610:	e0bffd17 	ldw	r2,-12(fp)
    1614:	10800517 	ldw	r2,20(r2)
    1618:	10801004 	addi	r2,r2,64
    161c:	1809883a 	mov	r4,r3
    1620:	100b883a 	mov	r5,r2
    1624:	0026f300 	call	26f30 <tse_mac_aRxRead>
   IOWR_ALTERA_AVALON_SGDMA_CONTROL(&tse_ptr->mi.rx_sgdma->base, ALTERA_TSE_SGDMA_INTR_MASK);
    1628:	e0bffd17 	ldw	r2,-12(fp)
    162c:	10800217 	ldw	r2,8(r2)
    1630:	10800304 	addi	r2,r2,12
    1634:	10800404 	addi	r2,r2,16
    1638:	00c00604 	movi	r3,24
    163c:	10c00035 	stwio	r3,0(r2)
  
   return SUCCESS;
    1640:	0005883a 	mov	r2,zero
}
    1644:	e037883a 	mov	sp,fp
    1648:	dfc00117 	ldw	ra,4(sp)
    164c:	df000017 	ldw	fp,0(sp)
    1650:	dec00204 	addi	sp,sp,8
    1654:	f800283a 	ret

00001658 <tse_mac_raw_send>:
 * @param  data_bytes - number of bytes of the data payload to be sent to the MAC
 * @return SUCCESS if success, else a negative value
 */

err_t tse_mac_raw_send(struct netif *netif, struct pbuf *pkt)
{
    1658:	defe6a04 	addi	sp,sp,-1624
    165c:	dfc19515 	stw	ra,1620(sp)
    1660:	df019415 	stw	fp,1616(sp)
    1664:	df019404 	addi	fp,sp,1616
    1668:	e13ffe15 	stw	r4,-8(fp)
    166c:	e17fff15 	stw	r5,-4(fp)
   unsigned int       *ActualData;

   /* Intermediate buffers used for temporary copy of frames that cannot be directrly DMA'ed*/
   char buf2[1560];

   ethernetif = netif->state;
    1670:	e0bffe17 	ldw	r2,-8(fp)
    1674:	10800717 	ldw	r2,28(r2)
    1678:	e0be7215 	stw	r2,-1592(fp)
   tse_ptr = ethernetif->tse_info;
    167c:	e0be7217 	ldw	r2,-1592(fp)
    1680:	10801617 	ldw	r2,88(r2)
    1684:	e0be7315 	stw	r2,-1588(fp)
   mi = &tse_ptr->mi;
    1688:	e0be7317 	ldw	r2,-1588(fp)
    168c:	e0be7415 	stw	r2,-1584(fp)
  
   for(p = pkt; p != NULL; p = p->next)
    1690:	e0bfff17 	ldw	r2,-4(fp)
    1694:	e0be7015 	stw	r2,-1600(fp)
    1698:	00003b06 	br	1788 <tse_mac_raw_send+0x130>
      {
      data = p->payload;
    169c:	e0be7017 	ldw	r2,-1600(fp)
    16a0:	10800117 	ldw	r2,4(r2)
    16a4:	e0be7115 	stw	r2,-1596(fp)
      len = p->len;
    16a8:	e0be7017 	ldw	r2,-1600(fp)
    16ac:	1080028b 	ldhu	r2,10(r2)
    16b0:	10bfffcc 	andi	r2,r2,65535
    16b4:	e0be7515 	stw	r2,-1580(fp)
       
      if(((unsigned long)data & 0x03) != 0) 
    16b8:	e0be7117 	ldw	r2,-1596(fp)
    16bc:	108000cc 	andi	r2,r2,3
    16c0:	10000726 	beq	r2,zero,16e0 <tse_mac_raw_send+0x88>
         /* 
          * Copy data to temporary buffer <buf2>. This is done because of allignment 
          * issues. The SGDMA cannot copy the data directly from (data + ETH_PAD_SIZE)
          * because it needs a 32-bit alligned address space. 
          */
         memcpy(buf2,data,len);
    16c4:	e0be7804 	addi	r2,fp,-1568
    16c8:	1009883a 	mov	r4,r2
    16cc:	e17e7117 	ldw	r5,-1596(fp)
    16d0:	e1be7517 	ldw	r6,-1580(fp)
    16d4:	00191f00 	call	191f0 <memcpy>
         data = (alt_u32 *)buf2;
    16d8:	e0be7804 	addi	r2,fp,-1568
    16dc:	e0be7115 	stw	r2,-1596(fp)
         }  
       
      ActualData = (void *)alt_remap_uncached (data, len);
    16e0:	e13e7117 	ldw	r4,-1596(fp)
    16e4:	e17e7517 	ldw	r5,-1580(fp)
    16e8:	00221400 	call	22140 <alt_remap_uncached>
    16ec:	e0be7615 	stw	r2,-1576(fp)
      /* Write data to Tx FIFO using the DMA */
      alt_avalon_sgdma_construct_mem_to_stream_desc(
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST], // descriptor I want to work with
    16f0:	e0be7317 	ldw	r2,-1588(fp)
         data = (alt_u32 *)buf2;
         }  
       
      ActualData = (void *)alt_remap_uncached (data, len);
      /* Write data to Tx FIFO using the DMA */
      alt_avalon_sgdma_construct_mem_to_stream_desc(
    16f4:	11000517 	ldw	r4,20(r2)
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST], // descriptor I want to work with
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_TX_SGDMA_DESC_OFST],// pointer to "next"
    16f8:	e0be7317 	ldw	r2,-1588(fp)
    16fc:	10800517 	ldw	r2,20(r2)
         data = (alt_u32 *)buf2;
         }  
       
      ActualData = (void *)alt_remap_uncached (data, len);
      /* Write data to Tx FIFO using the DMA */
      alt_avalon_sgdma_construct_mem_to_stream_desc(
    1700:	10c00804 	addi	r3,r2,32
    1704:	e0be7517 	ldw	r2,-1580(fp)
    1708:	10bfffcc 	andi	r2,r2,65535
    170c:	e1be7017 	ldw	r6,-1600(fp)
    1710:	e17fff17 	ldw	r5,-4(fp)
    1714:	314b003a 	cmpeq	r5,r6,r5
    1718:	29803fcc 	andi	r6,r5,255
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_TX_SGDMA_DESC_OFST],// pointer to "next"
           (alt_u32*)ActualData,                    // starting read address
           (len),                                   // # bytes
           0,                                       // don't read from constant address
           p == pkt,                                // generate sop
           p->next == NULL,                         // generate endofpacket signal
    171c:	e17e7017 	ldw	r5,-1600(fp)
    1720:	29400017 	ldw	r5,0(r5)
         data = (alt_u32 *)buf2;
         }  
       
      ActualData = (void *)alt_remap_uncached (data, len);
      /* Write data to Tx FIFO using the DMA */
      alt_avalon_sgdma_construct_mem_to_stream_desc(
    1724:	280b003a 	cmpeq	r5,r5,zero
    1728:	29403fcc 	andi	r5,r5,255
    172c:	d8000015 	stw	zero,0(sp)
    1730:	d9800115 	stw	r6,4(sp)
    1734:	d9400215 	stw	r5,8(sp)
    1738:	d8000315 	stw	zero,12(sp)
    173c:	180b883a 	mov	r5,r3
    1740:	e1be7617 	ldw	r6,-1576(fp)
    1744:	100f883a 	mov	r7,r2
    1748:	00262740 	call	26274 <alt_avalon_sgdma_construct_mem_to_stream_desc>
           0,                                       // don't read from constant address
           p == pkt,                                // generate sop
           p->next == NULL,                         // generate endofpacket signal
           0);                                      // atlantic channel (don't know/don't care: set to 0)
                  
      tx_length = tse_mac_sTxWrite(mi,&tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST]);
    174c:	e0be7317 	ldw	r2,-1588(fp)
    1750:	10800517 	ldw	r2,20(r2)
    1754:	e13e7417 	ldw	r4,-1584(fp)
    1758:	100b883a 	mov	r5,r2
    175c:	0026e500 	call	26e50 <tse_mac_sTxWrite>
    1760:	e0be7715 	stw	r2,-1572(fp)
      ethernetif->bytes_sent += tx_length;
    1764:	e0be7217 	ldw	r2,-1592(fp)
    1768:	10c00517 	ldw	r3,20(r2)
    176c:	e0be7717 	ldw	r2,-1572(fp)
    1770:	1887883a 	add	r3,r3,r2
    1774:	e0be7217 	ldw	r2,-1592(fp)
    1778:	10c00515 	stw	r3,20(r2)

   ethernetif = netif->state;
   tse_ptr = ethernetif->tse_info;
   mi = &tse_ptr->mi;
  
   for(p = pkt; p != NULL; p = p->next)
    177c:	e0be7017 	ldw	r2,-1600(fp)
    1780:	10800017 	ldw	r2,0(r2)
    1784:	e0be7015 	stw	r2,-1600(fp)
    1788:	e0be7017 	ldw	r2,-1600(fp)
    178c:	103fc31e 	bne	r2,zero,169c <tse_mac_raw_send+0x44>
           0);                                      // atlantic channel (don't know/don't care: set to 0)
                  
      tx_length = tse_mac_sTxWrite(mi,&tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST]);
      ethernetif->bytes_sent += tx_length;
      }
   LINK_STATS_INC(link.xmit);
    1790:	00800234 	movhi	r2,8
    1794:	1083bd04 	addi	r2,r2,3828
    1798:	1080000b 	ldhu	r2,0(r2)
    179c:	10800044 	addi	r2,r2,1
    17a0:	1007883a 	mov	r3,r2
    17a4:	00800234 	movhi	r2,8
    17a8:	1083bd04 	addi	r2,r2,3828
    17ac:	10c0000d 	sth	r3,0(r2)
   return ERR_OK;
    17b0:	0005883a 	mov	r2,zero
}
    17b4:	e037883a 	mov	sp,fp
    17b8:	dfc00117 	ldw	ra,4(sp)
    17bc:	df000017 	ldw	fp,0(sp)
    17c0:	dec00204 	addi	sp,sp,8
    17c4:	f800283a 	ret

000017c8 <tse_mac_rcv>:
 * 
 * @API TYPE        - callback internal function
 * @return SUCCESS on success
 */
int tse_mac_rcv(struct ethernetif *ethernetif)
{     
    17c8:	defff804 	addi	sp,sp,-32
    17cc:	dfc00715 	stw	ra,28(sp)
    17d0:	df000615 	stw	fp,24(sp)
    17d4:	df000604 	addi	fp,sp,24
    17d8:	e13fff15 	stw	r4,-4(fp)
   int pklen;
   lwip_tse_info* tse_ptr;
   alt_u32 *uncached_packet_payload;
   struct pbuf *p;
  
   tse_ptr = ethernetif->tse_info;
    17dc:	e0bfff17 	ldw	r2,-4(fp)
    17e0:	10801617 	ldw	r2,88(r2)
    17e4:	e0bffb15 	stw	r2,-20(fp)
   pklen = IORD_16DIRECT(&(tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST].actual_bytes_transferred),0);
    17e8:	e0bffb17 	ldw	r2,-20(fp)
    17ec:	10800517 	ldw	r2,20(r2)
    17f0:	10801004 	addi	r2,r2,64
    17f4:	10800704 	addi	r2,r2,28
    17f8:	1080002b 	ldhuio	r2,0(r2)
    17fc:	10bfffcc 	andi	r2,r2,65535
    1800:	e0bffc15 	stw	r2,-16(fp)
   p = ethernetif->lwipRxPbuf[ethernetif->lwipRxIndexIsr];
    1804:	e0bfff17 	ldw	r2,-4(fp)
    1808:	10801317 	ldw	r2,76(r2)
    180c:	e0ffff17 	ldw	r3,-4(fp)
    1810:	108001c4 	addi	r2,r2,7
    1814:	1085883a 	add	r2,r2,r2
    1818:	1085883a 	add	r2,r2,r2
    181c:	1885883a 	add	r2,r3,r2
    1820:	10800017 	ldw	r2,0(r2)
    1824:	e0bffd15 	stw	r2,-12(fp)
   p->tot_len = pklen;
    1828:	e0bffc17 	ldw	r2,-16(fp)
    182c:	1007883a 	mov	r3,r2
    1830:	e0bffd17 	ldw	r2,-12(fp)
    1834:	10c0020d 	sth	r3,8(r2)
   p->len = pklen;
    1838:	e0bffc17 	ldw	r2,-16(fp)
    183c:	1007883a 	mov	r3,r2
    1840:	e0bffd17 	ldw	r2,-12(fp)
    1844:	10c0028d 	sth	r3,10(r2)
   if ((IORD_ALTERA_TSE_SGDMA_DESC_STATUS(&tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]) & ( ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_CRC_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_PARITY_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK )) == 0)
    1848:	e0bffb17 	ldw	r2,-20(fp)
    184c:	10800517 	ldw	r2,20(r2)
    1850:	10801704 	addi	r2,r2,92
    1854:	10800037 	ldwio	r2,0(r2)
    1858:	1005d43a 	srai	r2,r2,16
    185c:	10801fcc 	andi	r2,r2,127
    1860:	1000261e 	bne	r2,zero,18fc <tse_mac_rcv+0x134>
      {
      if( ethernetif->lwipRxCount > LWIP_RX_ETH_BUFFER )
    1864:	e0bfff17 	ldw	r2,-4(fp)
    1868:	10801517 	ldw	r2,84(r2)
    186c:	10800350 	cmplti	r2,r2,13
    1870:	10000c1e 	bne	r2,zero,18a4 <tse_mac_rcv+0xdc>
         {    
         LINK_STATS_INC(link.drop);
    1874:	00800234 	movhi	r2,8
    1878:	1083bd04 	addi	r2,r2,3828
    187c:	1080018b 	ldhu	r2,6(r2)
    1880:	10800044 	addi	r2,r2,1
    1884:	1007883a 	mov	r3,r2
    1888:	00800234 	movhi	r2,8
    188c:	1083bd04 	addi	r2,r2,3828
    1890:	10c0018d 	sth	r3,6(r2)
         dprintf(("No free buffers for rx\n"));
    1894:	010000f4 	movhi	r4,3
    1898:	213c9504 	addi	r4,r4,-3500
    189c:	001965c0 	call	1965c <puts>
    18a0:	00001606 	br	18fc <tse_mac_rcv+0x134>
         }
      else 
         {
         ethernetif->bytes_recv += pklen;
    18a4:	e0bfff17 	ldw	r2,-4(fp)
    18a8:	10c00617 	ldw	r3,24(r2)
    18ac:	e0bffc17 	ldw	r2,-16(fp)
    18b0:	1887883a 	add	r3,r3,r2
    18b4:	e0bfff17 	ldw	r2,-4(fp)
    18b8:	10c00615 	stw	r3,24(r2)
         //  Set up DMA for the next pbuf in the buffer
         ++ethernetif->lwipRxCount;
    18bc:	e0bfff17 	ldw	r2,-4(fp)
    18c0:	10801517 	ldw	r2,84(r2)
    18c4:	10c00044 	addi	r3,r2,1
    18c8:	e0bfff17 	ldw	r2,-4(fp)
    18cc:	10c01515 	stw	r3,84(r2)
         if( ++ethernetif->lwipRxIndexIsr >= LWIP_RX_ETH_BUFFER )
    18d0:	e0bfff17 	ldw	r2,-4(fp)
    18d4:	10801317 	ldw	r2,76(r2)
    18d8:	10c00044 	addi	r3,r2,1
    18dc:	e0bfff17 	ldw	r2,-4(fp)
    18e0:	10c01315 	stw	r3,76(r2)
    18e4:	e0bfff17 	ldw	r2,-4(fp)
    18e8:	10801317 	ldw	r2,76(r2)
    18ec:	10800310 	cmplti	r2,r2,12
    18f0:	1000021e 	bne	r2,zero,18fc <tse_mac_rcv+0x134>
            ethernetif->lwipRxIndexIsr = 0;
    18f4:	e0bfff17 	ldw	r2,-4(fp)
    18f8:	10001315 	stw	zero,76(r2)
         }
      }      

   uncached_packet_payload = (alt_u32 *) ethernetif->lwipRxPbuf[ethernetif->lwipRxIndexIsr]->payload;
    18fc:	e0bfff17 	ldw	r2,-4(fp)
    1900:	10801317 	ldw	r2,76(r2)
    1904:	e0ffff17 	ldw	r3,-4(fp)
    1908:	108001c4 	addi	r2,r2,7
    190c:	1085883a 	add	r2,r2,r2
    1910:	1085883a 	add	r2,r2,r2
    1914:	1885883a 	add	r2,r3,r2
    1918:	10800017 	ldw	r2,0(r2)
    191c:	10800117 	ldw	r2,4(r2)
    1920:	e0bffe15 	stw	r2,-8(fp)
   alt_avalon_sgdma_construct_stream_to_mem_desc(
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
    1924:	e0bffb17 	ldw	r2,-20(fp)
    1928:	10800517 	ldw	r2,20(r2)
            ethernetif->lwipRxIndexIsr = 0;
         }
      }      

   uncached_packet_payload = (alt_u32 *) ethernetif->lwipRxPbuf[ethernetif->lwipRxIndexIsr]->payload;
   alt_avalon_sgdma_construct_stream_to_mem_desc(
    192c:	10c01004 	addi	r3,r2,64
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST],  // pointer to "next"
    1930:	e0bffb17 	ldw	r2,-20(fp)
    1934:	10800517 	ldw	r2,20(r2)
            ethernetif->lwipRxIndexIsr = 0;
         }
      }      

   uncached_packet_payload = (alt_u32 *) ethernetif->lwipRxPbuf[ethernetif->lwipRxIndexIsr]->payload;
   alt_avalon_sgdma_construct_stream_to_mem_desc(
    1938:	10801804 	addi	r2,r2,96
    193c:	d8000015 	stw	zero,0(sp)
    1940:	1809883a 	mov	r4,r3
    1944:	100b883a 	mov	r5,r2
    1948:	e1bffe17 	ldw	r6,-8(fp)
    194c:	000f883a 	mov	r7,zero
    1950:	00261a40 	call	261a4 <alt_avalon_sgdma_construct_stream_to_mem_desc>
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST],  // pointer to "next"
         uncached_packet_payload,            // starting write_address
         0,                                  // read until EOP
         0);          // don't write to constant address

   return ERR_OK;
    1954:	0005883a 	mov	r2,zero
}
    1958:	e037883a 	mov	sp,fp
    195c:	dfc00117 	ldw	ra,4(sp)
    1960:	df000017 	ldw	fp,0(sp)
    1964:	dec00204 	addi	sp,sp,8
    1968:	f800283a 	ret

0000196c <udpecho_recv>:
boolean         printed_flg = FALSE;
#endif

void udpecho_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct 
ip_addr *addr, u16_t port)
{
    196c:	defff904 	addi	sp,sp,-28
    1970:	dfc00615 	stw	ra,24(sp)
    1974:	df000515 	stw	fp,20(sp)
    1978:	df000504 	addi	fp,sp,20
    197c:	e13ffb15 	stw	r4,-20(fp)
    1980:	e17ffc15 	stw	r5,-16(fp)
    1984:	e1bffd15 	stw	r6,-12(fp)
    1988:	e1fffe15 	stw	r7,-8(fp)
    198c:	e0800217 	ldw	r2,8(fp)
    1990:	e0bfff0d 	sth	r2,-4(fp)
        begin_measure(histid);
        measuring_flg = TRUE;
    }
#endif

    if (p != NULL) {
    1994:	e0bffd17 	ldw	r2,-12(fp)
    1998:	10000826 	beq	r2,zero,19bc <udpecho_recv+0x50>
        /* send received packet back to sender */
        udp_sendto(pcb, p, addr, port);
    199c:	e0bfff0b 	ldhu	r2,-4(fp)
    19a0:	e13ffc17 	ldw	r4,-16(fp)
    19a4:	e17ffd17 	ldw	r5,-12(fp)
    19a8:	e1bffe17 	ldw	r6,-8(fp)
    19ac:	100f883a 	mov	r7,r2
    19b0:	00156f40 	call	156f4 <udp_sendto>
        /* free the pbuf */
        pbuf_free(p);
    19b4:	e13ffd17 	ldw	r4,-12(fp)
    19b8:	000aa340 	call	aa34 <pbuf_free>
    }

#if TEST_HISTOGRAM
    // End histogram measure
    if (histid <= TNUM_HIST && measuring_flg == TRUE) {
    19bc:	d0a00017 	ldw	r2,-32768(gp)
    19c0:	1089c468 	cmpgeui	r2,r2,10001
    19c4:	10000a1e 	bne	r2,zero,19f0 <udpecho_recv+0x84>
    19c8:	d0a8a917 	ldw	r2,-23900(gp)
    19cc:	10800058 	cmpnei	r2,r2,1
    19d0:	1000071e 	bne	r2,zero,19f0 <udpecho_recv+0x84>
        //printf("[histid: %d] Histogram measuring ending...\n", histid);
        if (end_measure(histid++)) {
    19d4:	d0a00017 	ldw	r2,-32768(gp)
    19d8:	1007883a 	mov	r3,r2
    19dc:	10800044 	addi	r2,r2,1
    19e0:	d0a00015 	stw	r2,-32768(gp)
    19e4:	1809883a 	mov	r4,r3
    19e8:	0001c980 	call	1c98 <end_measure>
            //printf("%d OK\n", histid);
        } else {
            //printf("%d ERR\n", histid);
        }
        measuring_flg = FALSE;
    19ec:	d028a915 	stw	zero,-23900(gp)
    }

    // Print histogram results
    if (histid > TNUM_HIST && printed_flg == FALSE) {
    19f0:	d0a00017 	ldw	r2,-32768(gp)
    19f4:	1089c470 	cmpltui	r2,r2,10001
    19f8:	10000b1e 	bne	r2,zero,1a28 <udpecho_recv+0xbc>
    19fc:	d0a8aa17 	ldw	r2,-23896(gp)
    1a00:	1000091e 	bne	r2,zero,1a28 <udpecho_recv+0xbc>
        printf("[histid: %d] Printing...\n", histid);
    1a04:	d0a00017 	ldw	r2,-32768(gp)
    1a08:	010000f4 	movhi	r4,3
    1a0c:	213ca304 	addi	r4,r4,-3444
    1a10:	100b883a 	mov	r5,r2
    1a14:	00193f00 	call	193f0 <printf>
        printed_flg = TRUE;
    1a18:	00800044 	movi	r2,1
    1a1c:	d0a8aa15 	stw	r2,-23896(gp)
        print_hist(TNUM_HIST);
    1a20:	0109c404 	movi	r4,10000
    1a24:	0001e300 	call	1e30 <print_hist>
    }
#endif
}
    1a28:	e037883a 	mov	sp,fp
    1a2c:	dfc00117 	ldw	ra,4(sp)
    1a30:	df000017 	ldw	fp,0(sp)
    1a34:	dec00204 	addi	sp,sp,8
    1a38:	f800283a 	ret

00001a3c <udpecho_init>:


void udpecho_init(void)
{
    1a3c:	defffd04 	addi	sp,sp,-12
    1a40:	dfc00215 	stw	ra,8(sp)
    1a44:	df000115 	stw	fp,4(sp)
    1a48:	df000104 	addi	fp,sp,4
    struct udp_pcb * pcb;
    printf("Initializing udp_init()...\n");
    1a4c:	010000f4 	movhi	r4,3
    1a50:	213caa04 	addi	r4,r4,-3416
    1a54:	001965c0 	call	1965c <puts>

    /* get new pcb */
    pcb = udp_new();
    1a58:	0015e040 	call	15e04 <udp_new>
    1a5c:	e0bfff15 	stw	r2,-4(fp)
    if (pcb == NULL) {
    1a60:	e0bfff17 	ldw	r2,-4(fp)
    1a64:	1000041e 	bne	r2,zero,1a78 <udpecho_init+0x3c>
        printf("udp_new failed!\n");
    1a68:	010000f4 	movhi	r4,3
    1a6c:	213cb104 	addi	r4,r4,-3388
    1a70:	001965c0 	call	1965c <puts>
        return;
    1a74:	00001506 	br	1acc <udpecho_init+0x90>
    }

    /* bind to any IP address on port 7 */
    if (udp_bind(pcb, IP_ADDR_ANY, 7) != ERR_OK) {
    1a78:	e13fff17 	ldw	r4,-4(fp)
    1a7c:	014000f4 	movhi	r5,3
    1a80:	29557404 	addi	r5,r5,21968
    1a84:	018001c4 	movi	r6,7
    1a88:	0015a740 	call	15a74 <udp_bind>
    1a8c:	10803fcc 	andi	r2,r2,255
    1a90:	1080201c 	xori	r2,r2,128
    1a94:	10bfe004 	addi	r2,r2,-128
    1a98:	10000426 	beq	r2,zero,1aac <udpecho_init+0x70>
        printf("udp_bind failed!\n");
    1a9c:	010000f4 	movhi	r4,3
    1aa0:	213cb504 	addi	r4,r4,-3372
    1aa4:	001965c0 	call	1965c <puts>
        return;
    1aa8:	00000806 	br	1acc <udpecho_init+0x90>
    }

    /* set udpecho_recv() as callback function
       for received packets */
    printf("Ready to accept UDP packets on port 7\n");
    1aac:	010000f4 	movhi	r4,3
    1ab0:	213cba04 	addi	r4,r4,-3352
    1ab4:	001965c0 	call	1965c <puts>
    udp_recv(pcb, udpecho_recv, NULL);
    1ab8:	e13fff17 	ldw	r4,-4(fp)
    1abc:	01400034 	movhi	r5,0
    1ac0:	29465b04 	addi	r5,r5,6508
    1ac4:	000d883a 	mov	r6,zero
    1ac8:	0015d280 	call	15d28 <udp_recv>
}
    1acc:	e037883a 	mov	sp,fp
    1ad0:	dfc00117 	ldw	ra,4(sp)
    1ad4:	df000017 	ldw	fp,0(sp)
    1ad8:	dec00204 	addi	sp,sp,8
    1adc:	f800283a 	ret

00001ae0 <get_utm>:
//#ifndef HIST_BM_HOOK                /* svOs */
//#define HIST_BM_HOOK()
//#endif /* HIST_BM_HOOK */

void get_utm(HISTTIM *p_time)
{
    1ae0:	defffd04 	addi	sp,sp,-12
    1ae4:	dfc00215 	stw	ra,8(sp)
    1ae8:	df000115 	stw	fp,4(sp)
    1aec:	df000104 	addi	fp,sp,4
    1af0:	e13fff15 	stw	r4,-4(fp)
	//*p_time = (HISTTIM) ((double)alt_timestamp() / (double)timestamp_freq * (double)1000000);
	*p_time = (HISTTIM)alt_timestamp();
    1af4:	0026d0c0 	call	26d0c <alt_timestamp>
    1af8:	e0ffff17 	ldw	r3,-4(fp)
    1afc:	18800015 	stw	r2,0(r3)
	//printf("%d\n", *p_time);
}
    1b00:	e037883a 	mov	sp,fp
    1b04:	dfc00117 	ldw	ra,4(sp)
    1b08:	df000017 	ldw	fp,0(sp)
    1b0c:	dec00204 	addi	sp,sp,8
    1b10:	f800283a 	ret

00001b14 <init_hist>:
/*
 *  szv
 */
boolean
init_hist(ObjectIDType histid, uint32 maxval, uint32 *histarea)
{
    1b14:	defff904 	addi	sp,sp,-28
    1b18:	df000615 	stw	fp,24(sp)
    1b1c:	df000604 	addi	fp,sp,24
    1b20:	e13ffd15 	stw	r4,-12(fp)
    1b24:	e17ffe15 	stw	r5,-8(fp)
    1b28:	e1bfff15 	stw	r6,-4(fp)
	HISTCB	*p_histcb;
	uint32	i;
	boolean ret = TRUE;
    1b2c:	00800044 	movi	r2,1
    1b30:	e0bffb15 	stw	r2,-20(fp)

	/* szvIDFALSE */
	if ((histid < TMIN_HISTID) || (histid > TMAX_HISTID)) {
    1b34:	e0bffd17 	ldw	r2,-12(fp)
    1b38:	10000326 	beq	r2,zero,1b48 <init_hist+0x34>
    1b3c:	e0bffd17 	ldw	r2,-12(fp)
    1b40:	1089c470 	cmpltui	r2,r2,10001
    1b44:	1000021e 	bne	r2,zero,1b50 <init_hist+0x3c>
		ret = FALSE;
    1b48:	e03ffb15 	stw	zero,-20(fp)
    1b4c:	00002206 	br	1bd8 <init_hist+0xc4>
	}
	else {
		p_histcb = &(histcb_table[histid - TMIN_HISTID]);
    1b50:	e0bffd17 	ldw	r2,-12(fp)
    1b54:	10bfffc4 	addi	r2,r2,-1
    1b58:	10c00624 	muli	r3,r2,24
    1b5c:	00800134 	movhi	r2,4
    1b60:	1097bb04 	addi	r2,r2,24300
    1b64:	1885883a 	add	r2,r3,r2
    1b68:	e0bffc15 	stw	r2,-16(fp)

		for (i = 0U; i <= maxval; i++) {
    1b6c:	e03ffa15 	stw	zero,-24(fp)
    1b70:	00000906 	br	1b98 <init_hist+0x84>
			histarea[i] = 0U;
    1b74:	e0bffa17 	ldw	r2,-24(fp)
    1b78:	1085883a 	add	r2,r2,r2
    1b7c:	1085883a 	add	r2,r2,r2
    1b80:	e0ffff17 	ldw	r3,-4(fp)
    1b84:	1885883a 	add	r2,r3,r2
    1b88:	10000015 	stw	zero,0(r2)
		ret = FALSE;
	}
	else {
		p_histcb = &(histcb_table[histid - TMIN_HISTID]);

		for (i = 0U; i <= maxval; i++) {
    1b8c:	e0bffa17 	ldw	r2,-24(fp)
    1b90:	10800044 	addi	r2,r2,1
    1b94:	e0bffa15 	stw	r2,-24(fp)
    1b98:	e0bffa17 	ldw	r2,-24(fp)
    1b9c:	e0fffe17 	ldw	r3,-8(fp)
    1ba0:	18bff42e 	bgeu	r3,r2,1b74 <init_hist+0x60>
			histarea[i] = 0U;
		}
		p_histcb->maxval = maxval;
    1ba4:	e0bffc17 	ldw	r2,-16(fp)
    1ba8:	e0fffe17 	ldw	r3,-8(fp)
    1bac:	10c00115 	stw	r3,4(r2)
		p_histcb->histarea = histarea;
    1bb0:	e0bffc17 	ldw	r2,-16(fp)
    1bb4:	e0ffff17 	ldw	r3,-4(fp)
    1bb8:	10c00215 	stw	r3,8(r2)
		p_histcb->over = 0U;
    1bbc:	e0bffc17 	ldw	r2,-16(fp)
    1bc0:	10000315 	stw	zero,12(r2)
		p_histcb->under = 0U;
    1bc4:	e0bffc17 	ldw	r2,-16(fp)
    1bc8:	10000415 	stw	zero,16(r2)
		p_histcb->initialized = TRUE;
    1bcc:	e0bffc17 	ldw	r2,-16(fp)
    1bd0:	00c00044 	movi	r3,1
    1bd4:	10c00515 	stw	r3,20(r2)
	}
	return(ret);
    1bd8:	e0bffb17 	ldw	r2,-20(fp)
}
    1bdc:	e037883a 	mov	sp,fp
    1be0:	df000017 	ldw	fp,0(sp)
    1be4:	dec00104 	addi	sp,sp,4
    1be8:	f800283a 	ret

00001bec <begin_measure>:
/*
 *  svJn
 */
boolean
begin_measure(ObjectIDType histid)
{
    1bec:	defffb04 	addi	sp,sp,-20
    1bf0:	dfc00415 	stw	ra,16(sp)
    1bf4:	df000315 	stw	fp,12(sp)
    1bf8:	df000304 	addi	fp,sp,12
    1bfc:	e13fff15 	stw	r4,-4(fp)
	HISTCB	*p_histcb;
	boolean ret = TRUE;
    1c00:	00800044 	movi	r2,1
    1c04:	e0bffd15 	stw	r2,-12(fp)
	if((int)histid % 500 == 1) {
    1c08:	e0bfff17 	ldw	r2,-4(fp)
    1c0c:	00c07d04 	movi	r3,500
    1c10:	10c7283a 	div	r3,r2,r3
    1c14:	18c07d24 	muli	r3,r3,500
    1c18:	10c5c83a 	sub	r2,r2,r3
    1c1c:	10800058 	cmpnei	r2,r2,1
    1c20:	1000011e 	bne	r2,zero,1c28 <begin_measure+0x3c>
		alt_timestamp_start();
    1c24:	0026c840 	call	26c84 <alt_timestamp_start>
	}

	/* szvIDFALSE */
	if ((histid < TMIN_HISTID) || (histid > TMAX_HISTID)) {
    1c28:	e0bfff17 	ldw	r2,-4(fp)
    1c2c:	10000326 	beq	r2,zero,1c3c <begin_measure+0x50>
    1c30:	e0bfff17 	ldw	r2,-4(fp)
    1c34:	1089c470 	cmpltui	r2,r2,10001
    1c38:	1000021e 	bne	r2,zero,1c44 <begin_measure+0x58>
		ret = FALSE;
    1c3c:	e03ffd15 	stw	zero,-12(fp)
    1c40:	00000f06 	br	1c80 <begin_measure+0x94>
	}
	else {
		p_histcb = &(histcb_table[histid - TMIN_HISTID]);
    1c44:	e0bfff17 	ldw	r2,-4(fp)
    1c48:	10bfffc4 	addi	r2,r2,-1
    1c4c:	10c00624 	muli	r3,r2,24
    1c50:	00800134 	movhi	r2,4
    1c54:	1097bb04 	addi	r2,r2,24300
    1c58:	1885883a 	add	r2,r3,r2
    1c5c:	e0bffe15 	stw	r2,-8(fp)

		/* FALSE */
		if (p_histcb->initialized == FALSE)	{
    1c60:	e0bffe17 	ldw	r2,-8(fp)
    1c64:	10800517 	ldw	r2,20(r2)
    1c68:	1000021e 	bne	r2,zero,1c74 <begin_measure+0x88>
			ret = FALSE;
    1c6c:	e03ffd15 	stw	zero,-12(fp)
    1c70:	00000306 	br	1c80 <begin_measure+0x94>
		}
		else {
			//HIST_BM_HOOK();
			HIST_GET_TIM(&(p_histcb->begin_time));
    1c74:	e0bffe17 	ldw	r2,-8(fp)
    1c78:	1009883a 	mov	r4,r2
    1c7c:	0001ae00 	call	1ae0 <get_utm>
		}
	}
	return(ret);
    1c80:	e0bffd17 	ldw	r2,-12(fp)
}
    1c84:	e037883a 	mov	sp,fp
    1c88:	dfc00117 	ldw	ra,4(sp)
    1c8c:	df000017 	ldw	fp,0(sp)
    1c90:	dec00204 	addi	sp,sp,8
    1c94:	f800283a 	ret

00001c98 <end_measure>:
/*
 *  svI
 */
boolean
end_measure(ObjectIDType histid)
{
    1c98:	defff704 	addi	sp,sp,-36
    1c9c:	dfc00815 	stw	ra,32(sp)
    1ca0:	df000715 	stw	fp,28(sp)
    1ca4:	dc400615 	stw	r17,24(sp)
    1ca8:	dc000515 	stw	r16,20(sp)
    1cac:	df000504 	addi	fp,sp,20
    1cb0:	e13fff15 	stw	r4,-4(fp)
	HISTCB	*p_histcb;
	HISTTIM	end_time;
	uint32	val;
	boolean ret = TRUE;
    1cb4:	00800044 	movi	r2,1
    1cb8:	e0bffb15 	stw	r2,-20(fp)

	HIST_GET_TIM(&end_time);
    1cbc:	e0bffe04 	addi	r2,fp,-8
    1cc0:	1009883a 	mov	r4,r2
    1cc4:	0001ae00 	call	1ae0 <get_utm>

	/* szvIDFALSE */
	if ((histid < TMIN_HISTID) || (histid > TMAX_HISTID)) {
    1cc8:	e0bfff17 	ldw	r2,-4(fp)
    1ccc:	10000326 	beq	r2,zero,1cdc <end_measure+0x44>
    1cd0:	e0bfff17 	ldw	r2,-4(fp)
    1cd4:	1089c470 	cmpltui	r2,r2,10001
    1cd8:	1000021e 	bne	r2,zero,1ce4 <end_measure+0x4c>
		ret = FALSE;
    1cdc:	e03ffb15 	stw	zero,-20(fp)
    1ce0:	00004b06 	br	1e10 <end_measure+0x178>
	}
	else {
		p_histcb = &(histcb_table[histid - TMIN_HISTID]);
    1ce4:	e0bfff17 	ldw	r2,-4(fp)
    1ce8:	10bfffc4 	addi	r2,r2,-1
    1cec:	10c00624 	muli	r3,r2,24
    1cf0:	00800134 	movhi	r2,4
    1cf4:	1097bb04 	addi	r2,r2,24300
    1cf8:	1885883a 	add	r2,r3,r2
    1cfc:	e0bffc15 	stw	r2,-16(fp)

		/* FALSE */
		if (p_histcb->initialized == FALSE)	{
    1d00:	e0bffc17 	ldw	r2,-16(fp)
    1d04:	10800517 	ldw	r2,20(r2)
    1d08:	1000021e 	bne	r2,zero,1d14 <end_measure+0x7c>
			ret = FALSE;
    1d0c:	e03ffb15 	stw	zero,-20(fp)
    1d10:	00003f06 	br	1e10 <end_measure+0x178>
		}
		else {
			//val = HIST_CONV_TIM(end_time - p_histcb->begin_time);
			val = (uint32) ((double)HIST_CONV_TIM(end_time - p_histcb->begin_time) / (double)timestamp_freq * (double)1000000);
    1d14:	e0fffe17 	ldw	r3,-8(fp)
    1d18:	e0bffc17 	ldw	r2,-16(fp)
    1d1c:	10800017 	ldw	r2,0(r2)
    1d20:	1885c83a 	sub	r2,r3,r2
    1d24:	1009883a 	mov	r4,r2
    1d28:	0018acc0 	call	18acc <__floatunsidf>
    1d2c:	1021883a 	mov	r16,r2
    1d30:	1823883a 	mov	r17,r3
    1d34:	d0a8ab17 	ldw	r2,-23892(gp)
    1d38:	1009883a 	mov	r4,r2
    1d3c:	0018acc0 	call	18acc <__floatunsidf>
    1d40:	100f883a 	mov	r7,r2
    1d44:	1811883a 	mov	r8,r3
    1d48:	8009883a 	mov	r4,r16
    1d4c:	880b883a 	mov	r5,r17
    1d50:	380d883a 	mov	r6,r7
    1d54:	400f883a 	mov	r7,r8
    1d58:	00187e00 	call	187e0 <__divdf3>
    1d5c:	1009883a 	mov	r4,r2
    1d60:	180b883a 	mov	r5,r3
    1d64:	2005883a 	mov	r2,r4
    1d68:	2807883a 	mov	r3,r5
    1d6c:	1009883a 	mov	r4,r2
    1d70:	180b883a 	mov	r5,r3
    1d74:	000d883a 	mov	r6,zero
    1d78:	01d04bf4 	movhi	r7,16687
    1d7c:	39e12004 	addi	r7,r7,-31616
    1d80:	00184fc0 	call	184fc <__muldf3>
    1d84:	1009883a 	mov	r4,r2
    1d88:	180b883a 	mov	r5,r3
    1d8c:	2005883a 	mov	r2,r4
    1d90:	2807883a 	mov	r3,r5
    1d94:	1009883a 	mov	r4,r2
    1d98:	180b883a 	mov	r5,r3
    1d9c:	00180700 	call	18070 <__fixunsdfsi>
    1da0:	e0bffd15 	stw	r2,-12(fp)
			//printf("timediff: %d\n", val);
			if (val <= p_histcb->maxval) {
    1da4:	e0bffc17 	ldw	r2,-16(fp)
    1da8:	10c00117 	ldw	r3,4(r2)
    1dac:	e0bffd17 	ldw	r2,-12(fp)
    1db0:	18800a36 	bltu	r3,r2,1ddc <end_measure+0x144>
				p_histcb->histarea[val]++;
    1db4:	e0bffc17 	ldw	r2,-16(fp)
    1db8:	10c00217 	ldw	r3,8(r2)
    1dbc:	e0bffd17 	ldw	r2,-12(fp)
    1dc0:	1085883a 	add	r2,r2,r2
    1dc4:	1085883a 	add	r2,r2,r2
    1dc8:	1885883a 	add	r2,r3,r2
    1dcc:	10c00017 	ldw	r3,0(r2)
    1dd0:	18c00044 	addi	r3,r3,1
    1dd4:	10c00015 	stw	r3,0(r2)
    1dd8:	00000d06 	br	1e10 <end_measure+0x178>
			}
			else if (val <= ((uint32) 0x7fffffff)) {
    1ddc:	e0bffd17 	ldw	r2,-12(fp)
    1de0:	10000616 	blt	r2,zero,1dfc <end_measure+0x164>
				p_histcb->over++;
    1de4:	e0bffc17 	ldw	r2,-16(fp)
    1de8:	10800317 	ldw	r2,12(r2)
    1dec:	10c00044 	addi	r3,r2,1
    1df0:	e0bffc17 	ldw	r2,-16(fp)
    1df4:	10c00315 	stw	r3,12(r2)
    1df8:	00000506 	br	1e10 <end_measure+0x178>
			}
			else {
				p_histcb->under++;
    1dfc:	e0bffc17 	ldw	r2,-16(fp)
    1e00:	10800417 	ldw	r2,16(r2)
    1e04:	10c00044 	addi	r3,r2,1
    1e08:	e0bffc17 	ldw	r2,-16(fp)
    1e0c:	10c00415 	stw	r3,16(r2)
			}
		}
	}
	return(ret);
    1e10:	e0bffb17 	ldw	r2,-20(fp)
}
    1e14:	e037883a 	mov	sp,fp
    1e18:	dfc00317 	ldw	ra,12(sp)
    1e1c:	df000217 	ldw	fp,8(sp)
    1e20:	dc400117 	ldw	r17,4(sp)
    1e24:	dc000017 	ldw	r16,0(sp)
    1e28:	dec00404 	addi	sp,sp,16
    1e2c:	f800283a 	ret

00001e30 <print_hist>:
/*
 *  szv\
 */
boolean
print_hist(ObjectIDType histid)
{
    1e30:	defffa04 	addi	sp,sp,-24
    1e34:	dfc00515 	stw	ra,20(sp)
    1e38:	df000415 	stw	fp,16(sp)
    1e3c:	df000404 	addi	fp,sp,16
    1e40:	e13fff15 	stw	r4,-4(fp)
	HISTCB	*p_histcb;
	int		i;
	boolean ret = TRUE;
    1e44:	00800044 	movi	r2,1
    1e48:	e0bffd15 	stw	r2,-12(fp)

	/* szvIDFALSE */
	if ((histid < TMIN_HISTID) || (histid > TMAX_HISTID)) {
    1e4c:	e0bfff17 	ldw	r2,-4(fp)
    1e50:	10000326 	beq	r2,zero,1e60 <print_hist+0x30>
    1e54:	e0bfff17 	ldw	r2,-4(fp)
    1e58:	1089c470 	cmpltui	r2,r2,10001
    1e5c:	1000021e 	bne	r2,zero,1e68 <print_hist+0x38>
		ret = FALSE;
    1e60:	e03ffd15 	stw	zero,-12(fp)
    1e64:	00004006 	br	1f68 <print_hist+0x138>
	}
	else {
		p_histcb = &(histcb_table[histid - TMIN_HISTID]);
    1e68:	e0bfff17 	ldw	r2,-4(fp)
    1e6c:	10bfffc4 	addi	r2,r2,-1
    1e70:	10c00624 	muli	r3,r2,24
    1e74:	00800134 	movhi	r2,4
    1e78:	1097bb04 	addi	r2,r2,24300
    1e7c:	1885883a 	add	r2,r3,r2
    1e80:	e0bffe15 	stw	r2,-8(fp)

		/* FALSE */
		if (p_histcb->initialized == FALSE)	{
    1e84:	e0bffe17 	ldw	r2,-8(fp)
    1e88:	10800517 	ldw	r2,20(r2)
    1e8c:	1000021e 	bne	r2,zero,1e98 <print_hist+0x68>
			ret = FALSE;
    1e90:	e03ffd15 	stw	zero,-12(fp)
    1e94:	00003406 	br	1f68 <print_hist+0x138>
		}
		else {
			for (i = 0U; i <= (int)p_histcb->maxval; i++) {
    1e98:	e03ffc15 	stw	zero,-16(fp)
    1e9c:	00001706 	br	1efc <print_hist+0xcc>
				if ((int)p_histcb->histarea[i] > 0U) {
    1ea0:	e0bffe17 	ldw	r2,-8(fp)
    1ea4:	10c00217 	ldw	r3,8(r2)
    1ea8:	e0bffc17 	ldw	r2,-16(fp)
    1eac:	1085883a 	add	r2,r2,r2
    1eb0:	1085883a 	add	r2,r2,r2
    1eb4:	1885883a 	add	r2,r3,r2
    1eb8:	10800017 	ldw	r2,0(r2)
    1ebc:	10000c26 	beq	r2,zero,1ef0 <print_hist+0xc0>
#ifndef MEASURE_100_NANO
					printf("%d : %d\n", i, (int)p_histcb->histarea[i]);
    1ec0:	e0bffe17 	ldw	r2,-8(fp)
    1ec4:	10c00217 	ldw	r3,8(r2)
    1ec8:	e0bffc17 	ldw	r2,-16(fp)
    1ecc:	1085883a 	add	r2,r2,r2
    1ed0:	1085883a 	add	r2,r2,r2
    1ed4:	1885883a 	add	r2,r3,r2
    1ed8:	10800017 	ldw	r2,0(r2)
    1edc:	010000f4 	movhi	r4,3
    1ee0:	213cc404 	addi	r4,r4,-3312
    1ee4:	e17ffc17 	ldw	r5,-16(fp)
    1ee8:	100d883a 	mov	r6,r2
    1eec:	00193f00 	call	193f0 <printf>
		/* FALSE */
		if (p_histcb->initialized == FALSE)	{
			ret = FALSE;
		}
		else {
			for (i = 0U; i <= (int)p_histcb->maxval; i++) {
    1ef0:	e0bffc17 	ldw	r2,-16(fp)
    1ef4:	10800044 	addi	r2,r2,1
    1ef8:	e0bffc15 	stw	r2,-16(fp)
    1efc:	e0bffe17 	ldw	r2,-8(fp)
    1f00:	10800117 	ldw	r2,4(r2)
    1f04:	1007883a 	mov	r3,r2
    1f08:	e0bffc17 	ldw	r2,-16(fp)
    1f0c:	18bfe40e 	bge	r3,r2,1ea0 <print_hist+0x70>
#else
					printf("%d.%d : %d\n", i / 10, i % 10, (int)p_histcb->histarea[i]);
#endif /* MEASURE_100_NANO */
				}
			}
			if (p_histcb->over > 0U) {
    1f10:	e0bffe17 	ldw	r2,-8(fp)
    1f14:	10800317 	ldw	r2,12(r2)
    1f18:	10000a26 	beq	r2,zero,1f44 <print_hist+0x114>
				printf("> %d : %d\n", (int)p_histcb->maxval, (int)p_histcb->over);
    1f1c:	e0bffe17 	ldw	r2,-8(fp)
    1f20:	10800117 	ldw	r2,4(r2)
    1f24:	1007883a 	mov	r3,r2
    1f28:	e0bffe17 	ldw	r2,-8(fp)
    1f2c:	10800317 	ldw	r2,12(r2)
    1f30:	010000f4 	movhi	r4,3
    1f34:	213cc704 	addi	r4,r4,-3300
    1f38:	180b883a 	mov	r5,r3
    1f3c:	100d883a 	mov	r6,r2
    1f40:	00193f00 	call	193f0 <printf>
			}
			if (p_histcb->under > 0U) {
    1f44:	e0bffe17 	ldw	r2,-8(fp)
    1f48:	10800417 	ldw	r2,16(r2)
    1f4c:	10000626 	beq	r2,zero,1f68 <print_hist+0x138>
				printf("> 0x7fffffff : %d\n", (int)p_histcb->under);
    1f50:	e0bffe17 	ldw	r2,-8(fp)
    1f54:	10800417 	ldw	r2,16(r2)
    1f58:	010000f4 	movhi	r4,3
    1f5c:	213cca04 	addi	r4,r4,-3288
    1f60:	100b883a 	mov	r5,r2
    1f64:	00193f00 	call	193f0 <printf>
			}
		}
	}

	return(ret);
    1f68:	e0bffd17 	ldw	r2,-12(fp)
}
    1f6c:	e037883a 	mov	sp,fp
    1f70:	dfc00117 	ldw	ra,4(sp)
    1f74:	df000017 	ldw	fp,0(sp)
    1f78:	dec00204 	addi	sp,sp,8
    1f7c:	f800283a 	ret

00001f80 <dhcp_handle_nak>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
    1f80:	defffc04 	addi	sp,sp,-16
    1f84:	dfc00315 	stw	ra,12(sp)
    1f88:	df000215 	stw	fp,8(sp)
    1f8c:	df000204 	addi	fp,sp,8
    1f90:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    1f94:	e0bfff17 	ldw	r2,-4(fp)
    1f98:	10800817 	ldw	r2,32(r2)
    1f9c:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
    1fa0:	e13fff17 	ldw	r4,-4(fp)
    1fa4:	0009e700 	call	9e70 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
    1fa8:	e13fff17 	ldw	r4,-4(fp)
    1fac:	014000f4 	movhi	r5,3
    1fb0:	29557404 	addi	r5,r5,21968
    1fb4:	0009bfc0 	call	9bfc <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
    1fb8:	e13fff17 	ldw	r4,-4(fp)
    1fbc:	014000f4 	movhi	r5,3
    1fc0:	29557404 	addi	r5,r5,21968
    1fc4:	0009d300 	call	9d30 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
    1fc8:	e13fff17 	ldw	r4,-4(fp)
    1fcc:	014000f4 	movhi	r5,3
    1fd0:	29557404 	addi	r5,r5,21968
    1fd4:	0009d740 	call	9d74 <netif_set_netmask>
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
    1fd8:	e13ffe17 	ldw	r4,-8(fp)
    1fdc:	01400304 	movi	r5,12
    1fe0:	0003c800 	call	3c80 <dhcp_set_state>
  /* We can immediately restart discovery */
  dhcp_discover(netif);
    1fe4:	e13fff17 	ldw	r4,-4(fp)
    1fe8:	00031900 	call	3190 <dhcp_discover>
}
    1fec:	e037883a 	mov	sp,fp
    1ff0:	dfc00117 	ldw	ra,4(sp)
    1ff4:	df000017 	ldw	fp,0(sp)
    1ff8:	dec00204 	addi	sp,sp,8
    1ffc:	f800283a 	ret

00002000 <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
    2000:	defffb04 	addi	sp,sp,-20
    2004:	dfc00415 	stw	ra,16(sp)
    2008:	df000315 	stw	fp,12(sp)
    200c:	df000304 	addi	fp,sp,12
    2010:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    2014:	e0bfff17 	ldw	r2,-4(fp)
    2018:	10800817 	ldw	r2,32(r2)
    201c:	e0bffd15 	stw	r2,-12(fp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  dhcp_set_state(dhcp, DHCP_CHECKING);
    2020:	e13ffd17 	ldw	r4,-12(fp)
    2024:	01400204 	movi	r5,8
    2028:	0003c800 	call	3c80 <dhcp_set_state>
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
    202c:	e0bffd17 	ldw	r2,-12(fp)
    2030:	10800904 	addi	r2,r2,36
    2034:	e13fff17 	ldw	r4,-4(fp)
    2038:	100b883a 	mov	r5,r2
    203c:	000d883a 	mov	r6,zero
    2040:	00173100 	call	17310 <etharp_query>
    2044:	e0bffe05 	stb	r2,-8(fp)
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
    2048:	e0bffd17 	ldw	r2,-12(fp)
    204c:	10800343 	ldbu	r2,13(r2)
    2050:	10800044 	addi	r2,r2,1
    2054:	1007883a 	mov	r3,r2
    2058:	e0bffd17 	ldw	r2,-12(fp)
    205c:	10c00345 	stb	r3,13(r2)
  msecs = 500;
    2060:	00807d04 	movi	r2,500
    2064:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    2068:	e0bffe8b 	ldhu	r2,-6(fp)
    206c:	10c07cc4 	addi	r3,r2,499
    2070:	00807d04 	movi	r2,500
    2074:	1885283a 	div	r2,r3,r2
    2078:	1007883a 	mov	r3,r2
    207c:	e0bffd17 	ldw	r2,-12(fp)
    2080:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
}
    2084:	e037883a 	mov	sp,fp
    2088:	dfc00117 	ldw	ra,4(sp)
    208c:	df000017 	ldw	fp,0(sp)
    2090:	dec00204 	addi	sp,sp,8
    2094:	f800283a 	ret

00002098 <dhcp_handle_offer>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
    2098:	defffc04 	addi	sp,sp,-16
    209c:	dfc00315 	stw	ra,12(sp)
    20a0:	df000215 	stw	fp,8(sp)
    20a4:	df000204 	addi	fp,sp,8
    20a8:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    20ac:	e0bfff17 	ldw	r2,-4(fp)
    20b0:	10800817 	ldw	r2,32(r2)
    20b4:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* obtain the server address */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SERVER_ID)) {
    20b8:	00800234 	movhi	r2,8
    20bc:	10821b04 	addi	r2,r2,2156
    20c0:	10800083 	ldbu	r2,2(r2)
    20c4:	10803fcc 	andi	r2,r2,255
    20c8:	10002226 	beq	r2,zero,2154 <dhcp_handle_offer+0xbc>
    ip4_addr_set_u32(&dhcp->server_ip_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SERVER_ID)));
    20cc:	00800234 	movhi	r2,8
    20d0:	10821e04 	addi	r2,r2,2168
    20d4:	10800217 	ldw	r2,8(r2)
    20d8:	1006d63a 	srli	r3,r2,24
    20dc:	00800234 	movhi	r2,8
    20e0:	10821e04 	addi	r2,r2,2168
    20e4:	10800217 	ldw	r2,8(r2)
    20e8:	1004d23a 	srli	r2,r2,8
    20ec:	10bfc00c 	andi	r2,r2,65280
    20f0:	1886b03a 	or	r3,r3,r2
    20f4:	00800234 	movhi	r2,8
    20f8:	10821e04 	addi	r2,r2,2168
    20fc:	10800217 	ldw	r2,8(r2)
    2100:	10bfc00c 	andi	r2,r2,65280
    2104:	1004923a 	slli	r2,r2,8
    2108:	1886b03a 	or	r3,r3,r2
    210c:	00800234 	movhi	r2,8
    2110:	10821e04 	addi	r2,r2,2168
    2114:	10800217 	ldw	r2,8(r2)
    2118:	1004963a 	slli	r2,r2,24
    211c:	1886b03a 	or	r3,r3,r2
    2120:	e0bffe17 	ldw	r2,-8(fp)
    2124:	10c00815 	stw	r3,32(r2)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n",
      ip4_addr_get_u32(&dhcp->server_ip_addr)));
    /* remember offered address */
    ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
    2128:	e0bffe17 	ldw	r2,-8(fp)
    212c:	10800217 	ldw	r2,8(r2)
    2130:	10c0040b 	ldhu	r3,16(r2)
    2134:	1080048b 	ldhu	r2,18(r2)
    2138:	1004943a 	slli	r2,r2,16
    213c:	10c4b03a 	or	r2,r2,r3
    2140:	1007883a 	mov	r3,r2
    2144:	e0bffe17 	ldw	r2,-8(fp)
    2148:	10c00915 	stw	r3,36(r2)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n",
      ip4_addr_get_u32(&dhcp->offered_ip_addr)));

    dhcp_select(netif);
    214c:	e13fff17 	ldw	r4,-4(fp)
    2150:	00021680 	call	2168 <dhcp_select>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_handle_offer(netif=%p) did not get server ID!\n", (void*)netif));
  }
}
    2154:	e037883a 	mov	sp,fp
    2158:	dfc00117 	ldw	ra,4(sp)
    215c:	df000017 	ldw	fp,0(sp)
    2160:	dec00204 	addi	sp,sp,8
    2164:	f800283a 	ret

00002168 <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
    2168:	defffa04 	addi	sp,sp,-24
    216c:	dfc00515 	stw	ra,20(sp)
    2170:	df000415 	stw	fp,16(sp)
    2174:	df000404 	addi	fp,sp,16
    2178:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    217c:	e0bfff17 	ldw	r2,-4(fp)
    2180:	10800817 	ldw	r2,32(r2)
    2184:	e0bffd15 	stw	r2,-12(fp)
  err_t result;
  u16_t msecs;

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  dhcp_set_state(dhcp, DHCP_REQUESTING);
    2188:	e13ffd17 	ldw	r4,-12(fp)
    218c:	01400044 	movi	r5,1
    2190:	0003c800 	call	3c80 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
    2194:	e13fff17 	ldw	r4,-4(fp)
    2198:	e17ffd17 	ldw	r5,-12(fp)
    219c:	018000c4 	movi	r6,3
    21a0:	0004cac0 	call	4cac <dhcp_create_msg>
    21a4:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
    21a8:	e0bffe07 	ldb	r2,-8(fp)
    21ac:	1000631e 	bne	r2,zero,233c <dhcp_select+0x1d4>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    21b0:	e13ffd17 	ldw	r4,-12(fp)
    21b4:	01400e44 	movi	r5,57
    21b8:	01800084 	movi	r6,2
    21bc:	0003cd80 	call	3cd8 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    21c0:	e0bfff17 	ldw	r2,-4(fp)
    21c4:	1080090b 	ldhu	r2,36(r2)
    21c8:	10bfffcc 	andi	r2,r2,65535
    21cc:	e13ffd17 	ldw	r4,-12(fp)
    21d0:	100b883a 	mov	r5,r2
    21d4:	0003e580 	call	3e58 <dhcp_option_short>

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    21d8:	e13ffd17 	ldw	r4,-12(fp)
    21dc:	01400c84 	movi	r5,50
    21e0:	01800104 	movi	r6,4
    21e4:	0003cd80 	call	3cd8 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
    21e8:	e0bffd17 	ldw	r2,-12(fp)
    21ec:	10800917 	ldw	r2,36(r2)
    21f0:	1006d63a 	srli	r3,r2,24
    21f4:	e0bffd17 	ldw	r2,-12(fp)
    21f8:	10800917 	ldw	r2,36(r2)
    21fc:	1004d23a 	srli	r2,r2,8
    2200:	10bfc00c 	andi	r2,r2,65280
    2204:	1886b03a 	or	r3,r3,r2
    2208:	e0bffd17 	ldw	r2,-12(fp)
    220c:	10800917 	ldw	r2,36(r2)
    2210:	10bfc00c 	andi	r2,r2,65280
    2214:	1004923a 	slli	r2,r2,8
    2218:	1886b03a 	or	r3,r3,r2
    221c:	e0bffd17 	ldw	r2,-12(fp)
    2220:	10800917 	ldw	r2,36(r2)
    2224:	1004963a 	slli	r2,r2,24
    2228:	1884b03a 	or	r2,r3,r2
    222c:	e13ffd17 	ldw	r4,-12(fp)
    2230:	100b883a 	mov	r5,r2
    2234:	0003f300 	call	3f30 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    2238:	e13ffd17 	ldw	r4,-12(fp)
    223c:	01400d84 	movi	r5,54
    2240:	01800104 	movi	r6,4
    2244:	0003cd80 	call	3cd8 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->server_ip_addr)));
    2248:	e0bffd17 	ldw	r2,-12(fp)
    224c:	10800817 	ldw	r2,32(r2)
    2250:	1006d63a 	srli	r3,r2,24
    2254:	e0bffd17 	ldw	r2,-12(fp)
    2258:	10800817 	ldw	r2,32(r2)
    225c:	1004d23a 	srli	r2,r2,8
    2260:	10bfc00c 	andi	r2,r2,65280
    2264:	1886b03a 	or	r3,r3,r2
    2268:	e0bffd17 	ldw	r2,-12(fp)
    226c:	10800817 	ldw	r2,32(r2)
    2270:	10bfc00c 	andi	r2,r2,65280
    2274:	1004923a 	slli	r2,r2,8
    2278:	1886b03a 	or	r3,r3,r2
    227c:	e0bffd17 	ldw	r2,-12(fp)
    2280:	10800817 	ldw	r2,32(r2)
    2284:	1004963a 	slli	r2,r2,24
    2288:	1884b03a 	or	r2,r3,r2
    228c:	e13ffd17 	ldw	r4,-12(fp)
    2290:	100b883a 	mov	r5,r2
    2294:	0003f300 	call	3f30 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
    2298:	e13ffd17 	ldw	r4,-12(fp)
    229c:	01400dc4 	movi	r5,55
    22a0:	01800104 	movi	r6,4
    22a4:	0003cd80 	call	3cd8 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
    22a8:	e13ffd17 	ldw	r4,-12(fp)
    22ac:	01400044 	movi	r5,1
    22b0:	0003dbc0 	call	3dbc <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
    22b4:	e13ffd17 	ldw	r4,-12(fp)
    22b8:	014000c4 	movi	r5,3
    22bc:	0003dbc0 	call	3dbc <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
    22c0:	e13ffd17 	ldw	r4,-12(fp)
    22c4:	01400704 	movi	r5,28
    22c8:	0003dbc0 	call	3dbc <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
    22cc:	e13ffd17 	ldw	r4,-12(fp)
    22d0:	01400184 	movi	r5,6
    22d4:	0003dbc0 	call	3dbc <dhcp_option_byte>

#if LWIP_NETIF_HOSTNAME
    dhcp_option_hostname(dhcp, netif);
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
    22d8:	e13ffd17 	ldw	r4,-12(fp)
    22dc:	00052600 	call	5260 <dhcp_option_trailer>
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    22e0:	e0bffd17 	ldw	r2,-12(fp)
    22e4:	10c00417 	ldw	r3,16(r2)
    22e8:	e0bffd17 	ldw	r2,-12(fp)
    22ec:	1080060b 	ldhu	r2,24(r2)
    22f0:	10803c04 	addi	r2,r2,240
    22f4:	10bfffcc 	andi	r2,r2,65535
    22f8:	1809883a 	mov	r4,r3
    22fc:	100b883a 	mov	r5,r2
    2300:	000a5b80 	call	a5b8 <pbuf_realloc>

    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    2304:	e0bffd17 	ldw	r2,-12(fp)
    2308:	10c00117 	ldw	r3,4(r2)
    230c:	e0bffd17 	ldw	r2,-12(fp)
    2310:	10800417 	ldw	r2,16(r2)
    2314:	e13fff17 	ldw	r4,-4(fp)
    2318:	d9000015 	stw	r4,0(sp)
    231c:	1809883a 	mov	r4,r3
    2320:	100b883a 	mov	r5,r2
    2324:	018000f4 	movhi	r6,3
    2328:	31957504 	addi	r6,r6,21972
    232c:	01c010c4 	movi	r7,67
    2330:	00157880 	call	15788 <udp_sendto_if>
    dhcp_delete_msg(dhcp);
    2334:	e13ffd17 	ldw	r4,-12(fp)
    2338:	00051800 	call	5180 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    233c:	e0bffd17 	ldw	r2,-12(fp)
    2340:	10800343 	ldbu	r2,13(r2)
    2344:	10800044 	addi	r2,r2,1
    2348:	1007883a 	mov	r3,r2
    234c:	e0bffd17 	ldw	r2,-12(fp)
    2350:	10c00345 	stb	r3,13(r2)
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
    2354:	e0bffd17 	ldw	r2,-12(fp)
    2358:	10800343 	ldbu	r2,13(r2)
    235c:	10803fcc 	andi	r2,r2,255
    2360:	108001a8 	cmpgeui	r2,r2,6
    2364:	1000061e 	bne	r2,zero,2380 <dhcp_select+0x218>
    2368:	e0bffd17 	ldw	r2,-12(fp)
    236c:	10800343 	ldbu	r2,13(r2)
    2370:	10803fcc 	andi	r2,r2,255
    2374:	00c0fa04 	movi	r3,1000
    2378:	1884983a 	sll	r2,r3,r2
    237c:	00000106 	br	2384 <dhcp_select+0x21c>
    2380:	00ba9804 	movi	r2,-5536
    2384:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    2388:	e0bffe8b 	ldhu	r2,-6(fp)
    238c:	10c07cc4 	addi	r3,r2,499
    2390:	00807d04 	movi	r2,500
    2394:	1885283a 	div	r2,r3,r2
    2398:	1007883a 	mov	r3,r2
    239c:	e0bffd17 	ldw	r2,-12(fp)
    23a0:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
    23a4:	e0bffe03 	ldbu	r2,-8(fp)
}
    23a8:	e037883a 	mov	sp,fp
    23ac:	dfc00117 	ldw	ra,4(sp)
    23b0:	df000017 	ldw	fp,0(sp)
    23b4:	dec00204 	addi	sp,sp,8
    23b8:	f800283a 	ret

000023bc <dhcp_coarse_tmr>:
/**
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 */
void
dhcp_coarse_tmr()
{
    23bc:	defffd04 	addi	sp,sp,-12
    23c0:	dfc00215 	stw	ra,8(sp)
    23c4:	df000115 	stw	fp,4(sp)
    23c8:	df000104 	addi	fp,sp,4
  struct netif *netif = netif_list;
    23cc:	008000f4 	movhi	r2,3
    23d0:	109e2904 	addi	r2,r2,30884
    23d4:	10800017 	ldw	r2,0(r2)
    23d8:	e0bfff15 	stw	r2,-4(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
    23dc:	00001d06 	br	2454 <dhcp_coarse_tmr+0x98>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
    23e0:	e0bfff17 	ldw	r2,-4(fp)
    23e4:	10800817 	ldw	r2,32(r2)
    23e8:	10001726 	beq	r2,zero,2448 <dhcp_coarse_tmr+0x8c>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
    23ec:	e0bfff17 	ldw	r2,-4(fp)
    23f0:	10800817 	ldw	r2,32(r2)
    23f4:	10c0078b 	ldhu	r3,30(r2)
    23f8:	193fffcc 	andi	r4,r3,65535
    23fc:	21000060 	cmpeqi	r4,r4,1
    2400:	18ffffc4 	addi	r3,r3,-1
    2404:	10c0078d 	sth	r3,30(r2)
    2408:	20803fcc 	andi	r2,r4,255
    240c:	10000326 	beq	r2,zero,241c <dhcp_coarse_tmr+0x60>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
    2410:	e13fff17 	ldw	r4,-4(fp)
    2414:	00027380 	call	2738 <dhcp_t2_timeout>
    2418:	00000b06 	br	2448 <dhcp_coarse_tmr+0x8c>
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
    241c:	e0bfff17 	ldw	r2,-4(fp)
    2420:	10800817 	ldw	r2,32(r2)
    2424:	10c0070b 	ldhu	r3,28(r2)
    2428:	193fffcc 	andi	r4,r3,65535
    242c:	21000060 	cmpeqi	r4,r4,1
    2430:	18ffffc4 	addi	r3,r3,-1
    2434:	10c0070d 	sth	r3,28(r2)
    2438:	20803fcc 	andi	r2,r4,255
    243c:	10000226 	beq	r2,zero,2448 <dhcp_coarse_tmr+0x8c>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t1 timeout\n"));
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
    2440:	e13fff17 	ldw	r4,-4(fp)
    2444:	00026c00 	call	26c0 <dhcp_t1_timeout>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
    2448:	e0bfff17 	ldw	r2,-4(fp)
    244c:	10800017 	ldw	r2,0(r2)
    2450:	e0bfff15 	stw	r2,-4(fp)
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
    2454:	e0bfff17 	ldw	r2,-4(fp)
    2458:	103fe11e 	bne	r2,zero,23e0 <dhcp_coarse_tmr+0x24>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
    245c:	e037883a 	mov	sp,fp
    2460:	dfc00117 	ldw	ra,4(sp)
    2464:	df000017 	ldw	fp,0(sp)
    2468:	dec00204 	addi	sp,sp,8
    246c:	f800283a 	ret

00002470 <dhcp_fine_tmr>:
 * A DHCP server is expected to respond within a short period of time.
 * This timer checks whether an outstanding DHCP request is timed out.
 */
void
dhcp_fine_tmr()
{
    2470:	defffd04 	addi	sp,sp,-12
    2474:	dfc00215 	stw	ra,8(sp)
    2478:	df000115 	stw	fp,4(sp)
    247c:	df000104 	addi	fp,sp,4
  struct netif *netif = netif_list;
    2480:	008000f4 	movhi	r2,3
    2484:	109e2904 	addi	r2,r2,30884
    2488:	10800017 	ldw	r2,0(r2)
    248c:	e0bfff15 	stw	r2,-4(fp)
  /* loop through netif's */
  while (netif != NULL) {
    2490:	00001f06 	br	2510 <dhcp_fine_tmr+0xa0>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
    2494:	e0bfff17 	ldw	r2,-4(fp)
    2498:	10800817 	ldw	r2,32(r2)
    249c:	10001926 	beq	r2,zero,2504 <dhcp_fine_tmr+0x94>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
    24a0:	e0bfff17 	ldw	r2,-4(fp)
    24a4:	10800817 	ldw	r2,32(r2)
    24a8:	1080068b 	ldhu	r2,26(r2)
    24ac:	10bfffcc 	andi	r2,r2,65535
    24b0:	108000b0 	cmpltui	r2,r2,2
    24b4:	1000061e 	bne	r2,zero,24d0 <dhcp_fine_tmr+0x60>
        netif->dhcp->request_timeout--;
    24b8:	e0bfff17 	ldw	r2,-4(fp)
    24bc:	10800817 	ldw	r2,32(r2)
    24c0:	10c0068b 	ldhu	r3,26(r2)
    24c4:	18ffffc4 	addi	r3,r3,-1
    24c8:	10c0068d 	sth	r3,26(r2)
    24cc:	00000d06 	br	2504 <dhcp_fine_tmr+0x94>
      }
      else if (netif->dhcp->request_timeout == 1) {
    24d0:	e0bfff17 	ldw	r2,-4(fp)
    24d4:	10800817 	ldw	r2,32(r2)
    24d8:	1080068b 	ldhu	r2,26(r2)
    24dc:	10bfffcc 	andi	r2,r2,65535
    24e0:	10800058 	cmpnei	r2,r2,1
    24e4:	1000071e 	bne	r2,zero,2504 <dhcp_fine_tmr+0x94>
        netif->dhcp->request_timeout--;
    24e8:	e0bfff17 	ldw	r2,-4(fp)
    24ec:	10800817 	ldw	r2,32(r2)
    24f0:	10c0068b 	ldhu	r3,26(r2)
    24f4:	18ffffc4 	addi	r3,r3,-1
    24f8:	10c0068d 	sth	r3,26(r2)
        /* { netif->dhcp->request_timeout == 0 } */
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_fine_tmr(): request timeout\n"));
        /* this client's request timeout triggered */
        dhcp_timeout(netif);
    24fc:	e13fff17 	ldw	r4,-4(fp)
    2500:	000252c0 	call	252c <dhcp_timeout>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
    2504:	e0bfff17 	ldw	r2,-4(fp)
    2508:	10800017 	ldw	r2,0(r2)
    250c:	e0bfff15 	stw	r2,-4(fp)
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
    2510:	e0bfff17 	ldw	r2,-4(fp)
    2514:	103fdf1e 	bne	r2,zero,2494 <dhcp_fine_tmr+0x24>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
    2518:	e037883a 	mov	sp,fp
    251c:	dfc00117 	ldw	ra,4(sp)
    2520:	df000017 	ldw	fp,0(sp)
    2524:	dec00204 	addi	sp,sp,8
    2528:	f800283a 	ret

0000252c <dhcp_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
    252c:	defffc04 	addi	sp,sp,-16
    2530:	dfc00315 	stw	ra,12(sp)
    2534:	df000215 	stw	fp,8(sp)
    2538:	df000204 	addi	fp,sp,8
    253c:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    2540:	e0bfff17 	ldw	r2,-4(fp)
    2544:	10800817 	ldw	r2,32(r2)
    2548:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
    254c:	e0bffe17 	ldw	r2,-8(fp)
    2550:	10800303 	ldbu	r2,12(r2)
    2554:	10803fcc 	andi	r2,r2,255
    2558:	10800320 	cmpeqi	r2,r2,12
    255c:	1000051e 	bne	r2,zero,2574 <dhcp_timeout+0x48>
    2560:	e0bffe17 	ldw	r2,-8(fp)
    2564:	10800303 	ldbu	r2,12(r2)
    2568:	10803fcc 	andi	r2,r2,255
    256c:	10800198 	cmpnei	r2,r2,6
    2570:	1000031e 	bne	r2,zero,2580 <dhcp_timeout+0x54>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
    2574:	e13fff17 	ldw	r4,-4(fp)
    2578:	00031900 	call	3190 <dhcp_discover>
    257c:	00004b06 	br	26ac <dhcp_timeout+0x180>
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
    2580:	e0bffe17 	ldw	r2,-8(fp)
    2584:	10800303 	ldbu	r2,12(r2)
    2588:	10803fcc 	andi	r2,r2,255
    258c:	10800058 	cmpnei	r2,r2,1
    2590:	10000d1e 	bne	r2,zero,25c8 <dhcp_timeout+0x9c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
    2594:	e0bffe17 	ldw	r2,-8(fp)
    2598:	10800343 	ldbu	r2,13(r2)
    259c:	10803fcc 	andi	r2,r2,255
    25a0:	108001a8 	cmpgeui	r2,r2,6
    25a4:	1000031e 	bne	r2,zero,25b4 <dhcp_timeout+0x88>
      dhcp_select(netif);
    25a8:	e13fff17 	ldw	r4,-4(fp)
    25ac:	00021680 	call	2168 <dhcp_select>
    25b0:	00003e06 	br	26ac <dhcp_timeout+0x180>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
    25b4:	e13fff17 	ldw	r4,-4(fp)
    25b8:	00039f40 	call	39f4 <dhcp_release>
      dhcp_discover(netif);
    25bc:	e13fff17 	ldw	r4,-4(fp)
    25c0:	00031900 	call	3190 <dhcp_discover>
    25c4:	00003906 	br	26ac <dhcp_timeout+0x180>
    }
#if DHCP_DOES_ARP_CHECK
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
    25c8:	e0bffe17 	ldw	r2,-8(fp)
    25cc:	10800303 	ldbu	r2,12(r2)
    25d0:	10803fcc 	andi	r2,r2,255
    25d4:	10800218 	cmpnei	r2,r2,8
    25d8:	10000b1e 	bne	r2,zero,2608 <dhcp_timeout+0xdc>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
    25dc:	e0bffe17 	ldw	r2,-8(fp)
    25e0:	10800343 	ldbu	r2,13(r2)
    25e4:	10803fcc 	andi	r2,r2,255
    25e8:	108000a8 	cmpgeui	r2,r2,2
    25ec:	1000031e 	bne	r2,zero,25fc <dhcp_timeout+0xd0>
      dhcp_check(netif);
    25f0:	e13fff17 	ldw	r4,-4(fp)
    25f4:	00020000 	call	2000 <dhcp_check>
    25f8:	00002c06 	br	26ac <dhcp_timeout+0x180>
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
    25fc:	e13fff17 	ldw	r4,-4(fp)
    2600:	00033300 	call	3330 <dhcp_bind>
    2604:	00002906 	br	26ac <dhcp_timeout+0x180>
    }
#endif /* DHCP_DOES_ARP_CHECK */
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
    2608:	e0bffe17 	ldw	r2,-8(fp)
    260c:	10800303 	ldbu	r2,12(r2)
    2610:	10803fcc 	andi	r2,r2,255
    2614:	10800158 	cmpnei	r2,r2,5
    2618:	1000031e 	bne	r2,zero,2628 <dhcp_timeout+0xfc>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
    261c:	e13fff17 	ldw	r4,-4(fp)
    2620:	00035b00 	call	35b0 <dhcp_renew>
    2624:	00002106 	br	26ac <dhcp_timeout+0x180>
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
    2628:	e0bffe17 	ldw	r2,-8(fp)
    262c:	10800303 	ldbu	r2,12(r2)
    2630:	10803fcc 	andi	r2,r2,255
    2634:	10800118 	cmpnei	r2,r2,4
    2638:	10000d1e 	bne	r2,zero,2670 <dhcp_timeout+0x144>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
    263c:	e0bffe17 	ldw	r2,-8(fp)
    2640:	10800343 	ldbu	r2,13(r2)
    2644:	10803fcc 	andi	r2,r2,255
    2648:	10800268 	cmpgeui	r2,r2,9
    264c:	1000031e 	bne	r2,zero,265c <dhcp_timeout+0x130>
      dhcp_rebind(netif);
    2650:	e13fff17 	ldw	r4,-4(fp)
    2654:	00037000 	call	3700 <dhcp_rebind>
    2658:	00001406 	br	26ac <dhcp_timeout+0x180>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
    265c:	e13fff17 	ldw	r4,-4(fp)
    2660:	00039f40 	call	39f4 <dhcp_release>
      dhcp_discover(netif);
    2664:	e13fff17 	ldw	r4,-4(fp)
    2668:	00031900 	call	3190 <dhcp_discover>
    266c:	00000f06 	br	26ac <dhcp_timeout+0x180>
    }
  } else if (dhcp->state == DHCP_REBOOTING) {
    2670:	e0bffe17 	ldw	r2,-8(fp)
    2674:	10800303 	ldbu	r2,12(r2)
    2678:	10803fcc 	andi	r2,r2,255
    267c:	108000d8 	cmpnei	r2,r2,3
    2680:	10000a1e 	bne	r2,zero,26ac <dhcp_timeout+0x180>
    if (dhcp->tries < REBOOT_TRIES) {
    2684:	e0bffe17 	ldw	r2,-8(fp)
    2688:	10800343 	ldbu	r2,13(r2)
    268c:	10803fcc 	andi	r2,r2,255
    2690:	108000a8 	cmpgeui	r2,r2,2
    2694:	1000031e 	bne	r2,zero,26a4 <dhcp_timeout+0x178>
      dhcp_reboot(netif);
    2698:	e13fff17 	ldw	r4,-4(fp)
    269c:	00038500 	call	3850 <dhcp_reboot>
    26a0:	00000206 	br	26ac <dhcp_timeout+0x180>
    } else {
      dhcp_discover(netif);
    26a4:	e13fff17 	ldw	r4,-4(fp)
    26a8:	00031900 	call	3190 <dhcp_discover>
    }
  }
}
    26ac:	e037883a 	mov	sp,fp
    26b0:	dfc00117 	ldw	ra,4(sp)
    26b4:	df000017 	ldw	fp,0(sp)
    26b8:	dec00204 	addi	sp,sp,8
    26bc:	f800283a 	ret

000026c0 <dhcp_t1_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t1_timeout(struct netif *netif)
{
    26c0:	defffc04 	addi	sp,sp,-16
    26c4:	dfc00315 	stw	ra,12(sp)
    26c8:	df000215 	stw	fp,8(sp)
    26cc:	df000204 	addi	fp,sp,8
    26d0:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    26d4:	e0bfff17 	ldw	r2,-4(fp)
    26d8:	10800817 	ldw	r2,32(r2)
    26dc:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) ||
    26e0:	e0bffe17 	ldw	r2,-8(fp)
    26e4:	10800303 	ldbu	r2,12(r2)
    26e8:	10803fcc 	andi	r2,r2,255
    26ec:	10800060 	cmpeqi	r2,r2,1
    26f0:	10000a1e 	bne	r2,zero,271c <dhcp_t1_timeout+0x5c>
    26f4:	e0bffe17 	ldw	r2,-8(fp)
    26f8:	10800303 	ldbu	r2,12(r2)
    26fc:	10803fcc 	andi	r2,r2,255
    2700:	108002a0 	cmpeqi	r2,r2,10
    2704:	1000051e 	bne	r2,zero,271c <dhcp_t1_timeout+0x5c>
      (dhcp->state == DHCP_RENEWING)) {
    2708:	e0bffe17 	ldw	r2,-8(fp)
    270c:	10800303 	ldbu	r2,12(r2)
static void
dhcp_t1_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) ||
    2710:	10803fcc 	andi	r2,r2,255
    2714:	10800158 	cmpnei	r2,r2,5
    2718:	1000021e 	bne	r2,zero,2724 <dhcp_t1_timeout+0x64>
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
                ("dhcp_t1_timeout(): must renew\n"));
    /* This slightly different to RFC2131: DHCPREQUEST will be sent from state
       DHCP_RENEWING, not DHCP_BOUND */
    dhcp_renew(netif);
    271c:	e13fff17 	ldw	r4,-4(fp)
    2720:	00035b00 	call	35b0 <dhcp_renew>
  }
}
    2724:	e037883a 	mov	sp,fp
    2728:	dfc00117 	ldw	ra,4(sp)
    272c:	df000017 	ldw	fp,0(sp)
    2730:	dec00204 	addi	sp,sp,8
    2734:	f800283a 	ret

00002738 <dhcp_t2_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t2_timeout(struct netif *netif)
{
    2738:	defffc04 	addi	sp,sp,-16
    273c:	dfc00315 	stw	ra,12(sp)
    2740:	df000215 	stw	fp,8(sp)
    2744:	df000204 	addi	fp,sp,8
    2748:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    274c:	e0bfff17 	ldw	r2,-4(fp)
    2750:	10800817 	ldw	r2,32(r2)
    2754:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) ||
    2758:	e0bffe17 	ldw	r2,-8(fp)
    275c:	10800303 	ldbu	r2,12(r2)
    2760:	10803fcc 	andi	r2,r2,255
    2764:	10800060 	cmpeqi	r2,r2,1
    2768:	10000a1e 	bne	r2,zero,2794 <dhcp_t2_timeout+0x5c>
    276c:	e0bffe17 	ldw	r2,-8(fp)
    2770:	10800303 	ldbu	r2,12(r2)
    2774:	10803fcc 	andi	r2,r2,255
    2778:	108002a0 	cmpeqi	r2,r2,10
    277c:	1000051e 	bne	r2,zero,2794 <dhcp_t2_timeout+0x5c>
      (dhcp->state == DHCP_RENEWING)) {
    2780:	e0bffe17 	ldw	r2,-8(fp)
    2784:	10800303 	ldbu	r2,12(r2)
static void
dhcp_t2_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) ||
    2788:	10803fcc 	andi	r2,r2,255
    278c:	10800158 	cmpnei	r2,r2,5
    2790:	1000021e 	bne	r2,zero,279c <dhcp_t2_timeout+0x64>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
                ("dhcp_t2_timeout(): must rebind\n"));
    /* This slightly different to RFC2131: DHCPREQUEST will be sent from state
       DHCP_REBINDING, not DHCP_BOUND */
    dhcp_rebind(netif);
    2794:	e13fff17 	ldw	r4,-4(fp)
    2798:	00037000 	call	3700 <dhcp_rebind>
  }
}
    279c:	e037883a 	mov	sp,fp
    27a0:	dfc00117 	ldw	ra,4(sp)
    27a4:	df000017 	ldw	fp,0(sp)
    27a8:	dec00204 	addi	sp,sp,8
    27ac:	f800283a 	ret

000027b0 <dhcp_handle_ack>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
    27b0:	defffd04 	addi	sp,sp,-12
    27b4:	df000215 	stw	fp,8(sp)
    27b8:	df000204 	addi	fp,sp,8
    27bc:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    27c0:	e0bfff17 	ldw	r2,-4(fp)
    27c4:	10800817 	ldw	r2,32(r2)
    27c8:	e0bffe15 	stw	r2,-8(fp)
#if LWIP_DNS
  u8_t n;
#endif /* LWIP_DNS */

  /* clear options we might not get from the ACK */
  ip_addr_set_zero(&dhcp->offered_sn_mask);
    27cc:	e0bffe17 	ldw	r2,-8(fp)
    27d0:	10000a15 	stw	zero,40(r2)
  ip_addr_set_zero(&dhcp->offered_gw_addr);
    27d4:	e0bffe17 	ldw	r2,-8(fp)
    27d8:	10000b15 	stw	zero,44(r2)
#if LWIP_DHCP_BOOTP_FILE
  ip_addr_set_zero(&dhcp->offered_si_addr);
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* lease time given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_LEASE_TIME)) {
    27dc:	00800234 	movhi	r2,8
    27e0:	10821b04 	addi	r2,r2,2156
    27e4:	108000c3 	ldbu	r2,3(r2)
    27e8:	10803fcc 	andi	r2,r2,255
    27ec:	10000526 	beq	r2,zero,2804 <dhcp_handle_ack+0x54>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_LEASE_TIME);
    27f0:	00800234 	movhi	r2,8
    27f4:	10821e04 	addi	r2,r2,2168
    27f8:	10c00317 	ldw	r3,12(r2)
    27fc:	e0bffe17 	ldw	r2,-8(fp)
    2800:	10c00c15 	stw	r3,48(r2)
  }
  /* renewal period given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T1)) {
    2804:	00800234 	movhi	r2,8
    2808:	10821b04 	addi	r2,r2,2156
    280c:	10800103 	ldbu	r2,4(r2)
    2810:	10803fcc 	andi	r2,r2,255
    2814:	10000626 	beq	r2,zero,2830 <dhcp_handle_ack+0x80>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T1);
    2818:	00800234 	movhi	r2,8
    281c:	10821e04 	addi	r2,r2,2168
    2820:	10c00417 	ldw	r3,16(r2)
    2824:	e0bffe17 	ldw	r2,-8(fp)
    2828:	10c00d15 	stw	r3,52(r2)
    282c:	00000506 	br	2844 <dhcp_handle_ack+0x94>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
    2830:	e0bffe17 	ldw	r2,-8(fp)
    2834:	10800c17 	ldw	r2,48(r2)
    2838:	1006d07a 	srli	r3,r2,1
    283c:	e0bffe17 	ldw	r2,-8(fp)
    2840:	10c00d15 	stw	r3,52(r2)
  }

  /* renewal period given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T2)) {
    2844:	00800234 	movhi	r2,8
    2848:	10821b04 	addi	r2,r2,2156
    284c:	10800143 	ldbu	r2,5(r2)
    2850:	10803fcc 	andi	r2,r2,255
    2854:	10000626 	beq	r2,zero,2870 <dhcp_handle_ack+0xc0>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T2);
    2858:	00800234 	movhi	r2,8
    285c:	10821e04 	addi	r2,r2,2168
    2860:	10c00517 	ldw	r3,20(r2)
    2864:	e0bffe17 	ldw	r2,-8(fp)
    2868:	10c00e15 	stw	r3,56(r2)
    286c:	00000406 	br	2880 <dhcp_handle_ack+0xd0>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
    2870:	e0bffe17 	ldw	r2,-8(fp)
    2874:	10c00c17 	ldw	r3,48(r2)
    2878:	e0bffe17 	ldw	r2,-8(fp)
    287c:	10c00e15 	stw	r3,56(r2)
  }

  /* (y)our internet address */
  ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
    2880:	e0bffe17 	ldw	r2,-8(fp)
    2884:	10800217 	ldw	r2,8(r2)
    2888:	10c0040b 	ldhu	r3,16(r2)
    288c:	1080048b 	ldhu	r2,18(r2)
    2890:	1004943a 	slli	r2,r2,16
    2894:	10c4b03a 	or	r2,r2,r3
    2898:	1007883a 	mov	r3,r2
    289c:	e0bffe17 	ldw	r2,-8(fp)
    28a0:	10c00915 	stw	r3,36(r2)
     boot file name copied in dhcp_parse_reply if not overloaded */
  ip_addr_copy(dhcp->offered_si_addr, dhcp->msg_in->siaddr);
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* subnet mask given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)) {
    28a4:	00800234 	movhi	r2,8
    28a8:	10821b04 	addi	r2,r2,2156
    28ac:	10800183 	ldbu	r2,6(r2)
    28b0:	10803fcc 	andi	r2,r2,255
    28b4:	10001b26 	beq	r2,zero,2924 <dhcp_handle_ack+0x174>
    /* remember given subnet mask */
    ip4_addr_set_u32(&dhcp->offered_sn_mask, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)));
    28b8:	00800234 	movhi	r2,8
    28bc:	10821e04 	addi	r2,r2,2168
    28c0:	10800617 	ldw	r2,24(r2)
    28c4:	1006d63a 	srli	r3,r2,24
    28c8:	00800234 	movhi	r2,8
    28cc:	10821e04 	addi	r2,r2,2168
    28d0:	10800617 	ldw	r2,24(r2)
    28d4:	1004d23a 	srli	r2,r2,8
    28d8:	10bfc00c 	andi	r2,r2,65280
    28dc:	1886b03a 	or	r3,r3,r2
    28e0:	00800234 	movhi	r2,8
    28e4:	10821e04 	addi	r2,r2,2168
    28e8:	10800617 	ldw	r2,24(r2)
    28ec:	10bfc00c 	andi	r2,r2,65280
    28f0:	1004923a 	slli	r2,r2,8
    28f4:	1886b03a 	or	r3,r3,r2
    28f8:	00800234 	movhi	r2,8
    28fc:	10821e04 	addi	r2,r2,2168
    2900:	10800617 	ldw	r2,24(r2)
    2904:	1004963a 	slli	r2,r2,24
    2908:	1886b03a 	or	r3,r3,r2
    290c:	e0bffe17 	ldw	r2,-8(fp)
    2910:	10c00a15 	stw	r3,40(r2)
    dhcp->subnet_mask_given = 1;
    2914:	e0bffe17 	ldw	r2,-8(fp)
    2918:	00c00044 	movi	r3,1
    291c:	10c00385 	stb	r3,14(r2)
    2920:	00000206 	br	292c <dhcp_handle_ack+0x17c>
  } else {
    dhcp->subnet_mask_given = 0;
    2924:	e0bffe17 	ldw	r2,-8(fp)
    2928:	10000385 	stb	zero,14(r2)
  }

  /* gateway router */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_ROUTER)) {
    292c:	00800234 	movhi	r2,8
    2930:	10821b04 	addi	r2,r2,2156
    2934:	108001c3 	ldbu	r2,7(r2)
    2938:	10803fcc 	andi	r2,r2,255
    293c:	10001726 	beq	r2,zero,299c <dhcp_handle_ack+0x1ec>
    ip4_addr_set_u32(&dhcp->offered_gw_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_ROUTER)));
    2940:	00800234 	movhi	r2,8
    2944:	10821e04 	addi	r2,r2,2168
    2948:	10800717 	ldw	r2,28(r2)
    294c:	1006d63a 	srli	r3,r2,24
    2950:	00800234 	movhi	r2,8
    2954:	10821e04 	addi	r2,r2,2168
    2958:	10800717 	ldw	r2,28(r2)
    295c:	1004d23a 	srli	r2,r2,8
    2960:	10bfc00c 	andi	r2,r2,65280
    2964:	1886b03a 	or	r3,r3,r2
    2968:	00800234 	movhi	r2,8
    296c:	10821e04 	addi	r2,r2,2168
    2970:	10800717 	ldw	r2,28(r2)
    2974:	10bfc00c 	andi	r2,r2,65280
    2978:	1004923a 	slli	r2,r2,8
    297c:	1886b03a 	or	r3,r3,r2
    2980:	00800234 	movhi	r2,8
    2984:	10821e04 	addi	r2,r2,2168
    2988:	10800717 	ldw	r2,28(r2)
    298c:	1004963a 	slli	r2,r2,24
    2990:	1886b03a 	or	r3,r3,r2
    2994:	e0bffe17 	ldw	r2,-8(fp)
    2998:	10c00b15 	stw	r3,44(r2)
    ip4_addr_set_u32(&dns_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_DNS_SERVER + n)));
    dns_setserver(n, &dns_addr);
    n++;
  }
#endif /* LWIP_DNS */
}
    299c:	e037883a 	mov	sp,fp
    29a0:	df000017 	ldw	fp,0(sp)
    29a4:	dec00104 	addi	sp,sp,4
    29a8:	f800283a 	ret

000029ac <dhcp_set_struct>:
 * @param netif the netif for which to set the struct dhcp
 * @param dhcp (uninitialised) dhcp struct allocated by the application
 */
void
dhcp_set_struct(struct netif *netif, struct dhcp *dhcp)
{
    29ac:	defffc04 	addi	sp,sp,-16
    29b0:	dfc00315 	stw	ra,12(sp)
    29b4:	df000215 	stw	fp,8(sp)
    29b8:	df000204 	addi	fp,sp,8
    29bc:	e13ffe15 	stw	r4,-8(fp)
    29c0:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT("netif != NULL", netif != NULL);
    29c4:	e0bffe17 	ldw	r2,-8(fp)
    29c8:	1000091e 	bne	r2,zero,29f0 <dhcp_set_struct+0x44>
    29cc:	010000f4 	movhi	r4,3
    29d0:	213ccf04 	addi	r4,r4,-3268
    29d4:	014000f4 	movhi	r5,3
    29d8:	297cd904 	addi	r5,r5,-3228
    29dc:	01809344 	movi	r6,589
    29e0:	01c000f4 	movhi	r7,3
    29e4:	39fcdd04 	addi	r7,r7,-3212
    29e8:	00193f00 	call	193f0 <printf>
    29ec:	003fff06 	br	29ec <dhcp_set_struct+0x40>
  LWIP_ASSERT("dhcp != NULL", dhcp != NULL);
    29f0:	e0bfff17 	ldw	r2,-4(fp)
    29f4:	1000091e 	bne	r2,zero,2a1c <dhcp_set_struct+0x70>
    29f8:	010000f4 	movhi	r4,3
    29fc:	213ccf04 	addi	r4,r4,-3268
    2a00:	014000f4 	movhi	r5,3
    2a04:	297ce304 	addi	r5,r5,-3188
    2a08:	01809384 	movi	r6,590
    2a0c:	01c000f4 	movhi	r7,3
    2a10:	39fcdd04 	addi	r7,r7,-3212
    2a14:	00193f00 	call	193f0 <printf>
    2a18:	003fff06 	br	2a18 <dhcp_set_struct+0x6c>
  LWIP_ASSERT("netif already has a struct dhcp set", netif->dhcp == NULL);
    2a1c:	e0bffe17 	ldw	r2,-8(fp)
    2a20:	10800817 	ldw	r2,32(r2)
    2a24:	10000926 	beq	r2,zero,2a4c <dhcp_set_struct+0xa0>
    2a28:	010000f4 	movhi	r4,3
    2a2c:	213ccf04 	addi	r4,r4,-3268
    2a30:	014000f4 	movhi	r5,3
    2a34:	297ce704 	addi	r5,r5,-3172
    2a38:	018093c4 	movi	r6,591
    2a3c:	01c000f4 	movhi	r7,3
    2a40:	39fcdd04 	addi	r7,r7,-3212
    2a44:	00193f00 	call	193f0 <printf>
    2a48:	003fff06 	br	2a48 <dhcp_set_struct+0x9c>

  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
    2a4c:	e13fff17 	ldw	r4,-4(fp)
    2a50:	000b883a 	mov	r5,zero
    2a54:	01800f04 	movi	r6,60
    2a58:	00192e80 	call	192e8 <memset>
  /* dhcp_set_state(&dhcp, DHCP_OFF); */
  netif->dhcp = dhcp;
    2a5c:	e0bffe17 	ldw	r2,-8(fp)
    2a60:	e0ffff17 	ldw	r3,-4(fp)
    2a64:	10c00815 	stw	r3,32(r2)
}
    2a68:	e037883a 	mov	sp,fp
    2a6c:	dfc00117 	ldw	ra,4(sp)
    2a70:	df000017 	ldw	fp,0(sp)
    2a74:	dec00204 	addi	sp,sp,8
    2a78:	f800283a 	ret

00002a7c <dhcp_cleanup>:
 *            struct dhcp since the memory is passed back to the heap.
 *
 * @param netif the netif from which to remove the struct dhcp
 */
void dhcp_cleanup(struct netif *netif)
{
    2a7c:	defffd04 	addi	sp,sp,-12
    2a80:	dfc00215 	stw	ra,8(sp)
    2a84:	df000115 	stw	fp,4(sp)
    2a88:	df000104 	addi	fp,sp,4
    2a8c:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("netif != NULL", netif != NULL);
    2a90:	e0bfff17 	ldw	r2,-4(fp)
    2a94:	1000091e 	bne	r2,zero,2abc <dhcp_cleanup+0x40>
    2a98:	010000f4 	movhi	r4,3
    2a9c:	213ccf04 	addi	r4,r4,-3268
    2aa0:	014000f4 	movhi	r5,3
    2aa4:	297cd904 	addi	r5,r5,-3228
    2aa8:	01809804 	movi	r6,608
    2aac:	01c000f4 	movhi	r7,3
    2ab0:	39fcdd04 	addi	r7,r7,-3212
    2ab4:	00193f00 	call	193f0 <printf>
    2ab8:	003fff06 	br	2ab8 <dhcp_cleanup+0x3c>

  if (netif->dhcp != NULL) {
    2abc:	e0bfff17 	ldw	r2,-4(fp)
    2ac0:	10800817 	ldw	r2,32(r2)
    2ac4:	10000626 	beq	r2,zero,2ae0 <dhcp_cleanup+0x64>
    mem_free(netif->dhcp);
    2ac8:	e0bfff17 	ldw	r2,-4(fp)
    2acc:	10800817 	ldw	r2,32(r2)
    2ad0:	1009883a 	mov	r4,r2
    2ad4:	0008afc0 	call	8afc <mem_free>
    netif->dhcp = NULL;
    2ad8:	e0bfff17 	ldw	r2,-4(fp)
    2adc:	10000815 	stw	zero,32(r2)
  }
}
    2ae0:	e037883a 	mov	sp,fp
    2ae4:	dfc00117 	ldw	ra,4(sp)
    2ae8:	df000017 	ldw	fp,0(sp)
    2aec:	dec00204 	addi	sp,sp,8
    2af0:	f800283a 	ret

00002af4 <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
    2af4:	defffb04 	addi	sp,sp,-20
    2af8:	dfc00415 	stw	ra,16(sp)
    2afc:	df000315 	stw	fp,12(sp)
    2b00:	df000304 	addi	fp,sp,12
    2b04:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp;
  err_t result = ERR_OK;
    2b08:	e03ffe05 	stb	zero,-8(fp)

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
    2b0c:	e0bfff17 	ldw	r2,-4(fp)
    2b10:	1000091e 	bne	r2,zero,2b38 <dhcp_start+0x44>
    2b14:	010000f4 	movhi	r4,3
    2b18:	213ccf04 	addi	r4,r4,-3268
    2b1c:	014000f4 	movhi	r5,3
    2b20:	297cd904 	addi	r5,r5,-3228
    2b24:	01809e84 	movi	r6,634
    2b28:	01c000f4 	movhi	r7,3
    2b2c:	39fcdd04 	addi	r7,r7,-3212
    2b30:	00193f00 	call	193f0 <printf>
    2b34:	003fff06 	br	2b34 <dhcp_start+0x40>
  dhcp = netif->dhcp;
    2b38:	e0bfff17 	ldw	r2,-4(fp)
    2b3c:	10800817 	ldw	r2,32(r2)
    2b40:	e0bffd15 	stw	r2,-12(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
    2b44:	e0bfff17 	ldw	r2,-4(fp)
    2b48:	10c00b43 	ldbu	r3,45(r2)
    2b4c:	00bffdc4 	movi	r2,-9
    2b50:	1884703a 	and	r2,r3,r2
    2b54:	1007883a 	mov	r3,r2
    2b58:	e0bfff17 	ldw	r2,-4(fp)
    2b5c:	10c00b45 	stb	r3,45(r2)

  /* check hwtype of the netif */
  if ((netif->flags & NETIF_FLAG_ETHARP) == 0) {
    2b60:	e0bfff17 	ldw	r2,-4(fp)
    2b64:	10800b43 	ldbu	r2,45(r2)
    2b68:	10803fcc 	andi	r2,r2,255
    2b6c:	1080080c 	andi	r2,r2,32
    2b70:	1000021e 	bne	r2,zero,2b7c <dhcp_start+0x88>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): No ETHARP netif\n"));
    return ERR_ARG;
    2b74:	00bffc84 	movi	r2,-14
    2b78:	00006b06 	br	2d28 <dhcp_start+0x234>
  }

  /* check MTU of the netif */
  if (netif->mtu < DHCP_MAX_MSG_LEN_MIN_REQUIRED) {
    2b7c:	e0bfff17 	ldw	r2,-4(fp)
    2b80:	1080090b 	ldhu	r2,36(r2)
    2b84:	10bfffcc 	andi	r2,r2,65535
    2b88:	10809028 	cmpgeui	r2,r2,576
    2b8c:	1000021e 	bne	r2,zero,2b98 <dhcp_start+0xa4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): Cannot use this netif with DHCP: MTU is too small\n"));
    return ERR_MEM;
    2b90:	00bfffc4 	movi	r2,-1
    2b94:	00006406 	br	2d28 <dhcp_start+0x234>
  }

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
    2b98:	e0bffd17 	ldw	r2,-12(fp)
    2b9c:	10000b1e 	bne	r2,zero,2bcc <dhcp_start+0xd8>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = (struct dhcp *)mem_malloc(sizeof(struct dhcp));
    2ba0:	01000f04 	movi	r4,60
    2ba4:	0008fcc0 	call	8fcc <mem_malloc>
    2ba8:	e0bffd15 	stw	r2,-12(fp)
    if (dhcp == NULL) {
    2bac:	e0bffd17 	ldw	r2,-12(fp)
    2bb0:	1000021e 	bne	r2,zero,2bbc <dhcp_start+0xc8>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
    2bb4:	00bfffc4 	movi	r2,-1
    2bb8:	00005b06 	br	2d28 <dhcp_start+0x234>
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
    2bbc:	e0bfff17 	ldw	r2,-4(fp)
    2bc0:	e0fffd17 	ldw	r3,-12(fp)
    2bc4:	10c00815 	stw	r3,32(r2)
    2bc8:	00001f06 	br	2c48 <dhcp_start+0x154>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): allocated dhcp"));
  /* already has DHCP client attached */
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(): restarting DHCP configuration\n"));
    if (dhcp->pcb != NULL) {
    2bcc:	e0bffd17 	ldw	r2,-12(fp)
    2bd0:	10800117 	ldw	r2,4(r2)
    2bd4:	10000426 	beq	r2,zero,2be8 <dhcp_start+0xf4>
      udp_remove(dhcp->pcb);
    2bd8:	e0bffd17 	ldw	r2,-12(fp)
    2bdc:	10800117 	ldw	r2,4(r2)
    2be0:	1009883a 	mov	r4,r2
    2be4:	0015d680 	call	15d68 <udp_remove>
    }
    LWIP_ASSERT("pbuf p_out wasn't freed", dhcp->p_out == NULL);
    2be8:	e0bffd17 	ldw	r2,-12(fp)
    2bec:	10800417 	ldw	r2,16(r2)
    2bf0:	10000926 	beq	r2,zero,2c18 <dhcp_start+0x124>
    2bf4:	010000f4 	movhi	r4,3
    2bf8:	213ccf04 	addi	r4,r4,-3268
    2bfc:	014000f4 	movhi	r5,3
    2c00:	297cf004 	addi	r5,r5,-3136
    2c04:	0180a784 	movi	r6,670
    2c08:	01c000f4 	movhi	r7,3
    2c0c:	39fcdd04 	addi	r7,r7,-3212
    2c10:	00193f00 	call	193f0 <printf>
    2c14:	003fff06 	br	2c14 <dhcp_start+0x120>
    LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL );
    2c18:	e0bffd17 	ldw	r2,-12(fp)
    2c1c:	10800217 	ldw	r2,8(r2)
    2c20:	10000926 	beq	r2,zero,2c48 <dhcp_start+0x154>
    2c24:	010000f4 	movhi	r4,3
    2c28:	213ccf04 	addi	r4,r4,-3268
    2c2c:	014000f4 	movhi	r5,3
    2c30:	297cf604 	addi	r5,r5,-3112
    2c34:	0180a7c4 	movi	r6,671
    2c38:	01c000f4 	movhi	r7,3
    2c3c:	39fcdd04 	addi	r7,r7,-3212
    2c40:	00193f00 	call	193f0 <printf>
    2c44:	003fff06 	br	2c44 <dhcp_start+0x150>
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
    2c48:	e13ffd17 	ldw	r4,-12(fp)
    2c4c:	000b883a 	mov	r5,zero
    2c50:	01800f04 	movi	r6,60
    2c54:	00192e80 	call	192e8 <memset>
  /* dhcp_set_state(&dhcp, DHCP_OFF); */
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
    2c58:	0015e040 	call	15e04 <udp_new>
    2c5c:	e0fffd17 	ldw	r3,-12(fp)
    2c60:	18800115 	stw	r2,4(r3)
  if (dhcp->pcb == NULL) {
    2c64:	e0bffd17 	ldw	r2,-12(fp)
    2c68:	10800117 	ldw	r2,4(r2)
    2c6c:	1000021e 	bne	r2,zero,2c78 <dhcp_start+0x184>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    return ERR_MEM;
    2c70:	00bfffc4 	movi	r2,-1
    2c74:	00002c06 	br	2d28 <dhcp_start+0x234>
  }
  ip_set_option(dhcp->pcb, SOF_BROADCAST);
    2c78:	e0bffd17 	ldw	r2,-12(fp)
    2c7c:	10800117 	ldw	r2,4(r2)
    2c80:	e0fffd17 	ldw	r3,-12(fp)
    2c84:	18c00117 	ldw	r3,4(r3)
    2c88:	18c00203 	ldbu	r3,8(r3)
    2c8c:	18c00814 	ori	r3,r3,32
    2c90:	10c00205 	stb	r3,8(r2)
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
    2c94:	e0bffd17 	ldw	r2,-12(fp)
    2c98:	10800117 	ldw	r2,4(r2)
    2c9c:	1009883a 	mov	r4,r2
    2ca0:	014000f4 	movhi	r5,3
    2ca4:	29557404 	addi	r5,r5,21968
    2ca8:	01801104 	movi	r6,68
    2cac:	0015a740 	call	15a74 <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
    2cb0:	e0bffd17 	ldw	r2,-12(fp)
    2cb4:	10800117 	ldw	r2,4(r2)
    2cb8:	1009883a 	mov	r4,r2
    2cbc:	014000f4 	movhi	r5,3
    2cc0:	29557404 	addi	r5,r5,21968
    2cc4:	018010c4 	movi	r6,67
    2cc8:	0015bd40 	call	15bd4 <udp_connect>
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
    2ccc:	e0bffd17 	ldw	r2,-12(fp)
    2cd0:	10800117 	ldw	r2,4(r2)
    2cd4:	1009883a 	mov	r4,r2
    2cd8:	01400034 	movhi	r5,0
    2cdc:	29526204 	addi	r5,r5,18824
    2ce0:	e1bfff17 	ldw	r6,-4(fp)
    2ce4:	0015d280 	call	15d28 <udp_recv>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
    2ce8:	e13fff17 	ldw	r4,-4(fp)
    2cec:	00031900 	call	3190 <dhcp_discover>
    2cf0:	e0bffe05 	stb	r2,-8(fp)
  if (result != ERR_OK) {
    2cf4:	e0bffe07 	ldb	r2,-8(fp)
    2cf8:	10000426 	beq	r2,zero,2d0c <dhcp_start+0x218>
    /* free resources allocated above */
    dhcp_stop(netif);
    2cfc:	e13fff17 	ldw	r4,-4(fp)
    2d00:	0003b9c0 	call	3b9c <dhcp_stop>
    return ERR_MEM;
    2d04:	00bfffc4 	movi	r2,-1
    2d08:	00000706 	br	2d28 <dhcp_start+0x234>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
    2d0c:	e0bfff17 	ldw	r2,-4(fp)
    2d10:	10800b43 	ldbu	r2,45(r2)
    2d14:	10800214 	ori	r2,r2,8
    2d18:	1007883a 	mov	r3,r2
    2d1c:	e0bfff17 	ldw	r2,-4(fp)
    2d20:	10c00b45 	stb	r3,45(r2)
  return result;
    2d24:	e0bffe03 	ldbu	r2,-8(fp)
}
    2d28:	e037883a 	mov	sp,fp
    2d2c:	dfc00117 	ldw	ra,4(sp)
    2d30:	df000017 	ldw	fp,0(sp)
    2d34:	dec00204 	addi	sp,sp,8
    2d38:	f800283a 	ret

00002d3c <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
    2d3c:	deffeb04 	addi	sp,sp,-84
    2d40:	dfc01415 	stw	ra,80(sp)
    2d44:	df001315 	stw	fp,76(sp)
    2d48:	df001304 	addi	fp,sp,76
    2d4c:	e13fff15 	stw	r4,-4(fp)
  struct dhcp dhcp;
  err_t result = ERR_OK;
    2d50:	e03fef05 	stb	zero,-68(fp)
  struct udp_pcb *pcb;

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
    2d54:	e0bfff17 	ldw	r2,-4(fp)
    2d58:	1000091e 	bne	r2,zero,2d80 <dhcp_inform+0x44>
    2d5c:	010000f4 	movhi	r4,3
    2d60:	213ccf04 	addi	r4,r4,-3268
    2d64:	014000f4 	movhi	r5,3
    2d68:	297cd904 	addi	r5,r5,-3228
    2d6c:	0180b384 	movi	r6,718
    2d70:	01c000f4 	movhi	r7,3
    2d74:	39fcdd04 	addi	r7,r7,-3212
    2d78:	00193f00 	call	193f0 <printf>
    2d7c:	003fff06 	br	2d7c <dhcp_inform+0x40>

  memset(&dhcp, 0, sizeof(struct dhcp));
    2d80:	e0bff004 	addi	r2,fp,-64
    2d84:	1009883a 	mov	r4,r2
    2d88:	000b883a 	mov	r5,zero
    2d8c:	01800f04 	movi	r6,60
    2d90:	00192e80 	call	192e8 <memset>
  dhcp_set_state(&dhcp, DHCP_INFORM);
    2d94:	e0bff004 	addi	r2,fp,-64
    2d98:	1009883a 	mov	r4,r2
    2d9c:	01400204 	movi	r5,8
    2da0:	0003c800 	call	3c80 <dhcp_set_state>

  if ((netif->dhcp != NULL) && (netif->dhcp->pcb != NULL)) {
    2da4:	e0bfff17 	ldw	r2,-4(fp)
    2da8:	10800817 	ldw	r2,32(r2)
    2dac:	10000926 	beq	r2,zero,2dd4 <dhcp_inform+0x98>
    2db0:	e0bfff17 	ldw	r2,-4(fp)
    2db4:	10800817 	ldw	r2,32(r2)
    2db8:	10800117 	ldw	r2,4(r2)
    2dbc:	10000526 	beq	r2,zero,2dd4 <dhcp_inform+0x98>
    /* re-use existing pcb */
    pcb = netif->dhcp->pcb;
    2dc0:	e0bfff17 	ldw	r2,-4(fp)
    2dc4:	10800817 	ldw	r2,32(r2)
    2dc8:	10800117 	ldw	r2,4(r2)
    2dcc:	e0bfee15 	stw	r2,-72(fp)
    2dd0:	00001106 	br	2e18 <dhcp_inform+0xdc>
  } else {
    pcb = udp_new();
    2dd4:	0015e040 	call	15e04 <udp_new>
    2dd8:	e0bfee15 	stw	r2,-72(fp)
    if (pcb == NULL) {
    2ddc:	e0bfee17 	ldw	r2,-72(fp)
    2de0:	10003c26 	beq	r2,zero,2ed4 <dhcp_inform+0x198>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform(): could not obtain pcb"));
      return;
    }
    dhcp.pcb = pcb;
    2de4:	e0bfee17 	ldw	r2,-72(fp)
    2de8:	e0bff115 	stw	r2,-60(fp)
    ip_set_option(dhcp.pcb, SOF_BROADCAST);
    2dec:	e0bff117 	ldw	r2,-60(fp)
    2df0:	e0fff117 	ldw	r3,-60(fp)
    2df4:	18c00203 	ldbu	r3,8(r3)
    2df8:	18c00814 	ori	r3,r3,32
    2dfc:	10c00205 	stb	r3,8(r2)
    udp_bind(dhcp.pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
    2e00:	e0bff117 	ldw	r2,-60(fp)
    2e04:	1009883a 	mov	r4,r2
    2e08:	014000f4 	movhi	r5,3
    2e0c:	29557404 	addi	r5,r5,21968
    2e10:	01801104 	movi	r6,68
    2e14:	0015a740 	call	15a74 <udp_bind>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  }
  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, &dhcp, DHCP_INFORM);
    2e18:	e0bff004 	addi	r2,fp,-64
    2e1c:	e13fff17 	ldw	r4,-4(fp)
    2e20:	100b883a 	mov	r5,r2
    2e24:	01800204 	movi	r6,8
    2e28:	0004cac0 	call	4cac <dhcp_create_msg>
    2e2c:	e0bfef05 	stb	r2,-68(fp)
  if (result == ERR_OK) {
    2e30:	e0bfef07 	ldb	r2,-68(fp)
    2e34:	1000221e 	bne	r2,zero,2ec0 <dhcp_inform+0x184>
    dhcp_option(&dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    2e38:	e0bff004 	addi	r2,fp,-64
    2e3c:	1009883a 	mov	r4,r2
    2e40:	01400e44 	movi	r5,57
    2e44:	01800084 	movi	r6,2
    2e48:	0003cd80 	call	3cd8 <dhcp_option>
    dhcp_option_short(&dhcp, DHCP_MAX_MSG_LEN(netif));
    2e4c:	e0bfff17 	ldw	r2,-4(fp)
    2e50:	1080090b 	ldhu	r2,36(r2)
    2e54:	10bfffcc 	andi	r2,r2,65535
    2e58:	e0fff004 	addi	r3,fp,-64
    2e5c:	1809883a 	mov	r4,r3
    2e60:	100b883a 	mov	r5,r2
    2e64:	0003e580 	call	3e58 <dhcp_option_short>

    dhcp_option_trailer(&dhcp);
    2e68:	e0bff004 	addi	r2,fp,-64
    2e6c:	1009883a 	mov	r4,r2
    2e70:	00052600 	call	5260 <dhcp_option_trailer>

    pbuf_realloc(dhcp.p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp.options_out_len);
    2e74:	e0fff417 	ldw	r3,-48(fp)
    2e78:	e0bff60b 	ldhu	r2,-40(fp)
    2e7c:	10803c04 	addi	r2,r2,240
    2e80:	10bfffcc 	andi	r2,r2,65535
    2e84:	1809883a 	mov	r4,r3
    2e88:	100b883a 	mov	r5,r2
    2e8c:	000a5b80 	call	a5b8 <pbuf_realloc>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(pcb, dhcp.p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    2e90:	e0bff417 	ldw	r2,-48(fp)
    2e94:	e0ffff17 	ldw	r3,-4(fp)
    2e98:	d8c00015 	stw	r3,0(sp)
    2e9c:	e13fee17 	ldw	r4,-72(fp)
    2ea0:	100b883a 	mov	r5,r2
    2ea4:	018000f4 	movhi	r6,3
    2ea8:	31957504 	addi	r6,r6,21972
    2eac:	01c010c4 	movi	r7,67
    2eb0:	00157880 	call	15788 <udp_sendto_if>
    dhcp_delete_msg(&dhcp);
    2eb4:	e0bff004 	addi	r2,fp,-64
    2eb8:	1009883a 	mov	r4,r2
    2ebc:	00051800 	call	5180 <dhcp_delete_msg>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp.pcb != NULL) {
    2ec0:	e0bff117 	ldw	r2,-60(fp)
    2ec4:	10000326 	beq	r2,zero,2ed4 <dhcp_inform+0x198>
    /* otherwise, the existing pcb was used */
    udp_remove(dhcp.pcb);
    2ec8:	e0bff117 	ldw	r2,-60(fp)
    2ecc:	1009883a 	mov	r4,r2
    2ed0:	0015d680 	call	15d68 <udp_remove>
  }
}
    2ed4:	e037883a 	mov	sp,fp
    2ed8:	dfc00117 	ldw	ra,4(sp)
    2edc:	df000017 	ldw	fp,0(sp)
    2ee0:	dec00204 	addi	sp,sp,8
    2ee4:	f800283a 	ret

00002ee8 <dhcp_network_changed>:
 * This enters the REBOOTING state to verify that the currently bound
 * address is still valid.
 */
void
dhcp_network_changed(struct netif *netif)
{
    2ee8:	defffc04 	addi	sp,sp,-16
    2eec:	dfc00315 	stw	ra,12(sp)
    2ef0:	df000215 	stw	fp,8(sp)
    2ef4:	df000204 	addi	fp,sp,8
    2ef8:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    2efc:	e0bfff17 	ldw	r2,-4(fp)
    2f00:	10800817 	ldw	r2,32(r2)
    2f04:	e0bffe15 	stw	r2,-8(fp)
  if (!dhcp)
    2f08:	e0bffe17 	ldw	r2,-8(fp)
    2f0c:	10001826 	beq	r2,zero,2f70 <dhcp_network_changed+0x88>
    return;
  switch (dhcp->state) {
    2f10:	e0bffe17 	ldw	r2,-8(fp)
    2f14:	10800303 	ldbu	r2,12(r2)
    2f18:	10803fcc 	andi	r2,r2,255
    2f1c:	10c00188 	cmpgei	r3,r2,6
    2f20:	1800041e 	bne	r3,zero,2f34 <dhcp_network_changed+0x4c>
    2f24:	10c000c8 	cmpgei	r3,r2,3
    2f28:	1800041e 	bne	r3,zero,2f3c <dhcp_network_changed+0x54>
    2f2c:	10001226 	beq	r2,zero,2f78 <dhcp_network_changed+0x90>
    2f30:	00000906 	br	2f58 <dhcp_network_changed+0x70>
    2f34:	108002a0 	cmpeqi	r2,r2,10
    2f38:	10000726 	beq	r2,zero,2f58 <dhcp_network_changed+0x70>
  case DHCP_REBINDING:
  case DHCP_RENEWING:
  case DHCP_BOUND:
  case DHCP_REBOOTING:
    netif_set_down(netif);
    2f3c:	e13fff17 	ldw	r4,-4(fp)
    2f40:	0009e700 	call	9e70 <netif_set_down>
    dhcp->tries = 0;
    2f44:	e0bffe17 	ldw	r2,-8(fp)
    2f48:	10000345 	stb	zero,13(r2)
    dhcp_reboot(netif);
    2f4c:	e13fff17 	ldw	r4,-4(fp)
    2f50:	00038500 	call	3850 <dhcp_reboot>
    break;
    2f54:	00000906 	br	2f7c <dhcp_network_changed+0x94>
  case DHCP_OFF:
    /* stay off */
    break;
  default:
    dhcp->tries = 0;
    2f58:	e0bffe17 	ldw	r2,-8(fp)
    2f5c:	10000345 	stb	zero,13(r2)
    if(dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_ON) {
      autoip_stop(netif);
      dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
    }
#endif /* LWIP_DHCP_AUTOIP_COOP */
    dhcp_discover(netif);
    2f60:	e13fff17 	ldw	r4,-4(fp)
    2f64:	00031900 	call	3190 <dhcp_discover>
    break;
    2f68:	0001883a 	nop
    2f6c:	00000306 	br	2f7c <dhcp_network_changed+0x94>
void
dhcp_network_changed(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  if (!dhcp)
    return;
    2f70:	0001883a 	nop
    2f74:	00000106 	br	2f7c <dhcp_network_changed+0x94>
    dhcp->tries = 0;
    dhcp_reboot(netif);
    break;
  case DHCP_OFF:
    /* stay off */
    break;
    2f78:	0001883a 	nop
    }
#endif /* LWIP_DHCP_AUTOIP_COOP */
    dhcp_discover(netif);
    break;
  }
}
    2f7c:	e037883a 	mov	sp,fp
    2f80:	dfc00117 	ldw	ra,4(sp)
    2f84:	df000017 	ldw	fp,0(sp)
    2f88:	dec00204 	addi	sp,sp,8
    2f8c:	f800283a 	ret

00002f90 <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, ip_addr_t *addr)
{
    2f90:	defffc04 	addi	sp,sp,-16
    2f94:	dfc00315 	stw	ra,12(sp)
    2f98:	df000215 	stw	fp,8(sp)
    2f9c:	df000204 	addi	fp,sp,8
    2fa0:	e13ffe15 	stw	r4,-8(fp)
    2fa4:	e17fff15 	stw	r5,-4(fp)
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
    2fa8:	e0bffe17 	ldw	r2,-8(fp)
    2fac:	1000091e 	bne	r2,zero,2fd4 <dhcp_arp_reply+0x44>
    2fb0:	010000f4 	movhi	r4,3
    2fb4:	213ccf04 	addi	r4,r4,-3268
    2fb8:	014000f4 	movhi	r5,3
    2fbc:	297cd904 	addi	r5,r5,-3228
    2fc0:	0180c944 	movi	r6,805
    2fc4:	01c000f4 	movhi	r7,3
    2fc8:	39fcdd04 	addi	r7,r7,-3212
    2fcc:	00193f00 	call	193f0 <printf>
    2fd0:	003fff06 	br	2fd0 <dhcp_arp_reply+0x40>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
    2fd4:	e0bffe17 	ldw	r2,-8(fp)
    2fd8:	10800817 	ldw	r2,32(r2)
    2fdc:	10000e26 	beq	r2,zero,3018 <dhcp_arp_reply+0x88>
    2fe0:	e0bffe17 	ldw	r2,-8(fp)
    2fe4:	10800817 	ldw	r2,32(r2)
    2fe8:	10800303 	ldbu	r2,12(r2)
    2fec:	10803fcc 	andi	r2,r2,255
    2ff0:	10800218 	cmpnei	r2,r2,8
    2ff4:	1000081e 	bne	r2,zero,3018 <dhcp_arp_reply+0x88>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n",
      ip4_addr_get_u32(addr)));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
    2ff8:	e0bfff17 	ldw	r2,-4(fp)
    2ffc:	10c00017 	ldw	r3,0(r2)
    3000:	e0bffe17 	ldw	r2,-8(fp)
    3004:	10800817 	ldw	r2,32(r2)
    3008:	10800917 	ldw	r2,36(r2)
    300c:	1880021e 	bne	r3,r2,3018 <dhcp_arp_reply+0x88>
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
        ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
    3010:	e13ffe17 	ldw	r4,-8(fp)
    3014:	000302c0 	call	302c <dhcp_decline>
    }
  }
}
    3018:	e037883a 	mov	sp,fp
    301c:	dfc00117 	ldw	ra,4(sp)
    3020:	df000017 	ldw	fp,0(sp)
    3024:	dec00204 	addi	sp,sp,8
    3028:	f800283a 	ret

0000302c <dhcp_decline>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_decline(struct netif *netif)
{
    302c:	defffa04 	addi	sp,sp,-24
    3030:	dfc00515 	stw	ra,20(sp)
    3034:	df000415 	stw	fp,16(sp)
    3038:	df000404 	addi	fp,sp,16
    303c:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    3040:	e0bfff17 	ldw	r2,-4(fp)
    3044:	10800817 	ldw	r2,32(r2)
    3048:	e0bffd15 	stw	r2,-12(fp)
  err_t result = ERR_OK;
    304c:	e03ffe05 	stb	zero,-8(fp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
    3050:	e13ffd17 	ldw	r4,-12(fp)
    3054:	01400304 	movi	r5,12
    3058:	0003c800 	call	3c80 <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_DECLINE);
    305c:	e13fff17 	ldw	r4,-4(fp)
    3060:	e17ffd17 	ldw	r5,-12(fp)
    3064:	01800104 	movi	r6,4
    3068:	0004cac0 	call	4cac <dhcp_create_msg>
    306c:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
    3070:	e0bffe07 	ldb	r2,-8(fp)
    3074:	1000311e 	bne	r2,zero,313c <dhcp_decline+0x110>
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    3078:	e13ffd17 	ldw	r4,-12(fp)
    307c:	01400c84 	movi	r5,50
    3080:	01800104 	movi	r6,4
    3084:	0003cd80 	call	3cd8 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
    3088:	e0bffd17 	ldw	r2,-12(fp)
    308c:	10800917 	ldw	r2,36(r2)
    3090:	1006d63a 	srli	r3,r2,24
    3094:	e0bffd17 	ldw	r2,-12(fp)
    3098:	10800917 	ldw	r2,36(r2)
    309c:	1004d23a 	srli	r2,r2,8
    30a0:	10bfc00c 	andi	r2,r2,65280
    30a4:	1886b03a 	or	r3,r3,r2
    30a8:	e0bffd17 	ldw	r2,-12(fp)
    30ac:	10800917 	ldw	r2,36(r2)
    30b0:	10bfc00c 	andi	r2,r2,65280
    30b4:	1004923a 	slli	r2,r2,8
    30b8:	1886b03a 	or	r3,r3,r2
    30bc:	e0bffd17 	ldw	r2,-12(fp)
    30c0:	10800917 	ldw	r2,36(r2)
    30c4:	1004963a 	slli	r2,r2,24
    30c8:	1884b03a 	or	r2,r3,r2
    30cc:	e13ffd17 	ldw	r4,-12(fp)
    30d0:	100b883a 	mov	r5,r2
    30d4:	0003f300 	call	3f30 <dhcp_option_long>

    dhcp_option_trailer(dhcp);
    30d8:	e13ffd17 	ldw	r4,-12(fp)
    30dc:	00052600 	call	5260 <dhcp_option_trailer>
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    30e0:	e0bffd17 	ldw	r2,-12(fp)
    30e4:	10c00417 	ldw	r3,16(r2)
    30e8:	e0bffd17 	ldw	r2,-12(fp)
    30ec:	1080060b 	ldhu	r2,24(r2)
    30f0:	10803c04 	addi	r2,r2,240
    30f4:	10bfffcc 	andi	r2,r2,65535
    30f8:	1809883a 	mov	r4,r3
    30fc:	100b883a 	mov	r5,r2
    3100:	000a5b80 	call	a5b8 <pbuf_realloc>

    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    3104:	e0bffd17 	ldw	r2,-12(fp)
    3108:	10c00117 	ldw	r3,4(r2)
    310c:	e0bffd17 	ldw	r2,-12(fp)
    3110:	10800417 	ldw	r2,16(r2)
    3114:	e13fff17 	ldw	r4,-4(fp)
    3118:	d9000015 	stw	r4,0(sp)
    311c:	1809883a 	mov	r4,r3
    3120:	100b883a 	mov	r5,r2
    3124:	018000f4 	movhi	r6,3
    3128:	31957504 	addi	r6,r6,21972
    312c:	01c010c4 	movi	r7,67
    3130:	00157880 	call	15788 <udp_sendto_if>
    dhcp_delete_msg(dhcp);
    3134:	e13ffd17 	ldw	r4,-12(fp)
    3138:	00051800 	call	5180 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    313c:	e0bffd17 	ldw	r2,-12(fp)
    3140:	10800343 	ldbu	r2,13(r2)
    3144:	10800044 	addi	r2,r2,1
    3148:	1007883a 	mov	r3,r2
    314c:	e0bffd17 	ldw	r2,-12(fp)
    3150:	10c00345 	stb	r3,13(r2)
  msecs = 10*1000;
    3154:	0089c404 	movi	r2,10000
    3158:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    315c:	e0bffe8b 	ldhu	r2,-6(fp)
    3160:	10c07cc4 	addi	r3,r2,499
    3164:	00807d04 	movi	r2,500
    3168:	1885283a 	div	r2,r3,r2
    316c:	1007883a 	mov	r3,r2
    3170:	e0bffd17 	ldw	r2,-12(fp)
    3174:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
    3178:	e0bffe03 	ldbu	r2,-8(fp)
}
    317c:	e037883a 	mov	sp,fp
    3180:	dfc00117 	ldw	ra,4(sp)
    3184:	df000017 	ldw	fp,0(sp)
    3188:	dec00204 	addi	sp,sp,8
    318c:	f800283a 	ret

00003190 <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
    3190:	defffa04 	addi	sp,sp,-24
    3194:	dfc00515 	stw	ra,20(sp)
    3198:	df000415 	stw	fp,16(sp)
    319c:	df000404 	addi	fp,sp,16
    31a0:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    31a4:	e0bfff17 	ldw	r2,-4(fp)
    31a8:	10800817 	ldw	r2,32(r2)
    31ac:	e0bffd15 	stw	r2,-12(fp)
  err_t result = ERR_OK;
    31b0:	e03ffe05 	stb	zero,-8(fp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover()\n"));
  ip_addr_set_any(&dhcp->offered_ip_addr);
    31b4:	e0bffd17 	ldw	r2,-12(fp)
    31b8:	10000915 	stw	zero,36(r2)
  dhcp_set_state(dhcp, DHCP_SELECTING);
    31bc:	e13ffd17 	ldw	r4,-12(fp)
    31c0:	01400184 	movi	r5,6
    31c4:	0003c800 	call	3c80 <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_DISCOVER);
    31c8:	e13fff17 	ldw	r4,-4(fp)
    31cc:	e17ffd17 	ldw	r5,-12(fp)
    31d0:	01800044 	movi	r6,1
    31d4:	0004cac0 	call	4cac <dhcp_create_msg>
    31d8:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
    31dc:	e0bffe07 	ldb	r2,-8(fp)
    31e0:	1000331e 	bne	r2,zero,32b0 <dhcp_discover+0x120>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    31e4:	e13ffd17 	ldw	r4,-12(fp)
    31e8:	01400e44 	movi	r5,57
    31ec:	01800084 	movi	r6,2
    31f0:	0003cd80 	call	3cd8 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    31f4:	e0bfff17 	ldw	r2,-4(fp)
    31f8:	1080090b 	ldhu	r2,36(r2)
    31fc:	10bfffcc 	andi	r2,r2,65535
    3200:	e13ffd17 	ldw	r4,-12(fp)
    3204:	100b883a 	mov	r5,r2
    3208:	0003e580 	call	3e58 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
    320c:	e13ffd17 	ldw	r4,-12(fp)
    3210:	01400dc4 	movi	r5,55
    3214:	01800104 	movi	r6,4
    3218:	0003cd80 	call	3cd8 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
    321c:	e13ffd17 	ldw	r4,-12(fp)
    3220:	01400044 	movi	r5,1
    3224:	0003dbc0 	call	3dbc <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
    3228:	e13ffd17 	ldw	r4,-12(fp)
    322c:	014000c4 	movi	r5,3
    3230:	0003dbc0 	call	3dbc <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
    3234:	e13ffd17 	ldw	r4,-12(fp)
    3238:	01400704 	movi	r5,28
    323c:	0003dbc0 	call	3dbc <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
    3240:	e13ffd17 	ldw	r4,-12(fp)
    3244:	01400184 	movi	r5,6
    3248:	0003dbc0 	call	3dbc <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
    324c:	e13ffd17 	ldw	r4,-12(fp)
    3250:	00052600 	call	5260 <dhcp_option_trailer>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    3254:	e0bffd17 	ldw	r2,-12(fp)
    3258:	10c00417 	ldw	r3,16(r2)
    325c:	e0bffd17 	ldw	r2,-12(fp)
    3260:	1080060b 	ldhu	r2,24(r2)
    3264:	10803c04 	addi	r2,r2,240
    3268:	10bfffcc 	andi	r2,r2,65535
    326c:	1809883a 	mov	r4,r3
    3270:	100b883a 	mov	r5,r2
    3274:	000a5b80 	call	a5b8 <pbuf_realloc>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    3278:	e0bffd17 	ldw	r2,-12(fp)
    327c:	10c00117 	ldw	r3,4(r2)
    3280:	e0bffd17 	ldw	r2,-12(fp)
    3284:	10800417 	ldw	r2,16(r2)
    3288:	e13fff17 	ldw	r4,-4(fp)
    328c:	d9000015 	stw	r4,0(sp)
    3290:	1809883a 	mov	r4,r3
    3294:	100b883a 	mov	r5,r2
    3298:	018000f4 	movhi	r6,3
    329c:	31957504 	addi	r6,r6,21972
    32a0:	01c010c4 	movi	r7,67
    32a4:	00157880 	call	15788 <udp_sendto_if>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_msg(dhcp);
    32a8:	e13ffd17 	ldw	r4,-12(fp)
    32ac:	00051800 	call	5180 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    32b0:	e0bffd17 	ldw	r2,-12(fp)
    32b4:	10800343 	ldbu	r2,13(r2)
    32b8:	10800044 	addi	r2,r2,1
    32bc:	1007883a 	mov	r3,r2
    32c0:	e0bffd17 	ldw	r2,-12(fp)
    32c4:	10c00345 	stb	r3,13(r2)
  if(dhcp->tries >= LWIP_DHCP_AUTOIP_COOP_TRIES && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
    32c8:	e0bffd17 	ldw	r2,-12(fp)
    32cc:	10800343 	ldbu	r2,13(r2)
    32d0:	10803fcc 	andi	r2,r2,255
    32d4:	108001a8 	cmpgeui	r2,r2,6
    32d8:	1000061e 	bne	r2,zero,32f4 <dhcp_discover+0x164>
    32dc:	e0bffd17 	ldw	r2,-12(fp)
    32e0:	10800343 	ldbu	r2,13(r2)
    32e4:	10803fcc 	andi	r2,r2,255
    32e8:	00c0fa04 	movi	r3,1000
    32ec:	1884983a 	sll	r2,r3,r2
    32f0:	00000106 	br	32f8 <dhcp_discover+0x168>
    32f4:	00ba9804 	movi	r2,-5536
    32f8:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    32fc:	e0bffe8b 	ldhu	r2,-6(fp)
    3300:	10c07cc4 	addi	r3,r2,499
    3304:	00807d04 	movi	r2,500
    3308:	1885283a 	div	r2,r3,r2
    330c:	1007883a 	mov	r3,r2
    3310:	e0bffd17 	ldw	r2,-12(fp)
    3314:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
    3318:	e0bffe03 	ldbu	r2,-8(fp)
}
    331c:	e037883a 	mov	sp,fp
    3320:	dfc00117 	ldw	ra,4(sp)
    3324:	df000017 	ldw	fp,0(sp)
    3328:	dec00204 	addi	sp,sp,8
    332c:	f800283a 	ret

00003330 <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
    3330:	defff804 	addi	sp,sp,-32
    3334:	dfc00715 	stw	ra,28(sp)
    3338:	df000615 	stw	fp,24(sp)
    333c:	df000604 	addi	fp,sp,24
    3340:	e13fff15 	stw	r4,-4(fp)
  u32_t timeout;
  struct dhcp *dhcp;
  ip_addr_t sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
    3344:	e0bfff17 	ldw	r2,-4(fp)
    3348:	1000091e 	bne	r2,zero,3370 <dhcp_bind+0x40>
    334c:	010000f4 	movhi	r4,3
    3350:	213ccf04 	addi	r4,r4,-3268
    3354:	014000f4 	movhi	r5,3
    3358:	297cfb04 	addi	r5,r5,-3092
    335c:	0180e904 	movi	r6,932
    3360:	01c000f4 	movhi	r7,3
    3364:	39fcdd04 	addi	r7,r7,-3212
    3368:	00193f00 	call	193f0 <printf>
    336c:	003fff06 	br	336c <dhcp_bind+0x3c>
  dhcp = netif->dhcp;
    3370:	e0bfff17 	ldw	r2,-4(fp)
    3374:	10800817 	ldw	r2,32(r2)
    3378:	e0bffb15 	stw	r2,-20(fp)
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
    337c:	e0bffb17 	ldw	r2,-20(fp)
    3380:	1000091e 	bne	r2,zero,33a8 <dhcp_bind+0x78>
    3384:	010000f4 	movhi	r4,3
    3388:	213ccf04 	addi	r4,r4,-3268
    338c:	014000f4 	movhi	r5,3
    3390:	297d0204 	addi	r5,r5,-3064
    3394:	0180e984 	movi	r6,934
    3398:	01c000f4 	movhi	r7,3
    339c:	39fcdd04 	addi	r7,r7,-3212
    33a0:	00193f00 	call	193f0 <printf>
    33a4:	003fff06 	br	33a4 <dhcp_bind+0x74>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
    33a8:	e0bffb17 	ldw	r2,-20(fp)
    33ac:	10800d17 	ldw	r2,52(r2)
    33b0:	10bfffe0 	cmpeqi	r2,r2,-1
    33b4:	1000161e 	bne	r2,zero,3410 <dhcp_bind+0xe0>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
    33b8:	e0bffb17 	ldw	r2,-20(fp)
    33bc:	10800d17 	ldw	r2,52(r2)
    33c0:	10c00784 	addi	r3,r2,30
    33c4:	00800f04 	movi	r2,60
    33c8:	1885203a 	divu	r2,r3,r2
    33cc:	e0bffa15 	stw	r2,-24(fp)
    if(timeout > 0xffff) {
    33d0:	e0bffa17 	ldw	r2,-24(fp)
    33d4:	00ffffd4 	movui	r3,65535
    33d8:	1880022e 	bgeu	r3,r2,33e4 <dhcp_bind+0xb4>
      timeout = 0xffff;
    33dc:	00bfffd4 	movui	r2,65535
    33e0:	e0bffa15 	stw	r2,-24(fp)
    }
    dhcp->t1_timeout = (u16_t)timeout;
    33e4:	e0bffa17 	ldw	r2,-24(fp)
    33e8:	1007883a 	mov	r3,r2
    33ec:	e0bffb17 	ldw	r2,-20(fp)
    33f0:	10c0070d 	sth	r3,28(r2)
    if (dhcp->t1_timeout == 0) {
    33f4:	e0bffb17 	ldw	r2,-20(fp)
    33f8:	1080070b 	ldhu	r2,28(r2)
    33fc:	10bfffcc 	andi	r2,r2,65535
    3400:	1000031e 	bne	r2,zero,3410 <dhcp_bind+0xe0>
      dhcp->t1_timeout = 1;
    3404:	e0bffb17 	ldw	r2,-20(fp)
    3408:	00c00044 	movi	r3,1
    340c:	10c0070d 	sth	r3,28(r2)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
    3410:	e0bffb17 	ldw	r2,-20(fp)
    3414:	10800e17 	ldw	r2,56(r2)
    3418:	10bfffe0 	cmpeqi	r2,r2,-1
    341c:	1000161e 	bne	r2,zero,3478 <dhcp_bind+0x148>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
    3420:	e0bffb17 	ldw	r2,-20(fp)
    3424:	10800e17 	ldw	r2,56(r2)
    3428:	10c00784 	addi	r3,r2,30
    342c:	00800f04 	movi	r2,60
    3430:	1885203a 	divu	r2,r3,r2
    3434:	e0bffa15 	stw	r2,-24(fp)
    if(timeout > 0xffff) {
    3438:	e0bffa17 	ldw	r2,-24(fp)
    343c:	00ffffd4 	movui	r3,65535
    3440:	1880022e 	bgeu	r3,r2,344c <dhcp_bind+0x11c>
      timeout = 0xffff;
    3444:	00bfffd4 	movui	r2,65535
    3448:	e0bffa15 	stw	r2,-24(fp)
    }
    dhcp->t2_timeout = (u16_t)timeout;
    344c:	e0bffa17 	ldw	r2,-24(fp)
    3450:	1007883a 	mov	r3,r2
    3454:	e0bffb17 	ldw	r2,-20(fp)
    3458:	10c0078d 	sth	r3,30(r2)
    if (dhcp->t2_timeout == 0) {
    345c:	e0bffb17 	ldw	r2,-20(fp)
    3460:	1080078b 	ldhu	r2,30(r2)
    3464:	10bfffcc 	andi	r2,r2,65535
    3468:	1000031e 	bne	r2,zero,3478 <dhcp_bind+0x148>
      dhcp->t2_timeout = 1;
    346c:	e0bffb17 	ldw	r2,-20(fp)
    3470:	00c00044 	movi	r3,1
    3474:	10c0078d 	sth	r3,30(r2)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }

  /* If we have sub 1 minute lease, t2 and t1 will kick in at the same time. */
  if ((dhcp->t1_timeout >= dhcp->t2_timeout) && (dhcp->t2_timeout > 0)) {
    3478:	e0bffb17 	ldw	r2,-20(fp)
    347c:	10c0070b 	ldhu	r3,28(r2)
    3480:	e0bffb17 	ldw	r2,-20(fp)
    3484:	1080078b 	ldhu	r2,30(r2)
    3488:	18ffffcc 	andi	r3,r3,65535
    348c:	10bfffcc 	andi	r2,r2,65535
    3490:	18800636 	bltu	r3,r2,34ac <dhcp_bind+0x17c>
    3494:	e0bffb17 	ldw	r2,-20(fp)
    3498:	1080078b 	ldhu	r2,30(r2)
    349c:	10bfffcc 	andi	r2,r2,65535
    34a0:	10000226 	beq	r2,zero,34ac <dhcp_bind+0x17c>
    dhcp->t1_timeout = 0;
    34a4:	e0bffb17 	ldw	r2,-20(fp)
    34a8:	1000070d 	sth	zero,28(r2)
  }

  if (dhcp->subnet_mask_given) {
    34ac:	e0bffb17 	ldw	r2,-20(fp)
    34b0:	10800383 	ldbu	r2,14(r2)
    34b4:	10803fcc 	andi	r2,r2,255
    34b8:	10000426 	beq	r2,zero,34cc <dhcp_bind+0x19c>
    /* copy offered network mask */
    ip_addr_copy(sn_mask, dhcp->offered_sn_mask);
    34bc:	e0bffb17 	ldw	r2,-20(fp)
    34c0:	10800a17 	ldw	r2,40(r2)
    34c4:	e0bffd15 	stw	r2,-12(fp)
    34c8:	00001506 	br	3520 <dhcp_bind+0x1f0>
  } else {
    /* subnet mask not given, choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&dhcp->offered_ip_addr);
    34cc:	e0bffb17 	ldw	r2,-20(fp)
    34d0:	10800904 	addi	r2,r2,36
    34d4:	10800003 	ldbu	r2,0(r2)
    34d8:	e0bffc05 	stb	r2,-16(fp)
    if (first_octet <= 127) {
    34dc:	e0bffc03 	ldbu	r2,-16(fp)
    34e0:	10803fcc 	andi	r2,r2,255
    34e4:	1080201c 	xori	r2,r2,128
    34e8:	10bfe004 	addi	r2,r2,-128
    34ec:	10000316 	blt	r2,zero,34fc <dhcp_bind+0x1cc>
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xff000000UL));
    34f0:	00803fc4 	movi	r2,255
    34f4:	e0bffd15 	stw	r2,-12(fp)
    34f8:	00000906 	br	3520 <dhcp_bind+0x1f0>
    } else if (first_octet >= 192) {
    34fc:	e0bffc03 	ldbu	r2,-16(fp)
    3500:	10803030 	cmpltui	r2,r2,192
    3504:	1000041e 	bne	r2,zero,3518 <dhcp_bind+0x1e8>
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffffff00UL));
    3508:	00804034 	movhi	r2,256
    350c:	10bfffc4 	addi	r2,r2,-1
    3510:	e0bffd15 	stw	r2,-12(fp)
    3514:	00000206 	br	3520 <dhcp_bind+0x1f0>
    } else {
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffff0000UL));
    3518:	00bfffd4 	movui	r2,65535
    351c:	e0bffd15 	stw	r2,-12(fp)
    }
  }

  ip_addr_copy(gw_addr, dhcp->offered_gw_addr);
    3520:	e0bffb17 	ldw	r2,-20(fp)
    3524:	10800b17 	ldw	r2,44(r2)
    3528:	e0bffe15 	stw	r2,-8(fp)
  /* gateway address not given? */
  if (ip_addr_isany(&gw_addr)) {
    352c:	e0bffe17 	ldw	r2,-8(fp)
    3530:	1000081e 	bne	r2,zero,3554 <dhcp_bind+0x224>
    /* copy network address */
    ip_addr_get_network(&gw_addr, &dhcp->offered_ip_addr, &sn_mask);
    3534:	e0bffb17 	ldw	r2,-20(fp)
    3538:	10c00917 	ldw	r3,36(r2)
    353c:	e0bffd17 	ldw	r2,-12(fp)
    3540:	1884703a 	and	r2,r3,r2
    3544:	e0bffe15 	stw	r2,-8(fp)
    /* use first host address on network as gateway */
    ip4_addr_set_u32(&gw_addr, ip4_addr_get_u32(&gw_addr) | PP_HTONL(0x00000001UL));
    3548:	e0bffe17 	ldw	r2,-8(fp)
    354c:	10804034 	orhi	r2,r2,256
    3550:	e0bffe15 	stw	r2,-8(fp)
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n",
    ip4_addr_get_u32(&dhcp->offered_ip_addr)));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
    3554:	e0bffb17 	ldw	r2,-20(fp)
    3558:	10800904 	addi	r2,r2,36
    355c:	e13fff17 	ldw	r4,-4(fp)
    3560:	100b883a 	mov	r5,r2
    3564:	0009bfc0 	call	9bfc <netif_set_ipaddr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n",
    ip4_addr_get_u32(&sn_mask)));
  netif_set_netmask(netif, &sn_mask);
    3568:	e0bffd04 	addi	r2,fp,-12
    356c:	e13fff17 	ldw	r4,-4(fp)
    3570:	100b883a 	mov	r5,r2
    3574:	0009d740 	call	9d74 <netif_set_netmask>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n",
    ip4_addr_get_u32(&gw_addr)));
  netif_set_gw(netif, &gw_addr);
    3578:	e0bffe04 	addi	r2,fp,-8
    357c:	e13fff17 	ldw	r4,-4(fp)
    3580:	100b883a 	mov	r5,r2
    3584:	0009d300 	call	9d30 <netif_set_gw>
  /* bring the interface up */
  netif_set_up(netif);
    3588:	e13fff17 	ldw	r4,-4(fp)
    358c:	0009de00 	call	9de0 <netif_set_up>
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
    3590:	e13ffb17 	ldw	r4,-20(fp)
    3594:	01400284 	movi	r5,10
    3598:	0003c800 	call	3c80 <dhcp_set_state>
}
    359c:	e037883a 	mov	sp,fp
    35a0:	dfc00117 	ldw	ra,4(sp)
    35a4:	df000017 	ldw	fp,0(sp)
    35a8:	dec00204 	addi	sp,sp,8
    35ac:	f800283a 	ret

000035b0 <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
    35b0:	defffa04 	addi	sp,sp,-24
    35b4:	dfc00515 	stw	ra,20(sp)
    35b8:	df000415 	stw	fp,16(sp)
    35bc:	df000404 	addi	fp,sp,16
    35c0:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    35c4:	e0bfff17 	ldw	r2,-4(fp)
    35c8:	10800817 	ldw	r2,32(r2)
    35cc:	e0bffd15 	stw	r2,-12(fp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
    35d0:	e13ffd17 	ldw	r4,-12(fp)
    35d4:	01400144 	movi	r5,5
    35d8:	0003c800 	call	3c80 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
    35dc:	e13fff17 	ldw	r4,-4(fp)
    35e0:	e17ffd17 	ldw	r5,-12(fp)
    35e4:	018000c4 	movi	r6,3
    35e8:	0004cac0 	call	4cac <dhcp_create_msg>
    35ec:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
    35f0:	e0bffe07 	ldb	r2,-8(fp)
    35f4:	1000231e 	bne	r2,zero,3684 <dhcp_renew+0xd4>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    35f8:	e13ffd17 	ldw	r4,-12(fp)
    35fc:	01400e44 	movi	r5,57
    3600:	01800084 	movi	r6,2
    3604:	0003cd80 	call	3cd8 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    3608:	e0bfff17 	ldw	r2,-4(fp)
    360c:	1080090b 	ldhu	r2,36(r2)
    3610:	10bfffcc 	andi	r2,r2,65535
    3614:	e13ffd17 	ldw	r4,-12(fp)
    3618:	100b883a 	mov	r5,r2
    361c:	0003e580 	call	3e58 <dhcp_option_short>
#if LWIP_NETIF_HOSTNAME
    dhcp_option_hostname(dhcp, netif);
#endif /* LWIP_NETIF_HOSTNAME */

    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
    3620:	e13ffd17 	ldw	r4,-12(fp)
    3624:	00052600 	call	5260 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    3628:	e0bffd17 	ldw	r2,-12(fp)
    362c:	10c00417 	ldw	r3,16(r2)
    3630:	e0bffd17 	ldw	r2,-12(fp)
    3634:	1080060b 	ldhu	r2,24(r2)
    3638:	10803c04 	addi	r2,r2,240
    363c:	10bfffcc 	andi	r2,r2,65535
    3640:	1809883a 	mov	r4,r3
    3644:	100b883a 	mov	r5,r2
    3648:	000a5b80 	call	a5b8 <pbuf_realloc>

    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
    364c:	e0bffd17 	ldw	r2,-12(fp)
    3650:	11000117 	ldw	r4,4(r2)
    3654:	e0bffd17 	ldw	r2,-12(fp)
    3658:	10c00417 	ldw	r3,16(r2)
    365c:	e0bffd17 	ldw	r2,-12(fp)
    3660:	10800804 	addi	r2,r2,32
    3664:	e17fff17 	ldw	r5,-4(fp)
    3668:	d9400015 	stw	r5,0(sp)
    366c:	180b883a 	mov	r5,r3
    3670:	100d883a 	mov	r6,r2
    3674:	01c010c4 	movi	r7,67
    3678:	00157880 	call	15788 <udp_sendto_if>
    dhcp_delete_msg(dhcp);
    367c:	e13ffd17 	ldw	r4,-12(fp)
    3680:	00051800 	call	5180 <dhcp_delete_msg>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    3684:	e0bffd17 	ldw	r2,-12(fp)
    3688:	10800343 	ldbu	r2,13(r2)
    368c:	10800044 	addi	r2,r2,1
    3690:	1007883a 	mov	r3,r2
    3694:	e0bffd17 	ldw	r2,-12(fp)
    3698:	10c00345 	stb	r3,13(r2)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
    369c:	e0bffd17 	ldw	r2,-12(fp)
    36a0:	10800343 	ldbu	r2,13(r2)
    36a4:	10803fcc 	andi	r2,r2,255
    36a8:	108002a8 	cmpgeui	r2,r2,10
    36ac:	1000051e 	bne	r2,zero,36c4 <dhcp_renew+0x114>
    36b0:	e0bffd17 	ldw	r2,-12(fp)
    36b4:	10800343 	ldbu	r2,13(r2)
    36b8:	10803fcc 	andi	r2,r2,255
    36bc:	1081f424 	muli	r2,r2,2000
    36c0:	00000106 	br	36c8 <dhcp_renew+0x118>
    36c4:	00938804 	movi	r2,20000
    36c8:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    36cc:	e0bffe8b 	ldhu	r2,-6(fp)
    36d0:	10c07cc4 	addi	r3,r2,499
    36d4:	00807d04 	movi	r2,500
    36d8:	1885283a 	div	r2,r3,r2
    36dc:	1007883a 	mov	r3,r2
    36e0:	e0bffd17 	ldw	r2,-12(fp)
    36e4:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
    36e8:	e0bffe03 	ldbu	r2,-8(fp)
}
    36ec:	e037883a 	mov	sp,fp
    36f0:	dfc00117 	ldw	ra,4(sp)
    36f4:	df000017 	ldw	fp,0(sp)
    36f8:	dec00204 	addi	sp,sp,8
    36fc:	f800283a 	ret

00003700 <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
    3700:	defffa04 	addi	sp,sp,-24
    3704:	dfc00515 	stw	ra,20(sp)
    3708:	df000415 	stw	fp,16(sp)
    370c:	df000404 	addi	fp,sp,16
    3710:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    3714:	e0bfff17 	ldw	r2,-4(fp)
    3718:	10800817 	ldw	r2,32(r2)
    371c:	e0bffd15 	stw	r2,-12(fp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
    3720:	e13ffd17 	ldw	r4,-12(fp)
    3724:	01400104 	movi	r5,4
    3728:	0003c800 	call	3c80 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
    372c:	e13fff17 	ldw	r4,-4(fp)
    3730:	e17ffd17 	ldw	r5,-12(fp)
    3734:	018000c4 	movi	r6,3
    3738:	0004cac0 	call	4cac <dhcp_create_msg>
    373c:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
    3740:	e0bffe07 	ldb	r2,-8(fp)
    3744:	1000231e 	bne	r2,zero,37d4 <dhcp_rebind+0xd4>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    3748:	e13ffd17 	ldw	r4,-12(fp)
    374c:	01400e44 	movi	r5,57
    3750:	01800084 	movi	r6,2
    3754:	0003cd80 	call	3cd8 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    3758:	e0bfff17 	ldw	r2,-4(fp)
    375c:	1080090b 	ldhu	r2,36(r2)
    3760:	10bfffcc 	andi	r2,r2,65535
    3764:	e13ffd17 	ldw	r4,-12(fp)
    3768:	100b883a 	mov	r5,r2
    376c:	0003e580 	call	3e58 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
    3770:	e13ffd17 	ldw	r4,-12(fp)
    3774:	00052600 	call	5260 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    3778:	e0bffd17 	ldw	r2,-12(fp)
    377c:	10c00417 	ldw	r3,16(r2)
    3780:	e0bffd17 	ldw	r2,-12(fp)
    3784:	1080060b 	ldhu	r2,24(r2)
    3788:	10803c04 	addi	r2,r2,240
    378c:	10bfffcc 	andi	r2,r2,65535
    3790:	1809883a 	mov	r4,r3
    3794:	100b883a 	mov	r5,r2
    3798:	000a5b80 	call	a5b8 <pbuf_realloc>

    /* broadcast to server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    379c:	e0bffd17 	ldw	r2,-12(fp)
    37a0:	10c00117 	ldw	r3,4(r2)
    37a4:	e0bffd17 	ldw	r2,-12(fp)
    37a8:	10800417 	ldw	r2,16(r2)
    37ac:	e13fff17 	ldw	r4,-4(fp)
    37b0:	d9000015 	stw	r4,0(sp)
    37b4:	1809883a 	mov	r4,r3
    37b8:	100b883a 	mov	r5,r2
    37bc:	018000f4 	movhi	r6,3
    37c0:	31957504 	addi	r6,r6,21972
    37c4:	01c010c4 	movi	r7,67
    37c8:	00157880 	call	15788 <udp_sendto_if>
    dhcp_delete_msg(dhcp);
    37cc:	e13ffd17 	ldw	r4,-12(fp)
    37d0:	00051800 	call	5180 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    37d4:	e0bffd17 	ldw	r2,-12(fp)
    37d8:	10800343 	ldbu	r2,13(r2)
    37dc:	10800044 	addi	r2,r2,1
    37e0:	1007883a 	mov	r3,r2
    37e4:	e0bffd17 	ldw	r2,-12(fp)
    37e8:	10c00345 	stb	r3,13(r2)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    37ec:	e0bffd17 	ldw	r2,-12(fp)
    37f0:	10800343 	ldbu	r2,13(r2)
    37f4:	10803fcc 	andi	r2,r2,255
    37f8:	108002a8 	cmpgeui	r2,r2,10
    37fc:	1000051e 	bne	r2,zero,3814 <dhcp_rebind+0x114>
    3800:	e0bffd17 	ldw	r2,-12(fp)
    3804:	10800343 	ldbu	r2,13(r2)
    3808:	10803fcc 	andi	r2,r2,255
    380c:	1080fa24 	muli	r2,r2,1000
    3810:	00000106 	br	3818 <dhcp_rebind+0x118>
    3814:	0089c404 	movi	r2,10000
    3818:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    381c:	e0bffe8b 	ldhu	r2,-6(fp)
    3820:	10c07cc4 	addi	r3,r2,499
    3824:	00807d04 	movi	r2,500
    3828:	1885283a 	div	r2,r3,r2
    382c:	1007883a 	mov	r3,r2
    3830:	e0bffd17 	ldw	r2,-12(fp)
    3834:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
    3838:	e0bffe03 	ldbu	r2,-8(fp)
}
    383c:	e037883a 	mov	sp,fp
    3840:	dfc00117 	ldw	ra,4(sp)
    3844:	df000017 	ldw	fp,0(sp)
    3848:	dec00204 	addi	sp,sp,8
    384c:	f800283a 	ret

00003850 <dhcp_reboot>:
 *
 * @param netif network interface which must reboot
 */
static err_t
dhcp_reboot(struct netif *netif)
{
    3850:	defffa04 	addi	sp,sp,-24
    3854:	dfc00515 	stw	ra,20(sp)
    3858:	df000415 	stw	fp,16(sp)
    385c:	df000404 	addi	fp,sp,16
    3860:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    3864:	e0bfff17 	ldw	r2,-4(fp)
    3868:	10800817 	ldw	r2,32(r2)
    386c:	e0bffd15 	stw	r2,-12(fp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot()\n"));
  dhcp_set_state(dhcp, DHCP_REBOOTING);
    3870:	e13ffd17 	ldw	r4,-12(fp)
    3874:	014000c4 	movi	r5,3
    3878:	0003c800 	call	3c80 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
    387c:	e13fff17 	ldw	r4,-4(fp)
    3880:	e17ffd17 	ldw	r5,-12(fp)
    3884:	018000c4 	movi	r6,3
    3888:	0004cac0 	call	4cac <dhcp_create_msg>
    388c:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
    3890:	e0bffe07 	ldb	r2,-8(fp)
    3894:	1000381e 	bne	r2,zero,3978 <dhcp_reboot+0x128>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    3898:	e13ffd17 	ldw	r4,-12(fp)
    389c:	01400e44 	movi	r5,57
    38a0:	01800084 	movi	r6,2
    38a4:	0003cd80 	call	3cd8 <dhcp_option>
    dhcp_option_short(dhcp, 576);
    38a8:	e13ffd17 	ldw	r4,-12(fp)
    38ac:	01409004 	movi	r5,576
    38b0:	0003e580 	call	3e58 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    38b4:	e13ffd17 	ldw	r4,-12(fp)
    38b8:	01400c84 	movi	r5,50
    38bc:	01800104 	movi	r6,4
    38c0:	0003cd80 	call	3cd8 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
    38c4:	e0bffd17 	ldw	r2,-12(fp)
    38c8:	10800917 	ldw	r2,36(r2)
    38cc:	1006d63a 	srli	r3,r2,24
    38d0:	e0bffd17 	ldw	r2,-12(fp)
    38d4:	10800917 	ldw	r2,36(r2)
    38d8:	1004d23a 	srli	r2,r2,8
    38dc:	10bfc00c 	andi	r2,r2,65280
    38e0:	1886b03a 	or	r3,r3,r2
    38e4:	e0bffd17 	ldw	r2,-12(fp)
    38e8:	10800917 	ldw	r2,36(r2)
    38ec:	10bfc00c 	andi	r2,r2,65280
    38f0:	1004923a 	slli	r2,r2,8
    38f4:	1886b03a 	or	r3,r3,r2
    38f8:	e0bffd17 	ldw	r2,-12(fp)
    38fc:	10800917 	ldw	r2,36(r2)
    3900:	1004963a 	slli	r2,r2,24
    3904:	1884b03a 	or	r2,r3,r2
    3908:	e13ffd17 	ldw	r4,-12(fp)
    390c:	100b883a 	mov	r5,r2
    3910:	0003f300 	call	3f30 <dhcp_option_long>

    dhcp_option_trailer(dhcp);
    3914:	e13ffd17 	ldw	r4,-12(fp)
    3918:	00052600 	call	5260 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    391c:	e0bffd17 	ldw	r2,-12(fp)
    3920:	10c00417 	ldw	r3,16(r2)
    3924:	e0bffd17 	ldw	r2,-12(fp)
    3928:	1080060b 	ldhu	r2,24(r2)
    392c:	10803c04 	addi	r2,r2,240
    3930:	10bfffcc 	andi	r2,r2,65535
    3934:	1809883a 	mov	r4,r3
    3938:	100b883a 	mov	r5,r2
    393c:	000a5b80 	call	a5b8 <pbuf_realloc>

    /* broadcast to server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    3940:	e0bffd17 	ldw	r2,-12(fp)
    3944:	10c00117 	ldw	r3,4(r2)
    3948:	e0bffd17 	ldw	r2,-12(fp)
    394c:	10800417 	ldw	r2,16(r2)
    3950:	e13fff17 	ldw	r4,-4(fp)
    3954:	d9000015 	stw	r4,0(sp)
    3958:	1809883a 	mov	r4,r3
    395c:	100b883a 	mov	r5,r2
    3960:	018000f4 	movhi	r6,3
    3964:	31957504 	addi	r6,r6,21972
    3968:	01c010c4 	movi	r7,67
    396c:	00157880 	call	15788 <udp_sendto_if>
    dhcp_delete_msg(dhcp);
    3970:	e13ffd17 	ldw	r4,-12(fp)
    3974:	00051800 	call	5180 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot: REBOOTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_reboot: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    3978:	e0bffd17 	ldw	r2,-12(fp)
    397c:	10800343 	ldbu	r2,13(r2)
    3980:	10800044 	addi	r2,r2,1
    3984:	1007883a 	mov	r3,r2
    3988:	e0bffd17 	ldw	r2,-12(fp)
    398c:	10c00345 	stb	r3,13(r2)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    3990:	e0bffd17 	ldw	r2,-12(fp)
    3994:	10800343 	ldbu	r2,13(r2)
    3998:	10803fcc 	andi	r2,r2,255
    399c:	108002a8 	cmpgeui	r2,r2,10
    39a0:	1000051e 	bne	r2,zero,39b8 <dhcp_reboot+0x168>
    39a4:	e0bffd17 	ldw	r2,-12(fp)
    39a8:	10800343 	ldbu	r2,13(r2)
    39ac:	10803fcc 	andi	r2,r2,255
    39b0:	1080fa24 	muli	r2,r2,1000
    39b4:	00000106 	br	39bc <dhcp_reboot+0x16c>
    39b8:	0089c404 	movi	r2,10000
    39bc:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    39c0:	e0bffe8b 	ldhu	r2,-6(fp)
    39c4:	10c07cc4 	addi	r3,r2,499
    39c8:	00807d04 	movi	r2,500
    39cc:	1885283a 	div	r2,r3,r2
    39d0:	1007883a 	mov	r3,r2
    39d4:	e0bffd17 	ldw	r2,-12(fp)
    39d8:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
    39dc:	e0bffe03 	ldbu	r2,-8(fp)
}
    39e0:	e037883a 	mov	sp,fp
    39e4:	dfc00117 	ldw	ra,4(sp)
    39e8:	df000017 	ldw	fp,0(sp)
    39ec:	dec00204 	addi	sp,sp,8
    39f0:	f800283a 	ret

000039f4 <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
    39f4:	defffa04 	addi	sp,sp,-24
    39f8:	dfc00515 	stw	ra,20(sp)
    39fc:	df000415 	stw	fp,16(sp)
    3a00:	df000404 	addi	fp,sp,16
    3a04:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
    3a08:	e0bfff17 	ldw	r2,-4(fp)
    3a0c:	10800817 	ldw	r2,32(r2)
    3a10:	e0bffd15 	stw	r2,-12(fp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
    3a14:	e13ffd17 	ldw	r4,-12(fp)
    3a18:	000b883a 	mov	r5,zero
    3a1c:	0003c800 	call	3c80 <dhcp_set_state>
  /* clean old DHCP offer */
  ip_addr_set_zero(&dhcp->server_ip_addr);
    3a20:	e0bffd17 	ldw	r2,-12(fp)
    3a24:	10000815 	stw	zero,32(r2)
  ip_addr_set_zero(&dhcp->offered_ip_addr);
    3a28:	e0bffd17 	ldw	r2,-12(fp)
    3a2c:	10000915 	stw	zero,36(r2)
  ip_addr_set_zero(&dhcp->offered_sn_mask);
    3a30:	e0bffd17 	ldw	r2,-12(fp)
    3a34:	10000a15 	stw	zero,40(r2)
  ip_addr_set_zero(&dhcp->offered_gw_addr);
    3a38:	e0bffd17 	ldw	r2,-12(fp)
    3a3c:	10000b15 	stw	zero,44(r2)
#if LWIP_DHCP_BOOTP_FILE
  ip_addr_set_zero(&dhcp->offered_si_addr);
#endif /* LWIP_DHCP_BOOTP_FILE */
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
    3a40:	e0bffd17 	ldw	r2,-12(fp)
    3a44:	10000e15 	stw	zero,56(r2)
    3a48:	e0bffd17 	ldw	r2,-12(fp)
    3a4c:	10c00e17 	ldw	r3,56(r2)
    3a50:	e0bffd17 	ldw	r2,-12(fp)
    3a54:	10c00d15 	stw	r3,52(r2)
    3a58:	e0bffd17 	ldw	r2,-12(fp)
    3a5c:	10c00d17 	ldw	r3,52(r2)
    3a60:	e0bffd17 	ldw	r2,-12(fp)
    3a64:	10c00c15 	stw	r3,48(r2)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_RELEASE);
    3a68:	e13fff17 	ldw	r4,-4(fp)
    3a6c:	e17ffd17 	ldw	r5,-12(fp)
    3a70:	018001c4 	movi	r6,7
    3a74:	0004cac0 	call	4cac <dhcp_create_msg>
    3a78:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
    3a7c:	e0bffe07 	ldb	r2,-8(fp)
    3a80:	1000191e 	bne	r2,zero,3ae8 <dhcp_release+0xf4>
    dhcp_option_trailer(dhcp);
    3a84:	e13ffd17 	ldw	r4,-12(fp)
    3a88:	00052600 	call	5260 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    3a8c:	e0bffd17 	ldw	r2,-12(fp)
    3a90:	10c00417 	ldw	r3,16(r2)
    3a94:	e0bffd17 	ldw	r2,-12(fp)
    3a98:	1080060b 	ldhu	r2,24(r2)
    3a9c:	10803c04 	addi	r2,r2,240
    3aa0:	10bfffcc 	andi	r2,r2,65535
    3aa4:	1809883a 	mov	r4,r3
    3aa8:	100b883a 	mov	r5,r2
    3aac:	000a5b80 	call	a5b8 <pbuf_realloc>

    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
    3ab0:	e0bffd17 	ldw	r2,-12(fp)
    3ab4:	11000117 	ldw	r4,4(r2)
    3ab8:	e0bffd17 	ldw	r2,-12(fp)
    3abc:	10c00417 	ldw	r3,16(r2)
    3ac0:	e0bffd17 	ldw	r2,-12(fp)
    3ac4:	10800804 	addi	r2,r2,32
    3ac8:	e17fff17 	ldw	r5,-4(fp)
    3acc:	d9400015 	stw	r5,0(sp)
    3ad0:	180b883a 	mov	r5,r3
    3ad4:	100d883a 	mov	r6,r2
    3ad8:	01c010c4 	movi	r7,67
    3adc:	00157880 	call	15788 <udp_sendto_if>
    dhcp_delete_msg(dhcp);
    3ae0:	e13ffd17 	ldw	r4,-12(fp)
    3ae4:	00051800 	call	5180 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    3ae8:	e0bffd17 	ldw	r2,-12(fp)
    3aec:	10800343 	ldbu	r2,13(r2)
    3af0:	10800044 	addi	r2,r2,1
    3af4:	1007883a 	mov	r3,r2
    3af8:	e0bffd17 	ldw	r2,-12(fp)
    3afc:	10c00345 	stb	r3,13(r2)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    3b00:	e0bffd17 	ldw	r2,-12(fp)
    3b04:	10800343 	ldbu	r2,13(r2)
    3b08:	10803fcc 	andi	r2,r2,255
    3b0c:	108002a8 	cmpgeui	r2,r2,10
    3b10:	1000051e 	bne	r2,zero,3b28 <dhcp_release+0x134>
    3b14:	e0bffd17 	ldw	r2,-12(fp)
    3b18:	10800343 	ldbu	r2,13(r2)
    3b1c:	10803fcc 	andi	r2,r2,255
    3b20:	1080fa24 	muli	r2,r2,1000
    3b24:	00000106 	br	3b2c <dhcp_release+0x138>
    3b28:	0089c404 	movi	r2,10000
    3b2c:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    3b30:	e0bffe8b 	ldhu	r2,-6(fp)
    3b34:	10c07cc4 	addi	r3,r2,499
    3b38:	00807d04 	movi	r2,500
    3b3c:	1885283a 	div	r2,r3,r2
    3b40:	1007883a 	mov	r3,r2
    3b44:	e0bffd17 	ldw	r2,-12(fp)
    3b48:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
    3b4c:	e13fff17 	ldw	r4,-4(fp)
    3b50:	0009e700 	call	9e70 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
    3b54:	e13fff17 	ldw	r4,-4(fp)
    3b58:	014000f4 	movhi	r5,3
    3b5c:	29557404 	addi	r5,r5,21968
    3b60:	0009bfc0 	call	9bfc <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
    3b64:	e13fff17 	ldw	r4,-4(fp)
    3b68:	014000f4 	movhi	r5,3
    3b6c:	29557404 	addi	r5,r5,21968
    3b70:	0009d300 	call	9d30 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
    3b74:	e13fff17 	ldw	r4,-4(fp)
    3b78:	014000f4 	movhi	r5,3
    3b7c:	29557404 	addi	r5,r5,21968
    3b80:	0009d740 	call	9d74 <netif_set_netmask>
  
  return result;
    3b84:	e0bffe03 	ldbu	r2,-8(fp)
}
    3b88:	e037883a 	mov	sp,fp
    3b8c:	dfc00117 	ldw	ra,4(sp)
    3b90:	df000017 	ldw	fp,0(sp)
    3b94:	dec00204 	addi	sp,sp,8
    3b98:	f800283a 	ret

00003b9c <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
    3b9c:	defffc04 	addi	sp,sp,-16
    3ba0:	dfc00315 	stw	ra,12(sp)
    3ba4:	df000215 	stw	fp,8(sp)
    3ba8:	df000204 	addi	fp,sp,8
    3bac:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
    3bb0:	e0bfff17 	ldw	r2,-4(fp)
    3bb4:	1000091e 	bne	r2,zero,3bdc <dhcp_stop+0x40>
    3bb8:	010000f4 	movhi	r4,3
    3bbc:	213ccf04 	addi	r4,r4,-3268
    3bc0:	014000f4 	movhi	r5,3
    3bc4:	297d0804 	addi	r5,r5,-3040
    3bc8:	018131c4 	movi	r6,1223
    3bcc:	01c000f4 	movhi	r7,3
    3bd0:	39fcdd04 	addi	r7,r7,-3212
    3bd4:	00193f00 	call	193f0 <printf>
    3bd8:	003fff06 	br	3bd8 <dhcp_stop+0x3c>
  dhcp = netif->dhcp;
    3bdc:	e0bfff17 	ldw	r2,-4(fp)
    3be0:	10800817 	ldw	r2,32(r2)
    3be4:	e0bffe15 	stw	r2,-8(fp)
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
    3be8:	e0bfff17 	ldw	r2,-4(fp)
    3bec:	10c00b43 	ldbu	r3,45(r2)
    3bf0:	00bffdc4 	movi	r2,-9
    3bf4:	1884703a 	and	r2,r3,r2
    3bf8:	1007883a 	mov	r3,r2
    3bfc:	e0bfff17 	ldw	r2,-4(fp)
    3c00:	10c00b45 	stb	r3,45(r2)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
    3c04:	e0bffe17 	ldw	r2,-8(fp)
    3c08:	10001826 	beq	r2,zero,3c6c <dhcp_stop+0xd0>
      autoip_stop(netif);
      dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
    }
#endif /* LWIP_DHCP_AUTOIP_COOP */

    if (dhcp->pcb != NULL) {
    3c0c:	e0bffe17 	ldw	r2,-8(fp)
    3c10:	10800117 	ldw	r2,4(r2)
    3c14:	10000626 	beq	r2,zero,3c30 <dhcp_stop+0x94>
      udp_remove(dhcp->pcb);
    3c18:	e0bffe17 	ldw	r2,-8(fp)
    3c1c:	10800117 	ldw	r2,4(r2)
    3c20:	1009883a 	mov	r4,r2
    3c24:	0015d680 	call	15d68 <udp_remove>
      dhcp->pcb = NULL;
    3c28:	e0bffe17 	ldw	r2,-8(fp)
    3c2c:	10000115 	stw	zero,4(r2)
    }
    LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL);
    3c30:	e0bffe17 	ldw	r2,-8(fp)
    3c34:	10800217 	ldw	r2,8(r2)
    3c38:	10000926 	beq	r2,zero,3c60 <dhcp_stop+0xc4>
    3c3c:	010000f4 	movhi	r4,3
    3c40:	213ccf04 	addi	r4,r4,-3268
    3c44:	014000f4 	movhi	r5,3
    3c48:	297cf604 	addi	r5,r5,-3112
    3c4c:	01813684 	movi	r6,1242
    3c50:	01c000f4 	movhi	r7,3
    3c54:	39fcdd04 	addi	r7,r7,-3212
    3c58:	00193f00 	call	193f0 <printf>
    3c5c:	003fff06 	br	3c5c <dhcp_stop+0xc0>
    dhcp_set_state(dhcp, DHCP_OFF);
    3c60:	e13ffe17 	ldw	r4,-8(fp)
    3c64:	000b883a 	mov	r5,zero
    3c68:	0003c800 	call	3c80 <dhcp_set_state>
  }
}
    3c6c:	e037883a 	mov	sp,fp
    3c70:	dfc00117 	ldw	ra,4(sp)
    3c74:	df000017 	ldw	fp,0(sp)
    3c78:	dec00204 	addi	sp,sp,8
    3c7c:	f800283a 	ret

00003c80 <dhcp_set_state>:
 *
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
    3c80:	defffd04 	addi	sp,sp,-12
    3c84:	df000215 	stw	fp,8(sp)
    3c88:	df000204 	addi	fp,sp,8
    3c8c:	e13ffe15 	stw	r4,-8(fp)
    3c90:	2805883a 	mov	r2,r5
    3c94:	e0bfff05 	stb	r2,-4(fp)
  if (new_state != dhcp->state) {
    3c98:	e0bffe17 	ldw	r2,-8(fp)
    3c9c:	10800303 	ldbu	r2,12(r2)
    3ca0:	10c03fcc 	andi	r3,r2,255
    3ca4:	e0bfff03 	ldbu	r2,-4(fp)
    3ca8:	18800726 	beq	r3,r2,3cc8 <dhcp_set_state+0x48>
    dhcp->state = new_state;
    3cac:	e0bffe17 	ldw	r2,-8(fp)
    3cb0:	e0ffff03 	ldbu	r3,-4(fp)
    3cb4:	10c00305 	stb	r3,12(r2)
    dhcp->tries = 0;
    3cb8:	e0bffe17 	ldw	r2,-8(fp)
    3cbc:	10000345 	stb	zero,13(r2)
    dhcp->request_timeout = 0;
    3cc0:	e0bffe17 	ldw	r2,-8(fp)
    3cc4:	1000068d 	sth	zero,26(r2)
  }
}
    3cc8:	e037883a 	mov	sp,fp
    3ccc:	df000017 	ldw	fp,0(sp)
    3cd0:	dec00104 	addi	sp,sp,4
    3cd4:	f800283a 	ret

00003cd8 <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
    3cd8:	defffb04 	addi	sp,sp,-20
    3cdc:	dfc00415 	stw	ra,16(sp)
    3ce0:	df000315 	stw	fp,12(sp)
    3ce4:	df000304 	addi	fp,sp,12
    3ce8:	e13ffd15 	stw	r4,-12(fp)
    3cec:	2807883a 	mov	r3,r5
    3cf0:	3005883a 	mov	r2,r6
    3cf4:	e0fffe05 	stb	r3,-8(fp)
    3cf8:	e0bfff05 	stb	r2,-4(fp)
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
    3cfc:	e0bffd17 	ldw	r2,-12(fp)
    3d00:	1080060b 	ldhu	r2,24(r2)
    3d04:	10ffffcc 	andi	r3,r2,65535
    3d08:	e0bfff03 	ldbu	r2,-4(fp)
    3d0c:	1885883a 	add	r2,r3,r2
    3d10:	10800084 	addi	r2,r2,2
    3d14:	10801170 	cmpltui	r2,r2,69
    3d18:	1000091e 	bne	r2,zero,3d40 <dhcp_option+0x68>
    3d1c:	010000f4 	movhi	r4,3
    3d20:	213ccf04 	addi	r4,r4,-3268
    3d24:	014000f4 	movhi	r5,3
    3d28:	297d0f04 	addi	r5,r5,-3012
    3d2c:	01813d84 	movi	r6,1270
    3d30:	01c000f4 	movhi	r7,3
    3d34:	39fcdd04 	addi	r7,r7,-3212
    3d38:	00193f00 	call	193f0 <printf>
    3d3c:	003fff06 	br	3d3c <dhcp_option+0x64>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
    3d40:	e0bffd17 	ldw	r2,-12(fp)
    3d44:	11000517 	ldw	r4,20(r2)
    3d48:	e0bffd17 	ldw	r2,-12(fp)
    3d4c:	1080060b 	ldhu	r2,24(r2)
    3d50:	10ffffcc 	andi	r3,r2,65535
    3d54:	20c7883a 	add	r3,r4,r3
    3d58:	18c03c04 	addi	r3,r3,240
    3d5c:	e13ffe03 	ldbu	r4,-8(fp)
    3d60:	19000005 	stb	r4,0(r3)
    3d64:	10800044 	addi	r2,r2,1
    3d68:	1007883a 	mov	r3,r2
    3d6c:	e0bffd17 	ldw	r2,-12(fp)
    3d70:	10c0060d 	sth	r3,24(r2)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
    3d74:	e0bffd17 	ldw	r2,-12(fp)
    3d78:	11000517 	ldw	r4,20(r2)
    3d7c:	e0bffd17 	ldw	r2,-12(fp)
    3d80:	1080060b 	ldhu	r2,24(r2)
    3d84:	10ffffcc 	andi	r3,r2,65535
    3d88:	20c7883a 	add	r3,r4,r3
    3d8c:	18c03c04 	addi	r3,r3,240
    3d90:	e13fff03 	ldbu	r4,-4(fp)
    3d94:	19000005 	stb	r4,0(r3)
    3d98:	10800044 	addi	r2,r2,1
    3d9c:	1007883a 	mov	r3,r2
    3da0:	e0bffd17 	ldw	r2,-12(fp)
    3da4:	10c0060d 	sth	r3,24(r2)
}
    3da8:	e037883a 	mov	sp,fp
    3dac:	dfc00117 	ldw	ra,4(sp)
    3db0:	df000017 	ldw	fp,0(sp)
    3db4:	dec00204 	addi	sp,sp,8
    3db8:	f800283a 	ret

00003dbc <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
    3dbc:	defffc04 	addi	sp,sp,-16
    3dc0:	dfc00315 	stw	ra,12(sp)
    3dc4:	df000215 	stw	fp,8(sp)
    3dc8:	df000204 	addi	fp,sp,8
    3dcc:	e13ffe15 	stw	r4,-8(fp)
    3dd0:	2805883a 	mov	r2,r5
    3dd4:	e0bfff05 	stb	r2,-4(fp)
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    3dd8:	e0bffe17 	ldw	r2,-8(fp)
    3ddc:	1080060b 	ldhu	r2,24(r2)
    3de0:	10bfffcc 	andi	r2,r2,65535
    3de4:	10801130 	cmpltui	r2,r2,68
    3de8:	1000091e 	bne	r2,zero,3e10 <dhcp_option_byte+0x54>
    3dec:	010000f4 	movhi	r4,3
    3df0:	213ccf04 	addi	r4,r4,-3268
    3df4:	014000f4 	movhi	r5,3
    3df8:	297d2104 	addi	r5,r5,-2940
    3dfc:	01814044 	movi	r6,1281
    3e00:	01c000f4 	movhi	r7,3
    3e04:	39fcdd04 	addi	r7,r7,-3212
    3e08:	00193f00 	call	193f0 <printf>
    3e0c:	003fff06 	br	3e0c <dhcp_option_byte+0x50>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
    3e10:	e0bffe17 	ldw	r2,-8(fp)
    3e14:	11000517 	ldw	r4,20(r2)
    3e18:	e0bffe17 	ldw	r2,-8(fp)
    3e1c:	1080060b 	ldhu	r2,24(r2)
    3e20:	10ffffcc 	andi	r3,r2,65535
    3e24:	20c7883a 	add	r3,r4,r3
    3e28:	18c03c04 	addi	r3,r3,240
    3e2c:	e13fff03 	ldbu	r4,-4(fp)
    3e30:	19000005 	stb	r4,0(r3)
    3e34:	10800044 	addi	r2,r2,1
    3e38:	1007883a 	mov	r3,r2
    3e3c:	e0bffe17 	ldw	r2,-8(fp)
    3e40:	10c0060d 	sth	r3,24(r2)
}
    3e44:	e037883a 	mov	sp,fp
    3e48:	dfc00117 	ldw	ra,4(sp)
    3e4c:	df000017 	ldw	fp,0(sp)
    3e50:	dec00204 	addi	sp,sp,8
    3e54:	f800283a 	ret

00003e58 <dhcp_option_short>:

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
    3e58:	defffc04 	addi	sp,sp,-16
    3e5c:	dfc00315 	stw	ra,12(sp)
    3e60:	df000215 	stw	fp,8(sp)
    3e64:	df000204 	addi	fp,sp,8
    3e68:	e13ffe15 	stw	r4,-8(fp)
    3e6c:	2805883a 	mov	r2,r5
    3e70:	e0bfff0d 	sth	r2,-4(fp)
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
    3e74:	e0bffe17 	ldw	r2,-8(fp)
    3e78:	1080060b 	ldhu	r2,24(r2)
    3e7c:	10bfffcc 	andi	r2,r2,65535
    3e80:	10800084 	addi	r2,r2,2
    3e84:	10801170 	cmpltui	r2,r2,69
    3e88:	1000091e 	bne	r2,zero,3eb0 <dhcp_option_short+0x58>
    3e8c:	010000f4 	movhi	r4,3
    3e90:	213ccf04 	addi	r4,r4,-3268
    3e94:	014000f4 	movhi	r5,3
    3e98:	297d3004 	addi	r5,r5,-2880
    3e9c:	01814204 	movi	r6,1288
    3ea0:	01c000f4 	movhi	r7,3
    3ea4:	39fcdd04 	addi	r7,r7,-3212
    3ea8:	00193f00 	call	193f0 <printf>
    3eac:	003fff06 	br	3eac <dhcp_option_short+0x54>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
    3eb0:	e0bffe17 	ldw	r2,-8(fp)
    3eb4:	11400517 	ldw	r5,20(r2)
    3eb8:	e0bffe17 	ldw	r2,-8(fp)
    3ebc:	1080060b 	ldhu	r2,24(r2)
    3ec0:	10ffffcc 	andi	r3,r2,65535
    3ec4:	e13fff0b 	ldhu	r4,-4(fp)
    3ec8:	2008d23a 	srli	r4,r4,8
    3ecc:	28c7883a 	add	r3,r5,r3
    3ed0:	18c03c04 	addi	r3,r3,240
    3ed4:	19000005 	stb	r4,0(r3)
    3ed8:	10800044 	addi	r2,r2,1
    3edc:	1007883a 	mov	r3,r2
    3ee0:	e0bffe17 	ldw	r2,-8(fp)
    3ee4:	10c0060d 	sth	r3,24(r2)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
    3ee8:	e0bffe17 	ldw	r2,-8(fp)
    3eec:	11400517 	ldw	r5,20(r2)
    3ef0:	e0bffe17 	ldw	r2,-8(fp)
    3ef4:	1080060b 	ldhu	r2,24(r2)
    3ef8:	10ffffcc 	andi	r3,r2,65535
    3efc:	e13fff0b 	ldhu	r4,-4(fp)
    3f00:	28c7883a 	add	r3,r5,r3
    3f04:	18c03c04 	addi	r3,r3,240
    3f08:	19000005 	stb	r4,0(r3)
    3f0c:	10800044 	addi	r2,r2,1
    3f10:	1007883a 	mov	r3,r2
    3f14:	e0bffe17 	ldw	r2,-8(fp)
    3f18:	10c0060d 	sth	r3,24(r2)
}
    3f1c:	e037883a 	mov	sp,fp
    3f20:	dfc00117 	ldw	ra,4(sp)
    3f24:	df000017 	ldw	fp,0(sp)
    3f28:	dec00204 	addi	sp,sp,8
    3f2c:	f800283a 	ret

00003f30 <dhcp_option_long>:

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
    3f30:	defffc04 	addi	sp,sp,-16
    3f34:	dfc00315 	stw	ra,12(sp)
    3f38:	df000215 	stw	fp,8(sp)
    3f3c:	df000204 	addi	fp,sp,8
    3f40:	e13ffe15 	stw	r4,-8(fp)
    3f44:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
    3f48:	e0bffe17 	ldw	r2,-8(fp)
    3f4c:	1080060b 	ldhu	r2,24(r2)
    3f50:	10bfffcc 	andi	r2,r2,65535
    3f54:	10800104 	addi	r2,r2,4
    3f58:	10801170 	cmpltui	r2,r2,69
    3f5c:	1000091e 	bne	r2,zero,3f84 <dhcp_option_long+0x54>
    3f60:	010000f4 	movhi	r4,3
    3f64:	213ccf04 	addi	r4,r4,-3268
    3f68:	014000f4 	movhi	r5,3
    3f6c:	297d4104 	addi	r5,r5,-2812
    3f70:	01814404 	movi	r6,1296
    3f74:	01c000f4 	movhi	r7,3
    3f78:	39fcdd04 	addi	r7,r7,-3212
    3f7c:	00193f00 	call	193f0 <printf>
    3f80:	003fff06 	br	3f80 <dhcp_option_long+0x50>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
    3f84:	e0bffe17 	ldw	r2,-8(fp)
    3f88:	11400517 	ldw	r5,20(r2)
    3f8c:	e0bffe17 	ldw	r2,-8(fp)
    3f90:	1080060b 	ldhu	r2,24(r2)
    3f94:	10ffffcc 	andi	r3,r2,65535
    3f98:	e13fff17 	ldw	r4,-4(fp)
    3f9c:	2008d63a 	srli	r4,r4,24
    3fa0:	28c7883a 	add	r3,r5,r3
    3fa4:	18c03c04 	addi	r3,r3,240
    3fa8:	19000005 	stb	r4,0(r3)
    3fac:	10800044 	addi	r2,r2,1
    3fb0:	1007883a 	mov	r3,r2
    3fb4:	e0bffe17 	ldw	r2,-8(fp)
    3fb8:	10c0060d 	sth	r3,24(r2)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
    3fbc:	e0bffe17 	ldw	r2,-8(fp)
    3fc0:	11400517 	ldw	r5,20(r2)
    3fc4:	e0bffe17 	ldw	r2,-8(fp)
    3fc8:	1080060b 	ldhu	r2,24(r2)
    3fcc:	10ffffcc 	andi	r3,r2,65535
    3fd0:	e13fff17 	ldw	r4,-4(fp)
    3fd4:	21003fec 	andhi	r4,r4,255
    3fd8:	2008d43a 	srli	r4,r4,16
    3fdc:	28c7883a 	add	r3,r5,r3
    3fe0:	18c03c04 	addi	r3,r3,240
    3fe4:	19000005 	stb	r4,0(r3)
    3fe8:	10800044 	addi	r2,r2,1
    3fec:	1007883a 	mov	r3,r2
    3ff0:	e0bffe17 	ldw	r2,-8(fp)
    3ff4:	10c0060d 	sth	r3,24(r2)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
    3ff8:	e0bffe17 	ldw	r2,-8(fp)
    3ffc:	11400517 	ldw	r5,20(r2)
    4000:	e0bffe17 	ldw	r2,-8(fp)
    4004:	1080060b 	ldhu	r2,24(r2)
    4008:	10ffffcc 	andi	r3,r2,65535
    400c:	e13fff17 	ldw	r4,-4(fp)
    4010:	213fc00c 	andi	r4,r4,65280
    4014:	2008d23a 	srli	r4,r4,8
    4018:	28c7883a 	add	r3,r5,r3
    401c:	18c03c04 	addi	r3,r3,240
    4020:	19000005 	stb	r4,0(r3)
    4024:	10800044 	addi	r2,r2,1
    4028:	1007883a 	mov	r3,r2
    402c:	e0bffe17 	ldw	r2,-8(fp)
    4030:	10c0060d 	sth	r3,24(r2)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
    4034:	e0bffe17 	ldw	r2,-8(fp)
    4038:	11400517 	ldw	r5,20(r2)
    403c:	e0bffe17 	ldw	r2,-8(fp)
    4040:	1080060b 	ldhu	r2,24(r2)
    4044:	10ffffcc 	andi	r3,r2,65535
    4048:	e13fff17 	ldw	r4,-4(fp)
    404c:	28c7883a 	add	r3,r5,r3
    4050:	18c03c04 	addi	r3,r3,240
    4054:	19000005 	stb	r4,0(r3)
    4058:	10800044 	addi	r2,r2,1
    405c:	1007883a 	mov	r3,r2
    4060:	e0bffe17 	ldw	r2,-8(fp)
    4064:	10c0060d 	sth	r3,24(r2)
}
    4068:	e037883a 	mov	sp,fp
    406c:	dfc00117 	ldw	ra,4(sp)
    4070:	df000017 	ldw	fp,0(sp)
    4074:	dec00204 	addi	sp,sp,8
    4078:	f800283a 	ret

0000407c <dhcp_parse_reply>:
 * use that further on.
 *
 */
static err_t
dhcp_parse_reply(struct dhcp *dhcp, struct pbuf *p)
{
    407c:	defff004 	addi	sp,sp,-64
    4080:	dfc00f15 	stw	ra,60(sp)
    4084:	df000e15 	stw	fp,56(sp)
    4088:	df000e04 	addi	fp,sp,56
    408c:	e13ffe15 	stw	r4,-8(fp)
    4090:	e17fff15 	stw	r5,-4(fp)
  u16_t offset;
  u16_t offset_max;
  u16_t options_idx;
  u16_t options_idx_max;
  struct pbuf *q;
  int parse_file_as_options = 0;
    4094:	e03ff615 	stw	zero,-40(fp)
  int parse_sname_as_options = 0;
    4098:	e03ff715 	stw	zero,-36(fp)

  /* clear received options */
  dhcp_clear_all_options(dhcp);
    409c:	01000234 	movhi	r4,8
    40a0:	21021b04 	addi	r4,r4,2156
    40a4:	000b883a 	mov	r5,zero
    40a8:	01800284 	movi	r6,10
    40ac:	00192e80 	call	192e8 <memset>
  /* check that beginning of dhcp_msg (up to and including chaddr) is in first pbuf */
  if (p->len < DHCP_SNAME_OFS) {
    40b0:	e0bfff17 	ldw	r2,-4(fp)
    40b4:	1080028b 	ldhu	r2,10(r2)
    40b8:	10bfffcc 	andi	r2,r2,65535
    40bc:	10800b28 	cmpgeui	r2,r2,44
    40c0:	1000021e 	bne	r2,zero,40cc <dhcp_parse_reply+0x50>
    return ERR_BUF;
    40c4:	00bfff84 	movi	r2,-2
    40c8:	00022a06 	br	4974 <dhcp_parse_reply+0x8f8>
  }
  dhcp->msg_in = (struct dhcp_msg *)p->payload;
    40cc:	e0bfff17 	ldw	r2,-4(fp)
    40d0:	10c00117 	ldw	r3,4(r2)
    40d4:	e0bffe17 	ldw	r2,-8(fp)
    40d8:	10c00215 	stw	r3,8(r2)
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* parse options */

  /* start with options field */
  options_idx = DHCP_OPTIONS_OFS;
    40dc:	00803c04 	movi	r2,240
    40e0:	e0bff40d 	sth	r2,-48(fp)
  /* parse options to the end of the received packet */
  options_idx_max = p->tot_len;
    40e4:	e0bfff17 	ldw	r2,-4(fp)
    40e8:	1080020b 	ldhu	r2,8(r2)
    40ec:	e0bff48d 	sth	r2,-46(fp)
again:
  q = p;
    40f0:	e0bfff17 	ldw	r2,-4(fp)
    40f4:	e0bff515 	stw	r2,-44(fp)
  while((q != NULL) && (options_idx >= q->len)) {
    40f8:	00000d06 	br	4130 <dhcp_parse_reply+0xb4>
    options_idx -= q->len;
    40fc:	e0bff517 	ldw	r2,-44(fp)
    4100:	1080028b 	ldhu	r2,10(r2)
    4104:	e0fff40b 	ldhu	r3,-48(fp)
    4108:	1885c83a 	sub	r2,r3,r2
    410c:	e0bff40d 	sth	r2,-48(fp)
    options_idx_max -= q->len;
    4110:	e0bff517 	ldw	r2,-44(fp)
    4114:	1080028b 	ldhu	r2,10(r2)
    4118:	e0fff48b 	ldhu	r3,-46(fp)
    411c:	1885c83a 	sub	r2,r3,r2
    4120:	e0bff48d 	sth	r2,-46(fp)
    q = q->next;
    4124:	e0bff517 	ldw	r2,-44(fp)
    4128:	10800017 	ldw	r2,0(r2)
    412c:	e0bff515 	stw	r2,-44(fp)
  options_idx = DHCP_OPTIONS_OFS;
  /* parse options to the end of the received packet */
  options_idx_max = p->tot_len;
again:
  q = p;
  while((q != NULL) && (options_idx >= q->len)) {
    4130:	e0bff517 	ldw	r2,-44(fp)
    4134:	10000526 	beq	r2,zero,414c <dhcp_parse_reply+0xd0>
    4138:	e0bff517 	ldw	r2,-44(fp)
    413c:	1080028b 	ldhu	r2,10(r2)
    4140:	10bfffcc 	andi	r2,r2,65535
    4144:	e0fff40b 	ldhu	r3,-48(fp)
    4148:	18bfec2e 	bgeu	r3,r2,40fc <dhcp_parse_reply+0x80>
    options_idx -= q->len;
    options_idx_max -= q->len;
    q = q->next;
  }
  if (q == NULL) {
    414c:	e0bff517 	ldw	r2,-44(fp)
    4150:	1000021e 	bne	r2,zero,415c <dhcp_parse_reply+0xe0>
    return ERR_BUF;
    4154:	00bfff84 	movi	r2,-2
    4158:	00020606 	br	4974 <dhcp_parse_reply+0x8f8>
  }
  offset = options_idx;
    415c:	e0bff40b 	ldhu	r2,-48(fp)
    4160:	e0bff30d 	sth	r2,-52(fp)
  offset_max = options_idx_max;
    4164:	e0bff48b 	ldhu	r2,-46(fp)
    4168:	e0bff38d 	sth	r2,-50(fp)
  options = (u8_t*)q->payload;
    416c:	e0bff517 	ldw	r2,-44(fp)
    4170:	10800117 	ldw	r2,4(r2)
    4174:	e0bff215 	stw	r2,-56(fp)
  /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
  while((q != NULL) && (options[offset] != DHCP_OPTION_END) && (offset < offset_max)) {
    4178:	0001c206 	br	4884 <dhcp_parse_reply+0x808>
    u8_t op = options[offset];
    417c:	e0bff30b 	ldhu	r2,-52(fp)
    4180:	e0fff217 	ldw	r3,-56(fp)
    4184:	1885883a 	add	r2,r3,r2
    4188:	10800003 	ldbu	r2,0(r2)
    418c:	e0bffa85 	stb	r2,-22(fp)
    u8_t len;
    u8_t decode_len = 0;
    4190:	e03ff845 	stb	zero,-31(fp)
    int decode_idx = -1;
    4194:	00bfffc4 	movi	r2,-1
    4198:	e0bff915 	stw	r2,-28(fp)
    u16_t val_offset = offset + 2;
    419c:	e0bff30b 	ldhu	r2,-52(fp)
    41a0:	10800084 	addi	r2,r2,2
    41a4:	e0bffa0d 	sth	r2,-24(fp)
    /* len byte might be in the next pbuf */
    if (offset + 1 < q->len) {
    41a8:	e0bff30b 	ldhu	r2,-52(fp)
    41ac:	10c00044 	addi	r3,r2,1
    41b0:	e0bff517 	ldw	r2,-44(fp)
    41b4:	1080028b 	ldhu	r2,10(r2)
    41b8:	10bfffcc 	andi	r2,r2,65535
    41bc:	1880070e 	bge	r3,r2,41dc <dhcp_parse_reply+0x160>
      len = options[offset + 1];
    41c0:	e0bff30b 	ldhu	r2,-52(fp)
    41c4:	10800044 	addi	r2,r2,1
    41c8:	e0fff217 	ldw	r3,-56(fp)
    41cc:	1885883a 	add	r2,r3,r2
    41d0:	10800003 	ldbu	r2,0(r2)
    41d4:	e0bff805 	stb	r2,-32(fp)
    41d8:	00000a06 	br	4204 <dhcp_parse_reply+0x188>
    } else {
      len = (q->next != NULL ? ((u8_t*)q->next->payload)[0] : 0);
    41dc:	e0bff517 	ldw	r2,-44(fp)
    41e0:	10800017 	ldw	r2,0(r2)
    41e4:	10000526 	beq	r2,zero,41fc <dhcp_parse_reply+0x180>
    41e8:	e0bff517 	ldw	r2,-44(fp)
    41ec:	10800017 	ldw	r2,0(r2)
    41f0:	10800117 	ldw	r2,4(r2)
    41f4:	10800003 	ldbu	r2,0(r2)
    41f8:	00000106 	br	4200 <dhcp_parse_reply+0x184>
    41fc:	0005883a 	mov	r2,zero
    4200:	e0bff805 	stb	r2,-32(fp)
    }
    /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
    decode_len = len;
    4204:	e0bff803 	ldbu	r2,-32(fp)
    4208:	e0bff845 	stb	r2,-31(fp)
    switch(op) {
    420c:	e0bffa83 	ldbu	r2,-22(fp)
    4210:	10c00f28 	cmpgeui	r3,r2,60
    4214:	1800e51e 	bne	r3,zero,45ac <dhcp_parse_reply+0x530>
    4218:	1085883a 	add	r2,r2,r2
    421c:	1087883a 	add	r3,r2,r2
    4220:	00800034 	movhi	r2,0
    4224:	10908d04 	addi	r2,r2,16948
    4228:	1885883a 	add	r2,r3,r2
    422c:	10800017 	ldw	r2,0(r2)
    4230:	1000683a 	jmp	r2
    4234:	00004324 	muli	zero,zero,268
    4238:	00004340 	call	434 <ethernetif_init+0x1c>
    423c:	000045ac 	andhi	zero,zero,278
    4240:	0000437c 	xorhi	zero,zero,269
    4244:	000045ac 	andhi	zero,zero,278
    4248:	000045ac 	andhi	zero,zero,278
    424c:	000043c0 	call	43c <ethernetif_init+0x24>
    4250:	000045ac 	andhi	zero,zero,278
    4254:	000045ac 	andhi	zero,zero,278
    4258:	000045ac 	andhi	zero,zero,278
    425c:	000045ac 	andhi	zero,zero,278
    4260:	000045ac 	andhi	zero,zero,278
    4264:	000045ac 	andhi	zero,zero,278
    4268:	000045ac 	andhi	zero,zero,278
    426c:	000045ac 	andhi	zero,zero,278
    4270:	000045ac 	andhi	zero,zero,278
    4274:	000045ac 	andhi	zero,zero,278
    4278:	000045ac 	andhi	zero,zero,278
    427c:	000045ac 	andhi	zero,zero,278
    4280:	000045ac 	andhi	zero,zero,278
    4284:	000045ac 	andhi	zero,zero,278
    4288:	000045ac 	andhi	zero,zero,278
    428c:	000045ac 	andhi	zero,zero,278
    4290:	000045ac 	andhi	zero,zero,278
    4294:	000045ac 	andhi	zero,zero,278
    4298:	000045ac 	andhi	zero,zero,278
    429c:	000045ac 	andhi	zero,zero,278
    42a0:	000045ac 	andhi	zero,zero,278
    42a4:	000045ac 	andhi	zero,zero,278
    42a8:	000045ac 	andhi	zero,zero,278
    42ac:	000045ac 	andhi	zero,zero,278
    42b0:	000045ac 	andhi	zero,zero,278
    42b4:	000045ac 	andhi	zero,zero,278
    42b8:	000045ac 	andhi	zero,zero,278
    42bc:	000045ac 	andhi	zero,zero,278
    42c0:	000045ac 	andhi	zero,zero,278
    42c4:	000045ac 	andhi	zero,zero,278
    42c8:	000045ac 	andhi	zero,zero,278
    42cc:	000045ac 	andhi	zero,zero,278
    42d0:	000045ac 	andhi	zero,zero,278
    42d4:	000045ac 	andhi	zero,zero,278
    42d8:	000045ac 	andhi	zero,zero,278
    42dc:	000045ac 	andhi	zero,zero,278
    42e0:	000045ac 	andhi	zero,zero,278
    42e4:	000045ac 	andhi	zero,zero,278
    42e8:	000045ac 	andhi	zero,zero,278
    42ec:	000045ac 	andhi	zero,zero,278
    42f0:	000045ac 	andhi	zero,zero,278
    42f4:	000045ac 	andhi	zero,zero,278
    42f8:	000045ac 	andhi	zero,zero,278
    42fc:	000045ac 	andhi	zero,zero,278
    4300:	00004448 	cmpgei	zero,zero,273
    4304:	00004484 	movi	zero,274
    4308:	000044bc 	xorhi	zero,zero,274
    430c:	000044f8 	rdprs	zero,zero,275
    4310:	000045ac 	andhi	zero,zero,278
    4314:	000045ac 	andhi	zero,zero,278
    4318:	000045ac 	andhi	zero,zero,278
    431c:	00004534 	movhi	zero,276
    4320:	00004570 	cmpltui	zero,zero,277
      /* case(DHCP_OPTION_END): handled above */
      case(DHCP_OPTION_PAD):
        /* special option: no len encoded */
        decode_len = len = 0;
    4324:	e03ff805 	stb	zero,-32(fp)
    4328:	e0bff803 	ldbu	r2,-32(fp)
    432c:	e0bff845 	stb	r2,-31(fp)
        /* will be increased below */
        offset--;
    4330:	e0bff30b 	ldhu	r2,-52(fp)
    4334:	10bfffc4 	addi	r2,r2,-1
    4338:	e0bff30d 	sth	r2,-52(fp)
        break;
    433c:	00009d06 	br	45b4 <dhcp_parse_reply+0x538>
      case(DHCP_OPTION_SUBNET_MASK):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    4340:	e0bff803 	ldbu	r2,-32(fp)
    4344:	10800120 	cmpeqi	r2,r2,4
    4348:	1000091e 	bne	r2,zero,4370 <dhcp_parse_reply+0x2f4>
    434c:	010000f4 	movhi	r4,3
    4350:	213ccf04 	addi	r4,r4,-3268
    4354:	014000f4 	movhi	r5,3
    4358:	297d5104 	addi	r5,r5,-2748
    435c:	01815ec4 	movi	r6,1403
    4360:	01c000f4 	movhi	r7,3
    4364:	39fcdd04 	addi	r7,r7,-3212
    4368:	00193f00 	call	193f0 <printf>
    436c:	003fff06 	br	436c <dhcp_parse_reply+0x2f0>
        decode_idx = DHCP_OPTION_IDX_SUBNET_MASK;
    4370:	00800184 	movi	r2,6
    4374:	e0bff915 	stw	r2,-28(fp)
        break;
    4378:	00008e06 	br	45b4 <dhcp_parse_reply+0x538>
      case(DHCP_OPTION_ROUTER):
        decode_len = 4; /* only copy the first given router */
    437c:	00800104 	movi	r2,4
    4380:	e0bff845 	stb	r2,-31(fp)
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
    4384:	e0fff803 	ldbu	r3,-32(fp)
    4388:	e0bff843 	ldbu	r2,-31(fp)
    438c:	1880092e 	bgeu	r3,r2,43b4 <dhcp_parse_reply+0x338>
    4390:	010000f4 	movhi	r4,3
    4394:	213ccf04 	addi	r4,r4,-3268
    4398:	014000f4 	movhi	r5,3
    439c:	297d5404 	addi	r5,r5,-2736
    43a0:	01816004 	movi	r6,1408
    43a4:	01c000f4 	movhi	r7,3
    43a8:	39fcdd04 	addi	r7,r7,-3212
    43ac:	00193f00 	call	193f0 <printf>
    43b0:	003fff06 	br	43b0 <dhcp_parse_reply+0x334>
        decode_idx = DHCP_OPTION_IDX_ROUTER;
    43b4:	008001c4 	movi	r2,7
    43b8:	e0bff915 	stw	r2,-28(fp)
        break;
    43bc:	00007d06 	br	45b4 <dhcp_parse_reply+0x538>
      case(DHCP_OPTION_DNS_SERVER):
        /* special case: there might be more than one server */
        LWIP_ERROR("len % 4 == 0", len % 4 == 0, return ERR_VAL;);
    43c0:	e0bff803 	ldbu	r2,-32(fp)
    43c4:	108000cc 	andi	r2,r2,3
    43c8:	10803fcc 	andi	r2,r2,255
    43cc:	10000926 	beq	r2,zero,43f4 <dhcp_parse_reply+0x378>
    43d0:	010000f4 	movhi	r4,3
    43d4:	213ccf04 	addi	r4,r4,-3268
    43d8:	014000f4 	movhi	r5,3
    43dc:	297d5904 	addi	r5,r5,-2716
    43e0:	01816144 	movi	r6,1413
    43e4:	01c000f4 	movhi	r7,3
    43e8:	39fcdd04 	addi	r7,r7,-3212
    43ec:	00193f00 	call	193f0 <printf>
    43f0:	003fff06 	br	43f0 <dhcp_parse_reply+0x374>
        /* limit number of DNS servers */
        decode_len = LWIP_MIN(len, 4 * DNS_MAX_SERVERS);
    43f4:	e0bff803 	ldbu	r2,-32(fp)
    43f8:	10c03fcc 	andi	r3,r2,255
    43fc:	18c00270 	cmpltui	r3,r3,9
    4400:	1800011e 	bne	r3,zero,4408 <dhcp_parse_reply+0x38c>
    4404:	00800204 	movi	r2,8
    4408:	e0bff845 	stb	r2,-31(fp)
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
    440c:	e0fff803 	ldbu	r3,-32(fp)
    4410:	e0bff843 	ldbu	r2,-31(fp)
    4414:	1880092e 	bgeu	r3,r2,443c <dhcp_parse_reply+0x3c0>
    4418:	010000f4 	movhi	r4,3
    441c:	213ccf04 	addi	r4,r4,-3268
    4420:	014000f4 	movhi	r5,3
    4424:	297d5404 	addi	r5,r5,-2736
    4428:	01816204 	movi	r6,1416
    442c:	01c000f4 	movhi	r7,3
    4430:	39fcdd04 	addi	r7,r7,-3212
    4434:	00193f00 	call	193f0 <printf>
    4438:	003fff06 	br	4438 <dhcp_parse_reply+0x3bc>
        decode_idx = DHCP_OPTION_IDX_DNS_SERVER;
    443c:	00800204 	movi	r2,8
    4440:	e0bff915 	stw	r2,-28(fp)
        break;
    4444:	00005b06 	br	45b4 <dhcp_parse_reply+0x538>
      case(DHCP_OPTION_LEASE_TIME):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    4448:	e0bff803 	ldbu	r2,-32(fp)
    444c:	10800120 	cmpeqi	r2,r2,4
    4450:	1000091e 	bne	r2,zero,4478 <dhcp_parse_reply+0x3fc>
    4454:	010000f4 	movhi	r4,3
    4458:	213ccf04 	addi	r4,r4,-3268
    445c:	014000f4 	movhi	r5,3
    4460:	297d5104 	addi	r5,r5,-2748
    4464:	01816304 	movi	r6,1420
    4468:	01c000f4 	movhi	r7,3
    446c:	39fcdd04 	addi	r7,r7,-3212
    4470:	00193f00 	call	193f0 <printf>
    4474:	003fff06 	br	4474 <dhcp_parse_reply+0x3f8>
        decode_idx = DHCP_OPTION_IDX_LEASE_TIME;
    4478:	008000c4 	movi	r2,3
    447c:	e0bff915 	stw	r2,-28(fp)
        break;
    4480:	00004c06 	br	45b4 <dhcp_parse_reply+0x538>
      case(DHCP_OPTION_OVERLOAD):
        LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
    4484:	e0bff803 	ldbu	r2,-32(fp)
    4488:	10800060 	cmpeqi	r2,r2,1
    448c:	1000091e 	bne	r2,zero,44b4 <dhcp_parse_reply+0x438>
    4490:	010000f4 	movhi	r4,3
    4494:	213ccf04 	addi	r4,r4,-3268
    4498:	014000f4 	movhi	r5,3
    449c:	297d5d04 	addi	r5,r5,-2700
    44a0:	01816404 	movi	r6,1424
    44a4:	01c000f4 	movhi	r7,3
    44a8:	39fcdd04 	addi	r7,r7,-3212
    44ac:	00193f00 	call	193f0 <printf>
    44b0:	003fff06 	br	44b0 <dhcp_parse_reply+0x434>
        decode_idx = DHCP_OPTION_IDX_OVERLOAD;
    44b4:	e03ff915 	stw	zero,-28(fp)
        break;
    44b8:	00003e06 	br	45b4 <dhcp_parse_reply+0x538>
      case(DHCP_OPTION_MESSAGE_TYPE):
        LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
    44bc:	e0bff803 	ldbu	r2,-32(fp)
    44c0:	10800060 	cmpeqi	r2,r2,1
    44c4:	1000091e 	bne	r2,zero,44ec <dhcp_parse_reply+0x470>
    44c8:	010000f4 	movhi	r4,3
    44cc:	213ccf04 	addi	r4,r4,-3268
    44d0:	014000f4 	movhi	r5,3
    44d4:	297d5d04 	addi	r5,r5,-2700
    44d8:	01816504 	movi	r6,1428
    44dc:	01c000f4 	movhi	r7,3
    44e0:	39fcdd04 	addi	r7,r7,-3212
    44e4:	00193f00 	call	193f0 <printf>
    44e8:	003fff06 	br	44e8 <dhcp_parse_reply+0x46c>
        decode_idx = DHCP_OPTION_IDX_MSG_TYPE;
    44ec:	00800044 	movi	r2,1
    44f0:	e0bff915 	stw	r2,-28(fp)
        break;
    44f4:	00002f06 	br	45b4 <dhcp_parse_reply+0x538>
      case(DHCP_OPTION_SERVER_ID):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    44f8:	e0bff803 	ldbu	r2,-32(fp)
    44fc:	10800120 	cmpeqi	r2,r2,4
    4500:	1000091e 	bne	r2,zero,4528 <dhcp_parse_reply+0x4ac>
    4504:	010000f4 	movhi	r4,3
    4508:	213ccf04 	addi	r4,r4,-3268
    450c:	014000f4 	movhi	r5,3
    4510:	297d5104 	addi	r5,r5,-2748
    4514:	01816604 	movi	r6,1432
    4518:	01c000f4 	movhi	r7,3
    451c:	39fcdd04 	addi	r7,r7,-3212
    4520:	00193f00 	call	193f0 <printf>
    4524:	003fff06 	br	4524 <dhcp_parse_reply+0x4a8>
        decode_idx = DHCP_OPTION_IDX_SERVER_ID;
    4528:	00800084 	movi	r2,2
    452c:	e0bff915 	stw	r2,-28(fp)
        break;
    4530:	00002006 	br	45b4 <dhcp_parse_reply+0x538>
      case(DHCP_OPTION_T1):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    4534:	e0bff803 	ldbu	r2,-32(fp)
    4538:	10800120 	cmpeqi	r2,r2,4
    453c:	1000091e 	bne	r2,zero,4564 <dhcp_parse_reply+0x4e8>
    4540:	010000f4 	movhi	r4,3
    4544:	213ccf04 	addi	r4,r4,-3268
    4548:	014000f4 	movhi	r5,3
    454c:	297d5104 	addi	r5,r5,-2748
    4550:	01816704 	movi	r6,1436
    4554:	01c000f4 	movhi	r7,3
    4558:	39fcdd04 	addi	r7,r7,-3212
    455c:	00193f00 	call	193f0 <printf>
    4560:	003fff06 	br	4560 <dhcp_parse_reply+0x4e4>
        decode_idx = DHCP_OPTION_IDX_T1;
    4564:	00800104 	movi	r2,4
    4568:	e0bff915 	stw	r2,-28(fp)
        break;
    456c:	00001106 	br	45b4 <dhcp_parse_reply+0x538>
      case(DHCP_OPTION_T2):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    4570:	e0bff803 	ldbu	r2,-32(fp)
    4574:	10800120 	cmpeqi	r2,r2,4
    4578:	1000091e 	bne	r2,zero,45a0 <dhcp_parse_reply+0x524>
    457c:	010000f4 	movhi	r4,3
    4580:	213ccf04 	addi	r4,r4,-3268
    4584:	014000f4 	movhi	r5,3
    4588:	297d5104 	addi	r5,r5,-2748
    458c:	01816804 	movi	r6,1440
    4590:	01c000f4 	movhi	r7,3
    4594:	39fcdd04 	addi	r7,r7,-3212
    4598:	00193f00 	call	193f0 <printf>
    459c:	003fff06 	br	459c <dhcp_parse_reply+0x520>
        decode_idx = DHCP_OPTION_IDX_T2;
    45a0:	00800144 	movi	r2,5
    45a4:	e0bff915 	stw	r2,-28(fp)
        break;
    45a8:	00000206 	br	45b4 <dhcp_parse_reply+0x538>
      default:
        decode_len = 0;
    45ac:	e03ff845 	stb	zero,-31(fp)
        LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", op));
        break;
    45b0:	0001883a 	nop
    }
    offset += len + 2;
    45b4:	e0fff803 	ldbu	r3,-32(fp)
    45b8:	e0bff30b 	ldhu	r2,-52(fp)
    45bc:	1885883a 	add	r2,r3,r2
    45c0:	10800084 	addi	r2,r2,2
    45c4:	e0bff30d 	sth	r2,-52(fp)
    if (decode_len > 0) {
    45c8:	e0bff843 	ldbu	r2,-31(fp)
    45cc:	10008826 	beq	r2,zero,47f0 <dhcp_parse_reply+0x774>
      u32_t value = 0;
    45d0:	e03ffd15 	stw	zero,-12(fp)
      u16_t copy_len;
decode_next:
      LWIP_ASSERT("check decode_idx", decode_idx >= 0 && decode_idx < DHCP_OPTION_IDX_MAX);
    45d4:	e0bff917 	ldw	r2,-28(fp)
    45d8:	10000316 	blt	r2,zero,45e8 <dhcp_parse_reply+0x56c>
    45dc:	e0bff917 	ldw	r2,-28(fp)
    45e0:	10800290 	cmplti	r2,r2,10
    45e4:	1000091e 	bne	r2,zero,460c <dhcp_parse_reply+0x590>
    45e8:	010000f4 	movhi	r4,3
    45ec:	213ccf04 	addi	r4,r4,-3268
    45f0:	014000f4 	movhi	r5,3
    45f4:	297d6004 	addi	r5,r5,-2688
    45f8:	01816b44 	movi	r6,1453
    45fc:	01c000f4 	movhi	r7,3
    4600:	39fcdd04 	addi	r7,r7,-3212
    4604:	00193f00 	call	193f0 <printf>
    4608:	003fff06 	br	4608 <dhcp_parse_reply+0x58c>
      if (!dhcp_option_given(dhcp, decode_idx)) {
    460c:	00c00234 	movhi	r3,8
    4610:	18c21b04 	addi	r3,r3,2156
    4614:	e0bff917 	ldw	r2,-28(fp)
    4618:	1885883a 	add	r2,r3,r2
    461c:	10800003 	ldbu	r2,0(r2)
    4620:	10803fcc 	andi	r2,r2,255
    4624:	1000721e 	bne	r2,zero,47f0 <dhcp_parse_reply+0x774>
        copy_len = LWIP_MIN(decode_len, 4);
    4628:	e0bff843 	ldbu	r2,-31(fp)
    462c:	10800128 	cmpgeui	r2,r2,4
    4630:	1000021e 	bne	r2,zero,463c <dhcp_parse_reply+0x5c0>
    4634:	e0bff843 	ldbu	r2,-31(fp)
    4638:	00000106 	br	4640 <dhcp_parse_reply+0x5c4>
    463c:	00800104 	movi	r2,4
    4640:	e0bffb0d 	sth	r2,-20(fp)
        pbuf_copy_partial(q, &value, copy_len, val_offset);
    4644:	e0fffb0b 	ldhu	r3,-20(fp)
    4648:	e0bffa0b 	ldhu	r2,-24(fp)
    464c:	e17ffd04 	addi	r5,fp,-12
    4650:	e13ff517 	ldw	r4,-44(fp)
    4654:	180d883a 	mov	r6,r3
    4658:	100f883a 	mov	r7,r2
    465c:	000b2040 	call	b204 <pbuf_copy_partial>
        if (decode_len > 4) {
    4660:	e0bff843 	ldbu	r2,-31(fp)
    4664:	10800170 	cmpltui	r2,r2,5
    4668:	1000311e 	bne	r2,zero,4730 <dhcp_parse_reply+0x6b4>
          /* decode more than one u32_t */
          LWIP_ERROR("decode_len % 4 == 0", decode_len % 4 == 0, return ERR_VAL;);
    466c:	e0bff843 	ldbu	r2,-31(fp)
    4670:	108000cc 	andi	r2,r2,3
    4674:	10803fcc 	andi	r2,r2,255
    4678:	10000926 	beq	r2,zero,46a0 <dhcp_parse_reply+0x624>
    467c:	010000f4 	movhi	r4,3
    4680:	213ccf04 	addi	r4,r4,-3268
    4684:	014000f4 	movhi	r5,3
    4688:	297d6504 	addi	r5,r5,-2668
    468c:	01816cc4 	movi	r6,1459
    4690:	01c000f4 	movhi	r7,3
    4694:	39fcdd04 	addi	r7,r7,-3212
    4698:	00193f00 	call	193f0 <printf>
    469c:	003fff06 	br	469c <dhcp_parse_reply+0x620>
          dhcp_got_option(dhcp, decode_idx);
    46a0:	00c00234 	movhi	r3,8
    46a4:	18c21b04 	addi	r3,r3,2156
    46a8:	e0bff917 	ldw	r2,-28(fp)
    46ac:	1885883a 	add	r2,r3,r2
    46b0:	00c00044 	movi	r3,1
    46b4:	10c00005 	stb	r3,0(r2)
          dhcp_set_option_value(dhcp, decode_idx, htonl(value));
    46b8:	e0bffd17 	ldw	r2,-12(fp)
    46bc:	1006d63a 	srli	r3,r2,24
    46c0:	e0bffd17 	ldw	r2,-12(fp)
    46c4:	1004d23a 	srli	r2,r2,8
    46c8:	10bfc00c 	andi	r2,r2,65280
    46cc:	1886b03a 	or	r3,r3,r2
    46d0:	e0bffd17 	ldw	r2,-12(fp)
    46d4:	10bfc00c 	andi	r2,r2,65280
    46d8:	1004923a 	slli	r2,r2,8
    46dc:	1886b03a 	or	r3,r3,r2
    46e0:	e0bffd17 	ldw	r2,-12(fp)
    46e4:	1004963a 	slli	r2,r2,24
    46e8:	1886b03a 	or	r3,r3,r2
    46ec:	01000234 	movhi	r4,8
    46f0:	21021e04 	addi	r4,r4,2168
    46f4:	e0bff917 	ldw	r2,-28(fp)
    46f8:	1085883a 	add	r2,r2,r2
    46fc:	1085883a 	add	r2,r2,r2
    4700:	2085883a 	add	r2,r4,r2
    4704:	10c00015 	stw	r3,0(r2)
          decode_len -= 4;
    4708:	e0bff843 	ldbu	r2,-31(fp)
    470c:	10bfff04 	addi	r2,r2,-4
    4710:	e0bff845 	stb	r2,-31(fp)
          val_offset += 4;
    4714:	e0bffa0b 	ldhu	r2,-24(fp)
    4718:	10800104 	addi	r2,r2,4
    471c:	e0bffa0d 	sth	r2,-24(fp)
          decode_idx++;
    4720:	e0bff917 	ldw	r2,-28(fp)
    4724:	10800044 	addi	r2,r2,1
    4728:	e0bff915 	stw	r2,-28(fp)
          goto decode_next;
    472c:	003fa906 	br	45d4 <dhcp_parse_reply+0x558>
        } else if (decode_len == 4) {
    4730:	e0bff843 	ldbu	r2,-31(fp)
    4734:	10800118 	cmpnei	r2,r2,4
    4738:	10000f1e 	bne	r2,zero,4778 <dhcp_parse_reply+0x6fc>
          value = ntohl(value);
    473c:	e0bffd17 	ldw	r2,-12(fp)
    4740:	1006d63a 	srli	r3,r2,24
    4744:	e0bffd17 	ldw	r2,-12(fp)
    4748:	1004d23a 	srli	r2,r2,8
    474c:	10bfc00c 	andi	r2,r2,65280
    4750:	1886b03a 	or	r3,r3,r2
    4754:	e0bffd17 	ldw	r2,-12(fp)
    4758:	10bfc00c 	andi	r2,r2,65280
    475c:	1004923a 	slli	r2,r2,8
    4760:	1886b03a 	or	r3,r3,r2
    4764:	e0bffd17 	ldw	r2,-12(fp)
    4768:	1004963a 	slli	r2,r2,24
    476c:	1884b03a 	or	r2,r3,r2
    4770:	e0bffd15 	stw	r2,-12(fp)
    4774:	00001006 	br	47b8 <dhcp_parse_reply+0x73c>
        } else {
          LWIP_ERROR("invalid decode_len", decode_len == 1, return ERR_VAL;);
    4778:	e0bff843 	ldbu	r2,-31(fp)
    477c:	10800060 	cmpeqi	r2,r2,1
    4780:	1000091e 	bne	r2,zero,47a8 <dhcp_parse_reply+0x72c>
    4784:	010000f4 	movhi	r4,3
    4788:	213ccf04 	addi	r4,r4,-3268
    478c:	014000f4 	movhi	r5,3
    4790:	297d6a04 	addi	r5,r5,-2648
    4794:	01816f44 	movi	r6,1469
    4798:	01c000f4 	movhi	r7,3
    479c:	39fcdd04 	addi	r7,r7,-3212
    47a0:	00193f00 	call	193f0 <printf>
    47a4:	003fff06 	br	47a4 <dhcp_parse_reply+0x728>
          value = ((u8_t*)&value)[0];
    47a8:	e0bffd04 	addi	r2,fp,-12
    47ac:	10800003 	ldbu	r2,0(r2)
    47b0:	10803fcc 	andi	r2,r2,255
    47b4:	e0bffd15 	stw	r2,-12(fp)
        }
        dhcp_got_option(dhcp, decode_idx);
    47b8:	00c00234 	movhi	r3,8
    47bc:	18c21b04 	addi	r3,r3,2156
    47c0:	e0bff917 	ldw	r2,-28(fp)
    47c4:	1885883a 	add	r2,r3,r2
    47c8:	00c00044 	movi	r3,1
    47cc:	10c00005 	stb	r3,0(r2)
        dhcp_set_option_value(dhcp, decode_idx, value);
    47d0:	e0fffd17 	ldw	r3,-12(fp)
    47d4:	01000234 	movhi	r4,8
    47d8:	21021e04 	addi	r4,r4,2168
    47dc:	e0bff917 	ldw	r2,-28(fp)
    47e0:	1085883a 	add	r2,r2,r2
    47e4:	1085883a 	add	r2,r2,r2
    47e8:	2085883a 	add	r2,r4,r2
    47ec:	10c00015 	stw	r3,0(r2)
      }
    }
    if (offset >= q->len) {
    47f0:	e0bff517 	ldw	r2,-44(fp)
    47f4:	1080028b 	ldhu	r2,10(r2)
    47f8:	10bfffcc 	andi	r2,r2,65535
    47fc:	e0fff30b 	ldhu	r3,-52(fp)
    4800:	18802036 	bltu	r3,r2,4884 <dhcp_parse_reply+0x808>
      offset -= q->len;
    4804:	e0bff517 	ldw	r2,-44(fp)
    4808:	1080028b 	ldhu	r2,10(r2)
    480c:	e0fff30b 	ldhu	r3,-52(fp)
    4810:	1885c83a 	sub	r2,r3,r2
    4814:	e0bff30d 	sth	r2,-52(fp)
      offset_max -= q->len;
    4818:	e0bff517 	ldw	r2,-44(fp)
    481c:	1080028b 	ldhu	r2,10(r2)
    4820:	e0fff38b 	ldhu	r3,-50(fp)
    4824:	1885c83a 	sub	r2,r3,r2
    4828:	e0bff38d 	sth	r2,-50(fp)
      if ((offset < offset_max) && offset_max) {
    482c:	e0fff30b 	ldhu	r3,-52(fp)
    4830:	e0bff38b 	ldhu	r2,-50(fp)
    4834:	18801f2e 	bgeu	r3,r2,48b4 <dhcp_parse_reply+0x838>
    4838:	e0bff38b 	ldhu	r2,-50(fp)
    483c:	10001d26 	beq	r2,zero,48b4 <dhcp_parse_reply+0x838>
        q = q->next;
    4840:	e0bff517 	ldw	r2,-44(fp)
    4844:	10800017 	ldw	r2,0(r2)
    4848:	e0bff515 	stw	r2,-44(fp)
        LWIP_ASSERT("next pbuf was null", q);
    484c:	e0bff517 	ldw	r2,-44(fp)
    4850:	1000091e 	bne	r2,zero,4878 <dhcp_parse_reply+0x7fc>
    4854:	010000f4 	movhi	r4,3
    4858:	213ccf04 	addi	r4,r4,-3268
    485c:	014000f4 	movhi	r5,3
    4860:	297d6f04 	addi	r5,r5,-2628
    4864:	01817244 	movi	r6,1481
    4868:	01c000f4 	movhi	r7,3
    486c:	39fcdd04 	addi	r7,r7,-3212
    4870:	00193f00 	call	193f0 <printf>
    4874:	003fff06 	br	4874 <dhcp_parse_reply+0x7f8>
        options = (u8_t*)q->payload;
    4878:	e0bff517 	ldw	r2,-44(fp)
    487c:	10800117 	ldw	r2,4(r2)
    4880:	e0bff215 	stw	r2,-56(fp)
  }
  offset = options_idx;
  offset_max = options_idx_max;
  options = (u8_t*)q->payload;
  /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
  while((q != NULL) && (options[offset] != DHCP_OPTION_END) && (offset < offset_max)) {
    4884:	e0bff517 	ldw	r2,-44(fp)
    4888:	10000a26 	beq	r2,zero,48b4 <dhcp_parse_reply+0x838>
    488c:	e0bff30b 	ldhu	r2,-52(fp)
    4890:	e0fff217 	ldw	r3,-56(fp)
    4894:	1885883a 	add	r2,r3,r2
    4898:	10800003 	ldbu	r2,0(r2)
    489c:	10803fcc 	andi	r2,r2,255
    48a0:	10803fe0 	cmpeqi	r2,r2,255
    48a4:	1000031e 	bne	r2,zero,48b4 <dhcp_parse_reply+0x838>
    48a8:	e0fff30b 	ldhu	r3,-52(fp)
    48ac:	e0bff38b 	ldhu	r2,-50(fp)
    48b0:	18be3236 	bltu	r3,r2,417c <dhcp_parse_reply+0x100>
        break;
      }
    }
  }
  /* is this an overloaded message? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_OVERLOAD)) {
    48b4:	00800234 	movhi	r2,8
    48b8:	10821b04 	addi	r2,r2,2156
    48bc:	10800003 	ldbu	r2,0(r2)
    48c0:	10803fcc 	andi	r2,r2,255
    48c4:	10001a26 	beq	r2,zero,4930 <dhcp_parse_reply+0x8b4>
    u32_t overload = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_OVERLOAD);
    48c8:	00800234 	movhi	r2,8
    48cc:	10821e04 	addi	r2,r2,2168
    48d0:	10800017 	ldw	r2,0(r2)
    48d4:	e0bffc15 	stw	r2,-16(fp)
    dhcp_clear_option(dhcp, DHCP_OPTION_IDX_OVERLOAD);
    48d8:	00800234 	movhi	r2,8
    48dc:	10821b04 	addi	r2,r2,2156
    48e0:	10000005 	stb	zero,0(r2)
    if (overload == DHCP_OVERLOAD_FILE) {
    48e4:	e0bffc17 	ldw	r2,-16(fp)
    48e8:	10800058 	cmpnei	r2,r2,1
    48ec:	1000031e 	bne	r2,zero,48fc <dhcp_parse_reply+0x880>
      parse_file_as_options = 1;
    48f0:	00800044 	movi	r2,1
    48f4:	e0bff615 	stw	r2,-40(fp)
    48f8:	00000d06 	br	4930 <dhcp_parse_reply+0x8b4>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded file field\n"));
    } else if (overload == DHCP_OVERLOAD_SNAME) {
    48fc:	e0bffc17 	ldw	r2,-16(fp)
    4900:	10800098 	cmpnei	r2,r2,2
    4904:	1000031e 	bne	r2,zero,4914 <dhcp_parse_reply+0x898>
      parse_sname_as_options = 1;
    4908:	00800044 	movi	r2,1
    490c:	e0bff715 	stw	r2,-36(fp)
    4910:	00000706 	br	4930 <dhcp_parse_reply+0x8b4>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded sname field\n"));
    } else if (overload == DHCP_OVERLOAD_SNAME_FILE) {
    4914:	e0bffc17 	ldw	r2,-16(fp)
    4918:	108000d8 	cmpnei	r2,r2,3
    491c:	1000041e 	bne	r2,zero,4930 <dhcp_parse_reply+0x8b4>
      parse_sname_as_options = 1;
    4920:	00800044 	movi	r2,1
    4924:	e0bff715 	stw	r2,-36(fp)
      parse_file_as_options = 1;
    4928:	00800044 	movi	r2,1
    492c:	e0bff615 	stw	r2,-40(fp)
      /* make sure the string is really NULL-terminated */
      dhcp->boot_file_name[DHCP_FILE_LEN-1] = 0;
    }
#endif /* LWIP_DHCP_BOOTP_FILE */
  }
  if (parse_file_as_options) {
    4930:	e0bff617 	ldw	r2,-40(fp)
    4934:	10000626 	beq	r2,zero,4950 <dhcp_parse_reply+0x8d4>
    /* if both are overloaded, parse file first and then sname (RFC 2131 ch. 4.1) */
    parse_file_as_options = 0;
    4938:	e03ff615 	stw	zero,-40(fp)
    options_idx = DHCP_FILE_OFS;
    493c:	00801b04 	movi	r2,108
    4940:	e0bff40d 	sth	r2,-48(fp)
    options_idx_max = DHCP_FILE_OFS + DHCP_FILE_LEN;
    4944:	00803b04 	movi	r2,236
    4948:	e0bff48d 	sth	r2,-46(fp)
    goto again;
    494c:	003de806 	br	40f0 <dhcp_parse_reply+0x74>
  } else if (parse_sname_as_options) {
    4950:	e0bff717 	ldw	r2,-36(fp)
    4954:	10000626 	beq	r2,zero,4970 <dhcp_parse_reply+0x8f4>
    parse_sname_as_options = 0;
    4958:	e03ff715 	stw	zero,-36(fp)
    options_idx = DHCP_SNAME_OFS;
    495c:	00800b04 	movi	r2,44
    4960:	e0bff40d 	sth	r2,-48(fp)
    options_idx_max = DHCP_SNAME_OFS + DHCP_SNAME_LEN;
    4964:	00801b04 	movi	r2,108
    4968:	e0bff48d 	sth	r2,-46(fp)
    goto again;
    496c:	003de006 	br	40f0 <dhcp_parse_reply+0x74>
  }
  return ERR_OK;
    4970:	0005883a 	mov	r2,zero
}
    4974:	e037883a 	mov	sp,fp
    4978:	dfc00117 	ldw	ra,4(sp)
    497c:	df000017 	ldw	fp,0(sp)
    4980:	dec00204 	addi	sp,sp,8
    4984:	f800283a 	ret

00004988 <dhcp_recv>:
/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void
dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *addr, u16_t port)
{
    4988:	defff404 	addi	sp,sp,-48
    498c:	dfc00b15 	stw	ra,44(sp)
    4990:	df000a15 	stw	fp,40(sp)
    4994:	df000a04 	addi	fp,sp,40
    4998:	e13ffb15 	stw	r4,-20(fp)
    499c:	e17ffc15 	stw	r5,-16(fp)
    49a0:	e1bffd15 	stw	r6,-12(fp)
    49a4:	e1fffe15 	stw	r7,-8(fp)
    49a8:	e0800217 	ldw	r2,8(fp)
    49ac:	e0bfff0d 	sth	r2,-4(fp)
  struct netif *netif = (struct netif *)arg;
    49b0:	e0bffb17 	ldw	r2,-20(fp)
    49b4:	e0bff715 	stw	r2,-36(fp)
  struct dhcp *dhcp = netif->dhcp;
    49b8:	e0bff717 	ldw	r2,-36(fp)
    49bc:	10800817 	ldw	r2,32(r2)
    49c0:	e0bff815 	stw	r2,-32(fp)
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
    49c4:	e0bffd17 	ldw	r2,-12(fp)
    49c8:	10800117 	ldw	r2,4(r2)
    49cc:	e0bff915 	stw	r2,-28(fp)
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);

  LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL);
    49d0:	e0bff817 	ldw	r2,-32(fp)
    49d4:	10800217 	ldw	r2,8(r2)
    49d8:	10000926 	beq	r2,zero,4a00 <dhcp_recv+0x78>
    49dc:	010000f4 	movhi	r4,3
    49e0:	213ccf04 	addi	r4,r4,-3268
    49e4:	014000f4 	movhi	r5,3
    49e8:	297cf604 	addi	r5,r5,-3112
    49ec:	01818444 	movi	r6,1553
    49f0:	01c000f4 	movhi	r7,3
    49f4:	39fcdd04 	addi	r7,r7,-3212
    49f8:	00193f00 	call	193f0 <printf>
    49fc:	003fff06 	br	49fc <dhcp_recv+0x74>

  if (p->len < DHCP_MIN_REPLY_LEN) {
    4a00:	e0bffd17 	ldw	r2,-12(fp)
    4a04:	1080028b 	ldhu	r2,10(r2)
    4a08:	10bfffcc 	andi	r2,r2,65535
    4a0c:	10800b28 	cmpgeui	r2,r2,44
    4a10:	10009226 	beq	r2,zero,4c5c <dhcp_recv+0x2d4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP reply message or pbuf too short\n"));
    goto free_pbuf_and_return;
  }

  if (reply_msg->op != DHCP_BOOTREPLY) {
    4a14:	e0bff917 	ldw	r2,-28(fp)
    4a18:	10800003 	ldbu	r2,0(r2)
    4a1c:	10803fcc 	andi	r2,r2,255
    4a20:	108000a0 	cmpeqi	r2,r2,2
    4a24:	10008f26 	beq	r2,zero,4c64 <dhcp_recv+0x2dc>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
    4a28:	e03ff605 	stb	zero,-40(fp)
    4a2c:	00001006 	br	4a70 <dhcp_recv+0xe8>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
    4a30:	e0bff603 	ldbu	r2,-40(fp)
    4a34:	e0fff717 	ldw	r3,-36(fp)
    4a38:	1885883a 	add	r2,r3,r2
    4a3c:	10800904 	addi	r2,r2,36
    4a40:	10c000c3 	ldbu	r3,3(r2)
    4a44:	e0bff603 	ldbu	r2,-40(fp)
    4a48:	e13ff917 	ldw	r4,-28(fp)
    4a4c:	2085883a 	add	r2,r4,r2
    4a50:	10800704 	addi	r2,r2,28
    4a54:	10800003 	ldbu	r2,0(r2)
    4a58:	18c03fcc 	andi	r3,r3,255
    4a5c:	10803fcc 	andi	r2,r2,255
    4a60:	1880821e 	bne	r3,r2,4c6c <dhcp_recv+0x2e4>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
    4a64:	e0bff603 	ldbu	r2,-40(fp)
    4a68:	10800044 	addi	r2,r2,1
    4a6c:	e0bff605 	stb	r2,-40(fp)
    4a70:	e0bff717 	ldw	r2,-36(fp)
    4a74:	10800983 	ldbu	r2,38(r2)
    4a78:	10803fcc 	andi	r2,r2,255
    4a7c:	e0fff603 	ldbu	r3,-40(fp)
    4a80:	18bfeb36 	bltu	r3,r2,4a30 <dhcp_recv+0xa8>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
    4a84:	e0bff917 	ldw	r2,-28(fp)
    4a88:	10c0010b 	ldhu	r3,4(r2)
    4a8c:	1080018b 	ldhu	r2,6(r2)
    4a90:	1004943a 	slli	r2,r2,16
    4a94:	10c4b03a 	or	r2,r2,r3
    4a98:	1006d63a 	srli	r3,r2,24
    4a9c:	e0bff917 	ldw	r2,-28(fp)
    4aa0:	1100010b 	ldhu	r4,4(r2)
    4aa4:	1080018b 	ldhu	r2,6(r2)
    4aa8:	1004943a 	slli	r2,r2,16
    4aac:	1104b03a 	or	r2,r2,r4
    4ab0:	1004d23a 	srli	r2,r2,8
    4ab4:	10bfc00c 	andi	r2,r2,65280
    4ab8:	1886b03a 	or	r3,r3,r2
    4abc:	e0bff917 	ldw	r2,-28(fp)
    4ac0:	1100010b 	ldhu	r4,4(r2)
    4ac4:	1080018b 	ldhu	r2,6(r2)
    4ac8:	1004943a 	slli	r2,r2,16
    4acc:	1104b03a 	or	r2,r2,r4
    4ad0:	10bfc00c 	andi	r2,r2,65280
    4ad4:	1004923a 	slli	r2,r2,8
    4ad8:	1886b03a 	or	r3,r3,r2
    4adc:	e0bff917 	ldw	r2,-28(fp)
    4ae0:	1100010b 	ldhu	r4,4(r2)
    4ae4:	1080018b 	ldhu	r2,6(r2)
    4ae8:	1004943a 	slli	r2,r2,16
    4aec:	1104b03a 	or	r2,r2,r4
    4af0:	1004963a 	slli	r2,r2,24
    4af4:	1886b03a 	or	r3,r3,r2
    4af8:	e0bff817 	ldw	r2,-32(fp)
    4afc:	10800017 	ldw	r2,0(r2)
    4b00:	18805c1e 	bne	r3,r2,4c74 <dhcp_recv+0x2ec>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n",ntohl(reply_msg->xid),dhcp->xid));
    goto free_pbuf_and_return;
  }
  /* option fields could be unfold? */
  if (dhcp_parse_reply(dhcp, p) != ERR_OK) {
    4b04:	e13ff817 	ldw	r4,-32(fp)
    4b08:	e17ffd17 	ldw	r5,-12(fp)
    4b0c:	000407c0 	call	407c <dhcp_parse_reply>
    4b10:	10803fcc 	andi	r2,r2,255
    4b14:	1080201c 	xori	r2,r2,128
    4b18:	10bfe004 	addi	r2,r2,-128
    4b1c:	1000571e 	bne	r2,zero,4c7c <dhcp_recv+0x2f4>
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  if (!dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE)) {
    4b20:	00800234 	movhi	r2,8
    4b24:	10821b04 	addi	r2,r2,2156
    4b28:	10800043 	ldbu	r2,1(r2)
    4b2c:	10803fcc 	andi	r2,r2,255
    4b30:	10005426 	beq	r2,zero,4c84 <dhcp_recv+0x2fc>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  }

  /* read DHCP message type */
  msg_type = (u8_t)dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_MSG_TYPE);
    4b34:	00800234 	movhi	r2,8
    4b38:	10821e04 	addi	r2,r2,2168
    4b3c:	10800117 	ldw	r2,4(r2)
    4b40:	e0bffa05 	stb	r2,-24(fp)
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
    4b44:	e0bffa03 	ldbu	r2,-24(fp)
    4b48:	10800158 	cmpnei	r2,r2,5
    4b4c:	10001c1e 	bne	r2,zero,4bc0 <dhcp_recv+0x238>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
    4b50:	e0bff817 	ldw	r2,-32(fp)
    4b54:	10800303 	ldbu	r2,12(r2)
    4b58:	10803fcc 	andi	r2,r2,255
    4b5c:	10800058 	cmpnei	r2,r2,1
    4b60:	1000051e 	bne	r2,zero,4b78 <dhcp_recv+0x1f0>
      dhcp_handle_ack(netif);
    4b64:	e13ff717 	ldw	r4,-36(fp)
    4b68:	00027b00 	call	27b0 <dhcp_handle_ack>
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
    4b6c:	e13ff717 	ldw	r4,-36(fp)
    4b70:	00020000 	call	2000 <dhcp_check>
    4b74:	00004406 	br	4c88 <dhcp_recv+0x300>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
    4b78:	e0bff817 	ldw	r2,-32(fp)
    4b7c:	10800303 	ldbu	r2,12(r2)
    4b80:	10803fcc 	andi	r2,r2,255
    4b84:	108000e0 	cmpeqi	r2,r2,3
    4b88:	10000a1e 	bne	r2,zero,4bb4 <dhcp_recv+0x22c>
    4b8c:	e0bff817 	ldw	r2,-32(fp)
    4b90:	10800303 	ldbu	r2,12(r2)
    4b94:	10803fcc 	andi	r2,r2,255
    4b98:	10800120 	cmpeqi	r2,r2,4
    4b9c:	1000051e 	bne	r2,zero,4bb4 <dhcp_recv+0x22c>
    4ba0:	e0bff817 	ldw	r2,-32(fp)
    4ba4:	10800303 	ldbu	r2,12(r2)
    4ba8:	10803fcc 	andi	r2,r2,255
    4bac:	10800158 	cmpnei	r2,r2,5
    4bb0:	1000351e 	bne	r2,zero,4c88 <dhcp_recv+0x300>
      dhcp_bind(netif);
    4bb4:	e13ff717 	ldw	r4,-36(fp)
    4bb8:	00033300 	call	3330 <dhcp_bind>
    4bbc:	00003206 	br	4c88 <dhcp_recv+0x300>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
    4bc0:	e0bffa03 	ldbu	r2,-24(fp)
    4bc4:	10800198 	cmpnei	r2,r2,6
    4bc8:	1000171e 	bne	r2,zero,4c28 <dhcp_recv+0x2a0>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
    4bcc:	e0bff817 	ldw	r2,-32(fp)
    4bd0:	10800303 	ldbu	r2,12(r2)
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
    4bd4:	10803fcc 	andi	r2,r2,255
    4bd8:	108000e0 	cmpeqi	r2,r2,3
    4bdc:	10000f1e 	bne	r2,zero,4c1c <dhcp_recv+0x294>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
    4be0:	e0bff817 	ldw	r2,-32(fp)
    4be4:	10800303 	ldbu	r2,12(r2)
    4be8:	10803fcc 	andi	r2,r2,255
    4bec:	10800060 	cmpeqi	r2,r2,1
    4bf0:	10000a1e 	bne	r2,zero,4c1c <dhcp_recv+0x294>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
    4bf4:	e0bff817 	ldw	r2,-32(fp)
    4bf8:	10800303 	ldbu	r2,12(r2)
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
    4bfc:	10803fcc 	andi	r2,r2,255
    4c00:	10800120 	cmpeqi	r2,r2,4
    4c04:	1000051e 	bne	r2,zero,4c1c <dhcp_recv+0x294>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
    4c08:	e0bff817 	ldw	r2,-32(fp)
    4c0c:	10800303 	ldbu	r2,12(r2)
    4c10:	10803fcc 	andi	r2,r2,255
    4c14:	10800158 	cmpnei	r2,r2,5
    4c18:	1000031e 	bne	r2,zero,4c28 <dhcp_recv+0x2a0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_NAK received\n"));
    dhcp_handle_nak(netif);
    4c1c:	e13ff717 	ldw	r4,-36(fp)
    4c20:	0001f800 	call	1f80 <dhcp_handle_nak>
    4c24:	00001806 	br	4c88 <dhcp_recv+0x300>
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
    4c28:	e0bffa03 	ldbu	r2,-24(fp)
    4c2c:	10800098 	cmpnei	r2,r2,2
    4c30:	1000151e 	bne	r2,zero,4c88 <dhcp_recv+0x300>
    4c34:	e0bff817 	ldw	r2,-32(fp)
    4c38:	10800303 	ldbu	r2,12(r2)
    4c3c:	10803fcc 	andi	r2,r2,255
    4c40:	10800198 	cmpnei	r2,r2,6
    4c44:	1000101e 	bne	r2,zero,4c88 <dhcp_recv+0x300>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
    4c48:	e0bff817 	ldw	r2,-32(fp)
    4c4c:	1000068d 	sth	zero,26(r2)
    /* remember offered lease */
    dhcp_handle_offer(netif);
    4c50:	e13ff717 	ldw	r4,-36(fp)
    4c54:	00020980 	call	2098 <dhcp_handle_offer>
    4c58:	00000b06 	br	4c88 <dhcp_recv+0x300>

  LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL);

  if (p->len < DHCP_MIN_REPLY_LEN) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP reply message or pbuf too short\n"));
    goto free_pbuf_and_return;
    4c5c:	0001883a 	nop
    4c60:	00000906 	br	4c88 <dhcp_recv+0x300>
  }

  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
    4c64:	0001883a 	nop
    4c68:	00000706 	br	4c88 <dhcp_recv+0x300>
  for (i = 0; i < netif->hwaddr_len; i++) {
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
        ("netif->hwaddr[%"U16_F"]==%02"X16_F" != reply_msg->chaddr[%"U16_F"]==%02"X16_F"\n",
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    4c6c:	0001883a 	nop
    4c70:	00000506 	br	4c88 <dhcp_recv+0x300>
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n",ntohl(reply_msg->xid),dhcp->xid));
    goto free_pbuf_and_return;
    4c74:	0001883a 	nop
    4c78:	00000306 	br	4c88 <dhcp_recv+0x300>
  }
  /* option fields could be unfold? */
  if (dhcp_parse_reply(dhcp, p) != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("problem unfolding DHCP message - too short on memory?\n"));
    goto free_pbuf_and_return;
    4c7c:	0001883a 	nop
    4c80:	00000106 	br	4c88 <dhcp_recv+0x300>

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  if (!dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE)) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
    4c84:	0001883a 	nop
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  dhcp->msg_in = NULL;
    4c88:	e0bff817 	ldw	r2,-32(fp)
    4c8c:	10000215 	stw	zero,8(r2)
  pbuf_free(p);
    4c90:	e13ffd17 	ldw	r4,-12(fp)
    4c94:	000aa340 	call	aa34 <pbuf_free>
}
    4c98:	e037883a 	mov	sp,fp
    4c9c:	dfc00117 	ldw	ra,4(sp)
    4ca0:	df000017 	ldw	fp,0(sp)
    4ca4:	dec00204 	addi	sp,sp,8
    4ca8:	f800283a 	ret

00004cac <dhcp_create_msg>:
 * @param dhcp dhcp control struct
 * @param message_type message type of the request
 */
static err_t
dhcp_create_msg(struct netif *netif, struct dhcp *dhcp, u8_t message_type)
{
    4cac:	defffa04 	addi	sp,sp,-24
    4cb0:	dfc00515 	stw	ra,20(sp)
    4cb4:	df000415 	stw	fp,16(sp)
    4cb8:	df000404 	addi	fp,sp,16
    4cbc:	e13ffd15 	stw	r4,-12(fp)
    4cc0:	e17ffe15 	stw	r5,-8(fp)
    4cc4:	3005883a 	mov	r2,r6
    4cc8:	e0bfff05 	stb	r2,-4(fp)
  if (!xid_initialised) {
    xid = DHCP_GLOBAL_XID;
    xid_initialised = !xid_initialised;
  }
#endif
  LWIP_ERROR("dhcp_create_msg: netif != NULL", (netif != NULL), return ERR_ARG;);
    4ccc:	e0bffd17 	ldw	r2,-12(fp)
    4cd0:	1000091e 	bne	r2,zero,4cf8 <dhcp_create_msg+0x4c>
    4cd4:	010000f4 	movhi	r4,3
    4cd8:	213ccf04 	addi	r4,r4,-3268
    4cdc:	014000f4 	movhi	r5,3
    4ce0:	297d7404 	addi	r5,r5,-2608
    4ce4:	01819f04 	movi	r6,1660
    4ce8:	01c000f4 	movhi	r7,3
    4cec:	39fcdd04 	addi	r7,r7,-3212
    4cf0:	00193f00 	call	193f0 <printf>
    4cf4:	003fff06 	br	4cf4 <dhcp_create_msg+0x48>
  LWIP_ERROR("dhcp_create_msg: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
    4cf8:	e0bffe17 	ldw	r2,-8(fp)
    4cfc:	1000091e 	bne	r2,zero,4d24 <dhcp_create_msg+0x78>
    4d00:	010000f4 	movhi	r4,3
    4d04:	213ccf04 	addi	r4,r4,-3268
    4d08:	014000f4 	movhi	r5,3
    4d0c:	297d7c04 	addi	r5,r5,-2576
    4d10:	01819f44 	movi	r6,1661
    4d14:	01c000f4 	movhi	r7,3
    4d18:	39fcdd04 	addi	r7,r7,-3212
    4d1c:	00193f00 	call	193f0 <printf>
    4d20:	003fff06 	br	4d20 <dhcp_create_msg+0x74>
  LWIP_ASSERT("dhcp_create_msg: dhcp->p_out == NULL", dhcp->p_out == NULL);
    4d24:	e0bffe17 	ldw	r2,-8(fp)
    4d28:	10800417 	ldw	r2,16(r2)
    4d2c:	10000926 	beq	r2,zero,4d54 <dhcp_create_msg+0xa8>
    4d30:	010000f4 	movhi	r4,3
    4d34:	213ccf04 	addi	r4,r4,-3268
    4d38:	014000f4 	movhi	r5,3
    4d3c:	297d8404 	addi	r5,r5,-2544
    4d40:	01819f84 	movi	r6,1662
    4d44:	01c000f4 	movhi	r7,3
    4d48:	39fcdd04 	addi	r7,r7,-3212
    4d4c:	00193f00 	call	193f0 <printf>
    4d50:	003fff06 	br	4d50 <dhcp_create_msg+0xa4>
  LWIP_ASSERT("dhcp_create_msg: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
    4d54:	e0bffe17 	ldw	r2,-8(fp)
    4d58:	10800517 	ldw	r2,20(r2)
    4d5c:	10000926 	beq	r2,zero,4d84 <dhcp_create_msg+0xd8>
    4d60:	010000f4 	movhi	r4,3
    4d64:	213ccf04 	addi	r4,r4,-3268
    4d68:	014000f4 	movhi	r5,3
    4d6c:	297d8e04 	addi	r5,r5,-2504
    4d70:	01819fc4 	movi	r6,1663
    4d74:	01c000f4 	movhi	r7,3
    4d78:	39fcdd04 	addi	r7,r7,-3212
    4d7c:	00193f00 	call	193f0 <printf>
    4d80:	003fff06 	br	4d80 <dhcp_create_msg+0xd4>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
    4d84:	0009883a 	mov	r4,zero
    4d88:	01404d04 	movi	r5,308
    4d8c:	000d883a 	mov	r6,zero
    4d90:	000a0740 	call	a074 <pbuf_alloc>
    4d94:	e0fffe17 	ldw	r3,-8(fp)
    4d98:	18800415 	stw	r2,16(r3)
  if (dhcp->p_out == NULL) {
    4d9c:	e0bffe17 	ldw	r2,-8(fp)
    4da0:	10800417 	ldw	r2,16(r2)
    4da4:	1000021e 	bne	r2,zero,4db0 <dhcp_create_msg+0x104>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_create_msg(): could not allocate pbuf\n"));
    return ERR_MEM;
    4da8:	00bfffc4 	movi	r2,-1
    4dac:	0000ef06 	br	516c <dhcp_create_msg+0x4c0>
  }
  LWIP_ASSERT("dhcp_create_msg: check that first pbuf can hold struct dhcp_msg",
    4db0:	e0bffe17 	ldw	r2,-8(fp)
    4db4:	10800417 	ldw	r2,16(r2)
    4db8:	1080028b 	ldhu	r2,10(r2)
    4dbc:	10bfffcc 	andi	r2,r2,65535
    4dc0:	10804d28 	cmpgeui	r2,r2,308
    4dc4:	1000091e 	bne	r2,zero,4dec <dhcp_create_msg+0x140>
    4dc8:	010000f4 	movhi	r4,3
    4dcc:	213ccf04 	addi	r4,r4,-3268
    4dd0:	014000f4 	movhi	r5,3
    4dd4:	297d9804 	addi	r5,r5,-2464
    4dd8:	0181a1c4 	movi	r6,1671
    4ddc:	01c000f4 	movhi	r7,3
    4de0:	39fcdd04 	addi	r7,r7,-3212
    4de4:	00193f00 	call	193f0 <printf>
    4de8:	003fff06 	br	4de8 <dhcp_create_msg+0x13c>
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* reuse transaction identifier in retransmissions */
  if (dhcp->tries == 0) {
    4dec:	e0bffe17 	ldw	r2,-8(fp)
    4df0:	10800343 	ldbu	r2,13(r2)
    4df4:	10803fcc 	andi	r2,r2,255
    4df8:	1000031e 	bne	r2,zero,4e08 <dhcp_create_msg+0x15c>
#if DHCP_CREATE_RAND_XID && defined(LWIP_RAND)
    xid = LWIP_RAND();
#else /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
    xid++;
    4dfc:	d0a00117 	ldw	r2,-32764(gp)
    4e00:	10800044 	addi	r2,r2,1
    4e04:	d0a00115 	stw	r2,-32764(gp)
#endif /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
  }
  dhcp->xid = xid;
    4e08:	d0e00117 	ldw	r3,-32764(gp)
    4e0c:	e0bffe17 	ldw	r2,-8(fp)
    4e10:	10c00015 	stw	r3,0(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
              ("transaction id xid(%"X32_F")\n", xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
    4e14:	e0bffe17 	ldw	r2,-8(fp)
    4e18:	10800417 	ldw	r2,16(r2)
    4e1c:	10c00117 	ldw	r3,4(r2)
    4e20:	e0bffe17 	ldw	r2,-8(fp)
    4e24:	10c00515 	stw	r3,20(r2)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
    4e28:	e0bffe17 	ldw	r2,-8(fp)
    4e2c:	10800517 	ldw	r2,20(r2)
    4e30:	00c00044 	movi	r3,1
    4e34:	10c00005 	stb	r3,0(r2)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
    4e38:	e0bffe17 	ldw	r2,-8(fp)
    4e3c:	10800517 	ldw	r2,20(r2)
    4e40:	00c00044 	movi	r3,1
    4e44:	10c00045 	stb	r3,1(r2)
  dhcp->msg_out->hlen = netif->hwaddr_len;
    4e48:	e0bffe17 	ldw	r2,-8(fp)
    4e4c:	10800517 	ldw	r2,20(r2)
    4e50:	e0fffd17 	ldw	r3,-12(fp)
    4e54:	18c00983 	ldbu	r3,38(r3)
    4e58:	10c00085 	stb	r3,2(r2)
  dhcp->msg_out->hops = 0;
    4e5c:	e0bffe17 	ldw	r2,-8(fp)
    4e60:	10800517 	ldw	r2,20(r2)
    4e64:	100000c5 	stb	zero,3(r2)
  dhcp->msg_out->xid = htonl(dhcp->xid);
    4e68:	e0bffe17 	ldw	r2,-8(fp)
    4e6c:	10800517 	ldw	r2,20(r2)
    4e70:	e0fffe17 	ldw	r3,-8(fp)
    4e74:	18c00017 	ldw	r3,0(r3)
    4e78:	1808d63a 	srli	r4,r3,24
    4e7c:	e0fffe17 	ldw	r3,-8(fp)
    4e80:	18c00017 	ldw	r3,0(r3)
    4e84:	1806d23a 	srli	r3,r3,8
    4e88:	18ffc00c 	andi	r3,r3,65280
    4e8c:	20c8b03a 	or	r4,r4,r3
    4e90:	e0fffe17 	ldw	r3,-8(fp)
    4e94:	18c00017 	ldw	r3,0(r3)
    4e98:	18ffc00c 	andi	r3,r3,65280
    4e9c:	1806923a 	slli	r3,r3,8
    4ea0:	20c8b03a 	or	r4,r4,r3
    4ea4:	e0fffe17 	ldw	r3,-8(fp)
    4ea8:	18c00017 	ldw	r3,0(r3)
    4eac:	1806963a 	slli	r3,r3,24
    4eb0:	20c6b03a 	or	r3,r4,r3
    4eb4:	193fffcc 	andi	r4,r3,65535
    4eb8:	1140010b 	ldhu	r5,4(r2)
    4ebc:	280a703a 	and	r5,r5,zero
    4ec0:	2908b03a 	or	r4,r5,r4
    4ec4:	1100010d 	sth	r4,4(r2)
    4ec8:	1806d43a 	srli	r3,r3,16
    4ecc:	1100018b 	ldhu	r4,6(r2)
    4ed0:	2008703a 	and	r4,r4,zero
    4ed4:	20c6b03a 	or	r3,r4,r3
    4ed8:	10c0018d 	sth	r3,6(r2)
  dhcp->msg_out->secs = 0;
    4edc:	e0bffe17 	ldw	r2,-8(fp)
    4ee0:	10800517 	ldw	r2,20(r2)
    4ee4:	1000020d 	sth	zero,8(r2)
  /* we don't need the broadcast flag since we can receive unicast traffic
     before being fully configured! */
  dhcp->msg_out->flags = 0;
    4ee8:	e0bffe17 	ldw	r2,-8(fp)
    4eec:	10800517 	ldw	r2,20(r2)
    4ef0:	1000028d 	sth	zero,10(r2)
  ip_addr_set_zero(&dhcp->msg_out->ciaddr);
    4ef4:	e0bffe17 	ldw	r2,-8(fp)
    4ef8:	10800517 	ldw	r2,20(r2)
    4efc:	10c0030b 	ldhu	r3,12(r2)
    4f00:	1806703a 	and	r3,r3,zero
    4f04:	10c0030d 	sth	r3,12(r2)
    4f08:	10c0038b 	ldhu	r3,14(r2)
    4f0c:	1806703a 	and	r3,r3,zero
    4f10:	10c0038d 	sth	r3,14(r2)
  /* set ciaddr to netif->ip_addr based on message_type and state */
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) ||
    4f14:	e0bfff03 	ldbu	r2,-4(fp)
    4f18:	10800220 	cmpeqi	r2,r2,8
    4f1c:	1000101e 	bne	r2,zero,4f60 <dhcp_create_msg+0x2b4>
    4f20:	e0bfff03 	ldbu	r2,-4(fp)
    4f24:	10800120 	cmpeqi	r2,r2,4
    4f28:	10000d1e 	bne	r2,zero,4f60 <dhcp_create_msg+0x2b4>
    4f2c:	e0bfff03 	ldbu	r2,-4(fp)
    4f30:	108000d8 	cmpnei	r2,r2,3
    4f34:	1000181e 	bne	r2,zero,4f98 <dhcp_create_msg+0x2ec>
      ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
       ((dhcp->state==DHCP_RENEWING) || dhcp->state==DHCP_REBINDING))) {
    4f38:	e0bffe17 	ldw	r2,-8(fp)
    4f3c:	10800303 	ldbu	r2,12(r2)
     before being fully configured! */
  dhcp->msg_out->flags = 0;
  ip_addr_set_zero(&dhcp->msg_out->ciaddr);
  /* set ciaddr to netif->ip_addr based on message_type and state */
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) ||
      ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
    4f40:	10803fcc 	andi	r2,r2,255
    4f44:	10800160 	cmpeqi	r2,r2,5
    4f48:	1000051e 	bne	r2,zero,4f60 <dhcp_create_msg+0x2b4>
       ((dhcp->state==DHCP_RENEWING) || dhcp->state==DHCP_REBINDING))) {
    4f4c:	e0bffe17 	ldw	r2,-8(fp)
    4f50:	10800303 	ldbu	r2,12(r2)
    4f54:	10803fcc 	andi	r2,r2,255
    4f58:	10800118 	cmpnei	r2,r2,4
    4f5c:	10000e1e 	bne	r2,zero,4f98 <dhcp_create_msg+0x2ec>
    ip_addr_copy(dhcp->msg_out->ciaddr, netif->ip_addr);
    4f60:	e0bffe17 	ldw	r2,-8(fp)
    4f64:	10800517 	ldw	r2,20(r2)
    4f68:	e0fffd17 	ldw	r3,-12(fp)
    4f6c:	18c00117 	ldw	r3,4(r3)
    4f70:	193fffcc 	andi	r4,r3,65535
    4f74:	1140030b 	ldhu	r5,12(r2)
    4f78:	280a703a 	and	r5,r5,zero
    4f7c:	2908b03a 	or	r4,r5,r4
    4f80:	1100030d 	sth	r4,12(r2)
    4f84:	1806d43a 	srli	r3,r3,16
    4f88:	1100038b 	ldhu	r4,14(r2)
    4f8c:	2008703a 	and	r4,r4,zero
    4f90:	20c6b03a 	or	r3,r4,r3
    4f94:	10c0038d 	sth	r3,14(r2)
  }
  ip_addr_set_zero(&dhcp->msg_out->yiaddr);
    4f98:	e0bffe17 	ldw	r2,-8(fp)
    4f9c:	10800517 	ldw	r2,20(r2)
    4fa0:	10c0040b 	ldhu	r3,16(r2)
    4fa4:	1806703a 	and	r3,r3,zero
    4fa8:	10c0040d 	sth	r3,16(r2)
    4fac:	10c0048b 	ldhu	r3,18(r2)
    4fb0:	1806703a 	and	r3,r3,zero
    4fb4:	10c0048d 	sth	r3,18(r2)
  ip_addr_set_zero(&dhcp->msg_out->siaddr);
    4fb8:	e0bffe17 	ldw	r2,-8(fp)
    4fbc:	10800517 	ldw	r2,20(r2)
    4fc0:	10c0050b 	ldhu	r3,20(r2)
    4fc4:	1806703a 	and	r3,r3,zero
    4fc8:	10c0050d 	sth	r3,20(r2)
    4fcc:	10c0058b 	ldhu	r3,22(r2)
    4fd0:	1806703a 	and	r3,r3,zero
    4fd4:	10c0058d 	sth	r3,22(r2)
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
    4fd8:	e0bffe17 	ldw	r2,-8(fp)
    4fdc:	10800517 	ldw	r2,20(r2)
    4fe0:	10c0060b 	ldhu	r3,24(r2)
    4fe4:	1806703a 	and	r3,r3,zero
    4fe8:	10c0060d 	sth	r3,24(r2)
    4fec:	10c0068b 	ldhu	r3,26(r2)
    4ff0:	1806703a 	and	r3,r3,zero
    4ff4:	10c0068d 	sth	r3,26(r2)
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    4ff8:	e03ffc0d 	sth	zero,-16(fp)
    4ffc:	00001606 	br	5058 <dhcp_create_msg+0x3ac>
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
    5000:	e0bffe17 	ldw	r2,-8(fp)
    5004:	11000517 	ldw	r4,20(r2)
    5008:	e0fffc0b 	ldhu	r3,-16(fp)
    500c:	e0bffd17 	ldw	r2,-12(fp)
    5010:	10800983 	ldbu	r2,38(r2)
    5014:	10803fcc 	andi	r2,r2,255
    5018:	10bfffcc 	andi	r2,r2,65535
    501c:	e17ffc0b 	ldhu	r5,-16(fp)
    5020:	2880062e 	bgeu	r5,r2,503c <dhcp_create_msg+0x390>
    5024:	e0bffc0b 	ldhu	r2,-16(fp)
    5028:	e17ffd17 	ldw	r5,-12(fp)
    502c:	2885883a 	add	r2,r5,r2
    5030:	10800904 	addi	r2,r2,36
    5034:	108000c3 	ldbu	r2,3(r2)
    5038:	00000106 	br	5040 <dhcp_create_msg+0x394>
    503c:	0005883a 	mov	r2,zero
    5040:	20c7883a 	add	r3,r4,r3
    5044:	18c00704 	addi	r3,r3,28
    5048:	18800005 	stb	r2,0(r3)
    ip_addr_copy(dhcp->msg_out->ciaddr, netif->ip_addr);
  }
  ip_addr_set_zero(&dhcp->msg_out->yiaddr);
  ip_addr_set_zero(&dhcp->msg_out->siaddr);
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    504c:	e0bffc0b 	ldhu	r2,-16(fp)
    5050:	10800044 	addi	r2,r2,1
    5054:	e0bffc0d 	sth	r2,-16(fp)
    5058:	e0bffc0b 	ldhu	r2,-16(fp)
    505c:	10800430 	cmpltui	r2,r2,16
    5060:	103fe71e 	bne	r2,zero,5000 <dhcp_create_msg+0x354>
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    5064:	e03ffc0d 	sth	zero,-16(fp)
    5068:	00000906 	br	5090 <dhcp_create_msg+0x3e4>
    dhcp->msg_out->sname[i] = 0;
    506c:	e0bffe17 	ldw	r2,-8(fp)
    5070:	10c00517 	ldw	r3,20(r2)
    5074:	e0bffc0b 	ldhu	r2,-16(fp)
    5078:	1885883a 	add	r2,r3,r2
    507c:	10800b04 	addi	r2,r2,44
    5080:	10000005 	stb	zero,0(r2)
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    5084:	e0bffc0b 	ldhu	r2,-16(fp)
    5088:	10800044 	addi	r2,r2,1
    508c:	e0bffc0d 	sth	r2,-16(fp)
    5090:	e0bffc0b 	ldhu	r2,-16(fp)
    5094:	10801030 	cmpltui	r2,r2,64
    5098:	103ff41e 	bne	r2,zero,506c <dhcp_create_msg+0x3c0>
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    509c:	e03ffc0d 	sth	zero,-16(fp)
    50a0:	00000906 	br	50c8 <dhcp_create_msg+0x41c>
    dhcp->msg_out->file[i] = 0;
    50a4:	e0bffe17 	ldw	r2,-8(fp)
    50a8:	10c00517 	ldw	r3,20(r2)
    50ac:	e0bffc0b 	ldhu	r2,-16(fp)
    50b0:	1885883a 	add	r2,r3,r2
    50b4:	10801b04 	addi	r2,r2,108
    50b8:	10000005 	stb	zero,0(r2)
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    50bc:	e0bffc0b 	ldhu	r2,-16(fp)
    50c0:	10800044 	addi	r2,r2,1
    50c4:	e0bffc0d 	sth	r2,-16(fp)
    50c8:	e0bffc0b 	ldhu	r2,-16(fp)
    50cc:	10802030 	cmpltui	r2,r2,128
    50d0:	103ff41e 	bne	r2,zero,50a4 <dhcp_create_msg+0x3f8>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
    50d4:	e0bffe17 	ldw	r2,-8(fp)
    50d8:	10800517 	ldw	r2,20(r2)
    50dc:	10c03b0b 	ldhu	r3,236(r2)
    50e0:	1806703a 	and	r3,r3,zero
    50e4:	1809883a 	mov	r4,r3
    50e8:	00e098c4 	movi	r3,-32157
    50ec:	20c6b03a 	or	r3,r4,r3
    50f0:	10c03b0d 	sth	r3,236(r2)
    50f4:	10c03b8b 	ldhu	r3,238(r2)
    50f8:	1806703a 	and	r3,r3,zero
    50fc:	18d8d4d4 	ori	r3,r3,25427
    5100:	10c03b8d 	sth	r3,238(r2)
  dhcp->options_out_len = 0;
    5104:	e0bffe17 	ldw	r2,-8(fp)
    5108:	1000060d 	sth	zero,24(r2)
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    510c:	e03ffc0d 	sth	zero,-16(fp)
    5110:	00000a06 	br	513c <dhcp_create_msg+0x490>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
    5114:	e0bffe17 	ldw	r2,-8(fp)
    5118:	11000517 	ldw	r4,20(r2)
    511c:	e0bffc0b 	ldhu	r2,-16(fp)
    5120:	e0fffc0b 	ldhu	r3,-16(fp)
    5124:	2085883a 	add	r2,r4,r2
    5128:	10803c04 	addi	r2,r2,240
    512c:	10c00005 	stb	r3,0(r2)
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    5130:	e0bffc0b 	ldhu	r2,-16(fp)
    5134:	10800044 	addi	r2,r2,1
    5138:	e0bffc0d 	sth	r2,-16(fp)
    513c:	e0bffc0b 	ldhu	r2,-16(fp)
    5140:	10801130 	cmpltui	r2,r2,68
    5144:	103ff31e 	bne	r2,zero,5114 <dhcp_create_msg+0x468>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  /* Add option MESSAGE_TYPE */
  dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
    5148:	e13ffe17 	ldw	r4,-8(fp)
    514c:	01400d44 	movi	r5,53
    5150:	01800044 	movi	r6,1
    5154:	0003cd80 	call	3cd8 <dhcp_option>
  dhcp_option_byte(dhcp, message_type);
    5158:	e0bfff03 	ldbu	r2,-4(fp)
    515c:	e13ffe17 	ldw	r4,-8(fp)
    5160:	100b883a 	mov	r5,r2
    5164:	0003dbc0 	call	3dbc <dhcp_option_byte>
  return ERR_OK;
    5168:	0005883a 	mov	r2,zero
}
    516c:	e037883a 	mov	sp,fp
    5170:	dfc00117 	ldw	ra,4(sp)
    5174:	df000017 	ldw	fp,0(sp)
    5178:	dec00204 	addi	sp,sp,8
    517c:	f800283a 	ret

00005180 <dhcp_delete_msg>:
 *
 * @param dhcp the dhcp struct to free the request from
 */
static void
dhcp_delete_msg(struct dhcp *dhcp)
{
    5180:	defffd04 	addi	sp,sp,-12
    5184:	dfc00215 	stw	ra,8(sp)
    5188:	df000115 	stw	fp,4(sp)
    518c:	df000104 	addi	fp,sp,4
    5190:	e13fff15 	stw	r4,-4(fp)
  LWIP_ERROR("dhcp_delete_msg: dhcp != NULL", (dhcp != NULL), return;);
    5194:	e0bfff17 	ldw	r2,-4(fp)
    5198:	1000091e 	bne	r2,zero,51c0 <dhcp_delete_msg+0x40>
    519c:	010000f4 	movhi	r4,3
    51a0:	213ccf04 	addi	r4,r4,-3268
    51a4:	014000f4 	movhi	r5,3
    51a8:	297da804 	addi	r5,r5,-2400
    51ac:	0181b244 	movi	r6,1737
    51b0:	01c000f4 	movhi	r7,3
    51b4:	39fcdd04 	addi	r7,r7,-3212
    51b8:	00193f00 	call	193f0 <printf>
    51bc:	003fff06 	br	51bc <dhcp_delete_msg+0x3c>
  LWIP_ASSERT("dhcp_delete_msg: dhcp->p_out != NULL", dhcp->p_out != NULL);
    51c0:	e0bfff17 	ldw	r2,-4(fp)
    51c4:	10800417 	ldw	r2,16(r2)
    51c8:	1000091e 	bne	r2,zero,51f0 <dhcp_delete_msg+0x70>
    51cc:	010000f4 	movhi	r4,3
    51d0:	213ccf04 	addi	r4,r4,-3268
    51d4:	014000f4 	movhi	r5,3
    51d8:	297db004 	addi	r5,r5,-2368
    51dc:	0181b284 	movi	r6,1738
    51e0:	01c000f4 	movhi	r7,3
    51e4:	39fcdd04 	addi	r7,r7,-3212
    51e8:	00193f00 	call	193f0 <printf>
    51ec:	003fff06 	br	51ec <dhcp_delete_msg+0x6c>
  LWIP_ASSERT("dhcp_delete_msg: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
    51f0:	e0bfff17 	ldw	r2,-4(fp)
    51f4:	10800517 	ldw	r2,20(r2)
    51f8:	1000091e 	bne	r2,zero,5220 <dhcp_delete_msg+0xa0>
    51fc:	010000f4 	movhi	r4,3
    5200:	213ccf04 	addi	r4,r4,-3268
    5204:	014000f4 	movhi	r5,3
    5208:	297dba04 	addi	r5,r5,-2328
    520c:	0181b2c4 	movi	r6,1739
    5210:	01c000f4 	movhi	r7,3
    5214:	39fcdd04 	addi	r7,r7,-3212
    5218:	00193f00 	call	193f0 <printf>
    521c:	003fff06 	br	521c <dhcp_delete_msg+0x9c>
  if (dhcp->p_out != NULL) {
    5220:	e0bfff17 	ldw	r2,-4(fp)
    5224:	10800417 	ldw	r2,16(r2)
    5228:	10000426 	beq	r2,zero,523c <dhcp_delete_msg+0xbc>
    pbuf_free(dhcp->p_out);
    522c:	e0bfff17 	ldw	r2,-4(fp)
    5230:	10800417 	ldw	r2,16(r2)
    5234:	1009883a 	mov	r4,r2
    5238:	000aa340 	call	aa34 <pbuf_free>
  }
  dhcp->p_out = NULL;
    523c:	e0bfff17 	ldw	r2,-4(fp)
    5240:	10000415 	stw	zero,16(r2)
  dhcp->msg_out = NULL;
    5244:	e0bfff17 	ldw	r2,-4(fp)
    5248:	10000515 	stw	zero,20(r2)
}
    524c:	e037883a 	mov	sp,fp
    5250:	dfc00117 	ldw	ra,4(sp)
    5254:	df000017 	ldw	fp,0(sp)
    5258:	dec00204 	addi	sp,sp,8
    525c:	f800283a 	ret

00005260 <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
    5260:	defffd04 	addi	sp,sp,-12
    5264:	dfc00215 	stw	ra,8(sp)
    5268:	df000115 	stw	fp,4(sp)
    526c:	df000104 	addi	fp,sp,4
    5270:	e13fff15 	stw	r4,-4(fp)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
    5274:	e0bfff17 	ldw	r2,-4(fp)
    5278:	1000091e 	bne	r2,zero,52a0 <dhcp_option_trailer+0x40>
    527c:	010000f4 	movhi	r4,3
    5280:	213ccf04 	addi	r4,r4,-3268
    5284:	014000f4 	movhi	r5,3
    5288:	297dc404 	addi	r5,r5,-2288
    528c:	0181b784 	movi	r6,1758
    5290:	01c000f4 	movhi	r7,3
    5294:	39fcdd04 	addi	r7,r7,-3212
    5298:	00193f00 	call	193f0 <printf>
    529c:	003fff06 	br	529c <dhcp_option_trailer+0x3c>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
    52a0:	e0bfff17 	ldw	r2,-4(fp)
    52a4:	10800517 	ldw	r2,20(r2)
    52a8:	1000091e 	bne	r2,zero,52d0 <dhcp_option_trailer+0x70>
    52ac:	010000f4 	movhi	r4,3
    52b0:	213ccf04 	addi	r4,r4,-3268
    52b4:	014000f4 	movhi	r5,3
    52b8:	297dcd04 	addi	r5,r5,-2252
    52bc:	0181b7c4 	movi	r6,1759
    52c0:	01c000f4 	movhi	r7,3
    52c4:	39fcdd04 	addi	r7,r7,-3212
    52c8:	00193f00 	call	193f0 <printf>
    52cc:	003fff06 	br	52cc <dhcp_option_trailer+0x6c>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    52d0:	e0bfff17 	ldw	r2,-4(fp)
    52d4:	1080060b 	ldhu	r2,24(r2)
    52d8:	10bfffcc 	andi	r2,r2,65535
    52dc:	10801130 	cmpltui	r2,r2,68
    52e0:	1000091e 	bne	r2,zero,5308 <dhcp_option_trailer+0xa8>
    52e4:	010000f4 	movhi	r4,3
    52e8:	213ccf04 	addi	r4,r4,-3268
    52ec:	014000f4 	movhi	r5,3
    52f0:	297dd804 	addi	r5,r5,-2208
    52f4:	0181b804 	movi	r6,1760
    52f8:	01c000f4 	movhi	r7,3
    52fc:	39fcdd04 	addi	r7,r7,-3212
    5300:	00193f00 	call	193f0 <printf>
    5304:	003fff06 	br	5304 <dhcp_option_trailer+0xa4>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
    5308:	e0bfff17 	ldw	r2,-4(fp)
    530c:	11000517 	ldw	r4,20(r2)
    5310:	e0bfff17 	ldw	r2,-4(fp)
    5314:	1080060b 	ldhu	r2,24(r2)
    5318:	10ffffcc 	andi	r3,r2,65535
    531c:	20c7883a 	add	r3,r4,r3
    5320:	18c03c04 	addi	r3,r3,240
    5324:	013fffc4 	movi	r4,-1
    5328:	19000005 	stb	r4,0(r3)
    532c:	10800044 	addi	r2,r2,1
    5330:	1007883a 	mov	r3,r2
    5334:	e0bfff17 	ldw	r2,-4(fp)
    5338:	10c0060d 	sth	r3,24(r2)
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
    533c:	00000c06 	br	5370 <dhcp_option_trailer+0x110>
         (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
    5340:	e0bfff17 	ldw	r2,-4(fp)
    5344:	11000517 	ldw	r4,20(r2)
    5348:	e0bfff17 	ldw	r2,-4(fp)
    534c:	1080060b 	ldhu	r2,24(r2)
    5350:	10ffffcc 	andi	r3,r2,65535
    5354:	20c7883a 	add	r3,r4,r3
    5358:	18c03c04 	addi	r3,r3,240
    535c:	18000005 	stb	zero,0(r3)
    5360:	10800044 	addi	r2,r2,1
    5364:	1007883a 	mov	r3,r2
    5368:	e0bfff17 	ldw	r2,-4(fp)
    536c:	10c0060d 	sth	r3,24(r2)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
    5370:	e0bfff17 	ldw	r2,-4(fp)
    5374:	1080060b 	ldhu	r2,24(r2)
    5378:	10bfffcc 	andi	r2,r2,65535
    537c:	10801130 	cmpltui	r2,r2,68
    5380:	1000051e 	bne	r2,zero,5398 <dhcp_option_trailer+0x138>
    5384:	e0bfff17 	ldw	r2,-4(fp)
    5388:	1080060b 	ldhu	r2,24(r2)
    538c:	10bfffcc 	andi	r2,r2,65535
    5390:	108000cc 	andi	r2,r2,3
    5394:	10000526 	beq	r2,zero,53ac <dhcp_option_trailer+0x14c>
         (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
    5398:	e0bfff17 	ldw	r2,-4(fp)
    539c:	1080060b 	ldhu	r2,24(r2)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
    53a0:	10bfffcc 	andi	r2,r2,65535
    53a4:	10801130 	cmpltui	r2,r2,68
    53a8:	103fe51e 	bne	r2,zero,5340 <dhcp_option_trailer+0xe0>
         (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
    53ac:	e037883a 	mov	sp,fp
    53b0:	dfc00117 	ldw	ra,4(sp)
    53b4:	df000017 	ldw	fp,0(sp)
    53b8:	dec00204 	addi	sp,sp,8
    53bc:	f800283a 	ret

000053c0 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
    53c0:	defffe04 	addi	sp,sp,-8
    53c4:	dfc00115 	stw	ra,4(sp)
    53c8:	df000015 	stw	fp,0(sp)
    53cc:	d839883a 	mov	fp,sp
  /* Modules initialization */
  stats_init();
    53d0:	000be3c0 	call	be3c <stats_init>
#if !NO_SYS
  sys_init();
#endif /* !NO_SYS */
  mem_init();
    53d4:	0008a5c0 	call	8a5c <mem_init>
  memp_init();
    53d8:	000943c0 	call	943c <memp_init>
  pbuf_init();
  netif_init();
    53dc:	00098cc0 	call	98cc <netif_init>
#endif /* LWIP_ARP */
#if LWIP_RAW
  raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
  udp_init();
    53e0:	0014ff40 	call	14ff4 <udp_init>
#endif /* LWIP_UDP */
#if LWIP_TCP
  tcp_init();
    53e4:	000be580 	call	be58 <tcp_init>
#endif /* LWIP_DNS */

#if LWIP_TIMERS
  sys_timeouts_init();
#endif /* LWIP_TIMERS */
}
    53e8:	e037883a 	mov	sp,fp
    53ec:	dfc00117 	ldw	ra,4(sp)
    53f0:	df000017 	ldw	fp,0(sp)
    53f4:	dec00204 	addi	sp,sp,8
    53f8:	f800283a 	ret

000053fc <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
    53fc:	defff304 	addi	sp,sp,-52
    5400:	dfc00c15 	stw	ra,48(sp)
    5404:	df000b15 	stw	fp,44(sp)
    5408:	df000b04 	addi	fp,sp,44
    540c:	e13ffe15 	stw	r4,-8(fp)
    5410:	e17fff15 	stw	r5,-4(fp)
#endif /* LWIP_DEBUG */
  struct icmp_echo_hdr *iecho;
  struct ip_hdr *iphdr;
  s16_t hlen;

  ICMP_STATS_INC(icmp.recv);
    5414:	00800234 	movhi	r2,8
    5418:	1083bd04 	addi	r2,r2,3828
    541c:	1080188b 	ldhu	r2,98(r2)
    5420:	10800044 	addi	r2,r2,1
    5424:	1007883a 	mov	r3,r2
    5428:	00800234 	movhi	r2,8
    542c:	1083bd04 	addi	r2,r2,3828
    5430:	10c0188d 	sth	r3,98(r2)
  snmp_inc_icmpinmsgs();


  iphdr = (struct ip_hdr *)p->payload;
    5434:	e0bffe17 	ldw	r2,-8(fp)
    5438:	10800117 	ldw	r2,4(r2)
    543c:	e0bff815 	stw	r2,-32(fp)
  hlen = IPH_HL(iphdr) * 4;
    5440:	e0bff817 	ldw	r2,-32(fp)
    5444:	10800003 	ldbu	r2,0(r2)
    5448:	10803fcc 	andi	r2,r2,255
    544c:	108003cc 	andi	r2,r2,15
    5450:	1085883a 	add	r2,r2,r2
    5454:	1085883a 	add	r2,r2,r2
    5458:	e0bffa0d 	sth	r2,-24(fp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
    545c:	e0bffa0b 	ldhu	r2,-24(fp)
    5460:	0085c83a 	sub	r2,zero,r2
    5464:	10bfffcc 	andi	r2,r2,65535
    5468:	10a0001c 	xori	r2,r2,32768
    546c:	10a00004 	addi	r2,r2,-32768
    5470:	e13ffe17 	ldw	r4,-8(fp)
    5474:	100b883a 	mov	r5,r2
    5478:	000a83c0 	call	a83c <pbuf_header>
    547c:	10803fcc 	andi	r2,r2,255
    5480:	10011d1e 	bne	r2,zero,58f8 <icmp_input+0x4fc>
    5484:	e0bffe17 	ldw	r2,-8(fp)
    5488:	1080020b 	ldhu	r2,8(r2)
    548c:	10bfffcc 	andi	r2,r2,65535
    5490:	10800130 	cmpltui	r2,r2,4
    5494:	1001181e 	bne	r2,zero,58f8 <icmp_input+0x4fc>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
    5498:	e0bffe17 	ldw	r2,-8(fp)
    549c:	10800117 	ldw	r2,4(r2)
    54a0:	10800003 	ldbu	r2,0(r2)
    54a4:	e0bffa85 	stb	r2,-22(fp)
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
    54a8:	e0bffa83 	ldbu	r2,-22(fp)
    54ac:	10010d26 	beq	r2,zero,58e4 <icmp_input+0x4e8>
    54b0:	10800220 	cmpeqi	r2,r2,8
    54b4:	1000fa26 	beq	r2,zero,58a0 <icmp_input+0x4a4>
       (as obviously, an echo request has been sent, too). */
    break; 
  case ICMP_ECHO:
#if !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
    {
      int accepted = 1;
    54b8:	00800044 	movi	r2,1
    54bc:	e0bff915 	stw	r2,-28(fp)
#if !LWIP_MULTICAST_PING
      /* multicast destination address? */
      if (ip_addr_ismulticast(&current_iphdr_dest)) {
    54c0:	008000f4 	movhi	r2,3
    54c4:	109e2104 	addi	r2,r2,30852
    54c8:	10800017 	ldw	r2,0(r2)
    54cc:	10803c0c 	andi	r2,r2,240
    54d0:	10803818 	cmpnei	r2,r2,224
    54d4:	1000011e 	bne	r2,zero,54dc <icmp_input+0xe0>
        accepted = 0;
    54d8:	e03ff915 	stw	zero,-28(fp)
      }
#endif /* LWIP_MULTICAST_PING */
#if !LWIP_BROADCAST_PING
      /* broadcast destination address? */
      if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
    54dc:	008000f4 	movhi	r2,3
    54e0:	109e2104 	addi	r2,r2,30852
    54e4:	10800017 	ldw	r2,0(r2)
    54e8:	1009883a 	mov	r4,r2
    54ec:	e17fff17 	ldw	r5,-4(fp)
    54f0:	0006da80 	call	6da8 <ip4_addr_isbroadcast>
    54f4:	10803fcc 	andi	r2,r2,255
    54f8:	10000126 	beq	r2,zero,5500 <icmp_input+0x104>
        accepted = 0;
    54fc:	e03ff915 	stw	zero,-28(fp)
      }
#endif /* LWIP_BROADCAST_PING */
      /* broadcast or multicast destination address not acceptd? */
      if (!accepted) {
    5500:	e0bff917 	ldw	r2,-28(fp)
    5504:	10000b1e 	bne	r2,zero,5534 <icmp_input+0x138>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
        ICMP_STATS_INC(icmp.err);
    5508:	00800234 	movhi	r2,8
    550c:	1083bd04 	addi	r2,r2,3828
    5510:	10801d0b 	ldhu	r2,116(r2)
    5514:	10800044 	addi	r2,r2,1
    5518:	1007883a 	mov	r3,r2
    551c:	00800234 	movhi	r2,8
    5520:	1083bd04 	addi	r2,r2,3828
    5524:	10c01d0d 	sth	r3,116(r2)
        pbuf_free(p);
    5528:	e13ffe17 	ldw	r4,-8(fp)
    552c:	000aa340 	call	aa34 <pbuf_free>
        return;
    5530:	00010806 	br	5954 <icmp_input+0x558>
      }
    }
#endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
    5534:	e0bffe17 	ldw	r2,-8(fp)
    5538:	1080020b 	ldhu	r2,8(r2)
    553c:	10bfffcc 	andi	r2,r2,65535
    5540:	10800228 	cmpgeui	r2,r2,8
    5544:	1000eb26 	beq	r2,zero,58f4 <icmp_input+0x4f8>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
    5548:	e13ffe17 	ldw	r4,-8(fp)
    554c:	00061540 	call	6154 <inet_chksum_pbuf>
    5550:	10bfffcc 	andi	r2,r2,65535
    5554:	10000b26 	beq	r2,zero,5584 <icmp_input+0x188>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
    5558:	e13ffe17 	ldw	r4,-8(fp)
    555c:	000aa340 	call	aa34 <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
    5560:	00800234 	movhi	r2,8
    5564:	1083bd04 	addi	r2,r2,3828
    5568:	10801a0b 	ldhu	r2,104(r2)
    556c:	10800044 	addi	r2,r2,1
    5570:	1007883a 	mov	r3,r2
    5574:	00800234 	movhi	r2,8
    5578:	1083bd04 	addi	r2,r2,3828
    557c:	10c01a0d 	sth	r3,104(r2)
      snmp_inc_icmpinerrors();
      return;
    5580:	0000f406 	br	5954 <icmp_input+0x558>
    }
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
    5584:	e13ffe17 	ldw	r4,-8(fp)
    5588:	01400884 	movi	r5,34
    558c:	000a83c0 	call	a83c <pbuf_header>
    5590:	10803fcc 	andi	r2,r2,255
    5594:	10005326 	beq	r2,zero,56e4 <icmp_input+0x2e8>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
    5598:	e0bffa0f 	ldh	r2,-24(fp)
    559c:	e13ffe17 	ldw	r4,-8(fp)
    55a0:	100b883a 	mov	r5,r2
    55a4:	000a83c0 	call	a83c <pbuf_header>
    55a8:	10803fcc 	andi	r2,r2,255
    55ac:	10000926 	beq	r2,zero,55d4 <icmp_input+0x1d8>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
    55b0:	010000f4 	movhi	r4,3
    55b4:	213de804 	addi	r4,r4,-2144
    55b8:	014000f4 	movhi	r5,3
    55bc:	297df204 	addi	r5,r5,-2104
    55c0:	01802604 	movi	r6,152
    55c4:	01c000f4 	movhi	r7,3
    55c8:	39fdff04 	addi	r7,r7,-2052
    55cc:	00193f00 	call	193f0 <printf>
    55d0:	003fff06 	br	55d0 <icmp_input+0x1d4>
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
    55d4:	e0bffe17 	ldw	r2,-8(fp)
    55d8:	1080020b 	ldhu	r2,8(r2)
    55dc:	10bfffcc 	andi	r2,r2,65535
    55e0:	01000084 	movi	r4,2
    55e4:	100b883a 	mov	r5,r2
    55e8:	000d883a 	mov	r6,zero
    55ec:	000a0740 	call	a074 <pbuf_alloc>
    55f0:	e0bffb15 	stw	r2,-20(fp)
      if (r == NULL) {
    55f4:	e0bffb17 	ldw	r2,-20(fp)
    55f8:	1000ca26 	beq	r2,zero,5924 <icmp_input+0x528>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
    55fc:	e0bffb17 	ldw	r2,-20(fp)
    5600:	1080028b 	ldhu	r2,10(r2)
    5604:	10ffffcc 	andi	r3,r2,65535
    5608:	e0bffa0f 	ldh	r2,-24(fp)
    560c:	10800204 	addi	r2,r2,8
    5610:	1880092e 	bgeu	r3,r2,5638 <icmp_input+0x23c>
    5614:	010000f4 	movhi	r4,3
    5618:	213de804 	addi	r4,r4,-2144
    561c:	014000f4 	movhi	r5,3
    5620:	297e0604 	addi	r5,r5,-2024
    5624:	01802884 	movi	r6,162
    5628:	01c000f4 	movhi	r7,3
    562c:	39fdff04 	addi	r7,r7,-2052
    5630:	00193f00 	call	193f0 <printf>
    5634:	003fff06 	br	5634 <icmp_input+0x238>
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
    5638:	e13ffb17 	ldw	r4,-20(fp)
    563c:	e17ffe17 	ldw	r5,-8(fp)
    5640:	000af380 	call	af38 <pbuf_copy>
    5644:	10803fcc 	andi	r2,r2,255
    5648:	1080201c 	xori	r2,r2,128
    564c:	10bfe004 	addi	r2,r2,-128
    5650:	10000926 	beq	r2,zero,5678 <icmp_input+0x27c>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
    5654:	010000f4 	movhi	r4,3
    5658:	213de804 	addi	r4,r4,-2144
    565c:	014000f4 	movhi	r5,3
    5660:	297e1404 	addi	r5,r5,-1968
    5664:	01802944 	movi	r6,165
    5668:	01c000f4 	movhi	r7,3
    566c:	39fdff04 	addi	r7,r7,-2052
    5670:	00193f00 	call	193f0 <printf>
    5674:	003fff06 	br	5674 <icmp_input+0x278>
        goto memerr;
      }
      iphdr = (struct ip_hdr *)r->payload;
    5678:	e0bffb17 	ldw	r2,-20(fp)
    567c:	10800117 	ldw	r2,4(r2)
    5680:	e0bff815 	stw	r2,-32(fp)
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
    5684:	e0bffa0b 	ldhu	r2,-24(fp)
    5688:	0085c83a 	sub	r2,zero,r2
    568c:	10bfffcc 	andi	r2,r2,65535
    5690:	10a0001c 	xori	r2,r2,32768
    5694:	10a00004 	addi	r2,r2,-32768
    5698:	e13ffb17 	ldw	r4,-20(fp)
    569c:	100b883a 	mov	r5,r2
    56a0:	000a83c0 	call	a83c <pbuf_header>
    56a4:	10803fcc 	andi	r2,r2,255
    56a8:	10000926 	beq	r2,zero,56d0 <icmp_input+0x2d4>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
    56ac:	010000f4 	movhi	r4,3
    56b0:	213de804 	addi	r4,r4,-2144
    56b4:	014000f4 	movhi	r5,3
    56b8:	297e1e04 	addi	r5,r5,-1928
    56bc:	01802ac4 	movi	r6,171
    56c0:	01c000f4 	movhi	r7,3
    56c4:	39fdff04 	addi	r7,r7,-2052
    56c8:	00193f00 	call	193f0 <printf>
    56cc:	003fff06 	br	56cc <icmp_input+0x2d0>
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
    56d0:	e13ffe17 	ldw	r4,-8(fp)
    56d4:	000aa340 	call	aa34 <pbuf_free>
      /* we now have an identical copy of p that has room for link headers */
      p = r;
    56d8:	e0bffb17 	ldw	r2,-20(fp)
    56dc:	e0bffe15 	stw	r2,-8(fp)
    56e0:	00000e06 	br	571c <icmp_input+0x320>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
    56e4:	e13ffe17 	ldw	r4,-8(fp)
    56e8:	017ff784 	movi	r5,-34
    56ec:	000a83c0 	call	a83c <pbuf_header>
    56f0:	10803fcc 	andi	r2,r2,255
    56f4:	10000926 	beq	r2,zero,571c <icmp_input+0x320>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
    56f8:	010000f4 	movhi	r4,3
    56fc:	213de804 	addi	r4,r4,-2144
    5700:	014000f4 	movhi	r5,3
    5704:	297e1e04 	addi	r5,r5,-1928
    5708:	01802d44 	movi	r6,181
    570c:	01c000f4 	movhi	r7,3
    5710:	39fdff04 	addi	r7,r7,-2052
    5714:	00193f00 	call	193f0 <printf>
    5718:	003fff06 	br	5718 <icmp_input+0x31c>
    }
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = (struct icmp_echo_hdr *)p->payload;
    571c:	e0bffe17 	ldw	r2,-8(fp)
    5720:	10800117 	ldw	r2,4(r2)
    5724:	e0bffc15 	stw	r2,-16(fp)
    ip_addr_copy(iphdr->src, *ip_current_dest_addr());
    5728:	008000f4 	movhi	r2,3
    572c:	109e2104 	addi	r2,r2,30852
    5730:	10c00017 	ldw	r3,0(r2)
    5734:	e0bff817 	ldw	r2,-32(fp)
    5738:	193fffcc 	andi	r4,r3,65535
    573c:	1140030b 	ldhu	r5,12(r2)
    5740:	280a703a 	and	r5,r5,zero
    5744:	2908b03a 	or	r4,r5,r4
    5748:	1100030d 	sth	r4,12(r2)
    574c:	1806d43a 	srli	r3,r3,16
    5750:	1100038b 	ldhu	r4,14(r2)
    5754:	2008703a 	and	r4,r4,zero
    5758:	20c6b03a 	or	r3,r4,r3
    575c:	10c0038d 	sth	r3,14(r2)
    ip_addr_copy(iphdr->dest, *ip_current_src_addr());
    5760:	008000f4 	movhi	r2,3
    5764:	109e1f04 	addi	r2,r2,30844
    5768:	10c00017 	ldw	r3,0(r2)
    576c:	e0bff817 	ldw	r2,-32(fp)
    5770:	193fffcc 	andi	r4,r3,65535
    5774:	1140040b 	ldhu	r5,16(r2)
    5778:	280a703a 	and	r5,r5,zero
    577c:	2908b03a 	or	r4,r5,r4
    5780:	1100040d 	sth	r4,16(r2)
    5784:	1806d43a 	srli	r3,r3,16
    5788:	1100048b 	ldhu	r4,18(r2)
    578c:	2008703a 	and	r4,r4,zero
    5790:	20c6b03a 	or	r3,r4,r3
    5794:	10c0048d 	sth	r3,18(r2)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
    5798:	e0bffc17 	ldw	r2,-16(fp)
    579c:	10000005 	stb	zero,0(r2)
#if CHECKSUM_GEN_ICMP
    /* adjust the checksum */
    if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
    57a0:	e0bffc17 	ldw	r2,-16(fp)
    57a4:	1080008b 	ldhu	r2,2(r2)
    57a8:	10bfffcc 	andi	r2,r2,65535
    57ac:	10bffdf0 	cmpltui	r2,r2,65527
    57b0:	1000071e 	bne	r2,zero,57d0 <icmp_input+0x3d4>
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
    57b4:	e0bffc17 	ldw	r2,-16(fp)
    57b8:	1080008b 	ldhu	r2,2(r2)
    57bc:	10800244 	addi	r2,r2,9
    57c0:	1007883a 	mov	r3,r2
    57c4:	e0bffc17 	ldw	r2,-16(fp)
    57c8:	10c0008d 	sth	r3,2(r2)
    57cc:	00000606 	br	57e8 <icmp_input+0x3ec>
    } else {
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
    57d0:	e0bffc17 	ldw	r2,-16(fp)
    57d4:	1080008b 	ldhu	r2,2(r2)
    57d8:	10800204 	addi	r2,r2,8
    57dc:	1007883a 	mov	r3,r2
    57e0:	e0bffc17 	ldw	r2,-16(fp)
    57e4:	10c0008d 	sth	r3,2(r2)
#else /* CHECKSUM_GEN_ICMP */
    iecho->chksum = 0;
#endif /* CHECKSUM_GEN_ICMP */

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
    57e8:	e0bff817 	ldw	r2,-32(fp)
    57ec:	00ffffc4 	movi	r3,-1
    57f0:	10c00205 	stb	r3,8(r2)
    IPH_CHKSUM_SET(iphdr, 0);
    57f4:	e0bff817 	ldw	r2,-32(fp)
    57f8:	1000028d 	sth	zero,10(r2)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    57fc:	e13ff817 	ldw	r4,-32(fp)
    5800:	01400504 	movi	r5,20
    5804:	00061100 	call	6110 <inet_chksum>
    5808:	e0fff817 	ldw	r3,-32(fp)
    580c:	1880028d 	sth	r2,10(r3)
#endif /* CHECKSUM_GEN_IP */

    ICMP_STATS_INC(icmp.xmit);
    5810:	00800234 	movhi	r2,8
    5814:	1083bd04 	addi	r2,r2,3828
    5818:	1080180b 	ldhu	r2,96(r2)
    581c:	10800044 	addi	r2,r2,1
    5820:	1007883a 	mov	r3,r2
    5824:	00800234 	movhi	r2,8
    5828:	1083bd04 	addi	r2,r2,3828
    582c:	10c0180d 	sth	r3,96(r2)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
    5830:	e0bffa0f 	ldh	r2,-24(fp)
    5834:	e13ffe17 	ldw	r4,-8(fp)
    5838:	100b883a 	mov	r5,r2
    583c:	000a83c0 	call	a83c <pbuf_header>
    5840:	10803fcc 	andi	r2,r2,255
    5844:	10000926 	beq	r2,zero,586c <icmp_input+0x470>
      LWIP_ASSERT("Can't move over header in packet", 0);
    5848:	010000f4 	movhi	r4,3
    584c:	213de804 	addi	r4,r4,-2144
    5850:	014000f4 	movhi	r5,3
    5854:	297e2b04 	addi	r5,r5,-1876
    5858:	01803684 	movi	r6,218
    585c:	01c000f4 	movhi	r7,3
    5860:	39fdff04 	addi	r7,r7,-2052
    5864:	00193f00 	call	193f0 <printf>
    5868:	003fff06 	br	5868 <icmp_input+0x46c>
    } else {
      err_t ret;
      /* send an ICMP packet, src addr is the dest addr of the curren packet */
      ret = ip_output_if(p, ip_current_dest_addr(), IP_HDRINCL,
    586c:	d8000015 	stw	zero,0(sp)
    5870:	00800044 	movi	r2,1
    5874:	d8800115 	stw	r2,4(sp)
    5878:	e0bfff17 	ldw	r2,-4(fp)
    587c:	d8800215 	stw	r2,8(sp)
    5880:	e13ffe17 	ldw	r4,-8(fp)
    5884:	014000f4 	movhi	r5,3
    5888:	295e2104 	addi	r5,r5,30852
    588c:	000d883a 	mov	r6,zero
    5890:	01c03fc4 	movi	r7,255
    5894:	00068540 	call	6854 <ip_output_if>
    5898:	e0bffd05 	stb	r2,-12(fp)
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
      }
    }
    break;
    589c:	00001206 	br	58e8 <icmp_input+0x4ec>
  default:
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    58a0:	00800234 	movhi	r2,8
    58a4:	1083bd04 	addi	r2,r2,3828
    58a8:	10801c0b 	ldhu	r2,112(r2)
    58ac:	10800044 	addi	r2,r2,1
    58b0:	1007883a 	mov	r3,r2
    58b4:	00800234 	movhi	r2,8
    58b8:	1083bd04 	addi	r2,r2,3828
    58bc:	10c01c0d 	sth	r3,112(r2)
    ICMP_STATS_INC(icmp.drop);
    58c0:	00800234 	movhi	r2,8
    58c4:	1083bd04 	addi	r2,r2,3828
    58c8:	1080198b 	ldhu	r2,102(r2)
    58cc:	10800044 	addi	r2,r2,1
    58d0:	1007883a 	mov	r3,r2
    58d4:	00800234 	movhi	r2,8
    58d8:	1083bd04 	addi	r2,r2,3828
    58dc:	10c0198d 	sth	r3,102(r2)
    58e0:	00000106 	br	58e8 <icmp_input+0x4ec>
#endif /* LWIP_DEBUG */
  switch (type) {
  case ICMP_ER:
    /* This is OK, echo reply might have been parsed by a raw PCB
       (as obviously, an echo request has been sent, too). */
    break; 
    58e4:	0001883a 	nop
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
    58e8:	e13ffe17 	ldw	r4,-8(fp)
    58ec:	000aa340 	call	aa34 <pbuf_free>
  return;
    58f0:	00001806 	br	5954 <icmp_input+0x558>
    }
#endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    58f4:	0001883a 	nop
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  return;
lenerr:
  pbuf_free(p);
    58f8:	e13ffe17 	ldw	r4,-8(fp)
    58fc:	000aa340 	call	aa34 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
    5900:	00800234 	movhi	r2,8
    5904:	1083bd04 	addi	r2,r2,3828
    5908:	10801a8b 	ldhu	r2,106(r2)
    590c:	10800044 	addi	r2,r2,1
    5910:	1007883a 	mov	r3,r2
    5914:	00800234 	movhi	r2,8
    5918:	1083bd04 	addi	r2,r2,3828
    591c:	10c01a8d 	sth	r3,106(r2)
  snmp_inc_icmpinerrors();
  return;
    5920:	00000c06 	br	5954 <icmp_input+0x558>
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
      if (r == NULL) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
    5924:	0001883a 	nop
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
memerr:
  pbuf_free(p);
    5928:	e13ffe17 	ldw	r4,-8(fp)
    592c:	000aa340 	call	aa34 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
    5930:	00800234 	movhi	r2,8
    5934:	1083bd04 	addi	r2,r2,3828
    5938:	10801d0b 	ldhu	r2,116(r2)
    593c:	10800044 	addi	r2,r2,1
    5940:	1007883a 	mov	r3,r2
    5944:	00800234 	movhi	r2,8
    5948:	1083bd04 	addi	r2,r2,3828
    594c:	10c01d0d 	sth	r3,116(r2)
  snmp_inc_icmpinerrors();
  return;
    5950:	0001883a 	nop
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
}
    5954:	e037883a 	mov	sp,fp
    5958:	dfc00117 	ldw	ra,4(sp)
    595c:	df000017 	ldw	fp,0(sp)
    5960:	dec00204 	addi	sp,sp,8
    5964:	f800283a 	ret

00005968 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
    5968:	defffc04 	addi	sp,sp,-16
    596c:	dfc00315 	stw	ra,12(sp)
    5970:	df000215 	stw	fp,8(sp)
    5974:	df000204 	addi	fp,sp,8
    5978:	e13ffe15 	stw	r4,-8(fp)
    597c:	e17fff15 	stw	r5,-4(fp)
  icmp_send_response(p, ICMP_DUR, t);
    5980:	e0bfff17 	ldw	r2,-4(fp)
    5984:	10803fcc 	andi	r2,r2,255
    5988:	e13ffe17 	ldw	r4,-8(fp)
    598c:	014000c4 	movi	r5,3
    5990:	100d883a 	mov	r6,r2
    5994:	00059f00 	call	59f0 <icmp_send_response>
}
    5998:	e037883a 	mov	sp,fp
    599c:	dfc00117 	ldw	ra,4(sp)
    59a0:	df000017 	ldw	fp,0(sp)
    59a4:	dec00204 	addi	sp,sp,8
    59a8:	f800283a 	ret

000059ac <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
    59ac:	defffc04 	addi	sp,sp,-16
    59b0:	dfc00315 	stw	ra,12(sp)
    59b4:	df000215 	stw	fp,8(sp)
    59b8:	df000204 	addi	fp,sp,8
    59bc:	e13ffe15 	stw	r4,-8(fp)
    59c0:	e17fff15 	stw	r5,-4(fp)
  icmp_send_response(p, ICMP_TE, t);
    59c4:	e0bfff17 	ldw	r2,-4(fp)
    59c8:	10803fcc 	andi	r2,r2,255
    59cc:	e13ffe17 	ldw	r4,-8(fp)
    59d0:	014002c4 	movi	r5,11
    59d4:	100d883a 	mov	r6,r2
    59d8:	00059f00 	call	59f0 <icmp_send_response>
}
    59dc:	e037883a 	mov	sp,fp
    59e0:	dfc00117 	ldw	ra,4(sp)
    59e4:	df000017 	ldw	fp,0(sp)
    59e8:	dec00204 	addi	sp,sp,8
    59ec:	f800283a 	ret

000059f0 <icmp_send_response>:
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
    59f0:	defff504 	addi	sp,sp,-44
    59f4:	dfc00a15 	stw	ra,40(sp)
    59f8:	df000915 	stw	fp,36(sp)
    59fc:	df000904 	addi	fp,sp,36
    5a00:	e13ffd15 	stw	r4,-12(fp)
    5a04:	2807883a 	mov	r3,r5
    5a08:	3005883a 	mov	r2,r6
    5a0c:	e0fffe05 	stb	r3,-8(fp)
    5a10:	e0bfff05 	stb	r2,-4(fp)
  /* we can use the echo header here */
  struct icmp_echo_hdr *icmphdr;
  ip_addr_t iphdr_src;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
    5a14:	01000044 	movi	r4,1
    5a18:	01400904 	movi	r5,36
    5a1c:	000d883a 	mov	r6,zero
    5a20:	000a0740 	call	a074 <pbuf_alloc>
    5a24:	e0bff915 	stw	r2,-28(fp)
                 PBUF_RAM);
  if (q == NULL) {
    5a28:	e0bff917 	ldw	r2,-28(fp)
    5a2c:	10004a26 	beq	r2,zero,5b58 <icmp_send_response+0x168>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
    5a30:	e0bff917 	ldw	r2,-28(fp)
    5a34:	1080028b 	ldhu	r2,10(r2)
    5a38:	10bfffcc 	andi	r2,r2,65535
    5a3c:	10800928 	cmpgeui	r2,r2,36
    5a40:	1000091e 	bne	r2,zero,5a68 <icmp_send_response+0x78>
    5a44:	010000f4 	movhi	r4,3
    5a48:	213de804 	addi	r4,r4,-2144
    5a4c:	014000f4 	movhi	r5,3
    5a50:	297e3404 	addi	r5,r5,-1840
    5a54:	01804cc4 	movi	r6,307
    5a58:	01c000f4 	movhi	r7,3
    5a5c:	39fdff04 	addi	r7,r7,-2052
    5a60:	00193f00 	call	193f0 <printf>
    5a64:	003fff06 	br	5a64 <icmp_send_response+0x74>
             (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = (struct ip_hdr *)p->payload;
    5a68:	e0bffd17 	ldw	r2,-12(fp)
    5a6c:	10800117 	ldw	r2,4(r2)
    5a70:	e0bffa15 	stw	r2,-24(fp)
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
    5a74:	e0bff917 	ldw	r2,-28(fp)
    5a78:	10800117 	ldw	r2,4(r2)
    5a7c:	e0bffb15 	stw	r2,-20(fp)
  icmphdr->type = type;
    5a80:	e0bffb17 	ldw	r2,-20(fp)
    5a84:	e0fffe03 	ldbu	r3,-8(fp)
    5a88:	10c00005 	stb	r3,0(r2)
  icmphdr->code = code;
    5a8c:	e0bffb17 	ldw	r2,-20(fp)
    5a90:	e0ffff03 	ldbu	r3,-4(fp)
    5a94:	10c00045 	stb	r3,1(r2)
  icmphdr->id = 0;
    5a98:	e0bffb17 	ldw	r2,-20(fp)
    5a9c:	1000010d 	sth	zero,4(r2)
  icmphdr->seqno = 0;
    5aa0:	e0bffb17 	ldw	r2,-20(fp)
    5aa4:	1000018d 	sth	zero,6(r2)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
    5aa8:	e0bff917 	ldw	r2,-28(fp)
    5aac:	10800117 	ldw	r2,4(r2)
    5ab0:	10c00204 	addi	r3,r2,8
    5ab4:	e0bffd17 	ldw	r2,-12(fp)
    5ab8:	10800117 	ldw	r2,4(r2)
    5abc:	1809883a 	mov	r4,r3
    5ac0:	100b883a 	mov	r5,r2
    5ac4:	01800704 	movi	r6,28
    5ac8:	00191f00 	call	191f0 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  icmphdr->chksum = 0;
    5acc:	e0bffb17 	ldw	r2,-20(fp)
    5ad0:	1000008d 	sth	zero,2(r2)
  icmphdr->chksum = inet_chksum(icmphdr, q->len);
    5ad4:	e0bff917 	ldw	r2,-28(fp)
    5ad8:	1080028b 	ldhu	r2,10(r2)
    5adc:	10bfffcc 	andi	r2,r2,65535
    5ae0:	e13ffb17 	ldw	r4,-20(fp)
    5ae4:	100b883a 	mov	r5,r2
    5ae8:	00061100 	call	6110 <inet_chksum>
    5aec:	e0fffb17 	ldw	r3,-20(fp)
    5af0:	1880008d 	sth	r2,2(r3)
  ICMP_STATS_INC(icmp.xmit);
    5af4:	00800234 	movhi	r2,8
    5af8:	1083bd04 	addi	r2,r2,3828
    5afc:	1080180b 	ldhu	r2,96(r2)
    5b00:	10800044 	addi	r2,r2,1
    5b04:	1007883a 	mov	r3,r2
    5b08:	00800234 	movhi	r2,8
    5b0c:	1083bd04 	addi	r2,r2,3828
    5b10:	10c0180d 	sth	r3,96(r2)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_addr_copy(iphdr_src, iphdr->src);
    5b14:	e0bffa17 	ldw	r2,-24(fp)
    5b18:	10c0030b 	ldhu	r3,12(r2)
    5b1c:	1080038b 	ldhu	r2,14(r2)
    5b20:	1004943a 	slli	r2,r2,16
    5b24:	10c4b03a 	or	r2,r2,r3
    5b28:	e0bffc15 	stw	r2,-16(fp)
  ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
    5b2c:	e0bffc04 	addi	r2,fp,-16
    5b30:	d8000015 	stw	zero,0(sp)
    5b34:	00c00044 	movi	r3,1
    5b38:	d8c00115 	stw	r3,4(sp)
    5b3c:	e13ff917 	ldw	r4,-28(fp)
    5b40:	000b883a 	mov	r5,zero
    5b44:	100d883a 	mov	r6,r2
    5b48:	01c03fc4 	movi	r7,255
    5b4c:	0006cbc0 	call	6cbc <ip_output>
  pbuf_free(q);
    5b50:	e13ff917 	ldw	r4,-28(fp)
    5b54:	000aa340 	call	aa34 <pbuf_free>
}
    5b58:	e037883a 	mov	sp,fp
    5b5c:	dfc00117 	ldw	ra,4(sp)
    5b60:	df000017 	ldw	fp,0(sp)
    5b64:	dec00204 	addi	sp,sp,8
    5b68:	f800283a 	ret

00005b6c <lwip_standard_chksum>:
 * @return host order (!) lwip checksum (non-inverted Internet sum) 
 */

static u16_t
lwip_standard_chksum(void *dataptr, int len)
{
    5b6c:	defff804 	addi	sp,sp,-32
    5b70:	df000715 	stw	fp,28(sp)
    5b74:	df000704 	addi	fp,sp,28
    5b78:	e13ffe15 	stw	r4,-8(fp)
    5b7c:	e17fff15 	stw	r5,-4(fp)
  u8_t *pb = (u8_t *)dataptr;
    5b80:	e0bffe17 	ldw	r2,-8(fp)
    5b84:	e0bff915 	stw	r2,-28(fp)
  u16_t *ps, t = 0;
    5b88:	e03ffd0d 	sth	zero,-12(fp)
  u32_t sum = 0;
    5b8c:	e03ffb15 	stw	zero,-20(fp)
  int odd = ((mem_ptr_t)pb & 1);
    5b90:	e0bff917 	ldw	r2,-28(fp)
    5b94:	1080004c 	andi	r2,r2,1
    5b98:	e0bffc15 	stw	r2,-16(fp)

  /* Get aligned to u16_t */
  if (odd && len > 0) {
    5b9c:	e0bffc17 	ldw	r2,-16(fp)
    5ba0:	10000d26 	beq	r2,zero,5bd8 <lwip_standard_chksum+0x6c>
    5ba4:	e0bfff17 	ldw	r2,-4(fp)
    5ba8:	00800b0e 	bge	zero,r2,5bd8 <lwip_standard_chksum+0x6c>
    ((u8_t *)&t)[1] = *pb++;
    5bac:	e0bffd04 	addi	r2,fp,-12
    5bb0:	10800044 	addi	r2,r2,1
    5bb4:	e0fff917 	ldw	r3,-28(fp)
    5bb8:	18c00003 	ldbu	r3,0(r3)
    5bbc:	10c00005 	stb	r3,0(r2)
    5bc0:	e0bff917 	ldw	r2,-28(fp)
    5bc4:	10800044 	addi	r2,r2,1
    5bc8:	e0bff915 	stw	r2,-28(fp)
    len--;
    5bcc:	e0bfff17 	ldw	r2,-4(fp)
    5bd0:	10bfffc4 	addi	r2,r2,-1
    5bd4:	e0bfff15 	stw	r2,-4(fp)
  }

  /* Add the bulk of the data */
  ps = (u16_t *)(void *)pb;
    5bd8:	e0bff917 	ldw	r2,-28(fp)
    5bdc:	e0bffa15 	stw	r2,-24(fp)
  while (len > 1) {
    5be0:	00000c06 	br	5c14 <lwip_standard_chksum+0xa8>
    sum += *ps++;
    5be4:	e0bffa17 	ldw	r2,-24(fp)
    5be8:	1080000b 	ldhu	r2,0(r2)
    5bec:	10bfffcc 	andi	r2,r2,65535
    5bf0:	e0fffb17 	ldw	r3,-20(fp)
    5bf4:	1885883a 	add	r2,r3,r2
    5bf8:	e0bffb15 	stw	r2,-20(fp)
    5bfc:	e0bffa17 	ldw	r2,-24(fp)
    5c00:	10800084 	addi	r2,r2,2
    5c04:	e0bffa15 	stw	r2,-24(fp)
    len -= 2;
    5c08:	e0bfff17 	ldw	r2,-4(fp)
    5c0c:	10bfff84 	addi	r2,r2,-2
    5c10:	e0bfff15 	stw	r2,-4(fp)
    len--;
  }

  /* Add the bulk of the data */
  ps = (u16_t *)(void *)pb;
  while (len > 1) {
    5c14:	e0bfff17 	ldw	r2,-4(fp)
    5c18:	10800088 	cmpgei	r2,r2,2
    5c1c:	103ff11e 	bne	r2,zero,5be4 <lwip_standard_chksum+0x78>
    sum += *ps++;
    len -= 2;
  }

  /* Consume left-over byte, if any */
  if (len > 0) {
    5c20:	e0bfff17 	ldw	r2,-4(fp)
    5c24:	0080040e 	bge	zero,r2,5c38 <lwip_standard_chksum+0xcc>
    ((u8_t *)&t)[0] = *(u8_t *)ps;
    5c28:	e0bffd04 	addi	r2,fp,-12
    5c2c:	e0fffa17 	ldw	r3,-24(fp)
    5c30:	18c00003 	ldbu	r3,0(r3)
    5c34:	10c00005 	stb	r3,0(r2)
  }

  /* Add end bytes */
  sum += t;
    5c38:	e0bffd0b 	ldhu	r2,-12(fp)
    5c3c:	10bfffcc 	andi	r2,r2,65535
    5c40:	e0fffb17 	ldw	r3,-20(fp)
    5c44:	1885883a 	add	r2,r3,r2
    5c48:	e0bffb15 	stw	r2,-20(fp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  sum = FOLD_U32T(sum);
    5c4c:	e0bffb17 	ldw	r2,-20(fp)
    5c50:	1006d43a 	srli	r3,r2,16
    5c54:	e0bffb17 	ldw	r2,-20(fp)
    5c58:	10bfffcc 	andi	r2,r2,65535
    5c5c:	1885883a 	add	r2,r3,r2
    5c60:	e0bffb15 	stw	r2,-20(fp)
  sum = FOLD_U32T(sum);
    5c64:	e0bffb17 	ldw	r2,-20(fp)
    5c68:	1006d43a 	srli	r3,r2,16
    5c6c:	e0bffb17 	ldw	r2,-20(fp)
    5c70:	10bfffcc 	andi	r2,r2,65535
    5c74:	1885883a 	add	r2,r3,r2
    5c78:	e0bffb15 	stw	r2,-20(fp)

  /* Swap if alignment was odd */
  if (odd) {
    5c7c:	e0bffc17 	ldw	r2,-16(fp)
    5c80:	10000826 	beq	r2,zero,5ca4 <lwip_standard_chksum+0x138>
    sum = SWAP_BYTES_IN_WORD(sum);
    5c84:	e0bffb17 	ldw	r2,-20(fp)
    5c88:	10bfc00c 	andi	r2,r2,65280
    5c8c:	1006d23a 	srli	r3,r2,8
    5c90:	e0bffb17 	ldw	r2,-20(fp)
    5c94:	1004923a 	slli	r2,r2,8
    5c98:	10bfffcc 	andi	r2,r2,65535
    5c9c:	1884b03a 	or	r2,r3,r2
    5ca0:	e0bffb15 	stw	r2,-20(fp)
  }

  return (u16_t)sum;
    5ca4:	e0bffb17 	ldw	r2,-20(fp)
}
    5ca8:	e037883a 	mov	sp,fp
    5cac:	df000017 	ldw	fp,0(sp)
    5cb0:	dec00104 	addi	sp,sp,4
    5cb4:	f800283a 	ret

00005cb8 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       ip_addr_t *src, ip_addr_t *dest,
       u8_t proto, u16_t proto_len)
{
    5cb8:	defff504 	addi	sp,sp,-44
    5cbc:	dfc00a15 	stw	ra,40(sp)
    5cc0:	df000915 	stw	fp,36(sp)
    5cc4:	df000904 	addi	fp,sp,36
    5cc8:	e13ffb15 	stw	r4,-20(fp)
    5ccc:	e17ffc15 	stw	r5,-16(fp)
    5cd0:	e1bffd15 	stw	r6,-12(fp)
    5cd4:	3805883a 	mov	r2,r7
    5cd8:	e0c00217 	ldw	r3,8(fp)
    5cdc:	e0bffe05 	stb	r2,-8(fp)
    5ce0:	e0ffff0d 	sth	r3,-4(fp)
  u32_t acc;
  u32_t addr;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
    5ce4:	e03ff715 	stw	zero,-36(fp)
  swapped = 0;
    5ce8:	e03ff905 	stb	zero,-28(fp)
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
    5cec:	e0bffb17 	ldw	r2,-20(fp)
    5cf0:	e0bff815 	stw	r2,-32(fp)
    5cf4:	00002606 	br	5d90 <inet_chksum_pseudo+0xd8>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
    5cf8:	e0bff817 	ldw	r2,-32(fp)
    5cfc:	10c00117 	ldw	r3,4(r2)
    5d00:	e0bff817 	ldw	r2,-32(fp)
    5d04:	1080028b 	ldhu	r2,10(r2)
    5d08:	10bfffcc 	andi	r2,r2,65535
    5d0c:	1809883a 	mov	r4,r3
    5d10:	100b883a 	mov	r5,r2
    5d14:	0005b6c0 	call	5b6c <lwip_standard_chksum>
    5d18:	10bfffcc 	andi	r2,r2,65535
    5d1c:	e0fff717 	ldw	r3,-36(fp)
    5d20:	1885883a 	add	r2,r3,r2
    5d24:	e0bff715 	stw	r2,-36(fp)
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
    5d28:	e0bff717 	ldw	r2,-36(fp)
    5d2c:	1006d43a 	srli	r3,r2,16
    5d30:	e0bff717 	ldw	r2,-36(fp)
    5d34:	10bfffcc 	andi	r2,r2,65535
    5d38:	1885883a 	add	r2,r3,r2
    5d3c:	e0bff715 	stw	r2,-36(fp)
    if (q->len % 2 != 0) {
    5d40:	e0bff817 	ldw	r2,-32(fp)
    5d44:	1080028b 	ldhu	r2,10(r2)
    5d48:	1080004c 	andi	r2,r2,1
    5d4c:	10bfffcc 	andi	r2,r2,65535
    5d50:	10000c26 	beq	r2,zero,5d84 <inet_chksum_pseudo+0xcc>
      swapped = 1 - swapped;
    5d54:	e0bff903 	ldbu	r2,-28(fp)
    5d58:	00c00044 	movi	r3,1
    5d5c:	1885c83a 	sub	r2,r3,r2
    5d60:	e0bff905 	stb	r2,-28(fp)
      acc = SWAP_BYTES_IN_WORD(acc);
    5d64:	e0bff717 	ldw	r2,-36(fp)
    5d68:	10bfc00c 	andi	r2,r2,65280
    5d6c:	1006d23a 	srli	r3,r2,8
    5d70:	e0bff717 	ldw	r2,-36(fp)
    5d74:	1004923a 	slli	r2,r2,8
    5d78:	10bfffcc 	andi	r2,r2,65535
    5d7c:	1884b03a 	or	r2,r3,r2
    5d80:	e0bff715 	stw	r2,-36(fp)
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
    5d84:	e0bff817 	ldw	r2,-32(fp)
    5d88:	10800017 	ldw	r2,0(r2)
    5d8c:	e0bff815 	stw	r2,-32(fp)
    5d90:	e0bff817 	ldw	r2,-32(fp)
    5d94:	103fd81e 	bne	r2,zero,5cf8 <inet_chksum_pseudo+0x40>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
    5d98:	e0bff903 	ldbu	r2,-28(fp)
    5d9c:	10000826 	beq	r2,zero,5dc0 <inet_chksum_pseudo+0x108>
    acc = SWAP_BYTES_IN_WORD(acc);
    5da0:	e0bff717 	ldw	r2,-36(fp)
    5da4:	10bfc00c 	andi	r2,r2,65280
    5da8:	1006d23a 	srli	r3,r2,8
    5dac:	e0bff717 	ldw	r2,-36(fp)
    5db0:	1004923a 	slli	r2,r2,8
    5db4:	10bfffcc 	andi	r2,r2,65535
    5db8:	1884b03a 	or	r2,r3,r2
    5dbc:	e0bff715 	stw	r2,-36(fp)
  }
  addr = ip4_addr_get_u32(src);
    5dc0:	e0bffc17 	ldw	r2,-16(fp)
    5dc4:	10800017 	ldw	r2,0(r2)
    5dc8:	e0bffa15 	stw	r2,-24(fp)
  acc += (addr & 0xffffUL);
    5dcc:	e0bffa17 	ldw	r2,-24(fp)
    5dd0:	10bfffcc 	andi	r2,r2,65535
    5dd4:	e0fff717 	ldw	r3,-36(fp)
    5dd8:	1885883a 	add	r2,r3,r2
    5ddc:	e0bff715 	stw	r2,-36(fp)
  acc += ((addr >> 16) & 0xffffUL);
    5de0:	e0bffa17 	ldw	r2,-24(fp)
    5de4:	1004d43a 	srli	r2,r2,16
    5de8:	e0fff717 	ldw	r3,-36(fp)
    5dec:	1885883a 	add	r2,r3,r2
    5df0:	e0bff715 	stw	r2,-36(fp)
  addr = ip4_addr_get_u32(dest);
    5df4:	e0bffd17 	ldw	r2,-12(fp)
    5df8:	10800017 	ldw	r2,0(r2)
    5dfc:	e0bffa15 	stw	r2,-24(fp)
  acc += (addr & 0xffffUL);
    5e00:	e0bffa17 	ldw	r2,-24(fp)
    5e04:	10bfffcc 	andi	r2,r2,65535
    5e08:	e0fff717 	ldw	r3,-36(fp)
    5e0c:	1885883a 	add	r2,r3,r2
    5e10:	e0bff715 	stw	r2,-36(fp)
  acc += ((addr >> 16) & 0xffffUL);
    5e14:	e0bffa17 	ldw	r2,-24(fp)
    5e18:	1004d43a 	srli	r2,r2,16
    5e1c:	e0fff717 	ldw	r3,-36(fp)
    5e20:	1885883a 	add	r2,r3,r2
    5e24:	e0bff715 	stw	r2,-36(fp)
  acc += (u32_t)htons((u16_t)proto);
    5e28:	e0bffe03 	ldbu	r2,-8(fp)
    5e2c:	1004923a 	slli	r2,r2,8
    5e30:	e0fff717 	ldw	r3,-36(fp)
    5e34:	1885883a 	add	r2,r3,r2
    5e38:	e0bff715 	stw	r2,-36(fp)
  acc += (u32_t)htons(proto_len);
    5e3c:	e0bfff0b 	ldhu	r2,-4(fp)
    5e40:	1004d23a 	srli	r2,r2,8
    5e44:	10ffffcc 	andi	r3,r2,65535
    5e48:	e0bfff0b 	ldhu	r2,-4(fp)
    5e4c:	1004923a 	slli	r2,r2,8
    5e50:	10bfffcc 	andi	r2,r2,65535
    5e54:	1884b03a 	or	r2,r3,r2
    5e58:	e0fff717 	ldw	r3,-36(fp)
    5e5c:	1885883a 	add	r2,r3,r2
    5e60:	e0bff715 	stw	r2,-36(fp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
    5e64:	e0bff717 	ldw	r2,-36(fp)
    5e68:	1006d43a 	srli	r3,r2,16
    5e6c:	e0bff717 	ldw	r2,-36(fp)
    5e70:	10bfffcc 	andi	r2,r2,65535
    5e74:	1885883a 	add	r2,r3,r2
    5e78:	e0bff715 	stw	r2,-36(fp)
  acc = FOLD_U32T(acc);
    5e7c:	e0bff717 	ldw	r2,-36(fp)
    5e80:	1006d43a 	srli	r3,r2,16
    5e84:	e0bff717 	ldw	r2,-36(fp)
    5e88:	10bfffcc 	andi	r2,r2,65535
    5e8c:	1885883a 	add	r2,r3,r2
    5e90:	e0bff715 	stw	r2,-36(fp)
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
    5e94:	e0bff717 	ldw	r2,-36(fp)
    5e98:	0084303a 	nor	r2,zero,r2
}
    5e9c:	e037883a 	mov	sp,fp
    5ea0:	dfc00117 	ldw	ra,4(sp)
    5ea4:	df000017 	ldw	fp,0(sp)
    5ea8:	dec00204 	addi	sp,sp,8
    5eac:	f800283a 	ret

00005eb0 <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       ip_addr_t *src, ip_addr_t *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
    5eb0:	defff404 	addi	sp,sp,-48
    5eb4:	dfc00b15 	stw	ra,44(sp)
    5eb8:	df000a15 	stw	fp,40(sp)
    5ebc:	df000a04 	addi	fp,sp,40
    5ec0:	e13ffa15 	stw	r4,-24(fp)
    5ec4:	e17ffb15 	stw	r5,-20(fp)
    5ec8:	e1bffc15 	stw	r6,-16(fp)
    5ecc:	3805883a 	mov	r2,r7
    5ed0:	e1000217 	ldw	r4,8(fp)
    5ed4:	e0c00317 	ldw	r3,12(fp)
    5ed8:	e0bffd05 	stb	r2,-12(fp)
    5edc:	e13ffe0d 	sth	r4,-8(fp)
    5ee0:	e0ffff0d 	sth	r3,-4(fp)
  u32_t addr;
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
    5ee4:	e03ff615 	stw	zero,-40(fp)
  swapped = 0;
    5ee8:	e03ff805 	stb	zero,-32(fp)
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
    5eec:	e0bffa17 	ldw	r2,-24(fp)
    5ef0:	e0bff715 	stw	r2,-36(fp)
    5ef4:	00003c06 	br	5fe8 <inet_chksum_pseudo_partial+0x138>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
    5ef8:	e0bff717 	ldw	r2,-36(fp)
    5efc:	1080028b 	ldhu	r2,10(r2)
    5f00:	e0bff88d 	sth	r2,-30(fp)
    if (chklen > chksum_len) {
    5f04:	e0bff88b 	ldhu	r2,-30(fp)
    5f08:	e0ffff0b 	ldhu	r3,-4(fp)
    5f0c:	1880022e 	bgeu	r3,r2,5f18 <inet_chksum_pseudo_partial+0x68>
      chklen = chksum_len;
    5f10:	e0bfff0b 	ldhu	r2,-4(fp)
    5f14:	e0bff88d 	sth	r2,-30(fp)
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
    5f18:	e0bff717 	ldw	r2,-36(fp)
    5f1c:	10c00117 	ldw	r3,4(r2)
    5f20:	e0bff88b 	ldhu	r2,-30(fp)
    5f24:	1809883a 	mov	r4,r3
    5f28:	100b883a 	mov	r5,r2
    5f2c:	0005b6c0 	call	5b6c <lwip_standard_chksum>
    5f30:	10bfffcc 	andi	r2,r2,65535
    5f34:	e0fff617 	ldw	r3,-40(fp)
    5f38:	1885883a 	add	r2,r3,r2
    5f3c:	e0bff615 	stw	r2,-40(fp)
    chksum_len -= chklen;
    5f40:	e0ffff0b 	ldhu	r3,-4(fp)
    5f44:	e0bff88b 	ldhu	r2,-30(fp)
    5f48:	1885c83a 	sub	r2,r3,r2
    5f4c:	e0bfff0d 	sth	r2,-4(fp)
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
    5f50:	e0bfff0b 	ldhu	r2,-4(fp)
    5f54:	109ffff0 	cmpltui	r2,r2,32767
    5f58:	1000091e 	bne	r2,zero,5f80 <inet_chksum_pseudo_partial+0xd0>
    5f5c:	010000f4 	movhi	r4,3
    5f60:	213e3f04 	addi	r4,r4,-1796
    5f64:	014000f4 	movhi	r5,3
    5f68:	297e4904 	addi	r5,r5,-1756
    5f6c:	01805884 	movi	r6,354
    5f70:	01c000f4 	movhi	r7,3
    5f74:	39fe4c04 	addi	r7,r7,-1744
    5f78:	00193f00 	call	193f0 <printf>
    5f7c:	003fff06 	br	5f7c <inet_chksum_pseudo_partial+0xcc>
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
    5f80:	e0bff617 	ldw	r2,-40(fp)
    5f84:	1006d43a 	srli	r3,r2,16
    5f88:	e0bff617 	ldw	r2,-40(fp)
    5f8c:	10bfffcc 	andi	r2,r2,65535
    5f90:	1885883a 	add	r2,r3,r2
    5f94:	e0bff615 	stw	r2,-40(fp)
    if (q->len % 2 != 0) {
    5f98:	e0bff717 	ldw	r2,-36(fp)
    5f9c:	1080028b 	ldhu	r2,10(r2)
    5fa0:	1080004c 	andi	r2,r2,1
    5fa4:	10bfffcc 	andi	r2,r2,65535
    5fa8:	10000c26 	beq	r2,zero,5fdc <inet_chksum_pseudo_partial+0x12c>
      swapped = 1 - swapped;
    5fac:	e0bff803 	ldbu	r2,-32(fp)
    5fb0:	00c00044 	movi	r3,1
    5fb4:	1885c83a 	sub	r2,r3,r2
    5fb8:	e0bff805 	stb	r2,-32(fp)
      acc = SWAP_BYTES_IN_WORD(acc);
    5fbc:	e0bff617 	ldw	r2,-40(fp)
    5fc0:	10bfc00c 	andi	r2,r2,65280
    5fc4:	1006d23a 	srli	r3,r2,8
    5fc8:	e0bff617 	ldw	r2,-40(fp)
    5fcc:	1004923a 	slli	r2,r2,8
    5fd0:	10bfffcc 	andi	r2,r2,65535
    5fd4:	1884b03a 	or	r2,r3,r2
    5fd8:	e0bff615 	stw	r2,-40(fp)
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
    5fdc:	e0bff717 	ldw	r2,-36(fp)
    5fe0:	10800017 	ldw	r2,0(r2)
    5fe4:	e0bff715 	stw	r2,-36(fp)
    5fe8:	e0bff717 	ldw	r2,-36(fp)
    5fec:	10000226 	beq	r2,zero,5ff8 <inet_chksum_pseudo_partial+0x148>
    5ff0:	e0bfff0b 	ldhu	r2,-4(fp)
    5ff4:	103fc01e 	bne	r2,zero,5ef8 <inet_chksum_pseudo_partial+0x48>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
    5ff8:	e0bff803 	ldbu	r2,-32(fp)
    5ffc:	10000826 	beq	r2,zero,6020 <inet_chksum_pseudo_partial+0x170>
    acc = SWAP_BYTES_IN_WORD(acc);
    6000:	e0bff617 	ldw	r2,-40(fp)
    6004:	10bfc00c 	andi	r2,r2,65280
    6008:	1006d23a 	srli	r3,r2,8
    600c:	e0bff617 	ldw	r2,-40(fp)
    6010:	1004923a 	slli	r2,r2,8
    6014:	10bfffcc 	andi	r2,r2,65535
    6018:	1884b03a 	or	r2,r3,r2
    601c:	e0bff615 	stw	r2,-40(fp)
  }
  addr = ip4_addr_get_u32(src);
    6020:	e0bffb17 	ldw	r2,-20(fp)
    6024:	10800017 	ldw	r2,0(r2)
    6028:	e0bff915 	stw	r2,-28(fp)
  acc += (addr & 0xffffUL);
    602c:	e0bff917 	ldw	r2,-28(fp)
    6030:	10bfffcc 	andi	r2,r2,65535
    6034:	e0fff617 	ldw	r3,-40(fp)
    6038:	1885883a 	add	r2,r3,r2
    603c:	e0bff615 	stw	r2,-40(fp)
  acc += ((addr >> 16) & 0xffffUL);
    6040:	e0bff917 	ldw	r2,-28(fp)
    6044:	1004d43a 	srli	r2,r2,16
    6048:	e0fff617 	ldw	r3,-40(fp)
    604c:	1885883a 	add	r2,r3,r2
    6050:	e0bff615 	stw	r2,-40(fp)
  addr = ip4_addr_get_u32(dest);
    6054:	e0bffc17 	ldw	r2,-16(fp)
    6058:	10800017 	ldw	r2,0(r2)
    605c:	e0bff915 	stw	r2,-28(fp)
  acc += (addr & 0xffffUL);
    6060:	e0bff917 	ldw	r2,-28(fp)
    6064:	10bfffcc 	andi	r2,r2,65535
    6068:	e0fff617 	ldw	r3,-40(fp)
    606c:	1885883a 	add	r2,r3,r2
    6070:	e0bff615 	stw	r2,-40(fp)
  acc += ((addr >> 16) & 0xffffUL);
    6074:	e0bff917 	ldw	r2,-28(fp)
    6078:	1004d43a 	srli	r2,r2,16
    607c:	e0fff617 	ldw	r3,-40(fp)
    6080:	1885883a 	add	r2,r3,r2
    6084:	e0bff615 	stw	r2,-40(fp)
  acc += (u32_t)htons((u16_t)proto);
    6088:	e0bffd03 	ldbu	r2,-12(fp)
    608c:	1004923a 	slli	r2,r2,8
    6090:	e0fff617 	ldw	r3,-40(fp)
    6094:	1885883a 	add	r2,r3,r2
    6098:	e0bff615 	stw	r2,-40(fp)
  acc += (u32_t)htons(proto_len);
    609c:	e0bffe0b 	ldhu	r2,-8(fp)
    60a0:	1004d23a 	srli	r2,r2,8
    60a4:	10ffffcc 	andi	r3,r2,65535
    60a8:	e0bffe0b 	ldhu	r2,-8(fp)
    60ac:	1004923a 	slli	r2,r2,8
    60b0:	10bfffcc 	andi	r2,r2,65535
    60b4:	1884b03a 	or	r2,r3,r2
    60b8:	e0fff617 	ldw	r3,-40(fp)
    60bc:	1885883a 	add	r2,r3,r2
    60c0:	e0bff615 	stw	r2,-40(fp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
    60c4:	e0bff617 	ldw	r2,-40(fp)
    60c8:	1006d43a 	srli	r3,r2,16
    60cc:	e0bff617 	ldw	r2,-40(fp)
    60d0:	10bfffcc 	andi	r2,r2,65535
    60d4:	1885883a 	add	r2,r3,r2
    60d8:	e0bff615 	stw	r2,-40(fp)
  acc = FOLD_U32T(acc);
    60dc:	e0bff617 	ldw	r2,-40(fp)
    60e0:	1006d43a 	srli	r3,r2,16
    60e4:	e0bff617 	ldw	r2,-40(fp)
    60e8:	10bfffcc 	andi	r2,r2,65535
    60ec:	1885883a 	add	r2,r3,r2
    60f0:	e0bff615 	stw	r2,-40(fp)
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
    60f4:	e0bff617 	ldw	r2,-40(fp)
    60f8:	0084303a 	nor	r2,zero,r2
}
    60fc:	e037883a 	mov	sp,fp
    6100:	dfc00117 	ldw	ra,4(sp)
    6104:	df000017 	ldw	fp,0(sp)
    6108:	dec00204 	addi	sp,sp,8
    610c:	f800283a 	ret

00006110 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
    6110:	defffc04 	addi	sp,sp,-16
    6114:	dfc00315 	stw	ra,12(sp)
    6118:	df000215 	stw	fp,8(sp)
    611c:	df000204 	addi	fp,sp,8
    6120:	e13ffe15 	stw	r4,-8(fp)
    6124:	2805883a 	mov	r2,r5
    6128:	e0bfff0d 	sth	r2,-4(fp)
  return ~LWIP_CHKSUM(dataptr, len);
    612c:	e0bfff0b 	ldhu	r2,-4(fp)
    6130:	e13ffe17 	ldw	r4,-8(fp)
    6134:	100b883a 	mov	r5,r2
    6138:	0005b6c0 	call	5b6c <lwip_standard_chksum>
    613c:	0084303a 	nor	r2,zero,r2
}
    6140:	e037883a 	mov	sp,fp
    6144:	dfc00117 	ldw	ra,4(sp)
    6148:	df000017 	ldw	fp,0(sp)
    614c:	dec00204 	addi	sp,sp,8
    6150:	f800283a 	ret

00006154 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
    6154:	defffa04 	addi	sp,sp,-24
    6158:	dfc00515 	stw	ra,20(sp)
    615c:	df000415 	stw	fp,16(sp)
    6160:	df000404 	addi	fp,sp,16
    6164:	e13fff15 	stw	r4,-4(fp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
    6168:	e03ffc15 	stw	zero,-16(fp)
  swapped = 0;
    616c:	e03ffe05 	stb	zero,-8(fp)
  for(q = p; q != NULL; q = q->next) {
    6170:	e0bfff17 	ldw	r2,-4(fp)
    6174:	e0bffd15 	stw	r2,-12(fp)
    6178:	00002606 	br	6214 <inet_chksum_pbuf+0xc0>
    acc += LWIP_CHKSUM(q->payload, q->len);
    617c:	e0bffd17 	ldw	r2,-12(fp)
    6180:	10c00117 	ldw	r3,4(r2)
    6184:	e0bffd17 	ldw	r2,-12(fp)
    6188:	1080028b 	ldhu	r2,10(r2)
    618c:	10bfffcc 	andi	r2,r2,65535
    6190:	1809883a 	mov	r4,r3
    6194:	100b883a 	mov	r5,r2
    6198:	0005b6c0 	call	5b6c <lwip_standard_chksum>
    619c:	10bfffcc 	andi	r2,r2,65535
    61a0:	e0fffc17 	ldw	r3,-16(fp)
    61a4:	1885883a 	add	r2,r3,r2
    61a8:	e0bffc15 	stw	r2,-16(fp)
    acc = FOLD_U32T(acc);
    61ac:	e0bffc17 	ldw	r2,-16(fp)
    61b0:	1006d43a 	srli	r3,r2,16
    61b4:	e0bffc17 	ldw	r2,-16(fp)
    61b8:	10bfffcc 	andi	r2,r2,65535
    61bc:	1885883a 	add	r2,r3,r2
    61c0:	e0bffc15 	stw	r2,-16(fp)
    if (q->len % 2 != 0) {
    61c4:	e0bffd17 	ldw	r2,-12(fp)
    61c8:	1080028b 	ldhu	r2,10(r2)
    61cc:	1080004c 	andi	r2,r2,1
    61d0:	10bfffcc 	andi	r2,r2,65535
    61d4:	10000c26 	beq	r2,zero,6208 <inet_chksum_pbuf+0xb4>
      swapped = 1 - swapped;
    61d8:	e0bffe03 	ldbu	r2,-8(fp)
    61dc:	00c00044 	movi	r3,1
    61e0:	1885c83a 	sub	r2,r3,r2
    61e4:	e0bffe05 	stb	r2,-8(fp)
      acc = SWAP_BYTES_IN_WORD(acc);
    61e8:	e0bffc17 	ldw	r2,-16(fp)
    61ec:	10bfc00c 	andi	r2,r2,65280
    61f0:	1006d23a 	srli	r3,r2,8
    61f4:	e0bffc17 	ldw	r2,-16(fp)
    61f8:	1004923a 	slli	r2,r2,8
    61fc:	10bfffcc 	andi	r2,r2,65535
    6200:	1884b03a 	or	r2,r3,r2
    6204:	e0bffc15 	stw	r2,-16(fp)
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
    6208:	e0bffd17 	ldw	r2,-12(fp)
    620c:	10800017 	ldw	r2,0(r2)
    6210:	e0bffd15 	stw	r2,-12(fp)
    6214:	e0bffd17 	ldw	r2,-12(fp)
    6218:	103fd81e 	bne	r2,zero,617c <inet_chksum_pbuf+0x28>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
    621c:	e0bffe03 	ldbu	r2,-8(fp)
    6220:	10000826 	beq	r2,zero,6244 <inet_chksum_pbuf+0xf0>
    acc = SWAP_BYTES_IN_WORD(acc);
    6224:	e0bffc17 	ldw	r2,-16(fp)
    6228:	10bfc00c 	andi	r2,r2,65280
    622c:	1006d23a 	srli	r3,r2,8
    6230:	e0bffc17 	ldw	r2,-16(fp)
    6234:	1004923a 	slli	r2,r2,8
    6238:	10bfffcc 	andi	r2,r2,65535
    623c:	1884b03a 	or	r2,r3,r2
    6240:	e0bffc15 	stw	r2,-16(fp)
  }
  return (u16_t)~(acc & 0xffffUL);
    6244:	e0bffc17 	ldw	r2,-16(fp)
    6248:	0084303a 	nor	r2,zero,r2
}
    624c:	e037883a 	mov	sp,fp
    6250:	dfc00117 	ldw	ra,4(sp)
    6254:	df000017 	ldw	fp,0(sp)
    6258:	dec00204 	addi	sp,sp,8
    625c:	f800283a 	ret

00006260 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(ip_addr_t *dest)
{
    6260:	defffd04 	addi	sp,sp,-12
    6264:	df000215 	stw	fp,8(sp)
    6268:	df000204 	addi	fp,sp,8
    626c:	e13fff15 	stw	r4,-4(fp)
    return netif;
  }
#endif

  /* iterate through netifs */
  for (netif = netif_list; netif != NULL; netif = netif->next) {
    6270:	008000f4 	movhi	r2,3
    6274:	109e2904 	addi	r2,r2,30884
    6278:	10800017 	ldw	r2,0(r2)
    627c:	e0bffe15 	stw	r2,-8(fp)
    6280:	00001306 	br	62d0 <ip_route+0x70>
    /* network mask matches? */
    if (netif_is_up(netif)) {
    6284:	e0bffe17 	ldw	r2,-8(fp)
    6288:	10800b43 	ldbu	r2,45(r2)
    628c:	10803fcc 	andi	r2,r2,255
    6290:	1080004c 	andi	r2,r2,1
    6294:	10000b26 	beq	r2,zero,62c4 <ip_route+0x64>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
    6298:	e0bfff17 	ldw	r2,-4(fp)
    629c:	10c00017 	ldw	r3,0(r2)
    62a0:	e0bffe17 	ldw	r2,-8(fp)
    62a4:	10800117 	ldw	r2,4(r2)
    62a8:	1886f03a 	xor	r3,r3,r2
    62ac:	e0bffe17 	ldw	r2,-8(fp)
    62b0:	10800217 	ldw	r2,8(r2)
    62b4:	1884703a 	and	r2,r3,r2
    62b8:	1000021e 	bne	r2,zero,62c4 <ip_route+0x64>
        /* return netif on which to forward IP packet */
        return netif;
    62bc:	e0bffe17 	ldw	r2,-8(fp)
    62c0:	00001d06 	br	6338 <ip_route+0xd8>
    return netif;
  }
#endif

  /* iterate through netifs */
  for (netif = netif_list; netif != NULL; netif = netif->next) {
    62c4:	e0bffe17 	ldw	r2,-8(fp)
    62c8:	10800017 	ldw	r2,0(r2)
    62cc:	e0bffe15 	stw	r2,-8(fp)
    62d0:	e0bffe17 	ldw	r2,-8(fp)
    62d4:	103feb1e 	bne	r2,zero,6284 <ip_route+0x24>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
    62d8:	008000f4 	movhi	r2,3
    62dc:	109e2a04 	addi	r2,r2,30888
    62e0:	10800017 	ldw	r2,0(r2)
    62e4:	10000726 	beq	r2,zero,6304 <ip_route+0xa4>
    62e8:	008000f4 	movhi	r2,3
    62ec:	109e2a04 	addi	r2,r2,30888
    62f0:	10800017 	ldw	r2,0(r2)
    62f4:	10800b43 	ldbu	r2,45(r2)
    62f8:	10803fcc 	andi	r2,r2,255
    62fc:	1080004c 	andi	r2,r2,1
    6300:	10000a1e 	bne	r2,zero,632c <ip_route+0xcc>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_route: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
    6304:	00800234 	movhi	r2,8
    6308:	1083bd04 	addi	r2,r2,3828
    630c:	1080158b 	ldhu	r2,86(r2)
    6310:	10800044 	addi	r2,r2,1
    6314:	1007883a 	mov	r3,r2
    6318:	00800234 	movhi	r2,8
    631c:	1083bd04 	addi	r2,r2,3828
    6320:	10c0158d 	sth	r3,86(r2)
    snmp_inc_ipoutnoroutes();
    return NULL;
    6324:	0005883a 	mov	r2,zero
    6328:	00000306 	br	6338 <ip_route+0xd8>
  }
  /* no matching netif found, use default netif */
  return netif_default;
    632c:	008000f4 	movhi	r2,3
    6330:	109e2a04 	addi	r2,r2,30888
    6334:	10800017 	ldw	r2,0(r2)
}
    6338:	e037883a 	mov	sp,fp
    633c:	df000017 	ldw	fp,0(sp)
    6340:	dec00104 	addi	sp,sp,4
    6344:	f800283a 	ret

00006348 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
    6348:	defff604 	addi	sp,sp,-40
    634c:	dfc00915 	stw	ra,36(sp)
    6350:	df000815 	stw	fp,32(sp)
    6354:	df000804 	addi	fp,sp,32
    6358:	e13ffe15 	stw	r4,-8(fp)
    635c:	e17fff15 	stw	r5,-4(fp)
  struct ip_hdr *iphdr;
  struct netif *netif;
  u16_t iphdr_hlen;
  u16_t iphdr_len;
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  int check_ip_src=1;
    6360:	00800044 	movi	r2,1
    6364:	e0bffa15 	stw	r2,-24(fp)
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */

  IP_STATS_INC(ip.recv);
    6368:	00800234 	movhi	r2,8
    636c:	1083bd04 	addi	r2,r2,3828
    6370:	1080128b 	ldhu	r2,74(r2)
    6374:	10800044 	addi	r2,r2,1
    6378:	1007883a 	mov	r3,r2
    637c:	00800234 	movhi	r2,8
    6380:	1083bd04 	addi	r2,r2,3828
    6384:	10c0128d 	sth	r3,74(r2)
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
    6388:	e0bffe17 	ldw	r2,-8(fp)
    638c:	10800117 	ldw	r2,4(r2)
    6390:	e0bff815 	stw	r2,-32(fp)
  if (IPH_V(iphdr) != 4) {
    6394:	e0bff817 	ldw	r2,-32(fp)
    6398:	10800003 	ldbu	r2,0(r2)
    639c:	10803fcc 	andi	r2,r2,255
    63a0:	1004d13a 	srli	r2,r2,4
    63a4:	10803fcc 	andi	r2,r2,255
    63a8:	10800120 	cmpeqi	r2,r2,4
    63ac:	1000141e 	bne	r2,zero,6400 <ip_input+0xb8>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
    63b0:	e13ffe17 	ldw	r4,-8(fp)
    63b4:	000aa340 	call	aa34 <pbuf_free>
    IP_STATS_INC(ip.err);
    63b8:	00800234 	movhi	r2,8
    63bc:	1083bd04 	addi	r2,r2,3828
    63c0:	1080170b 	ldhu	r2,92(r2)
    63c4:	10800044 	addi	r2,r2,1
    63c8:	1007883a 	mov	r3,r2
    63cc:	00800234 	movhi	r2,8
    63d0:	1083bd04 	addi	r2,r2,3828
    63d4:	10c0170d 	sth	r3,92(r2)
    IP_STATS_INC(ip.drop);
    63d8:	00800234 	movhi	r2,8
    63dc:	1083bd04 	addi	r2,r2,3828
    63e0:	1080138b 	ldhu	r2,78(r2)
    63e4:	10800044 	addi	r2,r2,1
    63e8:	1007883a 	mov	r3,r2
    63ec:	00800234 	movhi	r2,8
    63f0:	1083bd04 	addi	r2,r2,3828
    63f4:	10c0138d 	sth	r3,78(r2)
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
    63f8:	0005883a 	mov	r2,zero
    63fc:	00011006 	br	6840 <ip_input+0x4f8>
    return ERR_OK;
  }
#endif

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
    6400:	e0bff817 	ldw	r2,-32(fp)
    6404:	10800003 	ldbu	r2,0(r2)
    6408:	10803fcc 	andi	r2,r2,255
    640c:	108003cc 	andi	r2,r2,15
    6410:	e0bffc0d 	sth	r2,-16(fp)
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
    6414:	e0bffc0b 	ldhu	r2,-16(fp)
    6418:	1085883a 	add	r2,r2,r2
    641c:	1085883a 	add	r2,r2,r2
    6420:	e0bffc0d 	sth	r2,-16(fp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
    6424:	e0bff817 	ldw	r2,-32(fp)
    6428:	1080008b 	ldhu	r2,2(r2)
    642c:	10bfffcc 	andi	r2,r2,65535
    6430:	1004d23a 	srli	r2,r2,8
    6434:	1007883a 	mov	r3,r2
    6438:	e0bff817 	ldw	r2,-32(fp)
    643c:	1080008b 	ldhu	r2,2(r2)
    6440:	10bfffcc 	andi	r2,r2,65535
    6444:	1004923a 	slli	r2,r2,8
    6448:	1884b03a 	or	r2,r3,r2
    644c:	e0bffc8d 	sth	r2,-14(fp)

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
    6450:	e0bffe17 	ldw	r2,-8(fp)
    6454:	1080028b 	ldhu	r2,10(r2)
    6458:	10ffffcc 	andi	r3,r2,65535
    645c:	e0bffc0b 	ldhu	r2,-16(fp)
    6460:	18800536 	bltu	r3,r2,6478 <ip_input+0x130>
    6464:	e0bffe17 	ldw	r2,-8(fp)
    6468:	1080020b 	ldhu	r2,8(r2)
    646c:	10ffffcc 	andi	r3,r2,65535
    6470:	e0bffc8b 	ldhu	r2,-14(fp)
    6474:	1880142e 	bgeu	r3,r2,64c8 <ip_input+0x180>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
        iphdr_len, p->tot_len));
    }
    /* free (drop) packet pbufs */
    pbuf_free(p);
    6478:	e13ffe17 	ldw	r4,-8(fp)
    647c:	000aa340 	call	aa34 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
    6480:	00800234 	movhi	r2,8
    6484:	1083bd04 	addi	r2,r2,3828
    6488:	1080148b 	ldhu	r2,82(r2)
    648c:	10800044 	addi	r2,r2,1
    6490:	1007883a 	mov	r3,r2
    6494:	00800234 	movhi	r2,8
    6498:	1083bd04 	addi	r2,r2,3828
    649c:	10c0148d 	sth	r3,82(r2)
    IP_STATS_INC(ip.drop);
    64a0:	00800234 	movhi	r2,8
    64a4:	1083bd04 	addi	r2,r2,3828
    64a8:	1080138b 	ldhu	r2,78(r2)
    64ac:	10800044 	addi	r2,r2,1
    64b0:	1007883a 	mov	r3,r2
    64b4:	00800234 	movhi	r2,8
    64b8:	1083bd04 	addi	r2,r2,3828
    64bc:	10c0138d 	sth	r3,78(r2)
    snmp_inc_ipindiscards();
    return ERR_OK;
    64c0:	0005883a 	mov	r2,zero
    64c4:	0000de06 	br	6840 <ip_input+0x4f8>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
    64c8:	e0bffc0b 	ldhu	r2,-16(fp)
    64cc:	e13ff817 	ldw	r4,-32(fp)
    64d0:	100b883a 	mov	r5,r2
    64d4:	00061100 	call	6110 <inet_chksum>
    64d8:	10bfffcc 	andi	r2,r2,65535
    64dc:	10001426 	beq	r2,zero,6530 <ip_input+0x1e8>

    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
      ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
    64e0:	e13ffe17 	ldw	r4,-8(fp)
    64e4:	000aa340 	call	aa34 <pbuf_free>
    IP_STATS_INC(ip.chkerr);
    64e8:	00800234 	movhi	r2,8
    64ec:	1083bd04 	addi	r2,r2,3828
    64f0:	1080140b 	ldhu	r2,80(r2)
    64f4:	10800044 	addi	r2,r2,1
    64f8:	1007883a 	mov	r3,r2
    64fc:	00800234 	movhi	r2,8
    6500:	1083bd04 	addi	r2,r2,3828
    6504:	10c0140d 	sth	r3,80(r2)
    IP_STATS_INC(ip.drop);
    6508:	00800234 	movhi	r2,8
    650c:	1083bd04 	addi	r2,r2,3828
    6510:	1080138b 	ldhu	r2,78(r2)
    6514:	10800044 	addi	r2,r2,1
    6518:	1007883a 	mov	r3,r2
    651c:	00800234 	movhi	r2,8
    6520:	1083bd04 	addi	r2,r2,3828
    6524:	10c0138d 	sth	r3,78(r2)
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
    6528:	0005883a 	mov	r2,zero
    652c:	0000c406 	br	6840 <ip_input+0x4f8>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
    6530:	e0bffc8b 	ldhu	r2,-14(fp)
    6534:	e13ffe17 	ldw	r4,-8(fp)
    6538:	100b883a 	mov	r5,r2
    653c:	000a5b80 	call	a5b8 <pbuf_realloc>

  /* copy IP addresses to aligned ip_addr_t */
  ip_addr_copy(current_iphdr_dest, iphdr->dest);
    6540:	e0bff817 	ldw	r2,-32(fp)
    6544:	10c0040b 	ldhu	r3,16(r2)
    6548:	1080048b 	ldhu	r2,18(r2)
    654c:	1004943a 	slli	r2,r2,16
    6550:	10c4b03a 	or	r2,r2,r3
    6554:	d0a8af15 	stw	r2,-23876(gp)
  ip_addr_copy(current_iphdr_src, iphdr->src);
    6558:	e0bff817 	ldw	r2,-32(fp)
    655c:	10c0030b 	ldhu	r3,12(r2)
    6560:	1080038b 	ldhu	r2,14(r2)
    6564:	1004943a 	slli	r2,r2,16
    6568:	10c4b03a 	or	r2,r2,r3
    656c:	d0a8ad15 	stw	r2,-23884(gp)
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
    6570:	00800044 	movi	r2,1
    6574:	e0bffb15 	stw	r2,-20(fp)
    netif = inp;
    6578:	e0bfff17 	ldw	r2,-4(fp)
    657c:	e0bff915 	stw	r2,-28(fp)
          ip4_addr_get_u32(&iphdr->dest) & ip4_addr_get_u32(&netif->netmask),
          ip4_addr_get_u32(&netif->ip_addr) & ip4_addr_get_u32(&netif->netmask),
          ip4_addr_get_u32(&iphdr->dest) & ~ip4_addr_get_u32(&netif->netmask)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
    6580:	e0bff917 	ldw	r2,-28(fp)
    6584:	10800b43 	ldbu	r2,45(r2)
    6588:	10803fcc 	andi	r2,r2,255
    658c:	1080004c 	andi	r2,r2,1
    6590:	10001026 	beq	r2,zero,65d4 <ip_input+0x28c>
    6594:	e0bff917 	ldw	r2,-28(fp)
    6598:	10800104 	addi	r2,r2,4
    659c:	10000d26 	beq	r2,zero,65d4 <ip_input+0x28c>
    65a0:	e0bff917 	ldw	r2,-28(fp)
    65a4:	10800117 	ldw	r2,4(r2)
    65a8:	10000a26 	beq	r2,zero,65d4 <ip_input+0x28c>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
    65ac:	d0e8af17 	ldw	r3,-23876(gp)
    65b0:	e0bff917 	ldw	r2,-28(fp)
    65b4:	10800117 	ldw	r2,4(r2)
    65b8:	18801926 	beq	r3,r2,6620 <ip_input+0x2d8>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&current_iphdr_dest, netif)) {
    65bc:	d0a8af17 	ldw	r2,-23876(gp)
    65c0:	1009883a 	mov	r4,r2
    65c4:	e17ff917 	ldw	r5,-28(fp)
    65c8:	0006da80 	call	6da8 <ip4_addr_isbroadcast>
          ip4_addr_get_u32(&iphdr->dest) & ~ip4_addr_get_u32(&netif->netmask)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
    65cc:	10803fcc 	andi	r2,r2,255
    65d0:	1000131e 	bne	r2,zero,6620 <ip_input+0x2d8>
          /* break out of for loop */
          break;
        }
#endif /* LWIP_AUTOIP */
      }
      if (first) {
    65d4:	e0bffb17 	ldw	r2,-20(fp)
    65d8:	10000626 	beq	r2,zero,65f4 <ip_input+0x2ac>
        first = 0;
    65dc:	e03ffb15 	stw	zero,-20(fp)
        netif = netif_list;
    65e0:	008000f4 	movhi	r2,3
    65e4:	109e2904 	addi	r2,r2,30884
    65e8:	10800017 	ldw	r2,0(r2)
    65ec:	e0bff915 	stw	r2,-28(fp)
    65f0:	00000306 	br	6600 <ip_input+0x2b8>
      } else {
        netif = netif->next;
    65f4:	e0bff917 	ldw	r2,-28(fp)
    65f8:	10800017 	ldw	r2,0(r2)
    65fc:	e0bff915 	stw	r2,-28(fp)
      }
      if (netif == inp) {
    6600:	e0fff917 	ldw	r3,-28(fp)
    6604:	e0bfff17 	ldw	r2,-4(fp)
    6608:	1880031e 	bne	r3,r2,6618 <ip_input+0x2d0>
        netif = netif->next;
    660c:	e0bff917 	ldw	r2,-28(fp)
    6610:	10800017 	ldw	r2,0(r2)
    6614:	e0bff915 	stw	r2,-28(fp)
      }
    } while(netif != NULL);
    6618:	e0bff917 	ldw	r2,-28(fp)
    661c:	103fd81e 	bne	r2,zero,6580 <ip_input+0x238>
   * If you want to accept private broadcast communication while a netif is down,
   * define LWIP_IP_ACCEPT_UDP_PORT(dst_port), e.g.:
   *
   * #define LWIP_IP_ACCEPT_UDP_PORT(dst_port) ((dst_port) == PP_NTOHS(12345))
   */
  if (netif == NULL) {
    6620:	e0bff917 	ldw	r2,-28(fp)
    6624:	1000111e 	bne	r2,zero,666c <ip_input+0x324>
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
    6628:	e0bff817 	ldw	r2,-32(fp)
    662c:	10800243 	ldbu	r2,9(r2)
    6630:	10803fcc 	andi	r2,r2,255
    6634:	10800458 	cmpnei	r2,r2,17
    6638:	10000c1e 	bne	r2,zero,666c <ip_input+0x324>
      struct udp_hdr *udphdr = (struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen);
    663c:	e0bffc0b 	ldhu	r2,-16(fp)
    6640:	e0fff817 	ldw	r3,-32(fp)
    6644:	1885883a 	add	r2,r3,r2
    6648:	e0bffd15 	stw	r2,-12(fp)
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(udphdr->dest)));
      if (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr->dest)) {
    664c:	e0bffd17 	ldw	r2,-12(fp)
    6650:	1080008b 	ldhu	r2,2(r2)
    6654:	10bfffcc 	andi	r2,r2,65535
    6658:	10910018 	cmpnei	r2,r2,17408
    665c:	1000031e 	bne	r2,zero,666c <ip_input+0x324>
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: DHCP packet accepted.\n"));
        netif = inp;
    6660:	e0bfff17 	ldw	r2,-4(fp)
    6664:	e0bff915 	stw	r2,-28(fp)
        check_ip_src = 0;
    6668:	e03ffa15 	stw	zero,-24(fp)
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
  if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
    666c:	e0bffa17 	ldw	r2,-24(fp)
    6670:	10001826 	beq	r2,zero,66d4 <ip_input+0x38c>
    6674:	d0a8ad17 	ldw	r2,-23884(gp)
    6678:	10001626 	beq	r2,zero,66d4 <ip_input+0x38c>
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
  {  if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) ||
    667c:	d0a8ad17 	ldw	r2,-23884(gp)
    6680:	1009883a 	mov	r4,r2
    6684:	e17fff17 	ldw	r5,-4(fp)
    6688:	0006da80 	call	6da8 <ip4_addr_isbroadcast>
    668c:	10803fcc 	andi	r2,r2,255
    6690:	1000041e 	bne	r2,zero,66a4 <ip_input+0x35c>
         (ip_addr_ismulticast(&current_iphdr_src))) {
    6694:	d0a8ad17 	ldw	r2,-23884(gp)
    6698:	10803c0c 	andi	r2,r2,240
  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
  if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
  {  if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) ||
    669c:	10803818 	cmpnei	r2,r2,224
    66a0:	10000c1e 	bne	r2,zero,66d4 <ip_input+0x38c>
         (ip_addr_ismulticast(&current_iphdr_src))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
    66a4:	e13ffe17 	ldw	r4,-8(fp)
    66a8:	000aa340 	call	aa34 <pbuf_free>
      IP_STATS_INC(ip.drop);
    66ac:	00800234 	movhi	r2,8
    66b0:	1083bd04 	addi	r2,r2,3828
    66b4:	1080138b 	ldhu	r2,78(r2)
    66b8:	10800044 	addi	r2,r2,1
    66bc:	1007883a 	mov	r3,r2
    66c0:	00800234 	movhi	r2,8
    66c4:	1083bd04 	addi	r2,r2,3828
    66c8:	10c0138d 	sth	r3,78(r2)
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
    66cc:	0005883a 	mov	r2,zero
    66d0:	00005b06 	br	6840 <ip_input+0x4f8>
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
    66d4:	e0bff917 	ldw	r2,-28(fp)
    66d8:	1000041e 	bne	r2,zero,66ec <ip_input+0x3a4>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
    66dc:	e13ffe17 	ldw	r4,-8(fp)
    66e0:	000aa340 	call	aa34 <pbuf_free>
    return ERR_OK;
    66e4:	0005883a 	mov	r2,zero
    66e8:	00005506 	br	6840 <ip_input+0x4f8>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
    66ec:	e0bff817 	ldw	r2,-32(fp)
    66f0:	1080018b 	ldhu	r2,6(r2)
    66f4:	10bfffcc 	andi	r2,r2,65535
    66f8:	10bfcfcc 	andi	r2,r2,65343
    66fc:	10000a26 	beq	r2,zero,6728 <ip_input+0x3e0>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & PP_HTONS(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
    6700:	e13ffe17 	ldw	r4,-8(fp)
    6704:	00080a80 	call	80a8 <ip_reass>
    6708:	e0bffe15 	stw	r2,-8(fp)
    /* packet not fully reassembled yet? */
    if (p == NULL) {
    670c:	e0bffe17 	ldw	r2,-8(fp)
    6710:	1000021e 	bne	r2,zero,671c <ip_input+0x3d4>
      return ERR_OK;
    6714:	0005883a 	mov	r2,zero
    6718:	00004906 	br	6840 <ip_input+0x4f8>
    }
    iphdr = (struct ip_hdr *)p->payload;
    671c:	e0bffe17 	ldw	r2,-8(fp)
    6720:	10800117 	ldw	r2,4(r2)
    6724:	e0bff815 	stw	r2,-32(fp)
  /* send to upper layers */
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: \n"));
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

  current_netif = inp;
    6728:	e0bfff17 	ldw	r2,-4(fp)
    672c:	d0a8ae15 	stw	r2,-23880(gp)
  current_header = iphdr;
    6730:	e0bff817 	ldw	r2,-32(fp)
    6734:	d0a8b015 	stw	r2,-23872(gp)

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
    6738:	e13ffe17 	ldw	r4,-8(fp)
    673c:	e17fff17 	ldw	r5,-4(fp)
    6740:	000b94c0 	call	b94c <raw_input>
    6744:	10803fcc 	andi	r2,r2,255
    6748:	1000381e 	bne	r2,zero,682c <ip_input+0x4e4>
#endif /* LWIP_RAW */
  {
    switch (IPH_PROTO(iphdr)) {
    674c:	e0bff817 	ldw	r2,-32(fp)
    6750:	10800243 	ldbu	r2,9(r2)
    6754:	10803fcc 	andi	r2,r2,255
    6758:	10c001a0 	cmpeqi	r3,r2,6
    675c:	1800091e 	bne	r3,zero,6784 <ip_input+0x43c>
    6760:	10c00460 	cmpeqi	r3,r2,17
    6764:	1800031e 	bne	r3,zero,6774 <ip_input+0x42c>
    6768:	10800060 	cmpeqi	r2,r2,1
    676c:	1000091e 	bne	r2,zero,6794 <ip_input+0x44c>
    6770:	00000c06 	br	67a4 <ip_input+0x45c>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
    6774:	e13ffe17 	ldw	r4,-8(fp)
    6778:	e17fff17 	ldw	r5,-4(fp)
    677c:	00150bc0 	call	150bc <udp_input>
      break;
    6780:	00002a06 	br	682c <ip_input+0x4e4>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
    6784:	e13ffe17 	ldw	r4,-8(fp)
    6788:	e17fff17 	ldw	r5,-4(fp)
    678c:	000e48c0 	call	e48c <tcp_input>
      break;
    6790:	00002606 	br	682c <ip_input+0x4e4>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
    6794:	e13ffe17 	ldw	r4,-8(fp)
    6798:	e17fff17 	ldw	r5,-4(fp)
    679c:	00053fc0 	call	53fc <icmp_input>
      break;
    67a0:	00002206 	br	682c <ip_input+0x4e4>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) &&
    67a4:	d0a8af17 	ldw	r2,-23876(gp)
    67a8:	1009883a 	mov	r4,r2
    67ac:	e17fff17 	ldw	r5,-4(fp)
    67b0:	0006da80 	call	6da8 <ip4_addr_isbroadcast>
    67b4:	10803fcc 	andi	r2,r2,255
    67b8:	10000a1e 	bne	r2,zero,67e4 <ip_input+0x49c>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
    67bc:	d0a8af17 	ldw	r2,-23876(gp)
    67c0:	10803c0c 	andi	r2,r2,240
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) &&
    67c4:	10803820 	cmpeqi	r2,r2,224
    67c8:	1000061e 	bne	r2,zero,67e4 <ip_input+0x49c>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
        p->payload = iphdr;
    67cc:	e0bffe17 	ldw	r2,-8(fp)
    67d0:	e0fff817 	ldw	r3,-32(fp)
    67d4:	10c00115 	stw	r3,4(r2)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
    67d8:	e13ffe17 	ldw	r4,-8(fp)
    67dc:	01400084 	movi	r5,2
    67e0:	00059680 	call	5968 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
    67e4:	e13ffe17 	ldw	r4,-8(fp)
    67e8:	000aa340 	call	aa34 <pbuf_free>

      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Unsupported transport protocol %"U16_F"\n", IPH_PROTO(iphdr)));

      IP_STATS_INC(ip.proterr);
    67ec:	00800234 	movhi	r2,8
    67f0:	1083bd04 	addi	r2,r2,3828
    67f4:	1080160b 	ldhu	r2,88(r2)
    67f8:	10800044 	addi	r2,r2,1
    67fc:	1007883a 	mov	r3,r2
    6800:	00800234 	movhi	r2,8
    6804:	1083bd04 	addi	r2,r2,3828
    6808:	10c0160d 	sth	r3,88(r2)
      IP_STATS_INC(ip.drop);
    680c:	00800234 	movhi	r2,8
    6810:	1083bd04 	addi	r2,r2,3828
    6814:	1080138b 	ldhu	r2,78(r2)
    6818:	10800044 	addi	r2,r2,1
    681c:	1007883a 	mov	r3,r2
    6820:	00800234 	movhi	r2,8
    6824:	1083bd04 	addi	r2,r2,3828
    6828:	10c0138d 	sth	r3,78(r2)
      snmp_inc_ipinunknownprotos();
    }
  }

  current_netif = NULL;
    682c:	d028ae15 	stw	zero,-23880(gp)
  current_header = NULL;
    6830:	d028b015 	stw	zero,-23872(gp)
  ip_addr_set_any(&current_iphdr_src);
    6834:	d028ad15 	stw	zero,-23884(gp)
  ip_addr_set_any(&current_iphdr_dest);
    6838:	d028af15 	stw	zero,-23876(gp)

  return ERR_OK;
    683c:	0005883a 	mov	r2,zero
}
    6840:	e037883a 	mov	sp,fp
    6844:	dfc00117 	ldw	ra,4(sp)
    6848:	df000017 	ldw	fp,0(sp)
    684c:	dec00204 	addi	sp,sp,8
    6850:	f800283a 	ret

00006854 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
    6854:	defff404 	addi	sp,sp,-48
    6858:	dfc00b15 	stw	ra,44(sp)
    685c:	df000a15 	stw	fp,40(sp)
    6860:	df000a04 	addi	fp,sp,40
    6864:	e13ffa15 	stw	r4,-24(fp)
    6868:	e17ffb15 	stw	r5,-20(fp)
    686c:	e1bffc15 	stw	r6,-16(fp)
    6870:	3805883a 	mov	r2,r7
    6874:	e1000217 	ldw	r4,8(fp)
    6878:	e0c00317 	ldw	r3,12(fp)
    687c:	e0bffd05 	stb	r2,-12(fp)
    6880:	e13ffe05 	stb	r4,-8(fp)
    6884:	e0ffff05 	stb	r3,-4(fp)
{
#endif /* IP_OPTIONS_SEND */
  struct ip_hdr *iphdr;
  ip_addr_t dest_addr;
#if CHECKSUM_GEN_IP_INLINE
  u32_t chk_sum = 0;
    6888:	e03ff615 	stw	zero,-40(fp)
#endif /* CHECKSUM_GEN_IP_INLINE */

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);
    688c:	e0bffa17 	ldw	r2,-24(fp)
    6890:	1080038b 	ldhu	r2,14(r2)
    6894:	10bfffcc 	andi	r2,r2,65535
    6898:	10800060 	cmpeqi	r2,r2,1
    689c:	1000091e 	bne	r2,zero,68c4 <ip_output_if+0x70>
    68a0:	010000f4 	movhi	r4,3
    68a4:	213e5504 	addi	r4,r4,-1708
    68a8:	014000f4 	movhi	r5,3
    68ac:	297e5f04 	addi	r5,r5,-1668
    68b0:	0180a704 	movi	r6,668
    68b4:	01c000f4 	movhi	r7,3
    68b8:	39fe6204 	addi	r7,r7,-1656
    68bc:	00193f00 	call	193f0 <printf>
    68c0:	003fff06 	br	68c0 <ip_output_if+0x6c>

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
    68c4:	e0bffc17 	ldw	r2,-16(fp)
    68c8:	1000ce26 	beq	r2,zero,6c04 <ip_output_if+0x3b0>
    u16_t ip_hlen = IP_HLEN;
    68cc:	00800504 	movi	r2,20
    68d0:	e0bff70d 	sth	r2,-36(fp)
      }
#endif /* CHECKSUM_GEN_IP_INLINE */
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
    68d4:	e13ffa17 	ldw	r4,-24(fp)
    68d8:	01400504 	movi	r5,20
    68dc:	000a83c0 	call	a83c <pbuf_header>
    68e0:	10803fcc 	andi	r2,r2,255
    68e4:	10000a26 	beq	r2,zero,6910 <ip_output_if+0xbc>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
    68e8:	00800234 	movhi	r2,8
    68ec:	1083bd04 	addi	r2,r2,3828
    68f0:	1080170b 	ldhu	r2,92(r2)
    68f4:	10800044 	addi	r2,r2,1
    68f8:	1007883a 	mov	r3,r2
    68fc:	00800234 	movhi	r2,8
    6900:	1083bd04 	addi	r2,r2,3828
    6904:	10c0170d 	sth	r3,92(r2)
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    6908:	00bfff84 	movi	r2,-2
    690c:	0000e606 	br	6ca8 <ip_output_if+0x454>
    }

    iphdr = (struct ip_hdr *)p->payload;
    6910:	e0bffa17 	ldw	r2,-24(fp)
    6914:	10800117 	ldw	r2,4(r2)
    6918:	e0bff815 	stw	r2,-32(fp)
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
    691c:	e0bffa17 	ldw	r2,-24(fp)
    6920:	1080028b 	ldhu	r2,10(r2)
    6924:	10bfffcc 	andi	r2,r2,65535
    6928:	10800528 	cmpgeui	r2,r2,20
    692c:	1000091e 	bne	r2,zero,6954 <ip_output_if+0x100>
    6930:	010000f4 	movhi	r4,3
    6934:	213e5504 	addi	r4,r4,-1708
    6938:	014000f4 	movhi	r5,3
    693c:	297e6804 	addi	r5,r5,-1632
    6940:	0180b284 	movi	r6,714
    6944:	01c000f4 	movhi	r7,3
    6948:	39fe6204 	addi	r7,r7,-1656
    694c:	00193f00 	call	193f0 <printf>
    6950:	003fff06 	br	6950 <ip_output_if+0xfc>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
    6954:	e0bff817 	ldw	r2,-32(fp)
    6958:	e0fffd03 	ldbu	r3,-12(fp)
    695c:	10c00205 	stb	r3,8(r2)
    IPH_PROTO_SET(iphdr, proto);
    6960:	e0bff817 	ldw	r2,-32(fp)
    6964:	e0ffff03 	ldbu	r3,-4(fp)
    6968:	10c00245 	stb	r3,9(r2)
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(proto, ttl);
    696c:	e0bfff03 	ldbu	r2,-4(fp)
    6970:	1006923a 	slli	r3,r2,8
    6974:	e0bffd03 	ldbu	r2,-12(fp)
    6978:	1884b03a 	or	r2,r3,r2
    697c:	e0fff617 	ldw	r3,-40(fp)
    6980:	1885883a 	add	r2,r3,r2
    6984:	e0bff615 	stw	r2,-40(fp)
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip_addr_copy(iphdr->dest, *dest);
    6988:	e0bffc17 	ldw	r2,-16(fp)
    698c:	10c00017 	ldw	r3,0(r2)
    6990:	e0bff817 	ldw	r2,-32(fp)
    6994:	193fffcc 	andi	r4,r3,65535
    6998:	1140040b 	ldhu	r5,16(r2)
    699c:	280a703a 	and	r5,r5,zero
    69a0:	2908b03a 	or	r4,r5,r4
    69a4:	1100040d 	sth	r4,16(r2)
    69a8:	1806d43a 	srli	r3,r3,16
    69ac:	1100048b 	ldhu	r4,18(r2)
    69b0:	2008703a 	and	r4,r4,zero
    69b4:	20c6b03a 	or	r3,r4,r3
    69b8:	10c0048d 	sth	r3,18(r2)
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
    69bc:	e0bff817 	ldw	r2,-32(fp)
    69c0:	10c0040b 	ldhu	r3,16(r2)
    69c4:	1080048b 	ldhu	r2,18(r2)
    69c8:	1004943a 	slli	r2,r2,16
    69cc:	10c4b03a 	or	r2,r2,r3
    69d0:	10bfffcc 	andi	r2,r2,65535
    69d4:	e0fff617 	ldw	r3,-40(fp)
    69d8:	1885883a 	add	r2,r3,r2
    69dc:	e0bff615 	stw	r2,-40(fp)
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
    69e0:	e0bff817 	ldw	r2,-32(fp)
    69e4:	10c0040b 	ldhu	r3,16(r2)
    69e8:	1080048b 	ldhu	r2,18(r2)
    69ec:	1004943a 	slli	r2,r2,16
    69f0:	10c4b03a 	or	r2,r2,r3
    69f4:	1004d43a 	srli	r2,r2,16
    69f8:	e0fff617 	ldw	r3,-40(fp)
    69fc:	1885883a 	add	r2,r3,r2
    6a00:	e0bff615 	stw	r2,-40(fp)
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    6a04:	e0bff70b 	ldhu	r2,-36(fp)
    6a08:	1004d0ba 	srli	r2,r2,2
    6a0c:	10801014 	ori	r2,r2,64
    6a10:	1007883a 	mov	r3,r2
    6a14:	e0bff817 	ldw	r2,-32(fp)
    6a18:	10c00005 	stb	r3,0(r2)
    IPH_TOS_SET(iphdr, tos);
    6a1c:	e0bff817 	ldw	r2,-32(fp)
    6a20:	e0fffe03 	ldbu	r3,-8(fp)
    6a24:	10c00045 	stb	r3,1(r2)
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
    6a28:	e0bffe03 	ldbu	r2,-8(fp)
    6a2c:	1006923a 	slli	r3,r2,8
    6a30:	e0bff817 	ldw	r2,-32(fp)
    6a34:	10800003 	ldbu	r2,0(r2)
    6a38:	10803fcc 	andi	r2,r2,255
    6a3c:	1884b03a 	or	r2,r3,r2
    6a40:	e0fff617 	ldw	r3,-40(fp)
    6a44:	1885883a 	add	r2,r3,r2
    6a48:	e0bff615 	stw	r2,-40(fp)
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, htons(p->tot_len));
    6a4c:	e0bffa17 	ldw	r2,-24(fp)
    6a50:	1080020b 	ldhu	r2,8(r2)
    6a54:	10bfffcc 	andi	r2,r2,65535
    6a58:	1004d23a 	srli	r2,r2,8
    6a5c:	1007883a 	mov	r3,r2
    6a60:	e0bffa17 	ldw	r2,-24(fp)
    6a64:	1080020b 	ldhu	r2,8(r2)
    6a68:	10bfffcc 	andi	r2,r2,65535
    6a6c:	1004923a 	slli	r2,r2,8
    6a70:	1884b03a 	or	r2,r3,r2
    6a74:	1007883a 	mov	r3,r2
    6a78:	e0bff817 	ldw	r2,-32(fp)
    6a7c:	10c0008d 	sth	r3,2(r2)
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
    6a80:	e0bff817 	ldw	r2,-32(fp)
    6a84:	1080008b 	ldhu	r2,2(r2)
    6a88:	10bfffcc 	andi	r2,r2,65535
    6a8c:	e0fff617 	ldw	r3,-40(fp)
    6a90:	1885883a 	add	r2,r3,r2
    6a94:	e0bff615 	stw	r2,-40(fp)
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
    6a98:	e0bff817 	ldw	r2,-32(fp)
    6a9c:	1000018d 	sth	zero,6(r2)
    IPH_ID_SET(iphdr, htons(ip_id));
    6aa0:	d0a8ac0b 	ldhu	r2,-23888(gp)
    6aa4:	10bfffcc 	andi	r2,r2,65535
    6aa8:	1004d23a 	srli	r2,r2,8
    6aac:	1007883a 	mov	r3,r2
    6ab0:	d0a8ac0b 	ldhu	r2,-23888(gp)
    6ab4:	10bfffcc 	andi	r2,r2,65535
    6ab8:	1004923a 	slli	r2,r2,8
    6abc:	1884b03a 	or	r2,r3,r2
    6ac0:	1007883a 	mov	r3,r2
    6ac4:	e0bff817 	ldw	r2,-32(fp)
    6ac8:	10c0010d 	sth	r3,4(r2)
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
    6acc:	e0bff817 	ldw	r2,-32(fp)
    6ad0:	1080010b 	ldhu	r2,4(r2)
    6ad4:	10bfffcc 	andi	r2,r2,65535
    6ad8:	e0fff617 	ldw	r3,-40(fp)
    6adc:	1885883a 	add	r2,r3,r2
    6ae0:	e0bff615 	stw	r2,-40(fp)
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
    6ae4:	d0a8ac0b 	ldhu	r2,-23888(gp)
    6ae8:	10800044 	addi	r2,r2,1
    6aec:	d0a8ac0d 	sth	r2,-23888(gp)

    if (ip_addr_isany(src)) {
    6af0:	e0bffb17 	ldw	r2,-20(fp)
    6af4:	10000326 	beq	r2,zero,6b04 <ip_output_if+0x2b0>
    6af8:	e0bffb17 	ldw	r2,-20(fp)
    6afc:	10800017 	ldw	r2,0(r2)
    6b00:	10000e1e 	bne	r2,zero,6b3c <ip_output_if+0x2e8>
      ip_addr_copy(iphdr->src, netif->ip_addr);
    6b04:	e0800417 	ldw	r2,16(fp)
    6b08:	10c00117 	ldw	r3,4(r2)
    6b0c:	e0bff817 	ldw	r2,-32(fp)
    6b10:	193fffcc 	andi	r4,r3,65535
    6b14:	1140030b 	ldhu	r5,12(r2)
    6b18:	280a703a 	and	r5,r5,zero
    6b1c:	2908b03a 	or	r4,r5,r4
    6b20:	1100030d 	sth	r4,12(r2)
    6b24:	1806d43a 	srli	r3,r3,16
    6b28:	1100038b 	ldhu	r4,14(r2)
    6b2c:	2008703a 	and	r4,r4,zero
    6b30:	20c6b03a 	or	r3,r4,r3
    6b34:	10c0038d 	sth	r3,14(r2)
    6b38:	00000d06 	br	6b70 <ip_output_if+0x31c>
    } else {
      /* src cannot be NULL here */
      ip_addr_copy(iphdr->src, *src);
    6b3c:	e0bffb17 	ldw	r2,-20(fp)
    6b40:	10c00017 	ldw	r3,0(r2)
    6b44:	e0bff817 	ldw	r2,-32(fp)
    6b48:	193fffcc 	andi	r4,r3,65535
    6b4c:	1140030b 	ldhu	r5,12(r2)
    6b50:	280a703a 	and	r5,r5,zero
    6b54:	2908b03a 	or	r4,r5,r4
    6b58:	1100030d 	sth	r4,12(r2)
    6b5c:	1806d43a 	srli	r3,r3,16
    6b60:	1100038b 	ldhu	r4,14(r2)
    6b64:	2008703a 	and	r4,r4,zero
    6b68:	20c6b03a 	or	r3,r4,r3
    6b6c:	10c0038d 	sth	r3,14(r2)
    }

#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
    6b70:	e0bff817 	ldw	r2,-32(fp)
    6b74:	10c0030b 	ldhu	r3,12(r2)
    6b78:	1080038b 	ldhu	r2,14(r2)
    6b7c:	1004943a 	slli	r2,r2,16
    6b80:	10c4b03a 	or	r2,r2,r3
    6b84:	10bfffcc 	andi	r2,r2,65535
    6b88:	e0fff617 	ldw	r3,-40(fp)
    6b8c:	1885883a 	add	r2,r3,r2
    6b90:	e0bff615 	stw	r2,-40(fp)
    chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
    6b94:	e0bff817 	ldw	r2,-32(fp)
    6b98:	10c0030b 	ldhu	r3,12(r2)
    6b9c:	1080038b 	ldhu	r2,14(r2)
    6ba0:	1004943a 	slli	r2,r2,16
    6ba4:	10c4b03a 	or	r2,r2,r3
    6ba8:	1004d43a 	srli	r2,r2,16
    6bac:	e0fff617 	ldw	r3,-40(fp)
    6bb0:	1885883a 	add	r2,r3,r2
    6bb4:	e0bff615 	stw	r2,-40(fp)
    chk_sum = (chk_sum >> 16) + (chk_sum & 0xFFFF);
    6bb8:	e0bff617 	ldw	r2,-40(fp)
    6bbc:	1006d43a 	srli	r3,r2,16
    6bc0:	e0bff617 	ldw	r2,-40(fp)
    6bc4:	10bfffcc 	andi	r2,r2,65535
    6bc8:	1885883a 	add	r2,r3,r2
    6bcc:	e0bff615 	stw	r2,-40(fp)
    chk_sum = (chk_sum >> 16) + chk_sum;
    6bd0:	e0bff617 	ldw	r2,-40(fp)
    6bd4:	1004d43a 	srli	r2,r2,16
    6bd8:	e0fff617 	ldw	r3,-40(fp)
    6bdc:	1885883a 	add	r2,r3,r2
    6be0:	e0bff615 	stw	r2,-40(fp)
    chk_sum = ~chk_sum;
    6be4:	e0bff617 	ldw	r2,-40(fp)
    6be8:	0084303a 	nor	r2,zero,r2
    6bec:	e0bff615 	stw	r2,-40(fp)
    iphdr->_chksum = chk_sum; /* network order */
    6bf0:	e0bff617 	ldw	r2,-40(fp)
    6bf4:	1007883a 	mov	r3,r2
    6bf8:	e0bff817 	ldw	r2,-32(fp)
    6bfc:	10c0028d 	sth	r3,10(r2)
    6c00:	00000b06 	br	6c30 <ip_output_if+0x3dc>
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, ip_hlen));
#endif
#endif /* CHECKSUM_GEN_IP_INLINE */
  } else {
    /* IP header already included in p */
    iphdr = (struct ip_hdr *)p->payload;
    6c04:	e0bffa17 	ldw	r2,-24(fp)
    6c08:	10800117 	ldw	r2,4(r2)
    6c0c:	e0bff815 	stw	r2,-32(fp)
    ip_addr_copy(dest_addr, iphdr->dest);
    6c10:	e0bff817 	ldw	r2,-32(fp)
    6c14:	10c0040b 	ldhu	r3,16(r2)
    6c18:	1080048b 	ldhu	r2,18(r2)
    6c1c:	1004943a 	slli	r2,r2,16
    6c20:	10c4b03a 	or	r2,r2,r3
    6c24:	e0bff915 	stw	r2,-28(fp)
    dest = &dest_addr;
    6c28:	e0bff904 	addi	r2,fp,-28
    6c2c:	e0bffc15 	stw	r2,-16(fp)
  }

  IP_STATS_INC(ip.xmit);
    6c30:	00800234 	movhi	r2,8
    6c34:	1083bd04 	addi	r2,r2,3828
    6c38:	1080120b 	ldhu	r2,72(r2)
    6c3c:	10800044 	addi	r2,r2,1
    6c40:	1007883a 	mov	r3,r2
    6c44:	00800234 	movhi	r2,8
    6c48:	1083bd04 	addi	r2,r2,3828
    6c4c:	10c0120d 	sth	r3,72(r2)
  }
#endif /* LWIP_IGMP */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
    6c50:	e0800417 	ldw	r2,16(fp)
    6c54:	1080090b 	ldhu	r2,36(r2)
    6c58:	10bfffcc 	andi	r2,r2,65535
    6c5c:	10000c26 	beq	r2,zero,6c90 <ip_output_if+0x43c>
    6c60:	e0bffa17 	ldw	r2,-24(fp)
    6c64:	1080020b 	ldhu	r2,8(r2)
    6c68:	e0c00417 	ldw	r3,16(fp)
    6c6c:	18c0090b 	ldhu	r3,36(r3)
    6c70:	10bfffcc 	andi	r2,r2,65535
    6c74:	18ffffcc 	andi	r3,r3,65535
    6c78:	1880052e 	bgeu	r3,r2,6c90 <ip_output_if+0x43c>
    return ip_frag(p, netif, dest);
    6c7c:	e13ffa17 	ldw	r4,-24(fp)
    6c80:	e1400417 	ldw	r5,16(fp)
    6c84:	e1bffc17 	ldw	r6,-16(fp)
    6c88:	00085600 	call	8560 <ip_frag>
    6c8c:	00000606 	br	6ca8 <ip_output_if+0x454>
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
  return netif->output(netif, p, dest);
    6c90:	e0800417 	ldw	r2,16(fp)
    6c94:	10800517 	ldw	r2,20(r2)
    6c98:	e1000417 	ldw	r4,16(fp)
    6c9c:	e17ffa17 	ldw	r5,-24(fp)
    6ca0:	e1bffc17 	ldw	r6,-16(fp)
    6ca4:	103ee83a 	callr	r2
}
    6ca8:	e037883a 	mov	sp,fp
    6cac:	dfc00117 	ldw	ra,4(sp)
    6cb0:	df000017 	ldw	fp,0(sp)
    6cb4:	dec00204 	addi	sp,sp,8
    6cb8:	f800283a 	ret

00006cbc <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
    6cbc:	defff404 	addi	sp,sp,-48
    6cc0:	dfc00b15 	stw	ra,44(sp)
    6cc4:	df000a15 	stw	fp,40(sp)
    6cc8:	df000a04 	addi	fp,sp,40
    6ccc:	e13ffa15 	stw	r4,-24(fp)
    6cd0:	e17ffb15 	stw	r5,-20(fp)
    6cd4:	e1bffc15 	stw	r6,-16(fp)
    6cd8:	3805883a 	mov	r2,r7
    6cdc:	e1000217 	ldw	r4,8(fp)
    6ce0:	e0c00317 	ldw	r3,12(fp)
    6ce4:	e0bffd05 	stb	r2,-12(fp)
    6ce8:	e13ffe05 	stb	r4,-8(fp)
    6cec:	e0ffff05 	stb	r3,-4(fp)
  struct netif *netif;

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);
    6cf0:	e0bffa17 	ldw	r2,-24(fp)
    6cf4:	1080038b 	ldhu	r2,14(r2)
    6cf8:	10bfffcc 	andi	r2,r2,65535
    6cfc:	10800060 	cmpeqi	r2,r2,1
    6d00:	1000091e 	bne	r2,zero,6d28 <ip_output+0x6c>
    6d04:	010000f4 	movhi	r4,3
    6d08:	213e5504 	addi	r4,r4,-1708
    6d0c:	014000f4 	movhi	r5,3
    6d10:	297e5f04 	addi	r5,r5,-1668
    6d14:	0180ce44 	movi	r6,825
    6d18:	01c000f4 	movhi	r7,3
    6d1c:	39fe6204 	addi	r7,r7,-1656
    6d20:	00193f00 	call	193f0 <printf>
    6d24:	003fff06 	br	6d24 <ip_output+0x68>

  if ((netif = ip_route(dest)) == NULL) {
    6d28:	e13ffc17 	ldw	r4,-16(fp)
    6d2c:	00062600 	call	6260 <ip_route>
    6d30:	e0bff915 	stw	r2,-28(fp)
    6d34:	e0bff917 	ldw	r2,-28(fp)
    6d38:	10000a1e 	bne	r2,zero,6d64 <ip_output+0xa8>
    LWIP_DEBUGF(IP_DEBUG, ("ip_output: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
    6d3c:	00800234 	movhi	r2,8
    6d40:	1083bd04 	addi	r2,r2,3828
    6d44:	1080158b 	ldhu	r2,86(r2)
    6d48:	10800044 	addi	r2,r2,1
    6d4c:	1007883a 	mov	r3,r2
    6d50:	00800234 	movhi	r2,8
    6d54:	1083bd04 	addi	r2,r2,3828
    6d58:	10c0158d 	sth	r3,86(r2)
    return ERR_RTE;
    6d5c:	00bfff04 	movi	r2,-4
    6d60:	00000c06 	br	6d94 <ip_output+0xd8>
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
    6d64:	e0bffd03 	ldbu	r2,-12(fp)
    6d68:	e13ffe03 	ldbu	r4,-8(fp)
    6d6c:	e0ffff03 	ldbu	r3,-4(fp)
    6d70:	d9000015 	stw	r4,0(sp)
    6d74:	d8c00115 	stw	r3,4(sp)
    6d78:	e0fff917 	ldw	r3,-28(fp)
    6d7c:	d8c00215 	stw	r3,8(sp)
    6d80:	e13ffa17 	ldw	r4,-24(fp)
    6d84:	e17ffb17 	ldw	r5,-20(fp)
    6d88:	e1bffc17 	ldw	r6,-16(fp)
    6d8c:	100f883a 	mov	r7,r2
    6d90:	00068540 	call	6854 <ip_output_if>
}
    6d94:	e037883a 	mov	sp,fp
    6d98:	dfc00117 	ldw	ra,4(sp)
    6d9c:	df000017 	ldw	fp,0(sp)
    6da0:	dec00204 	addi	sp,sp,8
    6da4:	f800283a 	ret

00006da8 <ip4_addr_isbroadcast>:
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t
ip4_addr_isbroadcast(u32_t addr, const struct netif *netif)
{
    6da8:	defffc04 	addi	sp,sp,-16
    6dac:	df000315 	stw	fp,12(sp)
    6db0:	df000304 	addi	fp,sp,12
    6db4:	e13ffe15 	stw	r4,-8(fp)
    6db8:	e17fff15 	stw	r5,-4(fp)
  ip_addr_t ipaddr;
  ip4_addr_set_u32(&ipaddr, addr);
    6dbc:	e0bffe17 	ldw	r2,-8(fp)
    6dc0:	e0bffd15 	stw	r2,-12(fp)

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
    6dc4:	e0bffe17 	ldw	r2,-8(fp)
    6dc8:	10bfffe0 	cmpeqi	r2,r2,-1
    6dcc:	1000021e 	bne	r2,zero,6dd8 <ip4_addr_isbroadcast+0x30>
    6dd0:	e0bffe17 	ldw	r2,-8(fp)
    6dd4:	1000021e 	bne	r2,zero,6de0 <ip4_addr_isbroadcast+0x38>
      (addr == IPADDR_ANY)) {
    return 1;
    6dd8:	00800044 	movi	r2,1
    6ddc:	00002106 	br	6e64 <ip4_addr_isbroadcast+0xbc>
  /* no broadcast support on this network interface? */
  } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
    6de0:	e0bfff17 	ldw	r2,-4(fp)
    6de4:	10800b43 	ldbu	r2,45(r2)
    6de8:	10803fcc 	andi	r2,r2,255
    6dec:	1080008c 	andi	r2,r2,2
    6df0:	1000021e 	bne	r2,zero,6dfc <ip4_addr_isbroadcast+0x54>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
    6df4:	0005883a 	mov	r2,zero
    6df8:	00001a06 	br	6e64 <ip4_addr_isbroadcast+0xbc>
  /* address matches network interface address exactly? => no broadcast */
  } else if (addr == ip4_addr_get_u32(&netif->ip_addr)) {
    6dfc:	e0bfff17 	ldw	r2,-4(fp)
    6e00:	10c00117 	ldw	r3,4(r2)
    6e04:	e0bffe17 	ldw	r2,-8(fp)
    6e08:	1880021e 	bne	r3,r2,6e14 <ip4_addr_isbroadcast+0x6c>
    return 0;
    6e0c:	0005883a 	mov	r2,zero
    6e10:	00001406 	br	6e64 <ip4_addr_isbroadcast+0xbc>
  /*  on the same (sub) network... */
  } else if (ip_addr_netcmp(&ipaddr, &(netif->ip_addr), &(netif->netmask))
    6e14:	e0fffd17 	ldw	r3,-12(fp)
    6e18:	e0bfff17 	ldw	r2,-4(fp)
    6e1c:	10800117 	ldw	r2,4(r2)
    6e20:	1886f03a 	xor	r3,r3,r2
    6e24:	e0bfff17 	ldw	r2,-4(fp)
    6e28:	10800217 	ldw	r2,8(r2)
    6e2c:	1884703a 	and	r2,r3,r2
    6e30:	10000b1e 	bne	r2,zero,6e60 <ip4_addr_isbroadcast+0xb8>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr & ~ip4_addr_get_u32(&netif->netmask)) ==
    6e34:	e0bfff17 	ldw	r2,-4(fp)
    6e38:	10800217 	ldw	r2,8(r2)
    6e3c:	0086303a 	nor	r3,zero,r2
    6e40:	e0bffe17 	ldw	r2,-8(fp)
    6e44:	1886703a 	and	r3,r3,r2
           (IPADDR_BROADCAST & ~ip4_addr_get_u32(&netif->netmask)))) {
    6e48:	e0bfff17 	ldw	r2,-4(fp)
    6e4c:	10800217 	ldw	r2,8(r2)
    6e50:	0084303a 	nor	r2,zero,r2
  } else if (addr == ip4_addr_get_u32(&netif->ip_addr)) {
    return 0;
  /*  on the same (sub) network... */
  } else if (ip_addr_netcmp(&ipaddr, &(netif->ip_addr), &(netif->netmask))
         /* ...and host identifier bits are all ones? =>... */
          && ((addr & ~ip4_addr_get_u32(&netif->netmask)) ==
    6e54:	1880021e 	bne	r3,r2,6e60 <ip4_addr_isbroadcast+0xb8>
           (IPADDR_BROADCAST & ~ip4_addr_get_u32(&netif->netmask)))) {
    /* => network broadcast address */
    return 1;
    6e58:	00800044 	movi	r2,1
    6e5c:	00000106 	br	6e64 <ip4_addr_isbroadcast+0xbc>
  } else {
    return 0;
    6e60:	0005883a 	mov	r2,zero
  }
}
    6e64:	e037883a 	mov	sp,fp
    6e68:	df000017 	ldw	fp,0(sp)
    6e6c:	dec00104 	addi	sp,sp,4
    6e70:	f800283a 	ret

00006e74 <ip4_addr_netmask_valid>:
 * @param netmask the IPv4 netmask to check (in network byte order!)
 * @return 1 if the netmask is valid, 0 if it is not
 */
u8_t
ip4_addr_netmask_valid(u32_t netmask)
{
    6e74:	defffc04 	addi	sp,sp,-16
    6e78:	df000315 	stw	fp,12(sp)
    6e7c:	df000304 	addi	fp,sp,12
    6e80:	e13fff15 	stw	r4,-4(fp)
  u32_t mask;
  u32_t nm_hostorder = lwip_htonl(netmask);
    6e84:	e0bfff17 	ldw	r2,-4(fp)
    6e88:	1006d63a 	srli	r3,r2,24
    6e8c:	e0bfff17 	ldw	r2,-4(fp)
    6e90:	1004d23a 	srli	r2,r2,8
    6e94:	10bfc00c 	andi	r2,r2,65280
    6e98:	1886b03a 	or	r3,r3,r2
    6e9c:	e0bfff17 	ldw	r2,-4(fp)
    6ea0:	10bfc00c 	andi	r2,r2,65280
    6ea4:	1004923a 	slli	r2,r2,8
    6ea8:	1886b03a 	or	r3,r3,r2
    6eac:	e0bfff17 	ldw	r2,-4(fp)
    6eb0:	1004963a 	slli	r2,r2,24
    6eb4:	1884b03a 	or	r2,r3,r2
    6eb8:	e0bffe15 	stw	r2,-8(fp)

  /* first, check for the first zero */
  for (mask = 1UL << 31 ; mask != 0; mask >>= 1) {
    6ebc:	00a00034 	movhi	r2,32768
    6ec0:	e0bffd15 	stw	r2,-12(fp)
    6ec4:	00000706 	br	6ee4 <ip4_addr_netmask_valid+0x70>
    if ((nm_hostorder & mask) == 0) {
    6ec8:	e0fffe17 	ldw	r3,-8(fp)
    6ecc:	e0bffd17 	ldw	r2,-12(fp)
    6ed0:	1884703a 	and	r2,r3,r2
    6ed4:	10000626 	beq	r2,zero,6ef0 <ip4_addr_netmask_valid+0x7c>
{
  u32_t mask;
  u32_t nm_hostorder = lwip_htonl(netmask);

  /* first, check for the first zero */
  for (mask = 1UL << 31 ; mask != 0; mask >>= 1) {
    6ed8:	e0bffd17 	ldw	r2,-12(fp)
    6edc:	1004d07a 	srli	r2,r2,1
    6ee0:	e0bffd15 	stw	r2,-12(fp)
    6ee4:	e0bffd17 	ldw	r2,-12(fp)
    6ee8:	103ff71e 	bne	r2,zero,6ec8 <ip4_addr_netmask_valid+0x54>
    if ((nm_hostorder & mask) == 0) {
      break;
    }
  }
  /* then check that there is no one */
  for (; mask != 0; mask >>= 1) {
    6eec:	00000b06 	br	6f1c <ip4_addr_netmask_valid+0xa8>
  u32_t nm_hostorder = lwip_htonl(netmask);

  /* first, check for the first zero */
  for (mask = 1UL << 31 ; mask != 0; mask >>= 1) {
    if ((nm_hostorder & mask) == 0) {
      break;
    6ef0:	0001883a 	nop
    }
  }
  /* then check that there is no one */
  for (; mask != 0; mask >>= 1) {
    6ef4:	00000906 	br	6f1c <ip4_addr_netmask_valid+0xa8>
    if ((nm_hostorder & mask) != 0) {
    6ef8:	e0fffe17 	ldw	r3,-8(fp)
    6efc:	e0bffd17 	ldw	r2,-12(fp)
    6f00:	1884703a 	and	r2,r3,r2
    6f04:	10000226 	beq	r2,zero,6f10 <ip4_addr_netmask_valid+0x9c>
      /* there is a one after the first zero -> invalid */
      return 0;
    6f08:	0005883a 	mov	r2,zero
    6f0c:	00000606 	br	6f28 <ip4_addr_netmask_valid+0xb4>
    if ((nm_hostorder & mask) == 0) {
      break;
    }
  }
  /* then check that there is no one */
  for (; mask != 0; mask >>= 1) {
    6f10:	e0bffd17 	ldw	r2,-12(fp)
    6f14:	1004d07a 	srli	r2,r2,1
    6f18:	e0bffd15 	stw	r2,-12(fp)
    6f1c:	e0bffd17 	ldw	r2,-12(fp)
    6f20:	103ff51e 	bne	r2,zero,6ef8 <ip4_addr_netmask_valid+0x84>
      /* there is a one after the first zero -> invalid */
      return 0;
    }
  }
  /* no one after the first zero -> valid */
  return 1;
    6f24:	00800044 	movi	r2,1
}
    6f28:	e037883a 	mov	sp,fp
    6f2c:	df000017 	ldw	fp,0(sp)
    6f30:	dec00104 	addi	sp,sp,4
    6f34:	f800283a 	ret

00006f38 <ipaddr_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
ipaddr_addr(const char *cp)
{
    6f38:	defffc04 	addi	sp,sp,-16
    6f3c:	dfc00315 	stw	ra,12(sp)
    6f40:	df000215 	stw	fp,8(sp)
    6f44:	df000204 	addi	fp,sp,8
    6f48:	e13fff15 	stw	r4,-4(fp)
  ip_addr_t val;

  if (ipaddr_aton(cp, &val)) {
    6f4c:	e13fff17 	ldw	r4,-4(fp)
    6f50:	e17ffe04 	addi	r5,fp,-8
    6f54:	0006f7c0 	call	6f7c <ipaddr_aton>
    6f58:	10000226 	beq	r2,zero,6f64 <ipaddr_addr+0x2c>
    return ip4_addr_get_u32(&val);
    6f5c:	e0bffe17 	ldw	r2,-8(fp)
    6f60:	00000106 	br	6f68 <ipaddr_addr+0x30>
  }
  return (IPADDR_NONE);
    6f64:	00bfffc4 	movi	r2,-1
}
    6f68:	e037883a 	mov	sp,fp
    6f6c:	dfc00117 	ldw	ra,4(sp)
    6f70:	df000017 	ldw	fp,0(sp)
    6f74:	dec00204 	addi	sp,sp,8
    6f78:	f800283a 	ret

00006f7c <ipaddr_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
ipaddr_aton(const char *cp, ip_addr_t *addr)
{
    6f7c:	defff504 	addi	sp,sp,-44
    6f80:	dfc00a15 	stw	ra,40(sp)
    6f84:	df000915 	stw	fp,36(sp)
    6f88:	df000904 	addi	fp,sp,36
    6f8c:	e13ffe15 	stw	r4,-8(fp)
    6f90:	e17fff15 	stw	r5,-4(fp)
  u32_t val;
  u8_t base;
  char c;
  u32_t parts[4];
  u32_t *pp = parts;
    6f94:	e0bffa04 	addi	r2,fp,-24
    6f98:	e0bff915 	stw	r2,-28(fp)

  c = *cp;
    6f9c:	e0bffe17 	ldw	r2,-8(fp)
    6fa0:	10800003 	ldbu	r2,0(r2)
    6fa4:	e0bff845 	stb	r2,-31(fp)
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
    6fa8:	e0bff843 	ldbu	r2,-31(fp)
    6fac:	10803fcc 	andi	r2,r2,255
    6fb0:	10800c30 	cmpltui	r2,r2,48
    6fb4:	1000041e 	bne	r2,zero,6fc8 <ipaddr_aton+0x4c>
    6fb8:	e0bff843 	ldbu	r2,-31(fp)
    6fbc:	10803fcc 	andi	r2,r2,255
    6fc0:	10800eb0 	cmpltui	r2,r2,58
    6fc4:	1000021e 	bne	r2,zero,6fd0 <ipaddr_aton+0x54>
      return (0);
    6fc8:	0005883a 	mov	r2,zero
    6fcc:	0000ef06 	br	738c <ipaddr_aton+0x410>
    val = 0;
    6fd0:	e03ff715 	stw	zero,-36(fp)
    base = 10;
    6fd4:	00800284 	movi	r2,10
    6fd8:	e0bff805 	stb	r2,-32(fp)
    if (c == '0') {
    6fdc:	e0bff847 	ldb	r2,-31(fp)
    6fe0:	10800c18 	cmpnei	r2,r2,48
    6fe4:	1000171e 	bne	r2,zero,7044 <ipaddr_aton+0xc8>
      c = *++cp;
    6fe8:	e0bffe17 	ldw	r2,-8(fp)
    6fec:	10800044 	addi	r2,r2,1
    6ff0:	e0bffe15 	stw	r2,-8(fp)
    6ff4:	e0bffe17 	ldw	r2,-8(fp)
    6ff8:	10800003 	ldbu	r2,0(r2)
    6ffc:	e0bff845 	stb	r2,-31(fp)
      if (c == 'x' || c == 'X') {
    7000:	e0bff847 	ldb	r2,-31(fp)
    7004:	10801e20 	cmpeqi	r2,r2,120
    7008:	1000031e 	bne	r2,zero,7018 <ipaddr_aton+0x9c>
    700c:	e0bff847 	ldb	r2,-31(fp)
    7010:	10801618 	cmpnei	r2,r2,88
    7014:	1000091e 	bne	r2,zero,703c <ipaddr_aton+0xc0>
        base = 16;
    7018:	00800404 	movi	r2,16
    701c:	e0bff805 	stb	r2,-32(fp)
        c = *++cp;
    7020:	e0bffe17 	ldw	r2,-8(fp)
    7024:	10800044 	addi	r2,r2,1
    7028:	e0bffe15 	stw	r2,-8(fp)
    702c:	e0bffe17 	ldw	r2,-8(fp)
    7030:	10800003 	ldbu	r2,0(r2)
    7034:	e0bff845 	stb	r2,-31(fp)
    7038:	00000206 	br	7044 <ipaddr_aton+0xc8>
      } else
        base = 8;
    703c:	00800204 	movi	r2,8
    7040:	e0bff805 	stb	r2,-32(fp)
    }
    for (;;) {
      if (isdigit(c)) {
    7044:	e0bff843 	ldbu	r2,-31(fp)
    7048:	10803fcc 	andi	r2,r2,255
    704c:	10800c30 	cmpltui	r2,r2,48
    7050:	1000121e 	bne	r2,zero,709c <ipaddr_aton+0x120>
    7054:	e0bff843 	ldbu	r2,-31(fp)
    7058:	10803fcc 	andi	r2,r2,255
    705c:	10800ea8 	cmpgeui	r2,r2,58
    7060:	10000e1e 	bne	r2,zero,709c <ipaddr_aton+0x120>
        val = (val * base) + (int)(c - '0');
    7064:	e0fff803 	ldbu	r3,-32(fp)
    7068:	e0bff717 	ldw	r2,-36(fp)
    706c:	1887383a 	mul	r3,r3,r2
    7070:	e0bff847 	ldb	r2,-31(fp)
    7074:	1885883a 	add	r2,r3,r2
    7078:	10bff404 	addi	r2,r2,-48
    707c:	e0bff715 	stw	r2,-36(fp)
        c = *++cp;
    7080:	e0bffe17 	ldw	r2,-8(fp)
    7084:	10800044 	addi	r2,r2,1
    7088:	e0bffe15 	stw	r2,-8(fp)
    708c:	e0bffe17 	ldw	r2,-8(fp)
    7090:	10800003 	ldbu	r2,0(r2)
    7094:	e0bff845 	stb	r2,-31(fp)
      } else if (base == 16 && isxdigit(c)) {
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
        c = *++cp;
      } else
        break;
    }
    7098:	003fea06 	br	7044 <ipaddr_aton+0xc8>
    }
    for (;;) {
      if (isdigit(c)) {
        val = (val * base) + (int)(c - '0');
        c = *++cp;
      } else if (base == 16 && isxdigit(c)) {
    709c:	e0bff803 	ldbu	r2,-32(fp)
    70a0:	10800418 	cmpnei	r2,r2,16
    70a4:	1000311e 	bne	r2,zero,716c <ipaddr_aton+0x1f0>
    70a8:	e0bff843 	ldbu	r2,-31(fp)
    70ac:	10803fcc 	andi	r2,r2,255
    70b0:	10800c30 	cmpltui	r2,r2,48
    70b4:	1000041e 	bne	r2,zero,70c8 <ipaddr_aton+0x14c>
    70b8:	e0bff843 	ldbu	r2,-31(fp)
    70bc:	10803fcc 	andi	r2,r2,255
    70c0:	10800eb0 	cmpltui	r2,r2,58
    70c4:	1000101e 	bne	r2,zero,7108 <ipaddr_aton+0x18c>
    70c8:	e0bff843 	ldbu	r2,-31(fp)
    70cc:	10803fcc 	andi	r2,r2,255
    70d0:	10801870 	cmpltui	r2,r2,97
    70d4:	1000041e 	bne	r2,zero,70e8 <ipaddr_aton+0x16c>
    70d8:	e0bff843 	ldbu	r2,-31(fp)
    70dc:	10803fcc 	andi	r2,r2,255
    70e0:	108019f0 	cmpltui	r2,r2,103
    70e4:	1000081e 	bne	r2,zero,7108 <ipaddr_aton+0x18c>
    70e8:	e0bff843 	ldbu	r2,-31(fp)
    70ec:	10803fcc 	andi	r2,r2,255
    70f0:	10801070 	cmpltui	r2,r2,65
    70f4:	10001d1e 	bne	r2,zero,716c <ipaddr_aton+0x1f0>
    70f8:	e0bff843 	ldbu	r2,-31(fp)
    70fc:	10803fcc 	andi	r2,r2,255
    7100:	108011e8 	cmpgeui	r2,r2,71
    7104:	1000191e 	bne	r2,zero,716c <ipaddr_aton+0x1f0>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
    7108:	e0bff717 	ldw	r2,-36(fp)
    710c:	1006913a 	slli	r3,r2,4
    7110:	e0bff847 	ldb	r2,-31(fp)
    7114:	11000284 	addi	r4,r2,10
    7118:	e0bff843 	ldbu	r2,-31(fp)
    711c:	10803fcc 	andi	r2,r2,255
    7120:	10801870 	cmpltui	r2,r2,97
    7124:	1000061e 	bne	r2,zero,7140 <ipaddr_aton+0x1c4>
    7128:	e0bff843 	ldbu	r2,-31(fp)
    712c:	10803fcc 	andi	r2,r2,255
    7130:	10801ee8 	cmpgeui	r2,r2,123
    7134:	1000021e 	bne	r2,zero,7140 <ipaddr_aton+0x1c4>
    7138:	00801844 	movi	r2,97
    713c:	00000106 	br	7144 <ipaddr_aton+0x1c8>
    7140:	00801044 	movi	r2,65
    7144:	2085c83a 	sub	r2,r4,r2
    7148:	1884b03a 	or	r2,r3,r2
    714c:	e0bff715 	stw	r2,-36(fp)
        c = *++cp;
    7150:	e0bffe17 	ldw	r2,-8(fp)
    7154:	10800044 	addi	r2,r2,1
    7158:	e0bffe15 	stw	r2,-8(fp)
    715c:	e0bffe17 	ldw	r2,-8(fp)
    7160:	10800003 	ldbu	r2,0(r2)
    7164:	e0bff845 	stb	r2,-31(fp)
      } else
        break;
    }
    7168:	003fb606 	br	7044 <ipaddr_aton+0xc8>
    if (c == '.') {
    716c:	e0bff847 	ldb	r2,-31(fp)
    7170:	10800b98 	cmpnei	r2,r2,46
    7174:	1000131e 	bne	r2,zero,71c4 <ipaddr_aton+0x248>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3) {
    7178:	e0bffa04 	addi	r2,fp,-24
    717c:	10800304 	addi	r2,r2,12
    7180:	e0fff917 	ldw	r3,-28(fp)
    7184:	18800236 	bltu	r3,r2,7190 <ipaddr_aton+0x214>
        return (0);
    7188:	0005883a 	mov	r2,zero
    718c:	00007f06 	br	738c <ipaddr_aton+0x410>
      }
      *pp++ = val;
    7190:	e0bff917 	ldw	r2,-28(fp)
    7194:	e0fff717 	ldw	r3,-36(fp)
    7198:	10c00015 	stw	r3,0(r2)
    719c:	e0bff917 	ldw	r2,-28(fp)
    71a0:	10800104 	addi	r2,r2,4
    71a4:	e0bff915 	stw	r2,-28(fp)
      c = *++cp;
    71a8:	e0bffe17 	ldw	r2,-8(fp)
    71ac:	10800044 	addi	r2,r2,1
    71b0:	e0bffe15 	stw	r2,-8(fp)
    71b4:	e0bffe17 	ldw	r2,-8(fp)
    71b8:	10800003 	ldbu	r2,0(r2)
    71bc:	e0bff845 	stb	r2,-31(fp)
    } else
      break;
  }
    71c0:	003f7906 	br	6fa8 <ipaddr_aton+0x2c>
        return (0);
      }
      *pp++ = val;
      c = *++cp;
    } else
      break;
    71c4:	0001883a 	nop
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && !isspace(c)) {
    71c8:	e0bff847 	ldb	r2,-31(fp)
    71cc:	10001426 	beq	r2,zero,7220 <ipaddr_aton+0x2a4>
    71d0:	e0bff847 	ldb	r2,-31(fp)
    71d4:	10800820 	cmpeqi	r2,r2,32
    71d8:	1000111e 	bne	r2,zero,7220 <ipaddr_aton+0x2a4>
    71dc:	e0bff847 	ldb	r2,-31(fp)
    71e0:	10800320 	cmpeqi	r2,r2,12
    71e4:	10000e1e 	bne	r2,zero,7220 <ipaddr_aton+0x2a4>
    71e8:	e0bff847 	ldb	r2,-31(fp)
    71ec:	108002a0 	cmpeqi	r2,r2,10
    71f0:	10000b1e 	bne	r2,zero,7220 <ipaddr_aton+0x2a4>
    71f4:	e0bff847 	ldb	r2,-31(fp)
    71f8:	10800360 	cmpeqi	r2,r2,13
    71fc:	1000081e 	bne	r2,zero,7220 <ipaddr_aton+0x2a4>
    7200:	e0bff847 	ldb	r2,-31(fp)
    7204:	10800260 	cmpeqi	r2,r2,9
    7208:	1000051e 	bne	r2,zero,7220 <ipaddr_aton+0x2a4>
    720c:	e0bff847 	ldb	r2,-31(fp)
    7210:	108002e0 	cmpeqi	r2,r2,11
    7214:	1000021e 	bne	r2,zero,7220 <ipaddr_aton+0x2a4>
    return (0);
    7218:	0005883a 	mov	r2,zero
    721c:	00005b06 	br	738c <ipaddr_aton+0x410>
  }
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  switch (pp - parts + 1) {
    7220:	e0fff917 	ldw	r3,-28(fp)
    7224:	e0bffa04 	addi	r2,fp,-24
    7228:	1885c83a 	sub	r2,r3,r2
    722c:	1005d0ba 	srai	r2,r2,2
    7230:	10800044 	addi	r2,r2,1
    7234:	10c00168 	cmpgeui	r3,r2,5
    7238:	1800381e 	bne	r3,zero,731c <ipaddr_aton+0x3a0>
    723c:	1085883a 	add	r2,r2,r2
    7240:	1087883a 	add	r3,r2,r2
    7244:	00800034 	movhi	r2,0
    7248:	109c9604 	addi	r2,r2,29272
    724c:	1885883a 	add	r2,r3,r2
    7250:	10800017 	ldw	r2,0(r2)
    7254:	1000683a 	jmp	r2
    7258:	0000726c 	andhi	zero,zero,457
    725c:	00007340 	call	734 <send_data+0x70>
    7260:	00007274 	movhi	zero,457
    7264:	000072a0 	cmpeqi	zero,zero,458
    7268:	000072d8 	cmpnei	zero,zero,459

  case 0:
    return (0);       /* initial nondigit */
    726c:	0005883a 	mov	r2,zero
    7270:	00004606 	br	738c <ipaddr_aton+0x410>

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL) {
    7274:	e0fff717 	ldw	r3,-36(fp)
    7278:	00804034 	movhi	r2,256
    727c:	18800236 	bltu	r3,r2,7288 <ipaddr_aton+0x30c>
      return (0);
    7280:	0005883a 	mov	r2,zero
    7284:	00004106 	br	738c <ipaddr_aton+0x410>
    }
    val |= parts[0] << 24;
    7288:	e0bffa17 	ldw	r2,-24(fp)
    728c:	1004963a 	slli	r2,r2,24
    7290:	e0fff717 	ldw	r3,-36(fp)
    7294:	1884b03a 	or	r2,r3,r2
    7298:	e0bff715 	stw	r2,-36(fp)
    break;
    729c:	00002906 	br	7344 <ipaddr_aton+0x3c8>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff) {
    72a0:	e0bff717 	ldw	r2,-36(fp)
    72a4:	00ffffd4 	movui	r3,65535
    72a8:	1880022e 	bgeu	r3,r2,72b4 <ipaddr_aton+0x338>
      return (0);
    72ac:	0005883a 	mov	r2,zero
    72b0:	00003606 	br	738c <ipaddr_aton+0x410>
    }
    val |= (parts[0] << 24) | (parts[1] << 16);
    72b4:	e0bffa17 	ldw	r2,-24(fp)
    72b8:	1006963a 	slli	r3,r2,24
    72bc:	e0bffb17 	ldw	r2,-20(fp)
    72c0:	1004943a 	slli	r2,r2,16
    72c4:	1884b03a 	or	r2,r3,r2
    72c8:	e0fff717 	ldw	r3,-36(fp)
    72cc:	1884b03a 	or	r2,r3,r2
    72d0:	e0bff715 	stw	r2,-36(fp)
    break;
    72d4:	00001b06 	br	7344 <ipaddr_aton+0x3c8>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff) {
    72d8:	e0bff717 	ldw	r2,-36(fp)
    72dc:	10804030 	cmpltui	r2,r2,256
    72e0:	1000021e 	bne	r2,zero,72ec <ipaddr_aton+0x370>
      return (0);
    72e4:	0005883a 	mov	r2,zero
    72e8:	00002806 	br	738c <ipaddr_aton+0x410>
    }
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
    72ec:	e0bffa17 	ldw	r2,-24(fp)
    72f0:	1006963a 	slli	r3,r2,24
    72f4:	e0bffb17 	ldw	r2,-20(fp)
    72f8:	1004943a 	slli	r2,r2,16
    72fc:	1886b03a 	or	r3,r3,r2
    7300:	e0bffc17 	ldw	r2,-16(fp)
    7304:	1004923a 	slli	r2,r2,8
    7308:	1884b03a 	or	r2,r3,r2
    730c:	e0fff717 	ldw	r3,-36(fp)
    7310:	1884b03a 	or	r2,r3,r2
    7314:	e0bff715 	stw	r2,-36(fp)
    break;
    7318:	00000a06 	br	7344 <ipaddr_aton+0x3c8>
  default:
    LWIP_ASSERT("unhandled", 0);
    731c:	010000f4 	movhi	r4,3
    7320:	213e7404 	addi	r4,r4,-1584
    7324:	014000f4 	movhi	r5,3
    7328:	297e7e04 	addi	r5,r5,-1544
    732c:	01803cc4 	movi	r6,243
    7330:	01c000f4 	movhi	r7,3
    7334:	39fe8104 	addi	r7,r7,-1532
    7338:	00193f00 	call	193f0 <printf>
    733c:	003fff06 	br	733c <ipaddr_aton+0x3c0>

  case 0:
    return (0);       /* initial nondigit */

  case 1:             /* a -- 32 bits */
    break;
    7340:	0001883a 	nop
    break;
  default:
    LWIP_ASSERT("unhandled", 0);
    break;
  }
  if (addr) {
    7344:	e0bfff17 	ldw	r2,-4(fp)
    7348:	10000f26 	beq	r2,zero,7388 <ipaddr_aton+0x40c>
    ip4_addr_set_u32(addr, htonl(val));
    734c:	e0bff717 	ldw	r2,-36(fp)
    7350:	1006d63a 	srli	r3,r2,24
    7354:	e0bff717 	ldw	r2,-36(fp)
    7358:	1004d23a 	srli	r2,r2,8
    735c:	10bfc00c 	andi	r2,r2,65280
    7360:	1886b03a 	or	r3,r3,r2
    7364:	e0bff717 	ldw	r2,-36(fp)
    7368:	10bfc00c 	andi	r2,r2,65280
    736c:	1004923a 	slli	r2,r2,8
    7370:	1886b03a 	or	r3,r3,r2
    7374:	e0bff717 	ldw	r2,-36(fp)
    7378:	1004963a 	slli	r2,r2,24
    737c:	1886b03a 	or	r3,r3,r2
    7380:	e0bfff17 	ldw	r2,-4(fp)
    7384:	10c00015 	stw	r3,0(r2)
  }
  return (1);
    7388:	00800044 	movi	r2,1
}
    738c:	e037883a 	mov	sp,fp
    7390:	dfc00117 	ldw	ra,4(sp)
    7394:	df000017 	ldw	fp,0(sp)
    7398:	dec00204 	addi	sp,sp,8
    739c:	f800283a 	ret

000073a0 <ipaddr_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
ipaddr_ntoa(const ip_addr_t *addr)
{
    73a0:	defffd04 	addi	sp,sp,-12
    73a4:	dfc00215 	stw	ra,8(sp)
    73a8:	df000115 	stw	fp,4(sp)
    73ac:	df000104 	addi	fp,sp,4
    73b0:	e13fff15 	stw	r4,-4(fp)
  static char str[16];
  return ipaddr_ntoa_r(addr, str, 16);
    73b4:	e13fff17 	ldw	r4,-4(fp)
    73b8:	01400134 	movhi	r5,4
    73bc:	29623c04 	addi	r5,r5,-30480
    73c0:	01800404 	movi	r6,16
    73c4:	00073dc0 	call	73dc <ipaddr_ntoa_r>
}
    73c8:	e037883a 	mov	sp,fp
    73cc:	dfc00117 	ldw	ra,4(sp)
    73d0:	df000017 	ldw	fp,0(sp)
    73d4:	dec00204 	addi	sp,sp,8
    73d8:	f800283a 	ret

000073dc <ipaddr_ntoa_r>:
 * @param buflen length of buf
 * @return either pointer to buf which now holds the ASCII
 *         representation of addr or NULL if buf was too small
 */
char *ipaddr_ntoa_r(const ip_addr_t *addr, char *buf, int buflen)
{
    73dc:	defff504 	addi	sp,sp,-44
    73e0:	df000a15 	stw	fp,40(sp)
    73e4:	df000a04 	addi	fp,sp,40
    73e8:	e13ffd15 	stw	r4,-12(fp)
    73ec:	e17ffe15 	stw	r5,-8(fp)
    73f0:	e1bfff15 	stw	r6,-4(fp)
  char *rp;
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;
  int len = 0;
    73f4:	e03ff915 	stw	zero,-28(fp)

  s_addr = ip4_addr_get_u32(addr);
    73f8:	e0bffd17 	ldw	r2,-12(fp)
    73fc:	10800017 	ldw	r2,0(r2)
    7400:	e0bffb15 	stw	r2,-20(fp)

  rp = buf;
    7404:	e0bffe17 	ldw	r2,-8(fp)
    7408:	e0bff615 	stw	r2,-40(fp)
  ap = (u8_t *)&s_addr;
    740c:	e0bffb04 	addi	r2,fp,-20
    7410:	e0bff715 	stw	r2,-36(fp)
  for(n = 0; n < 4; n++) {
    7414:	e03ff805 	stb	zero,-32(fp)
    7418:	00004f06 	br	7558 <ipaddr_ntoa_r+0x17c>
    i = 0;
    741c:	e03ff845 	stb	zero,-31(fp)
    do {
      rem = *ap % (u8_t)10;
    7420:	e0bff717 	ldw	r2,-36(fp)
    7424:	10800003 	ldbu	r2,0(r2)
    7428:	10803fcc 	andi	r2,r2,255
    742c:	00c00284 	movi	r3,10
    7430:	10c7203a 	divu	r3,r2,r3
    7434:	18c002a4 	muli	r3,r3,10
    7438:	10c5c83a 	sub	r2,r2,r3
    743c:	e0bffa05 	stb	r2,-24(fp)
      *ap /= (u8_t)10;
    7440:	e0bff717 	ldw	r2,-36(fp)
    7444:	10800003 	ldbu	r2,0(r2)
    7448:	10c03fcc 	andi	r3,r2,255
    744c:	00800284 	movi	r2,10
    7450:	1885203a 	divu	r2,r3,r2
    7454:	1007883a 	mov	r3,r2
    7458:	e0bff717 	ldw	r2,-36(fp)
    745c:	10c00005 	stb	r3,0(r2)
      inv[i++] = '0' + rem;
    7460:	e0bff843 	ldbu	r2,-31(fp)
    7464:	e0fffa03 	ldbu	r3,-24(fp)
    7468:	18c00c04 	addi	r3,r3,48
    746c:	e13ffc04 	addi	r4,fp,-16
    7470:	2085883a 	add	r2,r4,r2
    7474:	10c00005 	stb	r3,0(r2)
    7478:	e0bff843 	ldbu	r2,-31(fp)
    747c:	10800044 	addi	r2,r2,1
    7480:	e0bff845 	stb	r2,-31(fp)
    } while(*ap);
    7484:	e0bff717 	ldw	r2,-36(fp)
    7488:	10800003 	ldbu	r2,0(r2)
    748c:	10803fcc 	andi	r2,r2,255
    7490:	103fe31e 	bne	r2,zero,7420 <ipaddr_ntoa_r+0x44>
    while(i--) {
    7494:	00001306 	br	74e4 <ipaddr_ntoa_r+0x108>
      if (len++ >= buflen) {
    7498:	e0fff917 	ldw	r3,-28(fp)
    749c:	e0bfff17 	ldw	r2,-4(fp)
    74a0:	1884403a 	cmpge	r2,r3,r2
    74a4:	e0fff917 	ldw	r3,-28(fp)
    74a8:	18c00044 	addi	r3,r3,1
    74ac:	e0fff915 	stw	r3,-28(fp)
    74b0:	10803fcc 	andi	r2,r2,255
    74b4:	10000226 	beq	r2,zero,74c0 <ipaddr_ntoa_r+0xe4>
        return NULL;
    74b8:	0005883a 	mov	r2,zero
    74bc:	00002f06 	br	757c <ipaddr_ntoa_r+0x1a0>
      }
      *rp++ = inv[i];
    74c0:	e0bff843 	ldbu	r2,-31(fp)
    74c4:	e0fffc04 	addi	r3,fp,-16
    74c8:	1885883a 	add	r2,r3,r2
    74cc:	10c00003 	ldbu	r3,0(r2)
    74d0:	e0bff617 	ldw	r2,-40(fp)
    74d4:	10c00005 	stb	r3,0(r2)
    74d8:	e0bff617 	ldw	r2,-40(fp)
    74dc:	10800044 	addi	r2,r2,1
    74e0:	e0bff615 	stw	r2,-40(fp)
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--) {
    74e4:	e0bff843 	ldbu	r2,-31(fp)
    74e8:	1004c03a 	cmpne	r2,r2,zero
    74ec:	e0fff843 	ldbu	r3,-31(fp)
    74f0:	18ffffc4 	addi	r3,r3,-1
    74f4:	e0fff845 	stb	r3,-31(fp)
    74f8:	10803fcc 	andi	r2,r2,255
    74fc:	103fe61e 	bne	r2,zero,7498 <ipaddr_ntoa_r+0xbc>
      if (len++ >= buflen) {
        return NULL;
      }
      *rp++ = inv[i];
    }
    if (len++ >= buflen) {
    7500:	e0fff917 	ldw	r3,-28(fp)
    7504:	e0bfff17 	ldw	r2,-4(fp)
    7508:	1884403a 	cmpge	r2,r3,r2
    750c:	e0fff917 	ldw	r3,-28(fp)
    7510:	18c00044 	addi	r3,r3,1
    7514:	e0fff915 	stw	r3,-28(fp)
    7518:	10803fcc 	andi	r2,r2,255
    751c:	10000226 	beq	r2,zero,7528 <ipaddr_ntoa_r+0x14c>
      return NULL;
    7520:	0005883a 	mov	r2,zero
    7524:	00001506 	br	757c <ipaddr_ntoa_r+0x1a0>
    }
    *rp++ = '.';
    7528:	e0bff617 	ldw	r2,-40(fp)
    752c:	00c00b84 	movi	r3,46
    7530:	10c00005 	stb	r3,0(r2)
    7534:	e0bff617 	ldw	r2,-40(fp)
    7538:	10800044 	addi	r2,r2,1
    753c:	e0bff615 	stw	r2,-40(fp)
    ap++;
    7540:	e0bff717 	ldw	r2,-36(fp)
    7544:	10800044 	addi	r2,r2,1
    7548:	e0bff715 	stw	r2,-36(fp)

  s_addr = ip4_addr_get_u32(addr);

  rp = buf;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    754c:	e0bff803 	ldbu	r2,-32(fp)
    7550:	10800044 	addi	r2,r2,1
    7554:	e0bff805 	stb	r2,-32(fp)
    7558:	e0bff803 	ldbu	r2,-32(fp)
    755c:	10800130 	cmpltui	r2,r2,4
    7560:	103fae1e 	bne	r2,zero,741c <ipaddr_ntoa_r+0x40>
      return NULL;
    }
    *rp++ = '.';
    ap++;
  }
  *--rp = 0;
    7564:	e0bff617 	ldw	r2,-40(fp)
    7568:	10bfffc4 	addi	r2,r2,-1
    756c:	e0bff615 	stw	r2,-40(fp)
    7570:	e0bff617 	ldw	r2,-40(fp)
    7574:	10000005 	stb	zero,0(r2)
  return buf;
    7578:	e0bffe17 	ldw	r2,-8(fp)
}
    757c:	e037883a 	mov	sp,fp
    7580:	df000017 	ldw	fp,0(sp)
    7584:	dec00104 	addi	sp,sp,4
    7588:	f800283a 	ret

0000758c <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
    758c:	defffb04 	addi	sp,sp,-20
    7590:	dfc00415 	stw	ra,16(sp)
    7594:	df000315 	stw	fp,12(sp)
    7598:	df000304 	addi	fp,sp,12
  struct ip_reassdata *r, *prev = NULL;
    759c:	e03ffe15 	stw	zero,-8(fp)

  r = reassdatagrams;
    75a0:	d0a8b117 	ldw	r2,-23868(gp)
    75a4:	e0bffd15 	stw	r2,-12(fp)
  while (r != NULL) {
    75a8:	00001806 	br	760c <ip_reass_tmr+0x80>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
    75ac:	e0bffd17 	ldw	r2,-12(fp)
    75b0:	108007c3 	ldbu	r2,31(r2)
    75b4:	10803fcc 	andi	r2,r2,255
    75b8:	10000c26 	beq	r2,zero,75ec <ip_reass_tmr+0x60>
      r->timer--;
    75bc:	e0bffd17 	ldw	r2,-12(fp)
    75c0:	108007c3 	ldbu	r2,31(r2)
    75c4:	10bfffc4 	addi	r2,r2,-1
    75c8:	1007883a 	mov	r3,r2
    75cc:	e0bffd17 	ldw	r2,-12(fp)
    75d0:	10c007c5 	stb	r3,31(r2)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
    75d4:	e0bffd17 	ldw	r2,-12(fp)
    75d8:	e0bffe15 	stw	r2,-8(fp)
      r = r->next;
    75dc:	e0bffd17 	ldw	r2,-12(fp)
    75e0:	10800017 	ldw	r2,0(r2)
    75e4:	e0bffd15 	stw	r2,-12(fp)
    75e8:	00000806 	br	760c <ip_reass_tmr+0x80>
    } else {
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
    75ec:	e0bffd17 	ldw	r2,-12(fp)
    75f0:	e0bfff15 	stw	r2,-4(fp)
      /* get the next pointer before freeing */
      r = r->next;
    75f4:	e0bffd17 	ldw	r2,-12(fp)
    75f8:	10800017 	ldw	r2,0(r2)
    75fc:	e0bffd15 	stw	r2,-12(fp)
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
    7600:	e13fff17 	ldw	r4,-4(fp)
    7604:	e17ffe17 	ldw	r5,-8(fp)
    7608:	00076280 	call	7628 <ip_reass_free_complete_datagram>
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
    760c:	e0bffd17 	ldw	r2,-12(fp)
    7610:	103fe61e 	bne	r2,zero,75ac <ip_reass_tmr+0x20>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
    7614:	e037883a 	mov	sp,fp
    7618:	dfc00117 	ldw	ra,4(sp)
    761c:	df000017 	ldw	fp,0(sp)
    7620:	dec00204 	addi	sp,sp,8
    7624:	f800283a 	ret

00007628 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
    7628:	defff704 	addi	sp,sp,-36
    762c:	dfc00815 	stw	ra,32(sp)
    7630:	df000715 	stw	fp,28(sp)
    7634:	df000704 	addi	fp,sp,28
    7638:	e13ffe15 	stw	r4,-8(fp)
    763c:	e17fff15 	stw	r5,-4(fp)
  u16_t pbufs_freed = 0;
    7640:	e03ff90d 	sth	zero,-28(fp)
  u8_t clen;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
    7644:	e0ffff17 	ldw	r3,-4(fp)
    7648:	e0bffe17 	ldw	r2,-8(fp)
    764c:	1880091e 	bne	r3,r2,7674 <ip_reass_free_complete_datagram+0x4c>
    7650:	010000f4 	movhi	r4,3
    7654:	213e8904 	addi	r4,r4,-1500
    7658:	014000f4 	movhi	r5,3
    765c:	297e9304 	addi	r5,r5,-1460
    7660:	01802944 	movi	r6,165
    7664:	01c000f4 	movhi	r7,3
    7668:	39fe9604 	addi	r7,r7,-1448
    766c:	00193f00 	call	193f0 <printf>
    7670:	003fff06 	br	7670 <ip_reass_free_complete_datagram+0x48>
  if (prev != NULL) {
    7674:	e0bfff17 	ldw	r2,-4(fp)
    7678:	10000d26 	beq	r2,zero,76b0 <ip_reass_free_complete_datagram+0x88>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
    767c:	e0bfff17 	ldw	r2,-4(fp)
    7680:	10c00017 	ldw	r3,0(r2)
    7684:	e0bffe17 	ldw	r2,-8(fp)
    7688:	18800926 	beq	r3,r2,76b0 <ip_reass_free_complete_datagram+0x88>
    768c:	010000f4 	movhi	r4,3
    7690:	213e8904 	addi	r4,r4,-1500
    7694:	014000f4 	movhi	r5,3
    7698:	297e9e04 	addi	r5,r5,-1416
    769c:	018029c4 	movi	r6,167
    76a0:	01c000f4 	movhi	r7,3
    76a4:	39fe9604 	addi	r7,r7,-1448
    76a8:	00193f00 	call	193f0 <printf>
    76ac:	003fff06 	br	76ac <ip_reass_free_complete_datagram+0x84>
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
    76b0:	e0bffe17 	ldw	r2,-8(fp)
    76b4:	10800117 	ldw	r2,4(r2)
    76b8:	10800117 	ldw	r2,4(r2)
    76bc:	e0bffb15 	stw	r2,-20(fp)
  if (iprh->start == 0) {
    76c0:	e0bffb17 	ldw	r2,-20(fp)
    76c4:	1080010b 	ldhu	r2,4(r2)
    76c8:	10bfffcc 	andi	r2,r2,65535
    76cc:	10002d1e 	bne	r2,zero,7784 <ip_reass_free_complete_datagram+0x15c>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    76d0:	e0bffe17 	ldw	r2,-8(fp)
    76d4:	10800117 	ldw	r2,4(r2)
    76d8:	e0bffa15 	stw	r2,-24(fp)
    ipr->p = iprh->next_pbuf;
    76dc:	e0bffb17 	ldw	r2,-20(fp)
    76e0:	10c0000b 	ldhu	r3,0(r2)
    76e4:	1080008b 	ldhu	r2,2(r2)
    76e8:	1004943a 	slli	r2,r2,16
    76ec:	10c4b03a 	or	r2,r2,r3
    76f0:	1007883a 	mov	r3,r2
    76f4:	e0bffe17 	ldw	r2,-8(fp)
    76f8:	10c00115 	stw	r3,4(r2)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
    76fc:	e0bffa17 	ldw	r2,-24(fp)
    7700:	10c00117 	ldw	r3,4(r2)
    7704:	e0bffe17 	ldw	r2,-8(fp)
    7708:	10800204 	addi	r2,r2,8
    770c:	1809883a 	mov	r4,r3
    7710:	100b883a 	mov	r5,r2
    7714:	01800504 	movi	r6,20
    7718:	00191f00 	call	191f0 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
    771c:	e13ffa17 	ldw	r4,-24(fp)
    7720:	01400044 	movi	r5,1
    7724:	00059ac0 	call	59ac <icmp_time_exceeded>
    clen = pbuf_clen(p);
    7728:	e13ffa17 	ldw	r4,-24(fp)
    772c:	000ac000 	call	ac00 <pbuf_clen>
    7730:	e0bffc05 	stb	r2,-16(fp)
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    7734:	e0fff90b 	ldhu	r3,-28(fp)
    7738:	e0bffc03 	ldbu	r2,-16(fp)
    773c:	1885883a 	add	r2,r3,r2
    7740:	00ffffd4 	movui	r3,65535
    7744:	1880090e 	bge	r3,r2,776c <ip_reass_free_complete_datagram+0x144>
    7748:	010000f4 	movhi	r4,3
    774c:	213e8904 	addi	r4,r4,-1500
    7750:	014000f4 	movhi	r5,3
    7754:	297ea304 	addi	r5,r5,-1396
    7758:	01802d84 	movi	r6,182
    775c:	01c000f4 	movhi	r7,3
    7760:	39fe9604 	addi	r7,r7,-1448
    7764:	00193f00 	call	193f0 <printf>
    7768:	003fff06 	br	7768 <ip_reass_free_complete_datagram+0x140>
    pbufs_freed += clen;
    776c:	e0fffc03 	ldbu	r3,-16(fp)
    7770:	e0bff90b 	ldhu	r2,-28(fp)
    7774:	1885883a 	add	r2,r3,r2
    7778:	e0bff90d 	sth	r2,-28(fp)
    pbuf_free(p);
    777c:	e13ffa17 	ldw	r4,-24(fp)
    7780:	000aa340 	call	aa34 <pbuf_free>
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
    7784:	e0bffe17 	ldw	r2,-8(fp)
    7788:	10800117 	ldw	r2,4(r2)
    778c:	e0bffa15 	stw	r2,-24(fp)
  while (p != NULL) {
    7790:	00002206 	br	781c <ip_reass_free_complete_datagram+0x1f4>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
    7794:	e0bffa17 	ldw	r2,-24(fp)
    7798:	10800117 	ldw	r2,4(r2)
    779c:	e0bffb15 	stw	r2,-20(fp)
    pcur = p;
    77a0:	e0bffa17 	ldw	r2,-24(fp)
    77a4:	e0bffd15 	stw	r2,-12(fp)
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
    77a8:	e0bffb17 	ldw	r2,-20(fp)
    77ac:	10c0000b 	ldhu	r3,0(r2)
    77b0:	1080008b 	ldhu	r2,2(r2)
    77b4:	1004943a 	slli	r2,r2,16
    77b8:	10c4b03a 	or	r2,r2,r3
    77bc:	e0bffa15 	stw	r2,-24(fp)
    clen = pbuf_clen(pcur);
    77c0:	e13ffd17 	ldw	r4,-12(fp)
    77c4:	000ac000 	call	ac00 <pbuf_clen>
    77c8:	e0bffc05 	stb	r2,-16(fp)
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    77cc:	e0fff90b 	ldhu	r3,-28(fp)
    77d0:	e0bffc03 	ldbu	r2,-16(fp)
    77d4:	1885883a 	add	r2,r3,r2
    77d8:	00ffffd4 	movui	r3,65535
    77dc:	1880090e 	bge	r3,r2,7804 <ip_reass_free_complete_datagram+0x1dc>
    77e0:	010000f4 	movhi	r4,3
    77e4:	213e8904 	addi	r4,r4,-1500
    77e8:	014000f4 	movhi	r5,3
    77ec:	297ea304 	addi	r5,r5,-1396
    77f0:	01803184 	movi	r6,198
    77f4:	01c000f4 	movhi	r7,3
    77f8:	39fe9604 	addi	r7,r7,-1448
    77fc:	00193f00 	call	193f0 <printf>
    7800:	003fff06 	br	7800 <ip_reass_free_complete_datagram+0x1d8>
    pbufs_freed += clen;
    7804:	e0fffc03 	ldbu	r3,-16(fp)
    7808:	e0bff90b 	ldhu	r2,-28(fp)
    780c:	1885883a 	add	r2,r3,r2
    7810:	e0bff90d 	sth	r2,-28(fp)
    pbuf_free(pcur);
    7814:	e13ffd17 	ldw	r4,-12(fp)
    7818:	000aa340 	call	aa34 <pbuf_free>
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
    781c:	e0bffa17 	ldw	r2,-24(fp)
    7820:	103fdc1e 	bne	r2,zero,7794 <ip_reass_free_complete_datagram+0x16c>
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
    pbuf_free(pcur);
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
    7824:	e13ffe17 	ldw	r4,-8(fp)
    7828:	e17fff17 	ldw	r5,-4(fp)
    782c:	0007abc0 	call	7abc <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
    7830:	d0a8b20b 	ldhu	r2,-23864(gp)
    7834:	10ffffcc 	andi	r3,r2,65535
    7838:	e0bff90b 	ldhu	r2,-28(fp)
    783c:	1880092e 	bgeu	r3,r2,7864 <ip_reass_free_complete_datagram+0x23c>
    7840:	010000f4 	movhi	r4,3
    7844:	213e8904 	addi	r4,r4,-1500
    7848:	014000f4 	movhi	r5,3
    784c:	297eab04 	addi	r5,r5,-1364
    7850:	01803304 	movi	r6,204
    7854:	01c000f4 	movhi	r7,3
    7858:	39fe9604 	addi	r7,r7,-1448
    785c:	00193f00 	call	193f0 <printf>
    7860:	003fff06 	br	7860 <ip_reass_free_complete_datagram+0x238>
  ip_reass_pbufcount -= pbufs_freed;
    7864:	d0e8b20b 	ldhu	r3,-23864(gp)
    7868:	e0bff90b 	ldhu	r2,-28(fp)
    786c:	1885c83a 	sub	r2,r3,r2
    7870:	d0a8b20d 	sth	r2,-23864(gp)

  return pbufs_freed;
    7874:	e0bff90b 	ldhu	r2,-28(fp)
}
    7878:	e037883a 	mov	sp,fp
    787c:	dfc00117 	ldw	ra,4(sp)
    7880:	df000017 	ldw	fp,0(sp)
    7884:	dec00204 	addi	sp,sp,8
    7888:	f800283a 	ret

0000788c <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
    788c:	defff604 	addi	sp,sp,-40
    7890:	dfc00915 	stw	ra,36(sp)
    7894:	df000815 	stw	fp,32(sp)
    7898:	df000804 	addi	fp,sp,32
    789c:	e13ffe15 	stw	r4,-8(fp)
    78a0:	e17fff15 	stw	r5,-4(fp)
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
    78a4:	e03ffb15 	stw	zero,-20(fp)
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    78a8:	e03ff915 	stw	zero,-28(fp)
    prev = NULL;
    78ac:	e03ffa15 	stw	zero,-24(fp)
    other_datagrams = 0;
    78b0:	e03ffc15 	stw	zero,-16(fp)
    r = reassdatagrams;
    78b4:	d0a8b117 	ldw	r2,-23868(gp)
    78b8:	e0bff815 	stw	r2,-32(fp)
    while (r != NULL) {
    78bc:	00003006 	br	7980 <ip_reass_remove_oldest_datagram+0xf4>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
    78c0:	e0bff817 	ldw	r2,-32(fp)
    78c4:	10c00517 	ldw	r3,20(r2)
    78c8:	e0bffe17 	ldw	r2,-8(fp)
    78cc:	1100030b 	ldhu	r4,12(r2)
    78d0:	1080038b 	ldhu	r2,14(r2)
    78d4:	1004943a 	slli	r2,r2,16
    78d8:	1104b03a 	or	r2,r2,r4
    78dc:	18800f1e 	bne	r3,r2,791c <ip_reass_remove_oldest_datagram+0x90>
    78e0:	e0bff817 	ldw	r2,-32(fp)
    78e4:	10c00617 	ldw	r3,24(r2)
    78e8:	e0bffe17 	ldw	r2,-8(fp)
    78ec:	1100040b 	ldhu	r4,16(r2)
    78f0:	1080048b 	ldhu	r2,18(r2)
    78f4:	1004943a 	slli	r2,r2,16
    78f8:	1104b03a 	or	r2,r2,r4
    78fc:	1880071e 	bne	r3,r2,791c <ip_reass_remove_oldest_datagram+0x90>
    7900:	e0bff817 	ldw	r2,-32(fp)
    7904:	10c0030b 	ldhu	r3,12(r2)
    7908:	e0bffe17 	ldw	r2,-8(fp)
    790c:	1080010b 	ldhu	r2,4(r2)
    7910:	18ffffcc 	andi	r3,r3,65535
    7914:	10bfffcc 	andi	r2,r2,65535
    7918:	18801126 	beq	r3,r2,7960 <ip_reass_remove_oldest_datagram+0xd4>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
    791c:	e0bffc17 	ldw	r2,-16(fp)
    7920:	10800044 	addi	r2,r2,1
    7924:	e0bffc15 	stw	r2,-16(fp)
        if (oldest == NULL) {
    7928:	e0bff917 	ldw	r2,-28(fp)
    792c:	1000031e 	bne	r2,zero,793c <ip_reass_remove_oldest_datagram+0xb0>
          oldest = r;
    7930:	e0bff817 	ldw	r2,-32(fp)
    7934:	e0bff915 	stw	r2,-28(fp)
    7938:	00000906 	br	7960 <ip_reass_remove_oldest_datagram+0xd4>
        } else if (r->timer <= oldest->timer) {
    793c:	e0bff817 	ldw	r2,-32(fp)
    7940:	108007c3 	ldbu	r2,31(r2)
    7944:	e0fff917 	ldw	r3,-28(fp)
    7948:	18c007c3 	ldbu	r3,31(r3)
    794c:	10803fcc 	andi	r2,r2,255
    7950:	18c03fcc 	andi	r3,r3,255
    7954:	18800236 	bltu	r3,r2,7960 <ip_reass_remove_oldest_datagram+0xd4>
          /* older than the previous oldest */
          oldest = r;
    7958:	e0bff817 	ldw	r2,-32(fp)
    795c:	e0bff915 	stw	r2,-28(fp)
        }
      }
      if (r->next != NULL) {
    7960:	e0bff817 	ldw	r2,-32(fp)
    7964:	10800017 	ldw	r2,0(r2)
    7968:	10000226 	beq	r2,zero,7974 <ip_reass_remove_oldest_datagram+0xe8>
        prev = r;
    796c:	e0bff817 	ldw	r2,-32(fp)
    7970:	e0bffa15 	stw	r2,-24(fp)
      }
      r = r->next;
    7974:	e0bff817 	ldw	r2,-32(fp)
    7978:	10800017 	ldw	r2,0(r2)
    797c:	e0bff815 	stw	r2,-32(fp)
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
    7980:	e0bff817 	ldw	r2,-32(fp)
    7984:	103fce1e 	bne	r2,zero,78c0 <ip_reass_remove_oldest_datagram+0x34>
      if (r->next != NULL) {
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
    7988:	e0bff917 	ldw	r2,-28(fp)
    798c:	10000826 	beq	r2,zero,79b0 <ip_reass_remove_oldest_datagram+0x124>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
    7990:	e13ff917 	ldw	r4,-28(fp)
    7994:	e17ffa17 	ldw	r5,-24(fp)
    7998:	00076280 	call	7628 <ip_reass_free_complete_datagram>
    799c:	e0bffd15 	stw	r2,-12(fp)
      pbufs_freed += pbufs_freed_current;
    79a0:	e0fffb17 	ldw	r3,-20(fp)
    79a4:	e0bffd17 	ldw	r2,-12(fp)
    79a8:	1885883a 	add	r2,r3,r2
    79ac:	e0bffb15 	stw	r2,-20(fp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
    79b0:	e0fffb17 	ldw	r3,-20(fp)
    79b4:	e0bfff17 	ldw	r2,-4(fp)
    79b8:	1880030e 	bge	r3,r2,79c8 <ip_reass_remove_oldest_datagram+0x13c>
    79bc:	e0bffc17 	ldw	r2,-16(fp)
    79c0:	10800088 	cmpgei	r2,r2,2
    79c4:	103fb81e 	bne	r2,zero,78a8 <ip_reass_remove_oldest_datagram+0x1c>
  return pbufs_freed;
    79c8:	e0bffb17 	ldw	r2,-20(fp)
}
    79cc:	e037883a 	mov	sp,fp
    79d0:	dfc00117 	ldw	ra,4(sp)
    79d4:	df000017 	ldw	fp,0(sp)
    79d8:	dec00204 	addi	sp,sp,8
    79dc:	f800283a 	ret

000079e0 <ip_reass_enqueue_new_datagram>:
 * @param clen number of pbufs needed to enqueue (used for freeing other datagrams if not enough space)
 * @return A pointer to the queue location into which the fragment was enqueued
 */
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
    79e0:	defffb04 	addi	sp,sp,-20
    79e4:	dfc00415 	stw	ra,16(sp)
    79e8:	df000315 	stw	fp,12(sp)
    79ec:	df000304 	addi	fp,sp,12
    79f0:	e13ffe15 	stw	r4,-8(fp)
    79f4:	e17fff15 	stw	r5,-4(fp)
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
    79f8:	01000144 	movi	r4,5
    79fc:	00095f80 	call	95f8 <memp_malloc>
    7a00:	e0bffd15 	stw	r2,-12(fp)
  if (ipr == NULL) {
    7a04:	e0bffd17 	ldw	r2,-12(fp)
    7a08:	1000141e 	bne	r2,zero,7a5c <ip_reass_enqueue_new_datagram+0x7c>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
    7a0c:	e13ffe17 	ldw	r4,-8(fp)
    7a10:	e17fff17 	ldw	r5,-4(fp)
    7a14:	000788c0 	call	788c <ip_reass_remove_oldest_datagram>
    7a18:	e0ffff17 	ldw	r3,-4(fp)
    7a1c:	10c00316 	blt	r2,r3,7a2c <ip_reass_enqueue_new_datagram+0x4c>
      ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
    7a20:	01000144 	movi	r4,5
    7a24:	00095f80 	call	95f8 <memp_malloc>
    7a28:	e0bffd15 	stw	r2,-12(fp)
    }
    if (ipr == NULL)
    7a2c:	e0bffd17 	ldw	r2,-12(fp)
    7a30:	10000a1e 	bne	r2,zero,7a5c <ip_reass_enqueue_new_datagram+0x7c>
#endif /* IP_REASS_FREE_OLDEST */
    {
      IPFRAG_STATS_INC(ip_frag.memerr);
    7a34:	00800234 	movhi	r2,8
    7a38:	1083bd04 	addi	r2,r2,3828
    7a3c:	10800f0b 	ldhu	r2,60(r2)
    7a40:	10800044 	addi	r2,r2,1
    7a44:	1007883a 	mov	r3,r2
    7a48:	00800234 	movhi	r2,8
    7a4c:	1083bd04 	addi	r2,r2,3828
    7a50:	10c00f0d 	sth	r3,60(r2)
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    7a54:	0005883a 	mov	r2,zero
    7a58:	00001306 	br	7aa8 <ip_reass_enqueue_new_datagram+0xc8>
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
    7a5c:	e13ffd17 	ldw	r4,-12(fp)
    7a60:	000b883a 	mov	r5,zero
    7a64:	01800804 	movi	r6,32
    7a68:	00192e80 	call	192e8 <memset>
  ipr->timer = IP_REASS_MAXAGE;
    7a6c:	e0bffd17 	ldw	r2,-12(fp)
    7a70:	00c000c4 	movi	r3,3
    7a74:	10c007c5 	stb	r3,31(r2)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
    7a78:	d0e8b117 	ldw	r3,-23868(gp)
    7a7c:	e0bffd17 	ldw	r2,-12(fp)
    7a80:	10c00015 	stw	r3,0(r2)
  reassdatagrams = ipr;
    7a84:	e0bffd17 	ldw	r2,-12(fp)
    7a88:	d0a8b115 	stw	r2,-23868(gp)
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
    7a8c:	e0bffd17 	ldw	r2,-12(fp)
    7a90:	10800204 	addi	r2,r2,8
    7a94:	1009883a 	mov	r4,r2
    7a98:	e17ffe17 	ldw	r5,-8(fp)
    7a9c:	01800504 	movi	r6,20
    7aa0:	00191f00 	call	191f0 <memcpy>
  return ipr;
    7aa4:	e0bffd17 	ldw	r2,-12(fp)
}
    7aa8:	e037883a 	mov	sp,fp
    7aac:	dfc00117 	ldw	ra,4(sp)
    7ab0:	df000017 	ldw	fp,0(sp)
    7ab4:	dec00204 	addi	sp,sp,8
    7ab8:	f800283a 	ret

00007abc <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
    7abc:	defffc04 	addi	sp,sp,-16
    7ac0:	dfc00315 	stw	ra,12(sp)
    7ac4:	df000215 	stw	fp,8(sp)
    7ac8:	df000204 	addi	fp,sp,8
    7acc:	e13ffe15 	stw	r4,-8(fp)
    7ad0:	e17fff15 	stw	r5,-4(fp)
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
    7ad4:	d0e8b117 	ldw	r3,-23868(gp)
    7ad8:	e0bffe17 	ldw	r2,-8(fp)
    7adc:	1880041e 	bne	r3,r2,7af0 <ip_reass_dequeue_datagram+0x34>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
    7ae0:	e0bffe17 	ldw	r2,-8(fp)
    7ae4:	10800017 	ldw	r2,0(r2)
    7ae8:	d0a8b115 	stw	r2,-23868(gp)
    7aec:	00000f06 	br	7b2c <ip_reass_dequeue_datagram+0x70>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    7af0:	e0bfff17 	ldw	r2,-4(fp)
    7af4:	1000091e 	bne	r2,zero,7b1c <ip_reass_dequeue_datagram+0x60>
    7af8:	010000f4 	movhi	r4,3
    7afc:	213e8904 	addi	r4,r4,-1500
    7b00:	014000f4 	movhi	r5,3
    7b04:	297eb204 	addi	r5,r5,-1336
    7b08:	01804e44 	movi	r6,313
    7b0c:	01c000f4 	movhi	r7,3
    7b10:	39fe9604 	addi	r7,r7,-1448
    7b14:	00193f00 	call	193f0 <printf>
    7b18:	003fff06 	br	7b18 <ip_reass_dequeue_datagram+0x5c>
    prev->next = ipr->next;
    7b1c:	e0bffe17 	ldw	r2,-8(fp)
    7b20:	10c00017 	ldw	r3,0(r2)
    7b24:	e0bfff17 	ldw	r2,-4(fp)
    7b28:	10c00015 	stw	r3,0(r2)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
    7b2c:	01000144 	movi	r4,5
    7b30:	e17ffe17 	ldw	r5,-8(fp)
    7b34:	00097d40 	call	97d4 <memp_free>
}
    7b38:	e037883a 	mov	sp,fp
    7b3c:	dfc00117 	ldw	ra,4(sp)
    7b40:	df000017 	ldw	fp,0(sp)
    7b44:	dec00204 	addi	sp,sp,8
    7b48:	f800283a 	ret

00007b4c <ip_reass_chain_frag_into_datagram_and_validate>:
 * @param new_p points to the pbuf for the current fragment
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
    7b4c:	defff404 	addi	sp,sp,-48
    7b50:	dfc00b15 	stw	ra,44(sp)
    7b54:	df000a15 	stw	fp,40(sp)
    7b58:	dc000915 	stw	r16,36(sp)
    7b5c:	df000904 	addi	fp,sp,36
    7b60:	e13ffe15 	stw	r4,-8(fp)
    7b64:	e17fff15 	stw	r5,-4(fp)
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
    7b68:	e03ff815 	stw	zero,-32(fp)
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
    7b6c:	00800044 	movi	r2,1
    7b70:	e0bffa15 	stw	r2,-24(fp)

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
    7b74:	e0bfff17 	ldw	r2,-4(fp)
    7b78:	10800117 	ldw	r2,4(r2)
    7b7c:	e0bffb15 	stw	r2,-20(fp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    7b80:	e0bffb17 	ldw	r2,-20(fp)
    7b84:	1080008b 	ldhu	r2,2(r2)
    7b88:	10bfffcc 	andi	r2,r2,65535
    7b8c:	1004d23a 	srli	r2,r2,8
    7b90:	1007883a 	mov	r3,r2
    7b94:	e0bffb17 	ldw	r2,-20(fp)
    7b98:	1080008b 	ldhu	r2,2(r2)
    7b9c:	10bfffcc 	andi	r2,r2,65535
    7ba0:	1004923a 	slli	r2,r2,8
    7ba4:	1884b03a 	or	r2,r3,r2
    7ba8:	1007883a 	mov	r3,r2
    7bac:	e0bffb17 	ldw	r2,-20(fp)
    7bb0:	10800003 	ldbu	r2,0(r2)
    7bb4:	10803fcc 	andi	r2,r2,255
    7bb8:	108003cc 	andi	r2,r2,15
    7bbc:	10bfff24 	muli	r2,r2,-4
    7bc0:	1885883a 	add	r2,r3,r2
    7bc4:	e0bffc0d 	sth	r2,-16(fp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    7bc8:	e0bffb17 	ldw	r2,-20(fp)
    7bcc:	1080018b 	ldhu	r2,6(r2)
    7bd0:	10bfffcc 	andi	r2,r2,65535
    7bd4:	1004d23a 	srli	r2,r2,8
    7bd8:	10ffffcc 	andi	r3,r2,65535
    7bdc:	e0bffb17 	ldw	r2,-20(fp)
    7be0:	1080018b 	ldhu	r2,6(r2)
    7be4:	10bfffcc 	andi	r2,r2,65535
    7be8:	1004923a 	slli	r2,r2,8
    7bec:	10bfffcc 	andi	r2,r2,65535
    7bf0:	1884b03a 	or	r2,r3,r2
    7bf4:	1087ffcc 	andi	r2,r2,8191
    7bf8:	100490fa 	slli	r2,r2,3
    7bfc:	e0bffc8d 	sth	r2,-14(fp)
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
    7c00:	e0bfff17 	ldw	r2,-4(fp)
    7c04:	10800117 	ldw	r2,4(r2)
    7c08:	e0bff715 	stw	r2,-36(fp)
  iprh->next_pbuf = NULL;
    7c0c:	e0bff717 	ldw	r2,-36(fp)
    7c10:	10c0000b 	ldhu	r3,0(r2)
    7c14:	1806703a 	and	r3,r3,zero
    7c18:	10c0000d 	sth	r3,0(r2)
    7c1c:	10c0008b 	ldhu	r3,2(r2)
    7c20:	1806703a 	and	r3,r3,zero
    7c24:	10c0008d 	sth	r3,2(r2)
  iprh->start = offset;
    7c28:	e0bff717 	ldw	r2,-36(fp)
    7c2c:	e0fffc8b 	ldhu	r3,-14(fp)
    7c30:	10c0010d 	sth	r3,4(r2)
  iprh->end = offset + len;
    7c34:	e0fffc8b 	ldhu	r3,-14(fp)
    7c38:	e0bffc0b 	ldhu	r2,-16(fp)
    7c3c:	1885883a 	add	r2,r3,r2
    7c40:	1007883a 	mov	r3,r2
    7c44:	e0bff717 	ldw	r2,-36(fp)
    7c48:	10c0018d 	sth	r3,6(r2)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    7c4c:	e0bffe17 	ldw	r2,-8(fp)
    7c50:	10800117 	ldw	r2,4(r2)
    7c54:	e0bff915 	stw	r2,-28(fp)
    7c58:	00005906 	br	7dc0 <ip_reass_chain_frag_into_datagram_and_validate+0x274>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
    7c5c:	e0bff917 	ldw	r2,-28(fp)
    7c60:	10800117 	ldw	r2,4(r2)
    7c64:	e0bffd15 	stw	r2,-12(fp)
    if (iprh->start < iprh_tmp->start) {
    7c68:	e0bff717 	ldw	r2,-36(fp)
    7c6c:	10c0010b 	ldhu	r3,4(r2)
    7c70:	e0bffd17 	ldw	r2,-12(fp)
    7c74:	1080010b 	ldhu	r2,4(r2)
    7c78:	18ffffcc 	andi	r3,r3,65535
    7c7c:	10bfffcc 	andi	r2,r2,65535
    7c80:	18802f2e 	bgeu	r3,r2,7d40 <ip_reass_chain_frag_into_datagram_and_validate+0x1f4>
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
    7c84:	e0bff717 	ldw	r2,-36(fp)
    7c88:	e0fff917 	ldw	r3,-28(fp)
    7c8c:	18ffffcc 	andi	r3,r3,65535
    7c90:	1100000b 	ldhu	r4,0(r2)
    7c94:	2008703a 	and	r4,r4,zero
    7c98:	20c6b03a 	or	r3,r4,r3
    7c9c:	10c0000d 	sth	r3,0(r2)
    7ca0:	e0fff917 	ldw	r3,-28(fp)
    7ca4:	1806d43a 	srli	r3,r3,16
    7ca8:	1100008b 	ldhu	r4,2(r2)
    7cac:	2008703a 	and	r4,r4,zero
    7cb0:	20c6b03a 	or	r3,r4,r3
    7cb4:	10c0008d 	sth	r3,2(r2)
      if (iprh_prev != NULL) {
    7cb8:	e0bff817 	ldw	r2,-32(fp)
    7cbc:	10001c26 	beq	r2,zero,7d30 <ip_reass_chain_frag_into_datagram_and_validate+0x1e4>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
    7cc0:	e0bff717 	ldw	r2,-36(fp)
    7cc4:	10c0010b 	ldhu	r3,4(r2)
    7cc8:	e0bff817 	ldw	r2,-32(fp)
    7ccc:	1080018b 	ldhu	r2,6(r2)
    7cd0:	18ffffcc 	andi	r3,r3,65535
    7cd4:	10bfffcc 	andi	r2,r2,65535
    7cd8:	1880e436 	bltu	r3,r2,806c <ip_reass_chain_frag_into_datagram_and_validate+0x520>
    7cdc:	e0bff717 	ldw	r2,-36(fp)
    7ce0:	1080018b 	ldhu	r2,6(r2)
    7ce4:	e0fffd17 	ldw	r3,-12(fp)
    7ce8:	18c0010b 	ldhu	r3,4(r3)
    7cec:	10bfffcc 	andi	r2,r2,65535
    7cf0:	18ffffcc 	andi	r3,r3,65535
    7cf4:	1880dd36 	bltu	r3,r2,806c <ip_reass_chain_frag_into_datagram_and_validate+0x520>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
    7cf8:	e0bff817 	ldw	r2,-32(fp)
    7cfc:	e0ffff17 	ldw	r3,-4(fp)
    7d00:	18ffffcc 	andi	r3,r3,65535
    7d04:	1100000b 	ldhu	r4,0(r2)
    7d08:	2008703a 	and	r4,r4,zero
    7d0c:	20c6b03a 	or	r3,r4,r3
    7d10:	10c0000d 	sth	r3,0(r2)
    7d14:	e0ffff17 	ldw	r3,-4(fp)
    7d18:	1806d43a 	srli	r3,r3,16
    7d1c:	1100008b 	ldhu	r4,2(r2)
    7d20:	2008703a 	and	r4,r4,zero
    7d24:	20c6b03a 	or	r3,r4,r3
    7d28:	10c0008d 	sth	r3,2(r2)
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
    7d2c:	00002606 	br	7dc8 <ip_reass_chain_frag_into_datagram_and_validate+0x27c>
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
    7d30:	e0bffe17 	ldw	r2,-8(fp)
    7d34:	e0ffff17 	ldw	r3,-4(fp)
    7d38:	10c00115 	stw	r3,4(r2)
      }
      break;
    7d3c:	00002206 	br	7dc8 <ip_reass_chain_frag_into_datagram_and_validate+0x27c>
    } else if(iprh->start == iprh_tmp->start) {
    7d40:	e0bff717 	ldw	r2,-36(fp)
    7d44:	10c0010b 	ldhu	r3,4(r2)
    7d48:	e0bffd17 	ldw	r2,-12(fp)
    7d4c:	1080010b 	ldhu	r2,4(r2)
    7d50:	18ffffcc 	andi	r3,r3,65535
    7d54:	10bfffcc 	andi	r2,r2,65535
    7d58:	1880c126 	beq	r3,r2,8060 <ip_reass_chain_frag_into_datagram_and_validate+0x514>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
    7d5c:	e0bff717 	ldw	r2,-36(fp)
    7d60:	10c0010b 	ldhu	r3,4(r2)
    7d64:	e0bffd17 	ldw	r2,-12(fp)
    7d68:	1080018b 	ldhu	r2,6(r2)
    7d6c:	18ffffcc 	andi	r3,r3,65535
    7d70:	10bfffcc 	andi	r2,r2,65535
    7d74:	1880bc36 	bltu	r3,r2,8068 <ip_reass_chain_frag_into_datagram_and_validate+0x51c>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
    7d78:	e0bff817 	ldw	r2,-32(fp)
    7d7c:	10000826 	beq	r2,zero,7da0 <ip_reass_chain_frag_into_datagram_and_validate+0x254>
        if (iprh_prev->end != iprh_tmp->start) {
    7d80:	e0bff817 	ldw	r2,-32(fp)
    7d84:	10c0018b 	ldhu	r3,6(r2)
    7d88:	e0bffd17 	ldw	r2,-12(fp)
    7d8c:	1080010b 	ldhu	r2,4(r2)
    7d90:	18ffffcc 	andi	r3,r3,65535
    7d94:	10bfffcc 	andi	r2,r2,65535
    7d98:	18800126 	beq	r3,r2,7da0 <ip_reass_chain_frag_into_datagram_and_validate+0x254>
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
    7d9c:	e03ffa15 	stw	zero,-24(fp)
        }
      }
    }
    q = iprh_tmp->next_pbuf;
    7da0:	e0bffd17 	ldw	r2,-12(fp)
    7da4:	10c0000b 	ldhu	r3,0(r2)
    7da8:	1080008b 	ldhu	r2,2(r2)
    7dac:	1004943a 	slli	r2,r2,16
    7db0:	10c4b03a 	or	r2,r2,r3
    7db4:	e0bff915 	stw	r2,-28(fp)
    iprh_prev = iprh_tmp;
    7db8:	e0bffd17 	ldw	r2,-12(fp)
    7dbc:	e0bff815 	stw	r2,-32(fp)
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    7dc0:	e0bff917 	ldw	r2,-28(fp)
    7dc4:	103fa51e 	bne	r2,zero,7c5c <ip_reass_chain_frag_into_datagram_and_validate+0x110>
    q = iprh_tmp->next_pbuf;
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
    7dc8:	e0bff917 	ldw	r2,-28(fp)
    7dcc:	1000371e 	bne	r2,zero,7eac <ip_reass_chain_frag_into_datagram_and_validate+0x360>
    if (iprh_prev != NULL) {
    7dd0:	e0bff817 	ldw	r2,-32(fp)
    7dd4:	10002626 	beq	r2,zero,7e70 <ip_reass_chain_frag_into_datagram_and_validate+0x324>
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
    7dd8:	e0bff817 	ldw	r2,-32(fp)
    7ddc:	1080018b 	ldhu	r2,6(r2)
    7de0:	e0fff717 	ldw	r3,-36(fp)
    7de4:	18c0010b 	ldhu	r3,4(r3)
    7de8:	10bfffcc 	andi	r2,r2,65535
    7dec:	18ffffcc 	andi	r3,r3,65535
    7df0:	1880092e 	bgeu	r3,r2,7e18 <ip_reass_chain_frag_into_datagram_and_validate+0x2cc>
    7df4:	010000f4 	movhi	r4,3
    7df8:	213e8904 	addi	r4,r4,-1500
    7dfc:	014000f4 	movhi	r5,3
    7e00:	297eb904 	addi	r5,r5,-1308
    7e04:	018064c4 	movi	r6,403
    7e08:	01c000f4 	movhi	r7,3
    7e0c:	39fe9604 	addi	r7,r7,-1448
    7e10:	00193f00 	call	193f0 <printf>
    7e14:	003fff06 	br	7e14 <ip_reass_chain_frag_into_datagram_and_validate+0x2c8>
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
    7e18:	e0bff817 	ldw	r2,-32(fp)
    7e1c:	e0ffff17 	ldw	r3,-4(fp)
    7e20:	18ffffcc 	andi	r3,r3,65535
    7e24:	1100000b 	ldhu	r4,0(r2)
    7e28:	2008703a 	and	r4,r4,zero
    7e2c:	20c6b03a 	or	r3,r4,r3
    7e30:	10c0000d 	sth	r3,0(r2)
    7e34:	e0ffff17 	ldw	r3,-4(fp)
    7e38:	1806d43a 	srli	r3,r3,16
    7e3c:	1100008b 	ldhu	r4,2(r2)
    7e40:	2008703a 	and	r4,r4,zero
    7e44:	20c6b03a 	or	r3,r4,r3
    7e48:	10c0008d 	sth	r3,2(r2)
      if (iprh_prev->end != iprh->start) {
    7e4c:	e0bff817 	ldw	r2,-32(fp)
    7e50:	10c0018b 	ldhu	r3,6(r2)
    7e54:	e0bff717 	ldw	r2,-36(fp)
    7e58:	1080010b 	ldhu	r2,4(r2)
    7e5c:	18ffffcc 	andi	r3,r3,65535
    7e60:	10bfffcc 	andi	r2,r2,65535
    7e64:	18801126 	beq	r3,r2,7eac <ip_reass_chain_frag_into_datagram_and_validate+0x360>
        valid = 0;
    7e68:	e03ffa15 	stw	zero,-24(fp)
    7e6c:	00000f06 	br	7eac <ip_reass_chain_frag_into_datagram_and_validate+0x360>
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
    7e70:	e0bffe17 	ldw	r2,-8(fp)
    7e74:	10800117 	ldw	r2,4(r2)
    7e78:	10000926 	beq	r2,zero,7ea0 <ip_reass_chain_frag_into_datagram_and_validate+0x354>
    7e7c:	010000f4 	movhi	r4,3
    7e80:	213e8904 	addi	r4,r4,-1500
    7e84:	014000f4 	movhi	r5,3
    7e88:	297ec104 	addi	r5,r5,-1276
    7e8c:	01806704 	movi	r6,412
    7e90:	01c000f4 	movhi	r7,3
    7e94:	39fe9604 	addi	r7,r7,-1448
    7e98:	00193f00 	call	193f0 <printf>
    7e9c:	003fff06 	br	7e9c <ip_reass_chain_frag_into_datagram_and_validate+0x350>
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
    7ea0:	e0bffe17 	ldw	r2,-8(fp)
    7ea4:	e0ffff17 	ldw	r3,-4(fp)
    7ea8:	10c00115 	stw	r3,4(r2)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
    7eac:	e0bffe17 	ldw	r2,-8(fp)
    7eb0:	10800783 	ldbu	r2,30(r2)
    7eb4:	10803fcc 	andi	r2,r2,255
    7eb8:	1080004c 	andi	r2,r2,1
    7ebc:	10006626 	beq	r2,zero,8058 <ip_reass_chain_frag_into_datagram_and_validate+0x50c>
    /* and had no wholes so far */
    if (valid) {
    7ec0:	e0bffa17 	ldw	r2,-24(fp)
    7ec4:	10006226 	beq	r2,zero,8050 <ip_reass_chain_frag_into_datagram_and_validate+0x504>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
    7ec8:	e0bffe17 	ldw	r2,-8(fp)
    7ecc:	10800117 	ldw	r2,4(r2)
    7ed0:	10800117 	ldw	r2,4(r2)
    7ed4:	1080010b 	ldhu	r2,4(r2)
    7ed8:	10bfffcc 	andi	r2,r2,65535
    7edc:	10000226 	beq	r2,zero,7ee8 <ip_reass_chain_frag_into_datagram_and_validate+0x39c>
        valid = 0;
    7ee0:	e03ffa15 	stw	zero,-24(fp)
    7ee4:	00005a06 	br	8050 <ip_reass_chain_frag_into_datagram_and_validate+0x504>
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
    7ee8:	e0bff717 	ldw	r2,-36(fp)
    7eec:	e0bff815 	stw	r2,-32(fp)
        q = iprh->next_pbuf;
    7ef0:	e0bff717 	ldw	r2,-36(fp)
    7ef4:	10c0000b 	ldhu	r3,0(r2)
    7ef8:	1080008b 	ldhu	r2,2(r2)
    7efc:	1004943a 	slli	r2,r2,16
    7f00:	10c4b03a 	or	r2,r2,r3
    7f04:	e0bff915 	stw	r2,-28(fp)
        while (q != NULL) {
    7f08:	00001406 	br	7f5c <ip_reass_chain_frag_into_datagram_and_validate+0x410>
          iprh = (struct ip_reass_helper*)q->payload;
    7f0c:	e0bff917 	ldw	r2,-28(fp)
    7f10:	10800117 	ldw	r2,4(r2)
    7f14:	e0bff715 	stw	r2,-36(fp)
          if (iprh_prev->end != iprh->start) {
    7f18:	e0bff817 	ldw	r2,-32(fp)
    7f1c:	10c0018b 	ldhu	r3,6(r2)
    7f20:	e0bff717 	ldw	r2,-36(fp)
    7f24:	1080010b 	ldhu	r2,4(r2)
    7f28:	18ffffcc 	andi	r3,r3,65535
    7f2c:	10bfffcc 	andi	r2,r2,65535
    7f30:	18800226 	beq	r3,r2,7f3c <ip_reass_chain_frag_into_datagram_and_validate+0x3f0>
            valid = 0;
    7f34:	e03ffa15 	stw	zero,-24(fp)
            break;
    7f38:	00000a06 	br	7f64 <ip_reass_chain_frag_into_datagram_and_validate+0x418>
          }
          iprh_prev = iprh;
    7f3c:	e0bff717 	ldw	r2,-36(fp)
    7f40:	e0bff815 	stw	r2,-32(fp)
          q = iprh->next_pbuf;
    7f44:	e0bff717 	ldw	r2,-36(fp)
    7f48:	10c0000b 	ldhu	r3,0(r2)
    7f4c:	1080008b 	ldhu	r2,2(r2)
    7f50:	1004943a 	slli	r2,r2,16
    7f54:	10c4b03a 	or	r2,r2,r3
    7f58:	e0bff915 	stw	r2,-28(fp)
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
    7f5c:	e0bff917 	ldw	r2,-28(fp)
    7f60:	103fea1e 	bne	r2,zero,7f0c <ip_reass_chain_frag_into_datagram_and_validate+0x3c0>
          iprh_prev = iprh;
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
    7f64:	e0bffa17 	ldw	r2,-24(fp)
    7f68:	10003926 	beq	r2,zero,8050 <ip_reass_chain_frag_into_datagram_and_validate+0x504>
          LWIP_ASSERT("sanity check", ipr->p != NULL);
    7f6c:	e0bffe17 	ldw	r2,-8(fp)
    7f70:	10800117 	ldw	r2,4(r2)
    7f74:	1000091e 	bne	r2,zero,7f9c <ip_reass_chain_frag_into_datagram_and_validate+0x450>
    7f78:	010000f4 	movhi	r4,3
    7f7c:	213e8904 	addi	r4,r4,-1500
    7f80:	014000f4 	movhi	r5,3
    7f84:	297ecf04 	addi	r5,r5,-1220
    7f88:	01806f04 	movi	r6,444
    7f8c:	01c000f4 	movhi	r7,3
    7f90:	39fe9604 	addi	r7,r7,-1448
    7f94:	00193f00 	call	193f0 <printf>
    7f98:	003fff06 	br	7f98 <ip_reass_chain_frag_into_datagram_and_validate+0x44c>
          LWIP_ASSERT("sanity check",
    7f9c:	e0bffe17 	ldw	r2,-8(fp)
    7fa0:	10800117 	ldw	r2,4(r2)
    7fa4:	10c00117 	ldw	r3,4(r2)
    7fa8:	e0bff717 	ldw	r2,-36(fp)
    7fac:	1880091e 	bne	r3,r2,7fd4 <ip_reass_chain_frag_into_datagram_and_validate+0x488>
    7fb0:	010000f4 	movhi	r4,3
    7fb4:	213e8904 	addi	r4,r4,-1500
    7fb8:	014000f4 	movhi	r5,3
    7fbc:	297ecf04 	addi	r5,r5,-1220
    7fc0:	01806f84 	movi	r6,446
    7fc4:	01c000f4 	movhi	r7,3
    7fc8:	39fe9604 	addi	r7,r7,-1448
    7fcc:	00193f00 	call	193f0 <printf>
    7fd0:	003fff06 	br	7fd0 <ip_reass_chain_frag_into_datagram_and_validate+0x484>
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
    7fd4:	e0bff717 	ldw	r2,-36(fp)
    7fd8:	10c0000b 	ldhu	r3,0(r2)
    7fdc:	1080008b 	ldhu	r2,2(r2)
    7fe0:	1004943a 	slli	r2,r2,16
    7fe4:	10c4b03a 	or	r2,r2,r3
    7fe8:	10000926 	beq	r2,zero,8010 <ip_reass_chain_frag_into_datagram_and_validate+0x4c4>
    7fec:	010000f4 	movhi	r4,3
    7ff0:	213e8904 	addi	r4,r4,-1500
    7ff4:	014000f4 	movhi	r5,3
    7ff8:	297ed304 	addi	r5,r5,-1204
    7ffc:	01807004 	movi	r6,448
    8000:	01c000f4 	movhi	r7,3
    8004:	39fe9604 	addi	r7,r7,-1448
    8008:	00193f00 	call	193f0 <printf>
    800c:	003fff06 	br	800c <ip_reass_chain_frag_into_datagram_and_validate+0x4c0>
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
    8010:	e0bff717 	ldw	r2,-36(fp)
    8014:	10c0018b 	ldhu	r3,6(r2)
    8018:	e0bffe17 	ldw	r2,-8(fp)
    801c:	1080070b 	ldhu	r2,28(r2)
    8020:	18ffffcc 	andi	r3,r3,65535
    8024:	10bfffcc 	andi	r2,r2,65535
    8028:	18800926 	beq	r3,r2,8050 <ip_reass_chain_frag_into_datagram_and_validate+0x504>
    802c:	010000f4 	movhi	r4,3
    8030:	213e8904 	addi	r4,r4,-1500
    8034:	014000f4 	movhi	r5,3
    8038:	297edc04 	addi	r5,r5,-1168
    803c:	01807084 	movi	r6,450
    8040:	01c000f4 	movhi	r7,3
    8044:	39fe9604 	addi	r7,r7,-1448
    8048:	00193f00 	call	193f0 <printf>
    804c:	003fff06 	br	804c <ip_reass_chain_frag_into_datagram_and_validate+0x500>
      }
    }
    /* If valid is 0 here, there are some fragments missing in the middle
     * (since MF == 0 has already arrived). Such datagrams simply time out if
     * no more fragments are received... */
    return valid;
    8050:	e0bffa17 	ldw	r2,-24(fp)
    8054:	00000e06 	br	8090 <ip_reass_chain_frag_into_datagram_and_validate+0x544>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
    8058:	0005883a 	mov	r2,zero
    805c:	00000c06 	br	8090 <ip_reass_chain_frag_into_datagram_and_validate+0x544>
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
    8060:	0001883a 	nop
    8064:	00000106 	br	806c <ip_reass_chain_frag_into_datagram_and_validate+0x520>
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
    8068:	0001883a 	nop
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
    806c:	d428b20b 	ldhu	r16,-23864(gp)
    8070:	e13fff17 	ldw	r4,-4(fp)
    8074:	000ac000 	call	ac00 <pbuf_clen>
    8078:	10803fcc 	andi	r2,r2,255
    807c:	8085c83a 	sub	r2,r16,r2
    8080:	d0a8b20d 	sth	r2,-23864(gp)
  pbuf_free(new_p);
    8084:	e13fff17 	ldw	r4,-4(fp)
    8088:	000aa340 	call	aa34 <pbuf_free>
  return 0;
    808c:	0005883a 	mov	r2,zero
#endif /* IP_REASS_CHECK_OVERLAP */
}
    8090:	e037883a 	mov	sp,fp
    8094:	dfc00217 	ldw	ra,8(sp)
    8098:	df000117 	ldw	fp,4(sp)
    809c:	dc000017 	ldw	r16,0(sp)
    80a0:	dec00304 	addi	sp,sp,12
    80a4:	f800283a 	ret

000080a8 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
    80a8:	defff504 	addi	sp,sp,-44
    80ac:	dfc00a15 	stw	ra,40(sp)
    80b0:	df000915 	stw	fp,36(sp)
    80b4:	dc000815 	stw	r16,32(sp)
    80b8:	df000804 	addi	fp,sp,32
    80bc:	e13fff15 	stw	r4,-4(fp)
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
    80c0:	e03ffa15 	stw	zero,-24(fp)

  IPFRAG_STATS_INC(ip_frag.recv);
    80c4:	00800234 	movhi	r2,8
    80c8:	1083bd04 	addi	r2,r2,3828
    80cc:	10800c8b 	ldhu	r2,50(r2)
    80d0:	10800044 	addi	r2,r2,1
    80d4:	1007883a 	mov	r3,r2
    80d8:	00800234 	movhi	r2,8
    80dc:	1083bd04 	addi	r2,r2,3828
    80e0:	10c00c8d 	sth	r3,50(r2)
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
    80e4:	e0bfff17 	ldw	r2,-4(fp)
    80e8:	10800117 	ldw	r2,4(r2)
    80ec:	e0bffb15 	stw	r2,-20(fp)

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
    80f0:	e0bffb17 	ldw	r2,-20(fp)
    80f4:	10800003 	ldbu	r2,0(r2)
    80f8:	10803fcc 	andi	r2,r2,255
    80fc:	108003cc 	andi	r2,r2,15
    8100:	1085883a 	add	r2,r2,r2
    8104:	1085883a 	add	r2,r2,r2
    8108:	10800520 	cmpeqi	r2,r2,20
    810c:	1000091e 	bne	r2,zero,8134 <ip_reass+0x8c>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    8110:	00800234 	movhi	r2,8
    8114:	1083bd04 	addi	r2,r2,3828
    8118:	1080110b 	ldhu	r2,68(r2)
    811c:	10800044 	addi	r2,r2,1
    8120:	1007883a 	mov	r3,r2
    8124:	00800234 	movhi	r2,8
    8128:	1083bd04 	addi	r2,r2,3828
    812c:	10c0110d 	sth	r3,68(r2)
    goto nullreturn;
    8130:	0000fa06 	br	851c <ip_reass+0x474>
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    8134:	e0bffb17 	ldw	r2,-20(fp)
    8138:	1080018b 	ldhu	r2,6(r2)
    813c:	10bfffcc 	andi	r2,r2,65535
    8140:	1004d23a 	srli	r2,r2,8
    8144:	10ffffcc 	andi	r3,r2,65535
    8148:	e0bffb17 	ldw	r2,-20(fp)
    814c:	1080018b 	ldhu	r2,6(r2)
    8150:	10bfffcc 	andi	r2,r2,65535
    8154:	1004923a 	slli	r2,r2,8
    8158:	10bfffcc 	andi	r2,r2,65535
    815c:	1884b03a 	or	r2,r3,r2
    8160:	1087ffcc 	andi	r2,r2,8191
    8164:	100490fa 	slli	r2,r2,3
    8168:	e0bffc0d 	sth	r2,-16(fp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    816c:	e0bffb17 	ldw	r2,-20(fp)
    8170:	1080008b 	ldhu	r2,2(r2)
    8174:	10bfffcc 	andi	r2,r2,65535
    8178:	1004d23a 	srli	r2,r2,8
    817c:	1007883a 	mov	r3,r2
    8180:	e0bffb17 	ldw	r2,-20(fp)
    8184:	1080008b 	ldhu	r2,2(r2)
    8188:	10bfffcc 	andi	r2,r2,65535
    818c:	1004923a 	slli	r2,r2,8
    8190:	1884b03a 	or	r2,r3,r2
    8194:	1007883a 	mov	r3,r2
    8198:	e0bffb17 	ldw	r2,-20(fp)
    819c:	10800003 	ldbu	r2,0(r2)
    81a0:	10803fcc 	andi	r2,r2,255
    81a4:	108003cc 	andi	r2,r2,15
    81a8:	10bfff24 	muli	r2,r2,-4
    81ac:	1885883a 	add	r2,r3,r2
    81b0:	e0bffc8d 	sth	r2,-14(fp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
    81b4:	e13fff17 	ldw	r4,-4(fp)
    81b8:	000ac000 	call	ac00 <pbuf_clen>
    81bc:	e0bffd05 	stb	r2,-12(fp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
    81c0:	d0a8b20b 	ldhu	r2,-23864(gp)
    81c4:	10ffffcc 	andi	r3,r2,65535
    81c8:	e0bffd03 	ldbu	r2,-12(fp)
    81cc:	1885883a 	add	r2,r3,r2
    81d0:	108002d0 	cmplti	r2,r2,11
    81d4:	1000141e 	bne	r2,zero,8228 <ip_reass+0x180>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
    81d8:	e0bffd03 	ldbu	r2,-12(fp)
    81dc:	e13ffb17 	ldw	r4,-20(fp)
    81e0:	100b883a 	mov	r5,r2
    81e4:	000788c0 	call	788c <ip_reass_remove_oldest_datagram>
    81e8:	10000626 	beq	r2,zero,8204 <ip_reass+0x15c>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
    81ec:	d0a8b20b 	ldhu	r2,-23864(gp)
    81f0:	10ffffcc 	andi	r3,r2,65535
    81f4:	e0bffd03 	ldbu	r2,-12(fp)
    81f8:	1885883a 	add	r2,r3,r2

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
    81fc:	108002d0 	cmplti	r2,r2,11
    8200:	1000091e 	bne	r2,zero,8228 <ip_reass+0x180>
#endif /* IP_REASS_FREE_OLDEST */
    {
      /* No datagram could be freed and still too many pbufs enqueued */
      LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: Overflow condition: pbufct=%d, clen=%d, MAX=%d\n",
        ip_reass_pbufcount, clen, IP_REASS_MAX_PBUFS));
      IPFRAG_STATS_INC(ip_frag.memerr);
    8204:	00800234 	movhi	r2,8
    8208:	1083bd04 	addi	r2,r2,3828
    820c:	10800f0b 	ldhu	r2,60(r2)
    8210:	10800044 	addi	r2,r2,1
    8214:	1007883a 	mov	r3,r2
    8218:	00800234 	movhi	r2,8
    821c:	1083bd04 	addi	r2,r2,3828
    8220:	10c00f0d 	sth	r3,60(r2)
      /* @todo: send ICMP time exceeded here? */
      /* drop this pbuf */
      goto nullreturn;
    8224:	0000bd06 	br	851c <ip_reass+0x474>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
    8228:	d0a8b117 	ldw	r2,-23868(gp)
    822c:	e0bff915 	stw	r2,-28(fp)
    8230:	00002506 	br	82c8 <ip_reass+0x220>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
    8234:	e0bff917 	ldw	r2,-28(fp)
    8238:	10c00517 	ldw	r3,20(r2)
    823c:	e0bffb17 	ldw	r2,-20(fp)
    8240:	1100030b 	ldhu	r4,12(r2)
    8244:	1080038b 	ldhu	r2,14(r2)
    8248:	1004943a 	slli	r2,r2,16
    824c:	1104b03a 	or	r2,r2,r4
    8250:	1880181e 	bne	r3,r2,82b4 <ip_reass+0x20c>
    8254:	e0bff917 	ldw	r2,-28(fp)
    8258:	10c00617 	ldw	r3,24(r2)
    825c:	e0bffb17 	ldw	r2,-20(fp)
    8260:	1100040b 	ldhu	r4,16(r2)
    8264:	1080048b 	ldhu	r2,18(r2)
    8268:	1004943a 	slli	r2,r2,16
    826c:	1104b03a 	or	r2,r2,r4
    8270:	1880101e 	bne	r3,r2,82b4 <ip_reass+0x20c>
    8274:	e0bff917 	ldw	r2,-28(fp)
    8278:	10c0030b 	ldhu	r3,12(r2)
    827c:	e0bffb17 	ldw	r2,-20(fp)
    8280:	1080010b 	ldhu	r2,4(r2)
    8284:	18ffffcc 	andi	r3,r3,65535
    8288:	10bfffcc 	andi	r2,r2,65535
    828c:	1880091e 	bne	r3,r2,82b4 <ip_reass+0x20c>
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
        ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
    8290:	00800234 	movhi	r2,8
    8294:	1083bd04 	addi	r2,r2,3828
    8298:	1080118b 	ldhu	r2,70(r2)
    829c:	10800044 	addi	r2,r2,1
    82a0:	1007883a 	mov	r3,r2
    82a4:	00800234 	movhi	r2,8
    82a8:	1083bd04 	addi	r2,r2,3828
    82ac:	10c0118d 	sth	r3,70(r2)
      break;
    82b0:	00000706 	br	82d0 <ip_reass+0x228>
    }
    ipr_prev = ipr;
    82b4:	e0bff917 	ldw	r2,-28(fp)
    82b8:	e0bffa15 	stw	r2,-24(fp)
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
    82bc:	e0bff917 	ldw	r2,-28(fp)
    82c0:	10800017 	ldw	r2,0(r2)
    82c4:	e0bff915 	stw	r2,-28(fp)
    82c8:	e0bff917 	ldw	r2,-28(fp)
    82cc:	103fd91e 	bne	r2,zero,8234 <ip_reass+0x18c>
      break;
    }
    ipr_prev = ipr;
  }

  if (ipr == NULL) {
    82d0:	e0bff917 	ldw	r2,-28(fp)
    82d4:	1000081e 	bne	r2,zero,82f8 <ip_reass+0x250>
  /* Enqueue a new datagram into the datagram queue */
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
    82d8:	e0bffd03 	ldbu	r2,-12(fp)
    82dc:	e13ffb17 	ldw	r4,-20(fp)
    82e0:	100b883a 	mov	r5,r2
    82e4:	00079e00 	call	79e0 <ip_reass_enqueue_new_datagram>
    82e8:	e0bff915 	stw	r2,-28(fp)
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
    82ec:	e0bff917 	ldw	r2,-28(fp)
    82f0:	1000211e 	bne	r2,zero,8378 <ip_reass+0x2d0>
      goto nullreturn;
    82f4:	00008906 	br	851c <ip_reass+0x474>
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
    82f8:	e0bffb17 	ldw	r2,-20(fp)
    82fc:	1080018b 	ldhu	r2,6(r2)
    8300:	10bfffcc 	andi	r2,r2,65535
    8304:	1004d23a 	srli	r2,r2,8
    8308:	10ffffcc 	andi	r3,r2,65535
    830c:	e0bffb17 	ldw	r2,-20(fp)
    8310:	1080018b 	ldhu	r2,6(r2)
    8314:	10bfffcc 	andi	r2,r2,65535
    8318:	1004923a 	slli	r2,r2,8
    831c:	10bfffcc 	andi	r2,r2,65535
    8320:	1884b03a 	or	r2,r3,r2
    8324:	1087ffcc 	andi	r2,r2,8191
    8328:	1000131e 	bne	r2,zero,8378 <ip_reass+0x2d0>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
    832c:	e0bff917 	ldw	r2,-28(fp)
    8330:	1080038b 	ldhu	r2,14(r2)
    8334:	10bfffcc 	andi	r2,r2,65535
    8338:	1004d23a 	srli	r2,r2,8
    833c:	10ffffcc 	andi	r3,r2,65535
    8340:	e0bff917 	ldw	r2,-28(fp)
    8344:	1080038b 	ldhu	r2,14(r2)
    8348:	10bfffcc 	andi	r2,r2,65535
    834c:	1004923a 	slli	r2,r2,8
    8350:	10bfffcc 	andi	r2,r2,65535
    8354:	1884b03a 	or	r2,r3,r2
    8358:	1087ffcc 	andi	r2,r2,8191
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
    835c:	10000626 	beq	r2,zero,8378 <ip_reass+0x2d0>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
    8360:	e0bff917 	ldw	r2,-28(fp)
    8364:	10800204 	addi	r2,r2,8
    8368:	1009883a 	mov	r4,r2
    836c:	e17ffb17 	ldw	r5,-20(fp)
    8370:	01800504 	movi	r6,20
    8374:	00191f00 	call	191f0 <memcpy>
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
    8378:	e0fffd03 	ldbu	r3,-12(fp)
    837c:	d0a8b20b 	ldhu	r2,-23864(gp)
    8380:	1885883a 	add	r2,r3,r2
    8384:	d0a8b20d 	sth	r2,-23864(gp)

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
    8388:	e0bffb17 	ldw	r2,-20(fp)
    838c:	1080018b 	ldhu	r2,6(r2)
    8390:	10bfffcc 	andi	r2,r2,65535
    8394:	1080080c 	andi	r2,r2,32
    8398:	10000c1e 	bne	r2,zero,83cc <ip_reass+0x324>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
    839c:	e0bff917 	ldw	r2,-28(fp)
    83a0:	10800783 	ldbu	r2,30(r2)
    83a4:	10800054 	ori	r2,r2,1
    83a8:	1007883a 	mov	r3,r2
    83ac:	e0bff917 	ldw	r2,-28(fp)
    83b0:	10c00785 	stb	r3,30(r2)
    ipr->datagram_len = offset + len;
    83b4:	e0fffc0b 	ldhu	r3,-16(fp)
    83b8:	e0bffc8b 	ldhu	r2,-14(fp)
    83bc:	1885883a 	add	r2,r3,r2
    83c0:	1007883a 	mov	r3,r2
    83c4:	e0bff917 	ldw	r2,-28(fp)
    83c8:	10c0070d 	sth	r3,28(r2)
     ("ip_reass: last fragment seen, total len %"S16_F"\n",
      ipr->datagram_len));
  }
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    83cc:	e13ff917 	ldw	r4,-28(fp)
    83d0:	e17fff17 	ldw	r5,-4(fp)
    83d4:	0007b4c0 	call	7b4c <ip_reass_chain_frag_into_datagram_and_validate>
    83d8:	10004e26 	beq	r2,zero,8514 <ip_reass+0x46c>
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
    83dc:	e0bff917 	ldw	r2,-28(fp)
    83e0:	1080070b 	ldhu	r2,28(r2)
    83e4:	10800504 	addi	r2,r2,20
    83e8:	1007883a 	mov	r3,r2
    83ec:	e0bff917 	ldw	r2,-28(fp)
    83f0:	10c0070d 	sth	r3,28(r2)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
    83f4:	e0bff917 	ldw	r2,-28(fp)
    83f8:	10800117 	ldw	r2,4(r2)
    83fc:	10800117 	ldw	r2,4(r2)
    8400:	10c0000b 	ldhu	r3,0(r2)
    8404:	1080008b 	ldhu	r2,2(r2)
    8408:	1004943a 	slli	r2,r2,16
    840c:	10c4b03a 	or	r2,r2,r3
    8410:	e0bff815 	stw	r2,-32(fp)

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    8414:	e0bff917 	ldw	r2,-28(fp)
    8418:	10800117 	ldw	r2,4(r2)
    841c:	10800117 	ldw	r2,4(r2)
    8420:	e0bffb15 	stw	r2,-20(fp)
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
    8424:	e0bff917 	ldw	r2,-28(fp)
    8428:	10800204 	addi	r2,r2,8
    842c:	e13ffb17 	ldw	r4,-20(fp)
    8430:	100b883a 	mov	r5,r2
    8434:	01800504 	movi	r6,20
    8438:	00191f00 	call	191f0 <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
    843c:	e0bff917 	ldw	r2,-28(fp)
    8440:	1080070b 	ldhu	r2,28(r2)
    8444:	10bfffcc 	andi	r2,r2,65535
    8448:	1004d23a 	srli	r2,r2,8
    844c:	1007883a 	mov	r3,r2
    8450:	e0bff917 	ldw	r2,-28(fp)
    8454:	1080070b 	ldhu	r2,28(r2)
    8458:	10bfffcc 	andi	r2,r2,65535
    845c:	1004923a 	slli	r2,r2,8
    8460:	1884b03a 	or	r2,r3,r2
    8464:	1007883a 	mov	r3,r2
    8468:	e0bffb17 	ldw	r2,-20(fp)
    846c:	10c0008d 	sth	r3,2(r2)
    IPH_OFFSET_SET(fraghdr, 0);
    8470:	e0bffb17 	ldw	r2,-20(fp)
    8474:	1000018d 	sth	zero,6(r2)
    IPH_CHKSUM_SET(fraghdr, 0);
    8478:	e0bffb17 	ldw	r2,-20(fp)
    847c:	1000028d 	sth	zero,10(r2)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
    8480:	e13ffb17 	ldw	r4,-20(fp)
    8484:	01400504 	movi	r5,20
    8488:	00061100 	call	6110 <inet_chksum>
    848c:	e0fffb17 	ldw	r3,-20(fp)
    8490:	1880028d 	sth	r2,10(r3)

    p = ipr->p;
    8494:	e0bff917 	ldw	r2,-28(fp)
    8498:	10800117 	ldw	r2,4(r2)
    849c:	e0bfff15 	stw	r2,-4(fp)

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
    84a0:	00000f06 	br	84e0 <ip_reass+0x438>
      iprh = (struct ip_reass_helper*)r->payload;
    84a4:	e0bff817 	ldw	r2,-32(fp)
    84a8:	10800117 	ldw	r2,4(r2)
    84ac:	e0bffe15 	stw	r2,-8(fp)

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
    84b0:	e13ff817 	ldw	r4,-32(fp)
    84b4:	017ffb04 	movi	r5,-20
    84b8:	000a83c0 	call	a83c <pbuf_header>
      pbuf_cat(p, r);
    84bc:	e13fff17 	ldw	r4,-4(fp)
    84c0:	e17ff817 	ldw	r5,-32(fp)
    84c4:	000ac8c0 	call	ac8c <pbuf_cat>
      r = iprh->next_pbuf;
    84c8:	e0bffe17 	ldw	r2,-8(fp)
    84cc:	10c0000b 	ldhu	r3,0(r2)
    84d0:	1080008b 	ldhu	r2,2(r2)
    84d4:	1004943a 	slli	r2,r2,16
    84d8:	10c4b03a 	or	r2,r2,r3
    84dc:	e0bff815 	stw	r2,-32(fp)
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
    84e0:	e0bff817 	ldw	r2,-32(fp)
    84e4:	103fef1e 	bne	r2,zero,84a4 <ip_reass+0x3fc>
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
    84e8:	e13ff917 	ldw	r4,-28(fp)
    84ec:	e17ffa17 	ldw	r5,-24(fp)
    84f0:	0007abc0 	call	7abc <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
    84f4:	d428b20b 	ldhu	r16,-23864(gp)
    84f8:	e13fff17 	ldw	r4,-4(fp)
    84fc:	000ac000 	call	ac00 <pbuf_clen>
    8500:	10803fcc 	andi	r2,r2,255
    8504:	8085c83a 	sub	r2,r16,r2
    8508:	d0a8b20d 	sth	r2,-23864(gp)

    /* Return the pbuf chain */
    return p;
    850c:	e0bfff17 	ldw	r2,-4(fp)
    8510:	00000d06 	br	8548 <ip_reass+0x4a0>
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
    8514:	0005883a 	mov	r2,zero
    8518:	00000b06 	br	8548 <ip_reass+0x4a0>

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
    851c:	00800234 	movhi	r2,8
    8520:	1083bd04 	addi	r2,r2,3828
    8524:	10800d8b 	ldhu	r2,54(r2)
    8528:	10800044 	addi	r2,r2,1
    852c:	1007883a 	mov	r3,r2
    8530:	00800234 	movhi	r2,8
    8534:	1083bd04 	addi	r2,r2,3828
    8538:	10c00d8d 	sth	r3,54(r2)
  pbuf_free(p);
    853c:	e13fff17 	ldw	r4,-4(fp)
    8540:	000aa340 	call	aa34 <pbuf_free>
  return NULL;
    8544:	0005883a 	mov	r2,zero
}
    8548:	e037883a 	mov	sp,fp
    854c:	dfc00217 	ldw	ra,8(sp)
    8550:	df000117 	ldw	fp,4(sp)
    8554:	dc000017 	ldw	r16,0(sp)
    8558:	dec00304 	addi	sp,sp,12
    855c:	f800283a 	ret

00008560 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, ip_addr_t *dest)
{
    8560:	defff304 	addi	sp,sp,-52
    8564:	dfc00c15 	stw	ra,48(sp)
    8568:	df000b15 	stw	fp,44(sp)
    856c:	df000b04 	addi	fp,sp,44
    8570:	e13ffd15 	stw	r4,-12(fp)
    8574:	e17ffe15 	stw	r5,-8(fp)
    8578:	e1bfff15 	stw	r6,-4(fp)
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
    857c:	e0bffe17 	ldw	r2,-8(fp)
    8580:	1080090b 	ldhu	r2,36(r2)
    8584:	e0bff70d 	sth	r2,-36(fp)
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
    8588:	00800504 	movi	r2,20
    858c:	e0bff60d 	sth	r2,-40(fp)
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
    8590:	01000084 	movi	r4,2
    8594:	000b883a 	mov	r5,zero
    8598:	01800084 	movi	r6,2
    859c:	000a0740 	call	a074 <pbuf_alloc>
    85a0:	e0bff815 	stw	r2,-32(fp)
  if (rambuf == NULL) {
    85a4:	e0bff817 	ldw	r2,-32(fp)
    85a8:	1000021e 	bne	r2,zero,85b4 <ip_frag+0x54>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
    85ac:	00bfffc4 	movi	r2,-1
    85b0:	0000a706 	br	8850 <ip_frag+0x2f0>
  }
  rambuf->tot_len = rambuf->len = mtu;
    85b4:	e0bff817 	ldw	r2,-32(fp)
    85b8:	e0fff70b 	ldhu	r3,-36(fp)
    85bc:	10c0028d 	sth	r3,10(r2)
    85c0:	e0bff817 	ldw	r2,-32(fp)
    85c4:	10c0028b 	ldhu	r3,10(r2)
    85c8:	e0bff817 	ldw	r2,-32(fp)
    85cc:	10c0020d 	sth	r3,8(r2)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
    85d0:	00800134 	movhi	r2,4
    85d4:	10a24004 	addi	r2,r2,-30464
    85d8:	10c000c4 	addi	r3,r2,3
    85dc:	00bfff04 	movi	r2,-4
    85e0:	1884703a 	and	r2,r3,r2
    85e4:	1007883a 	mov	r3,r2
    85e8:	e0bff817 	ldw	r2,-32(fp)
    85ec:	10c00115 	stw	r3,4(r2)

  /* Copy the IP header in it */
  iphdr = (struct ip_hdr *)rambuf->payload;
    85f0:	e0bff817 	ldw	r2,-32(fp)
    85f4:	10800117 	ldw	r2,4(r2)
    85f8:	e0bff915 	stw	r2,-28(fp)
  SMEMCPY(iphdr, p->payload, IP_HLEN);
    85fc:	e0bffd17 	ldw	r2,-12(fp)
    8600:	10800117 	ldw	r2,4(r2)
    8604:	e13ff917 	ldw	r4,-28(fp)
    8608:	100b883a 	mov	r5,r2
    860c:	01800504 	movi	r6,20
    8610:	00191f00 	call	191f0 <memcpy>
  original_iphdr = (struct ip_hdr *)p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
    8614:	e0bff917 	ldw	r2,-28(fp)
    8618:	1080018b 	ldhu	r2,6(r2)
    861c:	10bfffcc 	andi	r2,r2,65535
    8620:	1004d23a 	srli	r2,r2,8
    8624:	1007883a 	mov	r3,r2
    8628:	e0bff917 	ldw	r2,-28(fp)
    862c:	1080018b 	ldhu	r2,6(r2)
    8630:	10bfffcc 	andi	r2,r2,65535
    8634:	1004923a 	slli	r2,r2,8
    8638:	1884b03a 	or	r2,r3,r2
    863c:	e0bff68d 	sth	r2,-38(fp)
  ofo = tmp & IP_OFFMASK;
    8640:	e0bff68b 	ldhu	r2,-38(fp)
    8644:	1087ffcc 	andi	r2,r2,8191
    8648:	e0bff58d 	sth	r2,-42(fp)
  omf = tmp & IP_MF;
    864c:	e0bff68b 	ldhu	r2,-38(fp)
    8650:	1088000c 	andi	r2,r2,8192
    8654:	e0bffa0d 	sth	r2,-24(fp)

  left = p->tot_len - IP_HLEN;
    8658:	e0bffd17 	ldw	r2,-12(fp)
    865c:	1080020b 	ldhu	r2,8(r2)
    8660:	10bffb04 	addi	r2,r2,-20
    8664:	e0bff50d 	sth	r2,-44(fp)

  nfb = (mtu - IP_HLEN) / 8;
    8668:	e0bff70b 	ldhu	r2,-36(fp)
    866c:	10bffb04 	addi	r2,r2,-20
    8670:	1000010e 	bge	r2,zero,8678 <ip_frag+0x118>
    8674:	108001c4 	addi	r2,r2,7
    8678:	1005d0fa 	srai	r2,r2,3
    867c:	e0bffa8d 	sth	r2,-22(fp)

  while (left) {
    8680:	00006e06 	br	883c <ip_frag+0x2dc>
    last = (left <= mtu - IP_HLEN);
    8684:	e0bff50b 	ldhu	r2,-44(fp)
    8688:	e0fff70b 	ldhu	r3,-36(fp)
    868c:	18fffb04 	addi	r3,r3,-20
    8690:	1884403a 	cmpge	r2,r3,r2
    8694:	10803fcc 	andi	r2,r2,255
    8698:	e0bffb0d 	sth	r2,-20(fp)

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
    869c:	e0bff58b 	ldhu	r2,-42(fp)
    86a0:	1087ffcc 	andi	r2,r2,8191
    86a4:	1007883a 	mov	r3,r2
    86a8:	e0bffa0b 	ldhu	r2,-24(fp)
    86ac:	1884b03a 	or	r2,r3,r2
    86b0:	e0bff68d 	sth	r2,-38(fp)
    if (!last) {
    86b4:	e0bffb0b 	ldhu	r2,-20(fp)
    86b8:	1000031e 	bne	r2,zero,86c8 <ip_frag+0x168>
      tmp = tmp | IP_MF;
    86bc:	e0bff68b 	ldhu	r2,-38(fp)
    86c0:	10880014 	ori	r2,r2,8192
    86c4:	e0bff68d 	sth	r2,-38(fp)
    }

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
    86c8:	e0bffb0b 	ldhu	r2,-20(fp)
    86cc:	1000031e 	bne	r2,zero,86dc <ip_frag+0x17c>
    86d0:	e0bffa8b 	ldhu	r2,-22(fp)
    86d4:	100490fa 	slli	r2,r2,3
    86d8:	00000106 	br	86e0 <ip_frag+0x180>
    86dc:	e0bff50b 	ldhu	r2,-44(fp)
    86e0:	e0bffb8d 	sth	r2,-18(fp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
    86e4:	e0bff917 	ldw	r2,-28(fp)
    86e8:	11400504 	addi	r5,r2,20
    86ec:	e0fffb8b 	ldhu	r3,-18(fp)
    86f0:	e0bff60b 	ldhu	r2,-40(fp)
    86f4:	e13ffd17 	ldw	r4,-12(fp)
    86f8:	180d883a 	mov	r6,r3
    86fc:	100f883a 	mov	r7,r2
    8700:	000b2040 	call	b204 <pbuf_copy_partial>
    8704:	e0fff60b 	ldhu	r3,-40(fp)
    8708:	10c5883a 	add	r2,r2,r3
    870c:	e0bff60d 	sth	r2,-40(fp)
    poff = newpbuflen;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    8710:	e0bff68b 	ldhu	r2,-38(fp)
    8714:	1004d23a 	srli	r2,r2,8
    8718:	1007883a 	mov	r3,r2
    871c:	e0bff68b 	ldhu	r2,-38(fp)
    8720:	1004923a 	slli	r2,r2,8
    8724:	1884b03a 	or	r2,r3,r2
    8728:	1007883a 	mov	r3,r2
    872c:	e0bff917 	ldw	r2,-28(fp)
    8730:	10c0018d 	sth	r3,6(r2)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
    8734:	e0bffb8b 	ldhu	r2,-18(fp)
    8738:	10800504 	addi	r2,r2,20
    873c:	10bfc00c 	andi	r2,r2,65280
    8740:	1005d23a 	srai	r2,r2,8
    8744:	1007883a 	mov	r3,r2
    8748:	e0bffb8b 	ldhu	r2,-18(fp)
    874c:	10800504 	addi	r2,r2,20
    8750:	1004923a 	slli	r2,r2,8
    8754:	1884b03a 	or	r2,r3,r2
    8758:	1007883a 	mov	r3,r2
    875c:	e0bff917 	ldw	r2,-28(fp)
    8760:	10c0008d 	sth	r3,2(r2)
    IPH_CHKSUM_SET(iphdr, 0);
    8764:	e0bff917 	ldw	r2,-28(fp)
    8768:	1000028d 	sth	zero,10(r2)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    876c:	e13ff917 	ldw	r4,-28(fp)
    8770:	01400504 	movi	r5,20
    8774:	00061100 	call	6110 <inet_chksum>
    8778:	e0fff917 	ldw	r3,-28(fp)
    877c:	1880028d 	sth	r2,10(r3)

#if IP_FRAG_USES_STATIC_BUF
    if (last) {
    8780:	e0bffb0b 	ldhu	r2,-20(fp)
    8784:	10000626 	beq	r2,zero,87a0 <ip_frag+0x240>
      pbuf_realloc(rambuf, left + IP_HLEN);
    8788:	e0bff50b 	ldhu	r2,-44(fp)
    878c:	10800504 	addi	r2,r2,20
    8790:	10bfffcc 	andi	r2,r2,65535
    8794:	e13ff817 	ldw	r4,-32(fp)
    8798:	100b883a 	mov	r5,r2
    879c:	000a5b80 	call	a5b8 <pbuf_realloc>
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
    87a0:	01000084 	movi	r4,2
    87a4:	000b883a 	mov	r5,zero
    87a8:	000d883a 	mov	r6,zero
    87ac:	000a0740 	call	a074 <pbuf_alloc>
    87b0:	e0bffc15 	stw	r2,-16(fp)
    if (header != NULL) {
    87b4:	e0bffc17 	ldw	r2,-16(fp)
    87b8:	10001c26 	beq	r2,zero,882c <ip_frag+0x2cc>
      pbuf_chain(header, rambuf);
    87bc:	e13ffc17 	ldw	r4,-16(fp)
    87c0:	e17ff817 	ldw	r5,-32(fp)
    87c4:	000adcc0 	call	adcc <pbuf_chain>
      netif->output(netif, header, dest);
    87c8:	e0bffe17 	ldw	r2,-8(fp)
    87cc:	10800517 	ldw	r2,20(r2)
    87d0:	e13ffe17 	ldw	r4,-8(fp)
    87d4:	e17ffc17 	ldw	r5,-16(fp)
    87d8:	e1bfff17 	ldw	r6,-4(fp)
    87dc:	103ee83a 	callr	r2
      IPFRAG_STATS_INC(ip_frag.xmit);
    87e0:	00800234 	movhi	r2,8
    87e4:	1083bd04 	addi	r2,r2,3828
    87e8:	10800c0b 	ldhu	r2,48(r2)
    87ec:	10800044 	addi	r2,r2,1
    87f0:	1007883a 	mov	r3,r2
    87f4:	00800234 	movhi	r2,8
    87f8:	1083bd04 	addi	r2,r2,3828
    87fc:	10c00c0d 	sth	r3,48(r2)
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    8800:	e13ffc17 	ldw	r4,-16(fp)
    8804:	000aa340 	call	aa34 <pbuf_free>
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    8808:	e0fff50b 	ldhu	r3,-44(fp)
    880c:	e0bffb8b 	ldhu	r2,-18(fp)
    8810:	1885c83a 	sub	r2,r3,r2
    8814:	e0bff50d 	sth	r2,-44(fp)
    ofo += nfb;
    8818:	e0fff58b 	ldhu	r3,-42(fp)
    881c:	e0bffa8b 	ldhu	r2,-22(fp)
    8820:	1885883a 	add	r2,r3,r2
    8824:	e0bff58d 	sth	r2,-42(fp)
    8828:	00000406 	br	883c <ip_frag+0x2dc>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
    882c:	e13ff817 	ldw	r4,-32(fp)
    8830:	000aa340 	call	aa34 <pbuf_free>
      return ERR_MEM;
    8834:	00bfffc4 	movi	r2,-1
    8838:	00000506 	br	8850 <ip_frag+0x2f0>

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
    883c:	e0bff50b 	ldhu	r2,-44(fp)
    8840:	103f901e 	bne	r2,zero,8684 <ip_frag+0x124>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
    8844:	e13ff817 	ldw	r4,-32(fp)
    8848:	000aa340 	call	aa34 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
    884c:	0005883a 	mov	r2,zero
}
    8850:	e037883a 	mov	sp,fp
    8854:	dfc00117 	ldw	ra,4(sp)
    8858:	df000017 	ldw	fp,0(sp)
    885c:	dec00204 	addi	sp,sp,8
    8860:	f800283a 	ret

00008864 <plug_holes>:
 * This assumes access to the heap is protected by the calling function
 * already.
 */
static void
plug_holes(struct mem *mem)
{
    8864:	defffb04 	addi	sp,sp,-20
    8868:	dfc00415 	stw	ra,16(sp)
    886c:	df000315 	stw	fp,12(sp)
    8870:	df000304 	addi	fp,sp,12
    8874:	e13fff15 	stw	r4,-4(fp)
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
    8878:	d0a8b317 	ldw	r2,-23860(gp)
    887c:	e0ffff17 	ldw	r3,-4(fp)
    8880:	1880092e 	bgeu	r3,r2,88a8 <plug_holes+0x44>
    8884:	010000f4 	movhi	r4,3
    8888:	213ee804 	addi	r4,r4,-1120
    888c:	014000f4 	movhi	r5,3
    8890:	297ef204 	addi	r5,r5,-1080
    8894:	01803c44 	movi	r6,241
    8898:	01c000f4 	movhi	r7,3
    889c:	39fef804 	addi	r7,r7,-1056
    88a0:	00193f00 	call	193f0 <printf>
    88a4:	003fff06 	br	88a4 <plug_holes+0x40>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
    88a8:	d0a8b417 	ldw	r2,-23856(gp)
    88ac:	e0ffff17 	ldw	r3,-4(fp)
    88b0:	18800936 	bltu	r3,r2,88d8 <plug_holes+0x74>
    88b4:	010000f4 	movhi	r4,3
    88b8:	213ee804 	addi	r4,r4,-1120
    88bc:	014000f4 	movhi	r5,3
    88c0:	297efd04 	addi	r5,r5,-1036
    88c4:	01803c84 	movi	r6,242
    88c8:	01c000f4 	movhi	r7,3
    88cc:	39fef804 	addi	r7,r7,-1056
    88d0:	00193f00 	call	193f0 <printf>
    88d4:	003fff06 	br	88d4 <plug_holes+0x70>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
    88d8:	e0bfff17 	ldw	r2,-4(fp)
    88dc:	10800103 	ldbu	r2,4(r2)
    88e0:	10803fcc 	andi	r2,r2,255
    88e4:	10000926 	beq	r2,zero,890c <plug_holes+0xa8>
    88e8:	010000f4 	movhi	r4,3
    88ec:	213ee804 	addi	r4,r4,-1120
    88f0:	014000f4 	movhi	r5,3
    88f4:	297f0404 	addi	r5,r5,-1008
    88f8:	01803cc4 	movi	r6,243
    88fc:	01c000f4 	movhi	r7,3
    8900:	39fef804 	addi	r7,r7,-1056
    8904:	00193f00 	call	193f0 <printf>
    8908:	003fff06 	br	8908 <plug_holes+0xa4>

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
    890c:	e0bfff17 	ldw	r2,-4(fp)
    8910:	1080000b 	ldhu	r2,0(r2)
    8914:	10bfffcc 	andi	r2,r2,65535
    8918:	10819070 	cmpltui	r2,r2,1601
    891c:	1000091e 	bne	r2,zero,8944 <plug_holes+0xe0>
    8920:	010000f4 	movhi	r4,3
    8924:	213ee804 	addi	r4,r4,-1120
    8928:	014000f4 	movhi	r5,3
    892c:	297f0b04 	addi	r5,r5,-980
    8930:	01803d84 	movi	r6,246
    8934:	01c000f4 	movhi	r7,3
    8938:	39fef804 	addi	r7,r7,-1056
    893c:	00193f00 	call	193f0 <printf>
    8940:	003fff06 	br	8940 <plug_holes+0xdc>

  nmem = (struct mem *)(void *)&ram[mem->next];
    8944:	d0e8b317 	ldw	r3,-23860(gp)
    8948:	e0bfff17 	ldw	r2,-4(fp)
    894c:	1080000b 	ldhu	r2,0(r2)
    8950:	10bfffcc 	andi	r2,r2,65535
    8954:	1885883a 	add	r2,r3,r2
    8958:	e0bffd15 	stw	r2,-12(fp)
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
    895c:	e0ffff17 	ldw	r3,-4(fp)
    8960:	e0bffd17 	ldw	r2,-12(fp)
    8964:	18801926 	beq	r3,r2,89cc <plug_holes+0x168>
    8968:	e0bffd17 	ldw	r2,-12(fp)
    896c:	10800103 	ldbu	r2,4(r2)
    8970:	10803fcc 	andi	r2,r2,255
    8974:	1000151e 	bne	r2,zero,89cc <plug_holes+0x168>
    8978:	d0a8b417 	ldw	r2,-23856(gp)
    897c:	e0fffd17 	ldw	r3,-12(fp)
    8980:	18801226 	beq	r3,r2,89cc <plug_holes+0x168>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
    8984:	d0e8b517 	ldw	r3,-23852(gp)
    8988:	e0bffd17 	ldw	r2,-12(fp)
    898c:	1880021e 	bne	r3,r2,8998 <plug_holes+0x134>
      lfree = mem;
    8990:	e0bfff17 	ldw	r2,-4(fp)
    8994:	d0a8b515 	stw	r2,-23852(gp)
    }
    mem->next = nmem->next;
    8998:	e0bffd17 	ldw	r2,-12(fp)
    899c:	10c0000b 	ldhu	r3,0(r2)
    89a0:	e0bfff17 	ldw	r2,-4(fp)
    89a4:	10c0000d 	sth	r3,0(r2)
    ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
    89a8:	d0e8b317 	ldw	r3,-23860(gp)
    89ac:	e0bffd17 	ldw	r2,-12(fp)
    89b0:	1080000b 	ldhu	r2,0(r2)
    89b4:	10bfffcc 	andi	r2,r2,65535
    89b8:	1885883a 	add	r2,r3,r2
    89bc:	e13fff17 	ldw	r4,-4(fp)
    89c0:	d0e8b317 	ldw	r3,-23860(gp)
    89c4:	20c7c83a 	sub	r3,r4,r3
    89c8:	10c0008d 	sth	r3,2(r2)
  }

  /* plug hole backward */
  pmem = (struct mem *)(void *)&ram[mem->prev];
    89cc:	d0e8b317 	ldw	r3,-23860(gp)
    89d0:	e0bfff17 	ldw	r2,-4(fp)
    89d4:	1080008b 	ldhu	r2,2(r2)
    89d8:	10bfffcc 	andi	r2,r2,65535
    89dc:	1885883a 	add	r2,r3,r2
    89e0:	e0bffe15 	stw	r2,-8(fp)
  if (pmem != mem && pmem->used == 0) {
    89e4:	e0fffe17 	ldw	r3,-8(fp)
    89e8:	e0bfff17 	ldw	r2,-4(fp)
    89ec:	18801626 	beq	r3,r2,8a48 <plug_holes+0x1e4>
    89f0:	e0bffe17 	ldw	r2,-8(fp)
    89f4:	10800103 	ldbu	r2,4(r2)
    89f8:	10803fcc 	andi	r2,r2,255
    89fc:	1000121e 	bne	r2,zero,8a48 <plug_holes+0x1e4>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
    8a00:	d0e8b517 	ldw	r3,-23852(gp)
    8a04:	e0bfff17 	ldw	r2,-4(fp)
    8a08:	1880021e 	bne	r3,r2,8a14 <plug_holes+0x1b0>
      lfree = pmem;
    8a0c:	e0bffe17 	ldw	r2,-8(fp)
    8a10:	d0a8b515 	stw	r2,-23852(gp)
    }
    pmem->next = mem->next;
    8a14:	e0bfff17 	ldw	r2,-4(fp)
    8a18:	10c0000b 	ldhu	r3,0(r2)
    8a1c:	e0bffe17 	ldw	r2,-8(fp)
    8a20:	10c0000d 	sth	r3,0(r2)
    ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
    8a24:	d0e8b317 	ldw	r3,-23860(gp)
    8a28:	e0bfff17 	ldw	r2,-4(fp)
    8a2c:	1080000b 	ldhu	r2,0(r2)
    8a30:	10bfffcc 	andi	r2,r2,65535
    8a34:	1885883a 	add	r2,r3,r2
    8a38:	e13ffe17 	ldw	r4,-8(fp)
    8a3c:	d0e8b317 	ldw	r3,-23860(gp)
    8a40:	20c7c83a 	sub	r3,r4,r3
    8a44:	10c0008d 	sth	r3,2(r2)
  }
}
    8a48:	e037883a 	mov	sp,fp
    8a4c:	dfc00117 	ldw	ra,4(sp)
    8a50:	df000017 	ldw	fp,0(sp)
    8a54:	dec00204 	addi	sp,sp,8
    8a58:	f800283a 	ret

00008a5c <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
    8a5c:	defffe04 	addi	sp,sp,-8
    8a60:	df000115 	stw	fp,4(sp)
    8a64:	df000104 	addi	fp,sp,4

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
    8a68:	00800234 	movhi	r2,8
    8a6c:	10822804 	addi	r2,r2,2208
    8a70:	10c000c4 	addi	r3,r2,3
    8a74:	00bfff04 	movi	r2,-4
    8a78:	1884703a 	and	r2,r3,r2
    8a7c:	d0a8b315 	stw	r2,-23860(gp)
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
    8a80:	d0a8b317 	ldw	r2,-23860(gp)
    8a84:	e0bfff15 	stw	r2,-4(fp)
  mem->next = MEM_SIZE_ALIGNED;
    8a88:	e0bfff17 	ldw	r2,-4(fp)
    8a8c:	00c19004 	movi	r3,1600
    8a90:	10c0000d 	sth	r3,0(r2)
  mem->prev = 0;
    8a94:	e0bfff17 	ldw	r2,-4(fp)
    8a98:	1000008d 	sth	zero,2(r2)
  mem->used = 0;
    8a9c:	e0bfff17 	ldw	r2,-4(fp)
    8aa0:	10000105 	stb	zero,4(r2)
  /* initialize the end of the heap */
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
    8aa4:	d0a8b317 	ldw	r2,-23860(gp)
    8aa8:	10819004 	addi	r2,r2,1600
    8aac:	d0a8b415 	stw	r2,-23856(gp)
  ram_end->used = 1;
    8ab0:	d0a8b417 	ldw	r2,-23856(gp)
    8ab4:	00c00044 	movi	r3,1
    8ab8:	10c00105 	stb	r3,4(r2)
  ram_end->next = MEM_SIZE_ALIGNED;
    8abc:	d0a8b417 	ldw	r2,-23856(gp)
    8ac0:	00c19004 	movi	r3,1600
    8ac4:	10c0000d 	sth	r3,0(r2)
  ram_end->prev = MEM_SIZE_ALIGNED;
    8ac8:	d0a8b417 	ldw	r2,-23856(gp)
    8acc:	00c19004 	movi	r3,1600
    8ad0:	10c0008d 	sth	r3,2(r2)

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;
    8ad4:	d0a8b317 	ldw	r2,-23860(gp)
    8ad8:	d0a8b515 	stw	r2,-23852(gp)

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
    8adc:	00800234 	movhi	r2,8
    8ae0:	1083bd04 	addi	r2,r2,3828
    8ae4:	00c19004 	movi	r3,1600
    8ae8:	10c02a0d 	sth	r3,168(r2)

  if(sys_mutex_new(&mem_mutex) != ERR_OK) {
    LWIP_ASSERT("failed to create mem_mutex", 0);
  }
}
    8aec:	e037883a 	mov	sp,fp
    8af0:	df000017 	ldw	fp,0(sp)
    8af4:	dec00104 	addi	sp,sp,4
    8af8:	f800283a 	ret

00008afc <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
    8afc:	defffc04 	addi	sp,sp,-16
    8b00:	dfc00315 	stw	ra,12(sp)
    8b04:	df000215 	stw	fp,8(sp)
    8b08:	df000204 	addi	fp,sp,8
    8b0c:	e13fff15 	stw	r4,-4(fp)
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
    8b10:	e0bfff17 	ldw	r2,-4(fp)
    8b14:	10005326 	beq	r2,zero,8c64 <mem_free+0x168>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
    8b18:	e0bfff17 	ldw	r2,-4(fp)
    8b1c:	108000cc 	andi	r2,r2,3
    8b20:	10000926 	beq	r2,zero,8b48 <mem_free+0x4c>
    8b24:	010000f4 	movhi	r4,3
    8b28:	213ee804 	addi	r4,r4,-1120
    8b2c:	014000f4 	movhi	r5,3
    8b30:	297f1604 	addi	r5,r5,-936
    8b34:	01805004 	movi	r6,320
    8b38:	01c000f4 	movhi	r7,3
    8b3c:	39fef804 	addi	r7,r7,-1056
    8b40:	00193f00 	call	193f0 <printf>
    8b44:	003fff06 	br	8b44 <mem_free+0x48>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
    8b48:	d0a8b317 	ldw	r2,-23860(gp)
    8b4c:	e0ffff17 	ldw	r3,-4(fp)
    8b50:	18800336 	bltu	r3,r2,8b60 <mem_free+0x64>
    8b54:	d0a8b417 	ldw	r2,-23856(gp)
    8b58:	e0ffff17 	ldw	r3,-4(fp)
    8b5c:	18800936 	bltu	r3,r2,8b84 <mem_free+0x88>
    8b60:	010000f4 	movhi	r4,3
    8b64:	213ee804 	addi	r4,r4,-1120
    8b68:	014000f4 	movhi	r5,3
    8b6c:	297f1f04 	addi	r5,r5,-900
    8b70:	018050c4 	movi	r6,323
    8b74:	01c000f4 	movhi	r7,3
    8b78:	39fef804 	addi	r7,r7,-1056
    8b7c:	00193f00 	call	193f0 <printf>
    8b80:	003fff06 	br	8b80 <mem_free+0x84>
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
    8b84:	d0a8b317 	ldw	r2,-23860(gp)
    8b88:	e0ffff17 	ldw	r3,-4(fp)
    8b8c:	18800336 	bltu	r3,r2,8b9c <mem_free+0xa0>
    8b90:	d0a8b417 	ldw	r2,-23856(gp)
    8b94:	e0ffff17 	ldw	r3,-4(fp)
    8b98:	18800936 	bltu	r3,r2,8bc0 <mem_free+0xc4>
    SYS_ARCH_DECL_PROTECT(lev);
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    8b9c:	00800234 	movhi	r2,8
    8ba0:	1083bd04 	addi	r2,r2,3828
    8ba4:	10802c0b 	ldhu	r2,176(r2)
    8ba8:	10800044 	addi	r2,r2,1
    8bac:	1007883a 	mov	r3,r2
    8bb0:	00800234 	movhi	r2,8
    8bb4:	1083bd04 	addi	r2,r2,3828
    8bb8:	10c02c0d 	sth	r3,176(r2)
    SYS_ARCH_UNPROTECT(lev);
    return;
    8bbc:	00002a06 	br	8c68 <mem_free+0x16c>
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
    8bc0:	e0bfff17 	ldw	r2,-4(fp)
    8bc4:	10bffe04 	addi	r2,r2,-8
    8bc8:	e0bffe15 	stw	r2,-8(fp)
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
    8bcc:	e0bffe17 	ldw	r2,-8(fp)
    8bd0:	10800103 	ldbu	r2,4(r2)
    8bd4:	10803fcc 	andi	r2,r2,255
    8bd8:	1000091e 	bne	r2,zero,8c00 <mem_free+0x104>
    8bdc:	010000f4 	movhi	r4,3
    8be0:	213ee804 	addi	r4,r4,-1120
    8be4:	014000f4 	movhi	r5,3
    8be8:	297f2504 	addi	r5,r5,-876
    8bec:	018054c4 	movi	r6,339
    8bf0:	01c000f4 	movhi	r7,3
    8bf4:	39fef804 	addi	r7,r7,-1056
    8bf8:	00193f00 	call	193f0 <printf>
    8bfc:	003fff06 	br	8bfc <mem_free+0x100>
  /* ... and is now unused. */
  mem->used = 0;
    8c00:	e0bffe17 	ldw	r2,-8(fp)
    8c04:	10000105 	stb	zero,4(r2)

  if (mem < lfree) {
    8c08:	d0a8b517 	ldw	r2,-23852(gp)
    8c0c:	e0fffe17 	ldw	r3,-8(fp)
    8c10:	1880022e 	bgeu	r3,r2,8c1c <mem_free+0x120>
    /* the newly freed struct is now the lowest */
    lfree = mem;
    8c14:	e0bffe17 	ldw	r2,-8(fp)
    8c18:	d0a8b515 	stw	r2,-23852(gp)
  }

  MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));
    8c1c:	00800234 	movhi	r2,8
    8c20:	1083bd04 	addi	r2,r2,3828
    8c24:	10c02a8b 	ldhu	r3,170(r2)
    8c28:	e13ffe17 	ldw	r4,-8(fp)
    8c2c:	d0a8b317 	ldw	r2,-23860(gp)
    8c30:	2085c83a 	sub	r2,r4,r2
    8c34:	1009883a 	mov	r4,r2
    8c38:	e0bffe17 	ldw	r2,-8(fp)
    8c3c:	1080000b 	ldhu	r2,0(r2)
    8c40:	2085c83a 	sub	r2,r4,r2
    8c44:	1885883a 	add	r2,r3,r2
    8c48:	1007883a 	mov	r3,r2
    8c4c:	00800234 	movhi	r2,8
    8c50:	1083bd04 	addi	r2,r2,3828
    8c54:	10c02a8d 	sth	r3,170(r2)

  /* finally, see if prev or next are free also */
  plug_holes(mem);
    8c58:	e13ffe17 	ldw	r4,-8(fp)
    8c5c:	00088640 	call	8864 <plug_holes>
    8c60:	00000106 	br	8c68 <mem_free+0x16c>
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
    8c64:	0001883a 	nop
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
    8c68:	e037883a 	mov	sp,fp
    8c6c:	dfc00117 	ldw	ra,4(sp)
    8c70:	df000017 	ldw	fp,0(sp)
    8c74:	dec00204 	addi	sp,sp,8
    8c78:	f800283a 	ret

00008c7c <mem_trim>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_trim(void *rmem, mem_size_t newsize)
{
    8c7c:	defff804 	addi	sp,sp,-32
    8c80:	dfc00715 	stw	ra,28(sp)
    8c84:	df000615 	stw	fp,24(sp)
    8c88:	df000604 	addi	fp,sp,24
    8c8c:	e13ffe15 	stw	r4,-8(fp)
    8c90:	2805883a 	mov	r2,r5
    8c94:	e0bfff0d 	sth	r2,-4(fp)
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
    8c98:	e0bfff0b 	ldhu	r2,-4(fp)
    8c9c:	108000c4 	addi	r2,r2,3
    8ca0:	1007883a 	mov	r3,r2
    8ca4:	00bfff04 	movi	r2,-4
    8ca8:	1884703a 	and	r2,r3,r2
    8cac:	e0bfff0d 	sth	r2,-4(fp)

  if(newsize < MIN_SIZE_ALIGNED) {
    8cb0:	e0bfff0b 	ldhu	r2,-4(fp)
    8cb4:	10800328 	cmpgeui	r2,r2,12
    8cb8:	1000021e 	bne	r2,zero,8cc4 <mem_trim+0x48>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
    8cbc:	00800304 	movi	r2,12
    8cc0:	e0bfff0d 	sth	r2,-4(fp)
  }

  if (newsize > MEM_SIZE_ALIGNED) {
    8cc4:	e0bfff0b 	ldhu	r2,-4(fp)
    8cc8:	10819070 	cmpltui	r2,r2,1601
    8ccc:	1000021e 	bne	r2,zero,8cd8 <mem_trim+0x5c>
    return NULL;
    8cd0:	0005883a 	mov	r2,zero
    8cd4:	0000b806 	br	8fb8 <mem_trim+0x33c>
  }

  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
    8cd8:	d0a8b317 	ldw	r2,-23860(gp)
    8cdc:	e0fffe17 	ldw	r3,-8(fp)
    8ce0:	18800336 	bltu	r3,r2,8cf0 <mem_trim+0x74>
    8ce4:	d0a8b417 	ldw	r2,-23856(gp)
    8ce8:	e0fffe17 	ldw	r3,-8(fp)
    8cec:	18800936 	bltu	r3,r2,8d14 <mem_trim+0x98>
    8cf0:	010000f4 	movhi	r4,3
    8cf4:	213ee804 	addi	r4,r4,-1120
    8cf8:	014000f4 	movhi	r5,3
    8cfc:	297f2a04 	addi	r5,r5,-856
    8d00:	018061c4 	movi	r6,391
    8d04:	01c000f4 	movhi	r7,3
    8d08:	39fef804 	addi	r7,r7,-1056
    8d0c:	00193f00 	call	193f0 <printf>
    8d10:	003fff06 	br	8d10 <mem_trim+0x94>
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
    8d14:	d0a8b317 	ldw	r2,-23860(gp)
    8d18:	e0fffe17 	ldw	r3,-8(fp)
    8d1c:	18800336 	bltu	r3,r2,8d2c <mem_trim+0xb0>
    8d20:	d0a8b417 	ldw	r2,-23856(gp)
    8d24:	e0fffe17 	ldw	r3,-8(fp)
    8d28:	18800a36 	bltu	r3,r2,8d54 <mem_trim+0xd8>
    SYS_ARCH_DECL_PROTECT(lev);
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_trim: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    8d2c:	00800234 	movhi	r2,8
    8d30:	1083bd04 	addi	r2,r2,3828
    8d34:	10802c0b 	ldhu	r2,176(r2)
    8d38:	10800044 	addi	r2,r2,1
    8d3c:	1007883a 	mov	r3,r2
    8d40:	00800234 	movhi	r2,8
    8d44:	1083bd04 	addi	r2,r2,3828
    8d48:	10c02c0d 	sth	r3,176(r2)
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
    8d4c:	e0bffe17 	ldw	r2,-8(fp)
    8d50:	00009906 	br	8fb8 <mem_trim+0x33c>
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
    8d54:	e0bffe17 	ldw	r2,-8(fp)
    8d58:	10bffe04 	addi	r2,r2,-8
    8d5c:	e0bffa15 	stw	r2,-24(fp)
  /* ... and its offset pointer */
  ptr = (mem_size_t)((u8_t *)mem - ram);
    8d60:	e0fffa17 	ldw	r3,-24(fp)
    8d64:	d0a8b317 	ldw	r2,-23860(gp)
    8d68:	1885c83a 	sub	r2,r3,r2
    8d6c:	e0bffb0d 	sth	r2,-20(fp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
    8d70:	e0bffa17 	ldw	r2,-24(fp)
    8d74:	10c0000b 	ldhu	r3,0(r2)
    8d78:	e0bffb0b 	ldhu	r2,-20(fp)
    8d7c:	1885c83a 	sub	r2,r3,r2
    8d80:	10bffe04 	addi	r2,r2,-8
    8d84:	e0bffb8d 	sth	r2,-18(fp)
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
    8d88:	e0bfff0b 	ldhu	r2,-4(fp)
    8d8c:	e0fffb8b 	ldhu	r3,-18(fp)
    8d90:	1880092e 	bgeu	r3,r2,8db8 <mem_trim+0x13c>
    8d94:	010000f4 	movhi	r4,3
    8d98:	213ee804 	addi	r4,r4,-1120
    8d9c:	014000f4 	movhi	r5,3
    8da0:	297f3004 	addi	r5,r5,-832
    8da4:	01806604 	movi	r6,408
    8da8:	01c000f4 	movhi	r7,3
    8dac:	39fef804 	addi	r7,r7,-1056
    8db0:	00193f00 	call	193f0 <printf>
    8db4:	003fff06 	br	8db4 <mem_trim+0x138>
  if (newsize > size) {
    8db8:	e0bfff0b 	ldhu	r2,-4(fp)
    8dbc:	e0fffb8b 	ldhu	r3,-18(fp)
    8dc0:	1880022e 	bgeu	r3,r2,8dcc <mem_trim+0x150>
    /* not supported */
    return NULL;
    8dc4:	0005883a 	mov	r2,zero
    8dc8:	00007b06 	br	8fb8 <mem_trim+0x33c>
  }
  if (newsize == size) {
    8dcc:	e0ffff0b 	ldhu	r3,-4(fp)
    8dd0:	e0bffb8b 	ldhu	r2,-18(fp)
    8dd4:	1880021e 	bne	r3,r2,8de0 <mem_trim+0x164>
    /* No change in size, simply return */
    return rmem;
    8dd8:	e0bffe17 	ldw	r2,-8(fp)
    8ddc:	00007606 	br	8fb8 <mem_trim+0x33c>
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();

  mem2 = (struct mem *)(void *)&ram[mem->next];
    8de0:	d0e8b317 	ldw	r3,-23860(gp)
    8de4:	e0bffa17 	ldw	r2,-24(fp)
    8de8:	1080000b 	ldhu	r2,0(r2)
    8dec:	10bfffcc 	andi	r2,r2,65535
    8df0:	1885883a 	add	r2,r3,r2
    8df4:	e0bffc15 	stw	r2,-16(fp)
  if(mem2->used == 0) {
    8df8:	e0bffc17 	ldw	r2,-16(fp)
    8dfc:	10800103 	ldbu	r2,4(r2)
    8e00:	10803fcc 	andi	r2,r2,255
    8e04:	1000361e 	bne	r2,zero,8ee0 <mem_trim+0x264>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
    8e08:	e0bffc17 	ldw	r2,-16(fp)
    8e0c:	1080000b 	ldhu	r2,0(r2)
    8e10:	e0bffd0d 	sth	r2,-12(fp)
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    8e14:	e0fffb0b 	ldhu	r3,-20(fp)
    8e18:	e0bfff0b 	ldhu	r2,-4(fp)
    8e1c:	1885883a 	add	r2,r3,r2
    8e20:	10800204 	addi	r2,r2,8
    8e24:	e0bffd8d 	sth	r2,-10(fp)
    if (lfree == mem2) {
    8e28:	d0e8b517 	ldw	r3,-23852(gp)
    8e2c:	e0bffc17 	ldw	r2,-16(fp)
    8e30:	1880041e 	bne	r3,r2,8e44 <mem_trim+0x1c8>
      lfree = (struct mem *)(void *)&ram[ptr2];
    8e34:	d0e8b317 	ldw	r3,-23860(gp)
    8e38:	e0bffd8b 	ldhu	r2,-10(fp)
    8e3c:	1885883a 	add	r2,r3,r2
    8e40:	d0a8b515 	stw	r2,-23852(gp)
    }
    mem2 = (struct mem *)(void *)&ram[ptr2];
    8e44:	d0e8b317 	ldw	r3,-23860(gp)
    8e48:	e0bffd8b 	ldhu	r2,-10(fp)
    8e4c:	1885883a 	add	r2,r3,r2
    8e50:	e0bffc15 	stw	r2,-16(fp)
    mem2->used = 0;
    8e54:	e0bffc17 	ldw	r2,-16(fp)
    8e58:	10000105 	stb	zero,4(r2)
    /* restore the next pointer */
    mem2->next = next;
    8e5c:	e0bffc17 	ldw	r2,-16(fp)
    8e60:	e0fffd0b 	ldhu	r3,-12(fp)
    8e64:	10c0000d 	sth	r3,0(r2)
    /* link it back to mem */
    mem2->prev = ptr;
    8e68:	e0bffc17 	ldw	r2,-16(fp)
    8e6c:	e0fffb0b 	ldhu	r3,-20(fp)
    8e70:	10c0008d 	sth	r3,2(r2)
    /* link mem to it */
    mem->next = ptr2;
    8e74:	e0bffa17 	ldw	r2,-24(fp)
    8e78:	e0fffd8b 	ldhu	r3,-10(fp)
    8e7c:	10c0000d 	sth	r3,0(r2)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
    8e80:	e0bffc17 	ldw	r2,-16(fp)
    8e84:	1080000b 	ldhu	r2,0(r2)
    8e88:	10bfffcc 	andi	r2,r2,65535
    8e8c:	10819020 	cmpeqi	r2,r2,1600
    8e90:	1000071e 	bne	r2,zero,8eb0 <mem_trim+0x234>
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    8e94:	d0e8b317 	ldw	r3,-23860(gp)
    8e98:	e0bffc17 	ldw	r2,-16(fp)
    8e9c:	1080000b 	ldhu	r2,0(r2)
    8ea0:	10bfffcc 	andi	r2,r2,65535
    8ea4:	1885883a 	add	r2,r3,r2
    8ea8:	e0fffd8b 	ldhu	r3,-10(fp)
    8eac:	10c0008d 	sth	r3,2(r2)
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
    8eb0:	00800234 	movhi	r2,8
    8eb4:	1083bd04 	addi	r2,r2,3828
    8eb8:	10c02a8b 	ldhu	r3,170(r2)
    8ebc:	e13fff0b 	ldhu	r4,-4(fp)
    8ec0:	e0bffb8b 	ldhu	r2,-18(fp)
    8ec4:	2085c83a 	sub	r2,r4,r2
    8ec8:	1885883a 	add	r2,r3,r2
    8ecc:	1007883a 	mov	r3,r2
    8ed0:	00800234 	movhi	r2,8
    8ed4:	1083bd04 	addi	r2,r2,3828
    8ed8:	10c02a8d 	sth	r3,170(r2)
    8edc:	00003506 	br	8fb4 <mem_trim+0x338>
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
    8ee0:	e0bfff0b 	ldhu	r2,-4(fp)
    8ee4:	10800504 	addi	r2,r2,20
    8ee8:	e0fffb8b 	ldhu	r3,-18(fp)
    8eec:	18803136 	bltu	r3,r2,8fb4 <mem_trim+0x338>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    8ef0:	e0fffb0b 	ldhu	r3,-20(fp)
    8ef4:	e0bfff0b 	ldhu	r2,-4(fp)
    8ef8:	1885883a 	add	r2,r3,r2
    8efc:	10800204 	addi	r2,r2,8
    8f00:	e0bffd8d 	sth	r2,-10(fp)
    mem2 = (struct mem *)(void *)&ram[ptr2];
    8f04:	d0e8b317 	ldw	r3,-23860(gp)
    8f08:	e0bffd8b 	ldhu	r2,-10(fp)
    8f0c:	1885883a 	add	r2,r3,r2
    8f10:	e0bffc15 	stw	r2,-16(fp)
    if (mem2 < lfree) {
    8f14:	d0a8b517 	ldw	r2,-23852(gp)
    8f18:	e0fffc17 	ldw	r3,-16(fp)
    8f1c:	1880022e 	bgeu	r3,r2,8f28 <mem_trim+0x2ac>
      lfree = mem2;
    8f20:	e0bffc17 	ldw	r2,-16(fp)
    8f24:	d0a8b515 	stw	r2,-23852(gp)
    }
    mem2->used = 0;
    8f28:	e0bffc17 	ldw	r2,-16(fp)
    8f2c:	10000105 	stb	zero,4(r2)
    mem2->next = mem->next;
    8f30:	e0bffa17 	ldw	r2,-24(fp)
    8f34:	10c0000b 	ldhu	r3,0(r2)
    8f38:	e0bffc17 	ldw	r2,-16(fp)
    8f3c:	10c0000d 	sth	r3,0(r2)
    mem2->prev = ptr;
    8f40:	e0bffc17 	ldw	r2,-16(fp)
    8f44:	e0fffb0b 	ldhu	r3,-20(fp)
    8f48:	10c0008d 	sth	r3,2(r2)
    mem->next = ptr2;
    8f4c:	e0bffa17 	ldw	r2,-24(fp)
    8f50:	e0fffd8b 	ldhu	r3,-10(fp)
    8f54:	10c0000d 	sth	r3,0(r2)
    if (mem2->next != MEM_SIZE_ALIGNED) {
    8f58:	e0bffc17 	ldw	r2,-16(fp)
    8f5c:	1080000b 	ldhu	r2,0(r2)
    8f60:	10bfffcc 	andi	r2,r2,65535
    8f64:	10819020 	cmpeqi	r2,r2,1600
    8f68:	1000071e 	bne	r2,zero,8f88 <mem_trim+0x30c>
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    8f6c:	d0e8b317 	ldw	r3,-23860(gp)
    8f70:	e0bffc17 	ldw	r2,-16(fp)
    8f74:	1080000b 	ldhu	r2,0(r2)
    8f78:	10bfffcc 	andi	r2,r2,65535
    8f7c:	1885883a 	add	r2,r3,r2
    8f80:	e0fffd8b 	ldhu	r3,-10(fp)
    8f84:	10c0008d 	sth	r3,2(r2)
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
    8f88:	00800234 	movhi	r2,8
    8f8c:	1083bd04 	addi	r2,r2,3828
    8f90:	10c02a8b 	ldhu	r3,170(r2)
    8f94:	e13fff0b 	ldhu	r4,-4(fp)
    8f98:	e0bffb8b 	ldhu	r2,-18(fp)
    8f9c:	2085c83a 	sub	r2,r4,r2
    8fa0:	1885883a 	add	r2,r3,r2
    8fa4:	1007883a 	mov	r3,r2
    8fa8:	00800234 	movhi	r2,8
    8fac:	1083bd04 	addi	r2,r2,3828
    8fb0:	10c02a8d 	sth	r3,170(r2)
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
    8fb4:	e0bffe17 	ldw	r2,-8(fp)
}
    8fb8:	e037883a 	mov	sp,fp
    8fbc:	dfc00117 	ldw	ra,4(sp)
    8fc0:	df000017 	ldw	fp,0(sp)
    8fc4:	dec00204 	addi	sp,sp,8
    8fc8:	f800283a 	ret

00008fcc <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
    8fcc:	defff804 	addi	sp,sp,-32
    8fd0:	dfc00715 	stw	ra,28(sp)
    8fd4:	df000615 	stw	fp,24(sp)
    8fd8:	df000604 	addi	fp,sp,24
    8fdc:	2005883a 	mov	r2,r4
    8fe0:	e0bfff0d 	sth	r2,-4(fp)
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
    8fe4:	e0bfff0b 	ldhu	r2,-4(fp)
    8fe8:	1000021e 	bne	r2,zero,8ff4 <mem_malloc+0x28>
    return NULL;
    8fec:	0005883a 	mov	r2,zero
    8ff0:	0000ef06 	br	93b0 <mem_malloc+0x3e4>
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
    8ff4:	e0bfff0b 	ldhu	r2,-4(fp)
    8ff8:	108000c4 	addi	r2,r2,3
    8ffc:	1007883a 	mov	r3,r2
    9000:	00bfff04 	movi	r2,-4
    9004:	1884703a 	and	r2,r3,r2
    9008:	e0bfff0d 	sth	r2,-4(fp)

  if(size < MIN_SIZE_ALIGNED) {
    900c:	e0bfff0b 	ldhu	r2,-4(fp)
    9010:	10800328 	cmpgeui	r2,r2,12
    9014:	1000021e 	bne	r2,zero,9020 <mem_malloc+0x54>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
    9018:	00800304 	movi	r2,12
    901c:	e0bfff0d 	sth	r2,-4(fp)
  }

  if (size > MEM_SIZE_ALIGNED) {
    9020:	e0bfff0b 	ldhu	r2,-4(fp)
    9024:	10819070 	cmpltui	r2,r2,1601
    9028:	1000021e 	bne	r2,zero,9034 <mem_malloc+0x68>
    return NULL;
    902c:	0005883a 	mov	r2,zero
    9030:	0000df06 	br	93b0 <mem_malloc+0x3e4>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
    9034:	d0a8b517 	ldw	r2,-23852(gp)
    9038:	1007883a 	mov	r3,r2
    903c:	d0a8b317 	ldw	r2,-23860(gp)
    9040:	1885c83a 	sub	r2,r3,r2
    9044:	e0bffa0d 	sth	r2,-24(fp)
    9048:	0000cb06 	br	9378 <mem_malloc+0x3ac>
         ptr = ((struct mem *)(void *)&ram[ptr])->next) {
      mem = (struct mem *)(void *)&ram[ptr];
    904c:	d0e8b317 	ldw	r3,-23860(gp)
    9050:	e0bffa0b 	ldhu	r2,-24(fp)
    9054:	1885883a 	add	r2,r3,r2
    9058:	e0bffc15 	stw	r2,-16(fp)
        local_mem_free_count = 1;
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
    905c:	e0bffc17 	ldw	r2,-16(fp)
    9060:	10800103 	ldbu	r2,4(r2)
    9064:	10803fcc 	andi	r2,r2,255
    9068:	1000be1e 	bne	r2,zero,9364 <mem_malloc+0x398>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
    906c:	e0bffc17 	ldw	r2,-16(fp)
    9070:	1080000b 	ldhu	r2,0(r2)
    9074:	10ffffcc 	andi	r3,r2,65535
    9078:	e0bffa0b 	ldhu	r2,-24(fp)
    907c:	1885c83a 	sub	r2,r3,r2
    9080:	10fffe04 	addi	r3,r2,-8
    9084:	e0bfff0b 	ldhu	r2,-4(fp)
        local_mem_free_count = 1;
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
    9088:	1880b636 	bltu	r3,r2,9364 <mem_malloc+0x398>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
    908c:	e0bffc17 	ldw	r2,-16(fp)
    9090:	1080000b 	ldhu	r2,0(r2)
    9094:	10ffffcc 	andi	r3,r2,65535
    9098:	e0bffa0b 	ldhu	r2,-24(fp)
    909c:	1885c83a 	sub	r2,r3,r2
    90a0:	10fffe04 	addi	r3,r2,-8
    90a4:	e0bfff0b 	ldhu	r2,-4(fp)
    90a8:	10800504 	addi	r2,r2,20
    90ac:	18803e36 	bltu	r3,r2,91a8 <mem_malloc+0x1dc>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
    90b0:	e0fffa0b 	ldhu	r3,-24(fp)
    90b4:	e0bfff0b 	ldhu	r2,-4(fp)
    90b8:	1885883a 	add	r2,r3,r2
    90bc:	10800204 	addi	r2,r2,8
    90c0:	e0bffd0d 	sth	r2,-12(fp)
          /* create mem2 struct */
          mem2 = (struct mem *)(void *)&ram[ptr2];
    90c4:	d0e8b317 	ldw	r3,-23860(gp)
    90c8:	e0bffd0b 	ldhu	r2,-12(fp)
    90cc:	1885883a 	add	r2,r3,r2
    90d0:	e0bffe15 	stw	r2,-8(fp)
          mem2->used = 0;
    90d4:	e0bffe17 	ldw	r2,-8(fp)
    90d8:	10000105 	stb	zero,4(r2)
          mem2->next = mem->next;
    90dc:	e0bffc17 	ldw	r2,-16(fp)
    90e0:	10c0000b 	ldhu	r3,0(r2)
    90e4:	e0bffe17 	ldw	r2,-8(fp)
    90e8:	10c0000d 	sth	r3,0(r2)
          mem2->prev = ptr;
    90ec:	e0bffe17 	ldw	r2,-8(fp)
    90f0:	e0fffa0b 	ldhu	r3,-24(fp)
    90f4:	10c0008d 	sth	r3,2(r2)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
    90f8:	e0bffc17 	ldw	r2,-16(fp)
    90fc:	e0fffd0b 	ldhu	r3,-12(fp)
    9100:	10c0000d 	sth	r3,0(r2)
          mem->used = 1;
    9104:	e0bffc17 	ldw	r2,-16(fp)
    9108:	00c00044 	movi	r3,1
    910c:	10c00105 	stb	r3,4(r2)

          if (mem2->next != MEM_SIZE_ALIGNED) {
    9110:	e0bffe17 	ldw	r2,-8(fp)
    9114:	1080000b 	ldhu	r2,0(r2)
    9118:	10bfffcc 	andi	r2,r2,65535
    911c:	10819020 	cmpeqi	r2,r2,1600
    9120:	1000071e 	bne	r2,zero,9140 <mem_malloc+0x174>
            ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    9124:	d0e8b317 	ldw	r3,-23860(gp)
    9128:	e0bffe17 	ldw	r2,-8(fp)
    912c:	1080000b 	ldhu	r2,0(r2)
    9130:	10bfffcc 	andi	r2,r2,65535
    9134:	1885883a 	add	r2,r3,r2
    9138:	e0fffd0b 	ldhu	r3,-12(fp)
    913c:	10c0008d 	sth	r3,2(r2)
          }
          MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
    9140:	00800234 	movhi	r2,8
    9144:	1083bd04 	addi	r2,r2,3828
    9148:	10c02a8b 	ldhu	r3,170(r2)
    914c:	e0bfff0b 	ldhu	r2,-4(fp)
    9150:	1885883a 	add	r2,r3,r2
    9154:	10800204 	addi	r2,r2,8
    9158:	1007883a 	mov	r3,r2
    915c:	00800234 	movhi	r2,8
    9160:	1083bd04 	addi	r2,r2,3828
    9164:	10c02a8d 	sth	r3,170(r2)
    9168:	00800234 	movhi	r2,8
    916c:	1083bd04 	addi	r2,r2,3828
    9170:	10c02b0b 	ldhu	r3,172(r2)
    9174:	00800234 	movhi	r2,8
    9178:	1083bd04 	addi	r2,r2,3828
    917c:	10802a8b 	ldhu	r2,170(r2)
    9180:	18ffffcc 	andi	r3,r3,65535
    9184:	10bfffcc 	andi	r2,r2,65535
    9188:	1880272e 	bgeu	r3,r2,9228 <mem_malloc+0x25c>
    918c:	00800234 	movhi	r2,8
    9190:	1083bd04 	addi	r2,r2,3828
    9194:	10c02a8b 	ldhu	r3,170(r2)
    9198:	00800234 	movhi	r2,8
    919c:	1083bd04 	addi	r2,r2,3828
    91a0:	10c02b0d 	sth	r3,172(r2)
    91a4:	00002006 	br	9228 <mem_malloc+0x25c>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
    91a8:	e0bffc17 	ldw	r2,-16(fp)
    91ac:	00c00044 	movi	r3,1
    91b0:	10c00105 	stb	r3,4(r2)
          MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
    91b4:	00800234 	movhi	r2,8
    91b8:	1083bd04 	addi	r2,r2,3828
    91bc:	10c02a8b 	ldhu	r3,170(r2)
    91c0:	e0bffc17 	ldw	r2,-16(fp)
    91c4:	1100000b 	ldhu	r4,0(r2)
    91c8:	e17ffc17 	ldw	r5,-16(fp)
    91cc:	d0a8b317 	ldw	r2,-23860(gp)
    91d0:	2885c83a 	sub	r2,r5,r2
    91d4:	2085c83a 	sub	r2,r4,r2
    91d8:	1885883a 	add	r2,r3,r2
    91dc:	1007883a 	mov	r3,r2
    91e0:	00800234 	movhi	r2,8
    91e4:	1083bd04 	addi	r2,r2,3828
    91e8:	10c02a8d 	sth	r3,170(r2)
    91ec:	00800234 	movhi	r2,8
    91f0:	1083bd04 	addi	r2,r2,3828
    91f4:	10c02b0b 	ldhu	r3,172(r2)
    91f8:	00800234 	movhi	r2,8
    91fc:	1083bd04 	addi	r2,r2,3828
    9200:	10802a8b 	ldhu	r2,170(r2)
    9204:	18ffffcc 	andi	r3,r3,65535
    9208:	10bfffcc 	andi	r2,r2,65535
    920c:	1880062e 	bgeu	r3,r2,9228 <mem_malloc+0x25c>
    9210:	00800234 	movhi	r2,8
    9214:	1083bd04 	addi	r2,r2,3828
    9218:	10c02a8b 	ldhu	r3,170(r2)
    921c:	00800234 	movhi	r2,8
    9220:	1083bd04 	addi	r2,r2,3828
    9224:	10c02b0d 	sth	r3,172(r2)
        }
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
    9228:	d0a8b517 	ldw	r2,-23852(gp)
    922c:	e0fffc17 	ldw	r3,-16(fp)
    9230:	1880221e 	bne	r3,r2,92bc <mem_malloc+0x2f0>
          struct mem *cur = lfree;
    9234:	d0a8b517 	ldw	r2,-23852(gp)
    9238:	e0bffb15 	stw	r2,-20(fp)
          /* Find next free block after mem and update lowest free pointer */
          while (cur->used && cur != ram_end) {
    923c:	00000606 	br	9258 <mem_malloc+0x28c>
              /* If mem_free or mem_trim have run, we have to restart since they
                 could have altered our current struct mem or lfree. */
              goto mem_malloc_adjust_lfree;
            }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
            cur = (struct mem *)(void *)&ram[cur->next];
    9240:	d0e8b317 	ldw	r3,-23860(gp)
    9244:	e0bffb17 	ldw	r2,-20(fp)
    9248:	1080000b 	ldhu	r2,0(r2)
    924c:	10bfffcc 	andi	r2,r2,65535
    9250:	1885883a 	add	r2,r3,r2
    9254:	e0bffb15 	stw	r2,-20(fp)
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
          struct mem *cur = lfree;
          /* Find next free block after mem and update lowest free pointer */
          while (cur->used && cur != ram_end) {
    9258:	e0bffb17 	ldw	r2,-20(fp)
    925c:	10800103 	ldbu	r2,4(r2)
    9260:	10803fcc 	andi	r2,r2,255
    9264:	10000326 	beq	r2,zero,9274 <mem_malloc+0x2a8>
    9268:	d0a8b417 	ldw	r2,-23856(gp)
    926c:	e0fffb17 	ldw	r3,-20(fp)
    9270:	18bff31e 	bne	r3,r2,9240 <mem_malloc+0x274>
              goto mem_malloc_adjust_lfree;
            }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
            cur = (struct mem *)(void *)&ram[cur->next];
          }
          lfree = cur;
    9274:	e0bffb17 	ldw	r2,-20(fp)
    9278:	d0a8b515 	stw	r2,-23852(gp)
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
    927c:	d0e8b517 	ldw	r3,-23852(gp)
    9280:	d0a8b417 	ldw	r2,-23856(gp)
    9284:	18800d26 	beq	r3,r2,92bc <mem_malloc+0x2f0>
    9288:	d0a8b517 	ldw	r2,-23852(gp)
    928c:	10800103 	ldbu	r2,4(r2)
    9290:	10803fcc 	andi	r2,r2,255
    9294:	10000926 	beq	r2,zero,92bc <mem_malloc+0x2f0>
    9298:	010000f4 	movhi	r4,3
    929c:	213ee804 	addi	r4,r4,-1120
    92a0:	014000f4 	movhi	r5,3
    92a4:	297f3804 	addi	r5,r5,-800
    92a8:	01809884 	movi	r6,610
    92ac:	01c000f4 	movhi	r7,3
    92b0:	39fef804 	addi	r7,r7,-1056
    92b4:	00193f00 	call	193f0 <printf>
    92b8:	003fff06 	br	92b8 <mem_malloc+0x2ec>
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_mutex_unlock(&mem_mutex);
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
    92bc:	e0ffff0b 	ldhu	r3,-4(fp)
    92c0:	e0bffc17 	ldw	r2,-16(fp)
    92c4:	1885883a 	add	r2,r3,r2
    92c8:	10800204 	addi	r2,r2,8
    92cc:	d0e8b417 	ldw	r3,-23856(gp)
    92d0:	1880092e 	bgeu	r3,r2,92f8 <mem_malloc+0x32c>
    92d4:	010000f4 	movhi	r4,3
    92d8:	213ee804 	addi	r4,r4,-1120
    92dc:	014000f4 	movhi	r5,3
    92e0:	297f3f04 	addi	r5,r5,-772
    92e4:	018099c4 	movi	r6,615
    92e8:	01c000f4 	movhi	r7,3
    92ec:	39fef804 	addi	r7,r7,-1056
    92f0:	00193f00 	call	193f0 <printf>
    92f4:	003fff06 	br	92f4 <mem_malloc+0x328>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
    92f8:	e0bffc17 	ldw	r2,-16(fp)
    92fc:	108000cc 	andi	r2,r2,3
    9300:	10000926 	beq	r2,zero,9328 <mem_malloc+0x35c>
    9304:	010000f4 	movhi	r4,3
    9308:	213ee804 	addi	r4,r4,-1120
    930c:	014000f4 	movhi	r5,3
    9310:	297f4b04 	addi	r5,r5,-724
    9314:	01809a44 	movi	r6,617
    9318:	01c000f4 	movhi	r7,3
    931c:	39fef804 	addi	r7,r7,-1056
    9320:	00193f00 	call	193f0 <printf>
    9324:	003fff06 	br	9324 <mem_malloc+0x358>
         ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
    9328:	e0bffc17 	ldw	r2,-16(fp)
    932c:	108000cc 	andi	r2,r2,3
    9330:	10000926 	beq	r2,zero,9358 <mem_malloc+0x38c>
    9334:	010000f4 	movhi	r4,3
    9338:	213ee804 	addi	r4,r4,-1120
    933c:	014000f4 	movhi	r5,3
    9340:	297f5704 	addi	r5,r5,-676
    9344:	01809ac4 	movi	r6,619
    9348:	01c000f4 	movhi	r7,3
    934c:	39fef804 	addi	r7,r7,-1056
    9350:	00193f00 	call	193f0 <printf>
    9354:	003fff06 	br	9354 <mem_malloc+0x388>
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
    9358:	e0bffc17 	ldw	r2,-16(fp)
    935c:	10800204 	addi	r2,r2,8
    9360:	00001306 	br	93b0 <mem_malloc+0x3e4>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)(void *)&ram[ptr])->next) {
    9364:	d0e8b317 	ldw	r3,-23860(gp)
    9368:	e0bffa0b 	ldhu	r2,-24(fp)
    936c:	1885883a 	add	r2,r3,r2
    9370:	1080000b 	ldhu	r2,0(r2)
    9374:	e0bffa0d 	sth	r2,-24(fp)
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
    9378:	e0fffa0b 	ldhu	r3,-24(fp)
    937c:	e0bfff0b 	ldhu	r2,-4(fp)
    9380:	01019004 	movi	r4,1600
    9384:	2085c83a 	sub	r2,r4,r2
    9388:	18bf3016 	blt	r3,r2,904c <mem_malloc+0x80>
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
    /* if we got interrupted by a mem_free, try again */
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
    938c:	00800234 	movhi	r2,8
    9390:	1083bd04 	addi	r2,r2,3828
    9394:	10802b8b 	ldhu	r2,174(r2)
    9398:	10800044 	addi	r2,r2,1
    939c:	1007883a 	mov	r3,r2
    93a0:	00800234 	movhi	r2,8
    93a4:	1083bd04 	addi	r2,r2,3828
    93a8:	10c02b8d 	sth	r3,174(r2)
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
  return NULL;
    93ac:	0005883a 	mov	r2,zero
}
    93b0:	e037883a 	mov	sp,fp
    93b4:	dfc00117 	ldw	ra,4(sp)
    93b8:	df000017 	ldw	fp,0(sp)
    93bc:	dec00204 	addi	sp,sp,8
    93c0:	f800283a 	ret

000093c4 <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
    93c4:	defffb04 	addi	sp,sp,-20
    93c8:	dfc00415 	stw	ra,16(sp)
    93cc:	df000315 	stw	fp,12(sp)
    93d0:	df000304 	addi	fp,sp,12
    93d4:	2007883a 	mov	r3,r4
    93d8:	2805883a 	mov	r2,r5
    93dc:	e0fffe0d 	sth	r3,-8(fp)
    93e0:	e0bfff0d 	sth	r2,-4(fp)
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
    93e4:	e0fffe0b 	ldhu	r3,-8(fp)
    93e8:	e0bfff0b 	ldhu	r2,-4(fp)
    93ec:	1885383a 	mul	r2,r3,r2
    93f0:	10bfffcc 	andi	r2,r2,65535
    93f4:	1009883a 	mov	r4,r2
    93f8:	0008fcc0 	call	8fcc <mem_malloc>
    93fc:	e0bffd15 	stw	r2,-12(fp)
  if (p) {
    9400:	e0bffd17 	ldw	r2,-12(fp)
    9404:	10000726 	beq	r2,zero,9424 <mem_calloc+0x60>
    /* zero the memory */
    memset(p, 0, count * size);
    9408:	e0fffe0b 	ldhu	r3,-8(fp)
    940c:	e0bfff0b 	ldhu	r2,-4(fp)
    9410:	1885383a 	mul	r2,r3,r2
    9414:	e13ffd17 	ldw	r4,-12(fp)
    9418:	000b883a 	mov	r5,zero
    941c:	100d883a 	mov	r6,r2
    9420:	00192e80 	call	192e8 <memset>
  }
  return p;
    9424:	e0bffd17 	ldw	r2,-12(fp)
}
    9428:	e037883a 	mov	sp,fp
    942c:	dfc00117 	ldw	ra,4(sp)
    9430:	df000017 	ldw	fp,0(sp)
    9434:	dec00204 	addi	sp,sp,8
    9438:	f800283a 	ret

0000943c <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
    943c:	defffd04 	addi	sp,sp,-12
    9440:	df000215 	stw	fp,8(sp)
    9444:	df000204 	addi	fp,sp,8
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
    9448:	e03fff0d 	sth	zero,-4(fp)
    944c:	00002506 	br	94e4 <memp_init+0xa8>
    MEMP_STATS_AVAIL(used, i, 0);
    9450:	e0bfff0b 	ldhu	r2,-4(fp)
    9454:	00c00234 	movhi	r3,8
    9458:	18c3bd04 	addi	r3,r3,3828
    945c:	108002a4 	muli	r2,r2,10
    9460:	1885883a 	add	r2,r3,r2
    9464:	10802d04 	addi	r2,r2,180
    9468:	1000000d 	sth	zero,0(r2)
    MEMP_STATS_AVAIL(max, i, 0);
    946c:	e0bfff0b 	ldhu	r2,-4(fp)
    9470:	00c00234 	movhi	r3,8
    9474:	18c3bd04 	addi	r3,r3,3828
    9478:	108002a4 	muli	r2,r2,10
    947c:	1885883a 	add	r2,r3,r2
    9480:	10802d84 	addi	r2,r2,182
    9484:	1000000d 	sth	zero,0(r2)
    MEMP_STATS_AVAIL(err, i, 0);
    9488:	e0bfff0b 	ldhu	r2,-4(fp)
    948c:	00c00234 	movhi	r3,8
    9490:	18c3bd04 	addi	r3,r3,3828
    9494:	108002a4 	muli	r2,r2,10
    9498:	1885883a 	add	r2,r3,r2
    949c:	10802e04 	addi	r2,r2,184
    94a0:	1000000d 	sth	zero,0(r2)
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
    94a4:	e17fff0b 	ldhu	r5,-4(fp)
    94a8:	e0bfff0b 	ldhu	r2,-4(fp)
    94ac:	00c000f4 	movhi	r3,3
    94b0:	18ff6484 	addi	r3,r3,-622
    94b4:	1085883a 	add	r2,r2,r2
    94b8:	1885883a 	add	r2,r3,r2
    94bc:	10c0000b 	ldhu	r3,0(r2)
    94c0:	01000234 	movhi	r4,8
    94c4:	2103bd04 	addi	r4,r4,3828
    94c8:	288002a4 	muli	r2,r5,10
    94cc:	2085883a 	add	r2,r4,r2
    94d0:	10802c84 	addi	r2,r2,178
    94d4:	10c0000d 	sth	r3,0(r2)
memp_init(void)
{
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
    94d8:	e0bfff0b 	ldhu	r2,-4(fp)
    94dc:	10800044 	addi	r2,r2,1
    94e0:	e0bfff0d 	sth	r2,-4(fp)
    94e4:	e0bfff0b 	ldhu	r2,-4(fp)
    94e8:	10800270 	cmpltui	r2,r2,9
    94ec:	103fd81e 	bne	r2,zero,9450 <memp_init+0x14>
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

#if !MEMP_SEPARATE_POOLS
  memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
    94f0:	00800134 	movhi	r2,4
    94f4:	10a3c104 	addi	r2,r2,-28924
    94f8:	10c000c4 	addi	r3,r2,3
    94fc:	00bfff04 	movi	r2,-4
    9500:	1884703a 	and	r2,r3,r2
    9504:	e0bffe15 	stw	r2,-8(fp)
#endif /* !MEMP_SEPARATE_POOLS */
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    9508:	e03fff0d 	sth	zero,-4(fp)
    950c:	00003306 	br	95dc <memp_init+0x1a0>
    memp_tab[i] = NULL;
    9510:	e0bfff0b 	ldhu	r2,-4(fp)
    9514:	00c00134 	movhi	r3,4
    9518:	18e3b804 	addi	r3,r3,-28960
    951c:	1085883a 	add	r2,r2,r2
    9520:	1085883a 	add	r2,r2,r2
    9524:	1885883a 	add	r2,r3,r2
    9528:	10000015 	stw	zero,0(r2)
#if MEMP_SEPARATE_POOLS
    memp = (struct memp*)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
    952c:	e03fff8d 	sth	zero,-2(fp)
    9530:	00001e06 	br	95ac <memp_init+0x170>
      memp->next = memp_tab[i];
    9534:	e0bfff0b 	ldhu	r2,-4(fp)
    9538:	00c00134 	movhi	r3,4
    953c:	18e3b804 	addi	r3,r3,-28960
    9540:	1085883a 	add	r2,r2,r2
    9544:	1085883a 	add	r2,r2,r2
    9548:	1885883a 	add	r2,r3,r2
    954c:	10c00017 	ldw	r3,0(r2)
    9550:	e0bffe17 	ldw	r2,-8(fp)
    9554:	10c00015 	stw	r3,0(r2)
      memp_tab[i] = memp;
    9558:	e0bfff0b 	ldhu	r2,-4(fp)
    955c:	00c00134 	movhi	r3,4
    9560:	18e3b804 	addi	r3,r3,-28960
    9564:	1085883a 	add	r2,r2,r2
    9568:	1085883a 	add	r2,r2,r2
    956c:	1885883a 	add	r2,r3,r2
    9570:	e0fffe17 	ldw	r3,-8(fp)
    9574:	10c00015 	stw	r3,0(r2)
      memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
    9578:	e0bfff0b 	ldhu	r2,-4(fp)
    957c:	00c000f4 	movhi	r3,3
    9580:	18ff6004 	addi	r3,r3,-640
    9584:	1085883a 	add	r2,r2,r2
    9588:	1885883a 	add	r2,r3,r2
    958c:	1080000b 	ldhu	r2,0(r2)
    9590:	10bfffcc 	andi	r2,r2,65535
    9594:	e0fffe17 	ldw	r3,-8(fp)
    9598:	1885883a 	add	r2,r3,r2
    959c:	e0bffe15 	stw	r2,-8(fp)
    memp_tab[i] = NULL;
#if MEMP_SEPARATE_POOLS
    memp = (struct memp*)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
    95a0:	e0bfff8b 	ldhu	r2,-2(fp)
    95a4:	10800044 	addi	r2,r2,1
    95a8:	e0bfff8d 	sth	r2,-2(fp)
    95ac:	e0bfff0b 	ldhu	r2,-4(fp)
    95b0:	00c000f4 	movhi	r3,3
    95b4:	18ff6484 	addi	r3,r3,-622
    95b8:	1085883a 	add	r2,r2,r2
    95bc:	1885883a 	add	r2,r3,r2
    95c0:	1080000b 	ldhu	r2,0(r2)
    95c4:	10bfffcc 	andi	r2,r2,65535
    95c8:	e0ffff8b 	ldhu	r3,-2(fp)
    95cc:	18bfd936 	bltu	r3,r2,9534 <memp_init+0xf8>

#if !MEMP_SEPARATE_POOLS
  memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
#endif /* !MEMP_SEPARATE_POOLS */
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    95d0:	e0bfff0b 	ldhu	r2,-4(fp)
    95d4:	10800044 	addi	r2,r2,1
    95d8:	e0bfff0d 	sth	r2,-4(fp)
    95dc:	e0bfff0b 	ldhu	r2,-4(fp)
    95e0:	10800270 	cmpltui	r2,r2,9
    95e4:	103fca1e 	bne	r2,zero,9510 <memp_init+0xd4>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
    95e8:	e037883a 	mov	sp,fp
    95ec:	df000017 	ldw	fp,0(sp)
    95f0:	dec00104 	addi	sp,sp,4
    95f4:	f800283a 	ret

000095f8 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
    95f8:	defffc04 	addi	sp,sp,-16
    95fc:	dfc00315 	stw	ra,12(sp)
    9600:	df000215 	stw	fp,8(sp)
    9604:	df000204 	addi	fp,sp,8
    9608:	e13fff15 	stw	r4,-4(fp)
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
    960c:	e0bfff17 	ldw	r2,-4(fp)
    9610:	10800270 	cmpltui	r2,r2,9
    9614:	1000091e 	bne	r2,zero,963c <memp_malloc+0x44>
    9618:	010000f4 	movhi	r4,3
    961c:	213f6904 	addi	r4,r4,-604
    9620:	014000f4 	movhi	r5,3
    9624:	297f7304 	addi	r5,r5,-564
    9628:	01806384 	movi	r6,398
    962c:	01c000f4 	movhi	r7,3
    9630:	39ff7b04 	addi	r7,r7,-532
    9634:	00193f00 	call	193f0 <printf>
    9638:	003fff06 	br	9638 <memp_malloc+0x40>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
    963c:	00c00134 	movhi	r3,4
    9640:	18e3b804 	addi	r3,r3,-28960
    9644:	e0bfff17 	ldw	r2,-4(fp)
    9648:	1085883a 	add	r2,r2,r2
    964c:	1085883a 	add	r2,r2,r2
    9650:	1885883a 	add	r2,r3,r2
    9654:	10800017 	ldw	r2,0(r2)
    9658:	e0bffe15 	stw	r2,-8(fp)
  
  if (memp != NULL) {
    965c:	e0bffe17 	ldw	r2,-8(fp)
    9660:	10004426 	beq	r2,zero,9774 <memp_malloc+0x17c>
    memp_tab[type] = memp->next;
    9664:	e0bffe17 	ldw	r2,-8(fp)
    9668:	10c00017 	ldw	r3,0(r2)
    966c:	01000134 	movhi	r4,4
    9670:	2123b804 	addi	r4,r4,-28960
    9674:	e0bfff17 	ldw	r2,-4(fp)
    9678:	1085883a 	add	r2,r2,r2
    967c:	1085883a 	add	r2,r2,r2
    9680:	2085883a 	add	r2,r4,r2
    9684:	10c00015 	stw	r3,0(r2)
#if MEMP_OVERFLOW_CHECK
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    9688:	00c00234 	movhi	r3,8
    968c:	18c3bd04 	addi	r3,r3,3828
    9690:	e0bfff17 	ldw	r2,-4(fp)
    9694:	108002a4 	muli	r2,r2,10
    9698:	1885883a 	add	r2,r3,r2
    969c:	10802d04 	addi	r2,r2,180
    96a0:	1080000b 	ldhu	r2,0(r2)
    96a4:	10800044 	addi	r2,r2,1
    96a8:	1007883a 	mov	r3,r2
    96ac:	01000234 	movhi	r4,8
    96b0:	2103bd04 	addi	r4,r4,3828
    96b4:	e0bfff17 	ldw	r2,-4(fp)
    96b8:	108002a4 	muli	r2,r2,10
    96bc:	2085883a 	add	r2,r4,r2
    96c0:	10802d04 	addi	r2,r2,180
    96c4:	10c0000d 	sth	r3,0(r2)
    96c8:	00c00234 	movhi	r3,8
    96cc:	18c3bd04 	addi	r3,r3,3828
    96d0:	e0bfff17 	ldw	r2,-4(fp)
    96d4:	108002a4 	muli	r2,r2,10
    96d8:	1885883a 	add	r2,r3,r2
    96dc:	10802d84 	addi	r2,r2,182
    96e0:	10c0000b 	ldhu	r3,0(r2)
    96e4:	01000234 	movhi	r4,8
    96e8:	2103bd04 	addi	r4,r4,3828
    96ec:	e0bfff17 	ldw	r2,-4(fp)
    96f0:	108002a4 	muli	r2,r2,10
    96f4:	2085883a 	add	r2,r4,r2
    96f8:	10802d04 	addi	r2,r2,180
    96fc:	1080000b 	ldhu	r2,0(r2)
    9700:	18ffffcc 	andi	r3,r3,65535
    9704:	10bfffcc 	andi	r2,r2,65535
    9708:	18800e2e 	bgeu	r3,r2,9744 <memp_malloc+0x14c>
    970c:	00c00234 	movhi	r3,8
    9710:	18c3bd04 	addi	r3,r3,3828
    9714:	e0bfff17 	ldw	r2,-4(fp)
    9718:	108002a4 	muli	r2,r2,10
    971c:	1885883a 	add	r2,r3,r2
    9720:	10802d04 	addi	r2,r2,180
    9724:	10c0000b 	ldhu	r3,0(r2)
    9728:	01000234 	movhi	r4,8
    972c:	2103bd04 	addi	r4,r4,3828
    9730:	e0bfff17 	ldw	r2,-4(fp)
    9734:	108002a4 	muli	r2,r2,10
    9738:	2085883a 	add	r2,r4,r2
    973c:	10802d84 	addi	r2,r2,182
    9740:	10c0000d 	sth	r3,0(r2)
    LWIP_ASSERT("memp_malloc: memp properly aligned",
    9744:	e0bffe17 	ldw	r2,-8(fp)
    9748:	108000cc 	andi	r2,r2,3
    974c:	10001a26 	beq	r2,zero,97b8 <memp_malloc+0x1c0>
    9750:	010000f4 	movhi	r4,3
    9754:	213f6904 	addi	r4,r4,-604
    9758:	014000f4 	movhi	r5,3
    975c:	297f8104 	addi	r5,r5,-508
    9760:	01806804 	movi	r6,416
    9764:	01c000f4 	movhi	r7,3
    9768:	39ff7b04 	addi	r7,r7,-532
    976c:	00193f00 	call	193f0 <printf>
    9770:	003fff06 	br	9770 <memp_malloc+0x178>
                ((mem_ptr_t)memp % MEM_ALIGNMENT) == 0);
    memp = (struct memp*)(void *)((u8_t*)memp + MEMP_SIZE);
  } else {
    LWIP_DEBUGF(MEMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("memp_malloc: out of memory in pool %s\n", memp_desc[type]));
    MEMP_STATS_INC(err, type);
    9774:	00c00234 	movhi	r3,8
    9778:	18c3bd04 	addi	r3,r3,3828
    977c:	e0bfff17 	ldw	r2,-4(fp)
    9780:	108002a4 	muli	r2,r2,10
    9784:	1885883a 	add	r2,r3,r2
    9788:	10802e04 	addi	r2,r2,184
    978c:	1080000b 	ldhu	r2,0(r2)
    9790:	10800044 	addi	r2,r2,1
    9794:	1007883a 	mov	r3,r2
    9798:	01000234 	movhi	r4,8
    979c:	2103bd04 	addi	r4,r4,3828
    97a0:	e0bfff17 	ldw	r2,-4(fp)
    97a4:	108002a4 	muli	r2,r2,10
    97a8:	2085883a 	add	r2,r4,r2
    97ac:	10802e04 	addi	r2,r2,184
    97b0:	10c0000d 	sth	r3,0(r2)
    97b4:	00000106 	br	97bc <memp_malloc+0x1c4>
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
                ((mem_ptr_t)memp % MEM_ALIGNMENT) == 0);
    memp = (struct memp*)(void *)((u8_t*)memp + MEMP_SIZE);
    97b8:	0001883a 	nop
    MEMP_STATS_INC(err, type);
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
    97bc:	e0bffe17 	ldw	r2,-8(fp)
}
    97c0:	e037883a 	mov	sp,fp
    97c4:	dfc00117 	ldw	ra,4(sp)
    97c8:	df000017 	ldw	fp,0(sp)
    97cc:	dec00204 	addi	sp,sp,8
    97d0:	f800283a 	ret

000097d4 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
    97d4:	defffb04 	addi	sp,sp,-20
    97d8:	dfc00415 	stw	ra,16(sp)
    97dc:	df000315 	stw	fp,12(sp)
    97e0:	df000304 	addi	fp,sp,12
    97e4:	e13ffe15 	stw	r4,-8(fp)
    97e8:	e17fff15 	stw	r5,-4(fp)
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
    97ec:	e0bfff17 	ldw	r2,-4(fp)
    97f0:	10003026 	beq	r2,zero,98b4 <memp_free+0xe0>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
    97f4:	e0bfff17 	ldw	r2,-4(fp)
    97f8:	108000cc 	andi	r2,r2,3
    97fc:	10000926 	beq	r2,zero,9824 <memp_free+0x50>
    9800:	010000f4 	movhi	r4,3
    9804:	213f6904 	addi	r4,r4,-604
    9808:	014000f4 	movhi	r5,3
    980c:	297f8a04 	addi	r5,r5,-472
    9810:	01806f04 	movi	r6,444
    9814:	01c000f4 	movhi	r7,3
    9818:	39ff7b04 	addi	r7,r7,-532
    981c:	00193f00 	call	193f0 <printf>
    9820:	003fff06 	br	9820 <memp_free+0x4c>
                ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  memp = (struct memp *)(void *)((u8_t*)mem - MEMP_SIZE);
    9824:	e0bfff17 	ldw	r2,-4(fp)
    9828:	e0bffd15 	stw	r2,-12(fp)
  memp_overflow_check_element_overflow(memp, type);
  memp_overflow_check_element_underflow(memp, type);
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
    982c:	00c00234 	movhi	r3,8
    9830:	18c3bd04 	addi	r3,r3,3828
    9834:	e0bffe17 	ldw	r2,-8(fp)
    9838:	108002a4 	muli	r2,r2,10
    983c:	1885883a 	add	r2,r3,r2
    9840:	10802d04 	addi	r2,r2,180
    9844:	1080000b 	ldhu	r2,0(r2)
    9848:	10bfffc4 	addi	r2,r2,-1
    984c:	1007883a 	mov	r3,r2
    9850:	01000234 	movhi	r4,8
    9854:	2103bd04 	addi	r4,r4,3828
    9858:	e0bffe17 	ldw	r2,-8(fp)
    985c:	108002a4 	muli	r2,r2,10
    9860:	2085883a 	add	r2,r4,r2
    9864:	10802d04 	addi	r2,r2,180
    9868:	10c0000d 	sth	r3,0(r2)
  
  memp->next = memp_tab[type]; 
    986c:	00c00134 	movhi	r3,4
    9870:	18e3b804 	addi	r3,r3,-28960
    9874:	e0bffe17 	ldw	r2,-8(fp)
    9878:	1085883a 	add	r2,r2,r2
    987c:	1085883a 	add	r2,r2,r2
    9880:	1885883a 	add	r2,r3,r2
    9884:	10c00017 	ldw	r3,0(r2)
    9888:	e0bffd17 	ldw	r2,-12(fp)
    988c:	10c00015 	stw	r3,0(r2)
  memp_tab[type] = memp;
    9890:	00c00134 	movhi	r3,4
    9894:	18e3b804 	addi	r3,r3,-28960
    9898:	e0bffe17 	ldw	r2,-8(fp)
    989c:	1085883a 	add	r2,r2,r2
    98a0:	1085883a 	add	r2,r2,r2
    98a4:	1885883a 	add	r2,r3,r2
    98a8:	e0fffd17 	ldw	r3,-12(fp)
    98ac:	10c00015 	stw	r3,0(r2)
    98b0:	00000106 	br	98b8 <memp_free+0xe4>
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
    return;
    98b4:	0001883a 	nop
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
    98b8:	e037883a 	mov	sp,fp
    98bc:	dfc00117 	ldw	ra,4(sp)
    98c0:	df000017 	ldw	fp,0(sp)
    98c4:	dec00204 	addi	sp,sp,8
    98c8:	f800283a 	ret

000098cc <netif_init>:
}
#endif /* LWIP_HAVE_LOOPIF */

void
netif_init(void)
{
    98cc:	deffff04 	addi	sp,sp,-4
    98d0:	df000015 	stw	fp,0(sp)
    98d4:	d839883a 	mov	fp,sp
  netif_add(&loop_netif, &loop_ipaddr, &loop_netmask, &loop_gw, NULL, netif_loopif_init, tcpip_input);
#endif /* NO_SYS */
  netif_set_up(&loop_netif);

#endif /* LWIP_HAVE_LOOPIF */
}
    98d8:	e037883a 	mov	sp,fp
    98dc:	df000017 	ldw	fp,0(sp)
    98e0:	dec00104 	addi	sp,sp,4
    98e4:	f800283a 	ret

000098e8 <netif_add>:
 * @return netif, or NULL if failed.
 */
struct netif *
netif_add(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
  ip_addr_t *gw, void *state, netif_init_fn init, netif_input_fn input)
{
    98e8:	defffa04 	addi	sp,sp,-24
    98ec:	dfc00515 	stw	ra,20(sp)
    98f0:	df000415 	stw	fp,16(sp)
    98f4:	df000404 	addi	fp,sp,16
    98f8:	e13ffc15 	stw	r4,-16(fp)
    98fc:	e17ffd15 	stw	r5,-12(fp)
    9900:	e1bffe15 	stw	r6,-8(fp)
    9904:	e1ffff15 	stw	r7,-4(fp)

  LWIP_ASSERT("No init function given", init != NULL);
    9908:	e0800317 	ldw	r2,12(fp)
    990c:	1000091e 	bne	r2,zero,9934 <netif_add+0x4c>
    9910:	010000f4 	movhi	r4,3
    9914:	213f9204 	addi	r4,r4,-440
    9918:	014000f4 	movhi	r5,3
    991c:	297f9c04 	addi	r5,r5,-400
    9920:	018023c4 	movi	r6,143
    9924:	01c000f4 	movhi	r7,3
    9928:	39ffa204 	addi	r7,r7,-376
    992c:	00193f00 	call	193f0 <printf>
    9930:	003fff06 	br	9930 <netif_add+0x48>

  /* reset new interface configuration state */
  ip_addr_set_zero(&netif->ip_addr);
    9934:	e0bffc17 	ldw	r2,-16(fp)
    9938:	10000115 	stw	zero,4(r2)
  ip_addr_set_zero(&netif->netmask);
    993c:	e0bffc17 	ldw	r2,-16(fp)
    9940:	10000215 	stw	zero,8(r2)
  ip_addr_set_zero(&netif->gw);
    9944:	e0bffc17 	ldw	r2,-16(fp)
    9948:	10000315 	stw	zero,12(r2)
  netif->flags = 0;
    994c:	e0bffc17 	ldw	r2,-16(fp)
    9950:	10000b45 	stb	zero,45(r2)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
    9954:	e0bffc17 	ldw	r2,-16(fp)
    9958:	10000815 	stw	zero,32(r2)
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
    995c:	e0bffc17 	ldw	r2,-16(fp)
    9960:	e0c00217 	ldw	r3,8(fp)
    9964:	10c00715 	stw	r3,28(r2)
  netif->num = netif_num++;
    9968:	d0a8b603 	ldbu	r2,-23848(gp)
    996c:	e0fffc17 	ldw	r3,-16(fp)
    9970:	18800c05 	stb	r2,48(r3)
    9974:	10800044 	addi	r2,r2,1
    9978:	d0a8b605 	stb	r2,-23848(gp)
  netif->input = input;
    997c:	e0bffc17 	ldw	r2,-16(fp)
    9980:	e0c00417 	ldw	r3,16(fp)
    9984:	10c00415 	stw	r3,16(r2)
  NETIF_SET_HWADDRHINT(netif, NULL);
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
    9988:	e13ffc17 	ldw	r4,-16(fp)
    998c:	e17ffd17 	ldw	r5,-12(fp)
    9990:	e1bffe17 	ldw	r6,-8(fp)
    9994:	e1ffff17 	ldw	r7,-4(fp)
    9998:	00099ec0 	call	99ec <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
    999c:	e0800317 	ldw	r2,12(fp)
    99a0:	e13ffc17 	ldw	r4,-16(fp)
    99a4:	103ee83a 	callr	r2
    99a8:	10803fcc 	andi	r2,r2,255
    99ac:	1080201c 	xori	r2,r2,128
    99b0:	10bfe004 	addi	r2,r2,-128
    99b4:	10000226 	beq	r2,zero,99c0 <netif_add+0xd8>
    return NULL;
    99b8:	0005883a 	mov	r2,zero
    99bc:	00000606 	br	99d8 <netif_add+0xf0>
  }

  /* add this netif to the list */
  netif->next = netif_list;
    99c0:	d0e8b717 	ldw	r3,-23844(gp)
    99c4:	e0bffc17 	ldw	r2,-16(fp)
    99c8:	10c00015 	stw	r3,0(r2)
  netif_list = netif;
    99cc:	e0bffc17 	ldw	r2,-16(fp)
    99d0:	d0a8b715 	stw	r2,-23844(gp)
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
    99d4:	e0bffc17 	ldw	r2,-16(fp)
}
    99d8:	e037883a 	mov	sp,fp
    99dc:	dfc00117 	ldw	ra,4(sp)
    99e0:	df000017 	ldw	fp,0(sp)
    99e4:	dec00204 	addi	sp,sp,8
    99e8:	f800283a 	ret

000099ec <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
    ip_addr_t *gw)
{
    99ec:	defffa04 	addi	sp,sp,-24
    99f0:	dfc00515 	stw	ra,20(sp)
    99f4:	df000415 	stw	fp,16(sp)
    99f8:	df000404 	addi	fp,sp,16
    99fc:	e13ffc15 	stw	r4,-16(fp)
    9a00:	e17ffd15 	stw	r5,-12(fp)
    9a04:	e1bffe15 	stw	r6,-8(fp)
    9a08:	e1ffff15 	stw	r7,-4(fp)
  netif_set_ipaddr(netif, ipaddr);
    9a0c:	e13ffc17 	ldw	r4,-16(fp)
    9a10:	e17ffd17 	ldw	r5,-12(fp)
    9a14:	0009bfc0 	call	9bfc <netif_set_ipaddr>
  netif_set_netmask(netif, netmask);
    9a18:	e13ffc17 	ldw	r4,-16(fp)
    9a1c:	e17ffe17 	ldw	r5,-8(fp)
    9a20:	0009d740 	call	9d74 <netif_set_netmask>
  netif_set_gw(netif, gw);
    9a24:	e13ffc17 	ldw	r4,-16(fp)
    9a28:	e17fff17 	ldw	r5,-4(fp)
    9a2c:	0009d300 	call	9d30 <netif_set_gw>
}
    9a30:	e037883a 	mov	sp,fp
    9a34:	dfc00117 	ldw	ra,4(sp)
    9a38:	df000017 	ldw	fp,0(sp)
    9a3c:	dec00204 	addi	sp,sp,8
    9a40:	f800283a 	ret

00009a44 <netif_remove>:
 *
 * @param netif the network interface to remove
 */
void
netif_remove(struct netif *netif)
{
    9a44:	defffc04 	addi	sp,sp,-16
    9a48:	dfc00315 	stw	ra,12(sp)
    9a4c:	df000215 	stw	fp,8(sp)
    9a50:	df000204 	addi	fp,sp,8
    9a54:	e13fff15 	stw	r4,-4(fp)
  if (netif == NULL) {
    9a58:	e0bfff17 	ldw	r2,-4(fp)
    9a5c:	10002726 	beq	r2,zero,9afc <netif_remove+0xb8>
  /* stop IGMP processing */
  if (netif->flags & NETIF_FLAG_IGMP) {
    igmp_stop(netif);
  }
#endif /* LWIP_IGMP */
  if (netif_is_up(netif)) {
    9a60:	e0bfff17 	ldw	r2,-4(fp)
    9a64:	10800b43 	ldbu	r2,45(r2)
    9a68:	10803fcc 	andi	r2,r2,255
    9a6c:	1080004c 	andi	r2,r2,1
    9a70:	10000226 	beq	r2,zero,9a7c <netif_remove+0x38>
    /* set netif down before removing (call callback function) */
    netif_set_down(netif);
    9a74:	e13fff17 	ldw	r4,-4(fp)
    9a78:	0009e700 	call	9e70 <netif_set_down>
  }

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
    9a7c:	d0e8b717 	ldw	r3,-23844(gp)
    9a80:	e0bfff17 	ldw	r2,-4(fp)
    9a84:	1880041e 	bne	r3,r2,9a98 <netif_remove+0x54>
    netif_list = netif->next;
    9a88:	e0bfff17 	ldw	r2,-4(fp)
    9a8c:	10800017 	ldw	r2,0(r2)
    9a90:	d0a8b715 	stw	r2,-23844(gp)
    9a94:	00001306 	br	9ae4 <netif_remove+0xa0>
  } else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
    9a98:	d0a8b717 	ldw	r2,-23844(gp)
    9a9c:	e0bffe15 	stw	r2,-8(fp)
    9aa0:	00000c06 	br	9ad4 <netif_remove+0x90>
      if (tmpNetif->next == netif) {
    9aa4:	e0bffe17 	ldw	r2,-8(fp)
    9aa8:	10c00017 	ldw	r3,0(r2)
    9aac:	e0bfff17 	ldw	r2,-4(fp)
    9ab0:	1880051e 	bne	r3,r2,9ac8 <netif_remove+0x84>
        tmpNetif->next = netif->next;
    9ab4:	e0bfff17 	ldw	r2,-4(fp)
    9ab8:	10c00017 	ldw	r3,0(r2)
    9abc:	e0bffe17 	ldw	r2,-8(fp)
    9ac0:	10c00015 	stw	r3,0(r2)
        break;
    9ac4:	00000506 	br	9adc <netif_remove+0x98>
  if (netif_list == netif) {
    netif_list = netif->next;
  } else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
    9ac8:	e0bffe17 	ldw	r2,-8(fp)
    9acc:	10800017 	ldw	r2,0(r2)
    9ad0:	e0bffe15 	stw	r2,-8(fp)
    9ad4:	e0bffe17 	ldw	r2,-8(fp)
    9ad8:	103ff21e 	bne	r2,zero,9aa4 <netif_remove+0x60>
      if (tmpNetif->next == netif) {
        tmpNetif->next = netif->next;
        break;
      }
    }
    if (tmpNetif == NULL)
    9adc:	e0bffe17 	ldw	r2,-8(fp)
    9ae0:	10000826 	beq	r2,zero,9b04 <netif_remove+0xc0>
      return; /*  we didn't find any netif today */
  }
  snmp_dec_iflist();
  /* this netif is default? */
  if (netif_default == netif) {
    9ae4:	d0e8b817 	ldw	r3,-23840(gp)
    9ae8:	e0bfff17 	ldw	r2,-4(fp)
    9aec:	1880061e 	bne	r3,r2,9b08 <netif_remove+0xc4>
    /* reset default netif */
    netif_set_default(NULL);
    9af0:	0009883a 	mov	r4,zero
    9af4:	0009db80 	call	9db8 <netif_set_default>
    9af8:	00000306 	br	9b08 <netif_remove+0xc4>
 */
void
netif_remove(struct netif *netif)
{
  if (netif == NULL) {
    return;
    9afc:	0001883a 	nop
    9b00:	00000106 	br	9b08 <netif_remove+0xc4>
        tmpNetif->next = netif->next;
        break;
      }
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
    9b04:	0001883a 	nop
  if (netif->remove_callback) {
    netif->remove_callback(netif);
  }
#endif /* LWIP_NETIF_REMOVE_CALLBACK */
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
    9b08:	e037883a 	mov	sp,fp
    9b0c:	dfc00117 	ldw	ra,4(sp)
    9b10:	df000017 	ldw	fp,0(sp)
    9b14:	dec00204 	addi	sp,sp,8
    9b18:	f800283a 	ret

00009b1c <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
    9b1c:	defffc04 	addi	sp,sp,-16
    9b20:	df000315 	stw	fp,12(sp)
    9b24:	df000304 	addi	fp,sp,12
    9b28:	e13fff15 	stw	r4,-4(fp)
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
    9b2c:	e0bfff17 	ldw	r2,-4(fp)
    9b30:	1000021e 	bne	r2,zero,9b3c <netif_find+0x20>
    return NULL;
    9b34:	0005883a 	mov	r2,zero
    9b38:	00002c06 	br	9bec <netif_find+0xd0>
  }

  num = name[2] - '0';
    9b3c:	e0bfff17 	ldw	r2,-4(fp)
    9b40:	10800084 	addi	r2,r2,2
    9b44:	10800003 	ldbu	r2,0(r2)
    9b48:	10bff404 	addi	r2,r2,-48
    9b4c:	e0bffe05 	stb	r2,-8(fp)

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    9b50:	d0a8b717 	ldw	r2,-23844(gp)
    9b54:	e0bffd15 	stw	r2,-12(fp)
    9b58:	00002106 	br	9be0 <netif_find+0xc4>
    if (num == netif->num &&
    9b5c:	e0bffd17 	ldw	r2,-12(fp)
    9b60:	10800c03 	ldbu	r2,48(r2)
    9b64:	10c03fcc 	andi	r3,r2,255
    9b68:	e0bffe03 	ldbu	r2,-8(fp)
    9b6c:	1880191e 	bne	r3,r2,9bd4 <netif_find+0xb8>
       name[0] == netif->name[0] &&
    9b70:	e0bfff17 	ldw	r2,-4(fp)
    9b74:	10c00003 	ldbu	r3,0(r2)
    9b78:	e0bffd17 	ldw	r2,-12(fp)
    9b7c:	10800b83 	ldbu	r2,46(r2)
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
    9b80:	18c03fcc 	andi	r3,r3,255
    9b84:	18c0201c 	xori	r3,r3,128
    9b88:	18ffe004 	addi	r3,r3,-128
    9b8c:	10803fcc 	andi	r2,r2,255
    9b90:	1080201c 	xori	r2,r2,128
    9b94:	10bfe004 	addi	r2,r2,-128
    9b98:	18800e1e 	bne	r3,r2,9bd4 <netif_find+0xb8>
       name[0] == netif->name[0] &&
       name[1] == netif->name[1]) {
    9b9c:	e0bfff17 	ldw	r2,-4(fp)
    9ba0:	10800044 	addi	r2,r2,1
    9ba4:	10c00003 	ldbu	r3,0(r2)
    9ba8:	e0bffd17 	ldw	r2,-12(fp)
    9bac:	10800bc3 	ldbu	r2,47(r2)

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
       name[0] == netif->name[0] &&
    9bb0:	18c03fcc 	andi	r3,r3,255
    9bb4:	18c0201c 	xori	r3,r3,128
    9bb8:	18ffe004 	addi	r3,r3,-128
    9bbc:	10803fcc 	andi	r2,r2,255
    9bc0:	1080201c 	xori	r2,r2,128
    9bc4:	10bfe004 	addi	r2,r2,-128
    9bc8:	1880021e 	bne	r3,r2,9bd4 <netif_find+0xb8>
       name[1] == netif->name[1]) {
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
    9bcc:	e0bffd17 	ldw	r2,-12(fp)
    9bd0:	00000606 	br	9bec <netif_find+0xd0>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    9bd4:	e0bffd17 	ldw	r2,-12(fp)
    9bd8:	10800017 	ldw	r2,0(r2)
    9bdc:	e0bffd15 	stw	r2,-12(fp)
    9be0:	e0bffd17 	ldw	r2,-12(fp)
    9be4:	103fdd1e 	bne	r2,zero,9b5c <netif_find+0x40>
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
    9be8:	0005883a 	mov	r2,zero
}
    9bec:	e037883a 	mov	sp,fp
    9bf0:	df000017 	ldw	fp,0(sp)
    9bf4:	dec00104 	addi	sp,sp,4
    9bf8:	f800283a 	ret

00009bfc <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, ip_addr_t *ipaddr)
{
    9bfc:	defff904 	addi	sp,sp,-28
    9c00:	dfc00615 	stw	ra,24(sp)
    9c04:	df000515 	stw	fp,20(sp)
    9c08:	df000504 	addi	fp,sp,20
    9c0c:	e13ffe15 	stw	r4,-8(fp)
    9c10:	e17fff15 	stw	r5,-4(fp)
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
    9c14:	e0bfff17 	ldw	r2,-4(fp)
    9c18:	10003826 	beq	r2,zero,9cfc <netif_set_ipaddr+0x100>
    9c1c:	e0bfff17 	ldw	r2,-4(fp)
    9c20:	10c00017 	ldw	r3,0(r2)
    9c24:	e0bffe17 	ldw	r2,-8(fp)
    9c28:	10800117 	ldw	r2,4(r2)
    9c2c:	18803326 	beq	r3,r2,9cfc <netif_set_ipaddr+0x100>
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    9c30:	008000f4 	movhi	r2,3
    9c34:	109e2e04 	addi	r2,r2,30904
    9c38:	10800017 	ldw	r2,0(r2)
    9c3c:	e0bffb15 	stw	r2,-20(fp)
    while (pcb != NULL) {
    9c40:	00001006 	br	9c84 <netif_set_ipaddr+0x88>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
    9c44:	e0bffb17 	ldw	r2,-20(fp)
    9c48:	10c00017 	ldw	r3,0(r2)
    9c4c:	e0bffe17 	ldw	r2,-8(fp)
    9c50:	10800117 	ldw	r2,4(r2)
    9c54:	1880081e 	bne	r3,r2,9c78 <netif_set_ipaddr+0x7c>
        /* connections to link-local addresses must persist (RFC3927 ch. 1.9) */
        && !ip_addr_islinklocal(&(pcb->local_ip))
#endif /* LWIP_AUTOIP */
        ) {
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
    9c58:	e0bffb17 	ldw	r2,-20(fp)
    9c5c:	10800317 	ldw	r2,12(r2)
    9c60:	e0bffd15 	stw	r2,-12(fp)
        LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
    9c64:	e13ffb17 	ldw	r4,-20(fp)
    9c68:	000c5280 	call	c528 <tcp_abort>
        pcb = next;
    9c6c:	e0bffd17 	ldw	r2,-12(fp)
    9c70:	e0bffb15 	stw	r2,-20(fp)
    9c74:	00000306 	br	9c84 <netif_set_ipaddr+0x88>
      } else {
        pcb = pcb->next;
    9c78:	e0bffb17 	ldw	r2,-20(fp)
    9c7c:	10800317 	ldw	r2,12(r2)
    9c80:	e0bffb15 	stw	r2,-20(fp)
  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
    9c84:	e0bffb17 	ldw	r2,-20(fp)
    9c88:	103fee1e 	bne	r2,zero,9c44 <netif_set_ipaddr+0x48>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    9c8c:	008000f4 	movhi	r2,3
    9c90:	109e3004 	addi	r2,r2,30912
    9c94:	10800017 	ldw	r2,0(r2)
    9c98:	e0bffc15 	stw	r2,-16(fp)
    9c9c:	00001506 	br	9cf4 <netif_set_ipaddr+0xf8>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
    9ca0:	e0bffc17 	ldw	r2,-16(fp)
    9ca4:	10001026 	beq	r2,zero,9ce8 <netif_set_ipaddr+0xec>
    9ca8:	e0bffc17 	ldw	r2,-16(fp)
    9cac:	10800017 	ldw	r2,0(r2)
    9cb0:	10000d26 	beq	r2,zero,9ce8 <netif_set_ipaddr+0xec>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
    9cb4:	e0bffc17 	ldw	r2,-16(fp)
    9cb8:	10c00017 	ldw	r3,0(r2)
    9cbc:	e0bffe17 	ldw	r2,-8(fp)
    9cc0:	10800117 	ldw	r2,4(r2)
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
    9cc4:	1880081e 	bne	r3,r2,9ce8 <netif_set_ipaddr+0xec>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
    9cc8:	e0bfff17 	ldw	r2,-4(fp)
    9ccc:	10000326 	beq	r2,zero,9cdc <netif_set_ipaddr+0xe0>
    9cd0:	e0bfff17 	ldw	r2,-4(fp)
    9cd4:	10800017 	ldw	r2,0(r2)
    9cd8:	00000106 	br	9ce0 <netif_set_ipaddr+0xe4>
    9cdc:	0005883a 	mov	r2,zero
    9ce0:	e0fffc17 	ldw	r3,-16(fp)
    9ce4:	18800015 	stw	r2,0(r3)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    9ce8:	e0bffc17 	ldw	r2,-16(fp)
    9cec:	10800317 	ldw	r2,12(r2)
    9cf0:	e0bffc15 	stw	r2,-16(fp)
    9cf4:	e0bffc17 	ldw	r2,-16(fp)
    9cf8:	103fe91e 	bne	r2,zero,9ca0 <netif_set_ipaddr+0xa4>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
    9cfc:	e0bfff17 	ldw	r2,-4(fp)
    9d00:	10000326 	beq	r2,zero,9d10 <netif_set_ipaddr+0x114>
    9d04:	e0bfff17 	ldw	r2,-4(fp)
    9d08:	10800017 	ldw	r2,0(r2)
    9d0c:	00000106 	br	9d14 <netif_set_ipaddr+0x118>
    9d10:	0005883a 	mov	r2,zero
    9d14:	e0fffe17 	ldw	r3,-8(fp)
    9d18:	18800115 	stw	r2,4(r3)
    netif->name[0], netif->name[1],
    ip4_addr1_16(&netif->ip_addr),
    ip4_addr2_16(&netif->ip_addr),
    ip4_addr3_16(&netif->ip_addr),
    ip4_addr4_16(&netif->ip_addr)));
}
    9d1c:	e037883a 	mov	sp,fp
    9d20:	dfc00117 	ldw	ra,4(sp)
    9d24:	df000017 	ldw	fp,0(sp)
    9d28:	dec00204 	addi	sp,sp,8
    9d2c:	f800283a 	ret

00009d30 <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, ip_addr_t *gw)
{
    9d30:	defffd04 	addi	sp,sp,-12
    9d34:	df000215 	stw	fp,8(sp)
    9d38:	df000204 	addi	fp,sp,8
    9d3c:	e13ffe15 	stw	r4,-8(fp)
    9d40:	e17fff15 	stw	r5,-4(fp)
  ip_addr_set(&(netif->gw), gw);
    9d44:	e0bfff17 	ldw	r2,-4(fp)
    9d48:	10000326 	beq	r2,zero,9d58 <netif_set_gw+0x28>
    9d4c:	e0bfff17 	ldw	r2,-4(fp)
    9d50:	10800017 	ldw	r2,0(r2)
    9d54:	00000106 	br	9d5c <netif_set_gw+0x2c>
    9d58:	0005883a 	mov	r2,zero
    9d5c:	e0fffe17 	ldw	r3,-8(fp)
    9d60:	18800315 	stw	r2,12(r3)
    netif->name[0], netif->name[1],
    ip4_addr1_16(&netif->gw),
    ip4_addr2_16(&netif->gw),
    ip4_addr3_16(&netif->gw),
    ip4_addr4_16(&netif->gw)));
}
    9d64:	e037883a 	mov	sp,fp
    9d68:	df000017 	ldw	fp,0(sp)
    9d6c:	dec00104 	addi	sp,sp,4
    9d70:	f800283a 	ret

00009d74 <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
{
    9d74:	defffd04 	addi	sp,sp,-12
    9d78:	df000215 	stw	fp,8(sp)
    9d7c:	df000204 	addi	fp,sp,8
    9d80:	e13ffe15 	stw	r4,-8(fp)
    9d84:	e17fff15 	stw	r5,-4(fp)
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
    9d88:	e0bfff17 	ldw	r2,-4(fp)
    9d8c:	10000326 	beq	r2,zero,9d9c <netif_set_netmask+0x28>
    9d90:	e0bfff17 	ldw	r2,-4(fp)
    9d94:	10800017 	ldw	r2,0(r2)
    9d98:	00000106 	br	9da0 <netif_set_netmask+0x2c>
    9d9c:	0005883a 	mov	r2,zero
    9da0:	e0fffe17 	ldw	r3,-8(fp)
    9da4:	18800215 	stw	r2,8(r3)
    netif->name[0], netif->name[1],
    ip4_addr1_16(&netif->netmask),
    ip4_addr2_16(&netif->netmask),
    ip4_addr3_16(&netif->netmask),
    ip4_addr4_16(&netif->netmask)));
}
    9da8:	e037883a 	mov	sp,fp
    9dac:	df000017 	ldw	fp,0(sp)
    9db0:	dec00104 	addi	sp,sp,4
    9db4:	f800283a 	ret

00009db8 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
    9db8:	defffe04 	addi	sp,sp,-8
    9dbc:	df000115 	stw	fp,4(sp)
    9dc0:	df000104 	addi	fp,sp,4
    9dc4:	e13fff15 	stw	r4,-4(fp)
    snmp_delete_iprteidx_tree(1, netif);
  } else {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
    9dc8:	e0bfff17 	ldw	r2,-4(fp)
    9dcc:	d0a8b815 	stw	r2,-23840(gp)
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
    9dd0:	e037883a 	mov	sp,fp
    9dd4:	df000017 	ldw	fp,0(sp)
    9dd8:	dec00104 	addi	sp,sp,4
    9ddc:	f800283a 	ret

00009de0 <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
    9de0:	defffd04 	addi	sp,sp,-12
    9de4:	dfc00215 	stw	ra,8(sp)
    9de8:	df000115 	stw	fp,4(sp)
    9dec:	df000104 	addi	fp,sp,4
    9df0:	e13fff15 	stw	r4,-4(fp)
  if (!(netif->flags & NETIF_FLAG_UP)) {
    9df4:	e0bfff17 	ldw	r2,-4(fp)
    9df8:	10800b43 	ldbu	r2,45(r2)
    9dfc:	10803fcc 	andi	r2,r2,255
    9e00:	1080004c 	andi	r2,r2,1
    9e04:	1000151e 	bne	r2,zero,9e5c <netif_set_up+0x7c>
    netif->flags |= NETIF_FLAG_UP;
    9e08:	e0bfff17 	ldw	r2,-4(fp)
    9e0c:	10800b43 	ldbu	r2,45(r2)
    9e10:	10800054 	ori	r2,r2,1
    9e14:	1007883a 	mov	r3,r2
    9e18:	e0bfff17 	ldw	r2,-4(fp)
    9e1c:	10c00b45 	stb	r3,45(r2)
    snmp_get_sysuptime(&netif->ts);
#endif /* LWIP_SNMP */

    NETIF_STATUS_CALLBACK(netif);

    if (netif->flags & NETIF_FLAG_LINK_UP) {
    9e20:	e0bfff17 	ldw	r2,-4(fp)
    9e24:	10800b43 	ldbu	r2,45(r2)
    9e28:	10803fcc 	andi	r2,r2,255
    9e2c:	1080040c 	andi	r2,r2,16
    9e30:	10000a26 	beq	r2,zero,9e5c <netif_set_up+0x7c>
#if LWIP_ARP
      /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
      if (netif->flags & (NETIF_FLAG_ETHARP)) {
    9e34:	e0bfff17 	ldw	r2,-4(fp)
    9e38:	10800b43 	ldbu	r2,45(r2)
    9e3c:	10803fcc 	andi	r2,r2,255
    9e40:	1080080c 	andi	r2,r2,32
    9e44:	10000526 	beq	r2,zero,9e5c <netif_set_up+0x7c>
        etharp_gratuitous(netif);
    9e48:	e0bfff17 	ldw	r2,-4(fp)
    9e4c:	10800104 	addi	r2,r2,4
    9e50:	e13fff17 	ldw	r4,-4(fp)
    9e54:	100b883a 	mov	r5,r2
    9e58:	0017a0c0 	call	17a0c <etharp_request>
        igmp_report_groups( netif);
      }
#endif /* LWIP_IGMP */
    }
  }
}
    9e5c:	e037883a 	mov	sp,fp
    9e60:	dfc00117 	ldw	ra,4(sp)
    9e64:	df000017 	ldw	fp,0(sp)
    9e68:	dec00204 	addi	sp,sp,8
    9e6c:	f800283a 	ret

00009e70 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
    9e70:	defffd04 	addi	sp,sp,-12
    9e74:	dfc00215 	stw	ra,8(sp)
    9e78:	df000115 	stw	fp,4(sp)
    9e7c:	df000104 	addi	fp,sp,4
    9e80:	e13fff15 	stw	r4,-4(fp)
  if (netif->flags & NETIF_FLAG_UP) {
    9e84:	e0bfff17 	ldw	r2,-4(fp)
    9e88:	10800b43 	ldbu	r2,45(r2)
    9e8c:	10803fcc 	andi	r2,r2,255
    9e90:	1080004c 	andi	r2,r2,1
    9e94:	10000e26 	beq	r2,zero,9ed0 <netif_set_down+0x60>
    netif->flags &= ~NETIF_FLAG_UP;
    9e98:	e0bfff17 	ldw	r2,-4(fp)
    9e9c:	10c00b43 	ldbu	r3,45(r2)
    9ea0:	00bfff84 	movi	r2,-2
    9ea4:	1884703a 	and	r2,r3,r2
    9ea8:	1007883a 	mov	r3,r2
    9eac:	e0bfff17 	ldw	r2,-4(fp)
    9eb0:	10c00b45 	stb	r3,45(r2)
#if LWIP_SNMP
    snmp_get_sysuptime(&netif->ts);
#endif

#if LWIP_ARP
    if (netif->flags & NETIF_FLAG_ETHARP) {
    9eb4:	e0bfff17 	ldw	r2,-4(fp)
    9eb8:	10800b43 	ldbu	r2,45(r2)
    9ebc:	10803fcc 	andi	r2,r2,255
    9ec0:	1080080c 	andi	r2,r2,32
    9ec4:	10000226 	beq	r2,zero,9ed0 <netif_set_down+0x60>
      etharp_cleanup_netif(netif);
    9ec8:	e13fff17 	ldw	r4,-4(fp)
    9ecc:	00168780 	call	16878 <etharp_cleanup_netif>
    }
#endif /* LWIP_ARP */
    NETIF_STATUS_CALLBACK(netif);
  }
}
    9ed0:	e037883a 	mov	sp,fp
    9ed4:	dfc00117 	ldw	ra,4(sp)
    9ed8:	df000017 	ldw	fp,0(sp)
    9edc:	dec00204 	addi	sp,sp,8
    9ee0:	f800283a 	ret

00009ee4 <netif_set_link_up>:

/**
 * Called by a driver when its link goes up
 */
void netif_set_link_up(struct netif *netif )
{
    9ee4:	defffd04 	addi	sp,sp,-12
    9ee8:	dfc00215 	stw	ra,8(sp)
    9eec:	df000115 	stw	fp,4(sp)
    9ef0:	df000104 	addi	fp,sp,4
    9ef4:	e13fff15 	stw	r4,-4(fp)
  if (!(netif->flags & NETIF_FLAG_LINK_UP)) {
    9ef8:	e0bfff17 	ldw	r2,-4(fp)
    9efc:	10800b43 	ldbu	r2,45(r2)
    9f00:	10803fcc 	andi	r2,r2,255
    9f04:	1080040c 	andi	r2,r2,16
    9f08:	10001a1e 	bne	r2,zero,9f74 <netif_set_link_up+0x90>
    netif->flags |= NETIF_FLAG_LINK_UP;
    9f0c:	e0bfff17 	ldw	r2,-4(fp)
    9f10:	10800b43 	ldbu	r2,45(r2)
    9f14:	10800414 	ori	r2,r2,16
    9f18:	1007883a 	mov	r3,r2
    9f1c:	e0bfff17 	ldw	r2,-4(fp)
    9f20:	10c00b45 	stb	r3,45(r2)

#if LWIP_DHCP
    if (netif->dhcp) {
    9f24:	e0bfff17 	ldw	r2,-4(fp)
    9f28:	10800817 	ldw	r2,32(r2)
    9f2c:	10000226 	beq	r2,zero,9f38 <netif_set_link_up+0x54>
      dhcp_network_changed(netif);
    9f30:	e13fff17 	ldw	r4,-4(fp)
    9f34:	0002ee80 	call	2ee8 <dhcp_network_changed>
    if (netif->autoip) {
      autoip_network_changed(netif);
    }
#endif /* LWIP_AUTOIP */

    if (netif->flags & NETIF_FLAG_UP) {
    9f38:	e0bfff17 	ldw	r2,-4(fp)
    9f3c:	10800b43 	ldbu	r2,45(r2)
    9f40:	10803fcc 	andi	r2,r2,255
    9f44:	1080004c 	andi	r2,r2,1
    9f48:	10000a26 	beq	r2,zero,9f74 <netif_set_link_up+0x90>
#if LWIP_ARP
      /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
      if (netif->flags & NETIF_FLAG_ETHARP) {
    9f4c:	e0bfff17 	ldw	r2,-4(fp)
    9f50:	10800b43 	ldbu	r2,45(r2)
    9f54:	10803fcc 	andi	r2,r2,255
    9f58:	1080080c 	andi	r2,r2,32
    9f5c:	10000526 	beq	r2,zero,9f74 <netif_set_link_up+0x90>
        etharp_gratuitous(netif);
    9f60:	e0bfff17 	ldw	r2,-4(fp)
    9f64:	10800104 	addi	r2,r2,4
    9f68:	e13fff17 	ldw	r4,-4(fp)
    9f6c:	100b883a 	mov	r5,r2
    9f70:	0017a0c0 	call	17a0c <etharp_request>
      }
#endif /* LWIP_IGMP */
    }
    NETIF_LINK_CALLBACK(netif);
  }
}
    9f74:	e037883a 	mov	sp,fp
    9f78:	dfc00117 	ldw	ra,4(sp)
    9f7c:	df000017 	ldw	fp,0(sp)
    9f80:	dec00204 	addi	sp,sp,8
    9f84:	f800283a 	ret

00009f88 <netif_set_link_down>:

/**
 * Called by a driver when its link goes down
 */
void netif_set_link_down(struct netif *netif )
{
    9f88:	defffe04 	addi	sp,sp,-8
    9f8c:	df000115 	stw	fp,4(sp)
    9f90:	df000104 	addi	fp,sp,4
    9f94:	e13fff15 	stw	r4,-4(fp)
  if (netif->flags & NETIF_FLAG_LINK_UP) {
    9f98:	e0bfff17 	ldw	r2,-4(fp)
    9f9c:	10800b43 	ldbu	r2,45(r2)
    9fa0:	10803fcc 	andi	r2,r2,255
    9fa4:	1080040c 	andi	r2,r2,16
    9fa8:	10000726 	beq	r2,zero,9fc8 <netif_set_link_down+0x40>
    netif->flags &= ~NETIF_FLAG_LINK_UP;
    9fac:	e0bfff17 	ldw	r2,-4(fp)
    9fb0:	10c00b43 	ldbu	r3,45(r2)
    9fb4:	00bffbc4 	movi	r2,-17
    9fb8:	1884703a 	and	r2,r3,r2
    9fbc:	1007883a 	mov	r3,r2
    9fc0:	e0bfff17 	ldw	r2,-4(fp)
    9fc4:	10c00b45 	stb	r3,45(r2)
    NETIF_LINK_CALLBACK(netif);
  }
}
    9fc8:	e037883a 	mov	sp,fp
    9fcc:	df000017 	ldw	fp,0(sp)
    9fd0:	dec00104 	addi	sp,sp,4
    9fd4:	f800283a 	ret

00009fd8 <pbuf_free_ooseq>:
#if !NO_SYS
static
#endif /* !NO_SYS */
void
pbuf_free_ooseq(void)
{
    9fd8:	defffd04 	addi	sp,sp,-12
    9fdc:	dfc00215 	stw	ra,8(sp)
    9fe0:	df000115 	stw	fp,4(sp)
    9fe4:	df000104 	addi	fp,sp,4
  struct tcp_pcb* pcb;
  SYS_ARCH_DECL_PROTECT(old_level);

  SYS_ARCH_PROTECT(old_level);
  pbuf_free_ooseq_pending = 0;
    9fe8:	d028b905 	stb	zero,-23836(gp)
  SYS_ARCH_UNPROTECT(old_level);

  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
    9fec:	008000f4 	movhi	r2,3
    9ff0:	109e2e04 	addi	r2,r2,30904
    9ff4:	10800017 	ldw	r2,0(r2)
    9ff8:	e0bfff15 	stw	r2,-4(fp)
    9ffc:	00000d06 	br	a034 <pbuf_free_ooseq+0x5c>
    if (NULL != pcb->ooseq) {
    a000:	e0bfff17 	ldw	r2,-4(fp)
    a004:	10801e17 	ldw	r2,120(r2)
    a008:	10000726 	beq	r2,zero,a028 <pbuf_free_ooseq+0x50>
      /** Free the ooseq pbufs of one PCB only */
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free_ooseq: freeing out-of-sequence pbufs\n"));
      tcp_segs_free(pcb->ooseq);
    a00c:	e0bfff17 	ldw	r2,-4(fp)
    a010:	10801e17 	ldw	r2,120(r2)
    a014:	1009883a 	mov	r4,r2
    a018:	000d9b80 	call	d9b8 <tcp_segs_free>
      pcb->ooseq = NULL;
    a01c:	e0bfff17 	ldw	r2,-4(fp)
    a020:	10001e15 	stw	zero,120(r2)
      return;
    a024:	00000506 	br	a03c <pbuf_free_ooseq+0x64>

  SYS_ARCH_PROTECT(old_level);
  pbuf_free_ooseq_pending = 0;
  SYS_ARCH_UNPROTECT(old_level);

  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
    a028:	e0bfff17 	ldw	r2,-4(fp)
    a02c:	10800317 	ldw	r2,12(r2)
    a030:	e0bfff15 	stw	r2,-4(fp)
    a034:	e0bfff17 	ldw	r2,-4(fp)
    a038:	103ff11e 	bne	r2,zero,a000 <pbuf_free_ooseq+0x28>
      tcp_segs_free(pcb->ooseq);
      pcb->ooseq = NULL;
      return;
    }
  }
}
    a03c:	e037883a 	mov	sp,fp
    a040:	dfc00117 	ldw	ra,4(sp)
    a044:	df000017 	ldw	fp,0(sp)
    a048:	dec00204 	addi	sp,sp,8
    a04c:	f800283a 	ret

0000a050 <pbuf_pool_is_empty>:
#endif /* !NO_SYS */

/** Queue a call to pbuf_free_ooseq if not already queued. */
static void
pbuf_pool_is_empty(void)
{
    a050:	deffff04 	addi	sp,sp,-4
    a054:	df000015 	stw	fp,0(sp)
    a058:	d839883a 	mov	fp,sp
#ifndef PBUF_POOL_FREE_OOSEQ_QUEUE_CALL
  SYS_ARCH_DECL_PROTECT(old_level);
  SYS_ARCH_PROTECT(old_level);
  pbuf_free_ooseq_pending = 1;
    a05c:	00800044 	movi	r2,1
    a060:	d0a8b905 	stb	r2,-23836(gp)
  if(!queued) {
    /* queue a call to pbuf_free_ooseq if not already queued */
    PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
  }
#endif /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
}
    a064:	e037883a 	mov	sp,fp
    a068:	df000017 	ldw	fp,0(sp)
    a06c:	dec00104 	addi	sp,sp,4
    a070:	f800283a 	ret

0000a074 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
    a074:	defff604 	addi	sp,sp,-40
    a078:	dfc00915 	stw	ra,36(sp)
    a07c:	df000815 	stw	fp,32(sp)
    a080:	df000804 	addi	fp,sp,32
    a084:	e13ffd15 	stw	r4,-12(fp)
    a088:	2805883a 	mov	r2,r5
    a08c:	e1bfff15 	stw	r6,-4(fp)
    a090:	e0bffe0d 	sth	r2,-8(fp)
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  switch (layer) {
    a094:	e0bffd17 	ldw	r2,-12(fp)
    a098:	10c00060 	cmpeqi	r3,r2,1
    a09c:	1800091e 	bne	r3,zero,a0c4 <pbuf_alloc+0x50>
    a0a0:	0080052e 	bgeu	zero,r2,a0b8 <pbuf_alloc+0x44>
    a0a4:	10c000a0 	cmpeqi	r3,r2,2
    a0a8:	1800091e 	bne	r3,zero,a0d0 <pbuf_alloc+0x5c>
    a0ac:	108000e0 	cmpeqi	r2,r2,3
    a0b0:	10000a1e 	bne	r2,zero,a0dc <pbuf_alloc+0x68>
    a0b4:	00000b06 	br	a0e4 <pbuf_alloc+0x70>
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
    a0b8:	00800d84 	movi	r2,54
    a0bc:	e0bffa0d 	sth	r2,-24(fp)
    break;
    a0c0:	00001106 	br	a108 <pbuf_alloc+0x94>
  case PBUF_IP:
    /* add room for IP layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
    a0c4:	00800884 	movi	r2,34
    a0c8:	e0bffa0d 	sth	r2,-24(fp)
    break;
    a0cc:	00000e06 	br	a108 <pbuf_alloc+0x94>
  case PBUF_LINK:
    /* add room for link layer header */
    offset = PBUF_LINK_HLEN;
    a0d0:	00800384 	movi	r2,14
    a0d4:	e0bffa0d 	sth	r2,-24(fp)
    break;
    a0d8:	00000b06 	br	a108 <pbuf_alloc+0x94>
  case PBUF_RAW:
    offset = 0;
    a0dc:	e03ffa0d 	sth	zero,-24(fp)
    break;
    a0e0:	00000906 	br	a108 <pbuf_alloc+0x94>
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    a0e4:	010000f4 	movhi	r4,3
    a0e8:	213fa804 	addi	r4,r4,-352
    a0ec:	014000f4 	movhi	r5,3
    a0f0:	297fb204 	addi	r5,r5,-312
    a0f4:	01803a04 	movi	r6,232
    a0f8:	01c000f4 	movhi	r7,3
    a0fc:	39ffb904 	addi	r7,r7,-284
    a100:	00193f00 	call	193f0 <printf>
    a104:	003fff06 	br	a104 <pbuf_alloc+0x90>
    return NULL;
  }

  switch (type) {
    a108:	e0bfff17 	ldw	r2,-4(fp)
    a10c:	10c000e8 	cmpgeui	r3,r2,3
    a110:	1800021e 	bne	r3,zero,a11c <pbuf_alloc+0xa8>
    a114:	0080fc36 	bltu	zero,r2,a508 <pbuf_alloc+0x494>
    a118:	0000c306 	br	a428 <pbuf_alloc+0x3b4>
    a11c:	108000e0 	cmpeqi	r2,r2,3
    a120:	10011026 	beq	r2,zero,a564 <pbuf_alloc+0x4f0>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
    p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
    a124:	01000204 	movi	r4,8
    a128:	00095f80 	call	95f8 <memp_malloc>
    a12c:	e0bff815 	stw	r2,-32(fp)
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
    a130:	e0bff817 	ldw	r2,-32(fp)
    a134:	1000031e 	bne	r2,zero,a144 <pbuf_alloc+0xd0>
      PBUF_POOL_IS_EMPTY();
    a138:	000a0500 	call	a050 <pbuf_pool_is_empty>
      return NULL;
    a13c:	0005883a 	mov	r2,zero
    a140:	00011806 	br	a5a4 <pbuf_alloc+0x530>
    }
    p->type = type;
    a144:	e0bfff17 	ldw	r2,-4(fp)
    a148:	1007883a 	mov	r3,r2
    a14c:	e0bff817 	ldw	r2,-32(fp)
    a150:	10c00305 	stb	r3,12(r2)
    p->next = NULL;
    a154:	e0bff817 	ldw	r2,-32(fp)
    a158:	10000015 	stw	zero,0(r2)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
    a15c:	e0bffa0b 	ldhu	r2,-24(fp)
    a160:	10800404 	addi	r2,r2,16
    a164:	e0fff817 	ldw	r3,-32(fp)
    a168:	1885883a 	add	r2,r3,r2
    a16c:	10c000c4 	addi	r3,r2,3
    a170:	00bfff04 	movi	r2,-4
    a174:	1884703a 	and	r2,r3,r2
    a178:	1007883a 	mov	r3,r2
    a17c:	e0bff817 	ldw	r2,-32(fp)
    a180:	10c00115 	stw	r3,4(r2)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
    a184:	e0bff817 	ldw	r2,-32(fp)
    a188:	10800117 	ldw	r2,4(r2)
    a18c:	108000cc 	andi	r2,r2,3
    a190:	10000926 	beq	r2,zero,a1b8 <pbuf_alloc+0x144>
    a194:	010000f4 	movhi	r4,3
    a198:	213fa804 	addi	r4,r4,-352
    a19c:	014000f4 	movhi	r5,3
    a1a0:	297fbf04 	addi	r5,r5,-260
    a1a4:	01803ec4 	movi	r6,251
    a1a8:	01c000f4 	movhi	r7,3
    a1ac:	39ffb904 	addi	r7,r7,-284
    a1b0:	00193f00 	call	193f0 <printf>
    a1b4:	003fff06 	br	a1b4 <pbuf_alloc+0x140>
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
    a1b8:	e0bff817 	ldw	r2,-32(fp)
    a1bc:	e0fffe0b 	ldhu	r3,-8(fp)
    a1c0:	10c0020d 	sth	r3,8(r2)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
    a1c4:	e0bffa0b 	ldhu	r2,-24(fp)
    a1c8:	10c000c4 	addi	r3,r2,3
    a1cc:	00bfff04 	movi	r2,-4
    a1d0:	1884703a 	and	r2,r3,r2
    a1d4:	00c17b04 	movi	r3,1516
    a1d8:	1885c83a 	sub	r2,r3,r2
    a1dc:	e0fffe0b 	ldhu	r3,-8(fp)
    a1e0:	1880010e 	bge	r3,r2,a1e8 <pbuf_alloc+0x174>
    a1e4:	1805883a 	mov	r2,r3
    a1e8:	1007883a 	mov	r3,r2
    a1ec:	e0bff817 	ldw	r2,-32(fp)
    a1f0:	10c0028d 	sth	r3,10(r2)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
    a1f4:	e0bff817 	ldw	r2,-32(fp)
    a1f8:	10c00117 	ldw	r3,4(r2)
    a1fc:	e0bff817 	ldw	r2,-32(fp)
    a200:	1080028b 	ldhu	r2,10(r2)
    a204:	10bfffcc 	andi	r2,r2,65535
    a208:	1885883a 	add	r2,r3,r2
    a20c:	e0fff817 	ldw	r3,-32(fp)
    a210:	18c17f04 	addi	r3,r3,1532
    a214:	1880092e 	bgeu	r3,r2,a23c <pbuf_alloc+0x1c8>
    a218:	010000f4 	movhi	r4,3
    a21c:	213fa804 	addi	r4,r4,-352
    a220:	014000f4 	movhi	r5,3
    a224:	297fcb04 	addi	r5,r5,-212
    a228:	01804084 	movi	r6,258
    a22c:	01c000f4 	movhi	r7,3
    a230:	39ffb904 	addi	r7,r7,-284
    a234:	00193f00 	call	193f0 <printf>
    a238:	003fff06 	br	a238 <pbuf_alloc+0x1c4>
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
    a23c:	e0bffa0b 	ldhu	r2,-24(fp)
    a240:	10c000c4 	addi	r3,r2,3
    a244:	00bfff04 	movi	r2,-4
    a248:	1884703a 	and	r2,r3,r2
    a24c:	00c17b04 	movi	r3,1516
    a250:	1885c83a 	sub	r2,r3,r2
    a254:	00800916 	blt	zero,r2,a27c <pbuf_alloc+0x208>
    a258:	010000f4 	movhi	r4,3
    a25c:	213fa804 	addi	r4,r4,-352
    a260:	014000f4 	movhi	r5,3
    a264:	297fd804 	addi	r5,r5,-160
    a268:	01804104 	movi	r6,260
    a26c:	01c000f4 	movhi	r7,3
    a270:	39ffb904 	addi	r7,r7,-284
    a274:	00193f00 	call	193f0 <printf>
    a278:	003fff06 	br	a278 <pbuf_alloc+0x204>
      (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
    a27c:	e0bff817 	ldw	r2,-32(fp)
    a280:	00c00044 	movi	r3,1
    a284:	10c0038d 	sth	r3,14(r2)

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
    a288:	e0bff817 	ldw	r2,-32(fp)
    a28c:	e0bff915 	stw	r2,-28(fp)
    /* remaining length to be allocated */
    rem_len = length - p->len;
    a290:	e0fffe0b 	ldhu	r3,-8(fp)
    a294:	e0bff817 	ldw	r2,-32(fp)
    a298:	1080028b 	ldhu	r2,10(r2)
    a29c:	10bfffcc 	andi	r2,r2,65535
    a2a0:	1885c83a 	sub	r2,r3,r2
    a2a4:	e0bffb15 	stw	r2,-20(fp)
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
    a2a8:	00005c06 	br	a41c <pbuf_alloc+0x3a8>
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
    a2ac:	01000204 	movi	r4,8
    a2b0:	00095f80 	call	95f8 <memp_malloc>
    a2b4:	e0bffc15 	stw	r2,-16(fp)
      if (q == NULL) {
    a2b8:	e0bffc17 	ldw	r2,-16(fp)
    a2bc:	1000051e 	bne	r2,zero,a2d4 <pbuf_alloc+0x260>
        PBUF_POOL_IS_EMPTY();
    a2c0:	000a0500 	call	a050 <pbuf_pool_is_empty>
        /* free chain so far allocated */
        pbuf_free(p);
    a2c4:	e13ff817 	ldw	r4,-32(fp)
    a2c8:	000aa340 	call	aa34 <pbuf_free>
        /* bail out unsuccesfully */
        return NULL;
    a2cc:	0005883a 	mov	r2,zero
    a2d0:	0000b406 	br	a5a4 <pbuf_alloc+0x530>
      }
      q->type = type;
    a2d4:	e0bfff17 	ldw	r2,-4(fp)
    a2d8:	1007883a 	mov	r3,r2
    a2dc:	e0bffc17 	ldw	r2,-16(fp)
    a2e0:	10c00305 	stb	r3,12(r2)
      q->flags = 0;
    a2e4:	e0bffc17 	ldw	r2,-16(fp)
    a2e8:	10000345 	stb	zero,13(r2)
      q->next = NULL;
    a2ec:	e0bffc17 	ldw	r2,-16(fp)
    a2f0:	10000015 	stw	zero,0(r2)
      /* make previous pbuf point to this pbuf */
      r->next = q;
    a2f4:	e0bff917 	ldw	r2,-28(fp)
    a2f8:	e0fffc17 	ldw	r3,-16(fp)
    a2fc:	10c00015 	stw	r3,0(r2)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
    a300:	e0bffb17 	ldw	r2,-20(fp)
    a304:	00ffff94 	movui	r3,65534
    a308:	1880090e 	bge	r3,r2,a330 <pbuf_alloc+0x2bc>
    a30c:	010000f4 	movhi	r4,3
    a310:	213fa804 	addi	r4,r4,-352
    a314:	014000f4 	movhi	r5,3
    a318:	297fe504 	addi	r5,r5,-108
    a31c:	01804784 	movi	r6,286
    a320:	01c000f4 	movhi	r7,3
    a324:	39ffb904 	addi	r7,r7,-284
    a328:	00193f00 	call	193f0 <printf>
    a32c:	003fff06 	br	a32c <pbuf_alloc+0x2b8>
      q->tot_len = (u16_t)rem_len;
    a330:	e0bffb17 	ldw	r2,-20(fp)
    a334:	1007883a 	mov	r3,r2
    a338:	e0bffc17 	ldw	r2,-16(fp)
    a33c:	10c0020d 	sth	r3,8(r2)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
    a340:	e0bffb17 	ldw	r2,-20(fp)
    a344:	10bfffcc 	andi	r2,r2,65535
    a348:	10817b28 	cmpgeui	r2,r2,1516
    a34c:	1000021e 	bne	r2,zero,a358 <pbuf_alloc+0x2e4>
    a350:	e0bffb17 	ldw	r2,-20(fp)
    a354:	00000106 	br	a35c <pbuf_alloc+0x2e8>
    a358:	00817b04 	movi	r2,1516
    a35c:	e0fffc17 	ldw	r3,-16(fp)
    a360:	1880028d 	sth	r2,10(r3)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
    a364:	e0bffc17 	ldw	r2,-16(fp)
    a368:	10c00404 	addi	r3,r2,16
    a36c:	e0bffc17 	ldw	r2,-16(fp)
    a370:	10c00115 	stw	r3,4(r2)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
    a374:	e0bffc17 	ldw	r2,-16(fp)
    a378:	10800117 	ldw	r2,4(r2)
    a37c:	108000cc 	andi	r2,r2,3
    a380:	10000926 	beq	r2,zero,a3a8 <pbuf_alloc+0x334>
    a384:	010000f4 	movhi	r4,3
    a388:	213fa804 	addi	r4,r4,-352
    a38c:	014000f4 	movhi	r5,3
    a390:	297fea04 	addi	r5,r5,-88
    a394:	01804904 	movi	r6,292
    a398:	01c000f4 	movhi	r7,3
    a39c:	39ffb904 	addi	r7,r7,-284
    a3a0:	00193f00 	call	193f0 <printf>
    a3a4:	003fff06 	br	a3a4 <pbuf_alloc+0x330>
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
    a3a8:	e0bff817 	ldw	r2,-32(fp)
    a3ac:	10c00117 	ldw	r3,4(r2)
    a3b0:	e0bff817 	ldw	r2,-32(fp)
    a3b4:	1080028b 	ldhu	r2,10(r2)
    a3b8:	10bfffcc 	andi	r2,r2,65535
    a3bc:	1885883a 	add	r2,r3,r2
    a3c0:	e0fff817 	ldw	r3,-32(fp)
    a3c4:	18c17f04 	addi	r3,r3,1532
    a3c8:	1880092e 	bgeu	r3,r2,a3f0 <pbuf_alloc+0x37c>
    a3cc:	010000f4 	movhi	r4,3
    a3d0:	213fa804 	addi	r4,r4,-352
    a3d4:	014000f4 	movhi	r5,3
    a3d8:	297fcb04 	addi	r5,r5,-212
    a3dc:	018049c4 	movi	r6,295
    a3e0:	01c000f4 	movhi	r7,3
    a3e4:	39ffb904 	addi	r7,r7,-284
    a3e8:	00193f00 	call	193f0 <printf>
    a3ec:	003fff06 	br	a3ec <pbuf_alloc+0x378>
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
    a3f0:	e0bffc17 	ldw	r2,-16(fp)
    a3f4:	00c00044 	movi	r3,1
    a3f8:	10c0038d 	sth	r3,14(r2)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
    a3fc:	e0bffc17 	ldw	r2,-16(fp)
    a400:	1080028b 	ldhu	r2,10(r2)
    a404:	10bfffcc 	andi	r2,r2,65535
    a408:	e0fffb17 	ldw	r3,-20(fp)
    a40c:	1885c83a 	sub	r2,r3,r2
    a410:	e0bffb15 	stw	r2,-20(fp)
      /* remember this pbuf for linkage in next iteration */
      r = q;
    a414:	e0bffc17 	ldw	r2,-16(fp)
    a418:	e0bff915 	stw	r2,-28(fp)
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
    a41c:	e0bffb17 	ldw	r2,-20(fp)
    a420:	00bfa216 	blt	zero,r2,a2ac <pbuf_alloc+0x238>
      r = q;
    }
    /* end of chain */
    /*r->next = NULL;*/

    break;
    a424:	00005906 	br	a58c <pbuf_alloc+0x518>
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
    a428:	e0bffa0b 	ldhu	r2,-24(fp)
    a42c:	108004c4 	addi	r2,r2,19
    a430:	1007883a 	mov	r3,r2
    a434:	00bfff04 	movi	r2,-4
    a438:	1884703a 	and	r2,r3,r2
    a43c:	1007883a 	mov	r3,r2
    a440:	e0bffe0b 	ldhu	r2,-8(fp)
    a444:	108000c4 	addi	r2,r2,3
    a448:	1009883a 	mov	r4,r2
    a44c:	00bfff04 	movi	r2,-4
    a450:	2084703a 	and	r2,r4,r2
    a454:	1885883a 	add	r2,r3,r2
    a458:	10bfffcc 	andi	r2,r2,65535
    a45c:	1009883a 	mov	r4,r2
    a460:	0008fcc0 	call	8fcc <mem_malloc>
    a464:	e0bff815 	stw	r2,-32(fp)
    if (p == NULL) {
    a468:	e0bff817 	ldw	r2,-32(fp)
    a46c:	1000021e 	bne	r2,zero,a478 <pbuf_alloc+0x404>
      return NULL;
    a470:	0005883a 	mov	r2,zero
    a474:	00004b06 	br	a5a4 <pbuf_alloc+0x530>
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
    a478:	e0bffa0b 	ldhu	r2,-24(fp)
    a47c:	10800404 	addi	r2,r2,16
    a480:	e0fff817 	ldw	r3,-32(fp)
    a484:	1885883a 	add	r2,r3,r2
    a488:	10c000c4 	addi	r3,r2,3
    a48c:	00bfff04 	movi	r2,-4
    a490:	1884703a 	and	r2,r3,r2
    a494:	1007883a 	mov	r3,r2
    a498:	e0bff817 	ldw	r2,-32(fp)
    a49c:	10c00115 	stw	r3,4(r2)
    p->len = p->tot_len = length;
    a4a0:	e0bff817 	ldw	r2,-32(fp)
    a4a4:	e0fffe0b 	ldhu	r3,-8(fp)
    a4a8:	10c0020d 	sth	r3,8(r2)
    a4ac:	e0bff817 	ldw	r2,-32(fp)
    a4b0:	10c0020b 	ldhu	r3,8(r2)
    a4b4:	e0bff817 	ldw	r2,-32(fp)
    a4b8:	10c0028d 	sth	r3,10(r2)
    p->next = NULL;
    a4bc:	e0bff817 	ldw	r2,-32(fp)
    a4c0:	10000015 	stw	zero,0(r2)
    p->type = type;
    a4c4:	e0bfff17 	ldw	r2,-4(fp)
    a4c8:	1007883a 	mov	r3,r2
    a4cc:	e0bff817 	ldw	r2,-32(fp)
    a4d0:	10c00305 	stb	r3,12(r2)

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
    a4d4:	e0bff817 	ldw	r2,-32(fp)
    a4d8:	10800117 	ldw	r2,4(r2)
    a4dc:	108000cc 	andi	r2,r2,3
    a4e0:	10002926 	beq	r2,zero,a588 <pbuf_alloc+0x514>
    a4e4:	010000f4 	movhi	r4,3
    a4e8:	213fa804 	addi	r4,r4,-352
    a4ec:	014000f4 	movhi	r5,3
    a4f0:	297ff604 	addi	r5,r5,-40
    a4f4:	01804fc4 	movi	r6,319
    a4f8:	01c000f4 	movhi	r7,3
    a4fc:	39ffb904 	addi	r7,r7,-284
    a500:	00193f00 	call	193f0 <printf>
    a504:	003fff06 	br	a504 <pbuf_alloc+0x490>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = (struct pbuf *)memp_malloc(MEMP_PBUF);
    a508:	010001c4 	movi	r4,7
    a50c:	00095f80 	call	95f8 <memp_malloc>
    a510:	e0bff815 	stw	r2,-32(fp)
    if (p == NULL) {
    a514:	e0bff817 	ldw	r2,-32(fp)
    a518:	1000021e 	bne	r2,zero,a524 <pbuf_alloc+0x4b0>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                  ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    a51c:	0005883a 	mov	r2,zero
    a520:	00002006 	br	a5a4 <pbuf_alloc+0x530>
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
    a524:	e0bff817 	ldw	r2,-32(fp)
    a528:	10000115 	stw	zero,4(r2)
    p->len = p->tot_len = length;
    a52c:	e0bff817 	ldw	r2,-32(fp)
    a530:	e0fffe0b 	ldhu	r3,-8(fp)
    a534:	10c0020d 	sth	r3,8(r2)
    a538:	e0bff817 	ldw	r2,-32(fp)
    a53c:	10c0020b 	ldhu	r3,8(r2)
    a540:	e0bff817 	ldw	r2,-32(fp)
    a544:	10c0028d 	sth	r3,10(r2)
    p->next = NULL;
    a548:	e0bff817 	ldw	r2,-32(fp)
    a54c:	10000015 	stw	zero,0(r2)
    p->type = type;
    a550:	e0bfff17 	ldw	r2,-4(fp)
    a554:	1007883a 	mov	r3,r2
    a558:	e0bff817 	ldw	r2,-32(fp)
    a55c:	10c00305 	stb	r3,12(r2)
    break;
    a560:	00000a06 	br	a58c <pbuf_alloc+0x518>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
    a564:	010000f4 	movhi	r4,3
    a568:	213fa804 	addi	r4,r4,-352
    a56c:	014000f4 	movhi	r5,3
    a570:	29400104 	addi	r5,r5,4
    a574:	01805504 	movi	r6,340
    a578:	01c000f4 	movhi	r7,3
    a57c:	39ffb904 	addi	r7,r7,-284
    a580:	00193f00 	call	193f0 <printf>
    a584:	003fff06 	br	a584 <pbuf_alloc+0x510>
    p->next = NULL;
    p->type = type;

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
           ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    break;
    a588:	0001883a 	nop
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
    a58c:	e0bff817 	ldw	r2,-32(fp)
    a590:	00c00044 	movi	r3,1
    a594:	10c0038d 	sth	r3,14(r2)
  /* set flags */
  p->flags = 0;
    a598:	e0bff817 	ldw	r2,-32(fp)
    a59c:	10000345 	stb	zero,13(r2)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
    a5a0:	e0bff817 	ldw	r2,-32(fp)
}
    a5a4:	e037883a 	mov	sp,fp
    a5a8:	dfc00117 	ldw	ra,4(sp)
    a5ac:	df000017 	ldw	fp,0(sp)
    a5b0:	dec00204 	addi	sp,sp,8
    a5b4:	f800283a 	ret

0000a5b8 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
    a5b8:	defff904 	addi	sp,sp,-28
    a5bc:	dfc00615 	stw	ra,24(sp)
    a5c0:	df000515 	stw	fp,20(sp)
    a5c4:	df000504 	addi	fp,sp,20
    a5c8:	e13ffe15 	stw	r4,-8(fp)
    a5cc:	2805883a 	mov	r2,r5
    a5d0:	e0bfff0d 	sth	r2,-4(fp)
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
    a5d4:	e0bffe17 	ldw	r2,-8(fp)
    a5d8:	1000091e 	bne	r2,zero,a600 <pbuf_realloc+0x48>
    a5dc:	010000f4 	movhi	r4,3
    a5e0:	213fa804 	addi	r4,r4,-352
    a5e4:	014000f4 	movhi	r5,3
    a5e8:	29400804 	addi	r5,r5,32
    a5ec:	01806d04 	movi	r6,436
    a5f0:	01c000f4 	movhi	r7,3
    a5f4:	39ffb904 	addi	r7,r7,-284
    a5f8:	00193f00 	call	193f0 <printf>
    a5fc:	003fff06 	br	a5fc <pbuf_realloc+0x44>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
    a600:	e0bffe17 	ldw	r2,-8(fp)
    a604:	10800303 	ldbu	r2,12(r2)
    a608:	10803fcc 	andi	r2,r2,255
    a60c:	108000e0 	cmpeqi	r2,r2,3
    a610:	1000171e 	bne	r2,zero,a670 <pbuf_realloc+0xb8>
    a614:	e0bffe17 	ldw	r2,-8(fp)
    a618:	10800303 	ldbu	r2,12(r2)
    a61c:	10803fcc 	andi	r2,r2,255
    a620:	10800060 	cmpeqi	r2,r2,1
    a624:	1000121e 	bne	r2,zero,a670 <pbuf_realloc+0xb8>
    a628:	e0bffe17 	ldw	r2,-8(fp)
    a62c:	10800303 	ldbu	r2,12(r2)
    a630:	10803fcc 	andi	r2,r2,255
    a634:	10000e26 	beq	r2,zero,a670 <pbuf_realloc+0xb8>
    a638:	e0bffe17 	ldw	r2,-8(fp)
    a63c:	10800303 	ldbu	r2,12(r2)
    a640:	10803fcc 	andi	r2,r2,255
    a644:	108000a0 	cmpeqi	r2,r2,2
    a648:	1000091e 	bne	r2,zero,a670 <pbuf_realloc+0xb8>
    a64c:	010000f4 	movhi	r4,3
    a650:	213fa804 	addi	r4,r4,-352
    a654:	014000f4 	movhi	r5,3
    a658:	29400e04 	addi	r5,r5,56
    a65c:	01806e04 	movi	r6,440
    a660:	01c000f4 	movhi	r7,3
    a664:	39ffb904 	addi	r7,r7,-284
    a668:	00193f00 	call	193f0 <printf>
    a66c:	003fff06 	br	a66c <pbuf_realloc+0xb4>
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
    a670:	e0bffe17 	ldw	r2,-8(fp)
    a674:	1080020b 	ldhu	r2,8(r2)
    a678:	10bfffcc 	andi	r2,r2,65535
    a67c:	e0ffff0b 	ldhu	r3,-4(fp)
    a680:	1880682e 	bgeu	r3,r2,a824 <pbuf_realloc+0x26c>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
    a684:	e0ffff0b 	ldhu	r3,-4(fp)
    a688:	e0bffe17 	ldw	r2,-8(fp)
    a68c:	1080020b 	ldhu	r2,8(r2)
    a690:	10bfffcc 	andi	r2,r2,65535
    a694:	1885c83a 	sub	r2,r3,r2
    a698:	e0bffd15 	stw	r2,-12(fp)

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
    a69c:	e0bfff0b 	ldhu	r2,-4(fp)
    a6a0:	e0bffc0d 	sth	r2,-16(fp)
  q = p;
    a6a4:	e0bffe17 	ldw	r2,-8(fp)
    a6a8:	e0bffb15 	stw	r2,-20(fp)
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
    a6ac:	00002606 	br	a748 <pbuf_realloc+0x190>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
    a6b0:	e0bffb17 	ldw	r2,-20(fp)
    a6b4:	1080028b 	ldhu	r2,10(r2)
    a6b8:	e0fffc0b 	ldhu	r3,-16(fp)
    a6bc:	1885c83a 	sub	r2,r3,r2
    a6c0:	e0bffc0d 	sth	r2,-16(fp)
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
    a6c4:	e0bffd17 	ldw	r2,-12(fp)
    a6c8:	00ffff94 	movui	r3,65534
    a6cc:	1880090e 	bge	r3,r2,a6f4 <pbuf_realloc+0x13c>
    a6d0:	010000f4 	movhi	r4,3
    a6d4:	213fa804 	addi	r4,r4,-352
    a6d8:	014000f4 	movhi	r5,3
    a6dc:	29401504 	addi	r5,r5,84
    a6e0:	01807304 	movi	r6,460
    a6e4:	01c000f4 	movhi	r7,3
    a6e8:	39ffb904 	addi	r7,r7,-284
    a6ec:	00193f00 	call	193f0 <printf>
    a6f0:	003fff06 	br	a6f0 <pbuf_realloc+0x138>
    q->tot_len += (u16_t)grow;
    a6f4:	e0bffb17 	ldw	r2,-20(fp)
    a6f8:	10c0020b 	ldhu	r3,8(r2)
    a6fc:	e0bffd17 	ldw	r2,-12(fp)
    a700:	1885883a 	add	r2,r3,r2
    a704:	1007883a 	mov	r3,r2
    a708:	e0bffb17 	ldw	r2,-20(fp)
    a70c:	10c0020d 	sth	r3,8(r2)
    /* proceed to next pbuf in chain */
    q = q->next;
    a710:	e0bffb17 	ldw	r2,-20(fp)
    a714:	10800017 	ldw	r2,0(r2)
    a718:	e0bffb15 	stw	r2,-20(fp)
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
    a71c:	e0bffb17 	ldw	r2,-20(fp)
    a720:	1000091e 	bne	r2,zero,a748 <pbuf_realloc+0x190>
    a724:	010000f4 	movhi	r4,3
    a728:	213fa804 	addi	r4,r4,-352
    a72c:	014000f4 	movhi	r5,3
    a730:	29401a04 	addi	r5,r5,104
    a734:	01807404 	movi	r6,464
    a738:	01c000f4 	movhi	r7,3
    a73c:	39ffb904 	addi	r7,r7,-284
    a740:	00193f00 	call	193f0 <printf>
    a744:	003fff06 	br	a744 <pbuf_realloc+0x18c>

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
    a748:	e0bffb17 	ldw	r2,-20(fp)
    a74c:	1080028b 	ldhu	r2,10(r2)
    a750:	10ffffcc 	andi	r3,r2,65535
    a754:	e0bffc0b 	ldhu	r2,-16(fp)
    a758:	18bfd536 	bltu	r3,r2,a6b0 <pbuf_realloc+0xf8>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
    a75c:	e0bffb17 	ldw	r2,-20(fp)
    a760:	10800303 	ldbu	r2,12(r2)
    a764:	10803fcc 	andi	r2,r2,255
    a768:	10001d1e 	bne	r2,zero,a7e0 <pbuf_realloc+0x228>
    a76c:	e0bffb17 	ldw	r2,-20(fp)
    a770:	1080028b 	ldhu	r2,10(r2)
    a774:	10ffffcc 	andi	r3,r2,65535
    a778:	e0bffc0b 	ldhu	r2,-16(fp)
    a77c:	18801826 	beq	r3,r2,a7e0 <pbuf_realloc+0x228>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
    a780:	e0bffb17 	ldw	r2,-20(fp)
    a784:	10800117 	ldw	r2,4(r2)
    a788:	1007883a 	mov	r3,r2
    a78c:	e0bffb17 	ldw	r2,-20(fp)
    a790:	1885c83a 	sub	r2,r3,r2
    a794:	1007883a 	mov	r3,r2
    a798:	e0bffc0b 	ldhu	r2,-16(fp)
    a79c:	1885883a 	add	r2,r3,r2
    a7a0:	10bfffcc 	andi	r2,r2,65535
    a7a4:	e13ffb17 	ldw	r4,-20(fp)
    a7a8:	100b883a 	mov	r5,r2
    a7ac:	0008c7c0 	call	8c7c <mem_trim>
    a7b0:	e0bffb15 	stw	r2,-20(fp)
    LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
    a7b4:	e0bffb17 	ldw	r2,-20(fp)
    a7b8:	1000091e 	bne	r2,zero,a7e0 <pbuf_realloc+0x228>
    a7bc:	010000f4 	movhi	r4,3
    a7c0:	213fa804 	addi	r4,r4,-352
    a7c4:	014000f4 	movhi	r5,3
    a7c8:	29402004 	addi	r5,r5,128
    a7cc:	01807684 	movi	r6,474
    a7d0:	01c000f4 	movhi	r7,3
    a7d4:	39ffb904 	addi	r7,r7,-284
    a7d8:	00193f00 	call	193f0 <printf>
    a7dc:	003fff06 	br	a7dc <pbuf_realloc+0x224>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
    a7e0:	e0bffb17 	ldw	r2,-20(fp)
    a7e4:	e0fffc0b 	ldhu	r3,-16(fp)
    a7e8:	10c0028d 	sth	r3,10(r2)
  q->tot_len = q->len;
    a7ec:	e0bffb17 	ldw	r2,-20(fp)
    a7f0:	10c0028b 	ldhu	r3,10(r2)
    a7f4:	e0bffb17 	ldw	r2,-20(fp)
    a7f8:	10c0020d 	sth	r3,8(r2)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
    a7fc:	e0bffb17 	ldw	r2,-20(fp)
    a800:	10800017 	ldw	r2,0(r2)
    a804:	10000426 	beq	r2,zero,a818 <pbuf_realloc+0x260>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
    a808:	e0bffb17 	ldw	r2,-20(fp)
    a80c:	10800017 	ldw	r2,0(r2)
    a810:	1009883a 	mov	r4,r2
    a814:	000aa340 	call	aa34 <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
    a818:	e0bffb17 	ldw	r2,-20(fp)
    a81c:	10000015 	stw	zero,0(r2)
    a820:	00000106 	br	a828 <pbuf_realloc+0x270>
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
    /* enlarging not yet supported */
    return;
    a824:	0001883a 	nop
    pbuf_free(q->next);
  }
  /* q is last packet in chain */
  q->next = NULL;

}
    a828:	e037883a 	mov	sp,fp
    a82c:	dfc00117 	ldw	ra,4(sp)
    a830:	df000017 	ldw	fp,0(sp)
    a834:	dec00204 	addi	sp,sp,8
    a838:	f800283a 	ret

0000a83c <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
    a83c:	defffa04 	addi	sp,sp,-24
    a840:	dfc00515 	stw	ra,20(sp)
    a844:	df000415 	stw	fp,16(sp)
    a848:	df000404 	addi	fp,sp,16
    a84c:	e13ffe15 	stw	r4,-8(fp)
    a850:	2805883a 	mov	r2,r5
    a854:	e0bfff0d 	sth	r2,-4(fp)
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
    a858:	e0bffe17 	ldw	r2,-8(fp)
    a85c:	1000091e 	bne	r2,zero,a884 <pbuf_header+0x48>
    a860:	010000f4 	movhi	r4,3
    a864:	213fa804 	addi	r4,r4,-352
    a868:	014000f4 	movhi	r5,3
    a86c:	29402704 	addi	r5,r5,156
    a870:	01808144 	movi	r6,517
    a874:	01c000f4 	movhi	r7,3
    a878:	39ffb904 	addi	r7,r7,-284
    a87c:	00193f00 	call	193f0 <printf>
    a880:	003fff06 	br	a880 <pbuf_header+0x44>
  if ((header_size_increment == 0) || (p == NULL)) {
    a884:	e0bfff0f 	ldh	r2,-4(fp)
    a888:	10000226 	beq	r2,zero,a894 <pbuf_header+0x58>
    a88c:	e0bffe17 	ldw	r2,-8(fp)
    a890:	1000021e 	bne	r2,zero,a89c <pbuf_header+0x60>
    return 0;
    a894:	0005883a 	mov	r2,zero
    a898:	00006106 	br	aa20 <pbuf_header+0x1e4>
  }
 
  if (header_size_increment < 0){
    a89c:	e0bfff0f 	ldh	r2,-4(fp)
    a8a0:	1000110e 	bge	r2,zero,a8e8 <pbuf_header+0xac>
    increment_magnitude = -header_size_increment;
    a8a4:	e0bfff0b 	ldhu	r2,-4(fp)
    a8a8:	0085c83a 	sub	r2,zero,r2
    a8ac:	e0bffc0d 	sth	r2,-16(fp)
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
    a8b0:	e0bffe17 	ldw	r2,-8(fp)
    a8b4:	1080028b 	ldhu	r2,10(r2)
    a8b8:	10ffffcc 	andi	r3,r2,65535
    a8bc:	e0bffc0b 	ldhu	r2,-16(fp)
    a8c0:	18800b2e 	bgeu	r3,r2,a8f0 <pbuf_header+0xb4>
    a8c4:	010000f4 	movhi	r4,3
    a8c8:	213fa804 	addi	r4,r4,-352
    a8cc:	014000f4 	movhi	r5,3
    a8d0:	29402a04 	addi	r5,r5,168
    a8d4:	01808344 	movi	r6,525
    a8d8:	01c000f4 	movhi	r7,3
    a8dc:	39ffb904 	addi	r7,r7,-284
    a8e0:	00193f00 	call	193f0 <printf>
    a8e4:	003fff06 	br	a8e4 <pbuf_header+0xa8>
  } else {
    increment_magnitude = header_size_increment;
    a8e8:	e0bfff0b 	ldhu	r2,-4(fp)
    a8ec:	e0bffc0d 	sth	r2,-16(fp)
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
    a8f0:	e0bffe17 	ldw	r2,-8(fp)
    a8f4:	10800303 	ldbu	r2,12(r2)
    a8f8:	10803fcc 	andi	r2,r2,255
    a8fc:	e0bffc8d 	sth	r2,-14(fp)
  /* remember current payload pointer */
  payload = p->payload;
    a900:	e0bffe17 	ldw	r2,-8(fp)
    a904:	10800117 	ldw	r2,4(r2)
    a908:	e0bffd15 	stw	r2,-12(fp)

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    a90c:	e0bffc8b 	ldhu	r2,-14(fp)
    a910:	10000326 	beq	r2,zero,a920 <pbuf_header+0xe4>
    a914:	e0bffc8b 	ldhu	r2,-14(fp)
    a918:	108000d8 	cmpnei	r2,r2,3
    a91c:	1000111e 	bne	r2,zero,a964 <pbuf_header+0x128>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
    a920:	e0bffe17 	ldw	r2,-8(fp)
    a924:	10c00117 	ldw	r3,4(r2)
    a928:	e0bfff0f 	ldh	r2,-4(fp)
    a92c:	0085c83a 	sub	r2,zero,r2
    a930:	1887883a 	add	r3,r3,r2
    a934:	e0bffe17 	ldw	r2,-8(fp)
    a938:	10c00115 	stw	r3,4(r2)
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
    a93c:	e0bffe17 	ldw	r2,-8(fp)
    a940:	10c00117 	ldw	r3,4(r2)
    a944:	e0bffe17 	ldw	r2,-8(fp)
    a948:	10800404 	addi	r2,r2,16
    a94c:	1880252e 	bgeu	r3,r2,a9e4 <pbuf_header+0x1a8>
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload, (void *)(p + 1)));
      /* restore old payload pointer */
      p->payload = payload;
    a950:	e0bffe17 	ldw	r2,-8(fp)
    a954:	e0fffd17 	ldw	r3,-12(fp)
    a958:	10c00115 	stw	r3,4(r2)
      /* bail out unsuccesfully */
      return 1;
    a95c:	00800044 	movi	r2,1
    a960:	00002f06 	br	aa20 <pbuf_header+0x1e4>
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    a964:	e0bffc8b 	ldhu	r2,-14(fp)
    a968:	108000a0 	cmpeqi	r2,r2,2
    a96c:	1000031e 	bne	r2,zero,a97c <pbuf_header+0x140>
    a970:	e0bffc8b 	ldhu	r2,-14(fp)
    a974:	10800058 	cmpnei	r2,r2,1
    a978:	1000111e 	bne	r2,zero,a9c0 <pbuf_header+0x184>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
    a97c:	e0bfff0f 	ldh	r2,-4(fp)
    a980:	10000d0e 	bge	r2,zero,a9b8 <pbuf_header+0x17c>
    a984:	e0bffe17 	ldw	r2,-8(fp)
    a988:	1080028b 	ldhu	r2,10(r2)
    a98c:	10ffffcc 	andi	r3,r2,65535
    a990:	e0bffc0b 	ldhu	r2,-16(fp)
    a994:	18800836 	bltu	r3,r2,a9b8 <pbuf_header+0x17c>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    a998:	e0bffe17 	ldw	r2,-8(fp)
    a99c:	10c00117 	ldw	r3,4(r2)
    a9a0:	e0bfff0f 	ldh	r2,-4(fp)
    a9a4:	0085c83a 	sub	r2,zero,r2
    a9a8:	1887883a 	add	r3,r3,r2
    a9ac:	e0bffe17 	ldw	r2,-8(fp)
    a9b0:	10c00115 	stw	r3,4(r2)
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
    a9b4:	00000b06 	br	a9e4 <pbuf_header+0x1a8>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
    a9b8:	00800044 	movi	r2,1
    a9bc:	00001806 	br	aa20 <pbuf_header+0x1e4>
    }
  } else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    a9c0:	010000f4 	movhi	r4,3
    a9c4:	213fa804 	addi	r4,r4,-352
    a9c8:	014000f4 	movhi	r5,3
    a9cc:	29403204 	addi	r5,r5,200
    a9d0:	01808ec4 	movi	r6,571
    a9d4:	01c000f4 	movhi	r7,3
    a9d8:	39ffb904 	addi	r7,r7,-284
    a9dc:	00193f00 	call	193f0 <printf>
    a9e0:	003fff06 	br	a9e0 <pbuf_header+0x1a4>
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
    a9e4:	e0bffe17 	ldw	r2,-8(fp)
    a9e8:	10c0028b 	ldhu	r3,10(r2)
    a9ec:	e0bfff0b 	ldhu	r2,-4(fp)
    a9f0:	1885883a 	add	r2,r3,r2
    a9f4:	1007883a 	mov	r3,r2
    a9f8:	e0bffe17 	ldw	r2,-8(fp)
    a9fc:	10c0028d 	sth	r3,10(r2)
  p->tot_len += header_size_increment;
    aa00:	e0bffe17 	ldw	r2,-8(fp)
    aa04:	10c0020b 	ldhu	r3,8(r2)
    aa08:	e0bfff0b 	ldhu	r2,-4(fp)
    aa0c:	1885883a 	add	r2,r3,r2
    aa10:	1007883a 	mov	r3,r2
    aa14:	e0bffe17 	ldw	r2,-8(fp)
    aa18:	10c0020d 	sth	r3,8(r2)

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
    aa1c:	0005883a 	mov	r2,zero
}
    aa20:	e037883a 	mov	sp,fp
    aa24:	dfc00117 	ldw	ra,4(sp)
    aa28:	df000017 	ldw	fp,0(sp)
    aa2c:	dec00204 	addi	sp,sp,8
    aa30:	f800283a 	ret

0000aa34 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
    aa34:	defffa04 	addi	sp,sp,-24
    aa38:	dfc00515 	stw	ra,20(sp)
    aa3c:	df000415 	stw	fp,16(sp)
    aa40:	df000404 	addi	fp,sp,16
    aa44:	e13fff15 	stw	r4,-4(fp)
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
    aa48:	e0bfff17 	ldw	r2,-4(fp)
    aa4c:	10000d1e 	bne	r2,zero,aa84 <pbuf_free+0x50>
    LWIP_ASSERT("p != NULL", p != NULL);
    aa50:	e0bfff17 	ldw	r2,-4(fp)
    aa54:	1000091e 	bne	r2,zero,aa7c <pbuf_free+0x48>
    aa58:	010000f4 	movhi	r4,3
    aa5c:	213fa804 	addi	r4,r4,-352
    aa60:	014000f4 	movhi	r5,3
    aa64:	29402704 	addi	r5,r5,156
    aa68:	01809c44 	movi	r6,625
    aa6c:	01c000f4 	movhi	r7,3
    aa70:	39ffb904 	addi	r7,r7,-284
    aa74:	00193f00 	call	193f0 <printf>
    aa78:	003fff06 	br	aa78 <pbuf_free+0x44>
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
      ("pbuf_free(p == NULL) was called.\n"));
    return 0;
    aa7c:	0005883a 	mov	r2,zero
    aa80:	00005a06 	br	abec <pbuf_free+0x1b8>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
    aa84:	e0bfff17 	ldw	r2,-4(fp)
    aa88:	10800303 	ldbu	r2,12(r2)
    aa8c:	10803fcc 	andi	r2,r2,255
    aa90:	10001826 	beq	r2,zero,aaf4 <pbuf_free+0xc0>
    aa94:	e0bfff17 	ldw	r2,-4(fp)
    aa98:	10800303 	ldbu	r2,12(r2)
    aa9c:	10803fcc 	andi	r2,r2,255
    aaa0:	10800060 	cmpeqi	r2,r2,1
    aaa4:	1000131e 	bne	r2,zero,aaf4 <pbuf_free+0xc0>
    aaa8:	e0bfff17 	ldw	r2,-4(fp)
    aaac:	10800303 	ldbu	r2,12(r2)
    aab0:	10803fcc 	andi	r2,r2,255
    aab4:	108000a0 	cmpeqi	r2,r2,2
    aab8:	10000e1e 	bne	r2,zero,aaf4 <pbuf_free+0xc0>
    aabc:	e0bfff17 	ldw	r2,-4(fp)
    aac0:	10800303 	ldbu	r2,12(r2)
    aac4:	10803fcc 	andi	r2,r2,255
    aac8:	108000e0 	cmpeqi	r2,r2,3
    aacc:	1000091e 	bne	r2,zero,aaf4 <pbuf_free+0xc0>
    aad0:	010000f4 	movhi	r4,3
    aad4:	213fa804 	addi	r4,r4,-352
    aad8:	014000f4 	movhi	r5,3
    aadc:	29403604 	addi	r5,r5,216
    aae0:	01809f44 	movi	r6,637
    aae4:	01c000f4 	movhi	r7,3
    aae8:	39ffb904 	addi	r7,r7,-284
    aaec:	00193f00 	call	193f0 <printf>
    aaf0:	003fff06 	br	aaf0 <pbuf_free+0xbc>
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
    aaf4:	e03ffc05 	stb	zero,-16(fp)
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
    aaf8:	00003906 	br	abe0 <pbuf_free+0x1ac>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    aafc:	e0bfff17 	ldw	r2,-4(fp)
    ab00:	1080038b 	ldhu	r2,14(r2)
    ab04:	10bfffcc 	andi	r2,r2,65535
    ab08:	1000091e 	bne	r2,zero,ab30 <pbuf_free+0xfc>
    ab0c:	010000f4 	movhi	r4,3
    ab10:	213fa804 	addi	r4,r4,-352
    ab14:	014000f4 	movhi	r5,3
    ab18:	29403c04 	addi	r5,r5,240
    ab1c:	0180a284 	movi	r6,650
    ab20:	01c000f4 	movhi	r7,3
    ab24:	39ffb904 	addi	r7,r7,-284
    ab28:	00193f00 	call	193f0 <printf>
    ab2c:	003fff06 	br	ab2c <pbuf_free+0xf8>
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
    ab30:	e0bfff17 	ldw	r2,-4(fp)
    ab34:	1080038b 	ldhu	r2,14(r2)
    ab38:	10bfffc4 	addi	r2,r2,-1
    ab3c:	1007883a 	mov	r3,r2
    ab40:	e0bfff17 	ldw	r2,-4(fp)
    ab44:	10c0038d 	sth	r3,14(r2)
    ab48:	e0bfff17 	ldw	r2,-4(fp)
    ab4c:	1080038b 	ldhu	r2,14(r2)
    ab50:	e0bffc8d 	sth	r2,-14(fp)
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
    ab54:	e0bffc8b 	ldhu	r2,-14(fp)
    ab58:	1000201e 	bne	r2,zero,abdc <pbuf_free+0x1a8>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
    ab5c:	e0bfff17 	ldw	r2,-4(fp)
    ab60:	10800017 	ldw	r2,0(r2)
    ab64:	e0bffd15 	stw	r2,-12(fp)
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
    ab68:	e0bfff17 	ldw	r2,-4(fp)
    ab6c:	10800303 	ldbu	r2,12(r2)
    ab70:	10803fcc 	andi	r2,r2,255
    ab74:	e0bffe0d 	sth	r2,-8(fp)
        pc->custom_free_function(p);
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
    ab78:	e0bffe0b 	ldhu	r2,-8(fp)
    ab7c:	108000d8 	cmpnei	r2,r2,3
    ab80:	1000041e 	bne	r2,zero,ab94 <pbuf_free+0x160>
          memp_free(MEMP_PBUF_POOL, p);
    ab84:	01000204 	movi	r4,8
    ab88:	e17fff17 	ldw	r5,-4(fp)
    ab8c:	00097d40 	call	97d4 <memp_free>
    ab90:	00000c06 	br	abc4 <pbuf_free+0x190>
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
    ab94:	e0bffe0b 	ldhu	r2,-8(fp)
    ab98:	10800060 	cmpeqi	r2,r2,1
    ab9c:	1000031e 	bne	r2,zero,abac <pbuf_free+0x178>
    aba0:	e0bffe0b 	ldhu	r2,-8(fp)
    aba4:	10800098 	cmpnei	r2,r2,2
    aba8:	1000041e 	bne	r2,zero,abbc <pbuf_free+0x188>
          memp_free(MEMP_PBUF, p);
    abac:	010001c4 	movi	r4,7
    abb0:	e17fff17 	ldw	r5,-4(fp)
    abb4:	00097d40 	call	97d4 <memp_free>
    abb8:	00000206 	br	abc4 <pbuf_free+0x190>
        /* type == PBUF_RAM */
        } else {
          mem_free(p);
    abbc:	e13fff17 	ldw	r4,-4(fp)
    abc0:	0008afc0 	call	8afc <mem_free>
        }
      }
      count++;
    abc4:	e0bffc03 	ldbu	r2,-16(fp)
    abc8:	10800044 	addi	r2,r2,1
    abcc:	e0bffc05 	stb	r2,-16(fp)
      /* proceed to next pbuf */
      p = q;
    abd0:	e0bffd17 	ldw	r2,-12(fp)
    abd4:	e0bfff15 	stw	r2,-4(fp)
    abd8:	00000106 	br	abe0 <pbuf_free+0x1ac>
    /* p->ref > 0, this pbuf is still referenced to */
    /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
      /* stop walking through the chain */
      p = NULL;
    abdc:	e03fff15 	stw	zero,-4(fp)
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
    abe0:	e0bfff17 	ldw	r2,-4(fp)
    abe4:	103fc51e 	bne	r2,zero,aafc <pbuf_free+0xc8>
      p = NULL;
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
    abe8:	e0bffc03 	ldbu	r2,-16(fp)
}
    abec:	e037883a 	mov	sp,fp
    abf0:	dfc00117 	ldw	ra,4(sp)
    abf4:	df000017 	ldw	fp,0(sp)
    abf8:	dec00204 	addi	sp,sp,8
    abfc:	f800283a 	ret

0000ac00 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
    ac00:	defffd04 	addi	sp,sp,-12
    ac04:	df000215 	stw	fp,8(sp)
    ac08:	df000204 	addi	fp,sp,8
    ac0c:	e13fff15 	stw	r4,-4(fp)
  u8_t len;

  len = 0;
    ac10:	e03ffe05 	stb	zero,-8(fp)
  while (p != NULL) {
    ac14:	00000606 	br	ac30 <pbuf_clen+0x30>
    ++len;
    ac18:	e0bffe03 	ldbu	r2,-8(fp)
    ac1c:	10800044 	addi	r2,r2,1
    ac20:	e0bffe05 	stb	r2,-8(fp)
    p = p->next;
    ac24:	e0bfff17 	ldw	r2,-4(fp)
    ac28:	10800017 	ldw	r2,0(r2)
    ac2c:	e0bfff15 	stw	r2,-4(fp)
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
    ac30:	e0bfff17 	ldw	r2,-4(fp)
    ac34:	103ff81e 	bne	r2,zero,ac18 <pbuf_clen+0x18>
    ++len;
    p = p->next;
  }
  return len;
    ac38:	e0bffe03 	ldbu	r2,-8(fp)
}
    ac3c:	e037883a 	mov	sp,fp
    ac40:	df000017 	ldw	fp,0(sp)
    ac44:	dec00104 	addi	sp,sp,4
    ac48:	f800283a 	ret

0000ac4c <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
    ac4c:	defffe04 	addi	sp,sp,-8
    ac50:	df000115 	stw	fp,4(sp)
    ac54:	df000104 	addi	fp,sp,4
    ac58:	e13fff15 	stw	r4,-4(fp)
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
    ac5c:	e0bfff17 	ldw	r2,-4(fp)
    ac60:	10000626 	beq	r2,zero,ac7c <pbuf_ref+0x30>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
    ac64:	e0bfff17 	ldw	r2,-4(fp)
    ac68:	1080038b 	ldhu	r2,14(r2)
    ac6c:	10800044 	addi	r2,r2,1
    ac70:	1007883a 	mov	r3,r2
    ac74:	e0bfff17 	ldw	r2,-4(fp)
    ac78:	10c0038d 	sth	r3,14(r2)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
    ac7c:	e037883a 	mov	sp,fp
    ac80:	df000017 	ldw	fp,0(sp)
    ac84:	dec00104 	addi	sp,sp,4
    ac88:	f800283a 	ret

0000ac8c <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
    ac8c:	defffb04 	addi	sp,sp,-20
    ac90:	dfc00415 	stw	ra,16(sp)
    ac94:	df000315 	stw	fp,12(sp)
    ac98:	df000304 	addi	fp,sp,12
    ac9c:	e13ffe15 	stw	r4,-8(fp)
    aca0:	e17fff15 	stw	r5,-4(fp)
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
    aca4:	e0bffe17 	ldw	r2,-8(fp)
    aca8:	10000226 	beq	r2,zero,acb4 <pbuf_cat+0x28>
    acac:	e0bfff17 	ldw	r2,-4(fp)
    acb0:	1000091e 	bne	r2,zero,acd8 <pbuf_cat+0x4c>
    acb4:	010000f4 	movhi	r4,3
    acb8:	213fa804 	addi	r4,r4,-352
    acbc:	014000f4 	movhi	r5,3
    acc0:	29404204 	addi	r5,r5,264
    acc4:	0180bb84 	movi	r6,750
    acc8:	01c000f4 	movhi	r7,3
    accc:	39ffb904 	addi	r7,r7,-284
    acd0:	00193f00 	call	193f0 <printf>
    acd4:	003fff06 	br	acd4 <pbuf_cat+0x48>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    acd8:	e0bffe17 	ldw	r2,-8(fp)
    acdc:	e0bffd15 	stw	r2,-12(fp)
    ace0:	00000b06 	br	ad10 <pbuf_cat+0x84>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
    ace4:	e0bffd17 	ldw	r2,-12(fp)
    ace8:	10c0020b 	ldhu	r3,8(r2)
    acec:	e0bfff17 	ldw	r2,-4(fp)
    acf0:	1080020b 	ldhu	r2,8(r2)
    acf4:	1885883a 	add	r2,r3,r2
    acf8:	1007883a 	mov	r3,r2
    acfc:	e0bffd17 	ldw	r2,-12(fp)
    ad00:	10c0020d 	sth	r3,8(r2)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    ad04:	e0bffd17 	ldw	r2,-12(fp)
    ad08:	10800017 	ldw	r2,0(r2)
    ad0c:	e0bffd15 	stw	r2,-12(fp)
    ad10:	e0bffd17 	ldw	r2,-12(fp)
    ad14:	10800017 	ldw	r2,0(r2)
    ad18:	103ff21e 	bne	r2,zero,ace4 <pbuf_cat+0x58>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
    ad1c:	e0bffd17 	ldw	r2,-12(fp)
    ad20:	10c0020b 	ldhu	r3,8(r2)
    ad24:	e0bffd17 	ldw	r2,-12(fp)
    ad28:	1080028b 	ldhu	r2,10(r2)
    ad2c:	18ffffcc 	andi	r3,r3,65535
    ad30:	10bfffcc 	andi	r2,r2,65535
    ad34:	18800926 	beq	r3,r2,ad5c <pbuf_cat+0xd0>
    ad38:	010000f4 	movhi	r4,3
    ad3c:	213fa804 	addi	r4,r4,-352
    ad40:	014000f4 	movhi	r5,3
    ad44:	29405004 	addi	r5,r5,320
    ad48:	0180bd84 	movi	r6,758
    ad4c:	01c000f4 	movhi	r7,3
    ad50:	39ffb904 	addi	r7,r7,-284
    ad54:	00193f00 	call	193f0 <printf>
    ad58:	003fff06 	br	ad58 <pbuf_cat+0xcc>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
    ad5c:	e0bffd17 	ldw	r2,-12(fp)
    ad60:	10800017 	ldw	r2,0(r2)
    ad64:	10000926 	beq	r2,zero,ad8c <pbuf_cat+0x100>
    ad68:	010000f4 	movhi	r4,3
    ad6c:	213fa804 	addi	r4,r4,-352
    ad70:	014000f4 	movhi	r5,3
    ad74:	29405c04 	addi	r5,r5,368
    ad78:	0180bdc4 	movi	r6,759
    ad7c:	01c000f4 	movhi	r7,3
    ad80:	39ffb904 	addi	r7,r7,-284
    ad84:	00193f00 	call	193f0 <printf>
    ad88:	003fff06 	br	ad88 <pbuf_cat+0xfc>
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
    ad8c:	e0bffd17 	ldw	r2,-12(fp)
    ad90:	10c0020b 	ldhu	r3,8(r2)
    ad94:	e0bfff17 	ldw	r2,-4(fp)
    ad98:	1080020b 	ldhu	r2,8(r2)
    ad9c:	1885883a 	add	r2,r3,r2
    ada0:	1007883a 	mov	r3,r2
    ada4:	e0bffd17 	ldw	r2,-12(fp)
    ada8:	10c0020d 	sth	r3,8(r2)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
    adac:	e0bffd17 	ldw	r2,-12(fp)
    adb0:	e0ffff17 	ldw	r3,-4(fp)
    adb4:	10c00015 	stw	r3,0(r2)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
    adb8:	e037883a 	mov	sp,fp
    adbc:	dfc00117 	ldw	ra,4(sp)
    adc0:	df000017 	ldw	fp,0(sp)
    adc4:	dec00204 	addi	sp,sp,8
    adc8:	f800283a 	ret

0000adcc <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
    adcc:	defffc04 	addi	sp,sp,-16
    add0:	dfc00315 	stw	ra,12(sp)
    add4:	df000215 	stw	fp,8(sp)
    add8:	df000204 	addi	fp,sp,8
    addc:	e13ffe15 	stw	r4,-8(fp)
    ade0:	e17fff15 	stw	r5,-4(fp)
  pbuf_cat(h, t);
    ade4:	e13ffe17 	ldw	r4,-8(fp)
    ade8:	e17fff17 	ldw	r5,-4(fp)
    adec:	000ac8c0 	call	ac8c <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
    adf0:	e13fff17 	ldw	r4,-4(fp)
    adf4:	000ac4c0 	call	ac4c <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
    adf8:	e037883a 	mov	sp,fp
    adfc:	dfc00117 	ldw	ra,4(sp)
    ae00:	df000017 	ldw	fp,0(sp)
    ae04:	dec00204 	addi	sp,sp,8
    ae08:	f800283a 	ret

0000ae0c <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
    ae0c:	defffb04 	addi	sp,sp,-20
    ae10:	dfc00415 	stw	ra,16(sp)
    ae14:	df000315 	stw	fp,12(sp)
    ae18:	df000304 	addi	fp,sp,12
    ae1c:	e13fff15 	stw	r4,-4(fp)
  struct pbuf *q;
  u8_t tail_gone = 1;
    ae20:	00800044 	movi	r2,1
    ae24:	e0bffd05 	stb	r2,-12(fp)
  /* tail */
  q = p->next;
    ae28:	e0bfff17 	ldw	r2,-4(fp)
    ae2c:	10800017 	ldw	r2,0(r2)
    ae30:	e0bffe15 	stw	r2,-8(fp)
  /* pbuf has successor in chain? */
  if (q != NULL) {
    ae34:	e0bffe17 	ldw	r2,-8(fp)
    ae38:	10002526 	beq	r2,zero,aed0 <pbuf_dechain+0xc4>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
    ae3c:	e0bffe17 	ldw	r2,-8(fp)
    ae40:	1080020b 	ldhu	r2,8(r2)
    ae44:	10ffffcc 	andi	r3,r2,65535
    ae48:	e0bfff17 	ldw	r2,-4(fp)
    ae4c:	1080020b 	ldhu	r2,8(r2)
    ae50:	113fffcc 	andi	r4,r2,65535
    ae54:	e0bfff17 	ldw	r2,-4(fp)
    ae58:	1080028b 	ldhu	r2,10(r2)
    ae5c:	10bfffcc 	andi	r2,r2,65535
    ae60:	2085c83a 	sub	r2,r4,r2
    ae64:	18800926 	beq	r3,r2,ae8c <pbuf_dechain+0x80>
    ae68:	010000f4 	movhi	r4,3
    ae6c:	213fa804 	addi	r4,r4,-352
    ae70:	014000f4 	movhi	r5,3
    ae74:	29406004 	addi	r5,r5,384
    ae78:	0180cb04 	movi	r6,812
    ae7c:	01c000f4 	movhi	r7,3
    ae80:	39ffb904 	addi	r7,r7,-284
    ae84:	00193f00 	call	193f0 <printf>
    ae88:	003fff06 	br	ae88 <pbuf_dechain+0x7c>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
    ae8c:	e0bfff17 	ldw	r2,-4(fp)
    ae90:	10c0020b 	ldhu	r3,8(r2)
    ae94:	e0bfff17 	ldw	r2,-4(fp)
    ae98:	1080028b 	ldhu	r2,10(r2)
    ae9c:	1885c83a 	sub	r2,r3,r2
    aea0:	1007883a 	mov	r3,r2
    aea4:	e0bffe17 	ldw	r2,-8(fp)
    aea8:	10c0020d 	sth	r3,8(r2)
    /* decouple pbuf from remainder */
    p->next = NULL;
    aeac:	e0bfff17 	ldw	r2,-4(fp)
    aeb0:	10000015 	stw	zero,0(r2)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
    aeb4:	e0bfff17 	ldw	r2,-4(fp)
    aeb8:	10c0028b 	ldhu	r3,10(r2)
    aebc:	e0bfff17 	ldw	r2,-4(fp)
    aec0:	10c0020d 	sth	r3,8(r2)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
    aec4:	e13ffe17 	ldw	r4,-8(fp)
    aec8:	000aa340 	call	aa34 <pbuf_free>
    aecc:	e0bffd05 	stb	r2,-12(fp)
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
    aed0:	e0bfff17 	ldw	r2,-4(fp)
    aed4:	10c0020b 	ldhu	r3,8(r2)
    aed8:	e0bfff17 	ldw	r2,-4(fp)
    aedc:	1080028b 	ldhu	r2,10(r2)
    aee0:	18ffffcc 	andi	r3,r3,65535
    aee4:	10bfffcc 	andi	r2,r2,65535
    aee8:	18800926 	beq	r3,r2,af10 <pbuf_dechain+0x104>
    aeec:	010000f4 	movhi	r4,3
    aef0:	213fa804 	addi	r4,r4,-352
    aef4:	014000f4 	movhi	r5,3
    aef8:	29406904 	addi	r5,r5,420
    aefc:	0180cf44 	movi	r6,829
    af00:	01c000f4 	movhi	r7,3
    af04:	39ffb904 	addi	r7,r7,-284
    af08:	00193f00 	call	193f0 <printf>
    af0c:	003fff06 	br	af0c <pbuf_dechain+0x100>
  return ((tail_gone > 0) ? NULL : q);
    af10:	e0bffd03 	ldbu	r2,-12(fp)
    af14:	1000021e 	bne	r2,zero,af20 <pbuf_dechain+0x114>
    af18:	e0bffe17 	ldw	r2,-8(fp)
    af1c:	00000106 	br	af24 <pbuf_dechain+0x118>
    af20:	0005883a 	mov	r2,zero
}
    af24:	e037883a 	mov	sp,fp
    af28:	dfc00117 	ldw	ra,4(sp)
    af2c:	df000017 	ldw	fp,0(sp)
    af30:	dec00204 	addi	sp,sp,8
    af34:	f800283a 	ret

0000af38 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
    af38:	defffa04 	addi	sp,sp,-24
    af3c:	dfc00515 	stw	ra,20(sp)
    af40:	df000415 	stw	fp,16(sp)
    af44:	df000404 	addi	fp,sp,16
    af48:	e13ffe15 	stw	r4,-8(fp)
    af4c:	e17fff15 	stw	r5,-4(fp)
  u16_t offset_to=0, offset_from=0, len;
    af50:	e03ffc0d 	sth	zero,-16(fp)
    af54:	e03ffc8d 	sth	zero,-14(fp)

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
    af58:	e0bffe17 	ldw	r2,-8(fp)
    af5c:	10000926 	beq	r2,zero,af84 <pbuf_copy+0x4c>
    af60:	e0bfff17 	ldw	r2,-4(fp)
    af64:	10000726 	beq	r2,zero,af84 <pbuf_copy+0x4c>
    af68:	e0bffe17 	ldw	r2,-8(fp)
    af6c:	10c0020b 	ldhu	r3,8(r2)
    af70:	e0bfff17 	ldw	r2,-4(fp)
    af74:	1080020b 	ldhu	r2,8(r2)
    af78:	18ffffcc 	andi	r3,r3,65535
    af7c:	10bfffcc 	andi	r2,r2,65535
    af80:	1880092e 	bgeu	r3,r2,afa8 <pbuf_copy+0x70>
    af84:	010000f4 	movhi	r4,3
    af88:	213fa804 	addi	r4,r4,-352
    af8c:	014000f4 	movhi	r5,3
    af90:	29406f04 	addi	r5,r5,444
    af94:	0180d744 	movi	r6,861
    af98:	01c000f4 	movhi	r7,3
    af9c:	39ffb904 	addi	r7,r7,-284
    afa0:	00193f00 	call	193f0 <printf>
    afa4:	003fff06 	br	afa4 <pbuf_copy+0x6c>

  /* iterate through pbuf chain */
  do
  {
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
    afa8:	e0bffe17 	ldw	r2,-8(fp)
    afac:	1080028b 	ldhu	r2,10(r2)
    afb0:	10ffffcc 	andi	r3,r2,65535
    afb4:	e0bffc0b 	ldhu	r2,-16(fp)
    afb8:	1887c83a 	sub	r3,r3,r2
    afbc:	e0bfff17 	ldw	r2,-4(fp)
    afc0:	1080028b 	ldhu	r2,10(r2)
    afc4:	113fffcc 	andi	r4,r2,65535
    afc8:	e0bffc8b 	ldhu	r2,-14(fp)
    afcc:	2085c83a 	sub	r2,r4,r2
    afd0:	18800616 	blt	r3,r2,afec <pbuf_copy+0xb4>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
    afd4:	e0bfff17 	ldw	r2,-4(fp)
    afd8:	10c0028b 	ldhu	r3,10(r2)
    afdc:	e0bffc8b 	ldhu	r2,-14(fp)
    afe0:	1885c83a 	sub	r2,r3,r2
    afe4:	e0bffd0d 	sth	r2,-12(fp)
    afe8:	00000506 	br	b000 <pbuf_copy+0xc8>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    afec:	e0bffe17 	ldw	r2,-8(fp)
    aff0:	10c0028b 	ldhu	r3,10(r2)
    aff4:	e0bffc0b 	ldhu	r2,-16(fp)
    aff8:	1885c83a 	sub	r2,r3,r2
    affc:	e0bffd0d 	sth	r2,-12(fp)
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    b000:	e0bffe17 	ldw	r2,-8(fp)
    b004:	10c00117 	ldw	r3,4(r2)
    b008:	e0bffc0b 	ldhu	r2,-16(fp)
    b00c:	1889883a 	add	r4,r3,r2
    b010:	e0bfff17 	ldw	r2,-4(fp)
    b014:	10c00117 	ldw	r3,4(r2)
    b018:	e0bffc8b 	ldhu	r2,-14(fp)
    b01c:	1887883a 	add	r3,r3,r2
    b020:	e0bffd0b 	ldhu	r2,-12(fp)
    b024:	180b883a 	mov	r5,r3
    b028:	100d883a 	mov	r6,r2
    b02c:	00191f00 	call	191f0 <memcpy>
    offset_to += len;
    b030:	e0fffc0b 	ldhu	r3,-16(fp)
    b034:	e0bffd0b 	ldhu	r2,-12(fp)
    b038:	1885883a 	add	r2,r3,r2
    b03c:	e0bffc0d 	sth	r2,-16(fp)
    offset_from += len;
    b040:	e0fffc8b 	ldhu	r3,-14(fp)
    b044:	e0bffd0b 	ldhu	r2,-12(fp)
    b048:	1885883a 	add	r2,r3,r2
    b04c:	e0bffc8d 	sth	r2,-14(fp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    b050:	e0bffe17 	ldw	r2,-8(fp)
    b054:	1080028b 	ldhu	r2,10(r2)
    b058:	10ffffcc 	andi	r3,r2,65535
    b05c:	e0bffc0b 	ldhu	r2,-16(fp)
    b060:	1880092e 	bgeu	r3,r2,b088 <pbuf_copy+0x150>
    b064:	010000f4 	movhi	r4,3
    b068:	213fa804 	addi	r4,r4,-352
    b06c:	014000f4 	movhi	r5,3
    b070:	29407b04 	addi	r5,r5,492
    b074:	0180db44 	movi	r6,877
    b078:	01c000f4 	movhi	r7,3
    b07c:	39ffb904 	addi	r7,r7,-284
    b080:	00193f00 	call	193f0 <printf>
    b084:	003fff06 	br	b084 <pbuf_copy+0x14c>
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    b088:	e0bfff17 	ldw	r2,-4(fp)
    b08c:	1080028b 	ldhu	r2,10(r2)
    b090:	10ffffcc 	andi	r3,r2,65535
    b094:	e0bffc8b 	ldhu	r2,-14(fp)
    b098:	1880092e 	bgeu	r3,r2,b0c0 <pbuf_copy+0x188>
    b09c:	010000f4 	movhi	r4,3
    b0a0:	213fa804 	addi	r4,r4,-352
    b0a4:	014000f4 	movhi	r5,3
    b0a8:	29408104 	addi	r5,r5,516
    b0ac:	0180db84 	movi	r6,878
    b0b0:	01c000f4 	movhi	r7,3
    b0b4:	39ffb904 	addi	r7,r7,-284
    b0b8:	00193f00 	call	193f0 <printf>
    b0bc:	003fff06 	br	b0bc <pbuf_copy+0x184>
    if (offset_from >= p_from->len) {
    b0c0:	e0bfff17 	ldw	r2,-4(fp)
    b0c4:	1080028b 	ldhu	r2,10(r2)
    b0c8:	10bfffcc 	andi	r2,r2,65535
    b0cc:	e0fffc8b 	ldhu	r3,-14(fp)
    b0d0:	18800436 	bltu	r3,r2,b0e4 <pbuf_copy+0x1ac>
      /* on to next p_from (if any) */
      offset_from = 0;
    b0d4:	e03ffc8d 	sth	zero,-14(fp)
      p_from = p_from->next;
    b0d8:	e0bfff17 	ldw	r2,-4(fp)
    b0dc:	10800017 	ldw	r2,0(r2)
    b0e0:	e0bfff15 	stw	r2,-4(fp)
    }
    if (offset_to == p_to->len) {
    b0e4:	e0bffe17 	ldw	r2,-8(fp)
    b0e8:	1080028b 	ldhu	r2,10(r2)
    b0ec:	10ffffcc 	andi	r3,r2,65535
    b0f0:	e0bffc0b 	ldhu	r2,-16(fp)
    b0f4:	1880111e 	bne	r3,r2,b13c <pbuf_copy+0x204>
      /* on to next p_to (if any) */
      offset_to = 0;
    b0f8:	e03ffc0d 	sth	zero,-16(fp)
      p_to = p_to->next;
    b0fc:	e0bffe17 	ldw	r2,-8(fp)
    b100:	10800017 	ldw	r2,0(r2)
    b104:	e0bffe15 	stw	r2,-8(fp)
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
    b108:	e0bffe17 	ldw	r2,-8(fp)
    b10c:	10000b1e 	bne	r2,zero,b13c <pbuf_copy+0x204>
    b110:	e0bfff17 	ldw	r2,-4(fp)
    b114:	10000926 	beq	r2,zero,b13c <pbuf_copy+0x204>
    b118:	010000f4 	movhi	r4,3
    b11c:	213fa804 	addi	r4,r4,-352
    b120:	014000f4 	movhi	r5,3
    b124:	29408804 	addi	r5,r5,544
    b128:	0180de04 	movi	r6,888
    b12c:	01c000f4 	movhi	r7,3
    b130:	39ffb904 	addi	r7,r7,-284
    b134:	00193f00 	call	193f0 <printf>
    b138:	003fff06 	br	b138 <pbuf_copy+0x200>
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
    b13c:	e0bfff17 	ldw	r2,-4(fp)
    b140:	10001326 	beq	r2,zero,b190 <pbuf_copy+0x258>
    b144:	e0bfff17 	ldw	r2,-4(fp)
    b148:	10c0028b 	ldhu	r3,10(r2)
    b14c:	e0bfff17 	ldw	r2,-4(fp)
    b150:	1080020b 	ldhu	r2,8(r2)
    b154:	18ffffcc 	andi	r3,r3,65535
    b158:	10bfffcc 	andi	r2,r2,65535
    b15c:	18800c1e 	bne	r3,r2,b190 <pbuf_copy+0x258>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
    b160:	e0bfff17 	ldw	r2,-4(fp)
    b164:	10800017 	ldw	r2,0(r2)
    b168:	10000926 	beq	r2,zero,b190 <pbuf_copy+0x258>
    b16c:	010000f4 	movhi	r4,3
    b170:	213fa804 	addi	r4,r4,-352
    b174:	014000f4 	movhi	r5,3
    b178:	29408c04 	addi	r5,r5,560
    b17c:	0180df84 	movi	r6,894
    b180:	01c000f4 	movhi	r7,3
    b184:	39ffb904 	addi	r7,r7,-284
    b188:	00193f00 	call	193f0 <printf>
    b18c:	003fff06 	br	b18c <pbuf_copy+0x254>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
    b190:	e0bffe17 	ldw	r2,-8(fp)
    b194:	10001326 	beq	r2,zero,b1e4 <pbuf_copy+0x2ac>
    b198:	e0bffe17 	ldw	r2,-8(fp)
    b19c:	10c0028b 	ldhu	r3,10(r2)
    b1a0:	e0bffe17 	ldw	r2,-8(fp)
    b1a4:	1080020b 	ldhu	r2,8(r2)
    b1a8:	18ffffcc 	andi	r3,r3,65535
    b1ac:	10bfffcc 	andi	r2,r2,65535
    b1b0:	18800c1e 	bne	r3,r2,b1e4 <pbuf_copy+0x2ac>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
    b1b4:	e0bffe17 	ldw	r2,-8(fp)
    b1b8:	10800017 	ldw	r2,0(r2)
    b1bc:	10000926 	beq	r2,zero,b1e4 <pbuf_copy+0x2ac>
    b1c0:	010000f4 	movhi	r4,3
    b1c4:	213fa804 	addi	r4,r4,-352
    b1c8:	014000f4 	movhi	r5,3
    b1cc:	29408c04 	addi	r5,r5,560
    b1d0:	0180e0c4 	movi	r6,899
    b1d4:	01c000f4 	movhi	r7,3
    b1d8:	39ffb904 	addi	r7,r7,-284
    b1dc:	00193f00 	call	193f0 <printf>
    b1e0:	003fff06 	br	b1e0 <pbuf_copy+0x2a8>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
    b1e4:	e0bfff17 	ldw	r2,-4(fp)
    b1e8:	103f6f1e 	bne	r2,zero,afa8 <pbuf_copy+0x70>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
    b1ec:	0005883a 	mov	r2,zero
}
    b1f0:	e037883a 	mov	sp,fp
    b1f4:	dfc00117 	ldw	ra,4(sp)
    b1f8:	df000017 	ldw	fp,0(sp)
    b1fc:	dec00204 	addi	sp,sp,8
    b200:	f800283a 	ret

0000b204 <pbuf_copy_partial>:
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
    b204:	defff704 	addi	sp,sp,-36
    b208:	dfc00815 	stw	ra,32(sp)
    b20c:	df000715 	stw	fp,28(sp)
    b210:	df000704 	addi	fp,sp,28
    b214:	e13ffc15 	stw	r4,-16(fp)
    b218:	e17ffd15 	stw	r5,-12(fp)
    b21c:	3007883a 	mov	r3,r6
    b220:	3805883a 	mov	r2,r7
    b224:	e0fffe0d 	sth	r3,-8(fp)
    b228:	e0bfff0d 	sth	r2,-4(fp)
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;
    b22c:	e03ffb0d 	sth	zero,-20(fp)

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
    b230:	e0bffc17 	ldw	r2,-16(fp)
    b234:	1000091e 	bne	r2,zero,b25c <pbuf_copy_partial+0x58>
    b238:	010000f4 	movhi	r4,3
    b23c:	213fa804 	addi	r4,r4,-352
    b240:	014000f4 	movhi	r5,3
    b244:	29409704 	addi	r5,r5,604
    b248:	0180e744 	movi	r6,925
    b24c:	01c000f4 	movhi	r7,3
    b250:	39ffb904 	addi	r7,r7,-284
    b254:	00193f00 	call	193f0 <printf>
    b258:	003fff06 	br	b258 <pbuf_copy_partial+0x54>
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
    b25c:	e0bffd17 	ldw	r2,-12(fp)
    b260:	1000091e 	bne	r2,zero,b288 <pbuf_copy_partial+0x84>
    b264:	010000f4 	movhi	r4,3
    b268:	213fa804 	addi	r4,r4,-352
    b26c:	014000f4 	movhi	r5,3
    b270:	29409f04 	addi	r5,r5,636
    b274:	0180e784 	movi	r6,926
    b278:	01c000f4 	movhi	r7,3
    b27c:	39ffb904 	addi	r7,r7,-284
    b280:	00193f00 	call	193f0 <printf>
    b284:	003fff06 	br	b284 <pbuf_copy_partial+0x80>

  left = 0;
    b288:	e03ffa0d 	sth	zero,-24(fp)

  if((buf == NULL) || (dataptr == NULL)) {
    b28c:	e0bffc17 	ldw	r2,-16(fp)
    b290:	10000226 	beq	r2,zero,b29c <pbuf_copy_partial+0x98>
    b294:	e0bffd17 	ldw	r2,-12(fp)
    b298:	1000021e 	bne	r2,zero,b2a4 <pbuf_copy_partial+0xa0>
    return 0;
    b29c:	0005883a 	mov	r2,zero
    b2a0:	00003a06 	br	b38c <pbuf_copy_partial+0x188>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    b2a4:	e0bffc17 	ldw	r2,-16(fp)
    b2a8:	e0bff915 	stw	r2,-28(fp)
    b2ac:	00003206 	br	b378 <pbuf_copy_partial+0x174>
    if ((offset != 0) && (offset >= p->len)) {
    b2b0:	e0bfff0b 	ldhu	r2,-4(fp)
    b2b4:	10000b26 	beq	r2,zero,b2e4 <pbuf_copy_partial+0xe0>
    b2b8:	e0bff917 	ldw	r2,-28(fp)
    b2bc:	1080028b 	ldhu	r2,10(r2)
    b2c0:	10bfffcc 	andi	r2,r2,65535
    b2c4:	e0ffff0b 	ldhu	r3,-4(fp)
    b2c8:	18800636 	bltu	r3,r2,b2e4 <pbuf_copy_partial+0xe0>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
    b2cc:	e0bff917 	ldw	r2,-28(fp)
    b2d0:	1080028b 	ldhu	r2,10(r2)
    b2d4:	e0ffff0b 	ldhu	r3,-4(fp)
    b2d8:	1885c83a 	sub	r2,r3,r2
    b2dc:	e0bfff0d 	sth	r2,-4(fp)
    b2e0:	00002206 	br	b36c <pbuf_copy_partial+0x168>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
    b2e4:	e0bff917 	ldw	r2,-28(fp)
    b2e8:	10c0028b 	ldhu	r3,10(r2)
    b2ec:	e0bfff0b 	ldhu	r2,-4(fp)
    b2f0:	1885c83a 	sub	r2,r3,r2
    b2f4:	e0bffa8d 	sth	r2,-22(fp)
      if (buf_copy_len > len)
    b2f8:	e0bffa8b 	ldhu	r2,-22(fp)
    b2fc:	e0fffe0b 	ldhu	r3,-8(fp)
    b300:	1880022e 	bgeu	r3,r2,b30c <pbuf_copy_partial+0x108>
          buf_copy_len = len;
    b304:	e0bffe0b 	ldhu	r2,-8(fp)
    b308:	e0bffa8d 	sth	r2,-22(fp)
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
    b30c:	e0bffa0b 	ldhu	r2,-24(fp)
    b310:	e0fffd17 	ldw	r3,-12(fp)
    b314:	1889883a 	add	r4,r3,r2
    b318:	e0bff917 	ldw	r2,-28(fp)
    b31c:	10c00117 	ldw	r3,4(r2)
    b320:	e0bfff0b 	ldhu	r2,-4(fp)
    b324:	1887883a 	add	r3,r3,r2
    b328:	e0bffa8b 	ldhu	r2,-22(fp)
    b32c:	180b883a 	mov	r5,r3
    b330:	100d883a 	mov	r6,r2
    b334:	00191f00 	call	191f0 <memcpy>
      copied_total += buf_copy_len;
    b338:	e0fffb0b 	ldhu	r3,-20(fp)
    b33c:	e0bffa8b 	ldhu	r2,-22(fp)
    b340:	1885883a 	add	r2,r3,r2
    b344:	e0bffb0d 	sth	r2,-20(fp)
      left += buf_copy_len;
    b348:	e0fffa0b 	ldhu	r3,-24(fp)
    b34c:	e0bffa8b 	ldhu	r2,-22(fp)
    b350:	1885883a 	add	r2,r3,r2
    b354:	e0bffa0d 	sth	r2,-24(fp)
      len -= buf_copy_len;
    b358:	e0fffe0b 	ldhu	r3,-8(fp)
    b35c:	e0bffa8b 	ldhu	r2,-22(fp)
    b360:	1885c83a 	sub	r2,r3,r2
    b364:	e0bffe0d 	sth	r2,-8(fp)
      offset = 0;
    b368:	e03fff0d 	sth	zero,-4(fp)
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    b36c:	e0bff917 	ldw	r2,-28(fp)
    b370:	10800017 	ldw	r2,0(r2)
    b374:	e0bff915 	stw	r2,-28(fp)
    b378:	e0bffe0b 	ldhu	r2,-8(fp)
    b37c:	10000226 	beq	r2,zero,b388 <pbuf_copy_partial+0x184>
    b380:	e0bff917 	ldw	r2,-28(fp)
    b384:	103fca1e 	bne	r2,zero,b2b0 <pbuf_copy_partial+0xac>
      left += buf_copy_len;
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
    b388:	e0bffb0b 	ldhu	r2,-20(fp)
}
    b38c:	e037883a 	mov	sp,fp
    b390:	dfc00117 	ldw	ra,4(sp)
    b394:	df000017 	ldw	fp,0(sp)
    b398:	dec00204 	addi	sp,sp,8
    b39c:	f800283a 	ret

0000b3a0 <pbuf_take>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
{
    b3a0:	defff804 	addi	sp,sp,-32
    b3a4:	dfc00715 	stw	ra,28(sp)
    b3a8:	df000615 	stw	fp,24(sp)
    b3ac:	df000604 	addi	fp,sp,24
    b3b0:	e13ffd15 	stw	r4,-12(fp)
    b3b4:	e17ffe15 	stw	r5,-8(fp)
    b3b8:	3005883a 	mov	r2,r6
    b3bc:	e0bfff0d 	sth	r2,-4(fp)
  struct pbuf *p;
  u16_t buf_copy_len;
  u16_t total_copy_len = len;
    b3c0:	e0bfff0b 	ldhu	r2,-4(fp)
    b3c4:	e0bffb8d 	sth	r2,-18(fp)
  u16_t copied_total = 0;
    b3c8:	e03ffc0d 	sth	zero,-16(fp)

  LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return 0;);
    b3cc:	e0bffd17 	ldw	r2,-12(fp)
    b3d0:	1000091e 	bne	r2,zero,b3f8 <pbuf_take+0x58>
    b3d4:	010000f4 	movhi	r4,3
    b3d8:	213fa804 	addi	r4,r4,-352
    b3dc:	014000f4 	movhi	r5,3
    b3e0:	2940a804 	addi	r5,r5,672
    b3e4:	0180f344 	movi	r6,973
    b3e8:	01c000f4 	movhi	r7,3
    b3ec:	39ffb904 	addi	r7,r7,-284
    b3f0:	00193f00 	call	193f0 <printf>
    b3f4:	003fff06 	br	b3f4 <pbuf_take+0x54>
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return 0;);
    b3f8:	e0bffe17 	ldw	r2,-8(fp)
    b3fc:	1000091e 	bne	r2,zero,b424 <pbuf_take+0x84>
    b400:	010000f4 	movhi	r4,3
    b404:	213fa804 	addi	r4,r4,-352
    b408:	014000f4 	movhi	r5,3
    b40c:	2940ae04 	addi	r5,r5,696
    b410:	0180f384 	movi	r6,974
    b414:	01c000f4 	movhi	r7,3
    b418:	39ffb904 	addi	r7,r7,-284
    b41c:	00193f00 	call	193f0 <printf>
    b420:	003fff06 	br	b420 <pbuf_take+0x80>

  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
    b424:	e0bffd17 	ldw	r2,-12(fp)
    b428:	10000726 	beq	r2,zero,b448 <pbuf_take+0xa8>
    b42c:	e0bffe17 	ldw	r2,-8(fp)
    b430:	10000526 	beq	r2,zero,b448 <pbuf_take+0xa8>
    b434:	e0bffd17 	ldw	r2,-12(fp)
    b438:	1080020b 	ldhu	r2,8(r2)
    b43c:	10ffffcc 	andi	r3,r2,65535
    b440:	e0bfff0b 	ldhu	r2,-4(fp)
    b444:	1880022e 	bgeu	r3,r2,b450 <pbuf_take+0xb0>
    return ERR_ARG;
    b448:	00bffc84 	movi	r2,-14
    b44c:	00003d06 	br	b544 <pbuf_take+0x1a4>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; total_copy_len != 0; p = p->next) {
    b450:	e0bffd17 	ldw	r2,-12(fp)
    b454:	e0bffa15 	stw	r2,-24(fp)
    b458:	00002906 	br	b500 <pbuf_take+0x160>
    LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
    b45c:	e0bffa17 	ldw	r2,-24(fp)
    b460:	1000091e 	bne	r2,zero,b488 <pbuf_take+0xe8>
    b464:	010000f4 	movhi	r4,3
    b468:	213fa804 	addi	r4,r4,-352
    b46c:	014000f4 	movhi	r5,3
    b470:	2940b504 	addi	r5,r5,724
    b474:	0180f584 	movi	r6,982
    b478:	01c000f4 	movhi	r7,3
    b47c:	39ffb904 	addi	r7,r7,-284
    b480:	00193f00 	call	193f0 <printf>
    b484:	003fff06 	br	b484 <pbuf_take+0xe4>
    buf_copy_len = total_copy_len;
    b488:	e0bffb8b 	ldhu	r2,-18(fp)
    b48c:	e0bffb0d 	sth	r2,-20(fp)
    if (buf_copy_len > p->len) {
    b490:	e0bffa17 	ldw	r2,-24(fp)
    b494:	1080028b 	ldhu	r2,10(r2)
    b498:	10ffffcc 	andi	r3,r2,65535
    b49c:	e0bffb0b 	ldhu	r2,-20(fp)
    b4a0:	1880032e 	bgeu	r3,r2,b4b0 <pbuf_take+0x110>
      /* this pbuf cannot hold all remaining data */
      buf_copy_len = p->len;
    b4a4:	e0bffa17 	ldw	r2,-24(fp)
    b4a8:	1080028b 	ldhu	r2,10(r2)
    b4ac:	e0bffb0d 	sth	r2,-20(fp)
    }
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
    b4b0:	e0bffa17 	ldw	r2,-24(fp)
    b4b4:	11000117 	ldw	r4,4(r2)
    b4b8:	e0bffc0b 	ldhu	r2,-16(fp)
    b4bc:	e0fffe17 	ldw	r3,-8(fp)
    b4c0:	1887883a 	add	r3,r3,r2
    b4c4:	e0bffb0b 	ldhu	r2,-20(fp)
    b4c8:	180b883a 	mov	r5,r3
    b4cc:	100d883a 	mov	r6,r2
    b4d0:	00191f00 	call	191f0 <memcpy>
    total_copy_len -= buf_copy_len;
    b4d4:	e0fffb8b 	ldhu	r3,-18(fp)
    b4d8:	e0bffb0b 	ldhu	r2,-20(fp)
    b4dc:	1885c83a 	sub	r2,r3,r2
    b4e0:	e0bffb8d 	sth	r2,-18(fp)
    copied_total += buf_copy_len;
    b4e4:	e0fffc0b 	ldhu	r3,-16(fp)
    b4e8:	e0bffb0b 	ldhu	r2,-20(fp)
    b4ec:	1885883a 	add	r2,r3,r2
    b4f0:	e0bffc0d 	sth	r2,-16(fp)
  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
    return ERR_ARG;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; total_copy_len != 0; p = p->next) {
    b4f4:	e0bffa17 	ldw	r2,-24(fp)
    b4f8:	10800017 	ldw	r2,0(r2)
    b4fc:	e0bffa15 	stw	r2,-24(fp)
    b500:	e0bffb8b 	ldhu	r2,-18(fp)
    b504:	103fd51e 	bne	r2,zero,b45c <pbuf_take+0xbc>
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
    total_copy_len -= buf_copy_len;
    copied_total += buf_copy_len;
  }
  LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
    b508:	e0bffb8b 	ldhu	r2,-18(fp)
    b50c:	1000031e 	bne	r2,zero,b51c <pbuf_take+0x17c>
    b510:	e0fffc0b 	ldhu	r3,-16(fp)
    b514:	e0bfff0b 	ldhu	r2,-4(fp)
    b518:	18800926 	beq	r3,r2,b540 <pbuf_take+0x1a0>
    b51c:	010000f4 	movhi	r4,3
    b520:	213fa804 	addi	r4,r4,-352
    b524:	014000f4 	movhi	r5,3
    b528:	2940bb04 	addi	r5,r5,748
    b52c:	0180f844 	movi	r6,993
    b530:	01c000f4 	movhi	r7,3
    b534:	39ffb904 	addi	r7,r7,-284
    b538:	00193f00 	call	193f0 <printf>
    b53c:	003fff06 	br	b53c <pbuf_take+0x19c>
  return ERR_OK;
    b540:	0005883a 	mov	r2,zero
}
    b544:	e037883a 	mov	sp,fp
    b548:	dfc00117 	ldw	ra,4(sp)
    b54c:	df000017 	ldw	fp,0(sp)
    b550:	dec00204 	addi	sp,sp,8
    b554:	f800283a 	ret

0000b558 <pbuf_coalesce>:
 * @return a new, single pbuf (p->next is NULL)
 *         or the old pbuf if allocation fails
 */
struct pbuf*
pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
{
    b558:	defffa04 	addi	sp,sp,-24
    b55c:	dfc00515 	stw	ra,20(sp)
    b560:	df000415 	stw	fp,16(sp)
    b564:	df000404 	addi	fp,sp,16
    b568:	e13ffe15 	stw	r4,-8(fp)
    b56c:	e17fff15 	stw	r5,-4(fp)
  struct pbuf *q;
  err_t err;
  if (p->next == NULL) {
    b570:	e0bffe17 	ldw	r2,-8(fp)
    b574:	10800017 	ldw	r2,0(r2)
    b578:	1000021e 	bne	r2,zero,b584 <pbuf_coalesce+0x2c>
    return p;
    b57c:	e0bffe17 	ldw	r2,-8(fp)
    b580:	00001e06 	br	b5fc <pbuf_coalesce+0xa4>
  }
  q = pbuf_alloc(layer, p->tot_len, PBUF_RAM);
    b584:	e0bffe17 	ldw	r2,-8(fp)
    b588:	1080020b 	ldhu	r2,8(r2)
    b58c:	10bfffcc 	andi	r2,r2,65535
    b590:	e13fff17 	ldw	r4,-4(fp)
    b594:	100b883a 	mov	r5,r2
    b598:	000d883a 	mov	r6,zero
    b59c:	000a0740 	call	a074 <pbuf_alloc>
    b5a0:	e0bffc15 	stw	r2,-16(fp)
  if (q == NULL) {
    b5a4:	e0bffc17 	ldw	r2,-16(fp)
    b5a8:	1000021e 	bne	r2,zero,b5b4 <pbuf_coalesce+0x5c>
    /* @todo: what do we do now? */
    return p;
    b5ac:	e0bffe17 	ldw	r2,-8(fp)
    b5b0:	00001206 	br	b5fc <pbuf_coalesce+0xa4>
  }
  err = pbuf_copy(q, p);
    b5b4:	e13ffc17 	ldw	r4,-16(fp)
    b5b8:	e17ffe17 	ldw	r5,-8(fp)
    b5bc:	000af380 	call	af38 <pbuf_copy>
    b5c0:	e0bffd05 	stb	r2,-12(fp)
  LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
    b5c4:	e0bffd07 	ldb	r2,-12(fp)
    b5c8:	10000926 	beq	r2,zero,b5f0 <pbuf_coalesce+0x98>
    b5cc:	010000f4 	movhi	r4,3
    b5d0:	213fa804 	addi	r4,r4,-352
    b5d4:	014000f4 	movhi	r5,3
    b5d8:	2940c104 	addi	r5,r5,772
    b5dc:	0180ffc4 	movi	r6,1023
    b5e0:	01c000f4 	movhi	r7,3
    b5e4:	39ffb904 	addi	r7,r7,-284
    b5e8:	00193f00 	call	193f0 <printf>
    b5ec:	003fff06 	br	b5ec <pbuf_coalesce+0x94>
  pbuf_free(p);
    b5f0:	e13ffe17 	ldw	r4,-8(fp)
    b5f4:	000aa340 	call	aa34 <pbuf_free>
  return q;
    b5f8:	e0bffc17 	ldw	r2,-16(fp)
}
    b5fc:	e037883a 	mov	sp,fp
    b600:	dfc00117 	ldw	ra,4(sp)
    b604:	df000017 	ldw	fp,0(sp)
    b608:	dec00204 	addi	sp,sp,8
    b60c:	f800283a 	ret

0000b610 <pbuf_get_at>:
 * @param offset offset into p of the byte to return
 * @return byte at an offset into p OR ZERO IF 'offset' >= p->tot_len
 */
u8_t
pbuf_get_at(struct pbuf* p, u16_t offset)
{
    b610:	defffb04 	addi	sp,sp,-20
    b614:	df000415 	stw	fp,16(sp)
    b618:	df000404 	addi	fp,sp,16
    b61c:	e13ffe15 	stw	r4,-8(fp)
    b620:	2805883a 	mov	r2,r5
    b624:	e0bfff0d 	sth	r2,-4(fp)
  u16_t copy_from = offset;
    b628:	e0bfff0b 	ldhu	r2,-4(fp)
    b62c:	e0bffc0d 	sth	r2,-16(fp)
  struct pbuf* q = p;
    b630:	e0bffe17 	ldw	r2,-8(fp)
    b634:	e0bffd15 	stw	r2,-12(fp)

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= copy_from)) {
    b638:	00000806 	br	b65c <pbuf_get_at+0x4c>
    copy_from -= q->len;
    b63c:	e0bffd17 	ldw	r2,-12(fp)
    b640:	1080028b 	ldhu	r2,10(r2)
    b644:	e0fffc0b 	ldhu	r3,-16(fp)
    b648:	1885c83a 	sub	r2,r3,r2
    b64c:	e0bffc0d 	sth	r2,-16(fp)
    q = q->next;
    b650:	e0bffd17 	ldw	r2,-12(fp)
    b654:	10800017 	ldw	r2,0(r2)
    b658:	e0bffd15 	stw	r2,-12(fp)
{
  u16_t copy_from = offset;
  struct pbuf* q = p;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= copy_from)) {
    b65c:	e0bffd17 	ldw	r2,-12(fp)
    b660:	10000526 	beq	r2,zero,b678 <pbuf_get_at+0x68>
    b664:	e0bffd17 	ldw	r2,-12(fp)
    b668:	1080028b 	ldhu	r2,10(r2)
    b66c:	10bfffcc 	andi	r2,r2,65535
    b670:	e0fffc0b 	ldhu	r3,-16(fp)
    b674:	18bff12e 	bgeu	r3,r2,b63c <pbuf_get_at+0x2c>
    copy_from -= q->len;
    q = q->next;
  }
  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > copy_from)) {
    b678:	e0bffd17 	ldw	r2,-12(fp)
    b67c:	10000b26 	beq	r2,zero,b6ac <pbuf_get_at+0x9c>
    b680:	e0bffd17 	ldw	r2,-12(fp)
    b684:	1080028b 	ldhu	r2,10(r2)
    b688:	10bfffcc 	andi	r2,r2,65535
    b68c:	e0fffc0b 	ldhu	r3,-16(fp)
    b690:	1880062e 	bgeu	r3,r2,b6ac <pbuf_get_at+0x9c>
    return ((u8_t*)q->payload)[copy_from];
    b694:	e0bffd17 	ldw	r2,-12(fp)
    b698:	10c00117 	ldw	r3,4(r2)
    b69c:	e0bffc0b 	ldhu	r2,-16(fp)
    b6a0:	1885883a 	add	r2,r3,r2
    b6a4:	10800003 	ldbu	r2,0(r2)
    b6a8:	00000106 	br	b6b0 <pbuf_get_at+0xa0>
  }
  return 0;
    b6ac:	0005883a 	mov	r2,zero
}
    b6b0:	e037883a 	mov	sp,fp
    b6b4:	df000017 	ldw	fp,0(sp)
    b6b8:	dec00104 	addi	sp,sp,4
    b6bc:	f800283a 	ret

0000b6c0 <pbuf_memcmp>:
 * @return zero if equal, nonzero otherwise
 *         (0xffff if p is too short, diffoffset+1 otherwise)
 */
u16_t
pbuf_memcmp(struct pbuf* p, u16_t offset, const void* s2, u16_t n)
{
    b6c0:	defff704 	addi	sp,sp,-36
    b6c4:	dfc00815 	stw	ra,32(sp)
    b6c8:	df000715 	stw	fp,28(sp)
    b6cc:	df000704 	addi	fp,sp,28
    b6d0:	e13ffc15 	stw	r4,-16(fp)
    b6d4:	2807883a 	mov	r3,r5
    b6d8:	e1bffe15 	stw	r6,-8(fp)
    b6dc:	3805883a 	mov	r2,r7
    b6e0:	e0fffd0d 	sth	r3,-12(fp)
    b6e4:	e0bfff0d 	sth	r2,-4(fp)
  u16_t start = offset;
    b6e8:	e0bffd0b 	ldhu	r2,-12(fp)
    b6ec:	e0bff90d 	sth	r2,-28(fp)
  struct pbuf* q = p;
    b6f0:	e0bffc17 	ldw	r2,-16(fp)
    b6f4:	e0bffa15 	stw	r2,-24(fp)

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= start)) {
    b6f8:	00000806 	br	b71c <pbuf_memcmp+0x5c>
    start -= q->len;
    b6fc:	e0bffa17 	ldw	r2,-24(fp)
    b700:	1080028b 	ldhu	r2,10(r2)
    b704:	e0fff90b 	ldhu	r3,-28(fp)
    b708:	1885c83a 	sub	r2,r3,r2
    b70c:	e0bff90d 	sth	r2,-28(fp)
    q = q->next;
    b710:	e0bffa17 	ldw	r2,-24(fp)
    b714:	10800017 	ldw	r2,0(r2)
    b718:	e0bffa15 	stw	r2,-24(fp)
{
  u16_t start = offset;
  struct pbuf* q = p;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= start)) {
    b71c:	e0bffa17 	ldw	r2,-24(fp)
    b720:	10000526 	beq	r2,zero,b738 <pbuf_memcmp+0x78>
    b724:	e0bffa17 	ldw	r2,-24(fp)
    b728:	1080028b 	ldhu	r2,10(r2)
    b72c:	10bfffcc 	andi	r2,r2,65535
    b730:	e0fff90b 	ldhu	r3,-28(fp)
    b734:	18bff12e 	bgeu	r3,r2,b6fc <pbuf_memcmp+0x3c>
    start -= q->len;
    q = q->next;
  }
  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > start)) {
    b738:	e0bffa17 	ldw	r2,-24(fp)
    b73c:	10002226 	beq	r2,zero,b7c8 <pbuf_memcmp+0x108>
    b740:	e0bffa17 	ldw	r2,-24(fp)
    b744:	1080028b 	ldhu	r2,10(r2)
    b748:	10bfffcc 	andi	r2,r2,65535
    b74c:	e0fff90b 	ldhu	r3,-28(fp)
    b750:	18801d2e 	bgeu	r3,r2,b7c8 <pbuf_memcmp+0x108>
    u16_t i;
    for(i = 0; i < n; i++) {
    b754:	e03ffb0d 	sth	zero,-20(fp)
    b758:	00001606 	br	b7b4 <pbuf_memcmp+0xf4>
      u8_t a = pbuf_get_at(q, start + i);
    b75c:	e0fff90b 	ldhu	r3,-28(fp)
    b760:	e0bffb0b 	ldhu	r2,-20(fp)
    b764:	1885883a 	add	r2,r3,r2
    b768:	10bfffcc 	andi	r2,r2,65535
    b76c:	e13ffa17 	ldw	r4,-24(fp)
    b770:	100b883a 	mov	r5,r2
    b774:	000b6100 	call	b610 <pbuf_get_at>
    b778:	e0bffb85 	stb	r2,-18(fp)
      u8_t b = ((u8_t*)s2)[i];
    b77c:	e0bffb0b 	ldhu	r2,-20(fp)
    b780:	e0fffe17 	ldw	r3,-8(fp)
    b784:	1885883a 	add	r2,r3,r2
    b788:	10800003 	ldbu	r2,0(r2)
    b78c:	e0bffbc5 	stb	r2,-17(fp)
      if (a != b) {
    b790:	e0fffb83 	ldbu	r3,-18(fp)
    b794:	e0bffbc3 	ldbu	r2,-17(fp)
    b798:	18800326 	beq	r3,r2,b7a8 <pbuf_memcmp+0xe8>
        return i+1;
    b79c:	e0bffb0b 	ldhu	r2,-20(fp)
    b7a0:	10800044 	addi	r2,r2,1
    b7a4:	00000906 	br	b7cc <pbuf_memcmp+0x10c>
    q = q->next;
  }
  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > start)) {
    u16_t i;
    for(i = 0; i < n; i++) {
    b7a8:	e0bffb0b 	ldhu	r2,-20(fp)
    b7ac:	10800044 	addi	r2,r2,1
    b7b0:	e0bffb0d 	sth	r2,-20(fp)
    b7b4:	e0fffb0b 	ldhu	r3,-20(fp)
    b7b8:	e0bfff0b 	ldhu	r2,-4(fp)
    b7bc:	18bfe736 	bltu	r3,r2,b75c <pbuf_memcmp+0x9c>
      u8_t b = ((u8_t*)s2)[i];
      if (a != b) {
        return i+1;
      }
    }
    return 0;
    b7c0:	0005883a 	mov	r2,zero
    b7c4:	00000106 	br	b7cc <pbuf_memcmp+0x10c>
  }
  return 0xffff;
    b7c8:	00bfffc4 	movi	r2,-1
}
    b7cc:	e037883a 	mov	sp,fp
    b7d0:	dfc00117 	ldw	ra,4(sp)
    b7d4:	df000017 	ldw	fp,0(sp)
    b7d8:	dec00204 	addi	sp,sp,8
    b7dc:	f800283a 	ret

0000b7e0 <pbuf_memfind>:
 * @param start_offset offset into p at which to start searching
 * @return 0xFFFF if substr was not found in p or the index where it was found
 */
u16_t
pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
{
    b7e0:	defff804 	addi	sp,sp,-32
    b7e4:	dfc00715 	stw	ra,28(sp)
    b7e8:	df000615 	stw	fp,24(sp)
    b7ec:	df000604 	addi	fp,sp,24
    b7f0:	e13ffc15 	stw	r4,-16(fp)
    b7f4:	e17ffd15 	stw	r5,-12(fp)
    b7f8:	3007883a 	mov	r3,r6
    b7fc:	3805883a 	mov	r2,r7
    b800:	e0fffe0d 	sth	r3,-8(fp)
    b804:	e0bfff0d 	sth	r2,-4(fp)
  u16_t i;
  u16_t max = p->tot_len - mem_len;
    b808:	e0bffc17 	ldw	r2,-16(fp)
    b80c:	10c0020b 	ldhu	r3,8(r2)
    b810:	e0bffe0b 	ldhu	r2,-8(fp)
    b814:	1885c83a 	sub	r2,r3,r2
    b818:	e0bffa8d 	sth	r2,-22(fp)
  if (p->tot_len >= mem_len + start_offset) {
    b81c:	e0bffc17 	ldw	r2,-16(fp)
    b820:	1080020b 	ldhu	r2,8(r2)
    b824:	10ffffcc 	andi	r3,r2,65535
    b828:	e13ffe0b 	ldhu	r4,-8(fp)
    b82c:	e0bfff0b 	ldhu	r2,-4(fp)
    b830:	2085883a 	add	r2,r4,r2
    b834:	18801616 	blt	r3,r2,b890 <pbuf_memfind+0xb0>
    for(i = start_offset; i <= max; ) {
    b838:	e0bfff0b 	ldhu	r2,-4(fp)
    b83c:	e0bffa0d 	sth	r2,-24(fp)
    b840:	00001006 	br	b884 <pbuf_memfind+0xa4>
      u16_t plus = pbuf_memcmp(p, i, mem, mem_len);
    b844:	e0fffa0b 	ldhu	r3,-24(fp)
    b848:	e0bffe0b 	ldhu	r2,-8(fp)
    b84c:	e13ffc17 	ldw	r4,-16(fp)
    b850:	180b883a 	mov	r5,r3
    b854:	e1bffd17 	ldw	r6,-12(fp)
    b858:	100f883a 	mov	r7,r2
    b85c:	000b6c00 	call	b6c0 <pbuf_memcmp>
    b860:	e0bffb0d 	sth	r2,-20(fp)
      if (plus == 0) {
    b864:	e0bffb0b 	ldhu	r2,-20(fp)
    b868:	1000021e 	bne	r2,zero,b874 <pbuf_memfind+0x94>
        return i;
    b86c:	e0bffa0b 	ldhu	r2,-24(fp)
    b870:	00000806 	br	b894 <pbuf_memfind+0xb4>
      } else {
        i += plus;
    b874:	e0fffa0b 	ldhu	r3,-24(fp)
    b878:	e0bffb0b 	ldhu	r2,-20(fp)
    b87c:	1885883a 	add	r2,r3,r2
    b880:	e0bffa0d 	sth	r2,-24(fp)
pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
{
  u16_t i;
  u16_t max = p->tot_len - mem_len;
  if (p->tot_len >= mem_len + start_offset) {
    for(i = start_offset; i <= max; ) {
    b884:	e0bffa0b 	ldhu	r2,-24(fp)
    b888:	e0fffa8b 	ldhu	r3,-22(fp)
    b88c:	18bfed2e 	bgeu	r3,r2,b844 <pbuf_memfind+0x64>
      } else {
        i += plus;
      }
    }
  }
  return 0xFFFF;
    b890:	00bfffc4 	movi	r2,-1
}
    b894:	e037883a 	mov	sp,fp
    b898:	dfc00117 	ldw	ra,4(sp)
    b89c:	df000017 	ldw	fp,0(sp)
    b8a0:	dec00204 	addi	sp,sp,8
    b8a4:	f800283a 	ret

0000b8a8 <pbuf_strstr>:
 * @param substr string to search for in p, maximum length is 0xFFFE
 * @return 0xFFFF if substr was not found in p or the index where it was found
 */
u16_t
pbuf_strstr(struct pbuf* p, const char* substr)
{
    b8a8:	defffb04 	addi	sp,sp,-20
    b8ac:	dfc00415 	stw	ra,16(sp)
    b8b0:	df000315 	stw	fp,12(sp)
    b8b4:	df000304 	addi	fp,sp,12
    b8b8:	e13ffe15 	stw	r4,-8(fp)
    b8bc:	e17fff15 	stw	r5,-4(fp)
  size_t substr_len;
  if ((substr == NULL) || (substr[0] == 0) || (p->tot_len == 0xFFFF)) {
    b8c0:	e0bfff17 	ldw	r2,-4(fp)
    b8c4:	10000b26 	beq	r2,zero,b8f4 <pbuf_strstr+0x4c>
    b8c8:	e0bfff17 	ldw	r2,-4(fp)
    b8cc:	10800003 	ldbu	r2,0(r2)
    b8d0:	10803fcc 	andi	r2,r2,255
    b8d4:	1080201c 	xori	r2,r2,128
    b8d8:	10bfe004 	addi	r2,r2,-128
    b8dc:	10000526 	beq	r2,zero,b8f4 <pbuf_strstr+0x4c>
    b8e0:	e0bffe17 	ldw	r2,-8(fp)
    b8e4:	1080020b 	ldhu	r2,8(r2)
    b8e8:	10ffffcc 	andi	r3,r2,65535
    b8ec:	00bfffd4 	movui	r2,65535
    b8f0:	1880021e 	bne	r3,r2,b8fc <pbuf_strstr+0x54>
    return 0xFFFF;
    b8f4:	00bfffc4 	movi	r2,-1
    b8f8:	00000f06 	br	b938 <pbuf_strstr+0x90>
  }
  substr_len = strlen(substr);
    b8fc:	e13fff17 	ldw	r4,-4(fp)
    b900:	00197140 	call	19714 <strlen>
    b904:	e0bffd15 	stw	r2,-12(fp)
  if (substr_len >= 0xFFFF) {
    b908:	e0bffd17 	ldw	r2,-12(fp)
    b90c:	10bffff0 	cmpltui	r2,r2,65535
    b910:	1000021e 	bne	r2,zero,b91c <pbuf_strstr+0x74>
    return 0xFFFF;
    b914:	00bfffc4 	movi	r2,-1
    b918:	00000706 	br	b938 <pbuf_strstr+0x90>
  }
  return pbuf_memfind(p, substr, (u16_t)substr_len, 0);
    b91c:	e0bffd17 	ldw	r2,-12(fp)
    b920:	10bfffcc 	andi	r2,r2,65535
    b924:	e13ffe17 	ldw	r4,-8(fp)
    b928:	e17fff17 	ldw	r5,-4(fp)
    b92c:	100d883a 	mov	r6,r2
    b930:	000f883a 	mov	r7,zero
    b934:	000b7e00 	call	b7e0 <pbuf_memfind>
}
    b938:	e037883a 	mov	sp,fp
    b93c:	dfc00117 	ldw	ra,4(sp)
    b940:	df000017 	ldw	fp,0(sp)
    b944:	dec00204 	addi	sp,sp,8
    b948:	f800283a 	ret

0000b94c <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
    b94c:	defff704 	addi	sp,sp,-36
    b950:	dfc00815 	stw	ra,32(sp)
    b954:	df000715 	stw	fp,28(sp)
    b958:	df000704 	addi	fp,sp,28
    b95c:	e13ffe15 	stw	r4,-8(fp)
    b960:	e17fff15 	stw	r5,-4(fp)
  struct raw_pcb *pcb, *prev;
  struct ip_hdr *iphdr;
  s16_t proto;
  u8_t eaten = 0;
    b964:	e03ffb05 	stb	zero,-20(fp)

  LWIP_UNUSED_ARG(inp);

  iphdr = (struct ip_hdr *)p->payload;
    b968:	e0bffe17 	ldw	r2,-8(fp)
    b96c:	10800117 	ldw	r2,4(r2)
    b970:	e0bffc15 	stw	r2,-16(fp)
  proto = IPH_PROTO(iphdr);
    b974:	e0bffc17 	ldw	r2,-16(fp)
    b978:	10800243 	ldbu	r2,9(r2)
    b97c:	10803fcc 	andi	r2,r2,255
    b980:	e0bffd0d 	sth	r2,-12(fp)

  prev = NULL;
    b984:	e03ffa15 	stw	zero,-24(fp)
  pcb = raw_pcbs;
    b988:	d0a8ba17 	ldw	r2,-23832(gp)
    b98c:	e0bff915 	stw	r2,-28(fp)
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    b990:	00003206 	br	ba5c <raw_input+0x110>
    if ((pcb->protocol == proto) &&
    b994:	e0bff917 	ldw	r2,-28(fp)
    b998:	10800403 	ldbu	r2,16(r2)
    b99c:	10c03fcc 	andi	r3,r2,255
    b9a0:	e0bffd0f 	ldh	r2,-12(fp)
    b9a4:	1880281e 	bne	r3,r2,ba48 <raw_input+0xfc>
        (ip_addr_isany(&pcb->local_ip) ||
    b9a8:	e0bff917 	ldw	r2,-28(fp)
  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if ((pcb->protocol == proto) &&
    b9ac:	10000926 	beq	r2,zero,b9d4 <raw_input+0x88>
        (ip_addr_isany(&pcb->local_ip) ||
    b9b0:	e0bff917 	ldw	r2,-28(fp)
    b9b4:	10800017 	ldw	r2,0(r2)
    b9b8:	10000626 	beq	r2,zero,b9d4 <raw_input+0x88>
         ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest))) {
    b9bc:	e0bff917 	ldw	r2,-28(fp)
    b9c0:	10c00017 	ldw	r3,0(r2)
    b9c4:	008000f4 	movhi	r2,3
    b9c8:	109e2104 	addi	r2,r2,30852
    b9cc:	10800017 	ldw	r2,0(r2)
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if ((pcb->protocol == proto) &&
        (ip_addr_isany(&pcb->local_ip) ||
    b9d0:	18801d1e 	bne	r3,r2,ba48 <raw_input+0xfc>
      /* broadcast filter? */
      if (ip_get_option(pcb, SOF_BROADCAST) || !ip_addr_isbroadcast(&current_iphdr_dest, inp))
#endif /* IP_SOF_BROADCAST_RECV */
      {
        /* receive callback function available? */
        if (pcb->recv != NULL) {
    b9d4:	e0bff917 	ldw	r2,-28(fp)
    b9d8:	10800517 	ldw	r2,20(r2)
    b9dc:	10001a26 	beq	r2,zero,ba48 <raw_input+0xfc>
          /* the receive callback function did not eat the packet? */
          if (pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr()) != 0) {
    b9e0:	e0bff917 	ldw	r2,-28(fp)
    b9e4:	10c00517 	ldw	r3,20(r2)
    b9e8:	e0bff917 	ldw	r2,-28(fp)
    b9ec:	10800617 	ldw	r2,24(r2)
    b9f0:	1009883a 	mov	r4,r2
    b9f4:	e17ff917 	ldw	r5,-28(fp)
    b9f8:	e1bffe17 	ldw	r6,-8(fp)
    b9fc:	01c000f4 	movhi	r7,3
    ba00:	39de1f04 	addi	r7,r7,30844
    ba04:	183ee83a 	callr	r3
    ba08:	10803fcc 	andi	r2,r2,255
    ba0c:	10000e26 	beq	r2,zero,ba48 <raw_input+0xfc>
            /* receive function ate the packet */
            p = NULL;
    ba10:	e03ffe15 	stw	zero,-8(fp)
            eaten = 1;
    ba14:	00800044 	movi	r2,1
    ba18:	e0bffb05 	stb	r2,-20(fp)
            if (prev != NULL) {
    ba1c:	e0bffa17 	ldw	r2,-24(fp)
    ba20:	10000926 	beq	r2,zero,ba48 <raw_input+0xfc>
            /* move the pcb to the front of raw_pcbs so that is
               found faster next time */
              prev->next = pcb->next;
    ba24:	e0bff917 	ldw	r2,-28(fp)
    ba28:	10c00317 	ldw	r3,12(r2)
    ba2c:	e0bffa17 	ldw	r2,-24(fp)
    ba30:	10c00315 	stw	r3,12(r2)
              pcb->next = raw_pcbs;
    ba34:	d0e8ba17 	ldw	r3,-23832(gp)
    ba38:	e0bff917 	ldw	r2,-28(fp)
    ba3c:	10c00315 	stw	r3,12(r2)
              raw_pcbs = pcb;
    ba40:	e0bff917 	ldw	r2,-28(fp)
    ba44:	d0a8ba15 	stw	r2,-23832(gp)
        }
        /* no receive callback function was set for this raw PCB */
      }
      /* drop the packet */
    }
    prev = pcb;
    ba48:	e0bff917 	ldw	r2,-28(fp)
    ba4c:	e0bffa15 	stw	r2,-24(fp)
    pcb = pcb->next;
    ba50:	e0bff917 	ldw	r2,-28(fp)
    ba54:	10800317 	ldw	r2,12(r2)
    ba58:	e0bff915 	stw	r2,-28(fp)

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    ba5c:	e0bffb03 	ldbu	r2,-20(fp)
    ba60:	1000021e 	bne	r2,zero,ba6c <raw_input+0x120>
    ba64:	e0bff917 	ldw	r2,-28(fp)
    ba68:	103fca1e 	bne	r2,zero,b994 <raw_input+0x48>
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
    ba6c:	e0bffb03 	ldbu	r2,-20(fp)
}
    ba70:	e037883a 	mov	sp,fp
    ba74:	dfc00117 	ldw	ra,4(sp)
    ba78:	df000017 	ldw	fp,0(sp)
    ba7c:	dec00204 	addi	sp,sp,8
    ba80:	f800283a 	ret

0000ba84 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, ip_addr_t *ipaddr)
{
    ba84:	defffd04 	addi	sp,sp,-12
    ba88:	df000215 	stw	fp,8(sp)
    ba8c:	df000204 	addi	fp,sp,8
    ba90:	e13ffe15 	stw	r4,-8(fp)
    ba94:	e17fff15 	stw	r5,-4(fp)
  ip_addr_set(&pcb->local_ip, ipaddr);
    ba98:	e0bfff17 	ldw	r2,-4(fp)
    ba9c:	10000326 	beq	r2,zero,baac <raw_bind+0x28>
    baa0:	e0bfff17 	ldw	r2,-4(fp)
    baa4:	10800017 	ldw	r2,0(r2)
    baa8:	00000106 	br	bab0 <raw_bind+0x2c>
    baac:	0005883a 	mov	r2,zero
    bab0:	e0fffe17 	ldw	r3,-8(fp)
    bab4:	18800015 	stw	r2,0(r3)
  return ERR_OK;
    bab8:	0005883a 	mov	r2,zero
}
    babc:	e037883a 	mov	sp,fp
    bac0:	df000017 	ldw	fp,0(sp)
    bac4:	dec00104 	addi	sp,sp,4
    bac8:	f800283a 	ret

0000bacc <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, ip_addr_t *ipaddr)
{
    bacc:	defffd04 	addi	sp,sp,-12
    bad0:	df000215 	stw	fp,8(sp)
    bad4:	df000204 	addi	fp,sp,8
    bad8:	e13ffe15 	stw	r4,-8(fp)
    badc:	e17fff15 	stw	r5,-4(fp)
  ip_addr_set(&pcb->remote_ip, ipaddr);
    bae0:	e0bfff17 	ldw	r2,-4(fp)
    bae4:	10000326 	beq	r2,zero,baf4 <raw_connect+0x28>
    bae8:	e0bfff17 	ldw	r2,-4(fp)
    baec:	10800017 	ldw	r2,0(r2)
    baf0:	00000106 	br	baf8 <raw_connect+0x2c>
    baf4:	0005883a 	mov	r2,zero
    baf8:	e0fffe17 	ldw	r3,-8(fp)
    bafc:	18800115 	stw	r2,4(r3)
  return ERR_OK;
    bb00:	0005883a 	mov	r2,zero
}
    bb04:	e037883a 	mov	sp,fp
    bb08:	df000017 	ldw	fp,0(sp)
    bb0c:	dec00104 	addi	sp,sp,4
    bb10:	f800283a 	ret

0000bb14 <raw_recv>:
 * @return non-zero if the packet was free()d, zero if the packet remains
 * available for others.
 */
void
raw_recv(struct raw_pcb *pcb, raw_recv_fn recv, void *recv_arg)
{
    bb14:	defffc04 	addi	sp,sp,-16
    bb18:	df000315 	stw	fp,12(sp)
    bb1c:	df000304 	addi	fp,sp,12
    bb20:	e13ffd15 	stw	r4,-12(fp)
    bb24:	e17ffe15 	stw	r5,-8(fp)
    bb28:	e1bfff15 	stw	r6,-4(fp)
  /* remember recv() callback and user data */
  pcb->recv = recv;
    bb2c:	e0bffd17 	ldw	r2,-12(fp)
    bb30:	e0fffe17 	ldw	r3,-8(fp)
    bb34:	10c00515 	stw	r3,20(r2)
  pcb->recv_arg = recv_arg;
    bb38:	e0bffd17 	ldw	r2,-12(fp)
    bb3c:	e0ffff17 	ldw	r3,-4(fp)
    bb40:	10c00615 	stw	r3,24(r2)
}
    bb44:	e037883a 	mov	sp,fp
    bb48:	df000017 	ldw	fp,0(sp)
    bb4c:	dec00104 	addi	sp,sp,4
    bb50:	f800283a 	ret

0000bb54 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, ip_addr_t *ipaddr)
{
    bb54:	defff404 	addi	sp,sp,-48
    bb58:	dfc00b15 	stw	ra,44(sp)
    bb5c:	df000a15 	stw	fp,40(sp)
    bb60:	df000a04 	addi	fp,sp,40
    bb64:	e13ffd15 	stw	r4,-12(fp)
    bb68:	e17ffe15 	stw	r5,-8(fp)
    bb6c:	e1bfff15 	stw	r6,-4(fp)
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
    bb70:	e13ffe17 	ldw	r4,-8(fp)
    bb74:	01400504 	movi	r5,20
    bb78:	000a83c0 	call	a83c <pbuf_header>
    bb7c:	10803fcc 	andi	r2,r2,255
    bb80:	10001126 	beq	r2,zero,bbc8 <raw_sendto+0x74>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
    bb84:	01000044 	movi	r4,1
    bb88:	000b883a 	mov	r5,zero
    bb8c:	000d883a 	mov	r6,zero
    bb90:	000a0740 	call	a074 <pbuf_alloc>
    bb94:	e0bffa15 	stw	r2,-24(fp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
    bb98:	e0bffa17 	ldw	r2,-24(fp)
    bb9c:	1000021e 	bne	r2,zero,bba8 <raw_sendto+0x54>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    bba0:	00bfffc4 	movi	r2,-1
    bba4:	00004806 	br	bcc8 <raw_sendto+0x174>
    }
    if (p->tot_len != 0) {
    bba8:	e0bffe17 	ldw	r2,-8(fp)
    bbac:	1080020b 	ldhu	r2,8(r2)
    bbb0:	10bfffcc 	andi	r2,r2,65535
    bbb4:	10001426 	beq	r2,zero,bc08 <raw_sendto+0xb4>
      /* chain header q in front of given pbuf p */
      pbuf_chain(q, p);
    bbb8:	e13ffa17 	ldw	r4,-24(fp)
    bbbc:	e17ffe17 	ldw	r5,-8(fp)
    bbc0:	000adcc0 	call	adcc <pbuf_chain>
    bbc4:	00001006 	br	bc08 <raw_sendto+0xb4>
    }
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
    bbc8:	e0bffe17 	ldw	r2,-8(fp)
    bbcc:	e0bffa15 	stw	r2,-24(fp)
    if(pbuf_header(q, -IP_HLEN)) {
    bbd0:	e13ffa17 	ldw	r4,-24(fp)
    bbd4:	017ffb04 	movi	r5,-20
    bbd8:	000a83c0 	call	a83c <pbuf_header>
    bbdc:	10803fcc 	andi	r2,r2,255
    bbe0:	10000926 	beq	r2,zero,bc08 <raw_sendto+0xb4>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
    bbe4:	010000f4 	movhi	r4,3
    bbe8:	2100c604 	addi	r4,r4,792
    bbec:	014000f4 	movhi	r5,3
    bbf0:	2940d004 	addi	r5,r5,832
    bbf4:	018039c4 	movi	r6,231
    bbf8:	01c000f4 	movhi	r7,3
    bbfc:	39c0da04 	addi	r7,r7,872
    bc00:	00193f00 	call	193f0 <printf>
    bc04:	003fff06 	br	bc04 <raw_sendto+0xb0>
      return ERR_MEM;
    }
  }

  if ((netif = ip_route(ipaddr)) == NULL) {
    bc08:	e13fff17 	ldw	r4,-4(fp)
    bc0c:	00062600 	call	6260 <ip_route>
    bc10:	e0bffb15 	stw	r2,-20(fp)
    bc14:	e0bffb17 	ldw	r2,-20(fp)
    bc18:	1000071e 	bne	r2,zero,bc38 <raw_sendto+0xe4>
    LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_LEVEL_WARNING, ("raw_sendto: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr)));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
    bc1c:	e0fffa17 	ldw	r3,-24(fp)
    bc20:	e0bffe17 	ldw	r2,-8(fp)
    bc24:	18800226 	beq	r3,r2,bc30 <raw_sendto+0xdc>
      pbuf_free(q);
    bc28:	e13ffa17 	ldw	r4,-24(fp)
    bc2c:	000aa340 	call	aa34 <pbuf_free>
    }
    return ERR_RTE;
    bc30:	00bfff04 	movi	r2,-4
    bc34:	00002406 	br	bcc8 <raw_sendto+0x174>
    }
    return ERR_VAL;
  }
#endif /* IP_SOF_BROADCAST */

  if (ip_addr_isany(&pcb->local_ip)) {
    bc38:	e0bffd17 	ldw	r2,-12(fp)
    bc3c:	10000326 	beq	r2,zero,bc4c <raw_sendto+0xf8>
    bc40:	e0bffd17 	ldw	r2,-12(fp)
    bc44:	10800017 	ldw	r2,0(r2)
    bc48:	1000041e 	bne	r2,zero,bc5c <raw_sendto+0x108>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
    bc4c:	e0bffb17 	ldw	r2,-20(fp)
    bc50:	10800104 	addi	r2,r2,4
    bc54:	e0bff915 	stw	r2,-28(fp)
    bc58:	00000206 	br	bc64 <raw_sendto+0x110>
  } else {
    /* use RAW PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
    bc5c:	e0bffd17 	ldw	r2,-12(fp)
    bc60:	e0bff915 	stw	r2,-28(fp)
  }

  NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
    bc64:	e0bffd17 	ldw	r2,-12(fp)
    bc68:	10800283 	ldbu	r2,10(r2)
    bc6c:	10803fcc 	andi	r2,r2,255
    bc70:	e0fffd17 	ldw	r3,-12(fp)
    bc74:	18c00243 	ldbu	r3,9(r3)
    bc78:	19003fcc 	andi	r4,r3,255
    bc7c:	e0fffd17 	ldw	r3,-12(fp)
    bc80:	18c00403 	ldbu	r3,16(r3)
    bc84:	18c03fcc 	andi	r3,r3,255
    bc88:	d9000015 	stw	r4,0(sp)
    bc8c:	d8c00115 	stw	r3,4(sp)
    bc90:	e0fffb17 	ldw	r3,-20(fp)
    bc94:	d8c00215 	stw	r3,8(sp)
    bc98:	e13ffa17 	ldw	r4,-24(fp)
    bc9c:	e17ff917 	ldw	r5,-28(fp)
    bca0:	e1bfff17 	ldw	r6,-4(fp)
    bca4:	100f883a 	mov	r7,r2
    bca8:	00068540 	call	6854 <ip_output_if>
    bcac:	e0bffc05 	stb	r2,-16(fp)
  NETIF_SET_HWADDRHINT(netif, NULL);

  /* did we chain a header earlier? */
  if (q != p) {
    bcb0:	e0fffa17 	ldw	r3,-24(fp)
    bcb4:	e0bffe17 	ldw	r2,-8(fp)
    bcb8:	18800226 	beq	r3,r2,bcc4 <raw_sendto+0x170>
    /* free the header */
    pbuf_free(q);
    bcbc:	e13ffa17 	ldw	r4,-24(fp)
    bcc0:	000aa340 	call	aa34 <pbuf_free>
  }
  return err;
    bcc4:	e0bffc03 	ldbu	r2,-16(fp)
}
    bcc8:	e037883a 	mov	sp,fp
    bccc:	dfc00117 	ldw	ra,4(sp)
    bcd0:	df000017 	ldw	fp,0(sp)
    bcd4:	dec00204 	addi	sp,sp,8
    bcd8:	f800283a 	ret

0000bcdc <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
    bcdc:	defffc04 	addi	sp,sp,-16
    bce0:	dfc00315 	stw	ra,12(sp)
    bce4:	df000215 	stw	fp,8(sp)
    bce8:	df000204 	addi	fp,sp,8
    bcec:	e13ffe15 	stw	r4,-8(fp)
    bcf0:	e17fff15 	stw	r5,-4(fp)
  return raw_sendto(pcb, p, &pcb->remote_ip);
    bcf4:	e0bffe17 	ldw	r2,-8(fp)
    bcf8:	10800104 	addi	r2,r2,4
    bcfc:	e13ffe17 	ldw	r4,-8(fp)
    bd00:	e17fff17 	ldw	r5,-4(fp)
    bd04:	100d883a 	mov	r6,r2
    bd08:	000bb540 	call	bb54 <raw_sendto>
}
    bd0c:	e037883a 	mov	sp,fp
    bd10:	dfc00117 	ldw	ra,4(sp)
    bd14:	df000017 	ldw	fp,0(sp)
    bd18:	dec00204 	addi	sp,sp,8
    bd1c:	f800283a 	ret

0000bd20 <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
    bd20:	defffc04 	addi	sp,sp,-16
    bd24:	dfc00315 	stw	ra,12(sp)
    bd28:	df000215 	stw	fp,8(sp)
    bd2c:	df000204 	addi	fp,sp,8
    bd30:	e13fff15 	stw	r4,-4(fp)
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
    bd34:	d0e8ba17 	ldw	r3,-23832(gp)
    bd38:	e0bfff17 	ldw	r2,-4(fp)
    bd3c:	1880041e 	bne	r3,r2,bd50 <raw_remove+0x30>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    bd40:	d0a8ba17 	ldw	r2,-23832(gp)
    bd44:	10800317 	ldw	r2,12(r2)
    bd48:	d0a8ba15 	stw	r2,-23832(gp)
    bd4c:	00001306 	br	bd9c <raw_remove+0x7c>
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
    bd50:	d0a8ba17 	ldw	r2,-23832(gp)
    bd54:	e0bffe15 	stw	r2,-8(fp)
    bd58:	00000e06 	br	bd94 <raw_remove+0x74>
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
    bd5c:	e0bffe17 	ldw	r2,-8(fp)
    bd60:	10800317 	ldw	r2,12(r2)
    bd64:	10000826 	beq	r2,zero,bd88 <raw_remove+0x68>
    bd68:	e0bffe17 	ldw	r2,-8(fp)
    bd6c:	10c00317 	ldw	r3,12(r2)
    bd70:	e0bfff17 	ldw	r2,-4(fp)
    bd74:	1880041e 	bne	r3,r2,bd88 <raw_remove+0x68>
        /* remove pcb from list */
        pcb2->next = pcb->next;
    bd78:	e0bfff17 	ldw	r2,-4(fp)
    bd7c:	10c00317 	ldw	r3,12(r2)
    bd80:	e0bffe17 	ldw	r2,-8(fp)
    bd84:	10c00315 	stw	r3,12(r2)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
    bd88:	e0bffe17 	ldw	r2,-8(fp)
    bd8c:	10800317 	ldw	r2,12(r2)
    bd90:	e0bffe15 	stw	r2,-8(fp)
    bd94:	e0bffe17 	ldw	r2,-8(fp)
    bd98:	103ff01e 	bne	r2,zero,bd5c <raw_remove+0x3c>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
    bd9c:	0009883a 	mov	r4,zero
    bda0:	e17fff17 	ldw	r5,-4(fp)
    bda4:	00097d40 	call	97d4 <memp_free>
}
    bda8:	e037883a 	mov	sp,fp
    bdac:	dfc00117 	ldw	ra,4(sp)
    bdb0:	df000017 	ldw	fp,0(sp)
    bdb4:	dec00204 	addi	sp,sp,8
    bdb8:	f800283a 	ret

0000bdbc <raw_new>:
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto)
{
    bdbc:	defffc04 	addi	sp,sp,-16
    bdc0:	dfc00315 	stw	ra,12(sp)
    bdc4:	df000215 	stw	fp,8(sp)
    bdc8:	df000204 	addi	fp,sp,8
    bdcc:	2005883a 	mov	r2,r4
    bdd0:	e0bfff05 	stb	r2,-4(fp)
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_new\n"));

  pcb = (struct raw_pcb *)memp_malloc(MEMP_RAW_PCB);
    bdd4:	0009883a 	mov	r4,zero
    bdd8:	00095f80 	call	95f8 <memp_malloc>
    bddc:	e0bffe15 	stw	r2,-8(fp)
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
    bde0:	e0bffe17 	ldw	r2,-8(fp)
    bde4:	10000f26 	beq	r2,zero,be24 <raw_new+0x68>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
    bde8:	e13ffe17 	ldw	r4,-8(fp)
    bdec:	000b883a 	mov	r5,zero
    bdf0:	01800704 	movi	r6,28
    bdf4:	00192e80 	call	192e8 <memset>
    pcb->protocol = proto;
    bdf8:	e0bffe17 	ldw	r2,-8(fp)
    bdfc:	e0ffff03 	ldbu	r3,-4(fp)
    be00:	10c00405 	stb	r3,16(r2)
    pcb->ttl = RAW_TTL;
    be04:	e0bffe17 	ldw	r2,-8(fp)
    be08:	00ffffc4 	movi	r3,-1
    be0c:	10c00285 	stb	r3,10(r2)
    pcb->next = raw_pcbs;
    be10:	d0e8ba17 	ldw	r3,-23832(gp)
    be14:	e0bffe17 	ldw	r2,-8(fp)
    be18:	10c00315 	stw	r3,12(r2)
    raw_pcbs = pcb;
    be1c:	e0bffe17 	ldw	r2,-8(fp)
    be20:	d0a8ba15 	stw	r2,-23832(gp)
  }
  return pcb;
    be24:	e0bffe17 	ldw	r2,-8(fp)
}
    be28:	e037883a 	mov	sp,fp
    be2c:	dfc00117 	ldw	ra,4(sp)
    be30:	df000017 	ldw	fp,0(sp)
    be34:	dec00204 	addi	sp,sp,8
    be38:	f800283a 	ret

0000be3c <stats_init>:
#include <string.h>

struct stats_ lwip_stats;

void stats_init(void)
{
    be3c:	deffff04 	addi	sp,sp,-4
    be40:	df000015 	stw	fp,0(sp)
    be44:	d839883a 	mov	fp,sp
#endif /* MEMP_STATS */
#if MEM_STATS
  lwip_stats.mem.name = "MEM";
#endif /* MEM_STATS */
#endif /* LWIP_DEBUG */
}
    be48:	e037883a 	mov	sp,fp
    be4c:	df000017 	ldw	fp,0(sp)
    be50:	dec00104 	addi	sp,sp,4
    be54:	f800283a 	ret

0000be58 <tcp_init>:
/**
 * Initialize this module.
 */
void
tcp_init(void)
{
    be58:	deffff04 	addi	sp,sp,-4
    be5c:	df000015 	stw	fp,0(sp)
    be60:	d839883a 	mov	fp,sp
#if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
  tcp_port = TCP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
#endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
}
    be64:	e037883a 	mov	sp,fp
    be68:	df000017 	ldw	fp,0(sp)
    be6c:	dec00104 	addi	sp,sp,4
    be70:	f800283a 	ret

0000be74 <tcp_tmr>:
/**
 * Called periodically to dispatch TCP timers.
 */
void
tcp_tmr(void)
{
    be74:	defffe04 	addi	sp,sp,-8
    be78:	dfc00115 	stw	ra,4(sp)
    be7c:	df000015 	stw	fp,0(sp)
    be80:	d839883a 	mov	fp,sp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
    be84:	000d7700 	call	d770 <tcp_fasttmr>

  if (++tcp_timer & 1) {
    be88:	d0a8bb03 	ldbu	r2,-23828(gp)
    be8c:	10800044 	addi	r2,r2,1
    be90:	d0a8bb05 	stb	r2,-23828(gp)
    be94:	d0a8bb03 	ldbu	r2,-23828(gp)
    be98:	10803fcc 	andi	r2,r2,255
    be9c:	1080004c 	andi	r2,r2,1
    bea0:	10000126 	beq	r2,zero,bea8 <tcp_tmr+0x34>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
    bea4:	000cec40 	call	cec4 <tcp_slowtmr>
  }
}
    bea8:	e037883a 	mov	sp,fp
    beac:	dfc00117 	ldw	ra,4(sp)
    beb0:	df000017 	ldw	fp,0(sp)
    beb4:	dec00204 	addi	sp,sp,8
    beb8:	f800283a 	ret

0000bebc <tcp_close_shutdown>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
static err_t
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
    bebc:	defff904 	addi	sp,sp,-28
    bec0:	dfc00615 	stw	ra,24(sp)
    bec4:	df000515 	stw	fp,20(sp)
    bec8:	df000504 	addi	fp,sp,20
    becc:	e13ffe15 	stw	r4,-8(fp)
    bed0:	2805883a 	mov	r2,r5
    bed4:	e0bfff05 	stb	r2,-4(fp)
  err_t err;

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
    bed8:	e0bfff03 	ldbu	r2,-4(fp)
    bedc:	10006126 	beq	r2,zero,c064 <tcp_close_shutdown+0x1a8>
    bee0:	e0bffe17 	ldw	r2,-8(fp)
    bee4:	10800617 	ldw	r2,24(r2)
    bee8:	10800120 	cmpeqi	r2,r2,4
    beec:	1000041e 	bne	r2,zero,bf00 <tcp_close_shutdown+0x44>
    bef0:	e0bffe17 	ldw	r2,-8(fp)
    bef4:	10800617 	ldw	r2,24(r2)
    bef8:	108001d8 	cmpnei	r2,r2,7
    befc:	1000591e 	bne	r2,zero,c064 <tcp_close_shutdown+0x1a8>
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
    bf00:	e0bffe17 	ldw	r2,-8(fp)
    bf04:	10801f17 	ldw	r2,124(r2)
    bf08:	1000051e 	bne	r2,zero,bf20 <tcp_close_shutdown+0x64>
    bf0c:	e0bffe17 	ldw	r2,-8(fp)
    bf10:	10800c0b 	ldhu	r2,48(r2)
    bf14:	10bfffcc 	andi	r2,r2,65535
    bf18:	10820020 	cmpeqi	r2,r2,2048
    bf1c:	1000511e 	bne	r2,zero,c064 <tcp_close_shutdown+0x1a8>
      /* Not all data received by application, send RST to tell the remote
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
    bf20:	e0bffe17 	ldw	r2,-8(fp)
    bf24:	10800883 	ldbu	r2,34(r2)
    bf28:	10803fcc 	andi	r2,r2,255
    bf2c:	1080040c 	andi	r2,r2,16
    bf30:	1000091e 	bne	r2,zero,bf58 <tcp_close_shutdown+0x9c>
    bf34:	010000f4 	movhi	r4,3
    bf38:	21011004 	addi	r4,r4,1088
    bf3c:	014000f4 	movhi	r5,3
    bf40:	29411a04 	addi	r5,r5,1128
    bf44:	01802c84 	movi	r6,178
    bf48:	01c000f4 	movhi	r7,3
    bf4c:	39c12104 	addi	r7,r7,1156
    bf50:	00193f00 	call	193f0 <printf>
    bf54:	003fff06 	br	bf54 <tcp_close_shutdown+0x98>

      /* don't call tcp_abort here: we must not deallocate the pcb since
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
    bf58:	e0bffe17 	ldw	r2,-8(fp)
    bf5c:	11001517 	ldw	r4,84(r2)
    bf60:	e0bffe17 	ldw	r2,-8(fp)
    bf64:	11400b17 	ldw	r5,44(r2)
    bf68:	e0fffe17 	ldw	r3,-8(fp)
    bf6c:	e0bffe17 	ldw	r2,-8(fp)
    bf70:	10800104 	addi	r2,r2,4
        pcb->local_port, pcb->remote_port);
    bf74:	e1bffe17 	ldw	r6,-8(fp)
    bf78:	3180078b 	ldhu	r6,30(r6)
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);

      /* don't call tcp_abort here: we must not deallocate the pcb since
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
    bf7c:	31ffffcc 	andi	r7,r6,65535
        pcb->local_port, pcb->remote_port);
    bf80:	e1bffe17 	ldw	r6,-8(fp)
    bf84:	3180080b 	ldhu	r6,32(r6)
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);

      /* don't call tcp_abort here: we must not deallocate the pcb since
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
    bf88:	31bfffcc 	andi	r6,r6,65535
    bf8c:	d9c00015 	stw	r7,0(sp)
    bf90:	d9800115 	stw	r6,4(sp)
    bf94:	180d883a 	mov	r6,r3
    bf98:	100f883a 	mov	r7,r2
    bf9c:	00146680 	call	14668 <tcp_rst>
        pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
    bfa0:	e13ffe17 	ldw	r4,-8(fp)
    bfa4:	000e1180 	call	e118 <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
    bfa8:	d0e8bc17 	ldw	r3,-23824(gp)
    bfac:	e0bffe17 	ldw	r2,-8(fp)
    bfb0:	1880041e 	bne	r3,r2,bfc4 <tcp_close_shutdown+0x108>
    bfb4:	d0a8bc17 	ldw	r2,-23824(gp)
    bfb8:	10800317 	ldw	r2,12(r2)
    bfbc:	d0a8bc15 	stw	r2,-23824(gp)
    bfc0:	00001106 	br	c008 <tcp_close_shutdown+0x14c>
    bfc4:	d0a8bc17 	ldw	r2,-23824(gp)
    bfc8:	d0a8bf15 	stw	r2,-23812(gp)
    bfcc:	00000c06 	br	c000 <tcp_close_shutdown+0x144>
    bfd0:	d0a8bf17 	ldw	r2,-23812(gp)
    bfd4:	10c00317 	ldw	r3,12(r2)
    bfd8:	e0bffe17 	ldw	r2,-8(fp)
    bfdc:	1880051e 	bne	r3,r2,bff4 <tcp_close_shutdown+0x138>
    bfe0:	d0a8bf17 	ldw	r2,-23812(gp)
    bfe4:	e0fffe17 	ldw	r3,-8(fp)
    bfe8:	18c00317 	ldw	r3,12(r3)
    bfec:	10c00315 	stw	r3,12(r2)
    bff0:	00000506 	br	c008 <tcp_close_shutdown+0x14c>
    bff4:	d0a8bf17 	ldw	r2,-23812(gp)
    bff8:	10800317 	ldw	r2,12(r2)
    bffc:	d0a8bf15 	stw	r2,-23812(gp)
    c000:	d0a8bf17 	ldw	r2,-23812(gp)
    c004:	103ff21e 	bne	r2,zero,bfd0 <tcp_close_shutdown+0x114>
    c008:	e0bffe17 	ldw	r2,-8(fp)
    c00c:	10000315 	stw	zero,12(r2)
    c010:	00800044 	movi	r2,1
    c014:	d0a8bb85 	stb	r2,-23826(gp)
      if (pcb->state == ESTABLISHED) {
    c018:	e0bffe17 	ldw	r2,-8(fp)
    c01c:	10800617 	ldw	r2,24(r2)
    c020:	10800118 	cmpnei	r2,r2,4
    c024:	10000a1e 	bne	r2,zero,c050 <tcp_close_shutdown+0x194>
        /* move to TIME_WAIT since we close actively */
        pcb->state = TIME_WAIT;
    c028:	e0bffe17 	ldw	r2,-8(fp)
    c02c:	00c00284 	movi	r3,10
    c030:	10c00615 	stw	r3,24(r2)
        TCP_REG(&tcp_tw_pcbs, pcb);
    c034:	d0e8c117 	ldw	r3,-23804(gp)
    c038:	e0bffe17 	ldw	r2,-8(fp)
    c03c:	10c00315 	stw	r3,12(r2)
    c040:	e0bffe17 	ldw	r2,-8(fp)
    c044:	d0a8c115 	stw	r2,-23804(gp)
    c048:	0014fd80 	call	14fd8 <tcp_timer_needed>
    c04c:	00000306 	br	c05c <tcp_close_shutdown+0x1a0>
      } else {
        /* CLOSE_WAIT: deallocate the pcb since we already sent a RST for it */
        memp_free(MEMP_TCP_PCB, pcb);
    c050:	01000084 	movi	r4,2
    c054:	e17ffe17 	ldw	r5,-8(fp)
    c058:	00097d40 	call	97d4 <memp_free>
      }
      return ERR_OK;
    c05c:	0005883a 	mov	r2,zero
    c060:	00007506 	br	c238 <tcp_close_shutdown+0x37c>
    }
  }

  switch (pcb->state) {
    c064:	e0bffe17 	ldw	r2,-8(fp)
    c068:	10800617 	ldw	r2,24(r2)
    c06c:	10c00228 	cmpgeui	r3,r2,8
    c070:	1800621e 	bne	r3,zero,c1fc <tcp_close_shutdown+0x340>
    c074:	1085883a 	add	r2,r2,r2
    c078:	1087883a 	add	r3,r2,r2
    c07c:	00800074 	movhi	r2,1
    c080:	10b02404 	addi	r2,r2,-16240
    c084:	1885883a 	add	r2,r3,r2
    c088:	10800017 	ldw	r2,0(r2)
    c08c:	1000683a 	jmp	r2
    c090:	0000c0b0 	cmpltui	zero,zero,770
    c094:	0000c140 	call	c14 <http_accept+0xdc>
    c098:	0000c164 	muli	zero,zero,773
    c09c:	0000c190 	cmplti	zero,zero,774
    c0a0:	0000c1b4 	movhi	zero,774
    c0a4:	0000c1fc 	xorhi	zero,zero,775
    c0a8:	0000c1fc 	xorhi	zero,zero,775
    c0ac:	0000c1d8 	cmpnei	zero,zero,775
     * and the user needs some way to free it should the need arise.
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    c0b0:	e03ffd05 	stb	zero,-12(fp)
    if (pcb->local_port != 0) {
    c0b4:	e0bffe17 	ldw	r2,-8(fp)
    c0b8:	1080078b 	ldhu	r2,30(r2)
    c0bc:	10bfffcc 	andi	r2,r2,65535
    c0c0:	10001a26 	beq	r2,zero,c12c <tcp_close_shutdown+0x270>
      TCP_RMV(&tcp_bound_pcbs, pcb);
    c0c4:	d0e8c017 	ldw	r3,-23808(gp)
    c0c8:	e0bffe17 	ldw	r2,-8(fp)
    c0cc:	1880041e 	bne	r3,r2,c0e0 <tcp_close_shutdown+0x224>
    c0d0:	d0a8c017 	ldw	r2,-23808(gp)
    c0d4:	10800317 	ldw	r2,12(r2)
    c0d8:	d0a8c015 	stw	r2,-23808(gp)
    c0dc:	00001106 	br	c124 <tcp_close_shutdown+0x268>
    c0e0:	d0a8c017 	ldw	r2,-23808(gp)
    c0e4:	d0a8bf15 	stw	r2,-23812(gp)
    c0e8:	00000c06 	br	c11c <tcp_close_shutdown+0x260>
    c0ec:	d0a8bf17 	ldw	r2,-23812(gp)
    c0f0:	10c00317 	ldw	r3,12(r2)
    c0f4:	e0bffe17 	ldw	r2,-8(fp)
    c0f8:	1880051e 	bne	r3,r2,c110 <tcp_close_shutdown+0x254>
    c0fc:	d0a8bf17 	ldw	r2,-23812(gp)
    c100:	e0fffe17 	ldw	r3,-8(fp)
    c104:	18c00317 	ldw	r3,12(r3)
    c108:	10c00315 	stw	r3,12(r2)
    c10c:	00000506 	br	c124 <tcp_close_shutdown+0x268>
    c110:	d0a8bf17 	ldw	r2,-23812(gp)
    c114:	10800317 	ldw	r2,12(r2)
    c118:	d0a8bf15 	stw	r2,-23812(gp)
    c11c:	d0a8bf17 	ldw	r2,-23812(gp)
    c120:	103ff21e 	bne	r2,zero,c0ec <tcp_close_shutdown+0x230>
    c124:	e0bffe17 	ldw	r2,-8(fp)
    c128:	10000315 	stw	zero,12(r2)
    }
    memp_free(MEMP_TCP_PCB, pcb);
    c12c:	01000084 	movi	r4,2
    c130:	e17ffe17 	ldw	r5,-8(fp)
    c134:	00097d40 	call	97d4 <memp_free>
    pcb = NULL;
    c138:	e03ffe15 	stw	zero,-8(fp)
    break;
    c13c:	00003706 	br	c21c <tcp_close_shutdown+0x360>
  case LISTEN:
    err = ERR_OK;
    c140:	e03ffd05 	stb	zero,-12(fp)
    tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
    c144:	d128be04 	addi	r4,gp,-23816
    c148:	e17ffe17 	ldw	r5,-8(fp)
    c14c:	000e1f40 	call	e1f4 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    c150:	010000c4 	movi	r4,3
    c154:	e17ffe17 	ldw	r5,-8(fp)
    c158:	00097d40 	call	97d4 <memp_free>
    pcb = NULL;
    c15c:	e03ffe15 	stw	zero,-8(fp)
    break;
    c160:	00002e06 	br	c21c <tcp_close_shutdown+0x360>
  case SYN_SENT:
    err = ERR_OK;
    c164:	e03ffd05 	stb	zero,-12(fp)
    TCP_PCB_REMOVE_ACTIVE(pcb);
    c168:	d128bc04 	addi	r4,gp,-23824
    c16c:	e17ffe17 	ldw	r5,-8(fp)
    c170:	000e1f40 	call	e1f4 <tcp_pcb_remove>
    c174:	00800044 	movi	r2,1
    c178:	d0a8bb85 	stb	r2,-23826(gp)
    memp_free(MEMP_TCP_PCB, pcb);
    c17c:	01000084 	movi	r4,2
    c180:	e17ffe17 	ldw	r5,-8(fp)
    c184:	00097d40 	call	97d4 <memp_free>
    pcb = NULL;
    c188:	e03ffe15 	stw	zero,-8(fp)
    snmp_inc_tcpattemptfails();
    break;
    c18c:	00002306 	br	c21c <tcp_close_shutdown+0x360>
  case SYN_RCVD:
    err = tcp_send_fin(pcb);
    c190:	e13ffe17 	ldw	r4,-8(fp)
    c194:	00125a00 	call	125a0 <tcp_send_fin>
    c198:	e0bffd05 	stb	r2,-12(fp)
    if (err == ERR_OK) {
    c19c:	e0bffd07 	ldb	r2,-12(fp)
    c1a0:	1000191e 	bne	r2,zero,c208 <tcp_close_shutdown+0x34c>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
    c1a4:	e0bffe17 	ldw	r2,-8(fp)
    c1a8:	00c00144 	movi	r3,5
    c1ac:	10c00615 	stw	r3,24(r2)
    }
    break;
    c1b0:	00001506 	br	c208 <tcp_close_shutdown+0x34c>
  case ESTABLISHED:
    err = tcp_send_fin(pcb);
    c1b4:	e13ffe17 	ldw	r4,-8(fp)
    c1b8:	00125a00 	call	125a0 <tcp_send_fin>
    c1bc:	e0bffd05 	stb	r2,-12(fp)
    if (err == ERR_OK) {
    c1c0:	e0bffd07 	ldb	r2,-12(fp)
    c1c4:	1000121e 	bne	r2,zero,c210 <tcp_close_shutdown+0x354>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
    c1c8:	e0bffe17 	ldw	r2,-8(fp)
    c1cc:	00c00144 	movi	r3,5
    c1d0:	10c00615 	stw	r3,24(r2)
    }
    break;
    c1d4:	00000e06 	br	c210 <tcp_close_shutdown+0x354>
  case CLOSE_WAIT:
    err = tcp_send_fin(pcb);
    c1d8:	e13ffe17 	ldw	r4,-8(fp)
    c1dc:	00125a00 	call	125a0 <tcp_send_fin>
    c1e0:	e0bffd05 	stb	r2,-12(fp)
    if (err == ERR_OK) {
    c1e4:	e0bffd07 	ldb	r2,-12(fp)
    c1e8:	10000b1e 	bne	r2,zero,c218 <tcp_close_shutdown+0x35c>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
    c1ec:	e0bffe17 	ldw	r2,-8(fp)
    c1f0:	00c00244 	movi	r3,9
    c1f4:	10c00615 	stw	r3,24(r2)
    }
    break;
    c1f8:	00000706 	br	c218 <tcp_close_shutdown+0x35c>
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
    c1fc:	e03ffd05 	stb	zero,-12(fp)
    pcb = NULL;
    c200:	e03ffe15 	stw	zero,-8(fp)
    break;
    c204:	00000506 	br	c21c <tcp_close_shutdown+0x360>
    err = tcp_send_fin(pcb);
    if (err == ERR_OK) {
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
    }
    break;
    c208:	0001883a 	nop
    c20c:	00000306 	br	c21c <tcp_close_shutdown+0x360>
    err = tcp_send_fin(pcb);
    if (err == ERR_OK) {
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
    }
    break;
    c210:	0001883a 	nop
    c214:	00000106 	br	c21c <tcp_close_shutdown+0x360>
    err = tcp_send_fin(pcb);
    if (err == ERR_OK) {
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
    }
    break;
    c218:	0001883a 	nop
    err = ERR_OK;
    pcb = NULL;
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
    c21c:	e0bffe17 	ldw	r2,-8(fp)
    c220:	10000426 	beq	r2,zero,c234 <tcp_close_shutdown+0x378>
    c224:	e0bffd07 	ldb	r2,-12(fp)
    c228:	1000021e 	bne	r2,zero,c234 <tcp_close_shutdown+0x378>
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent and acked before close returns.
       This can only be valid for sequential APIs, not for the raw API. */
    tcp_output(pcb);
    c22c:	e13ffe17 	ldw	r4,-8(fp)
    c230:	0013a740 	call	13a74 <tcp_output>
  }
  return err;
    c234:	e0bffd03 	ldbu	r2,-12(fp)
}
    c238:	e037883a 	mov	sp,fp
    c23c:	dfc00117 	ldw	ra,4(sp)
    c240:	df000017 	ldw	fp,0(sp)
    c244:	dec00204 	addi	sp,sp,8
    c248:	f800283a 	ret

0000c24c <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
    c24c:	defffd04 	addi	sp,sp,-12
    c250:	dfc00215 	stw	ra,8(sp)
    c254:	df000115 	stw	fp,4(sp)
    c258:	df000104 	addi	fp,sp,4
    c25c:	e13fff15 	stw	r4,-4(fp)
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  if (pcb->state != LISTEN) {
    c260:	e0bfff17 	ldw	r2,-4(fp)
    c264:	10800617 	ldw	r2,24(r2)
    c268:	10800060 	cmpeqi	r2,r2,1
    c26c:	1000061e 	bne	r2,zero,c288 <tcp_close+0x3c>
    /* Set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
    c270:	e0bfff17 	ldw	r2,-4(fp)
    c274:	10800883 	ldbu	r2,34(r2)
    c278:	10800414 	ori	r2,r2,16
    c27c:	1007883a 	mov	r3,r2
    c280:	e0bfff17 	ldw	r2,-4(fp)
    c284:	10c00885 	stb	r3,34(r2)
  }
  /* ... and close */
  return tcp_close_shutdown(pcb, 1);
    c288:	e13fff17 	ldw	r4,-4(fp)
    c28c:	01400044 	movi	r5,1
    c290:	000bebc0 	call	bebc <tcp_close_shutdown>
}
    c294:	e037883a 	mov	sp,fp
    c298:	dfc00117 	ldw	ra,4(sp)
    c29c:	df000017 	ldw	fp,0(sp)
    c2a0:	dec00204 	addi	sp,sp,8
    c2a4:	f800283a 	ret

0000c2a8 <tcp_shutdown>:
 * @return ERR_OK if shutdown succeeded (or the PCB has already been shut down)
 *         another err_t on error.
 */
err_t
tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx)
{
    c2a8:	defffb04 	addi	sp,sp,-20
    c2ac:	dfc00415 	stw	ra,16(sp)
    c2b0:	df000315 	stw	fp,12(sp)
    c2b4:	df000304 	addi	fp,sp,12
    c2b8:	e13ffd15 	stw	r4,-12(fp)
    c2bc:	e17ffe15 	stw	r5,-8(fp)
    c2c0:	e1bfff15 	stw	r6,-4(fp)
  if (pcb->state == LISTEN) {
    c2c4:	e0bffd17 	ldw	r2,-12(fp)
    c2c8:	10800617 	ldw	r2,24(r2)
    c2cc:	10800058 	cmpnei	r2,r2,1
    c2d0:	1000021e 	bne	r2,zero,c2dc <tcp_shutdown+0x34>
    return ERR_CONN;
    c2d4:	00bffcc4 	movi	r2,-13
    c2d8:	00002a06 	br	c384 <tcp_shutdown+0xdc>
  }
  if (shut_rx) {
    c2dc:	e0bffe17 	ldw	r2,-8(fp)
    c2e0:	10001526 	beq	r2,zero,c338 <tcp_shutdown+0x90>
    /* shut down the receive side: set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
    c2e4:	e0bffd17 	ldw	r2,-12(fp)
    c2e8:	10800883 	ldbu	r2,34(r2)
    c2ec:	10800414 	ori	r2,r2,16
    c2f0:	1007883a 	mov	r3,r2
    c2f4:	e0bffd17 	ldw	r2,-12(fp)
    c2f8:	10c00885 	stb	r3,34(r2)
    if (shut_tx) {
    c2fc:	e0bfff17 	ldw	r2,-4(fp)
    c300:	10000426 	beq	r2,zero,c314 <tcp_shutdown+0x6c>
      /* shutting down the tx AND rx side is the same as closing for the raw API */
      return tcp_close_shutdown(pcb, 1);
    c304:	e13ffd17 	ldw	r4,-12(fp)
    c308:	01400044 	movi	r5,1
    c30c:	000bebc0 	call	bebc <tcp_close_shutdown>
    c310:	00001c06 	br	c384 <tcp_shutdown+0xdc>
    }
    /* ... and free buffered data */
    if (pcb->refused_data != NULL) {
    c314:	e0bffd17 	ldw	r2,-12(fp)
    c318:	10801f17 	ldw	r2,124(r2)
    c31c:	10000626 	beq	r2,zero,c338 <tcp_shutdown+0x90>
      pbuf_free(pcb->refused_data);
    c320:	e0bffd17 	ldw	r2,-12(fp)
    c324:	10801f17 	ldw	r2,124(r2)
    c328:	1009883a 	mov	r4,r2
    c32c:	000aa340 	call	aa34 <pbuf_free>
      pcb->refused_data = NULL;
    c330:	e0bffd17 	ldw	r2,-12(fp)
    c334:	10001f15 	stw	zero,124(r2)
    }
  }
  if (shut_tx) {
    c338:	e0bfff17 	ldw	r2,-4(fp)
    c33c:	10001026 	beq	r2,zero,c380 <tcp_shutdown+0xd8>
    /* This can't happen twice since if it succeeds, the pcb's state is changed.
       Only close in these states as the others directly deallocate the PCB */
    switch (pcb->state) {
    c340:	e0bffd17 	ldw	r2,-12(fp)
    c344:	10800617 	ldw	r2,24(r2)
    c348:	10c000f0 	cmpltui	r3,r2,3
    c34c:	18000a1e 	bne	r3,zero,c378 <tcp_shutdown+0xd0>
    c350:	10c00170 	cmpltui	r3,r2,5
    c354:	1800021e 	bne	r3,zero,c360 <tcp_shutdown+0xb8>
    c358:	108001e0 	cmpeqi	r2,r2,7
    c35c:	10000626 	beq	r2,zero,c378 <tcp_shutdown+0xd0>
    case SYN_RCVD:
    case ESTABLISHED:
    case CLOSE_WAIT:
      return tcp_close_shutdown(pcb, shut_rx);
    c360:	e0bffe17 	ldw	r2,-8(fp)
    c364:	10803fcc 	andi	r2,r2,255
    c368:	e13ffd17 	ldw	r4,-12(fp)
    c36c:	100b883a 	mov	r5,r2
    c370:	000bebc0 	call	bebc <tcp_close_shutdown>
    c374:	00000306 	br	c384 <tcp_shutdown+0xdc>
    default:
      /* Not (yet?) connected, cannot shutdown the TX side as that would bring us
        into CLOSED state, where the PCB is deallocated. */
      return ERR_CONN;
    c378:	00bffcc4 	movi	r2,-13
    c37c:	00000106 	br	c384 <tcp_shutdown+0xdc>
    }
  }
  return ERR_OK;
    c380:	0005883a 	mov	r2,zero
}
    c384:	e037883a 	mov	sp,fp
    c388:	dfc00117 	ldw	ra,4(sp)
    c38c:	df000017 	ldw	fp,0(sp)
    c390:	dec00204 	addi	sp,sp,8
    c394:	f800283a 	ret

0000c398 <tcp_abandon>:
 * @param pcb the tcp_pcb to abort
 * @param reset boolean to indicate whether a reset should be sent
 */
void
tcp_abandon(struct tcp_pcb *pcb, int reset)
{
    c398:	defff604 	addi	sp,sp,-40
    c39c:	dfc00915 	stw	ra,36(sp)
    c3a0:	df000815 	stw	fp,32(sp)
    c3a4:	df000804 	addi	fp,sp,32
    c3a8:	e13ffe15 	stw	r4,-8(fp)
    c3ac:	e17fff15 	stw	r5,-4(fp)
  tcp_err_fn errf;
#endif /* LWIP_CALLBACK_API */
  void *errf_arg;

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
    c3b0:	e0bffe17 	ldw	r2,-8(fp)
    c3b4:	10800617 	ldw	r2,24(r2)
    c3b8:	10800058 	cmpnei	r2,r2,1
    c3bc:	1000091e 	bne	r2,zero,c3e4 <tcp_abandon+0x4c>
    c3c0:	010000f4 	movhi	r4,3
    c3c4:	21011004 	addi	r4,r4,1088
    c3c8:	014000f4 	movhi	r5,3
    c3cc:	29412604 	addi	r5,r5,1176
    c3d0:	01805bc4 	movi	r6,367
    c3d4:	01c000f4 	movhi	r7,3
    c3d8:	39c12104 	addi	r7,r7,1156
    c3dc:	00193f00 	call	193f0 <printf>
    c3e0:	003fff06 	br	c3e0 <tcp_abandon+0x48>
    pcb->state != LISTEN);
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
    c3e4:	e0bffe17 	ldw	r2,-8(fp)
    c3e8:	10800617 	ldw	r2,24(r2)
    c3ec:	10800298 	cmpnei	r2,r2,10
    c3f0:	1000071e 	bne	r2,zero,c410 <tcp_abandon+0x78>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
    c3f4:	d128c104 	addi	r4,gp,-23804
    c3f8:	e17ffe17 	ldw	r5,-8(fp)
    c3fc:	000e1f40 	call	e1f4 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
    c400:	01000084 	movi	r4,2
    c404:	e17ffe17 	ldw	r5,-8(fp)
    c408:	00097d40 	call	97d4 <memp_free>
    c40c:	00004106 	br	c514 <tcp_abandon+0x17c>
  } else {
    seqno = pcb->snd_nxt;
    c410:	e0bffe17 	ldw	r2,-8(fp)
    c414:	10801517 	ldw	r2,84(r2)
    c418:	e0bffa15 	stw	r2,-24(fp)
    ackno = pcb->rcv_nxt;
    c41c:	e0bffe17 	ldw	r2,-8(fp)
    c420:	10800b17 	ldw	r2,44(r2)
    c424:	e0bffb15 	stw	r2,-20(fp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
    c428:	e0bffe17 	ldw	r2,-8(fp)
    c42c:	10802417 	ldw	r2,144(r2)
    c430:	e0bffc15 	stw	r2,-16(fp)
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
    c434:	e0bffe17 	ldw	r2,-8(fp)
    c438:	10800417 	ldw	r2,16(r2)
    c43c:	e0bffd15 	stw	r2,-12(fp)
    TCP_PCB_REMOVE_ACTIVE(pcb);
    c440:	d128bc04 	addi	r4,gp,-23824
    c444:	e17ffe17 	ldw	r5,-8(fp)
    c448:	000e1f40 	call	e1f4 <tcp_pcb_remove>
    c44c:	00800044 	movi	r2,1
    c450:	d0a8bb85 	stb	r2,-23826(gp)
    if (pcb->unacked != NULL) {
    c454:	e0bffe17 	ldw	r2,-8(fp)
    c458:	10801d17 	ldw	r2,116(r2)
    c45c:	10000426 	beq	r2,zero,c470 <tcp_abandon+0xd8>
      tcp_segs_free(pcb->unacked);
    c460:	e0bffe17 	ldw	r2,-8(fp)
    c464:	10801d17 	ldw	r2,116(r2)
    c468:	1009883a 	mov	r4,r2
    c46c:	000d9b80 	call	d9b8 <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
    c470:	e0bffe17 	ldw	r2,-8(fp)
    c474:	10801c17 	ldw	r2,112(r2)
    c478:	10000426 	beq	r2,zero,c48c <tcp_abandon+0xf4>
      tcp_segs_free(pcb->unsent);
    c47c:	e0bffe17 	ldw	r2,-8(fp)
    c480:	10801c17 	ldw	r2,112(r2)
    c484:	1009883a 	mov	r4,r2
    c488:	000d9b80 	call	d9b8 <tcp_segs_free>
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
    c48c:	e0bffe17 	ldw	r2,-8(fp)
    c490:	10801e17 	ldw	r2,120(r2)
    c494:	10000426 	beq	r2,zero,c4a8 <tcp_abandon+0x110>
      tcp_segs_free(pcb->ooseq);
    c498:	e0bffe17 	ldw	r2,-8(fp)
    c49c:	10801e17 	ldw	r2,120(r2)
    c4a0:	1009883a 	mov	r4,r2
    c4a4:	000d9b80 	call	d9b8 <tcp_segs_free>
    }
#endif /* TCP_QUEUE_OOSEQ */
    if (reset) {
    c4a8:	e0bfff17 	ldw	r2,-4(fp)
    c4ac:	10001026 	beq	r2,zero,c4f0 <tcp_abandon+0x158>
      LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    c4b0:	e0fffe17 	ldw	r3,-8(fp)
    c4b4:	e0bffe17 	ldw	r2,-8(fp)
    c4b8:	10800104 	addi	r2,r2,4
    c4bc:	e13ffe17 	ldw	r4,-8(fp)
    c4c0:	2100078b 	ldhu	r4,30(r4)
    c4c4:	217fffcc 	andi	r5,r4,65535
    c4c8:	e13ffe17 	ldw	r4,-8(fp)
    c4cc:	2100080b 	ldhu	r4,32(r4)
    c4d0:	213fffcc 	andi	r4,r4,65535
    c4d4:	d9400015 	stw	r5,0(sp)
    c4d8:	d9000115 	stw	r4,4(sp)
    c4dc:	e13ffa17 	ldw	r4,-24(fp)
    c4e0:	e17ffb17 	ldw	r5,-20(fp)
    c4e4:	180d883a 	mov	r6,r3
    c4e8:	100f883a 	mov	r7,r2
    c4ec:	00146680 	call	14668 <tcp_rst>
    }
    memp_free(MEMP_TCP_PCB, pcb);
    c4f0:	01000084 	movi	r4,2
    c4f4:	e17ffe17 	ldw	r5,-8(fp)
    c4f8:	00097d40 	call	97d4 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
    c4fc:	e0bffc17 	ldw	r2,-16(fp)
    c500:	10000426 	beq	r2,zero,c514 <tcp_abandon+0x17c>
    c504:	e0bffc17 	ldw	r2,-16(fp)
    c508:	e13ffd17 	ldw	r4,-12(fp)
    c50c:	017ffd84 	movi	r5,-10
    c510:	103ee83a 	callr	r2
  }
}
    c514:	e037883a 	mov	sp,fp
    c518:	dfc00117 	ldw	ra,4(sp)
    c51c:	df000017 	ldw	fp,0(sp)
    c520:	dec00204 	addi	sp,sp,8
    c524:	f800283a 	ret

0000c528 <tcp_abort>:
 *
 * @param pcb the tcp pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
    c528:	defffd04 	addi	sp,sp,-12
    c52c:	dfc00215 	stw	ra,8(sp)
    c530:	df000115 	stw	fp,4(sp)
    c534:	df000104 	addi	fp,sp,4
    c538:	e13fff15 	stw	r4,-4(fp)
  tcp_abandon(pcb, 1);
    c53c:	e13fff17 	ldw	r4,-4(fp)
    c540:	01400044 	movi	r5,1
    c544:	000c3980 	call	c398 <tcp_abandon>
}
    c548:	e037883a 	mov	sp,fp
    c54c:	dfc00117 	ldw	ra,4(sp)
    c550:	df000017 	ldw	fp,0(sp)
    c554:	dec00204 	addi	sp,sp,8
    c558:	f800283a 	ret

0000c55c <tcp_bind>:
 *         ERR_VAL if bind failed because the PCB is not in a valid state
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
    c55c:	defff804 	addi	sp,sp,-32
    c560:	dfc00715 	stw	ra,28(sp)
    c564:	df000615 	stw	fp,24(sp)
    c568:	df000604 	addi	fp,sp,24
    c56c:	e13ffd15 	stw	r4,-12(fp)
    c570:	e17ffe15 	stw	r5,-8(fp)
    c574:	3005883a 	mov	r2,r6
    c578:	e0bfff0d 	sth	r2,-4(fp)
  int i;
  int max_pcb_list = NUM_TCP_PCB_LISTS;
    c57c:	00800104 	movi	r2,4
    c580:	e0bffc15 	stw	r2,-16(fp)
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
    c584:	e0bffd17 	ldw	r2,-12(fp)
    c588:	10800617 	ldw	r2,24(r2)
    c58c:	10000926 	beq	r2,zero,c5b4 <tcp_bind+0x58>
    c590:	010000f4 	movhi	r4,3
    c594:	21011004 	addi	r4,r4,1088
    c598:	014000f4 	movhi	r5,3
    c59c:	29413304 	addi	r5,r5,1228
    c5a0:	01806dc4 	movi	r6,439
    c5a4:	01c000f4 	movhi	r7,3
    c5a8:	39c12104 	addi	r7,r7,1156
    c5ac:	00193f00 	call	193f0 <printf>
    c5b0:	003fff06 	br	c5b0 <tcp_bind+0x54>
  if (ip_get_option(pcb, SOF_REUSEADDR)) {
    max_pcb_list = NUM_TCP_PCB_LISTS_NO_TIME_WAIT;
  }
#endif /* SO_REUSE */

  if (port == 0) {
    c5b4:	e0bfff0b 	ldhu	r2,-4(fp)
    c5b8:	1000061e 	bne	r2,zero,c5d4 <tcp_bind+0x78>
    port = tcp_new_port();
    c5bc:	000cb300 	call	cb30 <tcp_new_port>
    c5c0:	e0bfff0d 	sth	r2,-4(fp)
    if (port == 0) {
    c5c4:	e0bfff0b 	ldhu	r2,-4(fp)
    c5c8:	1000021e 	bne	r2,zero,c5d4 <tcp_bind+0x78>
      return ERR_BUF;
    c5cc:	00bfff84 	movi	r2,-2
    c5d0:	00004006 	br	c6d4 <tcp_bind+0x178>
    }
  }

  /* Check if the address already is in use (on all lists) */
  for (i = 0; i < max_pcb_list; i++) {
    c5d4:	e03ffa15 	stw	zero,-24(fp)
    c5d8:	00002806 	br	c67c <tcp_bind+0x120>
    for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
    c5dc:	00c000f4 	movhi	r3,3
    c5e0:	18c10c04 	addi	r3,r3,1072
    c5e4:	e0bffa17 	ldw	r2,-24(fp)
    c5e8:	1085883a 	add	r2,r2,r2
    c5ec:	1085883a 	add	r2,r2,r2
    c5f0:	1885883a 	add	r2,r3,r2
    c5f4:	10800017 	ldw	r2,0(r2)
    c5f8:	10800017 	ldw	r2,0(r2)
    c5fc:	e0bffb15 	stw	r2,-20(fp)
    c600:	00001906 	br	c668 <tcp_bind+0x10c>
      if (cpcb->local_port == port) {
    c604:	e0bffb17 	ldw	r2,-20(fp)
    c608:	1080078b 	ldhu	r2,30(r2)
    c60c:	10ffffcc 	andi	r3,r2,65535
    c610:	e0bfff0b 	ldhu	r2,-4(fp)
    c614:	1880111e 	bne	r3,r2,c65c <tcp_bind+0x100>
           tcp_connect. */
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
            !ip_get_option(cpcb, SOF_REUSEADDR))
#endif /* SO_REUSE */
        {
          if (ip_addr_isany(&(cpcb->local_ip)) ||
    c618:	e0bffb17 	ldw	r2,-20(fp)
    c61c:	10000d26 	beq	r2,zero,c654 <tcp_bind+0xf8>
    c620:	e0bffb17 	ldw	r2,-20(fp)
    c624:	10800017 	ldw	r2,0(r2)
    c628:	10000a26 	beq	r2,zero,c654 <tcp_bind+0xf8>
    c62c:	e0bffe17 	ldw	r2,-8(fp)
    c630:	10000826 	beq	r2,zero,c654 <tcp_bind+0xf8>
              ip_addr_isany(ipaddr) ||
    c634:	e0bffe17 	ldw	r2,-8(fp)
    c638:	10800017 	ldw	r2,0(r2)
    c63c:	10000526 	beq	r2,zero,c654 <tcp_bind+0xf8>
              ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
    c640:	e0bffb17 	ldw	r2,-20(fp)
    c644:	10c00017 	ldw	r3,0(r2)
    c648:	e0bffe17 	ldw	r2,-8(fp)
    c64c:	10800017 	ldw	r2,0(r2)
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
            !ip_get_option(cpcb, SOF_REUSEADDR))
#endif /* SO_REUSE */
        {
          if (ip_addr_isany(&(cpcb->local_ip)) ||
              ip_addr_isany(ipaddr) ||
    c650:	1880021e 	bne	r3,r2,c65c <tcp_bind+0x100>
              ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
            return ERR_USE;
    c654:	00bffe04 	movi	r2,-8
    c658:	00001e06 	br	c6d4 <tcp_bind+0x178>
    }
  }

  /* Check if the address already is in use (on all lists) */
  for (i = 0; i < max_pcb_list; i++) {
    for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
    c65c:	e0bffb17 	ldw	r2,-20(fp)
    c660:	10800317 	ldw	r2,12(r2)
    c664:	e0bffb15 	stw	r2,-20(fp)
    c668:	e0bffb17 	ldw	r2,-20(fp)
    c66c:	103fe51e 	bne	r2,zero,c604 <tcp_bind+0xa8>
      return ERR_BUF;
    }
  }

  /* Check if the address already is in use (on all lists) */
  for (i = 0; i < max_pcb_list; i++) {
    c670:	e0bffa17 	ldw	r2,-24(fp)
    c674:	10800044 	addi	r2,r2,1
    c678:	e0bffa15 	stw	r2,-24(fp)
    c67c:	e0fffa17 	ldw	r3,-24(fp)
    c680:	e0bffc17 	ldw	r2,-16(fp)
    c684:	18bfd516 	blt	r3,r2,c5dc <tcp_bind+0x80>
        }
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
    c688:	e0bffe17 	ldw	r2,-8(fp)
    c68c:	10000726 	beq	r2,zero,c6ac <tcp_bind+0x150>
    c690:	e0bffe17 	ldw	r2,-8(fp)
    c694:	10800017 	ldw	r2,0(r2)
    c698:	10000426 	beq	r2,zero,c6ac <tcp_bind+0x150>
    pcb->local_ip = *ipaddr;
    c69c:	e0bffd17 	ldw	r2,-12(fp)
    c6a0:	e0fffe17 	ldw	r3,-8(fp)
    c6a4:	18c00017 	ldw	r3,0(r3)
    c6a8:	10c00015 	stw	r3,0(r2)
  }
  pcb->local_port = port;
    c6ac:	e0bffd17 	ldw	r2,-12(fp)
    c6b0:	e0ffff0b 	ldhu	r3,-4(fp)
    c6b4:	10c0078d 	sth	r3,30(r2)
  TCP_REG(&tcp_bound_pcbs, pcb);
    c6b8:	d0e8c017 	ldw	r3,-23808(gp)
    c6bc:	e0bffd17 	ldw	r2,-12(fp)
    c6c0:	10c00315 	stw	r3,12(r2)
    c6c4:	e0bffd17 	ldw	r2,-12(fp)
    c6c8:	d0a8c015 	stw	r2,-23808(gp)
    c6cc:	0014fd80 	call	14fd8 <tcp_timer_needed>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
    c6d0:	0005883a 	mov	r2,zero
}
    c6d4:	e037883a 	mov	sp,fp
    c6d8:	dfc00117 	ldw	ra,4(sp)
    c6dc:	df000017 	ldw	fp,0(sp)
    c6e0:	dec00204 	addi	sp,sp,8
    c6e4:	f800283a 	ret

0000c6e8 <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
    c6e8:	defffc04 	addi	sp,sp,-16
    c6ec:	df000315 	stw	fp,12(sp)
    c6f0:	df000304 	addi	fp,sp,12
    c6f4:	e13ffd15 	stw	r4,-12(fp)
    c6f8:	e17ffe15 	stw	r5,-8(fp)
    c6fc:	3005883a 	mov	r2,r6
    c700:	e0bfff05 	stb	r2,-4(fp)
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
    c704:	00bffd84 	movi	r2,-10
}
    c708:	e037883a 	mov	sp,fp
    c70c:	df000017 	ldw	fp,0(sp)
    c710:	dec00104 	addi	sp,sp,4
    c714:	f800283a 	ret

0000c718 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
    c718:	defffb04 	addi	sp,sp,-20
    c71c:	dfc00415 	stw	ra,16(sp)
    c720:	df000315 	stw	fp,12(sp)
    c724:	df000304 	addi	fp,sp,12
    c728:	e13ffe15 	stw	r4,-8(fp)
    c72c:	2805883a 	mov	r2,r5
    c730:	e0bfff05 	stb	r2,-4(fp)
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
    c734:	e0bffe17 	ldw	r2,-8(fp)
    c738:	10800617 	ldw	r2,24(r2)
    c73c:	10000926 	beq	r2,zero,c764 <tcp_listen_with_backlog+0x4c>
    c740:	010000f4 	movhi	r4,3
    c744:	21011004 	addi	r4,r4,1088
    c748:	014000f4 	movhi	r5,3
    c74c:	29413d04 	addi	r5,r5,1268
    c750:	01808304 	movi	r6,524
    c754:	01c000f4 	movhi	r7,3
    c758:	39c12104 	addi	r7,r7,1156
    c75c:	00193f00 	call	193f0 <printf>
    c760:	003fff06 	br	c760 <tcp_listen_with_backlog+0x48>

  /* already listening? */
  if (pcb->state == LISTEN) {
    c764:	e0bffe17 	ldw	r2,-8(fp)
    c768:	10800617 	ldw	r2,24(r2)
    c76c:	10800058 	cmpnei	r2,r2,1
    c770:	1000021e 	bne	r2,zero,c77c <tcp_listen_with_backlog+0x64>
    return pcb;
    c774:	e0bffe17 	ldw	r2,-8(fp)
    c778:	00005806 	br	c8dc <tcp_listen_with_backlog+0x1c4>
        }
      }
    }
  }
#endif /* SO_REUSE */
  lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
    c77c:	010000c4 	movi	r4,3
    c780:	00095f80 	call	95f8 <memp_malloc>
    c784:	e0bffd15 	stw	r2,-12(fp)
  if (lpcb == NULL) {
    c788:	e0bffd17 	ldw	r2,-12(fp)
    c78c:	1000021e 	bne	r2,zero,c798 <tcp_listen_with_backlog+0x80>
    return NULL;
    c790:	0005883a 	mov	r2,zero
    c794:	00005106 	br	c8dc <tcp_listen_with_backlog+0x1c4>
  }
  lpcb->callback_arg = pcb->callback_arg;
    c798:	e0bffe17 	ldw	r2,-8(fp)
    c79c:	10c00417 	ldw	r3,16(r2)
    c7a0:	e0bffd17 	ldw	r2,-12(fp)
    c7a4:	10c00415 	stw	r3,16(r2)
  lpcb->local_port = pcb->local_port;
    c7a8:	e0bffe17 	ldw	r2,-8(fp)
    c7ac:	10c0078b 	ldhu	r3,30(r2)
    c7b0:	e0bffd17 	ldw	r2,-12(fp)
    c7b4:	10c0078d 	sth	r3,30(r2)
  lpcb->state = LISTEN;
    c7b8:	e0bffd17 	ldw	r2,-12(fp)
    c7bc:	00c00044 	movi	r3,1
    c7c0:	10c00615 	stw	r3,24(r2)
  lpcb->prio = pcb->prio;
    c7c4:	e0bffe17 	ldw	r2,-8(fp)
    c7c8:	10c00703 	ldbu	r3,28(r2)
    c7cc:	e0bffd17 	ldw	r2,-12(fp)
    c7d0:	10c00705 	stb	r3,28(r2)
  lpcb->so_options = pcb->so_options;
    c7d4:	e0bffe17 	ldw	r2,-8(fp)
    c7d8:	10c00203 	ldbu	r3,8(r2)
    c7dc:	e0bffd17 	ldw	r2,-12(fp)
    c7e0:	10c00205 	stb	r3,8(r2)
  ip_set_option(lpcb, SOF_ACCEPTCONN);
    c7e4:	e0bffd17 	ldw	r2,-12(fp)
    c7e8:	10800203 	ldbu	r2,8(r2)
    c7ec:	10800094 	ori	r2,r2,2
    c7f0:	1007883a 	mov	r3,r2
    c7f4:	e0bffd17 	ldw	r2,-12(fp)
    c7f8:	10c00205 	stb	r3,8(r2)
  lpcb->ttl = pcb->ttl;
    c7fc:	e0bffe17 	ldw	r2,-8(fp)
    c800:	10c00283 	ldbu	r3,10(r2)
    c804:	e0bffd17 	ldw	r2,-12(fp)
    c808:	10c00285 	stb	r3,10(r2)
  lpcb->tos = pcb->tos;
    c80c:	e0bffe17 	ldw	r2,-8(fp)
    c810:	10c00243 	ldbu	r3,9(r2)
    c814:	e0bffd17 	ldw	r2,-12(fp)
    c818:	10c00245 	stb	r3,9(r2)
  ip_addr_copy(lpcb->local_ip, pcb->local_ip);
    c81c:	e0bffe17 	ldw	r2,-8(fp)
    c820:	10c00017 	ldw	r3,0(r2)
    c824:	e0bffd17 	ldw	r2,-12(fp)
    c828:	10c00015 	stw	r3,0(r2)
  if (pcb->local_port != 0) {
    c82c:	e0bffe17 	ldw	r2,-8(fp)
    c830:	1080078b 	ldhu	r2,30(r2)
    c834:	10bfffcc 	andi	r2,r2,65535
    c838:	10001a26 	beq	r2,zero,c8a4 <tcp_listen_with_backlog+0x18c>
    TCP_RMV(&tcp_bound_pcbs, pcb);
    c83c:	d0e8c017 	ldw	r3,-23808(gp)
    c840:	e0bffe17 	ldw	r2,-8(fp)
    c844:	1880041e 	bne	r3,r2,c858 <tcp_listen_with_backlog+0x140>
    c848:	d0a8c017 	ldw	r2,-23808(gp)
    c84c:	10800317 	ldw	r2,12(r2)
    c850:	d0a8c015 	stw	r2,-23808(gp)
    c854:	00001106 	br	c89c <tcp_listen_with_backlog+0x184>
    c858:	d0a8c017 	ldw	r2,-23808(gp)
    c85c:	d0a8bf15 	stw	r2,-23812(gp)
    c860:	00000c06 	br	c894 <tcp_listen_with_backlog+0x17c>
    c864:	d0a8bf17 	ldw	r2,-23812(gp)
    c868:	10c00317 	ldw	r3,12(r2)
    c86c:	e0bffe17 	ldw	r2,-8(fp)
    c870:	1880051e 	bne	r3,r2,c888 <tcp_listen_with_backlog+0x170>
    c874:	d0a8bf17 	ldw	r2,-23812(gp)
    c878:	e0fffe17 	ldw	r3,-8(fp)
    c87c:	18c00317 	ldw	r3,12(r3)
    c880:	10c00315 	stw	r3,12(r2)
    c884:	00000506 	br	c89c <tcp_listen_with_backlog+0x184>
    c888:	d0a8bf17 	ldw	r2,-23812(gp)
    c88c:	10800317 	ldw	r2,12(r2)
    c890:	d0a8bf15 	stw	r2,-23812(gp)
    c894:	d0a8bf17 	ldw	r2,-23812(gp)
    c898:	103ff21e 	bne	r2,zero,c864 <tcp_listen_with_backlog+0x14c>
    c89c:	e0bffe17 	ldw	r2,-8(fp)
    c8a0:	10000315 	stw	zero,12(r2)
  }
  memp_free(MEMP_TCP_PCB, pcb);
    c8a4:	01000084 	movi	r4,2
    c8a8:	e17ffe17 	ldw	r5,-8(fp)
    c8ac:	00097d40 	call	97d4 <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
    c8b0:	e0bffd17 	ldw	r2,-12(fp)
    c8b4:	00c00074 	movhi	r3,1
    c8b8:	18f1ba04 	addi	r3,r3,-14616
    c8bc:	10c00515 	stw	r3,20(r2)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
    c8c0:	d0e8be17 	ldw	r3,-23816(gp)
    c8c4:	e0bffd17 	ldw	r2,-12(fp)
    c8c8:	10c00315 	stw	r3,12(r2)
    c8cc:	e0bffd17 	ldw	r2,-12(fp)
    c8d0:	d0a8be15 	stw	r2,-23816(gp)
    c8d4:	0014fd80 	call	14fd8 <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
    c8d8:	e0bffd17 	ldw	r2,-12(fp)
}
    c8dc:	e037883a 	mov	sp,fp
    c8e0:	dfc00117 	ldw	ra,4(sp)
    c8e4:	df000017 	ldw	fp,0(sp)
    c8e8:	dec00204 	addi	sp,sp,8
    c8ec:	f800283a 	ret

0000c8f0 <tcp_update_rcv_ann_wnd>:
 *
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
    c8f0:	defffb04 	addi	sp,sp,-20
    c8f4:	dfc00415 	stw	ra,16(sp)
    c8f8:	df000315 	stw	fp,12(sp)
    c8fc:	df000304 	addi	fp,sp,12
    c900:	e13fff15 	stw	r4,-4(fp)
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
    c904:	e0bfff17 	ldw	r2,-4(fp)
    c908:	10c00b17 	ldw	r3,44(r2)
    c90c:	e0bfff17 	ldw	r2,-4(fp)
    c910:	10800c0b 	ldhu	r2,48(r2)
    c914:	10bfffcc 	andi	r2,r2,65535
    c918:	1885883a 	add	r2,r3,r2
    c91c:	e0bffd15 	stw	r2,-12(fp)

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    c920:	e0bfff17 	ldw	r2,-4(fp)
    c924:	10c00d17 	ldw	r3,52(r2)
    c928:	e0bfff17 	ldw	r2,-4(fp)
    c92c:	10800e8b 	ldhu	r2,58(r2)
    c930:	10bfffcc 	andi	r2,r2,65535
    c934:	10810068 	cmpgeui	r2,r2,1025
    c938:	1000041e 	bne	r2,zero,c94c <tcp_update_rcv_ann_wnd+0x5c>
    c93c:	e0bfff17 	ldw	r2,-4(fp)
    c940:	10800e8b 	ldhu	r2,58(r2)
    c944:	10bfffcc 	andi	r2,r2,65535
    c948:	00000106 	br	c950 <tcp_update_rcv_ann_wnd+0x60>
    c94c:	00810004 	movi	r2,1024
    c950:	1885883a 	add	r2,r3,r2
    c954:	e0fffd17 	ldw	r3,-12(fp)
    c958:	1885c83a 	sub	r2,r3,r2
    c95c:	10000916 	blt	r2,zero,c984 <tcp_update_rcv_ann_wnd+0x94>
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
    c960:	e0bfff17 	ldw	r2,-4(fp)
    c964:	10c00c0b 	ldhu	r3,48(r2)
    c968:	e0bfff17 	ldw	r2,-4(fp)
    c96c:	10c00c8d 	sth	r3,50(r2)
    return new_right_edge - pcb->rcv_ann_right_edge;
    c970:	e0bfff17 	ldw	r2,-4(fp)
    c974:	10800d17 	ldw	r2,52(r2)
    c978:	e0fffd17 	ldw	r3,-12(fp)
    c97c:	1885c83a 	sub	r2,r3,r2
    c980:	00002006 	br	ca04 <tcp_update_rcv_ann_wnd+0x114>
  } else {
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
    c984:	e0bfff17 	ldw	r2,-4(fp)
    c988:	10c00b17 	ldw	r3,44(r2)
    c98c:	e0bfff17 	ldw	r2,-4(fp)
    c990:	10800d17 	ldw	r2,52(r2)
    c994:	1885c83a 	sub	r2,r3,r2
    c998:	0080030e 	bge	zero,r2,c9a8 <tcp_update_rcv_ann_wnd+0xb8>
      /* Can happen due to other end sending out of advertised window,
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
    c99c:	e0bfff17 	ldw	r2,-4(fp)
    c9a0:	10000c8d 	sth	zero,50(r2)
    c9a4:	00001606 	br	ca00 <tcp_update_rcv_ann_wnd+0x110>
    } else {
      /* keep the right edge of window constant */
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
    c9a8:	e0bfff17 	ldw	r2,-4(fp)
    c9ac:	10c00d17 	ldw	r3,52(r2)
    c9b0:	e0bfff17 	ldw	r2,-4(fp)
    c9b4:	10800b17 	ldw	r2,44(r2)
    c9b8:	1885c83a 	sub	r2,r3,r2
    c9bc:	e0bffe15 	stw	r2,-8(fp)
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
    c9c0:	e0bffe17 	ldw	r2,-8(fp)
    c9c4:	00ffffd4 	movui	r3,65535
    c9c8:	1880092e 	bgeu	r3,r2,c9f0 <tcp_update_rcv_ann_wnd+0x100>
    c9cc:	010000f4 	movhi	r4,3
    c9d0:	21011004 	addi	r4,r4,1088
    c9d4:	014000f4 	movhi	r5,3
    c9d8:	29414604 	addi	r5,r5,1304
    c9dc:	018094c4 	movi	r6,595
    c9e0:	01c000f4 	movhi	r7,3
    c9e4:	39c12104 	addi	r7,r7,1156
    c9e8:	00193f00 	call	193f0 <printf>
    c9ec:	003fff06 	br	c9ec <tcp_update_rcv_ann_wnd+0xfc>
      pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
    c9f0:	e0bffe17 	ldw	r2,-8(fp)
    c9f4:	1007883a 	mov	r3,r2
    c9f8:	e0bfff17 	ldw	r2,-4(fp)
    c9fc:	10c00c8d 	sth	r3,50(r2)
    }
    return 0;
    ca00:	0005883a 	mov	r2,zero
  }
}
    ca04:	e037883a 	mov	sp,fp
    ca08:	dfc00117 	ldw	ra,4(sp)
    ca0c:	df000017 	ldw	fp,0(sp)
    ca10:	dec00204 	addi	sp,sp,8
    ca14:	f800283a 	ret

0000ca18 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
    ca18:	defffb04 	addi	sp,sp,-20
    ca1c:	dfc00415 	stw	ra,16(sp)
    ca20:	df000315 	stw	fp,12(sp)
    ca24:	df000304 	addi	fp,sp,12
    ca28:	e13ffe15 	stw	r4,-8(fp)
    ca2c:	2805883a 	mov	r2,r5
    ca30:	e0bfff0d 	sth	r2,-4(fp)
  int wnd_inflation;

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
    ca34:	e0bffe17 	ldw	r2,-8(fp)
    ca38:	10800617 	ldw	r2,24(r2)
    ca3c:	10800058 	cmpnei	r2,r2,1
    ca40:	1000091e 	bne	r2,zero,ca68 <tcp_recved+0x50>
    ca44:	010000f4 	movhi	r4,3
    ca48:	21011004 	addi	r4,r4,1088
    ca4c:	014000f4 	movhi	r5,3
    ca50:	29414d04 	addi	r5,r5,1332
    ca54:	01809a44 	movi	r6,617
    ca58:	01c000f4 	movhi	r7,3
    ca5c:	39c12104 	addi	r7,r7,1156
    ca60:	00193f00 	call	193f0 <printf>
    ca64:	003fff06 	br	ca64 <tcp_recved+0x4c>
    pcb->state != LISTEN);
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
    ca68:	e0bfff0b 	ldhu	r2,-4(fp)
    ca6c:	e0fffe17 	ldw	r3,-8(fp)
    ca70:	18c00c0b 	ldhu	r3,48(r3)
    ca74:	18ffffcc 	andi	r3,r3,65535
    ca78:	013fffd4 	movui	r4,65535
    ca7c:	20c7c83a 	sub	r3,r4,r3
    ca80:	1880090e 	bge	r3,r2,caa8 <tcp_recved+0x90>
    ca84:	010000f4 	movhi	r4,3
    ca88:	21011004 	addi	r4,r4,1088
    ca8c:	014000f4 	movhi	r5,3
    ca90:	29415704 	addi	r5,r5,1372
    ca94:	01809ac4 	movi	r6,619
    ca98:	01c000f4 	movhi	r7,3
    ca9c:	39c12104 	addi	r7,r7,1156
    caa0:	00193f00 	call	193f0 <printf>
    caa4:	003fff06 	br	caa4 <tcp_recved+0x8c>
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
    caa8:	e0bffe17 	ldw	r2,-8(fp)
    caac:	10c00c0b 	ldhu	r3,48(r2)
    cab0:	e0bfff0b 	ldhu	r2,-4(fp)
    cab4:	1885883a 	add	r2,r3,r2
    cab8:	1007883a 	mov	r3,r2
    cabc:	e0bffe17 	ldw	r2,-8(fp)
    cac0:	10c00c0d 	sth	r3,48(r2)
  if (pcb->rcv_wnd > TCP_WND) {
    cac4:	e0bffe17 	ldw	r2,-8(fp)
    cac8:	10800c0b 	ldhu	r2,48(r2)
    cacc:	10bfffcc 	andi	r2,r2,65535
    cad0:	10820070 	cmpltui	r2,r2,2049
    cad4:	1000031e 	bne	r2,zero,cae4 <tcp_recved+0xcc>
    pcb->rcv_wnd = TCP_WND;
    cad8:	e0bffe17 	ldw	r2,-8(fp)
    cadc:	00c20004 	movi	r3,2048
    cae0:	10c00c0d 	sth	r3,48(r2)
  }

  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
    cae4:	e13ffe17 	ldw	r4,-8(fp)
    cae8:	000c8f00 	call	c8f0 <tcp_update_rcv_ann_wnd>
    caec:	e0bffd15 	stw	r2,-12(fp)

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
    caf0:	e0bffd17 	ldw	r2,-12(fp)
    caf4:	10808010 	cmplti	r2,r2,512
    caf8:	1000081e 	bne	r2,zero,cb1c <tcp_recved+0x104>
    tcp_ack_now(pcb);
    cafc:	e0bffe17 	ldw	r2,-8(fp)
    cb00:	10800883 	ldbu	r2,34(r2)
    cb04:	10800094 	ori	r2,r2,2
    cb08:	1007883a 	mov	r3,r2
    cb0c:	e0bffe17 	ldw	r2,-8(fp)
    cb10:	10c00885 	stb	r3,34(r2)
    tcp_output(pcb);
    cb14:	e13ffe17 	ldw	r4,-8(fp)
    cb18:	0013a740 	call	13a74 <tcp_output>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
    cb1c:	e037883a 	mov	sp,fp
    cb20:	dfc00117 	ldw	ra,4(sp)
    cb24:	df000017 	ldw	fp,0(sp)
    cb28:	dec00204 	addi	sp,sp,8
    cb2c:	f800283a 	ret

0000cb30 <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
    cb30:	defffd04 	addi	sp,sp,-12
    cb34:	df000215 	stw	fp,8(sp)
    cb38:	df000204 	addi	fp,sp,8
  u8_t i;
  u16_t n = 0;
    cb3c:	e03ffe8d 	sth	zero,-6(fp)
    cb40:	00000106 	br	cb48 <tcp_new_port+0x18>
    for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
      if (pcb->local_port == tcp_port) {
        if (++n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
          return 0;
        }
        goto again;
    cb44:	0001883a 	nop
  u8_t i;
  u16_t n = 0;
  struct tcp_pcb *pcb;
  
again:
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
    cb48:	d0a0040b 	ldhu	r2,-32752(gp)
    cb4c:	113fffcc 	andi	r4,r2,65535
    cb50:	00ffffd4 	movui	r3,65535
    cb54:	20c7003a 	cmpeq	r3,r4,r3
    cb58:	10800044 	addi	r2,r2,1
    cb5c:	d0a0040d 	sth	r2,-32752(gp)
    cb60:	18803fcc 	andi	r2,r3,255
    cb64:	10000226 	beq	r2,zero,cb70 <tcp_new_port+0x40>
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
    cb68:	00b00004 	movi	r2,-16384
    cb6c:	d0a0040d 	sth	r2,-32752(gp)
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
    cb70:	e03ffe05 	stb	zero,-8(fp)
    cb74:	00002006 	br	cbf8 <tcp_new_port+0xc8>
    for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
    cb78:	e0bffe03 	ldbu	r2,-8(fp)
    cb7c:	00c000f4 	movhi	r3,3
    cb80:	18c10c04 	addi	r3,r3,1072
    cb84:	1085883a 	add	r2,r2,r2
    cb88:	1085883a 	add	r2,r2,r2
    cb8c:	1885883a 	add	r2,r3,r2
    cb90:	10800017 	ldw	r2,0(r2)
    cb94:	10800017 	ldw	r2,0(r2)
    cb98:	e0bfff15 	stw	r2,-4(fp)
    cb9c:	00001106 	br	cbe4 <tcp_new_port+0xb4>
      if (pcb->local_port == tcp_port) {
    cba0:	e0bfff17 	ldw	r2,-4(fp)
    cba4:	10c0078b 	ldhu	r3,30(r2)
    cba8:	d0a0040b 	ldhu	r2,-32752(gp)
    cbac:	18ffffcc 	andi	r3,r3,65535
    cbb0:	10bfffcc 	andi	r2,r2,65535
    cbb4:	1880081e 	bne	r3,r2,cbd8 <tcp_new_port+0xa8>
        if (++n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
    cbb8:	e0bffe8b 	ldhu	r2,-6(fp)
    cbbc:	10800044 	addi	r2,r2,1
    cbc0:	e0bffe8d 	sth	r2,-6(fp)
    cbc4:	e0bffe8b 	ldhu	r2,-6(fp)
    cbc8:	10900030 	cmpltui	r2,r2,16384
    cbcc:	103fdd1e 	bne	r2,zero,cb44 <tcp_new_port+0x14>
          return 0;
    cbd0:	0005883a 	mov	r2,zero
    cbd4:	00000c06 	br	cc08 <tcp_new_port+0xd8>
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
    for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
    cbd8:	e0bfff17 	ldw	r2,-4(fp)
    cbdc:	10800317 	ldw	r2,12(r2)
    cbe0:	e0bfff15 	stw	r2,-4(fp)
    cbe4:	e0bfff17 	ldw	r2,-4(fp)
    cbe8:	103fed1e 	bne	r2,zero,cba0 <tcp_new_port+0x70>
again:
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
    cbec:	e0bffe03 	ldbu	r2,-8(fp)
    cbf0:	10800044 	addi	r2,r2,1
    cbf4:	e0bffe05 	stb	r2,-8(fp)
    cbf8:	e0bffe03 	ldbu	r2,-8(fp)
    cbfc:	10800130 	cmpltui	r2,r2,4
    cc00:	103fdd1e 	bne	r2,zero,cb78 <tcp_new_port+0x48>
        }
        goto again;
      }
    }
  }
  return tcp_port;
    cc04:	d0a0040b 	ldhu	r2,-32752(gp)
}
    cc08:	e037883a 	mov	sp,fp
    cc0c:	df000017 	ldw	fp,0(sp)
    cc10:	dec00104 	addi	sp,sp,4
    cc14:	f800283a 	ret

0000cc18 <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port,
      tcp_connected_fn connected)
{
    cc18:	defff604 	addi	sp,sp,-40
    cc1c:	dfc00915 	stw	ra,36(sp)
    cc20:	df000815 	stw	fp,32(sp)
    cc24:	df000804 	addi	fp,sp,32
    cc28:	e13ffc15 	stw	r4,-16(fp)
    cc2c:	e17ffd15 	stw	r5,-12(fp)
    cc30:	3005883a 	mov	r2,r6
    cc34:	e1ffff15 	stw	r7,-4(fp)
    cc38:	e0bffe0d 	sth	r2,-8(fp)
  err_t ret;
  u32_t iss;
  u16_t old_local_port;

  LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
    cc3c:	e0bffc17 	ldw	r2,-16(fp)
    cc40:	10800617 	ldw	r2,24(r2)
    cc44:	10000926 	beq	r2,zero,cc6c <tcp_connect+0x54>
    cc48:	010000f4 	movhi	r4,3
    cc4c:	21011004 	addi	r4,r4,1088
    cc50:	014000f4 	movhi	r5,3
    cc54:	29416004 	addi	r5,r5,1408
    cc58:	0180acc4 	movi	r6,691
    cc5c:	01c000f4 	movhi	r7,3
    cc60:	39c12104 	addi	r7,r7,1156
    cc64:	00193f00 	call	193f0 <printf>
    cc68:	003fff06 	br	cc68 <tcp_connect+0x50>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    cc6c:	e0bffd17 	ldw	r2,-12(fp)
    cc70:	10000a26 	beq	r2,zero,cc9c <tcp_connect+0x84>
    pcb->remote_ip = *ipaddr;
    cc74:	e0bffc17 	ldw	r2,-16(fp)
    cc78:	e0fffd17 	ldw	r3,-12(fp)
    cc7c:	18c00017 	ldw	r3,0(r3)
    cc80:	10c00115 	stw	r3,4(r2)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
    cc84:	e0bffc17 	ldw	r2,-16(fp)
    cc88:	e0fffe0b 	ldhu	r3,-8(fp)
    cc8c:	10c0080d 	sth	r3,32(r2)

  /* check if we have a route to the remote host */
  if (ip_addr_isany(&(pcb->local_ip))) {
    cc90:	e0bffc17 	ldw	r2,-16(fp)
    cc94:	10000626 	beq	r2,zero,ccb0 <tcp_connect+0x98>
    cc98:	00000206 	br	cca4 <tcp_connect+0x8c>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
  } else {
    return ERR_VAL;
    cc9c:	00bffe84 	movi	r2,-6
    cca0:	00008306 	br	ceb0 <tcp_connect+0x298>
  }
  pcb->remote_port = port;

  /* check if we have a route to the remote host */
  if (ip_addr_isany(&(pcb->local_ip))) {
    cca4:	e0bffc17 	ldw	r2,-16(fp)
    cca8:	10800017 	ldw	r2,0(r2)
    ccac:	10000d1e 	bne	r2,zero,cce4 <tcp_connect+0xcc>
    /* no local IP address set, yet. */
    struct netif *netif = ip_route(&(pcb->remote_ip));
    ccb0:	e0bffc17 	ldw	r2,-16(fp)
    ccb4:	10800104 	addi	r2,r2,4
    ccb8:	1009883a 	mov	r4,r2
    ccbc:	00062600 	call	6260 <ip_route>
    ccc0:	e0bff815 	stw	r2,-32(fp)
    if (netif == NULL) {
    ccc4:	e0bff817 	ldw	r2,-32(fp)
    ccc8:	1000021e 	bne	r2,zero,ccd4 <tcp_connect+0xbc>
      /* Don't even try to send a SYN packet if we have no route
         since that will fail. */
      return ERR_RTE;
    cccc:	00bfff04 	movi	r2,-4
    ccd0:	00007706 	br	ceb0 <tcp_connect+0x298>
    }
    /* Use the netif's IP address as local address. */
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
    ccd4:	e0bff817 	ldw	r2,-32(fp)
    ccd8:	10c00117 	ldw	r3,4(r2)
    ccdc:	e0bffc17 	ldw	r2,-16(fp)
    cce0:	10c00015 	stw	r3,0(r2)
  }

  old_local_port = pcb->local_port;
    cce4:	e0bffc17 	ldw	r2,-16(fp)
    cce8:	1080078b 	ldhu	r2,30(r2)
    ccec:	e0bff90d 	sth	r2,-28(fp)
  if (pcb->local_port == 0) {
    ccf0:	e0bffc17 	ldw	r2,-16(fp)
    ccf4:	1080078b 	ldhu	r2,30(r2)
    ccf8:	10bfffcc 	andi	r2,r2,65535
    ccfc:	1000091e 	bne	r2,zero,cd24 <tcp_connect+0x10c>
    pcb->local_port = tcp_new_port();
    cd00:	000cb300 	call	cb30 <tcp_new_port>
    cd04:	e0fffc17 	ldw	r3,-16(fp)
    cd08:	1880078d 	sth	r2,30(r3)
    if (pcb->local_port == 0) {
    cd0c:	e0bffc17 	ldw	r2,-16(fp)
    cd10:	1080078b 	ldhu	r2,30(r2)
    cd14:	10bfffcc 	andi	r2,r2,65535
    cd18:	1000021e 	bne	r2,zero,cd24 <tcp_connect+0x10c>
      return ERR_BUF;
    cd1c:	00bfff84 	movi	r2,-2
    cd20:	00006306 	br	ceb0 <tcp_connect+0x298>
        }
      }
    }
  }
#endif /* SO_REUSE */
  iss = tcp_next_iss();
    cd24:	000e39c0 	call	e39c <tcp_next_iss>
    cd28:	e0bffa15 	stw	r2,-24(fp)
  pcb->rcv_nxt = 0;
    cd2c:	e0bffc17 	ldw	r2,-16(fp)
    cd30:	10000b15 	stw	zero,44(r2)
  pcb->snd_nxt = iss;
    cd34:	e0bffc17 	ldw	r2,-16(fp)
    cd38:	e0fffa17 	ldw	r3,-24(fp)
    cd3c:	10c01515 	stw	r3,84(r2)
  pcb->lastack = iss - 1;
    cd40:	e0bffa17 	ldw	r2,-24(fp)
    cd44:	10ffffc4 	addi	r3,r2,-1
    cd48:	e0bffc17 	ldw	r2,-16(fp)
    cd4c:	10c01315 	stw	r3,76(r2)
  pcb->snd_lbb = iss - 1;
    cd50:	e0bffa17 	ldw	r2,-24(fp)
    cd54:	10ffffc4 	addi	r3,r2,-1
    cd58:	e0bffc17 	ldw	r2,-16(fp)
    cd5c:	10c01815 	stw	r3,96(r2)
  pcb->rcv_wnd = TCP_WND;
    cd60:	e0bffc17 	ldw	r2,-16(fp)
    cd64:	00c20004 	movi	r3,2048
    cd68:	10c00c0d 	sth	r3,48(r2)
  pcb->rcv_ann_wnd = TCP_WND;
    cd6c:	e0bffc17 	ldw	r2,-16(fp)
    cd70:	00c20004 	movi	r3,2048
    cd74:	10c00c8d 	sth	r3,50(r2)
  pcb->rcv_ann_right_edge = pcb->rcv_nxt;
    cd78:	e0bffc17 	ldw	r2,-16(fp)
    cd7c:	10c00b17 	ldw	r3,44(r2)
    cd80:	e0bffc17 	ldw	r2,-16(fp)
    cd84:	10c00d15 	stw	r3,52(r2)
  pcb->snd_wnd = TCP_WND;
    cd88:	e0bffc17 	ldw	r2,-16(fp)
    cd8c:	00c20004 	movi	r3,2048
    cd90:	10c0190d 	sth	r3,100(r2)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    cd94:	e0bffc17 	ldw	r2,-16(fp)
    cd98:	00c08604 	movi	r3,536
    cd9c:	10c00e8d 	sth	r3,58(r2)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
    cda0:	e0bffc17 	ldw	r2,-16(fp)
    cda4:	10800e8b 	ldhu	r2,58(r2)
    cda8:	10bfffcc 	andi	r2,r2,65535
    cdac:	1009883a 	mov	r4,r2
    cdb0:	e17ffd17 	ldw	r5,-12(fp)
    cdb4:	000e3cc0 	call	e3cc <tcp_eff_send_mss>
    cdb8:	e0fffc17 	ldw	r3,-16(fp)
    cdbc:	18800e8d 	sth	r2,58(r3)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
    cdc0:	e0bffc17 	ldw	r2,-16(fp)
    cdc4:	00c00044 	movi	r3,1
    cdc8:	10c0140d 	sth	r3,80(r2)
  pcb->ssthresh = pcb->mss * 10;
    cdcc:	e0bffc17 	ldw	r2,-16(fp)
    cdd0:	10800e8b 	ldhu	r2,58(r2)
    cdd4:	108002a4 	muli	r2,r2,10
    cdd8:	1007883a 	mov	r3,r2
    cddc:	e0bffc17 	ldw	r2,-16(fp)
    cde0:	10c0148d 	sth	r3,82(r2)
#if LWIP_CALLBACK_API
  pcb->connected = connected;
    cde4:	e0bffc17 	ldw	r2,-16(fp)
    cde8:	e0ffff17 	ldw	r3,-4(fp)
    cdec:	10c02215 	stw	r3,136(r2)
#else /* LWIP_CALLBACK_API */  
  LWIP_UNUSED_ARG(connected);
#endif /* LWIP_CALLBACK_API */

  /* Send a SYN together with the MSS option. */
  ret = tcp_enqueue_flags(pcb, TCP_SYN);
    cdf0:	e13ffc17 	ldw	r4,-16(fp)
    cdf4:	01400084 	movi	r5,2
    cdf8:	00135100 	call	13510 <tcp_enqueue_flags>
    cdfc:	e0bffb05 	stb	r2,-20(fp)
  if (ret == ERR_OK) {
    ce00:	e0bffb07 	ldb	r2,-20(fp)
    ce04:	1000291e 	bne	r2,zero,ceac <tcp_connect+0x294>
    /* SYN segment was enqueued, changed the pcbs state now */
    pcb->state = SYN_SENT;
    ce08:	e0bffc17 	ldw	r2,-16(fp)
    ce0c:	00c00084 	movi	r3,2
    ce10:	10c00615 	stw	r3,24(r2)
    if (old_local_port != 0) {
    ce14:	e0bff90b 	ldhu	r2,-28(fp)
    ce18:	10001a26 	beq	r2,zero,ce84 <tcp_connect+0x26c>
      TCP_RMV(&tcp_bound_pcbs, pcb);
    ce1c:	d0e8c017 	ldw	r3,-23808(gp)
    ce20:	e0bffc17 	ldw	r2,-16(fp)
    ce24:	1880041e 	bne	r3,r2,ce38 <tcp_connect+0x220>
    ce28:	d0a8c017 	ldw	r2,-23808(gp)
    ce2c:	10800317 	ldw	r2,12(r2)
    ce30:	d0a8c015 	stw	r2,-23808(gp)
    ce34:	00001106 	br	ce7c <tcp_connect+0x264>
    ce38:	d0a8c017 	ldw	r2,-23808(gp)
    ce3c:	d0a8bf15 	stw	r2,-23812(gp)
    ce40:	00000c06 	br	ce74 <tcp_connect+0x25c>
    ce44:	d0a8bf17 	ldw	r2,-23812(gp)
    ce48:	10c00317 	ldw	r3,12(r2)
    ce4c:	e0bffc17 	ldw	r2,-16(fp)
    ce50:	1880051e 	bne	r3,r2,ce68 <tcp_connect+0x250>
    ce54:	d0a8bf17 	ldw	r2,-23812(gp)
    ce58:	e0fffc17 	ldw	r3,-16(fp)
    ce5c:	18c00317 	ldw	r3,12(r3)
    ce60:	10c00315 	stw	r3,12(r2)
    ce64:	00000506 	br	ce7c <tcp_connect+0x264>
    ce68:	d0a8bf17 	ldw	r2,-23812(gp)
    ce6c:	10800317 	ldw	r2,12(r2)
    ce70:	d0a8bf15 	stw	r2,-23812(gp)
    ce74:	d0a8bf17 	ldw	r2,-23812(gp)
    ce78:	103ff21e 	bne	r2,zero,ce44 <tcp_connect+0x22c>
    ce7c:	e0bffc17 	ldw	r2,-16(fp)
    ce80:	10000315 	stw	zero,12(r2)
    }
    TCP_REG_ACTIVE(pcb);
    ce84:	d0e8bc17 	ldw	r3,-23824(gp)
    ce88:	e0bffc17 	ldw	r2,-16(fp)
    ce8c:	10c00315 	stw	r3,12(r2)
    ce90:	e0bffc17 	ldw	r2,-16(fp)
    ce94:	d0a8bc15 	stw	r2,-23824(gp)
    ce98:	0014fd80 	call	14fd8 <tcp_timer_needed>
    ce9c:	00800044 	movi	r2,1
    cea0:	d0a8bb85 	stb	r2,-23826(gp)
    snmp_inc_tcpactiveopens();

    tcp_output(pcb);
    cea4:	e13ffc17 	ldw	r4,-16(fp)
    cea8:	0013a740 	call	13a74 <tcp_output>
  }
  return ret;
    ceac:	e0bffb03 	ldbu	r2,-20(fp)
}
    ceb0:	e037883a 	mov	sp,fp
    ceb4:	dfc00117 	ldw	ra,4(sp)
    ceb8:	df000017 	ldw	fp,0(sp)
    cebc:	dec00204 	addi	sp,sp,8
    cec0:	f800283a 	ret

0000cec4 <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
    cec4:	defff404 	addi	sp,sp,-48
    cec8:	dfc00b15 	stw	ra,44(sp)
    cecc:	df000a15 	stw	fp,40(sp)
    ced0:	df000a04 	addi	fp,sp,40
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;
    ced4:	e03ffa85 	stb	zero,-22(fp)

  ++tcp_ticks;
    ced8:	d0a8bd17 	ldw	r2,-23820(gp)
    cedc:	10800044 	addi	r2,r2,1
    cee0:	d0a8bd15 	stw	r2,-23820(gp)
  ++tcp_timer_ctr;
    cee4:	d0a8bb43 	ldbu	r2,-23827(gp)
    cee8:	10800044 	addi	r2,r2,1
    ceec:	d0a8bb45 	stb	r2,-23827(gp)
    cef0:	00000106 	br	cef8 <tcp_slowtmr+0x34>
        prev->polltmr = 0;
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        tcp_active_pcbs_changed = 0;
        TCP_EVENT_POLL(prev, err);
        if (tcp_active_pcbs_changed) {
          goto tcp_slowtmr_start;
    cef4:	0001883a 	nop
  ++tcp_ticks;
  ++tcp_timer_ctr;

tcp_slowtmr_start:
  /* Steps through all of the active PCBs. */
  prev = NULL;
    cef8:	e03ff915 	stw	zero,-28(fp)
  pcb = tcp_active_pcbs;
    cefc:	d0a8bc17 	ldw	r2,-23824(gp)
    cf00:	e0bff815 	stw	r2,-32(fp)
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    cf04:	0001c206 	br	d610 <tcp_slowtmr+0x74c>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    cf08:	e0bff817 	ldw	r2,-32(fp)
    cf0c:	10800617 	ldw	r2,24(r2)
    cf10:	1000091e 	bne	r2,zero,cf38 <tcp_slowtmr+0x74>
    cf14:	010000f4 	movhi	r4,3
    cf18:	21011004 	addi	r4,r4,1088
    cf1c:	014000f4 	movhi	r5,3
    cf20:	29416c04 	addi	r5,r5,1456
    cf24:	0180ca84 	movi	r6,810
    cf28:	01c000f4 	movhi	r7,3
    cf2c:	39c12104 	addi	r7,r7,1156
    cf30:	00193f00 	call	193f0 <printf>
    cf34:	003fff06 	br	cf34 <tcp_slowtmr+0x70>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    cf38:	e0bff817 	ldw	r2,-32(fp)
    cf3c:	10800617 	ldw	r2,24(r2)
    cf40:	10800058 	cmpnei	r2,r2,1
    cf44:	1000091e 	bne	r2,zero,cf6c <tcp_slowtmr+0xa8>
    cf48:	010000f4 	movhi	r4,3
    cf4c:	21011004 	addi	r4,r4,1088
    cf50:	014000f4 	movhi	r5,3
    cf54:	29417704 	addi	r5,r5,1500
    cf58:	0180cac4 	movi	r6,811
    cf5c:	01c000f4 	movhi	r7,3
    cf60:	39c12104 	addi	r7,r7,1156
    cf64:	00193f00 	call	193f0 <printf>
    cf68:	003fff06 	br	cf68 <tcp_slowtmr+0xa4>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
    cf6c:	e0bff817 	ldw	r2,-32(fp)
    cf70:	10800617 	ldw	r2,24(r2)
    cf74:	10800298 	cmpnei	r2,r2,10
    cf78:	1000091e 	bne	r2,zero,cfa0 <tcp_slowtmr+0xdc>
    cf7c:	010000f4 	movhi	r4,3
    cf80:	21011004 	addi	r4,r4,1088
    cf84:	014000f4 	movhi	r5,3
    cf88:	29418204 	addi	r5,r5,1544
    cf8c:	0180cb04 	movi	r6,812
    cf90:	01c000f4 	movhi	r7,3
    cf94:	39c12104 	addi	r7,r7,1156
    cf98:	00193f00 	call	193f0 <printf>
    cf9c:	003fff06 	br	cf9c <tcp_slowtmr+0xd8>
    if (pcb->last_timer == tcp_timer_ctr) {
    cfa0:	e0bff817 	ldw	r2,-32(fp)
    cfa4:	10c00943 	ldbu	r3,37(r2)
    cfa8:	d0a8bb43 	ldbu	r2,-23827(gp)
    cfac:	18c03fcc 	andi	r3,r3,255
    cfb0:	10803fcc 	andi	r2,r2,255
    cfb4:	1880041e 	bne	r3,r2,cfc8 <tcp_slowtmr+0x104>
      /* skip this pcb, we have already processed it */
      pcb = pcb->next;
    cfb8:	e0bff817 	ldw	r2,-32(fp)
    cfbc:	10800317 	ldw	r2,12(r2)
    cfc0:	e0bff815 	stw	r2,-32(fp)
      continue;
    cfc4:	00019206 	br	d610 <tcp_slowtmr+0x74c>
    }
    pcb->last_timer = tcp_timer_ctr;
    cfc8:	d0e8bb43 	ldbu	r3,-23827(gp)
    cfcc:	e0bff817 	ldw	r2,-32(fp)
    cfd0:	10c00945 	stb	r3,37(r2)

    pcb_remove = 0;
    cfd4:	e03ffa05 	stb	zero,-24(fp)
    pcb_reset = 0;
    cfd8:	e03ffa45 	stb	zero,-23(fp)

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
    cfdc:	e0bff817 	ldw	r2,-32(fp)
    cfe0:	10800617 	ldw	r2,24(r2)
    cfe4:	10800098 	cmpnei	r2,r2,2
    cfe8:	1000091e 	bne	r2,zero,d010 <tcp_slowtmr+0x14c>
    cfec:	e0bff817 	ldw	r2,-32(fp)
    cff0:	10801283 	ldbu	r2,74(r2)
    cff4:	10803fcc 	andi	r2,r2,255
    cff8:	10800198 	cmpnei	r2,r2,6
    cffc:	1000041e 	bne	r2,zero,d010 <tcp_slowtmr+0x14c>
      ++pcb_remove;
    d000:	e0bffa03 	ldbu	r2,-24(fp)
    d004:	10800044 	addi	r2,r2,1
    d008:	e0bffa05 	stb	r2,-24(fp)
    d00c:	00008c06 	br	d240 <tcp_slowtmr+0x37c>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
    d010:	e0bff817 	ldw	r2,-32(fp)
    d014:	10801283 	ldbu	r2,74(r2)
    d018:	10803fcc 	andi	r2,r2,255
    d01c:	10800318 	cmpnei	r2,r2,12
    d020:	1000041e 	bne	r2,zero,d034 <tcp_slowtmr+0x170>
      ++pcb_remove;
    d024:	e0bffa03 	ldbu	r2,-24(fp)
    d028:	10800044 	addi	r2,r2,1
    d02c:	e0bffa05 	stb	r2,-24(fp)
    d030:	00008306 	br	d240 <tcp_slowtmr+0x37c>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
    d034:	e0bff817 	ldw	r2,-32(fp)
    d038:	10802643 	ldbu	r2,153(r2)
    d03c:	10803fcc 	andi	r2,r2,255
    d040:	10002226 	beq	r2,zero,d0cc <tcp_slowtmr+0x208>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
    d044:	e0bff817 	ldw	r2,-32(fp)
    d048:	10802603 	ldbu	r2,152(r2)
    d04c:	10800044 	addi	r2,r2,1
    d050:	1007883a 	mov	r3,r2
    d054:	e0bff817 	ldw	r2,-32(fp)
    d058:	10c02605 	stb	r3,152(r2)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
    d05c:	e0bff817 	ldw	r2,-32(fp)
    d060:	10c02603 	ldbu	r3,152(r2)
    d064:	e0bff817 	ldw	r2,-32(fp)
    d068:	10802643 	ldbu	r2,153(r2)
    d06c:	10803fcc 	andi	r2,r2,255
    d070:	113fffc4 	addi	r4,r2,-1
    d074:	d0a00484 	addi	r2,gp,-32750
    d078:	2085883a 	add	r2,r4,r2
    d07c:	10800003 	ldbu	r2,0(r2)
    d080:	18c03fcc 	andi	r3,r3,255
    d084:	10803fcc 	andi	r2,r2,255
    d088:	18806d36 	bltu	r3,r2,d240 <tcp_slowtmr+0x37c>
          pcb->persist_cnt = 0;
    d08c:	e0bff817 	ldw	r2,-32(fp)
    d090:	10002605 	stb	zero,152(r2)
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
    d094:	e0bff817 	ldw	r2,-32(fp)
    d098:	10802643 	ldbu	r2,153(r2)
    d09c:	10803fcc 	andi	r2,r2,255
    d0a0:	108001e8 	cmpgeui	r2,r2,7
    d0a4:	1000061e 	bne	r2,zero,d0c0 <tcp_slowtmr+0x1fc>
            pcb->persist_backoff++;
    d0a8:	e0bff817 	ldw	r2,-32(fp)
    d0ac:	10802643 	ldbu	r2,153(r2)
    d0b0:	10800044 	addi	r2,r2,1
    d0b4:	1007883a 	mov	r3,r2
    d0b8:	e0bff817 	ldw	r2,-32(fp)
    d0bc:	10c02645 	stb	r3,153(r2)
          }
          tcp_zero_window_probe(pcb);
    d0c0:	e13ff817 	ldw	r4,-32(fp)
    d0c4:	0014dbc0 	call	14dbc <tcp_zero_window_probe>
    d0c8:	00005d06 	br	d240 <tcp_slowtmr+0x37c>
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0) {
    d0cc:	e0bff817 	ldw	r2,-32(fp)
    d0d0:	10800e0b 	ldhu	r2,56(r2)
    d0d4:	10bfffcc 	andi	r2,r2,65535
    d0d8:	10a0001c 	xori	r2,r2,32768
    d0dc:	10a00004 	addi	r2,r2,-32768
    d0e0:	10000616 	blt	r2,zero,d0fc <tcp_slowtmr+0x238>
          ++pcb->rtime;
    d0e4:	e0bff817 	ldw	r2,-32(fp)
    d0e8:	10800e0b 	ldhu	r2,56(r2)
    d0ec:	10800044 	addi	r2,r2,1
    d0f0:	1007883a 	mov	r3,r2
    d0f4:	e0bff817 	ldw	r2,-32(fp)
    d0f8:	10c00e0d 	sth	r3,56(r2)
        }

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
    d0fc:	e0bff817 	ldw	r2,-32(fp)
    d100:	10801d17 	ldw	r2,116(r2)
    d104:	10004e26 	beq	r2,zero,d240 <tcp_slowtmr+0x37c>
    d108:	e0bff817 	ldw	r2,-32(fp)
    d10c:	10c00e0b 	ldhu	r3,56(r2)
    d110:	e0bff817 	ldw	r2,-32(fp)
    d114:	1080120b 	ldhu	r2,72(r2)
    d118:	18ffffcc 	andi	r3,r3,65535
    d11c:	18e0001c 	xori	r3,r3,32768
    d120:	18e00004 	addi	r3,r3,-32768
    d124:	10bfffcc 	andi	r2,r2,65535
    d128:	10a0001c 	xori	r2,r2,32768
    d12c:	10a00004 	addi	r2,r2,-32768
    d130:	18804316 	blt	r3,r2,d240 <tcp_slowtmr+0x37c>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
    d134:	e0bff817 	ldw	r2,-32(fp)
    d138:	10800617 	ldw	r2,24(r2)
    d13c:	108000a0 	cmpeqi	r2,r2,2
    d140:	10001b1e 	bne	r2,zero,d1b0 <tcp_slowtmr+0x2ec>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
    d144:	e0bff817 	ldw	r2,-32(fp)
    d148:	1080110b 	ldhu	r2,68(r2)
    d14c:	10bfffcc 	andi	r2,r2,65535
    d150:	10a0001c 	xori	r2,r2,32768
    d154:	10a00004 	addi	r2,r2,-32768
    d158:	1005d0fa 	srai	r2,r2,3
    d15c:	10ffffcc 	andi	r3,r2,65535
    d160:	18e0001c 	xori	r3,r3,32768
    d164:	18e00004 	addi	r3,r3,-32768
    d168:	e0bff817 	ldw	r2,-32(fp)
    d16c:	1080118b 	ldhu	r2,70(r2)
    d170:	10bfffcc 	andi	r2,r2,65535
    d174:	10a0001c 	xori	r2,r2,32768
    d178:	10a00004 	addi	r2,r2,-32768
    d17c:	1887883a 	add	r3,r3,r2
    d180:	e0bff817 	ldw	r2,-32(fp)
    d184:	10801283 	ldbu	r2,74(r2)
    d188:	10803fcc 	andi	r2,r2,255
    d18c:	010000f4 	movhi	r4,3
    d190:	21010804 	addi	r4,r4,1056
    d194:	2085883a 	add	r2,r4,r2
    d198:	10800003 	ldbu	r2,0(r2)
    d19c:	10803fcc 	andi	r2,r2,255
    d1a0:	1884983a 	sll	r2,r3,r2
    d1a4:	1007883a 	mov	r3,r2
    d1a8:	e0bff817 	ldw	r2,-32(fp)
    d1ac:	10c0120d 	sth	r3,72(r2)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
    d1b0:	e0bff817 	ldw	r2,-32(fp)
    d1b4:	10000e0d 	sth	zero,56(r2)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
    d1b8:	e0bff817 	ldw	r2,-32(fp)
    d1bc:	1080190b 	ldhu	r2,100(r2)
    d1c0:	e0fff817 	ldw	r3,-32(fp)
    d1c4:	18c0140b 	ldhu	r3,80(r3)
    d1c8:	113fffcc 	andi	r4,r2,65535
    d1cc:	197fffcc 	andi	r5,r3,65535
    d1d0:	2900012e 	bgeu	r5,r4,d1d8 <tcp_slowtmr+0x314>
    d1d4:	1805883a 	mov	r2,r3
    d1d8:	e0bffb0d 	sth	r2,-20(fp)
          pcb->ssthresh = eff_wnd >> 1;
    d1dc:	e0bffb0b 	ldhu	r2,-20(fp)
    d1e0:	1004d07a 	srli	r2,r2,1
    d1e4:	1007883a 	mov	r3,r2
    d1e8:	e0bff817 	ldw	r2,-32(fp)
    d1ec:	10c0148d 	sth	r3,82(r2)
          if (pcb->ssthresh < (pcb->mss << 1)) {
    d1f0:	e0bff817 	ldw	r2,-32(fp)
    d1f4:	1080148b 	ldhu	r2,82(r2)
    d1f8:	10ffffcc 	andi	r3,r2,65535
    d1fc:	e0bff817 	ldw	r2,-32(fp)
    d200:	10800e8b 	ldhu	r2,58(r2)
    d204:	10bfffcc 	andi	r2,r2,65535
    d208:	1085883a 	add	r2,r2,r2
    d20c:	1880060e 	bge	r3,r2,d228 <tcp_slowtmr+0x364>
            pcb->ssthresh = (pcb->mss << 1);
    d210:	e0bff817 	ldw	r2,-32(fp)
    d214:	10800e8b 	ldhu	r2,58(r2)
    d218:	1085883a 	add	r2,r2,r2
    d21c:	1007883a 	mov	r3,r2
    d220:	e0bff817 	ldw	r2,-32(fp)
    d224:	10c0148d 	sth	r3,82(r2)
          }
          pcb->cwnd = pcb->mss;
    d228:	e0bff817 	ldw	r2,-32(fp)
    d22c:	10c00e8b 	ldhu	r3,58(r2)
    d230:	e0bff817 	ldw	r2,-32(fp)
    d234:	10c0140d 	sth	r3,80(r2)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
    d238:	e13ff817 	ldw	r4,-32(fp)
    d23c:	00148b80 	call	148b8 <tcp_rexmit_rto>
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
    d240:	e0bff817 	ldw	r2,-32(fp)
    d244:	10800617 	ldw	r2,24(r2)
    d248:	10800198 	cmpnei	r2,r2,6
    d24c:	10000e1e 	bne	r2,zero,d288 <tcp_slowtmr+0x3c4>
      /* If this PCB is in FIN_WAIT_2 because of SHUT_WR don't let it time out. */
      if (pcb->flags & TF_RXCLOSED) {
    d250:	e0bff817 	ldw	r2,-32(fp)
    d254:	10800883 	ldbu	r2,34(r2)
    d258:	10803fcc 	andi	r2,r2,255
    d25c:	1080040c 	andi	r2,r2,16
    d260:	10000926 	beq	r2,zero,d288 <tcp_slowtmr+0x3c4>
        /* PCB was fully closed (either through close() or SHUT_RDWR):
           normal FIN-WAIT timeout handling. */
        if ((u32_t)(tcp_ticks - pcb->tmr) >
    d264:	d0e8bd17 	ldw	r3,-23820(gp)
    d268:	e0bff817 	ldw	r2,-32(fp)
    d26c:	10800a17 	ldw	r2,40(r2)
    d270:	1885c83a 	sub	r2,r3,r2
    d274:	10800a70 	cmpltui	r2,r2,41
    d278:	1000031e 	bne	r2,zero,d288 <tcp_slowtmr+0x3c4>
            TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
          ++pcb_remove;
    d27c:	e0bffa03 	ldbu	r2,-24(fp)
    d280:	10800044 	addi	r2,r2,1
    d284:	e0bffa05 	stb	r2,-24(fp)
        }
      }
    }

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
    d288:	e0bff817 	ldw	r2,-32(fp)
    d28c:	10800203 	ldbu	r2,8(r2)
    d290:	10803fcc 	andi	r2,r2,255
    d294:	1080020c 	andi	r2,r2,8
    d298:	10003326 	beq	r2,zero,d368 <tcp_slowtmr+0x4a4>
       ((pcb->state == ESTABLISHED) ||
    d29c:	e0bff817 	ldw	r2,-32(fp)
    d2a0:	10800617 	ldw	r2,24(r2)
        }
      }
    }

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
    d2a4:	10800120 	cmpeqi	r2,r2,4
    d2a8:	1000041e 	bne	r2,zero,d2bc <tcp_slowtmr+0x3f8>
       ((pcb->state == ESTABLISHED) ||
        (pcb->state == CLOSE_WAIT))) {
    d2ac:	e0bff817 	ldw	r2,-32(fp)
    d2b0:	10800617 	ldw	r2,24(r2)
      }
    }

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
       ((pcb->state == ESTABLISHED) ||
    d2b4:	108001d8 	cmpnei	r2,r2,7
    d2b8:	10002b1e 	bne	r2,zero,d368 <tcp_slowtmr+0x4a4>
        (pcb->state == CLOSE_WAIT))) {
      if((u32_t)(tcp_ticks - pcb->tmr) >
    d2bc:	d0e8bd17 	ldw	r3,-23820(gp)
    d2c0:	e0bff817 	ldw	r2,-32(fp)
    d2c4:	10800a17 	ldw	r2,40(r2)
    d2c8:	1885c83a 	sub	r2,r3,r2
         (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
    d2cc:	e0fff817 	ldw	r3,-32(fp)
    d2d0:	19002517 	ldw	r4,148(r3)
    d2d4:	00c002b4 	movhi	r3,10
    d2d8:	18d32e04 	addi	r3,r3,19640
    d2dc:	20c9883a 	add	r4,r4,r3
    d2e0:	00c07d04 	movi	r3,500
    d2e4:	20c7203a 	divu	r3,r4,r3

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
       ((pcb->state == ESTABLISHED) ||
        (pcb->state == CLOSE_WAIT))) {
      if((u32_t)(tcp_ticks - pcb->tmr) >
    d2e8:	1880072e 	bgeu	r3,r2,d308 <tcp_slowtmr+0x444>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                                ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
        
        ++pcb_remove;
    d2ec:	e0bffa03 	ldbu	r2,-24(fp)
    d2f0:	10800044 	addi	r2,r2,1
    d2f4:	e0bffa05 	stb	r2,-24(fp)
        ++pcb_reset;
    d2f8:	e0bffa43 	ldbu	r2,-23(fp)
    d2fc:	10800044 	addi	r2,r2,1
    d300:	e0bffa45 	stb	r2,-23(fp)
    d304:	00001806 	br	d368 <tcp_slowtmr+0x4a4>
      }
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
    d308:	d0e8bd17 	ldw	r3,-23820(gp)
    d30c:	e0bff817 	ldw	r2,-32(fp)
    d310:	10800a17 	ldw	r2,40(r2)
    d314:	1885c83a 	sub	r2,r3,r2
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
    d318:	e0fff817 	ldw	r3,-32(fp)
    d31c:	19002517 	ldw	r4,148(r3)
    d320:	e0fff817 	ldw	r3,-32(fp)
    d324:	18c02683 	ldbu	r3,154(r3)
    d328:	19403fcc 	andi	r5,r3,255
    d32c:	00c00074 	movhi	r3,1
    d330:	18c93e04 	addi	r3,r3,9464
    d334:	28c7383a 	mul	r3,r5,r3
    d338:	20c9883a 	add	r4,r4,r3
              / TCP_SLOW_INTERVAL)
    d33c:	00c07d04 	movi	r3,500
    d340:	20c7203a 	divu	r3,r4,r3
                                ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
        
        ++pcb_remove;
        ++pcb_reset;
      }
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
    d344:	1880082e 	bgeu	r3,r2,d368 <tcp_slowtmr+0x4a4>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
              / TCP_SLOW_INTERVAL)
      {
        tcp_keepalive(pcb);
    d348:	e13ff817 	ldw	r4,-32(fp)
    d34c:	0014c780 	call	14c78 <tcp_keepalive>
        pcb->keep_cnt_sent++;
    d350:	e0bff817 	ldw	r2,-32(fp)
    d354:	10802683 	ldbu	r2,154(r2)
    d358:	10800044 	addi	r2,r2,1
    d35c:	1007883a 	mov	r3,r2
    d360:	e0bff817 	ldw	r2,-32(fp)
    d364:	10c02685 	stb	r3,154(r2)

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL &&
    d368:	e0bff817 	ldw	r2,-32(fp)
    d36c:	10801e17 	ldw	r2,120(r2)
    d370:	10001126 	beq	r2,zero,d3b8 <tcp_slowtmr+0x4f4>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
    d374:	d0e8bd17 	ldw	r3,-23820(gp)
    d378:	e0bff817 	ldw	r2,-32(fp)
    d37c:	10800a17 	ldw	r2,40(r2)
    d380:	1887c83a 	sub	r3,r3,r2
    d384:	e0bff817 	ldw	r2,-32(fp)
    d388:	1080120b 	ldhu	r2,72(r2)
    d38c:	10bfffcc 	andi	r2,r2,65535
    d390:	10a0001c 	xori	r2,r2,32768
    d394:	10a00004 	addi	r2,r2,-32768
    d398:	108001a4 	muli	r2,r2,6

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL &&
    d39c:	18800636 	bltu	r3,r2,d3b8 <tcp_slowtmr+0x4f4>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
    d3a0:	e0bff817 	ldw	r2,-32(fp)
    d3a4:	10801e17 	ldw	r2,120(r2)
    d3a8:	1009883a 	mov	r4,r2
    d3ac:	000d9b80 	call	d9b8 <tcp_segs_free>
      pcb->ooseq = NULL;
    d3b0:	e0bff817 	ldw	r2,-32(fp)
    d3b4:	10001e15 	stw	zero,120(r2)
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
    d3b8:	e0bff817 	ldw	r2,-32(fp)
    d3bc:	10800617 	ldw	r2,24(r2)
    d3c0:	108000d8 	cmpnei	r2,r2,3
    d3c4:	1000091e 	bne	r2,zero,d3ec <tcp_slowtmr+0x528>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
    d3c8:	d0e8bd17 	ldw	r3,-23820(gp)
    d3cc:	e0bff817 	ldw	r2,-32(fp)
    d3d0:	10800a17 	ldw	r2,40(r2)
    d3d4:	1885c83a 	sub	r2,r3,r2
    d3d8:	10800a70 	cmpltui	r2,r2,41
    d3dc:	1000031e 	bne	r2,zero,d3ec <tcp_slowtmr+0x528>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
    d3e0:	e0bffa03 	ldbu	r2,-24(fp)
    d3e4:	10800044 	addi	r2,r2,1
    d3e8:	e0bffa05 	stb	r2,-24(fp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
    d3ec:	e0bff817 	ldw	r2,-32(fp)
    d3f0:	10800617 	ldw	r2,24(r2)
    d3f4:	10800258 	cmpnei	r2,r2,9
    d3f8:	1000091e 	bne	r2,zero,d420 <tcp_slowtmr+0x55c>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
    d3fc:	d0e8bd17 	ldw	r3,-23820(gp)
    d400:	e0bff817 	ldw	r2,-32(fp)
    d404:	10800a17 	ldw	r2,40(r2)
    d408:	1885c83a 	sub	r2,r3,r2
    d40c:	10803c70 	cmpltui	r2,r2,241
    d410:	1000031e 	bne	r2,zero,d420 <tcp_slowtmr+0x55c>
        ++pcb_remove;
    d414:	e0bffa03 	ldbu	r2,-24(fp)
    d418:	10800044 	addi	r2,r2,1
    d41c:	e0bffa05 	stb	r2,-24(fp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
    d420:	e0bffa03 	ldbu	r2,-24(fp)
    d424:	10005126 	beq	r2,zero,d56c <tcp_slowtmr+0x6a8>
      struct tcp_pcb *pcb2;
      tcp_err_fn err_fn;
      void *err_arg;
      tcp_pcb_purge(pcb);
    d428:	e13ff817 	ldw	r4,-32(fp)
    d42c:	000e1180 	call	e118 <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
    d430:	e0bff917 	ldw	r2,-28(fp)
    d434:	10001126 	beq	r2,zero,d47c <tcp_slowtmr+0x5b8>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
    d438:	d0a8bc17 	ldw	r2,-23824(gp)
    d43c:	e0fff817 	ldw	r3,-32(fp)
    d440:	1880091e 	bne	r3,r2,d468 <tcp_slowtmr+0x5a4>
    d444:	010000f4 	movhi	r4,3
    d448:	21011004 	addi	r4,r4,1088
    d44c:	014000f4 	movhi	r5,3
    d450:	29418e04 	addi	r5,r5,1592
    d454:	0180ee84 	movi	r6,954
    d458:	01c000f4 	movhi	r7,3
    d45c:	39c12104 	addi	r7,r7,1156
    d460:	00193f00 	call	193f0 <printf>
    d464:	003fff06 	br	d464 <tcp_slowtmr+0x5a0>
        prev->next = pcb->next;
    d468:	e0bff817 	ldw	r2,-32(fp)
    d46c:	10c00317 	ldw	r3,12(r2)
    d470:	e0bff917 	ldw	r2,-28(fp)
    d474:	10c00315 	stw	r3,12(r2)
    d478:	00000f06 	br	d4b8 <tcp_slowtmr+0x5f4>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
    d47c:	d0e8bc17 	ldw	r3,-23824(gp)
    d480:	e0bff817 	ldw	r2,-32(fp)
    d484:	18800926 	beq	r3,r2,d4ac <tcp_slowtmr+0x5e8>
    d488:	010000f4 	movhi	r4,3
    d48c:	21011004 	addi	r4,r4,1088
    d490:	014000f4 	movhi	r5,3
    d494:	29419904 	addi	r5,r5,1636
    d498:	0180ef84 	movi	r6,958
    d49c:	01c000f4 	movhi	r7,3
    d4a0:	39c12104 	addi	r7,r7,1156
    d4a4:	00193f00 	call	193f0 <printf>
    d4a8:	003fff06 	br	d4a8 <tcp_slowtmr+0x5e4>
        tcp_active_pcbs = pcb->next;
    d4ac:	e0bff817 	ldw	r2,-32(fp)
    d4b0:	10800317 	ldw	r2,12(r2)
    d4b4:	d0a8bc15 	stw	r2,-23824(gp)
      }

      if (pcb_reset) {
    d4b8:	e0bffa43 	ldbu	r2,-23(fp)
    d4bc:	10001226 	beq	r2,zero,d508 <tcp_slowtmr+0x644>
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
    d4c0:	e0bff817 	ldw	r2,-32(fp)
    d4c4:	11001517 	ldw	r4,84(r2)
    d4c8:	e0bff817 	ldw	r2,-32(fp)
    d4cc:	11400b17 	ldw	r5,44(r2)
    d4d0:	e0fff817 	ldw	r3,-32(fp)
    d4d4:	e0bff817 	ldw	r2,-32(fp)
    d4d8:	10800104 	addi	r2,r2,4
          pcb->local_port, pcb->remote_port);
    d4dc:	e1bff817 	ldw	r6,-32(fp)
    d4e0:	3180078b 	ldhu	r6,30(r6)
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
      }

      if (pcb_reset) {
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
    d4e4:	31ffffcc 	andi	r7,r6,65535
          pcb->local_port, pcb->remote_port);
    d4e8:	e1bff817 	ldw	r6,-32(fp)
    d4ec:	3180080b 	ldhu	r6,32(r6)
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
      }

      if (pcb_reset) {
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
    d4f0:	31bfffcc 	andi	r6,r6,65535
    d4f4:	d9c00015 	stw	r7,0(sp)
    d4f8:	d9800115 	stw	r6,4(sp)
    d4fc:	180d883a 	mov	r6,r3
    d500:	100f883a 	mov	r7,r2
    d504:	00146680 	call	14668 <tcp_rst>
          pcb->local_port, pcb->remote_port);
      }

      err_fn = pcb->errf;
    d508:	e0bff817 	ldw	r2,-32(fp)
    d50c:	10802417 	ldw	r2,144(r2)
    d510:	e0bffc15 	stw	r2,-16(fp)
      err_arg = pcb->callback_arg;
    d514:	e0bff817 	ldw	r2,-32(fp)
    d518:	10800417 	ldw	r2,16(r2)
    d51c:	e0bffd15 	stw	r2,-12(fp)
      pcb2 = pcb;
    d520:	e0bff817 	ldw	r2,-32(fp)
    d524:	e0bffe15 	stw	r2,-8(fp)
      pcb = pcb->next;
    d528:	e0bff817 	ldw	r2,-32(fp)
    d52c:	10800317 	ldw	r2,12(r2)
    d530:	e0bff815 	stw	r2,-32(fp)
      memp_free(MEMP_TCP_PCB, pcb2);
    d534:	01000084 	movi	r4,2
    d538:	e17ffe17 	ldw	r5,-8(fp)
    d53c:	00097d40 	call	97d4 <memp_free>

      tcp_active_pcbs_changed = 0;
    d540:	d028bb85 	stb	zero,-23826(gp)
      TCP_EVENT_ERR(err_fn, err_arg, ERR_ABRT);
    d544:	e0bffc17 	ldw	r2,-16(fp)
    d548:	10000426 	beq	r2,zero,d55c <tcp_slowtmr+0x698>
    d54c:	e0bffc17 	ldw	r2,-16(fp)
    d550:	e13ffd17 	ldw	r4,-12(fp)
    d554:	017ffd84 	movi	r5,-10
    d558:	103ee83a 	callr	r2
      if (tcp_active_pcbs_changed) {
    d55c:	d0a8bb83 	ldbu	r2,-23826(gp)
    d560:	10803fcc 	andi	r2,r2,255
    d564:	10002a26 	beq	r2,zero,d610 <tcp_slowtmr+0x74c>
        goto tcp_slowtmr_start;
    d568:	003e6306 	br	cef8 <tcp_slowtmr+0x34>
      }
    } else {
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
    d56c:	e0bff817 	ldw	r2,-32(fp)
    d570:	e0bff915 	stw	r2,-28(fp)
      pcb = pcb->next;
    d574:	e0bff817 	ldw	r2,-32(fp)
    d578:	10800317 	ldw	r2,12(r2)
    d57c:	e0bff815 	stw	r2,-32(fp)

      /* We check if we should poll the connection. */
      ++prev->polltmr;
    d580:	e0bff917 	ldw	r2,-28(fp)
    d584:	108008c3 	ldbu	r2,35(r2)
    d588:	10800044 	addi	r2,r2,1
    d58c:	1007883a 	mov	r3,r2
    d590:	e0bff917 	ldw	r2,-28(fp)
    d594:	10c008c5 	stb	r3,35(r2)
      if (prev->polltmr >= prev->pollinterval) {
    d598:	e0bff917 	ldw	r2,-28(fp)
    d59c:	10c008c3 	ldbu	r3,35(r2)
    d5a0:	e0bff917 	ldw	r2,-28(fp)
    d5a4:	10800903 	ldbu	r2,36(r2)
    d5a8:	18c03fcc 	andi	r3,r3,255
    d5ac:	10803fcc 	andi	r2,r2,255
    d5b0:	18801736 	bltu	r3,r2,d610 <tcp_slowtmr+0x74c>
        prev->polltmr = 0;
    d5b4:	e0bff917 	ldw	r2,-28(fp)
    d5b8:	100008c5 	stb	zero,35(r2)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        tcp_active_pcbs_changed = 0;
    d5bc:	d028bb85 	stb	zero,-23826(gp)
        TCP_EVENT_POLL(prev, err);
    d5c0:	e0bff917 	ldw	r2,-28(fp)
    d5c4:	10802317 	ldw	r2,140(r2)
    d5c8:	10000926 	beq	r2,zero,d5f0 <tcp_slowtmr+0x72c>
    d5cc:	e0bff917 	ldw	r2,-28(fp)
    d5d0:	10c02317 	ldw	r3,140(r2)
    d5d4:	e0bff917 	ldw	r2,-28(fp)
    d5d8:	10800417 	ldw	r2,16(r2)
    d5dc:	1009883a 	mov	r4,r2
    d5e0:	e17ff917 	ldw	r5,-28(fp)
    d5e4:	183ee83a 	callr	r3
    d5e8:	e0bffa85 	stb	r2,-22(fp)
    d5ec:	00000106 	br	d5f4 <tcp_slowtmr+0x730>
    d5f0:	e03ffa85 	stb	zero,-22(fp)
        if (tcp_active_pcbs_changed) {
    d5f4:	d0a8bb83 	ldbu	r2,-23826(gp)
    d5f8:	10803fcc 	andi	r2,r2,255
    d5fc:	103e3d1e 	bne	r2,zero,cef4 <tcp_slowtmr+0x30>
          goto tcp_slowtmr_start;
        }
        /* if err == ERR_ABRT, 'prev' is already deallocated */
        if (err == ERR_OK) {
    d600:	e0bffa87 	ldb	r2,-22(fp)
    d604:	1000021e 	bne	r2,zero,d610 <tcp_slowtmr+0x74c>
          tcp_output(prev);
    d608:	e13ff917 	ldw	r4,-28(fp)
    d60c:	0013a740 	call	13a74 <tcp_output>
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    d610:	e0bff817 	ldw	r2,-32(fp)
    d614:	103e3c1e 	bne	r2,zero,cf08 <tcp_slowtmr+0x44>
    }
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
    d618:	e03ff915 	stw	zero,-28(fp)
  pcb = tcp_tw_pcbs;
    d61c:	d0a8c117 	ldw	r2,-23804(gp)
    d620:	e0bff815 	stw	r2,-32(fp)
  while (pcb != NULL) {
    d624:	00004b06 	br	d754 <tcp_slowtmr+0x890>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
    d628:	e0bff817 	ldw	r2,-32(fp)
    d62c:	10800617 	ldw	r2,24(r2)
    d630:	108002a0 	cmpeqi	r2,r2,10
    d634:	1000091e 	bne	r2,zero,d65c <tcp_slowtmr+0x798>
    d638:	010000f4 	movhi	r4,3
    d63c:	21011004 	addi	r4,r4,1088
    d640:	014000f4 	movhi	r5,3
    d644:	2941a404 	addi	r5,r5,1680
    d648:	0180fb84 	movi	r6,1006
    d64c:	01c000f4 	movhi	r7,3
    d650:	39c12104 	addi	r7,r7,1156
    d654:	00193f00 	call	193f0 <printf>
    d658:	003fff06 	br	d658 <tcp_slowtmr+0x794>
    pcb_remove = 0;
    d65c:	e03ffa05 	stb	zero,-24(fp)

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
    d660:	d0e8bd17 	ldw	r3,-23820(gp)
    d664:	e0bff817 	ldw	r2,-32(fp)
    d668:	10800a17 	ldw	r2,40(r2)
    d66c:	1885c83a 	sub	r2,r3,r2
    d670:	10803c70 	cmpltui	r2,r2,241
    d674:	1000031e 	bne	r2,zero,d684 <tcp_slowtmr+0x7c0>
      ++pcb_remove;
    d678:	e0bffa03 	ldbu	r2,-24(fp)
    d67c:	10800044 	addi	r2,r2,1
    d680:	e0bffa05 	stb	r2,-24(fp)
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
    d684:	e0bffa03 	ldbu	r2,-24(fp)
    d688:	10002d26 	beq	r2,zero,d740 <tcp_slowtmr+0x87c>
      struct tcp_pcb *pcb2;
      tcp_pcb_purge(pcb);
    d68c:	e13ff817 	ldw	r4,-32(fp)
    d690:	000e1180 	call	e118 <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
    d694:	e0bff917 	ldw	r2,-28(fp)
    d698:	10001126 	beq	r2,zero,d6e0 <tcp_slowtmr+0x81c>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
    d69c:	d0a8c117 	ldw	r2,-23804(gp)
    d6a0:	e0fff817 	ldw	r3,-32(fp)
    d6a4:	1880091e 	bne	r3,r2,d6cc <tcp_slowtmr+0x808>
    d6a8:	010000f4 	movhi	r4,3
    d6ac:	21011004 	addi	r4,r4,1088
    d6b0:	014000f4 	movhi	r5,3
    d6b4:	2941b004 	addi	r5,r5,1728
    d6b8:	0180ff84 	movi	r6,1022
    d6bc:	01c000f4 	movhi	r7,3
    d6c0:	39c12104 	addi	r7,r7,1156
    d6c4:	00193f00 	call	193f0 <printf>
    d6c8:	003fff06 	br	d6c8 <tcp_slowtmr+0x804>
        prev->next = pcb->next;
    d6cc:	e0bff817 	ldw	r2,-32(fp)
    d6d0:	10c00317 	ldw	r3,12(r2)
    d6d4:	e0bff917 	ldw	r2,-28(fp)
    d6d8:	10c00315 	stw	r3,12(r2)
    d6dc:	00000f06 	br	d71c <tcp_slowtmr+0x858>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
    d6e0:	d0e8c117 	ldw	r3,-23804(gp)
    d6e4:	e0bff817 	ldw	r2,-32(fp)
    d6e8:	18800926 	beq	r3,r2,d710 <tcp_slowtmr+0x84c>
    d6ec:	010000f4 	movhi	r4,3
    d6f0:	21011004 	addi	r4,r4,1088
    d6f4:	014000f4 	movhi	r5,3
    d6f8:	2941ba04 	addi	r5,r5,1768
    d6fc:	01810084 	movi	r6,1026
    d700:	01c000f4 	movhi	r7,3
    d704:	39c12104 	addi	r7,r7,1156
    d708:	00193f00 	call	193f0 <printf>
    d70c:	003fff06 	br	d70c <tcp_slowtmr+0x848>
        tcp_tw_pcbs = pcb->next;
    d710:	e0bff817 	ldw	r2,-32(fp)
    d714:	10800317 	ldw	r2,12(r2)
    d718:	d0a8c115 	stw	r2,-23804(gp)
      }
      pcb2 = pcb;
    d71c:	e0bff817 	ldw	r2,-32(fp)
    d720:	e0bfff15 	stw	r2,-4(fp)
      pcb = pcb->next;
    d724:	e0bff817 	ldw	r2,-32(fp)
    d728:	10800317 	ldw	r2,12(r2)
    d72c:	e0bff815 	stw	r2,-32(fp)
      memp_free(MEMP_TCP_PCB, pcb2);
    d730:	01000084 	movi	r4,2
    d734:	e17fff17 	ldw	r5,-4(fp)
    d738:	00097d40 	call	97d4 <memp_free>
    d73c:	00000506 	br	d754 <tcp_slowtmr+0x890>
    } else {
      prev = pcb;
    d740:	e0bff817 	ldw	r2,-32(fp)
    d744:	e0bff915 	stw	r2,-28(fp)
      pcb = pcb->next;
    d748:	e0bff817 	ldw	r2,-32(fp)
    d74c:	10800317 	ldw	r2,12(r2)
    d750:	e0bff815 	stw	r2,-32(fp)

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
    d754:	e0bff817 	ldw	r2,-32(fp)
    d758:	103fb31e 	bne	r2,zero,d628 <tcp_slowtmr+0x764>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
    d75c:	e037883a 	mov	sp,fp
    d760:	dfc00117 	ldw	ra,4(sp)
    d764:	df000017 	ldw	fp,0(sp)
    d768:	dec00204 	addi	sp,sp,8
    d76c:	f800283a 	ret

0000d770 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
    d770:	defffc04 	addi	sp,sp,-16
    d774:	dfc00315 	stw	ra,12(sp)
    d778:	df000215 	stw	fp,8(sp)
    d77c:	df000204 	addi	fp,sp,8
  struct tcp_pcb *pcb;

  ++tcp_timer_ctr;
    d780:	d0a8bb43 	ldbu	r2,-23827(gp)
    d784:	10800044 	addi	r2,r2,1
    d788:	d0a8bb45 	stb	r2,-23827(gp)
    d78c:	00000106 	br	d794 <tcp_fasttmr+0x24>
      if (pcb->refused_data != NULL) {
        tcp_active_pcbs_changed = 0;
        tcp_process_refused_data(pcb);
        if (tcp_active_pcbs_changed) {
          /* application callback has changed the pcb list: restart the loop */
          goto tcp_fasttmr_start;
    d790:	0001883a 	nop
  struct tcp_pcb *pcb;

  ++tcp_timer_ctr;

tcp_fasttmr_start:
  pcb = tcp_active_pcbs;
    d794:	d0a8bc17 	ldw	r2,-23824(gp)
    d798:	e0bffe15 	stw	r2,-8(fp)

  while(pcb != NULL) {
    d79c:	00002b06 	br	d84c <tcp_fasttmr+0xdc>
    if (pcb->last_timer != tcp_timer_ctr) {
    d7a0:	e0bffe17 	ldw	r2,-8(fp)
    d7a4:	10c00943 	ldbu	r3,37(r2)
    d7a8:	d0a8bb43 	ldbu	r2,-23827(gp)
    d7ac:	18c03fcc 	andi	r3,r3,255
    d7b0:	10803fcc 	andi	r2,r2,255
    d7b4:	18802526 	beq	r3,r2,d84c <tcp_fasttmr+0xdc>
      struct tcp_pcb *next;
      pcb->last_timer = tcp_timer_ctr;
    d7b8:	d0e8bb43 	ldbu	r3,-23827(gp)
    d7bc:	e0bffe17 	ldw	r2,-8(fp)
    d7c0:	10c00945 	stb	r3,37(r2)
      /* send delayed ACKs */
      if (pcb->flags & TF_ACK_DELAY) {
    d7c4:	e0bffe17 	ldw	r2,-8(fp)
    d7c8:	10800883 	ldbu	r2,34(r2)
    d7cc:	10803fcc 	andi	r2,r2,255
    d7d0:	1080004c 	andi	r2,r2,1
    d7d4:	10000f26 	beq	r2,zero,d814 <tcp_fasttmr+0xa4>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
        tcp_ack_now(pcb);
    d7d8:	e0bffe17 	ldw	r2,-8(fp)
    d7dc:	10800883 	ldbu	r2,34(r2)
    d7e0:	10800094 	ori	r2,r2,2
    d7e4:	1007883a 	mov	r3,r2
    d7e8:	e0bffe17 	ldw	r2,-8(fp)
    d7ec:	10c00885 	stb	r3,34(r2)
        tcp_output(pcb);
    d7f0:	e13ffe17 	ldw	r4,-8(fp)
    d7f4:	0013a740 	call	13a74 <tcp_output>
        pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    d7f8:	e0bffe17 	ldw	r2,-8(fp)
    d7fc:	10c00883 	ldbu	r3,34(r2)
    d800:	00bfff04 	movi	r2,-4
    d804:	1884703a 	and	r2,r3,r2
    d808:	1007883a 	mov	r3,r2
    d80c:	e0bffe17 	ldw	r2,-8(fp)
    d810:	10c00885 	stb	r3,34(r2)
      }

      next = pcb->next;
    d814:	e0bffe17 	ldw	r2,-8(fp)
    d818:	10800317 	ldw	r2,12(r2)
    d81c:	e0bfff15 	stw	r2,-4(fp)

      /* If there is data which was previously "refused" by upper layer */
      if (pcb->refused_data != NULL) {
    d820:	e0bffe17 	ldw	r2,-8(fp)
    d824:	10801f17 	ldw	r2,124(r2)
    d828:	10000626 	beq	r2,zero,d844 <tcp_fasttmr+0xd4>
        tcp_active_pcbs_changed = 0;
    d82c:	d028bb85 	stb	zero,-23826(gp)
        tcp_process_refused_data(pcb);
    d830:	e13ffe17 	ldw	r4,-8(fp)
    d834:	000d8680 	call	d868 <tcp_process_refused_data>
        if (tcp_active_pcbs_changed) {
    d838:	d0a8bb83 	ldbu	r2,-23826(gp)
    d83c:	10803fcc 	andi	r2,r2,255
    d840:	103fd31e 	bne	r2,zero,d790 <tcp_fasttmr+0x20>
          /* application callback has changed the pcb list: restart the loop */
          goto tcp_fasttmr_start;
        }
      }
      pcb = next;
    d844:	e0bfff17 	ldw	r2,-4(fp)
    d848:	e0bffe15 	stw	r2,-8(fp)
  ++tcp_timer_ctr;

tcp_fasttmr_start:
  pcb = tcp_active_pcbs;

  while(pcb != NULL) {
    d84c:	e0bffe17 	ldw	r2,-8(fp)
    d850:	103fd31e 	bne	r2,zero,d7a0 <tcp_fasttmr+0x30>
        }
      }
      pcb = next;
    }
  }
}
    d854:	e037883a 	mov	sp,fp
    d858:	dfc00117 	ldw	ra,4(sp)
    d85c:	df000017 	ldw	fp,0(sp)
    d860:	dec00204 	addi	sp,sp,8
    d864:	f800283a 	ret

0000d868 <tcp_process_refused_data>:

/** Pass pcb->refused_data to the recv callback */
err_t
tcp_process_refused_data(struct tcp_pcb *pcb)
{
    d868:	defffb04 	addi	sp,sp,-20
    d86c:	dfc00415 	stw	ra,16(sp)
    d870:	df000315 	stw	fp,12(sp)
    d874:	df000304 	addi	fp,sp,12
    d878:	e13fff15 	stw	r4,-4(fp)
  err_t err;
  u8_t refused_flags = pcb->refused_data->flags;
    d87c:	e0bfff17 	ldw	r2,-4(fp)
    d880:	10801f17 	ldw	r2,124(r2)
    d884:	10800343 	ldbu	r2,13(r2)
    d888:	e0bffd45 	stb	r2,-11(fp)
  /* set pcb->refused_data to NULL in case the callback frees it and then
     closes the pcb */
  struct pbuf *refused_data = pcb->refused_data;
    d88c:	e0bfff17 	ldw	r2,-4(fp)
    d890:	10801f17 	ldw	r2,124(r2)
    d894:	e0bffe15 	stw	r2,-8(fp)
  pcb->refused_data = NULL;
    d898:	e0bfff17 	ldw	r2,-4(fp)
    d89c:	10001f15 	stw	zero,124(r2)
  /* Notify again application with data previously received. */
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
  TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
    d8a0:	e0bfff17 	ldw	r2,-4(fp)
    d8a4:	10802117 	ldw	r2,132(r2)
    d8a8:	10000b26 	beq	r2,zero,d8d8 <tcp_process_refused_data+0x70>
    d8ac:	e0bfff17 	ldw	r2,-4(fp)
    d8b0:	10c02117 	ldw	r3,132(r2)
    d8b4:	e0bfff17 	ldw	r2,-4(fp)
    d8b8:	10800417 	ldw	r2,16(r2)
    d8bc:	1009883a 	mov	r4,r2
    d8c0:	e17fff17 	ldw	r5,-4(fp)
    d8c4:	e1bffe17 	ldw	r6,-8(fp)
    d8c8:	000f883a 	mov	r7,zero
    d8cc:	183ee83a 	callr	r3
    d8d0:	e0bffd05 	stb	r2,-12(fp)
    d8d4:	00000606 	br	d8f0 <tcp_process_refused_data+0x88>
    d8d8:	0009883a 	mov	r4,zero
    d8dc:	e17fff17 	ldw	r5,-4(fp)
    d8e0:	e1bffe17 	ldw	r6,-8(fp)
    d8e4:	000f883a 	mov	r7,zero
    d8e8:	000dafc0 	call	dafc <tcp_recv_null>
    d8ec:	e0bffd05 	stb	r2,-12(fp)
  if (err == ERR_OK) {
    d8f0:	e0bffd07 	ldb	r2,-12(fp)
    d8f4:	1000221e 	bne	r2,zero,d980 <tcp_process_refused_data+0x118>
    /* did refused_data include a FIN? */
    if (refused_flags & PBUF_FLAG_TCP_FIN) {
    d8f8:	e0bffd43 	ldbu	r2,-11(fp)
    d8fc:	1080080c 	andi	r2,r2,32
    d900:	10002726 	beq	r2,zero,d9a0 <tcp_process_refused_data+0x138>
      /* correct rcv_wnd as the application won't call tcp_recved()
         for the FIN's seqno */
      if (pcb->rcv_wnd != TCP_WND) {
    d904:	e0bfff17 	ldw	r2,-4(fp)
    d908:	10800c0b 	ldhu	r2,48(r2)
    d90c:	10bfffcc 	andi	r2,r2,65535
    d910:	10820020 	cmpeqi	r2,r2,2048
    d914:	1000061e 	bne	r2,zero,d930 <tcp_process_refused_data+0xc8>
        pcb->rcv_wnd++;
    d918:	e0bfff17 	ldw	r2,-4(fp)
    d91c:	10800c0b 	ldhu	r2,48(r2)
    d920:	10800044 	addi	r2,r2,1
    d924:	1007883a 	mov	r3,r2
    d928:	e0bfff17 	ldw	r2,-4(fp)
    d92c:	10c00c0d 	sth	r3,48(r2)
      }
      TCP_EVENT_CLOSED(pcb, err);
    d930:	e0bfff17 	ldw	r2,-4(fp)
    d934:	10802117 	ldw	r2,132(r2)
    d938:	10000b26 	beq	r2,zero,d968 <tcp_process_refused_data+0x100>
    d93c:	e0bfff17 	ldw	r2,-4(fp)
    d940:	10c02117 	ldw	r3,132(r2)
    d944:	e0bfff17 	ldw	r2,-4(fp)
    d948:	10800417 	ldw	r2,16(r2)
    d94c:	1009883a 	mov	r4,r2
    d950:	e17fff17 	ldw	r5,-4(fp)
    d954:	000d883a 	mov	r6,zero
    d958:	000f883a 	mov	r7,zero
    d95c:	183ee83a 	callr	r3
    d960:	e0bffd05 	stb	r2,-12(fp)
    d964:	00000106 	br	d96c <tcp_process_refused_data+0x104>
    d968:	e03ffd05 	stb	zero,-12(fp)
      if (err == ERR_ABRT) {
    d96c:	e0bffd07 	ldb	r2,-12(fp)
    d970:	10bffd98 	cmpnei	r2,r2,-10
    d974:	10000a1e 	bne	r2,zero,d9a0 <tcp_process_refused_data+0x138>
        return ERR_ABRT;
    d978:	00bffd84 	movi	r2,-10
    d97c:	00000906 	br	d9a4 <tcp_process_refused_data+0x13c>
      }
    }
  } else if (err == ERR_ABRT) {
    d980:	e0bffd07 	ldb	r2,-12(fp)
    d984:	10bffd98 	cmpnei	r2,r2,-10
    d988:	1000021e 	bne	r2,zero,d994 <tcp_process_refused_data+0x12c>
    /* if err == ERR_ABRT, 'pcb' is already deallocated */
    /* Drop incoming packets because pcb is "full" (only if the incoming
       segment contains data). */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
    return ERR_ABRT;
    d98c:	00bffd84 	movi	r2,-10
    d990:	00000406 	br	d9a4 <tcp_process_refused_data+0x13c>
  } else {
    /* data is still refused, pbuf is still valid (go on for ACK-only packets) */
    pcb->refused_data = refused_data;
    d994:	e0bfff17 	ldw	r2,-4(fp)
    d998:	e0fffe17 	ldw	r3,-8(fp)
    d99c:	10c01f15 	stw	r3,124(r2)
  }
  return ERR_OK;
    d9a0:	0005883a 	mov	r2,zero
}
    d9a4:	e037883a 	mov	sp,fp
    d9a8:	dfc00117 	ldw	ra,4(sp)
    d9ac:	df000017 	ldw	fp,0(sp)
    d9b0:	dec00204 	addi	sp,sp,8
    d9b4:	f800283a 	ret

0000d9b8 <tcp_segs_free>:
 *
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
    d9b8:	defffc04 	addi	sp,sp,-16
    d9bc:	dfc00315 	stw	ra,12(sp)
    d9c0:	df000215 	stw	fp,8(sp)
    d9c4:	df000204 	addi	fp,sp,8
    d9c8:	e13fff15 	stw	r4,-4(fp)
  while (seg != NULL) {
    d9cc:	00000706 	br	d9ec <tcp_segs_free+0x34>
    struct tcp_seg *next = seg->next;
    d9d0:	e0bfff17 	ldw	r2,-4(fp)
    d9d4:	10800017 	ldw	r2,0(r2)
    d9d8:	e0bffe15 	stw	r2,-8(fp)
    tcp_seg_free(seg);
    d9dc:	e13fff17 	ldw	r4,-4(fp)
    d9e0:	000da080 	call	da08 <tcp_seg_free>
    seg = next;
    d9e4:	e0bffe17 	ldw	r2,-8(fp)
    d9e8:	e0bfff15 	stw	r2,-4(fp)
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
    d9ec:	e0bfff17 	ldw	r2,-4(fp)
    d9f0:	103ff71e 	bne	r2,zero,d9d0 <tcp_segs_free+0x18>
    struct tcp_seg *next = seg->next;
    tcp_seg_free(seg);
    seg = next;
  }
}
    d9f4:	e037883a 	mov	sp,fp
    d9f8:	dfc00117 	ldw	ra,4(sp)
    d9fc:	df000017 	ldw	fp,0(sp)
    da00:	dec00204 	addi	sp,sp,8
    da04:	f800283a 	ret

0000da08 <tcp_seg_free>:
 *
 * @param seg single tcp_seg to free
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
    da08:	defffd04 	addi	sp,sp,-12
    da0c:	dfc00215 	stw	ra,8(sp)
    da10:	df000115 	stw	fp,4(sp)
    da14:	df000104 	addi	fp,sp,4
    da18:	e13fff15 	stw	r4,-4(fp)
  if (seg != NULL) {
    da1c:	e0bfff17 	ldw	r2,-4(fp)
    da20:	10000a26 	beq	r2,zero,da4c <tcp_seg_free+0x44>
    if (seg->p != NULL) {
    da24:	e0bfff17 	ldw	r2,-4(fp)
    da28:	10800117 	ldw	r2,4(r2)
    da2c:	10000426 	beq	r2,zero,da40 <tcp_seg_free+0x38>
      pbuf_free(seg->p);
    da30:	e0bfff17 	ldw	r2,-4(fp)
    da34:	10800117 	ldw	r2,4(r2)
    da38:	1009883a 	mov	r4,r2
    da3c:	000aa340 	call	aa34 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
    da40:	01000104 	movi	r4,4
    da44:	e17fff17 	ldw	r5,-4(fp)
    da48:	00097d40 	call	97d4 <memp_free>
  }
}
    da4c:	e037883a 	mov	sp,fp
    da50:	dfc00117 	ldw	ra,4(sp)
    da54:	df000017 	ldw	fp,0(sp)
    da58:	dec00204 	addi	sp,sp,8
    da5c:	f800283a 	ret

0000da60 <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
    da60:	defffd04 	addi	sp,sp,-12
    da64:	df000215 	stw	fp,8(sp)
    da68:	df000204 	addi	fp,sp,8
    da6c:	e13ffe15 	stw	r4,-8(fp)
    da70:	2805883a 	mov	r2,r5
    da74:	e0bfff05 	stb	r2,-4(fp)
  pcb->prio = prio;
    da78:	e0bffe17 	ldw	r2,-8(fp)
    da7c:	e0ffff03 	ldbu	r3,-4(fp)
    da80:	10c00705 	stb	r3,28(r2)
}
    da84:	e037883a 	mov	sp,fp
    da88:	df000017 	ldw	fp,0(sp)
    da8c:	dec00104 	addi	sp,sp,4
    da90:	f800283a 	ret

0000da94 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
    da94:	defffc04 	addi	sp,sp,-16
    da98:	dfc00315 	stw	ra,12(sp)
    da9c:	df000215 	stw	fp,8(sp)
    daa0:	df000204 	addi	fp,sp,8
    daa4:	e13fff15 	stw	r4,-4(fp)
  struct tcp_seg *cseg;

  cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
    daa8:	01000104 	movi	r4,4
    daac:	00095f80 	call	95f8 <memp_malloc>
    dab0:	e0bffe15 	stw	r2,-8(fp)
  if (cseg == NULL) {
    dab4:	e0bffe17 	ldw	r2,-8(fp)
    dab8:	1000021e 	bne	r2,zero,dac4 <tcp_seg_copy+0x30>
    return NULL;
    dabc:	0005883a 	mov	r2,zero
    dac0:	00000906 	br	dae8 <tcp_seg_copy+0x54>
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
    dac4:	e13ffe17 	ldw	r4,-8(fp)
    dac8:	e17fff17 	ldw	r5,-4(fp)
    dacc:	01800404 	movi	r6,16
    dad0:	00191f00 	call	191f0 <memcpy>
  pbuf_ref(cseg->p);
    dad4:	e0bffe17 	ldw	r2,-8(fp)
    dad8:	10800117 	ldw	r2,4(r2)
    dadc:	1009883a 	mov	r4,r2
    dae0:	000ac4c0 	call	ac4c <pbuf_ref>
  return cseg;
    dae4:	e0bffe17 	ldw	r2,-8(fp)
}
    dae8:	e037883a 	mov	sp,fp
    daec:	dfc00117 	ldw	ra,4(sp)
    daf0:	df000017 	ldw	fp,0(sp)
    daf4:	dec00204 	addi	sp,sp,8
    daf8:	f800283a 	ret

0000dafc <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
    dafc:	defffa04 	addi	sp,sp,-24
    db00:	dfc00515 	stw	ra,20(sp)
    db04:	df000415 	stw	fp,16(sp)
    db08:	df000404 	addi	fp,sp,16
    db0c:	e13ffc15 	stw	r4,-16(fp)
    db10:	e17ffd15 	stw	r5,-12(fp)
    db14:	e1bffe15 	stw	r6,-8(fp)
    db18:	3805883a 	mov	r2,r7
    db1c:	e0bfff05 	stb	r2,-4(fp)
  LWIP_UNUSED_ARG(arg);
  if (p != NULL) {
    db20:	e0bffe17 	ldw	r2,-8(fp)
    db24:	10000926 	beq	r2,zero,db4c <tcp_recv_null+0x50>
    tcp_recved(pcb, p->tot_len);
    db28:	e0bffe17 	ldw	r2,-8(fp)
    db2c:	1080020b 	ldhu	r2,8(r2)
    db30:	10bfffcc 	andi	r2,r2,65535
    db34:	e13ffd17 	ldw	r4,-12(fp)
    db38:	100b883a 	mov	r5,r2
    db3c:	000ca180 	call	ca18 <tcp_recved>
    pbuf_free(p);
    db40:	e13ffe17 	ldw	r4,-8(fp)
    db44:	000aa340 	call	aa34 <pbuf_free>
    db48:	00000506 	br	db60 <tcp_recv_null+0x64>
  } else if (err == ERR_OK) {
    db4c:	e0bfff07 	ldb	r2,-4(fp)
    db50:	1000031e 	bne	r2,zero,db60 <tcp_recv_null+0x64>
    return tcp_close(pcb);
    db54:	e13ffd17 	ldw	r4,-12(fp)
    db58:	000c24c0 	call	c24c <tcp_close>
    db5c:	00000106 	br	db64 <tcp_recv_null+0x68>
  }
  return ERR_OK;
    db60:	0005883a 	mov	r2,zero
}
    db64:	e037883a 	mov	sp,fp
    db68:	dfc00117 	ldw	ra,4(sp)
    db6c:	df000017 	ldw	fp,0(sp)
    db70:	dec00204 	addi	sp,sp,8
    db74:	f800283a 	ret

0000db78 <tcp_kill_prio>:
 *
 * @param prio minimum priority
 */
static void
tcp_kill_prio(u8_t prio)
{
    db78:	defff904 	addi	sp,sp,-28
    db7c:	dfc00615 	stw	ra,24(sp)
    db80:	df000515 	stw	fp,20(sp)
    db84:	df000504 	addi	fp,sp,20
    db88:	2005883a 	mov	r2,r4
    db8c:	e0bfff05 	stb	r2,-4(fp)
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
    db90:	00801fc4 	movi	r2,127
    db94:	e0bffe05 	stb	r2,-8(fp)
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
    db98:	e03ffd15 	stw	zero,-12(fp)
  inactive = NULL;
    db9c:	e03ffc15 	stw	zero,-16(fp)
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    dba0:	d0a8bc17 	ldw	r2,-23824(gp)
    dba4:	e0bffb15 	stw	r2,-20(fp)
    dba8:	00001d06 	br	dc20 <tcp_kill_prio+0xa8>
    if (pcb->prio <= prio &&
    dbac:	e0bffb17 	ldw	r2,-20(fp)
    dbb0:	10800703 	ldbu	r2,28(r2)
    dbb4:	10803fcc 	andi	r2,r2,255
    dbb8:	e0ffff03 	ldbu	r3,-4(fp)
    dbbc:	18801536 	bltu	r3,r2,dc14 <tcp_kill_prio+0x9c>
       pcb->prio <= mprio &&
    dbc0:	e0bffb17 	ldw	r2,-20(fp)
    dbc4:	10800703 	ldbu	r2,28(r2)
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
    dbc8:	10803fcc 	andi	r2,r2,255
    dbcc:	e0fffe03 	ldbu	r3,-8(fp)
    dbd0:	18801036 	bltu	r3,r2,dc14 <tcp_kill_prio+0x9c>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    dbd4:	d0e8bd17 	ldw	r3,-23820(gp)
    dbd8:	e0bffb17 	ldw	r2,-20(fp)
    dbdc:	10800a17 	ldw	r2,40(r2)
    dbe0:	1887c83a 	sub	r3,r3,r2
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
    dbe4:	e0bffd17 	ldw	r2,-12(fp)
    dbe8:	18800a36 	bltu	r3,r2,dc14 <tcp_kill_prio+0x9c>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
    dbec:	d0e8bd17 	ldw	r3,-23820(gp)
    dbf0:	e0bffb17 	ldw	r2,-20(fp)
    dbf4:	10800a17 	ldw	r2,40(r2)
    dbf8:	1885c83a 	sub	r2,r3,r2
    dbfc:	e0bffd15 	stw	r2,-12(fp)
      inactive = pcb;
    dc00:	e0bffb17 	ldw	r2,-20(fp)
    dc04:	e0bffc15 	stw	r2,-16(fp)
      mprio = pcb->prio;
    dc08:	e0bffb17 	ldw	r2,-20(fp)
    dc0c:	10800703 	ldbu	r2,28(r2)
    dc10:	e0bffe05 	stb	r2,-8(fp)
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    dc14:	e0bffb17 	ldw	r2,-20(fp)
    dc18:	10800317 	ldw	r2,12(r2)
    dc1c:	e0bffb15 	stw	r2,-20(fp)
    dc20:	e0bffb17 	ldw	r2,-20(fp)
    dc24:	103fe11e 	bne	r2,zero,dbac <tcp_kill_prio+0x34>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
    dc28:	e0bffc17 	ldw	r2,-16(fp)
    dc2c:	10000226 	beq	r2,zero,dc38 <tcp_kill_prio+0xc0>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
    dc30:	e13ffc17 	ldw	r4,-16(fp)
    dc34:	000c5280 	call	c528 <tcp_abort>
  }
}
    dc38:	e037883a 	mov	sp,fp
    dc3c:	dfc00117 	ldw	ra,4(sp)
    dc40:	df000017 	ldw	fp,0(sp)
    dc44:	dec00204 	addi	sp,sp,8
    dc48:	f800283a 	ret

0000dc4c <tcp_kill_timewait>:
 * Kills the oldest connection that is in TIME_WAIT state.
 * Called from tcp_alloc() if no more connections are available.
 */
static void
tcp_kill_timewait(void)
{
    dc4c:	defffb04 	addi	sp,sp,-20
    dc50:	dfc00415 	stw	ra,16(sp)
    dc54:	df000315 	stw	fp,12(sp)
    dc58:	df000304 	addi	fp,sp,12
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
    dc5c:	e03fff15 	stw	zero,-4(fp)
  inactive = NULL;
    dc60:	e03ffe15 	stw	zero,-8(fp)
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    dc64:	d0a8c117 	ldw	r2,-23804(gp)
    dc68:	e0bffd15 	stw	r2,-12(fp)
    dc6c:	00001006 	br	dcb0 <tcp_kill_timewait+0x64>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    dc70:	d0e8bd17 	ldw	r3,-23820(gp)
    dc74:	e0bffd17 	ldw	r2,-12(fp)
    dc78:	10800a17 	ldw	r2,40(r2)
    dc7c:	1887c83a 	sub	r3,r3,r2
    dc80:	e0bfff17 	ldw	r2,-4(fp)
    dc84:	18800736 	bltu	r3,r2,dca4 <tcp_kill_timewait+0x58>
      inactivity = tcp_ticks - pcb->tmr;
    dc88:	d0e8bd17 	ldw	r3,-23820(gp)
    dc8c:	e0bffd17 	ldw	r2,-12(fp)
    dc90:	10800a17 	ldw	r2,40(r2)
    dc94:	1885c83a 	sub	r2,r3,r2
    dc98:	e0bfff15 	stw	r2,-4(fp)
      inactive = pcb;
    dc9c:	e0bffd17 	ldw	r2,-12(fp)
    dca0:	e0bffe15 	stw	r2,-8(fp)
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    dca4:	e0bffd17 	ldw	r2,-12(fp)
    dca8:	10800317 	ldw	r2,12(r2)
    dcac:	e0bffd15 	stw	r2,-12(fp)
    dcb0:	e0bffd17 	ldw	r2,-12(fp)
    dcb4:	103fee1e 	bne	r2,zero,dc70 <tcp_kill_timewait+0x24>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
    dcb8:	e0bffe17 	ldw	r2,-8(fp)
    dcbc:	10000226 	beq	r2,zero,dcc8 <tcp_kill_timewait+0x7c>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
    dcc0:	e13ffe17 	ldw	r4,-8(fp)
    dcc4:	000c5280 	call	c528 <tcp_abort>
  }
}
    dcc8:	e037883a 	mov	sp,fp
    dccc:	dfc00117 	ldw	ra,4(sp)
    dcd0:	df000017 	ldw	fp,0(sp)
    dcd4:	dec00204 	addi	sp,sp,8
    dcd8:	f800283a 	ret

0000dcdc <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
    dcdc:	defffb04 	addi	sp,sp,-20
    dce0:	dfc00415 	stw	ra,16(sp)
    dce4:	df000315 	stw	fp,12(sp)
    dce8:	df000304 	addi	fp,sp,12
    dcec:	2005883a 	mov	r2,r4
    dcf0:	e0bfff05 	stb	r2,-4(fp)
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    dcf4:	01000084 	movi	r4,2
    dcf8:	00095f80 	call	95f8 <memp_malloc>
    dcfc:	e0bffd15 	stw	r2,-12(fp)
  if (pcb == NULL) {
    dd00:	e0bffd17 	ldw	r2,-12(fp)
    dd04:	1000201e 	bne	r2,zero,dd88 <tcp_alloc+0xac>
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
    dd08:	000dc4c0 	call	dc4c <tcp_kill_timewait>
    /* Try to allocate a tcp_pcb again. */
    pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    dd0c:	01000084 	movi	r4,2
    dd10:	00095f80 	call	95f8 <memp_malloc>
    dd14:	e0bffd15 	stw	r2,-12(fp)
    if (pcb == NULL) {
    dd18:	e0bffd17 	ldw	r2,-12(fp)
    dd1c:	1000101e 	bne	r2,zero,dd60 <tcp_alloc+0x84>
      /* Try killing active connections with lower priority than the new one. */
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing connection with prio lower than %d\n", prio));
      tcp_kill_prio(prio);
    dd20:	e0bfff03 	ldbu	r2,-4(fp)
    dd24:	1009883a 	mov	r4,r2
    dd28:	000db780 	call	db78 <tcp_kill_prio>
      /* Try to allocate a tcp_pcb again. */
      pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    dd2c:	01000084 	movi	r4,2
    dd30:	00095f80 	call	95f8 <memp_malloc>
    dd34:	e0bffd15 	stw	r2,-12(fp)
      if (pcb != NULL) {
    dd38:	e0bffd17 	ldw	r2,-12(fp)
    dd3c:	10000826 	beq	r2,zero,dd60 <tcp_alloc+0x84>
        /* adjust err stats: memp_malloc failed twice before */
        MEMP_STATS_DEC(err, MEMP_TCP_PCB);
    dd40:	00800234 	movhi	r2,8
    dd44:	1083bd04 	addi	r2,r2,3828
    dd48:	1080330b 	ldhu	r2,204(r2)
    dd4c:	10bfffc4 	addi	r2,r2,-1
    dd50:	1007883a 	mov	r3,r2
    dd54:	00800234 	movhi	r2,8
    dd58:	1083bd04 	addi	r2,r2,3828
    dd5c:	10c0330d 	sth	r3,204(r2)
      }
    }
    if (pcb != NULL) {
    dd60:	e0bffd17 	ldw	r2,-12(fp)
    dd64:	10000826 	beq	r2,zero,dd88 <tcp_alloc+0xac>
      /* adjust err stats: timewait PCB was freed above */
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
    dd68:	00800234 	movhi	r2,8
    dd6c:	1083bd04 	addi	r2,r2,3828
    dd70:	1080330b 	ldhu	r2,204(r2)
    dd74:	10bfffc4 	addi	r2,r2,-1
    dd78:	1007883a 	mov	r3,r2
    dd7c:	00800234 	movhi	r2,8
    dd80:	1083bd04 	addi	r2,r2,3828
    dd84:	10c0330d 	sth	r3,204(r2)
    }
  }
  if (pcb != NULL) {
    dd88:	e0bffd17 	ldw	r2,-12(fp)
    dd8c:	10004826 	beq	r2,zero,deb0 <tcp_alloc+0x1d4>
    memset(pcb, 0, sizeof(struct tcp_pcb));
    dd90:	e13ffd17 	ldw	r4,-12(fp)
    dd94:	000b883a 	mov	r5,zero
    dd98:	01802704 	movi	r6,156
    dd9c:	00192e80 	call	192e8 <memset>
    pcb->prio = prio;
    dda0:	e0bffd17 	ldw	r2,-12(fp)
    dda4:	e0ffff03 	ldbu	r3,-4(fp)
    dda8:	10c00705 	stb	r3,28(r2)
    pcb->snd_buf = TCP_SND_BUF;
    ddac:	e0bffd17 	ldw	r2,-12(fp)
    ddb0:	00d00004 	movi	r3,16384
    ddb4:	10c01a8d 	sth	r3,106(r2)
    pcb->snd_queuelen = 0;
    ddb8:	e0bffd17 	ldw	r2,-12(fp)
    ddbc:	10001b0d 	sth	zero,108(r2)
    pcb->rcv_wnd = TCP_WND;
    ddc0:	e0bffd17 	ldw	r2,-12(fp)
    ddc4:	00c20004 	movi	r3,2048
    ddc8:	10c00c0d 	sth	r3,48(r2)
    pcb->rcv_ann_wnd = TCP_WND;
    ddcc:	e0bffd17 	ldw	r2,-12(fp)
    ddd0:	00c20004 	movi	r3,2048
    ddd4:	10c00c8d 	sth	r3,50(r2)
    pcb->tos = 0;
    ddd8:	e0bffd17 	ldw	r2,-12(fp)
    dddc:	10000245 	stb	zero,9(r2)
    pcb->ttl = TCP_TTL;
    dde0:	e0bffd17 	ldw	r2,-12(fp)
    dde4:	00ffffc4 	movi	r3,-1
    dde8:	10c00285 	stb	r3,10(r2)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    ddec:	e0bffd17 	ldw	r2,-12(fp)
    ddf0:	00c08604 	movi	r3,536
    ddf4:	10c00e8d 	sth	r3,58(r2)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
    ddf8:	e0bffd17 	ldw	r2,-12(fp)
    ddfc:	00c00184 	movi	r3,6
    de00:	10c0120d 	sth	r3,72(r2)
    pcb->sa = 0;
    de04:	e0bffd17 	ldw	r2,-12(fp)
    de08:	1000110d 	sth	zero,68(r2)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
    de0c:	e0bffd17 	ldw	r2,-12(fp)
    de10:	00c00184 	movi	r3,6
    de14:	10c0118d 	sth	r3,70(r2)
    pcb->rtime = -1;
    de18:	e0bffd17 	ldw	r2,-12(fp)
    de1c:	00ffffc4 	movi	r3,-1
    de20:	10c00e0d 	sth	r3,56(r2)
    pcb->cwnd = 1;
    de24:	e0bffd17 	ldw	r2,-12(fp)
    de28:	00c00044 	movi	r3,1
    de2c:	10c0140d 	sth	r3,80(r2)
    iss = tcp_next_iss();
    de30:	000e39c0 	call	e39c <tcp_next_iss>
    de34:	e0bffe15 	stw	r2,-8(fp)
    pcb->snd_wl2 = iss;
    de38:	e0bffd17 	ldw	r2,-12(fp)
    de3c:	e0fffe17 	ldw	r3,-8(fp)
    de40:	10c01715 	stw	r3,92(r2)
    pcb->snd_nxt = iss;
    de44:	e0bffd17 	ldw	r2,-12(fp)
    de48:	e0fffe17 	ldw	r3,-8(fp)
    de4c:	10c01515 	stw	r3,84(r2)
    pcb->lastack = iss;
    de50:	e0bffd17 	ldw	r2,-12(fp)
    de54:	e0fffe17 	ldw	r3,-8(fp)
    de58:	10c01315 	stw	r3,76(r2)
    pcb->snd_lbb = iss;   
    de5c:	e0bffd17 	ldw	r2,-12(fp)
    de60:	e0fffe17 	ldw	r3,-8(fp)
    de64:	10c01815 	stw	r3,96(r2)
    pcb->tmr = tcp_ticks;
    de68:	d0e8bd17 	ldw	r3,-23820(gp)
    de6c:	e0bffd17 	ldw	r2,-12(fp)
    de70:	10c00a15 	stw	r3,40(r2)
    pcb->last_timer = tcp_timer_ctr;
    de74:	d0e8bb43 	ldbu	r3,-23827(gp)
    de78:	e0bffd17 	ldw	r2,-12(fp)
    de7c:	10c00945 	stb	r3,37(r2)

    pcb->polltmr = 0;
    de80:	e0bffd17 	ldw	r2,-12(fp)
    de84:	100008c5 	stb	zero,35(r2)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
    de88:	e0bffd17 	ldw	r2,-12(fp)
    de8c:	00c00074 	movhi	r3,1
    de90:	18f6bf04 	addi	r3,r3,-9476
    de94:	10c02115 	stw	r3,132(r2)
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
    de98:	e0bffd17 	ldw	r2,-12(fp)
    de9c:	00c01bb4 	movhi	r3,110
    dea0:	18f74004 	addi	r3,r3,-8960
    dea4:	10c02515 	stw	r3,148(r2)
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
    dea8:	e0bffd17 	ldw	r2,-12(fp)
    deac:	10002685 	stb	zero,154(r2)
  }
  return pcb;
    deb0:	e0bffd17 	ldw	r2,-12(fp)
}
    deb4:	e037883a 	mov	sp,fp
    deb8:	dfc00117 	ldw	ra,4(sp)
    debc:	df000017 	ldw	fp,0(sp)
    dec0:	dec00204 	addi	sp,sp,8
    dec4:	f800283a 	ret

0000dec8 <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
    dec8:	defffe04 	addi	sp,sp,-8
    decc:	dfc00115 	stw	ra,4(sp)
    ded0:	df000015 	stw	fp,0(sp)
    ded4:	d839883a 	mov	fp,sp
  return tcp_alloc(TCP_PRIO_NORMAL);
    ded8:	01001004 	movi	r4,64
    dedc:	000dcdc0 	call	dcdc <tcp_alloc>
}
    dee0:	e037883a 	mov	sp,fp
    dee4:	dfc00117 	ldw	ra,4(sp)
    dee8:	df000017 	ldw	fp,0(sp)
    deec:	dec00204 	addi	sp,sp,8
    def0:	f800283a 	ret

0000def4 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{
    def4:	defffd04 	addi	sp,sp,-12
    def8:	df000215 	stw	fp,8(sp)
    defc:	df000204 	addi	fp,sp,8
    df00:	e13ffe15 	stw	r4,-8(fp)
    df04:	e17fff15 	stw	r5,-4(fp)
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  pcb->callback_arg = arg;
    df08:	e0bffe17 	ldw	r2,-8(fp)
    df0c:	e0ffff17 	ldw	r3,-4(fp)
    df10:	10c00415 	stw	r3,16(r2)
}
    df14:	e037883a 	mov	sp,fp
    df18:	df000017 	ldw	fp,0(sp)
    df1c:	dec00104 	addi	sp,sp,4
    df20:	f800283a 	ret

0000df24 <tcp_recv>:
 * @param pcb tcp_pcb to set the recv callback
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
    df24:	defffc04 	addi	sp,sp,-16
    df28:	dfc00315 	stw	ra,12(sp)
    df2c:	df000215 	stw	fp,8(sp)
    df30:	df000204 	addi	fp,sp,8
    df34:	e13ffe15 	stw	r4,-8(fp)
    df38:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
    df3c:	e0bffe17 	ldw	r2,-8(fp)
    df40:	10800617 	ldw	r2,24(r2)
    df44:	10800058 	cmpnei	r2,r2,1
    df48:	1000091e 	bne	r2,zero,df70 <tcp_recv+0x4c>
    df4c:	010000f4 	movhi	r4,3
    df50:	21011004 	addi	r4,r4,1088
    df54:	014000f4 	movhi	r5,3
    df58:	2941c404 	addi	r5,r5,1808
    df5c:	01815c84 	movi	r6,1394
    df60:	01c000f4 	movhi	r7,3
    df64:	39c12104 	addi	r7,r7,1156
    df68:	00193f00 	call	193f0 <printf>
    df6c:	003fff06 	br	df6c <tcp_recv+0x48>
  pcb->recv = recv;
    df70:	e0bffe17 	ldw	r2,-8(fp)
    df74:	e0ffff17 	ldw	r3,-4(fp)
    df78:	10c02115 	stw	r3,132(r2)
}
    df7c:	e037883a 	mov	sp,fp
    df80:	dfc00117 	ldw	ra,4(sp)
    df84:	df000017 	ldw	fp,0(sp)
    df88:	dec00204 	addi	sp,sp,8
    df8c:	f800283a 	ret

0000df90 <tcp_sent>:
 * @param pcb tcp_pcb to set the sent callback
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
    df90:	defffc04 	addi	sp,sp,-16
    df94:	dfc00315 	stw	ra,12(sp)
    df98:	df000215 	stw	fp,8(sp)
    df9c:	df000204 	addi	fp,sp,8
    dfa0:	e13ffe15 	stw	r4,-8(fp)
    dfa4:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
    dfa8:	e0bffe17 	ldw	r2,-8(fp)
    dfac:	10800617 	ldw	r2,24(r2)
    dfb0:	10800058 	cmpnei	r2,r2,1
    dfb4:	1000091e 	bne	r2,zero,dfdc <tcp_sent+0x4c>
    dfb8:	010000f4 	movhi	r4,3
    dfbc:	21011004 	addi	r4,r4,1088
    dfc0:	014000f4 	movhi	r5,3
    dfc4:	2941ce04 	addi	r5,r5,1848
    dfc8:	01816004 	movi	r6,1408
    dfcc:	01c000f4 	movhi	r7,3
    dfd0:	39c12104 	addi	r7,r7,1156
    dfd4:	00193f00 	call	193f0 <printf>
    dfd8:	003fff06 	br	dfd8 <tcp_sent+0x48>
  pcb->sent = sent;
    dfdc:	e0bffe17 	ldw	r2,-8(fp)
    dfe0:	e0ffff17 	ldw	r3,-4(fp)
    dfe4:	10c02015 	stw	r3,128(r2)
}
    dfe8:	e037883a 	mov	sp,fp
    dfec:	dfc00117 	ldw	ra,4(sp)
    dff0:	df000017 	ldw	fp,0(sp)
    dff4:	dec00204 	addi	sp,sp,8
    dff8:	f800283a 	ret

0000dffc <tcp_err>:
 * @param err callback function to call for this pcb when a fatal error
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
    dffc:	defffc04 	addi	sp,sp,-16
    e000:	dfc00315 	stw	ra,12(sp)
    e004:	df000215 	stw	fp,8(sp)
    e008:	df000204 	addi	fp,sp,8
    e00c:	e13ffe15 	stw	r4,-8(fp)
    e010:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
    e014:	e0bffe17 	ldw	r2,-8(fp)
    e018:	10800617 	ldw	r2,24(r2)
    e01c:	10800058 	cmpnei	r2,r2,1
    e020:	1000091e 	bne	r2,zero,e048 <tcp_err+0x4c>
    e024:	010000f4 	movhi	r4,3
    e028:	21011004 	addi	r4,r4,1088
    e02c:	014000f4 	movhi	r5,3
    e030:	2941d804 	addi	r5,r5,1888
    e034:	018163c4 	movi	r6,1423
    e038:	01c000f4 	movhi	r7,3
    e03c:	39c12104 	addi	r7,r7,1156
    e040:	00193f00 	call	193f0 <printf>
    e044:	003fff06 	br	e044 <tcp_err+0x48>
  pcb->errf = err;
    e048:	e0bffe17 	ldw	r2,-8(fp)
    e04c:	e0ffff17 	ldw	r3,-4(fp)
    e050:	10c02415 	stw	r3,144(r2)
}
    e054:	e037883a 	mov	sp,fp
    e058:	dfc00117 	ldw	ra,4(sp)
    e05c:	df000017 	ldw	fp,0(sp)
    e060:	dec00204 	addi	sp,sp,8
    e064:	f800283a 	ret

0000e068 <tcp_accept>:
 * @param accept callback function to call for this pcb when LISTENing
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
{
    e068:	defffd04 	addi	sp,sp,-12
    e06c:	df000215 	stw	fp,8(sp)
    e070:	df000204 	addi	fp,sp,8
    e074:	e13ffe15 	stw	r4,-8(fp)
    e078:	e17fff15 	stw	r5,-4(fp)
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  pcb->accept = accept;
    e07c:	e0bffe17 	ldw	r2,-8(fp)
    e080:	e0ffff17 	ldw	r3,-4(fp)
    e084:	10c00515 	stw	r3,20(r2)
}
    e088:	e037883a 	mov	sp,fp
    e08c:	df000017 	ldw	fp,0(sp)
    e090:	dec00104 	addi	sp,sp,4
    e094:	f800283a 	ret

0000e098 <tcp_poll>:
 * timer interval, which is called twice a second.
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
    e098:	defffb04 	addi	sp,sp,-20
    e09c:	dfc00415 	stw	ra,16(sp)
    e0a0:	df000315 	stw	fp,12(sp)
    e0a4:	df000304 	addi	fp,sp,12
    e0a8:	e13ffd15 	stw	r4,-12(fp)
    e0ac:	e17ffe15 	stw	r5,-8(fp)
    e0b0:	3005883a 	mov	r2,r6
    e0b4:	e0bfff05 	stb	r2,-4(fp)
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
    e0b8:	e0bffd17 	ldw	r2,-12(fp)
    e0bc:	10800617 	ldw	r2,24(r2)
    e0c0:	10800058 	cmpnei	r2,r2,1
    e0c4:	1000091e 	bne	r2,zero,e0ec <tcp_poll+0x54>
    e0c8:	010000f4 	movhi	r4,3
    e0cc:	21011004 	addi	r4,r4,1088
    e0d0:	014000f4 	movhi	r5,3
    e0d4:	2941e204 	addi	r5,r5,1928
    e0d8:	01816b84 	movi	r6,1454
    e0dc:	01c000f4 	movhi	r7,3
    e0e0:	39c12104 	addi	r7,r7,1156
    e0e4:	00193f00 	call	193f0 <printf>
    e0e8:	003fff06 	br	e0e8 <tcp_poll+0x50>
#if LWIP_CALLBACK_API
  pcb->poll = poll;
    e0ec:	e0bffd17 	ldw	r2,-12(fp)
    e0f0:	e0fffe17 	ldw	r3,-8(fp)
    e0f4:	10c02315 	stw	r3,140(r2)
#else /* LWIP_CALLBACK_API */  
  LWIP_UNUSED_ARG(poll);
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
    e0f8:	e0bffd17 	ldw	r2,-12(fp)
    e0fc:	e0ffff03 	ldbu	r3,-4(fp)
    e100:	10c00905 	stb	r3,36(r2)
}
    e104:	e037883a 	mov	sp,fp
    e108:	dfc00117 	ldw	ra,4(sp)
    e10c:	df000017 	ldw	fp,0(sp)
    e110:	dec00204 	addi	sp,sp,8
    e114:	f800283a 	ret

0000e118 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
    e118:	defffd04 	addi	sp,sp,-12
    e11c:	dfc00215 	stw	ra,8(sp)
    e120:	df000115 	stw	fp,4(sp)
    e124:	df000104 	addi	fp,sp,4
    e128:	e13fff15 	stw	r4,-4(fp)
  if (pcb->state != CLOSED &&
    e12c:	e0bfff17 	ldw	r2,-4(fp)
    e130:	10800617 	ldw	r2,24(r2)
    e134:	10002a26 	beq	r2,zero,e1e0 <tcp_pcb_purge+0xc8>
     pcb->state != TIME_WAIT &&
    e138:	e0bfff17 	ldw	r2,-4(fp)
    e13c:	10800617 	ldw	r2,24(r2)
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
    e140:	108002a0 	cmpeqi	r2,r2,10
    e144:	1000261e 	bne	r2,zero,e1e0 <tcp_pcb_purge+0xc8>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {
    e148:	e0bfff17 	ldw	r2,-4(fp)
    e14c:	10800617 	ldw	r2,24(r2)
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
     pcb->state != TIME_WAIT &&
    e150:	10800060 	cmpeqi	r2,r2,1
    e154:	1000221e 	bne	r2,zero,e1e0 <tcp_pcb_purge+0xc8>
      }
    }
#endif /* TCP_LISTEN_BACKLOG */


    if (pcb->refused_data != NULL) {
    e158:	e0bfff17 	ldw	r2,-4(fp)
    e15c:	10801f17 	ldw	r2,124(r2)
    e160:	10000626 	beq	r2,zero,e17c <tcp_pcb_purge+0x64>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
    e164:	e0bfff17 	ldw	r2,-4(fp)
    e168:	10801f17 	ldw	r2,124(r2)
    e16c:	1009883a 	mov	r4,r2
    e170:	000aa340 	call	aa34 <pbuf_free>
      pcb->refused_data = NULL;
    e174:	e0bfff17 	ldw	r2,-4(fp)
    e178:	10001f15 	stw	zero,124(r2)
    }
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }
    tcp_segs_free(pcb->ooseq);
    e17c:	e0bfff17 	ldw	r2,-4(fp)
    e180:	10801e17 	ldw	r2,120(r2)
    e184:	1009883a 	mov	r4,r2
    e188:	000d9b80 	call	d9b8 <tcp_segs_free>
    pcb->ooseq = NULL;
    e18c:	e0bfff17 	ldw	r2,-4(fp)
    e190:	10001e15 	stw	zero,120(r2)
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
    e194:	e0bfff17 	ldw	r2,-4(fp)
    e198:	00ffffc4 	movi	r3,-1
    e19c:	10c00e0d 	sth	r3,56(r2)

    tcp_segs_free(pcb->unsent);
    e1a0:	e0bfff17 	ldw	r2,-4(fp)
    e1a4:	10801c17 	ldw	r2,112(r2)
    e1a8:	1009883a 	mov	r4,r2
    e1ac:	000d9b80 	call	d9b8 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
    e1b0:	e0bfff17 	ldw	r2,-4(fp)
    e1b4:	10801d17 	ldw	r2,116(r2)
    e1b8:	1009883a 	mov	r4,r2
    e1bc:	000d9b80 	call	d9b8 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
    e1c0:	e0bfff17 	ldw	r2,-4(fp)
    e1c4:	10001c15 	stw	zero,112(r2)
    e1c8:	e0bfff17 	ldw	r2,-4(fp)
    e1cc:	10c01c17 	ldw	r3,112(r2)
    e1d0:	e0bfff17 	ldw	r2,-4(fp)
    e1d4:	10c01d15 	stw	r3,116(r2)
#if TCP_OVERSIZE
    pcb->unsent_oversize = 0;
    e1d8:	e0bfff17 	ldw	r2,-4(fp)
    e1dc:	10001b8d 	sth	zero,110(r2)
#endif /* TCP_OVERSIZE */
  }
}
    e1e0:	e037883a 	mov	sp,fp
    e1e4:	dfc00117 	ldw	ra,4(sp)
    e1e8:	df000017 	ldw	fp,0(sp)
    e1ec:	dec00204 	addi	sp,sp,8
    e1f0:	f800283a 	ret

0000e1f4 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
    e1f4:	defffc04 	addi	sp,sp,-16
    e1f8:	dfc00315 	stw	ra,12(sp)
    e1fc:	df000215 	stw	fp,8(sp)
    e200:	df000204 	addi	fp,sp,8
    e204:	e13ffe15 	stw	r4,-8(fp)
    e208:	e17fff15 	stw	r5,-4(fp)
  TCP_RMV(pcblist, pcb);
    e20c:	e0bffe17 	ldw	r2,-8(fp)
    e210:	10c00017 	ldw	r3,0(r2)
    e214:	e0bfff17 	ldw	r2,-4(fp)
    e218:	1880061e 	bne	r3,r2,e234 <tcp_pcb_remove+0x40>
    e21c:	e0bffe17 	ldw	r2,-8(fp)
    e220:	10800017 	ldw	r2,0(r2)
    e224:	10c00317 	ldw	r3,12(r2)
    e228:	e0bffe17 	ldw	r2,-8(fp)
    e22c:	10c00015 	stw	r3,0(r2)
    e230:	00001206 	br	e27c <tcp_pcb_remove+0x88>
    e234:	e0bffe17 	ldw	r2,-8(fp)
    e238:	10800017 	ldw	r2,0(r2)
    e23c:	d0a8bf15 	stw	r2,-23812(gp)
    e240:	00000c06 	br	e274 <tcp_pcb_remove+0x80>
    e244:	d0a8bf17 	ldw	r2,-23812(gp)
    e248:	10c00317 	ldw	r3,12(r2)
    e24c:	e0bfff17 	ldw	r2,-4(fp)
    e250:	1880051e 	bne	r3,r2,e268 <tcp_pcb_remove+0x74>
    e254:	d0a8bf17 	ldw	r2,-23812(gp)
    e258:	e0ffff17 	ldw	r3,-4(fp)
    e25c:	18c00317 	ldw	r3,12(r3)
    e260:	10c00315 	stw	r3,12(r2)
    e264:	00000506 	br	e27c <tcp_pcb_remove+0x88>
    e268:	d0a8bf17 	ldw	r2,-23812(gp)
    e26c:	10800317 	ldw	r2,12(r2)
    e270:	d0a8bf15 	stw	r2,-23812(gp)
    e274:	d0a8bf17 	ldw	r2,-23812(gp)
    e278:	103ff21e 	bne	r2,zero,e244 <tcp_pcb_remove+0x50>
    e27c:	e0bfff17 	ldw	r2,-4(fp)
    e280:	10000315 	stw	zero,12(r2)

  tcp_pcb_purge(pcb);
    e284:	e13fff17 	ldw	r4,-4(fp)
    e288:	000e1180 	call	e118 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
    e28c:	e0bfff17 	ldw	r2,-4(fp)
    e290:	10800617 	ldw	r2,24(r2)
    e294:	108002a0 	cmpeqi	r2,r2,10
    e298:	1000111e 	bne	r2,zero,e2e0 <tcp_pcb_remove+0xec>
     pcb->state != LISTEN &&
    e29c:	e0bfff17 	ldw	r2,-4(fp)
    e2a0:	10800617 	ldw	r2,24(r2)
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
    e2a4:	10800060 	cmpeqi	r2,r2,1
    e2a8:	10000d1e 	bne	r2,zero,e2e0 <tcp_pcb_remove+0xec>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
    e2ac:	e0bfff17 	ldw	r2,-4(fp)
    e2b0:	10800883 	ldbu	r2,34(r2)
    e2b4:	10803fcc 	andi	r2,r2,255
    e2b8:	1080004c 	andi	r2,r2,1

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
    e2bc:	10000826 	beq	r2,zero,e2e0 <tcp_pcb_remove+0xec>
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
    e2c0:	e0bfff17 	ldw	r2,-4(fp)
    e2c4:	10800883 	ldbu	r2,34(r2)
    e2c8:	10800094 	ori	r2,r2,2
    e2cc:	1007883a 	mov	r3,r2
    e2d0:	e0bfff17 	ldw	r2,-4(fp)
    e2d4:	10c00885 	stb	r3,34(r2)
    tcp_output(pcb);
    e2d8:	e13fff17 	ldw	r4,-4(fp)
    e2dc:	0013a740 	call	13a74 <tcp_output>
  }

  if (pcb->state != LISTEN) {
    e2e0:	e0bfff17 	ldw	r2,-4(fp)
    e2e4:	10800617 	ldw	r2,24(r2)
    e2e8:	10800060 	cmpeqi	r2,r2,1
    e2ec:	1000241e 	bne	r2,zero,e380 <tcp_pcb_remove+0x18c>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
    e2f0:	e0bfff17 	ldw	r2,-4(fp)
    e2f4:	10801c17 	ldw	r2,112(r2)
    e2f8:	10000926 	beq	r2,zero,e320 <tcp_pcb_remove+0x12c>
    e2fc:	010000f4 	movhi	r4,3
    e300:	21011004 	addi	r4,r4,1088
    e304:	014000f4 	movhi	r5,3
    e308:	2941ea04 	addi	r5,r5,1960
    e30c:	01818444 	movi	r6,1553
    e310:	01c000f4 	movhi	r7,3
    e314:	39c12104 	addi	r7,r7,1156
    e318:	00193f00 	call	193f0 <printf>
    e31c:	003fff06 	br	e31c <tcp_pcb_remove+0x128>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
    e320:	e0bfff17 	ldw	r2,-4(fp)
    e324:	10801d17 	ldw	r2,116(r2)
    e328:	10000926 	beq	r2,zero,e350 <tcp_pcb_remove+0x15c>
    e32c:	010000f4 	movhi	r4,3
    e330:	21011004 	addi	r4,r4,1088
    e334:	014000f4 	movhi	r5,3
    e338:	2941f004 	addi	r5,r5,1984
    e33c:	01818484 	movi	r6,1554
    e340:	01c000f4 	movhi	r7,3
    e344:	39c12104 	addi	r7,r7,1156
    e348:	00193f00 	call	193f0 <printf>
    e34c:	003fff06 	br	e34c <tcp_pcb_remove+0x158>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
    e350:	e0bfff17 	ldw	r2,-4(fp)
    e354:	10801e17 	ldw	r2,120(r2)
    e358:	10000926 	beq	r2,zero,e380 <tcp_pcb_remove+0x18c>
    e35c:	010000f4 	movhi	r4,3
    e360:	21011004 	addi	r4,r4,1088
    e364:	014000f4 	movhi	r5,3
    e368:	2941f704 	addi	r5,r5,2012
    e36c:	01818504 	movi	r6,1556
    e370:	01c000f4 	movhi	r7,3
    e374:	39c12104 	addi	r7,r7,1156
    e378:	00193f00 	call	193f0 <printf>
    e37c:	003fff06 	br	e37c <tcp_pcb_remove+0x188>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
    e380:	e0bfff17 	ldw	r2,-4(fp)
    e384:	10000615 	stw	zero,24(r2)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
    e388:	e037883a 	mov	sp,fp
    e38c:	dfc00117 	ldw	ra,4(sp)
    e390:	df000017 	ldw	fp,0(sp)
    e394:	dec00204 	addi	sp,sp,8
    e398:	f800283a 	ret

0000e39c <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
    e39c:	deffff04 	addi	sp,sp,-4
    e3a0:	df000015 	stw	fp,0(sp)
    e3a4:	d839883a 	mov	fp,sp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
    e3a8:	d0e00717 	ldw	r3,-32740(gp)
    e3ac:	d0a8bd17 	ldw	r2,-23820(gp)
    e3b0:	1885883a 	add	r2,r3,r2
    e3b4:	d0a00715 	stw	r2,-32740(gp)
  return iss;
    e3b8:	d0a00717 	ldw	r2,-32740(gp)
}
    e3bc:	e037883a 	mov	sp,fp
    e3c0:	df000017 	ldw	fp,0(sp)
    e3c4:	dec00104 	addi	sp,sp,4
    e3c8:	f800283a 	ret

0000e3cc <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, ip_addr_t *addr)
{
    e3cc:	defffa04 	addi	sp,sp,-24
    e3d0:	dfc00515 	stw	ra,20(sp)
    e3d4:	df000415 	stw	fp,16(sp)
    e3d8:	df000404 	addi	fp,sp,16
    e3dc:	2005883a 	mov	r2,r4
    e3e0:	e17fff15 	stw	r5,-4(fp)
    e3e4:	e0bffe0d 	sth	r2,-8(fp)
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
    e3e8:	e13fff17 	ldw	r4,-4(fp)
    e3ec:	00062600 	call	6260 <ip_route>
    e3f0:	e0bffc15 	stw	r2,-16(fp)
  if ((outif != NULL) && (outif->mtu != 0)) {
    e3f4:	e0bffc17 	ldw	r2,-16(fp)
    e3f8:	10000f26 	beq	r2,zero,e438 <tcp_eff_send_mss+0x6c>
    e3fc:	e0bffc17 	ldw	r2,-16(fp)
    e400:	1080090b 	ldhu	r2,36(r2)
    e404:	10bfffcc 	andi	r2,r2,65535
    e408:	10000b26 	beq	r2,zero,e438 <tcp_eff_send_mss+0x6c>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
    e40c:	e0bffc17 	ldw	r2,-16(fp)
    e410:	1080090b 	ldhu	r2,36(r2)
    e414:	10bff604 	addi	r2,r2,-40
    e418:	e0bffd0d 	sth	r2,-12(fp)
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * We correct for TCP options in tcp_write(), and don't support IP options.
     */
    sendmss = LWIP_MIN(sendmss, mss_s);
    e41c:	e0fffe0b 	ldhu	r3,-8(fp)
    e420:	e0bffd0b 	ldhu	r2,-12(fp)
    e424:	113fffcc 	andi	r4,r2,65535
    e428:	197fffcc 	andi	r5,r3,65535
    e42c:	2900012e 	bgeu	r5,r4,e434 <tcp_eff_send_mss+0x68>
    e430:	1805883a 	mov	r2,r3
    e434:	e0bffe0d 	sth	r2,-8(fp)
  }
  return sendmss;
    e438:	e0bffe0b 	ldhu	r2,-8(fp)
}
    e43c:	e037883a 	mov	sp,fp
    e440:	dfc00117 	ldw	ra,4(sp)
    e444:	df000017 	ldw	fp,0(sp)
    e448:	dec00204 	addi	sp,sp,8
    e44c:	f800283a 	ret

0000e450 <tcp_debug_state_str>:
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

const char*
tcp_debug_state_str(enum tcp_state s)
{
    e450:	defffe04 	addi	sp,sp,-8
    e454:	df000115 	stw	fp,4(sp)
    e458:	df000104 	addi	fp,sp,4
    e45c:	e13fff15 	stw	r4,-4(fp)
  return tcp_state_str[s];
    e460:	00c000f4 	movhi	r3,3
    e464:	18c0fd04 	addi	r3,r3,1012
    e468:	e0bfff17 	ldw	r2,-4(fp)
    e46c:	1085883a 	add	r2,r2,r2
    e470:	1085883a 	add	r2,r2,r2
    e474:	1885883a 	add	r2,r3,r2
    e478:	10800017 	ldw	r2,0(r2)
}
    e47c:	e037883a 	mov	sp,fp
    e480:	df000017 	ldw	fp,0(sp)
    e484:	dec00104 	addi	sp,sp,4
    e488:	f800283a 	ret

0000e48c <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
    e48c:	defff604 	addi	sp,sp,-40
    e490:	dfc00915 	stw	ra,36(sp)
    e494:	df000815 	stw	fp,32(sp)
    e498:	df000804 	addi	fp,sp,32
    e49c:	e13ffe15 	stw	r4,-8(fp)
    e4a0:	e17fff15 	stw	r5,-4(fp)
  u8_t hdrlen;
  err_t err;

  PERF_START;

  TCP_STATS_INC(tcp.recv);
    e4a4:	00800234 	movhi	r2,8
    e4a8:	1083bd04 	addi	r2,r2,3828
    e4ac:	1080248b 	ldhu	r2,146(r2)
    e4b0:	10800044 	addi	r2,r2,1
    e4b4:	1007883a 	mov	r3,r2
    e4b8:	00800234 	movhi	r2,8
    e4bc:	1083bd04 	addi	r2,r2,3828
    e4c0:	10c0248d 	sth	r3,146(r2)
  snmp_inc_tcpinsegs();

  iphdr = (struct ip_hdr *)p->payload;
    e4c4:	e0bffe17 	ldw	r2,-8(fp)
    e4c8:	10800117 	ldw	r2,4(r2)
    e4cc:	d0a8c315 	stw	r2,-23796(gp)
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
    e4d0:	e0bffe17 	ldw	r2,-8(fp)
    e4d4:	10c00117 	ldw	r3,4(r2)
    e4d8:	d0a8c317 	ldw	r2,-23796(gp)
    e4dc:	10800003 	ldbu	r2,0(r2)
    e4e0:	10803fcc 	andi	r2,r2,255
    e4e4:	108003cc 	andi	r2,r2,15
    e4e8:	1085883a 	add	r2,r2,r2
    e4ec:	1085883a 	add	r2,r2,r2
    e4f0:	1885883a 	add	r2,r3,r2
    e4f4:	d0a8c215 	stw	r2,-23800(gp)
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
    e4f8:	d0a8c317 	ldw	r2,-23796(gp)
    e4fc:	10800003 	ldbu	r2,0(r2)
    e500:	10803fcc 	andi	r2,r2,255
    e504:	108003cc 	andi	r2,r2,15
    e508:	1085883a 	add	r2,r2,r2
    e50c:	1085883a 	add	r2,r2,r2
    e510:	0085c83a 	sub	r2,zero,r2
    e514:	10bfffcc 	andi	r2,r2,65535
    e518:	10a0001c 	xori	r2,r2,32768
    e51c:	10a00004 	addi	r2,r2,-32768
    e520:	e13ffe17 	ldw	r4,-8(fp)
    e524:	100b883a 	mov	r5,r2
    e528:	000a83c0 	call	a83c <pbuf_header>
    e52c:	10803fcc 	andi	r2,r2,255
    e530:	1000051e 	bne	r2,zero,e548 <tcp_input+0xbc>
    e534:	e0bffe17 	ldw	r2,-8(fp)
    e538:	1080020b 	ldhu	r2,8(r2)
    e53c:	10bfffcc 	andi	r2,r2,65535
    e540:	10800528 	cmpgeui	r2,r2,20
    e544:	1000091e 	bne	r2,zero,e56c <tcp_input+0xe0>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    e548:	00800234 	movhi	r2,8
    e54c:	1083bd04 	addi	r2,r2,3828
    e550:	1080268b 	ldhu	r2,154(r2)
    e554:	10800044 	addi	r2,r2,1
    e558:	1007883a 	mov	r3,r2
    e55c:	00800234 	movhi	r2,8
    e560:	1083bd04 	addi	r2,r2,3828
    e564:	10c0268d 	sth	r3,154(r2)
    goto dropped;
    e568:	0002fd06 	br	f160 <tcp_input+0xcd4>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
    e56c:	008000f4 	movhi	r2,3
    e570:	109e2104 	addi	r2,r2,30852
    e574:	10800017 	ldw	r2,0(r2)
    e578:	1009883a 	mov	r4,r2
    e57c:	e17fff17 	ldw	r5,-4(fp)
    e580:	0006da80 	call	6da8 <ip4_addr_isbroadcast>
    e584:	10803fcc 	andi	r2,r2,255
    e588:	1000061e 	bne	r2,zero,e5a4 <tcp_input+0x118>
      ip_addr_ismulticast(&current_iphdr_dest)) {
    e58c:	008000f4 	movhi	r2,3
    e590:	109e2104 	addi	r2,r2,30852
    e594:	10800017 	ldw	r2,0(r2)
    e598:	10803c0c 	andi	r2,r2,240
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
    e59c:	10803818 	cmpnei	r2,r2,224
    e5a0:	1000091e 	bne	r2,zero,e5c8 <tcp_input+0x13c>
      ip_addr_ismulticast(&current_iphdr_dest)) {
    TCP_STATS_INC(tcp.proterr);
    e5a4:	00800234 	movhi	r2,8
    e5a8:	1083bd04 	addi	r2,r2,3828
    e5ac:	1080280b 	ldhu	r2,160(r2)
    e5b0:	10800044 	addi	r2,r2,1
    e5b4:	1007883a 	mov	r3,r2
    e5b8:	00800234 	movhi	r2,8
    e5bc:	1083bd04 	addi	r2,r2,3828
    e5c0:	10c0280d 	sth	r3,160(r2)
    goto dropped;
    e5c4:	0002e606 	br	f160 <tcp_input+0xcd4>
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
      IP_PROTO_TCP, p->tot_len) != 0) {
    e5c8:	e0bffe17 	ldw	r2,-8(fp)
    e5cc:	1080020b 	ldhu	r2,8(r2)
    goto dropped;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
    e5d0:	10bfffcc 	andi	r2,r2,65535
    e5d4:	d8800015 	stw	r2,0(sp)
    e5d8:	e13ffe17 	ldw	r4,-8(fp)
    e5dc:	014000f4 	movhi	r5,3
    e5e0:	295e1f04 	addi	r5,r5,30844
    e5e4:	018000f4 	movhi	r6,3
    e5e8:	319e2104 	addi	r6,r6,30852
    e5ec:	01c00184 	movi	r7,6
    e5f0:	0005cb80 	call	5cb8 <inet_chksum_pseudo>
    e5f4:	10bfffcc 	andi	r2,r2,65535
    e5f8:	10000926 	beq	r2,zero,e620 <tcp_input+0x194>
        inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
      IP_PROTO_TCP, p->tot_len)));
#if TCP_DEBUG
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
    e5fc:	00800234 	movhi	r2,8
    e600:	1083bd04 	addi	r2,r2,3828
    e604:	1080260b 	ldhu	r2,152(r2)
    e608:	10800044 	addi	r2,r2,1
    e60c:	1007883a 	mov	r3,r2
    e610:	00800234 	movhi	r2,8
    e614:	1083bd04 	addi	r2,r2,3828
    e618:	10c0260d 	sth	r3,152(r2)
    goto dropped;
    e61c:	0002d006 	br	f160 <tcp_input+0xcd4>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
    e620:	d0a8c217 	ldw	r2,-23800(gp)
    e624:	1080030b 	ldhu	r2,12(r2)
    e628:	10bfffcc 	andi	r2,r2,65535
    e62c:	1004d23a 	srli	r2,r2,8
    e630:	10ffffcc 	andi	r3,r2,65535
    e634:	d0a8c217 	ldw	r2,-23800(gp)
    e638:	1080030b 	ldhu	r2,12(r2)
    e63c:	10bfffcc 	andi	r2,r2,65535
    e640:	1004923a 	slli	r2,r2,8
    e644:	10bfffcc 	andi	r2,r2,65535
    e648:	1884b03a 	or	r2,r3,r2
    e64c:	1005d33a 	srai	r2,r2,12
    e650:	e0bffd45 	stb	r2,-11(fp)
  if(pbuf_header(p, -(hdrlen * 4))){
    e654:	e0bffd43 	ldbu	r2,-11(fp)
    e658:	10bfff24 	muli	r2,r2,-4
    e65c:	10bfffcc 	andi	r2,r2,65535
    e660:	10a0001c 	xori	r2,r2,32768
    e664:	10a00004 	addi	r2,r2,-32768
    e668:	e13ffe17 	ldw	r4,-8(fp)
    e66c:	100b883a 	mov	r5,r2
    e670:	000a83c0 	call	a83c <pbuf_header>
    e674:	10803fcc 	andi	r2,r2,255
    e678:	10000926 	beq	r2,zero,e6a0 <tcp_input+0x214>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    e67c:	00800234 	movhi	r2,8
    e680:	1083bd04 	addi	r2,r2,3828
    e684:	1080268b 	ldhu	r2,154(r2)
    e688:	10800044 	addi	r2,r2,1
    e68c:	1007883a 	mov	r3,r2
    e690:	00800234 	movhi	r2,8
    e694:	1083bd04 	addi	r2,r2,3828
    e698:	10c0268d 	sth	r3,154(r2)
    goto dropped;
    e69c:	0002b006 	br	f160 <tcp_input+0xcd4>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
    e6a0:	d0a8c217 	ldw	r2,-23800(gp)
    e6a4:	d0e8c217 	ldw	r3,-23800(gp)
    e6a8:	18c0000b 	ldhu	r3,0(r3)
    e6ac:	18ffffcc 	andi	r3,r3,65535
    e6b0:	1806d23a 	srli	r3,r3,8
    e6b4:	1809883a 	mov	r4,r3
    e6b8:	d0e8c217 	ldw	r3,-23800(gp)
    e6bc:	18c0000b 	ldhu	r3,0(r3)
    e6c0:	18ffffcc 	andi	r3,r3,65535
    e6c4:	1806923a 	slli	r3,r3,8
    e6c8:	20c6b03a 	or	r3,r4,r3
    e6cc:	10c0000d 	sth	r3,0(r2)
  tcphdr->dest = ntohs(tcphdr->dest);
    e6d0:	d0a8c217 	ldw	r2,-23800(gp)
    e6d4:	d0e8c217 	ldw	r3,-23800(gp)
    e6d8:	18c0008b 	ldhu	r3,2(r3)
    e6dc:	18ffffcc 	andi	r3,r3,65535
    e6e0:	1806d23a 	srli	r3,r3,8
    e6e4:	1809883a 	mov	r4,r3
    e6e8:	d0e8c217 	ldw	r3,-23800(gp)
    e6ec:	18c0008b 	ldhu	r3,2(r3)
    e6f0:	18ffffcc 	andi	r3,r3,65535
    e6f4:	1806923a 	slli	r3,r3,8
    e6f8:	20c6b03a 	or	r3,r4,r3
    e6fc:	10c0008d 	sth	r3,2(r2)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
    e700:	d0a8c217 	ldw	r2,-23800(gp)
    e704:	d0e8c217 	ldw	r3,-23800(gp)
    e708:	1900010b 	ldhu	r4,4(r3)
    e70c:	18c0018b 	ldhu	r3,6(r3)
    e710:	1806943a 	slli	r3,r3,16
    e714:	1906b03a 	or	r3,r3,r4
    e718:	1808d63a 	srli	r4,r3,24
    e71c:	d0e8c217 	ldw	r3,-23800(gp)
    e720:	1940010b 	ldhu	r5,4(r3)
    e724:	18c0018b 	ldhu	r3,6(r3)
    e728:	1806943a 	slli	r3,r3,16
    e72c:	1946b03a 	or	r3,r3,r5
    e730:	1806d23a 	srli	r3,r3,8
    e734:	18ffc00c 	andi	r3,r3,65280
    e738:	20c8b03a 	or	r4,r4,r3
    e73c:	d0e8c217 	ldw	r3,-23800(gp)
    e740:	1940010b 	ldhu	r5,4(r3)
    e744:	18c0018b 	ldhu	r3,6(r3)
    e748:	1806943a 	slli	r3,r3,16
    e74c:	1946b03a 	or	r3,r3,r5
    e750:	18ffc00c 	andi	r3,r3,65280
    e754:	1806923a 	slli	r3,r3,8
    e758:	20c8b03a 	or	r4,r4,r3
    e75c:	d0e8c217 	ldw	r3,-23800(gp)
    e760:	1940010b 	ldhu	r5,4(r3)
    e764:	18c0018b 	ldhu	r3,6(r3)
    e768:	1806943a 	slli	r3,r3,16
    e76c:	1946b03a 	or	r3,r3,r5
    e770:	1806963a 	slli	r3,r3,24
    e774:	20c6b03a 	or	r3,r4,r3
    e778:	193fffcc 	andi	r4,r3,65535
    e77c:	1140010b 	ldhu	r5,4(r2)
    e780:	280a703a 	and	r5,r5,zero
    e784:	2908b03a 	or	r4,r5,r4
    e788:	1100010d 	sth	r4,4(r2)
    e78c:	1806d43a 	srli	r3,r3,16
    e790:	1100018b 	ldhu	r4,6(r2)
    e794:	2008703a 	and	r4,r4,zero
    e798:	20c6b03a 	or	r3,r4,r3
    e79c:	10c0018d 	sth	r3,6(r2)
    e7a0:	10c0010b 	ldhu	r3,4(r2)
    e7a4:	1080018b 	ldhu	r2,6(r2)
    e7a8:	1004943a 	slli	r2,r2,16
    e7ac:	10c4b03a 	or	r2,r2,r3
    e7b0:	d0a8c415 	stw	r2,-23792(gp)
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
    e7b4:	d0a8c217 	ldw	r2,-23800(gp)
    e7b8:	d0e8c217 	ldw	r3,-23800(gp)
    e7bc:	1900020b 	ldhu	r4,8(r3)
    e7c0:	18c0028b 	ldhu	r3,10(r3)
    e7c4:	1806943a 	slli	r3,r3,16
    e7c8:	1906b03a 	or	r3,r3,r4
    e7cc:	1808d63a 	srli	r4,r3,24
    e7d0:	d0e8c217 	ldw	r3,-23800(gp)
    e7d4:	1940020b 	ldhu	r5,8(r3)
    e7d8:	18c0028b 	ldhu	r3,10(r3)
    e7dc:	1806943a 	slli	r3,r3,16
    e7e0:	1946b03a 	or	r3,r3,r5
    e7e4:	1806d23a 	srli	r3,r3,8
    e7e8:	18ffc00c 	andi	r3,r3,65280
    e7ec:	20c8b03a 	or	r4,r4,r3
    e7f0:	d0e8c217 	ldw	r3,-23800(gp)
    e7f4:	1940020b 	ldhu	r5,8(r3)
    e7f8:	18c0028b 	ldhu	r3,10(r3)
    e7fc:	1806943a 	slli	r3,r3,16
    e800:	1946b03a 	or	r3,r3,r5
    e804:	18ffc00c 	andi	r3,r3,65280
    e808:	1806923a 	slli	r3,r3,8
    e80c:	20c8b03a 	or	r4,r4,r3
    e810:	d0e8c217 	ldw	r3,-23800(gp)
    e814:	1940020b 	ldhu	r5,8(r3)
    e818:	18c0028b 	ldhu	r3,10(r3)
    e81c:	1806943a 	slli	r3,r3,16
    e820:	1946b03a 	or	r3,r3,r5
    e824:	1806963a 	slli	r3,r3,24
    e828:	20c6b03a 	or	r3,r4,r3
    e82c:	193fffcc 	andi	r4,r3,65535
    e830:	1140020b 	ldhu	r5,8(r2)
    e834:	280a703a 	and	r5,r5,zero
    e838:	2908b03a 	or	r4,r5,r4
    e83c:	1100020d 	sth	r4,8(r2)
    e840:	1806d43a 	srli	r3,r3,16
    e844:	1100028b 	ldhu	r4,10(r2)
    e848:	2008703a 	and	r4,r4,zero
    e84c:	20c6b03a 	or	r3,r4,r3
    e850:	10c0028d 	sth	r3,10(r2)
    e854:	10c0020b 	ldhu	r3,8(r2)
    e858:	1080028b 	ldhu	r2,10(r2)
    e85c:	1004943a 	slli	r2,r2,16
    e860:	10c4b03a 	or	r2,r2,r3
    e864:	d0a8c515 	stw	r2,-23788(gp)
  tcphdr->wnd = ntohs(tcphdr->wnd);
    e868:	d0a8c217 	ldw	r2,-23800(gp)
    e86c:	d0e8c217 	ldw	r3,-23800(gp)
    e870:	18c0038b 	ldhu	r3,14(r3)
    e874:	18ffffcc 	andi	r3,r3,65535
    e878:	1806d23a 	srli	r3,r3,8
    e87c:	1809883a 	mov	r4,r3
    e880:	d0e8c217 	ldw	r3,-23800(gp)
    e884:	18c0038b 	ldhu	r3,14(r3)
    e888:	18ffffcc 	andi	r3,r3,65535
    e88c:	1806923a 	slli	r3,r3,8
    e890:	20c6b03a 	or	r3,r4,r3
    e894:	10c0038d 	sth	r3,14(r2)

  flags = TCPH_FLAGS(tcphdr);
    e898:	d0a8c217 	ldw	r2,-23800(gp)
    e89c:	1080030b 	ldhu	r2,12(r2)
    e8a0:	10bfffcc 	andi	r2,r2,65535
    e8a4:	1004d23a 	srli	r2,r2,8
    e8a8:	1007883a 	mov	r3,r2
    e8ac:	d0a8c217 	ldw	r2,-23800(gp)
    e8b0:	1080030b 	ldhu	r2,12(r2)
    e8b4:	10bfffcc 	andi	r2,r2,65535
    e8b8:	1004923a 	slli	r2,r2,8
    e8bc:	1884b03a 	or	r2,r3,r2
    e8c0:	10800fcc 	andi	r2,r2,63
    e8c4:	d0a8c605 	stb	r2,-23784(gp)
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
    e8c8:	e0bffe17 	ldw	r2,-8(fp)
    e8cc:	10c0020b 	ldhu	r3,8(r2)
    e8d0:	d0a8c603 	ldbu	r2,-23784(gp)
    e8d4:	10803fcc 	andi	r2,r2,255
    e8d8:	108000cc 	andi	r2,r2,3
    e8dc:	1004c03a 	cmpne	r2,r2,zero
    e8e0:	10803fcc 	andi	r2,r2,255
    e8e4:	1885883a 	add	r2,r3,r2
    e8e8:	d0a8c68d 	sth	r2,-23782(gp)

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
    e8ec:	e03ffb15 	stw	zero,-20(fp)

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    e8f0:	008000f4 	movhi	r2,3
    e8f4:	109e2e04 	addi	r2,r2,30904
    e8f8:	10800017 	ldw	r2,0(r2)
    e8fc:	e0bffa15 	stw	r2,-24(fp)
    e900:	00006e06 	br	eabc <tcp_input+0x630>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    e904:	e0bffa17 	ldw	r2,-24(fp)
    e908:	10800617 	ldw	r2,24(r2)
    e90c:	1000091e 	bne	r2,zero,e934 <tcp_input+0x4a8>
    e910:	010000f4 	movhi	r4,3
    e914:	2101fd04 	addi	r4,r4,2036
    e918:	014000f4 	movhi	r5,3
    e91c:	29420704 	addi	r5,r5,2076
    e920:	01802ac4 	movi	r6,171
    e924:	01c000f4 	movhi	r7,3
    e928:	39c21104 	addi	r7,r7,2116
    e92c:	00193f00 	call	193f0 <printf>
    e930:	003fff06 	br	e930 <tcp_input+0x4a4>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    e934:	e0bffa17 	ldw	r2,-24(fp)
    e938:	10800617 	ldw	r2,24(r2)
    e93c:	10800298 	cmpnei	r2,r2,10
    e940:	1000091e 	bne	r2,zero,e968 <tcp_input+0x4dc>
    e944:	010000f4 	movhi	r4,3
    e948:	2101fd04 	addi	r4,r4,2036
    e94c:	014000f4 	movhi	r5,3
    e950:	29421704 	addi	r5,r5,2140
    e954:	01802b04 	movi	r6,172
    e958:	01c000f4 	movhi	r7,3
    e95c:	39c21104 	addi	r7,r7,2116
    e960:	00193f00 	call	193f0 <printf>
    e964:	003fff06 	br	e964 <tcp_input+0x4d8>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    e968:	e0bffa17 	ldw	r2,-24(fp)
    e96c:	10800617 	ldw	r2,24(r2)
    e970:	10800058 	cmpnei	r2,r2,1
    e974:	1000091e 	bne	r2,zero,e99c <tcp_input+0x510>
    e978:	010000f4 	movhi	r4,3
    e97c:	2101fd04 	addi	r4,r4,2036
    e980:	014000f4 	movhi	r5,3
    e984:	29422204 	addi	r5,r5,2184
    e988:	01802b44 	movi	r6,173
    e98c:	01c000f4 	movhi	r7,3
    e990:	39c21104 	addi	r7,r7,2116
    e994:	00193f00 	call	193f0 <printf>
    e998:	003fff06 	br	e998 <tcp_input+0x50c>
    if (pcb->remote_port == tcphdr->src &&
    e99c:	e0bffa17 	ldw	r2,-24(fp)
    e9a0:	10c0080b 	ldhu	r3,32(r2)
    e9a4:	d0a8c217 	ldw	r2,-23800(gp)
    e9a8:	1080000b 	ldhu	r2,0(r2)
    e9ac:	18ffffcc 	andi	r3,r3,65535
    e9b0:	10bfffcc 	andi	r2,r2,65535
    e9b4:	18803c1e 	bne	r3,r2,eaa8 <tcp_input+0x61c>
       pcb->local_port == tcphdr->dest &&
    e9b8:	e0bffa17 	ldw	r2,-24(fp)
    e9bc:	10c0078b 	ldhu	r3,30(r2)
    e9c0:	d0a8c217 	ldw	r2,-23800(gp)
    e9c4:	1080008b 	ldhu	r2,2(r2)
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
    e9c8:	18ffffcc 	andi	r3,r3,65535
    e9cc:	10bfffcc 	andi	r2,r2,65535
    e9d0:	1880351e 	bne	r3,r2,eaa8 <tcp_input+0x61c>
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
    e9d4:	e0bffa17 	ldw	r2,-24(fp)
    e9d8:	10c00117 	ldw	r3,4(r2)
    e9dc:	008000f4 	movhi	r2,3
    e9e0:	109e1f04 	addi	r2,r2,30844
    e9e4:	10800017 	ldw	r2,0(r2)
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
    e9e8:	18802f1e 	bne	r3,r2,eaa8 <tcp_input+0x61c>
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
       ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
    e9ec:	e0bffa17 	ldw	r2,-24(fp)
    e9f0:	10c00017 	ldw	r3,0(r2)
    e9f4:	008000f4 	movhi	r2,3
    e9f8:	109e2104 	addi	r2,r2,30852
    e9fc:	10800017 	ldw	r2,0(r2)
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
    ea00:	1880291e 	bne	r3,r2,eaa8 <tcp_input+0x61c>
       ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
    ea04:	e0bffa17 	ldw	r2,-24(fp)
    ea08:	10c00317 	ldw	r3,12(r2)
    ea0c:	e0bffa17 	ldw	r2,-24(fp)
    ea10:	1880091e 	bne	r3,r2,ea38 <tcp_input+0x5ac>
    ea14:	010000f4 	movhi	r4,3
    ea18:	2101fd04 	addi	r4,r4,2036
    ea1c:	014000f4 	movhi	r5,3
    ea20:	29422c04 	addi	r5,r5,2224
    ea24:	01802d84 	movi	r6,182
    ea28:	01c000f4 	movhi	r7,3
    ea2c:	39c21104 	addi	r7,r7,2116
    ea30:	00193f00 	call	193f0 <printf>
    ea34:	003fff06 	br	ea34 <tcp_input+0x5a8>
      if (prev != NULL) {
    ea38:	e0bffb17 	ldw	r2,-20(fp)
    ea3c:	10000d26 	beq	r2,zero,ea74 <tcp_input+0x5e8>
        prev->next = pcb->next;
    ea40:	e0bffa17 	ldw	r2,-24(fp)
    ea44:	10c00317 	ldw	r3,12(r2)
    ea48:	e0bffb17 	ldw	r2,-20(fp)
    ea4c:	10c00315 	stw	r3,12(r2)
        pcb->next = tcp_active_pcbs;
    ea50:	008000f4 	movhi	r2,3
    ea54:	109e2e04 	addi	r2,r2,30904
    ea58:	10c00017 	ldw	r3,0(r2)
    ea5c:	e0bffa17 	ldw	r2,-24(fp)
    ea60:	10c00315 	stw	r3,12(r2)
        tcp_active_pcbs = pcb;
    ea64:	008000f4 	movhi	r2,3
    ea68:	109e2e04 	addi	r2,r2,30904
    ea6c:	e0fffa17 	ldw	r3,-24(fp)
    ea70:	10c00015 	stw	r3,0(r2)
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
    ea74:	e0bffa17 	ldw	r2,-24(fp)
    ea78:	10c00317 	ldw	r3,12(r2)
    ea7c:	e0bffa17 	ldw	r2,-24(fp)
    ea80:	1880111e 	bne	r3,r2,eac8 <tcp_input+0x63c>
    ea84:	010000f4 	movhi	r4,3
    ea88:	2101fd04 	addi	r4,r4,2036
    ea8c:	014000f4 	movhi	r5,3
    ea90:	29423704 	addi	r5,r5,2268
    ea94:	01802f04 	movi	r6,188
    ea98:	01c000f4 	movhi	r7,3
    ea9c:	39c21104 	addi	r7,r7,2116
    eaa0:	00193f00 	call	193f0 <printf>
    eaa4:	003fff06 	br	eaa4 <tcp_input+0x618>
      break;
    }
    prev = pcb;
    eaa8:	e0bffa17 	ldw	r2,-24(fp)
    eaac:	e0bffb15 	stw	r2,-20(fp)
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    eab0:	e0bffa17 	ldw	r2,-24(fp)
    eab4:	10800317 	ldw	r2,12(r2)
    eab8:	e0bffa15 	stw	r2,-24(fp)
    eabc:	e0bffa17 	ldw	r2,-24(fp)
    eac0:	103f901e 	bne	r2,zero,e904 <tcp_input+0x478>
    eac4:	00000106 	br	eacc <tcp_input+0x640>
        prev->next = pcb->next;
        pcb->next = tcp_active_pcbs;
        tcp_active_pcbs = pcb;
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
      break;
    eac8:	0001883a 	nop
    }
    prev = pcb;
  }

  if (pcb == NULL) {
    eacc:	e0bffa17 	ldw	r2,-24(fp)
    ead0:	10006b1e 	bne	r2,zero,ec80 <tcp_input+0x7f4>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    ead4:	008000f4 	movhi	r2,3
    ead8:	109e3304 	addi	r2,r2,30924
    eadc:	10800017 	ldw	r2,0(r2)
    eae0:	e0bffa15 	stw	r2,-24(fp)
    eae4:	00002f06 	br	eba4 <tcp_input+0x718>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
    eae8:	e0bffa17 	ldw	r2,-24(fp)
    eaec:	10800617 	ldw	r2,24(r2)
    eaf0:	108002a0 	cmpeqi	r2,r2,10
    eaf4:	1000091e 	bne	r2,zero,eb1c <tcp_input+0x690>
    eaf8:	010000f4 	movhi	r4,3
    eafc:	2101fd04 	addi	r4,r4,2036
    eb00:	014000f4 	movhi	r5,3
    eb04:	29424204 	addi	r5,r5,2312
    eb08:	01803184 	movi	r6,198
    eb0c:	01c000f4 	movhi	r7,3
    eb10:	39c21104 	addi	r7,r7,2116
    eb14:	00193f00 	call	193f0 <printf>
    eb18:	003fff06 	br	eb18 <tcp_input+0x68c>
      if (pcb->remote_port == tcphdr->src &&
    eb1c:	e0bffa17 	ldw	r2,-24(fp)
    eb20:	10c0080b 	ldhu	r3,32(r2)
    eb24:	d0a8c217 	ldw	r2,-23800(gp)
    eb28:	1080000b 	ldhu	r2,0(r2)
    eb2c:	18ffffcc 	andi	r3,r3,65535
    eb30:	10bfffcc 	andi	r2,r2,65535
    eb34:	1880181e 	bne	r3,r2,eb98 <tcp_input+0x70c>
         pcb->local_port == tcphdr->dest &&
    eb38:	e0bffa17 	ldw	r2,-24(fp)
    eb3c:	10c0078b 	ldhu	r3,30(r2)
    eb40:	d0a8c217 	ldw	r2,-23800(gp)
    eb44:	1080008b 	ldhu	r2,2(r2)
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
    eb48:	18ffffcc 	andi	r3,r3,65535
    eb4c:	10bfffcc 	andi	r2,r2,65535
    eb50:	1880111e 	bne	r3,r2,eb98 <tcp_input+0x70c>
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
    eb54:	e0bffa17 	ldw	r2,-24(fp)
    eb58:	10c00117 	ldw	r3,4(r2)
    eb5c:	008000f4 	movhi	r2,3
    eb60:	109e1f04 	addi	r2,r2,30844
    eb64:	10800017 	ldw	r2,0(r2)
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
    eb68:	18800b1e 	bne	r3,r2,eb98 <tcp_input+0x70c>
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
         ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
    eb6c:	e0bffa17 	ldw	r2,-24(fp)
    eb70:	10c00017 	ldw	r3,0(r2)
    eb74:	008000f4 	movhi	r2,3
    eb78:	109e2104 	addi	r2,r2,30852
    eb7c:	10800017 	ldw	r2,0(r2)
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
    eb80:	1880051e 	bne	r3,r2,eb98 <tcp_input+0x70c>
         ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
    eb84:	e13ffa17 	ldw	r4,-24(fp)
    eb88:	000f4340 	call	f434 <tcp_timewait_input>
        pbuf_free(p);
    eb8c:	e13ffe17 	ldw	r4,-8(fp)
    eb90:	000aa340 	call	aa34 <pbuf_free>
        return;
    eb94:	00017e06 	br	f190 <tcp_input+0xd04>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    eb98:	e0bffa17 	ldw	r2,-24(fp)
    eb9c:	10800317 	ldw	r2,12(r2)
    eba0:	e0bffa15 	stw	r2,-24(fp)
    eba4:	e0bffa17 	ldw	r2,-24(fp)
    eba8:	103fcf1e 	bne	r2,zero,eae8 <tcp_input+0x65c>
      }
    }

    /* Finally, if we still did not get a match, we check all PCBs that
       are LISTENing for incoming connections. */
    prev = NULL;
    ebac:	e03ffb15 	stw	zero,-20(fp)
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    ebb0:	008000f4 	movhi	r2,3
    ebb4:	109e3004 	addi	r2,r2,30912
    ebb8:	10800017 	ldw	r2,0(r2)
    ebbc:	e0bffc15 	stw	r2,-16(fp)
    ebc0:	00001706 	br	ec20 <tcp_input+0x794>
      if (lpcb->local_port == tcphdr->dest) {
    ebc4:	e0bffc17 	ldw	r2,-16(fp)
    ebc8:	10c0078b 	ldhu	r3,30(r2)
    ebcc:	d0a8c217 	ldw	r2,-23800(gp)
    ebd0:	1080008b 	ldhu	r2,2(r2)
    ebd4:	18ffffcc 	andi	r3,r3,65535
    ebd8:	10bfffcc 	andi	r2,r2,65535
    ebdc:	18800b1e 	bne	r3,r2,ec0c <tcp_input+0x780>
          /* found an ANY-match */
          lpcb_any = lpcb;
          lpcb_prev = prev;
        }
#else /* SO_REUSE */
        if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) ||
    ebe0:	e0bffc17 	ldw	r2,-16(fp)
    ebe4:	10c00017 	ldw	r3,0(r2)
    ebe8:	008000f4 	movhi	r2,3
    ebec:	109e2104 	addi	r2,r2,30852
    ebf0:	10800017 	ldw	r2,0(r2)
    ebf4:	18800c26 	beq	r3,r2,ec28 <tcp_input+0x79c>
            ip_addr_isany(&(lpcb->local_ip))) {
    ebf8:	e0bffc17 	ldw	r2,-16(fp)
          /* found an ANY-match */
          lpcb_any = lpcb;
          lpcb_prev = prev;
        }
#else /* SO_REUSE */
        if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) ||
    ebfc:	10000a26 	beq	r2,zero,ec28 <tcp_input+0x79c>
            ip_addr_isany(&(lpcb->local_ip))) {
    ec00:	e0bffc17 	ldw	r2,-16(fp)
    ec04:	10800017 	ldw	r2,0(r2)
    ec08:	10000726 	beq	r2,zero,ec28 <tcp_input+0x79c>
          /* found a match */
          break;
        }
#endif /* SO_REUSE */
      }
      prev = (struct tcp_pcb *)lpcb;
    ec0c:	e0bffc17 	ldw	r2,-16(fp)
    ec10:	e0bffb15 	stw	r2,-20(fp)
    }

    /* Finally, if we still did not get a match, we check all PCBs that
       are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    ec14:	e0bffc17 	ldw	r2,-16(fp)
    ec18:	10800317 	ldw	r2,12(r2)
    ec1c:	e0bffc15 	stw	r2,-16(fp)
    ec20:	e0bffc17 	ldw	r2,-16(fp)
    ec24:	103fe71e 	bne	r2,zero,ebc4 <tcp_input+0x738>
      /* only pass to ANY if no specific local IP has been found */
      lpcb = lpcb_any;
      prev = lpcb_prev;
    }
#endif /* SO_REUSE */
    if (lpcb != NULL) {
    ec28:	e0bffc17 	ldw	r2,-16(fp)
    ec2c:	10001426 	beq	r2,zero,ec80 <tcp_input+0x7f4>
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      if (prev != NULL) {
    ec30:	e0bffb17 	ldw	r2,-20(fp)
    ec34:	10000d26 	beq	r2,zero,ec6c <tcp_input+0x7e0>
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
    ec38:	e0bffc17 	ldw	r2,-16(fp)
    ec3c:	10c00317 	ldw	r3,12(r2)
    ec40:	e0bffb17 	ldw	r2,-20(fp)
    ec44:	10c00315 	stw	r3,12(r2)
              /* our successor is the remainder of the listening list */
        lpcb->next = tcp_listen_pcbs.listen_pcbs;
    ec48:	008000f4 	movhi	r2,3
    ec4c:	109e3004 	addi	r2,r2,30912
    ec50:	10c00017 	ldw	r3,0(r2)
    ec54:	e0bffc17 	ldw	r2,-16(fp)
    ec58:	10c00315 	stw	r3,12(r2)
              /* put this listening pcb at the head of the listening list */
        tcp_listen_pcbs.listen_pcbs = lpcb;
    ec5c:	008000f4 	movhi	r2,3
    ec60:	109e3004 	addi	r2,r2,30912
    ec64:	e0fffc17 	ldw	r3,-16(fp)
    ec68:	10c00015 	stw	r3,0(r2)
      }
    
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
      tcp_listen_input(lpcb);
    ec6c:	e13ffc17 	ldw	r4,-16(fp)
    ec70:	000f1a40 	call	f1a4 <tcp_listen_input>
      pbuf_free(p);
    ec74:	e13ffe17 	ldw	r4,-8(fp)
    ec78:	000aa340 	call	aa34 <pbuf_free>
      return;
    ec7c:	00014406 	br	f190 <tcp_input+0xd04>
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
#endif /* TCP_INPUT_DEBUG */


  if (pcb != NULL) {
    ec80:	e0bffa17 	ldw	r2,-24(fp)
    ec84:	10010226 	beq	r2,zero,f090 <tcp_input+0xc04>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
    ec88:	00800134 	movhi	r2,4
    ec8c:	10973504 	addi	r2,r2,23764
    ec90:	10000015 	stw	zero,0(r2)
    inseg.len = p->tot_len;
    ec94:	e0bffe17 	ldw	r2,-8(fp)
    ec98:	10c0020b 	ldhu	r3,8(r2)
    ec9c:	00800134 	movhi	r2,4
    eca0:	10973504 	addi	r2,r2,23764
    eca4:	10c0020d 	sth	r3,8(r2)
    inseg.p = p;
    eca8:	00800134 	movhi	r2,4
    ecac:	10973504 	addi	r2,r2,23764
    ecb0:	e0fffe17 	ldw	r3,-8(fp)
    ecb4:	10c00115 	stw	r3,4(r2)
    inseg.tcphdr = tcphdr;
    ecb8:	d0e8c217 	ldw	r3,-23800(gp)
    ecbc:	00800134 	movhi	r2,4
    ecc0:	10973504 	addi	r2,r2,23764
    ecc4:	10c00315 	stw	r3,12(r2)

    recv_data = NULL;
    ecc8:	d028c815 	stw	zero,-23776(gp)
    recv_flags = 0;
    eccc:	d028c705 	stb	zero,-23780(gp)

    if (flags & TCP_PSH) {
    ecd0:	d0a8c603 	ldbu	r2,-23784(gp)
    ecd4:	10803fcc 	andi	r2,r2,255
    ecd8:	1080020c 	andi	r2,r2,8
    ecdc:	10000626 	beq	r2,zero,ecf8 <tcp_input+0x86c>
      p->flags |= PBUF_FLAG_PUSH;
    ece0:	e0bffe17 	ldw	r2,-8(fp)
    ece4:	10800343 	ldbu	r2,13(r2)
    ece8:	10800054 	ori	r2,r2,1
    ecec:	1007883a 	mov	r3,r2
    ecf0:	e0bffe17 	ldw	r2,-8(fp)
    ecf4:	10c00345 	stb	r3,13(r2)
    }

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
    ecf8:	e0bffa17 	ldw	r2,-24(fp)
    ecfc:	10801f17 	ldw	r2,124(r2)
    ed00:	10001626 	beq	r2,zero,ed5c <tcp_input+0x8d0>
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
    ed04:	e13ffa17 	ldw	r4,-24(fp)
    ed08:	000d8680 	call	d868 <tcp_process_refused_data>
    ed0c:	10803fcc 	andi	r2,r2,255
    ed10:	1080201c 	xori	r2,r2,128
    ed14:	10bfe004 	addi	r2,r2,-128
    ed18:	10bffda0 	cmpeqi	r2,r2,-10
    ed1c:	1000061e 	bne	r2,zero,ed38 <tcp_input+0x8ac>
        ((pcb->refused_data != NULL) && (tcplen > 0))) {
    ed20:	e0bffa17 	ldw	r2,-24(fp)
    ed24:	10801f17 	ldw	r2,124(r2)
      p->flags |= PBUF_FLAG_PUSH;
    }

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
    ed28:	10000c26 	beq	r2,zero,ed5c <tcp_input+0x8d0>
        ((pcb->refused_data != NULL) && (tcplen > 0))) {
    ed2c:	d0a8c68b 	ldhu	r2,-23782(gp)
    ed30:	10bfffcc 	andi	r2,r2,65535
    ed34:	10000926 	beq	r2,zero,ed5c <tcp_input+0x8d0>
        /* pcb has been aborted or refused data is still refused and the new
           segment contains data */
        TCP_STATS_INC(tcp.drop);
    ed38:	00800234 	movhi	r2,8
    ed3c:	1083bd04 	addi	r2,r2,3828
    ed40:	1080258b 	ldhu	r2,150(r2)
    ed44:	10800044 	addi	r2,r2,1
    ed48:	1007883a 	mov	r3,r2
    ed4c:	00800234 	movhi	r2,8
    ed50:	1083bd04 	addi	r2,r2,3828
    ed54:	10c0258d 	sth	r3,150(r2)
        snmp_inc_tcpinerrs();
        goto aborted;
    ed58:	0000be06 	br	f054 <tcp_input+0xbc8>
      }
    }
    tcp_input_pcb = pcb;
    ed5c:	e0bffa17 	ldw	r2,-24(fp)
    ed60:	d0a8c915 	stw	r2,-23772(gp)
    err = tcp_process(pcb);
    ed64:	e13ffa17 	ldw	r4,-24(fp)
    ed68:	000f56c0 	call	f56c <tcp_process>
    ed6c:	e0bffd05 	stb	r2,-12(fp)
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
    ed70:	e0bffd07 	ldb	r2,-12(fp)
    ed74:	10bffda0 	cmpeqi	r2,r2,-10
    ed78:	1000b61e 	bne	r2,zero,f054 <tcp_input+0xbc8>
      if (recv_flags & TF_RESET) {
    ed7c:	d0a8c703 	ldbu	r2,-23780(gp)
    ed80:	10803fcc 	andi	r2,r2,255
    ed84:	1080020c 	andi	r2,r2,8
    ed88:	10001226 	beq	r2,zero,edd4 <tcp_input+0x948>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
    ed8c:	e0bffa17 	ldw	r2,-24(fp)
    ed90:	10802417 	ldw	r2,144(r2)
    ed94:	10000726 	beq	r2,zero,edb4 <tcp_input+0x928>
    ed98:	e0bffa17 	ldw	r2,-24(fp)
    ed9c:	10c02417 	ldw	r3,144(r2)
    eda0:	e0bffa17 	ldw	r2,-24(fp)
    eda4:	10800417 	ldw	r2,16(r2)
    eda8:	1009883a 	mov	r4,r2
    edac:	017ffd44 	movi	r5,-11
    edb0:	183ee83a 	callr	r3
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
    edb4:	010000f4 	movhi	r4,3
    edb8:	211e2e04 	addi	r4,r4,30904
    edbc:	e17ffa17 	ldw	r5,-24(fp)
    edc0:	000e1f40 	call	e1f4 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
    edc4:	01000084 	movi	r4,2
    edc8:	e17ffa17 	ldw	r5,-24(fp)
    edcc:	00097d40 	call	97d4 <memp_free>
    edd0:	0000a006 	br	f054 <tcp_input+0xbc8>
      } else if (recv_flags & TF_CLOSED) {
    edd4:	d0a8c703 	ldbu	r2,-23780(gp)
    edd8:	10803fcc 	andi	r2,r2,255
    eddc:	1080040c 	andi	r2,r2,16
    ede0:	10001726 	beq	r2,zero,ee40 <tcp_input+0x9b4>
        /* The connection has been closed and we will deallocate the
           PCB. */
        if (!(pcb->flags & TF_RXCLOSED)) {
    ede4:	e0bffa17 	ldw	r2,-24(fp)
    ede8:	10800883 	ldbu	r2,34(r2)
    edec:	10803fcc 	andi	r2,r2,255
    edf0:	1080040c 	andi	r2,r2,16
    edf4:	10000a1e 	bne	r2,zero,ee20 <tcp_input+0x994>
          /* Connection closed although the application has only shut down the
             tx side: call the PCB's err callback and indicate the closure to
             ensure the application doesn't continue using the PCB. */
          TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
    edf8:	e0bffa17 	ldw	r2,-24(fp)
    edfc:	10802417 	ldw	r2,144(r2)
    ee00:	10000726 	beq	r2,zero,ee20 <tcp_input+0x994>
    ee04:	e0bffa17 	ldw	r2,-24(fp)
    ee08:	10c02417 	ldw	r3,144(r2)
    ee0c:	e0bffa17 	ldw	r2,-24(fp)
    ee10:	10800417 	ldw	r2,16(r2)
    ee14:	1009883a 	mov	r4,r2
    ee18:	017ffd04 	movi	r5,-12
    ee1c:	183ee83a 	callr	r3
        }
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
    ee20:	010000f4 	movhi	r4,3
    ee24:	211e2e04 	addi	r4,r4,30904
    ee28:	e17ffa17 	ldw	r5,-24(fp)
    ee2c:	000e1f40 	call	e1f4 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
    ee30:	01000084 	movi	r4,2
    ee34:	e17ffa17 	ldw	r5,-24(fp)
    ee38:	00097d40 	call	97d4 <memp_free>
    ee3c:	00008506 	br	f054 <tcp_input+0xbc8>
      } else {
        err = ERR_OK;
    ee40:	e03ffd05 	stb	zero,-12(fp)
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
    ee44:	e0bffa17 	ldw	r2,-24(fp)
    ee48:	10801a0b 	ldhu	r2,104(r2)
    ee4c:	10bfffcc 	andi	r2,r2,65535
    ee50:	10001426 	beq	r2,zero,eea4 <tcp_input+0xa18>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
    ee54:	e0bffa17 	ldw	r2,-24(fp)
    ee58:	10802017 	ldw	r2,128(r2)
    ee5c:	10000d26 	beq	r2,zero,ee94 <tcp_input+0xa08>
    ee60:	e0bffa17 	ldw	r2,-24(fp)
    ee64:	11c02017 	ldw	r7,128(r2)
    ee68:	e0bffa17 	ldw	r2,-24(fp)
    ee6c:	10c00417 	ldw	r3,16(r2)
    ee70:	e0bffa17 	ldw	r2,-24(fp)
    ee74:	10801a0b 	ldhu	r2,104(r2)
    ee78:	10bfffcc 	andi	r2,r2,65535
    ee7c:	1809883a 	mov	r4,r3
    ee80:	e17ffa17 	ldw	r5,-24(fp)
    ee84:	100d883a 	mov	r6,r2
    ee88:	383ee83a 	callr	r7
    ee8c:	e0bffd05 	stb	r2,-12(fp)
    ee90:	00000106 	br	ee98 <tcp_input+0xa0c>
    ee94:	e03ffd05 	stb	zero,-12(fp)
          if (err == ERR_ABRT) {
    ee98:	e0bffd07 	ldb	r2,-12(fp)
    ee9c:	10bffd98 	cmpnei	r2,r2,-10
    eea0:	10006726 	beq	r2,zero,f040 <tcp_input+0xbb4>
            goto aborted;
          }
        }

        if (recv_data != NULL) {
    eea4:	d0a8c817 	ldw	r2,-23776(gp)
    eea8:	10003526 	beq	r2,zero,ef80 <tcp_input+0xaf4>
          LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
    eeac:	e0bffa17 	ldw	r2,-24(fp)
    eeb0:	10801f17 	ldw	r2,124(r2)
    eeb4:	10000926 	beq	r2,zero,eedc <tcp_input+0xa50>
    eeb8:	010000f4 	movhi	r4,3
    eebc:	2101fd04 	addi	r4,r4,2036
    eec0:	014000f4 	movhi	r5,3
    eec4:	29424e04 	addi	r5,r5,2360
    eec8:	01805504 	movi	r6,340
    eecc:	01c000f4 	movhi	r7,3
    eed0:	39c21104 	addi	r7,r7,2116
    eed4:	00193f00 	call	193f0 <printf>
    eed8:	003fff06 	br	eed8 <tcp_input+0xa4c>
          if (pcb->flags & TF_RXCLOSED) {
    eedc:	e0bffa17 	ldw	r2,-24(fp)
    eee0:	10800883 	ldbu	r2,34(r2)
    eee4:	10803fcc 	andi	r2,r2,255
    eee8:	1080040c 	andi	r2,r2,16
    eeec:	10000626 	beq	r2,zero,ef08 <tcp_input+0xa7c>
            /* received data although already closed -> abort (send RST) to
               notify the remote host that not all data has been processed */
            pbuf_free(recv_data);
    eef0:	d0a8c817 	ldw	r2,-23776(gp)
    eef4:	1009883a 	mov	r4,r2
    eef8:	000aa340 	call	aa34 <pbuf_free>
            tcp_abort(pcb);
    eefc:	e13ffa17 	ldw	r4,-24(fp)
    ef00:	000c5280 	call	c528 <tcp_abort>
            goto aborted;
    ef04:	00005306 	br	f054 <tcp_input+0xbc8>
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
    ef08:	e0bffa17 	ldw	r2,-24(fp)
    ef0c:	10802117 	ldw	r2,132(r2)
    ef10:	10000c26 	beq	r2,zero,ef44 <tcp_input+0xab8>
    ef14:	e0bffa17 	ldw	r2,-24(fp)
    ef18:	12002117 	ldw	r8,132(r2)
    ef1c:	e0bffa17 	ldw	r2,-24(fp)
    ef20:	10c00417 	ldw	r3,16(r2)
    ef24:	d0a8c817 	ldw	r2,-23776(gp)
    ef28:	1809883a 	mov	r4,r3
    ef2c:	e17ffa17 	ldw	r5,-24(fp)
    ef30:	100d883a 	mov	r6,r2
    ef34:	000f883a 	mov	r7,zero
    ef38:	403ee83a 	callr	r8
    ef3c:	e0bffd05 	stb	r2,-12(fp)
    ef40:	00000706 	br	ef60 <tcp_input+0xad4>
    ef44:	d0a8c817 	ldw	r2,-23776(gp)
    ef48:	0009883a 	mov	r4,zero
    ef4c:	e17ffa17 	ldw	r5,-24(fp)
    ef50:	100d883a 	mov	r6,r2
    ef54:	000f883a 	mov	r7,zero
    ef58:	000dafc0 	call	dafc <tcp_recv_null>
    ef5c:	e0bffd05 	stb	r2,-12(fp)
          if (err == ERR_ABRT) {
    ef60:	e0bffd07 	ldb	r2,-12(fp)
    ef64:	10bffd98 	cmpnei	r2,r2,-10
    ef68:	10003726 	beq	r2,zero,f048 <tcp_input+0xbbc>
            goto aborted;
          }

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
    ef6c:	e0bffd07 	ldb	r2,-12(fp)
    ef70:	10000326 	beq	r2,zero,ef80 <tcp_input+0xaf4>
            pcb->refused_data = recv_data;
    ef74:	d0e8c817 	ldw	r3,-23776(gp)
    ef78:	e0bffa17 	ldw	r2,-24(fp)
    ef7c:	10c01f15 	stw	r3,124(r2)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
    ef80:	d0a8c703 	ldbu	r2,-23780(gp)
    ef84:	10803fcc 	andi	r2,r2,255
    ef88:	1080080c 	andi	r2,r2,32
    ef8c:	10002826 	beq	r2,zero,f030 <tcp_input+0xba4>
          if (pcb->refused_data != NULL) {
    ef90:	e0bffa17 	ldw	r2,-24(fp)
    ef94:	10801f17 	ldw	r2,124(r2)
    ef98:	10000826 	beq	r2,zero,efbc <tcp_input+0xb30>
            /* Delay this if we have refused data. */
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
    ef9c:	e0bffa17 	ldw	r2,-24(fp)
    efa0:	10801f17 	ldw	r2,124(r2)
    efa4:	e0fffa17 	ldw	r3,-24(fp)
    efa8:	18c01f17 	ldw	r3,124(r3)
    efac:	18c00343 	ldbu	r3,13(r3)
    efb0:	18c00814 	ori	r3,r3,32
    efb4:	10c00345 	stb	r3,13(r2)
    efb8:	00001d06 	br	f030 <tcp_input+0xba4>
          } else {
            /* correct rcv_wnd as the application won't call tcp_recved()
               for the FIN's seqno */
            if (pcb->rcv_wnd != TCP_WND) {
    efbc:	e0bffa17 	ldw	r2,-24(fp)
    efc0:	10800c0b 	ldhu	r2,48(r2)
    efc4:	10bfffcc 	andi	r2,r2,65535
    efc8:	10820020 	cmpeqi	r2,r2,2048
    efcc:	1000061e 	bne	r2,zero,efe8 <tcp_input+0xb5c>
              pcb->rcv_wnd++;
    efd0:	e0bffa17 	ldw	r2,-24(fp)
    efd4:	10800c0b 	ldhu	r2,48(r2)
    efd8:	10800044 	addi	r2,r2,1
    efdc:	1007883a 	mov	r3,r2
    efe0:	e0bffa17 	ldw	r2,-24(fp)
    efe4:	10c00c0d 	sth	r3,48(r2)
            }
            TCP_EVENT_CLOSED(pcb, err);
    efe8:	e0bffa17 	ldw	r2,-24(fp)
    efec:	10802117 	ldw	r2,132(r2)
    eff0:	10000b26 	beq	r2,zero,f020 <tcp_input+0xb94>
    eff4:	e0bffa17 	ldw	r2,-24(fp)
    eff8:	10c02117 	ldw	r3,132(r2)
    effc:	e0bffa17 	ldw	r2,-24(fp)
    f000:	10800417 	ldw	r2,16(r2)
    f004:	1009883a 	mov	r4,r2
    f008:	e17ffa17 	ldw	r5,-24(fp)
    f00c:	000d883a 	mov	r6,zero
    f010:	000f883a 	mov	r7,zero
    f014:	183ee83a 	callr	r3
    f018:	e0bffd05 	stb	r2,-12(fp)
    f01c:	00000106 	br	f024 <tcp_input+0xb98>
    f020:	e03ffd05 	stb	zero,-12(fp)
            if (err == ERR_ABRT) {
    f024:	e0bffd07 	ldb	r2,-12(fp)
    f028:	10bffd98 	cmpnei	r2,r2,-10
    f02c:	10000826 	beq	r2,zero,f050 <tcp_input+0xbc4>
              goto aborted;
            }
          }
        }

        tcp_input_pcb = NULL;
    f030:	d028c915 	stw	zero,-23772(gp)
        /* Try to send something out. */
        tcp_output(pcb);
    f034:	e13ffa17 	ldw	r4,-24(fp)
    f038:	0013a740 	call	13a74 <tcp_output>
    f03c:	00000506 	br	f054 <tcp_input+0xbc8>
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
          TCP_EVENT_SENT(pcb, pcb->acked, err);
          if (err == ERR_ABRT) {
            goto aborted;
    f040:	0001883a 	nop
    f044:	00000306 	br	f054 <tcp_input+0xbc8>
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
          if (err == ERR_ABRT) {
            goto aborted;
    f048:	0001883a 	nop
    f04c:	00000106 	br	f054 <tcp_input+0xbc8>
            if (pcb->rcv_wnd != TCP_WND) {
              pcb->rcv_wnd++;
            }
            TCP_EVENT_CLOSED(pcb, err);
            if (err == ERR_ABRT) {
              goto aborted;
    f050:	0001883a 	nop
      }
    }
    /* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).
       Below this line, 'pcb' may not be dereferenced! */
aborted:
    tcp_input_pcb = NULL;
    f054:	d028c915 	stw	zero,-23772(gp)
    recv_data = NULL;
    f058:	d028c815 	stw	zero,-23776(gp)

    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
    f05c:	00800134 	movhi	r2,4
    f060:	10973504 	addi	r2,r2,23764
    f064:	10800117 	ldw	r2,4(r2)
    f068:	10004826 	beq	r2,zero,f18c <tcp_input+0xd00>
    {
      pbuf_free(inseg.p);
    f06c:	00800134 	movhi	r2,4
    f070:	10973504 	addi	r2,r2,23764
    f074:	10800117 	ldw	r2,4(r2)
    f078:	1009883a 	mov	r4,r2
    f07c:	000aa340 	call	aa34 <pbuf_free>
      inseg.p = NULL;
    f080:	00800134 	movhi	r2,4
    f084:	10973504 	addi	r2,r2,23764
    f088:	10000115 	stw	zero,4(r2)
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
    f08c:	00003f06 	br	f18c <tcp_input+0xd00>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
    f090:	d0a8c217 	ldw	r2,-23800(gp)
    f094:	1080030b 	ldhu	r2,12(r2)
    f098:	10bfffcc 	andi	r2,r2,65535
    f09c:	1004d23a 	srli	r2,r2,8
    f0a0:	10ffffcc 	andi	r3,r2,65535
    f0a4:	d0a8c217 	ldw	r2,-23800(gp)
    f0a8:	1080030b 	ldhu	r2,12(r2)
    f0ac:	10bfffcc 	andi	r2,r2,65535
    f0b0:	1004923a 	slli	r2,r2,8
    f0b4:	10bfffcc 	andi	r2,r2,65535
    f0b8:	1884b03a 	or	r2,r3,r2
    f0bc:	1080010c 	andi	r2,r2,4
    f0c0:	1000241e 	bne	r2,zero,f154 <tcp_input+0xcc8>
      TCP_STATS_INC(tcp.proterr);
    f0c4:	00800234 	movhi	r2,8
    f0c8:	1083bd04 	addi	r2,r2,3828
    f0cc:	1080280b 	ldhu	r2,160(r2)
    f0d0:	10800044 	addi	r2,r2,1
    f0d4:	1007883a 	mov	r3,r2
    f0d8:	00800234 	movhi	r2,8
    f0dc:	1083bd04 	addi	r2,r2,3828
    f0e0:	10c0280d 	sth	r3,160(r2)
      TCP_STATS_INC(tcp.drop);
    f0e4:	00800234 	movhi	r2,8
    f0e8:	1083bd04 	addi	r2,r2,3828
    f0ec:	1080258b 	ldhu	r2,150(r2)
    f0f0:	10800044 	addi	r2,r2,1
    f0f4:	1007883a 	mov	r3,r2
    f0f8:	00800234 	movhi	r2,8
    f0fc:	1083bd04 	addi	r2,r2,3828
    f100:	10c0258d 	sth	r3,150(r2)
      tcp_rst(ackno, seqno + tcplen,
    f104:	d0e8c517 	ldw	r3,-23788(gp)
    f108:	d0a8c68b 	ldhu	r2,-23782(gp)
    f10c:	113fffcc 	andi	r4,r2,65535
    f110:	d0a8c417 	ldw	r2,-23792(gp)
    f114:	2085883a 	add	r2,r4,r2
        ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
    f118:	d128c217 	ldw	r4,-23800(gp)
    f11c:	2100008b 	ldhu	r4,2(r4)
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
    f120:	217fffcc 	andi	r5,r4,65535
        ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
    f124:	d128c217 	ldw	r4,-23800(gp)
    f128:	2100000b 	ldhu	r4,0(r4)
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
    f12c:	213fffcc 	andi	r4,r4,65535
    f130:	d9400015 	stw	r5,0(sp)
    f134:	d9000115 	stw	r4,4(sp)
    f138:	1809883a 	mov	r4,r3
    f13c:	100b883a 	mov	r5,r2
    f140:	018000f4 	movhi	r6,3
    f144:	319e2104 	addi	r6,r6,30852
    f148:	01c000f4 	movhi	r7,3
    f14c:	39de1f04 	addi	r7,r7,30844
    f150:	00146680 	call	14668 <tcp_rst>
        ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
    f154:	e13ffe17 	ldw	r4,-8(fp)
    f158:	000aa340 	call	aa34 <pbuf_free>
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
    f15c:	00000b06 	br	f18c <tcp_input+0xd00>
dropped:
  TCP_STATS_INC(tcp.drop);
    f160:	00800234 	movhi	r2,8
    f164:	1083bd04 	addi	r2,r2,3828
    f168:	1080258b 	ldhu	r2,150(r2)
    f16c:	10800044 	addi	r2,r2,1
    f170:	1007883a 	mov	r3,r2
    f174:	00800234 	movhi	r2,8
    f178:	1083bd04 	addi	r2,r2,3828
    f17c:	10c0258d 	sth	r3,150(r2)
  snmp_inc_tcpinerrs();
  pbuf_free(p);
    f180:	e13ffe17 	ldw	r4,-8(fp)
    f184:	000aa340 	call	aa34 <pbuf_free>
    f188:	00000106 	br	f190 <tcp_input+0xd04>
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
    f18c:	0001883a 	nop
dropped:
  TCP_STATS_INC(tcp.drop);
  snmp_inc_tcpinerrs();
  pbuf_free(p);
}
    f190:	e037883a 	mov	sp,fp
    f194:	dfc00117 	ldw	ra,4(sp)
    f198:	df000017 	ldw	fp,0(sp)
    f19c:	dec00204 	addi	sp,sp,8
    f1a0:	f800283a 	ret

0000f1a4 <tcp_listen_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
    f1a4:	defff904 	addi	sp,sp,-28
    f1a8:	dfc00615 	stw	ra,24(sp)
    f1ac:	df000515 	stw	fp,20(sp)
    f1b0:	df000504 	addi	fp,sp,20
    f1b4:	e13fff15 	stw	r4,-4(fp)
  struct tcp_pcb *npcb;
  err_t rc;

  if (flags & TCP_RST) {
    f1b8:	d0a8c603 	ldbu	r2,-23784(gp)
    f1bc:	10803fcc 	andi	r2,r2,255
    f1c0:	1080010c 	andi	r2,r2,4
    f1c4:	10000226 	beq	r2,zero,f1d0 <tcp_listen_input+0x2c>
    /* An incoming RST should be ignored. Return. */
    return ERR_OK;
    f1c8:	0005883a 	mov	r2,zero
    f1cc:	00009406 	br	f420 <tcp_listen_input+0x27c>
  }

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    f1d0:	d0a8c603 	ldbu	r2,-23784(gp)
    f1d4:	10803fcc 	andi	r2,r2,255
    f1d8:	1080040c 	andi	r2,r2,16
    f1dc:	10001526 	beq	r2,zero,f234 <tcp_listen_input+0x90>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
    f1e0:	d0e8c517 	ldw	r3,-23788(gp)
    f1e4:	d0a8c68b 	ldhu	r2,-23782(gp)
    f1e8:	113fffcc 	andi	r4,r2,65535
    f1ec:	d0a8c417 	ldw	r2,-23792(gp)
    f1f0:	2085883a 	add	r2,r4,r2
      ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    f1f4:	d128c217 	ldw	r4,-23800(gp)
    f1f8:	2100008b 	ldhu	r4,2(r4)
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
    f1fc:	217fffcc 	andi	r5,r4,65535
      ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    f200:	d128c217 	ldw	r4,-23800(gp)
    f204:	2100000b 	ldhu	r4,0(r4)
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
    f208:	213fffcc 	andi	r4,r4,65535
    f20c:	d9400015 	stw	r5,0(sp)
    f210:	d9000115 	stw	r4,4(sp)
    f214:	1809883a 	mov	r4,r3
    f218:	100b883a 	mov	r5,r2
    f21c:	018000f4 	movhi	r6,3
    f220:	319e2104 	addi	r6,r6,30852
    f224:	01c000f4 	movhi	r7,3
    f228:	39de1f04 	addi	r7,r7,30844
    f22c:	00146680 	call	14668 <tcp_rst>
    f230:	00007a06 	br	f41c <tcp_listen_input+0x278>
      ip_current_src_addr(), tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
    f234:	d0a8c603 	ldbu	r2,-23784(gp)
    f238:	10803fcc 	andi	r2,r2,255
    f23c:	1080008c 	andi	r2,r2,2
    f240:	10007626 	beq	r2,zero,f41c <tcp_listen_input+0x278>
    if (pcb->accepts_pending >= pcb->backlog) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: listen backlog exceeded for port %"U16_F"\n", tcphdr->dest));
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
    f244:	e0bfff17 	ldw	r2,-4(fp)
    f248:	10800703 	ldbu	r2,28(r2)
    f24c:	10803fcc 	andi	r2,r2,255
    f250:	1009883a 	mov	r4,r2
    f254:	000dcdc0 	call	dcdc <tcp_alloc>
    f258:	e0bffd15 	stw	r2,-12(fp)
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
    f25c:	e0bffd17 	ldw	r2,-12(fp)
    f260:	10000a1e 	bne	r2,zero,f28c <tcp_listen_input+0xe8>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
      TCP_STATS_INC(tcp.memerr);
    f264:	00800234 	movhi	r2,8
    f268:	1083bd04 	addi	r2,r2,3828
    f26c:	1080270b 	ldhu	r2,156(r2)
    f270:	10800044 	addi	r2,r2,1
    f274:	1007883a 	mov	r3,r2
    f278:	00800234 	movhi	r2,8
    f27c:	1083bd04 	addi	r2,r2,3828
    f280:	10c0270d 	sth	r3,156(r2)
      return ERR_MEM;
    f284:	00bfffc4 	movi	r2,-1
    f288:	00006506 	br	f420 <tcp_listen_input+0x27c>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    f28c:	008000f4 	movhi	r2,3
    f290:	109e2104 	addi	r2,r2,30852
    f294:	10c00017 	ldw	r3,0(r2)
    f298:	e0bffd17 	ldw	r2,-12(fp)
    f29c:	10c00015 	stw	r3,0(r2)
    npcb->local_port = pcb->local_port;
    f2a0:	e0bfff17 	ldw	r2,-4(fp)
    f2a4:	10c0078b 	ldhu	r3,30(r2)
    f2a8:	e0bffd17 	ldw	r2,-12(fp)
    f2ac:	10c0078d 	sth	r3,30(r2)
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    f2b0:	008000f4 	movhi	r2,3
    f2b4:	109e1f04 	addi	r2,r2,30844
    f2b8:	10c00017 	ldw	r3,0(r2)
    f2bc:	e0bffd17 	ldw	r2,-12(fp)
    f2c0:	10c00115 	stw	r3,4(r2)
    npcb->remote_port = tcphdr->src;
    f2c4:	d0a8c217 	ldw	r2,-23800(gp)
    f2c8:	10c0000b 	ldhu	r3,0(r2)
    f2cc:	e0bffd17 	ldw	r2,-12(fp)
    f2d0:	10c0080d 	sth	r3,32(r2)
    npcb->state = SYN_RCVD;
    f2d4:	e0bffd17 	ldw	r2,-12(fp)
    f2d8:	00c000c4 	movi	r3,3
    f2dc:	10c00615 	stw	r3,24(r2)
    npcb->rcv_nxt = seqno + 1;
    f2e0:	d0a8c417 	ldw	r2,-23792(gp)
    f2e4:	10c00044 	addi	r3,r2,1
    f2e8:	e0bffd17 	ldw	r2,-12(fp)
    f2ec:	10c00b15 	stw	r3,44(r2)
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
    f2f0:	e0bffd17 	ldw	r2,-12(fp)
    f2f4:	10c00b17 	ldw	r3,44(r2)
    f2f8:	e0bffd17 	ldw	r2,-12(fp)
    f2fc:	10c00d15 	stw	r3,52(r2)
    npcb->snd_wnd = tcphdr->wnd;
    f300:	d0a8c217 	ldw	r2,-23800(gp)
    f304:	10c0038b 	ldhu	r3,14(r2)
    f308:	e0bffd17 	ldw	r2,-12(fp)
    f30c:	10c0190d 	sth	r3,100(r2)
    npcb->snd_wnd_max = tcphdr->wnd;
    f310:	d0a8c217 	ldw	r2,-23800(gp)
    f314:	10c0038b 	ldhu	r3,14(r2)
    f318:	e0bffd17 	ldw	r2,-12(fp)
    f31c:	10c0198d 	sth	r3,102(r2)
    npcb->ssthresh = npcb->snd_wnd;
    f320:	e0bffd17 	ldw	r2,-12(fp)
    f324:	10c0190b 	ldhu	r3,100(r2)
    f328:	e0bffd17 	ldw	r2,-12(fp)
    f32c:	10c0148d 	sth	r3,82(r2)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
    f330:	d0a8c417 	ldw	r2,-23792(gp)
    f334:	10ffffc4 	addi	r3,r2,-1
    f338:	e0bffd17 	ldw	r2,-12(fp)
    f33c:	10c01615 	stw	r3,88(r2)
    npcb->callback_arg = pcb->callback_arg;
    f340:	e0bfff17 	ldw	r2,-4(fp)
    f344:	10c00417 	ldw	r3,16(r2)
    f348:	e0bffd17 	ldw	r2,-12(fp)
    f34c:	10c00415 	stw	r3,16(r2)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
    f350:	e0bfff17 	ldw	r2,-4(fp)
    f354:	10c00517 	ldw	r3,20(r2)
    f358:	e0bffd17 	ldw	r2,-12(fp)
    f35c:	10c00515 	stw	r3,20(r2)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & SOF_INHERITED;
    f360:	e0bfff17 	ldw	r2,-4(fp)
    f364:	10c00203 	ldbu	r3,8(r2)
    f368:	00bfe304 	movi	r2,-116
    f36c:	1884703a 	and	r2,r3,r2
    f370:	1007883a 	mov	r3,r2
    f374:	e0bffd17 	ldw	r2,-12(fp)
    f378:	10c00205 	stb	r3,8(r2)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG_ACTIVE(npcb);
    f37c:	008000f4 	movhi	r2,3
    f380:	109e2e04 	addi	r2,r2,30904
    f384:	10c00017 	ldw	r3,0(r2)
    f388:	e0bffd17 	ldw	r2,-12(fp)
    f38c:	10c00315 	stw	r3,12(r2)
    f390:	008000f4 	movhi	r2,3
    f394:	109e2e04 	addi	r2,r2,30904
    f398:	e0fffd17 	ldw	r3,-12(fp)
    f39c:	10c00015 	stw	r3,0(r2)
    f3a0:	0014fd80 	call	14fd8 <tcp_timer_needed>
    f3a4:	008000f4 	movhi	r2,3
    f3a8:	109e2d84 	addi	r2,r2,30902
    f3ac:	00c00044 	movi	r3,1
    f3b0:	10c00005 	stb	r3,0(r2)

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
    f3b4:	e13ffd17 	ldw	r4,-12(fp)
    f3b8:	00121540 	call	12154 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
    f3bc:	e0bffd17 	ldw	r2,-12(fp)
    f3c0:	10800e8b 	ldhu	r2,58(r2)
    f3c4:	10ffffcc 	andi	r3,r2,65535
    f3c8:	e0bffd17 	ldw	r2,-12(fp)
    f3cc:	10800104 	addi	r2,r2,4
    f3d0:	1809883a 	mov	r4,r3
    f3d4:	100b883a 	mov	r5,r2
    f3d8:	000e3cc0 	call	e3cc <tcp_eff_send_mss>
    f3dc:	e0fffd17 	ldw	r3,-12(fp)
    f3e0:	18800e8d 	sth	r2,58(r3)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Send a SYN|ACK together with the MSS option. */
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
    f3e4:	e13ffd17 	ldw	r4,-12(fp)
    f3e8:	01400484 	movi	r5,18
    f3ec:	00135100 	call	13510 <tcp_enqueue_flags>
    f3f0:	e0bffe05 	stb	r2,-8(fp)
    if (rc != ERR_OK) {
    f3f4:	e0bffe07 	ldb	r2,-8(fp)
    f3f8:	10000526 	beq	r2,zero,f410 <tcp_listen_input+0x26c>
      tcp_abandon(npcb, 0);
    f3fc:	e13ffd17 	ldw	r4,-12(fp)
    f400:	000b883a 	mov	r5,zero
    f404:	000c3980 	call	c398 <tcp_abandon>
      return rc;
    f408:	e0bffe03 	ldbu	r2,-8(fp)
    f40c:	00000406 	br	f420 <tcp_listen_input+0x27c>
    }
    return tcp_output(npcb);
    f410:	e13ffd17 	ldw	r4,-12(fp)
    f414:	0013a740 	call	13a74 <tcp_output>
    f418:	00000106 	br	f420 <tcp_listen_input+0x27c>
  }
  return ERR_OK;
    f41c:	0005883a 	mov	r2,zero
}
    f420:	e037883a 	mov	sp,fp
    f424:	dfc00117 	ldw	ra,4(sp)
    f428:	df000017 	ldw	fp,0(sp)
    f42c:	dec00204 	addi	sp,sp,8
    f430:	f800283a 	ret

0000f434 <tcp_timewait_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
    f434:	defffb04 	addi	sp,sp,-20
    f438:	dfc00415 	stw	ra,16(sp)
    f43c:	df000315 	stw	fp,12(sp)
    f440:	df000304 	addi	fp,sp,12
    f444:	e13fff15 	stw	r4,-4(fp)
  /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
  /* RFC 793 3.9 Event Processing - Segment Arrives:
   * - first check sequence number - we skip that one in TIME_WAIT (always
   *   acceptable since we only send ACKs)
   * - second check the RST bit (... return) */
  if (flags & TCP_RST)  {
    f448:	d0a8c603 	ldbu	r2,-23784(gp)
    f44c:	10803fcc 	andi	r2,r2,255
    f450:	1080010c 	andi	r2,r2,4
    f454:	10000226 	beq	r2,zero,f460 <tcp_timewait_input+0x2c>
    return ERR_OK;
    f458:	0005883a 	mov	r2,zero
    f45c:	00003e06 	br	f558 <tcp_timewait_input+0x124>
  }
  /* - fourth, check the SYN bit, */
  if (flags & TCP_SYN) {
    f460:	d0a8c603 	ldbu	r2,-23784(gp)
    f464:	10803fcc 	andi	r2,r2,255
    f468:	1080008c 	andi	r2,r2,2
    f46c:	10002426 	beq	r2,zero,f500 <tcp_timewait_input+0xcc>
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
    f470:	d0e8c417 	ldw	r3,-23792(gp)
    f474:	e0bfff17 	ldw	r2,-4(fp)
    f478:	10800b17 	ldw	r2,44(r2)
    f47c:	1885c83a 	sub	r2,r3,r2
    f480:	10002816 	blt	r2,zero,f524 <tcp_timewait_input+0xf0>
    f484:	d0e8c417 	ldw	r3,-23792(gp)
    f488:	e0bfff17 	ldw	r2,-4(fp)
    f48c:	11000b17 	ldw	r4,44(r2)
    f490:	e0bfff17 	ldw	r2,-4(fp)
    f494:	10800c0b 	ldhu	r2,48(r2)
    f498:	10bfffcc 	andi	r2,r2,65535
    f49c:	2085883a 	add	r2,r4,r2
    f4a0:	1885c83a 	sub	r2,r3,r2
    f4a4:	00801f16 	blt	zero,r2,f524 <tcp_timewait_input+0xf0>
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
    f4a8:	d0e8c517 	ldw	r3,-23788(gp)
    f4ac:	d0a8c68b 	ldhu	r2,-23782(gp)
    f4b0:	113fffcc 	andi	r4,r2,65535
    f4b4:	d0a8c417 	ldw	r2,-23792(gp)
    f4b8:	2085883a 	add	r2,r4,r2
        tcphdr->dest, tcphdr->src);
    f4bc:	d128c217 	ldw	r4,-23800(gp)
    f4c0:	2100008b 	ldhu	r4,2(r4)
  if (flags & TCP_SYN) {
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
    f4c4:	217fffcc 	andi	r5,r4,65535
        tcphdr->dest, tcphdr->src);
    f4c8:	d128c217 	ldw	r4,-23800(gp)
    f4cc:	2100000b 	ldhu	r4,0(r4)
  if (flags & TCP_SYN) {
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
    f4d0:	213fffcc 	andi	r4,r4,65535
    f4d4:	d9400015 	stw	r5,0(sp)
    f4d8:	d9000115 	stw	r4,4(sp)
    f4dc:	1809883a 	mov	r4,r3
    f4e0:	100b883a 	mov	r5,r2
    f4e4:	018000f4 	movhi	r6,3
    f4e8:	319e2104 	addi	r6,r6,30852
    f4ec:	01c000f4 	movhi	r7,3
    f4f0:	39de1f04 	addi	r7,r7,30844
    f4f4:	00146680 	call	14668 <tcp_rst>
        tcphdr->dest, tcphdr->src);
      return ERR_OK;
    f4f8:	0005883a 	mov	r2,zero
    f4fc:	00001606 	br	f558 <tcp_timewait_input+0x124>
    }
  } else if (flags & TCP_FIN) {
    f500:	d0a8c603 	ldbu	r2,-23784(gp)
    f504:	10803fcc 	andi	r2,r2,255
    f508:	1080004c 	andi	r2,r2,1
    f50c:	10000526 	beq	r2,zero,f524 <tcp_timewait_input+0xf0>
    /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
         Restart the 2 MSL time-wait timeout.*/
    pcb->tmr = tcp_ticks;
    f510:	008000f4 	movhi	r2,3
    f514:	109e2f04 	addi	r2,r2,30908
    f518:	10c00017 	ldw	r3,0(r2)
    f51c:	e0bfff17 	ldw	r2,-4(fp)
    f520:	10c00a15 	stw	r3,40(r2)
  }

  if ((tcplen > 0))  {
    f524:	d0a8c68b 	ldhu	r2,-23782(gp)
    f528:	10bfffcc 	andi	r2,r2,65535
    f52c:	10000926 	beq	r2,zero,f554 <tcp_timewait_input+0x120>
    /* Acknowledge data, FIN or out-of-window SYN */
    pcb->flags |= TF_ACK_NOW;
    f530:	e0bfff17 	ldw	r2,-4(fp)
    f534:	10800883 	ldbu	r2,34(r2)
    f538:	10800094 	ori	r2,r2,2
    f53c:	1007883a 	mov	r3,r2
    f540:	e0bfff17 	ldw	r2,-4(fp)
    f544:	10c00885 	stb	r3,34(r2)
    return tcp_output(pcb);
    f548:	e13fff17 	ldw	r4,-4(fp)
    f54c:	0013a740 	call	13a74 <tcp_output>
    f550:	00000106 	br	f558 <tcp_timewait_input+0x124>
  }
  return ERR_OK;
    f554:	0005883a 	mov	r2,zero
}
    f558:	e037883a 	mov	sp,fp
    f55c:	dfc00117 	ldw	ra,4(sp)
    f560:	df000017 	ldw	fp,0(sp)
    f564:	dec00204 	addi	sp,sp,8
    f568:	f800283a 	ret

0000f56c <tcp_process>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
    f56c:	defff804 	addi	sp,sp,-32
    f570:	dfc00715 	stw	ra,28(sp)
    f574:	df000615 	stw	fp,24(sp)
    f578:	df000604 	addi	fp,sp,24
    f57c:	e13fff15 	stw	r4,-4(fp)
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
    f580:	e03ffc05 	stb	zero,-16(fp)
  err_t err;

  err = ERR_OK;
    f584:	e03ffc45 	stb	zero,-15(fp)

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
    f588:	d0a8c603 	ldbu	r2,-23784(gp)
    f58c:	10803fcc 	andi	r2,r2,255
    f590:	1080010c 	andi	r2,r2,4
    f594:	10003726 	beq	r2,zero,f674 <tcp_process+0x108>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
    f598:	e0bfff17 	ldw	r2,-4(fp)
    f59c:	10800617 	ldw	r2,24(r2)
    f5a0:	10800098 	cmpnei	r2,r2,2
    f5a4:	1000071e 	bne	r2,zero,f5c4 <tcp_process+0x58>
      if (ackno == pcb->snd_nxt) {
    f5a8:	e0bfff17 	ldw	r2,-4(fp)
    f5ac:	10c01517 	ldw	r3,84(r2)
    f5b0:	d0a8c517 	ldw	r2,-23788(gp)
    f5b4:	1880131e 	bne	r3,r2,f604 <tcp_process+0x98>
        acceptable = 1;
    f5b8:	00800044 	movi	r2,1
    f5bc:	e0bffc05 	stb	r2,-16(fp)
    f5c0:	00001006 	br	f604 <tcp_process+0x98>
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
    f5c4:	d0e8c417 	ldw	r3,-23792(gp)
    f5c8:	e0bfff17 	ldw	r2,-4(fp)
    f5cc:	10800b17 	ldw	r2,44(r2)
    f5d0:	1885c83a 	sub	r2,r3,r2
    f5d4:	10000b16 	blt	r2,zero,f604 <tcp_process+0x98>
    f5d8:	d0e8c417 	ldw	r3,-23792(gp)
    f5dc:	e0bfff17 	ldw	r2,-4(fp)
    f5e0:	11000b17 	ldw	r4,44(r2)
    f5e4:	e0bfff17 	ldw	r2,-4(fp)
    f5e8:	10800c0b 	ldhu	r2,48(r2)
    f5ec:	10bfffcc 	andi	r2,r2,65535
    f5f0:	2085883a 	add	r2,r4,r2
    f5f4:	1885c83a 	sub	r2,r3,r2
    f5f8:	00800216 	blt	zero,r2,f604 <tcp_process+0x98>
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
    f5fc:	00800044 	movi	r2,1
    f600:	e0bffc05 	stb	r2,-16(fp)
      }
    }

    if (acceptable) {
    f604:	e0bffc03 	ldbu	r2,-16(fp)
    f608:	10001826 	beq	r2,zero,f66c <tcp_process+0x100>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
    f60c:	e0bfff17 	ldw	r2,-4(fp)
    f610:	10800617 	ldw	r2,24(r2)
    f614:	1000091e 	bne	r2,zero,f63c <tcp_process+0xd0>
    f618:	010000f4 	movhi	r4,3
    f61c:	2101fd04 	addi	r4,r4,2036
    f620:	014000f4 	movhi	r5,3
    f624:	29425504 	addi	r5,r5,2388
    f628:	018095c4 	movi	r6,599
    f62c:	01c000f4 	movhi	r7,3
    f630:	39c21104 	addi	r7,r7,2116
    f634:	00193f00 	call	193f0 <printf>
    f638:	003fff06 	br	f638 <tcp_process+0xcc>
      recv_flags |= TF_RESET;
    f63c:	d0a8c703 	ldbu	r2,-23780(gp)
    f640:	10800214 	ori	r2,r2,8
    f644:	d0a8c705 	stb	r2,-23780(gp)
      pcb->flags &= ~TF_ACK_DELAY;
    f648:	e0bfff17 	ldw	r2,-4(fp)
    f64c:	10c00883 	ldbu	r3,34(r2)
    f650:	00bfff84 	movi	r2,-2
    f654:	1884703a 	and	r2,r3,r2
    f658:	1007883a 	mov	r3,r2
    f65c:	e0bfff17 	ldw	r2,-4(fp)
    f660:	10c00885 	stb	r3,34(r2)
      return ERR_RST;
    f664:	00bffd44 	movi	r2,-11
    f668:	0002b506 	br	10140 <tcp_process+0xbd4>
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      return ERR_OK;
    f66c:	0005883a 	mov	r2,zero
    f670:	0002b306 	br	10140 <tcp_process+0xbd4>
    }
  }

  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) { 
    f674:	d0a8c603 	ldbu	r2,-23784(gp)
    f678:	10803fcc 	andi	r2,r2,255
    f67c:	1080008c 	andi	r2,r2,2
    f680:	10001026 	beq	r2,zero,f6c4 <tcp_process+0x158>
    f684:	e0bfff17 	ldw	r2,-4(fp)
    f688:	10800617 	ldw	r2,24(r2)
    f68c:	108000a0 	cmpeqi	r2,r2,2
    f690:	10000c1e 	bne	r2,zero,f6c4 <tcp_process+0x158>
    f694:	e0bfff17 	ldw	r2,-4(fp)
    f698:	10800617 	ldw	r2,24(r2)
    f69c:	108000e0 	cmpeqi	r2,r2,3
    f6a0:	1000081e 	bne	r2,zero,f6c4 <tcp_process+0x158>
    /* Cope with new connection attempt after remote end crashed */
    tcp_ack_now(pcb);
    f6a4:	e0bfff17 	ldw	r2,-4(fp)
    f6a8:	10800883 	ldbu	r2,34(r2)
    f6ac:	10800094 	ori	r2,r2,2
    f6b0:	1007883a 	mov	r3,r2
    f6b4:	e0bfff17 	ldw	r2,-4(fp)
    f6b8:	10c00885 	stb	r3,34(r2)
    return ERR_OK;
    f6bc:	0005883a 	mov	r2,zero
    f6c0:	00029f06 	br	10140 <tcp_process+0xbd4>
  }
  
  if ((pcb->flags & TF_RXCLOSED) == 0) {
    f6c4:	e0bfff17 	ldw	r2,-4(fp)
    f6c8:	10800883 	ldbu	r2,34(r2)
    f6cc:	10803fcc 	andi	r2,r2,255
    f6d0:	1080040c 	andi	r2,r2,16
    f6d4:	1000051e 	bne	r2,zero,f6ec <tcp_process+0x180>
    /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
    pcb->tmr = tcp_ticks;
    f6d8:	008000f4 	movhi	r2,3
    f6dc:	109e2f04 	addi	r2,r2,30908
    f6e0:	10c00017 	ldw	r3,0(r2)
    f6e4:	e0bfff17 	ldw	r2,-4(fp)
    f6e8:	10c00a15 	stw	r3,40(r2)
  }
  pcb->keep_cnt_sent = 0;
    f6ec:	e0bfff17 	ldw	r2,-4(fp)
    f6f0:	10002685 	stb	zero,154(r2)

  tcp_parseopt(pcb);
    f6f4:	e13fff17 	ldw	r4,-4(fp)
    f6f8:	00121540 	call	12154 <tcp_parseopt>

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
    f6fc:	e0bfff17 	ldw	r2,-4(fp)
    f700:	10800617 	ldw	r2,24(r2)
    f704:	10c002a8 	cmpgeui	r3,r2,10
    f708:	18027d1e 	bne	r3,zero,10100 <tcp_process+0xb94>
    f70c:	1085883a 	add	r2,r2,r2
    f710:	1087883a 	add	r3,r2,r2
    f714:	00800074 	movhi	r2,1
    f718:	10bdca04 	addi	r2,r2,-2264
    f71c:	1885883a 	add	r2,r3,r2
    f720:	10800017 	ldw	r2,0(r2)
    f724:	1000683a 	jmp	r2
    f728:	00010100 	call	1010 <tse_mac_init+0x36c>
    f72c:	00010100 	call	1010 <tse_mac_init+0x36c>
    f730:	0000f750 	cmplti	zero,zero,989
    f734:	0000fa6c 	andhi	zero,zero,1001
    f738:	0000fc70 	cmpltui	zero,zero,1009
    f73c:	0000fcb0 	cmpltui	zero,zero,1010
    f740:	0000fe60 	cmpeqi	zero,zero,1017
    f744:	0000fc70 	cmpltui	zero,zero,1009
    f748:	0000ff98 	cmpnei	zero,zero,1022
    f74c:	000100c8 	cmpgei	zero,zero,1027
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
    f750:	d0a8c603 	ldbu	r2,-23784(gp)
    f754:	10803fcc 	andi	r2,r2,255
    f758:	1080040c 	andi	r2,r2,16
    f75c:	1000aa26 	beq	r2,zero,fa08 <tcp_process+0x49c>
    f760:	d0a8c603 	ldbu	r2,-23784(gp)
    f764:	10803fcc 	andi	r2,r2,255
    f768:	1080008c 	andi	r2,r2,2
    f76c:	1000a626 	beq	r2,zero,fa08 <tcp_process+0x49c>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
    f770:	e0bfff17 	ldw	r2,-4(fp)
    f774:	10801d17 	ldw	r2,116(r2)
    f778:	10800317 	ldw	r2,12(r2)
    f77c:	10c0010b 	ldhu	r3,4(r2)
    f780:	1080018b 	ldhu	r2,6(r2)
    f784:	1004943a 	slli	r2,r2,16
    f788:	10c4b03a 	or	r2,r2,r3
    f78c:	1006d63a 	srli	r3,r2,24
    f790:	e0bfff17 	ldw	r2,-4(fp)
    f794:	10801d17 	ldw	r2,116(r2)
    f798:	10800317 	ldw	r2,12(r2)
    f79c:	1100010b 	ldhu	r4,4(r2)
    f7a0:	1080018b 	ldhu	r2,6(r2)
    f7a4:	1004943a 	slli	r2,r2,16
    f7a8:	1104b03a 	or	r2,r2,r4
    f7ac:	1004d23a 	srli	r2,r2,8
    f7b0:	10bfc00c 	andi	r2,r2,65280
    f7b4:	1886b03a 	or	r3,r3,r2
    f7b8:	e0bfff17 	ldw	r2,-4(fp)
    f7bc:	10801d17 	ldw	r2,116(r2)
    f7c0:	10800317 	ldw	r2,12(r2)
    f7c4:	1100010b 	ldhu	r4,4(r2)
    f7c8:	1080018b 	ldhu	r2,6(r2)
    f7cc:	1004943a 	slli	r2,r2,16
    f7d0:	1104b03a 	or	r2,r2,r4
    f7d4:	10bfc00c 	andi	r2,r2,65280
    f7d8:	1004923a 	slli	r2,r2,8
    f7dc:	1886b03a 	or	r3,r3,r2
    f7e0:	e0bfff17 	ldw	r2,-4(fp)
    f7e4:	10801d17 	ldw	r2,116(r2)
    f7e8:	10800317 	ldw	r2,12(r2)
    f7ec:	1100010b 	ldhu	r4,4(r2)
    f7f0:	1080018b 	ldhu	r2,6(r2)
    f7f4:	1004943a 	slli	r2,r2,16
    f7f8:	1104b03a 	or	r2,r2,r4
    f7fc:	1004963a 	slli	r2,r2,24
    f800:	1884b03a 	or	r2,r3,r2
    f804:	10c00044 	addi	r3,r2,1
    f808:	d0a8c517 	ldw	r2,-23788(gp)
    f80c:	18807e1e 	bne	r3,r2,fa08 <tcp_process+0x49c>
      pcb->snd_buf++;
    f810:	e0bfff17 	ldw	r2,-4(fp)
    f814:	10801a8b 	ldhu	r2,106(r2)
    f818:	10800044 	addi	r2,r2,1
    f81c:	1007883a 	mov	r3,r2
    f820:	e0bfff17 	ldw	r2,-4(fp)
    f824:	10c01a8d 	sth	r3,106(r2)
      pcb->rcv_nxt = seqno + 1;
    f828:	d0a8c417 	ldw	r2,-23792(gp)
    f82c:	10c00044 	addi	r3,r2,1
    f830:	e0bfff17 	ldw	r2,-4(fp)
    f834:	10c00b15 	stw	r3,44(r2)
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
    f838:	e0bfff17 	ldw	r2,-4(fp)
    f83c:	10c00b17 	ldw	r3,44(r2)
    f840:	e0bfff17 	ldw	r2,-4(fp)
    f844:	10c00d15 	stw	r3,52(r2)
      pcb->lastack = ackno;
    f848:	d0e8c517 	ldw	r3,-23788(gp)
    f84c:	e0bfff17 	ldw	r2,-4(fp)
    f850:	10c01315 	stw	r3,76(r2)
      pcb->snd_wnd = tcphdr->wnd;
    f854:	d0a8c217 	ldw	r2,-23800(gp)
    f858:	10c0038b 	ldhu	r3,14(r2)
    f85c:	e0bfff17 	ldw	r2,-4(fp)
    f860:	10c0190d 	sth	r3,100(r2)
      pcb->snd_wnd_max = tcphdr->wnd;
    f864:	d0a8c217 	ldw	r2,-23800(gp)
    f868:	10c0038b 	ldhu	r3,14(r2)
    f86c:	e0bfff17 	ldw	r2,-4(fp)
    f870:	10c0198d 	sth	r3,102(r2)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
    f874:	d0a8c417 	ldw	r2,-23792(gp)
    f878:	10ffffc4 	addi	r3,r2,-1
    f87c:	e0bfff17 	ldw	r2,-4(fp)
    f880:	10c01615 	stw	r3,88(r2)
      pcb->state = ESTABLISHED;
    f884:	e0bfff17 	ldw	r2,-4(fp)
    f888:	00c00104 	movi	r3,4
    f88c:	10c00615 	stw	r3,24(r2)

#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
    f890:	e0bfff17 	ldw	r2,-4(fp)
    f894:	10800e8b 	ldhu	r2,58(r2)
    f898:	10ffffcc 	andi	r3,r2,65535
    f89c:	e0bfff17 	ldw	r2,-4(fp)
    f8a0:	10800104 	addi	r2,r2,4
    f8a4:	1809883a 	mov	r4,r3
    f8a8:	100b883a 	mov	r5,r2
    f8ac:	000e3cc0 	call	e3cc <tcp_eff_send_mss>
    f8b0:	e0ffff17 	ldw	r3,-4(fp)
    f8b4:	18800e8d 	sth	r2,58(r3)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
    f8b8:	e0bfff17 	ldw	r2,-4(fp)
    f8bc:	10800e8b 	ldhu	r2,58(r2)
    f8c0:	108002a4 	muli	r2,r2,10
    f8c4:	1007883a 	mov	r3,r2
    f8c8:	e0bfff17 	ldw	r2,-4(fp)
    f8cc:	10c0148d 	sth	r3,82(r2)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
    f8d0:	e0bfff17 	ldw	r2,-4(fp)
    f8d4:	1080140b 	ldhu	r2,80(r2)
    f8d8:	10bfffcc 	andi	r2,r2,65535
    f8dc:	10800058 	cmpnei	r2,r2,1
    f8e0:	1000041e 	bne	r2,zero,f8f4 <tcp_process+0x388>
    f8e4:	e0bfff17 	ldw	r2,-4(fp)
    f8e8:	10800e8b 	ldhu	r2,58(r2)
    f8ec:	1085883a 	add	r2,r2,r2
    f8f0:	00000206 	br	f8fc <tcp_process+0x390>
    f8f4:	e0bfff17 	ldw	r2,-4(fp)
    f8f8:	10800e8b 	ldhu	r2,58(r2)
    f8fc:	e0ffff17 	ldw	r3,-4(fp)
    f900:	1880140d 	sth	r2,80(r3)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
    f904:	e0bfff17 	ldw	r2,-4(fp)
    f908:	10801b0b 	ldhu	r2,108(r2)
    f90c:	10bfffcc 	andi	r2,r2,65535
    f910:	1000091e 	bne	r2,zero,f938 <tcp_process+0x3cc>
    f914:	010000f4 	movhi	r4,3
    f918:	2101fd04 	addi	r4,r4,2036
    f91c:	014000f4 	movhi	r5,3
    f920:	29425d04 	addi	r5,r5,2420
    f924:	0180a304 	movi	r6,652
    f928:	01c000f4 	movhi	r7,3
    f92c:	39c21104 	addi	r7,r7,2116
    f930:	00193f00 	call	193f0 <printf>
    f934:	003fff06 	br	f934 <tcp_process+0x3c8>
      --pcb->snd_queuelen;
    f938:	e0bfff17 	ldw	r2,-4(fp)
    f93c:	10801b0b 	ldhu	r2,108(r2)
    f940:	10bfffc4 	addi	r2,r2,-1
    f944:	1007883a 	mov	r3,r2
    f948:	e0bfff17 	ldw	r2,-4(fp)
    f94c:	10c01b0d 	sth	r3,108(r2)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
    f950:	e0bfff17 	ldw	r2,-4(fp)
    f954:	10801d17 	ldw	r2,116(r2)
    f958:	e0bffd15 	stw	r2,-12(fp)
      pcb->unacked = rseg->next;
    f95c:	e0bffd17 	ldw	r2,-12(fp)
    f960:	10c00017 	ldw	r3,0(r2)
    f964:	e0bfff17 	ldw	r2,-4(fp)
    f968:	10c01d15 	stw	r3,116(r2)
      tcp_seg_free(rseg);
    f96c:	e13ffd17 	ldw	r4,-12(fp)
    f970:	000da080 	call	da08 <tcp_seg_free>

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
    f974:	e0bfff17 	ldw	r2,-4(fp)
    f978:	10801d17 	ldw	r2,116(r2)
    f97c:	1000041e 	bne	r2,zero,f990 <tcp_process+0x424>
        pcb->rtime = -1;
    f980:	e0bfff17 	ldw	r2,-4(fp)
    f984:	00ffffc4 	movi	r3,-1
    f988:	10c00e0d 	sth	r3,56(r2)
    f98c:	00000406 	br	f9a0 <tcp_process+0x434>
      else {
        pcb->rtime = 0;
    f990:	e0bfff17 	ldw	r2,-4(fp)
    f994:	10000e0d 	sth	zero,56(r2)
        pcb->nrtx = 0;
    f998:	e0bfff17 	ldw	r2,-4(fp)
    f99c:	10001285 	stb	zero,74(r2)
      }

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
    f9a0:	e0bfff17 	ldw	r2,-4(fp)
    f9a4:	10802217 	ldw	r2,136(r2)
    f9a8:	10000a26 	beq	r2,zero,f9d4 <tcp_process+0x468>
    f9ac:	e0bfff17 	ldw	r2,-4(fp)
    f9b0:	10c02217 	ldw	r3,136(r2)
    f9b4:	e0bfff17 	ldw	r2,-4(fp)
    f9b8:	10800417 	ldw	r2,16(r2)
    f9bc:	1009883a 	mov	r4,r2
    f9c0:	e17fff17 	ldw	r5,-4(fp)
    f9c4:	000d883a 	mov	r6,zero
    f9c8:	183ee83a 	callr	r3
    f9cc:	e0bffc45 	stb	r2,-15(fp)
    f9d0:	00000106 	br	f9d8 <tcp_process+0x46c>
    f9d4:	e03ffc45 	stb	zero,-15(fp)
      if (err == ERR_ABRT) {
    f9d8:	e0bffc47 	ldb	r2,-15(fp)
    f9dc:	10bffd98 	cmpnei	r2,r2,-10
    f9e0:	1000021e 	bne	r2,zero,f9ec <tcp_process+0x480>
        return ERR_ABRT;
    f9e4:	00bffd84 	movi	r2,-10
    f9e8:	0001d506 	br	10140 <tcp_process+0xbd4>
      }
      tcp_ack_now(pcb);
    f9ec:	e0bfff17 	ldw	r2,-4(fp)
    f9f0:	10800883 	ldbu	r2,34(r2)
    f9f4:	10800094 	ori	r2,r2,2
    f9f8:	1007883a 	mov	r3,r2
    f9fc:	e0bfff17 	ldw	r2,-4(fp)
    fa00:	10c00885 	stb	r3,34(r2)
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
    }
    break;
    fa04:	0001c006 	br	10108 <tcp_process+0xb9c>
        return ERR_ABRT;
      }
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
    fa08:	d0a8c603 	ldbu	r2,-23784(gp)
    fa0c:	10803fcc 	andi	r2,r2,255
    fa10:	1080040c 	andi	r2,r2,16
    fa14:	1001bc26 	beq	r2,zero,10108 <tcp_process+0xb9c>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
    fa18:	d0e8c517 	ldw	r3,-23788(gp)
    fa1c:	d0a8c68b 	ldhu	r2,-23782(gp)
    fa20:	113fffcc 	andi	r4,r2,65535
    fa24:	d0a8c417 	ldw	r2,-23792(gp)
    fa28:	2085883a 	add	r2,r4,r2
        tcphdr->dest, tcphdr->src);
    fa2c:	d128c217 	ldw	r4,-23800(gp)
    fa30:	2100008b 	ldhu	r4,2(r4)
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
    fa34:	217fffcc 	andi	r5,r4,65535
        tcphdr->dest, tcphdr->src);
    fa38:	d128c217 	ldw	r4,-23800(gp)
    fa3c:	2100000b 	ldhu	r4,0(r4)
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
    fa40:	213fffcc 	andi	r4,r4,65535
    fa44:	d9400015 	stw	r5,0(sp)
    fa48:	d9000115 	stw	r4,4(sp)
    fa4c:	1809883a 	mov	r4,r3
    fa50:	100b883a 	mov	r5,r2
    fa54:	018000f4 	movhi	r6,3
    fa58:	319e2104 	addi	r6,r6,30852
    fa5c:	01c000f4 	movhi	r7,3
    fa60:	39de1f04 	addi	r7,r7,30844
    fa64:	00146680 	call	14668 <tcp_rst>
        tcphdr->dest, tcphdr->src);
    }
    break;
    fa68:	0001a706 	br	10108 <tcp_process+0xb9c>
  case SYN_RCVD:
    if (flags & TCP_ACK) {
    fa6c:	d0a8c603 	ldbu	r2,-23784(gp)
    fa70:	10803fcc 	andi	r2,r2,255
    fa74:	1080040c 	andi	r2,r2,16
    fa78:	10007126 	beq	r2,zero,fc40 <tcp_process+0x6d4>
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
    fa7c:	e0bfff17 	ldw	r2,-4(fp)
    fa80:	10801317 	ldw	r2,76(r2)
    fa84:	0086303a 	nor	r3,zero,r2
    fa88:	d0a8c517 	ldw	r2,-23788(gp)
    fa8c:	1885883a 	add	r2,r3,r2
    fa90:	10005416 	blt	r2,zero,fbe4 <tcp_process+0x678>
    fa94:	d0e8c517 	ldw	r3,-23788(gp)
    fa98:	e0bfff17 	ldw	r2,-4(fp)
    fa9c:	10801517 	ldw	r2,84(r2)
    faa0:	1885c83a 	sub	r2,r3,r2
    faa4:	00804f16 	blt	zero,r2,fbe4 <tcp_process+0x678>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
    faa8:	e0bfff17 	ldw	r2,-4(fp)
    faac:	00c00104 	movi	r3,4
    fab0:	10c00615 	stw	r3,24(r2)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
    fab4:	e0bfff17 	ldw	r2,-4(fp)
    fab8:	10800517 	ldw	r2,20(r2)
    fabc:	1000091e 	bne	r2,zero,fae4 <tcp_process+0x578>
    fac0:	010000f4 	movhi	r4,3
    fac4:	2101fd04 	addi	r4,r4,2036
    fac8:	014000f4 	movhi	r5,3
    facc:	29426304 	addi	r5,r5,2444
    fad0:	0180acc4 	movi	r6,691
    fad4:	01c000f4 	movhi	r7,3
    fad8:	39c21104 	addi	r7,r7,2116
    fadc:	00193f00 	call	193f0 <printf>
    fae0:	003fff06 	br	fae0 <tcp_process+0x574>
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
    fae4:	e0bfff17 	ldw	r2,-4(fp)
    fae8:	10800517 	ldw	r2,20(r2)
    faec:	10000a26 	beq	r2,zero,fb18 <tcp_process+0x5ac>
    faf0:	e0bfff17 	ldw	r2,-4(fp)
    faf4:	10c00517 	ldw	r3,20(r2)
    faf8:	e0bfff17 	ldw	r2,-4(fp)
    fafc:	10800417 	ldw	r2,16(r2)
    fb00:	1009883a 	mov	r4,r2
    fb04:	e17fff17 	ldw	r5,-4(fp)
    fb08:	000d883a 	mov	r6,zero
    fb0c:	183ee83a 	callr	r3
    fb10:	e0bffc45 	stb	r2,-15(fp)
    fb14:	00000206 	br	fb20 <tcp_process+0x5b4>
    fb18:	00bffc84 	movi	r2,-14
    fb1c:	e0bffc45 	stb	r2,-15(fp)
        if (err != ERR_OK) {
    fb20:	e0bffc47 	ldb	r2,-15(fp)
    fb24:	10000726 	beq	r2,zero,fb44 <tcp_process+0x5d8>
          /* If the accept function returns with an error, we abort
           * the connection. */
          /* Already aborted? */
          if (err != ERR_ABRT) {
    fb28:	e0bffc47 	ldb	r2,-15(fp)
    fb2c:	10bffda0 	cmpeqi	r2,r2,-10
    fb30:	1000021e 	bne	r2,zero,fb3c <tcp_process+0x5d0>
            tcp_abort(pcb);
    fb34:	e13fff17 	ldw	r4,-4(fp)
    fb38:	000c5280 	call	c528 <tcp_abort>
          }
          return ERR_ABRT;
    fb3c:	00bffd84 	movi	r2,-10
    fb40:	00017f06 	br	10140 <tcp_process+0xbd4>
        }
        old_cwnd = pcb->cwnd;
    fb44:	e0bfff17 	ldw	r2,-4(fp)
    fb48:	1080140b 	ldhu	r2,80(r2)
    fb4c:	e0bffe0d 	sth	r2,-8(fp)
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        tcp_receive(pcb);
    fb50:	e13fff17 	ldw	r4,-4(fp)
    fb54:	00103280 	call	10328 <tcp_receive>

        /* Prevent ACK for SYN to generate a sent event */
        if (pcb->acked != 0) {
    fb58:	e0bfff17 	ldw	r2,-4(fp)
    fb5c:	10801a0b 	ldhu	r2,104(r2)
    fb60:	10bfffcc 	andi	r2,r2,65535
    fb64:	10000626 	beq	r2,zero,fb80 <tcp_process+0x614>
          pcb->acked--;
    fb68:	e0bfff17 	ldw	r2,-4(fp)
    fb6c:	10801a0b 	ldhu	r2,104(r2)
    fb70:	10bfffc4 	addi	r2,r2,-1
    fb74:	1007883a 	mov	r3,r2
    fb78:	e0bfff17 	ldw	r2,-4(fp)
    fb7c:	10c01a0d 	sth	r3,104(r2)
        }

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
    fb80:	e0bffe0b 	ldhu	r2,-8(fp)
    fb84:	10800058 	cmpnei	r2,r2,1
    fb88:	1000041e 	bne	r2,zero,fb9c <tcp_process+0x630>
    fb8c:	e0bfff17 	ldw	r2,-4(fp)
    fb90:	10800e8b 	ldhu	r2,58(r2)
    fb94:	1085883a 	add	r2,r2,r2
    fb98:	00000206 	br	fba4 <tcp_process+0x638>
    fb9c:	e0bfff17 	ldw	r2,-4(fp)
    fba0:	10800e8b 	ldhu	r2,58(r2)
    fba4:	e0ffff17 	ldw	r3,-4(fp)
    fba8:	1880140d 	sth	r2,80(r3)

        if (recv_flags & TF_GOT_FIN) {
    fbac:	d0a8c703 	ldbu	r2,-23780(gp)
    fbb0:	10803fcc 	andi	r2,r2,255
    fbb4:	1080080c 	andi	r2,r2,32
    fbb8:	10001f26 	beq	r2,zero,fc38 <tcp_process+0x6cc>
          tcp_ack_now(pcb);
    fbbc:	e0bfff17 	ldw	r2,-4(fp)
    fbc0:	10800883 	ldbu	r2,34(r2)
    fbc4:	10800094 	ori	r2,r2,2
    fbc8:	1007883a 	mov	r3,r2
    fbcc:	e0bfff17 	ldw	r2,-4(fp)
    fbd0:	10c00885 	stb	r3,34(r2)
          pcb->state = CLOSE_WAIT;
    fbd4:	e0bfff17 	ldw	r2,-4(fp)
    fbd8:	00c001c4 	movi	r3,7
    fbdc:	10c00615 	stw	r3,24(r2)
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
    fbe0:	00001506 	br	fc38 <tcp_process+0x6cc>
          tcp_ack_now(pcb);
          pcb->state = CLOSE_WAIT;
        }
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
    fbe4:	d0e8c517 	ldw	r3,-23788(gp)
    fbe8:	d0a8c68b 	ldhu	r2,-23782(gp)
    fbec:	113fffcc 	andi	r4,r2,65535
    fbf0:	d0a8c417 	ldw	r2,-23792(gp)
    fbf4:	2085883a 	add	r2,r4,r2
                tcphdr->dest, tcphdr->src);
    fbf8:	d128c217 	ldw	r4,-23800(gp)
    fbfc:	2100008b 	ldhu	r4,2(r4)
          tcp_ack_now(pcb);
          pcb->state = CLOSE_WAIT;
        }
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
    fc00:	217fffcc 	andi	r5,r4,65535
                tcphdr->dest, tcphdr->src);
    fc04:	d128c217 	ldw	r4,-23800(gp)
    fc08:	2100000b 	ldhu	r4,0(r4)
          tcp_ack_now(pcb);
          pcb->state = CLOSE_WAIT;
        }
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
    fc0c:	213fffcc 	andi	r4,r4,65535
    fc10:	d9400015 	stw	r5,0(sp)
    fc14:	d9000115 	stw	r4,4(sp)
    fc18:	1809883a 	mov	r4,r3
    fc1c:	100b883a 	mov	r5,r2
    fc20:	018000f4 	movhi	r6,3
    fc24:	319e2104 	addi	r6,r6,30852
    fc28:	01c000f4 	movhi	r7,3
    fc2c:	39de1f04 	addi	r7,r7,30844
    fc30:	00146680 	call	14668 <tcp_rst>
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    }
    break;
    fc34:	00013606 	br	10110 <tcp_process+0xba4>
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
    fc38:	0001883a 	nop
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    }
    break;
    fc3c:	00013406 	br	10110 <tcp_process+0xba4>
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
                tcphdr->dest, tcphdr->src);
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
    fc40:	d0a8c603 	ldbu	r2,-23784(gp)
    fc44:	10803fcc 	andi	r2,r2,255
    fc48:	1080008c 	andi	r2,r2,2
    fc4c:	10013026 	beq	r2,zero,10110 <tcp_process+0xba4>
    fc50:	e0bfff17 	ldw	r2,-4(fp)
    fc54:	10800b17 	ldw	r2,44(r2)
    fc58:	10ffffc4 	addi	r3,r2,-1
    fc5c:	d0a8c417 	ldw	r2,-23792(gp)
    fc60:	18812b1e 	bne	r3,r2,10110 <tcp_process+0xba4>
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    fc64:	e13fff17 	ldw	r4,-4(fp)
    fc68:	001496c0 	call	1496c <tcp_rexmit>
    }
    break;
    fc6c:	00012806 	br	10110 <tcp_process+0xba4>
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    tcp_receive(pcb);
    fc70:	e13fff17 	ldw	r4,-4(fp)
    fc74:	00103280 	call	10328 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) { /* passive close */
    fc78:	d0a8c703 	ldbu	r2,-23780(gp)
    fc7c:	10803fcc 	andi	r2,r2,255
    fc80:	1080080c 	andi	r2,r2,32
    fc84:	10012426 	beq	r2,zero,10118 <tcp_process+0xbac>
      tcp_ack_now(pcb);
    fc88:	e0bfff17 	ldw	r2,-4(fp)
    fc8c:	10800883 	ldbu	r2,34(r2)
    fc90:	10800094 	ori	r2,r2,2
    fc94:	1007883a 	mov	r3,r2
    fc98:	e0bfff17 	ldw	r2,-4(fp)
    fc9c:	10c00885 	stb	r3,34(r2)
      pcb->state = CLOSE_WAIT;
    fca0:	e0bfff17 	ldw	r2,-4(fp)
    fca4:	00c001c4 	movi	r3,7
    fca8:	10c00615 	stw	r3,24(r2)
    }
    break;
    fcac:	00011a06 	br	10118 <tcp_process+0xbac>
  case FIN_WAIT_1:
    tcp_receive(pcb);
    fcb0:	e13fff17 	ldw	r4,-4(fp)
    fcb4:	00103280 	call	10328 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
    fcb8:	d0a8c703 	ldbu	r2,-23780(gp)
    fcbc:	10803fcc 	andi	r2,r2,255
    fcc0:	1080080c 	andi	r2,r2,32
    fcc4:	10005a26 	beq	r2,zero,fe30 <tcp_process+0x8c4>
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
    fcc8:	d0a8c603 	ldbu	r2,-23784(gp)
    fccc:	10803fcc 	andi	r2,r2,255
    fcd0:	1080040c 	andi	r2,r2,16
    fcd4:	10004c26 	beq	r2,zero,fe08 <tcp_process+0x89c>
    fcd8:	e0bfff17 	ldw	r2,-4(fp)
    fcdc:	10c01517 	ldw	r3,84(r2)
    fce0:	d0a8c517 	ldw	r2,-23788(gp)
    fce4:	1880481e 	bne	r3,r2,fe08 <tcp_process+0x89c>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
    fce8:	e0bfff17 	ldw	r2,-4(fp)
    fcec:	10800883 	ldbu	r2,34(r2)
    fcf0:	10800094 	ori	r2,r2,2
    fcf4:	1007883a 	mov	r3,r2
    fcf8:	e0bfff17 	ldw	r2,-4(fp)
    fcfc:	10c00885 	stb	r3,34(r2)
        tcp_pcb_purge(pcb);
    fd00:	e13fff17 	ldw	r4,-4(fp)
    fd04:	000e1180 	call	e118 <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
    fd08:	008000f4 	movhi	r2,3
    fd0c:	109e2e04 	addi	r2,r2,30904
    fd10:	10c00017 	ldw	r3,0(r2)
    fd14:	e0bfff17 	ldw	r2,-4(fp)
    fd18:	1880081e 	bne	r3,r2,fd3c <tcp_process+0x7d0>
    fd1c:	008000f4 	movhi	r2,3
    fd20:	109e2e04 	addi	r2,r2,30904
    fd24:	10800017 	ldw	r2,0(r2)
    fd28:	10c00317 	ldw	r3,12(r2)
    fd2c:	008000f4 	movhi	r2,3
    fd30:	109e2e04 	addi	r2,r2,30904
    fd34:	10c00015 	stw	r3,0(r2)
    fd38:	00001f06 	br	fdb8 <tcp_process+0x84c>
    fd3c:	008000f4 	movhi	r2,3
    fd40:	109e2e04 	addi	r2,r2,30904
    fd44:	10c00017 	ldw	r3,0(r2)
    fd48:	008000f4 	movhi	r2,3
    fd4c:	109e3104 	addi	r2,r2,30916
    fd50:	10c00015 	stw	r3,0(r2)
    fd54:	00001406 	br	fda8 <tcp_process+0x83c>
    fd58:	008000f4 	movhi	r2,3
    fd5c:	109e3104 	addi	r2,r2,30916
    fd60:	10800017 	ldw	r2,0(r2)
    fd64:	10c00317 	ldw	r3,12(r2)
    fd68:	e0bfff17 	ldw	r2,-4(fp)
    fd6c:	1880071e 	bne	r3,r2,fd8c <tcp_process+0x820>
    fd70:	008000f4 	movhi	r2,3
    fd74:	109e3104 	addi	r2,r2,30916
    fd78:	10800017 	ldw	r2,0(r2)
    fd7c:	e0ffff17 	ldw	r3,-4(fp)
    fd80:	18c00317 	ldw	r3,12(r3)
    fd84:	10c00315 	stw	r3,12(r2)
    fd88:	00000b06 	br	fdb8 <tcp_process+0x84c>
    fd8c:	008000f4 	movhi	r2,3
    fd90:	109e3104 	addi	r2,r2,30916
    fd94:	10800017 	ldw	r2,0(r2)
    fd98:	10c00317 	ldw	r3,12(r2)
    fd9c:	008000f4 	movhi	r2,3
    fda0:	109e3104 	addi	r2,r2,30916
    fda4:	10c00015 	stw	r3,0(r2)
    fda8:	008000f4 	movhi	r2,3
    fdac:	109e3104 	addi	r2,r2,30916
    fdb0:	10800017 	ldw	r2,0(r2)
    fdb4:	103fe81e 	bne	r2,zero,fd58 <tcp_process+0x7ec>
    fdb8:	e0bfff17 	ldw	r2,-4(fp)
    fdbc:	10000315 	stw	zero,12(r2)
    fdc0:	008000f4 	movhi	r2,3
    fdc4:	109e2d84 	addi	r2,r2,30902
    fdc8:	00c00044 	movi	r3,1
    fdcc:	10c00005 	stb	r3,0(r2)
        pcb->state = TIME_WAIT;
    fdd0:	e0bfff17 	ldw	r2,-4(fp)
    fdd4:	00c00284 	movi	r3,10
    fdd8:	10c00615 	stw	r3,24(r2)
        TCP_REG(&tcp_tw_pcbs, pcb);
    fddc:	008000f4 	movhi	r2,3
    fde0:	109e3304 	addi	r2,r2,30924
    fde4:	10c00017 	ldw	r3,0(r2)
    fde8:	e0bfff17 	ldw	r2,-4(fp)
    fdec:	10c00315 	stw	r3,12(r2)
    fdf0:	008000f4 	movhi	r2,3
    fdf4:	109e3304 	addi	r2,r2,30924
    fdf8:	e0ffff17 	ldw	r3,-4(fp)
    fdfc:	10c00015 	stw	r3,0(r2)
    fe00:	0014fd80 	call	14fd8 <tcp_timer_needed>
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
    fe04:	0000c606 	br	10120 <tcp_process+0xbb4>
        tcp_pcb_purge(pcb);
        TCP_RMV_ACTIVE(pcb);
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
    fe08:	e0bfff17 	ldw	r2,-4(fp)
    fe0c:	10800883 	ldbu	r2,34(r2)
    fe10:	10800094 	ori	r2,r2,2
    fe14:	1007883a 	mov	r3,r2
    fe18:	e0bfff17 	ldw	r2,-4(fp)
    fe1c:	10c00885 	stb	r3,34(r2)
        pcb->state = CLOSING;
    fe20:	e0bfff17 	ldw	r2,-4(fp)
    fe24:	00c00204 	movi	r3,8
    fe28:	10c00615 	stw	r3,24(r2)
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
    fe2c:	0000bc06 	br	10120 <tcp_process+0xbb4>
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
    fe30:	d0a8c603 	ldbu	r2,-23784(gp)
    fe34:	10803fcc 	andi	r2,r2,255
    fe38:	1080040c 	andi	r2,r2,16
    fe3c:	1000b826 	beq	r2,zero,10120 <tcp_process+0xbb4>
    fe40:	e0bfff17 	ldw	r2,-4(fp)
    fe44:	10c01517 	ldw	r3,84(r2)
    fe48:	d0a8c517 	ldw	r2,-23788(gp)
    fe4c:	1880b41e 	bne	r3,r2,10120 <tcp_process+0xbb4>
      pcb->state = FIN_WAIT_2;
    fe50:	e0bfff17 	ldw	r2,-4(fp)
    fe54:	00c00184 	movi	r3,6
    fe58:	10c00615 	stw	r3,24(r2)
    }
    break;
    fe5c:	0000b006 	br	10120 <tcp_process+0xbb4>
  case FIN_WAIT_2:
    tcp_receive(pcb);
    fe60:	e13fff17 	ldw	r4,-4(fp)
    fe64:	00103280 	call	10328 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
    fe68:	d0a8c703 	ldbu	r2,-23780(gp)
    fe6c:	10803fcc 	andi	r2,r2,255
    fe70:	1080080c 	andi	r2,r2,32
    fe74:	1000ac26 	beq	r2,zero,10128 <tcp_process+0xbbc>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
    fe78:	e0bfff17 	ldw	r2,-4(fp)
    fe7c:	10800883 	ldbu	r2,34(r2)
    fe80:	10800094 	ori	r2,r2,2
    fe84:	1007883a 	mov	r3,r2
    fe88:	e0bfff17 	ldw	r2,-4(fp)
    fe8c:	10c00885 	stb	r3,34(r2)
      tcp_pcb_purge(pcb);
    fe90:	e13fff17 	ldw	r4,-4(fp)
    fe94:	000e1180 	call	e118 <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
    fe98:	008000f4 	movhi	r2,3
    fe9c:	109e2e04 	addi	r2,r2,30904
    fea0:	10c00017 	ldw	r3,0(r2)
    fea4:	e0bfff17 	ldw	r2,-4(fp)
    fea8:	1880081e 	bne	r3,r2,fecc <tcp_process+0x960>
    feac:	008000f4 	movhi	r2,3
    feb0:	109e2e04 	addi	r2,r2,30904
    feb4:	10800017 	ldw	r2,0(r2)
    feb8:	10c00317 	ldw	r3,12(r2)
    febc:	008000f4 	movhi	r2,3
    fec0:	109e2e04 	addi	r2,r2,30904
    fec4:	10c00015 	stw	r3,0(r2)
    fec8:	00001f06 	br	ff48 <tcp_process+0x9dc>
    fecc:	008000f4 	movhi	r2,3
    fed0:	109e2e04 	addi	r2,r2,30904
    fed4:	10c00017 	ldw	r3,0(r2)
    fed8:	008000f4 	movhi	r2,3
    fedc:	109e3104 	addi	r2,r2,30916
    fee0:	10c00015 	stw	r3,0(r2)
    fee4:	00001406 	br	ff38 <tcp_process+0x9cc>
    fee8:	008000f4 	movhi	r2,3
    feec:	109e3104 	addi	r2,r2,30916
    fef0:	10800017 	ldw	r2,0(r2)
    fef4:	10c00317 	ldw	r3,12(r2)
    fef8:	e0bfff17 	ldw	r2,-4(fp)
    fefc:	1880071e 	bne	r3,r2,ff1c <tcp_process+0x9b0>
    ff00:	008000f4 	movhi	r2,3
    ff04:	109e3104 	addi	r2,r2,30916
    ff08:	10800017 	ldw	r2,0(r2)
    ff0c:	e0ffff17 	ldw	r3,-4(fp)
    ff10:	18c00317 	ldw	r3,12(r3)
    ff14:	10c00315 	stw	r3,12(r2)
    ff18:	00000b06 	br	ff48 <tcp_process+0x9dc>
    ff1c:	008000f4 	movhi	r2,3
    ff20:	109e3104 	addi	r2,r2,30916
    ff24:	10800017 	ldw	r2,0(r2)
    ff28:	10c00317 	ldw	r3,12(r2)
    ff2c:	008000f4 	movhi	r2,3
    ff30:	109e3104 	addi	r2,r2,30916
    ff34:	10c00015 	stw	r3,0(r2)
    ff38:	008000f4 	movhi	r2,3
    ff3c:	109e3104 	addi	r2,r2,30916
    ff40:	10800017 	ldw	r2,0(r2)
    ff44:	103fe81e 	bne	r2,zero,fee8 <tcp_process+0x97c>
    ff48:	e0bfff17 	ldw	r2,-4(fp)
    ff4c:	10000315 	stw	zero,12(r2)
    ff50:	008000f4 	movhi	r2,3
    ff54:	109e2d84 	addi	r2,r2,30902
    ff58:	00c00044 	movi	r3,1
    ff5c:	10c00005 	stb	r3,0(r2)
      pcb->state = TIME_WAIT;
    ff60:	e0bfff17 	ldw	r2,-4(fp)
    ff64:	00c00284 	movi	r3,10
    ff68:	10c00615 	stw	r3,24(r2)
      TCP_REG(&tcp_tw_pcbs, pcb);
    ff6c:	008000f4 	movhi	r2,3
    ff70:	109e3304 	addi	r2,r2,30924
    ff74:	10c00017 	ldw	r3,0(r2)
    ff78:	e0bfff17 	ldw	r2,-4(fp)
    ff7c:	10c00315 	stw	r3,12(r2)
    ff80:	008000f4 	movhi	r2,3
    ff84:	109e3304 	addi	r2,r2,30924
    ff88:	e0ffff17 	ldw	r3,-4(fp)
    ff8c:	10c00015 	stw	r3,0(r2)
    ff90:	0014fd80 	call	14fd8 <tcp_timer_needed>
    }
    break;
    ff94:	00006406 	br	10128 <tcp_process+0xbbc>
  case CLOSING:
    tcp_receive(pcb);
    ff98:	e13fff17 	ldw	r4,-4(fp)
    ff9c:	00103280 	call	10328 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
    ffa0:	d0a8c603 	ldbu	r2,-23784(gp)
    ffa4:	10803fcc 	andi	r2,r2,255
    ffa8:	1080040c 	andi	r2,r2,16
    ffac:	10006026 	beq	r2,zero,10130 <tcp_process+0xbc4>
    ffb0:	e0bfff17 	ldw	r2,-4(fp)
    ffb4:	10c01517 	ldw	r3,84(r2)
    ffb8:	d0a8c517 	ldw	r2,-23788(gp)
    ffbc:	18805c1e 	bne	r3,r2,10130 <tcp_process+0xbc4>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
    ffc0:	e13fff17 	ldw	r4,-4(fp)
    ffc4:	000e1180 	call	e118 <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
    ffc8:	008000f4 	movhi	r2,3
    ffcc:	109e2e04 	addi	r2,r2,30904
    ffd0:	10c00017 	ldw	r3,0(r2)
    ffd4:	e0bfff17 	ldw	r2,-4(fp)
    ffd8:	1880081e 	bne	r3,r2,fffc <tcp_process+0xa90>
    ffdc:	008000f4 	movhi	r2,3
    ffe0:	109e2e04 	addi	r2,r2,30904
    ffe4:	10800017 	ldw	r2,0(r2)
    ffe8:	10c00317 	ldw	r3,12(r2)
    ffec:	008000f4 	movhi	r2,3
    fff0:	109e2e04 	addi	r2,r2,30904
    fff4:	10c00015 	stw	r3,0(r2)
    fff8:	00001f06 	br	10078 <tcp_process+0xb0c>
    fffc:	008000f4 	movhi	r2,3
   10000:	109e2e04 	addi	r2,r2,30904
   10004:	10c00017 	ldw	r3,0(r2)
   10008:	008000f4 	movhi	r2,3
   1000c:	109e3104 	addi	r2,r2,30916
   10010:	10c00015 	stw	r3,0(r2)
   10014:	00001406 	br	10068 <tcp_process+0xafc>
   10018:	008000f4 	movhi	r2,3
   1001c:	109e3104 	addi	r2,r2,30916
   10020:	10800017 	ldw	r2,0(r2)
   10024:	10c00317 	ldw	r3,12(r2)
   10028:	e0bfff17 	ldw	r2,-4(fp)
   1002c:	1880071e 	bne	r3,r2,1004c <tcp_process+0xae0>
   10030:	008000f4 	movhi	r2,3
   10034:	109e3104 	addi	r2,r2,30916
   10038:	10800017 	ldw	r2,0(r2)
   1003c:	e0ffff17 	ldw	r3,-4(fp)
   10040:	18c00317 	ldw	r3,12(r3)
   10044:	10c00315 	stw	r3,12(r2)
   10048:	00000b06 	br	10078 <tcp_process+0xb0c>
   1004c:	008000f4 	movhi	r2,3
   10050:	109e3104 	addi	r2,r2,30916
   10054:	10800017 	ldw	r2,0(r2)
   10058:	10c00317 	ldw	r3,12(r2)
   1005c:	008000f4 	movhi	r2,3
   10060:	109e3104 	addi	r2,r2,30916
   10064:	10c00015 	stw	r3,0(r2)
   10068:	008000f4 	movhi	r2,3
   1006c:	109e3104 	addi	r2,r2,30916
   10070:	10800017 	ldw	r2,0(r2)
   10074:	103fe81e 	bne	r2,zero,10018 <tcp_process+0xaac>
   10078:	e0bfff17 	ldw	r2,-4(fp)
   1007c:	10000315 	stw	zero,12(r2)
   10080:	008000f4 	movhi	r2,3
   10084:	109e2d84 	addi	r2,r2,30902
   10088:	00c00044 	movi	r3,1
   1008c:	10c00005 	stb	r3,0(r2)
      pcb->state = TIME_WAIT;
   10090:	e0bfff17 	ldw	r2,-4(fp)
   10094:	00c00284 	movi	r3,10
   10098:	10c00615 	stw	r3,24(r2)
      TCP_REG(&tcp_tw_pcbs, pcb);
   1009c:	008000f4 	movhi	r2,3
   100a0:	109e3304 	addi	r2,r2,30924
   100a4:	10c00017 	ldw	r3,0(r2)
   100a8:	e0bfff17 	ldw	r2,-4(fp)
   100ac:	10c00315 	stw	r3,12(r2)
   100b0:	008000f4 	movhi	r2,3
   100b4:	109e3304 	addi	r2,r2,30924
   100b8:	e0ffff17 	ldw	r3,-4(fp)
   100bc:	10c00015 	stw	r3,0(r2)
   100c0:	0014fd80 	call	14fd8 <tcp_timer_needed>
    }
    break;
   100c4:	00001a06 	br	10130 <tcp_process+0xbc4>
  case LAST_ACK:
    tcp_receive(pcb);
   100c8:	e13fff17 	ldw	r4,-4(fp)
   100cc:	00103280 	call	10328 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
   100d0:	d0a8c603 	ldbu	r2,-23784(gp)
   100d4:	10803fcc 	andi	r2,r2,255
   100d8:	1080040c 	andi	r2,r2,16
   100dc:	10001626 	beq	r2,zero,10138 <tcp_process+0xbcc>
   100e0:	e0bfff17 	ldw	r2,-4(fp)
   100e4:	10c01517 	ldw	r3,84(r2)
   100e8:	d0a8c517 	ldw	r2,-23788(gp)
   100ec:	1880121e 	bne	r3,r2,10138 <tcp_process+0xbcc>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags |= TF_CLOSED;
   100f0:	d0a8c703 	ldbu	r2,-23780(gp)
   100f4:	10800414 	ori	r2,r2,16
   100f8:	d0a8c705 	stb	r2,-23780(gp)
    }
    break;
   100fc:	00000e06 	br	10138 <tcp_process+0xbcc>
  default:
    break;
   10100:	0001883a 	nop
   10104:	00000d06 	br	1013c <tcp_process+0xbd0>
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
    }
    break;
   10108:	0001883a 	nop
   1010c:	00000b06 	br	1013c <tcp_process+0xbd0>
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    }
    break;
   10110:	0001883a 	nop
   10114:	00000906 	br	1013c <tcp_process+0xbd0>
    tcp_receive(pcb);
    if (recv_flags & TF_GOT_FIN) { /* passive close */
      tcp_ack_now(pcb);
      pcb->state = CLOSE_WAIT;
    }
    break;
   10118:	0001883a 	nop
   1011c:	00000706 	br	1013c <tcp_process+0xbd0>
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
   10120:	0001883a 	nop
   10124:	00000506 	br	1013c <tcp_process+0xbd0>
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
   10128:	0001883a 	nop
   1012c:	00000306 	br	1013c <tcp_process+0xbd0>
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
   10130:	0001883a 	nop
   10134:	00000106 	br	1013c <tcp_process+0xbd0>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags |= TF_CLOSED;
    }
    break;
   10138:	0001883a 	nop
  default:
    break;
  }
  return ERR_OK;
   1013c:	0005883a 	mov	r2,zero
}
   10140:	e037883a 	mov	sp,fp
   10144:	dfc00117 	ldw	ra,4(sp)
   10148:	df000017 	ldw	fp,0(sp)
   1014c:	dec00204 	addi	sp,sp,8
   10150:	f800283a 	ret

00010154 <tcp_oos_insert_segment>:
 *
 * Called from tcp_receive()
 */
static void
tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
{
   10154:	defffb04 	addi	sp,sp,-20
   10158:	dfc00415 	stw	ra,16(sp)
   1015c:	df000315 	stw	fp,12(sp)
   10160:	df000304 	addi	fp,sp,12
   10164:	e13ffe15 	stw	r4,-8(fp)
   10168:	e17fff15 	stw	r5,-4(fp)
  struct tcp_seg *old_seg;

  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
   1016c:	e0bffe17 	ldw	r2,-8(fp)
   10170:	10800317 	ldw	r2,12(r2)
   10174:	1080030b 	ldhu	r2,12(r2)
   10178:	10bfffcc 	andi	r2,r2,65535
   1017c:	1004d23a 	srli	r2,r2,8
   10180:	10ffffcc 	andi	r3,r2,65535
   10184:	e0bffe17 	ldw	r2,-8(fp)
   10188:	10800317 	ldw	r2,12(r2)
   1018c:	1080030b 	ldhu	r2,12(r2)
   10190:	10bfffcc 	andi	r2,r2,65535
   10194:	1004923a 	slli	r2,r2,8
   10198:	10bfffcc 	andi	r2,r2,65535
   1019c:	1884b03a 	or	r2,r3,r2
   101a0:	1080004c 	andi	r2,r2,1
   101a4:	10002126 	beq	r2,zero,1022c <tcp_oos_insert_segment+0xd8>
    /* received segment overlaps all following segments */
    tcp_segs_free(next);
   101a8:	e13fff17 	ldw	r4,-4(fp)
   101ac:	000d9b80 	call	d9b8 <tcp_segs_free>
    next = NULL;
   101b0:	e03fff15 	stw	zero,-4(fp)
   101b4:	00005406 	br	10308 <tcp_oos_insert_segment+0x1b4>
       oos queue may have segments with FIN flag */
    while (next &&
           TCP_SEQ_GEQ((seqno + cseg->len),
                      (next->tcphdr->seqno + next->len))) {
      /* cseg with FIN already processed */
      if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
   101b8:	e0bfff17 	ldw	r2,-4(fp)
   101bc:	10800317 	ldw	r2,12(r2)
   101c0:	1080030b 	ldhu	r2,12(r2)
   101c4:	10bfffcc 	andi	r2,r2,65535
   101c8:	1004d23a 	srli	r2,r2,8
   101cc:	10ffffcc 	andi	r3,r2,65535
   101d0:	e0bfff17 	ldw	r2,-4(fp)
   101d4:	10800317 	ldw	r2,12(r2)
   101d8:	1080030b 	ldhu	r2,12(r2)
   101dc:	10bfffcc 	andi	r2,r2,65535
   101e0:	1004923a 	slli	r2,r2,8
   101e4:	10bfffcc 	andi	r2,r2,65535
   101e8:	1884b03a 	or	r2,r3,r2
   101ec:	1080004c 	andi	r2,r2,1
   101f0:	10000726 	beq	r2,zero,10210 <tcp_oos_insert_segment+0xbc>
        TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
   101f4:	e0bffe17 	ldw	r2,-8(fp)
   101f8:	10800317 	ldw	r2,12(r2)
   101fc:	e0fffe17 	ldw	r3,-8(fp)
   10200:	18c00317 	ldw	r3,12(r3)
   10204:	18c0030b 	ldhu	r3,12(r3)
   10208:	18c04014 	ori	r3,r3,256
   1020c:	10c0030d 	sth	r3,12(r2)
      }
      old_seg = next;
   10210:	e0bfff17 	ldw	r2,-4(fp)
   10214:	e0bffd15 	stw	r2,-12(fp)
      next = next->next;
   10218:	e0bfff17 	ldw	r2,-4(fp)
   1021c:	10800017 	ldw	r2,0(r2)
   10220:	e0bfff15 	stw	r2,-4(fp)
      tcp_seg_free(old_seg);
   10224:	e13ffd17 	ldw	r4,-12(fp)
   10228:	000da080 	call	da08 <tcp_seg_free>
    next = NULL;
  }
  else {
    /* delete some following segments
       oos queue may have segments with FIN flag */
    while (next &&
   1022c:	e0bfff17 	ldw	r2,-4(fp)
   10230:	10001226 	beq	r2,zero,1027c <tcp_oos_insert_segment+0x128>
           TCP_SEQ_GEQ((seqno + cseg->len),
   10234:	e0bffe17 	ldw	r2,-8(fp)
   10238:	1080020b 	ldhu	r2,8(r2)
   1023c:	10ffffcc 	andi	r3,r2,65535
   10240:	d0a8c417 	ldw	r2,-23792(gp)
   10244:	1887883a 	add	r3,r3,r2
   10248:	e0bfff17 	ldw	r2,-4(fp)
   1024c:	10800317 	ldw	r2,12(r2)
   10250:	1100010b 	ldhu	r4,4(r2)
   10254:	1080018b 	ldhu	r2,6(r2)
   10258:	1004943a 	slli	r2,r2,16
   1025c:	1104b03a 	or	r2,r2,r4
   10260:	1009883a 	mov	r4,r2
   10264:	e0bfff17 	ldw	r2,-4(fp)
   10268:	1080020b 	ldhu	r2,8(r2)
   1026c:	10bfffcc 	andi	r2,r2,65535
   10270:	2085883a 	add	r2,r4,r2
   10274:	1885c83a 	sub	r2,r3,r2
    next = NULL;
  }
  else {
    /* delete some following segments
       oos queue may have segments with FIN flag */
    while (next &&
   10278:	103fcf0e 	bge	r2,zero,101b8 <tcp_oos_insert_segment+0x64>
      }
      old_seg = next;
      next = next->next;
      tcp_seg_free(old_seg);
    }
    if (next &&
   1027c:	e0bfff17 	ldw	r2,-4(fp)
   10280:	10002126 	beq	r2,zero,10308 <tcp_oos_insert_segment+0x1b4>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
   10284:	e0bffe17 	ldw	r2,-8(fp)
   10288:	1080020b 	ldhu	r2,8(r2)
   1028c:	10ffffcc 	andi	r3,r2,65535
   10290:	d0a8c417 	ldw	r2,-23792(gp)
   10294:	1887883a 	add	r3,r3,r2
   10298:	e0bfff17 	ldw	r2,-4(fp)
   1029c:	10800317 	ldw	r2,12(r2)
   102a0:	1100010b 	ldhu	r4,4(r2)
   102a4:	1080018b 	ldhu	r2,6(r2)
   102a8:	1004943a 	slli	r2,r2,16
   102ac:	1104b03a 	or	r2,r2,r4
   102b0:	1885c83a 	sub	r2,r3,r2
      }
      old_seg = next;
      next = next->next;
      tcp_seg_free(old_seg);
    }
    if (next &&
   102b4:	0080140e 	bge	zero,r2,10308 <tcp_oos_insert_segment+0x1b4>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
      /* We need to trim the incoming segment. */
      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
   102b8:	e0bfff17 	ldw	r2,-4(fp)
   102bc:	10800317 	ldw	r2,12(r2)
   102c0:	10c0010b 	ldhu	r3,4(r2)
   102c4:	1080018b 	ldhu	r2,6(r2)
   102c8:	1004943a 	slli	r2,r2,16
   102cc:	10c4b03a 	or	r2,r2,r3
   102d0:	1007883a 	mov	r3,r2
   102d4:	d0a8c417 	ldw	r2,-23792(gp)
   102d8:	1885c83a 	sub	r2,r3,r2
   102dc:	1007883a 	mov	r3,r2
   102e0:	e0bffe17 	ldw	r2,-8(fp)
   102e4:	10c0020d 	sth	r3,8(r2)
      pbuf_realloc(cseg->p, cseg->len);
   102e8:	e0bffe17 	ldw	r2,-8(fp)
   102ec:	10c00117 	ldw	r3,4(r2)
   102f0:	e0bffe17 	ldw	r2,-8(fp)
   102f4:	1080020b 	ldhu	r2,8(r2)
   102f8:	10bfffcc 	andi	r2,r2,65535
   102fc:	1809883a 	mov	r4,r3
   10300:	100b883a 	mov	r5,r2
   10304:	000a5b80 	call	a5b8 <pbuf_realloc>
    }
  }
  cseg->next = next;
   10308:	e0bffe17 	ldw	r2,-8(fp)
   1030c:	e0ffff17 	ldw	r3,-4(fp)
   10310:	10c00015 	stw	r3,0(r2)
}
   10314:	e037883a 	mov	sp,fp
   10318:	dfc00117 	ldw	ra,4(sp)
   1031c:	df000017 	ldw	fp,0(sp)
   10320:	dec00204 	addi	sp,sp,8
   10324:	f800283a 	ret

00010328 <tcp_receive>:
 *
 * Called from tcp_process().
 */
static void
tcp_receive(struct tcp_pcb *pcb)
{
   10328:	defff204 	addi	sp,sp,-56
   1032c:	dfc00d15 	stw	ra,52(sp)
   10330:	df000c15 	stw	fp,48(sp)
   10334:	dc000b15 	stw	r16,44(sp)
   10338:	df000b04 	addi	fp,sp,44
   1033c:	e13fff15 	stw	r4,-4(fp)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  int found_dupack = 0;
   10340:	e03ffa15 	stw	zero,-24(fp)
#if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
  u32_t ooseq_blen;
  u16_t ooseq_qlen;
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */

  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
   10344:	e0bfff17 	ldw	r2,-4(fp)
   10348:	10800617 	ldw	r2,24(r2)
   1034c:	10800128 	cmpgeui	r2,r2,4
   10350:	1000091e 	bne	r2,zero,10378 <tcp_receive+0x50>
   10354:	010000f4 	movhi	r4,3
   10358:	2101fd04 	addi	r4,r4,2036
   1035c:	014000f4 	movhi	r5,3
   10360:	29426804 	addi	r5,r5,2464
   10364:	0180d804 	movi	r6,864
   10368:	01c000f4 	movhi	r7,3
   1036c:	39c21104 	addi	r7,r7,2116
   10370:	00193f00 	call	193f0 <printf>
   10374:	003fff06 	br	10374 <tcp_receive+0x4c>

  if (flags & TCP_ACK) {
   10378:	d0a8c603 	ldbu	r2,-23784(gp)
   1037c:	10803fcc 	andi	r2,r2,255
   10380:	1080040c 	andi	r2,r2,16
   10384:	10029d26 	beq	r2,zero,10dfc <tcp_receive+0xad4>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
   10388:	e0bfff17 	ldw	r2,-4(fp)
   1038c:	1080190b 	ldhu	r2,100(r2)
   10390:	10ffffcc 	andi	r3,r2,65535
   10394:	e0bfff17 	ldw	r2,-4(fp)
   10398:	10801717 	ldw	r2,92(r2)
   1039c:	1885883a 	add	r2,r3,r2
   103a0:	e0bffb15 	stw	r2,-20(fp)

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
   103a4:	e0bfff17 	ldw	r2,-4(fp)
   103a8:	10c01617 	ldw	r3,88(r2)
   103ac:	d0a8c417 	ldw	r2,-23792(gp)
   103b0:	1885c83a 	sub	r2,r3,r2
   103b4:	10001416 	blt	r2,zero,10408 <tcp_receive+0xe0>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
   103b8:	e0bfff17 	ldw	r2,-4(fp)
   103bc:	10c01617 	ldw	r3,88(r2)
   103c0:	d0a8c417 	ldw	r2,-23792(gp)

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
   103c4:	1880051e 	bne	r3,r2,103dc <tcp_receive+0xb4>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
   103c8:	e0bfff17 	ldw	r2,-4(fp)
   103cc:	10c01717 	ldw	r3,92(r2)
   103d0:	d0a8c517 	ldw	r2,-23788(gp)
   103d4:	1885c83a 	sub	r2,r3,r2
   103d8:	10000b16 	blt	r2,zero,10408 <tcp_receive+0xe0>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
   103dc:	e0bfff17 	ldw	r2,-4(fp)
   103e0:	10c01717 	ldw	r3,92(r2)
   103e4:	d0a8c517 	ldw	r2,-23788(gp)
  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
   103e8:	1880301e 	bne	r3,r2,104ac <tcp_receive+0x184>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
   103ec:	d0a8c217 	ldw	r2,-23800(gp)
   103f0:	1080038b 	ldhu	r2,14(r2)
   103f4:	e0ffff17 	ldw	r3,-4(fp)
   103f8:	18c0190b 	ldhu	r3,100(r3)
   103fc:	10bfffcc 	andi	r2,r2,65535
   10400:	18ffffcc 	andi	r3,r3,65535
   10404:	1880292e 	bgeu	r3,r2,104ac <tcp_receive+0x184>
      pcb->snd_wnd = tcphdr->wnd;
   10408:	d0a8c217 	ldw	r2,-23800(gp)
   1040c:	10c0038b 	ldhu	r3,14(r2)
   10410:	e0bfff17 	ldw	r2,-4(fp)
   10414:	10c0190d 	sth	r3,100(r2)
      /* keep track of the biggest window announced by the remote host to calculate
         the maximum segment size */
      if (pcb->snd_wnd_max < tcphdr->wnd) {
   10418:	e0bfff17 	ldw	r2,-4(fp)
   1041c:	10c0198b 	ldhu	r3,102(r2)
   10420:	d0a8c217 	ldw	r2,-23800(gp)
   10424:	1080038b 	ldhu	r2,14(r2)
   10428:	18ffffcc 	andi	r3,r3,65535
   1042c:	10bfffcc 	andi	r2,r2,65535
   10430:	1880042e 	bgeu	r3,r2,10444 <tcp_receive+0x11c>
        pcb->snd_wnd_max = tcphdr->wnd;
   10434:	d0a8c217 	ldw	r2,-23800(gp)
   10438:	10c0038b 	ldhu	r3,14(r2)
   1043c:	e0bfff17 	ldw	r2,-4(fp)
   10440:	10c0198d 	sth	r3,102(r2)
      }
      pcb->snd_wl1 = seqno;
   10444:	d0e8c417 	ldw	r3,-23792(gp)
   10448:	e0bfff17 	ldw	r2,-4(fp)
   1044c:	10c01615 	stw	r3,88(r2)
      pcb->snd_wl2 = ackno;
   10450:	d0e8c517 	ldw	r3,-23788(gp)
   10454:	e0bfff17 	ldw	r2,-4(fp)
   10458:	10c01715 	stw	r3,92(r2)
      if (pcb->snd_wnd == 0) {
   1045c:	e0bfff17 	ldw	r2,-4(fp)
   10460:	1080190b 	ldhu	r2,100(r2)
   10464:	10bfffcc 	andi	r2,r2,65535
   10468:	10000a1e 	bne	r2,zero,10494 <tcp_receive+0x16c>
        if (pcb->persist_backoff == 0) {
   1046c:	e0bfff17 	ldw	r2,-4(fp)
   10470:	10802643 	ldbu	r2,153(r2)
   10474:	10803fcc 	andi	r2,r2,255
   10478:	10000c1e 	bne	r2,zero,104ac <tcp_receive+0x184>
          /* start persist timer */
          pcb->persist_cnt = 0;
   1047c:	e0bfff17 	ldw	r2,-4(fp)
   10480:	10002605 	stb	zero,152(r2)
          pcb->persist_backoff = 1;
   10484:	e0bfff17 	ldw	r2,-4(fp)
   10488:	00c00044 	movi	r3,1
   1048c:	10c02645 	stb	r3,153(r2)
   10490:	00000606 	br	104ac <tcp_receive+0x184>
        }
      } else if (pcb->persist_backoff > 0) {
   10494:	e0bfff17 	ldw	r2,-4(fp)
   10498:	10802643 	ldbu	r2,153(r2)
   1049c:	10803fcc 	andi	r2,r2,255
   104a0:	10000226 	beq	r2,zero,104ac <tcp_receive+0x184>
        /* stop persist timer */
          pcb->persist_backoff = 0;
   104a4:	e0bfff17 	ldw	r2,-4(fp)
   104a8:	10002645 	stb	zero,153(r2)
     * If it only passes 1, should reset dupack counter
     *
     */

    /* Clause 1 */
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
   104ac:	d0e8c517 	ldw	r3,-23788(gp)
   104b0:	e0bfff17 	ldw	r2,-4(fp)
   104b4:	10801317 	ldw	r2,76(r2)
   104b8:	1885c83a 	sub	r2,r3,r2
   104bc:	00804b16 	blt	zero,r2,105ec <tcp_receive+0x2c4>
      pcb->acked = 0;
   104c0:	e0bfff17 	ldw	r2,-4(fp)
   104c4:	10001a0d 	sth	zero,104(r2)
      /* Clause 2 */
      if (tcplen == 0) {
   104c8:	d0a8c68b 	ldhu	r2,-23782(gp)
   104cc:	10bfffcc 	andi	r2,r2,65535
   104d0:	1000411e 	bne	r2,zero,105d8 <tcp_receive+0x2b0>
        /* Clause 3 */
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
   104d4:	e0bfff17 	ldw	r2,-4(fp)
   104d8:	10c01717 	ldw	r3,92(r2)
   104dc:	e0bfff17 	ldw	r2,-4(fp)
   104e0:	1080190b 	ldhu	r2,100(r2)
   104e4:	10bfffcc 	andi	r2,r2,65535
   104e8:	1887883a 	add	r3,r3,r2
   104ec:	e0bffb17 	ldw	r2,-20(fp)
   104f0:	1880391e 	bne	r3,r2,105d8 <tcp_receive+0x2b0>
          /* Clause 4 */
          if (pcb->rtime >= 0) {
   104f4:	e0bfff17 	ldw	r2,-4(fp)
   104f8:	10800e0b 	ldhu	r2,56(r2)
   104fc:	10bfffcc 	andi	r2,r2,65535
   10500:	10a0001c 	xori	r2,r2,32768
   10504:	10a00004 	addi	r2,r2,-32768
   10508:	10003316 	blt	r2,zero,105d8 <tcp_receive+0x2b0>
            /* Clause 5 */
            if (pcb->lastack == ackno) {
   1050c:	e0bfff17 	ldw	r2,-4(fp)
   10510:	10c01317 	ldw	r3,76(r2)
   10514:	d0a8c517 	ldw	r2,-23788(gp)
   10518:	18802f1e 	bne	r3,r2,105d8 <tcp_receive+0x2b0>
              found_dupack = 1;
   1051c:	00800044 	movi	r2,1
   10520:	e0bffa15 	stw	r2,-24(fp)
              if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
   10524:	e0bfff17 	ldw	r2,-4(fp)
   10528:	108012c3 	ldbu	r2,75(r2)
   1052c:	10800044 	addi	r2,r2,1
   10530:	e0ffff17 	ldw	r3,-4(fp)
   10534:	18c012c3 	ldbu	r3,75(r3)
   10538:	10803fcc 	andi	r2,r2,255
   1053c:	18c03fcc 	andi	r3,r3,255
   10540:	1880062e 	bgeu	r3,r2,1055c <tcp_receive+0x234>
                ++pcb->dupacks;
   10544:	e0bfff17 	ldw	r2,-4(fp)
   10548:	108012c3 	ldbu	r2,75(r2)
   1054c:	10800044 	addi	r2,r2,1
   10550:	1007883a 	mov	r3,r2
   10554:	e0bfff17 	ldw	r2,-4(fp)
   10558:	10c012c5 	stb	r3,75(r2)
              }
              if (pcb->dupacks > 3) {
   1055c:	e0bfff17 	ldw	r2,-4(fp)
   10560:	108012c3 	ldbu	r2,75(r2)
   10564:	10803fcc 	andi	r2,r2,255
   10568:	10800130 	cmpltui	r2,r2,4
   1056c:	1000131e 	bne	r2,zero,105bc <tcp_receive+0x294>
                /* Inflate the congestion window, but not if it means that
                   the value overflows. */
                if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
   10570:	e0bfff17 	ldw	r2,-4(fp)
   10574:	10c0140b 	ldhu	r3,80(r2)
   10578:	e0bfff17 	ldw	r2,-4(fp)
   1057c:	10800e8b 	ldhu	r2,58(r2)
   10580:	1885883a 	add	r2,r3,r2
   10584:	e0ffff17 	ldw	r3,-4(fp)
   10588:	18c0140b 	ldhu	r3,80(r3)
   1058c:	10bfffcc 	andi	r2,r2,65535
   10590:	18ffffcc 	andi	r3,r3,65535
   10594:	1880102e 	bgeu	r3,r2,105d8 <tcp_receive+0x2b0>
                  pcb->cwnd += pcb->mss;
   10598:	e0bfff17 	ldw	r2,-4(fp)
   1059c:	10c0140b 	ldhu	r3,80(r2)
   105a0:	e0bfff17 	ldw	r2,-4(fp)
   105a4:	10800e8b 	ldhu	r2,58(r2)
   105a8:	1885883a 	add	r2,r3,r2
   105ac:	1007883a 	mov	r3,r2
   105b0:	e0bfff17 	ldw	r2,-4(fp)
   105b4:	10c0140d 	sth	r3,80(r2)
   105b8:	00000706 	br	105d8 <tcp_receive+0x2b0>
                }
              } else if (pcb->dupacks == 3) {
   105bc:	e0bfff17 	ldw	r2,-4(fp)
   105c0:	108012c3 	ldbu	r2,75(r2)
   105c4:	10803fcc 	andi	r2,r2,255
   105c8:	108000d8 	cmpnei	r2,r2,3
   105cc:	1000021e 	bne	r2,zero,105d8 <tcp_receive+0x2b0>
                /* Do fast retransmit */
                tcp_rexmit_fast(pcb);
   105d0:	e13fff17 	ldw	r4,-4(fp)
   105d4:	0014b540 	call	14b54 <tcp_rexmit_fast>
          }
        }
      }
      /* If Clause (1) or more is true, but not a duplicate ack, reset
       * count of consecutive duplicate acks */
      if (!found_dupack) {
   105d8:	e0bffa17 	ldw	r2,-24(fp)
   105dc:	1001781e 	bne	r2,zero,10bc0 <tcp_receive+0x898>
        pcb->dupacks = 0;
   105e0:	e0bfff17 	ldw	r2,-4(fp)
   105e4:	100012c5 	stb	zero,75(r2)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
   105e8:	00017506 	br	10bc0 <tcp_receive+0x898>
      /* If Clause (1) or more is true, but not a duplicate ack, reset
       * count of consecutive duplicate acks */
      if (!found_dupack) {
        pcb->dupacks = 0;
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)){
   105ec:	e0bfff17 	ldw	r2,-4(fp)
   105f0:	10801317 	ldw	r2,76(r2)
   105f4:	0086303a 	nor	r3,zero,r2
   105f8:	d0a8c517 	ldw	r2,-23788(gp)
   105fc:	1885883a 	add	r2,r3,r2
   10600:	10011316 	blt	r2,zero,10a50 <tcp_receive+0x728>
   10604:	d0e8c517 	ldw	r3,-23788(gp)
   10608:	e0bfff17 	ldw	r2,-4(fp)
   1060c:	10801517 	ldw	r2,84(r2)
   10610:	1885c83a 	sub	r2,r3,r2
   10614:	00810e16 	blt	zero,r2,10a50 <tcp_receive+0x728>
      /* We come here when the ACK acknowledges new data. */

      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
   10618:	e0bfff17 	ldw	r2,-4(fp)
   1061c:	10800883 	ldbu	r2,34(r2)
   10620:	10803fcc 	andi	r2,r2,255
   10624:	1080010c 	andi	r2,r2,4
   10628:	10000b26 	beq	r2,zero,10658 <tcp_receive+0x330>
        pcb->flags &= ~TF_INFR;
   1062c:	e0bfff17 	ldw	r2,-4(fp)
   10630:	10c00883 	ldbu	r3,34(r2)
   10634:	00bffec4 	movi	r2,-5
   10638:	1884703a 	and	r2,r3,r2
   1063c:	1007883a 	mov	r3,r2
   10640:	e0bfff17 	ldw	r2,-4(fp)
   10644:	10c00885 	stb	r3,34(r2)
        pcb->cwnd = pcb->ssthresh;
   10648:	e0bfff17 	ldw	r2,-4(fp)
   1064c:	10c0148b 	ldhu	r3,82(r2)
   10650:	e0bfff17 	ldw	r2,-4(fp)
   10654:	10c0140d 	sth	r3,80(r2)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
   10658:	e0bfff17 	ldw	r2,-4(fp)
   1065c:	10001285 	stb	zero,74(r2)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
   10660:	e0bfff17 	ldw	r2,-4(fp)
   10664:	1080110b 	ldhu	r2,68(r2)
   10668:	10bfffcc 	andi	r2,r2,65535
   1066c:	10a0001c 	xori	r2,r2,32768
   10670:	10a00004 	addi	r2,r2,-32768
   10674:	1005d0fa 	srai	r2,r2,3
   10678:	1007883a 	mov	r3,r2
   1067c:	e0bfff17 	ldw	r2,-4(fp)
   10680:	1080118b 	ldhu	r2,70(r2)
   10684:	1885883a 	add	r2,r3,r2
   10688:	1007883a 	mov	r3,r2
   1068c:	e0bfff17 	ldw	r2,-4(fp)
   10690:	10c0120d 	sth	r3,72(r2)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
   10694:	d0a8c517 	ldw	r2,-23788(gp)
   10698:	1007883a 	mov	r3,r2
   1069c:	e0bfff17 	ldw	r2,-4(fp)
   106a0:	10801317 	ldw	r2,76(r2)
   106a4:	1885c83a 	sub	r2,r3,r2
   106a8:	1007883a 	mov	r3,r2
   106ac:	e0bfff17 	ldw	r2,-4(fp)
   106b0:	10c01a0d 	sth	r3,104(r2)

      pcb->snd_buf += pcb->acked;
   106b4:	e0bfff17 	ldw	r2,-4(fp)
   106b8:	10c01a8b 	ldhu	r3,106(r2)
   106bc:	e0bfff17 	ldw	r2,-4(fp)
   106c0:	10801a0b 	ldhu	r2,104(r2)
   106c4:	1885883a 	add	r2,r3,r2
   106c8:	1007883a 	mov	r3,r2
   106cc:	e0bfff17 	ldw	r2,-4(fp)
   106d0:	10c01a8d 	sth	r3,106(r2)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
   106d4:	e0bfff17 	ldw	r2,-4(fp)
   106d8:	100012c5 	stb	zero,75(r2)
      pcb->lastack = ackno;
   106dc:	d0e8c517 	ldw	r3,-23788(gp)
   106e0:	e0bfff17 	ldw	r2,-4(fp)
   106e4:	10c01315 	stw	r3,76(r2)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
   106e8:	e0bfff17 	ldw	r2,-4(fp)
   106ec:	10800617 	ldw	r2,24(r2)
   106f0:	10800130 	cmpltui	r2,r2,4
   106f4:	1000861e 	bne	r2,zero,10910 <tcp_receive+0x5e8>
        if (pcb->cwnd < pcb->ssthresh) {
   106f8:	e0bfff17 	ldw	r2,-4(fp)
   106fc:	10c0140b 	ldhu	r3,80(r2)
   10700:	e0bfff17 	ldw	r2,-4(fp)
   10704:	1080148b 	ldhu	r2,82(r2)
   10708:	18ffffcc 	andi	r3,r3,65535
   1070c:	10bfffcc 	andi	r2,r2,65535
   10710:	1880132e 	bgeu	r3,r2,10760 <tcp_receive+0x438>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
   10714:	e0bfff17 	ldw	r2,-4(fp)
   10718:	10c0140b 	ldhu	r3,80(r2)
   1071c:	e0bfff17 	ldw	r2,-4(fp)
   10720:	10800e8b 	ldhu	r2,58(r2)
   10724:	1885883a 	add	r2,r3,r2
   10728:	e0ffff17 	ldw	r3,-4(fp)
   1072c:	18c0140b 	ldhu	r3,80(r3)
   10730:	10bfffcc 	andi	r2,r2,65535
   10734:	18ffffcc 	andi	r3,r3,65535
   10738:	1880752e 	bgeu	r3,r2,10910 <tcp_receive+0x5e8>
            pcb->cwnd += pcb->mss;
   1073c:	e0bfff17 	ldw	r2,-4(fp)
   10740:	10c0140b 	ldhu	r3,80(r2)
   10744:	e0bfff17 	ldw	r2,-4(fp)
   10748:	10800e8b 	ldhu	r2,58(r2)
   1074c:	1885883a 	add	r2,r3,r2
   10750:	1007883a 	mov	r3,r2
   10754:	e0bfff17 	ldw	r2,-4(fp)
   10758:	10c0140d 	sth	r3,80(r2)
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
   1075c:	00006c06 	br	10910 <tcp_receive+0x5e8>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
            pcb->cwnd += pcb->mss;
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
   10760:	e0bfff17 	ldw	r2,-4(fp)
   10764:	10c0140b 	ldhu	r3,80(r2)
   10768:	e0bfff17 	ldw	r2,-4(fp)
   1076c:	10800e8b 	ldhu	r2,58(r2)
   10770:	113fffcc 	andi	r4,r2,65535
   10774:	e0bfff17 	ldw	r2,-4(fp)
   10778:	10800e8b 	ldhu	r2,58(r2)
   1077c:	10bfffcc 	andi	r2,r2,65535
   10780:	2089383a 	mul	r4,r4,r2
   10784:	e0bfff17 	ldw	r2,-4(fp)
   10788:	1080140b 	ldhu	r2,80(r2)
   1078c:	10bfffcc 	andi	r2,r2,65535
   10790:	2085283a 	div	r2,r4,r2
   10794:	1885883a 	add	r2,r3,r2
   10798:	e0bffc0d 	sth	r2,-16(fp)
          if (new_cwnd > pcb->cwnd) {
   1079c:	e0bfff17 	ldw	r2,-4(fp)
   107a0:	1080140b 	ldhu	r2,80(r2)
   107a4:	10ffffcc 	andi	r3,r2,65535
   107a8:	e0bffc0b 	ldhu	r2,-16(fp)
   107ac:	1880582e 	bgeu	r3,r2,10910 <tcp_receive+0x5e8>
            pcb->cwnd = new_cwnd;
   107b0:	e0bfff17 	ldw	r2,-4(fp)
   107b4:	e0fffc0b 	ldhu	r3,-16(fp)
   107b8:	10c0140d 	sth	r3,80(r2)
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
   107bc:	00005406 	br	10910 <tcp_receive+0x5e8>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
   107c0:	e0bfff17 	ldw	r2,-4(fp)
   107c4:	10801d17 	ldw	r2,116(r2)
   107c8:	e0bff515 	stw	r2,-44(fp)
        pcb->unacked = pcb->unacked->next;
   107cc:	e0bfff17 	ldw	r2,-4(fp)
   107d0:	10801d17 	ldw	r2,116(r2)
   107d4:	10c00017 	ldw	r3,0(r2)
   107d8:	e0bfff17 	ldw	r2,-4(fp)
   107dc:	10c01d15 	stw	r3,116(r2)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
   107e0:	e0bfff17 	ldw	r2,-4(fp)
   107e4:	14001b0b 	ldhu	r16,108(r2)
   107e8:	e0bff517 	ldw	r2,-44(fp)
   107ec:	10800117 	ldw	r2,4(r2)
   107f0:	1009883a 	mov	r4,r2
   107f4:	000ac000 	call	ac00 <pbuf_clen>
   107f8:	10803fcc 	andi	r2,r2,255
   107fc:	80ffffcc 	andi	r3,r16,65535
   10800:	10bfffcc 	andi	r2,r2,65535
   10804:	1880092e 	bgeu	r3,r2,1082c <tcp_receive+0x504>
   10808:	010000f4 	movhi	r4,3
   1080c:	2101fd04 	addi	r4,r4,2036
   10810:	014000f4 	movhi	r5,3
   10814:	29426f04 	addi	r5,r5,2492
   10818:	0180ff04 	movi	r6,1020
   1081c:	01c000f4 	movhi	r7,3
   10820:	39c21104 	addi	r7,r7,2116
   10824:	00193f00 	call	193f0 <printf>
   10828:	003fff06 	br	10828 <tcp_receive+0x500>
        /* Prevent ACK for FIN to generate a sent event */
        if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
   1082c:	e0bfff17 	ldw	r2,-4(fp)
   10830:	10801a0b 	ldhu	r2,104(r2)
   10834:	10bfffcc 	andi	r2,r2,65535
   10838:	10001526 	beq	r2,zero,10890 <tcp_receive+0x568>
   1083c:	e0bff517 	ldw	r2,-44(fp)
   10840:	10800317 	ldw	r2,12(r2)
   10844:	1080030b 	ldhu	r2,12(r2)
   10848:	10bfffcc 	andi	r2,r2,65535
   1084c:	1004d23a 	srli	r2,r2,8
   10850:	10ffffcc 	andi	r3,r2,65535
   10854:	e0bff517 	ldw	r2,-44(fp)
   10858:	10800317 	ldw	r2,12(r2)
   1085c:	1080030b 	ldhu	r2,12(r2)
   10860:	10bfffcc 	andi	r2,r2,65535
   10864:	1004923a 	slli	r2,r2,8
   10868:	10bfffcc 	andi	r2,r2,65535
   1086c:	1884b03a 	or	r2,r3,r2
   10870:	1080004c 	andi	r2,r2,1
   10874:	10000626 	beq	r2,zero,10890 <tcp_receive+0x568>
          pcb->acked--;
   10878:	e0bfff17 	ldw	r2,-4(fp)
   1087c:	10801a0b 	ldhu	r2,104(r2)
   10880:	10bfffc4 	addi	r2,r2,-1
   10884:	1007883a 	mov	r3,r2
   10888:	e0bfff17 	ldw	r2,-4(fp)
   1088c:	10c01a0d 	sth	r3,104(r2)
        }

        pcb->snd_queuelen -= pbuf_clen(next->p);
   10890:	e0bfff17 	ldw	r2,-4(fp)
   10894:	14001b0b 	ldhu	r16,108(r2)
   10898:	e0bff517 	ldw	r2,-44(fp)
   1089c:	10800117 	ldw	r2,4(r2)
   108a0:	1009883a 	mov	r4,r2
   108a4:	000ac000 	call	ac00 <pbuf_clen>
   108a8:	10803fcc 	andi	r2,r2,255
   108ac:	8085c83a 	sub	r2,r16,r2
   108b0:	1007883a 	mov	r3,r2
   108b4:	e0bfff17 	ldw	r2,-4(fp)
   108b8:	10c01b0d 	sth	r3,108(r2)
        tcp_seg_free(next);
   108bc:	e13ff517 	ldw	r4,-44(fp)
   108c0:	000da080 	call	da08 <tcp_seg_free>

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
   108c4:	e0bfff17 	ldw	r2,-4(fp)
   108c8:	10801b0b 	ldhu	r2,108(r2)
   108cc:	10bfffcc 	andi	r2,r2,65535
   108d0:	10001026 	beq	r2,zero,10914 <tcp_receive+0x5ec>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
   108d4:	e0bfff17 	ldw	r2,-4(fp)
   108d8:	10801d17 	ldw	r2,116(r2)
   108dc:	10000d1e 	bne	r2,zero,10914 <tcp_receive+0x5ec>
   108e0:	e0bfff17 	ldw	r2,-4(fp)
   108e4:	10801c17 	ldw	r2,112(r2)
   108e8:	10000a1e 	bne	r2,zero,10914 <tcp_receive+0x5ec>
   108ec:	010000f4 	movhi	r4,3
   108f0:	2101fd04 	addi	r4,r4,2036
   108f4:	014000f4 	movhi	r5,3
   108f8:	29427904 	addi	r5,r5,2532
   108fc:	01810204 	movi	r6,1032
   10900:	01c000f4 	movhi	r7,3
   10904:	39c21104 	addi	r7,r7,2116
   10908:	00193f00 	call	193f0 <printf>
   1090c:	003fff06 	br	1090c <tcp_receive+0x5e4>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
   10910:	0001883a 	nop
   10914:	e0bfff17 	ldw	r2,-4(fp)
   10918:	10801d17 	ldw	r2,116(r2)
   1091c:	10004026 	beq	r2,zero,10a20 <tcp_receive+0x6f8>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
   10920:	e0bfff17 	ldw	r2,-4(fp)
   10924:	10801d17 	ldw	r2,116(r2)
   10928:	10800317 	ldw	r2,12(r2)
   1092c:	10c0010b 	ldhu	r3,4(r2)
   10930:	1080018b 	ldhu	r2,6(r2)
   10934:	1004943a 	slli	r2,r2,16
   10938:	10c4b03a 	or	r2,r2,r3
   1093c:	1006d63a 	srli	r3,r2,24
   10940:	e0bfff17 	ldw	r2,-4(fp)
   10944:	10801d17 	ldw	r2,116(r2)
   10948:	10800317 	ldw	r2,12(r2)
   1094c:	1100010b 	ldhu	r4,4(r2)
   10950:	1080018b 	ldhu	r2,6(r2)
   10954:	1004943a 	slli	r2,r2,16
   10958:	1104b03a 	or	r2,r2,r4
   1095c:	1004d23a 	srli	r2,r2,8
   10960:	10bfc00c 	andi	r2,r2,65280
   10964:	1886b03a 	or	r3,r3,r2
   10968:	e0bfff17 	ldw	r2,-4(fp)
   1096c:	10801d17 	ldw	r2,116(r2)
   10970:	10800317 	ldw	r2,12(r2)
   10974:	1100010b 	ldhu	r4,4(r2)
   10978:	1080018b 	ldhu	r2,6(r2)
   1097c:	1004943a 	slli	r2,r2,16
   10980:	1104b03a 	or	r2,r2,r4
   10984:	10bfc00c 	andi	r2,r2,65280
   10988:	1004923a 	slli	r2,r2,8
   1098c:	1886b03a 	or	r3,r3,r2
   10990:	e0bfff17 	ldw	r2,-4(fp)
   10994:	10801d17 	ldw	r2,116(r2)
   10998:	10800317 	ldw	r2,12(r2)
   1099c:	1100010b 	ldhu	r4,4(r2)
   109a0:	1080018b 	ldhu	r2,6(r2)
   109a4:	1004943a 	slli	r2,r2,16
   109a8:	1104b03a 	or	r2,r2,r4
   109ac:	1004963a 	slli	r2,r2,24
   109b0:	1886b03a 	or	r3,r3,r2
   109b4:	e0bfff17 	ldw	r2,-4(fp)
   109b8:	10801d17 	ldw	r2,116(r2)
   109bc:	1080020b 	ldhu	r2,8(r2)
   109c0:	113fffcc 	andi	r4,r2,65535
   109c4:	e0bfff17 	ldw	r2,-4(fp)
   109c8:	10801d17 	ldw	r2,116(r2)
   109cc:	10800317 	ldw	r2,12(r2)
   109d0:	1080030b 	ldhu	r2,12(r2)
   109d4:	10bfffcc 	andi	r2,r2,65535
   109d8:	1004d23a 	srli	r2,r2,8
   109dc:	117fffcc 	andi	r5,r2,65535
   109e0:	e0bfff17 	ldw	r2,-4(fp)
   109e4:	10801d17 	ldw	r2,116(r2)
   109e8:	10800317 	ldw	r2,12(r2)
   109ec:	1080030b 	ldhu	r2,12(r2)
   109f0:	10bfffcc 	andi	r2,r2,65535
   109f4:	1004923a 	slli	r2,r2,8
   109f8:	10bfffcc 	andi	r2,r2,65535
   109fc:	2884b03a 	or	r2,r5,r2
   10a00:	108000cc 	andi	r2,r2,3
   10a04:	1004c03a 	cmpne	r2,r2,zero
   10a08:	10803fcc 	andi	r2,r2,255
   10a0c:	2085883a 	add	r2,r4,r2
   10a10:	1887883a 	add	r3,r3,r2
   10a14:	d0a8c517 	ldw	r2,-23788(gp)
   10a18:	1885c83a 	sub	r2,r3,r2
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
   10a1c:	00bf680e 	bge	zero,r2,107c0 <tcp_receive+0x498>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
   10a20:	e0bfff17 	ldw	r2,-4(fp)
   10a24:	10801d17 	ldw	r2,116(r2)
   10a28:	1000041e 	bne	r2,zero,10a3c <tcp_receive+0x714>
        pcb->rtime = -1;
   10a2c:	e0bfff17 	ldw	r2,-4(fp)
   10a30:	00ffffc4 	movi	r3,-1
   10a34:	10c00e0d 	sth	r3,56(r2)
   10a38:	00000206 	br	10a44 <tcp_receive+0x71c>
      else
        pcb->rtime = 0;
   10a3c:	e0bfff17 	ldw	r2,-4(fp)
   10a40:	10000e0d 	sth	zero,56(r2)

      pcb->polltmr = 0;
   10a44:	e0bfff17 	ldw	r2,-4(fp)
   10a48:	100008c5 	stb	zero,35(r2)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
   10a4c:	00005c06 	br	10bc0 <tcp_receive+0x898>
        pcb->rtime = 0;

      pcb->polltmr = 0;
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
   10a50:	e0bfff17 	ldw	r2,-4(fp)
   10a54:	10001a0d 	sth	zero,104(r2)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
   10a58:	00005906 	br	10bc0 <tcp_receive+0x898>
                           TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
   10a5c:	e0bfff17 	ldw	r2,-4(fp)
   10a60:	10801c17 	ldw	r2,112(r2)
   10a64:	e0bff515 	stw	r2,-44(fp)
      pcb->unsent = pcb->unsent->next;
   10a68:	e0bfff17 	ldw	r2,-4(fp)
   10a6c:	10801c17 	ldw	r2,112(r2)
   10a70:	10c00017 	ldw	r3,0(r2)
   10a74:	e0bfff17 	ldw	r2,-4(fp)
   10a78:	10c01c15 	stw	r3,112(r2)
#if TCP_OVERSIZE
      if (pcb->unsent == NULL) {
   10a7c:	e0bfff17 	ldw	r2,-4(fp)
   10a80:	10801c17 	ldw	r2,112(r2)
   10a84:	1000021e 	bne	r2,zero,10a90 <tcp_receive+0x768>
        pcb->unsent_oversize = 0;
   10a88:	e0bfff17 	ldw	r2,-4(fp)
   10a8c:	10001b8d 	sth	zero,110(r2)
      }
#endif /* TCP_OVERSIZE */ 
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
   10a90:	e0bfff17 	ldw	r2,-4(fp)
   10a94:	14001b0b 	ldhu	r16,108(r2)
   10a98:	e0bff517 	ldw	r2,-44(fp)
   10a9c:	10800117 	ldw	r2,4(r2)
   10aa0:	1009883a 	mov	r4,r2
   10aa4:	000ac000 	call	ac00 <pbuf_clen>
   10aa8:	10803fcc 	andi	r2,r2,255
   10aac:	80ffffcc 	andi	r3,r16,65535
   10ab0:	10bfffcc 	andi	r2,r2,65535
   10ab4:	1880092e 	bgeu	r3,r2,10adc <tcp_receive+0x7b4>
   10ab8:	010000f4 	movhi	r4,3
   10abc:	2101fd04 	addi	r4,r4,2036
   10ac0:	014000f4 	movhi	r5,3
   10ac4:	29426f04 	addi	r5,r5,2492
   10ac8:	01810b84 	movi	r6,1070
   10acc:	01c000f4 	movhi	r7,3
   10ad0:	39c21104 	addi	r7,r7,2116
   10ad4:	00193f00 	call	193f0 <printf>
   10ad8:	003fff06 	br	10ad8 <tcp_receive+0x7b0>
      /* Prevent ACK for FIN to generate a sent event */
      if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
   10adc:	e0bfff17 	ldw	r2,-4(fp)
   10ae0:	10801a0b 	ldhu	r2,104(r2)
   10ae4:	10bfffcc 	andi	r2,r2,65535
   10ae8:	10001526 	beq	r2,zero,10b40 <tcp_receive+0x818>
   10aec:	e0bff517 	ldw	r2,-44(fp)
   10af0:	10800317 	ldw	r2,12(r2)
   10af4:	1080030b 	ldhu	r2,12(r2)
   10af8:	10bfffcc 	andi	r2,r2,65535
   10afc:	1004d23a 	srli	r2,r2,8
   10b00:	10ffffcc 	andi	r3,r2,65535
   10b04:	e0bff517 	ldw	r2,-44(fp)
   10b08:	10800317 	ldw	r2,12(r2)
   10b0c:	1080030b 	ldhu	r2,12(r2)
   10b10:	10bfffcc 	andi	r2,r2,65535
   10b14:	1004923a 	slli	r2,r2,8
   10b18:	10bfffcc 	andi	r2,r2,65535
   10b1c:	1884b03a 	or	r2,r3,r2
   10b20:	1080004c 	andi	r2,r2,1
   10b24:	10000626 	beq	r2,zero,10b40 <tcp_receive+0x818>
        pcb->acked--;
   10b28:	e0bfff17 	ldw	r2,-4(fp)
   10b2c:	10801a0b 	ldhu	r2,104(r2)
   10b30:	10bfffc4 	addi	r2,r2,-1
   10b34:	1007883a 	mov	r3,r2
   10b38:	e0bfff17 	ldw	r2,-4(fp)
   10b3c:	10c01a0d 	sth	r3,104(r2)
      }
      pcb->snd_queuelen -= pbuf_clen(next->p);
   10b40:	e0bfff17 	ldw	r2,-4(fp)
   10b44:	14001b0b 	ldhu	r16,108(r2)
   10b48:	e0bff517 	ldw	r2,-44(fp)
   10b4c:	10800117 	ldw	r2,4(r2)
   10b50:	1009883a 	mov	r4,r2
   10b54:	000ac000 	call	ac00 <pbuf_clen>
   10b58:	10803fcc 	andi	r2,r2,255
   10b5c:	8085c83a 	sub	r2,r16,r2
   10b60:	1007883a 	mov	r3,r2
   10b64:	e0bfff17 	ldw	r2,-4(fp)
   10b68:	10c01b0d 	sth	r3,108(r2)
      tcp_seg_free(next);
   10b6c:	e13ff517 	ldw	r4,-44(fp)
   10b70:	000da080 	call	da08 <tcp_seg_free>
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
   10b74:	e0bfff17 	ldw	r2,-4(fp)
   10b78:	10801b0b 	ldhu	r2,108(r2)
   10b7c:	10bfffcc 	andi	r2,r2,65535
   10b80:	10001026 	beq	r2,zero,10bc4 <tcp_receive+0x89c>
        LWIP_ASSERT("tcp_receive: valid queue length",
   10b84:	e0bfff17 	ldw	r2,-4(fp)
   10b88:	10801d17 	ldw	r2,116(r2)
   10b8c:	10000d1e 	bne	r2,zero,10bc4 <tcp_receive+0x89c>
   10b90:	e0bfff17 	ldw	r2,-4(fp)
   10b94:	10801c17 	ldw	r2,112(r2)
   10b98:	10000a1e 	bne	r2,zero,10bc4 <tcp_receive+0x89c>
   10b9c:	010000f4 	movhi	r4,3
   10ba0:	2101fd04 	addi	r4,r4,2036
   10ba4:	014000f4 	movhi	r5,3
   10ba8:	29427904 	addi	r5,r5,2532
   10bac:	01810e04 	movi	r6,1080
   10bb0:	01c000f4 	movhi	r7,3
   10bb4:	39c21104 	addi	r7,r7,2116
   10bb8:	00193f00 	call	193f0 <printf>
   10bbc:	003fff06 	br	10bbc <tcp_receive+0x894>
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
   10bc0:	0001883a 	nop
   10bc4:	e0bfff17 	ldw	r2,-4(fp)
   10bc8:	10801c17 	ldw	r2,112(r2)
   10bcc:	10004526 	beq	r2,zero,10ce4 <tcp_receive+0x9bc>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
   10bd0:	d0e8c517 	ldw	r3,-23788(gp)
   10bd4:	e0bfff17 	ldw	r2,-4(fp)
   10bd8:	10801c17 	ldw	r2,112(r2)
   10bdc:	10800317 	ldw	r2,12(r2)
   10be0:	1100010b 	ldhu	r4,4(r2)
   10be4:	1080018b 	ldhu	r2,6(r2)
   10be8:	1004943a 	slli	r2,r2,16
   10bec:	1104b03a 	or	r2,r2,r4
   10bf0:	1008d63a 	srli	r4,r2,24
   10bf4:	e0bfff17 	ldw	r2,-4(fp)
   10bf8:	10801c17 	ldw	r2,112(r2)
   10bfc:	10800317 	ldw	r2,12(r2)
   10c00:	1140010b 	ldhu	r5,4(r2)
   10c04:	1080018b 	ldhu	r2,6(r2)
   10c08:	1004943a 	slli	r2,r2,16
   10c0c:	1144b03a 	or	r2,r2,r5
   10c10:	1004d23a 	srli	r2,r2,8
   10c14:	10bfc00c 	andi	r2,r2,65280
   10c18:	2088b03a 	or	r4,r4,r2
   10c1c:	e0bfff17 	ldw	r2,-4(fp)
   10c20:	10801c17 	ldw	r2,112(r2)
   10c24:	10800317 	ldw	r2,12(r2)
   10c28:	1140010b 	ldhu	r5,4(r2)
   10c2c:	1080018b 	ldhu	r2,6(r2)
   10c30:	1004943a 	slli	r2,r2,16
   10c34:	1144b03a 	or	r2,r2,r5
   10c38:	10bfc00c 	andi	r2,r2,65280
   10c3c:	1004923a 	slli	r2,r2,8
   10c40:	2088b03a 	or	r4,r4,r2
   10c44:	e0bfff17 	ldw	r2,-4(fp)
   10c48:	10801c17 	ldw	r2,112(r2)
   10c4c:	10800317 	ldw	r2,12(r2)
   10c50:	1140010b 	ldhu	r5,4(r2)
   10c54:	1080018b 	ldhu	r2,6(r2)
   10c58:	1004943a 	slli	r2,r2,16
   10c5c:	1144b03a 	or	r2,r2,r5
   10c60:	1004963a 	slli	r2,r2,24
   10c64:	2088b03a 	or	r4,r4,r2
   10c68:	e0bfff17 	ldw	r2,-4(fp)
   10c6c:	10801c17 	ldw	r2,112(r2)
   10c70:	1080020b 	ldhu	r2,8(r2)
   10c74:	117fffcc 	andi	r5,r2,65535
   10c78:	e0bfff17 	ldw	r2,-4(fp)
   10c7c:	10801c17 	ldw	r2,112(r2)
   10c80:	10800317 	ldw	r2,12(r2)
   10c84:	1080030b 	ldhu	r2,12(r2)
   10c88:	10bfffcc 	andi	r2,r2,65535
   10c8c:	1004d23a 	srli	r2,r2,8
   10c90:	11bfffcc 	andi	r6,r2,65535
   10c94:	e0bfff17 	ldw	r2,-4(fp)
   10c98:	10801c17 	ldw	r2,112(r2)
   10c9c:	10800317 	ldw	r2,12(r2)
   10ca0:	1080030b 	ldhu	r2,12(r2)
   10ca4:	10bfffcc 	andi	r2,r2,65535
   10ca8:	1004923a 	slli	r2,r2,8
   10cac:	10bfffcc 	andi	r2,r2,65535
   10cb0:	3084b03a 	or	r2,r6,r2
   10cb4:	108000cc 	andi	r2,r2,3
   10cb8:	1004c03a 	cmpne	r2,r2,zero
   10cbc:	10803fcc 	andi	r2,r2,255
   10cc0:	2885883a 	add	r2,r5,r2
   10cc4:	2085883a 	add	r2,r4,r2
   10cc8:	1885c83a 	sub	r2,r3,r2
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
   10ccc:	10000516 	blt	r2,zero,10ce4 <tcp_receive+0x9bc>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
   10cd0:	d0e8c517 	ldw	r3,-23788(gp)
   10cd4:	e0bfff17 	ldw	r2,-4(fp)
   10cd8:	10801517 	ldw	r2,84(r2)
   10cdc:	1885c83a 	sub	r2,r3,r2
   10ce0:	00bf5e0e 	bge	zero,r2,10a5c <tcp_receive+0x734>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
   10ce4:	e0bfff17 	ldw	r2,-4(fp)
   10ce8:	10800f17 	ldw	r2,60(r2)
   10cec:	10004326 	beq	r2,zero,10dfc <tcp_receive+0xad4>
   10cf0:	e0bfff17 	ldw	r2,-4(fp)
   10cf4:	10c01017 	ldw	r3,64(r2)
   10cf8:	d0a8c517 	ldw	r2,-23788(gp)
   10cfc:	1885c83a 	sub	r2,r3,r2
   10d00:	10003e0e 	bge	r2,zero,10dfc <tcp_receive+0xad4>
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
   10d04:	008000f4 	movhi	r2,3
   10d08:	109e2f04 	addi	r2,r2,30908
   10d0c:	10800017 	ldw	r2,0(r2)
   10d10:	1007883a 	mov	r3,r2
   10d14:	e0bfff17 	ldw	r2,-4(fp)
   10d18:	10800f17 	ldw	r2,60(r2)
   10d1c:	1885c83a 	sub	r2,r3,r2
   10d20:	e0bff90d 	sth	r2,-28(fp)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
   10d24:	e0fff90b 	ldhu	r3,-28(fp)
   10d28:	e0bfff17 	ldw	r2,-4(fp)
   10d2c:	1080110b 	ldhu	r2,68(r2)
   10d30:	10bfffcc 	andi	r2,r2,65535
   10d34:	10a0001c 	xori	r2,r2,32768
   10d38:	10a00004 	addi	r2,r2,-32768
   10d3c:	1005d0fa 	srai	r2,r2,3
   10d40:	1885c83a 	sub	r2,r3,r2
   10d44:	e0bff90d 	sth	r2,-28(fp)
      pcb->sa += m;
   10d48:	e0bfff17 	ldw	r2,-4(fp)
   10d4c:	1080110b 	ldhu	r2,68(r2)
   10d50:	1007883a 	mov	r3,r2
   10d54:	e0bff90b 	ldhu	r2,-28(fp)
   10d58:	1885883a 	add	r2,r3,r2
   10d5c:	1007883a 	mov	r3,r2
   10d60:	e0bfff17 	ldw	r2,-4(fp)
   10d64:	10c0110d 	sth	r3,68(r2)
      if (m < 0) {
   10d68:	e0bff90f 	ldh	r2,-28(fp)
   10d6c:	1000030e 	bge	r2,zero,10d7c <tcp_receive+0xa54>
        m = -m;
   10d70:	e0bff90b 	ldhu	r2,-28(fp)
   10d74:	0085c83a 	sub	r2,zero,r2
   10d78:	e0bff90d 	sth	r2,-28(fp)
      }
      m = m - (pcb->sv >> 2);
   10d7c:	e0fff90b 	ldhu	r3,-28(fp)
   10d80:	e0bfff17 	ldw	r2,-4(fp)
   10d84:	1080118b 	ldhu	r2,70(r2)
   10d88:	10bfffcc 	andi	r2,r2,65535
   10d8c:	10a0001c 	xori	r2,r2,32768
   10d90:	10a00004 	addi	r2,r2,-32768
   10d94:	1005d0ba 	srai	r2,r2,2
   10d98:	1885c83a 	sub	r2,r3,r2
   10d9c:	e0bff90d 	sth	r2,-28(fp)
      pcb->sv += m;
   10da0:	e0bfff17 	ldw	r2,-4(fp)
   10da4:	1080118b 	ldhu	r2,70(r2)
   10da8:	1007883a 	mov	r3,r2
   10dac:	e0bff90b 	ldhu	r2,-28(fp)
   10db0:	1885883a 	add	r2,r3,r2
   10db4:	1007883a 	mov	r3,r2
   10db8:	e0bfff17 	ldw	r2,-4(fp)
   10dbc:	10c0118d 	sth	r3,70(r2)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
   10dc0:	e0bfff17 	ldw	r2,-4(fp)
   10dc4:	1080110b 	ldhu	r2,68(r2)
   10dc8:	10bfffcc 	andi	r2,r2,65535
   10dcc:	10a0001c 	xori	r2,r2,32768
   10dd0:	10a00004 	addi	r2,r2,-32768
   10dd4:	1005d0fa 	srai	r2,r2,3
   10dd8:	1007883a 	mov	r3,r2
   10ddc:	e0bfff17 	ldw	r2,-4(fp)
   10de0:	1080118b 	ldhu	r2,70(r2)
   10de4:	1885883a 	add	r2,r3,r2
   10de8:	1007883a 	mov	r3,r2
   10dec:	e0bfff17 	ldw	r2,-4(fp)
   10df0:	10c0120d 	sth	r3,72(r2)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
   10df4:	e0bfff17 	ldw	r2,-4(fp)
   10df8:	10000f15 	stw	zero,60(r2)

  /* If the incoming segment contains data, we must process it
     further unless the pcb already received a FIN.
     (RFC 793, chapeter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
     LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
  if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
   10dfc:	d0a8c68b 	ldhu	r2,-23782(gp)
   10e00:	10bfffcc 	andi	r2,r2,65535
   10e04:	1004b826 	beq	r2,zero,120e8 <tcp_receive+0x1dc0>
   10e08:	e0bfff17 	ldw	r2,-4(fp)
   10e0c:	10800617 	ldw	r2,24(r2)
   10e10:	108001e8 	cmpgeui	r2,r2,7
   10e14:	1004b41e 	bne	r2,zero,120e8 <tcp_receive+0x1dc0>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
   10e18:	e0bfff17 	ldw	r2,-4(fp)
   10e1c:	10c00b17 	ldw	r3,44(r2)
   10e20:	d0a8c417 	ldw	r2,-23792(gp)
   10e24:	0084303a 	nor	r2,zero,r2
   10e28:	1885883a 	add	r2,r3,r2
   10e2c:	1000a516 	blt	r2,zero,110c4 <tcp_receive+0xd9c>
   10e30:	e0bfff17 	ldw	r2,-4(fp)
   10e34:	10c00b17 	ldw	r3,44(r2)
   10e38:	d0a8c68b 	ldhu	r2,-23782(gp)
   10e3c:	113fffcc 	andi	r4,r2,65535
   10e40:	d0a8c417 	ldw	r2,-23792(gp)
   10e44:	2085883a 	add	r2,r4,r2
   10e48:	1885c83a 	sub	r2,r3,r2
   10e4c:	10800044 	addi	r2,r2,1
   10e50:	00809c16 	blt	zero,r2,110c4 <tcp_receive+0xd9c>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
   10e54:	e0bfff17 	ldw	r2,-4(fp)
   10e58:	10c00b17 	ldw	r3,44(r2)
   10e5c:	d0a8c417 	ldw	r2,-23792(gp)
   10e60:	1885c83a 	sub	r2,r3,r2
   10e64:	e0bff815 	stw	r2,-32(fp)
      p = inseg.p;
   10e68:	00800134 	movhi	r2,4
   10e6c:	10973504 	addi	r2,r2,23764
   10e70:	10800117 	ldw	r2,4(r2)
   10e74:	e0bff715 	stw	r2,-36(fp)
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
   10e78:	00800134 	movhi	r2,4
   10e7c:	10973504 	addi	r2,r2,23764
   10e80:	10800117 	ldw	r2,4(r2)
   10e84:	1000091e 	bne	r2,zero,10eac <tcp_receive+0xb84>
   10e88:	010000f4 	movhi	r4,3
   10e8c:	2101fd04 	addi	r4,r4,2036
   10e90:	014000f4 	movhi	r5,3
   10e94:	29428104 	addi	r5,r5,2564
   10e98:	01812584 	movi	r6,1174
   10e9c:	01c000f4 	movhi	r7,3
   10ea0:	39c21104 	addi	r7,r7,2116
   10ea4:	00193f00 	call	193f0 <printf>
   10ea8:	003fff06 	br	10ea8 <tcp_receive+0xb80>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
   10eac:	e0bff817 	ldw	r2,-32(fp)
   10eb0:	109fffd0 	cmplti	r2,r2,32767
   10eb4:	1000091e 	bne	r2,zero,10edc <tcp_receive+0xbb4>
   10eb8:	010000f4 	movhi	r4,3
   10ebc:	2101fd04 	addi	r4,r4,2036
   10ec0:	014000f4 	movhi	r5,3
   10ec4:	29428504 	addi	r5,r5,2580
   10ec8:	018125c4 	movi	r6,1175
   10ecc:	01c000f4 	movhi	r7,3
   10ed0:	39c21104 	addi	r7,r7,2116
   10ed4:	00193f00 	call	193f0 <printf>
   10ed8:	003fff06 	br	10ed8 <tcp_receive+0xbb0>
      if (inseg.p->len < off) {
   10edc:	00800134 	movhi	r2,4
   10ee0:	10973504 	addi	r2,r2,23764
   10ee4:	10800117 	ldw	r2,4(r2)
   10ee8:	1080028b 	ldhu	r2,10(r2)
   10eec:	10ffffcc 	andi	r3,r2,65535
   10ef0:	e0bff817 	ldw	r2,-32(fp)
   10ef4:	18803e0e 	bge	r3,r2,10ff0 <tcp_receive+0xcc8>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
   10ef8:	00800134 	movhi	r2,4
   10efc:	10973504 	addi	r2,r2,23764
   10f00:	10800117 	ldw	r2,4(r2)
   10f04:	1080020b 	ldhu	r2,8(r2)
   10f08:	10ffffcc 	andi	r3,r2,65535
   10f0c:	e0bff817 	ldw	r2,-32(fp)
   10f10:	1880090e 	bge	r3,r2,10f38 <tcp_receive+0xc10>
   10f14:	010000f4 	movhi	r4,3
   10f18:	2101fd04 	addi	r4,r4,2036
   10f1c:	014000f4 	movhi	r5,3
   10f20:	29428904 	addi	r5,r5,2596
   10f24:	01812644 	movi	r6,1177
   10f28:	01c000f4 	movhi	r7,3
   10f2c:	39c21104 	addi	r7,r7,2116
   10f30:	00193f00 	call	193f0 <printf>
   10f34:	003fff06 	br	10f34 <tcp_receive+0xc0c>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
   10f38:	00800134 	movhi	r2,4
   10f3c:	10973504 	addi	r2,r2,23764
   10f40:	10800117 	ldw	r2,4(r2)
   10f44:	10c0020b 	ldhu	r3,8(r2)
   10f48:	e0bff817 	ldw	r2,-32(fp)
   10f4c:	1885c83a 	sub	r2,r3,r2
   10f50:	e0bffc8d 	sth	r2,-14(fp)
        while (p->len < off) {
   10f54:	00000e06 	br	10f90 <tcp_receive+0xc68>
          off -= p->len;
   10f58:	e0bff717 	ldw	r2,-36(fp)
   10f5c:	1080028b 	ldhu	r2,10(r2)
   10f60:	10bfffcc 	andi	r2,r2,65535
   10f64:	e0fff817 	ldw	r3,-32(fp)
   10f68:	1885c83a 	sub	r2,r3,r2
   10f6c:	e0bff815 	stw	r2,-32(fp)
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
   10f70:	e0bff717 	ldw	r2,-36(fp)
   10f74:	e0fffc8b 	ldhu	r3,-14(fp)
   10f78:	10c0020d 	sth	r3,8(r2)
          p->len = 0;
   10f7c:	e0bff717 	ldw	r2,-36(fp)
   10f80:	1000028d 	sth	zero,10(r2)
          p = p->next;
   10f84:	e0bff717 	ldw	r2,-36(fp)
   10f88:	10800017 	ldw	r2,0(r2)
   10f8c:	e0bff715 	stw	r2,-36(fp)
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
   10f90:	e0bff717 	ldw	r2,-36(fp)
   10f94:	1080028b 	ldhu	r2,10(r2)
   10f98:	10ffffcc 	andi	r3,r2,65535
   10f9c:	e0bff817 	ldw	r2,-32(fp)
   10fa0:	18bfed16 	blt	r3,r2,10f58 <tcp_receive+0xc30>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
   10fa4:	e0bff817 	ldw	r2,-32(fp)
   10fa8:	0085c83a 	sub	r2,zero,r2
   10fac:	10bfffcc 	andi	r2,r2,65535
   10fb0:	10a0001c 	xori	r2,r2,32768
   10fb4:	10a00004 	addi	r2,r2,-32768
   10fb8:	e13ff717 	ldw	r4,-36(fp)
   10fbc:	100b883a 	mov	r5,r2
   10fc0:	000a83c0 	call	a83c <pbuf_header>
   10fc4:	10803fcc 	andi	r2,r2,255
   10fc8:	10001f26 	beq	r2,zero,11048 <tcp_receive+0xd20>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
   10fcc:	010000f4 	movhi	r4,3
   10fd0:	2101fd04 	addi	r4,r4,2036
   10fd4:	014000f4 	movhi	r5,3
   10fd8:	29428d04 	addi	r5,r5,2612
   10fdc:	01812984 	movi	r6,1190
   10fe0:	01c000f4 	movhi	r7,3
   10fe4:	39c21104 	addi	r7,r7,2116
   10fe8:	00193f00 	call	193f0 <printf>
   10fec:	003fff06 	br	10fec <tcp_receive+0xcc4>
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
   10ff0:	00800134 	movhi	r2,4
   10ff4:	10973504 	addi	r2,r2,23764
   10ff8:	10c00117 	ldw	r3,4(r2)
   10ffc:	e0bff817 	ldw	r2,-32(fp)
   11000:	0085c83a 	sub	r2,zero,r2
   11004:	10bfffcc 	andi	r2,r2,65535
   11008:	10a0001c 	xori	r2,r2,32768
   1100c:	10a00004 	addi	r2,r2,-32768
   11010:	1809883a 	mov	r4,r3
   11014:	100b883a 	mov	r5,r2
   11018:	000a83c0 	call	a83c <pbuf_header>
   1101c:	10803fcc 	andi	r2,r2,255
   11020:	10000926 	beq	r2,zero,11048 <tcp_receive+0xd20>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
   11024:	010000f4 	movhi	r4,3
   11028:	2101fd04 	addi	r4,r4,2036
   1102c:	014000f4 	movhi	r5,3
   11030:	29428d04 	addi	r5,r5,2612
   11034:	01812ac4 	movi	r6,1195
   11038:	01c000f4 	movhi	r7,3
   1103c:	39c21104 	addi	r7,r7,2116
   11040:	00193f00 	call	193f0 <printf>
   11044:	003fff06 	br	11044 <tcp_receive+0xd1c>
        }
      }
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
   11048:	00800134 	movhi	r2,4
   1104c:	10973504 	addi	r2,r2,23764
   11050:	10c0020b 	ldhu	r3,8(r2)
   11054:	d0a8c417 	ldw	r2,-23792(gp)
   11058:	1009883a 	mov	r4,r2
   1105c:	e0bfff17 	ldw	r2,-4(fp)
   11060:	10800b17 	ldw	r2,44(r2)
   11064:	2085c83a 	sub	r2,r4,r2
   11068:	1885883a 	add	r2,r3,r2
   1106c:	1007883a 	mov	r3,r2
   11070:	00800134 	movhi	r2,4
   11074:	10973504 	addi	r2,r2,23764
   11078:	10c0020d 	sth	r3,8(r2)
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
   1107c:	00800134 	movhi	r2,4
   11080:	10973504 	addi	r2,r2,23764
   11084:	10800317 	ldw	r2,12(r2)
   11088:	e0ffff17 	ldw	r3,-4(fp)
   1108c:	18c00b17 	ldw	r3,44(r3)
   11090:	d0e8c415 	stw	r3,-23792(gp)
   11094:	d0e8c417 	ldw	r3,-23792(gp)
   11098:	193fffcc 	andi	r4,r3,65535
   1109c:	1140010b 	ldhu	r5,4(r2)
   110a0:	280a703a 	and	r5,r5,zero
   110a4:	2908b03a 	or	r4,r5,r4
   110a8:	1100010d 	sth	r4,4(r2)
   110ac:	1806d43a 	srli	r3,r3,16
   110b0:	1100018b 	ldhu	r4,6(r2)
   110b4:	2008703a 	and	r4,r4,zero
   110b8:	20c6b03a 	or	r3,r4,r3
   110bc:	10c0018d 	sth	r3,6(r2)
   110c0:	00000b06 	br	110f0 <tcp_receive+0xdc8>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
   110c4:	d0e8c417 	ldw	r3,-23792(gp)
   110c8:	e0bfff17 	ldw	r2,-4(fp)
   110cc:	10800b17 	ldw	r2,44(r2)
   110d0:	1885c83a 	sub	r2,r3,r2
   110d4:	1000060e 	bge	r2,zero,110f0 <tcp_receive+0xdc8>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
   110d8:	e0bfff17 	ldw	r2,-4(fp)
   110dc:	10800883 	ldbu	r2,34(r2)
   110e0:	10800094 	ori	r2,r2,2
   110e4:	1007883a 	mov	r3,r2
   110e8:	e0bfff17 	ldw	r2,-4(fp)
   110ec:	10c00885 	stb	r3,34(r2)
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
   110f0:	d0e8c417 	ldw	r3,-23792(gp)
   110f4:	e0bfff17 	ldw	r2,-4(fp)
   110f8:	10800b17 	ldw	r2,44(r2)
   110fc:	1885c83a 	sub	r2,r3,r2
   11100:	1003f516 	blt	r2,zero,120d8 <tcp_receive+0x1db0>
   11104:	d0e8c417 	ldw	r3,-23792(gp)
   11108:	e0bfff17 	ldw	r2,-4(fp)
   1110c:	11000b17 	ldw	r4,44(r2)
   11110:	e0bfff17 	ldw	r2,-4(fp)
   11114:	10800c0b 	ldhu	r2,48(r2)
   11118:	10bfffcc 	andi	r2,r2,65535
   1111c:	2085883a 	add	r2,r4,r2
   11120:	1885c83a 	sub	r2,r3,r2
   11124:	10800044 	addi	r2,r2,1
   11128:	0083eb16 	blt	zero,r2,120d8 <tcp_receive+0x1db0>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
   1112c:	e0bfff17 	ldw	r2,-4(fp)
   11130:	10c00b17 	ldw	r3,44(r2)
   11134:	d0a8c417 	ldw	r2,-23792(gp)
   11138:	1882861e 	bne	r3,r2,11b54 <tcp_receive+0x182c>
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
        tcplen = TCP_TCPLEN(&inseg);
   1113c:	00800134 	movhi	r2,4
   11140:	10973504 	addi	r2,r2,23764
   11144:	10c0020b 	ldhu	r3,8(r2)
   11148:	00800134 	movhi	r2,4
   1114c:	10973504 	addi	r2,r2,23764
   11150:	10800317 	ldw	r2,12(r2)
   11154:	1080030b 	ldhu	r2,12(r2)
   11158:	10bfffcc 	andi	r2,r2,65535
   1115c:	1004d23a 	srli	r2,r2,8
   11160:	113fffcc 	andi	r4,r2,65535
   11164:	00800134 	movhi	r2,4
   11168:	10973504 	addi	r2,r2,23764
   1116c:	10800317 	ldw	r2,12(r2)
   11170:	1080030b 	ldhu	r2,12(r2)
   11174:	10bfffcc 	andi	r2,r2,65535
   11178:	1004923a 	slli	r2,r2,8
   1117c:	10bfffcc 	andi	r2,r2,65535
   11180:	2084b03a 	or	r2,r4,r2
   11184:	108000cc 	andi	r2,r2,3
   11188:	1004c03a 	cmpne	r2,r2,zero
   1118c:	10803fcc 	andi	r2,r2,255
   11190:	1885883a 	add	r2,r3,r2
   11194:	d0a8c68d 	sth	r2,-23782(gp)

        if (tcplen > pcb->rcv_wnd) {
   11198:	e0bfff17 	ldw	r2,-4(fp)
   1119c:	10c00c0b 	ldhu	r3,48(r2)
   111a0:	d0a8c68b 	ldhu	r2,-23782(gp)
   111a4:	18ffffcc 	andi	r3,r3,65535
   111a8:	10bfffcc 	andi	r2,r2,65535
   111ac:	1880802e 	bgeu	r3,r2,113b0 <tcp_receive+0x1088>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                      ("tcp_receive: other end overran receive window"
                       "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                       seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
   111b0:	00800134 	movhi	r2,4
   111b4:	10973504 	addi	r2,r2,23764
   111b8:	10800317 	ldw	r2,12(r2)
   111bc:	1080030b 	ldhu	r2,12(r2)
   111c0:	10bfffcc 	andi	r2,r2,65535
   111c4:	1004d23a 	srli	r2,r2,8
   111c8:	10ffffcc 	andi	r3,r2,65535
   111cc:	00800134 	movhi	r2,4
   111d0:	10973504 	addi	r2,r2,23764
   111d4:	10800317 	ldw	r2,12(r2)
   111d8:	1080030b 	ldhu	r2,12(r2)
   111dc:	10bfffcc 	andi	r2,r2,65535
   111e0:	1004923a 	slli	r2,r2,8
   111e4:	10bfffcc 	andi	r2,r2,65535
   111e8:	1884b03a 	or	r2,r3,r2
   111ec:	1080004c 	andi	r2,r2,1
   111f0:	10001c26 	beq	r2,zero,11264 <tcp_receive+0xf3c>
            /* Must remove the FIN from the header as we're trimming 
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
   111f4:	00800134 	movhi	r2,4
   111f8:	10973504 	addi	r2,r2,23764
   111fc:	10800317 	ldw	r2,12(r2)
   11200:	00c00134 	movhi	r3,4
   11204:	18d73504 	addi	r3,r3,23764
   11208:	18c00317 	ldw	r3,12(r3)
   1120c:	1900030b 	ldhu	r4,12(r3)
   11210:	00f03fc4 	movi	r3,-16129
   11214:	20c6703a 	and	r3,r4,r3
   11218:	1809883a 	mov	r4,r3
   1121c:	00c00134 	movhi	r3,4
   11220:	18d73504 	addi	r3,r3,23764
   11224:	18c00317 	ldw	r3,12(r3)
   11228:	18c0030b 	ldhu	r3,12(r3)
   1122c:	18ffffcc 	andi	r3,r3,65535
   11230:	1806d23a 	srli	r3,r3,8
   11234:	180b883a 	mov	r5,r3
   11238:	00c00134 	movhi	r3,4
   1123c:	18d73504 	addi	r3,r3,23764
   11240:	18c00317 	ldw	r3,12(r3)
   11244:	18c0030b 	ldhu	r3,12(r3)
   11248:	18ffffcc 	andi	r3,r3,65535
   1124c:	1806923a 	slli	r3,r3,8
   11250:	28c6b03a 	or	r3,r5,r3
   11254:	18c00f8c 	andi	r3,r3,62
   11258:	1806923a 	slli	r3,r3,8
   1125c:	20c6b03a 	or	r3,r4,r3
   11260:	10c0030d 	sth	r3,12(r2)
          }
          /* Adjust length of segment to fit in the window. */
          inseg.len = pcb->rcv_wnd;
   11264:	e0bfff17 	ldw	r2,-4(fp)
   11268:	10c00c0b 	ldhu	r3,48(r2)
   1126c:	00800134 	movhi	r2,4
   11270:	10973504 	addi	r2,r2,23764
   11274:	10c0020d 	sth	r3,8(r2)
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
   11278:	00800134 	movhi	r2,4
   1127c:	10973504 	addi	r2,r2,23764
   11280:	10800317 	ldw	r2,12(r2)
   11284:	1080030b 	ldhu	r2,12(r2)
   11288:	10bfffcc 	andi	r2,r2,65535
   1128c:	1004d23a 	srli	r2,r2,8
   11290:	10ffffcc 	andi	r3,r2,65535
   11294:	00800134 	movhi	r2,4
   11298:	10973504 	addi	r2,r2,23764
   1129c:	10800317 	ldw	r2,12(r2)
   112a0:	1080030b 	ldhu	r2,12(r2)
   112a4:	10bfffcc 	andi	r2,r2,65535
   112a8:	1004923a 	slli	r2,r2,8
   112ac:	10bfffcc 	andi	r2,r2,65535
   112b0:	1884b03a 	or	r2,r3,r2
   112b4:	1080008c 	andi	r2,r2,2
   112b8:	10000826 	beq	r2,zero,112dc <tcp_receive+0xfb4>
            inseg.len -= 1;
   112bc:	00800134 	movhi	r2,4
   112c0:	10973504 	addi	r2,r2,23764
   112c4:	1080020b 	ldhu	r2,8(r2)
   112c8:	10bfffc4 	addi	r2,r2,-1
   112cc:	1007883a 	mov	r3,r2
   112d0:	00800134 	movhi	r2,4
   112d4:	10973504 	addi	r2,r2,23764
   112d8:	10c0020d 	sth	r3,8(r2)
          }
          pbuf_realloc(inseg.p, inseg.len);
   112dc:	00800134 	movhi	r2,4
   112e0:	10973504 	addi	r2,r2,23764
   112e4:	10c00117 	ldw	r3,4(r2)
   112e8:	00800134 	movhi	r2,4
   112ec:	10973504 	addi	r2,r2,23764
   112f0:	1080020b 	ldhu	r2,8(r2)
   112f4:	10bfffcc 	andi	r2,r2,65535
   112f8:	1809883a 	mov	r4,r3
   112fc:	100b883a 	mov	r5,r2
   11300:	000a5b80 	call	a5b8 <pbuf_realloc>
          tcplen = TCP_TCPLEN(&inseg);
   11304:	00800134 	movhi	r2,4
   11308:	10973504 	addi	r2,r2,23764
   1130c:	10c0020b 	ldhu	r3,8(r2)
   11310:	00800134 	movhi	r2,4
   11314:	10973504 	addi	r2,r2,23764
   11318:	10800317 	ldw	r2,12(r2)
   1131c:	1080030b 	ldhu	r2,12(r2)
   11320:	10bfffcc 	andi	r2,r2,65535
   11324:	1004d23a 	srli	r2,r2,8
   11328:	113fffcc 	andi	r4,r2,65535
   1132c:	00800134 	movhi	r2,4
   11330:	10973504 	addi	r2,r2,23764
   11334:	10800317 	ldw	r2,12(r2)
   11338:	1080030b 	ldhu	r2,12(r2)
   1133c:	10bfffcc 	andi	r2,r2,65535
   11340:	1004923a 	slli	r2,r2,8
   11344:	10bfffcc 	andi	r2,r2,65535
   11348:	2084b03a 	or	r2,r4,r2
   1134c:	108000cc 	andi	r2,r2,3
   11350:	1004c03a 	cmpne	r2,r2,zero
   11354:	10803fcc 	andi	r2,r2,255
   11358:	1885883a 	add	r2,r3,r2
   1135c:	d0a8c68d 	sth	r2,-23782(gp)
          LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
   11360:	d0a8c68b 	ldhu	r2,-23782(gp)
   11364:	10ffffcc 	andi	r3,r2,65535
   11368:	d0a8c417 	ldw	r2,-23792(gp)
   1136c:	1887883a 	add	r3,r3,r2
   11370:	e0bfff17 	ldw	r2,-4(fp)
   11374:	11000b17 	ldw	r4,44(r2)
   11378:	e0bfff17 	ldw	r2,-4(fp)
   1137c:	10800c0b 	ldhu	r2,48(r2)
   11380:	10bfffcc 	andi	r2,r2,65535
   11384:	2085883a 	add	r2,r4,r2
   11388:	18800926 	beq	r3,r2,113b0 <tcp_receive+0x1088>
   1138c:	010000f4 	movhi	r4,3
   11390:	2101fd04 	addi	r4,r4,2036
   11394:	014000f4 	movhi	r5,3
   11398:	29429204 	addi	r5,r5,2632
   1139c:	01813604 	movi	r6,1240
   113a0:	01c000f4 	movhi	r7,3
   113a4:	39c21104 	addi	r7,r7,2116
   113a8:	00193f00 	call	193f0 <printf>
   113ac:	003fff06 	br	113ac <tcp_receive+0x1084>
        }
#if TCP_QUEUE_OOSEQ
        /* Received in-sequence data, adjust ooseq data if:
           - FIN has been received or
           - inseq overlaps with ooseq */
        if (pcb->ooseq != NULL) {
   113b0:	e0bfff17 	ldw	r2,-4(fp)
   113b4:	10801e17 	ldw	r2,120(r2)
   113b8:	1000ea26 	beq	r2,zero,11764 <tcp_receive+0x143c>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
   113bc:	00800134 	movhi	r2,4
   113c0:	10973504 	addi	r2,r2,23764
   113c4:	10800317 	ldw	r2,12(r2)
   113c8:	1080030b 	ldhu	r2,12(r2)
   113cc:	10bfffcc 	andi	r2,r2,65535
   113d0:	1004d23a 	srli	r2,r2,8
   113d4:	10ffffcc 	andi	r3,r2,65535
   113d8:	00800134 	movhi	r2,4
   113dc:	10973504 	addi	r2,r2,23764
   113e0:	10800317 	ldw	r2,12(r2)
   113e4:	1080030b 	ldhu	r2,12(r2)
   113e8:	10bfffcc 	andi	r2,r2,65535
   113ec:	1004923a 	slli	r2,r2,8
   113f0:	10bfffcc 	andi	r2,r2,65535
   113f4:	1884b03a 	or	r2,r3,r2
   113f8:	1080004c 	andi	r2,r2,1
   113fc:	10000f26 	beq	r2,zero,1143c <tcp_receive+0x1114>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                        ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
            /* Received in-order FIN means anything that was received
             * out of order must now have been received in-order, so
             * bin the ooseq queue */
            while (pcb->ooseq != NULL) {
   11400:	00000a06 	br	1142c <tcp_receive+0x1104>
              struct tcp_seg *old_ooseq = pcb->ooseq;
   11404:	e0bfff17 	ldw	r2,-4(fp)
   11408:	10801e17 	ldw	r2,120(r2)
   1140c:	e0bffd15 	stw	r2,-12(fp)
              pcb->ooseq = pcb->ooseq->next;
   11410:	e0bfff17 	ldw	r2,-4(fp)
   11414:	10801e17 	ldw	r2,120(r2)
   11418:	10c00017 	ldw	r3,0(r2)
   1141c:	e0bfff17 	ldw	r2,-4(fp)
   11420:	10c01e15 	stw	r3,120(r2)
              tcp_seg_free(old_ooseq);
   11424:	e13ffd17 	ldw	r4,-12(fp)
   11428:	000da080 	call	da08 <tcp_seg_free>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                        ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
            /* Received in-order FIN means anything that was received
             * out of order must now have been received in-order, so
             * bin the ooseq queue */
            while (pcb->ooseq != NULL) {
   1142c:	e0bfff17 	ldw	r2,-4(fp)
   11430:	10801e17 	ldw	r2,120(r2)
   11434:	103ff31e 	bne	r2,zero,11404 <tcp_receive+0x10dc>
   11438:	0000ca06 	br	11764 <tcp_receive+0x143c>
              struct tcp_seg *old_ooseq = pcb->ooseq;
              pcb->ooseq = pcb->ooseq->next;
              tcp_seg_free(old_ooseq);
            }
          } else {
            next = pcb->ooseq;
   1143c:	e0bfff17 	ldw	r2,-4(fp)
   11440:	10801e17 	ldw	r2,120(r2)
   11444:	e0bff515 	stw	r2,-44(fp)
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
   11448:	00004706 	br	11568 <tcp_receive+0x1240>
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              /* inseg cannot have FIN here (already processed above) */
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
   1144c:	e0bff517 	ldw	r2,-44(fp)
   11450:	10800317 	ldw	r2,12(r2)
   11454:	1080030b 	ldhu	r2,12(r2)
   11458:	10bfffcc 	andi	r2,r2,65535
   1145c:	1004d23a 	srli	r2,r2,8
   11460:	10ffffcc 	andi	r3,r2,65535
   11464:	e0bff517 	ldw	r2,-44(fp)
   11468:	10800317 	ldw	r2,12(r2)
   1146c:	1080030b 	ldhu	r2,12(r2)
   11470:	10bfffcc 	andi	r2,r2,65535
   11474:	1004923a 	slli	r2,r2,8
   11478:	10bfffcc 	andi	r2,r2,65535
   1147c:	1884b03a 	or	r2,r3,r2
   11480:	1080004c 	andi	r2,r2,1
   11484:	10003126 	beq	r2,zero,1154c <tcp_receive+0x1224>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
   11488:	00800134 	movhi	r2,4
   1148c:	10973504 	addi	r2,r2,23764
   11490:	10800317 	ldw	r2,12(r2)
   11494:	1080030b 	ldhu	r2,12(r2)
   11498:	10bfffcc 	andi	r2,r2,65535
   1149c:	1004d23a 	srli	r2,r2,8
   114a0:	10ffffcc 	andi	r3,r2,65535
   114a4:	00800134 	movhi	r2,4
   114a8:	10973504 	addi	r2,r2,23764
   114ac:	10800317 	ldw	r2,12(r2)
   114b0:	1080030b 	ldhu	r2,12(r2)
   114b4:	10bfffcc 	andi	r2,r2,65535
   114b8:	1004923a 	slli	r2,r2,8
   114bc:	10bfffcc 	andi	r2,r2,65535
   114c0:	1884b03a 	or	r2,r3,r2
   114c4:	1080008c 	andi	r2,r2,2
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              /* inseg cannot have FIN here (already processed above) */
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
   114c8:	1000201e 	bne	r2,zero,1154c <tcp_receive+0x1224>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
   114cc:	00800134 	movhi	r2,4
   114d0:	10973504 	addi	r2,r2,23764
   114d4:	10800317 	ldw	r2,12(r2)
   114d8:	00c00134 	movhi	r3,4
   114dc:	18d73504 	addi	r3,r3,23764
   114e0:	18c00317 	ldw	r3,12(r3)
   114e4:	18c0030b 	ldhu	r3,12(r3)
   114e8:	18c04014 	ori	r3,r3,256
   114ec:	10c0030d 	sth	r3,12(r2)
                tcplen = TCP_TCPLEN(&inseg);
   114f0:	00800134 	movhi	r2,4
   114f4:	10973504 	addi	r2,r2,23764
   114f8:	10c0020b 	ldhu	r3,8(r2)
   114fc:	00800134 	movhi	r2,4
   11500:	10973504 	addi	r2,r2,23764
   11504:	10800317 	ldw	r2,12(r2)
   11508:	1080030b 	ldhu	r2,12(r2)
   1150c:	10bfffcc 	andi	r2,r2,65535
   11510:	1004d23a 	srli	r2,r2,8
   11514:	113fffcc 	andi	r4,r2,65535
   11518:	00800134 	movhi	r2,4
   1151c:	10973504 	addi	r2,r2,23764
   11520:	10800317 	ldw	r2,12(r2)
   11524:	1080030b 	ldhu	r2,12(r2)
   11528:	10bfffcc 	andi	r2,r2,65535
   1152c:	1004923a 	slli	r2,r2,8
   11530:	10bfffcc 	andi	r2,r2,65535
   11534:	2084b03a 	or	r2,r4,r2
   11538:	108000cc 	andi	r2,r2,3
   1153c:	1004c03a 	cmpne	r2,r2,zero
   11540:	10803fcc 	andi	r2,r2,255
   11544:	1885883a 	add	r2,r3,r2
   11548:	d0a8c68d 	sth	r2,-23782(gp)
              }
              prev = next;
   1154c:	e0bff517 	ldw	r2,-44(fp)
   11550:	e0bff615 	stw	r2,-40(fp)
              next = next->next;
   11554:	e0bff517 	ldw	r2,-44(fp)
   11558:	10800017 	ldw	r2,0(r2)
   1155c:	e0bff515 	stw	r2,-44(fp)
              tcp_seg_free(prev);
   11560:	e13ff617 	ldw	r4,-40(fp)
   11564:	000da080 	call	da08 <tcp_seg_free>
            }
          } else {
            next = pcb->ooseq;
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
   11568:	e0bff517 	ldw	r2,-44(fp)
   1156c:	10001126 	beq	r2,zero,115b4 <tcp_receive+0x128c>
                   TCP_SEQ_GEQ(seqno + tcplen,
   11570:	d0a8c68b 	ldhu	r2,-23782(gp)
   11574:	10ffffcc 	andi	r3,r2,65535
   11578:	d0a8c417 	ldw	r2,-23792(gp)
   1157c:	1887883a 	add	r3,r3,r2
   11580:	e0bff517 	ldw	r2,-44(fp)
   11584:	10800317 	ldw	r2,12(r2)
   11588:	1100010b 	ldhu	r4,4(r2)
   1158c:	1080018b 	ldhu	r2,6(r2)
   11590:	1004943a 	slli	r2,r2,16
   11594:	1104b03a 	or	r2,r2,r4
   11598:	1009883a 	mov	r4,r2
   1159c:	e0bff517 	ldw	r2,-44(fp)
   115a0:	1080020b 	ldhu	r2,8(r2)
   115a4:	10bfffcc 	andi	r2,r2,65535
   115a8:	2085883a 	add	r2,r4,r2
   115ac:	1885c83a 	sub	r2,r3,r2
            }
          } else {
            next = pcb->ooseq;
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
   115b0:	103fa60e 	bge	r2,zero,1144c <tcp_receive+0x1124>
              next = next->next;
              tcp_seg_free(prev);
            }
            /* Now trim right side of inseg if it overlaps with the first
             * segment on ooseq */
            if (next &&
   115b4:	e0bff517 	ldw	r2,-44(fp)
   115b8:	10006726 	beq	r2,zero,11758 <tcp_receive+0x1430>
                TCP_SEQ_GT(seqno + tcplen,
   115bc:	d0a8c68b 	ldhu	r2,-23782(gp)
   115c0:	10ffffcc 	andi	r3,r2,65535
   115c4:	d0a8c417 	ldw	r2,-23792(gp)
   115c8:	1887883a 	add	r3,r3,r2
   115cc:	e0bff517 	ldw	r2,-44(fp)
   115d0:	10800317 	ldw	r2,12(r2)
   115d4:	1100010b 	ldhu	r4,4(r2)
   115d8:	1080018b 	ldhu	r2,6(r2)
   115dc:	1004943a 	slli	r2,r2,16
   115e0:	1104b03a 	or	r2,r2,r4
   115e4:	1885c83a 	sub	r2,r3,r2
              next = next->next;
              tcp_seg_free(prev);
            }
            /* Now trim right side of inseg if it overlaps with the first
             * segment on ooseq */
            if (next &&
   115e8:	00805b0e 	bge	zero,r2,11758 <tcp_receive+0x1430>
                TCP_SEQ_GT(seqno + tcplen,
                           next->tcphdr->seqno)) {
              /* inseg cannot have FIN here (already processed above) */
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
   115ec:	e0bff517 	ldw	r2,-44(fp)
   115f0:	10800317 	ldw	r2,12(r2)
   115f4:	10c0010b 	ldhu	r3,4(r2)
   115f8:	1080018b 	ldhu	r2,6(r2)
   115fc:	1004943a 	slli	r2,r2,16
   11600:	10c4b03a 	or	r2,r2,r3
   11604:	1007883a 	mov	r3,r2
   11608:	d0a8c417 	ldw	r2,-23792(gp)
   1160c:	1885c83a 	sub	r2,r3,r2
   11610:	1007883a 	mov	r3,r2
   11614:	00800134 	movhi	r2,4
   11618:	10973504 	addi	r2,r2,23764
   1161c:	10c0020d 	sth	r3,8(r2)
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
   11620:	00800134 	movhi	r2,4
   11624:	10973504 	addi	r2,r2,23764
   11628:	10800317 	ldw	r2,12(r2)
   1162c:	1080030b 	ldhu	r2,12(r2)
   11630:	10bfffcc 	andi	r2,r2,65535
   11634:	1004d23a 	srli	r2,r2,8
   11638:	10ffffcc 	andi	r3,r2,65535
   1163c:	00800134 	movhi	r2,4
   11640:	10973504 	addi	r2,r2,23764
   11644:	10800317 	ldw	r2,12(r2)
   11648:	1080030b 	ldhu	r2,12(r2)
   1164c:	10bfffcc 	andi	r2,r2,65535
   11650:	1004923a 	slli	r2,r2,8
   11654:	10bfffcc 	andi	r2,r2,65535
   11658:	1884b03a 	or	r2,r3,r2
   1165c:	1080008c 	andi	r2,r2,2
   11660:	10000826 	beq	r2,zero,11684 <tcp_receive+0x135c>
                inseg.len -= 1;
   11664:	00800134 	movhi	r2,4
   11668:	10973504 	addi	r2,r2,23764
   1166c:	1080020b 	ldhu	r2,8(r2)
   11670:	10bfffc4 	addi	r2,r2,-1
   11674:	1007883a 	mov	r3,r2
   11678:	00800134 	movhi	r2,4
   1167c:	10973504 	addi	r2,r2,23764
   11680:	10c0020d 	sth	r3,8(r2)
              }
              pbuf_realloc(inseg.p, inseg.len);
   11684:	00800134 	movhi	r2,4
   11688:	10973504 	addi	r2,r2,23764
   1168c:	10c00117 	ldw	r3,4(r2)
   11690:	00800134 	movhi	r2,4
   11694:	10973504 	addi	r2,r2,23764
   11698:	1080020b 	ldhu	r2,8(r2)
   1169c:	10bfffcc 	andi	r2,r2,65535
   116a0:	1809883a 	mov	r4,r3
   116a4:	100b883a 	mov	r5,r2
   116a8:	000a5b80 	call	a5b8 <pbuf_realloc>
              tcplen = TCP_TCPLEN(&inseg);
   116ac:	00800134 	movhi	r2,4
   116b0:	10973504 	addi	r2,r2,23764
   116b4:	10c0020b 	ldhu	r3,8(r2)
   116b8:	00800134 	movhi	r2,4
   116bc:	10973504 	addi	r2,r2,23764
   116c0:	10800317 	ldw	r2,12(r2)
   116c4:	1080030b 	ldhu	r2,12(r2)
   116c8:	10bfffcc 	andi	r2,r2,65535
   116cc:	1004d23a 	srli	r2,r2,8
   116d0:	113fffcc 	andi	r4,r2,65535
   116d4:	00800134 	movhi	r2,4
   116d8:	10973504 	addi	r2,r2,23764
   116dc:	10800317 	ldw	r2,12(r2)
   116e0:	1080030b 	ldhu	r2,12(r2)
   116e4:	10bfffcc 	andi	r2,r2,65535
   116e8:	1004923a 	slli	r2,r2,8
   116ec:	10bfffcc 	andi	r2,r2,65535
   116f0:	2084b03a 	or	r2,r4,r2
   116f4:	108000cc 	andi	r2,r2,3
   116f8:	1004c03a 	cmpne	r2,r2,zero
   116fc:	10803fcc 	andi	r2,r2,255
   11700:	1885883a 	add	r2,r3,r2
   11704:	d0a8c68d 	sth	r2,-23782(gp)
              LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
   11708:	d0a8c68b 	ldhu	r2,-23782(gp)
   1170c:	10ffffcc 	andi	r3,r2,65535
   11710:	d0a8c417 	ldw	r2,-23792(gp)
   11714:	1887883a 	add	r3,r3,r2
   11718:	e0bff517 	ldw	r2,-44(fp)
   1171c:	10800317 	ldw	r2,12(r2)
   11720:	1100010b 	ldhu	r4,4(r2)
   11724:	1080018b 	ldhu	r2,6(r2)
   11728:	1004943a 	slli	r2,r2,16
   1172c:	1104b03a 	or	r2,r2,r4
   11730:	18800926 	beq	r3,r2,11758 <tcp_receive+0x1430>
   11734:	010000f4 	movhi	r4,3
   11738:	2101fd04 	addi	r4,r4,2036
   1173c:	014000f4 	movhi	r5,3
   11740:	2942a004 	addi	r5,r5,2688
   11744:	01814204 	movi	r6,1288
   11748:	01c000f4 	movhi	r7,3
   1174c:	39c21104 	addi	r7,r7,2116
   11750:	00193f00 	call	193f0 <printf>
   11754:	003fff06 	br	11754 <tcp_receive+0x142c>
                          (seqno + tcplen) == next->tcphdr->seqno);
            }
            pcb->ooseq = next;
   11758:	e0bfff17 	ldw	r2,-4(fp)
   1175c:	e0fff517 	ldw	r3,-44(fp)
   11760:	10c01e15 	stw	r3,120(r2)
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;
   11764:	d0a8c68b 	ldhu	r2,-23782(gp)
   11768:	10ffffcc 	andi	r3,r2,65535
   1176c:	d0a8c417 	ldw	r2,-23792(gp)
   11770:	1887883a 	add	r3,r3,r2
   11774:	e0bfff17 	ldw	r2,-4(fp)
   11778:	10c00b15 	stw	r3,44(r2)

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
   1177c:	e0bfff17 	ldw	r2,-4(fp)
   11780:	10c00c0b 	ldhu	r3,48(r2)
   11784:	d0a8c68b 	ldhu	r2,-23782(gp)
   11788:	18ffffcc 	andi	r3,r3,65535
   1178c:	10bfffcc 	andi	r2,r2,65535
   11790:	1880092e 	bgeu	r3,r2,117b8 <tcp_receive+0x1490>
   11794:	010000f4 	movhi	r4,3
   11798:	2101fd04 	addi	r4,r4,2036
   1179c:	014000f4 	movhi	r5,3
   117a0:	2942af04 	addi	r5,r5,2748
   117a4:	01814484 	movi	r6,1298
   117a8:	01c000f4 	movhi	r7,3
   117ac:	39c21104 	addi	r7,r7,2116
   117b0:	00193f00 	call	193f0 <printf>
   117b4:	003fff06 	br	117b4 <tcp_receive+0x148c>
        pcb->rcv_wnd -= tcplen;
   117b8:	e0bfff17 	ldw	r2,-4(fp)
   117bc:	10c00c0b 	ldhu	r3,48(r2)
   117c0:	d0a8c68b 	ldhu	r2,-23782(gp)
   117c4:	1885c83a 	sub	r2,r3,r2
   117c8:	1007883a 	mov	r3,r2
   117cc:	e0bfff17 	ldw	r2,-4(fp)
   117d0:	10c00c0d 	sth	r3,48(r2)

        tcp_update_rcv_ann_wnd(pcb);
   117d4:	e13fff17 	ldw	r4,-4(fp)
   117d8:	000c8f00 	call	c8f0 <tcp_update_rcv_ann_wnd>
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
   117dc:	00800134 	movhi	r2,4
   117e0:	10973504 	addi	r2,r2,23764
   117e4:	10800117 	ldw	r2,4(r2)
   117e8:	1080020b 	ldhu	r2,8(r2)
   117ec:	10bfffcc 	andi	r2,r2,65535
   117f0:	10000726 	beq	r2,zero,11810 <tcp_receive+0x14e8>
          recv_data = inseg.p;
   117f4:	00800134 	movhi	r2,4
   117f8:	10973504 	addi	r2,r2,23764
   117fc:	10800117 	ldw	r2,4(r2)
   11800:	d0a8c815 	stw	r2,-23776(gp)
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
   11804:	00800134 	movhi	r2,4
   11808:	10973504 	addi	r2,r2,23764
   1180c:	10000115 	stw	zero,4(r2)
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
   11810:	00800134 	movhi	r2,4
   11814:	10973504 	addi	r2,r2,23764
   11818:	10800317 	ldw	r2,12(r2)
   1181c:	1080030b 	ldhu	r2,12(r2)
   11820:	10bfffcc 	andi	r2,r2,65535
   11824:	1004d23a 	srli	r2,r2,8
   11828:	10ffffcc 	andi	r3,r2,65535
   1182c:	00800134 	movhi	r2,4
   11830:	10973504 	addi	r2,r2,23764
   11834:	10800317 	ldw	r2,12(r2)
   11838:	1080030b 	ldhu	r2,12(r2)
   1183c:	10bfffcc 	andi	r2,r2,65535
   11840:	1004923a 	slli	r2,r2,8
   11844:	10bfffcc 	andi	r2,r2,65535
   11848:	1884b03a 	or	r2,r3,r2
   1184c:	1080004c 	andi	r2,r2,1
   11850:	10009726 	beq	r2,zero,11ab0 <tcp_receive+0x1788>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags |= TF_GOT_FIN;
   11854:	d0a8c703 	ldbu	r2,-23780(gp)
   11858:	10800814 	ori	r2,r2,32
   1185c:	d0a8c705 	stb	r2,-23780(gp)
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
   11860:	00009306 	br	11ab0 <tcp_receive+0x1788>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
   11864:	e0bfff17 	ldw	r2,-4(fp)
   11868:	10801e17 	ldw	r2,120(r2)
   1186c:	e0bffe15 	stw	r2,-8(fp)
          seqno = pcb->ooseq->tcphdr->seqno;
   11870:	e0bfff17 	ldw	r2,-4(fp)
   11874:	10801e17 	ldw	r2,120(r2)
   11878:	10800317 	ldw	r2,12(r2)
   1187c:	10c0010b 	ldhu	r3,4(r2)
   11880:	1080018b 	ldhu	r2,6(r2)
   11884:	1004943a 	slli	r2,r2,16
   11888:	10c4b03a 	or	r2,r2,r3
   1188c:	d0a8c415 	stw	r2,-23792(gp)

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
   11890:	e0bfff17 	ldw	r2,-4(fp)
   11894:	10c00b17 	ldw	r3,44(r2)
   11898:	e0bffe17 	ldw	r2,-8(fp)
   1189c:	1080020b 	ldhu	r2,8(r2)
   118a0:	113fffcc 	andi	r4,r2,65535
   118a4:	e0bffe17 	ldw	r2,-8(fp)
   118a8:	10800317 	ldw	r2,12(r2)
   118ac:	1080030b 	ldhu	r2,12(r2)
   118b0:	10bfffcc 	andi	r2,r2,65535
   118b4:	1004d23a 	srli	r2,r2,8
   118b8:	117fffcc 	andi	r5,r2,65535
   118bc:	e0bffe17 	ldw	r2,-8(fp)
   118c0:	10800317 	ldw	r2,12(r2)
   118c4:	1080030b 	ldhu	r2,12(r2)
   118c8:	10bfffcc 	andi	r2,r2,65535
   118cc:	1004923a 	slli	r2,r2,8
   118d0:	10bfffcc 	andi	r2,r2,65535
   118d4:	2884b03a 	or	r2,r5,r2
   118d8:	108000cc 	andi	r2,r2,3
   118dc:	1004c03a 	cmpne	r2,r2,zero
   118e0:	10803fcc 	andi	r2,r2,255
   118e4:	2085883a 	add	r2,r4,r2
   118e8:	1887883a 	add	r3,r3,r2
   118ec:	e0bfff17 	ldw	r2,-4(fp)
   118f0:	10c00b15 	stw	r3,44(r2)
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
   118f4:	e0bfff17 	ldw	r2,-4(fp)
   118f8:	10800c0b 	ldhu	r2,48(r2)
   118fc:	10ffffcc 	andi	r3,r2,65535
   11900:	e0bffe17 	ldw	r2,-8(fp)
   11904:	1080020b 	ldhu	r2,8(r2)
   11908:	113fffcc 	andi	r4,r2,65535
   1190c:	e0bffe17 	ldw	r2,-8(fp)
   11910:	10800317 	ldw	r2,12(r2)
   11914:	1080030b 	ldhu	r2,12(r2)
   11918:	10bfffcc 	andi	r2,r2,65535
   1191c:	1004d23a 	srli	r2,r2,8
   11920:	117fffcc 	andi	r5,r2,65535
   11924:	e0bffe17 	ldw	r2,-8(fp)
   11928:	10800317 	ldw	r2,12(r2)
   1192c:	1080030b 	ldhu	r2,12(r2)
   11930:	10bfffcc 	andi	r2,r2,65535
   11934:	1004923a 	slli	r2,r2,8
   11938:	10bfffcc 	andi	r2,r2,65535
   1193c:	2884b03a 	or	r2,r5,r2
   11940:	108000cc 	andi	r2,r2,3
   11944:	1004c03a 	cmpne	r2,r2,zero
   11948:	10803fcc 	andi	r2,r2,255
   1194c:	2085883a 	add	r2,r4,r2
   11950:	1880090e 	bge	r3,r2,11978 <tcp_receive+0x1650>
   11954:	010000f4 	movhi	r4,3
   11958:	2101fd04 	addi	r4,r4,2036
   1195c:	014000f4 	movhi	r5,3
   11960:	2942b704 	addi	r5,r5,2780
   11964:	01814dc4 	movi	r6,1335
   11968:	01c000f4 	movhi	r7,3
   1196c:	39c21104 	addi	r7,r7,2116
   11970:	00193f00 	call	193f0 <printf>
   11974:	003fff06 	br	11974 <tcp_receive+0x164c>
                      pcb->rcv_wnd >= TCP_TCPLEN(cseg));
          pcb->rcv_wnd -= TCP_TCPLEN(cseg);
   11978:	e0bfff17 	ldw	r2,-4(fp)
   1197c:	10c00c0b 	ldhu	r3,48(r2)
   11980:	e0bffe17 	ldw	r2,-8(fp)
   11984:	1100020b 	ldhu	r4,8(r2)
   11988:	e0bffe17 	ldw	r2,-8(fp)
   1198c:	10800317 	ldw	r2,12(r2)
   11990:	1080030b 	ldhu	r2,12(r2)
   11994:	10bfffcc 	andi	r2,r2,65535
   11998:	1004d23a 	srli	r2,r2,8
   1199c:	117fffcc 	andi	r5,r2,65535
   119a0:	e0bffe17 	ldw	r2,-8(fp)
   119a4:	10800317 	ldw	r2,12(r2)
   119a8:	1080030b 	ldhu	r2,12(r2)
   119ac:	10bfffcc 	andi	r2,r2,65535
   119b0:	1004923a 	slli	r2,r2,8
   119b4:	10bfffcc 	andi	r2,r2,65535
   119b8:	2884b03a 	or	r2,r5,r2
   119bc:	108000cc 	andi	r2,r2,3
   119c0:	1004c03a 	cmpne	r2,r2,zero
   119c4:	10803fcc 	andi	r2,r2,255
   119c8:	2085883a 	add	r2,r4,r2
   119cc:	1885c83a 	sub	r2,r3,r2
   119d0:	1007883a 	mov	r3,r2
   119d4:	e0bfff17 	ldw	r2,-4(fp)
   119d8:	10c00c0d 	sth	r3,48(r2)

          tcp_update_rcv_ann_wnd(pcb);
   119dc:	e13fff17 	ldw	r4,-4(fp)
   119e0:	000c8f00 	call	c8f0 <tcp_update_rcv_ann_wnd>

          if (cseg->p->tot_len > 0) {
   119e4:	e0bffe17 	ldw	r2,-8(fp)
   119e8:	10800117 	ldw	r2,4(r2)
   119ec:	1080020b 	ldhu	r2,8(r2)
   119f0:	10bfffcc 	andi	r2,r2,65535
   119f4:	10000e26 	beq	r2,zero,11a30 <tcp_receive+0x1708>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
   119f8:	d0a8c817 	ldw	r2,-23776(gp)
   119fc:	10000726 	beq	r2,zero,11a1c <tcp_receive+0x16f4>
              pbuf_cat(recv_data, cseg->p);
   11a00:	d0e8c817 	ldw	r3,-23776(gp)
   11a04:	e0bffe17 	ldw	r2,-8(fp)
   11a08:	10800117 	ldw	r2,4(r2)
   11a0c:	1809883a 	mov	r4,r3
   11a10:	100b883a 	mov	r5,r2
   11a14:	000ac8c0 	call	ac8c <pbuf_cat>
   11a18:	00000306 	br	11a28 <tcp_receive+0x1700>
            } else {
              recv_data = cseg->p;
   11a1c:	e0bffe17 	ldw	r2,-8(fp)
   11a20:	10800117 	ldw	r2,4(r2)
   11a24:	d0a8c815 	stw	r2,-23776(gp)
            }
            cseg->p = NULL;
   11a28:	e0bffe17 	ldw	r2,-8(fp)
   11a2c:	10000115 	stw	zero,4(r2)
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
   11a30:	e0bffe17 	ldw	r2,-8(fp)
   11a34:	10800317 	ldw	r2,12(r2)
   11a38:	1080030b 	ldhu	r2,12(r2)
   11a3c:	10bfffcc 	andi	r2,r2,65535
   11a40:	1004d23a 	srli	r2,r2,8
   11a44:	10ffffcc 	andi	r3,r2,65535
   11a48:	e0bffe17 	ldw	r2,-8(fp)
   11a4c:	10800317 	ldw	r2,12(r2)
   11a50:	1080030b 	ldhu	r2,12(r2)
   11a54:	10bfffcc 	andi	r2,r2,65535
   11a58:	1004923a 	slli	r2,r2,8
   11a5c:	10bfffcc 	andi	r2,r2,65535
   11a60:	1884b03a 	or	r2,r3,r2
   11a64:	1080004c 	andi	r2,r2,1
   11a68:	10000a26 	beq	r2,zero,11a94 <tcp_receive+0x176c>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags |= TF_GOT_FIN;
   11a6c:	d0a8c703 	ldbu	r2,-23780(gp)
   11a70:	10800814 	ori	r2,r2,32
   11a74:	d0a8c705 	stb	r2,-23780(gp)
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
   11a78:	e0bfff17 	ldw	r2,-4(fp)
   11a7c:	10800617 	ldw	r2,24(r2)
   11a80:	10800118 	cmpnei	r2,r2,4
   11a84:	1000031e 	bne	r2,zero,11a94 <tcp_receive+0x176c>
              pcb->state = CLOSE_WAIT;
   11a88:	e0bfff17 	ldw	r2,-4(fp)
   11a8c:	00c001c4 	movi	r3,7
   11a90:	10c00615 	stw	r3,24(r2)
            } 
          }

          pcb->ooseq = cseg->next;
   11a94:	e0bffe17 	ldw	r2,-8(fp)
   11a98:	10c00017 	ldw	r3,0(r2)
   11a9c:	e0bfff17 	ldw	r2,-4(fp)
   11aa0:	10c01e15 	stw	r3,120(r2)
          tcp_seg_free(cseg);
   11aa4:	e13ffe17 	ldw	r4,-8(fp)
   11aa8:	000da080 	call	da08 <tcp_seg_free>
   11aac:	00000106 	br	11ab4 <tcp_receive+0x178c>
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
   11ab0:	0001883a 	nop
   11ab4:	e0bfff17 	ldw	r2,-4(fp)
   11ab8:	10801e17 	ldw	r2,120(r2)
   11abc:	10000b26 	beq	r2,zero,11aec <tcp_receive+0x17c4>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
   11ac0:	e0bfff17 	ldw	r2,-4(fp)
   11ac4:	10801e17 	ldw	r2,120(r2)
   11ac8:	10800317 	ldw	r2,12(r2)
   11acc:	10c0010b 	ldhu	r3,4(r2)
   11ad0:	1080018b 	ldhu	r2,6(r2)
   11ad4:	1004943a 	slli	r2,r2,16
   11ad8:	10c4b03a 	or	r2,r2,r3
   11adc:	1007883a 	mov	r3,r2
   11ae0:	e0bfff17 	ldw	r2,-4(fp)
   11ae4:	10800b17 	ldw	r2,44(r2)
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
   11ae8:	18bf5e26 	beq	r3,r2,11864 <tcp_receive+0x153c>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
   11aec:	e0bfff17 	ldw	r2,-4(fp)
   11af0:	10800883 	ldbu	r2,34(r2)
   11af4:	10803fcc 	andi	r2,r2,255
   11af8:	1080004c 	andi	r2,r2,1
   11afc:	10000e26 	beq	r2,zero,11b38 <tcp_receive+0x1810>
   11b00:	e0bfff17 	ldw	r2,-4(fp)
   11b04:	10c00883 	ldbu	r3,34(r2)
   11b08:	00bfff84 	movi	r2,-2
   11b0c:	1884703a 	and	r2,r3,r2
   11b10:	1007883a 	mov	r3,r2
   11b14:	e0bfff17 	ldw	r2,-4(fp)
   11b18:	10c00885 	stb	r3,34(r2)
   11b1c:	e0bfff17 	ldw	r2,-4(fp)
   11b20:	10800883 	ldbu	r2,34(r2)
   11b24:	10800094 	ori	r2,r2,2
   11b28:	1007883a 	mov	r3,r2
   11b2c:	e0bfff17 	ldw	r2,-4(fp)
   11b30:	10c00885 	stb	r3,34(r2)
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
   11b34:	00016b06 	br	120e4 <tcp_receive+0x1dbc>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
   11b38:	e0bfff17 	ldw	r2,-4(fp)
   11b3c:	10800883 	ldbu	r2,34(r2)
   11b40:	10800054 	ori	r2,r2,1
   11b44:	1007883a 	mov	r3,r2
   11b48:	e0bfff17 	ldw	r2,-4(fp)
   11b4c:	10c00885 	stb	r3,34(r2)
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
   11b50:	00016406 	br	120e4 <tcp_receive+0x1dbc>
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_send_empty_ack(pcb);
   11b54:	e13fff17 	ldw	r4,-4(fp)
   11b58:	001392c0 	call	1392c <tcp_send_empty_ack>
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
   11b5c:	e0bfff17 	ldw	r2,-4(fp)
   11b60:	10801e17 	ldw	r2,120(r2)
   11b64:	1000061e 	bne	r2,zero,11b80 <tcp_receive+0x1858>
          pcb->ooseq = tcp_seg_copy(&inseg);
   11b68:	01000134 	movhi	r4,4
   11b6c:	21173504 	addi	r4,r4,23764
   11b70:	000da940 	call	da94 <tcp_seg_copy>
   11b74:	e0ffff17 	ldw	r3,-4(fp)
   11b78:	18801e15 	stw	r2,120(r3)
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
   11b7c:	00015906 	br	120e4 <tcp_receive+0x1dbc>

             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
   11b80:	e03ff615 	stw	zero,-40(fp)
          for(next = pcb->ooseq; next != NULL; next = next->next) {
   11b84:	e0bfff17 	ldw	r2,-4(fp)
   11b88:	10801e17 	ldw	r2,120(r2)
   11b8c:	e0bff515 	stw	r2,-44(fp)
   11b90:	00014206 	br	1209c <tcp_receive+0x1d74>
            if (seqno == next->tcphdr->seqno) {
   11b94:	e0bff517 	ldw	r2,-44(fp)
   11b98:	10800317 	ldw	r2,12(r2)
   11b9c:	10c0010b 	ldhu	r3,4(r2)
   11ba0:	1080018b 	ldhu	r2,6(r2)
   11ba4:	1004943a 	slli	r2,r2,16
   11ba8:	10c4b03a 	or	r2,r2,r3
   11bac:	1007883a 	mov	r3,r2
   11bb0:	d0a8c417 	ldw	r2,-23792(gp)
   11bb4:	18801b1e 	bne	r3,r2,11c24 <tcp_receive+0x18fc>
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
   11bb8:	00800134 	movhi	r2,4
   11bbc:	10973504 	addi	r2,r2,23764
   11bc0:	1080020b 	ldhu	r2,8(r2)
   11bc4:	e0fff517 	ldw	r3,-44(fp)
   11bc8:	18c0020b 	ldhu	r3,8(r3)
   11bcc:	10bfffcc 	andi	r2,r2,65535
   11bd0:	18ffffcc 	andi	r3,r3,65535
   11bd4:	1881342e 	bgeu	r3,r2,120a8 <tcp_receive+0x1d80>
                /* The incoming segment is larger than the old
                   segment. We replace some segments with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
   11bd8:	01000134 	movhi	r4,4
   11bdc:	21173504 	addi	r4,r4,23764
   11be0:	000da940 	call	da94 <tcp_seg_copy>
   11be4:	e0bffe15 	stw	r2,-8(fp)
                if (cseg != NULL) {
   11be8:	e0bffe17 	ldw	r2,-8(fp)
   11bec:	10013026 	beq	r2,zero,120b0 <tcp_receive+0x1d88>
                  if (prev != NULL) {
   11bf0:	e0bff617 	ldw	r2,-40(fp)
   11bf4:	10000426 	beq	r2,zero,11c08 <tcp_receive+0x18e0>
                    prev->next = cseg;
   11bf8:	e0bff617 	ldw	r2,-40(fp)
   11bfc:	e0fffe17 	ldw	r3,-8(fp)
   11c00:	10c00015 	stw	r3,0(r2)
   11c04:	00000306 	br	11c14 <tcp_receive+0x18ec>
                  } else {
                    pcb->ooseq = cseg;
   11c08:	e0bfff17 	ldw	r2,-4(fp)
   11c0c:	e0fffe17 	ldw	r3,-8(fp)
   11c10:	10c01e15 	stw	r3,120(r2)
                  }
                  tcp_oos_insert_segment(cseg, next);
   11c14:	e13ffe17 	ldw	r4,-8(fp)
   11c18:	e17ff517 	ldw	r5,-44(fp)
   11c1c:	00101540 	call	10154 <tcp_oos_insert_segment>
                }
                break;
   11c20:	00012306 	br	120b0 <tcp_receive+0x1d88>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
   11c24:	e0bff617 	ldw	r2,-40(fp)
   11c28:	1000161e 	bne	r2,zero,11c84 <tcp_receive+0x195c>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
   11c2c:	d0e8c417 	ldw	r3,-23792(gp)
   11c30:	e0bff517 	ldw	r2,-44(fp)
   11c34:	10800317 	ldw	r2,12(r2)
   11c38:	1100010b 	ldhu	r4,4(r2)
   11c3c:	1080018b 	ldhu	r2,6(r2)
   11c40:	1004943a 	slli	r2,r2,16
   11c44:	1104b03a 	or	r2,r2,r4
   11c48:	1885c83a 	sub	r2,r3,r2
   11c4c:	1000500e 	bge	r2,zero,11d90 <tcp_receive+0x1a68>
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */
                  cseg = tcp_seg_copy(&inseg);
   11c50:	01000134 	movhi	r4,4
   11c54:	21173504 	addi	r4,r4,23764
   11c58:	000da940 	call	da94 <tcp_seg_copy>
   11c5c:	e0bffe15 	stw	r2,-8(fp)
                  if (cseg != NULL) {
   11c60:	e0bffe17 	ldw	r2,-8(fp)
   11c64:	10011426 	beq	r2,zero,120b8 <tcp_receive+0x1d90>
                    pcb->ooseq = cseg;
   11c68:	e0bfff17 	ldw	r2,-4(fp)
   11c6c:	e0fffe17 	ldw	r3,-8(fp)
   11c70:	10c01e15 	stw	r3,120(r2)
                    tcp_oos_insert_segment(cseg, next);
   11c74:	e13ffe17 	ldw	r4,-8(fp)
   11c78:	e17ff517 	ldw	r5,-44(fp)
   11c7c:	00101540 	call	10154 <tcp_oos_insert_segment>
                  }
                  break;
   11c80:	00010d06 	br	120b8 <tcp_receive+0x1d90>
                }
              } else {
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
   11c84:	e0bff617 	ldw	r2,-40(fp)
   11c88:	10800317 	ldw	r2,12(r2)
   11c8c:	10c0010b 	ldhu	r3,4(r2)
   11c90:	1080018b 	ldhu	r2,6(r2)
   11c94:	1004943a 	slli	r2,r2,16
   11c98:	10c4b03a 	or	r2,r2,r3
   11c9c:	0086303a 	nor	r3,zero,r2
   11ca0:	d0a8c417 	ldw	r2,-23792(gp)
   11ca4:	1885883a 	add	r2,r3,r2
   11ca8:	10003916 	blt	r2,zero,11d90 <tcp_receive+0x1a68>
   11cac:	d0e8c417 	ldw	r3,-23792(gp)
   11cb0:	e0bff517 	ldw	r2,-44(fp)
   11cb4:	10800317 	ldw	r2,12(r2)
   11cb8:	1100010b 	ldhu	r4,4(r2)
   11cbc:	1080018b 	ldhu	r2,6(r2)
   11cc0:	1004943a 	slli	r2,r2,16
   11cc4:	1104b03a 	or	r2,r2,r4
   11cc8:	1885c83a 	sub	r2,r3,r2
   11ccc:	10800044 	addi	r2,r2,1
   11cd0:	00802f16 	blt	zero,r2,11d90 <tcp_receive+0x1a68>
                  /* The sequence number of the incoming segment is in
                     between the sequence numbers of the previous and
                     the next segment on ->ooseq. We trim trim the previous
                     segment, delete next segments that included in received segment
                     and trim received, if needed. */
                  cseg = tcp_seg_copy(&inseg);
   11cd4:	01000134 	movhi	r4,4
   11cd8:	21173504 	addi	r4,r4,23764
   11cdc:	000da940 	call	da94 <tcp_seg_copy>
   11ce0:	e0bffe15 	stw	r2,-8(fp)
                  if (cseg != NULL) {
   11ce4:	e0bffe17 	ldw	r2,-8(fp)
   11ce8:	1000f526 	beq	r2,zero,120c0 <tcp_receive+0x1d98>
                    if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
   11cec:	e0bff617 	ldw	r2,-40(fp)
   11cf0:	10800317 	ldw	r2,12(r2)
   11cf4:	10c0010b 	ldhu	r3,4(r2)
   11cf8:	1080018b 	ldhu	r2,6(r2)
   11cfc:	1004943a 	slli	r2,r2,16
   11d00:	10c4b03a 	or	r2,r2,r3
   11d04:	1007883a 	mov	r3,r2
   11d08:	e0bff617 	ldw	r2,-40(fp)
   11d0c:	1080020b 	ldhu	r2,8(r2)
   11d10:	10bfffcc 	andi	r2,r2,65535
   11d14:	1887883a 	add	r3,r3,r2
   11d18:	d0a8c417 	ldw	r2,-23792(gp)
   11d1c:	1885c83a 	sub	r2,r3,r2
   11d20:	0080140e 	bge	zero,r2,11d74 <tcp_receive+0x1a4c>
                      /* We need to trim the prev segment. */
                      prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
   11d24:	d0a8c417 	ldw	r2,-23792(gp)
   11d28:	1007883a 	mov	r3,r2
   11d2c:	e0bff617 	ldw	r2,-40(fp)
   11d30:	10800317 	ldw	r2,12(r2)
   11d34:	1100010b 	ldhu	r4,4(r2)
   11d38:	1080018b 	ldhu	r2,6(r2)
   11d3c:	1004943a 	slli	r2,r2,16
   11d40:	1104b03a 	or	r2,r2,r4
   11d44:	1885c83a 	sub	r2,r3,r2
   11d48:	1007883a 	mov	r3,r2
   11d4c:	e0bff617 	ldw	r2,-40(fp)
   11d50:	10c0020d 	sth	r3,8(r2)
                      pbuf_realloc(prev->p, prev->len);
   11d54:	e0bff617 	ldw	r2,-40(fp)
   11d58:	10c00117 	ldw	r3,4(r2)
   11d5c:	e0bff617 	ldw	r2,-40(fp)
   11d60:	1080020b 	ldhu	r2,8(r2)
   11d64:	10bfffcc 	andi	r2,r2,65535
   11d68:	1809883a 	mov	r4,r3
   11d6c:	100b883a 	mov	r5,r2
   11d70:	000a5b80 	call	a5b8 <pbuf_realloc>
                    }
                    prev->next = cseg;
   11d74:	e0bff617 	ldw	r2,-40(fp)
   11d78:	e0fffe17 	ldw	r3,-8(fp)
   11d7c:	10c00015 	stw	r3,0(r2)
                    tcp_oos_insert_segment(cseg, next);
   11d80:	e13ffe17 	ldw	r4,-8(fp)
   11d84:	e17ff517 	ldw	r5,-44(fp)
   11d88:	00101540 	call	10154 <tcp_oos_insert_segment>
                  }
                  break;
   11d8c:	0000cc06 	br	120c0 <tcp_receive+0x1d98>
                }
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
   11d90:	e0bff517 	ldw	r2,-44(fp)
   11d94:	10800017 	ldw	r2,0(r2)
   11d98:	1000bb1e 	bne	r2,zero,12088 <tcp_receive+0x1d60>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
   11d9c:	d0e8c417 	ldw	r3,-23792(gp)
   11da0:	e0bff517 	ldw	r2,-44(fp)
   11da4:	10800317 	ldw	r2,12(r2)
   11da8:	1100010b 	ldhu	r4,4(r2)
   11dac:	1080018b 	ldhu	r2,6(r2)
   11db0:	1004943a 	slli	r2,r2,16
   11db4:	1104b03a 	or	r2,r2,r4
   11db8:	1885c83a 	sub	r2,r3,r2
                }
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
   11dbc:	0080b20e 	bge	zero,r2,12088 <tcp_receive+0x1d60>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
   11dc0:	e0bff517 	ldw	r2,-44(fp)
   11dc4:	10800317 	ldw	r2,12(r2)
   11dc8:	1080030b 	ldhu	r2,12(r2)
   11dcc:	10bfffcc 	andi	r2,r2,65535
   11dd0:	1004d23a 	srli	r2,r2,8
   11dd4:	10ffffcc 	andi	r3,r2,65535
   11dd8:	e0bff517 	ldw	r2,-44(fp)
   11ddc:	10800317 	ldw	r2,12(r2)
   11de0:	1080030b 	ldhu	r2,12(r2)
   11de4:	10bfffcc 	andi	r2,r2,65535
   11de8:	1004923a 	slli	r2,r2,8
   11dec:	10bfffcc 	andi	r2,r2,65535
   11df0:	1884b03a 	or	r2,r3,r2
   11df4:	1080004c 	andi	r2,r2,1
   11df8:	1000b31e 	bne	r2,zero,120c8 <tcp_receive+0x1da0>
                  /* segment "next" already contains all data */
                  break;
                }
                next->next = tcp_seg_copy(&inseg);
   11dfc:	01000134 	movhi	r4,4
   11e00:	21173504 	addi	r4,r4,23764
   11e04:	000da940 	call	da94 <tcp_seg_copy>
   11e08:	e0fff517 	ldw	r3,-44(fp)
   11e0c:	18800015 	stw	r2,0(r3)
                if (next->next != NULL) {
   11e10:	e0bff517 	ldw	r2,-44(fp)
   11e14:	10800017 	ldw	r2,0(r2)
   11e18:	1000ad26 	beq	r2,zero,120d0 <tcp_receive+0x1da8>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
   11e1c:	e0bff517 	ldw	r2,-44(fp)
   11e20:	10800317 	ldw	r2,12(r2)
   11e24:	10c0010b 	ldhu	r3,4(r2)
   11e28:	1080018b 	ldhu	r2,6(r2)
   11e2c:	1004943a 	slli	r2,r2,16
   11e30:	10c4b03a 	or	r2,r2,r3
   11e34:	1007883a 	mov	r3,r2
   11e38:	e0bff517 	ldw	r2,-44(fp)
   11e3c:	1080020b 	ldhu	r2,8(r2)
   11e40:	10bfffcc 	andi	r2,r2,65535
   11e44:	1887883a 	add	r3,r3,r2
   11e48:	d0a8c417 	ldw	r2,-23792(gp)
   11e4c:	1885c83a 	sub	r2,r3,r2
   11e50:	0080140e 	bge	zero,r2,11ea4 <tcp_receive+0x1b7c>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
   11e54:	d0a8c417 	ldw	r2,-23792(gp)
   11e58:	1007883a 	mov	r3,r2
   11e5c:	e0bff517 	ldw	r2,-44(fp)
   11e60:	10800317 	ldw	r2,12(r2)
   11e64:	1100010b 	ldhu	r4,4(r2)
   11e68:	1080018b 	ldhu	r2,6(r2)
   11e6c:	1004943a 	slli	r2,r2,16
   11e70:	1104b03a 	or	r2,r2,r4
   11e74:	1885c83a 	sub	r2,r3,r2
   11e78:	1007883a 	mov	r3,r2
   11e7c:	e0bff517 	ldw	r2,-44(fp)
   11e80:	10c0020d 	sth	r3,8(r2)
                    pbuf_realloc(next->p, next->len);
   11e84:	e0bff517 	ldw	r2,-44(fp)
   11e88:	10c00117 	ldw	r3,4(r2)
   11e8c:	e0bff517 	ldw	r2,-44(fp)
   11e90:	1080020b 	ldhu	r2,8(r2)
   11e94:	10bfffcc 	andi	r2,r2,65535
   11e98:	1809883a 	mov	r4,r3
   11e9c:	100b883a 	mov	r5,r2
   11ea0:	000a5b80 	call	a5b8 <pbuf_realloc>
                  }
                  /* check if the remote side overruns our receive window */
                  if ((u32_t)tcplen + seqno > pcb->rcv_nxt + (u32_t)pcb->rcv_wnd) {
   11ea4:	d0a8c68b 	ldhu	r2,-23782(gp)
   11ea8:	10ffffcc 	andi	r3,r2,65535
   11eac:	d0a8c417 	ldw	r2,-23792(gp)
   11eb0:	1885883a 	add	r2,r3,r2
   11eb4:	e0ffff17 	ldw	r3,-4(fp)
   11eb8:	19000b17 	ldw	r4,44(r3)
   11ebc:	e0ffff17 	ldw	r3,-4(fp)
   11ec0:	18c00c0b 	ldhu	r3,48(r3)
   11ec4:	18ffffcc 	andi	r3,r3,65535
   11ec8:	20c7883a 	add	r3,r4,r3
   11ecc:	1880802e 	bgeu	r3,r2,120d0 <tcp_receive+0x1da8>
                    LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                                ("tcp_receive: other end overran receive window"
                                 "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                                 seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
                    if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
   11ed0:	e0bff517 	ldw	r2,-44(fp)
   11ed4:	10800017 	ldw	r2,0(r2)
   11ed8:	10800317 	ldw	r2,12(r2)
   11edc:	1080030b 	ldhu	r2,12(r2)
   11ee0:	10bfffcc 	andi	r2,r2,65535
   11ee4:	1004d23a 	srli	r2,r2,8
   11ee8:	10ffffcc 	andi	r3,r2,65535
   11eec:	e0bff517 	ldw	r2,-44(fp)
   11ef0:	10800017 	ldw	r2,0(r2)
   11ef4:	10800317 	ldw	r2,12(r2)
   11ef8:	1080030b 	ldhu	r2,12(r2)
   11efc:	10bfffcc 	andi	r2,r2,65535
   11f00:	1004923a 	slli	r2,r2,8
   11f04:	10bfffcc 	andi	r2,r2,65535
   11f08:	1884b03a 	or	r2,r3,r2
   11f0c:	1080004c 	andi	r2,r2,1
   11f10:	10001c26 	beq	r2,zero,11f84 <tcp_receive+0x1c5c>
                      /* Must remove the FIN from the header as we're trimming 
                       * that byte of sequence-space from the packet */
                      TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) &~ TCP_FIN);
   11f14:	e0bff517 	ldw	r2,-44(fp)
   11f18:	10800017 	ldw	r2,0(r2)
   11f1c:	10800317 	ldw	r2,12(r2)
   11f20:	e0fff517 	ldw	r3,-44(fp)
   11f24:	18c00017 	ldw	r3,0(r3)
   11f28:	18c00317 	ldw	r3,12(r3)
   11f2c:	1900030b 	ldhu	r4,12(r3)
   11f30:	00f03fc4 	movi	r3,-16129
   11f34:	20c6703a 	and	r3,r4,r3
   11f38:	1809883a 	mov	r4,r3
   11f3c:	e0fff517 	ldw	r3,-44(fp)
   11f40:	18c00017 	ldw	r3,0(r3)
   11f44:	18c00317 	ldw	r3,12(r3)
   11f48:	18c0030b 	ldhu	r3,12(r3)
   11f4c:	18ffffcc 	andi	r3,r3,65535
   11f50:	1806d23a 	srli	r3,r3,8
   11f54:	180b883a 	mov	r5,r3
   11f58:	e0fff517 	ldw	r3,-44(fp)
   11f5c:	18c00017 	ldw	r3,0(r3)
   11f60:	18c00317 	ldw	r3,12(r3)
   11f64:	18c0030b 	ldhu	r3,12(r3)
   11f68:	18ffffcc 	andi	r3,r3,65535
   11f6c:	1806923a 	slli	r3,r3,8
   11f70:	28c6b03a 	or	r3,r5,r3
   11f74:	18c00f8c 	andi	r3,r3,62
   11f78:	1806923a 	slli	r3,r3,8
   11f7c:	20c6b03a 	or	r3,r4,r3
   11f80:	10c0030d 	sth	r3,12(r2)
                    }
                    /* Adjust length of segment to fit in the window. */
                    next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
   11f84:	e0bff517 	ldw	r2,-44(fp)
   11f88:	10800017 	ldw	r2,0(r2)
   11f8c:	e0ffff17 	ldw	r3,-4(fp)
   11f90:	18c00b17 	ldw	r3,44(r3)
   11f94:	1809883a 	mov	r4,r3
   11f98:	e0ffff17 	ldw	r3,-4(fp)
   11f9c:	18c00c0b 	ldhu	r3,48(r3)
   11fa0:	20c7883a 	add	r3,r4,r3
   11fa4:	1809883a 	mov	r4,r3
   11fa8:	d0e8c417 	ldw	r3,-23792(gp)
   11fac:	20c7c83a 	sub	r3,r4,r3
   11fb0:	10c0020d 	sth	r3,8(r2)
                    pbuf_realloc(next->next->p, next->next->len);
   11fb4:	e0bff517 	ldw	r2,-44(fp)
   11fb8:	10800017 	ldw	r2,0(r2)
   11fbc:	10c00117 	ldw	r3,4(r2)
   11fc0:	e0bff517 	ldw	r2,-44(fp)
   11fc4:	10800017 	ldw	r2,0(r2)
   11fc8:	1080020b 	ldhu	r2,8(r2)
   11fcc:	10bfffcc 	andi	r2,r2,65535
   11fd0:	1809883a 	mov	r4,r3
   11fd4:	100b883a 	mov	r5,r2
   11fd8:	000a5b80 	call	a5b8 <pbuf_realloc>
                    tcplen = TCP_TCPLEN(next->next);
   11fdc:	e0bff517 	ldw	r2,-44(fp)
   11fe0:	10800017 	ldw	r2,0(r2)
   11fe4:	10c0020b 	ldhu	r3,8(r2)
   11fe8:	e0bff517 	ldw	r2,-44(fp)
   11fec:	10800017 	ldw	r2,0(r2)
   11ff0:	10800317 	ldw	r2,12(r2)
   11ff4:	1080030b 	ldhu	r2,12(r2)
   11ff8:	10bfffcc 	andi	r2,r2,65535
   11ffc:	1004d23a 	srli	r2,r2,8
   12000:	113fffcc 	andi	r4,r2,65535
   12004:	e0bff517 	ldw	r2,-44(fp)
   12008:	10800017 	ldw	r2,0(r2)
   1200c:	10800317 	ldw	r2,12(r2)
   12010:	1080030b 	ldhu	r2,12(r2)
   12014:	10bfffcc 	andi	r2,r2,65535
   12018:	1004923a 	slli	r2,r2,8
   1201c:	10bfffcc 	andi	r2,r2,65535
   12020:	2084b03a 	or	r2,r4,r2
   12024:	108000cc 	andi	r2,r2,3
   12028:	1004c03a 	cmpne	r2,r2,zero
   1202c:	10803fcc 	andi	r2,r2,255
   12030:	1885883a 	add	r2,r3,r2
   12034:	d0a8c68d 	sth	r2,-23782(gp)
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
   12038:	d0a8c68b 	ldhu	r2,-23782(gp)
   1203c:	10ffffcc 	andi	r3,r2,65535
   12040:	d0a8c417 	ldw	r2,-23792(gp)
   12044:	1887883a 	add	r3,r3,r2
   12048:	e0bfff17 	ldw	r2,-4(fp)
   1204c:	11000b17 	ldw	r4,44(r2)
   12050:	e0bfff17 	ldw	r2,-4(fp)
   12054:	10800c0b 	ldhu	r2,48(r2)
   12058:	10bfffcc 	andi	r2,r2,65535
   1205c:	2085883a 	add	r2,r4,r2
   12060:	18801b26 	beq	r3,r2,120d0 <tcp_receive+0x1da8>
   12064:	010000f4 	movhi	r4,3
   12068:	2101fd04 	addi	r4,r4,2036
   1206c:	014000f4 	movhi	r5,3
   12070:	29429204 	addi	r5,r5,2632
   12074:	01817284 	movi	r6,1482
   12078:	01c000f4 	movhi	r7,3
   1207c:	39c21104 	addi	r7,r7,2116
   12080:	00193f00 	call	193f0 <printf>
   12084:	003fff06 	br	12084 <tcp_receive+0x1d5c>
                  }
                }
                break;
              }
            }
            prev = next;
   12088:	e0bff517 	ldw	r2,-44(fp)
   1208c:	e0bff615 	stw	r2,-40(fp)
             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
   12090:	e0bff517 	ldw	r2,-44(fp)
   12094:	10800017 	ldw	r2,0(r2)
   12098:	e0bff515 	stw	r2,-44(fp)
   1209c:	e0bff517 	ldw	r2,-44(fp)
   120a0:	103ebc1e 	bne	r2,zero,11b94 <tcp_receive+0x186c>
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
   120a4:	00000f06 	br	120e4 <tcp_receive+0x1dbc>
                break;
              } else {
                /* Either the lenghts are the same or the incoming
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
   120a8:	0001883a 	nop
   120ac:	00000906 	br	120d4 <tcp_receive+0x1dac>
                  } else {
                    pcb->ooseq = cseg;
                  }
                  tcp_oos_insert_segment(cseg, next);
                }
                break;
   120b0:	0001883a 	nop
   120b4:	00000706 	br	120d4 <tcp_receive+0x1dac>
                  cseg = tcp_seg_copy(&inseg);
                  if (cseg != NULL) {
                    pcb->ooseq = cseg;
                    tcp_oos_insert_segment(cseg, next);
                  }
                  break;
   120b8:	0001883a 	nop
   120bc:	00000506 	br	120d4 <tcp_receive+0x1dac>
                      pbuf_realloc(prev->p, prev->len);
                    }
                    prev->next = cseg;
                    tcp_oos_insert_segment(cseg, next);
                  }
                  break;
   120c0:	0001883a 	nop
   120c4:	00000306 	br	120d4 <tcp_receive+0x1dac>
                 of the list. */
              if (next->next == NULL &&
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
                  /* segment "next" already contains all data */
                  break;
   120c8:	0001883a 	nop
   120cc:	00000106 	br	120d4 <tcp_receive+0x1dac>
                    tcplen = TCP_TCPLEN(next->next);
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
                                (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
                  }
                }
                break;
   120d0:	0001883a 	nop
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
   120d4:	00000306 	br	120e4 <tcp_receive+0x1dbc>
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */
#endif /* TCP_QUEUE_OOSEQ */
      }
    } else {
      /* The incoming segment is not withing the window. */
      tcp_send_empty_ack(pcb);
   120d8:	e13fff17 	ldw	r4,-4(fp)
   120dc:	001392c0 	call	1392c <tcp_send_empty_ack>
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
   120e0:	00001606 	br	1213c <tcp_receive+0x1e14>
   120e4:	00001506 	br	1213c <tcp_receive+0x1e14>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
   120e8:	d0e8c417 	ldw	r3,-23792(gp)
   120ec:	e0bfff17 	ldw	r2,-4(fp)
   120f0:	10800b17 	ldw	r2,44(r2)
   120f4:	1885c83a 	sub	r2,r3,r2
   120f8:	10000a16 	blt	r2,zero,12124 <tcp_receive+0x1dfc>
   120fc:	d0e8c417 	ldw	r3,-23792(gp)
   12100:	e0bfff17 	ldw	r2,-4(fp)
   12104:	11000b17 	ldw	r4,44(r2)
   12108:	e0bfff17 	ldw	r2,-4(fp)
   1210c:	10800c0b 	ldhu	r2,48(r2)
   12110:	10bfffcc 	andi	r2,r2,65535
   12114:	2085883a 	add	r2,r4,r2
   12118:	1885c83a 	sub	r2,r3,r2
   1211c:	10800044 	addi	r2,r2,1
   12120:	0080060e 	bge	zero,r2,1213c <tcp_receive+0x1e14>
      tcp_ack_now(pcb);
   12124:	e0bfff17 	ldw	r2,-4(fp)
   12128:	10800883 	ldbu	r2,34(r2)
   1212c:	10800094 	ori	r2,r2,2
   12130:	1007883a 	mov	r3,r2
   12134:	e0bfff17 	ldw	r2,-4(fp)
   12138:	10c00885 	stb	r3,34(r2)
    }
  }
}
   1213c:	e037883a 	mov	sp,fp
   12140:	dfc00217 	ldw	ra,8(sp)
   12144:	df000117 	ldw	fp,4(sp)
   12148:	dc000017 	ldw	r16,0(sp)
   1214c:	dec00304 	addi	sp,sp,12
   12150:	f800283a 	ret

00012154 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
   12154:	defffa04 	addi	sp,sp,-24
   12158:	df000515 	stw	fp,20(sp)
   1215c:	df000504 	addi	fp,sp,20
   12160:	e13fff15 	stw	r4,-4(fp)
  u8_t *opts, opt;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  opts = (u8_t *)tcphdr + TCP_HLEN;
   12164:	d0a8c217 	ldw	r2,-23800(gp)
   12168:	10800504 	addi	r2,r2,20
   1216c:	e0bffc15 	stw	r2,-16(fp)

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
   12170:	d0a8c217 	ldw	r2,-23800(gp)
   12174:	1080030b 	ldhu	r2,12(r2)
   12178:	10bfffcc 	andi	r2,r2,65535
   1217c:	1004d23a 	srli	r2,r2,8
   12180:	10ffffcc 	andi	r3,r2,65535
   12184:	d0a8c217 	ldw	r2,-23800(gp)
   12188:	1080030b 	ldhu	r2,12(r2)
   1218c:	10bfffcc 	andi	r2,r2,65535
   12190:	1004923a 	slli	r2,r2,8
   12194:	10bfffcc 	andi	r2,r2,65535
   12198:	1884b03a 	or	r2,r3,r2
   1219c:	1005d33a 	srai	r2,r2,12
   121a0:	10800190 	cmplti	r2,r2,6
   121a4:	1000651e 	bne	r2,zero,1233c <tcp_parseopt+0x1e8>
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
   121a8:	d0a8c217 	ldw	r2,-23800(gp)
   121ac:	1080030b 	ldhu	r2,12(r2)
   121b0:	10bfffcc 	andi	r2,r2,65535
   121b4:	1004d23a 	srli	r2,r2,8
   121b8:	10ffffcc 	andi	r3,r2,65535
   121bc:	d0a8c217 	ldw	r2,-23800(gp)
   121c0:	1080030b 	ldhu	r2,12(r2)
   121c4:	10bfffcc 	andi	r2,r2,65535
   121c8:	1004923a 	slli	r2,r2,8
   121cc:	10bfffcc 	andi	r2,r2,65535
   121d0:	1884b03a 	or	r2,r3,r2
   121d4:	1005d33a 	srai	r2,r2,12
   121d8:	10bffec4 	addi	r2,r2,-5
   121dc:	1085883a 	add	r2,r2,r2
   121e0:	1085883a 	add	r2,r2,r2
   121e4:	e0bffd0d 	sth	r2,-12(fp)
    for (c = 0; c < max_c; ) {
   121e8:	e03ffb0d 	sth	zero,-20(fp)
   121ec:	00004a06 	br	12318 <tcp_parseopt+0x1c4>
      opt = opts[c];
   121f0:	e0bffb0b 	ldhu	r2,-20(fp)
   121f4:	e0fffc17 	ldw	r3,-16(fp)
   121f8:	1885883a 	add	r2,r3,r2
   121fc:	10800003 	ldbu	r2,0(r2)
   12200:	e0bffd85 	stb	r2,-10(fp)
      switch (opt) {
   12204:	e0bffd83 	ldbu	r2,-10(fp)
   12208:	10c00060 	cmpeqi	r3,r2,1
   1220c:	1800041e 	bne	r3,zero,12220 <tcp_parseopt+0xcc>
   12210:	10c000a0 	cmpeqi	r3,r2,2
   12214:	1800061e 	bne	r3,zero,12230 <tcp_parseopt+0xdc>
   12218:	10004326 	beq	r2,zero,12328 <tcp_parseopt+0x1d4>
   1221c:	00002e06 	br	122d8 <tcp_parseopt+0x184>
        /* End of options. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
        return;
      case 0x01:
        /* NOP option. */
        ++c;
   12220:	e0bffb0b 	ldhu	r2,-20(fp)
   12224:	10800044 	addi	r2,r2,1
   12228:	e0bffb0d 	sth	r2,-20(fp)
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
        break;
   1222c:	00003a06 	br	12318 <tcp_parseopt+0x1c4>
      case 0x02:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
        if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
   12230:	e0bffb0b 	ldhu	r2,-20(fp)
   12234:	10800044 	addi	r2,r2,1
   12238:	e0fffc17 	ldw	r3,-16(fp)
   1223c:	1885883a 	add	r2,r3,r2
   12240:	10800003 	ldbu	r2,0(r2)
   12244:	10803fcc 	andi	r2,r2,255
   12248:	10800118 	cmpnei	r2,r2,4
   1224c:	1000381e 	bne	r2,zero,12330 <tcp_parseopt+0x1dc>
   12250:	e0bffb0b 	ldhu	r2,-20(fp)
   12254:	10800104 	addi	r2,r2,4
   12258:	e0fffd0b 	ldhu	r3,-12(fp)
   1225c:	18803416 	blt	r3,r2,12330 <tcp_parseopt+0x1dc>
          /* Bad length */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
   12260:	e0bffb0b 	ldhu	r2,-20(fp)
   12264:	10800084 	addi	r2,r2,2
   12268:	e0fffc17 	ldw	r3,-16(fp)
   1226c:	1885883a 	add	r2,r3,r2
   12270:	10800003 	ldbu	r2,0(r2)
   12274:	10803fcc 	andi	r2,r2,255
   12278:	1004923a 	slli	r2,r2,8
   1227c:	1007883a 	mov	r3,r2
   12280:	e0bffb0b 	ldhu	r2,-20(fp)
   12284:	108000c4 	addi	r2,r2,3
   12288:	e13ffc17 	ldw	r4,-16(fp)
   1228c:	2085883a 	add	r2,r4,r2
   12290:	10800003 	ldbu	r2,0(r2)
   12294:	10803fcc 	andi	r2,r2,255
   12298:	1884b03a 	or	r2,r3,r2
   1229c:	e0bffe0d 	sth	r2,-8(fp)
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
   122a0:	e0bffe0b 	ldhu	r2,-8(fp)
   122a4:	10816d68 	cmpgeui	r2,r2,1461
   122a8:	1000041e 	bne	r2,zero,122bc <tcp_parseopt+0x168>
   122ac:	e0bffe0b 	ldhu	r2,-8(fp)
   122b0:	10000226 	beq	r2,zero,122bc <tcp_parseopt+0x168>
   122b4:	e0bffe0b 	ldhu	r2,-8(fp)
   122b8:	00000106 	br	122c0 <tcp_parseopt+0x16c>
   122bc:	00816d04 	movi	r2,1460
   122c0:	e0ffff17 	ldw	r3,-4(fp)
   122c4:	18800e8d 	sth	r2,58(r3)
        /* Advance to next option */
        c += 0x04;
   122c8:	e0bffb0b 	ldhu	r2,-20(fp)
   122cc:	10800104 	addi	r2,r2,4
   122d0:	e0bffb0d 	sth	r2,-20(fp)
        break;
   122d4:	00001006 	br	12318 <tcp_parseopt+0x1c4>
        c += 0x0A;
        break;
#endif
      default:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        if (opts[c + 1] == 0) {
   122d8:	e0bffb0b 	ldhu	r2,-20(fp)
   122dc:	10800044 	addi	r2,r2,1
   122e0:	e0fffc17 	ldw	r3,-16(fp)
   122e4:	1885883a 	add	r2,r3,r2
   122e8:	10800003 	ldbu	r2,0(r2)
   122ec:	10803fcc 	andi	r2,r2,255
   122f0:	10001126 	beq	r2,zero,12338 <tcp_parseopt+0x1e4>
             and we don't process them further. */
          return;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
   122f4:	e0bffb0b 	ldhu	r2,-20(fp)
   122f8:	10800044 	addi	r2,r2,1
   122fc:	e0fffc17 	ldw	r3,-16(fp)
   12300:	1885883a 	add	r2,r3,r2
   12304:	10800003 	ldbu	r2,0(r2)
   12308:	10c03fcc 	andi	r3,r2,255
   1230c:	e0bffb0b 	ldhu	r2,-20(fp)
   12310:	1885883a 	add	r2,r3,r2
   12314:	e0bffb0d 	sth	r2,-20(fp)
  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    for (c = 0; c < max_c; ) {
   12318:	e0fffb0b 	ldhu	r3,-20(fp)
   1231c:	e0bffd0b 	ldhu	r2,-12(fp)
   12320:	18bfb336 	bltu	r3,r2,121f0 <tcp_parseopt+0x9c>
   12324:	00000506 	br	1233c <tcp_parseopt+0x1e8>
      opt = opts[c];
      switch (opt) {
      case 0x00:
        /* End of options. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
        return;
   12328:	0001883a 	nop
   1232c:	00000306 	br	1233c <tcp_parseopt+0x1e8>
      case 0x02:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
        if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
          /* Bad length */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          return;
   12330:	0001883a 	nop
   12334:	00000106 	br	1233c <tcp_parseopt+0x1e8>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        if (opts[c + 1] == 0) {
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          /* If the length field is zero, the options are malformed
             and we don't process them further. */
          return;
   12338:	0001883a 	nop
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
   1233c:	e037883a 	mov	sp,fp
   12340:	df000017 	ldw	fp,0(sp)
   12344:	dec00104 	addi	sp,sp,4
   12348:	f800283a 	ret

0001234c <tcp_output_alloc_header>:
 * @return pbuf with p->payload being the tcp_hdr
 */
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
                      u32_t seqno_be /* already in network byte order */)
{
   1234c:	defff804 	addi	sp,sp,-32
   12350:	dfc00715 	stw	ra,28(sp)
   12354:	df000615 	stw	fp,24(sp)
   12358:	df000604 	addi	fp,sp,24
   1235c:	e13ffc15 	stw	r4,-16(fp)
   12360:	2807883a 	mov	r3,r5
   12364:	3005883a 	mov	r2,r6
   12368:	e1ffff15 	stw	r7,-4(fp)
   1236c:	e0fffd0d 	sth	r3,-12(fp)
   12370:	e0bffe0d 	sth	r2,-8(fp)
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
   12374:	e0fffd0b 	ldhu	r3,-12(fp)
   12378:	e0bffe0b 	ldhu	r2,-8(fp)
   1237c:	1885883a 	add	r2,r3,r2
   12380:	10800504 	addi	r2,r2,20
   12384:	10bfffcc 	andi	r2,r2,65535
   12388:	01000044 	movi	r4,1
   1238c:	100b883a 	mov	r5,r2
   12390:	000d883a 	mov	r6,zero
   12394:	000a0740 	call	a074 <pbuf_alloc>
   12398:	e0bffa15 	stw	r2,-24(fp)
  if (p != NULL) {
   1239c:	e0bffa17 	ldw	r2,-24(fp)
   123a0:	10007926 	beq	r2,zero,12588 <tcp_output_alloc_header+0x23c>
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
   123a4:	e0bffa17 	ldw	r2,-24(fp)
   123a8:	1080028b 	ldhu	r2,10(r2)
   123ac:	10ffffcc 	andi	r3,r2,65535
   123b0:	e0bffd0b 	ldhu	r2,-12(fp)
   123b4:	10800504 	addi	r2,r2,20
   123b8:	1880090e 	bge	r3,r2,123e0 <tcp_output_alloc_header+0x94>
   123bc:	010000f4 	movhi	r4,3
   123c0:	2102c104 	addi	r4,r4,2820
   123c4:	014000f4 	movhi	r5,3
   123c8:	2942cb04 	addi	r5,r5,2860
   123cc:	01801944 	movi	r6,101
   123d0:	01c000f4 	movhi	r7,3
   123d4:	39c2d704 	addi	r7,r7,2908
   123d8:	00193f00 	call	193f0 <printf>
   123dc:	003fff06 	br	123dc <tcp_output_alloc_header+0x90>
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
   123e0:	e0bffa17 	ldw	r2,-24(fp)
   123e4:	10800117 	ldw	r2,4(r2)
   123e8:	e0bffb15 	stw	r2,-20(fp)
    tcphdr->src = htons(pcb->local_port);
   123ec:	e0bffc17 	ldw	r2,-16(fp)
   123f0:	1080078b 	ldhu	r2,30(r2)
   123f4:	10bfffcc 	andi	r2,r2,65535
   123f8:	1004d23a 	srli	r2,r2,8
   123fc:	1007883a 	mov	r3,r2
   12400:	e0bffc17 	ldw	r2,-16(fp)
   12404:	1080078b 	ldhu	r2,30(r2)
   12408:	10bfffcc 	andi	r2,r2,65535
   1240c:	1004923a 	slli	r2,r2,8
   12410:	1884b03a 	or	r2,r3,r2
   12414:	1007883a 	mov	r3,r2
   12418:	e0bffb17 	ldw	r2,-20(fp)
   1241c:	10c0000d 	sth	r3,0(r2)
    tcphdr->dest = htons(pcb->remote_port);
   12420:	e0bffc17 	ldw	r2,-16(fp)
   12424:	1080080b 	ldhu	r2,32(r2)
   12428:	10bfffcc 	andi	r2,r2,65535
   1242c:	1004d23a 	srli	r2,r2,8
   12430:	1007883a 	mov	r3,r2
   12434:	e0bffc17 	ldw	r2,-16(fp)
   12438:	1080080b 	ldhu	r2,32(r2)
   1243c:	10bfffcc 	andi	r2,r2,65535
   12440:	1004923a 	slli	r2,r2,8
   12444:	1884b03a 	or	r2,r3,r2
   12448:	1007883a 	mov	r3,r2
   1244c:	e0bffb17 	ldw	r2,-20(fp)
   12450:	10c0008d 	sth	r3,2(r2)
    tcphdr->seqno = seqno_be;
   12454:	e0bffb17 	ldw	r2,-20(fp)
   12458:	e0ffff17 	ldw	r3,-4(fp)
   1245c:	18ffffcc 	andi	r3,r3,65535
   12460:	1100010b 	ldhu	r4,4(r2)
   12464:	2008703a 	and	r4,r4,zero
   12468:	20c6b03a 	or	r3,r4,r3
   1246c:	10c0010d 	sth	r3,4(r2)
   12470:	e0ffff17 	ldw	r3,-4(fp)
   12474:	1806d43a 	srli	r3,r3,16
   12478:	1100018b 	ldhu	r4,6(r2)
   1247c:	2008703a 	and	r4,r4,zero
   12480:	20c6b03a 	or	r3,r4,r3
   12484:	10c0018d 	sth	r3,6(r2)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
   12488:	e0bffc17 	ldw	r2,-16(fp)
   1248c:	10800b17 	ldw	r2,44(r2)
   12490:	1006d63a 	srli	r3,r2,24
   12494:	e0bffc17 	ldw	r2,-16(fp)
   12498:	10800b17 	ldw	r2,44(r2)
   1249c:	1004d23a 	srli	r2,r2,8
   124a0:	10bfc00c 	andi	r2,r2,65280
   124a4:	1886b03a 	or	r3,r3,r2
   124a8:	e0bffc17 	ldw	r2,-16(fp)
   124ac:	10800b17 	ldw	r2,44(r2)
   124b0:	10bfc00c 	andi	r2,r2,65280
   124b4:	1004923a 	slli	r2,r2,8
   124b8:	1886b03a 	or	r3,r3,r2
   124bc:	e0bffc17 	ldw	r2,-16(fp)
   124c0:	10800b17 	ldw	r2,44(r2)
   124c4:	1004963a 	slli	r2,r2,24
   124c8:	1886b03a 	or	r3,r3,r2
   124cc:	e0bffb17 	ldw	r2,-20(fp)
   124d0:	193fffcc 	andi	r4,r3,65535
   124d4:	1140020b 	ldhu	r5,8(r2)
   124d8:	280a703a 	and	r5,r5,zero
   124dc:	2908b03a 	or	r4,r5,r4
   124e0:	1100020d 	sth	r4,8(r2)
   124e4:	1806d43a 	srli	r3,r3,16
   124e8:	1100028b 	ldhu	r4,10(r2)
   124ec:	2008703a 	and	r4,r4,zero
   124f0:	20c6b03a 	or	r3,r4,r3
   124f4:	10c0028d 	sth	r3,10(r2)
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
   124f8:	e0bffd0b 	ldhu	r2,-12(fp)
   124fc:	1004d0ba 	srli	r2,r2,2
   12500:	10bfffcc 	andi	r2,r2,65535
   12504:	10800144 	addi	r2,r2,5
   12508:	1004933a 	slli	r2,r2,12
   1250c:	10bfffcc 	andi	r2,r2,65535
   12510:	1004d23a 	srli	r2,r2,8
   12514:	10840014 	ori	r2,r2,4096
   12518:	1007883a 	mov	r3,r2
   1251c:	e0bffb17 	ldw	r2,-20(fp)
   12520:	10c0030d 	sth	r3,12(r2)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
   12524:	e0bffc17 	ldw	r2,-16(fp)
   12528:	10800c8b 	ldhu	r2,50(r2)
   1252c:	10bfffcc 	andi	r2,r2,65535
   12530:	1004d23a 	srli	r2,r2,8
   12534:	1007883a 	mov	r3,r2
   12538:	e0bffc17 	ldw	r2,-16(fp)
   1253c:	10800c8b 	ldhu	r2,50(r2)
   12540:	10bfffcc 	andi	r2,r2,65535
   12544:	1004923a 	slli	r2,r2,8
   12548:	1884b03a 	or	r2,r3,r2
   1254c:	1007883a 	mov	r3,r2
   12550:	e0bffb17 	ldw	r2,-20(fp)
   12554:	10c0038d 	sth	r3,14(r2)
    tcphdr->chksum = 0;
   12558:	e0bffb17 	ldw	r2,-20(fp)
   1255c:	1000040d 	sth	zero,16(r2)
    tcphdr->urgp = 0;
   12560:	e0bffb17 	ldw	r2,-20(fp)
   12564:	1000048d 	sth	zero,18(r2)

    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
   12568:	e0bffc17 	ldw	r2,-16(fp)
   1256c:	10c00b17 	ldw	r3,44(r2)
   12570:	e0bffc17 	ldw	r2,-16(fp)
   12574:	10800c8b 	ldhu	r2,50(r2)
   12578:	10bfffcc 	andi	r2,r2,65535
   1257c:	1887883a 	add	r3,r3,r2
   12580:	e0bffc17 	ldw	r2,-16(fp)
   12584:	10c00d15 	stw	r3,52(r2)
  }
  return p;
   12588:	e0bffa17 	ldw	r2,-24(fp)
}
   1258c:	e037883a 	mov	sp,fp
   12590:	dfc00117 	ldw	ra,4(sp)
   12594:	df000017 	ldw	fp,0(sp)
   12598:	dec00204 	addi	sp,sp,8
   1259c:	f800283a 	ret

000125a0 <tcp_send_fin>:
 * @param pcb the tcp_pcb over which to send a segment
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_fin(struct tcp_pcb *pcb)
{
   125a0:	defffc04 	addi	sp,sp,-16
   125a4:	dfc00315 	stw	ra,12(sp)
   125a8:	df000215 	stw	fp,8(sp)
   125ac:	df000204 	addi	fp,sp,8
   125b0:	e13fff15 	stw	r4,-4(fp)
  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
   125b4:	e0bfff17 	ldw	r2,-4(fp)
   125b8:	10801c17 	ldw	r2,112(r2)
   125bc:	10002826 	beq	r2,zero,12660 <tcp_send_fin+0xc0>
    struct tcp_seg *last_unsent;
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
   125c0:	e0bfff17 	ldw	r2,-4(fp)
   125c4:	10801c17 	ldw	r2,112(r2)
   125c8:	e0bffe15 	stw	r2,-8(fp)
   125cc:	00000306 	br	125dc <tcp_send_fin+0x3c>
         last_unsent = last_unsent->next);
   125d0:	e0bffe17 	ldw	r2,-8(fp)
   125d4:	10800017 	ldw	r2,0(r2)
   125d8:	e0bffe15 	stw	r2,-8(fp)
tcp_send_fin(struct tcp_pcb *pcb)
{
  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
    struct tcp_seg *last_unsent;
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
   125dc:	e0bffe17 	ldw	r2,-8(fp)
   125e0:	10800017 	ldw	r2,0(r2)
   125e4:	103ffa1e 	bne	r2,zero,125d0 <tcp_send_fin+0x30>
         last_unsent = last_unsent->next);

    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
   125e8:	e0bffe17 	ldw	r2,-8(fp)
   125ec:	10800317 	ldw	r2,12(r2)
   125f0:	1080030b 	ldhu	r2,12(r2)
   125f4:	10bfffcc 	andi	r2,r2,65535
   125f8:	1004d23a 	srli	r2,r2,8
   125fc:	10ffffcc 	andi	r3,r2,65535
   12600:	e0bffe17 	ldw	r2,-8(fp)
   12604:	10800317 	ldw	r2,12(r2)
   12608:	1080030b 	ldhu	r2,12(r2)
   1260c:	10bfffcc 	andi	r2,r2,65535
   12610:	1004923a 	slli	r2,r2,8
   12614:	10bfffcc 	andi	r2,r2,65535
   12618:	1884b03a 	or	r2,r3,r2
   1261c:	108001cc 	andi	r2,r2,7
   12620:	10000f1e 	bne	r2,zero,12660 <tcp_send_fin+0xc0>
      /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
   12624:	e0bffe17 	ldw	r2,-8(fp)
   12628:	10800317 	ldw	r2,12(r2)
   1262c:	e0fffe17 	ldw	r3,-8(fp)
   12630:	18c00317 	ldw	r3,12(r3)
   12634:	18c0030b 	ldhu	r3,12(r3)
   12638:	18c04014 	ori	r3,r3,256
   1263c:	10c0030d 	sth	r3,12(r2)
      pcb->flags |= TF_FIN;
   12640:	e0bfff17 	ldw	r2,-4(fp)
   12644:	10800883 	ldbu	r2,34(r2)
   12648:	10800814 	ori	r2,r2,32
   1264c:	1007883a 	mov	r3,r2
   12650:	e0bfff17 	ldw	r2,-4(fp)
   12654:	10c00885 	stb	r3,34(r2)
      return ERR_OK;
   12658:	0005883a 	mov	r2,zero
   1265c:	00000306 	br	1266c <tcp_send_fin+0xcc>
    }
  }
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue_flags(pcb, TCP_FIN);
   12660:	e13fff17 	ldw	r4,-4(fp)
   12664:	01400044 	movi	r5,1
   12668:	00135100 	call	13510 <tcp_enqueue_flags>
}
   1266c:	e037883a 	mov	sp,fp
   12670:	dfc00117 	ldw	ra,4(sp)
   12674:	df000017 	ldw	fp,0(sp)
   12678:	dec00204 	addi	sp,sp,8
   1267c:	f800283a 	ret

00012680 <tcp_create_segment>:
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
   12680:	defff704 	addi	sp,sp,-36
   12684:	dfc00815 	stw	ra,32(sp)
   12688:	df000715 	stw	fp,28(sp)
   1268c:	df000704 	addi	fp,sp,28
   12690:	e13ffb15 	stw	r4,-20(fp)
   12694:	e17ffc15 	stw	r5,-16(fp)
   12698:	3005883a 	mov	r2,r6
   1269c:	e1fffe15 	stw	r7,-8(fp)
   126a0:	e0c00217 	ldw	r3,8(fp)
   126a4:	e0bffd05 	stb	r2,-12(fp)
   126a8:	e0ffff05 	stb	r3,-4(fp)
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
   126ac:	e0bfff03 	ldbu	r2,-4(fp)
   126b0:	1080004c 	andi	r2,r2,1
   126b4:	10000226 	beq	r2,zero,126c0 <tcp_create_segment+0x40>
   126b8:	00c00104 	movi	r3,4
   126bc:	00000106 	br	126c4 <tcp_create_segment+0x44>
   126c0:	0007883a 	mov	r3,zero
   126c4:	e0bfff03 	ldbu	r2,-4(fp)
   126c8:	1080008c 	andi	r2,r2,2
   126cc:	10000226 	beq	r2,zero,126d8 <tcp_create_segment+0x58>
   126d0:	00800304 	movi	r2,12
   126d4:	00000106 	br	126dc <tcp_create_segment+0x5c>
   126d8:	0005883a 	mov	r2,zero
   126dc:	1885883a 	add	r2,r3,r2
   126e0:	e0bff905 	stb	r2,-28(fp)

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
   126e4:	01000104 	movi	r4,4
   126e8:	00095f80 	call	95f8 <memp_malloc>
   126ec:	e0bffa15 	stw	r2,-24(fp)
   126f0:	e0bffa17 	ldw	r2,-24(fp)
   126f4:	1000041e 	bne	r2,zero,12708 <tcp_create_segment+0x88>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
   126f8:	e13ffc17 	ldw	r4,-16(fp)
   126fc:	000aa340 	call	aa34 <pbuf_free>
    return NULL;
   12700:	0005883a 	mov	r2,zero
   12704:	00007206 	br	128d0 <tcp_create_segment+0x250>
  }
  seg->flags = optflags;
   12708:	e0bffa17 	ldw	r2,-24(fp)
   1270c:	e0ffff03 	ldbu	r3,-4(fp)
   12710:	10c00285 	stb	r3,10(r2)
  seg->next = NULL;
   12714:	e0bffa17 	ldw	r2,-24(fp)
   12718:	10000015 	stw	zero,0(r2)
  seg->p = p;
   1271c:	e0bffa17 	ldw	r2,-24(fp)
   12720:	e0fffc17 	ldw	r3,-16(fp)
   12724:	10c00115 	stw	r3,4(r2)
  seg->len = p->tot_len - optlen;
   12728:	e0bffc17 	ldw	r2,-16(fp)
   1272c:	10c0020b 	ldhu	r3,8(r2)
   12730:	e0bff903 	ldbu	r2,-28(fp)
   12734:	1885c83a 	sub	r2,r3,r2
   12738:	1007883a 	mov	r3,r2
   1273c:	e0bffa17 	ldw	r2,-24(fp)
   12740:	10c0020d 	sth	r3,8(r2)
  LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
              (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_header(p, TCP_HLEN)) {
   12744:	e13ffc17 	ldw	r4,-16(fp)
   12748:	01400504 	movi	r5,20
   1274c:	000a83c0 	call	a83c <pbuf_header>
   12750:	10803fcc 	andi	r2,r2,255
   12754:	10000c26 	beq	r2,zero,12788 <tcp_create_segment+0x108>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
   12758:	00800234 	movhi	r2,8
   1275c:	1083bd04 	addi	r2,r2,3828
   12760:	1080290b 	ldhu	r2,164(r2)
   12764:	10800044 	addi	r2,r2,1
   12768:	1007883a 	mov	r3,r2
   1276c:	00800234 	movhi	r2,8
   12770:	1083bd04 	addi	r2,r2,3828
   12774:	10c0290d 	sth	r3,164(r2)
    tcp_seg_free(seg);
   12778:	e13ffa17 	ldw	r4,-24(fp)
   1277c:	000da080 	call	da08 <tcp_seg_free>
    return NULL;
   12780:	0005883a 	mov	r2,zero
   12784:	00005206 	br	128d0 <tcp_create_segment+0x250>
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
   12788:	e0bffa17 	ldw	r2,-24(fp)
   1278c:	10800117 	ldw	r2,4(r2)
   12790:	10c00117 	ldw	r3,4(r2)
   12794:	e0bffa17 	ldw	r2,-24(fp)
   12798:	10c00315 	stw	r3,12(r2)
  seg->tcphdr->src = htons(pcb->local_port);
   1279c:	e0bffa17 	ldw	r2,-24(fp)
   127a0:	10800317 	ldw	r2,12(r2)
   127a4:	e0fffb17 	ldw	r3,-20(fp)
   127a8:	18c0078b 	ldhu	r3,30(r3)
   127ac:	18ffffcc 	andi	r3,r3,65535
   127b0:	1806d23a 	srli	r3,r3,8
   127b4:	1809883a 	mov	r4,r3
   127b8:	e0fffb17 	ldw	r3,-20(fp)
   127bc:	18c0078b 	ldhu	r3,30(r3)
   127c0:	18ffffcc 	andi	r3,r3,65535
   127c4:	1806923a 	slli	r3,r3,8
   127c8:	20c6b03a 	or	r3,r4,r3
   127cc:	10c0000d 	sth	r3,0(r2)
  seg->tcphdr->dest = htons(pcb->remote_port);
   127d0:	e0bffa17 	ldw	r2,-24(fp)
   127d4:	10800317 	ldw	r2,12(r2)
   127d8:	e0fffb17 	ldw	r3,-20(fp)
   127dc:	18c0080b 	ldhu	r3,32(r3)
   127e0:	18ffffcc 	andi	r3,r3,65535
   127e4:	1806d23a 	srli	r3,r3,8
   127e8:	1809883a 	mov	r4,r3
   127ec:	e0fffb17 	ldw	r3,-20(fp)
   127f0:	18c0080b 	ldhu	r3,32(r3)
   127f4:	18ffffcc 	andi	r3,r3,65535
   127f8:	1806923a 	slli	r3,r3,8
   127fc:	20c6b03a 	or	r3,r4,r3
   12800:	10c0008d 	sth	r3,2(r2)
  seg->tcphdr->seqno = htonl(seqno);
   12804:	e0bffa17 	ldw	r2,-24(fp)
   12808:	10800317 	ldw	r2,12(r2)
   1280c:	e0fffe17 	ldw	r3,-8(fp)
   12810:	1808d63a 	srli	r4,r3,24
   12814:	e0fffe17 	ldw	r3,-8(fp)
   12818:	1806d23a 	srli	r3,r3,8
   1281c:	18ffc00c 	andi	r3,r3,65280
   12820:	20c8b03a 	or	r4,r4,r3
   12824:	e0fffe17 	ldw	r3,-8(fp)
   12828:	18ffc00c 	andi	r3,r3,65280
   1282c:	1806923a 	slli	r3,r3,8
   12830:	20c8b03a 	or	r4,r4,r3
   12834:	e0fffe17 	ldw	r3,-8(fp)
   12838:	1806963a 	slli	r3,r3,24
   1283c:	20c6b03a 	or	r3,r4,r3
   12840:	193fffcc 	andi	r4,r3,65535
   12844:	1140010b 	ldhu	r5,4(r2)
   12848:	280a703a 	and	r5,r5,zero
   1284c:	2908b03a 	or	r4,r5,r4
   12850:	1100010d 	sth	r4,4(r2)
   12854:	1806d43a 	srli	r3,r3,16
   12858:	1100018b 	ldhu	r4,6(r2)
   1285c:	2008703a 	and	r4,r4,zero
   12860:	20c6b03a 	or	r3,r4,r3
   12864:	10c0018d 	sth	r3,6(r2)
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
   12868:	e0bffa17 	ldw	r2,-24(fp)
   1286c:	10800317 	ldw	r2,12(r2)
   12870:	e0fff903 	ldbu	r3,-28(fp)
   12874:	1806d0ba 	srli	r3,r3,2
   12878:	18c03fcc 	andi	r3,r3,255
   1287c:	18c00144 	addi	r3,r3,5
   12880:	1808933a 	slli	r4,r3,12
   12884:	e0fffd03 	ldbu	r3,-12(fp)
   12888:	20c6b03a 	or	r3,r4,r3
   1288c:	18ffc00c 	andi	r3,r3,65280
   12890:	1807d23a 	srai	r3,r3,8
   12894:	1809883a 	mov	r4,r3
   12898:	e0fff903 	ldbu	r3,-28(fp)
   1289c:	1806d0ba 	srli	r3,r3,2
   128a0:	18c03fcc 	andi	r3,r3,255
   128a4:	18c00144 	addi	r3,r3,5
   128a8:	180a933a 	slli	r5,r3,12
   128ac:	e0fffd03 	ldbu	r3,-12(fp)
   128b0:	28c6b03a 	or	r3,r5,r3
   128b4:	1806923a 	slli	r3,r3,8
   128b8:	20c6b03a 	or	r3,r4,r3
   128bc:	10c0030d 	sth	r3,12(r2)
  /* wnd and chksum are set in tcp_output */
  seg->tcphdr->urgp = 0;
   128c0:	e0bffa17 	ldw	r2,-24(fp)
   128c4:	10800317 	ldw	r2,12(r2)
   128c8:	1000048d 	sth	zero,18(r2)
  return seg;
   128cc:	e0bffa17 	ldw	r2,-24(fp)
} 
   128d0:	e037883a 	mov	sp,fp
   128d4:	dfc00117 	ldw	ra,4(sp)
   128d8:	df000017 	ldw	fp,0(sp)
   128dc:	dec00204 	addi	sp,sp,8
   128e0:	f800283a 	ret

000128e4 <tcp_pbuf_prealloc>:
#if TCP_OVERSIZE
static struct pbuf *
tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
                  u16_t *oversize, struct tcp_pcb *pcb, u8_t apiflags,
                  u8_t first_seg)
{
   128e4:	defff604 	addi	sp,sp,-40
   128e8:	dfc00915 	stw	ra,36(sp)
   128ec:	df000815 	stw	fp,32(sp)
   128f0:	df000804 	addi	fp,sp,32
   128f4:	e13ffa15 	stw	r4,-24(fp)
   128f8:	2807883a 	mov	r3,r5
   128fc:	3005883a 	mov	r2,r6
   12900:	e1fffd15 	stw	r7,-12(fp)
   12904:	e1400317 	ldw	r5,12(fp)
   12908:	e1000417 	ldw	r4,16(fp)
   1290c:	e0fffb0d 	sth	r3,-20(fp)
   12910:	e0bffc0d 	sth	r2,-16(fp)
   12914:	e17ffe05 	stb	r5,-8(fp)
   12918:	e13fff05 	stb	r4,-4(fp)
  struct pbuf *p;
  u16_t alloc = length;
   1291c:	e0bffb0b 	ldhu	r2,-20(fp)
   12920:	e0bff80d 	sth	r2,-32(fp)
  LWIP_UNUSED_ARG(apiflags);
  LWIP_UNUSED_ARG(first_seg);
  /* always create MSS-sized pbufs */
  alloc = max_length;
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (length < max_length) {
   12924:	e0fffb0b 	ldhu	r3,-20(fp)
   12928:	e0bffc0b 	ldhu	r2,-16(fp)
   1292c:	1880182e 	bgeu	r3,r2,12990 <tcp_pbuf_prealloc+0xac>
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
   12930:	e0bffe03 	ldbu	r2,-8(fp)
   12934:	1080008c 	andi	r2,r2,2
   12938:	10000d1e 	bne	r2,zero,12970 <tcp_pbuf_prealloc+0x8c>
        (!(pcb->flags & TF_NODELAY) &&
   1293c:	e0800217 	ldw	r2,8(fp)
   12940:	10800883 	ldbu	r2,34(r2)
   12944:	10803fcc 	andi	r2,r2,255
   12948:	1080100c 	andi	r2,r2,64
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
   1294c:	1000101e 	bne	r2,zero,12990 <tcp_pbuf_prealloc+0xac>
        (!(pcb->flags & TF_NODELAY) &&
   12950:	e0bfff03 	ldbu	r2,-4(fp)
   12954:	10000626 	beq	r2,zero,12970 <tcp_pbuf_prealloc+0x8c>
         (!first_seg ||
          pcb->unsent != NULL ||
   12958:	e0800217 	ldw	r2,8(fp)
   1295c:	10801c17 	ldw	r2,112(r2)
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
        (!(pcb->flags & TF_NODELAY) &&
         (!first_seg ||
   12960:	1000031e 	bne	r2,zero,12970 <tcp_pbuf_prealloc+0x8c>
          pcb->unsent != NULL ||
          pcb->unacked != NULL))) {
   12964:	e0800217 	ldw	r2,8(fp)
   12968:	10801d17 	ldw	r2,116(r2)
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
        (!(pcb->flags & TF_NODELAY) &&
         (!first_seg ||
          pcb->unsent != NULL ||
   1296c:	10000826 	beq	r2,zero,12990 <tcp_pbuf_prealloc+0xac>
          pcb->unacked != NULL))) {
      alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(length + TCP_OVERSIZE));
   12970:	e0bffb0b 	ldhu	r2,-20(fp)
   12974:	10c16dc4 	addi	r3,r2,1463
   12978:	00bfff04 	movi	r2,-4
   1297c:	1884703a 	and	r2,r3,r2
   12980:	e0fffc0b 	ldhu	r3,-16(fp)
   12984:	1880010e 	bge	r3,r2,1298c <tcp_pbuf_prealloc+0xa8>
   12988:	1805883a 	mov	r2,r3
   1298c:	e0bff80d 	sth	r2,-32(fp)
    }
  }
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
   12990:	e0bff80b 	ldhu	r2,-32(fp)
   12994:	e13ffa17 	ldw	r4,-24(fp)
   12998:	100b883a 	mov	r5,r2
   1299c:	000d883a 	mov	r6,zero
   129a0:	000a0740 	call	a074 <pbuf_alloc>
   129a4:	e0bff915 	stw	r2,-28(fp)
  if (p == NULL) {
   129a8:	e0bff917 	ldw	r2,-28(fp)
   129ac:	1000021e 	bne	r2,zero,129b8 <tcp_pbuf_prealloc+0xd4>
    return NULL;
   129b0:	0005883a 	mov	r2,zero
   129b4:	00001b06 	br	12a24 <tcp_pbuf_prealloc+0x140>
  }
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
   129b8:	e0bff917 	ldw	r2,-28(fp)
   129bc:	10800017 	ldw	r2,0(r2)
   129c0:	10000926 	beq	r2,zero,129e8 <tcp_pbuf_prealloc+0x104>
   129c4:	010000f4 	movhi	r4,3
   129c8:	2102c104 	addi	r4,r4,2820
   129cc:	014000f4 	movhi	r5,3
   129d0:	2942dd04 	addi	r5,r5,2932
   129d4:	018040c4 	movi	r6,259
   129d8:	01c000f4 	movhi	r7,3
   129dc:	39c2d704 	addi	r7,r7,2908
   129e0:	00193f00 	call	193f0 <printf>
   129e4:	003fff06 	br	129e4 <tcp_pbuf_prealloc+0x100>
  *oversize = p->len - length;
   129e8:	e0bff917 	ldw	r2,-28(fp)
   129ec:	10c0028b 	ldhu	r3,10(r2)
   129f0:	e0bffb0b 	ldhu	r2,-20(fp)
   129f4:	1885c83a 	sub	r2,r3,r2
   129f8:	1007883a 	mov	r3,r2
   129fc:	e0bffd17 	ldw	r2,-12(fp)
   12a00:	10c0000d 	sth	r3,0(r2)
  /* trim p->len to the currently used size */
  p->len = p->tot_len = length;
   12a04:	e0bff917 	ldw	r2,-28(fp)
   12a08:	e0fffb0b 	ldhu	r3,-20(fp)
   12a0c:	10c0020d 	sth	r3,8(r2)
   12a10:	e0bff917 	ldw	r2,-28(fp)
   12a14:	10c0020b 	ldhu	r3,8(r2)
   12a18:	e0bff917 	ldw	r2,-28(fp)
   12a1c:	10c0028d 	sth	r3,10(r2)
  return p;
   12a20:	e0bff917 	ldw	r2,-28(fp)
}
   12a24:	e037883a 	mov	sp,fp
   12a28:	dfc00117 	ldw	ra,4(sp)
   12a2c:	df000017 	ldw	fp,0(sp)
   12a30:	dec00204 	addi	sp,sp,8
   12a34:	f800283a 	ret

00012a38 <tcp_write_checks>:
 * @param len length of data to send (checked agains snd_buf)
 * @return ERR_OK if tcp_write is allowed to proceed, another err_t otherwise
 */
static err_t
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
   12a38:	defffc04 	addi	sp,sp,-16
   12a3c:	dfc00315 	stw	ra,12(sp)
   12a40:	df000215 	stw	fp,8(sp)
   12a44:	df000204 	addi	fp,sp,8
   12a48:	e13ffe15 	stw	r4,-8(fp)
   12a4c:	2805883a 	mov	r2,r5
   12a50:	e0bfff0d 	sth	r2,-4(fp)
  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
   12a54:	e0bffe17 	ldw	r2,-8(fp)
   12a58:	10800617 	ldw	r2,24(r2)
   12a5c:	10800120 	cmpeqi	r2,r2,4
   12a60:	10000e1e 	bne	r2,zero,12a9c <tcp_write_checks+0x64>
      (pcb->state != CLOSE_WAIT) &&
   12a64:	e0bffe17 	ldw	r2,-8(fp)
   12a68:	10800617 	ldw	r2,24(r2)
 */
static err_t
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
   12a6c:	108001e0 	cmpeqi	r2,r2,7
   12a70:	10000a1e 	bne	r2,zero,12a9c <tcp_write_checks+0x64>
      (pcb->state != CLOSE_WAIT) &&
      (pcb->state != SYN_SENT) &&
   12a74:	e0bffe17 	ldw	r2,-8(fp)
   12a78:	10800617 	ldw	r2,24(r2)
static err_t
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
      (pcb->state != CLOSE_WAIT) &&
   12a7c:	108000a0 	cmpeqi	r2,r2,2
   12a80:	1000061e 	bne	r2,zero,12a9c <tcp_write_checks+0x64>
      (pcb->state != SYN_SENT) &&
      (pcb->state != SYN_RCVD)) {
   12a84:	e0bffe17 	ldw	r2,-8(fp)
   12a88:	10800617 	ldw	r2,24(r2)
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
      (pcb->state != CLOSE_WAIT) &&
      (pcb->state != SYN_SENT) &&
   12a8c:	108000e0 	cmpeqi	r2,r2,3
   12a90:	1000021e 	bne	r2,zero,12a9c <tcp_write_checks+0x64>
      (pcb->state != SYN_RCVD)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
   12a94:	00bffcc4 	movi	r2,-13
   12a98:	00005006 	br	12bdc <tcp_write_checks+0x1a4>
  } else if (len == 0) {
   12a9c:	e0bfff0b 	ldhu	r2,-4(fp)
   12aa0:	1000021e 	bne	r2,zero,12aac <tcp_write_checks+0x74>
    return ERR_OK;
   12aa4:	0005883a 	mov	r2,zero
   12aa8:	00004c06 	br	12bdc <tcp_write_checks+0x1a4>
  }

  /* fail on too much data */
  if (len > pcb->snd_buf) {
   12aac:	e0bffe17 	ldw	r2,-8(fp)
   12ab0:	10801a8b 	ldhu	r2,106(r2)
   12ab4:	10ffffcc 	andi	r3,r2,65535
   12ab8:	e0bfff0b 	ldhu	r2,-4(fp)
   12abc:	1880092e 	bgeu	r3,r2,12ae4 <tcp_write_checks+0xac>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n",
      len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
   12ac0:	e0bffe17 	ldw	r2,-8(fp)
   12ac4:	10c00883 	ldbu	r3,34(r2)
   12ac8:	00bfe004 	movi	r2,-128
   12acc:	1884b03a 	or	r2,r3,r2
   12ad0:	1007883a 	mov	r3,r2
   12ad4:	e0bffe17 	ldw	r2,-8(fp)
   12ad8:	10c00885 	stb	r3,34(r2)
    return ERR_MEM;
   12adc:	00bfffc4 	movi	r2,-1
   12ae0:	00003e06 	br	12bdc <tcp_write_checks+0x1a4>
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
   12ae4:	e0bffe17 	ldw	r2,-8(fp)
   12ae8:	10801b0b 	ldhu	r2,108(r2)
   12aec:	10bfffcc 	andi	r2,r2,65535
   12af0:	10800b28 	cmpgeui	r2,r2,44
   12af4:	1000051e 	bne	r2,zero,12b0c <tcp_write_checks+0xd4>
   12af8:	e0bffe17 	ldw	r2,-8(fp)
   12afc:	10801b0b 	ldhu	r2,108(r2)
   12b00:	10bfffcc 	andi	r2,r2,65535
   12b04:	10bfff70 	cmpltui	r2,r2,65533
   12b08:	1000111e 	bne	r2,zero,12b50 <tcp_write_checks+0x118>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too long queue %"U16_F" (max %"U16_F")\n",
      pcb->snd_queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
   12b0c:	00800234 	movhi	r2,8
   12b10:	1083bd04 	addi	r2,r2,3828
   12b14:	1080270b 	ldhu	r2,156(r2)
   12b18:	10800044 	addi	r2,r2,1
   12b1c:	1007883a 	mov	r3,r2
   12b20:	00800234 	movhi	r2,8
   12b24:	1083bd04 	addi	r2,r2,3828
   12b28:	10c0270d 	sth	r3,156(r2)
    pcb->flags |= TF_NAGLEMEMERR;
   12b2c:	e0bffe17 	ldw	r2,-8(fp)
   12b30:	10c00883 	ldbu	r3,34(r2)
   12b34:	00bfe004 	movi	r2,-128
   12b38:	1884b03a 	or	r2,r3,r2
   12b3c:	1007883a 	mov	r3,r2
   12b40:	e0bffe17 	ldw	r2,-8(fp)
   12b44:	10c00885 	stb	r3,34(r2)
    return ERR_MEM;
   12b48:	00bfffc4 	movi	r2,-1
   12b4c:	00002306 	br	12bdc <tcp_write_checks+0x1a4>
  }
  if (pcb->snd_queuelen != 0) {
   12b50:	e0bffe17 	ldw	r2,-8(fp)
   12b54:	10801b0b 	ldhu	r2,108(r2)
   12b58:	10bfffcc 	andi	r2,r2,65535
   12b5c:	10000f26 	beq	r2,zero,12b9c <tcp_write_checks+0x164>
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
   12b60:	e0bffe17 	ldw	r2,-8(fp)
   12b64:	10801d17 	ldw	r2,116(r2)
   12b68:	10001b1e 	bne	r2,zero,12bd8 <tcp_write_checks+0x1a0>
   12b6c:	e0bffe17 	ldw	r2,-8(fp)
   12b70:	10801c17 	ldw	r2,112(r2)
   12b74:	1000181e 	bne	r2,zero,12bd8 <tcp_write_checks+0x1a0>
   12b78:	010000f4 	movhi	r4,3
   12b7c:	2102c104 	addi	r4,r4,2820
   12b80:	014000f4 	movhi	r5,3
   12b84:	2942e204 	addi	r5,r5,2952
   12b88:	01805244 	movi	r6,329
   12b8c:	01c000f4 	movhi	r7,3
   12b90:	39c2d704 	addi	r7,r7,2908
   12b94:	00193f00 	call	193f0 <printf>
   12b98:	003fff06 	br	12b98 <tcp_write_checks+0x160>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
   12b9c:	e0bffe17 	ldw	r2,-8(fp)
   12ba0:	10801d17 	ldw	r2,116(r2)
   12ba4:	1000031e 	bne	r2,zero,12bb4 <tcp_write_checks+0x17c>
   12ba8:	e0bffe17 	ldw	r2,-8(fp)
   12bac:	10801c17 	ldw	r2,112(r2)
   12bb0:	10000926 	beq	r2,zero,12bd8 <tcp_write_checks+0x1a0>
   12bb4:	010000f4 	movhi	r4,3
   12bb8:	2102c104 	addi	r4,r4,2820
   12bbc:	014000f4 	movhi	r5,3
   12bc0:	2942f104 	addi	r5,r5,3012
   12bc4:	01805304 	movi	r6,332
   12bc8:	01c000f4 	movhi	r7,3
   12bcc:	39c2d704 	addi	r7,r7,2908
   12bd0:	00193f00 	call	193f0 <printf>
   12bd4:	003fff06 	br	12bd4 <tcp_write_checks+0x19c>
      pcb->unacked == NULL && pcb->unsent == NULL);
  }
  return ERR_OK;
   12bd8:	0005883a 	mov	r2,zero
}
   12bdc:	e037883a 	mov	sp,fp
   12be0:	dfc00117 	ldw	ra,4(sp)
   12be4:	df000017 	ldw	fp,0(sp)
   12be8:	dec00204 	addi	sp,sp,8
   12bec:	f800283a 	ret

00012bf0 <tcp_write>:
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
   12bf0:	deffe804 	addi	sp,sp,-96
   12bf4:	dfc01715 	stw	ra,92(sp)
   12bf8:	df001615 	stw	fp,88(sp)
   12bfc:	df001604 	addi	fp,sp,88
   12c00:	e13ffc15 	stw	r4,-16(fp)
   12c04:	e17ffd15 	stw	r5,-12(fp)
   12c08:	3007883a 	mov	r3,r6
   12c0c:	3805883a 	mov	r2,r7
   12c10:	e0fffe0d 	sth	r3,-8(fp)
   12c14:	e0bfff05 	stb	r2,-4(fp)
  struct pbuf *concat_p = NULL;
   12c18:	e03fed15 	stw	zero,-76(fp)
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
   12c1c:	e03fee15 	stw	zero,-72(fp)
   12c20:	e03fef15 	stw	zero,-68(fp)
   12c24:	e03ff015 	stw	zero,-64(fp)
   12c28:	e03ff115 	stw	zero,-60(fp)
  u16_t pos = 0; /* position in 'arg' data */
   12c2c:	e03ff20d 	sth	zero,-56(fp)
  u16_t queuelen;
  u8_t optlen = 0;
   12c30:	e03ff605 	stb	zero,-40(fp)
  u8_t optflags = 0;
   12c34:	e03ff645 	stb	zero,-39(fp)
#if TCP_OVERSIZE
  u16_t oversize = 0;
   12c38:	e03ffb0d 	sth	zero,-20(fp)
  u16_t oversize_used = 0;
   12c3c:	e03ff30d 	sth	zero,-52(fp)
  u8_t concat_chksum_swapped = 0;
  u16_t concat_chksummed = 0;
#endif /* TCP_CHECKSUM_ON_COPY */
  err_t err;
  /* don't allocate segments bigger than half the maximum window we ever received */
  u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max/2);
   12c40:	e0bffc17 	ldw	r2,-16(fp)
   12c44:	1080198b 	ldhu	r2,102(r2)
   12c48:	10bfffcc 	andi	r2,r2,65535
   12c4c:	1004d07a 	srli	r2,r2,1
   12c50:	e0fffc17 	ldw	r3,-16(fp)
   12c54:	18c00e8b 	ldhu	r3,58(r3)
   12c58:	113fffcc 	andi	r4,r2,65535
   12c5c:	197fffcc 	andi	r5,r3,65535
   12c60:	2900012e 	bgeu	r5,r4,12c68 <tcp_write+0x78>
   12c64:	1805883a 	mov	r2,r3
   12c68:	e0bff68d 	sth	r2,-38(fp)
  apiflags |= TCP_WRITE_FLAG_COPY;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)apiflags));
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)", 
   12c6c:	e0bffd17 	ldw	r2,-12(fp)
   12c70:	1000091e 	bne	r2,zero,12c98 <tcp_write+0xa8>
   12c74:	010000f4 	movhi	r4,3
   12c78:	2102c104 	addi	r4,r4,2820
   12c7c:	014000f4 	movhi	r5,3
   12c80:	2942fe04 	addi	r5,r5,3064
   12c84:	01805fc4 	movi	r6,383
   12c88:	01c000f4 	movhi	r7,3
   12c8c:	39c2d704 	addi	r7,r7,2908
   12c90:	00193f00 	call	193f0 <printf>
   12c94:	003fff06 	br	12c94 <tcp_write+0xa4>
             arg != NULL, return ERR_ARG;);

  err = tcp_write_checks(pcb, len);
   12c98:	e0bffe0b 	ldhu	r2,-8(fp)
   12c9c:	e13ffc17 	ldw	r4,-16(fp)
   12ca0:	100b883a 	mov	r5,r2
   12ca4:	0012a380 	call	12a38 <tcp_write_checks>
   12ca8:	e0bff705 	stb	r2,-36(fp)
  if (err != ERR_OK) {
   12cac:	e0bff707 	ldb	r2,-36(fp)
   12cb0:	10000226 	beq	r2,zero,12cbc <tcp_write+0xcc>
    return err;
   12cb4:	e0bff703 	ldbu	r2,-36(fp)
   12cb8:	00021006 	br	134fc <tcp_write+0x90c>
  }
  queuelen = pcb->snd_queuelen;
   12cbc:	e0bffc17 	ldw	r2,-16(fp)
   12cc0:	10801b0b 	ldhu	r2,108(r2)
   12cc4:	e0bff28d 	sth	r2,-54(fp)
   *
   * pos records progress as data is segmented.
   */

  /* Find the tail of the unsent queue. */
  if (pcb->unsent != NULL) {
   12cc8:	e0bffc17 	ldw	r2,-16(fp)
   12ccc:	10801c17 	ldw	r2,112(r2)
   12cd0:	1000a026 	beq	r2,zero,12f54 <tcp_write+0x364>
    u16_t space;
    u16_t unsent_optlen;

    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
   12cd4:	e0bffc17 	ldw	r2,-16(fp)
   12cd8:	10801c17 	ldw	r2,112(r2)
   12cdc:	e0bfee15 	stw	r2,-72(fp)
   12ce0:	00000306 	br	12cf0 <tcp_write+0x100>
         last_unsent = last_unsent->next);
   12ce4:	e0bfee17 	ldw	r2,-72(fp)
   12ce8:	10800017 	ldw	r2,0(r2)
   12cec:	e0bfee15 	stw	r2,-72(fp)
  if (pcb->unsent != NULL) {
    u16_t space;
    u16_t unsent_optlen;

    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
   12cf0:	e0bfee17 	ldw	r2,-72(fp)
   12cf4:	10800017 	ldw	r2,0(r2)
   12cf8:	103ffa1e 	bne	r2,zero,12ce4 <tcp_write+0xf4>
         last_unsent = last_unsent->next);

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
   12cfc:	e0bfee17 	ldw	r2,-72(fp)
   12d00:	10800283 	ldbu	r2,10(r2)
   12d04:	10803fcc 	andi	r2,r2,255
   12d08:	1080004c 	andi	r2,r2,1
   12d0c:	10000226 	beq	r2,zero,12d18 <tcp_write+0x128>
   12d10:	00c00104 	movi	r3,4
   12d14:	00000106 	br	12d1c <tcp_write+0x12c>
   12d18:	0007883a 	mov	r3,zero
   12d1c:	e0bfee17 	ldw	r2,-72(fp)
   12d20:	10800283 	ldbu	r2,10(r2)
   12d24:	10803fcc 	andi	r2,r2,255
   12d28:	1080008c 	andi	r2,r2,2
   12d2c:	10000226 	beq	r2,zero,12d38 <tcp_write+0x148>
   12d30:	00800304 	movi	r2,12
   12d34:	00000106 	br	12d3c <tcp_write+0x14c>
   12d38:	0005883a 	mov	r2,zero
   12d3c:	1885883a 	add	r2,r3,r2
   12d40:	e0bff78d 	sth	r2,-34(fp)
    space = mss_local - (last_unsent->len + unsent_optlen);
   12d44:	e0bfee17 	ldw	r2,-72(fp)
   12d48:	10c0020b 	ldhu	r3,8(r2)
   12d4c:	e0bff78b 	ldhu	r2,-34(fp)
   12d50:	1885883a 	add	r2,r3,r2
   12d54:	e0fff68b 	ldhu	r3,-38(fp)
   12d58:	1885c83a 	sub	r2,r3,r2
   12d5c:	e0bff38d 	sth	r2,-50(fp)
#if TCP_OVERSIZE_DBGCHECK
    /* check that pcb->unsent_oversize matches last_unsent->unsent_oversize */
    LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
                pcb->unsent_oversize == last_unsent->oversize_left);
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
   12d60:	e0bffc17 	ldw	r2,-16(fp)
   12d64:	10801b8b 	ldhu	r2,110(r2)
   12d68:	e0bffb0d 	sth	r2,-20(fp)
    if (oversize > 0) {
   12d6c:	e0bffb0b 	ldhu	r2,-20(fp)
   12d70:	10bfffcc 	andi	r2,r2,65535
   12d74:	10002126 	beq	r2,zero,12dfc <tcp_write+0x20c>
      LWIP_ASSERT("inconsistent oversize vs. space", oversize_used <= space);
   12d78:	e0bff30b 	ldhu	r2,-52(fp)
   12d7c:	e0fff38b 	ldhu	r3,-50(fp)
   12d80:	1880092e 	bgeu	r3,r2,12da8 <tcp_write+0x1b8>
   12d84:	010000f4 	movhi	r4,3
   12d88:	2102c104 	addi	r4,r4,2820
   12d8c:	014000f4 	movhi	r5,3
   12d90:	29430b04 	addi	r5,r5,3116
   12d94:	01807044 	movi	r6,449
   12d98:	01c000f4 	movhi	r7,3
   12d9c:	39c2d704 	addi	r7,r7,2908
   12da0:	00193f00 	call	193f0 <printf>
   12da4:	003fff06 	br	12da4 <tcp_write+0x1b4>
      seg = last_unsent;
   12da8:	e0bfee17 	ldw	r2,-72(fp)
   12dac:	e0bfef15 	stw	r2,-68(fp)
      oversize_used = oversize < len ? oversize : len;
   12db0:	e0fffb0b 	ldhu	r3,-20(fp)
   12db4:	e0bffe0b 	ldhu	r2,-8(fp)
   12db8:	113fffcc 	andi	r4,r2,65535
   12dbc:	197fffcc 	andi	r5,r3,65535
   12dc0:	2900012e 	bgeu	r5,r4,12dc8 <tcp_write+0x1d8>
   12dc4:	1805883a 	mov	r2,r3
   12dc8:	e0bff30d 	sth	r2,-52(fp)
      pos += oversize_used;
   12dcc:	e0fff20b 	ldhu	r3,-56(fp)
   12dd0:	e0bff30b 	ldhu	r2,-52(fp)
   12dd4:	1885883a 	add	r2,r3,r2
   12dd8:	e0bff20d 	sth	r2,-56(fp)
      oversize -= oversize_used;
   12ddc:	e0fffb0b 	ldhu	r3,-20(fp)
   12de0:	e0bff30b 	ldhu	r2,-52(fp)
   12de4:	1885c83a 	sub	r2,r3,r2
   12de8:	e0bffb0d 	sth	r2,-20(fp)
      space -= oversize_used;
   12dec:	e0fff38b 	ldhu	r3,-50(fp)
   12df0:	e0bff30b 	ldhu	r2,-52(fp)
   12df4:	1885c83a 	sub	r2,r3,r2
   12df8:	e0bff38d 	sth	r2,-50(fp)
    }
    /* now we are either finished or oversize is zero */
    LWIP_ASSERT("inconsistend oversize vs. len", (oversize == 0) || (pos == len));
   12dfc:	e0bffb0b 	ldhu	r2,-20(fp)
   12e00:	10bfffcc 	andi	r2,r2,65535
   12e04:	10000c26 	beq	r2,zero,12e38 <tcp_write+0x248>
   12e08:	e0fff20b 	ldhu	r3,-56(fp)
   12e0c:	e0bffe0b 	ldhu	r2,-8(fp)
   12e10:	18800926 	beq	r3,r2,12e38 <tcp_write+0x248>
   12e14:	010000f4 	movhi	r4,3
   12e18:	2102c104 	addi	r4,r4,2820
   12e1c:	014000f4 	movhi	r5,3
   12e20:	29431304 	addi	r5,r5,3148
   12e24:	01807244 	movi	r6,457
   12e28:	01c000f4 	movhi	r7,3
   12e2c:	39c2d704 	addi	r7,r7,2908
   12e30:	00193f00 	call	193f0 <printf>
   12e34:	003fff06 	br	12e34 <tcp_write+0x244>
     *
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
     * the end.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
   12e38:	e0fff20b 	ldhu	r3,-56(fp)
   12e3c:	e0bffe0b 	ldhu	r2,-8(fp)
   12e40:	1880ef2e 	bgeu	r3,r2,13200 <tcp_write+0x610>
   12e44:	e0bff38b 	ldhu	r2,-50(fp)
   12e48:	1000ed26 	beq	r2,zero,13200 <tcp_write+0x610>
   12e4c:	e0bfee17 	ldw	r2,-72(fp)
   12e50:	1080020b 	ldhu	r2,8(r2)
   12e54:	10bfffcc 	andi	r2,r2,65535
   12e58:	1000e926 	beq	r2,zero,13200 <tcp_write+0x610>
      u16_t seglen = space < len - pos ? space : len - pos;
   12e5c:	e0fffe0b 	ldhu	r3,-8(fp)
   12e60:	e0bff20b 	ldhu	r2,-56(fp)
   12e64:	1885c83a 	sub	r2,r3,r2
   12e68:	e0fff38b 	ldhu	r3,-50(fp)
   12e6c:	1880010e 	bge	r3,r2,12e74 <tcp_write+0x284>
   12e70:	1805883a 	mov	r2,r3
   12e74:	e0bff80d 	sth	r2,-32(fp)
      seg = last_unsent;
   12e78:	e0bfee17 	ldw	r2,-72(fp)
   12e7c:	e0bfef15 	stw	r2,-68(fp)

      /* Create a pbuf with a copy or reference to seglen bytes. We
       * can use PBUF_RAW here since the data appears in the middle of
       * a segment. A header will never be prepended. */
      if (apiflags & TCP_WRITE_FLAG_COPY) {
   12e80:	e0bfff03 	ldbu	r2,-4(fp)
   12e84:	1080004c 	andi	r2,r2,1
   12e88:	10001a26 	beq	r2,zero,12ef4 <tcp_write+0x304>
        /* Data is copied */
        if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
   12e8c:	e17ff80b 	ldhu	r5,-32(fp)
   12e90:	e0fff38b 	ldhu	r3,-50(fp)
   12e94:	e13fff03 	ldbu	r4,-4(fp)
   12e98:	e0bffb04 	addi	r2,fp,-20
   12e9c:	e1bffc17 	ldw	r6,-16(fp)
   12ea0:	d9800015 	stw	r6,0(sp)
   12ea4:	d9000115 	stw	r4,4(sp)
   12ea8:	01000044 	movi	r4,1
   12eac:	d9000215 	stw	r4,8(sp)
   12eb0:	010000c4 	movi	r4,3
   12eb4:	180d883a 	mov	r6,r3
   12eb8:	100f883a 	mov	r7,r2
   12ebc:	00128e40 	call	128e4 <tcp_pbuf_prealloc>
   12ec0:	e0bfed15 	stw	r2,-76(fp)
   12ec4:	e0bfed17 	ldw	r2,-76(fp)
   12ec8:	10015826 	beq	r2,zero,1342c <tcp_write+0x83c>
          goto memerr;
        }
#if TCP_OVERSIZE_DBGCHECK
        last_unsent->oversize_left += oversize;
#endif /* TCP_OVERSIZE_DBGCHECK */
        TCP_DATA_COPY2(concat_p->payload, (u8_t*)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
   12ecc:	e0bfed17 	ldw	r2,-76(fp)
   12ed0:	11000117 	ldw	r4,4(r2)
   12ed4:	e0bff20b 	ldhu	r2,-56(fp)
   12ed8:	e0fffd17 	ldw	r3,-12(fp)
   12edc:	1887883a 	add	r3,r3,r2
   12ee0:	e0bff80b 	ldhu	r2,-32(fp)
   12ee4:	180b883a 	mov	r5,r3
   12ee8:	100d883a 	mov	r6,r2
   12eec:	00191f00 	call	191f0 <memcpy>
   12ef0:	00000d06 	br	12f28 <tcp_write+0x338>
#if TCP_CHECKSUM_ON_COPY
        concat_chksummed += seglen;
#endif /* TCP_CHECKSUM_ON_COPY */
      } else {
        /* Data is not copied */
        if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
   12ef4:	e0bff80b 	ldhu	r2,-32(fp)
   12ef8:	010000c4 	movi	r4,3
   12efc:	100b883a 	mov	r5,r2
   12f00:	01800044 	movi	r6,1
   12f04:	000a0740 	call	a074 <pbuf_alloc>
   12f08:	e0bfed15 	stw	r2,-76(fp)
   12f0c:	e0bfed17 	ldw	r2,-76(fp)
   12f10:	10014826 	beq	r2,zero,13434 <tcp_write+0x844>
        tcp_seg_add_chksum(~inet_chksum((u8_t*)arg + pos, seglen), seglen,
          &concat_chksum, &concat_chksum_swapped);
        concat_chksummed += seglen;
#endif /* TCP_CHECKSUM_ON_COPY */
        /* reference the non-volatile payload data */
        concat_p->payload = (u8_t*)arg + pos;
   12f14:	e0bff20b 	ldhu	r2,-56(fp)
   12f18:	e0fffd17 	ldw	r3,-12(fp)
   12f1c:	1887883a 	add	r3,r3,r2
   12f20:	e0bfed17 	ldw	r2,-76(fp)
   12f24:	10c00115 	stw	r3,4(r2)
      }

      pos += seglen;
   12f28:	e0fff20b 	ldhu	r3,-56(fp)
   12f2c:	e0bff80b 	ldhu	r2,-32(fp)
   12f30:	1885883a 	add	r2,r3,r2
   12f34:	e0bff20d 	sth	r2,-56(fp)
      queuelen += pbuf_clen(concat_p);
   12f38:	e13fed17 	ldw	r4,-76(fp)
   12f3c:	000ac000 	call	ac00 <pbuf_clen>
   12f40:	10c03fcc 	andi	r3,r2,255
   12f44:	e0bff28b 	ldhu	r2,-54(fp)
   12f48:	1885883a 	add	r2,r3,r2
   12f4c:	e0bff28d 	sth	r2,-54(fp)
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
   12f50:	0000ab06 	br	13200 <tcp_write+0x610>
      pos += seglen;
      queuelen += pbuf_clen(concat_p);
    }
  } else {
#if TCP_OVERSIZE
    LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
   12f54:	e0bffc17 	ldw	r2,-16(fp)
   12f58:	10801b8b 	ldhu	r2,110(r2)
   12f5c:	10bfffcc 	andi	r2,r2,65535
   12f60:	1000a726 	beq	r2,zero,13200 <tcp_write+0x610>
   12f64:	010000f4 	movhi	r4,3
   12f68:	2102c104 	addi	r4,r4,2820
   12f6c:	014000f4 	movhi	r5,3
   12f70:	29431b04 	addi	r5,r5,3180
   12f74:	01808004 	movi	r6,512
   12f78:	01c000f4 	movhi	r7,3
   12f7c:	39c2d704 	addi	r7,r7,2908
   12f80:	00193f00 	call	193f0 <printf>
   12f84:	003fff06 	br	12f84 <tcp_write+0x394>
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
    struct pbuf *p;
    u16_t left = len - pos;
   12f88:	e0fffe0b 	ldhu	r3,-8(fp)
   12f8c:	e0bff20b 	ldhu	r2,-56(fp)
   12f90:	1885c83a 	sub	r2,r3,r2
   12f94:	e0bff88d 	sth	r2,-30(fp)
    u16_t max_len = mss_local - optlen;
   12f98:	e0bff603 	ldbu	r2,-40(fp)
   12f9c:	e0fff68b 	ldhu	r3,-38(fp)
   12fa0:	1885c83a 	sub	r2,r3,r2
   12fa4:	e0bff90d 	sth	r2,-28(fp)
    u16_t seglen = left > max_len ? max_len : left;
   12fa8:	e0fff90b 	ldhu	r3,-28(fp)
   12fac:	e0bff88b 	ldhu	r2,-30(fp)
   12fb0:	113fffcc 	andi	r4,r2,65535
   12fb4:	197fffcc 	andi	r5,r3,65535
   12fb8:	2900012e 	bgeu	r5,r4,12fc0 <tcp_write+0x3d0>
   12fbc:	1805883a 	mov	r2,r3
   12fc0:	e0bff98d 	sth	r2,-26(fp)
#if TCP_CHECKSUM_ON_COPY
    u16_t chksum = 0;
    u8_t chksum_swapped = 0;
#endif /* TCP_CHECKSUM_ON_COPY */

    if (apiflags & TCP_WRITE_FLAG_COPY) {
   12fc4:	e0bfff03 	ldbu	r2,-4(fp)
   12fc8:	1080004c 	andi	r2,r2,1
   12fcc:	10002f26 	beq	r2,zero,1308c <tcp_write+0x49c>
      /* If copy is set, memory should be allocated and data copied
       * into pbuf */
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
   12fd0:	e0fff603 	ldbu	r3,-40(fp)
   12fd4:	e0bff98b 	ldhu	r2,-26(fp)
   12fd8:	1885883a 	add	r2,r3,r2
   12fdc:	117fffcc 	andi	r5,r2,65535
   12fe0:	e0fff68b 	ldhu	r3,-38(fp)
   12fe4:	e1bfff03 	ldbu	r6,-4(fp)
   12fe8:	e0bff117 	ldw	r2,-60(fp)
   12fec:	1005003a 	cmpeq	r2,r2,zero
   12ff0:	11003fcc 	andi	r4,r2,255
   12ff4:	e0bffb04 	addi	r2,fp,-20
   12ff8:	e1fffc17 	ldw	r7,-16(fp)
   12ffc:	d9c00015 	stw	r7,0(sp)
   13000:	d9800115 	stw	r6,4(sp)
   13004:	d9000215 	stw	r4,8(sp)
   13008:	0009883a 	mov	r4,zero
   1300c:	180d883a 	mov	r6,r3
   13010:	100f883a 	mov	r7,r2
   13014:	00128e40 	call	128e4 <tcp_pbuf_prealloc>
   13018:	e0bff415 	stw	r2,-48(fp)
   1301c:	e0bff417 	ldw	r2,-48(fp)
   13020:	10010626 	beq	r2,zero,1343c <tcp_write+0x84c>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
   13024:	e0bff417 	ldw	r2,-48(fp)
   13028:	1080028b 	ldhu	r2,10(r2)
   1302c:	10ffffcc 	andi	r3,r2,65535
   13030:	e0bff98b 	ldhu	r2,-26(fp)
   13034:	1880092e 	bgeu	r3,r2,1305c <tcp_write+0x46c>
   13038:	010000f4 	movhi	r4,3
   1303c:	2102c104 	addi	r4,r4,2820
   13040:	014000f4 	movhi	r5,3
   13044:	29432704 	addi	r5,r5,3228
   13048:	01808704 	movi	r6,540
   1304c:	01c000f4 	movhi	r7,3
   13050:	39c2d704 	addi	r7,r7,2908
   13054:	00193f00 	call	193f0 <printf>
   13058:	003fff06 	br	13058 <tcp_write+0x468>
                  (p->len >= seglen));
      TCP_DATA_COPY2((char *)p->payload + optlen, (u8_t*)arg + pos, seglen, &chksum, &chksum_swapped);
   1305c:	e0bff417 	ldw	r2,-48(fp)
   13060:	10c00117 	ldw	r3,4(r2)
   13064:	e0bff603 	ldbu	r2,-40(fp)
   13068:	1889883a 	add	r4,r3,r2
   1306c:	e0bff20b 	ldhu	r2,-56(fp)
   13070:	e0fffd17 	ldw	r3,-12(fp)
   13074:	1887883a 	add	r3,r3,r2
   13078:	e0bff98b 	ldhu	r2,-26(fp)
   1307c:	180b883a 	mov	r5,r3
   13080:	100d883a 	mov	r6,r2
   13084:	00191f00 	call	191f0 <memcpy>
   13088:	00002706 	br	13128 <tcp_write+0x538>
       * sent out on the link (as it has to be ACKed by the remote
       * party) we can safely use PBUF_ROM instead of PBUF_REF here.
       */
      struct pbuf *p2;
#if TCP_OVERSIZE
      LWIP_ASSERT("oversize == 0", oversize == 0);
   1308c:	e0bffb0b 	ldhu	r2,-20(fp)
   13090:	10bfffcc 	andi	r2,r2,65535
   13094:	10000926 	beq	r2,zero,130bc <tcp_write+0x4cc>
   13098:	010000f4 	movhi	r4,3
   1309c:	2102c104 	addi	r4,r4,2820
   130a0:	014000f4 	movhi	r5,3
   130a4:	29433704 	addi	r5,r5,3292
   130a8:	01808984 	movi	r6,550
   130ac:	01c000f4 	movhi	r7,3
   130b0:	39c2d704 	addi	r7,r7,2908
   130b4:	00193f00 	call	193f0 <printf>
   130b8:	003fff06 	br	130b8 <tcp_write+0x4c8>
#endif /* TCP_OVERSIZE */
      if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
   130bc:	e0bff98b 	ldhu	r2,-26(fp)
   130c0:	0009883a 	mov	r4,zero
   130c4:	100b883a 	mov	r5,r2
   130c8:	01800044 	movi	r6,1
   130cc:	000a0740 	call	a074 <pbuf_alloc>
   130d0:	e0bffa15 	stw	r2,-24(fp)
   130d4:	e0bffa17 	ldw	r2,-24(fp)
   130d8:	1000da26 	beq	r2,zero,13444 <tcp_write+0x854>
#if TCP_CHECKSUM_ON_COPY
      /* calculate the checksum of nocopy-data */
      chksum = ~inet_chksum((u8_t*)arg + pos, seglen);
#endif /* TCP_CHECKSUM_ON_COPY */
      /* reference the non-volatile payload data */
      p2->payload = (u8_t*)arg + pos;
   130dc:	e0bff20b 	ldhu	r2,-56(fp)
   130e0:	e0fffd17 	ldw	r3,-12(fp)
   130e4:	1887883a 	add	r3,r3,r2
   130e8:	e0bffa17 	ldw	r2,-24(fp)
   130ec:	10c00115 	stw	r3,4(r2)

      /* Second, allocate a pbuf for the headers. */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
   130f0:	e0bff603 	ldbu	r2,-40(fp)
   130f4:	0009883a 	mov	r4,zero
   130f8:	100b883a 	mov	r5,r2
   130fc:	000d883a 	mov	r6,zero
   13100:	000a0740 	call	a074 <pbuf_alloc>
   13104:	e0bff415 	stw	r2,-48(fp)
   13108:	e0bff417 	ldw	r2,-48(fp)
   1310c:	1000031e 	bne	r2,zero,1311c <tcp_write+0x52c>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p2);
   13110:	e13ffa17 	ldw	r4,-24(fp)
   13114:	000aa340 	call	aa34 <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for header pbuf\n"));
        goto memerr;
   13118:	0000cd06 	br	13450 <tcp_write+0x860>
      }
      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(p/*header*/, p2/*data*/);
   1311c:	e13ff417 	ldw	r4,-48(fp)
   13120:	e17ffa17 	ldw	r5,-24(fp)
   13124:	000ac8c0 	call	ac8c <pbuf_cat>
    }

    queuelen += pbuf_clen(p);
   13128:	e13ff417 	ldw	r4,-48(fp)
   1312c:	000ac000 	call	ac00 <pbuf_clen>
   13130:	10c03fcc 	andi	r3,r2,255
   13134:	e0bff28b 	ldhu	r2,-54(fp)
   13138:	1885883a 	add	r2,r3,r2
   1313c:	e0bff28d 	sth	r2,-54(fp)

    /* Now that there are more segments queued, we check again if the
     * length of the queue exceeds the configured maximum or
     * overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
   13140:	e0bff28b 	ldhu	r2,-54(fp)
   13144:	10800b68 	cmpgeui	r2,r2,45
   13148:	1000031e 	bne	r2,zero,13158 <tcp_write+0x568>
   1314c:	e0bff28b 	ldhu	r2,-54(fp)
   13150:	10bfff70 	cmpltui	r2,r2,65533
   13154:	1000031e 	bne	r2,zero,13164 <tcp_write+0x574>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      pbuf_free(p);
   13158:	e13ff417 	ldw	r4,-48(fp)
   1315c:	000aa340 	call	aa34 <pbuf_free>
      goto memerr;
   13160:	0000bb06 	br	13450 <tcp_write+0x860>
    }

    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
   13164:	e0bffc17 	ldw	r2,-16(fp)
   13168:	10c01817 	ldw	r3,96(r2)
   1316c:	e0bff20b 	ldhu	r2,-56(fp)
   13170:	1885883a 	add	r2,r3,r2
   13174:	e0fff643 	ldbu	r3,-39(fp)
   13178:	d8c00015 	stw	r3,0(sp)
   1317c:	e13ffc17 	ldw	r4,-16(fp)
   13180:	e17ff417 	ldw	r5,-48(fp)
   13184:	000d883a 	mov	r6,zero
   13188:	100f883a 	mov	r7,r2
   1318c:	00126800 	call	12680 <tcp_create_segment>
   13190:	e0bfef15 	stw	r2,-68(fp)
   13194:	e0bfef17 	ldw	r2,-68(fp)
   13198:	1000ac26 	beq	r2,zero,1344c <tcp_write+0x85c>
    seg->chksum_swapped = chksum_swapped;
    seg->flags |= TF_SEG_DATA_CHECKSUMMED;
#endif /* TCP_CHECKSUM_ON_COPY */

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
   1319c:	e0bff117 	ldw	r2,-60(fp)
   131a0:	1000031e 	bne	r2,zero,131b0 <tcp_write+0x5c0>
      queue = seg;
   131a4:	e0bfef17 	ldw	r2,-68(fp)
   131a8:	e0bff115 	stw	r2,-60(fp)
   131ac:	00000e06 	br	131e8 <tcp_write+0x5f8>
    } else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
   131b0:	e0bff017 	ldw	r2,-64(fp)
   131b4:	1000091e 	bne	r2,zero,131dc <tcp_write+0x5ec>
   131b8:	010000f4 	movhi	r4,3
   131bc:	2102c104 	addi	r4,r4,2820
   131c0:	014000f4 	movhi	r5,3
   131c4:	29433b04 	addi	r5,r5,3308
   131c8:	018096c4 	movi	r6,603
   131cc:	01c000f4 	movhi	r7,3
   131d0:	39c2d704 	addi	r7,r7,2908
   131d4:	00193f00 	call	193f0 <printf>
   131d8:	003fff06 	br	131d8 <tcp_write+0x5e8>
      prev_seg->next = seg;
   131dc:	e0bff017 	ldw	r2,-64(fp)
   131e0:	e0ffef17 	ldw	r3,-68(fp)
   131e4:	10c00015 	stw	r3,0(r2)
    }
    /* remember last segment of to-be-queued data for next iteration */
    prev_seg = seg;
   131e8:	e0bfef17 	ldw	r2,-68(fp)
   131ec:	e0bff015 	stw	r2,-64(fp)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));

    pos += seglen;
   131f0:	e0fff20b 	ldhu	r3,-56(fp)
   131f4:	e0bff98b 	ldhu	r2,-26(fp)
   131f8:	1885883a 	add	r2,r3,r2
   131fc:	e0bff20d 	sth	r2,-56(fp)
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
   13200:	e0fff20b 	ldhu	r3,-56(fp)
   13204:	e0bffe0b 	ldhu	r2,-8(fp)
   13208:	18bf5f36 	bltu	r3,r2,12f88 <tcp_write+0x398>
  /*
   * Phase 1: If data has been added to the preallocated tail of
   * last_unsent, we update the length fields of the pbuf chain.
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
   1320c:	e0bff30b 	ldhu	r2,-52(fp)
   13210:	10002c26 	beq	r2,zero,132c4 <tcp_write+0x6d4>
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
   13214:	e0bfee17 	ldw	r2,-72(fp)
   13218:	10800117 	ldw	r2,4(r2)
   1321c:	e0bff515 	stw	r2,-44(fp)
   13220:	00001f06 	br	132a0 <tcp_write+0x6b0>
      p->tot_len += oversize_used;
   13224:	e0bff517 	ldw	r2,-44(fp)
   13228:	10c0020b 	ldhu	r3,8(r2)
   1322c:	e0bff30b 	ldhu	r2,-52(fp)
   13230:	1885883a 	add	r2,r3,r2
   13234:	1007883a 	mov	r3,r2
   13238:	e0bff517 	ldw	r2,-44(fp)
   1323c:	10c0020d 	sth	r3,8(r2)
      if (p->next == NULL) {
   13240:	e0bff517 	ldw	r2,-44(fp)
   13244:	10800017 	ldw	r2,0(r2)
   13248:	1000121e 	bne	r2,zero,13294 <tcp_write+0x6a4>
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
   1324c:	e0bff517 	ldw	r2,-44(fp)
   13250:	10c00117 	ldw	r3,4(r2)
   13254:	e0bff517 	ldw	r2,-44(fp)
   13258:	1080028b 	ldhu	r2,10(r2)
   1325c:	10bfffcc 	andi	r2,r2,65535
   13260:	1887883a 	add	r3,r3,r2
   13264:	e0bff30b 	ldhu	r2,-52(fp)
   13268:	1809883a 	mov	r4,r3
   1326c:	e17ffd17 	ldw	r5,-12(fp)
   13270:	100d883a 	mov	r6,r2
   13274:	00191f00 	call	191f0 <memcpy>
        p->len += oversize_used;
   13278:	e0bff517 	ldw	r2,-44(fp)
   1327c:	10c0028b 	ldhu	r3,10(r2)
   13280:	e0bff30b 	ldhu	r2,-52(fp)
   13284:	1885883a 	add	r2,r3,r2
   13288:	1007883a 	mov	r3,r2
   1328c:	e0bff517 	ldw	r2,-44(fp)
   13290:	10c0028d 	sth	r3,10(r2)
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
   13294:	e0bff517 	ldw	r2,-44(fp)
   13298:	10800017 	ldw	r2,0(r2)
   1329c:	e0bff515 	stw	r2,-44(fp)
   132a0:	e0bff517 	ldw	r2,-44(fp)
   132a4:	103fdf1e 	bne	r2,zero,13224 <tcp_write+0x634>
      if (p->next == NULL) {
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
        p->len += oversize_used;
      }
    }
    last_unsent->len += oversize_used;
   132a8:	e0bfee17 	ldw	r2,-72(fp)
   132ac:	10c0020b 	ldhu	r3,8(r2)
   132b0:	e0bff30b 	ldhu	r2,-52(fp)
   132b4:	1885883a 	add	r2,r3,r2
   132b8:	1007883a 	mov	r3,r2
   132bc:	e0bfee17 	ldw	r2,-72(fp)
   132c0:	10c0020d 	sth	r3,8(r2)
    LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
                last_unsent->oversize_left >= oversize_used);
    last_unsent->oversize_left -= oversize_used;
#endif /* TCP_OVERSIZE_DBGCHECK */
  }
  pcb->unsent_oversize = oversize;
   132c4:	e0fffb0b 	ldhu	r3,-20(fp)
   132c8:	e0bffc17 	ldw	r2,-16(fp)
   132cc:	10c01b8d 	sth	r3,110(r2)
#endif /* TCP_OVERSIZE */

  /*
   * Phase 2: concat_p can be concatenated onto last_unsent->p
   */
  if (concat_p != NULL) {
   132d0:	e0bfed17 	ldw	r2,-76(fp)
   132d4:	10001826 	beq	r2,zero,13338 <tcp_write+0x748>
    LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
   132d8:	e0bfee17 	ldw	r2,-72(fp)
   132dc:	1000091e 	bne	r2,zero,13304 <tcp_write+0x714>
   132e0:	010000f4 	movhi	r4,3
   132e4:	2102c104 	addi	r4,r4,2820
   132e8:	014000f4 	movhi	r5,3
   132ec:	29434004 	addi	r5,r5,3328
   132f0:	0180a2c4 	movi	r6,651
   132f4:	01c000f4 	movhi	r7,3
   132f8:	39c2d704 	addi	r7,r7,2908
   132fc:	00193f00 	call	193f0 <printf>
   13300:	003fff06 	br	13300 <tcp_write+0x710>
      (last_unsent != NULL));
    pbuf_cat(last_unsent->p, concat_p);
   13304:	e0bfee17 	ldw	r2,-72(fp)
   13308:	10800117 	ldw	r2,4(r2)
   1330c:	1009883a 	mov	r4,r2
   13310:	e17fed17 	ldw	r5,-76(fp)
   13314:	000ac8c0 	call	ac8c <pbuf_cat>
    last_unsent->len += concat_p->tot_len;
   13318:	e0bfee17 	ldw	r2,-72(fp)
   1331c:	10c0020b 	ldhu	r3,8(r2)
   13320:	e0bfed17 	ldw	r2,-76(fp)
   13324:	1080020b 	ldhu	r2,8(r2)
   13328:	1885883a 	add	r2,r3,r2
   1332c:	1007883a 	mov	r3,r2
   13330:	e0bfee17 	ldw	r2,-72(fp)
   13334:	10c0020d 	sth	r3,8(r2)

  /*
   * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
   * is harmless
   */
  if (last_unsent == NULL) {
   13338:	e0bfee17 	ldw	r2,-72(fp)
   1333c:	1000041e 	bne	r2,zero,13350 <tcp_write+0x760>
    pcb->unsent = queue;
   13340:	e0bffc17 	ldw	r2,-16(fp)
   13344:	e0fff117 	ldw	r3,-60(fp)
   13348:	10c01c15 	stw	r3,112(r2)
   1334c:	00000306 	br	1335c <tcp_write+0x76c>
  } else {
    last_unsent->next = queue;
   13350:	e0bfee17 	ldw	r2,-72(fp)
   13354:	e0fff117 	ldw	r3,-60(fp)
   13358:	10c00015 	stw	r3,0(r2)
  }

  /*
   * Finally update the pcb state.
   */
  pcb->snd_lbb += len;
   1335c:	e0bffc17 	ldw	r2,-16(fp)
   13360:	10c01817 	ldw	r3,96(r2)
   13364:	e0bffe0b 	ldhu	r2,-8(fp)
   13368:	1887883a 	add	r3,r3,r2
   1336c:	e0bffc17 	ldw	r2,-16(fp)
   13370:	10c01815 	stw	r3,96(r2)
  pcb->snd_buf -= len;
   13374:	e0bffc17 	ldw	r2,-16(fp)
   13378:	10c01a8b 	ldhu	r3,106(r2)
   1337c:	e0bffe0b 	ldhu	r2,-8(fp)
   13380:	1885c83a 	sub	r2,r3,r2
   13384:	1007883a 	mov	r3,r2
   13388:	e0bffc17 	ldw	r2,-16(fp)
   1338c:	10c01a8d 	sth	r3,106(r2)
  pcb->snd_queuelen = queuelen;
   13390:	e0bffc17 	ldw	r2,-16(fp)
   13394:	e0fff28b 	ldhu	r3,-54(fp)
   13398:	10c01b0d 	sth	r3,108(r2)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: %"S16_F" (after enqueued)\n",
    pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
   1339c:	e0bffc17 	ldw	r2,-16(fp)
   133a0:	10801b0b 	ldhu	r2,108(r2)
   133a4:	10bfffcc 	andi	r2,r2,65535
   133a8:	10000f26 	beq	r2,zero,133e8 <tcp_write+0x7f8>
    LWIP_ASSERT("tcp_write: valid queue length",
   133ac:	e0bffc17 	ldw	r2,-16(fp)
   133b0:	10801d17 	ldw	r2,116(r2)
   133b4:	10000c1e 	bne	r2,zero,133e8 <tcp_write+0x7f8>
   133b8:	e0bffc17 	ldw	r2,-16(fp)
   133bc:	10801c17 	ldw	r2,112(r2)
   133c0:	1000091e 	bne	r2,zero,133e8 <tcp_write+0x7f8>
   133c4:	010000f4 	movhi	r4,3
   133c8:	2102c104 	addi	r4,r4,2820
   133cc:	014000f4 	movhi	r5,3
   133d0:	29434e04 	addi	r5,r5,3384
   133d4:	0180ab04 	movi	r6,684
   133d8:	01c000f4 	movhi	r7,3
   133dc:	39c2d704 	addi	r7,r7,2908
   133e0:	00193f00 	call	193f0 <printf>
   133e4:	003fff06 	br	133e4 <tcp_write+0x7f4>
                pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued. */
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
   133e8:	e0bfef17 	ldw	r2,-68(fp)
   133ec:	10000d26 	beq	r2,zero,13424 <tcp_write+0x834>
   133f0:	e0bfef17 	ldw	r2,-68(fp)
   133f4:	10800317 	ldw	r2,12(r2)
   133f8:	10000a26 	beq	r2,zero,13424 <tcp_write+0x834>
   133fc:	e0bfff03 	ldbu	r2,-4(fp)
   13400:	1080008c 	andi	r2,r2,2
   13404:	1000071e 	bne	r2,zero,13424 <tcp_write+0x834>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
   13408:	e0bfef17 	ldw	r2,-68(fp)
   1340c:	10800317 	ldw	r2,12(r2)
   13410:	e0ffef17 	ldw	r3,-68(fp)
   13414:	18c00317 	ldw	r3,12(r3)
   13418:	18c0030b 	ldhu	r3,12(r3)
   1341c:	18c20014 	ori	r3,r3,2048
   13420:	10c0030d 	sth	r3,12(r2)
  }

  return ERR_OK;
   13424:	0005883a 	mov	r2,zero
   13428:	00003406 	br	134fc <tcp_write+0x90c>
        /* Data is copied */
        if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
          LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,
                      ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n",
                       seglen));
          goto memerr;
   1342c:	0001883a 	nop
   13430:	00000706 	br	13450 <tcp_write+0x860>
      } else {
        /* Data is not copied */
        if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
          LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,
                      ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
          goto memerr;
   13434:	0001883a 	nop
   13438:	00000506 	br	13450 <tcp_write+0x860>
    if (apiflags & TCP_WRITE_FLAG_COPY) {
      /* If copy is set, memory should be allocated and data copied
       * into pbuf */
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
   1343c:	0001883a 	nop
   13440:	00000306 	br	13450 <tcp_write+0x860>
#if TCP_OVERSIZE
      LWIP_ASSERT("oversize == 0", oversize == 0);
#endif /* TCP_OVERSIZE */
      if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
   13444:	0001883a 	nop
   13448:	00000106 	br	13450 <tcp_write+0x860>
      pbuf_free(p);
      goto memerr;
    }

    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
      goto memerr;
   1344c:	0001883a 	nop
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
   13450:	e0bffc17 	ldw	r2,-16(fp)
   13454:	10c00883 	ldbu	r3,34(r2)
   13458:	00bfe004 	movi	r2,-128
   1345c:	1884b03a 	or	r2,r3,r2
   13460:	1007883a 	mov	r3,r2
   13464:	e0bffc17 	ldw	r2,-16(fp)
   13468:	10c00885 	stb	r3,34(r2)
  TCP_STATS_INC(tcp.memerr);
   1346c:	00800234 	movhi	r2,8
   13470:	1083bd04 	addi	r2,r2,3828
   13474:	1080270b 	ldhu	r2,156(r2)
   13478:	10800044 	addi	r2,r2,1
   1347c:	1007883a 	mov	r3,r2
   13480:	00800234 	movhi	r2,8
   13484:	1083bd04 	addi	r2,r2,3828
   13488:	10c0270d 	sth	r3,156(r2)

  if (concat_p != NULL) {
   1348c:	e0bfed17 	ldw	r2,-76(fp)
   13490:	10000226 	beq	r2,zero,1349c <tcp_write+0x8ac>
    pbuf_free(concat_p);
   13494:	e13fed17 	ldw	r4,-76(fp)
   13498:	000aa340 	call	aa34 <pbuf_free>
  }
  if (queue != NULL) {
   1349c:	e0bff117 	ldw	r2,-60(fp)
   134a0:	10000226 	beq	r2,zero,134ac <tcp_write+0x8bc>
    tcp_segs_free(queue);
   134a4:	e13ff117 	ldw	r4,-60(fp)
   134a8:	000d9b80 	call	d9b8 <tcp_segs_free>
  }
  if (pcb->snd_queuelen != 0) {
   134ac:	e0bffc17 	ldw	r2,-16(fp)
   134b0:	10801b0b 	ldhu	r2,108(r2)
   134b4:	10bfffcc 	andi	r2,r2,65535
   134b8:	10000f26 	beq	r2,zero,134f8 <tcp_write+0x908>
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
   134bc:	e0bffc17 	ldw	r2,-16(fp)
   134c0:	10801d17 	ldw	r2,116(r2)
   134c4:	10000c1e 	bne	r2,zero,134f8 <tcp_write+0x908>
   134c8:	e0bffc17 	ldw	r2,-16(fp)
   134cc:	10801c17 	ldw	r2,112(r2)
   134d0:	1000091e 	bne	r2,zero,134f8 <tcp_write+0x908>
   134d4:	010000f4 	movhi	r4,3
   134d8:	2102c104 	addi	r4,r4,2820
   134dc:	014000f4 	movhi	r5,3
   134e0:	29434e04 	addi	r5,r5,3384
   134e4:	0180b044 	movi	r6,705
   134e8:	01c000f4 	movhi	r7,3
   134ec:	39c2d704 	addi	r7,r7,2908
   134f0:	00193f00 	call	193f0 <printf>
   134f4:	003fff06 	br	134f4 <tcp_write+0x904>
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
   134f8:	00bfffc4 	movi	r2,-1
}
   134fc:	e037883a 	mov	sp,fp
   13500:	dfc00117 	ldw	ra,4(sp)
   13504:	df000017 	ldw	fp,0(sp)
   13508:	dec00204 	addi	sp,sp,8
   1350c:	f800283a 	ret

00013510 <tcp_enqueue_flags>:
 * @param optdata pointer to TCP options, or NULL.
 * @param optlen length of TCP options in bytes.
 */
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
   13510:	defff504 	addi	sp,sp,-44
   13514:	dfc00a15 	stw	ra,40(sp)
   13518:	df000915 	stw	fp,36(sp)
   1351c:	dc000815 	stw	r16,32(sp)
   13520:	df000804 	addi	fp,sp,32
   13524:	e13ffe15 	stw	r4,-8(fp)
   13528:	2805883a 	mov	r2,r5
   1352c:	e0bfff05 	stb	r2,-4(fp)
  struct pbuf *p;
  struct tcp_seg *seg;
  u8_t optflags = 0;
   13530:	e03ff905 	stb	zero,-28(fp)
  u8_t optlen = 0;
   13534:	e03ffb05 	stb	zero,-20(fp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
   13538:	e0bfff03 	ldbu	r2,-4(fp)
   1353c:	108000cc 	andi	r2,r2,3
   13540:	1000091e 	bne	r2,zero,13568 <tcp_enqueue_flags+0x58>
   13544:	010000f4 	movhi	r4,3
   13548:	2102c104 	addi	r4,r4,2820
   1354c:	014000f4 	movhi	r5,3
   13550:	29435604 	addi	r5,r5,3416
   13554:	0180b704 	movi	r6,732
   13558:	01c000f4 	movhi	r7,3
   1355c:	39c2d704 	addi	r7,r7,2908
   13560:	00193f00 	call	193f0 <printf>
   13564:	003fff06 	br	13564 <tcp_enqueue_flags+0x54>
              (flags & (TCP_SYN | TCP_FIN)) != 0);

  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
   13568:	e0bffe17 	ldw	r2,-8(fp)
   1356c:	10801b0b 	ldhu	r2,108(r2)
   13570:	10bfffcc 	andi	r2,r2,65535
   13574:	10800b28 	cmpgeui	r2,r2,44
   13578:	1000051e 	bne	r2,zero,13590 <tcp_enqueue_flags+0x80>
   1357c:	e0bffe17 	ldw	r2,-8(fp)
   13580:	10801b0b 	ldhu	r2,108(r2)
   13584:	10bfffcc 	andi	r2,r2,65535
   13588:	10bfff70 	cmpltui	r2,r2,65533
   1358c:	1000111e 	bne	r2,zero,135d4 <tcp_enqueue_flags+0xc4>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: too long queue %"U16_F" (max %"U16_F")\n",
                                       pcb->snd_queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
   13590:	00800234 	movhi	r2,8
   13594:	1083bd04 	addi	r2,r2,3828
   13598:	1080270b 	ldhu	r2,156(r2)
   1359c:	10800044 	addi	r2,r2,1
   135a0:	1007883a 	mov	r3,r2
   135a4:	00800234 	movhi	r2,8
   135a8:	1083bd04 	addi	r2,r2,3828
   135ac:	10c0270d 	sth	r3,156(r2)
    pcb->flags |= TF_NAGLEMEMERR;
   135b0:	e0bffe17 	ldw	r2,-8(fp)
   135b4:	10c00883 	ldbu	r3,34(r2)
   135b8:	00bfe004 	movi	r2,-128
   135bc:	1884b03a 	or	r2,r3,r2
   135c0:	1007883a 	mov	r3,r2
   135c4:	e0bffe17 	ldw	r2,-8(fp)
   135c8:	10c00885 	stb	r3,34(r2)
    return ERR_MEM;
   135cc:	00bfffc4 	movi	r2,-1
   135d0:	0000d006 	br	13914 <tcp_enqueue_flags+0x404>
  }

  if (flags & TCP_SYN) {
   135d4:	e0bfff03 	ldbu	r2,-4(fp)
   135d8:	1080008c 	andi	r2,r2,2
   135dc:	10000226 	beq	r2,zero,135e8 <tcp_enqueue_flags+0xd8>
    optflags = TF_SEG_OPTS_MSS;
   135e0:	00800044 	movi	r2,1
   135e4:	e0bff905 	stb	r2,-28(fp)
#if LWIP_TCP_TIMESTAMPS
  if ((pcb->flags & TF_TIMESTAMP)) {
    optflags |= TF_SEG_OPTS_TS;
  }
#endif /* LWIP_TCP_TIMESTAMPS */
  optlen = LWIP_TCP_OPT_LENGTH(optflags);
   135e8:	e0bff903 	ldbu	r2,-28(fp)
   135ec:	1080004c 	andi	r2,r2,1
   135f0:	10000226 	beq	r2,zero,135fc <tcp_enqueue_flags+0xec>
   135f4:	00c00104 	movi	r3,4
   135f8:	00000106 	br	13600 <tcp_enqueue_flags+0xf0>
   135fc:	0007883a 	mov	r3,zero
   13600:	e0bff903 	ldbu	r2,-28(fp)
   13604:	1080008c 	andi	r2,r2,2
   13608:	10000226 	beq	r2,zero,13614 <tcp_enqueue_flags+0x104>
   1360c:	00800304 	movi	r2,12
   13610:	00000106 	br	13618 <tcp_enqueue_flags+0x108>
   13614:	0005883a 	mov	r2,zero
   13618:	1885883a 	add	r2,r3,r2
   1361c:	e0bffb05 	stb	r2,-20(fp)

  /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
   * We need one available snd_buf byte to do that.
   * This means we can't send FIN while snd_buf==0. A better fix would be to
   * not include SYN and FIN sequence numbers in the snd_buf count. */
  if (pcb->snd_buf == 0) {
   13620:	e0bffe17 	ldw	r2,-8(fp)
   13624:	10801a8b 	ldhu	r2,106(r2)
   13628:	10bfffcc 	andi	r2,r2,65535
   1362c:	10000a1e 	bne	r2,zero,13658 <tcp_enqueue_flags+0x148>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: no send buffer available\n"));
    TCP_STATS_INC(tcp.memerr);
   13630:	00800234 	movhi	r2,8
   13634:	1083bd04 	addi	r2,r2,3828
   13638:	1080270b 	ldhu	r2,156(r2)
   1363c:	10800044 	addi	r2,r2,1
   13640:	1007883a 	mov	r3,r2
   13644:	00800234 	movhi	r2,8
   13648:	1083bd04 	addi	r2,r2,3828
   1364c:	10c0270d 	sth	r3,156(r2)
    return ERR_MEM;
   13650:	00bfffc4 	movi	r2,-1
   13654:	0000af06 	br	13914 <tcp_enqueue_flags+0x404>
  }

  /* Allocate pbuf with room for TCP header + options */
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
   13658:	e0bffb03 	ldbu	r2,-20(fp)
   1365c:	0009883a 	mov	r4,zero
   13660:	100b883a 	mov	r5,r2
   13664:	000d883a 	mov	r6,zero
   13668:	000a0740 	call	a074 <pbuf_alloc>
   1366c:	e0bffc15 	stw	r2,-16(fp)
   13670:	e0bffc17 	ldw	r2,-16(fp)
   13674:	1000111e 	bne	r2,zero,136bc <tcp_enqueue_flags+0x1ac>
    pcb->flags |= TF_NAGLEMEMERR;
   13678:	e0bffe17 	ldw	r2,-8(fp)
   1367c:	10c00883 	ldbu	r3,34(r2)
   13680:	00bfe004 	movi	r2,-128
   13684:	1884b03a 	or	r2,r3,r2
   13688:	1007883a 	mov	r3,r2
   1368c:	e0bffe17 	ldw	r2,-8(fp)
   13690:	10c00885 	stb	r3,34(r2)
    TCP_STATS_INC(tcp.memerr);
   13694:	00800234 	movhi	r2,8
   13698:	1083bd04 	addi	r2,r2,3828
   1369c:	1080270b 	ldhu	r2,156(r2)
   136a0:	10800044 	addi	r2,r2,1
   136a4:	1007883a 	mov	r3,r2
   136a8:	00800234 	movhi	r2,8
   136ac:	1083bd04 	addi	r2,r2,3828
   136b0:	10c0270d 	sth	r3,156(r2)
    return ERR_MEM;
   136b4:	00bfffc4 	movi	r2,-1
   136b8:	00009606 	br	13914 <tcp_enqueue_flags+0x404>
  }
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
   136bc:	e0bffc17 	ldw	r2,-16(fp)
   136c0:	10c0028b 	ldhu	r3,10(r2)
   136c4:	e0bffb03 	ldbu	r2,-20(fp)
   136c8:	18ffffcc 	andi	r3,r3,65535
   136cc:	10bfffcc 	andi	r2,r2,65535
   136d0:	1880092e 	bgeu	r3,r2,136f8 <tcp_enqueue_flags+0x1e8>
   136d4:	010000f4 	movhi	r4,3
   136d8:	2102c104 	addi	r4,r4,2820
   136dc:	014000f4 	movhi	r5,3
   136e0:	29436c04 	addi	r5,r5,3504
   136e4:	0180c084 	movi	r6,770
   136e8:	01c000f4 	movhi	r7,3
   136ec:	39c2d704 	addi	r7,r7,2908
   136f0:	00193f00 	call	193f0 <printf>
   136f4:	003fff06 	br	136f4 <tcp_enqueue_flags+0x1e4>
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
   136f8:	e0ffff03 	ldbu	r3,-4(fp)
   136fc:	e0bffe17 	ldw	r2,-8(fp)
   13700:	10801817 	ldw	r2,96(r2)
   13704:	e13ff903 	ldbu	r4,-28(fp)
   13708:	d9000015 	stw	r4,0(sp)
   1370c:	e13ffe17 	ldw	r4,-8(fp)
   13710:	e17ffc17 	ldw	r5,-16(fp)
   13714:	180d883a 	mov	r6,r3
   13718:	100f883a 	mov	r7,r2
   1371c:	00126800 	call	12680 <tcp_create_segment>
   13720:	e0bffd15 	stw	r2,-12(fp)
   13724:	e0bffd17 	ldw	r2,-12(fp)
   13728:	1000111e 	bne	r2,zero,13770 <tcp_enqueue_flags+0x260>
    pcb->flags |= TF_NAGLEMEMERR;
   1372c:	e0bffe17 	ldw	r2,-8(fp)
   13730:	10c00883 	ldbu	r3,34(r2)
   13734:	00bfe004 	movi	r2,-128
   13738:	1884b03a 	or	r2,r3,r2
   1373c:	1007883a 	mov	r3,r2
   13740:	e0bffe17 	ldw	r2,-8(fp)
   13744:	10c00885 	stb	r3,34(r2)
    TCP_STATS_INC(tcp.memerr);
   13748:	00800234 	movhi	r2,8
   1374c:	1083bd04 	addi	r2,r2,3828
   13750:	1080270b 	ldhu	r2,156(r2)
   13754:	10800044 	addi	r2,r2,1
   13758:	1007883a 	mov	r3,r2
   1375c:	00800234 	movhi	r2,8
   13760:	1083bd04 	addi	r2,r2,3828
   13764:	10c0270d 	sth	r3,156(r2)
    return ERR_MEM;
   13768:	00bfffc4 	movi	r2,-1
   1376c:	00006906 	br	13914 <tcp_enqueue_flags+0x404>
  }
  LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % MEM_ALIGNMENT) == 0);
   13770:	e0bffd17 	ldw	r2,-12(fp)
   13774:	10800317 	ldw	r2,12(r2)
   13778:	108000cc 	andi	r2,r2,3
   1377c:	10000926 	beq	r2,zero,137a4 <tcp_enqueue_flags+0x294>
   13780:	010000f4 	movhi	r4,3
   13784:	2102c104 	addi	r4,r4,2820
   13788:	014000f4 	movhi	r5,3
   1378c:	29437b04 	addi	r5,r5,3564
   13790:	0180c284 	movi	r6,778
   13794:	01c000f4 	movhi	r7,3
   13798:	39c2d704 	addi	r7,r7,2908
   1379c:	00193f00 	call	193f0 <printf>
   137a0:	003fff06 	br	137a0 <tcp_enqueue_flags+0x290>
  LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
   137a4:	e0bffd17 	ldw	r2,-12(fp)
   137a8:	1080020b 	ldhu	r2,8(r2)
   137ac:	10bfffcc 	andi	r2,r2,65535
   137b0:	10000926 	beq	r2,zero,137d8 <tcp_enqueue_flags+0x2c8>
   137b4:	010000f4 	movhi	r4,3
   137b8:	2102c104 	addi	r4,r4,2820
   137bc:	014000f4 	movhi	r5,3
   137c0:	29438104 	addi	r5,r5,3588
   137c4:	0180c2c4 	movi	r6,779
   137c8:	01c000f4 	movhi	r7,3
   137cc:	39c2d704 	addi	r7,r7,2908
   137d0:	00193f00 	call	193f0 <printf>
   137d4:	003fff06 	br	137d4 <tcp_enqueue_flags+0x2c4>
               ntohl(seg->tcphdr->seqno),
               ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
   137d8:	e0bffe17 	ldw	r2,-8(fp)
   137dc:	10801c17 	ldw	r2,112(r2)
   137e0:	1000041e 	bne	r2,zero,137f4 <tcp_enqueue_flags+0x2e4>
    pcb->unsent = seg;
   137e4:	e0bffe17 	ldw	r2,-8(fp)
   137e8:	e0fffd17 	ldw	r3,-12(fp)
   137ec:	10c01c15 	stw	r3,112(r2)
   137f0:	00000d06 	br	13828 <tcp_enqueue_flags+0x318>
  } else {
    struct tcp_seg *useg;
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
   137f4:	e0bffe17 	ldw	r2,-8(fp)
   137f8:	10801c17 	ldw	r2,112(r2)
   137fc:	e0bffa15 	stw	r2,-24(fp)
   13800:	00000306 	br	13810 <tcp_enqueue_flags+0x300>
   13804:	e0bffa17 	ldw	r2,-24(fp)
   13808:	10800017 	ldw	r2,0(r2)
   1380c:	e0bffa15 	stw	r2,-24(fp)
   13810:	e0bffa17 	ldw	r2,-24(fp)
   13814:	10800017 	ldw	r2,0(r2)
   13818:	103ffa1e 	bne	r2,zero,13804 <tcp_enqueue_flags+0x2f4>
    useg->next = seg;
   1381c:	e0bffa17 	ldw	r2,-24(fp)
   13820:	e0fffd17 	ldw	r3,-12(fp)
   13824:	10c00015 	stw	r3,0(r2)
  }
#if TCP_OVERSIZE
  /* The new unsent tail has no space */
  pcb->unsent_oversize = 0;
   13828:	e0bffe17 	ldw	r2,-8(fp)
   1382c:	10001b8d 	sth	zero,110(r2)
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
   13830:	e0bfff03 	ldbu	r2,-4(fp)
   13834:	1080008c 	andi	r2,r2,2
   13838:	1000031e 	bne	r2,zero,13848 <tcp_enqueue_flags+0x338>
   1383c:	e0bfff03 	ldbu	r2,-4(fp)
   13840:	1080004c 	andi	r2,r2,1
   13844:	10000b26 	beq	r2,zero,13874 <tcp_enqueue_flags+0x364>
    pcb->snd_lbb++;
   13848:	e0bffe17 	ldw	r2,-8(fp)
   1384c:	10801817 	ldw	r2,96(r2)
   13850:	10c00044 	addi	r3,r2,1
   13854:	e0bffe17 	ldw	r2,-8(fp)
   13858:	10c01815 	stw	r3,96(r2)
    /* optlen does not influence snd_buf */
    pcb->snd_buf--;
   1385c:	e0bffe17 	ldw	r2,-8(fp)
   13860:	10801a8b 	ldhu	r2,106(r2)
   13864:	10bfffc4 	addi	r2,r2,-1
   13868:	1007883a 	mov	r3,r2
   1386c:	e0bffe17 	ldw	r2,-8(fp)
   13870:	10c01a8d 	sth	r3,106(r2)
  }
  if (flags & TCP_FIN) {
   13874:	e0bfff03 	ldbu	r2,-4(fp)
   13878:	1080004c 	andi	r2,r2,1
   1387c:	10000626 	beq	r2,zero,13898 <tcp_enqueue_flags+0x388>
    pcb->flags |= TF_FIN;
   13880:	e0bffe17 	ldw	r2,-8(fp)
   13884:	10800883 	ldbu	r2,34(r2)
   13888:	10800814 	ori	r2,r2,32
   1388c:	1007883a 	mov	r3,r2
   13890:	e0bffe17 	ldw	r2,-8(fp)
   13894:	10c00885 	stb	r3,34(r2)
  }

  /* update number of segments on the queues */
  pcb->snd_queuelen += pbuf_clen(seg->p);
   13898:	e0bffe17 	ldw	r2,-8(fp)
   1389c:	14001b0b 	ldhu	r16,108(r2)
   138a0:	e0bffd17 	ldw	r2,-12(fp)
   138a4:	10800117 	ldw	r2,4(r2)
   138a8:	1009883a 	mov	r4,r2
   138ac:	000ac000 	call	ac00 <pbuf_clen>
   138b0:	10803fcc 	andi	r2,r2,255
   138b4:	8085883a 	add	r2,r16,r2
   138b8:	1007883a 	mov	r3,r2
   138bc:	e0bffe17 	ldw	r2,-8(fp)
   138c0:	10c01b0d 	sth	r3,108(r2)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
   138c4:	e0bffe17 	ldw	r2,-8(fp)
   138c8:	10801b0b 	ldhu	r2,108(r2)
   138cc:	10bfffcc 	andi	r2,r2,65535
   138d0:	10000f26 	beq	r2,zero,13910 <tcp_enqueue_flags+0x400>
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
   138d4:	e0bffe17 	ldw	r2,-8(fp)
   138d8:	10801d17 	ldw	r2,116(r2)
   138dc:	10000c1e 	bne	r2,zero,13910 <tcp_enqueue_flags+0x400>
   138e0:	e0bffe17 	ldw	r2,-8(fp)
   138e4:	10801c17 	ldw	r2,112(r2)
   138e8:	1000091e 	bne	r2,zero,13910 <tcp_enqueue_flags+0x400>
   138ec:	010000f4 	movhi	r4,3
   138f0:	2102c104 	addi	r4,r4,2820
   138f4:	014000f4 	movhi	r5,3
   138f8:	29438c04 	addi	r5,r5,3632
   138fc:	0180cbc4 	movi	r6,815
   13900:	01c000f4 	movhi	r7,3
   13904:	39c2d704 	addi	r7,r7,2908
   13908:	00193f00 	call	193f0 <printf>
   1390c:	003fff06 	br	1390c <tcp_enqueue_flags+0x3fc>
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
   13910:	0005883a 	mov	r2,zero
}
   13914:	e037883a 	mov	sp,fp
   13918:	dfc00217 	ldw	ra,8(sp)
   1391c:	df000117 	ldw	fp,4(sp)
   13920:	dc000017 	ldw	r16,0(sp)
   13924:	dec00304 	addi	sp,sp,12
   13928:	f800283a 	ret

0001392c <tcp_send_empty_ack>:
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
   1392c:	defff804 	addi	sp,sp,-32
   13930:	dfc00715 	stw	ra,28(sp)
   13934:	df000615 	stw	fp,24(sp)
   13938:	df000604 	addi	fp,sp,24
   1393c:	e13fff15 	stw	r4,-4(fp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  u8_t optlen = 0;
   13940:	e03ffc05 	stb	zero,-16(fp)
  if (pcb->flags & TF_TIMESTAMP) {
    optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
  }
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
   13944:	e0fffc03 	ldbu	r3,-16(fp)
   13948:	e0bfff17 	ldw	r2,-4(fp)
   1394c:	10801517 	ldw	r2,84(r2)
   13950:	1008d63a 	srli	r4,r2,24
   13954:	e0bfff17 	ldw	r2,-4(fp)
   13958:	10801517 	ldw	r2,84(r2)
   1395c:	1004d23a 	srli	r2,r2,8
   13960:	10bfc00c 	andi	r2,r2,65280
   13964:	2088b03a 	or	r4,r4,r2
   13968:	e0bfff17 	ldw	r2,-4(fp)
   1396c:	10801517 	ldw	r2,84(r2)
   13970:	10bfc00c 	andi	r2,r2,65280
   13974:	1004923a 	slli	r2,r2,8
   13978:	2088b03a 	or	r4,r4,r2
   1397c:	e0bfff17 	ldw	r2,-4(fp)
   13980:	10801517 	ldw	r2,84(r2)
   13984:	1004963a 	slli	r2,r2,24
   13988:	2084b03a 	or	r2,r4,r2
   1398c:	e13fff17 	ldw	r4,-4(fp)
   13990:	180b883a 	mov	r5,r3
   13994:	000d883a 	mov	r6,zero
   13998:	100f883a 	mov	r7,r2
   1399c:	001234c0 	call	1234c <tcp_output_alloc_header>
   139a0:	e0bffd15 	stw	r2,-12(fp)
  if (p == NULL) {
   139a4:	e0bffd17 	ldw	r2,-12(fp)
   139a8:	1000021e 	bne	r2,zero,139b4 <tcp_send_empty_ack+0x88>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
   139ac:	00bfff84 	movi	r2,-2
   139b0:	00002b06 	br	13a60 <tcp_send_empty_ack+0x134>
  }
  tcphdr = (struct tcp_hdr *)p->payload;
   139b4:	e0bffd17 	ldw	r2,-12(fp)
   139b8:	10800117 	ldw	r2,4(r2)
   139bc:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  /* remove ACK flags from the PCB, as we send an empty ACK now */
  pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
   139c0:	e0bfff17 	ldw	r2,-4(fp)
   139c4:	10c00883 	ldbu	r3,34(r2)
   139c8:	00bfff04 	movi	r2,-4
   139cc:	1884703a 	and	r2,r3,r2
   139d0:	1007883a 	mov	r3,r2
   139d4:	e0bfff17 	ldw	r2,-4(fp)
   139d8:	10c00885 	stb	r3,34(r2)
    tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
  }
#endif 

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
   139dc:	e0ffff17 	ldw	r3,-4(fp)
   139e0:	e0bfff17 	ldw	r2,-4(fp)
   139e4:	10800104 	addi	r2,r2,4
        IP_PROTO_TCP, p->tot_len);
   139e8:	e13ffd17 	ldw	r4,-12(fp)
   139ec:	2100020b 	ldhu	r4,8(r4)
    tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
  }
#endif 

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
   139f0:	213fffcc 	andi	r4,r4,65535
   139f4:	d9000015 	stw	r4,0(sp)
   139f8:	e13ffd17 	ldw	r4,-12(fp)
   139fc:	180b883a 	mov	r5,r3
   13a00:	100d883a 	mov	r6,r2
   13a04:	01c00184 	movi	r7,6
   13a08:	0005cb80 	call	5cb8 <inet_chksum_pseudo>
   13a0c:	e0fffe17 	ldw	r3,-8(fp)
   13a10:	1880040d 	sth	r2,16(r3)
#endif
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
   13a14:	e17fff17 	ldw	r5,-4(fp)
   13a18:	e0bfff17 	ldw	r2,-4(fp)
   13a1c:	10c00104 	addi	r3,r2,4
   13a20:	e0bfff17 	ldw	r2,-4(fp)
   13a24:	10800283 	ldbu	r2,10(r2)
   13a28:	10803fcc 	andi	r2,r2,255
   13a2c:	e13fff17 	ldw	r4,-4(fp)
   13a30:	21000243 	ldbu	r4,9(r4)
   13a34:	21003fcc 	andi	r4,r4,255
   13a38:	d9000015 	stw	r4,0(sp)
   13a3c:	01000184 	movi	r4,6
   13a40:	d9000115 	stw	r4,4(sp)
   13a44:	e13ffd17 	ldw	r4,-12(fp)
   13a48:	180d883a 	mov	r6,r3
   13a4c:	100f883a 	mov	r7,r2
   13a50:	0006cbc0 	call	6cbc <ip_output>
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
  pbuf_free(p);
   13a54:	e13ffd17 	ldw	r4,-12(fp)
   13a58:	000aa340 	call	aa34 <pbuf_free>

  return ERR_OK;
   13a5c:	0005883a 	mov	r2,zero
}
   13a60:	e037883a 	mov	sp,fp
   13a64:	dfc00117 	ldw	ra,4(sp)
   13a68:	df000017 	ldw	fp,0(sp)
   13a6c:	dec00204 	addi	sp,sp,8
   13a70:	f800283a 	ret

00013a74 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
   13a74:	defff804 	addi	sp,sp,-32
   13a78:	dfc00715 	stw	ra,28(sp)
   13a7c:	df000615 	stw	fp,24(sp)
   13a80:	df000604 	addi	fp,sp,24
   13a84:	e13fff15 	stw	r4,-4(fp)
#if TCP_CWND_DEBUG
  s16_t i = 0;
#endif /* TCP_CWND_DEBUG */

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_output for listen-pcbs",
   13a88:	e0bfff17 	ldw	r2,-4(fp)
   13a8c:	10800617 	ldw	r2,24(r2)
   13a90:	10800058 	cmpnei	r2,r2,1
   13a94:	1000091e 	bne	r2,zero,13abc <tcp_output+0x48>
   13a98:	010000f4 	movhi	r4,3
   13a9c:	2102c104 	addi	r4,r4,2820
   13aa0:	014000f4 	movhi	r5,3
   13aa4:	29439604 	addi	r5,r5,3672
   13aa8:	0180e304 	movi	r6,908
   13aac:	01c000f4 	movhi	r7,3
   13ab0:	39c2d704 	addi	r7,r7,2908
   13ab4:	00193f00 	call	193f0 <printf>
   13ab8:	003fff06 	br	13ab8 <tcp_output+0x44>

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
   13abc:	008000f4 	movhi	r2,3
   13ac0:	109e3b04 	addi	r2,r2,30956
   13ac4:	10c00017 	ldw	r3,0(r2)
   13ac8:	e0bfff17 	ldw	r2,-4(fp)
   13acc:	1880021e 	bne	r3,r2,13ad8 <tcp_output+0x64>
    return ERR_OK;
   13ad0:	0005883a 	mov	r2,zero
   13ad4:	0001eb06 	br	14284 <tcp_output+0x810>
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
   13ad8:	e0bfff17 	ldw	r2,-4(fp)
   13adc:	1080140b 	ldhu	r2,80(r2)
   13ae0:	e0ffff17 	ldw	r3,-4(fp)
   13ae4:	18c0190b 	ldhu	r3,100(r3)
   13ae8:	113fffcc 	andi	r4,r2,65535
   13aec:	197fffcc 	andi	r5,r3,65535
   13af0:	2900012e 	bgeu	r5,r4,13af8 <tcp_output+0x84>
   13af4:	1805883a 	mov	r2,r3
   13af8:	10bfffcc 	andi	r2,r2,65535
   13afc:	e0bffd15 	stw	r2,-12(fp)

  seg = pcb->unsent;
   13b00:	e0bfff17 	ldw	r2,-4(fp)
   13b04:	10801c17 	ldw	r2,112(r2)
   13b08:	e0bffa15 	stw	r2,-24(fp)
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
   13b0c:	e0bfff17 	ldw	r2,-4(fp)
   13b10:	10800883 	ldbu	r2,34(r2)
   13b14:	10803fcc 	andi	r2,r2,255
   13b18:	1080008c 	andi	r2,r2,2
   13b1c:	10002f26 	beq	r2,zero,13bdc <tcp_output+0x168>
   13b20:	e0bffa17 	ldw	r2,-24(fp)
   13b24:	10002a26 	beq	r2,zero,13bd0 <tcp_output+0x15c>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
   13b28:	e0bffa17 	ldw	r2,-24(fp)
   13b2c:	10800317 	ldw	r2,12(r2)
   13b30:	10c0010b 	ldhu	r3,4(r2)
   13b34:	1080018b 	ldhu	r2,6(r2)
   13b38:	1004943a 	slli	r2,r2,16
   13b3c:	10c4b03a 	or	r2,r2,r3
   13b40:	1006d63a 	srli	r3,r2,24
   13b44:	e0bffa17 	ldw	r2,-24(fp)
   13b48:	10800317 	ldw	r2,12(r2)
   13b4c:	1100010b 	ldhu	r4,4(r2)
   13b50:	1080018b 	ldhu	r2,6(r2)
   13b54:	1004943a 	slli	r2,r2,16
   13b58:	1104b03a 	or	r2,r2,r4
   13b5c:	1004d23a 	srli	r2,r2,8
   13b60:	10bfc00c 	andi	r2,r2,65280
   13b64:	1886b03a 	or	r3,r3,r2
   13b68:	e0bffa17 	ldw	r2,-24(fp)
   13b6c:	10800317 	ldw	r2,12(r2)
   13b70:	1100010b 	ldhu	r4,4(r2)
   13b74:	1080018b 	ldhu	r2,6(r2)
   13b78:	1004943a 	slli	r2,r2,16
   13b7c:	1104b03a 	or	r2,r2,r4
   13b80:	10bfc00c 	andi	r2,r2,65280
   13b84:	1004923a 	slli	r2,r2,8
   13b88:	1886b03a 	or	r3,r3,r2
   13b8c:	e0bffa17 	ldw	r2,-24(fp)
   13b90:	10800317 	ldw	r2,12(r2)
   13b94:	1100010b 	ldhu	r4,4(r2)
   13b98:	1080018b 	ldhu	r2,6(r2)
   13b9c:	1004943a 	slli	r2,r2,16
   13ba0:	1104b03a 	or	r2,r2,r4
   13ba4:	1004963a 	slli	r2,r2,24
   13ba8:	1886b03a 	or	r3,r3,r2
   13bac:	e0bfff17 	ldw	r2,-4(fp)
   13bb0:	10801317 	ldw	r2,76(r2)
   13bb4:	1887c83a 	sub	r3,r3,r2
   13bb8:	e0bffa17 	ldw	r2,-24(fp)
   13bbc:	1080020b 	ldhu	r2,8(r2)
   13bc0:	10bfffcc 	andi	r2,r2,65535
   13bc4:	1885883a 	add	r2,r3,r2
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
   13bc8:	e0fffd17 	ldw	r3,-12(fp)
   13bcc:	1880032e 	bgeu	r3,r2,13bdc <tcp_output+0x168>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
     return tcp_send_empty_ack(pcb);
   13bd0:	e13fff17 	ldw	r4,-4(fp)
   13bd4:	001392c0 	call	1392c <tcp_send_empty_ack>
   13bd8:	0001aa06 	br	14284 <tcp_output+0x810>
  }

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
   13bdc:	e0bfff17 	ldw	r2,-4(fp)
   13be0:	10801d17 	ldw	r2,116(r2)
   13be4:	e0bffb15 	stw	r2,-20(fp)
  if (useg != NULL) {
   13be8:	e0bffb17 	ldw	r2,-20(fp)
   13bec:	10016b26 	beq	r2,zero,1419c <tcp_output+0x728>
    for (; useg->next != NULL; useg = useg->next);
   13bf0:	00000306 	br	13c00 <tcp_output+0x18c>
   13bf4:	e0bffb17 	ldw	r2,-20(fp)
   13bf8:	10800017 	ldw	r2,0(r2)
   13bfc:	e0bffb15 	stw	r2,-20(fp)
   13c00:	e0bffb17 	ldw	r2,-20(fp)
   13c04:	10800017 	ldw	r2,0(r2)
   13c08:	103ffa1e 	bne	r2,zero,13bf4 <tcp_output+0x180>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
   13c0c:	00016306 	br	1419c <tcp_output+0x728>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
   13c10:	e0bffa17 	ldw	r2,-24(fp)
   13c14:	10800317 	ldw	r2,12(r2)
   13c18:	1080030b 	ldhu	r2,12(r2)
   13c1c:	10bfffcc 	andi	r2,r2,65535
   13c20:	1004d23a 	srli	r2,r2,8
   13c24:	10ffffcc 	andi	r3,r2,65535
   13c28:	e0bffa17 	ldw	r2,-24(fp)
   13c2c:	10800317 	ldw	r2,12(r2)
   13c30:	1080030b 	ldhu	r2,12(r2)
   13c34:	10bfffcc 	andi	r2,r2,65535
   13c38:	1004923a 	slli	r2,r2,8
   13c3c:	10bfffcc 	andi	r2,r2,65535
   13c40:	1884b03a 	or	r2,r3,r2
   13c44:	1080010c 	andi	r2,r2,4
   13c48:	10000926 	beq	r2,zero,13c70 <tcp_output+0x1fc>
   13c4c:	010000f4 	movhi	r4,3
   13c50:	2102c104 	addi	r4,r4,2820
   13c54:	014000f4 	movhi	r5,3
   13c58:	2943a004 	addi	r5,r5,3712
   13c5c:	0180f144 	movi	r6,965
   13c60:	01c000f4 	movhi	r7,3
   13c64:	39c2d704 	addi	r7,r7,2908
   13c68:	00193f00 	call	193f0 <printf>
   13c6c:	003fff06 	br	13c6c <tcp_output+0x1f8>
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
   13c70:	e0bfff17 	ldw	r2,-4(fp)
   13c74:	10801d17 	ldw	r2,116(r2)
   13c78:	10001d26 	beq	r2,zero,13cf0 <tcp_output+0x27c>
   13c7c:	e0bfff17 	ldw	r2,-4(fp)
   13c80:	10800883 	ldbu	r2,34(r2)
   13c84:	10803fcc 	andi	r2,r2,255
   13c88:	1080110c 	andi	r2,r2,68
   13c8c:	1000181e 	bne	r2,zero,13cf0 <tcp_output+0x27c>
   13c90:	e0bfff17 	ldw	r2,-4(fp)
   13c94:	10801c17 	ldw	r2,112(r2)
   13c98:	10000c26 	beq	r2,zero,13ccc <tcp_output+0x258>
   13c9c:	e0bfff17 	ldw	r2,-4(fp)
   13ca0:	10801c17 	ldw	r2,112(r2)
   13ca4:	10800017 	ldw	r2,0(r2)
   13ca8:	1000111e 	bne	r2,zero,13cf0 <tcp_output+0x27c>
   13cac:	e0bfff17 	ldw	r2,-4(fp)
   13cb0:	10801c17 	ldw	r2,112(r2)
   13cb4:	10c0020b 	ldhu	r3,8(r2)
   13cb8:	e0bfff17 	ldw	r2,-4(fp)
   13cbc:	10800e8b 	ldhu	r2,58(r2)
   13cc0:	18ffffcc 	andi	r3,r3,65535
   13cc4:	10bfffcc 	andi	r2,r2,65535
   13cc8:	1880092e 	bgeu	r3,r2,13cf0 <tcp_output+0x27c>
   13ccc:	e0bfff17 	ldw	r2,-4(fp)
   13cd0:	10801a8b 	ldhu	r2,106(r2)
   13cd4:	10bfffcc 	andi	r2,r2,65535
   13cd8:	10000526 	beq	r2,zero,13cf0 <tcp_output+0x27c>
   13cdc:	e0bfff17 	ldw	r2,-4(fp)
   13ce0:	10801b0b 	ldhu	r2,108(r2)
   13ce4:	10bfffcc 	andi	r2,r2,65535
   13ce8:	10800b30 	cmpltui	r2,r2,44
   13cec:	1000021e 	bne	r2,zero,13cf8 <tcp_output+0x284>
   13cf0:	00800044 	movi	r2,1
   13cf4:	00000106 	br	13cfc <tcp_output+0x288>
   13cf8:	0005883a 	mov	r2,zero
   13cfc:	1000051e 	bne	r2,zero,13d14 <tcp_output+0x2a0>
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
   13d00:	e0bfff17 	ldw	r2,-4(fp)
   13d04:	10800883 	ldbu	r2,34(r2)
   13d08:	10803fcc 	andi	r2,r2,255
   13d0c:	1080280c 	andi	r2,r2,160
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
   13d10:	10014f26 	beq	r2,zero,14250 <tcp_output+0x7dc>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
   13d14:	e0bffa17 	ldw	r2,-24(fp)
   13d18:	10c00017 	ldw	r3,0(r2)
   13d1c:	e0bfff17 	ldw	r2,-4(fp)
   13d20:	10c01c15 	stw	r3,112(r2)

    if (pcb->state != SYN_SENT) {
   13d24:	e0bfff17 	ldw	r2,-4(fp)
   13d28:	10800617 	ldw	r2,24(r2)
   13d2c:	108000a0 	cmpeqi	r2,r2,2
   13d30:	10000e1e 	bne	r2,zero,13d6c <tcp_output+0x2f8>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
   13d34:	e0bffa17 	ldw	r2,-24(fp)
   13d38:	10800317 	ldw	r2,12(r2)
   13d3c:	e0fffa17 	ldw	r3,-24(fp)
   13d40:	18c00317 	ldw	r3,12(r3)
   13d44:	18c0030b 	ldhu	r3,12(r3)
   13d48:	18c40014 	ori	r3,r3,4096
   13d4c:	10c0030d 	sth	r3,12(r2)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
   13d50:	e0bfff17 	ldw	r2,-4(fp)
   13d54:	10c00883 	ldbu	r3,34(r2)
   13d58:	00bfff04 	movi	r2,-4
   13d5c:	1884703a 	and	r2,r3,r2
   13d60:	1007883a 	mov	r3,r2
   13d64:	e0bfff17 	ldw	r2,-4(fp)
   13d68:	10c00885 	stb	r3,34(r2)
    }

    tcp_output_segment(seg, pcb);
   13d6c:	e13ffa17 	ldw	r4,-24(fp)
   13d70:	e17fff17 	ldw	r5,-4(fp)
   13d74:	00142980 	call	14298 <tcp_output_segment>
    snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
   13d78:	e0bffa17 	ldw	r2,-24(fp)
   13d7c:	10800317 	ldw	r2,12(r2)
   13d80:	10c0010b 	ldhu	r3,4(r2)
   13d84:	1080018b 	ldhu	r2,6(r2)
   13d88:	1004943a 	slli	r2,r2,16
   13d8c:	10c4b03a 	or	r2,r2,r3
   13d90:	1006d63a 	srli	r3,r2,24
   13d94:	e0bffa17 	ldw	r2,-24(fp)
   13d98:	10800317 	ldw	r2,12(r2)
   13d9c:	1100010b 	ldhu	r4,4(r2)
   13da0:	1080018b 	ldhu	r2,6(r2)
   13da4:	1004943a 	slli	r2,r2,16
   13da8:	1104b03a 	or	r2,r2,r4
   13dac:	1004d23a 	srli	r2,r2,8
   13db0:	10bfc00c 	andi	r2,r2,65280
   13db4:	1886b03a 	or	r3,r3,r2
   13db8:	e0bffa17 	ldw	r2,-24(fp)
   13dbc:	10800317 	ldw	r2,12(r2)
   13dc0:	1100010b 	ldhu	r4,4(r2)
   13dc4:	1080018b 	ldhu	r2,6(r2)
   13dc8:	1004943a 	slli	r2,r2,16
   13dcc:	1104b03a 	or	r2,r2,r4
   13dd0:	10bfc00c 	andi	r2,r2,65280
   13dd4:	1004923a 	slli	r2,r2,8
   13dd8:	1886b03a 	or	r3,r3,r2
   13ddc:	e0bffa17 	ldw	r2,-24(fp)
   13de0:	10800317 	ldw	r2,12(r2)
   13de4:	1100010b 	ldhu	r4,4(r2)
   13de8:	1080018b 	ldhu	r2,6(r2)
   13dec:	1004943a 	slli	r2,r2,16
   13df0:	1104b03a 	or	r2,r2,r4
   13df4:	1004963a 	slli	r2,r2,24
   13df8:	1886b03a 	or	r3,r3,r2
   13dfc:	e0bffa17 	ldw	r2,-24(fp)
   13e00:	1080020b 	ldhu	r2,8(r2)
   13e04:	113fffcc 	andi	r4,r2,65535
   13e08:	e0bffa17 	ldw	r2,-24(fp)
   13e0c:	10800317 	ldw	r2,12(r2)
   13e10:	1080030b 	ldhu	r2,12(r2)
   13e14:	10bfffcc 	andi	r2,r2,65535
   13e18:	1004d23a 	srli	r2,r2,8
   13e1c:	117fffcc 	andi	r5,r2,65535
   13e20:	e0bffa17 	ldw	r2,-24(fp)
   13e24:	10800317 	ldw	r2,12(r2)
   13e28:	1080030b 	ldhu	r2,12(r2)
   13e2c:	10bfffcc 	andi	r2,r2,65535
   13e30:	1004923a 	slli	r2,r2,8
   13e34:	10bfffcc 	andi	r2,r2,65535
   13e38:	2884b03a 	or	r2,r5,r2
   13e3c:	108000cc 	andi	r2,r2,3
   13e40:	1004c03a 	cmpne	r2,r2,zero
   13e44:	10803fcc 	andi	r2,r2,255
   13e48:	2085883a 	add	r2,r4,r2
   13e4c:	1885883a 	add	r2,r3,r2
   13e50:	e0bffe15 	stw	r2,-8(fp)
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
   13e54:	e0bfff17 	ldw	r2,-4(fp)
   13e58:	10c01517 	ldw	r3,84(r2)
   13e5c:	e0bffe17 	ldw	r2,-8(fp)
   13e60:	1885c83a 	sub	r2,r3,r2
   13e64:	1000030e 	bge	r2,zero,13e74 <tcp_output+0x400>
      pcb->snd_nxt = snd_nxt;
   13e68:	e0bfff17 	ldw	r2,-4(fp)
   13e6c:	e0fffe17 	ldw	r3,-8(fp)
   13e70:	10c01515 	stw	r3,84(r2)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
   13e74:	e0bffa17 	ldw	r2,-24(fp)
   13e78:	1080020b 	ldhu	r2,8(r2)
   13e7c:	10ffffcc 	andi	r3,r2,65535
   13e80:	e0bffa17 	ldw	r2,-24(fp)
   13e84:	10800317 	ldw	r2,12(r2)
   13e88:	1080030b 	ldhu	r2,12(r2)
   13e8c:	10bfffcc 	andi	r2,r2,65535
   13e90:	1004d23a 	srli	r2,r2,8
   13e94:	113fffcc 	andi	r4,r2,65535
   13e98:	e0bffa17 	ldw	r2,-24(fp)
   13e9c:	10800317 	ldw	r2,12(r2)
   13ea0:	1080030b 	ldhu	r2,12(r2)
   13ea4:	10bfffcc 	andi	r2,r2,65535
   13ea8:	1004923a 	slli	r2,r2,8
   13eac:	10bfffcc 	andi	r2,r2,65535
   13eb0:	2084b03a 	or	r2,r4,r2
   13eb4:	108000cc 	andi	r2,r2,3
   13eb8:	1004c03a 	cmpne	r2,r2,zero
   13ebc:	10803fcc 	andi	r2,r2,255
   13ec0:	1885883a 	add	r2,r3,r2
   13ec4:	0080b00e 	bge	zero,r2,14188 <tcp_output+0x714>
      seg->next = NULL;
   13ec8:	e0bffa17 	ldw	r2,-24(fp)
   13ecc:	10000015 	stw	zero,0(r2)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
   13ed0:	e0bfff17 	ldw	r2,-4(fp)
   13ed4:	10801d17 	ldw	r2,116(r2)
   13ed8:	1000061e 	bne	r2,zero,13ef4 <tcp_output+0x480>
        pcb->unacked = seg;
   13edc:	e0bfff17 	ldw	r2,-4(fp)
   13ee0:	e0fffa17 	ldw	r3,-24(fp)
   13ee4:	10c01d15 	stw	r3,116(r2)
        useg = seg;
   13ee8:	e0bffa17 	ldw	r2,-24(fp)
   13eec:	e0bffb15 	stw	r2,-20(fp)
   13ef0:	0000a706 	br	14190 <tcp_output+0x71c>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
   13ef4:	e0bffa17 	ldw	r2,-24(fp)
   13ef8:	10800317 	ldw	r2,12(r2)
   13efc:	10c0010b 	ldhu	r3,4(r2)
   13f00:	1080018b 	ldhu	r2,6(r2)
   13f04:	1004943a 	slli	r2,r2,16
   13f08:	10c4b03a 	or	r2,r2,r3
   13f0c:	1006d63a 	srli	r3,r2,24
   13f10:	e0bffa17 	ldw	r2,-24(fp)
   13f14:	10800317 	ldw	r2,12(r2)
   13f18:	1100010b 	ldhu	r4,4(r2)
   13f1c:	1080018b 	ldhu	r2,6(r2)
   13f20:	1004943a 	slli	r2,r2,16
   13f24:	1104b03a 	or	r2,r2,r4
   13f28:	1004d23a 	srli	r2,r2,8
   13f2c:	10bfc00c 	andi	r2,r2,65280
   13f30:	1886b03a 	or	r3,r3,r2
   13f34:	e0bffa17 	ldw	r2,-24(fp)
   13f38:	10800317 	ldw	r2,12(r2)
   13f3c:	1100010b 	ldhu	r4,4(r2)
   13f40:	1080018b 	ldhu	r2,6(r2)
   13f44:	1004943a 	slli	r2,r2,16
   13f48:	1104b03a 	or	r2,r2,r4
   13f4c:	10bfc00c 	andi	r2,r2,65280
   13f50:	1004923a 	slli	r2,r2,8
   13f54:	1886b03a 	or	r3,r3,r2
   13f58:	e0bffa17 	ldw	r2,-24(fp)
   13f5c:	10800317 	ldw	r2,12(r2)
   13f60:	1100010b 	ldhu	r4,4(r2)
   13f64:	1080018b 	ldhu	r2,6(r2)
   13f68:	1004943a 	slli	r2,r2,16
   13f6c:	1104b03a 	or	r2,r2,r4
   13f70:	1004963a 	slli	r2,r2,24
   13f74:	1886b03a 	or	r3,r3,r2
   13f78:	e0bffb17 	ldw	r2,-20(fp)
   13f7c:	10800317 	ldw	r2,12(r2)
   13f80:	1100010b 	ldhu	r4,4(r2)
   13f84:	1080018b 	ldhu	r2,6(r2)
   13f88:	1004943a 	slli	r2,r2,16
   13f8c:	1104b03a 	or	r2,r2,r4
   13f90:	1008d63a 	srli	r4,r2,24
   13f94:	e0bffb17 	ldw	r2,-20(fp)
   13f98:	10800317 	ldw	r2,12(r2)
   13f9c:	1140010b 	ldhu	r5,4(r2)
   13fa0:	1080018b 	ldhu	r2,6(r2)
   13fa4:	1004943a 	slli	r2,r2,16
   13fa8:	1144b03a 	or	r2,r2,r5
   13fac:	1004d23a 	srli	r2,r2,8
   13fb0:	10bfc00c 	andi	r2,r2,65280
   13fb4:	2088b03a 	or	r4,r4,r2
   13fb8:	e0bffb17 	ldw	r2,-20(fp)
   13fbc:	10800317 	ldw	r2,12(r2)
   13fc0:	1140010b 	ldhu	r5,4(r2)
   13fc4:	1080018b 	ldhu	r2,6(r2)
   13fc8:	1004943a 	slli	r2,r2,16
   13fcc:	1144b03a 	or	r2,r2,r5
   13fd0:	10bfc00c 	andi	r2,r2,65280
   13fd4:	1004923a 	slli	r2,r2,8
   13fd8:	2088b03a 	or	r4,r4,r2
   13fdc:	e0bffb17 	ldw	r2,-20(fp)
   13fe0:	10800317 	ldw	r2,12(r2)
   13fe4:	1140010b 	ldhu	r5,4(r2)
   13fe8:	1080018b 	ldhu	r2,6(r2)
   13fec:	1004943a 	slli	r2,r2,16
   13ff0:	1144b03a 	or	r2,r2,r5
   13ff4:	1004963a 	slli	r2,r2,24
   13ff8:	2084b03a 	or	r2,r4,r2
   13ffc:	1885c83a 	sub	r2,r3,r2
   14000:	10005a0e 	bge	r2,zero,1416c <tcp_output+0x6f8>
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
   14004:	e0bfff17 	ldw	r2,-4(fp)
   14008:	10801d04 	addi	r2,r2,116
   1400c:	e0bffc15 	stw	r2,-16(fp)
          while (*cur_seg &&
   14010:	00000306 	br	14020 <tcp_output+0x5ac>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
              cur_seg = &((*cur_seg)->next );
   14014:	e0bffc17 	ldw	r2,-16(fp)
   14018:	10800017 	ldw	r2,0(r2)
   1401c:	e0bffc15 	stw	r2,-16(fp)
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
   14020:	e0bffc17 	ldw	r2,-16(fp)
   14024:	10800017 	ldw	r2,0(r2)
   14028:	10004826 	beq	r2,zero,1414c <tcp_output+0x6d8>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
   1402c:	e0bffc17 	ldw	r2,-16(fp)
   14030:	10800017 	ldw	r2,0(r2)
   14034:	10800317 	ldw	r2,12(r2)
   14038:	10c0010b 	ldhu	r3,4(r2)
   1403c:	1080018b 	ldhu	r2,6(r2)
   14040:	1004943a 	slli	r2,r2,16
   14044:	10c4b03a 	or	r2,r2,r3
   14048:	1006d63a 	srli	r3,r2,24
   1404c:	e0bffc17 	ldw	r2,-16(fp)
   14050:	10800017 	ldw	r2,0(r2)
   14054:	10800317 	ldw	r2,12(r2)
   14058:	1100010b 	ldhu	r4,4(r2)
   1405c:	1080018b 	ldhu	r2,6(r2)
   14060:	1004943a 	slli	r2,r2,16
   14064:	1104b03a 	or	r2,r2,r4
   14068:	1004d23a 	srli	r2,r2,8
   1406c:	10bfc00c 	andi	r2,r2,65280
   14070:	1886b03a 	or	r3,r3,r2
   14074:	e0bffc17 	ldw	r2,-16(fp)
   14078:	10800017 	ldw	r2,0(r2)
   1407c:	10800317 	ldw	r2,12(r2)
   14080:	1100010b 	ldhu	r4,4(r2)
   14084:	1080018b 	ldhu	r2,6(r2)
   14088:	1004943a 	slli	r2,r2,16
   1408c:	1104b03a 	or	r2,r2,r4
   14090:	10bfc00c 	andi	r2,r2,65280
   14094:	1004923a 	slli	r2,r2,8
   14098:	1886b03a 	or	r3,r3,r2
   1409c:	e0bffc17 	ldw	r2,-16(fp)
   140a0:	10800017 	ldw	r2,0(r2)
   140a4:	10800317 	ldw	r2,12(r2)
   140a8:	1100010b 	ldhu	r4,4(r2)
   140ac:	1080018b 	ldhu	r2,6(r2)
   140b0:	1004943a 	slli	r2,r2,16
   140b4:	1104b03a 	or	r2,r2,r4
   140b8:	1004963a 	slli	r2,r2,24
   140bc:	1886b03a 	or	r3,r3,r2
   140c0:	e0bffa17 	ldw	r2,-24(fp)
   140c4:	10800317 	ldw	r2,12(r2)
   140c8:	1100010b 	ldhu	r4,4(r2)
   140cc:	1080018b 	ldhu	r2,6(r2)
   140d0:	1004943a 	slli	r2,r2,16
   140d4:	1104b03a 	or	r2,r2,r4
   140d8:	1008d63a 	srli	r4,r2,24
   140dc:	e0bffa17 	ldw	r2,-24(fp)
   140e0:	10800317 	ldw	r2,12(r2)
   140e4:	1140010b 	ldhu	r5,4(r2)
   140e8:	1080018b 	ldhu	r2,6(r2)
   140ec:	1004943a 	slli	r2,r2,16
   140f0:	1144b03a 	or	r2,r2,r5
   140f4:	1004d23a 	srli	r2,r2,8
   140f8:	10bfc00c 	andi	r2,r2,65280
   140fc:	2088b03a 	or	r4,r4,r2
   14100:	e0bffa17 	ldw	r2,-24(fp)
   14104:	10800317 	ldw	r2,12(r2)
   14108:	1140010b 	ldhu	r5,4(r2)
   1410c:	1080018b 	ldhu	r2,6(r2)
   14110:	1004943a 	slli	r2,r2,16
   14114:	1144b03a 	or	r2,r2,r5
   14118:	10bfc00c 	andi	r2,r2,65280
   1411c:	1004923a 	slli	r2,r2,8
   14120:	2088b03a 	or	r4,r4,r2
   14124:	e0bffa17 	ldw	r2,-24(fp)
   14128:	10800317 	ldw	r2,12(r2)
   1412c:	1140010b 	ldhu	r5,4(r2)
   14130:	1080018b 	ldhu	r2,6(r2)
   14134:	1004943a 	slli	r2,r2,16
   14138:	1144b03a 	or	r2,r2,r5
   1413c:	1004963a 	slli	r2,r2,24
   14140:	2084b03a 	or	r2,r4,r2
   14144:	1885c83a 	sub	r2,r3,r2
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
   14148:	103fb216 	blt	r2,zero,14014 <tcp_output+0x5a0>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
              cur_seg = &((*cur_seg)->next );
          }
          seg->next = (*cur_seg);
   1414c:	e0bffc17 	ldw	r2,-16(fp)
   14150:	10c00017 	ldw	r3,0(r2)
   14154:	e0bffa17 	ldw	r2,-24(fp)
   14158:	10c00015 	stw	r3,0(r2)
          (*cur_seg) = seg;
   1415c:	e0bffc17 	ldw	r2,-16(fp)
   14160:	e0fffa17 	ldw	r3,-24(fp)
   14164:	10c00015 	stw	r3,0(r2)
   14168:	00000906 	br	14190 <tcp_output+0x71c>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
   1416c:	e0bffb17 	ldw	r2,-20(fp)
   14170:	e0fffa17 	ldw	r3,-24(fp)
   14174:	10c00015 	stw	r3,0(r2)
          useg = useg->next;
   14178:	e0bffb17 	ldw	r2,-20(fp)
   1417c:	10800017 	ldw	r2,0(r2)
   14180:	e0bffb15 	stw	r2,-20(fp)
   14184:	00000206 	br	14190 <tcp_output+0x71c>
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
   14188:	e13ffa17 	ldw	r4,-24(fp)
   1418c:	000da080 	call	da08 <tcp_seg_free>
    }
    seg = pcb->unsent;
   14190:	e0bfff17 	ldw	r2,-4(fp)
   14194:	10801c17 	ldw	r2,112(r2)
   14198:	e0bffa15 	stw	r2,-24(fp)
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
   1419c:	e0bffa17 	ldw	r2,-24(fp)
   141a0:	10002c26 	beq	r2,zero,14254 <tcp_output+0x7e0>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
   141a4:	e0bffa17 	ldw	r2,-24(fp)
   141a8:	10800317 	ldw	r2,12(r2)
   141ac:	10c0010b 	ldhu	r3,4(r2)
   141b0:	1080018b 	ldhu	r2,6(r2)
   141b4:	1004943a 	slli	r2,r2,16
   141b8:	10c4b03a 	or	r2,r2,r3
   141bc:	1006d63a 	srli	r3,r2,24
   141c0:	e0bffa17 	ldw	r2,-24(fp)
   141c4:	10800317 	ldw	r2,12(r2)
   141c8:	1100010b 	ldhu	r4,4(r2)
   141cc:	1080018b 	ldhu	r2,6(r2)
   141d0:	1004943a 	slli	r2,r2,16
   141d4:	1104b03a 	or	r2,r2,r4
   141d8:	1004d23a 	srli	r2,r2,8
   141dc:	10bfc00c 	andi	r2,r2,65280
   141e0:	1886b03a 	or	r3,r3,r2
   141e4:	e0bffa17 	ldw	r2,-24(fp)
   141e8:	10800317 	ldw	r2,12(r2)
   141ec:	1100010b 	ldhu	r4,4(r2)
   141f0:	1080018b 	ldhu	r2,6(r2)
   141f4:	1004943a 	slli	r2,r2,16
   141f8:	1104b03a 	or	r2,r2,r4
   141fc:	10bfc00c 	andi	r2,r2,65280
   14200:	1004923a 	slli	r2,r2,8
   14204:	1886b03a 	or	r3,r3,r2
   14208:	e0bffa17 	ldw	r2,-24(fp)
   1420c:	10800317 	ldw	r2,12(r2)
   14210:	1100010b 	ldhu	r4,4(r2)
   14214:	1080018b 	ldhu	r2,6(r2)
   14218:	1004943a 	slli	r2,r2,16
   1421c:	1104b03a 	or	r2,r2,r4
   14220:	1004963a 	slli	r2,r2,24
   14224:	1886b03a 	or	r3,r3,r2
   14228:	e0bfff17 	ldw	r2,-4(fp)
   1422c:	10801317 	ldw	r2,76(r2)
   14230:	1887c83a 	sub	r3,r3,r2
   14234:	e0bffa17 	ldw	r2,-24(fp)
   14238:	1080020b 	ldhu	r2,8(r2)
   1423c:	10bfffcc 	andi	r2,r2,65535
   14240:	1885883a 	add	r2,r3,r2
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
   14244:	e0fffd17 	ldw	r3,-12(fp)
   14248:	18be712e 	bgeu	r3,r2,13c10 <tcp_output+0x19c>
   1424c:	00000106 	br	14254 <tcp_output+0x7e0>
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
      break;
   14250:	0001883a 	nop
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }
#if TCP_OVERSIZE
  if (pcb->unsent == NULL) {
   14254:	e0bfff17 	ldw	r2,-4(fp)
   14258:	10801c17 	ldw	r2,112(r2)
   1425c:	1000021e 	bne	r2,zero,14268 <tcp_output+0x7f4>
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
   14260:	e0bfff17 	ldw	r2,-4(fp)
   14264:	10001b8d 	sth	zero,110(r2)
  }
#endif /* TCP_OVERSIZE */

  pcb->flags &= ~TF_NAGLEMEMERR;
   14268:	e0bfff17 	ldw	r2,-4(fp)
   1426c:	10800883 	ldbu	r2,34(r2)
   14270:	10801fcc 	andi	r2,r2,127
   14274:	1007883a 	mov	r3,r2
   14278:	e0bfff17 	ldw	r2,-4(fp)
   1427c:	10c00885 	stb	r3,34(r2)
  return ERR_OK;
   14280:	0005883a 	mov	r2,zero
}
   14284:	e037883a 	mov	sp,fp
   14288:	dfc00117 	ldw	ra,4(sp)
   1428c:	df000017 	ldw	fp,0(sp)
   14290:	dec00204 	addi	sp,sp,8
   14294:	f800283a 	ret

00014298 <tcp_output_segment>:
 * @param seg the tcp_seg to send
 * @param pcb the tcp_pcb for the TCP connection used to send the segment
 */
static void
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
{
   14298:	defff504 	addi	sp,sp,-44
   1429c:	dfc00a15 	stw	ra,40(sp)
   142a0:	df000915 	stw	fp,36(sp)
   142a4:	dc000815 	stw	r16,32(sp)
   142a8:	df000804 	addi	fp,sp,32
   142ac:	e13ffe15 	stw	r4,-8(fp)
   142b0:	e17fff15 	stw	r5,-4(fp)
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
   142b4:	e0bffe17 	ldw	r2,-8(fp)
   142b8:	10800317 	ldw	r2,12(r2)
   142bc:	e0ffff17 	ldw	r3,-4(fp)
   142c0:	18c00b17 	ldw	r3,44(r3)
   142c4:	1808d63a 	srli	r4,r3,24
   142c8:	e0ffff17 	ldw	r3,-4(fp)
   142cc:	18c00b17 	ldw	r3,44(r3)
   142d0:	1806d23a 	srli	r3,r3,8
   142d4:	18ffc00c 	andi	r3,r3,65280
   142d8:	20c8b03a 	or	r4,r4,r3
   142dc:	e0ffff17 	ldw	r3,-4(fp)
   142e0:	18c00b17 	ldw	r3,44(r3)
   142e4:	18ffc00c 	andi	r3,r3,65280
   142e8:	1806923a 	slli	r3,r3,8
   142ec:	20c8b03a 	or	r4,r4,r3
   142f0:	e0ffff17 	ldw	r3,-4(fp)
   142f4:	18c00b17 	ldw	r3,44(r3)
   142f8:	1806963a 	slli	r3,r3,24
   142fc:	20c6b03a 	or	r3,r4,r3
   14300:	193fffcc 	andi	r4,r3,65535
   14304:	1140020b 	ldhu	r5,8(r2)
   14308:	280a703a 	and	r5,r5,zero
   1430c:	2908b03a 	or	r4,r5,r4
   14310:	1100020d 	sth	r4,8(r2)
   14314:	1806d43a 	srli	r3,r3,16
   14318:	1100028b 	ldhu	r4,10(r2)
   1431c:	2008703a 	and	r4,r4,zero
   14320:	20c6b03a 	or	r3,r4,r3
   14324:	10c0028d 	sth	r3,10(r2)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
   14328:	e0bffe17 	ldw	r2,-8(fp)
   1432c:	10800317 	ldw	r2,12(r2)
   14330:	e0ffff17 	ldw	r3,-4(fp)
   14334:	18c00c8b 	ldhu	r3,50(r3)
   14338:	18ffffcc 	andi	r3,r3,65535
   1433c:	1806d23a 	srli	r3,r3,8
   14340:	1809883a 	mov	r4,r3
   14344:	e0ffff17 	ldw	r3,-4(fp)
   14348:	18c00c8b 	ldhu	r3,50(r3)
   1434c:	18ffffcc 	andi	r3,r3,65535
   14350:	1806923a 	slli	r3,r3,8
   14354:	20c6b03a 	or	r3,r4,r3
   14358:	10c0038d 	sth	r3,14(r2)

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
   1435c:	e0bfff17 	ldw	r2,-4(fp)
   14360:	10c00b17 	ldw	r3,44(r2)
   14364:	e0bfff17 	ldw	r2,-4(fp)
   14368:	10800c8b 	ldhu	r2,50(r2)
   1436c:	10bfffcc 	andi	r2,r2,65535
   14370:	1887883a 	add	r3,r3,r2
   14374:	e0bfff17 	ldw	r2,-4(fp)
   14378:	10c00d15 	stw	r3,52(r2)

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
   1437c:	e0bffe17 	ldw	r2,-8(fp)
   14380:	10800317 	ldw	r2,12(r2)
   14384:	10800504 	addi	r2,r2,20
   14388:	e0bffa15 	stw	r2,-24(fp)
  if (seg->flags & TF_SEG_OPTS_MSS) {
   1438c:	e0bffe17 	ldw	r2,-8(fp)
   14390:	10800283 	ldbu	r2,10(r2)
   14394:	10803fcc 	andi	r2,r2,255
   14398:	1080004c 	andi	r2,r2,1
   1439c:	10001c26 	beq	r2,zero,14410 <tcp_output_segment+0x178>
    u16_t mss;
#if TCP_CALCULATE_EFF_SEND_MSS
    mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
   143a0:	e0bfff17 	ldw	r2,-4(fp)
   143a4:	10800104 	addi	r2,r2,4
   143a8:	01016d04 	movi	r4,1460
   143ac:	100b883a 	mov	r5,r2
   143b0:	000e3cc0 	call	e3cc <tcp_eff_send_mss>
   143b4:	e0bffb0d 	sth	r2,-20(fp)
#else /* TCP_CALCULATE_EFF_SEND_MSS */
    mss = TCP_MSS;
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
    *opts = TCP_BUILD_MSS_OPTION(mss);
   143b8:	e0bffb0b 	ldhu	r2,-20(fp)
   143bc:	10808134 	orhi	r2,r2,516
   143c0:	1004d63a 	srli	r2,r2,24
   143c4:	1007883a 	mov	r3,r2
   143c8:	e0bffb0b 	ldhu	r2,-20(fp)
   143cc:	10808134 	orhi	r2,r2,516
   143d0:	1005d23a 	srai	r2,r2,8
   143d4:	10bfc00c 	andi	r2,r2,65280
   143d8:	1886b03a 	or	r3,r3,r2
   143dc:	e0bffb0b 	ldhu	r2,-20(fp)
   143e0:	10bfc00c 	andi	r2,r2,65280
   143e4:	1004923a 	slli	r2,r2,8
   143e8:	1886b03a 	or	r3,r3,r2
   143ec:	e0bffb0b 	ldhu	r2,-20(fp)
   143f0:	1004963a 	slli	r2,r2,24
   143f4:	1884b03a 	or	r2,r3,r2
   143f8:	1007883a 	mov	r3,r2
   143fc:	e0bffa17 	ldw	r2,-24(fp)
   14400:	10c00015 	stw	r3,0(r2)
    opts += 1;
   14404:	e0bffa17 	ldw	r2,-24(fp)
   14408:	10800104 	addi	r2,r2,4
   1440c:	e0bffa15 	stw	r2,-24(fp)
  }
#endif

  /* Set retransmission timer running if it is not currently enabled 
     This must be set before checking the route. */
  if (pcb->rtime == -1) {
   14410:	e0bfff17 	ldw	r2,-4(fp)
   14414:	10800e0b 	ldhu	r2,56(r2)
   14418:	10bfffcc 	andi	r2,r2,65535
   1441c:	10a0001c 	xori	r2,r2,32768
   14420:	10a00004 	addi	r2,r2,-32768
   14424:	10bfffd8 	cmpnei	r2,r2,-1
   14428:	1000021e 	bne	r2,zero,14434 <tcp_output_segment+0x19c>
    pcb->rtime = 0;
   1442c:	e0bfff17 	ldw	r2,-4(fp)
   14430:	10000e0d 	sth	zero,56(r2)
  }

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
   14434:	e0bfff17 	ldw	r2,-4(fp)
   14438:	10000326 	beq	r2,zero,14448 <tcp_output_segment+0x1b0>
   1443c:	e0bfff17 	ldw	r2,-4(fp)
   14440:	10800017 	ldw	r2,0(r2)
   14444:	10000b1e 	bne	r2,zero,14474 <tcp_output_segment+0x1dc>
    netif = ip_route(&(pcb->remote_ip));
   14448:	e0bfff17 	ldw	r2,-4(fp)
   1444c:	10800104 	addi	r2,r2,4
   14450:	1009883a 	mov	r4,r2
   14454:	00062600 	call	6260 <ip_route>
   14458:	e0bffc15 	stw	r2,-16(fp)
    if (netif == NULL) {
   1445c:	e0bffc17 	ldw	r2,-16(fp)
   14460:	10007a26 	beq	r2,zero,1464c <tcp_output_segment+0x3b4>
      return;
    }
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
   14464:	e0bffc17 	ldw	r2,-16(fp)
   14468:	10c00117 	ldw	r3,4(r2)
   1446c:	e0bfff17 	ldw	r2,-4(fp)
   14470:	10c00015 	stw	r3,0(r2)
  }

  if (pcb->rttest == 0) {
   14474:	e0bfff17 	ldw	r2,-4(fp)
   14478:	10800f17 	ldw	r2,60(r2)
   1447c:	1000281e 	bne	r2,zero,14520 <tcp_output_segment+0x288>
    pcb->rttest = tcp_ticks;
   14480:	008000f4 	movhi	r2,3
   14484:	109e2f04 	addi	r2,r2,30908
   14488:	10c00017 	ldw	r3,0(r2)
   1448c:	e0bfff17 	ldw	r2,-4(fp)
   14490:	10c00f15 	stw	r3,60(r2)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
   14494:	e0bffe17 	ldw	r2,-8(fp)
   14498:	10800317 	ldw	r2,12(r2)
   1449c:	10c0010b 	ldhu	r3,4(r2)
   144a0:	1080018b 	ldhu	r2,6(r2)
   144a4:	1004943a 	slli	r2,r2,16
   144a8:	10c4b03a 	or	r2,r2,r3
   144ac:	1006d63a 	srli	r3,r2,24
   144b0:	e0bffe17 	ldw	r2,-8(fp)
   144b4:	10800317 	ldw	r2,12(r2)
   144b8:	1100010b 	ldhu	r4,4(r2)
   144bc:	1080018b 	ldhu	r2,6(r2)
   144c0:	1004943a 	slli	r2,r2,16
   144c4:	1104b03a 	or	r2,r2,r4
   144c8:	1004d23a 	srli	r2,r2,8
   144cc:	10bfc00c 	andi	r2,r2,65280
   144d0:	1886b03a 	or	r3,r3,r2
   144d4:	e0bffe17 	ldw	r2,-8(fp)
   144d8:	10800317 	ldw	r2,12(r2)
   144dc:	1100010b 	ldhu	r4,4(r2)
   144e0:	1080018b 	ldhu	r2,6(r2)
   144e4:	1004943a 	slli	r2,r2,16
   144e8:	1104b03a 	or	r2,r2,r4
   144ec:	10bfc00c 	andi	r2,r2,65280
   144f0:	1004923a 	slli	r2,r2,8
   144f4:	1886b03a 	or	r3,r3,r2
   144f8:	e0bffe17 	ldw	r2,-8(fp)
   144fc:	10800317 	ldw	r2,12(r2)
   14500:	1100010b 	ldhu	r4,4(r2)
   14504:	1080018b 	ldhu	r2,6(r2)
   14508:	1004943a 	slli	r2,r2,16
   1450c:	1104b03a 	or	r2,r2,r4
   14510:	1004963a 	slli	r2,r2,24
   14514:	1886b03a 	or	r3,r3,r2
   14518:	e0bfff17 	ldw	r2,-4(fp)
   1451c:	10c01015 	stw	r3,64(r2)
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
   14520:	e0bffe17 	ldw	r2,-8(fp)
   14524:	10800317 	ldw	r2,12(r2)
   14528:	1007883a 	mov	r3,r2
   1452c:	e0bffe17 	ldw	r2,-8(fp)
   14530:	10800117 	ldw	r2,4(r2)
   14534:	10800117 	ldw	r2,4(r2)
   14538:	1885c83a 	sub	r2,r3,r2
   1453c:	e0bffd0d 	sth	r2,-12(fp)

  seg->p->len -= len;
   14540:	e0bffe17 	ldw	r2,-8(fp)
   14544:	10800117 	ldw	r2,4(r2)
   14548:	e0fffe17 	ldw	r3,-8(fp)
   1454c:	18c00117 	ldw	r3,4(r3)
   14550:	1900028b 	ldhu	r4,10(r3)
   14554:	e0fffd0b 	ldhu	r3,-12(fp)
   14558:	20c7c83a 	sub	r3,r4,r3
   1455c:	10c0028d 	sth	r3,10(r2)
  seg->p->tot_len -= len;
   14560:	e0bffe17 	ldw	r2,-8(fp)
   14564:	10800117 	ldw	r2,4(r2)
   14568:	e0fffe17 	ldw	r3,-8(fp)
   1456c:	18c00117 	ldw	r3,4(r3)
   14570:	1900020b 	ldhu	r4,8(r3)
   14574:	e0fffd0b 	ldhu	r3,-12(fp)
   14578:	20c7c83a 	sub	r3,r4,r3
   1457c:	10c0020d 	sth	r3,8(r2)

  seg->p->payload = seg->tcphdr;
   14580:	e0bffe17 	ldw	r2,-8(fp)
   14584:	10800117 	ldw	r2,4(r2)
   14588:	e0fffe17 	ldw	r3,-8(fp)
   1458c:	18c00317 	ldw	r3,12(r3)
   14590:	10c00115 	stw	r3,4(r2)

  seg->tcphdr->chksum = 0;
   14594:	e0bffe17 	ldw	r2,-8(fp)
   14598:	10800317 	ldw	r2,12(r2)
   1459c:	1000040d 	sth	zero,16(r2)
      seg->tcphdr->chksum = chksum_slow;
    }
#endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
  }
#else /* TCP_CHECKSUM_ON_COPY */
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
   145a0:	e0bffe17 	ldw	r2,-8(fp)
   145a4:	14000317 	ldw	r16,12(r2)
   145a8:	e0bffe17 	ldw	r2,-8(fp)
   145ac:	11000117 	ldw	r4,4(r2)
   145b0:	e0ffff17 	ldw	r3,-4(fp)
   145b4:	e0bfff17 	ldw	r2,-4(fp)
   145b8:	10800104 	addi	r2,r2,4
         &(pcb->remote_ip),
         IP_PROTO_TCP, seg->p->tot_len);
   145bc:	e17ffe17 	ldw	r5,-8(fp)
   145c0:	29400117 	ldw	r5,4(r5)
   145c4:	2940020b 	ldhu	r5,8(r5)
      seg->tcphdr->chksum = chksum_slow;
    }
#endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
  }
#else /* TCP_CHECKSUM_ON_COPY */
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
   145c8:	297fffcc 	andi	r5,r5,65535
   145cc:	d9400015 	stw	r5,0(sp)
   145d0:	180b883a 	mov	r5,r3
   145d4:	100d883a 	mov	r6,r2
   145d8:	01c00184 	movi	r7,6
   145dc:	0005cb80 	call	5cb8 <inet_chksum_pseudo>
   145e0:	8080040d 	sth	r2,16(r16)
         &(pcb->remote_ip),
         IP_PROTO_TCP, seg->p->tot_len);
#endif /* TCP_CHECKSUM_ON_COPY */
#endif /* CHECKSUM_GEN_TCP */
  TCP_STATS_INC(tcp.xmit);
   145e4:	00800234 	movhi	r2,8
   145e8:	1083bd04 	addi	r2,r2,3828
   145ec:	1080240b 	ldhu	r2,144(r2)
   145f0:	10800044 	addi	r2,r2,1
   145f4:	1007883a 	mov	r3,r2
   145f8:	00800234 	movhi	r2,8
   145fc:	1083bd04 	addi	r2,r2,3828
   14600:	10c0240d 	sth	r3,144(r2)

#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
   14604:	e0bffe17 	ldw	r2,-8(fp)
   14608:	11000117 	ldw	r4,4(r2)
   1460c:	e17fff17 	ldw	r5,-4(fp)
   14610:	e0bfff17 	ldw	r2,-4(fp)
   14614:	10c00104 	addi	r3,r2,4
   14618:	e0bfff17 	ldw	r2,-4(fp)
   1461c:	10800283 	ldbu	r2,10(r2)
   14620:	10803fcc 	andi	r2,r2,255
   14624:	e1bfff17 	ldw	r6,-4(fp)
   14628:	31800243 	ldbu	r6,9(r6)
   1462c:	31803fcc 	andi	r6,r6,255
   14630:	d9800015 	stw	r6,0(sp)
   14634:	01800184 	movi	r6,6
   14638:	d9800115 	stw	r6,4(sp)
   1463c:	180d883a 	mov	r6,r3
   14640:	100f883a 	mov	r7,r2
   14644:	0006cbc0 	call	6cbc <ip_output>
   14648:	00000106 	br	14650 <tcp_output_segment+0x3b8>
  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
    netif = ip_route(&(pcb->remote_ip));
    if (netif == NULL) {
      return;
   1464c:	0001883a 	nop
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
}
   14650:	e037883a 	mov	sp,fp
   14654:	dfc00217 	ldw	ra,8(sp)
   14658:	df000117 	ldw	fp,4(sp)
   1465c:	dc000017 	ldw	r16,0(sp)
   14660:	dec00304 	addi	sp,sp,12
   14664:	f800283a 	ret

00014668 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  ip_addr_t *local_ip, ip_addr_t *remote_ip,
  u16_t local_port, u16_t remote_port)
{
   14668:	defff404 	addi	sp,sp,-48
   1466c:	dfc00b15 	stw	ra,44(sp)
   14670:	df000a15 	stw	fp,40(sp)
   14674:	df000a04 	addi	fp,sp,40
   14678:	e13ffa15 	stw	r4,-24(fp)
   1467c:	e17ffb15 	stw	r5,-20(fp)
   14680:	e1bffc15 	stw	r6,-16(fp)
   14684:	e1fffd15 	stw	r7,-12(fp)
   14688:	e0c00217 	ldw	r3,8(fp)
   1468c:	e0800317 	ldw	r2,12(fp)
   14690:	e0fffe0d 	sth	r3,-8(fp)
   14694:	e0bfff0d 	sth	r2,-4(fp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
   14698:	01000044 	movi	r4,1
   1469c:	01400504 	movi	r5,20
   146a0:	000d883a 	mov	r6,zero
   146a4:	000a0740 	call	a074 <pbuf_alloc>
   146a8:	e0bff815 	stw	r2,-32(fp)
  if (p == NULL) {
   146ac:	e0bff817 	ldw	r2,-32(fp)
   146b0:	10007b26 	beq	r2,zero,148a0 <tcp_rst+0x238>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
   146b4:	e0bff817 	ldw	r2,-32(fp)
   146b8:	1080028b 	ldhu	r2,10(r2)
   146bc:	10bfffcc 	andi	r2,r2,65535
   146c0:	10800528 	cmpgeui	r2,r2,20
   146c4:	1000091e 	bne	r2,zero,146ec <tcp_rst+0x84>
   146c8:	010000f4 	movhi	r4,3
   146cc:	2102c104 	addi	r4,r4,2820
   146d0:	014000f4 	movhi	r5,3
   146d4:	2942cb04 	addi	r5,r5,2860
   146d8:	01812dc4 	movi	r6,1207
   146dc:	01c000f4 	movhi	r7,3
   146e0:	39c2d704 	addi	r7,r7,2908
   146e4:	00193f00 	call	193f0 <printf>
   146e8:	003fff06 	br	146e8 <tcp_rst+0x80>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
   146ec:	e0bff817 	ldw	r2,-32(fp)
   146f0:	10800117 	ldw	r2,4(r2)
   146f4:	e0bff915 	stw	r2,-28(fp)
  tcphdr->src = htons(local_port);
   146f8:	e0bffe0b 	ldhu	r2,-8(fp)
   146fc:	1004d23a 	srli	r2,r2,8
   14700:	1007883a 	mov	r3,r2
   14704:	e0bffe0b 	ldhu	r2,-8(fp)
   14708:	1004923a 	slli	r2,r2,8
   1470c:	1884b03a 	or	r2,r3,r2
   14710:	1007883a 	mov	r3,r2
   14714:	e0bff917 	ldw	r2,-28(fp)
   14718:	10c0000d 	sth	r3,0(r2)
  tcphdr->dest = htons(remote_port);
   1471c:	e0bfff0b 	ldhu	r2,-4(fp)
   14720:	1004d23a 	srli	r2,r2,8
   14724:	1007883a 	mov	r3,r2
   14728:	e0bfff0b 	ldhu	r2,-4(fp)
   1472c:	1004923a 	slli	r2,r2,8
   14730:	1884b03a 	or	r2,r3,r2
   14734:	1007883a 	mov	r3,r2
   14738:	e0bff917 	ldw	r2,-28(fp)
   1473c:	10c0008d 	sth	r3,2(r2)
  tcphdr->seqno = htonl(seqno);
   14740:	e0bffa17 	ldw	r2,-24(fp)
   14744:	1006d63a 	srli	r3,r2,24
   14748:	e0bffa17 	ldw	r2,-24(fp)
   1474c:	1004d23a 	srli	r2,r2,8
   14750:	10bfc00c 	andi	r2,r2,65280
   14754:	1886b03a 	or	r3,r3,r2
   14758:	e0bffa17 	ldw	r2,-24(fp)
   1475c:	10bfc00c 	andi	r2,r2,65280
   14760:	1004923a 	slli	r2,r2,8
   14764:	1886b03a 	or	r3,r3,r2
   14768:	e0bffa17 	ldw	r2,-24(fp)
   1476c:	1004963a 	slli	r2,r2,24
   14770:	1886b03a 	or	r3,r3,r2
   14774:	e0bff917 	ldw	r2,-28(fp)
   14778:	193fffcc 	andi	r4,r3,65535
   1477c:	1140010b 	ldhu	r5,4(r2)
   14780:	280a703a 	and	r5,r5,zero
   14784:	2908b03a 	or	r4,r5,r4
   14788:	1100010d 	sth	r4,4(r2)
   1478c:	1806d43a 	srli	r3,r3,16
   14790:	1100018b 	ldhu	r4,6(r2)
   14794:	2008703a 	and	r4,r4,zero
   14798:	20c6b03a 	or	r3,r4,r3
   1479c:	10c0018d 	sth	r3,6(r2)
  tcphdr->ackno = htonl(ackno);
   147a0:	e0bffb17 	ldw	r2,-20(fp)
   147a4:	1006d63a 	srli	r3,r2,24
   147a8:	e0bffb17 	ldw	r2,-20(fp)
   147ac:	1004d23a 	srli	r2,r2,8
   147b0:	10bfc00c 	andi	r2,r2,65280
   147b4:	1886b03a 	or	r3,r3,r2
   147b8:	e0bffb17 	ldw	r2,-20(fp)
   147bc:	10bfc00c 	andi	r2,r2,65280
   147c0:	1004923a 	slli	r2,r2,8
   147c4:	1886b03a 	or	r3,r3,r2
   147c8:	e0bffb17 	ldw	r2,-20(fp)
   147cc:	1004963a 	slli	r2,r2,24
   147d0:	1886b03a 	or	r3,r3,r2
   147d4:	e0bff917 	ldw	r2,-28(fp)
   147d8:	193fffcc 	andi	r4,r3,65535
   147dc:	1140020b 	ldhu	r5,8(r2)
   147e0:	280a703a 	and	r5,r5,zero
   147e4:	2908b03a 	or	r4,r5,r4
   147e8:	1100020d 	sth	r4,8(r2)
   147ec:	1806d43a 	srli	r3,r3,16
   147f0:	1100028b 	ldhu	r4,10(r2)
   147f4:	2008703a 	and	r4,r4,zero
   147f8:	20c6b03a 	or	r3,r4,r3
   147fc:	10c0028d 	sth	r3,10(r2)
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
   14800:	e0bff917 	ldw	r2,-28(fp)
   14804:	00c51404 	movi	r3,5200
   14808:	10c0030d 	sth	r3,12(r2)
  tcphdr->wnd = PP_HTONS(TCP_WND);
   1480c:	e0bff917 	ldw	r2,-28(fp)
   14810:	00c00204 	movi	r3,8
   14814:	10c0038d 	sth	r3,14(r2)
  tcphdr->chksum = 0;
   14818:	e0bff917 	ldw	r2,-28(fp)
   1481c:	1000040d 	sth	zero,16(r2)
  tcphdr->urgp = 0;
   14820:	e0bff917 	ldw	r2,-28(fp)
   14824:	1000048d 	sth	zero,18(r2)

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
              IP_PROTO_TCP, p->tot_len);
   14828:	e0bff817 	ldw	r2,-32(fp)
   1482c:	1080020b 	ldhu	r2,8(r2)
  tcphdr->wnd = PP_HTONS(TCP_WND);
  tcphdr->chksum = 0;
  tcphdr->urgp = 0;

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
   14830:	10bfffcc 	andi	r2,r2,65535
   14834:	d8800015 	stw	r2,0(sp)
   14838:	e13ff817 	ldw	r4,-32(fp)
   1483c:	e17ffc17 	ldw	r5,-16(fp)
   14840:	e1bffd17 	ldw	r6,-12(fp)
   14844:	01c00184 	movi	r7,6
   14848:	0005cb80 	call	5cb8 <inet_chksum_pseudo>
   1484c:	e0fff917 	ldw	r3,-28(fp)
   14850:	1880040d 	sth	r2,16(r3)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
   14854:	00800234 	movhi	r2,8
   14858:	1083bd04 	addi	r2,r2,3828
   1485c:	1080240b 	ldhu	r2,144(r2)
   14860:	10800044 	addi	r2,r2,1
   14864:	1007883a 	mov	r3,r2
   14868:	00800234 	movhi	r2,8
   1486c:	1083bd04 	addi	r2,r2,3828
   14870:	10c0240d 	sth	r3,144(r2)
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
   14874:	d8000015 	stw	zero,0(sp)
   14878:	00800184 	movi	r2,6
   1487c:	d8800115 	stw	r2,4(sp)
   14880:	e13ff817 	ldw	r4,-32(fp)
   14884:	e17ffc17 	ldw	r5,-16(fp)
   14888:	e1bffd17 	ldw	r6,-12(fp)
   1488c:	01c03fc4 	movi	r7,255
   14890:	0006cbc0 	call	6cbc <ip_output>
  pbuf_free(p);
   14894:	e13ff817 	ldw	r4,-32(fp)
   14898:	000aa340 	call	aa34 <pbuf_free>
   1489c:	00000106 	br	148a4 <tcp_rst+0x23c>
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  if (p == NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
   148a0:	0001883a 	nop
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  pbuf_free(p);
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
   148a4:	e037883a 	mov	sp,fp
   148a8:	dfc00117 	ldw	ra,4(sp)
   148ac:	df000017 	ldw	fp,0(sp)
   148b0:	dec00204 	addi	sp,sp,8
   148b4:	f800283a 	ret

000148b8 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
   148b8:	defffc04 	addi	sp,sp,-16
   148bc:	dfc00315 	stw	ra,12(sp)
   148c0:	df000215 	stw	fp,8(sp)
   148c4:	df000204 	addi	fp,sp,8
   148c8:	e13fff15 	stw	r4,-4(fp)
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
   148cc:	e0bfff17 	ldw	r2,-4(fp)
   148d0:	10801d17 	ldw	r2,116(r2)
   148d4:	10001f26 	beq	r2,zero,14954 <tcp_rexmit_rto+0x9c>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
   148d8:	e0bfff17 	ldw	r2,-4(fp)
   148dc:	10801d17 	ldw	r2,116(r2)
   148e0:	e0bffe15 	stw	r2,-8(fp)
   148e4:	00000306 	br	148f4 <tcp_rexmit_rto+0x3c>
   148e8:	e0bffe17 	ldw	r2,-8(fp)
   148ec:	10800017 	ldw	r2,0(r2)
   148f0:	e0bffe15 	stw	r2,-8(fp)
   148f4:	e0bffe17 	ldw	r2,-8(fp)
   148f8:	10800017 	ldw	r2,0(r2)
   148fc:	103ffa1e 	bne	r2,zero,148e8 <tcp_rexmit_rto+0x30>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
   14900:	e0bfff17 	ldw	r2,-4(fp)
   14904:	10c01c17 	ldw	r3,112(r2)
   14908:	e0bffe17 	ldw	r2,-8(fp)
   1490c:	10c00015 	stw	r3,0(r2)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
   14910:	e0bfff17 	ldw	r2,-4(fp)
   14914:	10c01d17 	ldw	r3,116(r2)
   14918:	e0bfff17 	ldw	r2,-4(fp)
   1491c:	10c01c15 	stw	r3,112(r2)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
   14920:	e0bfff17 	ldw	r2,-4(fp)
   14924:	10001d15 	stw	zero,116(r2)
  /* last unsent hasn't changed, no need to reset unsent_oversize */

  /* increment number of retransmissions */
  ++pcb->nrtx;
   14928:	e0bfff17 	ldw	r2,-4(fp)
   1492c:	10801283 	ldbu	r2,74(r2)
   14930:	10800044 	addi	r2,r2,1
   14934:	1007883a 	mov	r3,r2
   14938:	e0bfff17 	ldw	r2,-4(fp)
   1493c:	10c01285 	stb	r3,74(r2)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
   14940:	e0bfff17 	ldw	r2,-4(fp)
   14944:	10000f15 	stw	zero,60(r2)

  /* Do the actual retransmission */
  tcp_output(pcb);
   14948:	e13fff17 	ldw	r4,-4(fp)
   1494c:	0013a740 	call	13a74 <tcp_output>
   14950:	00000106 	br	14958 <tcp_rexmit_rto+0xa0>
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
    return;
   14954:	0001883a 	nop
  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;

  /* Do the actual retransmission */
  tcp_output(pcb);
}
   14958:	e037883a 	mov	sp,fp
   1495c:	dfc00117 	ldw	ra,4(sp)
   14960:	df000017 	ldw	fp,0(sp)
   14964:	dec00204 	addi	sp,sp,8
   14968:	f800283a 	ret

0001496c <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
   1496c:	defffc04 	addi	sp,sp,-16
   14970:	df000315 	stw	fp,12(sp)
   14974:	df000304 	addi	fp,sp,12
   14978:	e13fff15 	stw	r4,-4(fp)
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
   1497c:	e0bfff17 	ldw	r2,-4(fp)
   14980:	10801d17 	ldw	r2,116(r2)
   14984:	10006e26 	beq	r2,zero,14b40 <tcp_rexmit+0x1d4>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
   14988:	e0bfff17 	ldw	r2,-4(fp)
   1498c:	10801d17 	ldw	r2,116(r2)
   14990:	e0bffe15 	stw	r2,-8(fp)
  pcb->unacked = seg->next;
   14994:	e0bffe17 	ldw	r2,-8(fp)
   14998:	10c00017 	ldw	r3,0(r2)
   1499c:	e0bfff17 	ldw	r2,-4(fp)
   149a0:	10c01d15 	stw	r3,116(r2)

  cur_seg = &(pcb->unsent);
   149a4:	e0bfff17 	ldw	r2,-4(fp)
   149a8:	10801c04 	addi	r2,r2,112
   149ac:	e0bffd15 	stw	r2,-12(fp)
  while (*cur_seg &&
   149b0:	00000306 	br	149c0 <tcp_rexmit+0x54>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
   149b4:	e0bffd17 	ldw	r2,-12(fp)
   149b8:	10800017 	ldw	r2,0(r2)
   149bc:	e0bffd15 	stw	r2,-12(fp)
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
   149c0:	e0bffd17 	ldw	r2,-12(fp)
   149c4:	10800017 	ldw	r2,0(r2)
   149c8:	10004826 	beq	r2,zero,14aec <tcp_rexmit+0x180>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
   149cc:	e0bffd17 	ldw	r2,-12(fp)
   149d0:	10800017 	ldw	r2,0(r2)
   149d4:	10800317 	ldw	r2,12(r2)
   149d8:	10c0010b 	ldhu	r3,4(r2)
   149dc:	1080018b 	ldhu	r2,6(r2)
   149e0:	1004943a 	slli	r2,r2,16
   149e4:	10c4b03a 	or	r2,r2,r3
   149e8:	1006d63a 	srli	r3,r2,24
   149ec:	e0bffd17 	ldw	r2,-12(fp)
   149f0:	10800017 	ldw	r2,0(r2)
   149f4:	10800317 	ldw	r2,12(r2)
   149f8:	1100010b 	ldhu	r4,4(r2)
   149fc:	1080018b 	ldhu	r2,6(r2)
   14a00:	1004943a 	slli	r2,r2,16
   14a04:	1104b03a 	or	r2,r2,r4
   14a08:	1004d23a 	srli	r2,r2,8
   14a0c:	10bfc00c 	andi	r2,r2,65280
   14a10:	1886b03a 	or	r3,r3,r2
   14a14:	e0bffd17 	ldw	r2,-12(fp)
   14a18:	10800017 	ldw	r2,0(r2)
   14a1c:	10800317 	ldw	r2,12(r2)
   14a20:	1100010b 	ldhu	r4,4(r2)
   14a24:	1080018b 	ldhu	r2,6(r2)
   14a28:	1004943a 	slli	r2,r2,16
   14a2c:	1104b03a 	or	r2,r2,r4
   14a30:	10bfc00c 	andi	r2,r2,65280
   14a34:	1004923a 	slli	r2,r2,8
   14a38:	1886b03a 	or	r3,r3,r2
   14a3c:	e0bffd17 	ldw	r2,-12(fp)
   14a40:	10800017 	ldw	r2,0(r2)
   14a44:	10800317 	ldw	r2,12(r2)
   14a48:	1100010b 	ldhu	r4,4(r2)
   14a4c:	1080018b 	ldhu	r2,6(r2)
   14a50:	1004943a 	slli	r2,r2,16
   14a54:	1104b03a 	or	r2,r2,r4
   14a58:	1004963a 	slli	r2,r2,24
   14a5c:	1886b03a 	or	r3,r3,r2
   14a60:	e0bffe17 	ldw	r2,-8(fp)
   14a64:	10800317 	ldw	r2,12(r2)
   14a68:	1100010b 	ldhu	r4,4(r2)
   14a6c:	1080018b 	ldhu	r2,6(r2)
   14a70:	1004943a 	slli	r2,r2,16
   14a74:	1104b03a 	or	r2,r2,r4
   14a78:	1008d63a 	srli	r4,r2,24
   14a7c:	e0bffe17 	ldw	r2,-8(fp)
   14a80:	10800317 	ldw	r2,12(r2)
   14a84:	1140010b 	ldhu	r5,4(r2)
   14a88:	1080018b 	ldhu	r2,6(r2)
   14a8c:	1004943a 	slli	r2,r2,16
   14a90:	1144b03a 	or	r2,r2,r5
   14a94:	1004d23a 	srli	r2,r2,8
   14a98:	10bfc00c 	andi	r2,r2,65280
   14a9c:	2088b03a 	or	r4,r4,r2
   14aa0:	e0bffe17 	ldw	r2,-8(fp)
   14aa4:	10800317 	ldw	r2,12(r2)
   14aa8:	1140010b 	ldhu	r5,4(r2)
   14aac:	1080018b 	ldhu	r2,6(r2)
   14ab0:	1004943a 	slli	r2,r2,16
   14ab4:	1144b03a 	or	r2,r2,r5
   14ab8:	10bfc00c 	andi	r2,r2,65280
   14abc:	1004923a 	slli	r2,r2,8
   14ac0:	2088b03a 	or	r4,r4,r2
   14ac4:	e0bffe17 	ldw	r2,-8(fp)
   14ac8:	10800317 	ldw	r2,12(r2)
   14acc:	1140010b 	ldhu	r5,4(r2)
   14ad0:	1080018b 	ldhu	r2,6(r2)
   14ad4:	1004943a 	slli	r2,r2,16
   14ad8:	1144b03a 	or	r2,r2,r5
   14adc:	1004963a 	slli	r2,r2,24
   14ae0:	2084b03a 	or	r2,r4,r2
   14ae4:	1885c83a 	sub	r2,r3,r2
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
   14ae8:	103fb216 	blt	r2,zero,149b4 <tcp_rexmit+0x48>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
  }
  seg->next = *cur_seg;
   14aec:	e0bffd17 	ldw	r2,-12(fp)
   14af0:	10c00017 	ldw	r3,0(r2)
   14af4:	e0bffe17 	ldw	r2,-8(fp)
   14af8:	10c00015 	stw	r3,0(r2)
  *cur_seg = seg;
   14afc:	e0bffd17 	ldw	r2,-12(fp)
   14b00:	e0fffe17 	ldw	r3,-8(fp)
   14b04:	10c00015 	stw	r3,0(r2)
#if TCP_OVERSIZE
  if (seg->next == NULL) {
   14b08:	e0bffe17 	ldw	r2,-8(fp)
   14b0c:	10800017 	ldw	r2,0(r2)
   14b10:	1000021e 	bne	r2,zero,14b1c <tcp_rexmit+0x1b0>
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
   14b14:	e0bfff17 	ldw	r2,-4(fp)
   14b18:	10001b8d 	sth	zero,110(r2)
  }
#endif /* TCP_OVERSIZE */

  ++pcb->nrtx;
   14b1c:	e0bfff17 	ldw	r2,-4(fp)
   14b20:	10801283 	ldbu	r2,74(r2)
   14b24:	10800044 	addi	r2,r2,1
   14b28:	1007883a 	mov	r3,r2
   14b2c:	e0bfff17 	ldw	r2,-4(fp)
   14b30:	10c01285 	stb	r3,74(r2)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
   14b34:	e0bfff17 	ldw	r2,-4(fp)
   14b38:	10000f15 	stw	zero,60(r2)
   14b3c:	00000106 	br	14b44 <tcp_rexmit+0x1d8>
{
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
    return;
   14b40:	0001883a 	nop

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  /* No need to call tcp_output: we are always called from tcp_input()
     and thus tcp_output directly returns. */
}
   14b44:	e037883a 	mov	sp,fp
   14b48:	df000017 	ldw	fp,0(sp)
   14b4c:	dec00104 	addi	sp,sp,4
   14b50:	f800283a 	ret

00014b54 <tcp_rexmit_fast>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void 
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
   14b54:	defffd04 	addi	sp,sp,-12
   14b58:	dfc00215 	stw	ra,8(sp)
   14b5c:	df000115 	stw	fp,4(sp)
   14b60:	df000104 	addi	fp,sp,4
   14b64:	e13fff15 	stw	r4,-4(fp)
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
   14b68:	e0bfff17 	ldw	r2,-4(fp)
   14b6c:	10801d17 	ldw	r2,116(r2)
   14b70:	10003c26 	beq	r2,zero,14c64 <tcp_rexmit_fast+0x110>
   14b74:	e0bfff17 	ldw	r2,-4(fp)
   14b78:	10800883 	ldbu	r2,34(r2)
   14b7c:	10803fcc 	andi	r2,r2,255
   14b80:	1080010c 	andi	r2,r2,4
   14b84:	1000371e 	bne	r2,zero,14c64 <tcp_rexmit_fast+0x110>
    LWIP_DEBUGF(TCP_FR_DEBUG, 
                ("tcp_receive: dupacks %"U16_F" (%"U32_F
                 "), fast retransmit %"U32_F"\n",
                 (u16_t)pcb->dupacks, pcb->lastack,
                 ntohl(pcb->unacked->tcphdr->seqno)));
    tcp_rexmit(pcb);
   14b88:	e13fff17 	ldw	r4,-4(fp)
   14b8c:	001496c0 	call	1496c <tcp_rexmit>

    /* Set ssthresh to half of the minimum of the current
     * cwnd and the advertised window */
    if (pcb->cwnd > pcb->snd_wnd) {
   14b90:	e0bfff17 	ldw	r2,-4(fp)
   14b94:	1080140b 	ldhu	r2,80(r2)
   14b98:	e0ffff17 	ldw	r3,-4(fp)
   14b9c:	18c0190b 	ldhu	r3,100(r3)
   14ba0:	10bfffcc 	andi	r2,r2,65535
   14ba4:	18ffffcc 	andi	r3,r3,65535
   14ba8:	1880082e 	bgeu	r3,r2,14bcc <tcp_rexmit_fast+0x78>
      pcb->ssthresh = pcb->snd_wnd / 2;
   14bac:	e0bfff17 	ldw	r2,-4(fp)
   14bb0:	1080190b 	ldhu	r2,100(r2)
   14bb4:	10bfffcc 	andi	r2,r2,65535
   14bb8:	1004d07a 	srli	r2,r2,1
   14bbc:	1007883a 	mov	r3,r2
   14bc0:	e0bfff17 	ldw	r2,-4(fp)
   14bc4:	10c0148d 	sth	r3,82(r2)
   14bc8:	00000706 	br	14be8 <tcp_rexmit_fast+0x94>
    } else {
      pcb->ssthresh = pcb->cwnd / 2;
   14bcc:	e0bfff17 	ldw	r2,-4(fp)
   14bd0:	1080140b 	ldhu	r2,80(r2)
   14bd4:	10bfffcc 	andi	r2,r2,65535
   14bd8:	1004d07a 	srli	r2,r2,1
   14bdc:	1007883a 	mov	r3,r2
   14be0:	e0bfff17 	ldw	r2,-4(fp)
   14be4:	10c0148d 	sth	r3,82(r2)
    }
    
    /* The minimum value for ssthresh should be 2 MSS */
    if (pcb->ssthresh < 2*pcb->mss) {
   14be8:	e0bfff17 	ldw	r2,-4(fp)
   14bec:	1080148b 	ldhu	r2,82(r2)
   14bf0:	10ffffcc 	andi	r3,r2,65535
   14bf4:	e0bfff17 	ldw	r2,-4(fp)
   14bf8:	10800e8b 	ldhu	r2,58(r2)
   14bfc:	10bfffcc 	andi	r2,r2,65535
   14c00:	1085883a 	add	r2,r2,r2
   14c04:	1880060e 	bge	r3,r2,14c20 <tcp_rexmit_fast+0xcc>
      LWIP_DEBUGF(TCP_FR_DEBUG, 
                  ("tcp_receive: The minimum value for ssthresh %"U16_F
                   " should be min 2 mss %"U16_F"...\n",
                   pcb->ssthresh, 2*pcb->mss));
      pcb->ssthresh = 2*pcb->mss;
   14c08:	e0bfff17 	ldw	r2,-4(fp)
   14c0c:	10800e8b 	ldhu	r2,58(r2)
   14c10:	1085883a 	add	r2,r2,r2
   14c14:	1007883a 	mov	r3,r2
   14c18:	e0bfff17 	ldw	r2,-4(fp)
   14c1c:	10c0148d 	sth	r3,82(r2)
    }
    
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
   14c20:	e0bfff17 	ldw	r2,-4(fp)
   14c24:	1100148b 	ldhu	r4,82(r2)
   14c28:	e0bfff17 	ldw	r2,-4(fp)
   14c2c:	10c00e8b 	ldhu	r3,58(r2)
   14c30:	1805883a 	mov	r2,r3
   14c34:	1085883a 	add	r2,r2,r2
   14c38:	10c5883a 	add	r2,r2,r3
   14c3c:	2085883a 	add	r2,r4,r2
   14c40:	1007883a 	mov	r3,r2
   14c44:	e0bfff17 	ldw	r2,-4(fp)
   14c48:	10c0140d 	sth	r3,80(r2)
    pcb->flags |= TF_INFR;
   14c4c:	e0bfff17 	ldw	r2,-4(fp)
   14c50:	10800883 	ldbu	r2,34(r2)
   14c54:	10800114 	ori	r2,r2,4
   14c58:	1007883a 	mov	r3,r2
   14c5c:	e0bfff17 	ldw	r2,-4(fp)
   14c60:	10c00885 	stb	r3,34(r2)
  } 
}
   14c64:	e037883a 	mov	sp,fp
   14c68:	dfc00117 	ldw	ra,4(sp)
   14c6c:	df000017 	ldw	fp,0(sp)
   14c70:	dec00204 	addi	sp,sp,8
   14c74:	f800283a 	ret

00014c78 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
   14c78:	defff904 	addi	sp,sp,-28
   14c7c:	dfc00615 	stw	ra,24(sp)
   14c80:	df000515 	stw	fp,20(sp)
   14c84:	df000504 	addi	fp,sp,20
   14c88:	e13fff15 	stw	r4,-4(fp)
                          ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
   14c8c:	e0bfff17 	ldw	r2,-4(fp)
   14c90:	10801517 	ldw	r2,84(r2)
   14c94:	10bfffc4 	addi	r2,r2,-1
   14c98:	1006d63a 	srli	r3,r2,24
   14c9c:	e0bfff17 	ldw	r2,-4(fp)
   14ca0:	10801517 	ldw	r2,84(r2)
   14ca4:	10bfffc4 	addi	r2,r2,-1
   14ca8:	1004d23a 	srli	r2,r2,8
   14cac:	10bfc00c 	andi	r2,r2,65280
   14cb0:	1886b03a 	or	r3,r3,r2
   14cb4:	e0bfff17 	ldw	r2,-4(fp)
   14cb8:	10801517 	ldw	r2,84(r2)
   14cbc:	10bfffc4 	addi	r2,r2,-1
   14cc0:	10bfc00c 	andi	r2,r2,65280
   14cc4:	1004923a 	slli	r2,r2,8
   14cc8:	1886b03a 	or	r3,r3,r2
   14ccc:	e0bfff17 	ldw	r2,-4(fp)
   14cd0:	10801517 	ldw	r2,84(r2)
   14cd4:	10bfffc4 	addi	r2,r2,-1
   14cd8:	1004963a 	slli	r2,r2,24
   14cdc:	1884b03a 	or	r2,r3,r2
   14ce0:	e13fff17 	ldw	r4,-4(fp)
   14ce4:	000b883a 	mov	r5,zero
   14ce8:	000d883a 	mov	r6,zero
   14cec:	100f883a 	mov	r7,r2
   14cf0:	001234c0 	call	1234c <tcp_output_alloc_header>
   14cf4:	e0bffd15 	stw	r2,-12(fp)
  if(p == NULL) {
   14cf8:	e0bffd17 	ldw	r2,-12(fp)
   14cfc:	10002926 	beq	r2,zero,14da4 <tcp_keepalive+0x12c>
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
   14d00:	e0bffd17 	ldw	r2,-12(fp)
   14d04:	10800117 	ldw	r2,4(r2)
   14d08:	e0bffe15 	stw	r2,-8(fp)

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
   14d0c:	e0ffff17 	ldw	r3,-4(fp)
   14d10:	e0bfff17 	ldw	r2,-4(fp)
   14d14:	10800104 	addi	r2,r2,4
                                      IP_PROTO_TCP, p->tot_len);
   14d18:	e13ffd17 	ldw	r4,-12(fp)
   14d1c:	2100020b 	ldhu	r4,8(r4)
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
   14d20:	213fffcc 	andi	r4,r4,65535
   14d24:	d9000015 	stw	r4,0(sp)
   14d28:	e13ffd17 	ldw	r4,-12(fp)
   14d2c:	180b883a 	mov	r5,r3
   14d30:	100d883a 	mov	r6,r2
   14d34:	01c00184 	movi	r7,6
   14d38:	0005cb80 	call	5cb8 <inet_chksum_pseudo>
   14d3c:	e0fffe17 	ldw	r3,-8(fp)
   14d40:	1880040d 	sth	r2,16(r3)
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
   14d44:	00800234 	movhi	r2,8
   14d48:	1083bd04 	addi	r2,r2,3828
   14d4c:	1080240b 	ldhu	r2,144(r2)
   14d50:	10800044 	addi	r2,r2,1
   14d54:	1007883a 	mov	r3,r2
   14d58:	00800234 	movhi	r2,8
   14d5c:	1083bd04 	addi	r2,r2,3828
   14d60:	10c0240d 	sth	r3,144(r2)
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
   14d64:	e17fff17 	ldw	r5,-4(fp)
   14d68:	e0bfff17 	ldw	r2,-4(fp)
   14d6c:	10c00104 	addi	r3,r2,4
   14d70:	e0bfff17 	ldw	r2,-4(fp)
   14d74:	10800283 	ldbu	r2,10(r2)
   14d78:	10803fcc 	andi	r2,r2,255
   14d7c:	d8000015 	stw	zero,0(sp)
   14d80:	01000184 	movi	r4,6
   14d84:	d9000115 	stw	r4,4(sp)
   14d88:	e13ffd17 	ldw	r4,-12(fp)
   14d8c:	180d883a 	mov	r6,r3
   14d90:	100f883a 	mov	r7,r2
   14d94:	0006cbc0 	call	6cbc <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
   14d98:	e13ffd17 	ldw	r4,-12(fp)
   14d9c:	000aa340 	call	aa34 <pbuf_free>
   14da0:	00000106 	br	14da8 <tcp_keepalive+0x130>
   
  p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
   14da4:	0001883a 	nop

  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
   14da8:	e037883a 	mov	sp,fp
   14dac:	dfc00117 	ldw	ra,4(sp)
   14db0:	df000017 	ldw	fp,0(sp)
   14db4:	dec00204 	addi	sp,sp,8
   14db8:	f800283a 	ret

00014dbc <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
   14dbc:	defff604 	addi	sp,sp,-40
   14dc0:	dfc00915 	stw	ra,36(sp)
   14dc4:	df000815 	stw	fp,32(sp)
   14dc8:	df000804 	addi	fp,sp,32
   14dcc:	e13fff15 	stw	r4,-4(fp)
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
   14dd0:	e0bfff17 	ldw	r2,-4(fp)
   14dd4:	10801d17 	ldw	r2,116(r2)
   14dd8:	e0bffa15 	stw	r2,-24(fp)

  if(seg == NULL) {
   14ddc:	e0bffa17 	ldw	r2,-24(fp)
   14de0:	1000031e 	bne	r2,zero,14df0 <tcp_zero_window_probe+0x34>
    seg = pcb->unsent;
   14de4:	e0bfff17 	ldw	r2,-4(fp)
   14de8:	10801c17 	ldw	r2,112(r2)
   14dec:	e0bffa15 	stw	r2,-24(fp)
  }
  if(seg == NULL) {
   14df0:	e0bffa17 	ldw	r2,-24(fp)
   14df4:	10007026 	beq	r2,zero,14fb8 <tcp_zero_window_probe+0x1fc>
    return;
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
   14df8:	e0bffa17 	ldw	r2,-24(fp)
   14dfc:	10800317 	ldw	r2,12(r2)
   14e00:	1080030b 	ldhu	r2,12(r2)
   14e04:	10bfffcc 	andi	r2,r2,65535
   14e08:	1004d23a 	srli	r2,r2,8
   14e0c:	10ffffcc 	andi	r3,r2,65535
   14e10:	e0bffa17 	ldw	r2,-24(fp)
   14e14:	10800317 	ldw	r2,12(r2)
   14e18:	1080030b 	ldhu	r2,12(r2)
   14e1c:	10bfffcc 	andi	r2,r2,65535
   14e20:	1004923a 	slli	r2,r2,8
   14e24:	10bfffcc 	andi	r2,r2,65535
   14e28:	1884b03a 	or	r2,r3,r2
   14e2c:	1080004c 	andi	r2,r2,1
   14e30:	10000626 	beq	r2,zero,14e4c <tcp_zero_window_probe+0x90>
   14e34:	e0bffa17 	ldw	r2,-24(fp)
   14e38:	1080020b 	ldhu	r2,8(r2)
   14e3c:	10bfffcc 	andi	r2,r2,65535
   14e40:	1000021e 	bne	r2,zero,14e4c <tcp_zero_window_probe+0x90>
   14e44:	00800044 	movi	r2,1
   14e48:	00000106 	br	14e50 <tcp_zero_window_probe+0x94>
   14e4c:	0005883a 	mov	r2,zero
   14e50:	e0bffb05 	stb	r2,-20(fp)
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;
   14e54:	e0bffb03 	ldbu	r2,-20(fp)
   14e58:	1005003a 	cmpeq	r2,r2,zero
   14e5c:	10803fcc 	andi	r2,r2,255
   14e60:	e0bffb8d 	sth	r2,-18(fp)

  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
   14e64:	e0fffb8b 	ldhu	r3,-18(fp)
   14e68:	e0bffa17 	ldw	r2,-24(fp)
   14e6c:	10800317 	ldw	r2,12(r2)
   14e70:	1100010b 	ldhu	r4,4(r2)
   14e74:	1080018b 	ldhu	r2,6(r2)
   14e78:	1004943a 	slli	r2,r2,16
   14e7c:	1104b03a 	or	r2,r2,r4
   14e80:	e13fff17 	ldw	r4,-4(fp)
   14e84:	000b883a 	mov	r5,zero
   14e88:	180d883a 	mov	r6,r3
   14e8c:	100f883a 	mov	r7,r2
   14e90:	001234c0 	call	1234c <tcp_output_alloc_header>
   14e94:	e0bffc15 	stw	r2,-16(fp)
  if(p == NULL) {
   14e98:	e0bffc17 	ldw	r2,-16(fp)
   14e9c:	10004826 	beq	r2,zero,14fc0 <tcp_zero_window_probe+0x204>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
   14ea0:	e0bffc17 	ldw	r2,-16(fp)
   14ea4:	10800117 	ldw	r2,4(r2)
   14ea8:	e0bffd15 	stw	r2,-12(fp)

  if (is_fin) {
   14eac:	e0bffb03 	ldbu	r2,-20(fp)
   14eb0:	10000926 	beq	r2,zero,14ed8 <tcp_zero_window_probe+0x11c>
    /* FIN segment, no data */
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
   14eb4:	e0bffd17 	ldw	r2,-12(fp)
   14eb8:	10c0030b 	ldhu	r3,12(r2)
   14ebc:	00b03fc4 	movi	r2,-16129
   14ec0:	1884703a 	and	r2,r3,r2
   14ec4:	10844014 	ori	r2,r2,4352
   14ec8:	1007883a 	mov	r3,r2
   14ecc:	e0bffd17 	ldw	r2,-12(fp)
   14ed0:	10c0030d 	sth	r3,12(r2)
   14ed4:	00001206 	br	14f20 <tcp_zero_window_probe+0x164>
  } else {
    /* Data segment, copy in one byte from the head of the unacked queue */
    char *d = ((char *)p->payload + TCP_HLEN);
   14ed8:	e0bffc17 	ldw	r2,-16(fp)
   14edc:	10800117 	ldw	r2,4(r2)
   14ee0:	10800504 	addi	r2,r2,20
   14ee4:	e0bffe15 	stw	r2,-8(fp)
    /* Depending on whether the segment has already been sent (unacked) or not
       (unsent), seg->p->payload points to the IP header or TCP header.
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
   14ee8:	e0bffa17 	ldw	r2,-24(fp)
   14eec:	10c00117 	ldw	r3,4(r2)
   14ef0:	e0bffa17 	ldw	r2,-24(fp)
   14ef4:	10800117 	ldw	r2,4(r2)
   14ef8:	1100020b 	ldhu	r4,8(r2)
   14efc:	e0bffa17 	ldw	r2,-24(fp)
   14f00:	1080020b 	ldhu	r2,8(r2)
   14f04:	2085c83a 	sub	r2,r4,r2
   14f08:	10bfffcc 	andi	r2,r2,65535
   14f0c:	1809883a 	mov	r4,r3
   14f10:	e17ffe17 	ldw	r5,-8(fp)
   14f14:	01800044 	movi	r6,1
   14f18:	100f883a 	mov	r7,r2
   14f1c:	000b2040 	call	b204 <pbuf_copy_partial>
  }

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
   14f20:	e0ffff17 	ldw	r3,-4(fp)
   14f24:	e0bfff17 	ldw	r2,-4(fp)
   14f28:	10800104 	addi	r2,r2,4
                                      IP_PROTO_TCP, p->tot_len);
   14f2c:	e13ffc17 	ldw	r4,-16(fp)
   14f30:	2100020b 	ldhu	r4,8(r4)
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
  }

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
   14f34:	213fffcc 	andi	r4,r4,65535
   14f38:	d9000015 	stw	r4,0(sp)
   14f3c:	e13ffc17 	ldw	r4,-16(fp)
   14f40:	180b883a 	mov	r5,r3
   14f44:	100d883a 	mov	r6,r2
   14f48:	01c00184 	movi	r7,6
   14f4c:	0005cb80 	call	5cb8 <inet_chksum_pseudo>
   14f50:	e0fffd17 	ldw	r3,-12(fp)
   14f54:	1880040d 	sth	r2,16(r3)
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
   14f58:	00800234 	movhi	r2,8
   14f5c:	1083bd04 	addi	r2,r2,3828
   14f60:	1080240b 	ldhu	r2,144(r2)
   14f64:	10800044 	addi	r2,r2,1
   14f68:	1007883a 	mov	r3,r2
   14f6c:	00800234 	movhi	r2,8
   14f70:	1083bd04 	addi	r2,r2,3828
   14f74:	10c0240d 	sth	r3,144(r2)
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
   14f78:	e17fff17 	ldw	r5,-4(fp)
   14f7c:	e0bfff17 	ldw	r2,-4(fp)
   14f80:	10c00104 	addi	r3,r2,4
   14f84:	e0bfff17 	ldw	r2,-4(fp)
   14f88:	10800283 	ldbu	r2,10(r2)
   14f8c:	10803fcc 	andi	r2,r2,255
   14f90:	d8000015 	stw	zero,0(sp)
   14f94:	01000184 	movi	r4,6
   14f98:	d9000115 	stw	r4,4(sp)
   14f9c:	e13ffc17 	ldw	r4,-16(fp)
   14fa0:	180d883a 	mov	r6,r3
   14fa4:	100f883a 	mov	r7,r2
   14fa8:	0006cbc0 	call	6cbc <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
   14fac:	e13ffc17 	ldw	r4,-16(fp)
   14fb0:	000aa340 	call	aa34 <pbuf_free>
   14fb4:	00000306 	br	14fc4 <tcp_zero_window_probe+0x208>

  if(seg == NULL) {
    seg = pcb->unsent;
  }
  if(seg == NULL) {
    return;
   14fb8:	0001883a 	nop
   14fbc:	00000106 	br	14fc4 <tcp_zero_window_probe+0x208>
  len = is_fin ? 0 : 1;

  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
   14fc0:	0001883a 	nop
  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
   14fc4:	e037883a 	mov	sp,fp
   14fc8:	dfc00117 	ldw	ra,4(sp)
   14fcc:	df000017 	ldw	fp,0(sp)
   14fd0:	dec00204 	addi	sp,sp,8
   14fd4:	f800283a 	ret

00014fd8 <tcp_timer_needed>:

#else /* LWIP_TIMERS */
/* Satisfy the TCP code which calls this function */
void
tcp_timer_needed(void)
{
   14fd8:	deffff04 	addi	sp,sp,-4
   14fdc:	df000015 	stw	fp,0(sp)
   14fe0:	d839883a 	mov	fp,sp
}
   14fe4:	e037883a 	mov	sp,fp
   14fe8:	df000017 	ldw	fp,0(sp)
   14fec:	dec00104 	addi	sp,sp,4
   14ff0:	f800283a 	ret

00014ff4 <udp_init>:
/**
 * Initialize this module.
 */
void
udp_init(void)
{
   14ff4:	deffff04 	addi	sp,sp,-4
   14ff8:	df000015 	stw	fp,0(sp)
   14ffc:	d839883a 	mov	fp,sp
#if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
  udp_port = UDP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
#endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
}
   15000:	e037883a 	mov	sp,fp
   15004:	df000017 	ldw	fp,0(sp)
   15008:	dec00104 	addi	sp,sp,4
   1500c:	f800283a 	ret

00015010 <udp_new_port>:
 *
 * @return a new (free) local UDP port number
 */
static u16_t
udp_new_port(void)
{
   15010:	defffd04 	addi	sp,sp,-12
   15014:	df000215 	stw	fp,8(sp)
   15018:	df000204 	addi	fp,sp,8
  u16_t n = 0;
   1501c:	e03ffe0d 	sth	zero,-8(fp)
   15020:	00000106 	br	15028 <udp_new_port+0x18>
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == udp_port) {
      if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
        return 0;
      }
      goto again;
   15024:	0001883a 	nop
{
  u16_t n = 0;
  struct udp_pcb *pcb;
  
again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
   15028:	d0a0080b 	ldhu	r2,-32736(gp)
   1502c:	113fffcc 	andi	r4,r2,65535
   15030:	00ffffd4 	movui	r3,65535
   15034:	20c7003a 	cmpeq	r3,r4,r3
   15038:	10800044 	addi	r2,r2,1
   1503c:	d0a0080d 	sth	r2,-32736(gp)
   15040:	18803fcc 	andi	r2,r3,255
   15044:	10000226 	beq	r2,zero,15050 <udp_new_port+0x40>
    udp_port = UDP_LOCAL_PORT_RANGE_START;
   15048:	00b00004 	movi	r2,-16384
   1504c:	d0a0080d 	sth	r2,-32736(gp)
  }
  /* Check all PCBs. */
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
   15050:	d0a8ca17 	ldw	r2,-23768(gp)
   15054:	e0bfff15 	stw	r2,-4(fp)
   15058:	00001106 	br	150a0 <udp_new_port+0x90>
    if (pcb->local_port == udp_port) {
   1505c:	e0bfff17 	ldw	r2,-4(fp)
   15060:	10c0048b 	ldhu	r3,18(r2)
   15064:	d0a0080b 	ldhu	r2,-32736(gp)
   15068:	18ffffcc 	andi	r3,r3,65535
   1506c:	10bfffcc 	andi	r2,r2,65535
   15070:	1880081e 	bne	r3,r2,15094 <udp_new_port+0x84>
      if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
   15074:	e0bffe0b 	ldhu	r2,-8(fp)
   15078:	10800044 	addi	r2,r2,1
   1507c:	e0bffe0d 	sth	r2,-8(fp)
   15080:	e0bffe0b 	ldhu	r2,-8(fp)
   15084:	10900030 	cmpltui	r2,r2,16384
   15088:	103fe61e 	bne	r2,zero,15024 <udp_new_port+0x14>
        return 0;
   1508c:	0005883a 	mov	r2,zero
   15090:	00000606 	br	150ac <udp_new_port+0x9c>
again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
    udp_port = UDP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCBs. */
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
   15094:	e0bfff17 	ldw	r2,-4(fp)
   15098:	10800317 	ldw	r2,12(r2)
   1509c:	e0bfff15 	stw	r2,-4(fp)
   150a0:	e0bfff17 	ldw	r2,-4(fp)
   150a4:	103fed1e 	bne	r2,zero,1505c <udp_new_port+0x4c>
        return 0;
      }
      goto again;
    }
  }
  return udp_port;
   150a8:	d0a0080b 	ldhu	r2,-32736(gp)
  if (ipcb != NULL) {
    return 0;
  }
  return udp_port;
#endif
}
   150ac:	e037883a 	mov	sp,fp
   150b0:	df000017 	ldw	fp,0(sp)
   150b4:	dec00104 	addi	sp,sp,4
   150b8:	f800283a 	ret

000150bc <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
   150bc:	defff304 	addi	sp,sp,-52
   150c0:	dfc00c15 	stw	ra,48(sp)
   150c4:	df000b15 	stw	fp,44(sp)
   150c8:	df000b04 	addi	fp,sp,44
   150cc:	e13ffe15 	stw	r4,-8(fp)
   150d0:	e17fff15 	stw	r5,-4(fp)
  u8_t local_match;
  u8_t broadcast;

  PERF_START;

  UDP_STATS_INC(udp.recv);
   150d4:	00800234 	movhi	r2,8
   150d8:	1083bd04 	addi	r2,r2,3828
   150dc:	10801e8b 	ldhu	r2,122(r2)
   150e0:	10800044 	addi	r2,r2,1
   150e4:	1007883a 	mov	r3,r2
   150e8:	00800234 	movhi	r2,8
   150ec:	1083bd04 	addi	r2,r2,3828
   150f0:	10c01e8d 	sth	r3,122(r2)

  iphdr = (struct ip_hdr *)p->payload;
   150f4:	e0bffe17 	ldw	r2,-8(fp)
   150f8:	10800117 	ldw	r2,4(r2)
   150fc:	e0bffa15 	stw	r2,-24(fp)

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
   15100:	e0bffe17 	ldw	r2,-8(fp)
   15104:	1080020b 	ldhu	r2,8(r2)
   15108:	10ffffcc 	andi	r3,r2,65535
   1510c:	e0bffa17 	ldw	r2,-24(fp)
   15110:	10800003 	ldbu	r2,0(r2)
   15114:	10803fcc 	andi	r2,r2,255
   15118:	108003cc 	andi	r2,r2,15
   1511c:	10800084 	addi	r2,r2,2
   15120:	1085883a 	add	r2,r2,r2
   15124:	1085883a 	add	r2,r2,r2
   15128:	18800f16 	blt	r3,r2,15168 <udp_input+0xac>
   1512c:	e0bffa17 	ldw	r2,-24(fp)
   15130:	10800003 	ldbu	r2,0(r2)
   15134:	10803fcc 	andi	r2,r2,255
   15138:	108003cc 	andi	r2,r2,15
   1513c:	1085883a 	add	r2,r2,r2
   15140:	1085883a 	add	r2,r2,r2
   15144:	0085c83a 	sub	r2,zero,r2
   15148:	10bfffcc 	andi	r2,r2,65535
   1514c:	10a0001c 	xori	r2,r2,32768
   15150:	10a00004 	addi	r2,r2,-32768
   15154:	e13ffe17 	ldw	r4,-8(fp)
   15158:	100b883a 	mov	r5,r2
   1515c:	000a83c0 	call	a83c <pbuf_header>
   15160:	10803fcc 	andi	r2,r2,255
   15164:	10001326 	beq	r2,zero,151b4 <udp_input+0xf8>
    /* drop short packets */
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
   15168:	00800234 	movhi	r2,8
   1516c:	1083bd04 	addi	r2,r2,3828
   15170:	1080208b 	ldhu	r2,130(r2)
   15174:	10800044 	addi	r2,r2,1
   15178:	1007883a 	mov	r3,r2
   1517c:	00800234 	movhi	r2,8
   15180:	1083bd04 	addi	r2,r2,3828
   15184:	10c0208d 	sth	r3,130(r2)
    UDP_STATS_INC(udp.drop);
   15188:	00800234 	movhi	r2,8
   1518c:	1083bd04 	addi	r2,r2,3828
   15190:	10801f8b 	ldhu	r2,126(r2)
   15194:	10800044 	addi	r2,r2,1
   15198:	1007883a 	mov	r3,r2
   1519c:	00800234 	movhi	r2,8
   151a0:	1083bd04 	addi	r2,r2,3828
   151a4:	10c01f8d 	sth	r3,126(r2)
    snmp_inc_udpinerrors();
    pbuf_free(p);
   151a8:	e13ffe17 	ldw	r4,-8(fp)
   151ac:	000aa340 	call	aa34 <pbuf_free>
    goto end;
   151b0:	00013606 	br	1568c <udp_input+0x5d0>
  }

  udphdr = (struct udp_hdr *)p->payload;
   151b4:	e0bffe17 	ldw	r2,-8(fp)
   151b8:	10800117 	ldw	r2,4(r2)
   151bc:	e0bffb15 	stw	r2,-20(fp)

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
   151c0:	008000f4 	movhi	r2,3
   151c4:	109e2104 	addi	r2,r2,30852
   151c8:	10800017 	ldw	r2,0(r2)
   151cc:	1009883a 	mov	r4,r2
   151d0:	e17fff17 	ldw	r5,-4(fp)
   151d4:	0006da80 	call	6da8 <ip4_addr_isbroadcast>
   151d8:	e0bffc05 	stb	r2,-16(fp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
   151dc:	e0bffb17 	ldw	r2,-20(fp)
   151e0:	1080000b 	ldhu	r2,0(r2)
   151e4:	10bfffcc 	andi	r2,r2,65535
   151e8:	1004d23a 	srli	r2,r2,8
   151ec:	1007883a 	mov	r3,r2
   151f0:	e0bffb17 	ldw	r2,-20(fp)
   151f4:	1080000b 	ldhu	r2,0(r2)
   151f8:	10bfffcc 	andi	r2,r2,65535
   151fc:	1004923a 	slli	r2,r2,8
   15200:	1884b03a 	or	r2,r3,r2
   15204:	e0bffc8d 	sth	r2,-14(fp)
  dest = ntohs(udphdr->dest);
   15208:	e0bffb17 	ldw	r2,-20(fp)
   1520c:	1080008b 	ldhu	r2,2(r2)
   15210:	10bfffcc 	andi	r2,r2,65535
   15214:	1004d23a 	srli	r2,r2,8
   15218:	1007883a 	mov	r3,r2
   1521c:	e0bffb17 	ldw	r2,-20(fp)
   15220:	1080008b 	ldhu	r2,2(r2)
   15224:	10bfffcc 	andi	r2,r2,65535
   15228:	1004923a 	slli	r2,r2,8
   1522c:	1884b03a 	or	r2,r3,r2
   15230:	e0bffd0d 	sth	r2,-12(fp)
               ip4_addr3_16(&iphdr->dest), ip4_addr4_16(&iphdr->dest), ntohs(udphdr->dest),
               ip4_addr1_16(&iphdr->src), ip4_addr2_16(&iphdr->src),
               ip4_addr3_16(&iphdr->src), ip4_addr4_16(&iphdr->src), ntohs(udphdr->src)));

#if LWIP_DHCP
  pcb = NULL;
   15234:	e03ff615 	stw	zero,-40(fp)
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
   15238:	e0bffd0b 	ldhu	r2,-12(fp)
   1523c:	10801118 	cmpnei	r2,r2,68
   15240:	1000211e 	bne	r2,zero,152c8 <udp_input+0x20c>
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
   15244:	e0bffc8b 	ldhu	r2,-14(fp)
   15248:	108010d8 	cmpnei	r2,r2,67
   1524c:	1000861e 	bne	r2,zero,15468 <udp_input+0x3ac>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
   15250:	e0bfff17 	ldw	r2,-4(fp)
   15254:	10800817 	ldw	r2,32(r2)
   15258:	10008326 	beq	r2,zero,15468 <udp_input+0x3ac>
   1525c:	e0bfff17 	ldw	r2,-4(fp)
   15260:	10800817 	ldw	r2,32(r2)
   15264:	10800117 	ldw	r2,4(r2)
   15268:	10007f26 	beq	r2,zero,15468 <udp_input+0x3ac>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
   1526c:	e0bfff17 	ldw	r2,-4(fp)
   15270:	10800817 	ldw	r2,32(r2)
   15274:	10800117 	ldw	r2,4(r2)
   15278:	10800104 	addi	r2,r2,4
   1527c:	10000d26 	beq	r2,zero,152b4 <udp_input+0x1f8>
   15280:	e0bfff17 	ldw	r2,-4(fp)
   15284:	10800817 	ldw	r2,32(r2)
   15288:	10800117 	ldw	r2,4(r2)
   1528c:	10800117 	ldw	r2,4(r2)
   15290:	10000826 	beq	r2,zero,152b4 <udp_input+0x1f8>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &current_iphdr_src))) {
   15294:	e0bfff17 	ldw	r2,-4(fp)
   15298:	10800817 	ldw	r2,32(r2)
   1529c:	10800117 	ldw	r2,4(r2)
   152a0:	10c00117 	ldw	r3,4(r2)
   152a4:	008000f4 	movhi	r2,3
   152a8:	109e1f04 	addi	r2,r2,30844
   152ac:	10800017 	ldw	r2,0(r2)
    if (src == DHCP_SERVER_PORT) {
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
   152b0:	18806d1e 	bne	r3,r2,15468 <udp_input+0x3ac>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &current_iphdr_src))) {
          pcb = inp->dhcp->pcb;
   152b4:	e0bfff17 	ldw	r2,-4(fp)
   152b8:	10800817 	ldw	r2,32(r2)
   152bc:	10800117 	ldw	r2,4(r2)
   152c0:	e0bff615 	stw	r2,-40(fp)
   152c4:	00006806 	br	15468 <udp_input+0x3ac>
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
   152c8:	e03ff715 	stw	zero,-36(fp)
    local_match = 0;
   152cc:	e03ff905 	stb	zero,-28(fp)
    uncon_pcb = NULL;
   152d0:	e03ff815 	stw	zero,-32(fp)
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
   152d4:	d0a8ca17 	ldw	r2,-23768(gp)
   152d8:	e0bff615 	stw	r2,-40(fp)
   152dc:	00005c06 	br	15450 <udp_input+0x394>
      local_match = 0;
   152e0:	e03ff905 	stb	zero,-28(fp)
                   ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip), pcb->local_port,
                   ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                   ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if (pcb->local_port == dest) {
   152e4:	e0bff617 	ldw	r2,-40(fp)
   152e8:	1080048b 	ldhu	r2,18(r2)
   152ec:	10ffffcc 	andi	r3,r2,65535
   152f0:	e0bffd0b 	ldhu	r2,-12(fp)
   152f4:	1880291e 	bne	r3,r2,1539c <udp_input+0x2e0>
        if (
   152f8:	e0bffc03 	ldbu	r2,-16(fp)
   152fc:	1000051e 	bne	r2,zero,15314 <udp_input+0x258>
           (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
   15300:	e0bff617 	ldw	r2,-40(fp)
   15304:	10001a26 	beq	r2,zero,15370 <udp_input+0x2b4>
   15308:	e0bff617 	ldw	r2,-40(fp)
   1530c:	10800017 	ldw	r2,0(r2)
   15310:	10001726 	beq	r2,zero,15370 <udp_input+0x2b4>
           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest) ||
   15314:	e0bff617 	ldw	r2,-40(fp)
   15318:	10c00017 	ldw	r3,0(r2)
   1531c:	008000f4 	movhi	r2,3
   15320:	109e2104 	addi	r2,r2,30852
   15324:	10800017 	ldw	r2,0(r2)
                   ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if (pcb->local_port == dest) {
        if (
           (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
   15328:	18801126 	beq	r3,r2,15370 <udp_input+0x2b4>
           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest) ||
   1532c:	e0bffc03 	ldbu	r2,-16(fp)
   15330:	10001a26 	beq	r2,zero,1539c <udp_input+0x2e0>
            (broadcast && ip_get_option(pcb, SOF_BROADCAST) &&
             (ip_addr_isany(&pcb->local_ip) ||
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#else /* IP_SOF_BROADCAST_RECV */
            (broadcast &&
             (ip_addr_isany(&pcb->local_ip) ||
   15334:	e0bff617 	ldw	r2,-40(fp)
#if IP_SOF_BROADCAST_RECV
            (broadcast && ip_get_option(pcb, SOF_BROADCAST) &&
             (ip_addr_isany(&pcb->local_ip) ||
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#else /* IP_SOF_BROADCAST_RECV */
            (broadcast &&
   15338:	10000d26 	beq	r2,zero,15370 <udp_input+0x2b4>
             (ip_addr_isany(&pcb->local_ip) ||
   1533c:	e0bff617 	ldw	r2,-40(fp)
   15340:	10800017 	ldw	r2,0(r2)
   15344:	10000a26 	beq	r2,zero,15370 <udp_input+0x2b4>
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
   15348:	e0bff617 	ldw	r2,-40(fp)
   1534c:	10c00017 	ldw	r3,0(r2)
   15350:	008000f4 	movhi	r2,3
   15354:	109e2104 	addi	r2,r2,30852
   15358:	10800017 	ldw	r2,0(r2)
   1535c:	1886f03a 	xor	r3,r3,r2
   15360:	e0bfff17 	ldw	r2,-4(fp)
   15364:	10800217 	ldw	r2,8(r2)
   15368:	1884703a 	and	r2,r3,r2
            (broadcast && ip_get_option(pcb, SOF_BROADCAST) &&
             (ip_addr_isany(&pcb->local_ip) ||
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#else /* IP_SOF_BROADCAST_RECV */
            (broadcast &&
             (ip_addr_isany(&pcb->local_ip) ||
   1536c:	10000b1e 	bne	r2,zero,1539c <udp_input+0x2e0>
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#endif /* IP_SOF_BROADCAST_RECV */ 
          local_match = 1;
   15370:	00800044 	movi	r2,1
   15374:	e0bff905 	stb	r2,-28(fp)
          if ((uncon_pcb == NULL) && 
   15378:	e0bff817 	ldw	r2,-32(fp)
   1537c:	1000071e 	bne	r2,zero,1539c <udp_input+0x2e0>
              ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
   15380:	e0bff617 	ldw	r2,-40(fp)
   15384:	10800403 	ldbu	r2,16(r2)
   15388:	10803fcc 	andi	r2,r2,255
   1538c:	1080010c 	andi	r2,r2,4
            (broadcast &&
             (ip_addr_isany(&pcb->local_ip) ||
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#endif /* IP_SOF_BROADCAST_RECV */ 
          local_match = 1;
          if ((uncon_pcb == NULL) && 
   15390:	1000021e 	bne	r2,zero,1539c <udp_input+0x2e0>
              ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
            /* the first unconnected matching PCB */
            uncon_pcb = pcb;
   15394:	e0bff617 	ldw	r2,-40(fp)
   15398:	e0bff815 	stw	r2,-32(fp)
          }
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
   1539c:	e0bff903 	ldbu	r2,-28(fp)
   153a0:	10002626 	beq	r2,zero,1543c <udp_input+0x380>
          (pcb->remote_port == src) &&
   153a4:	e0bff617 	ldw	r2,-40(fp)
   153a8:	1080050b 	ldhu	r2,20(r2)
            uncon_pcb = pcb;
          }
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
   153ac:	10ffffcc 	andi	r3,r2,65535
   153b0:	e0bffc8b 	ldhu	r2,-14(fp)
   153b4:	1880211e 	bne	r3,r2,1543c <udp_input+0x380>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
   153b8:	e0bff617 	ldw	r2,-40(fp)
   153bc:	10800104 	addi	r2,r2,4
          }
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
   153c0:	10000926 	beq	r2,zero,153e8 <udp_input+0x32c>
          (ip_addr_isany(&pcb->remote_ip) ||
   153c4:	e0bff617 	ldw	r2,-40(fp)
   153c8:	10800117 	ldw	r2,4(r2)
   153cc:	10000626 	beq	r2,zero,153e8 <udp_input+0x32c>
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
   153d0:	e0bff617 	ldw	r2,-40(fp)
   153d4:	10c00117 	ldw	r3,4(r2)
   153d8:	008000f4 	movhi	r2,3
   153dc:	109e1f04 	addi	r2,r2,30844
   153e0:	10800017 	ldw	r2,0(r2)
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
   153e4:	1880151e 	bne	r3,r2,1543c <udp_input+0x380>
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
   153e8:	e0bff717 	ldw	r2,-36(fp)
   153ec:	10000a26 	beq	r2,zero,15418 <udp_input+0x35c>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
   153f0:	e0bff617 	ldw	r2,-40(fp)
   153f4:	10c00317 	ldw	r3,12(r2)
   153f8:	e0bff717 	ldw	r2,-36(fp)
   153fc:	10c00315 	stw	r3,12(r2)
          pcb->next = udp_pcbs;
   15400:	d0e8ca17 	ldw	r3,-23768(gp)
   15404:	e0bff617 	ldw	r2,-40(fp)
   15408:	10c00315 	stw	r3,12(r2)
          udp_pcbs = pcb;
   1540c:	e0bff617 	ldw	r2,-40(fp)
   15410:	d0a8ca15 	stw	r2,-23768(gp)
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
   15414:	00001006 	br	15458 <udp_input+0x39c>
             found faster next time */
          prev->next = pcb->next;
          pcb->next = udp_pcbs;
          udp_pcbs = pcb;
        } else {
          UDP_STATS_INC(udp.cachehit);
   15418:	00800234 	movhi	r2,8
   1541c:	1083bd04 	addi	r2,r2,3828
   15420:	1080238b 	ldhu	r2,142(r2)
   15424:	10800044 	addi	r2,r2,1
   15428:	1007883a 	mov	r3,r2
   1542c:	00800234 	movhi	r2,8
   15430:	1083bd04 	addi	r2,r2,3828
   15434:	10c0238d 	sth	r3,142(r2)
        }
        break;
   15438:	00000706 	br	15458 <udp_input+0x39c>
      }
      prev = pcb;
   1543c:	e0bff617 	ldw	r2,-40(fp)
   15440:	e0bff715 	stw	r2,-36(fp)
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
   15444:	e0bff617 	ldw	r2,-40(fp)
   15448:	10800317 	ldw	r2,12(r2)
   1544c:	e0bff615 	stw	r2,-40(fp)
   15450:	e0bff617 	ldw	r2,-40(fp)
   15454:	103fa21e 	bne	r2,zero,152e0 <udp_input+0x224>
        break;
      }
      prev = pcb;
    }
    /* no fully matching pcb found? then look for an unconnected pcb */
    if (pcb == NULL) {
   15458:	e0bff617 	ldw	r2,-40(fp)
   1545c:	1000021e 	bne	r2,zero,15468 <udp_input+0x3ac>
      pcb = uncon_pcb;
   15460:	e0bff817 	ldw	r2,-32(fp)
   15464:	e0bff615 	stw	r2,-40(fp)
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
   15468:	e0bff617 	ldw	r2,-40(fp)
   1546c:	1000061e 	bne	r2,zero,15488 <udp_input+0x3cc>
   15470:	e0bfff17 	ldw	r2,-4(fp)
   15474:	10c00117 	ldw	r3,4(r2)
   15478:	008000f4 	movhi	r2,3
   1547c:	109e2104 	addi	r2,r2,30852
   15480:	10800017 	ldw	r2,0(r2)
   15484:	18807f1e 	bne	r3,r2,15684 <udp_input+0x5c8>
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
   15488:	e0bffb17 	ldw	r2,-20(fp)
   1548c:	1080018b 	ldhu	r2,6(r2)
   15490:	10bfffcc 	andi	r2,r2,65535
   15494:	10002026 	beq	r2,zero,15518 <udp_input+0x45c>
        if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
                               IP_PROTO_UDP, p->tot_len) != 0) {
   15498:	e0bffe17 	ldw	r2,-8(fp)
   1549c:	1080020b 	ldhu	r2,8(r2)
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
        if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
   154a0:	10bfffcc 	andi	r2,r2,65535
   154a4:	d8800015 	stw	r2,0(sp)
   154a8:	e13ffe17 	ldw	r4,-8(fp)
   154ac:	014000f4 	movhi	r5,3
   154b0:	295e1f04 	addi	r5,r5,30844
   154b4:	018000f4 	movhi	r6,3
   154b8:	319e2104 	addi	r6,r6,30852
   154bc:	01c00444 	movi	r7,17
   154c0:	0005cb80 	call	5cb8 <inet_chksum_pseudo>
   154c4:	10bfffcc 	andi	r2,r2,65535
   154c8:	10001326 	beq	r2,zero,15518 <udp_input+0x45c>
                               IP_PROTO_UDP, p->tot_len) != 0) {
          LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
   154cc:	00800234 	movhi	r2,8
   154d0:	1083bd04 	addi	r2,r2,3828
   154d4:	1080200b 	ldhu	r2,128(r2)
   154d8:	10800044 	addi	r2,r2,1
   154dc:	1007883a 	mov	r3,r2
   154e0:	00800234 	movhi	r2,8
   154e4:	1083bd04 	addi	r2,r2,3828
   154e8:	10c0200d 	sth	r3,128(r2)
          UDP_STATS_INC(udp.drop);
   154ec:	00800234 	movhi	r2,8
   154f0:	1083bd04 	addi	r2,r2,3828
   154f4:	10801f8b 	ldhu	r2,126(r2)
   154f8:	10800044 	addi	r2,r2,1
   154fc:	1007883a 	mov	r3,r2
   15500:	00800234 	movhi	r2,8
   15504:	1083bd04 	addi	r2,r2,3828
   15508:	10c01f8d 	sth	r3,126(r2)
          snmp_inc_udpinerrors();
          pbuf_free(p);
   1550c:	e13ffe17 	ldw	r4,-8(fp)
   15510:	000aa340 	call	aa34 <pbuf_free>
          goto end;
   15514:	00005d06 	br	1568c <udp_input+0x5d0>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
   15518:	e13ffe17 	ldw	r4,-8(fp)
   1551c:	017ffe04 	movi	r5,-8
   15520:	000a83c0 	call	a83c <pbuf_header>
   15524:	10803fcc 	andi	r2,r2,255
   15528:	10000926 	beq	r2,zero,15550 <udp_input+0x494>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
   1552c:	010000f4 	movhi	r4,3
   15530:	2103a604 	addi	r4,r4,3736
   15534:	014000f4 	movhi	r5,3
   15538:	2943b004 	addi	r5,r5,3776
   1553c:	01805604 	movi	r6,344
   15540:	01c000f4 	movhi	r7,3
   15544:	39c3b504 	addi	r7,r7,3796
   15548:	00193f00 	call	193f0 <printf>
   1554c:	003fff06 	br	1554c <udp_input+0x490>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
   15550:	e0bff617 	ldw	r2,-40(fp)
   15554:	10001326 	beq	r2,zero,155a4 <udp_input+0x4e8>
          pbuf_header(p, -(s16_t)((IPH_HL(iphdr) * 4) + UDP_HLEN));
        }
      }
#endif /* SO_REUSE && SO_REUSE_RXTOALL */
      /* callback */
      if (pcb->recv != NULL) {
   15558:	e0bff617 	ldw	r2,-40(fp)
   1555c:	10800617 	ldw	r2,24(r2)
   15560:	10000d26 	beq	r2,zero,15598 <udp_input+0x4dc>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
   15564:	e0bff617 	ldw	r2,-40(fp)
   15568:	10c00617 	ldw	r3,24(r2)
   1556c:	e0bff617 	ldw	r2,-40(fp)
   15570:	10800717 	ldw	r2,28(r2)
   15574:	e13ffc8b 	ldhu	r4,-14(fp)
   15578:	d9000015 	stw	r4,0(sp)
   1557c:	1009883a 	mov	r4,r2
   15580:	e17ff617 	ldw	r5,-40(fp)
   15584:	e1bffe17 	ldw	r6,-8(fp)
   15588:	01c000f4 	movhi	r7,3
   1558c:	39de1f04 	addi	r7,r7,30844
   15590:	183ee83a 	callr	r3
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
   15594:	00003d06 	br	1568c <udp_input+0x5d0>
      if (pcb->recv != NULL) {
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
   15598:	e13ffe17 	ldw	r4,-8(fp)
   1559c:	000aa340 	call	aa34 <pbuf_free>
        goto end;
   155a0:	00003a06 	br	1568c <udp_input+0x5d0>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!broadcast &&
   155a4:	e0bffc03 	ldbu	r2,-16(fp)
   155a8:	1000231e 	bne	r2,zero,15638 <udp_input+0x57c>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
   155ac:	008000f4 	movhi	r2,3
   155b0:	109e2104 	addi	r2,r2,30852
   155b4:	10800017 	ldw	r2,0(r2)
   155b8:	10803c0c 	andi	r2,r2,240
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!broadcast &&
   155bc:	10803820 	cmpeqi	r2,r2,224
   155c0:	10001d1e 	bne	r2,zero,15638 <udp_input+0x57c>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
   155c4:	e0bffa17 	ldw	r2,-24(fp)
   155c8:	10800003 	ldbu	r2,0(r2)
   155cc:	10803fcc 	andi	r2,r2,255
   155d0:	108003cc 	andi	r2,r2,15
   155d4:	10800084 	addi	r2,r2,2
   155d8:	1085883a 	add	r2,r2,r2
   155dc:	1085883a 	add	r2,r2,r2
   155e0:	10bfffcc 	andi	r2,r2,65535
   155e4:	10a0001c 	xori	r2,r2,32768
   155e8:	10a00004 	addi	r2,r2,-32768
   155ec:	e13ffe17 	ldw	r4,-8(fp)
   155f0:	100b883a 	mov	r5,r2
   155f4:	000a83c0 	call	a83c <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
   155f8:	e0bffe17 	ldw	r2,-8(fp)
   155fc:	10c00117 	ldw	r3,4(r2)
   15600:	e0bffa17 	ldw	r2,-24(fp)
   15604:	18800926 	beq	r3,r2,1562c <udp_input+0x570>
   15608:	010000f4 	movhi	r4,3
   1560c:	2103a604 	addi	r4,r4,3736
   15610:	014000f4 	movhi	r5,3
   15614:	2943ba04 	addi	r5,r5,3816
   15618:	018068c4 	movi	r6,419
   1561c:	01c000f4 	movhi	r7,3
   15620:	39c3b504 	addi	r7,r7,3796
   15624:	00193f00 	call	193f0 <printf>
   15628:	003fff06 	br	15628 <udp_input+0x56c>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
   1562c:	e13ffe17 	ldw	r4,-8(fp)
   15630:	014000c4 	movi	r5,3
   15634:	00059680 	call	5968 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
   15638:	00800234 	movhi	r2,8
   1563c:	1083bd04 	addi	r2,r2,3828
   15640:	1080220b 	ldhu	r2,136(r2)
   15644:	10800044 	addi	r2,r2,1
   15648:	1007883a 	mov	r3,r2
   1564c:	00800234 	movhi	r2,8
   15650:	1083bd04 	addi	r2,r2,3828
   15654:	10c0220d 	sth	r3,136(r2)
      UDP_STATS_INC(udp.drop);
   15658:	00800234 	movhi	r2,8
   1565c:	1083bd04 	addi	r2,r2,3828
   15660:	10801f8b 	ldhu	r2,126(r2)
   15664:	10800044 	addi	r2,r2,1
   15668:	1007883a 	mov	r3,r2
   1566c:	00800234 	movhi	r2,8
   15670:	1083bd04 	addi	r2,r2,3828
   15674:	10c01f8d 	sth	r3,126(r2)
      snmp_inc_udpnoports();
      pbuf_free(p);
   15678:	e13ffe17 	ldw	r4,-8(fp)
   1567c:	000aa340 	call	aa34 <pbuf_free>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
   15680:	00000206 	br	1568c <udp_input+0x5d0>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
    }
  } else {
    pbuf_free(p);
   15684:	e13ffe17 	ldw	r4,-8(fp)
   15688:	000aa340 	call	aa34 <pbuf_free>
  }
end:
  PERF_STOP("udp_input");
}
   1568c:	e037883a 	mov	sp,fp
   15690:	dfc00117 	ldw	ra,4(sp)
   15694:	df000017 	ldw	fp,0(sp)
   15698:	dec00204 	addi	sp,sp,8
   1569c:	f800283a 	ret

000156a0 <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
   156a0:	defffc04 	addi	sp,sp,-16
   156a4:	dfc00315 	stw	ra,12(sp)
   156a8:	df000215 	stw	fp,8(sp)
   156ac:	df000204 	addi	fp,sp,8
   156b0:	e13ffe15 	stw	r4,-8(fp)
   156b4:	e17fff15 	stw	r5,-4(fp)
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
   156b8:	e0bffe17 	ldw	r2,-8(fp)
   156bc:	10c00104 	addi	r3,r2,4
   156c0:	e0bffe17 	ldw	r2,-8(fp)
   156c4:	1080050b 	ldhu	r2,20(r2)
   156c8:	10bfffcc 	andi	r2,r2,65535
   156cc:	e13ffe17 	ldw	r4,-8(fp)
   156d0:	e17fff17 	ldw	r5,-4(fp)
   156d4:	180d883a 	mov	r6,r3
   156d8:	100f883a 	mov	r7,r2
   156dc:	00156f40 	call	156f4 <udp_sendto>
}
   156e0:	e037883a 	mov	sp,fp
   156e4:	dfc00117 	ldw	ra,4(sp)
   156e8:	df000017 	ldw	fp,0(sp)
   156ec:	dec00204 	addi	sp,sp,8
   156f0:	f800283a 	ret

000156f4 <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  ip_addr_t *dst_ip, u16_t dst_port)
{
   156f4:	defff804 	addi	sp,sp,-32
   156f8:	dfc00715 	stw	ra,28(sp)
   156fc:	df000615 	stw	fp,24(sp)
   15700:	df000604 	addi	fp,sp,24
   15704:	e13ffc15 	stw	r4,-16(fp)
   15708:	e17ffd15 	stw	r5,-12(fp)
   1570c:	e1bffe15 	stw	r6,-8(fp)
   15710:	3805883a 	mov	r2,r7
   15714:	e0bfff0d 	sth	r2,-4(fp)

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
   15718:	e13ffe17 	ldw	r4,-8(fp)
   1571c:	00062600 	call	6260 <ip_route>
   15720:	e0bffb15 	stw	r2,-20(fp)
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
   15724:	e0bffb17 	ldw	r2,-20(fp)
   15728:	10000a1e 	bne	r2,zero,15754 <udp_sendto+0x60>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dst_ip), ip4_addr2_16(dst_ip), ip4_addr3_16(dst_ip), ip4_addr4_16(dst_ip)));
    UDP_STATS_INC(udp.rterr);
   1572c:	00800234 	movhi	r2,8
   15730:	1083bd04 	addi	r2,r2,3828
   15734:	1080218b 	ldhu	r2,134(r2)
   15738:	10800044 	addi	r2,r2,1
   1573c:	1007883a 	mov	r3,r2
   15740:	00800234 	movhi	r2,8
   15744:	1083bd04 	addi	r2,r2,3828
   15748:	10c0218d 	sth	r3,134(r2)
    return ERR_RTE;
   1574c:	00bfff04 	movi	r2,-4
   15750:	00000806 	br	15774 <udp_sendto+0x80>
  }
#if LWIP_CHECKSUM_ON_COPY
  return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum);
#else /* LWIP_CHECKSUM_ON_COPY */
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
   15754:	e0bfff0b 	ldhu	r2,-4(fp)
   15758:	e0fffb17 	ldw	r3,-20(fp)
   1575c:	d8c00015 	stw	r3,0(sp)
   15760:	e13ffc17 	ldw	r4,-16(fp)
   15764:	e17ffd17 	ldw	r5,-12(fp)
   15768:	e1bffe17 	ldw	r6,-8(fp)
   1576c:	100f883a 	mov	r7,r2
   15770:	00157880 	call	15788 <udp_sendto_if>
#endif /* LWIP_CHECKSUM_ON_COPY */
}
   15774:	e037883a 	mov	sp,fp
   15778:	dfc00117 	ldw	ra,4(sp)
   1577c:	df000017 	ldw	fp,0(sp)
   15780:	dec00204 	addi	sp,sp,8
   15784:	f800283a 	ret

00015788 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif)
{
   15788:	defff304 	addi	sp,sp,-52
   1578c:	dfc00c15 	stw	ra,48(sp)
   15790:	df000b15 	stw	fp,44(sp)
   15794:	df000b04 	addi	fp,sp,44
   15798:	e13ffc15 	stw	r4,-16(fp)
   1579c:	e17ffd15 	stw	r5,-12(fp)
   157a0:	e1bffe15 	stw	r6,-8(fp)
   157a4:	3805883a 	mov	r2,r7
   157a8:	e0bfff0d 	sth	r2,-4(fp)
    return ERR_VAL;
  }
#endif /* IP_SOF_BROADCAST */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
   157ac:	e0bffc17 	ldw	r2,-16(fp)
   157b0:	1080048b 	ldhu	r2,18(r2)
   157b4:	10bfffcc 	andi	r2,r2,65535
   157b8:	10000d1e 	bne	r2,zero,157f0 <udp_sendto_if+0x68>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
   157bc:	e0fffc17 	ldw	r3,-16(fp)
   157c0:	e0bffc17 	ldw	r2,-16(fp)
   157c4:	1080048b 	ldhu	r2,18(r2)
   157c8:	10bfffcc 	andi	r2,r2,65535
   157cc:	e13ffc17 	ldw	r4,-16(fp)
   157d0:	180b883a 	mov	r5,r3
   157d4:	100d883a 	mov	r6,r2
   157d8:	0015a740 	call	15a74 <udp_bind>
   157dc:	e0bffa85 	stb	r2,-22(fp)
    if (err != ERR_OK) {
   157e0:	e0bffa87 	ldb	r2,-22(fp)
   157e4:	10000226 	beq	r2,zero,157f0 <udp_sendto_if+0x68>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind failed\n"));
      return err;
   157e8:	e0bffa83 	ldbu	r2,-22(fp)
   157ec:	00009c06 	br	15a60 <udp_sendto_if+0x2d8>
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
   157f0:	e13ffd17 	ldw	r4,-12(fp)
   157f4:	01400204 	movi	r5,8
   157f8:	000a83c0 	call	a83c <pbuf_header>
   157fc:	10803fcc 	andi	r2,r2,255
   15800:	10001126 	beq	r2,zero,15848 <udp_sendto_if+0xc0>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
   15804:	01000044 	movi	r4,1
   15808:	01400204 	movi	r5,8
   1580c:	000d883a 	mov	r6,zero
   15810:	000a0740 	call	a074 <pbuf_alloc>
   15814:	e0bff915 	stw	r2,-28(fp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
   15818:	e0bff917 	ldw	r2,-28(fp)
   1581c:	1000021e 	bne	r2,zero,15828 <udp_sendto_if+0xa0>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
   15820:	00bfffc4 	movi	r2,-1
   15824:	00008e06 	br	15a60 <udp_sendto_if+0x2d8>
    }
    if (p->tot_len != 0) {
   15828:	e0bffd17 	ldw	r2,-12(fp)
   1582c:	1080020b 	ldhu	r2,8(r2)
   15830:	10bfffcc 	andi	r2,r2,65535
   15834:	10000626 	beq	r2,zero,15850 <udp_sendto_if+0xc8>
      /* chain header q in front of given pbuf p (only if p contains data) */
      pbuf_chain(q, p);
   15838:	e13ff917 	ldw	r4,-28(fp)
   1583c:	e17ffd17 	ldw	r5,-12(fp)
   15840:	000adcc0 	call	adcc <pbuf_chain>
   15844:	00000206 	br	15850 <udp_sendto_if+0xc8>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
   15848:	e0bffd17 	ldw	r2,-12(fp)
   1584c:	e0bff915 	stw	r2,-28(fp)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
   15850:	e0bff917 	ldw	r2,-28(fp)
   15854:	1080028b 	ldhu	r2,10(r2)
   15858:	10bfffcc 	andi	r2,r2,65535
   1585c:	10800228 	cmpgeui	r2,r2,8
   15860:	1000091e 	bne	r2,zero,15888 <udp_sendto_if+0x100>
   15864:	010000f4 	movhi	r4,3
   15868:	2103a604 	addi	r4,r4,3736
   1586c:	014000f4 	movhi	r5,3
   15870:	2943bf04 	addi	r5,r5,3836
   15874:	01809884 	movi	r6,610
   15878:	01c000f4 	movhi	r7,3
   1587c:	39c3b504 	addi	r7,r7,3796
   15880:	00193f00 	call	193f0 <printf>
   15884:	003fff06 	br	15884 <udp_sendto_if+0xfc>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = (struct udp_hdr *)q->payload;
   15888:	e0bff917 	ldw	r2,-28(fp)
   1588c:	10800117 	ldw	r2,4(r2)
   15890:	e0bffb15 	stw	r2,-20(fp)
  udphdr->src = htons(pcb->local_port);
   15894:	e0bffc17 	ldw	r2,-16(fp)
   15898:	1080048b 	ldhu	r2,18(r2)
   1589c:	10bfffcc 	andi	r2,r2,65535
   158a0:	1004d23a 	srli	r2,r2,8
   158a4:	1007883a 	mov	r3,r2
   158a8:	e0bffc17 	ldw	r2,-16(fp)
   158ac:	1080048b 	ldhu	r2,18(r2)
   158b0:	10bfffcc 	andi	r2,r2,65535
   158b4:	1004923a 	slli	r2,r2,8
   158b8:	1884b03a 	or	r2,r3,r2
   158bc:	1007883a 	mov	r3,r2
   158c0:	e0bffb17 	ldw	r2,-20(fp)
   158c4:	10c0000d 	sth	r3,0(r2)
  udphdr->dest = htons(dst_port);
   158c8:	e0bfff0b 	ldhu	r2,-4(fp)
   158cc:	1004d23a 	srli	r2,r2,8
   158d0:	1007883a 	mov	r3,r2
   158d4:	e0bfff0b 	ldhu	r2,-4(fp)
   158d8:	1004923a 	slli	r2,r2,8
   158dc:	1884b03a 	or	r2,r3,r2
   158e0:	1007883a 	mov	r3,r2
   158e4:	e0bffb17 	ldw	r2,-20(fp)
   158e8:	10c0008d 	sth	r3,2(r2)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
   158ec:	e0bffb17 	ldw	r2,-20(fp)
   158f0:	1000018d 	sth	zero,6(r2)
  }
#endif /* LWIP_IGMP */


  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
   158f4:	e0bffc17 	ldw	r2,-16(fp)
   158f8:	10000326 	beq	r2,zero,15908 <udp_sendto_if+0x180>
   158fc:	e0bffc17 	ldw	r2,-16(fp)
   15900:	10800017 	ldw	r2,0(r2)
   15904:	1000041e 	bne	r2,zero,15918 <udp_sendto_if+0x190>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
   15908:	e0800217 	ldw	r2,8(fp)
   1590c:	10800104 	addi	r2,r2,4
   15910:	e0bff815 	stw	r2,-32(fp)
   15914:	00000f06 	br	15954 <udp_sendto_if+0x1cc>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
   15918:	e0bffc17 	ldw	r2,-16(fp)
   1591c:	10c00017 	ldw	r3,0(r2)
   15920:	e0800217 	ldw	r2,8(fp)
   15924:	10800117 	ldw	r2,4(r2)
   15928:	18800826 	beq	r3,r2,1594c <udp_sendto_if+0x1c4>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
   1592c:	e0fff917 	ldw	r3,-28(fp)
   15930:	e0bffd17 	ldw	r2,-12(fp)
   15934:	18800326 	beq	r3,r2,15944 <udp_sendto_if+0x1bc>
        /* free the header pbuf */
        pbuf_free(q);
   15938:	e13ff917 	ldw	r4,-28(fp)
   1593c:	000aa340 	call	aa34 <pbuf_free>
        q = NULL;
   15940:	e03ff915 	stw	zero,-28(fp)
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
   15944:	00bffe84 	movi	r2,-6
   15948:	00004506 	br	15a60 <udp_sendto_if+0x2d8>
    }
    /* use UDP PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
   1594c:	e0bffc17 	ldw	r2,-16(fp)
   15950:	e0bff815 	stw	r2,-32(fp)
    NETIF_SET_HWADDRHINT(netif, NULL);
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
   15954:	e0bff917 	ldw	r2,-28(fp)
   15958:	1080020b 	ldhu	r2,8(r2)
   1595c:	10bfffcc 	andi	r2,r2,65535
   15960:	1004d23a 	srli	r2,r2,8
   15964:	1007883a 	mov	r3,r2
   15968:	e0bff917 	ldw	r2,-28(fp)
   1596c:	1080020b 	ldhu	r2,8(r2)
   15970:	10bfffcc 	andi	r2,r2,65535
   15974:	1004923a 	slli	r2,r2,8
   15978:	1884b03a 	or	r2,r3,r2
   1597c:	1007883a 	mov	r3,r2
   15980:	e0bffb17 	ldw	r2,-20(fp)
   15984:	10c0010d 	sth	r3,4(r2)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
   15988:	e0bffc17 	ldw	r2,-16(fp)
   1598c:	10800403 	ldbu	r2,16(r2)
   15990:	10803fcc 	andi	r2,r2,255
   15994:	1080004c 	andi	r2,r2,1
   15998:	1000111e 	bne	r2,zero,159e0 <udp_sendto_if+0x258>
        acc = udpchksum + (u16_t)~(chksum);
        udpchksum = FOLD_U32T(acc);
      } else
#endif /* LWIP_CHECKSUM_ON_COPY */
      {
        udpchksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
   1599c:	e0bff917 	ldw	r2,-28(fp)
   159a0:	1080020b 	ldhu	r2,8(r2)
   159a4:	10bfffcc 	andi	r2,r2,65535
   159a8:	d8800015 	stw	r2,0(sp)
   159ac:	e13ff917 	ldw	r4,-28(fp)
   159b0:	e17ff817 	ldw	r5,-32(fp)
   159b4:	e1bffe17 	ldw	r6,-8(fp)
   159b8:	01c00444 	movi	r7,17
   159bc:	0005cb80 	call	5cb8 <inet_chksum_pseudo>
   159c0:	e0bffa0d 	sth	r2,-24(fp)
      }

      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udpchksum == 0x0000) {
   159c4:	e0bffa0b 	ldhu	r2,-24(fp)
   159c8:	1000021e 	bne	r2,zero,159d4 <udp_sendto_if+0x24c>
        udpchksum = 0xffff;
   159cc:	00bfffc4 	movi	r2,-1
   159d0:	e0bffa0d 	sth	r2,-24(fp)
      }
      udphdr->chksum = udpchksum;
   159d4:	e0bffb17 	ldw	r2,-20(fp)
   159d8:	e0fffa0b 	ldhu	r3,-24(fp)
   159dc:	10c0018d 	sth	r3,6(r2)
#endif /* CHECKSUM_GEN_UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04"X16_F"\n", udphdr->chksum));
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
    NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
   159e0:	e0bffc17 	ldw	r2,-16(fp)
   159e4:	10800283 	ldbu	r2,10(r2)
   159e8:	10803fcc 	andi	r2,r2,255
   159ec:	e0fffc17 	ldw	r3,-16(fp)
   159f0:	18c00243 	ldbu	r3,9(r3)
   159f4:	18c03fcc 	andi	r3,r3,255
   159f8:	d8c00015 	stw	r3,0(sp)
   159fc:	00c00444 	movi	r3,17
   15a00:	d8c00115 	stw	r3,4(sp)
   15a04:	e0c00217 	ldw	r3,8(fp)
   15a08:	d8c00215 	stw	r3,8(sp)
   15a0c:	e13ff917 	ldw	r4,-28(fp)
   15a10:	e17ff817 	ldw	r5,-32(fp)
   15a14:	e1bffe17 	ldw	r6,-8(fp)
   15a18:	100f883a 	mov	r7,r2
   15a1c:	00068540 	call	6854 <ip_output_if>
   15a20:	e0bffa85 	stb	r2,-22(fp)
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
   15a24:	e0fff917 	ldw	r3,-28(fp)
   15a28:	e0bffd17 	ldw	r2,-12(fp)
   15a2c:	18800326 	beq	r3,r2,15a3c <udp_sendto_if+0x2b4>
    /* free the header pbuf */
    pbuf_free(q);
   15a30:	e13ff917 	ldw	r4,-28(fp)
   15a34:	000aa340 	call	aa34 <pbuf_free>
    q = NULL;
   15a38:	e03ff915 	stw	zero,-28(fp)
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
   15a3c:	00800234 	movhi	r2,8
   15a40:	1083bd04 	addi	r2,r2,3828
   15a44:	10801e0b 	ldhu	r2,120(r2)
   15a48:	10800044 	addi	r2,r2,1
   15a4c:	1007883a 	mov	r3,r2
   15a50:	00800234 	movhi	r2,8
   15a54:	1083bd04 	addi	r2,r2,3828
   15a58:	10c01e0d 	sth	r3,120(r2)
  return err;
   15a5c:	e0bffa83 	ldbu	r2,-22(fp)
}
   15a60:	e037883a 	mov	sp,fp
   15a64:	dfc00117 	ldw	ra,4(sp)
   15a68:	df000017 	ldw	fp,0(sp)
   15a6c:	dec00204 	addi	sp,sp,8
   15a70:	f800283a 	ret

00015a74 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
   15a74:	defff904 	addi	sp,sp,-28
   15a78:	dfc00615 	stw	ra,24(sp)
   15a7c:	df000515 	stw	fp,20(sp)
   15a80:	df000504 	addi	fp,sp,20
   15a84:	e13ffd15 	stw	r4,-12(fp)
   15a88:	e17ffe15 	stw	r5,-8(fp)
   15a8c:	3005883a 	mov	r2,r6
   15a90:	e0bfff0d 	sth	r2,-4(fp)

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
   15a94:	e03ffc05 	stb	zero,-16(fp)
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
   15a98:	d0a8ca17 	ldw	r2,-23768(gp)
   15a9c:	e0bffb15 	stw	r2,-20(fp)
   15aa0:	00002a06 	br	15b4c <udp_bind+0xd8>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
   15aa4:	e0fffd17 	ldw	r3,-12(fp)
   15aa8:	e0bffb17 	ldw	r2,-20(fp)
   15aac:	18800e1e 	bne	r3,r2,15ae8 <udp_bind+0x74>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
   15ab0:	e0bffc03 	ldbu	r2,-16(fp)
   15ab4:	10000926 	beq	r2,zero,15adc <udp_bind+0x68>
   15ab8:	010000f4 	movhi	r4,3
   15abc:	2103a604 	addi	r4,r4,3736
   15ac0:	014000f4 	movhi	r5,3
   15ac4:	2943cb04 	addi	r5,r5,3884
   15ac8:	0180c344 	movi	r6,781
   15acc:	01c000f4 	movhi	r7,3
   15ad0:	39c3b504 	addi	r7,r7,3796
   15ad4:	00193f00 	call	193f0 <printf>
   15ad8:	003fff06 	br	15ad8 <udp_bind+0x64>
      /* pcb already in list, just rebind */
      rebind = 1;
   15adc:	00800044 	movi	r2,1
   15ae0:	e0bffc05 	stb	r2,-16(fp)
   15ae4:	00001606 	br	15b40 <udp_bind+0xcc>
             !ip_get_option(ipcb, SOF_REUSEADDR)) {
#else /* SO_REUSE */
    /* port matches that of PCB in list and REUSEADDR not set -> reject */
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
   15ae8:	e0bffb17 	ldw	r2,-20(fp)
   15aec:	1080048b 	ldhu	r2,18(r2)
   15af0:	10ffffcc 	andi	r3,r2,65535
   15af4:	e0bfff0b 	ldhu	r2,-4(fp)
   15af8:	1880111e 	bne	r3,r2,15b40 <udp_bind+0xcc>
          /* IP address matches, or one is IP_ADDR_ANY? */
          (ip_addr_isany(&(ipcb->local_ip)) ||
   15afc:	e0bffb17 	ldw	r2,-20(fp)
             !ip_get_option(ipcb, SOF_REUSEADDR)) {
#else /* SO_REUSE */
    /* port matches that of PCB in list and REUSEADDR not set -> reject */
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
   15b00:	10000d26 	beq	r2,zero,15b38 <udp_bind+0xc4>
          /* IP address matches, or one is IP_ADDR_ANY? */
          (ip_addr_isany(&(ipcb->local_ip)) ||
   15b04:	e0bffb17 	ldw	r2,-20(fp)
   15b08:	10800017 	ldw	r2,0(r2)
   15b0c:	10000a26 	beq	r2,zero,15b38 <udp_bind+0xc4>
   15b10:	e0bffe17 	ldw	r2,-8(fp)
   15b14:	10000826 	beq	r2,zero,15b38 <udp_bind+0xc4>
           ip_addr_isany(ipaddr) ||
   15b18:	e0bffe17 	ldw	r2,-8(fp)
   15b1c:	10800017 	ldw	r2,0(r2)
   15b20:	10000526 	beq	r2,zero,15b38 <udp_bind+0xc4>
           ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
   15b24:	e0bffb17 	ldw	r2,-20(fp)
   15b28:	10c00017 	ldw	r3,0(r2)
   15b2c:	e0bffe17 	ldw	r2,-8(fp)
   15b30:	10800017 	ldw	r2,0(r2)
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
          /* IP address matches, or one is IP_ADDR_ANY? */
          (ip_addr_isany(&(ipcb->local_ip)) ||
           ip_addr_isany(ipaddr) ||
   15b34:	1880021e 	bne	r3,r2,15b40 <udp_bind+0xcc>
           ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
        /* other PCB already binds to this local IP and port */
        LWIP_DEBUGF(UDP_DEBUG,
                    ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
        return ERR_USE;
   15b38:	00bffe04 	movi	r2,-8
   15b3c:	00002006 	br	15bc0 <udp_bind+0x14c>
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
   15b40:	e0bffb17 	ldw	r2,-20(fp)
   15b44:	10800317 	ldw	r2,12(r2)
   15b48:	e0bffb15 	stw	r2,-20(fp)
   15b4c:	e0bffb17 	ldw	r2,-20(fp)
   15b50:	103fd41e 	bne	r2,zero,15aa4 <udp_bind+0x30>
        return ERR_USE;
      }
    }
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
   15b54:	e0bffe17 	ldw	r2,-8(fp)
   15b58:	10000326 	beq	r2,zero,15b68 <udp_bind+0xf4>
   15b5c:	e0bffe17 	ldw	r2,-8(fp)
   15b60:	10800017 	ldw	r2,0(r2)
   15b64:	00000106 	br	15b6c <udp_bind+0xf8>
   15b68:	0005883a 	mov	r2,zero
   15b6c:	e0fffd17 	ldw	r3,-12(fp)
   15b70:	18800015 	stw	r2,0(r3)

  /* no port specified? */
  if (port == 0) {
   15b74:	e0bfff0b 	ldhu	r2,-4(fp)
   15b78:	1000061e 	bne	r2,zero,15b94 <udp_bind+0x120>
    port = udp_new_port();
   15b7c:	00150100 	call	15010 <udp_new_port>
   15b80:	e0bfff0d 	sth	r2,-4(fp)
    if (port == 0) {
   15b84:	e0bfff0b 	ldhu	r2,-4(fp)
   15b88:	1000021e 	bne	r2,zero,15b94 <udp_bind+0x120>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
   15b8c:	00bffe04 	movi	r2,-8
   15b90:	00000b06 	br	15bc0 <udp_bind+0x14c>
    }
  }
  pcb->local_port = port;
   15b94:	e0bffd17 	ldw	r2,-12(fp)
   15b98:	e0ffff0b 	ldhu	r3,-4(fp)
   15b9c:	10c0048d 	sth	r3,18(r2)
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
   15ba0:	e0bffc03 	ldbu	r2,-16(fp)
   15ba4:	1000051e 	bne	r2,zero,15bbc <udp_bind+0x148>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
   15ba8:	d0e8ca17 	ldw	r3,-23768(gp)
   15bac:	e0bffd17 	ldw	r2,-12(fp)
   15bb0:	10c00315 	stw	r3,12(r2)
    udp_pcbs = pcb;
   15bb4:	e0bffd17 	ldw	r2,-12(fp)
   15bb8:	d0a8ca15 	stw	r2,-23768(gp)
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));
  return ERR_OK;
   15bbc:	0005883a 	mov	r2,zero
}
   15bc0:	e037883a 	mov	sp,fp
   15bc4:	dfc00117 	ldw	ra,4(sp)
   15bc8:	df000017 	ldw	fp,0(sp)
   15bcc:	dec00204 	addi	sp,sp,8
   15bd0:	f800283a 	ret

00015bd4 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
   15bd4:	defff904 	addi	sp,sp,-28
   15bd8:	dfc00615 	stw	ra,24(sp)
   15bdc:	df000515 	stw	fp,20(sp)
   15be0:	df000504 	addi	fp,sp,20
   15be4:	e13ffd15 	stw	r4,-12(fp)
   15be8:	e17ffe15 	stw	r5,-8(fp)
   15bec:	3005883a 	mov	r2,r6
   15bf0:	e0bfff0d 	sth	r2,-4(fp)
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
   15bf4:	e0bffd17 	ldw	r2,-12(fp)
   15bf8:	1080048b 	ldhu	r2,18(r2)
   15bfc:	10bfffcc 	andi	r2,r2,65535
   15c00:	10000d1e 	bne	r2,zero,15c38 <udp_connect+0x64>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
   15c04:	e0fffd17 	ldw	r3,-12(fp)
   15c08:	e0bffd17 	ldw	r2,-12(fp)
   15c0c:	1080048b 	ldhu	r2,18(r2)
   15c10:	10bfffcc 	andi	r2,r2,65535
   15c14:	e13ffd17 	ldw	r4,-12(fp)
   15c18:	180b883a 	mov	r5,r3
   15c1c:	100d883a 	mov	r6,r2
   15c20:	0015a740 	call	15a74 <udp_bind>
   15c24:	e0bffc05 	stb	r2,-16(fp)
    if (err != ERR_OK) {
   15c28:	e0bffc07 	ldb	r2,-16(fp)
   15c2c:	10000226 	beq	r2,zero,15c38 <udp_connect+0x64>
      return err;
   15c30:	e0bffc03 	ldbu	r2,-16(fp)
   15c34:	00002406 	br	15cc8 <udp_connect+0xf4>
    }
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
   15c38:	e0bffe17 	ldw	r2,-8(fp)
   15c3c:	10000326 	beq	r2,zero,15c4c <udp_connect+0x78>
   15c40:	e0bffe17 	ldw	r2,-8(fp)
   15c44:	10800017 	ldw	r2,0(r2)
   15c48:	00000106 	br	15c50 <udp_connect+0x7c>
   15c4c:	0005883a 	mov	r2,zero
   15c50:	e0fffd17 	ldw	r3,-12(fp)
   15c54:	18800115 	stw	r2,4(r3)
  pcb->remote_port = port;
   15c58:	e0bffd17 	ldw	r2,-12(fp)
   15c5c:	e0ffff0b 	ldhu	r3,-4(fp)
   15c60:	10c0050d 	sth	r3,20(r2)
  pcb->flags |= UDP_FLAGS_CONNECTED;
   15c64:	e0bffd17 	ldw	r2,-12(fp)
   15c68:	10800403 	ldbu	r2,16(r2)
   15c6c:	10800114 	ori	r2,r2,4
   15c70:	1007883a 	mov	r3,r2
   15c74:	e0bffd17 	ldw	r2,-12(fp)
   15c78:	10c00405 	stb	r3,16(r2)
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
   15c7c:	d0a8ca17 	ldw	r2,-23768(gp)
   15c80:	e0bffb15 	stw	r2,-20(fp)
   15c84:	00000806 	br	15ca8 <udp_connect+0xd4>
    if (pcb == ipcb) {
   15c88:	e0fffd17 	ldw	r3,-12(fp)
   15c8c:	e0bffb17 	ldw	r2,-20(fp)
   15c90:	1880021e 	bne	r3,r2,15c9c <udp_connect+0xc8>
      /* already on the list, just return */
      return ERR_OK;
   15c94:	0005883a 	mov	r2,zero
   15c98:	00000b06 	br	15cc8 <udp_connect+0xf4>
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
   15c9c:	e0bffb17 	ldw	r2,-20(fp)
   15ca0:	10800317 	ldw	r2,12(r2)
   15ca4:	e0bffb15 	stw	r2,-20(fp)
   15ca8:	e0bffb17 	ldw	r2,-20(fp)
   15cac:	103ff61e 	bne	r2,zero,15c88 <udp_connect+0xb4>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
   15cb0:	d0e8ca17 	ldw	r3,-23768(gp)
   15cb4:	e0bffd17 	ldw	r2,-12(fp)
   15cb8:	10c00315 	stw	r3,12(r2)
  udp_pcbs = pcb;
   15cbc:	e0bffd17 	ldw	r2,-12(fp)
   15cc0:	d0a8ca15 	stw	r2,-23768(gp)
  return ERR_OK;
   15cc4:	0005883a 	mov	r2,zero
}
   15cc8:	e037883a 	mov	sp,fp
   15ccc:	dfc00117 	ldw	ra,4(sp)
   15cd0:	df000017 	ldw	fp,0(sp)
   15cd4:	dec00204 	addi	sp,sp,8
   15cd8:	f800283a 	ret

00015cdc <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
   15cdc:	defffe04 	addi	sp,sp,-8
   15ce0:	df000115 	stw	fp,4(sp)
   15ce4:	df000104 	addi	fp,sp,4
   15ce8:	e13fff15 	stw	r4,-4(fp)
  /* reset remote address association */
  ip_addr_set_any(&pcb->remote_ip);
   15cec:	e0bfff17 	ldw	r2,-4(fp)
   15cf0:	10000115 	stw	zero,4(r2)
  pcb->remote_port = 0;
   15cf4:	e0bfff17 	ldw	r2,-4(fp)
   15cf8:	1000050d 	sth	zero,20(r2)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
   15cfc:	e0bfff17 	ldw	r2,-4(fp)
   15d00:	10c00403 	ldbu	r3,16(r2)
   15d04:	00bffec4 	movi	r2,-5
   15d08:	1884703a 	and	r2,r3,r2
   15d0c:	1007883a 	mov	r3,r2
   15d10:	e0bfff17 	ldw	r2,-4(fp)
   15d14:	10c00405 	stb	r3,16(r2)
}
   15d18:	e037883a 	mov	sp,fp
   15d1c:	df000017 	ldw	fp,0(sp)
   15d20:	dec00104 	addi	sp,sp,4
   15d24:	f800283a 	ret

00015d28 <udp_recv>:
 * @param recv function pointer of the callback function
 * @param recv_arg additional argument to pass to the callback function
 */
void
udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
   15d28:	defffc04 	addi	sp,sp,-16
   15d2c:	df000315 	stw	fp,12(sp)
   15d30:	df000304 	addi	fp,sp,12
   15d34:	e13ffd15 	stw	r4,-12(fp)
   15d38:	e17ffe15 	stw	r5,-8(fp)
   15d3c:	e1bfff15 	stw	r6,-4(fp)
  /* remember recv() callback and user data */
  pcb->recv = recv;
   15d40:	e0bffd17 	ldw	r2,-12(fp)
   15d44:	e0fffe17 	ldw	r3,-8(fp)
   15d48:	10c00615 	stw	r3,24(r2)
  pcb->recv_arg = recv_arg;
   15d4c:	e0bffd17 	ldw	r2,-12(fp)
   15d50:	e0ffff17 	ldw	r3,-4(fp)
   15d54:	10c00715 	stw	r3,28(r2)
}
   15d58:	e037883a 	mov	sp,fp
   15d5c:	df000017 	ldw	fp,0(sp)
   15d60:	dec00104 	addi	sp,sp,4
   15d64:	f800283a 	ret

00015d68 <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
   15d68:	defffc04 	addi	sp,sp,-16
   15d6c:	dfc00315 	stw	ra,12(sp)
   15d70:	df000215 	stw	fp,8(sp)
   15d74:	df000204 	addi	fp,sp,8
   15d78:	e13fff15 	stw	r4,-4(fp)
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
   15d7c:	d0e8ca17 	ldw	r3,-23768(gp)
   15d80:	e0bfff17 	ldw	r2,-4(fp)
   15d84:	1880041e 	bne	r3,r2,15d98 <udp_remove+0x30>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
   15d88:	d0a8ca17 	ldw	r2,-23768(gp)
   15d8c:	10800317 	ldw	r2,12(r2)
   15d90:	d0a8ca15 	stw	r2,-23768(gp)
   15d94:	00001306 	br	15de4 <udp_remove+0x7c>
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
   15d98:	d0a8ca17 	ldw	r2,-23768(gp)
   15d9c:	e0bffe15 	stw	r2,-8(fp)
   15da0:	00000e06 	br	15ddc <udp_remove+0x74>
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
   15da4:	e0bffe17 	ldw	r2,-8(fp)
   15da8:	10800317 	ldw	r2,12(r2)
   15dac:	10000826 	beq	r2,zero,15dd0 <udp_remove+0x68>
   15db0:	e0bffe17 	ldw	r2,-8(fp)
   15db4:	10c00317 	ldw	r3,12(r2)
   15db8:	e0bfff17 	ldw	r2,-4(fp)
   15dbc:	1880041e 	bne	r3,r2,15dd0 <udp_remove+0x68>
        /* remove pcb from list */
        pcb2->next = pcb->next;
   15dc0:	e0bfff17 	ldw	r2,-4(fp)
   15dc4:	10c00317 	ldw	r3,12(r2)
   15dc8:	e0bffe17 	ldw	r2,-8(fp)
   15dcc:	10c00315 	stw	r3,12(r2)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
   15dd0:	e0bffe17 	ldw	r2,-8(fp)
   15dd4:	10800317 	ldw	r2,12(r2)
   15dd8:	e0bffe15 	stw	r2,-8(fp)
   15ddc:	e0bffe17 	ldw	r2,-8(fp)
   15de0:	103ff01e 	bne	r2,zero,15da4 <udp_remove+0x3c>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
   15de4:	01000044 	movi	r4,1
   15de8:	e17fff17 	ldw	r5,-4(fp)
   15dec:	00097d40 	call	97d4 <memp_free>
}
   15df0:	e037883a 	mov	sp,fp
   15df4:	dfc00117 	ldw	ra,4(sp)
   15df8:	df000017 	ldw	fp,0(sp)
   15dfc:	dec00204 	addi	sp,sp,8
   15e00:	f800283a 	ret

00015e04 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
   15e04:	defffd04 	addi	sp,sp,-12
   15e08:	dfc00215 	stw	ra,8(sp)
   15e0c:	df000115 	stw	fp,4(sp)
   15e10:	df000104 	addi	fp,sp,4
  struct udp_pcb *pcb;
  pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
   15e14:	01000044 	movi	r4,1
   15e18:	00095f80 	call	95f8 <memp_malloc>
   15e1c:	e0bfff15 	stw	r2,-4(fp)
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
   15e20:	e0bfff17 	ldw	r2,-4(fp)
   15e24:	10000726 	beq	r2,zero,15e44 <udp_new+0x40>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
   15e28:	e13fff17 	ldw	r4,-4(fp)
   15e2c:	000b883a 	mov	r5,zero
   15e30:	01800804 	movi	r6,32
   15e34:	00192e80 	call	192e8 <memset>
    pcb->ttl = UDP_TTL;
   15e38:	e0bfff17 	ldw	r2,-4(fp)
   15e3c:	00ffffc4 	movi	r3,-1
   15e40:	10c00285 	stb	r3,10(r2)
  }
  return pcb;
   15e44:	e0bfff17 	ldw	r2,-4(fp)
}
   15e48:	e037883a 	mov	sp,fp
   15e4c:	dfc00117 	ldw	ra,4(sp)
   15e50:	df000017 	ldw	fp,0(sp)
   15e54:	dec00204 	addi	sp,sp,8
   15e58:	f800283a 	ret

00015e5c <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
   15e5c:	defffc04 	addi	sp,sp,-16
   15e60:	dfc00315 	stw	ra,12(sp)
   15e64:	df000215 	stw	fp,8(sp)
   15e68:	df000204 	addi	fp,sp,8
   15e6c:	e13fff15 	stw	r4,-4(fp)
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
   15e70:	e0bfff17 	ldw	r2,-4(fp)
   15e74:	1000091e 	bne	r2,zero,15e9c <free_etharp_q+0x40>
   15e78:	010000f4 	movhi	r4,3
   15e7c:	2103ce04 	addi	r4,r4,3896
   15e80:	014000f4 	movhi	r5,3
   15e84:	2943d804 	addi	r5,r5,3936
   15e88:	01802784 	movi	r6,158
   15e8c:	01c000f4 	movhi	r7,3
   15e90:	39c3db04 	addi	r7,r7,3948
   15e94:	00193f00 	call	193f0 <printf>
   15e98:	003fff06 	br	15e98 <free_etharp_q+0x3c>
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
   15e9c:	e0bfff17 	ldw	r2,-4(fp)
   15ea0:	10800117 	ldw	r2,4(r2)
   15ea4:	1000211e 	bne	r2,zero,15f2c <free_etharp_q+0xd0>
   15ea8:	010000f4 	movhi	r4,3
   15eac:	2103ce04 	addi	r4,r4,3896
   15eb0:	014000f4 	movhi	r5,3
   15eb4:	2943e104 	addi	r5,r5,3972
   15eb8:	018027c4 	movi	r6,159
   15ebc:	01c000f4 	movhi	r7,3
   15ec0:	39c3db04 	addi	r7,r7,3948
   15ec4:	00193f00 	call	193f0 <printf>
   15ec8:	003fff06 	br	15ec8 <free_etharp_q+0x6c>
  while (q) {
    r = q;
   15ecc:	e0bfff17 	ldw	r2,-4(fp)
   15ed0:	e0bffe15 	stw	r2,-8(fp)
    q = q->next;
   15ed4:	e0bfff17 	ldw	r2,-4(fp)
   15ed8:	10800017 	ldw	r2,0(r2)
   15edc:	e0bfff15 	stw	r2,-4(fp)
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
   15ee0:	e0bffe17 	ldw	r2,-8(fp)
   15ee4:	10800117 	ldw	r2,4(r2)
   15ee8:	1000091e 	bne	r2,zero,15f10 <free_etharp_q+0xb4>
   15eec:	010000f4 	movhi	r4,3
   15ef0:	2103ce04 	addi	r4,r4,3896
   15ef4:	014000f4 	movhi	r5,3
   15ef8:	2943e504 	addi	r5,r5,3988
   15efc:	018028c4 	movi	r6,163
   15f00:	01c000f4 	movhi	r7,3
   15f04:	39c3db04 	addi	r7,r7,3948
   15f08:	00193f00 	call	193f0 <printf>
   15f0c:	003fff06 	br	15f0c <free_etharp_q+0xb0>
    pbuf_free(r->p);
   15f10:	e0bffe17 	ldw	r2,-8(fp)
   15f14:	10800117 	ldw	r2,4(r2)
   15f18:	1009883a 	mov	r4,r2
   15f1c:	000aa340 	call	aa34 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
   15f20:	01000184 	movi	r4,6
   15f24:	e17ffe17 	ldw	r5,-8(fp)
   15f28:	00097d40 	call	97d4 <memp_free>
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
   15f2c:	e0bfff17 	ldw	r2,-4(fp)
   15f30:	103fe61e 	bne	r2,zero,15ecc <free_etharp_q+0x70>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
   15f34:	e037883a 	mov	sp,fp
   15f38:	dfc00117 	ldw	ra,4(sp)
   15f3c:	df000017 	ldw	fp,0(sp)
   15f40:	dec00204 	addi	sp,sp,8
   15f44:	f800283a 	ret

00015f48 <etharp_free_entry>:
#endif /* ARP_QUEUEING */

/** Clean up ARP table entries */
static void
etharp_free_entry(int i)
{
   15f48:	defffd04 	addi	sp,sp,-12
   15f4c:	dfc00215 	stw	ra,8(sp)
   15f50:	df000115 	stw	fp,4(sp)
   15f54:	df000104 	addi	fp,sp,4
   15f58:	e13fff15 	stw	r4,-4(fp)
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
   15f5c:	00c00134 	movhi	r3,4
   15f60:	18d73904 	addi	r3,r3,23780
   15f64:	e0bfff17 	ldw	r2,-4(fp)
   15f68:	10800524 	muli	r2,r2,20
   15f6c:	1885883a 	add	r2,r3,r2
   15f70:	10800017 	ldw	r2,0(r2)
   15f74:	10000e26 	beq	r2,zero,15fb0 <etharp_free_entry+0x68>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
   15f78:	00c00134 	movhi	r3,4
   15f7c:	18d73904 	addi	r3,r3,23780
   15f80:	e0bfff17 	ldw	r2,-4(fp)
   15f84:	10800524 	muli	r2,r2,20
   15f88:	1885883a 	add	r2,r3,r2
   15f8c:	10800017 	ldw	r2,0(r2)
   15f90:	1009883a 	mov	r4,r2
   15f94:	0015e5c0 	call	15e5c <free_etharp_q>
    arp_table[i].q = NULL;
   15f98:	00c00134 	movhi	r3,4
   15f9c:	18d73904 	addi	r3,r3,23780
   15fa0:	e0bfff17 	ldw	r2,-4(fp)
   15fa4:	10800524 	muli	r2,r2,20
   15fa8:	1885883a 	add	r2,r3,r2
   15fac:	10000015 	stw	zero,0(r2)
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
   15fb0:	00c00134 	movhi	r3,4
   15fb4:	18d73904 	addi	r3,r3,23780
   15fb8:	e0bfff17 	ldw	r2,-4(fp)
   15fbc:	10800524 	muli	r2,r2,20
   15fc0:	1885883a 	add	r2,r3,r2
   15fc4:	10800404 	addi	r2,r2,16
   15fc8:	10000085 	stb	zero,2(r2)
  arp_table[i].ctime = 0;
  arp_table[i].netif = NULL;
  ip_addr_set_zero(&arp_table[i].ipaddr);
  arp_table[i].ethaddr = ethzero;
#endif /* LWIP_DEBUG */
}
   15fcc:	e037883a 	mov	sp,fp
   15fd0:	dfc00117 	ldw	ra,4(sp)
   15fd4:	df000017 	ldw	fp,0(sp)
   15fd8:	dec00204 	addi	sp,sp,8
   15fdc:	f800283a 	ret

00015fe0 <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL milliseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
   15fe0:	defffd04 	addi	sp,sp,-12
   15fe4:	dfc00215 	stw	ra,8(sp)
   15fe8:	df000115 	stw	fp,4(sp)
   15fec:	df000104 	addi	fp,sp,4
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
   15ff0:	e03fff05 	stb	zero,-4(fp)
   15ff4:	00004f06 	br	16134 <etharp_tmr+0x154>
    u8_t state = arp_table[i].state;
   15ff8:	e0bfff03 	ldbu	r2,-4(fp)
   15ffc:	00c00134 	movhi	r3,4
   16000:	18d73904 	addi	r3,r3,23780
   16004:	10800524 	muli	r2,r2,20
   16008:	1885883a 	add	r2,r3,r2
   1600c:	10800404 	addi	r2,r2,16
   16010:	10800083 	ldbu	r2,2(r2)
   16014:	e0bfff45 	stb	r2,-3(fp)
    if (state != ETHARP_STATE_EMPTY
   16018:	e0bfff43 	ldbu	r2,-3(fp)
   1601c:	10004226 	beq	r2,zero,16128 <etharp_tmr+0x148>
#if ETHARP_SUPPORT_STATIC_ENTRIES
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
   16020:	e0bfff03 	ldbu	r2,-4(fp)
   16024:	01000134 	movhi	r4,4
   16028:	21173904 	addi	r4,r4,23780
   1602c:	10c00524 	muli	r3,r2,20
   16030:	20c7883a 	add	r3,r4,r3
   16034:	18c00404 	addi	r3,r3,16
   16038:	18c000c3 	ldbu	r3,3(r3)
   1603c:	18c00044 	addi	r3,r3,1
   16040:	01000134 	movhi	r4,4
   16044:	21173904 	addi	r4,r4,23780
   16048:	10800524 	muli	r2,r2,20
   1604c:	2085883a 	add	r2,r4,r2
   16050:	10800404 	addi	r2,r2,16
   16054:	10c000c5 	stb	r3,3(r2)
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
   16058:	e0bfff03 	ldbu	r2,-4(fp)
   1605c:	00c00134 	movhi	r3,4
   16060:	18d73904 	addi	r3,r3,23780
   16064:	10800524 	muli	r2,r2,20
   16068:	1885883a 	add	r2,r3,r2
   1606c:	10800404 	addi	r2,r2,16
   16070:	108000c3 	ldbu	r2,3(r2)
   16074:	10803fcc 	andi	r2,r2,255
   16078:	10803c28 	cmpgeui	r2,r2,240
   1607c:	1000141e 	bne	r2,zero,160d0 <etharp_tmr+0xf0>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
   16080:	e0bfff03 	ldbu	r2,-4(fp)
   16084:	00c00134 	movhi	r3,4
   16088:	18d73904 	addi	r3,r3,23780
   1608c:	10800524 	muli	r2,r2,20
   16090:	1885883a 	add	r2,r3,r2
   16094:	10800404 	addi	r2,r2,16
   16098:	10800083 	ldbu	r2,2(r2)
#if ETHARP_SUPPORT_STATIC_ENTRIES
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
   1609c:	10803fcc 	andi	r2,r2,255
   160a0:	10800058 	cmpnei	r2,r2,1
   160a4:	10000e1e 	bne	r2,zero,160e0 <etharp_tmr+0x100>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
           (arp_table[i].ctime >= ARP_MAXPENDING))) {
   160a8:	e0bfff03 	ldbu	r2,-4(fp)
   160ac:	00c00134 	movhi	r3,4
   160b0:	18d73904 	addi	r3,r3,23780
   160b4:	10800524 	muli	r2,r2,20
   160b8:	1885883a 	add	r2,r3,r2
   160bc:	10800404 	addi	r2,r2,16
   160c0:	108000c3 	ldbu	r2,3(r2)
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
   160c4:	10803fcc 	andi	r2,r2,255
   160c8:	108000b0 	cmpltui	r2,r2,2
   160cc:	1000041e 	bne	r2,zero,160e0 <etharp_tmr+0x100>
           (arp_table[i].ctime >= ARP_MAXPENDING))) {
        /* pending or stable entry has become old! */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %"U16_F".\n",
             arp_table[i].state >= ETHARP_STATE_STABLE ? "stable" : "pending", (u16_t)i));
        /* clean up entries that have just been expired */
        etharp_free_entry(i);
   160d0:	e0bfff03 	ldbu	r2,-4(fp)
   160d4:	1009883a 	mov	r4,r2
   160d8:	0015f480 	call	15f48 <etharp_free_entry>
   160dc:	00001206 	br	16128 <etharp_tmr+0x148>
      }
      else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
   160e0:	e0bfff03 	ldbu	r2,-4(fp)
   160e4:	00c00134 	movhi	r3,4
   160e8:	18d73904 	addi	r3,r3,23780
   160ec:	10800524 	muli	r2,r2,20
   160f0:	1885883a 	add	r2,r3,r2
   160f4:	10800404 	addi	r2,r2,16
   160f8:	10800083 	ldbu	r2,2(r2)
   160fc:	10803fcc 	andi	r2,r2,255
   16100:	108000d8 	cmpnei	r2,r2,3
   16104:	1000081e 	bne	r2,zero,16128 <etharp_tmr+0x148>
        /* Reset state to stable, so that the next transmitted packet will
           re-send an ARP request. */
        arp_table[i].state = ETHARP_STATE_STABLE;
   16108:	e0bfff03 	ldbu	r2,-4(fp)
   1610c:	00c00134 	movhi	r3,4
   16110:	18d73904 	addi	r3,r3,23780
   16114:	10800524 	muli	r2,r2,20
   16118:	1885883a 	add	r2,r3,r2
   1611c:	10800404 	addi	r2,r2,16
   16120:	00c00084 	movi	r3,2
   16124:	10c00085 	stb	r3,2(r2)
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
   16128:	e0bfff03 	ldbu	r2,-4(fp)
   1612c:	10800044 	addi	r2,r2,1
   16130:	e0bfff05 	stb	r2,-4(fp)
   16134:	e0bfff03 	ldbu	r2,-4(fp)
   16138:	108002b0 	cmpltui	r2,r2,10
   1613c:	103fae1e 	bne	r2,zero,15ff8 <etharp_tmr+0x18>
        /* resend an ARP query here? */
      }
#endif /* ARP_QUEUEING */
    }
  }
}
   16140:	e037883a 	mov	sp,fp
   16144:	dfc00117 	ldw	ra,4(sp)
   16148:	df000017 	ldw	fp,0(sp)
   1614c:	dec00204 	addi	sp,sp,8
   16150:	f800283a 	ret

00016154 <etharp_find_entry>:
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
   16154:	defff904 	addi	sp,sp,-28
   16158:	dfc00615 	stw	ra,24(sp)
   1615c:	df000515 	stw	fp,20(sp)
   16160:	df000504 	addi	fp,sp,20
   16164:	e13ffe15 	stw	r4,-8(fp)
   16168:	2805883a 	mov	r2,r5
   1616c:	e0bfff05 	stb	r2,-4(fp)
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
   16170:	00800284 	movi	r2,10
   16174:	e0bffb05 	stb	r2,-20(fp)
   16178:	00800284 	movi	r2,10
   1617c:	e0bffb45 	stb	r2,-19(fp)
  s8_t empty = ARP_TABLE_SIZE;
   16180:	00800284 	movi	r2,10
   16184:	e0bffb85 	stb	r2,-18(fp)
  u8_t i = 0, age_pending = 0, age_stable = 0;
   16188:	e03ffbc5 	stb	zero,-17(fp)
   1618c:	e03ffc05 	stb	zero,-16(fp)
   16190:	e03ffc45 	stb	zero,-15(fp)
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
   16194:	00800284 	movi	r2,10
   16198:	e0bffc85 	stb	r2,-14(fp)
  /* its age */
  u8_t age_queue = 0;
   1619c:	e03ffcc5 	stb	zero,-13(fp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
   161a0:	e03ffbc5 	stb	zero,-17(fp)
   161a4:	00007d06 	br	1639c <etharp_find_entry+0x248>
    u8_t state = arp_table[i].state;
   161a8:	e0bffbc3 	ldbu	r2,-17(fp)
   161ac:	00c00134 	movhi	r3,4
   161b0:	18d73904 	addi	r3,r3,23780
   161b4:	10800524 	muli	r2,r2,20
   161b8:	1885883a 	add	r2,r3,r2
   161bc:	10800404 	addi	r2,r2,16
   161c0:	10800083 	ldbu	r2,2(r2)
   161c4:	e0bffd05 	stb	r2,-12(fp)
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
   161c8:	e0bffb87 	ldb	r2,-18(fp)
   161cc:	10800298 	cmpnei	r2,r2,10
   161d0:	1000051e 	bne	r2,zero,161e8 <etharp_find_entry+0x94>
   161d4:	e0bffd03 	ldbu	r2,-12(fp)
   161d8:	1000031e 	bne	r2,zero,161e8 <etharp_find_entry+0x94>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
   161dc:	e0bffbc3 	ldbu	r2,-17(fp)
   161e0:	e0bffb85 	stb	r2,-18(fp)
   161e4:	00006a06 	br	16390 <etharp_find_entry+0x23c>
    } else if (state != ETHARP_STATE_EMPTY) {
   161e8:	e0bffd03 	ldbu	r2,-12(fp)
   161ec:	10006826 	beq	r2,zero,16390 <etharp_find_entry+0x23c>
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
   161f0:	e0bffd03 	ldbu	r2,-12(fp)
   161f4:	10800060 	cmpeqi	r2,r2,1
   161f8:	10000c1e 	bne	r2,zero,1622c <etharp_find_entry+0xd8>
   161fc:	e0bffd03 	ldbu	r2,-12(fp)
   16200:	108000a8 	cmpgeui	r2,r2,2
   16204:	1000091e 	bne	r2,zero,1622c <etharp_find_entry+0xd8>
   16208:	010000f4 	movhi	r4,3
   1620c:	2103ce04 	addi	r4,r4,3896
   16210:	014000f4 	movhi	r5,3
   16214:	2943e904 	addi	r5,r5,4004
   16218:	01804b04 	movi	r6,300
   1621c:	01c000f4 	movhi	r7,3
   16220:	39c3db04 	addi	r7,r7,3948
   16224:	00193f00 	call	193f0 <printf>
   16228:	003fff06 	br	16228 <etharp_find_entry+0xd4>
        state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
   1622c:	e0bffe17 	ldw	r2,-8(fp)
   16230:	10000c26 	beq	r2,zero,16264 <etharp_find_entry+0x110>
   16234:	e0bffe17 	ldw	r2,-8(fp)
   16238:	10c00017 	ldw	r3,0(r2)
   1623c:	e0bffbc3 	ldbu	r2,-17(fp)
   16240:	01000134 	movhi	r4,4
   16244:	21173904 	addi	r4,r4,23780
   16248:	10800524 	muli	r2,r2,20
   1624c:	2085883a 	add	r2,r4,r2
   16250:	10800104 	addi	r2,r2,4
   16254:	10800017 	ldw	r2,0(r2)
   16258:	1880021e 	bne	r3,r2,16264 <etharp_find_entry+0x110>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
   1625c:	e0bffbc3 	ldbu	r2,-17(fp)
   16260:	0000c506 	br	16578 <etharp_find_entry+0x424>
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
   16264:	e0bffd03 	ldbu	r2,-12(fp)
   16268:	10800058 	cmpnei	r2,r2,1
   1626c:	1000311e 	bne	r2,zero,16334 <etharp_find_entry+0x1e0>
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
   16270:	e0bffbc3 	ldbu	r2,-17(fp)
   16274:	00c00134 	movhi	r3,4
   16278:	18d73904 	addi	r3,r3,23780
   1627c:	10800524 	muli	r2,r2,20
   16280:	1885883a 	add	r2,r3,r2
   16284:	10800017 	ldw	r2,0(r2)
   16288:	10001526 	beq	r2,zero,162e0 <etharp_find_entry+0x18c>
          if (arp_table[i].ctime >= age_queue) {
   1628c:	e0bffbc3 	ldbu	r2,-17(fp)
   16290:	00c00134 	movhi	r3,4
   16294:	18d73904 	addi	r3,r3,23780
   16298:	10800524 	muli	r2,r2,20
   1629c:	1885883a 	add	r2,r3,r2
   162a0:	10800404 	addi	r2,r2,16
   162a4:	108000c3 	ldbu	r2,3(r2)
   162a8:	10c03fcc 	andi	r3,r2,255
   162ac:	e0bffcc3 	ldbu	r2,-13(fp)
   162b0:	18803736 	bltu	r3,r2,16390 <etharp_find_entry+0x23c>
            old_queue = i;
   162b4:	e0bffbc3 	ldbu	r2,-17(fp)
   162b8:	e0bffc85 	stb	r2,-14(fp)
            age_queue = arp_table[i].ctime;
   162bc:	e0bffbc3 	ldbu	r2,-17(fp)
   162c0:	00c00134 	movhi	r3,4
   162c4:	18d73904 	addi	r3,r3,23780
   162c8:	10800524 	muli	r2,r2,20
   162cc:	1885883a 	add	r2,r3,r2
   162d0:	10800404 	addi	r2,r2,16
   162d4:	108000c3 	ldbu	r2,3(r2)
   162d8:	e0bffcc5 	stb	r2,-13(fp)
   162dc:	00002c06 	br	16390 <etharp_find_entry+0x23c>
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
   162e0:	e0bffbc3 	ldbu	r2,-17(fp)
   162e4:	00c00134 	movhi	r3,4
   162e8:	18d73904 	addi	r3,r3,23780
   162ec:	10800524 	muli	r2,r2,20
   162f0:	1885883a 	add	r2,r3,r2
   162f4:	10800404 	addi	r2,r2,16
   162f8:	108000c3 	ldbu	r2,3(r2)
   162fc:	10c03fcc 	andi	r3,r2,255
   16300:	e0bffc03 	ldbu	r2,-16(fp)
   16304:	18802236 	bltu	r3,r2,16390 <etharp_find_entry+0x23c>
            old_pending = i;
   16308:	e0bffbc3 	ldbu	r2,-17(fp)
   1630c:	e0bffb05 	stb	r2,-20(fp)
            age_pending = arp_table[i].ctime;
   16310:	e0bffbc3 	ldbu	r2,-17(fp)
   16314:	00c00134 	movhi	r3,4
   16318:	18d73904 	addi	r3,r3,23780
   1631c:	10800524 	muli	r2,r2,20
   16320:	1885883a 	add	r2,r3,r2
   16324:	10800404 	addi	r2,r2,16
   16328:	108000c3 	ldbu	r2,3(r2)
   1632c:	e0bffc05 	stb	r2,-16(fp)
   16330:	00001706 	br	16390 <etharp_find_entry+0x23c>
          }
        }
      /* stable entry? */
      } else if (state >= ETHARP_STATE_STABLE) {
   16334:	e0bffd03 	ldbu	r2,-12(fp)
   16338:	108000b0 	cmpltui	r2,r2,2
   1633c:	1000141e 	bne	r2,zero,16390 <etharp_find_entry+0x23c>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
   16340:	e0bffbc3 	ldbu	r2,-17(fp)
   16344:	00c00134 	movhi	r3,4
   16348:	18d73904 	addi	r3,r3,23780
   1634c:	10800524 	muli	r2,r2,20
   16350:	1885883a 	add	r2,r3,r2
   16354:	10800404 	addi	r2,r2,16
   16358:	108000c3 	ldbu	r2,3(r2)
   1635c:	10c03fcc 	andi	r3,r2,255
   16360:	e0bffc43 	ldbu	r2,-15(fp)
   16364:	18800a36 	bltu	r3,r2,16390 <etharp_find_entry+0x23c>
            old_stable = i;
   16368:	e0bffbc3 	ldbu	r2,-17(fp)
   1636c:	e0bffb45 	stb	r2,-19(fp)
            age_stable = arp_table[i].ctime;
   16370:	e0bffbc3 	ldbu	r2,-17(fp)
   16374:	00c00134 	movhi	r3,4
   16378:	18d73904 	addi	r3,r3,23780
   1637c:	10800524 	muli	r2,r2,20
   16380:	1885883a 	add	r2,r3,r2
   16384:	10800404 	addi	r2,r2,16
   16388:	108000c3 	ldbu	r2,3(r2)
   1638c:	e0bffc45 	stb	r2,-15(fp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
   16390:	e0bffbc3 	ldbu	r2,-17(fp)
   16394:	10800044 	addi	r2,r2,1
   16398:	e0bffbc5 	stb	r2,-17(fp)
   1639c:	e0bffbc3 	ldbu	r2,-17(fp)
   163a0:	108002b0 	cmpltui	r2,r2,10
   163a4:	103f801e 	bne	r2,zero,161a8 <etharp_find_entry+0x54>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
   163a8:	e0bfff03 	ldbu	r2,-4(fp)
   163ac:	1080008c 	andi	r2,r2,2
   163b0:	1000061e 	bne	r2,zero,163cc <etharp_find_entry+0x278>
   163b4:	e0bffb87 	ldb	r2,-18(fp)
   163b8:	10800298 	cmpnei	r2,r2,10
   163bc:	1000051e 	bne	r2,zero,163d4 <etharp_find_entry+0x280>
      /* or no empty entry found and not allowed to recycle? */
      ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
   163c0:	e0bfff03 	ldbu	r2,-4(fp)
   163c4:	1080004c 	andi	r2,r2,1
   163c8:	1000021e 	bne	r2,zero,163d4 <etharp_find_entry+0x280>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
   163cc:	00bfffc4 	movi	r2,-1
   163d0:	00006906 	br	16578 <etharp_find_entry+0x424>
   * 
   * { ETHARP_FLAG_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
   163d4:	e0bffb87 	ldb	r2,-18(fp)
   163d8:	10800288 	cmpgei	r2,r2,10
   163dc:	1000031e 	bne	r2,zero,163ec <etharp_find_entry+0x298>
    i = empty;
   163e0:	e0bffb83 	ldbu	r2,-18(fp)
   163e4:	e0bffbc5 	stb	r2,-17(fp)
   163e8:	00003206 	br	164b4 <etharp_find_entry+0x360>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  } else {
    /* 2) found recyclable stable entry? */
    if (old_stable < ARP_TABLE_SIZE) {
   163ec:	e0bffb47 	ldb	r2,-19(fp)
   163f0:	10800288 	cmpgei	r2,r2,10
   163f4:	1000121e 	bne	r2,zero,16440 <etharp_find_entry+0x2ec>
      /* recycle oldest stable*/
      i = old_stable;
   163f8:	e0bffb43 	ldbu	r2,-19(fp)
   163fc:	e0bffbc5 	stb	r2,-17(fp)
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
      /* no queued packets should exist on stable entries */
      LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
   16400:	e0bffbc3 	ldbu	r2,-17(fp)
   16404:	00c00134 	movhi	r3,4
   16408:	18d73904 	addi	r3,r3,23780
   1640c:	10800524 	muli	r2,r2,20
   16410:	1885883a 	add	r2,r3,r2
   16414:	10800017 	ldw	r2,0(r2)
   16418:	10001726 	beq	r2,zero,16478 <etharp_find_entry+0x324>
   1641c:	010000f4 	movhi	r4,3
   16420:	2103ce04 	addi	r4,r4,3896
   16424:	014000f4 	movhi	r5,3
   16428:	2943f904 	addi	r5,r5,4068
   1642c:	01805c44 	movi	r6,369
   16430:	01c000f4 	movhi	r7,3
   16434:	39c3db04 	addi	r7,r7,3948
   16438:	00193f00 	call	193f0 <printf>
   1643c:	003fff06 	br	1643c <etharp_find_entry+0x2e8>
    /* 3) found recyclable pending entry without queued packets? */
    } else if (old_pending < ARP_TABLE_SIZE) {
   16440:	e0bffb07 	ldb	r2,-20(fp)
   16444:	10800288 	cmpgei	r2,r2,10
   16448:	1000031e 	bne	r2,zero,16458 <etharp_find_entry+0x304>
      /* recycle oldest pending */
      i = old_pending;
   1644c:	e0bffb03 	ldbu	r2,-20(fp)
   16450:	e0bffbc5 	stb	r2,-17(fp)
   16454:	00000806 	br	16478 <etharp_find_entry+0x324>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
    /* 4) found recyclable pending entry with queued packets? */
    } else if (old_queue < ARP_TABLE_SIZE) {
   16458:	e0bffc87 	ldb	r2,-14(fp)
   1645c:	10800288 	cmpgei	r2,r2,10
   16460:	1000031e 	bne	r2,zero,16470 <etharp_find_entry+0x31c>
      /* recycle oldest pending (queued packets are free in etharp_free_entry) */
      i = old_queue;
   16464:	e0bffc83 	ldbu	r2,-14(fp)
   16468:	e0bffbc5 	stb	r2,-17(fp)
   1646c:	00000206 	br	16478 <etharp_find_entry+0x324>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
      /* no empty or recyclable entries found */
    } else {
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty or recyclable entries found\n"));
      return (s8_t)ERR_MEM;
   16470:	00bfffc4 	movi	r2,-1
   16474:	00004006 	br	16578 <etharp_find_entry+0x424>
    }

    /* { empty or recyclable entry found } */
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
   16478:	e0bffbc3 	ldbu	r2,-17(fp)
   1647c:	108002b0 	cmpltui	r2,r2,10
   16480:	1000091e 	bne	r2,zero,164a8 <etharp_find_entry+0x354>
   16484:	010000f4 	movhi	r4,3
   16488:	2103ce04 	addi	r4,r4,3896
   1648c:	014000f4 	movhi	r5,3
   16490:	2943ff04 	addi	r5,r5,4092
   16494:	018060c4 	movi	r6,387
   16498:	01c000f4 	movhi	r7,3
   1649c:	39c3db04 	addi	r7,r7,3948
   164a0:	00193f00 	call	193f0 <printf>
   164a4:	003fff06 	br	164a4 <etharp_find_entry+0x350>
    etharp_free_entry(i);
   164a8:	e0bffbc3 	ldbu	r2,-17(fp)
   164ac:	1009883a 	mov	r4,r2
   164b0:	0015f480 	call	15f48 <etharp_free_entry>
  }

  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
   164b4:	e0bffbc3 	ldbu	r2,-17(fp)
   164b8:	108002b0 	cmpltui	r2,r2,10
   164bc:	1000091e 	bne	r2,zero,164e4 <etharp_find_entry+0x390>
   164c0:	010000f4 	movhi	r4,3
   164c4:	2103ce04 	addi	r4,r4,3896
   164c8:	014000f4 	movhi	r5,3
   164cc:	2943ff04 	addi	r5,r5,4092
   164d0:	018061c4 	movi	r6,391
   164d4:	01c000f4 	movhi	r7,3
   164d8:	39c3db04 	addi	r7,r7,3948
   164dc:	00193f00 	call	193f0 <printf>
   164e0:	003fff06 	br	164e0 <etharp_find_entry+0x38c>
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
   164e4:	e0bffbc3 	ldbu	r2,-17(fp)
   164e8:	00c00134 	movhi	r3,4
   164ec:	18d73904 	addi	r3,r3,23780
   164f0:	10800524 	muli	r2,r2,20
   164f4:	1885883a 	add	r2,r3,r2
   164f8:	10800404 	addi	r2,r2,16
   164fc:	10800083 	ldbu	r2,2(r2)
   16500:	10803fcc 	andi	r2,r2,255
   16504:	10000926 	beq	r2,zero,1652c <etharp_find_entry+0x3d8>
   16508:	010000f4 	movhi	r4,3
   1650c:	2103ce04 	addi	r4,r4,3896
   16510:	014000f4 	movhi	r5,3
   16514:	29440404 	addi	r5,r5,4112
   16518:	01806244 	movi	r6,393
   1651c:	01c000f4 	movhi	r7,3
   16520:	39c3db04 	addi	r7,r7,3948
   16524:	00193f00 	call	193f0 <printf>
   16528:	003fff06 	br	16528 <etharp_find_entry+0x3d4>
    arp_table[i].state == ETHARP_STATE_EMPTY);

  /* IP address given? */
  if (ipaddr != NULL) {
   1652c:	e0bffe17 	ldw	r2,-8(fp)
   16530:	10000926 	beq	r2,zero,16558 <etharp_find_entry+0x404>
    /* set IP address */
    ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
   16534:	e0bffbc3 	ldbu	r2,-17(fp)
   16538:	e0fffe17 	ldw	r3,-8(fp)
   1653c:	18c00017 	ldw	r3,0(r3)
   16540:	01000134 	movhi	r4,4
   16544:	21173904 	addi	r4,r4,23780
   16548:	10800524 	muli	r2,r2,20
   1654c:	2085883a 	add	r2,r4,r2
   16550:	10800104 	addi	r2,r2,4
   16554:	10c00015 	stw	r3,0(r2)
  }
  arp_table[i].ctime = 0;
   16558:	e0bffbc3 	ldbu	r2,-17(fp)
   1655c:	00c00134 	movhi	r3,4
   16560:	18d73904 	addi	r3,r3,23780
   16564:	10800524 	muli	r2,r2,20
   16568:	1885883a 	add	r2,r3,r2
   1656c:	10800404 	addi	r2,r2,16
   16570:	100000c5 	stb	zero,3(r2)
  return (err_t)i;
   16574:	e0bffbc3 	ldbu	r2,-17(fp)
}
   16578:	e037883a 	mov	sp,fp
   1657c:	dfc00117 	ldw	ra,4(sp)
   16580:	df000017 	ldw	fp,0(sp)
   16584:	dec00204 	addi	sp,sp,8
   16588:	f800283a 	ret

0001658c <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
   1658c:	defff904 	addi	sp,sp,-28
   16590:	dfc00615 	stw	ra,24(sp)
   16594:	df000515 	stw	fp,20(sp)
   16598:	df000504 	addi	fp,sp,20
   1659c:	e13ffc15 	stw	r4,-16(fp)
   165a0:	e17ffd15 	stw	r5,-12(fp)
   165a4:	e1bffe15 	stw	r6,-8(fp)
   165a8:	e1ffff15 	stw	r7,-4(fp)
  struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
   165ac:	e0bffd17 	ldw	r2,-12(fp)
   165b0:	10800117 	ldw	r2,4(r2)
   165b4:	e0bffb15 	stw	r2,-20(fp)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
   165b8:	e0bffc17 	ldw	r2,-16(fp)
   165bc:	10800983 	ldbu	r2,38(r2)
   165c0:	10803fcc 	andi	r2,r2,255
   165c4:	108001a0 	cmpeqi	r2,r2,6
   165c8:	1000091e 	bne	r2,zero,165f0 <etharp_send_ip+0x64>
   165cc:	010000f4 	movhi	r4,3
   165d0:	2103ce04 	addi	r4,r4,3896
   165d4:	014000f4 	movhi	r5,3
   165d8:	29440f04 	addi	r5,r5,4156
   165dc:	01806904 	movi	r6,420
   165e0:	01c000f4 	movhi	r7,3
   165e4:	39c3db04 	addi	r7,r7,3948
   165e8:	00193f00 	call	193f0 <printf>
   165ec:	003fff06 	br	165ec <etharp_send_ip+0x60>
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  ETHADDR32_COPY(&ethhdr->dest, dst);
   165f0:	e0bffb17 	ldw	r2,-20(fp)
   165f4:	10800084 	addi	r2,r2,2
   165f8:	1009883a 	mov	r4,r2
   165fc:	e17fff17 	ldw	r5,-4(fp)
   16600:	01800184 	movi	r6,6
   16604:	00191f00 	call	191f0 <memcpy>
  ETHADDR16_COPY(&ethhdr->src, src);
   16608:	e0bffb17 	ldw	r2,-20(fp)
   1660c:	10800204 	addi	r2,r2,8
   16610:	1009883a 	mov	r4,r2
   16614:	e17ffe17 	ldw	r5,-8(fp)
   16618:	01800184 	movi	r6,6
   1661c:	00191f00 	call	191f0 <memcpy>
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
   16620:	e0bffb17 	ldw	r2,-20(fp)
   16624:	00c00204 	movi	r3,8
   16628:	10c0038d 	sth	r3,14(r2)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
   1662c:	e0bffc17 	ldw	r2,-16(fp)
   16630:	10800617 	ldw	r2,24(r2)
   16634:	e13ffc17 	ldw	r4,-16(fp)
   16638:	e17ffd17 	ldw	r5,-12(fp)
   1663c:	103ee83a 	callr	r2
}
   16640:	e037883a 	mov	sp,fp
   16644:	dfc00117 	ldw	ra,4(sp)
   16648:	df000017 	ldw	fp,0(sp)
   1664c:	dec00204 	addi	sp,sp,8
   16650:	f800283a 	ret

00016654 <etharp_update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
etharp_update_arp_entry(struct netif *netif, ip_addr_t *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
   16654:	defff704 	addi	sp,sp,-36
   16658:	dfc00815 	stw	ra,32(sp)
   1665c:	df000715 	stw	fp,28(sp)
   16660:	df000704 	addi	fp,sp,28
   16664:	e13ffc15 	stw	r4,-16(fp)
   16668:	e17ffd15 	stw	r5,-12(fp)
   1666c:	e1bffe15 	stw	r6,-8(fp)
   16670:	3805883a 	mov	r2,r7
   16674:	e0bfff05 	stb	r2,-4(fp)
  s8_t i;
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
   16678:	e0bffc17 	ldw	r2,-16(fp)
   1667c:	10800983 	ldbu	r2,38(r2)
   16680:	10803fcc 	andi	r2,r2,255
   16684:	108001a0 	cmpeqi	r2,r2,6
   16688:	1000091e 	bne	r2,zero,166b0 <etharp_update_arp_entry+0x5c>
   1668c:	010000f4 	movhi	r4,3
   16690:	2103ce04 	addi	r4,r4,3896
   16694:	014000f4 	movhi	r5,3
   16698:	29442004 	addi	r5,r5,4224
   1669c:	018070c4 	movi	r6,451
   166a0:	01c000f4 	movhi	r7,3
   166a4:	39c3db04 	addi	r7,r7,3948
   166a8:	00193f00 	call	193f0 <printf>
   166ac:	003fff06 	br	166ac <etharp_update_arp_entry+0x58>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
   166b0:	e0bffd17 	ldw	r2,-12(fp)
   166b4:	10000f26 	beq	r2,zero,166f4 <etharp_update_arp_entry+0xa0>
   166b8:	e0bffd17 	ldw	r2,-12(fp)
   166bc:	10800017 	ldw	r2,0(r2)
   166c0:	10000c26 	beq	r2,zero,166f4 <etharp_update_arp_entry+0xa0>
      ip_addr_isbroadcast(ipaddr, netif) ||
   166c4:	e0bffd17 	ldw	r2,-12(fp)
   166c8:	10800017 	ldw	r2,0(r2)
   166cc:	1009883a 	mov	r4,r2
   166d0:	e17ffc17 	ldw	r5,-16(fp)
   166d4:	0006da80 	call	6da8 <ip4_addr_isbroadcast>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
   166d8:	10803fcc 	andi	r2,r2,255
   166dc:	1000051e 	bne	r2,zero,166f4 <etharp_update_arp_entry+0xa0>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
   166e0:	e0bffd17 	ldw	r2,-12(fp)
   166e4:	10800017 	ldw	r2,0(r2)
   166e8:	10803c0c 	andi	r2,r2,240
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
   166ec:	10803818 	cmpnei	r2,r2,224
   166f0:	1000021e 	bne	r2,zero,166fc <etharp_update_arp_entry+0xa8>
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
   166f4:	00bffc84 	movi	r2,-14
   166f8:	00005a06 	br	16864 <etharp_update_arp_entry+0x210>
  }
  /* find or create ARP entry */
  i = etharp_find_entry(ipaddr, flags);
   166fc:	e0bfff03 	ldbu	r2,-4(fp)
   16700:	e13ffd17 	ldw	r4,-12(fp)
   16704:	100b883a 	mov	r5,r2
   16708:	00161540 	call	16154 <etharp_find_entry>
   1670c:	e0bff905 	stb	r2,-28(fp)
  /* bail out if no entry could be found */
  if (i < 0) {
   16710:	e0bff907 	ldb	r2,-28(fp)
   16714:	1000020e 	bge	r2,zero,16720 <etharp_update_arp_entry+0xcc>
    return (err_t)i;
   16718:	e0bff903 	ldbu	r2,-28(fp)
   1671c:	00005106 	br	16864 <etharp_update_arp_entry+0x210>
    arp_table[i].state = ETHARP_STATE_STATIC;
  } else
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
  {
    /* mark it stable */
    arp_table[i].state = ETHARP_STATE_STABLE;
   16720:	e0bff907 	ldb	r2,-28(fp)
   16724:	00c00134 	movhi	r3,4
   16728:	18d73904 	addi	r3,r3,23780
   1672c:	10800524 	muli	r2,r2,20
   16730:	1885883a 	add	r2,r3,r2
   16734:	10800404 	addi	r2,r2,16
   16738:	00c00084 	movi	r3,2
   1673c:	10c00085 	stb	r3,2(r2)
  }

  /* record network interface */
  arp_table[i].netif = netif;
   16740:	e0bff907 	ldb	r2,-28(fp)
   16744:	00c00134 	movhi	r3,4
   16748:	18d73904 	addi	r3,r3,23780
   1674c:	10800524 	muli	r2,r2,20
   16750:	1885883a 	add	r2,r3,r2
   16754:	10800204 	addi	r2,r2,8
   16758:	e0fffc17 	ldw	r3,-16(fp)
   1675c:	10c00015 	stw	r3,0(r2)
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
   16760:	e0bff907 	ldb	r2,-28(fp)
   16764:	10800524 	muli	r2,r2,20
   16768:	10c00304 	addi	r3,r2,12
   1676c:	00800134 	movhi	r2,4
   16770:	10973904 	addi	r2,r2,23780
   16774:	1885883a 	add	r2,r3,r2
   16778:	e0fffe17 	ldw	r3,-8(fp)
   1677c:	19000003 	ldbu	r4,0(r3)
   16780:	11000005 	stb	r4,0(r2)
   16784:	19000043 	ldbu	r4,1(r3)
   16788:	11000045 	stb	r4,1(r2)
   1678c:	19000083 	ldbu	r4,2(r3)
   16790:	11000085 	stb	r4,2(r2)
   16794:	190000c3 	ldbu	r4,3(r3)
   16798:	110000c5 	stb	r4,3(r2)
   1679c:	19000103 	ldbu	r4,4(r3)
   167a0:	11000105 	stb	r4,4(r2)
   167a4:	18c00143 	ldbu	r3,5(r3)
   167a8:	10c00145 	stb	r3,5(r2)
  /* reset time stamp */
  arp_table[i].ctime = 0;
   167ac:	e0bff907 	ldb	r2,-28(fp)
   167b0:	00c00134 	movhi	r3,4
   167b4:	18d73904 	addi	r3,r3,23780
   167b8:	10800524 	muli	r2,r2,20
   167bc:	1885883a 	add	r2,r3,r2
   167c0:	10800404 	addi	r2,r2,16
   167c4:	100000c5 	stb	zero,3(r2)
  /* this is where we will send out queued packets! */
#if ARP_QUEUEING
  while (arp_table[i].q != NULL) {
   167c8:	00001e06 	br	16844 <etharp_update_arp_entry+0x1f0>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
   167cc:	e0bff907 	ldb	r2,-28(fp)
   167d0:	00c00134 	movhi	r3,4
   167d4:	18d73904 	addi	r3,r3,23780
   167d8:	10800524 	muli	r2,r2,20
   167dc:	1885883a 	add	r2,r3,r2
   167e0:	10800017 	ldw	r2,0(r2)
   167e4:	e0bffa15 	stw	r2,-24(fp)
    /* pop first item off the queue */
    arp_table[i].q = q->next;
   167e8:	e0bff907 	ldb	r2,-28(fp)
   167ec:	e0fffa17 	ldw	r3,-24(fp)
   167f0:	18c00017 	ldw	r3,0(r3)
   167f4:	01000134 	movhi	r4,4
   167f8:	21173904 	addi	r4,r4,23780
   167fc:	10800524 	muli	r2,r2,20
   16800:	2085883a 	add	r2,r4,r2
   16804:	10c00015 	stw	r3,0(r2)
    /* get the packet pointer */
    p = q->p;
   16808:	e0bffa17 	ldw	r2,-24(fp)
   1680c:	10800117 	ldw	r2,4(r2)
   16810:	e0bffb15 	stw	r2,-20(fp)
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
   16814:	01000184 	movi	r4,6
   16818:	e17ffa17 	ldw	r5,-24(fp)
   1681c:	00097d40 	call	97d4 <memp_free>
  if (arp_table[i].q != NULL) {
    struct pbuf *p = arp_table[i].q;
    arp_table[i].q = NULL;
#endif /* ARP_QUEUEING */
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
   16820:	e0bffc17 	ldw	r2,-16(fp)
   16824:	108009c4 	addi	r2,r2,39
   16828:	e13ffc17 	ldw	r4,-16(fp)
   1682c:	e17ffb17 	ldw	r5,-20(fp)
   16830:	100d883a 	mov	r6,r2
   16834:	e1fffe17 	ldw	r7,-8(fp)
   16838:	001658c0 	call	1658c <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
   1683c:	e13ffb17 	ldw	r4,-20(fp)
   16840:	000aa340 	call	aa34 <pbuf_free>
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
  /* reset time stamp */
  arp_table[i].ctime = 0;
  /* this is where we will send out queued packets! */
#if ARP_QUEUEING
  while (arp_table[i].q != NULL) {
   16844:	e0bff907 	ldb	r2,-28(fp)
   16848:	00c00134 	movhi	r3,4
   1684c:	18d73904 	addi	r3,r3,23780
   16850:	10800524 	muli	r2,r2,20
   16854:	1885883a 	add	r2,r3,r2
   16858:	10800017 	ldw	r2,0(r2)
   1685c:	103fdb1e 	bne	r2,zero,167cc <etharp_update_arp_entry+0x178>
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
    /* free the queued IP packet */
    pbuf_free(p);
  }
  return ERR_OK;
   16860:	0005883a 	mov	r2,zero
}
   16864:	e037883a 	mov	sp,fp
   16868:	dfc00117 	ldw	ra,4(sp)
   1686c:	df000017 	ldw	fp,0(sp)
   16870:	dec00204 	addi	sp,sp,8
   16874:	f800283a 	ret

00016878 <etharp_cleanup_netif>:
 * Remove all ARP table entries of the specified netif.
 *
 * @param netif points to a network interface
 */
void etharp_cleanup_netif(struct netif *netif)
{
   16878:	defffc04 	addi	sp,sp,-16
   1687c:	dfc00315 	stw	ra,12(sp)
   16880:	df000215 	stw	fp,8(sp)
   16884:	df000204 	addi	fp,sp,8
   16888:	e13fff15 	stw	r4,-4(fp)
  u8_t i;

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
   1688c:	e03ffe05 	stb	zero,-8(fp)
   16890:	00001906 	br	168f8 <etharp_cleanup_netif+0x80>
    u8_t state = arp_table[i].state;
   16894:	e0bffe03 	ldbu	r2,-8(fp)
   16898:	00c00134 	movhi	r3,4
   1689c:	18d73904 	addi	r3,r3,23780
   168a0:	10800524 	muli	r2,r2,20
   168a4:	1885883a 	add	r2,r3,r2
   168a8:	10800404 	addi	r2,r2,16
   168ac:	10800083 	ldbu	r2,2(r2)
   168b0:	e0bffe45 	stb	r2,-7(fp)
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
   168b4:	e0bffe43 	ldbu	r2,-7(fp)
   168b8:	10000c26 	beq	r2,zero,168ec <etharp_cleanup_netif+0x74>
   168bc:	e0bffe03 	ldbu	r2,-8(fp)
   168c0:	00c00134 	movhi	r3,4
   168c4:	18d73904 	addi	r3,r3,23780
   168c8:	10800524 	muli	r2,r2,20
   168cc:	1885883a 	add	r2,r3,r2
   168d0:	10800204 	addi	r2,r2,8
   168d4:	10c00017 	ldw	r3,0(r2)
   168d8:	e0bfff17 	ldw	r2,-4(fp)
   168dc:	1880031e 	bne	r3,r2,168ec <etharp_cleanup_netif+0x74>
      etharp_free_entry(i);
   168e0:	e0bffe03 	ldbu	r2,-8(fp)
   168e4:	1009883a 	mov	r4,r2
   168e8:	0015f480 	call	15f48 <etharp_free_entry>
 */
void etharp_cleanup_netif(struct netif *netif)
{
  u8_t i;

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
   168ec:	e0bffe03 	ldbu	r2,-8(fp)
   168f0:	10800044 	addi	r2,r2,1
   168f4:	e0bffe05 	stb	r2,-8(fp)
   168f8:	e0bffe03 	ldbu	r2,-8(fp)
   168fc:	108002b0 	cmpltui	r2,r2,10
   16900:	103fe41e 	bne	r2,zero,16894 <etharp_cleanup_netif+0x1c>
    u8_t state = arp_table[i].state;
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
      etharp_free_entry(i);
    }
  }
}
   16904:	e037883a 	mov	sp,fp
   16908:	dfc00117 	ldw	ra,4(sp)
   1690c:	df000017 	ldw	fp,0(sp)
   16910:	dec00204 	addi	sp,sp,8
   16914:	f800283a 	ret

00016918 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, ip_addr_t *ipaddr,
         struct eth_addr **eth_ret, ip_addr_t **ip_ret)
{
   16918:	defff904 	addi	sp,sp,-28
   1691c:	dfc00615 	stw	ra,24(sp)
   16920:	df000515 	stw	fp,20(sp)
   16924:	df000504 	addi	fp,sp,20
   16928:	e13ffc15 	stw	r4,-16(fp)
   1692c:	e17ffd15 	stw	r5,-12(fp)
   16930:	e1bffe15 	stw	r6,-8(fp)
   16934:	e1ffff15 	stw	r7,-4(fp)
  s8_t i;

  LWIP_ASSERT("eth_ret != NULL && ip_ret != NULL",
   16938:	e0bffe17 	ldw	r2,-8(fp)
   1693c:	10000226 	beq	r2,zero,16948 <etharp_find_addr+0x30>
   16940:	e0bfff17 	ldw	r2,-4(fp)
   16944:	1000091e 	bne	r2,zero,1696c <etharp_find_addr+0x54>
   16948:	010000f4 	movhi	r4,3
   1694c:	2103ce04 	addi	r4,r4,3896
   16950:	014000f4 	movhi	r5,3
   16954:	29442a04 	addi	r5,r5,4264
   16958:	01809844 	movi	r6,609
   1695c:	01c000f4 	movhi	r7,3
   16960:	39c3db04 	addi	r7,r7,3948
   16964:	00193f00 	call	193f0 <printf>
   16968:	003fff06 	br	16968 <etharp_find_addr+0x50>
    eth_ret != NULL && ip_ret != NULL);

  LWIP_UNUSED_ARG(netif);

  i = etharp_find_entry(ipaddr, ETHARP_FLAG_FIND_ONLY);
   1696c:	e13ffd17 	ldw	r4,-12(fp)
   16970:	01400084 	movi	r5,2
   16974:	00161540 	call	16154 <etharp_find_entry>
   16978:	e0bffb05 	stb	r2,-20(fp)
  if((i >= 0) && (arp_table[i].state >= ETHARP_STATE_STABLE)) {
   1697c:	e0bffb07 	ldb	r2,-20(fp)
   16980:	10001c16 	blt	r2,zero,169f4 <etharp_find_addr+0xdc>
   16984:	e0bffb07 	ldb	r2,-20(fp)
   16988:	00c00134 	movhi	r3,4
   1698c:	18d73904 	addi	r3,r3,23780
   16990:	10800524 	muli	r2,r2,20
   16994:	1885883a 	add	r2,r3,r2
   16998:	10800404 	addi	r2,r2,16
   1699c:	10800083 	ldbu	r2,2(r2)
   169a0:	10803fcc 	andi	r2,r2,255
   169a4:	108000b0 	cmpltui	r2,r2,2
   169a8:	1000121e 	bne	r2,zero,169f4 <etharp_find_addr+0xdc>
      *eth_ret = &arp_table[i].ethaddr;
   169ac:	e0bffb07 	ldb	r2,-20(fp)
   169b0:	10800524 	muli	r2,r2,20
   169b4:	10c00304 	addi	r3,r2,12
   169b8:	00800134 	movhi	r2,4
   169bc:	10973904 	addi	r2,r2,23780
   169c0:	1887883a 	add	r3,r3,r2
   169c4:	e0bffe17 	ldw	r2,-8(fp)
   169c8:	10c00015 	stw	r3,0(r2)
      *ip_ret = &arp_table[i].ipaddr;
   169cc:	e0bffb07 	ldb	r2,-20(fp)
   169d0:	10800524 	muli	r2,r2,20
   169d4:	10c00104 	addi	r3,r2,4
   169d8:	00800134 	movhi	r2,4
   169dc:	10973904 	addi	r2,r2,23780
   169e0:	1887883a 	add	r3,r3,r2
   169e4:	e0bfff17 	ldw	r2,-4(fp)
   169e8:	10c00015 	stw	r3,0(r2)
      return i;
   169ec:	e0bffb03 	ldbu	r2,-20(fp)
   169f0:	00000106 	br	169f8 <etharp_find_addr+0xe0>
  }
  return -1;
   169f4:	00bfffc4 	movi	r2,-1
}
   169f8:	e037883a 	mov	sp,fp
   169fc:	dfc00117 	ldw	ra,4(sp)
   16a00:	df000017 	ldw	fp,0(sp)
   16a04:	dec00204 	addi	sp,sp,8
   16a08:	f800283a 	ret

00016a0c <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
static void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
   16a0c:	defff904 	addi	sp,sp,-28
   16a10:	dfc00615 	stw	ra,24(sp)
   16a14:	df000515 	stw	fp,20(sp)
   16a18:	df000504 	addi	fp,sp,20
   16a1c:	e13ffe15 	stw	r4,-8(fp)
   16a20:	e17fff15 	stw	r5,-4(fp)
  struct eth_hdr *ethhdr;
  struct ip_hdr *iphdr;
  ip_addr_t iphdr_src;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
   16a24:	e0bffe17 	ldw	r2,-8(fp)
   16a28:	1000091e 	bne	r2,zero,16a50 <etharp_ip_input+0x44>
   16a2c:	010000f4 	movhi	r4,3
   16a30:	2103ce04 	addi	r4,r4,3896
   16a34:	014000f4 	movhi	r5,3
   16a38:	29443304 	addi	r5,r5,4300
   16a3c:	0180a104 	movi	r6,644
   16a40:	01c000f4 	movhi	r7,3
   16a44:	39c3db04 	addi	r7,r7,3948
   16a48:	00193f00 	call	193f0 <printf>
   16a4c:	003fff06 	br	16a4c <etharp_ip_input+0x40>

  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  ethhdr = (struct eth_hdr *)p->payload;
   16a50:	e0bfff17 	ldw	r2,-4(fp)
   16a54:	10800117 	ldw	r2,4(r2)
   16a58:	e0bffb15 	stw	r2,-20(fp)
  iphdr = (struct ip_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
   16a5c:	e0bffb17 	ldw	r2,-20(fp)
   16a60:	10800404 	addi	r2,r2,16
   16a64:	e0bffc15 	stw	r2,-16(fp)
  if (ethhdr->type == PP_HTONS(ETHTYPE_VLAN)) {
    iphdr = (struct ip_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  ip_addr_copy(iphdr_src, iphdr->src);
   16a68:	e0bffc17 	ldw	r2,-16(fp)
   16a6c:	10c0030b 	ldhu	r3,12(r2)
   16a70:	1080038b 	ldhu	r2,14(r2)
   16a74:	1004943a 	slli	r2,r2,16
   16a78:	10c4b03a 	or	r2,r2,r3
   16a7c:	e0bffd15 	stw	r2,-12(fp)

  /* source is not on the local network? */
  if (!ip_addr_netcmp(&iphdr_src, &(netif->ip_addr), &(netif->netmask))) {
   16a80:	e0fffd17 	ldw	r3,-12(fp)
   16a84:	e0bffe17 	ldw	r2,-8(fp)
   16a88:	10800117 	ldw	r2,4(r2)
   16a8c:	1886f03a 	xor	r3,r3,r2
   16a90:	e0bffe17 	ldw	r2,-8(fp)
   16a94:	10800217 	ldw	r2,8(r2)
   16a98:	1884703a 	and	r2,r3,r2
   16a9c:	1000081e 	bne	r2,zero,16ac0 <etharp_ip_input+0xb4>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update the source IP address in the cache, if present */
  /* @todo We could use ETHARP_FLAG_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  etharp_update_arp_entry(netif, &iphdr_src, &(ethhdr->src), ETHARP_FLAG_FIND_ONLY);
   16aa0:	e0bffb17 	ldw	r2,-20(fp)
   16aa4:	10800204 	addi	r2,r2,8
   16aa8:	e0fffd04 	addi	r3,fp,-12
   16aac:	e13ffe17 	ldw	r4,-8(fp)
   16ab0:	180b883a 	mov	r5,r3
   16ab4:	100d883a 	mov	r6,r2
   16ab8:	01c00084 	movi	r7,2
   16abc:	00166540 	call	16654 <etharp_update_arp_entry>
}
   16ac0:	e037883a 	mov	sp,fp
   16ac4:	dfc00117 	ldw	ra,4(sp)
   16ac8:	df000017 	ldw	fp,0(sp)
   16acc:	dec00204 	addi	sp,sp,8
   16ad0:	f800283a 	ret

00016ad4 <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
static void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
   16ad4:	defff604 	addi	sp,sp,-40
   16ad8:	dfc00915 	stw	ra,36(sp)
   16adc:	df000815 	stw	fp,32(sp)
   16ae0:	df000804 	addi	fp,sp,32
   16ae4:	e13ffd15 	stw	r4,-12(fp)
   16ae8:	e17ffe15 	stw	r5,-8(fp)
   16aec:	e1bfff15 	stw	r6,-4(fp)
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
   16af0:	e0bffd17 	ldw	r2,-12(fp)
   16af4:	1000091e 	bne	r2,zero,16b1c <etharp_arp_input+0x48>
   16af8:	010000f4 	movhi	r4,3
   16afc:	2103ce04 	addi	r4,r4,3896
   16b00:	014000f4 	movhi	r5,3
   16b04:	29443304 	addi	r5,r5,4300
   16b08:	0180aec4 	movi	r6,699
   16b0c:	01c000f4 	movhi	r7,3
   16b10:	39c3db04 	addi	r7,r7,3948
   16b14:	00193f00 	call	193f0 <printf>
   16b18:	003fff06 	br	16b18 <etharp_arp_input+0x44>

  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < SIZEOF_ETHARP_PACKET) {
   16b1c:	e0bfff17 	ldw	r2,-4(fp)
   16b20:	1080028b 	ldhu	r2,10(r2)
   16b24:	10bfffcc 	andi	r2,r2,65535
   16b28:	10800b28 	cmpgeui	r2,r2,44
   16b2c:	1000131e 	bne	r2,zero,16b7c <etharp_arp_input+0xa8>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len,
      (s16_t)SIZEOF_ETHARP_PACKET));
    ETHARP_STATS_INC(etharp.lenerr);
   16b30:	00800234 	movhi	r2,8
   16b34:	1083bd04 	addi	r2,r2,3828
   16b38:	1080088b 	ldhu	r2,34(r2)
   16b3c:	10800044 	addi	r2,r2,1
   16b40:	1007883a 	mov	r3,r2
   16b44:	00800234 	movhi	r2,8
   16b48:	1083bd04 	addi	r2,r2,3828
   16b4c:	10c0088d 	sth	r3,34(r2)
    ETHARP_STATS_INC(etharp.drop);
   16b50:	00800234 	movhi	r2,8
   16b54:	1083bd04 	addi	r2,r2,3828
   16b58:	1080078b 	ldhu	r2,30(r2)
   16b5c:	10800044 	addi	r2,r2,1
   16b60:	1007883a 	mov	r3,r2
   16b64:	00800234 	movhi	r2,8
   16b68:	1083bd04 	addi	r2,r2,3828
   16b6c:	10c0078d 	sth	r3,30(r2)
    pbuf_free(p);
   16b70:	e13fff17 	ldw	r4,-4(fp)
   16b74:	000aa340 	call	aa34 <pbuf_free>
   16b78:	0000ba06 	br	16e64 <etharp_arp_input+0x390>
    return;
  }

  ethhdr = (struct eth_hdr *)p->payload;
   16b7c:	e0bfff17 	ldw	r2,-4(fp)
   16b80:	10800117 	ldw	r2,4(r2)
   16b84:	e0bff915 	stw	r2,-28(fp)
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
   16b88:	e0bff917 	ldw	r2,-28(fp)
   16b8c:	10800404 	addi	r2,r2,16
   16b90:	e0bffa15 	stw	r2,-24(fp)
    hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
   16b94:	e0bffa17 	ldw	r2,-24(fp)
   16b98:	1080000b 	ldhu	r2,0(r2)
   16b9c:	10bfffcc 	andi	r2,r2,65535
   16ba0:	10804018 	cmpnei	r2,r2,256
   16ba4:	10000f1e 	bne	r2,zero,16be4 <etharp_arp_input+0x110>
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
   16ba8:	e0bffa17 	ldw	r2,-24(fp)
   16bac:	10800103 	ldbu	r2,4(r2)
    hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
   16bb0:	10803fcc 	andi	r2,r2,255
   16bb4:	10800198 	cmpnei	r2,r2,6
   16bb8:	10000a1e 	bne	r2,zero,16be4 <etharp_arp_input+0x110>
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
      (hdr->protolen != sizeof(ip_addr_t)) ||
   16bbc:	e0bffa17 	ldw	r2,-24(fp)
   16bc0:	10800143 	ldbu	r2,5(r2)
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
   16bc4:	10803fcc 	andi	r2,r2,255
   16bc8:	10800118 	cmpnei	r2,r2,4
   16bcc:	1000051e 	bne	r2,zero,16be4 <etharp_arp_input+0x110>
      (hdr->protolen != sizeof(ip_addr_t)) ||
      (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
   16bd0:	e0bffa17 	ldw	r2,-24(fp)
   16bd4:	1080008b 	ldhu	r2,2(r2)
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
      (hdr->protolen != sizeof(ip_addr_t)) ||
   16bd8:	10bfffcc 	andi	r2,r2,65535
   16bdc:	10800220 	cmpeqi	r2,r2,8
   16be0:	1000131e 	bne	r2,zero,16c30 <etharp_arp_input+0x15c>
      (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, hdr->hwlen, hdr->proto, hdr->protolen));
    ETHARP_STATS_INC(etharp.proterr);
   16be4:	00800234 	movhi	r2,8
   16be8:	1083bd04 	addi	r2,r2,3828
   16bec:	10800a0b 	ldhu	r2,40(r2)
   16bf0:	10800044 	addi	r2,r2,1
   16bf4:	1007883a 	mov	r3,r2
   16bf8:	00800234 	movhi	r2,8
   16bfc:	1083bd04 	addi	r2,r2,3828
   16c00:	10c00a0d 	sth	r3,40(r2)
    ETHARP_STATS_INC(etharp.drop);
   16c04:	00800234 	movhi	r2,8
   16c08:	1083bd04 	addi	r2,r2,3828
   16c0c:	1080078b 	ldhu	r2,30(r2)
   16c10:	10800044 	addi	r2,r2,1
   16c14:	1007883a 	mov	r3,r2
   16c18:	00800234 	movhi	r2,8
   16c1c:	1083bd04 	addi	r2,r2,3828
   16c20:	10c0078d 	sth	r3,30(r2)
    pbuf_free(p);
   16c24:	e13fff17 	ldw	r4,-4(fp)
   16c28:	000aa340 	call	aa34 <pbuf_free>
   16c2c:	00008d06 	br	16e64 <etharp_arp_input+0x390>
    return;
  }
  ETHARP_STATS_INC(etharp.recv);
   16c30:	00800234 	movhi	r2,8
   16c34:	1083bd04 	addi	r2,r2,3828
   16c38:	1080068b 	ldhu	r2,26(r2)
   16c3c:	10800044 	addi	r2,r2,1
   16c40:	1007883a 	mov	r3,r2
   16c44:	00800234 	movhi	r2,8
   16c48:	1083bd04 	addi	r2,r2,3828
   16c4c:	10c0068d 	sth	r3,26(r2)
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
   16c50:	e0bffa17 	ldw	r2,-24(fp)
   16c54:	10800384 	addi	r2,r2,14
   16c58:	e0fffb04 	addi	r3,fp,-20
   16c5c:	1809883a 	mov	r4,r3
   16c60:	100b883a 	mov	r5,r2
   16c64:	01800104 	movi	r6,4
   16c68:	00191f00 	call	191f0 <memcpy>
  IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
   16c6c:	e0bffa17 	ldw	r2,-24(fp)
   16c70:	10800604 	addi	r2,r2,24
   16c74:	e0fffc04 	addi	r3,fp,-16
   16c78:	1809883a 	mov	r4,r3
   16c7c:	100b883a 	mov	r5,r2
   16c80:	01800104 	movi	r6,4
   16c84:	00191f00 	call	191f0 <memcpy>

  /* this interface is not configured? */
  if (ip_addr_isany(&netif->ip_addr)) {
   16c88:	e0bffd17 	ldw	r2,-12(fp)
   16c8c:	10800104 	addi	r2,r2,4
   16c90:	10000326 	beq	r2,zero,16ca0 <etharp_arp_input+0x1cc>
   16c94:	e0bffd17 	ldw	r2,-12(fp)
   16c98:	10800117 	ldw	r2,4(r2)
   16c9c:	1000021e 	bne	r2,zero,16ca8 <etharp_arp_input+0x1d4>
    for_us = 0;
   16ca0:	e03ff805 	stb	zero,-32(fp)
   16ca4:	00000506 	br	16cbc <etharp_arp_input+0x1e8>
  } else {
    /* ARP packet directed to us? */
    for_us = (u8_t)ip_addr_cmp(&dipaddr, &(netif->ip_addr));
   16ca8:	e0fffc17 	ldw	r3,-16(fp)
   16cac:	e0bffd17 	ldw	r2,-12(fp)
   16cb0:	10800117 	ldw	r2,4(r2)
   16cb4:	1885003a 	cmpeq	r2,r3,r2
   16cb8:	e0bff805 	stb	r2,-32(fp)
  /* ARP message directed to us?
      -> add IP address in ARP cache; assume requester wants to talk to us,
         can result in directly sending the queued packets for this host.
     ARP message not directed to us?
      ->  update the source IP address in the cache, if present */
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
   16cbc:	e0bffa17 	ldw	r2,-24(fp)
   16cc0:	10c00204 	addi	r3,r2,8
   16cc4:	e0bff803 	ldbu	r2,-32(fp)
   16cc8:	10000226 	beq	r2,zero,16cd4 <etharp_arp_input+0x200>
   16ccc:	00800044 	movi	r2,1
   16cd0:	00000106 	br	16cd8 <etharp_arp_input+0x204>
   16cd4:	00800084 	movi	r2,2
   16cd8:	e17ffb04 	addi	r5,fp,-20
   16cdc:	e13ffd17 	ldw	r4,-12(fp)
   16ce0:	180d883a 	mov	r6,r3
   16ce4:	100f883a 	mov	r7,r2
   16ce8:	00166540 	call	16654 <etharp_update_arp_entry>
                   for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);

  /* now act on the message itself */
  switch (hdr->opcode) {
   16cec:	e0bffa17 	ldw	r2,-24(fp)
   16cf0:	1080018b 	ldhu	r2,6(r2)
   16cf4:	10bfffcc 	andi	r2,r2,65535
   16cf8:	10c04020 	cmpeqi	r3,r2,256
   16cfc:	1800031e 	bne	r3,zero,16d0c <etharp_arp_input+0x238>
   16d00:	10808020 	cmpeqi	r2,r2,512
   16d04:	1000471e 	bne	r2,zero,16e24 <etharp_arp_input+0x350>
   16d08:	00004b06 	br	16e38 <etharp_arp_input+0x364>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
   16d0c:	e0bff803 	ldbu	r2,-32(fp)
   16d10:	10004326 	beq	r2,zero,16e20 <etharp_arp_input+0x34c>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
   16d14:	e0bffa17 	ldw	r2,-24(fp)
   16d18:	00c08004 	movi	r3,512
   16d1c:	10c0018d 	sth	r3,6(r2)

      IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
   16d20:	e0bffa17 	ldw	r2,-24(fp)
   16d24:	10c00604 	addi	r3,r2,24
   16d28:	e0bffa17 	ldw	r2,-24(fp)
   16d2c:	10800384 	addi	r2,r2,14
   16d30:	1809883a 	mov	r4,r3
   16d34:	100b883a 	mov	r5,r2
   16d38:	01800104 	movi	r6,4
   16d3c:	00191f00 	call	191f0 <memcpy>
      IPADDR2_COPY(&hdr->sipaddr, &netif->ip_addr);
   16d40:	e0bffa17 	ldw	r2,-24(fp)
   16d44:	10c00384 	addi	r3,r2,14
   16d48:	e0bffd17 	ldw	r2,-12(fp)
   16d4c:	10800104 	addi	r2,r2,4
   16d50:	1809883a 	mov	r4,r3
   16d54:	100b883a 	mov	r5,r2
   16d58:	01800104 	movi	r6,4
   16d5c:	00191f00 	call	191f0 <memcpy>

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
   16d60:	e0bffd17 	ldw	r2,-12(fp)
   16d64:	10800983 	ldbu	r2,38(r2)
   16d68:	10803fcc 	andi	r2,r2,255
   16d6c:	108001a0 	cmpeqi	r2,r2,6
   16d70:	1000091e 	bne	r2,zero,16d98 <etharp_arp_input+0x2c4>
   16d74:	010000f4 	movhi	r4,3
   16d78:	2103ce04 	addi	r4,r4,3896
   16d7c:	014000f4 	movhi	r5,3
   16d80:	29440f04 	addi	r5,r5,4156
   16d84:	0180c484 	movi	r6,786
   16d88:	01c000f4 	movhi	r7,3
   16d8c:	39c3db04 	addi	r7,r7,3948
   16d90:	00193f00 	call	193f0 <printf>
   16d94:	003fff06 	br	16d94 <etharp_arp_input+0x2c0>
       * 'sender IP address' MUST be sent using link-layer broadcast instead of
       * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
      ethdst_hwaddr = ip_addr_islinklocal(&netif->ip_addr) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
   16d98:	e0bffa17 	ldw	r2,-24(fp)
   16d9c:	10c00484 	addi	r3,r2,18
   16da0:	e0bffa17 	ldw	r2,-24(fp)
   16da4:	10800204 	addi	r2,r2,8
   16da8:	1809883a 	mov	r4,r3
   16dac:	100b883a 	mov	r5,r2
   16db0:	01800184 	movi	r6,6
   16db4:	00191f00 	call	191f0 <memcpy>
#if LWIP_AUTOIP
      ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
      ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
   16db8:	e0bff917 	ldw	r2,-28(fp)
   16dbc:	10c00084 	addi	r3,r2,2
   16dc0:	e0bffa17 	ldw	r2,-24(fp)
   16dc4:	10800204 	addi	r2,r2,8
   16dc8:	1809883a 	mov	r4,r3
   16dcc:	100b883a 	mov	r5,r2
   16dd0:	01800184 	movi	r6,6
   16dd4:	00191f00 	call	191f0 <memcpy>
#endif /* LWIP_AUTOIP */
      ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
   16dd8:	e0bffa17 	ldw	r2,-24(fp)
   16ddc:	10800204 	addi	r2,r2,8
   16de0:	1009883a 	mov	r4,r2
   16de4:	e17ffe17 	ldw	r5,-8(fp)
   16de8:	01800184 	movi	r6,6
   16dec:	00191f00 	call	191f0 <memcpy>
      ETHADDR16_COPY(&ethhdr->src, ethaddr);
   16df0:	e0bff917 	ldw	r2,-28(fp)
   16df4:	10800204 	addi	r2,r2,8
   16df8:	1009883a 	mov	r4,r2
   16dfc:	e17ffe17 	ldw	r5,-8(fp)
   16e00:	01800184 	movi	r6,6
   16e04:	00191f00 	call	191f0 <memcpy>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
   16e08:	e0bffd17 	ldw	r2,-12(fp)
   16e0c:	10800617 	ldw	r2,24(r2)
   16e10:	e13ffd17 	ldw	r4,-12(fp)
   16e14:	e17fff17 	ldw	r5,-4(fp)
   16e18:	103ee83a 	callr	r2
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
    }
    break;
   16e1c:	00000f06 	br	16e5c <etharp_arp_input+0x388>
   16e20:	00000e06 	br	16e5c <etharp_arp_input+0x388>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
   16e24:	e0bffb04 	addi	r2,fp,-20
   16e28:	e13ffd17 	ldw	r4,-12(fp)
   16e2c:	100b883a 	mov	r5,r2
   16e30:	0002f900 	call	2f90 <dhcp_arp_reply>
#endif /* (LWIP_DHCP && DHCP_DOES_ARP_CHECK) */
    break;
   16e34:	00000906 	br	16e5c <etharp_arp_input+0x388>
  default:
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
   16e38:	00800234 	movhi	r2,8
   16e3c:	1083bd04 	addi	r2,r2,3828
   16e40:	10800b0b 	ldhu	r2,44(r2)
   16e44:	10800044 	addi	r2,r2,1
   16e48:	1007883a 	mov	r3,r2
   16e4c:	00800234 	movhi	r2,8
   16e50:	1083bd04 	addi	r2,r2,3828
   16e54:	10c00b0d 	sth	r3,44(r2)
    break;
   16e58:	0001883a 	nop
  }
  /* free ARP packet */
  pbuf_free(p);
   16e5c:	e13fff17 	ldw	r4,-4(fp)
   16e60:	000aa340 	call	aa34 <pbuf_free>
}
   16e64:	e037883a 	mov	sp,fp
   16e68:	dfc00117 	ldw	ra,4(sp)
   16e6c:	df000017 	ldw	fp,0(sp)
   16e70:	dec00204 	addi	sp,sp,8
   16e74:	f800283a 	ret

00016e78 <etharp_output_to_arp_index>:
/** Just a small helper function that sends a pbuf to an ethernet address
 * in the arp_table specified by the index 'arp_idx'.
 */
static err_t
etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
{
   16e78:	defffb04 	addi	sp,sp,-20
   16e7c:	dfc00415 	stw	ra,16(sp)
   16e80:	df000315 	stw	fp,12(sp)
   16e84:	df000304 	addi	fp,sp,12
   16e88:	e13ffd15 	stw	r4,-12(fp)
   16e8c:	e17ffe15 	stw	r5,-8(fp)
   16e90:	3005883a 	mov	r2,r6
   16e94:	e0bfff05 	stb	r2,-4(fp)
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
   16e98:	e0bfff03 	ldbu	r2,-4(fp)
   16e9c:	00c00134 	movhi	r3,4
   16ea0:	18d73904 	addi	r3,r3,23780
   16ea4:	10800524 	muli	r2,r2,20
   16ea8:	1885883a 	add	r2,r3,r2
   16eac:	10800404 	addi	r2,r2,16
   16eb0:	10800083 	ldbu	r2,2(r2)
   16eb4:	10803fcc 	andi	r2,r2,255
   16eb8:	108000a8 	cmpgeui	r2,r2,2
   16ebc:	1000091e 	bne	r2,zero,16ee4 <etharp_output_to_arp_index+0x6c>
   16ec0:	010000f4 	movhi	r4,3
   16ec4:	2103ce04 	addi	r4,r4,3896
   16ec8:	014000f4 	movhi	r5,3
   16ecc:	29443704 	addi	r5,r5,4316
   16ed0:	0180d344 	movi	r6,845
   16ed4:	01c000f4 	movhi	r7,3
   16ed8:	39c3db04 	addi	r7,r7,3948
   16edc:	00193f00 	call	193f0 <printf>
   16ee0:	003fff06 	br	16ee0 <etharp_output_to_arp_index+0x68>
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
   16ee4:	e0bfff03 	ldbu	r2,-4(fp)
   16ee8:	00c00134 	movhi	r3,4
   16eec:	18d73904 	addi	r3,r3,23780
   16ef0:	10800524 	muli	r2,r2,20
   16ef4:	1885883a 	add	r2,r3,r2
   16ef8:	10800404 	addi	r2,r2,16
   16efc:	10800083 	ldbu	r2,2(r2)
   16f00:	10803fcc 	andi	r2,r2,255
   16f04:	10800098 	cmpnei	r2,r2,2
   16f08:	10001f1e 	bne	r2,zero,16f88 <etharp_output_to_arp_index+0x110>
      (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
   16f0c:	e0bfff03 	ldbu	r2,-4(fp)
   16f10:	00c00134 	movhi	r3,4
   16f14:	18d73904 	addi	r3,r3,23780
   16f18:	10800524 	muli	r2,r2,20
   16f1c:	1885883a 	add	r2,r3,r2
   16f20:	10800404 	addi	r2,r2,16
   16f24:	108000c3 	ldbu	r2,3(r2)
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
   16f28:	10803fcc 	andi	r2,r2,255
   16f2c:	10803930 	cmpltui	r2,r2,228
   16f30:	1000151e 	bne	r2,zero,16f88 <etharp_output_to_arp_index+0x110>
      (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
    if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
   16f34:	e0bfff03 	ldbu	r2,-4(fp)
   16f38:	10800524 	muli	r2,r2,20
   16f3c:	10c00104 	addi	r3,r2,4
   16f40:	00800134 	movhi	r2,4
   16f44:	10973904 	addi	r2,r2,23780
   16f48:	1885883a 	add	r2,r3,r2
   16f4c:	e13ffd17 	ldw	r4,-12(fp)
   16f50:	100b883a 	mov	r5,r2
   16f54:	0017a0c0 	call	17a0c <etharp_request>
   16f58:	10803fcc 	andi	r2,r2,255
   16f5c:	1080201c 	xori	r2,r2,128
   16f60:	10bfe004 	addi	r2,r2,-128
   16f64:	1000081e 	bne	r2,zero,16f88 <etharp_output_to_arp_index+0x110>
      arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
   16f68:	e0bfff03 	ldbu	r2,-4(fp)
   16f6c:	00c00134 	movhi	r3,4
   16f70:	18d73904 	addi	r3,r3,23780
   16f74:	10800524 	muli	r2,r2,20
   16f78:	1885883a 	add	r2,r3,r2
   16f7c:	10800404 	addi	r2,r2,16
   16f80:	00c000c4 	movi	r3,3
   16f84:	10c00085 	stb	r3,2(r2)
    }
  }
  
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
   16f88:	e0bffd17 	ldw	r2,-12(fp)
   16f8c:	10c009c4 	addi	r3,r2,39
    &arp_table[arp_idx].ethaddr);
   16f90:	e0bfff03 	ldbu	r2,-4(fp)
    if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
      arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
    }
  }
  
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
   16f94:	10800524 	muli	r2,r2,20
   16f98:	11000304 	addi	r4,r2,12
   16f9c:	00800134 	movhi	r2,4
   16fa0:	10973904 	addi	r2,r2,23780
   16fa4:	2085883a 	add	r2,r4,r2
   16fa8:	e13ffd17 	ldw	r4,-12(fp)
   16fac:	e17ffe17 	ldw	r5,-8(fp)
   16fb0:	180d883a 	mov	r6,r3
   16fb4:	100f883a 	mov	r7,r2
   16fb8:	001658c0 	call	1658c <etharp_send_ip>
    &arp_table[arp_idx].ethaddr);
}
   16fbc:	e037883a 	mov	sp,fp
   16fc0:	dfc00117 	ldw	ra,4(sp)
   16fc4:	df000017 	ldw	fp,0(sp)
   16fc8:	dec00204 	addi	sp,sp,8
   16fcc:	f800283a 	ret

00016fd0 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, ip_addr_t *ipaddr)
{
   16fd0:	defff704 	addi	sp,sp,-36
   16fd4:	dfc00815 	stw	ra,32(sp)
   16fd8:	df000715 	stw	fp,28(sp)
   16fdc:	df000704 	addi	fp,sp,28
   16fe0:	e13ffd15 	stw	r4,-12(fp)
   16fe4:	e17ffe15 	stw	r5,-8(fp)
   16fe8:	e1bfff15 	stw	r6,-4(fp)
  struct eth_addr *dest;
  struct eth_addr mcastaddr;
  ip_addr_t *dst_addr = ipaddr;
   16fec:	e0bfff17 	ldw	r2,-4(fp)
   16ff0:	e0bffa15 	stw	r2,-24(fp)

  LWIP_ASSERT("netif != NULL", netif != NULL);
   16ff4:	e0bffd17 	ldw	r2,-12(fp)
   16ff8:	1000091e 	bne	r2,zero,17020 <etharp_output+0x50>
   16ffc:	010000f4 	movhi	r4,3
   17000:	2103ce04 	addi	r4,r4,3896
   17004:	014000f4 	movhi	r5,3
   17008:	29443304 	addi	r5,r5,4300
   1700c:	0180dd44 	movi	r6,885
   17010:	01c000f4 	movhi	r7,3
   17014:	39c3db04 	addi	r7,r7,3948
   17018:	00193f00 	call	193f0 <printf>
   1701c:	003fff06 	br	1701c <etharp_output+0x4c>
  LWIP_ASSERT("q != NULL", q != NULL);
   17020:	e0bffe17 	ldw	r2,-8(fp)
   17024:	1000091e 	bne	r2,zero,1704c <etharp_output+0x7c>
   17028:	010000f4 	movhi	r4,3
   1702c:	2103ce04 	addi	r4,r4,3896
   17030:	014000f4 	movhi	r5,3
   17034:	2943d804 	addi	r5,r5,3936
   17038:	0180dd84 	movi	r6,886
   1703c:	01c000f4 	movhi	r7,3
   17040:	39c3db04 	addi	r7,r7,3948
   17044:	00193f00 	call	193f0 <printf>
   17048:	003fff06 	br	17048 <etharp_output+0x78>
  LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
   1704c:	e0bfff17 	ldw	r2,-4(fp)
   17050:	1000091e 	bne	r2,zero,17078 <etharp_output+0xa8>
   17054:	010000f4 	movhi	r4,3
   17058:	2103ce04 	addi	r4,r4,3896
   1705c:	014000f4 	movhi	r5,3
   17060:	29444304 	addi	r5,r5,4364
   17064:	0180ddc4 	movi	r6,887
   17068:	01c000f4 	movhi	r7,3
   1706c:	39c3db04 	addi	r7,r7,3948
   17070:	00193f00 	call	193f0 <printf>
   17074:	003fff06 	br	17074 <etharp_output+0xa4>

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
   17078:	e13ffe17 	ldw	r4,-8(fp)
   1707c:	01400404 	movi	r5,16
   17080:	000a83c0 	call	a83c <pbuf_header>
   17084:	10803fcc 	andi	r2,r2,255
   17088:	10000a26 	beq	r2,zero,170b4 <etharp_output+0xe4>
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
   1708c:	00800234 	movhi	r2,8
   17090:	1083bd04 	addi	r2,r2,3828
   17094:	1080028b 	ldhu	r2,10(r2)
   17098:	10800044 	addi	r2,r2,1
   1709c:	1007883a 	mov	r3,r2
   170a0:	00800234 	movhi	r2,8
   170a4:	1083bd04 	addi	r2,r2,3828
   170a8:	10c0028d 	sth	r3,10(r2)
    return ERR_BUF;
   170ac:	00bfff84 	movi	r2,-2
   170b0:	00009206 	br	172fc <etharp_output+0x32c>

  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
   170b4:	e0bfff17 	ldw	r2,-4(fp)
   170b8:	10800017 	ldw	r2,0(r2)
   170bc:	1009883a 	mov	r4,r2
   170c0:	e17ffd17 	ldw	r5,-12(fp)
   170c4:	0006da80 	call	6da8 <ip4_addr_isbroadcast>
   170c8:	10803fcc 	andi	r2,r2,255
   170cc:	10000326 	beq	r2,zero,170dc <etharp_output+0x10c>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
   170d0:	d0a00884 	addi	r2,gp,-32734
   170d4:	e0bff915 	stw	r2,-28(fp)
   170d8:	00008106 	br	172e0 <etharp_output+0x310>
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
   170dc:	e0bfff17 	ldw	r2,-4(fp)
   170e0:	10800017 	ldw	r2,0(r2)
   170e4:	10803c0c 	andi	r2,r2,240
   170e8:	10803818 	cmpnei	r2,r2,224
   170ec:	1000131e 	bne	r2,zero,1713c <etharp_output+0x16c>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
   170f0:	00800044 	movi	r2,1
   170f4:	e0bffb45 	stb	r2,-19(fp)
    mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
   170f8:	e03ffb85 	stb	zero,-18(fp)
    mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
   170fc:	00801784 	movi	r2,94
   17100:	e0bffbc5 	stb	r2,-17(fp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
   17104:	e0bfff17 	ldw	r2,-4(fp)
   17108:	10800044 	addi	r2,r2,1
   1710c:	10800003 	ldbu	r2,0(r2)
   17110:	10801fcc 	andi	r2,r2,127
   17114:	e0bffc05 	stb	r2,-16(fp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
   17118:	e0bfff17 	ldw	r2,-4(fp)
   1711c:	10800083 	ldbu	r2,2(r2)
   17120:	e0bffc45 	stb	r2,-15(fp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
   17124:	e0bfff17 	ldw	r2,-4(fp)
   17128:	108000c3 	ldbu	r2,3(r2)
   1712c:	e0bffc85 	stb	r2,-14(fp)
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
   17130:	e0bffb44 	addi	r2,fp,-19
   17134:	e0bff915 	stw	r2,-28(fp)
   17138:	00006906 	br	172e0 <etharp_output+0x310>
  /* unicast destination IP address? */
  } else {
    s8_t i;
    /* outside local network? if so, this can neither be a global broadcast nor
       a subnet broadcast. */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
   1713c:	e0bfff17 	ldw	r2,-4(fp)
   17140:	10c00017 	ldw	r3,0(r2)
   17144:	e0bffd17 	ldw	r2,-12(fp)
   17148:	10800117 	ldw	r2,4(r2)
   1714c:	1886f03a 	xor	r3,r3,r2
   17150:	e0bffd17 	ldw	r2,-12(fp)
   17154:	10800217 	ldw	r2,8(r2)
   17158:	1884703a 	and	r2,r3,r2
   1715c:	10001126 	beq	r2,zero,171a4 <etharp_output+0x1d4>
        !ip_addr_islinklocal(ipaddr)) {
   17160:	e0bfff17 	ldw	r2,-4(fp)
   17164:	10800017 	ldw	r2,0(r2)
   17168:	10ffffcc 	andi	r3,r2,65535
  /* unicast destination IP address? */
  } else {
    s8_t i;
    /* outside local network? if so, this can neither be a global broadcast nor
       a subnet broadcast. */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
   1716c:	00bfaa54 	movui	r2,65193
   17170:	18800c26 	beq	r3,r2,171a4 <etharp_output+0x1d4>
         router for forwarding". */
      if (!ip_addr_islinklocal(&iphdr->src))
#endif /* LWIP_AUTOIP */
      {
        /* interface has default gateway? */
        if (!ip_addr_isany(&netif->gw)) {
   17174:	e0bffd17 	ldw	r2,-12(fp)
   17178:	10800304 	addi	r2,r2,12
   1717c:	10000726 	beq	r2,zero,1719c <etharp_output+0x1cc>
   17180:	e0bffd17 	ldw	r2,-12(fp)
   17184:	10800317 	ldw	r2,12(r2)
   17188:	10000426 	beq	r2,zero,1719c <etharp_output+0x1cc>
          /* send to hardware address of default gateway IP address */
          dst_addr = &(netif->gw);
   1718c:	e0bffd17 	ldw	r2,-12(fp)
   17190:	10800304 	addi	r2,r2,12
   17194:	e0bffa15 	stw	r2,-24(fp)
   17198:	00000206 	br	171a4 <etharp_output+0x1d4>
        /* no default gateway available */
        } else {
          /* no route to destination error (default gateway missing) */
          return ERR_RTE;
   1719c:	00bfff04 	movi	r2,-4
   171a0:	00005606 	br	172fc <etharp_output+0x32c>
    if (netif->addr_hint != NULL) {
      /* per-pcb cached entry was given */
      u8_t etharp_cached_entry = *(netif->addr_hint);
      if (etharp_cached_entry < ARP_TABLE_SIZE) {
#endif /* LWIP_NETIF_HWADDRHINT */
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
   171a4:	d0a8cb03 	ldbu	r2,-23764(gp)
   171a8:	10803fcc 	andi	r2,r2,255
   171ac:	00c00134 	movhi	r3,4
   171b0:	18d73904 	addi	r3,r3,23780
   171b4:	10800524 	muli	r2,r2,20
   171b8:	1885883a 	add	r2,r3,r2
   171bc:	10800404 	addi	r2,r2,16
   171c0:	10800083 	ldbu	r2,2(r2)
   171c4:	10803fcc 	andi	r2,r2,255
   171c8:	108000b0 	cmpltui	r2,r2,2
   171cc:	10001a1e 	bne	r2,zero,17238 <etharp_output+0x268>
            (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
   171d0:	e0bffa17 	ldw	r2,-24(fp)
   171d4:	10c00017 	ldw	r3,0(r2)
   171d8:	d0a8cb03 	ldbu	r2,-23764(gp)
   171dc:	10803fcc 	andi	r2,r2,255
   171e0:	01000134 	movhi	r4,4
   171e4:	21173904 	addi	r4,r4,23780
   171e8:	10800524 	muli	r2,r2,20
   171ec:	2085883a 	add	r2,r4,r2
   171f0:	10800104 	addi	r2,r2,4
   171f4:	10800017 	ldw	r2,0(r2)
    if (netif->addr_hint != NULL) {
      /* per-pcb cached entry was given */
      u8_t etharp_cached_entry = *(netif->addr_hint);
      if (etharp_cached_entry < ARP_TABLE_SIZE) {
#endif /* LWIP_NETIF_HWADDRHINT */
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
   171f8:	18800f1e 	bne	r3,r2,17238 <etharp_output+0x268>
            (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
          /* the per-pcb-cached entry is stable and the right one! */
          ETHARP_STATS_INC(etharp.cachehit);
   171fc:	00800234 	movhi	r2,8
   17200:	1083bd04 	addi	r2,r2,3828
   17204:	10800b8b 	ldhu	r2,46(r2)
   17208:	10800044 	addi	r2,r2,1
   1720c:	1007883a 	mov	r3,r2
   17210:	00800234 	movhi	r2,8
   17214:	1083bd04 	addi	r2,r2,3828
   17218:	10c00b8d 	sth	r3,46(r2)
          return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
   1721c:	d0a8cb03 	ldbu	r2,-23764(gp)
   17220:	10803fcc 	andi	r2,r2,255
   17224:	e13ffd17 	ldw	r4,-12(fp)
   17228:	e17ffe17 	ldw	r5,-8(fp)
   1722c:	100d883a 	mov	r6,r2
   17230:	0016e780 	call	16e78 <etharp_output_to_arp_index>
   17234:	00003106 	br	172fc <etharp_output+0x32c>
    }
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
   17238:	e03ffb05 	stb	zero,-20(fp)
   1723c:	00002006 	br	172c0 <etharp_output+0x2f0>
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
   17240:	e0bffb07 	ldb	r2,-20(fp)
   17244:	00c00134 	movhi	r3,4
   17248:	18d73904 	addi	r3,r3,23780
   1724c:	10800524 	muli	r2,r2,20
   17250:	1885883a 	add	r2,r3,r2
   17254:	10800404 	addi	r2,r2,16
   17258:	10800083 	ldbu	r2,2(r2)
   1725c:	10803fcc 	andi	r2,r2,255
   17260:	108000b0 	cmpltui	r2,r2,2
   17264:	1000131e 	bne	r2,zero,172b4 <etharp_output+0x2e4>
          (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
   17268:	e0bffa17 	ldw	r2,-24(fp)
   1726c:	10c00017 	ldw	r3,0(r2)
   17270:	e0bffb07 	ldb	r2,-20(fp)
   17274:	01000134 	movhi	r4,4
   17278:	21173904 	addi	r4,r4,23780
   1727c:	10800524 	muli	r2,r2,20
   17280:	2085883a 	add	r2,r4,r2
   17284:	10800104 	addi	r2,r2,4
   17288:	10800017 	ldw	r2,0(r2)
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
   1728c:	1880091e 	bne	r3,r2,172b4 <etharp_output+0x2e4>
          (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
        /* found an existing, stable entry */
        ETHARP_SET_HINT(netif, i);
   17290:	e0bffb03 	ldbu	r2,-20(fp)
   17294:	d0a8cb05 	stb	r2,-23764(gp)
        return etharp_output_to_arp_index(netif, q, i);
   17298:	e0bffb03 	ldbu	r2,-20(fp)
   1729c:	10803fcc 	andi	r2,r2,255
   172a0:	e13ffd17 	ldw	r4,-12(fp)
   172a4:	e17ffe17 	ldw	r5,-8(fp)
   172a8:	100d883a 	mov	r6,r2
   172ac:	0016e780 	call	16e78 <etharp_output_to_arp_index>
   172b0:	00001206 	br	172fc <etharp_output+0x32c>
    }
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
   172b4:	e0bffb03 	ldbu	r2,-20(fp)
   172b8:	10800044 	addi	r2,r2,1
   172bc:	e0bffb05 	stb	r2,-20(fp)
   172c0:	e0bffb07 	ldb	r2,-20(fp)
   172c4:	10800290 	cmplti	r2,r2,10
   172c8:	103fdd1e 	bne	r2,zero,17240 <etharp_output+0x270>
        return etharp_output_to_arp_index(netif, q, i);
      }
    }
    /* no stable entry found, use the (slower) query function:
       queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, dst_addr, q);
   172cc:	e13ffd17 	ldw	r4,-12(fp)
   172d0:	e17ffa17 	ldw	r5,-24(fp)
   172d4:	e1bffe17 	ldw	r6,-8(fp)
   172d8:	00173100 	call	17310 <etharp_query>
   172dc:	00000706 	br	172fc <etharp_output+0x32c>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
   172e0:	e0bffd17 	ldw	r2,-12(fp)
   172e4:	108009c4 	addi	r2,r2,39
   172e8:	e13ffd17 	ldw	r4,-12(fp)
   172ec:	e17ffe17 	ldw	r5,-8(fp)
   172f0:	100d883a 	mov	r6,r2
   172f4:	e1fff917 	ldw	r7,-28(fp)
   172f8:	001658c0 	call	1658c <etharp_send_ip>
}
   172fc:	e037883a 	mov	sp,fp
   17300:	dfc00117 	ldw	ra,4(sp)
   17304:	df000017 	ldw	fp,0(sp)
   17308:	dec00204 	addi	sp,sp,8
   1730c:	f800283a 	ret

00017310 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, ip_addr_t *ipaddr, struct pbuf *q)
{
   17310:	defff404 	addi	sp,sp,-48
   17314:	dfc00b15 	stw	ra,44(sp)
   17318:	df000a15 	stw	fp,40(sp)
   1731c:	df000a04 	addi	fp,sp,40
   17320:	e13ffd15 	stw	r4,-12(fp)
   17324:	e17ffe15 	stw	r5,-8(fp)
   17328:	e1bfff15 	stw	r6,-4(fp)
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
   1732c:	e0bffd17 	ldw	r2,-12(fp)
   17330:	108009c4 	addi	r2,r2,39
   17334:	e0bffa15 	stw	r2,-24(fp)
  err_t result = ERR_MEM;
   17338:	00bfffc4 	movi	r2,-1
   1733c:	e0bff605 	stb	r2,-40(fp)
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
   17340:	e0bffe17 	ldw	r2,-8(fp)
   17344:	10800017 	ldw	r2,0(r2)
   17348:	1009883a 	mov	r4,r2
   1734c:	e17ffd17 	ldw	r5,-12(fp)
   17350:	0006da80 	call	6da8 <ip4_addr_isbroadcast>
   17354:	10803fcc 	andi	r2,r2,255
   17358:	10000a1e 	bne	r2,zero,17384 <etharp_query+0x74>
      ip_addr_ismulticast(ipaddr) ||
   1735c:	e0bffe17 	ldw	r2,-8(fp)
   17360:	10800017 	ldw	r2,0(r2)
   17364:	10803c0c 	andi	r2,r2,240
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
   17368:	10803820 	cmpeqi	r2,r2,224
   1736c:	1000051e 	bne	r2,zero,17384 <etharp_query+0x74>
      ip_addr_ismulticast(ipaddr) ||
   17370:	e0bffe17 	ldw	r2,-8(fp)
   17374:	10000326 	beq	r2,zero,17384 <etharp_query+0x74>
      ip_addr_isany(ipaddr)) {
   17378:	e0bffe17 	ldw	r2,-8(fp)
   1737c:	10800017 	ldw	r2,0(r2)
   17380:	1000021e 	bne	r2,zero,1738c <etharp_query+0x7c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
   17384:	00bffc84 	movi	r2,-14
   17388:	0000ff06 	br	17788 <etharp_query+0x478>
  }

  /* find entry in ARP cache, ask to create entry if queueing packet */
  i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);
   1738c:	e13ffe17 	ldw	r4,-8(fp)
   17390:	01400044 	movi	r5,1
   17394:	00161540 	call	16154 <etharp_find_entry>
   17398:	e0bffb05 	stb	r2,-20(fp)

  /* could not find or create entry? */
  if (i < 0) {
   1739c:	e0bffb07 	ldb	r2,-20(fp)
   173a0:	10000c0e 	bge	r2,zero,173d4 <etharp_query+0xc4>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
    if (q) {
   173a4:	e0bfff17 	ldw	r2,-4(fp)
   173a8:	10000826 	beq	r2,zero,173cc <etharp_query+0xbc>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
      ETHARP_STATS_INC(etharp.memerr);
   173ac:	00800234 	movhi	r2,8
   173b0:	1083bd04 	addi	r2,r2,3828
   173b4:	1080090b 	ldhu	r2,36(r2)
   173b8:	10800044 	addi	r2,r2,1
   173bc:	1007883a 	mov	r3,r2
   173c0:	00800234 	movhi	r2,8
   173c4:	1083bd04 	addi	r2,r2,3828
   173c8:	10c0090d 	sth	r3,36(r2)
    }
    return (err_t)i;
   173cc:	e0bffb03 	ldbu	r2,-20(fp)
   173d0:	0000ed06 	br	17788 <etharp_query+0x478>
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
   173d4:	e0bffb07 	ldb	r2,-20(fp)
   173d8:	00c00134 	movhi	r3,4
   173dc:	18d73904 	addi	r3,r3,23780
   173e0:	10800524 	muli	r2,r2,20
   173e4:	1885883a 	add	r2,r3,r2
   173e8:	10800404 	addi	r2,r2,16
   173ec:	10800083 	ldbu	r2,2(r2)
   173f0:	10803fcc 	andi	r2,r2,255
   173f4:	1000081e 	bne	r2,zero,17418 <etharp_query+0x108>
    arp_table[i].state = ETHARP_STATE_PENDING;
   173f8:	e0bffb07 	ldb	r2,-20(fp)
   173fc:	00c00134 	movhi	r3,4
   17400:	18d73904 	addi	r3,r3,23780
   17404:	10800524 	muli	r2,r2,20
   17408:	1885883a 	add	r2,r3,r2
   1740c:	10800404 	addi	r2,r2,16
   17410:	00c00044 	movi	r3,1
   17414:	10c00085 	stb	r3,2(r2)
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
   17418:	e0bffb07 	ldb	r2,-20(fp)
   1741c:	00c00134 	movhi	r3,4
   17420:	18d73904 	addi	r3,r3,23780
   17424:	10800524 	muli	r2,r2,20
   17428:	1885883a 	add	r2,r3,r2
   1742c:	10800404 	addi	r2,r2,16
   17430:	10800083 	ldbu	r2,2(r2)
   17434:	10803fcc 	andi	r2,r2,255
   17438:	10800060 	cmpeqi	r2,r2,1
   1743c:	1000131e 	bne	r2,zero,1748c <etharp_query+0x17c>
   17440:	e0bffb07 	ldb	r2,-20(fp)
   17444:	00c00134 	movhi	r3,4
   17448:	18d73904 	addi	r3,r3,23780
   1744c:	10800524 	muli	r2,r2,20
   17450:	1885883a 	add	r2,r3,r2
   17454:	10800404 	addi	r2,r2,16
   17458:	10800083 	ldbu	r2,2(r2)
   1745c:	10803fcc 	andi	r2,r2,255
   17460:	108000a8 	cmpgeui	r2,r2,2
   17464:	1000091e 	bne	r2,zero,1748c <etharp_query+0x17c>
   17468:	010000f4 	movhi	r4,3
   1746c:	2103ce04 	addi	r4,r4,3896
   17470:	014000f4 	movhi	r5,3
   17474:	29444704 	addi	r5,r5,4380
   17478:	018106c4 	movi	r6,1051
   1747c:	01c000f4 	movhi	r7,3
   17480:	39c3db04 	addi	r7,r7,3948
   17484:	00193f00 	call	193f0 <printf>
   17488:	003fff06 	br	17488 <etharp_query+0x178>
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state >= ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
   1748c:	e0bffb07 	ldb	r2,-20(fp)
   17490:	00c00134 	movhi	r3,4
   17494:	18d73904 	addi	r3,r3,23780
   17498:	10800524 	muli	r2,r2,20
   1749c:	1885883a 	add	r2,r3,r2
   174a0:	10800404 	addi	r2,r2,16
   174a4:	10800083 	ldbu	r2,2(r2)
   174a8:	10803fcc 	andi	r2,r2,255
   174ac:	10800060 	cmpeqi	r2,r2,1
   174b0:	1000021e 	bne	r2,zero,174bc <etharp_query+0x1ac>
   174b4:	e0bfff17 	ldw	r2,-4(fp)
   174b8:	1000081e 	bne	r2,zero,174dc <etharp_query+0x1cc>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
   174bc:	e13ffd17 	ldw	r4,-12(fp)
   174c0:	e17ffe17 	ldw	r5,-8(fp)
   174c4:	0017a0c0 	call	17a0c <etharp_request>
   174c8:	e0bff605 	stb	r2,-40(fp)
      /* ARP request couldn't be sent */
      /* We don't re-send arp request in etharp_tmr, but we still queue packets,
         since this failure could be temporary, and the next packet calling
         etharp_query again could lead to sending the queued packets. */
    }
    if (q == NULL) {
   174cc:	e0bfff17 	ldw	r2,-4(fp)
   174d0:	1000021e 	bne	r2,zero,174dc <etharp_query+0x1cc>
      return result;
   174d4:	e0bff603 	ldbu	r2,-40(fp)
   174d8:	0000ab06 	br	17788 <etharp_query+0x478>
    }
  }

  /* packet given? */
  LWIP_ASSERT("q != NULL", q != NULL);
   174dc:	e0bfff17 	ldw	r2,-4(fp)
   174e0:	1000091e 	bne	r2,zero,17508 <etharp_query+0x1f8>
   174e4:	010000f4 	movhi	r4,3
   174e8:	2103ce04 	addi	r4,r4,3896
   174ec:	014000f4 	movhi	r5,3
   174f0:	2943d804 	addi	r5,r5,3936
   174f4:	01810b44 	movi	r6,1069
   174f8:	01c000f4 	movhi	r7,3
   174fc:	39c3db04 	addi	r7,r7,3948
   17500:	00193f00 	call	193f0 <printf>
   17504:	003fff06 	br	17504 <etharp_query+0x1f4>
  /* stable entry? */
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
   17508:	e0bffb07 	ldb	r2,-20(fp)
   1750c:	00c00134 	movhi	r3,4
   17510:	18d73904 	addi	r3,r3,23780
   17514:	10800524 	muli	r2,r2,20
   17518:	1885883a 	add	r2,r3,r2
   1751c:	10800404 	addi	r2,r2,16
   17520:	10800083 	ldbu	r2,2(r2)
   17524:	10803fcc 	andi	r2,r2,255
   17528:	108000b0 	cmpltui	r2,r2,2
   1752c:	10000f1e 	bne	r2,zero,1756c <etharp_query+0x25c>
    /* we have a valid IP->Ethernet address mapping */
    ETHARP_SET_HINT(netif, i);
   17530:	e0bffb03 	ldbu	r2,-20(fp)
   17534:	d0a8cb05 	stb	r2,-23764(gp)
    /* send the packet */
    result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
   17538:	e0bffb07 	ldb	r2,-20(fp)
   1753c:	10800524 	muli	r2,r2,20
   17540:	10c00304 	addi	r3,r2,12
   17544:	00800134 	movhi	r2,4
   17548:	10973904 	addi	r2,r2,23780
   1754c:	1885883a 	add	r2,r3,r2
   17550:	e13ffd17 	ldw	r4,-12(fp)
   17554:	e17fff17 	ldw	r5,-4(fp)
   17558:	e1bffa17 	ldw	r6,-24(fp)
   1755c:	100f883a 	mov	r7,r2
   17560:	001658c0 	call	1658c <etharp_send_ip>
   17564:	e0bff605 	stb	r2,-40(fp)
   17568:	00008606 	br	17784 <etharp_query+0x474>
  /* pending entry? (either just created or already pending */
  } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
   1756c:	e0bffb07 	ldb	r2,-20(fp)
   17570:	00c00134 	movhi	r3,4
   17574:	18d73904 	addi	r3,r3,23780
   17578:	10800524 	muli	r2,r2,20
   1757c:	1885883a 	add	r2,r3,r2
   17580:	10800404 	addi	r2,r2,16
   17584:	10800083 	ldbu	r2,2(r2)
   17588:	10803fcc 	andi	r2,r2,255
   1758c:	10800058 	cmpnei	r2,r2,1
   17590:	10007c1e 	bne	r2,zero,17784 <etharp_query+0x474>
    /* entry is still pending, queue the given packet 'q' */
    struct pbuf *p;
    int copy_needed = 0;
   17594:	e03ff815 	stw	zero,-32(fp)
    /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
     * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
     * PBUF_ROMs can be left as they are, since ROM must not get changed. */
    p = q;
   17598:	e0bfff17 	ldw	r2,-4(fp)
   1759c:	e0bff715 	stw	r2,-36(fp)
    while (p) {
   175a0:	00001e06 	br	1761c <etharp_query+0x30c>
      LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
   175a4:	e0bff717 	ldw	r2,-36(fp)
   175a8:	10c0028b 	ldhu	r3,10(r2)
   175ac:	e0bff717 	ldw	r2,-36(fp)
   175b0:	1080020b 	ldhu	r2,8(r2)
   175b4:	18ffffcc 	andi	r3,r3,65535
   175b8:	10bfffcc 	andi	r2,r2,65535
   175bc:	18800c1e 	bne	r3,r2,175f0 <etharp_query+0x2e0>
   175c0:	e0bff717 	ldw	r2,-36(fp)
   175c4:	10800017 	ldw	r2,0(r2)
   175c8:	10000926 	beq	r2,zero,175f0 <etharp_query+0x2e0>
   175cc:	010000f4 	movhi	r4,3
   175d0:	2103ce04 	addi	r4,r4,3896
   175d4:	014000f4 	movhi	r5,3
   175d8:	29445104 	addi	r5,r5,4420
   175dc:	01810f84 	movi	r6,1086
   175e0:	01c000f4 	movhi	r7,3
   175e4:	39c3db04 	addi	r7,r7,3948
   175e8:	00193f00 	call	193f0 <printf>
   175ec:	003fff06 	br	175ec <etharp_query+0x2dc>
      if(p->type != PBUF_ROM) {
   175f0:	e0bff717 	ldw	r2,-36(fp)
   175f4:	10800303 	ldbu	r2,12(r2)
   175f8:	10803fcc 	andi	r2,r2,255
   175fc:	10800060 	cmpeqi	r2,r2,1
   17600:	1000031e 	bne	r2,zero,17610 <etharp_query+0x300>
        copy_needed = 1;
   17604:	00800044 	movi	r2,1
   17608:	e0bff815 	stw	r2,-32(fp)
        break;
   1760c:	00000506 	br	17624 <etharp_query+0x314>
      }
      p = p->next;
   17610:	e0bff717 	ldw	r2,-36(fp)
   17614:	10800017 	ldw	r2,0(r2)
   17618:	e0bff715 	stw	r2,-36(fp)
    int copy_needed = 0;
    /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
     * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
     * PBUF_ROMs can be left as they are, since ROM must not get changed. */
    p = q;
    while (p) {
   1761c:	e0bff717 	ldw	r2,-36(fp)
   17620:	103fe01e 	bne	r2,zero,175a4 <etharp_query+0x294>
        copy_needed = 1;
        break;
      }
      p = p->next;
    }
    if(copy_needed) {
   17624:	e0bff817 	ldw	r2,-32(fp)
   17628:	10001526 	beq	r2,zero,17680 <etharp_query+0x370>
      /* copy the whole packet into new pbufs */
      p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
   1762c:	e0bff717 	ldw	r2,-36(fp)
   17630:	1080020b 	ldhu	r2,8(r2)
   17634:	10bfffcc 	andi	r2,r2,65535
   17638:	010000c4 	movi	r4,3
   1763c:	100b883a 	mov	r5,r2
   17640:	000d883a 	mov	r6,zero
   17644:	000a0740 	call	a074 <pbuf_alloc>
   17648:	e0bff715 	stw	r2,-36(fp)
      if(p != NULL) {
   1764c:	e0bff717 	ldw	r2,-36(fp)
   17650:	10000f26 	beq	r2,zero,17690 <etharp_query+0x380>
        if (pbuf_copy(p, q) != ERR_OK) {
   17654:	e13ff717 	ldw	r4,-36(fp)
   17658:	e17fff17 	ldw	r5,-4(fp)
   1765c:	000af380 	call	af38 <pbuf_copy>
   17660:	10803fcc 	andi	r2,r2,255
   17664:	1080201c 	xori	r2,r2,128
   17668:	10bfe004 	addi	r2,r2,-128
   1766c:	10000826 	beq	r2,zero,17690 <etharp_query+0x380>
          pbuf_free(p);
   17670:	e13ff717 	ldw	r4,-36(fp)
   17674:	000aa340 	call	aa34 <pbuf_free>
          p = NULL;
   17678:	e03ff715 	stw	zero,-36(fp)
   1767c:	00000406 	br	17690 <etharp_query+0x380>
        }
      }
    } else {
      /* referencing the old pbuf is enough */
      p = q;
   17680:	e0bfff17 	ldw	r2,-4(fp)
   17684:	e0bff715 	stw	r2,-36(fp)
      pbuf_ref(p);
   17688:	e13ff717 	ldw	r4,-36(fp)
   1768c:	000ac4c0 	call	ac4c <pbuf_ref>
    }
    /* packet could be taken over? */
    if (p != NULL) {
   17690:	e0bff717 	ldw	r2,-36(fp)
   17694:	10003126 	beq	r2,zero,1775c <etharp_query+0x44c>
      /* queue packet ... */
#if ARP_QUEUEING
      struct etharp_q_entry *new_entry;
      /* allocate a new arp queue entry */
      new_entry = (struct etharp_q_entry *)memp_malloc(MEMP_ARP_QUEUE);
   17698:	01000184 	movi	r4,6
   1769c:	00095f80 	call	95f8 <memp_malloc>
   176a0:	e0bffc15 	stw	r2,-16(fp)
      if (new_entry != NULL) {
   176a4:	e0bffc17 	ldw	r2,-16(fp)
   176a8:	10002726 	beq	r2,zero,17748 <etharp_query+0x438>
        new_entry->next = 0;
   176ac:	e0bffc17 	ldw	r2,-16(fp)
   176b0:	10000015 	stw	zero,0(r2)
        new_entry->p = p;
   176b4:	e0bffc17 	ldw	r2,-16(fp)
   176b8:	e0fff717 	ldw	r3,-36(fp)
   176bc:	10c00115 	stw	r3,4(r2)
        if(arp_table[i].q != NULL) {
   176c0:	e0bffb07 	ldb	r2,-20(fp)
   176c4:	00c00134 	movhi	r3,4
   176c8:	18d73904 	addi	r3,r3,23780
   176cc:	10800524 	muli	r2,r2,20
   176d0:	1885883a 	add	r2,r3,r2
   176d4:	10800017 	ldw	r2,0(r2)
   176d8:	10001226 	beq	r2,zero,17724 <etharp_query+0x414>
          /* queue was already existent, append the new entry to the end */
          struct etharp_q_entry *r;
          r = arp_table[i].q;
   176dc:	e0bffb07 	ldb	r2,-20(fp)
   176e0:	00c00134 	movhi	r3,4
   176e4:	18d73904 	addi	r3,r3,23780
   176e8:	10800524 	muli	r2,r2,20
   176ec:	1885883a 	add	r2,r3,r2
   176f0:	10800017 	ldw	r2,0(r2)
   176f4:	e0bff915 	stw	r2,-28(fp)
          while (r->next != NULL) {
   176f8:	00000306 	br	17708 <etharp_query+0x3f8>
            r = r->next;
   176fc:	e0bff917 	ldw	r2,-28(fp)
   17700:	10800017 	ldw	r2,0(r2)
   17704:	e0bff915 	stw	r2,-28(fp)
        new_entry->p = p;
        if(arp_table[i].q != NULL) {
          /* queue was already existent, append the new entry to the end */
          struct etharp_q_entry *r;
          r = arp_table[i].q;
          while (r->next != NULL) {
   17708:	e0bff917 	ldw	r2,-28(fp)
   1770c:	10800017 	ldw	r2,0(r2)
   17710:	103ffa1e 	bne	r2,zero,176fc <etharp_query+0x3ec>
            r = r->next;
          }
          r->next = new_entry;
   17714:	e0bff917 	ldw	r2,-28(fp)
   17718:	e0fffc17 	ldw	r3,-16(fp)
   1771c:	10c00015 	stw	r3,0(r2)
   17720:	00000706 	br	17740 <etharp_query+0x430>
        } else {
          /* queue did not exist, first item in queue */
          arp_table[i].q = new_entry;
   17724:	e0bffb07 	ldb	r2,-20(fp)
   17728:	00c00134 	movhi	r3,4
   1772c:	18d73904 	addi	r3,r3,23780
   17730:	10800524 	muli	r2,r2,20
   17734:	1885883a 	add	r2,r3,r2
   17738:	e0fffc17 	ldw	r3,-16(fp)
   1773c:	10c00015 	stw	r3,0(r2)
        }
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
        result = ERR_OK;
   17740:	e03ff605 	stb	zero,-40(fp)
   17744:	00000f06 	br	17784 <etharp_query+0x474>
      } else {
        /* the pool MEMP_ARP_QUEUE is empty */
        pbuf_free(p);
   17748:	e13ff717 	ldw	r4,-36(fp)
   1774c:	000aa340 	call	aa34 <pbuf_free>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
        result = ERR_MEM;
   17750:	00bfffc4 	movi	r2,-1
   17754:	e0bff605 	stb	r2,-40(fp)
   17758:	00000a06 	br	17784 <etharp_query+0x474>
      arp_table[i].q = p;
      result = ERR_OK;
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
#endif /* ARP_QUEUEING */
    } else {
      ETHARP_STATS_INC(etharp.memerr);
   1775c:	00800234 	movhi	r2,8
   17760:	1083bd04 	addi	r2,r2,3828
   17764:	1080090b 	ldhu	r2,36(r2)
   17768:	10800044 	addi	r2,r2,1
   1776c:	1007883a 	mov	r3,r2
   17770:	00800234 	movhi	r2,8
   17774:	1083bd04 	addi	r2,r2,3828
   17778:	10c0090d 	sth	r3,36(r2)
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
      result = ERR_MEM;
   1777c:	00bfffc4 	movi	r2,-1
   17780:	e0bff605 	stb	r2,-40(fp)
    }
  }
  return result;
   17784:	e0bff603 	ldbu	r2,-40(fp)
}
   17788:	e037883a 	mov	sp,fp
   1778c:	dfc00117 	ldw	ra,4(sp)
   17790:	df000017 	ldw	fp,0(sp)
   17794:	dec00204 	addi	sp,sp,8
   17798:	f800283a 	ret

0001779c <etharp_raw>:
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const ip_addr_t *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const ip_addr_t *ipdst_addr,
           const u16_t opcode)
{
   1779c:	defff504 	addi	sp,sp,-44
   177a0:	dfc00a15 	stw	ra,40(sp)
   177a4:	df000915 	stw	fp,36(sp)
   177a8:	df000904 	addi	fp,sp,36
   177ac:	e13ffb15 	stw	r4,-20(fp)
   177b0:	e17ffc15 	stw	r5,-16(fp)
   177b4:	e1bffd15 	stw	r6,-12(fp)
   177b8:	e1fffe15 	stw	r7,-8(fp)
   177bc:	e0800517 	ldw	r2,20(fp)
   177c0:	e0bfff0d 	sth	r2,-4(fp)
  struct pbuf *p;
  err_t result = ERR_OK;
   177c4:	e03ff705 	stb	zero,-36(fp)
  struct etharp_hdr *hdr;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ASSERT("netif != NULL", netif != NULL);
   177c8:	e0bffb17 	ldw	r2,-20(fp)
   177cc:	1000091e 	bne	r2,zero,177f4 <etharp_raw+0x58>
   177d0:	010000f4 	movhi	r4,3
   177d4:	2103ce04 	addi	r4,r4,3896
   177d8:	014000f4 	movhi	r5,3
   177dc:	29443304 	addi	r5,r5,4300
   177e0:	01812944 	movi	r6,1189
   177e4:	01c000f4 	movhi	r7,3
   177e8:	39c3db04 	addi	r7,r7,3948
   177ec:	00193f00 	call	193f0 <printf>
   177f0:	003fff06 	br	177f0 <etharp_raw+0x54>

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
   177f4:	010000c4 	movi	r4,3
   177f8:	01400b04 	movi	r5,44
   177fc:	000d883a 	mov	r6,zero
   17800:	000a0740 	call	a074 <pbuf_alloc>
   17804:	e0bff815 	stw	r2,-32(fp)
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
   17808:	e0bff817 	ldw	r2,-32(fp)
   1780c:	10000a1e 	bne	r2,zero,17838 <etharp_raw+0x9c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
   17810:	00800234 	movhi	r2,8
   17814:	1083bd04 	addi	r2,r2,3828
   17818:	1080090b 	ldhu	r2,36(r2)
   1781c:	10800044 	addi	r2,r2,1
   17820:	1007883a 	mov	r3,r2
   17824:	00800234 	movhi	r2,8
   17828:	1083bd04 	addi	r2,r2,3828
   1782c:	10c0090d 	sth	r3,36(r2)
    return ERR_MEM;
   17830:	00bfffc4 	movi	r2,-1
   17834:	00007006 	br	179f8 <etharp_raw+0x25c>
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
   17838:	e0bff817 	ldw	r2,-32(fp)
   1783c:	1080028b 	ldhu	r2,10(r2)
   17840:	10bfffcc 	andi	r2,r2,65535
   17844:	10800b28 	cmpgeui	r2,r2,44
   17848:	1000091e 	bne	r2,zero,17870 <etharp_raw+0xd4>
   1784c:	010000f4 	movhi	r4,3
   17850:	2103ce04 	addi	r4,r4,3896
   17854:	014000f4 	movhi	r5,3
   17858:	29445804 	addi	r5,r5,4448
   1785c:	01812c44 	movi	r6,1201
   17860:	01c000f4 	movhi	r7,3
   17864:	39c3db04 	addi	r7,r7,3948
   17868:	00193f00 	call	193f0 <printf>
   1786c:	003fff06 	br	1786c <etharp_raw+0xd0>
              (p->len >= SIZEOF_ETHARP_PACKET));

  ethhdr = (struct eth_hdr *)p->payload;
   17870:	e0bff817 	ldw	r2,-32(fp)
   17874:	10800117 	ldw	r2,4(r2)
   17878:	e0bff915 	stw	r2,-28(fp)
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
   1787c:	e0bff917 	ldw	r2,-28(fp)
   17880:	10800404 	addi	r2,r2,16
   17884:	e0bffa15 	stw	r2,-24(fp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
   17888:	e0bfff0b 	ldhu	r2,-4(fp)
   1788c:	1004d23a 	srli	r2,r2,8
   17890:	1007883a 	mov	r3,r2
   17894:	e0bfff0b 	ldhu	r2,-4(fp)
   17898:	1004923a 	slli	r2,r2,8
   1789c:	1884b03a 	or	r2,r3,r2
   178a0:	1007883a 	mov	r3,r2
   178a4:	e0bffa17 	ldw	r2,-24(fp)
   178a8:	10c0018d 	sth	r3,6(r2)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
   178ac:	e0bffb17 	ldw	r2,-20(fp)
   178b0:	10800983 	ldbu	r2,38(r2)
   178b4:	10803fcc 	andi	r2,r2,255
   178b8:	108001a0 	cmpeqi	r2,r2,6
   178bc:	1000091e 	bne	r2,zero,178e4 <etharp_raw+0x148>
   178c0:	010000f4 	movhi	r4,3
   178c4:	2103ce04 	addi	r4,r4,3896
   178c8:	014000f4 	movhi	r5,3
   178cc:	29440f04 	addi	r5,r5,4156
   178d0:	01812e44 	movi	r6,1209
   178d4:	01c000f4 	movhi	r7,3
   178d8:	39c3db04 	addi	r7,r7,3948
   178dc:	00193f00 	call	193f0 <printf>
   178e0:	003fff06 	br	178e0 <etharp_raw+0x144>
   * 'sender IP address' MUST be sent using link-layer broadcast instead of
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
   178e4:	e0bffa17 	ldw	r2,-24(fp)
   178e8:	10800204 	addi	r2,r2,8
   178ec:	1009883a 	mov	r4,r2
   178f0:	e17ffe17 	ldw	r5,-8(fp)
   178f4:	01800184 	movi	r6,6
   178f8:	00191f00 	call	191f0 <memcpy>
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
   178fc:	e0bffa17 	ldw	r2,-24(fp)
   17900:	10800484 	addi	r2,r2,18
   17904:	1009883a 	mov	r4,r2
   17908:	e1400317 	ldw	r5,12(fp)
   1790c:	01800184 	movi	r6,6
   17910:	00191f00 	call	191f0 <memcpy>
  /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
  ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
   17914:	e0bff917 	ldw	r2,-28(fp)
   17918:	10800084 	addi	r2,r2,2
   1791c:	1009883a 	mov	r4,r2
   17920:	e17ffd17 	ldw	r5,-12(fp)
   17924:	01800184 	movi	r6,6
   17928:	00191f00 	call	191f0 <memcpy>
#endif /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
   1792c:	e0bff917 	ldw	r2,-28(fp)
   17930:	10800204 	addi	r2,r2,8
   17934:	1009883a 	mov	r4,r2
   17938:	e17ffc17 	ldw	r5,-16(fp)
   1793c:	01800184 	movi	r6,6
   17940:	00191f00 	call	191f0 <memcpy>
  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
   17944:	e0bffa17 	ldw	r2,-24(fp)
   17948:	10800384 	addi	r2,r2,14
   1794c:	1009883a 	mov	r4,r2
   17950:	e1400217 	ldw	r5,8(fp)
   17954:	01800104 	movi	r6,4
   17958:	00191f00 	call	191f0 <memcpy>
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
   1795c:	e0bffa17 	ldw	r2,-24(fp)
   17960:	10800604 	addi	r2,r2,24
   17964:	1009883a 	mov	r4,r2
   17968:	e1400417 	ldw	r5,16(fp)
   1796c:	01800104 	movi	r6,4
   17970:	00191f00 	call	191f0 <memcpy>

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
   17974:	e0bffa17 	ldw	r2,-24(fp)
   17978:	00c04004 	movi	r3,256
   1797c:	10c0000d 	sth	r3,0(r2)
  hdr->proto = PP_HTONS(ETHTYPE_IP);
   17980:	e0bffa17 	ldw	r2,-24(fp)
   17984:	00c00204 	movi	r3,8
   17988:	10c0008d 	sth	r3,2(r2)
  /* set hwlen and protolen */
  hdr->hwlen = ETHARP_HWADDR_LEN;
   1798c:	e0bffa17 	ldw	r2,-24(fp)
   17990:	00c00184 	movi	r3,6
   17994:	10c00105 	stb	r3,4(r2)
  hdr->protolen = sizeof(ip_addr_t);
   17998:	e0bffa17 	ldw	r2,-24(fp)
   1799c:	00c00104 	movi	r3,4
   179a0:	10c00145 	stb	r3,5(r2)

  ethhdr->type = PP_HTONS(ETHTYPE_ARP);
   179a4:	e0bff917 	ldw	r2,-28(fp)
   179a8:	00c18204 	movi	r3,1544
   179ac:	10c0038d 	sth	r3,14(r2)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
   179b0:	e0bffb17 	ldw	r2,-20(fp)
   179b4:	10800617 	ldw	r2,24(r2)
   179b8:	e13ffb17 	ldw	r4,-20(fp)
   179bc:	e17ff817 	ldw	r5,-32(fp)
   179c0:	103ee83a 	callr	r2
   179c4:	e0bff705 	stb	r2,-36(fp)
  ETHARP_STATS_INC(etharp.xmit);
   179c8:	00800234 	movhi	r2,8
   179cc:	1083bd04 	addi	r2,r2,3828
   179d0:	1080060b 	ldhu	r2,24(r2)
   179d4:	10800044 	addi	r2,r2,1
   179d8:	1007883a 	mov	r3,r2
   179dc:	00800234 	movhi	r2,8
   179e0:	1083bd04 	addi	r2,r2,3828
   179e4:	10c0060d 	sth	r3,24(r2)
  /* free ARP query packet */
  pbuf_free(p);
   179e8:	e13ff817 	ldw	r4,-32(fp)
   179ec:	000aa340 	call	aa34 <pbuf_free>
  p = NULL;
   179f0:	e03ff815 	stw	zero,-32(fp)
  /* could not allocate pbuf for ARP request */

  return result;
   179f4:	e0bff703 	ldbu	r2,-36(fp)
}
   179f8:	e037883a 	mov	sp,fp
   179fc:	dfc00117 	ldw	ra,4(sp)
   17a00:	df000017 	ldw	fp,0(sp)
   17a04:	dec00204 	addi	sp,sp,8
   17a08:	f800283a 	ret

00017a0c <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
   17a0c:	defff804 	addi	sp,sp,-32
   17a10:	dfc00715 	stw	ra,28(sp)
   17a14:	df000615 	stw	fp,24(sp)
   17a18:	df000604 	addi	fp,sp,24
   17a1c:	e13ffe15 	stw	r4,-8(fp)
   17a20:	e17fff15 	stw	r5,-4(fp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
   17a24:	e0bffe17 	ldw	r2,-8(fp)
   17a28:	10c009c4 	addi	r3,r2,39
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
   17a2c:	e0bffe17 	ldw	r2,-8(fp)
   17a30:	108009c4 	addi	r2,r2,39
   17a34:	e13ffe17 	ldw	r4,-8(fp)
   17a38:	21000104 	addi	r4,r4,4
 */
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
   17a3c:	d9000015 	stw	r4,0(sp)
   17a40:	d1200a04 	addi	r4,gp,-32728
   17a44:	d9000115 	stw	r4,4(sp)
   17a48:	e13fff17 	ldw	r4,-4(fp)
   17a4c:	d9000215 	stw	r4,8(sp)
   17a50:	01000044 	movi	r4,1
   17a54:	d9000315 	stw	r4,12(sp)
   17a58:	e13ffe17 	ldw	r4,-8(fp)
   17a5c:	180b883a 	mov	r5,r3
   17a60:	d1a00884 	addi	r6,gp,-32734
   17a64:	100f883a 	mov	r7,r2
   17a68:	001779c0 	call	1779c <etharp_raw>
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
   17a6c:	e037883a 	mov	sp,fp
   17a70:	dfc00117 	ldw	ra,4(sp)
   17a74:	df000017 	ldw	fp,0(sp)
   17a78:	dec00204 	addi	sp,sp,8
   17a7c:	f800283a 	ret

00017a80 <ethernet_input>:
 */
#include "../../../histogram.h"
#include "../../../echo.h"
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
   17a80:	defff904 	addi	sp,sp,-28
   17a84:	dfc00615 	stw	ra,24(sp)
   17a88:	df000515 	stw	fp,20(sp)
   17a8c:	df000504 	addi	fp,sp,20
   17a90:	e13ffe15 	stw	r4,-8(fp)
   17a94:	e17fff15 	stw	r5,-4(fp)
#if TEST_HISTOGRAM
//#if 0
  if (histid <= TNUM_HIST && measuring_flg == FALSE) {
   17a98:	008000f4 	movhi	r2,3
   17a9c:	10957204 	addi	r2,r2,21960
   17aa0:	10800017 	ldw	r2,0(r2)
   17aa4:	1089c468 	cmpgeui	r2,r2,10001
   17aa8:	10000d1e 	bne	r2,zero,17ae0 <ethernet_input+0x60>
   17aac:	008000f4 	movhi	r2,3
   17ab0:	109e1b04 	addi	r2,r2,30828
   17ab4:	10800017 	ldw	r2,0(r2)
   17ab8:	1000091e 	bne	r2,zero,17ae0 <ethernet_input+0x60>
      //printf("[histid: %d] Histogram measuring starting...\n", histid);
      begin_measure(histid);
   17abc:	008000f4 	movhi	r2,3
   17ac0:	10957204 	addi	r2,r2,21960
   17ac4:	10800017 	ldw	r2,0(r2)
   17ac8:	1009883a 	mov	r4,r2
   17acc:	0001bec0 	call	1bec <begin_measure>
      measuring_flg = TRUE;
   17ad0:	008000f4 	movhi	r2,3
   17ad4:	109e1b04 	addi	r2,r2,30828
   17ad8:	00c00044 	movi	r3,1
   17adc:	10c00015 	stw	r3,0(r2)
  }
#endif
  struct eth_hdr* ethhdr;
  u16_t type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN
  s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
   17ae0:	00800404 	movi	r2,16
   17ae4:	e0bffb0d 	sth	r2,-20(fp)
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

  if (p->len <= SIZEOF_ETH_HDR) {
   17ae8:	e0bffe17 	ldw	r2,-8(fp)
   17aec:	1080028b 	ldhu	r2,10(r2)
   17af0:	10bfffcc 	andi	r2,r2,65535
   17af4:	10800468 	cmpgeui	r2,r2,17
   17af8:	1000111e 	bne	r2,zero,17b40 <ethernet_input+0xc0>
    /* a packet with only an ethernet header (or less) is not valid for us */
    ETHARP_STATS_INC(etharp.proterr);
   17afc:	00800234 	movhi	r2,8
   17b00:	1083bd04 	addi	r2,r2,3828
   17b04:	10800a0b 	ldhu	r2,40(r2)
   17b08:	10800044 	addi	r2,r2,1
   17b0c:	1007883a 	mov	r3,r2
   17b10:	00800234 	movhi	r2,8
   17b14:	1083bd04 	addi	r2,r2,3828
   17b18:	10c00a0d 	sth	r3,40(r2)
    ETHARP_STATS_INC(etharp.drop);
   17b1c:	00800234 	movhi	r2,8
   17b20:	1083bd04 	addi	r2,r2,3828
   17b24:	1080078b 	ldhu	r2,30(r2)
   17b28:	10800044 	addi	r2,r2,1
   17b2c:	1007883a 	mov	r3,r2
   17b30:	00800234 	movhi	r2,8
   17b34:	1083bd04 	addi	r2,r2,3828
   17b38:	10c0078d 	sth	r3,30(r2)
    goto free_and_return;
   17b3c:	00007406 	br	17d10 <ethernet_input+0x290>
  }

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = (struct eth_hdr *)p->payload;
   17b40:	e0bffe17 	ldw	r2,-8(fp)
   17b44:	10800117 	ldw	r2,4(r2)
   17b48:	e0bffc15 	stw	r2,-16(fp)
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  type = ethhdr->type;
   17b4c:	e0bffc17 	ldw	r2,-16(fp)
   17b50:	1080038b 	ldhu	r2,14(r2)
   17b54:	e0bffd0d 	sth	r2,-12(fp)

#if LWIP_ARP_FILTER_NETIF
  netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
   17b58:	e0bffc17 	ldw	r2,-16(fp)
   17b5c:	10800083 	ldbu	r2,2(r2)
   17b60:	10803fcc 	andi	r2,r2,255
   17b64:	1080004c 	andi	r2,r2,1
   17b68:	10002226 	beq	r2,zero,17bf4 <ethernet_input+0x174>
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
   17b6c:	e0bffc17 	ldw	r2,-16(fp)
   17b70:	10800083 	ldbu	r2,2(r2)
   17b74:	10803fcc 	andi	r2,r2,255
   17b78:	10800058 	cmpnei	r2,r2,1
   17b7c:	1000101e 	bne	r2,zero,17bc0 <ethernet_input+0x140>
      if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
   17b80:	e0bffc17 	ldw	r2,-16(fp)
   17b84:	108000c3 	ldbu	r2,3(r2)
   17b88:	10803fcc 	andi	r2,r2,255
   17b8c:	1000191e 	bne	r2,zero,17bf4 <ethernet_input+0x174>
          (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
   17b90:	e0bffc17 	ldw	r2,-16(fp)
   17b94:	10800103 	ldbu	r2,4(r2)
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
      if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
   17b98:	10803fcc 	andi	r2,r2,255
   17b9c:	10801798 	cmpnei	r2,r2,94
   17ba0:	1000141e 	bne	r2,zero,17bf4 <ethernet_input+0x174>
          (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
        /* mark the pbuf as link-layer multicast */
        p->flags |= PBUF_FLAG_LLMCAST;
   17ba4:	e0bffe17 	ldw	r2,-8(fp)
   17ba8:	10800343 	ldbu	r2,13(r2)
   17bac:	10800414 	ori	r2,r2,16
   17bb0:	1007883a 	mov	r3,r2
   17bb4:	e0bffe17 	ldw	r2,-8(fp)
   17bb8:	10c00345 	stb	r3,13(r2)
   17bbc:	00000d06 	br	17bf4 <ethernet_input+0x174>
      }
    } else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
   17bc0:	e0bffc17 	ldw	r2,-16(fp)
   17bc4:	10800084 	addi	r2,r2,2
   17bc8:	1009883a 	mov	r4,r2
   17bcc:	d1600884 	addi	r5,gp,-32734
   17bd0:	01800184 	movi	r6,6
   17bd4:	00191740 	call	19174 <memcmp>
   17bd8:	1000061e 	bne	r2,zero,17bf4 <ethernet_input+0x174>
      /* mark the pbuf as link-layer broadcast */
      p->flags |= PBUF_FLAG_LLBCAST;
   17bdc:	e0bffe17 	ldw	r2,-8(fp)
   17be0:	10800343 	ldbu	r2,13(r2)
   17be4:	10800214 	ori	r2,r2,8
   17be8:	1007883a 	mov	r3,r2
   17bec:	e0bffe17 	ldw	r2,-8(fp)
   17bf0:	10c00345 	stb	r3,13(r2)
    }
  }

  switch (type) {
   17bf4:	e0bffd0b 	ldhu	r2,-12(fp)
   17bf8:	10c00220 	cmpeqi	r3,r2,8
   17bfc:	1800031e 	bne	r3,zero,17c0c <ethernet_input+0x18c>
   17c00:	10818220 	cmpeqi	r2,r2,1544
   17c04:	1000201e 	bne	r2,zero,17c88 <ethernet_input+0x208>
   17c08:	00002b06 	br	17cb8 <ethernet_input+0x238>
#if LWIP_ARP
    /* IP packet? */
    case PP_HTONS(ETHTYPE_IP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
   17c0c:	e0bfff17 	ldw	r2,-4(fp)
   17c10:	10800b43 	ldbu	r2,45(r2)
   17c14:	10803fcc 	andi	r2,r2,255
   17c18:	1080080c 	andi	r2,r2,32
   17c1c:	10003926 	beq	r2,zero,17d04 <ethernet_input+0x284>
        goto free_and_return;
      }
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
   17c20:	e13fff17 	ldw	r4,-4(fp)
   17c24:	e17ffe17 	ldw	r5,-8(fp)
   17c28:	0016a0c0 	call	16a0c <etharp_ip_input>
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -ip_hdr_offset)) {
   17c2c:	e0bffb0b 	ldhu	r2,-20(fp)
   17c30:	0085c83a 	sub	r2,zero,r2
   17c34:	10bfffcc 	andi	r2,r2,65535
   17c38:	10a0001c 	xori	r2,r2,32768
   17c3c:	10a00004 	addi	r2,r2,-32768
   17c40:	e13ffe17 	ldw	r4,-8(fp)
   17c44:	100b883a 	mov	r5,r2
   17c48:	000a83c0 	call	a83c <pbuf_header>
   17c4c:	10803fcc 	andi	r2,r2,255
   17c50:	10000926 	beq	r2,zero,17c78 <ethernet_input+0x1f8>
        LWIP_ASSERT("Can't move over header in packet", 0);
   17c54:	010000f4 	movhi	r4,3
   17c58:	2103ce04 	addi	r4,r4,3896
   17c5c:	014000f4 	movhi	r5,3
   17c60:	29446504 	addi	r5,r5,4500
   17c64:	01815644 	movi	r6,1369
   17c68:	01c000f4 	movhi	r7,3
   17c6c:	39c3db04 	addi	r7,r7,3948
   17c70:	00193f00 	call	193f0 <printf>
   17c74:	003fff06 	br	17c74 <ethernet_input+0x1f4>
        goto free_and_return;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
   17c78:	e13ffe17 	ldw	r4,-8(fp)
   17c7c:	e17fff17 	ldw	r5,-4(fp)
   17c80:	00063480 	call	6348 <ip_input>
      }
      break;
   17c84:	00001d06 	br	17cfc <ethernet_input+0x27c>
      
    case PP_HTONS(ETHTYPE_ARP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
   17c88:	e0bfff17 	ldw	r2,-4(fp)
   17c8c:	10800b43 	ldbu	r2,45(r2)
   17c90:	10803fcc 	andi	r2,r2,255
   17c94:	1080080c 	andi	r2,r2,32
   17c98:	10001c26 	beq	r2,zero,17d0c <ethernet_input+0x28c>
        goto free_and_return;
      }
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
   17c9c:	e0bfff17 	ldw	r2,-4(fp)
   17ca0:	108009c4 	addi	r2,r2,39
   17ca4:	e13fff17 	ldw	r4,-4(fp)
   17ca8:	100b883a 	mov	r5,r2
   17cac:	e1bffe17 	ldw	r6,-8(fp)
   17cb0:	0016ad40 	call	16ad4 <etharp_arp_input>
      break;
   17cb4:	00001106 	br	17cfc <ethernet_input+0x27c>
      pppoe_data_input(netif, p);
      break;
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
   17cb8:	00800234 	movhi	r2,8
   17cbc:	1083bd04 	addi	r2,r2,3828
   17cc0:	10800a0b 	ldhu	r2,40(r2)
   17cc4:	10800044 	addi	r2,r2,1
   17cc8:	1007883a 	mov	r3,r2
   17ccc:	00800234 	movhi	r2,8
   17cd0:	1083bd04 	addi	r2,r2,3828
   17cd4:	10c00a0d 	sth	r3,40(r2)
      ETHARP_STATS_INC(etharp.drop);
   17cd8:	00800234 	movhi	r2,8
   17cdc:	1083bd04 	addi	r2,r2,3828
   17ce0:	1080078b 	ldhu	r2,30(r2)
   17ce4:	10800044 	addi	r2,r2,1
   17ce8:	1007883a 	mov	r3,r2
   17cec:	00800234 	movhi	r2,8
   17cf0:	1083bd04 	addi	r2,r2,3828
   17cf4:	10c0078d 	sth	r3,30(r2)
      goto free_and_return;
   17cf8:	00000506 	br	17d10 <ethernet_input+0x290>
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
   17cfc:	0005883a 	mov	r2,zero
   17d00:	00000606 	br	17d1c <ethernet_input+0x29c>
  switch (type) {
#if LWIP_ARP
    /* IP packet? */
    case PP_HTONS(ETHTYPE_IP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
        goto free_and_return;
   17d04:	0001883a 	nop
   17d08:	00000106 	br	17d10 <ethernet_input+0x290>
      }
      break;
      
    case PP_HTONS(ETHTYPE_ARP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
        goto free_and_return;
   17d0c:	0001883a 	nop
  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;

free_and_return:
  pbuf_free(p);
   17d10:	e13ffe17 	ldw	r4,-8(fp)
   17d14:	000aa340 	call	aa34 <pbuf_free>
  return ERR_OK;
   17d18:	0005883a 	mov	r2,zero
}
   17d1c:	e037883a 	mov	sp,fp
   17d20:	dfc00117 	ldw	ra,4(sp)
   17d24:	df000017 	ldw	fp,0(sp)
   17d28:	dec00204 	addi	sp,sp,8
   17d2c:	f800283a 	ret

00017d30 <lwipAlarmCallback>:
static alt_u32  lwipTicksPer250mS;
static alt_u32  lwip250mStimer;

//  Alarm callback function.
alt_u32 lwipAlarmCallback(void* context)
{
   17d30:	defffe04 	addi	sp,sp,-8
   17d34:	df000115 	stw	fp,4(sp)
   17d38:	df000104 	addi	fp,sp,4
   17d3c:	e13fff15 	stw	r4,-4(fp)
    lwipProcessTimerFlag = 1;          //  Set flag to process timers
   17d40:	00800044 	movi	r2,1
   17d44:	d0a8cc15 	stw	r2,-23760(gp)
    return lwipTicksPer250mS;
   17d48:	d0a8cd17 	ldw	r2,-23756(gp)
}
   17d4c:	e037883a 	mov	sp,fp
   17d50:	df000017 	ldw	fp,0(sp)
   17d54:	dec00104 	addi	sp,sp,4
   17d58:	f800283a 	ret

00017d5c <main>:

//  Define netif for lwIP
struct netif    alteraTseNetif;

int main()
{
   17d5c:	defc1104 	addi	sp,sp,-4028
   17d60:	dfc3ee15 	stw	ra,4024(sp)
   17d64:	df03ed15 	stw	fp,4020(sp)
   17d68:	df03ed04 	addi	fp,sp,4020
// Enable/disable this in echo.h
#if TEST_HISTOGRAM
	// Start altera timestamp
	//alt_timestamp_start();
    // Get timestamp freq
    timestamp_freq = alt_timestamp_freq();
   17d6c:	0026d9c0 	call	26d9c <alt_timestamp_freq>
   17d70:	00c000f4 	movhi	r3,3
   17d74:	18de1d04 	addi	r3,r3,30836
   17d78:	18800015 	stw	r2,0(r3)
    // Init histogram
    uint32      histarea[1001];
	int i;
    for (i = 1; i <= TNUM_HIST; i++){
   17d7c:	00800044 	movi	r2,1
   17d80:	e0bc1615 	stw	r2,-4008(fp)
   17d84:	00000906 	br	17dac <main+0x50>
        init_hist(i, 1000, histarea);
   17d88:	e0fc1617 	ldw	r3,-4008(fp)
   17d8c:	e0bc1704 	addi	r2,fp,-4004
   17d90:	1809883a 	mov	r4,r3
   17d94:	0140fa04 	movi	r5,1000
   17d98:	100d883a 	mov	r6,r2
   17d9c:	0001b140 	call	1b14 <init_hist>
    // Get timestamp freq
    timestamp_freq = alt_timestamp_freq();
    // Init histogram
    uint32      histarea[1001];
	int i;
    for (i = 1; i <= TNUM_HIST; i++){
   17da0:	e0bc1617 	ldw	r2,-4008(fp)
   17da4:	10800044 	addi	r2,r2,1
   17da8:	e0bc1615 	stw	r2,-4008(fp)
   17dac:	e0bc1617 	ldw	r2,-4008(fp)
   17db0:	1089c450 	cmplti	r2,r2,10001
   17db4:	103ff41e 	bne	r2,zero,17d88 <main+0x2c>
        init_hist(i, 1000, histarea);
    }
#endif /* TEST_HISTOGRAM */

    printf("Running...\n");
   17db8:	010000f4 	movhi	r4,3
   17dbc:	21046e04 	addi	r4,r4,4536
   17dc0:	001965c0 	call	1965c <puts>
    lwip250mStimer = 0;
   17dc4:	d028ce15 	stw	zero,-23752(gp)
    lwipProcessTimerFlag = 0;
   17dc8:	d028cc15 	stw	zero,-23760(gp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
   17dcc:	008000f4 	movhi	r2,3
   17dd0:	109e4d04 	addi	r2,r2,31028
   17dd4:	10800017 	ldw	r2,0(r2)
    lwipTicksPer250mS = alt_ticks_per_second() / 4;
   17dd8:	1004d0ba 	srli	r2,r2,2
   17ddc:	d0a8cd15 	stw	r2,-23756(gp)
    if (alt_alarm_start (&lwipAlarm, lwipTicksPer250mS, lwipAlarmCallback, NULL) < 0)
   17de0:	d0a8cd17 	ldw	r2,-23756(gp)
   17de4:	01000134 	movhi	r4,4
   17de8:	21176b04 	addi	r4,r4,23980
   17dec:	100b883a 	mov	r5,r2
   17df0:	01800074 	movhi	r6,1
   17df4:	319f4c04 	addi	r6,r6,32048
   17df8:	000f883a 	mov	r7,zero
   17dfc:	00218400 	call	21840 <alt_alarm_start>
   17e00:	1000040e 	bge	r2,zero,17e14 <main+0xb8>
        {
        printf ("System clock is required!\n");
   17e04:	010000f4 	movhi	r4,3
   17e08:	21047104 	addi	r4,r4,4548
   17e0c:	001965c0 	call	1965c <puts>
        for(;;);
   17e10:	003fff06 	br	17e10 <main+0xb4>
        }
    
    //  Load platform specific MAC address into netif
    alteraTseNetif.hwaddr[0] = 0x00;
   17e14:	00800234 	movhi	r2,8
   17e18:	10840504 	addi	r2,r2,4116
   17e1c:	100009c5 	stb	zero,39(r2)
    alteraTseNetif.hwaddr[1] = 0x07;
   17e20:	00800234 	movhi	r2,8
   17e24:	10840504 	addi	r2,r2,4116
   17e28:	00c001c4 	movi	r3,7
   17e2c:	10c00a05 	stb	r3,40(r2)
    alteraTseNetif.hwaddr[2] = 0xab;
   17e30:	00800234 	movhi	r2,8
   17e34:	10840504 	addi	r2,r2,4116
   17e38:	00ffeac4 	movi	r3,-85
   17e3c:	10c00a45 	stb	r3,41(r2)
    alteraTseNetif.hwaddr[3] = 0xf0;
   17e40:	00800234 	movhi	r2,8
   17e44:	10840504 	addi	r2,r2,4116
   17e48:	00fffc04 	movi	r3,-16
   17e4c:	10c00a85 	stb	r3,42(r2)
    alteraTseNetif.hwaddr[4] = 0x0d;
   17e50:	00800234 	movhi	r2,8
   17e54:	10840504 	addi	r2,r2,4116
   17e58:	00c00344 	movi	r3,13
   17e5c:	10c00ac5 	stb	r3,43(r2)
    alteraTseNetif.hwaddr[5] = 0xba;
   17e60:	00800234 	movhi	r2,8
   17e64:	10840504 	addi	r2,r2,4116
   17e68:	00ffee84 	movi	r3,-70
   17e6c:	10c00b05 	stb	r3,44(r2)

    //  Initialize lwIP, Altera TSE and the ethernetif
    lwip_init();
   17e70:	00053c00 	call	53c0 <lwip_init>
    if(netif_add(&alteraTseNetif, &ip_zero, &ip_zero, &ip_zero, alteraTseNetif.state, ethernetif_init, ethernet_input) == NULL)
   17e74:	00800234 	movhi	r2,8
   17e78:	10840504 	addi	r2,r2,4116
   17e7c:	10800717 	ldw	r2,28(r2)
   17e80:	d8800015 	stw	r2,0(sp)
   17e84:	00800034 	movhi	r2,0
   17e88:	10810604 	addi	r2,r2,1048
   17e8c:	d8800115 	stw	r2,4(sp)
   17e90:	00800074 	movhi	r2,1
   17e94:	109ea004 	addi	r2,r2,31360
   17e98:	d8800215 	stw	r2,8(sp)
   17e9c:	01000234 	movhi	r4,8
   17ea0:	21040504 	addi	r4,r4,4116
   17ea4:	d168cf04 	addi	r5,gp,-23748
   17ea8:	d1a8cf04 	addi	r6,gp,-23748
   17eac:	d1e8cf04 	addi	r7,gp,-23748
   17eb0:	00098e80 	call	98e8 <netif_add>
   17eb4:	1000041e 	bne	r2,zero,17ec8 <main+0x16c>
        {
        printf( "Fatal error initializing...\n" );
   17eb8:	010000f4 	movhi	r4,3
   17ebc:	21047804 	addi	r4,r4,4576
   17ec0:	001965c0 	call	1965c <puts>
        for(;;);
   17ec4:	003fff06 	br	17ec4 <main+0x168>
        }
    netif_set_default(&alteraTseNetif);
   17ec8:	01000234 	movhi	r4,8
   17ecc:	21040504 	addi	r4,r4,4116
   17ed0:	0009db80 	call	9db8 <netif_set_default>
    
    // Initialize Altera TSE in a loop if waiting for a link
    printf("Waiting for link...");
   17ed4:	010000f4 	movhi	r4,3
   17ed8:	21047f04 	addi	r4,r4,4604
   17edc:	00193f00 	call	193f0 <printf>
    while(((struct ethernetif *) alteraTseNetif.state)->link_alive!=1)
   17ee0:	00001006 	br	17f24 <main+0x1c8>
        {
        mSdelay(1000);
   17ee4:	010003f4 	movhi	r4,15
   17ee8:	21109004 	addi	r4,r4,16960
   17eec:	00224a80 	call	224a8 <usleep>
        putchar('.');
   17ef0:	008000f4 	movhi	r2,3
   17ef4:	10957f04 	addi	r2,r2,22012
   17ef8:	10800017 	ldw	r2,0(r2)
   17efc:	10800217 	ldw	r2,8(r2)
   17f00:	01000b84 	movi	r4,46
   17f04:	100b883a 	mov	r5,r2
   17f08:	00194e80 	call	194e8 <putc>
        tse_mac_init(0, alteraTseNetif.state);
   17f0c:	00800234 	movhi	r2,8
   17f10:	10840504 	addi	r2,r2,4116
   17f14:	10800717 	ldw	r2,28(r2)
   17f18:	0009883a 	mov	r4,zero
   17f1c:	100b883a 	mov	r5,r2
   17f20:	0000ca40 	call	ca4 <tse_mac_init>
        }
    netif_set_default(&alteraTseNetif);
    
    // Initialize Altera TSE in a loop if waiting for a link
    printf("Waiting for link...");
    while(((struct ethernetif *) alteraTseNetif.state)->link_alive!=1)
   17f24:	00800234 	movhi	r2,8
   17f28:	10840504 	addi	r2,r2,4116
   17f2c:	10800717 	ldw	r2,28(r2)
   17f30:	10800217 	ldw	r2,8(r2)
   17f34:	10800058 	cmpnei	r2,r2,1
   17f38:	103fea1e 	bne	r2,zero,17ee4 <main+0x188>
        {
        mSdelay(1000);
        putchar('.');
        tse_mac_init(0, alteraTseNetif.state);
        }
    printf("OK\n");
   17f3c:	010000f4 	movhi	r4,3
   17f40:	21048404 	addi	r4,r4,4624
   17f44:	001965c0 	call	1965c <puts>
            lwipProcessTimers();
        //  Poll lwIP for incoming packets.
        ethernetif_input(&alteraTseNetif);
        }
#else
    STATIC_IP;
   17f48:	008802f4 	movhi	r2,8203
   17f4c:	10862b04 	addi	r2,r2,6316
   17f50:	d0a8d015 	stw	r2,-23744(gp)
    netif_set_ipaddr(&alteraTseNetif, &lwipStaticIp);
   17f54:	01000234 	movhi	r4,8
   17f58:	21040504 	addi	r4,r4,4116
   17f5c:	d168d004 	addi	r5,gp,-23744
   17f60:	0009bfc0 	call	9bfc <netif_set_ipaddr>
    netif_set_up(&alteraTseNetif);
   17f64:	01000234 	movhi	r4,8
   17f68:	21040504 	addi	r4,r4,4116
   17f6c:	0009de00 	call	9de0 <netif_set_up>
#endif
    printf("IP address: %s\n", ip_ntoa(&alteraTseNetif.ip_addr));
   17f70:	01000234 	movhi	r4,8
   17f74:	21040604 	addi	r4,r4,4120
   17f78:	00073a00 	call	73a0 <ipaddr_ntoa>
   17f7c:	010000f4 	movhi	r4,3
   17f80:	21048504 	addi	r4,r4,4628
   17f84:	100b883a 	mov	r5,r2
   17f88:	00193f00 	call	193f0 <printf>

#if BUILD_HTTPD
    httpd_init();
#endif
    udpecho_init();
   17f8c:	0001a3c0 	call	1a3c <udpecho_init>
    //  This is the main loop for lwIP - other processing can be done by calling application functions.
    for(;;)
        {
        //  Process lwIP timer dependent code
        if(lwipProcessTimerFlag)
   17f90:	d0a8cc17 	ldw	r2,-23760(gp)
   17f94:	10000126 	beq	r2,zero,17f9c <main+0x240>
            lwipProcessTimers();
   17f98:	0017fac0 	call	17fac <lwipProcessTimers>
        //  Poll lwIP for incoming packets.
        ethernetif_input(&alteraTseNetif);
   17f9c:	01000234 	movhi	r4,8
   17fa0:	21040504 	addi	r4,r4,4116
   17fa4:	00003340 	call	334 <ethernetif_input>
        }
   17fa8:	003ff906 	br	17f90 <main+0x234>

00017fac <lwipProcessTimers>:
    return 0;
}

//  Run this every 250mS to update lwIP timers
void        lwipProcessTimers(void)
{
   17fac:	defffe04 	addi	sp,sp,-8
   17fb0:	dfc00115 	stw	ra,4(sp)
   17fb4:	df000015 	stw	fp,0(sp)
   17fb8:	d839883a 	mov	fp,sp
    lwipProcessTimerFlag = 0;
   17fbc:	d028cc15 	stw	zero,-23760(gp)
    lwip250mStimer += 250;
   17fc0:	d0a8ce17 	ldw	r2,-23752(gp)
   17fc4:	10803e84 	addi	r2,r2,250
   17fc8:	d0a8ce15 	stw	r2,-23752(gp)
    if( (lwip250mStimer % TCP_TMR_INTERVAL) == 0 ) { tcp_tmr(); }
   17fcc:	d0a8ce17 	ldw	r2,-23752(gp)
   17fd0:	00c03e84 	movi	r3,250
   17fd4:	10c7203a 	divu	r3,r2,r3
   17fd8:	18c03ea4 	muli	r3,r3,250
   17fdc:	10c5c83a 	sub	r2,r2,r3
   17fe0:	1000011e 	bne	r2,zero,17fe8 <lwipProcessTimers+0x3c>
   17fe4:	000be740 	call	be74 <tcp_tmr>
    if( (lwip250mStimer % ARP_TMR_INTERVAL) == 0 ) { etharp_tmr(); }
   17fe8:	d0a8ce17 	ldw	r2,-23752(gp)
   17fec:	00c4e204 	movi	r3,5000
   17ff0:	10c7203a 	divu	r3,r2,r3
   17ff4:	18c4e224 	muli	r3,r3,5000
   17ff8:	10c5c83a 	sub	r2,r2,r3
   17ffc:	1000011e 	bne	r2,zero,18004 <lwipProcessTimers+0x58>
   18000:	0015fe00 	call	15fe0 <etharp_tmr>
#if IP_REASSEMBLY
    if( (lwip250mStimer % IP_TMR_INTERVAL) == 0 ) { ip_reass_tmr(); }
   18004:	d0a8ce17 	ldw	r2,-23752(gp)
   18008:	00c0fa04 	movi	r3,1000
   1800c:	10c7203a 	divu	r3,r2,r3
   18010:	18c0fa24 	muli	r3,r3,1000
   18014:	10c5c83a 	sub	r2,r2,r3
   18018:	1000011e 	bne	r2,zero,18020 <lwipProcessTimers+0x74>
   1801c:	000758c0 	call	758c <ip_reass_tmr>
#endif
#if LWIP_IGMP
    if( (lwip250mStimer % IGMP_TMR_INTERVAL ) == 0 ) { igmp_tmr(); } 
#endif
#if LWIP_DHCP
    if( (lwip250mStimer % DHCP_FINE_TIMER_MSECS ) == 0 ) { dhcp_fine_tmr(); }
   18020:	d0a8ce17 	ldw	r2,-23752(gp)
   18024:	00c07d04 	movi	r3,500
   18028:	10c7203a 	divu	r3,r2,r3
   1802c:	18c07d24 	muli	r3,r3,500
   18030:	10c5c83a 	sub	r2,r2,r3
   18034:	1000011e 	bne	r2,zero,1803c <lwipProcessTimers+0x90>
   18038:	00024700 	call	2470 <dhcp_fine_tmr>
    if( (lwip250mStimer % (DHCP_COARSE_TIMER_SECS*1000) ) == 0 ) { dhcp_coarse_tmr(); }
   1803c:	d0a8ce17 	ldw	r2,-23752(gp)
   18040:	00fa9814 	movui	r3,60000
   18044:	10c9203a 	divu	r4,r2,r3
   18048:	00fa9814 	movui	r3,60000
   1804c:	20c7383a 	mul	r3,r4,r3
   18050:	10c5c83a 	sub	r2,r2,r3
   18054:	1000011e 	bne	r2,zero,1805c <lwipProcessTimers+0xb0>
   18058:	00023bc0 	call	23bc <dhcp_coarse_tmr>
#endif
#if LWIP_DNS
    if( (lwip250mStimer % DNS_TMR_INTERVAL) == 0 ) { dns_tmr(); }
#endif
}
   1805c:	e037883a 	mov	sp,fp
   18060:	dfc00117 	ldw	ra,4(sp)
   18064:	df000017 	ldw	fp,0(sp)
   18068:	dec00204 	addi	sp,sp,8
   1806c:	f800283a 	ret

00018070 <__fixunsdfsi>:
   18070:	defffd04 	addi	sp,sp,-12
   18074:	000d883a 	mov	r6,zero
   18078:	01d07834 	movhi	r7,16864
   1807c:	dc400115 	stw	r17,4(sp)
   18080:	dc000015 	stw	r16,0(sp)
   18084:	dfc00215 	stw	ra,8(sp)
   18088:	2023883a 	mov	r17,r4
   1808c:	2821883a 	mov	r16,r5
   18090:	00189940 	call	18994 <__gedf2>
   18094:	1000080e 	bge	r2,zero,180b8 <__fixunsdfsi+0x48>
   18098:	8809883a 	mov	r4,r17
   1809c:	800b883a 	mov	r5,r16
   180a0:	00189f80 	call	189f8 <__fixdfsi>
   180a4:	dfc00217 	ldw	ra,8(sp)
   180a8:	dc400117 	ldw	r17,4(sp)
   180ac:	dc000017 	ldw	r16,0(sp)
   180b0:	dec00304 	addi	sp,sp,12
   180b4:	f800283a 	ret
   180b8:	000d883a 	mov	r6,zero
   180bc:	01d07834 	movhi	r7,16864
   180c0:	8809883a 	mov	r4,r17
   180c4:	800b883a 	mov	r5,r16
   180c8:	001849c0 	call	1849c <__subdf3>
   180cc:	180b883a 	mov	r5,r3
   180d0:	1009883a 	mov	r4,r2
   180d4:	00189f80 	call	189f8 <__fixdfsi>
   180d8:	00e00034 	movhi	r3,32768
   180dc:	10c5883a 	add	r2,r2,r3
   180e0:	dfc00217 	ldw	ra,8(sp)
   180e4:	dc400117 	ldw	r17,4(sp)
   180e8:	dc000017 	ldw	r16,0(sp)
   180ec:	dec00304 	addi	sp,sp,12
   180f0:	f800283a 	ret

000180f4 <_fpadd_parts>:
   180f4:	2005883a 	mov	r2,r4
   180f8:	21000017 	ldw	r4,0(r4)
   180fc:	01c00044 	movi	r7,1
   18100:	3900622e 	bgeu	r7,r4,1828c <_fpadd_parts+0x198>
   18104:	28c00017 	ldw	r3,0(r5)
   18108:	38c05f2e 	bgeu	r7,r3,18288 <_fpadd_parts+0x194>
   1810c:	01c00104 	movi	r7,4
   18110:	21c0c626 	beq	r4,r7,1842c <_fpadd_parts+0x338>
   18114:	19c05c26 	beq	r3,r7,18288 <_fpadd_parts+0x194>
   18118:	01c00084 	movi	r7,2
   1811c:	19c06b26 	beq	r3,r7,182cc <_fpadd_parts+0x1d8>
   18120:	21c05926 	beq	r4,r7,18288 <_fpadd_parts+0x194>
   18124:	11c00217 	ldw	r7,8(r2)
   18128:	2ac00217 	ldw	r11,8(r5)
   1812c:	13000317 	ldw	r12,12(r2)
   18130:	13400417 	ldw	r13,16(r2)
   18134:	3ac9c83a 	sub	r4,r7,r11
   18138:	2a000317 	ldw	r8,12(r5)
   1813c:	2a400417 	ldw	r9,16(r5)
   18140:	2015883a 	mov	r10,r4
   18144:	20007516 	blt	r4,zero,1831c <_fpadd_parts+0x228>
   18148:	00c00fc4 	movi	r3,63
   1814c:	1a805016 	blt	r3,r10,18290 <_fpadd_parts+0x19c>
   18150:	0100870e 	bge	zero,r4,18370 <_fpadd_parts+0x27c>
   18154:	50fff804 	addi	r3,r10,-32
   18158:	18009916 	blt	r3,zero,183c0 <_fpadd_parts+0x2cc>
   1815c:	48d6d83a 	srl	r11,r9,r3
   18160:	001d883a 	mov	r14,zero
   18164:	18009e16 	blt	r3,zero,183e0 <_fpadd_parts+0x2ec>
   18168:	01000044 	movi	r4,1
   1816c:	20c6983a 	sll	r3,r4,r3
   18170:	0015883a 	mov	r10,zero
   18174:	513fffc4 	addi	r4,r10,-1
   18178:	2295403a 	cmpgeu	r10,r4,r10
   1817c:	1a87c83a 	sub	r3,r3,r10
   18180:	1a52703a 	and	r9,r3,r9
   18184:	2210703a 	and	r8,r4,r8
   18188:	4250b03a 	or	r8,r8,r9
   1818c:	4010c03a 	cmpne	r8,r8,zero
   18190:	42d0b03a 	or	r8,r8,r11
   18194:	7013883a 	mov	r9,r14
   18198:	11000117 	ldw	r4,4(r2)
   1819c:	28800117 	ldw	r2,4(r5)
   181a0:	20804126 	beq	r4,r2,182a8 <_fpadd_parts+0x1b4>
   181a4:	20006326 	beq	r4,zero,18334 <_fpadd_parts+0x240>
   181a8:	4305c83a 	sub	r2,r8,r12
   181ac:	4091803a 	cmpltu	r8,r8,r2
   181b0:	4b47c83a 	sub	r3,r9,r13
   181b4:	1a07c83a 	sub	r3,r3,r8
   181b8:	18006316 	blt	r3,zero,18348 <_fpadd_parts+0x254>
   181bc:	30000115 	stw	zero,4(r6)
   181c0:	31c00215 	stw	r7,8(r6)
   181c4:	30800315 	stw	r2,12(r6)
   181c8:	30c00415 	stw	r3,16(r6)
   181cc:	11ffffc4 	addi	r7,r2,-1
   181d0:	388b403a 	cmpgeu	r5,r7,r2
   181d4:	194bc83a 	sub	r5,r3,r5
   181d8:	01040034 	movhi	r4,4096
   181dc:	213fffc4 	addi	r4,r4,-1
   181e0:	21401736 	bltu	r4,r5,18240 <_fpadd_parts+0x14c>
   181e4:	29008226 	beq	r5,r4,183f0 <_fpadd_parts+0x2fc>
   181e8:	31400217 	ldw	r5,8(r6)
   181ec:	02840034 	movhi	r10,4096
   181f0:	52bfffc4 	addi	r10,r10,-1
   181f4:	033fff84 	movi	r12,-2
   181f8:	297fffc4 	addi	r5,r5,-1
   181fc:	00000106 	br	18204 <_fpadd_parts+0x110>
   18200:	3a804a26 	beq	r7,r10,1832c <_fpadd_parts+0x238>
   18204:	1089883a 	add	r4,r2,r2
   18208:	2091803a 	cmpltu	r8,r4,r2
   1820c:	18c7883a 	add	r3,r3,r3
   18210:	227fffc4 	addi	r9,r4,-1
   18214:	40d1883a 	add	r8,r8,r3
   18218:	490f403a 	cmpgeu	r7,r9,r4
   1821c:	41cfc83a 	sub	r7,r8,r7
   18220:	2817883a 	mov	r11,r5
   18224:	2005883a 	mov	r2,r4
   18228:	4007883a 	mov	r3,r8
   1822c:	297fffc4 	addi	r5,r5,-1
   18230:	51fff32e 	bgeu	r10,r7,18200 <_fpadd_parts+0x10c>
   18234:	31000315 	stw	r4,12(r6)
   18238:	32000415 	stw	r8,16(r6)
   1823c:	32c00215 	stw	r11,8(r6)
   18240:	010000c4 	movi	r4,3
   18244:	31000015 	stw	r4,0(r6)
   18248:	01080034 	movhi	r4,8192
   1824c:	213fffc4 	addi	r4,r4,-1
   18250:	20c00b2e 	bgeu	r4,r3,18280 <_fpadd_parts+0x18c>
   18254:	180e97fa 	slli	r7,r3,31
   18258:	1008d07a 	srli	r4,r2,1
   1825c:	31400217 	ldw	r5,8(r6)
   18260:	1806d07a 	srli	r3,r3,1
   18264:	1080004c 	andi	r2,r2,1
   18268:	3908b03a 	or	r4,r7,r4
   1826c:	1108b03a 	or	r4,r2,r4
   18270:	29400044 	addi	r5,r5,1
   18274:	31000315 	stw	r4,12(r6)
   18278:	30c00415 	stw	r3,16(r6)
   1827c:	31400215 	stw	r5,8(r6)
   18280:	3005883a 	mov	r2,r6
   18284:	f800283a 	ret
   18288:	2805883a 	mov	r2,r5
   1828c:	f800283a 	ret
   18290:	59c01e0e 	bge	r11,r7,1830c <_fpadd_parts+0x218>
   18294:	11000117 	ldw	r4,4(r2)
   18298:	28800117 	ldw	r2,4(r5)
   1829c:	0011883a 	mov	r8,zero
   182a0:	0013883a 	mov	r9,zero
   182a4:	20bfbf1e 	bne	r4,r2,181a4 <_fpadd_parts+0xb0>
   182a8:	4305883a 	add	r2,r8,r12
   182ac:	1207803a 	cmpltu	r3,r2,r8
   182b0:	4b53883a 	add	r9,r9,r13
   182b4:	1a47883a 	add	r3,r3,r9
   182b8:	31000115 	stw	r4,4(r6)
   182bc:	31c00215 	stw	r7,8(r6)
   182c0:	30800315 	stw	r2,12(r6)
   182c4:	30c00415 	stw	r3,16(r6)
   182c8:	003fdd06 	br	18240 <_fpadd_parts+0x14c>
   182cc:	20ffef1e 	bne	r4,r3,1828c <_fpadd_parts+0x198>
   182d0:	31000015 	stw	r4,0(r6)
   182d4:	10c00117 	ldw	r3,4(r2)
   182d8:	30c00115 	stw	r3,4(r6)
   182dc:	10c00217 	ldw	r3,8(r2)
   182e0:	11000117 	ldw	r4,4(r2)
   182e4:	29400117 	ldw	r5,4(r5)
   182e8:	30c00215 	stw	r3,8(r6)
   182ec:	10c00317 	ldw	r3,12(r2)
   182f0:	2908703a 	and	r4,r5,r4
   182f4:	30c00315 	stw	r3,12(r6)
   182f8:	10c00417 	ldw	r3,16(r2)
   182fc:	31000115 	stw	r4,4(r6)
   18300:	3005883a 	mov	r2,r6
   18304:	30c00415 	stw	r3,16(r6)
   18308:	f800283a 	ret
   1830c:	580f883a 	mov	r7,r11
   18310:	0019883a 	mov	r12,zero
   18314:	001b883a 	mov	r13,zero
   18318:	003f9f06 	br	18198 <_fpadd_parts+0xa4>
   1831c:	0115c83a 	sub	r10,zero,r4
   18320:	00c00fc4 	movi	r3,63
   18324:	1abfda16 	blt	r3,r10,18290 <_fpadd_parts+0x19c>
   18328:	003f8906 	br	18150 <_fpadd_parts+0x5c>
   1832c:	627fb52e 	bgeu	r12,r9,18204 <_fpadd_parts+0x110>
   18330:	003fc006 	br	18234 <_fpadd_parts+0x140>
   18334:	6205c83a 	sub	r2,r12,r8
   18338:	6099803a 	cmpltu	r12,r12,r2
   1833c:	6a47c83a 	sub	r3,r13,r9
   18340:	1b07c83a 	sub	r3,r3,r12
   18344:	183f9d0e 	bge	r3,zero,181bc <_fpadd_parts+0xc8>
   18348:	0085c83a 	sub	r2,zero,r2
   1834c:	1008c03a 	cmpne	r4,r2,zero
   18350:	00c7c83a 	sub	r3,zero,r3
   18354:	1907c83a 	sub	r3,r3,r4
   18358:	01000044 	movi	r4,1
   1835c:	31000115 	stw	r4,4(r6)
   18360:	31c00215 	stw	r7,8(r6)
   18364:	30800315 	stw	r2,12(r6)
   18368:	30c00415 	stw	r3,16(r6)
   1836c:	003f9706 	br	181cc <_fpadd_parts+0xd8>
   18370:	203f8926 	beq	r4,zero,18198 <_fpadd_parts+0xa4>
   18374:	50fff804 	addi	r3,r10,-32
   18378:	3a8f883a 	add	r7,r7,r10
   1837c:	18002316 	blt	r3,zero,1840c <_fpadd_parts+0x318>
   18380:	68d6d83a 	srl	r11,r13,r3
   18384:	001d883a 	mov	r14,zero
   18388:	18001c16 	blt	r3,zero,183fc <_fpadd_parts+0x308>
   1838c:	01000044 	movi	r4,1
   18390:	20c6983a 	sll	r3,r4,r3
   18394:	0015883a 	mov	r10,zero
   18398:	513fffc4 	addi	r4,r10,-1
   1839c:	2295403a 	cmpgeu	r10,r4,r10
   183a0:	1a87c83a 	sub	r3,r3,r10
   183a4:	1b5a703a 	and	r13,r3,r13
   183a8:	2318703a 	and	r12,r4,r12
   183ac:	6358b03a 	or	r12,r12,r13
   183b0:	6018c03a 	cmpne	r12,r12,zero
   183b4:	62d8b03a 	or	r12,r12,r11
   183b8:	701b883a 	mov	r13,r14
   183bc:	003f7606 	br	18198 <_fpadd_parts+0xa4>
   183c0:	4808907a 	slli	r4,r9,1
   183c4:	02c007c4 	movi	r11,31
   183c8:	5a97c83a 	sub	r11,r11,r10
   183cc:	22c8983a 	sll	r4,r4,r11
   183d0:	4296d83a 	srl	r11,r8,r10
   183d4:	4a9cd83a 	srl	r14,r9,r10
   183d8:	22d6b03a 	or	r11,r4,r11
   183dc:	003f6106 	br	18164 <_fpadd_parts+0x70>
   183e0:	00c00044 	movi	r3,1
   183e4:	1a94983a 	sll	r10,r3,r10
   183e8:	0007883a 	mov	r3,zero
   183ec:	003f6106 	br	18174 <_fpadd_parts+0x80>
   183f0:	013fff84 	movi	r4,-2
   183f4:	21ff7c2e 	bgeu	r4,r7,181e8 <_fpadd_parts+0xf4>
   183f8:	003f9106 	br	18240 <_fpadd_parts+0x14c>
   183fc:	00c00044 	movi	r3,1
   18400:	1a94983a 	sll	r10,r3,r10
   18404:	0007883a 	mov	r3,zero
   18408:	003fe306 	br	18398 <_fpadd_parts+0x2a4>
   1840c:	6816907a 	slli	r11,r13,1
   18410:	010007c4 	movi	r4,31
   18414:	2289c83a 	sub	r4,r4,r10
   18418:	5908983a 	sll	r4,r11,r4
   1841c:	6296d83a 	srl	r11,r12,r10
   18420:	6a9cd83a 	srl	r14,r13,r10
   18424:	22d6b03a 	or	r11,r4,r11
   18428:	003fd706 	br	18388 <_fpadd_parts+0x294>
   1842c:	193f971e 	bne	r3,r4,1828c <_fpadd_parts+0x198>
   18430:	11000117 	ldw	r4,4(r2)
   18434:	28c00117 	ldw	r3,4(r5)
   18438:	20ff9426 	beq	r4,r3,1828c <_fpadd_parts+0x198>
   1843c:	008000f4 	movhi	r2,3
   18440:	10848904 	addi	r2,r2,4644
   18444:	f800283a 	ret

00018448 <__adddf3>:
   18448:	deffec04 	addi	sp,sp,-80
   1844c:	d9001115 	stw	r4,68(sp)
   18450:	d9401215 	stw	r5,72(sp)
   18454:	d9001104 	addi	r4,sp,68
   18458:	d9400a04 	addi	r5,sp,40
   1845c:	dfc01315 	stw	ra,76(sp)
   18460:	d9c01015 	stw	r7,64(sp)
   18464:	d9800f15 	stw	r6,60(sp)
   18468:	0018f180 	call	18f18 <__unpack_d>
   1846c:	d9000f04 	addi	r4,sp,60
   18470:	d9400504 	addi	r5,sp,20
   18474:	0018f180 	call	18f18 <__unpack_d>
   18478:	d9000a04 	addi	r4,sp,40
   1847c:	d9400504 	addi	r5,sp,20
   18480:	d80d883a 	mov	r6,sp
   18484:	00180f40 	call	180f4 <_fpadd_parts>
   18488:	1009883a 	mov	r4,r2
   1848c:	0018cf40 	call	18cf4 <__pack_d>
   18490:	dfc01317 	ldw	ra,76(sp)
   18494:	dec01404 	addi	sp,sp,80
   18498:	f800283a 	ret

0001849c <__subdf3>:
   1849c:	deffec04 	addi	sp,sp,-80
   184a0:	d9001115 	stw	r4,68(sp)
   184a4:	d9401215 	stw	r5,72(sp)
   184a8:	d9001104 	addi	r4,sp,68
   184ac:	d9400a04 	addi	r5,sp,40
   184b0:	dfc01315 	stw	ra,76(sp)
   184b4:	d9c01015 	stw	r7,64(sp)
   184b8:	d9800f15 	stw	r6,60(sp)
   184bc:	0018f180 	call	18f18 <__unpack_d>
   184c0:	d9000f04 	addi	r4,sp,60
   184c4:	d9400504 	addi	r5,sp,20
   184c8:	0018f180 	call	18f18 <__unpack_d>
   184cc:	d8800617 	ldw	r2,24(sp)
   184d0:	d9000a04 	addi	r4,sp,40
   184d4:	d9400504 	addi	r5,sp,20
   184d8:	d80d883a 	mov	r6,sp
   184dc:	1080005c 	xori	r2,r2,1
   184e0:	d8800615 	stw	r2,24(sp)
   184e4:	00180f40 	call	180f4 <_fpadd_parts>
   184e8:	1009883a 	mov	r4,r2
   184ec:	0018cf40 	call	18cf4 <__pack_d>
   184f0:	dfc01317 	ldw	ra,76(sp)
   184f4:	dec01404 	addi	sp,sp,80
   184f8:	f800283a 	ret

000184fc <__muldf3>:
   184fc:	deffe404 	addi	sp,sp,-112
   18500:	d9001115 	stw	r4,68(sp)
   18504:	d9401215 	stw	r5,72(sp)
   18508:	d9001104 	addi	r4,sp,68
   1850c:	d9400a04 	addi	r5,sp,40
   18510:	dfc01b15 	stw	ra,108(sp)
   18514:	d9800f15 	stw	r6,60(sp)
   18518:	d9c01015 	stw	r7,64(sp)
   1851c:	ddc01a15 	stw	r23,104(sp)
   18520:	dd801915 	stw	r22,100(sp)
   18524:	dd401815 	stw	r21,96(sp)
   18528:	dd001715 	stw	r20,92(sp)
   1852c:	dcc01615 	stw	r19,88(sp)
   18530:	dc801515 	stw	r18,84(sp)
   18534:	dc401415 	stw	r17,80(sp)
   18538:	dc001315 	stw	r16,76(sp)
   1853c:	0018f180 	call	18f18 <__unpack_d>
   18540:	d9000f04 	addi	r4,sp,60
   18544:	d9400504 	addi	r5,sp,20
   18548:	0018f180 	call	18f18 <__unpack_d>
   1854c:	d8c00a17 	ldw	r3,40(sp)
   18550:	00800044 	movi	r2,1
   18554:	10c01136 	bltu	r2,r3,1859c <__muldf3+0xa0>
   18558:	d8c00b17 	ldw	r3,44(sp)
   1855c:	d8800617 	ldw	r2,24(sp)
   18560:	d9000a04 	addi	r4,sp,40
   18564:	1884c03a 	cmpne	r2,r3,r2
   18568:	d8800b15 	stw	r2,44(sp)
   1856c:	0018cf40 	call	18cf4 <__pack_d>
   18570:	dfc01b17 	ldw	ra,108(sp)
   18574:	ddc01a17 	ldw	r23,104(sp)
   18578:	dd801917 	ldw	r22,100(sp)
   1857c:	dd401817 	ldw	r21,96(sp)
   18580:	dd001717 	ldw	r20,92(sp)
   18584:	dcc01617 	ldw	r19,88(sp)
   18588:	dc801517 	ldw	r18,84(sp)
   1858c:	dc401417 	ldw	r17,80(sp)
   18590:	dc001317 	ldw	r16,76(sp)
   18594:	dec01c04 	addi	sp,sp,112
   18598:	f800283a 	ret
   1859c:	d9000517 	ldw	r4,20(sp)
   185a0:	11000636 	bltu	r2,r4,185bc <__muldf3+0xc0>
   185a4:	d8800617 	ldw	r2,24(sp)
   185a8:	d8c00b17 	ldw	r3,44(sp)
   185ac:	d9000504 	addi	r4,sp,20
   185b0:	1884c03a 	cmpne	r2,r3,r2
   185b4:	d8800615 	stw	r2,24(sp)
   185b8:	003fec06 	br	1856c <__muldf3+0x70>
   185bc:	00800104 	movi	r2,4
   185c0:	1880051e 	bne	r3,r2,185d8 <__muldf3+0xdc>
   185c4:	00800084 	movi	r2,2
   185c8:	20bfe31e 	bne	r4,r2,18558 <__muldf3+0x5c>
   185cc:	010000f4 	movhi	r4,3
   185d0:	21048904 	addi	r4,r4,4644
   185d4:	003fe506 	br	1856c <__muldf3+0x70>
   185d8:	2080031e 	bne	r4,r2,185e8 <__muldf3+0xec>
   185dc:	00800084 	movi	r2,2
   185e0:	18bffa26 	beq	r3,r2,185cc <__muldf3+0xd0>
   185e4:	003fef06 	br	185a4 <__muldf3+0xa8>
   185e8:	00800084 	movi	r2,2
   185ec:	18bfda26 	beq	r3,r2,18558 <__muldf3+0x5c>
   185f0:	20bfec26 	beq	r4,r2,185a4 <__muldf3+0xa8>
   185f4:	dc000d17 	ldw	r16,52(sp)
   185f8:	dd000817 	ldw	r20,32(sp)
   185fc:	dc800917 	ldw	r18,36(sp)
   18600:	8009883a 	mov	r4,r16
   18604:	000b883a 	mov	r5,zero
   18608:	a00d883a 	mov	r6,r20
   1860c:	000f883a 	mov	r7,zero
   18610:	0018be80 	call	18be8 <__muldi3>
   18614:	dc400e17 	ldw	r17,56(sp)
   18618:	9009883a 	mov	r4,r18
   1861c:	800d883a 	mov	r6,r16
   18620:	000b883a 	mov	r5,zero
   18624:	000f883a 	mov	r7,zero
   18628:	102f883a 	mov	r23,r2
   1862c:	1827883a 	mov	r19,r3
   18630:	0018be80 	call	18be8 <__muldi3>
   18634:	900d883a 	mov	r6,r18
   18638:	8809883a 	mov	r4,r17
   1863c:	000b883a 	mov	r5,zero
   18640:	000f883a 	mov	r7,zero
   18644:	102b883a 	mov	r21,r2
   18648:	1821883a 	mov	r16,r3
   1864c:	0018be80 	call	18be8 <__muldi3>
   18650:	8809883a 	mov	r4,r17
   18654:	000b883a 	mov	r5,zero
   18658:	a00d883a 	mov	r6,r20
   1865c:	000f883a 	mov	r7,zero
   18660:	102d883a 	mov	r22,r2
   18664:	1825883a 	mov	r18,r3
   18668:	0018be80 	call	18be8 <__muldi3>
   1866c:	154b883a 	add	r5,r2,r21
   18670:	2889803a 	cmpltu	r4,r5,r2
   18674:	1c07883a 	add	r3,r3,r16
   18678:	20c9883a 	add	r4,r4,r3
   1867c:	24004b36 	bltu	r4,r16,187ac <__muldf3+0x2b0>
   18680:	8100011e 	bne	r16,r4,18688 <__muldf3+0x18c>
   18684:	2d404936 	bltu	r5,r21,187ac <__muldf3+0x2b0>
   18688:	0011883a 	mov	r8,zero
   1868c:	0007883a 	mov	r3,zero
   18690:	2ccb883a 	add	r5,r5,r19
   18694:	b80d883a 	mov	r6,r23
   18698:	2cc0012e 	bgeu	r5,r19,186a0 <__muldf3+0x1a4>
   1869c:	02000044 	movi	r8,1
   186a0:	258f883a 	add	r7,r4,r22
   186a4:	3909803a 	cmpltu	r4,r7,r4
   186a8:	da400c17 	ldw	r9,48(sp)
   186ac:	2489883a 	add	r4,r4,r18
   186b0:	d8800717 	ldw	r2,28(sp)
   186b4:	20c9883a 	add	r4,r4,r3
   186b8:	da800b17 	ldw	r10,44(sp)
   186bc:	d8c00617 	ldw	r3,24(sp)
   186c0:	3a11883a 	add	r8,r7,r8
   186c4:	4885883a 	add	r2,r9,r2
   186c8:	50c6c03a 	cmpne	r3,r10,r3
   186cc:	41cf803a 	cmpltu	r7,r8,r7
   186d0:	12400104 	addi	r9,r2,4
   186d4:	d8c00115 	stw	r3,4(sp)
   186d8:	3909883a 	add	r4,r7,r4
   186dc:	da400215 	stw	r9,8(sp)
   186e0:	03480034 	movhi	r13,8192
   186e4:	6b7fffc4 	addi	r13,r13,-1
   186e8:	4007883a 	mov	r3,r8
   186ec:	6900102e 	bgeu	r13,r4,18730 <__muldf3+0x234>
   186f0:	10800144 	addi	r2,r2,5
   186f4:	180ed07a 	srli	r7,r3,1
   186f8:	18c0004c 	andi	r3,r3,1
   186fc:	201097fa 	slli	r8,r4,31
   18700:	281697fa 	slli	r11,r5,31
   18704:	2008d07a 	srli	r4,r4,1
   18708:	3014d07a 	srli	r10,r6,1
   1870c:	2812d07a 	srli	r9,r5,1
   18710:	1019883a 	mov	r12,r2
   18714:	18000226 	beq	r3,zero,18720 <__muldf3+0x224>
   18718:	5a8cb03a 	or	r6,r11,r10
   1871c:	49600034 	orhi	r5,r9,32768
   18720:	41c6b03a 	or	r3,r8,r7
   18724:	10800044 	addi	r2,r2,1
   18728:	693ff236 	bltu	r13,r4,186f4 <__muldf3+0x1f8>
   1872c:	db000215 	stw	r12,8(sp)
   18730:	03440034 	movhi	r13,4096
   18734:	6b7fffc4 	addi	r13,r13,-1
   18738:	69001336 	bltu	r13,r4,18788 <__muldf3+0x28c>
   1873c:	d8800217 	ldw	r2,8(sp)
   18740:	10bfffc4 	addi	r2,r2,-1
   18744:	18d3883a 	add	r9,r3,r3
   18748:	48c7803a 	cmpltu	r3,r9,r3
   1874c:	2109883a 	add	r4,r4,r4
   18750:	190f883a 	add	r7,r3,r4
   18754:	3191883a 	add	r8,r6,r6
   18758:	4197803a 	cmpltu	r11,r8,r6
   1875c:	2955883a 	add	r10,r5,r5
   18760:	1019883a 	mov	r12,r2
   18764:	4807883a 	mov	r3,r9
   18768:	3809883a 	mov	r4,r7
   1876c:	2800010e 	bge	r5,zero,18774 <__muldf3+0x278>
   18770:	48c00054 	ori	r3,r9,1
   18774:	400d883a 	mov	r6,r8
   18778:	5a8b883a 	add	r5,r11,r10
   1877c:	10bfffc4 	addi	r2,r2,-1
   18780:	69fff02e 	bgeu	r13,r7,18744 <__muldf3+0x248>
   18784:	db000215 	stw	r12,8(sp)
   18788:	18803fcc 	andi	r2,r3,255
   1878c:	01c02004 	movi	r7,128
   18790:	11c00926 	beq	r2,r7,187b8 <__muldf3+0x2bc>
   18794:	008000c4 	movi	r2,3
   18798:	d9000415 	stw	r4,16(sp)
   1879c:	d8c00315 	stw	r3,12(sp)
   187a0:	d8800015 	stw	r2,0(sp)
   187a4:	d809883a 	mov	r4,sp
   187a8:	003f7006 	br	1856c <__muldf3+0x70>
   187ac:	0011883a 	mov	r8,zero
   187b0:	00c00044 	movi	r3,1
   187b4:	003fb606 	br	18690 <__muldf3+0x194>
   187b8:	19c0400c 	andi	r7,r3,256
   187bc:	383ff51e 	bne	r7,zero,18794 <__muldf3+0x298>
   187c0:	314ab03a 	or	r5,r6,r5
   187c4:	283ff326 	beq	r5,zero,18794 <__muldf3+0x298>
   187c8:	1885883a 	add	r2,r3,r2
   187cc:	10cb803a 	cmpltu	r5,r2,r3
   187d0:	00ffc004 	movi	r3,-256
   187d4:	10c6703a 	and	r3,r2,r3
   187d8:	2909883a 	add	r4,r5,r4
   187dc:	003fed06 	br	18794 <__muldf3+0x298>

000187e0 <__divdf3>:
   187e0:	defff104 	addi	sp,sp,-60
   187e4:	d9000c15 	stw	r4,48(sp)
   187e8:	d9400d15 	stw	r5,52(sp)
   187ec:	d9000c04 	addi	r4,sp,48
   187f0:	d9400504 	addi	r5,sp,20
   187f4:	dfc00e15 	stw	ra,56(sp)
   187f8:	d9800a15 	stw	r6,40(sp)
   187fc:	d9c00b15 	stw	r7,44(sp)
   18800:	0018f180 	call	18f18 <__unpack_d>
   18804:	d9000a04 	addi	r4,sp,40
   18808:	d80b883a 	mov	r5,sp
   1880c:	0018f180 	call	18f18 <__unpack_d>
   18810:	d8c00517 	ldw	r3,20(sp)
   18814:	00800044 	movi	r2,1
   18818:	10c00536 	bltu	r2,r3,18830 <__divdf3+0x50>
   1881c:	d9000504 	addi	r4,sp,20
   18820:	0018cf40 	call	18cf4 <__pack_d>
   18824:	dfc00e17 	ldw	ra,56(sp)
   18828:	dec00f04 	addi	sp,sp,60
   1882c:	f800283a 	ret
   18830:	d9000017 	ldw	r4,0(sp)
   18834:	11000536 	bltu	r2,r4,1884c <__divdf3+0x6c>
   18838:	d809883a 	mov	r4,sp
   1883c:	0018cf40 	call	18cf4 <__pack_d>
   18840:	dfc00e17 	ldw	ra,56(sp)
   18844:	dec00f04 	addi	sp,sp,60
   18848:	f800283a 	ret
   1884c:	d9800617 	ldw	r6,24(sp)
   18850:	d9400117 	ldw	r5,4(sp)
   18854:	00800104 	movi	r2,4
   18858:	314af03a 	xor	r5,r6,r5
   1885c:	d9400615 	stw	r5,24(sp)
   18860:	18800226 	beq	r3,r2,1886c <__divdf3+0x8c>
   18864:	01400084 	movi	r5,2
   18868:	1940041e 	bne	r3,r5,1887c <__divdf3+0x9c>
   1886c:	193feb1e 	bne	r3,r4,1881c <__divdf3+0x3c>
   18870:	010000f4 	movhi	r4,3
   18874:	21048904 	addi	r4,r4,4644
   18878:	003fe906 	br	18820 <__divdf3+0x40>
   1887c:	20803326 	beq	r4,r2,1894c <__divdf3+0x16c>
   18880:	21403726 	beq	r4,r5,18960 <__divdf3+0x180>
   18884:	d8800217 	ldw	r2,8(sp)
   18888:	d9000717 	ldw	r4,28(sp)
   1888c:	d8c00917 	ldw	r3,36(sp)
   18890:	da000417 	ldw	r8,16(sp)
   18894:	2089c83a 	sub	r4,r4,r2
   18898:	d9000715 	stw	r4,28(sp)
   1889c:	d8800817 	ldw	r2,32(sp)
   188a0:	dbc00317 	ldw	r15,12(sp)
   188a4:	1a000236 	bltu	r3,r8,188b0 <__divdf3+0xd0>
   188a8:	40c0081e 	bne	r8,r3,188cc <__divdf3+0xec>
   188ac:	13c0072e 	bgeu	r2,r15,188cc <__divdf3+0xec>
   188b0:	108b883a 	add	r5,r2,r2
   188b4:	288d803a 	cmpltu	r6,r5,r2
   188b8:	18c7883a 	add	r3,r3,r3
   188bc:	213fffc4 	addi	r4,r4,-1
   188c0:	2805883a 	mov	r2,r5
   188c4:	30c7883a 	add	r3,r6,r3
   188c8:	d9000715 	stw	r4,28(sp)
   188cc:	01400f44 	movi	r5,61
   188d0:	000f883a 	mov	r7,zero
   188d4:	01040034 	movhi	r4,4096
   188d8:	0019883a 	mov	r12,zero
   188dc:	001b883a 	mov	r13,zero
   188e0:	201697fa 	slli	r11,r4,31
   188e4:	3814d07a 	srli	r10,r7,1
   188e8:	297fffc4 	addi	r5,r5,-1
   188ec:	1a000936 	bltu	r3,r8,18914 <__divdf3+0x134>
   188f0:	13cdc83a 	sub	r6,r2,r15
   188f4:	1193803a 	cmpltu	r9,r2,r6
   188f8:	1a1dc83a 	sub	r14,r3,r8
   188fc:	40c0011e 	bne	r8,r3,18904 <__divdf3+0x124>
   18900:	13c00436 	bltu	r2,r15,18914 <__divdf3+0x134>
   18904:	3005883a 	mov	r2,r6
   18908:	7247c83a 	sub	r3,r14,r9
   1890c:	61d8b03a 	or	r12,r12,r7
   18910:	691ab03a 	or	r13,r13,r4
   18914:	108d883a 	add	r6,r2,r2
   18918:	3093803a 	cmpltu	r9,r6,r2
   1891c:	18c7883a 	add	r3,r3,r3
   18920:	5a8eb03a 	or	r7,r11,r10
   18924:	2008d07a 	srli	r4,r4,1
   18928:	3005883a 	mov	r2,r6
   1892c:	48c7883a 	add	r3,r9,r3
   18930:	283feb1e 	bne	r5,zero,188e0 <__divdf3+0x100>
   18934:	61003fcc 	andi	r4,r12,255
   18938:	01402004 	movi	r5,128
   1893c:	21400b26 	beq	r4,r5,1896c <__divdf3+0x18c>
   18940:	db000815 	stw	r12,32(sp)
   18944:	db400915 	stw	r13,36(sp)
   18948:	003fb406 	br	1881c <__divdf3+0x3c>
   1894c:	d8000815 	stw	zero,32(sp)
   18950:	d8000915 	stw	zero,36(sp)
   18954:	d8000715 	stw	zero,28(sp)
   18958:	d9000504 	addi	r4,sp,20
   1895c:	003fb006 	br	18820 <__divdf3+0x40>
   18960:	d8800515 	stw	r2,20(sp)
   18964:	d9000504 	addi	r4,sp,20
   18968:	003fad06 	br	18820 <__divdf3+0x40>
   1896c:	6140400c 	andi	r5,r12,256
   18970:	283ff31e 	bne	r5,zero,18940 <__divdf3+0x160>
   18974:	30c4b03a 	or	r2,r6,r3
   18978:	103ff126 	beq	r2,zero,18940 <__divdf3+0x160>
   1897c:	6109883a 	add	r4,r12,r4
   18980:	2305803a 	cmpltu	r2,r4,r12
   18984:	033fc004 	movi	r12,-256
   18988:	2318703a 	and	r12,r4,r12
   1898c:	135b883a 	add	r13,r2,r13
   18990:	003feb06 	br	18940 <__divdf3+0x160>

00018994 <__gedf2>:
   18994:	defff104 	addi	sp,sp,-60
   18998:	d9000c15 	stw	r4,48(sp)
   1899c:	d9400d15 	stw	r5,52(sp)
   189a0:	d9000c04 	addi	r4,sp,48
   189a4:	d9400504 	addi	r5,sp,20
   189a8:	dfc00e15 	stw	ra,56(sp)
   189ac:	d9800a15 	stw	r6,40(sp)
   189b0:	d9c00b15 	stw	r7,44(sp)
   189b4:	0018f180 	call	18f18 <__unpack_d>
   189b8:	d9000a04 	addi	r4,sp,40
   189bc:	d80b883a 	mov	r5,sp
   189c0:	0018f180 	call	18f18 <__unpack_d>
   189c4:	d8c00517 	ldw	r3,20(sp)
   189c8:	00800044 	movi	r2,1
   189cc:	10c0082e 	bgeu	r2,r3,189f0 <__gedf2+0x5c>
   189d0:	d8c00017 	ldw	r3,0(sp)
   189d4:	10c0062e 	bgeu	r2,r3,189f0 <__gedf2+0x5c>
   189d8:	d9000504 	addi	r4,sp,20
   189dc:	d80b883a 	mov	r5,sp
   189e0:	001901c0 	call	1901c <__fpcmp_parts_d>
   189e4:	dfc00e17 	ldw	ra,56(sp)
   189e8:	dec00f04 	addi	sp,sp,60
   189ec:	f800283a 	ret
   189f0:	00bfffc4 	movi	r2,-1
   189f4:	003ffb06 	br	189e4 <__gedf2+0x50>

000189f8 <__fixdfsi>:
   189f8:	defff804 	addi	sp,sp,-32
   189fc:	d9000515 	stw	r4,20(sp)
   18a00:	d9400615 	stw	r5,24(sp)
   18a04:	d9000504 	addi	r4,sp,20
   18a08:	d80b883a 	mov	r5,sp
   18a0c:	dfc00715 	stw	ra,28(sp)
   18a10:	0018f180 	call	18f18 <__unpack_d>
   18a14:	d8800017 	ldw	r2,0(sp)
   18a18:	00c00084 	movi	r3,2
   18a1c:	10c01c26 	beq	r2,r3,18a90 <__fixdfsi+0x98>
   18a20:	00c00044 	movi	r3,1
   18a24:	18801a2e 	bgeu	r3,r2,18a90 <__fixdfsi+0x98>
   18a28:	00c00104 	movi	r3,4
   18a2c:	10c01126 	beq	r2,r3,18a74 <__fixdfsi+0x7c>
   18a30:	d8800217 	ldw	r2,8(sp)
   18a34:	10001616 	blt	r2,zero,18a90 <__fixdfsi+0x98>
   18a38:	00c00784 	movi	r3,30
   18a3c:	18800d16 	blt	r3,r2,18a74 <__fixdfsi+0x7c>
   18a40:	00c00f04 	movi	r3,60
   18a44:	1885c83a 	sub	r2,r3,r2
   18a48:	10fff804 	addi	r3,r2,-32
   18a4c:	d9400317 	ldw	r5,12(sp)
   18a50:	d9000417 	ldw	r4,16(sp)
   18a54:	18001616 	blt	r3,zero,18ab0 <__fixdfsi+0xb8>
   18a58:	20c4d83a 	srl	r2,r4,r3
   18a5c:	d8c00117 	ldw	r3,4(sp)
   18a60:	18000126 	beq	r3,zero,18a68 <__fixdfsi+0x70>
   18a64:	0085c83a 	sub	r2,zero,r2
   18a68:	dfc00717 	ldw	ra,28(sp)
   18a6c:	dec00804 	addi	sp,sp,32
   18a70:	f800283a 	ret
   18a74:	d8800117 	ldw	r2,4(sp)
   18a78:	1000091e 	bne	r2,zero,18aa0 <__fixdfsi+0xa8>
   18a7c:	00a00034 	movhi	r2,32768
   18a80:	10bfffc4 	addi	r2,r2,-1
   18a84:	dfc00717 	ldw	ra,28(sp)
   18a88:	dec00804 	addi	sp,sp,32
   18a8c:	f800283a 	ret
   18a90:	0005883a 	mov	r2,zero
   18a94:	dfc00717 	ldw	ra,28(sp)
   18a98:	dec00804 	addi	sp,sp,32
   18a9c:	f800283a 	ret
   18aa0:	00a00034 	movhi	r2,32768
   18aa4:	dfc00717 	ldw	ra,28(sp)
   18aa8:	dec00804 	addi	sp,sp,32
   18aac:	f800283a 	ret
   18ab0:	2008907a 	slli	r4,r4,1
   18ab4:	018007c4 	movi	r6,31
   18ab8:	308dc83a 	sub	r6,r6,r2
   18abc:	2188983a 	sll	r4,r4,r6
   18ac0:	2884d83a 	srl	r2,r5,r2
   18ac4:	2084b03a 	or	r2,r4,r2
   18ac8:	003fe406 	br	18a5c <__fixdfsi+0x64>

00018acc <__floatunsidf>:
   18acc:	defff904 	addi	sp,sp,-28
   18ad0:	dc000515 	stw	r16,20(sp)
   18ad4:	dfc00615 	stw	ra,24(sp)
   18ad8:	d8000115 	stw	zero,4(sp)
   18adc:	2021883a 	mov	r16,r4
   18ae0:	20001726 	beq	r4,zero,18b40 <__floatunsidf+0x74>
   18ae4:	008000c4 	movi	r2,3
   18ae8:	d8800015 	stw	r2,0(sp)
   18aec:	00800f04 	movi	r2,60
   18af0:	d8800215 	stw	r2,8(sp)
   18af4:	0018c480 	call	18c48 <__clzsi2>
   18af8:	10c00744 	addi	r3,r2,29
   18afc:	18001816 	blt	r3,zero,18b60 <__floatunsidf+0x94>
   18b00:	18002d26 	beq	r3,zero,18bb8 <__floatunsidf+0xec>
   18b04:	113fff44 	addi	r4,r2,-3
   18b08:	20002e16 	blt	r4,zero,18bc4 <__floatunsidf+0xf8>
   18b0c:	8108983a 	sll	r4,r16,r4
   18b10:	0021883a 	mov	r16,zero
   18b14:	014007c4 	movi	r5,31
   18b18:	2885c83a 	sub	r2,r5,r2
   18b1c:	dc000315 	stw	r16,12(sp)
   18b20:	d9000415 	stw	r4,16(sp)
   18b24:	d8800215 	stw	r2,8(sp)
   18b28:	d809883a 	mov	r4,sp
   18b2c:	0018cf40 	call	18cf4 <__pack_d>
   18b30:	dfc00617 	ldw	ra,24(sp)
   18b34:	dc000517 	ldw	r16,20(sp)
   18b38:	dec00704 	addi	sp,sp,28
   18b3c:	f800283a 	ret
   18b40:	00800084 	movi	r2,2
   18b44:	d809883a 	mov	r4,sp
   18b48:	d8800015 	stw	r2,0(sp)
   18b4c:	0018cf40 	call	18cf4 <__pack_d>
   18b50:	dfc00617 	ldw	ra,24(sp)
   18b54:	dc000517 	ldw	r16,20(sp)
   18b58:	dec00704 	addi	sp,sp,28
   18b5c:	f800283a 	ret
   18b60:	00c7c83a 	sub	r3,zero,r3
   18b64:	193ff804 	addi	r4,r3,-32
   18b68:	20001c16 	blt	r4,zero,18bdc <__floatunsidf+0x110>
   18b6c:	000b883a 	mov	r5,zero
   18b70:	2009d7fa 	srai	r4,r4,31
   18b74:	80c6d83a 	srl	r3,r16,r3
   18b78:	297fffc4 	addi	r5,r5,-1
   18b7c:	2c20703a 	and	r16,r5,r16
   18b80:	8020c03a 	cmpne	r16,r16,zero
   18b84:	1906703a 	and	r3,r3,r4
   18b88:	010007c4 	movi	r4,31
   18b8c:	80c6b03a 	or	r3,r16,r3
   18b90:	2085c83a 	sub	r2,r4,r2
   18b94:	d809883a 	mov	r4,sp
   18b98:	d8c00315 	stw	r3,12(sp)
   18b9c:	d8000415 	stw	zero,16(sp)
   18ba0:	d8800215 	stw	r2,8(sp)
   18ba4:	0018cf40 	call	18cf4 <__pack_d>
   18ba8:	dfc00617 	ldw	ra,24(sp)
   18bac:	dc000517 	ldw	r16,20(sp)
   18bb0:	dec00704 	addi	sp,sp,28
   18bb4:	f800283a 	ret
   18bb8:	dc000315 	stw	r16,12(sp)
   18bbc:	d8000415 	stw	zero,16(sp)
   18bc0:	003fd906 	br	18b28 <__floatunsidf+0x5c>
   18bc4:	800ad07a 	srli	r5,r16,1
   18bc8:	010007c4 	movi	r4,31
   18bcc:	20c9c83a 	sub	r4,r4,r3
   18bd0:	2908d83a 	srl	r4,r5,r4
   18bd4:	80e0983a 	sll	r16,r16,r3
   18bd8:	003fce06 	br	18b14 <__floatunsidf+0x48>
   18bdc:	01400044 	movi	r5,1
   18be0:	28ca983a 	sll	r5,r5,r3
   18be4:	003fe206 	br	18b70 <__floatunsidf+0xa4>

00018be8 <__muldi3>:
   18be8:	20bfffcc 	andi	r2,r4,65535
   18bec:	2010d43a 	srli	r8,r4,16
   18bf0:	30ffffcc 	andi	r3,r6,65535
   18bf4:	3014d43a 	srli	r10,r6,16
   18bf8:	1893383a 	mul	r9,r3,r2
   18bfc:	1a07383a 	mul	r3,r3,r8
   18c00:	5085383a 	mul	r2,r10,r2
   18c04:	4816d43a 	srli	r11,r9,16
   18c08:	5211383a 	mul	r8,r10,r8
   18c0c:	1885883a 	add	r2,r3,r2
   18c10:	12c5883a 	add	r2,r2,r11
   18c14:	10c0022e 	bgeu	r2,r3,18c20 <__muldi3+0x38>
   18c18:	00c00074 	movhi	r3,1
   18c1c:	40d1883a 	add	r8,r8,r3
   18c20:	1014d43a 	srli	r10,r2,16
   18c24:	21c9383a 	mul	r4,r4,r7
   18c28:	314d383a 	mul	r6,r6,r5
   18c2c:	1004943a 	slli	r2,r2,16
   18c30:	4291883a 	add	r8,r8,r10
   18c34:	4a7fffcc 	andi	r9,r9,65535
   18c38:	2187883a 	add	r3,r4,r6
   18c3c:	1245883a 	add	r2,r2,r9
   18c40:	1a07883a 	add	r3,r3,r8
   18c44:	f800283a 	ret

00018c48 <__clzsi2>:
   18c48:	00bfffd4 	movui	r2,65535
   18c4c:	11000b36 	bltu	r2,r4,18c7c <__clzsi2+0x34>
   18c50:	00803fc4 	movi	r2,255
   18c54:	11001e2e 	bgeu	r2,r4,18cd0 <__clzsi2+0x88>
   18c58:	00c00204 	movi	r3,8
   18c5c:	20c8d83a 	srl	r4,r4,r3
   18c60:	00c000f4 	movhi	r3,3
   18c64:	18c48e04 	addi	r3,r3,4664
   18c68:	00800604 	movi	r2,24
   18c6c:	1909883a 	add	r4,r3,r4
   18c70:	20c00003 	ldbu	r3,0(r4)
   18c74:	10c5c83a 	sub	r2,r2,r3
   18c78:	f800283a 	ret
   18c7c:	00804034 	movhi	r2,256
   18c80:	10bfffc4 	addi	r2,r2,-1
   18c84:	11000936 	bltu	r2,r4,18cac <__clzsi2+0x64>
   18c88:	00800404 	movi	r2,16
   18c8c:	1007883a 	mov	r3,r2
   18c90:	20c8d83a 	srl	r4,r4,r3
   18c94:	00c000f4 	movhi	r3,3
   18c98:	18c48e04 	addi	r3,r3,4664
   18c9c:	1909883a 	add	r4,r3,r4
   18ca0:	20c00003 	ldbu	r3,0(r4)
   18ca4:	10c5c83a 	sub	r2,r2,r3
   18ca8:	f800283a 	ret
   18cac:	00c00604 	movi	r3,24
   18cb0:	20c8d83a 	srl	r4,r4,r3
   18cb4:	00c000f4 	movhi	r3,3
   18cb8:	18c48e04 	addi	r3,r3,4664
   18cbc:	00800204 	movi	r2,8
   18cc0:	1909883a 	add	r4,r3,r4
   18cc4:	20c00003 	ldbu	r3,0(r4)
   18cc8:	10c5c83a 	sub	r2,r2,r3
   18ccc:	f800283a 	ret
   18cd0:	0007883a 	mov	r3,zero
   18cd4:	20c8d83a 	srl	r4,r4,r3
   18cd8:	00c000f4 	movhi	r3,3
   18cdc:	18c48e04 	addi	r3,r3,4664
   18ce0:	00800804 	movi	r2,32
   18ce4:	1909883a 	add	r4,r3,r4
   18ce8:	20c00003 	ldbu	r3,0(r4)
   18cec:	10c5c83a 	sub	r2,r2,r3
   18cf0:	f800283a 	ret

00018cf4 <__pack_d>:
   18cf4:	20800017 	ldw	r2,0(r4)
   18cf8:	defff804 	addi	sp,sp,-32
   18cfc:	dcc00315 	stw	r19,12(sp)
   18d00:	dc800215 	stw	r18,8(sp)
   18d04:	dfc00715 	stw	ra,28(sp)
   18d08:	dd800615 	stw	r22,24(sp)
   18d0c:	dd400515 	stw	r21,20(sp)
   18d10:	dd000415 	stw	r20,16(sp)
   18d14:	dc400115 	stw	r17,4(sp)
   18d18:	dc000015 	stw	r16,0(sp)
   18d1c:	04800044 	movi	r18,1
   18d20:	24400317 	ldw	r17,12(r4)
   18d24:	24000417 	ldw	r16,16(r4)
   18d28:	24c00117 	ldw	r19,4(r4)
   18d2c:	9080422e 	bgeu	r18,r2,18e38 <__pack_d+0x144>
   18d30:	00c00104 	movi	r3,4
   18d34:	10c03c26 	beq	r2,r3,18e28 <__pack_d+0x134>
   18d38:	00c00084 	movi	r3,2
   18d3c:	10c01926 	beq	r2,r3,18da4 <__pack_d+0xb0>
   18d40:	8c04b03a 	or	r2,r17,r16
   18d44:	10001726 	beq	r2,zero,18da4 <__pack_d+0xb0>
   18d48:	21000217 	ldw	r4,8(r4)
   18d4c:	00bf0084 	movi	r2,-1022
   18d50:	20804016 	blt	r4,r2,18e54 <__pack_d+0x160>
   18d54:	0080ffc4 	movi	r2,1023
   18d58:	11003316 	blt	r2,r4,18e28 <__pack_d+0x134>
   18d5c:	88803fcc 	andi	r2,r17,255
   18d60:	00c02004 	movi	r3,128
   18d64:	10c02926 	beq	r2,r3,18e0c <__pack_d+0x118>
   18d68:	88801fc4 	addi	r2,r17,127
   18d6c:	1463803a 	cmpltu	r17,r2,r17
   18d70:	8c21883a 	add	r16,r17,r16
   18d74:	1023883a 	mov	r17,r2
   18d78:	00880034 	movhi	r2,8192
   18d7c:	10bfffc4 	addi	r2,r2,-1
   18d80:	14001c36 	bltu	r2,r16,18df4 <__pack_d+0x100>
   18d84:	2100ffc4 	addi	r4,r4,1023
   18d88:	8006963a 	slli	r3,r16,24
   18d8c:	8804d23a 	srli	r2,r17,8
   18d90:	8020913a 	slli	r16,r16,4
   18d94:	2101ffcc 	andi	r4,r4,2047
   18d98:	1884b03a 	or	r2,r3,r2
   18d9c:	8020d33a 	srli	r16,r16,12
   18da0:	00000306 	br	18db0 <__pack_d+0xbc>
   18da4:	0009883a 	mov	r4,zero
   18da8:	0005883a 	mov	r2,zero
   18dac:	0021883a 	mov	r16,zero
   18db0:	2008953a 	slli	r4,r4,20
   18db4:	982697fa 	slli	r19,r19,31
   18db8:	00c00434 	movhi	r3,16
   18dbc:	18ffffc4 	addi	r3,r3,-1
   18dc0:	80e0703a 	and	r16,r16,r3
   18dc4:	8106b03a 	or	r3,r16,r4
   18dc8:	1cc6b03a 	or	r3,r3,r19
   18dcc:	dfc00717 	ldw	ra,28(sp)
   18dd0:	dd800617 	ldw	r22,24(sp)
   18dd4:	dd400517 	ldw	r21,20(sp)
   18dd8:	dd000417 	ldw	r20,16(sp)
   18ddc:	dcc00317 	ldw	r19,12(sp)
   18de0:	dc800217 	ldw	r18,8(sp)
   18de4:	dc400117 	ldw	r17,4(sp)
   18de8:	dc000017 	ldw	r16,0(sp)
   18dec:	dec00804 	addi	sp,sp,32
   18df0:	f800283a 	ret
   18df4:	800697fa 	slli	r3,r16,31
   18df8:	8804d07a 	srli	r2,r17,1
   18dfc:	21010004 	addi	r4,r4,1024
   18e00:	8020d07a 	srli	r16,r16,1
   18e04:	18a2b03a 	or	r17,r3,r2
   18e08:	003fdf06 	br	18d88 <__pack_d+0x94>
   18e0c:	88c0400c 	andi	r3,r17,256
   18e10:	183fd926 	beq	r3,zero,18d78 <__pack_d+0x84>
   18e14:	8885883a 	add	r2,r17,r2
   18e18:	1463803a 	cmpltu	r17,r2,r17
   18e1c:	8c21883a 	add	r16,r17,r16
   18e20:	1023883a 	mov	r17,r2
   18e24:	003fd406 	br	18d78 <__pack_d+0x84>
   18e28:	0101ffc4 	movi	r4,2047
   18e2c:	0005883a 	mov	r2,zero
   18e30:	0021883a 	mov	r16,zero
   18e34:	003fde06 	br	18db0 <__pack_d+0xbc>
   18e38:	84000234 	orhi	r16,r16,8
   18e3c:	00c00434 	movhi	r3,16
   18e40:	18ffffc4 	addi	r3,r3,-1
   18e44:	8805883a 	mov	r2,r17
   18e48:	80e0703a 	and	r16,r16,r3
   18e4c:	0101ffc4 	movi	r4,2047
   18e50:	003fd706 	br	18db0 <__pack_d+0xbc>
   18e54:	1129c83a 	sub	r20,r2,r4
   18e58:	00800e04 	movi	r2,56
   18e5c:	15002716 	blt	r2,r20,18efc <__pack_d+0x208>
   18e60:	800b883a 	mov	r5,r16
   18e64:	a00d883a 	mov	r6,r20
   18e68:	8809883a 	mov	r4,r17
   18e6c:	00190ec0 	call	190ec <__lshrdi3>
   18e70:	9009883a 	mov	r4,r18
   18e74:	000b883a 	mov	r5,zero
   18e78:	a00d883a 	mov	r6,r20
   18e7c:	102d883a 	mov	r22,r2
   18e80:	182b883a 	mov	r21,r3
   18e84:	00191300 	call	19130 <__ashldi3>
   18e88:	1009003a 	cmpeq	r4,r2,zero
   18e8c:	1907c83a 	sub	r3,r3,r4
   18e90:	10bfffc4 	addi	r2,r2,-1
   18e94:	1c20703a 	and	r16,r3,r16
   18e98:	1444703a 	and	r2,r2,r17
   18e9c:	1404b03a 	or	r2,r2,r16
   18ea0:	1004c03a 	cmpne	r2,r2,zero
   18ea4:	1584b03a 	or	r2,r2,r22
   18ea8:	11003fcc 	andi	r4,r2,255
   18eac:	01402004 	movi	r5,128
   18eb0:	a807883a 	mov	r3,r21
   18eb4:	2140131e 	bne	r4,r5,18f04 <__pack_d+0x210>
   18eb8:	1140400c 	andi	r5,r2,256
   18ebc:	28000426 	beq	r5,zero,18ed0 <__pack_d+0x1dc>
   18ec0:	1109883a 	add	r4,r2,r4
   18ec4:	2085803a 	cmpltu	r2,r4,r2
   18ec8:	1547883a 	add	r3,r2,r21
   18ecc:	2005883a 	mov	r2,r4
   18ed0:	1808963a 	slli	r4,r3,24
   18ed4:	1004d23a 	srli	r2,r2,8
   18ed8:	1820913a 	slli	r16,r3,4
   18edc:	01440034 	movhi	r5,4096
   18ee0:	297fffc4 	addi	r5,r5,-1
   18ee4:	2084b03a 	or	r2,r4,r2
   18ee8:	8020d33a 	srli	r16,r16,12
   18eec:	01000044 	movi	r4,1
   18ef0:	28ffaf36 	bltu	r5,r3,18db0 <__pack_d+0xbc>
   18ef4:	0009883a 	mov	r4,zero
   18ef8:	003fad06 	br	18db0 <__pack_d+0xbc>
   18efc:	0005883a 	mov	r2,zero
   18f00:	0007883a 	mov	r3,zero
   18f04:	11001fc4 	addi	r4,r2,127
   18f08:	2085803a 	cmpltu	r2,r4,r2
   18f0c:	10c7883a 	add	r3,r2,r3
   18f10:	2005883a 	mov	r2,r4
   18f14:	003fee06 	br	18ed0 <__pack_d+0x1dc>

00018f18 <__unpack_d>:
   18f18:	21800117 	ldw	r6,4(r4)
   18f1c:	20c00017 	ldw	r3,0(r4)
   18f20:	3004d7fa 	srli	r2,r6,31
   18f24:	3008d53a 	srli	r4,r6,20
   18f28:	28800115 	stw	r2,4(r5)
   18f2c:	2101ffcc 	andi	r4,r4,2047
   18f30:	00800434 	movhi	r2,16
   18f34:	10bfffc4 	addi	r2,r2,-1
   18f38:	3084703a 	and	r2,r6,r2
   18f3c:	20001a1e 	bne	r4,zero,18fa8 <__unpack_d+0x90>
   18f40:	1888b03a 	or	r4,r3,r2
   18f44:	20002626 	beq	r4,zero,18fe0 <__unpack_d+0xc8>
   18f48:	1808d63a 	srli	r4,r3,24
   18f4c:	1004923a 	slli	r2,r2,8
   18f50:	01bf0084 	movi	r6,-1022
   18f54:	29800215 	stw	r6,8(r5)
   18f58:	2084b03a 	or	r2,r4,r2
   18f5c:	010000c4 	movi	r4,3
   18f60:	29000015 	stw	r4,0(r5)
   18f64:	02040034 	movhi	r8,4096
   18f68:	423fffc4 	addi	r8,r8,-1
   18f6c:	1806923a 	slli	r3,r3,8
   18f70:	40801836 	bltu	r8,r2,18fd4 <__unpack_d+0xbc>
   18f74:	013f0044 	movi	r4,-1023
   18f78:	18cd883a 	add	r6,r3,r3
   18f7c:	30c7803a 	cmpltu	r3,r6,r3
   18f80:	1085883a 	add	r2,r2,r2
   18f84:	1885883a 	add	r2,r3,r2
   18f88:	200f883a 	mov	r7,r4
   18f8c:	3007883a 	mov	r3,r6
   18f90:	213fffc4 	addi	r4,r4,-1
   18f94:	40bff82e 	bgeu	r8,r2,18f78 <__unpack_d+0x60>
   18f98:	29c00215 	stw	r7,8(r5)
   18f9c:	28c00315 	stw	r3,12(r5)
   18fa0:	28800415 	stw	r2,16(r5)
   18fa4:	f800283a 	ret
   18fa8:	01c1ffc4 	movi	r7,2047
   18fac:	21c00f26 	beq	r4,r7,18fec <__unpack_d+0xd4>
   18fb0:	180cd63a 	srli	r6,r3,24
   18fb4:	1004923a 	slli	r2,r2,8
   18fb8:	213f0044 	addi	r4,r4,-1023
   18fbc:	1806923a 	slli	r3,r3,8
   18fc0:	3084b03a 	or	r2,r6,r2
   18fc4:	29000215 	stw	r4,8(r5)
   18fc8:	010000c4 	movi	r4,3
   18fcc:	10840034 	orhi	r2,r2,4096
   18fd0:	29000015 	stw	r4,0(r5)
   18fd4:	28c00315 	stw	r3,12(r5)
   18fd8:	28800415 	stw	r2,16(r5)
   18fdc:	f800283a 	ret
   18fe0:	00800084 	movi	r2,2
   18fe4:	28800015 	stw	r2,0(r5)
   18fe8:	f800283a 	ret
   18fec:	1888b03a 	or	r4,r3,r2
   18ff0:	20000526 	beq	r4,zero,19008 <__unpack_d+0xf0>
   18ff4:	3180022c 	andhi	r6,r6,8
   18ff8:	30000626 	beq	r6,zero,19014 <__unpack_d+0xfc>
   18ffc:	01000044 	movi	r4,1
   19000:	29000015 	stw	r4,0(r5)
   19004:	003ff306 	br	18fd4 <__unpack_d+0xbc>
   19008:	00800104 	movi	r2,4
   1900c:	28800015 	stw	r2,0(r5)
   19010:	f800283a 	ret
   19014:	28000015 	stw	zero,0(r5)
   19018:	003fee06 	br	18fd4 <__unpack_d+0xbc>

0001901c <__fpcmp_parts_d>:
   1901c:	20c00017 	ldw	r3,0(r4)
   19020:	00800044 	movi	r2,1
   19024:	10c0142e 	bgeu	r2,r3,19078 <__fpcmp_parts_d+0x5c>
   19028:	29800017 	ldw	r6,0(r5)
   1902c:	1180122e 	bgeu	r2,r6,19078 <__fpcmp_parts_d+0x5c>
   19030:	01c00104 	movi	r7,4
   19034:	19c02826 	beq	r3,r7,190d8 <__fpcmp_parts_d+0xbc>
   19038:	31c00926 	beq	r6,r7,19060 <__fpcmp_parts_d+0x44>
   1903c:	01c00084 	movi	r7,2
   19040:	19c00626 	beq	r3,r7,1905c <__fpcmp_parts_d+0x40>
   19044:	31c00a26 	beq	r6,r7,19070 <__fpcmp_parts_d+0x54>
   19048:	20c00117 	ldw	r3,4(r4)
   1904c:	29800117 	ldw	r6,4(r5)
   19050:	19800b26 	beq	r3,r6,19080 <__fpcmp_parts_d+0x64>
   19054:	1800041e 	bne	r3,zero,19068 <__fpcmp_parts_d+0x4c>
   19058:	f800283a 	ret
   1905c:	30c01a26 	beq	r6,r3,190c8 <__fpcmp_parts_d+0xac>
   19060:	28800117 	ldw	r2,4(r5)
   19064:	1000041e 	bne	r2,zero,19078 <__fpcmp_parts_d+0x5c>
   19068:	00bfffc4 	movi	r2,-1
   1906c:	f800283a 	ret
   19070:	20800117 	ldw	r2,4(r4)
   19074:	103ffc1e 	bne	r2,zero,19068 <__fpcmp_parts_d+0x4c>
   19078:	00800044 	movi	r2,1
   1907c:	f800283a 	ret
   19080:	21c00217 	ldw	r7,8(r4)
   19084:	29800217 	ldw	r6,8(r5)
   19088:	31c0020e 	bge	r6,r7,19094 <__fpcmp_parts_d+0x78>
   1908c:	183ff61e 	bne	r3,zero,19068 <__fpcmp_parts_d+0x4c>
   19090:	f800283a 	ret
   19094:	39800a16 	blt	r7,r6,190c0 <__fpcmp_parts_d+0xa4>
   19098:	20800417 	ldw	r2,16(r4)
   1909c:	29800417 	ldw	r6,16(r5)
   190a0:	21c00317 	ldw	r7,12(r4)
   190a4:	29000317 	ldw	r4,12(r5)
   190a8:	30800936 	bltu	r6,r2,190d0 <__fpcmp_parts_d+0xb4>
   190ac:	1180011e 	bne	r2,r6,190b4 <__fpcmp_parts_d+0x98>
   190b0:	21c00736 	bltu	r4,r7,190d0 <__fpcmp_parts_d+0xb4>
   190b4:	11800236 	bltu	r2,r6,190c0 <__fpcmp_parts_d+0xa4>
   190b8:	3080031e 	bne	r6,r2,190c8 <__fpcmp_parts_d+0xac>
   190bc:	3900022e 	bgeu	r7,r4,190c8 <__fpcmp_parts_d+0xac>
   190c0:	183fe926 	beq	r3,zero,19068 <__fpcmp_parts_d+0x4c>
   190c4:	003fec06 	br	19078 <__fpcmp_parts_d+0x5c>
   190c8:	0005883a 	mov	r2,zero
   190cc:	f800283a 	ret
   190d0:	183fe926 	beq	r3,zero,19078 <__fpcmp_parts_d+0x5c>
   190d4:	003fe406 	br	19068 <__fpcmp_parts_d+0x4c>
   190d8:	30ffe51e 	bne	r6,r3,19070 <__fpcmp_parts_d+0x54>
   190dc:	28c00117 	ldw	r3,4(r5)
   190e0:	20800117 	ldw	r2,4(r4)
   190e4:	1885c83a 	sub	r2,r3,r2
   190e8:	f800283a 	ret

000190ec <__lshrdi3>:
   190ec:	2005883a 	mov	r2,r4
   190f0:	2807883a 	mov	r3,r5
   190f4:	30000826 	beq	r6,zero,19118 <__lshrdi3+0x2c>
   190f8:	01000804 	movi	r4,32
   190fc:	2189c83a 	sub	r4,r4,r6
   19100:	0100060e 	bge	zero,r4,1911c <__lshrdi3+0x30>
   19104:	1184d83a 	srl	r2,r2,r6
   19108:	2908983a 	sll	r4,r5,r4
   1910c:	298cd83a 	srl	r6,r5,r6
   19110:	2084b03a 	or	r2,r4,r2
   19114:	3007883a 	mov	r3,r6
   19118:	f800283a 	ret
   1911c:	0105c83a 	sub	r2,zero,r4
   19120:	000d883a 	mov	r6,zero
   19124:	2884d83a 	srl	r2,r5,r2
   19128:	3007883a 	mov	r3,r6
   1912c:	003ffa06 	br	19118 <__lshrdi3+0x2c>

00019130 <__ashldi3>:
   19130:	2005883a 	mov	r2,r4
   19134:	2807883a 	mov	r3,r5
   19138:	30000826 	beq	r6,zero,1915c <__ashldi3+0x2c>
   1913c:	01000804 	movi	r4,32
   19140:	2189c83a 	sub	r4,r4,r6
   19144:	0100060e 	bge	zero,r4,19160 <__ashldi3+0x30>
   19148:	1108d83a 	srl	r4,r2,r4
   1914c:	2986983a 	sll	r3,r5,r6
   19150:	118c983a 	sll	r6,r2,r6
   19154:	20c6b03a 	or	r3,r4,r3
   19158:	3005883a 	mov	r2,r6
   1915c:	f800283a 	ret
   19160:	0107c83a 	sub	r3,zero,r4
   19164:	000d883a 	mov	r6,zero
   19168:	10c6983a 	sll	r3,r2,r3
   1916c:	3005883a 	mov	r2,r6
   19170:	003ffa06 	br	1915c <__ashldi3+0x2c>

00019174 <memcmp>:
   19174:	01c000c4 	movi	r7,3
   19178:	3980192e 	bgeu	r7,r6,191e0 <memcmp+0x6c>
   1917c:	2904b03a 	or	r2,r5,r4
   19180:	11c4703a 	and	r2,r2,r7
   19184:	10000f26 	beq	r2,zero,191c4 <memcmp+0x50>
   19188:	20c00003 	ldbu	r3,0(r4)
   1918c:	28800003 	ldbu	r2,0(r5)
   19190:	1880151e 	bne	r3,r2,191e8 <memcmp+0x74>
   19194:	31bfff84 	addi	r6,r6,-2
   19198:	01ffffc4 	movi	r7,-1
   1919c:	00000406 	br	191b0 <memcmp+0x3c>
   191a0:	20c00003 	ldbu	r3,0(r4)
   191a4:	28800003 	ldbu	r2,0(r5)
   191a8:	31bfffc4 	addi	r6,r6,-1
   191ac:	18800e1e 	bne	r3,r2,191e8 <memcmp+0x74>
   191b0:	21000044 	addi	r4,r4,1
   191b4:	29400044 	addi	r5,r5,1
   191b8:	31fff91e 	bne	r6,r7,191a0 <memcmp+0x2c>
   191bc:	0005883a 	mov	r2,zero
   191c0:	f800283a 	ret
   191c4:	20c00017 	ldw	r3,0(r4)
   191c8:	28800017 	ldw	r2,0(r5)
   191cc:	1880041e 	bne	r3,r2,191e0 <memcmp+0x6c>
   191d0:	31bfff04 	addi	r6,r6,-4
   191d4:	21000104 	addi	r4,r4,4
   191d8:	29400104 	addi	r5,r5,4
   191dc:	39bff936 	bltu	r7,r6,191c4 <memcmp+0x50>
   191e0:	303fe91e 	bne	r6,zero,19188 <memcmp+0x14>
   191e4:	003ff506 	br	191bc <memcmp+0x48>
   191e8:	1885c83a 	sub	r2,r3,r2
   191ec:	f800283a 	ret

000191f0 <memcpy>:
   191f0:	00c003c4 	movi	r3,15
   191f4:	2005883a 	mov	r2,r4
   191f8:	3009883a 	mov	r4,r6
   191fc:	1980032e 	bgeu	r3,r6,1920c <memcpy+0x1c>
   19200:	2886b03a 	or	r3,r5,r2
   19204:	18c000cc 	andi	r3,r3,3
   19208:	18000926 	beq	r3,zero,19230 <memcpy+0x40>
   1920c:	1007883a 	mov	r3,r2
   19210:	290f883a 	add	r7,r5,r4
   19214:	20000526 	beq	r4,zero,1922c <memcpy+0x3c>
   19218:	29800003 	ldbu	r6,0(r5)
   1921c:	18c00044 	addi	r3,r3,1
   19220:	29400044 	addi	r5,r5,1
   19224:	19bfffc5 	stb	r6,-1(r3)
   19228:	29fffb1e 	bne	r5,r7,19218 <memcpy+0x28>
   1922c:	f800283a 	ret
   19230:	327ffc04 	addi	r9,r6,-16
   19234:	4812d13a 	srli	r9,r9,4
   19238:	11000404 	addi	r4,r2,16
   1923c:	1007883a 	mov	r3,r2
   19240:	4810913a 	slli	r8,r9,4
   19244:	280f883a 	mov	r7,r5
   19248:	2209883a 	add	r4,r4,r8
   1924c:	3a000017 	ldw	r8,0(r7)
   19250:	18c00404 	addi	r3,r3,16
   19254:	39c00404 	addi	r7,r7,16
   19258:	1a3ffc15 	stw	r8,-16(r3)
   1925c:	3a3ffd17 	ldw	r8,-12(r7)
   19260:	1a3ffd15 	stw	r8,-12(r3)
   19264:	3a3ffe17 	ldw	r8,-8(r7)
   19268:	1a3ffe15 	stw	r8,-8(r3)
   1926c:	3a3fff17 	ldw	r8,-4(r7)
   19270:	1a3fff15 	stw	r8,-4(r3)
   19274:	193ff51e 	bne	r3,r4,1924c <memcpy+0x5c>
   19278:	49c00044 	addi	r7,r9,1
   1927c:	380e913a 	slli	r7,r7,4
   19280:	310003cc 	andi	r4,r6,15
   19284:	018000c4 	movi	r6,3
   19288:	11c7883a 	add	r3,r2,r7
   1928c:	29cb883a 	add	r5,r5,r7
   19290:	313fdf2e 	bgeu	r6,r4,19210 <memcpy+0x20>
   19294:	213fff04 	addi	r4,r4,-4
   19298:	2014d0ba 	srli	r10,r4,2
   1929c:	1a400104 	addi	r9,r3,4
   192a0:	180d883a 	mov	r6,r3
   192a4:	528f883a 	add	r7,r10,r10
   192a8:	39cf883a 	add	r7,r7,r7
   192ac:	49d3883a 	add	r9,r9,r7
   192b0:	280f883a 	mov	r7,r5
   192b4:	3a000017 	ldw	r8,0(r7)
   192b8:	31800104 	addi	r6,r6,4
   192bc:	39c00104 	addi	r7,r7,4
   192c0:	323fff15 	stw	r8,-4(r6)
   192c4:	327ffb1e 	bne	r6,r9,192b4 <memcpy+0xc4>
   192c8:	51800044 	addi	r6,r10,1
   192cc:	52bfff24 	muli	r10,r10,-4
   192d0:	318d883a 	add	r6,r6,r6
   192d4:	318d883a 	add	r6,r6,r6
   192d8:	5109883a 	add	r4,r10,r4
   192dc:	298b883a 	add	r5,r5,r6
   192e0:	1987883a 	add	r3,r3,r6
   192e4:	003fca06 	br	19210 <memcpy+0x20>

000192e8 <memset>:
   192e8:	00c000c4 	movi	r3,3
   192ec:	2005883a 	mov	r2,r4
   192f0:	29403fcc 	andi	r5,r5,255
   192f4:	19802d2e 	bgeu	r3,r6,193ac <memset+0xc4>
   192f8:	20c6703a 	and	r3,r4,r3
   192fc:	18002e1e 	bne	r3,zero,193b8 <memset+0xd0>
   19300:	2806923a 	slli	r3,r5,8
   19304:	010003c4 	movi	r4,15
   19308:	3011883a 	mov	r8,r6
   1930c:	1946b03a 	or	r3,r3,r5
   19310:	180e943a 	slli	r7,r3,16
   19314:	38ceb03a 	or	r7,r7,r3
   19318:	1007883a 	mov	r3,r2
   1931c:	21800f2e 	bgeu	r4,r6,1935c <memset+0x74>
   19320:	19c00015 	stw	r7,0(r3)
   19324:	19c00115 	stw	r7,4(r3)
   19328:	19c00215 	stw	r7,8(r3)
   1932c:	19c00315 	stw	r7,12(r3)
   19330:	423ffc04 	addi	r8,r8,-16
   19334:	18c00404 	addi	r3,r3,16
   19338:	223ff936 	bltu	r4,r8,19320 <memset+0x38>
   1933c:	30fffc04 	addi	r3,r6,-16
   19340:	1806d13a 	srli	r3,r3,4
   19344:	318003cc 	andi	r6,r6,15
   19348:	010000c4 	movi	r4,3
   1934c:	18c00044 	addi	r3,r3,1
   19350:	1806913a 	slli	r3,r3,4
   19354:	10c7883a 	add	r3,r2,r3
   19358:	21800e2e 	bgeu	r4,r6,19394 <memset+0xac>
   1935c:	1813883a 	mov	r9,r3
   19360:	3011883a 	mov	r8,r6
   19364:	010000c4 	movi	r4,3
   19368:	49c00015 	stw	r7,0(r9)
   1936c:	423fff04 	addi	r8,r8,-4
   19370:	4a400104 	addi	r9,r9,4
   19374:	223ffc36 	bltu	r4,r8,19368 <memset+0x80>
   19378:	313fff04 	addi	r4,r6,-4
   1937c:	2008d0ba 	srli	r4,r4,2
   19380:	318000cc 	andi	r6,r6,3
   19384:	21000044 	addi	r4,r4,1
   19388:	2109883a 	add	r4,r4,r4
   1938c:	2109883a 	add	r4,r4,r4
   19390:	1907883a 	add	r3,r3,r4
   19394:	30000a26 	beq	r6,zero,193c0 <memset+0xd8>
   19398:	198d883a 	add	r6,r3,r6
   1939c:	19400005 	stb	r5,0(r3)
   193a0:	18c00044 	addi	r3,r3,1
   193a4:	19bffd1e 	bne	r3,r6,1939c <memset+0xb4>
   193a8:	f800283a 	ret
   193ac:	2007883a 	mov	r3,r4
   193b0:	303ff91e 	bne	r6,zero,19398 <memset+0xb0>
   193b4:	00000206 	br	193c0 <memset+0xd8>
   193b8:	2007883a 	mov	r3,r4
   193bc:	003ff606 	br	19398 <memset+0xb0>
   193c0:	f800283a 	ret

000193c4 <_printf_r>:
   193c4:	defffd04 	addi	sp,sp,-12
   193c8:	dfc00015 	stw	ra,0(sp)
   193cc:	d9800115 	stw	r6,4(sp)
   193d0:	d9c00215 	stw	r7,8(sp)
   193d4:	280d883a 	mov	r6,r5
   193d8:	21400217 	ldw	r5,8(r4)
   193dc:	d9c00104 	addi	r7,sp,4
   193e0:	00198d00 	call	198d0 <___vfprintf_internal_r>
   193e4:	dfc00017 	ldw	ra,0(sp)
   193e8:	dec00304 	addi	sp,sp,12
   193ec:	f800283a 	ret

000193f0 <printf>:
   193f0:	defffc04 	addi	sp,sp,-16
   193f4:	dfc00015 	stw	ra,0(sp)
   193f8:	d9400115 	stw	r5,4(sp)
   193fc:	d9800215 	stw	r6,8(sp)
   19400:	d9c00315 	stw	r7,12(sp)
   19404:	008000f4 	movhi	r2,3
   19408:	10957f04 	addi	r2,r2,22012
   1940c:	10800017 	ldw	r2,0(r2)
   19410:	200b883a 	mov	r5,r4
   19414:	d9800104 	addi	r6,sp,4
   19418:	11000217 	ldw	r4,8(r2)
   1941c:	001b6c80 	call	1b6c8 <__vfprintf_internal>
   19420:	dfc00017 	ldw	ra,0(sp)
   19424:	dec00404 	addi	sp,sp,16
   19428:	f800283a 	ret

0001942c <_putc_r>:
   1942c:	defffc04 	addi	sp,sp,-16
   19430:	dc000215 	stw	r16,8(sp)
   19434:	dfc00315 	stw	ra,12(sp)
   19438:	2021883a 	mov	r16,r4
   1943c:	20000226 	beq	r4,zero,19448 <_putc_r+0x1c>
   19440:	20800e17 	ldw	r2,56(r4)
   19444:	10001d26 	beq	r2,zero,194bc <_putc_r+0x90>
   19448:	30800217 	ldw	r2,8(r6)
   1944c:	10bfffc4 	addi	r2,r2,-1
   19450:	30800215 	stw	r2,8(r6)
   19454:	10000a16 	blt	r2,zero,19480 <_putc_r+0x54>
   19458:	30800017 	ldw	r2,0(r6)
   1945c:	11400005 	stb	r5,0(r2)
   19460:	30800017 	ldw	r2,0(r6)
   19464:	10c00044 	addi	r3,r2,1
   19468:	10800003 	ldbu	r2,0(r2)
   1946c:	30c00015 	stw	r3,0(r6)
   19470:	dfc00317 	ldw	ra,12(sp)
   19474:	dc000217 	ldw	r16,8(sp)
   19478:	dec00404 	addi	sp,sp,16
   1947c:	f800283a 	ret
   19480:	30c00617 	ldw	r3,24(r6)
   19484:	10c01316 	blt	r2,r3,194d4 <_putc_r+0xa8>
   19488:	30800017 	ldw	r2,0(r6)
   1948c:	01000284 	movi	r4,10
   19490:	11400005 	stb	r5,0(r2)
   19494:	30c00017 	ldw	r3,0(r6)
   19498:	19400003 	ldbu	r5,0(r3)
   1949c:	29000d26 	beq	r5,r4,194d4 <_putc_r+0xa8>
   194a0:	18c00044 	addi	r3,r3,1
   194a4:	2805883a 	mov	r2,r5
   194a8:	30c00015 	stw	r3,0(r6)
   194ac:	dfc00317 	ldw	ra,12(sp)
   194b0:	dc000217 	ldw	r16,8(sp)
   194b4:	dec00404 	addi	sp,sp,16
   194b8:	f800283a 	ret
   194bc:	d9400015 	stw	r5,0(sp)
   194c0:	d9800115 	stw	r6,4(sp)
   194c4:	001d4840 	call	1d484 <__sinit>
   194c8:	d9800117 	ldw	r6,4(sp)
   194cc:	d9400017 	ldw	r5,0(sp)
   194d0:	003fdd06 	br	19448 <_putc_r+0x1c>
   194d4:	8009883a 	mov	r4,r16
   194d8:	dfc00317 	ldw	ra,12(sp)
   194dc:	dc000217 	ldw	r16,8(sp)
   194e0:	dec00404 	addi	sp,sp,16
   194e4:	001b6ec1 	jmpi	1b6ec <__swbuf_r>

000194e8 <putc>:
   194e8:	defffc04 	addi	sp,sp,-16
   194ec:	dc400115 	stw	r17,4(sp)
   194f0:	044000f4 	movhi	r17,3
   194f4:	8c557f04 	addi	r17,r17,22012
   194f8:	88800017 	ldw	r2,0(r17)
   194fc:	dc800215 	stw	r18,8(sp)
   19500:	dc000015 	stw	r16,0(sp)
   19504:	dfc00315 	stw	ra,12(sp)
   19508:	2025883a 	mov	r18,r4
   1950c:	2821883a 	mov	r16,r5
   19510:	10000226 	beq	r2,zero,1951c <putc+0x34>
   19514:	10c00e17 	ldw	r3,56(r2)
   19518:	18002126 	beq	r3,zero,195a0 <putc+0xb8>
   1951c:	80800217 	ldw	r2,8(r16)
   19520:	10bfffc4 	addi	r2,r2,-1
   19524:	80800215 	stw	r2,8(r16)
   19528:	10000c16 	blt	r2,zero,1955c <putc+0x74>
   1952c:	80800017 	ldw	r2,0(r16)
   19530:	14800005 	stb	r18,0(r2)
   19534:	80800017 	ldw	r2,0(r16)
   19538:	10c00044 	addi	r3,r2,1
   1953c:	10800003 	ldbu	r2,0(r2)
   19540:	80c00015 	stw	r3,0(r16)
   19544:	dfc00317 	ldw	ra,12(sp)
   19548:	dc800217 	ldw	r18,8(sp)
   1954c:	dc400117 	ldw	r17,4(sp)
   19550:	dc000017 	ldw	r16,0(sp)
   19554:	dec00404 	addi	sp,sp,16
   19558:	f800283a 	ret
   1955c:	80c00617 	ldw	r3,24(r16)
   19560:	10c01216 	blt	r2,r3,195ac <putc+0xc4>
   19564:	80800017 	ldw	r2,0(r16)
   19568:	01000284 	movi	r4,10
   1956c:	14800005 	stb	r18,0(r2)
   19570:	80c00017 	ldw	r3,0(r16)
   19574:	19400003 	ldbu	r5,0(r3)
   19578:	29001526 	beq	r5,r4,195d0 <putc+0xe8>
   1957c:	18c00044 	addi	r3,r3,1
   19580:	2805883a 	mov	r2,r5
   19584:	80c00015 	stw	r3,0(r16)
   19588:	dfc00317 	ldw	ra,12(sp)
   1958c:	dc800217 	ldw	r18,8(sp)
   19590:	dc400117 	ldw	r17,4(sp)
   19594:	dc000017 	ldw	r16,0(sp)
   19598:	dec00404 	addi	sp,sp,16
   1959c:	f800283a 	ret
   195a0:	1009883a 	mov	r4,r2
   195a4:	001d4840 	call	1d484 <__sinit>
   195a8:	003fdc06 	br	1951c <putc+0x34>
   195ac:	89000017 	ldw	r4,0(r17)
   195b0:	900b883a 	mov	r5,r18
   195b4:	800d883a 	mov	r6,r16
   195b8:	dfc00317 	ldw	ra,12(sp)
   195bc:	dc800217 	ldw	r18,8(sp)
   195c0:	dc400117 	ldw	r17,4(sp)
   195c4:	dc000017 	ldw	r16,0(sp)
   195c8:	dec00404 	addi	sp,sp,16
   195cc:	001b6ec1 	jmpi	1b6ec <__swbuf_r>
   195d0:	89000017 	ldw	r4,0(r17)
   195d4:	003ff706 	br	195b4 <putc+0xcc>

000195d8 <_puts_r>:
   195d8:	defff604 	addi	sp,sp,-40
   195dc:	dc400815 	stw	r17,32(sp)
   195e0:	2023883a 	mov	r17,r4
   195e4:	2809883a 	mov	r4,r5
   195e8:	dc000715 	stw	r16,28(sp)
   195ec:	dfc00915 	stw	ra,36(sp)
   195f0:	2821883a 	mov	r16,r5
   195f4:	00197140 	call	19714 <strlen>
   195f8:	10c00044 	addi	r3,r2,1
   195fc:	d8800115 	stw	r2,4(sp)
   19600:	89400217 	ldw	r5,8(r17)
   19604:	008000f4 	movhi	r2,3
   19608:	1084cf04 	addi	r2,r2,4924
   1960c:	d8800215 	stw	r2,8(sp)
   19610:	00800044 	movi	r2,1
   19614:	d8800315 	stw	r2,12(sp)
   19618:	8809883a 	mov	r4,r17
   1961c:	00800084 	movi	r2,2
   19620:	d9800404 	addi	r6,sp,16
   19624:	dc000015 	stw	r16,0(sp)
   19628:	d8c00615 	stw	r3,24(sp)
   1962c:	dec00415 	stw	sp,16(sp)
   19630:	d8800515 	stw	r2,20(sp)
   19634:	001dad80 	call	1dad8 <__sfvwrite_r>
   19638:	1000061e 	bne	r2,zero,19654 <_puts_r+0x7c>
   1963c:	00800284 	movi	r2,10
   19640:	dfc00917 	ldw	ra,36(sp)
   19644:	dc400817 	ldw	r17,32(sp)
   19648:	dc000717 	ldw	r16,28(sp)
   1964c:	dec00a04 	addi	sp,sp,40
   19650:	f800283a 	ret
   19654:	00bfffc4 	movi	r2,-1
   19658:	003ff906 	br	19640 <_puts_r+0x68>

0001965c <puts>:
   1965c:	008000f4 	movhi	r2,3
   19660:	10957f04 	addi	r2,r2,22012
   19664:	200b883a 	mov	r5,r4
   19668:	11000017 	ldw	r4,0(r2)
   1966c:	00195d81 	jmpi	195d8 <_puts_r>

00019670 <strcmp>:
   19670:	2904b03a 	or	r2,r5,r4
   19674:	108000cc 	andi	r2,r2,3
   19678:	1000171e 	bne	r2,zero,196d8 <strcmp+0x68>
   1967c:	20800017 	ldw	r2,0(r4)
   19680:	28c00017 	ldw	r3,0(r5)
   19684:	10c0141e 	bne	r2,r3,196d8 <strcmp+0x68>
   19688:	027fbff4 	movhi	r9,65279
   1968c:	4a7fbfc4 	addi	r9,r9,-257
   19690:	1247883a 	add	r3,r2,r9
   19694:	0084303a 	nor	r2,zero,r2
   19698:	1884703a 	and	r2,r3,r2
   1969c:	02202074 	movhi	r8,32897
   196a0:	42202004 	addi	r8,r8,-32640
   196a4:	1204703a 	and	r2,r2,r8
   196a8:	10000226 	beq	r2,zero,196b4 <strcmp+0x44>
   196ac:	00001706 	br	1970c <strcmp+0x9c>
   196b0:	3000161e 	bne	r6,zero,1970c <strcmp+0x9c>
   196b4:	21000104 	addi	r4,r4,4
   196b8:	20800017 	ldw	r2,0(r4)
   196bc:	29400104 	addi	r5,r5,4
   196c0:	28c00017 	ldw	r3,0(r5)
   196c4:	124f883a 	add	r7,r2,r9
   196c8:	008c303a 	nor	r6,zero,r2
   196cc:	398c703a 	and	r6,r7,r6
   196d0:	320c703a 	and	r6,r6,r8
   196d4:	10fff626 	beq	r2,r3,196b0 <strcmp+0x40>
   196d8:	20800007 	ldb	r2,0(r4)
   196dc:	1000051e 	bne	r2,zero,196f4 <strcmp+0x84>
   196e0:	00000606 	br	196fc <strcmp+0x8c>
   196e4:	21000044 	addi	r4,r4,1
   196e8:	20800007 	ldb	r2,0(r4)
   196ec:	29400044 	addi	r5,r5,1
   196f0:	10000226 	beq	r2,zero,196fc <strcmp+0x8c>
   196f4:	28c00007 	ldb	r3,0(r5)
   196f8:	10fffa26 	beq	r2,r3,196e4 <strcmp+0x74>
   196fc:	20c00003 	ldbu	r3,0(r4)
   19700:	28800003 	ldbu	r2,0(r5)
   19704:	1885c83a 	sub	r2,r3,r2
   19708:	f800283a 	ret
   1970c:	0005883a 	mov	r2,zero
   19710:	f800283a 	ret

00019714 <strlen>:
   19714:	208000cc 	andi	r2,r4,3
   19718:	10001f1e 	bne	r2,zero,19798 <strlen+0x84>
   1971c:	20800017 	ldw	r2,0(r4)
   19720:	01ffbff4 	movhi	r7,65279
   19724:	39ffbfc4 	addi	r7,r7,-257
   19728:	01a02074 	movhi	r6,32897
   1972c:	31a02004 	addi	r6,r6,-32640
   19730:	11c7883a 	add	r3,r2,r7
   19734:	0084303a 	nor	r2,zero,r2
   19738:	1886703a 	and	r3,r3,r2
   1973c:	1986703a 	and	r3,r3,r6
   19740:	2005883a 	mov	r2,r4
   19744:	1800101e 	bne	r3,zero,19788 <strlen+0x74>
   19748:	10800104 	addi	r2,r2,4
   1974c:	10c00017 	ldw	r3,0(r2)
   19750:	19cb883a 	add	r5,r3,r7
   19754:	00c6303a 	nor	r3,zero,r3
   19758:	28c6703a 	and	r3,r5,r3
   1975c:	1986703a 	and	r3,r3,r6
   19760:	1800091e 	bne	r3,zero,19788 <strlen+0x74>
   19764:	10800104 	addi	r2,r2,4
   19768:	10c00017 	ldw	r3,0(r2)
   1976c:	19cb883a 	add	r5,r3,r7
   19770:	00c6303a 	nor	r3,zero,r3
   19774:	28c6703a 	and	r3,r5,r3
   19778:	1986703a 	and	r3,r3,r6
   1977c:	183ff226 	beq	r3,zero,19748 <strlen+0x34>
   19780:	00000106 	br	19788 <strlen+0x74>
   19784:	10800044 	addi	r2,r2,1
   19788:	10c00007 	ldb	r3,0(r2)
   1978c:	183ffd1e 	bne	r3,zero,19784 <strlen+0x70>
   19790:	1105c83a 	sub	r2,r2,r4
   19794:	f800283a 	ret
   19798:	2005883a 	mov	r2,r4
   1979c:	003ffa06 	br	19788 <strlen+0x74>

000197a0 <strncmp>:
   197a0:	30001826 	beq	r6,zero,19804 <strncmp+0x64>
   197a4:	2904b03a 	or	r2,r5,r4
   197a8:	108000cc 	andi	r2,r2,3
   197ac:	10001726 	beq	r2,zero,1980c <strncmp+0x6c>
   197b0:	31bfffc4 	addi	r6,r6,-1
   197b4:	20800007 	ldb	r2,0(r4)
   197b8:	28c00007 	ldb	r3,0(r5)
   197bc:	10c0331e 	bne	r2,r3,1988c <strncmp+0xec>
   197c0:	30001026 	beq	r6,zero,19804 <strncmp+0x64>
   197c4:	10000f26 	beq	r2,zero,19804 <strncmp+0x64>
   197c8:	20800044 	addi	r2,r4,1
   197cc:	29400044 	addi	r5,r5,1
   197d0:	2189883a 	add	r4,r4,r6
   197d4:	00000406 	br	197e8 <strncmp+0x48>
   197d8:	11000a26 	beq	r2,r4,19804 <strncmp+0x64>
   197dc:	18000926 	beq	r3,zero,19804 <strncmp+0x64>
   197e0:	10800044 	addi	r2,r2,1
   197e4:	29400044 	addi	r5,r5,1
   197e8:	10c00007 	ldb	r3,0(r2)
   197ec:	29800007 	ldb	r6,0(r5)
   197f0:	19bff926 	beq	r3,r6,197d8 <strncmp+0x38>
   197f4:	10c00003 	ldbu	r3,0(r2)
   197f8:	28800003 	ldbu	r2,0(r5)
   197fc:	1885c83a 	sub	r2,r3,r2
   19800:	f800283a 	ret
   19804:	0005883a 	mov	r2,zero
   19808:	f800283a 	ret
   1980c:	024000c4 	movi	r9,3
   19810:	49bfe72e 	bgeu	r9,r6,197b0 <strncmp+0x10>
   19814:	20800017 	ldw	r2,0(r4)
   19818:	28c00017 	ldw	r3,0(r5)
   1981c:	10ffe41e 	bne	r2,r3,197b0 <strncmp+0x10>
   19820:	30ffff04 	addi	r3,r6,-4
   19824:	183ff726 	beq	r3,zero,19804 <strncmp+0x64>
   19828:	02ffbff4 	movhi	r11,65279
   1982c:	5affbfc4 	addi	r11,r11,-257
   19830:	12cd883a 	add	r6,r2,r11
   19834:	0084303a 	nor	r2,zero,r2
   19838:	3084703a 	and	r2,r6,r2
   1983c:	02a02074 	movhi	r10,32897
   19840:	52a02004 	addi	r10,r10,-32640
   19844:	1284703a 	and	r2,r2,r10
   19848:	10000b26 	beq	r2,zero,19878 <strncmp+0xd8>
   1984c:	003fed06 	br	19804 <strncmp+0x64>
   19850:	21800017 	ldw	r6,0(r4)
   19854:	28800017 	ldw	r2,0(r5)
   19858:	32d1883a 	add	r8,r6,r11
   1985c:	018e303a 	nor	r7,zero,r6
   19860:	41ce703a 	and	r7,r8,r7
   19864:	3a8e703a 	and	r7,r7,r10
   19868:	30800a1e 	bne	r6,r2,19894 <strncmp+0xf4>
   1986c:	18ffff04 	addi	r3,r3,-4
   19870:	183fe426 	beq	r3,zero,19804 <strncmp+0x64>
   19874:	383fe31e 	bne	r7,zero,19804 <strncmp+0x64>
   19878:	21000104 	addi	r4,r4,4
   1987c:	29400104 	addi	r5,r5,4
   19880:	48fff336 	bltu	r9,r3,19850 <strncmp+0xb0>
   19884:	19bfffc4 	addi	r6,r3,-1
   19888:	183fca1e 	bne	r3,zero,197b4 <strncmp+0x14>
   1988c:	2005883a 	mov	r2,r4
   19890:	003fd806 	br	197f4 <strncmp+0x54>
   19894:	19bfffc4 	addi	r6,r3,-1
   19898:	003fc606 	br	197b4 <strncmp+0x14>

0001989c <__sprint_r>:
   1989c:	30800217 	ldw	r2,8(r6)
   198a0:	defffe04 	addi	sp,sp,-8
   198a4:	dc000015 	stw	r16,0(sp)
   198a8:	dfc00115 	stw	ra,4(sp)
   198ac:	3021883a 	mov	r16,r6
   198b0:	10000226 	beq	r2,zero,198bc <__sprint_r+0x20>
   198b4:	001dad80 	call	1dad8 <__sfvwrite_r>
   198b8:	80000215 	stw	zero,8(r16)
   198bc:	80000115 	stw	zero,4(r16)
   198c0:	dfc00117 	ldw	ra,4(sp)
   198c4:	dc000017 	ldw	r16,0(sp)
   198c8:	dec00204 	addi	sp,sp,8
   198cc:	f800283a 	ret

000198d0 <___vfprintf_internal_r>:
   198d0:	defeb904 	addi	sp,sp,-1308
   198d4:	dc013d15 	stw	r16,1268(sp)
   198d8:	d9013015 	stw	r4,1216(sp)
   198dc:	dfc14615 	stw	ra,1304(sp)
   198e0:	df014515 	stw	fp,1300(sp)
   198e4:	ddc14415 	stw	r23,1296(sp)
   198e8:	dd814315 	stw	r22,1292(sp)
   198ec:	dd414215 	stw	r21,1288(sp)
   198f0:	dd014115 	stw	r20,1284(sp)
   198f4:	dcc14015 	stw	r19,1280(sp)
   198f8:	dc813f15 	stw	r18,1276(sp)
   198fc:	dc413e15 	stw	r17,1272(sp)
   19900:	d9412915 	stw	r5,1188(sp)
   19904:	3021883a 	mov	r16,r6
   19908:	d9c12d15 	stw	r7,1204(sp)
   1990c:	001e1c40 	call	1e1c4 <_localeconv_r>
   19910:	10800017 	ldw	r2,0(r2)
   19914:	d9013017 	ldw	r4,1216(sp)
   19918:	d8013315 	stw	zero,1228(sp)
   1991c:	d8813715 	stw	r2,1244(sp)
   19920:	d8013415 	stw	zero,1232(sp)
   19924:	20000226 	beq	r4,zero,19930 <___vfprintf_internal_r+0x60>
   19928:	20800e17 	ldw	r2,56(r4)
   1992c:	10019826 	beq	r2,zero,19f90 <___vfprintf_internal_r+0x6c0>
   19930:	da012917 	ldw	r8,1188(sp)
   19934:	4080030b 	ldhu	r2,12(r8)
   19938:	10c0020c 	andi	r3,r2,8
   1993c:	18ffffcc 	andi	r3,r3,65535
   19940:	18e0001c 	xori	r3,r3,32768
   19944:	18e00004 	addi	r3,r3,-32768
   19948:	18013a26 	beq	r3,zero,19e34 <___vfprintf_internal_r+0x564>
   1994c:	40c00417 	ldw	r3,16(r8)
   19950:	18013826 	beq	r3,zero,19e34 <___vfprintf_internal_r+0x564>
   19954:	1100068c 	andi	r4,r2,26
   19958:	00c00284 	movi	r3,10
   1995c:	20c13e26 	beq	r4,r3,19e58 <___vfprintf_internal_r+0x588>
   19960:	da010dc4 	addi	r8,sp,1079
   19964:	d8800404 	addi	r2,sp,16
   19968:	da012615 	stw	r8,1176(sp)
   1996c:	d8811b15 	stw	r2,1132(sp)
   19970:	1013883a 	mov	r9,r2
   19974:	d8812617 	ldw	r2,1176(sp)
   19978:	da010e04 	addi	r8,sp,1080
   1997c:	dc413017 	ldw	r17,1216(sp)
   19980:	da012715 	stw	r8,1180(sp)
   19984:	4091c83a 	sub	r8,r8,r2
   19988:	d8011d15 	stw	zero,1140(sp)
   1998c:	d8011c15 	stw	zero,1136(sp)
   19990:	802b883a 	mov	r21,r16
   19994:	d8013215 	stw	zero,1224(sp)
   19998:	d8013615 	stw	zero,1240(sp)
   1999c:	d8013515 	stw	zero,1236(sp)
   199a0:	d8012c15 	stw	zero,1200(sp)
   199a4:	da013915 	stw	r8,1252(sp)
   199a8:	a8800007 	ldb	r2,0(r21)
   199ac:	1002ec26 	beq	r2,zero,1a560 <___vfprintf_internal_r+0xc90>
   199b0:	00c00944 	movi	r3,37
   199b4:	a825883a 	mov	r18,r21
   199b8:	10c0021e 	bne	r2,r3,199c4 <___vfprintf_internal_r+0xf4>
   199bc:	00001406 	br	19a10 <___vfprintf_internal_r+0x140>
   199c0:	10c00326 	beq	r2,r3,199d0 <___vfprintf_internal_r+0x100>
   199c4:	94800044 	addi	r18,r18,1
   199c8:	90800007 	ldb	r2,0(r18)
   199cc:	103ffc1e 	bne	r2,zero,199c0 <___vfprintf_internal_r+0xf0>
   199d0:	9561c83a 	sub	r16,r18,r21
   199d4:	80000e26 	beq	r16,zero,19a10 <___vfprintf_internal_r+0x140>
   199d8:	da011d17 	ldw	r8,1140(sp)
   199dc:	d8c11c17 	ldw	r3,1136(sp)
   199e0:	4d400015 	stw	r21,0(r9)
   199e4:	4c000115 	stw	r16,4(r9)
   199e8:	4411883a 	add	r8,r8,r16
   199ec:	18c00044 	addi	r3,r3,1
   199f0:	da011d15 	stw	r8,1140(sp)
   199f4:	d8c11c15 	stw	r3,1136(sp)
   199f8:	008001c4 	movi	r2,7
   199fc:	10c15d16 	blt	r2,r3,19f74 <___vfprintf_internal_r+0x6a4>
   19a00:	4a400204 	addi	r9,r9,8
   19a04:	d8812c17 	ldw	r2,1200(sp)
   19a08:	1405883a 	add	r2,r2,r16
   19a0c:	d8812c15 	stw	r2,1200(sp)
   19a10:	90800007 	ldb	r2,0(r18)
   19a14:	10013b26 	beq	r2,zero,19f04 <___vfprintf_internal_r+0x634>
   19a18:	95400044 	addi	r21,r18,1
   19a1c:	94800047 	ldb	r18,1(r18)
   19a20:	d8012585 	stb	zero,1174(sp)
   19a24:	073fffc4 	movi	fp,-1
   19a28:	d8012e15 	stw	zero,1208(sp)
   19a2c:	0021883a 	mov	r16,zero
   19a30:	00c01604 	movi	r3,88
   19a34:	01400244 	movi	r5,9
   19a38:	02800a84 	movi	r10,42
   19a3c:	01c01b04 	movi	r7,108
   19a40:	01800ac4 	movi	r6,43
   19a44:	02c00804 	movi	r11,32
   19a48:	ad400044 	addi	r21,r21,1
   19a4c:	90bff804 	addi	r2,r18,-32
   19a50:	1880092e 	bgeu	r3,r2,19a78 <___vfprintf_internal_r+0x1a8>
   19a54:	90012b26 	beq	r18,zero,19f04 <___vfprintf_internal_r+0x634>
   19a58:	00c00044 	movi	r3,1
   19a5c:	d8c12815 	stw	r3,1184(sp)
   19a60:	dc810405 	stb	r18,1040(sp)
   19a64:	d8012585 	stb	zero,1174(sp)
   19a68:	d8c12b15 	stw	r3,1196(sp)
   19a6c:	dcc10404 	addi	r19,sp,1040
   19a70:	d8013115 	stw	zero,1220(sp)
   19a74:	00008806 	br	19c98 <___vfprintf_internal_r+0x3c8>
   19a78:	1085883a 	add	r2,r2,r2
   19a7c:	1085883a 	add	r2,r2,r2
   19a80:	010000b4 	movhi	r4,2
   19a84:	2126a504 	addi	r4,r4,-25964
   19a88:	1105883a 	add	r2,r2,r4
   19a8c:	10800017 	ldw	r2,0(r2)
   19a90:	1000683a 	jmp	r2
   19a94:	0001a048 	cmpgei	zero,zero,1665
   19a98:	00019a54 	movui	zero,1641
   19a9c:	00019a54 	movui	zero,1641
   19aa0:	0001a05c 	xori	zero,zero,1665
   19aa4:	00019a54 	movui	zero,1641
   19aa8:	00019a54 	movui	zero,1641
   19aac:	00019a54 	movui	zero,1641
   19ab0:	00019a54 	movui	zero,1641
   19ab4:	00019a54 	movui	zero,1641
   19ab8:	00019a54 	movui	zero,1641
   19abc:	0001a144 	movi	zero,1669
   19ac0:	0001a000 	call	1a00 <udpecho_recv+0x94>
   19ac4:	00019a54 	movui	zero,1641
   19ac8:	00019e28 	cmpgeui	zero,zero,1656
   19acc:	0001a00c 	andi	zero,zero,1664
   19ad0:	00019a54 	movui	zero,1641
   19ad4:	0001a068 	cmpgeui	zero,zero,1665
   19ad8:	0001a168 	cmpgeui	zero,zero,1669
   19adc:	0001a168 	cmpgeui	zero,zero,1669
   19ae0:	0001a168 	cmpgeui	zero,zero,1669
   19ae4:	0001a168 	cmpgeui	zero,zero,1669
   19ae8:	0001a168 	cmpgeui	zero,zero,1669
   19aec:	0001a168 	cmpgeui	zero,zero,1669
   19af0:	0001a168 	cmpgeui	zero,zero,1669
   19af4:	0001a168 	cmpgeui	zero,zero,1669
   19af8:	0001a168 	cmpgeui	zero,zero,1669
   19afc:	00019a54 	movui	zero,1641
   19b00:	00019a54 	movui	zero,1641
   19b04:	00019a54 	movui	zero,1641
   19b08:	00019a54 	movui	zero,1641
   19b0c:	00019a54 	movui	zero,1641
   19b10:	00019a54 	movui	zero,1641
   19b14:	00019a54 	movui	zero,1641
   19b18:	00019a54 	movui	zero,1641
   19b1c:	00019a54 	movui	zero,1641
   19b20:	00019a54 	movui	zero,1641
   19b24:	00019dc4 	movi	zero,1655
   19b28:	0001a190 	cmplti	zero,zero,1670
   19b2c:	00019a54 	movui	zero,1641
   19b30:	0001a190 	cmplti	zero,zero,1670
   19b34:	00019a54 	movui	zero,1641
   19b38:	00019a54 	movui	zero,1641
   19b3c:	00019a54 	movui	zero,1641
   19b40:	00019a54 	movui	zero,1641
   19b44:	0001a300 	call	1a30 <udpecho_recv+0xc4>
   19b48:	00019a54 	movui	zero,1641
   19b4c:	00019a54 	movui	zero,1641
   19b50:	00019d8c 	andi	zero,zero,1654
   19b54:	00019a54 	movui	zero,1641
   19b58:	00019a54 	movui	zero,1641
   19b5c:	00019a54 	movui	zero,1641
   19b60:	00019a54 	movui	zero,1641
   19b64:	00019a54 	movui	zero,1641
   19b68:	00019bf8 	rdprs	zero,zero,1647
   19b6c:	00019a54 	movui	zero,1641
   19b70:	00019a54 	movui	zero,1641
   19b74:	0001a074 	movhi	zero,1665
   19b78:	00019a54 	movui	zero,1641
   19b7c:	00019a54 	movui	zero,1641
   19b80:	00019a54 	movui	zero,1641
   19b84:	00019a54 	movui	zero,1641
   19b88:	00019a54 	movui	zero,1641
   19b8c:	00019a54 	movui	zero,1641
   19b90:	00019a54 	movui	zero,1641
   19b94:	00019a54 	movui	zero,1641
   19b98:	00019a54 	movui	zero,1641
   19b9c:	00019a54 	movui	zero,1641
   19ba0:	0001a0e8 	cmpgeui	zero,zero,1667
   19ba4:	00019dc8 	cmpgei	zero,zero,1655
   19ba8:	0001a190 	cmplti	zero,zero,1670
   19bac:	0001a190 	cmplti	zero,zero,1670
   19bb0:	0001a190 	cmplti	zero,zero,1670
   19bb4:	0001a0c8 	cmpgei	zero,zero,1667
   19bb8:	00019dc8 	cmpgei	zero,zero,1655
   19bbc:	00019a54 	movui	zero,1641
   19bc0:	00019a54 	movui	zero,1641
   19bc4:	0001a0d4 	movui	zero,1667
   19bc8:	00019a54 	movui	zero,1641
   19bcc:	0001a118 	cmpnei	zero,zero,1668
   19bd0:	00019d90 	cmplti	zero,zero,1654
   19bd4:	0001a218 	cmpnei	zero,zero,1672
   19bd8:	0001a264 	muli	zero,zero,1673
   19bdc:	00019a54 	movui	zero,1641
   19be0:	0001a270 	cmpltui	zero,zero,1673
   19be4:	00019a54 	movui	zero,1641
   19be8:	00019bfc 	xorhi	zero,zero,1647
   19bec:	00019a54 	movui	zero,1641
   19bf0:	00019a54 	movui	zero,1641
   19bf4:	0001a2cc 	andi	zero,zero,1675
   19bf8:	84000414 	ori	r16,r16,16
   19bfc:	8080080c 	andi	r2,r16,32
   19c00:	1000f51e 	bne	r2,zero,19fd8 <___vfprintf_internal_r+0x708>
   19c04:	8080040c 	andi	r2,r16,16
   19c08:	10042c26 	beq	r2,zero,1acbc <___vfprintf_internal_r+0x13ec>
   19c0c:	da012d17 	ldw	r8,1204(sp)
   19c10:	002d883a 	mov	r22,zero
   19c14:	00c00044 	movi	r3,1
   19c18:	45c00017 	ldw	r23,0(r8)
   19c1c:	42000104 	addi	r8,r8,4
   19c20:	da012d15 	stw	r8,1204(sp)
   19c24:	b805883a 	mov	r2,r23
   19c28:	d8012585 	stb	zero,1174(sp)
   19c2c:	e0000216 	blt	fp,zero,19c38 <___vfprintf_internal_r+0x368>
   19c30:	013fdfc4 	movi	r4,-129
   19c34:	8120703a 	and	r16,r16,r4
   19c38:	1002671e 	bne	r2,zero,1a5d8 <___vfprintf_internal_r+0xd08>
   19c3c:	e002661e 	bne	fp,zero,1a5d8 <___vfprintf_internal_r+0xd08>
   19c40:	18c03fcc 	andi	r3,r3,255
   19c44:	1803561e 	bne	r3,zero,1a9a0 <___vfprintf_internal_r+0x10d0>
   19c48:	8080004c 	andi	r2,r16,1
   19c4c:	10035426 	beq	r2,zero,1a9a0 <___vfprintf_internal_r+0x10d0>
   19c50:	da013917 	ldw	r8,1252(sp)
   19c54:	00800c04 	movi	r2,48
   19c58:	d8810dc5 	stb	r2,1079(sp)
   19c5c:	da012b15 	stw	r8,1196(sp)
   19c60:	dcc10dc4 	addi	r19,sp,1079
   19c64:	d8812b17 	ldw	r2,1196(sp)
   19c68:	d8812815 	stw	r2,1184(sp)
   19c6c:	1700010e 	bge	r2,fp,19c74 <___vfprintf_internal_r+0x3a4>
   19c70:	df012815 	stw	fp,1184(sp)
   19c74:	d8812583 	ldbu	r2,1174(sp)
   19c78:	df013115 	stw	fp,1220(sp)
   19c7c:	10803fcc 	andi	r2,r2,255
   19c80:	1080201c 	xori	r2,r2,128
   19c84:	10bfe004 	addi	r2,r2,-128
   19c88:	10000326 	beq	r2,zero,19c98 <___vfprintf_internal_r+0x3c8>
   19c8c:	da012817 	ldw	r8,1184(sp)
   19c90:	42000044 	addi	r8,r8,1
   19c94:	da012815 	stw	r8,1184(sp)
   19c98:	80c0008c 	andi	r3,r16,2
   19c9c:	d8c12a15 	stw	r3,1192(sp)
   19ca0:	18000326 	beq	r3,zero,19cb0 <___vfprintf_internal_r+0x3e0>
   19ca4:	da012817 	ldw	r8,1184(sp)
   19ca8:	42000084 	addi	r8,r8,2
   19cac:	da012815 	stw	r8,1184(sp)
   19cb0:	80c0210c 	andi	r3,r16,132
   19cb4:	d8c12f15 	stw	r3,1212(sp)
   19cb8:	1801941e 	bne	r3,zero,1a30c <___vfprintf_internal_r+0xa3c>
   19cbc:	da012e17 	ldw	r8,1208(sp)
   19cc0:	d8c12817 	ldw	r3,1184(sp)
   19cc4:	40edc83a 	sub	r22,r8,r3
   19cc8:	0581900e 	bge	zero,r22,1a30c <___vfprintf_internal_r+0xa3c>
   19ccc:	02800404 	movi	r10,16
   19cd0:	da011d17 	ldw	r8,1140(sp)
   19cd4:	d8c11c17 	ldw	r3,1136(sp)
   19cd8:	05c000f4 	movhi	r23,3
   19cdc:	bdc4e084 	addi	r23,r23,4994
   19ce0:	5580200e 	bge	r10,r22,19d64 <___vfprintf_internal_r+0x494>
   19ce4:	dc813815 	stw	r18,1248(sp)
   19ce8:	5039883a 	mov	fp,r10
   19cec:	b825883a 	mov	r18,r23
   19cf0:	050001c4 	movi	r20,7
   19cf4:	b02f883a 	mov	r23,r22
   19cf8:	802d883a 	mov	r22,r16
   19cfc:	dc012917 	ldw	r16,1188(sp)
   19d00:	00000306 	br	19d10 <___vfprintf_internal_r+0x440>
   19d04:	bdfffc04 	addi	r23,r23,-16
   19d08:	4a400204 	addi	r9,r9,8
   19d0c:	e5c0110e 	bge	fp,r23,19d54 <___vfprintf_internal_r+0x484>
   19d10:	4c800015 	stw	r18,0(r9)
   19d14:	4f000115 	stw	fp,4(r9)
   19d18:	42000404 	addi	r8,r8,16
   19d1c:	18c00044 	addi	r3,r3,1
   19d20:	da011d15 	stw	r8,1140(sp)
   19d24:	d8c11c15 	stw	r3,1136(sp)
   19d28:	a0fff60e 	bge	r20,r3,19d04 <___vfprintf_internal_r+0x434>
   19d2c:	8809883a 	mov	r4,r17
   19d30:	800b883a 	mov	r5,r16
   19d34:	d9811b04 	addi	r6,sp,1132
   19d38:	001989c0 	call	1989c <__sprint_r>
   19d3c:	1000771e 	bne	r2,zero,19f1c <___vfprintf_internal_r+0x64c>
   19d40:	bdfffc04 	addi	r23,r23,-16
   19d44:	da011d17 	ldw	r8,1140(sp)
   19d48:	d8c11c17 	ldw	r3,1136(sp)
   19d4c:	da400404 	addi	r9,sp,16
   19d50:	e5ffef16 	blt	fp,r23,19d10 <___vfprintf_internal_r+0x440>
   19d54:	b021883a 	mov	r16,r22
   19d58:	b82d883a 	mov	r22,r23
   19d5c:	902f883a 	mov	r23,r18
   19d60:	dc813817 	ldw	r18,1248(sp)
   19d64:	4dc00015 	stw	r23,0(r9)
   19d68:	4d800115 	stw	r22,4(r9)
   19d6c:	4591883a 	add	r8,r8,r22
   19d70:	18c00044 	addi	r3,r3,1
   19d74:	da011d15 	stw	r8,1140(sp)
   19d78:	d8c11c15 	stw	r3,1136(sp)
   19d7c:	008001c4 	movi	r2,7
   19d80:	10c36d16 	blt	r2,r3,1ab38 <___vfprintf_internal_r+0x1268>
   19d84:	4a400204 	addi	r9,r9,8
   19d88:	00016206 	br	1a314 <___vfprintf_internal_r+0xa44>
   19d8c:	84000414 	ori	r16,r16,16
   19d90:	8080080c 	andi	r2,r16,32
   19d94:	1000801e 	bne	r2,zero,19f98 <___vfprintf_internal_r+0x6c8>
   19d98:	8080040c 	andi	r2,r16,16
   19d9c:	1003da26 	beq	r2,zero,1ad08 <___vfprintf_internal_r+0x1438>
   19da0:	d8c12d17 	ldw	r3,1204(sp)
   19da4:	002d883a 	mov	r22,zero
   19da8:	1dc00017 	ldw	r23,0(r3)
   19dac:	18c00104 	addi	r3,r3,4
   19db0:	d8c12d15 	stw	r3,1204(sp)
   19db4:	b805883a 	mov	r2,r23
   19db8:	0007883a 	mov	r3,zero
   19dbc:	d8012585 	stb	zero,1174(sp)
   19dc0:	003f9a06 	br	19c2c <___vfprintf_internal_r+0x35c>
   19dc4:	84000414 	ori	r16,r16,16
   19dc8:	8080080c 	andi	r2,r16,32
   19dcc:	10007b1e 	bne	r2,zero,19fbc <___vfprintf_internal_r+0x6ec>
   19dd0:	8080040c 	andi	r2,r16,16
   19dd4:	1003ed26 	beq	r2,zero,1ad8c <___vfprintf_internal_r+0x14bc>
   19dd8:	d9012d17 	ldw	r4,1204(sp)
   19ddc:	25c00017 	ldw	r23,0(r4)
   19de0:	21000104 	addi	r4,r4,4
   19de4:	d9012d15 	stw	r4,1204(sp)
   19de8:	b82dd7fa 	srai	r22,r23,31
   19dec:	b005883a 	mov	r2,r22
   19df0:	1003230e 	bge	r2,zero,1aa80 <___vfprintf_internal_r+0x11b0>
   19df4:	05efc83a 	sub	r23,zero,r23
   19df8:	b804c03a 	cmpne	r2,r23,zero
   19dfc:	05adc83a 	sub	r22,zero,r22
   19e00:	b0adc83a 	sub	r22,r22,r2
   19e04:	00800b44 	movi	r2,45
   19e08:	d8812585 	stb	r2,1174(sp)
   19e0c:	00c00044 	movi	r3,1
   19e10:	bd84b03a 	or	r2,r23,r22
   19e14:	003f8506 	br	19c2c <___vfprintf_internal_r+0x35c>
   19e18:	da012e17 	ldw	r8,1208(sp)
   19e1c:	d8812d15 	stw	r2,1204(sp)
   19e20:	0211c83a 	sub	r8,zero,r8
   19e24:	da012e15 	stw	r8,1208(sp)
   19e28:	84000114 	ori	r16,r16,4
   19e2c:	ac800007 	ldb	r18,0(r21)
   19e30:	003f0506 	br	19a48 <___vfprintf_internal_r+0x178>
   19e34:	d9013017 	ldw	r4,1216(sp)
   19e38:	d9412917 	ldw	r5,1188(sp)
   19e3c:	001b8440 	call	1b844 <__swsetup_r>
   19e40:	10003d1e 	bne	r2,zero,19f38 <___vfprintf_internal_r+0x668>
   19e44:	d8c12917 	ldw	r3,1188(sp)
   19e48:	1880030b 	ldhu	r2,12(r3)
   19e4c:	00c00284 	movi	r3,10
   19e50:	1100068c 	andi	r4,r2,26
   19e54:	20fec21e 	bne	r4,r3,19960 <___vfprintf_internal_r+0x90>
   19e58:	d9012917 	ldw	r4,1188(sp)
   19e5c:	20c0038b 	ldhu	r3,14(r4)
   19e60:	193fffcc 	andi	r4,r3,65535
   19e64:	2120001c 	xori	r4,r4,32768
   19e68:	21200004 	addi	r4,r4,-32768
   19e6c:	203ebc16 	blt	r4,zero,19960 <___vfprintf_internal_r+0x90>
   19e70:	da012917 	ldw	r8,1188(sp)
   19e74:	d9013017 	ldw	r4,1216(sp)
   19e78:	d9c12d17 	ldw	r7,1204(sp)
   19e7c:	42800717 	ldw	r10,28(r8)
   19e80:	42400917 	ldw	r9,36(r8)
   19e84:	10bfff4c 	andi	r2,r2,65533
   19e88:	02010004 	movi	r8,1024
   19e8c:	d881070d 	sth	r2,1052(sp)
   19e90:	d9410404 	addi	r5,sp,1040
   19e94:	d8800404 	addi	r2,sp,16
   19e98:	800d883a 	mov	r6,r16
   19e9c:	d8c1078d 	sth	r3,1054(sp)
   19ea0:	da810b15 	stw	r10,1068(sp)
   19ea4:	da410d15 	stw	r9,1076(sp)
   19ea8:	d8810415 	stw	r2,1040(sp)
   19eac:	d8810815 	stw	r2,1056(sp)
   19eb0:	da010615 	stw	r8,1048(sp)
   19eb4:	da010915 	stw	r8,1060(sp)
   19eb8:	d8010a15 	stw	zero,1064(sp)
   19ebc:	00198d00 	call	198d0 <___vfprintf_internal_r>
   19ec0:	d8812c15 	stw	r2,1200(sp)
   19ec4:	10000416 	blt	r2,zero,19ed8 <___vfprintf_internal_r+0x608>
   19ec8:	d9013017 	ldw	r4,1216(sp)
   19ecc:	d9410404 	addi	r5,sp,1040
   19ed0:	001d1dc0 	call	1d1dc <_fflush_r>
   19ed4:	1005d81e 	bne	r2,zero,1b638 <___vfprintf_internal_r+0x1d68>
   19ed8:	d881070b 	ldhu	r2,1052(sp)
   19edc:	1080100c 	andi	r2,r2,64
   19ee0:	10bfffcc 	andi	r2,r2,65535
   19ee4:	10a0001c 	xori	r2,r2,32768
   19ee8:	10a00004 	addi	r2,r2,-32768
   19eec:	10001426 	beq	r2,zero,19f40 <___vfprintf_internal_r+0x670>
   19ef0:	d8c12917 	ldw	r3,1188(sp)
   19ef4:	1880030b 	ldhu	r2,12(r3)
   19ef8:	10801014 	ori	r2,r2,64
   19efc:	1880030d 	sth	r2,12(r3)
   19f00:	00000f06 	br	19f40 <___vfprintf_internal_r+0x670>
   19f04:	d8811d17 	ldw	r2,1140(sp)
   19f08:	10000426 	beq	r2,zero,19f1c <___vfprintf_internal_r+0x64c>
   19f0c:	d9013017 	ldw	r4,1216(sp)
   19f10:	d9412917 	ldw	r5,1188(sp)
   19f14:	d9811b04 	addi	r6,sp,1132
   19f18:	001989c0 	call	1989c <__sprint_r>
   19f1c:	d8c12917 	ldw	r3,1188(sp)
   19f20:	1880030b 	ldhu	r2,12(r3)
   19f24:	1080100c 	andi	r2,r2,64
   19f28:	10bfffcc 	andi	r2,r2,65535
   19f2c:	10a0001c 	xori	r2,r2,32768
   19f30:	10a00004 	addi	r2,r2,-32768
   19f34:	10000226 	beq	r2,zero,19f40 <___vfprintf_internal_r+0x670>
   19f38:	00bfffc4 	movi	r2,-1
   19f3c:	d8812c15 	stw	r2,1200(sp)
   19f40:	d8812c17 	ldw	r2,1200(sp)
   19f44:	dfc14617 	ldw	ra,1304(sp)
   19f48:	df014517 	ldw	fp,1300(sp)
   19f4c:	ddc14417 	ldw	r23,1296(sp)
   19f50:	dd814317 	ldw	r22,1292(sp)
   19f54:	dd414217 	ldw	r21,1288(sp)
   19f58:	dd014117 	ldw	r20,1284(sp)
   19f5c:	dcc14017 	ldw	r19,1280(sp)
   19f60:	dc813f17 	ldw	r18,1276(sp)
   19f64:	dc413e17 	ldw	r17,1272(sp)
   19f68:	dc013d17 	ldw	r16,1268(sp)
   19f6c:	dec14704 	addi	sp,sp,1308
   19f70:	f800283a 	ret
   19f74:	d9412917 	ldw	r5,1188(sp)
   19f78:	8809883a 	mov	r4,r17
   19f7c:	d9811b04 	addi	r6,sp,1132
   19f80:	001989c0 	call	1989c <__sprint_r>
   19f84:	103fe51e 	bne	r2,zero,19f1c <___vfprintf_internal_r+0x64c>
   19f88:	da400404 	addi	r9,sp,16
   19f8c:	003e9d06 	br	19a04 <___vfprintf_internal_r+0x134>
   19f90:	001d4840 	call	1d484 <__sinit>
   19f94:	003e6606 	br	19930 <___vfprintf_internal_r+0x60>
   19f98:	d8812d17 	ldw	r2,1204(sp)
   19f9c:	0007883a 	mov	r3,zero
   19fa0:	15c00017 	ldw	r23,0(r2)
   19fa4:	15800117 	ldw	r22,4(r2)
   19fa8:	10800204 	addi	r2,r2,8
   19fac:	d8812d15 	stw	r2,1204(sp)
   19fb0:	d8012585 	stb	zero,1174(sp)
   19fb4:	bd84b03a 	or	r2,r23,r22
   19fb8:	003f1c06 	br	19c2c <___vfprintf_internal_r+0x35c>
   19fbc:	d8c12d17 	ldw	r3,1204(sp)
   19fc0:	18800117 	ldw	r2,4(r3)
   19fc4:	1dc00017 	ldw	r23,0(r3)
   19fc8:	18c00204 	addi	r3,r3,8
   19fcc:	d8c12d15 	stw	r3,1204(sp)
   19fd0:	102d883a 	mov	r22,r2
   19fd4:	003f8606 	br	19df0 <___vfprintf_internal_r+0x520>
   19fd8:	d8c12d17 	ldw	r3,1204(sp)
   19fdc:	d9012d17 	ldw	r4,1204(sp)
   19fe0:	1dc00017 	ldw	r23,0(r3)
   19fe4:	1d800117 	ldw	r22,4(r3)
   19fe8:	21000204 	addi	r4,r4,8
   19fec:	00c00044 	movi	r3,1
   19ff0:	d9012d15 	stw	r4,1204(sp)
   19ff4:	bd84b03a 	or	r2,r23,r22
   19ff8:	d8012585 	stb	zero,1174(sp)
   19ffc:	003f0b06 	br	19c2c <___vfprintf_internal_r+0x35c>
   1a000:	d9812585 	stb	r6,1174(sp)
   1a004:	ac800007 	ldb	r18,0(r21)
   1a008:	003e8f06 	br	19a48 <___vfprintf_internal_r+0x178>
   1a00c:	ac800007 	ldb	r18,0(r21)
   1a010:	a9000044 	addi	r4,r21,1
   1a014:	92857d26 	beq	r18,r10,1b60c <___vfprintf_internal_r+0x1d3c>
   1a018:	90bff404 	addi	r2,r18,-48
   1a01c:	0039883a 	mov	fp,zero
   1a020:	28800736 	bltu	r5,r2,1a040 <___vfprintf_internal_r+0x770>
   1a024:	24800007 	ldb	r18,0(r4)
   1a028:	e70002a4 	muli	fp,fp,10
   1a02c:	21000044 	addi	r4,r4,1
   1a030:	1739883a 	add	fp,r2,fp
   1a034:	90bff404 	addi	r2,r18,-48
   1a038:	28bffa2e 	bgeu	r5,r2,1a024 <___vfprintf_internal_r+0x754>
   1a03c:	e0044216 	blt	fp,zero,1b148 <___vfprintf_internal_r+0x1878>
   1a040:	202b883a 	mov	r21,r4
   1a044:	003e8106 	br	19a4c <___vfprintf_internal_r+0x17c>
   1a048:	d8812587 	ldb	r2,1174(sp)
   1a04c:	1003581e 	bne	r2,zero,1adb0 <___vfprintf_internal_r+0x14e0>
   1a050:	dac12585 	stb	r11,1174(sp)
   1a054:	ac800007 	ldb	r18,0(r21)
   1a058:	003e7b06 	br	19a48 <___vfprintf_internal_r+0x178>
   1a05c:	84000054 	ori	r16,r16,1
   1a060:	ac800007 	ldb	r18,0(r21)
   1a064:	003e7806 	br	19a48 <___vfprintf_internal_r+0x178>
   1a068:	84002014 	ori	r16,r16,128
   1a06c:	ac800007 	ldb	r18,0(r21)
   1a070:	003e7506 	br	19a48 <___vfprintf_internal_r+0x178>
   1a074:	020000f4 	movhi	r8,3
   1a078:	4204d404 	addi	r8,r8,4944
   1a07c:	da013615 	stw	r8,1240(sp)
   1a080:	8080080c 	andi	r2,r16,32
   1a084:	10009626 	beq	r2,zero,1a2e0 <___vfprintf_internal_r+0xa10>
   1a088:	d8812d17 	ldw	r2,1204(sp)
   1a08c:	15c00017 	ldw	r23,0(r2)
   1a090:	15800117 	ldw	r22,4(r2)
   1a094:	10800204 	addi	r2,r2,8
   1a098:	d8812d15 	stw	r2,1204(sp)
   1a09c:	8080004c 	andi	r2,r16,1
   1a0a0:	1002ae26 	beq	r2,zero,1ab5c <___vfprintf_internal_r+0x128c>
   1a0a4:	bd84b03a 	or	r2,r23,r22
   1a0a8:	10032a26 	beq	r2,zero,1ad54 <___vfprintf_internal_r+0x1484>
   1a0ac:	00c00c04 	movi	r3,48
   1a0b0:	d8c12505 	stb	r3,1172(sp)
   1a0b4:	dc812545 	stb	r18,1173(sp)
   1a0b8:	84000094 	ori	r16,r16,2
   1a0bc:	00c00084 	movi	r3,2
   1a0c0:	d8012585 	stb	zero,1174(sp)
   1a0c4:	003ed906 	br	19c2c <___vfprintf_internal_r+0x35c>
   1a0c8:	84001014 	ori	r16,r16,64
   1a0cc:	ac800007 	ldb	r18,0(r21)
   1a0d0:	003e5d06 	br	19a48 <___vfprintf_internal_r+0x178>
   1a0d4:	ac800007 	ldb	r18,0(r21)
   1a0d8:	a805883a 	mov	r2,r21
   1a0dc:	91c43226 	beq	r18,r7,1b1a8 <___vfprintf_internal_r+0x18d8>
   1a0e0:	84000414 	ori	r16,r16,16
   1a0e4:	003e5806 	br	19a48 <___vfprintf_internal_r+0x178>
   1a0e8:	d8c12d17 	ldw	r3,1204(sp)
   1a0ec:	02000044 	movi	r8,1
   1a0f0:	da012815 	stw	r8,1184(sp)
   1a0f4:	18800017 	ldw	r2,0(r3)
   1a0f8:	18c00104 	addi	r3,r3,4
   1a0fc:	d8012585 	stb	zero,1174(sp)
   1a100:	d8810405 	stb	r2,1040(sp)
   1a104:	d8c12d15 	stw	r3,1204(sp)
   1a108:	da012b15 	stw	r8,1196(sp)
   1a10c:	dcc10404 	addi	r19,sp,1040
   1a110:	d8013115 	stw	zero,1220(sp)
   1a114:	003ee006 	br	19c98 <___vfprintf_internal_r+0x3c8>
   1a118:	8080080c 	andi	r2,r16,32
   1a11c:	10031026 	beq	r2,zero,1ad60 <___vfprintf_internal_r+0x1490>
   1a120:	d9012d17 	ldw	r4,1204(sp)
   1a124:	da012c17 	ldw	r8,1200(sp)
   1a128:	20800017 	ldw	r2,0(r4)
   1a12c:	4007d7fa 	srai	r3,r8,31
   1a130:	21000104 	addi	r4,r4,4
   1a134:	d9012d15 	stw	r4,1204(sp)
   1a138:	12000015 	stw	r8,0(r2)
   1a13c:	10c00115 	stw	r3,4(r2)
   1a140:	003e1906 	br	199a8 <___vfprintf_internal_r+0xd8>
   1a144:	da012d17 	ldw	r8,1204(sp)
   1a148:	d9012d17 	ldw	r4,1204(sp)
   1a14c:	42000017 	ldw	r8,0(r8)
   1a150:	20800104 	addi	r2,r4,4
   1a154:	da012e15 	stw	r8,1208(sp)
   1a158:	403f2f16 	blt	r8,zero,19e18 <___vfprintf_internal_r+0x548>
   1a15c:	d8812d15 	stw	r2,1204(sp)
   1a160:	ac800007 	ldb	r18,0(r21)
   1a164:	003e3806 	br	19a48 <___vfprintf_internal_r+0x178>
   1a168:	0009883a 	mov	r4,zero
   1a16c:	90bff404 	addi	r2,r18,-48
   1a170:	ac800007 	ldb	r18,0(r21)
   1a174:	210002a4 	muli	r4,r4,10
   1a178:	ad400044 	addi	r21,r21,1
   1a17c:	2089883a 	add	r4,r4,r2
   1a180:	90bff404 	addi	r2,r18,-48
   1a184:	28bffa2e 	bgeu	r5,r2,1a170 <___vfprintf_internal_r+0x8a0>
   1a188:	d9012e15 	stw	r4,1208(sp)
   1a18c:	003e2f06 	br	19a4c <___vfprintf_internal_r+0x17c>
   1a190:	8080020c 	andi	r2,r16,8
   1a194:	1002d426 	beq	r2,zero,1ace8 <___vfprintf_internal_r+0x1418>
   1a198:	d8c12d17 	ldw	r3,1204(sp)
   1a19c:	1d800017 	ldw	r22,0(r3)
   1a1a0:	1d000117 	ldw	r20,4(r3)
   1a1a4:	18c00204 	addi	r3,r3,8
   1a1a8:	d8c12d15 	stw	r3,1204(sp)
   1a1ac:	dd813315 	stw	r22,1228(sp)
   1a1b0:	dd013415 	stw	r20,1232(sp)
   1a1b4:	b009883a 	mov	r4,r22
   1a1b8:	a00b883a 	mov	r5,r20
   1a1bc:	da413c15 	stw	r9,1264(sp)
   1a1c0:	00202e80 	call	202e8 <__isinfd>
   1a1c4:	da413c17 	ldw	r9,1264(sp)
   1a1c8:	b009883a 	mov	r4,r22
   1a1cc:	a00b883a 	mov	r5,r20
   1a1d0:	10035726 	beq	r2,zero,1af30 <___vfprintf_internal_r+0x1660>
   1a1d4:	000d883a 	mov	r6,zero
   1a1d8:	000f883a 	mov	r7,zero
   1a1dc:	00215e00 	call	215e0 <__ltdf2>
   1a1e0:	da413c17 	ldw	r9,1264(sp)
   1a1e4:	10041b16 	blt	r2,zero,1b254 <___vfprintf_internal_r+0x1984>
   1a1e8:	d8812583 	ldbu	r2,1174(sp)
   1a1ec:	00c011c4 	movi	r3,71
   1a1f0:	1c830b16 	blt	r3,r18,1ae20 <___vfprintf_internal_r+0x1550>
   1a1f4:	04c000f4 	movhi	r19,3
   1a1f8:	9cc4d004 	addi	r19,r19,4928
   1a1fc:	020000c4 	movi	r8,3
   1a200:	00ffdfc4 	movi	r3,-129
   1a204:	da012815 	stw	r8,1184(sp)
   1a208:	80e0703a 	and	r16,r16,r3
   1a20c:	da012b15 	stw	r8,1196(sp)
   1a210:	d8013115 	stw	zero,1220(sp)
   1a214:	003e9906 	br	19c7c <___vfprintf_internal_r+0x3ac>
   1a218:	d8812d17 	ldw	r2,1204(sp)
   1a21c:	d8c12d17 	ldw	r3,1204(sp)
   1a220:	020000f4 	movhi	r8,3
   1a224:	4204d904 	addi	r8,r8,4964
   1a228:	15c00017 	ldw	r23,0(r2)
   1a22c:	00800c04 	movi	r2,48
   1a230:	18c00104 	addi	r3,r3,4
   1a234:	d8812505 	stb	r2,1172(sp)
   1a238:	00801e04 	movi	r2,120
   1a23c:	d8812545 	stb	r2,1173(sp)
   1a240:	d8c12d15 	stw	r3,1204(sp)
   1a244:	002d883a 	mov	r22,zero
   1a248:	84000094 	ori	r16,r16,2
   1a24c:	da013615 	stw	r8,1240(sp)
   1a250:	00c00084 	movi	r3,2
   1a254:	04801e04 	movi	r18,120
   1a258:	b805883a 	mov	r2,r23
   1a25c:	d8012585 	stb	zero,1174(sp)
   1a260:	003e7206 	br	19c2c <___vfprintf_internal_r+0x35c>
   1a264:	84000814 	ori	r16,r16,32
   1a268:	ac800007 	ldb	r18,0(r21)
   1a26c:	003df606 	br	19a48 <___vfprintf_internal_r+0x178>
   1a270:	d8812d17 	ldw	r2,1204(sp)
   1a274:	d8012585 	stb	zero,1174(sp)
   1a278:	14c00017 	ldw	r19,0(r2)
   1a27c:	15c00104 	addi	r23,r2,4
   1a280:	98040126 	beq	r19,zero,1b288 <___vfprintf_internal_r+0x19b8>
   1a284:	9809883a 	mov	r4,r19
   1a288:	e003dd16 	blt	fp,zero,1b200 <___vfprintf_internal_r+0x1930>
   1a28c:	000b883a 	mov	r5,zero
   1a290:	e00d883a 	mov	r6,fp
   1a294:	da413c15 	stw	r9,1264(sp)
   1a298:	001eb240 	call	1eb24 <memchr>
   1a29c:	da413c17 	ldw	r9,1264(sp)
   1a2a0:	10042e26 	beq	r2,zero,1b35c <___vfprintf_internal_r+0x1a8c>
   1a2a4:	14c5c83a 	sub	r2,r2,r19
   1a2a8:	d8812b15 	stw	r2,1196(sp)
   1a2ac:	e083790e 	bge	fp,r2,1b094 <___vfprintf_internal_r+0x17c4>
   1a2b0:	df012815 	stw	fp,1184(sp)
   1a2b4:	e0049516 	blt	fp,zero,1b50c <___vfprintf_internal_r+0x1c3c>
   1a2b8:	d8812583 	ldbu	r2,1174(sp)
   1a2bc:	df012b15 	stw	fp,1196(sp)
   1a2c0:	ddc12d15 	stw	r23,1204(sp)
   1a2c4:	d8013115 	stw	zero,1220(sp)
   1a2c8:	003e6c06 	br	19c7c <___vfprintf_internal_r+0x3ac>
   1a2cc:	020000f4 	movhi	r8,3
   1a2d0:	4204d904 	addi	r8,r8,4964
   1a2d4:	da013615 	stw	r8,1240(sp)
   1a2d8:	8080080c 	andi	r2,r16,32
   1a2dc:	103f6a1e 	bne	r2,zero,1a088 <___vfprintf_internal_r+0x7b8>
   1a2e0:	8080040c 	andi	r2,r16,16
   1a2e4:	10029326 	beq	r2,zero,1ad34 <___vfprintf_internal_r+0x1464>
   1a2e8:	d8c12d17 	ldw	r3,1204(sp)
   1a2ec:	002d883a 	mov	r22,zero
   1a2f0:	1dc00017 	ldw	r23,0(r3)
   1a2f4:	18c00104 	addi	r3,r3,4
   1a2f8:	d8c12d15 	stw	r3,1204(sp)
   1a2fc:	003f6706 	br	1a09c <___vfprintf_internal_r+0x7cc>
   1a300:	84000214 	ori	r16,r16,8
   1a304:	ac800007 	ldb	r18,0(r21)
   1a308:	003dcf06 	br	19a48 <___vfprintf_internal_r+0x178>
   1a30c:	da011d17 	ldw	r8,1140(sp)
   1a310:	d8c11c17 	ldw	r3,1136(sp)
   1a314:	d8812587 	ldb	r2,1174(sp)
   1a318:	10000b26 	beq	r2,zero,1a348 <___vfprintf_internal_r+0xa78>
   1a31c:	d8812584 	addi	r2,sp,1174
   1a320:	48800015 	stw	r2,0(r9)
   1a324:	00800044 	movi	r2,1
   1a328:	48800115 	stw	r2,4(r9)
   1a32c:	4091883a 	add	r8,r8,r2
   1a330:	1887883a 	add	r3,r3,r2
   1a334:	da011d15 	stw	r8,1140(sp)
   1a338:	d8c11c15 	stw	r3,1136(sp)
   1a33c:	008001c4 	movi	r2,7
   1a340:	10c18516 	blt	r2,r3,1a958 <___vfprintf_internal_r+0x1088>
   1a344:	4a400204 	addi	r9,r9,8
   1a348:	d9012a17 	ldw	r4,1192(sp)
   1a34c:	20000b26 	beq	r4,zero,1a37c <___vfprintf_internal_r+0xaac>
   1a350:	d8812504 	addi	r2,sp,1172
   1a354:	48800015 	stw	r2,0(r9)
   1a358:	00800084 	movi	r2,2
   1a35c:	48800115 	stw	r2,4(r9)
   1a360:	4091883a 	add	r8,r8,r2
   1a364:	18c00044 	addi	r3,r3,1
   1a368:	da011d15 	stw	r8,1140(sp)
   1a36c:	d8c11c15 	stw	r3,1136(sp)
   1a370:	008001c4 	movi	r2,7
   1a374:	10c18116 	blt	r2,r3,1a97c <___vfprintf_internal_r+0x10ac>
   1a378:	4a400204 	addi	r9,r9,8
   1a37c:	d9012f17 	ldw	r4,1212(sp)
   1a380:	00802004 	movi	r2,128
   1a384:	2080fc26 	beq	r4,r2,1a778 <___vfprintf_internal_r+0xea8>
   1a388:	d8813117 	ldw	r2,1220(sp)
   1a38c:	d9012b17 	ldw	r4,1196(sp)
   1a390:	112fc83a 	sub	r23,r2,r4
   1a394:	05c02a0e 	bge	zero,r23,1a440 <___vfprintf_internal_r+0xb70>
   1a398:	07000404 	movi	fp,16
   1a39c:	050000f4 	movhi	r20,3
   1a3a0:	a504e484 	addi	r20,r20,5010
   1a3a4:	e5c01d0e 	bge	fp,r23,1a41c <___vfprintf_internal_r+0xb4c>
   1a3a8:	dc812a15 	stw	r18,1192(sp)
   1a3ac:	058001c4 	movi	r22,7
   1a3b0:	a025883a 	mov	r18,r20
   1a3b4:	8029883a 	mov	r20,r16
   1a3b8:	dc012917 	ldw	r16,1188(sp)
   1a3bc:	00000306 	br	1a3cc <___vfprintf_internal_r+0xafc>
   1a3c0:	bdfffc04 	addi	r23,r23,-16
   1a3c4:	4a400204 	addi	r9,r9,8
   1a3c8:	e5c0110e 	bge	fp,r23,1a410 <___vfprintf_internal_r+0xb40>
   1a3cc:	4c800015 	stw	r18,0(r9)
   1a3d0:	4f000115 	stw	fp,4(r9)
   1a3d4:	42000404 	addi	r8,r8,16
   1a3d8:	18c00044 	addi	r3,r3,1
   1a3dc:	da011d15 	stw	r8,1140(sp)
   1a3e0:	d8c11c15 	stw	r3,1136(sp)
   1a3e4:	b0fff60e 	bge	r22,r3,1a3c0 <___vfprintf_internal_r+0xaf0>
   1a3e8:	8809883a 	mov	r4,r17
   1a3ec:	800b883a 	mov	r5,r16
   1a3f0:	d9811b04 	addi	r6,sp,1132
   1a3f4:	001989c0 	call	1989c <__sprint_r>
   1a3f8:	103ec81e 	bne	r2,zero,19f1c <___vfprintf_internal_r+0x64c>
   1a3fc:	bdfffc04 	addi	r23,r23,-16
   1a400:	da011d17 	ldw	r8,1140(sp)
   1a404:	d8c11c17 	ldw	r3,1136(sp)
   1a408:	da400404 	addi	r9,sp,16
   1a40c:	e5ffef16 	blt	fp,r23,1a3cc <___vfprintf_internal_r+0xafc>
   1a410:	a021883a 	mov	r16,r20
   1a414:	9029883a 	mov	r20,r18
   1a418:	dc812a17 	ldw	r18,1192(sp)
   1a41c:	4d000015 	stw	r20,0(r9)
   1a420:	4dc00115 	stw	r23,4(r9)
   1a424:	45d1883a 	add	r8,r8,r23
   1a428:	18c00044 	addi	r3,r3,1
   1a42c:	da011d15 	stw	r8,1140(sp)
   1a430:	d8c11c15 	stw	r3,1136(sp)
   1a434:	008001c4 	movi	r2,7
   1a438:	10c13e16 	blt	r2,r3,1a934 <___vfprintf_internal_r+0x1064>
   1a43c:	4a400204 	addi	r9,r9,8
   1a440:	8080400c 	andi	r2,r16,256
   1a444:	1000831e 	bne	r2,zero,1a654 <___vfprintf_internal_r+0xd84>
   1a448:	d8812b17 	ldw	r2,1196(sp)
   1a44c:	4cc00015 	stw	r19,0(r9)
   1a450:	48800115 	stw	r2,4(r9)
   1a454:	4091883a 	add	r8,r8,r2
   1a458:	18c00044 	addi	r3,r3,1
   1a45c:	da011d15 	stw	r8,1140(sp)
   1a460:	d8c11c15 	stw	r3,1136(sp)
   1a464:	008001c4 	movi	r2,7
   1a468:	10c05316 	blt	r2,r3,1a5b8 <___vfprintf_internal_r+0xce8>
   1a46c:	4a400204 	addi	r9,r9,8
   1a470:	8400010c 	andi	r16,r16,4
   1a474:	80002e26 	beq	r16,zero,1a530 <___vfprintf_internal_r+0xc60>
   1a478:	d8812e17 	ldw	r2,1208(sp)
   1a47c:	d8c12817 	ldw	r3,1184(sp)
   1a480:	10e1c83a 	sub	r16,r2,r3
   1a484:	04002a0e 	bge	zero,r16,1a530 <___vfprintf_internal_r+0xc60>
   1a488:	04800404 	movi	r18,16
   1a48c:	d8c11c17 	ldw	r3,1136(sp)
   1a490:	05c000f4 	movhi	r23,3
   1a494:	bdc4e084 	addi	r23,r23,4994
   1a498:	9400170e 	bge	r18,r16,1a4f8 <___vfprintf_internal_r+0xc28>
   1a49c:	04c001c4 	movi	r19,7
   1a4a0:	dd012917 	ldw	r20,1188(sp)
   1a4a4:	00000306 	br	1a4b4 <___vfprintf_internal_r+0xbe4>
   1a4a8:	843ffc04 	addi	r16,r16,-16
   1a4ac:	4a400204 	addi	r9,r9,8
   1a4b0:	9400110e 	bge	r18,r16,1a4f8 <___vfprintf_internal_r+0xc28>
   1a4b4:	4dc00015 	stw	r23,0(r9)
   1a4b8:	4c800115 	stw	r18,4(r9)
   1a4bc:	42000404 	addi	r8,r8,16
   1a4c0:	18c00044 	addi	r3,r3,1
   1a4c4:	da011d15 	stw	r8,1140(sp)
   1a4c8:	d8c11c15 	stw	r3,1136(sp)
   1a4cc:	98fff60e 	bge	r19,r3,1a4a8 <___vfprintf_internal_r+0xbd8>
   1a4d0:	8809883a 	mov	r4,r17
   1a4d4:	a00b883a 	mov	r5,r20
   1a4d8:	d9811b04 	addi	r6,sp,1132
   1a4dc:	001989c0 	call	1989c <__sprint_r>
   1a4e0:	103e8e1e 	bne	r2,zero,19f1c <___vfprintf_internal_r+0x64c>
   1a4e4:	843ffc04 	addi	r16,r16,-16
   1a4e8:	da011d17 	ldw	r8,1140(sp)
   1a4ec:	d8c11c17 	ldw	r3,1136(sp)
   1a4f0:	da400404 	addi	r9,sp,16
   1a4f4:	943fef16 	blt	r18,r16,1a4b4 <___vfprintf_internal_r+0xbe4>
   1a4f8:	4dc00015 	stw	r23,0(r9)
   1a4fc:	4c000115 	stw	r16,4(r9)
   1a500:	8211883a 	add	r8,r16,r8
   1a504:	18c00044 	addi	r3,r3,1
   1a508:	da011d15 	stw	r8,1140(sp)
   1a50c:	d8c11c15 	stw	r3,1136(sp)
   1a510:	008001c4 	movi	r2,7
   1a514:	10c0060e 	bge	r2,r3,1a530 <___vfprintf_internal_r+0xc60>
   1a518:	d9412917 	ldw	r5,1188(sp)
   1a51c:	8809883a 	mov	r4,r17
   1a520:	d9811b04 	addi	r6,sp,1132
   1a524:	001989c0 	call	1989c <__sprint_r>
   1a528:	103e7c1e 	bne	r2,zero,19f1c <___vfprintf_internal_r+0x64c>
   1a52c:	da011d17 	ldw	r8,1140(sp)
   1a530:	dd012817 	ldw	r20,1184(sp)
   1a534:	d9012e17 	ldw	r4,1208(sp)
   1a538:	a100010e 	bge	r20,r4,1a540 <___vfprintf_internal_r+0xc70>
   1a53c:	2029883a 	mov	r20,r4
   1a540:	d8812c17 	ldw	r2,1200(sp)
   1a544:	1505883a 	add	r2,r2,r20
   1a548:	d8812c15 	stw	r2,1200(sp)
   1a54c:	4000b91e 	bne	r8,zero,1a834 <___vfprintf_internal_r+0xf64>
   1a550:	d8011c15 	stw	zero,1136(sp)
   1a554:	a8800007 	ldb	r2,0(r21)
   1a558:	da400404 	addi	r9,sp,16
   1a55c:	103d141e 	bne	r2,zero,199b0 <___vfprintf_internal_r+0xe0>
   1a560:	a825883a 	mov	r18,r21
   1a564:	003d2a06 	br	19a10 <___vfprintf_internal_r+0x140>
   1a568:	d9412917 	ldw	r5,1188(sp)
   1a56c:	8809883a 	mov	r4,r17
   1a570:	d9811b04 	addi	r6,sp,1132
   1a574:	001989c0 	call	1989c <__sprint_r>
   1a578:	103e681e 	bne	r2,zero,19f1c <___vfprintf_internal_r+0x64c>
   1a57c:	da011d17 	ldw	r8,1140(sp)
   1a580:	da400404 	addi	r9,sp,16
   1a584:	8080004c 	andi	r2,r16,1
   1a588:	103fb926 	beq	r2,zero,1a470 <___vfprintf_internal_r+0xba0>
   1a58c:	d8c11c17 	ldw	r3,1136(sp)
   1a590:	d9013717 	ldw	r4,1244(sp)
   1a594:	00800044 	movi	r2,1
   1a598:	48800115 	stw	r2,4(r9)
   1a59c:	49000015 	stw	r4,0(r9)
   1a5a0:	4091883a 	add	r8,r8,r2
   1a5a4:	1887883a 	add	r3,r3,r2
   1a5a8:	da011d15 	stw	r8,1140(sp)
   1a5ac:	d8c11c15 	stw	r3,1136(sp)
   1a5b0:	008001c4 	movi	r2,7
   1a5b4:	10ffad0e 	bge	r2,r3,1a46c <___vfprintf_internal_r+0xb9c>
   1a5b8:	d9412917 	ldw	r5,1188(sp)
   1a5bc:	8809883a 	mov	r4,r17
   1a5c0:	d9811b04 	addi	r6,sp,1132
   1a5c4:	001989c0 	call	1989c <__sprint_r>
   1a5c8:	103e541e 	bne	r2,zero,19f1c <___vfprintf_internal_r+0x64c>
   1a5cc:	da400404 	addi	r9,sp,16
   1a5d0:	da011d17 	ldw	r8,1140(sp)
   1a5d4:	003fa606 	br	1a470 <___vfprintf_internal_r+0xba0>
   1a5d8:	18803fcc 	andi	r2,r3,255
   1a5dc:	00c00044 	movi	r3,1
   1a5e0:	10c10126 	beq	r2,r3,1a9e8 <___vfprintf_internal_r+0x1118>
   1a5e4:	00c00084 	movi	r3,2
   1a5e8:	10c0f026 	beq	r2,r3,1a9ac <___vfprintf_internal_r+0x10dc>
   1a5ec:	d8c10dc4 	addi	r3,sp,1079
   1a5f0:	b808d0fa 	srli	r4,r23,3
   1a5f4:	b00a977a 	slli	r5,r22,29
   1a5f8:	b02cd0fa 	srli	r22,r22,3
   1a5fc:	bdc001cc 	andi	r23,r23,7
   1a600:	b8800c04 	addi	r2,r23,48
   1a604:	292eb03a 	or	r23,r5,r4
   1a608:	18800005 	stb	r2,0(r3)
   1a60c:	bd88b03a 	or	r4,r23,r22
   1a610:	1827883a 	mov	r19,r3
   1a614:	18ffffc4 	addi	r3,r3,-1
   1a618:	203ff51e 	bne	r4,zero,1a5f0 <___vfprintf_internal_r+0xd20>
   1a61c:	8100004c 	andi	r4,r16,1
   1a620:	980b883a 	mov	r5,r19
   1a624:	20000726 	beq	r4,zero,1a644 <___vfprintf_internal_r+0xd74>
   1a628:	10803fcc 	andi	r2,r2,255
   1a62c:	1080201c 	xori	r2,r2,128
   1a630:	10bfe004 	addi	r2,r2,-128
   1a634:	01000c04 	movi	r4,48
   1a638:	11000226 	beq	r2,r4,1a644 <___vfprintf_internal_r+0xd74>
   1a63c:	1827883a 	mov	r19,r3
   1a640:	293fffc5 	stb	r4,-1(r5)
   1a644:	d8812717 	ldw	r2,1180(sp)
   1a648:	14c5c83a 	sub	r2,r2,r19
   1a64c:	d8812b15 	stw	r2,1196(sp)
   1a650:	003d8406 	br	19c64 <___vfprintf_internal_r+0x394>
   1a654:	00801944 	movi	r2,101
   1a658:	14807c0e 	bge	r2,r18,1a84c <___vfprintf_internal_r+0xf7c>
   1a65c:	d9013317 	ldw	r4,1228(sp)
   1a660:	d9413417 	ldw	r5,1232(sp)
   1a664:	000d883a 	mov	r6,zero
   1a668:	000f883a 	mov	r7,zero
   1a66c:	d8c13b15 	stw	r3,1260(sp)
   1a670:	da013a15 	stw	r8,1256(sp)
   1a674:	da413c15 	stw	r9,1264(sp)
   1a678:	00214c40 	call	214c4 <__eqdf2>
   1a67c:	d8c13b17 	ldw	r3,1260(sp)
   1a680:	da013a17 	ldw	r8,1256(sp)
   1a684:	da413c17 	ldw	r9,1264(sp)
   1a688:	1001001e 	bne	r2,zero,1aa8c <___vfprintf_internal_r+0x11bc>
   1a68c:	008000f4 	movhi	r2,3
   1a690:	1084e004 	addi	r2,r2,4992
   1a694:	48800015 	stw	r2,0(r9)
   1a698:	00800044 	movi	r2,1
   1a69c:	48800115 	stw	r2,4(r9)
   1a6a0:	4091883a 	add	r8,r8,r2
   1a6a4:	1887883a 	add	r3,r3,r2
   1a6a8:	da011d15 	stw	r8,1140(sp)
   1a6ac:	d8c11c15 	stw	r3,1136(sp)
   1a6b0:	008001c4 	movi	r2,7
   1a6b4:	10c1dd16 	blt	r2,r3,1ae2c <___vfprintf_internal_r+0x155c>
   1a6b8:	4a400204 	addi	r9,r9,8
   1a6bc:	d8812417 	ldw	r2,1168(sp)
   1a6c0:	d8c13217 	ldw	r3,1224(sp)
   1a6c4:	10c00216 	blt	r2,r3,1a6d0 <___vfprintf_internal_r+0xe00>
   1a6c8:	8080004c 	andi	r2,r16,1
   1a6cc:	103f6826 	beq	r2,zero,1a470 <___vfprintf_internal_r+0xba0>
   1a6d0:	d8c11c17 	ldw	r3,1136(sp)
   1a6d4:	d9013717 	ldw	r4,1244(sp)
   1a6d8:	00800044 	movi	r2,1
   1a6dc:	48800115 	stw	r2,4(r9)
   1a6e0:	49000015 	stw	r4,0(r9)
   1a6e4:	4091883a 	add	r8,r8,r2
   1a6e8:	1887883a 	add	r3,r3,r2
   1a6ec:	da011d15 	stw	r8,1140(sp)
   1a6f0:	d8c11c15 	stw	r3,1136(sp)
   1a6f4:	008001c4 	movi	r2,7
   1a6f8:	10c2af16 	blt	r2,r3,1b1b8 <___vfprintf_internal_r+0x18e8>
   1a6fc:	4a400204 	addi	r9,r9,8
   1a700:	d8813217 	ldw	r2,1224(sp)
   1a704:	14bfffc4 	addi	r18,r2,-1
   1a708:	04bf590e 	bge	zero,r18,1a470 <___vfprintf_internal_r+0xba0>
   1a70c:	04c00404 	movi	r19,16
   1a710:	d8c11c17 	ldw	r3,1136(sp)
   1a714:	050000f4 	movhi	r20,3
   1a718:	a504e484 	addi	r20,r20,5010
   1a71c:	9c81630e 	bge	r19,r18,1acac <___vfprintf_internal_r+0x13dc>
   1a720:	058001c4 	movi	r22,7
   1a724:	ddc12917 	ldw	r23,1188(sp)
   1a728:	00000306 	br	1a738 <___vfprintf_internal_r+0xe68>
   1a72c:	4a400204 	addi	r9,r9,8
   1a730:	94bffc04 	addi	r18,r18,-16
   1a734:	9c815d0e 	bge	r19,r18,1acac <___vfprintf_internal_r+0x13dc>
   1a738:	4d000015 	stw	r20,0(r9)
   1a73c:	4cc00115 	stw	r19,4(r9)
   1a740:	42000404 	addi	r8,r8,16
   1a744:	18c00044 	addi	r3,r3,1
   1a748:	da011d15 	stw	r8,1140(sp)
   1a74c:	d8c11c15 	stw	r3,1136(sp)
   1a750:	b0fff60e 	bge	r22,r3,1a72c <___vfprintf_internal_r+0xe5c>
   1a754:	8809883a 	mov	r4,r17
   1a758:	b80b883a 	mov	r5,r23
   1a75c:	d9811b04 	addi	r6,sp,1132
   1a760:	001989c0 	call	1989c <__sprint_r>
   1a764:	103ded1e 	bne	r2,zero,19f1c <___vfprintf_internal_r+0x64c>
   1a768:	da011d17 	ldw	r8,1140(sp)
   1a76c:	d8c11c17 	ldw	r3,1136(sp)
   1a770:	da400404 	addi	r9,sp,16
   1a774:	003fee06 	br	1a730 <___vfprintf_internal_r+0xe60>
   1a778:	d8812e17 	ldw	r2,1208(sp)
   1a77c:	d9012817 	ldw	r4,1184(sp)
   1a780:	112fc83a 	sub	r23,r2,r4
   1a784:	05ff000e 	bge	zero,r23,1a388 <___vfprintf_internal_r+0xab8>
   1a788:	07000404 	movi	fp,16
   1a78c:	050000f4 	movhi	r20,3
   1a790:	a504e484 	addi	r20,r20,5010
   1a794:	e5c01d0e 	bge	fp,r23,1a80c <___vfprintf_internal_r+0xf3c>
   1a798:	dc812a15 	stw	r18,1192(sp)
   1a79c:	058001c4 	movi	r22,7
   1a7a0:	a025883a 	mov	r18,r20
   1a7a4:	8029883a 	mov	r20,r16
   1a7a8:	dc012917 	ldw	r16,1188(sp)
   1a7ac:	00000306 	br	1a7bc <___vfprintf_internal_r+0xeec>
   1a7b0:	bdfffc04 	addi	r23,r23,-16
   1a7b4:	4a400204 	addi	r9,r9,8
   1a7b8:	e5c0110e 	bge	fp,r23,1a800 <___vfprintf_internal_r+0xf30>
   1a7bc:	4c800015 	stw	r18,0(r9)
   1a7c0:	4f000115 	stw	fp,4(r9)
   1a7c4:	42000404 	addi	r8,r8,16
   1a7c8:	18c00044 	addi	r3,r3,1
   1a7cc:	da011d15 	stw	r8,1140(sp)
   1a7d0:	d8c11c15 	stw	r3,1136(sp)
   1a7d4:	b0fff60e 	bge	r22,r3,1a7b0 <___vfprintf_internal_r+0xee0>
   1a7d8:	8809883a 	mov	r4,r17
   1a7dc:	800b883a 	mov	r5,r16
   1a7e0:	d9811b04 	addi	r6,sp,1132
   1a7e4:	001989c0 	call	1989c <__sprint_r>
   1a7e8:	103dcc1e 	bne	r2,zero,19f1c <___vfprintf_internal_r+0x64c>
   1a7ec:	bdfffc04 	addi	r23,r23,-16
   1a7f0:	da011d17 	ldw	r8,1140(sp)
   1a7f4:	d8c11c17 	ldw	r3,1136(sp)
   1a7f8:	da400404 	addi	r9,sp,16
   1a7fc:	e5ffef16 	blt	fp,r23,1a7bc <___vfprintf_internal_r+0xeec>
   1a800:	a021883a 	mov	r16,r20
   1a804:	9029883a 	mov	r20,r18
   1a808:	dc812a17 	ldw	r18,1192(sp)
   1a80c:	4d000015 	stw	r20,0(r9)
   1a810:	4dc00115 	stw	r23,4(r9)
   1a814:	45d1883a 	add	r8,r8,r23
   1a818:	18c00044 	addi	r3,r3,1
   1a81c:	da011d15 	stw	r8,1140(sp)
   1a820:	d8c11c15 	stw	r3,1136(sp)
   1a824:	008001c4 	movi	r2,7
   1a828:	10c11716 	blt	r2,r3,1ac88 <___vfprintf_internal_r+0x13b8>
   1a82c:	4a400204 	addi	r9,r9,8
   1a830:	003ed506 	br	1a388 <___vfprintf_internal_r+0xab8>
   1a834:	d9412917 	ldw	r5,1188(sp)
   1a838:	8809883a 	mov	r4,r17
   1a83c:	d9811b04 	addi	r6,sp,1132
   1a840:	001989c0 	call	1989c <__sprint_r>
   1a844:	103f4226 	beq	r2,zero,1a550 <___vfprintf_internal_r+0xc80>
   1a848:	003db406 	br	19f1c <___vfprintf_internal_r+0x64c>
   1a84c:	d9013217 	ldw	r4,1224(sp)
   1a850:	00800044 	movi	r2,1
   1a854:	4cc00015 	stw	r19,0(r9)
   1a858:	1100e10e 	bge	r2,r4,1abe0 <___vfprintf_internal_r+0x1310>
   1a85c:	00800044 	movi	r2,1
   1a860:	48800115 	stw	r2,4(r9)
   1a864:	4091883a 	add	r8,r8,r2
   1a868:	1887883a 	add	r3,r3,r2
   1a86c:	da011d15 	stw	r8,1140(sp)
   1a870:	d8c11c15 	stw	r3,1136(sp)
   1a874:	008001c4 	movi	r2,7
   1a878:	10c0ed16 	blt	r2,r3,1ac30 <___vfprintf_internal_r+0x1360>
   1a87c:	4a400204 	addi	r9,r9,8
   1a880:	d8813717 	ldw	r2,1244(sp)
   1a884:	48800015 	stw	r2,0(r9)
   1a888:	00800044 	movi	r2,1
   1a88c:	48800115 	stw	r2,4(r9)
   1a890:	4091883a 	add	r8,r8,r2
   1a894:	1887883a 	add	r3,r3,r2
   1a898:	da011d15 	stw	r8,1140(sp)
   1a89c:	d8c11c15 	stw	r3,1136(sp)
   1a8a0:	008001c4 	movi	r2,7
   1a8a4:	10c0eb16 	blt	r2,r3,1ac54 <___vfprintf_internal_r+0x1384>
   1a8a8:	4c800204 	addi	r18,r9,8
   1a8ac:	d9013317 	ldw	r4,1228(sp)
   1a8b0:	d9413417 	ldw	r5,1232(sp)
   1a8b4:	000d883a 	mov	r6,zero
   1a8b8:	000f883a 	mov	r7,zero
   1a8bc:	d8c13b15 	stw	r3,1260(sp)
   1a8c0:	da013a15 	stw	r8,1256(sp)
   1a8c4:	00215200 	call	21520 <__nedf2>
   1a8c8:	d8c13b17 	ldw	r3,1260(sp)
   1a8cc:	da013a17 	ldw	r8,1256(sp)
   1a8d0:	1000a626 	beq	r2,zero,1ab6c <___vfprintf_internal_r+0x129c>
   1a8d4:	d9013217 	ldw	r4,1224(sp)
   1a8d8:	9cc00044 	addi	r19,r19,1
   1a8dc:	94c00015 	stw	r19,0(r18)
   1a8e0:	20bfffc4 	addi	r2,r4,-1
   1a8e4:	90800115 	stw	r2,4(r18)
   1a8e8:	4091883a 	add	r8,r8,r2
   1a8ec:	18c00044 	addi	r3,r3,1
   1a8f0:	da011d15 	stw	r8,1140(sp)
   1a8f4:	d8c11c15 	stw	r3,1136(sp)
   1a8f8:	008001c4 	movi	r2,7
   1a8fc:	10c0c316 	blt	r2,r3,1ac0c <___vfprintf_internal_r+0x133c>
   1a900:	94800204 	addi	r18,r18,8
   1a904:	d9013517 	ldw	r4,1236(sp)
   1a908:	d8811fc4 	addi	r2,sp,1151
   1a90c:	90800015 	stw	r2,0(r18)
   1a910:	91000115 	stw	r4,4(r18)
   1a914:	4111883a 	add	r8,r8,r4
   1a918:	18c00044 	addi	r3,r3,1
   1a91c:	da011d15 	stw	r8,1140(sp)
   1a920:	d8c11c15 	stw	r3,1136(sp)
   1a924:	008001c4 	movi	r2,7
   1a928:	10ff2316 	blt	r2,r3,1a5b8 <___vfprintf_internal_r+0xce8>
   1a92c:	92400204 	addi	r9,r18,8
   1a930:	003ecf06 	br	1a470 <___vfprintf_internal_r+0xba0>
   1a934:	d9412917 	ldw	r5,1188(sp)
   1a938:	8809883a 	mov	r4,r17
   1a93c:	d9811b04 	addi	r6,sp,1132
   1a940:	001989c0 	call	1989c <__sprint_r>
   1a944:	103d751e 	bne	r2,zero,19f1c <___vfprintf_internal_r+0x64c>
   1a948:	da011d17 	ldw	r8,1140(sp)
   1a94c:	d8c11c17 	ldw	r3,1136(sp)
   1a950:	da400404 	addi	r9,sp,16
   1a954:	003eba06 	br	1a440 <___vfprintf_internal_r+0xb70>
   1a958:	d9412917 	ldw	r5,1188(sp)
   1a95c:	8809883a 	mov	r4,r17
   1a960:	d9811b04 	addi	r6,sp,1132
   1a964:	001989c0 	call	1989c <__sprint_r>
   1a968:	103d6c1e 	bne	r2,zero,19f1c <___vfprintf_internal_r+0x64c>
   1a96c:	da011d17 	ldw	r8,1140(sp)
   1a970:	d8c11c17 	ldw	r3,1136(sp)
   1a974:	da400404 	addi	r9,sp,16
   1a978:	003e7306 	br	1a348 <___vfprintf_internal_r+0xa78>
   1a97c:	d9412917 	ldw	r5,1188(sp)
   1a980:	8809883a 	mov	r4,r17
   1a984:	d9811b04 	addi	r6,sp,1132
   1a988:	001989c0 	call	1989c <__sprint_r>
   1a98c:	103d631e 	bne	r2,zero,19f1c <___vfprintf_internal_r+0x64c>
   1a990:	da011d17 	ldw	r8,1140(sp)
   1a994:	d8c11c17 	ldw	r3,1136(sp)
   1a998:	da400404 	addi	r9,sp,16
   1a99c:	003e7706 	br	1a37c <___vfprintf_internal_r+0xaac>
   1a9a0:	d8012b15 	stw	zero,1196(sp)
   1a9a4:	dcc10e04 	addi	r19,sp,1080
   1a9a8:	003cae06 	br	19c64 <___vfprintf_internal_r+0x394>
   1a9ac:	d9413617 	ldw	r5,1240(sp)
   1a9b0:	d8810dc4 	addi	r2,sp,1079
   1a9b4:	b8c003cc 	andi	r3,r23,15
   1a9b8:	b008973a 	slli	r4,r22,28
   1a9bc:	28c7883a 	add	r3,r5,r3
   1a9c0:	b82ed13a 	srli	r23,r23,4
   1a9c4:	18c00003 	ldbu	r3,0(r3)
   1a9c8:	b02cd13a 	srli	r22,r22,4
   1a9cc:	25eeb03a 	or	r23,r4,r23
   1a9d0:	10c00005 	stb	r3,0(r2)
   1a9d4:	bd86b03a 	or	r3,r23,r22
   1a9d8:	1027883a 	mov	r19,r2
   1a9dc:	10bfffc4 	addi	r2,r2,-1
   1a9e0:	183ff41e 	bne	r3,zero,1a9b4 <___vfprintf_internal_r+0x10e4>
   1a9e4:	003f1706 	br	1a644 <___vfprintf_internal_r+0xd74>
   1a9e8:	b0025826 	beq	r22,zero,1b34c <___vfprintf_internal_r+0x1a7c>
   1a9ec:	b807883a 	mov	r3,r23
   1a9f0:	d8810dc4 	addi	r2,sp,1079
   1a9f4:	882f883a 	mov	r23,r17
   1a9f8:	04c00244 	movi	r19,9
   1a9fc:	8023883a 	mov	r17,r16
   1aa00:	da412815 	stw	r9,1184(sp)
   1aa04:	1821883a 	mov	r16,r3
   1aa08:	8009883a 	mov	r4,r16
   1aa0c:	b00b883a 	mov	r5,r22
   1aa10:	01800284 	movi	r6,10
   1aa14:	000f883a 	mov	r7,zero
   1aa18:	1029883a 	mov	r20,r2
   1aa1c:	0020f380 	call	20f38 <__umoddi3>
   1aa20:	10800c04 	addi	r2,r2,48
   1aa24:	8009883a 	mov	r4,r16
   1aa28:	b00b883a 	mov	r5,r22
   1aa2c:	a0800005 	stb	r2,0(r20)
   1aa30:	01800284 	movi	r6,10
   1aa34:	000f883a 	mov	r7,zero
   1aa38:	00209700 	call	20970 <__udivdi3>
   1aa3c:	1021883a 	mov	r16,r2
   1aa40:	182d883a 	mov	r22,r3
   1aa44:	a0bfffc4 	addi	r2,r20,-1
   1aa48:	183fef1e 	bne	r3,zero,1aa08 <___vfprintf_internal_r+0x1138>
   1aa4c:	9c3fee36 	bltu	r19,r16,1aa08 <___vfprintf_internal_r+0x1138>
   1aa50:	da412817 	ldw	r9,1184(sp)
   1aa54:	8005883a 	mov	r2,r16
   1aa58:	8821883a 	mov	r16,r17
   1aa5c:	b823883a 	mov	r17,r23
   1aa60:	102f883a 	mov	r23,r2
   1aa64:	d8812717 	ldw	r2,1180(sp)
   1aa68:	a4ffffc4 	addi	r19,r20,-1
   1aa6c:	bdc00c04 	addi	r23,r23,48
   1aa70:	14c5c83a 	sub	r2,r2,r19
   1aa74:	a5ffffc5 	stb	r23,-1(r20)
   1aa78:	d8812b15 	stw	r2,1196(sp)
   1aa7c:	003c7906 	br	19c64 <___vfprintf_internal_r+0x394>
   1aa80:	00c00044 	movi	r3,1
   1aa84:	bd84b03a 	or	r2,r23,r22
   1aa88:	003c6806 	br	19c2c <___vfprintf_internal_r+0x35c>
   1aa8c:	dc812417 	ldw	r18,1168(sp)
   1aa90:	0480ee0e 	bge	zero,r18,1ae4c <___vfprintf_internal_r+0x157c>
   1aa94:	d9013217 	ldw	r4,1224(sp)
   1aa98:	4cc00015 	stw	r19,0(r9)
   1aa9c:	9100c616 	blt	r18,r4,1adb8 <___vfprintf_internal_r+0x14e8>
   1aaa0:	49000115 	stw	r4,4(r9)
   1aaa4:	4111883a 	add	r8,r8,r4
   1aaa8:	18c00044 	addi	r3,r3,1
   1aaac:	da011d15 	stw	r8,1140(sp)
   1aab0:	d8c11c15 	stw	r3,1136(sp)
   1aab4:	008001c4 	movi	r2,7
   1aab8:	10c20916 	blt	r2,r3,1b2e0 <___vfprintf_internal_r+0x1a10>
   1aabc:	4a400204 	addi	r9,r9,8
   1aac0:	d8813217 	ldw	r2,1224(sp)
   1aac4:	90a5c83a 	sub	r18,r18,r2
   1aac8:	04beae0e 	bge	zero,r18,1a584 <___vfprintf_internal_r+0xcb4>
   1aacc:	04c00404 	movi	r19,16
   1aad0:	d8c11c17 	ldw	r3,1136(sp)
   1aad4:	050000f4 	movhi	r20,3
   1aad8:	a504e484 	addi	r20,r20,5010
   1aadc:	9c81be0e 	bge	r19,r18,1b1d8 <___vfprintf_internal_r+0x1908>
   1aae0:	058001c4 	movi	r22,7
   1aae4:	ddc12917 	ldw	r23,1188(sp)
   1aae8:	00000306 	br	1aaf8 <___vfprintf_internal_r+0x1228>
   1aaec:	4a400204 	addi	r9,r9,8
   1aaf0:	94bffc04 	addi	r18,r18,-16
   1aaf4:	9c81b80e 	bge	r19,r18,1b1d8 <___vfprintf_internal_r+0x1908>
   1aaf8:	4d000015 	stw	r20,0(r9)
   1aafc:	4cc00115 	stw	r19,4(r9)
   1ab00:	42000404 	addi	r8,r8,16
   1ab04:	18c00044 	addi	r3,r3,1
   1ab08:	da011d15 	stw	r8,1140(sp)
   1ab0c:	d8c11c15 	stw	r3,1136(sp)
   1ab10:	b0fff60e 	bge	r22,r3,1aaec <___vfprintf_internal_r+0x121c>
   1ab14:	8809883a 	mov	r4,r17
   1ab18:	b80b883a 	mov	r5,r23
   1ab1c:	d9811b04 	addi	r6,sp,1132
   1ab20:	001989c0 	call	1989c <__sprint_r>
   1ab24:	103cfd1e 	bne	r2,zero,19f1c <___vfprintf_internal_r+0x64c>
   1ab28:	da011d17 	ldw	r8,1140(sp)
   1ab2c:	d8c11c17 	ldw	r3,1136(sp)
   1ab30:	da400404 	addi	r9,sp,16
   1ab34:	003fee06 	br	1aaf0 <___vfprintf_internal_r+0x1220>
   1ab38:	d9412917 	ldw	r5,1188(sp)
   1ab3c:	8809883a 	mov	r4,r17
   1ab40:	d9811b04 	addi	r6,sp,1132
   1ab44:	001989c0 	call	1989c <__sprint_r>
   1ab48:	103cf41e 	bne	r2,zero,19f1c <___vfprintf_internal_r+0x64c>
   1ab4c:	da011d17 	ldw	r8,1140(sp)
   1ab50:	d8c11c17 	ldw	r3,1136(sp)
   1ab54:	da400404 	addi	r9,sp,16
   1ab58:	003dee06 	br	1a314 <___vfprintf_internal_r+0xa44>
   1ab5c:	00c00084 	movi	r3,2
   1ab60:	bd84b03a 	or	r2,r23,r22
   1ab64:	d8012585 	stb	zero,1174(sp)
   1ab68:	003c3006 	br	19c2c <___vfprintf_internal_r+0x35c>
   1ab6c:	d8813217 	ldw	r2,1224(sp)
   1ab70:	14ffffc4 	addi	r19,r2,-1
   1ab74:	04ff630e 	bge	zero,r19,1a904 <___vfprintf_internal_r+0x1034>
   1ab78:	05800404 	movi	r22,16
   1ab7c:	050000f4 	movhi	r20,3
   1ab80:	a504e484 	addi	r20,r20,5010
   1ab84:	b4c03c0e 	bge	r22,r19,1ac78 <___vfprintf_internal_r+0x13a8>
   1ab88:	05c001c4 	movi	r23,7
   1ab8c:	df012917 	ldw	fp,1188(sp)
   1ab90:	00000306 	br	1aba0 <___vfprintf_internal_r+0x12d0>
   1ab94:	94800204 	addi	r18,r18,8
   1ab98:	9cfffc04 	addi	r19,r19,-16
   1ab9c:	b4c0360e 	bge	r22,r19,1ac78 <___vfprintf_internal_r+0x13a8>
   1aba0:	95000015 	stw	r20,0(r18)
   1aba4:	95800115 	stw	r22,4(r18)
   1aba8:	42000404 	addi	r8,r8,16
   1abac:	18c00044 	addi	r3,r3,1
   1abb0:	da011d15 	stw	r8,1140(sp)
   1abb4:	d8c11c15 	stw	r3,1136(sp)
   1abb8:	b8fff60e 	bge	r23,r3,1ab94 <___vfprintf_internal_r+0x12c4>
   1abbc:	8809883a 	mov	r4,r17
   1abc0:	e00b883a 	mov	r5,fp
   1abc4:	d9811b04 	addi	r6,sp,1132
   1abc8:	001989c0 	call	1989c <__sprint_r>
   1abcc:	103cd31e 	bne	r2,zero,19f1c <___vfprintf_internal_r+0x64c>
   1abd0:	da011d17 	ldw	r8,1140(sp)
   1abd4:	d8c11c17 	ldw	r3,1136(sp)
   1abd8:	dc800404 	addi	r18,sp,16
   1abdc:	003fee06 	br	1ab98 <___vfprintf_internal_r+0x12c8>
   1abe0:	8088703a 	and	r4,r16,r2
   1abe4:	203f1d1e 	bne	r4,zero,1a85c <___vfprintf_internal_r+0xf8c>
   1abe8:	48800115 	stw	r2,4(r9)
   1abec:	42000044 	addi	r8,r8,1
   1abf0:	18c00044 	addi	r3,r3,1
   1abf4:	da011d15 	stw	r8,1140(sp)
   1abf8:	d8c11c15 	stw	r3,1136(sp)
   1abfc:	008001c4 	movi	r2,7
   1ac00:	10c00216 	blt	r2,r3,1ac0c <___vfprintf_internal_r+0x133c>
   1ac04:	4c800204 	addi	r18,r9,8
   1ac08:	003f3e06 	br	1a904 <___vfprintf_internal_r+0x1034>
   1ac0c:	d9412917 	ldw	r5,1188(sp)
   1ac10:	8809883a 	mov	r4,r17
   1ac14:	d9811b04 	addi	r6,sp,1132
   1ac18:	001989c0 	call	1989c <__sprint_r>
   1ac1c:	103cbf1e 	bne	r2,zero,19f1c <___vfprintf_internal_r+0x64c>
   1ac20:	dc800404 	addi	r18,sp,16
   1ac24:	da011d17 	ldw	r8,1140(sp)
   1ac28:	d8c11c17 	ldw	r3,1136(sp)
   1ac2c:	003f3506 	br	1a904 <___vfprintf_internal_r+0x1034>
   1ac30:	d9412917 	ldw	r5,1188(sp)
   1ac34:	8809883a 	mov	r4,r17
   1ac38:	d9811b04 	addi	r6,sp,1132
   1ac3c:	001989c0 	call	1989c <__sprint_r>
   1ac40:	103cb61e 	bne	r2,zero,19f1c <___vfprintf_internal_r+0x64c>
   1ac44:	da011d17 	ldw	r8,1140(sp)
   1ac48:	d8c11c17 	ldw	r3,1136(sp)
   1ac4c:	da400404 	addi	r9,sp,16
   1ac50:	003f0b06 	br	1a880 <___vfprintf_internal_r+0xfb0>
   1ac54:	d9412917 	ldw	r5,1188(sp)
   1ac58:	8809883a 	mov	r4,r17
   1ac5c:	d9811b04 	addi	r6,sp,1132
   1ac60:	001989c0 	call	1989c <__sprint_r>
   1ac64:	103cad1e 	bne	r2,zero,19f1c <___vfprintf_internal_r+0x64c>
   1ac68:	da011d17 	ldw	r8,1140(sp)
   1ac6c:	d8c11c17 	ldw	r3,1136(sp)
   1ac70:	dc800404 	addi	r18,sp,16
   1ac74:	003f0d06 	br	1a8ac <___vfprintf_internal_r+0xfdc>
   1ac78:	95000015 	stw	r20,0(r18)
   1ac7c:	94c00115 	stw	r19,4(r18)
   1ac80:	44d1883a 	add	r8,r8,r19
   1ac84:	003f1906 	br	1a8ec <___vfprintf_internal_r+0x101c>
   1ac88:	d9412917 	ldw	r5,1188(sp)
   1ac8c:	8809883a 	mov	r4,r17
   1ac90:	d9811b04 	addi	r6,sp,1132
   1ac94:	001989c0 	call	1989c <__sprint_r>
   1ac98:	103ca01e 	bne	r2,zero,19f1c <___vfprintf_internal_r+0x64c>
   1ac9c:	da011d17 	ldw	r8,1140(sp)
   1aca0:	d8c11c17 	ldw	r3,1136(sp)
   1aca4:	da400404 	addi	r9,sp,16
   1aca8:	003db706 	br	1a388 <___vfprintf_internal_r+0xab8>
   1acac:	4d000015 	stw	r20,0(r9)
   1acb0:	4c800115 	stw	r18,4(r9)
   1acb4:	4491883a 	add	r8,r8,r18
   1acb8:	003de706 	br	1a458 <___vfprintf_internal_r+0xb88>
   1acbc:	8080100c 	andi	r2,r16,64
   1acc0:	10010226 	beq	r2,zero,1b0cc <___vfprintf_internal_r+0x17fc>
   1acc4:	d8812d17 	ldw	r2,1204(sp)
   1acc8:	002d883a 	mov	r22,zero
   1accc:	00c00044 	movi	r3,1
   1acd0:	15c0000b 	ldhu	r23,0(r2)
   1acd4:	10800104 	addi	r2,r2,4
   1acd8:	d8812d15 	stw	r2,1204(sp)
   1acdc:	d8012585 	stb	zero,1174(sp)
   1ace0:	b805883a 	mov	r2,r23
   1ace4:	003bd106 	br	19c2c <___vfprintf_internal_r+0x35c>
   1ace8:	d9012d17 	ldw	r4,1204(sp)
   1acec:	25800017 	ldw	r22,0(r4)
   1acf0:	25000117 	ldw	r20,4(r4)
   1acf4:	21000204 	addi	r4,r4,8
   1acf8:	d9012d15 	stw	r4,1204(sp)
   1acfc:	dd813315 	stw	r22,1228(sp)
   1ad00:	dd013415 	stw	r20,1232(sp)
   1ad04:	003d2b06 	br	1a1b4 <___vfprintf_internal_r+0x8e4>
   1ad08:	8080100c 	andi	r2,r16,64
   1ad0c:	1000fe26 	beq	r2,zero,1b108 <___vfprintf_internal_r+0x1838>
   1ad10:	d9012d17 	ldw	r4,1204(sp)
   1ad14:	002d883a 	mov	r22,zero
   1ad18:	0007883a 	mov	r3,zero
   1ad1c:	25c0000b 	ldhu	r23,0(r4)
   1ad20:	21000104 	addi	r4,r4,4
   1ad24:	d9012d15 	stw	r4,1204(sp)
   1ad28:	b805883a 	mov	r2,r23
   1ad2c:	d8012585 	stb	zero,1174(sp)
   1ad30:	003bbe06 	br	19c2c <___vfprintf_internal_r+0x35c>
   1ad34:	8080100c 	andi	r2,r16,64
   1ad38:	1000ed26 	beq	r2,zero,1b0f0 <___vfprintf_internal_r+0x1820>
   1ad3c:	d9012d17 	ldw	r4,1204(sp)
   1ad40:	002d883a 	mov	r22,zero
   1ad44:	25c0000b 	ldhu	r23,0(r4)
   1ad48:	21000104 	addi	r4,r4,4
   1ad4c:	d9012d15 	stw	r4,1204(sp)
   1ad50:	003cd206 	br	1a09c <___vfprintf_internal_r+0x7cc>
   1ad54:	00c00084 	movi	r3,2
   1ad58:	d8012585 	stb	zero,1174(sp)
   1ad5c:	003bb306 	br	19c2c <___vfprintf_internal_r+0x35c>
   1ad60:	8080040c 	andi	r2,r16,16
   1ad64:	1000f11e 	bne	r2,zero,1b12c <___vfprintf_internal_r+0x185c>
   1ad68:	8400100c 	andi	r16,r16,64
   1ad6c:	80015526 	beq	r16,zero,1b2c4 <___vfprintf_internal_r+0x19f4>
   1ad70:	da012d17 	ldw	r8,1204(sp)
   1ad74:	d8c12c17 	ldw	r3,1200(sp)
   1ad78:	40800017 	ldw	r2,0(r8)
   1ad7c:	42000104 	addi	r8,r8,4
   1ad80:	da012d15 	stw	r8,1204(sp)
   1ad84:	10c0000d 	sth	r3,0(r2)
   1ad88:	003b0706 	br	199a8 <___vfprintf_internal_r+0xd8>
   1ad8c:	8080100c 	andi	r2,r16,64
   1ad90:	1000c726 	beq	r2,zero,1b0b0 <___vfprintf_internal_r+0x17e0>
   1ad94:	da012d17 	ldw	r8,1204(sp)
   1ad98:	45c0000f 	ldh	r23,0(r8)
   1ad9c:	42000104 	addi	r8,r8,4
   1ada0:	da012d15 	stw	r8,1204(sp)
   1ada4:	b82dd7fa 	srai	r22,r23,31
   1ada8:	b005883a 	mov	r2,r22
   1adac:	003c1006 	br	19df0 <___vfprintf_internal_r+0x520>
   1adb0:	ac800007 	ldb	r18,0(r21)
   1adb4:	003b2406 	br	19a48 <___vfprintf_internal_r+0x178>
   1adb8:	4c800115 	stw	r18,4(r9)
   1adbc:	9211883a 	add	r8,r18,r8
   1adc0:	18c00044 	addi	r3,r3,1
   1adc4:	da011d15 	stw	r8,1140(sp)
   1adc8:	d8c11c15 	stw	r3,1136(sp)
   1adcc:	008001c4 	movi	r2,7
   1add0:	10c15416 	blt	r2,r3,1b324 <___vfprintf_internal_r+0x1a54>
   1add4:	4a400204 	addi	r9,r9,8
   1add8:	d8813717 	ldw	r2,1244(sp)
   1addc:	9ca7883a 	add	r19,r19,r18
   1ade0:	48800015 	stw	r2,0(r9)
   1ade4:	00800044 	movi	r2,1
   1ade8:	48800115 	stw	r2,4(r9)
   1adec:	4091883a 	add	r8,r8,r2
   1adf0:	1887883a 	add	r3,r3,r2
   1adf4:	da011d15 	stw	r8,1140(sp)
   1adf8:	d8c11c15 	stw	r3,1136(sp)
   1adfc:	008001c4 	movi	r2,7
   1ae00:	10c14016 	blt	r2,r3,1b304 <___vfprintf_internal_r+0x1a34>
   1ae04:	4a400204 	addi	r9,r9,8
   1ae08:	d9013217 	ldw	r4,1224(sp)
   1ae0c:	da011d17 	ldw	r8,1140(sp)
   1ae10:	d8c11c17 	ldw	r3,1136(sp)
   1ae14:	24a5c83a 	sub	r18,r4,r18
   1ae18:	4cc00015 	stw	r19,0(r9)
   1ae1c:	003fa406 	br	1acb0 <___vfprintf_internal_r+0x13e0>
   1ae20:	04c000f4 	movhi	r19,3
   1ae24:	9cc4d104 	addi	r19,r19,4932
   1ae28:	003cf406 	br	1a1fc <___vfprintf_internal_r+0x92c>
   1ae2c:	d9412917 	ldw	r5,1188(sp)
   1ae30:	8809883a 	mov	r4,r17
   1ae34:	d9811b04 	addi	r6,sp,1132
   1ae38:	001989c0 	call	1989c <__sprint_r>
   1ae3c:	103c371e 	bne	r2,zero,19f1c <___vfprintf_internal_r+0x64c>
   1ae40:	da011d17 	ldw	r8,1140(sp)
   1ae44:	da400404 	addi	r9,sp,16
   1ae48:	003e1c06 	br	1a6bc <___vfprintf_internal_r+0xdec>
   1ae4c:	008000f4 	movhi	r2,3
   1ae50:	1084e004 	addi	r2,r2,4992
   1ae54:	48800015 	stw	r2,0(r9)
   1ae58:	00800044 	movi	r2,1
   1ae5c:	48800115 	stw	r2,4(r9)
   1ae60:	4091883a 	add	r8,r8,r2
   1ae64:	1887883a 	add	r3,r3,r2
   1ae68:	da011d15 	stw	r8,1140(sp)
   1ae6c:	d8c11c15 	stw	r3,1136(sp)
   1ae70:	008001c4 	movi	r2,7
   1ae74:	10c0c316 	blt	r2,r3,1b184 <___vfprintf_internal_r+0x18b4>
   1ae78:	4a400204 	addi	r9,r9,8
   1ae7c:	9000041e 	bne	r18,zero,1ae90 <___vfprintf_internal_r+0x15c0>
   1ae80:	d8c13217 	ldw	r3,1224(sp)
   1ae84:	1800021e 	bne	r3,zero,1ae90 <___vfprintf_internal_r+0x15c0>
   1ae88:	8080004c 	andi	r2,r16,1
   1ae8c:	103d7826 	beq	r2,zero,1a470 <___vfprintf_internal_r+0xba0>
   1ae90:	d8c11c17 	ldw	r3,1136(sp)
   1ae94:	d9013717 	ldw	r4,1244(sp)
   1ae98:	00800044 	movi	r2,1
   1ae9c:	48800115 	stw	r2,4(r9)
   1aea0:	49000015 	stw	r4,0(r9)
   1aea4:	4091883a 	add	r8,r8,r2
   1aea8:	1887883a 	add	r3,r3,r2
   1aeac:	da011d15 	stw	r8,1140(sp)
   1aeb0:	d8c11c15 	stw	r3,1136(sp)
   1aeb4:	008001c4 	movi	r2,7
   1aeb8:	10c12e16 	blt	r2,r3,1b374 <___vfprintf_internal_r+0x1aa4>
   1aebc:	4a400204 	addi	r9,r9,8
   1aec0:	04a5c83a 	sub	r18,zero,r18
   1aec4:	0480de0e 	bge	zero,r18,1b240 <___vfprintf_internal_r+0x1970>
   1aec8:	05800404 	movi	r22,16
   1aecc:	050000f4 	movhi	r20,3
   1aed0:	a504e484 	addi	r20,r20,5010
   1aed4:	b480e20e 	bge	r22,r18,1b260 <___vfprintf_internal_r+0x1990>
   1aed8:	05c001c4 	movi	r23,7
   1aedc:	df012917 	ldw	fp,1188(sp)
   1aee0:	00000306 	br	1aef0 <___vfprintf_internal_r+0x1620>
   1aee4:	4a400204 	addi	r9,r9,8
   1aee8:	94bffc04 	addi	r18,r18,-16
   1aeec:	b480dc0e 	bge	r22,r18,1b260 <___vfprintf_internal_r+0x1990>
   1aef0:	4d000015 	stw	r20,0(r9)
   1aef4:	4d800115 	stw	r22,4(r9)
   1aef8:	42000404 	addi	r8,r8,16
   1aefc:	18c00044 	addi	r3,r3,1
   1af00:	da011d15 	stw	r8,1140(sp)
   1af04:	d8c11c15 	stw	r3,1136(sp)
   1af08:	b8fff60e 	bge	r23,r3,1aee4 <___vfprintf_internal_r+0x1614>
   1af0c:	8809883a 	mov	r4,r17
   1af10:	e00b883a 	mov	r5,fp
   1af14:	d9811b04 	addi	r6,sp,1132
   1af18:	001989c0 	call	1989c <__sprint_r>
   1af1c:	103bff1e 	bne	r2,zero,19f1c <___vfprintf_internal_r+0x64c>
   1af20:	da011d17 	ldw	r8,1140(sp)
   1af24:	d8c11c17 	ldw	r3,1136(sp)
   1af28:	da400404 	addi	r9,sp,16
   1af2c:	003fee06 	br	1aee8 <___vfprintf_internal_r+0x1618>
   1af30:	da413c15 	stw	r9,1264(sp)
   1af34:	00203200 	call	20320 <__isnand>
   1af38:	da413c17 	ldw	r9,1264(sp)
   1af3c:	1000851e 	bne	r2,zero,1b154 <___vfprintf_internal_r+0x1884>
   1af40:	00bfffc4 	movi	r2,-1
   1af44:	e0817626 	beq	fp,r2,1b520 <___vfprintf_internal_r+0x1c50>
   1af48:	008019c4 	movi	r2,103
   1af4c:	90817126 	beq	r18,r2,1b514 <___vfprintf_internal_r+0x1c44>
   1af50:	008011c4 	movi	r2,71
   1af54:	90816f26 	beq	r18,r2,1b514 <___vfprintf_internal_r+0x1c44>
   1af58:	82004014 	ori	r8,r16,256
   1af5c:	da012a15 	stw	r8,1192(sp)
   1af60:	a0017116 	blt	r20,zero,1b528 <___vfprintf_internal_r+0x1c58>
   1af64:	d8012f05 	stb	zero,1212(sp)
   1af68:	00801984 	movi	r2,102
   1af6c:	90811226 	beq	r18,r2,1b3b8 <___vfprintf_internal_r+0x1ae8>
   1af70:	00801184 	movi	r2,70
   1af74:	90811026 	beq	r18,r2,1b3b8 <___vfprintf_internal_r+0x1ae8>
   1af78:	00801944 	movi	r2,101
   1af7c:	90819b26 	beq	r18,r2,1b5ec <___vfprintf_internal_r+0x1d1c>
   1af80:	00801144 	movi	r2,69
   1af84:	90819926 	beq	r18,r2,1b5ec <___vfprintf_internal_r+0x1d1c>
   1af88:	e02f883a 	mov	r23,fp
   1af8c:	d8812404 	addi	r2,sp,1168
   1af90:	d8800115 	stw	r2,4(sp)
   1af94:	d8812304 	addi	r2,sp,1164
   1af98:	d8800215 	stw	r2,8(sp)
   1af9c:	d8812204 	addi	r2,sp,1160
   1afa0:	ddc00015 	stw	r23,0(sp)
   1afa4:	d8800315 	stw	r2,12(sp)
   1afa8:	8809883a 	mov	r4,r17
   1afac:	b00b883a 	mov	r5,r22
   1afb0:	a00d883a 	mov	r6,r20
   1afb4:	01c00084 	movi	r7,2
   1afb8:	da413c15 	stw	r9,1264(sp)
   1afbc:	001bbc00 	call	1bbc0 <_dtoa_r>
   1afc0:	1027883a 	mov	r19,r2
   1afc4:	008019c4 	movi	r2,103
   1afc8:	da413c17 	ldw	r9,1264(sp)
   1afcc:	90818c1e 	bne	r18,r2,1b600 <___vfprintf_internal_r+0x1d30>
   1afd0:	8080004c 	andi	r2,r16,1
   1afd4:	10017926 	beq	r2,zero,1b5bc <___vfprintf_internal_r+0x1cec>
   1afd8:	00801184 	movi	r2,70
   1afdc:	9dc7883a 	add	r3,r19,r23
   1afe0:	90810626 	beq	r18,r2,1b3fc <___vfprintf_internal_r+0x1b2c>
   1afe4:	b009883a 	mov	r4,r22
   1afe8:	a00b883a 	mov	r5,r20
   1afec:	000d883a 	mov	r6,zero
   1aff0:	000f883a 	mov	r7,zero
   1aff4:	d8c13b15 	stw	r3,1260(sp)
   1aff8:	da413c15 	stw	r9,1264(sp)
   1affc:	00214c40 	call	214c4 <__eqdf2>
   1b000:	d8c13b17 	ldw	r3,1260(sp)
   1b004:	da413c17 	ldw	r9,1264(sp)
   1b008:	10000726 	beq	r2,zero,1b028 <___vfprintf_internal_r+0x1758>
   1b00c:	d8812217 	ldw	r2,1160(sp)
   1b010:	10c1962e 	bgeu	r2,r3,1b66c <___vfprintf_internal_r+0x1d9c>
   1b014:	01000c04 	movi	r4,48
   1b018:	11000005 	stb	r4,0(r2)
   1b01c:	10800044 	addi	r2,r2,1
   1b020:	d8812215 	stw	r2,1160(sp)
   1b024:	10fffc1e 	bne	r2,r3,1b018 <___vfprintf_internal_r+0x1748>
   1b028:	1cc7c83a 	sub	r3,r3,r19
   1b02c:	d8c13215 	stw	r3,1224(sp)
   1b030:	008019c4 	movi	r2,103
   1b034:	90810626 	beq	r18,r2,1b450 <___vfprintf_internal_r+0x1b80>
   1b038:	008011c4 	movi	r2,71
   1b03c:	90810426 	beq	r18,r2,1b450 <___vfprintf_internal_r+0x1b80>
   1b040:	00801984 	movi	r2,102
   1b044:	90819a1e 	bne	r18,r2,1b6b0 <___vfprintf_internal_r+0x1de0>
   1b048:	d8812417 	ldw	r2,1168(sp)
   1b04c:	d8812b15 	stw	r2,1196(sp)
   1b050:	0081880e 	bge	zero,r2,1b674 <___vfprintf_internal_r+0x1da4>
   1b054:	e000021e 	bne	fp,zero,1b060 <___vfprintf_internal_r+0x1790>
   1b058:	8400004c 	andi	r16,r16,1
   1b05c:	80000426 	beq	r16,zero,1b070 <___vfprintf_internal_r+0x17a0>
   1b060:	d8812b17 	ldw	r2,1196(sp)
   1b064:	e2000044 	addi	r8,fp,1
   1b068:	1205883a 	add	r2,r2,r8
   1b06c:	d8812b15 	stw	r2,1196(sp)
   1b070:	d8812815 	stw	r2,1184(sp)
   1b074:	10011716 	blt	r2,zero,1b4d4 <___vfprintf_internal_r+0x1c04>
   1b078:	ddc12f07 	ldb	r23,1212(sp)
   1b07c:	b800ca26 	beq	r23,zero,1b3a8 <___vfprintf_internal_r+0x1ad8>
   1b080:	00800b44 	movi	r2,45
   1b084:	d8812585 	stb	r2,1174(sp)
   1b088:	dc012a17 	ldw	r16,1192(sp)
   1b08c:	d8013115 	stw	zero,1220(sp)
   1b090:	003afe06 	br	19c8c <___vfprintf_internal_r+0x3bc>
   1b094:	d8812b17 	ldw	r2,1196(sp)
   1b098:	d8812815 	stw	r2,1184(sp)
   1b09c:	10005e16 	blt	r2,zero,1b218 <___vfprintf_internal_r+0x1948>
   1b0a0:	d8812583 	ldbu	r2,1174(sp)
   1b0a4:	ddc12d15 	stw	r23,1204(sp)
   1b0a8:	d8013115 	stw	zero,1220(sp)
   1b0ac:	003af306 	br	19c7c <___vfprintf_internal_r+0x3ac>
   1b0b0:	d8812d17 	ldw	r2,1204(sp)
   1b0b4:	15c00017 	ldw	r23,0(r2)
   1b0b8:	10800104 	addi	r2,r2,4
   1b0bc:	d8812d15 	stw	r2,1204(sp)
   1b0c0:	b82dd7fa 	srai	r22,r23,31
   1b0c4:	b005883a 	mov	r2,r22
   1b0c8:	003b4906 	br	19df0 <___vfprintf_internal_r+0x520>
   1b0cc:	d8c12d17 	ldw	r3,1204(sp)
   1b0d0:	002d883a 	mov	r22,zero
   1b0d4:	1dc00017 	ldw	r23,0(r3)
   1b0d8:	18c00104 	addi	r3,r3,4
   1b0dc:	d8c12d15 	stw	r3,1204(sp)
   1b0e0:	b805883a 	mov	r2,r23
   1b0e4:	00c00044 	movi	r3,1
   1b0e8:	d8012585 	stb	zero,1174(sp)
   1b0ec:	003acf06 	br	19c2c <___vfprintf_internal_r+0x35c>
   1b0f0:	da012d17 	ldw	r8,1204(sp)
   1b0f4:	002d883a 	mov	r22,zero
   1b0f8:	45c00017 	ldw	r23,0(r8)
   1b0fc:	42000104 	addi	r8,r8,4
   1b100:	da012d15 	stw	r8,1204(sp)
   1b104:	003be506 	br	1a09c <___vfprintf_internal_r+0x7cc>
   1b108:	da012d17 	ldw	r8,1204(sp)
   1b10c:	002d883a 	mov	r22,zero
   1b110:	0007883a 	mov	r3,zero
   1b114:	45c00017 	ldw	r23,0(r8)
   1b118:	42000104 	addi	r8,r8,4
   1b11c:	da012d15 	stw	r8,1204(sp)
   1b120:	b805883a 	mov	r2,r23
   1b124:	d8012585 	stb	zero,1174(sp)
   1b128:	003ac006 	br	19c2c <___vfprintf_internal_r+0x35c>
   1b12c:	d8c12d17 	ldw	r3,1204(sp)
   1b130:	d9012c17 	ldw	r4,1200(sp)
   1b134:	18800017 	ldw	r2,0(r3)
   1b138:	18c00104 	addi	r3,r3,4
   1b13c:	d8c12d15 	stw	r3,1204(sp)
   1b140:	11000015 	stw	r4,0(r2)
   1b144:	003a1806 	br	199a8 <___vfprintf_internal_r+0xd8>
   1b148:	073fffc4 	movi	fp,-1
   1b14c:	202b883a 	mov	r21,r4
   1b150:	003a3e06 	br	19a4c <___vfprintf_internal_r+0x17c>
   1b154:	008011c4 	movi	r2,71
   1b158:	14809016 	blt	r2,r18,1b39c <___vfprintf_internal_r+0x1acc>
   1b15c:	04c000f4 	movhi	r19,3
   1b160:	9cc4d204 	addi	r19,r19,4936
   1b164:	00c000c4 	movi	r3,3
   1b168:	00bfdfc4 	movi	r2,-129
   1b16c:	80a0703a 	and	r16,r16,r2
   1b170:	d8c12815 	stw	r3,1184(sp)
   1b174:	d8812583 	ldbu	r2,1174(sp)
   1b178:	d8c12b15 	stw	r3,1196(sp)
   1b17c:	d8013115 	stw	zero,1220(sp)
   1b180:	003abe06 	br	19c7c <___vfprintf_internal_r+0x3ac>
   1b184:	d9412917 	ldw	r5,1188(sp)
   1b188:	8809883a 	mov	r4,r17
   1b18c:	d9811b04 	addi	r6,sp,1132
   1b190:	001989c0 	call	1989c <__sprint_r>
   1b194:	103b611e 	bne	r2,zero,19f1c <___vfprintf_internal_r+0x64c>
   1b198:	dc812417 	ldw	r18,1168(sp)
   1b19c:	da011d17 	ldw	r8,1140(sp)
   1b1a0:	da400404 	addi	r9,sp,16
   1b1a4:	003f3506 	br	1ae7c <___vfprintf_internal_r+0x15ac>
   1b1a8:	ad400044 	addi	r21,r21,1
   1b1ac:	84000814 	ori	r16,r16,32
   1b1b0:	14800047 	ldb	r18,1(r2)
   1b1b4:	003a2406 	br	19a48 <___vfprintf_internal_r+0x178>
   1b1b8:	d9412917 	ldw	r5,1188(sp)
   1b1bc:	8809883a 	mov	r4,r17
   1b1c0:	d9811b04 	addi	r6,sp,1132
   1b1c4:	001989c0 	call	1989c <__sprint_r>
   1b1c8:	103b541e 	bne	r2,zero,19f1c <___vfprintf_internal_r+0x64c>
   1b1cc:	da011d17 	ldw	r8,1140(sp)
   1b1d0:	da400404 	addi	r9,sp,16
   1b1d4:	003d4a06 	br	1a700 <___vfprintf_internal_r+0xe30>
   1b1d8:	4d000015 	stw	r20,0(r9)
   1b1dc:	4c800115 	stw	r18,4(r9)
   1b1e0:	4491883a 	add	r8,r8,r18
   1b1e4:	18c00044 	addi	r3,r3,1
   1b1e8:	da011d15 	stw	r8,1140(sp)
   1b1ec:	d8c11c15 	stw	r3,1136(sp)
   1b1f0:	008001c4 	movi	r2,7
   1b1f4:	10fcdc16 	blt	r2,r3,1a568 <___vfprintf_internal_r+0xc98>
   1b1f8:	4a400204 	addi	r9,r9,8
   1b1fc:	003ce106 	br	1a584 <___vfprintf_internal_r+0xcb4>
   1b200:	da413c15 	stw	r9,1264(sp)
   1b204:	00197140 	call	19714 <strlen>
   1b208:	d8812b15 	stw	r2,1196(sp)
   1b20c:	d8812815 	stw	r2,1184(sp)
   1b210:	da413c17 	ldw	r9,1264(sp)
   1b214:	103fa20e 	bge	r2,zero,1b0a0 <___vfprintf_internal_r+0x17d0>
   1b218:	d8012815 	stw	zero,1184(sp)
   1b21c:	003fa006 	br	1b0a0 <___vfprintf_internal_r+0x17d0>
   1b220:	d9412917 	ldw	r5,1188(sp)
   1b224:	8809883a 	mov	r4,r17
   1b228:	d9811b04 	addi	r6,sp,1132
   1b22c:	001989c0 	call	1989c <__sprint_r>
   1b230:	103b3a1e 	bne	r2,zero,19f1c <___vfprintf_internal_r+0x64c>
   1b234:	da011d17 	ldw	r8,1140(sp)
   1b238:	d8c11c17 	ldw	r3,1136(sp)
   1b23c:	da400404 	addi	r9,sp,16
   1b240:	d8813217 	ldw	r2,1224(sp)
   1b244:	4cc00015 	stw	r19,0(r9)
   1b248:	48800115 	stw	r2,4(r9)
   1b24c:	4091883a 	add	r8,r8,r2
   1b250:	003c8106 	br	1a458 <___vfprintf_internal_r+0xb88>
   1b254:	00800b44 	movi	r2,45
   1b258:	d8812585 	stb	r2,1174(sp)
   1b25c:	003be306 	br	1a1ec <___vfprintf_internal_r+0x91c>
   1b260:	4d000015 	stw	r20,0(r9)
   1b264:	4c800115 	stw	r18,4(r9)
   1b268:	4491883a 	add	r8,r8,r18
   1b26c:	18c00044 	addi	r3,r3,1
   1b270:	da011d15 	stw	r8,1140(sp)
   1b274:	d8c11c15 	stw	r3,1136(sp)
   1b278:	008001c4 	movi	r2,7
   1b27c:	10ffe816 	blt	r2,r3,1b220 <___vfprintf_internal_r+0x1950>
   1b280:	4a400204 	addi	r9,r9,8
   1b284:	003fee06 	br	1b240 <___vfprintf_internal_r+0x1970>
   1b288:	df012b15 	stw	fp,1196(sp)
   1b28c:	00800184 	movi	r2,6
   1b290:	1700072e 	bgeu	r2,fp,1b2b0 <___vfprintf_internal_r+0x19e0>
   1b294:	d8812b15 	stw	r2,1196(sp)
   1b298:	d8812815 	stw	r2,1184(sp)
   1b29c:	ddc12d15 	stw	r23,1204(sp)
   1b2a0:	04c000f4 	movhi	r19,3
   1b2a4:	9cc4de04 	addi	r19,r19,4984
   1b2a8:	d8013115 	stw	zero,1220(sp)
   1b2ac:	003a7a06 	br	19c98 <___vfprintf_internal_r+0x3c8>
   1b2b0:	d8812b17 	ldw	r2,1196(sp)
   1b2b4:	d8812815 	stw	r2,1184(sp)
   1b2b8:	103ff80e 	bge	r2,zero,1b29c <___vfprintf_internal_r+0x19cc>
   1b2bc:	d8012815 	stw	zero,1184(sp)
   1b2c0:	003ff606 	br	1b29c <___vfprintf_internal_r+0x19cc>
   1b2c4:	d9012d17 	ldw	r4,1204(sp)
   1b2c8:	da012c17 	ldw	r8,1200(sp)
   1b2cc:	20800017 	ldw	r2,0(r4)
   1b2d0:	21000104 	addi	r4,r4,4
   1b2d4:	d9012d15 	stw	r4,1204(sp)
   1b2d8:	12000015 	stw	r8,0(r2)
   1b2dc:	0039b206 	br	199a8 <___vfprintf_internal_r+0xd8>
   1b2e0:	d9412917 	ldw	r5,1188(sp)
   1b2e4:	8809883a 	mov	r4,r17
   1b2e8:	d9811b04 	addi	r6,sp,1132
   1b2ec:	001989c0 	call	1989c <__sprint_r>
   1b2f0:	103b0a1e 	bne	r2,zero,19f1c <___vfprintf_internal_r+0x64c>
   1b2f4:	dc812417 	ldw	r18,1168(sp)
   1b2f8:	da011d17 	ldw	r8,1140(sp)
   1b2fc:	da400404 	addi	r9,sp,16
   1b300:	003def06 	br	1aac0 <___vfprintf_internal_r+0x11f0>
   1b304:	d9412917 	ldw	r5,1188(sp)
   1b308:	8809883a 	mov	r4,r17
   1b30c:	d9811b04 	addi	r6,sp,1132
   1b310:	001989c0 	call	1989c <__sprint_r>
   1b314:	103b011e 	bne	r2,zero,19f1c <___vfprintf_internal_r+0x64c>
   1b318:	dc812417 	ldw	r18,1168(sp)
   1b31c:	da400404 	addi	r9,sp,16
   1b320:	003eb906 	br	1ae08 <___vfprintf_internal_r+0x1538>
   1b324:	d9412917 	ldw	r5,1188(sp)
   1b328:	8809883a 	mov	r4,r17
   1b32c:	d9811b04 	addi	r6,sp,1132
   1b330:	001989c0 	call	1989c <__sprint_r>
   1b334:	103af91e 	bne	r2,zero,19f1c <___vfprintf_internal_r+0x64c>
   1b338:	dc812417 	ldw	r18,1168(sp)
   1b33c:	da011d17 	ldw	r8,1140(sp)
   1b340:	d8c11c17 	ldw	r3,1136(sp)
   1b344:	da400404 	addi	r9,sp,16
   1b348:	003ea306 	br	1add8 <___vfprintf_internal_r+0x1508>
   1b34c:	00800244 	movi	r2,9
   1b350:	15fda636 	bltu	r2,r23,1a9ec <___vfprintf_internal_r+0x111c>
   1b354:	dd010e04 	addi	r20,sp,1080
   1b358:	003dc206 	br	1aa64 <___vfprintf_internal_r+0x1194>
   1b35c:	df012815 	stw	fp,1184(sp)
   1b360:	d8812583 	ldbu	r2,1174(sp)
   1b364:	df012b15 	stw	fp,1196(sp)
   1b368:	ddc12d15 	stw	r23,1204(sp)
   1b36c:	d8013115 	stw	zero,1220(sp)
   1b370:	003a4206 	br	19c7c <___vfprintf_internal_r+0x3ac>
   1b374:	d9412917 	ldw	r5,1188(sp)
   1b378:	8809883a 	mov	r4,r17
   1b37c:	d9811b04 	addi	r6,sp,1132
   1b380:	001989c0 	call	1989c <__sprint_r>
   1b384:	103ae51e 	bne	r2,zero,19f1c <___vfprintf_internal_r+0x64c>
   1b388:	dc812417 	ldw	r18,1168(sp)
   1b38c:	da011d17 	ldw	r8,1140(sp)
   1b390:	d8c11c17 	ldw	r3,1136(sp)
   1b394:	da400404 	addi	r9,sp,16
   1b398:	003ec906 	br	1aec0 <___vfprintf_internal_r+0x15f0>
   1b39c:	04c000f4 	movhi	r19,3
   1b3a0:	9cc4d304 	addi	r19,r19,4940
   1b3a4:	003f6f06 	br	1b164 <___vfprintf_internal_r+0x1894>
   1b3a8:	d8812583 	ldbu	r2,1174(sp)
   1b3ac:	dc012a17 	ldw	r16,1192(sp)
   1b3b0:	d8013115 	stw	zero,1220(sp)
   1b3b4:	003a3106 	br	19c7c <___vfprintf_internal_r+0x3ac>
   1b3b8:	d8812404 	addi	r2,sp,1168
   1b3bc:	d8800115 	stw	r2,4(sp)
   1b3c0:	d8812304 	addi	r2,sp,1164
   1b3c4:	d8800215 	stw	r2,8(sp)
   1b3c8:	d8812204 	addi	r2,sp,1160
   1b3cc:	df000015 	stw	fp,0(sp)
   1b3d0:	d8800315 	stw	r2,12(sp)
   1b3d4:	8809883a 	mov	r4,r17
   1b3d8:	b00b883a 	mov	r5,r22
   1b3dc:	a00d883a 	mov	r6,r20
   1b3e0:	01c000c4 	movi	r7,3
   1b3e4:	da413c15 	stw	r9,1264(sp)
   1b3e8:	001bbc00 	call	1bbc0 <_dtoa_r>
   1b3ec:	da413c17 	ldw	r9,1264(sp)
   1b3f0:	1027883a 	mov	r19,r2
   1b3f4:	1707883a 	add	r3,r2,fp
   1b3f8:	e02f883a 	mov	r23,fp
   1b3fc:	99000007 	ldb	r4,0(r19)
   1b400:	00800c04 	movi	r2,48
   1b404:	20800326 	beq	r4,r2,1b414 <___vfprintf_internal_r+0x1b44>
   1b408:	da812417 	ldw	r10,1168(sp)
   1b40c:	1a87883a 	add	r3,r3,r10
   1b410:	003ef406 	br	1afe4 <___vfprintf_internal_r+0x1714>
   1b414:	b009883a 	mov	r4,r22
   1b418:	a00b883a 	mov	r5,r20
   1b41c:	000d883a 	mov	r6,zero
   1b420:	000f883a 	mov	r7,zero
   1b424:	d8c13b15 	stw	r3,1260(sp)
   1b428:	da413c15 	stw	r9,1264(sp)
   1b42c:	00215200 	call	21520 <__nedf2>
   1b430:	d8c13b17 	ldw	r3,1260(sp)
   1b434:	da413c17 	ldw	r9,1264(sp)
   1b438:	103ff326 	beq	r2,zero,1b408 <___vfprintf_internal_r+0x1b38>
   1b43c:	00800044 	movi	r2,1
   1b440:	15d5c83a 	sub	r10,r2,r23
   1b444:	da812415 	stw	r10,1168(sp)
   1b448:	1a87883a 	add	r3,r3,r10
   1b44c:	003ee506 	br	1afe4 <___vfprintf_internal_r+0x1714>
   1b450:	d8812417 	ldw	r2,1168(sp)
   1b454:	d8812b15 	stw	r2,1196(sp)
   1b458:	1029883a 	mov	r20,r2
   1b45c:	00bfff44 	movi	r2,-3
   1b460:	a0800116 	blt	r20,r2,1b468 <___vfprintf_internal_r+0x1b98>
   1b464:	e5001d0e 	bge	fp,r20,1b4dc <___vfprintf_internal_r+0x1c0c>
   1b468:	94bfff84 	addi	r18,r18,-2
   1b46c:	a53fffc4 	addi	r20,r20,-1
   1b470:	dd012415 	stw	r20,1168(sp)
   1b474:	dc811fc5 	stb	r18,1151(sp)
   1b478:	a0007816 	blt	r20,zero,1b65c <___vfprintf_internal_r+0x1d8c>
   1b47c:	00800ac4 	movi	r2,43
   1b480:	d8812005 	stb	r2,1152(sp)
   1b484:	00800244 	movi	r2,9
   1b488:	15002b16 	blt	r2,r20,1b538 <___vfprintf_internal_r+0x1c68>
   1b48c:	00800c04 	movi	r2,48
   1b490:	a5000c04 	addi	r20,r20,48
   1b494:	d8812045 	stb	r2,1153(sp)
   1b498:	dd012085 	stb	r20,1154(sp)
   1b49c:	d8c120c4 	addi	r3,sp,1155
   1b4a0:	d8811fc4 	addi	r2,sp,1151
   1b4a4:	da013217 	ldw	r8,1224(sp)
   1b4a8:	1885c83a 	sub	r2,r3,r2
   1b4ac:	d8813515 	stw	r2,1236(sp)
   1b4b0:	4085883a 	add	r2,r8,r2
   1b4b4:	d8812b15 	stw	r2,1196(sp)
   1b4b8:	00800044 	movi	r2,1
   1b4bc:	1200610e 	bge	r2,r8,1b644 <___vfprintf_internal_r+0x1d74>
   1b4c0:	d8812b17 	ldw	r2,1196(sp)
   1b4c4:	10800044 	addi	r2,r2,1
   1b4c8:	d8812b15 	stw	r2,1196(sp)
   1b4cc:	d8812815 	stw	r2,1184(sp)
   1b4d0:	103ee90e 	bge	r2,zero,1b078 <___vfprintf_internal_r+0x17a8>
   1b4d4:	d8012815 	stw	zero,1184(sp)
   1b4d8:	003ee706 	br	1b078 <___vfprintf_internal_r+0x17a8>
   1b4dc:	d8812b17 	ldw	r2,1196(sp)
   1b4e0:	da013217 	ldw	r8,1224(sp)
   1b4e4:	12003716 	blt	r2,r8,1b5c4 <___vfprintf_internal_r+0x1cf4>
   1b4e8:	8400004c 	andi	r16,r16,1
   1b4ec:	80000326 	beq	r16,zero,1b4fc <___vfprintf_internal_r+0x1c2c>
   1b4f0:	d8812b17 	ldw	r2,1196(sp)
   1b4f4:	10800044 	addi	r2,r2,1
   1b4f8:	d8812b15 	stw	r2,1196(sp)
   1b4fc:	d8812815 	stw	r2,1184(sp)
   1b500:	10003716 	blt	r2,zero,1b5e0 <___vfprintf_internal_r+0x1d10>
   1b504:	048019c4 	movi	r18,103
   1b508:	003edb06 	br	1b078 <___vfprintf_internal_r+0x17a8>
   1b50c:	d8012815 	stw	zero,1184(sp)
   1b510:	003b6906 	br	1a2b8 <___vfprintf_internal_r+0x9e8>
   1b514:	e03e901e 	bne	fp,zero,1af58 <___vfprintf_internal_r+0x1688>
   1b518:	07000044 	movi	fp,1
   1b51c:	003e8e06 	br	1af58 <___vfprintf_internal_r+0x1688>
   1b520:	07000184 	movi	fp,6
   1b524:	003e8c06 	br	1af58 <___vfprintf_internal_r+0x1688>
   1b528:	00c00b44 	movi	r3,45
   1b52c:	a520003c 	xorhi	r20,r20,32768
   1b530:	d8c12f05 	stb	r3,1212(sp)
   1b534:	003e8c06 	br	1af68 <___vfprintf_internal_r+0x1698>
   1b538:	d8c11f84 	addi	r3,sp,1150
   1b53c:	102f883a 	mov	r23,r2
   1b540:	4839883a 	mov	fp,r9
   1b544:	a009883a 	mov	r4,r20
   1b548:	01400284 	movi	r5,10
   1b54c:	182d883a 	mov	r22,r3
   1b550:	00217d40 	call	217d4 <__modsi3>
   1b554:	10800c04 	addi	r2,r2,48
   1b558:	a009883a 	mov	r4,r20
   1b55c:	b0800005 	stb	r2,0(r22)
   1b560:	01400284 	movi	r5,10
   1b564:	00217840 	call	21784 <__divsi3>
   1b568:	1029883a 	mov	r20,r2
   1b56c:	b0ffffc4 	addi	r3,r22,-1
   1b570:	b8bff416 	blt	r23,r2,1b544 <___vfprintf_internal_r+0x1c74>
   1b574:	11400c04 	addi	r5,r2,48
   1b578:	b17fffc5 	stb	r5,-1(r22)
   1b57c:	d8811fc4 	addi	r2,sp,1151
   1b580:	e013883a 	mov	r9,fp
   1b584:	1880482e 	bgeu	r3,r2,1b6a8 <___vfprintf_internal_r+0x1dd8>
   1b588:	b007883a 	mov	r3,r22
   1b58c:	d9012044 	addi	r4,sp,1153
   1b590:	00000206 	br	1b59c <___vfprintf_internal_r+0x1ccc>
   1b594:	19400003 	ldbu	r5,0(r3)
   1b598:	18c00044 	addi	r3,r3,1
   1b59c:	21400005 	stb	r5,0(r4)
   1b5a0:	21000044 	addi	r4,r4,1
   1b5a4:	10fffb1e 	bne	r2,r3,1b594 <___vfprintf_internal_r+0x1cc4>
   1b5a8:	d8c12004 	addi	r3,sp,1152
   1b5ac:	1d87c83a 	sub	r3,r3,r22
   1b5b0:	d9012044 	addi	r4,sp,1153
   1b5b4:	20c7883a 	add	r3,r4,r3
   1b5b8:	003fba06 	br	1b4a4 <___vfprintf_internal_r+0x1bd4>
   1b5bc:	d8c12217 	ldw	r3,1160(sp)
   1b5c0:	003e9906 	br	1b028 <___vfprintf_internal_r+0x1758>
   1b5c4:	05000b0e 	bge	zero,r20,1b5f4 <___vfprintf_internal_r+0x1d24>
   1b5c8:	05000044 	movi	r20,1
   1b5cc:	da013217 	ldw	r8,1224(sp)
   1b5d0:	a229883a 	add	r20,r20,r8
   1b5d4:	dd012b15 	stw	r20,1196(sp)
   1b5d8:	dd012815 	stw	r20,1184(sp)
   1b5dc:	a03fc90e 	bge	r20,zero,1b504 <___vfprintf_internal_r+0x1c34>
   1b5e0:	d8012815 	stw	zero,1184(sp)
   1b5e4:	048019c4 	movi	r18,103
   1b5e8:	003ea306 	br	1b078 <___vfprintf_internal_r+0x17a8>
   1b5ec:	e5c00044 	addi	r23,fp,1
   1b5f0:	003e6606 	br	1af8c <___vfprintf_internal_r+0x16bc>
   1b5f4:	00800084 	movi	r2,2
   1b5f8:	1529c83a 	sub	r20,r2,r20
   1b5fc:	003ff306 	br	1b5cc <___vfprintf_internal_r+0x1cfc>
   1b600:	008011c4 	movi	r2,71
   1b604:	90be7226 	beq	r18,r2,1afd0 <___vfprintf_internal_r+0x1700>
   1b608:	003e7306 	br	1afd8 <___vfprintf_internal_r+0x1708>
   1b60c:	d8812d17 	ldw	r2,1204(sp)
   1b610:	ac800043 	ldbu	r18,1(r21)
   1b614:	202b883a 	mov	r21,r4
   1b618:	17000017 	ldw	fp,0(r2)
   1b61c:	10800104 	addi	r2,r2,4
   1b620:	d8812d15 	stw	r2,1204(sp)
   1b624:	e0001b16 	blt	fp,zero,1b694 <___vfprintf_internal_r+0x1dc4>
   1b628:	94803fcc 	andi	r18,r18,255
   1b62c:	9480201c 	xori	r18,r18,128
   1b630:	94bfe004 	addi	r18,r18,-128
   1b634:	00390406 	br	19a48 <___vfprintf_internal_r+0x178>
   1b638:	00bfffc4 	movi	r2,-1
   1b63c:	d8812c15 	stw	r2,1200(sp)
   1b640:	003a2506 	br	19ed8 <___vfprintf_internal_r+0x608>
   1b644:	80a0703a 	and	r16,r16,r2
   1b648:	803f9d1e 	bne	r16,zero,1b4c0 <___vfprintf_internal_r+0x1bf0>
   1b64c:	d8812b17 	ldw	r2,1196(sp)
   1b650:	d8812815 	stw	r2,1184(sp)
   1b654:	103e880e 	bge	r2,zero,1b078 <___vfprintf_internal_r+0x17a8>
   1b658:	003f9e06 	br	1b4d4 <___vfprintf_internal_r+0x1c04>
   1b65c:	00800b44 	movi	r2,45
   1b660:	0529c83a 	sub	r20,zero,r20
   1b664:	d8812005 	stb	r2,1152(sp)
   1b668:	003f8606 	br	1b484 <___vfprintf_internal_r+0x1bb4>
   1b66c:	1007883a 	mov	r3,r2
   1b670:	003e6d06 	br	1b028 <___vfprintf_internal_r+0x1758>
   1b674:	e000021e 	bne	fp,zero,1b680 <___vfprintf_internal_r+0x1db0>
   1b678:	8400004c 	andi	r16,r16,1
   1b67c:	80000e26 	beq	r16,zero,1b6b8 <___vfprintf_internal_r+0x1de8>
   1b680:	e7000084 	addi	fp,fp,2
   1b684:	df012b15 	stw	fp,1196(sp)
   1b688:	df012815 	stw	fp,1184(sp)
   1b68c:	e03e7a0e 	bge	fp,zero,1b078 <___vfprintf_internal_r+0x17a8>
   1b690:	003f9006 	br	1b4d4 <___vfprintf_internal_r+0x1c04>
   1b694:	94803fcc 	andi	r18,r18,255
   1b698:	9480201c 	xori	r18,r18,128
   1b69c:	073fffc4 	movi	fp,-1
   1b6a0:	94bfe004 	addi	r18,r18,-128
   1b6a4:	0038e806 	br	19a48 <___vfprintf_internal_r+0x178>
   1b6a8:	d8c12044 	addi	r3,sp,1153
   1b6ac:	003f7d06 	br	1b4a4 <___vfprintf_internal_r+0x1bd4>
   1b6b0:	dd012417 	ldw	r20,1168(sp)
   1b6b4:	003f6d06 	br	1b46c <___vfprintf_internal_r+0x1b9c>
   1b6b8:	00c00044 	movi	r3,1
   1b6bc:	d8c12815 	stw	r3,1184(sp)
   1b6c0:	d8c12b15 	stw	r3,1196(sp)
   1b6c4:	003e6c06 	br	1b078 <___vfprintf_internal_r+0x17a8>

0001b6c8 <__vfprintf_internal>:
   1b6c8:	008000f4 	movhi	r2,3
   1b6cc:	10957f04 	addi	r2,r2,22012
   1b6d0:	2007883a 	mov	r3,r4
   1b6d4:	11000017 	ldw	r4,0(r2)
   1b6d8:	2805883a 	mov	r2,r5
   1b6dc:	300f883a 	mov	r7,r6
   1b6e0:	180b883a 	mov	r5,r3
   1b6e4:	100d883a 	mov	r6,r2
   1b6e8:	00198d01 	jmpi	198d0 <___vfprintf_internal_r>

0001b6ec <__swbuf_r>:
   1b6ec:	defffc04 	addi	sp,sp,-16
   1b6f0:	dc800215 	stw	r18,8(sp)
   1b6f4:	dc400115 	stw	r17,4(sp)
   1b6f8:	dc000015 	stw	r16,0(sp)
   1b6fc:	dfc00315 	stw	ra,12(sp)
   1b700:	2023883a 	mov	r17,r4
   1b704:	2825883a 	mov	r18,r5
   1b708:	3021883a 	mov	r16,r6
   1b70c:	20000226 	beq	r4,zero,1b718 <__swbuf_r+0x2c>
   1b710:	20800e17 	ldw	r2,56(r4)
   1b714:	10003b26 	beq	r2,zero,1b804 <__swbuf_r+0x118>
   1b718:	8080030b 	ldhu	r2,12(r16)
   1b71c:	80c00617 	ldw	r3,24(r16)
   1b720:	1080020c 	andi	r2,r2,8
   1b724:	10bfffcc 	andi	r2,r2,65535
   1b728:	10a0001c 	xori	r2,r2,32768
   1b72c:	80c00215 	stw	r3,8(r16)
   1b730:	10a00004 	addi	r2,r2,-32768
   1b734:	10002226 	beq	r2,zero,1b7c0 <__swbuf_r+0xd4>
   1b738:	80800417 	ldw	r2,16(r16)
   1b73c:	10002026 	beq	r2,zero,1b7c0 <__swbuf_r+0xd4>
   1b740:	80c00017 	ldw	r3,0(r16)
   1b744:	81000517 	ldw	r4,20(r16)
   1b748:	94803fcc 	andi	r18,r18,255
   1b74c:	1885c83a 	sub	r2,r3,r2
   1b750:	1100250e 	bge	r2,r4,1b7e8 <__swbuf_r+0xfc>
   1b754:	10800044 	addi	r2,r2,1
   1b758:	81400217 	ldw	r5,8(r16)
   1b75c:	19000044 	addi	r4,r3,1
   1b760:	297fffc4 	addi	r5,r5,-1
   1b764:	81400215 	stw	r5,8(r16)
   1b768:	1c800005 	stb	r18,0(r3)
   1b76c:	80c00517 	ldw	r3,20(r16)
   1b770:	81000015 	stw	r4,0(r16)
   1b774:	18800c26 	beq	r3,r2,1b7a8 <__swbuf_r+0xbc>
   1b778:	8080030b 	ldhu	r2,12(r16)
   1b77c:	1080004c 	andi	r2,r2,1
   1b780:	10000226 	beq	r2,zero,1b78c <__swbuf_r+0xa0>
   1b784:	00800284 	movi	r2,10
   1b788:	90800726 	beq	r18,r2,1b7a8 <__swbuf_r+0xbc>
   1b78c:	9005883a 	mov	r2,r18
   1b790:	dfc00317 	ldw	ra,12(sp)
   1b794:	dc800217 	ldw	r18,8(sp)
   1b798:	dc400117 	ldw	r17,4(sp)
   1b79c:	dc000017 	ldw	r16,0(sp)
   1b7a0:	dec00404 	addi	sp,sp,16
   1b7a4:	f800283a 	ret
   1b7a8:	8809883a 	mov	r4,r17
   1b7ac:	800b883a 	mov	r5,r16
   1b7b0:	001d1dc0 	call	1d1dc <_fflush_r>
   1b7b4:	103ff526 	beq	r2,zero,1b78c <__swbuf_r+0xa0>
   1b7b8:	04bfffc4 	movi	r18,-1
   1b7bc:	003ff306 	br	1b78c <__swbuf_r+0xa0>
   1b7c0:	8809883a 	mov	r4,r17
   1b7c4:	800b883a 	mov	r5,r16
   1b7c8:	001b8440 	call	1b844 <__swsetup_r>
   1b7cc:	10000f1e 	bne	r2,zero,1b80c <__swbuf_r+0x120>
   1b7d0:	80800417 	ldw	r2,16(r16)
   1b7d4:	80c00017 	ldw	r3,0(r16)
   1b7d8:	81000517 	ldw	r4,20(r16)
   1b7dc:	94803fcc 	andi	r18,r18,255
   1b7e0:	1885c83a 	sub	r2,r3,r2
   1b7e4:	113fdb16 	blt	r2,r4,1b754 <__swbuf_r+0x68>
   1b7e8:	8809883a 	mov	r4,r17
   1b7ec:	800b883a 	mov	r5,r16
   1b7f0:	001d1dc0 	call	1d1dc <_fflush_r>
   1b7f4:	103ff01e 	bne	r2,zero,1b7b8 <__swbuf_r+0xcc>
   1b7f8:	80c00017 	ldw	r3,0(r16)
   1b7fc:	00800044 	movi	r2,1
   1b800:	003fd506 	br	1b758 <__swbuf_r+0x6c>
   1b804:	001d4840 	call	1d484 <__sinit>
   1b808:	003fc306 	br	1b718 <__swbuf_r+0x2c>
   1b80c:	8080030b 	ldhu	r2,12(r16)
   1b810:	04bfffc4 	movi	r18,-1
   1b814:	10801014 	ori	r2,r2,64
   1b818:	8080030d 	sth	r2,12(r16)
   1b81c:	00800244 	movi	r2,9
   1b820:	88800015 	stw	r2,0(r17)
   1b824:	003fd906 	br	1b78c <__swbuf_r+0xa0>

0001b828 <__swbuf>:
   1b828:	00c000f4 	movhi	r3,3
   1b82c:	18d57f04 	addi	r3,r3,22012
   1b830:	2005883a 	mov	r2,r4
   1b834:	19000017 	ldw	r4,0(r3)
   1b838:	280d883a 	mov	r6,r5
   1b83c:	100b883a 	mov	r5,r2
   1b840:	001b6ec1 	jmpi	1b6ec <__swbuf_r>

0001b844 <__swsetup_r>:
   1b844:	008000f4 	movhi	r2,3
   1b848:	10957f04 	addi	r2,r2,22012
   1b84c:	10800017 	ldw	r2,0(r2)
   1b850:	defffd04 	addi	sp,sp,-12
   1b854:	dc400115 	stw	r17,4(sp)
   1b858:	dc000015 	stw	r16,0(sp)
   1b85c:	dfc00215 	stw	ra,8(sp)
   1b860:	2023883a 	mov	r17,r4
   1b864:	2821883a 	mov	r16,r5
   1b868:	10000226 	beq	r2,zero,1b874 <__swsetup_r+0x30>
   1b86c:	10c00e17 	ldw	r3,56(r2)
   1b870:	18003d26 	beq	r3,zero,1b968 <__swsetup_r+0x124>
   1b874:	8080030b 	ldhu	r2,12(r16)
   1b878:	10c0020c 	andi	r3,r2,8
   1b87c:	18ffffcc 	andi	r3,r3,65535
   1b880:	18e0001c 	xori	r3,r3,32768
   1b884:	18e00004 	addi	r3,r3,-32768
   1b888:	18001226 	beq	r3,zero,1b8d4 <__swsetup_r+0x90>
   1b88c:	80c00417 	ldw	r3,16(r16)
   1b890:	18001f26 	beq	r3,zero,1b910 <__swsetup_r+0xcc>
   1b894:	1100004c 	andi	r4,r2,1
   1b898:	2000261e 	bne	r4,zero,1b934 <__swsetup_r+0xf0>
   1b89c:	1080008c 	andi	r2,r2,2
   1b8a0:	10bfffcc 	andi	r2,r2,65535
   1b8a4:	10a0001c 	xori	r2,r2,32768
   1b8a8:	10a00004 	addi	r2,r2,-32768
   1b8ac:	1000311e 	bne	r2,zero,1b974 <__swsetup_r+0x130>
   1b8b0:	80800517 	ldw	r2,20(r16)
   1b8b4:	80800215 	stw	r2,8(r16)
   1b8b8:	18002326 	beq	r3,zero,1b948 <__swsetup_r+0x104>
   1b8bc:	0005883a 	mov	r2,zero
   1b8c0:	dfc00217 	ldw	ra,8(sp)
   1b8c4:	dc400117 	ldw	r17,4(sp)
   1b8c8:	dc000017 	ldw	r16,0(sp)
   1b8cc:	dec00304 	addi	sp,sp,12
   1b8d0:	f800283a 	ret
   1b8d4:	10c0040c 	andi	r3,r2,16
   1b8d8:	18ffffcc 	andi	r3,r3,65535
   1b8dc:	18e0001c 	xori	r3,r3,32768
   1b8e0:	18e00004 	addi	r3,r3,-32768
   1b8e4:	18001e26 	beq	r3,zero,1b960 <__swsetup_r+0x11c>
   1b8e8:	10c0010c 	andi	r3,r2,4
   1b8ec:	18ffffcc 	andi	r3,r3,65535
   1b8f0:	18e0001c 	xori	r3,r3,32768
   1b8f4:	18e00004 	addi	r3,r3,-32768
   1b8f8:	1800211e 	bne	r3,zero,1b980 <__swsetup_r+0x13c>
   1b8fc:	80c00417 	ldw	r3,16(r16)
   1b900:	11400214 	ori	r5,r2,8
   1b904:	8140030d 	sth	r5,12(r16)
   1b908:	2805883a 	mov	r2,r5
   1b90c:	183fe11e 	bne	r3,zero,1b894 <__swsetup_r+0x50>
   1b910:	1140a00c 	andi	r5,r2,640
   1b914:	01008004 	movi	r4,512
   1b918:	293fde26 	beq	r5,r4,1b894 <__swsetup_r+0x50>
   1b91c:	8809883a 	mov	r4,r17
   1b920:	800b883a 	mov	r5,r16
   1b924:	001e1f80 	call	1e1f8 <__smakebuf_r>
   1b928:	8080030b 	ldhu	r2,12(r16)
   1b92c:	80c00417 	ldw	r3,16(r16)
   1b930:	003fd806 	br	1b894 <__swsetup_r+0x50>
   1b934:	80800517 	ldw	r2,20(r16)
   1b938:	80000215 	stw	zero,8(r16)
   1b93c:	0085c83a 	sub	r2,zero,r2
   1b940:	80800615 	stw	r2,24(r16)
   1b944:	183fdd1e 	bne	r3,zero,1b8bc <__swsetup_r+0x78>
   1b948:	8080030b 	ldhu	r2,12(r16)
   1b94c:	1080200c 	andi	r2,r2,128
   1b950:	10bfffcc 	andi	r2,r2,65535
   1b954:	10a0001c 	xori	r2,r2,32768
   1b958:	10a00004 	addi	r2,r2,-32768
   1b95c:	103fd826 	beq	r2,zero,1b8c0 <__swsetup_r+0x7c>
   1b960:	00bfffc4 	movi	r2,-1
   1b964:	003fd606 	br	1b8c0 <__swsetup_r+0x7c>
   1b968:	1009883a 	mov	r4,r2
   1b96c:	001d4840 	call	1d484 <__sinit>
   1b970:	003fc006 	br	1b874 <__swsetup_r+0x30>
   1b974:	0005883a 	mov	r2,zero
   1b978:	80800215 	stw	r2,8(r16)
   1b97c:	003fce06 	br	1b8b8 <__swsetup_r+0x74>
   1b980:	81400c17 	ldw	r5,48(r16)
   1b984:	28000626 	beq	r5,zero,1b9a0 <__swsetup_r+0x15c>
   1b988:	80c01004 	addi	r3,r16,64
   1b98c:	28c00326 	beq	r5,r3,1b99c <__swsetup_r+0x158>
   1b990:	8809883a 	mov	r4,r17
   1b994:	001d8080 	call	1d808 <_free_r>
   1b998:	8080030b 	ldhu	r2,12(r16)
   1b99c:	80000c15 	stw	zero,48(r16)
   1b9a0:	80c00417 	ldw	r3,16(r16)
   1b9a4:	013ff6c4 	movi	r4,-37
   1b9a8:	2084703a 	and	r2,r4,r2
   1b9ac:	80000115 	stw	zero,4(r16)
   1b9b0:	80c00015 	stw	r3,0(r16)
   1b9b4:	003fd206 	br	1b900 <__swsetup_r+0xbc>

0001b9b8 <quorem>:
   1b9b8:	defff704 	addi	sp,sp,-36
   1b9bc:	dc400115 	stw	r17,4(sp)
   1b9c0:	20800417 	ldw	r2,16(r4)
   1b9c4:	2c400417 	ldw	r17,16(r5)
   1b9c8:	dd800615 	stw	r22,24(sp)
   1b9cc:	dd400515 	stw	r21,20(sp)
   1b9d0:	dfc00815 	stw	ra,32(sp)
   1b9d4:	ddc00715 	stw	r23,28(sp)
   1b9d8:	dd000415 	stw	r20,16(sp)
   1b9dc:	dcc00315 	stw	r19,12(sp)
   1b9e0:	dc800215 	stw	r18,8(sp)
   1b9e4:	dc000015 	stw	r16,0(sp)
   1b9e8:	202b883a 	mov	r21,r4
   1b9ec:	282d883a 	mov	r22,r5
   1b9f0:	14407116 	blt	r2,r17,1bbb8 <quorem+0x200>
   1b9f4:	88800104 	addi	r2,r17,4
   1b9f8:	1085883a 	add	r2,r2,r2
   1b9fc:	1085883a 	add	r2,r2,r2
   1ba00:	28a7883a 	add	r19,r5,r2
   1ba04:	2085883a 	add	r2,r4,r2
   1ba08:	15c00017 	ldw	r23,0(r2)
   1ba0c:	99400017 	ldw	r5,0(r19)
   1ba10:	8c7fffc4 	addi	r17,r17,-1
   1ba14:	b809883a 	mov	r4,r23
   1ba18:	29400044 	addi	r5,r5,1
   1ba1c:	00218300 	call	21830 <__udivsi3>
   1ba20:	1025883a 	mov	r18,r2
   1ba24:	b4000504 	addi	r16,r22,20
   1ba28:	ad000504 	addi	r20,r21,20
   1ba2c:	10002d26 	beq	r2,zero,1bae4 <quorem+0x12c>
   1ba30:	800d883a 	mov	r6,r16
   1ba34:	a007883a 	mov	r3,r20
   1ba38:	000f883a 	mov	r7,zero
   1ba3c:	0005883a 	mov	r2,zero
   1ba40:	32c00017 	ldw	r11,0(r6)
   1ba44:	1a400017 	ldw	r9,0(r3)
   1ba48:	31800104 	addi	r6,r6,4
   1ba4c:	5abfffcc 	andi	r10,r11,65535
   1ba50:	5495383a 	mul	r10,r10,r18
   1ba54:	5816d43a 	srli	r11,r11,16
   1ba58:	4a3fffcc 	andi	r8,r9,65535
   1ba5c:	3a95883a 	add	r10,r7,r10
   1ba60:	500ed43a 	srli	r7,r10,16
   1ba64:	5c97383a 	mul	r11,r11,r18
   1ba68:	4085883a 	add	r2,r8,r2
   1ba6c:	52bfffcc 	andi	r10,r10,65535
   1ba70:	1291c83a 	sub	r8,r2,r10
   1ba74:	4804d43a 	srli	r2,r9,16
   1ba78:	3acf883a 	add	r7,r7,r11
   1ba7c:	4015d43a 	srai	r10,r8,16
   1ba80:	393fffcc 	andi	r4,r7,65535
   1ba84:	1105c83a 	sub	r2,r2,r4
   1ba88:	1285883a 	add	r2,r2,r10
   1ba8c:	1880008d 	sth	r2,2(r3)
   1ba90:	1a00000d 	sth	r8,0(r3)
   1ba94:	380ed43a 	srli	r7,r7,16
   1ba98:	1005d43a 	srai	r2,r2,16
   1ba9c:	18c00104 	addi	r3,r3,4
   1baa0:	99bfe72e 	bgeu	r19,r6,1ba40 <quorem+0x88>
   1baa4:	b8000f1e 	bne	r23,zero,1bae4 <quorem+0x12c>
   1baa8:	88800144 	addi	r2,r17,5
   1baac:	1085883a 	add	r2,r2,r2
   1bab0:	1085883a 	add	r2,r2,r2
   1bab4:	a887883a 	add	r3,r21,r2
   1bab8:	18bfff04 	addi	r2,r3,-4
   1babc:	a080082e 	bgeu	r20,r2,1bae0 <quorem+0x128>
   1bac0:	18ffff17 	ldw	r3,-4(r3)
   1bac4:	18000326 	beq	r3,zero,1bad4 <quorem+0x11c>
   1bac8:	00000506 	br	1bae0 <quorem+0x128>
   1bacc:	10c00017 	ldw	r3,0(r2)
   1bad0:	1800031e 	bne	r3,zero,1bae0 <quorem+0x128>
   1bad4:	10bfff04 	addi	r2,r2,-4
   1bad8:	8c7fffc4 	addi	r17,r17,-1
   1badc:	a0bffb36 	bltu	r20,r2,1bacc <quorem+0x114>
   1bae0:	ac400415 	stw	r17,16(r21)
   1bae4:	a809883a 	mov	r4,r21
   1bae8:	b00b883a 	mov	r5,r22
   1baec:	001f5e80 	call	1f5e8 <__mcmp>
   1baf0:	10002516 	blt	r2,zero,1bb88 <quorem+0x1d0>
   1baf4:	94800044 	addi	r18,r18,1
   1baf8:	a007883a 	mov	r3,r20
   1bafc:	000b883a 	mov	r5,zero
   1bb00:	1a000017 	ldw	r8,0(r3)
   1bb04:	81c00017 	ldw	r7,0(r16)
   1bb08:	84000104 	addi	r16,r16,4
   1bb0c:	41bfffcc 	andi	r6,r8,65535
   1bb10:	38bfffcc 	andi	r2,r7,65535
   1bb14:	314b883a 	add	r5,r6,r5
   1bb18:	288dc83a 	sub	r6,r5,r2
   1bb1c:	380ed43a 	srli	r7,r7,16
   1bb20:	400ad43a 	srli	r5,r8,16
   1bb24:	3005d43a 	srai	r2,r6,16
   1bb28:	1980000d 	sth	r6,0(r3)
   1bb2c:	29cbc83a 	sub	r5,r5,r7
   1bb30:	288b883a 	add	r5,r5,r2
   1bb34:	1940008d 	sth	r5,2(r3)
   1bb38:	280bd43a 	srai	r5,r5,16
   1bb3c:	18c00104 	addi	r3,r3,4
   1bb40:	9c3fef2e 	bgeu	r19,r16,1bb00 <quorem+0x148>
   1bb44:	88800144 	addi	r2,r17,5
   1bb48:	1085883a 	add	r2,r2,r2
   1bb4c:	1085883a 	add	r2,r2,r2
   1bb50:	a885883a 	add	r2,r21,r2
   1bb54:	10c00017 	ldw	r3,0(r2)
   1bb58:	18000b1e 	bne	r3,zero,1bb88 <quorem+0x1d0>
   1bb5c:	10ffff04 	addi	r3,r2,-4
   1bb60:	a0c0082e 	bgeu	r20,r3,1bb84 <quorem+0x1cc>
   1bb64:	10bfff17 	ldw	r2,-4(r2)
   1bb68:	10000326 	beq	r2,zero,1bb78 <quorem+0x1c0>
   1bb6c:	00000506 	br	1bb84 <quorem+0x1cc>
   1bb70:	18800017 	ldw	r2,0(r3)
   1bb74:	1000031e 	bne	r2,zero,1bb84 <quorem+0x1cc>
   1bb78:	18ffff04 	addi	r3,r3,-4
   1bb7c:	8c7fffc4 	addi	r17,r17,-1
   1bb80:	a0fffb36 	bltu	r20,r3,1bb70 <quorem+0x1b8>
   1bb84:	ac400415 	stw	r17,16(r21)
   1bb88:	9005883a 	mov	r2,r18
   1bb8c:	dfc00817 	ldw	ra,32(sp)
   1bb90:	ddc00717 	ldw	r23,28(sp)
   1bb94:	dd800617 	ldw	r22,24(sp)
   1bb98:	dd400517 	ldw	r21,20(sp)
   1bb9c:	dd000417 	ldw	r20,16(sp)
   1bba0:	dcc00317 	ldw	r19,12(sp)
   1bba4:	dc800217 	ldw	r18,8(sp)
   1bba8:	dc400117 	ldw	r17,4(sp)
   1bbac:	dc000017 	ldw	r16,0(sp)
   1bbb0:	dec00904 	addi	sp,sp,36
   1bbb4:	f800283a 	ret
   1bbb8:	0005883a 	mov	r2,zero
   1bbbc:	003ff306 	br	1bb8c <quorem+0x1d4>

0001bbc0 <_dtoa_r>:
   1bbc0:	20801017 	ldw	r2,64(r4)
   1bbc4:	deffdf04 	addi	sp,sp,-132
   1bbc8:	dcc01a15 	stw	r19,104(sp)
   1bbcc:	dc801915 	stw	r18,100(sp)
   1bbd0:	dc401815 	stw	r17,96(sp)
   1bbd4:	dc001715 	stw	r16,92(sp)
   1bbd8:	dfc02015 	stw	ra,128(sp)
   1bbdc:	df001f15 	stw	fp,124(sp)
   1bbe0:	ddc01e15 	stw	r23,120(sp)
   1bbe4:	dd801d15 	stw	r22,116(sp)
   1bbe8:	dd401c15 	stw	r21,112(sp)
   1bbec:	dd001b15 	stw	r20,108(sp)
   1bbf0:	d9400315 	stw	r5,12(sp)
   1bbf4:	d9c00415 	stw	r7,16(sp)
   1bbf8:	2021883a 	mov	r16,r4
   1bbfc:	3025883a 	mov	r18,r6
   1bc00:	dcc02317 	ldw	r19,140(sp)
   1bc04:	3023883a 	mov	r17,r6
   1bc08:	10000826 	beq	r2,zero,1bc2c <_dtoa_r+0x6c>
   1bc0c:	20c01117 	ldw	r3,68(r4)
   1bc10:	01800044 	movi	r6,1
   1bc14:	100b883a 	mov	r5,r2
   1bc18:	30cc983a 	sll	r6,r6,r3
   1bc1c:	10c00115 	stw	r3,4(r2)
   1bc20:	11800215 	stw	r6,8(r2)
   1bc24:	001edec0 	call	1edec <_Bfree>
   1bc28:	80001015 	stw	zero,64(r16)
   1bc2c:	90002f16 	blt	r18,zero,1bcec <_dtoa_r+0x12c>
   1bc30:	98000015 	stw	zero,0(r19)
   1bc34:	90dffc2c 	andhi	r3,r18,32752
   1bc38:	009ffc34 	movhi	r2,32752
   1bc3c:	18801c26 	beq	r3,r2,1bcb0 <_dtoa_r+0xf0>
   1bc40:	d9000317 	ldw	r4,12(sp)
   1bc44:	880b883a 	mov	r5,r17
   1bc48:	000d883a 	mov	r6,zero
   1bc4c:	000f883a 	mov	r7,zero
   1bc50:	00214c40 	call	214c4 <__eqdf2>
   1bc54:	10002c1e 	bne	r2,zero,1bd08 <_dtoa_r+0x148>
   1bc58:	d9002217 	ldw	r4,136(sp)
   1bc5c:	d9c02417 	ldw	r7,144(sp)
   1bc60:	00800044 	movi	r2,1
   1bc64:	20800015 	stw	r2,0(r4)
   1bc68:	38019426 	beq	r7,zero,1c2bc <_dtoa_r+0x6fc>
   1bc6c:	008000f4 	movhi	r2,3
   1bc70:	1084e044 	addi	r2,r2,4993
   1bc74:	38800015 	stw	r2,0(r7)
   1bc78:	15ffffc4 	addi	r23,r2,-1
   1bc7c:	b805883a 	mov	r2,r23
   1bc80:	dfc02017 	ldw	ra,128(sp)
   1bc84:	df001f17 	ldw	fp,124(sp)
   1bc88:	ddc01e17 	ldw	r23,120(sp)
   1bc8c:	dd801d17 	ldw	r22,116(sp)
   1bc90:	dd401c17 	ldw	r21,112(sp)
   1bc94:	dd001b17 	ldw	r20,108(sp)
   1bc98:	dcc01a17 	ldw	r19,104(sp)
   1bc9c:	dc801917 	ldw	r18,100(sp)
   1bca0:	dc401817 	ldw	r17,96(sp)
   1bca4:	dc001717 	ldw	r16,92(sp)
   1bca8:	dec02104 	addi	sp,sp,132
   1bcac:	f800283a 	ret
   1bcb0:	d8c02217 	ldw	r3,136(sp)
   1bcb4:	d9000317 	ldw	r4,12(sp)
   1bcb8:	0089c3c4 	movi	r2,9999
   1bcbc:	18800015 	stw	r2,0(r3)
   1bcc0:	20016c26 	beq	r4,zero,1c274 <_dtoa_r+0x6b4>
   1bcc4:	05c000f4 	movhi	r23,3
   1bcc8:	bdc4ec04 	addi	r23,r23,5040
   1bccc:	d9c02417 	ldw	r7,144(sp)
   1bcd0:	383fea26 	beq	r7,zero,1bc7c <_dtoa_r+0xbc>
   1bcd4:	b88000c7 	ldb	r2,3(r23)
   1bcd8:	10016d1e 	bne	r2,zero,1c290 <_dtoa_r+0x6d0>
   1bcdc:	b88000c4 	addi	r2,r23,3
   1bce0:	d8c02417 	ldw	r3,144(sp)
   1bce4:	18800015 	stw	r2,0(r3)
   1bce8:	003fe406 	br	1bc7c <_dtoa_r+0xbc>
   1bcec:	04600034 	movhi	r17,32768
   1bcf0:	8c7fffc4 	addi	r17,r17,-1
   1bcf4:	9462703a 	and	r17,r18,r17
   1bcf8:	00800044 	movi	r2,1
   1bcfc:	98800015 	stw	r2,0(r19)
   1bd00:	8825883a 	mov	r18,r17
   1bd04:	003fcb06 	br	1bc34 <_dtoa_r+0x74>
   1bd08:	d9400317 	ldw	r5,12(sp)
   1bd0c:	9028d53a 	srli	r20,r18,20
   1bd10:	d8800204 	addi	r2,sp,8
   1bd14:	d8800015 	stw	r2,0(sp)
   1bd18:	8009883a 	mov	r4,r16
   1bd1c:	880d883a 	mov	r6,r17
   1bd20:	d9c00104 	addi	r7,sp,4
   1bd24:	001f9900 	call	1f990 <__d2b>
   1bd28:	a501ffcc 	andi	r20,r20,2047
   1bd2c:	1039883a 	mov	fp,r2
   1bd30:	a001591e 	bne	r20,zero,1c298 <_dtoa_r+0x6d8>
   1bd34:	dd400217 	ldw	r21,8(sp)
   1bd38:	dd000117 	ldw	r20,4(sp)
   1bd3c:	00befbc4 	movi	r2,-1041
   1bd40:	ad29883a 	add	r20,r21,r20
   1bd44:	a082d216 	blt	r20,r2,1c890 <_dtoa_r+0xcd0>
   1bd48:	d8c00317 	ldw	r3,12(sp)
   1bd4c:	013f0384 	movi	r4,-1010
   1bd50:	2509c83a 	sub	r4,r4,r20
   1bd54:	a0810484 	addi	r2,r20,1042
   1bd58:	9124983a 	sll	r18,r18,r4
   1bd5c:	1884d83a 	srl	r2,r3,r2
   1bd60:	9088b03a 	or	r4,r18,r2
   1bd64:	0018acc0 	call	18acc <__floatunsidf>
   1bd68:	1009883a 	mov	r4,r2
   1bd6c:	017f8434 	movhi	r5,65040
   1bd70:	00800044 	movi	r2,1
   1bd74:	194b883a 	add	r5,r3,r5
   1bd78:	a53fffc4 	addi	r20,r20,-1
   1bd7c:	d8800f15 	stw	r2,60(sp)
   1bd80:	000d883a 	mov	r6,zero
   1bd84:	01cffe34 	movhi	r7,16376
   1bd88:	001849c0 	call	1849c <__subdf3>
   1bd8c:	1009883a 	mov	r4,r2
   1bd90:	180b883a 	mov	r5,r3
   1bd94:	0198dbf4 	movhi	r6,25455
   1bd98:	3190d844 	addi	r6,r6,17249
   1bd9c:	01cff4f4 	movhi	r7,16339
   1bda0:	39e1e9c4 	addi	r7,r7,-30809
   1bda4:	00184fc0 	call	184fc <__muldf3>
   1bda8:	180b883a 	mov	r5,r3
   1bdac:	01a2d874 	movhi	r6,35681
   1bdb0:	31b22cc4 	addi	r6,r6,-14157
   1bdb4:	01cff1f4 	movhi	r7,16327
   1bdb8:	39e28a04 	addi	r7,r7,-30168
   1bdbc:	1009883a 	mov	r4,r2
   1bdc0:	00184480 	call	18448 <__adddf3>
   1bdc4:	a009883a 	mov	r4,r20
   1bdc8:	1027883a 	mov	r19,r2
   1bdcc:	1825883a 	mov	r18,r3
   1bdd0:	002163c0 	call	2163c <__floatsidf>
   1bdd4:	1009883a 	mov	r4,r2
   1bdd8:	180b883a 	mov	r5,r3
   1bddc:	019427f4 	movhi	r6,20639
   1bde0:	319e7ec4 	addi	r6,r6,31227
   1bde4:	01cff4f4 	movhi	r7,16339
   1bde8:	39d104c4 	addi	r7,r7,17427
   1bdec:	00184fc0 	call	184fc <__muldf3>
   1bdf0:	9809883a 	mov	r4,r19
   1bdf4:	900b883a 	mov	r5,r18
   1bdf8:	100d883a 	mov	r6,r2
   1bdfc:	180f883a 	mov	r7,r3
   1be00:	00184480 	call	18448 <__adddf3>
   1be04:	1009883a 	mov	r4,r2
   1be08:	180b883a 	mov	r5,r3
   1be0c:	1027883a 	mov	r19,r2
   1be10:	1825883a 	mov	r18,r3
   1be14:	00189f80 	call	189f8 <__fixdfsi>
   1be18:	9809883a 	mov	r4,r19
   1be1c:	900b883a 	mov	r5,r18
   1be20:	000d883a 	mov	r6,zero
   1be24:	000f883a 	mov	r7,zero
   1be28:	d8800615 	stw	r2,24(sp)
   1be2c:	00215e00 	call	215e0 <__ltdf2>
   1be30:	10027e16 	blt	r2,zero,1c82c <_dtoa_r+0xc6c>
   1be34:	d8c00617 	ldw	r3,24(sp)
   1be38:	00800584 	movi	r2,22
   1be3c:	10c26c36 	bltu	r2,r3,1c7f0 <_dtoa_r+0xc30>
   1be40:	180490fa 	slli	r2,r3,3
   1be44:	00c000f4 	movhi	r3,3
   1be48:	18c51104 	addi	r3,r3,5188
   1be4c:	d9800317 	ldw	r6,12(sp)
   1be50:	1885883a 	add	r2,r3,r2
   1be54:	11000017 	ldw	r4,0(r2)
   1be58:	11400117 	ldw	r5,4(r2)
   1be5c:	880f883a 	mov	r7,r17
   1be60:	002157c0 	call	2157c <__gtdf2>
   1be64:	00828f0e 	bge	zero,r2,1c8a4 <_dtoa_r+0xce4>
   1be68:	d8800617 	ldw	r2,24(sp)
   1be6c:	d8000d15 	stw	zero,52(sp)
   1be70:	10bfffc4 	addi	r2,r2,-1
   1be74:	d8800615 	stw	r2,24(sp)
   1be78:	ad29c83a 	sub	r20,r21,r20
   1be7c:	a53fffc4 	addi	r20,r20,-1
   1be80:	a0026616 	blt	r20,zero,1c81c <_dtoa_r+0xc5c>
   1be84:	dd000715 	stw	r20,28(sp)
   1be88:	d8000815 	stw	zero,32(sp)
   1be8c:	d8800617 	ldw	r2,24(sp)
   1be90:	10025a16 	blt	r2,zero,1c7fc <_dtoa_r+0xc3c>
   1be94:	d8c00717 	ldw	r3,28(sp)
   1be98:	d8800b15 	stw	r2,44(sp)
   1be9c:	d8000a15 	stw	zero,40(sp)
   1bea0:	1887883a 	add	r3,r3,r2
   1bea4:	d8c00715 	stw	r3,28(sp)
   1bea8:	d9c00417 	ldw	r7,16(sp)
   1beac:	00800244 	movi	r2,9
   1beb0:	11c10536 	bltu	r2,r7,1c2c8 <_dtoa_r+0x708>
   1beb4:	00800144 	movi	r2,5
   1beb8:	11c4c60e 	bge	r2,r7,1d1d4 <_dtoa_r+0x1614>
   1bebc:	39ffff04 	addi	r7,r7,-4
   1bec0:	d9c00415 	stw	r7,16(sp)
   1bec4:	0027883a 	mov	r19,zero
   1bec8:	d9c00417 	ldw	r7,16(sp)
   1becc:	008000c4 	movi	r2,3
   1bed0:	3883a226 	beq	r7,r2,1cd5c <_dtoa_r+0x119c>
   1bed4:	11c2bc16 	blt	r2,r7,1c9c8 <_dtoa_r+0xe08>
   1bed8:	00800084 	movi	r2,2
   1bedc:	3880fb1e 	bne	r7,r2,1c2cc <_dtoa_r+0x70c>
   1bee0:	d8000c15 	stw	zero,48(sp)
   1bee4:	d9002117 	ldw	r4,132(sp)
   1bee8:	0103ae0e 	bge	zero,r4,1cda4 <_dtoa_r+0x11e4>
   1beec:	2025883a 	mov	r18,r4
   1bef0:	d9000e15 	stw	r4,56(sp)
   1bef4:	d9000915 	stw	r4,36(sp)
   1bef8:	80001115 	stw	zero,68(r16)
   1befc:	008005c4 	movi	r2,23
   1bf00:	1484b22e 	bgeu	r2,r18,1d1cc <_dtoa_r+0x160c>
   1bf04:	00c00044 	movi	r3,1
   1bf08:	00800104 	movi	r2,4
   1bf0c:	1085883a 	add	r2,r2,r2
   1bf10:	11000504 	addi	r4,r2,20
   1bf14:	180b883a 	mov	r5,r3
   1bf18:	18c00044 	addi	r3,r3,1
   1bf1c:	913ffb2e 	bgeu	r18,r4,1bf0c <_dtoa_r+0x34c>
   1bf20:	81401115 	stw	r5,68(r16)
   1bf24:	8009883a 	mov	r4,r16
   1bf28:	001ed440 	call	1ed44 <_Balloc>
   1bf2c:	102f883a 	mov	r23,r2
   1bf30:	80801015 	stw	r2,64(r16)
   1bf34:	00800384 	movi	r2,14
   1bf38:	1480f036 	bltu	r2,r18,1c2fc <_dtoa_r+0x73c>
   1bf3c:	9800ef26 	beq	r19,zero,1c2fc <_dtoa_r+0x73c>
   1bf40:	d8800617 	ldw	r2,24(sp)
   1bf44:	00839c0e 	bge	zero,r2,1cdb8 <_dtoa_r+0x11f8>
   1bf48:	d8c00617 	ldw	r3,24(sp)
   1bf4c:	108003cc 	andi	r2,r2,15
   1bf50:	100490fa 	slli	r2,r2,3
   1bf54:	182bd13a 	srai	r21,r3,4
   1bf58:	00c000f4 	movhi	r3,3
   1bf5c:	18c51104 	addi	r3,r3,5188
   1bf60:	1885883a 	add	r2,r3,r2
   1bf64:	a8c0040c 	andi	r3,r21,16
   1bf68:	12800017 	ldw	r10,0(r2)
   1bf6c:	15800117 	ldw	r22,4(r2)
   1bf70:	18038726 	beq	r3,zero,1cd90 <_dtoa_r+0x11d0>
   1bf74:	008000f4 	movhi	r2,3
   1bf78:	10850704 	addi	r2,r2,5148
   1bf7c:	11800817 	ldw	r6,32(r2)
   1bf80:	11c00917 	ldw	r7,36(r2)
   1bf84:	d9000317 	ldw	r4,12(sp)
   1bf88:	880b883a 	mov	r5,r17
   1bf8c:	da801515 	stw	r10,84(sp)
   1bf90:	00187e00 	call	187e0 <__divdf3>
   1bf94:	da801517 	ldw	r10,84(sp)
   1bf98:	d8801015 	stw	r2,64(sp)
   1bf9c:	1829883a 	mov	r20,r3
   1bfa0:	ad4003cc 	andi	r21,r21,15
   1bfa4:	048000c4 	movi	r18,3
   1bfa8:	a8001126 	beq	r21,zero,1bff0 <_dtoa_r+0x430>
   1bfac:	04c000f4 	movhi	r19,3
   1bfb0:	9cc50704 	addi	r19,r19,5148
   1bfb4:	5005883a 	mov	r2,r10
   1bfb8:	b007883a 	mov	r3,r22
   1bfbc:	a980004c 	andi	r6,r21,1
   1bfc0:	1009883a 	mov	r4,r2
   1bfc4:	a82bd07a 	srai	r21,r21,1
   1bfc8:	180b883a 	mov	r5,r3
   1bfcc:	30000426 	beq	r6,zero,1bfe0 <_dtoa_r+0x420>
   1bfd0:	99800017 	ldw	r6,0(r19)
   1bfd4:	99c00117 	ldw	r7,4(r19)
   1bfd8:	94800044 	addi	r18,r18,1
   1bfdc:	00184fc0 	call	184fc <__muldf3>
   1bfe0:	9cc00204 	addi	r19,r19,8
   1bfe4:	a83ff51e 	bne	r21,zero,1bfbc <_dtoa_r+0x3fc>
   1bfe8:	1015883a 	mov	r10,r2
   1bfec:	182d883a 	mov	r22,r3
   1bff0:	d9001017 	ldw	r4,64(sp)
   1bff4:	a00b883a 	mov	r5,r20
   1bff8:	500d883a 	mov	r6,r10
   1bffc:	b00f883a 	mov	r7,r22
   1c000:	00187e00 	call	187e0 <__divdf3>
   1c004:	1027883a 	mov	r19,r2
   1c008:	1829883a 	mov	r20,r3
   1c00c:	d8c00d17 	ldw	r3,52(sp)
   1c010:	18000626 	beq	r3,zero,1c02c <_dtoa_r+0x46c>
   1c014:	9809883a 	mov	r4,r19
   1c018:	a00b883a 	mov	r5,r20
   1c01c:	000d883a 	mov	r6,zero
   1c020:	01cffc34 	movhi	r7,16368
   1c024:	00215e00 	call	215e0 <__ltdf2>
   1c028:	10040e16 	blt	r2,zero,1d064 <_dtoa_r+0x14a4>
   1c02c:	9009883a 	mov	r4,r18
   1c030:	002163c0 	call	2163c <__floatsidf>
   1c034:	1009883a 	mov	r4,r2
   1c038:	180b883a 	mov	r5,r3
   1c03c:	980d883a 	mov	r6,r19
   1c040:	a00f883a 	mov	r7,r20
   1c044:	00184fc0 	call	184fc <__muldf3>
   1c048:	1009883a 	mov	r4,r2
   1c04c:	180b883a 	mov	r5,r3
   1c050:	000d883a 	mov	r6,zero
   1c054:	01d00734 	movhi	r7,16412
   1c058:	00184480 	call	18448 <__adddf3>
   1c05c:	057f3034 	movhi	r21,64704
   1c060:	1d6b883a 	add	r21,r3,r21
   1c064:	d8c00917 	ldw	r3,36(sp)
   1c068:	1025883a 	mov	r18,r2
   1c06c:	18031f26 	beq	r3,zero,1ccec <_dtoa_r+0x112c>
   1c070:	d8800617 	ldw	r2,24(sp)
   1c074:	dac00917 	ldw	r11,36(sp)
   1c078:	d8801315 	stw	r2,76(sp)
   1c07c:	d8c00c17 	ldw	r3,48(sp)
   1c080:	18039026 	beq	r3,zero,1cec4 <_dtoa_r+0x1304>
   1c084:	58bfffc4 	addi	r2,r11,-1
   1c088:	100490fa 	slli	r2,r2,3
   1c08c:	00c000f4 	movhi	r3,3
   1c090:	18c51104 	addi	r3,r3,5188
   1c094:	0009883a 	mov	r4,zero
   1c098:	1885883a 	add	r2,r3,r2
   1c09c:	11800017 	ldw	r6,0(r2)
   1c0a0:	11c00117 	ldw	r7,4(r2)
   1c0a4:	014ff834 	movhi	r5,16352
   1c0a8:	dac01615 	stw	r11,88(sp)
   1c0ac:	00187e00 	call	187e0 <__divdf3>
   1c0b0:	900d883a 	mov	r6,r18
   1c0b4:	a80f883a 	mov	r7,r21
   1c0b8:	1009883a 	mov	r4,r2
   1c0bc:	180b883a 	mov	r5,r3
   1c0c0:	001849c0 	call	1849c <__subdf3>
   1c0c4:	a00b883a 	mov	r5,r20
   1c0c8:	9809883a 	mov	r4,r19
   1c0cc:	182b883a 	mov	r21,r3
   1c0d0:	d8801015 	stw	r2,64(sp)
   1c0d4:	00189f80 	call	189f8 <__fixdfsi>
   1c0d8:	1009883a 	mov	r4,r2
   1c0dc:	d8801515 	stw	r2,84(sp)
   1c0e0:	002163c0 	call	2163c <__floatsidf>
   1c0e4:	9809883a 	mov	r4,r19
   1c0e8:	a00b883a 	mov	r5,r20
   1c0ec:	100d883a 	mov	r6,r2
   1c0f0:	180f883a 	mov	r7,r3
   1c0f4:	001849c0 	call	1849c <__subdf3>
   1c0f8:	da401517 	ldw	r9,84(sp)
   1c0fc:	d9001017 	ldw	r4,64(sp)
   1c100:	a80b883a 	mov	r5,r21
   1c104:	4d000c04 	addi	r20,r9,48
   1c108:	bd000005 	stb	r20,0(r23)
   1c10c:	100d883a 	mov	r6,r2
   1c110:	180f883a 	mov	r7,r3
   1c114:	bd800044 	addi	r22,r23,1
   1c118:	1025883a 	mov	r18,r2
   1c11c:	1827883a 	mov	r19,r3
   1c120:	002157c0 	call	2157c <__gtdf2>
   1c124:	00842216 	blt	zero,r2,1d1b0 <_dtoa_r+0x15f0>
   1c128:	0009883a 	mov	r4,zero
   1c12c:	014ffc34 	movhi	r5,16368
   1c130:	900d883a 	mov	r6,r18
   1c134:	980f883a 	mov	r7,r19
   1c138:	001849c0 	call	1849c <__subdf3>
   1c13c:	d9001017 	ldw	r4,64(sp)
   1c140:	a80b883a 	mov	r5,r21
   1c144:	100d883a 	mov	r6,r2
   1c148:	180f883a 	mov	r7,r3
   1c14c:	002157c0 	call	2157c <__gtdf2>
   1c150:	dac01617 	ldw	r11,88(sp)
   1c154:	00841316 	blt	zero,r2,1d1a4 <_dtoa_r+0x15e4>
   1c158:	00800044 	movi	r2,1
   1c15c:	12c0670e 	bge	r2,r11,1c2fc <_dtoa_r+0x73c>
   1c160:	bad7883a 	add	r11,r23,r11
   1c164:	df001115 	stw	fp,68(sp)
   1c168:	dc401215 	stw	r17,72(sp)
   1c16c:	5839883a 	mov	fp,r11
   1c170:	dc401017 	ldw	r17,64(sp)
   1c174:	00000806 	br	1c198 <_dtoa_r+0x5d8>
   1c178:	001849c0 	call	1849c <__subdf3>
   1c17c:	1009883a 	mov	r4,r2
   1c180:	180b883a 	mov	r5,r3
   1c184:	880d883a 	mov	r6,r17
   1c188:	a80f883a 	mov	r7,r21
   1c18c:	00215e00 	call	215e0 <__ltdf2>
   1c190:	1003ee16 	blt	r2,zero,1d14c <_dtoa_r+0x158c>
   1c194:	b703f126 	beq	r22,fp,1d15c <_dtoa_r+0x159c>
   1c198:	8809883a 	mov	r4,r17
   1c19c:	a80b883a 	mov	r5,r21
   1c1a0:	000d883a 	mov	r6,zero
   1c1a4:	01d00934 	movhi	r7,16420
   1c1a8:	00184fc0 	call	184fc <__muldf3>
   1c1ac:	000d883a 	mov	r6,zero
   1c1b0:	01d00934 	movhi	r7,16420
   1c1b4:	9009883a 	mov	r4,r18
   1c1b8:	980b883a 	mov	r5,r19
   1c1bc:	1023883a 	mov	r17,r2
   1c1c0:	182b883a 	mov	r21,r3
   1c1c4:	00184fc0 	call	184fc <__muldf3>
   1c1c8:	180b883a 	mov	r5,r3
   1c1cc:	1009883a 	mov	r4,r2
   1c1d0:	1825883a 	mov	r18,r3
   1c1d4:	1027883a 	mov	r19,r2
   1c1d8:	00189f80 	call	189f8 <__fixdfsi>
   1c1dc:	1009883a 	mov	r4,r2
   1c1e0:	1029883a 	mov	r20,r2
   1c1e4:	002163c0 	call	2163c <__floatsidf>
   1c1e8:	9809883a 	mov	r4,r19
   1c1ec:	900b883a 	mov	r5,r18
   1c1f0:	100d883a 	mov	r6,r2
   1c1f4:	180f883a 	mov	r7,r3
   1c1f8:	001849c0 	call	1849c <__subdf3>
   1c1fc:	a5000c04 	addi	r20,r20,48
   1c200:	b5000005 	stb	r20,0(r22)
   1c204:	1009883a 	mov	r4,r2
   1c208:	180b883a 	mov	r5,r3
   1c20c:	880d883a 	mov	r6,r17
   1c210:	a80f883a 	mov	r7,r21
   1c214:	1025883a 	mov	r18,r2
   1c218:	1827883a 	mov	r19,r3
   1c21c:	00215e00 	call	215e0 <__ltdf2>
   1c220:	b5800044 	addi	r22,r22,1
   1c224:	0009883a 	mov	r4,zero
   1c228:	014ffc34 	movhi	r5,16368
   1c22c:	900d883a 	mov	r6,r18
   1c230:	980f883a 	mov	r7,r19
   1c234:	103fd00e 	bge	r2,zero,1c178 <_dtoa_r+0x5b8>
   1c238:	d9001317 	ldw	r4,76(sp)
   1c23c:	df001117 	ldw	fp,68(sp)
   1c240:	d9000615 	stw	r4,24(sp)
   1c244:	8009883a 	mov	r4,r16
   1c248:	e00b883a 	mov	r5,fp
   1c24c:	001edec0 	call	1edec <_Bfree>
   1c250:	d9c00617 	ldw	r7,24(sp)
   1c254:	d8c02217 	ldw	r3,136(sp)
   1c258:	d9002417 	ldw	r4,144(sp)
   1c25c:	b0000005 	stb	zero,0(r22)
   1c260:	38800044 	addi	r2,r7,1
   1c264:	18800015 	stw	r2,0(r3)
   1c268:	203e8426 	beq	r4,zero,1bc7c <_dtoa_r+0xbc>
   1c26c:	25800015 	stw	r22,0(r4)
   1c270:	003e8206 	br	1bc7c <_dtoa_r+0xbc>
   1c274:	00800434 	movhi	r2,16
   1c278:	10bfffc4 	addi	r2,r2,-1
   1c27c:	90a4703a 	and	r18,r18,r2
   1c280:	903e901e 	bne	r18,zero,1bcc4 <_dtoa_r+0x104>
   1c284:	05c000f4 	movhi	r23,3
   1c288:	bdc4e904 	addi	r23,r23,5028
   1c28c:	003e8f06 	br	1bccc <_dtoa_r+0x10c>
   1c290:	b8800204 	addi	r2,r23,8
   1c294:	003e9206 	br	1bce0 <_dtoa_r+0x120>
   1c298:	01400434 	movhi	r5,16
   1c29c:	297fffc4 	addi	r5,r5,-1
   1c2a0:	894a703a 	and	r5,r17,r5
   1c2a4:	d9000317 	ldw	r4,12(sp)
   1c2a8:	294ffc34 	orhi	r5,r5,16368
   1c2ac:	a53f0044 	addi	r20,r20,-1023
   1c2b0:	dd400217 	ldw	r21,8(sp)
   1c2b4:	d8000f15 	stw	zero,60(sp)
   1c2b8:	003eb106 	br	1bd80 <_dtoa_r+0x1c0>
   1c2bc:	05c000f4 	movhi	r23,3
   1c2c0:	bdc4e004 	addi	r23,r23,4992
   1c2c4:	003e6d06 	br	1bc7c <_dtoa_r+0xbc>
   1c2c8:	d8000415 	stw	zero,16(sp)
   1c2cc:	80001115 	stw	zero,68(r16)
   1c2d0:	8009883a 	mov	r4,r16
   1c2d4:	000b883a 	mov	r5,zero
   1c2d8:	001ed440 	call	1ed44 <_Balloc>
   1c2dc:	01ffffc4 	movi	r7,-1
   1c2e0:	102f883a 	mov	r23,r2
   1c2e4:	80801015 	stw	r2,64(r16)
   1c2e8:	00800044 	movi	r2,1
   1c2ec:	d9c00915 	stw	r7,36(sp)
   1c2f0:	d8002115 	stw	zero,132(sp)
   1c2f4:	d9c00e15 	stw	r7,56(sp)
   1c2f8:	d8800c15 	stw	r2,48(sp)
   1c2fc:	d8800117 	ldw	r2,4(sp)
   1c300:	10008b16 	blt	r2,zero,1c530 <_dtoa_r+0x970>
   1c304:	d9000617 	ldw	r4,24(sp)
   1c308:	00c00384 	movi	r3,14
   1c30c:	19008816 	blt	r3,r4,1c530 <_dtoa_r+0x970>
   1c310:	200490fa 	slli	r2,r4,3
   1c314:	d9c02117 	ldw	r7,132(sp)
   1c318:	00c000f4 	movhi	r3,3
   1c31c:	18c51104 	addi	r3,r3,5188
   1c320:	1885883a 	add	r2,r3,r2
   1c324:	14800017 	ldw	r18,0(r2)
   1c328:	14c00117 	ldw	r19,4(r2)
   1c32c:	3801c916 	blt	r7,zero,1ca54 <_dtoa_r+0xe94>
   1c330:	d9000317 	ldw	r4,12(sp)
   1c334:	900d883a 	mov	r6,r18
   1c338:	980f883a 	mov	r7,r19
   1c33c:	880b883a 	mov	r5,r17
   1c340:	00187e00 	call	187e0 <__divdf3>
   1c344:	180b883a 	mov	r5,r3
   1c348:	1009883a 	mov	r4,r2
   1c34c:	00189f80 	call	189f8 <__fixdfsi>
   1c350:	1009883a 	mov	r4,r2
   1c354:	102b883a 	mov	r21,r2
   1c358:	002163c0 	call	2163c <__floatsidf>
   1c35c:	1009883a 	mov	r4,r2
   1c360:	180b883a 	mov	r5,r3
   1c364:	900d883a 	mov	r6,r18
   1c368:	980f883a 	mov	r7,r19
   1c36c:	00184fc0 	call	184fc <__muldf3>
   1c370:	d9000317 	ldw	r4,12(sp)
   1c374:	880b883a 	mov	r5,r17
   1c378:	100d883a 	mov	r6,r2
   1c37c:	180f883a 	mov	r7,r3
   1c380:	001849c0 	call	1849c <__subdf3>
   1c384:	d9c00917 	ldw	r7,36(sp)
   1c388:	1009883a 	mov	r4,r2
   1c38c:	a8800c04 	addi	r2,r21,48
   1c390:	b8800005 	stb	r2,0(r23)
   1c394:	01800044 	movi	r6,1
   1c398:	180b883a 	mov	r5,r3
   1c39c:	2005883a 	mov	r2,r4
   1c3a0:	bd800044 	addi	r22,r23,1
   1c3a4:	39803726 	beq	r7,r6,1c484 <_dtoa_r+0x8c4>
   1c3a8:	000d883a 	mov	r6,zero
   1c3ac:	01d00934 	movhi	r7,16420
   1c3b0:	00184fc0 	call	184fc <__muldf3>
   1c3b4:	1009883a 	mov	r4,r2
   1c3b8:	180b883a 	mov	r5,r3
   1c3bc:	000d883a 	mov	r6,zero
   1c3c0:	000f883a 	mov	r7,zero
   1c3c4:	1029883a 	mov	r20,r2
   1c3c8:	1823883a 	mov	r17,r3
   1c3cc:	00214c40 	call	214c4 <__eqdf2>
   1c3d0:	103f9c26 	beq	r2,zero,1c244 <_dtoa_r+0x684>
   1c3d4:	dd400917 	ldw	r21,36(sp)
   1c3d8:	dc000415 	stw	r16,16(sp)
   1c3dc:	00000906 	br	1c404 <_dtoa_r+0x844>
   1c3e0:	00184fc0 	call	184fc <__muldf3>
   1c3e4:	1009883a 	mov	r4,r2
   1c3e8:	180b883a 	mov	r5,r3
   1c3ec:	000d883a 	mov	r6,zero
   1c3f0:	000f883a 	mov	r7,zero
   1c3f4:	1029883a 	mov	r20,r2
   1c3f8:	1823883a 	mov	r17,r3
   1c3fc:	00214c40 	call	214c4 <__eqdf2>
   1c400:	10022926 	beq	r2,zero,1cca8 <_dtoa_r+0x10e8>
   1c404:	900d883a 	mov	r6,r18
   1c408:	980f883a 	mov	r7,r19
   1c40c:	a009883a 	mov	r4,r20
   1c410:	880b883a 	mov	r5,r17
   1c414:	00187e00 	call	187e0 <__divdf3>
   1c418:	180b883a 	mov	r5,r3
   1c41c:	1009883a 	mov	r4,r2
   1c420:	00189f80 	call	189f8 <__fixdfsi>
   1c424:	1009883a 	mov	r4,r2
   1c428:	1021883a 	mov	r16,r2
   1c42c:	002163c0 	call	2163c <__floatsidf>
   1c430:	1009883a 	mov	r4,r2
   1c434:	180b883a 	mov	r5,r3
   1c438:	900d883a 	mov	r6,r18
   1c43c:	980f883a 	mov	r7,r19
   1c440:	00184fc0 	call	184fc <__muldf3>
   1c444:	a009883a 	mov	r4,r20
   1c448:	880b883a 	mov	r5,r17
   1c44c:	100d883a 	mov	r6,r2
   1c450:	180f883a 	mov	r7,r3
   1c454:	001849c0 	call	1849c <__subdf3>
   1c458:	82400c04 	addi	r9,r16,48
   1c45c:	b2400005 	stb	r9,0(r22)
   1c460:	b5800044 	addi	r22,r22,1
   1c464:	b5d3c83a 	sub	r9,r22,r23
   1c468:	000d883a 	mov	r6,zero
   1c46c:	01d00934 	movhi	r7,16420
   1c470:	1009883a 	mov	r4,r2
   1c474:	180b883a 	mov	r5,r3
   1c478:	aa7fd91e 	bne	r21,r9,1c3e0 <_dtoa_r+0x820>
   1c47c:	802b883a 	mov	r21,r16
   1c480:	dc000417 	ldw	r16,16(sp)
   1c484:	1009883a 	mov	r4,r2
   1c488:	180b883a 	mov	r5,r3
   1c48c:	100d883a 	mov	r6,r2
   1c490:	180f883a 	mov	r7,r3
   1c494:	00184480 	call	18448 <__adddf3>
   1c498:	9009883a 	mov	r4,r18
   1c49c:	980b883a 	mov	r5,r19
   1c4a0:	100d883a 	mov	r6,r2
   1c4a4:	180f883a 	mov	r7,r3
   1c4a8:	1023883a 	mov	r17,r2
   1c4ac:	1829883a 	mov	r20,r3
   1c4b0:	00215e00 	call	215e0 <__ltdf2>
   1c4b4:	10000816 	blt	r2,zero,1c4d8 <_dtoa_r+0x918>
   1c4b8:	9009883a 	mov	r4,r18
   1c4bc:	980b883a 	mov	r5,r19
   1c4c0:	880d883a 	mov	r6,r17
   1c4c4:	a00f883a 	mov	r7,r20
   1c4c8:	00214c40 	call	214c4 <__eqdf2>
   1c4cc:	103f5d1e 	bne	r2,zero,1c244 <_dtoa_r+0x684>
   1c4d0:	ad40004c 	andi	r21,r21,1
   1c4d4:	a83f5b26 	beq	r21,zero,1c244 <_dtoa_r+0x684>
   1c4d8:	b53fffc3 	ldbu	r20,-1(r22)
   1c4dc:	b0ffff84 	addi	r3,r22,-2
   1c4e0:	01400e44 	movi	r5,57
   1c4e4:	00000306 	br	1c4f4 <_dtoa_r+0x934>
   1c4e8:	1d000003 	ldbu	r20,0(r3)
   1c4ec:	102d883a 	mov	r22,r2
   1c4f0:	18ffffc4 	addi	r3,r3,-1
   1c4f4:	a1003fcc 	andi	r4,r20,255
   1c4f8:	2100201c 	xori	r4,r4,128
   1c4fc:	213fe004 	addi	r4,r4,-128
   1c500:	b0bfffc4 	addi	r2,r22,-1
   1c504:	2142ca1e 	bne	r4,r5,1d030 <_dtoa_r+0x1470>
   1c508:	b8bff71e 	bne	r23,r2,1c4e8 <_dtoa_r+0x928>
   1c50c:	d8800617 	ldw	r2,24(sp)
   1c510:	05000c44 	movi	r20,49
   1c514:	10800044 	addi	r2,r2,1
   1c518:	d8800615 	stw	r2,24(sp)
   1c51c:	00800c04 	movi	r2,48
   1c520:	b8800005 	stb	r2,0(r23)
   1c524:	b805883a 	mov	r2,r23
   1c528:	15000005 	stb	r20,0(r2)
   1c52c:	003f4506 	br	1c244 <_dtoa_r+0x684>
   1c530:	d9c00c17 	ldw	r7,48(sp)
   1c534:	3800c926 	beq	r7,zero,1c85c <_dtoa_r+0xc9c>
   1c538:	d9c00417 	ldw	r7,16(sp)
   1c53c:	00c00044 	movi	r3,1
   1c540:	19c16c0e 	bge	r3,r7,1caf4 <_dtoa_r+0xf34>
   1c544:	d9000917 	ldw	r4,36(sp)
   1c548:	d9c00a17 	ldw	r7,40(sp)
   1c54c:	24ffffc4 	addi	r19,r4,-1
   1c550:	3cc20716 	blt	r7,r19,1cd70 <_dtoa_r+0x11b0>
   1c554:	3ce7c83a 	sub	r19,r7,r19
   1c558:	d9c00917 	ldw	r7,36(sp)
   1c55c:	3802ae16 	blt	r7,zero,1d018 <_dtoa_r+0x1458>
   1c560:	dc800817 	ldw	r18,32(sp)
   1c564:	d8800917 	ldw	r2,36(sp)
   1c568:	d8c00817 	ldw	r3,32(sp)
   1c56c:	d9c00717 	ldw	r7,28(sp)
   1c570:	8009883a 	mov	r4,r16
   1c574:	1887883a 	add	r3,r3,r2
   1c578:	388f883a 	add	r7,r7,r2
   1c57c:	01400044 	movi	r5,1
   1c580:	d8c00815 	stw	r3,32(sp)
   1c584:	d9c00715 	stw	r7,28(sp)
   1c588:	001f1440 	call	1f144 <__i2b>
   1c58c:	102b883a 	mov	r21,r2
   1c590:	90000a26 	beq	r18,zero,1c5bc <_dtoa_r+0x9fc>
   1c594:	d8800717 	ldw	r2,28(sp)
   1c598:	0080080e 	bge	zero,r2,1c5bc <_dtoa_r+0x9fc>
   1c59c:	90812b16 	blt	r18,r2,1ca4c <_dtoa_r+0xe8c>
   1c5a0:	d8c00817 	ldw	r3,32(sp)
   1c5a4:	d9000717 	ldw	r4,28(sp)
   1c5a8:	90a5c83a 	sub	r18,r18,r2
   1c5ac:	1887c83a 	sub	r3,r3,r2
   1c5b0:	2089c83a 	sub	r4,r4,r2
   1c5b4:	d8c00815 	stw	r3,32(sp)
   1c5b8:	d9000715 	stw	r4,28(sp)
   1c5bc:	d9c00a17 	ldw	r7,40(sp)
   1c5c0:	01c0140e 	bge	zero,r7,1c614 <_dtoa_r+0xa54>
   1c5c4:	d8800c17 	ldw	r2,48(sp)
   1c5c8:	1001de26 	beq	r2,zero,1cd44 <_dtoa_r+0x1184>
   1c5cc:	04c00e0e 	bge	zero,r19,1c608 <_dtoa_r+0xa48>
   1c5d0:	a80b883a 	mov	r5,r21
   1c5d4:	8009883a 	mov	r4,r16
   1c5d8:	980d883a 	mov	r6,r19
   1c5dc:	001f3600 	call	1f360 <__pow5mult>
   1c5e0:	e00d883a 	mov	r6,fp
   1c5e4:	8009883a 	mov	r4,r16
   1c5e8:	100b883a 	mov	r5,r2
   1c5ec:	102b883a 	mov	r21,r2
   1c5f0:	001f1800 	call	1f180 <__multiply>
   1c5f4:	1029883a 	mov	r20,r2
   1c5f8:	e00b883a 	mov	r5,fp
   1c5fc:	8009883a 	mov	r4,r16
   1c600:	001edec0 	call	1edec <_Bfree>
   1c604:	a039883a 	mov	fp,r20
   1c608:	d8c00a17 	ldw	r3,40(sp)
   1c60c:	1ccdc83a 	sub	r6,r3,r19
   1c610:	3001291e 	bne	r6,zero,1cab8 <_dtoa_r+0xef8>
   1c614:	8009883a 	mov	r4,r16
   1c618:	01400044 	movi	r5,1
   1c61c:	001f1440 	call	1f144 <__i2b>
   1c620:	d9000b17 	ldw	r4,44(sp)
   1c624:	1029883a 	mov	r20,r2
   1c628:	0100050e 	bge	zero,r4,1c640 <_dtoa_r+0xa80>
   1c62c:	d9800b17 	ldw	r6,44(sp)
   1c630:	8009883a 	mov	r4,r16
   1c634:	100b883a 	mov	r5,r2
   1c638:	001f3600 	call	1f360 <__pow5mult>
   1c63c:	1029883a 	mov	r20,r2
   1c640:	d9c00417 	ldw	r7,16(sp)
   1c644:	00800044 	movi	r2,1
   1c648:	11c0f00e 	bge	r2,r7,1ca0c <_dtoa_r+0xe4c>
   1c64c:	0023883a 	mov	r17,zero
   1c650:	d8800b17 	ldw	r2,44(sp)
   1c654:	1001741e 	bne	r2,zero,1cc28 <_dtoa_r+0x1068>
   1c658:	00800044 	movi	r2,1
   1c65c:	d8c00717 	ldw	r3,28(sp)
   1c660:	10c5883a 	add	r2,r2,r3
   1c664:	108007cc 	andi	r2,r2,31
   1c668:	10008026 	beq	r2,zero,1c86c <_dtoa_r+0xcac>
   1c66c:	01000804 	movi	r4,32
   1c670:	2089c83a 	sub	r4,r4,r2
   1c674:	00c00104 	movi	r3,4
   1c678:	1902d00e 	bge	r3,r4,1d1bc <_dtoa_r+0x15fc>
   1c67c:	d9000817 	ldw	r4,32(sp)
   1c680:	d9c00717 	ldw	r7,28(sp)
   1c684:	00c00704 	movi	r3,28
   1c688:	1885c83a 	sub	r2,r3,r2
   1c68c:	2089883a 	add	r4,r4,r2
   1c690:	388f883a 	add	r7,r7,r2
   1c694:	d9000815 	stw	r4,32(sp)
   1c698:	90a5883a 	add	r18,r18,r2
   1c69c:	d9c00715 	stw	r7,28(sp)
   1c6a0:	d9c00817 	ldw	r7,32(sp)
   1c6a4:	01c0050e 	bge	zero,r7,1c6bc <_dtoa_r+0xafc>
   1c6a8:	e00b883a 	mov	r5,fp
   1c6ac:	8009883a 	mov	r4,r16
   1c6b0:	380d883a 	mov	r6,r7
   1c6b4:	001f48c0 	call	1f48c <__lshift>
   1c6b8:	1039883a 	mov	fp,r2
   1c6bc:	d8800717 	ldw	r2,28(sp)
   1c6c0:	0080050e 	bge	zero,r2,1c6d8 <_dtoa_r+0xb18>
   1c6c4:	a00b883a 	mov	r5,r20
   1c6c8:	8009883a 	mov	r4,r16
   1c6cc:	100d883a 	mov	r6,r2
   1c6d0:	001f48c0 	call	1f48c <__lshift>
   1c6d4:	1029883a 	mov	r20,r2
   1c6d8:	d8c00d17 	ldw	r3,52(sp)
   1c6dc:	1801401e 	bne	r3,zero,1cbe0 <_dtoa_r+0x1020>
   1c6e0:	d8800917 	ldw	r2,36(sp)
   1c6e4:	00815a0e 	bge	zero,r2,1cc50 <_dtoa_r+0x1090>
   1c6e8:	d8c00c17 	ldw	r3,48(sp)
   1c6ec:	18006f1e 	bne	r3,zero,1c8ac <_dtoa_r+0xcec>
   1c6f0:	b823883a 	mov	r17,r23
   1c6f4:	dc800917 	ldw	r18,36(sp)
   1c6f8:	00000206 	br	1c704 <_dtoa_r+0xb44>
   1c6fc:	001ee140 	call	1ee14 <__multadd>
   1c700:	1039883a 	mov	fp,r2
   1c704:	e009883a 	mov	r4,fp
   1c708:	a00b883a 	mov	r5,r20
   1c70c:	001b9b80 	call	1b9b8 <quorem>
   1c710:	10800c04 	addi	r2,r2,48
   1c714:	88800005 	stb	r2,0(r17)
   1c718:	8c400044 	addi	r17,r17,1
   1c71c:	8dc7c83a 	sub	r3,r17,r23
   1c720:	8009883a 	mov	r4,r16
   1c724:	e00b883a 	mov	r5,fp
   1c728:	01800284 	movi	r6,10
   1c72c:	000f883a 	mov	r7,zero
   1c730:	1cbff216 	blt	r3,r18,1c6fc <_dtoa_r+0xb3c>
   1c734:	dd800917 	ldw	r22,36(sp)
   1c738:	1007883a 	mov	r3,r2
   1c73c:	05823a0e 	bge	zero,r22,1d028 <_dtoa_r+0x1468>
   1c740:	bdad883a 	add	r22,r23,r22
   1c744:	0023883a 	mov	r17,zero
   1c748:	e00b883a 	mov	r5,fp
   1c74c:	01800044 	movi	r6,1
   1c750:	8009883a 	mov	r4,r16
   1c754:	d8c01515 	stw	r3,84(sp)
   1c758:	001f48c0 	call	1f48c <__lshift>
   1c75c:	1009883a 	mov	r4,r2
   1c760:	a00b883a 	mov	r5,r20
   1c764:	1039883a 	mov	fp,r2
   1c768:	001f5e80 	call	1f5e8 <__mcmp>
   1c76c:	d8c01517 	ldw	r3,84(sp)
   1c770:	0080d60e 	bge	zero,r2,1cacc <_dtoa_r+0xf0c>
   1c774:	b13fffc3 	ldbu	r4,-1(r22)
   1c778:	b0ffff84 	addi	r3,r22,-2
   1c77c:	01800e44 	movi	r6,57
   1c780:	00000306 	br	1c790 <_dtoa_r+0xbd0>
   1c784:	19000003 	ldbu	r4,0(r3)
   1c788:	102d883a 	mov	r22,r2
   1c78c:	18ffffc4 	addi	r3,r3,-1
   1c790:	21403fcc 	andi	r5,r4,255
   1c794:	2940201c 	xori	r5,r5,128
   1c798:	297fe004 	addi	r5,r5,-128
   1c79c:	b0bfffc4 	addi	r2,r22,-1
   1c7a0:	2981a71e 	bne	r5,r6,1ce40 <_dtoa_r+0x1280>
   1c7a4:	b8bff71e 	bne	r23,r2,1c784 <_dtoa_r+0xbc4>
   1c7a8:	d8800617 	ldw	r2,24(sp)
   1c7ac:	10800044 	addi	r2,r2,1
   1c7b0:	d8800615 	stw	r2,24(sp)
   1c7b4:	00800c44 	movi	r2,49
   1c7b8:	b8800005 	stb	r2,0(r23)
   1c7bc:	8009883a 	mov	r4,r16
   1c7c0:	a00b883a 	mov	r5,r20
   1c7c4:	001edec0 	call	1edec <_Bfree>
   1c7c8:	a83e9e26 	beq	r21,zero,1c244 <_dtoa_r+0x684>
   1c7cc:	88000426 	beq	r17,zero,1c7e0 <_dtoa_r+0xc20>
   1c7d0:	8d400326 	beq	r17,r21,1c7e0 <_dtoa_r+0xc20>
   1c7d4:	8009883a 	mov	r4,r16
   1c7d8:	880b883a 	mov	r5,r17
   1c7dc:	001edec0 	call	1edec <_Bfree>
   1c7e0:	8009883a 	mov	r4,r16
   1c7e4:	a80b883a 	mov	r5,r21
   1c7e8:	001edec0 	call	1edec <_Bfree>
   1c7ec:	003e9506 	br	1c244 <_dtoa_r+0x684>
   1c7f0:	00c00044 	movi	r3,1
   1c7f4:	d8c00d15 	stw	r3,52(sp)
   1c7f8:	003d9f06 	br	1be78 <_dtoa_r+0x2b8>
   1c7fc:	d9000817 	ldw	r4,32(sp)
   1c800:	d8800617 	ldw	r2,24(sp)
   1c804:	d8000b15 	stw	zero,44(sp)
   1c808:	2089c83a 	sub	r4,r4,r2
   1c80c:	0087c83a 	sub	r3,zero,r2
   1c810:	d9000815 	stw	r4,32(sp)
   1c814:	d8c00a15 	stw	r3,40(sp)
   1c818:	003da306 	br	1bea8 <_dtoa_r+0x2e8>
   1c81c:	0529c83a 	sub	r20,zero,r20
   1c820:	dd000815 	stw	r20,32(sp)
   1c824:	d8000715 	stw	zero,28(sp)
   1c828:	003d9806 	br	1be8c <_dtoa_r+0x2cc>
   1c82c:	d9000617 	ldw	r4,24(sp)
   1c830:	002163c0 	call	2163c <__floatsidf>
   1c834:	1009883a 	mov	r4,r2
   1c838:	180b883a 	mov	r5,r3
   1c83c:	980d883a 	mov	r6,r19
   1c840:	900f883a 	mov	r7,r18
   1c844:	00215200 	call	21520 <__nedf2>
   1c848:	103d7a26 	beq	r2,zero,1be34 <_dtoa_r+0x274>
   1c84c:	d8800617 	ldw	r2,24(sp)
   1c850:	10bfffc4 	addi	r2,r2,-1
   1c854:	d8800615 	stw	r2,24(sp)
   1c858:	003d7606 	br	1be34 <_dtoa_r+0x274>
   1c85c:	dcc00a17 	ldw	r19,40(sp)
   1c860:	dc800817 	ldw	r18,32(sp)
   1c864:	002b883a 	mov	r21,zero
   1c868:	003f4906 	br	1c590 <_dtoa_r+0x9d0>
   1c86c:	00800704 	movi	r2,28
   1c870:	d8c00817 	ldw	r3,32(sp)
   1c874:	d9000717 	ldw	r4,28(sp)
   1c878:	90a5883a 	add	r18,r18,r2
   1c87c:	1887883a 	add	r3,r3,r2
   1c880:	2089883a 	add	r4,r4,r2
   1c884:	d8c00815 	stw	r3,32(sp)
   1c888:	d9000715 	stw	r4,28(sp)
   1c88c:	003f8406 	br	1c6a0 <_dtoa_r+0xae0>
   1c890:	d9c00317 	ldw	r7,12(sp)
   1c894:	013efb84 	movi	r4,-1042
   1c898:	2509c83a 	sub	r4,r4,r20
   1c89c:	3908983a 	sll	r4,r7,r4
   1c8a0:	003d3006 	br	1bd64 <_dtoa_r+0x1a4>
   1c8a4:	d8000d15 	stw	zero,52(sp)
   1c8a8:	003d7306 	br	1be78 <_dtoa_r+0x2b8>
   1c8ac:	0480050e 	bge	zero,r18,1c8c4 <_dtoa_r+0xd04>
   1c8b0:	a80b883a 	mov	r5,r21
   1c8b4:	8009883a 	mov	r4,r16
   1c8b8:	900d883a 	mov	r6,r18
   1c8bc:	001f48c0 	call	1f48c <__lshift>
   1c8c0:	102b883a 	mov	r21,r2
   1c8c4:	8801611e 	bne	r17,zero,1ce4c <_dtoa_r+0x128c>
   1c8c8:	a827883a 	mov	r19,r21
   1c8cc:	d8c00317 	ldw	r3,12(sp)
   1c8d0:	d9000917 	ldw	r4,36(sp)
   1c8d4:	b8bfffc4 	addi	r2,r23,-1
   1c8d8:	18c0004c 	andi	r3,r3,1
   1c8dc:	1105883a 	add	r2,r2,r4
   1c8e0:	b825883a 	mov	r18,r23
   1c8e4:	d8800515 	stw	r2,20(sp)
   1c8e8:	a823883a 	mov	r17,r21
   1c8ec:	d8c00315 	stw	r3,12(sp)
   1c8f0:	ddc00715 	stw	r23,28(sp)
   1c8f4:	e009883a 	mov	r4,fp
   1c8f8:	a00b883a 	mov	r5,r20
   1c8fc:	001b9b80 	call	1b9b8 <quorem>
   1c900:	e009883a 	mov	r4,fp
   1c904:	880b883a 	mov	r5,r17
   1c908:	102d883a 	mov	r22,r2
   1c90c:	001f5e80 	call	1f5e8 <__mcmp>
   1c910:	980d883a 	mov	r6,r19
   1c914:	8009883a 	mov	r4,r16
   1c918:	a00b883a 	mov	r5,r20
   1c91c:	102b883a 	mov	r21,r2
   1c920:	001f6400 	call	1f640 <__mdiff>
   1c924:	100d883a 	mov	r6,r2
   1c928:	10800317 	ldw	r2,12(r2)
   1c92c:	b5c00c04 	addi	r23,r22,48
   1c930:	10008c26 	beq	r2,zero,1cb64 <_dtoa_r+0xfa4>
   1c934:	8009883a 	mov	r4,r16
   1c938:	300b883a 	mov	r5,r6
   1c93c:	001edec0 	call	1edec <_Bfree>
   1c940:	00800044 	movi	r2,1
   1c944:	a8007116 	blt	r21,zero,1cb0c <_dtoa_r+0xf4c>
   1c948:	a800041e 	bne	r21,zero,1c95c <_dtoa_r+0xd9c>
   1c94c:	d9c00417 	ldw	r7,16(sp)
   1c950:	3800021e 	bne	r7,zero,1c95c <_dtoa_r+0xd9c>
   1c954:	d8c00317 	ldw	r3,12(sp)
   1c958:	18006c26 	beq	r3,zero,1cb0c <_dtoa_r+0xf4c>
   1c95c:	00814c16 	blt	zero,r2,1ce90 <_dtoa_r+0x12d0>
   1c960:	d8c00517 	ldw	r3,20(sp)
   1c964:	95400044 	addi	r21,r18,1
   1c968:	95c00005 	stb	r23,0(r18)
   1c96c:	a82d883a 	mov	r22,r21
   1c970:	90c14d26 	beq	r18,r3,1cea8 <_dtoa_r+0x12e8>
   1c974:	e00b883a 	mov	r5,fp
   1c978:	8009883a 	mov	r4,r16
   1c97c:	01800284 	movi	r6,10
   1c980:	000f883a 	mov	r7,zero
   1c984:	001ee140 	call	1ee14 <__multadd>
   1c988:	1039883a 	mov	fp,r2
   1c98c:	8cc08b26 	beq	r17,r19,1cbbc <_dtoa_r+0xffc>
   1c990:	880b883a 	mov	r5,r17
   1c994:	01800284 	movi	r6,10
   1c998:	000f883a 	mov	r7,zero
   1c99c:	8009883a 	mov	r4,r16
   1c9a0:	001ee140 	call	1ee14 <__multadd>
   1c9a4:	980b883a 	mov	r5,r19
   1c9a8:	8009883a 	mov	r4,r16
   1c9ac:	01800284 	movi	r6,10
   1c9b0:	000f883a 	mov	r7,zero
   1c9b4:	1023883a 	mov	r17,r2
   1c9b8:	001ee140 	call	1ee14 <__multadd>
   1c9bc:	1027883a 	mov	r19,r2
   1c9c0:	a825883a 	mov	r18,r21
   1c9c4:	003fcb06 	br	1c8f4 <_dtoa_r+0xd34>
   1c9c8:	d9c00417 	ldw	r7,16(sp)
   1c9cc:	00800104 	movi	r2,4
   1c9d0:	3880e426 	beq	r7,r2,1cd64 <_dtoa_r+0x11a4>
   1c9d4:	00800144 	movi	r2,5
   1c9d8:	38be3c1e 	bne	r7,r2,1c2cc <_dtoa_r+0x70c>
   1c9dc:	00c00044 	movi	r3,1
   1c9e0:	d8c00c15 	stw	r3,48(sp)
   1c9e4:	d9c02117 	ldw	r7,132(sp)
   1c9e8:	d8800617 	ldw	r2,24(sp)
   1c9ec:	388f883a 	add	r7,r7,r2
   1c9f0:	3c800044 	addi	r18,r7,1
   1c9f4:	d9c00e15 	stw	r7,56(sp)
   1c9f8:	dc800915 	stw	r18,36(sp)
   1c9fc:	04bd3e16 	blt	zero,r18,1bef8 <_dtoa_r+0x338>
   1ca00:	80001115 	stw	zero,68(r16)
   1ca04:	000b883a 	mov	r5,zero
   1ca08:	003d4606 	br	1bf24 <_dtoa_r+0x364>
   1ca0c:	d8c00317 	ldw	r3,12(sp)
   1ca10:	183f0e1e 	bne	r3,zero,1c64c <_dtoa_r+0xa8c>
   1ca14:	00c00434 	movhi	r3,16
   1ca18:	18ffffc4 	addi	r3,r3,-1
   1ca1c:	88c6703a 	and	r3,r17,r3
   1ca20:	183f0a1e 	bne	r3,zero,1c64c <_dtoa_r+0xa8c>
   1ca24:	8c5ffc2c 	andhi	r17,r17,32752
   1ca28:	883f0826 	beq	r17,zero,1c64c <_dtoa_r+0xa8c>
   1ca2c:	d9000817 	ldw	r4,32(sp)
   1ca30:	d9c00717 	ldw	r7,28(sp)
   1ca34:	1023883a 	mov	r17,r2
   1ca38:	2089883a 	add	r4,r4,r2
   1ca3c:	388f883a 	add	r7,r7,r2
   1ca40:	d9000815 	stw	r4,32(sp)
   1ca44:	d9c00715 	stw	r7,28(sp)
   1ca48:	003f0106 	br	1c650 <_dtoa_r+0xa90>
   1ca4c:	9005883a 	mov	r2,r18
   1ca50:	003ed306 	br	1c5a0 <_dtoa_r+0x9e0>
   1ca54:	d8800917 	ldw	r2,36(sp)
   1ca58:	00be3516 	blt	zero,r2,1c330 <_dtoa_r+0x770>
   1ca5c:	1000b61e 	bne	r2,zero,1cd38 <_dtoa_r+0x1178>
   1ca60:	9009883a 	mov	r4,r18
   1ca64:	980b883a 	mov	r5,r19
   1ca68:	000d883a 	mov	r6,zero
   1ca6c:	01d00534 	movhi	r7,16404
   1ca70:	00184fc0 	call	184fc <__muldf3>
   1ca74:	d9800317 	ldw	r6,12(sp)
   1ca78:	1009883a 	mov	r4,r2
   1ca7c:	180b883a 	mov	r5,r3
   1ca80:	880f883a 	mov	r7,r17
   1ca84:	00189940 	call	18994 <__gedf2>
   1ca88:	0029883a 	mov	r20,zero
   1ca8c:	002b883a 	mov	r21,zero
   1ca90:	10007e16 	blt	r2,zero,1cc8c <_dtoa_r+0x10cc>
   1ca94:	d8802117 	ldw	r2,132(sp)
   1ca98:	b82d883a 	mov	r22,r23
   1ca9c:	0084303a 	nor	r2,zero,r2
   1caa0:	d8800615 	stw	r2,24(sp)
   1caa4:	8009883a 	mov	r4,r16
   1caa8:	a00b883a 	mov	r5,r20
   1caac:	001edec0 	call	1edec <_Bfree>
   1cab0:	a83f4b1e 	bne	r21,zero,1c7e0 <_dtoa_r+0xc20>
   1cab4:	003de306 	br	1c244 <_dtoa_r+0x684>
   1cab8:	e00b883a 	mov	r5,fp
   1cabc:	8009883a 	mov	r4,r16
   1cac0:	001f3600 	call	1f360 <__pow5mult>
   1cac4:	1039883a 	mov	fp,r2
   1cac8:	003ed206 	br	1c614 <_dtoa_r+0xa54>
   1cacc:	1000021e 	bne	r2,zero,1cad8 <_dtoa_r+0xf18>
   1cad0:	18c0004c 	andi	r3,r3,1
   1cad4:	183f271e 	bne	r3,zero,1c774 <_dtoa_r+0xbb4>
   1cad8:	01000c04 	movi	r4,48
   1cadc:	00000106 	br	1cae4 <_dtoa_r+0xf24>
   1cae0:	102d883a 	mov	r22,r2
   1cae4:	b0bfffc4 	addi	r2,r22,-1
   1cae8:	10c00007 	ldb	r3,0(r2)
   1caec:	193ffc26 	beq	r3,r4,1cae0 <_dtoa_r+0xf20>
   1caf0:	003f3206 	br	1c7bc <_dtoa_r+0xbfc>
   1caf4:	d8c00f17 	ldw	r3,60(sp)
   1caf8:	18015026 	beq	r3,zero,1d03c <_dtoa_r+0x147c>
   1cafc:	10810cc4 	addi	r2,r2,1075
   1cb00:	dcc00a17 	ldw	r19,40(sp)
   1cb04:	dc800817 	ldw	r18,32(sp)
   1cb08:	003e9706 	br	1c568 <_dtoa_r+0x9a8>
   1cb0c:	b807883a 	mov	r3,r23
   1cb10:	182b883a 	mov	r21,r3
   1cb14:	ddc00717 	ldw	r23,28(sp)
   1cb18:	00800e0e 	bge	zero,r2,1cb54 <_dtoa_r+0xf94>
   1cb1c:	e00b883a 	mov	r5,fp
   1cb20:	01800044 	movi	r6,1
   1cb24:	8009883a 	mov	r4,r16
   1cb28:	d8c01515 	stw	r3,84(sp)
   1cb2c:	001f48c0 	call	1f48c <__lshift>
   1cb30:	1009883a 	mov	r4,r2
   1cb34:	a00b883a 	mov	r5,r20
   1cb38:	1039883a 	mov	fp,r2
   1cb3c:	001f5e80 	call	1f5e8 <__mcmp>
   1cb40:	d8c01517 	ldw	r3,84(sp)
   1cb44:	0081880e 	bge	zero,r2,1d168 <_dtoa_r+0x15a8>
   1cb48:	00800e44 	movi	r2,57
   1cb4c:	b0c00c44 	addi	r3,r22,49
   1cb50:	a8816326 	beq	r21,r2,1d0e0 <_dtoa_r+0x1520>
   1cb54:	90c00005 	stb	r3,0(r18)
   1cb58:	95800044 	addi	r22,r18,1
   1cb5c:	982b883a 	mov	r21,r19
   1cb60:	003f1606 	br	1c7bc <_dtoa_r+0xbfc>
   1cb64:	300b883a 	mov	r5,r6
   1cb68:	e009883a 	mov	r4,fp
   1cb6c:	d9801515 	stw	r6,84(sp)
   1cb70:	001f5e80 	call	1f5e8 <__mcmp>
   1cb74:	d9801517 	ldw	r6,84(sp)
   1cb78:	8009883a 	mov	r4,r16
   1cb7c:	d8801515 	stw	r2,84(sp)
   1cb80:	300b883a 	mov	r5,r6
   1cb84:	001edec0 	call	1edec <_Bfree>
   1cb88:	d8801517 	ldw	r2,84(sp)
   1cb8c:	103f6d1e 	bne	r2,zero,1c944 <_dtoa_r+0xd84>
   1cb90:	d9c00417 	ldw	r7,16(sp)
   1cb94:	383f6b1e 	bne	r7,zero,1c944 <_dtoa_r+0xd84>
   1cb98:	d8c00317 	ldw	r3,12(sp)
   1cb9c:	183f691e 	bne	r3,zero,1c944 <_dtoa_r+0xd84>
   1cba0:	b807883a 	mov	r3,r23
   1cba4:	00800e44 	movi	r2,57
   1cba8:	ddc00717 	ldw	r23,28(sp)
   1cbac:	18814c26 	beq	r3,r2,1d0e0 <_dtoa_r+0x1520>
   1cbb0:	057fe80e 	bge	zero,r21,1cb54 <_dtoa_r+0xf94>
   1cbb4:	b0c00c44 	addi	r3,r22,49
   1cbb8:	003fe606 	br	1cb54 <_dtoa_r+0xf94>
   1cbbc:	880b883a 	mov	r5,r17
   1cbc0:	8009883a 	mov	r4,r16
   1cbc4:	01800284 	movi	r6,10
   1cbc8:	000f883a 	mov	r7,zero
   1cbcc:	001ee140 	call	1ee14 <__multadd>
   1cbd0:	1023883a 	mov	r17,r2
   1cbd4:	1027883a 	mov	r19,r2
   1cbd8:	a825883a 	mov	r18,r21
   1cbdc:	003f4506 	br	1c8f4 <_dtoa_r+0xd34>
   1cbe0:	e009883a 	mov	r4,fp
   1cbe4:	a00b883a 	mov	r5,r20
   1cbe8:	001f5e80 	call	1f5e8 <__mcmp>
   1cbec:	103ebc0e 	bge	r2,zero,1c6e0 <_dtoa_r+0xb20>
   1cbf0:	e00b883a 	mov	r5,fp
   1cbf4:	8009883a 	mov	r4,r16
   1cbf8:	01800284 	movi	r6,10
   1cbfc:	000f883a 	mov	r7,zero
   1cc00:	001ee140 	call	1ee14 <__multadd>
   1cc04:	1039883a 	mov	fp,r2
   1cc08:	d8800617 	ldw	r2,24(sp)
   1cc0c:	d8c00c17 	ldw	r3,48(sp)
   1cc10:	10bfffc4 	addi	r2,r2,-1
   1cc14:	d8800615 	stw	r2,24(sp)
   1cc18:	1801571e 	bne	r3,zero,1d178 <_dtoa_r+0x15b8>
   1cc1c:	d9c00e17 	ldw	r7,56(sp)
   1cc20:	d9c00915 	stw	r7,36(sp)
   1cc24:	003eae06 	br	1c6e0 <_dtoa_r+0xb20>
   1cc28:	a0800417 	ldw	r2,16(r20)
   1cc2c:	10800104 	addi	r2,r2,4
   1cc30:	1085883a 	add	r2,r2,r2
   1cc34:	1085883a 	add	r2,r2,r2
   1cc38:	a085883a 	add	r2,r20,r2
   1cc3c:	11000017 	ldw	r4,0(r2)
   1cc40:	001f02c0 	call	1f02c <__hi0bits>
   1cc44:	00c00804 	movi	r3,32
   1cc48:	1885c83a 	sub	r2,r3,r2
   1cc4c:	003e8306 	br	1c65c <_dtoa_r+0xa9c>
   1cc50:	d9c00417 	ldw	r7,16(sp)
   1cc54:	00800084 	movi	r2,2
   1cc58:	11fea30e 	bge	r2,r7,1c6e8 <_dtoa_r+0xb28>
   1cc5c:	d8800917 	ldw	r2,36(sp)
   1cc60:	103f8c1e 	bne	r2,zero,1ca94 <_dtoa_r+0xed4>
   1cc64:	a00b883a 	mov	r5,r20
   1cc68:	8009883a 	mov	r4,r16
   1cc6c:	01800144 	movi	r6,5
   1cc70:	000f883a 	mov	r7,zero
   1cc74:	001ee140 	call	1ee14 <__multadd>
   1cc78:	e009883a 	mov	r4,fp
   1cc7c:	100b883a 	mov	r5,r2
   1cc80:	1029883a 	mov	r20,r2
   1cc84:	001f5e80 	call	1f5e8 <__mcmp>
   1cc88:	00bf820e 	bge	zero,r2,1ca94 <_dtoa_r+0xed4>
   1cc8c:	00800c44 	movi	r2,49
   1cc90:	b8800005 	stb	r2,0(r23)
   1cc94:	d8800617 	ldw	r2,24(sp)
   1cc98:	bd800044 	addi	r22,r23,1
   1cc9c:	10800044 	addi	r2,r2,1
   1cca0:	d8800615 	stw	r2,24(sp)
   1cca4:	003f7f06 	br	1caa4 <_dtoa_r+0xee4>
   1cca8:	dc000417 	ldw	r16,16(sp)
   1ccac:	003d6506 	br	1c244 <_dtoa_r+0x684>
   1ccb0:	9009883a 	mov	r4,r18
   1ccb4:	002163c0 	call	2163c <__floatsidf>
   1ccb8:	1009883a 	mov	r4,r2
   1ccbc:	180b883a 	mov	r5,r3
   1ccc0:	980d883a 	mov	r6,r19
   1ccc4:	a00f883a 	mov	r7,r20
   1ccc8:	00184fc0 	call	184fc <__muldf3>
   1cccc:	1009883a 	mov	r4,r2
   1ccd0:	180b883a 	mov	r5,r3
   1ccd4:	000d883a 	mov	r6,zero
   1ccd8:	01d00734 	movhi	r7,16412
   1ccdc:	00184480 	call	18448 <__adddf3>
   1cce0:	057f3034 	movhi	r21,64704
   1cce4:	1025883a 	mov	r18,r2
   1cce8:	1d6b883a 	add	r21,r3,r21
   1ccec:	9809883a 	mov	r4,r19
   1ccf0:	a00b883a 	mov	r5,r20
   1ccf4:	000d883a 	mov	r6,zero
   1ccf8:	01d00534 	movhi	r7,16404
   1ccfc:	001849c0 	call	1849c <__subdf3>
   1cd00:	1009883a 	mov	r4,r2
   1cd04:	180b883a 	mov	r5,r3
   1cd08:	900d883a 	mov	r6,r18
   1cd0c:	a80f883a 	mov	r7,r21
   1cd10:	1027883a 	mov	r19,r2
   1cd14:	1829883a 	mov	r20,r3
   1cd18:	002157c0 	call	2157c <__gtdf2>
   1cd1c:	00806616 	blt	zero,r2,1ceb8 <_dtoa_r+0x12f8>
   1cd20:	a9e0003c 	xorhi	r7,r21,32768
   1cd24:	9809883a 	mov	r4,r19
   1cd28:	a00b883a 	mov	r5,r20
   1cd2c:	900d883a 	mov	r6,r18
   1cd30:	00215e00 	call	215e0 <__ltdf2>
   1cd34:	103d710e 	bge	r2,zero,1c2fc <_dtoa_r+0x73c>
   1cd38:	0029883a 	mov	r20,zero
   1cd3c:	002b883a 	mov	r21,zero
   1cd40:	003f5406 	br	1ca94 <_dtoa_r+0xed4>
   1cd44:	d9800a17 	ldw	r6,40(sp)
   1cd48:	e00b883a 	mov	r5,fp
   1cd4c:	8009883a 	mov	r4,r16
   1cd50:	001f3600 	call	1f360 <__pow5mult>
   1cd54:	1039883a 	mov	fp,r2
   1cd58:	003e2e06 	br	1c614 <_dtoa_r+0xa54>
   1cd5c:	d8000c15 	stw	zero,48(sp)
   1cd60:	003f2006 	br	1c9e4 <_dtoa_r+0xe24>
   1cd64:	00800044 	movi	r2,1
   1cd68:	d8800c15 	stw	r2,48(sp)
   1cd6c:	003c5d06 	br	1bee4 <_dtoa_r+0x324>
   1cd70:	d8c00a17 	ldw	r3,40(sp)
   1cd74:	d9000b17 	ldw	r4,44(sp)
   1cd78:	dcc00a15 	stw	r19,40(sp)
   1cd7c:	98c5c83a 	sub	r2,r19,r3
   1cd80:	2089883a 	add	r4,r4,r2
   1cd84:	d9000b15 	stw	r4,44(sp)
   1cd88:	0027883a 	mov	r19,zero
   1cd8c:	003df206 	br	1c558 <_dtoa_r+0x998>
   1cd90:	d9000317 	ldw	r4,12(sp)
   1cd94:	8829883a 	mov	r20,r17
   1cd98:	04800084 	movi	r18,2
   1cd9c:	d9001015 	stw	r4,64(sp)
   1cda0:	003c8106 	br	1bfa8 <_dtoa_r+0x3e8>
   1cda4:	04800044 	movi	r18,1
   1cda8:	dc800e15 	stw	r18,56(sp)
   1cdac:	dc800915 	stw	r18,36(sp)
   1cdb0:	dc802115 	stw	r18,132(sp)
   1cdb4:	003f1206 	br	1ca00 <_dtoa_r+0xe40>
   1cdb8:	d8800617 	ldw	r2,24(sp)
   1cdbc:	00abc83a 	sub	r21,zero,r2
   1cdc0:	a800a426 	beq	r21,zero,1d054 <_dtoa_r+0x1494>
   1cdc4:	a88003cc 	andi	r2,r21,15
   1cdc8:	100490fa 	slli	r2,r2,3
   1cdcc:	00c000f4 	movhi	r3,3
   1cdd0:	18c51104 	addi	r3,r3,5188
   1cdd4:	d9000317 	ldw	r4,12(sp)
   1cdd8:	1885883a 	add	r2,r3,r2
   1cddc:	11800017 	ldw	r6,0(r2)
   1cde0:	11c00117 	ldw	r7,4(r2)
   1cde4:	a82bd13a 	srai	r21,r21,4
   1cde8:	880b883a 	mov	r5,r17
   1cdec:	00184fc0 	call	184fc <__muldf3>
   1cdf0:	1027883a 	mov	r19,r2
   1cdf4:	1829883a 	mov	r20,r3
   1cdf8:	a800e826 	beq	r21,zero,1d19c <_dtoa_r+0x15dc>
   1cdfc:	058000f4 	movhi	r22,3
   1ce00:	b5850704 	addi	r22,r22,5148
   1ce04:	04800084 	movi	r18,2
   1ce08:	a980004c 	andi	r6,r21,1
   1ce0c:	1009883a 	mov	r4,r2
   1ce10:	a82bd07a 	srai	r21,r21,1
   1ce14:	180b883a 	mov	r5,r3
   1ce18:	30000426 	beq	r6,zero,1ce2c <_dtoa_r+0x126c>
   1ce1c:	b1800017 	ldw	r6,0(r22)
   1ce20:	b1c00117 	ldw	r7,4(r22)
   1ce24:	94800044 	addi	r18,r18,1
   1ce28:	00184fc0 	call	184fc <__muldf3>
   1ce2c:	b5800204 	addi	r22,r22,8
   1ce30:	a83ff51e 	bne	r21,zero,1ce08 <_dtoa_r+0x1248>
   1ce34:	1027883a 	mov	r19,r2
   1ce38:	1829883a 	mov	r20,r3
   1ce3c:	003c7306 	br	1c00c <_dtoa_r+0x44c>
   1ce40:	21000044 	addi	r4,r4,1
   1ce44:	11000005 	stb	r4,0(r2)
   1ce48:	003e5c06 	br	1c7bc <_dtoa_r+0xbfc>
   1ce4c:	a9400117 	ldw	r5,4(r21)
   1ce50:	8009883a 	mov	r4,r16
   1ce54:	001ed440 	call	1ed44 <_Balloc>
   1ce58:	a9800417 	ldw	r6,16(r21)
   1ce5c:	11000304 	addi	r4,r2,12
   1ce60:	a9400304 	addi	r5,r21,12
   1ce64:	31800084 	addi	r6,r6,2
   1ce68:	318d883a 	add	r6,r6,r6
   1ce6c:	318d883a 	add	r6,r6,r6
   1ce70:	1023883a 	mov	r17,r2
   1ce74:	00191f00 	call	191f0 <memcpy>
   1ce78:	8009883a 	mov	r4,r16
   1ce7c:	880b883a 	mov	r5,r17
   1ce80:	01800044 	movi	r6,1
   1ce84:	001f48c0 	call	1f48c <__lshift>
   1ce88:	1027883a 	mov	r19,r2
   1ce8c:	003e8f06 	br	1c8cc <_dtoa_r+0xd0c>
   1ce90:	b807883a 	mov	r3,r23
   1ce94:	00800e44 	movi	r2,57
   1ce98:	ddc00717 	ldw	r23,28(sp)
   1ce9c:	18809026 	beq	r3,r2,1d0e0 <_dtoa_r+0x1520>
   1cea0:	18c00044 	addi	r3,r3,1
   1cea4:	003f2b06 	br	1cb54 <_dtoa_r+0xf94>
   1cea8:	b807883a 	mov	r3,r23
   1ceac:	982b883a 	mov	r21,r19
   1ceb0:	ddc00717 	ldw	r23,28(sp)
   1ceb4:	003e2406 	br	1c748 <_dtoa_r+0xb88>
   1ceb8:	0029883a 	mov	r20,zero
   1cebc:	002b883a 	mov	r21,zero
   1cec0:	003f7206 	br	1cc8c <_dtoa_r+0x10cc>
   1cec4:	593fffc4 	addi	r4,r11,-1
   1cec8:	200490fa 	slli	r2,r4,3
   1cecc:	00c000f4 	movhi	r3,3
   1ced0:	18c51104 	addi	r3,r3,5188
   1ced4:	d9001015 	stw	r4,64(sp)
   1ced8:	1885883a 	add	r2,r3,r2
   1cedc:	11000017 	ldw	r4,0(r2)
   1cee0:	11400117 	ldw	r5,4(r2)
   1cee4:	900d883a 	mov	r6,r18
   1cee8:	a80f883a 	mov	r7,r21
   1ceec:	dac01615 	stw	r11,88(sp)
   1cef0:	00184fc0 	call	184fc <__muldf3>
   1cef4:	a00b883a 	mov	r5,r20
   1cef8:	9809883a 	mov	r4,r19
   1cefc:	d8c01215 	stw	r3,72(sp)
   1cf00:	d8801115 	stw	r2,68(sp)
   1cf04:	00189f80 	call	189f8 <__fixdfsi>
   1cf08:	1009883a 	mov	r4,r2
   1cf0c:	1025883a 	mov	r18,r2
   1cf10:	002163c0 	call	2163c <__floatsidf>
   1cf14:	9809883a 	mov	r4,r19
   1cf18:	a00b883a 	mov	r5,r20
   1cf1c:	100d883a 	mov	r6,r2
   1cf20:	180f883a 	mov	r7,r3
   1cf24:	94800c04 	addi	r18,r18,48
   1cf28:	001849c0 	call	1849c <__subdf3>
   1cf2c:	bc800005 	stb	r18,0(r23)
   1cf30:	dac01617 	ldw	r11,88(sp)
   1cf34:	102b883a 	mov	r21,r2
   1cf38:	00800044 	movi	r2,1
   1cf3c:	bd800044 	addi	r22,r23,1
   1cf40:	1815883a 	mov	r10,r3
   1cf44:	58802226 	beq	r11,r2,1cfd0 <_dtoa_r+0x1410>
   1cf48:	bad7883a 	add	r11,r23,r11
   1cf4c:	dc001415 	stw	r16,80(sp)
   1cf50:	a805883a 	mov	r2,r21
   1cf54:	b027883a 	mov	r19,r22
   1cf58:	5821883a 	mov	r16,r11
   1cf5c:	882b883a 	mov	r21,r17
   1cf60:	000d883a 	mov	r6,zero
   1cf64:	01d00934 	movhi	r7,16420
   1cf68:	1009883a 	mov	r4,r2
   1cf6c:	180b883a 	mov	r5,r3
   1cf70:	00184fc0 	call	184fc <__muldf3>
   1cf74:	180b883a 	mov	r5,r3
   1cf78:	1009883a 	mov	r4,r2
   1cf7c:	1829883a 	mov	r20,r3
   1cf80:	1023883a 	mov	r17,r2
   1cf84:	00189f80 	call	189f8 <__fixdfsi>
   1cf88:	1009883a 	mov	r4,r2
   1cf8c:	1025883a 	mov	r18,r2
   1cf90:	002163c0 	call	2163c <__floatsidf>
   1cf94:	8809883a 	mov	r4,r17
   1cf98:	a00b883a 	mov	r5,r20
   1cf9c:	100d883a 	mov	r6,r2
   1cfa0:	180f883a 	mov	r7,r3
   1cfa4:	94800c04 	addi	r18,r18,48
   1cfa8:	001849c0 	call	1849c <__subdf3>
   1cfac:	9cc00044 	addi	r19,r19,1
   1cfb0:	9cbfffc5 	stb	r18,-1(r19)
   1cfb4:	9c3fea1e 	bne	r19,r16,1cf60 <_dtoa_r+0x13a0>
   1cfb8:	1815883a 	mov	r10,r3
   1cfbc:	d8c01017 	ldw	r3,64(sp)
   1cfc0:	dc001417 	ldw	r16,80(sp)
   1cfc4:	a823883a 	mov	r17,r21
   1cfc8:	b0ed883a 	add	r22,r22,r3
   1cfcc:	102b883a 	mov	r21,r2
   1cfd0:	d9001117 	ldw	r4,68(sp)
   1cfd4:	d9401217 	ldw	r5,72(sp)
   1cfd8:	000d883a 	mov	r6,zero
   1cfdc:	01cff834 	movhi	r7,16352
   1cfe0:	da801515 	stw	r10,84(sp)
   1cfe4:	00184480 	call	18448 <__adddf3>
   1cfe8:	da801517 	ldw	r10,84(sp)
   1cfec:	1009883a 	mov	r4,r2
   1cff0:	180b883a 	mov	r5,r3
   1cff4:	500f883a 	mov	r7,r10
   1cff8:	a80d883a 	mov	r6,r21
   1cffc:	00215e00 	call	215e0 <__ltdf2>
   1d000:	da801517 	ldw	r10,84(sp)
   1d004:	10003b0e 	bge	r2,zero,1d0f4 <_dtoa_r+0x1534>
   1d008:	d9c01317 	ldw	r7,76(sp)
   1d00c:	b53fffc3 	ldbu	r20,-1(r22)
   1d010:	d9c00615 	stw	r7,24(sp)
   1d014:	003d3106 	br	1c4dc <_dtoa_r+0x91c>
   1d018:	d8800817 	ldw	r2,32(sp)
   1d01c:	11e5c83a 	sub	r18,r2,r7
   1d020:	0005883a 	mov	r2,zero
   1d024:	003d5006 	br	1c568 <_dtoa_r+0x9a8>
   1d028:	05800044 	movi	r22,1
   1d02c:	003dc406 	br	1c740 <_dtoa_r+0xb80>
   1d030:	a5000044 	addi	r20,r20,1
   1d034:	15000005 	stb	r20,0(r2)
   1d038:	003c8206 	br	1c244 <_dtoa_r+0x684>
   1d03c:	d8800217 	ldw	r2,8(sp)
   1d040:	00c00d84 	movi	r3,54
   1d044:	dcc00a17 	ldw	r19,40(sp)
   1d048:	1885c83a 	sub	r2,r3,r2
   1d04c:	dc800817 	ldw	r18,32(sp)
   1d050:	003d4506 	br	1c568 <_dtoa_r+0x9a8>
   1d054:	dcc00317 	ldw	r19,12(sp)
   1d058:	8829883a 	mov	r20,r17
   1d05c:	04800084 	movi	r18,2
   1d060:	003bea06 	br	1c00c <_dtoa_r+0x44c>
   1d064:	d9000917 	ldw	r4,36(sp)
   1d068:	203f1126 	beq	r4,zero,1ccb0 <_dtoa_r+0x10f0>
   1d06c:	d9c00e17 	ldw	r7,56(sp)
   1d070:	01fca20e 	bge	zero,r7,1c2fc <_dtoa_r+0x73c>
   1d074:	a00b883a 	mov	r5,r20
   1d078:	9809883a 	mov	r4,r19
   1d07c:	000d883a 	mov	r6,zero
   1d080:	01d00934 	movhi	r7,16420
   1d084:	00184fc0 	call	184fc <__muldf3>
   1d088:	91000044 	addi	r4,r18,1
   1d08c:	1027883a 	mov	r19,r2
   1d090:	1829883a 	mov	r20,r3
   1d094:	002163c0 	call	2163c <__floatsidf>
   1d098:	9809883a 	mov	r4,r19
   1d09c:	a00b883a 	mov	r5,r20
   1d0a0:	100d883a 	mov	r6,r2
   1d0a4:	180f883a 	mov	r7,r3
   1d0a8:	00184fc0 	call	184fc <__muldf3>
   1d0ac:	1009883a 	mov	r4,r2
   1d0b0:	180b883a 	mov	r5,r3
   1d0b4:	000d883a 	mov	r6,zero
   1d0b8:	01d00734 	movhi	r7,16412
   1d0bc:	00184480 	call	18448 <__adddf3>
   1d0c0:	1025883a 	mov	r18,r2
   1d0c4:	d8800617 	ldw	r2,24(sp)
   1d0c8:	057f3034 	movhi	r21,64704
   1d0cc:	1d6b883a 	add	r21,r3,r21
   1d0d0:	10bfffc4 	addi	r2,r2,-1
   1d0d4:	d8801315 	stw	r2,76(sp)
   1d0d8:	dac00e17 	ldw	r11,56(sp)
   1d0dc:	003be706 	br	1c07c <_dtoa_r+0x4bc>
   1d0e0:	01000e44 	movi	r4,57
   1d0e4:	91000005 	stb	r4,0(r18)
   1d0e8:	95800044 	addi	r22,r18,1
   1d0ec:	982b883a 	mov	r21,r19
   1d0f0:	003da106 	br	1c778 <_dtoa_r+0xbb8>
   1d0f4:	d9801117 	ldw	r6,68(sp)
   1d0f8:	d9c01217 	ldw	r7,72(sp)
   1d0fc:	0009883a 	mov	r4,zero
   1d100:	014ff834 	movhi	r5,16352
   1d104:	da801515 	stw	r10,84(sp)
   1d108:	001849c0 	call	1849c <__subdf3>
   1d10c:	da801517 	ldw	r10,84(sp)
   1d110:	1009883a 	mov	r4,r2
   1d114:	180b883a 	mov	r5,r3
   1d118:	a80d883a 	mov	r6,r21
   1d11c:	500f883a 	mov	r7,r10
   1d120:	002157c0 	call	2157c <__gtdf2>
   1d124:	00bc750e 	bge	zero,r2,1c2fc <_dtoa_r+0x73c>
   1d128:	01000c04 	movi	r4,48
   1d12c:	00000106 	br	1d134 <_dtoa_r+0x1574>
   1d130:	102d883a 	mov	r22,r2
   1d134:	b0bfffc4 	addi	r2,r22,-1
   1d138:	10c00007 	ldb	r3,0(r2)
   1d13c:	193ffc26 	beq	r3,r4,1d130 <_dtoa_r+0x1570>
   1d140:	d8801317 	ldw	r2,76(sp)
   1d144:	d8800615 	stw	r2,24(sp)
   1d148:	003c3e06 	br	1c244 <_dtoa_r+0x684>
   1d14c:	d9001317 	ldw	r4,76(sp)
   1d150:	df001117 	ldw	fp,68(sp)
   1d154:	d9000615 	stw	r4,24(sp)
   1d158:	003ce006 	br	1c4dc <_dtoa_r+0x91c>
   1d15c:	df001117 	ldw	fp,68(sp)
   1d160:	dc401217 	ldw	r17,72(sp)
   1d164:	003c6506 	br	1c2fc <_dtoa_r+0x73c>
   1d168:	103e7a1e 	bne	r2,zero,1cb54 <_dtoa_r+0xf94>
   1d16c:	1880004c 	andi	r2,r3,1
   1d170:	103e7826 	beq	r2,zero,1cb54 <_dtoa_r+0xf94>
   1d174:	003e7406 	br	1cb48 <_dtoa_r+0xf88>
   1d178:	8009883a 	mov	r4,r16
   1d17c:	a80b883a 	mov	r5,r21
   1d180:	01800284 	movi	r6,10
   1d184:	000f883a 	mov	r7,zero
   1d188:	001ee140 	call	1ee14 <__multadd>
   1d18c:	d9000e17 	ldw	r4,56(sp)
   1d190:	102b883a 	mov	r21,r2
   1d194:	d9000915 	stw	r4,36(sp)
   1d198:	003d5106 	br	1c6e0 <_dtoa_r+0xb20>
   1d19c:	04800084 	movi	r18,2
   1d1a0:	003b9a06 	br	1c00c <_dtoa_r+0x44c>
   1d1a4:	d8c01317 	ldw	r3,76(sp)
   1d1a8:	d8c00615 	stw	r3,24(sp)
   1d1ac:	003ccb06 	br	1c4dc <_dtoa_r+0x91c>
   1d1b0:	d8c01317 	ldw	r3,76(sp)
   1d1b4:	d8c00615 	stw	r3,24(sp)
   1d1b8:	003c2206 	br	1c244 <_dtoa_r+0x684>
   1d1bc:	20fd3826 	beq	r4,r3,1c6a0 <_dtoa_r+0xae0>
   1d1c0:	00c00f04 	movi	r3,60
   1d1c4:	1885c83a 	sub	r2,r3,r2
   1d1c8:	003da906 	br	1c870 <_dtoa_r+0xcb0>
   1d1cc:	000b883a 	mov	r5,zero
   1d1d0:	003b5406 	br	1bf24 <_dtoa_r+0x364>
   1d1d4:	04c00044 	movi	r19,1
   1d1d8:	003b3b06 	br	1bec8 <_dtoa_r+0x308>

0001d1dc <_fflush_r>:
   1d1dc:	defffb04 	addi	sp,sp,-20
   1d1e0:	dcc00315 	stw	r19,12(sp)
   1d1e4:	dc400115 	stw	r17,4(sp)
   1d1e8:	dfc00415 	stw	ra,16(sp)
   1d1ec:	dc800215 	stw	r18,8(sp)
   1d1f0:	dc000015 	stw	r16,0(sp)
   1d1f4:	2027883a 	mov	r19,r4
   1d1f8:	2823883a 	mov	r17,r5
   1d1fc:	20000226 	beq	r4,zero,1d208 <_fflush_r+0x2c>
   1d200:	20800e17 	ldw	r2,56(r4)
   1d204:	10005726 	beq	r2,zero,1d364 <_fflush_r+0x188>
   1d208:	8880030b 	ldhu	r2,12(r17)
   1d20c:	10c0020c 	andi	r3,r2,8
   1d210:	18ffffcc 	andi	r3,r3,65535
   1d214:	18e0001c 	xori	r3,r3,32768
   1d218:	18e00004 	addi	r3,r3,-32768
   1d21c:	1800311e 	bne	r3,zero,1d2e4 <_fflush_r+0x108>
   1d220:	89000117 	ldw	r4,4(r17)
   1d224:	10c20014 	ori	r3,r2,2048
   1d228:	88c0030d 	sth	r3,12(r17)
   1d22c:	180b883a 	mov	r5,r3
   1d230:	0100520e 	bge	zero,r4,1d37c <_fflush_r+0x1a0>
   1d234:	88c00a17 	ldw	r3,40(r17)
   1d238:	18002226 	beq	r3,zero,1d2c4 <_fflush_r+0xe8>
   1d23c:	1084000c 	andi	r2,r2,4096
   1d240:	10bfffcc 	andi	r2,r2,65535
   1d244:	10a0001c 	xori	r2,r2,32768
   1d248:	10a00004 	addi	r2,r2,-32768
   1d24c:	10004e26 	beq	r2,zero,1d388 <_fflush_r+0x1ac>
   1d250:	8c001417 	ldw	r16,80(r17)
   1d254:	2940010c 	andi	r5,r5,4
   1d258:	297fffcc 	andi	r5,r5,65535
   1d25c:	2960001c 	xori	r5,r5,32768
   1d260:	29600004 	addi	r5,r5,-32768
   1d264:	28000626 	beq	r5,zero,1d280 <_fflush_r+0xa4>
   1d268:	89000117 	ldw	r4,4(r17)
   1d26c:	88800c17 	ldw	r2,48(r17)
   1d270:	8121c83a 	sub	r16,r16,r4
   1d274:	10000226 	beq	r2,zero,1d280 <_fflush_r+0xa4>
   1d278:	88800f17 	ldw	r2,60(r17)
   1d27c:	80a1c83a 	sub	r16,r16,r2
   1d280:	89400717 	ldw	r5,28(r17)
   1d284:	9809883a 	mov	r4,r19
   1d288:	800d883a 	mov	r6,r16
   1d28c:	000f883a 	mov	r7,zero
   1d290:	183ee83a 	callr	r3
   1d294:	8080281e 	bne	r16,r2,1d338 <_fflush_r+0x15c>
   1d298:	8880030b 	ldhu	r2,12(r17)
   1d29c:	88c00417 	ldw	r3,16(r17)
   1d2a0:	88000115 	stw	zero,4(r17)
   1d2a4:	113dffcc 	andi	r4,r2,63487
   1d2a8:	1084000c 	andi	r2,r2,4096
   1d2ac:	10bfffcc 	andi	r2,r2,65535
   1d2b0:	10a0001c 	xori	r2,r2,32768
   1d2b4:	8900030d 	sth	r4,12(r17)
   1d2b8:	88c00015 	stw	r3,0(r17)
   1d2bc:	10a00004 	addi	r2,r2,-32768
   1d2c0:	10002c1e 	bne	r2,zero,1d374 <_fflush_r+0x198>
   1d2c4:	0005883a 	mov	r2,zero
   1d2c8:	dfc00417 	ldw	ra,16(sp)
   1d2cc:	dcc00317 	ldw	r19,12(sp)
   1d2d0:	dc800217 	ldw	r18,8(sp)
   1d2d4:	dc400117 	ldw	r17,4(sp)
   1d2d8:	dc000017 	ldw	r16,0(sp)
   1d2dc:	dec00504 	addi	sp,sp,20
   1d2e0:	f800283a 	ret
   1d2e4:	8c800417 	ldw	r18,16(r17)
   1d2e8:	903ff626 	beq	r18,zero,1d2c4 <_fflush_r+0xe8>
   1d2ec:	8c000017 	ldw	r16,0(r17)
   1d2f0:	108000cc 	andi	r2,r2,3
   1d2f4:	8c800015 	stw	r18,0(r17)
   1d2f8:	84a1c83a 	sub	r16,r16,r18
   1d2fc:	10001b1e 	bne	r2,zero,1d36c <_fflush_r+0x190>
   1d300:	88800517 	ldw	r2,20(r17)
   1d304:	88800215 	stw	r2,8(r17)
   1d308:	04000316 	blt	zero,r16,1d318 <_fflush_r+0x13c>
   1d30c:	003fed06 	br	1d2c4 <_fflush_r+0xe8>
   1d310:	90a5883a 	add	r18,r18,r2
   1d314:	043feb0e 	bge	zero,r16,1d2c4 <_fflush_r+0xe8>
   1d318:	88800917 	ldw	r2,36(r17)
   1d31c:	89400717 	ldw	r5,28(r17)
   1d320:	800f883a 	mov	r7,r16
   1d324:	900d883a 	mov	r6,r18
   1d328:	9809883a 	mov	r4,r19
   1d32c:	103ee83a 	callr	r2
   1d330:	80a1c83a 	sub	r16,r16,r2
   1d334:	00bff616 	blt	zero,r2,1d310 <_fflush_r+0x134>
   1d338:	88c0030b 	ldhu	r3,12(r17)
   1d33c:	00bfffc4 	movi	r2,-1
   1d340:	18c01014 	ori	r3,r3,64
   1d344:	88c0030d 	sth	r3,12(r17)
   1d348:	dfc00417 	ldw	ra,16(sp)
   1d34c:	dcc00317 	ldw	r19,12(sp)
   1d350:	dc800217 	ldw	r18,8(sp)
   1d354:	dc400117 	ldw	r17,4(sp)
   1d358:	dc000017 	ldw	r16,0(sp)
   1d35c:	dec00504 	addi	sp,sp,20
   1d360:	f800283a 	ret
   1d364:	001d4840 	call	1d484 <__sinit>
   1d368:	003fa706 	br	1d208 <_fflush_r+0x2c>
   1d36c:	0005883a 	mov	r2,zero
   1d370:	003fe406 	br	1d304 <_fflush_r+0x128>
   1d374:	8c001415 	stw	r16,80(r17)
   1d378:	003fd206 	br	1d2c4 <_fflush_r+0xe8>
   1d37c:	88c00f17 	ldw	r3,60(r17)
   1d380:	00ffac16 	blt	zero,r3,1d234 <_fflush_r+0x58>
   1d384:	003fcf06 	br	1d2c4 <_fflush_r+0xe8>
   1d388:	89400717 	ldw	r5,28(r17)
   1d38c:	9809883a 	mov	r4,r19
   1d390:	000d883a 	mov	r6,zero
   1d394:	01c00044 	movi	r7,1
   1d398:	183ee83a 	callr	r3
   1d39c:	1021883a 	mov	r16,r2
   1d3a0:	00bfffc4 	movi	r2,-1
   1d3a4:	80800326 	beq	r16,r2,1d3b4 <_fflush_r+0x1d8>
   1d3a8:	8940030b 	ldhu	r5,12(r17)
   1d3ac:	88c00a17 	ldw	r3,40(r17)
   1d3b0:	003fa806 	br	1d254 <_fflush_r+0x78>
   1d3b4:	98c00017 	ldw	r3,0(r19)
   1d3b8:	00800744 	movi	r2,29
   1d3bc:	18bfde1e 	bne	r3,r2,1d338 <_fflush_r+0x15c>
   1d3c0:	003fc006 	br	1d2c4 <_fflush_r+0xe8>

0001d3c4 <fflush>:
   1d3c4:	200b883a 	mov	r5,r4
   1d3c8:	20000426 	beq	r4,zero,1d3dc <fflush+0x18>
   1d3cc:	008000f4 	movhi	r2,3
   1d3d0:	10957f04 	addi	r2,r2,22012
   1d3d4:	11000017 	ldw	r4,0(r2)
   1d3d8:	001d1dc1 	jmpi	1d1dc <_fflush_r>
   1d3dc:	008000f4 	movhi	r2,3
   1d3e0:	10957e04 	addi	r2,r2,22008
   1d3e4:	11000017 	ldw	r4,0(r2)
   1d3e8:	014000b4 	movhi	r5,2
   1d3ec:	29747704 	addi	r5,r5,-11812
   1d3f0:	001e0641 	jmpi	1e064 <_fwalk_reent>

0001d3f4 <__fp_lock>:
   1d3f4:	0005883a 	mov	r2,zero
   1d3f8:	f800283a 	ret

0001d3fc <__fp_unlock>:
   1d3fc:	0005883a 	mov	r2,zero
   1d400:	f800283a 	ret

0001d404 <_cleanup_r>:
   1d404:	014000b4 	movhi	r5,2
   1d408:	2941ee04 	addi	r5,r5,1976
   1d40c:	001dfbc1 	jmpi	1dfbc <_fwalk>

0001d410 <__sfmoreglue>:
   1d410:	defffc04 	addi	sp,sp,-16
   1d414:	dc400115 	stw	r17,4(sp)
   1d418:	2c401724 	muli	r17,r5,92
   1d41c:	dc800215 	stw	r18,8(sp)
   1d420:	2825883a 	mov	r18,r5
   1d424:	89400304 	addi	r5,r17,12
   1d428:	dc000015 	stw	r16,0(sp)
   1d42c:	dfc00315 	stw	ra,12(sp)
   1d430:	001e3a00 	call	1e3a0 <_malloc_r>
   1d434:	1021883a 	mov	r16,r2
   1d438:	10000726 	beq	r2,zero,1d458 <__sfmoreglue+0x48>
   1d43c:	11000304 	addi	r4,r2,12
   1d440:	10000015 	stw	zero,0(r2)
   1d444:	14800115 	stw	r18,4(r2)
   1d448:	11000215 	stw	r4,8(r2)
   1d44c:	000b883a 	mov	r5,zero
   1d450:	880d883a 	mov	r6,r17
   1d454:	00192e80 	call	192e8 <memset>
   1d458:	8005883a 	mov	r2,r16
   1d45c:	dfc00317 	ldw	ra,12(sp)
   1d460:	dc800217 	ldw	r18,8(sp)
   1d464:	dc400117 	ldw	r17,4(sp)
   1d468:	dc000017 	ldw	r16,0(sp)
   1d46c:	dec00404 	addi	sp,sp,16
   1d470:	f800283a 	ret

0001d474 <_cleanup>:
   1d474:	008000f4 	movhi	r2,3
   1d478:	10957e04 	addi	r2,r2,22008
   1d47c:	11000017 	ldw	r4,0(r2)
   1d480:	001d4041 	jmpi	1d404 <_cleanup_r>

0001d484 <__sinit>:
   1d484:	20800e17 	ldw	r2,56(r4)
   1d488:	1000401e 	bne	r2,zero,1d58c <__sinit+0x108>
   1d48c:	21400117 	ldw	r5,4(r4)
   1d490:	018000b4 	movhi	r6,2
   1d494:	31b50104 	addi	r6,r6,-11260
   1d498:	20c00217 	ldw	r3,8(r4)
   1d49c:	21800f15 	stw	r6,60(r4)
   1d4a0:	2080bb04 	addi	r2,r4,748
   1d4a4:	02400044 	movi	r9,1
   1d4a8:	018000c4 	movi	r6,3
   1d4ac:	2180b915 	stw	r6,740(r4)
   1d4b0:	2080ba15 	stw	r2,744(r4)
   1d4b4:	22400e15 	stw	r9,56(r4)
   1d4b8:	20800317 	ldw	r2,12(r4)
   1d4bc:	2000b815 	stw	zero,736(r4)
   1d4c0:	020000b4 	movhi	r8,2
   1d4c4:	4200ec04 	addi	r8,r8,944
   1d4c8:	01c000b4 	movhi	r7,2
   1d4cc:	39c10104 	addi	r7,r7,1028
   1d4d0:	018000b4 	movhi	r6,2
   1d4d4:	31812304 	addi	r6,r6,1164
   1d4d8:	010000b4 	movhi	r4,2
   1d4dc:	21013a04 	addi	r4,r4,1256
   1d4e0:	02800104 	movi	r10,4
   1d4e4:	28000015 	stw	zero,0(r5)
   1d4e8:	28000115 	stw	zero,4(r5)
   1d4ec:	28000215 	stw	zero,8(r5)
   1d4f0:	2a80030d 	sth	r10,12(r5)
   1d4f4:	2800038d 	sth	zero,14(r5)
   1d4f8:	28000415 	stw	zero,16(r5)
   1d4fc:	28000515 	stw	zero,20(r5)
   1d500:	28000615 	stw	zero,24(r5)
   1d504:	29400715 	stw	r5,28(r5)
   1d508:	2a000815 	stw	r8,32(r5)
   1d50c:	29c00915 	stw	r7,36(r5)
   1d510:	29800a15 	stw	r6,40(r5)
   1d514:	29000b15 	stw	r4,44(r5)
   1d518:	01400284 	movi	r5,10
   1d51c:	18000015 	stw	zero,0(r3)
   1d520:	18000115 	stw	zero,4(r3)
   1d524:	18000215 	stw	zero,8(r3)
   1d528:	1940030d 	sth	r5,12(r3)
   1d52c:	1a40038d 	sth	r9,14(r3)
   1d530:	18000415 	stw	zero,16(r3)
   1d534:	18000515 	stw	zero,20(r3)
   1d538:	18000615 	stw	zero,24(r3)
   1d53c:	18c00715 	stw	r3,28(r3)
   1d540:	1a000815 	stw	r8,32(r3)
   1d544:	19c00915 	stw	r7,36(r3)
   1d548:	19800a15 	stw	r6,40(r3)
   1d54c:	19000b15 	stw	r4,44(r3)
   1d550:	00c00484 	movi	r3,18
   1d554:	10c0030d 	sth	r3,12(r2)
   1d558:	00c00084 	movi	r3,2
   1d55c:	10000015 	stw	zero,0(r2)
   1d560:	10000115 	stw	zero,4(r2)
   1d564:	10000215 	stw	zero,8(r2)
   1d568:	10c0038d 	sth	r3,14(r2)
   1d56c:	10000415 	stw	zero,16(r2)
   1d570:	10000515 	stw	zero,20(r2)
   1d574:	10000615 	stw	zero,24(r2)
   1d578:	10800715 	stw	r2,28(r2)
   1d57c:	12000815 	stw	r8,32(r2)
   1d580:	11c00915 	stw	r7,36(r2)
   1d584:	11800a15 	stw	r6,40(r2)
   1d588:	11000b15 	stw	r4,44(r2)
   1d58c:	f800283a 	ret

0001d590 <__sfp>:
   1d590:	defffc04 	addi	sp,sp,-16
   1d594:	008000f4 	movhi	r2,3
   1d598:	10957e04 	addi	r2,r2,22008
   1d59c:	dc400115 	stw	r17,4(sp)
   1d5a0:	14400017 	ldw	r17,0(r2)
   1d5a4:	dc800215 	stw	r18,8(sp)
   1d5a8:	dfc00315 	stw	ra,12(sp)
   1d5ac:	88800e17 	ldw	r2,56(r17)
   1d5b0:	dc000015 	stw	r16,0(sp)
   1d5b4:	2025883a 	mov	r18,r4
   1d5b8:	10002826 	beq	r2,zero,1d65c <__sfp+0xcc>
   1d5bc:	8c40b804 	addi	r17,r17,736
   1d5c0:	043fffc4 	movi	r16,-1
   1d5c4:	89400117 	ldw	r5,4(r17)
   1d5c8:	88800217 	ldw	r2,8(r17)
   1d5cc:	297fffc4 	addi	r5,r5,-1
   1d5d0:	28000a16 	blt	r5,zero,1d5fc <__sfp+0x6c>
   1d5d4:	10c0030f 	ldh	r3,12(r2)
   1d5d8:	18000c26 	beq	r3,zero,1d60c <__sfp+0x7c>
   1d5dc:	10c01a04 	addi	r3,r2,104
   1d5e0:	00000206 	br	1d5ec <__sfp+0x5c>
   1d5e4:	19bfe90f 	ldh	r6,-92(r3)
   1d5e8:	30000826 	beq	r6,zero,1d60c <__sfp+0x7c>
   1d5ec:	297fffc4 	addi	r5,r5,-1
   1d5f0:	18bffd04 	addi	r2,r3,-12
   1d5f4:	18c01704 	addi	r3,r3,92
   1d5f8:	2c3ffa1e 	bne	r5,r16,1d5e4 <__sfp+0x54>
   1d5fc:	88800017 	ldw	r2,0(r17)
   1d600:	10001926 	beq	r2,zero,1d668 <__sfp+0xd8>
   1d604:	1023883a 	mov	r17,r2
   1d608:	003fee06 	br	1d5c4 <__sfp+0x34>
   1d60c:	00ffffc4 	movi	r3,-1
   1d610:	10c0038d 	sth	r3,14(r2)
   1d614:	00c00044 	movi	r3,1
   1d618:	10c0030d 	sth	r3,12(r2)
   1d61c:	10000015 	stw	zero,0(r2)
   1d620:	10000215 	stw	zero,8(r2)
   1d624:	10000115 	stw	zero,4(r2)
   1d628:	10000415 	stw	zero,16(r2)
   1d62c:	10000515 	stw	zero,20(r2)
   1d630:	10000615 	stw	zero,24(r2)
   1d634:	10000c15 	stw	zero,48(r2)
   1d638:	10000d15 	stw	zero,52(r2)
   1d63c:	10001115 	stw	zero,68(r2)
   1d640:	10001215 	stw	zero,72(r2)
   1d644:	dfc00317 	ldw	ra,12(sp)
   1d648:	dc800217 	ldw	r18,8(sp)
   1d64c:	dc400117 	ldw	r17,4(sp)
   1d650:	dc000017 	ldw	r16,0(sp)
   1d654:	dec00404 	addi	sp,sp,16
   1d658:	f800283a 	ret
   1d65c:	8809883a 	mov	r4,r17
   1d660:	001d4840 	call	1d484 <__sinit>
   1d664:	003fd506 	br	1d5bc <__sfp+0x2c>
   1d668:	9009883a 	mov	r4,r18
   1d66c:	01400104 	movi	r5,4
   1d670:	001d4100 	call	1d410 <__sfmoreglue>
   1d674:	88800015 	stw	r2,0(r17)
   1d678:	103fe21e 	bne	r2,zero,1d604 <__sfp+0x74>
   1d67c:	00800304 	movi	r2,12
   1d680:	90800015 	stw	r2,0(r18)
   1d684:	0005883a 	mov	r2,zero
   1d688:	003fee06 	br	1d644 <__sfp+0xb4>

0001d68c <__sfp_lock_acquire>:
   1d68c:	f800283a 	ret

0001d690 <__sfp_lock_release>:
   1d690:	f800283a 	ret

0001d694 <__sinit_lock_acquire>:
   1d694:	f800283a 	ret

0001d698 <__sinit_lock_release>:
   1d698:	f800283a 	ret

0001d69c <__fp_lock_all>:
   1d69c:	008000f4 	movhi	r2,3
   1d6a0:	10957f04 	addi	r2,r2,22012
   1d6a4:	11000017 	ldw	r4,0(r2)
   1d6a8:	014000b4 	movhi	r5,2
   1d6ac:	2974fd04 	addi	r5,r5,-11276
   1d6b0:	001dfbc1 	jmpi	1dfbc <_fwalk>

0001d6b4 <__fp_unlock_all>:
   1d6b4:	008000f4 	movhi	r2,3
   1d6b8:	10957f04 	addi	r2,r2,22012
   1d6bc:	11000017 	ldw	r4,0(r2)
   1d6c0:	014000b4 	movhi	r5,2
   1d6c4:	2974ff04 	addi	r5,r5,-11268
   1d6c8:	001dfbc1 	jmpi	1dfbc <_fwalk>

0001d6cc <_malloc_trim_r>:
   1d6cc:	defffb04 	addi	sp,sp,-20
   1d6d0:	dcc00315 	stw	r19,12(sp)
   1d6d4:	dc800215 	stw	r18,8(sp)
   1d6d8:	dc400115 	stw	r17,4(sp)
   1d6dc:	dc000015 	stw	r16,0(sp)
   1d6e0:	2827883a 	mov	r19,r5
   1d6e4:	dfc00415 	stw	ra,16(sp)
   1d6e8:	044000f4 	movhi	r17,3
   1d6ec:	8c4e9e04 	addi	r17,r17,14968
   1d6f0:	2021883a 	mov	r16,r4
   1d6f4:	0021f600 	call	21f60 <__malloc_lock>
   1d6f8:	88800217 	ldw	r2,8(r17)
   1d6fc:	14800117 	ldw	r18,4(r2)
   1d700:	00bfff04 	movi	r2,-4
   1d704:	90a4703a 	and	r18,r18,r2
   1d708:	9083fbc4 	addi	r2,r18,4079
   1d70c:	14e7c83a 	sub	r19,r2,r19
   1d710:	9826d33a 	srli	r19,r19,12
   1d714:	0083ffc4 	movi	r2,4095
   1d718:	9cffffc4 	addi	r19,r19,-1
   1d71c:	9826933a 	slli	r19,r19,12
   1d720:	14c0060e 	bge	r2,r19,1d73c <_malloc_trim_r+0x70>
   1d724:	8009883a 	mov	r4,r16
   1d728:	000b883a 	mov	r5,zero
   1d72c:	002034c0 	call	2034c <_sbrk_r>
   1d730:	88c00217 	ldw	r3,8(r17)
   1d734:	1c87883a 	add	r3,r3,r18
   1d738:	10c00a26 	beq	r2,r3,1d764 <_malloc_trim_r+0x98>
   1d73c:	8009883a 	mov	r4,r16
   1d740:	0021f800 	call	21f80 <__malloc_unlock>
   1d744:	0005883a 	mov	r2,zero
   1d748:	dfc00417 	ldw	ra,16(sp)
   1d74c:	dcc00317 	ldw	r19,12(sp)
   1d750:	dc800217 	ldw	r18,8(sp)
   1d754:	dc400117 	ldw	r17,4(sp)
   1d758:	dc000017 	ldw	r16,0(sp)
   1d75c:	dec00504 	addi	sp,sp,20
   1d760:	f800283a 	ret
   1d764:	8009883a 	mov	r4,r16
   1d768:	04cbc83a 	sub	r5,zero,r19
   1d76c:	002034c0 	call	2034c <_sbrk_r>
   1d770:	00ffffc4 	movi	r3,-1
   1d774:	10c01326 	beq	r2,r3,1d7c4 <_malloc_trim_r+0xf8>
   1d778:	00800134 	movhi	r2,4
   1d77c:	10977104 	addi	r2,r2,24004
   1d780:	11000017 	ldw	r4,0(r2)
   1d784:	88c00217 	ldw	r3,8(r17)
   1d788:	94e5c83a 	sub	r18,r18,r19
   1d78c:	94800054 	ori	r18,r18,1
   1d790:	24e7c83a 	sub	r19,r4,r19
   1d794:	1c800115 	stw	r18,4(r3)
   1d798:	8009883a 	mov	r4,r16
   1d79c:	14c00015 	stw	r19,0(r2)
   1d7a0:	0021f800 	call	21f80 <__malloc_unlock>
   1d7a4:	00800044 	movi	r2,1
   1d7a8:	dfc00417 	ldw	ra,16(sp)
   1d7ac:	dcc00317 	ldw	r19,12(sp)
   1d7b0:	dc800217 	ldw	r18,8(sp)
   1d7b4:	dc400117 	ldw	r17,4(sp)
   1d7b8:	dc000017 	ldw	r16,0(sp)
   1d7bc:	dec00504 	addi	sp,sp,20
   1d7c0:	f800283a 	ret
   1d7c4:	8009883a 	mov	r4,r16
   1d7c8:	000b883a 	mov	r5,zero
   1d7cc:	002034c0 	call	2034c <_sbrk_r>
   1d7d0:	88c00217 	ldw	r3,8(r17)
   1d7d4:	014003c4 	movi	r5,15
   1d7d8:	10c9c83a 	sub	r4,r2,r3
   1d7dc:	293fd70e 	bge	r5,r4,1d73c <_malloc_trim_r+0x70>
   1d7e0:	014000f4 	movhi	r5,3
   1d7e4:	29558104 	addi	r5,r5,22020
   1d7e8:	29400017 	ldw	r5,0(r5)
   1d7ec:	21000054 	ori	r4,r4,1
   1d7f0:	19000115 	stw	r4,4(r3)
   1d7f4:	1145c83a 	sub	r2,r2,r5
   1d7f8:	01400134 	movhi	r5,4
   1d7fc:	29577104 	addi	r5,r5,24004
   1d800:	28800015 	stw	r2,0(r5)
   1d804:	003fcd06 	br	1d73c <_malloc_trim_r+0x70>

0001d808 <_free_r>:
   1d808:	defffd04 	addi	sp,sp,-12
   1d80c:	dc400115 	stw	r17,4(sp)
   1d810:	dc000015 	stw	r16,0(sp)
   1d814:	dfc00215 	stw	ra,8(sp)
   1d818:	2821883a 	mov	r16,r5
   1d81c:	2023883a 	mov	r17,r4
   1d820:	28004b26 	beq	r5,zero,1d950 <_free_r+0x148>
   1d824:	0021f600 	call	21f60 <__malloc_lock>
   1d828:	823fff17 	ldw	r8,-4(r16)
   1d82c:	00bfff84 	movi	r2,-2
   1d830:	81bffe04 	addi	r6,r16,-8
   1d834:	4084703a 	and	r2,r8,r2
   1d838:	3087883a 	add	r3,r6,r2
   1d83c:	014000f4 	movhi	r5,3
   1d840:	294e9e04 	addi	r5,r5,14968
   1d844:	1a400117 	ldw	r9,4(r3)
   1d848:	29000217 	ldw	r4,8(r5)
   1d84c:	01ffff04 	movi	r7,-4
   1d850:	49ce703a 	and	r7,r9,r7
   1d854:	20c06526 	beq	r4,r3,1d9ec <_free_r+0x1e4>
   1d858:	19c00115 	stw	r7,4(r3)
   1d85c:	4200004c 	andi	r8,r8,1
   1d860:	40003026 	beq	r8,zero,1d924 <_free_r+0x11c>
   1d864:	0009883a 	mov	r4,zero
   1d868:	19d1883a 	add	r8,r3,r7
   1d86c:	42000117 	ldw	r8,4(r8)
   1d870:	4200004c 	andi	r8,r8,1
   1d874:	4000061e 	bne	r8,zero,1d890 <_free_r+0x88>
   1d878:	11c5883a 	add	r2,r2,r7
   1d87c:	19c00217 	ldw	r7,8(r3)
   1d880:	20004e26 	beq	r4,zero,1d9bc <_free_r+0x1b4>
   1d884:	18c00317 	ldw	r3,12(r3)
   1d888:	38c00315 	stw	r3,12(r7)
   1d88c:	19c00215 	stw	r7,8(r3)
   1d890:	11c00054 	ori	r7,r2,1
   1d894:	3087883a 	add	r3,r6,r2
   1d898:	31c00115 	stw	r7,4(r6)
   1d89c:	18800015 	stw	r2,0(r3)
   1d8a0:	20001a1e 	bne	r4,zero,1d90c <_free_r+0x104>
   1d8a4:	00c07fc4 	movi	r3,511
   1d8a8:	18802e2e 	bgeu	r3,r2,1d964 <_free_r+0x15c>
   1d8ac:	1006d27a 	srli	r3,r2,9
   1d8b0:	01000104 	movi	r4,4
   1d8b4:	20c06636 	bltu	r4,r3,1da50 <_free_r+0x248>
   1d8b8:	1008d1ba 	srli	r4,r2,6
   1d8bc:	21000e04 	addi	r4,r4,56
   1d8c0:	210f883a 	add	r7,r4,r4
   1d8c4:	39cf883a 	add	r7,r7,r7
   1d8c8:	39cf883a 	add	r7,r7,r7
   1d8cc:	29cf883a 	add	r7,r5,r7
   1d8d0:	38c00217 	ldw	r3,8(r7)
   1d8d4:	014000f4 	movhi	r5,3
   1d8d8:	294e9e04 	addi	r5,r5,14968
   1d8dc:	19c06126 	beq	r3,r7,1da64 <_free_r+0x25c>
   1d8e0:	013fff04 	movi	r4,-4
   1d8e4:	19400117 	ldw	r5,4(r3)
   1d8e8:	290a703a 	and	r5,r5,r4
   1d8ec:	1140022e 	bgeu	r2,r5,1d8f8 <_free_r+0xf0>
   1d8f0:	18c00217 	ldw	r3,8(r3)
   1d8f4:	38fffb1e 	bne	r7,r3,1d8e4 <_free_r+0xdc>
   1d8f8:	18800317 	ldw	r2,12(r3)
   1d8fc:	30800315 	stw	r2,12(r6)
   1d900:	30c00215 	stw	r3,8(r6)
   1d904:	11800215 	stw	r6,8(r2)
   1d908:	19800315 	stw	r6,12(r3)
   1d90c:	8809883a 	mov	r4,r17
   1d910:	dfc00217 	ldw	ra,8(sp)
   1d914:	dc400117 	ldw	r17,4(sp)
   1d918:	dc000017 	ldw	r16,0(sp)
   1d91c:	dec00304 	addi	sp,sp,12
   1d920:	0021f801 	jmpi	21f80 <__malloc_unlock>
   1d924:	813ffe17 	ldw	r4,-8(r16)
   1d928:	2a400204 	addi	r9,r5,8
   1d92c:	310dc83a 	sub	r6,r6,r4
   1d930:	32000217 	ldw	r8,8(r6)
   1d934:	1105883a 	add	r2,r2,r4
   1d938:	42404326 	beq	r8,r9,1da48 <_free_r+0x240>
   1d93c:	32400317 	ldw	r9,12(r6)
   1d940:	0009883a 	mov	r4,zero
   1d944:	42400315 	stw	r9,12(r8)
   1d948:	4a000215 	stw	r8,8(r9)
   1d94c:	003fc606 	br	1d868 <_free_r+0x60>
   1d950:	dfc00217 	ldw	ra,8(sp)
   1d954:	dc400117 	ldw	r17,4(sp)
   1d958:	dc000017 	ldw	r16,0(sp)
   1d95c:	dec00304 	addi	sp,sp,12
   1d960:	f800283a 	ret
   1d964:	1004d0fa 	srli	r2,r2,3
   1d968:	02000044 	movi	r8,1
   1d96c:	29c00117 	ldw	r7,4(r5)
   1d970:	1087883a 	add	r3,r2,r2
   1d974:	18c7883a 	add	r3,r3,r3
   1d978:	1005d0ba 	srai	r2,r2,2
   1d97c:	18c7883a 	add	r3,r3,r3
   1d980:	28c7883a 	add	r3,r5,r3
   1d984:	19000217 	ldw	r4,8(r3)
   1d988:	4084983a 	sll	r2,r8,r2
   1d98c:	30c00315 	stw	r3,12(r6)
   1d990:	31000215 	stw	r4,8(r6)
   1d994:	11c4b03a 	or	r2,r2,r7
   1d998:	21800315 	stw	r6,12(r4)
   1d99c:	8809883a 	mov	r4,r17
   1d9a0:	28800115 	stw	r2,4(r5)
   1d9a4:	19800215 	stw	r6,8(r3)
   1d9a8:	dfc00217 	ldw	ra,8(sp)
   1d9ac:	dc400117 	ldw	r17,4(sp)
   1d9b0:	dc000017 	ldw	r16,0(sp)
   1d9b4:	dec00304 	addi	sp,sp,12
   1d9b8:	0021f801 	jmpi	21f80 <__malloc_unlock>
   1d9bc:	020000f4 	movhi	r8,3
   1d9c0:	420ea004 	addi	r8,r8,14976
   1d9c4:	3a3faf1e 	bne	r7,r8,1d884 <_free_r+0x7c>
   1d9c8:	29800515 	stw	r6,20(r5)
   1d9cc:	29800415 	stw	r6,16(r5)
   1d9d0:	11000054 	ori	r4,r2,1
   1d9d4:	3087883a 	add	r3,r6,r2
   1d9d8:	31c00315 	stw	r7,12(r6)
   1d9dc:	31c00215 	stw	r7,8(r6)
   1d9e0:	31000115 	stw	r4,4(r6)
   1d9e4:	18800015 	stw	r2,0(r3)
   1d9e8:	003fc806 	br	1d90c <_free_r+0x104>
   1d9ec:	4200004c 	andi	r8,r8,1
   1d9f0:	3885883a 	add	r2,r7,r2
   1d9f4:	4000071e 	bne	r8,zero,1da14 <_free_r+0x20c>
   1d9f8:	81fffe17 	ldw	r7,-8(r16)
   1d9fc:	31cdc83a 	sub	r6,r6,r7
   1da00:	30c00317 	ldw	r3,12(r6)
   1da04:	31000217 	ldw	r4,8(r6)
   1da08:	11c5883a 	add	r2,r2,r7
   1da0c:	20c00315 	stw	r3,12(r4)
   1da10:	19000215 	stw	r4,8(r3)
   1da14:	00c000f4 	movhi	r3,3
   1da18:	18d58204 	addi	r3,r3,22024
   1da1c:	18c00017 	ldw	r3,0(r3)
   1da20:	11000054 	ori	r4,r2,1
   1da24:	31000115 	stw	r4,4(r6)
   1da28:	29800215 	stw	r6,8(r5)
   1da2c:	10ffb736 	bltu	r2,r3,1d90c <_free_r+0x104>
   1da30:	008000f4 	movhi	r2,3
   1da34:	109e4804 	addi	r2,r2,31008
   1da38:	11400017 	ldw	r5,0(r2)
   1da3c:	8809883a 	mov	r4,r17
   1da40:	001d6cc0 	call	1d6cc <_malloc_trim_r>
   1da44:	003fb106 	br	1d90c <_free_r+0x104>
   1da48:	01000044 	movi	r4,1
   1da4c:	003f8606 	br	1d868 <_free_r+0x60>
   1da50:	01000504 	movi	r4,20
   1da54:	20c00b36 	bltu	r4,r3,1da84 <_free_r+0x27c>
   1da58:	190016c4 	addi	r4,r3,91
   1da5c:	210f883a 	add	r7,r4,r4
   1da60:	003f9806 	br	1d8c4 <_free_r+0xbc>
   1da64:	2009d0ba 	srai	r4,r4,2
   1da68:	00800044 	movi	r2,1
   1da6c:	29c00117 	ldw	r7,4(r5)
   1da70:	1108983a 	sll	r4,r2,r4
   1da74:	1805883a 	mov	r2,r3
   1da78:	21c8b03a 	or	r4,r4,r7
   1da7c:	29000115 	stw	r4,4(r5)
   1da80:	003f9e06 	br	1d8fc <_free_r+0xf4>
   1da84:	01001504 	movi	r4,84
   1da88:	20c00436 	bltu	r4,r3,1da9c <_free_r+0x294>
   1da8c:	1008d33a 	srli	r4,r2,12
   1da90:	21001b84 	addi	r4,r4,110
   1da94:	210f883a 	add	r7,r4,r4
   1da98:	003f8a06 	br	1d8c4 <_free_r+0xbc>
   1da9c:	01005504 	movi	r4,340
   1daa0:	20c00436 	bltu	r4,r3,1dab4 <_free_r+0x2ac>
   1daa4:	1008d3fa 	srli	r4,r2,15
   1daa8:	21001dc4 	addi	r4,r4,119
   1daac:	210f883a 	add	r7,r4,r4
   1dab0:	003f8406 	br	1d8c4 <_free_r+0xbc>
   1dab4:	01015504 	movi	r4,1364
   1dab8:	20c00436 	bltu	r4,r3,1dacc <_free_r+0x2c4>
   1dabc:	1008d4ba 	srli	r4,r2,18
   1dac0:	21001f04 	addi	r4,r4,124
   1dac4:	210f883a 	add	r7,r4,r4
   1dac8:	003f7e06 	br	1d8c4 <_free_r+0xbc>
   1dacc:	01c03f04 	movi	r7,252
   1dad0:	01001f84 	movi	r4,126
   1dad4:	003f7b06 	br	1d8c4 <_free_r+0xbc>

0001dad8 <__sfvwrite_r>:
   1dad8:	30800217 	ldw	r2,8(r6)
   1dadc:	defff504 	addi	sp,sp,-44
   1dae0:	dd400615 	stw	r21,24(sp)
   1dae4:	dd000515 	stw	r20,20(sp)
   1dae8:	dc000115 	stw	r16,4(sp)
   1daec:	dfc00a15 	stw	ra,40(sp)
   1daf0:	df000915 	stw	fp,36(sp)
   1daf4:	ddc00815 	stw	r23,32(sp)
   1daf8:	dd800715 	stw	r22,28(sp)
   1dafc:	dcc00415 	stw	r19,16(sp)
   1db00:	dc800315 	stw	r18,12(sp)
   1db04:	dc400215 	stw	r17,8(sp)
   1db08:	3029883a 	mov	r20,r6
   1db0c:	202b883a 	mov	r21,r4
   1db10:	2821883a 	mov	r16,r5
   1db14:	10002126 	beq	r2,zero,1db9c <__sfvwrite_r+0xc4>
   1db18:	2880030b 	ldhu	r2,12(r5)
   1db1c:	10c0020c 	andi	r3,r2,8
   1db20:	18ffffcc 	andi	r3,r3,65535
   1db24:	18e0001c 	xori	r3,r3,32768
   1db28:	18e00004 	addi	r3,r3,-32768
   1db2c:	18002826 	beq	r3,zero,1dbd0 <__sfvwrite_r+0xf8>
   1db30:	28c00417 	ldw	r3,16(r5)
   1db34:	18002626 	beq	r3,zero,1dbd0 <__sfvwrite_r+0xf8>
   1db38:	10c0008c 	andi	r3,r2,2
   1db3c:	18ffffcc 	andi	r3,r3,65535
   1db40:	18e0001c 	xori	r3,r3,32768
   1db44:	18e00004 	addi	r3,r3,-32768
   1db48:	a4400017 	ldw	r17,0(r20)
   1db4c:	18002b26 	beq	r3,zero,1dbfc <__sfvwrite_r+0x124>
   1db50:	0027883a 	mov	r19,zero
   1db54:	0025883a 	mov	r18,zero
   1db58:	05810004 	movi	r22,1024
   1db5c:	980d883a 	mov	r6,r19
   1db60:	a809883a 	mov	r4,r21
   1db64:	90004f26 	beq	r18,zero,1dca4 <__sfvwrite_r+0x1cc>
   1db68:	900f883a 	mov	r7,r18
   1db6c:	81400717 	ldw	r5,28(r16)
   1db70:	b480012e 	bgeu	r22,r18,1db78 <__sfvwrite_r+0xa0>
   1db74:	01c10004 	movi	r7,1024
   1db78:	80800917 	ldw	r2,36(r16)
   1db7c:	103ee83a 	callr	r2
   1db80:	0080540e 	bge	zero,r2,1dcd4 <__sfvwrite_r+0x1fc>
   1db84:	a0c00217 	ldw	r3,8(r20)
   1db88:	98a7883a 	add	r19,r19,r2
   1db8c:	90a5c83a 	sub	r18,r18,r2
   1db90:	1885c83a 	sub	r2,r3,r2
   1db94:	a0800215 	stw	r2,8(r20)
   1db98:	103ff01e 	bne	r2,zero,1db5c <__sfvwrite_r+0x84>
   1db9c:	0005883a 	mov	r2,zero
   1dba0:	dfc00a17 	ldw	ra,40(sp)
   1dba4:	df000917 	ldw	fp,36(sp)
   1dba8:	ddc00817 	ldw	r23,32(sp)
   1dbac:	dd800717 	ldw	r22,28(sp)
   1dbb0:	dd400617 	ldw	r21,24(sp)
   1dbb4:	dd000517 	ldw	r20,20(sp)
   1dbb8:	dcc00417 	ldw	r19,16(sp)
   1dbbc:	dc800317 	ldw	r18,12(sp)
   1dbc0:	dc400217 	ldw	r17,8(sp)
   1dbc4:	dc000117 	ldw	r16,4(sp)
   1dbc8:	dec00b04 	addi	sp,sp,44
   1dbcc:	f800283a 	ret
   1dbd0:	a809883a 	mov	r4,r21
   1dbd4:	800b883a 	mov	r5,r16
   1dbd8:	001b8440 	call	1b844 <__swsetup_r>
   1dbdc:	1000f01e 	bne	r2,zero,1dfa0 <__sfvwrite_r+0x4c8>
   1dbe0:	8080030b 	ldhu	r2,12(r16)
   1dbe4:	a4400017 	ldw	r17,0(r20)
   1dbe8:	10c0008c 	andi	r3,r2,2
   1dbec:	18ffffcc 	andi	r3,r3,65535
   1dbf0:	18e0001c 	xori	r3,r3,32768
   1dbf4:	18e00004 	addi	r3,r3,-32768
   1dbf8:	183fd51e 	bne	r3,zero,1db50 <__sfvwrite_r+0x78>
   1dbfc:	10c0004c 	andi	r3,r2,1
   1dc00:	002d883a 	mov	r22,zero
   1dc04:	1800381e 	bne	r3,zero,1dce8 <__sfvwrite_r+0x210>
   1dc08:	0025883a 	mov	r18,zero
   1dc0c:	90002126 	beq	r18,zero,1dc94 <__sfvwrite_r+0x1bc>
   1dc10:	10c0800c 	andi	r3,r2,512
   1dc14:	18ffffcc 	andi	r3,r3,65535
   1dc18:	18e0001c 	xori	r3,r3,32768
   1dc1c:	18e00004 	addi	r3,r3,-32768
   1dc20:	84c00217 	ldw	r19,8(r16)
   1dc24:	18006b26 	beq	r3,zero,1ddd4 <__sfvwrite_r+0x2fc>
   1dc28:	980f883a 	mov	r7,r19
   1dc2c:	94c08636 	bltu	r18,r19,1de48 <__sfvwrite_r+0x370>
   1dc30:	10c1200c 	andi	r3,r2,1152
   1dc34:	18009f1e 	bne	r3,zero,1deb4 <__sfvwrite_r+0x3dc>
   1dc38:	81000017 	ldw	r4,0(r16)
   1dc3c:	982f883a 	mov	r23,r19
   1dc40:	9039883a 	mov	fp,r18
   1dc44:	9027883a 	mov	r19,r18
   1dc48:	380d883a 	mov	r6,r7
   1dc4c:	b00b883a 	mov	r5,r22
   1dc50:	d9c00015 	stw	r7,0(sp)
   1dc54:	001ec1c0 	call	1ec1c <memmove>
   1dc58:	d9c00017 	ldw	r7,0(sp)
   1dc5c:	81000217 	ldw	r4,8(r16)
   1dc60:	80800017 	ldw	r2,0(r16)
   1dc64:	25efc83a 	sub	r23,r4,r23
   1dc68:	11cf883a 	add	r7,r2,r7
   1dc6c:	85c00215 	stw	r23,8(r16)
   1dc70:	81c00015 	stw	r7,0(r16)
   1dc74:	a0800217 	ldw	r2,8(r20)
   1dc78:	b72d883a 	add	r22,r22,fp
   1dc7c:	9725c83a 	sub	r18,r18,fp
   1dc80:	14e7c83a 	sub	r19,r2,r19
   1dc84:	a4c00215 	stw	r19,8(r20)
   1dc88:	983fc426 	beq	r19,zero,1db9c <__sfvwrite_r+0xc4>
   1dc8c:	8080030b 	ldhu	r2,12(r16)
   1dc90:	903fdf1e 	bne	r18,zero,1dc10 <__sfvwrite_r+0x138>
   1dc94:	8d800017 	ldw	r22,0(r17)
   1dc98:	8c800117 	ldw	r18,4(r17)
   1dc9c:	8c400204 	addi	r17,r17,8
   1dca0:	003fda06 	br	1dc0c <__sfvwrite_r+0x134>
   1dca4:	8cc00017 	ldw	r19,0(r17)
   1dca8:	8c800117 	ldw	r18,4(r17)
   1dcac:	8c400204 	addi	r17,r17,8
   1dcb0:	003faa06 	br	1db5c <__sfvwrite_r+0x84>
   1dcb4:	001fcec0 	call	1fcec <_realloc_r>
   1dcb8:	102f883a 	mov	r23,r2
   1dcbc:	10009f1e 	bne	r2,zero,1df3c <__sfvwrite_r+0x464>
   1dcc0:	81400417 	ldw	r5,16(r16)
   1dcc4:	a809883a 	mov	r4,r21
   1dcc8:	001d8080 	call	1d808 <_free_r>
   1dccc:	00800304 	movi	r2,12
   1dcd0:	a8800015 	stw	r2,0(r21)
   1dcd4:	80c0030b 	ldhu	r3,12(r16)
   1dcd8:	00bfffc4 	movi	r2,-1
   1dcdc:	18c01014 	ori	r3,r3,64
   1dce0:	80c0030d 	sth	r3,12(r16)
   1dce4:	003fae06 	br	1dba0 <__sfvwrite_r+0xc8>
   1dce8:	0007883a 	mov	r3,zero
   1dcec:	0039883a 	mov	fp,zero
   1dcf0:	0025883a 	mov	r18,zero
   1dcf4:	90001e26 	beq	r18,zero,1dd70 <__sfvwrite_r+0x298>
   1dcf8:	18006526 	beq	r3,zero,1de90 <__sfvwrite_r+0x3b8>
   1dcfc:	b02f883a 	mov	r23,r22
   1dd00:	9580012e 	bgeu	r18,r22,1dd08 <__sfvwrite_r+0x230>
   1dd04:	902f883a 	mov	r23,r18
   1dd08:	81000017 	ldw	r4,0(r16)
   1dd0c:	80800417 	ldw	r2,16(r16)
   1dd10:	84c00217 	ldw	r19,8(r16)
   1dd14:	81c00517 	ldw	r7,20(r16)
   1dd18:	1100022e 	bgeu	r2,r4,1dd24 <__sfvwrite_r+0x24c>
   1dd1c:	99e7883a 	add	r19,r19,r7
   1dd20:	9dc01816 	blt	r19,r23,1dd84 <__sfvwrite_r+0x2ac>
   1dd24:	b9c03b16 	blt	r23,r7,1de14 <__sfvwrite_r+0x33c>
   1dd28:	80800917 	ldw	r2,36(r16)
   1dd2c:	81400717 	ldw	r5,28(r16)
   1dd30:	a809883a 	mov	r4,r21
   1dd34:	d8c00015 	stw	r3,0(sp)
   1dd38:	e00d883a 	mov	r6,fp
   1dd3c:	103ee83a 	callr	r2
   1dd40:	1027883a 	mov	r19,r2
   1dd44:	d8c00017 	ldw	r3,0(sp)
   1dd48:	00bfe20e 	bge	zero,r2,1dcd4 <__sfvwrite_r+0x1fc>
   1dd4c:	b4edc83a 	sub	r22,r22,r19
   1dd50:	b0001a26 	beq	r22,zero,1ddbc <__sfvwrite_r+0x2e4>
   1dd54:	a0800217 	ldw	r2,8(r20)
   1dd58:	e4f9883a 	add	fp,fp,r19
   1dd5c:	94e5c83a 	sub	r18,r18,r19
   1dd60:	14e7c83a 	sub	r19,r2,r19
   1dd64:	a4c00215 	stw	r19,8(r20)
   1dd68:	983f8c26 	beq	r19,zero,1db9c <__sfvwrite_r+0xc4>
   1dd6c:	903fe21e 	bne	r18,zero,1dcf8 <__sfvwrite_r+0x220>
   1dd70:	8f000017 	ldw	fp,0(r17)
   1dd74:	8c800117 	ldw	r18,4(r17)
   1dd78:	0007883a 	mov	r3,zero
   1dd7c:	8c400204 	addi	r17,r17,8
   1dd80:	003fdc06 	br	1dcf4 <__sfvwrite_r+0x21c>
   1dd84:	e00b883a 	mov	r5,fp
   1dd88:	980d883a 	mov	r6,r19
   1dd8c:	d8c00015 	stw	r3,0(sp)
   1dd90:	001ec1c0 	call	1ec1c <memmove>
   1dd94:	80800017 	ldw	r2,0(r16)
   1dd98:	a809883a 	mov	r4,r21
   1dd9c:	800b883a 	mov	r5,r16
   1dda0:	14c5883a 	add	r2,r2,r19
   1dda4:	80800015 	stw	r2,0(r16)
   1dda8:	001d1dc0 	call	1d1dc <_fflush_r>
   1ddac:	d8c00017 	ldw	r3,0(sp)
   1ddb0:	103fc81e 	bne	r2,zero,1dcd4 <__sfvwrite_r+0x1fc>
   1ddb4:	b4edc83a 	sub	r22,r22,r19
   1ddb8:	b03fe61e 	bne	r22,zero,1dd54 <__sfvwrite_r+0x27c>
   1ddbc:	a809883a 	mov	r4,r21
   1ddc0:	800b883a 	mov	r5,r16
   1ddc4:	001d1dc0 	call	1d1dc <_fflush_r>
   1ddc8:	103fc21e 	bne	r2,zero,1dcd4 <__sfvwrite_r+0x1fc>
   1ddcc:	0007883a 	mov	r3,zero
   1ddd0:	003fe006 	br	1dd54 <__sfvwrite_r+0x27c>
   1ddd4:	81000017 	ldw	r4,0(r16)
   1ddd8:	80800417 	ldw	r2,16(r16)
   1dddc:	1100022e 	bgeu	r2,r4,1dde8 <__sfvwrite_r+0x310>
   1dde0:	9839883a 	mov	fp,r19
   1dde4:	9c806036 	bltu	r19,r18,1df68 <__sfvwrite_r+0x490>
   1dde8:	81c00517 	ldw	r7,20(r16)
   1ddec:	91c01c36 	bltu	r18,r7,1de60 <__sfvwrite_r+0x388>
   1ddf0:	80800917 	ldw	r2,36(r16)
   1ddf4:	81400717 	ldw	r5,28(r16)
   1ddf8:	a809883a 	mov	r4,r21
   1ddfc:	b00d883a 	mov	r6,r22
   1de00:	103ee83a 	callr	r2
   1de04:	1027883a 	mov	r19,r2
   1de08:	00bfb20e 	bge	zero,r2,1dcd4 <__sfvwrite_r+0x1fc>
   1de0c:	1039883a 	mov	fp,r2
   1de10:	003f9806 	br	1dc74 <__sfvwrite_r+0x19c>
   1de14:	b80d883a 	mov	r6,r23
   1de18:	e00b883a 	mov	r5,fp
   1de1c:	d8c00015 	stw	r3,0(sp)
   1de20:	001ec1c0 	call	1ec1c <memmove>
   1de24:	80800217 	ldw	r2,8(r16)
   1de28:	81000017 	ldw	r4,0(r16)
   1de2c:	b827883a 	mov	r19,r23
   1de30:	15c5c83a 	sub	r2,r2,r23
   1de34:	25ef883a 	add	r23,r4,r23
   1de38:	80800215 	stw	r2,8(r16)
   1de3c:	85c00015 	stw	r23,0(r16)
   1de40:	d8c00017 	ldw	r3,0(sp)
   1de44:	003fc106 	br	1dd4c <__sfvwrite_r+0x274>
   1de48:	81000017 	ldw	r4,0(r16)
   1de4c:	902f883a 	mov	r23,r18
   1de50:	9039883a 	mov	fp,r18
   1de54:	9027883a 	mov	r19,r18
   1de58:	900f883a 	mov	r7,r18
   1de5c:	003f7a06 	br	1dc48 <__sfvwrite_r+0x170>
   1de60:	b00b883a 	mov	r5,r22
   1de64:	900d883a 	mov	r6,r18
   1de68:	001ec1c0 	call	1ec1c <memmove>
   1de6c:	80c00217 	ldw	r3,8(r16)
   1de70:	80800017 	ldw	r2,0(r16)
   1de74:	9027883a 	mov	r19,r18
   1de78:	1c87c83a 	sub	r3,r3,r18
   1de7c:	1485883a 	add	r2,r2,r18
   1de80:	80c00215 	stw	r3,8(r16)
   1de84:	80800015 	stw	r2,0(r16)
   1de88:	9039883a 	mov	fp,r18
   1de8c:	003f7906 	br	1dc74 <__sfvwrite_r+0x19c>
   1de90:	e009883a 	mov	r4,fp
   1de94:	01400284 	movi	r5,10
   1de98:	900d883a 	mov	r6,r18
   1de9c:	001eb240 	call	1eb24 <memchr>
   1dea0:	10003c26 	beq	r2,zero,1df94 <__sfvwrite_r+0x4bc>
   1dea4:	15800044 	addi	r22,r2,1
   1dea8:	b72dc83a 	sub	r22,r22,fp
   1deac:	00c00044 	movi	r3,1
   1deb0:	003f9206 	br	1dcfc <__sfvwrite_r+0x224>
   1deb4:	81000517 	ldw	r4,20(r16)
   1deb8:	81400417 	ldw	r5,16(r16)
   1debc:	80c00017 	ldw	r3,0(r16)
   1dec0:	210d883a 	add	r6,r4,r4
   1dec4:	3109883a 	add	r4,r6,r4
   1dec8:	2026d7fa 	srli	r19,r4,31
   1decc:	1979c83a 	sub	fp,r3,r5
   1ded0:	e1800044 	addi	r6,fp,1
   1ded4:	9909883a 	add	r4,r19,r4
   1ded8:	2027d07a 	srai	r19,r4,1
   1dedc:	3489883a 	add	r4,r6,r18
   1dee0:	980d883a 	mov	r6,r19
   1dee4:	9900022e 	bgeu	r19,r4,1def0 <__sfvwrite_r+0x418>
   1dee8:	2027883a 	mov	r19,r4
   1deec:	200d883a 	mov	r6,r4
   1def0:	1081000c 	andi	r2,r2,1024
   1def4:	10bfffcc 	andi	r2,r2,65535
   1def8:	10a0001c 	xori	r2,r2,32768
   1defc:	10a00004 	addi	r2,r2,-32768
   1df00:	a809883a 	mov	r4,r21
   1df04:	103f6b26 	beq	r2,zero,1dcb4 <__sfvwrite_r+0x1dc>
   1df08:	300b883a 	mov	r5,r6
   1df0c:	001e3a00 	call	1e3a0 <_malloc_r>
   1df10:	102f883a 	mov	r23,r2
   1df14:	103f6d26 	beq	r2,zero,1dccc <__sfvwrite_r+0x1f4>
   1df18:	81400417 	ldw	r5,16(r16)
   1df1c:	1009883a 	mov	r4,r2
   1df20:	e00d883a 	mov	r6,fp
   1df24:	00191f00 	call	191f0 <memcpy>
   1df28:	8080030b 	ldhu	r2,12(r16)
   1df2c:	00fedfc4 	movi	r3,-1153
   1df30:	10c4703a 	and	r2,r2,r3
   1df34:	10802014 	ori	r2,r2,128
   1df38:	8080030d 	sth	r2,12(r16)
   1df3c:	bf09883a 	add	r4,r23,fp
   1df40:	9f07c83a 	sub	r3,r19,fp
   1df44:	85c00415 	stw	r23,16(r16)
   1df48:	84c00515 	stw	r19,20(r16)
   1df4c:	81000015 	stw	r4,0(r16)
   1df50:	902f883a 	mov	r23,r18
   1df54:	80c00215 	stw	r3,8(r16)
   1df58:	9039883a 	mov	fp,r18
   1df5c:	9027883a 	mov	r19,r18
   1df60:	900f883a 	mov	r7,r18
   1df64:	003f3806 	br	1dc48 <__sfvwrite_r+0x170>
   1df68:	b00b883a 	mov	r5,r22
   1df6c:	980d883a 	mov	r6,r19
   1df70:	001ec1c0 	call	1ec1c <memmove>
   1df74:	80800017 	ldw	r2,0(r16)
   1df78:	a809883a 	mov	r4,r21
   1df7c:	800b883a 	mov	r5,r16
   1df80:	14c5883a 	add	r2,r2,r19
   1df84:	80800015 	stw	r2,0(r16)
   1df88:	001d1dc0 	call	1d1dc <_fflush_r>
   1df8c:	103f3926 	beq	r2,zero,1dc74 <__sfvwrite_r+0x19c>
   1df90:	003f5006 	br	1dcd4 <__sfvwrite_r+0x1fc>
   1df94:	95800044 	addi	r22,r18,1
   1df98:	00c00044 	movi	r3,1
   1df9c:	003f5706 	br	1dcfc <__sfvwrite_r+0x224>
   1dfa0:	80c0030b 	ldhu	r3,12(r16)
   1dfa4:	00bfffc4 	movi	r2,-1
   1dfa8:	18c01014 	ori	r3,r3,64
   1dfac:	80c0030d 	sth	r3,12(r16)
   1dfb0:	00c00244 	movi	r3,9
   1dfb4:	a8c00015 	stw	r3,0(r21)
   1dfb8:	003ef906 	br	1dba0 <__sfvwrite_r+0xc8>

0001dfbc <_fwalk>:
   1dfbc:	defff904 	addi	sp,sp,-28
   1dfc0:	dcc00315 	stw	r19,12(sp)
   1dfc4:	24c0b804 	addi	r19,r4,736
   1dfc8:	dd400515 	stw	r21,20(sp)
   1dfcc:	dd000415 	stw	r20,16(sp)
   1dfd0:	dfc00615 	stw	ra,24(sp)
   1dfd4:	dc800215 	stw	r18,8(sp)
   1dfd8:	dc400115 	stw	r17,4(sp)
   1dfdc:	dc000015 	stw	r16,0(sp)
   1dfe0:	282b883a 	mov	r21,r5
   1dfe4:	0029883a 	mov	r20,zero
   1dfe8:	001d68c0 	call	1d68c <__sfp_lock_acquire>
   1dfec:	98001226 	beq	r19,zero,1e038 <_fwalk+0x7c>
   1dff0:	04bfffc4 	movi	r18,-1
   1dff4:	9c400117 	ldw	r17,4(r19)
   1dff8:	9c000217 	ldw	r16,8(r19)
   1dffc:	8c7fffc4 	addi	r17,r17,-1
   1e000:	88000b16 	blt	r17,zero,1e030 <_fwalk+0x74>
   1e004:	84000304 	addi	r16,r16,12
   1e008:	80c0000f 	ldh	r3,0(r16)
   1e00c:	8c7fffc4 	addi	r17,r17,-1
   1e010:	813ffd04 	addi	r4,r16,-12
   1e014:	18000426 	beq	r3,zero,1e028 <_fwalk+0x6c>
   1e018:	80c0008f 	ldh	r3,2(r16)
   1e01c:	1c800226 	beq	r3,r18,1e028 <_fwalk+0x6c>
   1e020:	a83ee83a 	callr	r21
   1e024:	a0a8b03a 	or	r20,r20,r2
   1e028:	84001704 	addi	r16,r16,92
   1e02c:	8cbff61e 	bne	r17,r18,1e008 <_fwalk+0x4c>
   1e030:	9cc00017 	ldw	r19,0(r19)
   1e034:	983fef1e 	bne	r19,zero,1dff4 <_fwalk+0x38>
   1e038:	001d6900 	call	1d690 <__sfp_lock_release>
   1e03c:	a005883a 	mov	r2,r20
   1e040:	dfc00617 	ldw	ra,24(sp)
   1e044:	dd400517 	ldw	r21,20(sp)
   1e048:	dd000417 	ldw	r20,16(sp)
   1e04c:	dcc00317 	ldw	r19,12(sp)
   1e050:	dc800217 	ldw	r18,8(sp)
   1e054:	dc400117 	ldw	r17,4(sp)
   1e058:	dc000017 	ldw	r16,0(sp)
   1e05c:	dec00704 	addi	sp,sp,28
   1e060:	f800283a 	ret

0001e064 <_fwalk_reent>:
   1e064:	defff804 	addi	sp,sp,-32
   1e068:	dcc00315 	stw	r19,12(sp)
   1e06c:	24c0b804 	addi	r19,r4,736
   1e070:	dd800615 	stw	r22,24(sp)
   1e074:	dd400515 	stw	r21,20(sp)
   1e078:	dd000415 	stw	r20,16(sp)
   1e07c:	dfc00715 	stw	ra,28(sp)
   1e080:	dc800215 	stw	r18,8(sp)
   1e084:	dc400115 	stw	r17,4(sp)
   1e088:	dc000015 	stw	r16,0(sp)
   1e08c:	2029883a 	mov	r20,r4
   1e090:	282b883a 	mov	r21,r5
   1e094:	002d883a 	mov	r22,zero
   1e098:	001d68c0 	call	1d68c <__sfp_lock_acquire>
   1e09c:	98001326 	beq	r19,zero,1e0ec <_fwalk_reent+0x88>
   1e0a0:	04bfffc4 	movi	r18,-1
   1e0a4:	9c400117 	ldw	r17,4(r19)
   1e0a8:	9c000217 	ldw	r16,8(r19)
   1e0ac:	8c7fffc4 	addi	r17,r17,-1
   1e0b0:	88000c16 	blt	r17,zero,1e0e4 <_fwalk_reent+0x80>
   1e0b4:	84000304 	addi	r16,r16,12
   1e0b8:	80c0000f 	ldh	r3,0(r16)
   1e0bc:	8c7fffc4 	addi	r17,r17,-1
   1e0c0:	817ffd04 	addi	r5,r16,-12
   1e0c4:	18000526 	beq	r3,zero,1e0dc <_fwalk_reent+0x78>
   1e0c8:	80c0008f 	ldh	r3,2(r16)
   1e0cc:	a009883a 	mov	r4,r20
   1e0d0:	1c800226 	beq	r3,r18,1e0dc <_fwalk_reent+0x78>
   1e0d4:	a83ee83a 	callr	r21
   1e0d8:	b0acb03a 	or	r22,r22,r2
   1e0dc:	84001704 	addi	r16,r16,92
   1e0e0:	8cbff51e 	bne	r17,r18,1e0b8 <_fwalk_reent+0x54>
   1e0e4:	9cc00017 	ldw	r19,0(r19)
   1e0e8:	983fee1e 	bne	r19,zero,1e0a4 <_fwalk_reent+0x40>
   1e0ec:	001d6900 	call	1d690 <__sfp_lock_release>
   1e0f0:	b005883a 	mov	r2,r22
   1e0f4:	dfc00717 	ldw	ra,28(sp)
   1e0f8:	dd800617 	ldw	r22,24(sp)
   1e0fc:	dd400517 	ldw	r21,20(sp)
   1e100:	dd000417 	ldw	r20,16(sp)
   1e104:	dcc00317 	ldw	r19,12(sp)
   1e108:	dc800217 	ldw	r18,8(sp)
   1e10c:	dc400117 	ldw	r17,4(sp)
   1e110:	dc000017 	ldw	r16,0(sp)
   1e114:	dec00804 	addi	sp,sp,32
   1e118:	f800283a 	ret

0001e11c <_setlocale_r>:
   1e11c:	defffc04 	addi	sp,sp,-16
   1e120:	dc800215 	stw	r18,8(sp)
   1e124:	dc400115 	stw	r17,4(sp)
   1e128:	dc000015 	stw	r16,0(sp)
   1e12c:	dfc00315 	stw	ra,12(sp)
   1e130:	3021883a 	mov	r16,r6
   1e134:	2023883a 	mov	r17,r4
   1e138:	2825883a 	mov	r18,r5
   1e13c:	30001626 	beq	r6,zero,1e198 <_setlocale_r+0x7c>
   1e140:	3009883a 	mov	r4,r6
   1e144:	014000f4 	movhi	r5,3
   1e148:	2944ce04 	addi	r5,r5,4920
   1e14c:	00196700 	call	19670 <strcmp>
   1e150:	10000a1e 	bne	r2,zero,1e17c <_setlocale_r+0x60>
   1e154:	8c800c15 	stw	r18,48(r17)
   1e158:	8c000d15 	stw	r16,52(r17)
   1e15c:	008000f4 	movhi	r2,3
   1e160:	1084ce04 	addi	r2,r2,4920
   1e164:	dfc00317 	ldw	ra,12(sp)
   1e168:	dc800217 	ldw	r18,8(sp)
   1e16c:	dc400117 	ldw	r17,4(sp)
   1e170:	dc000017 	ldw	r16,0(sp)
   1e174:	dec00404 	addi	sp,sp,16
   1e178:	f800283a 	ret
   1e17c:	8009883a 	mov	r4,r16
   1e180:	014000f4 	movhi	r5,3
   1e184:	2944d804 	addi	r5,r5,4960
   1e188:	00196700 	call	19670 <strcmp>
   1e18c:	103ff126 	beq	r2,zero,1e154 <_setlocale_r+0x38>
   1e190:	0005883a 	mov	r2,zero
   1e194:	003ff306 	br	1e164 <_setlocale_r+0x48>
   1e198:	008000f4 	movhi	r2,3
   1e19c:	1084ce04 	addi	r2,r2,4920
   1e1a0:	dfc00317 	ldw	ra,12(sp)
   1e1a4:	dc800217 	ldw	r18,8(sp)
   1e1a8:	dc400117 	ldw	r17,4(sp)
   1e1ac:	dc000017 	ldw	r16,0(sp)
   1e1b0:	dec00404 	addi	sp,sp,16
   1e1b4:	f800283a 	ret

0001e1b8 <__locale_charset>:
   1e1b8:	008000f4 	movhi	r2,3
   1e1bc:	1084ed04 	addi	r2,r2,5044
   1e1c0:	f800283a 	ret

0001e1c4 <_localeconv_r>:
   1e1c4:	008000f4 	movhi	r2,3
   1e1c8:	1084f104 	addi	r2,r2,5060
   1e1cc:	f800283a 	ret

0001e1d0 <setlocale>:
   1e1d0:	00c000f4 	movhi	r3,3
   1e1d4:	18d57f04 	addi	r3,r3,22012
   1e1d8:	2005883a 	mov	r2,r4
   1e1dc:	19000017 	ldw	r4,0(r3)
   1e1e0:	280d883a 	mov	r6,r5
   1e1e4:	100b883a 	mov	r5,r2
   1e1e8:	001e11c1 	jmpi	1e11c <_setlocale_r>

0001e1ec <localeconv>:
   1e1ec:	008000f4 	movhi	r2,3
   1e1f0:	1084f104 	addi	r2,r2,5060
   1e1f4:	f800283a 	ret

0001e1f8 <__smakebuf_r>:
   1e1f8:	2880030b 	ldhu	r2,12(r5)
   1e1fc:	deffed04 	addi	sp,sp,-76
   1e200:	dc401015 	stw	r17,64(sp)
   1e204:	10c0008c 	andi	r3,r2,2
   1e208:	18ffffcc 	andi	r3,r3,65535
   1e20c:	18e0001c 	xori	r3,r3,32768
   1e210:	dc000f15 	stw	r16,60(sp)
   1e214:	dfc01215 	stw	ra,72(sp)
   1e218:	dc801115 	stw	r18,68(sp)
   1e21c:	18e00004 	addi	r3,r3,-32768
   1e220:	2821883a 	mov	r16,r5
   1e224:	2023883a 	mov	r17,r4
   1e228:	1800381e 	bne	r3,zero,1e30c <__smakebuf_r+0x114>
   1e22c:	2940038f 	ldh	r5,14(r5)
   1e230:	28002d16 	blt	r5,zero,1e2e8 <__smakebuf_r+0xf0>
   1e234:	d80d883a 	mov	r6,sp
   1e238:	00207cc0 	call	207cc <_fstat_r>
   1e23c:	10002916 	blt	r2,zero,1e2e4 <__smakebuf_r+0xec>
   1e240:	d8800117 	ldw	r2,4(sp)
   1e244:	00e00014 	movui	r3,32768
   1e248:	10bc000c 	andi	r2,r2,61440
   1e24c:	10c03c26 	beq	r2,r3,1e340 <__smakebuf_r+0x148>
   1e250:	80c0030b 	ldhu	r3,12(r16)
   1e254:	18c20014 	ori	r3,r3,2048
   1e258:	80c0030d 	sth	r3,12(r16)
   1e25c:	00c80004 	movi	r3,8192
   1e260:	10c00c1e 	bne	r2,r3,1e294 <__smakebuf_r+0x9c>
   1e264:	8140038f 	ldh	r5,14(r16)
   1e268:	8809883a 	mov	r4,r17
   1e26c:	00208340 	call	20834 <_isatty_r>
   1e270:	10000826 	beq	r2,zero,1e294 <__smakebuf_r+0x9c>
   1e274:	80c0030b 	ldhu	r3,12(r16)
   1e278:	808010c4 	addi	r2,r16,67
   1e27c:	80800015 	stw	r2,0(r16)
   1e280:	18c00054 	ori	r3,r3,1
   1e284:	80800415 	stw	r2,16(r16)
   1e288:	00800044 	movi	r2,1
   1e28c:	80c0030d 	sth	r3,12(r16)
   1e290:	80800515 	stw	r2,20(r16)
   1e294:	04810004 	movi	r18,1024
   1e298:	8809883a 	mov	r4,r17
   1e29c:	900b883a 	mov	r5,r18
   1e2a0:	001e3a00 	call	1e3a0 <_malloc_r>
   1e2a4:	10003026 	beq	r2,zero,1e368 <__smakebuf_r+0x170>
   1e2a8:	80c0030b 	ldhu	r3,12(r16)
   1e2ac:	010000b4 	movhi	r4,2
   1e2b0:	21350104 	addi	r4,r4,-11260
   1e2b4:	89000f15 	stw	r4,60(r17)
   1e2b8:	18c02014 	ori	r3,r3,128
   1e2bc:	80c0030d 	sth	r3,12(r16)
   1e2c0:	80800015 	stw	r2,0(r16)
   1e2c4:	80800415 	stw	r2,16(r16)
   1e2c8:	84800515 	stw	r18,20(r16)
   1e2cc:	dfc01217 	ldw	ra,72(sp)
   1e2d0:	dc801117 	ldw	r18,68(sp)
   1e2d4:	dc401017 	ldw	r17,64(sp)
   1e2d8:	dc000f17 	ldw	r16,60(sp)
   1e2dc:	dec01304 	addi	sp,sp,76
   1e2e0:	f800283a 	ret
   1e2e4:	8080030b 	ldhu	r2,12(r16)
   1e2e8:	10c0200c 	andi	r3,r2,128
   1e2ec:	18ffffcc 	andi	r3,r3,65535
   1e2f0:	18e0001c 	xori	r3,r3,32768
   1e2f4:	18e00004 	addi	r3,r3,-32768
   1e2f8:	18000f1e 	bne	r3,zero,1e338 <__smakebuf_r+0x140>
   1e2fc:	04810004 	movi	r18,1024
   1e300:	10820014 	ori	r2,r2,2048
   1e304:	8080030d 	sth	r2,12(r16)
   1e308:	003fe306 	br	1e298 <__smakebuf_r+0xa0>
   1e30c:	288010c4 	addi	r2,r5,67
   1e310:	28800015 	stw	r2,0(r5)
   1e314:	28800415 	stw	r2,16(r5)
   1e318:	00800044 	movi	r2,1
   1e31c:	28800515 	stw	r2,20(r5)
   1e320:	dfc01217 	ldw	ra,72(sp)
   1e324:	dc801117 	ldw	r18,68(sp)
   1e328:	dc401017 	ldw	r17,64(sp)
   1e32c:	dc000f17 	ldw	r16,60(sp)
   1e330:	dec01304 	addi	sp,sp,76
   1e334:	f800283a 	ret
   1e338:	04801004 	movi	r18,64
   1e33c:	003ff006 	br	1e300 <__smakebuf_r+0x108>
   1e340:	81000a17 	ldw	r4,40(r16)
   1e344:	00c000b4 	movhi	r3,2
   1e348:	18c12304 	addi	r3,r3,1164
   1e34c:	20ffc01e 	bne	r4,r3,1e250 <__smakebuf_r+0x58>
   1e350:	8080030b 	ldhu	r2,12(r16)
   1e354:	00c10004 	movi	r3,1024
   1e358:	80c01315 	stw	r3,76(r16)
   1e35c:	10c4b03a 	or	r2,r2,r3
   1e360:	8080030d 	sth	r2,12(r16)
   1e364:	003fcb06 	br	1e294 <__smakebuf_r+0x9c>
   1e368:	8080030b 	ldhu	r2,12(r16)
   1e36c:	10c0800c 	andi	r3,r2,512
   1e370:	18ffffcc 	andi	r3,r3,65535
   1e374:	18e0001c 	xori	r3,r3,32768
   1e378:	18e00004 	addi	r3,r3,-32768
   1e37c:	183fd31e 	bne	r3,zero,1e2cc <__smakebuf_r+0xd4>
   1e380:	10800094 	ori	r2,r2,2
   1e384:	80c010c4 	addi	r3,r16,67
   1e388:	8080030d 	sth	r2,12(r16)
   1e38c:	00800044 	movi	r2,1
   1e390:	80c00015 	stw	r3,0(r16)
   1e394:	80c00415 	stw	r3,16(r16)
   1e398:	80800515 	stw	r2,20(r16)
   1e39c:	003fcb06 	br	1e2cc <__smakebuf_r+0xd4>

0001e3a0 <_malloc_r>:
   1e3a0:	defff604 	addi	sp,sp,-40
   1e3a4:	dc800215 	stw	r18,8(sp)
   1e3a8:	dfc00915 	stw	ra,36(sp)
   1e3ac:	df000815 	stw	fp,32(sp)
   1e3b0:	ddc00715 	stw	r23,28(sp)
   1e3b4:	dd800615 	stw	r22,24(sp)
   1e3b8:	dd400515 	stw	r21,20(sp)
   1e3bc:	dd000415 	stw	r20,16(sp)
   1e3c0:	dcc00315 	stw	r19,12(sp)
   1e3c4:	dc400115 	stw	r17,4(sp)
   1e3c8:	dc000015 	stw	r16,0(sp)
   1e3cc:	288002c4 	addi	r2,r5,11
   1e3d0:	00c00584 	movi	r3,22
   1e3d4:	2025883a 	mov	r18,r4
   1e3d8:	18802b2e 	bgeu	r3,r2,1e488 <_malloc_r+0xe8>
   1e3dc:	047ffe04 	movi	r17,-8
   1e3e0:	1462703a 	and	r17,r2,r17
   1e3e4:	88002a16 	blt	r17,zero,1e490 <_malloc_r+0xf0>
   1e3e8:	89402936 	bltu	r17,r5,1e490 <_malloc_r+0xf0>
   1e3ec:	9009883a 	mov	r4,r18
   1e3f0:	0021f600 	call	21f60 <__malloc_lock>
   1e3f4:	00807dc4 	movi	r2,503
   1e3f8:	14402936 	bltu	r2,r17,1e4a0 <_malloc_r+0x100>
   1e3fc:	8808d0fa 	srli	r4,r17,3
   1e400:	04c000f4 	movhi	r19,3
   1e404:	9cce9e04 	addi	r19,r19,14968
   1e408:	2105883a 	add	r2,r4,r4
   1e40c:	1085883a 	add	r2,r2,r2
   1e410:	1085883a 	add	r2,r2,r2
   1e414:	9885883a 	add	r2,r19,r2
   1e418:	14000317 	ldw	r16,12(r2)
   1e41c:	80815526 	beq	r16,r2,1e974 <_malloc_r+0x5d4>
   1e420:	81000117 	ldw	r4,4(r16)
   1e424:	00bfff04 	movi	r2,-4
   1e428:	80c00317 	ldw	r3,12(r16)
   1e42c:	2084703a 	and	r2,r4,r2
   1e430:	8085883a 	add	r2,r16,r2
   1e434:	11800117 	ldw	r6,4(r2)
   1e438:	81400217 	ldw	r5,8(r16)
   1e43c:	9009883a 	mov	r4,r18
   1e440:	31800054 	ori	r6,r6,1
   1e444:	11800115 	stw	r6,4(r2)
   1e448:	28c00315 	stw	r3,12(r5)
   1e44c:	19400215 	stw	r5,8(r3)
   1e450:	0021f800 	call	21f80 <__malloc_unlock>
   1e454:	80800204 	addi	r2,r16,8
   1e458:	dfc00917 	ldw	ra,36(sp)
   1e45c:	df000817 	ldw	fp,32(sp)
   1e460:	ddc00717 	ldw	r23,28(sp)
   1e464:	dd800617 	ldw	r22,24(sp)
   1e468:	dd400517 	ldw	r21,20(sp)
   1e46c:	dd000417 	ldw	r20,16(sp)
   1e470:	dcc00317 	ldw	r19,12(sp)
   1e474:	dc800217 	ldw	r18,8(sp)
   1e478:	dc400117 	ldw	r17,4(sp)
   1e47c:	dc000017 	ldw	r16,0(sp)
   1e480:	dec00a04 	addi	sp,sp,40
   1e484:	f800283a 	ret
   1e488:	04400404 	movi	r17,16
   1e48c:	897fd72e 	bgeu	r17,r5,1e3ec <_malloc_r+0x4c>
   1e490:	00800304 	movi	r2,12
   1e494:	90800015 	stw	r2,0(r18)
   1e498:	0005883a 	mov	r2,zero
   1e49c:	003fee06 	br	1e458 <_malloc_r+0xb8>
   1e4a0:	8808d27a 	srli	r4,r17,9
   1e4a4:	20007126 	beq	r4,zero,1e66c <_malloc_r+0x2cc>
   1e4a8:	00800104 	movi	r2,4
   1e4ac:	1100eb36 	bltu	r2,r4,1e85c <_malloc_r+0x4bc>
   1e4b0:	8808d1ba 	srli	r4,r17,6
   1e4b4:	21000e04 	addi	r4,r4,56
   1e4b8:	210b883a 	add	r5,r4,r4
   1e4bc:	294b883a 	add	r5,r5,r5
   1e4c0:	294b883a 	add	r5,r5,r5
   1e4c4:	04c000f4 	movhi	r19,3
   1e4c8:	9cce9e04 	addi	r19,r19,14968
   1e4cc:	994b883a 	add	r5,r19,r5
   1e4d0:	2c000317 	ldw	r16,12(r5)
   1e4d4:	2c000e26 	beq	r5,r16,1e510 <_malloc_r+0x170>
   1e4d8:	80c00117 	ldw	r3,4(r16)
   1e4dc:	01ffff04 	movi	r7,-4
   1e4e0:	018003c4 	movi	r6,15
   1e4e4:	19c6703a 	and	r3,r3,r7
   1e4e8:	1c45c83a 	sub	r2,r3,r17
   1e4ec:	30800716 	blt	r6,r2,1e50c <_malloc_r+0x16c>
   1e4f0:	1000610e 	bge	r2,zero,1e678 <_malloc_r+0x2d8>
   1e4f4:	84000317 	ldw	r16,12(r16)
   1e4f8:	2c000526 	beq	r5,r16,1e510 <_malloc_r+0x170>
   1e4fc:	80c00117 	ldw	r3,4(r16)
   1e500:	19c6703a 	and	r3,r3,r7
   1e504:	1c45c83a 	sub	r2,r3,r17
   1e508:	30bff90e 	bge	r6,r2,1e4f0 <_malloc_r+0x150>
   1e50c:	213fffc4 	addi	r4,r4,-1
   1e510:	21000044 	addi	r4,r4,1
   1e514:	9c000417 	ldw	r16,16(r19)
   1e518:	00c000f4 	movhi	r3,3
   1e51c:	18ce9e04 	addi	r3,r3,14968
   1e520:	1a400204 	addi	r9,r3,8
   1e524:	8240ff26 	beq	r16,r9,1e924 <_malloc_r+0x584>
   1e528:	81400117 	ldw	r5,4(r16)
   1e52c:	00bfff04 	movi	r2,-4
   1e530:	018003c4 	movi	r6,15
   1e534:	2884703a 	and	r2,r5,r2
   1e538:	144bc83a 	sub	r5,r2,r17
   1e53c:	3140ea16 	blt	r6,r5,1e8e8 <_malloc_r+0x548>
   1e540:	1a400515 	stw	r9,20(r3)
   1e544:	1a400415 	stw	r9,16(r3)
   1e548:	2800570e 	bge	r5,zero,1e6a8 <_malloc_r+0x308>
   1e54c:	01407fc4 	movi	r5,511
   1e550:	2880ca36 	bltu	r5,r2,1e87c <_malloc_r+0x4dc>
   1e554:	1004d0fa 	srli	r2,r2,3
   1e558:	02000044 	movi	r8,1
   1e55c:	19c00117 	ldw	r7,4(r3)
   1e560:	108b883a 	add	r5,r2,r2
   1e564:	294b883a 	add	r5,r5,r5
   1e568:	1005d0ba 	srai	r2,r2,2
   1e56c:	294b883a 	add	r5,r5,r5
   1e570:	28cb883a 	add	r5,r5,r3
   1e574:	29800217 	ldw	r6,8(r5)
   1e578:	4084983a 	sll	r2,r8,r2
   1e57c:	81400315 	stw	r5,12(r16)
   1e580:	81800215 	stw	r6,8(r16)
   1e584:	11c4b03a 	or	r2,r2,r7
   1e588:	18800115 	stw	r2,4(r3)
   1e58c:	2c000215 	stw	r16,8(r5)
   1e590:	34000315 	stw	r16,12(r6)
   1e594:	200bd0ba 	srai	r5,r4,2
   1e598:	00c00044 	movi	r3,1
   1e59c:	194a983a 	sll	r5,r3,r5
   1e5a0:	11404936 	bltu	r2,r5,1e6c8 <_malloc_r+0x328>
   1e5a4:	1146703a 	and	r3,r2,r5
   1e5a8:	18000a1e 	bne	r3,zero,1e5d4 <_malloc_r+0x234>
   1e5ac:	00ffff04 	movi	r3,-4
   1e5b0:	294b883a 	add	r5,r5,r5
   1e5b4:	20c8703a 	and	r4,r4,r3
   1e5b8:	1146703a 	and	r3,r2,r5
   1e5bc:	21000104 	addi	r4,r4,4
   1e5c0:	1800041e 	bne	r3,zero,1e5d4 <_malloc_r+0x234>
   1e5c4:	294b883a 	add	r5,r5,r5
   1e5c8:	1146703a 	and	r3,r2,r5
   1e5cc:	21000104 	addi	r4,r4,4
   1e5d0:	183ffc26 	beq	r3,zero,1e5c4 <_malloc_r+0x224>
   1e5d4:	023fff04 	movi	r8,-4
   1e5d8:	01c003c4 	movi	r7,15
   1e5dc:	2105883a 	add	r2,r4,r4
   1e5e0:	1085883a 	add	r2,r2,r2
   1e5e4:	1085883a 	add	r2,r2,r2
   1e5e8:	9899883a 	add	r12,r19,r2
   1e5ec:	62800304 	addi	r10,r12,12
   1e5f0:	2017883a 	mov	r11,r4
   1e5f4:	54000017 	ldw	r16,0(r10)
   1e5f8:	51bffd04 	addi	r6,r10,-12
   1e5fc:	8180041e 	bne	r16,r6,1e610 <_malloc_r+0x270>
   1e600:	0000ca06 	br	1e92c <_malloc_r+0x58c>
   1e604:	10001c0e 	bge	r2,zero,1e678 <_malloc_r+0x2d8>
   1e608:	84000317 	ldw	r16,12(r16)
   1e60c:	8180c726 	beq	r16,r6,1e92c <_malloc_r+0x58c>
   1e610:	80c00117 	ldw	r3,4(r16)
   1e614:	1a06703a 	and	r3,r3,r8
   1e618:	1c45c83a 	sub	r2,r3,r17
   1e61c:	38bff90e 	bge	r7,r2,1e604 <_malloc_r+0x264>
   1e620:	81000317 	ldw	r4,12(r16)
   1e624:	81400217 	ldw	r5,8(r16)
   1e628:	8447883a 	add	r3,r16,r17
   1e62c:	8c400054 	ori	r17,r17,1
   1e630:	29000315 	stw	r4,12(r5)
   1e634:	21400215 	stw	r5,8(r4)
   1e638:	84400115 	stw	r17,4(r16)
   1e63c:	1889883a 	add	r4,r3,r2
   1e640:	11400054 	ori	r5,r2,1
   1e644:	98c00515 	stw	r3,20(r19)
   1e648:	98c00415 	stw	r3,16(r19)
   1e64c:	20800015 	stw	r2,0(r4)
   1e650:	1a400315 	stw	r9,12(r3)
   1e654:	1a400215 	stw	r9,8(r3)
   1e658:	19400115 	stw	r5,4(r3)
   1e65c:	9009883a 	mov	r4,r18
   1e660:	0021f800 	call	21f80 <__malloc_unlock>
   1e664:	80800204 	addi	r2,r16,8
   1e668:	003f7b06 	br	1e458 <_malloc_r+0xb8>
   1e66c:	8808d0fa 	srli	r4,r17,3
   1e670:	210b883a 	add	r5,r4,r4
   1e674:	003f9106 	br	1e4bc <_malloc_r+0x11c>
   1e678:	80c7883a 	add	r3,r16,r3
   1e67c:	19400117 	ldw	r5,4(r3)
   1e680:	80800317 	ldw	r2,12(r16)
   1e684:	81000217 	ldw	r4,8(r16)
   1e688:	29400054 	ori	r5,r5,1
   1e68c:	19400115 	stw	r5,4(r3)
   1e690:	20800315 	stw	r2,12(r4)
   1e694:	11000215 	stw	r4,8(r2)
   1e698:	9009883a 	mov	r4,r18
   1e69c:	0021f800 	call	21f80 <__malloc_unlock>
   1e6a0:	80800204 	addi	r2,r16,8
   1e6a4:	003f6c06 	br	1e458 <_malloc_r+0xb8>
   1e6a8:	8085883a 	add	r2,r16,r2
   1e6ac:	10c00117 	ldw	r3,4(r2)
   1e6b0:	9009883a 	mov	r4,r18
   1e6b4:	18c00054 	ori	r3,r3,1
   1e6b8:	10c00115 	stw	r3,4(r2)
   1e6bc:	0021f800 	call	21f80 <__malloc_unlock>
   1e6c0:	80800204 	addi	r2,r16,8
   1e6c4:	003f6406 	br	1e458 <_malloc_r+0xb8>
   1e6c8:	9c000217 	ldw	r16,8(r19)
   1e6cc:	00bfff04 	movi	r2,-4
   1e6d0:	85400117 	ldw	r21,4(r16)
   1e6d4:	a8aa703a 	and	r21,r21,r2
   1e6d8:	ac400336 	bltu	r21,r17,1e6e8 <_malloc_r+0x348>
   1e6dc:	ac45c83a 	sub	r2,r21,r17
   1e6e0:	00c003c4 	movi	r3,15
   1e6e4:	18805316 	blt	r3,r2,1e834 <_malloc_r+0x494>
   1e6e8:	d5e8d617 	ldw	r23,-23720(gp)
   1e6ec:	d0e00f17 	ldw	r3,-32708(gp)
   1e6f0:	00bfffc4 	movi	r2,-1
   1e6f4:	8579883a 	add	fp,r16,r21
   1e6f8:	8def883a 	add	r23,r17,r23
   1e6fc:	1880d226 	beq	r3,r2,1ea48 <_malloc_r+0x6a8>
   1e700:	bdc403c4 	addi	r23,r23,4111
   1e704:	00bc0004 	movi	r2,-4096
   1e708:	b8ae703a 	and	r23,r23,r2
   1e70c:	9009883a 	mov	r4,r18
   1e710:	b80b883a 	mov	r5,r23
   1e714:	002034c0 	call	2034c <_sbrk_r>
   1e718:	1029883a 	mov	r20,r2
   1e71c:	00bfffc4 	movi	r2,-1
   1e720:	a080d126 	beq	r20,r2,1ea68 <_malloc_r+0x6c8>
   1e724:	a7009f36 	bltu	r20,fp,1e9a4 <_malloc_r+0x604>
   1e728:	05800134 	movhi	r22,4
   1e72c:	b5977104 	addi	r22,r22,24004
   1e730:	b0800017 	ldw	r2,0(r22)
   1e734:	b885883a 	add	r2,r23,r2
   1e738:	b0800015 	stw	r2,0(r22)
   1e73c:	e500cf26 	beq	fp,r20,1ea7c <_malloc_r+0x6dc>
   1e740:	d1200f17 	ldw	r4,-32708(gp)
   1e744:	00ffffc4 	movi	r3,-1
   1e748:	20c0e026 	beq	r4,r3,1eacc <_malloc_r+0x72c>
   1e74c:	a739c83a 	sub	fp,r20,fp
   1e750:	1705883a 	add	r2,r2,fp
   1e754:	b0800015 	stw	r2,0(r22)
   1e758:	a08001cc 	andi	r2,r20,7
   1e75c:	1000a526 	beq	r2,zero,1e9f4 <_malloc_r+0x654>
   1e760:	a0a9c83a 	sub	r20,r20,r2
   1e764:	00c40204 	movi	r3,4104
   1e768:	a5000204 	addi	r20,r20,8
   1e76c:	1885c83a 	sub	r2,r3,r2
   1e770:	a5c7883a 	add	r3,r20,r23
   1e774:	18c3ffcc 	andi	r3,r3,4095
   1e778:	10efc83a 	sub	r23,r2,r3
   1e77c:	9009883a 	mov	r4,r18
   1e780:	b80b883a 	mov	r5,r23
   1e784:	002034c0 	call	2034c <_sbrk_r>
   1e788:	00ffffc4 	movi	r3,-1
   1e78c:	10c0cc26 	beq	r2,r3,1eac0 <_malloc_r+0x720>
   1e790:	1505c83a 	sub	r2,r2,r20
   1e794:	b887883a 	add	r3,r23,r2
   1e798:	18c00054 	ori	r3,r3,1
   1e79c:	b0800017 	ldw	r2,0(r22)
   1e7a0:	9d000215 	stw	r20,8(r19)
   1e7a4:	a0c00115 	stw	r3,4(r20)
   1e7a8:	b885883a 	add	r2,r23,r2
   1e7ac:	b0800015 	stw	r2,0(r22)
   1e7b0:	84c00e26 	beq	r16,r19,1e7ec <_malloc_r+0x44c>
   1e7b4:	00c003c4 	movi	r3,15
   1e7b8:	1d40902e 	bgeu	r3,r21,1e9fc <_malloc_r+0x65c>
   1e7bc:	ad7ffd04 	addi	r21,r21,-12
   1e7c0:	013ffe04 	movi	r4,-8
   1e7c4:	a908703a 	and	r4,r21,r4
   1e7c8:	810b883a 	add	r5,r16,r4
   1e7cc:	01800144 	movi	r6,5
   1e7d0:	29800115 	stw	r6,4(r5)
   1e7d4:	29800215 	stw	r6,8(r5)
   1e7d8:	81400117 	ldw	r5,4(r16)
   1e7dc:	2940004c 	andi	r5,r5,1
   1e7e0:	214ab03a 	or	r5,r4,r5
   1e7e4:	81400115 	stw	r5,4(r16)
   1e7e8:	1900ae36 	bltu	r3,r4,1eaa4 <_malloc_r+0x704>
   1e7ec:	d0e8d517 	ldw	r3,-23724(gp)
   1e7f0:	1880012e 	bgeu	r3,r2,1e7f8 <_malloc_r+0x458>
   1e7f4:	d0a8d515 	stw	r2,-23724(gp)
   1e7f8:	d0e8d417 	ldw	r3,-23728(gp)
   1e7fc:	9c000217 	ldw	r16,8(r19)
   1e800:	1880012e 	bgeu	r3,r2,1e808 <_malloc_r+0x468>
   1e804:	d0a8d415 	stw	r2,-23728(gp)
   1e808:	80c00117 	ldw	r3,4(r16)
   1e80c:	00bfff04 	movi	r2,-4
   1e810:	1886703a 	and	r3,r3,r2
   1e814:	1c45c83a 	sub	r2,r3,r17
   1e818:	1c400236 	bltu	r3,r17,1e824 <_malloc_r+0x484>
   1e81c:	00c003c4 	movi	r3,15
   1e820:	18800416 	blt	r3,r2,1e834 <_malloc_r+0x494>
   1e824:	9009883a 	mov	r4,r18
   1e828:	0021f800 	call	21f80 <__malloc_unlock>
   1e82c:	0005883a 	mov	r2,zero
   1e830:	003f0906 	br	1e458 <_malloc_r+0xb8>
   1e834:	88c00054 	ori	r3,r17,1
   1e838:	10800054 	ori	r2,r2,1
   1e83c:	80c00115 	stw	r3,4(r16)
   1e840:	8463883a 	add	r17,r16,r17
   1e844:	88800115 	stw	r2,4(r17)
   1e848:	9009883a 	mov	r4,r18
   1e84c:	9c400215 	stw	r17,8(r19)
   1e850:	0021f800 	call	21f80 <__malloc_unlock>
   1e854:	80800204 	addi	r2,r16,8
   1e858:	003eff06 	br	1e458 <_malloc_r+0xb8>
   1e85c:	00800504 	movi	r2,20
   1e860:	1100492e 	bgeu	r2,r4,1e988 <_malloc_r+0x5e8>
   1e864:	00801504 	movi	r2,84
   1e868:	11005c36 	bltu	r2,r4,1e9dc <_malloc_r+0x63c>
   1e86c:	8808d33a 	srli	r4,r17,12
   1e870:	21001b84 	addi	r4,r4,110
   1e874:	210b883a 	add	r5,r4,r4
   1e878:	003f1006 	br	1e4bc <_malloc_r+0x11c>
   1e87c:	1006d27a 	srli	r3,r2,9
   1e880:	01400104 	movi	r5,4
   1e884:	28c0432e 	bgeu	r5,r3,1e994 <_malloc_r+0x5f4>
   1e888:	01400504 	movi	r5,20
   1e88c:	28c07036 	bltu	r5,r3,1ea50 <_malloc_r+0x6b0>
   1e890:	194016c4 	addi	r5,r3,91
   1e894:	294d883a 	add	r6,r5,r5
   1e898:	318d883a 	add	r6,r6,r6
   1e89c:	318d883a 	add	r6,r6,r6
   1e8a0:	998d883a 	add	r6,r19,r6
   1e8a4:	30c00217 	ldw	r3,8(r6)
   1e8a8:	01c000f4 	movhi	r7,3
   1e8ac:	39ce9e04 	addi	r7,r7,14968
   1e8b0:	19805726 	beq	r3,r6,1ea10 <_malloc_r+0x670>
   1e8b4:	01ffff04 	movi	r7,-4
   1e8b8:	19400117 	ldw	r5,4(r3)
   1e8bc:	29ca703a 	and	r5,r5,r7
   1e8c0:	1140022e 	bgeu	r2,r5,1e8cc <_malloc_r+0x52c>
   1e8c4:	18c00217 	ldw	r3,8(r3)
   1e8c8:	30fffb1e 	bne	r6,r3,1e8b8 <_malloc_r+0x518>
   1e8cc:	19400317 	ldw	r5,12(r3)
   1e8d0:	98800117 	ldw	r2,4(r19)
   1e8d4:	81400315 	stw	r5,12(r16)
   1e8d8:	80c00215 	stw	r3,8(r16)
   1e8dc:	2c000215 	stw	r16,8(r5)
   1e8e0:	1c000315 	stw	r16,12(r3)
   1e8e4:	003f2b06 	br	1e594 <_malloc_r+0x1f4>
   1e8e8:	8445883a 	add	r2,r16,r17
   1e8ec:	8c400054 	ori	r17,r17,1
   1e8f0:	18800515 	stw	r2,20(r3)
   1e8f4:	18800415 	stw	r2,16(r3)
   1e8f8:	29000054 	ori	r4,r5,1
   1e8fc:	1147883a 	add	r3,r2,r5
   1e900:	84400115 	stw	r17,4(r16)
   1e904:	11000115 	stw	r4,4(r2)
   1e908:	12400315 	stw	r9,12(r2)
   1e90c:	12400215 	stw	r9,8(r2)
   1e910:	19400015 	stw	r5,0(r3)
   1e914:	9009883a 	mov	r4,r18
   1e918:	0021f800 	call	21f80 <__malloc_unlock>
   1e91c:	80800204 	addi	r2,r16,8
   1e920:	003ecd06 	br	1e458 <_malloc_r+0xb8>
   1e924:	18800117 	ldw	r2,4(r3)
   1e928:	003f1a06 	br	1e594 <_malloc_r+0x1f4>
   1e92c:	5ac00044 	addi	r11,r11,1
   1e930:	588000cc 	andi	r2,r11,3
   1e934:	52800204 	addi	r10,r10,8
   1e938:	103f2e1e 	bne	r2,zero,1e5f4 <_malloc_r+0x254>
   1e93c:	20c000cc 	andi	r3,r4,3
   1e940:	60bffe04 	addi	r2,r12,-8
   1e944:	18006f26 	beq	r3,zero,1eb04 <_malloc_r+0x764>
   1e948:	63000017 	ldw	r12,0(r12)
   1e94c:	213fffc4 	addi	r4,r4,-1
   1e950:	60bffa26 	beq	r12,r2,1e93c <_malloc_r+0x59c>
   1e954:	98800117 	ldw	r2,4(r19)
   1e958:	294b883a 	add	r5,r5,r5
   1e95c:	117f5a36 	bltu	r2,r5,1e6c8 <_malloc_r+0x328>
   1e960:	283f5926 	beq	r5,zero,1e6c8 <_malloc_r+0x328>
   1e964:	1146703a 	and	r3,r2,r5
   1e968:	18001626 	beq	r3,zero,1e9c4 <_malloc_r+0x624>
   1e96c:	5809883a 	mov	r4,r11
   1e970:	003f1a06 	br	1e5dc <_malloc_r+0x23c>
   1e974:	80800204 	addi	r2,r16,8
   1e978:	84000517 	ldw	r16,20(r16)
   1e97c:	143ea81e 	bne	r2,r16,1e420 <_malloc_r+0x80>
   1e980:	21000084 	addi	r4,r4,2
   1e984:	003ee306 	br	1e514 <_malloc_r+0x174>
   1e988:	210016c4 	addi	r4,r4,91
   1e98c:	210b883a 	add	r5,r4,r4
   1e990:	003eca06 	br	1e4bc <_malloc_r+0x11c>
   1e994:	100ad1ba 	srli	r5,r2,6
   1e998:	29400e04 	addi	r5,r5,56
   1e99c:	294d883a 	add	r6,r5,r5
   1e9a0:	003fbd06 	br	1e898 <_malloc_r+0x4f8>
   1e9a4:	84ff6026 	beq	r16,r19,1e728 <_malloc_r+0x388>
   1e9a8:	008000f4 	movhi	r2,3
   1e9ac:	108e9e04 	addi	r2,r2,14968
   1e9b0:	14000217 	ldw	r16,8(r2)
   1e9b4:	00bfff04 	movi	r2,-4
   1e9b8:	80c00117 	ldw	r3,4(r16)
   1e9bc:	1886703a 	and	r3,r3,r2
   1e9c0:	003f9406 	br	1e814 <_malloc_r+0x474>
   1e9c4:	294b883a 	add	r5,r5,r5
   1e9c8:	1146703a 	and	r3,r2,r5
   1e9cc:	5ac00104 	addi	r11,r11,4
   1e9d0:	183ffc26 	beq	r3,zero,1e9c4 <_malloc_r+0x624>
   1e9d4:	5809883a 	mov	r4,r11
   1e9d8:	003f0006 	br	1e5dc <_malloc_r+0x23c>
   1e9dc:	00805504 	movi	r2,340
   1e9e0:	11001336 	bltu	r2,r4,1ea30 <_malloc_r+0x690>
   1e9e4:	8808d3fa 	srli	r4,r17,15
   1e9e8:	21001dc4 	addi	r4,r4,119
   1e9ec:	210b883a 	add	r5,r4,r4
   1e9f0:	003eb206 	br	1e4bc <_malloc_r+0x11c>
   1e9f4:	00840004 	movi	r2,4096
   1e9f8:	003f5d06 	br	1e770 <_malloc_r+0x3d0>
   1e9fc:	00800044 	movi	r2,1
   1ea00:	a0800115 	stw	r2,4(r20)
   1ea04:	a021883a 	mov	r16,r20
   1ea08:	0007883a 	mov	r3,zero
   1ea0c:	003f8106 	br	1e814 <_malloc_r+0x474>
   1ea10:	280bd0ba 	srai	r5,r5,2
   1ea14:	01800044 	movi	r6,1
   1ea18:	38800117 	ldw	r2,4(r7)
   1ea1c:	314c983a 	sll	r6,r6,r5
   1ea20:	180b883a 	mov	r5,r3
   1ea24:	3084b03a 	or	r2,r6,r2
   1ea28:	38800115 	stw	r2,4(r7)
   1ea2c:	003fa906 	br	1e8d4 <_malloc_r+0x534>
   1ea30:	00815504 	movi	r2,1364
   1ea34:	11001836 	bltu	r2,r4,1ea98 <_malloc_r+0x6f8>
   1ea38:	8808d4ba 	srli	r4,r17,18
   1ea3c:	21001f04 	addi	r4,r4,124
   1ea40:	210b883a 	add	r5,r4,r4
   1ea44:	003e9d06 	br	1e4bc <_malloc_r+0x11c>
   1ea48:	bdc00404 	addi	r23,r23,16
   1ea4c:	003f2f06 	br	1e70c <_malloc_r+0x36c>
   1ea50:	01401504 	movi	r5,84
   1ea54:	28c01f36 	bltu	r5,r3,1ead4 <_malloc_r+0x734>
   1ea58:	100ad33a 	srli	r5,r2,12
   1ea5c:	29401b84 	addi	r5,r5,110
   1ea60:	294d883a 	add	r6,r5,r5
   1ea64:	003f8c06 	br	1e898 <_malloc_r+0x4f8>
   1ea68:	9c000217 	ldw	r16,8(r19)
   1ea6c:	00bfff04 	movi	r2,-4
   1ea70:	80c00117 	ldw	r3,4(r16)
   1ea74:	1886703a 	and	r3,r3,r2
   1ea78:	003f6606 	br	1e814 <_malloc_r+0x474>
   1ea7c:	e0c3ffcc 	andi	r3,fp,4095
   1ea80:	183f2f1e 	bne	r3,zero,1e740 <_malloc_r+0x3a0>
   1ea84:	98c00217 	ldw	r3,8(r19)
   1ea88:	bd49883a 	add	r4,r23,r21
   1ea8c:	21000054 	ori	r4,r4,1
   1ea90:	19000115 	stw	r4,4(r3)
   1ea94:	003f5506 	br	1e7ec <_malloc_r+0x44c>
   1ea98:	01403f04 	movi	r5,252
   1ea9c:	01001f84 	movi	r4,126
   1eaa0:	003e8606 	br	1e4bc <_malloc_r+0x11c>
   1eaa4:	9009883a 	mov	r4,r18
   1eaa8:	81400204 	addi	r5,r16,8
   1eaac:	001d8080 	call	1d808 <_free_r>
   1eab0:	00800134 	movhi	r2,4
   1eab4:	10977104 	addi	r2,r2,24004
   1eab8:	10800017 	ldw	r2,0(r2)
   1eabc:	003f4b06 	br	1e7ec <_malloc_r+0x44c>
   1eac0:	00c00044 	movi	r3,1
   1eac4:	002f883a 	mov	r23,zero
   1eac8:	003f3406 	br	1e79c <_malloc_r+0x3fc>
   1eacc:	d5200f15 	stw	r20,-32708(gp)
   1ead0:	003f2106 	br	1e758 <_malloc_r+0x3b8>
   1ead4:	01405504 	movi	r5,340
   1ead8:	28c00436 	bltu	r5,r3,1eaec <_malloc_r+0x74c>
   1eadc:	100ad3fa 	srli	r5,r2,15
   1eae0:	29401dc4 	addi	r5,r5,119
   1eae4:	294d883a 	add	r6,r5,r5
   1eae8:	003f6b06 	br	1e898 <_malloc_r+0x4f8>
   1eaec:	01415504 	movi	r5,1364
   1eaf0:	28c00936 	bltu	r5,r3,1eb18 <_malloc_r+0x778>
   1eaf4:	100ad4ba 	srli	r5,r2,18
   1eaf8:	29401f04 	addi	r5,r5,124
   1eafc:	294d883a 	add	r6,r5,r5
   1eb00:	003f6506 	br	1e898 <_malloc_r+0x4f8>
   1eb04:	98800117 	ldw	r2,4(r19)
   1eb08:	0146303a 	nor	r3,zero,r5
   1eb0c:	1884703a 	and	r2,r3,r2
   1eb10:	98800115 	stw	r2,4(r19)
   1eb14:	003f9006 	br	1e958 <_malloc_r+0x5b8>
   1eb18:	01803f04 	movi	r6,252
   1eb1c:	01401f84 	movi	r5,126
   1eb20:	003f5d06 	br	1e898 <_malloc_r+0x4f8>

0001eb24 <memchr>:
   1eb24:	008000c4 	movi	r2,3
   1eb28:	29403fcc 	andi	r5,r5,255
   1eb2c:	1180282e 	bgeu	r2,r6,1ebd0 <memchr+0xac>
   1eb30:	2086703a 	and	r3,r4,r2
   1eb34:	1800351e 	bne	r3,zero,1ec0c <memchr+0xe8>
   1eb38:	2816923a 	slli	r11,r5,8
   1eb3c:	2093883a 	add	r9,r4,r2
   1eb40:	22000084 	addi	r8,r4,2
   1eb44:	5957883a 	add	r11,r11,r5
   1eb48:	5816923a 	slli	r11,r11,8
   1eb4c:	20c00044 	addi	r3,r4,1
   1eb50:	037fbff4 	movhi	r13,65279
   1eb54:	6b7fbfc4 	addi	r13,r13,-257
   1eb58:	5957883a 	add	r11,r11,r5
   1eb5c:	5816923a 	slli	r11,r11,8
   1eb60:	03202074 	movhi	r12,32897
   1eb64:	63202004 	addi	r12,r12,-32640
   1eb68:	101d883a 	mov	r14,r2
   1eb6c:	5957883a 	add	r11,r11,r5
   1eb70:	21c00017 	ldw	r7,0(r4)
   1eb74:	31bfff04 	addi	r6,r6,-4
   1eb78:	1805883a 	mov	r2,r3
   1eb7c:	3acef03a 	xor	r7,r7,r11
   1eb80:	3b55883a 	add	r10,r7,r13
   1eb84:	01ce303a 	nor	r7,zero,r7
   1eb88:	51ce703a 	and	r7,r10,r7
   1eb8c:	3b0e703a 	and	r7,r7,r12
   1eb90:	38000a26 	beq	r7,zero,1ebbc <memchr+0x98>
   1eb94:	21c00003 	ldbu	r7,0(r4)
   1eb98:	39401e26 	beq	r7,r5,1ec14 <memchr+0xf0>
   1eb9c:	19c00003 	ldbu	r7,0(r3)
   1eba0:	39401926 	beq	r7,r5,1ec08 <memchr+0xe4>
   1eba4:	41c00003 	ldbu	r7,0(r8)
   1eba8:	4005883a 	mov	r2,r8
   1ebac:	39401626 	beq	r7,r5,1ec08 <memchr+0xe4>
   1ebb0:	49c00003 	ldbu	r7,0(r9)
   1ebb4:	4805883a 	mov	r2,r9
   1ebb8:	39401326 	beq	r7,r5,1ec08 <memchr+0xe4>
   1ebbc:	21000104 	addi	r4,r4,4
   1ebc0:	4a400104 	addi	r9,r9,4
   1ebc4:	42000104 	addi	r8,r8,4
   1ebc8:	18c00104 	addi	r3,r3,4
   1ebcc:	71bfe836 	bltu	r14,r6,1eb70 <memchr+0x4c>
   1ebd0:	2005883a 	mov	r2,r4
   1ebd4:	30000a26 	beq	r6,zero,1ec00 <memchr+0xdc>
   1ebd8:	10c00003 	ldbu	r3,0(r2)
   1ebdc:	19400a26 	beq	r3,r5,1ec08 <memchr+0xe4>
   1ebe0:	10c00044 	addi	r3,r2,1
   1ebe4:	118d883a 	add	r6,r2,r6
   1ebe8:	00000306 	br	1ebf8 <memchr+0xd4>
   1ebec:	11000003 	ldbu	r4,0(r2)
   1ebf0:	18c00044 	addi	r3,r3,1
   1ebf4:	21400426 	beq	r4,r5,1ec08 <memchr+0xe4>
   1ebf8:	1805883a 	mov	r2,r3
   1ebfc:	19bffb1e 	bne	r3,r6,1ebec <memchr+0xc8>
   1ec00:	0005883a 	mov	r2,zero
   1ec04:	f800283a 	ret
   1ec08:	f800283a 	ret
   1ec0c:	2005883a 	mov	r2,r4
   1ec10:	003ff106 	br	1ebd8 <memchr+0xb4>
   1ec14:	2005883a 	mov	r2,r4
   1ec18:	f800283a 	ret

0001ec1c <memmove>:
   1ec1c:	2005883a 	mov	r2,r4
   1ec20:	300f883a 	mov	r7,r6
   1ec24:	29000b2e 	bgeu	r5,r4,1ec54 <memmove+0x38>
   1ec28:	2987883a 	add	r3,r5,r6
   1ec2c:	20c0092e 	bgeu	r4,r3,1ec54 <memmove+0x38>
   1ec30:	218b883a 	add	r5,r4,r6
   1ec34:	198fc83a 	sub	r7,r3,r6
   1ec38:	30003f26 	beq	r6,zero,1ed38 <memmove+0x11c>
   1ec3c:	18ffffc4 	addi	r3,r3,-1
   1ec40:	19000003 	ldbu	r4,0(r3)
   1ec44:	297fffc4 	addi	r5,r5,-1
   1ec48:	29000005 	stb	r4,0(r5)
   1ec4c:	19fffb1e 	bne	r3,r7,1ec3c <memmove+0x20>
   1ec50:	f800283a 	ret
   1ec54:	00c003c4 	movi	r3,15
   1ec58:	1980382e 	bgeu	r3,r6,1ed3c <memmove+0x120>
   1ec5c:	2886b03a 	or	r3,r5,r2
   1ec60:	18c000cc 	andi	r3,r3,3
   1ec64:	1800351e 	bne	r3,zero,1ed3c <memmove+0x120>
   1ec68:	327ffc04 	addi	r9,r6,-16
   1ec6c:	4812d13a 	srli	r9,r9,4
   1ec70:	12000404 	addi	r8,r2,16
   1ec74:	1007883a 	mov	r3,r2
   1ec78:	4808913a 	slli	r4,r9,4
   1ec7c:	280f883a 	mov	r7,r5
   1ec80:	4111883a 	add	r8,r8,r4
   1ec84:	39000017 	ldw	r4,0(r7)
   1ec88:	18c00404 	addi	r3,r3,16
   1ec8c:	39c00404 	addi	r7,r7,16
   1ec90:	193ffc15 	stw	r4,-16(r3)
   1ec94:	393ffd17 	ldw	r4,-12(r7)
   1ec98:	193ffd15 	stw	r4,-12(r3)
   1ec9c:	393ffe17 	ldw	r4,-8(r7)
   1eca0:	193ffe15 	stw	r4,-8(r3)
   1eca4:	393fff17 	ldw	r4,-4(r7)
   1eca8:	193fff15 	stw	r4,-4(r3)
   1ecac:	1a3ff51e 	bne	r3,r8,1ec84 <memmove+0x68>
   1ecb0:	49000044 	addi	r4,r9,1
   1ecb4:	2008913a 	slli	r4,r4,4
   1ecb8:	31c003cc 	andi	r7,r6,15
   1ecbc:	1107883a 	add	r3,r2,r4
   1ecc0:	290b883a 	add	r5,r5,r4
   1ecc4:	010000c4 	movi	r4,3
   1ecc8:	21c0142e 	bgeu	r4,r7,1ed1c <memmove+0x100>
   1eccc:	39ffff04 	addi	r7,r7,-4
   1ecd0:	3814d0ba 	srli	r10,r7,2
   1ecd4:	1a400104 	addi	r9,r3,4
   1ecd8:	180d883a 	mov	r6,r3
   1ecdc:	5289883a 	add	r4,r10,r10
   1ece0:	2109883a 	add	r4,r4,r4
   1ece4:	4913883a 	add	r9,r9,r4
   1ece8:	2809883a 	mov	r4,r5
   1ecec:	22000017 	ldw	r8,0(r4)
   1ecf0:	31800104 	addi	r6,r6,4
   1ecf4:	21000104 	addi	r4,r4,4
   1ecf8:	323fff15 	stw	r8,-4(r6)
   1ecfc:	327ffb1e 	bne	r6,r9,1ecec <memmove+0xd0>
   1ed00:	51000044 	addi	r4,r10,1
   1ed04:	52bfff24 	muli	r10,r10,-4
   1ed08:	2109883a 	add	r4,r4,r4
   1ed0c:	2109883a 	add	r4,r4,r4
   1ed10:	51cf883a 	add	r7,r10,r7
   1ed14:	290b883a 	add	r5,r5,r4
   1ed18:	1907883a 	add	r3,r3,r4
   1ed1c:	38000626 	beq	r7,zero,1ed38 <memmove+0x11c>
   1ed20:	19cf883a 	add	r7,r3,r7
   1ed24:	29800003 	ldbu	r6,0(r5)
   1ed28:	18c00044 	addi	r3,r3,1
   1ed2c:	29400044 	addi	r5,r5,1
   1ed30:	19bfffc5 	stb	r6,-1(r3)
   1ed34:	19fffb1e 	bne	r3,r7,1ed24 <memmove+0x108>
   1ed38:	f800283a 	ret
   1ed3c:	1007883a 	mov	r3,r2
   1ed40:	003ff606 	br	1ed1c <memmove+0x100>

0001ed44 <_Balloc>:
   1ed44:	20801317 	ldw	r2,76(r4)
   1ed48:	defffc04 	addi	sp,sp,-16
   1ed4c:	dc400115 	stw	r17,4(sp)
   1ed50:	dc000015 	stw	r16,0(sp)
   1ed54:	dfc00315 	stw	ra,12(sp)
   1ed58:	dc800215 	stw	r18,8(sp)
   1ed5c:	2023883a 	mov	r17,r4
   1ed60:	2821883a 	mov	r16,r5
   1ed64:	10000f26 	beq	r2,zero,1eda4 <_Balloc+0x60>
   1ed68:	8407883a 	add	r3,r16,r16
   1ed6c:	18c7883a 	add	r3,r3,r3
   1ed70:	10c7883a 	add	r3,r2,r3
   1ed74:	18800017 	ldw	r2,0(r3)
   1ed78:	10001126 	beq	r2,zero,1edc0 <_Balloc+0x7c>
   1ed7c:	11000017 	ldw	r4,0(r2)
   1ed80:	19000015 	stw	r4,0(r3)
   1ed84:	10000415 	stw	zero,16(r2)
   1ed88:	10000315 	stw	zero,12(r2)
   1ed8c:	dfc00317 	ldw	ra,12(sp)
   1ed90:	dc800217 	ldw	r18,8(sp)
   1ed94:	dc400117 	ldw	r17,4(sp)
   1ed98:	dc000017 	ldw	r16,0(sp)
   1ed9c:	dec00404 	addi	sp,sp,16
   1eda0:	f800283a 	ret
   1eda4:	01400104 	movi	r5,4
   1eda8:	01800404 	movi	r6,16
   1edac:	002055c0 	call	2055c <_calloc_r>
   1edb0:	88801315 	stw	r2,76(r17)
   1edb4:	103fec1e 	bne	r2,zero,1ed68 <_Balloc+0x24>
   1edb8:	0005883a 	mov	r2,zero
   1edbc:	003ff306 	br	1ed8c <_Balloc+0x48>
   1edc0:	01400044 	movi	r5,1
   1edc4:	2c24983a 	sll	r18,r5,r16
   1edc8:	8809883a 	mov	r4,r17
   1edcc:	91800144 	addi	r6,r18,5
   1edd0:	318d883a 	add	r6,r6,r6
   1edd4:	318d883a 	add	r6,r6,r6
   1edd8:	002055c0 	call	2055c <_calloc_r>
   1eddc:	103ff626 	beq	r2,zero,1edb8 <_Balloc+0x74>
   1ede0:	14000115 	stw	r16,4(r2)
   1ede4:	14800215 	stw	r18,8(r2)
   1ede8:	003fe606 	br	1ed84 <_Balloc+0x40>

0001edec <_Bfree>:
   1edec:	28000826 	beq	r5,zero,1ee10 <_Bfree+0x24>
   1edf0:	28c00117 	ldw	r3,4(r5)
   1edf4:	20801317 	ldw	r2,76(r4)
   1edf8:	18c7883a 	add	r3,r3,r3
   1edfc:	18c7883a 	add	r3,r3,r3
   1ee00:	10c5883a 	add	r2,r2,r3
   1ee04:	10c00017 	ldw	r3,0(r2)
   1ee08:	28c00015 	stw	r3,0(r5)
   1ee0c:	11400015 	stw	r5,0(r2)
   1ee10:	f800283a 	ret

0001ee14 <__multadd>:
   1ee14:	defffa04 	addi	sp,sp,-24
   1ee18:	dc000115 	stw	r16,4(sp)
   1ee1c:	2c000417 	ldw	r16,16(r5)
   1ee20:	dc800315 	stw	r18,12(sp)
   1ee24:	dc400215 	stw	r17,8(sp)
   1ee28:	dfc00515 	stw	ra,20(sp)
   1ee2c:	dcc00415 	stw	r19,16(sp)
   1ee30:	2823883a 	mov	r17,r5
   1ee34:	2025883a 	mov	r18,r4
   1ee38:	28c00504 	addi	r3,r5,20
   1ee3c:	0011883a 	mov	r8,zero
   1ee40:	1a800017 	ldw	r10,0(r3)
   1ee44:	18c00104 	addi	r3,r3,4
   1ee48:	42000044 	addi	r8,r8,1
   1ee4c:	527fffcc 	andi	r9,r10,65535
   1ee50:	4993383a 	mul	r9,r9,r6
   1ee54:	5014d43a 	srli	r10,r10,16
   1ee58:	49d3883a 	add	r9,r9,r7
   1ee5c:	480ed43a 	srli	r7,r9,16
   1ee60:	5195383a 	mul	r10,r10,r6
   1ee64:	4a7fffcc 	andi	r9,r9,65535
   1ee68:	3a8f883a 	add	r7,r7,r10
   1ee6c:	3814943a 	slli	r10,r7,16
   1ee70:	380ed43a 	srli	r7,r7,16
   1ee74:	5253883a 	add	r9,r10,r9
   1ee78:	1a7fff15 	stw	r9,-4(r3)
   1ee7c:	443ff016 	blt	r8,r16,1ee40 <__multadd+0x2c>
   1ee80:	38000926 	beq	r7,zero,1eea8 <__multadd+0x94>
   1ee84:	88800217 	ldw	r2,8(r17)
   1ee88:	80800f0e 	bge	r16,r2,1eec8 <__multadd+0xb4>
   1ee8c:	80800144 	addi	r2,r16,5
   1ee90:	1085883a 	add	r2,r2,r2
   1ee94:	1085883a 	add	r2,r2,r2
   1ee98:	8885883a 	add	r2,r17,r2
   1ee9c:	84000044 	addi	r16,r16,1
   1eea0:	11c00015 	stw	r7,0(r2)
   1eea4:	8c000415 	stw	r16,16(r17)
   1eea8:	8805883a 	mov	r2,r17
   1eeac:	dfc00517 	ldw	ra,20(sp)
   1eeb0:	dcc00417 	ldw	r19,16(sp)
   1eeb4:	dc800317 	ldw	r18,12(sp)
   1eeb8:	dc400217 	ldw	r17,8(sp)
   1eebc:	dc000117 	ldw	r16,4(sp)
   1eec0:	dec00604 	addi	sp,sp,24
   1eec4:	f800283a 	ret
   1eec8:	89400117 	ldw	r5,4(r17)
   1eecc:	9009883a 	mov	r4,r18
   1eed0:	d9c00015 	stw	r7,0(sp)
   1eed4:	29400044 	addi	r5,r5,1
   1eed8:	001ed440 	call	1ed44 <_Balloc>
   1eedc:	89800417 	ldw	r6,16(r17)
   1eee0:	89400304 	addi	r5,r17,12
   1eee4:	11000304 	addi	r4,r2,12
   1eee8:	31800084 	addi	r6,r6,2
   1eeec:	318d883a 	add	r6,r6,r6
   1eef0:	318d883a 	add	r6,r6,r6
   1eef4:	1027883a 	mov	r19,r2
   1eef8:	00191f00 	call	191f0 <memcpy>
   1eefc:	88c00117 	ldw	r3,4(r17)
   1ef00:	90801317 	ldw	r2,76(r18)
   1ef04:	d9c00017 	ldw	r7,0(sp)
   1ef08:	18c7883a 	add	r3,r3,r3
   1ef0c:	18c7883a 	add	r3,r3,r3
   1ef10:	10c5883a 	add	r2,r2,r3
   1ef14:	10c00017 	ldw	r3,0(r2)
   1ef18:	88c00015 	stw	r3,0(r17)
   1ef1c:	14400015 	stw	r17,0(r2)
   1ef20:	9823883a 	mov	r17,r19
   1ef24:	003fd906 	br	1ee8c <__multadd+0x78>

0001ef28 <__s2b>:
   1ef28:	defff904 	addi	sp,sp,-28
   1ef2c:	dd000415 	stw	r20,16(sp)
   1ef30:	dc400115 	stw	r17,4(sp)
   1ef34:	2829883a 	mov	r20,r5
   1ef38:	2023883a 	mov	r17,r4
   1ef3c:	01400244 	movi	r5,9
   1ef40:	39000204 	addi	r4,r7,8
   1ef44:	dcc00315 	stw	r19,12(sp)
   1ef48:	dc800215 	stw	r18,8(sp)
   1ef4c:	dfc00615 	stw	ra,24(sp)
   1ef50:	dd400515 	stw	r21,20(sp)
   1ef54:	dc000015 	stw	r16,0(sp)
   1ef58:	3825883a 	mov	r18,r7
   1ef5c:	3027883a 	mov	r19,r6
   1ef60:	00217840 	call	21784 <__divsi3>
   1ef64:	00c00044 	movi	r3,1
   1ef68:	000b883a 	mov	r5,zero
   1ef6c:	1880030e 	bge	r3,r2,1ef7c <__s2b+0x54>
   1ef70:	18c7883a 	add	r3,r3,r3
   1ef74:	29400044 	addi	r5,r5,1
   1ef78:	18bffd16 	blt	r3,r2,1ef70 <__s2b+0x48>
   1ef7c:	8809883a 	mov	r4,r17
   1ef80:	001ed440 	call	1ed44 <_Balloc>
   1ef84:	d8c00717 	ldw	r3,28(sp)
   1ef88:	10c00515 	stw	r3,20(r2)
   1ef8c:	00c00044 	movi	r3,1
   1ef90:	10c00415 	stw	r3,16(r2)
   1ef94:	00c00244 	movi	r3,9
   1ef98:	1cc0210e 	bge	r3,r19,1f020 <__s2b+0xf8>
   1ef9c:	a0eb883a 	add	r21,r20,r3
   1efa0:	a821883a 	mov	r16,r21
   1efa4:	a4e9883a 	add	r20,r20,r19
   1efa8:	81c00007 	ldb	r7,0(r16)
   1efac:	8809883a 	mov	r4,r17
   1efb0:	84000044 	addi	r16,r16,1
   1efb4:	100b883a 	mov	r5,r2
   1efb8:	01800284 	movi	r6,10
   1efbc:	39fff404 	addi	r7,r7,-48
   1efc0:	001ee140 	call	1ee14 <__multadd>
   1efc4:	853ff81e 	bne	r16,r20,1efa8 <__s2b+0x80>
   1efc8:	ace1883a 	add	r16,r21,r19
   1efcc:	843ffe04 	addi	r16,r16,-8
   1efd0:	9c800a0e 	bge	r19,r18,1effc <__s2b+0xd4>
   1efd4:	94e5c83a 	sub	r18,r18,r19
   1efd8:	84a5883a 	add	r18,r16,r18
   1efdc:	81c00007 	ldb	r7,0(r16)
   1efe0:	8809883a 	mov	r4,r17
   1efe4:	84000044 	addi	r16,r16,1
   1efe8:	100b883a 	mov	r5,r2
   1efec:	01800284 	movi	r6,10
   1eff0:	39fff404 	addi	r7,r7,-48
   1eff4:	001ee140 	call	1ee14 <__multadd>
   1eff8:	84bff81e 	bne	r16,r18,1efdc <__s2b+0xb4>
   1effc:	dfc00617 	ldw	ra,24(sp)
   1f000:	dd400517 	ldw	r21,20(sp)
   1f004:	dd000417 	ldw	r20,16(sp)
   1f008:	dcc00317 	ldw	r19,12(sp)
   1f00c:	dc800217 	ldw	r18,8(sp)
   1f010:	dc400117 	ldw	r17,4(sp)
   1f014:	dc000017 	ldw	r16,0(sp)
   1f018:	dec00704 	addi	sp,sp,28
   1f01c:	f800283a 	ret
   1f020:	a4000284 	addi	r16,r20,10
   1f024:	1827883a 	mov	r19,r3
   1f028:	003fe906 	br	1efd0 <__s2b+0xa8>

0001f02c <__hi0bits>:
   1f02c:	20bfffec 	andhi	r2,r4,65535
   1f030:	1000141e 	bne	r2,zero,1f084 <__hi0bits+0x58>
   1f034:	2008943a 	slli	r4,r4,16
   1f038:	00800404 	movi	r2,16
   1f03c:	20ffc02c 	andhi	r3,r4,65280
   1f040:	1800021e 	bne	r3,zero,1f04c <__hi0bits+0x20>
   1f044:	2008923a 	slli	r4,r4,8
   1f048:	10800204 	addi	r2,r2,8
   1f04c:	20fc002c 	andhi	r3,r4,61440
   1f050:	1800021e 	bne	r3,zero,1f05c <__hi0bits+0x30>
   1f054:	2008913a 	slli	r4,r4,4
   1f058:	10800104 	addi	r2,r2,4
   1f05c:	20f0002c 	andhi	r3,r4,49152
   1f060:	1800031e 	bne	r3,zero,1f070 <__hi0bits+0x44>
   1f064:	2109883a 	add	r4,r4,r4
   1f068:	10800084 	addi	r2,r2,2
   1f06c:	2109883a 	add	r4,r4,r4
   1f070:	20000316 	blt	r4,zero,1f080 <__hi0bits+0x54>
   1f074:	2110002c 	andhi	r4,r4,16384
   1f078:	2000041e 	bne	r4,zero,1f08c <__hi0bits+0x60>
   1f07c:	00800804 	movi	r2,32
   1f080:	f800283a 	ret
   1f084:	0005883a 	mov	r2,zero
   1f088:	003fec06 	br	1f03c <__hi0bits+0x10>
   1f08c:	10800044 	addi	r2,r2,1
   1f090:	f800283a 	ret

0001f094 <__lo0bits>:
   1f094:	20c00017 	ldw	r3,0(r4)
   1f098:	188001cc 	andi	r2,r3,7
   1f09c:	10000826 	beq	r2,zero,1f0c0 <__lo0bits+0x2c>
   1f0a0:	1880004c 	andi	r2,r3,1
   1f0a4:	1000211e 	bne	r2,zero,1f12c <__lo0bits+0x98>
   1f0a8:	1880008c 	andi	r2,r3,2
   1f0ac:	1000211e 	bne	r2,zero,1f134 <__lo0bits+0xa0>
   1f0b0:	1806d0ba 	srli	r3,r3,2
   1f0b4:	00800084 	movi	r2,2
   1f0b8:	20c00015 	stw	r3,0(r4)
   1f0bc:	f800283a 	ret
   1f0c0:	18bfffcc 	andi	r2,r3,65535
   1f0c4:	10001326 	beq	r2,zero,1f114 <__lo0bits+0x80>
   1f0c8:	0005883a 	mov	r2,zero
   1f0cc:	19403fcc 	andi	r5,r3,255
   1f0d0:	2800021e 	bne	r5,zero,1f0dc <__lo0bits+0x48>
   1f0d4:	1806d23a 	srli	r3,r3,8
   1f0d8:	10800204 	addi	r2,r2,8
   1f0dc:	194003cc 	andi	r5,r3,15
   1f0e0:	2800021e 	bne	r5,zero,1f0ec <__lo0bits+0x58>
   1f0e4:	1806d13a 	srli	r3,r3,4
   1f0e8:	10800104 	addi	r2,r2,4
   1f0ec:	194000cc 	andi	r5,r3,3
   1f0f0:	2800021e 	bne	r5,zero,1f0fc <__lo0bits+0x68>
   1f0f4:	1806d0ba 	srli	r3,r3,2
   1f0f8:	10800084 	addi	r2,r2,2
   1f0fc:	1940004c 	andi	r5,r3,1
   1f100:	2800081e 	bne	r5,zero,1f124 <__lo0bits+0x90>
   1f104:	1806d07a 	srli	r3,r3,1
   1f108:	1800051e 	bne	r3,zero,1f120 <__lo0bits+0x8c>
   1f10c:	00800804 	movi	r2,32
   1f110:	f800283a 	ret
   1f114:	1806d43a 	srli	r3,r3,16
   1f118:	00800404 	movi	r2,16
   1f11c:	003feb06 	br	1f0cc <__lo0bits+0x38>
   1f120:	10800044 	addi	r2,r2,1
   1f124:	20c00015 	stw	r3,0(r4)
   1f128:	f800283a 	ret
   1f12c:	0005883a 	mov	r2,zero
   1f130:	f800283a 	ret
   1f134:	1806d07a 	srli	r3,r3,1
   1f138:	00800044 	movi	r2,1
   1f13c:	20c00015 	stw	r3,0(r4)
   1f140:	f800283a 	ret

0001f144 <__i2b>:
   1f144:	defffd04 	addi	sp,sp,-12
   1f148:	dc000015 	stw	r16,0(sp)
   1f14c:	04000044 	movi	r16,1
   1f150:	dc400115 	stw	r17,4(sp)
   1f154:	2823883a 	mov	r17,r5
   1f158:	800b883a 	mov	r5,r16
   1f15c:	dfc00215 	stw	ra,8(sp)
   1f160:	001ed440 	call	1ed44 <_Balloc>
   1f164:	14400515 	stw	r17,20(r2)
   1f168:	14000415 	stw	r16,16(r2)
   1f16c:	dfc00217 	ldw	ra,8(sp)
   1f170:	dc400117 	ldw	r17,4(sp)
   1f174:	dc000017 	ldw	r16,0(sp)
   1f178:	dec00304 	addi	sp,sp,12
   1f17c:	f800283a 	ret

0001f180 <__multiply>:
   1f180:	defffa04 	addi	sp,sp,-24
   1f184:	dcc00315 	stw	r19,12(sp)
   1f188:	dc400115 	stw	r17,4(sp)
   1f18c:	34c00417 	ldw	r19,16(r6)
   1f190:	2c400417 	ldw	r17,16(r5)
   1f194:	dd000415 	stw	r20,16(sp)
   1f198:	dc800215 	stw	r18,8(sp)
   1f19c:	dfc00515 	stw	ra,20(sp)
   1f1a0:	dc000015 	stw	r16,0(sp)
   1f1a4:	2825883a 	mov	r18,r5
   1f1a8:	3029883a 	mov	r20,r6
   1f1ac:	8cc0050e 	bge	r17,r19,1f1c4 <__multiply+0x44>
   1f1b0:	8807883a 	mov	r3,r17
   1f1b4:	3025883a 	mov	r18,r6
   1f1b8:	9823883a 	mov	r17,r19
   1f1bc:	2829883a 	mov	r20,r5
   1f1c0:	1827883a 	mov	r19,r3
   1f1c4:	90800217 	ldw	r2,8(r18)
   1f1c8:	8ce1883a 	add	r16,r17,r19
   1f1cc:	91400117 	ldw	r5,4(r18)
   1f1d0:	1400010e 	bge	r2,r16,1f1d8 <__multiply+0x58>
   1f1d4:	29400044 	addi	r5,r5,1
   1f1d8:	001ed440 	call	1ed44 <_Balloc>
   1f1dc:	83c00144 	addi	r15,r16,5
   1f1e0:	7bdf883a 	add	r15,r15,r15
   1f1e4:	7bdf883a 	add	r15,r15,r15
   1f1e8:	13800504 	addi	r14,r2,20
   1f1ec:	13df883a 	add	r15,r2,r15
   1f1f0:	7007883a 	mov	r3,r14
   1f1f4:	73c0032e 	bgeu	r14,r15,1f204 <__multiply+0x84>
   1f1f8:	18000015 	stw	zero,0(r3)
   1f1fc:	18c00104 	addi	r3,r3,4
   1f200:	1bfffd36 	bltu	r3,r15,1f1f8 <__multiply+0x78>
   1f204:	99800144 	addi	r6,r19,5
   1f208:	8b000144 	addi	r12,r17,5
   1f20c:	318d883a 	add	r6,r6,r6
   1f210:	6319883a 	add	r12,r12,r12
   1f214:	318d883a 	add	r6,r6,r6
   1f218:	6319883a 	add	r12,r12,r12
   1f21c:	a3400504 	addi	r13,r20,20
   1f220:	a18d883a 	add	r6,r20,r6
   1f224:	94400504 	addi	r17,r18,20
   1f228:	9319883a 	add	r12,r18,r12
   1f22c:	6980392e 	bgeu	r13,r6,1f314 <__multiply+0x194>
   1f230:	6a800017 	ldw	r10,0(r13)
   1f234:	52ffffcc 	andi	r11,r10,65535
   1f238:	58001826 	beq	r11,zero,1f29c <__multiply+0x11c>
   1f23c:	7007883a 	mov	r3,r14
   1f240:	8809883a 	mov	r4,r17
   1f244:	000b883a 	mov	r5,zero
   1f248:	22400017 	ldw	r9,0(r4)
   1f24c:	1a000017 	ldw	r8,0(r3)
   1f250:	21000104 	addi	r4,r4,4
   1f254:	49ffffcc 	andi	r7,r9,65535
   1f258:	3acf383a 	mul	r7,r7,r11
   1f25c:	4812d43a 	srli	r9,r9,16
   1f260:	42bfffcc 	andi	r10,r8,65535
   1f264:	3a8f883a 	add	r7,r7,r10
   1f268:	394f883a 	add	r7,r7,r5
   1f26c:	4010d43a 	srli	r8,r8,16
   1f270:	4acb383a 	mul	r5,r9,r11
   1f274:	3814d43a 	srli	r10,r7,16
   1f278:	19c0000d 	sth	r7,0(r3)
   1f27c:	2a0b883a 	add	r5,r5,r8
   1f280:	2a8b883a 	add	r5,r5,r10
   1f284:	1940008d 	sth	r5,2(r3)
   1f288:	280ad43a 	srli	r5,r5,16
   1f28c:	18c00104 	addi	r3,r3,4
   1f290:	233fed36 	bltu	r4,r12,1f248 <__multiply+0xc8>
   1f294:	19400015 	stw	r5,0(r3)
   1f298:	6a800017 	ldw	r10,0(r13)
   1f29c:	5014d43a 	srli	r10,r10,16
   1f2a0:	50001926 	beq	r10,zero,1f308 <__multiply+0x188>
   1f2a4:	71400017 	ldw	r5,0(r14)
   1f2a8:	7007883a 	mov	r3,r14
   1f2ac:	8809883a 	mov	r4,r17
   1f2b0:	280f883a 	mov	r7,r5
   1f2b4:	0017883a 	mov	r11,zero
   1f2b8:	22400017 	ldw	r9,0(r4)
   1f2bc:	380ed43a 	srli	r7,r7,16
   1f2c0:	1940000d 	sth	r5,0(r3)
   1f2c4:	4a3fffcc 	andi	r8,r9,65535
   1f2c8:	4291383a 	mul	r8,r8,r10
   1f2cc:	4812d43a 	srli	r9,r9,16
   1f2d0:	18c00104 	addi	r3,r3,4
   1f2d4:	41d1883a 	add	r8,r8,r7
   1f2d8:	19c00017 	ldw	r7,0(r3)
   1f2dc:	42d1883a 	add	r8,r8,r11
   1f2e0:	4a93383a 	mul	r9,r9,r10
   1f2e4:	1a3fff8d 	sth	r8,-2(r3)
   1f2e8:	4010d43a 	srli	r8,r8,16
   1f2ec:	397fffcc 	andi	r5,r7,65535
   1f2f0:	2a4b883a 	add	r5,r5,r9
   1f2f4:	2a0b883a 	add	r5,r5,r8
   1f2f8:	21000104 	addi	r4,r4,4
   1f2fc:	2816d43a 	srli	r11,r5,16
   1f300:	233fed36 	bltu	r4,r12,1f2b8 <__multiply+0x138>
   1f304:	19400015 	stw	r5,0(r3)
   1f308:	6b400104 	addi	r13,r13,4
   1f30c:	73800104 	addi	r14,r14,4
   1f310:	69bfc736 	bltu	r13,r6,1f230 <__multiply+0xb0>
   1f314:	0400090e 	bge	zero,r16,1f33c <__multiply+0x1bc>
   1f318:	78ffff17 	ldw	r3,-4(r15)
   1f31c:	7bffff04 	addi	r15,r15,-4
   1f320:	18000326 	beq	r3,zero,1f330 <__multiply+0x1b0>
   1f324:	00000506 	br	1f33c <__multiply+0x1bc>
   1f328:	78c00017 	ldw	r3,0(r15)
   1f32c:	1800031e 	bne	r3,zero,1f33c <__multiply+0x1bc>
   1f330:	843fffc4 	addi	r16,r16,-1
   1f334:	7bffff04 	addi	r15,r15,-4
   1f338:	803ffb1e 	bne	r16,zero,1f328 <__multiply+0x1a8>
   1f33c:	14000415 	stw	r16,16(r2)
   1f340:	dfc00517 	ldw	ra,20(sp)
   1f344:	dd000417 	ldw	r20,16(sp)
   1f348:	dcc00317 	ldw	r19,12(sp)
   1f34c:	dc800217 	ldw	r18,8(sp)
   1f350:	dc400117 	ldw	r17,4(sp)
   1f354:	dc000017 	ldw	r16,0(sp)
   1f358:	dec00604 	addi	sp,sp,24
   1f35c:	f800283a 	ret

0001f360 <__pow5mult>:
   1f360:	defffb04 	addi	sp,sp,-20
   1f364:	dcc00315 	stw	r19,12(sp)
   1f368:	dc800215 	stw	r18,8(sp)
   1f36c:	dc000015 	stw	r16,0(sp)
   1f370:	dfc00415 	stw	ra,16(sp)
   1f374:	dc400115 	stw	r17,4(sp)
   1f378:	308000cc 	andi	r2,r6,3
   1f37c:	3021883a 	mov	r16,r6
   1f380:	2027883a 	mov	r19,r4
   1f384:	2825883a 	mov	r18,r5
   1f388:	10002e1e 	bne	r2,zero,1f444 <__pow5mult+0xe4>
   1f38c:	8021d0ba 	srai	r16,r16,2
   1f390:	80001a26 	beq	r16,zero,1f3fc <__pow5mult+0x9c>
   1f394:	9c401217 	ldw	r17,72(r19)
   1f398:	8800061e 	bne	r17,zero,1f3b4 <__pow5mult+0x54>
   1f39c:	00003406 	br	1f470 <__pow5mult+0x110>
   1f3a0:	8021d07a 	srai	r16,r16,1
   1f3a4:	80001526 	beq	r16,zero,1f3fc <__pow5mult+0x9c>
   1f3a8:	88c00017 	ldw	r3,0(r17)
   1f3ac:	18001b26 	beq	r3,zero,1f41c <__pow5mult+0xbc>
   1f3b0:	1823883a 	mov	r17,r3
   1f3b4:	80c0004c 	andi	r3,r16,1
   1f3b8:	183ff926 	beq	r3,zero,1f3a0 <__pow5mult+0x40>
   1f3bc:	900b883a 	mov	r5,r18
   1f3c0:	880d883a 	mov	r6,r17
   1f3c4:	9809883a 	mov	r4,r19
   1f3c8:	001f1800 	call	1f180 <__multiply>
   1f3cc:	90001b26 	beq	r18,zero,1f43c <__pow5mult+0xdc>
   1f3d0:	91000117 	ldw	r4,4(r18)
   1f3d4:	98c01317 	ldw	r3,76(r19)
   1f3d8:	8021d07a 	srai	r16,r16,1
   1f3dc:	2109883a 	add	r4,r4,r4
   1f3e0:	2109883a 	add	r4,r4,r4
   1f3e4:	1907883a 	add	r3,r3,r4
   1f3e8:	19000017 	ldw	r4,0(r3)
   1f3ec:	91000015 	stw	r4,0(r18)
   1f3f0:	1c800015 	stw	r18,0(r3)
   1f3f4:	1025883a 	mov	r18,r2
   1f3f8:	803feb1e 	bne	r16,zero,1f3a8 <__pow5mult+0x48>
   1f3fc:	9005883a 	mov	r2,r18
   1f400:	dfc00417 	ldw	ra,16(sp)
   1f404:	dcc00317 	ldw	r19,12(sp)
   1f408:	dc800217 	ldw	r18,8(sp)
   1f40c:	dc400117 	ldw	r17,4(sp)
   1f410:	dc000017 	ldw	r16,0(sp)
   1f414:	dec00504 	addi	sp,sp,20
   1f418:	f800283a 	ret
   1f41c:	880b883a 	mov	r5,r17
   1f420:	880d883a 	mov	r6,r17
   1f424:	9809883a 	mov	r4,r19
   1f428:	001f1800 	call	1f180 <__multiply>
   1f42c:	88800015 	stw	r2,0(r17)
   1f430:	10000015 	stw	zero,0(r2)
   1f434:	1023883a 	mov	r17,r2
   1f438:	003fde06 	br	1f3b4 <__pow5mult+0x54>
   1f43c:	1025883a 	mov	r18,r2
   1f440:	003fd706 	br	1f3a0 <__pow5mult+0x40>
   1f444:	10bfffc4 	addi	r2,r2,-1
   1f448:	1085883a 	add	r2,r2,r2
   1f44c:	00c000f4 	movhi	r3,3
   1f450:	18c54304 	addi	r3,r3,5388
   1f454:	1085883a 	add	r2,r2,r2
   1f458:	1885883a 	add	r2,r3,r2
   1f45c:	11800017 	ldw	r6,0(r2)
   1f460:	000f883a 	mov	r7,zero
   1f464:	001ee140 	call	1ee14 <__multadd>
   1f468:	1025883a 	mov	r18,r2
   1f46c:	003fc706 	br	1f38c <__pow5mult+0x2c>
   1f470:	9809883a 	mov	r4,r19
   1f474:	01409c44 	movi	r5,625
   1f478:	001f1440 	call	1f144 <__i2b>
   1f47c:	98801215 	stw	r2,72(r19)
   1f480:	1023883a 	mov	r17,r2
   1f484:	10000015 	stw	zero,0(r2)
   1f488:	003fca06 	br	1f3b4 <__pow5mult+0x54>

0001f48c <__lshift>:
   1f48c:	defff904 	addi	sp,sp,-28
   1f490:	dd400515 	stw	r21,20(sp)
   1f494:	dc400115 	stw	r17,4(sp)
   1f498:	2d400417 	ldw	r21,16(r5)
   1f49c:	3023d17a 	srai	r17,r6,5
   1f4a0:	28800217 	ldw	r2,8(r5)
   1f4a4:	dd000415 	stw	r20,16(sp)
   1f4a8:	8d6b883a 	add	r21,r17,r21
   1f4ac:	dcc00315 	stw	r19,12(sp)
   1f4b0:	dc800215 	stw	r18,8(sp)
   1f4b4:	dc000015 	stw	r16,0(sp)
   1f4b8:	dfc00615 	stw	ra,24(sp)
   1f4bc:	ac000044 	addi	r16,r21,1
   1f4c0:	2825883a 	mov	r18,r5
   1f4c4:	3029883a 	mov	r20,r6
   1f4c8:	2027883a 	mov	r19,r4
   1f4cc:	29400117 	ldw	r5,4(r5)
   1f4d0:	1400030e 	bge	r2,r16,1f4e0 <__lshift+0x54>
   1f4d4:	1085883a 	add	r2,r2,r2
   1f4d8:	29400044 	addi	r5,r5,1
   1f4dc:	143ffd16 	blt	r2,r16,1f4d4 <__lshift+0x48>
   1f4e0:	9809883a 	mov	r4,r19
   1f4e4:	001ed440 	call	1ed44 <_Balloc>
   1f4e8:	10c00504 	addi	r3,r2,20
   1f4ec:	0440090e 	bge	zero,r17,1f514 <__lshift+0x88>
   1f4f0:	000f883a 	mov	r7,zero
   1f4f4:	18000015 	stw	zero,0(r3)
   1f4f8:	39c00044 	addi	r7,r7,1
   1f4fc:	18c00104 	addi	r3,r3,4
   1f500:	3c7ffc1e 	bne	r7,r17,1f4f4 <__lshift+0x68>
   1f504:	38c00144 	addi	r3,r7,5
   1f508:	18c7883a 	add	r3,r3,r3
   1f50c:	18c7883a 	add	r3,r3,r3
   1f510:	10c7883a 	add	r3,r2,r3
   1f514:	92000417 	ldw	r8,16(r18)
   1f518:	a18007cc 	andi	r6,r20,31
   1f51c:	91c00504 	addi	r7,r18,20
   1f520:	42000144 	addi	r8,r8,5
   1f524:	4211883a 	add	r8,r8,r8
   1f528:	4211883a 	add	r8,r8,r8
   1f52c:	9211883a 	add	r8,r18,r8
   1f530:	30002226 	beq	r6,zero,1f5bc <__lshift+0x130>
   1f534:	02800804 	movi	r10,32
   1f538:	5195c83a 	sub	r10,r10,r6
   1f53c:	000b883a 	mov	r5,zero
   1f540:	3a400017 	ldw	r9,0(r7)
   1f544:	18c00104 	addi	r3,r3,4
   1f548:	39c00104 	addi	r7,r7,4
   1f54c:	4992983a 	sll	r9,r9,r6
   1f550:	2a4ab03a 	or	r5,r5,r9
   1f554:	197fff15 	stw	r5,-4(r3)
   1f558:	397fff17 	ldw	r5,-4(r7)
   1f55c:	2a8ad83a 	srl	r5,r5,r10
   1f560:	3a3ff736 	bltu	r7,r8,1f540 <__lshift+0xb4>
   1f564:	19400015 	stw	r5,0(r3)
   1f568:	28000126 	beq	r5,zero,1f570 <__lshift+0xe4>
   1f56c:	ac000084 	addi	r16,r21,2
   1f570:	91000117 	ldw	r4,4(r18)
   1f574:	98c01317 	ldw	r3,76(r19)
   1f578:	843fffc4 	addi	r16,r16,-1
   1f57c:	2109883a 	add	r4,r4,r4
   1f580:	2109883a 	add	r4,r4,r4
   1f584:	1907883a 	add	r3,r3,r4
   1f588:	19000017 	ldw	r4,0(r3)
   1f58c:	14000415 	stw	r16,16(r2)
   1f590:	91000015 	stw	r4,0(r18)
   1f594:	1c800015 	stw	r18,0(r3)
   1f598:	dfc00617 	ldw	ra,24(sp)
   1f59c:	dd400517 	ldw	r21,20(sp)
   1f5a0:	dd000417 	ldw	r20,16(sp)
   1f5a4:	dcc00317 	ldw	r19,12(sp)
   1f5a8:	dc800217 	ldw	r18,8(sp)
   1f5ac:	dc400117 	ldw	r17,4(sp)
   1f5b0:	dc000017 	ldw	r16,0(sp)
   1f5b4:	dec00704 	addi	sp,sp,28
   1f5b8:	f800283a 	ret
   1f5bc:	39400017 	ldw	r5,0(r7)
   1f5c0:	18c00104 	addi	r3,r3,4
   1f5c4:	39c00104 	addi	r7,r7,4
   1f5c8:	197fff15 	stw	r5,-4(r3)
   1f5cc:	3a3fe82e 	bgeu	r7,r8,1f570 <__lshift+0xe4>
   1f5d0:	39400017 	ldw	r5,0(r7)
   1f5d4:	18c00104 	addi	r3,r3,4
   1f5d8:	39c00104 	addi	r7,r7,4
   1f5dc:	197fff15 	stw	r5,-4(r3)
   1f5e0:	3a3ff636 	bltu	r7,r8,1f5bc <__lshift+0x130>
   1f5e4:	003fe206 	br	1f570 <__lshift+0xe4>

0001f5e8 <__mcmp>:
   1f5e8:	20800417 	ldw	r2,16(r4)
   1f5ec:	28c00417 	ldw	r3,16(r5)
   1f5f0:	10c5c83a 	sub	r2,r2,r3
   1f5f4:	10000f1e 	bne	r2,zero,1f634 <__mcmp+0x4c>
   1f5f8:	18c00144 	addi	r3,r3,5
   1f5fc:	18c7883a 	add	r3,r3,r3
   1f600:	18c7883a 	add	r3,r3,r3
   1f604:	21c00504 	addi	r7,r4,20
   1f608:	28cb883a 	add	r5,r5,r3
   1f60c:	20c9883a 	add	r4,r4,r3
   1f610:	213fff04 	addi	r4,r4,-4
   1f614:	297fff04 	addi	r5,r5,-4
   1f618:	21800017 	ldw	r6,0(r4)
   1f61c:	28c00017 	ldw	r3,0(r5)
   1f620:	30c0021e 	bne	r6,r3,1f62c <__mcmp+0x44>
   1f624:	393ffa36 	bltu	r7,r4,1f610 <__mcmp+0x28>
   1f628:	f800283a 	ret
   1f62c:	30c00236 	bltu	r6,r3,1f638 <__mcmp+0x50>
   1f630:	00800044 	movi	r2,1
   1f634:	f800283a 	ret
   1f638:	00bfffc4 	movi	r2,-1
   1f63c:	f800283a 	ret

0001f640 <__mdiff>:
   1f640:	defffb04 	addi	sp,sp,-20
   1f644:	dc000015 	stw	r16,0(sp)
   1f648:	2821883a 	mov	r16,r5
   1f64c:	dc800215 	stw	r18,8(sp)
   1f650:	300b883a 	mov	r5,r6
   1f654:	2025883a 	mov	r18,r4
   1f658:	8009883a 	mov	r4,r16
   1f65c:	dc400115 	stw	r17,4(sp)
   1f660:	dfc00415 	stw	ra,16(sp)
   1f664:	dcc00315 	stw	r19,12(sp)
   1f668:	3023883a 	mov	r17,r6
   1f66c:	001f5e80 	call	1f5e8 <__mcmp>
   1f670:	10005026 	beq	r2,zero,1f7b4 <__mdiff+0x174>
   1f674:	10004a16 	blt	r2,zero,1f7a0 <__mdiff+0x160>
   1f678:	0027883a 	mov	r19,zero
   1f67c:	81400117 	ldw	r5,4(r16)
   1f680:	9009883a 	mov	r4,r18
   1f684:	001ed440 	call	1ed44 <_Balloc>
   1f688:	82400417 	ldw	r9,16(r16)
   1f68c:	89800417 	ldw	r6,16(r17)
   1f690:	14c00315 	stw	r19,12(r2)
   1f694:	4b800144 	addi	r14,r9,5
   1f698:	31800144 	addi	r6,r6,5
   1f69c:	739d883a 	add	r14,r14,r14
   1f6a0:	318d883a 	add	r6,r6,r6
   1f6a4:	739d883a 	add	r14,r14,r14
   1f6a8:	318d883a 	add	r6,r6,r6
   1f6ac:	81c00504 	addi	r7,r16,20
   1f6b0:	839d883a 	add	r14,r16,r14
   1f6b4:	8a000504 	addi	r8,r17,20
   1f6b8:	898d883a 	add	r6,r17,r6
   1f6bc:	10c00504 	addi	r3,r2,20
   1f6c0:	0009883a 	mov	r4,zero
   1f6c4:	3b000017 	ldw	r12,0(r7)
   1f6c8:	42c00017 	ldw	r11,0(r8)
   1f6cc:	42000104 	addi	r8,r8,4
   1f6d0:	62bfffcc 	andi	r10,r12,65535
   1f6d4:	5b7fffcc 	andi	r13,r11,65535
   1f6d8:	5109883a 	add	r4,r10,r4
   1f6dc:	2355c83a 	sub	r10,r4,r13
   1f6e0:	5816d43a 	srli	r11,r11,16
   1f6e4:	6008d43a 	srli	r4,r12,16
   1f6e8:	501bd43a 	srai	r13,r10,16
   1f6ec:	1a80000d 	sth	r10,0(r3)
   1f6f0:	22c9c83a 	sub	r4,r4,r11
   1f6f4:	2349883a 	add	r4,r4,r13
   1f6f8:	1900008d 	sth	r4,2(r3)
   1f6fc:	39c00104 	addi	r7,r7,4
   1f700:	2009d43a 	srai	r4,r4,16
   1f704:	18c00104 	addi	r3,r3,4
   1f708:	41bfee36 	bltu	r8,r6,1f6c4 <__mdiff+0x84>
   1f70c:	180b883a 	mov	r5,r3
   1f710:	3815883a 	mov	r10,r7
   1f714:	3b80132e 	bgeu	r7,r14,1f764 <__mdiff+0x124>
   1f718:	3a000017 	ldw	r8,0(r7)
   1f71c:	18c00104 	addi	r3,r3,4
   1f720:	39c00104 	addi	r7,r7,4
   1f724:	41bfffcc 	andi	r6,r8,65535
   1f728:	310d883a 	add	r6,r6,r4
   1f72c:	3009d43a 	srai	r4,r6,16
   1f730:	4010d43a 	srli	r8,r8,16
   1f734:	19bfff0d 	sth	r6,-4(r3)
   1f738:	2209883a 	add	r4,r4,r8
   1f73c:	193fff8d 	sth	r4,-2(r3)
   1f740:	2009d43a 	srai	r4,r4,16
   1f744:	3bbff436 	bltu	r7,r14,1f718 <__mdiff+0xd8>
   1f748:	0286303a 	nor	r3,zero,r10
   1f74c:	1b87883a 	add	r3,r3,r14
   1f750:	1806d0ba 	srli	r3,r3,2
   1f754:	18c00044 	addi	r3,r3,1
   1f758:	18c7883a 	add	r3,r3,r3
   1f75c:	18c7883a 	add	r3,r3,r3
   1f760:	28c7883a 	add	r3,r5,r3
   1f764:	193fff17 	ldw	r4,-4(r3)
   1f768:	18ffff04 	addi	r3,r3,-4
   1f76c:	2000041e 	bne	r4,zero,1f780 <__mdiff+0x140>
   1f770:	18ffff04 	addi	r3,r3,-4
   1f774:	19000017 	ldw	r4,0(r3)
   1f778:	4a7fffc4 	addi	r9,r9,-1
   1f77c:	203ffc26 	beq	r4,zero,1f770 <__mdiff+0x130>
   1f780:	12400415 	stw	r9,16(r2)
   1f784:	dfc00417 	ldw	ra,16(sp)
   1f788:	dcc00317 	ldw	r19,12(sp)
   1f78c:	dc800217 	ldw	r18,8(sp)
   1f790:	dc400117 	ldw	r17,4(sp)
   1f794:	dc000017 	ldw	r16,0(sp)
   1f798:	dec00504 	addi	sp,sp,20
   1f79c:	f800283a 	ret
   1f7a0:	8005883a 	mov	r2,r16
   1f7a4:	04c00044 	movi	r19,1
   1f7a8:	8821883a 	mov	r16,r17
   1f7ac:	1023883a 	mov	r17,r2
   1f7b0:	003fb206 	br	1f67c <__mdiff+0x3c>
   1f7b4:	9009883a 	mov	r4,r18
   1f7b8:	000b883a 	mov	r5,zero
   1f7bc:	001ed440 	call	1ed44 <_Balloc>
   1f7c0:	00c00044 	movi	r3,1
   1f7c4:	10c00415 	stw	r3,16(r2)
   1f7c8:	10000515 	stw	zero,20(r2)
   1f7cc:	dfc00417 	ldw	ra,16(sp)
   1f7d0:	dcc00317 	ldw	r19,12(sp)
   1f7d4:	dc800217 	ldw	r18,8(sp)
   1f7d8:	dc400117 	ldw	r17,4(sp)
   1f7dc:	dc000017 	ldw	r16,0(sp)
   1f7e0:	dec00504 	addi	sp,sp,20
   1f7e4:	f800283a 	ret

0001f7e8 <__ulp>:
   1f7e8:	295ffc2c 	andhi	r5,r5,32752
   1f7ec:	00bf3034 	movhi	r2,64704
   1f7f0:	2887883a 	add	r3,r5,r2
   1f7f4:	00c0020e 	bge	zero,r3,1f800 <__ulp+0x18>
   1f7f8:	0005883a 	mov	r2,zero
   1f7fc:	f800283a 	ret
   1f800:	00c7c83a 	sub	r3,zero,r3
   1f804:	1805d53a 	srai	r2,r3,20
   1f808:	00c004c4 	movi	r3,19
   1f80c:	18800a0e 	bge	r3,r2,1f838 <__ulp+0x50>
   1f810:	01000c84 	movi	r4,50
   1f814:	0007883a 	mov	r3,zero
   1f818:	20800516 	blt	r4,r2,1f830 <__ulp+0x48>
   1f81c:	01000cc4 	movi	r4,51
   1f820:	2085c83a 	sub	r2,r4,r2
   1f824:	01000044 	movi	r4,1
   1f828:	2084983a 	sll	r2,r4,r2
   1f82c:	f800283a 	ret
   1f830:	00800044 	movi	r2,1
   1f834:	f800283a 	ret
   1f838:	00c00234 	movhi	r3,8
   1f83c:	1887d83a 	sra	r3,r3,r2
   1f840:	0005883a 	mov	r2,zero
   1f844:	f800283a 	ret

0001f848 <__b2d>:
   1f848:	defffa04 	addi	sp,sp,-24
   1f84c:	dc000015 	stw	r16,0(sp)
   1f850:	24000417 	ldw	r16,16(r4)
   1f854:	dc400115 	stw	r17,4(sp)
   1f858:	dcc00315 	stw	r19,12(sp)
   1f85c:	84000144 	addi	r16,r16,5
   1f860:	8421883a 	add	r16,r16,r16
   1f864:	8421883a 	add	r16,r16,r16
   1f868:	2421883a 	add	r16,r4,r16
   1f86c:	847fff17 	ldw	r17,-4(r16)
   1f870:	24c00504 	addi	r19,r4,20
   1f874:	dd000415 	stw	r20,16(sp)
   1f878:	8809883a 	mov	r4,r17
   1f87c:	dc800215 	stw	r18,8(sp)
   1f880:	2829883a 	mov	r20,r5
   1f884:	dfc00515 	stw	ra,20(sp)
   1f888:	001f02c0 	call	1f02c <__hi0bits>
   1f88c:	00c00804 	movi	r3,32
   1f890:	1887c83a 	sub	r3,r3,r2
   1f894:	a0c00015 	stw	r3,0(r20)
   1f898:	00c00284 	movi	r3,10
   1f89c:	84bfff04 	addi	r18,r16,-4
   1f8a0:	18801216 	blt	r3,r2,1f8ec <__b2d+0xa4>
   1f8a4:	010002c4 	movi	r4,11
   1f8a8:	2089c83a 	sub	r4,r4,r2
   1f8ac:	8906d83a 	srl	r3,r17,r4
   1f8b0:	18cffc34 	orhi	r3,r3,16368
   1f8b4:	9c80322e 	bgeu	r19,r18,1f980 <__b2d+0x138>
   1f8b8:	817ffe17 	ldw	r5,-8(r16)
   1f8bc:	2908d83a 	srl	r4,r5,r4
   1f8c0:	10800544 	addi	r2,r2,21
   1f8c4:	88a2983a 	sll	r17,r17,r2
   1f8c8:	2444b03a 	or	r2,r4,r17
   1f8cc:	dfc00517 	ldw	ra,20(sp)
   1f8d0:	dd000417 	ldw	r20,16(sp)
   1f8d4:	dcc00317 	ldw	r19,12(sp)
   1f8d8:	dc800217 	ldw	r18,8(sp)
   1f8dc:	dc400117 	ldw	r17,4(sp)
   1f8e0:	dc000017 	ldw	r16,0(sp)
   1f8e4:	dec00604 	addi	sp,sp,24
   1f8e8:	f800283a 	ret
   1f8ec:	9c801636 	bltu	r19,r18,1f948 <__b2d+0x100>
   1f8f0:	113ffd44 	addi	r4,r2,-11
   1f8f4:	000b883a 	mov	r5,zero
   1f8f8:	20001726 	beq	r4,zero,1f958 <__b2d+0x110>
   1f8fc:	00c00ac4 	movi	r3,43
   1f900:	1885c83a 	sub	r2,r3,r2
   1f904:	8906983a 	sll	r3,r17,r4
   1f908:	288cd83a 	srl	r6,r5,r2
   1f90c:	18cffc34 	orhi	r3,r3,16368
   1f910:	1986b03a 	or	r3,r3,r6
   1f914:	9c801c2e 	bgeu	r19,r18,1f988 <__b2d+0x140>
   1f918:	91bfff17 	ldw	r6,-4(r18)
   1f91c:	3084d83a 	srl	r2,r6,r2
   1f920:	2908983a 	sll	r4,r5,r4
   1f924:	1104b03a 	or	r2,r2,r4
   1f928:	dfc00517 	ldw	ra,20(sp)
   1f92c:	dd000417 	ldw	r20,16(sp)
   1f930:	dcc00317 	ldw	r19,12(sp)
   1f934:	dc800217 	ldw	r18,8(sp)
   1f938:	dc400117 	ldw	r17,4(sp)
   1f93c:	dc000017 	ldw	r16,0(sp)
   1f940:	dec00604 	addi	sp,sp,24
   1f944:	f800283a 	ret
   1f948:	113ffd44 	addi	r4,r2,-11
   1f94c:	84bffe04 	addi	r18,r16,-8
   1f950:	817ffe17 	ldw	r5,-8(r16)
   1f954:	203fe91e 	bne	r4,zero,1f8fc <__b2d+0xb4>
   1f958:	88cffc34 	orhi	r3,r17,16368
   1f95c:	2805883a 	mov	r2,r5
   1f960:	dfc00517 	ldw	ra,20(sp)
   1f964:	dd000417 	ldw	r20,16(sp)
   1f968:	dcc00317 	ldw	r19,12(sp)
   1f96c:	dc800217 	ldw	r18,8(sp)
   1f970:	dc400117 	ldw	r17,4(sp)
   1f974:	dc000017 	ldw	r16,0(sp)
   1f978:	dec00604 	addi	sp,sp,24
   1f97c:	f800283a 	ret
   1f980:	0009883a 	mov	r4,zero
   1f984:	003fce06 	br	1f8c0 <__b2d+0x78>
   1f988:	0005883a 	mov	r2,zero
   1f98c:	003fe406 	br	1f920 <__b2d+0xd8>

0001f990 <__d2b>:
   1f990:	defff804 	addi	sp,sp,-32
   1f994:	dc400315 	stw	r17,12(sp)
   1f998:	3023883a 	mov	r17,r6
   1f99c:	dc800415 	stw	r18,16(sp)
   1f9a0:	8824907a 	slli	r18,r17,1
   1f9a4:	dcc00515 	stw	r19,20(sp)
   1f9a8:	2827883a 	mov	r19,r5
   1f9ac:	9024d57a 	srli	r18,r18,21
   1f9b0:	01400044 	movi	r5,1
   1f9b4:	dd000615 	stw	r20,24(sp)
   1f9b8:	dc000215 	stw	r16,8(sp)
   1f9bc:	dfc00715 	stw	ra,28(sp)
   1f9c0:	3829883a 	mov	r20,r7
   1f9c4:	001ed440 	call	1ed44 <_Balloc>
   1f9c8:	1021883a 	mov	r16,r2
   1f9cc:	00800434 	movhi	r2,16
   1f9d0:	10bfffc4 	addi	r2,r2,-1
   1f9d4:	88a2703a 	and	r17,r17,r2
   1f9d8:	90000126 	beq	r18,zero,1f9e0 <__d2b+0x50>
   1f9dc:	8c400434 	orhi	r17,r17,16
   1f9e0:	dc400015 	stw	r17,0(sp)
   1f9e4:	98002226 	beq	r19,zero,1fa70 <__d2b+0xe0>
   1f9e8:	d9000104 	addi	r4,sp,4
   1f9ec:	dcc00115 	stw	r19,4(sp)
   1f9f0:	001f0940 	call	1f094 <__lo0bits>
   1f9f4:	d8c00017 	ldw	r3,0(sp)
   1f9f8:	10002d1e 	bne	r2,zero,1fab0 <__d2b+0x120>
   1f9fc:	d9000117 	ldw	r4,4(sp)
   1fa00:	81000515 	stw	r4,20(r16)
   1fa04:	1823003a 	cmpeq	r17,r3,zero
   1fa08:	01000084 	movi	r4,2
   1fa0c:	2463c83a 	sub	r17,r4,r17
   1fa10:	80c00615 	stw	r3,24(r16)
   1fa14:	84400415 	stw	r17,16(r16)
   1fa18:	90001d1e 	bne	r18,zero,1fa90 <__d2b+0x100>
   1fa1c:	88c00104 	addi	r3,r17,4
   1fa20:	18c7883a 	add	r3,r3,r3
   1fa24:	18c7883a 	add	r3,r3,r3
   1fa28:	80c7883a 	add	r3,r16,r3
   1fa2c:	19000017 	ldw	r4,0(r3)
   1fa30:	10bef384 	addi	r2,r2,-1074
   1fa34:	a0800015 	stw	r2,0(r20)
   1fa38:	001f02c0 	call	1f02c <__hi0bits>
   1fa3c:	8822917a 	slli	r17,r17,5
   1fa40:	d8c00817 	ldw	r3,32(sp)
   1fa44:	8885c83a 	sub	r2,r17,r2
   1fa48:	18800015 	stw	r2,0(r3)
   1fa4c:	8005883a 	mov	r2,r16
   1fa50:	dfc00717 	ldw	ra,28(sp)
   1fa54:	dd000617 	ldw	r20,24(sp)
   1fa58:	dcc00517 	ldw	r19,20(sp)
   1fa5c:	dc800417 	ldw	r18,16(sp)
   1fa60:	dc400317 	ldw	r17,12(sp)
   1fa64:	dc000217 	ldw	r16,8(sp)
   1fa68:	dec00804 	addi	sp,sp,32
   1fa6c:	f800283a 	ret
   1fa70:	d809883a 	mov	r4,sp
   1fa74:	001f0940 	call	1f094 <__lo0bits>
   1fa78:	d8c00017 	ldw	r3,0(sp)
   1fa7c:	04400044 	movi	r17,1
   1fa80:	84400415 	stw	r17,16(r16)
   1fa84:	80c00515 	stw	r3,20(r16)
   1fa88:	10800804 	addi	r2,r2,32
   1fa8c:	903fe326 	beq	r18,zero,1fa1c <__d2b+0x8c>
   1fa90:	00c00d44 	movi	r3,53
   1fa94:	94bef344 	addi	r18,r18,-1075
   1fa98:	90a5883a 	add	r18,r18,r2
   1fa9c:	1885c83a 	sub	r2,r3,r2
   1faa0:	d8c00817 	ldw	r3,32(sp)
   1faa4:	a4800015 	stw	r18,0(r20)
   1faa8:	18800015 	stw	r2,0(r3)
   1faac:	003fe706 	br	1fa4c <__d2b+0xbc>
   1fab0:	01000804 	movi	r4,32
   1fab4:	2089c83a 	sub	r4,r4,r2
   1fab8:	1908983a 	sll	r4,r3,r4
   1fabc:	d9400117 	ldw	r5,4(sp)
   1fac0:	1886d83a 	srl	r3,r3,r2
   1fac4:	2148b03a 	or	r4,r4,r5
   1fac8:	81000515 	stw	r4,20(r16)
   1facc:	d8c00015 	stw	r3,0(sp)
   1fad0:	003fcc06 	br	1fa04 <__d2b+0x74>

0001fad4 <__ratio>:
   1fad4:	defff904 	addi	sp,sp,-28
   1fad8:	dc400315 	stw	r17,12(sp)
   1fadc:	2823883a 	mov	r17,r5
   1fae0:	d9400104 	addi	r5,sp,4
   1fae4:	dfc00615 	stw	ra,24(sp)
   1fae8:	dcc00515 	stw	r19,20(sp)
   1faec:	dc800415 	stw	r18,16(sp)
   1faf0:	2027883a 	mov	r19,r4
   1faf4:	dc000215 	stw	r16,8(sp)
   1faf8:	001f8480 	call	1f848 <__b2d>
   1fafc:	8809883a 	mov	r4,r17
   1fb00:	d80b883a 	mov	r5,sp
   1fb04:	1025883a 	mov	r18,r2
   1fb08:	1821883a 	mov	r16,r3
   1fb0c:	001f8480 	call	1f848 <__b2d>
   1fb10:	99400417 	ldw	r5,16(r19)
   1fb14:	89000417 	ldw	r4,16(r17)
   1fb18:	d9800117 	ldw	r6,4(sp)
   1fb1c:	2909c83a 	sub	r4,r5,r4
   1fb20:	d9400017 	ldw	r5,0(sp)
   1fb24:	2008917a 	slli	r4,r4,5
   1fb28:	314bc83a 	sub	r5,r6,r5
   1fb2c:	290b883a 	add	r5,r5,r4
   1fb30:	01400e0e 	bge	zero,r5,1fb6c <__ratio+0x98>
   1fb34:	280a953a 	slli	r5,r5,20
   1fb38:	2c21883a 	add	r16,r5,r16
   1fb3c:	9009883a 	mov	r4,r18
   1fb40:	800b883a 	mov	r5,r16
   1fb44:	100d883a 	mov	r6,r2
   1fb48:	180f883a 	mov	r7,r3
   1fb4c:	00187e00 	call	187e0 <__divdf3>
   1fb50:	dfc00617 	ldw	ra,24(sp)
   1fb54:	dcc00517 	ldw	r19,20(sp)
   1fb58:	dc800417 	ldw	r18,16(sp)
   1fb5c:	dc400317 	ldw	r17,12(sp)
   1fb60:	dc000217 	ldw	r16,8(sp)
   1fb64:	dec00704 	addi	sp,sp,28
   1fb68:	f800283a 	ret
   1fb6c:	280a953a 	slli	r5,r5,20
   1fb70:	1947c83a 	sub	r3,r3,r5
   1fb74:	003ff106 	br	1fb3c <__ratio+0x68>

0001fb78 <_mprec_log10>:
   1fb78:	defffe04 	addi	sp,sp,-8
   1fb7c:	dc000015 	stw	r16,0(sp)
   1fb80:	dfc00115 	stw	ra,4(sp)
   1fb84:	008005c4 	movi	r2,23
   1fb88:	2021883a 	mov	r16,r4
   1fb8c:	11000d0e 	bge	r2,r4,1fbc4 <_mprec_log10+0x4c>
   1fb90:	0005883a 	mov	r2,zero
   1fb94:	00cffc34 	movhi	r3,16368
   1fb98:	843fffc4 	addi	r16,r16,-1
   1fb9c:	1009883a 	mov	r4,r2
   1fba0:	180b883a 	mov	r5,r3
   1fba4:	000d883a 	mov	r6,zero
   1fba8:	01d00934 	movhi	r7,16420
   1fbac:	00184fc0 	call	184fc <__muldf3>
   1fbb0:	803ff91e 	bne	r16,zero,1fb98 <_mprec_log10+0x20>
   1fbb4:	dfc00117 	ldw	ra,4(sp)
   1fbb8:	dc000017 	ldw	r16,0(sp)
   1fbbc:	dec00204 	addi	sp,sp,8
   1fbc0:	f800283a 	ret
   1fbc4:	202090fa 	slli	r16,r4,3
   1fbc8:	008000f4 	movhi	r2,3
   1fbcc:	10851104 	addi	r2,r2,5188
   1fbd0:	1421883a 	add	r16,r2,r16
   1fbd4:	80800017 	ldw	r2,0(r16)
   1fbd8:	80c00117 	ldw	r3,4(r16)
   1fbdc:	dfc00117 	ldw	ra,4(sp)
   1fbe0:	dc000017 	ldw	r16,0(sp)
   1fbe4:	dec00204 	addi	sp,sp,8
   1fbe8:	f800283a 	ret

0001fbec <__copybits>:
   1fbec:	297fffc4 	addi	r5,r5,-1
   1fbf0:	31c00417 	ldw	r7,16(r6)
   1fbf4:	2811d17a 	srai	r8,r5,5
   1fbf8:	30800504 	addi	r2,r6,20
   1fbfc:	39c00144 	addi	r7,r7,5
   1fc00:	42000044 	addi	r8,r8,1
   1fc04:	39cf883a 	add	r7,r7,r7
   1fc08:	4211883a 	add	r8,r8,r8
   1fc0c:	39cf883a 	add	r7,r7,r7
   1fc10:	4211883a 	add	r8,r8,r8
   1fc14:	31cf883a 	add	r7,r6,r7
   1fc18:	2211883a 	add	r8,r4,r8
   1fc1c:	11c00d2e 	bgeu	r2,r7,1fc54 <__copybits+0x68>
   1fc20:	2007883a 	mov	r3,r4
   1fc24:	11400017 	ldw	r5,0(r2)
   1fc28:	18c00104 	addi	r3,r3,4
   1fc2c:	10800104 	addi	r2,r2,4
   1fc30:	197fff15 	stw	r5,-4(r3)
   1fc34:	11fffb36 	bltu	r2,r7,1fc24 <__copybits+0x38>
   1fc38:	3985c83a 	sub	r2,r7,r6
   1fc3c:	10bffac4 	addi	r2,r2,-21
   1fc40:	1004d0ba 	srli	r2,r2,2
   1fc44:	10800044 	addi	r2,r2,1
   1fc48:	1085883a 	add	r2,r2,r2
   1fc4c:	1085883a 	add	r2,r2,r2
   1fc50:	2089883a 	add	r4,r4,r2
   1fc54:	2200032e 	bgeu	r4,r8,1fc64 <__copybits+0x78>
   1fc58:	20000015 	stw	zero,0(r4)
   1fc5c:	21000104 	addi	r4,r4,4
   1fc60:	223ffd36 	bltu	r4,r8,1fc58 <__copybits+0x6c>
   1fc64:	f800283a 	ret

0001fc68 <__any_on>:
   1fc68:	21800417 	ldw	r6,16(r4)
   1fc6c:	2805d17a 	srai	r2,r5,5
   1fc70:	20c00504 	addi	r3,r4,20
   1fc74:	30800f0e 	bge	r6,r2,1fcb4 <__any_on+0x4c>
   1fc78:	3005883a 	mov	r2,r6
   1fc7c:	10800144 	addi	r2,r2,5
   1fc80:	1085883a 	add	r2,r2,r2
   1fc84:	1085883a 	add	r2,r2,r2
   1fc88:	2089883a 	add	r4,r4,r2
   1fc8c:	1900152e 	bgeu	r3,r4,1fce4 <__any_on+0x7c>
   1fc90:	20bfff17 	ldw	r2,-4(r4)
   1fc94:	213fff04 	addi	r4,r4,-4
   1fc98:	1000041e 	bne	r2,zero,1fcac <__any_on+0x44>
   1fc9c:	1900112e 	bgeu	r3,r4,1fce4 <__any_on+0x7c>
   1fca0:	213fff04 	addi	r4,r4,-4
   1fca4:	20800017 	ldw	r2,0(r4)
   1fca8:	103ffc26 	beq	r2,zero,1fc9c <__any_on+0x34>
   1fcac:	00800044 	movi	r2,1
   1fcb0:	f800283a 	ret
   1fcb4:	11bff10e 	bge	r2,r6,1fc7c <__any_on+0x14>
   1fcb8:	294007cc 	andi	r5,r5,31
   1fcbc:	283fef26 	beq	r5,zero,1fc7c <__any_on+0x14>
   1fcc0:	11800144 	addi	r6,r2,5
   1fcc4:	318d883a 	add	r6,r6,r6
   1fcc8:	318d883a 	add	r6,r6,r6
   1fccc:	218d883a 	add	r6,r4,r6
   1fcd0:	31800017 	ldw	r6,0(r6)
   1fcd4:	314ed83a 	srl	r7,r6,r5
   1fcd8:	394a983a 	sll	r5,r7,r5
   1fcdc:	29bff31e 	bne	r5,r6,1fcac <__any_on+0x44>
   1fce0:	003fe606 	br	1fc7c <__any_on+0x14>
   1fce4:	0005883a 	mov	r2,zero
   1fce8:	f800283a 	ret

0001fcec <_realloc_r>:
   1fcec:	defff504 	addi	sp,sp,-44
   1fcf0:	dd400615 	stw	r21,24(sp)
   1fcf4:	dc800315 	stw	r18,12(sp)
   1fcf8:	dc000115 	stw	r16,4(sp)
   1fcfc:	dfc00a15 	stw	ra,40(sp)
   1fd00:	df000915 	stw	fp,36(sp)
   1fd04:	ddc00815 	stw	r23,32(sp)
   1fd08:	dd800715 	stw	r22,28(sp)
   1fd0c:	dd000515 	stw	r20,20(sp)
   1fd10:	dcc00415 	stw	r19,16(sp)
   1fd14:	dc400215 	stw	r17,8(sp)
   1fd18:	2821883a 	mov	r16,r5
   1fd1c:	202b883a 	mov	r21,r4
   1fd20:	3025883a 	mov	r18,r6
   1fd24:	28009626 	beq	r5,zero,1ff80 <_realloc_r+0x294>
   1fd28:	0021f600 	call	21f60 <__malloc_lock>
   1fd2c:	80bfff17 	ldw	r2,-4(r16)
   1fd30:	04ffff04 	movi	r19,-4
   1fd34:	90c002c4 	addi	r3,r18,11
   1fd38:	01000584 	movi	r4,22
   1fd3c:	85bffe04 	addi	r22,r16,-8
   1fd40:	14e6703a 	and	r19,r2,r19
   1fd44:	20c0372e 	bgeu	r4,r3,1fe24 <_realloc_r+0x138>
   1fd48:	047ffe04 	movi	r17,-8
   1fd4c:	1c62703a 	and	r17,r3,r17
   1fd50:	8807883a 	mov	r3,r17
   1fd54:	88005a16 	blt	r17,zero,1fec0 <_realloc_r+0x1d4>
   1fd58:	8c805936 	bltu	r17,r18,1fec0 <_realloc_r+0x1d4>
   1fd5c:	98c0340e 	bge	r19,r3,1fe30 <_realloc_r+0x144>
   1fd60:	070000f4 	movhi	fp,3
   1fd64:	e70e9e04 	addi	fp,fp,14968
   1fd68:	e1400217 	ldw	r5,8(fp)
   1fd6c:	b4c9883a 	add	r4,r22,r19
   1fd70:	29009026 	beq	r5,r4,1ffb4 <_realloc_r+0x2c8>
   1fd74:	21800117 	ldw	r6,4(r4)
   1fd78:	01ffff84 	movi	r7,-2
   1fd7c:	31ce703a 	and	r7,r6,r7
   1fd80:	21cf883a 	add	r7,r4,r7
   1fd84:	39c00117 	ldw	r7,4(r7)
   1fd88:	39c0004c 	andi	r7,r7,1
   1fd8c:	38004326 	beq	r7,zero,1fe9c <_realloc_r+0x1b0>
   1fd90:	000d883a 	mov	r6,zero
   1fd94:	0009883a 	mov	r4,zero
   1fd98:	1080004c 	andi	r2,r2,1
   1fd9c:	10005a1e 	bne	r2,zero,1ff08 <_realloc_r+0x21c>
   1fda0:	85fffe17 	ldw	r23,-8(r16)
   1fda4:	00bfff04 	movi	r2,-4
   1fda8:	b5efc83a 	sub	r23,r22,r23
   1fdac:	b9c00117 	ldw	r7,4(r23)
   1fdb0:	388e703a 	and	r7,r7,r2
   1fdb4:	3ccf883a 	add	r7,r7,r19
   1fdb8:	20005226 	beq	r4,zero,1ff04 <_realloc_r+0x218>
   1fdbc:	31e9883a 	add	r20,r6,r7
   1fdc0:	2140c726 	beq	r4,r5,200e0 <_realloc_r+0x3f4>
   1fdc4:	a0c04f16 	blt	r20,r3,1ff04 <_realloc_r+0x218>
   1fdc8:	20800317 	ldw	r2,12(r4)
   1fdcc:	20c00217 	ldw	r3,8(r4)
   1fdd0:	99bfff04 	addi	r6,r19,-4
   1fdd4:	01000904 	movi	r4,36
   1fdd8:	18800315 	stw	r2,12(r3)
   1fddc:	10c00215 	stw	r3,8(r2)
   1fde0:	b8c00217 	ldw	r3,8(r23)
   1fde4:	b8800317 	ldw	r2,12(r23)
   1fde8:	bc800204 	addi	r18,r23,8
   1fdec:	18800315 	stw	r2,12(r3)
   1fdf0:	10c00215 	stw	r3,8(r2)
   1fdf4:	2180ed36 	bltu	r4,r6,201ac <_realloc_r+0x4c0>
   1fdf8:	008004c4 	movi	r2,19
   1fdfc:	11809b2e 	bgeu	r2,r6,2006c <_realloc_r+0x380>
   1fe00:	80800017 	ldw	r2,0(r16)
   1fe04:	b8800215 	stw	r2,8(r23)
   1fe08:	80800117 	ldw	r2,4(r16)
   1fe0c:	b8800315 	stw	r2,12(r23)
   1fe10:	008006c4 	movi	r2,27
   1fe14:	1180f936 	bltu	r2,r6,201fc <_realloc_r+0x510>
   1fe18:	b8800404 	addi	r2,r23,16
   1fe1c:	80c00204 	addi	r3,r16,8
   1fe20:	00009406 	br	20074 <_realloc_r+0x388>
   1fe24:	00c00404 	movi	r3,16
   1fe28:	1823883a 	mov	r17,r3
   1fe2c:	003fca06 	br	1fd58 <_realloc_r+0x6c>
   1fe30:	9829883a 	mov	r20,r19
   1fe34:	a447c83a 	sub	r3,r20,r17
   1fe38:	010003c4 	movi	r4,15
   1fe3c:	1080004c 	andi	r2,r2,1
   1fe40:	20c02336 	bltu	r4,r3,1fed0 <_realloc_r+0x1e4>
   1fe44:	1504b03a 	or	r2,r2,r20
   1fe48:	b0800115 	stw	r2,4(r22)
   1fe4c:	b52d883a 	add	r22,r22,r20
   1fe50:	b0800117 	ldw	r2,4(r22)
   1fe54:	10800054 	ori	r2,r2,1
   1fe58:	b0800115 	stw	r2,4(r22)
   1fe5c:	a809883a 	mov	r4,r21
   1fe60:	0021f800 	call	21f80 <__malloc_unlock>
   1fe64:	8025883a 	mov	r18,r16
   1fe68:	9005883a 	mov	r2,r18
   1fe6c:	dfc00a17 	ldw	ra,40(sp)
   1fe70:	df000917 	ldw	fp,36(sp)
   1fe74:	ddc00817 	ldw	r23,32(sp)
   1fe78:	dd800717 	ldw	r22,28(sp)
   1fe7c:	dd400617 	ldw	r21,24(sp)
   1fe80:	dd000517 	ldw	r20,20(sp)
   1fe84:	dcc00417 	ldw	r19,16(sp)
   1fe88:	dc800317 	ldw	r18,12(sp)
   1fe8c:	dc400217 	ldw	r17,8(sp)
   1fe90:	dc000117 	ldw	r16,4(sp)
   1fe94:	dec00b04 	addi	sp,sp,44
   1fe98:	f800283a 	ret
   1fe9c:	01ffff04 	movi	r7,-4
   1fea0:	31cc703a 	and	r6,r6,r7
   1fea4:	34e9883a 	add	r20,r6,r19
   1fea8:	a0ffbb16 	blt	r20,r3,1fd98 <_realloc_r+0xac>
   1feac:	20c00317 	ldw	r3,12(r4)
   1feb0:	21000217 	ldw	r4,8(r4)
   1feb4:	20c00315 	stw	r3,12(r4)
   1feb8:	19000215 	stw	r4,8(r3)
   1febc:	003fdd06 	br	1fe34 <_realloc_r+0x148>
   1fec0:	00800304 	movi	r2,12
   1fec4:	a8800015 	stw	r2,0(r21)
   1fec8:	0025883a 	mov	r18,zero
   1fecc:	003fe606 	br	1fe68 <_realloc_r+0x17c>
   1fed0:	1444b03a 	or	r2,r2,r17
   1fed4:	b0800115 	stw	r2,4(r22)
   1fed8:	b44b883a 	add	r5,r22,r17
   1fedc:	18800054 	ori	r2,r3,1
   1fee0:	28800115 	stw	r2,4(r5)
   1fee4:	28c7883a 	add	r3,r5,r3
   1fee8:	18800117 	ldw	r2,4(r3)
   1feec:	a809883a 	mov	r4,r21
   1fef0:	29400204 	addi	r5,r5,8
   1fef4:	10800054 	ori	r2,r2,1
   1fef8:	18800115 	stw	r2,4(r3)
   1fefc:	001d8080 	call	1d808 <_free_r>
   1ff00:	003fd606 	br	1fe5c <_realloc_r+0x170>
   1ff04:	38c0330e 	bge	r7,r3,1ffd4 <_realloc_r+0x2e8>
   1ff08:	900b883a 	mov	r5,r18
   1ff0c:	a809883a 	mov	r4,r21
   1ff10:	001e3a00 	call	1e3a0 <_malloc_r>
   1ff14:	1025883a 	mov	r18,r2
   1ff18:	10001626 	beq	r2,zero,1ff74 <_realloc_r+0x288>
   1ff1c:	80bfff17 	ldw	r2,-4(r16)
   1ff20:	00ffff84 	movi	r3,-2
   1ff24:	913ffe04 	addi	r4,r18,-8
   1ff28:	10c6703a 	and	r3,r2,r3
   1ff2c:	b0c7883a 	add	r3,r22,r3
   1ff30:	20c09926 	beq	r4,r3,20198 <_realloc_r+0x4ac>
   1ff34:	99bfff04 	addi	r6,r19,-4
   1ff38:	00800904 	movi	r2,36
   1ff3c:	11806436 	bltu	r2,r6,200d0 <_realloc_r+0x3e4>
   1ff40:	00c004c4 	movi	r3,19
   1ff44:	19804036 	bltu	r3,r6,20048 <_realloc_r+0x35c>
   1ff48:	9005883a 	mov	r2,r18
   1ff4c:	8007883a 	mov	r3,r16
   1ff50:	19000017 	ldw	r4,0(r3)
   1ff54:	11000015 	stw	r4,0(r2)
   1ff58:	19000117 	ldw	r4,4(r3)
   1ff5c:	11000115 	stw	r4,4(r2)
   1ff60:	18c00217 	ldw	r3,8(r3)
   1ff64:	10c00215 	stw	r3,8(r2)
   1ff68:	a809883a 	mov	r4,r21
   1ff6c:	800b883a 	mov	r5,r16
   1ff70:	001d8080 	call	1d808 <_free_r>
   1ff74:	a809883a 	mov	r4,r21
   1ff78:	0021f800 	call	21f80 <__malloc_unlock>
   1ff7c:	003fba06 	br	1fe68 <_realloc_r+0x17c>
   1ff80:	300b883a 	mov	r5,r6
   1ff84:	dfc00a17 	ldw	ra,40(sp)
   1ff88:	df000917 	ldw	fp,36(sp)
   1ff8c:	ddc00817 	ldw	r23,32(sp)
   1ff90:	dd800717 	ldw	r22,28(sp)
   1ff94:	dd400617 	ldw	r21,24(sp)
   1ff98:	dd000517 	ldw	r20,20(sp)
   1ff9c:	dcc00417 	ldw	r19,16(sp)
   1ffa0:	dc800317 	ldw	r18,12(sp)
   1ffa4:	dc400217 	ldw	r17,8(sp)
   1ffa8:	dc000117 	ldw	r16,4(sp)
   1ffac:	dec00b04 	addi	sp,sp,44
   1ffb0:	001e3a01 	jmpi	1e3a0 <_malloc_r>
   1ffb4:	29800117 	ldw	r6,4(r5)
   1ffb8:	013fff04 	movi	r4,-4
   1ffbc:	89c00404 	addi	r7,r17,16
   1ffc0:	310c703a 	and	r6,r6,r4
   1ffc4:	34c9883a 	add	r4,r6,r19
   1ffc8:	21c0340e 	bge	r4,r7,2009c <_realloc_r+0x3b0>
   1ffcc:	2809883a 	mov	r4,r5
   1ffd0:	003f7106 	br	1fd98 <_realloc_r+0xac>
   1ffd4:	b8800317 	ldw	r2,12(r23)
   1ffd8:	b8c00217 	ldw	r3,8(r23)
   1ffdc:	99bfff04 	addi	r6,r19,-4
   1ffe0:	01000904 	movi	r4,36
   1ffe4:	18800315 	stw	r2,12(r3)
   1ffe8:	10c00215 	stw	r3,8(r2)
   1ffec:	bc800204 	addi	r18,r23,8
   1fff0:	21807836 	bltu	r4,r6,201d4 <_realloc_r+0x4e8>
   1fff4:	008004c4 	movi	r2,19
   1fff8:	1180732e 	bgeu	r2,r6,201c8 <_realloc_r+0x4dc>
   1fffc:	80800017 	ldw	r2,0(r16)
   20000:	b8800215 	stw	r2,8(r23)
   20004:	80800117 	ldw	r2,4(r16)
   20008:	b8800315 	stw	r2,12(r23)
   2000c:	008006c4 	movi	r2,27
   20010:	11808936 	bltu	r2,r6,20238 <_realloc_r+0x54c>
   20014:	b8800404 	addi	r2,r23,16
   20018:	80c00204 	addi	r3,r16,8
   2001c:	19000017 	ldw	r4,0(r3)
   20020:	9021883a 	mov	r16,r18
   20024:	3829883a 	mov	r20,r7
   20028:	11000015 	stw	r4,0(r2)
   2002c:	19000117 	ldw	r4,4(r3)
   20030:	b82d883a 	mov	r22,r23
   20034:	11000115 	stw	r4,4(r2)
   20038:	18c00217 	ldw	r3,8(r3)
   2003c:	10c00215 	stw	r3,8(r2)
   20040:	b8800117 	ldw	r2,4(r23)
   20044:	003f7b06 	br	1fe34 <_realloc_r+0x148>
   20048:	80c00017 	ldw	r3,0(r16)
   2004c:	90c00015 	stw	r3,0(r18)
   20050:	80c00117 	ldw	r3,4(r16)
   20054:	90c00115 	stw	r3,4(r18)
   20058:	00c006c4 	movi	r3,27
   2005c:	19804636 	bltu	r3,r6,20178 <_realloc_r+0x48c>
   20060:	90800204 	addi	r2,r18,8
   20064:	80c00204 	addi	r3,r16,8
   20068:	003fb906 	br	1ff50 <_realloc_r+0x264>
   2006c:	9005883a 	mov	r2,r18
   20070:	8007883a 	mov	r3,r16
   20074:	19000017 	ldw	r4,0(r3)
   20078:	9021883a 	mov	r16,r18
   2007c:	b82d883a 	mov	r22,r23
   20080:	11000015 	stw	r4,0(r2)
   20084:	19000117 	ldw	r4,4(r3)
   20088:	11000115 	stw	r4,4(r2)
   2008c:	18c00217 	ldw	r3,8(r3)
   20090:	10c00215 	stw	r3,8(r2)
   20094:	b8800117 	ldw	r2,4(r23)
   20098:	003f6606 	br	1fe34 <_realloc_r+0x148>
   2009c:	2445c83a 	sub	r2,r4,r17
   200a0:	b46d883a 	add	r22,r22,r17
   200a4:	10800054 	ori	r2,r2,1
   200a8:	b0800115 	stw	r2,4(r22)
   200ac:	80bfff17 	ldw	r2,-4(r16)
   200b0:	a809883a 	mov	r4,r21
   200b4:	e5800215 	stw	r22,8(fp)
   200b8:	1080004c 	andi	r2,r2,1
   200bc:	88a2b03a 	or	r17,r17,r2
   200c0:	847fff15 	stw	r17,-4(r16)
   200c4:	0021f800 	call	21f80 <__malloc_unlock>
   200c8:	8025883a 	mov	r18,r16
   200cc:	003f6606 	br	1fe68 <_realloc_r+0x17c>
   200d0:	9009883a 	mov	r4,r18
   200d4:	800b883a 	mov	r5,r16
   200d8:	001ec1c0 	call	1ec1c <memmove>
   200dc:	003fa206 	br	1ff68 <_realloc_r+0x27c>
   200e0:	88800404 	addi	r2,r17,16
   200e4:	a0bf8716 	blt	r20,r2,1ff04 <_realloc_r+0x218>
   200e8:	b8800317 	ldw	r2,12(r23)
   200ec:	b8c00217 	ldw	r3,8(r23)
   200f0:	99bfff04 	addi	r6,r19,-4
   200f4:	01000904 	movi	r4,36
   200f8:	18800315 	stw	r2,12(r3)
   200fc:	10c00215 	stw	r3,8(r2)
   20100:	bc800204 	addi	r18,r23,8
   20104:	21806536 	bltu	r4,r6,2029c <_realloc_r+0x5b0>
   20108:	008004c4 	movi	r2,19
   2010c:	1180592e 	bgeu	r2,r6,20274 <_realloc_r+0x588>
   20110:	80800017 	ldw	r2,0(r16)
   20114:	b8800215 	stw	r2,8(r23)
   20118:	80800117 	ldw	r2,4(r16)
   2011c:	b8800315 	stw	r2,12(r23)
   20120:	008006c4 	movi	r2,27
   20124:	11806136 	bltu	r2,r6,202ac <_realloc_r+0x5c0>
   20128:	b8800404 	addi	r2,r23,16
   2012c:	80c00204 	addi	r3,r16,8
   20130:	19000017 	ldw	r4,0(r3)
   20134:	11000015 	stw	r4,0(r2)
   20138:	19000117 	ldw	r4,4(r3)
   2013c:	11000115 	stw	r4,4(r2)
   20140:	18c00217 	ldw	r3,8(r3)
   20144:	10c00215 	stw	r3,8(r2)
   20148:	a447c83a 	sub	r3,r20,r17
   2014c:	bc45883a 	add	r2,r23,r17
   20150:	18c00054 	ori	r3,r3,1
   20154:	10c00115 	stw	r3,4(r2)
   20158:	b8c00117 	ldw	r3,4(r23)
   2015c:	e0800215 	stw	r2,8(fp)
   20160:	a809883a 	mov	r4,r21
   20164:	1880004c 	andi	r2,r3,1
   20168:	88a2b03a 	or	r17,r17,r2
   2016c:	bc400115 	stw	r17,4(r23)
   20170:	0021f800 	call	21f80 <__malloc_unlock>
   20174:	003f3c06 	br	1fe68 <_realloc_r+0x17c>
   20178:	80c00217 	ldw	r3,8(r16)
   2017c:	90c00215 	stw	r3,8(r18)
   20180:	80c00317 	ldw	r3,12(r16)
   20184:	90c00315 	stw	r3,12(r18)
   20188:	30802426 	beq	r6,r2,2021c <_realloc_r+0x530>
   2018c:	90800404 	addi	r2,r18,16
   20190:	80c00404 	addi	r3,r16,16
   20194:	003f6e06 	br	1ff50 <_realloc_r+0x264>
   20198:	953fff17 	ldw	r20,-4(r18)
   2019c:	00ffff04 	movi	r3,-4
   201a0:	a0e8703a 	and	r20,r20,r3
   201a4:	a4e9883a 	add	r20,r20,r19
   201a8:	003f2206 	br	1fe34 <_realloc_r+0x148>
   201ac:	800b883a 	mov	r5,r16
   201b0:	9009883a 	mov	r4,r18
   201b4:	001ec1c0 	call	1ec1c <memmove>
   201b8:	9021883a 	mov	r16,r18
   201bc:	b8800117 	ldw	r2,4(r23)
   201c0:	b82d883a 	mov	r22,r23
   201c4:	003f1b06 	br	1fe34 <_realloc_r+0x148>
   201c8:	9005883a 	mov	r2,r18
   201cc:	8007883a 	mov	r3,r16
   201d0:	003f9206 	br	2001c <_realloc_r+0x330>
   201d4:	800b883a 	mov	r5,r16
   201d8:	9009883a 	mov	r4,r18
   201dc:	d9c00015 	stw	r7,0(sp)
   201e0:	001ec1c0 	call	1ec1c <memmove>
   201e4:	d9c00017 	ldw	r7,0(sp)
   201e8:	9021883a 	mov	r16,r18
   201ec:	b8800117 	ldw	r2,4(r23)
   201f0:	3829883a 	mov	r20,r7
   201f4:	b82d883a 	mov	r22,r23
   201f8:	003f0e06 	br	1fe34 <_realloc_r+0x148>
   201fc:	80800217 	ldw	r2,8(r16)
   20200:	b8800415 	stw	r2,16(r23)
   20204:	80800317 	ldw	r2,12(r16)
   20208:	b8800515 	stw	r2,20(r23)
   2020c:	31001226 	beq	r6,r4,20258 <_realloc_r+0x56c>
   20210:	b8800604 	addi	r2,r23,24
   20214:	80c00404 	addi	r3,r16,16
   20218:	003f9606 	br	20074 <_realloc_r+0x388>
   2021c:	81000417 	ldw	r4,16(r16)
   20220:	90800604 	addi	r2,r18,24
   20224:	80c00604 	addi	r3,r16,24
   20228:	91000415 	stw	r4,16(r18)
   2022c:	81000517 	ldw	r4,20(r16)
   20230:	91000515 	stw	r4,20(r18)
   20234:	003f4606 	br	1ff50 <_realloc_r+0x264>
   20238:	80800217 	ldw	r2,8(r16)
   2023c:	b8800415 	stw	r2,16(r23)
   20240:	80800317 	ldw	r2,12(r16)
   20244:	b8800515 	stw	r2,20(r23)
   20248:	31000d26 	beq	r6,r4,20280 <_realloc_r+0x594>
   2024c:	b8800604 	addi	r2,r23,24
   20250:	80c00404 	addi	r3,r16,16
   20254:	003f7106 	br	2001c <_realloc_r+0x330>
   20258:	81000417 	ldw	r4,16(r16)
   2025c:	b8800804 	addi	r2,r23,32
   20260:	80c00604 	addi	r3,r16,24
   20264:	b9000615 	stw	r4,24(r23)
   20268:	81000517 	ldw	r4,20(r16)
   2026c:	b9000715 	stw	r4,28(r23)
   20270:	003f8006 	br	20074 <_realloc_r+0x388>
   20274:	9005883a 	mov	r2,r18
   20278:	8007883a 	mov	r3,r16
   2027c:	003fac06 	br	20130 <_realloc_r+0x444>
   20280:	81000417 	ldw	r4,16(r16)
   20284:	b8800804 	addi	r2,r23,32
   20288:	80c00604 	addi	r3,r16,24
   2028c:	b9000615 	stw	r4,24(r23)
   20290:	81000517 	ldw	r4,20(r16)
   20294:	b9000715 	stw	r4,28(r23)
   20298:	003f6006 	br	2001c <_realloc_r+0x330>
   2029c:	9009883a 	mov	r4,r18
   202a0:	800b883a 	mov	r5,r16
   202a4:	001ec1c0 	call	1ec1c <memmove>
   202a8:	003fa706 	br	20148 <_realloc_r+0x45c>
   202ac:	80800217 	ldw	r2,8(r16)
   202b0:	b8800415 	stw	r2,16(r23)
   202b4:	80800317 	ldw	r2,12(r16)
   202b8:	b8800515 	stw	r2,20(r23)
   202bc:	31000326 	beq	r6,r4,202cc <_realloc_r+0x5e0>
   202c0:	b8800604 	addi	r2,r23,24
   202c4:	80c00404 	addi	r3,r16,16
   202c8:	003f9906 	br	20130 <_realloc_r+0x444>
   202cc:	81000417 	ldw	r4,16(r16)
   202d0:	b8800804 	addi	r2,r23,32
   202d4:	80c00604 	addi	r3,r16,24
   202d8:	b9000615 	stw	r4,24(r23)
   202dc:	81000517 	ldw	r4,20(r16)
   202e0:	b9000715 	stw	r4,28(r23)
   202e4:	003f9206 	br	20130 <_realloc_r+0x444>

000202e8 <__isinfd>:
   202e8:	0105c83a 	sub	r2,zero,r4
   202ec:	1108b03a 	or	r4,r2,r4
   202f0:	2004d7fa 	srli	r2,r4,31
   202f4:	00e00034 	movhi	r3,32768
   202f8:	18ffffc4 	addi	r3,r3,-1
   202fc:	28ca703a 	and	r5,r5,r3
   20300:	1144b03a 	or	r2,r2,r5
   20304:	00dffc34 	movhi	r3,32752
   20308:	1885c83a 	sub	r2,r3,r2
   2030c:	0087c83a 	sub	r3,zero,r2
   20310:	1884b03a 	or	r2,r3,r2
   20314:	1005d7fa 	srai	r2,r2,31
   20318:	10800044 	addi	r2,r2,1
   2031c:	f800283a 	ret

00020320 <__isnand>:
   20320:	0105c83a 	sub	r2,zero,r4
   20324:	1108b03a 	or	r4,r2,r4
   20328:	2004d7fa 	srli	r2,r4,31
   2032c:	00e00034 	movhi	r3,32768
   20330:	18ffffc4 	addi	r3,r3,-1
   20334:	28ca703a 	and	r5,r5,r3
   20338:	1144b03a 	or	r2,r2,r5
   2033c:	00dffc34 	movhi	r3,32752
   20340:	1885c83a 	sub	r2,r3,r2
   20344:	1004d7fa 	srli	r2,r2,31
   20348:	f800283a 	ret

0002034c <_sbrk_r>:
   2034c:	defffd04 	addi	sp,sp,-12
   20350:	dc400115 	stw	r17,4(sp)
   20354:	dc000015 	stw	r16,0(sp)
   20358:	2023883a 	mov	r17,r4
   2035c:	040000f4 	movhi	r16,3
   20360:	841e4904 	addi	r16,r16,31012
   20364:	2809883a 	mov	r4,r5
   20368:	dfc00215 	stw	ra,8(sp)
   2036c:	80000015 	stw	zero,0(r16)
   20370:	00221800 	call	22180 <sbrk>
   20374:	00ffffc4 	movi	r3,-1
   20378:	10c00526 	beq	r2,r3,20390 <_sbrk_r+0x44>
   2037c:	dfc00217 	ldw	ra,8(sp)
   20380:	dc400117 	ldw	r17,4(sp)
   20384:	dc000017 	ldw	r16,0(sp)
   20388:	dec00304 	addi	sp,sp,12
   2038c:	f800283a 	ret
   20390:	80c00017 	ldw	r3,0(r16)
   20394:	183ff926 	beq	r3,zero,2037c <_sbrk_r+0x30>
   20398:	88c00015 	stw	r3,0(r17)
   2039c:	dfc00217 	ldw	ra,8(sp)
   203a0:	dc400117 	ldw	r17,4(sp)
   203a4:	dc000017 	ldw	r16,0(sp)
   203a8:	dec00304 	addi	sp,sp,12
   203ac:	f800283a 	ret

000203b0 <__sread>:
   203b0:	defffe04 	addi	sp,sp,-8
   203b4:	dc000015 	stw	r16,0(sp)
   203b8:	2821883a 	mov	r16,r5
   203bc:	2940038f 	ldh	r5,14(r5)
   203c0:	dfc00115 	stw	ra,4(sp)
   203c4:	00209040 	call	20904 <_read_r>
   203c8:	10000716 	blt	r2,zero,203e8 <__sread+0x38>
   203cc:	80c01417 	ldw	r3,80(r16)
   203d0:	1887883a 	add	r3,r3,r2
   203d4:	80c01415 	stw	r3,80(r16)
   203d8:	dfc00117 	ldw	ra,4(sp)
   203dc:	dc000017 	ldw	r16,0(sp)
   203e0:	dec00204 	addi	sp,sp,8
   203e4:	f800283a 	ret
   203e8:	80c0030b 	ldhu	r3,12(r16)
   203ec:	18fbffcc 	andi	r3,r3,61439
   203f0:	80c0030d 	sth	r3,12(r16)
   203f4:	dfc00117 	ldw	ra,4(sp)
   203f8:	dc000017 	ldw	r16,0(sp)
   203fc:	dec00204 	addi	sp,sp,8
   20400:	f800283a 	ret

00020404 <__swrite>:
   20404:	2880030b 	ldhu	r2,12(r5)
   20408:	defffb04 	addi	sp,sp,-20
   2040c:	dcc00315 	stw	r19,12(sp)
   20410:	10c0400c 	andi	r3,r2,256
   20414:	18ffffcc 	andi	r3,r3,65535
   20418:	18e0001c 	xori	r3,r3,32768
   2041c:	dc800215 	stw	r18,8(sp)
   20420:	dc400115 	stw	r17,4(sp)
   20424:	dc000015 	stw	r16,0(sp)
   20428:	dfc00415 	stw	ra,16(sp)
   2042c:	18e00004 	addi	r3,r3,-32768
   20430:	2821883a 	mov	r16,r5
   20434:	2027883a 	mov	r19,r4
   20438:	3025883a 	mov	r18,r6
   2043c:	3823883a 	mov	r17,r7
   20440:	18000526 	beq	r3,zero,20458 <__swrite+0x54>
   20444:	2940038f 	ldh	r5,14(r5)
   20448:	000d883a 	mov	r6,zero
   2044c:	01c00084 	movi	r7,2
   20450:	00208980 	call	20898 <_lseek_r>
   20454:	8080030b 	ldhu	r2,12(r16)
   20458:	8140038f 	ldh	r5,14(r16)
   2045c:	10bbffcc 	andi	r2,r2,61439
   20460:	9809883a 	mov	r4,r19
   20464:	900d883a 	mov	r6,r18
   20468:	880f883a 	mov	r7,r17
   2046c:	8080030d 	sth	r2,12(r16)
   20470:	dfc00417 	ldw	ra,16(sp)
   20474:	dcc00317 	ldw	r19,12(sp)
   20478:	dc800217 	ldw	r18,8(sp)
   2047c:	dc400117 	ldw	r17,4(sp)
   20480:	dc000017 	ldw	r16,0(sp)
   20484:	dec00504 	addi	sp,sp,20
   20488:	00204f01 	jmpi	204f0 <_write_r>

0002048c <__sseek>:
   2048c:	defffe04 	addi	sp,sp,-8
   20490:	dc000015 	stw	r16,0(sp)
   20494:	2821883a 	mov	r16,r5
   20498:	2940038f 	ldh	r5,14(r5)
   2049c:	dfc00115 	stw	ra,4(sp)
   204a0:	00208980 	call	20898 <_lseek_r>
   204a4:	00ffffc4 	movi	r3,-1
   204a8:	10c00826 	beq	r2,r3,204cc <__sseek+0x40>
   204ac:	80c0030b 	ldhu	r3,12(r16)
   204b0:	80801415 	stw	r2,80(r16)
   204b4:	18c40014 	ori	r3,r3,4096
   204b8:	80c0030d 	sth	r3,12(r16)
   204bc:	dfc00117 	ldw	ra,4(sp)
   204c0:	dc000017 	ldw	r16,0(sp)
   204c4:	dec00204 	addi	sp,sp,8
   204c8:	f800283a 	ret
   204cc:	80c0030b 	ldhu	r3,12(r16)
   204d0:	18fbffcc 	andi	r3,r3,61439
   204d4:	80c0030d 	sth	r3,12(r16)
   204d8:	dfc00117 	ldw	ra,4(sp)
   204dc:	dc000017 	ldw	r16,0(sp)
   204e0:	dec00204 	addi	sp,sp,8
   204e4:	f800283a 	ret

000204e8 <__sclose>:
   204e8:	2940038f 	ldh	r5,14(r5)
   204ec:	00206181 	jmpi	20618 <_close_r>

000204f0 <_write_r>:
   204f0:	defffd04 	addi	sp,sp,-12
   204f4:	dc400115 	stw	r17,4(sp)
   204f8:	dc000015 	stw	r16,0(sp)
   204fc:	2023883a 	mov	r17,r4
   20500:	040000f4 	movhi	r16,3
   20504:	841e4904 	addi	r16,r16,31012
   20508:	2809883a 	mov	r4,r5
   2050c:	300b883a 	mov	r5,r6
   20510:	380d883a 	mov	r6,r7
   20514:	dfc00215 	stw	ra,8(sp)
   20518:	80000015 	stw	zero,0(r16)
   2051c:	00225280 	call	22528 <write>
   20520:	00ffffc4 	movi	r3,-1
   20524:	10c00526 	beq	r2,r3,2053c <_write_r+0x4c>
   20528:	dfc00217 	ldw	ra,8(sp)
   2052c:	dc400117 	ldw	r17,4(sp)
   20530:	dc000017 	ldw	r16,0(sp)
   20534:	dec00304 	addi	sp,sp,12
   20538:	f800283a 	ret
   2053c:	80c00017 	ldw	r3,0(r16)
   20540:	183ff926 	beq	r3,zero,20528 <_write_r+0x38>
   20544:	88c00015 	stw	r3,0(r17)
   20548:	dfc00217 	ldw	ra,8(sp)
   2054c:	dc400117 	ldw	r17,4(sp)
   20550:	dc000017 	ldw	r16,0(sp)
   20554:	dec00304 	addi	sp,sp,12
   20558:	f800283a 	ret

0002055c <_calloc_r>:
   2055c:	314b383a 	mul	r5,r6,r5
   20560:	defffe04 	addi	sp,sp,-8
   20564:	dc000015 	stw	r16,0(sp)
   20568:	dfc00115 	stw	ra,4(sp)
   2056c:	001e3a00 	call	1e3a0 <_malloc_r>
   20570:	1021883a 	mov	r16,r2
   20574:	10000c26 	beq	r2,zero,205a8 <_calloc_r+0x4c>
   20578:	11bfff17 	ldw	r6,-4(r2)
   2057c:	00ffff04 	movi	r3,-4
   20580:	00800904 	movi	r2,36
   20584:	30cc703a 	and	r6,r6,r3
   20588:	30cd883a 	add	r6,r6,r3
   2058c:	11801436 	bltu	r2,r6,205e0 <_calloc_r+0x84>
   20590:	00c004c4 	movi	r3,19
   20594:	19800936 	bltu	r3,r6,205bc <_calloc_r+0x60>
   20598:	8005883a 	mov	r2,r16
   2059c:	10000015 	stw	zero,0(r2)
   205a0:	10000115 	stw	zero,4(r2)
   205a4:	10000215 	stw	zero,8(r2)
   205a8:	8005883a 	mov	r2,r16
   205ac:	dfc00117 	ldw	ra,4(sp)
   205b0:	dc000017 	ldw	r16,0(sp)
   205b4:	dec00204 	addi	sp,sp,8
   205b8:	f800283a 	ret
   205bc:	80000015 	stw	zero,0(r16)
   205c0:	80000115 	stw	zero,4(r16)
   205c4:	00c006c4 	movi	r3,27
   205c8:	19800d2e 	bgeu	r3,r6,20600 <_calloc_r+0xa4>
   205cc:	80000215 	stw	zero,8(r16)
   205d0:	80000315 	stw	zero,12(r16)
   205d4:	30800c26 	beq	r6,r2,20608 <_calloc_r+0xac>
   205d8:	80800404 	addi	r2,r16,16
   205dc:	003fef06 	br	2059c <_calloc_r+0x40>
   205e0:	8009883a 	mov	r4,r16
   205e4:	000b883a 	mov	r5,zero
   205e8:	00192e80 	call	192e8 <memset>
   205ec:	8005883a 	mov	r2,r16
   205f0:	dfc00117 	ldw	ra,4(sp)
   205f4:	dc000017 	ldw	r16,0(sp)
   205f8:	dec00204 	addi	sp,sp,8
   205fc:	f800283a 	ret
   20600:	80800204 	addi	r2,r16,8
   20604:	003fe506 	br	2059c <_calloc_r+0x40>
   20608:	80000415 	stw	zero,16(r16)
   2060c:	80000515 	stw	zero,20(r16)
   20610:	80800604 	addi	r2,r16,24
   20614:	003fe106 	br	2059c <_calloc_r+0x40>

00020618 <_close_r>:
   20618:	defffd04 	addi	sp,sp,-12
   2061c:	dc400115 	stw	r17,4(sp)
   20620:	dc000015 	stw	r16,0(sp)
   20624:	2023883a 	mov	r17,r4
   20628:	040000f4 	movhi	r16,3
   2062c:	841e4904 	addi	r16,r16,31012
   20630:	2809883a 	mov	r4,r5
   20634:	dfc00215 	stw	ra,8(sp)
   20638:	80000015 	stw	zero,0(r16)
   2063c:	00219fc0 	call	219fc <close>
   20640:	00ffffc4 	movi	r3,-1
   20644:	10c00526 	beq	r2,r3,2065c <_close_r+0x44>
   20648:	dfc00217 	ldw	ra,8(sp)
   2064c:	dc400117 	ldw	r17,4(sp)
   20650:	dc000017 	ldw	r16,0(sp)
   20654:	dec00304 	addi	sp,sp,12
   20658:	f800283a 	ret
   2065c:	80c00017 	ldw	r3,0(r16)
   20660:	183ff926 	beq	r3,zero,20648 <_close_r+0x30>
   20664:	88c00015 	stw	r3,0(r17)
   20668:	dfc00217 	ldw	ra,8(sp)
   2066c:	dc400117 	ldw	r17,4(sp)
   20670:	dc000017 	ldw	r16,0(sp)
   20674:	dec00304 	addi	sp,sp,12
   20678:	f800283a 	ret

0002067c <_fclose_r>:
   2067c:	defffc04 	addi	sp,sp,-16
   20680:	dc400115 	stw	r17,4(sp)
   20684:	dc000015 	stw	r16,0(sp)
   20688:	dfc00315 	stw	ra,12(sp)
   2068c:	dc800215 	stw	r18,8(sp)
   20690:	2821883a 	mov	r16,r5
   20694:	2023883a 	mov	r17,r4
   20698:	28003426 	beq	r5,zero,2076c <_fclose_r+0xf0>
   2069c:	001d68c0 	call	1d68c <__sfp_lock_acquire>
   206a0:	88000226 	beq	r17,zero,206ac <_fclose_r+0x30>
   206a4:	88800e17 	ldw	r2,56(r17)
   206a8:	10003826 	beq	r2,zero,2078c <_fclose_r+0x110>
   206ac:	8080030f 	ldh	r2,12(r16)
   206b0:	10002526 	beq	r2,zero,20748 <_fclose_r+0xcc>
   206b4:	8809883a 	mov	r4,r17
   206b8:	800b883a 	mov	r5,r16
   206bc:	001d1dc0 	call	1d1dc <_fflush_r>
   206c0:	1025883a 	mov	r18,r2
   206c4:	80800b17 	ldw	r2,44(r16)
   206c8:	10000426 	beq	r2,zero,206dc <_fclose_r+0x60>
   206cc:	81400717 	ldw	r5,28(r16)
   206d0:	8809883a 	mov	r4,r17
   206d4:	103ee83a 	callr	r2
   206d8:	10003516 	blt	r2,zero,207b0 <_fclose_r+0x134>
   206dc:	8080030b 	ldhu	r2,12(r16)
   206e0:	1080200c 	andi	r2,r2,128
   206e4:	10bfffcc 	andi	r2,r2,65535
   206e8:	10a0001c 	xori	r2,r2,32768
   206ec:	10a00004 	addi	r2,r2,-32768
   206f0:	10002b1e 	bne	r2,zero,207a0 <_fclose_r+0x124>
   206f4:	81400c17 	ldw	r5,48(r16)
   206f8:	28000526 	beq	r5,zero,20710 <_fclose_r+0x94>
   206fc:	80801004 	addi	r2,r16,64
   20700:	28800226 	beq	r5,r2,2070c <_fclose_r+0x90>
   20704:	8809883a 	mov	r4,r17
   20708:	001d8080 	call	1d808 <_free_r>
   2070c:	80000c15 	stw	zero,48(r16)
   20710:	81401117 	ldw	r5,68(r16)
   20714:	28000326 	beq	r5,zero,20724 <_fclose_r+0xa8>
   20718:	8809883a 	mov	r4,r17
   2071c:	001d8080 	call	1d808 <_free_r>
   20720:	80001115 	stw	zero,68(r16)
   20724:	8000030d 	sth	zero,12(r16)
   20728:	001d6900 	call	1d690 <__sfp_lock_release>
   2072c:	9005883a 	mov	r2,r18
   20730:	dfc00317 	ldw	ra,12(sp)
   20734:	dc800217 	ldw	r18,8(sp)
   20738:	dc400117 	ldw	r17,4(sp)
   2073c:	dc000017 	ldw	r16,0(sp)
   20740:	dec00404 	addi	sp,sp,16
   20744:	f800283a 	ret
   20748:	001d6900 	call	1d690 <__sfp_lock_release>
   2074c:	0025883a 	mov	r18,zero
   20750:	9005883a 	mov	r2,r18
   20754:	dfc00317 	ldw	ra,12(sp)
   20758:	dc800217 	ldw	r18,8(sp)
   2075c:	dc400117 	ldw	r17,4(sp)
   20760:	dc000017 	ldw	r16,0(sp)
   20764:	dec00404 	addi	sp,sp,16
   20768:	f800283a 	ret
   2076c:	0025883a 	mov	r18,zero
   20770:	9005883a 	mov	r2,r18
   20774:	dfc00317 	ldw	ra,12(sp)
   20778:	dc800217 	ldw	r18,8(sp)
   2077c:	dc400117 	ldw	r17,4(sp)
   20780:	dc000017 	ldw	r16,0(sp)
   20784:	dec00404 	addi	sp,sp,16
   20788:	f800283a 	ret
   2078c:	8809883a 	mov	r4,r17
   20790:	001d4840 	call	1d484 <__sinit>
   20794:	8080030f 	ldh	r2,12(r16)
   20798:	103fc61e 	bne	r2,zero,206b4 <_fclose_r+0x38>
   2079c:	003fea06 	br	20748 <_fclose_r+0xcc>
   207a0:	81400417 	ldw	r5,16(r16)
   207a4:	8809883a 	mov	r4,r17
   207a8:	001d8080 	call	1d808 <_free_r>
   207ac:	003fd106 	br	206f4 <_fclose_r+0x78>
   207b0:	04bfffc4 	movi	r18,-1
   207b4:	003fc906 	br	206dc <_fclose_r+0x60>

000207b8 <fclose>:
   207b8:	008000f4 	movhi	r2,3
   207bc:	10957f04 	addi	r2,r2,22012
   207c0:	200b883a 	mov	r5,r4
   207c4:	11000017 	ldw	r4,0(r2)
   207c8:	002067c1 	jmpi	2067c <_fclose_r>

000207cc <_fstat_r>:
   207cc:	defffd04 	addi	sp,sp,-12
   207d0:	dc400115 	stw	r17,4(sp)
   207d4:	dc000015 	stw	r16,0(sp)
   207d8:	2023883a 	mov	r17,r4
   207dc:	040000f4 	movhi	r16,3
   207e0:	841e4904 	addi	r16,r16,31012
   207e4:	2809883a 	mov	r4,r5
   207e8:	300b883a 	mov	r5,r6
   207ec:	dfc00215 	stw	ra,8(sp)
   207f0:	80000015 	stw	zero,0(r16)
   207f4:	0021b400 	call	21b40 <fstat>
   207f8:	00ffffc4 	movi	r3,-1
   207fc:	10c00526 	beq	r2,r3,20814 <_fstat_r+0x48>
   20800:	dfc00217 	ldw	ra,8(sp)
   20804:	dc400117 	ldw	r17,4(sp)
   20808:	dc000017 	ldw	r16,0(sp)
   2080c:	dec00304 	addi	sp,sp,12
   20810:	f800283a 	ret
   20814:	80c00017 	ldw	r3,0(r16)
   20818:	183ff926 	beq	r3,zero,20800 <_fstat_r+0x34>
   2081c:	88c00015 	stw	r3,0(r17)
   20820:	dfc00217 	ldw	ra,8(sp)
   20824:	dc400117 	ldw	r17,4(sp)
   20828:	dc000017 	ldw	r16,0(sp)
   2082c:	dec00304 	addi	sp,sp,12
   20830:	f800283a 	ret

00020834 <_isatty_r>:
   20834:	defffd04 	addi	sp,sp,-12
   20838:	dc400115 	stw	r17,4(sp)
   2083c:	dc000015 	stw	r16,0(sp)
   20840:	2023883a 	mov	r17,r4
   20844:	040000f4 	movhi	r16,3
   20848:	841e4904 	addi	r16,r16,31012
   2084c:	2809883a 	mov	r4,r5
   20850:	dfc00215 	stw	ra,8(sp)
   20854:	80000015 	stw	zero,0(r16)
   20858:	0021c3c0 	call	21c3c <isatty>
   2085c:	00ffffc4 	movi	r3,-1
   20860:	10c00526 	beq	r2,r3,20878 <_isatty_r+0x44>
   20864:	dfc00217 	ldw	ra,8(sp)
   20868:	dc400117 	ldw	r17,4(sp)
   2086c:	dc000017 	ldw	r16,0(sp)
   20870:	dec00304 	addi	sp,sp,12
   20874:	f800283a 	ret
   20878:	80c00017 	ldw	r3,0(r16)
   2087c:	183ff926 	beq	r3,zero,20864 <_isatty_r+0x30>
   20880:	88c00015 	stw	r3,0(r17)
   20884:	dfc00217 	ldw	ra,8(sp)
   20888:	dc400117 	ldw	r17,4(sp)
   2088c:	dc000017 	ldw	r16,0(sp)
   20890:	dec00304 	addi	sp,sp,12
   20894:	f800283a 	ret

00020898 <_lseek_r>:
   20898:	defffd04 	addi	sp,sp,-12
   2089c:	dc400115 	stw	r17,4(sp)
   208a0:	dc000015 	stw	r16,0(sp)
   208a4:	2023883a 	mov	r17,r4
   208a8:	040000f4 	movhi	r16,3
   208ac:	841e4904 	addi	r16,r16,31012
   208b0:	2809883a 	mov	r4,r5
   208b4:	300b883a 	mov	r5,r6
   208b8:	380d883a 	mov	r6,r7
   208bc:	dfc00215 	stw	ra,8(sp)
   208c0:	80000015 	stw	zero,0(r16)
   208c4:	0021e180 	call	21e18 <lseek>
   208c8:	00ffffc4 	movi	r3,-1
   208cc:	10c00526 	beq	r2,r3,208e4 <_lseek_r+0x4c>
   208d0:	dfc00217 	ldw	ra,8(sp)
   208d4:	dc400117 	ldw	r17,4(sp)
   208d8:	dc000017 	ldw	r16,0(sp)
   208dc:	dec00304 	addi	sp,sp,12
   208e0:	f800283a 	ret
   208e4:	80c00017 	ldw	r3,0(r16)
   208e8:	183ff926 	beq	r3,zero,208d0 <_lseek_r+0x38>
   208ec:	88c00015 	stw	r3,0(r17)
   208f0:	dfc00217 	ldw	ra,8(sp)
   208f4:	dc400117 	ldw	r17,4(sp)
   208f8:	dc000017 	ldw	r16,0(sp)
   208fc:	dec00304 	addi	sp,sp,12
   20900:	f800283a 	ret

00020904 <_read_r>:
   20904:	defffd04 	addi	sp,sp,-12
   20908:	dc400115 	stw	r17,4(sp)
   2090c:	dc000015 	stw	r16,0(sp)
   20910:	2023883a 	mov	r17,r4
   20914:	040000f4 	movhi	r16,3
   20918:	841e4904 	addi	r16,r16,31012
   2091c:	2809883a 	mov	r4,r5
   20920:	300b883a 	mov	r5,r6
   20924:	380d883a 	mov	r6,r7
   20928:	dfc00215 	stw	ra,8(sp)
   2092c:	80000015 	stw	zero,0(r16)
   20930:	0021ff00 	call	21ff0 <read>
   20934:	00ffffc4 	movi	r3,-1
   20938:	10c00526 	beq	r2,r3,20950 <_read_r+0x4c>
   2093c:	dfc00217 	ldw	ra,8(sp)
   20940:	dc400117 	ldw	r17,4(sp)
   20944:	dc000017 	ldw	r16,0(sp)
   20948:	dec00304 	addi	sp,sp,12
   2094c:	f800283a 	ret
   20950:	80c00017 	ldw	r3,0(r16)
   20954:	183ff926 	beq	r3,zero,2093c <_read_r+0x38>
   20958:	88c00015 	stw	r3,0(r17)
   2095c:	dfc00217 	ldw	ra,8(sp)
   20960:	dc400117 	ldw	r17,4(sp)
   20964:	dc000017 	ldw	r16,0(sp)
   20968:	dec00304 	addi	sp,sp,12
   2096c:	f800283a 	ret

00020970 <__udivdi3>:
   20970:	defff504 	addi	sp,sp,-44
   20974:	dd000515 	stw	r20,20(sp)
   20978:	dcc00415 	stw	r19,16(sp)
   2097c:	dc800315 	stw	r18,12(sp)
   20980:	dc400215 	stw	r17,8(sp)
   20984:	dc000115 	stw	r16,4(sp)
   20988:	dfc00a15 	stw	ra,40(sp)
   2098c:	df000915 	stw	fp,36(sp)
   20990:	ddc00815 	stw	r23,32(sp)
   20994:	dd800715 	stw	r22,28(sp)
   20998:	dd400615 	stw	r21,24(sp)
   2099c:	2025883a 	mov	r18,r4
   209a0:	2823883a 	mov	r17,r5
   209a4:	3021883a 	mov	r16,r6
   209a8:	2027883a 	mov	r19,r4
   209ac:	2829883a 	mov	r20,r5
   209b0:	3800401e 	bne	r7,zero,20ab4 <__udivdi3+0x144>
   209b4:	2980602e 	bgeu	r5,r6,20b38 <__udivdi3+0x1c8>
   209b8:	00bfffd4 	movui	r2,65535
   209bc:	1180aa36 	bltu	r2,r6,20c68 <__udivdi3+0x2f8>
   209c0:	00803fc4 	movi	r2,255
   209c4:	11814436 	bltu	r2,r6,20ed8 <__udivdi3+0x568>
   209c8:	0005883a 	mov	r2,zero
   209cc:	0007883a 	mov	r3,zero
   209d0:	3084d83a 	srl	r2,r6,r2
   209d4:	010000f4 	movhi	r4,3
   209d8:	21048e04 	addi	r4,r4,4664
   209dc:	2085883a 	add	r2,r4,r2
   209e0:	10800003 	ldbu	r2,0(r2)
   209e4:	10c7883a 	add	r3,r2,r3
   209e8:	00800804 	movi	r2,32
   209ec:	10c5c83a 	sub	r2,r2,r3
   209f0:	10000526 	beq	r2,zero,20a08 <__udivdi3+0x98>
   209f4:	88a2983a 	sll	r17,r17,r2
   209f8:	90c6d83a 	srl	r3,r18,r3
   209fc:	30a0983a 	sll	r16,r6,r2
   20a00:	90a6983a 	sll	r19,r18,r2
   20a04:	88e8b03a 	or	r20,r17,r3
   20a08:	8022d43a 	srli	r17,r16,16
   20a0c:	a009883a 	mov	r4,r20
   20a10:	857fffcc 	andi	r21,r16,65535
   20a14:	880b883a 	mov	r5,r17
   20a18:	00218380 	call	21838 <__umodsi3>
   20a1c:	a009883a 	mov	r4,r20
   20a20:	880b883a 	mov	r5,r17
   20a24:	102d883a 	mov	r22,r2
   20a28:	00218300 	call	21830 <__udivsi3>
   20a2c:	b02c943a 	slli	r22,r22,16
   20a30:	9806d43a 	srli	r3,r19,16
   20a34:	1549383a 	mul	r4,r2,r21
   20a38:	1025883a 	mov	r18,r2
   20a3c:	b0c6b03a 	or	r3,r22,r3
   20a40:	1900052e 	bgeu	r3,r4,20a58 <__udivdi3+0xe8>
   20a44:	1c07883a 	add	r3,r3,r16
   20a48:	10bfffc4 	addi	r2,r2,-1
   20a4c:	1c000136 	bltu	r3,r16,20a54 <__udivdi3+0xe4>
   20a50:	19013636 	bltu	r3,r4,20f2c <__udivdi3+0x5bc>
   20a54:	1025883a 	mov	r18,r2
   20a58:	1929c83a 	sub	r20,r3,r4
   20a5c:	a009883a 	mov	r4,r20
   20a60:	880b883a 	mov	r5,r17
   20a64:	00218380 	call	21838 <__umodsi3>
   20a68:	102d883a 	mov	r22,r2
   20a6c:	a009883a 	mov	r4,r20
   20a70:	880b883a 	mov	r5,r17
   20a74:	00218300 	call	21830 <__udivsi3>
   20a78:	b02c943a 	slli	r22,r22,16
   20a7c:	156b383a 	mul	r21,r2,r21
   20a80:	9cffffcc 	andi	r19,r19,65535
   20a84:	b4e6b03a 	or	r19,r22,r19
   20a88:	1009883a 	mov	r4,r2
   20a8c:	9d40052e 	bgeu	r19,r21,20aa4 <__udivdi3+0x134>
   20a90:	9c27883a 	add	r19,r19,r16
   20a94:	10bfffc4 	addi	r2,r2,-1
   20a98:	9c00f736 	bltu	r19,r16,20e78 <__udivdi3+0x508>
   20a9c:	9d40f62e 	bgeu	r19,r21,20e78 <__udivdi3+0x508>
   20aa0:	213fff84 	addi	r4,r4,-2
   20aa4:	9004943a 	slli	r2,r18,16
   20aa8:	0007883a 	mov	r3,zero
   20aac:	2084b03a 	or	r2,r4,r2
   20ab0:	00001506 	br	20b08 <__udivdi3+0x198>
   20ab4:	29c06536 	bltu	r5,r7,20c4c <__udivdi3+0x2dc>
   20ab8:	00bfffd4 	movui	r2,65535
   20abc:	11c0652e 	bgeu	r2,r7,20c54 <__udivdi3+0x2e4>
   20ac0:	00804034 	movhi	r2,256
   20ac4:	10bfffc4 	addi	r2,r2,-1
   20ac8:	11c0f736 	bltu	r2,r7,20ea8 <__udivdi3+0x538>
   20acc:	00c00404 	movi	r3,16
   20ad0:	180b883a 	mov	r5,r3
   20ad4:	38c6d83a 	srl	r3,r7,r3
   20ad8:	010000f4 	movhi	r4,3
   20adc:	21048e04 	addi	r4,r4,4664
   20ae0:	04000804 	movi	r16,32
   20ae4:	20c7883a 	add	r3,r4,r3
   20ae8:	18800003 	ldbu	r2,0(r3)
   20aec:	1145883a 	add	r2,r2,r5
   20af0:	80a1c83a 	sub	r16,r16,r2
   20af4:	8000691e 	bne	r16,zero,20c9c <__udivdi3+0x32c>
   20af8:	0007883a 	mov	r3,zero
   20afc:	3c406536 	bltu	r7,r17,20c94 <__udivdi3+0x324>
   20b00:	9180642e 	bgeu	r18,r6,20c94 <__udivdi3+0x324>
   20b04:	0005883a 	mov	r2,zero
   20b08:	dfc00a17 	ldw	ra,40(sp)
   20b0c:	df000917 	ldw	fp,36(sp)
   20b10:	ddc00817 	ldw	r23,32(sp)
   20b14:	dd800717 	ldw	r22,28(sp)
   20b18:	dd400617 	ldw	r21,24(sp)
   20b1c:	dd000517 	ldw	r20,20(sp)
   20b20:	dcc00417 	ldw	r19,16(sp)
   20b24:	dc800317 	ldw	r18,12(sp)
   20b28:	dc400217 	ldw	r17,8(sp)
   20b2c:	dc000117 	ldw	r16,4(sp)
   20b30:	dec00b04 	addi	sp,sp,44
   20b34:	f800283a 	ret
   20b38:	3000041e 	bne	r6,zero,20b4c <__udivdi3+0x1dc>
   20b3c:	01000044 	movi	r4,1
   20b40:	000b883a 	mov	r5,zero
   20b44:	00218300 	call	21830 <__udivsi3>
   20b48:	1021883a 	mov	r16,r2
   20b4c:	00bfffd4 	movui	r2,65535
   20b50:	14004b2e 	bgeu	r2,r16,20c80 <__udivdi3+0x310>
   20b54:	00804034 	movhi	r2,256
   20b58:	10bfffc4 	addi	r2,r2,-1
   20b5c:	1400d836 	bltu	r2,r16,20ec0 <__udivdi3+0x550>
   20b60:	00800404 	movi	r2,16
   20b64:	1007883a 	mov	r3,r2
   20b68:	8084d83a 	srl	r2,r16,r2
   20b6c:	010000f4 	movhi	r4,3
   20b70:	21048e04 	addi	r4,r4,4664
   20b74:	2085883a 	add	r2,r4,r2
   20b78:	10800003 	ldbu	r2,0(r2)
   20b7c:	10c7883a 	add	r3,r2,r3
   20b80:	00800804 	movi	r2,32
   20b84:	10c5c83a 	sub	r2,r2,r3
   20b88:	1000891e 	bne	r2,zero,20db0 <__udivdi3+0x440>
   20b8c:	8028d43a 	srli	r20,r16,16
   20b90:	8c23c83a 	sub	r17,r17,r16
   20b94:	84bfffcc 	andi	r18,r16,65535
   20b98:	00c00044 	movi	r3,1
   20b9c:	8809883a 	mov	r4,r17
   20ba0:	a00b883a 	mov	r5,r20
   20ba4:	d8c00015 	stw	r3,0(sp)
   20ba8:	00218380 	call	21838 <__umodsi3>
   20bac:	8809883a 	mov	r4,r17
   20bb0:	a00b883a 	mov	r5,r20
   20bb4:	102b883a 	mov	r21,r2
   20bb8:	00218300 	call	21830 <__udivsi3>
   20bbc:	a82a943a 	slli	r21,r21,16
   20bc0:	9808d43a 	srli	r4,r19,16
   20bc4:	148b383a 	mul	r5,r2,r18
   20bc8:	1023883a 	mov	r17,r2
   20bcc:	a908b03a 	or	r4,r21,r4
   20bd0:	d8c00017 	ldw	r3,0(sp)
   20bd4:	2140052e 	bgeu	r4,r5,20bec <__udivdi3+0x27c>
   20bd8:	2409883a 	add	r4,r4,r16
   20bdc:	10bfffc4 	addi	r2,r2,-1
   20be0:	24000136 	bltu	r4,r16,20be8 <__udivdi3+0x278>
   20be4:	2140ce36 	bltu	r4,r5,20f20 <__udivdi3+0x5b0>
   20be8:	1023883a 	mov	r17,r2
   20bec:	216bc83a 	sub	r21,r4,r5
   20bf0:	a809883a 	mov	r4,r21
   20bf4:	a00b883a 	mov	r5,r20
   20bf8:	d8c00015 	stw	r3,0(sp)
   20bfc:	00218380 	call	21838 <__umodsi3>
   20c00:	102d883a 	mov	r22,r2
   20c04:	a809883a 	mov	r4,r21
   20c08:	a00b883a 	mov	r5,r20
   20c0c:	00218300 	call	21830 <__udivsi3>
   20c10:	b02c943a 	slli	r22,r22,16
   20c14:	14a5383a 	mul	r18,r2,r18
   20c18:	9cffffcc 	andi	r19,r19,65535
   20c1c:	b4e6b03a 	or	r19,r22,r19
   20c20:	1009883a 	mov	r4,r2
   20c24:	d8c00017 	ldw	r3,0(sp)
   20c28:	9c80052e 	bgeu	r19,r18,20c40 <__udivdi3+0x2d0>
   20c2c:	9c27883a 	add	r19,r19,r16
   20c30:	10bfffc4 	addi	r2,r2,-1
   20c34:	9c009236 	bltu	r19,r16,20e80 <__udivdi3+0x510>
   20c38:	9c80912e 	bgeu	r19,r18,20e80 <__udivdi3+0x510>
   20c3c:	213fff84 	addi	r4,r4,-2
   20c40:	8804943a 	slli	r2,r17,16
   20c44:	2084b03a 	or	r2,r4,r2
   20c48:	003faf06 	br	20b08 <__udivdi3+0x198>
   20c4c:	0007883a 	mov	r3,zero
   20c50:	003fac06 	br	20b04 <__udivdi3+0x194>
   20c54:	00803fc4 	movi	r2,255
   20c58:	11c09636 	bltu	r2,r7,20eb4 <__udivdi3+0x544>
   20c5c:	0007883a 	mov	r3,zero
   20c60:	000b883a 	mov	r5,zero
   20c64:	003f9b06 	br	20ad4 <__udivdi3+0x164>
   20c68:	00804034 	movhi	r2,256
   20c6c:	10bfffc4 	addi	r2,r2,-1
   20c70:	11809636 	bltu	r2,r6,20ecc <__udivdi3+0x55c>
   20c74:	00800404 	movi	r2,16
   20c78:	1007883a 	mov	r3,r2
   20c7c:	003f5406 	br	209d0 <__udivdi3+0x60>
   20c80:	00803fc4 	movi	r2,255
   20c84:	14009736 	bltu	r2,r16,20ee4 <__udivdi3+0x574>
   20c88:	0005883a 	mov	r2,zero
   20c8c:	0007883a 	mov	r3,zero
   20c90:	003fb506 	br	20b68 <__udivdi3+0x1f8>
   20c94:	00800044 	movi	r2,1
   20c98:	003f9b06 	br	20b08 <__udivdi3+0x198>
   20c9c:	3086d83a 	srl	r3,r6,r2
   20ca0:	3c0e983a 	sll	r7,r7,r16
   20ca4:	88aad83a 	srl	r21,r17,r2
   20ca8:	9084d83a 	srl	r2,r18,r2
   20cac:	38e6b03a 	or	r19,r7,r3
   20cb0:	9828d43a 	srli	r20,r19,16
   20cb4:	8c22983a 	sll	r17,r17,r16
   20cb8:	a809883a 	mov	r4,r21
   20cbc:	a00b883a 	mov	r5,r20
   20cc0:	342c983a 	sll	r22,r6,r16
   20cc4:	88a2b03a 	or	r17,r17,r2
   20cc8:	00218380 	call	21838 <__umodsi3>
   20ccc:	a809883a 	mov	r4,r21
   20cd0:	a00b883a 	mov	r5,r20
   20cd4:	1039883a 	mov	fp,r2
   20cd8:	00218300 	call	21830 <__udivsi3>
   20cdc:	102b883a 	mov	r21,r2
   20ce0:	9dffffcc 	andi	r23,r19,65535
   20ce4:	e008943a 	slli	r4,fp,16
   20ce8:	8804d43a 	srli	r2,r17,16
   20cec:	adcd383a 	mul	r6,r21,r23
   20cf0:	2088b03a 	or	r4,r4,r2
   20cf4:	2180042e 	bgeu	r4,r6,20d08 <__udivdi3+0x398>
   20cf8:	24c9883a 	add	r4,r4,r19
   20cfc:	a8bfffc4 	addi	r2,r21,-1
   20d00:	24c07f2e 	bgeu	r4,r19,20f00 <__udivdi3+0x590>
   20d04:	102b883a 	mov	r21,r2
   20d08:	21b9c83a 	sub	fp,r4,r6
   20d0c:	e009883a 	mov	r4,fp
   20d10:	a00b883a 	mov	r5,r20
   20d14:	00218380 	call	21838 <__umodsi3>
   20d18:	e009883a 	mov	r4,fp
   20d1c:	a00b883a 	mov	r5,r20
   20d20:	d8800015 	stw	r2,0(sp)
   20d24:	00218300 	call	21830 <__udivsi3>
   20d28:	d8c00017 	ldw	r3,0(sp)
   20d2c:	15cb383a 	mul	r5,r2,r23
   20d30:	8c7fffcc 	andi	r17,r17,65535
   20d34:	1806943a 	slli	r3,r3,16
   20d38:	1009883a 	mov	r4,r2
   20d3c:	1c46b03a 	or	r3,r3,r17
   20d40:	1940042e 	bgeu	r3,r5,20d54 <__udivdi3+0x3e4>
   20d44:	1cc7883a 	add	r3,r3,r19
   20d48:	10bfffc4 	addi	r2,r2,-1
   20d4c:	1cc0682e 	bgeu	r3,r19,20ef0 <__udivdi3+0x580>
   20d50:	1009883a 	mov	r4,r2
   20d54:	a804943a 	slli	r2,r21,16
   20d58:	b1ffffcc 	andi	r7,r22,65535
   20d5c:	b02cd43a 	srli	r22,r22,16
   20d60:	2084b03a 	or	r2,r4,r2
   20d64:	113fffcc 	andi	r4,r2,65535
   20d68:	100cd43a 	srli	r6,r2,16
   20d6c:	21d1383a 	mul	r8,r4,r7
   20d70:	2589383a 	mul	r4,r4,r22
   20d74:	31cf383a 	mul	r7,r6,r7
   20d78:	4012d43a 	srli	r9,r8,16
   20d7c:	1947c83a 	sub	r3,r3,r5
   20d80:	3909883a 	add	r4,r7,r4
   20d84:	2249883a 	add	r4,r4,r9
   20d88:	35ad383a 	mul	r22,r6,r22
   20d8c:	21c0022e 	bgeu	r4,r7,20d98 <__udivdi3+0x428>
   20d90:	01400074 	movhi	r5,1
   20d94:	b16d883a 	add	r22,r22,r5
   20d98:	200ad43a 	srli	r5,r4,16
   20d9c:	b16d883a 	add	r22,r22,r5
   20da0:	1d803e36 	bltu	r3,r22,20e9c <__udivdi3+0x52c>
   20da4:	1d803826 	beq	r3,r22,20e88 <__udivdi3+0x518>
   20da8:	0007883a 	mov	r3,zero
   20dac:	003f5606 	br	20b08 <__udivdi3+0x198>
   20db0:	80a0983a 	sll	r16,r16,r2
   20db4:	88ead83a 	srl	r21,r17,r3
   20db8:	90c6d83a 	srl	r3,r18,r3
   20dbc:	8028d43a 	srli	r20,r16,16
   20dc0:	88a2983a 	sll	r17,r17,r2
   20dc4:	a809883a 	mov	r4,r21
   20dc8:	a00b883a 	mov	r5,r20
   20dcc:	88ecb03a 	or	r22,r17,r3
   20dd0:	90a6983a 	sll	r19,r18,r2
   20dd4:	00218380 	call	21838 <__umodsi3>
   20dd8:	a809883a 	mov	r4,r21
   20ddc:	a00b883a 	mov	r5,r20
   20de0:	1023883a 	mov	r17,r2
   20de4:	00218300 	call	21830 <__udivsi3>
   20de8:	102b883a 	mov	r21,r2
   20dec:	84bfffcc 	andi	r18,r16,65535
   20df0:	8808943a 	slli	r4,r17,16
   20df4:	b004d43a 	srli	r2,r22,16
   20df8:	ac87383a 	mul	r3,r21,r18
   20dfc:	2088b03a 	or	r4,r4,r2
   20e00:	20c0062e 	bgeu	r4,r3,20e1c <__udivdi3+0x4ac>
   20e04:	2409883a 	add	r4,r4,r16
   20e08:	a8bfffc4 	addi	r2,r21,-1
   20e0c:	24004236 	bltu	r4,r16,20f18 <__udivdi3+0x5a8>
   20e10:	20c0412e 	bgeu	r4,r3,20f18 <__udivdi3+0x5a8>
   20e14:	ad7fff84 	addi	r21,r21,-2
   20e18:	2409883a 	add	r4,r4,r16
   20e1c:	20efc83a 	sub	r23,r4,r3
   20e20:	b809883a 	mov	r4,r23
   20e24:	a00b883a 	mov	r5,r20
   20e28:	00218380 	call	21838 <__umodsi3>
   20e2c:	1023883a 	mov	r17,r2
   20e30:	a00b883a 	mov	r5,r20
   20e34:	b809883a 	mov	r4,r23
   20e38:	00218300 	call	21830 <__udivsi3>
   20e3c:	8822943a 	slli	r17,r17,16
   20e40:	148b383a 	mul	r5,r2,r18
   20e44:	b5bfffcc 	andi	r22,r22,65535
   20e48:	8da2b03a 	or	r17,r17,r22
   20e4c:	8940062e 	bgeu	r17,r5,20e68 <__udivdi3+0x4f8>
   20e50:	8c23883a 	add	r17,r17,r16
   20e54:	10ffffc4 	addi	r3,r2,-1
   20e58:	8c002d36 	bltu	r17,r16,20f10 <__udivdi3+0x5a0>
   20e5c:	89402c2e 	bgeu	r17,r5,20f10 <__udivdi3+0x5a0>
   20e60:	10bfff84 	addi	r2,r2,-2
   20e64:	8c23883a 	add	r17,r17,r16
   20e68:	a806943a 	slli	r3,r21,16
   20e6c:	8963c83a 	sub	r17,r17,r5
   20e70:	10c6b03a 	or	r3,r2,r3
   20e74:	003f4906 	br	20b9c <__udivdi3+0x22c>
   20e78:	1009883a 	mov	r4,r2
   20e7c:	003f0906 	br	20aa4 <__udivdi3+0x134>
   20e80:	1009883a 	mov	r4,r2
   20e84:	003f6e06 	br	20c40 <__udivdi3+0x2d0>
   20e88:	2008943a 	slli	r4,r4,16
   20e8c:	9420983a 	sll	r16,r18,r16
   20e90:	423fffcc 	andi	r8,r8,65535
   20e94:	2209883a 	add	r4,r4,r8
   20e98:	813fc32e 	bgeu	r16,r4,20da8 <__udivdi3+0x438>
   20e9c:	10bfffc4 	addi	r2,r2,-1
   20ea0:	0007883a 	mov	r3,zero
   20ea4:	003f1806 	br	20b08 <__udivdi3+0x198>
   20ea8:	00c00604 	movi	r3,24
   20eac:	180b883a 	mov	r5,r3
   20eb0:	003f0806 	br	20ad4 <__udivdi3+0x164>
   20eb4:	00c00204 	movi	r3,8
   20eb8:	180b883a 	mov	r5,r3
   20ebc:	003f0506 	br	20ad4 <__udivdi3+0x164>
   20ec0:	00800604 	movi	r2,24
   20ec4:	1007883a 	mov	r3,r2
   20ec8:	003f2706 	br	20b68 <__udivdi3+0x1f8>
   20ecc:	00800604 	movi	r2,24
   20ed0:	1007883a 	mov	r3,r2
   20ed4:	003ebe06 	br	209d0 <__udivdi3+0x60>
   20ed8:	00800204 	movi	r2,8
   20edc:	1007883a 	mov	r3,r2
   20ee0:	003ebb06 	br	209d0 <__udivdi3+0x60>
   20ee4:	00800204 	movi	r2,8
   20ee8:	1007883a 	mov	r3,r2
   20eec:	003f1e06 	br	20b68 <__udivdi3+0x1f8>
   20ef0:	197f972e 	bgeu	r3,r5,20d50 <__udivdi3+0x3e0>
   20ef4:	213fff84 	addi	r4,r4,-2
   20ef8:	1cc7883a 	add	r3,r3,r19
   20efc:	003f9506 	br	20d54 <__udivdi3+0x3e4>
   20f00:	21bf802e 	bgeu	r4,r6,20d04 <__udivdi3+0x394>
   20f04:	ad7fff84 	addi	r21,r21,-2
   20f08:	24c9883a 	add	r4,r4,r19
   20f0c:	003f7e06 	br	20d08 <__udivdi3+0x398>
   20f10:	1805883a 	mov	r2,r3
   20f14:	003fd406 	br	20e68 <__udivdi3+0x4f8>
   20f18:	102b883a 	mov	r21,r2
   20f1c:	003fbf06 	br	20e1c <__udivdi3+0x4ac>
   20f20:	8c7fff84 	addi	r17,r17,-2
   20f24:	2409883a 	add	r4,r4,r16
   20f28:	003f3006 	br	20bec <__udivdi3+0x27c>
   20f2c:	94bfff84 	addi	r18,r18,-2
   20f30:	1c07883a 	add	r3,r3,r16
   20f34:	003ec806 	br	20a58 <__udivdi3+0xe8>

00020f38 <__umoddi3>:
   20f38:	defff504 	addi	sp,sp,-44
   20f3c:	dd000515 	stw	r20,20(sp)
   20f40:	dcc00415 	stw	r19,16(sp)
   20f44:	dc800315 	stw	r18,12(sp)
   20f48:	dc400215 	stw	r17,8(sp)
   20f4c:	dc000115 	stw	r16,4(sp)
   20f50:	dfc00a15 	stw	ra,40(sp)
   20f54:	df000915 	stw	fp,36(sp)
   20f58:	ddc00815 	stw	r23,32(sp)
   20f5c:	dd800715 	stw	r22,28(sp)
   20f60:	dd400615 	stw	r21,24(sp)
   20f64:	2025883a 	mov	r18,r4
   20f68:	2823883a 	mov	r17,r5
   20f6c:	3021883a 	mov	r16,r6
   20f70:	2027883a 	mov	r19,r4
   20f74:	2829883a 	mov	r20,r5
   20f78:	3800351e 	bne	r7,zero,21050 <__umoddi3+0x118>
   20f7c:	29804d2e 	bgeu	r5,r6,210b4 <__umoddi3+0x17c>
   20f80:	00bfffd4 	movui	r2,65535
   20f84:	11809a36 	bltu	r2,r6,211f0 <__umoddi3+0x2b8>
   20f88:	00803fc4 	movi	r2,255
   20f8c:	11813936 	bltu	r2,r6,21474 <__umoddi3+0x53c>
   20f90:	0005883a 	mov	r2,zero
   20f94:	0009883a 	mov	r4,zero
   20f98:	3084d83a 	srl	r2,r6,r2
   20f9c:	00c000f4 	movhi	r3,3
   20fa0:	18c48e04 	addi	r3,r3,4664
   20fa4:	05400804 	movi	r21,32
   20fa8:	1885883a 	add	r2,r3,r2
   20fac:	10800003 	ldbu	r2,0(r2)
   20fb0:	1109883a 	add	r4,r2,r4
   20fb4:	a92bc83a 	sub	r21,r21,r4
   20fb8:	a800ec26 	beq	r21,zero,2136c <__umoddi3+0x434>
   20fbc:	8d62983a 	sll	r17,r17,r21
   20fc0:	9108d83a 	srl	r4,r18,r4
   20fc4:	3560983a 	sll	r16,r6,r21
   20fc8:	9566983a 	sll	r19,r18,r21
   20fcc:	8928b03a 	or	r20,r17,r4
   20fd0:	8022d43a 	srli	r17,r16,16
   20fd4:	a009883a 	mov	r4,r20
   20fd8:	84bfffcc 	andi	r18,r16,65535
   20fdc:	880b883a 	mov	r5,r17
   20fe0:	00218380 	call	21838 <__umodsi3>
   20fe4:	a009883a 	mov	r4,r20
   20fe8:	880b883a 	mov	r5,r17
   20fec:	102d883a 	mov	r22,r2
   20ff0:	00218300 	call	21830 <__udivsi3>
   20ff4:	b02c943a 	slli	r22,r22,16
   20ff8:	9806d43a 	srli	r3,r19,16
   20ffc:	1485383a 	mul	r2,r2,r18
   21000:	b0c6b03a 	or	r3,r22,r3
   21004:	1880042e 	bgeu	r3,r2,21018 <__umoddi3+0xe0>
   21008:	1c07883a 	add	r3,r3,r16
   2100c:	1c000236 	bltu	r3,r16,21018 <__umoddi3+0xe0>
   21010:	1880012e 	bgeu	r3,r2,21018 <__umoddi3+0xe0>
   21014:	1c07883a 	add	r3,r3,r16
   21018:	18a9c83a 	sub	r20,r3,r2
   2101c:	a009883a 	mov	r4,r20
   21020:	880b883a 	mov	r5,r17
   21024:	00218380 	call	21838 <__umodsi3>
   21028:	102d883a 	mov	r22,r2
   2102c:	a009883a 	mov	r4,r20
   21030:	880b883a 	mov	r5,r17
   21034:	00218300 	call	21830 <__udivsi3>
   21038:	b02c943a 	slli	r22,r22,16
   2103c:	1485383a 	mul	r2,r2,r18
   21040:	9cffffcc 	andi	r19,r19,65535
   21044:	b4e6b03a 	or	r19,r22,r19
   21048:	9880522e 	bgeu	r19,r2,21194 <__umoddi3+0x25c>
   2104c:	00004d06 	br	21184 <__umoddi3+0x24c>
   21050:	29c05436 	bltu	r5,r7,211a4 <__umoddi3+0x26c>
   21054:	00bfffd4 	movui	r2,65535
   21058:	11c0602e 	bgeu	r2,r7,211dc <__umoddi3+0x2a4>
   2105c:	00804034 	movhi	r2,256
   21060:	10bfffc4 	addi	r2,r2,-1
   21064:	11c0f736 	bltu	r2,r7,21444 <__umoddi3+0x50c>
   21068:	00c00404 	movi	r3,16
   2106c:	1827883a 	mov	r19,r3
   21070:	38c6d83a 	srl	r3,r7,r3
   21074:	010000f4 	movhi	r4,3
   21078:	21048e04 	addi	r4,r4,4664
   2107c:	04000804 	movi	r16,32
   21080:	20c7883a 	add	r3,r4,r3
   21084:	18800003 	ldbu	r2,0(r3)
   21088:	14e7883a 	add	r19,r2,r19
   2108c:	84e1c83a 	sub	r16,r16,r19
   21090:	8000621e 	bne	r16,zero,2121c <__umoddi3+0x2e4>
   21094:	3c400136 	bltu	r7,r17,2109c <__umoddi3+0x164>
   21098:	91810336 	bltu	r18,r6,214a8 <__umoddi3+0x570>
   2109c:	9185c83a 	sub	r2,r18,r6
   210a0:	89e3c83a 	sub	r17,r17,r7
   210a4:	90a5803a 	cmpltu	r18,r18,r2
   210a8:	8ca9c83a 	sub	r20,r17,r18
   210ac:	a007883a 	mov	r3,r20
   210b0:	00003e06 	br	211ac <__umoddi3+0x274>
   210b4:	3000041e 	bne	r6,zero,210c8 <__umoddi3+0x190>
   210b8:	01000044 	movi	r4,1
   210bc:	000b883a 	mov	r5,zero
   210c0:	00218300 	call	21830 <__udivsi3>
   210c4:	1021883a 	mov	r16,r2
   210c8:	00bfffd4 	movui	r2,65535
   210cc:	14004e2e 	bgeu	r2,r16,21208 <__umoddi3+0x2d0>
   210d0:	00804034 	movhi	r2,256
   210d4:	10bfffc4 	addi	r2,r2,-1
   210d8:	1400e336 	bltu	r2,r16,21468 <__umoddi3+0x530>
   210dc:	00800404 	movi	r2,16
   210e0:	1007883a 	mov	r3,r2
   210e4:	8084d83a 	srl	r2,r16,r2
   210e8:	010000f4 	movhi	r4,3
   210ec:	21048e04 	addi	r4,r4,4664
   210f0:	05400804 	movi	r21,32
   210f4:	2085883a 	add	r2,r4,r2
   210f8:	10800003 	ldbu	r2,0(r2)
   210fc:	10c7883a 	add	r3,r2,r3
   21100:	a8ebc83a 	sub	r21,r21,r3
   21104:	a8009b1e 	bne	r21,zero,21374 <__umoddi3+0x43c>
   21108:	8028d43a 	srli	r20,r16,16
   2110c:	8c23c83a 	sub	r17,r17,r16
   21110:	85bfffcc 	andi	r22,r16,65535
   21114:	8809883a 	mov	r4,r17
   21118:	a00b883a 	mov	r5,r20
   2111c:	00218380 	call	21838 <__umodsi3>
   21120:	8809883a 	mov	r4,r17
   21124:	a00b883a 	mov	r5,r20
   21128:	1025883a 	mov	r18,r2
   2112c:	00218300 	call	21830 <__udivsi3>
   21130:	9024943a 	slli	r18,r18,16
   21134:	9806d43a 	srli	r3,r19,16
   21138:	1585383a 	mul	r2,r2,r22
   2113c:	90c6b03a 	or	r3,r18,r3
   21140:	1880032e 	bgeu	r3,r2,21150 <__umoddi3+0x218>
   21144:	1c07883a 	add	r3,r3,r16
   21148:	1c000136 	bltu	r3,r16,21150 <__umoddi3+0x218>
   2114c:	1880d436 	bltu	r3,r2,214a0 <__umoddi3+0x568>
   21150:	18a3c83a 	sub	r17,r3,r2
   21154:	8809883a 	mov	r4,r17
   21158:	a00b883a 	mov	r5,r20
   2115c:	00218380 	call	21838 <__umodsi3>
   21160:	1025883a 	mov	r18,r2
   21164:	8809883a 	mov	r4,r17
   21168:	a00b883a 	mov	r5,r20
   2116c:	00218300 	call	21830 <__udivsi3>
   21170:	9024943a 	slli	r18,r18,16
   21174:	1585383a 	mul	r2,r2,r22
   21178:	9cffffcc 	andi	r19,r19,65535
   2117c:	94e6b03a 	or	r19,r18,r19
   21180:	9880042e 	bgeu	r19,r2,21194 <__umoddi3+0x25c>
   21184:	9c27883a 	add	r19,r19,r16
   21188:	9c000236 	bltu	r19,r16,21194 <__umoddi3+0x25c>
   2118c:	9880012e 	bgeu	r19,r2,21194 <__umoddi3+0x25c>
   21190:	9c27883a 	add	r19,r19,r16
   21194:	98a7c83a 	sub	r19,r19,r2
   21198:	9d44d83a 	srl	r2,r19,r21
   2119c:	0007883a 	mov	r3,zero
   211a0:	00000206 	br	211ac <__umoddi3+0x274>
   211a4:	2005883a 	mov	r2,r4
   211a8:	2807883a 	mov	r3,r5
   211ac:	dfc00a17 	ldw	ra,40(sp)
   211b0:	df000917 	ldw	fp,36(sp)
   211b4:	ddc00817 	ldw	r23,32(sp)
   211b8:	dd800717 	ldw	r22,28(sp)
   211bc:	dd400617 	ldw	r21,24(sp)
   211c0:	dd000517 	ldw	r20,20(sp)
   211c4:	dcc00417 	ldw	r19,16(sp)
   211c8:	dc800317 	ldw	r18,12(sp)
   211cc:	dc400217 	ldw	r17,8(sp)
   211d0:	dc000117 	ldw	r16,4(sp)
   211d4:	dec00b04 	addi	sp,sp,44
   211d8:	f800283a 	ret
   211dc:	00803fc4 	movi	r2,255
   211e0:	11c09536 	bltu	r2,r7,21438 <__umoddi3+0x500>
   211e4:	0007883a 	mov	r3,zero
   211e8:	0027883a 	mov	r19,zero
   211ec:	003fa006 	br	21070 <__umoddi3+0x138>
   211f0:	00804034 	movhi	r2,256
   211f4:	10bfffc4 	addi	r2,r2,-1
   211f8:	11809536 	bltu	r2,r6,21450 <__umoddi3+0x518>
   211fc:	00800404 	movi	r2,16
   21200:	1009883a 	mov	r4,r2
   21204:	003f6406 	br	20f98 <__umoddi3+0x60>
   21208:	00803fc4 	movi	r2,255
   2120c:	14009336 	bltu	r2,r16,2145c <__umoddi3+0x524>
   21210:	0005883a 	mov	r2,zero
   21214:	0007883a 	mov	r3,zero
   21218:	003fb206 	br	210e4 <__umoddi3+0x1ac>
   2121c:	34c4d83a 	srl	r2,r6,r19
   21220:	3c0e983a 	sll	r7,r7,r16
   21224:	8ceed83a 	srl	r23,r17,r19
   21228:	8c22983a 	sll	r17,r17,r16
   2122c:	38a8b03a 	or	r20,r7,r2
   21230:	a02ad43a 	srli	r21,r20,16
   21234:	94c4d83a 	srl	r2,r18,r19
   21238:	b809883a 	mov	r4,r23
   2123c:	a80b883a 	mov	r5,r21
   21240:	88a2b03a 	or	r17,r17,r2
   21244:	342c983a 	sll	r22,r6,r16
   21248:	00218380 	call	21838 <__umodsi3>
   2124c:	b809883a 	mov	r4,r23
   21250:	a80b883a 	mov	r5,r21
   21254:	d8800015 	stw	r2,0(sp)
   21258:	00218300 	call	21830 <__udivsi3>
   2125c:	d8c00017 	ldw	r3,0(sp)
   21260:	102f883a 	mov	r23,r2
   21264:	a73fffcc 	andi	fp,r20,65535
   21268:	180a943a 	slli	r5,r3,16
   2126c:	8804d43a 	srli	r2,r17,16
   21270:	bf09383a 	mul	r4,r23,fp
   21274:	9424983a 	sll	r18,r18,r16
   21278:	288ab03a 	or	r5,r5,r2
   2127c:	2900042e 	bgeu	r5,r4,21290 <__umoddi3+0x358>
   21280:	2d0b883a 	add	r5,r5,r20
   21284:	b8bfffc4 	addi	r2,r23,-1
   21288:	2d00812e 	bgeu	r5,r20,21490 <__umoddi3+0x558>
   2128c:	102f883a 	mov	r23,r2
   21290:	2907c83a 	sub	r3,r5,r4
   21294:	1809883a 	mov	r4,r3
   21298:	a80b883a 	mov	r5,r21
   2129c:	d8c00015 	stw	r3,0(sp)
   212a0:	00218380 	call	21838 <__umodsi3>
   212a4:	d8c00017 	ldw	r3,0(sp)
   212a8:	a80b883a 	mov	r5,r21
   212ac:	d8800015 	stw	r2,0(sp)
   212b0:	1809883a 	mov	r4,r3
   212b4:	00218300 	call	21830 <__udivsi3>
   212b8:	d9800017 	ldw	r6,0(sp)
   212bc:	8c7fffcc 	andi	r17,r17,65535
   212c0:	3008943a 	slli	r4,r6,16
   212c4:	170d383a 	mul	r6,r2,fp
   212c8:	2448b03a 	or	r4,r4,r17
   212cc:	2180042e 	bgeu	r4,r6,212e0 <__umoddi3+0x3a8>
   212d0:	2509883a 	add	r4,r4,r20
   212d4:	10ffffc4 	addi	r3,r2,-1
   212d8:	2500692e 	bgeu	r4,r20,21480 <__umoddi3+0x548>
   212dc:	1805883a 	mov	r2,r3
   212e0:	b82e943a 	slli	r23,r23,16
   212e4:	b010d43a 	srli	r8,r22,16
   212e8:	b1ffffcc 	andi	r7,r22,65535
   212ec:	15eeb03a 	or	r23,r2,r23
   212f0:	b8bfffcc 	andi	r2,r23,65535
   212f4:	b82ed43a 	srli	r23,r23,16
   212f8:	11c7383a 	mul	r3,r2,r7
   212fc:	1205383a 	mul	r2,r2,r8
   21300:	b9cf383a 	mul	r7,r23,r7
   21304:	400b883a 	mov	r5,r8
   21308:	1810d43a 	srli	r8,r3,16
   2130c:	3885883a 	add	r2,r7,r2
   21310:	2189c83a 	sub	r4,r4,r6
   21314:	1205883a 	add	r2,r2,r8
   21318:	b94b383a 	mul	r5,r23,r5
   2131c:	11c0022e 	bgeu	r2,r7,21328 <__umoddi3+0x3f0>
   21320:	01800074 	movhi	r6,1
   21324:	298b883a 	add	r5,r5,r6
   21328:	100cd43a 	srli	r6,r2,16
   2132c:	1004943a 	slli	r2,r2,16
   21330:	18ffffcc 	andi	r3,r3,65535
   21334:	298b883a 	add	r5,r5,r6
   21338:	10c5883a 	add	r2,r2,r3
   2133c:	21403836 	bltu	r4,r5,21420 <__umoddi3+0x4e8>
   21340:	21405c26 	beq	r4,r5,214b4 <__umoddi3+0x57c>
   21344:	2147c83a 	sub	r3,r4,r5
   21348:	102d883a 	mov	r22,r2
   2134c:	95adc83a 	sub	r22,r18,r22
   21350:	95a5803a 	cmpltu	r18,r18,r22
   21354:	1c87c83a 	sub	r3,r3,r18
   21358:	1cc4983a 	sll	r2,r3,r19
   2135c:	b42cd83a 	srl	r22,r22,r16
   21360:	1c06d83a 	srl	r3,r3,r16
   21364:	1584b03a 	or	r2,r2,r22
   21368:	003f9006 	br	211ac <__umoddi3+0x274>
   2136c:	002b883a 	mov	r21,zero
   21370:	003f1706 	br	20fd0 <__umoddi3+0x98>
   21374:	8560983a 	sll	r16,r16,r21
   21378:	88e6d83a 	srl	r19,r17,r3
   2137c:	90c6d83a 	srl	r3,r18,r3
   21380:	8028d43a 	srli	r20,r16,16
   21384:	8d62983a 	sll	r17,r17,r21
   21388:	9809883a 	mov	r4,r19
   2138c:	a00b883a 	mov	r5,r20
   21390:	88eeb03a 	or	r23,r17,r3
   21394:	00218380 	call	21838 <__umodsi3>
   21398:	9809883a 	mov	r4,r19
   2139c:	a00b883a 	mov	r5,r20
   213a0:	1023883a 	mov	r17,r2
   213a4:	00218300 	call	21830 <__udivsi3>
   213a8:	85bfffcc 	andi	r22,r16,65535
   213ac:	880a943a 	slli	r5,r17,16
   213b0:	b806d43a 	srli	r3,r23,16
   213b4:	1585383a 	mul	r2,r2,r22
   213b8:	9566983a 	sll	r19,r18,r21
   213bc:	28cab03a 	or	r5,r5,r3
   213c0:	2880042e 	bgeu	r5,r2,213d4 <__umoddi3+0x49c>
   213c4:	2c0b883a 	add	r5,r5,r16
   213c8:	2c000236 	bltu	r5,r16,213d4 <__umoddi3+0x49c>
   213cc:	2880012e 	bgeu	r5,r2,213d4 <__umoddi3+0x49c>
   213d0:	2c0b883a 	add	r5,r5,r16
   213d4:	28a5c83a 	sub	r18,r5,r2
   213d8:	9009883a 	mov	r4,r18
   213dc:	a00b883a 	mov	r5,r20
   213e0:	00218380 	call	21838 <__umodsi3>
   213e4:	1023883a 	mov	r17,r2
   213e8:	9009883a 	mov	r4,r18
   213ec:	a00b883a 	mov	r5,r20
   213f0:	00218300 	call	21830 <__udivsi3>
   213f4:	8822943a 	slli	r17,r17,16
   213f8:	1585383a 	mul	r2,r2,r22
   213fc:	bdffffcc 	andi	r23,r23,65535
   21400:	8de2b03a 	or	r17,r17,r23
   21404:	8880042e 	bgeu	r17,r2,21418 <__umoddi3+0x4e0>
   21408:	8c23883a 	add	r17,r17,r16
   2140c:	8c000236 	bltu	r17,r16,21418 <__umoddi3+0x4e0>
   21410:	8880012e 	bgeu	r17,r2,21418 <__umoddi3+0x4e0>
   21414:	8c23883a 	add	r17,r17,r16
   21418:	88a3c83a 	sub	r17,r17,r2
   2141c:	003f3d06 	br	21114 <__umoddi3+0x1dc>
   21420:	15adc83a 	sub	r22,r2,r22
   21424:	2d07c83a 	sub	r3,r5,r20
   21428:	1585803a 	cmpltu	r2,r2,r22
   2142c:	1887c83a 	sub	r3,r3,r2
   21430:	20c7c83a 	sub	r3,r4,r3
   21434:	003fc506 	br	2134c <__umoddi3+0x414>
   21438:	00c00204 	movi	r3,8
   2143c:	1827883a 	mov	r19,r3
   21440:	003f0b06 	br	21070 <__umoddi3+0x138>
   21444:	00c00604 	movi	r3,24
   21448:	1827883a 	mov	r19,r3
   2144c:	003f0806 	br	21070 <__umoddi3+0x138>
   21450:	00800604 	movi	r2,24
   21454:	1009883a 	mov	r4,r2
   21458:	003ecf06 	br	20f98 <__umoddi3+0x60>
   2145c:	00800204 	movi	r2,8
   21460:	1007883a 	mov	r3,r2
   21464:	003f1f06 	br	210e4 <__umoddi3+0x1ac>
   21468:	00800604 	movi	r2,24
   2146c:	1007883a 	mov	r3,r2
   21470:	003f1c06 	br	210e4 <__umoddi3+0x1ac>
   21474:	00800204 	movi	r2,8
   21478:	1009883a 	mov	r4,r2
   2147c:	003ec606 	br	20f98 <__umoddi3+0x60>
   21480:	21bf962e 	bgeu	r4,r6,212dc <__umoddi3+0x3a4>
   21484:	10bfff84 	addi	r2,r2,-2
   21488:	2509883a 	add	r4,r4,r20
   2148c:	003f9406 	br	212e0 <__umoddi3+0x3a8>
   21490:	293f7e2e 	bgeu	r5,r4,2128c <__umoddi3+0x354>
   21494:	bdffff84 	addi	r23,r23,-2
   21498:	2d0b883a 	add	r5,r5,r20
   2149c:	003f7c06 	br	21290 <__umoddi3+0x358>
   214a0:	1c07883a 	add	r3,r3,r16
   214a4:	003f2a06 	br	21150 <__umoddi3+0x218>
   214a8:	9005883a 	mov	r2,r18
   214ac:	a007883a 	mov	r3,r20
   214b0:	003f3e06 	br	211ac <__umoddi3+0x274>
   214b4:	90bfda36 	bltu	r18,r2,21420 <__umoddi3+0x4e8>
   214b8:	102d883a 	mov	r22,r2
   214bc:	0007883a 	mov	r3,zero
   214c0:	003fa206 	br	2134c <__umoddi3+0x414>

000214c4 <__eqdf2>:
   214c4:	defff104 	addi	sp,sp,-60
   214c8:	d9000c15 	stw	r4,48(sp)
   214cc:	d9400d15 	stw	r5,52(sp)
   214d0:	d9000c04 	addi	r4,sp,48
   214d4:	d9400504 	addi	r5,sp,20
   214d8:	dfc00e15 	stw	ra,56(sp)
   214dc:	d9800a15 	stw	r6,40(sp)
   214e0:	d9c00b15 	stw	r7,44(sp)
   214e4:	0018f180 	call	18f18 <__unpack_d>
   214e8:	d9000a04 	addi	r4,sp,40
   214ec:	d80b883a 	mov	r5,sp
   214f0:	0018f180 	call	18f18 <__unpack_d>
   214f4:	d8c00517 	ldw	r3,20(sp)
   214f8:	00800044 	movi	r2,1
   214fc:	10c0052e 	bgeu	r2,r3,21514 <__eqdf2+0x50>
   21500:	d8c00017 	ldw	r3,0(sp)
   21504:	10c0032e 	bgeu	r2,r3,21514 <__eqdf2+0x50>
   21508:	d9000504 	addi	r4,sp,20
   2150c:	d80b883a 	mov	r5,sp
   21510:	001901c0 	call	1901c <__fpcmp_parts_d>
   21514:	dfc00e17 	ldw	ra,56(sp)
   21518:	dec00f04 	addi	sp,sp,60
   2151c:	f800283a 	ret

00021520 <__nedf2>:
   21520:	defff104 	addi	sp,sp,-60
   21524:	d9000c15 	stw	r4,48(sp)
   21528:	d9400d15 	stw	r5,52(sp)
   2152c:	d9000c04 	addi	r4,sp,48
   21530:	d9400504 	addi	r5,sp,20
   21534:	dfc00e15 	stw	ra,56(sp)
   21538:	d9800a15 	stw	r6,40(sp)
   2153c:	d9c00b15 	stw	r7,44(sp)
   21540:	0018f180 	call	18f18 <__unpack_d>
   21544:	d9000a04 	addi	r4,sp,40
   21548:	d80b883a 	mov	r5,sp
   2154c:	0018f180 	call	18f18 <__unpack_d>
   21550:	d8c00517 	ldw	r3,20(sp)
   21554:	00800044 	movi	r2,1
   21558:	10c0052e 	bgeu	r2,r3,21570 <__nedf2+0x50>
   2155c:	d8c00017 	ldw	r3,0(sp)
   21560:	10c0032e 	bgeu	r2,r3,21570 <__nedf2+0x50>
   21564:	d9000504 	addi	r4,sp,20
   21568:	d80b883a 	mov	r5,sp
   2156c:	001901c0 	call	1901c <__fpcmp_parts_d>
   21570:	dfc00e17 	ldw	ra,56(sp)
   21574:	dec00f04 	addi	sp,sp,60
   21578:	f800283a 	ret

0002157c <__gtdf2>:
   2157c:	defff104 	addi	sp,sp,-60
   21580:	d9000c15 	stw	r4,48(sp)
   21584:	d9400d15 	stw	r5,52(sp)
   21588:	d9000c04 	addi	r4,sp,48
   2158c:	d9400504 	addi	r5,sp,20
   21590:	dfc00e15 	stw	ra,56(sp)
   21594:	d9800a15 	stw	r6,40(sp)
   21598:	d9c00b15 	stw	r7,44(sp)
   2159c:	0018f180 	call	18f18 <__unpack_d>
   215a0:	d9000a04 	addi	r4,sp,40
   215a4:	d80b883a 	mov	r5,sp
   215a8:	0018f180 	call	18f18 <__unpack_d>
   215ac:	d8c00517 	ldw	r3,20(sp)
   215b0:	00800044 	movi	r2,1
   215b4:	10c0082e 	bgeu	r2,r3,215d8 <__gtdf2+0x5c>
   215b8:	d8c00017 	ldw	r3,0(sp)
   215bc:	10c0062e 	bgeu	r2,r3,215d8 <__gtdf2+0x5c>
   215c0:	d9000504 	addi	r4,sp,20
   215c4:	d80b883a 	mov	r5,sp
   215c8:	001901c0 	call	1901c <__fpcmp_parts_d>
   215cc:	dfc00e17 	ldw	ra,56(sp)
   215d0:	dec00f04 	addi	sp,sp,60
   215d4:	f800283a 	ret
   215d8:	00bfffc4 	movi	r2,-1
   215dc:	003ffb06 	br	215cc <__gtdf2+0x50>

000215e0 <__ltdf2>:
   215e0:	defff104 	addi	sp,sp,-60
   215e4:	d9000c15 	stw	r4,48(sp)
   215e8:	d9400d15 	stw	r5,52(sp)
   215ec:	d9000c04 	addi	r4,sp,48
   215f0:	d9400504 	addi	r5,sp,20
   215f4:	dfc00e15 	stw	ra,56(sp)
   215f8:	d9800a15 	stw	r6,40(sp)
   215fc:	d9c00b15 	stw	r7,44(sp)
   21600:	0018f180 	call	18f18 <__unpack_d>
   21604:	d9000a04 	addi	r4,sp,40
   21608:	d80b883a 	mov	r5,sp
   2160c:	0018f180 	call	18f18 <__unpack_d>
   21610:	d8c00517 	ldw	r3,20(sp)
   21614:	00800044 	movi	r2,1
   21618:	10c0052e 	bgeu	r2,r3,21630 <__ltdf2+0x50>
   2161c:	d8c00017 	ldw	r3,0(sp)
   21620:	10c0032e 	bgeu	r2,r3,21630 <__ltdf2+0x50>
   21624:	d9000504 	addi	r4,sp,20
   21628:	d80b883a 	mov	r5,sp
   2162c:	001901c0 	call	1901c <__fpcmp_parts_d>
   21630:	dfc00e17 	ldw	ra,56(sp)
   21634:	dec00f04 	addi	sp,sp,60
   21638:	f800283a 	ret

0002163c <__floatsidf>:
   2163c:	2004d7fa 	srli	r2,r4,31
   21640:	defff904 	addi	sp,sp,-28
   21644:	00c000c4 	movi	r3,3
   21648:	dfc00615 	stw	ra,24(sp)
   2164c:	dc000515 	stw	r16,20(sp)
   21650:	d8c00015 	stw	r3,0(sp)
   21654:	d8800115 	stw	r2,4(sp)
   21658:	2000081e 	bne	r4,zero,2167c <__floatsidf+0x40>
   2165c:	00800084 	movi	r2,2
   21660:	d8800015 	stw	r2,0(sp)
   21664:	d809883a 	mov	r4,sp
   21668:	0018cf40 	call	18cf4 <__pack_d>
   2166c:	dfc00617 	ldw	ra,24(sp)
   21670:	dc000517 	ldw	r16,20(sp)
   21674:	dec00704 	addi	sp,sp,28
   21678:	f800283a 	ret
   2167c:	00c00f04 	movi	r3,60
   21680:	d8c00215 	stw	r3,8(sp)
   21684:	10000f1e 	bne	r2,zero,216c4 <__floatsidf+0x88>
   21688:	2021883a 	mov	r16,r4
   2168c:	8009883a 	mov	r4,r16
   21690:	0018c480 	call	18c48 <__clzsi2>
   21694:	11000744 	addi	r4,r2,29
   21698:	0100110e 	bge	zero,r4,216e0 <__floatsidf+0xa4>
   2169c:	10ffff44 	addi	r3,r2,-3
   216a0:	18001216 	blt	r3,zero,216ec <__floatsidf+0xb0>
   216a4:	80c6983a 	sll	r3,r16,r3
   216a8:	0009883a 	mov	r4,zero
   216ac:	014007c4 	movi	r5,31
   216b0:	2885c83a 	sub	r2,r5,r2
   216b4:	d9000315 	stw	r4,12(sp)
   216b8:	d8c00415 	stw	r3,16(sp)
   216bc:	d8800215 	stw	r2,8(sp)
   216c0:	003fe806 	br	21664 <__floatsidf+0x28>
   216c4:	00a00034 	movhi	r2,32768
   216c8:	20800e26 	beq	r4,r2,21704 <__floatsidf+0xc8>
   216cc:	0121c83a 	sub	r16,zero,r4
   216d0:	8009883a 	mov	r4,r16
   216d4:	0018c480 	call	18c48 <__clzsi2>
   216d8:	11000744 	addi	r4,r2,29
   216dc:	013fef16 	blt	zero,r4,2169c <__floatsidf+0x60>
   216e0:	dc000315 	stw	r16,12(sp)
   216e4:	d8000415 	stw	zero,16(sp)
   216e8:	003fde06 	br	21664 <__floatsidf+0x28>
   216ec:	800ad07a 	srli	r5,r16,1
   216f0:	00c007c4 	movi	r3,31
   216f4:	1907c83a 	sub	r3,r3,r4
   216f8:	28c6d83a 	srl	r3,r5,r3
   216fc:	8108983a 	sll	r4,r16,r4
   21700:	003fea06 	br	216ac <__floatsidf+0x70>
   21704:	0005883a 	mov	r2,zero
   21708:	00f07834 	movhi	r3,49632
   2170c:	003fd706 	br	2166c <__floatsidf+0x30>

00021710 <udivmodsi4>:
   21710:	2005883a 	mov	r2,r4
   21714:	2900182e 	bgeu	r5,r4,21778 <udivmodsi4+0x68>
   21718:	28001716 	blt	r5,zero,21778 <udivmodsi4+0x68>
   2171c:	01000804 	movi	r4,32
   21720:	00c00044 	movi	r3,1
   21724:	00000206 	br	21730 <udivmodsi4+0x20>
   21728:	20001126 	beq	r4,zero,21770 <udivmodsi4+0x60>
   2172c:	28000516 	blt	r5,zero,21744 <udivmodsi4+0x34>
   21730:	294b883a 	add	r5,r5,r5
   21734:	213fffc4 	addi	r4,r4,-1
   21738:	18c7883a 	add	r3,r3,r3
   2173c:	28bffa36 	bltu	r5,r2,21728 <udivmodsi4+0x18>
   21740:	18000b26 	beq	r3,zero,21770 <udivmodsi4+0x60>
   21744:	0009883a 	mov	r4,zero
   21748:	11400236 	bltu	r2,r5,21754 <udivmodsi4+0x44>
   2174c:	1145c83a 	sub	r2,r2,r5
   21750:	20c8b03a 	or	r4,r4,r3
   21754:	1806d07a 	srli	r3,r3,1
   21758:	280ad07a 	srli	r5,r5,1
   2175c:	183ffa1e 	bne	r3,zero,21748 <udivmodsi4+0x38>
   21760:	3000021e 	bne	r6,zero,2176c <udivmodsi4+0x5c>
   21764:	2005883a 	mov	r2,r4
   21768:	f800283a 	ret
   2176c:	f800283a 	ret
   21770:	0009883a 	mov	r4,zero
   21774:	003ffa06 	br	21760 <udivmodsi4+0x50>
   21778:	00c00044 	movi	r3,1
   2177c:	0009883a 	mov	r4,zero
   21780:	003ff106 	br	21748 <udivmodsi4+0x38>

00021784 <__divsi3>:
   21784:	defffe04 	addi	sp,sp,-8
   21788:	dfc00115 	stw	ra,4(sp)
   2178c:	dc000015 	stw	r16,0(sp)
   21790:	20000a16 	blt	r4,zero,217bc <__divsi3+0x38>
   21794:	0021883a 	mov	r16,zero
   21798:	28000b16 	blt	r5,zero,217c8 <__divsi3+0x44>
   2179c:	000d883a 	mov	r6,zero
   217a0:	00217100 	call	21710 <udivmodsi4>
   217a4:	80000126 	beq	r16,zero,217ac <__divsi3+0x28>
   217a8:	0085c83a 	sub	r2,zero,r2
   217ac:	dfc00117 	ldw	ra,4(sp)
   217b0:	dc000017 	ldw	r16,0(sp)
   217b4:	dec00204 	addi	sp,sp,8
   217b8:	f800283a 	ret
   217bc:	0109c83a 	sub	r4,zero,r4
   217c0:	04000044 	movi	r16,1
   217c4:	283ff50e 	bge	r5,zero,2179c <__divsi3+0x18>
   217c8:	014bc83a 	sub	r5,zero,r5
   217cc:	8400005c 	xori	r16,r16,1
   217d0:	003ff206 	br	2179c <__divsi3+0x18>

000217d4 <__modsi3>:
   217d4:	deffff04 	addi	sp,sp,-4
   217d8:	dfc00015 	stw	ra,0(sp)
   217dc:	20000516 	blt	r4,zero,217f4 <__modsi3+0x20>
   217e0:	28000c16 	blt	r5,zero,21814 <__modsi3+0x40>
   217e4:	01800044 	movi	r6,1
   217e8:	dfc00017 	ldw	ra,0(sp)
   217ec:	dec00104 	addi	sp,sp,4
   217f0:	00217101 	jmpi	21710 <udivmodsi4>
   217f4:	0109c83a 	sub	r4,zero,r4
   217f8:	28000b16 	blt	r5,zero,21828 <__modsi3+0x54>
   217fc:	01800044 	movi	r6,1
   21800:	00217100 	call	21710 <udivmodsi4>
   21804:	0085c83a 	sub	r2,zero,r2
   21808:	dfc00017 	ldw	ra,0(sp)
   2180c:	dec00104 	addi	sp,sp,4
   21810:	f800283a 	ret
   21814:	014bc83a 	sub	r5,zero,r5
   21818:	01800044 	movi	r6,1
   2181c:	dfc00017 	ldw	ra,0(sp)
   21820:	dec00104 	addi	sp,sp,4
   21824:	00217101 	jmpi	21710 <udivmodsi4>
   21828:	014bc83a 	sub	r5,zero,r5
   2182c:	003ff306 	br	217fc <__modsi3+0x28>

00021830 <__udivsi3>:
   21830:	000d883a 	mov	r6,zero
   21834:	00217101 	jmpi	21710 <udivmodsi4>

00021838 <__umodsi3>:
   21838:	01800044 	movi	r6,1
   2183c:	00217101 	jmpi	21710 <udivmodsi4>

00021840 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
   21840:	defff404 	addi	sp,sp,-48
   21844:	df000b15 	stw	fp,44(sp)
   21848:	df000b04 	addi	fp,sp,44
   2184c:	e13ffc15 	stw	r4,-16(fp)
   21850:	e17ffd15 	stw	r5,-12(fp)
   21854:	e1bffe15 	stw	r6,-8(fp)
   21858:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
   2185c:	e03ff515 	stw	zero,-44(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
   21860:	008000f4 	movhi	r2,3
   21864:	109e4d04 	addi	r2,r2,31028
   21868:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
   2186c:	10004a26 	beq	r2,zero,21998 <alt_alarm_start+0x158>
  {
    if (alarm)
   21870:	e0bffc17 	ldw	r2,-16(fp)
   21874:	10004626 	beq	r2,zero,21990 <alt_alarm_start+0x150>
    {
      alarm->callback = callback;
   21878:	e0bffc17 	ldw	r2,-16(fp)
   2187c:	e0fffe17 	ldw	r3,-8(fp)
   21880:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
   21884:	e0bffc17 	ldw	r2,-16(fp)
   21888:	e0ffff17 	ldw	r3,-4(fp)
   2188c:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   21890:	0005303a 	rdctl	r2,status
   21894:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   21898:	e0fff717 	ldw	r3,-36(fp)
   2189c:	00bfff84 	movi	r2,-2
   218a0:	1884703a 	and	r2,r3,r2
   218a4:	1001703a 	wrctl	status,r2
  
  return context;
   218a8:	e0bff717 	ldw	r2,-36(fp)
 
      irq_context = alt_irq_disable_all ();
   218ac:	e0bff615 	stw	r2,-40(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
   218b0:	008000f4 	movhi	r2,3
   218b4:	109e4e04 	addi	r2,r2,31032
   218b8:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
   218bc:	e0bff515 	stw	r2,-44(fp)
      
      alarm->time = nticks + current_nticks + 1; 
   218c0:	e0fffd17 	ldw	r3,-12(fp)
   218c4:	e0bff517 	ldw	r2,-44(fp)
   218c8:	1885883a 	add	r2,r3,r2
   218cc:	10c00044 	addi	r3,r2,1
   218d0:	e0bffc17 	ldw	r2,-16(fp)
   218d4:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
   218d8:	e0bffc17 	ldw	r2,-16(fp)
   218dc:	10c00217 	ldw	r3,8(r2)
   218e0:	e0bff517 	ldw	r2,-44(fp)
   218e4:	1880042e 	bgeu	r3,r2,218f8 <alt_alarm_start+0xb8>
      {
        alarm->rollover = 1;
   218e8:	e0bffc17 	ldw	r2,-16(fp)
   218ec:	00c00044 	movi	r3,1
   218f0:	10c00405 	stb	r3,16(r2)
   218f4:	00000206 	br	21900 <alt_alarm_start+0xc0>
      }
      else
      {
        alarm->rollover = 0;
   218f8:	e0bffc17 	ldw	r2,-16(fp)
   218fc:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
   21900:	e0bffc17 	ldw	r2,-16(fp)
   21904:	00c000f4 	movhi	r3,3
   21908:	18d58a04 	addi	r3,r3,22056
   2190c:	e0fff815 	stw	r3,-32(fp)
   21910:	e0bff915 	stw	r2,-28(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
   21914:	e0bff917 	ldw	r2,-28(fp)
   21918:	e0fff817 	ldw	r3,-32(fp)
   2191c:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
   21920:	e0bff817 	ldw	r2,-32(fp)
   21924:	10c00017 	ldw	r3,0(r2)
   21928:	e0bff917 	ldw	r2,-28(fp)
   2192c:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
   21930:	e0bff817 	ldw	r2,-32(fp)
   21934:	10800017 	ldw	r2,0(r2)
   21938:	e0fff917 	ldw	r3,-28(fp)
   2193c:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
   21940:	e0bff817 	ldw	r2,-32(fp)
   21944:	e0fff917 	ldw	r3,-28(fp)
   21948:	10c00015 	stw	r3,0(r2)
   2194c:	e0bff617 	ldw	r2,-40(fp)
   21950:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   21954:	0005303a 	rdctl	r2,status
   21958:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   2195c:	e0fffb17 	ldw	r3,-20(fp)
   21960:	00bfff84 	movi	r2,-2
   21964:	1884703a 	and	r2,r3,r2
   21968:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   2196c:	e0bffa17 	ldw	r2,-24(fp)
   21970:	1080004c 	andi	r2,r2,1
   21974:	e0fffb17 	ldw	r3,-20(fp)
   21978:	1884b03a 	or	r2,r3,r2
   2197c:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
   21980:	e0bffb17 	ldw	r2,-20(fp)
   21984:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
   21988:	0005883a 	mov	r2,zero
   2198c:	00000306 	br	2199c <alt_alarm_start+0x15c>
    }
    else
    {
      return -EINVAL;
   21990:	00bffa84 	movi	r2,-22
   21994:	00000106 	br	2199c <alt_alarm_start+0x15c>
    }
  }
  else
  {
    return -ENOTSUP;
   21998:	00bfde84 	movi	r2,-134
  }
}
   2199c:	e037883a 	mov	sp,fp
   219a0:	df000017 	ldw	fp,0(sp)
   219a4:	dec00104 	addi	sp,sp,4
   219a8:	f800283a 	ret

000219ac <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   219ac:	defffe04 	addi	sp,sp,-8
   219b0:	dfc00115 	stw	ra,4(sp)
   219b4:	df000015 	stw	fp,0(sp)
   219b8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   219bc:	008000f4 	movhi	r2,3
   219c0:	10958804 	addi	r2,r2,22048
   219c4:	10800017 	ldw	r2,0(r2)
   219c8:	10000526 	beq	r2,zero,219e0 <alt_get_errno+0x34>
   219cc:	008000f4 	movhi	r2,3
   219d0:	10958804 	addi	r2,r2,22048
   219d4:	10800017 	ldw	r2,0(r2)
   219d8:	103ee83a 	callr	r2
   219dc:	00000206 	br	219e8 <alt_get_errno+0x3c>
   219e0:	008000f4 	movhi	r2,3
   219e4:	109e4904 	addi	r2,r2,31012
}
   219e8:	e037883a 	mov	sp,fp
   219ec:	dfc00117 	ldw	ra,4(sp)
   219f0:	df000017 	ldw	fp,0(sp)
   219f4:	dec00204 	addi	sp,sp,8
   219f8:	f800283a 	ret

000219fc <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
   219fc:	defffb04 	addi	sp,sp,-20
   21a00:	dfc00415 	stw	ra,16(sp)
   21a04:	df000315 	stw	fp,12(sp)
   21a08:	df000304 	addi	fp,sp,12
   21a0c:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
   21a10:	e0bfff17 	ldw	r2,-4(fp)
   21a14:	10000616 	blt	r2,zero,21a30 <close+0x34>
   21a18:	e0bfff17 	ldw	r2,-4(fp)
   21a1c:	10c00324 	muli	r3,r2,12
   21a20:	008000f4 	movhi	r2,3
   21a24:	108faa04 	addi	r2,r2,16040
   21a28:	1885883a 	add	r2,r3,r2
   21a2c:	00000106 	br	21a34 <close+0x38>
   21a30:	0005883a 	mov	r2,zero
   21a34:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
   21a38:	e0bffd17 	ldw	r2,-12(fp)
   21a3c:	10001826 	beq	r2,zero,21aa0 <close+0xa4>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
   21a40:	e0bffd17 	ldw	r2,-12(fp)
   21a44:	10800017 	ldw	r2,0(r2)
   21a48:	10800417 	ldw	r2,16(r2)
   21a4c:	10000626 	beq	r2,zero,21a68 <close+0x6c>
   21a50:	e0bffd17 	ldw	r2,-12(fp)
   21a54:	10800017 	ldw	r2,0(r2)
   21a58:	10800417 	ldw	r2,16(r2)
   21a5c:	e13ffd17 	ldw	r4,-12(fp)
   21a60:	103ee83a 	callr	r2
   21a64:	00000106 	br	21a6c <close+0x70>
   21a68:	0005883a 	mov	r2,zero
   21a6c:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
   21a70:	e13fff17 	ldw	r4,-4(fp)
   21a74:	00220e00 	call	220e0 <alt_release_fd>
    if (rval < 0)
   21a78:	e0bffe17 	ldw	r2,-8(fp)
   21a7c:	1000060e 	bge	r2,zero,21a98 <close+0x9c>
    {
      ALT_ERRNO = -rval;
   21a80:	00219ac0 	call	219ac <alt_get_errno>
   21a84:	e0fffe17 	ldw	r3,-8(fp)
   21a88:	00c7c83a 	sub	r3,zero,r3
   21a8c:	10c00015 	stw	r3,0(r2)
      return -1;
   21a90:	00bfffc4 	movi	r2,-1
   21a94:	00000606 	br	21ab0 <close+0xb4>
    }
    return 0;
   21a98:	0005883a 	mov	r2,zero
   21a9c:	00000406 	br	21ab0 <close+0xb4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
   21aa0:	00219ac0 	call	219ac <alt_get_errno>
   21aa4:	00c01444 	movi	r3,81
   21aa8:	10c00015 	stw	r3,0(r2)
    return -1;
   21aac:	00bfffc4 	movi	r2,-1
  }
}
   21ab0:	e037883a 	mov	sp,fp
   21ab4:	dfc00117 	ldw	ra,4(sp)
   21ab8:	df000017 	ldw	fp,0(sp)
   21abc:	dec00204 	addi	sp,sp,8
   21ac0:	f800283a 	ret

00021ac4 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
   21ac4:	defffc04 	addi	sp,sp,-16
   21ac8:	df000315 	stw	fp,12(sp)
   21acc:	df000304 	addi	fp,sp,12
   21ad0:	e13ffd15 	stw	r4,-12(fp)
   21ad4:	e17ffe15 	stw	r5,-8(fp)
   21ad8:	e1bfff15 	stw	r6,-4(fp)
  return len;
   21adc:	e0bfff17 	ldw	r2,-4(fp)
}
   21ae0:	e037883a 	mov	sp,fp
   21ae4:	df000017 	ldw	fp,0(sp)
   21ae8:	dec00104 	addi	sp,sp,4
   21aec:	f800283a 	ret

00021af0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   21af0:	defffe04 	addi	sp,sp,-8
   21af4:	dfc00115 	stw	ra,4(sp)
   21af8:	df000015 	stw	fp,0(sp)
   21afc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   21b00:	008000f4 	movhi	r2,3
   21b04:	10958804 	addi	r2,r2,22048
   21b08:	10800017 	ldw	r2,0(r2)
   21b0c:	10000526 	beq	r2,zero,21b24 <alt_get_errno+0x34>
   21b10:	008000f4 	movhi	r2,3
   21b14:	10958804 	addi	r2,r2,22048
   21b18:	10800017 	ldw	r2,0(r2)
   21b1c:	103ee83a 	callr	r2
   21b20:	00000206 	br	21b2c <alt_get_errno+0x3c>
   21b24:	008000f4 	movhi	r2,3
   21b28:	109e4904 	addi	r2,r2,31012
}
   21b2c:	e037883a 	mov	sp,fp
   21b30:	dfc00117 	ldw	ra,4(sp)
   21b34:	df000017 	ldw	fp,0(sp)
   21b38:	dec00204 	addi	sp,sp,8
   21b3c:	f800283a 	ret

00021b40 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
   21b40:	defffb04 	addi	sp,sp,-20
   21b44:	dfc00415 	stw	ra,16(sp)
   21b48:	df000315 	stw	fp,12(sp)
   21b4c:	df000304 	addi	fp,sp,12
   21b50:	e13ffe15 	stw	r4,-8(fp)
   21b54:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   21b58:	e0bffe17 	ldw	r2,-8(fp)
   21b5c:	10000616 	blt	r2,zero,21b78 <fstat+0x38>
   21b60:	e0bffe17 	ldw	r2,-8(fp)
   21b64:	10c00324 	muli	r3,r2,12
   21b68:	008000f4 	movhi	r2,3
   21b6c:	108faa04 	addi	r2,r2,16040
   21b70:	1885883a 	add	r2,r3,r2
   21b74:	00000106 	br	21b7c <fstat+0x3c>
   21b78:	0005883a 	mov	r2,zero
   21b7c:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
   21b80:	e0bffd17 	ldw	r2,-12(fp)
   21b84:	10001026 	beq	r2,zero,21bc8 <fstat+0x88>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
   21b88:	e0bffd17 	ldw	r2,-12(fp)
   21b8c:	10800017 	ldw	r2,0(r2)
   21b90:	10800817 	ldw	r2,32(r2)
   21b94:	10000726 	beq	r2,zero,21bb4 <fstat+0x74>
    {
      return fd->dev->fstat(fd, st);
   21b98:	e0bffd17 	ldw	r2,-12(fp)
   21b9c:	10800017 	ldw	r2,0(r2)
   21ba0:	10800817 	ldw	r2,32(r2)
   21ba4:	e13ffd17 	ldw	r4,-12(fp)
   21ba8:	e17fff17 	ldw	r5,-4(fp)
   21bac:	103ee83a 	callr	r2
   21bb0:	00000906 	br	21bd8 <fstat+0x98>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
   21bb4:	e0bfff17 	ldw	r2,-4(fp)
   21bb8:	00c80004 	movi	r3,8192
   21bbc:	10c00115 	stw	r3,4(r2)
      return 0;
   21bc0:	0005883a 	mov	r2,zero
   21bc4:	00000406 	br	21bd8 <fstat+0x98>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
   21bc8:	0021af00 	call	21af0 <alt_get_errno>
   21bcc:	00c01444 	movi	r3,81
   21bd0:	10c00015 	stw	r3,0(r2)
    return -1;
   21bd4:	00bfffc4 	movi	r2,-1
  }
}
   21bd8:	e037883a 	mov	sp,fp
   21bdc:	dfc00117 	ldw	ra,4(sp)
   21be0:	df000017 	ldw	fp,0(sp)
   21be4:	dec00204 	addi	sp,sp,8
   21be8:	f800283a 	ret

00021bec <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   21bec:	defffe04 	addi	sp,sp,-8
   21bf0:	dfc00115 	stw	ra,4(sp)
   21bf4:	df000015 	stw	fp,0(sp)
   21bf8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   21bfc:	008000f4 	movhi	r2,3
   21c00:	10958804 	addi	r2,r2,22048
   21c04:	10800017 	ldw	r2,0(r2)
   21c08:	10000526 	beq	r2,zero,21c20 <alt_get_errno+0x34>
   21c0c:	008000f4 	movhi	r2,3
   21c10:	10958804 	addi	r2,r2,22048
   21c14:	10800017 	ldw	r2,0(r2)
   21c18:	103ee83a 	callr	r2
   21c1c:	00000206 	br	21c28 <alt_get_errno+0x3c>
   21c20:	008000f4 	movhi	r2,3
   21c24:	109e4904 	addi	r2,r2,31012
}
   21c28:	e037883a 	mov	sp,fp
   21c2c:	dfc00117 	ldw	ra,4(sp)
   21c30:	df000017 	ldw	fp,0(sp)
   21c34:	dec00204 	addi	sp,sp,8
   21c38:	f800283a 	ret

00021c3c <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
   21c3c:	deffed04 	addi	sp,sp,-76
   21c40:	dfc01215 	stw	ra,72(sp)
   21c44:	df001115 	stw	fp,68(sp)
   21c48:	df001104 	addi	fp,sp,68
   21c4c:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   21c50:	e0bfff17 	ldw	r2,-4(fp)
   21c54:	10000616 	blt	r2,zero,21c70 <isatty+0x34>
   21c58:	e0bfff17 	ldw	r2,-4(fp)
   21c5c:	10c00324 	muli	r3,r2,12
   21c60:	008000f4 	movhi	r2,3
   21c64:	108faa04 	addi	r2,r2,16040
   21c68:	1885883a 	add	r2,r3,r2
   21c6c:	00000106 	br	21c74 <isatty+0x38>
   21c70:	0005883a 	mov	r2,zero
   21c74:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
   21c78:	e0bfef17 	ldw	r2,-68(fp)
   21c7c:	10000e26 	beq	r2,zero,21cb8 <isatty+0x7c>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
   21c80:	e0bfef17 	ldw	r2,-68(fp)
   21c84:	10800017 	ldw	r2,0(r2)
   21c88:	10800817 	ldw	r2,32(r2)
   21c8c:	1000021e 	bne	r2,zero,21c98 <isatty+0x5c>
    {
      return 1;
   21c90:	00800044 	movi	r2,1
   21c94:	00000c06 	br	21cc8 <isatty+0x8c>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
   21c98:	e0bff004 	addi	r2,fp,-64
   21c9c:	e13fff17 	ldw	r4,-4(fp)
   21ca0:	100b883a 	mov	r5,r2
   21ca4:	0021b400 	call	21b40 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
   21ca8:	e0bff117 	ldw	r2,-60(fp)
   21cac:	10880020 	cmpeqi	r2,r2,8192
   21cb0:	10803fcc 	andi	r2,r2,255
   21cb4:	00000406 	br	21cc8 <isatty+0x8c>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
   21cb8:	0021bec0 	call	21bec <alt_get_errno>
   21cbc:	00c01444 	movi	r3,81
   21cc0:	10c00015 	stw	r3,0(r2)
    return 0;
   21cc4:	0005883a 	mov	r2,zero
  }
}
   21cc8:	e037883a 	mov	sp,fp
   21ccc:	dfc00117 	ldw	ra,4(sp)
   21cd0:	df000017 	ldw	fp,0(sp)
   21cd4:	dec00204 	addi	sp,sp,8
   21cd8:	f800283a 	ret

00021cdc <alt_load_section>:
   21cdc:	defffc04 	addi	sp,sp,-16
   21ce0:	df000315 	stw	fp,12(sp)
   21ce4:	df000304 	addi	fp,sp,12
   21ce8:	e13ffd15 	stw	r4,-12(fp)
   21cec:	e17ffe15 	stw	r5,-8(fp)
   21cf0:	e1bfff15 	stw	r6,-4(fp)
   21cf4:	e0fffe17 	ldw	r3,-8(fp)
   21cf8:	e0bffd17 	ldw	r2,-12(fp)
   21cfc:	18800e26 	beq	r3,r2,21d38 <alt_load_section+0x5c>
   21d00:	00000a06 	br	21d2c <alt_load_section+0x50>
   21d04:	e0bffd17 	ldw	r2,-12(fp)
   21d08:	10c00017 	ldw	r3,0(r2)
   21d0c:	e0bffe17 	ldw	r2,-8(fp)
   21d10:	10c00015 	stw	r3,0(r2)
   21d14:	e0bffe17 	ldw	r2,-8(fp)
   21d18:	10800104 	addi	r2,r2,4
   21d1c:	e0bffe15 	stw	r2,-8(fp)
   21d20:	e0bffd17 	ldw	r2,-12(fp)
   21d24:	10800104 	addi	r2,r2,4
   21d28:	e0bffd15 	stw	r2,-12(fp)
   21d2c:	e0fffe17 	ldw	r3,-8(fp)
   21d30:	e0bfff17 	ldw	r2,-4(fp)
   21d34:	18bff31e 	bne	r3,r2,21d04 <alt_load_section+0x28>
   21d38:	e037883a 	mov	sp,fp
   21d3c:	df000017 	ldw	fp,0(sp)
   21d40:	dec00104 	addi	sp,sp,4
   21d44:	f800283a 	ret

00021d48 <alt_load>:
   21d48:	defffe04 	addi	sp,sp,-8
   21d4c:	dfc00115 	stw	ra,4(sp)
   21d50:	df000015 	stw	fp,0(sp)
   21d54:	d839883a 	mov	fp,sp
   21d58:	010000f4 	movhi	r4,3
   21d5c:	21159304 	addi	r4,r4,22092
   21d60:	014000f4 	movhi	r5,3
   21d64:	294d0b04 	addi	r5,r5,13356
   21d68:	018000f4 	movhi	r6,3
   21d6c:	31959304 	addi	r6,r6,22092
   21d70:	0021cdc0 	call	21cdc <alt_load_section>
   21d74:	01000034 	movhi	r4,0
   21d78:	21000804 	addi	r4,r4,32
   21d7c:	01400034 	movhi	r5,0
   21d80:	29400804 	addi	r5,r5,32
   21d84:	01800034 	movhi	r6,0
   21d88:	31800804 	addi	r6,r6,32
   21d8c:	0021cdc0 	call	21cdc <alt_load_section>
   21d90:	010000f4 	movhi	r4,3
   21d94:	2138bf04 	addi	r4,r4,-7428
   21d98:	014000f4 	movhi	r5,3
   21d9c:	2978bf04 	addi	r5,r5,-7428
   21da0:	018000f4 	movhi	r6,3
   21da4:	318d0b04 	addi	r6,r6,13356
   21da8:	0021cdc0 	call	21cdc <alt_load_section>
   21dac:	002cd180 	call	2cd18 <alt_dcache_flush_all>
   21db0:	002d0240 	call	2d024 <alt_icache_flush_all>
   21db4:	e037883a 	mov	sp,fp
   21db8:	dfc00117 	ldw	ra,4(sp)
   21dbc:	df000017 	ldw	fp,0(sp)
   21dc0:	dec00204 	addi	sp,sp,8
   21dc4:	f800283a 	ret

00021dc8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   21dc8:	defffe04 	addi	sp,sp,-8
   21dcc:	dfc00115 	stw	ra,4(sp)
   21dd0:	df000015 	stw	fp,0(sp)
   21dd4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   21dd8:	008000f4 	movhi	r2,3
   21ddc:	10958804 	addi	r2,r2,22048
   21de0:	10800017 	ldw	r2,0(r2)
   21de4:	10000526 	beq	r2,zero,21dfc <alt_get_errno+0x34>
   21de8:	008000f4 	movhi	r2,3
   21dec:	10958804 	addi	r2,r2,22048
   21df0:	10800017 	ldw	r2,0(r2)
   21df4:	103ee83a 	callr	r2
   21df8:	00000206 	br	21e04 <alt_get_errno+0x3c>
   21dfc:	008000f4 	movhi	r2,3
   21e00:	109e4904 	addi	r2,r2,31012
}
   21e04:	e037883a 	mov	sp,fp
   21e08:	dfc00117 	ldw	ra,4(sp)
   21e0c:	df000017 	ldw	fp,0(sp)
   21e10:	dec00204 	addi	sp,sp,8
   21e14:	f800283a 	ret

00021e18 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
   21e18:	defff904 	addi	sp,sp,-28
   21e1c:	dfc00615 	stw	ra,24(sp)
   21e20:	df000515 	stw	fp,20(sp)
   21e24:	df000504 	addi	fp,sp,20
   21e28:	e13ffd15 	stw	r4,-12(fp)
   21e2c:	e17ffe15 	stw	r5,-8(fp)
   21e30:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
   21e34:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   21e38:	e0bffd17 	ldw	r2,-12(fp)
   21e3c:	10000616 	blt	r2,zero,21e58 <lseek+0x40>
   21e40:	e0bffd17 	ldw	r2,-12(fp)
   21e44:	10c00324 	muli	r3,r2,12
   21e48:	008000f4 	movhi	r2,3
   21e4c:	108faa04 	addi	r2,r2,16040
   21e50:	1885883a 	add	r2,r3,r2
   21e54:	00000106 	br	21e5c <lseek+0x44>
   21e58:	0005883a 	mov	r2,zero
   21e5c:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
   21e60:	e0bffc17 	ldw	r2,-16(fp)
   21e64:	10001026 	beq	r2,zero,21ea8 <lseek+0x90>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
   21e68:	e0bffc17 	ldw	r2,-16(fp)
   21e6c:	10800017 	ldw	r2,0(r2)
   21e70:	10800717 	ldw	r2,28(r2)
   21e74:	10000926 	beq	r2,zero,21e9c <lseek+0x84>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
   21e78:	e0bffc17 	ldw	r2,-16(fp)
   21e7c:	10800017 	ldw	r2,0(r2)
   21e80:	10800717 	ldw	r2,28(r2)
   21e84:	e13ffc17 	ldw	r4,-16(fp)
   21e88:	e17ffe17 	ldw	r5,-8(fp)
   21e8c:	e1bfff17 	ldw	r6,-4(fp)
   21e90:	103ee83a 	callr	r2
   21e94:	e0bffb15 	stw	r2,-20(fp)
   21e98:	00000506 	br	21eb0 <lseek+0x98>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
   21e9c:	00bfde84 	movi	r2,-134
   21ea0:	e0bffb15 	stw	r2,-20(fp)
   21ea4:	00000206 	br	21eb0 <lseek+0x98>
    }
  }
  else  
  {
    rc = -EBADFD;
   21ea8:	00bfebc4 	movi	r2,-81
   21eac:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
   21eb0:	e0bffb17 	ldw	r2,-20(fp)
   21eb4:	1000060e 	bge	r2,zero,21ed0 <lseek+0xb8>
  {
    ALT_ERRNO = -rc;
   21eb8:	0021dc80 	call	21dc8 <alt_get_errno>
   21ebc:	e0fffb17 	ldw	r3,-20(fp)
   21ec0:	00c7c83a 	sub	r3,zero,r3
   21ec4:	10c00015 	stw	r3,0(r2)
    rc = -1;
   21ec8:	00bfffc4 	movi	r2,-1
   21ecc:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
   21ed0:	e0bffb17 	ldw	r2,-20(fp)
}
   21ed4:	e037883a 	mov	sp,fp
   21ed8:	dfc00117 	ldw	ra,4(sp)
   21edc:	df000017 	ldw	fp,0(sp)
   21ee0:	dec00204 	addi	sp,sp,8
   21ee4:	f800283a 	ret

00021ee8 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
   21ee8:	defffd04 	addi	sp,sp,-12
   21eec:	dfc00215 	stw	ra,8(sp)
   21ef0:	df000115 	stw	fp,4(sp)
   21ef4:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
   21ef8:	0009883a 	mov	r4,zero
   21efc:	002264c0 	call	2264c <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
   21f00:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
   21f04:	002268c0 	call	2268c <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
   21f08:	010000f4 	movhi	r4,3
   21f0c:	21054904 	addi	r4,r4,5412
   21f10:	014000f4 	movhi	r5,3
   21f14:	29454904 	addi	r5,r5,5412
   21f18:	018000f4 	movhi	r6,3
   21f1c:	31854904 	addi	r6,r6,5412
   21f20:	002d1140 	call	2d114 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
   21f24:	002ce240 	call	2ce24 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
   21f28:	010000f4 	movhi	r4,3
   21f2c:	2133a004 	addi	r4,r4,-12672
   21f30:	002dee80 	call	2dee8 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
   21f34:	d128d817 	ldw	r4,-23712(gp)
   21f38:	d0e8d917 	ldw	r3,-23708(gp)
   21f3c:	d0a8da17 	ldw	r2,-23704(gp)
   21f40:	180b883a 	mov	r5,r3
   21f44:	100d883a 	mov	r6,r2
   21f48:	0017d5c0 	call	17d5c <main>
   21f4c:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
   21f50:	01000044 	movi	r4,1
   21f54:	00219fc0 	call	219fc <close>
  exit (result);
   21f58:	e13fff17 	ldw	r4,-4(fp)
   21f5c:	002defc0 	call	2defc <exit>

00021f60 <__malloc_lock>:
   21f60:	defffe04 	addi	sp,sp,-8
   21f64:	df000115 	stw	fp,4(sp)
   21f68:	df000104 	addi	fp,sp,4
   21f6c:	e13fff15 	stw	r4,-4(fp)
   21f70:	e037883a 	mov	sp,fp
   21f74:	df000017 	ldw	fp,0(sp)
   21f78:	dec00104 	addi	sp,sp,4
   21f7c:	f800283a 	ret

00021f80 <__malloc_unlock>:
   21f80:	defffe04 	addi	sp,sp,-8
   21f84:	df000115 	stw	fp,4(sp)
   21f88:	df000104 	addi	fp,sp,4
   21f8c:	e13fff15 	stw	r4,-4(fp)
   21f90:	e037883a 	mov	sp,fp
   21f94:	df000017 	ldw	fp,0(sp)
   21f98:	dec00104 	addi	sp,sp,4
   21f9c:	f800283a 	ret

00021fa0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   21fa0:	defffe04 	addi	sp,sp,-8
   21fa4:	dfc00115 	stw	ra,4(sp)
   21fa8:	df000015 	stw	fp,0(sp)
   21fac:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   21fb0:	008000f4 	movhi	r2,3
   21fb4:	10958804 	addi	r2,r2,22048
   21fb8:	10800017 	ldw	r2,0(r2)
   21fbc:	10000526 	beq	r2,zero,21fd4 <alt_get_errno+0x34>
   21fc0:	008000f4 	movhi	r2,3
   21fc4:	10958804 	addi	r2,r2,22048
   21fc8:	10800017 	ldw	r2,0(r2)
   21fcc:	103ee83a 	callr	r2
   21fd0:	00000206 	br	21fdc <alt_get_errno+0x3c>
   21fd4:	008000f4 	movhi	r2,3
   21fd8:	109e4904 	addi	r2,r2,31012
}
   21fdc:	e037883a 	mov	sp,fp
   21fe0:	dfc00117 	ldw	ra,4(sp)
   21fe4:	df000017 	ldw	fp,0(sp)
   21fe8:	dec00204 	addi	sp,sp,8
   21fec:	f800283a 	ret

00021ff0 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
   21ff0:	defff904 	addi	sp,sp,-28
   21ff4:	dfc00615 	stw	ra,24(sp)
   21ff8:	df000515 	stw	fp,20(sp)
   21ffc:	df000504 	addi	fp,sp,20
   22000:	e13ffd15 	stw	r4,-12(fp)
   22004:	e17ffe15 	stw	r5,-8(fp)
   22008:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   2200c:	e0bffd17 	ldw	r2,-12(fp)
   22010:	10000616 	blt	r2,zero,2202c <read+0x3c>
   22014:	e0bffd17 	ldw	r2,-12(fp)
   22018:	10c00324 	muli	r3,r2,12
   2201c:	008000f4 	movhi	r2,3
   22020:	108faa04 	addi	r2,r2,16040
   22024:	1885883a 	add	r2,r3,r2
   22028:	00000106 	br	22030 <read+0x40>
   2202c:	0005883a 	mov	r2,zero
   22030:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
   22034:	e0bffb17 	ldw	r2,-20(fp)
   22038:	10002026 	beq	r2,zero,220bc <read+0xcc>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
   2203c:	e0bffb17 	ldw	r2,-20(fp)
   22040:	10800217 	ldw	r2,8(r2)
   22044:	108000cc 	andi	r2,r2,3
   22048:	10800060 	cmpeqi	r2,r2,1
   2204c:	1000171e 	bne	r2,zero,220ac <read+0xbc>
        (fd->dev->read))
   22050:	e0bffb17 	ldw	r2,-20(fp)
   22054:	10800017 	ldw	r2,0(r2)
   22058:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
   2205c:	10001326 	beq	r2,zero,220ac <read+0xbc>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
   22060:	e0bffb17 	ldw	r2,-20(fp)
   22064:	10800017 	ldw	r2,0(r2)
   22068:	10c00517 	ldw	r3,20(r2)
   2206c:	e0bfff17 	ldw	r2,-4(fp)
   22070:	e13ffb17 	ldw	r4,-20(fp)
   22074:	e17ffe17 	ldw	r5,-8(fp)
   22078:	100d883a 	mov	r6,r2
   2207c:	183ee83a 	callr	r3
   22080:	e0bffc15 	stw	r2,-16(fp)
   22084:	e0bffc17 	ldw	r2,-16(fp)
   22088:	1000060e 	bge	r2,zero,220a4 <read+0xb4>
        {
          ALT_ERRNO = -rval;
   2208c:	0021fa00 	call	21fa0 <alt_get_errno>
   22090:	e0fffc17 	ldw	r3,-16(fp)
   22094:	00c7c83a 	sub	r3,zero,r3
   22098:	10c00015 	stw	r3,0(r2)
          return -1;
   2209c:	00bfffc4 	movi	r2,-1
   220a0:	00000a06 	br	220cc <read+0xdc>
        }
        return rval;
   220a4:	e0bffc17 	ldw	r2,-16(fp)
   220a8:	00000806 	br	220cc <read+0xdc>
      }
      else
      {
        ALT_ERRNO = EACCES;
   220ac:	0021fa00 	call	21fa0 <alt_get_errno>
   220b0:	00c00344 	movi	r3,13
   220b4:	10c00015 	stw	r3,0(r2)
   220b8:	00000306 	br	220c8 <read+0xd8>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
   220bc:	0021fa00 	call	21fa0 <alt_get_errno>
   220c0:	00c01444 	movi	r3,81
   220c4:	10c00015 	stw	r3,0(r2)
  }
  return -1;
   220c8:	00bfffc4 	movi	r2,-1
}
   220cc:	e037883a 	mov	sp,fp
   220d0:	dfc00117 	ldw	ra,4(sp)
   220d4:	df000017 	ldw	fp,0(sp)
   220d8:	dec00204 	addi	sp,sp,8
   220dc:	f800283a 	ret

000220e0 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
   220e0:	defffe04 	addi	sp,sp,-8
   220e4:	df000115 	stw	fp,4(sp)
   220e8:	df000104 	addi	fp,sp,4
   220ec:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
   220f0:	e0bfff17 	ldw	r2,-4(fp)
   220f4:	108000d0 	cmplti	r2,r2,3
   220f8:	10000d1e 	bne	r2,zero,22130 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
   220fc:	00c000f4 	movhi	r3,3
   22100:	18cfaa04 	addi	r3,r3,16040
   22104:	e0bfff17 	ldw	r2,-4(fp)
   22108:	10800324 	muli	r2,r2,12
   2210c:	1885883a 	add	r2,r3,r2
   22110:	10800204 	addi	r2,r2,8
   22114:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
   22118:	00c000f4 	movhi	r3,3
   2211c:	18cfaa04 	addi	r3,r3,16040
   22120:	e0bfff17 	ldw	r2,-4(fp)
   22124:	10800324 	muli	r2,r2,12
   22128:	1885883a 	add	r2,r3,r2
   2212c:	10000015 	stw	zero,0(r2)
  }
}
   22130:	e037883a 	mov	sp,fp
   22134:	df000017 	ldw	fp,0(sp)
   22138:	dec00104 	addi	sp,sp,4
   2213c:	f800283a 	ret

00022140 <alt_remap_uncached>:
 * Convert a pointer to a block of cached memory, into a block of
 * uncached memory.
 */

volatile void* alt_remap_uncached (void* ptr, alt_u32 len)
{
   22140:	defffc04 	addi	sp,sp,-16
   22144:	dfc00315 	stw	ra,12(sp)
   22148:	df000215 	stw	fp,8(sp)
   2214c:	df000204 	addi	fp,sp,8
   22150:	e13ffe15 	stw	r4,-8(fp)
   22154:	e17fff15 	stw	r5,-4(fp)
  alt_dcache_flush (ptr, len);
   22158:	e13ffe17 	ldw	r4,-8(fp)
   2215c:	e17fff17 	ldw	r5,-4(fp)
   22160:	002ccf40 	call	2ccf4 <alt_dcache_flush>
  return (volatile void*) (((alt_u32) ptr) | BYPASS_DCACHE_MASK);
   22164:	e0bffe17 	ldw	r2,-8(fp)
   22168:	10a00034 	orhi	r2,r2,32768
}
   2216c:	e037883a 	mov	sp,fp
   22170:	dfc00117 	ldw	ra,4(sp)
   22174:	df000017 	ldw	fp,0(sp)
   22178:	dec00204 	addi	sp,sp,8
   2217c:	f800283a 	ret

00022180 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
   22180:	defff704 	addi	sp,sp,-36
   22184:	df000815 	stw	fp,32(sp)
   22188:	df000804 	addi	fp,sp,32
   2218c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   22190:	0005303a 	rdctl	r2,status
   22194:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   22198:	e0fffa17 	ldw	r3,-24(fp)
   2219c:	00bfff84 	movi	r2,-2
   221a0:	1884703a 	and	r2,r3,r2
   221a4:	1001703a 	wrctl	status,r2
  
  return context;
   221a8:	e0bffa17 	ldw	r2,-24(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
   221ac:	e0bff815 	stw	r2,-32(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
   221b0:	d0a01717 	ldw	r2,-32676(gp)
   221b4:	10c000c4 	addi	r3,r2,3
   221b8:	00bfff04 	movi	r2,-4
   221bc:	1884703a 	and	r2,r3,r2
   221c0:	d0a01715 	stw	r2,-32676(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
   221c4:	d0e01717 	ldw	r3,-32676(gp)
   221c8:	e0bfff17 	ldw	r2,-4(fp)
   221cc:	1885883a 	add	r2,r3,r2
   221d0:	00c08034 	movhi	r3,512
   221d4:	18c00004 	addi	r3,r3,0
   221d8:	1880112e 	bgeu	r3,r2,22220 <sbrk+0xa0>
   221dc:	e0bff817 	ldw	r2,-32(fp)
   221e0:	e0bffb15 	stw	r2,-20(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   221e4:	0005303a 	rdctl	r2,status
   221e8:	e0bffc15 	stw	r2,-16(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   221ec:	e0fffc17 	ldw	r3,-16(fp)
   221f0:	00bfff84 	movi	r2,-2
   221f4:	1884703a 	and	r2,r3,r2
   221f8:	e0bffc15 	stw	r2,-16(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   221fc:	e0bffb17 	ldw	r2,-20(fp)
   22200:	1080004c 	andi	r2,r2,1
   22204:	e0fffc17 	ldw	r3,-16(fp)
   22208:	1884b03a 	or	r2,r3,r2
   2220c:	e0bffc15 	stw	r2,-16(fp)
  
  NIOS2_WRITE_STATUS (status);
   22210:	e0bffc17 	ldw	r2,-16(fp)
   22214:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
   22218:	00bfffc4 	movi	r2,-1
   2221c:	00001606 	br	22278 <sbrk+0xf8>
  }
#endif

  prev_heap_end = heap_end; 
   22220:	d0a01717 	ldw	r2,-32676(gp)
   22224:	e0bff915 	stw	r2,-28(fp)
  heap_end += incr; 
   22228:	d0e01717 	ldw	r3,-32676(gp)
   2222c:	e0bfff17 	ldw	r2,-4(fp)
   22230:	1885883a 	add	r2,r3,r2
   22234:	d0a01715 	stw	r2,-32676(gp)
   22238:	e0bff817 	ldw	r2,-32(fp)
   2223c:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   22240:	0005303a 	rdctl	r2,status
   22244:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   22248:	e0fffe17 	ldw	r3,-8(fp)
   2224c:	00bfff84 	movi	r2,-2
   22250:	1884703a 	and	r2,r3,r2
   22254:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   22258:	e0bffd17 	ldw	r2,-12(fp)
   2225c:	1080004c 	andi	r2,r2,1
   22260:	e0fffe17 	ldw	r3,-8(fp)
   22264:	1884b03a 	or	r2,r3,r2
   22268:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
   2226c:	e0bffe17 	ldw	r2,-8(fp)
   22270:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
   22274:	e0bff917 	ldw	r2,-28(fp)
} 
   22278:	e037883a 	mov	sp,fp
   2227c:	df000017 	ldw	fp,0(sp)
   22280:	dec00104 	addi	sp,sp,4
   22284:	f800283a 	ret

00022288 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
   22288:	defff904 	addi	sp,sp,-28
   2228c:	df000615 	stw	fp,24(sp)
   22290:	df000604 	addi	fp,sp,24
   22294:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   22298:	0005303a 	rdctl	r2,status
   2229c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   222a0:	e0fffb17 	ldw	r3,-20(fp)
   222a4:	00bfff84 	movi	r2,-2
   222a8:	1884703a 	and	r2,r3,r2
   222ac:	1001703a 	wrctl	status,r2
  
  return context;
   222b0:	e0bffb17 	ldw	r2,-20(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
   222b4:	e0bffa15 	stw	r2,-24(fp)
  alt_llist_remove (&alarm->llist);
   222b8:	e0bfff17 	ldw	r2,-4(fp)
   222bc:	e0bffc15 	stw	r2,-16(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
   222c0:	e0bffc17 	ldw	r2,-16(fp)
   222c4:	10800017 	ldw	r2,0(r2)
   222c8:	e0fffc17 	ldw	r3,-16(fp)
   222cc:	18c00117 	ldw	r3,4(r3)
   222d0:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
   222d4:	e0bffc17 	ldw	r2,-16(fp)
   222d8:	10800117 	ldw	r2,4(r2)
   222dc:	e0fffc17 	ldw	r3,-16(fp)
   222e0:	18c00017 	ldw	r3,0(r3)
   222e4:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
   222e8:	e0bffc17 	ldw	r2,-16(fp)
   222ec:	e0fffc17 	ldw	r3,-16(fp)
   222f0:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
   222f4:	e0bffc17 	ldw	r2,-16(fp)
   222f8:	e0fffc17 	ldw	r3,-16(fp)
   222fc:	10c00015 	stw	r3,0(r2)
   22300:	e0bffa17 	ldw	r2,-24(fp)
   22304:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   22308:	0005303a 	rdctl	r2,status
   2230c:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   22310:	e0fffe17 	ldw	r3,-8(fp)
   22314:	00bfff84 	movi	r2,-2
   22318:	1884703a 	and	r2,r3,r2
   2231c:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   22320:	e0bffd17 	ldw	r2,-12(fp)
   22324:	1080004c 	andi	r2,r2,1
   22328:	e0fffe17 	ldw	r3,-8(fp)
   2232c:	1884b03a 	or	r2,r3,r2
   22330:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
   22334:	e0bffe17 	ldw	r2,-8(fp)
   22338:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
   2233c:	e037883a 	mov	sp,fp
   22340:	df000017 	ldw	fp,0(sp)
   22344:	dec00104 	addi	sp,sp,4
   22348:	f800283a 	ret

0002234c <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
   2234c:	defffb04 	addi	sp,sp,-20
   22350:	dfc00415 	stw	ra,16(sp)
   22354:	df000315 	stw	fp,12(sp)
   22358:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
   2235c:	d0a01817 	ldw	r2,-32672(gp)
   22360:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
   22364:	d0a8dc17 	ldw	r2,-23696(gp)
   22368:	10800044 	addi	r2,r2,1
   2236c:	d0a8dc15 	stw	r2,-23696(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
   22370:	00002e06 	br	2242c <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
   22374:	e0bffd17 	ldw	r2,-12(fp)
   22378:	10800017 	ldw	r2,0(r2)
   2237c:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
   22380:	e0bffd17 	ldw	r2,-12(fp)
   22384:	10800403 	ldbu	r2,16(r2)
   22388:	10803fcc 	andi	r2,r2,255
   2238c:	10000426 	beq	r2,zero,223a0 <alt_tick+0x54>
   22390:	d0a8dc17 	ldw	r2,-23696(gp)
   22394:	1000021e 	bne	r2,zero,223a0 <alt_tick+0x54>
    {
      alarm->rollover = 0;
   22398:	e0bffd17 	ldw	r2,-12(fp)
   2239c:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
   223a0:	e0bffd17 	ldw	r2,-12(fp)
   223a4:	10800217 	ldw	r2,8(r2)
   223a8:	d0e8dc17 	ldw	r3,-23696(gp)
   223ac:	18801d36 	bltu	r3,r2,22424 <alt_tick+0xd8>
   223b0:	e0bffd17 	ldw	r2,-12(fp)
   223b4:	10800403 	ldbu	r2,16(r2)
   223b8:	10803fcc 	andi	r2,r2,255
   223bc:	1000191e 	bne	r2,zero,22424 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
   223c0:	e0bffd17 	ldw	r2,-12(fp)
   223c4:	10c00317 	ldw	r3,12(r2)
   223c8:	e0bffd17 	ldw	r2,-12(fp)
   223cc:	10800517 	ldw	r2,20(r2)
   223d0:	1009883a 	mov	r4,r2
   223d4:	183ee83a 	callr	r3
   223d8:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
   223dc:	e0bfff17 	ldw	r2,-4(fp)
   223e0:	1000031e 	bne	r2,zero,223f0 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
   223e4:	e13ffd17 	ldw	r4,-12(fp)
   223e8:	00222880 	call	22288 <alt_alarm_stop>
   223ec:	00000d06 	br	22424 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
   223f0:	e0bffd17 	ldw	r2,-12(fp)
   223f4:	10c00217 	ldw	r3,8(r2)
   223f8:	e0bfff17 	ldw	r2,-4(fp)
   223fc:	1887883a 	add	r3,r3,r2
   22400:	e0bffd17 	ldw	r2,-12(fp)
   22404:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
   22408:	e0bffd17 	ldw	r2,-12(fp)
   2240c:	10c00217 	ldw	r3,8(r2)
   22410:	d0a8dc17 	ldw	r2,-23696(gp)
   22414:	1880032e 	bgeu	r3,r2,22424 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
   22418:	e0bffd17 	ldw	r2,-12(fp)
   2241c:	00c00044 	movi	r3,1
   22420:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
   22424:	e0bffe17 	ldw	r2,-8(fp)
   22428:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
   2242c:	e0fffd17 	ldw	r3,-12(fp)
   22430:	d0a01804 	addi	r2,gp,-32672
   22434:	18bfcf1e 	bne	r3,r2,22374 <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
   22438:	0001883a 	nop
}
   2243c:	e037883a 	mov	sp,fp
   22440:	dfc00117 	ldw	ra,4(sp)
   22444:	df000017 	ldw	fp,0(sp)
   22448:	dec00204 	addi	sp,sp,8
   2244c:	f800283a 	ret

00022450 <alt_uncached_malloc>:
/*
 * Allocate a block of uncached memory.
 */

volatile void* alt_uncached_malloc (size_t size)
{
   22450:	defffc04 	addi	sp,sp,-16
   22454:	dfc00315 	stw	ra,12(sp)
   22458:	df000215 	stw	fp,8(sp)
   2245c:	df000204 	addi	fp,sp,8
   22460:	e13fff15 	stw	r4,-4(fp)
  void* ptr;

  ptr = malloc (size);
   22464:	e13fff17 	ldw	r4,-4(fp)
   22468:	002df340 	call	2df34 <malloc>
   2246c:	e0bffe15 	stw	r2,-8(fp)

  alt_dcache_flush (ptr, size);
   22470:	e13ffe17 	ldw	r4,-8(fp)
   22474:	e17fff17 	ldw	r5,-4(fp)
   22478:	002ccf40 	call	2ccf4 <alt_dcache_flush>

  return ptr ? (volatile void*) (((alt_u32) ptr) | BYPASS_DCACHE_MASK) : NULL;
   2247c:	e0bffe17 	ldw	r2,-8(fp)
   22480:	10000326 	beq	r2,zero,22490 <alt_uncached_malloc+0x40>
   22484:	e0bffe17 	ldw	r2,-8(fp)
   22488:	10a00034 	orhi	r2,r2,32768
   2248c:	00000106 	br	22494 <alt_uncached_malloc+0x44>
   22490:	0005883a 	mov	r2,zero
}
   22494:	e037883a 	mov	sp,fp
   22498:	dfc00117 	ldw	ra,4(sp)
   2249c:	df000017 	ldw	fp,0(sp)
   224a0:	dec00204 	addi	sp,sp,8
   224a4:	f800283a 	ret

000224a8 <usleep>:
   224a8:	defffd04 	addi	sp,sp,-12
   224ac:	dfc00215 	stw	ra,8(sp)
   224b0:	df000115 	stw	fp,4(sp)
   224b4:	df000104 	addi	fp,sp,4
   224b8:	e13fff15 	stw	r4,-4(fp)
   224bc:	e13fff17 	ldw	r4,-4(fp)
   224c0:	002cbcc0 	call	2cbcc <alt_busy_sleep>
   224c4:	e037883a 	mov	sp,fp
   224c8:	dfc00117 	ldw	ra,4(sp)
   224cc:	df000017 	ldw	fp,0(sp)
   224d0:	dec00204 	addi	sp,sp,8
   224d4:	f800283a 	ret

000224d8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   224d8:	defffe04 	addi	sp,sp,-8
   224dc:	dfc00115 	stw	ra,4(sp)
   224e0:	df000015 	stw	fp,0(sp)
   224e4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   224e8:	008000f4 	movhi	r2,3
   224ec:	10958804 	addi	r2,r2,22048
   224f0:	10800017 	ldw	r2,0(r2)
   224f4:	10000526 	beq	r2,zero,2250c <alt_get_errno+0x34>
   224f8:	008000f4 	movhi	r2,3
   224fc:	10958804 	addi	r2,r2,22048
   22500:	10800017 	ldw	r2,0(r2)
   22504:	103ee83a 	callr	r2
   22508:	00000206 	br	22514 <alt_get_errno+0x3c>
   2250c:	008000f4 	movhi	r2,3
   22510:	109e4904 	addi	r2,r2,31012
}
   22514:	e037883a 	mov	sp,fp
   22518:	dfc00117 	ldw	ra,4(sp)
   2251c:	df000017 	ldw	fp,0(sp)
   22520:	dec00204 	addi	sp,sp,8
   22524:	f800283a 	ret

00022528 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
   22528:	defff904 	addi	sp,sp,-28
   2252c:	dfc00615 	stw	ra,24(sp)
   22530:	df000515 	stw	fp,20(sp)
   22534:	df000504 	addi	fp,sp,20
   22538:	e13ffd15 	stw	r4,-12(fp)
   2253c:	e17ffe15 	stw	r5,-8(fp)
   22540:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   22544:	e0bffd17 	ldw	r2,-12(fp)
   22548:	10000616 	blt	r2,zero,22564 <write+0x3c>
   2254c:	e0bffd17 	ldw	r2,-12(fp)
   22550:	10c00324 	muli	r3,r2,12
   22554:	008000f4 	movhi	r2,3
   22558:	108faa04 	addi	r2,r2,16040
   2255c:	1885883a 	add	r2,r3,r2
   22560:	00000106 	br	22568 <write+0x40>
   22564:	0005883a 	mov	r2,zero
   22568:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
   2256c:	e0bffb17 	ldw	r2,-20(fp)
   22570:	10001f26 	beq	r2,zero,225f0 <write+0xc8>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
   22574:	e0bffb17 	ldw	r2,-20(fp)
   22578:	10800217 	ldw	r2,8(r2)
   2257c:	108000cc 	andi	r2,r2,3
   22580:	10001726 	beq	r2,zero,225e0 <write+0xb8>
   22584:	e0bffb17 	ldw	r2,-20(fp)
   22588:	10800017 	ldw	r2,0(r2)
   2258c:	10800617 	ldw	r2,24(r2)
   22590:	10001326 	beq	r2,zero,225e0 <write+0xb8>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
   22594:	e0bffb17 	ldw	r2,-20(fp)
   22598:	10800017 	ldw	r2,0(r2)
   2259c:	10c00617 	ldw	r3,24(r2)
   225a0:	e0bfff17 	ldw	r2,-4(fp)
   225a4:	e13ffb17 	ldw	r4,-20(fp)
   225a8:	e17ffe17 	ldw	r5,-8(fp)
   225ac:	100d883a 	mov	r6,r2
   225b0:	183ee83a 	callr	r3
   225b4:	e0bffc15 	stw	r2,-16(fp)
   225b8:	e0bffc17 	ldw	r2,-16(fp)
   225bc:	1000060e 	bge	r2,zero,225d8 <write+0xb0>
      {
        ALT_ERRNO = -rval;
   225c0:	00224d80 	call	224d8 <alt_get_errno>
   225c4:	e0fffc17 	ldw	r3,-16(fp)
   225c8:	00c7c83a 	sub	r3,zero,r3
   225cc:	10c00015 	stw	r3,0(r2)
        return -1;
   225d0:	00bfffc4 	movi	r2,-1
   225d4:	00000a06 	br	22600 <write+0xd8>
      }
      return rval;
   225d8:	e0bffc17 	ldw	r2,-16(fp)
   225dc:	00000806 	br	22600 <write+0xd8>
    }
    else
    {
      ALT_ERRNO = EACCES;
   225e0:	00224d80 	call	224d8 <alt_get_errno>
   225e4:	00c00344 	movi	r3,13
   225e8:	10c00015 	stw	r3,0(r2)
   225ec:	00000306 	br	225fc <write+0xd4>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
   225f0:	00224d80 	call	224d8 <alt_get_errno>
   225f4:	00c01444 	movi	r3,81
   225f8:	10c00015 	stw	r3,0(r2)
  }
  return -1;
   225fc:	00bfffc4 	movi	r2,-1
}
   22600:	e037883a 	mov	sp,fp
   22604:	dfc00117 	ldw	ra,4(sp)
   22608:	df000017 	ldw	fp,0(sp)
   2260c:	dec00204 	addi	sp,sp,8
   22610:	f800283a 	ret

00022614 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
   22614:	defffd04 	addi	sp,sp,-12
   22618:	dfc00215 	stw	ra,8(sp)
   2261c:	df000115 	stw	fp,4(sp)
   22620:	df000104 	addi	fp,sp,4
   22624:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
   22628:	e13fff17 	ldw	r4,-4(fp)
   2262c:	014000f4 	movhi	r5,3
   22630:	29558504 	addi	r5,r5,22036
   22634:	002cd840 	call	2cd84 <alt_dev_llist_insert>
}
   22638:	e037883a 	mov	sp,fp
   2263c:	dfc00117 	ldw	ra,4(sp)
   22640:	df000017 	ldw	fp,0(sp)
   22644:	dec00204 	addi	sp,sp,8
   22648:	f800283a 	ret

0002264c <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
   2264c:	defffd04 	addi	sp,sp,-12
   22650:	dfc00215 	stw	ra,8(sp)
   22654:	df000115 	stw	fp,4(sp)
   22658:	df000104 	addi	fp,sp,4
   2265c:	e13fff15 	stw	r4,-4(fp)
    ALTERA_VIC_IRQ_INIT ( VIC_0, vic_0);
   22660:	010000f4 	movhi	r4,3
   22664:	21100a04 	addi	r4,r4,16424
   22668:	002c9380 	call	2c938 <alt_vic_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
   2266c:	00802034 	movhi	r2,128
   22670:	10800044 	addi	r2,r2,1
   22674:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
   22678:	e037883a 	mov	sp,fp
   2267c:	dfc00117 	ldw	ra,4(sp)
   22680:	df000017 	ldw	fp,0(sp)
   22684:	dec00204 	addi	sp,sp,8
   22688:	f800283a 	ret

0002268c <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
   2268c:	defffe04 	addi	sp,sp,-8
   22690:	dfc00115 	stw	ra,4(sp)
   22694:	df000015 	stw	fp,0(sp)
   22698:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( SYS_CLK_TIMER, sys_clk_timer);
   2269c:	01020034 	movhi	r4,2048
   226a0:	21005804 	addi	r4,r4,352
   226a4:	000b883a 	mov	r5,zero
   226a8:	000d883a 	mov	r6,zero
   226ac:	01c0fa04 	movi	r7,1000
   226b0:	0026bfc0 	call	26bfc <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
   226b4:	008000f4 	movhi	r2,3
   226b8:	109e4f04 	addi	r2,r2,31036
   226bc:	00c20034 	movhi	r3,2048
   226c0:	18c08004 	addi	r3,r3,512
   226c4:	10c00015 	stw	r3,0(r2)
   226c8:	008000f4 	movhi	r2,3
   226cc:	109e5004 	addi	r2,r2,31040
   226d0:	00c0e534 	movhi	r3,916
   226d4:	18e1c004 	addi	r3,r3,-30976
   226d8:	10c00015 	stw	r3,0(r2)
    ALTERA_AVALON_TIMER_INIT ( TIMER_5, timer_5);
    ALTERA_AVALON_TIMER_INIT ( TIMER_6, timer_6);
    ALTERA_AVALON_TIMER_INIT ( TIMER_7, timer_7);
    ALTERA_AVALON_TIMER_INIT ( TIMER_8, timer_8);
    ALTERA_AVALON_TIMER_INIT ( TIMER_9, timer_9);
    ALTERA_AVALON_CFI_FLASH_INIT ( EXT_FLASH, ext_flash);
   226dc:	010000f4 	movhi	r4,3
   226e0:	21103104 	addi	r4,r4,16580
   226e4:	00227fc0 	call	227fc <alt_flash_cfi_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
   226e8:	010000f4 	movhi	r4,3
   226ec:	21107104 	addi	r4,r4,16836
   226f0:	000b883a 	mov	r5,zero
   226f4:	01800044 	movi	r6,1
   226f8:	00245ec0 	call	245ec <altera_avalon_jtag_uart_init>
   226fc:	010000f4 	movhi	r4,3
   22700:	21106704 	addi	r4,r4,16796
   22704:	00226140 	call	22614 <alt_dev_reg>
    ALTERA_AVALON_LCD_16207_INIT ( LCD, lcd);
   22708:	010000f4 	movhi	r4,3
   2270c:	21148904 	addi	r4,r4,21028
   22710:	0025c980 	call	25c98 <altera_avalon_lcd_16207_init>
   22714:	010000f4 	movhi	r4,3
   22718:	21147f04 	addi	r4,r4,20988
   2271c:	00226140 	call	22614 <alt_dev_reg>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
   22720:	010000f4 	movhi	r4,3
   22724:	2114c704 	addi	r4,r4,21276
   22728:	000b883a 	mov	r5,zero
   2272c:	01800304 	movi	r6,12
   22730:	0026ab80 	call	26ab8 <alt_avalon_sgdma_init>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TX, sgdma_tx);
   22734:	010000f4 	movhi	r4,3
   22738:	2114d304 	addi	r4,r4,21324
   2273c:	000b883a 	mov	r5,zero
   22740:	01800344 	movi	r6,13
   22744:	0026ab80 	call	26ab8 <alt_avalon_sgdma_init>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, sysid);
   22748:	0001883a 	nop
    ALTERA_AVALON_UART_INIT ( RS232, rs232);
   2274c:	010000f4 	movhi	r4,3
   22750:	2114e904 	addi	r4,r4,21412
   22754:	000b883a 	mov	r5,zero
   22758:	018001c4 	movi	r6,7
   2275c:	002be7c0 	call	2be7c <altera_avalon_uart_init>
   22760:	010000f4 	movhi	r4,3
   22764:	2114df04 	addi	r4,r4,21372
   22768:	00226140 	call	22614 <alt_dev_reg>
    ALTERA_AVALON_UART_INIT ( UART_0, uart_0);
   2276c:	010000f4 	movhi	r4,3
   22770:	21151a04 	addi	r4,r4,21608
   22774:	000b883a 	mov	r5,zero
   22778:	018000c4 	movi	r6,3
   2277c:	002be7c0 	call	2be7c <altera_avalon_uart_init>
   22780:	010000f4 	movhi	r4,3
   22784:	21151004 	addi	r4,r4,21568
   22788:	00226140 	call	22614 <alt_dev_reg>
    ALTERA_AVALON_UART_INIT ( UART_1, uart_1);
   2278c:	010000f4 	movhi	r4,3
   22790:	21154b04 	addi	r4,r4,21804
   22794:	000b883a 	mov	r5,zero
   22798:	01800104 	movi	r6,4
   2279c:	002be7c0 	call	2be7c <altera_avalon_uart_init>
   227a0:	010000f4 	movhi	r4,3
   227a4:	21154104 	addi	r4,r4,21764
   227a8:	00226140 	call	22614 <alt_dev_reg>
    ALTERA_ETH_TSE_INIT ( TSE_MAC, tse_mac);
   227ac:	0001883a 	nop
}
   227b0:	e037883a 	mov	sp,fp
   227b4:	dfc00117 	ldw	ra,4(sp)
   227b8:	df000017 	ldw	fp,0(sp)
   227bc:	dec00204 	addi	sp,sp,8
   227c0:	f800283a 	ret

000227c4 <alt_flash_device_register>:
   227c4:	defffd04 	addi	sp,sp,-12
   227c8:	dfc00215 	stw	ra,8(sp)
   227cc:	df000115 	stw	fp,4(sp)
   227d0:	df000104 	addi	fp,sp,4
   227d4:	e13fff15 	stw	r4,-4(fp)
   227d8:	e13fff17 	ldw	r4,-4(fp)
   227dc:	014000f4 	movhi	r5,3
   227e0:	29559004 	addi	r5,r5,22080
   227e4:	002cd840 	call	2cd84 <alt_dev_llist_insert>
   227e8:	e037883a 	mov	sp,fp
   227ec:	dfc00117 	ldw	ra,4(sp)
   227f0:	df000017 	ldw	fp,0(sp)
   227f4:	dec00204 	addi	sp,sp,8
   227f8:	f800283a 	ret

000227fc <alt_flash_cfi_init>:
   227fc:	defffc04 	addi	sp,sp,-16
   22800:	dfc00315 	stw	ra,12(sp)
   22804:	df000215 	stw	fp,8(sp)
   22808:	df000204 	addi	fp,sp,8
   2280c:	e13fff15 	stw	r4,-4(fp)
   22810:	e03ffe15 	stw	zero,-8(fp)
   22814:	e13fff17 	ldw	r4,-4(fp)
   22818:	0023c440 	call	23c44 <alt_read_cfi_width>
   2281c:	e0bffe15 	stw	r2,-8(fp)
   22820:	e0bffe17 	ldw	r2,-8(fp)
   22824:	1000031e 	bne	r2,zero,22834 <alt_flash_cfi_init+0x38>
   22828:	e13fff17 	ldw	r4,-4(fp)
   2282c:	002339c0 	call	2339c <alt_set_flash_width_func>
   22830:	e0bffe15 	stw	r2,-8(fp)
   22834:	e0bffe17 	ldw	r2,-8(fp)
   22838:	1000031e 	bne	r2,zero,22848 <alt_flash_cfi_init+0x4c>
   2283c:	e13fff17 	ldw	r4,-4(fp)
   22840:	002367c0 	call	2367c <alt_read_cfi_table>
   22844:	e0bffe15 	stw	r2,-8(fp)
   22848:	e0bffe17 	ldw	r2,-8(fp)
   2284c:	1000031e 	bne	r2,zero,2285c <alt_flash_cfi_init+0x60>
   22850:	e13fff17 	ldw	r4,-4(fp)
   22854:	00235600 	call	23560 <alt_set_flash_algorithm_func>
   22858:	e0bffe15 	stw	r2,-8(fp)
   2285c:	e0bffe17 	ldw	r2,-8(fp)
   22860:	1000041e 	bne	r2,zero,22874 <alt_flash_cfi_init+0x78>
   22864:	e0bfff17 	ldw	r2,-4(fp)
   22868:	1009883a 	mov	r4,r2
   2286c:	00227c40 	call	227c4 <alt_flash_device_register>
   22870:	e0bffe15 	stw	r2,-8(fp)
   22874:	e0bffe17 	ldw	r2,-8(fp)
   22878:	e037883a 	mov	sp,fp
   2287c:	dfc00117 	ldw	ra,4(sp)
   22880:	df000017 	ldw	fp,0(sp)
   22884:	dec00204 	addi	sp,sp,8
   22888:	f800283a 	ret

0002288c <alt_flash_cfi_write>:
   2288c:	defff104 	addi	sp,sp,-60
   22890:	dfc00e15 	stw	ra,56(sp)
   22894:	df000d15 	stw	fp,52(sp)
   22898:	df000d04 	addi	fp,sp,52
   2289c:	e13ffc15 	stw	r4,-16(fp)
   228a0:	e17ffd15 	stw	r5,-12(fp)
   228a4:	e1bffe15 	stw	r6,-8(fp)
   228a8:	e1ffff15 	stw	r7,-4(fp)
   228ac:	e03ff415 	stw	zero,-48(fp)
   228b0:	e0bfff17 	ldw	r2,-4(fp)
   228b4:	e0bff815 	stw	r2,-32(fp)
   228b8:	e0bffd17 	ldw	r2,-12(fp)
   228bc:	e0bff915 	stw	r2,-28(fp)
   228c0:	e0bffc17 	ldw	r2,-16(fp)
   228c4:	e0bffa15 	stw	r2,-24(fp)
   228c8:	e03ff515 	stw	zero,-44(fp)
   228cc:	00008806 	br	22af0 <alt_flash_cfi_write+0x264>
   228d0:	e0fffa17 	ldw	r3,-24(fp)
   228d4:	e0bff517 	ldw	r2,-44(fp)
   228d8:	1004913a 	slli	r2,r2,4
   228dc:	1885883a 	add	r2,r3,r2
   228e0:	10800d04 	addi	r2,r2,52
   228e4:	10800017 	ldw	r2,0(r2)
   228e8:	e0fffd17 	ldw	r3,-12(fp)
   228ec:	18807d16 	blt	r3,r2,22ae4 <alt_flash_cfi_write+0x258>
   228f0:	e0fffa17 	ldw	r3,-24(fp)
   228f4:	e0bff517 	ldw	r2,-44(fp)
   228f8:	1004913a 	slli	r2,r2,4
   228fc:	1885883a 	add	r2,r3,r2
   22900:	10800d04 	addi	r2,r2,52
   22904:	10c00017 	ldw	r3,0(r2)
   22908:	e13ffa17 	ldw	r4,-24(fp)
   2290c:	e0bff517 	ldw	r2,-44(fp)
   22910:	1004913a 	slli	r2,r2,4
   22914:	2085883a 	add	r2,r4,r2
   22918:	10800e04 	addi	r2,r2,56
   2291c:	10800017 	ldw	r2,0(r2)
   22920:	1885883a 	add	r2,r3,r2
   22924:	e0fffd17 	ldw	r3,-12(fp)
   22928:	18806e0e 	bge	r3,r2,22ae4 <alt_flash_cfi_write+0x258>
   2292c:	e0fffa17 	ldw	r3,-24(fp)
   22930:	e0bff517 	ldw	r2,-44(fp)
   22934:	1004913a 	slli	r2,r2,4
   22938:	1885883a 	add	r2,r3,r2
   2293c:	10800d04 	addi	r2,r2,52
   22940:	10800017 	ldw	r2,0(r2)
   22944:	e0bff715 	stw	r2,-36(fp)
   22948:	e03ff615 	stw	zero,-40(fp)
   2294c:	00005d06 	br	22ac4 <alt_flash_cfi_write+0x238>
   22950:	e0fffd17 	ldw	r3,-12(fp)
   22954:	e0bff717 	ldw	r2,-36(fp)
   22958:	18804e16 	blt	r3,r2,22a94 <alt_flash_cfi_write+0x208>
   2295c:	e0fffa17 	ldw	r3,-24(fp)
   22960:	e0bff517 	ldw	r2,-44(fp)
   22964:	10800104 	addi	r2,r2,4
   22968:	1004913a 	slli	r2,r2,4
   2296c:	1885883a 	add	r2,r3,r2
   22970:	10c00017 	ldw	r3,0(r2)
   22974:	e0bff717 	ldw	r2,-36(fp)
   22978:	1885883a 	add	r2,r3,r2
   2297c:	e0fffd17 	ldw	r3,-12(fp)
   22980:	1880440e 	bge	r3,r2,22a94 <alt_flash_cfi_write+0x208>
   22984:	e0fffa17 	ldw	r3,-24(fp)
   22988:	e0bff517 	ldw	r2,-44(fp)
   2298c:	10800104 	addi	r2,r2,4
   22990:	1004913a 	slli	r2,r2,4
   22994:	1885883a 	add	r2,r3,r2
   22998:	10c00017 	ldw	r3,0(r2)
   2299c:	e0bff717 	ldw	r2,-36(fp)
   229a0:	1887883a 	add	r3,r3,r2
   229a4:	e0bffd17 	ldw	r2,-12(fp)
   229a8:	1885c83a 	sub	r2,r3,r2
   229ac:	e0bffb15 	stw	r2,-20(fp)
   229b0:	e0fffb17 	ldw	r3,-20(fp)
   229b4:	e0bfff17 	ldw	r2,-4(fp)
   229b8:	1880010e 	bge	r3,r2,229c0 <alt_flash_cfi_write+0x134>
   229bc:	1805883a 	mov	r2,r3
   229c0:	e0bffb15 	stw	r2,-20(fp)
   229c4:	e0bffa17 	ldw	r2,-24(fp)
   229c8:	10c00a17 	ldw	r3,40(r2)
   229cc:	e0bffd17 	ldw	r2,-12(fp)
   229d0:	1887883a 	add	r3,r3,r2
   229d4:	e0bffb17 	ldw	r2,-20(fp)
   229d8:	e13ffe17 	ldw	r4,-8(fp)
   229dc:	180b883a 	mov	r5,r3
   229e0:	100d883a 	mov	r6,r2
   229e4:	00191740 	call	19174 <memcmp>
   229e8:	10001426 	beq	r2,zero,22a3c <alt_flash_cfi_write+0x1b0>
   229ec:	e0bffa17 	ldw	r2,-24(fp)
   229f0:	10c00817 	ldw	r3,32(r2)
   229f4:	e0bffa17 	ldw	r2,-24(fp)
   229f8:	1009883a 	mov	r4,r2
   229fc:	e17ff717 	ldw	r5,-36(fp)
   22a00:	183ee83a 	callr	r3
   22a04:	e0bff415 	stw	r2,-48(fp)
   22a08:	e0bff417 	ldw	r2,-48(fp)
   22a0c:	10000b1e 	bne	r2,zero,22a3c <alt_flash_cfi_write+0x1b0>
   22a10:	e0bffa17 	ldw	r2,-24(fp)
   22a14:	10c00917 	ldw	r3,36(r2)
   22a18:	e0bffa17 	ldw	r2,-24(fp)
   22a1c:	e13ffb17 	ldw	r4,-20(fp)
   22a20:	d9000015 	stw	r4,0(sp)
   22a24:	1009883a 	mov	r4,r2
   22a28:	e17ff717 	ldw	r5,-36(fp)
   22a2c:	e1bffd17 	ldw	r6,-12(fp)
   22a30:	e1fffe17 	ldw	r7,-8(fp)
   22a34:	183ee83a 	callr	r3
   22a38:	e0bff415 	stw	r2,-48(fp)
   22a3c:	e0ffff17 	ldw	r3,-4(fp)
   22a40:	e0bffb17 	ldw	r2,-20(fp)
   22a44:	18802e26 	beq	r3,r2,22b00 <alt_flash_cfi_write+0x274>
   22a48:	e0bff417 	ldw	r2,-48(fp)
   22a4c:	10002c1e 	bne	r2,zero,22b00 <alt_flash_cfi_write+0x274>
   22a50:	e0ffff17 	ldw	r3,-4(fp)
   22a54:	e0bffb17 	ldw	r2,-20(fp)
   22a58:	1885c83a 	sub	r2,r3,r2
   22a5c:	e0bfff15 	stw	r2,-4(fp)
   22a60:	e0fffa17 	ldw	r3,-24(fp)
   22a64:	e0bff517 	ldw	r2,-44(fp)
   22a68:	10800104 	addi	r2,r2,4
   22a6c:	1004913a 	slli	r2,r2,4
   22a70:	1885883a 	add	r2,r3,r2
   22a74:	10c00017 	ldw	r3,0(r2)
   22a78:	e0bff717 	ldw	r2,-36(fp)
   22a7c:	1885883a 	add	r2,r3,r2
   22a80:	e0bffd15 	stw	r2,-12(fp)
   22a84:	e0bffb17 	ldw	r2,-20(fp)
   22a88:	e0fffe17 	ldw	r3,-8(fp)
   22a8c:	1885883a 	add	r2,r3,r2
   22a90:	e0bffe15 	stw	r2,-8(fp)
   22a94:	e0fffa17 	ldw	r3,-24(fp)
   22a98:	e0bff517 	ldw	r2,-44(fp)
   22a9c:	10800104 	addi	r2,r2,4
   22aa0:	1004913a 	slli	r2,r2,4
   22aa4:	1885883a 	add	r2,r3,r2
   22aa8:	10800017 	ldw	r2,0(r2)
   22aac:	e0fff717 	ldw	r3,-36(fp)
   22ab0:	1885883a 	add	r2,r3,r2
   22ab4:	e0bff715 	stw	r2,-36(fp)
   22ab8:	e0bff617 	ldw	r2,-40(fp)
   22abc:	10800044 	addi	r2,r2,1
   22ac0:	e0bff615 	stw	r2,-40(fp)
   22ac4:	e0fffa17 	ldw	r3,-24(fp)
   22ac8:	e0bff517 	ldw	r2,-44(fp)
   22acc:	1004913a 	slli	r2,r2,4
   22ad0:	1885883a 	add	r2,r3,r2
   22ad4:	10800f04 	addi	r2,r2,60
   22ad8:	10800017 	ldw	r2,0(r2)
   22adc:	e0fff617 	ldw	r3,-40(fp)
   22ae0:	18bf9b16 	blt	r3,r2,22950 <alt_flash_cfi_write+0xc4>
   22ae4:	e0bff517 	ldw	r2,-44(fp)
   22ae8:	10800044 	addi	r2,r2,1
   22aec:	e0bff515 	stw	r2,-44(fp)
   22af0:	e0bffa17 	ldw	r2,-24(fp)
   22af4:	10800c17 	ldw	r2,48(r2)
   22af8:	e0fff517 	ldw	r3,-44(fp)
   22afc:	18bf7416 	blt	r3,r2,228d0 <alt_flash_cfi_write+0x44>
   22b00:	e0bffa17 	ldw	r2,-24(fp)
   22b04:	10c00a17 	ldw	r3,40(r2)
   22b08:	e0bff917 	ldw	r2,-28(fp)
   22b0c:	1887883a 	add	r3,r3,r2
   22b10:	e0bff817 	ldw	r2,-32(fp)
   22b14:	1809883a 	mov	r4,r3
   22b18:	100b883a 	mov	r5,r2
   22b1c:	002ccf40 	call	2ccf4 <alt_dcache_flush>
   22b20:	e0bff417 	ldw	r2,-48(fp)
   22b24:	e037883a 	mov	sp,fp
   22b28:	dfc00117 	ldw	ra,4(sp)
   22b2c:	df000017 	ldw	fp,0(sp)
   22b30:	dec00204 	addi	sp,sp,8
   22b34:	f800283a 	ret

00022b38 <alt_flash_cfi_get_info>:
   22b38:	defffa04 	addi	sp,sp,-24
   22b3c:	df000515 	stw	fp,20(sp)
   22b40:	df000504 	addi	fp,sp,20
   22b44:	e13ffd15 	stw	r4,-12(fp)
   22b48:	e17ffe15 	stw	r5,-8(fp)
   22b4c:	e1bfff15 	stw	r6,-4(fp)
   22b50:	e03ffb15 	stw	zero,-20(fp)
   22b54:	e0bffd17 	ldw	r2,-12(fp)
   22b58:	e0bffc15 	stw	r2,-16(fp)
   22b5c:	e0bffc17 	ldw	r2,-16(fp)
   22b60:	10c00c17 	ldw	r3,48(r2)
   22b64:	e0bfff17 	ldw	r2,-4(fp)
   22b68:	10c00015 	stw	r3,0(r2)
   22b6c:	e0bffc17 	ldw	r2,-16(fp)
   22b70:	10800c17 	ldw	r2,48(r2)
   22b74:	1000031e 	bne	r2,zero,22b84 <alt_flash_cfi_get_info+0x4c>
   22b78:	00bffec4 	movi	r2,-5
   22b7c:	e0bffb15 	stw	r2,-20(fp)
   22b80:	00000b06 	br	22bb0 <alt_flash_cfi_get_info+0x78>
   22b84:	e0bffc17 	ldw	r2,-16(fp)
   22b88:	10800c17 	ldw	r2,48(r2)
   22b8c:	10800250 	cmplti	r2,r2,9
   22b90:	1000031e 	bne	r2,zero,22ba0 <alt_flash_cfi_get_info+0x68>
   22b94:	00bffd04 	movi	r2,-12
   22b98:	e0bffb15 	stw	r2,-20(fp)
   22b9c:	00000406 	br	22bb0 <alt_flash_cfi_get_info+0x78>
   22ba0:	e0bffc17 	ldw	r2,-16(fp)
   22ba4:	10c00d04 	addi	r3,r2,52
   22ba8:	e0bffe17 	ldw	r2,-8(fp)
   22bac:	10c00015 	stw	r3,0(r2)
   22bb0:	e0bffb17 	ldw	r2,-20(fp)
   22bb4:	e037883a 	mov	sp,fp
   22bb8:	df000017 	ldw	fp,0(sp)
   22bbc:	dec00104 	addi	sp,sp,4
   22bc0:	f800283a 	ret

00022bc4 <alt_flash_cfi_read>:
   22bc4:	defff904 	addi	sp,sp,-28
   22bc8:	dfc00615 	stw	ra,24(sp)
   22bcc:	df000515 	stw	fp,20(sp)
   22bd0:	df000504 	addi	fp,sp,20
   22bd4:	e13ffc15 	stw	r4,-16(fp)
   22bd8:	e17ffd15 	stw	r5,-12(fp)
   22bdc:	e1bffe15 	stw	r6,-8(fp)
   22be0:	e1ffff15 	stw	r7,-4(fp)
   22be4:	e0bffc17 	ldw	r2,-16(fp)
   22be8:	e0bffb15 	stw	r2,-20(fp)
   22bec:	e0bffb17 	ldw	r2,-20(fp)
   22bf0:	10c00a17 	ldw	r3,40(r2)
   22bf4:	e0bffd17 	ldw	r2,-12(fp)
   22bf8:	1887883a 	add	r3,r3,r2
   22bfc:	e0bfff17 	ldw	r2,-4(fp)
   22c00:	e13ffe17 	ldw	r4,-8(fp)
   22c04:	180b883a 	mov	r5,r3
   22c08:	100d883a 	mov	r6,r2
   22c0c:	00191f00 	call	191f0 <memcpy>
   22c10:	0005883a 	mov	r2,zero
   22c14:	e037883a 	mov	sp,fp
   22c18:	dfc00117 	ldw	ra,4(sp)
   22c1c:	df000017 	ldw	fp,0(sp)
   22c20:	dec00204 	addi	sp,sp,8
   22c24:	f800283a 	ret

00022c28 <alt_write_value_to_flash>:
   22c28:	defffa04 	addi	sp,sp,-24
   22c2c:	df000515 	stw	fp,20(sp)
   22c30:	df000504 	addi	fp,sp,20
   22c34:	e13ffd15 	stw	r4,-12(fp)
   22c38:	e17ffe15 	stw	r5,-8(fp)
   22c3c:	e1bfff15 	stw	r6,-4(fp)
   22c40:	e0bffd17 	ldw	r2,-12(fp)
   22c44:	10802e17 	ldw	r2,184(r2)
   22c48:	10800058 	cmpnei	r2,r2,1
   22c4c:	1000091e 	bne	r2,zero,22c74 <alt_write_value_to_flash+0x4c>
   22c50:	e0bffd17 	ldw	r2,-12(fp)
   22c54:	10c00a17 	ldw	r3,40(r2)
   22c58:	e0bffe17 	ldw	r2,-8(fp)
   22c5c:	1885883a 	add	r2,r3,r2
   22c60:	e0ffff17 	ldw	r3,-4(fp)
   22c64:	18c00003 	ldbu	r3,0(r3)
   22c68:	18c03fcc 	andi	r3,r3,255
   22c6c:	10c00025 	stbio	r3,0(r2)
   22c70:	00003e06 	br	22d6c <alt_write_value_to_flash+0x144>
   22c74:	e0bffd17 	ldw	r2,-12(fp)
   22c78:	10802e17 	ldw	r2,184(r2)
   22c7c:	10800098 	cmpnei	r2,r2,2
   22c80:	1000141e 	bne	r2,zero,22cd4 <alt_write_value_to_flash+0xac>
   22c84:	e0bfff17 	ldw	r2,-4(fp)
   22c88:	10800003 	ldbu	r2,0(r2)
   22c8c:	10803fcc 	andi	r2,r2,255
   22c90:	e0bffb0d 	sth	r2,-20(fp)
   22c94:	e0bfff17 	ldw	r2,-4(fp)
   22c98:	10800044 	addi	r2,r2,1
   22c9c:	10800003 	ldbu	r2,0(r2)
   22ca0:	10803fcc 	andi	r2,r2,255
   22ca4:	1004923a 	slli	r2,r2,8
   22ca8:	1007883a 	mov	r3,r2
   22cac:	e0bffb0b 	ldhu	r2,-20(fp)
   22cb0:	1884b03a 	or	r2,r3,r2
   22cb4:	e0bffb0d 	sth	r2,-20(fp)
   22cb8:	e0bffd17 	ldw	r2,-12(fp)
   22cbc:	10c00a17 	ldw	r3,40(r2)
   22cc0:	e0bffe17 	ldw	r2,-8(fp)
   22cc4:	1885883a 	add	r2,r3,r2
   22cc8:	e0fffb0b 	ldhu	r3,-20(fp)
   22ccc:	10c0002d 	sthio	r3,0(r2)
   22cd0:	00002606 	br	22d6c <alt_write_value_to_flash+0x144>
   22cd4:	e0bffd17 	ldw	r2,-12(fp)
   22cd8:	10802e17 	ldw	r2,184(r2)
   22cdc:	10800118 	cmpnei	r2,r2,4
   22ce0:	1000221e 	bne	r2,zero,22d6c <alt_write_value_to_flash+0x144>
   22ce4:	e0bfff17 	ldw	r2,-4(fp)
   22ce8:	10800003 	ldbu	r2,0(r2)
   22cec:	10803fcc 	andi	r2,r2,255
   22cf0:	e0bffc15 	stw	r2,-16(fp)
   22cf4:	e0bfff17 	ldw	r2,-4(fp)
   22cf8:	10800044 	addi	r2,r2,1
   22cfc:	10800003 	ldbu	r2,0(r2)
   22d00:	10803fcc 	andi	r2,r2,255
   22d04:	1004923a 	slli	r2,r2,8
   22d08:	e0fffc17 	ldw	r3,-16(fp)
   22d0c:	1884b03a 	or	r2,r3,r2
   22d10:	e0bffc15 	stw	r2,-16(fp)
   22d14:	e0bfff17 	ldw	r2,-4(fp)
   22d18:	10800084 	addi	r2,r2,2
   22d1c:	10800003 	ldbu	r2,0(r2)
   22d20:	10803fcc 	andi	r2,r2,255
   22d24:	1004943a 	slli	r2,r2,16
   22d28:	e0fffc17 	ldw	r3,-16(fp)
   22d2c:	1884b03a 	or	r2,r3,r2
   22d30:	e0bffc15 	stw	r2,-16(fp)
   22d34:	e0bfff17 	ldw	r2,-4(fp)
   22d38:	108000c4 	addi	r2,r2,3
   22d3c:	10800003 	ldbu	r2,0(r2)
   22d40:	10803fcc 	andi	r2,r2,255
   22d44:	1004963a 	slli	r2,r2,24
   22d48:	e0fffc17 	ldw	r3,-16(fp)
   22d4c:	1884b03a 	or	r2,r3,r2
   22d50:	e0bffc15 	stw	r2,-16(fp)
   22d54:	e0bffd17 	ldw	r2,-12(fp)
   22d58:	10c00a17 	ldw	r3,40(r2)
   22d5c:	e0bffe17 	ldw	r2,-8(fp)
   22d60:	1885883a 	add	r2,r3,r2
   22d64:	e0fffc17 	ldw	r3,-16(fp)
   22d68:	10c00035 	stwio	r3,0(r2)
   22d6c:	0001883a 	nop
   22d70:	e037883a 	mov	sp,fp
   22d74:	df000017 	ldw	fp,0(sp)
   22d78:	dec00104 	addi	sp,sp,4
   22d7c:	f800283a 	ret

00022d80 <alt_flash_program_block>:
   22d80:	defff304 	addi	sp,sp,-52
   22d84:	dfc00c15 	stw	ra,48(sp)
   22d88:	df000b15 	stw	fp,44(sp)
   22d8c:	df000b04 	addi	fp,sp,44
   22d90:	e13ffc15 	stw	r4,-16(fp)
   22d94:	e17ffd15 	stw	r5,-12(fp)
   22d98:	e1bffe15 	stw	r6,-8(fp)
   22d9c:	e1ffff15 	stw	r7,-4(fp)
   22da0:	e03ff515 	stw	zero,-44(fp)
   22da4:	e0bffc17 	ldw	r2,-16(fp)
   22da8:	10c00a17 	ldw	r3,40(r2)
   22dac:	e0bffd17 	ldw	r2,-12(fp)
   22db0:	1885883a 	add	r2,r3,r2
   22db4:	e0fffc17 	ldw	r3,-16(fp)
   22db8:	18c02e17 	ldw	r3,184(r3)
   22dbc:	10c9283a 	div	r4,r2,r3
   22dc0:	20c7383a 	mul	r3,r4,r3
   22dc4:	10c5c83a 	sub	r2,r2,r3
   22dc8:	e0bff815 	stw	r2,-32(fp)
   22dcc:	e0bff817 	ldw	r2,-32(fp)
   22dd0:	10003b26 	beq	r2,zero,22ec0 <alt_flash_program_block+0x140>
   22dd4:	e0bffc17 	ldw	r2,-16(fp)
   22dd8:	10c02e17 	ldw	r3,184(r2)
   22ddc:	e0bff817 	ldw	r2,-32(fp)
   22de0:	1885c83a 	sub	r2,r3,r2
   22de4:	e0bff915 	stw	r2,-28(fp)
   22de8:	e03ff615 	stw	zero,-40(fp)
   22dec:	00001206 	br	22e38 <alt_flash_program_block+0xb8>
   22df0:	e0bffc17 	ldw	r2,-16(fp)
   22df4:	10c00a17 	ldw	r3,40(r2)
   22df8:	e13ffd17 	ldw	r4,-12(fp)
   22dfc:	e0bff817 	ldw	r2,-32(fp)
   22e00:	2089c83a 	sub	r4,r4,r2
   22e04:	e0bff617 	ldw	r2,-40(fp)
   22e08:	2085883a 	add	r2,r4,r2
   22e0c:	1885883a 	add	r2,r3,r2
   22e10:	10800023 	ldbuio	r2,0(r2)
   22e14:	10803fcc 	andi	r2,r2,255
   22e18:	1007883a 	mov	r3,r2
   22e1c:	e13ffb04 	addi	r4,fp,-20
   22e20:	e0bff617 	ldw	r2,-40(fp)
   22e24:	2085883a 	add	r2,r4,r2
   22e28:	10c00005 	stb	r3,0(r2)
   22e2c:	e0bff617 	ldw	r2,-40(fp)
   22e30:	10800044 	addi	r2,r2,1
   22e34:	e0bff615 	stw	r2,-40(fp)
   22e38:	e0fff617 	ldw	r3,-40(fp)
   22e3c:	e0bff817 	ldw	r2,-32(fp)
   22e40:	18bfeb16 	blt	r3,r2,22df0 <alt_flash_program_block+0x70>
   22e44:	e03ff615 	stw	zero,-40(fp)
   22e48:	00000d06 	br	22e80 <alt_flash_program_block+0x100>
   22e4c:	e0fff817 	ldw	r3,-32(fp)
   22e50:	e0bff617 	ldw	r2,-40(fp)
   22e54:	1885883a 	add	r2,r3,r2
   22e58:	e0fff617 	ldw	r3,-40(fp)
   22e5c:	e13ffe17 	ldw	r4,-8(fp)
   22e60:	20c7883a 	add	r3,r4,r3
   22e64:	18c00003 	ldbu	r3,0(r3)
   22e68:	e13ffb04 	addi	r4,fp,-20
   22e6c:	2085883a 	add	r2,r4,r2
   22e70:	10c00005 	stb	r3,0(r2)
   22e74:	e0bff617 	ldw	r2,-40(fp)
   22e78:	10800044 	addi	r2,r2,1
   22e7c:	e0bff615 	stw	r2,-40(fp)
   22e80:	e0fff617 	ldw	r3,-40(fp)
   22e84:	e0bff917 	ldw	r2,-28(fp)
   22e88:	18bff016 	blt	r3,r2,22e4c <alt_flash_program_block+0xcc>
   22e8c:	e0fffd17 	ldw	r3,-12(fp)
   22e90:	e0bff817 	ldw	r2,-32(fp)
   22e94:	1887c83a 	sub	r3,r3,r2
   22e98:	e0bffb04 	addi	r2,fp,-20
   22e9c:	e1c00217 	ldw	r7,8(fp)
   22ea0:	e13ffc17 	ldw	r4,-16(fp)
   22ea4:	180b883a 	mov	r5,r3
   22ea8:	100d883a 	mov	r6,r2
   22eac:	383ee83a 	callr	r7
   22eb0:	e0bff515 	stw	r2,-44(fp)
   22eb4:	e0bff917 	ldw	r2,-28(fp)
   22eb8:	e0bff615 	stw	r2,-40(fp)
   22ebc:	00000106 	br	22ec4 <alt_flash_program_block+0x144>
   22ec0:	e03ff615 	stw	zero,-40(fp)
   22ec4:	e0fffd17 	ldw	r3,-12(fp)
   22ec8:	e0bfff17 	ldw	r2,-4(fp)
   22ecc:	1885883a 	add	r2,r3,r2
   22ed0:	e0fffc17 	ldw	r3,-16(fp)
   22ed4:	18c02e17 	ldw	r3,184(r3)
   22ed8:	10c9283a 	div	r4,r2,r3
   22edc:	20c7383a 	mul	r3,r4,r3
   22ee0:	10c5c83a 	sub	r2,r2,r3
   22ee4:	e0bffa15 	stw	r2,-24(fp)
   22ee8:	00001106 	br	22f30 <alt_flash_program_block+0x1b0>
   22eec:	e0fffd17 	ldw	r3,-12(fp)
   22ef0:	e0bff617 	ldw	r2,-40(fp)
   22ef4:	1887883a 	add	r3,r3,r2
   22ef8:	e0bff617 	ldw	r2,-40(fp)
   22efc:	e13ffe17 	ldw	r4,-8(fp)
   22f00:	2085883a 	add	r2,r4,r2
   22f04:	e1c00217 	ldw	r7,8(fp)
   22f08:	e13ffc17 	ldw	r4,-16(fp)
   22f0c:	180b883a 	mov	r5,r3
   22f10:	100d883a 	mov	r6,r2
   22f14:	383ee83a 	callr	r7
   22f18:	e0bff515 	stw	r2,-44(fp)
   22f1c:	e0bffc17 	ldw	r2,-16(fp)
   22f20:	10802e17 	ldw	r2,184(r2)
   22f24:	e0fff617 	ldw	r3,-40(fp)
   22f28:	1885883a 	add	r2,r3,r2
   22f2c:	e0bff615 	stw	r2,-40(fp)
   22f30:	e0bff517 	ldw	r2,-44(fp)
   22f34:	1000051e 	bne	r2,zero,22f4c <alt_flash_program_block+0x1cc>
   22f38:	e0ffff17 	ldw	r3,-4(fp)
   22f3c:	e0bffa17 	ldw	r2,-24(fp)
   22f40:	1885c83a 	sub	r2,r3,r2
   22f44:	e0fff617 	ldw	r3,-40(fp)
   22f48:	18bfe816 	blt	r3,r2,22eec <alt_flash_program_block+0x16c>
   22f4c:	e0bffa17 	ldw	r2,-24(fp)
   22f50:	10003b26 	beq	r2,zero,23040 <alt_flash_program_block+0x2c0>
   22f54:	e0bff517 	ldw	r2,-44(fp)
   22f58:	1000391e 	bne	r2,zero,23040 <alt_flash_program_block+0x2c0>
   22f5c:	e0bffc17 	ldw	r2,-16(fp)
   22f60:	10c02e17 	ldw	r3,184(r2)
   22f64:	e0bffa17 	ldw	r2,-24(fp)
   22f68:	1885c83a 	sub	r2,r3,r2
   22f6c:	e0bff815 	stw	r2,-32(fp)
   22f70:	e03ff715 	stw	zero,-36(fp)
   22f74:	00000d06 	br	22fac <alt_flash_program_block+0x22c>
   22f78:	e0fff617 	ldw	r3,-40(fp)
   22f7c:	e0bff717 	ldw	r2,-36(fp)
   22f80:	1885883a 	add	r2,r3,r2
   22f84:	e0fffe17 	ldw	r3,-8(fp)
   22f88:	1885883a 	add	r2,r3,r2
   22f8c:	10c00003 	ldbu	r3,0(r2)
   22f90:	e13ffb04 	addi	r4,fp,-20
   22f94:	e0bff717 	ldw	r2,-36(fp)
   22f98:	2085883a 	add	r2,r4,r2
   22f9c:	10c00005 	stb	r3,0(r2)
   22fa0:	e0bff717 	ldw	r2,-36(fp)
   22fa4:	10800044 	addi	r2,r2,1
   22fa8:	e0bff715 	stw	r2,-36(fp)
   22fac:	e0fff717 	ldw	r3,-36(fp)
   22fb0:	e0bffa17 	ldw	r2,-24(fp)
   22fb4:	18bff016 	blt	r3,r2,22f78 <alt_flash_program_block+0x1f8>
   22fb8:	e03ff715 	stw	zero,-36(fp)
   22fbc:	00001306 	br	2300c <alt_flash_program_block+0x28c>
   22fc0:	e0fffa17 	ldw	r3,-24(fp)
   22fc4:	e0bff717 	ldw	r2,-36(fp)
   22fc8:	1885883a 	add	r2,r3,r2
   22fcc:	e0fffc17 	ldw	r3,-16(fp)
   22fd0:	19000a17 	ldw	r4,40(r3)
   22fd4:	e17ffd17 	ldw	r5,-12(fp)
   22fd8:	e0ffff17 	ldw	r3,-4(fp)
   22fdc:	28cb883a 	add	r5,r5,r3
   22fe0:	e0fff717 	ldw	r3,-36(fp)
   22fe4:	28c7883a 	add	r3,r5,r3
   22fe8:	20c7883a 	add	r3,r4,r3
   22fec:	18c00023 	ldbuio	r3,0(r3)
   22ff0:	18c03fcc 	andi	r3,r3,255
   22ff4:	e13ffb04 	addi	r4,fp,-20
   22ff8:	2085883a 	add	r2,r4,r2
   22ffc:	10c00005 	stb	r3,0(r2)
   23000:	e0bff717 	ldw	r2,-36(fp)
   23004:	10800044 	addi	r2,r2,1
   23008:	e0bff715 	stw	r2,-36(fp)
   2300c:	e0fff717 	ldw	r3,-36(fp)
   23010:	e0bff817 	ldw	r2,-32(fp)
   23014:	18bfea16 	blt	r3,r2,22fc0 <alt_flash_program_block+0x240>
   23018:	e0fffd17 	ldw	r3,-12(fp)
   2301c:	e0bff617 	ldw	r2,-40(fp)
   23020:	1887883a 	add	r3,r3,r2
   23024:	e0bffb04 	addi	r2,fp,-20
   23028:	e1c00217 	ldw	r7,8(fp)
   2302c:	e13ffc17 	ldw	r4,-16(fp)
   23030:	180b883a 	mov	r5,r3
   23034:	100d883a 	mov	r6,r2
   23038:	383ee83a 	callr	r7
   2303c:	e0bff515 	stw	r2,-44(fp)
   23040:	e0bff517 	ldw	r2,-44(fp)
   23044:	e037883a 	mov	sp,fp
   23048:	dfc00117 	ldw	ra,4(sp)
   2304c:	df000017 	ldw	fp,0(sp)
   23050:	dec00204 	addi	sp,sp,8
   23054:	f800283a 	ret

00023058 <alt_read_query_entry_8bit>:
   23058:	defffd04 	addi	sp,sp,-12
   2305c:	df000215 	stw	fp,8(sp)
   23060:	df000204 	addi	fp,sp,8
   23064:	e13ffe15 	stw	r4,-8(fp)
   23068:	e17fff15 	stw	r5,-4(fp)
   2306c:	e0bffe17 	ldw	r2,-8(fp)
   23070:	10c00a17 	ldw	r3,40(r2)
   23074:	e0bfff17 	ldw	r2,-4(fp)
   23078:	1885883a 	add	r2,r3,r2
   2307c:	10800023 	ldbuio	r2,0(r2)
   23080:	10803fcc 	andi	r2,r2,255
   23084:	e037883a 	mov	sp,fp
   23088:	df000017 	ldw	fp,0(sp)
   2308c:	dec00104 	addi	sp,sp,4
   23090:	f800283a 	ret

00023094 <alt_read_query_entry_16bit>:
   23094:	defffd04 	addi	sp,sp,-12
   23098:	df000215 	stw	fp,8(sp)
   2309c:	df000204 	addi	fp,sp,8
   230a0:	e13ffe15 	stw	r4,-8(fp)
   230a4:	e17fff15 	stw	r5,-4(fp)
   230a8:	e0bffe17 	ldw	r2,-8(fp)
   230ac:	10c00a17 	ldw	r3,40(r2)
   230b0:	e0bfff17 	ldw	r2,-4(fp)
   230b4:	1085883a 	add	r2,r2,r2
   230b8:	1885883a 	add	r2,r3,r2
   230bc:	1080002b 	ldhuio	r2,0(r2)
   230c0:	10bfffcc 	andi	r2,r2,65535
   230c4:	e037883a 	mov	sp,fp
   230c8:	df000017 	ldw	fp,0(sp)
   230cc:	dec00104 	addi	sp,sp,4
   230d0:	f800283a 	ret

000230d4 <alt_read_query_entry_32bit>:
   230d4:	defffd04 	addi	sp,sp,-12
   230d8:	df000215 	stw	fp,8(sp)
   230dc:	df000204 	addi	fp,sp,8
   230e0:	e13ffe15 	stw	r4,-8(fp)
   230e4:	e17fff15 	stw	r5,-4(fp)
   230e8:	e0bffe17 	ldw	r2,-8(fp)
   230ec:	10c00a17 	ldw	r3,40(r2)
   230f0:	e0bfff17 	ldw	r2,-4(fp)
   230f4:	1085883a 	add	r2,r2,r2
   230f8:	1085883a 	add	r2,r2,r2
   230fc:	1885883a 	add	r2,r3,r2
   23100:	10800037 	ldwio	r2,0(r2)
   23104:	e037883a 	mov	sp,fp
   23108:	df000017 	ldw	fp,0(sp)
   2310c:	dec00104 	addi	sp,sp,4
   23110:	f800283a 	ret

00023114 <alt_write_flash_command_8bit_device_8bit_mode>:
   23114:	defffc04 	addi	sp,sp,-16
   23118:	df000315 	stw	fp,12(sp)
   2311c:	df000304 	addi	fp,sp,12
   23120:	e13ffd15 	stw	r4,-12(fp)
   23124:	e17ffe15 	stw	r5,-8(fp)
   23128:	3005883a 	mov	r2,r6
   2312c:	e0bfff05 	stb	r2,-4(fp)
   23130:	e0bffe17 	ldw	r2,-8(fp)
   23134:	e0fffd17 	ldw	r3,-12(fp)
   23138:	1885883a 	add	r2,r3,r2
   2313c:	e0ffff03 	ldbu	r3,-4(fp)
   23140:	10c00025 	stbio	r3,0(r2)
   23144:	0001883a 	nop
   23148:	e037883a 	mov	sp,fp
   2314c:	df000017 	ldw	fp,0(sp)
   23150:	dec00104 	addi	sp,sp,4
   23154:	f800283a 	ret

00023158 <alt_write_flash_command_16bit_device_8bit_mode>:
   23158:	defffc04 	addi	sp,sp,-16
   2315c:	df000315 	stw	fp,12(sp)
   23160:	df000304 	addi	fp,sp,12
   23164:	e13ffd15 	stw	r4,-12(fp)
   23168:	e17ffe15 	stw	r5,-8(fp)
   2316c:	3005883a 	mov	r2,r6
   23170:	e0bfff05 	stb	r2,-4(fp)
   23174:	e0bffe17 	ldw	r2,-8(fp)
   23178:	1080004c 	andi	r2,r2,1
   2317c:	10000726 	beq	r2,zero,2319c <alt_write_flash_command_16bit_device_8bit_mode+0x44>
   23180:	e0bffe17 	ldw	r2,-8(fp)
   23184:	1085883a 	add	r2,r2,r2
   23188:	e0fffd17 	ldw	r3,-12(fp)
   2318c:	1885883a 	add	r2,r3,r2
   23190:	e0ffff03 	ldbu	r3,-4(fp)
   23194:	10c00025 	stbio	r3,0(r2)
   23198:	00000706 	br	231b8 <alt_write_flash_command_16bit_device_8bit_mode+0x60>
   2319c:	e0bffe17 	ldw	r2,-8(fp)
   231a0:	1085883a 	add	r2,r2,r2
   231a4:	10800044 	addi	r2,r2,1
   231a8:	e0fffd17 	ldw	r3,-12(fp)
   231ac:	1885883a 	add	r2,r3,r2
   231b0:	e0ffff03 	ldbu	r3,-4(fp)
   231b4:	10c00025 	stbio	r3,0(r2)
   231b8:	0001883a 	nop
   231bc:	e037883a 	mov	sp,fp
   231c0:	df000017 	ldw	fp,0(sp)
   231c4:	dec00104 	addi	sp,sp,4
   231c8:	f800283a 	ret

000231cc <alt_write_flash_command_32bit_device_8bit_mode>:
   231cc:	defffc04 	addi	sp,sp,-16
   231d0:	df000315 	stw	fp,12(sp)
   231d4:	df000304 	addi	fp,sp,12
   231d8:	e13ffd15 	stw	r4,-12(fp)
   231dc:	e17ffe15 	stw	r5,-8(fp)
   231e0:	3005883a 	mov	r2,r6
   231e4:	e0bfff05 	stb	r2,-4(fp)
   231e8:	e0bffe17 	ldw	r2,-8(fp)
   231ec:	1085883a 	add	r2,r2,r2
   231f0:	1085883a 	add	r2,r2,r2
   231f4:	e0fffd17 	ldw	r3,-12(fp)
   231f8:	1885883a 	add	r2,r3,r2
   231fc:	e0ffff03 	ldbu	r3,-4(fp)
   23200:	10c00025 	stbio	r3,0(r2)
   23204:	0001883a 	nop
   23208:	e037883a 	mov	sp,fp
   2320c:	df000017 	ldw	fp,0(sp)
   23210:	dec00104 	addi	sp,sp,4
   23214:	f800283a 	ret

00023218 <alt_write_flash_command_16bit_device_16bit_mode>:
   23218:	defffc04 	addi	sp,sp,-16
   2321c:	df000315 	stw	fp,12(sp)
   23220:	df000304 	addi	fp,sp,12
   23224:	e13ffd15 	stw	r4,-12(fp)
   23228:	e17ffe15 	stw	r5,-8(fp)
   2322c:	3005883a 	mov	r2,r6
   23230:	e0bfff05 	stb	r2,-4(fp)
   23234:	e0bffe17 	ldw	r2,-8(fp)
   23238:	1085883a 	add	r2,r2,r2
   2323c:	e0fffd17 	ldw	r3,-12(fp)
   23240:	1885883a 	add	r2,r3,r2
   23244:	e0ffff03 	ldbu	r3,-4(fp)
   23248:	10c0002d 	sthio	r3,0(r2)
   2324c:	0001883a 	nop
   23250:	e037883a 	mov	sp,fp
   23254:	df000017 	ldw	fp,0(sp)
   23258:	dec00104 	addi	sp,sp,4
   2325c:	f800283a 	ret

00023260 <alt_write_flash_command_32bit_device_16bit_mode>:
   23260:	defffc04 	addi	sp,sp,-16
   23264:	df000315 	stw	fp,12(sp)
   23268:	df000304 	addi	fp,sp,12
   2326c:	e13ffd15 	stw	r4,-12(fp)
   23270:	e17ffe15 	stw	r5,-8(fp)
   23274:	3005883a 	mov	r2,r6
   23278:	e0bfff05 	stb	r2,-4(fp)
   2327c:	e0bffe17 	ldw	r2,-8(fp)
   23280:	1085883a 	add	r2,r2,r2
   23284:	1085883a 	add	r2,r2,r2
   23288:	e0fffd17 	ldw	r3,-12(fp)
   2328c:	1885883a 	add	r2,r3,r2
   23290:	e0ffff03 	ldbu	r3,-4(fp)
   23294:	10c0002d 	sthio	r3,0(r2)
   23298:	0001883a 	nop
   2329c:	e037883a 	mov	sp,fp
   232a0:	df000017 	ldw	fp,0(sp)
   232a4:	dec00104 	addi	sp,sp,4
   232a8:	f800283a 	ret

000232ac <alt_write_flash_command_32bit_device_32bit_mode>:
   232ac:	defffc04 	addi	sp,sp,-16
   232b0:	df000315 	stw	fp,12(sp)
   232b4:	df000304 	addi	fp,sp,12
   232b8:	e13ffd15 	stw	r4,-12(fp)
   232bc:	e17ffe15 	stw	r5,-8(fp)
   232c0:	3005883a 	mov	r2,r6
   232c4:	e0bfff05 	stb	r2,-4(fp)
   232c8:	e0bffe17 	ldw	r2,-8(fp)
   232cc:	1085883a 	add	r2,r2,r2
   232d0:	1085883a 	add	r2,r2,r2
   232d4:	e0fffd17 	ldw	r3,-12(fp)
   232d8:	1885883a 	add	r2,r3,r2
   232dc:	e0ffff03 	ldbu	r3,-4(fp)
   232e0:	10c00035 	stwio	r3,0(r2)
   232e4:	0001883a 	nop
   232e8:	e037883a 	mov	sp,fp
   232ec:	df000017 	ldw	fp,0(sp)
   232f0:	dec00104 	addi	sp,sp,4
   232f4:	f800283a 	ret

000232f8 <alt_write_native_8bit>:
   232f8:	defffd04 	addi	sp,sp,-12
   232fc:	df000215 	stw	fp,8(sp)
   23300:	df000204 	addi	fp,sp,8
   23304:	e13ffe15 	stw	r4,-8(fp)
   23308:	e17fff15 	stw	r5,-4(fp)
   2330c:	e0bfff17 	ldw	r2,-4(fp)
   23310:	10c03fcc 	andi	r3,r2,255
   23314:	e0bffe17 	ldw	r2,-8(fp)
   23318:	10c00025 	stbio	r3,0(r2)
   2331c:	0001883a 	nop
   23320:	e037883a 	mov	sp,fp
   23324:	df000017 	ldw	fp,0(sp)
   23328:	dec00104 	addi	sp,sp,4
   2332c:	f800283a 	ret

00023330 <alt_write_native_16bit>:
   23330:	defffd04 	addi	sp,sp,-12
   23334:	df000215 	stw	fp,8(sp)
   23338:	df000204 	addi	fp,sp,8
   2333c:	e13ffe15 	stw	r4,-8(fp)
   23340:	e17fff15 	stw	r5,-4(fp)
   23344:	e0bfff17 	ldw	r2,-4(fp)
   23348:	10ffffcc 	andi	r3,r2,65535
   2334c:	e0bffe17 	ldw	r2,-8(fp)
   23350:	10c0002d 	sthio	r3,0(r2)
   23354:	0001883a 	nop
   23358:	e037883a 	mov	sp,fp
   2335c:	df000017 	ldw	fp,0(sp)
   23360:	dec00104 	addi	sp,sp,4
   23364:	f800283a 	ret

00023368 <alt_write_native_32bit>:
   23368:	defffd04 	addi	sp,sp,-12
   2336c:	df000215 	stw	fp,8(sp)
   23370:	df000204 	addi	fp,sp,8
   23374:	e13ffe15 	stw	r4,-8(fp)
   23378:	e17fff15 	stw	r5,-4(fp)
   2337c:	e0ffff17 	ldw	r3,-4(fp)
   23380:	e0bffe17 	ldw	r2,-8(fp)
   23384:	10c00035 	stwio	r3,0(r2)
   23388:	0001883a 	nop
   2338c:	e037883a 	mov	sp,fp
   23390:	df000017 	ldw	fp,0(sp)
   23394:	dec00104 	addi	sp,sp,4
   23398:	f800283a 	ret

0002339c <alt_set_flash_width_func>:
   2339c:	defffd04 	addi	sp,sp,-12
   233a0:	df000215 	stw	fp,8(sp)
   233a4:	df000204 	addi	fp,sp,8
   233a8:	e13fff15 	stw	r4,-4(fp)
   233ac:	e03ffe15 	stw	zero,-8(fp)
   233b0:	e0bfff17 	ldw	r2,-4(fp)
   233b4:	10802e17 	ldw	r2,184(r2)
   233b8:	10c000a0 	cmpeqi	r3,r2,2
   233bc:	1800231e 	bne	r3,zero,2344c <alt_set_flash_width_func+0xb0>
   233c0:	10c00120 	cmpeqi	r3,r2,4
   233c4:	1800371e 	bne	r3,zero,234a4 <alt_set_flash_width_func+0x108>
   233c8:	10800060 	cmpeqi	r2,r2,1
   233cc:	10003e26 	beq	r2,zero,234c8 <alt_set_flash_width_func+0x12c>
   233d0:	e0bfff17 	ldw	r2,-4(fp)
   233d4:	00c000b4 	movhi	r3,2
   233d8:	18ccbe04 	addi	r3,r3,13048
   233dc:	10c03515 	stw	r3,212(r2)
   233e0:	e0bfff17 	ldw	r2,-4(fp)
   233e4:	10802f17 	ldw	r2,188(r2)
   233e8:	10800058 	cmpnei	r2,r2,1
   233ec:	1000051e 	bne	r2,zero,23404 <alt_set_flash_width_func+0x68>
   233f0:	e0bfff17 	ldw	r2,-4(fp)
   233f4:	00c000b4 	movhi	r3,2
   233f8:	18cc4504 	addi	r3,r3,12564
   233fc:	10c03315 	stw	r3,204(r2)
   23400:	00003406 	br	234d4 <alt_set_flash_width_func+0x138>
   23404:	e0bfff17 	ldw	r2,-4(fp)
   23408:	10802f17 	ldw	r2,188(r2)
   2340c:	10800098 	cmpnei	r2,r2,2
   23410:	1000051e 	bne	r2,zero,23428 <alt_set_flash_width_func+0x8c>
   23414:	e0bfff17 	ldw	r2,-4(fp)
   23418:	00c000b4 	movhi	r3,2
   2341c:	18cc5604 	addi	r3,r3,12632
   23420:	10c03315 	stw	r3,204(r2)
   23424:	00002b06 	br	234d4 <alt_set_flash_width_func+0x138>
   23428:	e0bfff17 	ldw	r2,-4(fp)
   2342c:	10802f17 	ldw	r2,188(r2)
   23430:	10800118 	cmpnei	r2,r2,4
   23434:	1000271e 	bne	r2,zero,234d4 <alt_set_flash_width_func+0x138>
   23438:	e0bfff17 	ldw	r2,-4(fp)
   2343c:	00c000b4 	movhi	r3,2
   23440:	18cc7304 	addi	r3,r3,12748
   23444:	10c03315 	stw	r3,204(r2)
   23448:	00002206 	br	234d4 <alt_set_flash_width_func+0x138>
   2344c:	e0bfff17 	ldw	r2,-4(fp)
   23450:	00c000b4 	movhi	r3,2
   23454:	18cccc04 	addi	r3,r3,13104
   23458:	10c03515 	stw	r3,212(r2)
   2345c:	e0bfff17 	ldw	r2,-4(fp)
   23460:	10802f17 	ldw	r2,188(r2)
   23464:	10800098 	cmpnei	r2,r2,2
   23468:	1000051e 	bne	r2,zero,23480 <alt_set_flash_width_func+0xe4>
   2346c:	e0bfff17 	ldw	r2,-4(fp)
   23470:	00c000b4 	movhi	r3,2
   23474:	18cc8604 	addi	r3,r3,12824
   23478:	10c03315 	stw	r3,204(r2)
   2347c:	00001706 	br	234dc <alt_set_flash_width_func+0x140>
   23480:	e0bfff17 	ldw	r2,-4(fp)
   23484:	10802f17 	ldw	r2,188(r2)
   23488:	10800118 	cmpnei	r2,r2,4
   2348c:	1000131e 	bne	r2,zero,234dc <alt_set_flash_width_func+0x140>
   23490:	e0bfff17 	ldw	r2,-4(fp)
   23494:	00c000b4 	movhi	r3,2
   23498:	18cc9804 	addi	r3,r3,12896
   2349c:	10c03315 	stw	r3,204(r2)
   234a0:	00000e06 	br	234dc <alt_set_flash_width_func+0x140>
   234a4:	e0bfff17 	ldw	r2,-4(fp)
   234a8:	00c000b4 	movhi	r3,2
   234ac:	18ccda04 	addi	r3,r3,13160
   234b0:	10c03515 	stw	r3,212(r2)
   234b4:	e0bfff17 	ldw	r2,-4(fp)
   234b8:	00c000b4 	movhi	r3,2
   234bc:	18ccab04 	addi	r3,r3,12972
   234c0:	10c03315 	stw	r3,204(r2)
   234c4:	00000606 	br	234e0 <alt_set_flash_width_func+0x144>
   234c8:	00bffcc4 	movi	r2,-13
   234cc:	e0bffe15 	stw	r2,-8(fp)
   234d0:	00000306 	br	234e0 <alt_set_flash_width_func+0x144>
   234d4:	0001883a 	nop
   234d8:	00000106 	br	234e0 <alt_set_flash_width_func+0x144>
   234dc:	0001883a 	nop
   234e0:	e0bffe17 	ldw	r2,-8(fp)
   234e4:	1000191e 	bne	r2,zero,2354c <alt_set_flash_width_func+0x1b0>
   234e8:	e0bfff17 	ldw	r2,-4(fp)
   234ec:	10802f17 	ldw	r2,188(r2)
   234f0:	10c000a0 	cmpeqi	r3,r2,2
   234f4:	1800091e 	bne	r3,zero,2351c <alt_set_flash_width_func+0x180>
   234f8:	10c00120 	cmpeqi	r3,r2,4
   234fc:	18000c1e 	bne	r3,zero,23530 <alt_set_flash_width_func+0x194>
   23500:	10800060 	cmpeqi	r2,r2,1
   23504:	10000f26 	beq	r2,zero,23544 <alt_set_flash_width_func+0x1a8>
   23508:	e0bfff17 	ldw	r2,-4(fp)
   2350c:	00c000b4 	movhi	r3,2
   23510:	18cc1604 	addi	r3,r3,12376
   23514:	10c03415 	stw	r3,208(r2)
   23518:	00000c06 	br	2354c <alt_set_flash_width_func+0x1b0>
   2351c:	e0bfff17 	ldw	r2,-4(fp)
   23520:	00c000b4 	movhi	r3,2
   23524:	18cc2504 	addi	r3,r3,12436
   23528:	10c03415 	stw	r3,208(r2)
   2352c:	00000706 	br	2354c <alt_set_flash_width_func+0x1b0>
   23530:	e0bfff17 	ldw	r2,-4(fp)
   23534:	00c000b4 	movhi	r3,2
   23538:	18cc3504 	addi	r3,r3,12500
   2353c:	10c03415 	stw	r3,208(r2)
   23540:	00000206 	br	2354c <alt_set_flash_width_func+0x1b0>
   23544:	00bffcc4 	movi	r2,-13
   23548:	e0bffe15 	stw	r2,-8(fp)
   2354c:	e0bffe17 	ldw	r2,-8(fp)
   23550:	e037883a 	mov	sp,fp
   23554:	df000017 	ldw	fp,0(sp)
   23558:	dec00104 	addi	sp,sp,4
   2355c:	f800283a 	ret

00023560 <alt_set_flash_algorithm_func>:
   23560:	defffd04 	addi	sp,sp,-12
   23564:	df000215 	stw	fp,8(sp)
   23568:	df000204 	addi	fp,sp,8
   2356c:	e13fff15 	stw	r4,-4(fp)
   23570:	e03ffe15 	stw	zero,-8(fp)
   23574:	e0bfff17 	ldw	r2,-4(fp)
   23578:	10802d17 	ldw	r2,180(r2)
   2357c:	10c000a0 	cmpeqi	r3,r2,2
   23580:	1800051e 	bne	r3,zero,23598 <alt_set_flash_algorithm_func+0x38>
   23584:	10c000e0 	cmpeqi	r3,r2,3
   23588:	18000c1e 	bne	r3,zero,235bc <alt_set_flash_algorithm_func+0x5c>
   2358c:	10800060 	cmpeqi	r2,r2,1
   23590:	10000a1e 	bne	r2,zero,235bc <alt_set_flash_algorithm_func+0x5c>
   23594:	00001206 	br	235e0 <alt_set_flash_algorithm_func+0x80>
   23598:	e0bfff17 	ldw	r2,-4(fp)
   2359c:	00c000f4 	movhi	r3,3
   235a0:	18f51904 	addi	r3,r3,-11164
   235a4:	10c00815 	stw	r3,32(r2)
   235a8:	e0bfff17 	ldw	r2,-4(fp)
   235ac:	00c000f4 	movhi	r3,3
   235b0:	18f4ff04 	addi	r3,r3,-11268
   235b4:	10c00915 	stw	r3,36(r2)
   235b8:	00000b06 	br	235e8 <alt_set_flash_algorithm_func+0x88>
   235bc:	e0bfff17 	ldw	r2,-4(fp)
   235c0:	00c000f4 	movhi	r3,3
   235c4:	18f63704 	addi	r3,r3,-10020
   235c8:	10c00815 	stw	r3,32(r2)
   235cc:	e0bfff17 	ldw	r2,-4(fp)
   235d0:	00c000f4 	movhi	r3,3
   235d4:	18f61704 	addi	r3,r3,-10148
   235d8:	10c00915 	stw	r3,36(r2)
   235dc:	00000206 	br	235e8 <alt_set_flash_algorithm_func+0x88>
   235e0:	00bffec4 	movi	r2,-5
   235e4:	e0bffe15 	stw	r2,-8(fp)
   235e8:	e0bffe17 	ldw	r2,-8(fp)
   235ec:	e037883a 	mov	sp,fp
   235f0:	df000017 	ldw	fp,0(sp)
   235f4:	dec00104 	addi	sp,sp,4
   235f8:	f800283a 	ret

000235fc <alt_read_16bit_query_entry>:
   235fc:	defffb04 	addi	sp,sp,-20
   23600:	dfc00415 	stw	ra,16(sp)
   23604:	df000315 	stw	fp,12(sp)
   23608:	df000304 	addi	fp,sp,12
   2360c:	e13ffe15 	stw	r4,-8(fp)
   23610:	e17fff15 	stw	r5,-4(fp)
   23614:	e0bffe17 	ldw	r2,-8(fp)
   23618:	10803417 	ldw	r2,208(r2)
   2361c:	e13ffe17 	ldw	r4,-8(fp)
   23620:	e17fff17 	ldw	r5,-4(fp)
   23624:	103ee83a 	callr	r2
   23628:	10803fcc 	andi	r2,r2,255
   2362c:	e0bffd0d 	sth	r2,-12(fp)
   23630:	e0bffe17 	ldw	r2,-8(fp)
   23634:	10c03417 	ldw	r3,208(r2)
   23638:	e0bfff17 	ldw	r2,-4(fp)
   2363c:	10800044 	addi	r2,r2,1
   23640:	e13ffe17 	ldw	r4,-8(fp)
   23644:	100b883a 	mov	r5,r2
   23648:	183ee83a 	callr	r3
   2364c:	10803fcc 	andi	r2,r2,255
   23650:	1004923a 	slli	r2,r2,8
   23654:	1007883a 	mov	r3,r2
   23658:	e0bffd0b 	ldhu	r2,-12(fp)
   2365c:	1884b03a 	or	r2,r3,r2
   23660:	e0bffd0d 	sth	r2,-12(fp)
   23664:	e0bffd0b 	ldhu	r2,-12(fp)
   23668:	e037883a 	mov	sp,fp
   2366c:	dfc00117 	ldw	ra,4(sp)
   23670:	df000017 	ldw	fp,0(sp)
   23674:	dec00204 	addi	sp,sp,8
   23678:	f800283a 	ret

0002367c <alt_read_cfi_table>:
   2367c:	defff304 	addi	sp,sp,-52
   23680:	dfc00c15 	stw	ra,48(sp)
   23684:	df000b15 	stw	fp,44(sp)
   23688:	df000b04 	addi	fp,sp,44
   2368c:	e13fff15 	stw	r4,-4(fp)
   23690:	e03ff715 	stw	zero,-36(fp)
   23694:	e03ff815 	stw	zero,-32(fp)
   23698:	e03ff915 	stw	zero,-28(fp)
   2369c:	e13fff17 	ldw	r4,-4(fp)
   236a0:	00243b40 	call	243b4 <alt_check_primary_table>
   236a4:	e0bff715 	stw	r2,-36(fp)
   236a8:	e0bff717 	ldw	r2,-36(fp)
   236ac:	10015f1e 	bne	r2,zero,23c2c <alt_read_cfi_table+0x5b0>
   236b0:	e0bfff17 	ldw	r2,-4(fp)
   236b4:	10803417 	ldw	r2,208(r2)
   236b8:	e13fff17 	ldw	r4,-4(fp)
   236bc:	014004c4 	movi	r5,19
   236c0:	103ee83a 	callr	r2
   236c4:	10c03fcc 	andi	r3,r2,255
   236c8:	e0bfff17 	ldw	r2,-4(fp)
   236cc:	10c02d15 	stw	r3,180(r2)
   236d0:	e0bfff17 	ldw	r2,-4(fp)
   236d4:	10803417 	ldw	r2,208(r2)
   236d8:	e13fff17 	ldw	r4,-4(fp)
   236dc:	014007c4 	movi	r5,31
   236e0:	103ee83a 	callr	r2
   236e4:	10803fcc 	andi	r2,r2,255
   236e8:	e0bffa15 	stw	r2,-24(fp)
   236ec:	e0bfff17 	ldw	r2,-4(fp)
   236f0:	10803417 	ldw	r2,208(r2)
   236f4:	e13fff17 	ldw	r4,-4(fp)
   236f8:	014008c4 	movi	r5,35
   236fc:	103ee83a 	callr	r2
   23700:	10803fcc 	andi	r2,r2,255
   23704:	e0bffb15 	stw	r2,-20(fp)
   23708:	e0bffa17 	ldw	r2,-24(fp)
   2370c:	10000226 	beq	r2,zero,23718 <alt_read_cfi_table+0x9c>
   23710:	e0bffb17 	ldw	r2,-20(fp)
   23714:	1000041e 	bne	r2,zero,23728 <alt_read_cfi_table+0xac>
   23718:	e0bfff17 	ldw	r2,-4(fp)
   2371c:	00c0fa04 	movi	r3,1000
   23720:	10c03015 	stw	r3,192(r2)
   23724:	00000706 	br	23744 <alt_read_cfi_table+0xc8>
   23728:	00c00044 	movi	r3,1
   2372c:	e0bffa17 	ldw	r2,-24(fp)
   23730:	1886983a 	sll	r3,r3,r2
   23734:	e0bffb17 	ldw	r2,-20(fp)
   23738:	1886983a 	sll	r3,r3,r2
   2373c:	e0bfff17 	ldw	r2,-4(fp)
   23740:	10c03015 	stw	r3,192(r2)
   23744:	e0bfff17 	ldw	r2,-4(fp)
   23748:	10803417 	ldw	r2,208(r2)
   2374c:	e13fff17 	ldw	r4,-4(fp)
   23750:	01400844 	movi	r5,33
   23754:	103ee83a 	callr	r2
   23758:	10803fcc 	andi	r2,r2,255
   2375c:	e0bffa15 	stw	r2,-24(fp)
   23760:	e0bfff17 	ldw	r2,-4(fp)
   23764:	10803417 	ldw	r2,208(r2)
   23768:	e13fff17 	ldw	r4,-4(fp)
   2376c:	01400944 	movi	r5,37
   23770:	103ee83a 	callr	r2
   23774:	10803fcc 	andi	r2,r2,255
   23778:	e0bffb15 	stw	r2,-20(fp)
   2377c:	e0bffa17 	ldw	r2,-24(fp)
   23780:	10000226 	beq	r2,zero,2378c <alt_read_cfi_table+0x110>
   23784:	e0bffb17 	ldw	r2,-20(fp)
   23788:	1000051e 	bne	r2,zero,237a0 <alt_read_cfi_table+0x124>
   2378c:	e0bfff17 	ldw	r2,-4(fp)
   23790:	00c04c74 	movhi	r3,305
   23794:	18cb4004 	addi	r3,r3,11520
   23798:	10c03115 	stw	r3,196(r2)
   2379c:	00000806 	br	237c0 <alt_read_cfi_table+0x144>
   237a0:	00c00044 	movi	r3,1
   237a4:	e0bffa17 	ldw	r2,-24(fp)
   237a8:	1886983a 	sll	r3,r3,r2
   237ac:	e0bffb17 	ldw	r2,-20(fp)
   237b0:	1884983a 	sll	r2,r3,r2
   237b4:	10c0fa24 	muli	r3,r2,1000
   237b8:	e0bfff17 	ldw	r2,-4(fp)
   237bc:	10c03115 	stw	r3,196(r2)
   237c0:	e0bfff17 	ldw	r2,-4(fp)
   237c4:	10803417 	ldw	r2,208(r2)
   237c8:	e13fff17 	ldw	r4,-4(fp)
   237cc:	014009c4 	movi	r5,39
   237d0:	103ee83a 	callr	r2
   237d4:	10803fcc 	andi	r2,r2,255
   237d8:	00c00044 	movi	r3,1
   237dc:	1884983a 	sll	r2,r3,r2
   237e0:	e0bffc15 	stw	r2,-16(fp)
   237e4:	e0bfff17 	ldw	r2,-4(fp)
   237e8:	10803417 	ldw	r2,208(r2)
   237ec:	e13fff17 	ldw	r4,-4(fp)
   237f0:	01400b04 	movi	r5,44
   237f4:	103ee83a 	callr	r2
   237f8:	10c03fcc 	andi	r3,r2,255
   237fc:	e0bfff17 	ldw	r2,-4(fp)
   23800:	10c00c15 	stw	r3,48(r2)
   23804:	e0bfff17 	ldw	r2,-4(fp)
   23808:	10800c17 	ldw	r2,48(r2)
   2380c:	10800250 	cmplti	r2,r2,9
   23810:	1000031e 	bne	r2,zero,23820 <alt_read_cfi_table+0x1a4>
   23814:	00bffd04 	movi	r2,-12
   23818:	e0bff715 	stw	r2,-36(fp)
   2381c:	00006006 	br	239a0 <alt_read_cfi_table+0x324>
   23820:	e03ff515 	stw	zero,-44(fp)
   23824:	00005506 	br	2397c <alt_read_cfi_table+0x300>
   23828:	e0bff517 	ldw	r2,-44(fp)
   2382c:	1085883a 	add	r2,r2,r2
   23830:	1085883a 	add	r2,r2,r2
   23834:	10800b44 	addi	r2,r2,45
   23838:	e13fff17 	ldw	r4,-4(fp)
   2383c:	100b883a 	mov	r5,r2
   23840:	00235fc0 	call	235fc <alt_read_16bit_query_entry>
   23844:	10ffffcc 	andi	r3,r2,65535
   23848:	e13fff17 	ldw	r4,-4(fp)
   2384c:	e0bff517 	ldw	r2,-44(fp)
   23850:	1004913a 	slli	r2,r2,4
   23854:	2085883a 	add	r2,r4,r2
   23858:	10800f04 	addi	r2,r2,60
   2385c:	10c00015 	stw	r3,0(r2)
   23860:	e0ffff17 	ldw	r3,-4(fp)
   23864:	e0bff517 	ldw	r2,-44(fp)
   23868:	1004913a 	slli	r2,r2,4
   2386c:	1885883a 	add	r2,r3,r2
   23870:	10800f04 	addi	r2,r2,60
   23874:	10800017 	ldw	r2,0(r2)
   23878:	10c00044 	addi	r3,r2,1
   2387c:	e13fff17 	ldw	r4,-4(fp)
   23880:	e0bff517 	ldw	r2,-44(fp)
   23884:	1004913a 	slli	r2,r2,4
   23888:	2085883a 	add	r2,r4,r2
   2388c:	10800f04 	addi	r2,r2,60
   23890:	10c00015 	stw	r3,0(r2)
   23894:	e0bff517 	ldw	r2,-44(fp)
   23898:	1085883a 	add	r2,r2,r2
   2389c:	1085883a 	add	r2,r2,r2
   238a0:	10800bc4 	addi	r2,r2,47
   238a4:	e13fff17 	ldw	r4,-4(fp)
   238a8:	100b883a 	mov	r5,r2
   238ac:	00235fc0 	call	235fc <alt_read_16bit_query_entry>
   238b0:	10ffffcc 	andi	r3,r2,65535
   238b4:	e13fff17 	ldw	r4,-4(fp)
   238b8:	e0bff517 	ldw	r2,-44(fp)
   238bc:	10800104 	addi	r2,r2,4
   238c0:	1004913a 	slli	r2,r2,4
   238c4:	2085883a 	add	r2,r4,r2
   238c8:	10c00015 	stw	r3,0(r2)
   238cc:	e0ffff17 	ldw	r3,-4(fp)
   238d0:	e0bff517 	ldw	r2,-44(fp)
   238d4:	10800104 	addi	r2,r2,4
   238d8:	1004913a 	slli	r2,r2,4
   238dc:	1885883a 	add	r2,r3,r2
   238e0:	10800017 	ldw	r2,0(r2)
   238e4:	1006923a 	slli	r3,r2,8
   238e8:	e13fff17 	ldw	r4,-4(fp)
   238ec:	e0bff517 	ldw	r2,-44(fp)
   238f0:	10800104 	addi	r2,r2,4
   238f4:	1004913a 	slli	r2,r2,4
   238f8:	2085883a 	add	r2,r4,r2
   238fc:	10c00015 	stw	r3,0(r2)
   23900:	e0ffff17 	ldw	r3,-4(fp)
   23904:	e0bff517 	ldw	r2,-44(fp)
   23908:	1004913a 	slli	r2,r2,4
   2390c:	1885883a 	add	r2,r3,r2
   23910:	10800f04 	addi	r2,r2,60
   23914:	10c00017 	ldw	r3,0(r2)
   23918:	e13fff17 	ldw	r4,-4(fp)
   2391c:	e0bff517 	ldw	r2,-44(fp)
   23920:	10800104 	addi	r2,r2,4
   23924:	1004913a 	slli	r2,r2,4
   23928:	2085883a 	add	r2,r4,r2
   2392c:	10800017 	ldw	r2,0(r2)
   23930:	1887383a 	mul	r3,r3,r2
   23934:	e13fff17 	ldw	r4,-4(fp)
   23938:	e0bff517 	ldw	r2,-44(fp)
   2393c:	1004913a 	slli	r2,r2,4
   23940:	2085883a 	add	r2,r4,r2
   23944:	10800e04 	addi	r2,r2,56
   23948:	10c00015 	stw	r3,0(r2)
   2394c:	e0ffff17 	ldw	r3,-4(fp)
   23950:	e0bff517 	ldw	r2,-44(fp)
   23954:	1004913a 	slli	r2,r2,4
   23958:	1885883a 	add	r2,r3,r2
   2395c:	10800e04 	addi	r2,r2,56
   23960:	10800017 	ldw	r2,0(r2)
   23964:	e0fff817 	ldw	r3,-32(fp)
   23968:	1885883a 	add	r2,r3,r2
   2396c:	e0bff815 	stw	r2,-32(fp)
   23970:	e0bff517 	ldw	r2,-44(fp)
   23974:	10800044 	addi	r2,r2,1
   23978:	e0bff515 	stw	r2,-44(fp)
   2397c:	e0bfff17 	ldw	r2,-4(fp)
   23980:	10800c17 	ldw	r2,48(r2)
   23984:	e0fff517 	ldw	r3,-44(fp)
   23988:	18bfa716 	blt	r3,r2,23828 <alt_read_cfi_table+0x1ac>
   2398c:	e0fff817 	ldw	r3,-32(fp)
   23990:	e0bffc17 	ldw	r2,-16(fp)
   23994:	18800226 	beq	r3,r2,239a0 <alt_read_cfi_table+0x324>
   23998:	00bffb44 	movi	r2,-19
   2399c:	e0bff715 	stw	r2,-36(fp)
   239a0:	e0bfff17 	ldw	r2,-4(fp)
   239a4:	10c03417 	ldw	r3,208(r2)
   239a8:	e0bfff17 	ldw	r2,-4(fp)
   239ac:	10803217 	ldw	r2,200(r2)
   239b0:	108003c4 	addi	r2,r2,15
   239b4:	e13fff17 	ldw	r4,-4(fp)
   239b8:	100b883a 	mov	r5,r2
   239bc:	183ee83a 	callr	r3
   239c0:	e0bffd05 	stb	r2,-12(fp)
   239c4:	e0bfff17 	ldw	r2,-4(fp)
   239c8:	10802d17 	ldw	r2,180(r2)
   239cc:	10800098 	cmpnei	r2,r2,2
   239d0:	1000601e 	bne	r2,zero,23b54 <alt_read_cfi_table+0x4d8>
   239d4:	e0bffd03 	ldbu	r2,-12(fp)
   239d8:	108000d8 	cmpnei	r2,r2,3
   239dc:	10005d1e 	bne	r2,zero,23b54 <alt_read_cfi_table+0x4d8>
   239e0:	e0bfff17 	ldw	r2,-4(fp)
   239e4:	10800c17 	ldw	r2,48(r2)
   239e8:	10bfffc4 	addi	r2,r2,-1
   239ec:	e0bff515 	stw	r2,-44(fp)
   239f0:	e03ff615 	stw	zero,-40(fp)
   239f4:	00005406 	br	23b48 <alt_read_cfi_table+0x4cc>
   239f8:	e0ffff17 	ldw	r3,-4(fp)
   239fc:	e0bff517 	ldw	r2,-44(fp)
   23a00:	1004913a 	slli	r2,r2,4
   23a04:	1885883a 	add	r2,r3,r2
   23a08:	10800e04 	addi	r2,r2,56
   23a0c:	10800017 	ldw	r2,0(r2)
   23a10:	e0bffe15 	stw	r2,-8(fp)
   23a14:	e0ffff17 	ldw	r3,-4(fp)
   23a18:	e0bff617 	ldw	r2,-40(fp)
   23a1c:	1004913a 	slli	r2,r2,4
   23a20:	1885883a 	add	r2,r3,r2
   23a24:	10800e04 	addi	r2,r2,56
   23a28:	10c00017 	ldw	r3,0(r2)
   23a2c:	e13fff17 	ldw	r4,-4(fp)
   23a30:	e0bff517 	ldw	r2,-44(fp)
   23a34:	1004913a 	slli	r2,r2,4
   23a38:	2085883a 	add	r2,r4,r2
   23a3c:	10800e04 	addi	r2,r2,56
   23a40:	10c00015 	stw	r3,0(r2)
   23a44:	e0ffff17 	ldw	r3,-4(fp)
   23a48:	e0bff617 	ldw	r2,-40(fp)
   23a4c:	1004913a 	slli	r2,r2,4
   23a50:	1885883a 	add	r2,r3,r2
   23a54:	10800e04 	addi	r2,r2,56
   23a58:	e0fffe17 	ldw	r3,-8(fp)
   23a5c:	10c00015 	stw	r3,0(r2)
   23a60:	e0ffff17 	ldw	r3,-4(fp)
   23a64:	e0bff517 	ldw	r2,-44(fp)
   23a68:	10800104 	addi	r2,r2,4
   23a6c:	1004913a 	slli	r2,r2,4
   23a70:	1885883a 	add	r2,r3,r2
   23a74:	10800017 	ldw	r2,0(r2)
   23a78:	e0bffe15 	stw	r2,-8(fp)
   23a7c:	e0ffff17 	ldw	r3,-4(fp)
   23a80:	e0bff617 	ldw	r2,-40(fp)
   23a84:	10800104 	addi	r2,r2,4
   23a88:	1004913a 	slli	r2,r2,4
   23a8c:	1885883a 	add	r2,r3,r2
   23a90:	10c00017 	ldw	r3,0(r2)
   23a94:	e13fff17 	ldw	r4,-4(fp)
   23a98:	e0bff517 	ldw	r2,-44(fp)
   23a9c:	10800104 	addi	r2,r2,4
   23aa0:	1004913a 	slli	r2,r2,4
   23aa4:	2085883a 	add	r2,r4,r2
   23aa8:	10c00015 	stw	r3,0(r2)
   23aac:	e0ffff17 	ldw	r3,-4(fp)
   23ab0:	e0bff617 	ldw	r2,-40(fp)
   23ab4:	10800104 	addi	r2,r2,4
   23ab8:	1004913a 	slli	r2,r2,4
   23abc:	1885883a 	add	r2,r3,r2
   23ac0:	e0fffe17 	ldw	r3,-8(fp)
   23ac4:	10c00015 	stw	r3,0(r2)
   23ac8:	e0ffff17 	ldw	r3,-4(fp)
   23acc:	e0bff517 	ldw	r2,-44(fp)
   23ad0:	1004913a 	slli	r2,r2,4
   23ad4:	1885883a 	add	r2,r3,r2
   23ad8:	10800f04 	addi	r2,r2,60
   23adc:	10800017 	ldw	r2,0(r2)
   23ae0:	e0bffe15 	stw	r2,-8(fp)
   23ae4:	e0ffff17 	ldw	r3,-4(fp)
   23ae8:	e0bff617 	ldw	r2,-40(fp)
   23aec:	1004913a 	slli	r2,r2,4
   23af0:	1885883a 	add	r2,r3,r2
   23af4:	10800f04 	addi	r2,r2,60
   23af8:	10c00017 	ldw	r3,0(r2)
   23afc:	e13fff17 	ldw	r4,-4(fp)
   23b00:	e0bff517 	ldw	r2,-44(fp)
   23b04:	1004913a 	slli	r2,r2,4
   23b08:	2085883a 	add	r2,r4,r2
   23b0c:	10800f04 	addi	r2,r2,60
   23b10:	10c00015 	stw	r3,0(r2)
   23b14:	e0ffff17 	ldw	r3,-4(fp)
   23b18:	e0bff617 	ldw	r2,-40(fp)
   23b1c:	1004913a 	slli	r2,r2,4
   23b20:	1885883a 	add	r2,r3,r2
   23b24:	10800f04 	addi	r2,r2,60
   23b28:	e0fffe17 	ldw	r3,-8(fp)
   23b2c:	10c00015 	stw	r3,0(r2)
   23b30:	e0bff517 	ldw	r2,-44(fp)
   23b34:	10bfffc4 	addi	r2,r2,-1
   23b38:	e0bff515 	stw	r2,-44(fp)
   23b3c:	e0bff617 	ldw	r2,-40(fp)
   23b40:	10800044 	addi	r2,r2,1
   23b44:	e0bff615 	stw	r2,-40(fp)
   23b48:	e0bff617 	ldw	r2,-40(fp)
   23b4c:	e0fff517 	ldw	r3,-44(fp)
   23b50:	18bfa90e 	bge	r3,r2,239f8 <alt_read_cfi_table+0x37c>
   23b54:	e03ff515 	stw	zero,-44(fp)
   23b58:	00001306 	br	23ba8 <alt_read_cfi_table+0x52c>
   23b5c:	e0ffff17 	ldw	r3,-4(fp)
   23b60:	e0bff517 	ldw	r2,-44(fp)
   23b64:	1004913a 	slli	r2,r2,4
   23b68:	1885883a 	add	r2,r3,r2
   23b6c:	10800d04 	addi	r2,r2,52
   23b70:	e0fff917 	ldw	r3,-28(fp)
   23b74:	10c00015 	stw	r3,0(r2)
   23b78:	e0ffff17 	ldw	r3,-4(fp)
   23b7c:	e0bff517 	ldw	r2,-44(fp)
   23b80:	1004913a 	slli	r2,r2,4
   23b84:	1885883a 	add	r2,r3,r2
   23b88:	10800e04 	addi	r2,r2,56
   23b8c:	10800017 	ldw	r2,0(r2)
   23b90:	e0fff917 	ldw	r3,-28(fp)
   23b94:	1885883a 	add	r2,r3,r2
   23b98:	e0bff915 	stw	r2,-28(fp)
   23b9c:	e0bff517 	ldw	r2,-44(fp)
   23ba0:	10800044 	addi	r2,r2,1
   23ba4:	e0bff515 	stw	r2,-44(fp)
   23ba8:	e0bfff17 	ldw	r2,-4(fp)
   23bac:	10800c17 	ldw	r2,48(r2)
   23bb0:	e0fff517 	ldw	r3,-44(fp)
   23bb4:	18bfe916 	blt	r3,r2,23b5c <alt_read_cfi_table+0x4e0>
   23bb8:	e0bfff17 	ldw	r2,-4(fp)
   23bbc:	10802d17 	ldw	r2,180(r2)
   23bc0:	10c000a0 	cmpeqi	r3,r2,2
   23bc4:	1800051e 	bne	r3,zero,23bdc <alt_read_cfi_table+0x560>
   23bc8:	10c000e0 	cmpeqi	r3,r2,3
   23bcc:	18000c1e 	bne	r3,zero,23c00 <alt_read_cfi_table+0x584>
   23bd0:	10800060 	cmpeqi	r2,r2,1
   23bd4:	10000a1e 	bne	r2,zero,23c00 <alt_read_cfi_table+0x584>
   23bd8:	00001206 	br	23c24 <alt_read_cfi_table+0x5a8>
   23bdc:	e0bfff17 	ldw	r2,-4(fp)
   23be0:	10c03317 	ldw	r3,204(r2)
   23be4:	e0bfff17 	ldw	r2,-4(fp)
   23be8:	10800a17 	ldw	r2,40(r2)
   23bec:	1009883a 	mov	r4,r2
   23bf0:	01401544 	movi	r5,85
   23bf4:	01803c04 	movi	r6,240
   23bf8:	183ee83a 	callr	r3
   23bfc:	00000b06 	br	23c2c <alt_read_cfi_table+0x5b0>
   23c00:	e0bfff17 	ldw	r2,-4(fp)
   23c04:	10c03317 	ldw	r3,204(r2)
   23c08:	e0bfff17 	ldw	r2,-4(fp)
   23c0c:	10800a17 	ldw	r2,40(r2)
   23c10:	1009883a 	mov	r4,r2
   23c14:	01401544 	movi	r5,85
   23c18:	01803fc4 	movi	r6,255
   23c1c:	183ee83a 	callr	r3
   23c20:	00000206 	br	23c2c <alt_read_cfi_table+0x5b0>
   23c24:	00bffec4 	movi	r2,-5
   23c28:	e0bff715 	stw	r2,-36(fp)
   23c2c:	e0bff717 	ldw	r2,-36(fp)
   23c30:	e037883a 	mov	sp,fp
   23c34:	dfc00117 	ldw	ra,4(sp)
   23c38:	df000017 	ldw	fp,0(sp)
   23c3c:	dec00204 	addi	sp,sp,8
   23c40:	f800283a 	ret

00023c44 <alt_read_cfi_width>:
   23c44:	defff704 	addi	sp,sp,-36
   23c48:	dfc00815 	stw	ra,32(sp)
   23c4c:	df000715 	stw	fp,28(sp)
   23c50:	df000704 	addi	fp,sp,28
   23c54:	e13fff15 	stw	r4,-4(fp)
   23c58:	e03ffa15 	stw	zero,-24(fp)
   23c5c:	e0bfff17 	ldw	r2,-4(fp)
   23c60:	10800a17 	ldw	r2,40(r2)
   23c64:	1009883a 	mov	r4,r2
   23c68:	01401544 	movi	r5,85
   23c6c:	01802604 	movi	r6,152
   23c70:	00231140 	call	23114 <alt_write_flash_command_8bit_device_8bit_mode>
   23c74:	e03ff915 	stw	zero,-28(fp)
   23c78:	00000f06 	br	23cb8 <alt_read_cfi_width+0x74>
   23c7c:	e0bfff17 	ldw	r2,-4(fp)
   23c80:	10c00a17 	ldw	r3,40(r2)
   23c84:	e0bff917 	ldw	r2,-28(fp)
   23c88:	10800404 	addi	r2,r2,16
   23c8c:	1885883a 	add	r2,r3,r2
   23c90:	10800023 	ldbuio	r2,0(r2)
   23c94:	10803fcc 	andi	r2,r2,255
   23c98:	1007883a 	mov	r3,r2
   23c9c:	e13ffb84 	addi	r4,fp,-18
   23ca0:	e0bff917 	ldw	r2,-28(fp)
   23ca4:	2085883a 	add	r2,r4,r2
   23ca8:	10c00005 	stb	r3,0(r2)
   23cac:	e0bff917 	ldw	r2,-28(fp)
   23cb0:	10800044 	addi	r2,r2,1
   23cb4:	e0bff915 	stw	r2,-28(fp)
   23cb8:	e0bff917 	ldw	r2,-28(fp)
   23cbc:	108000d0 	cmplti	r2,r2,3
   23cc0:	103fee1e 	bne	r2,zero,23c7c <alt_read_cfi_width+0x38>
   23cc4:	e0bffb83 	ldbu	r2,-18(fp)
   23cc8:	10803fcc 	andi	r2,r2,255
   23ccc:	10801458 	cmpnei	r2,r2,81
   23cd0:	10001d1e 	bne	r2,zero,23d48 <alt_read_cfi_width+0x104>
   23cd4:	e0bffbc3 	ldbu	r2,-17(fp)
   23cd8:	10803fcc 	andi	r2,r2,255
   23cdc:	10801498 	cmpnei	r2,r2,82
   23ce0:	1000191e 	bne	r2,zero,23d48 <alt_read_cfi_width+0x104>
   23ce4:	e0bffc03 	ldbu	r2,-16(fp)
   23ce8:	10803fcc 	andi	r2,r2,255
   23cec:	10801658 	cmpnei	r2,r2,89
   23cf0:	1000151e 	bne	r2,zero,23d48 <alt_read_cfi_width+0x104>
   23cf4:	e0bfff17 	ldw	r2,-4(fp)
   23cf8:	00c00044 	movi	r3,1
   23cfc:	10c02e15 	stw	r3,184(r2)
   23d00:	e0bfff17 	ldw	r2,-4(fp)
   23d04:	00c00044 	movi	r3,1
   23d08:	10c02f15 	stw	r3,188(r2)
   23d0c:	e0bfff17 	ldw	r2,-4(fp)
   23d10:	10800a17 	ldw	r2,40(r2)
   23d14:	10800a04 	addi	r2,r2,40
   23d18:	1080002b 	ldhuio	r2,0(r2)
   23d1c:	10bfffcc 	andi	r2,r2,65535
   23d20:	e0bffb0d 	sth	r2,-20(fp)
   23d24:	e0bffb0b 	ldhu	r2,-20(fp)
   23d28:	10800044 	addi	r2,r2,1
   23d2c:	e0bffb0d 	sth	r2,-20(fp)
   23d30:	e0bffb0b 	ldhu	r2,-20(fp)
   23d34:	1080004c 	andi	r2,r2,1
   23d38:	1001981e 	bne	r2,zero,2439c <alt_read_cfi_width+0x758>
   23d3c:	00bffb44 	movi	r2,-19
   23d40:	e0bffa15 	stw	r2,-24(fp)
   23d44:	00019506 	br	2439c <alt_read_cfi_width+0x758>
   23d48:	e0bfff17 	ldw	r2,-4(fp)
   23d4c:	10800a17 	ldw	r2,40(r2)
   23d50:	1009883a 	mov	r4,r2
   23d54:	01401544 	movi	r5,85
   23d58:	01802604 	movi	r6,152
   23d5c:	00231580 	call	23158 <alt_write_flash_command_16bit_device_8bit_mode>
   23d60:	e03ff915 	stw	zero,-28(fp)
   23d64:	00000f06 	br	23da4 <alt_read_cfi_width+0x160>
   23d68:	e0bfff17 	ldw	r2,-4(fp)
   23d6c:	10c00a17 	ldw	r3,40(r2)
   23d70:	e0bff917 	ldw	r2,-28(fp)
   23d74:	10800804 	addi	r2,r2,32
   23d78:	1885883a 	add	r2,r3,r2
   23d7c:	10800023 	ldbuio	r2,0(r2)
   23d80:	10803fcc 	andi	r2,r2,255
   23d84:	1007883a 	mov	r3,r2
   23d88:	e13ffb84 	addi	r4,fp,-18
   23d8c:	e0bff917 	ldw	r2,-28(fp)
   23d90:	2085883a 	add	r2,r4,r2
   23d94:	10c00005 	stb	r3,0(r2)
   23d98:	e0bff917 	ldw	r2,-28(fp)
   23d9c:	10800044 	addi	r2,r2,1
   23da0:	e0bff915 	stw	r2,-28(fp)
   23da4:	e0bff917 	ldw	r2,-28(fp)
   23da8:	10800190 	cmplti	r2,r2,6
   23dac:	103fee1e 	bne	r2,zero,23d68 <alt_read_cfi_width+0x124>
   23db0:	e0bffb83 	ldbu	r2,-18(fp)
   23db4:	10803fcc 	andi	r2,r2,255
   23db8:	10801458 	cmpnei	r2,r2,81
   23dbc:	1000291e 	bne	r2,zero,23e64 <alt_read_cfi_width+0x220>
   23dc0:	e0bffbc3 	ldbu	r2,-17(fp)
   23dc4:	10803fcc 	andi	r2,r2,255
   23dc8:	10801458 	cmpnei	r2,r2,81
   23dcc:	1000251e 	bne	r2,zero,23e64 <alt_read_cfi_width+0x220>
   23dd0:	e0bffc03 	ldbu	r2,-16(fp)
   23dd4:	10803fcc 	andi	r2,r2,255
   23dd8:	10801498 	cmpnei	r2,r2,82
   23ddc:	1000211e 	bne	r2,zero,23e64 <alt_read_cfi_width+0x220>
   23de0:	e0bffc43 	ldbu	r2,-15(fp)
   23de4:	10803fcc 	andi	r2,r2,255
   23de8:	10801498 	cmpnei	r2,r2,82
   23dec:	10001d1e 	bne	r2,zero,23e64 <alt_read_cfi_width+0x220>
   23df0:	e0bffc83 	ldbu	r2,-14(fp)
   23df4:	10803fcc 	andi	r2,r2,255
   23df8:	10801658 	cmpnei	r2,r2,89
   23dfc:	1000191e 	bne	r2,zero,23e64 <alt_read_cfi_width+0x220>
   23e00:	e0bffcc3 	ldbu	r2,-13(fp)
   23e04:	10803fcc 	andi	r2,r2,255
   23e08:	10801658 	cmpnei	r2,r2,89
   23e0c:	1000151e 	bne	r2,zero,23e64 <alt_read_cfi_width+0x220>
   23e10:	e0bfff17 	ldw	r2,-4(fp)
   23e14:	00c00044 	movi	r3,1
   23e18:	10c02e15 	stw	r3,184(r2)
   23e1c:	e0bfff17 	ldw	r2,-4(fp)
   23e20:	00c00084 	movi	r3,2
   23e24:	10c02f15 	stw	r3,188(r2)
   23e28:	e0bfff17 	ldw	r2,-4(fp)
   23e2c:	10800a17 	ldw	r2,40(r2)
   23e30:	10801404 	addi	r2,r2,80
   23e34:	1080002b 	ldhuio	r2,0(r2)
   23e38:	10bfffcc 	andi	r2,r2,65535
   23e3c:	e0bffb0d 	sth	r2,-20(fp)
   23e40:	e0bffb0b 	ldhu	r2,-20(fp)
   23e44:	10800044 	addi	r2,r2,1
   23e48:	e0bffb0d 	sth	r2,-20(fp)
   23e4c:	e0bffb0b 	ldhu	r2,-20(fp)
   23e50:	1080004c 	andi	r2,r2,1
   23e54:	1001511e 	bne	r2,zero,2439c <alt_read_cfi_width+0x758>
   23e58:	00bffb44 	movi	r2,-19
   23e5c:	e0bffa15 	stw	r2,-24(fp)
   23e60:	00014e06 	br	2439c <alt_read_cfi_width+0x758>
   23e64:	e0bfff17 	ldw	r2,-4(fp)
   23e68:	10800a17 	ldw	r2,40(r2)
   23e6c:	1009883a 	mov	r4,r2
   23e70:	01401544 	movi	r5,85
   23e74:	01802604 	movi	r6,152
   23e78:	00232180 	call	23218 <alt_write_flash_command_16bit_device_16bit_mode>
   23e7c:	e03ff915 	stw	zero,-28(fp)
   23e80:	00000f06 	br	23ec0 <alt_read_cfi_width+0x27c>
   23e84:	e0bfff17 	ldw	r2,-4(fp)
   23e88:	10c00a17 	ldw	r3,40(r2)
   23e8c:	e0bff917 	ldw	r2,-28(fp)
   23e90:	10800804 	addi	r2,r2,32
   23e94:	1885883a 	add	r2,r3,r2
   23e98:	10800023 	ldbuio	r2,0(r2)
   23e9c:	10803fcc 	andi	r2,r2,255
   23ea0:	1007883a 	mov	r3,r2
   23ea4:	e13ffb84 	addi	r4,fp,-18
   23ea8:	e0bff917 	ldw	r2,-28(fp)
   23eac:	2085883a 	add	r2,r4,r2
   23eb0:	10c00005 	stb	r3,0(r2)
   23eb4:	e0bff917 	ldw	r2,-28(fp)
   23eb8:	10800044 	addi	r2,r2,1
   23ebc:	e0bff915 	stw	r2,-28(fp)
   23ec0:	e0bff917 	ldw	r2,-28(fp)
   23ec4:	10800190 	cmplti	r2,r2,6
   23ec8:	103fee1e 	bne	r2,zero,23e84 <alt_read_cfi_width+0x240>
   23ecc:	e0bffb83 	ldbu	r2,-18(fp)
   23ed0:	10803fcc 	andi	r2,r2,255
   23ed4:	10801458 	cmpnei	r2,r2,81
   23ed8:	1000261e 	bne	r2,zero,23f74 <alt_read_cfi_width+0x330>
   23edc:	e0bffbc3 	ldbu	r2,-17(fp)
   23ee0:	10803fcc 	andi	r2,r2,255
   23ee4:	1000231e 	bne	r2,zero,23f74 <alt_read_cfi_width+0x330>
   23ee8:	e0bffc03 	ldbu	r2,-16(fp)
   23eec:	10803fcc 	andi	r2,r2,255
   23ef0:	10801498 	cmpnei	r2,r2,82
   23ef4:	10001f1e 	bne	r2,zero,23f74 <alt_read_cfi_width+0x330>
   23ef8:	e0bffc43 	ldbu	r2,-15(fp)
   23efc:	10803fcc 	andi	r2,r2,255
   23f00:	10001c1e 	bne	r2,zero,23f74 <alt_read_cfi_width+0x330>
   23f04:	e0bffc83 	ldbu	r2,-14(fp)
   23f08:	10803fcc 	andi	r2,r2,255
   23f0c:	10801658 	cmpnei	r2,r2,89
   23f10:	1000181e 	bne	r2,zero,23f74 <alt_read_cfi_width+0x330>
   23f14:	e0bffcc3 	ldbu	r2,-13(fp)
   23f18:	10803fcc 	andi	r2,r2,255
   23f1c:	1000151e 	bne	r2,zero,23f74 <alt_read_cfi_width+0x330>
   23f20:	e0bfff17 	ldw	r2,-4(fp)
   23f24:	00c00084 	movi	r3,2
   23f28:	10c02e15 	stw	r3,184(r2)
   23f2c:	e0bfff17 	ldw	r2,-4(fp)
   23f30:	00c00084 	movi	r3,2
   23f34:	10c02f15 	stw	r3,188(r2)
   23f38:	e0bfff17 	ldw	r2,-4(fp)
   23f3c:	10800a17 	ldw	r2,40(r2)
   23f40:	10801404 	addi	r2,r2,80
   23f44:	1080002b 	ldhuio	r2,0(r2)
   23f48:	10bfffcc 	andi	r2,r2,65535
   23f4c:	e0bffb0d 	sth	r2,-20(fp)
   23f50:	e0bffb0b 	ldhu	r2,-20(fp)
   23f54:	10800044 	addi	r2,r2,1
   23f58:	e0bffb0d 	sth	r2,-20(fp)
   23f5c:	e0bffb0b 	ldhu	r2,-20(fp)
   23f60:	1080008c 	andi	r2,r2,2
   23f64:	10010d1e 	bne	r2,zero,2439c <alt_read_cfi_width+0x758>
   23f68:	00bffb44 	movi	r2,-19
   23f6c:	e0bffa15 	stw	r2,-24(fp)
   23f70:	00010a06 	br	2439c <alt_read_cfi_width+0x758>
   23f74:	e0bfff17 	ldw	r2,-4(fp)
   23f78:	10800a17 	ldw	r2,40(r2)
   23f7c:	1009883a 	mov	r4,r2
   23f80:	01401544 	movi	r5,85
   23f84:	01802604 	movi	r6,152
   23f88:	00232ac0 	call	232ac <alt_write_flash_command_32bit_device_32bit_mode>
   23f8c:	e03ff915 	stw	zero,-28(fp)
   23f90:	00000f06 	br	23fd0 <alt_read_cfi_width+0x38c>
   23f94:	e0bfff17 	ldw	r2,-4(fp)
   23f98:	10c00a17 	ldw	r3,40(r2)
   23f9c:	e0bff917 	ldw	r2,-28(fp)
   23fa0:	10801004 	addi	r2,r2,64
   23fa4:	1885883a 	add	r2,r3,r2
   23fa8:	10800023 	ldbuio	r2,0(r2)
   23fac:	10803fcc 	andi	r2,r2,255
   23fb0:	1007883a 	mov	r3,r2
   23fb4:	e13ffb84 	addi	r4,fp,-18
   23fb8:	e0bff917 	ldw	r2,-28(fp)
   23fbc:	2085883a 	add	r2,r4,r2
   23fc0:	10c00005 	stb	r3,0(r2)
   23fc4:	e0bff917 	ldw	r2,-28(fp)
   23fc8:	10800044 	addi	r2,r2,1
   23fcc:	e0bff915 	stw	r2,-28(fp)
   23fd0:	e0bff917 	ldw	r2,-28(fp)
   23fd4:	10800310 	cmplti	r2,r2,12
   23fd8:	103fee1e 	bne	r2,zero,23f94 <alt_read_cfi_width+0x350>
   23fdc:	e0bffb83 	ldbu	r2,-18(fp)
   23fe0:	10803fcc 	andi	r2,r2,255
   23fe4:	10801458 	cmpnei	r2,r2,81
   23fe8:	1000371e 	bne	r2,zero,240c8 <alt_read_cfi_width+0x484>
   23fec:	e0bffbc3 	ldbu	r2,-17(fp)
   23ff0:	10803fcc 	andi	r2,r2,255
   23ff4:	1000341e 	bne	r2,zero,240c8 <alt_read_cfi_width+0x484>
   23ff8:	e0bffc03 	ldbu	r2,-16(fp)
   23ffc:	10803fcc 	andi	r2,r2,255
   24000:	1000311e 	bne	r2,zero,240c8 <alt_read_cfi_width+0x484>
   24004:	e0bffc43 	ldbu	r2,-15(fp)
   24008:	10803fcc 	andi	r2,r2,255
   2400c:	10002e1e 	bne	r2,zero,240c8 <alt_read_cfi_width+0x484>
   24010:	e0bffc83 	ldbu	r2,-14(fp)
   24014:	10803fcc 	andi	r2,r2,255
   24018:	10801498 	cmpnei	r2,r2,82
   2401c:	10002a1e 	bne	r2,zero,240c8 <alt_read_cfi_width+0x484>
   24020:	e0bffcc3 	ldbu	r2,-13(fp)
   24024:	10803fcc 	andi	r2,r2,255
   24028:	1000271e 	bne	r2,zero,240c8 <alt_read_cfi_width+0x484>
   2402c:	e0bffd03 	ldbu	r2,-12(fp)
   24030:	10803fcc 	andi	r2,r2,255
   24034:	1000241e 	bne	r2,zero,240c8 <alt_read_cfi_width+0x484>
   24038:	e0bffd43 	ldbu	r2,-11(fp)
   2403c:	10803fcc 	andi	r2,r2,255
   24040:	1000211e 	bne	r2,zero,240c8 <alt_read_cfi_width+0x484>
   24044:	e0bffd83 	ldbu	r2,-10(fp)
   24048:	10803fcc 	andi	r2,r2,255
   2404c:	10801658 	cmpnei	r2,r2,89
   24050:	10001d1e 	bne	r2,zero,240c8 <alt_read_cfi_width+0x484>
   24054:	e0bffdc3 	ldbu	r2,-9(fp)
   24058:	10803fcc 	andi	r2,r2,255
   2405c:	10001a1e 	bne	r2,zero,240c8 <alt_read_cfi_width+0x484>
   24060:	e0bffe03 	ldbu	r2,-8(fp)
   24064:	10803fcc 	andi	r2,r2,255
   24068:	1000171e 	bne	r2,zero,240c8 <alt_read_cfi_width+0x484>
   2406c:	e0bffe43 	ldbu	r2,-7(fp)
   24070:	10803fcc 	andi	r2,r2,255
   24074:	1000141e 	bne	r2,zero,240c8 <alt_read_cfi_width+0x484>
   24078:	e0bfff17 	ldw	r2,-4(fp)
   2407c:	00c00104 	movi	r3,4
   24080:	10c02e15 	stw	r3,184(r2)
   24084:	e0bfff17 	ldw	r2,-4(fp)
   24088:	00c00104 	movi	r3,4
   2408c:	10c02f15 	stw	r3,188(r2)
   24090:	e0bfff17 	ldw	r2,-4(fp)
   24094:	10800a17 	ldw	r2,40(r2)
   24098:	10802804 	addi	r2,r2,160
   2409c:	10800037 	ldwio	r2,0(r2)
   240a0:	e0bffb0d 	sth	r2,-20(fp)
   240a4:	e0bffb0b 	ldhu	r2,-20(fp)
   240a8:	10800044 	addi	r2,r2,1
   240ac:	e0bffb0d 	sth	r2,-20(fp)
   240b0:	e0bffb0b 	ldhu	r2,-20(fp)
   240b4:	1080010c 	andi	r2,r2,4
   240b8:	1000b81e 	bne	r2,zero,2439c <alt_read_cfi_width+0x758>
   240bc:	00bffb44 	movi	r2,-19
   240c0:	e0bffa15 	stw	r2,-24(fp)
   240c4:	0000b506 	br	2439c <alt_read_cfi_width+0x758>
   240c8:	e0bfff17 	ldw	r2,-4(fp)
   240cc:	10800a17 	ldw	r2,40(r2)
   240d0:	1009883a 	mov	r4,r2
   240d4:	01401544 	movi	r5,85
   240d8:	01802604 	movi	r6,152
   240dc:	00232600 	call	23260 <alt_write_flash_command_32bit_device_16bit_mode>
   240e0:	e03ff915 	stw	zero,-28(fp)
   240e4:	00000f06 	br	24124 <alt_read_cfi_width+0x4e0>
   240e8:	e0bfff17 	ldw	r2,-4(fp)
   240ec:	10c00a17 	ldw	r3,40(r2)
   240f0:	e0bff917 	ldw	r2,-28(fp)
   240f4:	10801004 	addi	r2,r2,64
   240f8:	1885883a 	add	r2,r3,r2
   240fc:	10800023 	ldbuio	r2,0(r2)
   24100:	10803fcc 	andi	r2,r2,255
   24104:	1007883a 	mov	r3,r2
   24108:	e13ffb84 	addi	r4,fp,-18
   2410c:	e0bff917 	ldw	r2,-28(fp)
   24110:	2085883a 	add	r2,r4,r2
   24114:	10c00005 	stb	r3,0(r2)
   24118:	e0bff917 	ldw	r2,-28(fp)
   2411c:	10800044 	addi	r2,r2,1
   24120:	e0bff915 	stw	r2,-28(fp)
   24124:	e0bff917 	ldw	r2,-28(fp)
   24128:	10800310 	cmplti	r2,r2,12
   2412c:	103fee1e 	bne	r2,zero,240e8 <alt_read_cfi_width+0x4a4>
   24130:	e0bffb83 	ldbu	r2,-18(fp)
   24134:	10803fcc 	andi	r2,r2,255
   24138:	10801458 	cmpnei	r2,r2,81
   2413c:	10003a1e 	bne	r2,zero,24228 <alt_read_cfi_width+0x5e4>
   24140:	e0bffbc3 	ldbu	r2,-17(fp)
   24144:	10803fcc 	andi	r2,r2,255
   24148:	1000371e 	bne	r2,zero,24228 <alt_read_cfi_width+0x5e4>
   2414c:	e0bffc03 	ldbu	r2,-16(fp)
   24150:	10803fcc 	andi	r2,r2,255
   24154:	10801458 	cmpnei	r2,r2,81
   24158:	1000331e 	bne	r2,zero,24228 <alt_read_cfi_width+0x5e4>
   2415c:	e0bffc43 	ldbu	r2,-15(fp)
   24160:	10803fcc 	andi	r2,r2,255
   24164:	1000301e 	bne	r2,zero,24228 <alt_read_cfi_width+0x5e4>
   24168:	e0bffc83 	ldbu	r2,-14(fp)
   2416c:	10803fcc 	andi	r2,r2,255
   24170:	10801498 	cmpnei	r2,r2,82
   24174:	10002c1e 	bne	r2,zero,24228 <alt_read_cfi_width+0x5e4>
   24178:	e0bffcc3 	ldbu	r2,-13(fp)
   2417c:	10803fcc 	andi	r2,r2,255
   24180:	1000291e 	bne	r2,zero,24228 <alt_read_cfi_width+0x5e4>
   24184:	e0bffd03 	ldbu	r2,-12(fp)
   24188:	10803fcc 	andi	r2,r2,255
   2418c:	10801498 	cmpnei	r2,r2,82
   24190:	1000251e 	bne	r2,zero,24228 <alt_read_cfi_width+0x5e4>
   24194:	e0bffd43 	ldbu	r2,-11(fp)
   24198:	10803fcc 	andi	r2,r2,255
   2419c:	1000221e 	bne	r2,zero,24228 <alt_read_cfi_width+0x5e4>
   241a0:	e0bffd83 	ldbu	r2,-10(fp)
   241a4:	10803fcc 	andi	r2,r2,255
   241a8:	10801658 	cmpnei	r2,r2,89
   241ac:	10001e1e 	bne	r2,zero,24228 <alt_read_cfi_width+0x5e4>
   241b0:	e0bffdc3 	ldbu	r2,-9(fp)
   241b4:	10803fcc 	andi	r2,r2,255
   241b8:	10001b1e 	bne	r2,zero,24228 <alt_read_cfi_width+0x5e4>
   241bc:	e0bffe03 	ldbu	r2,-8(fp)
   241c0:	10803fcc 	andi	r2,r2,255
   241c4:	10801658 	cmpnei	r2,r2,89
   241c8:	1000171e 	bne	r2,zero,24228 <alt_read_cfi_width+0x5e4>
   241cc:	e0bffe43 	ldbu	r2,-7(fp)
   241d0:	10803fcc 	andi	r2,r2,255
   241d4:	1000141e 	bne	r2,zero,24228 <alt_read_cfi_width+0x5e4>
   241d8:	e0bfff17 	ldw	r2,-4(fp)
   241dc:	00c00084 	movi	r3,2
   241e0:	10c02e15 	stw	r3,184(r2)
   241e4:	e0bfff17 	ldw	r2,-4(fp)
   241e8:	00c00104 	movi	r3,4
   241ec:	10c02f15 	stw	r3,188(r2)
   241f0:	e0bfff17 	ldw	r2,-4(fp)
   241f4:	10800a17 	ldw	r2,40(r2)
   241f8:	10802804 	addi	r2,r2,160
   241fc:	10800037 	ldwio	r2,0(r2)
   24200:	e0bffb0d 	sth	r2,-20(fp)
   24204:	e0bffb0b 	ldhu	r2,-20(fp)
   24208:	10800044 	addi	r2,r2,1
   2420c:	e0bffb0d 	sth	r2,-20(fp)
   24210:	e0bffb0b 	ldhu	r2,-20(fp)
   24214:	1080010c 	andi	r2,r2,4
   24218:	1000601e 	bne	r2,zero,2439c <alt_read_cfi_width+0x758>
   2421c:	00bffb44 	movi	r2,-19
   24220:	e0bffa15 	stw	r2,-24(fp)
   24224:	00005d06 	br	2439c <alt_read_cfi_width+0x758>
   24228:	e0bfff17 	ldw	r2,-4(fp)
   2422c:	10800a17 	ldw	r2,40(r2)
   24230:	1009883a 	mov	r4,r2
   24234:	01401544 	movi	r5,85
   24238:	01802604 	movi	r6,152
   2423c:	00231cc0 	call	231cc <alt_write_flash_command_32bit_device_8bit_mode>
   24240:	e03ff915 	stw	zero,-28(fp)
   24244:	00000f06 	br	24284 <alt_read_cfi_width+0x640>
   24248:	e0bfff17 	ldw	r2,-4(fp)
   2424c:	10c00a17 	ldw	r3,40(r2)
   24250:	e0bff917 	ldw	r2,-28(fp)
   24254:	10801004 	addi	r2,r2,64
   24258:	1885883a 	add	r2,r3,r2
   2425c:	10800023 	ldbuio	r2,0(r2)
   24260:	10803fcc 	andi	r2,r2,255
   24264:	1007883a 	mov	r3,r2
   24268:	e13ffb84 	addi	r4,fp,-18
   2426c:	e0bff917 	ldw	r2,-28(fp)
   24270:	2085883a 	add	r2,r4,r2
   24274:	10c00005 	stb	r3,0(r2)
   24278:	e0bff917 	ldw	r2,-28(fp)
   2427c:	10800044 	addi	r2,r2,1
   24280:	e0bff915 	stw	r2,-28(fp)
   24284:	e0bff917 	ldw	r2,-28(fp)
   24288:	10800310 	cmplti	r2,r2,12
   2428c:	103fee1e 	bne	r2,zero,24248 <alt_read_cfi_width+0x604>
   24290:	e0bffb83 	ldbu	r2,-18(fp)
   24294:	10803fcc 	andi	r2,r2,255
   24298:	10801458 	cmpnei	r2,r2,81
   2429c:	10003f1e 	bne	r2,zero,2439c <alt_read_cfi_width+0x758>
   242a0:	e0bffbc3 	ldbu	r2,-17(fp)
   242a4:	10803fcc 	andi	r2,r2,255
   242a8:	10801458 	cmpnei	r2,r2,81
   242ac:	10003b1e 	bne	r2,zero,2439c <alt_read_cfi_width+0x758>
   242b0:	e0bffc03 	ldbu	r2,-16(fp)
   242b4:	10803fcc 	andi	r2,r2,255
   242b8:	10801458 	cmpnei	r2,r2,81
   242bc:	1000371e 	bne	r2,zero,2439c <alt_read_cfi_width+0x758>
   242c0:	e0bffc43 	ldbu	r2,-15(fp)
   242c4:	10803fcc 	andi	r2,r2,255
   242c8:	10801458 	cmpnei	r2,r2,81
   242cc:	1000331e 	bne	r2,zero,2439c <alt_read_cfi_width+0x758>
   242d0:	e0bffc83 	ldbu	r2,-14(fp)
   242d4:	10803fcc 	andi	r2,r2,255
   242d8:	10801498 	cmpnei	r2,r2,82
   242dc:	10002f1e 	bne	r2,zero,2439c <alt_read_cfi_width+0x758>
   242e0:	e0bffcc3 	ldbu	r2,-13(fp)
   242e4:	10803fcc 	andi	r2,r2,255
   242e8:	10801498 	cmpnei	r2,r2,82
   242ec:	10002b1e 	bne	r2,zero,2439c <alt_read_cfi_width+0x758>
   242f0:	e0bffd03 	ldbu	r2,-12(fp)
   242f4:	10803fcc 	andi	r2,r2,255
   242f8:	10801498 	cmpnei	r2,r2,82
   242fc:	1000271e 	bne	r2,zero,2439c <alt_read_cfi_width+0x758>
   24300:	e0bffd43 	ldbu	r2,-11(fp)
   24304:	10803fcc 	andi	r2,r2,255
   24308:	10801498 	cmpnei	r2,r2,82
   2430c:	1000231e 	bne	r2,zero,2439c <alt_read_cfi_width+0x758>
   24310:	e0bffd83 	ldbu	r2,-10(fp)
   24314:	10803fcc 	andi	r2,r2,255
   24318:	10801658 	cmpnei	r2,r2,89
   2431c:	10001f1e 	bne	r2,zero,2439c <alt_read_cfi_width+0x758>
   24320:	e0bffdc3 	ldbu	r2,-9(fp)
   24324:	10803fcc 	andi	r2,r2,255
   24328:	10801658 	cmpnei	r2,r2,89
   2432c:	10001b1e 	bne	r2,zero,2439c <alt_read_cfi_width+0x758>
   24330:	e0bffe03 	ldbu	r2,-8(fp)
   24334:	10803fcc 	andi	r2,r2,255
   24338:	10801658 	cmpnei	r2,r2,89
   2433c:	1000171e 	bne	r2,zero,2439c <alt_read_cfi_width+0x758>
   24340:	e0bffe43 	ldbu	r2,-7(fp)
   24344:	10803fcc 	andi	r2,r2,255
   24348:	10801658 	cmpnei	r2,r2,89
   2434c:	1000131e 	bne	r2,zero,2439c <alt_read_cfi_width+0x758>
   24350:	e0bfff17 	ldw	r2,-4(fp)
   24354:	00c00044 	movi	r3,1
   24358:	10c02e15 	stw	r3,184(r2)
   2435c:	e0bfff17 	ldw	r2,-4(fp)
   24360:	00c00104 	movi	r3,4
   24364:	10c02f15 	stw	r3,188(r2)
   24368:	e0bfff17 	ldw	r2,-4(fp)
   2436c:	10800a17 	ldw	r2,40(r2)
   24370:	10802804 	addi	r2,r2,160
   24374:	10800037 	ldwio	r2,0(r2)
   24378:	e0bffb0d 	sth	r2,-20(fp)
   2437c:	e0bffb0b 	ldhu	r2,-20(fp)
   24380:	10800044 	addi	r2,r2,1
   24384:	e0bffb0d 	sth	r2,-20(fp)
   24388:	e0bffb0b 	ldhu	r2,-20(fp)
   2438c:	1080010c 	andi	r2,r2,4
   24390:	1000021e 	bne	r2,zero,2439c <alt_read_cfi_width+0x758>
   24394:	00bffb44 	movi	r2,-19
   24398:	e0bffa15 	stw	r2,-24(fp)
   2439c:	e0bffa17 	ldw	r2,-24(fp)
   243a0:	e037883a 	mov	sp,fp
   243a4:	dfc00117 	ldw	ra,4(sp)
   243a8:	df000017 	ldw	fp,0(sp)
   243ac:	dec00204 	addi	sp,sp,8
   243b0:	f800283a 	ret

000243b4 <alt_check_primary_table>:
   243b4:	defffa04 	addi	sp,sp,-24
   243b8:	dfc00515 	stw	ra,20(sp)
   243bc:	df000415 	stw	fp,16(sp)
   243c0:	df000404 	addi	fp,sp,16
   243c4:	e13fff15 	stw	r4,-4(fp)
   243c8:	e03ffd15 	stw	zero,-12(fp)
   243cc:	e13fff17 	ldw	r4,-4(fp)
   243d0:	01400544 	movi	r5,21
   243d4:	00235fc0 	call	235fc <alt_read_16bit_query_entry>
   243d8:	10ffffcc 	andi	r3,r2,65535
   243dc:	e0bfff17 	ldw	r2,-4(fp)
   243e0:	10c03215 	stw	r3,200(r2)
   243e4:	e03ffc15 	stw	zero,-16(fp)
   243e8:	00001006 	br	2442c <alt_check_primary_table+0x78>
   243ec:	e0bfff17 	ldw	r2,-4(fp)
   243f0:	10c03417 	ldw	r3,208(r2)
   243f4:	e0bfff17 	ldw	r2,-4(fp)
   243f8:	11003217 	ldw	r4,200(r2)
   243fc:	e0bffc17 	ldw	r2,-16(fp)
   24400:	2085883a 	add	r2,r4,r2
   24404:	e13fff17 	ldw	r4,-4(fp)
   24408:	100b883a 	mov	r5,r2
   2440c:	183ee83a 	callr	r3
   24410:	e13ffe04 	addi	r4,fp,-8
   24414:	e0fffc17 	ldw	r3,-16(fp)
   24418:	20c7883a 	add	r3,r4,r3
   2441c:	18800005 	stb	r2,0(r3)
   24420:	e0bffc17 	ldw	r2,-16(fp)
   24424:	10800044 	addi	r2,r2,1
   24428:	e0bffc15 	stw	r2,-16(fp)
   2442c:	e0bffc17 	ldw	r2,-16(fp)
   24430:	108000d0 	cmplti	r2,r2,3
   24434:	103fed1e 	bne	r2,zero,243ec <alt_check_primary_table+0x38>
   24438:	e0bffe03 	ldbu	r2,-8(fp)
   2443c:	10803fcc 	andi	r2,r2,255
   24440:	10801418 	cmpnei	r2,r2,80
   24444:	1000081e 	bne	r2,zero,24468 <alt_check_primary_table+0xb4>
   24448:	e0bffe43 	ldbu	r2,-7(fp)
   2444c:	10803fcc 	andi	r2,r2,255
   24450:	10801498 	cmpnei	r2,r2,82
   24454:	1000041e 	bne	r2,zero,24468 <alt_check_primary_table+0xb4>
   24458:	e0bffe83 	ldbu	r2,-6(fp)
   2445c:	10803fcc 	andi	r2,r2,255
   24460:	10801260 	cmpeqi	r2,r2,73
   24464:	1000021e 	bne	r2,zero,24470 <alt_check_primary_table+0xbc>
   24468:	00bffb44 	movi	r2,-19
   2446c:	e0bffd15 	stw	r2,-12(fp)
   24470:	e0bffd17 	ldw	r2,-12(fp)
   24474:	e037883a 	mov	sp,fp
   24478:	dfc00117 	ldw	ra,4(sp)
   2447c:	df000017 	ldw	fp,0(sp)
   24480:	dec00204 	addi	sp,sp,8
   24484:	f800283a 	ret

00024488 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
   24488:	defffa04 	addi	sp,sp,-24
   2448c:	dfc00515 	stw	ra,20(sp)
   24490:	df000415 	stw	fp,16(sp)
   24494:	df000404 	addi	fp,sp,16
   24498:	e13ffd15 	stw	r4,-12(fp)
   2449c:	e17ffe15 	stw	r5,-8(fp)
   244a0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   244a4:	e0bffd17 	ldw	r2,-12(fp)
   244a8:	10800017 	ldw	r2,0(r2)
   244ac:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
   244b0:	e0bffc17 	ldw	r2,-16(fp)
   244b4:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
   244b8:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
   244bc:	10800217 	ldw	r2,8(r2)
   244c0:	1809883a 	mov	r4,r3
   244c4:	e17ffe17 	ldw	r5,-8(fp)
   244c8:	e1bfff17 	ldw	r6,-4(fp)
   244cc:	100f883a 	mov	r7,r2
   244d0:	0024ab00 	call	24ab0 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
   244d4:	e037883a 	mov	sp,fp
   244d8:	dfc00117 	ldw	ra,4(sp)
   244dc:	df000017 	ldw	fp,0(sp)
   244e0:	dec00204 	addi	sp,sp,8
   244e4:	f800283a 	ret

000244e8 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
   244e8:	defffa04 	addi	sp,sp,-24
   244ec:	dfc00515 	stw	ra,20(sp)
   244f0:	df000415 	stw	fp,16(sp)
   244f4:	df000404 	addi	fp,sp,16
   244f8:	e13ffd15 	stw	r4,-12(fp)
   244fc:	e17ffe15 	stw	r5,-8(fp)
   24500:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   24504:	e0bffd17 	ldw	r2,-12(fp)
   24508:	10800017 	ldw	r2,0(r2)
   2450c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
   24510:	e0bffc17 	ldw	r2,-16(fp)
   24514:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
   24518:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
   2451c:	10800217 	ldw	r2,8(r2)
   24520:	1809883a 	mov	r4,r3
   24524:	e17ffe17 	ldw	r5,-8(fp)
   24528:	e1bfff17 	ldw	r6,-4(fp)
   2452c:	100f883a 	mov	r7,r2
   24530:	0024cf40 	call	24cf4 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
   24534:	e037883a 	mov	sp,fp
   24538:	dfc00117 	ldw	ra,4(sp)
   2453c:	df000017 	ldw	fp,0(sp)
   24540:	dec00204 	addi	sp,sp,8
   24544:	f800283a 	ret

00024548 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
   24548:	defffc04 	addi	sp,sp,-16
   2454c:	dfc00315 	stw	ra,12(sp)
   24550:	df000215 	stw	fp,8(sp)
   24554:	df000204 	addi	fp,sp,8
   24558:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   2455c:	e0bfff17 	ldw	r2,-4(fp)
   24560:	10800017 	ldw	r2,0(r2)
   24564:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
   24568:	e0bffe17 	ldw	r2,-8(fp)
   2456c:	10c00a04 	addi	r3,r2,40
   24570:	e0bfff17 	ldw	r2,-4(fp)
   24574:	10800217 	ldw	r2,8(r2)
   24578:	1809883a 	mov	r4,r3
   2457c:	100b883a 	mov	r5,r2
   24580:	00249540 	call	24954 <altera_avalon_jtag_uart_close>
}
   24584:	e037883a 	mov	sp,fp
   24588:	dfc00117 	ldw	ra,4(sp)
   2458c:	df000017 	ldw	fp,0(sp)
   24590:	dec00204 	addi	sp,sp,8
   24594:	f800283a 	ret

00024598 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
   24598:	defffa04 	addi	sp,sp,-24
   2459c:	dfc00515 	stw	ra,20(sp)
   245a0:	df000415 	stw	fp,16(sp)
   245a4:	df000404 	addi	fp,sp,16
   245a8:	e13ffd15 	stw	r4,-12(fp)
   245ac:	e17ffe15 	stw	r5,-8(fp)
   245b0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
   245b4:	e0bffd17 	ldw	r2,-12(fp)
   245b8:	10800017 	ldw	r2,0(r2)
   245bc:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
   245c0:	e0bffc17 	ldw	r2,-16(fp)
   245c4:	10800a04 	addi	r2,r2,40
   245c8:	1009883a 	mov	r4,r2
   245cc:	e17ffe17 	ldw	r5,-8(fp)
   245d0:	e1bfff17 	ldw	r6,-4(fp)
   245d4:	00249bc0 	call	249bc <altera_avalon_jtag_uart_ioctl>
}
   245d8:	e037883a 	mov	sp,fp
   245dc:	dfc00117 	ldw	ra,4(sp)
   245e0:	df000017 	ldw	fp,0(sp)
   245e4:	dec00204 	addi	sp,sp,8
   245e8:	f800283a 	ret

000245ec <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
   245ec:	defffa04 	addi	sp,sp,-24
   245f0:	dfc00515 	stw	ra,20(sp)
   245f4:	df000415 	stw	fp,16(sp)
   245f8:	df000404 	addi	fp,sp,16
   245fc:	e13ffd15 	stw	r4,-12(fp)
   24600:	e17ffe15 	stw	r5,-8(fp)
   24604:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
   24608:	e0bffd17 	ldw	r2,-12(fp)
   2460c:	00c00044 	movi	r3,1
   24610:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
   24614:	e0bffd17 	ldw	r2,-12(fp)
   24618:	10800017 	ldw	r2,0(r2)
   2461c:	10800104 	addi	r2,r2,4
   24620:	e0fffd17 	ldw	r3,-12(fp)
   24624:	18c00817 	ldw	r3,32(r3)
   24628:	10c00035 	stwio	r3,0(r2)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
   2462c:	e0fffe17 	ldw	r3,-8(fp)
   24630:	e0bfff17 	ldw	r2,-4(fp)
   24634:	d8000015 	stw	zero,0(sp)
   24638:	1809883a 	mov	r4,r3
   2463c:	100b883a 	mov	r5,r2
   24640:	018000b4 	movhi	r6,2
   24644:	3191ab04 	addi	r6,r6,18092
   24648:	e1fffd17 	ldw	r7,-12(fp)
   2464c:	002ca740 	call	2ca74 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
   24650:	e0bffd17 	ldw	r2,-12(fp)
   24654:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
   24658:	e0bffd17 	ldw	r2,-12(fp)
   2465c:	10c00204 	addi	r3,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
   24660:	008000f4 	movhi	r2,3
   24664:	109e4d04 	addi	r2,r2,31028
   24668:	10800017 	ldw	r2,0(r2)
   2466c:	1809883a 	mov	r4,r3
   24670:	100b883a 	mov	r5,r2
   24674:	018000b4 	movhi	r6,2
   24678:	31922c04 	addi	r6,r6,18608
   2467c:	e1fffd17 	ldw	r7,-12(fp)
   24680:	00218400 	call	21840 <alt_alarm_start>
   24684:	1000040e 	bge	r2,zero,24698 <altera_avalon_jtag_uart_init+0xac>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
   24688:	e0bffd17 	ldw	r2,-12(fp)
   2468c:	00e00034 	movhi	r3,32768
   24690:	18ffffc4 	addi	r3,r3,-1
   24694:	10c00115 	stw	r3,4(r2)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
   24698:	e037883a 	mov	sp,fp
   2469c:	dfc00117 	ldw	ra,4(sp)
   246a0:	df000017 	ldw	fp,0(sp)
   246a4:	dec00204 	addi	sp,sp,8
   246a8:	f800283a 	ret

000246ac <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
   246ac:	defff804 	addi	sp,sp,-32
   246b0:	df000715 	stw	fp,28(sp)
   246b4:	df000704 	addi	fp,sp,28
   246b8:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
   246bc:	e0bfff17 	ldw	r2,-4(fp)
   246c0:	e0bffb15 	stw	r2,-20(fp)
  unsigned int base = sp->base;
   246c4:	e0bffb17 	ldw	r2,-20(fp)
   246c8:	10800017 	ldw	r2,0(r2)
   246cc:	e0bffc15 	stw	r2,-16(fp)
   246d0:	00000106 	br	246d8 <altera_avalon_jtag_uart_irq+0x2c>
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
   246d4:	0001883a 	nop
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
   246d8:	e0bffc17 	ldw	r2,-16(fp)
   246dc:	10800104 	addi	r2,r2,4
   246e0:	10800037 	ldwio	r2,0(r2)
   246e4:	e0bffd15 	stw	r2,-12(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
   246e8:	e0bffd17 	ldw	r2,-12(fp)
   246ec:	1080c00c 	andi	r2,r2,768
   246f0:	10006a26 	beq	r2,zero,2489c <altera_avalon_jtag_uart_irq+0x1f0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
   246f4:	e0bffd17 	ldw	r2,-12(fp)
   246f8:	1080400c 	andi	r2,r2,256
   246fc:	10003326 	beq	r2,zero,247cc <altera_avalon_jtag_uart_irq+0x120>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
   24700:	00800074 	movhi	r2,1
   24704:	e0bff915 	stw	r2,-28(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   24708:	e0bffb17 	ldw	r2,-20(fp)
   2470c:	10800a17 	ldw	r2,40(r2)
   24710:	10800044 	addi	r2,r2,1
   24714:	1081ffcc 	andi	r2,r2,2047
   24718:	e0bffe15 	stw	r2,-8(fp)
        if (next == sp->rx_out)
   2471c:	e0bffb17 	ldw	r2,-20(fp)
   24720:	10c00b17 	ldw	r3,44(r2)
   24724:	e0bffe17 	ldw	r2,-8(fp)
   24728:	18801426 	beq	r3,r2,2477c <altera_avalon_jtag_uart_irq+0xd0>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
   2472c:	e0bffc17 	ldw	r2,-16(fp)
   24730:	10800037 	ldwio	r2,0(r2)
   24734:	e0bff915 	stw	r2,-28(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
   24738:	e0bff917 	ldw	r2,-28(fp)
   2473c:	10a0000c 	andi	r2,r2,32768
   24740:	10001026 	beq	r2,zero,24784 <altera_avalon_jtag_uart_irq+0xd8>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
   24744:	e0bffb17 	ldw	r2,-20(fp)
   24748:	10800a17 	ldw	r2,40(r2)
   2474c:	e0fff917 	ldw	r3,-28(fp)
   24750:	e13ffb17 	ldw	r4,-20(fp)
   24754:	2085883a 	add	r2,r4,r2
   24758:	10800e04 	addi	r2,r2,56
   2475c:	10c00005 	stb	r3,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   24760:	e0bffb17 	ldw	r2,-20(fp)
   24764:	10800a17 	ldw	r2,40(r2)
   24768:	10800044 	addi	r2,r2,1
   2476c:	10c1ffcc 	andi	r3,r2,2047
   24770:	e0bffb17 	ldw	r2,-20(fp)
   24774:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
   24778:	003fe306 	br	24708 <altera_avalon_jtag_uart_irq+0x5c>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
   2477c:	0001883a 	nop
   24780:	00000106 	br	24788 <altera_avalon_jtag_uart_irq+0xdc>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
   24784:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
   24788:	e0bff917 	ldw	r2,-28(fp)
   2478c:	10bfffec 	andhi	r2,r2,65535
   24790:	10000e26 	beq	r2,zero,247cc <altera_avalon_jtag_uart_irq+0x120>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
   24794:	e0bffb17 	ldw	r2,-20(fp)
   24798:	10c00817 	ldw	r3,32(r2)
   2479c:	00bfff84 	movi	r2,-2
   247a0:	1886703a 	and	r3,r3,r2
   247a4:	e0bffb17 	ldw	r2,-20(fp)
   247a8:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
   247ac:	e0bffc17 	ldw	r2,-16(fp)
   247b0:	10800104 	addi	r2,r2,4
   247b4:	e0fffb17 	ldw	r3,-20(fp)
   247b8:	18c00817 	ldw	r3,32(r3)
   247bc:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
   247c0:	e0bffc17 	ldw	r2,-16(fp)
   247c4:	10800104 	addi	r2,r2,4
   247c8:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
   247cc:	e0bffd17 	ldw	r2,-12(fp)
   247d0:	1080800c 	andi	r2,r2,512
   247d4:	103fbf26 	beq	r2,zero,246d4 <altera_avalon_jtag_uart_irq+0x28>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
   247d8:	e0bffd17 	ldw	r2,-12(fp)
   247dc:	1004d43a 	srli	r2,r2,16
   247e0:	e0bffa15 	stw	r2,-24(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
   247e4:	00001406 	br	24838 <altera_avalon_jtag_uart_irq+0x18c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
   247e8:	e0bffc17 	ldw	r2,-16(fp)
   247ec:	e0fffb17 	ldw	r3,-20(fp)
   247f0:	18c00d17 	ldw	r3,52(r3)
   247f4:	e13ffb17 	ldw	r4,-20(fp)
   247f8:	20c7883a 	add	r3,r4,r3
   247fc:	18c20e04 	addi	r3,r3,2104
   24800:	18c00003 	ldbu	r3,0(r3)
   24804:	18c03fcc 	andi	r3,r3,255
   24808:	18c0201c 	xori	r3,r3,128
   2480c:	18ffe004 	addi	r3,r3,-128
   24810:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   24814:	e0bffb17 	ldw	r2,-20(fp)
   24818:	10800d17 	ldw	r2,52(r2)
   2481c:	10800044 	addi	r2,r2,1
   24820:	10c1ffcc 	andi	r3,r2,2047
   24824:	e0bffb17 	ldw	r2,-20(fp)
   24828:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
   2482c:	e0bffa17 	ldw	r2,-24(fp)
   24830:	10bfffc4 	addi	r2,r2,-1
   24834:	e0bffa15 	stw	r2,-24(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
   24838:	e0bffa17 	ldw	r2,-24(fp)
   2483c:	10000526 	beq	r2,zero,24854 <altera_avalon_jtag_uart_irq+0x1a8>
   24840:	e0bffb17 	ldw	r2,-20(fp)
   24844:	10c00d17 	ldw	r3,52(r2)
   24848:	e0bffb17 	ldw	r2,-20(fp)
   2484c:	10800c17 	ldw	r2,48(r2)
   24850:	18bfe51e 	bne	r3,r2,247e8 <altera_avalon_jtag_uart_irq+0x13c>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
   24854:	e0bffa17 	ldw	r2,-24(fp)
   24858:	103f9e26 	beq	r2,zero,246d4 <altera_avalon_jtag_uart_irq+0x28>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
   2485c:	e0bffb17 	ldw	r2,-20(fp)
   24860:	10c00817 	ldw	r3,32(r2)
   24864:	00bfff44 	movi	r2,-3
   24868:	1886703a 	and	r3,r3,r2
   2486c:	e0bffb17 	ldw	r2,-20(fp)
   24870:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
   24874:	e0bffb17 	ldw	r2,-20(fp)
   24878:	10800017 	ldw	r2,0(r2)
   2487c:	10800104 	addi	r2,r2,4
   24880:	e0fffb17 	ldw	r3,-20(fp)
   24884:	18c00817 	ldw	r3,32(r3)
   24888:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
   2488c:	e0bffc17 	ldw	r2,-16(fp)
   24890:	10800104 	addi	r2,r2,4
   24894:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
   24898:	003f8e06 	br	246d4 <altera_avalon_jtag_uart_irq+0x28>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
   2489c:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
   248a0:	e037883a 	mov	sp,fp
   248a4:	df000017 	ldw	fp,0(sp)
   248a8:	dec00104 	addi	sp,sp,4
   248ac:	f800283a 	ret

000248b0 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
   248b0:	defffc04 	addi	sp,sp,-16
   248b4:	df000315 	stw	fp,12(sp)
   248b8:	df000304 	addi	fp,sp,12
   248bc:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
   248c0:	e0bfff17 	ldw	r2,-4(fp)
   248c4:	e0bffd15 	stw	r2,-12(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
   248c8:	e0bffd17 	ldw	r2,-12(fp)
   248cc:	10800017 	ldw	r2,0(r2)
   248d0:	10800104 	addi	r2,r2,4
   248d4:	10800037 	ldwio	r2,0(r2)
   248d8:	e0bffe15 	stw	r2,-8(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
   248dc:	e0bffe17 	ldw	r2,-8(fp)
   248e0:	1081000c 	andi	r2,r2,1024
   248e4:	10000a26 	beq	r2,zero,24910 <altera_avalon_jtag_uart_timeout+0x60>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
   248e8:	e0bffd17 	ldw	r2,-12(fp)
   248ec:	10800017 	ldw	r2,0(r2)
   248f0:	10800104 	addi	r2,r2,4
   248f4:	e0fffd17 	ldw	r3,-12(fp)
   248f8:	18c00817 	ldw	r3,32(r3)
   248fc:	18c10014 	ori	r3,r3,1024
   24900:	10c00035 	stwio	r3,0(r2)
    sp->host_inactive = 0;
   24904:	e0bffd17 	ldw	r2,-12(fp)
   24908:	10000915 	stw	zero,36(r2)
   2490c:	00000a06 	br	24938 <altera_avalon_jtag_uart_timeout+0x88>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
   24910:	e0bffd17 	ldw	r2,-12(fp)
   24914:	10800917 	ldw	r2,36(r2)
   24918:	00e00034 	movhi	r3,32768
   2491c:	18ffff04 	addi	r3,r3,-4
   24920:	18800536 	bltu	r3,r2,24938 <altera_avalon_jtag_uart_timeout+0x88>
    sp->host_inactive++;
   24924:	e0bffd17 	ldw	r2,-12(fp)
   24928:	10800917 	ldw	r2,36(r2)
   2492c:	10c00044 	addi	r3,r2,1
   24930:	e0bffd17 	ldw	r2,-12(fp)
   24934:	10c00915 	stw	r3,36(r2)
   24938:	008000f4 	movhi	r2,3
   2493c:	109e4d04 	addi	r2,r2,31028
   24940:	10800017 	ldw	r2,0(r2)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
   24944:	e037883a 	mov	sp,fp
   24948:	df000017 	ldw	fp,0(sp)
   2494c:	dec00104 	addi	sp,sp,4
   24950:	f800283a 	ret

00024954 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
   24954:	defffd04 	addi	sp,sp,-12
   24958:	df000215 	stw	fp,8(sp)
   2495c:	df000204 	addi	fp,sp,8
   24960:	e13ffe15 	stw	r4,-8(fp)
   24964:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
   24968:	00000506 	br	24980 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
   2496c:	e0bfff17 	ldw	r2,-4(fp)
   24970:	1090000c 	andi	r2,r2,16384
   24974:	10000226 	beq	r2,zero,24980 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
   24978:	00bffd44 	movi	r2,-11
   2497c:	00000b06 	br	249ac <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
   24980:	e0bffe17 	ldw	r2,-8(fp)
   24984:	10c00d17 	ldw	r3,52(r2)
   24988:	e0bffe17 	ldw	r2,-8(fp)
   2498c:	10800c17 	ldw	r2,48(r2)
   24990:	18800526 	beq	r3,r2,249a8 <altera_avalon_jtag_uart_close+0x54>
   24994:	e0bffe17 	ldw	r2,-8(fp)
   24998:	10c00917 	ldw	r3,36(r2)
   2499c:	e0bffe17 	ldw	r2,-8(fp)
   249a0:	10800117 	ldw	r2,4(r2)
   249a4:	18bff136 	bltu	r3,r2,2496c <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
   249a8:	0005883a 	mov	r2,zero
}
   249ac:	e037883a 	mov	sp,fp
   249b0:	df000017 	ldw	fp,0(sp)
   249b4:	dec00104 	addi	sp,sp,4
   249b8:	f800283a 	ret

000249bc <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
   249bc:	defffa04 	addi	sp,sp,-24
   249c0:	df000515 	stw	fp,20(sp)
   249c4:	df000504 	addi	fp,sp,20
   249c8:	e13ffd15 	stw	r4,-12(fp)
   249cc:	e17ffe15 	stw	r5,-8(fp)
   249d0:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
   249d4:	00bff9c4 	movi	r2,-25
   249d8:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
   249dc:	e0bffe17 	ldw	r2,-8(fp)
   249e0:	10da8060 	cmpeqi	r3,r2,27137
   249e4:	1800031e 	bne	r3,zero,249f4 <altera_avalon_jtag_uart_ioctl+0x38>
   249e8:	109a80a0 	cmpeqi	r2,r2,27138
   249ec:	1000181e 	bne	r2,zero,24a50 <altera_avalon_jtag_uart_ioctl+0x94>
   249f0:	00002606 	br	24a8c <altera_avalon_jtag_uart_ioctl+0xd0>
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
   249f4:	e0bffd17 	ldw	r2,-12(fp)
   249f8:	10c00117 	ldw	r3,4(r2)
   249fc:	00a00034 	movhi	r2,32768
   24a00:	10bfffc4 	addi	r2,r2,-1
   24a04:	18802226 	beq	r3,r2,24a90 <altera_avalon_jtag_uart_ioctl+0xd4>
    {
      int timeout = *((int *)arg);
   24a08:	e0bfff17 	ldw	r2,-4(fp)
   24a0c:	10800017 	ldw	r2,0(r2)
   24a10:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
   24a14:	e0bffc17 	ldw	r2,-16(fp)
   24a18:	10800090 	cmplti	r2,r2,2
   24a1c:	1000061e 	bne	r2,zero,24a38 <altera_avalon_jtag_uart_ioctl+0x7c>
   24a20:	e0fffc17 	ldw	r3,-16(fp)
   24a24:	00a00034 	movhi	r2,32768
   24a28:	10bfffc4 	addi	r2,r2,-1
   24a2c:	18800226 	beq	r3,r2,24a38 <altera_avalon_jtag_uart_ioctl+0x7c>
   24a30:	e0bffc17 	ldw	r2,-16(fp)
   24a34:	00000206 	br	24a40 <altera_avalon_jtag_uart_ioctl+0x84>
   24a38:	00a00034 	movhi	r2,32768
   24a3c:	10bfff84 	addi	r2,r2,-2
   24a40:	e0fffd17 	ldw	r3,-12(fp)
   24a44:	18800115 	stw	r2,4(r3)
      rc = 0;
   24a48:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
   24a4c:	00001006 	br	24a90 <altera_avalon_jtag_uart_ioctl+0xd4>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
   24a50:	e0bffd17 	ldw	r2,-12(fp)
   24a54:	10c00117 	ldw	r3,4(r2)
   24a58:	00a00034 	movhi	r2,32768
   24a5c:	10bfffc4 	addi	r2,r2,-1
   24a60:	18800d26 	beq	r3,r2,24a98 <altera_avalon_jtag_uart_ioctl+0xdc>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
   24a64:	e0bffd17 	ldw	r2,-12(fp)
   24a68:	10c00917 	ldw	r3,36(r2)
   24a6c:	e0bffd17 	ldw	r2,-12(fp)
   24a70:	10800117 	ldw	r2,4(r2)
   24a74:	1885803a 	cmpltu	r2,r3,r2
   24a78:	10c03fcc 	andi	r3,r2,255
   24a7c:	e0bfff17 	ldw	r2,-4(fp)
   24a80:	10c00015 	stw	r3,0(r2)
      rc = 0;
   24a84:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
   24a88:	00000306 	br	24a98 <altera_avalon_jtag_uart_ioctl+0xdc>

  default:
    break;
   24a8c:	00000306 	br	24a9c <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
   24a90:	0001883a 	nop
   24a94:	00000106 	br	24a9c <altera_avalon_jtag_uart_ioctl+0xe0>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
   24a98:	0001883a 	nop

  default:
    break;
  }

  return rc;
   24a9c:	e0bffb17 	ldw	r2,-20(fp)
}
   24aa0:	e037883a 	mov	sp,fp
   24aa4:	df000017 	ldw	fp,0(sp)
   24aa8:	dec00104 	addi	sp,sp,4
   24aac:	f800283a 	ret

00024ab0 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
   24ab0:	defff204 	addi	sp,sp,-56
   24ab4:	dfc00d15 	stw	ra,52(sp)
   24ab8:	df000c15 	stw	fp,48(sp)
   24abc:	df000c04 	addi	fp,sp,48
   24ac0:	e13ffc15 	stw	r4,-16(fp)
   24ac4:	e17ffd15 	stw	r5,-12(fp)
   24ac8:	e1bffe15 	stw	r6,-8(fp)
   24acc:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
   24ad0:	e0bffd17 	ldw	r2,-12(fp)
   24ad4:	e0bff415 	stw	r2,-48(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
   24ad8:	00004706 	br	24bf8 <altera_avalon_jtag_uart_read+0x148>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
   24adc:	e0bffc17 	ldw	r2,-16(fp)
   24ae0:	10800a17 	ldw	r2,40(r2)
   24ae4:	e0bff615 	stw	r2,-40(fp)
      out = sp->rx_out;
   24ae8:	e0bffc17 	ldw	r2,-16(fp)
   24aec:	10800b17 	ldw	r2,44(r2)
   24af0:	e0bff715 	stw	r2,-36(fp)

      if (in >= out)
   24af4:	e0fff617 	ldw	r3,-40(fp)
   24af8:	e0bff717 	ldw	r2,-36(fp)
   24afc:	18800536 	bltu	r3,r2,24b14 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
   24b00:	e0fff617 	ldw	r3,-40(fp)
   24b04:	e0bff717 	ldw	r2,-36(fp)
   24b08:	1885c83a 	sub	r2,r3,r2
   24b0c:	e0bff515 	stw	r2,-44(fp)
   24b10:	00000406 	br	24b24 <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
   24b14:	00c20004 	movi	r3,2048
   24b18:	e0bff717 	ldw	r2,-36(fp)
   24b1c:	1885c83a 	sub	r2,r3,r2
   24b20:	e0bff515 	stw	r2,-44(fp)

      if (n == 0)
   24b24:	e0bff517 	ldw	r2,-44(fp)
   24b28:	10001e26 	beq	r2,zero,24ba4 <altera_avalon_jtag_uart_read+0xf4>
        break; /* No more data available */

      if (n > space)
   24b2c:	e0fffe17 	ldw	r3,-8(fp)
   24b30:	e0bff517 	ldw	r2,-44(fp)
   24b34:	1880022e 	bgeu	r3,r2,24b40 <altera_avalon_jtag_uart_read+0x90>
        n = space;
   24b38:	e0bffe17 	ldw	r2,-8(fp)
   24b3c:	e0bff515 	stw	r2,-44(fp)

      memcpy(ptr, sp->rx_buf + out, n);
   24b40:	e0bff717 	ldw	r2,-36(fp)
   24b44:	10800e04 	addi	r2,r2,56
   24b48:	e0fffc17 	ldw	r3,-16(fp)
   24b4c:	1885883a 	add	r2,r3,r2
   24b50:	e13ff417 	ldw	r4,-48(fp)
   24b54:	100b883a 	mov	r5,r2
   24b58:	e1bff517 	ldw	r6,-44(fp)
   24b5c:	00191f00 	call	191f0 <memcpy>
      ptr   += n;
   24b60:	e0fff417 	ldw	r3,-48(fp)
   24b64:	e0bff517 	ldw	r2,-44(fp)
   24b68:	1885883a 	add	r2,r3,r2
   24b6c:	e0bff415 	stw	r2,-48(fp)
      space -= n;
   24b70:	e0fffe17 	ldw	r3,-8(fp)
   24b74:	e0bff517 	ldw	r2,-44(fp)
   24b78:	1885c83a 	sub	r2,r3,r2
   24b7c:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   24b80:	e0fff717 	ldw	r3,-36(fp)
   24b84:	e0bff517 	ldw	r2,-44(fp)
   24b88:	1885883a 	add	r2,r3,r2
   24b8c:	10c1ffcc 	andi	r3,r2,2047
   24b90:	e0bffc17 	ldw	r2,-16(fp)
   24b94:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
   24b98:	e0bffe17 	ldw	r2,-8(fp)
   24b9c:	00bfcf16 	blt	zero,r2,24adc <altera_avalon_jtag_uart_read+0x2c>
   24ba0:	00000106 	br	24ba8 <altera_avalon_jtag_uart_read+0xf8>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
   24ba4:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
   24ba8:	e0fff417 	ldw	r3,-48(fp)
   24bac:	e0bffd17 	ldw	r2,-12(fp)
   24bb0:	1880141e 	bne	r3,r2,24c04 <altera_avalon_jtag_uart_read+0x154>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
   24bb4:	e0bfff17 	ldw	r2,-4(fp)
   24bb8:	1090000c 	andi	r2,r2,16384
   24bbc:	1000131e 	bne	r2,zero,24c0c <altera_avalon_jtag_uart_read+0x15c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
   24bc0:	0001883a 	nop
   24bc4:	e0bffc17 	ldw	r2,-16(fp)
   24bc8:	10c00a17 	ldw	r3,40(r2)
   24bcc:	e0bff617 	ldw	r2,-40(fp)
   24bd0:	1880051e 	bne	r3,r2,24be8 <altera_avalon_jtag_uart_read+0x138>
   24bd4:	e0bffc17 	ldw	r2,-16(fp)
   24bd8:	10c00917 	ldw	r3,36(r2)
   24bdc:	e0bffc17 	ldw	r2,-16(fp)
   24be0:	10800117 	ldw	r2,4(r2)
   24be4:	18bff736 	bltu	r3,r2,24bc4 <altera_avalon_jtag_uart_read+0x114>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
   24be8:	e0bffc17 	ldw	r2,-16(fp)
   24bec:	10c00a17 	ldw	r3,40(r2)
   24bf0:	e0bff617 	ldw	r2,-40(fp)
   24bf4:	18800726 	beq	r3,r2,24c14 <altera_avalon_jtag_uart_read+0x164>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
   24bf8:	e0bffe17 	ldw	r2,-8(fp)
   24bfc:	00bfb716 	blt	zero,r2,24adc <altera_avalon_jtag_uart_read+0x2c>
   24c00:	00000506 	br	24c18 <altera_avalon_jtag_uart_read+0x168>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
   24c04:	0001883a 	nop
   24c08:	00000306 	br	24c18 <altera_avalon_jtag_uart_read+0x168>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
   24c0c:	0001883a 	nop
   24c10:	00000106 	br	24c18 <altera_avalon_jtag_uart_read+0x168>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
   24c14:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
   24c18:	e0fff417 	ldw	r3,-48(fp)
   24c1c:	e0bffd17 	ldw	r2,-12(fp)
   24c20:	18802226 	beq	r3,r2,24cac <altera_avalon_jtag_uart_read+0x1fc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   24c24:	0005303a 	rdctl	r2,status
   24c28:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   24c2c:	e0fff917 	ldw	r3,-28(fp)
   24c30:	00bfff84 	movi	r2,-2
   24c34:	1884703a 	and	r2,r3,r2
   24c38:	1001703a 	wrctl	status,r2
  
  return context;
   24c3c:	e0bff917 	ldw	r2,-28(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
   24c40:	e0bff815 	stw	r2,-32(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
   24c44:	e0bffc17 	ldw	r2,-16(fp)
   24c48:	10800817 	ldw	r2,32(r2)
   24c4c:	10c00054 	ori	r3,r2,1
   24c50:	e0bffc17 	ldw	r2,-16(fp)
   24c54:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
   24c58:	e0bffc17 	ldw	r2,-16(fp)
   24c5c:	10800017 	ldw	r2,0(r2)
   24c60:	10800104 	addi	r2,r2,4
   24c64:	e0fffc17 	ldw	r3,-16(fp)
   24c68:	18c00817 	ldw	r3,32(r3)
   24c6c:	10c00035 	stwio	r3,0(r2)
   24c70:	e0bff817 	ldw	r2,-32(fp)
   24c74:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   24c78:	0005303a 	rdctl	r2,status
   24c7c:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   24c80:	e0fffb17 	ldw	r3,-20(fp)
   24c84:	00bfff84 	movi	r2,-2
   24c88:	1884703a 	and	r2,r3,r2
   24c8c:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   24c90:	e0bffa17 	ldw	r2,-24(fp)
   24c94:	1080004c 	andi	r2,r2,1
   24c98:	e0fffb17 	ldw	r3,-20(fp)
   24c9c:	1884b03a 	or	r2,r3,r2
   24ca0:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
   24ca4:	e0bffb17 	ldw	r2,-20(fp)
   24ca8:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
   24cac:	e0fff417 	ldw	r3,-48(fp)
   24cb0:	e0bffd17 	ldw	r2,-12(fp)
   24cb4:	18800426 	beq	r3,r2,24cc8 <altera_avalon_jtag_uart_read+0x218>
    return ptr - buffer;
   24cb8:	e0fff417 	ldw	r3,-48(fp)
   24cbc:	e0bffd17 	ldw	r2,-12(fp)
   24cc0:	1885c83a 	sub	r2,r3,r2
   24cc4:	00000606 	br	24ce0 <altera_avalon_jtag_uart_read+0x230>
  else if (flags & O_NONBLOCK)
   24cc8:	e0bfff17 	ldw	r2,-4(fp)
   24ccc:	1090000c 	andi	r2,r2,16384
   24cd0:	10000226 	beq	r2,zero,24cdc <altera_avalon_jtag_uart_read+0x22c>
    return -EWOULDBLOCK;
   24cd4:	00bffd44 	movi	r2,-11
   24cd8:	00000106 	br	24ce0 <altera_avalon_jtag_uart_read+0x230>
  else
    return -EIO;
   24cdc:	00bffec4 	movi	r2,-5
}
   24ce0:	e037883a 	mov	sp,fp
   24ce4:	dfc00117 	ldw	ra,4(sp)
   24ce8:	df000017 	ldw	fp,0(sp)
   24cec:	dec00204 	addi	sp,sp,8
   24cf0:	f800283a 	ret

00024cf4 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
   24cf4:	defff204 	addi	sp,sp,-56
   24cf8:	dfc00d15 	stw	ra,52(sp)
   24cfc:	df000c15 	stw	fp,48(sp)
   24d00:	df000c04 	addi	fp,sp,48
   24d04:	e13ffc15 	stw	r4,-16(fp)
   24d08:	e17ffd15 	stw	r5,-12(fp)
   24d0c:	e1bffe15 	stw	r6,-8(fp)
   24d10:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
   24d14:	e03ff415 	stw	zero,-48(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
   24d18:	e0bffd17 	ldw	r2,-12(fp)
   24d1c:	e0bff615 	stw	r2,-40(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
   24d20:	00003706 	br	24e00 <altera_avalon_jtag_uart_write+0x10c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
   24d24:	e0bffc17 	ldw	r2,-16(fp)
   24d28:	10800c17 	ldw	r2,48(r2)
   24d2c:	e0bff715 	stw	r2,-36(fp)
      out = sp->tx_out;
   24d30:	e0bffc17 	ldw	r2,-16(fp)
   24d34:	10800d17 	ldw	r2,52(r2)
   24d38:	e0bff415 	stw	r2,-48(fp)

      if (in < out)
   24d3c:	e0fff717 	ldw	r3,-36(fp)
   24d40:	e0bff417 	ldw	r2,-48(fp)
   24d44:	1880062e 	bgeu	r3,r2,24d60 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
   24d48:	e0fff417 	ldw	r3,-48(fp)
   24d4c:	e0bff717 	ldw	r2,-36(fp)
   24d50:	1885c83a 	sub	r2,r3,r2
   24d54:	10bfffc4 	addi	r2,r2,-1
   24d58:	e0bff515 	stw	r2,-44(fp)
   24d5c:	00000b06 	br	24d8c <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
   24d60:	e0bff417 	ldw	r2,-48(fp)
   24d64:	10000526 	beq	r2,zero,24d7c <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
   24d68:	00c20004 	movi	r3,2048
   24d6c:	e0bff717 	ldw	r2,-36(fp)
   24d70:	1885c83a 	sub	r2,r3,r2
   24d74:	e0bff515 	stw	r2,-44(fp)
   24d78:	00000406 	br	24d8c <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
   24d7c:	00c1ffc4 	movi	r3,2047
   24d80:	e0bff717 	ldw	r2,-36(fp)
   24d84:	1885c83a 	sub	r2,r3,r2
   24d88:	e0bff515 	stw	r2,-44(fp)

      if (n == 0)
   24d8c:	e0bff517 	ldw	r2,-44(fp)
   24d90:	10001e26 	beq	r2,zero,24e0c <altera_avalon_jtag_uart_write+0x118>
        break;

      if (n > count)
   24d94:	e0fffe17 	ldw	r3,-8(fp)
   24d98:	e0bff517 	ldw	r2,-44(fp)
   24d9c:	1880022e 	bgeu	r3,r2,24da8 <altera_avalon_jtag_uart_write+0xb4>
        n = count;
   24da0:	e0bffe17 	ldw	r2,-8(fp)
   24da4:	e0bff515 	stw	r2,-44(fp)

      memcpy(sp->tx_buf + in, ptr, n);
   24da8:	e0bff717 	ldw	r2,-36(fp)
   24dac:	10820e04 	addi	r2,r2,2104
   24db0:	e0fffc17 	ldw	r3,-16(fp)
   24db4:	1885883a 	add	r2,r3,r2
   24db8:	1009883a 	mov	r4,r2
   24dbc:	e17ffd17 	ldw	r5,-12(fp)
   24dc0:	e1bff517 	ldw	r6,-44(fp)
   24dc4:	00191f00 	call	191f0 <memcpy>
      ptr   += n;
   24dc8:	e0fffd17 	ldw	r3,-12(fp)
   24dcc:	e0bff517 	ldw	r2,-44(fp)
   24dd0:	1885883a 	add	r2,r3,r2
   24dd4:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
   24dd8:	e0fffe17 	ldw	r3,-8(fp)
   24ddc:	e0bff517 	ldw	r2,-44(fp)
   24de0:	1885c83a 	sub	r2,r3,r2
   24de4:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   24de8:	e0fff717 	ldw	r3,-36(fp)
   24dec:	e0bff517 	ldw	r2,-44(fp)
   24df0:	1885883a 	add	r2,r3,r2
   24df4:	10c1ffcc 	andi	r3,r2,2047
   24df8:	e0bffc17 	ldw	r2,-16(fp)
   24dfc:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
   24e00:	e0bffe17 	ldw	r2,-8(fp)
   24e04:	00bfc716 	blt	zero,r2,24d24 <altera_avalon_jtag_uart_write+0x30>
   24e08:	00000106 	br	24e10 <altera_avalon_jtag_uart_write+0x11c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
   24e0c:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   24e10:	0005303a 	rdctl	r2,status
   24e14:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   24e18:	e0fff917 	ldw	r3,-28(fp)
   24e1c:	00bfff84 	movi	r2,-2
   24e20:	1884703a 	and	r2,r3,r2
   24e24:	1001703a 	wrctl	status,r2
  
  return context;
   24e28:	e0bff917 	ldw	r2,-28(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
   24e2c:	e0bff815 	stw	r2,-32(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
   24e30:	e0bffc17 	ldw	r2,-16(fp)
   24e34:	10800817 	ldw	r2,32(r2)
   24e38:	10c00094 	ori	r3,r2,2
   24e3c:	e0bffc17 	ldw	r2,-16(fp)
   24e40:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
   24e44:	e0bffc17 	ldw	r2,-16(fp)
   24e48:	10800017 	ldw	r2,0(r2)
   24e4c:	10800104 	addi	r2,r2,4
   24e50:	e0fffc17 	ldw	r3,-16(fp)
   24e54:	18c00817 	ldw	r3,32(r3)
   24e58:	10c00035 	stwio	r3,0(r2)
   24e5c:	e0bff817 	ldw	r2,-32(fp)
   24e60:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   24e64:	0005303a 	rdctl	r2,status
   24e68:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   24e6c:	e0fffb17 	ldw	r3,-20(fp)
   24e70:	00bfff84 	movi	r2,-2
   24e74:	1884703a 	and	r2,r3,r2
   24e78:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   24e7c:	e0bffa17 	ldw	r2,-24(fp)
   24e80:	1080004c 	andi	r2,r2,1
   24e84:	e0fffb17 	ldw	r3,-20(fp)
   24e88:	1884b03a 	or	r2,r3,r2
   24e8c:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
   24e90:	e0bffb17 	ldw	r2,-20(fp)
   24e94:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
   24e98:	e0bffe17 	ldw	r2,-8(fp)
   24e9c:	0080110e 	bge	zero,r2,24ee4 <altera_avalon_jtag_uart_write+0x1f0>
    {
      if (flags & O_NONBLOCK)
   24ea0:	e0bfff17 	ldw	r2,-4(fp)
   24ea4:	1090000c 	andi	r2,r2,16384
   24ea8:	1000111e 	bne	r2,zero,24ef0 <altera_avalon_jtag_uart_write+0x1fc>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
   24eac:	0001883a 	nop
   24eb0:	e0bffc17 	ldw	r2,-16(fp)
   24eb4:	10c00d17 	ldw	r3,52(r2)
   24eb8:	e0bff417 	ldw	r2,-48(fp)
   24ebc:	1880051e 	bne	r3,r2,24ed4 <altera_avalon_jtag_uart_write+0x1e0>
   24ec0:	e0bffc17 	ldw	r2,-16(fp)
   24ec4:	10c00917 	ldw	r3,36(r2)
   24ec8:	e0bffc17 	ldw	r2,-16(fp)
   24ecc:	10800117 	ldw	r2,4(r2)
   24ed0:	18bff736 	bltu	r3,r2,24eb0 <altera_avalon_jtag_uart_write+0x1bc>
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
   24ed4:	e0bffc17 	ldw	r2,-16(fp)
   24ed8:	10c00d17 	ldw	r3,52(r2)
   24edc:	e0bff417 	ldw	r2,-48(fp)
   24ee0:	18800526 	beq	r3,r2,24ef8 <altera_avalon_jtag_uart_write+0x204>
         break;
    }
  }
  while (count > 0);
   24ee4:	e0bffe17 	ldw	r2,-8(fp)
   24ee8:	00bfc516 	blt	zero,r2,24e00 <altera_avalon_jtag_uart_write+0x10c>
   24eec:	00000306 	br	24efc <altera_avalon_jtag_uart_write+0x208>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
   24ef0:	0001883a 	nop
   24ef4:	00000106 	br	24efc <altera_avalon_jtag_uart_write+0x208>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
         break;
   24ef8:	0001883a 	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
   24efc:	e0fffd17 	ldw	r3,-12(fp)
   24f00:	e0bff617 	ldw	r2,-40(fp)
   24f04:	18800426 	beq	r3,r2,24f18 <altera_avalon_jtag_uart_write+0x224>
    return ptr - start;
   24f08:	e0fffd17 	ldw	r3,-12(fp)
   24f0c:	e0bff617 	ldw	r2,-40(fp)
   24f10:	1885c83a 	sub	r2,r3,r2
   24f14:	00000606 	br	24f30 <altera_avalon_jtag_uart_write+0x23c>
  else if (flags & O_NONBLOCK)
   24f18:	e0bfff17 	ldw	r2,-4(fp)
   24f1c:	1090000c 	andi	r2,r2,16384
   24f20:	10000226 	beq	r2,zero,24f2c <altera_avalon_jtag_uart_write+0x238>
    return -EWOULDBLOCK;
   24f24:	00bffd44 	movi	r2,-11
   24f28:	00000106 	br	24f30 <altera_avalon_jtag_uart_write+0x23c>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
   24f2c:	00bffec4 	movi	r2,-5
}
   24f30:	e037883a 	mov	sp,fp
   24f34:	dfc00117 	ldw	ra,4(sp)
   24f38:	df000017 	ldw	fp,0(sp)
   24f3c:	dec00204 	addi	sp,sp,8
   24f40:	f800283a 	ret

00024f44 <lcd_write_command>:

/* --------------------------------------------------------------------- */

static void lcd_write_command(altera_avalon_lcd_16207_state* sp, 
  unsigned char command)
{
   24f44:	defffa04 	addi	sp,sp,-24
   24f48:	dfc00515 	stw	ra,20(sp)
   24f4c:	df000415 	stw	fp,16(sp)
   24f50:	df000404 	addi	fp,sp,16
   24f54:	e13ffe15 	stw	r4,-8(fp)
   24f58:	2805883a 	mov	r2,r5
   24f5c:	e0bfff05 	stb	r2,-4(fp)
  unsigned int base = sp->base;
   24f60:	e0bffe17 	ldw	r2,-8(fp)
   24f64:	10800017 	ldw	r2,0(r2)
   24f68:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
   24f6c:	008003f4 	movhi	r2,15
   24f70:	10909004 	addi	r2,r2,16960
   24f74:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
   24f78:	e0bffe17 	ldw	r2,-8(fp)
   24f7c:	10800803 	ldbu	r2,32(r2)
   24f80:	10803fcc 	andi	r2,r2,255
   24f84:	1080201c 	xori	r2,r2,128
   24f88:	10bfe004 	addi	r2,r2,-128
   24f8c:	10000a26 	beq	r2,zero,24fb8 <lcd_write_command+0x74>
    return;
   24f90:	00001406 	br	24fe4 <lcd_write_command+0xa0>

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
    if (--i == 0)
   24f94:	e0bffc17 	ldw	r2,-16(fp)
   24f98:	10bfffc4 	addi	r2,r2,-1
   24f9c:	e0bffc15 	stw	r2,-16(fp)
   24fa0:	e0bffc17 	ldw	r2,-16(fp)
   24fa4:	1000051e 	bne	r2,zero,24fbc <lcd_write_command+0x78>
    {
      sp->broken = 1;
   24fa8:	e0bffe17 	ldw	r2,-8(fp)
   24fac:	00c00044 	movi	r3,1
   24fb0:	10c00805 	stb	r3,32(r2)
      return;
   24fb4:	00000b06 	br	24fe4 <lcd_write_command+0xa0>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
   24fb8:	0001883a 	nop
   24fbc:	e0bffd17 	ldw	r2,-12(fp)
   24fc0:	10800104 	addi	r2,r2,4
   24fc4:	10800037 	ldwio	r2,0(r2)
   24fc8:	1080200c 	andi	r2,r2,128
   24fcc:	103ff11e 	bne	r2,zero,24f94 <lcd_write_command+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
   24fd0:	01001904 	movi	r4,100
   24fd4:	00224a80 	call	224a8 <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, command);
   24fd8:	e0bffd17 	ldw	r2,-12(fp)
   24fdc:	e0ffff03 	ldbu	r3,-4(fp)
   24fe0:	10c00035 	stwio	r3,0(r2)
}
   24fe4:	e037883a 	mov	sp,fp
   24fe8:	dfc00117 	ldw	ra,4(sp)
   24fec:	df000017 	ldw	fp,0(sp)
   24ff0:	dec00204 	addi	sp,sp,8
   24ff4:	f800283a 	ret

00024ff8 <lcd_write_data>:

/* --------------------------------------------------------------------- */

static void lcd_write_data(altera_avalon_lcd_16207_state* sp, 
  unsigned char data)
{
   24ff8:	defffa04 	addi	sp,sp,-24
   24ffc:	dfc00515 	stw	ra,20(sp)
   25000:	df000415 	stw	fp,16(sp)
   25004:	df000404 	addi	fp,sp,16
   25008:	e13ffe15 	stw	r4,-8(fp)
   2500c:	2805883a 	mov	r2,r5
   25010:	e0bfff05 	stb	r2,-4(fp)
  unsigned int base = sp->base;
   25014:	e0bffe17 	ldw	r2,-8(fp)
   25018:	10800017 	ldw	r2,0(r2)
   2501c:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
   25020:	008003f4 	movhi	r2,15
   25024:	10909004 	addi	r2,r2,16960
   25028:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
   2502c:	e0bffe17 	ldw	r2,-8(fp)
   25030:	10800803 	ldbu	r2,32(r2)
   25034:	10803fcc 	andi	r2,r2,255
   25038:	1080201c 	xori	r2,r2,128
   2503c:	10bfe004 	addi	r2,r2,-128
   25040:	10000a26 	beq	r2,zero,2506c <lcd_write_data+0x74>
    return;
   25044:	00001b06 	br	250b4 <lcd_write_data+0xbc>

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
    if (--i == 0)
   25048:	e0bffc17 	ldw	r2,-16(fp)
   2504c:	10bfffc4 	addi	r2,r2,-1
   25050:	e0bffc15 	stw	r2,-16(fp)
   25054:	e0bffc17 	ldw	r2,-16(fp)
   25058:	1000051e 	bne	r2,zero,25070 <lcd_write_data+0x78>
    {
      sp->broken = 1;
   2505c:	e0bffe17 	ldw	r2,-8(fp)
   25060:	00c00044 	movi	r3,1
   25064:	10c00805 	stb	r3,32(r2)
      return;
   25068:	00001206 	br	250b4 <lcd_write_data+0xbc>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
   2506c:	0001883a 	nop
   25070:	e0bffd17 	ldw	r2,-12(fp)
   25074:	10800104 	addi	r2,r2,4
   25078:	10800037 	ldwio	r2,0(r2)
   2507c:	1080200c 	andi	r2,r2,128
   25080:	103ff11e 	bne	r2,zero,25048 <lcd_write_data+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
   25084:	01001904 	movi	r4,100
   25088:	00224a80 	call	224a8 <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_DATA(base, data);
   2508c:	e0bffd17 	ldw	r2,-12(fp)
   25090:	10800204 	addi	r2,r2,8
   25094:	e0ffff03 	ldbu	r3,-4(fp)
   25098:	10c00035 	stwio	r3,0(r2)

  sp->address++;
   2509c:	e0bffe17 	ldw	r2,-8(fp)
   250a0:	108008c3 	ldbu	r2,35(r2)
   250a4:	10800044 	addi	r2,r2,1
   250a8:	1007883a 	mov	r3,r2
   250ac:	e0bffe17 	ldw	r2,-8(fp)
   250b0:	10c008c5 	stb	r3,35(r2)
}
   250b4:	e037883a 	mov	sp,fp
   250b8:	dfc00117 	ldw	ra,4(sp)
   250bc:	df000017 	ldw	fp,0(sp)
   250c0:	dec00204 	addi	sp,sp,8
   250c4:	f800283a 	ret

000250c8 <lcd_clear_screen>:

/* --------------------------------------------------------------------- */

static void lcd_clear_screen(altera_avalon_lcd_16207_state* sp)
{
   250c8:	defffc04 	addi	sp,sp,-16
   250cc:	dfc00315 	stw	ra,12(sp)
   250d0:	df000215 	stw	fp,8(sp)
   250d4:	df000204 	addi	fp,sp,8
   250d8:	e13fff15 	stw	r4,-4(fp)
  int y;

  lcd_write_command(sp, LCD_CMD_CLEAR);
   250dc:	e13fff17 	ldw	r4,-4(fp)
   250e0:	01400044 	movi	r5,1
   250e4:	0024f440 	call	24f44 <lcd_write_command>

  sp->x = 0;
   250e8:	e0bfff17 	ldw	r2,-4(fp)
   250ec:	10000845 	stb	zero,33(r2)
  sp->y = 0;
   250f0:	e0bfff17 	ldw	r2,-4(fp)
   250f4:	10000885 	stb	zero,34(r2)
  sp->address = 0;
   250f8:	e0bfff17 	ldw	r2,-4(fp)
   250fc:	100008c5 	stb	zero,35(r2)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   25100:	e03ffe15 	stw	zero,-8(fp)
   25104:	00001b06 	br	25174 <lcd_clear_screen+0xac>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
   25108:	e0bffe17 	ldw	r2,-8(fp)
   2510c:	108018e4 	muli	r2,r2,99
   25110:	10801004 	addi	r2,r2,64
   25114:	e0ffff17 	ldw	r3,-4(fp)
   25118:	1885883a 	add	r2,r3,r2
   2511c:	1009883a 	mov	r4,r2
   25120:	01400804 	movi	r5,32
   25124:	01801444 	movi	r6,81
   25128:	00192e80 	call	192e8 <memset>
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
   2512c:	e0bffe17 	ldw	r2,-8(fp)
   25130:	108018e4 	muli	r2,r2,99
   25134:	10800c04 	addi	r2,r2,48
   25138:	e0ffff17 	ldw	r3,-4(fp)
   2513c:	1885883a 	add	r2,r3,r2
   25140:	1009883a 	mov	r4,r2
   25144:	01400804 	movi	r5,32
   25148:	01800404 	movi	r6,16
   2514c:	00192e80 	call	192e8 <memset>
    sp->line[y].width = 0;
   25150:	e0ffff17 	ldw	r3,-4(fp)
   25154:	e0bffe17 	ldw	r2,-8(fp)
   25158:	108018e4 	muli	r2,r2,99
   2515c:	1885883a 	add	r2,r3,r2
   25160:	10802404 	addi	r2,r2,144
   25164:	10000045 	stb	zero,1(r2)

  sp->x = 0;
  sp->y = 0;
  sp->address = 0;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   25168:	e0bffe17 	ldw	r2,-8(fp)
   2516c:	10800044 	addi	r2,r2,1
   25170:	e0bffe15 	stw	r2,-8(fp)
   25174:	e0bffe17 	ldw	r2,-8(fp)
   25178:	10800090 	cmplti	r2,r2,2
   2517c:	103fe21e 	bne	r2,zero,25108 <lcd_clear_screen+0x40>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
    sp->line[y].width = 0;
  }
}
   25180:	e037883a 	mov	sp,fp
   25184:	dfc00117 	ldw	ra,4(sp)
   25188:	df000017 	ldw	fp,0(sp)
   2518c:	dec00204 	addi	sp,sp,8
   25190:	f800283a 	ret

00025194 <lcd_repaint_screen>:

/* --------------------------------------------------------------------- */

static void lcd_repaint_screen(altera_avalon_lcd_16207_state* sp)
{
   25194:	defff704 	addi	sp,sp,-36
   25198:	dfc00815 	stw	ra,32(sp)
   2519c:	df000715 	stw	fp,28(sp)
   251a0:	df000704 	addi	fp,sp,28
   251a4:	e13fff15 	stw	r4,-4(fp)
  /* scrollpos controls how much the lines have scrolled round.  The speed
   * each line scrolls at is controlled by its speed variable - while
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;
   251a8:	e0bfff17 	ldw	r2,-4(fp)
   251ac:	10800943 	ldbu	r2,37(r2)
   251b0:	10803fcc 	andi	r2,r2,255
   251b4:	e0bffc15 	stw	r2,-16(fp)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   251b8:	e03ff915 	stw	zero,-28(fp)
   251bc:	00006806 	br	25360 <lcd_repaint_screen+0x1cc>
  {
    int width  = sp->line[y].width;
   251c0:	e0ffff17 	ldw	r3,-4(fp)
   251c4:	e0bff917 	ldw	r2,-28(fp)
   251c8:	108018e4 	muli	r2,r2,99
   251cc:	1885883a 	add	r2,r3,r2
   251d0:	10802404 	addi	r2,r2,144
   251d4:	10800043 	ldbu	r2,1(r2)
   251d8:	10803fcc 	andi	r2,r2,255
   251dc:	1080201c 	xori	r2,r2,128
   251e0:	10bfe004 	addi	r2,r2,-128
   251e4:	e0bffd15 	stw	r2,-12(fp)
    int offset = (scrollpos * sp->line[y].speed) >> 8;
   251e8:	e0ffff17 	ldw	r3,-4(fp)
   251ec:	e0bff917 	ldw	r2,-28(fp)
   251f0:	108018e4 	muli	r2,r2,99
   251f4:	1885883a 	add	r2,r3,r2
   251f8:	10802404 	addi	r2,r2,144
   251fc:	10800083 	ldbu	r2,2(r2)
   25200:	10c03fcc 	andi	r3,r2,255
   25204:	e0bffc17 	ldw	r2,-16(fp)
   25208:	1885383a 	mul	r2,r3,r2
   2520c:	1005d23a 	srai	r2,r2,8
   25210:	e0bffb15 	stw	r2,-20(fp)
    if (offset >= width)
   25214:	e0fffb17 	ldw	r3,-20(fp)
   25218:	e0bffd17 	ldw	r2,-12(fp)
   2521c:	18800116 	blt	r3,r2,25224 <lcd_repaint_screen+0x90>
      offset = 0;
   25220:	e03ffb15 	stw	zero,-20(fp)

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
   25224:	e03ffa15 	stw	zero,-24(fp)
   25228:	00004706 	br	25348 <lcd_repaint_screen+0x1b4>
    {
      char c = sp->line[y].data[(x + offset) % width];
   2522c:	e0fffa17 	ldw	r3,-24(fp)
   25230:	e0bffb17 	ldw	r2,-20(fp)
   25234:	1885883a 	add	r2,r3,r2
   25238:	e0fffd17 	ldw	r3,-12(fp)
   2523c:	10c9283a 	div	r4,r2,r3
   25240:	e0fffd17 	ldw	r3,-12(fp)
   25244:	20c7383a 	mul	r3,r4,r3
   25248:	10c5c83a 	sub	r2,r2,r3
   2524c:	e13fff17 	ldw	r4,-4(fp)
   25250:	e0fff917 	ldw	r3,-28(fp)
   25254:	18c018e4 	muli	r3,r3,99
   25258:	20c7883a 	add	r3,r4,r3
   2525c:	1885883a 	add	r2,r3,r2
   25260:	10801004 	addi	r2,r2,64
   25264:	10800003 	ldbu	r2,0(r2)
   25268:	e0bffe05 	stb	r2,-8(fp)

      /* Writing data takes 40us, so don't do it unless required */
      if (sp->line[y].visible[x] != c)
   2526c:	e0ffff17 	ldw	r3,-4(fp)
   25270:	e0bff917 	ldw	r2,-28(fp)
   25274:	108018e4 	muli	r2,r2,99
   25278:	1887883a 	add	r3,r3,r2
   2527c:	e0bffa17 	ldw	r2,-24(fp)
   25280:	1885883a 	add	r2,r3,r2
   25284:	10800c04 	addi	r2,r2,48
   25288:	10800003 	ldbu	r2,0(r2)
   2528c:	10c03fcc 	andi	r3,r2,255
   25290:	18c0201c 	xori	r3,r3,128
   25294:	18ffe004 	addi	r3,r3,-128
   25298:	e0bffe07 	ldb	r2,-8(fp)
   2529c:	18802726 	beq	r3,r2,2533c <lcd_repaint_screen+0x1a8>
      {
        unsigned char address = x + colstart[y];
   252a0:	e0fff917 	ldw	r3,-28(fp)
   252a4:	d0a01a04 	addi	r2,gp,-32664
   252a8:	1885883a 	add	r2,r3,r2
   252ac:	10800003 	ldbu	r2,0(r2)
   252b0:	1007883a 	mov	r3,r2
   252b4:	e0bffa17 	ldw	r2,-24(fp)
   252b8:	1885883a 	add	r2,r3,r2
   252bc:	e0bffe45 	stb	r2,-7(fp)

        if (address != sp->address)
   252c0:	e0fffe43 	ldbu	r3,-7(fp)
   252c4:	e0bfff17 	ldw	r2,-4(fp)
   252c8:	108008c3 	ldbu	r2,35(r2)
   252cc:	10803fcc 	andi	r2,r2,255
   252d0:	1080201c 	xori	r2,r2,128
   252d4:	10bfe004 	addi	r2,r2,-128
   252d8:	18800a26 	beq	r3,r2,25304 <lcd_repaint_screen+0x170>
        {
          lcd_write_command(sp, LCD_CMD_WRITE_DATA | address);
   252dc:	e0fffe43 	ldbu	r3,-7(fp)
   252e0:	00bfe004 	movi	r2,-128
   252e4:	1884b03a 	or	r2,r3,r2
   252e8:	10803fcc 	andi	r2,r2,255
   252ec:	e13fff17 	ldw	r4,-4(fp)
   252f0:	100b883a 	mov	r5,r2
   252f4:	0024f440 	call	24f44 <lcd_write_command>
          sp->address = address;
   252f8:	e0fffe43 	ldbu	r3,-7(fp)
   252fc:	e0bfff17 	ldw	r2,-4(fp)
   25300:	10c008c5 	stb	r3,35(r2)
        }

        lcd_write_data(sp, c);
   25304:	e0bffe03 	ldbu	r2,-8(fp)
   25308:	10803fcc 	andi	r2,r2,255
   2530c:	e13fff17 	ldw	r4,-4(fp)
   25310:	100b883a 	mov	r5,r2
   25314:	0024ff80 	call	24ff8 <lcd_write_data>
        sp->line[y].visible[x] = c;
   25318:	e0ffff17 	ldw	r3,-4(fp)
   2531c:	e0bff917 	ldw	r2,-28(fp)
   25320:	108018e4 	muli	r2,r2,99
   25324:	1887883a 	add	r3,r3,r2
   25328:	e0bffa17 	ldw	r2,-24(fp)
   2532c:	1885883a 	add	r2,r3,r2
   25330:	10800c04 	addi	r2,r2,48
   25334:	e0fffe03 	ldbu	r3,-8(fp)
   25338:	10c00005 	stb	r3,0(r2)
    int width  = sp->line[y].width;
    int offset = (scrollpos * sp->line[y].speed) >> 8;
    if (offset >= width)
      offset = 0;

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
   2533c:	e0bffa17 	ldw	r2,-24(fp)
   25340:	10800044 	addi	r2,r2,1
   25344:	e0bffa15 	stw	r2,-24(fp)
   25348:	e0bffa17 	ldw	r2,-24(fp)
   2534c:	10800410 	cmplti	r2,r2,16
   25350:	103fb61e 	bne	r2,zero,2522c <lcd_repaint_screen+0x98>
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   25354:	e0bff917 	ldw	r2,-28(fp)
   25358:	10800044 	addi	r2,r2,1
   2535c:	e0bff915 	stw	r2,-28(fp)
   25360:	e0bff917 	ldw	r2,-28(fp)
   25364:	10800090 	cmplti	r2,r2,2
   25368:	103f951e 	bne	r2,zero,251c0 <lcd_repaint_screen+0x2c>
        lcd_write_data(sp, c);
        sp->line[y].visible[x] = c;
      }
    }
  }
}
   2536c:	e037883a 	mov	sp,fp
   25370:	dfc00117 	ldw	ra,4(sp)
   25374:	df000017 	ldw	fp,0(sp)
   25378:	dec00204 	addi	sp,sp,8
   2537c:	f800283a 	ret

00025380 <lcd_scroll_up>:

/* --------------------------------------------------------------------- */

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
   25380:	defffc04 	addi	sp,sp,-16
   25384:	dfc00315 	stw	ra,12(sp)
   25388:	df000215 	stw	fp,8(sp)
   2538c:	df000204 	addi	fp,sp,8
   25390:	e13fff15 	stw	r4,-4(fp)
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   25394:	e03ffe15 	stw	zero,-8(fp)
   25398:	00001e06 	br	25414 <lcd_scroll_up+0x94>
  {
    if (y < ALT_LCD_HEIGHT-1)
   2539c:	e0bffe17 	ldw	r2,-8(fp)
   253a0:	00801016 	blt	zero,r2,253e4 <lcd_scroll_up+0x64>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
   253a4:	e0bffe17 	ldw	r2,-8(fp)
   253a8:	108018e4 	muli	r2,r2,99
   253ac:	10801004 	addi	r2,r2,64
   253b0:	e0ffff17 	ldw	r3,-4(fp)
   253b4:	1887883a 	add	r3,r3,r2
   253b8:	e0bffe17 	ldw	r2,-8(fp)
   253bc:	10800044 	addi	r2,r2,1
   253c0:	108018e4 	muli	r2,r2,99
   253c4:	10801004 	addi	r2,r2,64
   253c8:	e13fff17 	ldw	r4,-4(fp)
   253cc:	2085883a 	add	r2,r4,r2
   253d0:	1809883a 	mov	r4,r3
   253d4:	100b883a 	mov	r5,r2
   253d8:	01801404 	movi	r6,80
   253dc:	00191f00 	call	191f0 <memcpy>
   253e0:	00000906 	br	25408 <lcd_scroll_up+0x88>
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
   253e4:	e0bffe17 	ldw	r2,-8(fp)
   253e8:	108018e4 	muli	r2,r2,99
   253ec:	10801004 	addi	r2,r2,64
   253f0:	e0ffff17 	ldw	r3,-4(fp)
   253f4:	1885883a 	add	r2,r3,r2
   253f8:	1009883a 	mov	r4,r2
   253fc:	01400804 	movi	r5,32
   25400:	01801404 	movi	r6,80
   25404:	00192e80 	call	192e8 <memset>

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   25408:	e0bffe17 	ldw	r2,-8(fp)
   2540c:	10800044 	addi	r2,r2,1
   25410:	e0bffe15 	stw	r2,-8(fp)
   25414:	e0bffe17 	ldw	r2,-8(fp)
   25418:	10800090 	cmplti	r2,r2,2
   2541c:	103fdf1e 	bne	r2,zero,2539c <lcd_scroll_up+0x1c>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
  }

  sp->y--;
   25420:	e0bfff17 	ldw	r2,-4(fp)
   25424:	10800883 	ldbu	r2,34(r2)
   25428:	10bfffc4 	addi	r2,r2,-1
   2542c:	1007883a 	mov	r3,r2
   25430:	e0bfff17 	ldw	r2,-4(fp)
   25434:	10c00885 	stb	r3,34(r2)
}
   25438:	e037883a 	mov	sp,fp
   2543c:	dfc00117 	ldw	ra,4(sp)
   25440:	df000017 	ldw	fp,0(sp)
   25444:	dec00204 	addi	sp,sp,8
   25448:	f800283a 	ret

0002544c <lcd_handle_escape>:

/* --------------------------------------------------------------------- */

static void lcd_handle_escape(altera_avalon_lcd_16207_state* sp, char c)
{
   2544c:	defff904 	addi	sp,sp,-28
   25450:	dfc00615 	stw	ra,24(sp)
   25454:	df000515 	stw	fp,20(sp)
   25458:	df000504 	addi	fp,sp,20
   2545c:	e13ffe15 	stw	r4,-8(fp)
   25460:	2805883a 	mov	r2,r5
   25464:	e0bfff05 	stb	r2,-4(fp)
  int parm1 = 0, parm2 = 0;
   25468:	e03ffb15 	stw	zero,-20(fp)
   2546c:	e03ffc15 	stw	zero,-16(fp)

  if (sp->escape[0] == '[')
   25470:	e0bffe17 	ldw	r2,-8(fp)
   25474:	10800a03 	ldbu	r2,40(r2)
   25478:	10803fcc 	andi	r2,r2,255
   2547c:	1080201c 	xori	r2,r2,128
   25480:	10bfe004 	addi	r2,r2,-128
   25484:	108016d8 	cmpnei	r2,r2,91
   25488:	1000441e 	bne	r2,zero,2559c <lcd_handle_escape+0x150>
  {
    char * ptr = sp->escape+1;
   2548c:	e0bffe17 	ldw	r2,-8(fp)
   25490:	10800a44 	addi	r2,r2,41
   25494:	e0bffd15 	stw	r2,-12(fp)
    while (isdigit(*ptr))
   25498:	00000d06 	br	254d0 <lcd_handle_escape+0x84>
      parm1 = (parm1 * 10) + (*ptr++ - '0');
   2549c:	e0bffb17 	ldw	r2,-20(fp)
   254a0:	10c002a4 	muli	r3,r2,10
   254a4:	e0bffd17 	ldw	r2,-12(fp)
   254a8:	10800003 	ldbu	r2,0(r2)
   254ac:	10803fcc 	andi	r2,r2,255
   254b0:	1080201c 	xori	r2,r2,128
   254b4:	10bfe004 	addi	r2,r2,-128
   254b8:	10bff404 	addi	r2,r2,-48
   254bc:	1885883a 	add	r2,r3,r2
   254c0:	e0bffb15 	stw	r2,-20(fp)
   254c4:	e0bffd17 	ldw	r2,-12(fp)
   254c8:	10800044 	addi	r2,r2,1
   254cc:	e0bffd15 	stw	r2,-12(fp)
  int parm1 = 0, parm2 = 0;

  if (sp->escape[0] == '[')
  {
    char * ptr = sp->escape+1;
    while (isdigit(*ptr))
   254d0:	008000f4 	movhi	r2,3
   254d4:	10959204 	addi	r2,r2,22088
   254d8:	10c00017 	ldw	r3,0(r2)
   254dc:	e0bffd17 	ldw	r2,-12(fp)
   254e0:	10800003 	ldbu	r2,0(r2)
   254e4:	10803fcc 	andi	r2,r2,255
   254e8:	1080201c 	xori	r2,r2,128
   254ec:	10bfe004 	addi	r2,r2,-128
   254f0:	1885883a 	add	r2,r3,r2
   254f4:	10800003 	ldbu	r2,0(r2)
   254f8:	10803fcc 	andi	r2,r2,255
   254fc:	1080010c 	andi	r2,r2,4
   25500:	103fe61e 	bne	r2,zero,2549c <lcd_handle_escape+0x50>
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
   25504:	e0bffd17 	ldw	r2,-12(fp)
   25508:	10800003 	ldbu	r2,0(r2)
   2550c:	10803fcc 	andi	r2,r2,255
   25510:	1080201c 	xori	r2,r2,128
   25514:	10bfe004 	addi	r2,r2,-128
   25518:	10800ed8 	cmpnei	r2,r2,59
   2551c:	1000211e 	bne	r2,zero,255a4 <lcd_handle_escape+0x158>
    {
      ptr++;
   25520:	e0bffd17 	ldw	r2,-12(fp)
   25524:	10800044 	addi	r2,r2,1
   25528:	e0bffd15 	stw	r2,-12(fp)
      while (isdigit(*ptr))
   2552c:	00000d06 	br	25564 <lcd_handle_escape+0x118>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
   25530:	e0bffc17 	ldw	r2,-16(fp)
   25534:	10c002a4 	muli	r3,r2,10
   25538:	e0bffd17 	ldw	r2,-12(fp)
   2553c:	10800003 	ldbu	r2,0(r2)
   25540:	10803fcc 	andi	r2,r2,255
   25544:	1080201c 	xori	r2,r2,128
   25548:	10bfe004 	addi	r2,r2,-128
   2554c:	10bff404 	addi	r2,r2,-48
   25550:	1885883a 	add	r2,r3,r2
   25554:	e0bffc15 	stw	r2,-16(fp)
   25558:	e0bffd17 	ldw	r2,-12(fp)
   2555c:	10800044 	addi	r2,r2,1
   25560:	e0bffd15 	stw	r2,-12(fp)
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
    {
      ptr++;
      while (isdigit(*ptr))
   25564:	008000f4 	movhi	r2,3
   25568:	10959204 	addi	r2,r2,22088
   2556c:	10c00017 	ldw	r3,0(r2)
   25570:	e0bffd17 	ldw	r2,-12(fp)
   25574:	10800003 	ldbu	r2,0(r2)
   25578:	10803fcc 	andi	r2,r2,255
   2557c:	1080201c 	xori	r2,r2,128
   25580:	10bfe004 	addi	r2,r2,-128
   25584:	1885883a 	add	r2,r3,r2
   25588:	10800003 	ldbu	r2,0(r2)
   2558c:	10803fcc 	andi	r2,r2,255
   25590:	1080010c 	andi	r2,r2,4
   25594:	103fe61e 	bne	r2,zero,25530 <lcd_handle_escape+0xe4>
   25598:	00000206 	br	255a4 <lcd_handle_escape+0x158>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
    }
  }
  else
    parm1 = -1;
   2559c:	00bfffc4 	movi	r2,-1
   255a0:	e0bffb15 	stw	r2,-20(fp)

  switch (c)
   255a4:	e0bfff07 	ldb	r2,-4(fp)
   255a8:	10c012a0 	cmpeqi	r3,r2,74
   255ac:	18002a1e 	bne	r3,zero,25658 <lcd_handle_escape+0x20c>
   255b0:	10c012c8 	cmpgei	r3,r2,75
   255b4:	1800031e 	bne	r3,zero,255c4 <lcd_handle_escape+0x178>
   255b8:	10801220 	cmpeqi	r2,r2,72
   255bc:	1000051e 	bne	r2,zero,255d4 <lcd_handle_escape+0x188>
   255c0:	00004c06 	br	256f4 <lcd_handle_escape+0x2a8>
   255c4:	10c012e0 	cmpeqi	r3,r2,75
   255c8:	1800291e 	bne	r3,zero,25670 <lcd_handle_escape+0x224>
   255cc:	108019a0 	cmpeqi	r2,r2,102
   255d0:	10004826 	beq	r2,zero,256f4 <lcd_handle_escape+0x2a8>
  {
  case 'H': /* ESC '[' <y> ';' <x> 'H'  : Move cursor to location */
  case 'f': /* Same as above */
    if (parm2 > 0)
   255d4:	e0bffc17 	ldw	r2,-16(fp)
   255d8:	0080050e 	bge	zero,r2,255f0 <lcd_handle_escape+0x1a4>
      sp->x = parm2 - 1;
   255dc:	e0bffc17 	ldw	r2,-16(fp)
   255e0:	10bfffc4 	addi	r2,r2,-1
   255e4:	1007883a 	mov	r3,r2
   255e8:	e0bffe17 	ldw	r2,-8(fp)
   255ec:	10c00845 	stb	r3,33(r2)
    if (parm1 > 0)
   255f0:	e0bffb17 	ldw	r2,-20(fp)
   255f4:	00803a0e 	bge	zero,r2,256e0 <lcd_handle_escape+0x294>
    {
      sp->y = parm1 - 1;
   255f8:	e0bffb17 	ldw	r2,-20(fp)
   255fc:	10bfffc4 	addi	r2,r2,-1
   25600:	1007883a 	mov	r3,r2
   25604:	e0bffe17 	ldw	r2,-8(fp)
   25608:	10c00885 	stb	r3,34(r2)
      if (sp->y > ALT_LCD_HEIGHT * 2)
   2560c:	e0bffe17 	ldw	r2,-8(fp)
   25610:	10800883 	ldbu	r2,34(r2)
   25614:	10803fcc 	andi	r2,r2,255
   25618:	10800170 	cmpltui	r2,r2,5
   2561c:	1000071e 	bne	r2,zero,2563c <lcd_handle_escape+0x1f0>
        sp->y = ALT_LCD_HEIGHT * 2;
   25620:	e0bffe17 	ldw	r2,-8(fp)
   25624:	00c00104 	movi	r3,4
   25628:	10c00885 	stb	r3,34(r2)
      while (sp->y > ALT_LCD_HEIGHT)
   2562c:	00000306 	br	2563c <lcd_handle_escape+0x1f0>
        lcd_scroll_up(sp);
   25630:	e13ffe17 	ldw	r4,-8(fp)
   25634:	00253800 	call	25380 <lcd_scroll_up>
   25638:	00000106 	br	25640 <lcd_handle_escape+0x1f4>
    if (parm1 > 0)
    {
      sp->y = parm1 - 1;
      if (sp->y > ALT_LCD_HEIGHT * 2)
        sp->y = ALT_LCD_HEIGHT * 2;
      while (sp->y > ALT_LCD_HEIGHT)
   2563c:	0001883a 	nop
   25640:	e0bffe17 	ldw	r2,-8(fp)
   25644:	10800883 	ldbu	r2,34(r2)
   25648:	10803fcc 	andi	r2,r2,255
   2564c:	108000e8 	cmpgeui	r2,r2,3
   25650:	103ff71e 	bne	r2,zero,25630 <lcd_handle_escape+0x1e4>
        lcd_scroll_up(sp);
    }
    break;
   25654:	00002206 	br	256e0 <lcd_handle_escape+0x294>
    /*   ESC J      is clear to beginning of line    [unimplemented]
     *   ESC [ 0 J  is clear to bottom of screen     [unimplemented]
     *   ESC [ 1 J  is clear to beginning of screen  [unimplemented]
     *   ESC [ 2 J  is clear screen
     */
    if (parm1 == 2)
   25658:	e0bffb17 	ldw	r2,-20(fp)
   2565c:	10800098 	cmpnei	r2,r2,2
   25660:	1000211e 	bne	r2,zero,256e8 <lcd_handle_escape+0x29c>
      lcd_clear_screen(sp);
   25664:	e13ffe17 	ldw	r4,-8(fp)
   25668:	00250c80 	call	250c8 <lcd_clear_screen>
    break;
   2566c:	00001e06 	br	256e8 <lcd_handle_escape+0x29c>
    /*   ESC K      is clear to end of line
     *   ESC [ 0 K  is clear to end of line
     *   ESC [ 1 K  is clear to beginning of line    [unimplemented]
     *   ESC [ 2 K  is clear line                    [unimplemented]
     */
    if (parm1 < 1)
   25670:	e0bffb17 	ldw	r2,-20(fp)
   25674:	00801e16 	blt	zero,r2,256f0 <lcd_handle_escape+0x2a4>
    {
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
   25678:	e0bffe17 	ldw	r2,-8(fp)
   2567c:	10800843 	ldbu	r2,33(r2)
   25680:	10803fcc 	andi	r2,r2,255
   25684:	10801428 	cmpgeui	r2,r2,80
   25688:	1000191e 	bne	r2,zero,256f0 <lcd_handle_escape+0x2a4>
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
   2568c:	e0bffe17 	ldw	r2,-8(fp)
   25690:	10800883 	ldbu	r2,34(r2)
   25694:	10803fcc 	andi	r2,r2,255
   25698:	108018e4 	muli	r2,r2,99
   2569c:	10801004 	addi	r2,r2,64
   256a0:	e0fffe17 	ldw	r3,-8(fp)
   256a4:	1887883a 	add	r3,r3,r2
   256a8:	e0bffe17 	ldw	r2,-8(fp)
   256ac:	10800843 	ldbu	r2,33(r2)
   256b0:	10803fcc 	andi	r2,r2,255
   256b4:	1887883a 	add	r3,r3,r2
   256b8:	e0bffe17 	ldw	r2,-8(fp)
   256bc:	10800843 	ldbu	r2,33(r2)
   256c0:	10803fcc 	andi	r2,r2,255
   256c4:	01001404 	movi	r4,80
   256c8:	2085c83a 	sub	r2,r4,r2
   256cc:	1809883a 	mov	r4,r3
   256d0:	01400804 	movi	r5,32
   256d4:	100d883a 	mov	r6,r2
   256d8:	00192e80 	call	192e8 <memset>
    }
    break;
   256dc:	00000406 	br	256f0 <lcd_handle_escape+0x2a4>
      if (sp->y > ALT_LCD_HEIGHT * 2)
        sp->y = ALT_LCD_HEIGHT * 2;
      while (sp->y > ALT_LCD_HEIGHT)
        lcd_scroll_up(sp);
    }
    break;
   256e0:	0001883a 	nop
   256e4:	00000306 	br	256f4 <lcd_handle_escape+0x2a8>
     *   ESC [ 1 J  is clear to beginning of screen  [unimplemented]
     *   ESC [ 2 J  is clear screen
     */
    if (parm1 == 2)
      lcd_clear_screen(sp);
    break;
   256e8:	0001883a 	nop
   256ec:	00000106 	br	256f4 <lcd_handle_escape+0x2a8>
    if (parm1 < 1)
    {
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
    }
    break;
   256f0:	0001883a 	nop
  }
}
   256f4:	e037883a 	mov	sp,fp
   256f8:	dfc00117 	ldw	ra,4(sp)
   256fc:	df000017 	ldw	fp,0(sp)
   25700:	dec00204 	addi	sp,sp,8
   25704:	f800283a 	ret

00025708 <altera_avalon_lcd_16207_write>:

/* --------------------------------------------------------------------- */

int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp, 
  const char* ptr, int len, int flags)
{
   25708:	defff304 	addi	sp,sp,-52
   2570c:	dfc00c15 	stw	ra,48(sp)
   25710:	df000b15 	stw	fp,44(sp)
   25714:	df000b04 	addi	fp,sp,44
   25718:	e13ffc15 	stw	r4,-16(fp)
   2571c:	e17ffd15 	stw	r5,-12(fp)
   25720:	e1bffe15 	stw	r6,-8(fp)
   25724:	e1ffff15 	stw	r7,-4(fp)
  const char* end = ptr + len;
   25728:	e0bffe17 	ldw	r2,-8(fp)
   2572c:	e0fffd17 	ldw	r3,-12(fp)
   25730:	1885883a 	add	r2,r3,r2
   25734:	e0bff815 	stw	r2,-32(fp)

  ALT_SEM_PEND (sp->write_lock, 0);

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;
   25738:	e0bffc17 	ldw	r2,-16(fp)
   2573c:	00c00044 	movi	r3,1
   25740:	10c009c5 	stb	r3,39(r2)

  for ( ; ptr < end ; ptr++)
   25744:	00009d06 	br	259bc <altera_avalon_lcd_16207_write+0x2b4>
  {
    char c = *ptr;
   25748:	e0bffd17 	ldw	r2,-12(fp)
   2574c:	10800003 	ldbu	r2,0(r2)
   25750:	e0bff905 	stb	r2,-28(fp)

    if (sp->esccount >= 0)
   25754:	e0bffc17 	ldw	r2,-16(fp)
   25758:	10800903 	ldbu	r2,36(r2)
   2575c:	10803fcc 	andi	r2,r2,255
   25760:	1080201c 	xori	r2,r2,128
   25764:	10bfe004 	addi	r2,r2,-128
   25768:	10003816 	blt	r2,zero,2584c <altera_avalon_lcd_16207_write+0x144>
    {
      unsigned int esccount = sp->esccount;
   2576c:	e0bffc17 	ldw	r2,-16(fp)
   25770:	10800903 	ldbu	r2,36(r2)
   25774:	10803fcc 	andi	r2,r2,255
   25778:	1080201c 	xori	r2,r2,128
   2577c:	10bfe004 	addi	r2,r2,-128
   25780:	e0bffa15 	stw	r2,-24(fp)

      /* Single character escape sequences can end with any character
       * Multi character escape sequences start with '[' and contain
       * digits and semicolons before terminating
       */
      if ((esccount == 0 && c != '[') ||
   25784:	e0bffa17 	ldw	r2,-24(fp)
   25788:	1000031e 	bne	r2,zero,25798 <altera_avalon_lcd_16207_write+0x90>
   2578c:	e0bff907 	ldb	r2,-28(fp)
   25790:	108016d8 	cmpnei	r2,r2,91
   25794:	10000e1e 	bne	r2,zero,257d0 <altera_avalon_lcd_16207_write+0xc8>
   25798:	e0bffa17 	ldw	r2,-24(fp)
   2579c:	10001926 	beq	r2,zero,25804 <altera_avalon_lcd_16207_write+0xfc>
          (esccount > 0 && !isdigit(c) && c != ';'))
   257a0:	008000f4 	movhi	r2,3
   257a4:	10959204 	addi	r2,r2,22088
   257a8:	10c00017 	ldw	r3,0(r2)
   257ac:	e0bff907 	ldb	r2,-28(fp)
   257b0:	1885883a 	add	r2,r3,r2
   257b4:	10800003 	ldbu	r2,0(r2)
   257b8:	10803fcc 	andi	r2,r2,255
   257bc:	1080010c 	andi	r2,r2,4
   257c0:	1000101e 	bne	r2,zero,25804 <altera_avalon_lcd_16207_write+0xfc>
   257c4:	e0bff907 	ldb	r2,-28(fp)
   257c8:	10800ee0 	cmpeqi	r2,r2,59
   257cc:	10000d1e 	bne	r2,zero,25804 <altera_avalon_lcd_16207_write+0xfc>
      {
        sp->escape[esccount] = 0;
   257d0:	e0fffc17 	ldw	r3,-16(fp)
   257d4:	e0bffa17 	ldw	r2,-24(fp)
   257d8:	1885883a 	add	r2,r3,r2
   257dc:	10800a04 	addi	r2,r2,40
   257e0:	10000005 	stb	zero,0(r2)

        lcd_handle_escape(sp, c);
   257e4:	e0bff907 	ldb	r2,-28(fp)
   257e8:	e13ffc17 	ldw	r4,-16(fp)
   257ec:	100b883a 	mov	r5,r2
   257f0:	002544c0 	call	2544c <lcd_handle_escape>

        sp->esccount = -1;
   257f4:	e0bffc17 	ldw	r2,-16(fp)
   257f8:	00ffffc4 	movi	r3,-1
   257fc:	10c00905 	stb	r3,36(r2)
   25800:	00006b06 	br	259b0 <altera_avalon_lcd_16207_write+0x2a8>
      }
      else if (sp->esccount < sizeof(sp->escape)-1)
   25804:	e0bffc17 	ldw	r2,-16(fp)
   25808:	10800903 	ldbu	r2,36(r2)
   2580c:	10803fcc 	andi	r2,r2,255
   25810:	108001e8 	cmpgeui	r2,r2,7
   25814:	1000651e 	bne	r2,zero,259ac <altera_avalon_lcd_16207_write+0x2a4>
      {
        sp->escape[esccount] = c;
   25818:	e0fffc17 	ldw	r3,-16(fp)
   2581c:	e0bffa17 	ldw	r2,-24(fp)
   25820:	1885883a 	add	r2,r3,r2
   25824:	10800a04 	addi	r2,r2,40
   25828:	e0fff903 	ldbu	r3,-28(fp)
   2582c:	10c00005 	stb	r3,0(r2)
        sp->esccount++;
   25830:	e0bffc17 	ldw	r2,-16(fp)
   25834:	10800903 	ldbu	r2,36(r2)
   25838:	10800044 	addi	r2,r2,1
   2583c:	1007883a 	mov	r3,r2
   25840:	e0bffc17 	ldw	r2,-16(fp)
   25844:	10c00905 	stb	r3,36(r2)
   25848:	00005806 	br	259ac <altera_avalon_lcd_16207_write+0x2a4>
      }
    }
    else if (c == 27) /* ESC */
   2584c:	e0bff907 	ldb	r2,-28(fp)
   25850:	108006d8 	cmpnei	r2,r2,27
   25854:	1000031e 	bne	r2,zero,25864 <altera_avalon_lcd_16207_write+0x15c>
    {
      sp->esccount = 0;
   25858:	e0bffc17 	ldw	r2,-16(fp)
   2585c:	10000905 	stb	zero,36(r2)
   25860:	00005306 	br	259b0 <altera_avalon_lcd_16207_write+0x2a8>
    }
    else if (c == '\r')
   25864:	e0bff907 	ldb	r2,-28(fp)
   25868:	10800358 	cmpnei	r2,r2,13
   2586c:	1000031e 	bne	r2,zero,2587c <altera_avalon_lcd_16207_write+0x174>
    {
      sp->x = 0;
   25870:	e0bffc17 	ldw	r2,-16(fp)
   25874:	10000845 	stb	zero,33(r2)
   25878:	00004d06 	br	259b0 <altera_avalon_lcd_16207_write+0x2a8>
    }
    else if (c == '\n')
   2587c:	e0bff907 	ldb	r2,-28(fp)
   25880:	10800298 	cmpnei	r2,r2,10
   25884:	1000101e 	bne	r2,zero,258c8 <altera_avalon_lcd_16207_write+0x1c0>
    {
      sp->x = 0;
   25888:	e0bffc17 	ldw	r2,-16(fp)
   2588c:	10000845 	stb	zero,33(r2)
      sp->y++;
   25890:	e0bffc17 	ldw	r2,-16(fp)
   25894:	10800883 	ldbu	r2,34(r2)
   25898:	10800044 	addi	r2,r2,1
   2589c:	1007883a 	mov	r3,r2
   258a0:	e0bffc17 	ldw	r2,-16(fp)
   258a4:	10c00885 	stb	r3,34(r2)

      /* Let the cursor sit at X=0, Y=HEIGHT without scrolling so the user
       * can print two lines of data without losing one.
       */
      if (sp->y > ALT_LCD_HEIGHT)
   258a8:	e0bffc17 	ldw	r2,-16(fp)
   258ac:	10800883 	ldbu	r2,34(r2)
   258b0:	10803fcc 	andi	r2,r2,255
   258b4:	108000f0 	cmpltui	r2,r2,3
   258b8:	10003d1e 	bne	r2,zero,259b0 <altera_avalon_lcd_16207_write+0x2a8>
        lcd_scroll_up(sp);
   258bc:	e13ffc17 	ldw	r4,-16(fp)
   258c0:	00253800 	call	25380 <lcd_scroll_up>
   258c4:	00003a06 	br	259b0 <altera_avalon_lcd_16207_write+0x2a8>
    }
    else if (c == '\b')
   258c8:	e0bff907 	ldb	r2,-28(fp)
   258cc:	10800218 	cmpnei	r2,r2,8
   258d0:	10000b1e 	bne	r2,zero,25900 <altera_avalon_lcd_16207_write+0x1f8>
    {
      if (sp->x > 0)
   258d4:	e0bffc17 	ldw	r2,-16(fp)
   258d8:	10800843 	ldbu	r2,33(r2)
   258dc:	10803fcc 	andi	r2,r2,255
   258e0:	10003326 	beq	r2,zero,259b0 <altera_avalon_lcd_16207_write+0x2a8>
        sp->x--;
   258e4:	e0bffc17 	ldw	r2,-16(fp)
   258e8:	10800843 	ldbu	r2,33(r2)
   258ec:	10bfffc4 	addi	r2,r2,-1
   258f0:	1007883a 	mov	r3,r2
   258f4:	e0bffc17 	ldw	r2,-16(fp)
   258f8:	10c00845 	stb	r3,33(r2)
   258fc:	00002c06 	br	259b0 <altera_avalon_lcd_16207_write+0x2a8>
    }
    else if (isprint(c))
   25900:	008000f4 	movhi	r2,3
   25904:	10959204 	addi	r2,r2,22088
   25908:	10c00017 	ldw	r3,0(r2)
   2590c:	e0bff907 	ldb	r2,-28(fp)
   25910:	1885883a 	add	r2,r3,r2
   25914:	10800003 	ldbu	r2,0(r2)
   25918:	10803fcc 	andi	r2,r2,255
   2591c:	1080201c 	xori	r2,r2,128
   25920:	10bfe004 	addi	r2,r2,-128
   25924:	108025cc 	andi	r2,r2,151
   25928:	10002126 	beq	r2,zero,259b0 <altera_avalon_lcd_16207_write+0x2a8>
    {
      /* If we didn't scroll on the last linefeed then we might need to do
       * it now. */
      if (sp->y >= ALT_LCD_HEIGHT)
   2592c:	e0bffc17 	ldw	r2,-16(fp)
   25930:	10800883 	ldbu	r2,34(r2)
   25934:	10803fcc 	andi	r2,r2,255
   25938:	108000b0 	cmpltui	r2,r2,2
   2593c:	1000021e 	bne	r2,zero,25948 <altera_avalon_lcd_16207_write+0x240>
        lcd_scroll_up(sp);
   25940:	e13ffc17 	ldw	r4,-16(fp)
   25944:	00253800 	call	25380 <lcd_scroll_up>

      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
   25948:	e0bffc17 	ldw	r2,-16(fp)
   2594c:	10800843 	ldbu	r2,33(r2)
   25950:	10803fcc 	andi	r2,r2,255
   25954:	10801428 	cmpgeui	r2,r2,80
   25958:	10000d1e 	bne	r2,zero,25990 <altera_avalon_lcd_16207_write+0x288>
        sp->line[sp->y].data[sp->x] = c;
   2595c:	e0bffc17 	ldw	r2,-16(fp)
   25960:	10800883 	ldbu	r2,34(r2)
   25964:	10c03fcc 	andi	r3,r2,255
   25968:	e0bffc17 	ldw	r2,-16(fp)
   2596c:	10800843 	ldbu	r2,33(r2)
   25970:	10803fcc 	andi	r2,r2,255
   25974:	e13ffc17 	ldw	r4,-16(fp)
   25978:	18c018e4 	muli	r3,r3,99
   2597c:	20c7883a 	add	r3,r4,r3
   25980:	1885883a 	add	r2,r3,r2
   25984:	10801004 	addi	r2,r2,64
   25988:	e0fff903 	ldbu	r3,-28(fp)
   2598c:	10c00005 	stb	r3,0(r2)

      sp->x++;
   25990:	e0bffc17 	ldw	r2,-16(fp)
   25994:	10800843 	ldbu	r2,33(r2)
   25998:	10800044 	addi	r2,r2,1
   2599c:	1007883a 	mov	r3,r2
   259a0:	e0bffc17 	ldw	r2,-16(fp)
   259a4:	10c00845 	stb	r3,33(r2)
   259a8:	00000106 	br	259b0 <altera_avalon_lcd_16207_write+0x2a8>
        sp->esccount = -1;
      }
      else if (sp->esccount < sizeof(sp->escape)-1)
      {
        sp->escape[esccount] = c;
        sp->esccount++;
   259ac:	0001883a 	nop

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;

  for ( ; ptr < end ; ptr++)
   259b0:	e0bffd17 	ldw	r2,-12(fp)
   259b4:	10800044 	addi	r2,r2,1
   259b8:	e0bffd15 	stw	r2,-12(fp)
   259bc:	e0fffd17 	ldw	r3,-12(fp)
   259c0:	e0bff817 	ldw	r2,-32(fp)
   259c4:	18bf6036 	bltu	r3,r2,25748 <altera_avalon_lcd_16207_write+0x40>
      sp->x++;
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
   259c8:	00800404 	movi	r2,16
   259cc:	e0bff615 	stw	r2,-40(fp)
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   259d0:	e03ff515 	stw	zero,-44(fp)
   259d4:	00003706 	br	25ab4 <altera_avalon_lcd_16207_write+0x3ac>
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
   259d8:	00801404 	movi	r2,80
   259dc:	e0bff715 	stw	r2,-36(fp)
   259e0:	00001106 	br	25a28 <altera_avalon_lcd_16207_write+0x320>
      if (sp->line[y].data[width-1] != ' ')
   259e4:	e0bff717 	ldw	r2,-36(fp)
   259e8:	10bfffc4 	addi	r2,r2,-1
   259ec:	e13ffc17 	ldw	r4,-16(fp)
   259f0:	e0fff517 	ldw	r3,-44(fp)
   259f4:	18c018e4 	muli	r3,r3,99
   259f8:	20c7883a 	add	r3,r4,r3
   259fc:	1885883a 	add	r2,r3,r2
   25a00:	10801004 	addi	r2,r2,64
   25a04:	10800003 	ldbu	r2,0(r2)
   25a08:	10803fcc 	andi	r2,r2,255
   25a0c:	1080201c 	xori	r2,r2,128
   25a10:	10bfe004 	addi	r2,r2,-128
   25a14:	10800820 	cmpeqi	r2,r2,32
   25a18:	10000626 	beq	r2,zero,25a34 <altera_avalon_lcd_16207_write+0x32c>
  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
   25a1c:	e0bff717 	ldw	r2,-36(fp)
   25a20:	10bfffc4 	addi	r2,r2,-1
   25a24:	e0bff715 	stw	r2,-36(fp)
   25a28:	e0bff717 	ldw	r2,-36(fp)
   25a2c:	00bfed16 	blt	zero,r2,259e4 <altera_avalon_lcd_16207_write+0x2dc>
   25a30:	00000106 	br	25a38 <altera_avalon_lcd_16207_write+0x330>
      if (sp->line[y].data[width-1] != ' ')
        break;
   25a34:	0001883a 	nop

    /* The minimum width is the size of the LCD panel.  If the real width
     * is long enough to require scrolling then add an extra space so the
     * end of the message doesn't run into the beginning of it.
     */
    if (width <= ALT_LCD_WIDTH)
   25a38:	e0bff717 	ldw	r2,-36(fp)
   25a3c:	10800448 	cmpgei	r2,r2,17
   25a40:	1000031e 	bne	r2,zero,25a50 <altera_avalon_lcd_16207_write+0x348>
      width = ALT_LCD_WIDTH;
   25a44:	00800404 	movi	r2,16
   25a48:	e0bff715 	stw	r2,-36(fp)
   25a4c:	00000306 	br	25a5c <altera_avalon_lcd_16207_write+0x354>
    else
      width++;
   25a50:	e0bff717 	ldw	r2,-36(fp)
   25a54:	10800044 	addi	r2,r2,1
   25a58:	e0bff715 	stw	r2,-36(fp)

    sp->line[y].width = width;
   25a5c:	e0bff717 	ldw	r2,-36(fp)
   25a60:	1007883a 	mov	r3,r2
   25a64:	e13ffc17 	ldw	r4,-16(fp)
   25a68:	e0bff517 	ldw	r2,-44(fp)
   25a6c:	108018e4 	muli	r2,r2,99
   25a70:	2085883a 	add	r2,r4,r2
   25a74:	10802404 	addi	r2,r2,144
   25a78:	10c00045 	stb	r3,1(r2)
    if (widthmax < width)
   25a7c:	e0fff617 	ldw	r3,-40(fp)
   25a80:	e0bff717 	ldw	r2,-36(fp)
   25a84:	1880020e 	bge	r3,r2,25a90 <altera_avalon_lcd_16207_write+0x388>
      widthmax = width;
   25a88:	e0bff717 	ldw	r2,-36(fp)
   25a8c:	e0bff615 	stw	r2,-40(fp)
    sp->line[y].speed = 0; /* By default lines don't scroll */
   25a90:	e0fffc17 	ldw	r3,-16(fp)
   25a94:	e0bff517 	ldw	r2,-44(fp)
   25a98:	108018e4 	muli	r2,r2,99
   25a9c:	1885883a 	add	r2,r3,r2
   25aa0:	10802404 	addi	r2,r2,144
   25aa4:	10000085 	stb	zero,2(r2)
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   25aa8:	e0bff517 	ldw	r2,-44(fp)
   25aac:	10800044 	addi	r2,r2,1
   25ab0:	e0bff515 	stw	r2,-44(fp)
   25ab4:	e0bff517 	ldw	r2,-44(fp)
   25ab8:	10800090 	cmplti	r2,r2,2
   25abc:	103fc61e 	bne	r2,zero,259d8 <altera_avalon_lcd_16207_write+0x2d0>
    if (widthmax < width)
      widthmax = width;
    sp->line[y].speed = 0; /* By default lines don't scroll */
  }

  if (widthmax <= ALT_LCD_WIDTH)
   25ac0:	e0bff617 	ldw	r2,-40(fp)
   25ac4:	10800448 	cmpgei	r2,r2,17
   25ac8:	1000031e 	bne	r2,zero,25ad8 <altera_avalon_lcd_16207_write+0x3d0>
    sp->scrollmax = 0;
   25acc:	e0bffc17 	ldw	r2,-16(fp)
   25ad0:	10000985 	stb	zero,38(r2)
   25ad4:	00002d06 	br	25b8c <altera_avalon_lcd_16207_write+0x484>
  else
  {
    widthmax *= 2;
   25ad8:	e0bff617 	ldw	r2,-40(fp)
   25adc:	1085883a 	add	r2,r2,r2
   25ae0:	e0bff615 	stw	r2,-40(fp)
    sp->scrollmax = widthmax;
   25ae4:	e0bff617 	ldw	r2,-40(fp)
   25ae8:	1007883a 	mov	r3,r2
   25aec:	e0bffc17 	ldw	r2,-16(fp)
   25af0:	10c00985 	stb	r3,38(r2)

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   25af4:	e03ff515 	stw	zero,-44(fp)
   25af8:	00002106 	br	25b80 <altera_avalon_lcd_16207_write+0x478>
      if (sp->line[y].width > ALT_LCD_WIDTH)
   25afc:	e0fffc17 	ldw	r3,-16(fp)
   25b00:	e0bff517 	ldw	r2,-44(fp)
   25b04:	108018e4 	muli	r2,r2,99
   25b08:	1885883a 	add	r2,r3,r2
   25b0c:	10802404 	addi	r2,r2,144
   25b10:	10800043 	ldbu	r2,1(r2)
   25b14:	10803fcc 	andi	r2,r2,255
   25b18:	1080201c 	xori	r2,r2,128
   25b1c:	10bfe004 	addi	r2,r2,-128
   25b20:	10800450 	cmplti	r2,r2,17
   25b24:	1000131e 	bne	r2,zero,25b74 <altera_avalon_lcd_16207_write+0x46c>
         */
#if 1
        /* This option makes all the lines scroll round at different speeds
         * which are chosen so that all the scrolls finish at the same time.
         */
        sp->line[y].speed = 256 * sp->line[y].width / widthmax;
   25b28:	e0fffc17 	ldw	r3,-16(fp)
   25b2c:	e0bff517 	ldw	r2,-44(fp)
   25b30:	108018e4 	muli	r2,r2,99
   25b34:	1885883a 	add	r2,r3,r2
   25b38:	10802404 	addi	r2,r2,144
   25b3c:	10800043 	ldbu	r2,1(r2)
   25b40:	10803fcc 	andi	r2,r2,255
   25b44:	1080201c 	xori	r2,r2,128
   25b48:	10bfe004 	addi	r2,r2,-128
   25b4c:	1006923a 	slli	r3,r2,8
   25b50:	e0bff617 	ldw	r2,-40(fp)
   25b54:	1885283a 	div	r2,r3,r2
   25b58:	1007883a 	mov	r3,r2
   25b5c:	e13ffc17 	ldw	r4,-16(fp)
   25b60:	e0bff517 	ldw	r2,-44(fp)
   25b64:	108018e4 	muli	r2,r2,99
   25b68:	2085883a 	add	r2,r4,r2
   25b6c:	10802404 	addi	r2,r2,144
   25b70:	10c00085 	stb	r3,2(r2)
  {
    widthmax *= 2;
    sp->scrollmax = widthmax;

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   25b74:	e0bff517 	ldw	r2,-44(fp)
   25b78:	10800044 	addi	r2,r2,1
   25b7c:	e0bff515 	stw	r2,-44(fp)
   25b80:	e0bff517 	ldw	r2,-44(fp)
   25b84:	10800090 	cmplti	r2,r2,2
   25b88:	103fdc1e 	bne	r2,zero,25afc <altera_avalon_lcd_16207_write+0x3f4>
   * (because active was set when the timer interrupt occurred).  If there
   * has been a missed repaint then paint again.  And again.  etc.
   */
  for ( ; ; )
  {
    int old_scrollpos = sp->scrollpos;
   25b8c:	e0bffc17 	ldw	r2,-16(fp)
   25b90:	10800943 	ldbu	r2,37(r2)
   25b94:	10803fcc 	andi	r2,r2,255
   25b98:	e0bffb15 	stw	r2,-20(fp)

    lcd_repaint_screen(sp);
   25b9c:	e13ffc17 	ldw	r4,-16(fp)
   25ba0:	00251940 	call	25194 <lcd_repaint_screen>

    /* Let the timer routines repaint the display again */
    sp->active = 0;
   25ba4:	e0bffc17 	ldw	r2,-16(fp)
   25ba8:	100009c5 	stb	zero,39(r2)

    /* Have the timer routines tried to scroll while we were painting?
     * If not then we can exit */
    if (sp->scrollpos == old_scrollpos)
   25bac:	e0bffc17 	ldw	r2,-16(fp)
   25bb0:	10800943 	ldbu	r2,37(r2)
   25bb4:	10c03fcc 	andi	r3,r2,255
   25bb8:	e0bffb17 	ldw	r2,-20(fp)
   25bbc:	18800426 	beq	r3,r2,25bd0 <altera_avalon_lcd_16207_write+0x4c8>
      break;

    /* We need to repaint again since the display scrolled while we were
     * painting last time */
    sp->active = 1;
   25bc0:	e0bffc17 	ldw	r2,-16(fp)
   25bc4:	00c00044 	movi	r3,1
   25bc8:	10c009c5 	stb	r3,39(r2)
  }
   25bcc:	003fef06 	br	25b8c <altera_avalon_lcd_16207_write+0x484>
    sp->active = 0;

    /* Have the timer routines tried to scroll while we were painting?
     * If not then we can exit */
    if (sp->scrollpos == old_scrollpos)
      break;
   25bd0:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);

  return len;
   25bd4:	e0bffe17 	ldw	r2,-8(fp)
}
   25bd8:	e037883a 	mov	sp,fp
   25bdc:	dfc00117 	ldw	ra,4(sp)
   25be0:	df000017 	ldw	fp,0(sp)
   25be4:	dec00204 	addi	sp,sp,8
   25be8:	f800283a 	ret

00025bec <alt_lcd_16207_timeout>:
/*
 * Timeout routine is called every second
 */

static alt_u32 alt_lcd_16207_timeout(void* context) 
{
   25bec:	defffc04 	addi	sp,sp,-16
   25bf0:	dfc00315 	stw	ra,12(sp)
   25bf4:	df000215 	stw	fp,8(sp)
   25bf8:	df000204 	addi	fp,sp,8
   25bfc:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_lcd_16207_state* sp = (altera_avalon_lcd_16207_state*)context;
   25c00:	e0bfff17 	ldw	r2,-4(fp)
   25c04:	e0bffe15 	stw	r2,-8(fp)

  /* Update the scrolling position */
  if (sp->scrollpos + 1 >= sp->scrollmax)
   25c08:	e0bffe17 	ldw	r2,-8(fp)
   25c0c:	10800943 	ldbu	r2,37(r2)
   25c10:	10803fcc 	andi	r2,r2,255
   25c14:	10c00044 	addi	r3,r2,1
   25c18:	e0bffe17 	ldw	r2,-8(fp)
   25c1c:	10800983 	ldbu	r2,38(r2)
   25c20:	10803fcc 	andi	r2,r2,255
   25c24:	18800316 	blt	r3,r2,25c34 <alt_lcd_16207_timeout+0x48>
    sp->scrollpos = 0;
   25c28:	e0bffe17 	ldw	r2,-8(fp)
   25c2c:	10000945 	stb	zero,37(r2)
   25c30:	00000606 	br	25c4c <alt_lcd_16207_timeout+0x60>
  else
    sp->scrollpos = sp->scrollpos + 1;
   25c34:	e0bffe17 	ldw	r2,-8(fp)
   25c38:	10800943 	ldbu	r2,37(r2)
   25c3c:	10800044 	addi	r2,r2,1
   25c40:	1007883a 	mov	r3,r2
   25c44:	e0bffe17 	ldw	r2,-8(fp)
   25c48:	10c00945 	stb	r3,37(r2)

  /* Repaint the panel unless the foreground will do it again soon */
  if (sp->scrollmax > 0 && !sp->active)
   25c4c:	e0bffe17 	ldw	r2,-8(fp)
   25c50:	10800983 	ldbu	r2,38(r2)
   25c54:	10803fcc 	andi	r2,r2,255
   25c58:	10000826 	beq	r2,zero,25c7c <alt_lcd_16207_timeout+0x90>
   25c5c:	e0bffe17 	ldw	r2,-8(fp)
   25c60:	108009c3 	ldbu	r2,39(r2)
   25c64:	10803fcc 	andi	r2,r2,255
   25c68:	1080201c 	xori	r2,r2,128
   25c6c:	10bfe004 	addi	r2,r2,-128
   25c70:	1000021e 	bne	r2,zero,25c7c <alt_lcd_16207_timeout+0x90>
    lcd_repaint_screen(sp);
   25c74:	e13ffe17 	ldw	r4,-8(fp)
   25c78:	00251940 	call	25194 <lcd_repaint_screen>

  return sp->period;
   25c7c:	e0bffe17 	ldw	r2,-8(fp)
   25c80:	10800717 	ldw	r2,28(r2)
}
   25c84:	e037883a 	mov	sp,fp
   25c88:	dfc00117 	ldw	ra,4(sp)
   25c8c:	df000017 	ldw	fp,0(sp)
   25c90:	dec00204 	addi	sp,sp,8
   25c94:	f800283a 	ret

00025c98 <altera_avalon_lcd_16207_init>:

/*
 * Called at boot time to initialise the LCD driver
 */
void altera_avalon_lcd_16207_init(altera_avalon_lcd_16207_state* sp)
{
   25c98:	defffc04 	addi	sp,sp,-16
   25c9c:	dfc00315 	stw	ra,12(sp)
   25ca0:	df000215 	stw	fp,8(sp)
   25ca4:	df000204 	addi	fp,sp,8
   25ca8:	e13fff15 	stw	r4,-4(fp)
  unsigned int base = sp->base;
   25cac:	e0bfff17 	ldw	r2,-4(fp)
   25cb0:	10800017 	ldw	r2,0(r2)
   25cb4:	e0bffe15 	stw	r2,-8(fp)

  /* Mark the device as functional */
  sp->broken = 0;
   25cb8:	e0bfff17 	ldw	r2,-4(fp)
   25cbc:	10000805 	stb	zero,32(r2)
   * the BUSY bit in the status register doesn't work until the display
   * has been reset three times.
   */

  /* Wait for 15 ms then reset */
  usleep(15000);
   25cc0:	010ea604 	movi	r4,15000
   25cc4:	00224a80 	call	224a8 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
   25cc8:	e0bffe17 	ldw	r2,-8(fp)
   25ccc:	00c00c04 	movi	r3,48
   25cd0:	10c00035 	stwio	r3,0(r2)

  /* Wait for another 4.1ms and reset again */
  usleep(4100);  
   25cd4:	01040104 	movi	r4,4100
   25cd8:	00224a80 	call	224a8 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
   25cdc:	e0bffe17 	ldw	r2,-8(fp)
   25ce0:	00c00c04 	movi	r3,48
   25ce4:	10c00035 	stwio	r3,0(r2)

  /* Wait a further 1 ms and reset a third time */
  usleep(1000);
   25ce8:	0100fa04 	movi	r4,1000
   25cec:	00224a80 	call	224a8 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
   25cf0:	e0bffe17 	ldw	r2,-8(fp)
   25cf4:	00c00c04 	movi	r3,48
   25cf8:	10c00035 	stwio	r3,0(r2)

  /* Setup interface parameters: 8 bit bus, 2 rows, 5x7 font */
  lcd_write_command(sp, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT | LCD_CMD_TWO_LINE);
   25cfc:	e13fff17 	ldw	r4,-4(fp)
   25d00:	01400e04 	movi	r5,56
   25d04:	0024f440 	call	24f44 <lcd_write_command>
  
  /* Turn display off */
  lcd_write_command(sp, LCD_CMD_ONOFF);
   25d08:	e13fff17 	ldw	r4,-4(fp)
   25d0c:	01400204 	movi	r5,8
   25d10:	0024f440 	call	24f44 <lcd_write_command>

  /* Clear display */
  lcd_clear_screen(sp);
   25d14:	e13fff17 	ldw	r4,-4(fp)
   25d18:	00250c80 	call	250c8 <lcd_clear_screen>
  
  /* Set mode: increment after writing, don't shift display */
  lcd_write_command(sp, LCD_CMD_MODES | LCD_CMD_MODE_INC);
   25d1c:	e13fff17 	ldw	r4,-4(fp)
   25d20:	01400184 	movi	r5,6
   25d24:	0024f440 	call	24f44 <lcd_write_command>

  /* Turn display on */
  lcd_write_command(sp, LCD_CMD_ONOFF | LCD_CMD_ENABLE_DISP);
   25d28:	e13fff17 	ldw	r4,-4(fp)
   25d2c:	01400304 	movi	r5,12
   25d30:	0024f440 	call	24f44 <lcd_write_command>

  sp->esccount = -1;
   25d34:	e0bfff17 	ldw	r2,-4(fp)
   25d38:	00ffffc4 	movi	r3,-1
   25d3c:	10c00905 	stb	r3,36(r2)
  memset(sp->escape, 0, sizeof(sp->escape));
   25d40:	e0bfff17 	ldw	r2,-4(fp)
   25d44:	10800a04 	addi	r2,r2,40
   25d48:	1009883a 	mov	r4,r2
   25d4c:	000b883a 	mov	r5,zero
   25d50:	01800204 	movi	r6,8
   25d54:	00192e80 	call	192e8 <memset>

  sp->scrollpos = 0;
   25d58:	e0bfff17 	ldw	r2,-4(fp)
   25d5c:	10000945 	stb	zero,37(r2)
  sp->scrollmax = 0;
   25d60:	e0bfff17 	ldw	r2,-4(fp)
   25d64:	10000985 	stb	zero,38(r2)
  sp->active = 0;
   25d68:	e0bfff17 	ldw	r2,-4(fp)
   25d6c:	100009c5 	stb	zero,39(r2)
   25d70:	008000f4 	movhi	r2,3
   25d74:	109e4d04 	addi	r2,r2,31028
   25d78:	10800017 	ldw	r2,0(r2)

  sp->period = alt_ticks_per_second() / 10; /* Call every 100ms */
   25d7c:	1007883a 	mov	r3,r2
   25d80:	00800284 	movi	r2,10
   25d84:	1885203a 	divu	r2,r3,r2
   25d88:	1007883a 	mov	r3,r2
   25d8c:	e0bfff17 	ldw	r2,-4(fp)
   25d90:	10c00715 	stw	r3,28(r2)

  alt_alarm_start(&sp->alarm, sp->period, &alt_lcd_16207_timeout, sp);
   25d94:	e0bfff17 	ldw	r2,-4(fp)
   25d98:	10c00104 	addi	r3,r2,4
   25d9c:	e0bfff17 	ldw	r2,-4(fp)
   25da0:	10800717 	ldw	r2,28(r2)
   25da4:	1809883a 	mov	r4,r3
   25da8:	100b883a 	mov	r5,r2
   25dac:	018000b4 	movhi	r6,2
   25db0:	3196fb04 	addi	r6,r6,23532
   25db4:	e1ffff17 	ldw	r7,-4(fp)
   25db8:	00218400 	call	21840 <alt_alarm_start>
}
   25dbc:	e037883a 	mov	sp,fp
   25dc0:	dfc00117 	ldw	ra,4(sp)
   25dc4:	df000017 	ldw	fp,0(sp)
   25dc8:	dec00204 	addi	sp,sp,8
   25dcc:	f800283a 	ret

00025dd0 <altera_avalon_lcd_16207_write_fd>:
extern int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp,
  const char* ptr, int count, int flags);

int 
altera_avalon_lcd_16207_write_fd(alt_fd* fd, const char* buffer, int space)
{
   25dd0:	defffa04 	addi	sp,sp,-24
   25dd4:	dfc00515 	stw	ra,20(sp)
   25dd8:	df000415 	stw	fp,16(sp)
   25ddc:	df000404 	addi	fp,sp,16
   25de0:	e13ffd15 	stw	r4,-12(fp)
   25de4:	e17ffe15 	stw	r5,-8(fp)
   25de8:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_lcd_16207_dev* dev = (altera_avalon_lcd_16207_dev*) fd->dev; 
   25dec:	e0bffd17 	ldw	r2,-12(fp)
   25df0:	10800017 	ldw	r2,0(r2)
   25df4:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_lcd_16207_write(&dev->state, buffer, space,
   25df8:	e0bffc17 	ldw	r2,-16(fp)
   25dfc:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
   25e00:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_lcd_16207_write_fd(alt_fd* fd, const char* buffer, int space)
{
    altera_avalon_lcd_16207_dev* dev = (altera_avalon_lcd_16207_dev*) fd->dev; 

    return altera_avalon_lcd_16207_write(&dev->state, buffer, space,
   25e04:	10800217 	ldw	r2,8(r2)
   25e08:	1809883a 	mov	r4,r3
   25e0c:	e17ffe17 	ldw	r5,-8(fp)
   25e10:	e1bfff17 	ldw	r6,-4(fp)
   25e14:	100f883a 	mov	r7,r2
   25e18:	00257080 	call	25708 <altera_avalon_lcd_16207_write>
      fd->fd_flags);
}
   25e1c:	e037883a 	mov	sp,fp
   25e20:	dfc00117 	ldw	ra,4(sp)
   25e24:	df000017 	ldw	fp,0(sp)
   25e28:	dec00204 	addi	sp,sp,8
   25e2c:	f800283a 	ret

00025e30 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   25e30:	defffe04 	addi	sp,sp,-8
   25e34:	dfc00115 	stw	ra,4(sp)
   25e38:	df000015 	stw	fp,0(sp)
   25e3c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   25e40:	008000f4 	movhi	r2,3
   25e44:	10958804 	addi	r2,r2,22048
   25e48:	10800017 	ldw	r2,0(r2)
   25e4c:	10000526 	beq	r2,zero,25e64 <alt_get_errno+0x34>
   25e50:	008000f4 	movhi	r2,3
   25e54:	10958804 	addi	r2,r2,22048
   25e58:	10800017 	ldw	r2,0(r2)
   25e5c:	103ee83a 	callr	r2
   25e60:	00000206 	br	25e6c <alt_get_errno+0x3c>
   25e64:	008000f4 	movhi	r2,3
   25e68:	109e4904 	addi	r2,r2,31012
}
   25e6c:	e037883a 	mov	sp,fp
   25e70:	dfc00117 	ldw	ra,4(sp)
   25e74:	df000017 	ldw	fp,0(sp)
   25e78:	dec00204 	addi	sp,sp,8
   25e7c:	f800283a 	ret

00025e80 <alt_avalon_sgdma_do_async_transfer>:
 * - 0 for success, or various errors defined in <errno.h>
 */
int alt_avalon_sgdma_do_async_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
   25e80:	defffc04 	addi	sp,sp,-16
   25e84:	df000315 	stw	fp,12(sp)
   25e88:	df000304 	addi	fp,sp,12
   25e8c:	e13ffe15 	stw	r4,-8(fp)
   25e90:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
   25e94:	e0bffe17 	ldw	r2,-8(fp)
   25e98:	10800317 	ldw	r2,12(r2)
   25e9c:	10800037 	ldwio	r2,0(r2)
   25ea0:	1080040c 	andi	r2,r2,16
   25ea4:	10000226 	beq	r2,zero,25eb0 <alt_avalon_sgdma_do_async_transfer+0x30>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
   25ea8:	00bffc04 	movi	r2,-16
   25eac:	00003906 	br	25f94 <alt_avalon_sgdma_do_async_transfer+0x114>
  }

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
   25eb0:	e0bffe17 	ldw	r2,-8(fp)
   25eb4:	10800317 	ldw	r2,12(r2)
   25eb8:	10800404 	addi	r2,r2,16
   25ebc:	e0fffe17 	ldw	r3,-8(fp)
   25ec0:	18c00317 	ldw	r3,12(r3)
   25ec4:	18c00404 	addi	r3,r3,16
   25ec8:	19000037 	ldwio	r4,0(r3)
   25ecc:	00fff7c4 	movi	r3,-33
   25ed0:	20c6703a 	and	r3,r4,r3
   25ed4:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
   25ed8:	e0bffe17 	ldw	r2,-8(fp)
   25edc:	10800317 	ldw	r2,12(r2)
   25ee0:	00c03fc4 	movi	r3,255
   25ee4:	10c00035 	stwio	r3,0(r2)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
   25ee8:	e0bffe17 	ldw	r2,-8(fp)
   25eec:	10800317 	ldw	r2,12(r2)
   25ef0:	10800804 	addi	r2,r2,32
   25ef4:	e0ffff17 	ldw	r3,-4(fp)
   25ef8:	10c00035 	stwio	r3,0(r2)
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
   25efc:	e0bffe17 	ldw	r2,-8(fp)
   25f00:	10800917 	ldw	r2,36(r2)
   25f04:	10001126 	beq	r2,zero,25f4c <alt_avalon_sgdma_do_async_transfer+0xcc>
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   25f08:	e0bffe17 	ldw	r2,-8(fp)
   25f0c:	10800317 	ldw	r2,12(r2)
   25f10:	10800404 	addi	r2,r2,16
   25f14:	10800037 	ldwio	r2,0(r2)
   25f18:	e0bffd15 	stw	r2,-12(fp)

    control |= (dev->chain_control                          |
   25f1c:	e0bffe17 	ldw	r2,-8(fp)
   25f20:	10c00b17 	ldw	r3,44(r2)
   25f24:	e0bffd17 	ldw	r2,-12(fp)
   25f28:	1884b03a 	or	r2,r3,r2
   25f2c:	10801814 	ori	r2,r2,96
   25f30:	e0bffd15 	stw	r2,-12(fp)
                ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK  );

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   25f34:	e0bffe17 	ldw	r2,-8(fp)
   25f38:	10800317 	ldw	r2,12(r2)
   25f3c:	10800404 	addi	r2,r2,16
   25f40:	e0fffd17 	ldw	r3,-12(fp)
   25f44:	10c00035 	stwio	r3,0(r2)
   25f48:	00001106 	br	25f90 <alt_avalon_sgdma_do_async_transfer+0x110>
   *   - Run
   *   - Stop on an error with any particular descriptor
   *   - Disable interrupt generation
   */
  else {
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   25f4c:	e0bffe17 	ldw	r2,-8(fp)
   25f50:	10800317 	ldw	r2,12(r2)
   25f54:	10800404 	addi	r2,r2,16
   25f58:	10800037 	ldwio	r2,0(r2)
   25f5c:	e0bffd15 	stw	r2,-12(fp)

    control |= (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
   25f60:	e0bffd17 	ldw	r2,-12(fp)
   25f64:	10801814 	ori	r2,r2,96
   25f68:	e0bffd15 	stw	r2,-12(fp)
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK );
    control &= ~ALTERA_AVALON_SGDMA_CONTROL_IE_GLOBAL_MSK;
   25f6c:	e0fffd17 	ldw	r3,-12(fp)
   25f70:	00bffbc4 	movi	r2,-17
   25f74:	1884703a 	and	r2,r3,r2
   25f78:	e0bffd15 	stw	r2,-12(fp)

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   25f7c:	e0bffe17 	ldw	r2,-8(fp)
   25f80:	10800317 	ldw	r2,12(r2)
   25f84:	10800404 	addi	r2,r2,16
   25f88:	e0fffd17 	ldw	r3,-12(fp)
   25f8c:	10c00035 	stwio	r3,0(r2)

  /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
  return 0;
   25f90:	0005883a 	mov	r2,zero
}
   25f94:	e037883a 	mov	sp,fp
   25f98:	df000017 	ldw	fp,0(sp)
   25f9c:	dec00104 	addi	sp,sp,4
   25fa0:	f800283a 	ret

00025fa4 <alt_avalon_sgdma_do_sync_transfer>:
 * - status: Content of SGDMA status register.
 */
alt_u8 alt_avalon_sgdma_do_sync_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
   25fa4:	defffc04 	addi	sp,sp,-16
   25fa8:	df000315 	stw	fp,12(sp)
   25fac:	df000304 	addi	fp,sp,12
   25fb0:	e13ffe15 	stw	r4,-8(fp)
   25fb4:	e17fff15 	stw	r5,-4(fp)
  alt_u8 status;

  /* Wait for any pending transfers to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
   25fb8:	0001883a 	nop
   25fbc:	e0bffe17 	ldw	r2,-8(fp)
   25fc0:	10800317 	ldw	r2,12(r2)
   25fc4:	10800037 	ldwio	r2,0(r2)
   25fc8:	1080040c 	andi	r2,r2,16
   25fcc:	103ffb1e 	bne	r2,zero,25fbc <alt_avalon_sgdma_do_sync_transfer+0x18>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );


  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
   25fd0:	e0bffe17 	ldw	r2,-8(fp)
   25fd4:	10800317 	ldw	r2,12(r2)
   25fd8:	10800404 	addi	r2,r2,16
   25fdc:	e0fffe17 	ldw	r3,-8(fp)
   25fe0:	18c00317 	ldw	r3,12(r3)
   25fe4:	18c00404 	addi	r3,r3,16
   25fe8:	19000037 	ldwio	r4,0(r3)
   25fec:	00fff7c4 	movi	r3,-33
   25ff0:	20c6703a 	and	r3,r4,r3
   25ff4:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
   25ff8:	e0bffe17 	ldw	r2,-8(fp)
   25ffc:	10800317 	ldw	r2,12(r2)
   26000:	00c03fc4 	movi	r3,255
   26004:	10c00035 	stwio	r3,0(r2)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
   26008:	e0bffe17 	ldw	r2,-8(fp)
   2600c:	10800317 	ldw	r2,12(r2)
   26010:	10800804 	addi	r2,r2,32
   26014:	e0ffff17 	ldw	r3,-4(fp)
   26018:	10c00035 	stwio	r3,0(r2)
   * Set up SGDMA controller to:
   * - Disable interrupt generation
   * - Run once a valid descriptor is written to controller
   * - Stop on an error with any particular descriptor
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
   2601c:	e0bffe17 	ldw	r2,-8(fp)
   26020:	10800317 	ldw	r2,12(r2)
   26024:	10800404 	addi	r2,r2,16
   26028:	e0fffe17 	ldw	r3,-8(fp)
   2602c:	18c00317 	ldw	r3,12(r3)
   26030:	18c00404 	addi	r3,r3,16
   26034:	18c00037 	ldwio	r3,0(r3)
   26038:	18c01814 	ori	r3,r3,96
   2603c:	10c00035 	stwio	r3,0(r2)
    (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK |
     ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK | 
     IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base)) );

  /* Wait for the descriptor (chain) to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
   26040:	0001883a 	nop
   26044:	e0bffe17 	ldw	r2,-8(fp)
   26048:	10800317 	ldw	r2,12(r2)
   2604c:	10800037 	ldwio	r2,0(r2)
   26050:	1080040c 	andi	r2,r2,16
   26054:	103ffb1e 	bne	r2,zero,26044 <alt_avalon_sgdma_do_sync_transfer+0xa0>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
   26058:	e0bffe17 	ldw	r2,-8(fp)
   2605c:	10800317 	ldw	r2,12(r2)
   26060:	10800404 	addi	r2,r2,16
   26064:	e0fffe17 	ldw	r3,-8(fp)
   26068:	18c00317 	ldw	r3,12(r3)
   2606c:	18c00404 	addi	r3,r3,16
   26070:	19000037 	ldwio	r4,0(r3)
   26074:	00fff7c4 	movi	r3,-33
   26078:	20c6703a 	and	r3,r4,r3
   2607c:	10c00035 	stwio	r3,0(r2)
    (IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) &
     ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK) );

  /* Get & clear status register contents */
  status = IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base);
   26080:	e0bffe17 	ldw	r2,-8(fp)
   26084:	10800317 	ldw	r2,12(r2)
   26088:	10800037 	ldwio	r2,0(r2)
   2608c:	e0bffd05 	stb	r2,-12(fp)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
   26090:	e0bffe17 	ldw	r2,-8(fp)
   26094:	10800317 	ldw	r2,12(r2)
   26098:	00c03fc4 	movi	r3,255
   2609c:	10c00035 	stwio	r3,0(r2)

  return status;
   260a0:	e0bffd03 	ldbu	r2,-12(fp)
}
   260a4:	e037883a 	mov	sp,fp
   260a8:	df000017 	ldw	fp,0(sp)
   260ac:	dec00104 	addi	sp,sp,4
   260b0:	f800283a 	ret

000260b4 <alt_avalon_sgdma_construct_mem_to_mem_desc>:
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
   260b4:	defff404 	addi	sp,sp,-48
   260b8:	dfc00b15 	stw	ra,44(sp)
   260bc:	df000a15 	stw	fp,40(sp)
   260c0:	df000a04 	addi	fp,sp,40
   260c4:	e13ffb15 	stw	r4,-20(fp)
   260c8:	e17ffc15 	stw	r5,-16(fp)
   260cc:	e1bffd15 	stw	r6,-12(fp)
   260d0:	e1fffe15 	stw	r7,-8(fp)
   260d4:	e0800217 	ldw	r2,8(fp)
   260d8:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
   260dc:	e0bfff0b 	ldhu	r2,-4(fp)
   260e0:	d8800015 	stw	r2,0(sp)
   260e4:	e0800317 	ldw	r2,12(fp)
   260e8:	d8800115 	stw	r2,4(sp)
   260ec:	e0800417 	ldw	r2,16(fp)
   260f0:	d8800215 	stw	r2,8(sp)
   260f4:	d8000315 	stw	zero,12(sp)
   260f8:	d8000415 	stw	zero,16(sp)
   260fc:	e13ffb17 	ldw	r4,-20(fp)
   26100:	e17ffc17 	ldw	r5,-16(fp)
   26104:	e1bffd17 	ldw	r6,-12(fp)
   26108:	e1fffe17 	ldw	r7,-8(fp)
   2610c:	00261240 	call	26124 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>
    write_addr, length, read_fixed, write_fixed, 0, 0);
}
   26110:	e037883a 	mov	sp,fp
   26114:	dfc00117 	ldw	ra,4(sp)
   26118:	df000017 	ldw	fp,0(sp)
   2611c:	dec00204 	addi	sp,sp,8
   26120:	f800283a 	ret

00026124 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>:
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
   26124:	defff204 	addi	sp,sp,-56
   26128:	dfc00d15 	stw	ra,52(sp)
   2612c:	df000c15 	stw	fp,48(sp)
   26130:	df000c04 	addi	fp,sp,48
   26134:	e13ffb15 	stw	r4,-20(fp)
   26138:	e17ffc15 	stw	r5,-16(fp)
   2613c:	e1bffd15 	stw	r6,-12(fp)
   26140:	e1fffe15 	stw	r7,-8(fp)
   26144:	e0800217 	ldw	r2,8(fp)
   26148:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
   2614c:	e0bfff0b 	ldhu	r2,-4(fp)
   26150:	d8800015 	stw	r2,0(sp)
   26154:	d8000115 	stw	zero,4(sp)
   26158:	e0800317 	ldw	r2,12(fp)
   2615c:	d8800215 	stw	r2,8(sp)
   26160:	e0800417 	ldw	r2,16(fp)
   26164:	d8800315 	stw	r2,12(sp)
   26168:	e0800517 	ldw	r2,20(fp)
   2616c:	d8800415 	stw	r2,16(sp)
   26170:	e0800617 	ldw	r2,24(fp)
   26174:	d8800515 	stw	r2,20(sp)
   26178:	d8000615 	stw	zero,24(sp)
   2617c:	e13ffb17 	ldw	r4,-20(fp)
   26180:	e17ffc17 	ldw	r5,-16(fp)
   26184:	e1bffd17 	ldw	r6,-12(fp)
   26188:	e1fffe17 	ldw	r7,-8(fp)
   2618c:	00266900 	call	26690 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    write_fixed,
    read_burst,
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in mem-to-mem mode
}
   26190:	e037883a 	mov	sp,fp
   26194:	dfc00117 	ldw	ra,4(sp)
   26198:	df000017 	ldw	fp,0(sp)
   2619c:	dec00204 	addi	sp,sp,8
   261a0:	f800283a 	ret

000261a4 <alt_avalon_sgdma_construct_stream_to_mem_desc>:
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
   261a4:	defff804 	addi	sp,sp,-32
   261a8:	dfc00715 	stw	ra,28(sp)
   261ac:	df000615 	stw	fp,24(sp)
   261b0:	df000604 	addi	fp,sp,24
   261b4:	e13ffc15 	stw	r4,-16(fp)
   261b8:	e17ffd15 	stw	r5,-12(fp)
   261bc:	e1bffe15 	stw	r6,-8(fp)
   261c0:	3805883a 	mov	r2,r7
   261c4:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
   261c8:	e0bfff0b 	ldhu	r2,-4(fp)
   261cc:	e0c00217 	ldw	r3,8(fp)
   261d0:	d8c00015 	stw	r3,0(sp)
   261d4:	d8000115 	stw	zero,4(sp)
   261d8:	e13ffc17 	ldw	r4,-16(fp)
   261dc:	e17ffd17 	ldw	r5,-12(fp)
   261e0:	e1bffe17 	ldw	r6,-8(fp)
   261e4:	100f883a 	mov	r7,r2
   261e8:	00262000 	call	26200 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>
    length_or_eop, write_fixed, 0);
}
   261ec:	e037883a 	mov	sp,fp
   261f0:	dfc00117 	ldw	ra,4(sp)
   261f4:	df000017 	ldw	fp,0(sp)
   261f8:	dec00204 	addi	sp,sp,8
   261fc:	f800283a 	ret

00026200 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>:
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
   26200:	defff304 	addi	sp,sp,-52
   26204:	dfc00c15 	stw	ra,48(sp)
   26208:	df000b15 	stw	fp,44(sp)
   2620c:	df000b04 	addi	fp,sp,44
   26210:	e13ffc15 	stw	r4,-16(fp)
   26214:	e17ffd15 	stw	r5,-12(fp)
   26218:	e1bffe15 	stw	r6,-8(fp)
   2621c:	3805883a 	mov	r2,r7
   26220:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
   26224:	e0bfff0b 	ldhu	r2,-4(fp)
   26228:	d8800015 	stw	r2,0(sp)
   2622c:	d8000115 	stw	zero,4(sp)
   26230:	d8000215 	stw	zero,8(sp)
   26234:	e0800217 	ldw	r2,8(fp)
   26238:	d8800315 	stw	r2,12(sp)
   2623c:	d8000415 	stw	zero,16(sp)
   26240:	e0800317 	ldw	r2,12(fp)
   26244:	d8800515 	stw	r2,20(sp)
   26248:	d8000615 	stw	zero,24(sp)
   2624c:	e13ffc17 	ldw	r4,-16(fp)
   26250:	e17ffd17 	ldw	r5,-12(fp)
   26254:	000d883a 	mov	r6,zero
   26258:	e1fffe17 	ldw	r7,-8(fp)
   2625c:	00266900 	call	26690 <alt_avalon_sgdma_construct_descriptor_burst>
    0x0,            // Read fixed: N/A in stream-to-mem mode
    write_fixed,
    0,              // Read_burst : N/A in stream-to-mem mode
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in stream-to-mem mode
}
   26260:	e037883a 	mov	sp,fp
   26264:	dfc00117 	ldw	ra,4(sp)
   26268:	df000017 	ldw	fp,0(sp)
   2626c:	dec00204 	addi	sp,sp,8
   26270:	f800283a 	ret

00026274 <alt_avalon_sgdma_construct_mem_to_stream_desc>:
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
   26274:	defff404 	addi	sp,sp,-48
   26278:	dfc00b15 	stw	ra,44(sp)
   2627c:	df000a15 	stw	fp,40(sp)
   26280:	df000a04 	addi	fp,sp,40
   26284:	e13ffb15 	stw	r4,-20(fp)
   26288:	e17ffc15 	stw	r5,-16(fp)
   2628c:	e1bffd15 	stw	r6,-12(fp)
   26290:	3805883a 	mov	r2,r7
   26294:	e0c00517 	ldw	r3,20(fp)
   26298:	e0bffe0d 	sth	r2,-8(fp)
   2629c:	e0ffff05 	stb	r3,-4(fp)
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
   262a0:	e0bffe0b 	ldhu	r2,-8(fp)
   262a4:	e0ffff03 	ldbu	r3,-4(fp)
   262a8:	e1000217 	ldw	r4,8(fp)
   262ac:	d9000015 	stw	r4,0(sp)
   262b0:	e1000317 	ldw	r4,12(fp)
   262b4:	d9000115 	stw	r4,4(sp)
   262b8:	e1000417 	ldw	r4,16(fp)
   262bc:	d9000215 	stw	r4,8(sp)
   262c0:	d8000315 	stw	zero,12(sp)
   262c4:	d8c00415 	stw	r3,16(sp)
   262c8:	e13ffb17 	ldw	r4,-20(fp)
   262cc:	e17ffc17 	ldw	r5,-16(fp)
   262d0:	e1bffd17 	ldw	r6,-12(fp)
   262d4:	100f883a 	mov	r7,r2
   262d8:	00262f00 	call	262f0 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>
    length, read_fixed, generate_sop, generate_eop, 0, atlantic_channel);

}
   262dc:	e037883a 	mov	sp,fp
   262e0:	dfc00117 	ldw	ra,4(sp)
   262e4:	df000017 	ldw	fp,0(sp)
   262e8:	dec00204 	addi	sp,sp,8
   262ec:	f800283a 	ret

000262f0 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>:
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
   262f0:	defff204 	addi	sp,sp,-56
   262f4:	dfc00d15 	stw	ra,52(sp)
   262f8:	df000c15 	stw	fp,48(sp)
   262fc:	df000c04 	addi	fp,sp,48
   26300:	e13ffb15 	stw	r4,-20(fp)
   26304:	e17ffc15 	stw	r5,-16(fp)
   26308:	e1bffd15 	stw	r6,-12(fp)
   2630c:	3805883a 	mov	r2,r7
   26310:	e0c00617 	ldw	r3,24(fp)
   26314:	e0bffe0d 	sth	r2,-8(fp)
   26318:	e0ffff05 	stb	r3,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
   2631c:	e0fffe0b 	ldhu	r3,-8(fp)
   26320:	e0bfff03 	ldbu	r2,-4(fp)
   26324:	d8c00015 	stw	r3,0(sp)
   26328:	e0c00417 	ldw	r3,16(fp)
   2632c:	d8c00115 	stw	r3,4(sp)
   26330:	e0c00217 	ldw	r3,8(fp)
   26334:	d8c00215 	stw	r3,8(sp)
   26338:	e0c00317 	ldw	r3,12(fp)
   2633c:	d8c00315 	stw	r3,12(sp)
   26340:	e0c00517 	ldw	r3,20(fp)
   26344:	d8c00415 	stw	r3,16(sp)
   26348:	d8000515 	stw	zero,20(sp)
   2634c:	d8800615 	stw	r2,24(sp)
   26350:	e13ffb17 	ldw	r4,-20(fp)
   26354:	e17ffc17 	ldw	r5,-16(fp)
   26358:	e1bffd17 	ldw	r6,-12(fp)
   2635c:	000f883a 	mov	r7,zero
   26360:	00266900 	call	26690 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    generate_sop,
    read_burst,
    0,                 // Write_burst : N/A in mem-to-stream mode
    atlantic_channel);
}
   26364:	e037883a 	mov	sp,fp
   26368:	dfc00117 	ldw	ra,4(sp)
   2636c:	df000017 	ldw	fp,0(sp)
   26370:	dec00204 	addi	sp,sp,8
   26374:	f800283a 	ret

00026378 <alt_avalon_sgdma_register_callback>:
void alt_avalon_sgdma_register_callback(
  alt_sgdma_dev *dev,
  alt_avalon_sgdma_callback callback,
  alt_u32 chain_control,
  void *context)
{
   26378:	defffb04 	addi	sp,sp,-20
   2637c:	df000415 	stw	fp,16(sp)
   26380:	df000404 	addi	fp,sp,16
   26384:	e13ffc15 	stw	r4,-16(fp)
   26388:	e17ffd15 	stw	r5,-12(fp)
   2638c:	e1bffe15 	stw	r6,-8(fp)
   26390:	e1ffff15 	stw	r7,-4(fp)
  dev->callback         = callback;
   26394:	e0bffc17 	ldw	r2,-16(fp)
   26398:	e0fffd17 	ldw	r3,-12(fp)
   2639c:	10c00915 	stw	r3,36(r2)
  dev->callback_context = context;
   263a0:	e0bffc17 	ldw	r2,-16(fp)
   263a4:	e0ffff17 	ldw	r3,-4(fp)
   263a8:	10c00a15 	stw	r3,40(r2)
  dev->chain_control    = chain_control;
   263ac:	e0bffc17 	ldw	r2,-16(fp)
   263b0:	e0fffe17 	ldw	r3,-8(fp)
   263b4:	10c00b15 	stw	r3,44(r2)
}
   263b8:	e037883a 	mov	sp,fp
   263bc:	df000017 	ldw	fp,0(sp)
   263c0:	dec00104 	addi	sp,sp,4
   263c4:	f800283a 	ret

000263c8 <alt_avalon_sgdma_start>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct.
 */
void alt_avalon_sgdma_start(alt_sgdma_dev *dev)
{
   263c8:	defffd04 	addi	sp,sp,-12
   263cc:	df000215 	stw	fp,8(sp)
   263d0:	df000204 	addi	fp,sp,8
   263d4:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   263d8:	e0bfff17 	ldw	r2,-4(fp)
   263dc:	10800317 	ldw	r2,12(r2)
   263e0:	10800404 	addi	r2,r2,16
   263e4:	10800037 	ldwio	r2,0(r2)
   263e8:	e0bffe15 	stw	r2,-8(fp)
  control |= ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
   263ec:	e0bffe17 	ldw	r2,-8(fp)
   263f0:	10800814 	ori	r2,r2,32
   263f4:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   263f8:	e0bfff17 	ldw	r2,-4(fp)
   263fc:	10800317 	ldw	r2,12(r2)
   26400:	10800404 	addi	r2,r2,16
   26404:	e0fffe17 	ldw	r3,-8(fp)
   26408:	10c00035 	stwio	r3,0(r2)
}
   2640c:	e037883a 	mov	sp,fp
   26410:	df000017 	ldw	fp,0(sp)
   26414:	dec00104 	addi	sp,sp,4
   26418:	f800283a 	ret

0002641c <alt_avalon_sgdma_stop>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct
 */
void alt_avalon_sgdma_stop(alt_sgdma_dev *dev)
{
   2641c:	defffd04 	addi	sp,sp,-12
   26420:	df000215 	stw	fp,8(sp)
   26424:	df000204 	addi	fp,sp,8
   26428:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   2642c:	e0bfff17 	ldw	r2,-4(fp)
   26430:	10800317 	ldw	r2,12(r2)
   26434:	10800404 	addi	r2,r2,16
   26438:	10800037 	ldwio	r2,0(r2)
   2643c:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
   26440:	e0fffe17 	ldw	r3,-8(fp)
   26444:	00bff7c4 	movi	r2,-33
   26448:	1884703a 	and	r2,r3,r2
   2644c:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   26450:	e0bfff17 	ldw	r2,-4(fp)
   26454:	10800317 	ldw	r2,12(r2)
   26458:	10800404 	addi	r2,r2,16
   2645c:	e0fffe17 	ldw	r3,-8(fp)
   26460:	10c00035 	stwio	r3,0(r2)
}
   26464:	e037883a 	mov	sp,fp
   26468:	df000017 	ldw	fp,0(sp)
   2646c:	dec00104 	addi	sp,sp,4
   26470:	f800283a 	ret

00026474 <alt_avalon_sgdma_check_descriptor_status>:
 * - 0 if the descriptor is error-free, not "owned by hardware", or
 *   a previously requested transfer has appeared to have completed
 *   normally. Or, various error conditions defined in <errno.h>
 */
int alt_avalon_sgdma_check_descriptor_status(alt_sgdma_descriptor *desc)
{
   26474:	defffe04 	addi	sp,sp,-8
   26478:	df000115 	stw	fp,4(sp)
   2647c:	df000104 	addi	fp,sp,4
   26480:	e13fff15 	stw	r4,-4(fp)
  /* Errors take precedence */
  if( IORD_8DIRECT(&desc->status, 0) &
   26484:	e0bfff17 	ldw	r2,-4(fp)
   26488:	10800784 	addi	r2,r2,30
   2648c:	10800023 	ldbuio	r2,0(r2)
   26490:	10803fcc 	andi	r2,r2,255
   26494:	10801fcc 	andi	r2,r2,127
   26498:	10000226 	beq	r2,zero,264a4 <alt_avalon_sgdma_check_descriptor_status+0x30>
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
   2649c:	00bffec4 	movi	r2,-5
   264a0:	00000906 	br	264c8 <alt_avalon_sgdma_check_descriptor_status+0x54>
  }

  if( IORD_8DIRECT(&desc->control, 0) &
   264a4:	e0bfff17 	ldw	r2,-4(fp)
   264a8:	108007c4 	addi	r2,r2,31
   264ac:	10800023 	ldbuio	r2,0(r2)
   264b0:	10803fcc 	andi	r2,r2,255
   264b4:	1080200c 	andi	r2,r2,128
   264b8:	10000226 	beq	r2,zero,264c4 <alt_avalon_sgdma_check_descriptor_status+0x50>
      ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK) {
    return -EINPROGRESS;
   264bc:	00bfe244 	movi	r2,-119
   264c0:	00000106 	br	264c8 <alt_avalon_sgdma_check_descriptor_status+0x54>
  }

    return 0;
   264c4:	0005883a 	mov	r2,zero
}
   264c8:	e037883a 	mov	sp,fp
   264cc:	df000017 	ldw	fp,0(sp)
   264d0:	dec00104 	addi	sp,sp,4
   264d4:	f800283a 	ret

000264d8 <alt_avalon_sgdma_open>:
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
   264d8:	defffc04 	addi	sp,sp,-16
   264dc:	dfc00315 	stw	ra,12(sp)
   264e0:	df000215 	stw	fp,8(sp)
   264e4:	df000204 	addi	fp,sp,8
   264e8:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
   264ec:	e13fff17 	ldw	r4,-4(fp)
   264f0:	d1601b04 	addi	r5,gp,-32660
   264f4:	002cedc0 	call	2cedc <alt_find_dev>
   264f8:	e0bffe15 	stw	r2,-8(fp)

  if (NULL == dev) {
   264fc:	e0bffe17 	ldw	r2,-8(fp)
   26500:	1000031e 	bne	r2,zero,26510 <alt_avalon_sgdma_open+0x38>
    ALT_ERRNO = ENODEV;
   26504:	0025e300 	call	25e30 <alt_get_errno>
   26508:	00c004c4 	movi	r3,19
   2650c:	10c00015 	stw	r3,0(r2)
  }

  return dev;
   26510:	e0bffe17 	ldw	r2,-8(fp)
}
   26514:	e037883a 	mov	sp,fp
   26518:	dfc00117 	ldw	ra,4(sp)
   2651c:	df000017 	ldw	fp,0(sp)
   26520:	dec00204 	addi	sp,sp,8
   26524:	f800283a 	ret

00026528 <alt_avalon_sgdma_construct_descriptor>:
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
   26528:	defff104 	addi	sp,sp,-60
   2652c:	dfc00e15 	stw	ra,56(sp)
   26530:	df000d15 	stw	fp,52(sp)
   26534:	df000d04 	addi	fp,sp,52
   26538:	e13ffa15 	stw	r4,-24(fp)
   2653c:	e17ffb15 	stw	r5,-20(fp)
   26540:	e1bffc15 	stw	r6,-16(fp)
   26544:	e1fffd15 	stw	r7,-12(fp)
   26548:	e0c00217 	ldw	r3,8(fp)
   2654c:	e0800617 	ldw	r2,24(fp)
   26550:	e0fffe0d 	sth	r3,-8(fp)
   26554:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
   26558:	e0fffe0b 	ldhu	r3,-8(fp)
   2655c:	e0bfff03 	ldbu	r2,-4(fp)
   26560:	d8c00015 	stw	r3,0(sp)
   26564:	e0c00317 	ldw	r3,12(fp)
   26568:	d8c00115 	stw	r3,4(sp)
   2656c:	e0c00417 	ldw	r3,16(fp)
   26570:	d8c00215 	stw	r3,8(sp)
   26574:	e0c00517 	ldw	r3,20(fp)
   26578:	d8c00315 	stw	r3,12(sp)
   2657c:	d8000415 	stw	zero,16(sp)
   26580:	d8000515 	stw	zero,20(sp)
   26584:	d8800615 	stw	r2,24(sp)
   26588:	e13ffa17 	ldw	r4,-24(fp)
   2658c:	e17ffb17 	ldw	r5,-20(fp)
   26590:	e1bffc17 	ldw	r6,-16(fp)
   26594:	e1fffd17 	ldw	r7,-12(fp)
   26598:	00266900 	call	26690 <alt_avalon_sgdma_construct_descriptor_burst>
    write_addr, length_or_eop, generate_eop, read_fixed, write_fixed_or_sop, 
    0, 0, atlantic_channel);
}
   2659c:	e037883a 	mov	sp,fp
   265a0:	dfc00117 	ldw	ra,4(sp)
   265a4:	df000017 	ldw	fp,0(sp)
   265a8:	dec00204 	addi	sp,sp,8
   265ac:	f800283a 	ret

000265b0 <alt_avalon_sgdma_enable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_enable_desc_poll(alt_sgdma_dev *dev, alt_u32 frequency)
{
   265b0:	defffc04 	addi	sp,sp,-16
   265b4:	df000315 	stw	fp,12(sp)
   265b8:	df000304 	addi	fp,sp,12
   265bc:	e13ffe15 	stw	r4,-8(fp)
   265c0:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   265c4:	e0bffe17 	ldw	r2,-8(fp)
   265c8:	10800317 	ldw	r2,12(r2)
   265cc:	10800404 	addi	r2,r2,16
   265d0:	10800037 	ldwio	r2,0(r2)
   265d4:	e0bffd15 	stw	r2,-12(fp)
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
   265d8:	e0fffd17 	ldw	r3,-12(fp)
   265dc:	00a00434 	movhi	r2,32784
   265e0:	10bfffc4 	addi	r2,r2,-1
   265e4:	1884703a 	and	r2,r3,r2
   265e8:	e0bffd15 	stw	r2,-12(fp)
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
   265ec:	e0bfff17 	ldw	r2,-4(fp)
   265f0:	1004953a 	slli	r2,r2,20
   265f4:	10dffc2c 	andhi	r3,r2,32752

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
   265f8:	e0bffd17 	ldw	r2,-12(fp)
   265fc:	1884b03a 	or	r2,r3,r2
   26600:	10800134 	orhi	r2,r2,4
   26604:	e0bffd15 	stw	r2,-12(fp)
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   26608:	e0bffe17 	ldw	r2,-8(fp)
   2660c:	10800317 	ldw	r2,12(r2)
   26610:	10800404 	addi	r2,r2,16
   26614:	e0fffd17 	ldw	r3,-12(fp)
   26618:	10c00035 	stwio	r3,0(r2)
  
  return;
   2661c:	0001883a 	nop
}
   26620:	e037883a 	mov	sp,fp
   26624:	df000017 	ldw	fp,0(sp)
   26628:	dec00104 	addi	sp,sp,4
   2662c:	f800283a 	ret

00026630 <alt_avalon_sgdma_disable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_disable_desc_poll(alt_sgdma_dev *dev)
{
   26630:	defffd04 	addi	sp,sp,-12
   26634:	df000215 	stw	fp,8(sp)
   26638:	df000204 	addi	fp,sp,8
   2663c:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   26640:	e0bfff17 	ldw	r2,-4(fp)
   26644:	10800317 	ldw	r2,12(r2)
   26648:	10800404 	addi	r2,r2,16
   2664c:	10800037 	ldwio	r2,0(r2)
   26650:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK;
   26654:	e0fffe17 	ldw	r3,-8(fp)
   26658:	00bfff34 	movhi	r2,65532
   2665c:	10bfffc4 	addi	r2,r2,-1
   26660:	1884703a 	and	r2,r3,r2
   26664:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   26668:	e0bfff17 	ldw	r2,-4(fp)
   2666c:	10800317 	ldw	r2,12(r2)
   26670:	10800404 	addi	r2,r2,16
   26674:	e0fffe17 	ldw	r3,-8(fp)
   26678:	10c00035 	stwio	r3,0(r2)
  
  return;
   2667c:	0001883a 	nop
}
   26680:	e037883a 	mov	sp,fp
   26684:	df000017 	ldw	fp,0(sp)
   26688:	dec00104 	addi	sp,sp,4
   2668c:	f800283a 	ret

00026690 <alt_avalon_sgdma_construct_descriptor_burst>:
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
   26690:	defff804 	addi	sp,sp,-32
   26694:	dfc00715 	stw	ra,28(sp)
   26698:	df000615 	stw	fp,24(sp)
   2669c:	df000604 	addi	fp,sp,24
   266a0:	e13ffa15 	stw	r4,-24(fp)
   266a4:	e17ffb15 	stw	r5,-20(fp)
   266a8:	e1bffc15 	stw	r6,-16(fp)
   266ac:	e1fffd15 	stw	r7,-12(fp)
   266b0:	e0c00217 	ldw	r3,8(fp)
   266b4:	e0800817 	ldw	r2,32(fp)
   266b8:	e0fffe0d 	sth	r3,-8(fp)
   266bc:	e0bfff05 	stb	r2,-4(fp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
   266c0:	e0bffb17 	ldw	r2,-20(fp)
   266c4:	108007c4 	addi	r2,r2,31
   266c8:	e0fffb17 	ldw	r3,-20(fp)
   266cc:	18c007c3 	ldbu	r3,31(r3)
   266d0:	19003fcc 	andi	r4,r3,255
   266d4:	00ffdfc4 	movi	r3,-129
   266d8:	20c6703a 	and	r3,r4,r3
   266dc:	10c00025 	stbio	r3,0(r2)
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
   266e0:	e0bffa17 	ldw	r2,-24(fp)
   266e4:	e0fffc17 	ldw	r3,-16(fp)
   266e8:	18c03fcc 	andi	r3,r3,255
   266ec:	11000003 	ldbu	r4,0(r2)
   266f0:	2008703a 	and	r4,r4,zero
   266f4:	20c6b03a 	or	r3,r4,r3
   266f8:	10c00005 	stb	r3,0(r2)
   266fc:	e0fffc17 	ldw	r3,-16(fp)
   26700:	1806d23a 	srli	r3,r3,8
   26704:	18c03fcc 	andi	r3,r3,255
   26708:	11000043 	ldbu	r4,1(r2)
   2670c:	2008703a 	and	r4,r4,zero
   26710:	20c6b03a 	or	r3,r4,r3
   26714:	10c00045 	stb	r3,1(r2)
   26718:	e0fffc17 	ldw	r3,-16(fp)
   2671c:	1806d43a 	srli	r3,r3,16
   26720:	18c03fcc 	andi	r3,r3,255
   26724:	11000083 	ldbu	r4,2(r2)
   26728:	2008703a 	and	r4,r4,zero
   2672c:	20c6b03a 	or	r3,r4,r3
   26730:	10c00085 	stb	r3,2(r2)
   26734:	e0fffc17 	ldw	r3,-16(fp)
   26738:	1806d63a 	srli	r3,r3,24
   2673c:	110000c3 	ldbu	r4,3(r2)
   26740:	2008703a 	and	r4,r4,zero
   26744:	20c6b03a 	or	r3,r4,r3
   26748:	10c000c5 	stb	r3,3(r2)
  desc->write_addr               = write_addr;
   2674c:	e0bffa17 	ldw	r2,-24(fp)
   26750:	e0fffd17 	ldw	r3,-12(fp)
   26754:	18c03fcc 	andi	r3,r3,255
   26758:	11000203 	ldbu	r4,8(r2)
   2675c:	2008703a 	and	r4,r4,zero
   26760:	20c6b03a 	or	r3,r4,r3
   26764:	10c00205 	stb	r3,8(r2)
   26768:	e0fffd17 	ldw	r3,-12(fp)
   2676c:	1806d23a 	srli	r3,r3,8
   26770:	18c03fcc 	andi	r3,r3,255
   26774:	11000243 	ldbu	r4,9(r2)
   26778:	2008703a 	and	r4,r4,zero
   2677c:	20c6b03a 	or	r3,r4,r3
   26780:	10c00245 	stb	r3,9(r2)
   26784:	e0fffd17 	ldw	r3,-12(fp)
   26788:	1806d43a 	srli	r3,r3,16
   2678c:	18c03fcc 	andi	r3,r3,255
   26790:	11000283 	ldbu	r4,10(r2)
   26794:	2008703a 	and	r4,r4,zero
   26798:	20c6b03a 	or	r3,r4,r3
   2679c:	10c00285 	stb	r3,10(r2)
   267a0:	e0fffd17 	ldw	r3,-12(fp)
   267a4:	1806d63a 	srli	r3,r3,24
   267a8:	110002c3 	ldbu	r4,11(r2)
   267ac:	2008703a 	and	r4,r4,zero
   267b0:	20c6b03a 	or	r3,r4,r3
   267b4:	10c002c5 	stb	r3,11(r2)
  desc->next                     = (alt_u32 *) next;
   267b8:	e0bffa17 	ldw	r2,-24(fp)
   267bc:	e0fffb17 	ldw	r3,-20(fp)
   267c0:	18c03fcc 	andi	r3,r3,255
   267c4:	11000403 	ldbu	r4,16(r2)
   267c8:	2008703a 	and	r4,r4,zero
   267cc:	20c6b03a 	or	r3,r4,r3
   267d0:	10c00405 	stb	r3,16(r2)
   267d4:	e0fffb17 	ldw	r3,-20(fp)
   267d8:	1806d23a 	srli	r3,r3,8
   267dc:	18c03fcc 	andi	r3,r3,255
   267e0:	11000443 	ldbu	r4,17(r2)
   267e4:	2008703a 	and	r4,r4,zero
   267e8:	20c6b03a 	or	r3,r4,r3
   267ec:	10c00445 	stb	r3,17(r2)
   267f0:	e0fffb17 	ldw	r3,-20(fp)
   267f4:	1806d43a 	srli	r3,r3,16
   267f8:	18c03fcc 	andi	r3,r3,255
   267fc:	11000483 	ldbu	r4,18(r2)
   26800:	2008703a 	and	r4,r4,zero
   26804:	20c6b03a 	or	r3,r4,r3
   26808:	10c00485 	stb	r3,18(r2)
   2680c:	e0fffb17 	ldw	r3,-20(fp)
   26810:	1806d63a 	srli	r3,r3,24
   26814:	110004c3 	ldbu	r4,19(r2)
   26818:	2008703a 	and	r4,r4,zero
   2681c:	20c6b03a 	or	r3,r4,r3
   26820:	10c004c5 	stb	r3,19(r2)
  desc->read_addr_pad            = 0x0;
   26824:	e0bffa17 	ldw	r2,-24(fp)
   26828:	10c00103 	ldbu	r3,4(r2)
   2682c:	1806703a 	and	r3,r3,zero
   26830:	10c00105 	stb	r3,4(r2)
   26834:	10c00143 	ldbu	r3,5(r2)
   26838:	1806703a 	and	r3,r3,zero
   2683c:	10c00145 	stb	r3,5(r2)
   26840:	10c00183 	ldbu	r3,6(r2)
   26844:	1806703a 	and	r3,r3,zero
   26848:	10c00185 	stb	r3,6(r2)
   2684c:	10c001c3 	ldbu	r3,7(r2)
   26850:	1806703a 	and	r3,r3,zero
   26854:	10c001c5 	stb	r3,7(r2)
  desc->write_addr_pad           = 0x0;
   26858:	e0bffa17 	ldw	r2,-24(fp)
   2685c:	10c00303 	ldbu	r3,12(r2)
   26860:	1806703a 	and	r3,r3,zero
   26864:	10c00305 	stb	r3,12(r2)
   26868:	10c00343 	ldbu	r3,13(r2)
   2686c:	1806703a 	and	r3,r3,zero
   26870:	10c00345 	stb	r3,13(r2)
   26874:	10c00383 	ldbu	r3,14(r2)
   26878:	1806703a 	and	r3,r3,zero
   2687c:	10c00385 	stb	r3,14(r2)
   26880:	10c003c3 	ldbu	r3,15(r2)
   26884:	1806703a 	and	r3,r3,zero
   26888:	10c003c5 	stb	r3,15(r2)
  desc->next_pad                 = 0x0;
   2688c:	e0bffa17 	ldw	r2,-24(fp)
   26890:	10c00503 	ldbu	r3,20(r2)
   26894:	1806703a 	and	r3,r3,zero
   26898:	10c00505 	stb	r3,20(r2)
   2689c:	10c00543 	ldbu	r3,21(r2)
   268a0:	1806703a 	and	r3,r3,zero
   268a4:	10c00545 	stb	r3,21(r2)
   268a8:	10c00583 	ldbu	r3,22(r2)
   268ac:	1806703a 	and	r3,r3,zero
   268b0:	10c00585 	stb	r3,22(r2)
   268b4:	10c005c3 	ldbu	r3,23(r2)
   268b8:	1806703a 	and	r3,r3,zero
   268bc:	10c005c5 	stb	r3,23(r2)
  desc->bytes_to_transfer        = length_or_eop;
   268c0:	e0bffa17 	ldw	r2,-24(fp)
   268c4:	e0fffe0b 	ldhu	r3,-8(fp)
   268c8:	18c03fcc 	andi	r3,r3,255
   268cc:	11000603 	ldbu	r4,24(r2)
   268d0:	2008703a 	and	r4,r4,zero
   268d4:	20c6b03a 	or	r3,r4,r3
   268d8:	10c00605 	stb	r3,24(r2)
   268dc:	e0fffe0b 	ldhu	r3,-8(fp)
   268e0:	1806d23a 	srli	r3,r3,8
   268e4:	18ffffcc 	andi	r3,r3,65535
   268e8:	11000643 	ldbu	r4,25(r2)
   268ec:	2008703a 	and	r4,r4,zero
   268f0:	20c6b03a 	or	r3,r4,r3
   268f4:	10c00645 	stb	r3,25(r2)
  desc->actual_bytes_transferred = 0;
   268f8:	e0bffa17 	ldw	r2,-24(fp)
   268fc:	10c00703 	ldbu	r3,28(r2)
   26900:	1806703a 	and	r3,r3,zero
   26904:	10c00705 	stb	r3,28(r2)
   26908:	10c00743 	ldbu	r3,29(r2)
   2690c:	1806703a 	and	r3,r3,zero
   26910:	10c00745 	stb	r3,29(r2)
  desc->status                   = 0x0;
   26914:	e0bffa17 	ldw	r2,-24(fp)
   26918:	10000785 	stb	zero,30(r2)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
   2691c:	e0800617 	ldw	r2,24(fp)
   26920:	1007883a 	mov	r3,r2
   26924:	e0bffa17 	ldw	r2,-24(fp)
   26928:	10c00685 	stb	r3,26(r2)
  desc->write_burst              = write_burst;
   2692c:	e0800717 	ldw	r2,28(fp)
   26930:	1007883a 	mov	r3,r2
   26934:	e0bffa17 	ldw	r2,-24(fp)
   26938:	10c006c5 	stb	r3,27(r2)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
   2693c:	e0800317 	ldw	r2,12(fp)
   26940:	10000226 	beq	r2,zero,2694c <alt_avalon_sgdma_construct_descriptor_burst+0x2bc>
   26944:	00ffe044 	movi	r3,-127
   26948:	00000106 	br	26950 <alt_avalon_sgdma_construct_descriptor_burst+0x2c0>
   2694c:	00ffe004 	movi	r3,-128
   26950:	e0800417 	ldw	r2,16(fp)
   26954:	10000226 	beq	r2,zero,26960 <alt_avalon_sgdma_construct_descriptor_burst+0x2d0>
   26958:	00800084 	movi	r2,2
   2695c:	00000106 	br	26964 <alt_avalon_sgdma_construct_descriptor_burst+0x2d4>
   26960:	0005883a 	mov	r2,zero
   26964:	1884b03a 	or	r2,r3,r2
   26968:	1007883a 	mov	r3,r2
   2696c:	e0800517 	ldw	r2,20(fp)
   26970:	10000226 	beq	r2,zero,2697c <alt_avalon_sgdma_construct_descriptor_burst+0x2ec>
   26974:	00800104 	movi	r2,4
   26978:	00000106 	br	26980 <alt_avalon_sgdma_construct_descriptor_burst+0x2f0>
   2697c:	0005883a 	mov	r2,zero
   26980:	1884b03a 	or	r2,r3,r2
   26984:	1007883a 	mov	r3,r2
   26988:	e0bfff03 	ldbu	r2,-4(fp)
   2698c:	10000426 	beq	r2,zero,269a0 <alt_avalon_sgdma_construct_descriptor_burst+0x310>
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_GENERATE_EOP_MSK : 0x0)        |
    (read_fixed ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_READ_FIXED_ADDRESS_MSK : 0x0)  |
    (write_fixed_or_sop ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_WRITE_FIXED_ADDRESS_MSK : 0x0) |
    (atlantic_channel ? ( (atlantic_channel & 0x0F) << 3) : 0)
   26990:	e0bfff03 	ldbu	r2,-4(fp)
   26994:	108003cc 	andi	r2,r2,15
   26998:	100490fa 	slli	r2,r2,3
   2699c:	00000106 	br	269a4 <alt_avalon_sgdma_construct_descriptor_burst+0x314>
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
   269a0:	0005883a 	mov	r2,zero
   269a4:	1884b03a 	or	r2,r3,r2
   269a8:	1007883a 	mov	r3,r2
   269ac:	e0bffa17 	ldw	r2,-24(fp)
   269b0:	10c007c5 	stb	r3,31(r2)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to
   */
  alt_remap_uncached(desc, sizeof(alt_sgdma_descriptor));
   269b4:	e13ffa17 	ldw	r4,-24(fp)
   269b8:	01400804 	movi	r5,32
   269bc:	00221400 	call	22140 <alt_remap_uncached>
}
   269c0:	e037883a 	mov	sp,fp
   269c4:	dfc00117 	ldw	ra,4(sp)
   269c8:	df000017 	ldw	fp,0(sp)
   269cc:	dec00204 	addi	sp,sp,8
   269d0:	f800283a 	ret

000269d4 <alt_avalon_sgdma_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_sgdma_irq(void *context)
#else
static void alt_avalon_sgdma_irq(void *context, alt_u32 id)
#endif
{
   269d4:	defff804 	addi	sp,sp,-32
   269d8:	dfc00715 	stw	ra,28(sp)
   269dc:	df000615 	stw	fp,24(sp)
   269e0:	df000604 	addi	fp,sp,24
   269e4:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev *dev = (alt_sgdma_dev *) context;
   269e8:	e0bfff17 	ldw	r2,-4(fp)
   269ec:	e0bffa15 	stw	r2,-24(fp)
   * Note: This is explicitly done before calling user interrupt-handling
   * code rather than after; if user ISR code initiates another SGDMA
   * transfer which completes quickly, reading the control register after
   * the callback routine may result in a lost interrupt.
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
   269f0:	e0bffa17 	ldw	r2,-24(fp)
   269f4:	10800317 	ldw	r2,12(r2)
   269f8:	10800404 	addi	r2,r2,16
   269fc:	e0fffa17 	ldw	r3,-24(fp)
   26a00:	18c00317 	ldw	r3,12(r3)
   26a04:	18c00404 	addi	r3,r3,16
   26a08:	18c00037 	ldwio	r3,0(r3)
   26a0c:	18e00034 	orhi	r3,r3,32768
   26a10:	10c00035 	stwio	r3,0(r2)
    IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) | 0x80000000);
  
  /* Dummy read to ensure IRQ is negated before the ISR returns */
  IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   26a14:	e0bffa17 	ldw	r2,-24(fp)
   26a18:	10800317 	ldw	r2,12(r2)
   26a1c:	10800404 	addi	r2,r2,16
   26a20:	10800037 	ldwio	r2,0(r2)
   * Other interrupts are explicitly disabled if callbacks
   * are registered because there is no guarantee that they are 
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
   26a24:	e0bffa17 	ldw	r2,-24(fp)
   26a28:	10800917 	ldw	r2,36(r2)
   26a2c:	10001d26 	beq	r2,zero,26aa4 <alt_avalon_sgdma_irq+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   26a30:	0005303a 	rdctl	r2,status
   26a34:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   26a38:	e0fffc17 	ldw	r3,-16(fp)
   26a3c:	00bfff84 	movi	r2,-2
   26a40:	1884703a 	and	r2,r3,r2
   26a44:	1001703a 	wrctl	status,r2
  
  return context;
   26a48:	e0bffc17 	ldw	r2,-16(fp)
    cpu_sr = alt_irq_disable_all();
   26a4c:	e0bffb15 	stw	r2,-20(fp)
    (dev->callback)(dev->callback_context);
   26a50:	e0bffa17 	ldw	r2,-24(fp)
   26a54:	10c00917 	ldw	r3,36(r2)
   26a58:	e0bffa17 	ldw	r2,-24(fp)
   26a5c:	10800a17 	ldw	r2,40(r2)
   26a60:	1009883a 	mov	r4,r2
   26a64:	183ee83a 	callr	r3
   26a68:	e0bffb17 	ldw	r2,-20(fp)
   26a6c:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   26a70:	0005303a 	rdctl	r2,status
   26a74:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   26a78:	e0fffe17 	ldw	r3,-8(fp)
   26a7c:	00bfff84 	movi	r2,-2
   26a80:	1884703a 	and	r2,r3,r2
   26a84:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   26a88:	e0bffd17 	ldw	r2,-12(fp)
   26a8c:	1080004c 	andi	r2,r2,1
   26a90:	e0fffe17 	ldw	r3,-8(fp)
   26a94:	1884b03a 	or	r2,r3,r2
   26a98:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
   26a9c:	e0bffe17 	ldw	r2,-8(fp)
   26aa0:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(cpu_sr);
  }
}
   26aa4:	e037883a 	mov	sp,fp
   26aa8:	dfc00117 	ldw	ra,4(sp)
   26aac:	df000017 	ldw	fp,0(sp)
   26ab0:	dec00204 	addi	sp,sp,8
   26ab4:	f800283a 	ret

00026ab8 <alt_avalon_sgdma_init>:
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
   26ab8:	defffa04 	addi	sp,sp,-24
   26abc:	dfc00515 	stw	ra,20(sp)
   26ac0:	df000415 	stw	fp,16(sp)
   26ac4:	df000404 	addi	fp,sp,16
   26ac8:	e13ffd15 	stw	r4,-12(fp)
   26acc:	e17ffe15 	stw	r5,-8(fp)
   26ad0:	e1bfff15 	stw	r6,-4(fp)

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
   26ad4:	e0bffd17 	ldw	r2,-12(fp)
   26ad8:	10800317 	ldw	r2,12(r2)
   26adc:	10800404 	addi	r2,r2,16
   26ae0:	00c00074 	movhi	r3,1
   26ae4:	10c00035 	stwio	r3,0(r2)
    ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
   26ae8:	e0bffd17 	ldw	r2,-12(fp)
   26aec:	10800317 	ldw	r2,12(r2)
   26af0:	10800404 	addi	r2,r2,16
   26af4:	00c00074 	movhi	r3,1
   26af8:	10c00035 	stwio	r3,0(r2)

  /*
   * Disable interrupts, halt future descriptor processing,
   * and clear status register content
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 0x0);
   26afc:	e0bffd17 	ldw	r2,-12(fp)
   26b00:	10800317 	ldw	r2,12(r2)
   26b04:	10800404 	addi	r2,r2,16
   26b08:	0007883a 	mov	r3,zero
   26b0c:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
   26b10:	e0bffd17 	ldw	r2,-12(fp)
   26b14:	10800317 	ldw	r2,12(r2)
   26b18:	00c03fc4 	movi	r3,255
   26b1c:	10c00035 	stwio	r3,0(r2)

  /* Register this instance of the SGDMA controller with HAL */
  alt_dev_llist_insert((alt_dev_llist*) dev, &alt_sgdma_list);
   26b20:	e13ffd17 	ldw	r4,-12(fp)
   26b24:	d1601b04 	addi	r5,gp,-32660
   26b28:	002cd840 	call	2cd84 <alt_dev_llist_insert>

  /* Install IRQ handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(ic_id, irq, alt_avalon_sgdma_irq, dev, 0x0);
   26b2c:	d8000015 	stw	zero,0(sp)
   26b30:	e13ffe17 	ldw	r4,-8(fp)
   26b34:	e17fff17 	ldw	r5,-4(fp)
   26b38:	018000b4 	movhi	r6,2
   26b3c:	319a7504 	addi	r6,r6,27092
   26b40:	e1fffd17 	ldw	r7,-12(fp)
   26b44:	002ca740 	call	2ca74 <alt_ic_isr_register>
#else
  alt_irq_register(irq, dev, alt_avalon_sgdma_irq);
#endif  
}
   26b48:	e037883a 	mov	sp,fp
   26b4c:	dfc00117 	ldw	ra,4(sp)
   26b50:	df000017 	ldw	fp,0(sp)
   26b54:	dec00204 	addi	sp,sp,8
   26b58:	f800283a 	ret

00026b5c <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
   26b5c:	defff904 	addi	sp,sp,-28
   26b60:	dfc00615 	stw	ra,24(sp)
   26b64:	df000515 	stw	fp,20(sp)
   26b68:	df000504 	addi	fp,sp,20
   26b6c:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
   26b70:	0007883a 	mov	r3,zero
   26b74:	e0bfff17 	ldw	r2,-4(fp)
   26b78:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
   26b7c:	e0bfff17 	ldw	r2,-4(fp)
   26b80:	10800104 	addi	r2,r2,4
   26b84:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   26b88:	0005303a 	rdctl	r2,status
   26b8c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   26b90:	e0fffc17 	ldw	r3,-16(fp)
   26b94:	00bfff84 	movi	r2,-2
   26b98:	1884703a 	and	r2,r3,r2
   26b9c:	1001703a 	wrctl	status,r2
  
  return context;
   26ba0:	e0bffc17 	ldw	r2,-16(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
   26ba4:	e0bffb15 	stw	r2,-20(fp)
  alt_tick ();
   26ba8:	002234c0 	call	2234c <alt_tick>
   26bac:	e0bffb17 	ldw	r2,-20(fp)
   26bb0:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   26bb4:	0005303a 	rdctl	r2,status
   26bb8:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   26bbc:	e0fffe17 	ldw	r3,-8(fp)
   26bc0:	00bfff84 	movi	r2,-2
   26bc4:	1884703a 	and	r2,r3,r2
   26bc8:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   26bcc:	e0bffd17 	ldw	r2,-12(fp)
   26bd0:	1080004c 	andi	r2,r2,1
   26bd4:	e0fffe17 	ldw	r3,-8(fp)
   26bd8:	1884b03a 	or	r2,r3,r2
   26bdc:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
   26be0:	e0bffe17 	ldw	r2,-8(fp)
   26be4:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
   26be8:	e037883a 	mov	sp,fp
   26bec:	dfc00117 	ldw	ra,4(sp)
   26bf0:	df000017 	ldw	fp,0(sp)
   26bf4:	dec00204 	addi	sp,sp,8
   26bf8:	f800283a 	ret

00026bfc <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
   26bfc:	defff804 	addi	sp,sp,-32
   26c00:	dfc00715 	stw	ra,28(sp)
   26c04:	df000615 	stw	fp,24(sp)
   26c08:	df000604 	addi	fp,sp,24
   26c0c:	e13ffc15 	stw	r4,-16(fp)
   26c10:	e17ffd15 	stw	r5,-12(fp)
   26c14:	e1bffe15 	stw	r6,-8(fp)
   26c18:	e1ffff15 	stw	r7,-4(fp)
   26c1c:	e0bfff17 	ldw	r2,-4(fp)
   26c20:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
   26c24:	008000f4 	movhi	r2,3
   26c28:	109e4d04 	addi	r2,r2,31028
   26c2c:	10800017 	ldw	r2,0(r2)
   26c30:	1000041e 	bne	r2,zero,26c44 <alt_avalon_timer_sc_init+0x48>
  {
    _alt_tick_rate = nticks;
   26c34:	008000f4 	movhi	r2,3
   26c38:	109e4d04 	addi	r2,r2,31028
   26c3c:	e0fffb17 	ldw	r3,-20(fp)
   26c40:	10c00015 	stw	r3,0(r2)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
   26c44:	e0bffc17 	ldw	r2,-16(fp)
   26c48:	10800104 	addi	r2,r2,4
   26c4c:	00c001c4 	movi	r3,7
   26c50:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
   26c54:	d8000015 	stw	zero,0(sp)
   26c58:	e13ffd17 	ldw	r4,-12(fp)
   26c5c:	e17ffe17 	ldw	r5,-8(fp)
   26c60:	018000b4 	movhi	r6,2
   26c64:	319ad704 	addi	r6,r6,27484
   26c68:	e1fffc17 	ldw	r7,-16(fp)
   26c6c:	002ca740 	call	2ca74 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
   26c70:	e037883a 	mov	sp,fp
   26c74:	dfc00117 	ldw	ra,4(sp)
   26c78:	df000017 	ldw	fp,0(sp)
   26c7c:	dec00204 	addi	sp,sp,8
   26c80:	f800283a 	ret

00026c84 <alt_timestamp_start>:
 * The return value of this function is 0 upon sucess and -1 if in timestamp
 * device has not been registered. 
 */

int alt_timestamp_start(void)
{
   26c84:	defffe04 	addi	sp,sp,-8
   26c88:	df000115 	stw	fp,4(sp)
   26c8c:	df000104 	addi	fp,sp,4
  void* base = altera_avalon_timer_ts_base;
   26c90:	008000f4 	movhi	r2,3
   26c94:	109e4f04 	addi	r2,r2,31036
   26c98:	10800017 	ldw	r2,0(r2)
   26c9c:	e0bfff15 	stw	r2,-4(fp)

  if (!altera_avalon_timer_ts_freq)
   26ca0:	008000f4 	movhi	r2,3
   26ca4:	109e5004 	addi	r2,r2,31040
   26ca8:	10800017 	ldw	r2,0(r2)
   26cac:	1000021e 	bne	r2,zero,26cb8 <alt_timestamp_start+0x34>
  {
    return -1;
   26cb0:	00bfffc4 	movi	r2,-1
   26cb4:	00001106 	br	26cfc <alt_timestamp_start+0x78>
        IOWR_ALTERA_AVALON_TIMER_PERIOD_1 (base, 0xFFFF);;
        IOWR_ALTERA_AVALON_TIMER_PERIOD_2 (base, 0xFFFF);
        IOWR_ALTERA_AVALON_TIMER_PERIOD_3 (base, 0xFFFF);
        IOWR_ALTERA_AVALON_TIMER_CONTROL (base, ALTERA_AVALON_TIMER_CONTROL_START_MSK);
    } else {
        IOWR_ALTERA_AVALON_TIMER_CONTROL (base,ALTERA_AVALON_TIMER_CONTROL_STOP_MSK);
   26cb8:	e0bfff17 	ldw	r2,-4(fp)
   26cbc:	10800104 	addi	r2,r2,4
   26cc0:	00c00204 	movi	r3,8
   26cc4:	10c00035 	stwio	r3,0(r2)
        IOWR_ALTERA_AVALON_TIMER_PERIODL (base, 0xFFFF);
   26cc8:	e0bfff17 	ldw	r2,-4(fp)
   26ccc:	10800204 	addi	r2,r2,8
   26cd0:	00ffffd4 	movui	r3,65535
   26cd4:	10c00035 	stwio	r3,0(r2)
        IOWR_ALTERA_AVALON_TIMER_PERIODH (base, 0xFFFF);
   26cd8:	e0bfff17 	ldw	r2,-4(fp)
   26cdc:	10800304 	addi	r2,r2,12
   26ce0:	00ffffd4 	movui	r3,65535
   26ce4:	10c00035 	stwio	r3,0(r2)
        IOWR_ALTERA_AVALON_TIMER_CONTROL (base, ALTERA_AVALON_TIMER_CONTROL_START_MSK); 
   26ce8:	e0bfff17 	ldw	r2,-4(fp)
   26cec:	10800104 	addi	r2,r2,4
   26cf0:	00c00104 	movi	r3,4
   26cf4:	10c00035 	stwio	r3,0(r2)
    } 
  }
  return 0;
   26cf8:	0005883a 	mov	r2,zero
}
   26cfc:	e037883a 	mov	sp,fp
   26d00:	df000017 	ldw	fp,0(sp)
   26d04:	dec00104 	addi	sp,sp,4
   26d08:	f800283a 	ret

00026d0c <alt_timestamp>:
 * The returned timestamp counts up from the last time the period register
 * was reset. 
 */

alt_timestamp_type alt_timestamp(void)
{
   26d0c:	defffc04 	addi	sp,sp,-16
   26d10:	df000315 	stw	fp,12(sp)
   26d14:	df000304 	addi	fp,sp,12

  void* base = altera_avalon_timer_ts_base;
   26d18:	008000f4 	movhi	r2,3
   26d1c:	109e4f04 	addi	r2,r2,31036
   26d20:	10800017 	ldw	r2,0(r2)
   26d24:	e0bffd15 	stw	r2,-12(fp)

  if (!altera_avalon_timer_ts_freq)
   26d28:	008000f4 	movhi	r2,3
   26d2c:	109e5004 	addi	r2,r2,31040
   26d30:	10800017 	ldw	r2,0(r2)
   26d34:	1000021e 	bne	r2,zero,26d40 <alt_timestamp+0x34>
  {
	if(ALT_TIMESTAMP_COUNTER_SIZE == 64) {
        return 0xFFFFFFFFFFFFFFFFULL;
    } else {
        return 0xFFFFFFFF;
   26d38:	00bfffc4 	movi	r2,-1
   26d3c:	00001306 	br	26d8c <alt_timestamp+0x80>
        alt_timestamp_type snap_2 = IORD_ALTERA_AVALON_TIMER_SNAP_2(base) & ALTERA_AVALON_TIMER_SNAP_2_MSK;
        alt_timestamp_type snap_3 = IORD_ALTERA_AVALON_TIMER_SNAP_3(base) & ALTERA_AVALON_TIMER_SNAP_3_MSK;
        
        return (0xFFFFFFFFFFFFFFFFULL - ( (snap_3 << 48) | (snap_2 << 32) | (snap_1 << 16) | (snap_0) ));
    } else {
        IOWR_ALTERA_AVALON_TIMER_SNAPL (base, 0);
   26d40:	e0bffd17 	ldw	r2,-12(fp)
   26d44:	10800404 	addi	r2,r2,16
   26d48:	0007883a 	mov	r3,zero
   26d4c:	10c00035 	stwio	r3,0(r2)
        alt_timestamp_type lower = IORD_ALTERA_AVALON_TIMER_SNAPL(base) & ALTERA_AVALON_TIMER_SNAPL_MSK;
   26d50:	e0bffd17 	ldw	r2,-12(fp)
   26d54:	10800404 	addi	r2,r2,16
   26d58:	10800037 	ldwio	r2,0(r2)
   26d5c:	10bfffcc 	andi	r2,r2,65535
   26d60:	e0bffe15 	stw	r2,-8(fp)
        alt_timestamp_type upper = IORD_ALTERA_AVALON_TIMER_SNAPH(base) & ALTERA_AVALON_TIMER_SNAPH_MSK;
   26d64:	e0bffd17 	ldw	r2,-12(fp)
   26d68:	10800504 	addi	r2,r2,20
   26d6c:	10800037 	ldwio	r2,0(r2)
   26d70:	10bfffcc 	andi	r2,r2,65535
   26d74:	e0bfff15 	stw	r2,-4(fp)
        
        return (0xFFFFFFFF - ((upper << 16) | lower)); 
   26d78:	e0bfff17 	ldw	r2,-4(fp)
   26d7c:	1006943a 	slli	r3,r2,16
   26d80:	e0bffe17 	ldw	r2,-8(fp)
   26d84:	1884b03a 	or	r2,r3,r2
   26d88:	0084303a 	nor	r2,zero,r2
    }  
  }
}
   26d8c:	e037883a 	mov	sp,fp
   26d90:	df000017 	ldw	fp,0(sp)
   26d94:	dec00104 	addi	sp,sp,4
   26d98:	f800283a 	ret

00026d9c <alt_timestamp_freq>:
 * Return the number of timestamp ticks per second. This will be 0 if no
 * timestamp device has been registered.
 */

alt_u32 alt_timestamp_freq(void)
{
   26d9c:	deffff04 	addi	sp,sp,-4
   26da0:	df000015 	stw	fp,0(sp)
   26da4:	d839883a 	mov	fp,sp
  return altera_avalon_timer_ts_freq;
   26da8:	008000f4 	movhi	r2,3
   26dac:	109e5004 	addi	r2,r2,31040
   26db0:	10800017 	ldw	r2,0(r2)
}
   26db4:	e037883a 	mov	sp,fp
   26db8:	df000017 	ldw	fp,0(sp)
   26dbc:	dec00104 	addi	sp,sp,4
   26dc0:	f800283a 	ret

00026dc4 <no_printf>:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void no_printf (char *fmt, ...) {}
   26dc4:	defffb04 	addi	sp,sp,-20
   26dc8:	df000115 	stw	fp,4(sp)
   26dcc:	df000104 	addi	fp,sp,4
   26dd0:	e1400115 	stw	r5,4(fp)
   26dd4:	e1800215 	stw	r6,8(fp)
   26dd8:	e1c00315 	stw	r7,12(fp)
   26ddc:	e13fff15 	stw	r4,-4(fp)
   26de0:	e037883a 	mov	sp,fp
   26de4:	df000017 	ldw	fp,0(sp)
   26de8:	dec00404 	addi	sp,sp,16
   26dec:	f800283a 	ret

00026df0 <tse_mac_initTransInfo2>:

alt_32 tse_mac_initTransInfo2( tse_mac_trans_info *mi,
                                        alt_u32 mac_base,
                                        alt_32 tx_sgdma,
                                        alt_32 rx_sgdma,
                                        alt_32 cfgflags) {
   26df0:	defffb04 	addi	sp,sp,-20
   26df4:	df000415 	stw	fp,16(sp)
   26df8:	df000404 	addi	fp,sp,16
   26dfc:	e13ffc15 	stw	r4,-16(fp)
   26e00:	e17ffd15 	stw	r5,-12(fp)
   26e04:	e1bffe15 	stw	r6,-8(fp)
   26e08:	e1ffff15 	stw	r7,-4(fp)
                                              
        mi->base     = (np_tse_mac*)mac_base;
   26e0c:	e0fffd17 	ldw	r3,-12(fp)
   26e10:	e0bffc17 	ldw	r2,-16(fp)
   26e14:	10c00015 	stw	r3,0(r2)
        mi->tx_sgdma = (alt_sgdma_dev *)tx_sgdma;
   26e18:	e0fffe17 	ldw	r3,-8(fp)
   26e1c:	e0bffc17 	ldw	r2,-16(fp)
   26e20:	10c00115 	stw	r3,4(r2)
        mi->rx_sgdma = (alt_sgdma_dev *)rx_sgdma;
   26e24:	e0ffff17 	ldw	r3,-4(fp)
   26e28:	e0bffc17 	ldw	r2,-16(fp)
   26e2c:	10c00215 	stw	r3,8(r2)
        mi->cfgflags = cfgflags;     
   26e30:	e0c00117 	ldw	r3,4(fp)
   26e34:	e0bffc17 	ldw	r2,-16(fp)
   26e38:	10c00415 	stw	r3,16(r2)
        return SUCCESS;
   26e3c:	0005883a 	mov	r2,zero
}
   26e40:	e037883a 	mov	sp,fp
   26e44:	df000017 	ldw	fp,0(sp)
   26e48:	dec00104 	addi	sp,sp,4
   26e4c:	f800283a 	ret

00026e50 <tse_mac_sTxWrite>:
  * @param txDesc           Pointer to the transmit SGDMA descriptor
  * @return actual bytes transferred if ok, else error (-1)
  */
alt_32 tse_mac_sTxWrite( tse_mac_trans_info *mi, 
                       alt_sgdma_descriptor *txDesc)   
{ 
   26e50:	defffa04 	addi	sp,sp,-24
   26e54:	dfc00515 	stw	ra,20(sp)
   26e58:	df000415 	stw	fp,16(sp)
   26e5c:	df000404 	addi	fp,sp,16
   26e60:	e13ffe15 	stw	r4,-8(fp)
   26e64:	e17fff15 	stw	r5,-4(fp)

  alt_32 timeout;
  alt_u8 result = 0;
   26e68:	e03ffd05 	stb	zero,-12(fp)
  alt_u16 actualBytesTransferred;
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
   26e6c:	e03ffc15 	stw	zero,-16(fp)
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
   26e70:	00000e06 	br	26eac <tse_mac_sTxWrite+0x5c>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
           if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
   26e74:	e0fffc17 	ldw	r3,-16(fp)
   26e78:	008003f4 	movhi	r2,15
   26e7c:	10909004 	addi	r2,r2,16960
   26e80:	1885003a 	cmpeq	r2,r3,r2
   26e84:	e0fffc17 	ldw	r3,-16(fp)
   26e88:	18c00044 	addi	r3,r3,1
   26e8c:	e0fffc15 	stw	r3,-16(fp)
   26e90:	10803fcc 	andi	r2,r2,255
   26e94:	10000526 	beq	r2,zero,26eac <tse_mac_sTxWrite+0x5c>
            tse_dprintf(4, "WARNING : TX SGDMA Timeout\n");
   26e98:	010000f4 	movhi	r4,3
   26e9c:	21056904 	addi	r4,r4,5540
   26ea0:	001965c0 	call	1965c <puts>
            return ENP_RESOURCE;  // avoid being stuck here
   26ea4:	00bffa84 	movi	r2,-22
   26ea8:	00001c06 	br	26f1c <tse_mac_sTxWrite+0xcc>
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
   26eac:	e0bffe17 	ldw	r2,-8(fp)
   26eb0:	10800117 	ldw	r2,4(r2)
   26eb4:	10800317 	ldw	r2,12(r2)
   26eb8:	10800037 	ldwio	r2,0(r2)
   26ebc:	1080040c 	andi	r2,r2,16
   26ec0:	103fec1e 	bne	r2,zero,26e74 <tse_mac_sTxWrite+0x24>
           }
  }

  // Set up the SGDMA
  // Clear the status and control bits of the SGDMA descriptor
  IOWR_ALTERA_AVALON_SGDMA_CONTROL (mi->tx_sgdma->base, 0);
   26ec4:	e0bffe17 	ldw	r2,-8(fp)
   26ec8:	10800117 	ldw	r2,4(r2)
   26ecc:	10800317 	ldw	r2,12(r2)
   26ed0:	10800404 	addi	r2,r2,16
   26ed4:	0007883a 	mov	r3,zero
   26ed8:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS (mi->tx_sgdma->base, 0xFF);
   26edc:	e0bffe17 	ldw	r2,-8(fp)
   26ee0:	10800117 	ldw	r2,4(r2)
   26ee4:	10800317 	ldw	r2,12(r2)
   26ee8:	00c03fc4 	movi	r3,255
   26eec:	10c00035 	stwio	r3,0(r2)
  
  // Start SGDMA (blocking call)
  result = alt_avalon_sgdma_do_sync_transfer(
                mi->tx_sgdma, 
   26ef0:	e0bffe17 	ldw	r2,-8(fp)
  // Clear the status and control bits of the SGDMA descriptor
  IOWR_ALTERA_AVALON_SGDMA_CONTROL (mi->tx_sgdma->base, 0);
  IOWR_ALTERA_AVALON_SGDMA_STATUS (mi->tx_sgdma->base, 0xFF);
  
  // Start SGDMA (blocking call)
  result = alt_avalon_sgdma_do_sync_transfer(
   26ef4:	10800117 	ldw	r2,4(r2)
   26ef8:	1009883a 	mov	r4,r2
   26efc:	e17fff17 	ldw	r5,-4(fp)
   26f00:	0025fa40 	call	25fa4 <alt_avalon_sgdma_do_sync_transfer>
   26f04:	e0bffd05 	stb	r2,-12(fp)
                mi->tx_sgdma, 
                (alt_sgdma_descriptor *) &txDesc[0]);
  
  /* perform cache save read to obtain actual bytes transferred for current sgdma descriptor */
  actualBytesTransferred = IORD_ALTERA_TSE_SGDMA_DESC_ACTUAL_BYTES_TRANSFERRED(&txDesc[0]);
   26f08:	e0bfff17 	ldw	r2,-4(fp)
   26f0c:	10800704 	addi	r2,r2,28
   26f10:	10800037 	ldwio	r2,0(r2)
   26f14:	e0bffd8d 	sth	r2,-10(fp)

  return actualBytesTransferred;
   26f18:	e0bffd8b 	ldhu	r2,-10(fp)
}
   26f1c:	e037883a 	mov	sp,fp
   26f20:	dfc00117 	ldw	ra,4(sp)
   26f24:	df000017 	ldw	fp,0(sp)
   26f28:	dec00204 	addi	sp,sp,8
   26f2c:	f800283a 	ret

00026f30 <tse_mac_aRxRead>:
  *        the actual bytes transferred for current descriptor
  */
alt_32 tse_mac_aRxRead( 
  tse_mac_trans_info *mi,       
  alt_sgdma_descriptor *rxDesc)  
{
   26f30:	defffa04 	addi	sp,sp,-24
   26f34:	dfc00515 	stw	ra,20(sp)
   26f38:	df000415 	stw	fp,16(sp)
   26f3c:	df000404 	addi	fp,sp,16
   26f40:	e13ffe15 	stw	r4,-8(fp)
   26f44:	e17fff15 	stw	r5,-4(fp)
  alt_32 timeout;
  
  alt_u8 result = 0;
   26f48:	e03ffd05 	stb	zero,-12(fp)
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
   26f4c:	e03ffc15 	stw	zero,-16(fp)
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
   26f50:	00000e06 	br	26f8c <tse_mac_aRxRead+0x5c>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
   26f54:	e0fffc17 	ldw	r3,-16(fp)
   26f58:	008003f4 	movhi	r2,15
   26f5c:	10909004 	addi	r2,r2,16960
   26f60:	1885003a 	cmpeq	r2,r3,r2
   26f64:	e0fffc17 	ldw	r3,-16(fp)
   26f68:	18c00044 	addi	r3,r3,1
   26f6c:	e0fffc15 	stw	r3,-16(fp)
   26f70:	10803fcc 	andi	r2,r2,255
   26f74:	10000526 	beq	r2,zero,26f8c <tse_mac_aRxRead+0x5c>
        tse_dprintf(4, "WARNING : RX SGDMA Timeout\n");
   26f78:	010000f4 	movhi	r4,3
   26f7c:	21057004 	addi	r4,r4,5568
   26f80:	001965c0 	call	1965c <puts>
        return ENP_RESOURCE;  // avoid being stuck here
   26f84:	00bffa84 	movi	r2,-22
   26f88:	00000d06 	br	26fc0 <tse_mac_aRxRead+0x90>
  alt_u8 result = 0;
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
   26f8c:	e0bffe17 	ldw	r2,-8(fp)
   26f90:	10800217 	ldw	r2,8(r2)
   26f94:	10800317 	ldw	r2,12(r2)
   26f98:	10800037 	ldwio	r2,0(r2)
   26f9c:	1080040c 	andi	r2,r2,16
   26fa0:	103fec1e 	bne	r2,zero,26f54 <tse_mac_aRxRead+0x24>
  }

 
  // SGDMA operation invoked for RX (non-blocking call)
  result = alt_avalon_sgdma_do_async_transfer(
                mi->rx_sgdma, 
   26fa4:	e0bffe17 	ldw	r2,-8(fp)
    }
  }

 
  // SGDMA operation invoked for RX (non-blocking call)
  result = alt_avalon_sgdma_do_async_transfer(
   26fa8:	10800217 	ldw	r2,8(r2)
   26fac:	1009883a 	mov	r4,r2
   26fb0:	e17fff17 	ldw	r5,-4(fp)
   26fb4:	0025e800 	call	25e80 <alt_avalon_sgdma_do_async_transfer>
   26fb8:	e0bffd05 	stb	r2,-12(fp)
                mi->rx_sgdma, 
                (alt_sgdma_descriptor *) &rxDesc[0]);

 
  return SUCCESS;
   26fbc:	0005883a 	mov	r2,zero
}
   26fc0:	e037883a 	mov	sp,fp
   26fc4:	dfc00117 	ldw	ra,4(sp)
   26fc8:	df000017 	ldw	fp,0(sp)
   26fcc:	dec00204 	addi	sp,sp,8
   26fd0:	f800283a 	ret

00026fd4 <tse_mac_SwReset>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_SwReset(np_tse_mac *pmac) 
{
   26fd4:	defffc04 	addi	sp,sp,-16
   26fd8:	df000315 	stw	fp,12(sp)
   26fdc:	df000304 	addi	fp,sp,12
   26fe0:	e13fff15 	stw	r4,-4(fp)
	alt_32 timeout;
	alt_32 cc;
        
    cc = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
   26fe4:	e0bfff17 	ldw	r2,-4(fp)
   26fe8:	10800204 	addi	r2,r2,8
   26fec:	10800037 	ldwio	r2,0(r2)
   26ff0:	e0bffe15 	stw	r2,-8(fp)
    
    // set reset and Gig-Speed bits to make sure we have an incoming clock on
    // tx side. If there is a 10/100 PHY, we will still have a valid clock on
    // tx_clk no matter what setting we have here, but on a Gig phy the
    // MII clock may be missing.
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,(ALTERA_TSEMAC_CMD_SW_RESET_MSK | ALTERA_TSEMAC_CMD_ETH_SPEED_MSK));
   26ff4:	e0bfff17 	ldw	r2,-4(fp)
   26ff8:	10800204 	addi	r2,r2,8
   26ffc:	00c80204 	movi	r3,8200
   27000:	10c00035 	stwio	r3,0(r2)

    
    // wait for completion with fallback in case there is no PHY or it is
    // not connected and hence might not provide any clocks at all.
    timeout=0;
   27004:	e03ffd15 	stw	zero,-12(fp)
    while( (IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac) & ALTERA_TSEMAC_CMD_SW_RESET_MSK) != 0 && timeout < ALTERA_TSE_SW_RESET_TIME_OUT_CNT) timeout++;
   27008:	00000306 	br	27018 <tse_mac_SwReset+0x44>
   2700c:	e0bffd17 	ldw	r2,-12(fp)
   27010:	10800044 	addi	r2,r2,1
   27014:	e0bffd15 	stw	r2,-12(fp)
   27018:	e0bfff17 	ldw	r2,-4(fp)
   2701c:	10800204 	addi	r2,r2,8
   27020:	10800037 	ldwio	r2,0(r2)
   27024:	1088000c 	andi	r2,r2,8192
   27028:	10000326 	beq	r2,zero,27038 <tse_mac_SwReset+0x64>
   2702c:	e0bffd17 	ldw	r2,-12(fp)
   27030:	1089c410 	cmplti	r2,r2,10000
   27034:	103ff51e 	bne	r2,zero,2700c <tse_mac_SwReset+0x38>
   
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,cc); // Restore
   27038:	e0bfff17 	ldw	r2,-4(fp)
   2703c:	10800204 	addi	r2,r2,8
   27040:	e0fffe17 	ldw	r3,-8(fp)
   27044:	10c00035 	stwio	r3,0(r2)
    return SUCCESS;
   27048:	0005883a 	mov	r2,zero
}
   2704c:	e037883a 	mov	sp,fp
   27050:	df000017 	ldw	fp,0(sp)
   27054:	dec00104 	addi	sp,sp,4
   27058:	f800283a 	ret

0002705c <tse_mac_setMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_setMIImode(np_tse_mac *pmac)
{
   2705c:	defffd04 	addi	sp,sp,-12
   27060:	df000215 	stw	fp,8(sp)
   27064:	df000204 	addi	fp,sp,8
   27068:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
   2706c:	e0bfff17 	ldw	r2,-4(fp)
   27070:	10800204 	addi	r2,r2,8
   27074:	10800037 	ldwio	r2,0(r2)
   27078:	e0bffe15 	stw	r2,-8(fp)
  helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK; 
   2707c:	e0fffe17 	ldw	r3,-8(fp)
   27080:	00bffdc4 	movi	r2,-9
   27084:	1884703a 	and	r2,r3,r2
   27088:	e0bffe15 	stw	r2,-8(fp)
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
   2708c:	e0bfff17 	ldw	r2,-4(fp)
   27090:	10800204 	addi	r2,r2,8
   27094:	e0fffe17 	ldw	r3,-8(fp)
   27098:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
   2709c:	0005883a 	mov	r2,zero
}
   270a0:	e037883a 	mov	sp,fp
   270a4:	df000017 	ldw	fp,0(sp)
   270a8:	dec00104 	addi	sp,sp,4
   270ac:	f800283a 	ret

000270b0 <tse_mac_setGMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
 */
alt_32 tse_mac_setGMIImode(np_tse_mac *pmac)
{
   270b0:	defffd04 	addi	sp,sp,-12
   270b4:	df000215 	stw	fp,8(sp)
   270b8:	df000204 	addi	fp,sp,8
   270bc:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
   270c0:	e0bfff17 	ldw	r2,-4(fp)
   270c4:	10800204 	addi	r2,r2,8
   270c8:	10800037 	ldwio	r2,0(r2)
   270cc:	e0bffe15 	stw	r2,-8(fp)
  helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
   270d0:	e0bffe17 	ldw	r2,-8(fp)
   270d4:	10800214 	ori	r2,r2,8
   270d8:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
   270dc:	e0bfff17 	ldw	r2,-4(fp)
   270e0:	10800204 	addi	r2,r2,8
   270e4:	e0fffe17 	ldw	r3,-8(fp)
   270e8:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
   270ec:	0005883a 	mov	r2,zero
}
   270f0:	e037883a 	mov	sp,fp
   270f4:	df000017 	ldw	fp,0(sp)
   270f8:	dec00104 	addi	sp,sp,4
   270fc:	f800283a 	ret

00027100 <alt_tse_phy_add_profile>:
 * @param  phy  pointer to alt_tse_phy_profile structure describing PHY registers
 * @return      index of PHY added in PHY profile on success, else return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 * PHY which are currently supported by default :  Marvell 88E1111, Marvell Quad PHY 88E1145, National DP83865, and National DP83848C
 */
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
   27100:	defffb04 	addi	sp,sp,-20
   27104:	dfc00415 	stw	ra,16(sp)
   27108:	df000315 	stw	fp,12(sp)
   2710c:	dc000215 	stw	r16,8(sp)
   27110:	df000204 	addi	fp,sp,8
   27114:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
   27118:	e03ffe15 	stw	zero,-8(fp)
   2711c:	00002906 	br	271c4 <alt_tse_phy_add_profile+0xc4>
    {
        if(pphy_profiles[i]->oui == phy->oui && pphy_profiles[i]->model_number == phy->model_number)
   27120:	00c00234 	movhi	r3,8
   27124:	18c41a04 	addi	r3,r3,4200
   27128:	e0bffe17 	ldw	r2,-8(fp)
   2712c:	1085883a 	add	r2,r2,r2
   27130:	1085883a 	add	r2,r2,r2
   27134:	1885883a 	add	r2,r3,r2
   27138:	10800017 	ldw	r2,0(r2)
   2713c:	10c01417 	ldw	r3,80(r2)
   27140:	e0bfff17 	ldw	r2,-4(fp)
   27144:	10801417 	ldw	r2,80(r2)
   27148:	18801b1e 	bne	r3,r2,271b8 <alt_tse_phy_add_profile+0xb8>
   2714c:	00c00234 	movhi	r3,8
   27150:	18c41a04 	addi	r3,r3,4200
   27154:	e0bffe17 	ldw	r2,-8(fp)
   27158:	1085883a 	add	r2,r2,r2
   2715c:	1085883a 	add	r2,r2,r2
   27160:	1885883a 	add	r2,r3,r2
   27164:	10800017 	ldw	r2,0(r2)
   27168:	10c01503 	ldbu	r3,84(r2)
   2716c:	e0bfff17 	ldw	r2,-4(fp)
   27170:	10801503 	ldbu	r2,84(r2)
   27174:	18c03fcc 	andi	r3,r3,255
   27178:	10803fcc 	andi	r2,r2,255
   2717c:	18800e1e 	bne	r3,r2,271b8 <alt_tse_phy_add_profile+0xb8>
        {
            tse_dprintf(4, "WARNING : PHY OUI 0x%06x, PHY Model Number 0x%02x already exist in PHY profile\n", (int) phy->oui, phy->model_number);
   27180:	e0bfff17 	ldw	r2,-4(fp)
   27184:	10801417 	ldw	r2,80(r2)
   27188:	1007883a 	mov	r3,r2
   2718c:	e0bfff17 	ldw	r2,-4(fp)
   27190:	10801503 	ldbu	r2,84(r2)
   27194:	10803fcc 	andi	r2,r2,255
   27198:	010000f4 	movhi	r4,3
   2719c:	21057704 	addi	r4,r4,5596
   271a0:	180b883a 	mov	r5,r3
   271a4:	100d883a 	mov	r6,r2
   271a8:	00193f00 	call	193f0 <printf>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
   271ac:	010000f4 	movhi	r4,3
   271b0:	21058b04 	addi	r4,r4,5676
   271b4:	001965c0 	call	1965c <puts>
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
   271b8:	e0bffe17 	ldw	r2,-8(fp)
   271bc:	10800044 	addi	r2,r2,1
   271c0:	e0bffe15 	stw	r2,-8(fp)
   271c4:	d0a8df03 	ldbu	r2,-23684(gp)
   271c8:	10803fcc 	andi	r2,r2,255
   271cc:	e0fffe17 	ldw	r3,-8(fp)
   271d0:	18bfd316 	blt	r3,r2,27120 <alt_tse_phy_add_profile+0x20>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
        }
    }

    /* Allocate memory space to store the profile */    
    pphy_profiles[phy_profile_count] = (alt_tse_phy_profile *) malloc(sizeof(alt_tse_phy_profile));
   271d4:	d0a8df03 	ldbu	r2,-23684(gp)
   271d8:	14003fcc 	andi	r16,r2,255
   271dc:	01001904 	movi	r4,100
   271e0:	002df340 	call	2df34 <malloc>
   271e4:	1007883a 	mov	r3,r2
   271e8:	01000234 	movhi	r4,8
   271ec:	21041a04 	addi	r4,r4,4200
   271f0:	8405883a 	add	r2,r16,r16
   271f4:	1085883a 	add	r2,r2,r2
   271f8:	2085883a 	add	r2,r4,r2
   271fc:	10c00015 	stw	r3,0(r2)
    if(!pphy_profiles[phy_profile_count]) {
   27200:	d0a8df03 	ldbu	r2,-23684(gp)
   27204:	10803fcc 	andi	r2,r2,255
   27208:	00c00234 	movhi	r3,8
   2720c:	18c41a04 	addi	r3,r3,4200
   27210:	1085883a 	add	r2,r2,r2
   27214:	1085883a 	add	r2,r2,r2
   27218:	1885883a 	add	r2,r3,r2
   2721c:	10800017 	ldw	r2,0(r2)
   27220:	1000081e 	bne	r2,zero,27244 <alt_tse_phy_add_profile+0x144>
        tse_dprintf(1, "ERROR   : Unable to allocate memory for pphy_profile[%d]\n", phy_profile_count);
   27224:	d0a8df03 	ldbu	r2,-23684(gp)
   27228:	10803fcc 	andi	r2,r2,255
   2722c:	010000f4 	movhi	r4,3
   27230:	2105a304 	addi	r4,r4,5772
   27234:	100b883a 	mov	r5,r2
   27238:	00193f00 	call	193f0 <printf>
        return ALTERA_TSE_MALLOC_FAILED;
   2723c:	00bfffc4 	movi	r2,-1
   27240:	00002206 	br	272cc <alt_tse_phy_add_profile+0x1cc>
    }

    /* Store PHY information */
    *pphy_profiles[phy_profile_count] = *phy;
   27244:	d0a8df03 	ldbu	r2,-23684(gp)
   27248:	10803fcc 	andi	r2,r2,255
   2724c:	00c00234 	movhi	r3,8
   27250:	18c41a04 	addi	r3,r3,4200
   27254:	1085883a 	add	r2,r2,r2
   27258:	1085883a 	add	r2,r2,r2
   2725c:	1885883a 	add	r2,r3,r2
   27260:	10c00017 	ldw	r3,0(r2)
   27264:	e0bfff17 	ldw	r2,-4(fp)
   27268:	1809883a 	mov	r4,r3
   2726c:	1007883a 	mov	r3,r2
   27270:	00801904 	movi	r2,100
   27274:	180b883a 	mov	r5,r3
   27278:	100d883a 	mov	r6,r2
   2727c:	00191f00 	call	191f0 <memcpy>
    strcpy(pphy_profiles[phy_profile_count]->name, phy->name);
   27280:	d0a8df03 	ldbu	r2,-23684(gp)
   27284:	10803fcc 	andi	r2,r2,255
   27288:	00c00234 	movhi	r3,8
   2728c:	18c41a04 	addi	r3,r3,4200
   27290:	1085883a 	add	r2,r2,r2
   27294:	1085883a 	add	r2,r2,r2
   27298:	1885883a 	add	r2,r3,r2
   2729c:	10800017 	ldw	r2,0(r2)
   272a0:	1007883a 	mov	r3,r2
   272a4:	e0bfff17 	ldw	r2,-4(fp)
   272a8:	1809883a 	mov	r4,r3
   272ac:	100b883a 	mov	r5,r2
   272b0:	002df5c0 	call	2df5c <strcpy>
    
    phy_profile_count++;
   272b4:	d0a8df03 	ldbu	r2,-23684(gp)
   272b8:	10800044 	addi	r2,r2,1
   272bc:	d0a8df05 	stb	r2,-23684(gp)
    
    return phy_profile_count - 1;
   272c0:	d0a8df03 	ldbu	r2,-23684(gp)
   272c4:	10803fcc 	andi	r2,r2,255
   272c8:	10bfffc4 	addi	r2,r2,-1
}
   272cc:	e037883a 	mov	sp,fp
   272d0:	dfc00217 	ldw	ra,8(sp)
   272d4:	df000117 	ldw	fp,4(sp)
   272d8:	dc000017 	ldw	r16,0(sp)
   272dc:	dec00304 	addi	sp,sp,12
   272e0:	f800283a 	ret

000272e4 <alt_tse_system_add_sys>:
alt_32 alt_tse_system_add_sys(
	alt_tse_system_mac					*psys_mac,
	alt_tse_system_sgdma				*psys_sgdma,
	alt_tse_system_desc_mem				*psys_mem,
	alt_tse_system_shared_fifo			*psys_shared_fifo,
	alt_tse_system_phy 					*psys_phy ) {
   272e4:	defff204 	addi	sp,sp,-56
   272e8:	dfc00d15 	stw	ra,52(sp)
   272ec:	df000c15 	stw	fp,48(sp)
   272f0:	dc000b15 	stw	r16,44(sp)
   272f4:	df000b04 	addi	fp,sp,44
   272f8:	e13ffc15 	stw	r4,-16(fp)
   272fc:	e17ffd15 	stw	r5,-12(fp)
   27300:	e1bffe15 	stw	r6,-8(fp)
   27304:	e1ffff15 	stw	r7,-4(fp)

	int i;
	int loop_end;
	
	alt_tse_system_mac					*pmac	= psys_mac;
   27308:	e0bffc17 	ldw	r2,-16(fp)
   2730c:	e0bffb15 	stw	r2,-20(fp)
	alt_tse_system_sgdma				*psgdma	= psys_sgdma;
   27310:	e0bffd17 	ldw	r2,-12(fp)
   27314:	e0bff715 	stw	r2,-36(fp)
	alt_tse_system_desc_mem				*pmem	= psys_mem;
   27318:	e0bffe17 	ldw	r2,-8(fp)
   2731c:	e0bff815 	stw	r2,-32(fp)
	alt_tse_system_shared_fifo			*pfifo	= psys_shared_fifo;
   27320:	e0bfff17 	ldw	r2,-4(fp)
   27324:	e0bff915 	stw	r2,-28(fp)
	alt_tse_system_phy 					*pphy	= psys_phy;
   27328:	e0800317 	ldw	r2,12(fp)
   2732c:	e0bffa15 	stw	r2,-24(fp)
	
	static alt_8 tse_system_count = 0;
	
	/* Determine number of loop */
	/* Run at least one for non-multi-channel MAC */
	if(pmac->tse_num_of_channel == 0) {
   27330:	e0bffb17 	ldw	r2,-20(fp)
   27334:	10800303 	ldbu	r2,12(r2)
   27338:	10803fcc 	andi	r2,r2,255
   2733c:	1000031e 	bne	r2,zero,2734c <alt_tse_system_add_sys+0x68>
		loop_end = 1;
   27340:	00800044 	movi	r2,1
   27344:	e0bff615 	stw	r2,-40(fp)
   27348:	00000e06 	br	27384 <alt_tse_system_add_sys+0xa0>
	}
	else if(pmac->tse_num_of_channel > 0) {
   2734c:	e0bffb17 	ldw	r2,-20(fp)
   27350:	10800303 	ldbu	r2,12(r2)
   27354:	10803fcc 	andi	r2,r2,255
   27358:	10000526 	beq	r2,zero,27370 <alt_tse_system_add_sys+0x8c>
		loop_end = pmac->tse_num_of_channel; 
   2735c:	e0bffb17 	ldw	r2,-20(fp)
   27360:	10800303 	ldbu	r2,12(r2)
   27364:	10803fcc 	andi	r2,r2,255
   27368:	e0bff615 	stw	r2,-40(fp)
   2736c:	00000506 	br	27384 <alt_tse_system_add_sys+0xa0>
	}
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
   27370:	010000f4 	movhi	r4,3
   27374:	2105b204 	addi	r4,r4,5832
   27378:	001965c0 	call	1965c <puts>
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
   2737c:	00bfffc4 	movi	r2,-1
   27380:	00025106 	br	27cc8 <alt_tse_system_add_sys+0x9e4>
	}

	for(i = 0; i < loop_end; i++) {
   27384:	e03ff515 	stw	zero,-44(fp)
   27388:	00024b06 	br	27cb8 <alt_tse_system_add_sys+0x9d4>
		
		/* Make sure the boundary of array is not exceeded */
		if(tse_system_count >= MAXNETS) {
   2738c:	d0a8dfc3 	ldbu	r2,-23681(gp)
   27390:	10803fcc 	andi	r2,r2,255
   27394:	1080201c 	xori	r2,r2,128
   27398:	10bfe004 	addi	r2,r2,-128
   2739c:	10800210 	cmplti	r2,r2,8
   273a0:	10000c1e 	bne	r2,zero,273d4 <alt_tse_system_add_sys+0xf0>
			tse_dprintf(2, "ERROR   : Number of TSE System added exceed the size of array!\n");
   273a4:	010000f4 	movhi	r4,3
   273a8:	2105be04 	addi	r4,r4,5880
   273ac:	001965c0 	call	1965c <puts>
			tse_dprintf(2, "ERROR   : Size of array = %d, Number of TSE System = %d\n", MAXNETS, tse_system_count);
   273b0:	d0a8dfc3 	ldbu	r2,-23681(gp)
   273b4:	10803fcc 	andi	r2,r2,255
   273b8:	1080201c 	xori	r2,r2,128
   273bc:	10bfe004 	addi	r2,r2,-128
   273c0:	010000f4 	movhi	r4,3
   273c4:	2105ce04 	addi	r4,r4,5944
   273c8:	01400204 	movi	r5,8
   273cc:	100d883a 	mov	r6,r2
   273d0:	00193f00 	call	193f0 <printf>
		}

		/* Add MAC info to alt_tse_system_info structure */
		if(pmac == 0) {
   273d4:	e0bffb17 	ldw	r2,-20(fp)
   273d8:	1000081e 	bne	r2,zero,273fc <alt_tse_system_add_sys+0x118>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
   273dc:	010000f4 	movhi	r4,3
   273e0:	2105dd04 	addi	r4,r4,6004
   273e4:	001965c0 	call	1965c <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys()\n");
   273e8:	010000f4 	movhi	r4,3
   273ec:	2105e704 	addi	r4,r4,6044
   273f0:	001965c0 	call	1965c <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
   273f4:	00bfffc4 	movi	r2,-1
   273f8:	00023306 	br	27cc8 <alt_tse_system_add_sys+0x9e4>
		}		
		
		tse_mac_device[tse_system_count].tse_mac_base 					= pmac->tse_mac_base + (i * 0x400);
   273fc:	d0a8dfc3 	ldbu	r2,-23681(gp)
   27400:	10803fcc 	andi	r2,r2,255
   27404:	1080201c 	xori	r2,r2,128
   27408:	10bfe004 	addi	r2,r2,-128
   2740c:	e0fffb17 	ldw	r3,-20(fp)
   27410:	19000017 	ldw	r4,0(r3)
   27414:	e0fff517 	ldw	r3,-44(fp)
   27418:	180692ba 	slli	r3,r3,10
   2741c:	20c7883a 	add	r3,r4,r3
   27420:	010000f4 	movhi	r4,3
   27424:	210d0b04 	addi	r4,r4,13356
   27428:	10801224 	muli	r2,r2,72
   2742c:	2085883a 	add	r2,r4,r2
   27430:	10c00015 	stw	r3,0(r2)
		tse_mac_device[tse_system_count].tse_tx_depth 					= pmac->tse_tx_depth;
   27434:	d0a8dfc3 	ldbu	r2,-23681(gp)
   27438:	10803fcc 	andi	r2,r2,255
   2743c:	1080201c 	xori	r2,r2,128
   27440:	10bfe004 	addi	r2,r2,-128
   27444:	e0fffb17 	ldw	r3,-20(fp)
   27448:	18c0010b 	ldhu	r3,4(r3)
   2744c:	010000f4 	movhi	r4,3
   27450:	210d0b04 	addi	r4,r4,13356
   27454:	10801224 	muli	r2,r2,72
   27458:	2085883a 	add	r2,r4,r2
   2745c:	10800104 	addi	r2,r2,4
   27460:	10c0000d 	sth	r3,0(r2)
		tse_mac_device[tse_system_count].tse_rx_depth 					= pmac->tse_rx_depth;
   27464:	d0a8dfc3 	ldbu	r2,-23681(gp)
   27468:	10803fcc 	andi	r2,r2,255
   2746c:	1080201c 	xori	r2,r2,128
   27470:	10bfe004 	addi	r2,r2,-128
   27474:	e0fffb17 	ldw	r3,-20(fp)
   27478:	18c0018b 	ldhu	r3,6(r3)
   2747c:	010000f4 	movhi	r4,3
   27480:	210d0b04 	addi	r4,r4,13356
   27484:	10801224 	muli	r2,r2,72
   27488:	2085883a 	add	r2,r4,r2
   2748c:	10800104 	addi	r2,r2,4
   27490:	10c0008d 	sth	r3,2(r2)
		tse_mac_device[tse_system_count].tse_use_mdio 					= pmac->tse_use_mdio;
   27494:	d0a8dfc3 	ldbu	r2,-23681(gp)
   27498:	10803fcc 	andi	r2,r2,255
   2749c:	1080201c 	xori	r2,r2,128
   274a0:	10bfe004 	addi	r2,r2,-128
   274a4:	e0fffb17 	ldw	r3,-20(fp)
   274a8:	18c00203 	ldbu	r3,8(r3)
   274ac:	010000f4 	movhi	r4,3
   274b0:	210d0b04 	addi	r4,r4,13356
   274b4:	10801224 	muli	r2,r2,72
   274b8:	2085883a 	add	r2,r4,r2
   274bc:	10800204 	addi	r2,r2,8
   274c0:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_en_maclite 				= pmac->tse_en_maclite;
   274c4:	d0a8dfc3 	ldbu	r2,-23681(gp)
   274c8:	10803fcc 	andi	r2,r2,255
   274cc:	1080201c 	xori	r2,r2,128
   274d0:	10bfe004 	addi	r2,r2,-128
   274d4:	e0fffb17 	ldw	r3,-20(fp)
   274d8:	18c00243 	ldbu	r3,9(r3)
   274dc:	010000f4 	movhi	r4,3
   274e0:	210d0b04 	addi	r4,r4,13356
   274e4:	10801224 	muli	r2,r2,72
   274e8:	2085883a 	add	r2,r4,r2
   274ec:	10800204 	addi	r2,r2,8
   274f0:	10c00045 	stb	r3,1(r2)
		tse_mac_device[tse_system_count].tse_maclite_gige 				= pmac->tse_maclite_gige;
   274f4:	d0a8dfc3 	ldbu	r2,-23681(gp)
   274f8:	10803fcc 	andi	r2,r2,255
   274fc:	1080201c 	xori	r2,r2,128
   27500:	10bfe004 	addi	r2,r2,-128
   27504:	e0fffb17 	ldw	r3,-20(fp)
   27508:	18c00283 	ldbu	r3,10(r3)
   2750c:	010000f4 	movhi	r4,3
   27510:	210d0b04 	addi	r4,r4,13356
   27514:	10801224 	muli	r2,r2,72
   27518:	2085883a 	add	r2,r4,r2
   2751c:	10800204 	addi	r2,r2,8
   27520:	10c00085 	stb	r3,2(r2)
		tse_mac_device[tse_system_count].tse_multichannel_mac 			= pmac->tse_multichannel_mac;
   27524:	d0a8dfc3 	ldbu	r2,-23681(gp)
   27528:	10803fcc 	andi	r2,r2,255
   2752c:	1080201c 	xori	r2,r2,128
   27530:	10bfe004 	addi	r2,r2,-128
   27534:	e0fffb17 	ldw	r3,-20(fp)
   27538:	18c002c3 	ldbu	r3,11(r3)
   2753c:	010000f4 	movhi	r4,3
   27540:	210d0b04 	addi	r4,r4,13356
   27544:	10801224 	muli	r2,r2,72
   27548:	2085883a 	add	r2,r4,r2
   2754c:	10800204 	addi	r2,r2,8
   27550:	10c000c5 	stb	r3,3(r2)
		tse_mac_device[tse_system_count].tse_num_of_channel 			= pmac->tse_num_of_channel;
   27554:	d0a8dfc3 	ldbu	r2,-23681(gp)
   27558:	10803fcc 	andi	r2,r2,255
   2755c:	1080201c 	xori	r2,r2,128
   27560:	10bfe004 	addi	r2,r2,-128
   27564:	e0fffb17 	ldw	r3,-20(fp)
   27568:	18c00303 	ldbu	r3,12(r3)
   2756c:	010000f4 	movhi	r4,3
   27570:	210d0b04 	addi	r4,r4,13356
   27574:	10801224 	muli	r2,r2,72
   27578:	2085883a 	add	r2,r4,r2
   2757c:	10800304 	addi	r2,r2,12
   27580:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_mdio_shared 				= pmac->tse_mdio_shared;
   27584:	d0a8dfc3 	ldbu	r2,-23681(gp)
   27588:	10803fcc 	andi	r2,r2,255
   2758c:	1080201c 	xori	r2,r2,128
   27590:	10bfe004 	addi	r2,r2,-128
   27594:	e0fffb17 	ldw	r3,-20(fp)
   27598:	18c00343 	ldbu	r3,13(r3)
   2759c:	010000f4 	movhi	r4,3
   275a0:	210d0b04 	addi	r4,r4,13356
   275a4:	10801224 	muli	r2,r2,72
   275a8:	2085883a 	add	r2,r4,r2
   275ac:	10800304 	addi	r2,r2,12
   275b0:	10c00045 	stb	r3,1(r2)
		tse_mac_device[tse_system_count].tse_number_of_mac_mdio_shared	= pmac->tse_number_of_mac_mdio_shared;
   275b4:	d0a8dfc3 	ldbu	r2,-23681(gp)
   275b8:	10803fcc 	andi	r2,r2,255
   275bc:	1080201c 	xori	r2,r2,128
   275c0:	10bfe004 	addi	r2,r2,-128
   275c4:	e0fffb17 	ldw	r3,-20(fp)
   275c8:	18c00383 	ldbu	r3,14(r3)
   275cc:	010000f4 	movhi	r4,3
   275d0:	210d0b04 	addi	r4,r4,13356
   275d4:	10801224 	muli	r2,r2,72
   275d8:	2085883a 	add	r2,r4,r2
   275dc:	10800304 	addi	r2,r2,12
   275e0:	10c00085 	stb	r3,2(r2)
		tse_mac_device[tse_system_count].tse_pcs_ena 					= pmac->tse_pcs_ena;
   275e4:	d0a8dfc3 	ldbu	r2,-23681(gp)
   275e8:	10803fcc 	andi	r2,r2,255
   275ec:	1080201c 	xori	r2,r2,128
   275f0:	10bfe004 	addi	r2,r2,-128
   275f4:	e0fffb17 	ldw	r3,-20(fp)
   275f8:	18c003c3 	ldbu	r3,15(r3)
   275fc:	010000f4 	movhi	r4,3
   27600:	210d0b04 	addi	r4,r4,13356
   27604:	10801224 	muli	r2,r2,72
   27608:	2085883a 	add	r2,r4,r2
   2760c:	10800304 	addi	r2,r2,12
   27610:	10c000c5 	stb	r3,3(r2)
		tse_mac_device[tse_system_count].tse_pcs_sgmii 					= pmac->tse_pcs_sgmii;
   27614:	d0a8dfc3 	ldbu	r2,-23681(gp)
   27618:	10803fcc 	andi	r2,r2,255
   2761c:	1080201c 	xori	r2,r2,128
   27620:	10bfe004 	addi	r2,r2,-128
   27624:	e0fffb17 	ldw	r3,-20(fp)
   27628:	18c00403 	ldbu	r3,16(r3)
   2762c:	010000f4 	movhi	r4,3
   27630:	210d0b04 	addi	r4,r4,13356
   27634:	10801224 	muli	r2,r2,72
   27638:	2085883a 	add	r2,r4,r2
   2763c:	10800404 	addi	r2,r2,16
   27640:	10c00005 	stb	r3,0(r2)
		
		/* Add SGDMA info to alt_tse_system_info structure */
		if(psgdma == 0) {
   27644:	e0bff717 	ldw	r2,-36(fp)
   27648:	10000d1e 	bne	r2,zero,27680 <alt_tse_system_add_sys+0x39c>
			tse_dprintf(2, "ERROR   : SGDMA system structure == NULL\n");
   2764c:	010000f4 	movhi	r4,3
   27650:	2105f904 	addi	r4,r4,6116
   27654:	001965c0 	call	1965c <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys() for tse_mac_device[%d]\n", tse_system_count);
   27658:	d0a8dfc3 	ldbu	r2,-23681(gp)
   2765c:	10803fcc 	andi	r2,r2,255
   27660:	1080201c 	xori	r2,r2,128
   27664:	10bfe004 	addi	r2,r2,-128
   27668:	010000f4 	movhi	r4,3
   2766c:	21060404 	addi	r4,r4,6160
   27670:	100b883a 	mov	r5,r2
   27674:	00193f00 	call	193f0 <printf>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
   27678:	00bfffc4 	movi	r2,-1
   2767c:	00019206 	br	27cc8 <alt_tse_system_add_sys+0x9e4>
		}
		
		tse_mac_device[tse_system_count].tse_sgdma_tx = (char *) malloc(strlen(psgdma->tse_sgdma_tx) + 1);
   27680:	d0a8dfc3 	ldbu	r2,-23681(gp)
   27684:	14003fcc 	andi	r16,r2,255
   27688:	8400201c 	xori	r16,r16,128
   2768c:	843fe004 	addi	r16,r16,-128
   27690:	e0bff717 	ldw	r2,-36(fp)
   27694:	10800017 	ldw	r2,0(r2)
   27698:	1009883a 	mov	r4,r2
   2769c:	00197140 	call	19714 <strlen>
   276a0:	10800044 	addi	r2,r2,1
   276a4:	1009883a 	mov	r4,r2
   276a8:	002df340 	call	2df34 <malloc>
   276ac:	1007883a 	mov	r3,r2
   276b0:	010000f4 	movhi	r4,3
   276b4:	210d0b04 	addi	r4,r4,13356
   276b8:	80801224 	muli	r2,r16,72
   276bc:	2085883a 	add	r2,r4,r2
   276c0:	10800504 	addi	r2,r2,20
   276c4:	10c00015 	stw	r3,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_tx) {
   276c8:	d0a8dfc3 	ldbu	r2,-23681(gp)
   276cc:	10803fcc 	andi	r2,r2,255
   276d0:	1080201c 	xori	r2,r2,128
   276d4:	10bfe004 	addi	r2,r2,-128
   276d8:	00c000f4 	movhi	r3,3
   276dc:	18cd0b04 	addi	r3,r3,13356
   276e0:	10801224 	muli	r2,r2,72
   276e4:	1885883a 	add	r2,r3,r2
   276e8:	10800504 	addi	r2,r2,20
   276ec:	10800017 	ldw	r2,0(r2)
   276f0:	10000a1e 	bne	r2,zero,2771c <alt_tse_system_add_sys+0x438>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_tx\n", tse_system_count);
   276f4:	d0a8dfc3 	ldbu	r2,-23681(gp)
   276f8:	10803fcc 	andi	r2,r2,255
   276fc:	1080201c 	xori	r2,r2,128
   27700:	10bfe004 	addi	r2,r2,-128
   27704:	010000f4 	movhi	r4,3
   27708:	21061c04 	addi	r4,r4,6256
   2770c:	100b883a 	mov	r5,r2
   27710:	00193f00 	call	193f0 <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
   27714:	00bfffc4 	movi	r2,-1
   27718:	00016b06 	br	27cc8 <alt_tse_system_add_sys+0x9e4>
	    }   
		strcpy(tse_mac_device[tse_system_count].tse_sgdma_tx, psgdma->tse_sgdma_tx);
   2771c:	d0a8dfc3 	ldbu	r2,-23681(gp)
   27720:	10803fcc 	andi	r2,r2,255
   27724:	1080201c 	xori	r2,r2,128
   27728:	10bfe004 	addi	r2,r2,-128
   2772c:	00c000f4 	movhi	r3,3
   27730:	18cd0b04 	addi	r3,r3,13356
   27734:	10801224 	muli	r2,r2,72
   27738:	1885883a 	add	r2,r3,r2
   2773c:	10800504 	addi	r2,r2,20
   27740:	10c00017 	ldw	r3,0(r2)
   27744:	e0bff717 	ldw	r2,-36(fp)
   27748:	10800017 	ldw	r2,0(r2)
   2774c:	1809883a 	mov	r4,r3
   27750:	100b883a 	mov	r5,r2
   27754:	002df5c0 	call	2df5c <strcpy>
		
		tse_mac_device[tse_system_count].tse_sgdma_rx = (char *) malloc(strlen(psgdma->tse_sgdma_rx) + 1);
   27758:	d0a8dfc3 	ldbu	r2,-23681(gp)
   2775c:	14003fcc 	andi	r16,r2,255
   27760:	8400201c 	xori	r16,r16,128
   27764:	843fe004 	addi	r16,r16,-128
   27768:	e0bff717 	ldw	r2,-36(fp)
   2776c:	10800117 	ldw	r2,4(r2)
   27770:	1009883a 	mov	r4,r2
   27774:	00197140 	call	19714 <strlen>
   27778:	10800044 	addi	r2,r2,1
   2777c:	1009883a 	mov	r4,r2
   27780:	002df340 	call	2df34 <malloc>
   27784:	1007883a 	mov	r3,r2
   27788:	010000f4 	movhi	r4,3
   2778c:	210d0b04 	addi	r4,r4,13356
   27790:	80801224 	muli	r2,r16,72
   27794:	2085883a 	add	r2,r4,r2
   27798:	10800604 	addi	r2,r2,24
   2779c:	10c00015 	stw	r3,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_rx) {
   277a0:	d0a8dfc3 	ldbu	r2,-23681(gp)
   277a4:	10803fcc 	andi	r2,r2,255
   277a8:	1080201c 	xori	r2,r2,128
   277ac:	10bfe004 	addi	r2,r2,-128
   277b0:	00c000f4 	movhi	r3,3
   277b4:	18cd0b04 	addi	r3,r3,13356
   277b8:	10801224 	muli	r2,r2,72
   277bc:	1885883a 	add	r2,r3,r2
   277c0:	10800604 	addi	r2,r2,24
   277c4:	10800017 	ldw	r2,0(r2)
   277c8:	10000a1e 	bne	r2,zero,277f4 <alt_tse_system_add_sys+0x510>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_rx\n", tse_system_count);
   277cc:	d0a8dfc3 	ldbu	r2,-23681(gp)
   277d0:	10803fcc 	andi	r2,r2,255
   277d4:	1080201c 	xori	r2,r2,128
   277d8:	10bfe004 	addi	r2,r2,-128
   277dc:	010000f4 	movhi	r4,3
   277e0:	21062f04 	addi	r4,r4,6332
   277e4:	100b883a 	mov	r5,r2
   277e8:	00193f00 	call	193f0 <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
   277ec:	00bfffc4 	movi	r2,-1
   277f0:	00013506 	br	27cc8 <alt_tse_system_add_sys+0x9e4>
	    }
	    strcpy(tse_mac_device[tse_system_count].tse_sgdma_rx, psgdma->tse_sgdma_rx);
   277f4:	d0a8dfc3 	ldbu	r2,-23681(gp)
   277f8:	10803fcc 	andi	r2,r2,255
   277fc:	1080201c 	xori	r2,r2,128
   27800:	10bfe004 	addi	r2,r2,-128
   27804:	00c000f4 	movhi	r3,3
   27808:	18cd0b04 	addi	r3,r3,13356
   2780c:	10801224 	muli	r2,r2,72
   27810:	1885883a 	add	r2,r3,r2
   27814:	10800604 	addi	r2,r2,24
   27818:	10c00017 	ldw	r3,0(r2)
   2781c:	e0bff717 	ldw	r2,-36(fp)
   27820:	10800117 	ldw	r2,4(r2)
   27824:	1809883a 	mov	r4,r3
   27828:	100b883a 	mov	r5,r2
   2782c:	002df5c0 	call	2df5c <strcpy>
	    
		tse_mac_device[tse_system_count].tse_sgdma_rx_irq = psgdma->tse_sgdma_rx_irq;
   27830:	d0a8dfc3 	ldbu	r2,-23681(gp)
   27834:	10803fcc 	andi	r2,r2,255
   27838:	1080201c 	xori	r2,r2,128
   2783c:	10bfe004 	addi	r2,r2,-128
   27840:	e0fff717 	ldw	r3,-36(fp)
   27844:	18c0020b 	ldhu	r3,8(r3)
   27848:	010000f4 	movhi	r4,3
   2784c:	210d0b04 	addi	r4,r4,13356
   27850:	10801224 	muli	r2,r2,72
   27854:	2085883a 	add	r2,r4,r2
   27858:	10800704 	addi	r2,r2,28
   2785c:	10c0000d 	sth	r3,0(r2)
		
		/* Add descriptor memory info to alt_tse_system_info structure */
		if(pmem == 0) {
   27860:	e0bff817 	ldw	r2,-32(fp)
   27864:	1000151e 	bne	r2,zero,278bc <alt_tse_system_add_sys+0x5d8>
			tse_mac_device[tse_system_count].ext_desc_mem	= TSE_INT_DESC_MEM;
   27868:	d0a8dfc3 	ldbu	r2,-23681(gp)
   2786c:	10803fcc 	andi	r2,r2,255
   27870:	1080201c 	xori	r2,r2,128
   27874:	10bfe004 	addi	r2,r2,-128
   27878:	00c000f4 	movhi	r3,3
   2787c:	18cd0b04 	addi	r3,r3,13356
   27880:	10801224 	muli	r2,r2,72
   27884:	1885883a 	add	r2,r3,r2
   27888:	10800704 	addi	r2,r2,28
   2788c:	10000085 	stb	zero,2(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= TSE_INT_DESC_MEM;
   27890:	d0a8dfc3 	ldbu	r2,-23681(gp)
   27894:	10803fcc 	andi	r2,r2,255
   27898:	1080201c 	xori	r2,r2,128
   2789c:	10bfe004 	addi	r2,r2,-128
   278a0:	00c000f4 	movhi	r3,3
   278a4:	18cd0b04 	addi	r3,r3,13356
   278a8:	10801224 	muli	r2,r2,72
   278ac:	1885883a 	add	r2,r3,r2
   278b0:	10800804 	addi	r2,r2,32
   278b4:	10000015 	stw	zero,0(r2)
   278b8:	00001806 	br	2791c <alt_tse_system_add_sys+0x638>
		}
		else {
			tse_mac_device[tse_system_count].ext_desc_mem	= pmem->ext_desc_mem;
   278bc:	d0a8dfc3 	ldbu	r2,-23681(gp)
   278c0:	10803fcc 	andi	r2,r2,255
   278c4:	1080201c 	xori	r2,r2,128
   278c8:	10bfe004 	addi	r2,r2,-128
   278cc:	e0fff817 	ldw	r3,-32(fp)
   278d0:	18c00003 	ldbu	r3,0(r3)
   278d4:	010000f4 	movhi	r4,3
   278d8:	210d0b04 	addi	r4,r4,13356
   278dc:	10801224 	muli	r2,r2,72
   278e0:	2085883a 	add	r2,r4,r2
   278e4:	10800704 	addi	r2,r2,28
   278e8:	10c00085 	stb	r3,2(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= pmem->desc_mem_base;
   278ec:	d0a8dfc3 	ldbu	r2,-23681(gp)
   278f0:	10803fcc 	andi	r2,r2,255
   278f4:	1080201c 	xori	r2,r2,128
   278f8:	10bfe004 	addi	r2,r2,-128
   278fc:	e0fff817 	ldw	r3,-32(fp)
   27900:	18c00117 	ldw	r3,4(r3)
   27904:	010000f4 	movhi	r4,3
   27908:	210d0b04 	addi	r4,r4,13356
   2790c:	10801224 	muli	r2,r2,72
   27910:	2085883a 	add	r2,r4,r2
   27914:	10800804 	addi	r2,r2,32
   27918:	10c00015 	stw	r3,0(r2)
		}
		
		/* Add shared fifo info to alt_tse_system_info structure */
		if(pfifo == 0) {
   2791c:	e0bff917 	ldw	r2,-28(fp)
   27920:	1000471e 	bne	r2,zero,27a40 <alt_tse_system_add_sys+0x75c>
			tse_mac_device[tse_system_count].use_shared_fifo                = TSE_NO_SHARED_FIFO;
   27924:	d0a8dfc3 	ldbu	r2,-23681(gp)
   27928:	10803fcc 	andi	r2,r2,255
   2792c:	1080201c 	xori	r2,r2,128
   27930:	10bfe004 	addi	r2,r2,-128
   27934:	00c000f4 	movhi	r3,3
   27938:	18cd0b04 	addi	r3,r3,13356
   2793c:	10801224 	muli	r2,r2,72
   27940:	1885883a 	add	r2,r3,r2
   27944:	10800904 	addi	r2,r2,36
   27948:	10000005 	stb	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= TSE_NO_SHARED_FIFO;
   2794c:	d0a8dfc3 	ldbu	r2,-23681(gp)
   27950:	10803fcc 	andi	r2,r2,255
   27954:	1080201c 	xori	r2,r2,128
   27958:	10bfe004 	addi	r2,r2,-128
   2795c:	00c000f4 	movhi	r3,3
   27960:	18cd0b04 	addi	r3,r3,13356
   27964:	10801224 	muli	r2,r2,72
   27968:	1885883a 	add	r2,r3,r2
   2796c:	10800a04 	addi	r2,r2,40
   27970:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= TSE_NO_SHARED_FIFO;
   27974:	d0a8dfc3 	ldbu	r2,-23681(gp)
   27978:	10803fcc 	andi	r2,r2,255
   2797c:	1080201c 	xori	r2,r2,128
   27980:	10bfe004 	addi	r2,r2,-128
   27984:	00c000f4 	movhi	r3,3
   27988:	18cd0b04 	addi	r3,r3,13356
   2798c:	10801224 	muli	r2,r2,72
   27990:	1885883a 	add	r2,r3,r2
   27994:	10800b04 	addi	r2,r2,44
   27998:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = TSE_NO_SHARED_FIFO;
   2799c:	d0a8dfc3 	ldbu	r2,-23681(gp)
   279a0:	10803fcc 	andi	r2,r2,255
   279a4:	1080201c 	xori	r2,r2,128
   279a8:	10bfe004 	addi	r2,r2,-128
   279ac:	00c000f4 	movhi	r3,3
   279b0:	18cd0b04 	addi	r3,r3,13356
   279b4:	10801224 	muli	r2,r2,72
   279b8:	1885883a 	add	r2,r3,r2
   279bc:	10800c04 	addi	r2,r2,48
   279c0:	10000015 	stw	zero,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= TSE_NO_SHARED_FIFO;
   279c4:	d0a8dfc3 	ldbu	r2,-23681(gp)
   279c8:	10803fcc 	andi	r2,r2,255
   279cc:	1080201c 	xori	r2,r2,128
   279d0:	10bfe004 	addi	r2,r2,-128
   279d4:	00c000f4 	movhi	r3,3
   279d8:	18cd0b04 	addi	r3,r3,13356
   279dc:	10801224 	muli	r2,r2,72
   279e0:	1885883a 	add	r2,r3,r2
   279e4:	10800d04 	addi	r2,r2,52
   279e8:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= TSE_NO_SHARED_FIFO;
   279ec:	d0a8dfc3 	ldbu	r2,-23681(gp)
   279f0:	10803fcc 	andi	r2,r2,255
   279f4:	1080201c 	xori	r2,r2,128
   279f8:	10bfe004 	addi	r2,r2,-128
   279fc:	00c000f4 	movhi	r3,3
   27a00:	18cd0b04 	addi	r3,r3,13356
   27a04:	10801224 	muli	r2,r2,72
   27a08:	1885883a 	add	r2,r3,r2
   27a0c:	10800e04 	addi	r2,r2,56
   27a10:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = TSE_NO_SHARED_FIFO;
   27a14:	d0a8dfc3 	ldbu	r2,-23681(gp)
   27a18:	10803fcc 	andi	r2,r2,255
   27a1c:	1080201c 	xori	r2,r2,128
   27a20:	10bfe004 	addi	r2,r2,-128
   27a24:	00c000f4 	movhi	r3,3
   27a28:	18cd0b04 	addi	r3,r3,13356
   27a2c:	10801224 	muli	r2,r2,72
   27a30:	1885883a 	add	r2,r3,r2
   27a34:	10800f04 	addi	r2,r2,60
   27a38:	10000015 	stw	zero,0(r2)
   27a3c:	00005406 	br	27b90 <alt_tse_system_add_sys+0x8ac>
		}
		else {
			tse_mac_device[tse_system_count].use_shared_fifo                = pfifo->use_shared_fifo;
   27a40:	d0a8dfc3 	ldbu	r2,-23681(gp)
   27a44:	10803fcc 	andi	r2,r2,255
   27a48:	1080201c 	xori	r2,r2,128
   27a4c:	10bfe004 	addi	r2,r2,-128
   27a50:	e0fff917 	ldw	r3,-28(fp)
   27a54:	18c00003 	ldbu	r3,0(r3)
   27a58:	010000f4 	movhi	r4,3
   27a5c:	210d0b04 	addi	r4,r4,13356
   27a60:	10801224 	muli	r2,r2,72
   27a64:	2085883a 	add	r2,r4,r2
   27a68:	10800904 	addi	r2,r2,36
   27a6c:	10c00005 	stb	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= pfifo->tse_shared_fifo_tx_ctrl_base;
   27a70:	d0a8dfc3 	ldbu	r2,-23681(gp)
   27a74:	10803fcc 	andi	r2,r2,255
   27a78:	1080201c 	xori	r2,r2,128
   27a7c:	10bfe004 	addi	r2,r2,-128
   27a80:	e0fff917 	ldw	r3,-28(fp)
   27a84:	18c00117 	ldw	r3,4(r3)
   27a88:	010000f4 	movhi	r4,3
   27a8c:	210d0b04 	addi	r4,r4,13356
   27a90:	10801224 	muli	r2,r2,72
   27a94:	2085883a 	add	r2,r4,r2
   27a98:	10800a04 	addi	r2,r2,40
   27a9c:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= pfifo->tse_shared_fifo_tx_stat_base;
   27aa0:	d0a8dfc3 	ldbu	r2,-23681(gp)
   27aa4:	10803fcc 	andi	r2,r2,255
   27aa8:	1080201c 	xori	r2,r2,128
   27aac:	10bfe004 	addi	r2,r2,-128
   27ab0:	e0fff917 	ldw	r3,-28(fp)
   27ab4:	18c00217 	ldw	r3,8(r3)
   27ab8:	010000f4 	movhi	r4,3
   27abc:	210d0b04 	addi	r4,r4,13356
   27ac0:	10801224 	muli	r2,r2,72
   27ac4:	2085883a 	add	r2,r4,r2
   27ac8:	10800b04 	addi	r2,r2,44
   27acc:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = pfifo->tse_shared_fifo_tx_depth;
   27ad0:	d0a8dfc3 	ldbu	r2,-23681(gp)
   27ad4:	10803fcc 	andi	r2,r2,255
   27ad8:	1080201c 	xori	r2,r2,128
   27adc:	10bfe004 	addi	r2,r2,-128
   27ae0:	e0fff917 	ldw	r3,-28(fp)
   27ae4:	18c00317 	ldw	r3,12(r3)
   27ae8:	010000f4 	movhi	r4,3
   27aec:	210d0b04 	addi	r4,r4,13356
   27af0:	10801224 	muli	r2,r2,72
   27af4:	2085883a 	add	r2,r4,r2
   27af8:	10800c04 	addi	r2,r2,48
   27afc:	10c00015 	stw	r3,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= pfifo->tse_shared_fifo_rx_ctrl_base;
   27b00:	d0a8dfc3 	ldbu	r2,-23681(gp)
   27b04:	10803fcc 	andi	r2,r2,255
   27b08:	1080201c 	xori	r2,r2,128
   27b0c:	10bfe004 	addi	r2,r2,-128
   27b10:	e0fff917 	ldw	r3,-28(fp)
   27b14:	18c00417 	ldw	r3,16(r3)
   27b18:	010000f4 	movhi	r4,3
   27b1c:	210d0b04 	addi	r4,r4,13356
   27b20:	10801224 	muli	r2,r2,72
   27b24:	2085883a 	add	r2,r4,r2
   27b28:	10800d04 	addi	r2,r2,52
   27b2c:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= pfifo->tse_shared_fifo_rx_stat_base;
   27b30:	d0a8dfc3 	ldbu	r2,-23681(gp)
   27b34:	10803fcc 	andi	r2,r2,255
   27b38:	1080201c 	xori	r2,r2,128
   27b3c:	10bfe004 	addi	r2,r2,-128
   27b40:	e0fff917 	ldw	r3,-28(fp)
   27b44:	18c00517 	ldw	r3,20(r3)
   27b48:	010000f4 	movhi	r4,3
   27b4c:	210d0b04 	addi	r4,r4,13356
   27b50:	10801224 	muli	r2,r2,72
   27b54:	2085883a 	add	r2,r4,r2
   27b58:	10800e04 	addi	r2,r2,56
   27b5c:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = pfifo->tse_shared_fifo_rx_depth;
   27b60:	d0a8dfc3 	ldbu	r2,-23681(gp)
   27b64:	10803fcc 	andi	r2,r2,255
   27b68:	1080201c 	xori	r2,r2,128
   27b6c:	10bfe004 	addi	r2,r2,-128
   27b70:	e0fff917 	ldw	r3,-28(fp)
   27b74:	18c00617 	ldw	r3,24(r3)
   27b78:	010000f4 	movhi	r4,3
   27b7c:	210d0b04 	addi	r4,r4,13356
   27b80:	10801224 	muli	r2,r2,72
   27b84:	2085883a 	add	r2,r4,r2
   27b88:	10800f04 	addi	r2,r2,60
   27b8c:	10c00015 	stw	r3,0(r2)
		}
		
		/* Add PHY info to alt_tse_system_info structure */
		if(pphy == 0) {
   27b90:	e0bffa17 	ldw	r2,-24(fp)
   27b94:	1000161e 	bne	r2,zero,27bf0 <alt_tse_system_add_sys+0x90c>
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= TSE_PHY_AUTO_ADDRESS;
   27b98:	d0a8dfc3 	ldbu	r2,-23681(gp)
   27b9c:	10803fcc 	andi	r2,r2,255
   27ba0:	1080201c 	xori	r2,r2,128
   27ba4:	10bfe004 	addi	r2,r2,-128
   27ba8:	00c000f4 	movhi	r3,3
   27bac:	18cd0b04 	addi	r3,r3,13356
   27bb0:	10801224 	muli	r2,r2,72
   27bb4:	1885883a 	add	r2,r3,r2
   27bb8:	10801004 	addi	r2,r2,64
   27bbc:	00ffffc4 	movi	r3,-1
   27bc0:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= 0;
   27bc4:	d0a8dfc3 	ldbu	r2,-23681(gp)
   27bc8:	10803fcc 	andi	r2,r2,255
   27bcc:	1080201c 	xori	r2,r2,128
   27bd0:	10bfe004 	addi	r2,r2,-128
   27bd4:	00c000f4 	movhi	r3,3
   27bd8:	18cd0b04 	addi	r3,r3,13356
   27bdc:	10801224 	muli	r2,r2,72
   27be0:	1885883a 	add	r2,r3,r2
   27be4:	10801104 	addi	r2,r2,68
   27be8:	10000015 	stw	zero,0(r2)
   27bec:	00001806 	br	27c50 <alt_tse_system_add_sys+0x96c>
		}
		else {
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= pphy->tse_phy_mdio_address;
   27bf0:	d0a8dfc3 	ldbu	r2,-23681(gp)
   27bf4:	10803fcc 	andi	r2,r2,255
   27bf8:	1080201c 	xori	r2,r2,128
   27bfc:	10bfe004 	addi	r2,r2,-128
   27c00:	e0fffa17 	ldw	r3,-24(fp)
   27c04:	18c00017 	ldw	r3,0(r3)
   27c08:	010000f4 	movhi	r4,3
   27c0c:	210d0b04 	addi	r4,r4,13356
   27c10:	10801224 	muli	r2,r2,72
   27c14:	2085883a 	add	r2,r4,r2
   27c18:	10801004 	addi	r2,r2,64
   27c1c:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= pphy->tse_phy_cfg;
   27c20:	d0a8dfc3 	ldbu	r2,-23681(gp)
   27c24:	10803fcc 	andi	r2,r2,255
   27c28:	1080201c 	xori	r2,r2,128
   27c2c:	10bfe004 	addi	r2,r2,-128
   27c30:	e0fffa17 	ldw	r3,-24(fp)
   27c34:	18c00117 	ldw	r3,4(r3)
   27c38:	010000f4 	movhi	r4,3
   27c3c:	210d0b04 	addi	r4,r4,13356
   27c40:	10801224 	muli	r2,r2,72
   27c44:	2085883a 	add	r2,r4,r2
   27c48:	10801104 	addi	r2,r2,68
   27c4c:	10c00015 	stw	r3,0(r2)
		}
		
		/* Point to next structure */
		psgdma++;
   27c50:	e0bff717 	ldw	r2,-36(fp)
   27c54:	10800304 	addi	r2,r2,12
   27c58:	e0bff715 	stw	r2,-36(fp)
		if(pmem) pmem++;
   27c5c:	e0bff817 	ldw	r2,-32(fp)
   27c60:	10000326 	beq	r2,zero,27c70 <alt_tse_system_add_sys+0x98c>
   27c64:	e0bff817 	ldw	r2,-32(fp)
   27c68:	10800204 	addi	r2,r2,8
   27c6c:	e0bff815 	stw	r2,-32(fp)
		if(pfifo) pfifo++;
   27c70:	e0bff917 	ldw	r2,-28(fp)
   27c74:	10000326 	beq	r2,zero,27c84 <alt_tse_system_add_sys+0x9a0>
   27c78:	e0bff917 	ldw	r2,-28(fp)
   27c7c:	10800704 	addi	r2,r2,28
   27c80:	e0bff915 	stw	r2,-28(fp)
		if(pphy) pphy++;
   27c84:	e0bffa17 	ldw	r2,-24(fp)
   27c88:	10000326 	beq	r2,zero,27c98 <alt_tse_system_add_sys+0x9b4>
   27c8c:	e0bffa17 	ldw	r2,-24(fp)
   27c90:	10800204 	addi	r2,r2,8
   27c94:	e0bffa15 	stw	r2,-24(fp)
		
		tse_system_count++;
   27c98:	d0a8dfc3 	ldbu	r2,-23681(gp)
   27c9c:	10800044 	addi	r2,r2,1
   27ca0:	d0a8dfc5 	stb	r2,-23681(gp)
		max_mac_system = tse_system_count;
   27ca4:	d0a8dfc3 	ldbu	r2,-23681(gp)
   27ca8:	d0a01d05 	stb	r2,-32652(gp)
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
	}

	for(i = 0; i < loop_end; i++) {
   27cac:	e0bff517 	ldw	r2,-44(fp)
   27cb0:	10800044 	addi	r2,r2,1
   27cb4:	e0bff515 	stw	r2,-44(fp)
   27cb8:	e0fff517 	ldw	r3,-44(fp)
   27cbc:	e0bff617 	ldw	r2,-40(fp)
   27cc0:	18bdb216 	blt	r3,r2,2738c <alt_tse_system_add_sys+0xa8>
		
		tse_system_count++;
		max_mac_system = tse_system_count;
	}
	
	return SUCCESS;
   27cc4:	0005883a 	mov	r2,zero
	
}
   27cc8:	e037883a 	mov	sp,fp
   27ccc:	dfc00217 	ldw	ra,8(sp)
   27cd0:	df000117 	ldw	fp,4(sp)
   27cd4:	dc000017 	ldw	r16,0(sp)
   27cd8:	dec00304 	addi	sp,sp,12
   27cdc:	f800283a 	ret

00027ce0 <alt_tse_sys_enable_mdio_sharing>:
 * @param		number_of_mac  number of MAC sharing MDIO block
 * @return      SUCCESS on success
 * 				ALTERA_TSE_SYSTEM_DEF_ERROR if definition of system incorrect or pointer == NULL
 * Multi-channel MAC not supported
 */
alt_32 alt_tse_sys_enable_mdio_sharing(alt_tse_system_mac **psys_mac_list, alt_u8 number_of_mac) {
   27ce0:	defff904 	addi	sp,sp,-28
   27ce4:	dfc00615 	stw	ra,24(sp)
   27ce8:	df000515 	stw	fp,20(sp)
   27cec:	df000504 	addi	fp,sp,20
   27cf0:	e13ffe15 	stw	r4,-8(fp)
   27cf4:	2805883a 	mov	r2,r5
   27cf8:	e0bfff05 	stb	r2,-4(fp)
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
   27cfc:	e03ffb15 	stw	zero,-20(fp)
   27d00:	00004706 	br	27e20 <alt_tse_sys_enable_mdio_sharing+0x140>
		psys_mac = psys_mac_list[i];
   27d04:	e0bffb17 	ldw	r2,-20(fp)
   27d08:	1085883a 	add	r2,r2,r2
   27d0c:	1085883a 	add	r2,r2,r2
   27d10:	e0fffe17 	ldw	r3,-8(fp)
   27d14:	1885883a 	add	r2,r3,r2
   27d18:	10800017 	ldw	r2,0(r2)
   27d1c:	e0bffd15 	stw	r2,-12(fp)
		
		if(psys_mac == 0) {
   27d20:	e0bffd17 	ldw	r2,-12(fp)
   27d24:	1000081e 	bne	r2,zero,27d48 <alt_tse_sys_enable_mdio_sharing+0x68>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
   27d28:	010000f4 	movhi	r4,3
   27d2c:	2105dd04 	addi	r4,r4,6004
   27d30:	001965c0 	call	1965c <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
   27d34:	010000f4 	movhi	r4,3
   27d38:	21064204 	addi	r4,r4,6408
   27d3c:	001965c0 	call	1965c <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
   27d40:	00bfffc4 	movi	r2,-1
   27d44:	00003a06 	br	27e30 <alt_tse_sys_enable_mdio_sharing+0x150>
		}
		
		for(j = 0; j < max_mac_system; j++) {
   27d48:	e03ffc15 	stw	zero,-16(fp)
   27d4c:	00002d06 	br	27e04 <alt_tse_sys_enable_mdio_sharing+0x124>
			
			if(psys_mac->tse_mac_base == tse_mac_device[j].tse_mac_base) {
   27d50:	e0bffd17 	ldw	r2,-12(fp)
   27d54:	10c00017 	ldw	r3,0(r2)
   27d58:	010000f4 	movhi	r4,3
   27d5c:	210d0b04 	addi	r4,r4,13356
   27d60:	e0bffc17 	ldw	r2,-16(fp)
   27d64:	10801224 	muli	r2,r2,72
   27d68:	2085883a 	add	r2,r4,r2
   27d6c:	10800017 	ldw	r2,0(r2)
   27d70:	1880211e 	bne	r3,r2,27df8 <alt_tse_sys_enable_mdio_sharing+0x118>
				if(tse_mac_device[j].tse_multichannel_mac) {
   27d74:	00c000f4 	movhi	r3,3
   27d78:	18cd0b04 	addi	r3,r3,13356
   27d7c:	e0bffc17 	ldw	r2,-16(fp)
   27d80:	10801224 	muli	r2,r2,72
   27d84:	1885883a 	add	r2,r3,r2
   27d88:	10800204 	addi	r2,r2,8
   27d8c:	108000c3 	ldbu	r2,3(r2)
   27d90:	10803fcc 	andi	r2,r2,255
   27d94:	10000826 	beq	r2,zero,27db8 <alt_tse_sys_enable_mdio_sharing+0xd8>
					tse_dprintf(2, "ERROR   : MDIO sharing supported by default for Multi-channel MAC\n");
   27d98:	010000f4 	movhi	r4,3
   27d9c:	21065604 	addi	r4,r4,6488
   27da0:	001965c0 	call	1965c <puts>
					tse_dprintf(2, "ERROR   : Do not include Multi-channel MAC in the MAC List\n");
   27da4:	010000f4 	movhi	r4,3
   27da8:	21066704 	addi	r4,r4,6556
   27dac:	001965c0 	call	1965c <puts>
					return ALTERA_TSE_SYSTEM_DEF_ERROR;
   27db0:	00bfffc4 	movi	r2,-1
   27db4:	00001e06 	br	27e30 <alt_tse_sys_enable_mdio_sharing+0x150>
				}
				
				tse_mac_device[j].tse_mdio_shared = 1;
   27db8:	00c000f4 	movhi	r3,3
   27dbc:	18cd0b04 	addi	r3,r3,13356
   27dc0:	e0bffc17 	ldw	r2,-16(fp)
   27dc4:	10801224 	muli	r2,r2,72
   27dc8:	1885883a 	add	r2,r3,r2
   27dcc:	10800304 	addi	r2,r2,12
   27dd0:	00c00044 	movi	r3,1
   27dd4:	10c00045 	stb	r3,1(r2)
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
   27dd8:	00c000f4 	movhi	r3,3
   27ddc:	18cd0b04 	addi	r3,r3,13356
   27de0:	e0bffc17 	ldw	r2,-16(fp)
   27de4:	10801224 	muli	r2,r2,72
   27de8:	1885883a 	add	r2,r3,r2
   27dec:	10800304 	addi	r2,r2,12
   27df0:	e0ffff03 	ldbu	r3,-4(fp)
   27df4:	10c00085 	stb	r3,2(r2)
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
		}
		
		for(j = 0; j < max_mac_system; j++) {
   27df8:	e0bffc17 	ldw	r2,-16(fp)
   27dfc:	10800044 	addi	r2,r2,1
   27e00:	e0bffc15 	stw	r2,-16(fp)
   27e04:	d0a01d03 	ldbu	r2,-32652(gp)
   27e08:	10803fcc 	andi	r2,r2,255
   27e0c:	e0fffc17 	ldw	r3,-16(fp)
   27e10:	18bfcf16 	blt	r3,r2,27d50 <alt_tse_sys_enable_mdio_sharing+0x70>
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
   27e14:	e0bffb17 	ldw	r2,-20(fp)
   27e18:	10800044 	addi	r2,r2,1
   27e1c:	e0bffb15 	stw	r2,-20(fp)
   27e20:	e0bfff03 	ldbu	r2,-4(fp)
   27e24:	e0fffb17 	ldw	r3,-20(fp)
   27e28:	18bfb616 	blt	r3,r2,27d04 <alt_tse_sys_enable_mdio_sharing+0x24>
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
			}
		}	
	}
	
	return SUCCESS;
   27e2c:	0005883a 	mov	r2,zero
}
   27e30:	e037883a 	mov	sp,fp
   27e34:	dfc00117 	ldw	ra,4(sp)
   27e38:	df000017 	ldw	fp,0(sp)
   27e3c:	dec00204 	addi	sp,sp,8
   27e40:	f800283a 	ret

00027e44 <alt_tse_mac_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Public
 * @param pmac          Pointer to the TSE MAC Control Interface Base address
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_mac_get_common_speed(np_tse_mac *pmac) {
   27e44:	defffc04 	addi	sp,sp,-16
   27e48:	dfc00315 	stw	ra,12(sp)
   27e4c:	df000215 	stw	fp,8(sp)
   27e50:	df000204 	addi	fp,sp,8
   27e54:	e13fff15 	stw	r4,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
   27e58:	e13fff17 	ldw	r4,-4(fp)
   27e5c:	002802c0 	call	2802c <alt_tse_get_mac_info>
   27e60:	10800317 	ldw	r2,12(r2)
   27e64:	e0bffe15 	stw	r2,-8(fp)
    return alt_tse_phy_get_common_speed(pmac_group);
   27e68:	e13ffe17 	ldw	r4,-8(fp)
   27e6c:	002b1c40 	call	2b1c4 <alt_tse_phy_get_common_speed>
}
   27e70:	e037883a 	mov	sp,fp
   27e74:	dfc00117 	ldw	ra,4(sp)
   27e78:	df000017 	ldw	fp,0(sp)
   27e7c:	dec00204 	addi	sp,sp,8
   27e80:	f800283a 	ret

00027e84 <alt_tse_mac_set_common_speed>:
 * @API Type:               Public
 * @param pmac              Pointer to the TSE MAC Control Interface Base address
 *        common_speed      common speed supported by all PHYs
 * @return                  common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_mac_set_common_speed(np_tse_mac *pmac, alt_32 common_speed) {
   27e84:	defffb04 	addi	sp,sp,-20
   27e88:	dfc00415 	stw	ra,16(sp)
   27e8c:	df000315 	stw	fp,12(sp)
   27e90:	df000304 	addi	fp,sp,12
   27e94:	e13ffe15 	stw	r4,-8(fp)
   27e98:	e17fff15 	stw	r5,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
   27e9c:	e13ffe17 	ldw	r4,-8(fp)
   27ea0:	002802c0 	call	2802c <alt_tse_get_mac_info>
   27ea4:	10800317 	ldw	r2,12(r2)
   27ea8:	e0bffd15 	stw	r2,-12(fp)
    return alt_tse_phy_set_common_speed(pmac_group, common_speed);
   27eac:	e13ffd17 	ldw	r4,-12(fp)
   27eb0:	e17fff17 	ldw	r5,-4(fp)
   27eb4:	002b4ec0 	call	2b4ec <alt_tse_phy_set_common_speed>
}
   27eb8:	e037883a 	mov	sp,fp
   27ebc:	dfc00117 	ldw	ra,4(sp)
   27ec0:	df000017 	ldw	fp,0(sp)
   27ec4:	dec00204 	addi	sp,sp,8
   27ec8:	f800283a 	ret

00027ecc <alt_tse_get_system_index>:
/* @Function Description: Get the index of alt_tse_system_info structure in tse_mac_device[]
 * @API Type:        Internal
 * @param psys_info  Pointer to the alt_tse_system_info structure
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
   27ecc:	defffd04 	addi	sp,sp,-12
   27ed0:	df000215 	stw	fp,8(sp)
   27ed4:	df000204 	addi	fp,sp,8
   27ed8:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
   27edc:	e03ffe15 	stw	zero,-8(fp)
   27ee0:	00000c06 	br	27f14 <alt_tse_get_system_index+0x48>
        if(psys_info == &tse_mac_device[i]) {
   27ee4:	e0bffe17 	ldw	r2,-8(fp)
   27ee8:	10c01224 	muli	r3,r2,72
   27eec:	008000f4 	movhi	r2,3
   27ef0:	108d0b04 	addi	r2,r2,13356
   27ef4:	1887883a 	add	r3,r3,r2
   27ef8:	e0bfff17 	ldw	r2,-4(fp)
   27efc:	1880021e 	bne	r3,r2,27f08 <alt_tse_get_system_index+0x3c>
            return i;
   27f00:	e0bffe17 	ldw	r2,-8(fp)
   27f04:	00000806 	br	27f28 <alt_tse_get_system_index+0x5c>
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
   27f08:	e0bffe17 	ldw	r2,-8(fp)
   27f0c:	10800044 	addi	r2,r2,1
   27f10:	e0bffe15 	stw	r2,-8(fp)
   27f14:	d0a01d03 	ldbu	r2,-32652(gp)
   27f18:	10803fcc 	andi	r2,r2,255
   27f1c:	e0fffe17 	ldw	r3,-8(fp)
   27f20:	18bff016 	blt	r3,r2,27ee4 <alt_tse_get_system_index+0x18>
        if(psys_info == &tse_mac_device[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
   27f24:	00bfffc4 	movi	r2,-1
}
   27f28:	e037883a 	mov	sp,fp
   27f2c:	df000017 	ldw	fp,0(sp)
   27f30:	dec00104 	addi	sp,sp,4
   27f34:	f800283a 	ret

00027f38 <alt_tse_get_mac_group_index>:
/* @Function Description: Get the index of alt_tse_mac_group structure in pmac_groups[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_group structure
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
   27f38:	defffd04 	addi	sp,sp,-12
   27f3c:	df000215 	stw	fp,8(sp)
   27f40:	df000204 	addi	fp,sp,8
   27f44:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   27f48:	e03ffe15 	stw	zero,-8(fp)
   27f4c:	00000e06 	br	27f88 <alt_tse_get_mac_group_index+0x50>
        if(pmac_group == pmac_groups[i]) {
   27f50:	00c00234 	movhi	r3,8
   27f54:	18c41204 	addi	r3,r3,4168
   27f58:	e0bffe17 	ldw	r2,-8(fp)
   27f5c:	1085883a 	add	r2,r2,r2
   27f60:	1085883a 	add	r2,r2,r2
   27f64:	1885883a 	add	r2,r3,r2
   27f68:	10c00017 	ldw	r3,0(r2)
   27f6c:	e0bfff17 	ldw	r2,-4(fp)
   27f70:	1880021e 	bne	r3,r2,27f7c <alt_tse_get_mac_group_index+0x44>
            return i;
   27f74:	e0bffe17 	ldw	r2,-8(fp)
   27f78:	00000806 	br	27f9c <alt_tse_get_mac_group_index+0x64>
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   27f7c:	e0bffe17 	ldw	r2,-8(fp)
   27f80:	10800044 	addi	r2,r2,1
   27f84:	e0bffe15 	stw	r2,-8(fp)
   27f88:	d0a8df43 	ldbu	r2,-23683(gp)
   27f8c:	10803fcc 	andi	r2,r2,255
   27f90:	e0fffe17 	ldw	r3,-8(fp)
   27f94:	18bfee16 	blt	r3,r2,27f50 <alt_tse_get_mac_group_index+0x18>
        if(pmac_group == pmac_groups[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
   27f98:	00bfffc4 	movi	r2,-1
}
   27f9c:	e037883a 	mov	sp,fp
   27fa0:	df000017 	ldw	fp,0(sp)
   27fa4:	dec00104 	addi	sp,sp,4
   27fa8:	f800283a 	ret

00027fac <alt_tse_get_mac_info_index>:
/* @Function Description: Get the index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_info structure
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
   27fac:	defffd04 	addi	sp,sp,-12
   27fb0:	df000215 	stw	fp,8(sp)
   27fb4:	df000204 	addi	fp,sp,8
   27fb8:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   27fbc:	e03ffe15 	stw	zero,-8(fp)
   27fc0:	00000f06 	br	28000 <alt_tse_get_mac_info_index+0x54>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   27fc4:	e0bfff17 	ldw	r2,-4(fp)
   27fc8:	10c00317 	ldw	r3,12(r2)
   27fcc:	e0bffe17 	ldw	r2,-8(fp)
   27fd0:	10800044 	addi	r2,r2,1
   27fd4:	1085883a 	add	r2,r2,r2
   27fd8:	1085883a 	add	r2,r2,r2
   27fdc:	1885883a 	add	r2,r3,r2
   27fe0:	10c00017 	ldw	r3,0(r2)
   27fe4:	e0bfff17 	ldw	r2,-4(fp)
   27fe8:	1880021e 	bne	r3,r2,27ff4 <alt_tse_get_mac_info_index+0x48>
            return i;
   27fec:	e0bffe17 	ldw	r2,-8(fp)
   27ff0:	00000a06 	br	2801c <alt_tse_get_mac_info_index+0x70>
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   27ff4:	e0bffe17 	ldw	r2,-8(fp)
   27ff8:	10800044 	addi	r2,r2,1
   27ffc:	e0bffe15 	stw	r2,-8(fp)
   28000:	e0bfff17 	ldw	r2,-4(fp)
   28004:	10800317 	ldw	r2,12(r2)
   28008:	10800003 	ldbu	r2,0(r2)
   2800c:	10803fcc 	andi	r2,r2,255
   28010:	e0fffe17 	ldw	r3,-8(fp)
   28014:	18bfeb16 	blt	r3,r2,27fc4 <alt_tse_get_mac_info_index+0x18>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
            return i;
        }
    }
    
    return ALTERA_TSE_NO_INDEX_FOUND;
   28018:	00bfffc4 	movi	r2,-1
}
   2801c:	e037883a 	mov	sp,fp
   28020:	df000017 	ldw	fp,0(sp)
   28024:	dec00104 	addi	sp,sp,4
   28028:	f800283a 	ret

0002802c <alt_tse_get_mac_info>:
/* @Function Description: Get the pointer of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac        Pointer to the TSE MAC Control Interface Base address
 * @return            Pointer to alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_tse_mac_info *alt_tse_get_mac_info(np_tse_mac *pmac) {
   2802c:	defffa04 	addi	sp,sp,-24
   28030:	df000515 	stw	fp,20(sp)
   28034:	df000504 	addi	fp,sp,20
   28038:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
   2803c:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_mac_info *pmac_info = 0;
   28040:	e03ffe15 	stw	zero,-8(fp)
    
    for(i = 0; i < mac_group_count; i++) {
   28044:	e03ffb15 	stw	zero,-20(fp)
   28048:	00002506 	br	280e0 <alt_tse_get_mac_info+0xb4>
        pmac_group = pmac_groups[i];
   2804c:	00c00234 	movhi	r3,8
   28050:	18c41204 	addi	r3,r3,4168
   28054:	e0bffb17 	ldw	r2,-20(fp)
   28058:	1085883a 	add	r2,r2,r2
   2805c:	1085883a 	add	r2,r2,r2
   28060:	1885883a 	add	r2,r3,r2
   28064:	10800017 	ldw	r2,0(r2)
   28068:	e0bffd15 	stw	r2,-12(fp)
        for(j = 0; j < pmac_group->channel; j++) {
   2806c:	e03ffc15 	stw	zero,-16(fp)
   28070:	00001306 	br	280c0 <alt_tse_get_mac_info+0x94>
            pmac_info = pmac_group->pmac_info[j];
   28074:	e0fffd17 	ldw	r3,-12(fp)
   28078:	e0bffc17 	ldw	r2,-16(fp)
   2807c:	10800044 	addi	r2,r2,1
   28080:	1085883a 	add	r2,r2,r2
   28084:	1085883a 	add	r2,r2,r2
   28088:	1885883a 	add	r2,r3,r2
   2808c:	10800017 	ldw	r2,0(r2)
   28090:	e0bffe15 	stw	r2,-8(fp)
            if(((np_tse_mac *) pmac_info->psys_info->tse_mac_base) == pmac) {
   28094:	e0bffe17 	ldw	r2,-8(fp)
   28098:	10800217 	ldw	r2,8(r2)
   2809c:	10800017 	ldw	r2,0(r2)
   280a0:	1007883a 	mov	r3,r2
   280a4:	e0bfff17 	ldw	r2,-4(fp)
   280a8:	1880021e 	bne	r3,r2,280b4 <alt_tse_get_mac_info+0x88>
                return pmac_info;
   280ac:	e0bffe17 	ldw	r2,-8(fp)
   280b0:	00001006 	br	280f4 <alt_tse_get_mac_info+0xc8>
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
        pmac_group = pmac_groups[i];
        for(j = 0; j < pmac_group->channel; j++) {
   280b4:	e0bffc17 	ldw	r2,-16(fp)
   280b8:	10800044 	addi	r2,r2,1
   280bc:	e0bffc15 	stw	r2,-16(fp)
   280c0:	e0bffd17 	ldw	r2,-12(fp)
   280c4:	10800003 	ldbu	r2,0(r2)
   280c8:	10803fcc 	andi	r2,r2,255
   280cc:	e0fffc17 	ldw	r3,-16(fp)
   280d0:	18bfe816 	blt	r3,r2,28074 <alt_tse_get_mac_info+0x48>
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
   280d4:	e0bffb17 	ldw	r2,-20(fp)
   280d8:	10800044 	addi	r2,r2,1
   280dc:	e0bffb15 	stw	r2,-20(fp)
   280e0:	d0a8df43 	ldbu	r2,-23683(gp)
   280e4:	10803fcc 	andi	r2,r2,255
   280e8:	e0fffb17 	ldw	r3,-20(fp)
   280ec:	18bfd716 	blt	r3,r2,2804c <alt_tse_get_mac_info+0x20>
                return pmac_info;
            }
        }        
    }
    
    return 0;
   280f0:	0005883a 	mov	r2,zero
}
   280f4:	e037883a 	mov	sp,fp
   280f8:	df000017 	ldw	fp,0(sp)
   280fc:	dec00104 	addi	sp,sp,4
   28100:	f800283a 	ret

00028104 <alt_tse_mac_set_speed>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param speed 2 = 1000 Mbps, 1 = 100 Mbps, 0 = 10 Mbps
 * @return ENP_PARAM if invalid speed specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_speed(np_tse_mac *pmac, alt_u8 speed)
{
   28104:	defffc04 	addi	sp,sp,-16
   28108:	df000315 	stw	fp,12(sp)
   2810c:	df000304 	addi	fp,sp,12
   28110:	e13ffe15 	stw	r4,-8(fp)
   28114:	2805883a 	mov	r2,r5
   28118:	e0bfff05 	stb	r2,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
   2811c:	e0bffe17 	ldw	r2,-8(fp)
   28120:	10800204 	addi	r2,r2,8
   28124:	10800037 	ldwio	r2,0(r2)
   28128:	e0bffd15 	stw	r2,-12(fp)
  
  /* 1000 Mbps */
  if(speed == TSE_PHY_SPEED_1000) {
   2812c:	e0bfff03 	ldbu	r2,-4(fp)
   28130:	10800098 	cmpnei	r2,r2,2
   28134:	1000091e 	bne	r2,zero,2815c <alt_tse_mac_set_speed+0x58>
    helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
   28138:	e0bffd17 	ldw	r2,-12(fp)
   2813c:	10800214 	ori	r2,r2,8
   28140:	e0bffd15 	stw	r2,-12(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
   28144:	e0fffd17 	ldw	r3,-12(fp)
   28148:	00bf8034 	movhi	r2,65024
   2814c:	10bfffc4 	addi	r2,r2,-1
   28150:	1884703a 	and	r2,r3,r2
   28154:	e0bffd15 	stw	r2,-12(fp)
   28158:	00001906 	br	281c0 <alt_tse_mac_set_speed+0xbc>
  }
  /* 100 Mbps */
  else if(speed == TSE_PHY_SPEED_100) {
   2815c:	e0bfff03 	ldbu	r2,-4(fp)
   28160:	10800058 	cmpnei	r2,r2,1
   28164:	10000a1e 	bne	r2,zero,28190 <alt_tse_mac_set_speed+0x8c>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
   28168:	e0fffd17 	ldw	r3,-12(fp)
   2816c:	00bffdc4 	movi	r2,-9
   28170:	1884703a 	and	r2,r3,r2
   28174:	e0bffd15 	stw	r2,-12(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
   28178:	e0fffd17 	ldw	r3,-12(fp)
   2817c:	00bf8034 	movhi	r2,65024
   28180:	10bfffc4 	addi	r2,r2,-1
   28184:	1884703a 	and	r2,r3,r2
   28188:	e0bffd15 	stw	r2,-12(fp)
   2818c:	00000c06 	br	281c0 <alt_tse_mac_set_speed+0xbc>
  }
  /* 10 Mbps */
  else if(speed == TSE_PHY_SPEED_10) {
   28190:	e0bfff03 	ldbu	r2,-4(fp)
   28194:	1000081e 	bne	r2,zero,281b8 <alt_tse_mac_set_speed+0xb4>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
   28198:	e0fffd17 	ldw	r3,-12(fp)
   2819c:	00bffdc4 	movi	r2,-9
   281a0:	1884703a 	and	r2,r3,r2
   281a4:	e0bffd15 	stw	r2,-12(fp)
	helpvar |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
   281a8:	e0bffd17 	ldw	r2,-12(fp)
   281ac:	10808034 	orhi	r2,r2,512
   281b0:	e0bffd15 	stw	r2,-12(fp)
   281b4:	00000206 	br	281c0 <alt_tse_mac_set_speed+0xbc>
  }  
  else {
    return ENP_PARAM;
   281b8:	00bffd84 	movi	r2,-10
   281bc:	00000506 	br	281d4 <alt_tse_mac_set_speed+0xd0>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
   281c0:	e0bffe17 	ldw	r2,-8(fp)
   281c4:	10800204 	addi	r2,r2,8
   281c8:	e0fffd17 	ldw	r3,-12(fp)
   281cc:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
   281d0:	0005883a 	mov	r2,zero
}
   281d4:	e037883a 	mov	sp,fp
   281d8:	df000017 	ldw	fp,0(sp)
   281dc:	dec00104 	addi	sp,sp,4
   281e0:	f800283a 	ret

000281e4 <alt_tse_mac_set_duplex>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param duplex 1 = Full Duplex, 0 = Half Duplex
 * @return ENP_PARAM if invalid duplex specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_duplex(np_tse_mac *pmac, alt_u8 duplex)
{
   281e4:	defffc04 	addi	sp,sp,-16
   281e8:	df000315 	stw	fp,12(sp)
   281ec:	df000304 	addi	fp,sp,12
   281f0:	e13ffe15 	stw	r4,-8(fp)
   281f4:	2805883a 	mov	r2,r5
   281f8:	e0bfff05 	stb	r2,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
   281fc:	e0bffe17 	ldw	r2,-8(fp)
   28200:	10800204 	addi	r2,r2,8
   28204:	10800037 	ldwio	r2,0(r2)
   28208:	e0bffd15 	stw	r2,-12(fp)
  
  /* Half Duplex */
  if(duplex == TSE_PHY_DUPLEX_HALF) {
   2820c:	e0bfff03 	ldbu	r2,-4(fp)
   28210:	1000041e 	bne	r2,zero,28224 <alt_tse_mac_set_duplex+0x40>
    helpvar |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
   28214:	e0bffd17 	ldw	r2,-12(fp)
   28218:	10810014 	ori	r2,r2,1024
   2821c:	e0bffd15 	stw	r2,-12(fp)
   28220:	00000a06 	br	2824c <alt_tse_mac_set_duplex+0x68>
  } 
  /* Full Duplex */
  else if(duplex == TSE_PHY_DUPLEX_FULL) {
   28224:	e0bfff03 	ldbu	r2,-4(fp)
   28228:	10800058 	cmpnei	r2,r2,1
   2822c:	1000051e 	bne	r2,zero,28244 <alt_tse_mac_set_duplex+0x60>
    helpvar &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
   28230:	e0fffd17 	ldw	r3,-12(fp)
   28234:	00beffc4 	movi	r2,-1025
   28238:	1884703a 	and	r2,r3,r2
   2823c:	e0bffd15 	stw	r2,-12(fp)
   28240:	00000206 	br	2824c <alt_tse_mac_set_duplex+0x68>
  }
  else {
    return ENP_PARAM;
   28244:	00bffd84 	movi	r2,-10
   28248:	00000506 	br	28260 <alt_tse_mac_set_duplex+0x7c>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
   2824c:	e0bffe17 	ldw	r2,-8(fp)
   28250:	10800204 	addi	r2,r2,8
   28254:	e0fffd17 	ldw	r3,-12(fp)
   28258:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
   2825c:	0005883a 	mov	r2,zero

}
   28260:	e037883a 	mov	sp,fp
   28264:	df000017 	ldw	fp,0(sp)
   28268:	dec00104 	addi	sp,sp,4
   2826c:	f800283a 	ret

00028270 <getPHYSpeed>:
  	(((speed == TSE_PHY_SPEED_1000) ? 1 : 0) << 1) |   \
	(((speed == TSE_PHY_SPEED_100) ? 1 : 0) << 2) |     \
	(((speed == TSE_PHY_SPEED_10) ? 1 : 0) << 3) |      \
	((speed == TSE_PHY_SPEED_INVALID) ? ALT_TSE_E_INVALID_SPEED : 0))
  
alt_32 getPHYSpeed(np_tse_mac *pmac) {
   28270:	defff404 	addi	sp,sp,-48
   28274:	dfc00b15 	stw	ra,44(sp)
   28278:	df000a15 	stw	fp,40(sp)
   2827c:	df000a04 	addi	fp,sp,40
   28280:	e13fff15 	stw	r4,-4(fp)

	alt_u8 speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
   28284:	00800044 	movi	r2,1
   28288:	e0bff705 	stb	r2,-36(fp)
	alt_u8 duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;     /* 1 = full ; 0 = half*/
   2828c:	00800044 	movi	r2,1
   28290:	e0bff745 	stb	r2,-35(fp)
	alt_32 result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
   28294:	e0bff743 	ldbu	r2,-35(fp)
   28298:	10c0004c 	andi	r3,r2,1
   2829c:	e0bff703 	ldbu	r2,-36(fp)
   282a0:	10800098 	cmpnei	r2,r2,2
   282a4:	1000021e 	bne	r2,zero,282b0 <getPHYSpeed+0x40>
   282a8:	00800084 	movi	r2,2
   282ac:	00000106 	br	282b4 <getPHYSpeed+0x44>
   282b0:	0005883a 	mov	r2,zero
   282b4:	1886b03a 	or	r3,r3,r2
   282b8:	e0bff703 	ldbu	r2,-36(fp)
   282bc:	10800058 	cmpnei	r2,r2,1
   282c0:	1000021e 	bne	r2,zero,282cc <getPHYSpeed+0x5c>
   282c4:	00800104 	movi	r2,4
   282c8:	00000106 	br	282d0 <getPHYSpeed+0x60>
   282cc:	0005883a 	mov	r2,zero
   282d0:	1886b03a 	or	r3,r3,r2
   282d4:	e0bff703 	ldbu	r2,-36(fp)
   282d8:	1000021e 	bne	r2,zero,282e4 <getPHYSpeed+0x74>
   282dc:	00800204 	movi	r2,8
   282e0:	00000106 	br	282e8 <getPHYSpeed+0x78>
   282e4:	0005883a 	mov	r2,zero
   282e8:	1886b03a 	or	r3,r3,r2
   282ec:	e0bff703 	ldbu	r2,-36(fp)
   282f0:	108000d8 	cmpnei	r2,r2,3
   282f4:	1000021e 	bne	r2,zero,28300 <getPHYSpeed+0x90>
   282f8:	00800074 	movhi	r2,1
   282fc:	00000106 	br	28304 <getPHYSpeed+0x94>
   28300:	0005883a 	mov	r2,zero
   28304:	1884b03a 	or	r2,r3,r2
   28308:	e0bff815 	stw	r2,-32(fp)
    
    alt_tse_phy_info *pphy = 0;
   2830c:	e03ff915 	stw	zero,-28(fp)
    alt_tse_mac_info *pmac_info = 0;
   28310:	e03ffa15 	stw	zero,-24(fp)
    alt_tse_mac_group *pmac_group = 0;
   28314:	e03ffb15 	stw	zero,-20(fp)
    alt_tse_system_info *psys = 0;
   28318:	e03ffc15 	stw	zero,-16(fp)
    
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
   2831c:	e03ffd05 	stb	zero,-12(fp)
    alt_8 mac_group_index = 0;
   28320:	e03ffd45 	stb	zero,-11(fp)
    
    /* initialized PHYs only once */
    static alt_u8 is_init = 0;
    if(is_init == 0) {
   28324:	d0a8df83 	ldbu	r2,-23682(gp)
   28328:	10803fcc 	andi	r2,r2,255
   2832c:	1000031e 	bne	r2,zero,2833c <getPHYSpeed+0xcc>
        alt_tse_phy_init();
   28330:	002a2440 	call	2a244 <alt_tse_phy_init>
        is_init = 1;
   28334:	00800044 	movi	r2,1
   28338:	d0a8df85 	stb	r2,-23682(gp)
    }
    
    /* Look for pmac_group and pmac_info structure based on pmac or iface */
    pmac_info = alt_tse_get_mac_info(pmac);
   2833c:	e13fff17 	ldw	r4,-4(fp)
   28340:	002802c0 	call	2802c <alt_tse_get_mac_info>
   28344:	e0bffa15 	stw	r2,-24(fp)
    
    if(pmac_info == 0) {
   28348:	e0bffa17 	ldw	r2,-24(fp)
   2834c:	1000491e 	bne	r2,zero,28474 <getPHYSpeed+0x204>
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
   28350:	00800044 	movi	r2,1
   28354:	e0bff705 	stb	r2,-36(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
   28358:	00800044 	movi	r2,1
   2835c:	e0bff745 	stb	r2,-35(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PMAC_FOUND;
   28360:	e0bff743 	ldbu	r2,-35(fp)
   28364:	10c0004c 	andi	r3,r2,1
   28368:	e0bff703 	ldbu	r2,-36(fp)
   2836c:	10800098 	cmpnei	r2,r2,2
   28370:	1000021e 	bne	r2,zero,2837c <getPHYSpeed+0x10c>
   28374:	00800084 	movi	r2,2
   28378:	00000106 	br	28380 <getPHYSpeed+0x110>
   2837c:	0005883a 	mov	r2,zero
   28380:	1886b03a 	or	r3,r3,r2
   28384:	e0bff703 	ldbu	r2,-36(fp)
   28388:	10800058 	cmpnei	r2,r2,1
   2838c:	1000021e 	bne	r2,zero,28398 <getPHYSpeed+0x128>
   28390:	00800104 	movi	r2,4
   28394:	00000106 	br	2839c <getPHYSpeed+0x12c>
   28398:	0005883a 	mov	r2,zero
   2839c:	1886b03a 	or	r3,r3,r2
   283a0:	e0bff703 	ldbu	r2,-36(fp)
   283a4:	1000021e 	bne	r2,zero,283b0 <getPHYSpeed+0x140>
   283a8:	00800204 	movi	r2,8
   283ac:	00000106 	br	283b4 <getPHYSpeed+0x144>
   283b0:	0005883a 	mov	r2,zero
   283b4:	1886b03a 	or	r3,r3,r2
   283b8:	e0bff703 	ldbu	r2,-36(fp)
   283bc:	108000d8 	cmpnei	r2,r2,3
   283c0:	1000021e 	bne	r2,zero,283cc <getPHYSpeed+0x15c>
   283c4:	00800074 	movhi	r2,1
   283c8:	00000106 	br	283d0 <getPHYSpeed+0x160>
   283cc:	0005883a 	mov	r2,zero
   283d0:	1884b03a 	or	r2,r3,r2
   283d4:	10802034 	orhi	r2,r2,128
   283d8:	e0bff815 	stw	r2,-32(fp)
        tse_dprintf(2, "ERROR   : [getPHYSpeed] pmac not found from list of pmac_info[]! Speed = %s Mbps, Duplex = %s\n", speed == TSE_PHY_SPEED_1000 ? "1000" :
   283dc:	e0bff703 	ldbu	r2,-36(fp)
   283e0:	108000a0 	cmpeqi	r2,r2,2
   283e4:	10000f1e 	bne	r2,zero,28424 <getPHYSpeed+0x1b4>
   283e8:	e0bff703 	ldbu	r2,-36(fp)
   283ec:	10800060 	cmpeqi	r2,r2,1
   283f0:	1000081e 	bne	r2,zero,28414 <getPHYSpeed+0x1a4>
   283f4:	e0bff703 	ldbu	r2,-36(fp)
   283f8:	1000031e 	bne	r2,zero,28408 <getPHYSpeed+0x198>
   283fc:	008000f4 	movhi	r2,3
   28400:	10867604 	addi	r2,r2,6616
   28404:	00000206 	br	28410 <getPHYSpeed+0x1a0>
   28408:	008000f4 	movhi	r2,3
   2840c:	10867704 	addi	r2,r2,6620
   28410:	00000206 	br	2841c <getPHYSpeed+0x1ac>
   28414:	008000f4 	movhi	r2,3
   28418:	10867904 	addi	r2,r2,6628
   2841c:	1007883a 	mov	r3,r2
   28420:	00000206 	br	2842c <getPHYSpeed+0x1bc>
   28424:	00c000f4 	movhi	r3,3
   28428:	18c67a04 	addi	r3,r3,6632
   2842c:	e0bff743 	ldbu	r2,-35(fp)
   28430:	10800058 	cmpnei	r2,r2,1
   28434:	1000031e 	bne	r2,zero,28444 <getPHYSpeed+0x1d4>
   28438:	008000f4 	movhi	r2,3
   2843c:	10867c04 	addi	r2,r2,6640
   28440:	00000206 	br	2844c <getPHYSpeed+0x1dc>
   28444:	008000f4 	movhi	r2,3
   28448:	10867e04 	addi	r2,r2,6648
   2844c:	010000f4 	movhi	r4,3
   28450:	21068004 	addi	r4,r4,6656
   28454:	180b883a 	mov	r5,r3
   28458:	100d883a 	mov	r6,r2
   2845c:	00193f00 	call	193f0 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        tse_dprintf(2, "ERROR   : [getPHYSpeed] Please define tse_mac_device[] correctly\n");
   28460:	010000f4 	movhi	r4,3
   28464:	21069804 	addi	r4,r4,6752
   28468:	001965c0 	call	1965c <puts>
        return result;
   2846c:	e0bff817 	ldw	r2,-32(fp)
   28470:	00021706 	br	28cd0 <getPHYSpeed+0xa60>
    }
    
    pphy = pmac_info->pphy_info;
   28474:	e0bffa17 	ldw	r2,-24(fp)
   28478:	10800117 	ldw	r2,4(r2)
   2847c:	e0bff915 	stw	r2,-28(fp)
    pmac_group = pmac_info->pmac_group;
   28480:	e0bffa17 	ldw	r2,-24(fp)
   28484:	10800317 	ldw	r2,12(r2)
   28488:	e0bffb15 	stw	r2,-20(fp)
    psys = pmac_info->psys_info;
   2848c:	e0bffa17 	ldw	r2,-24(fp)
   28490:	10800217 	ldw	r2,8(r2)
   28494:	e0bffc15 	stw	r2,-16(fp)
    
    mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   28498:	e13ffa17 	ldw	r4,-24(fp)
   2849c:	0027fac0 	call	27fac <alt_tse_get_mac_info_index>
   284a0:	e0bffd05 	stb	r2,-12(fp)
    mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   284a4:	e13ffb17 	ldw	r4,-20(fp)
   284a8:	0027f380 	call	27f38 <alt_tse_get_mac_group_index>
   284ac:	e0bffd45 	stb	r2,-11(fp)
         
    /* MDIO is not used */
    if (pmac_group->pmac_info[0]->psys_info->tse_use_mdio == 0)
   284b0:	e0bffb17 	ldw	r2,-20(fp)
   284b4:	10800117 	ldw	r2,4(r2)
   284b8:	10800217 	ldw	r2,8(r2)
   284bc:	10800203 	ldbu	r2,8(r2)
   284c0:	10803fcc 	andi	r2,r2,255
   284c4:	10005a1e 	bne	r2,zero,28630 <getPHYSpeed+0x3c0>
    {
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
   284c8:	00800044 	movi	r2,1
   284cc:	e0bff705 	stb	r2,-36(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
   284d0:	00800044 	movi	r2,1
   284d4:	e0bff745 	stb	r2,-35(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_MDIO;
   284d8:	e0bff743 	ldbu	r2,-35(fp)
   284dc:	10c0004c 	andi	r3,r2,1
   284e0:	e0bff703 	ldbu	r2,-36(fp)
   284e4:	10800098 	cmpnei	r2,r2,2
   284e8:	1000021e 	bne	r2,zero,284f4 <getPHYSpeed+0x284>
   284ec:	00800084 	movi	r2,2
   284f0:	00000106 	br	284f8 <getPHYSpeed+0x288>
   284f4:	0005883a 	mov	r2,zero
   284f8:	1886b03a 	or	r3,r3,r2
   284fc:	e0bff703 	ldbu	r2,-36(fp)
   28500:	10800058 	cmpnei	r2,r2,1
   28504:	1000021e 	bne	r2,zero,28510 <getPHYSpeed+0x2a0>
   28508:	00800104 	movi	r2,4
   2850c:	00000106 	br	28514 <getPHYSpeed+0x2a4>
   28510:	0005883a 	mov	r2,zero
   28514:	1886b03a 	or	r3,r3,r2
   28518:	e0bff703 	ldbu	r2,-36(fp)
   2851c:	1000021e 	bne	r2,zero,28528 <getPHYSpeed+0x2b8>
   28520:	00800204 	movi	r2,8
   28524:	00000106 	br	2852c <getPHYSpeed+0x2bc>
   28528:	0005883a 	mov	r2,zero
   2852c:	1886b03a 	or	r3,r3,r2
   28530:	e0bff703 	ldbu	r2,-36(fp)
   28534:	108000d8 	cmpnei	r2,r2,3
   28538:	1000021e 	bne	r2,zero,28544 <getPHYSpeed+0x2d4>
   2853c:	00800074 	movhi	r2,1
   28540:	00000106 	br	28548 <getPHYSpeed+0x2d8>
   28544:	0005883a 	mov	r2,zero
   28548:	1884b03a 	or	r2,r3,r2
   2854c:	10801034 	orhi	r2,r2,64
   28550:	e0bff815 	stw	r2,-32(fp)
        usleep(ALTERA_NOMDIO_TIMEOUT_THRESHOLD);
   28554:	010003f4 	movhi	r4,15
   28558:	21109004 	addi	r4,r4,16960
   2855c:	00224a80 	call	224a8 <usleep>
        if(psys->tse_phy_cfg) {
   28560:	e0bffc17 	ldw	r2,-16(fp)
   28564:	10801117 	ldw	r2,68(r2)
   28568:	10000d26 	beq	r2,zero,285a0 <getPHYSpeed+0x330>
        	tse_dprintf(4, "WARNING : PHY[%d.%d] - MDIO not enabled! Running user configuration...\n", mac_group_index, mac_info_index);
   2856c:	e0fffd47 	ldb	r3,-11(fp)
   28570:	e0bffd07 	ldb	r2,-12(fp)
   28574:	010000f4 	movhi	r4,3
   28578:	2106a904 	addi	r4,r4,6820
   2857c:	180b883a 	mov	r5,r3
   28580:	100d883a 	mov	r6,r2
   28584:	00193f00 	call	193f0 <printf>
        	result = psys->tse_phy_cfg(pmac);
   28588:	e0bffc17 	ldw	r2,-16(fp)
   2858c:	10801117 	ldw	r2,68(r2)
   28590:	e13fff17 	ldw	r4,-4(fp)
   28594:	103ee83a 	callr	r2
   28598:	e0bff815 	stw	r2,-32(fp)
   2859c:	00002206 	br	28628 <getPHYSpeed+0x3b8>
        }
        else {
        	tse_dprintf(4, "WARNING : MAC Group[%d] - MDIO not enabled! Speed = %s, Duplex = %s\n", mac_group_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
   285a0:	e17ffd47 	ldb	r5,-11(fp)
   285a4:	e0bff703 	ldbu	r2,-36(fp)
   285a8:	108000a0 	cmpeqi	r2,r2,2
   285ac:	10000f1e 	bne	r2,zero,285ec <getPHYSpeed+0x37c>
   285b0:	e0bff703 	ldbu	r2,-36(fp)
   285b4:	10800060 	cmpeqi	r2,r2,1
   285b8:	1000081e 	bne	r2,zero,285dc <getPHYSpeed+0x36c>
   285bc:	e0bff703 	ldbu	r2,-36(fp)
   285c0:	1000031e 	bne	r2,zero,285d0 <getPHYSpeed+0x360>
   285c4:	008000f4 	movhi	r2,3
   285c8:	10867604 	addi	r2,r2,6616
   285cc:	00000206 	br	285d8 <getPHYSpeed+0x368>
   285d0:	008000f4 	movhi	r2,3
   285d4:	10867704 	addi	r2,r2,6620
   285d8:	00000206 	br	285e4 <getPHYSpeed+0x374>
   285dc:	008000f4 	movhi	r2,3
   285e0:	10867904 	addi	r2,r2,6628
   285e4:	1007883a 	mov	r3,r2
   285e8:	00000206 	br	285f4 <getPHYSpeed+0x384>
   285ec:	00c000f4 	movhi	r3,3
   285f0:	18c67a04 	addi	r3,r3,6632
   285f4:	e0bff743 	ldbu	r2,-35(fp)
   285f8:	10800058 	cmpnei	r2,r2,1
   285fc:	1000031e 	bne	r2,zero,2860c <getPHYSpeed+0x39c>
   28600:	008000f4 	movhi	r2,3
   28604:	10867c04 	addi	r2,r2,6640
   28608:	00000206 	br	28614 <getPHYSpeed+0x3a4>
   2860c:	008000f4 	movhi	r2,3
   28610:	10867e04 	addi	r2,r2,6648
   28614:	010000f4 	movhi	r4,3
   28618:	2106bb04 	addi	r4,r4,6892
   2861c:	180d883a 	mov	r6,r3
   28620:	100f883a 	mov	r7,r2
   28624:	00193f00 	call	193f0 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        }
        return result;
   28628:	e0bff817 	ldw	r2,-32(fp)
   2862c:	0001a806 	br	28cd0 <getPHYSpeed+0xa60>

    /* Not running simulation */
    #ifndef ALT_SIM_OPTIMIZE
	
		/* These variables declaration are here to avoid "warning: unused variable" message when compile for simulation */
		np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   28630:	e0bffb17 	ldw	r2,-20(fp)
   28634:	10800117 	ldw	r2,4(r2)
   28638:	10800217 	ldw	r2,8(r2)
   2863c:	10800017 	ldw	r2,0(r2)
   28640:	e0bffe15 	stw	r2,-8(fp)
    
        /* if no PHY connected to the MAC */
        if(pphy == 0) {
   28644:	e0bff917 	ldw	r2,-28(fp)
   28648:	1000471e 	bne	r2,zero,28768 <getPHYSpeed+0x4f8>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
   2864c:	00800044 	movi	r2,1
   28650:	e0bff705 	stb	r2,-36(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
   28654:	00800044 	movi	r2,1
   28658:	e0bff745 	stb	r2,-35(fp)
            result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY;
   2865c:	e0bff743 	ldbu	r2,-35(fp)
   28660:	10c0004c 	andi	r3,r2,1
   28664:	e0bff703 	ldbu	r2,-36(fp)
   28668:	10800098 	cmpnei	r2,r2,2
   2866c:	1000021e 	bne	r2,zero,28678 <getPHYSpeed+0x408>
   28670:	00800084 	movi	r2,2
   28674:	00000106 	br	2867c <getPHYSpeed+0x40c>
   28678:	0005883a 	mov	r2,zero
   2867c:	1886b03a 	or	r3,r3,r2
   28680:	e0bff703 	ldbu	r2,-36(fp)
   28684:	10800058 	cmpnei	r2,r2,1
   28688:	1000021e 	bne	r2,zero,28694 <getPHYSpeed+0x424>
   2868c:	00800104 	movi	r2,4
   28690:	00000106 	br	28698 <getPHYSpeed+0x428>
   28694:	0005883a 	mov	r2,zero
   28698:	1886b03a 	or	r3,r3,r2
   2869c:	e0bff703 	ldbu	r2,-36(fp)
   286a0:	1000021e 	bne	r2,zero,286ac <getPHYSpeed+0x43c>
   286a4:	00800204 	movi	r2,8
   286a8:	00000106 	br	286b0 <getPHYSpeed+0x440>
   286ac:	0005883a 	mov	r2,zero
   286b0:	1886b03a 	or	r3,r3,r2
   286b4:	e0bff703 	ldbu	r2,-36(fp)
   286b8:	108000d8 	cmpnei	r2,r2,3
   286bc:	1000021e 	bne	r2,zero,286c8 <getPHYSpeed+0x458>
   286c0:	00800074 	movhi	r2,1
   286c4:	00000106 	br	286cc <getPHYSpeed+0x45c>
   286c8:	0005883a 	mov	r2,zero
   286cc:	1884b03a 	or	r2,r3,r2
   286d0:	10800834 	orhi	r2,r2,32
   286d4:	e0bff815 	stw	r2,-32(fp)
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - No PHY connected! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
   286d8:	e17ffd47 	ldb	r5,-11(fp)
   286dc:	e1bffd07 	ldb	r6,-12(fp)
   286e0:	e0bff703 	ldbu	r2,-36(fp)
   286e4:	108000a0 	cmpeqi	r2,r2,2
   286e8:	10000e1e 	bne	r2,zero,28724 <getPHYSpeed+0x4b4>
   286ec:	e0bff703 	ldbu	r2,-36(fp)
   286f0:	10800060 	cmpeqi	r2,r2,1
   286f4:	1000081e 	bne	r2,zero,28718 <getPHYSpeed+0x4a8>
   286f8:	e0bff703 	ldbu	r2,-36(fp)
   286fc:	1000031e 	bne	r2,zero,2870c <getPHYSpeed+0x49c>
   28700:	008000f4 	movhi	r2,3
   28704:	10867604 	addi	r2,r2,6616
   28708:	00000206 	br	28714 <getPHYSpeed+0x4a4>
   2870c:	008000f4 	movhi	r2,3
   28710:	10867704 	addi	r2,r2,6620
   28714:	00000206 	br	28720 <getPHYSpeed+0x4b0>
   28718:	008000f4 	movhi	r2,3
   2871c:	10867904 	addi	r2,r2,6628
   28720:	00000206 	br	2872c <getPHYSpeed+0x4bc>
   28724:	008000f4 	movhi	r2,3
   28728:	10867a04 	addi	r2,r2,6632
   2872c:	e0fff743 	ldbu	r3,-35(fp)
   28730:	18c00058 	cmpnei	r3,r3,1
   28734:	1800031e 	bne	r3,zero,28744 <getPHYSpeed+0x4d4>
   28738:	00c000f4 	movhi	r3,3
   2873c:	18c67c04 	addi	r3,r3,6640
   28740:	00000206 	br	2874c <getPHYSpeed+0x4dc>
   28744:	00c000f4 	movhi	r3,3
   28748:	18c67e04 	addi	r3,r3,6648
   2874c:	d8c00015 	stw	r3,0(sp)
   28750:	010000f4 	movhi	r4,3
   28754:	2106cd04 	addi	r4,r4,6964
   28758:	100f883a 	mov	r7,r2
   2875c:	00193f00 	call	193f0 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
            return result;
   28760:	e0bff817 	ldw	r2,-32(fp)
   28764:	00015a06 	br	28cd0 <getPHYSpeed+0xa60>
        }

		/* Small MAC */
		if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
   28768:	e0bffa17 	ldw	r2,-24(fp)
   2876c:	10800003 	ldbu	r2,0(r2)
   28770:	10803fcc 	andi	r2,r2,255
   28774:	10800058 	cmpnei	r2,r2,1
   28778:	1000081e 	bne	r2,zero,2879c <getPHYSpeed+0x52c>
			alt_tse_phy_set_adv_1000(pphy, 0);
   2877c:	e13ff917 	ldw	r4,-28(fp)
   28780:	000b883a 	mov	r5,zero
   28784:	002ac180 	call	2ac18 <alt_tse_phy_set_adv_1000>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
   28788:	e13ff917 	ldw	r4,-28(fp)
   2878c:	01400134 	movhi	r5,4
   28790:	29742404 	addi	r5,r5,-12144
   28794:	002a35c0 	call	2a35c <alt_tse_phy_restart_an>
   28798:	00000f06 	br	287d8 <getPHYSpeed+0x568>
		}
		else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
   2879c:	e0bffa17 	ldw	r2,-24(fp)
   287a0:	10800003 	ldbu	r2,0(r2)
   287a4:	10803fcc 	andi	r2,r2,255
   287a8:	10800098 	cmpnei	r2,r2,2
   287ac:	10000a1e 	bne	r2,zero,287d8 <getPHYSpeed+0x568>
			alt_tse_phy_set_adv_100(pphy, 0);
   287b0:	e13ff917 	ldw	r4,-28(fp)
   287b4:	000b883a 	mov	r5,zero
   287b8:	002add40 	call	2add4 <alt_tse_phy_set_adv_100>
			alt_tse_phy_set_adv_10(pphy, 0);
   287bc:	e13ff917 	ldw	r4,-28(fp)
   287c0:	000b883a 	mov	r5,zero
   287c4:	002b01c0 	call	2b01c <alt_tse_phy_set_adv_10>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
   287c8:	e13ff917 	ldw	r4,-28(fp)
   287cc:	01400134 	movhi	r5,4
   287d0:	29742404 	addi	r5,r5,-12144
   287d4:	002a35c0 	call	2a35c <alt_tse_phy_restart_an>
		}
		
		/* check link connection for this PHY */
		if(alt_tse_phy_check_link(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD) == TSE_PHY_AN_NOT_COMPLETE) {
   287d8:	e13ff917 	ldw	r4,-28(fp)
   287dc:	01400134 	movhi	r5,4
   287e0:	29742404 	addi	r5,r5,-12144
   287e4:	002a5200 	call	2a520 <alt_tse_phy_check_link>
   287e8:	10bfffd8 	cmpnei	r2,r2,-1
   287ec:	1000471e 	bne	r2,zero,2890c <getPHYSpeed+0x69c>
			speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
   287f0:	00800044 	movi	r2,1
   287f4:	e0bff705 	stb	r2,-36(fp)
			duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
   287f8:	00800044 	movi	r2,1
   287fc:	e0bff745 	stb	r2,-35(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_AN_NOT_COMPLETE;
   28800:	e0bff743 	ldbu	r2,-35(fp)
   28804:	10c0004c 	andi	r3,r2,1
   28808:	e0bff703 	ldbu	r2,-36(fp)
   2880c:	10800098 	cmpnei	r2,r2,2
   28810:	1000021e 	bne	r2,zero,2881c <getPHYSpeed+0x5ac>
   28814:	00800084 	movi	r2,2
   28818:	00000106 	br	28820 <getPHYSpeed+0x5b0>
   2881c:	0005883a 	mov	r2,zero
   28820:	1886b03a 	or	r3,r3,r2
   28824:	e0bff703 	ldbu	r2,-36(fp)
   28828:	10800058 	cmpnei	r2,r2,1
   2882c:	1000021e 	bne	r2,zero,28838 <getPHYSpeed+0x5c8>
   28830:	00800104 	movi	r2,4
   28834:	00000106 	br	2883c <getPHYSpeed+0x5cc>
   28838:	0005883a 	mov	r2,zero
   2883c:	1886b03a 	or	r3,r3,r2
   28840:	e0bff703 	ldbu	r2,-36(fp)
   28844:	1000021e 	bne	r2,zero,28850 <getPHYSpeed+0x5e0>
   28848:	00800204 	movi	r2,8
   2884c:	00000106 	br	28854 <getPHYSpeed+0x5e4>
   28850:	0005883a 	mov	r2,zero
   28854:	1886b03a 	or	r3,r3,r2
   28858:	e0bff703 	ldbu	r2,-36(fp)
   2885c:	108000d8 	cmpnei	r2,r2,3
   28860:	1000021e 	bne	r2,zero,2886c <getPHYSpeed+0x5fc>
   28864:	00800074 	movhi	r2,1
   28868:	00000106 	br	28870 <getPHYSpeed+0x600>
   2886c:	0005883a 	mov	r2,zero
   28870:	1884b03a 	or	r2,r3,r2
   28874:	10800234 	orhi	r2,r2,8
   28878:	e0bff815 	stw	r2,-32(fp)
			tse_dprintf(3, "WARNING : PHY[%d.%d] - Auto-Negotiation not completed! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
   2887c:	e17ffd47 	ldb	r5,-11(fp)
   28880:	e1bffd07 	ldb	r6,-12(fp)
   28884:	e0bff703 	ldbu	r2,-36(fp)
   28888:	108000a0 	cmpeqi	r2,r2,2
   2888c:	10000e1e 	bne	r2,zero,288c8 <getPHYSpeed+0x658>
   28890:	e0bff703 	ldbu	r2,-36(fp)
   28894:	10800060 	cmpeqi	r2,r2,1
   28898:	1000081e 	bne	r2,zero,288bc <getPHYSpeed+0x64c>
   2889c:	e0bff703 	ldbu	r2,-36(fp)
   288a0:	1000031e 	bne	r2,zero,288b0 <getPHYSpeed+0x640>
   288a4:	008000f4 	movhi	r2,3
   288a8:	10867604 	addi	r2,r2,6616
   288ac:	00000206 	br	288b8 <getPHYSpeed+0x648>
   288b0:	008000f4 	movhi	r2,3
   288b4:	10867704 	addi	r2,r2,6620
   288b8:	00000206 	br	288c4 <getPHYSpeed+0x654>
   288bc:	008000f4 	movhi	r2,3
   288c0:	10867904 	addi	r2,r2,6628
   288c4:	00000206 	br	288d0 <getPHYSpeed+0x660>
   288c8:	008000f4 	movhi	r2,3
   288cc:	10867a04 	addi	r2,r2,6632
   288d0:	e0fff743 	ldbu	r3,-35(fp)
   288d4:	18c00058 	cmpnei	r3,r3,1
   288d8:	1800031e 	bne	r3,zero,288e8 <getPHYSpeed+0x678>
   288dc:	00c000f4 	movhi	r3,3
   288e0:	18c67c04 	addi	r3,r3,6640
   288e4:	00000206 	br	288f0 <getPHYSpeed+0x680>
   288e8:	00c000f4 	movhi	r3,3
   288ec:	18c67e04 	addi	r3,r3,6648
   288f0:	d8c00015 	stw	r3,0(sp)
   288f4:	010000f4 	movhi	r4,3
   288f8:	2106de04 	addi	r4,r4,7032
   288fc:	100f883a 	mov	r7,r2
   28900:	00193f00 	call	193f0 <printf>
																			 speed == TSE_PHY_SPEED_100 ? "100" :
																			 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
																			 duplex == 1 ? "Full" : "Half");
			return result;
   28904:	e0bff817 	ldw	r2,-32(fp)
   28908:	0000f106 	br	28cd0 <getPHYSpeed+0xa60>
		}

        IOWR(&pmac_group_base->MDIO_ADDR1, 0, pphy->mdio_address);
   2890c:	e0bffe17 	ldw	r2,-8(fp)
   28910:	10801004 	addi	r2,r2,64
   28914:	e0fff917 	ldw	r3,-28(fp)
   28918:	18c00003 	ldbu	r3,0(r3)
   2891c:	18c03fcc 	andi	r3,r3,255
   28920:	10c00035 	stwio	r3,0(r2)
        /* To enable PHY loopback */
        #if ENABLE_PHY_LOOPBACK
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Putting PHY in loopback\n", mac_group_index, mac_info_index);
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 1);   // enable PHY loopback
		#else
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
   28924:	d8000015 	stw	zero,0(sp)
   28928:	e13ff917 	ldw	r4,-28(fp)
   2892c:	000b883a 	mov	r5,zero
   28930:	01800384 	movi	r6,14
   28934:	01c00044 	movi	r7,1
   28938:	0028d840 	call	28d84 <alt_tse_phy_wr_mdio_reg>
        #endif
       
        /* if PHY not found in profile */
        if(pphy->pphy_profile == 0) {
   2893c:	e0bff917 	ldw	r2,-28(fp)
   28940:	10800517 	ldw	r2,20(r2)
   28944:	10002b1e 	bne	r2,zero,289f4 <getPHYSpeed+0x784>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not found in PHY profile\n", mac_group_index, mac_info_index);
   28948:	e0fffd47 	ldb	r3,-11(fp)
   2894c:	e0bffd07 	ldb	r2,-12(fp)
   28950:	010000f4 	movhi	r4,3
   28954:	2106f204 	addi	r4,r4,7112
   28958:	180b883a 	mov	r5,r3
   2895c:	100d883a 	mov	r6,r2
   28960:	00193f00 	call	193f0 <printf>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
   28964:	00800044 	movi	r2,1
   28968:	e0bff705 	stb	r2,-36(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
   2896c:	00800044 	movi	r2,1
   28970:	e0bff745 	stb	r2,-35(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY_PROFILE;
   28974:	e0bff743 	ldbu	r2,-35(fp)
   28978:	10c0004c 	andi	r3,r2,1
   2897c:	e0bff703 	ldbu	r2,-36(fp)
   28980:	10800098 	cmpnei	r2,r2,2
   28984:	1000021e 	bne	r2,zero,28990 <getPHYSpeed+0x720>
   28988:	00800084 	movi	r2,2
   2898c:	00000106 	br	28994 <getPHYSpeed+0x724>
   28990:	0005883a 	mov	r2,zero
   28994:	1886b03a 	or	r3,r3,r2
   28998:	e0bff703 	ldbu	r2,-36(fp)
   2899c:	10800058 	cmpnei	r2,r2,1
   289a0:	1000021e 	bne	r2,zero,289ac <getPHYSpeed+0x73c>
   289a4:	00800104 	movi	r2,4
   289a8:	00000106 	br	289b0 <getPHYSpeed+0x740>
   289ac:	0005883a 	mov	r2,zero
   289b0:	1886b03a 	or	r3,r3,r2
   289b4:	e0bff703 	ldbu	r2,-36(fp)
   289b8:	1000021e 	bne	r2,zero,289c4 <getPHYSpeed+0x754>
   289bc:	00800204 	movi	r2,8
   289c0:	00000106 	br	289c8 <getPHYSpeed+0x758>
   289c4:	0005883a 	mov	r2,zero
   289c8:	1886b03a 	or	r3,r3,r2
   289cc:	e0bff703 	ldbu	r2,-36(fp)
   289d0:	108000d8 	cmpnei	r2,r2,3
   289d4:	1000021e 	bne	r2,zero,289e0 <getPHYSpeed+0x770>
   289d8:	00800074 	movhi	r2,1
   289dc:	00000106 	br	289e4 <getPHYSpeed+0x774>
   289e0:	0005883a 	mov	r2,zero
   289e4:	1884b03a 	or	r2,r3,r2
   289e8:	10800134 	orhi	r2,r2,4
   289ec:	e0bff815 	stw	r2,-32(fp)
   289f0:	00009406 	br	28c44 <getPHYSpeed+0x9d4>
        }
        // retrieve duplex information from PHY
		else
		{
			if(pphy->pphy_profile->link_status_read)
   289f4:	e0bff917 	ldw	r2,-28(fp)
   289f8:	10800517 	ldw	r2,20(r2)
   289fc:	10801817 	ldw	r2,96(r2)
   28a00:	10002626 	beq	r2,zero,28a9c <getPHYSpeed+0x82c>
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
   28a04:	e0bff917 	ldw	r2,-28(fp)
   28a08:	10800517 	ldw	r2,20(r2)
   28a0c:	10801817 	ldw	r2,96(r2)
   28a10:	e13ffe17 	ldw	r4,-8(fp)
   28a14:	103ee83a 	callr	r2
   28a18:	e0bff815 	stw	r2,-32(fp)
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
   28a1c:	e0bff817 	ldw	r2,-32(fp)
   28a20:	1080008c 	andi	r2,r2,2
   28a24:	10000c1e 	bne	r2,zero,28a58 <getPHYSpeed+0x7e8>
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
   28a28:	e0bff817 	ldw	r2,-32(fp)
   28a2c:	1080010c 	andi	r2,r2,4
		else
		{
			if(pphy->pphy_profile->link_status_read)
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
   28a30:	1000071e 	bne	r2,zero,28a50 <getPHYSpeed+0x7e0>
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
   28a34:	e0bff817 	ldw	r2,-32(fp)
   28a38:	1080020c 	andi	r2,r2,8
		else
		{
			if(pphy->pphy_profile->link_status_read)
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
   28a3c:	10000226 	beq	r2,zero,28a48 <getPHYSpeed+0x7d8>
   28a40:	0005883a 	mov	r2,zero
   28a44:	00000106 	br	28a4c <getPHYSpeed+0x7dc>
   28a48:	008000c4 	movi	r2,3
   28a4c:	00000106 	br	28a54 <getPHYSpeed+0x7e4>
   28a50:	00800044 	movi	r2,1
   28a54:	00000106 	br	28a5c <getPHYSpeed+0x7ec>
   28a58:	00800084 	movi	r2,2
   28a5c:	e0bff705 	stb	r2,-36(fp)
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
				duplex = (result & 0x01) ? TSE_PHY_DUPLEX_FULL : TSE_PHY_DUPLEX_HALF;
   28a60:	e0bff817 	ldw	r2,-32(fp)
   28a64:	1080004c 	andi	r2,r2,1
   28a68:	1004c03a 	cmpne	r2,r2,zero
   28a6c:	e0bff745 	stb	r2,-35(fp)
				
				if(result & ALT_TSE_E_INVALID_SPEED)
   28a70:	e0bff817 	ldw	r2,-32(fp)
   28a74:	1080006c 	andhi	r2,r2,1
   28a78:	10007226 	beq	r2,zero,28c44 <getPHYSpeed+0x9d4>
				{
					tse_dprintf(3, "WARNING : PHY[%d.%d] - Invalid speed read from PHY\n", mac_group_index, mac_info_index);
   28a7c:	e0fffd47 	ldb	r3,-11(fp)
   28a80:	e0bffd07 	ldb	r2,-12(fp)
   28a84:	010000f4 	movhi	r4,3
   28a88:	21070004 	addi	r4,r4,7168
   28a8c:	180b883a 	mov	r5,r3
   28a90:	100d883a 	mov	r6,r2
   28a94:	00193f00 	call	193f0 <printf>
   28a98:	00006a06 	br	28c44 <getPHYSpeed+0x9d4>
				}
			}
			else if(pphy->pphy_profile->status_reg_location == 0)
   28a9c:	e0bff917 	ldw	r2,-28(fp)
   28aa0:	10800517 	ldw	r2,20(r2)
   28aa4:	10801583 	ldbu	r2,86(r2)
   28aa8:	10803fcc 	andi	r2,r2,255
   28aac:	10002b1e 	bne	r2,zero,28b5c <getPHYSpeed+0x8ec>
	        {
	            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY Specific Status register information not provided in profile\n", mac_group_index, mac_info_index);
   28ab0:	e0fffd47 	ldb	r3,-11(fp)
   28ab4:	e0bffd07 	ldb	r2,-12(fp)
   28ab8:	010000f4 	movhi	r4,3
   28abc:	21070d04 	addi	r4,r4,7220
   28ac0:	180b883a 	mov	r5,r3
   28ac4:	100d883a 	mov	r6,r2
   28ac8:	00193f00 	call	193f0 <printf>
	            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
   28acc:	00800044 	movi	r2,1
   28ad0:	e0bff705 	stb	r2,-36(fp)
	            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
   28ad4:	00800044 	movi	r2,1
   28ad8:	e0bff745 	stb	r2,-35(fp)
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_PROFILE_INCORRECT_DEFINED;
   28adc:	e0bff743 	ldbu	r2,-35(fp)
   28ae0:	10c0004c 	andi	r3,r2,1
   28ae4:	e0bff703 	ldbu	r2,-36(fp)
   28ae8:	10800098 	cmpnei	r2,r2,2
   28aec:	1000021e 	bne	r2,zero,28af8 <getPHYSpeed+0x888>
   28af0:	00800084 	movi	r2,2
   28af4:	00000106 	br	28afc <getPHYSpeed+0x88c>
   28af8:	0005883a 	mov	r2,zero
   28afc:	1886b03a 	or	r3,r3,r2
   28b00:	e0bff703 	ldbu	r2,-36(fp)
   28b04:	10800058 	cmpnei	r2,r2,1
   28b08:	1000021e 	bne	r2,zero,28b14 <getPHYSpeed+0x8a4>
   28b0c:	00800104 	movi	r2,4
   28b10:	00000106 	br	28b18 <getPHYSpeed+0x8a8>
   28b14:	0005883a 	mov	r2,zero
   28b18:	1886b03a 	or	r3,r3,r2
   28b1c:	e0bff703 	ldbu	r2,-36(fp)
   28b20:	1000021e 	bne	r2,zero,28b2c <getPHYSpeed+0x8bc>
   28b24:	00800204 	movi	r2,8
   28b28:	00000106 	br	28b30 <getPHYSpeed+0x8c0>
   28b2c:	0005883a 	mov	r2,zero
   28b30:	1886b03a 	or	r3,r3,r2
   28b34:	e0bff703 	ldbu	r2,-36(fp)
   28b38:	108000d8 	cmpnei	r2,r2,3
   28b3c:	1000021e 	bne	r2,zero,28b48 <getPHYSpeed+0x8d8>
   28b40:	00800074 	movhi	r2,1
   28b44:	00000106 	br	28b4c <getPHYSpeed+0x8dc>
   28b48:	0005883a 	mov	r2,zero
   28b4c:	1884b03a 	or	r2,r3,r2
   28b50:	108000b4 	orhi	r2,r2,2
   28b54:	e0bff815 	stw	r2,-32(fp)
   28b58:	00003a06 	br	28c44 <getPHYSpeed+0x9d4>
	        }
	        else
	        {
	            /* extract connection speed and duplex information */
	        	speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
   28b5c:	e0bff917 	ldw	r2,-28(fp)
   28b60:	10800517 	ldw	r2,20(r2)
   28b64:	10801583 	ldbu	r2,86(r2)
   28b68:	10c03fcc 	andi	r3,r2,255
   28b6c:	e0bff917 	ldw	r2,-28(fp)
   28b70:	10800517 	ldw	r2,20(r2)
   28b74:	108015c3 	ldbu	r2,87(r2)
   28b78:	10803fcc 	andi	r2,r2,255
   28b7c:	e13ff917 	ldw	r4,-28(fp)
   28b80:	180b883a 	mov	r5,r3
   28b84:	100d883a 	mov	r6,r2
   28b88:	01c00084 	movi	r7,2
   28b8c:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   28b90:	e0bff705 	stb	r2,-36(fp)
	            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
   28b94:	e0bff917 	ldw	r2,-28(fp)
   28b98:	10800517 	ldw	r2,20(r2)
   28b9c:	10801583 	ldbu	r2,86(r2)
   28ba0:	10c03fcc 	andi	r3,r2,255
   28ba4:	e0bff917 	ldw	r2,-28(fp)
   28ba8:	10800517 	ldw	r2,20(r2)
   28bac:	10801603 	ldbu	r2,88(r2)
   28bb0:	10803fcc 	andi	r2,r2,255
   28bb4:	e13ff917 	ldw	r4,-28(fp)
   28bb8:	180b883a 	mov	r5,r3
   28bbc:	100d883a 	mov	r6,r2
   28bc0:	01c00044 	movi	r7,1
   28bc4:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   28bc8:	e0bff745 	stb	r2,-35(fp)
				
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
   28bcc:	e0bff743 	ldbu	r2,-35(fp)
   28bd0:	10c0004c 	andi	r3,r2,1
   28bd4:	e0bff703 	ldbu	r2,-36(fp)
   28bd8:	10800098 	cmpnei	r2,r2,2
   28bdc:	1000021e 	bne	r2,zero,28be8 <getPHYSpeed+0x978>
   28be0:	00800084 	movi	r2,2
   28be4:	00000106 	br	28bec <getPHYSpeed+0x97c>
   28be8:	0005883a 	mov	r2,zero
   28bec:	1886b03a 	or	r3,r3,r2
   28bf0:	e0bff703 	ldbu	r2,-36(fp)
   28bf4:	10800058 	cmpnei	r2,r2,1
   28bf8:	1000021e 	bne	r2,zero,28c04 <getPHYSpeed+0x994>
   28bfc:	00800104 	movi	r2,4
   28c00:	00000106 	br	28c08 <getPHYSpeed+0x998>
   28c04:	0005883a 	mov	r2,zero
   28c08:	1886b03a 	or	r3,r3,r2
   28c0c:	e0bff703 	ldbu	r2,-36(fp)
   28c10:	1000021e 	bne	r2,zero,28c1c <getPHYSpeed+0x9ac>
   28c14:	00800204 	movi	r2,8
   28c18:	00000106 	br	28c20 <getPHYSpeed+0x9b0>
   28c1c:	0005883a 	mov	r2,zero
   28c20:	1886b03a 	or	r3,r3,r2
   28c24:	e0bff703 	ldbu	r2,-36(fp)
   28c28:	108000d8 	cmpnei	r2,r2,3
   28c2c:	1000021e 	bne	r2,zero,28c38 <getPHYSpeed+0x9c8>
   28c30:	00800074 	movhi	r2,1
   28c34:	00000106 	br	28c3c <getPHYSpeed+0x9cc>
   28c38:	0005883a 	mov	r2,zero
   28c3c:	1884b03a 	or	r2,r3,r2
   28c40:	e0bff815 	stw	r2,-32(fp)
        /* for simulation purpose, default to gigabit mode */
        speed = 1;
        duplex = 1;
    #endif

    tse_dprintf(5, "INFO    : PHY[%d.%d] - Speed = %s, Duplex = %s\n",  mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
   28c44:	e17ffd47 	ldb	r5,-11(fp)
   28c48:	e1bffd07 	ldb	r6,-12(fp)
   28c4c:	e0bff703 	ldbu	r2,-36(fp)
   28c50:	108000a0 	cmpeqi	r2,r2,2
   28c54:	10000e1e 	bne	r2,zero,28c90 <getPHYSpeed+0xa20>
   28c58:	e0bff703 	ldbu	r2,-36(fp)
   28c5c:	10800060 	cmpeqi	r2,r2,1
   28c60:	1000081e 	bne	r2,zero,28c84 <getPHYSpeed+0xa14>
   28c64:	e0bff703 	ldbu	r2,-36(fp)
   28c68:	1000031e 	bne	r2,zero,28c78 <getPHYSpeed+0xa08>
   28c6c:	008000f4 	movhi	r2,3
   28c70:	10867604 	addi	r2,r2,6616
   28c74:	00000206 	br	28c80 <getPHYSpeed+0xa10>
   28c78:	008000f4 	movhi	r2,3
   28c7c:	10867704 	addi	r2,r2,6620
   28c80:	00000206 	br	28c8c <getPHYSpeed+0xa1c>
   28c84:	008000f4 	movhi	r2,3
   28c88:	10867904 	addi	r2,r2,6628
   28c8c:	00000206 	br	28c98 <getPHYSpeed+0xa28>
   28c90:	008000f4 	movhi	r2,3
   28c94:	10867a04 	addi	r2,r2,6632
   28c98:	e0fff743 	ldbu	r3,-35(fp)
   28c9c:	18c00058 	cmpnei	r3,r3,1
   28ca0:	1800031e 	bne	r3,zero,28cb0 <getPHYSpeed+0xa40>
   28ca4:	00c000f4 	movhi	r3,3
   28ca8:	18c67c04 	addi	r3,r3,6640
   28cac:	00000206 	br	28cb8 <getPHYSpeed+0xa48>
   28cb0:	00c000f4 	movhi	r3,3
   28cb4:	18c67e04 	addi	r3,r3,6648
   28cb8:	d8c00015 	stw	r3,0(sp)
   28cbc:	010000f4 	movhi	r4,3
   28cc0:	21072404 	addi	r4,r4,7312
   28cc4:	100f883a 	mov	r7,r2
   28cc8:	00193f00 	call	193f0 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");

    return result;
   28ccc:	e0bff817 	ldw	r2,-32(fp)
}
   28cd0:	e037883a 	mov	sp,fp
   28cd4:	dfc00117 	ldw	ra,4(sp)
   28cd8:	df000017 	ldw	fp,0(sp)
   28cdc:	dec00204 	addi	sp,sp,8
   28ce0:	f800283a 	ret

00028ce4 <alt_tse_phy_rd_mdio_addr>:
/* @Function Description: Read MDIO address from the MDIO address1 register of first MAC within MAC group
 * @API Type:    Internal
 * @param pmac   Pointer to the alt_tse_phy_info structure
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_rd_mdio_addr(alt_tse_phy_info *pphy) {
   28ce4:	defffd04 	addi	sp,sp,-12
   28ce8:	df000215 	stw	fp,8(sp)
   28cec:	df000204 	addi	fp,sp,8
   28cf0:	e13fff15 	stw	r4,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   28cf4:	e0bfff17 	ldw	r2,-4(fp)
   28cf8:	10800617 	ldw	r2,24(r2)
   28cfc:	10800317 	ldw	r2,12(r2)
   28d00:	10800117 	ldw	r2,4(r2)
   28d04:	10800217 	ldw	r2,8(r2)
   28d08:	10800017 	ldw	r2,0(r2)
   28d0c:	e0bffe15 	stw	r2,-8(fp)
    return IORD(&pmac_group_base->MDIO_ADDR1, 0);
   28d10:	e0bffe17 	ldw	r2,-8(fp)
   28d14:	10801004 	addi	r2,r2,64
   28d18:	10800037 	ldwio	r2,0(r2)
}
   28d1c:	e037883a 	mov	sp,fp
   28d20:	df000017 	ldw	fp,0(sp)
   28d24:	dec00104 	addi	sp,sp,4
   28d28:	f800283a 	ret

00028d2c <alt_tse_phy_wr_mdio_addr>:
 * @API Type:           Internal
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
   28d2c:	defffc04 	addi	sp,sp,-16
   28d30:	df000315 	stw	fp,12(sp)
   28d34:	df000304 	addi	fp,sp,12
   28d38:	e13ffe15 	stw	r4,-8(fp)
   28d3c:	2805883a 	mov	r2,r5
   28d40:	e0bfff05 	stb	r2,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   28d44:	e0bffe17 	ldw	r2,-8(fp)
   28d48:	10800617 	ldw	r2,24(r2)
   28d4c:	10800317 	ldw	r2,12(r2)
   28d50:	10800117 	ldw	r2,4(r2)
   28d54:	10800217 	ldw	r2,8(r2)
   28d58:	10800017 	ldw	r2,0(r2)
   28d5c:	e0bffd15 	stw	r2,-12(fp)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
   28d60:	e0bffd17 	ldw	r2,-12(fp)
   28d64:	10801004 	addi	r2,r2,64
   28d68:	e0ffff03 	ldbu	r3,-4(fp)
   28d6c:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
   28d70:	0005883a 	mov	r2,zero
}
   28d74:	e037883a 	mov	sp,fp
   28d78:	df000017 	ldw	fp,0(sp)
   28d7c:	dec00104 	addi	sp,sp,4
   28d80:	f800283a 	ret

00028d84 <alt_tse_phy_wr_mdio_reg>:
  * @param  bit_length       number of bits to be written to the register.
  * @param  data             data to be written to the register at specific bit location of register.
  * @return SUCCESS 
  */
alt_32 alt_tse_phy_wr_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length, alt_u16 data)
{
   28d84:	defff604 	addi	sp,sp,-40
   28d88:	df000915 	stw	fp,36(sp)
   28d8c:	df000904 	addi	fp,sp,36
   28d90:	e13ffb15 	stw	r4,-20(fp)
   28d94:	2809883a 	mov	r4,r5
   28d98:	3007883a 	mov	r3,r6
   28d9c:	3805883a 	mov	r2,r7
   28da0:	e1400117 	ldw	r5,4(fp)
   28da4:	e13ffc05 	stb	r4,-16(fp)
   28da8:	e0fffd05 	stb	r3,-12(fp)
   28dac:	e0bffe05 	stb	r2,-8(fp)
   28db0:	e17fff0d 	sth	r5,-4(fp)
    
    alt_u16 temp_data;
    alt_u16 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   28db4:	e0bffb17 	ldw	r2,-20(fp)
   28db8:	10800617 	ldw	r2,24(r2)
   28dbc:	10800317 	ldw	r2,12(r2)
   28dc0:	10800117 	ldw	r2,4(r2)
   28dc4:	10800217 	ldw	r2,8(r2)
   28dc8:	10800017 	ldw	r2,0(r2)
   28dcc:	e0bff915 	stw	r2,-28(fp)
    
    bit_mask = 0x00;
   28dd0:	e03ff70d 	sth	zero,-36(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
   28dd4:	e03ff815 	stw	zero,-32(fp)
   28dd8:	00000906 	br	28e00 <alt_tse_phy_wr_mdio_reg+0x7c>
    {
        bit_mask <<= 1;
   28ddc:	e0bff70b 	ldhu	r2,-36(fp)
   28de0:	1085883a 	add	r2,r2,r2
   28de4:	e0bff70d 	sth	r2,-36(fp)
        bit_mask |= 0x01;        
   28de8:	e0bff70b 	ldhu	r2,-36(fp)
   28dec:	10800054 	ori	r2,r2,1
   28df0:	e0bff70d 	sth	r2,-36(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
   28df4:	e0bff817 	ldw	r2,-32(fp)
   28df8:	10800044 	addi	r2,r2,1
   28dfc:	e0bff815 	stw	r2,-32(fp)
   28e00:	e0bffe03 	ldbu	r2,-8(fp)
   28e04:	e0fff817 	ldw	r3,-32(fp)
   28e08:	18bff416 	blt	r3,r2,28ddc <alt_tse_phy_wr_mdio_reg+0x58>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* shifting mask to left by bit_num */
    bit_mask <<= lsb_num;
   28e0c:	e0fff70b 	ldhu	r3,-36(fp)
   28e10:	e0bffd03 	ldbu	r2,-12(fp)
   28e14:	1884983a 	sll	r2,r3,r2
   28e18:	e0bff70d 	sth	r2,-36(fp)

    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
   28e1c:	e0bff917 	ldw	r2,-28(fp)
   28e20:	10c0a004 	addi	r3,r2,640
   28e24:	e0bffc03 	ldbu	r2,-16(fp)
   28e28:	1085883a 	add	r2,r2,r2
   28e2c:	1085883a 	add	r2,r2,r2
   28e30:	1885883a 	add	r2,r3,r2
   28e34:	10800037 	ldwio	r2,0(r2)
   28e38:	e0bffa0d 	sth	r2,-24(fp)
    
    /* clear bits to be written */
    temp_data &= ~bit_mask;
   28e3c:	e0bff70b 	ldhu	r2,-36(fp)
   28e40:	0084303a 	nor	r2,zero,r2
   28e44:	1007883a 	mov	r3,r2
   28e48:	e0bffa0b 	ldhu	r2,-24(fp)
   28e4c:	1884703a 	and	r2,r3,r2
   28e50:	e0bffa0d 	sth	r2,-24(fp)
    
    /* OR-ed together corresponding bits data */
    temp_data |= ((data << lsb_num) & bit_mask);    
   28e54:	e0ffff0b 	ldhu	r3,-4(fp)
   28e58:	e0bffd03 	ldbu	r2,-12(fp)
   28e5c:	1884983a 	sll	r2,r3,r2
   28e60:	1007883a 	mov	r3,r2
   28e64:	e0bff70b 	ldhu	r2,-36(fp)
   28e68:	1884703a 	and	r2,r3,r2
   28e6c:	1007883a 	mov	r3,r2
   28e70:	e0bffa0b 	ldhu	r2,-24(fp)
   28e74:	1884b03a 	or	r2,r3,r2
   28e78:	e0bffa0d 	sth	r2,-24(fp)
    
    /* write data to MDIO register */
    IOWR(&pmac->mdio1, reg_num, temp_data);
   28e7c:	e0bff917 	ldw	r2,-28(fp)
   28e80:	10c0a004 	addi	r3,r2,640
   28e84:	e0bffc03 	ldbu	r2,-16(fp)
   28e88:	1085883a 	add	r2,r2,r2
   28e8c:	1085883a 	add	r2,r2,r2
   28e90:	1885883a 	add	r2,r3,r2
   28e94:	e0fffa0b 	ldhu	r3,-24(fp)
   28e98:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
   28e9c:	0005883a 	mov	r2,zero
    
}
   28ea0:	e037883a 	mov	sp,fp
   28ea4:	df000017 	ldw	fp,0(sp)
   28ea8:	dec00104 	addi	sp,sp,4
   28eac:	f800283a 	ret

00028eb0 <alt_tse_phy_rd_mdio_reg>:
 * @param  bit_length       number of bits to be read from the register.
 * @return data read from MDIO register 
 */

alt_u32 alt_tse_phy_rd_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length)
{
   28eb0:	defff704 	addi	sp,sp,-36
   28eb4:	df000815 	stw	fp,32(sp)
   28eb8:	df000804 	addi	fp,sp,32
   28ebc:	e13ffc15 	stw	r4,-16(fp)
   28ec0:	2809883a 	mov	r4,r5
   28ec4:	3007883a 	mov	r3,r6
   28ec8:	3805883a 	mov	r2,r7
   28ecc:	e13ffd05 	stb	r4,-12(fp)
   28ed0:	e0fffe05 	stb	r3,-8(fp)
   28ed4:	e0bfff05 	stb	r2,-4(fp)
    alt_u16 temp_data;
    alt_u32 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   28ed8:	e0bffc17 	ldw	r2,-16(fp)
   28edc:	10800617 	ldw	r2,24(r2)
   28ee0:	10800317 	ldw	r2,12(r2)
   28ee4:	10800117 	ldw	r2,4(r2)
   28ee8:	10800217 	ldw	r2,8(r2)
   28eec:	10800017 	ldw	r2,0(r2)
   28ef0:	e0bffa15 	stw	r2,-24(fp)
    
    bit_mask = 0x00;
   28ef4:	e03ff815 	stw	zero,-32(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
   28ef8:	e03ff915 	stw	zero,-28(fp)
   28efc:	00000906 	br	28f24 <alt_tse_phy_rd_mdio_reg+0x74>
    {
        bit_mask <<= 1;
   28f00:	e0bff817 	ldw	r2,-32(fp)
   28f04:	1085883a 	add	r2,r2,r2
   28f08:	e0bff815 	stw	r2,-32(fp)
        bit_mask |= 0x01;        
   28f0c:	e0bff817 	ldw	r2,-32(fp)
   28f10:	10800054 	ori	r2,r2,1
   28f14:	e0bff815 	stw	r2,-32(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
   28f18:	e0bff917 	ldw	r2,-28(fp)
   28f1c:	10800044 	addi	r2,r2,1
   28f20:	e0bff915 	stw	r2,-28(fp)
   28f24:	e0bfff03 	ldbu	r2,-4(fp)
   28f28:	e0fff917 	ldw	r3,-28(fp)
   28f2c:	18bff416 	blt	r3,r2,28f00 <alt_tse_phy_rd_mdio_reg+0x50>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
   28f30:	e0bffa17 	ldw	r2,-24(fp)
   28f34:	10c0a004 	addi	r3,r2,640
   28f38:	e0bffd03 	ldbu	r2,-12(fp)
   28f3c:	1085883a 	add	r2,r2,r2
   28f40:	1085883a 	add	r2,r2,r2
   28f44:	1885883a 	add	r2,r3,r2
   28f48:	10800037 	ldwio	r2,0(r2)
   28f4c:	e0bffb0d 	sth	r2,-20(fp)
    
    /* shifting read data */
    temp_data >>= lsb_num;
   28f50:	e0fffb0b 	ldhu	r3,-20(fp)
   28f54:	e0bffe03 	ldbu	r2,-8(fp)
   28f58:	1885d83a 	sra	r2,r3,r2
   28f5c:	e0bffb0d 	sth	r2,-20(fp)
    
    return (temp_data & bit_mask);
   28f60:	e0fffb0b 	ldhu	r3,-20(fp)
   28f64:	e0bff817 	ldw	r2,-32(fp)
   28f68:	1884703a 	and	r2,r3,r2
}
   28f6c:	e037883a 	mov	sp,fp
   28f70:	df000017 	ldw	fp,0(sp)
   28f74:	dec00104 	addi	sp,sp,4
   28f78:	f800283a 	ret

00028f7c <alt_tse_phy_add_profile_default>:
 * @param pmac  N/A
 * @return      Number of PHY in profile
 * 
 * User might add their own PHY by calling alt_tse_phy_add_profile()
 */
alt_32 alt_tse_phy_add_profile_default() {
   28f7c:	deff9a04 	addi	sp,sp,-408
   28f80:	dfc06515 	stw	ra,404(sp)
   28f84:	df006415 	stw	fp,400(sp)
   28f88:	df006404 	addi	fp,sp,400
        
    /* ------------------------------ */
    /* Marvell PHY on PHYWORKX board  */
    /* ------------------------------ */
    
    alt_tse_phy_profile MV88E1111 = {"Marvell 88E1111",      /* Marvell 88E1111                                  */
   28f8c:	e0ff9c04 	addi	r3,fp,-400
   28f90:	00801904 	movi	r2,100
   28f94:	1809883a 	mov	r4,r3
   28f98:	000b883a 	mov	r5,zero
   28f9c:	100d883a 	mov	r6,r2
   28fa0:	00192e80 	call	192e8 <memset>
   28fa4:	009d9cb4 	movhi	r2,30322
   28fa8:	10985344 	addi	r2,r2,24909
   28fac:	e0bf9c15 	stw	r2,-400(fp)
   28fb0:	00881b34 	movhi	r2,8300
   28fb4:	109b1944 	addi	r2,r2,27749
   28fb8:	e0bf9d15 	stw	r2,-396(fp)
   28fbc:	008c5174 	movhi	r2,12613
   28fc0:	108e0e04 	addi	r2,r2,14392
   28fc4:	e0bf9e15 	stw	r2,-392(fp)
   28fc8:	00800c74 	movhi	r2,49
   28fcc:	108c4c44 	addi	r2,r2,12593
   28fd0:	e0bf9f15 	stw	r2,-388(fp)
   28fd4:	e0ffa004 	addi	r3,fp,-384
   28fd8:	00801004 	movi	r2,64
   28fdc:	1809883a 	mov	r4,r3
   28fe0:	000b883a 	mov	r5,zero
   28fe4:	100d883a 	mov	r6,r2
   28fe8:	00192e80 	call	192e8 <memset>
   28fec:	009410c4 	movi	r2,20547
   28ff0:	e0bfb015 	stw	r2,-320(fp)
   28ff4:	00800304 	movi	r2,12
   28ff8:	e0bfb105 	stb	r2,-316(fp)
   28ffc:	00800084 	movi	r2,2
   29000:	e0bfb145 	stb	r2,-315(fp)
   29004:	00800444 	movi	r2,17
   29008:	e0bfb185 	stb	r2,-314(fp)
   2900c:	00800384 	movi	r2,14
   29010:	e0bfb1c5 	stb	r2,-313(fp)
   29014:	00800344 	movi	r2,13
   29018:	e0bfb205 	stb	r2,-312(fp)
   2901c:	00800284 	movi	r2,10
   29020:	e0bfb245 	stb	r2,-311(fp)
   29024:	008000f4 	movhi	r2,3
   29028:	10ae6904 	addi	r2,r2,-18012
   2902c:	e0bfb315 	stw	r2,-308(fp)
    
    /* ---------------------------------- */
    /* Marvell Quad PHY on PHYWORKX board */
    /* ---------------------------------- */
    
    alt_tse_phy_profile MV88E1145 = {"Marvell Quad PHY 88E1145",      /* Marvell 88E1145                                  */
   29030:	e0ffb504 	addi	r3,fp,-300
   29034:	00801904 	movi	r2,100
   29038:	1809883a 	mov	r4,r3
   2903c:	000b883a 	mov	r5,zero
   29040:	100d883a 	mov	r6,r2
   29044:	00192e80 	call	192e8 <memset>
   29048:	009d9cb4 	movhi	r2,30322
   2904c:	10985344 	addi	r2,r2,24909
   29050:	e0bfb515 	stw	r2,-300(fp)
   29054:	00881b34 	movhi	r2,8300
   29058:	109b1944 	addi	r2,r2,27749
   2905c:	e0bfb615 	stw	r2,-296(fp)
   29060:	00991874 	movhi	r2,25697
   29064:	109d5444 	addi	r2,r2,30033
   29068:	e0bfb715 	stw	r2,-292(fp)
   2906c:	00965234 	movhi	r2,22856
   29070:	10940804 	addi	r2,r2,20512
   29074:	e0bfb815 	stw	r2,-288(fp)
   29078:	00914e34 	movhi	r2,17720
   2907c:	108e0804 	addi	r2,r2,14368
   29080:	e0bfb915 	stw	r2,-284(fp)
   29084:	008d4d34 	movhi	r2,13620
   29088:	108c4c44 	addi	r2,r2,12593
   2908c:	e0bfba15 	stw	r2,-280(fp)
   29090:	e03fbb15 	stw	zero,-276(fp)
   29094:	e03fbc15 	stw	zero,-272(fp)
   29098:	e03fbd15 	stw	zero,-268(fp)
   2909c:	e03fbe15 	stw	zero,-264(fp)
   290a0:	e03fbf15 	stw	zero,-260(fp)
   290a4:	e03fc015 	stw	zero,-256(fp)
   290a8:	e03fc115 	stw	zero,-252(fp)
   290ac:	e03fc215 	stw	zero,-248(fp)
   290b0:	e03fc315 	stw	zero,-244(fp)
   290b4:	e03fc415 	stw	zero,-240(fp)
   290b8:	e03fc515 	stw	zero,-236(fp)
   290bc:	e03fc615 	stw	zero,-232(fp)
   290c0:	e03fc715 	stw	zero,-228(fp)
   290c4:	e03fc815 	stw	zero,-224(fp)
   290c8:	009410c4 	movi	r2,20547
   290cc:	e0bfc915 	stw	r2,-220(fp)
   290d0:	00800344 	movi	r2,13
   290d4:	e0bfca05 	stb	r2,-216(fp)
   290d8:	00800084 	movi	r2,2
   290dc:	e0bfca45 	stb	r2,-215(fp)
   290e0:	00800444 	movi	r2,17
   290e4:	e0bfca85 	stb	r2,-214(fp)
   290e8:	00800384 	movi	r2,14
   290ec:	e0bfcac5 	stb	r2,-213(fp)
   290f0:	00800344 	movi	r2,13
   290f4:	e0bfcb05 	stb	r2,-212(fp)
   290f8:	00800284 	movi	r2,10
   290fc:	e0bfcb45 	stb	r2,-211(fp)
   29100:	008000f4 	movhi	r2,3
   29104:	10ae6904 	addi	r2,r2,-18012
   29108:	e0bfcc15 	stw	r2,-208(fp)
                      
    /* ------------------------------ */
    /* National PHY on PHYWORKX board */
    /* ------------------------------ */  
    
    alt_tse_phy_profile DP83865 = {"National DP83865",     /* National DP83865                                 */
   2910c:	e0ffce04 	addi	r3,fp,-200
   29110:	00801904 	movi	r2,100
   29114:	1809883a 	mov	r4,r3
   29118:	000b883a 	mov	r5,zero
   2911c:	100d883a 	mov	r6,r2
   29120:	00192e80 	call	192e8 <memset>
   29124:	009a5d34 	movhi	r2,26996
   29128:	10985384 	addi	r2,r2,24910
   2912c:	e0bfce15 	stw	r2,-200(fp)
   29130:	009b1874 	movhi	r2,27745
   29134:	109b9bc4 	addi	r2,r2,28271
   29138:	e0bfcf15 	stw	r2,-196(fp)
   2913c:	008e1434 	movhi	r2,14416
   29140:	10910804 	addi	r2,r2,17440
   29144:	e0bfd015 	stw	r2,-192(fp)
   29148:	008d4db4 	movhi	r2,13622
   2914c:	108e0cc4 	addi	r2,r2,14387
   29150:	e0bfd115 	stw	r2,-188(fp)
   29154:	e03fd215 	stw	zero,-184(fp)
   29158:	e0ffd304 	addi	r3,fp,-180
   2915c:	00800f04 	movi	r2,60
   29160:	1809883a 	mov	r4,r3
   29164:	000b883a 	mov	r5,zero
   29168:	100d883a 	mov	r6,r2
   2916c:	00192e80 	call	192e8 <memset>
   29170:	00800234 	movhi	r2,8
   29174:	108005c4 	addi	r2,r2,23
   29178:	e0bfe215 	stw	r2,-120(fp)
   2917c:	008001c4 	movi	r2,7
   29180:	e0bfe305 	stb	r2,-116(fp)
   29184:	00800284 	movi	r2,10
   29188:	e0bfe345 	stb	r2,-115(fp)
   2918c:	00800444 	movi	r2,17
   29190:	e0bfe385 	stb	r2,-114(fp)
   29194:	008000c4 	movi	r2,3
   29198:	e0bfe3c5 	stb	r2,-113(fp)
   2919c:	00800044 	movi	r2,1
   291a0:	e0bfe405 	stb	r2,-112(fp)
   291a4:	00800084 	movi	r2,2
   291a8:	e0bfe445 	stb	r2,-111(fp)
                      
    /* -------------------------------------- */
    /* National 10/100 PHY on PHYWORKX board  */
    /* -------------------------------------- */ 
                      
    alt_tse_phy_profile DP83848C = {"National DP83848C",  /* National DP83848C                                          */
   291ac:	008000f4 	movhi	r2,3
   291b0:	10873004 	addi	r2,r2,7360
   291b4:	e13fe704 	addi	r4,fp,-100
   291b8:	1007883a 	mov	r3,r2
   291bc:	00801904 	movi	r2,100
   291c0:	180b883a 	mov	r5,r3
   291c4:	100d883a 	mov	r6,r2
   291c8:	00191f00 	call	191f0 <memcpy>
						   0,                              /* No function pointer configure National DP83848C            */
						   &DP83848C_link_status_read      /* Function pointer to read from PHY specific status register */           
                          };
                      
    /* add supported PHY to profile */                          
    alt_tse_phy_add_profile(&MV88E1111);
   291cc:	e13f9c04 	addi	r4,fp,-400
   291d0:	00271000 	call	27100 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&MV88E1145);
   291d4:	e0bfb504 	addi	r2,fp,-300
   291d8:	1009883a 	mov	r4,r2
   291dc:	00271000 	call	27100 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83865);
   291e0:	e0bfce04 	addi	r2,fp,-200
   291e4:	1009883a 	mov	r4,r2
   291e8:	00271000 	call	27100 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83848C);
   291ec:	e0bfe704 	addi	r2,fp,-100
   291f0:	1009883a 	mov	r4,r2
   291f4:	00271000 	call	27100 <alt_tse_phy_add_profile>
    
    
    return phy_profile_count;
   291f8:	d0a8df03 	ldbu	r2,-23684(gp)
   291fc:	10803fcc 	andi	r2,r2,255
}
   29200:	e037883a 	mov	sp,fp
   29204:	dfc00117 	ldw	ra,4(sp)
   29208:	df000017 	ldw	fp,0(sp)
   2920c:	dec00204 	addi	sp,sp,8
   29210:	f800283a 	ret

00029214 <alt_tse_phy_print_profile>:
/* @Function Description: Display PHYs available in profile
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      Number of PHY in profile
 */
alt_32 alt_tse_phy_print_profile() {
   29214:	defffd04 	addi	sp,sp,-12
   29218:	dfc00215 	stw	ra,8(sp)
   2921c:	df000115 	stw	fp,4(sp)
   29220:	df000104 	addi	fp,sp,4
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
   29224:	d0a8df03 	ldbu	r2,-23684(gp)
   29228:	10803fcc 	andi	r2,r2,255
   2922c:	010000f4 	movhi	r4,3
   29230:	21074904 	addi	r4,r4,7460
   29234:	100b883a 	mov	r5,r2
   29238:	0026dc40 	call	26dc4 <no_printf>
    
    for(i = 0; i < phy_profile_count; i++)
   2923c:	e03fff05 	stb	zero,-4(fp)
   29240:	00006d06 	br	293f8 <alt_tse_phy_print_profile+0x1e4>
    {
        tse_dprintf(6, "Profile No.%2d   :\n", i);
   29244:	e0bfff07 	ldb	r2,-4(fp)
   29248:	010000f4 	movhi	r4,3
   2924c:	21075804 	addi	r4,r4,7520
   29250:	100b883a 	mov	r5,r2
   29254:	0026dc40 	call	26dc4 <no_printf>
        tse_dprintf(6, "PHY Name        : %s\n", pphy_profiles[i]->name);
   29258:	e0bfff07 	ldb	r2,-4(fp)
   2925c:	00c00234 	movhi	r3,8
   29260:	18c41a04 	addi	r3,r3,4200
   29264:	1085883a 	add	r2,r2,r2
   29268:	1085883a 	add	r2,r2,r2
   2926c:	1885883a 	add	r2,r3,r2
   29270:	10800017 	ldw	r2,0(r2)
   29274:	010000f4 	movhi	r4,3
   29278:	21075d04 	addi	r4,r4,7540
   2927c:	100b883a 	mov	r5,r2
   29280:	0026dc40 	call	26dc4 <no_printf>
   
        tse_dprintf(6, "PHY OUI         : 0x%06x\n", (int)pphy_profiles[i]->oui);
   29284:	e0bfff07 	ldb	r2,-4(fp)
   29288:	00c00234 	movhi	r3,8
   2928c:	18c41a04 	addi	r3,r3,4200
   29290:	1085883a 	add	r2,r2,r2
   29294:	1085883a 	add	r2,r2,r2
   29298:	1885883a 	add	r2,r3,r2
   2929c:	10800017 	ldw	r2,0(r2)
   292a0:	10801417 	ldw	r2,80(r2)
   292a4:	010000f4 	movhi	r4,3
   292a8:	21076304 	addi	r4,r4,7564
   292ac:	100b883a 	mov	r5,r2
   292b0:	0026dc40 	call	26dc4 <no_printf>
        tse_dprintf(6, "PHY Model Num.  : 0x%02x\n", pphy_profiles[i]->model_number);
   292b4:	e0bfff07 	ldb	r2,-4(fp)
   292b8:	00c00234 	movhi	r3,8
   292bc:	18c41a04 	addi	r3,r3,4200
   292c0:	1085883a 	add	r2,r2,r2
   292c4:	1085883a 	add	r2,r2,r2
   292c8:	1885883a 	add	r2,r3,r2
   292cc:	10800017 	ldw	r2,0(r2)
   292d0:	10801503 	ldbu	r2,84(r2)
   292d4:	10803fcc 	andi	r2,r2,255
   292d8:	010000f4 	movhi	r4,3
   292dc:	21076a04 	addi	r4,r4,7592
   292e0:	100b883a 	mov	r5,r2
   292e4:	0026dc40 	call	26dc4 <no_printf>
        tse_dprintf(6, "PHY Rev. Num.   : 0x%02x\n", pphy_profiles[i]->revision_number);
   292e8:	e0bfff07 	ldb	r2,-4(fp)
   292ec:	00c00234 	movhi	r3,8
   292f0:	18c41a04 	addi	r3,r3,4200
   292f4:	1085883a 	add	r2,r2,r2
   292f8:	1085883a 	add	r2,r2,r2
   292fc:	1885883a 	add	r2,r3,r2
   29300:	10800017 	ldw	r2,0(r2)
   29304:	10801543 	ldbu	r2,85(r2)
   29308:	10803fcc 	andi	r2,r2,255
   2930c:	010000f4 	movhi	r4,3
   29310:	21077104 	addi	r4,r4,7620
   29314:	100b883a 	mov	r5,r2
   29318:	0026dc40 	call	26dc4 <no_printf>
        
        tse_dprintf(6, "Status Register : 0x%02x\n", pphy_profiles[i]->status_reg_location); 
   2931c:	e0bfff07 	ldb	r2,-4(fp)
   29320:	00c00234 	movhi	r3,8
   29324:	18c41a04 	addi	r3,r3,4200
   29328:	1085883a 	add	r2,r2,r2
   2932c:	1085883a 	add	r2,r2,r2
   29330:	1885883a 	add	r2,r3,r2
   29334:	10800017 	ldw	r2,0(r2)
   29338:	10801583 	ldbu	r2,86(r2)
   2933c:	10803fcc 	andi	r2,r2,255
   29340:	010000f4 	movhi	r4,3
   29344:	21077804 	addi	r4,r4,7648
   29348:	100b883a 	mov	r5,r2
   2934c:	0026dc40 	call	26dc4 <no_printf>
        
        tse_dprintf(6, "Speed Bit       : %d\n", pphy_profiles[i]->speed_lsb_location);
   29350:	e0bfff07 	ldb	r2,-4(fp)
   29354:	00c00234 	movhi	r3,8
   29358:	18c41a04 	addi	r3,r3,4200
   2935c:	1085883a 	add	r2,r2,r2
   29360:	1085883a 	add	r2,r2,r2
   29364:	1885883a 	add	r2,r3,r2
   29368:	10800017 	ldw	r2,0(r2)
   2936c:	108015c3 	ldbu	r2,87(r2)
   29370:	10803fcc 	andi	r2,r2,255
   29374:	010000f4 	movhi	r4,3
   29378:	21077f04 	addi	r4,r4,7676
   2937c:	100b883a 	mov	r5,r2
   29380:	0026dc40 	call	26dc4 <no_printf>
        
        tse_dprintf(6, "Duplex Bit      : %d\n", pphy_profiles[i]->duplex_bit_location);
   29384:	e0bfff07 	ldb	r2,-4(fp)
   29388:	00c00234 	movhi	r3,8
   2938c:	18c41a04 	addi	r3,r3,4200
   29390:	1085883a 	add	r2,r2,r2
   29394:	1085883a 	add	r2,r2,r2
   29398:	1885883a 	add	r2,r3,r2
   2939c:	10800017 	ldw	r2,0(r2)
   293a0:	10801603 	ldbu	r2,88(r2)
   293a4:	10803fcc 	andi	r2,r2,255
   293a8:	010000f4 	movhi	r4,3
   293ac:	21078504 	addi	r4,r4,7700
   293b0:	100b883a 	mov	r5,r2
   293b4:	0026dc40 	call	26dc4 <no_printf>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
   293b8:	e0bfff07 	ldb	r2,-4(fp)
   293bc:	00c00234 	movhi	r3,8
   293c0:	18c41a04 	addi	r3,r3,4200
   293c4:	1085883a 	add	r2,r2,r2
   293c8:	1085883a 	add	r2,r2,r2
   293cc:	1885883a 	add	r2,r3,r2
   293d0:	10800017 	ldw	r2,0(r2)
   293d4:	10801643 	ldbu	r2,89(r2)
   293d8:	10803fcc 	andi	r2,r2,255
   293dc:	010000f4 	movhi	r4,3
   293e0:	21078b04 	addi	r4,r4,7724
   293e4:	100b883a 	mov	r5,r2
   293e8:	0026dc40 	call	26dc4 <no_printf>
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
    
    for(i = 0; i < phy_profile_count; i++)
   293ec:	e0bfff03 	ldbu	r2,-4(fp)
   293f0:	10800044 	addi	r2,r2,1
   293f4:	e0bfff05 	stb	r2,-4(fp)
   293f8:	e0ffff07 	ldb	r3,-4(fp)
   293fc:	d0a8df03 	ldbu	r2,-23684(gp)
   29400:	10803fcc 	andi	r2,r2,255
   29404:	18bf8f16 	blt	r3,r2,29244 <alt_tse_phy_print_profile+0x30>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
 
    }
    
    return phy_profile_count;
   29408:	d0a8df03 	ldbu	r2,-23684(gp)
   2940c:	10803fcc 	andi	r2,r2,255
}
   29410:	e037883a 	mov	sp,fp
   29414:	dfc00117 	ldw	ra,4(sp)
   29418:	df000017 	ldw	fp,0(sp)
   2941c:	dec00204 	addi	sp,sp,8
   29420:	f800283a 	ret

00029424 <alt_tse_mac_group_init>:
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      return SUCCESS
 *              return ALTERA_TSE_SYSTEM_DEF_ERROR if alt_tse_system_info structure definition error
 */
alt_32 alt_tse_mac_group_init() {
   29424:	defffa04 	addi	sp,sp,-24
   29428:	dfc00515 	stw	ra,20(sp)
   2942c:	df000415 	stw	fp,16(sp)
   29430:	df000404 	addi	fp,sp,16
    
	alt_8 i;
	alt_8 j;
    
    alt_tse_mac_group *pmac_group = 0;
   29434:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_mac_info *pmac_info = 0;
   29438:	e03ffe15 	stw	zero,-8(fp)
    alt_tse_system_info *psys = 0;
   2943c:	e03fff15 	stw	zero,-4(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
   29440:	d028df45 	stb	zero,-23683(gp)
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
   29444:	e03ffc05 	stb	zero,-16(fp)
   29448:	00019306 	br	29a98 <alt_tse_mac_group_init+0x674>
        psys = &tse_mac_device[i];
   2944c:	e0bffc07 	ldb	r2,-16(fp)
   29450:	10c01224 	muli	r3,r2,72
   29454:	008000f4 	movhi	r2,3
   29458:	108d0b04 	addi	r2,r2,13356
   2945c:	1885883a 	add	r2,r3,r2
   29460:	e0bfff15 	stw	r2,-4(fp)

        if((psys->tse_sgdma_tx != 0) && (psys->tse_sgdma_rx != 0)) {    	
   29464:	e0bfff17 	ldw	r2,-4(fp)
   29468:	10800517 	ldw	r2,20(r2)
   2946c:	10018726 	beq	r2,zero,29a8c <alt_tse_mac_group_init+0x668>
   29470:	e0bfff17 	ldw	r2,-4(fp)
   29474:	10800617 	ldw	r2,24(r2)
   29478:	10018426 	beq	r2,zero,29a8c <alt_tse_mac_group_init+0x668>
            tse_dprintf(5, "INFO    : TSE MAC %d found at address 0x%08x\n", mac_group_count, (int) psys->tse_mac_base);
   2947c:	d0a8df43 	ldbu	r2,-23683(gp)
   29480:	10c03fcc 	andi	r3,r2,255
   29484:	e0bfff17 	ldw	r2,-4(fp)
   29488:	10800017 	ldw	r2,0(r2)
   2948c:	010000f4 	movhi	r4,3
   29490:	21079104 	addi	r4,r4,7748
   29494:	180b883a 	mov	r5,r3
   29498:	100d883a 	mov	r6,r2
   2949c:	00193f00 	call	193f0 <printf>
            
            /* Allocate memory for the structure */
            pmac_group = (alt_tse_mac_group *) malloc(sizeof(alt_tse_mac_group));
   294a0:	01000904 	movi	r4,36
   294a4:	002df340 	call	2df34 <malloc>
   294a8:	e0bffd15 	stw	r2,-12(fp)
            if(!pmac_group) {
   294ac:	e0bffd17 	ldw	r2,-12(fp)
   294b0:	1000081e 	bne	r2,zero,294d4 <alt_tse_mac_group_init+0xb0>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]\n", mac_group_count);
   294b4:	d0a8df43 	ldbu	r2,-23683(gp)
   294b8:	10803fcc 	andi	r2,r2,255
   294bc:	010000f4 	movhi	r4,3
   294c0:	21079d04 	addi	r4,r4,7796
   294c4:	100b883a 	mov	r5,r2
   294c8:	00193f00 	call	193f0 <printf>
                return ALTERA_TSE_MALLOC_FAILED;
   294cc:	00bfffc4 	movi	r2,-1
   294d0:	00017606 	br	29aac <alt_tse_mac_group_init+0x688>
            }
           
            /* Non-multi-channel MAC considered as 1 channel */
            if(psys->tse_multichannel_mac) {
   294d4:	e0bfff17 	ldw	r2,-4(fp)
   294d8:	108002c3 	ldbu	r2,11(r2)
   294dc:	10803fcc 	andi	r2,r2,255
   294e0:	10001226 	beq	r2,zero,2952c <alt_tse_mac_group_init+0x108>
                pmac_group->channel = psys->tse_num_of_channel;
   294e4:	e0bfff17 	ldw	r2,-4(fp)
   294e8:	10c00303 	ldbu	r3,12(r2)
   294ec:	e0bffd17 	ldw	r2,-12(fp)
   294f0:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = Yes\n");
   294f4:	010000f4 	movhi	r4,3
   294f8:	2107ab04 	addi	r4,r4,7852
   294fc:	0026dc40 	call	26dc4 <no_printf>
                tse_dprintf(6, "INFO    : Number of channel        = %d\n", pmac_group->channel);
   29500:	e0bffd17 	ldw	r2,-12(fp)
   29504:	10800003 	ldbu	r2,0(r2)
   29508:	10803fcc 	andi	r2,r2,255
   2950c:	010000f4 	movhi	r4,3
   29510:	2107b604 	addi	r4,r4,7896
   29514:	100b883a 	mov	r5,r2
   29518:	0026dc40 	call	26dc4 <no_printf>
            	tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
   2951c:	010000f4 	movhi	r4,3
   29520:	2107c104 	addi	r4,r4,7940
   29524:	0026dc40 	call	26dc4 <no_printf>
   29528:	00001f06 	br	295a8 <alt_tse_mac_group_init+0x184>
            }
            else if(psys->tse_mdio_shared) {
   2952c:	e0bfff17 	ldw	r2,-4(fp)
   29530:	10800343 	ldbu	r2,13(r2)
   29534:	10803fcc 	andi	r2,r2,255
   29538:	10001226 	beq	r2,zero,29584 <alt_tse_mac_group_init+0x160>
                pmac_group->channel = psys->tse_number_of_mac_mdio_shared;
   2953c:	e0bfff17 	ldw	r2,-4(fp)
   29540:	10c00383 	ldbu	r3,14(r2)
   29544:	e0bffd17 	ldw	r2,-12(fp)
   29548:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
   2954c:	010000f4 	movhi	r4,3
   29550:	2107cc04 	addi	r4,r4,7984
   29554:	0026dc40 	call	26dc4 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
   29558:	010000f4 	movhi	r4,3
   2955c:	2107c104 	addi	r4,r4,7940
   29560:	0026dc40 	call	26dc4 <no_printf>
                tse_dprintf(6, "INFO    : Number of MAC Share MDIO = %d\n", pmac_group->channel);
   29564:	e0bffd17 	ldw	r2,-12(fp)
   29568:	10800003 	ldbu	r2,0(r2)
   2956c:	10803fcc 	andi	r2,r2,255
   29570:	010000f4 	movhi	r4,3
   29574:	2107d704 	addi	r4,r4,8028
   29578:	100b883a 	mov	r5,r2
   2957c:	0026dc40 	call	26dc4 <no_printf>
   29580:	00000906 	br	295a8 <alt_tse_mac_group_init+0x184>
            }
            else {
                pmac_group->channel = 1;
   29584:	e0bffd17 	ldw	r2,-12(fp)
   29588:	00c00044 	movi	r3,1
   2958c:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
   29590:	010000f4 	movhi	r4,3
   29594:	2107cc04 	addi	r4,r4,7984
   29598:	0026dc40 	call	26dc4 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
   2959c:	010000f4 	movhi	r4,3
   295a0:	2107e204 	addi	r4,r4,8072
   295a4:	0026dc40 	call	26dc4 <no_printf>
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
   295a8:	e03ffc45 	stb	zero,-15(fp)
   295ac:	00012006 	br	29a30 <alt_tse_mac_group_init+0x60c>
                /* Allocate memory for the structure */
                pmac_info = (alt_tse_mac_info *) malloc(sizeof(alt_tse_mac_info));
   295b0:	01000404 	movi	r4,16
   295b4:	002df340 	call	2df34 <malloc>
   295b8:	e0bffe15 	stw	r2,-8(fp)
                if(!pmac_info) {
   295bc:	e0bffe17 	ldw	r2,-8(fp)
   295c0:	10000a1e 	bne	r2,zero,295ec <alt_tse_mac_group_init+0x1c8>
                    tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]->pmac_info[%d]\n", mac_group_count, j);
   295c4:	d0a8df43 	ldbu	r2,-23683(gp)
   295c8:	10c03fcc 	andi	r3,r2,255
   295cc:	e0bffc47 	ldb	r2,-15(fp)
   295d0:	010000f4 	movhi	r4,3
   295d4:	2107ed04 	addi	r4,r4,8116
   295d8:	180b883a 	mov	r5,r3
   295dc:	100d883a 	mov	r6,r2
   295e0:	00193f00 	call	193f0 <printf>
                    return ALTERA_TSE_MALLOC_FAILED;
   295e4:	00bfffc4 	movi	r2,-1
   295e8:	00013006 	br	29aac <alt_tse_mac_group_init+0x688>
                }
                
                pmac_info->pmac_group = pmac_group;
   295ec:	e0bffe17 	ldw	r2,-8(fp)
   295f0:	e0fffd17 	ldw	r3,-12(fp)
   295f4:	10c00315 	stw	r3,12(r2)
                
                pmac_info->pphy_info = 0;
   295f8:	e0bffe17 	ldw	r2,-8(fp)
   295fc:	10000115 	stw	zero,4(r2)
                
                pmac_info->psys_info = &tse_mac_device[i + j];
   29600:	e0fffc07 	ldb	r3,-16(fp)
   29604:	e0bffc47 	ldb	r2,-15(fp)
   29608:	1885883a 	add	r2,r3,r2
   2960c:	10c01224 	muli	r3,r2,72
   29610:	008000f4 	movhi	r2,3
   29614:	108d0b04 	addi	r2,r2,13356
   29618:	1887883a 	add	r3,r3,r2
   2961c:	e0bffe17 	ldw	r2,-8(fp)
   29620:	10c00215 	stw	r3,8(r2)
                
                /* check to make sure the alt_tse_system_info defined correctly or has been defined */
                if((pmac_info->psys_info->tse_sgdma_tx == 0) || (pmac_info->psys_info->tse_sgdma_rx == 0)){                	
   29624:	e0bffe17 	ldw	r2,-8(fp)
   29628:	10800217 	ldw	r2,8(r2)
   2962c:	10800517 	ldw	r2,20(r2)
   29630:	10000426 	beq	r2,zero,29644 <alt_tse_mac_group_init+0x220>
   29634:	e0bffe17 	ldw	r2,-8(fp)
   29638:	10800217 	ldw	r2,8(r2)
   2963c:	10800617 	ldw	r2,24(r2)
   29640:	1000091e 	bne	r2,zero,29668 <alt_tse_mac_group_init+0x244>
                    tse_dprintf(2, "ERROR   : tse_mac_device[%d] does not defined correctly!\n", i + j);
   29644:	e0fffc07 	ldb	r3,-16(fp)
   29648:	e0bffc47 	ldb	r2,-15(fp)
   2964c:	1885883a 	add	r2,r3,r2
   29650:	010000f4 	movhi	r4,3
   29654:	2107ff04 	addi	r4,r4,8188
   29658:	100b883a 	mov	r5,r2
   2965c:	00193f00 	call	193f0 <printf>
                    return ALTERA_TSE_SYSTEM_DEF_ERROR;
   29660:	00bfffc4 	movi	r2,-1
   29664:	00011106 	br	29aac <alt_tse_mac_group_init+0x688>
                }
                
                /* MAC type detection */
                if(pmac_info->psys_info->tse_en_maclite) {
   29668:	e0bffe17 	ldw	r2,-8(fp)
   2966c:	10800217 	ldw	r2,8(r2)
   29670:	10800243 	ldbu	r2,9(r2)
   29674:	10803fcc 	andi	r2,r2,255
   29678:	10000d26 	beq	r2,zero,296b0 <alt_tse_mac_group_init+0x28c>
                    if(pmac_info->psys_info->tse_maclite_gige) {
   2967c:	e0bffe17 	ldw	r2,-8(fp)
   29680:	10800217 	ldw	r2,8(r2)
   29684:	10800283 	ldbu	r2,10(r2)
   29688:	10803fcc 	andi	r2,r2,255
   2968c:	10000426 	beq	r2,zero,296a0 <alt_tse_mac_group_init+0x27c>
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_1000;
   29690:	e0bffe17 	ldw	r2,-8(fp)
   29694:	00c00084 	movi	r3,2
   29698:	10c00005 	stb	r3,0(r2)
   2969c:	00000606 	br	296b8 <alt_tse_mac_group_init+0x294>
                    }
                    else {
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_10_100;
   296a0:	e0bffe17 	ldw	r2,-8(fp)
   296a4:	00c00044 	movi	r3,1
   296a8:	10c00005 	stb	r3,0(r2)
   296ac:	00000206 	br	296b8 <alt_tse_mac_group_init+0x294>
                    }
                }
                else {
                    pmac_info->mac_type = ALTERA_TSE_FULL_MAC;                    
   296b0:	e0bffe17 	ldw	r2,-8(fp)
   296b4:	10000005 	stb	zero,0(r2)
                }
                
                if((pmac_info->psys_info->tse_mdio_shared) && (!pmac_info->psys_info->tse_multichannel_mac)){
   296b8:	e0bffe17 	ldw	r2,-8(fp)
   296bc:	10800217 	ldw	r2,8(r2)
   296c0:	10800343 	ldbu	r2,13(r2)
   296c4:	10803fcc 	andi	r2,r2,255
   296c8:	10006526 	beq	r2,zero,29860 <alt_tse_mac_group_init+0x43c>
   296cc:	e0bffe17 	ldw	r2,-8(fp)
   296d0:	10800217 	ldw	r2,8(r2)
   296d4:	108002c3 	ldbu	r2,11(r2)
   296d8:	10803fcc 	andi	r2,r2,255
   296dc:	1000601e 	bne	r2,zero,29860 <alt_tse_mac_group_init+0x43c>
                	tse_dprintf(6, "INFO    : MAC %2d Address           = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
   296e0:	e0fffc47 	ldb	r3,-15(fp)
   296e4:	e0bffe17 	ldw	r2,-8(fp)
   296e8:	10800217 	ldw	r2,8(r2)
   296ec:	10800017 	ldw	r2,0(r2)
   296f0:	010000f4 	movhi	r4,3
   296f4:	21080e04 	addi	r4,r4,8248
   296f8:	180b883a 	mov	r5,r3
   296fc:	100d883a 	mov	r6,r2
   29700:	0026dc40 	call	26dc4 <no_printf>
                    tse_dprintf(6, "INFO    : MAC %2d Device            = tse_mac_device[%d]\n", j, i + j);
   29704:	e0fffc47 	ldb	r3,-15(fp)
   29708:	e13ffc07 	ldb	r4,-16(fp)
   2970c:	e0bffc47 	ldb	r2,-15(fp)
   29710:	2085883a 	add	r2,r4,r2
   29714:	010000f4 	movhi	r4,3
   29718:	21081a04 	addi	r4,r4,8296
   2971c:	180b883a 	mov	r5,r3
   29720:	100d883a 	mov	r6,r2
   29724:	0026dc40 	call	26dc4 <no_printf>
                    
                	switch(pmac_info->mac_type) {
   29728:	e0bffe17 	ldw	r2,-8(fp)
   2972c:	10800003 	ldbu	r2,0(r2)
   29730:	10803fcc 	andi	r2,r2,255
   29734:	10c00060 	cmpeqi	r3,r2,1
   29738:	18000c1e 	bne	r3,zero,2976c <alt_tse_mac_group_init+0x348>
   2973c:	10c000a0 	cmpeqi	r3,r2,2
   29740:	1800021e 	bne	r3,zero,2974c <alt_tse_mac_group_init+0x328>
   29744:	10001126 	beq	r2,zero,2978c <alt_tse_mac_group_init+0x368>
   29748:	00001806 	br	297ac <alt_tse_mac_group_init+0x388>
                        case ALTERA_TSE_MACLITE_1000:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "1000 Mbps Small MAC");
   2974c:	e0bffc47 	ldb	r2,-15(fp)
   29750:	010000f4 	movhi	r4,3
   29754:	21082904 	addi	r4,r4,8356
   29758:	100b883a 	mov	r5,r2
   2975c:	018000f4 	movhi	r6,3
   29760:	31883404 	addi	r6,r6,8400
   29764:	0026dc40 	call	26dc4 <no_printf>
                            break;
   29768:	00001706 	br	297c8 <alt_tse_mac_group_init+0x3a4>
                        case ALTERA_TSE_MACLITE_10_100:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100 Mbps Small MAC");
   2976c:	e0bffc47 	ldb	r2,-15(fp)
   29770:	010000f4 	movhi	r4,3
   29774:	21082904 	addi	r4,r4,8356
   29778:	100b883a 	mov	r5,r2
   2977c:	018000f4 	movhi	r6,3
   29780:	31883904 	addi	r6,r6,8420
   29784:	0026dc40 	call	26dc4 <no_printf>
                            break;
   29788:	00000f06 	br	297c8 <alt_tse_mac_group_init+0x3a4>
                        case ALTERA_TSE_FULL_MAC:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100/1000 Ethernet MAC");
   2978c:	e0bffc47 	ldb	r2,-15(fp)
   29790:	010000f4 	movhi	r4,3
   29794:	21082904 	addi	r4,r4,8356
   29798:	100b883a 	mov	r5,r2
   2979c:	018000f4 	movhi	r6,3
   297a0:	31883f04 	addi	r6,r6,8444
   297a4:	0026dc40 	call	26dc4 <no_printf>
                            break;
   297a8:	00000706 	br	297c8 <alt_tse_mac_group_init+0x3a4>
                        default :
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "Unknown");
   297ac:	e0bffc47 	ldb	r2,-15(fp)
   297b0:	010000f4 	movhi	r4,3
   297b4:	21082904 	addi	r4,r4,8356
   297b8:	100b883a 	mov	r5,r2
   297bc:	018000f4 	movhi	r6,3
   297c0:	31867704 	addi	r6,r6,6620
   297c4:	0026dc40 	call	26dc4 <no_printf>
                    }
                    
                    if(pmac_info->psys_info->tse_pcs_ena) {
   297c8:	e0bffe17 	ldw	r2,-8(fp)
   297cc:	10800217 	ldw	r2,8(r2)
   297d0:	108003c3 	ldbu	r2,15(r2)
   297d4:	10803fcc 	andi	r2,r2,255
   297d8:	10008a26 	beq	r2,zero,29a04 <alt_tse_mac_group_init+0x5e0>
                        tse_dprintf(6, "INFO    : PCS %2d Enable            = %s\n", j, pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
   297dc:	e0fffc47 	ldb	r3,-15(fp)
   297e0:	e0bffe17 	ldw	r2,-8(fp)
   297e4:	10800217 	ldw	r2,8(r2)
   297e8:	108003c3 	ldbu	r2,15(r2)
   297ec:	10803fcc 	andi	r2,r2,255
   297f0:	10000326 	beq	r2,zero,29800 <alt_tse_mac_group_init+0x3dc>
   297f4:	008000f4 	movhi	r2,3
   297f8:	10884604 	addi	r2,r2,8472
   297fc:	00000206 	br	29808 <alt_tse_mac_group_init+0x3e4>
   29800:	008000f4 	movhi	r2,3
   29804:	10884704 	addi	r2,r2,8476
   29808:	010000f4 	movhi	r4,3
   2980c:	21084804 	addi	r4,r4,8480
   29810:	180b883a 	mov	r5,r3
   29814:	100d883a 	mov	r6,r2
   29818:	0026dc40 	call	26dc4 <no_printf>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
   2981c:	e0fffc47 	ldb	r3,-15(fp)
   29820:	e0bffe17 	ldw	r2,-8(fp)
   29824:	10800217 	ldw	r2,8(r2)
   29828:	10800403 	ldbu	r2,16(r2)
   2982c:	10803fcc 	andi	r2,r2,255
   29830:	10000326 	beq	r2,zero,29840 <alt_tse_mac_group_init+0x41c>
   29834:	008000f4 	movhi	r2,3
   29838:	10884604 	addi	r2,r2,8472
   2983c:	00000206 	br	29848 <alt_tse_mac_group_init+0x424>
   29840:	008000f4 	movhi	r2,3
   29844:	10884704 	addi	r2,r2,8476
   29848:	010000f4 	movhi	r4,3
   2984c:	21085304 	addi	r4,r4,8524
   29850:	180b883a 	mov	r5,r3
   29854:	100d883a 	mov	r6,r2
   29858:	0026dc40 	call	26dc4 <no_printf>
                            break;
                        default :
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "Unknown");
                    }
                    
                    if(pmac_info->psys_info->tse_pcs_ena) {
   2985c:	00006906 	br	29a04 <alt_tse_mac_group_init+0x5e0>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
                    }
                }
                else {
                	/* display only once for all MAC, except shared MDIO MACs */
	                if(j == 0) {
   29860:	e0bffc47 	ldb	r2,-15(fp)
   29864:	1000411e 	bne	r2,zero,2996c <alt_tse_mac_group_init+0x548>
	                    switch(pmac_info->mac_type) {
   29868:	e0bffe17 	ldw	r2,-8(fp)
   2986c:	10800003 	ldbu	r2,0(r2)
   29870:	10803fcc 	andi	r2,r2,255
   29874:	10c00060 	cmpeqi	r3,r2,1
   29878:	18000a1e 	bne	r3,zero,298a4 <alt_tse_mac_group_init+0x480>
   2987c:	10c000a0 	cmpeqi	r3,r2,2
   29880:	1800021e 	bne	r3,zero,2988c <alt_tse_mac_group_init+0x468>
   29884:	10000d26 	beq	r2,zero,298bc <alt_tse_mac_group_init+0x498>
   29888:	00001206 	br	298d4 <alt_tse_mac_group_init+0x4b0>
	                        case ALTERA_TSE_MACLITE_1000:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "1000 Mbps Small MAC");
   2988c:	010000f4 	movhi	r4,3
   29890:	21085e04 	addi	r4,r4,8568
   29894:	014000f4 	movhi	r5,3
   29898:	29483404 	addi	r5,r5,8400
   2989c:	0026dc40 	call	26dc4 <no_printf>
	                            break;
   298a0:	00001106 	br	298e8 <alt_tse_mac_group_init+0x4c4>
	                        case ALTERA_TSE_MACLITE_10_100:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100 Mbps Small MAC");
   298a4:	010000f4 	movhi	r4,3
   298a8:	21085e04 	addi	r4,r4,8568
   298ac:	014000f4 	movhi	r5,3
   298b0:	29483904 	addi	r5,r5,8420
   298b4:	0026dc40 	call	26dc4 <no_printf>
	                            break;
   298b8:	00000b06 	br	298e8 <alt_tse_mac_group_init+0x4c4>
	                        case ALTERA_TSE_FULL_MAC:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100/1000 Ethernet MAC");
   298bc:	010000f4 	movhi	r4,3
   298c0:	21085e04 	addi	r4,r4,8568
   298c4:	014000f4 	movhi	r5,3
   298c8:	29483f04 	addi	r5,r5,8444
   298cc:	0026dc40 	call	26dc4 <no_printf>
	                            break;
   298d0:	00000506 	br	298e8 <alt_tse_mac_group_init+0x4c4>
	                        default :
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "Unknown");
   298d4:	010000f4 	movhi	r4,3
   298d8:	21085e04 	addi	r4,r4,8568
   298dc:	014000f4 	movhi	r5,3
   298e0:	29467704 	addi	r5,r5,6620
   298e4:	0026dc40 	call	26dc4 <no_printf>
	                    }
	                    
	                    if(pmac_info->psys_info->tse_pcs_ena) {
   298e8:	e0bffe17 	ldw	r2,-8(fp)
   298ec:	10800217 	ldw	r2,8(r2)
   298f0:	108003c3 	ldbu	r2,15(r2)
   298f4:	10803fcc 	andi	r2,r2,255
   298f8:	10001c26 	beq	r2,zero,2996c <alt_tse_mac_group_init+0x548>
	                        tse_dprintf(6, "INFO    : PCS Enable               = %s\n", pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
   298fc:	e0bffe17 	ldw	r2,-8(fp)
   29900:	10800217 	ldw	r2,8(r2)
   29904:	108003c3 	ldbu	r2,15(r2)
   29908:	10803fcc 	andi	r2,r2,255
   2990c:	10000326 	beq	r2,zero,2991c <alt_tse_mac_group_init+0x4f8>
   29910:	008000f4 	movhi	r2,3
   29914:	10884604 	addi	r2,r2,8472
   29918:	00000206 	br	29924 <alt_tse_mac_group_init+0x500>
   2991c:	008000f4 	movhi	r2,3
   29920:	10884704 	addi	r2,r2,8476
   29924:	010000f4 	movhi	r4,3
   29928:	21086904 	addi	r4,r4,8612
   2992c:	100b883a 	mov	r5,r2
   29930:	0026dc40 	call	26dc4 <no_printf>
	                        tse_dprintf(6, "INFO    : PCS SGMII Enable         = %s\n", pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");	                        
   29934:	e0bffe17 	ldw	r2,-8(fp)
   29938:	10800217 	ldw	r2,8(r2)
   2993c:	10800403 	ldbu	r2,16(r2)
   29940:	10803fcc 	andi	r2,r2,255
   29944:	10000326 	beq	r2,zero,29954 <alt_tse_mac_group_init+0x530>
   29948:	008000f4 	movhi	r2,3
   2994c:	10884604 	addi	r2,r2,8472
   29950:	00000206 	br	2995c <alt_tse_mac_group_init+0x538>
   29954:	008000f4 	movhi	r2,3
   29958:	10884704 	addi	r2,r2,8476
   2995c:	010000f4 	movhi	r4,3
   29960:	21087404 	addi	r4,r4,8656
   29964:	100b883a 	mov	r5,r2
   29968:	0026dc40 	call	26dc4 <no_printf>
	                    }
	                }
	                
                	if(pmac_info->psys_info->tse_multichannel_mac) {
   2996c:	e0bffe17 	ldw	r2,-8(fp)
   29970:	10800217 	ldw	r2,8(r2)
   29974:	108002c3 	ldbu	r2,11(r2)
   29978:	10803fcc 	andi	r2,r2,255
   2997c:	10001326 	beq	r2,zero,299cc <alt_tse_mac_group_init+0x5a8>
                		tse_dprintf(6, "INFO    : Channel %2d Address       = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
   29980:	e0fffc47 	ldb	r3,-15(fp)
   29984:	e0bffe17 	ldw	r2,-8(fp)
   29988:	10800217 	ldw	r2,8(r2)
   2998c:	10800017 	ldw	r2,0(r2)
   29990:	010000f4 	movhi	r4,3
   29994:	21087f04 	addi	r4,r4,8700
   29998:	180b883a 	mov	r5,r3
   2999c:	100d883a 	mov	r6,r2
   299a0:	0026dc40 	call	26dc4 <no_printf>
	                    tse_dprintf(6, "INFO    : Channel %2d Device        = tse_mac_device[%d]\n", j, i + j);
   299a4:	e0fffc47 	ldb	r3,-15(fp)
   299a8:	e13ffc07 	ldb	r4,-16(fp)
   299ac:	e0bffc47 	ldb	r2,-15(fp)
   299b0:	2085883a 	add	r2,r4,r2
   299b4:	010000f4 	movhi	r4,3
   299b8:	21088b04 	addi	r4,r4,8748
   299bc:	180b883a 	mov	r5,r3
   299c0:	100d883a 	mov	r6,r2
   299c4:	0026dc40 	call	26dc4 <no_printf>
   299c8:	00000e06 	br	29a04 <alt_tse_mac_group_init+0x5e0>
	            	}                
	                else {
	                    tse_dprintf(6, "INFO    : MAC Address              = 0x%08x\n", (int) pmac_info->psys_info->tse_mac_base);
   299cc:	e0bffe17 	ldw	r2,-8(fp)
   299d0:	10800217 	ldw	r2,8(r2)
   299d4:	10800017 	ldw	r2,0(r2)
   299d8:	010000f4 	movhi	r4,3
   299dc:	21089a04 	addi	r4,r4,8808
   299e0:	100b883a 	mov	r5,r2
   299e4:	0026dc40 	call	26dc4 <no_printf>
	                    tse_dprintf(6, "INFO    : MAC Device               = tse_mac_device[%d]\n", i + j);
   299e8:	e0fffc07 	ldb	r3,-16(fp)
   299ec:	e0bffc47 	ldb	r2,-15(fp)
   299f0:	1885883a 	add	r2,r3,r2
   299f4:	010000f4 	movhi	r4,3
   299f8:	2108a604 	addi	r4,r4,8856
   299fc:	100b883a 	mov	r5,r2
   29a00:	0026dc40 	call	26dc4 <no_printf>
	                }
                }
                
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
   29a04:	e0bffc47 	ldb	r2,-15(fp)
   29a08:	e0fffd17 	ldw	r3,-12(fp)
   29a0c:	10800044 	addi	r2,r2,1
   29a10:	1085883a 	add	r2,r2,r2
   29a14:	1085883a 	add	r2,r2,r2
   29a18:	1885883a 	add	r2,r3,r2
   29a1c:	e0fffe17 	ldw	r3,-8(fp)
   29a20:	10c00015 	stw	r3,0(r2)
                pmac_group->channel = 1;
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
   29a24:	e0bffc43 	ldbu	r2,-15(fp)
   29a28:	10800044 	addi	r2,r2,1
   29a2c:	e0bffc45 	stb	r2,-15(fp)
   29a30:	e0fffc47 	ldb	r3,-15(fp)
   29a34:	e0bffd17 	ldw	r2,-12(fp)
   29a38:	10800003 	ldbu	r2,0(r2)
   29a3c:	10803fcc 	andi	r2,r2,255
   29a40:	18bedb16 	blt	r3,r2,295b0 <alt_tse_mac_group_init+0x18c>
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
            }
            
            /* store the pointer in global variable */
            pmac_groups[mac_group_count] = pmac_group;
   29a44:	d0a8df43 	ldbu	r2,-23683(gp)
   29a48:	10803fcc 	andi	r2,r2,255
   29a4c:	00c00234 	movhi	r3,8
   29a50:	18c41204 	addi	r3,r3,4168
   29a54:	1085883a 	add	r2,r2,r2
   29a58:	1085883a 	add	r2,r2,r2
   29a5c:	1885883a 	add	r2,r3,r2
   29a60:	e0fffd17 	ldw	r3,-12(fp)
   29a64:	10c00015 	stw	r3,0(r2)
            
            mac_group_count++;
   29a68:	d0a8df43 	ldbu	r2,-23683(gp)
   29a6c:	10800044 	addi	r2,r2,1
   29a70:	d0a8df45 	stb	r2,-23683(gp)

            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
   29a74:	e0bffd17 	ldw	r2,-12(fp)
   29a78:	10c00003 	ldbu	r3,0(r2)
   29a7c:	e0bffc03 	ldbu	r2,-16(fp)
   29a80:	1885883a 	add	r2,r3,r2
   29a84:	10bfffc4 	addi	r2,r2,-1
   29a88:	e0bffc05 	stb	r2,-16(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
   29a8c:	e0bffc03 	ldbu	r2,-16(fp)
   29a90:	10800044 	addi	r2,r2,1
   29a94:	e0bffc05 	stb	r2,-16(fp)
   29a98:	e0fffc07 	ldb	r3,-16(fp)
   29a9c:	d0a01d03 	ldbu	r2,-32652(gp)
   29aa0:	10803fcc 	andi	r2,r2,255
   29aa4:	18be6916 	blt	r3,r2,2944c <alt_tse_mac_group_init+0x28>
            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
                        
        }
    }
    return SUCCESS;
   29aa8:	0005883a 	mov	r2,zero
}
   29aac:	e037883a 	mov	sp,fp
   29ab0:	dfc00117 	ldw	ra,4(sp)
   29ab4:	df000017 	ldw	fp,0(sp)
   29ab8:	dec00204 	addi	sp,sp,8
   29abc:	f800283a 	ret

00029ac0 <alt_tse_mac_get_phy>:
/* @Function Description: Store information of all the PHYs connected to MAC to phy_list
 * @API Type:         Internal
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @return            Number of PHY not in profile, return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 */
alt_32 alt_tse_mac_get_phy(alt_tse_mac_group *pmac_group) {
   29ac0:	deffed04 	addi	sp,sp,-76
   29ac4:	dfc01215 	stw	ra,72(sp)
   29ac8:	df001115 	stw	fp,68(sp)
   29acc:	df001104 	addi	fp,sp,68
   29ad0:	e13fff15 	stw	r4,-4(fp)
    
	alt_32 phyid; 
	alt_32 phyid2 = 0;
   29ad4:	e03ff515 	stw	zero,-44(fp)
    alt_u8 revision_number;

    alt_32 i;

    alt_u8 is_phy_in_profile;
    alt_32 return_value = 0;
   29ad8:	e03ff315 	stw	zero,-52(fp)
    
    alt_8 phy_info_count = 0;
   29adc:	e03ff405 	stb	zero,-48(fp)
    
    alt_tse_phy_info *pphy = 0;
   29ae0:	e03ff615 	stw	zero,-40(fp)
    alt_tse_mac_info *pmac_info = 0;
   29ae4:	e03ff715 	stw	zero,-36(fp)
    alt_tse_system_info *psys = 0;
   29ae8:	e03ff815 	stw	zero,-32(fp)
    
    np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   29aec:	e0bfff17 	ldw	r2,-4(fp)
   29af0:	10800117 	ldw	r2,4(r2)
   29af4:	10800217 	ldw	r2,8(r2)
   29af8:	10800017 	ldw	r2,0(r2)
   29afc:	e0bff915 	stw	r2,-28(fp)
            
    /* Record previous MDIO address, to be restored at the end of function */
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
   29b00:	e0bff917 	ldw	r2,-28(fp)
   29b04:	10801004 	addi	r2,r2,64
   29b08:	10800037 	ldwio	r2,0(r2)
   29b0c:	e0bffa15 	stw	r2,-24(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   29b10:	e13fff17 	ldw	r4,-4(fp)
   29b14:	0027f380 	call	27f38 <alt_tse_get_mac_group_index>
   29b18:	e0bffb05 	stb	r2,-20(fp)
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x00; phyadd < 0x20; phyadd++)
   29b1c:	e03ff005 	stb	zero,-64(fp)
   29b20:	0000ca06 	br	29e4c <alt_tse_mac_get_phy+0x38c>
    {        
        IOWR(&pmac_group_base->MDIO_ADDR1, 0, phyadd);
   29b24:	e0bff917 	ldw	r2,-28(fp)
   29b28:	10801004 	addi	r2,r2,64
   29b2c:	e0fff003 	ldbu	r3,-64(fp)
   29b30:	10c00035 	stwio	r3,0(r2)
        phyid = IORD(&pmac_group_base->mdio1.PHY_ID1,0);     // read PHY ID
   29b34:	e0bff917 	ldw	r2,-28(fp)
   29b38:	1080a204 	addi	r2,r2,648
   29b3c:	10800037 	ldwio	r2,0(r2)
   29b40:	e0bffc15 	stw	r2,-16(fp)
        phyid2 = IORD(&pmac_group_base->mdio1.PHY_ID2,0);     // read PHY ID
   29b44:	e0bff917 	ldw	r2,-28(fp)
   29b48:	1080a304 	addi	r2,r2,652
   29b4c:	10800037 	ldwio	r2,0(r2)
   29b50:	e0bff515 	stw	r2,-44(fp)
        
        /* PHY found */
        if (phyid != phyid2)
   29b54:	e0fffc17 	ldw	r3,-16(fp)
   29b58:	e0bff517 	ldw	r2,-44(fp)
   29b5c:	1880b826 	beq	r3,r2,29e40 <alt_tse_mac_get_phy+0x380>
        {
            pphy = (alt_tse_phy_info *) malloc(sizeof(alt_tse_phy_info));
   29b60:	01000704 	movi	r4,28
   29b64:	002df340 	call	2df34 <malloc>
   29b68:	e0bff615 	stw	r2,-40(fp)
            if(!pphy) {
   29b6c:	e0bff617 	ldw	r2,-40(fp)
   29b70:	1000091e 	bne	r2,zero,29b98 <alt_tse_mac_get_phy+0xd8>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for phy_info[%d.%d]\n", mac_group_index, phy_info_count);
   29b74:	e0fffb07 	ldb	r3,-20(fp)
   29b78:	e0bff407 	ldb	r2,-48(fp)
   29b7c:	010000f4 	movhi	r4,3
   29b80:	2108b504 	addi	r4,r4,8916
   29b84:	180b883a 	mov	r5,r3
   29b88:	100d883a 	mov	r6,r2
   29b8c:	00193f00 	call	193f0 <printf>
                return ALTERA_TSE_MALLOC_FAILED;
   29b90:	00bfffc4 	movi	r2,-1
   29b94:	0000cc06 	br	29ec8 <alt_tse_mac_get_phy+0x408>
            }
            
            /* store PHY address */
            pphy->mdio_address = phyadd;
   29b98:	e0bff617 	ldw	r2,-40(fp)
   29b9c:	e0fff003 	ldbu	r3,-64(fp)
   29ba0:	10c00005 	stb	r3,0(r2)

            /* get oui, model number, and revision number from PHYID and PHYID2 */
            oui = (phyid << 6) | ((phyid2 >> 10) & 0x3f);
   29ba4:	e0bffc17 	ldw	r2,-16(fp)
   29ba8:	100691ba 	slli	r3,r2,6
   29bac:	e0bff517 	ldw	r2,-44(fp)
   29bb0:	1005d2ba 	srai	r2,r2,10
   29bb4:	10800fcc 	andi	r2,r2,63
   29bb8:	1884b03a 	or	r2,r3,r2
   29bbc:	e0bffd15 	stw	r2,-12(fp)
            model_number = (phyid2 >> 4) & 0x3f;
   29bc0:	e0bff517 	ldw	r2,-44(fp)
   29bc4:	1005d13a 	srai	r2,r2,4
   29bc8:	10800fcc 	andi	r2,r2,63
   29bcc:	e0bffe05 	stb	r2,-8(fp)
            revision_number = phyid2 & 0x0f;
   29bd0:	e0bff517 	ldw	r2,-44(fp)
   29bd4:	108003cc 	andi	r2,r2,15
   29bd8:	e0bffe45 	stb	r2,-7(fp)
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
   29bdc:	e03ff205 	stb	zero,-56(fp)
            for(i = 0; i < phy_profile_count; i++) {
   29be0:	e03ff115 	stw	zero,-60(fp)
   29be4:	00003306 	br	29cb4 <alt_tse_mac_get_phy+0x1f4>
                
                /* if PHY match with PHY in profile */
                if((pphy_profiles[i]->oui == oui) && (pphy_profiles[i]->model_number == model_number))
   29be8:	00c00234 	movhi	r3,8
   29bec:	18c41a04 	addi	r3,r3,4200
   29bf0:	e0bff117 	ldw	r2,-60(fp)
   29bf4:	1085883a 	add	r2,r2,r2
   29bf8:	1085883a 	add	r2,r2,r2
   29bfc:	1885883a 	add	r2,r3,r2
   29c00:	10800017 	ldw	r2,0(r2)
   29c04:	10c01417 	ldw	r3,80(r2)
   29c08:	e0bffd17 	ldw	r2,-12(fp)
   29c0c:	1880261e 	bne	r3,r2,29ca8 <alt_tse_mac_get_phy+0x1e8>
   29c10:	00c00234 	movhi	r3,8
   29c14:	18c41a04 	addi	r3,r3,4200
   29c18:	e0bff117 	ldw	r2,-60(fp)
   29c1c:	1085883a 	add	r2,r2,r2
   29c20:	1085883a 	add	r2,r2,r2
   29c24:	1885883a 	add	r2,r3,r2
   29c28:	10800017 	ldw	r2,0(r2)
   29c2c:	10801503 	ldbu	r2,84(r2)
   29c30:	10c03fcc 	andi	r3,r2,255
   29c34:	e0bffe03 	ldbu	r2,-8(fp)
   29c38:	18801b1e 	bne	r3,r2,29ca8 <alt_tse_mac_get_phy+0x1e8>
                {
                    pphy->pphy_profile = pphy_profiles[i];
   29c3c:	00c00234 	movhi	r3,8
   29c40:	18c41a04 	addi	r3,r3,4200
   29c44:	e0bff117 	ldw	r2,-60(fp)
   29c48:	1085883a 	add	r2,r2,r2
   29c4c:	1085883a 	add	r2,r2,r2
   29c50:	1885883a 	add	r2,r3,r2
   29c54:	10c00017 	ldw	r3,0(r2)
   29c58:	e0bff617 	ldw	r2,-40(fp)
   29c5c:	10c00515 	stw	r3,20(r2)
                    
                    /* PHY found, add it to phy_list */
                    tse_dprintf(5, "INFO    : PHY %s found at PHY address 0x%02x of MAC Group[%d]\n", pphy_profiles[i]->name, phyadd, mac_group_index);
   29c60:	00c00234 	movhi	r3,8
   29c64:	18c41a04 	addi	r3,r3,4200
   29c68:	e0bff117 	ldw	r2,-60(fp)
   29c6c:	1085883a 	add	r2,r2,r2
   29c70:	1085883a 	add	r2,r2,r2
   29c74:	1885883a 	add	r2,r3,r2
   29c78:	10800017 	ldw	r2,0(r2)
   29c7c:	100b883a 	mov	r5,r2
   29c80:	e0fff003 	ldbu	r3,-64(fp)
   29c84:	e0bffb07 	ldb	r2,-20(fp)
   29c88:	010000f4 	movhi	r4,3
   29c8c:	2108c404 	addi	r4,r4,8976
   29c90:	180d883a 	mov	r6,r3
   29c94:	100f883a 	mov	r7,r2
   29c98:	00193f00 	call	193f0 <printf>
                    is_phy_in_profile = 1;
   29c9c:	00800044 	movi	r2,1
   29ca0:	e0bff205 	stb	r2,-56(fp)
                    break;
   29ca4:	00000706 	br	29cc4 <alt_tse_mac_get_phy+0x204>
            model_number = (phyid2 >> 4) & 0x3f;
            revision_number = phyid2 & 0x0f;
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
            for(i = 0; i < phy_profile_count; i++) {
   29ca8:	e0bff117 	ldw	r2,-60(fp)
   29cac:	10800044 	addi	r2,r2,1
   29cb0:	e0bff115 	stw	r2,-60(fp)
   29cb4:	d0a8df03 	ldbu	r2,-23684(gp)
   29cb8:	10803fcc 	andi	r2,r2,255
   29cbc:	e0fff117 	ldw	r3,-60(fp)
   29cc0:	18bfc916 	blt	r3,r2,29be8 <alt_tse_mac_get_phy+0x128>
                    is_phy_in_profile = 1;
                    break;
                }
            }
            /* PHY not found in PHY profile */
            if(is_phy_in_profile == 0) {
   29cc4:	e0bff203 	ldbu	r2,-56(fp)
   29cc8:	10000f1e 	bne	r2,zero,29d08 <alt_tse_mac_get_phy+0x248>
                pphy->pphy_profile = 0;
   29ccc:	e0bff617 	ldw	r2,-40(fp)
   29cd0:	10000515 	stw	zero,20(r2)
                tse_dprintf(3, "WARNING : Unknown PHY found at PHY address 0x%02x of MAC Group[%d]\n", phyadd, mac_group_index);
   29cd4:	e0fff003 	ldbu	r3,-64(fp)
   29cd8:	e0bffb07 	ldb	r2,-20(fp)
   29cdc:	010000f4 	movhi	r4,3
   29ce0:	2108d404 	addi	r4,r4,9040
   29ce4:	180b883a 	mov	r5,r3
   29ce8:	100d883a 	mov	r6,r2
   29cec:	00193f00 	call	193f0 <printf>
                tse_dprintf(3, "WARNING : Please add PHY information to PHY profile\n");
   29cf0:	010000f4 	movhi	r4,3
   29cf4:	2108e504 	addi	r4,r4,9108
   29cf8:	001965c0 	call	1965c <puts>
                return_value++;
   29cfc:	e0bff317 	ldw	r2,-52(fp)
   29d00:	10800044 	addi	r2,r2,1
   29d04:	e0bff315 	stw	r2,-52(fp)
            }
            
            tse_dprintf(6, "INFO    : PHY OUI             =  0x%06x\n", (int) oui);
   29d08:	e0bffd17 	ldw	r2,-12(fp)
   29d0c:	010000f4 	movhi	r4,3
   29d10:	2108f204 	addi	r4,r4,9160
   29d14:	100b883a 	mov	r5,r2
   29d18:	0026dc40 	call	26dc4 <no_printf>
            tse_dprintf(6, "INFO    : PHY Model Number    =  0x%02x\n", model_number);
   29d1c:	e0bffe03 	ldbu	r2,-8(fp)
   29d20:	010000f4 	movhi	r4,3
   29d24:	2108fd04 	addi	r4,r4,9204
   29d28:	100b883a 	mov	r5,r2
   29d2c:	0026dc40 	call	26dc4 <no_printf>
            tse_dprintf(6, "INFO    : PHY Revision Number =  0x%01x\n", revision_number);
   29d30:	e0bffe43 	ldbu	r2,-7(fp)
   29d34:	010000f4 	movhi	r4,3
   29d38:	21090804 	addi	r4,r4,9248
   29d3c:	100b883a 	mov	r5,r2
   29d40:	0026dc40 	call	26dc4 <no_printf>
            
            /* map the detected PHY to connected MAC */
            if(alt_tse_mac_associate_phy(pmac_group, pphy) == TSE_PHY_MAP_SUCCESS) {
   29d44:	e13fff17 	ldw	r4,-4(fp)
   29d48:	e17ff617 	ldw	r5,-40(fp)
   29d4c:	0029edc0 	call	29edc <alt_tse_mac_associate_phy>
   29d50:	1000351e 	bne	r2,zero,29e28 <alt_tse_mac_get_phy+0x368>
            	
            	pmac_info = pphy->pmac_info;
   29d54:	e0bff617 	ldw	r2,-40(fp)
   29d58:	10800617 	ldw	r2,24(r2)
   29d5c:	e0bff715 	stw	r2,-36(fp)
            	psys = pmac_info->psys_info;
   29d60:	e0bff717 	ldw	r2,-36(fp)
   29d64:	10800217 	ldw	r2,8(r2)
   29d68:	e0bff815 	stw	r2,-32(fp)
            	
            	/* Disable PHY loopback to allow Auto-Negotiation completed */
    	        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
   29d6c:	d8000015 	stw	zero,0(sp)
   29d70:	e13ff617 	ldw	r4,-40(fp)
   29d74:	000b883a 	mov	r5,zero
   29d78:	01800384 	movi	r6,14
   29d7c:	01c00044 	movi	r7,1
   29d80:	0028d840 	call	28d84 <alt_tse_phy_wr_mdio_reg>
				
				/* Reset auto-negotiation advertisement */
				alt_tse_phy_set_adv_1000(pphy, 1);
   29d84:	e13ff617 	ldw	r4,-40(fp)
   29d88:	01400044 	movi	r5,1
   29d8c:	002ac180 	call	2ac18 <alt_tse_phy_set_adv_1000>
				alt_tse_phy_set_adv_100(pphy, 1);
   29d90:	e13ff617 	ldw	r4,-40(fp)
   29d94:	01400044 	movi	r5,1
   29d98:	002add40 	call	2add4 <alt_tse_phy_set_adv_100>
				alt_tse_phy_set_adv_10(pphy, 1);
   29d9c:	e13ff617 	ldw	r4,-40(fp)
   29da0:	01400044 	movi	r5,1
   29da4:	002b01c0 	call	2b01c <alt_tse_phy_set_adv_10>
            	            	
	            /* check link connection for this PHY */
	            alt_tse_phy_restart_an(pphy, ALTERA_CHECKLINK_TIMEOUT_THRESHOLD);
   29da8:	e13ff617 	ldw	r4,-40(fp)
   29dac:	014003f4 	movhi	r5,15
   29db0:	29509004 	addi	r5,r5,16960
   29db4:	002a35c0 	call	2a35c <alt_tse_phy_restart_an>
	            
	            /* Perform additional setting if there is any */
	            /* Profile specific */
	            if(pphy->pphy_profile) {
   29db8:	e0bff617 	ldw	r2,-40(fp)
   29dbc:	10800517 	ldw	r2,20(r2)
   29dc0:	10000f26 	beq	r2,zero,29e00 <alt_tse_mac_get_phy+0x340>
		            if(pphy->pphy_profile->phy_cfg) {
   29dc4:	e0bff617 	ldw	r2,-40(fp)
   29dc8:	10800517 	ldw	r2,20(r2)
   29dcc:	10801717 	ldw	r2,92(r2)
   29dd0:	10000b26 	beq	r2,zero,29e00 <alt_tse_mac_get_phy+0x340>
		                tse_dprintf(6, "INFO    : Applying additional PHY configuration of %s\n", pphy->pphy_profile->name);
   29dd4:	e0bff617 	ldw	r2,-40(fp)
   29dd8:	10800517 	ldw	r2,20(r2)
   29ddc:	010000f4 	movhi	r4,3
   29de0:	21091304 	addi	r4,r4,9292
   29de4:	100b883a 	mov	r5,r2
   29de8:	0026dc40 	call	26dc4 <no_printf>
		                pphy->pphy_profile->phy_cfg(pmac_group_base);
   29dec:	e0bff617 	ldw	r2,-40(fp)
   29df0:	10800517 	ldw	r2,20(r2)
   29df4:	10801717 	ldw	r2,92(r2)
   29df8:	e13ff917 	ldw	r4,-28(fp)
   29dfc:	103ee83a 	callr	r2
		            }
	            }
	            
	            /* Initialize PHY, call user's function pointer in alt_tse_system_info structure */
	            /* Individual PHY specific */
            	if(psys->tse_phy_cfg) {
   29e00:	e0bff817 	ldw	r2,-32(fp)
   29e04:	10801117 	ldw	r2,68(r2)
   29e08:	10000726 	beq	r2,zero,29e28 <alt_tse_mac_get_phy+0x368>
            		tse_dprintf(6, "INFO    : Applying additional user PHY configuration\n");
   29e0c:	010000f4 	movhi	r4,3
   29e10:	21092104 	addi	r4,r4,9348
   29e14:	0026dc40 	call	26dc4 <no_printf>
            		psys->tse_phy_cfg(pmac_group_base);
   29e18:	e0bff817 	ldw	r2,-32(fp)
   29e1c:	10801117 	ldw	r2,68(r2)
   29e20:	e13ff917 	ldw	r4,-28(fp)
   29e24:	103ee83a 	callr	r2
            	}
            }
            
            tse_dprintf(6, "\n");
   29e28:	010000f4 	movhi	r4,3
   29e2c:	21092f04 	addi	r4,r4,9404
   29e30:	0026dc40 	call	26dc4 <no_printf>
	            
            phy_info_count++;
   29e34:	e0bff403 	ldbu	r2,-48(fp)
   29e38:	10800044 	addi	r2,r2,1
   29e3c:	e0bff405 	stb	r2,-48(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x00; phyadd < 0x20; phyadd++)
   29e40:	e0bff003 	ldbu	r2,-64(fp)
   29e44:	10800044 	addi	r2,r2,1
   29e48:	e0bff005 	stb	r2,-64(fp)
   29e4c:	e0bff003 	ldbu	r2,-64(fp)
   29e50:	10800830 	cmpltui	r2,r2,32
   29e54:	103f331e 	bne	r2,zero,29b24 <alt_tse_mac_get_phy+0x64>
            phy_info_count++;
        }
    }
    
    /* check to verify the number of connected PHY match the number of channel */
    if(pmac_group->channel != phy_info_count) {
   29e58:	e0bfff17 	ldw	r2,-4(fp)
   29e5c:	10800003 	ldbu	r2,0(r2)
   29e60:	10c03fcc 	andi	r3,r2,255
   29e64:	e0bff407 	ldb	r2,-48(fp)
   29e68:	18801226 	beq	r3,r2,29eb4 <alt_tse_mac_get_phy+0x3f4>
        if(phy_info_count == 0) {
   29e6c:	e0bff407 	ldb	r2,-48(fp)
   29e70:	1000061e 	bne	r2,zero,29e8c <alt_tse_mac_get_phy+0x3cc>
            tse_dprintf(2, "ERROR   : MAC Group[%d] - No PHY connected!\n", mac_group_index);
   29e74:	e0bffb07 	ldb	r2,-20(fp)
   29e78:	010000f4 	movhi	r4,3
   29e7c:	21093004 	addi	r4,r4,9408
   29e80:	100b883a 	mov	r5,r2
   29e84:	00193f00 	call	193f0 <printf>
   29e88:	00000a06 	br	29eb4 <alt_tse_mac_get_phy+0x3f4>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Group[%d] - Number of PHY connected is not equal to the number of channel, Number of PHY : %d, Channel : %d\n", mac_group_index, phy_info_count, pmac_group->channel);
   29e8c:	e17ffb07 	ldb	r5,-20(fp)
   29e90:	e0fff407 	ldb	r3,-48(fp)
   29e94:	e0bfff17 	ldw	r2,-4(fp)
   29e98:	10800003 	ldbu	r2,0(r2)
   29e9c:	10803fcc 	andi	r2,r2,255
   29ea0:	010000f4 	movhi	r4,3
   29ea4:	21093c04 	addi	r4,r4,9456
   29ea8:	180d883a 	mov	r6,r3
   29eac:	100f883a 	mov	r7,r2
   29eb0:	00193f00 	call	193f0 <printf>
        }
    }
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
   29eb4:	e0bff917 	ldw	r2,-28(fp)
   29eb8:	10801004 	addi	r2,r2,64
   29ebc:	e0fffa17 	ldw	r3,-24(fp)
   29ec0:	10c00035 	stwio	r3,0(r2)
    
    return return_value;
   29ec4:	e0bff317 	ldw	r2,-52(fp)
}
   29ec8:	e037883a 	mov	sp,fp
   29ecc:	dfc00117 	ldw	ra,4(sp)
   29ed0:	df000017 	ldw	fp,0(sp)
   29ed4:	dec00204 	addi	sp,sp,8
   29ed8:	f800283a 	ret

00029edc <alt_tse_mac_associate_phy>:
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @param pphy        Pointer to the TSE PHY info structure which hold information of PHY
 * @return            return TSE_PHY_MAP_ERROR if mapping error
 *                    return TSE_PHY_MAP_SUCCESS otherwise
 */
alt_32 alt_tse_mac_associate_phy(alt_tse_mac_group *pmac_group, alt_tse_phy_info *pphy) {
   29edc:	defff604 	addi	sp,sp,-40
   29ee0:	dfc00915 	stw	ra,36(sp)
   29ee4:	df000815 	stw	fp,32(sp)
   29ee8:	df000804 	addi	fp,sp,32
   29eec:	e13ffe15 	stw	r4,-8(fp)
   29ef0:	e17fff15 	stw	r5,-4(fp)
    
	alt_32 i;
	alt_32 return_value = TSE_PHY_MAP_SUCCESS;
   29ef4:	e03ff915 	stw	zero,-28(fp)
    
	alt_u8 is_mapped;

    alt_tse_system_info *psys = 0;
   29ef8:	e03ffb15 	stw	zero,-20(fp)
    alt_tse_mac_info *pmac_info = 0;
   29efc:	e03ffc15 	stw	zero,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
   29f00:	e03ffd05 	stb	zero,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   29f04:	e13ffe17 	ldw	r4,-8(fp)
   29f08:	0027f380 	call	27f38 <alt_tse_get_mac_group_index>
   29f0c:	e0bffd45 	stb	r2,-11(fp)
    alt_8 sys_info_index = 0;
   29f10:	e03ffd85 	stb	zero,-10(fp)
    
    is_mapped = 0;
   29f14:	e03ffa05 	stb	zero,-24(fp)
    
    for(i = 0; i < pmac_group->channel; i++) {
   29f18:	e03ff815 	stw	zero,-32(fp)
   29f1c:	00002b06 	br	29fcc <alt_tse_mac_associate_phy+0xf0>
        pmac_info = pmac_group->pmac_info[i];
   29f20:	e0fffe17 	ldw	r3,-8(fp)
   29f24:	e0bff817 	ldw	r2,-32(fp)
   29f28:	10800044 	addi	r2,r2,1
   29f2c:	1085883a 	add	r2,r2,r2
   29f30:	1085883a 	add	r2,r2,r2
   29f34:	1885883a 	add	r2,r3,r2
   29f38:	10800017 	ldw	r2,0(r2)
   29f3c:	e0bffc15 	stw	r2,-16(fp)
        psys = pmac_info->psys_info;
   29f40:	e0bffc17 	ldw	r2,-16(fp)
   29f44:	10800217 	ldw	r2,8(r2)
   29f48:	e0bffb15 	stw	r2,-20(fp)
       
        /* map according to the PHY address in alt_tse_system_info.h */
        if(psys->tse_phy_mdio_address == pphy->mdio_address) {
   29f4c:	e0bffb17 	ldw	r2,-20(fp)
   29f50:	10c01017 	ldw	r3,64(r2)
   29f54:	e0bfff17 	ldw	r2,-4(fp)
   29f58:	10800003 	ldbu	r2,0(r2)
   29f5c:	10803fcc 	andi	r2,r2,255
   29f60:	1880171e 	bne	r3,r2,29fc0 <alt_tse_mac_associate_phy+0xe4>
        	mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   29f64:	e13ffc17 	ldw	r4,-16(fp)
   29f68:	0027fac0 	call	27fac <alt_tse_get_mac_info_index>
   29f6c:	e0bffd05 	stb	r2,-12(fp)
	        sys_info_index = alt_tse_get_system_index(psys);
   29f70:	e13ffb17 	ldw	r4,-20(fp)
   29f74:	0027ecc0 	call	27ecc <alt_tse_get_system_index>
   29f78:	e0bffd85 	stb	r2,-10(fp)
	        
            pmac_info->pphy_info = pphy;
   29f7c:	e0bffc17 	ldw	r2,-16(fp)
   29f80:	e0ffff17 	ldw	r3,-4(fp)
   29f84:	10c00115 	stw	r3,4(r2)
            pphy->pmac_info = pmac_info;
   29f88:	e0bfff17 	ldw	r2,-4(fp)
   29f8c:	e0fffc17 	ldw	r3,-16(fp)
   29f90:	10c00615 	stw	r3,24(r2)
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Explicitly mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
   29f94:	e17ffd47 	ldb	r5,-11(fp)
   29f98:	e0fffd07 	ldb	r3,-12(fp)
   29f9c:	e0bffd87 	ldb	r2,-10(fp)
   29fa0:	010000f4 	movhi	r4,3
   29fa4:	21095b04 	addi	r4,r4,9580
   29fa8:	180d883a 	mov	r6,r3
   29fac:	100f883a 	mov	r7,r2
   29fb0:	00193f00 	call	193f0 <printf>
            is_mapped = 1;
   29fb4:	00800044 	movi	r2,1
   29fb8:	e0bffa05 	stb	r2,-24(fp)
            break;
   29fbc:	00000806 	br	29fe0 <alt_tse_mac_associate_phy+0x104>
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    alt_8 sys_info_index = 0;
    
    is_mapped = 0;
    
    for(i = 0; i < pmac_group->channel; i++) {
   29fc0:	e0bff817 	ldw	r2,-32(fp)
   29fc4:	10800044 	addi	r2,r2,1
   29fc8:	e0bff815 	stw	r2,-32(fp)
   29fcc:	e0bffe17 	ldw	r2,-8(fp)
   29fd0:	10800003 	ldbu	r2,0(r2)
   29fd4:	10803fcc 	andi	r2,r2,255
   29fd8:	e0fff817 	ldw	r3,-32(fp)
   29fdc:	18bfd016 	blt	r3,r2,29f20 <alt_tse_mac_associate_phy+0x44>
            break;
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
   29fe0:	e0bffa03 	ldbu	r2,-24(fp)
   29fe4:	10003c1e 	bne	r2,zero,2a0d8 <alt_tse_mac_associate_phy+0x1fc>
        for(i = 0; i < pmac_group->channel; i++) {
   29fe8:	e03ff815 	stw	zero,-32(fp)
   29fec:	00003506 	br	2a0c4 <alt_tse_mac_associate_phy+0x1e8>
            pmac_info = pmac_group->pmac_info[i];
   29ff0:	e0fffe17 	ldw	r3,-8(fp)
   29ff4:	e0bff817 	ldw	r2,-32(fp)
   29ff8:	10800044 	addi	r2,r2,1
   29ffc:	1085883a 	add	r2,r2,r2
   2a000:	1085883a 	add	r2,r2,r2
   2a004:	1885883a 	add	r2,r3,r2
   2a008:	10800017 	ldw	r2,0(r2)
   2a00c:	e0bffc15 	stw	r2,-16(fp)
            psys = pmac_info->psys_info;
   2a010:	e0bffc17 	ldw	r2,-16(fp)
   2a014:	10800217 	ldw	r2,8(r2)
   2a018:	e0bffb15 	stw	r2,-20(fp)
            
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
   2a01c:	e0bffb17 	ldw	r2,-20(fp)
   2a020:	10800517 	ldw	r2,20(r2)
   2a024:	10002326 	beq	r2,zero,2a0b4 <alt_tse_mac_associate_phy+0x1d8>
   2a028:	e0bffb17 	ldw	r2,-20(fp)
   2a02c:	10800617 	ldw	r2,24(r2)
   2a030:	10002026 	beq	r2,zero,2a0b4 <alt_tse_mac_associate_phy+0x1d8>
            	continue;
            }
            
            if(psys->tse_phy_mdio_address == TSE_PHY_AUTO_ADDRESS) {
   2a034:	e0bffb17 	ldw	r2,-20(fp)
   2a038:	10801017 	ldw	r2,64(r2)
   2a03c:	10bfffd8 	cmpnei	r2,r2,-1
   2a040:	10001d1e 	bne	r2,zero,2a0b8 <alt_tse_mac_associate_phy+0x1dc>
                mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   2a044:	e13ffc17 	ldw	r4,-16(fp)
   2a048:	0027fac0 	call	27fac <alt_tse_get_mac_info_index>
   2a04c:	e0bffd05 	stb	r2,-12(fp)
                sys_info_index = alt_tse_get_system_index(psys);
   2a050:	e13ffb17 	ldw	r4,-20(fp)
   2a054:	0027ecc0 	call	27ecc <alt_tse_get_system_index>
   2a058:	e0bffd85 	stb	r2,-10(fp)
                
                pmac_info->pphy_info = pphy;
   2a05c:	e0bffc17 	ldw	r2,-16(fp)
   2a060:	e0ffff17 	ldw	r3,-4(fp)
   2a064:	10c00115 	stw	r3,4(r2)
                pphy->pmac_info = pmac_info;
   2a068:	e0bfff17 	ldw	r2,-4(fp)
   2a06c:	e0fffc17 	ldw	r3,-16(fp)
   2a070:	10c00615 	stw	r3,24(r2)
                psys->tse_phy_mdio_address = pphy->mdio_address;
   2a074:	e0bfff17 	ldw	r2,-4(fp)
   2a078:	10800003 	ldbu	r2,0(r2)
   2a07c:	10c03fcc 	andi	r3,r2,255
   2a080:	e0bffb17 	ldw	r2,-20(fp)
   2a084:	10c01015 	stw	r3,64(r2)
                tse_dprintf(5, "INFO    : PHY[%d.%d] - Automatically mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
   2a088:	e17ffd47 	ldb	r5,-11(fp)
   2a08c:	e0fffd07 	ldb	r3,-12(fp)
   2a090:	e0bffd87 	ldb	r2,-10(fp)
   2a094:	010000f4 	movhi	r4,3
   2a098:	21096b04 	addi	r4,r4,9644
   2a09c:	180d883a 	mov	r6,r3
   2a0a0:	100f883a 	mov	r7,r2
   2a0a4:	00193f00 	call	193f0 <printf>
                is_mapped = 1;
   2a0a8:	00800044 	movi	r2,1
   2a0ac:	e0bffa05 	stb	r2,-24(fp)
                break;
   2a0b0:	00000906 	br	2a0d8 <alt_tse_mac_associate_phy+0x1fc>
            pmac_info = pmac_group->pmac_info[i];
            psys = pmac_info->psys_info;
            
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
            	continue;
   2a0b4:	0001883a 	nop
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
        for(i = 0; i < pmac_group->channel; i++) {
   2a0b8:	e0bff817 	ldw	r2,-32(fp)
   2a0bc:	10800044 	addi	r2,r2,1
   2a0c0:	e0bff815 	stw	r2,-32(fp)
   2a0c4:	e0bffe17 	ldw	r2,-8(fp)
   2a0c8:	10800003 	ldbu	r2,0(r2)
   2a0cc:	10803fcc 	andi	r2,r2,255
   2a0d0:	e0fff817 	ldw	r3,-32(fp)
   2a0d4:	18bfc616 	blt	r3,r2,29ff0 <alt_tse_mac_associate_phy+0x114>
            }
        }
    }
    
    /* Still cannot find any matched MAC-PHY */
    if(is_mapped == 0) {
   2a0d8:	e0bffa03 	ldbu	r2,-24(fp)
   2a0dc:	1000091e 	bne	r2,zero,2a104 <alt_tse_mac_associate_phy+0x228>
    	pphy->pmac_info = 0;
   2a0e0:	e0bfff17 	ldw	r2,-4(fp)
   2a0e4:	10000615 	stw	zero,24(r2)
        tse_dprintf(2, "WARNING : PHY[%d.X] - Mapping of PHY to MAC failed! Make sure the PHY address is defined correctly in tse_mac_device[] structure, and number of PHYs connected is equivalent to number of channel\n", mac_group_index);
   2a0e8:	e0bffd47 	ldb	r2,-11(fp)
   2a0ec:	010000f4 	movhi	r4,3
   2a0f0:	21097c04 	addi	r4,r4,9712
   2a0f4:	100b883a 	mov	r5,r2
   2a0f8:	00193f00 	call	193f0 <printf>
        return_value = TSE_PHY_MAP_ERROR;
   2a0fc:	00bfffc4 	movi	r2,-1
   2a100:	e0bff915 	stw	r2,-28(fp)
    }
    
    return return_value;
   2a104:	e0bff917 	ldw	r2,-28(fp)
}
   2a108:	e037883a 	mov	sp,fp
   2a10c:	dfc00117 	ldw	ra,4(sp)
   2a110:	df000017 	ldw	fp,0(sp)
   2a114:	dec00204 	addi	sp,sp,8
   2a118:	f800283a 	ret

0002a11c <alt_tse_phy_cfg_pcs>:
/* @Function Description: Configure operating mode of Altera PCS if available
 * @API Type:           Internal
 * @param pmac_info     pointer to MAC info variable
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_cfg_pcs(alt_tse_mac_info *pmac_info) {
   2a11c:	defff804 	addi	sp,sp,-32
   2a120:	dfc00715 	stw	ra,28(sp)
   2a124:	df000615 	stw	fp,24(sp)
   2a128:	df000604 	addi	fp,sp,24
   2a12c:	e13fff15 	stw	r4,-4(fp)
    
    alt_tse_system_info *psys = pmac_info->psys_info;
   2a130:	e0bfff17 	ldw	r2,-4(fp)
   2a134:	10800217 	ldw	r2,8(r2)
   2a138:	e0bffa15 	stw	r2,-24(fp)
    np_tse_mac *pmac = (np_tse_mac *) psys->tse_mac_base;
   2a13c:	e0bffa17 	ldw	r2,-24(fp)
   2a140:	10800017 	ldw	r2,0(r2)
   2a144:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   2a148:	e0bfff17 	ldw	r2,-4(fp)
   2a14c:	10800317 	ldw	r2,12(r2)
   2a150:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   2a154:	e13fff17 	ldw	r4,-4(fp)
   2a158:	0027fac0 	call	27fac <alt_tse_get_mac_info_index>
   2a15c:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   2a160:	e13ffc17 	ldw	r4,-16(fp)
   2a164:	0027f380 	call	27f38 <alt_tse_get_mac_group_index>
   2a168:	e0bffd45 	stb	r2,-11(fp)

    if(psys->tse_pcs_ena) {
   2a16c:	e0bffa17 	ldw	r2,-24(fp)
   2a170:	108003c3 	ldbu	r2,15(r2)
   2a174:	10803fcc 	andi	r2,r2,255
   2a178:	10002c26 	beq	r2,zero,2a22c <alt_tse_phy_cfg_pcs+0x110>
        tse_dprintf(5, "INFO    : PCS[%d.%d] - Configuring PCS operating mode\n", mac_group_index, mac_info_index);
   2a17c:	e0fffd47 	ldb	r3,-11(fp)
   2a180:	e0bffd07 	ldb	r2,-12(fp)
   2a184:	010000f4 	movhi	r4,3
   2a188:	2109ad04 	addi	r4,r4,9908
   2a18c:	180b883a 	mov	r5,r3
   2a190:	100d883a 	mov	r6,r2
   2a194:	00193f00 	call	193f0 <printf>
        
        alt_32 data = IORD(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE); 
   2a198:	e0bffb17 	ldw	r2,-20(fp)
   2a19c:	10808004 	addi	r2,r2,512
   2a1a0:	10801404 	addi	r2,r2,80
   2a1a4:	10800037 	ldwio	r2,0(r2)
   2a1a8:	e0bffe15 	stw	r2,-8(fp)
        
        if(psys->tse_pcs_sgmii) {
   2a1ac:	e0bffa17 	ldw	r2,-24(fp)
   2a1b0:	10800403 	ldbu	r2,16(r2)
   2a1b4:	10803fcc 	andi	r2,r2,255
   2a1b8:	10000e26 	beq	r2,zero,2a1f4 <alt_tse_phy_cfg_pcs+0xd8>
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode enabled\n", mac_group_index, mac_info_index);
   2a1bc:	e0fffd47 	ldb	r3,-11(fp)
   2a1c0:	e0bffd07 	ldb	r2,-12(fp)
   2a1c4:	010000f4 	movhi	r4,3
   2a1c8:	2109bb04 	addi	r4,r4,9964
   2a1cc:	180b883a 	mov	r5,r3
   2a1d0:	100d883a 	mov	r6,r2
   2a1d4:	00193f00 	call	193f0 <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data | 0x03);
   2a1d8:	e0bffb17 	ldw	r2,-20(fp)
   2a1dc:	10808004 	addi	r2,r2,512
   2a1e0:	10801404 	addi	r2,r2,80
   2a1e4:	e0fffe17 	ldw	r3,-8(fp)
   2a1e8:	18c000d4 	ori	r3,r3,3
   2a1ec:	10c00035 	stwio	r3,0(r2)
   2a1f0:	00000e06 	br	2a22c <alt_tse_phy_cfg_pcs+0x110>
            }
        else {
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode disabled\n", mac_group_index, mac_info_index);
   2a1f4:	e0fffd47 	ldb	r3,-11(fp)
   2a1f8:	e0bffd07 	ldb	r2,-12(fp)
   2a1fc:	010000f4 	movhi	r4,3
   2a200:	2109c704 	addi	r4,r4,10012
   2a204:	180b883a 	mov	r5,r3
   2a208:	100d883a 	mov	r6,r2
   2a20c:	00193f00 	call	193f0 <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data & ~0x03);
   2a210:	e0bffb17 	ldw	r2,-20(fp)
   2a214:	10808004 	addi	r2,r2,512
   2a218:	10801404 	addi	r2,r2,80
   2a21c:	e13ffe17 	ldw	r4,-8(fp)
   2a220:	00ffff04 	movi	r3,-4
   2a224:	20c6703a 	and	r3,r4,r3
   2a228:	10c00035 	stwio	r3,0(r2)
        }
    }
    
    return SUCCESS;
   2a22c:	0005883a 	mov	r2,zero
}
   2a230:	e037883a 	mov	sp,fp
   2a234:	dfc00117 	ldw	ra,4(sp)
   2a238:	df000017 	ldw	fp,0(sp)
   2a23c:	dec00204 	addi	sp,sp,8
   2a240:	f800283a 	ret

0002a244 <alt_tse_phy_init>:
/* @Function Description: Detect and initialize all the PHYs connected
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      SUCCESS
 */
alt_32 alt_tse_phy_init() {
   2a244:	defffb04 	addi	sp,sp,-20
   2a248:	dfc00415 	stw	ra,16(sp)
   2a24c:	df000315 	stw	fp,12(sp)
   2a250:	df000304 	addi	fp,sp,12
	alt_8 i = 0;
   2a254:	e03ffd05 	stb	zero,-12(fp)
	alt_8 j = 0;
   2a258:	e03ffd45 	stb	zero,-11(fp)
    
    alt_tse_mac_group *pmac_group = 0;
   2a25c:	e03ffe15 	stw	zero,-8(fp)
    alt_tse_mac_info *pmac_info = 0;
   2a260:	e03fff15 	stw	zero,-4(fp)
    
    /* add supported PHYs */
    alt_tse_phy_add_profile_default();
   2a264:	0028f7c0 	call	28f7c <alt_tse_phy_add_profile_default>
    
    /* display PHY in profile */
    alt_tse_phy_print_profile();
   2a268:	00292140 	call	29214 <alt_tse_phy_print_profile>
    
    alt_tse_mac_group_init();
   2a26c:	00294240 	call	29424 <alt_tse_mac_group_init>
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
   2a270:	e03ffd05 	stb	zero,-12(fp)
   2a274:	00002f06 	br	2a334 <alt_tse_phy_init+0xf0>
        pmac_group = pmac_groups[i];
   2a278:	e0bffd07 	ldb	r2,-12(fp)
   2a27c:	00c00234 	movhi	r3,8
   2a280:	18c41204 	addi	r3,r3,4168
   2a284:	1085883a 	add	r2,r2,r2
   2a288:	1085883a 	add	r2,r2,r2
   2a28c:	1885883a 	add	r2,r3,r2
   2a290:	10800017 	ldw	r2,0(r2)
   2a294:	e0bffe15 	stw	r2,-8(fp)
        
        if(pmac_group->pmac_info[0]->psys_info->tse_use_mdio) {
   2a298:	e0bffe17 	ldw	r2,-8(fp)
   2a29c:	10800117 	ldw	r2,4(r2)
   2a2a0:	10800217 	ldw	r2,8(r2)
   2a2a4:	10800203 	ldbu	r2,8(r2)
   2a2a8:	10803fcc 	andi	r2,r2,255
   2a2ac:	10000326 	beq	r2,zero,2a2bc <alt_tse_phy_init+0x78>
            
        	/* get connected PHYs */
            alt_tse_mac_get_phy(pmac_group);
   2a2b0:	e13ffe17 	ldw	r4,-8(fp)
   2a2b4:	0029ac00 	call	29ac0 <alt_tse_mac_get_phy>
   2a2b8:	00000706 	br	2a2d8 <alt_tse_phy_init+0x94>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
   2a2bc:	e0fffd07 	ldb	r3,-12(fp)
   2a2c0:	e0bffd47 	ldb	r2,-11(fp)
   2a2c4:	010000f4 	movhi	r4,3
   2a2c8:	2109d304 	addi	r4,r4,10060
   2a2cc:	180b883a 	mov	r5,r3
   2a2d0:	100d883a 	mov	r6,r2
   2a2d4:	00193f00 	call	193f0 <printf>
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
   2a2d8:	e03ffd45 	stb	zero,-11(fp)
   2a2dc:	00000d06 	br	2a314 <alt_tse_phy_init+0xd0>
            pmac_info = pmac_group->pmac_info[j];
   2a2e0:	e0bffd47 	ldb	r2,-11(fp)
   2a2e4:	e0fffe17 	ldw	r3,-8(fp)
   2a2e8:	10800044 	addi	r2,r2,1
   2a2ec:	1085883a 	add	r2,r2,r2
   2a2f0:	1085883a 	add	r2,r2,r2
   2a2f4:	1885883a 	add	r2,r3,r2
   2a2f8:	10800017 	ldw	r2,0(r2)
   2a2fc:	e0bfff15 	stw	r2,-4(fp)
            
            alt_tse_phy_cfg_pcs(pmac_info);
   2a300:	e13fff17 	ldw	r4,-4(fp)
   2a304:	002a11c0 	call	2a11c <alt_tse_phy_cfg_pcs>
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
   2a308:	e0bffd43 	ldbu	r2,-11(fp)
   2a30c:	10800044 	addi	r2,r2,1
   2a310:	e0bffd45 	stb	r2,-11(fp)
   2a314:	e0fffd47 	ldb	r3,-11(fp)
   2a318:	e0bffe17 	ldw	r2,-8(fp)
   2a31c:	10800003 	ldbu	r2,0(r2)
   2a320:	10803fcc 	andi	r2,r2,255
   2a324:	18bfee16 	blt	r3,r2,2a2e0 <alt_tse_phy_init+0x9c>
    
    alt_tse_mac_group_init();
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
   2a328:	e0bffd03 	ldbu	r2,-12(fp)
   2a32c:	10800044 	addi	r2,r2,1
   2a330:	e0bffd05 	stb	r2,-12(fp)
   2a334:	e0fffd07 	ldb	r3,-12(fp)
   2a338:	d0a8df43 	ldbu	r2,-23683(gp)
   2a33c:	10803fcc 	andi	r2,r2,255
   2a340:	18bfcd16 	blt	r3,r2,2a278 <alt_tse_phy_init+0x34>
            
            alt_tse_phy_cfg_pcs(pmac_info);
        }
    }
                
    return SUCCESS;
   2a344:	0005883a 	mov	r2,zero
}
   2a348:	e037883a 	mov	sp,fp
   2a34c:	dfc00117 	ldw	ra,4(sp)
   2a350:	df000017 	ldw	fp,0(sp)
   2a354:	dec00204 	addi	sp,sp,8
   2a358:	f800283a 	ret

0002a35c <alt_tse_phy_restart_an>:
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *                              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_restart_an(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
   2a35c:	defff704 	addi	sp,sp,-36
   2a360:	dfc00815 	stw	ra,32(sp)
   2a364:	df000715 	stw	fp,28(sp)
   2a368:	df000704 	addi	fp,sp,28
   2a36c:	e13ffe15 	stw	r4,-8(fp)
   2a370:	e17fff15 	stw	r5,-4(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
   2a374:	e0bffe17 	ldw	r2,-8(fp)
   2a378:	10800617 	ldw	r2,24(r2)
   2a37c:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   2a380:	e0bffb17 	ldw	r2,-20(fp)
   2a384:	10800317 	ldw	r2,12(r2)
   2a388:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   2a38c:	e13ffb17 	ldw	r4,-20(fp)
   2a390:	0027fac0 	call	27fac <alt_tse_get_mac_info_index>
   2a394:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   2a398:	e13ffc17 	ldw	r4,-16(fp)
   2a39c:	0027f380 	call	27f38 <alt_tse_get_mac_group_index>
   2a3a0:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
   2a3a4:	e13ffe17 	ldw	r4,-8(fp)
   2a3a8:	0028ce40 	call	28ce4 <alt_tse_phy_rd_mdio_addr>
   2a3ac:	e0bffd85 	stb	r2,-10(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
   2a3b0:	e0bffe17 	ldw	r2,-8(fp)
   2a3b4:	10800003 	ldbu	r2,0(r2)
   2a3b8:	10803fcc 	andi	r2,r2,255
   2a3bc:	e13ffe17 	ldw	r4,-8(fp)
   2a3c0:	100b883a 	mov	r5,r2
   2a3c4:	0028d2c0 	call	28d2c <alt_tse_phy_wr_mdio_addr>
    
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
   2a3c8:	e13ffe17 	ldw	r4,-8(fp)
   2a3cc:	01400044 	movi	r5,1
   2a3d0:	018000c4 	movi	r6,3
   2a3d4:	01c00044 	movi	r7,1
   2a3d8:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2a3dc:	10000d1e 	bne	r2,zero,2a414 <alt_tse_phy_restart_an+0xb8>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
   2a3e0:	e0fffd47 	ldb	r3,-11(fp)
   2a3e4:	e0bffd07 	ldb	r2,-12(fp)
   2a3e8:	010000f4 	movhi	r4,3
   2a3ec:	2109e904 	addi	r4,r4,10148
   2a3f0:	180b883a 	mov	r5,r3
   2a3f4:	100d883a 	mov	r6,r2
   2a3f8:	00193f00 	call	193f0 <printf>
        
		/* Restore previous MDIO address */
		alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   2a3fc:	e0bffd83 	ldbu	r2,-10(fp)
   2a400:	e13ffe17 	ldw	r4,-8(fp)
   2a404:	100b883a 	mov	r5,r2
   2a408:	0028d2c0 	call	28d2c <alt_tse_phy_wr_mdio_addr>
		
		return TSE_PHY_AN_NOT_CAPABLE;
   2a40c:	00bfff84 	movi	r2,-2
   2a410:	00003e06 	br	2a50c <alt_tse_phy_restart_an+0x1b0>
    }
    
    /* enable Auto-Negotiation */    
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_AN_ENA, 1, 1);
   2a414:	00800044 	movi	r2,1
   2a418:	d8800015 	stw	r2,0(sp)
   2a41c:	e13ffe17 	ldw	r4,-8(fp)
   2a420:	000b883a 	mov	r5,zero
   2a424:	01800304 	movi	r6,12
   2a428:	01c00044 	movi	r7,1
   2a42c:	0028d840 	call	28d84 <alt_tse_phy_wr_mdio_reg>
    
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
   2a430:	00800044 	movi	r2,1
   2a434:	d8800015 	stw	r2,0(sp)
   2a438:	e13ffe17 	ldw	r4,-8(fp)
   2a43c:	000b883a 	mov	r5,zero
   2a440:	01800244 	movi	r6,9
   2a444:	01c00044 	movi	r7,1
   2a448:	0028d840 	call	28d84 <alt_tse_phy_wr_mdio_reg>
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
   2a44c:	e0fffd47 	ldb	r3,-11(fp)
   2a450:	e0bffd07 	ldb	r2,-12(fp)
   2a454:	010000f4 	movhi	r4,3
   2a458:	2109f904 	addi	r4,r4,10212
   2a45c:	180b883a 	mov	r5,r3
   2a460:	100d883a 	mov	r6,r2
   2a464:	00193f00 	call	193f0 <printf>
    
    alt_32 timeout = 0;
   2a468:	e03ffa15 	stw	zero,-24(fp)
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
   2a46c:	00001506 	br	2a4c4 <alt_tse_phy_restart_an+0x168>
        if(timeout++ > timeout_threshold) {
   2a470:	e0bffa17 	ldw	r2,-24(fp)
   2a474:	e0ffff17 	ldw	r3,-4(fp)
   2a478:	1885803a 	cmpltu	r2,r3,r2
   2a47c:	e0fffa17 	ldw	r3,-24(fp)
   2a480:	18c00044 	addi	r3,r3,1
   2a484:	e0fffa15 	stw	r3,-24(fp)
   2a488:	10803fcc 	andi	r2,r2,255
   2a48c:	10000d26 	beq	r2,zero,2a4c4 <alt_tse_phy_restart_an+0x168>
           tse_dprintf(4, "WARNING : PHY[%d.%d] - Auto-Negotiation FAILED\n", mac_group_index, mac_info_index);
   2a490:	e0fffd47 	ldb	r3,-11(fp)
   2a494:	e0bffd07 	ldb	r2,-12(fp)
   2a498:	010000f4 	movhi	r4,3
   2a49c:	210a0b04 	addi	r4,r4,10284
   2a4a0:	180b883a 	mov	r5,r3
   2a4a4:	100d883a 	mov	r6,r2
   2a4a8:	00193f00 	call	193f0 <printf>
		   
		   /* Restore previous MDIO address */
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   2a4ac:	e0bffd83 	ldbu	r2,-10(fp)
   2a4b0:	e13ffe17 	ldw	r4,-8(fp)
   2a4b4:	100b883a 	mov	r5,r2
   2a4b8:	0028d2c0 	call	28d2c <alt_tse_phy_wr_mdio_addr>
           
		   return TSE_PHY_AN_NOT_COMPLETE;
   2a4bc:	00bfffc4 	movi	r2,-1
   2a4c0:	00001206 	br	2a50c <alt_tse_phy_restart_an+0x1b0>
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
    
    alt_32 timeout = 0;
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
   2a4c4:	e13ffe17 	ldw	r4,-8(fp)
   2a4c8:	01400044 	movi	r5,1
   2a4cc:	01800144 	movi	r6,5
   2a4d0:	01c00044 	movi	r7,1
   2a4d4:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2a4d8:	103fe526 	beq	r2,zero,2a470 <alt_tse_phy_restart_an+0x114>
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
           
		   return TSE_PHY_AN_NOT_COMPLETE;
        }
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Auto-Negotiation PASSED\n", mac_group_index, mac_info_index);
   2a4dc:	e0fffd47 	ldb	r3,-11(fp)
   2a4e0:	e0bffd07 	ldb	r2,-12(fp)
   2a4e4:	010000f4 	movhi	r4,3
   2a4e8:	210a1704 	addi	r4,r4,10332
   2a4ec:	180b883a 	mov	r5,r3
   2a4f0:	100d883a 	mov	r6,r2
   2a4f4:	00193f00 	call	193f0 <printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   2a4f8:	e0bffd83 	ldbu	r2,-10(fp)
   2a4fc:	e13ffe17 	ldw	r4,-8(fp)
   2a500:	100b883a 	mov	r5,r2
   2a504:	0028d2c0 	call	28d2c <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE;
   2a508:	0005883a 	mov	r2,zero
}
   2a50c:	e037883a 	mov	sp,fp
   2a510:	dfc00117 	ldw	ra,4(sp)
   2a514:	df000017 	ldw	fp,0(sp)
   2a518:	dec00204 	addi	sp,sp,8
   2a51c:	f800283a 	ret

0002a520 <alt_tse_phy_check_link>:
 * @param pphy                  Pointer to the alt_tse_phy_info structure
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 */
alt_32 alt_tse_phy_check_link(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
   2a520:	defff904 	addi	sp,sp,-28
   2a524:	dfc00615 	stw	ra,24(sp)
   2a528:	df000515 	stw	fp,20(sp)
   2a52c:	df000504 	addi	fp,sp,20
   2a530:	e13ffe15 	stw	r4,-8(fp)
   2a534:	e17fff15 	stw	r5,-4(fp)

    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
   2a538:	e0bffe17 	ldw	r2,-8(fp)
   2a53c:	10800617 	ldw	r2,24(r2)
   2a540:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   2a544:	e0bffb17 	ldw	r2,-20(fp)
   2a548:	10800317 	ldw	r2,12(r2)
   2a54c:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   2a550:	e13ffb17 	ldw	r4,-20(fp)
   2a554:	0027fac0 	call	27fac <alt_tse_get_mac_info_index>
   2a558:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group); 
   2a55c:	e13ffc17 	ldw	r4,-16(fp)
   2a560:	0027f380 	call	27f38 <alt_tse_get_mac_group_index>
   2a564:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
   2a568:	e13ffe17 	ldw	r4,-8(fp)
   2a56c:	0028ce40 	call	28ce4 <alt_tse_phy_rd_mdio_addr>
   2a570:	e0bffd85 	stb	r2,-10(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
   2a574:	e0bffe17 	ldw	r2,-8(fp)
   2a578:	10800003 	ldbu	r2,0(r2)
   2a57c:	10803fcc 	andi	r2,r2,255
   2a580:	e13ffe17 	ldw	r4,-8(fp)
   2a584:	100b883a 	mov	r5,r2
   2a588:	0028d2c0 	call	28d2c <alt_tse_phy_wr_mdio_addr>
    /* Issue a PHY reset here and wait for the link
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
   2a58c:	e0fffd47 	ldb	r3,-11(fp)
   2a590:	e0bffd07 	ldb	r2,-12(fp)
   2a594:	010000f4 	movhi	r4,3
   2a598:	210a2304 	addi	r4,r4,10380
   2a59c:	180b883a 	mov	r5,r3
   2a5a0:	100d883a 	mov	r6,r2
   2a5a4:	00193f00 	call	193f0 <printf>
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
   2a5a8:	e13ffe17 	ldw	r4,-8(fp)
   2a5ac:	000b883a 	mov	r5,zero
   2a5b0:	01800384 	movi	r6,14
   2a5b4:	01c00044 	movi	r7,1
   2a5b8:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2a5bc:	1000061e 	bne	r2,zero,2a5d8 <alt_tse_phy_check_link+0xb8>
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
   2a5c0:	e13ffe17 	ldw	r4,-8(fp)
   2a5c4:	01400044 	movi	r5,1
   2a5c8:	01800144 	movi	r6,5
   2a5cc:	01c00044 	movi	r7,1
   2a5d0:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
   2a5d4:	1000191e 	bne	r2,zero,2a63c <alt_tse_phy_check_link+0x11c>
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
        
        tse_dprintf(5, "INFO    : PHY[%d.%d] - Link not yet established, restart auto-negotiation...\n", mac_group_index, mac_info_index);
   2a5d8:	e0fffd47 	ldb	r3,-11(fp)
   2a5dc:	e0bffd07 	ldb	r2,-12(fp)
   2a5e0:	010000f4 	movhi	r4,3
   2a5e4:	210a2e04 	addi	r4,r4,10424
   2a5e8:	180b883a 	mov	r5,r3
   2a5ec:	100d883a 	mov	r6,r2
   2a5f0:	00193f00 	call	193f0 <printf>
        /* restart Auto-Negotiation */
        /* if Auto-Negotiation still cannot complete, then go to next PHY */
        if(alt_tse_phy_restart_an(pphy, timeout_threshold) == TSE_PHY_AN_NOT_COMPLETE) {
   2a5f4:	e13ffe17 	ldw	r4,-8(fp)
   2a5f8:	e17fff17 	ldw	r5,-4(fp)
   2a5fc:	002a35c0 	call	2a35c <alt_tse_phy_restart_an>
   2a600:	10bfffd8 	cmpnei	r2,r2,-1
   2a604:	10000d1e 	bne	r2,zero,2a63c <alt_tse_phy_check_link+0x11c>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - Link could not established\n", mac_group_index, mac_info_index);
   2a608:	e0fffd47 	ldb	r3,-11(fp)
   2a60c:	e0bffd07 	ldb	r2,-12(fp)
   2a610:	010000f4 	movhi	r4,3
   2a614:	210a4204 	addi	r4,r4,10504
   2a618:	180b883a 	mov	r5,r3
   2a61c:	100d883a 	mov	r6,r2
   2a620:	00193f00 	call	193f0 <printf>
			
			/* Restore previous MDIO address */
			alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   2a624:	e0bffd83 	ldbu	r2,-10(fp)
   2a628:	e13ffe17 	ldw	r4,-8(fp)
   2a62c:	100b883a 	mov	r5,r2
   2a630:	0028d2c0 	call	28d2c <alt_tse_phy_wr_mdio_addr>
	
            return TSE_PHY_AN_NOT_COMPLETE;
   2a634:	00bfffc4 	movi	r2,-1
   2a638:	00000c06 	br	2a66c <alt_tse_phy_check_link+0x14c>
        }            
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Link established\n", mac_group_index, mac_info_index);
   2a63c:	e0fffd47 	ldb	r3,-11(fp)
   2a640:	e0bffd07 	ldb	r2,-12(fp)
   2a644:	010000f4 	movhi	r4,3
   2a648:	210a4f04 	addi	r4,r4,10556
   2a64c:	180b883a 	mov	r5,r3
   2a650:	100d883a 	mov	r6,r2
   2a654:	00193f00 	call	193f0 <printf>
            
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   2a658:	e0bffd83 	ldbu	r2,-10(fp)
   2a65c:	e13ffe17 	ldw	r4,-8(fp)
   2a660:	100b883a 	mov	r5,r2
   2a664:	0028d2c0 	call	28d2c <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE; 
   2a668:	0005883a 	mov	r2,zero
}
   2a66c:	e037883a 	mov	sp,fp
   2a670:	dfc00117 	ldw	ra,4(sp)
   2a674:	df000017 	ldw	fp,0(sp)
   2a678:	dec00204 	addi	sp,sp,8
   2a67c:	f800283a 	ret

0002a680 <alt_tse_phy_get_cap>:
 * @param pmac  Pointer to the alt_tse_phy_info structure
 * @return      return TSE_PHY_AN_COMPLETE if success
 *              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_get_cap(alt_tse_phy_info *pphy) {
   2a680:	defff904 	addi	sp,sp,-28
   2a684:	dfc00615 	stw	ra,24(sp)
   2a688:	df000515 	stw	fp,20(sp)
   2a68c:	df000504 	addi	fp,sp,20
   2a690:	e13fff15 	stw	r4,-4(fp)
	alt_32 return_value = TSE_PHY_AN_COMPLETE;
   2a694:	e03ffb15 	stw	zero,-20(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
   2a698:	e0bfff17 	ldw	r2,-4(fp)
   2a69c:	10800617 	ldw	r2,24(r2)
   2a6a0:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   2a6a4:	e0bffc17 	ldw	r2,-16(fp)
   2a6a8:	10800317 	ldw	r2,12(r2)
   2a6ac:	e0bffd15 	stw	r2,-12(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   2a6b0:	e13ffc17 	ldw	r4,-16(fp)
   2a6b4:	0027fac0 	call	27fac <alt_tse_get_mac_info_index>
   2a6b8:	e0bffe05 	stb	r2,-8(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);    
   2a6bc:	e13ffd17 	ldw	r4,-12(fp)
   2a6c0:	0027f380 	call	27f38 <alt_tse_get_mac_group_index>
   2a6c4:	e0bffe45 	stb	r2,-7(fp)
        
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
   2a6c8:	e13fff17 	ldw	r4,-4(fp)
   2a6cc:	0028ce40 	call	28ce4 <alt_tse_phy_rd_mdio_addr>
   2a6d0:	e0bffe85 	stb	r2,-6(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
   2a6d4:	e0bfff17 	ldw	r2,-4(fp)
   2a6d8:	10800003 	ldbu	r2,0(r2)
   2a6dc:	10803fcc 	andi	r2,r2,255
   2a6e0:	e13fff17 	ldw	r4,-4(fp)
   2a6e4:	100b883a 	mov	r5,r2
   2a6e8:	0028d2c0 	call	28d2c <alt_tse_phy_wr_mdio_addr>
            
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
   2a6ec:	e13fff17 	ldw	r4,-4(fp)
   2a6f0:	01400044 	movi	r5,1
   2a6f4:	018000c4 	movi	r6,3
   2a6f8:	01c00044 	movi	r7,1
   2a6fc:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2a700:	10000d1e 	bne	r2,zero,2a738 <alt_tse_phy_get_cap+0xb8>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
   2a704:	e0fffe47 	ldb	r3,-7(fp)
   2a708:	e0bffe07 	ldb	r2,-8(fp)
   2a70c:	010000f4 	movhi	r4,3
   2a710:	2109e904 	addi	r4,r4,10148
   2a714:	180b883a 	mov	r5,r3
   2a718:	100d883a 	mov	r6,r2
   2a71c:	00193f00 	call	193f0 <printf>
        
        /* Restore previous MDIO address */
        alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   2a720:	e0bffe83 	ldbu	r2,-6(fp)
   2a724:	e13fff17 	ldw	r4,-4(fp)
   2a728:	100b883a 	mov	r5,r2
   2a72c:	0028d2c0 	call	28d2c <alt_tse_phy_wr_mdio_addr>
        
        return TSE_PHY_AN_NOT_CAPABLE;
   2a730:	00bfff84 	movi	r2,-2
   2a734:	00013306 	br	2ac04 <alt_tse_phy_get_cap+0x584>
    }
    
    /* check whether link has been established */
    alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
   2a738:	e13fff17 	ldw	r4,-4(fp)
   2a73c:	01400134 	movhi	r5,4
   2a740:	29742404 	addi	r5,r5,-12144
   2a744:	002a35c0 	call	2a35c <alt_tse_phy_restart_an>
    
    if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0) {
   2a748:	e13fff17 	ldw	r4,-4(fp)
   2a74c:	01400044 	movi	r5,1
   2a750:	01800144 	movi	r6,5
   2a754:	01c00044 	movi	r7,1
   2a758:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2a75c:	1000021e 	bne	r2,zero,2a768 <alt_tse_phy_get_cap+0xe8>
        return_value = TSE_PHY_AN_NOT_COMPLETE;
   2a760:	00bfffc4 	movi	r2,-1
   2a764:	e0bffb15 	stw	r2,-20(fp)
    }
    
    /* get PHY capabilities */
    pphy->link_capability.cap_1000_base_x_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_FULL, 1);
   2a768:	e13fff17 	ldw	r4,-4(fp)
   2a76c:	014003c4 	movi	r5,15
   2a770:	018003c4 	movi	r6,15
   2a774:	01c00044 	movi	r7,1
   2a778:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2a77c:	1007883a 	mov	r3,r2
   2a780:	e0bfff17 	ldw	r2,-4(fp)
   2a784:	10c00045 	stb	r3,1(r2)
    pphy->link_capability.cap_1000_base_x_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_HALF, 1);
   2a788:	e13fff17 	ldw	r4,-4(fp)
   2a78c:	014003c4 	movi	r5,15
   2a790:	01800384 	movi	r6,14
   2a794:	01c00044 	movi	r7,1
   2a798:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2a79c:	1007883a 	mov	r3,r2
   2a7a0:	e0bfff17 	ldw	r2,-4(fp)
   2a7a4:	10c00085 	stb	r3,2(r2)
    pphy->link_capability.cap_1000_base_t_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1);
   2a7a8:	e13fff17 	ldw	r4,-4(fp)
   2a7ac:	014003c4 	movi	r5,15
   2a7b0:	01800344 	movi	r6,13
   2a7b4:	01c00044 	movi	r7,1
   2a7b8:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2a7bc:	1007883a 	mov	r3,r2
   2a7c0:	e0bfff17 	ldw	r2,-4(fp)
   2a7c4:	10c000c5 	stb	r3,3(r2)
    pphy->link_capability.cap_1000_base_t_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
   2a7c8:	e13fff17 	ldw	r4,-4(fp)
   2a7cc:	014003c4 	movi	r5,15
   2a7d0:	01800304 	movi	r6,12
   2a7d4:	01c00044 	movi	r7,1
   2a7d8:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2a7dc:	1007883a 	mov	r3,r2
   2a7e0:	e0bfff17 	ldw	r2,-4(fp)
   2a7e4:	10c00105 	stb	r3,4(r2)
    
    pphy->link_capability.cap_100_base_t4      = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
   2a7e8:	e13fff17 	ldw	r4,-4(fp)
   2a7ec:	01400044 	movi	r5,1
   2a7f0:	018003c4 	movi	r6,15
   2a7f4:	01c00044 	movi	r7,1
   2a7f8:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2a7fc:	1007883a 	mov	r3,r2
   2a800:	e0bfff17 	ldw	r2,-4(fp)
   2a804:	10c00145 	stb	r3,5(r2)
    pphy->link_capability.cap_100_base_x_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
   2a808:	e13fff17 	ldw	r4,-4(fp)
   2a80c:	01400044 	movi	r5,1
   2a810:	01800384 	movi	r6,14
   2a814:	01c00044 	movi	r7,1
   2a818:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2a81c:	1007883a 	mov	r3,r2
   2a820:	e0bfff17 	ldw	r2,-4(fp)
   2a824:	10c00185 	stb	r3,6(r2)
    pphy->link_capability.cap_100_base_x_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
   2a828:	e13fff17 	ldw	r4,-4(fp)
   2a82c:	01400044 	movi	r5,1
   2a830:	01800344 	movi	r6,13
   2a834:	01c00044 	movi	r7,1
   2a838:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2a83c:	1007883a 	mov	r3,r2
   2a840:	e0bfff17 	ldw	r2,-4(fp)
   2a844:	10c001c5 	stb	r3,7(r2)
    pphy->link_capability.cap_100_base_t2_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_FULL, 1);
   2a848:	e13fff17 	ldw	r4,-4(fp)
   2a84c:	01400044 	movi	r5,1
   2a850:	01800284 	movi	r6,10
   2a854:	01c00044 	movi	r7,1
   2a858:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2a85c:	1007883a 	mov	r3,r2
   2a860:	e0bfff17 	ldw	r2,-4(fp)
   2a864:	10c00205 	stb	r3,8(r2)
    pphy->link_capability.cap_100_base_t2_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_HALF, 1);
   2a868:	e13fff17 	ldw	r4,-4(fp)
   2a86c:	01400044 	movi	r5,1
   2a870:	01800244 	movi	r6,9
   2a874:	01c00044 	movi	r7,1
   2a878:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2a87c:	1007883a 	mov	r3,r2
   2a880:	e0bfff17 	ldw	r2,-4(fp)
   2a884:	10c00245 	stb	r3,9(r2)
    pphy->link_capability.cap_10_base_t_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
   2a888:	e13fff17 	ldw	r4,-4(fp)
   2a88c:	01400044 	movi	r5,1
   2a890:	01800304 	movi	r6,12
   2a894:	01c00044 	movi	r7,1
   2a898:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2a89c:	1007883a 	mov	r3,r2
   2a8a0:	e0bfff17 	ldw	r2,-4(fp)
   2a8a4:	10c00285 	stb	r3,10(r2)
    pphy->link_capability.cap_10_base_t_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
   2a8a8:	e13fff17 	ldw	r4,-4(fp)
   2a8ac:	01400044 	movi	r5,1
   2a8b0:	018002c4 	movi	r6,11
   2a8b4:	01c00044 	movi	r7,1
   2a8b8:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2a8bc:	1007883a 	mov	r3,r2
   2a8c0:	e0bfff17 	ldw	r2,-4(fp)
   2a8c4:	10c002c5 	stb	r3,11(r2)
    
    /* get link partner capability */
    pphy->link_capability.lp_1000_base_t_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_FULL_ADV, 1);
   2a8c8:	e13fff17 	ldw	r4,-4(fp)
   2a8cc:	01400284 	movi	r5,10
   2a8d0:	018002c4 	movi	r6,11
   2a8d4:	01c00044 	movi	r7,1
   2a8d8:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2a8dc:	1007883a 	mov	r3,r2
   2a8e0:	e0bfff17 	ldw	r2,-4(fp)
   2a8e4:	10c00305 	stb	r3,12(r2)
    pphy->link_capability.lp_1000_base_t_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_HALF_ADV, 1);
   2a8e8:	e13fff17 	ldw	r4,-4(fp)
   2a8ec:	01400284 	movi	r5,10
   2a8f0:	01800284 	movi	r6,10
   2a8f4:	01c00044 	movi	r7,1
   2a8f8:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2a8fc:	1007883a 	mov	r3,r2
   2a900:	e0bfff17 	ldw	r2,-4(fp)
   2a904:	10c00345 	stb	r3,13(r2)
    
    pphy->link_capability.lp_100_base_t4       = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1);
   2a908:	e13fff17 	ldw	r4,-4(fp)
   2a90c:	01400144 	movi	r5,5
   2a910:	01800244 	movi	r6,9
   2a914:	01c00044 	movi	r7,1
   2a918:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2a91c:	1007883a 	mov	r3,r2
   2a920:	e0bfff17 	ldw	r2,-4(fp)
   2a924:	10c00385 	stb	r3,14(r2)
    pphy->link_capability.lp_100_base_tx_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1);
   2a928:	e13fff17 	ldw	r4,-4(fp)
   2a92c:	01400144 	movi	r5,5
   2a930:	01800204 	movi	r6,8
   2a934:	01c00044 	movi	r7,1
   2a938:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2a93c:	1007883a 	mov	r3,r2
   2a940:	e0bfff17 	ldw	r2,-4(fp)
   2a944:	10c003c5 	stb	r3,15(r2)
    pphy->link_capability.lp_100_base_tx_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1);
   2a948:	e13fff17 	ldw	r4,-4(fp)
   2a94c:	01400144 	movi	r5,5
   2a950:	018001c4 	movi	r6,7
   2a954:	01c00044 	movi	r7,1
   2a958:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2a95c:	1007883a 	mov	r3,r2
   2a960:	e0bfff17 	ldw	r2,-4(fp)
   2a964:	10c00405 	stb	r3,16(r2)
    pphy->link_capability.lp_10_base_tx_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1);
   2a968:	e13fff17 	ldw	r4,-4(fp)
   2a96c:	01400144 	movi	r5,5
   2a970:	01800184 	movi	r6,6
   2a974:	01c00044 	movi	r7,1
   2a978:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2a97c:	1007883a 	mov	r3,r2
   2a980:	e0bfff17 	ldw	r2,-4(fp)
   2a984:	10c00445 	stb	r3,17(r2)
    pphy->link_capability.lp_10_base_tx_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1);
   2a988:	e13fff17 	ldw	r4,-4(fp)
   2a98c:	01400144 	movi	r5,5
   2a990:	01800144 	movi	r6,5
   2a994:	01c00044 	movi	r7,1
   2a998:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2a99c:	1007883a 	mov	r3,r2
   2a9a0:	e0bfff17 	ldw	r2,-4(fp)
   2a9a4:	10c00485 	stb	r3,18(r2)
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Capability of PHY :\n", mac_group_index, mac_info_index);
   2a9a8:	e0fffe47 	ldb	r3,-7(fp)
   2a9ac:	e0bffe07 	ldb	r2,-8(fp)
   2a9b0:	010000f4 	movhi	r4,3
   2a9b4:	210a5a04 	addi	r4,r4,10600
   2a9b8:	180b883a 	mov	r5,r3
   2a9bc:	100d883a 	mov	r6,r2
   2a9c0:	0026dc40 	call	26dc4 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Full Duplex = %d\n", pphy->link_capability.cap_1000_base_x_full);
   2a9c4:	e0bfff17 	ldw	r2,-4(fp)
   2a9c8:	10800043 	ldbu	r2,1(r2)
   2a9cc:	10803fcc 	andi	r2,r2,255
   2a9d0:	010000f4 	movhi	r4,3
   2a9d4:	210a6504 	addi	r4,r4,10644
   2a9d8:	100b883a 	mov	r5,r2
   2a9dc:	0026dc40 	call	26dc4 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Half Duplex = %d\n", pphy->link_capability.cap_1000_base_x_half);
   2a9e0:	e0bfff17 	ldw	r2,-4(fp)
   2a9e4:	10800083 	ldbu	r2,2(r2)
   2a9e8:	10803fcc 	andi	r2,r2,255
   2a9ec:	010000f4 	movhi	r4,3
   2a9f0:	210a6f04 	addi	r4,r4,10684
   2a9f4:	100b883a 	mov	r5,r2
   2a9f8:	0026dc40 	call	26dc4 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.cap_1000_base_t_full);
   2a9fc:	e0bfff17 	ldw	r2,-4(fp)
   2aa00:	108000c3 	ldbu	r2,3(r2)
   2aa04:	10803fcc 	andi	r2,r2,255
   2aa08:	010000f4 	movhi	r4,3
   2aa0c:	210a7904 	addi	r4,r4,10724
   2aa10:	100b883a 	mov	r5,r2
   2aa14:	0026dc40 	call	26dc4 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.cap_1000_base_t_half);
   2aa18:	e0bfff17 	ldw	r2,-4(fp)
   2aa1c:	10800103 	ldbu	r2,4(r2)
   2aa20:	10803fcc 	andi	r2,r2,255
   2aa24:	010000f4 	movhi	r4,3
   2aa28:	210a8304 	addi	r4,r4,10764
   2aa2c:	100b883a 	mov	r5,r2
   2aa30:	0026dc40 	call	26dc4 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.cap_100_base_t4);
   2aa34:	e0bfff17 	ldw	r2,-4(fp)
   2aa38:	10800143 	ldbu	r2,5(r2)
   2aa3c:	10803fcc 	andi	r2,r2,255
   2aa40:	010000f4 	movhi	r4,3
   2aa44:	210a8d04 	addi	r4,r4,10804
   2aa48:	100b883a 	mov	r5,r2
   2aa4c:	0026dc40 	call	26dc4 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Full Duplex  = %d\n", pphy->link_capability.cap_100_base_x_full);
   2aa50:	e0bfff17 	ldw	r2,-4(fp)
   2aa54:	10800183 	ldbu	r2,6(r2)
   2aa58:	10803fcc 	andi	r2,r2,255
   2aa5c:	010000f4 	movhi	r4,3
   2aa60:	210a9704 	addi	r4,r4,10844
   2aa64:	100b883a 	mov	r5,r2
   2aa68:	0026dc40 	call	26dc4 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Half Duplex  = %d\n", pphy->link_capability.cap_100_base_x_half);
   2aa6c:	e0bfff17 	ldw	r2,-4(fp)
   2aa70:	108001c3 	ldbu	r2,7(r2)
   2aa74:	10803fcc 	andi	r2,r2,255
   2aa78:	010000f4 	movhi	r4,3
   2aa7c:	210aa104 	addi	r4,r4,10884
   2aa80:	100b883a 	mov	r5,r2
   2aa84:	0026dc40 	call	26dc4 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Full Duplex = %d\n", pphy->link_capability.cap_100_base_t2_full);
   2aa88:	e0bfff17 	ldw	r2,-4(fp)
   2aa8c:	10800203 	ldbu	r2,8(r2)
   2aa90:	10803fcc 	andi	r2,r2,255
   2aa94:	010000f4 	movhi	r4,3
   2aa98:	210aab04 	addi	r4,r4,10924
   2aa9c:	100b883a 	mov	r5,r2
   2aaa0:	0026dc40 	call	26dc4 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Half Duplex = %d\n", pphy->link_capability.cap_100_base_t2_half);
   2aaa4:	e0bfff17 	ldw	r2,-4(fp)
   2aaa8:	10800243 	ldbu	r2,9(r2)
   2aaac:	10803fcc 	andi	r2,r2,255
   2aab0:	010000f4 	movhi	r4,3
   2aab4:	210ab504 	addi	r4,r4,10964
   2aab8:	100b883a 	mov	r5,r2
   2aabc:	0026dc40 	call	26dc4 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Full Duplex   = %d\n", pphy->link_capability.cap_10_base_t_full);
   2aac0:	e0bfff17 	ldw	r2,-4(fp)
   2aac4:	10800283 	ldbu	r2,10(r2)
   2aac8:	10803fcc 	andi	r2,r2,255
   2aacc:	010000f4 	movhi	r4,3
   2aad0:	210abf04 	addi	r4,r4,11004
   2aad4:	100b883a 	mov	r5,r2
   2aad8:	0026dc40 	call	26dc4 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Half Duplex   = %d\n", pphy->link_capability.cap_10_base_t_half);
   2aadc:	e0bfff17 	ldw	r2,-4(fp)
   2aae0:	108002c3 	ldbu	r2,11(r2)
   2aae4:	10803fcc 	andi	r2,r2,255
   2aae8:	010000f4 	movhi	r4,3
   2aaec:	210ac904 	addi	r4,r4,11044
   2aaf0:	100b883a 	mov	r5,r2
   2aaf4:	0026dc40 	call	26dc4 <no_printf>
    tse_dprintf(6, "\n");
   2aaf8:	010000f4 	movhi	r4,3
   2aafc:	21092f04 	addi	r4,r4,9404
   2ab00:	0026dc40 	call	26dc4 <no_printf>
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Link Partner Capability :\n", mac_group_index, mac_info_index);
   2ab04:	e0fffe47 	ldb	r3,-7(fp)
   2ab08:	e0bffe07 	ldb	r2,-8(fp)
   2ab0c:	010000f4 	movhi	r4,3
   2ab10:	210ad304 	addi	r4,r4,11084
   2ab14:	180b883a 	mov	r5,r3
   2ab18:	100d883a 	mov	r6,r2
   2ab1c:	0026dc40 	call	26dc4 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.lp_1000_base_t_full);
   2ab20:	e0bfff17 	ldw	r2,-4(fp)
   2ab24:	10800303 	ldbu	r2,12(r2)
   2ab28:	10803fcc 	andi	r2,r2,255
   2ab2c:	010000f4 	movhi	r4,3
   2ab30:	210a7904 	addi	r4,r4,10724
   2ab34:	100b883a 	mov	r5,r2
   2ab38:	0026dc40 	call	26dc4 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.lp_1000_base_t_half);
   2ab3c:	e0bfff17 	ldw	r2,-4(fp)
   2ab40:	10800343 	ldbu	r2,13(r2)
   2ab44:	10803fcc 	andi	r2,r2,255
   2ab48:	010000f4 	movhi	r4,3
   2ab4c:	210a8304 	addi	r4,r4,10764
   2ab50:	100b883a 	mov	r5,r2
   2ab54:	0026dc40 	call	26dc4 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.lp_100_base_t4);
   2ab58:	e0bfff17 	ldw	r2,-4(fp)
   2ab5c:	10800383 	ldbu	r2,14(r2)
   2ab60:	10803fcc 	andi	r2,r2,255
   2ab64:	010000f4 	movhi	r4,3
   2ab68:	210a8d04 	addi	r4,r4,10804
   2ab6c:	100b883a 	mov	r5,r2
   2ab70:	0026dc40 	call	26dc4 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Full Duplex = %d\n", pphy->link_capability.lp_100_base_tx_full);
   2ab74:	e0bfff17 	ldw	r2,-4(fp)
   2ab78:	108003c3 	ldbu	r2,15(r2)
   2ab7c:	10803fcc 	andi	r2,r2,255
   2ab80:	010000f4 	movhi	r4,3
   2ab84:	210ae004 	addi	r4,r4,11136
   2ab88:	100b883a 	mov	r5,r2
   2ab8c:	0026dc40 	call	26dc4 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Half Duplex = %d\n", pphy->link_capability.lp_100_base_tx_half);
   2ab90:	e0bfff17 	ldw	r2,-4(fp)
   2ab94:	10800403 	ldbu	r2,16(r2)
   2ab98:	10803fcc 	andi	r2,r2,255
   2ab9c:	010000f4 	movhi	r4,3
   2aba0:	210aea04 	addi	r4,r4,11176
   2aba4:	100b883a 	mov	r5,r2
   2aba8:	0026dc40 	call	26dc4 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Full Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_full);
   2abac:	e0bfff17 	ldw	r2,-4(fp)
   2abb0:	10800443 	ldbu	r2,17(r2)
   2abb4:	10803fcc 	andi	r2,r2,255
   2abb8:	010000f4 	movhi	r4,3
   2abbc:	210af404 	addi	r4,r4,11216
   2abc0:	100b883a 	mov	r5,r2
   2abc4:	0026dc40 	call	26dc4 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Half Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_half);
   2abc8:	e0bfff17 	ldw	r2,-4(fp)
   2abcc:	10800483 	ldbu	r2,18(r2)
   2abd0:	10803fcc 	andi	r2,r2,255
   2abd4:	010000f4 	movhi	r4,3
   2abd8:	210afe04 	addi	r4,r4,11256
   2abdc:	100b883a 	mov	r5,r2
   2abe0:	0026dc40 	call	26dc4 <no_printf>
    tse_dprintf(6, "\n");
   2abe4:	010000f4 	movhi	r4,3
   2abe8:	21092f04 	addi	r4,r4,9404
   2abec:	0026dc40 	call	26dc4 <no_printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   2abf0:	e0bffe83 	ldbu	r2,-6(fp)
   2abf4:	e13fff17 	ldw	r4,-4(fp)
   2abf8:	100b883a 	mov	r5,r2
   2abfc:	0028d2c0 	call	28d2c <alt_tse_phy_wr_mdio_addr>
    
    return return_value;
   2ac00:	e0bffb17 	ldw	r2,-20(fp)
    
}
   2ac04:	e037883a 	mov	sp,fp
   2ac08:	dfc00117 	ldw	ra,4(sp)
   2ac0c:	df000017 	ldw	fp,0(sp)
   2ac10:	dec00204 	addi	sp,sp,8
   2ac14:	f800283a 	ret

0002ac18 <alt_tse_phy_set_adv_1000>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_1000(alt_tse_phy_info *pphy, alt_u8 enable) {
   2ac18:	defff804 	addi	sp,sp,-32
   2ac1c:	dfc00715 	stw	ra,28(sp)
   2ac20:	df000615 	stw	fp,24(sp)
   2ac24:	df000604 	addi	fp,sp,24
   2ac28:	e13ffe15 	stw	r4,-8(fp)
   2ac2c:	2805883a 	mov	r2,r5
   2ac30:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
   2ac34:	e0bffe17 	ldw	r2,-8(fp)
   2ac38:	10800617 	ldw	r2,24(r2)
   2ac3c:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   2ac40:	e0bffb17 	ldw	r2,-20(fp)
   2ac44:	10800317 	ldw	r2,12(r2)
   2ac48:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   2ac4c:	e13ffb17 	ldw	r4,-20(fp)
   2ac50:	0027fac0 	call	27fac <alt_tse_get_mac_info_index>
   2ac54:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   2ac58:	e13ffc17 	ldw	r4,-16(fp)
   2ac5c:	0027f380 	call	27f38 <alt_tse_get_mac_group_index>
   2ac60:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
   2ac64:	e13ffe17 	ldw	r4,-8(fp)
   2ac68:	0028ce40 	call	28ce4 <alt_tse_phy_rd_mdio_addr>
   2ac6c:	e0bffd85 	stb	r2,-10(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
   2ac70:	e0bffe17 	ldw	r2,-8(fp)
   2ac74:	10800003 	ldbu	r2,0(r2)
   2ac78:	10803fcc 	andi	r2,r2,255
   2ac7c:	e13ffe17 	ldw	r4,-8(fp)
   2ac80:	100b883a 	mov	r5,r2
   2ac84:	0028d2c0 	call	28d2c <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
   2ac88:	e0bfff03 	ldbu	r2,-4(fp)
   2ac8c:	10002b26 	beq	r2,zero,2ad3c <alt_tse_phy_set_adv_1000+0x124>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1); 
   2ac90:	e13ffe17 	ldw	r4,-8(fp)
   2ac94:	014003c4 	movi	r5,15
   2ac98:	01800344 	movi	r6,13
   2ac9c:	01c00044 	movi	r7,1
   2aca0:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2aca4:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, cap);
   2aca8:	e0bffdc3 	ldbu	r2,-9(fp)
   2acac:	d8800015 	stw	r2,0(sp)
   2acb0:	e13ffe17 	ldw	r4,-8(fp)
   2acb4:	01400244 	movi	r5,9
   2acb8:	01800244 	movi	r6,9
   2acbc:	01c00044 	movi	r7,1
   2acc0:	0028d840 	call	28d84 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
   2acc4:	e17ffd47 	ldb	r5,-11(fp)
   2acc8:	e0fffd07 	ldb	r3,-12(fp)
   2accc:	e0bffdc3 	ldbu	r2,-9(fp)
   2acd0:	010000f4 	movhi	r4,3
   2acd4:	210b0804 	addi	r4,r4,11296
   2acd8:	180d883a 	mov	r6,r3
   2acdc:	100f883a 	mov	r7,r2
   2ace0:	0026dc40 	call	26dc4 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
   2ace4:	e13ffe17 	ldw	r4,-8(fp)
   2ace8:	014003c4 	movi	r5,15
   2acec:	01800304 	movi	r6,12
   2acf0:	01c00044 	movi	r7,1
   2acf4:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2acf8:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, cap);
   2acfc:	e0bffdc3 	ldbu	r2,-9(fp)
   2ad00:	d8800015 	stw	r2,0(sp)
   2ad04:	e13ffe17 	ldw	r4,-8(fp)
   2ad08:	01400244 	movi	r5,9
   2ad0c:	01800204 	movi	r6,8
   2ad10:	01c00044 	movi	r7,1
   2ad14:	0028d840 	call	28d84 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
   2ad18:	e17ffd47 	ldb	r5,-11(fp)
   2ad1c:	e0fffd07 	ldb	r3,-12(fp)
   2ad20:	e0bffdc3 	ldbu	r2,-9(fp)
   2ad24:	010000f4 	movhi	r4,3
   2ad28:	210b1b04 	addi	r4,r4,11372
   2ad2c:	180d883a 	mov	r6,r3
   2ad30:	100f883a 	mov	r7,r2
   2ad34:	0026dc40 	call	26dc4 <no_printf>
   2ad38:	00001c06 	br	2adac <alt_tse_phy_set_adv_1000+0x194>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, 0);
   2ad3c:	d8000015 	stw	zero,0(sp)
   2ad40:	e13ffe17 	ldw	r4,-8(fp)
   2ad44:	01400244 	movi	r5,9
   2ad48:	01800244 	movi	r6,9
   2ad4c:	01c00044 	movi	r7,1
   2ad50:	0028d840 	call	28d84 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
   2ad54:	e0fffd47 	ldb	r3,-11(fp)
   2ad58:	e0bffd07 	ldb	r2,-12(fp)
   2ad5c:	010000f4 	movhi	r4,3
   2ad60:	210b0804 	addi	r4,r4,11296
   2ad64:	180b883a 	mov	r5,r3
   2ad68:	100d883a 	mov	r6,r2
   2ad6c:	000f883a 	mov	r7,zero
   2ad70:	0026dc40 	call	26dc4 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, 0);
   2ad74:	d8000015 	stw	zero,0(sp)
   2ad78:	e13ffe17 	ldw	r4,-8(fp)
   2ad7c:	01400244 	movi	r5,9
   2ad80:	01800204 	movi	r6,8
   2ad84:	01c00044 	movi	r7,1
   2ad88:	0028d840 	call	28d84 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement 1000 Base-T half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
   2ad8c:	e0fffd47 	ldb	r3,-11(fp)
   2ad90:	e0bffd07 	ldb	r2,-12(fp)
   2ad94:	010000f4 	movhi	r4,3
   2ad98:	210b2e04 	addi	r4,r4,11448
   2ad9c:	180b883a 	mov	r5,r3
   2ada0:	100d883a 	mov	r6,r2
   2ada4:	000f883a 	mov	r7,zero
   2ada8:	0026dc40 	call	26dc4 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);    
   2adac:	e0bffd83 	ldbu	r2,-10(fp)
   2adb0:	e13ffe17 	ldw	r4,-8(fp)
   2adb4:	100b883a 	mov	r5,r2
   2adb8:	0028d2c0 	call	28d2c <alt_tse_phy_wr_mdio_addr>

    return SUCCESS;
   2adbc:	0005883a 	mov	r2,zero
}
   2adc0:	e037883a 	mov	sp,fp
   2adc4:	dfc00117 	ldw	ra,4(sp)
   2adc8:	df000017 	ldw	fp,0(sp)
   2adcc:	dec00204 	addi	sp,sp,8
   2add0:	f800283a 	ret

0002add4 <alt_tse_phy_set_adv_100>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_100(alt_tse_phy_info *pphy, alt_u8 enable) {
   2add4:	defff804 	addi	sp,sp,-32
   2add8:	dfc00715 	stw	ra,28(sp)
   2addc:	df000615 	stw	fp,24(sp)
   2ade0:	df000604 	addi	fp,sp,24
   2ade4:	e13ffe15 	stw	r4,-8(fp)
   2ade8:	2805883a 	mov	r2,r5
   2adec:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
   2adf0:	e0bffe17 	ldw	r2,-8(fp)
   2adf4:	10800617 	ldw	r2,24(r2)
   2adf8:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   2adfc:	e0bffb17 	ldw	r2,-20(fp)
   2ae00:	10800317 	ldw	r2,12(r2)
   2ae04:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   2ae08:	e13ffb17 	ldw	r4,-20(fp)
   2ae0c:	0027fac0 	call	27fac <alt_tse_get_mac_info_index>
   2ae10:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   2ae14:	e13ffc17 	ldw	r4,-16(fp)
   2ae18:	0027f380 	call	27f38 <alt_tse_get_mac_group_index>
   2ae1c:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
   2ae20:	e13ffe17 	ldw	r4,-8(fp)
   2ae24:	0028ce40 	call	28ce4 <alt_tse_phy_rd_mdio_addr>
   2ae28:	e0bffd85 	stb	r2,-10(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
   2ae2c:	e0bffe17 	ldw	r2,-8(fp)
   2ae30:	10800003 	ldbu	r2,0(r2)
   2ae34:	10803fcc 	andi	r2,r2,255
   2ae38:	e13ffe17 	ldw	r4,-8(fp)
   2ae3c:	100b883a 	mov	r5,r2
   2ae40:	0028d2c0 	call	28d2c <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
   2ae44:	e0bfff03 	ldbu	r2,-4(fp)
   2ae48:	10004026 	beq	r2,zero,2af4c <alt_tse_phy_set_adv_100+0x178>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
   2ae4c:	e13ffe17 	ldw	r4,-8(fp)
   2ae50:	01400044 	movi	r5,1
   2ae54:	018003c4 	movi	r6,15
   2ae58:	01c00044 	movi	r7,1
   2ae5c:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2ae60:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, cap);
   2ae64:	e0bffdc3 	ldbu	r2,-9(fp)
   2ae68:	d8800015 	stw	r2,0(sp)
   2ae6c:	e13ffe17 	ldw	r4,-8(fp)
   2ae70:	01400104 	movi	r5,4
   2ae74:	01800244 	movi	r6,9
   2ae78:	01c00044 	movi	r7,1
   2ae7c:	0028d840 	call	28d84 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, cap);
   2ae80:	e17ffd47 	ldb	r5,-11(fp)
   2ae84:	e0fffd07 	ldb	r3,-12(fp)
   2ae88:	e0bffdc3 	ldbu	r2,-9(fp)
   2ae8c:	010000f4 	movhi	r4,3
   2ae90:	210b4004 	addi	r4,r4,11520
   2ae94:	180d883a 	mov	r6,r3
   2ae98:	100f883a 	mov	r7,r2
   2ae9c:	0026dc40 	call	26dc4 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
   2aea0:	e13ffe17 	ldw	r4,-8(fp)
   2aea4:	01400044 	movi	r5,1
   2aea8:	01800384 	movi	r6,14
   2aeac:	01c00044 	movi	r7,1
   2aeb0:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2aeb4:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, cap);
   2aeb8:	e0bffdc3 	ldbu	r2,-9(fp)
   2aebc:	d8800015 	stw	r2,0(sp)
   2aec0:	e13ffe17 	ldw	r4,-8(fp)
   2aec4:	01400104 	movi	r5,4
   2aec8:	01800204 	movi	r6,8
   2aecc:	01c00044 	movi	r7,1
   2aed0:	0028d840 	call	28d84 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
   2aed4:	e17ffd47 	ldb	r5,-11(fp)
   2aed8:	e0fffd07 	ldb	r3,-12(fp)
   2aedc:	e0bffdc3 	ldbu	r2,-9(fp)
   2aee0:	010000f4 	movhi	r4,3
   2aee4:	210b5004 	addi	r4,r4,11584
   2aee8:	180d883a 	mov	r6,r3
   2aeec:	100f883a 	mov	r7,r2
   2aef0:	0026dc40 	call	26dc4 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
   2aef4:	e13ffe17 	ldw	r4,-8(fp)
   2aef8:	01400044 	movi	r5,1
   2aefc:	01800344 	movi	r6,13
   2af00:	01c00044 	movi	r7,1
   2af04:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2af08:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, cap);
   2af0c:	e0bffdc3 	ldbu	r2,-9(fp)
   2af10:	d8800015 	stw	r2,0(sp)
   2af14:	e13ffe17 	ldw	r4,-8(fp)
   2af18:	01400104 	movi	r5,4
   2af1c:	018001c4 	movi	r6,7
   2af20:	01c00044 	movi	r7,1
   2af24:	0028d840 	call	28d84 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
   2af28:	e17ffd47 	ldb	r5,-11(fp)
   2af2c:	e0fffd07 	ldb	r3,-12(fp)
   2af30:	e0bffdc3 	ldbu	r2,-9(fp)
   2af34:	010000f4 	movhi	r4,3
   2af38:	210b6304 	addi	r4,r4,11660
   2af3c:	180d883a 	mov	r6,r3
   2af40:	100f883a 	mov	r7,r2
   2af44:	0026dc40 	call	26dc4 <no_printf>
   2af48:	00002a06 	br	2aff4 <alt_tse_phy_set_adv_100+0x220>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, 0);
   2af4c:	d8000015 	stw	zero,0(sp)
   2af50:	e13ffe17 	ldw	r4,-8(fp)
   2af54:	01400104 	movi	r5,4
   2af58:	01800244 	movi	r6,9
   2af5c:	01c00044 	movi	r7,1
   2af60:	0028d840 	call	28d84 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, 0);
   2af64:	e0fffd47 	ldb	r3,-11(fp)
   2af68:	e0bffd07 	ldb	r2,-12(fp)
   2af6c:	010000f4 	movhi	r4,3
   2af70:	210b4004 	addi	r4,r4,11520
   2af74:	180b883a 	mov	r5,r3
   2af78:	100d883a 	mov	r6,r2
   2af7c:	000f883a 	mov	r7,zero
   2af80:	0026dc40 	call	26dc4 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, 0);
   2af84:	d8000015 	stw	zero,0(sp)
   2af88:	e13ffe17 	ldw	r4,-8(fp)
   2af8c:	01400104 	movi	r5,4
   2af90:	01800204 	movi	r6,8
   2af94:	01c00044 	movi	r7,1
   2af98:	0028d840 	call	28d84 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
   2af9c:	e0fffd47 	ldb	r3,-11(fp)
   2afa0:	e0bffd07 	ldb	r2,-12(fp)
   2afa4:	010000f4 	movhi	r4,3
   2afa8:	210b5004 	addi	r4,r4,11584
   2afac:	180b883a 	mov	r5,r3
   2afb0:	100d883a 	mov	r6,r2
   2afb4:	000f883a 	mov	r7,zero
   2afb8:	0026dc40 	call	26dc4 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, 0);
   2afbc:	d8000015 	stw	zero,0(sp)
   2afc0:	e13ffe17 	ldw	r4,-8(fp)
   2afc4:	01400104 	movi	r5,4
   2afc8:	018001c4 	movi	r6,7
   2afcc:	01c00044 	movi	r7,1
   2afd0:	0028d840 	call	28d84 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
   2afd4:	e0fffd47 	ldb	r3,-11(fp)
   2afd8:	e0bffd07 	ldb	r2,-12(fp)
   2afdc:	010000f4 	movhi	r4,3
   2afe0:	210b6304 	addi	r4,r4,11660
   2afe4:	180b883a 	mov	r5,r3
   2afe8:	100d883a 	mov	r6,r2
   2afec:	000f883a 	mov	r7,zero
   2aff0:	0026dc40 	call	26dc4 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);  
   2aff4:	e0bffd83 	ldbu	r2,-10(fp)
   2aff8:	e13ffe17 	ldw	r4,-8(fp)
   2affc:	100b883a 	mov	r5,r2
   2b000:	0028d2c0 	call	28d2c <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
   2b004:	0005883a 	mov	r2,zero
}
   2b008:	e037883a 	mov	sp,fp
   2b00c:	dfc00117 	ldw	ra,4(sp)
   2b010:	df000017 	ldw	fp,0(sp)
   2b014:	dec00204 	addi	sp,sp,8
   2b018:	f800283a 	ret

0002b01c <alt_tse_phy_set_adv_10>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_10(alt_tse_phy_info *pphy, alt_u8 enable) {
   2b01c:	defff504 	addi	sp,sp,-44
   2b020:	dfc00a15 	stw	ra,40(sp)
   2b024:	df000915 	stw	fp,36(sp)
   2b028:	df000904 	addi	fp,sp,36
   2b02c:	e13ffe15 	stw	r4,-8(fp)
   2b030:	2805883a 	mov	r2,r5
   2b034:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
   2b038:	e0bffe17 	ldw	r2,-8(fp)
   2b03c:	10800617 	ldw	r2,24(r2)
   2b040:	e0bff815 	stw	r2,-32(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   2b044:	e0bff817 	ldw	r2,-32(fp)
   2b048:	10800317 	ldw	r2,12(r2)
   2b04c:	e0bff915 	stw	r2,-28(fp)
    
    /* get index of the pointers in pointer array list */
    int mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   2b050:	e13ff817 	ldw	r4,-32(fp)
   2b054:	0027fac0 	call	27fac <alt_tse_get_mac_info_index>
   2b058:	e0bffa15 	stw	r2,-24(fp)
    int mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   2b05c:	e13ff917 	ldw	r4,-28(fp)
   2b060:	0027f380 	call	27f38 <alt_tse_get_mac_group_index>
   2b064:	e0bffb15 	stw	r2,-20(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    int mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
   2b068:	e13ffe17 	ldw	r4,-8(fp)
   2b06c:	0028ce40 	call	28ce4 <alt_tse_phy_rd_mdio_addr>
   2b070:	e0bffc15 	stw	r2,-16(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
   2b074:	e0bffe17 	ldw	r2,-8(fp)
   2b078:	10800003 	ldbu	r2,0(r2)
   2b07c:	10803fcc 	andi	r2,r2,255
   2b080:	e13ffe17 	ldw	r4,-8(fp)
   2b084:	100b883a 	mov	r5,r2
   2b088:	0028d2c0 	call	28d2c <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
   2b08c:	e0bfff03 	ldbu	r2,-4(fp)
   2b090:	10002926 	beq	r2,zero,2b138 <alt_tse_phy_set_adv_10+0x11c>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
   2b094:	e13ffe17 	ldw	r4,-8(fp)
   2b098:	01400044 	movi	r5,1
   2b09c:	01800304 	movi	r6,12
   2b0a0:	01c00044 	movi	r7,1
   2b0a4:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2b0a8:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, cap);
   2b0ac:	e0bffd03 	ldbu	r2,-12(fp)
   2b0b0:	d8800015 	stw	r2,0(sp)
   2b0b4:	e13ffe17 	ldw	r4,-8(fp)
   2b0b8:	01400104 	movi	r5,4
   2b0bc:	01800184 	movi	r6,6
   2b0c0:	01c00044 	movi	r7,1
   2b0c4:	0028d840 	call	28d84 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
   2b0c8:	e0bffd03 	ldbu	r2,-12(fp)
   2b0cc:	010000f4 	movhi	r4,3
   2b0d0:	210b7604 	addi	r4,r4,11736
   2b0d4:	e17ffb17 	ldw	r5,-20(fp)
   2b0d8:	e1bffa17 	ldw	r6,-24(fp)
   2b0dc:	100f883a 	mov	r7,r2
   2b0e0:	0026dc40 	call	26dc4 <no_printf>
    
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
   2b0e4:	e13ffe17 	ldw	r4,-8(fp)
   2b0e8:	01400044 	movi	r5,1
   2b0ec:	018002c4 	movi	r6,11
   2b0f0:	01c00044 	movi	r7,1
   2b0f4:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2b0f8:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, cap);
   2b0fc:	e0bffd03 	ldbu	r2,-12(fp)
   2b100:	d8800015 	stw	r2,0(sp)
   2b104:	e13ffe17 	ldw	r4,-8(fp)
   2b108:	01400104 	movi	r5,4
   2b10c:	01800144 	movi	r6,5
   2b110:	01c00044 	movi	r7,1
   2b114:	0028d840 	call	28d84 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
   2b118:	e0bffd03 	ldbu	r2,-12(fp)
   2b11c:	010000f4 	movhi	r4,3
   2b120:	210b8904 	addi	r4,r4,11812
   2b124:	e17ffb17 	ldw	r5,-20(fp)
   2b128:	e1bffa17 	ldw	r6,-24(fp)
   2b12c:	100f883a 	mov	r7,r2
   2b130:	0026dc40 	call	26dc4 <no_printf>
   2b134:	00001806 	br	2b198 <alt_tse_phy_set_adv_10+0x17c>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, 0);
   2b138:	d8000015 	stw	zero,0(sp)
   2b13c:	e13ffe17 	ldw	r4,-8(fp)
   2b140:	01400104 	movi	r5,4
   2b144:	01800184 	movi	r6,6
   2b148:	01c00044 	movi	r7,1
   2b14c:	0028d840 	call	28d84 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
   2b150:	010000f4 	movhi	r4,3
   2b154:	210b7604 	addi	r4,r4,11736
   2b158:	e17ffb17 	ldw	r5,-20(fp)
   2b15c:	e1bffa17 	ldw	r6,-24(fp)
   2b160:	000f883a 	mov	r7,zero
   2b164:	0026dc40 	call	26dc4 <no_printf>
    
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, 0);
   2b168:	d8000015 	stw	zero,0(sp)
   2b16c:	e13ffe17 	ldw	r4,-8(fp)
   2b170:	01400104 	movi	r5,4
   2b174:	01800144 	movi	r6,5
   2b178:	01c00044 	movi	r7,1
   2b17c:	0028d840 	call	28d84 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
   2b180:	010000f4 	movhi	r4,3
   2b184:	210b8904 	addi	r4,r4,11812
   2b188:	e17ffb17 	ldw	r5,-20(fp)
   2b18c:	e1bffa17 	ldw	r6,-24(fp)
   2b190:	000f883a 	mov	r7,zero
   2b194:	0026dc40 	call	26dc4 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   2b198:	e0bffc17 	ldw	r2,-16(fp)
   2b19c:	10803fcc 	andi	r2,r2,255
   2b1a0:	e13ffe17 	ldw	r4,-8(fp)
   2b1a4:	100b883a 	mov	r5,r2
   2b1a8:	0028d2c0 	call	28d2c <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
   2b1ac:	0005883a 	mov	r2,zero
}
   2b1b0:	e037883a 	mov	sp,fp
   2b1b4:	dfc00117 	ldw	ra,4(sp)
   2b1b8:	df000017 	ldw	fp,0(sp)
   2b1bc:	dec00204 	addi	sp,sp,8
   2b1c0:	f800283a 	ret

0002b1c4 <alt_tse_phy_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Internal
 * @param pmac_group    Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_phy_get_common_speed(alt_tse_mac_group *pmac_group) {
   2b1c4:	defff604 	addi	sp,sp,-40
   2b1c8:	dfc00915 	stw	ra,36(sp)
   2b1cc:	df000815 	stw	fp,32(sp)
   2b1d0:	df000804 	addi	fp,sp,32
   2b1d4:	e13fff15 	stw	r4,-4(fp)
    
	alt_32 i;
	alt_u8 common_1000 = 1;
   2b1d8:	00800044 	movi	r2,1
   2b1dc:	e0bff905 	stb	r2,-28(fp)
	alt_u8 common_100 = 1;
   2b1e0:	00800044 	movi	r2,1
   2b1e4:	e0bff945 	stb	r2,-27(fp)
	alt_u8 common_10 = 1;
   2b1e8:	00800044 	movi	r2,1
   2b1ec:	e0bff985 	stb	r2,-26(fp)
    
	alt_32 common_speed;
    
	alt_u8 none_an_complete = 1;
   2b1f0:	00800044 	movi	r2,1
   2b1f4:	e0bffb05 	stb	r2,-20(fp)
    
    alt_tse_mac_info *pmac_info = 0;
   2b1f8:	e03ffc15 	stw	zero,-16(fp)
    alt_tse_phy_info *pphy = 0;
   2b1fc:	e03ffd15 	stw	zero,-12(fp)
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   2b200:	e13fff17 	ldw	r4,-4(fp)
   2b204:	0027f380 	call	27f38 <alt_tse_get_mac_group_index>
   2b208:	e0bffe05 	stb	r2,-8(fp)
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
   2b20c:	e03ff815 	stw	zero,-32(fp)
   2b210:	00001c06 	br	2b284 <alt_tse_phy_get_common_speed+0xc0>
        pmac_info = pmac_group->pmac_info[i];
   2b214:	e0ffff17 	ldw	r3,-4(fp)
   2b218:	e0bff817 	ldw	r2,-32(fp)
   2b21c:	10800044 	addi	r2,r2,1
   2b220:	1085883a 	add	r2,r2,r2
   2b224:	1085883a 	add	r2,r2,r2
   2b228:	1885883a 	add	r2,r3,r2
   2b22c:	10800017 	ldw	r2,0(r2)
   2b230:	e0bffc15 	stw	r2,-16(fp)
        pphy = pmac_info->pphy_info;
   2b234:	e0bffc17 	ldw	r2,-16(fp)
   2b238:	10800117 	ldw	r2,4(r2)
   2b23c:	e0bffd15 	stw	r2,-12(fp)
        
        /* run only if PHY connected */
        if(pphy) {
   2b240:	e0bffd17 	ldw	r2,-12(fp)
   2b244:	10000926 	beq	r2,zero,2b26c <alt_tse_phy_get_common_speed+0xa8>
            alt_tse_phy_set_adv_1000(pphy, 1);
   2b248:	e13ffd17 	ldw	r4,-12(fp)
   2b24c:	01400044 	movi	r5,1
   2b250:	002ac180 	call	2ac18 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
   2b254:	e13ffd17 	ldw	r4,-12(fp)
   2b258:	01400044 	movi	r5,1
   2b25c:	002add40 	call	2add4 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
   2b260:	e13ffd17 	ldw	r4,-12(fp)
   2b264:	01400044 	movi	r5,1
   2b268:	002b01c0 	call	2b01c <alt_tse_phy_set_adv_10>
        }
        tse_dprintf(6, "\n");
   2b26c:	010000f4 	movhi	r4,3
   2b270:	21092f04 	addi	r4,r4,9404
   2b274:	0026dc40 	call	26dc4 <no_printf>
    alt_tse_phy_info *pphy = 0;
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
   2b278:	e0bff817 	ldw	r2,-32(fp)
   2b27c:	10800044 	addi	r2,r2,1
   2b280:	e0bff815 	stw	r2,-32(fp)
   2b284:	e0bfff17 	ldw	r2,-4(fp)
   2b288:	10800003 	ldbu	r2,0(r2)
   2b28c:	10803fcc 	andi	r2,r2,255
   2b290:	e0fff817 	ldw	r3,-32(fp)
   2b294:	18bfdf16 	blt	r3,r2,2b214 <alt_tse_phy_get_common_speed+0x50>
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
   2b298:	e03ff815 	stw	zero,-32(fp)
   2b29c:	00005606 	br	2b3f8 <alt_tse_phy_get_common_speed+0x234>

        pmac_info = pmac_group->pmac_info[i];
   2b2a0:	e0ffff17 	ldw	r3,-4(fp)
   2b2a4:	e0bff817 	ldw	r2,-32(fp)
   2b2a8:	10800044 	addi	r2,r2,1
   2b2ac:	1085883a 	add	r2,r2,r2
   2b2b0:	1085883a 	add	r2,r2,r2
   2b2b4:	1885883a 	add	r2,r3,r2
   2b2b8:	10800017 	ldw	r2,0(r2)
   2b2bc:	e0bffc15 	stw	r2,-16(fp)
        pphy = pmac_info->pphy_info;
   2b2c0:	e0bffc17 	ldw	r2,-16(fp)
   2b2c4:	10800117 	ldw	r2,4(r2)
   2b2c8:	e0bffd15 	stw	r2,-12(fp)
        
        /* if no PHY connected */
        if(!pphy) {
   2b2cc:	e0bffd17 	ldw	r2,-12(fp)
   2b2d0:	10004326 	beq	r2,zero,2b3e0 <alt_tse_phy_get_common_speed+0x21c>
            continue;
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
   2b2d4:	e13ffd17 	ldw	r4,-12(fp)
   2b2d8:	002a6800 	call	2a680 <alt_tse_phy_get_cap>
   2b2dc:	1000421e 	bne	r2,zero,2b3e8 <alt_tse_phy_get_common_speed+0x224>
            continue;
        }
        
        none_an_complete = 0;
   2b2e0:	e03ffb05 	stb	zero,-20(fp)
        
        /* Small MAC */
        if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
   2b2e4:	e0bffc17 	ldw	r2,-16(fp)
   2b2e8:	10800003 	ldbu	r2,0(r2)
   2b2ec:	10803fcc 	andi	r2,r2,255
   2b2f0:	10800058 	cmpnei	r2,r2,1
   2b2f4:	1000021e 	bne	r2,zero,2b300 <alt_tse_phy_get_common_speed+0x13c>
            common_1000 = 0;
   2b2f8:	e03ff905 	stb	zero,-28(fp)
   2b2fc:	00000706 	br	2b31c <alt_tse_phy_get_common_speed+0x158>
        }
        else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
   2b300:	e0bffc17 	ldw	r2,-16(fp)
   2b304:	10800003 	ldbu	r2,0(r2)
   2b308:	10803fcc 	andi	r2,r2,255
   2b30c:	10800098 	cmpnei	r2,r2,2
   2b310:	1000021e 	bne	r2,zero,2b31c <alt_tse_phy_get_common_speed+0x158>
            common_100 = 0;
   2b314:	e03ff945 	stb	zero,-27(fp)
            common_10 = 0;            
   2b318:	e03ff985 	stb	zero,-26(fp)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
   2b31c:	e0bffd17 	ldw	r2,-12(fp)
   2b320:	10c000c3 	ldbu	r3,3(r2)
   2b324:	e0bffd17 	ldw	r2,-12(fp)
   2b328:	10800303 	ldbu	r2,12(r2)
   2b32c:	1884703a 	and	r2,r3,r2
   2b330:	1007883a 	mov	r3,r2
   2b334:	e0bff903 	ldbu	r2,-28(fp)
   2b338:	1884703a 	and	r2,r3,r2
   2b33c:	e0bff905 	stb	r2,-28(fp)
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
   2b340:	e0bffd17 	ldw	r2,-12(fp)
   2b344:	10c00183 	ldbu	r3,6(r2)
   2b348:	e0bffd17 	ldw	r2,-12(fp)
   2b34c:	108003c3 	ldbu	r2,15(r2)
   2b350:	1884703a 	and	r2,r3,r2
   2b354:	1007883a 	mov	r3,r2
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
   2b358:	e0bffd17 	ldw	r2,-12(fp)
   2b35c:	110001c3 	ldbu	r4,7(r2)
   2b360:	e0bffd17 	ldw	r2,-12(fp)
   2b364:	10800403 	ldbu	r2,16(r2)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
   2b368:	2084703a 	and	r2,r4,r2
   2b36c:	1884b03a 	or	r2,r3,r2
   2b370:	1007883a 	mov	r3,r2
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
   2b374:	e0bffd17 	ldw	r2,-12(fp)
   2b378:	11000143 	ldbu	r4,5(r2)
   2b37c:	e0bffd17 	ldw	r2,-12(fp)
   2b380:	10800383 	ldbu	r2,14(r2)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
   2b384:	2084703a 	and	r2,r4,r2
   2b388:	1884b03a 	or	r2,r3,r2
   2b38c:	1007883a 	mov	r3,r2
   2b390:	e0bff943 	ldbu	r2,-27(fp)
   2b394:	1884703a 	and	r2,r3,r2
   2b398:	e0bff945 	stb	r2,-27(fp)
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
        common_10 &= ((pphy->link_capability.cap_10_base_t_full & pphy->link_capability.lp_10_base_tx_full) |
   2b39c:	e0bffd17 	ldw	r2,-12(fp)
   2b3a0:	10c00283 	ldbu	r3,10(r2)
   2b3a4:	e0bffd17 	ldw	r2,-12(fp)
   2b3a8:	10800443 	ldbu	r2,17(r2)
   2b3ac:	1884703a 	and	r2,r3,r2
   2b3b0:	1007883a 	mov	r3,r2
                        (pphy->link_capability.cap_10_base_t_half & pphy->link_capability.lp_10_base_tx_half));
   2b3b4:	e0bffd17 	ldw	r2,-12(fp)
   2b3b8:	110002c3 	ldbu	r4,11(r2)
   2b3bc:	e0bffd17 	ldw	r2,-12(fp)
   2b3c0:	10800483 	ldbu	r2,18(r2)
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
        common_10 &= ((pphy->link_capability.cap_10_base_t_full & pphy->link_capability.lp_10_base_tx_full) |
   2b3c4:	2084703a 	and	r2,r4,r2
   2b3c8:	1884b03a 	or	r2,r3,r2
   2b3cc:	1007883a 	mov	r3,r2
   2b3d0:	e0bff983 	ldbu	r2,-26(fp)
   2b3d4:	1884703a 	and	r2,r3,r2
   2b3d8:	e0bff985 	stb	r2,-26(fp)
   2b3dc:	00000306 	br	2b3ec <alt_tse_phy_get_common_speed+0x228>
        pmac_info = pmac_group->pmac_info[i];
        pphy = pmac_info->pphy_info;
        
        /* if no PHY connected */
        if(!pphy) {
            continue;
   2b3e0:	0001883a 	nop
   2b3e4:	00000106 	br	2b3ec <alt_tse_phy_get_common_speed+0x228>
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
            continue;
   2b3e8:	0001883a 	nop
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
   2b3ec:	e0bff817 	ldw	r2,-32(fp)
   2b3f0:	10800044 	addi	r2,r2,1
   2b3f4:	e0bff815 	stw	r2,-32(fp)
   2b3f8:	e0bfff17 	ldw	r2,-4(fp)
   2b3fc:	10800003 	ldbu	r2,0(r2)
   2b400:	10803fcc 	andi	r2,r2,255
   2b404:	e0fff817 	ldw	r3,-32(fp)
   2b408:	18bfa516 	blt	r3,r2,2b2a0 <alt_tse_phy_get_common_speed+0xdc>
                        (pphy->link_capability.cap_10_base_t_half & pphy->link_capability.lp_10_base_tx_half));

    }
    
    /* get common speed based on capabilities */
    if(none_an_complete == 1) {
   2b40c:	e0bffb03 	ldbu	r2,-20(fp)
   2b410:	10800058 	cmpnei	r2,r2,1
   2b414:	1000081e 	bne	r2,zero,2b438 <alt_tse_phy_get_common_speed+0x274>
        common_speed = TSE_PHY_SPEED_NO_COMMON;
   2b418:	00bfffc4 	movi	r2,-1
   2b41c:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - None of the PHYs Auto-Negotiation completed!\n", mac_group_index);
   2b420:	e0bffe07 	ldb	r2,-8(fp)
   2b424:	010000f4 	movhi	r4,3
   2b428:	210b9c04 	addi	r4,r4,11888
   2b42c:	100b883a 	mov	r5,r2
   2b430:	00193f00 	call	193f0 <printf>
   2b434:	00002706 	br	2b4d4 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_1000) {
   2b438:	e0bff903 	ldbu	r2,-28(fp)
   2b43c:	10000926 	beq	r2,zero,2b464 <alt_tse_phy_get_common_speed+0x2a0>
        common_speed = TSE_PHY_SPEED_1000;
   2b440:	00800084 	movi	r2,2
   2b444:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 1000);
   2b448:	e0bffe07 	ldb	r2,-8(fp)
   2b44c:	010000f4 	movhi	r4,3
   2b450:	210bae04 	addi	r4,r4,11960
   2b454:	100b883a 	mov	r5,r2
   2b458:	0180fa04 	movi	r6,1000
   2b45c:	00193f00 	call	193f0 <printf>
   2b460:	00001c06 	br	2b4d4 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_100) {
   2b464:	e0bff943 	ldbu	r2,-27(fp)
   2b468:	10000926 	beq	r2,zero,2b490 <alt_tse_phy_get_common_speed+0x2cc>
        common_speed = TSE_PHY_SPEED_100;
   2b46c:	00800044 	movi	r2,1
   2b470:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 100);
   2b474:	e0bffe07 	ldb	r2,-8(fp)
   2b478:	010000f4 	movhi	r4,3
   2b47c:	210bae04 	addi	r4,r4,11960
   2b480:	100b883a 	mov	r5,r2
   2b484:	01801904 	movi	r6,100
   2b488:	00193f00 	call	193f0 <printf>
   2b48c:	00001106 	br	2b4d4 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_10) {
   2b490:	e0bff983 	ldbu	r2,-26(fp)
   2b494:	10000826 	beq	r2,zero,2b4b8 <alt_tse_phy_get_common_speed+0x2f4>
        common_speed = TSE_PHY_SPEED_10;
   2b498:	e03ffa15 	stw	zero,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 10);
   2b49c:	e0bffe07 	ldb	r2,-8(fp)
   2b4a0:	010000f4 	movhi	r4,3
   2b4a4:	210bae04 	addi	r4,r4,11960
   2b4a8:	100b883a 	mov	r5,r2
   2b4ac:	01800284 	movi	r6,10
   2b4b0:	00193f00 	call	193f0 <printf>
   2b4b4:	00000706 	br	2b4d4 <alt_tse_phy_get_common_speed+0x310>
    }
    else {
        common_speed = TSE_PHY_SPEED_NO_COMMON;
   2b4b8:	00bfffc4 	movi	r2,-1
   2b4bc:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - No common speed at all!\n", mac_group_index);    }
   2b4c0:	e0bffe07 	ldb	r2,-8(fp)
   2b4c4:	010000f4 	movhi	r4,3
   2b4c8:	210bbb04 	addi	r4,r4,12012
   2b4cc:	100b883a 	mov	r5,r2
   2b4d0:	00193f00 	call	193f0 <printf>

    return common_speed;
   2b4d4:	e0bffa17 	ldw	r2,-24(fp)
}
   2b4d8:	e037883a 	mov	sp,fp
   2b4dc:	dfc00117 	ldw	ra,4(sp)
   2b4e0:	df000017 	ldw	fp,0(sp)
   2b4e4:	dec00204 	addi	sp,sp,8
   2b4e8:	f800283a 	ret

0002b4ec <alt_tse_phy_set_common_speed>:
 * @API Type:               Internal
 * @param pmac_group        Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 *        common_speed      common speed supported by all PHYs
 * @return      common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_phy_set_common_speed(alt_tse_mac_group *pmac_group, alt_32 common_speed) {
   2b4ec:	defff004 	addi	sp,sp,-64
   2b4f0:	dfc00f15 	stw	ra,60(sp)
   2b4f4:	df000e15 	stw	fp,56(sp)
   2b4f8:	dc400d15 	stw	r17,52(sp)
   2b4fc:	dc000c15 	stw	r16,48(sp)
   2b500:	df000c04 	addi	fp,sp,48
   2b504:	e13ffe15 	stw	r4,-8(fp)
   2b508:	e17fff15 	stw	r5,-4(fp)
	alt_u8 speed;
	alt_u8 duplex;
    
	alt_u8 gb_capable;
    
    alt_tse_phy_info *pphy = 0;
   2b50c:	e03ff715 	stw	zero,-36(fp)
    alt_tse_mac_info *pmac_info = 0;
   2b510:	e03ff815 	stw	zero,-32(fp)
    alt_tse_system_info *psys = 0;
   2b514:	e03ff915 	stw	zero,-28(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
   2b518:	e03ffa05 	stb	zero,-24(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   2b51c:	e13ffe17 	ldw	r4,-8(fp)
   2b520:	0027f380 	call	27f38 <alt_tse_get_mac_group_index>
   2b524:	e0bffa45 	stb	r2,-23(fp)
         
    /* Record previous MDIO address, to be restored at the end of function */
    np_tse_mac *pmac_group_base = (np_tse_mac *)pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   2b528:	e0bffe17 	ldw	r2,-8(fp)
   2b52c:	10800117 	ldw	r2,4(r2)
   2b530:	10800217 	ldw	r2,8(r2)
   2b534:	10800017 	ldw	r2,0(r2)
   2b538:	e0bffb15 	stw	r2,-20(fp)
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
   2b53c:	e0bffb17 	ldw	r2,-20(fp)
   2b540:	10801004 	addi	r2,r2,64
   2b544:	10800037 	ldwio	r2,0(r2)
   2b548:	e0bffc15 	stw	r2,-16(fp)
    
    if((common_speed < TSE_PHY_SPEED_10) || (common_speed > TSE_PHY_SPEED_1000)) {
   2b54c:	e0bfff17 	ldw	r2,-4(fp)
   2b550:	10000316 	blt	r2,zero,2b560 <alt_tse_phy_set_common_speed+0x74>
   2b554:	e0bfff17 	ldw	r2,-4(fp)
   2b558:	108000d0 	cmplti	r2,r2,3
   2b55c:	10000c1e 	bne	r2,zero,2b590 <alt_tse_phy_set_common_speed+0xa4>
        tse_dprintf(2, "ERROR   : MAC Group[%d] - Invalid common speed specified! common speed = %d\n", mac_group_index, (int)common_speed);
   2b560:	e0bffa47 	ldb	r2,-23(fp)
   2b564:	010000f4 	movhi	r4,3
   2b568:	210bc804 	addi	r4,r4,12064
   2b56c:	100b883a 	mov	r5,r2
   2b570:	e1bfff17 	ldw	r6,-4(fp)
   2b574:	00193f00 	call	193f0 <printf>
		/* Restore previous MDIO address */
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
   2b578:	e0bffb17 	ldw	r2,-20(fp)
   2b57c:	10801004 	addi	r2,r2,64
   2b580:	e0fffc17 	ldw	r3,-16(fp)
   2b584:	10c00035 	stwio	r3,0(r2)
        return TSE_PHY_SPEED_NO_COMMON;
   2b588:	00bfffc4 	movi	r2,-1
   2b58c:	0000fe06 	br	2b988 <alt_tse_phy_set_common_speed+0x49c>
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
   2b590:	e03ff515 	stw	zero,-44(fp)
   2b594:	0000dc06 	br	2b908 <alt_tse_phy_set_common_speed+0x41c>
        pmac_info = pmac_group->pmac_info[i];
   2b598:	e0fffe17 	ldw	r3,-8(fp)
   2b59c:	e0bff517 	ldw	r2,-44(fp)
   2b5a0:	10800044 	addi	r2,r2,1
   2b5a4:	1085883a 	add	r2,r2,r2
   2b5a8:	1085883a 	add	r2,r2,r2
   2b5ac:	1885883a 	add	r2,r3,r2
   2b5b0:	10800017 	ldw	r2,0(r2)
   2b5b4:	e0bff815 	stw	r2,-32(fp)
        mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   2b5b8:	e13ff817 	ldw	r4,-32(fp)
   2b5bc:	0027fac0 	call	27fac <alt_tse_get_mac_info_index>
   2b5c0:	e0bffa05 	stb	r2,-24(fp)

        pphy = pmac_info->pphy_info;
   2b5c4:	e0bff817 	ldw	r2,-32(fp)
   2b5c8:	10800117 	ldw	r2,4(r2)
   2b5cc:	e0bff715 	stw	r2,-36(fp)
        
        /* if no PHY connected */
        if(!pphy) {
   2b5d0:	e0bff717 	ldw	r2,-36(fp)
   2b5d4:	1000c826 	beq	r2,zero,2b8f8 <alt_tse_phy_set_common_speed+0x40c>
            continue;
        }
        
        psys = pmac_info->psys_info; 
   2b5d8:	e0bff817 	ldw	r2,-32(fp)
   2b5dc:	10800217 	ldw	r2,8(r2)
   2b5e0:	e0bff915 	stw	r2,-28(fp)
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
   2b5e4:	e0bff717 	ldw	r2,-36(fp)
   2b5e8:	10800003 	ldbu	r2,0(r2)
   2b5ec:	10803fcc 	andi	r2,r2,255
   2b5f0:	e13ff717 	ldw	r4,-36(fp)
   2b5f4:	100b883a 	mov	r5,r2
   2b5f8:	0028d2c0 	call	28d2c <alt_tse_phy_wr_mdio_addr>

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
   2b5fc:	e0bff717 	ldw	r2,-36(fp)
   2b600:	108000c3 	ldbu	r2,3(r2)
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
   2b604:	10803fcc 	andi	r2,r2,255
   2b608:	10000c1e 	bne	r2,zero,2b63c <alt_tse_phy_set_common_speed+0x150>
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
   2b60c:	e0bff717 	ldw	r2,-36(fp)
   2b610:	10800103 	ldbu	r2,4(r2)
   2b614:	10803fcc 	andi	r2,r2,255
   2b618:	1000081e 	bne	r2,zero,2b63c <alt_tse_phy_set_common_speed+0x150>
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
   2b61c:	e0bff717 	ldw	r2,-36(fp)
   2b620:	10800043 	ldbu	r2,1(r2)
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
   2b624:	10803fcc 	andi	r2,r2,255
   2b628:	1000041e 	bne	r2,zero,2b63c <alt_tse_phy_set_common_speed+0x150>
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
   2b62c:	e0bff717 	ldw	r2,-36(fp)
   2b630:	10800083 	ldbu	r2,2(r2)
   2b634:	10803fcc 	andi	r2,r2,255
   2b638:	10000226 	beq	r2,zero,2b644 <alt_tse_phy_set_common_speed+0x158>
   2b63c:	00800044 	movi	r2,1
   2b640:	00000106 	br	2b648 <alt_tse_phy_set_common_speed+0x15c>
   2b644:	0005883a 	mov	r2,zero
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
   2b648:	e0bffd05 	stb	r2,-12(fp)
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
        
        /* if PHY does not supports 1000 Mbps, and common speed is 1000 Mbps */
        if((!gb_capable) && (common_speed == TSE_PHY_SPEED_1000)) {
   2b64c:	e0bffd03 	ldbu	r2,-12(fp)
   2b650:	1000101e 	bne	r2,zero,2b694 <alt_tse_phy_set_common_speed+0x1a8>
   2b654:	e0bfff17 	ldw	r2,-4(fp)
   2b658:	10800098 	cmpnei	r2,r2,2
   2b65c:	10000d1e 	bne	r2,zero,2b694 <alt_tse_phy_set_common_speed+0x1a8>
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - PHY does not support 1000 Mbps, please specify valid common speed\n", mac_group_index, mac_info_index);
   2b660:	e0fffa47 	ldb	r3,-23(fp)
   2b664:	e0bffa07 	ldb	r2,-24(fp)
   2b668:	010000f4 	movhi	r4,3
   2b66c:	210bdc04 	addi	r4,r4,12144
   2b670:	180b883a 	mov	r5,r3
   2b674:	100d883a 	mov	r6,r2
   2b678:	00193f00 	call	193f0 <printf>
			/* Restore previous MDIO address */
			IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
   2b67c:	e0bffb17 	ldw	r2,-20(fp)
   2b680:	10801004 	addi	r2,r2,64
   2b684:	e0fffc17 	ldw	r3,-16(fp)
   2b688:	10c00035 	stwio	r3,0(r2)
            return TSE_PHY_SPEED_NO_COMMON;
   2b68c:	00bfffc4 	movi	r2,-1
   2b690:	0000bd06 	br	2b988 <alt_tse_phy_set_common_speed+0x49c>
        }
        
        /* if PHY is not Auto-Negotiation capable */
        if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
   2b694:	e13ff717 	ldw	r4,-36(fp)
   2b698:	01400044 	movi	r5,1
   2b69c:	018000c4 	movi	r6,3
   2b6a0:	01c00044 	movi	r7,1
   2b6a4:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2b6a8:	1000141e 	bne	r2,zero,2b6fc <alt_tse_phy_set_common_speed+0x210>
            
            /* if PHY supports 1000 Mbps, write msb of speed */
            if(gb_capable) {
   2b6ac:	e0bffd03 	ldbu	r2,-12(fp)
   2b6b0:	10000926 	beq	r2,zero,2b6d8 <alt_tse_phy_set_common_speed+0x1ec>
                alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_MSB, 1, common_speed >> 1);
   2b6b4:	e0bfff17 	ldw	r2,-4(fp)
   2b6b8:	1005d07a 	srai	r2,r2,1
   2b6bc:	10bfffcc 	andi	r2,r2,65535
   2b6c0:	d8800015 	stw	r2,0(sp)
   2b6c4:	e13ff717 	ldw	r4,-36(fp)
   2b6c8:	000b883a 	mov	r5,zero
   2b6cc:	01800184 	movi	r6,6
   2b6d0:	01c00044 	movi	r7,1
   2b6d4:	0028d840 	call	28d84 <alt_tse_phy_wr_mdio_reg>
            }
            /* write lsb of speed */
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_LSB, 1, common_speed);
   2b6d8:	e0bfff17 	ldw	r2,-4(fp)
   2b6dc:	10bfffcc 	andi	r2,r2,65535
   2b6e0:	d8800015 	stw	r2,0(sp)
   2b6e4:	e13ff717 	ldw	r4,-36(fp)
   2b6e8:	000b883a 	mov	r5,zero
   2b6ec:	01800344 	movi	r6,13
   2b6f0:	01c00044 	movi	r7,1
   2b6f4:	0028d840 	call	28d84 <alt_tse_phy_wr_mdio_reg>
            
            /* continue to next PHY */
            continue;
   2b6f8:	00008006 	br	2b8fc <alt_tse_phy_set_common_speed+0x410>
        }
        
        /* set Auto-Negotiation advertisement based on common speed */
        if(common_speed == TSE_PHY_SPEED_1000) {
   2b6fc:	e0bfff17 	ldw	r2,-4(fp)
   2b700:	10800098 	cmpnei	r2,r2,2
   2b704:	10000a1e 	bne	r2,zero,2b730 <alt_tse_phy_set_common_speed+0x244>
            alt_tse_phy_set_adv_1000(pphy, 1);
   2b708:	e13ff717 	ldw	r4,-36(fp)
   2b70c:	01400044 	movi	r5,1
   2b710:	002ac180 	call	2ac18 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
   2b714:	e13ff717 	ldw	r4,-36(fp)
   2b718:	01400044 	movi	r5,1
   2b71c:	002add40 	call	2add4 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
   2b720:	e13ff717 	ldw	r4,-36(fp)
   2b724:	01400044 	movi	r5,1
   2b728:	002b01c0 	call	2b01c <alt_tse_phy_set_adv_10>
   2b72c:	00002206 	br	2b7b8 <alt_tse_phy_set_common_speed+0x2cc>
        }
        else if(common_speed == TSE_PHY_SPEED_100) {
   2b730:	e0bfff17 	ldw	r2,-4(fp)
   2b734:	10800058 	cmpnei	r2,r2,1
   2b738:	10000a1e 	bne	r2,zero,2b764 <alt_tse_phy_set_common_speed+0x278>
            alt_tse_phy_set_adv_1000(pphy, 0);
   2b73c:	e13ff717 	ldw	r4,-36(fp)
   2b740:	000b883a 	mov	r5,zero
   2b744:	002ac180 	call	2ac18 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
   2b748:	e13ff717 	ldw	r4,-36(fp)
   2b74c:	01400044 	movi	r5,1
   2b750:	002add40 	call	2add4 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
   2b754:	e13ff717 	ldw	r4,-36(fp)
   2b758:	01400044 	movi	r5,1
   2b75c:	002b01c0 	call	2b01c <alt_tse_phy_set_adv_10>
   2b760:	00001506 	br	2b7b8 <alt_tse_phy_set_common_speed+0x2cc>
        }    
        else if(common_speed == TSE_PHY_SPEED_10) {
   2b764:	e0bfff17 	ldw	r2,-4(fp)
   2b768:	10000a1e 	bne	r2,zero,2b794 <alt_tse_phy_set_common_speed+0x2a8>
            alt_tse_phy_set_adv_1000(pphy, 0);
   2b76c:	e13ff717 	ldw	r4,-36(fp)
   2b770:	000b883a 	mov	r5,zero
   2b774:	002ac180 	call	2ac18 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
   2b778:	e13ff717 	ldw	r4,-36(fp)
   2b77c:	000b883a 	mov	r5,zero
   2b780:	002add40 	call	2add4 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
   2b784:	e13ff717 	ldw	r4,-36(fp)
   2b788:	01400044 	movi	r5,1
   2b78c:	002b01c0 	call	2b01c <alt_tse_phy_set_adv_10>
   2b790:	00000906 	br	2b7b8 <alt_tse_phy_set_common_speed+0x2cc>
        }
        else {
            alt_tse_phy_set_adv_1000(pphy, 0);
   2b794:	e13ff717 	ldw	r4,-36(fp)
   2b798:	000b883a 	mov	r5,zero
   2b79c:	002ac180 	call	2ac18 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
   2b7a0:	e13ff717 	ldw	r4,-36(fp)
   2b7a4:	000b883a 	mov	r5,zero
   2b7a8:	002add40 	call	2add4 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 0);
   2b7ac:	e13ff717 	ldw	r4,-36(fp)
   2b7b0:	000b883a 	mov	r5,zero
   2b7b4:	002b01c0 	call	2b01c <alt_tse_phy_set_adv_10>
        }
        
        /* if PHY Auto-Negotiation is completed */
        if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 1) {
   2b7b8:	e13ff717 	ldw	r4,-36(fp)
   2b7bc:	01400044 	movi	r5,1
   2b7c0:	01800144 	movi	r6,5
   2b7c4:	01c00044 	movi	r7,1
   2b7c8:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2b7cc:	10800058 	cmpnei	r2,r2,1
   2b7d0:	10003b1e 	bne	r2,zero,2b8c0 <alt_tse_phy_set_common_speed+0x3d4>
            
            /* read both msb and lsb of speed bits if PHY support 1000 Mbps */
            if(gb_capable) {
   2b7d4:	e0bffd03 	ldbu	r2,-12(fp)
   2b7d8:	10000f26 	beq	r2,zero,2b818 <alt_tse_phy_set_common_speed+0x32c>
        
                /* get speed information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
   2b7dc:	e0bff717 	ldw	r2,-36(fp)
   2b7e0:	10800517 	ldw	r2,20(r2)
   2b7e4:	10801583 	ldbu	r2,86(r2)
   2b7e8:	10c03fcc 	andi	r3,r2,255
   2b7ec:	e0bff717 	ldw	r2,-36(fp)
   2b7f0:	10800517 	ldw	r2,20(r2)
   2b7f4:	108015c3 	ldbu	r2,87(r2)
   2b7f8:	10803fcc 	andi	r2,r2,255
   2b7fc:	e13ff717 	ldw	r4,-36(fp)
   2b800:	180b883a 	mov	r5,r3
   2b804:	100d883a 	mov	r6,r2
   2b808:	01c00084 	movi	r7,2
   2b80c:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2b810:	e0bff605 	stb	r2,-40(fp)
   2b814:	00000e06 	br	2b850 <alt_tse_phy_set_common_speed+0x364>
            }
            
            /* read lsb of speed only if PHY support only 10/100 Mbps */
            else {
                /* get speed and link information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 1);
   2b818:	e0bff717 	ldw	r2,-36(fp)
   2b81c:	10800517 	ldw	r2,20(r2)
   2b820:	10801583 	ldbu	r2,86(r2)
   2b824:	10c03fcc 	andi	r3,r2,255
   2b828:	e0bff717 	ldw	r2,-36(fp)
   2b82c:	10800517 	ldw	r2,20(r2)
   2b830:	108015c3 	ldbu	r2,87(r2)
   2b834:	10803fcc 	andi	r2,r2,255
   2b838:	e13ff717 	ldw	r4,-36(fp)
   2b83c:	180b883a 	mov	r5,r3
   2b840:	100d883a 	mov	r6,r2
   2b844:	01c00044 	movi	r7,1
   2b848:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2b84c:	e0bff605 	stb	r2,-40(fp)
            }
            
            /* if current speed != common speed, then restart Auto-Negotiation */
            if(speed != common_speed) {
   2b850:	e0fff603 	ldbu	r3,-40(fp)
   2b854:	e0bfff17 	ldw	r2,-4(fp)
   2b858:	18800426 	beq	r3,r2,2b86c <alt_tse_phy_set_common_speed+0x380>
                alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
   2b85c:	e13ff717 	ldw	r4,-36(fp)
   2b860:	01400134 	movhi	r5,4
   2b864:	29742404 	addi	r5,r5,-12144
   2b868:	002a35c0 	call	2a35c <alt_tse_phy_restart_an>
            }
            
            /* get speed information after Auto-Negotiation */
            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
   2b86c:	e0bff717 	ldw	r2,-36(fp)
   2b870:	10800517 	ldw	r2,20(r2)
   2b874:	10801583 	ldbu	r2,86(r2)
   2b878:	10c03fcc 	andi	r3,r2,255
   2b87c:	e0bff717 	ldw	r2,-36(fp)
   2b880:	10800517 	ldw	r2,20(r2)
   2b884:	10801603 	ldbu	r2,88(r2)
   2b888:	10803fcc 	andi	r2,r2,255
   2b88c:	e13ff717 	ldw	r4,-36(fp)
   2b890:	180b883a 	mov	r5,r3
   2b894:	100d883a 	mov	r6,r2
   2b898:	01c00044 	movi	r7,1
   2b89c:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2b8a0:	e0bffd45 	stb	r2,-11(fp)
            
            /* Set MAC duplex register */
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
   2b8a4:	e0bff917 	ldw	r2,-28(fp)
   2b8a8:	10800017 	ldw	r2,0(r2)
   2b8ac:	1007883a 	mov	r3,r2
   2b8b0:	e0bffd43 	ldbu	r2,-11(fp)
   2b8b4:	1809883a 	mov	r4,r3
   2b8b8:	100b883a 	mov	r5,r2
   2b8bc:	00281e40 	call	281e4 <alt_tse_mac_set_duplex>
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
   2b8c0:	e47ffa47 	ldb	r17,-23(fp)
   2b8c4:	e43ffa07 	ldb	r16,-24(fp)
   2b8c8:	e13ff717 	ldw	r4,-36(fp)
   2b8cc:	01400044 	movi	r5,1
   2b8d0:	000d883a 	mov	r6,zero
   2b8d4:	01c00404 	movi	r7,16
   2b8d8:	0028eb00 	call	28eb0 <alt_tse_phy_rd_mdio_reg>
   2b8dc:	010000f4 	movhi	r4,3
   2b8e0:	210bf304 	addi	r4,r4,12236
   2b8e4:	880b883a 	mov	r5,r17
   2b8e8:	800d883a 	mov	r6,r16
   2b8ec:	100f883a 	mov	r7,r2
   2b8f0:	00193f00 	call	193f0 <printf>
   2b8f4:	00000106 	br	2b8fc <alt_tse_phy_set_common_speed+0x410>

        pphy = pmac_info->pphy_info;
        
        /* if no PHY connected */
        if(!pphy) {
            continue;
   2b8f8:	0001883a 	nop
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
        return TSE_PHY_SPEED_NO_COMMON;
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
   2b8fc:	e0bff517 	ldw	r2,-44(fp)
   2b900:	10800044 	addi	r2,r2,1
   2b904:	e0bff515 	stw	r2,-44(fp)
   2b908:	e0bffe17 	ldw	r2,-8(fp)
   2b90c:	10800003 	ldbu	r2,0(r2)
   2b910:	10803fcc 	andi	r2,r2,255
   2b914:	e0fff517 	ldw	r3,-44(fp)
   2b918:	18bf1f16 	blt	r3,r2,2b598 <alt_tse_phy_set_common_speed+0xac>
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
    }
    tse_dprintf(5, "INFO    : MAC Group[%d] - All PHYs set to common speed : %d Mbps\n", mac_group_index, (common_speed == TSE_PHY_SPEED_1000) ? 1000 : ((common_speed == TSE_PHY_SPEED_100) ? 100 : 10));
   2b91c:	e0fffa47 	ldb	r3,-23(fp)
   2b920:	e0bfff17 	ldw	r2,-4(fp)
   2b924:	108000a0 	cmpeqi	r2,r2,2
   2b928:	1000071e 	bne	r2,zero,2b948 <alt_tse_phy_set_common_speed+0x45c>
   2b92c:	e0bfff17 	ldw	r2,-4(fp)
   2b930:	10800058 	cmpnei	r2,r2,1
   2b934:	1000021e 	bne	r2,zero,2b940 <alt_tse_phy_set_common_speed+0x454>
   2b938:	00801904 	movi	r2,100
   2b93c:	00000106 	br	2b944 <alt_tse_phy_set_common_speed+0x458>
   2b940:	00800284 	movi	r2,10
   2b944:	00000106 	br	2b94c <alt_tse_phy_set_common_speed+0x460>
   2b948:	0080fa04 	movi	r2,1000
   2b94c:	010000f4 	movhi	r4,3
   2b950:	210bff04 	addi	r4,r4,12284
   2b954:	180b883a 	mov	r5,r3
   2b958:	100d883a 	mov	r6,r2
   2b95c:	00193f00 	call	193f0 <printf>

    /* Set MAC speed register */
    alt_tse_mac_set_speed(pmac_group_base, common_speed);
   2b960:	e0bfff17 	ldw	r2,-4(fp)
   2b964:	10803fcc 	andi	r2,r2,255
   2b968:	e13ffb17 	ldw	r4,-20(fp)
   2b96c:	100b883a 	mov	r5,r2
   2b970:	00281040 	call	28104 <alt_tse_mac_set_speed>
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
   2b974:	e0bffb17 	ldw	r2,-20(fp)
   2b978:	10801004 	addi	r2,r2,64
   2b97c:	e0fffc17 	ldw	r3,-16(fp)
   2b980:	10c00035 	stwio	r3,0(r2)
        
    return common_speed;
   2b984:	e0bfff17 	ldw	r2,-4(fp)
}
   2b988:	e037883a 	mov	sp,fp
   2b98c:	dfc00317 	ldw	ra,12(sp)
   2b990:	df000217 	ldw	fp,8(sp)
   2b994:	dc400117 	ldw	r17,4(sp)
   2b998:	dc000017 	ldw	r16,0(sp)
   2b99c:	dec00404 	addi	sp,sp,16
   2b9a0:	f800283a 	ret

0002b9a4 <marvell_phy_cfg>:

/* @Function Description: Additional configuration for Marvell PHY
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address of MAC group
 */
alt_32 marvell_phy_cfg(np_tse_mac *pmac) {
   2b9a4:	defffc04 	addi	sp,sp,-16
   2b9a8:	dfc00315 	stw	ra,12(sp)
   2b9ac:	df000215 	stw	fp,8(sp)
   2b9b0:	df000204 	addi	fp,sp,8
   2b9b4:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat;
    
    /* If there is no link yet, we enable auto crossover and reset the PHY */
    if((IORD(&pmac->mdio1.STATUS, 0) & PCS_ST_an_done) == 0) {
   2b9b8:	e0bfff17 	ldw	r2,-4(fp)
   2b9bc:	1080a104 	addi	r2,r2,644
   2b9c0:	10800037 	ldwio	r2,0(r2)
   2b9c4:	1080080c 	andi	r2,r2,32
   2b9c8:	1000161e 	bne	r2,zero,2ba24 <marvell_phy_cfg+0x80>
        tse_dprintf(5, "MARVELL : Enabling auto crossover\n");
   2b9cc:	010000f4 	movhi	r4,3
   2b9d0:	210c1004 	addi	r4,r4,12352
   2b9d4:	001965c0 	call	1965c <puts>
        IOWR(&pmac->mdio1.CONTROL, 16, 0x0078);
   2b9d8:	e0bfff17 	ldw	r2,-4(fp)
   2b9dc:	1080a004 	addi	r2,r2,640
   2b9e0:	10801004 	addi	r2,r2,64
   2b9e4:	00c01e04 	movi	r3,120
   2b9e8:	10c00035 	stwio	r3,0(r2)
        tse_dprintf(5, "MARVELL : PHY reset\n");
   2b9ec:	010000f4 	movhi	r4,3
   2b9f0:	210c1904 	addi	r4,r4,12388
   2b9f4:	001965c0 	call	1965c <puts>
        dat = IORD(&pmac->mdio1.CONTROL, 0); 
   2b9f8:	e0bfff17 	ldw	r2,-4(fp)
   2b9fc:	1080a004 	addi	r2,r2,640
   2ba00:	10800037 	ldwio	r2,0(r2)
   2ba04:	e0bffe0d 	sth	r2,-8(fp)
        IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);        
   2ba08:	e0bfff17 	ldw	r2,-4(fp)
   2ba0c:	1080a004 	addi	r2,r2,640
   2ba10:	e13ffe0b 	ldhu	r4,-8(fp)
   2ba14:	00e00004 	movi	r3,-32768
   2ba18:	20c6b03a 	or	r3,r4,r3
   2ba1c:	18ffffcc 	andi	r3,r3,65535
   2ba20:	10c00035 	stwio	r3,0(r2)
    }
    
    return 0;
   2ba24:	0005883a 	mov	r2,zero
}
   2ba28:	e037883a 	mov	sp,fp
   2ba2c:	dfc00117 	ldw	ra,4(sp)
   2ba30:	df000017 	ldw	fp,0(sp)
   2ba34:	dec00204 	addi	sp,sp,8
   2ba38:	f800283a 	ret

0002ba3c <marvell_cfg_gmii>:

/* @Function Description: Change operating mode of Marvell PHY to GMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_gmii(np_tse_mac *pmac) {
   2ba3c:	defffc04 	addi	sp,sp,-16
   2ba40:	dfc00315 	stw	ra,12(sp)
   2ba44:	df000215 	stw	fp,8(sp)
   2ba48:	df000204 	addi	fp,sp,8
   2ba4c:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
   2ba50:	e0bfff17 	ldw	r2,-4(fp)
   2ba54:	1080bb04 	addi	r2,r2,748
   2ba58:	10800037 	ldwio	r2,0(r2)
   2ba5c:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
   2ba60:	e0fffe0b 	ldhu	r3,-8(fp)
   2ba64:	00bffc04 	movi	r2,-16
   2ba68:	1884703a 	and	r2,r3,r2
   2ba6c:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to GMII to copper mode\n");
   2ba70:	010000f4 	movhi	r4,3
   2ba74:	210c1e04 	addi	r4,r4,12408
   2ba78:	001965c0 	call	1965c <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xf);
   2ba7c:	e0bfff17 	ldw	r2,-4(fp)
   2ba80:	1080bb04 	addi	r2,r2,748
   2ba84:	e0fffe0b 	ldhu	r3,-8(fp)
   2ba88:	18c003d4 	ori	r3,r3,15
   2ba8c:	18ffffcc 	andi	r3,r3,65535
   2ba90:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
   2ba94:	010000f4 	movhi	r4,3
   2ba98:	210c2a04 	addi	r4,r4,12456
   2ba9c:	001965c0 	call	1965c <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
   2baa0:	e0bfff17 	ldw	r2,-4(fp)
   2baa4:	1080b404 	addi	r2,r2,720
   2baa8:	10800037 	ldwio	r2,0(r2)
   2baac:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
   2bab0:	e0fffe0b 	ldhu	r3,-8(fp)
   2bab4:	00bfdf44 	movi	r2,-131
   2bab8:	1884703a 	and	r2,r3,r2
   2babc:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
   2bac0:	e0bfff17 	ldw	r2,-4(fp)
   2bac4:	1080b404 	addi	r2,r2,720
   2bac8:	e0fffe0b 	ldhu	r3,-8(fp)
   2bacc:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
   2bad0:	010000f4 	movhi	r4,3
   2bad4:	210c1904 	addi	r4,r4,12388
   2bad8:	001965c0 	call	1965c <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
   2badc:	e0bfff17 	ldw	r2,-4(fp)
   2bae0:	1080a004 	addi	r2,r2,640
   2bae4:	10800037 	ldwio	r2,0(r2)
   2bae8:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
   2baec:	e0bfff17 	ldw	r2,-4(fp)
   2baf0:	1080a004 	addi	r2,r2,640
   2baf4:	e13ffe0b 	ldhu	r4,-8(fp)
   2baf8:	00e00004 	movi	r3,-32768
   2bafc:	20c6b03a 	or	r3,r4,r3
   2bb00:	18ffffcc 	andi	r3,r3,65535
   2bb04:	10c00035 	stwio	r3,0(r2)
    
    return 1;
   2bb08:	00800044 	movi	r2,1
}
   2bb0c:	e037883a 	mov	sp,fp
   2bb10:	dfc00117 	ldw	ra,4(sp)
   2bb14:	df000017 	ldw	fp,0(sp)
   2bb18:	dec00204 	addi	sp,sp,8
   2bb1c:	f800283a 	ret

0002bb20 <marvell_cfg_sgmii>:

/* @Function Description: Change operating mode of Marvell PHY to SGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_sgmii(np_tse_mac *pmac) {
   2bb20:	defffc04 	addi	sp,sp,-16
   2bb24:	dfc00315 	stw	ra,12(sp)
   2bb28:	df000215 	stw	fp,8(sp)
   2bb2c:	df000204 	addi	fp,sp,8
   2bb30:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
   2bb34:	e0bfff17 	ldw	r2,-4(fp)
   2bb38:	1080bb04 	addi	r2,r2,748
   2bb3c:	10800037 	ldwio	r2,0(r2)
   2bb40:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
   2bb44:	e0fffe0b 	ldhu	r3,-8(fp)
   2bb48:	00bffc04 	movi	r2,-16
   2bb4c:	1884703a 	and	r2,r3,r2
   2bb50:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to SGMII without clock with SGMII Auto-Neg to copper mode\n");
   2bb54:	010000f4 	movhi	r4,3
   2bb58:	210c3404 	addi	r4,r4,12496
   2bb5c:	001965c0 	call	1965c <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0x4);
   2bb60:	e0bfff17 	ldw	r2,-4(fp)
   2bb64:	1080bb04 	addi	r2,r2,748
   2bb68:	e0fffe0b 	ldhu	r3,-8(fp)
   2bb6c:	18c00114 	ori	r3,r3,4
   2bb70:	18ffffcc 	andi	r3,r3,65535
   2bb74:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
   2bb78:	010000f4 	movhi	r4,3
   2bb7c:	210c2a04 	addi	r4,r4,12456
   2bb80:	001965c0 	call	1965c <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
   2bb84:	e0bfff17 	ldw	r2,-4(fp)
   2bb88:	1080b404 	addi	r2,r2,720
   2bb8c:	10800037 	ldwio	r2,0(r2)
   2bb90:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
   2bb94:	e0fffe0b 	ldhu	r3,-8(fp)
   2bb98:	00bfdf44 	movi	r2,-131
   2bb9c:	1884703a 	and	r2,r3,r2
   2bba0:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
   2bba4:	e0bfff17 	ldw	r2,-4(fp)
   2bba8:	1080b404 	addi	r2,r2,720
   2bbac:	e0fffe0b 	ldhu	r3,-8(fp)
   2bbb0:	10c00035 	stwio	r3,0(r2)

    tse_dprintf(5, "MARVELL : PHY reset\n");
   2bbb4:	010000f4 	movhi	r4,3
   2bbb8:	210c1904 	addi	r4,r4,12388
   2bbbc:	001965c0 	call	1965c <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
   2bbc0:	e0bfff17 	ldw	r2,-4(fp)
   2bbc4:	1080a004 	addi	r2,r2,640
   2bbc8:	10800037 	ldwio	r2,0(r2)
   2bbcc:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
   2bbd0:	e0bfff17 	ldw	r2,-4(fp)
   2bbd4:	1080a004 	addi	r2,r2,640
   2bbd8:	e13ffe0b 	ldhu	r4,-8(fp)
   2bbdc:	00e00004 	movi	r3,-32768
   2bbe0:	20c6b03a 	or	r3,r4,r3
   2bbe4:	18ffffcc 	andi	r3,r3,65535
   2bbe8:	10c00035 	stwio	r3,0(r2)
    
    return 1;
   2bbec:	00800044 	movi	r2,1
}
   2bbf0:	e037883a 	mov	sp,fp
   2bbf4:	dfc00117 	ldw	ra,4(sp)
   2bbf8:	df000017 	ldw	fp,0(sp)
   2bbfc:	dec00204 	addi	sp,sp,8
   2bc00:	f800283a 	ret

0002bc04 <marvell_cfg_rgmii>:

/* @Function Description: Change operating mode of Marvell PHY to RGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_rgmii(np_tse_mac *pmac) {
   2bc04:	defffc04 	addi	sp,sp,-16
   2bc08:	dfc00315 	stw	ra,12(sp)
   2bc0c:	df000215 	stw	fp,8(sp)
   2bc10:	df000204 	addi	fp,sp,8
   2bc14:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
   2bc18:	e0bfff17 	ldw	r2,-4(fp)
   2bc1c:	1080bb04 	addi	r2,r2,748
   2bc20:	10800037 	ldwio	r2,0(r2)
   2bc24:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
   2bc28:	e0fffe0b 	ldhu	r3,-8(fp)
   2bc2c:	00bffc04 	movi	r2,-16
   2bc30:	1884703a 	and	r2,r3,r2
   2bc34:	e0bffe0d 	sth	r2,-8(fp)
    
    tse_dprintf(5, "MARVELL : Mode changed to RGMII/Modified MII to Copper mode\n");
   2bc38:	010000f4 	movhi	r4,3
   2bc3c:	210c4904 	addi	r4,r4,12580
   2bc40:	001965c0 	call	1965c <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xb);
   2bc44:	e0bfff17 	ldw	r2,-4(fp)
   2bc48:	1080bb04 	addi	r2,r2,748
   2bc4c:	e0fffe0b 	ldhu	r3,-8(fp)
   2bc50:	18c002d4 	ori	r3,r3,11
   2bc54:	18ffffcc 	andi	r3,r3,65535
   2bc58:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Enable RGMII Timing Control\n");
   2bc5c:	010000f4 	movhi	r4,3
   2bc60:	210c5804 	addi	r4,r4,12640
   2bc64:	001965c0 	call	1965c <puts>
    dat = IORD(&pmac->mdio1.reg14, 0);
   2bc68:	e0bfff17 	ldw	r2,-4(fp)
   2bc6c:	1080b404 	addi	r2,r2,720
   2bc70:	10800037 	ldwio	r2,0(r2)
   2bc74:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
   2bc78:	e0fffe0b 	ldhu	r3,-8(fp)
   2bc7c:	00bfdf44 	movi	r2,-131
   2bc80:	1884703a 	and	r2,r3,r2
   2bc84:	e0bffe0d 	sth	r2,-8(fp)
    dat |= 0x82;
   2bc88:	e0bffe0b 	ldhu	r2,-8(fp)
   2bc8c:	10802094 	ori	r2,r2,130
   2bc90:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);    
   2bc94:	e0bfff17 	ldw	r2,-4(fp)
   2bc98:	1080b404 	addi	r2,r2,720
   2bc9c:	e0fffe0b 	ldhu	r3,-8(fp)
   2bca0:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
   2bca4:	010000f4 	movhi	r4,3
   2bca8:	210c1904 	addi	r4,r4,12388
   2bcac:	001965c0 	call	1965c <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
   2bcb0:	e0bfff17 	ldw	r2,-4(fp)
   2bcb4:	1080a004 	addi	r2,r2,640
   2bcb8:	10800037 	ldwio	r2,0(r2)
   2bcbc:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
   2bcc0:	e0bfff17 	ldw	r2,-4(fp)
   2bcc4:	1080a004 	addi	r2,r2,640
   2bcc8:	e13ffe0b 	ldhu	r4,-8(fp)
   2bccc:	00e00004 	movi	r3,-32768
   2bcd0:	20c6b03a 	or	r3,r4,r3
   2bcd4:	18ffffcc 	andi	r3,r3,65535
   2bcd8:	10c00035 	stwio	r3,0(r2)
    
    return 1;
   2bcdc:	00800044 	movi	r2,1
    
}
   2bce0:	e037883a 	mov	sp,fp
   2bce4:	dfc00117 	ldw	ra,4(sp)
   2bce8:	df000017 	ldw	fp,0(sp)
   2bcec:	dec00204 	addi	sp,sp,8
   2bcf0:	f800283a 	ret

0002bcf4 <DP83848C_link_status_read>:

/* @Function Description: Read link status from PHY specific status register of DP83848C
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_u32 DP83848C_link_status_read(np_tse_mac *pmac) {
   2bcf4:	defffc04 	addi	sp,sp,-16
   2bcf8:	df000315 	stw	fp,12(sp)
   2bcfc:	df000304 	addi	fp,sp,12
   2bd00:	e13fff15 	stw	r4,-4(fp)
	alt_u32 link_status = 0;
   2bd04:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 reg_status = IORD(&pmac->mdio1.reg10, 0);
   2bd08:	e0bfff17 	ldw	r2,-4(fp)
   2bd0c:	1080b004 	addi	r2,r2,704
   2bd10:	10800037 	ldwio	r2,0(r2)
   2bd14:	e0bffe15 	stw	r2,-8(fp)
	
	/* If speed == 10 Mbps */
	if(reg_status & 0x2) {
   2bd18:	e0bffe17 	ldw	r2,-8(fp)
   2bd1c:	1080008c 	andi	r2,r2,2
   2bd20:	10000426 	beq	r2,zero,2bd34 <DP83848C_link_status_read+0x40>
		link_status |= 0x8;
   2bd24:	e0bffd17 	ldw	r2,-12(fp)
   2bd28:	10800214 	ori	r2,r2,8
   2bd2c:	e0bffd15 	stw	r2,-12(fp)
   2bd30:	00000306 	br	2bd40 <DP83848C_link_status_read+0x4c>
	}
	/* Else speed = 100 Mbps */
	else {
		link_status |= 0x4;
   2bd34:	e0bffd17 	ldw	r2,-12(fp)
   2bd38:	10800114 	ori	r2,r2,4
   2bd3c:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* If duplex == Full */
	if(reg_status & 0x4) {
   2bd40:	e0bffe17 	ldw	r2,-8(fp)
   2bd44:	1080010c 	andi	r2,r2,4
   2bd48:	10000326 	beq	r2,zero,2bd58 <DP83848C_link_status_read+0x64>
		link_status |= 0x1;
   2bd4c:	e0bffd17 	ldw	r2,-12(fp)
   2bd50:	10800054 	ori	r2,r2,1
   2bd54:	e0bffd15 	stw	r2,-12(fp)
	}
	
	return link_status;
   2bd58:	e0bffd17 	ldw	r2,-12(fp)
}
   2bd5c:	e037883a 	mov	sp,fp
   2bd60:	df000017 	ldw	fp,0(sp)
   2bd64:	dec00104 	addi	sp,sp,4
   2bd68:	f800283a 	ret

0002bd6c <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
   2bd6c:	defffa04 	addi	sp,sp,-24
   2bd70:	dfc00515 	stw	ra,20(sp)
   2bd74:	df000415 	stw	fp,16(sp)
   2bd78:	df000404 	addi	fp,sp,16
   2bd7c:	e13ffd15 	stw	r4,-12(fp)
   2bd80:	e17ffe15 	stw	r5,-8(fp)
   2bd84:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
   2bd88:	e0bffd17 	ldw	r2,-12(fp)
   2bd8c:	10800017 	ldw	r2,0(r2)
   2bd90:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
   2bd94:	e0bffc17 	ldw	r2,-16(fp)
   2bd98:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
   2bd9c:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 

    return altera_avalon_uart_read(&dev->state, buffer, space,
   2bda0:	10800217 	ldw	r2,8(r2)
   2bda4:	1809883a 	mov	r4,r3
   2bda8:	e17ffe17 	ldw	r5,-8(fp)
   2bdac:	e1bfff17 	ldw	r6,-4(fp)
   2bdb0:	100f883a 	mov	r7,r2
   2bdb4:	002c2740 	call	2c274 <altera_avalon_uart_read>
      fd->fd_flags);
}
   2bdb8:	e037883a 	mov	sp,fp
   2bdbc:	dfc00117 	ldw	ra,4(sp)
   2bdc0:	df000017 	ldw	fp,0(sp)
   2bdc4:	dec00204 	addi	sp,sp,8
   2bdc8:	f800283a 	ret

0002bdcc <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
   2bdcc:	defffa04 	addi	sp,sp,-24
   2bdd0:	dfc00515 	stw	ra,20(sp)
   2bdd4:	df000415 	stw	fp,16(sp)
   2bdd8:	df000404 	addi	fp,sp,16
   2bddc:	e13ffd15 	stw	r4,-12(fp)
   2bde0:	e17ffe15 	stw	r5,-8(fp)
   2bde4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
   2bde8:	e0bffd17 	ldw	r2,-12(fp)
   2bdec:	10800017 	ldw	r2,0(r2)
   2bdf0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
   2bdf4:	e0bffc17 	ldw	r2,-16(fp)
   2bdf8:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
   2bdfc:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 

    return altera_avalon_uart_write(&dev->state, buffer, space,
   2be00:	10800217 	ldw	r2,8(r2)
   2be04:	1809883a 	mov	r4,r3
   2be08:	e17ffe17 	ldw	r5,-8(fp)
   2be0c:	e1bfff17 	ldw	r6,-4(fp)
   2be10:	100f883a 	mov	r7,r2
   2be14:	002c5200 	call	2c520 <altera_avalon_uart_write>
      fd->fd_flags);
}
   2be18:	e037883a 	mov	sp,fp
   2be1c:	dfc00117 	ldw	ra,4(sp)
   2be20:	df000017 	ldw	fp,0(sp)
   2be24:	dec00204 	addi	sp,sp,8
   2be28:	f800283a 	ret

0002be2c <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
   2be2c:	defffc04 	addi	sp,sp,-16
   2be30:	dfc00315 	stw	ra,12(sp)
   2be34:	df000215 	stw	fp,8(sp)
   2be38:	df000204 	addi	fp,sp,8
   2be3c:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
   2be40:	e0bfff17 	ldw	r2,-4(fp)
   2be44:	10800017 	ldw	r2,0(r2)
   2be48:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
   2be4c:	e0bffe17 	ldw	r2,-8(fp)
   2be50:	10c00a04 	addi	r3,r2,40
   2be54:	e0bfff17 	ldw	r2,-4(fp)
   2be58:	10800217 	ldw	r2,8(r2)
   2be5c:	1809883a 	mov	r4,r3
   2be60:	100b883a 	mov	r5,r2
   2be64:	002c1d00 	call	2c1d0 <altera_avalon_uart_close>
}
   2be68:	e037883a 	mov	sp,fp
   2be6c:	dfc00117 	ldw	ra,4(sp)
   2be70:	df000017 	ldw	fp,0(sp)
   2be74:	dec00204 	addi	sp,sp,8
   2be78:	f800283a 	ret

0002be7c <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
   2be7c:	defff804 	addi	sp,sp,-32
   2be80:	dfc00715 	stw	ra,28(sp)
   2be84:	df000615 	stw	fp,24(sp)
   2be88:	df000604 	addi	fp,sp,24
   2be8c:	e13ffd15 	stw	r4,-12(fp)
   2be90:	e17ffe15 	stw	r5,-8(fp)
   2be94:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
   2be98:	e0bffd17 	ldw	r2,-12(fp)
   2be9c:	10800017 	ldw	r2,0(r2)
   2bea0:	e0bffb15 	stw	r2,-20(fp)
 * HAL.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_no_error (void)
{
  return 0;
   2bea4:	0005883a 	mov	r2,zero
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
   2bea8:	1000041e 	bne	r2,zero,2bebc <altera_avalon_uart_init+0x40>
   2beac:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
   2beb0:	1000021e 	bne	r2,zero,2bebc <altera_avalon_uart_init+0x40>
   2beb4:	0005883a 	mov	r2,zero
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
   2beb8:	10000226 	beq	r2,zero,2bec4 <altera_avalon_uart_init+0x48>
   2bebc:	00800044 	movi	r2,1
   2bec0:	00000106 	br	2bec8 <altera_avalon_uart_init+0x4c>
   2bec4:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
   2bec8:	e0bffc15 	stw	r2,-16(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
   2becc:	e0bffc17 	ldw	r2,-16(fp)
   2bed0:	10000f1e 	bne	r2,zero,2bf10 <altera_avalon_uart_init+0x94>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
   2bed4:	e0bffd17 	ldw	r2,-12(fp)
   2bed8:	00c32004 	movi	r3,3200
   2bedc:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
   2bee0:	e0bffb17 	ldw	r2,-20(fp)
   2bee4:	10800304 	addi	r2,r2,12
   2bee8:	e0fffd17 	ldw	r3,-12(fp)
   2beec:	18c00117 	ldw	r3,4(r3)
   2bef0:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
   2bef4:	d8000015 	stw	zero,0(sp)
   2bef8:	e13ffe17 	ldw	r4,-8(fp)
   2befc:	e17fff17 	ldw	r5,-4(fp)
   2bf00:	018000f4 	movhi	r6,3
   2bf04:	31afc904 	addi	r6,r6,-16604
   2bf08:	e1fffd17 	ldw	r7,-12(fp)
   2bf0c:	002ca740 	call	2ca74 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
   2bf10:	e037883a 	mov	sp,fp
   2bf14:	dfc00117 	ldw	ra,4(sp)
   2bf18:	df000017 	ldw	fp,0(sp)
   2bf1c:	dec00204 	addi	sp,sp,8
   2bf20:	f800283a 	ret

0002bf24 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
   2bf24:	defffa04 	addi	sp,sp,-24
   2bf28:	dfc00515 	stw	ra,20(sp)
   2bf2c:	df000415 	stw	fp,16(sp)
   2bf30:	df000404 	addi	fp,sp,16
   2bf34:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
   2bf38:	e0bfff17 	ldw	r2,-4(fp)
   2bf3c:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
   2bf40:	e0bffc17 	ldw	r2,-16(fp)
   2bf44:	10800017 	ldw	r2,0(r2)
   2bf48:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
   2bf4c:	e0bffd17 	ldw	r2,-12(fp)
   2bf50:	10800204 	addi	r2,r2,8
   2bf54:	10800037 	ldwio	r2,0(r2)
   2bf58:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
   2bf5c:	e0bffd17 	ldw	r2,-12(fp)
   2bf60:	10800204 	addi	r2,r2,8
   2bf64:	0007883a 	mov	r3,zero
   2bf68:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
   2bf6c:	e0bffd17 	ldw	r2,-12(fp)
   2bf70:	10800204 	addi	r2,r2,8
   2bf74:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
   2bf78:	e0bffe17 	ldw	r2,-8(fp)
   2bf7c:	1080200c 	andi	r2,r2,128
   2bf80:	10000326 	beq	r2,zero,2bf90 <altera_avalon_uart_irq+0x6c>
  {
    altera_avalon_uart_rxirq(sp, status);
   2bf84:	e13ffc17 	ldw	r4,-16(fp)
   2bf88:	e17ffe17 	ldw	r5,-8(fp)
   2bf8c:	002bfbc0 	call	2bfbc <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
   2bf90:	e0bffe17 	ldw	r2,-8(fp)
   2bf94:	1081100c 	andi	r2,r2,1088
   2bf98:	10000326 	beq	r2,zero,2bfa8 <altera_avalon_uart_irq+0x84>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
   2bf9c:	e13ffc17 	ldw	r4,-16(fp)
   2bfa0:	e17ffe17 	ldw	r5,-8(fp)
   2bfa4:	002c0940 	call	2c094 <altera_avalon_uart_txirq>
  }
  

}
   2bfa8:	e037883a 	mov	sp,fp
   2bfac:	dfc00117 	ldw	ra,4(sp)
   2bfb0:	df000017 	ldw	fp,0(sp)
   2bfb4:	dec00204 	addi	sp,sp,8
   2bfb8:	f800283a 	ret

0002bfbc <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
   2bfbc:	defffc04 	addi	sp,sp,-16
   2bfc0:	df000315 	stw	fp,12(sp)
   2bfc4:	df000304 	addi	fp,sp,12
   2bfc8:	e13ffe15 	stw	r4,-8(fp)
   2bfcc:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
   2bfd0:	e0bfff17 	ldw	r2,-4(fp)
   2bfd4:	108000cc 	andi	r2,r2,3
   2bfd8:	1000291e 	bne	r2,zero,2c080 <altera_avalon_uart_rxirq+0xc4>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
   2bfdc:	e0bffe17 	ldw	r2,-8(fp)
   2bfe0:	10800317 	ldw	r2,12(r2)
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
   2bfe4:	e0bffe17 	ldw	r2,-8(fp)
   2bfe8:	10800317 	ldw	r2,12(r2)
   2bfec:	10800044 	addi	r2,r2,1
   2bff0:	10800fcc 	andi	r2,r2,63
   2bff4:	e0bffd15 	stw	r2,-12(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
   2bff8:	e0bffe17 	ldw	r2,-8(fp)
   2bffc:	10800317 	ldw	r2,12(r2)
   2c000:	e0fffe17 	ldw	r3,-8(fp)
   2c004:	18c00017 	ldw	r3,0(r3)
   2c008:	18c00037 	ldwio	r3,0(r3)
   2c00c:	e13ffe17 	ldw	r4,-8(fp)
   2c010:	2085883a 	add	r2,r4,r2
   2c014:	10800704 	addi	r2,r2,28
   2c018:	10c00005 	stb	r3,0(r2)

  sp->rx_end = next;
   2c01c:	e0bffe17 	ldw	r2,-8(fp)
   2c020:	e0fffd17 	ldw	r3,-12(fp)
   2c024:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
   2c028:	e0bffe17 	ldw	r2,-8(fp)
   2c02c:	10800317 	ldw	r2,12(r2)
   2c030:	10800044 	addi	r2,r2,1
   2c034:	10800fcc 	andi	r2,r2,63
   2c038:	e0bffd15 	stw	r2,-12(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
   2c03c:	e0bffe17 	ldw	r2,-8(fp)
   2c040:	10c00217 	ldw	r3,8(r2)
   2c044:	e0bffd17 	ldw	r2,-12(fp)
   2c048:	18800e1e 	bne	r3,r2,2c084 <altera_avalon_uart_rxirq+0xc8>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
   2c04c:	e0bffe17 	ldw	r2,-8(fp)
   2c050:	10c00117 	ldw	r3,4(r2)
   2c054:	00bfdfc4 	movi	r2,-129
   2c058:	1886703a 	and	r3,r3,r2
   2c05c:	e0bffe17 	ldw	r2,-8(fp)
   2c060:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
   2c064:	e0bffe17 	ldw	r2,-8(fp)
   2c068:	10800017 	ldw	r2,0(r2)
   2c06c:	10800304 	addi	r2,r2,12
   2c070:	e0fffe17 	ldw	r3,-8(fp)
   2c074:	18c00117 	ldw	r3,4(r3)
   2c078:	10c00035 	stwio	r3,0(r2)
   2c07c:	00000106 	br	2c084 <altera_avalon_uart_rxirq+0xc8>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
   2c080:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
   2c084:	e037883a 	mov	sp,fp
   2c088:	df000017 	ldw	fp,0(sp)
   2c08c:	dec00104 	addi	sp,sp,4
   2c090:	f800283a 	ret

0002c094 <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
   2c094:	defffd04 	addi	sp,sp,-12
   2c098:	df000215 	stw	fp,8(sp)
   2c09c:	df000204 	addi	fp,sp,8
   2c0a0:	e13ffe15 	stw	r4,-8(fp)
   2c0a4:	e17fff15 	stw	r5,-4(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
   2c0a8:	e0bffe17 	ldw	r2,-8(fp)
   2c0ac:	10c00417 	ldw	r3,16(r2)
   2c0b0:	e0bffe17 	ldw	r2,-8(fp)
   2c0b4:	10800517 	ldw	r2,20(r2)
   2c0b8:	18803026 	beq	r3,r2,2c17c <altera_avalon_uart_txirq+0xe8>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
   2c0bc:	e0bffe17 	ldw	r2,-8(fp)
   2c0c0:	10800617 	ldw	r2,24(r2)
   2c0c4:	1080008c 	andi	r2,r2,2
   2c0c8:	10000326 	beq	r2,zero,2c0d8 <altera_avalon_uart_txirq+0x44>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
   2c0cc:	e0bfff17 	ldw	r2,-4(fp)
   2c0d0:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
   2c0d4:	10001b26 	beq	r2,zero,2c144 <altera_avalon_uart_txirq+0xb0>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
   2c0d8:	e0bffe17 	ldw	r2,-8(fp)
   2c0dc:	10800417 	ldw	r2,16(r2)
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
   2c0e0:	e0bffe17 	ldw	r2,-8(fp)
   2c0e4:	10800017 	ldw	r2,0(r2)
   2c0e8:	10800104 	addi	r2,r2,4
   2c0ec:	e0fffe17 	ldw	r3,-8(fp)
   2c0f0:	18c00417 	ldw	r3,16(r3)
   2c0f4:	e13ffe17 	ldw	r4,-8(fp)
   2c0f8:	20c7883a 	add	r3,r4,r3
   2c0fc:	18c01704 	addi	r3,r3,92
   2c100:	18c00003 	ldbu	r3,0(r3)
   2c104:	18c03fcc 	andi	r3,r3,255
   2c108:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
   2c10c:	e0bffe17 	ldw	r2,-8(fp)
   2c110:	10800417 	ldw	r2,16(r2)
   2c114:	10800044 	addi	r2,r2,1
   2c118:	e0fffe17 	ldw	r3,-8(fp)
   2c11c:	18800415 	stw	r2,16(r3)
   2c120:	10c00fcc 	andi	r3,r2,63
   2c124:	e0bffe17 	ldw	r2,-8(fp)
   2c128:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
   2c12c:	e0bffe17 	ldw	r2,-8(fp)
   2c130:	10800117 	ldw	r2,4(r2)
   2c134:	10c01014 	ori	r3,r2,64
   2c138:	e0bffe17 	ldw	r2,-8(fp)
   2c13c:	10c00115 	stw	r3,4(r2)
   2c140:	00000e06 	br	2c17c <altera_avalon_uart_txirq+0xe8>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
   2c144:	e0bffe17 	ldw	r2,-8(fp)
   2c148:	10800017 	ldw	r2,0(r2)
   2c14c:	10800204 	addi	r2,r2,8
   2c150:	10800037 	ldwio	r2,0(r2)
   2c154:	e0bfff15 	stw	r2,-4(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
   2c158:	e0bfff17 	ldw	r2,-4(fp)
   2c15c:	1082000c 	andi	r2,r2,2048
   2c160:	1000061e 	bne	r2,zero,2c17c <altera_avalon_uart_txirq+0xe8>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
   2c164:	e0bffe17 	ldw	r2,-8(fp)
   2c168:	10c00117 	ldw	r3,4(r2)
   2c16c:	00bfefc4 	movi	r2,-65
   2c170:	1886703a 	and	r3,r3,r2
   2c174:	e0bffe17 	ldw	r2,-8(fp)
   2c178:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
   2c17c:	e0bffe17 	ldw	r2,-8(fp)
   2c180:	10c00417 	ldw	r3,16(r2)
   2c184:	e0bffe17 	ldw	r2,-8(fp)
   2c188:	10800517 	ldw	r2,20(r2)
   2c18c:	1880061e 	bne	r3,r2,2c1a8 <altera_avalon_uart_txirq+0x114>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
   2c190:	e0bffe17 	ldw	r2,-8(fp)
   2c194:	10c00117 	ldw	r3,4(r2)
   2c198:	00beefc4 	movi	r2,-1089
   2c19c:	1886703a 	and	r3,r3,r2
   2c1a0:	e0bffe17 	ldw	r2,-8(fp)
   2c1a4:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
   2c1a8:	e0bffe17 	ldw	r2,-8(fp)
   2c1ac:	10800017 	ldw	r2,0(r2)
   2c1b0:	10800304 	addi	r2,r2,12
   2c1b4:	e0fffe17 	ldw	r3,-8(fp)
   2c1b8:	18c00117 	ldw	r3,4(r3)
   2c1bc:	10c00035 	stwio	r3,0(r2)
}
   2c1c0:	e037883a 	mov	sp,fp
   2c1c4:	df000017 	ldw	fp,0(sp)
   2c1c8:	dec00104 	addi	sp,sp,4
   2c1cc:	f800283a 	ret

0002c1d0 <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
   2c1d0:	defffd04 	addi	sp,sp,-12
   2c1d4:	df000215 	stw	fp,8(sp)
   2c1d8:	df000204 	addi	fp,sp,8
   2c1dc:	e13ffe15 	stw	r4,-8(fp)
   2c1e0:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
   2c1e4:	00000506 	br	2c1fc <altera_avalon_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
   2c1e8:	e0bfff17 	ldw	r2,-4(fp)
   2c1ec:	1090000c 	andi	r2,r2,16384
   2c1f0:	10000226 	beq	r2,zero,2c1fc <altera_avalon_uart_close+0x2c>
      return -EWOULDBLOCK; 
   2c1f4:	00bffd44 	movi	r2,-11
   2c1f8:	00000606 	br	2c214 <altera_avalon_uart_close+0x44>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
   2c1fc:	e0bffe17 	ldw	r2,-8(fp)
   2c200:	10c00417 	ldw	r3,16(r2)
   2c204:	e0bffe17 	ldw	r2,-8(fp)
   2c208:	10800517 	ldw	r2,20(r2)
   2c20c:	18bff61e 	bne	r3,r2,2c1e8 <altera_avalon_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
   2c210:	0005883a 	mov	r2,zero
}
   2c214:	e037883a 	mov	sp,fp
   2c218:	df000017 	ldw	fp,0(sp)
   2c21c:	dec00104 	addi	sp,sp,4
   2c220:	f800283a 	ret

0002c224 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   2c224:	defffe04 	addi	sp,sp,-8
   2c228:	dfc00115 	stw	ra,4(sp)
   2c22c:	df000015 	stw	fp,0(sp)
   2c230:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   2c234:	008000f4 	movhi	r2,3
   2c238:	10958804 	addi	r2,r2,22048
   2c23c:	10800017 	ldw	r2,0(r2)
   2c240:	10000526 	beq	r2,zero,2c258 <alt_get_errno+0x34>
   2c244:	008000f4 	movhi	r2,3
   2c248:	10958804 	addi	r2,r2,22048
   2c24c:	10800017 	ldw	r2,0(r2)
   2c250:	103ee83a 	callr	r2
   2c254:	00000206 	br	2c260 <alt_get_errno+0x3c>
   2c258:	008000f4 	movhi	r2,3
   2c25c:	109e4904 	addi	r2,r2,31012
}
   2c260:	e037883a 	mov	sp,fp
   2c264:	dfc00117 	ldw	ra,4(sp)
   2c268:	df000017 	ldw	fp,0(sp)
   2c26c:	dec00204 	addi	sp,sp,8
   2c270:	f800283a 	ret

0002c274 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
   2c274:	deffef04 	addi	sp,sp,-68
   2c278:	dfc01015 	stw	ra,64(sp)
   2c27c:	df000f15 	stw	fp,60(sp)
   2c280:	df000f04 	addi	fp,sp,60
   2c284:	e13ffc15 	stw	r4,-16(fp)
   2c288:	e17ffd15 	stw	r5,-12(fp)
   2c28c:	e1bffe15 	stw	r6,-8(fp)
   2c290:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u32         next;
  alt_u8          read_would_block = 0;
   2c294:	e03ff105 	stb	zero,-60(fp)
  int             count = 0;
   2c298:	e03ff215 	stw	zero,-56(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
   2c29c:	e0bfff17 	ldw	r2,-4(fp)
   2c2a0:	1090000c 	andi	r2,r2,16384
   2c2a4:	1005003a 	cmpeq	r2,r2,zero
   2c2a8:	10803fcc 	andi	r2,r2,255
   2c2ac:	e0bff315 	stw	r2,-52(fp)
  /*
   * Calculate which slot in the circular buffer is the next one to read
   * data from.
   */

  next = (sp->rx_start + 1) & ALT_AVALON_UART_BUF_MSK;
   2c2b0:	e0bffc17 	ldw	r2,-16(fp)
   2c2b4:	10800217 	ldw	r2,8(r2)
   2c2b8:	10800044 	addi	r2,r2,1
   2c2bc:	10800fcc 	andi	r2,r2,63
   2c2c0:	e0bff415 	stw	r2,-48(fp)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
   2c2c4:	00001906 	br	2c32c <altera_avalon_uart_read+0xb8>
    {
      count++;
   2c2c8:	e0bff217 	ldw	r2,-56(fp)
   2c2cc:	10800044 	addi	r2,r2,1
   2c2d0:	e0bff215 	stw	r2,-56(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
   2c2d4:	e0bffc17 	ldw	r2,-16(fp)
   2c2d8:	10800217 	ldw	r2,8(r2)
   2c2dc:	e0fffc17 	ldw	r3,-16(fp)
   2c2e0:	1885883a 	add	r2,r3,r2
   2c2e4:	10800704 	addi	r2,r2,28
   2c2e8:	10800003 	ldbu	r2,0(r2)
   2c2ec:	1007883a 	mov	r3,r2
   2c2f0:	e0bffd17 	ldw	r2,-12(fp)
   2c2f4:	10c00005 	stb	r3,0(r2)
   2c2f8:	e0bffd17 	ldw	r2,-12(fp)
   2c2fc:	10800044 	addi	r2,r2,1
   2c300:	e0bffd15 	stw	r2,-12(fp)
      
      sp->rx_start = (++sp->rx_start) & ALT_AVALON_UART_BUF_MSK;
   2c304:	e0bffc17 	ldw	r2,-16(fp)
   2c308:	10800217 	ldw	r2,8(r2)
   2c30c:	10c00044 	addi	r3,r2,1
   2c310:	e0bffc17 	ldw	r2,-16(fp)
   2c314:	10c00215 	stw	r3,8(r2)
   2c318:	e0bffc17 	ldw	r2,-16(fp)
   2c31c:	10800217 	ldw	r2,8(r2)
   2c320:	10c00fcc 	andi	r3,r2,63
   2c324:	e0bffc17 	ldw	r2,-16(fp)
   2c328:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
   2c32c:	e0fff217 	ldw	r3,-56(fp)
   2c330:	e0bffe17 	ldw	r2,-8(fp)
   2c334:	1880050e 	bge	r3,r2,2c34c <altera_avalon_uart_read+0xd8>
   2c338:	e0bffc17 	ldw	r2,-16(fp)
   2c33c:	10c00217 	ldw	r3,8(r2)
   2c340:	e0bffc17 	ldw	r2,-16(fp)
   2c344:	10800317 	ldw	r2,12(r2)
   2c348:	18bfdf1e 	bne	r3,r2,2c2c8 <altera_avalon_uart_read+0x54>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
   2c34c:	e0bff217 	ldw	r2,-56(fp)
   2c350:	10002f1e 	bne	r2,zero,2c410 <altera_avalon_uart_read+0x19c>
   2c354:	e0bffc17 	ldw	r2,-16(fp)
   2c358:	10c00217 	ldw	r3,8(r2)
   2c35c:	e0bffc17 	ldw	r2,-16(fp)
   2c360:	10800317 	ldw	r2,12(r2)
   2c364:	18802a1e 	bne	r3,r2,2c410 <altera_avalon_uart_read+0x19c>
    {
      if (!block)
   2c368:	e0bff317 	ldw	r2,-52(fp)
   2c36c:	1000061e 	bne	r2,zero,2c388 <altera_avalon_uart_read+0x114>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
   2c370:	002c2240 	call	2c224 <alt_get_errno>
   2c374:	00c002c4 	movi	r3,11
   2c378:	10c00015 	stw	r3,0(r2)
        read_would_block = 1;
   2c37c:	00800044 	movi	r2,1
   2c380:	e0bff105 	stb	r2,-60(fp)
        break;
   2c384:	00002606 	br	2c420 <altera_avalon_uart_read+0x1ac>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   2c388:	0005303a 	rdctl	r2,status
   2c38c:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   2c390:	e0fff617 	ldw	r3,-40(fp)
   2c394:	00bfff84 	movi	r2,-2
   2c398:	1884703a 	and	r2,r3,r2
   2c39c:	1001703a 	wrctl	status,r2
  
  return context;
   2c3a0:	e0bff617 	ldw	r2,-40(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
   2c3a4:	e0bff515 	stw	r2,-44(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
   2c3a8:	e0bffc17 	ldw	r2,-16(fp)
   2c3ac:	10800117 	ldw	r2,4(r2)
   2c3b0:	10c02014 	ori	r3,r2,128
   2c3b4:	e0bffc17 	ldw	r2,-16(fp)
   2c3b8:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
   2c3bc:	e0bffc17 	ldw	r2,-16(fp)
   2c3c0:	10800017 	ldw	r2,0(r2)
   2c3c4:	10800304 	addi	r2,r2,12
   2c3c8:	e0fffc17 	ldw	r3,-16(fp)
   2c3cc:	18c00117 	ldw	r3,4(r3)
   2c3d0:	10c00035 	stwio	r3,0(r2)
   2c3d4:	e0bff517 	ldw	r2,-44(fp)
   2c3d8:	e0bff715 	stw	r2,-36(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   2c3dc:	0005303a 	rdctl	r2,status
   2c3e0:	e0bff815 	stw	r2,-32(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   2c3e4:	e0fff817 	ldw	r3,-32(fp)
   2c3e8:	00bfff84 	movi	r2,-2
   2c3ec:	1884703a 	and	r2,r3,r2
   2c3f0:	e0bff815 	stw	r2,-32(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   2c3f4:	e0bff717 	ldw	r2,-36(fp)
   2c3f8:	1080004c 	andi	r2,r2,1
   2c3fc:	e0fff817 	ldw	r3,-32(fp)
   2c400:	1884b03a 	or	r2,r3,r2
   2c404:	e0bff815 	stw	r2,-32(fp)
  
  NIOS2_WRITE_STATUS (status);
   2c408:	e0bff817 	ldw	r2,-32(fp)
   2c40c:	1001703a 	wrctl	status,r2
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
   2c410:	e0bff217 	ldw	r2,-56(fp)
   2c414:	1000021e 	bne	r2,zero,2c420 <altera_avalon_uart_read+0x1ac>
   2c418:	e0bffe17 	ldw	r2,-8(fp)
   2c41c:	103fc31e 	bne	r2,zero,2c32c <altera_avalon_uart_read+0xb8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   2c420:	0005303a 	rdctl	r2,status
   2c424:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   2c428:	e0fff917 	ldw	r3,-28(fp)
   2c42c:	00bfff84 	movi	r2,-2
   2c430:	1884703a 	and	r2,r3,r2
   2c434:	1001703a 	wrctl	status,r2
  
  return context;
   2c438:	e0bff917 	ldw	r2,-28(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
   2c43c:	e0bff515 	stw	r2,-44(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
   2c440:	e0bffc17 	ldw	r2,-16(fp)
   2c444:	10800117 	ldw	r2,4(r2)
   2c448:	10c02014 	ori	r3,r2,128
   2c44c:	e0bffc17 	ldw	r2,-16(fp)
   2c450:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
   2c454:	e0bffc17 	ldw	r2,-16(fp)
   2c458:	10800017 	ldw	r2,0(r2)
   2c45c:	10800304 	addi	r2,r2,12
   2c460:	e0fffc17 	ldw	r3,-16(fp)
   2c464:	18c00117 	ldw	r3,4(r3)
   2c468:	10c00035 	stwio	r3,0(r2)
   2c46c:	e0bff517 	ldw	r2,-44(fp)
   2c470:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   2c474:	0005303a 	rdctl	r2,status
   2c478:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   2c47c:	e0fffb17 	ldw	r3,-20(fp)
   2c480:	00bfff84 	movi	r2,-2
   2c484:	1884703a 	and	r2,r3,r2
   2c488:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   2c48c:	e0bffa17 	ldw	r2,-24(fp)
   2c490:	1080004c 	andi	r2,r2,1
   2c494:	e0fffb17 	ldw	r3,-20(fp)
   2c498:	1884b03a 	or	r2,r3,r2
   2c49c:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
   2c4a0:	e0bffb17 	ldw	r2,-20(fp)
   2c4a4:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
   2c4a8:	e0bff103 	ldbu	r2,-60(fp)
   2c4ac:	10000226 	beq	r2,zero,2c4b8 <altera_avalon_uart_read+0x244>
    return -EWOULDBLOCK;
   2c4b0:	00bffd44 	movi	r2,-11
   2c4b4:	00000106 	br	2c4bc <altera_avalon_uart_read+0x248>
  }
  else {
    return count;
   2c4b8:	e0bff217 	ldw	r2,-56(fp)
  }
}
   2c4bc:	e037883a 	mov	sp,fp
   2c4c0:	dfc00117 	ldw	ra,4(sp)
   2c4c4:	df000017 	ldw	fp,0(sp)
   2c4c8:	dec00204 	addi	sp,sp,8
   2c4cc:	f800283a 	ret

0002c4d0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   2c4d0:	defffe04 	addi	sp,sp,-8
   2c4d4:	dfc00115 	stw	ra,4(sp)
   2c4d8:	df000015 	stw	fp,0(sp)
   2c4dc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   2c4e0:	008000f4 	movhi	r2,3
   2c4e4:	10958804 	addi	r2,r2,22048
   2c4e8:	10800017 	ldw	r2,0(r2)
   2c4ec:	10000526 	beq	r2,zero,2c504 <alt_get_errno+0x34>
   2c4f0:	008000f4 	movhi	r2,3
   2c4f4:	10958804 	addi	r2,r2,22048
   2c4f8:	10800017 	ldw	r2,0(r2)
   2c4fc:	103ee83a 	callr	r2
   2c500:	00000206 	br	2c50c <alt_get_errno+0x3c>
   2c504:	008000f4 	movhi	r2,3
   2c508:	109e4904 	addi	r2,r2,31012
}
   2c50c:	e037883a 	mov	sp,fp
   2c510:	dfc00117 	ldw	ra,4(sp)
   2c514:	df000017 	ldw	fp,0(sp)
   2c518:	dec00204 	addi	sp,sp,8
   2c51c:	f800283a 	ret

0002c520 <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
   2c520:	defff004 	addi	sp,sp,-64
   2c524:	dfc00f15 	stw	ra,60(sp)
   2c528:	df000e15 	stw	fp,56(sp)
   2c52c:	df000e04 	addi	fp,sp,56
   2c530:	e13ffc15 	stw	r4,-16(fp)
   2c534:	e17ffd15 	stw	r5,-12(fp)
   2c538:	e1bffe15 	stw	r6,-8(fp)
   2c53c:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
   2c540:	e0bffe17 	ldw	r2,-8(fp)
   2c544:	e0bff215 	stw	r2,-56(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
   2c548:	e0bfff17 	ldw	r2,-4(fp)
   2c54c:	1090000c 	andi	r2,r2,16384
   2c550:	e0bff315 	stw	r2,-52(fp)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
   2c554:	00004606 	br	2c670 <altera_avalon_uart_write+0x150>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
   2c558:	e0bffc17 	ldw	r2,-16(fp)
   2c55c:	10800517 	ldw	r2,20(r2)
   2c560:	10800044 	addi	r2,r2,1
   2c564:	10800fcc 	andi	r2,r2,63
   2c568:	e0bff415 	stw	r2,-48(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
   2c56c:	e0bffc17 	ldw	r2,-16(fp)
   2c570:	10c00417 	ldw	r3,16(r2)
   2c574:	e0bff417 	ldw	r2,-48(fp)
   2c578:	18802c1e 	bne	r3,r2,2c62c <altera_avalon_uart_write+0x10c>
    {
      if (no_block)
   2c57c:	e0bff317 	ldw	r2,-52(fp)
   2c580:	10000426 	beq	r2,zero,2c594 <altera_avalon_uart_write+0x74>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
   2c584:	002c4d00 	call	2c4d0 <alt_get_errno>
   2c588:	00c002c4 	movi	r3,11
   2c58c:	10c00015 	stw	r3,0(r2)
        break;
   2c590:	00003906 	br	2c678 <altera_avalon_uart_write+0x158>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   2c594:	0005303a 	rdctl	r2,status
   2c598:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   2c59c:	e0fff617 	ldw	r3,-40(fp)
   2c5a0:	00bfff84 	movi	r2,-2
   2c5a4:	1884703a 	and	r2,r3,r2
   2c5a8:	1001703a 	wrctl	status,r2
  
  return context;
   2c5ac:	e0bff617 	ldw	r2,-40(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
   2c5b0:	e0bff515 	stw	r2,-44(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
   2c5b4:	e0bffc17 	ldw	r2,-16(fp)
   2c5b8:	10800117 	ldw	r2,4(r2)
   2c5bc:	10c11014 	ori	r3,r2,1088
   2c5c0:	e0bffc17 	ldw	r2,-16(fp)
   2c5c4:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
   2c5c8:	e0bffc17 	ldw	r2,-16(fp)
   2c5cc:	10800017 	ldw	r2,0(r2)
   2c5d0:	10800304 	addi	r2,r2,12
   2c5d4:	e0fffc17 	ldw	r3,-16(fp)
   2c5d8:	18c00117 	ldw	r3,4(r3)
   2c5dc:	10c00035 	stwio	r3,0(r2)
   2c5e0:	e0bff517 	ldw	r2,-44(fp)
   2c5e4:	e0bff715 	stw	r2,-36(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   2c5e8:	0005303a 	rdctl	r2,status
   2c5ec:	e0bff815 	stw	r2,-32(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   2c5f0:	e0fff817 	ldw	r3,-32(fp)
   2c5f4:	00bfff84 	movi	r2,-2
   2c5f8:	1884703a 	and	r2,r3,r2
   2c5fc:	e0bff815 	stw	r2,-32(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   2c600:	e0bff717 	ldw	r2,-36(fp)
   2c604:	1080004c 	andi	r2,r2,1
   2c608:	e0fff817 	ldw	r3,-32(fp)
   2c60c:	1884b03a 	or	r2,r3,r2
   2c610:	e0bff815 	stw	r2,-32(fp)
  
  NIOS2_WRITE_STATUS (status);
   2c614:	e0bff817 	ldw	r2,-32(fp)
   2c618:	1001703a 	wrctl	status,r2
          ALT_FLAG_PEND (sp->events, 
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
   2c61c:	e0bffc17 	ldw	r2,-16(fp)
   2c620:	10c00417 	ldw	r3,16(r2)
   2c624:	e0bff417 	ldw	r2,-48(fp)
   2c628:	18bffc26 	beq	r3,r2,2c61c <altera_avalon_uart_write+0xfc>
      }
    }

    count--;
   2c62c:	e0bff217 	ldw	r2,-56(fp)
   2c630:	10bfffc4 	addi	r2,r2,-1
   2c634:	e0bff215 	stw	r2,-56(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
   2c638:	e0bffc17 	ldw	r2,-16(fp)
   2c63c:	10800517 	ldw	r2,20(r2)
   2c640:	e0fffd17 	ldw	r3,-12(fp)
   2c644:	18c00003 	ldbu	r3,0(r3)
   2c648:	e13ffc17 	ldw	r4,-16(fp)
   2c64c:	2085883a 	add	r2,r4,r2
   2c650:	10801704 	addi	r2,r2,92
   2c654:	10c00005 	stb	r3,0(r2)
   2c658:	e0bffd17 	ldw	r2,-12(fp)
   2c65c:	10800044 	addi	r2,r2,1
   2c660:	e0bffd15 	stw	r2,-12(fp)
    sp->tx_end = next;
   2c664:	e0bffc17 	ldw	r2,-16(fp)
   2c668:	e0fff417 	ldw	r3,-48(fp)
   2c66c:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
   2c670:	e0bff217 	ldw	r2,-56(fp)
   2c674:	103fb81e 	bne	r2,zero,2c558 <altera_avalon_uart_write+0x38>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   2c678:	0005303a 	rdctl	r2,status
   2c67c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   2c680:	e0fff917 	ldw	r3,-28(fp)
   2c684:	00bfff84 	movi	r2,-2
   2c688:	1884703a 	and	r2,r3,r2
   2c68c:	1001703a 	wrctl	status,r2
  
  return context;
   2c690:	e0bff917 	ldw	r2,-28(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
   2c694:	e0bff515 	stw	r2,-44(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
   2c698:	e0bffc17 	ldw	r2,-16(fp)
   2c69c:	10800117 	ldw	r2,4(r2)
   2c6a0:	10c11014 	ori	r3,r2,1088
   2c6a4:	e0bffc17 	ldw	r2,-16(fp)
   2c6a8:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
   2c6ac:	e0bffc17 	ldw	r2,-16(fp)
   2c6b0:	10800017 	ldw	r2,0(r2)
   2c6b4:	10800304 	addi	r2,r2,12
   2c6b8:	e0fffc17 	ldw	r3,-16(fp)
   2c6bc:	18c00117 	ldw	r3,4(r3)
   2c6c0:	10c00035 	stwio	r3,0(r2)
   2c6c4:	e0bff517 	ldw	r2,-44(fp)
   2c6c8:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   2c6cc:	0005303a 	rdctl	r2,status
   2c6d0:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   2c6d4:	e0fffb17 	ldw	r3,-20(fp)
   2c6d8:	00bfff84 	movi	r2,-2
   2c6dc:	1884703a 	and	r2,r3,r2
   2c6e0:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   2c6e4:	e0bffa17 	ldw	r2,-24(fp)
   2c6e8:	1080004c 	andi	r2,r2,1
   2c6ec:	e0fffb17 	ldw	r3,-20(fp)
   2c6f0:	1884b03a 	or	r2,r3,r2
   2c6f4:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
   2c6f8:	e0bffb17 	ldw	r2,-20(fp)
   2c6fc:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
   2c700:	e0fffe17 	ldw	r3,-8(fp)
   2c704:	e0bff217 	ldw	r2,-56(fp)
   2c708:	1885c83a 	sub	r2,r3,r2
}
   2c70c:	e037883a 	mov	sp,fp
   2c710:	dfc00117 	ldw	ra,4(sp)
   2c714:	df000017 	ldw	fp,0(sp)
   2c718:	dec00204 	addi	sp,sp,8
   2c71c:	f800283a 	ret

0002c720 <VIC_0_VECTOR_TABLE>:

    .section .text, "xa"
    .align 2
    .globl VIC_0_VECTOR_TABLE
VIC_0_VECTOR_TABLE:
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c720:	0030e03a 	nextpc	et
   2c724:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c730:	0030e03a 	nextpc	et
   2c734:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c740:	0030e03a 	nextpc	et
   2c744:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c750:	0030e03a 	nextpc	et
   2c754:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c760:	0030e03a 	nextpc	et
   2c764:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c770:	0030e03a 	nextpc	et
   2c774:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c780:	0030e03a 	nextpc	et
   2c784:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c790:	0030e03a 	nextpc	et
   2c794:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c7a0:	0030e03a 	nextpc	et
   2c7a4:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c7b0:	0030e03a 	nextpc	et
   2c7b4:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c7c0:	0030e03a 	nextpc	et
   2c7c4:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c7d0:	0030e03a 	nextpc	et
   2c7d4:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c7e0:	0030e03a 	nextpc	et
   2c7e4:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c7f0:	0030e03a 	nextpc	et
   2c7f4:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c800:	0030e03a 	nextpc	et
   2c804:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c810:	0030e03a 	nextpc	et
   2c814:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c820:	0030e03a 	nextpc	et
   2c824:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c830:	0030e03a 	nextpc	et
   2c834:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c840:	0030e03a 	nextpc	et
   2c844:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c850:	0030e03a 	nextpc	et
   2c854:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c860:	0030e03a 	nextpc	et
   2c864:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c870:	0030e03a 	nextpc	et
   2c874:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c880:	0030e03a 	nextpc	et
   2c884:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c890:	0030e03a 	nextpc	et
   2c894:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c8a0:	0030e03a 	nextpc	et
   2c8a4:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c8b0:	0030e03a 	nextpc	et
   2c8b4:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c8c0:	0030e03a 	nextpc	et
   2c8c4:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c8d0:	0030e03a 	nextpc	et
   2c8d4:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c8e0:	0030e03a 	nextpc	et
   2c8e4:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c8f0:	0030e03a 	nextpc	et
   2c8f4:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c900:	0030e03a 	nextpc	et
   2c904:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   2c910:	0030e03a 	nextpc	et
   2c914:	002c9201 	jmpi	2c920 <alt_shadow_non_preemptive_interrupt>
	...

0002c920 <alt_shadow_non_preemptive_interrupt>:
    .section ALTERA_VIC_DRIVER_LINKER_SECTION
    .set nobreak
    .globl alt_shadow_non_preemptive_interrupt
alt_shadow_non_preemptive_interrupt:

    ldw r16, 4(et)               /* load ISR pointer */
   2c920:	c4000117 	ldw	r16,4(et)

     /*
      * Get SP from previous register set.
      */

    rdprs sp, sp, 0
   2c924:	dec00038 	rdprs	sp,sp,0
  /*
   * Notify the operating system that we are at interrupt level.
   */
    ALT_OS_INT_ENTER_ASM

    ldw r4, 8(et)               /* load isr_context */
   2c928:	c1000217 	ldw	r4,8(et)
    callr r16                   /* call ISR */
   2c92c:	803ee83a 	callr	r16
    /*
     * Notify the operating system that interrupt processing is complete.
     */
    ALT_OS_INT_EXIT_ASM

    addi ea, ea, -4             /* instruction that caused exception */
   2c930:	ef7fff04 	addi	ea,ea,-4
    eret
   2c934:	ef80083a 	eret

0002c938 <alt_vic_irq_init>:
  * @API Type:              Internal
  * @param pdev             pointer of type alt_vic_dev, main Device Structure.
  * @return                 None
  */
void alt_vic_irq_init (alt_vic_dev* pdev)
{
   2c938:	defffd04 	addi	sp,sp,-12
   2c93c:	df000215 	stw	fp,8(sp)
   2c940:	df000204 	addi	fp,sp,8
   2c944:	e13fff15 	stw	r4,-4(fp)
    alt_u32 i;
    static const int VEC_SIZE_ARRAY[]={4, 8, 16, 32, 64, 128, 256, 512};

    /* Stores the VIC instance to list */
    alt_vic_dev_list[pdev->intr_controller_id] = pdev;
   2c948:	e0bfff17 	ldw	r2,-4(fp)
   2c94c:	10800117 	ldw	r2,4(r2)
   2c950:	1085883a 	add	r2,r2,r2
   2c954:	1087883a 	add	r3,r2,r2
   2c958:	d0a8e004 	addi	r2,gp,-23680
   2c95c:	1885883a 	add	r2,r3,r2
   2c960:	e0ffff17 	ldw	r3,-4(fp)
   2c964:	10c00015 	stw	r3,0(r2)

    /* Disables all interrupts */
    IOWR_ALTERA_VIC_INT_ENABLE_CLR(pdev->base, 0xFFFFFFFF);
   2c968:	e0bfff17 	ldw	r2,-4(fp)
   2c96c:	10800017 	ldw	r2,0(r2)
   2c970:	10802204 	addi	r2,r2,136
   2c974:	00ffffc4 	movi	r3,-1
   2c978:	10c00035 	stwio	r3,0(r2)

    /* Initialize INT_CONFIG for all interrupts in this VIC */
    for(i = 0; i < pdev->num_of_intr_ports; i++)
   2c97c:	e03ffe15 	stw	zero,-8(fp)
   2c980:	00001106 	br	2c9c8 <alt_vic_irq_init+0x90>
    {
        IOWR_ALTERA_VIC_INT_CONFIG(pdev->base, i, pdev->int_config[i]);
   2c984:	e0bfff17 	ldw	r2,-4(fp)
   2c988:	10c00017 	ldw	r3,0(r2)
   2c98c:	e0bffe17 	ldw	r2,-8(fp)
   2c990:	1085883a 	add	r2,r2,r2
   2c994:	1085883a 	add	r2,r2,r2
   2c998:	1887883a 	add	r3,r3,r2
   2c99c:	e13fff17 	ldw	r4,-4(fp)
   2c9a0:	e0bffe17 	ldw	r2,-8(fp)
   2c9a4:	108001c4 	addi	r2,r2,7
   2c9a8:	1085883a 	add	r2,r2,r2
   2c9ac:	1085883a 	add	r2,r2,r2
   2c9b0:	2085883a 	add	r2,r4,r2
   2c9b4:	10800017 	ldw	r2,0(r2)
   2c9b8:	18800035 	stwio	r2,0(r3)

    /* Disables all interrupts */
    IOWR_ALTERA_VIC_INT_ENABLE_CLR(pdev->base, 0xFFFFFFFF);

    /* Initialize INT_CONFIG for all interrupts in this VIC */
    for(i = 0; i < pdev->num_of_intr_ports; i++)
   2c9bc:	e0bffe17 	ldw	r2,-8(fp)
   2c9c0:	10800044 	addi	r2,r2,1
   2c9c4:	e0bffe15 	stw	r2,-8(fp)
   2c9c8:	e0bfff17 	ldw	r2,-4(fp)
   2c9cc:	10800217 	ldw	r2,8(r2)
   2c9d0:	e0fffe17 	ldw	r3,-8(fp)
   2c9d4:	18bfeb36 	bltu	r3,r2,2c984 <alt_vic_irq_init+0x4c>
    {
        IOWR_ALTERA_VIC_INT_CONFIG(pdev->base, i, pdev->int_config[i]);
    }

    /* Set vector size and disable/enable daisy-chained input */
    for(i = 0; i < sizeof(VEC_SIZE_ARRAY)/sizeof(VEC_SIZE_ARRAY[0]); i++)
   2c9d8:	e03ffe15 	stw	zero,-8(fp)
   2c9dc:	00001806 	br	2ca40 <alt_vic_irq_init+0x108>
    {
        if(VEC_SIZE_ARRAY[i] == pdev->vec_size)
   2c9e0:	00c000f4 	movhi	r3,3
   2c9e4:	18cc6204 	addi	r3,r3,12680
   2c9e8:	e0bffe17 	ldw	r2,-8(fp)
   2c9ec:	1085883a 	add	r2,r2,r2
   2c9f0:	1085883a 	add	r2,r2,r2
   2c9f4:	1885883a 	add	r2,r3,r2
   2c9f8:	10800017 	ldw	r2,0(r2)
   2c9fc:	1007883a 	mov	r3,r2
   2ca00:	e0bfff17 	ldw	r2,-4(fp)
   2ca04:	10800517 	ldw	r2,20(r2)
   2ca08:	18800a1e 	bne	r3,r2,2ca34 <alt_vic_irq_init+0xfc>
        {
            IOWR_ALTERA_VIC_CONFIG(pdev->base,
   2ca0c:	e0bfff17 	ldw	r2,-4(fp)
   2ca10:	10800017 	ldw	r2,0(r2)
   2ca14:	10802804 	addi	r2,r2,160
   2ca18:	e0ffff17 	ldw	r3,-4(fp)
   2ca1c:	18c00417 	ldw	r3,16(r3)
   2ca20:	180890fa 	slli	r4,r3,3
   2ca24:	e0fffe17 	ldw	r3,-8(fp)
   2ca28:	20c6b03a 	or	r3,r4,r3
   2ca2c:	10c00035 	stwio	r3,0(r2)
                (i | (pdev->daisy_chain_present << ALTERA_VIC_CONFIG_DC_OFST)));
            break;
   2ca30:	00000606 	br	2ca4c <alt_vic_irq_init+0x114>
    {
        IOWR_ALTERA_VIC_INT_CONFIG(pdev->base, i, pdev->int_config[i]);
    }

    /* Set vector size and disable/enable daisy-chained input */
    for(i = 0; i < sizeof(VEC_SIZE_ARRAY)/sizeof(VEC_SIZE_ARRAY[0]); i++)
   2ca34:	e0bffe17 	ldw	r2,-8(fp)
   2ca38:	10800044 	addi	r2,r2,1
   2ca3c:	e0bffe15 	stw	r2,-8(fp)
   2ca40:	e0bffe17 	ldw	r2,-8(fp)
   2ca44:	10800230 	cmpltui	r2,r2,8
   2ca48:	103fe51e 	bne	r2,zero,2c9e0 <alt_vic_irq_init+0xa8>
            break;
        }
    }

    /* Set vector table base address */
    IOWR_ALTERA_VIC_VEC_TBL_BASE(pdev->base,((alt_u32)pdev->vec_addr));
   2ca4c:	e0bfff17 	ldw	r2,-4(fp)
   2ca50:	10800017 	ldw	r2,0(r2)
   2ca54:	10802a04 	addi	r2,r2,168
   2ca58:	e0ffff17 	ldw	r3,-4(fp)
   2ca5c:	18c00617 	ldw	r3,24(r3)
   2ca60:	10c00035 	stwio	r3,0(r2)
}
   2ca64:	e037883a 	mov	sp,fp
   2ca68:	df000017 	ldw	fp,0(sp)
   2ca6c:	dec00104 	addi	sp,sp,4
   2ca70:	f800283a 	ret

0002ca74 <alt_ic_isr_register>:
int alt_ic_isr_register(alt_u32 ic_id,
                        alt_u32 irq,
                        alt_isr_func isr,
                        void *isr_context,
                        void* flags)
{
   2ca74:	defff504 	addi	sp,sp,-44
   2ca78:	df000a15 	stw	fp,40(sp)
   2ca7c:	df000a04 	addi	fp,sp,40
   2ca80:	e13ffc15 	stw	r4,-16(fp)
   2ca84:	e17ffd15 	stw	r5,-12(fp)
   2ca88:	e1bffe15 	stw	r6,-8(fp)
   2ca8c:	e1ffff15 	stw	r7,-4(fp)
    alt_vic_dev *pdev;
    alt_u32 *offset;
    alt_irq_context status;

    if(ic_id >= ALT_NUM_EXTERNAL_INTERRUPT_CONTROLLERS)
   2ca90:	e0bffc17 	ldw	r2,-16(fp)
   2ca94:	10000226 	beq	r2,zero,2caa0 <alt_ic_isr_register+0x2c>
        return -1;
   2ca98:	00bfffc4 	movi	r2,-1
   2ca9c:	00004706 	br	2cbbc <alt_ic_isr_register+0x148>

    /* Get VIC handle */
    pdev = alt_vic_dev_list[ic_id];
   2caa0:	00c000f4 	movhi	r3,3
   2caa4:	18de5204 	addi	r3,r3,31048
   2caa8:	e0bffc17 	ldw	r2,-16(fp)
   2caac:	1085883a 	add	r2,r2,r2
   2cab0:	1085883a 	add	r2,r2,r2
   2cab4:	1885883a 	add	r2,r3,r2
   2cab8:	10800017 	ldw	r2,0(r2)
   2cabc:	e0bff615 	stw	r2,-40(fp)

    if(irq < pdev->num_of_intr_ports)
   2cac0:	e0bff617 	ldw	r2,-40(fp)
   2cac4:	10800217 	ldw	r2,8(r2)
   2cac8:	e0fffd17 	ldw	r3,-12(fp)
   2cacc:	18803a2e 	bgeu	r3,r2,2cbb8 <alt_ic_isr_register+0x144>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   2cad0:	0005303a 	rdctl	r2,status
   2cad4:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   2cad8:	e0fff917 	ldw	r3,-28(fp)
   2cadc:	00bfff84 	movi	r2,-2
   2cae0:	1884703a 	and	r2,r3,r2
   2cae4:	1001703a 	wrctl	status,r2
  
  return context;
   2cae8:	e0bff917 	ldw	r2,-28(fp)
    {
        /* Disable all interrupts */
        status = alt_irq_disable_all ();
   2caec:	e0bff715 	stw	r2,-36(fp)

        /* Get table offset */
        offset = pdev->vec_addr + (irq * pdev->vec_size);
   2caf0:	e0bff617 	ldw	r2,-40(fp)
   2caf4:	10c00617 	ldw	r3,24(r2)
   2caf8:	e0bff617 	ldw	r2,-40(fp)
   2cafc:	11000517 	ldw	r4,20(r2)
   2cb00:	e0bffd17 	ldw	r2,-12(fp)
   2cb04:	2085383a 	mul	r2,r4,r2
   2cb08:	1885883a 	add	r2,r3,r2
   2cb0c:	e0bff815 	stw	r2,-32(fp)

        /* Write ISR and ISR context to vector table */
        ALT_VECTOR_TABLE_WRITE(offset+2, isr);
   2cb10:	e0bff817 	ldw	r2,-32(fp)
   2cb14:	10800204 	addi	r2,r2,8
   2cb18:	e0fffe17 	ldw	r3,-8(fp)
   2cb1c:	10c00015 	stw	r3,0(r2)
        ALT_VECTOR_TABLE_WRITE(offset+3, isr_context);
   2cb20:	e0bff817 	ldw	r2,-32(fp)
   2cb24:	10800304 	addi	r2,r2,12
   2cb28:	e0ffff17 	ldw	r3,-4(fp)
   2cb2c:	10c00015 	stw	r3,0(r2)

        if(isr)
   2cb30:	e0bffe17 	ldw	r2,-8(fp)
   2cb34:	10000826 	beq	r2,zero,2cb58 <alt_ic_isr_register+0xe4>
        {
            /* Enable this IRQ on the VIC */
            IOWR_ALTERA_VIC_INT_ENABLE_SET(pdev->base, 1 << irq);
   2cb38:	e0bff617 	ldw	r2,-40(fp)
   2cb3c:	10800017 	ldw	r2,0(r2)
   2cb40:	10802104 	addi	r2,r2,132
   2cb44:	e0fffd17 	ldw	r3,-12(fp)
   2cb48:	01000044 	movi	r4,1
   2cb4c:	20c6983a 	sll	r3,r4,r3
   2cb50:	10c00035 	stwio	r3,0(r2)
   2cb54:	00000706 	br	2cb74 <alt_ic_isr_register+0x100>
        }
        else
        {
            /* Disable this IRQ on the VIC */
            IOWR_ALTERA_VIC_INT_ENABLE_CLR(pdev->base, 1 << irq);
   2cb58:	e0bff617 	ldw	r2,-40(fp)
   2cb5c:	10800017 	ldw	r2,0(r2)
   2cb60:	10802204 	addi	r2,r2,136
   2cb64:	e0fffd17 	ldw	r3,-12(fp)
   2cb68:	01000044 	movi	r4,1
   2cb6c:	20c6983a 	sll	r3,r4,r3
   2cb70:	10c00035 	stwio	r3,0(r2)
   2cb74:	e0bff717 	ldw	r2,-36(fp)
   2cb78:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   2cb7c:	0005303a 	rdctl	r2,status
   2cb80:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   2cb84:	e0fffb17 	ldw	r3,-20(fp)
   2cb88:	00bfff84 	movi	r2,-2
   2cb8c:	1884703a 	and	r2,r3,r2
   2cb90:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   2cb94:	e0bffa17 	ldw	r2,-24(fp)
   2cb98:	1080004c 	andi	r2,r2,1
   2cb9c:	e0fffb17 	ldw	r3,-20(fp)
   2cba0:	1884b03a 	or	r2,r3,r2
   2cba4:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
   2cba8:	e0bffb17 	ldw	r2,-20(fp)
   2cbac:	1001703a 	wrctl	status,r2
        }

        /* Re-enable all interrupts */
        alt_irq_enable_all(status);

        return 0;
   2cbb0:	0005883a 	mov	r2,zero
   2cbb4:	00000106 	br	2cbbc <alt_ic_isr_register+0x148>
    }

    return -1;
   2cbb8:	00bfffc4 	movi	r2,-1
}
   2cbbc:	e037883a 	mov	sp,fp
   2cbc0:	df000017 	ldw	fp,0(sp)
   2cbc4:	dec00104 	addi	sp,sp,4
   2cbc8:	f800283a 	ret

0002cbcc <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
   2cbcc:	defffb04 	addi	sp,sp,-20
   2cbd0:	df000415 	stw	fp,16(sp)
   2cbd4:	df000404 	addi	fp,sp,16
   2cbd8:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
   2cbdc:	008000c4 	movi	r2,3
   2cbe0:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
   2cbe4:	e0fffd17 	ldw	r3,-12(fp)
   2cbe8:	008003f4 	movhi	r2,15
   2cbec:	10909004 	addi	r2,r2,16960
   2cbf0:	1885383a 	mul	r2,r3,r2
   2cbf4:	00c17db4 	movhi	r3,1526
   2cbf8:	18f84004 	addi	r3,r3,-7936
   2cbfc:	1885203a 	divu	r2,r3,r2
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
   2cc00:	00e00034 	movhi	r3,32768
   2cc04:	18ffffc4 	addi	r3,r3,-1
   2cc08:	1885203a 	divu	r2,r3,r2
   2cc0c:	e0ffff17 	ldw	r3,-4(fp)
   2cc10:	1885203a 	divu	r2,r3,r2
   2cc14:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
   2cc18:	e0bffe17 	ldw	r2,-8(fp)
   2cc1c:	10002526 	beq	r2,zero,2ccb4 <alt_busy_sleep+0xe8>
  {
    for(i=0;i<big_loops;i++)
   2cc20:	e03ffc15 	stw	zero,-16(fp)
   2cc24:	00001406 	br	2cc78 <alt_busy_sleep+0xac>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
   2cc28:	00a00034 	movhi	r2,32768
   2cc2c:	10bfffc4 	addi	r2,r2,-1
   2cc30:	10bfffc4 	addi	r2,r2,-1
   2cc34:	103ffe1e 	bne	r2,zero,2cc30 <alt_busy_sleep+0x64>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
   2cc38:	e0fffd17 	ldw	r3,-12(fp)
   2cc3c:	008003f4 	movhi	r2,15
   2cc40:	10909004 	addi	r2,r2,16960
   2cc44:	1885383a 	mul	r2,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
   2cc48:	00c17db4 	movhi	r3,1526
   2cc4c:	18f84004 	addi	r3,r3,-7936
   2cc50:	1885203a 	divu	r2,r3,r2
   2cc54:	00e00034 	movhi	r3,32768
   2cc58:	18ffffc4 	addi	r3,r3,-1
   2cc5c:	1885203a 	divu	r2,r3,r2
   2cc60:	e0ffff17 	ldw	r3,-4(fp)
   2cc64:	1885c83a 	sub	r2,r3,r2
   2cc68:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
   2cc6c:	e0bffc17 	ldw	r2,-16(fp)
   2cc70:	10800044 	addi	r2,r2,1
   2cc74:	e0bffc15 	stw	r2,-16(fp)
   2cc78:	e0fffc17 	ldw	r3,-16(fp)
   2cc7c:	e0bffe17 	ldw	r2,-8(fp)
   2cc80:	18bfe916 	blt	r3,r2,2cc28 <alt_busy_sleep+0x5c>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
   2cc84:	e0fffd17 	ldw	r3,-12(fp)
   2cc88:	008003f4 	movhi	r2,15
   2cc8c:	10909004 	addi	r2,r2,16960
   2cc90:	1885383a 	mul	r2,r3,r2
   2cc94:	00c17db4 	movhi	r3,1526
   2cc98:	18f84004 	addi	r3,r3,-7936
   2cc9c:	1887203a 	divu	r3,r3,r2
   2cca0:	e0bfff17 	ldw	r2,-4(fp)
   2cca4:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
   2cca8:	10bfffc4 	addi	r2,r2,-1
   2ccac:	103ffe1e 	bne	r2,zero,2cca8 <alt_busy_sleep+0xdc>
   2ccb0:	00000b06 	br	2cce0 <alt_busy_sleep+0x114>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
   2ccb4:	e0fffd17 	ldw	r3,-12(fp)
   2ccb8:	008003f4 	movhi	r2,15
   2ccbc:	10909004 	addi	r2,r2,16960
   2ccc0:	1885383a 	mul	r2,r3,r2
   2ccc4:	00c17db4 	movhi	r3,1526
   2ccc8:	18f84004 	addi	r3,r3,-7936
   2cccc:	1887203a 	divu	r3,r3,r2
   2ccd0:	e0bfff17 	ldw	r2,-4(fp)
   2ccd4:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
   2ccd8:	10bfffc4 	addi	r2,r2,-1
   2ccdc:	00bffe16 	blt	zero,r2,2ccd8 <alt_busy_sleep+0x10c>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
   2cce0:	0005883a 	mov	r2,zero
}
   2cce4:	e037883a 	mov	sp,fp
   2cce8:	df000017 	ldw	fp,0(sp)
   2ccec:	dec00104 	addi	sp,sp,4
   2ccf0:	f800283a 	ret

0002ccf4 <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
   2ccf4:	defffd04 	addi	sp,sp,-12
   2ccf8:	df000215 	stw	fp,8(sp)
   2ccfc:	df000204 	addi	fp,sp,8
   2cd00:	e13ffe15 	stw	r4,-8(fp)
   2cd04:	e17fff15 	stw	r5,-4(fp)
  {
    ALT_FLUSH_DATA(i);
  }

#endif /* NIOS2_DCACHE_SIZE > 0 */
}
   2cd08:	e037883a 	mov	sp,fp
   2cd0c:	df000017 	ldw	fp,0(sp)
   2cd10:	dec00104 	addi	sp,sp,4
   2cd14:	f800283a 	ret

0002cd18 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
   2cd18:	deffff04 	addi	sp,sp,-4
   2cd1c:	df000015 	stw	fp,0(sp)
   2cd20:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
   2cd24:	e037883a 	mov	sp,fp
   2cd28:	df000017 	ldw	fp,0(sp)
   2cd2c:	dec00104 	addi	sp,sp,4
   2cd30:	f800283a 	ret

0002cd34 <alt_get_errno>:
   2cd34:	defffe04 	addi	sp,sp,-8
   2cd38:	dfc00115 	stw	ra,4(sp)
   2cd3c:	df000015 	stw	fp,0(sp)
   2cd40:	d839883a 	mov	fp,sp
   2cd44:	008000f4 	movhi	r2,3
   2cd48:	10958804 	addi	r2,r2,22048
   2cd4c:	10800017 	ldw	r2,0(r2)
   2cd50:	10000526 	beq	r2,zero,2cd68 <alt_get_errno+0x34>
   2cd54:	008000f4 	movhi	r2,3
   2cd58:	10958804 	addi	r2,r2,22048
   2cd5c:	10800017 	ldw	r2,0(r2)
   2cd60:	103ee83a 	callr	r2
   2cd64:	00000206 	br	2cd70 <alt_get_errno+0x3c>
   2cd68:	008000f4 	movhi	r2,3
   2cd6c:	109e4904 	addi	r2,r2,31012
   2cd70:	e037883a 	mov	sp,fp
   2cd74:	dfc00117 	ldw	ra,4(sp)
   2cd78:	df000017 	ldw	fp,0(sp)
   2cd7c:	dec00204 	addi	sp,sp,8
   2cd80:	f800283a 	ret

0002cd84 <alt_dev_llist_insert>:
   2cd84:	defffa04 	addi	sp,sp,-24
   2cd88:	dfc00515 	stw	ra,20(sp)
   2cd8c:	df000415 	stw	fp,16(sp)
   2cd90:	df000404 	addi	fp,sp,16
   2cd94:	e13ffe15 	stw	r4,-8(fp)
   2cd98:	e17fff15 	stw	r5,-4(fp)
   2cd9c:	e0bffe17 	ldw	r2,-8(fp)
   2cda0:	10000326 	beq	r2,zero,2cdb0 <alt_dev_llist_insert+0x2c>
   2cda4:	e0bffe17 	ldw	r2,-8(fp)
   2cda8:	10800217 	ldw	r2,8(r2)
   2cdac:	1000051e 	bne	r2,zero,2cdc4 <alt_dev_llist_insert+0x40>
   2cdb0:	002cd340 	call	2cd34 <alt_get_errno>
   2cdb4:	00c00584 	movi	r3,22
   2cdb8:	10c00015 	stw	r3,0(r2)
   2cdbc:	00bffa84 	movi	r2,-22
   2cdc0:	00001306 	br	2ce10 <alt_dev_llist_insert+0x8c>
   2cdc4:	e0bffe17 	ldw	r2,-8(fp)
   2cdc8:	e0ffff17 	ldw	r3,-4(fp)
   2cdcc:	e0fffc15 	stw	r3,-16(fp)
   2cdd0:	e0bffd15 	stw	r2,-12(fp)
   2cdd4:	e0bffd17 	ldw	r2,-12(fp)
   2cdd8:	e0fffc17 	ldw	r3,-16(fp)
   2cddc:	10c00115 	stw	r3,4(r2)
   2cde0:	e0bffc17 	ldw	r2,-16(fp)
   2cde4:	10c00017 	ldw	r3,0(r2)
   2cde8:	e0bffd17 	ldw	r2,-12(fp)
   2cdec:	10c00015 	stw	r3,0(r2)
   2cdf0:	e0bffc17 	ldw	r2,-16(fp)
   2cdf4:	10800017 	ldw	r2,0(r2)
   2cdf8:	e0fffd17 	ldw	r3,-12(fp)
   2cdfc:	10c00115 	stw	r3,4(r2)
   2ce00:	e0bffc17 	ldw	r2,-16(fp)
   2ce04:	e0fffd17 	ldw	r3,-12(fp)
   2ce08:	10c00015 	stw	r3,0(r2)
   2ce0c:	0005883a 	mov	r2,zero
   2ce10:	e037883a 	mov	sp,fp
   2ce14:	dfc00117 	ldw	ra,4(sp)
   2ce18:	df000017 	ldw	fp,0(sp)
   2ce1c:	dec00204 	addi	sp,sp,8
   2ce20:	f800283a 	ret

0002ce24 <_do_ctors>:
   2ce24:	defffd04 	addi	sp,sp,-12
   2ce28:	dfc00215 	stw	ra,8(sp)
   2ce2c:	df000115 	stw	fp,4(sp)
   2ce30:	df000104 	addi	fp,sp,4
   2ce34:	008000f4 	movhi	r2,3
   2ce38:	10b8be04 	addi	r2,r2,-7432
   2ce3c:	e0bfff15 	stw	r2,-4(fp)
   2ce40:	00000606 	br	2ce5c <_do_ctors+0x38>
   2ce44:	e0bfff17 	ldw	r2,-4(fp)
   2ce48:	10800017 	ldw	r2,0(r2)
   2ce4c:	103ee83a 	callr	r2
   2ce50:	e0bfff17 	ldw	r2,-4(fp)
   2ce54:	10bfff04 	addi	r2,r2,-4
   2ce58:	e0bfff15 	stw	r2,-4(fp)
   2ce5c:	e0ffff17 	ldw	r3,-4(fp)
   2ce60:	008000f4 	movhi	r2,3
   2ce64:	10b8bf04 	addi	r2,r2,-7428
   2ce68:	18bff62e 	bgeu	r3,r2,2ce44 <_do_ctors+0x20>
   2ce6c:	e037883a 	mov	sp,fp
   2ce70:	dfc00117 	ldw	ra,4(sp)
   2ce74:	df000017 	ldw	fp,0(sp)
   2ce78:	dec00204 	addi	sp,sp,8
   2ce7c:	f800283a 	ret

0002ce80 <_do_dtors>:
   2ce80:	defffd04 	addi	sp,sp,-12
   2ce84:	dfc00215 	stw	ra,8(sp)
   2ce88:	df000115 	stw	fp,4(sp)
   2ce8c:	df000104 	addi	fp,sp,4
   2ce90:	008000f4 	movhi	r2,3
   2ce94:	10b8be04 	addi	r2,r2,-7432
   2ce98:	e0bfff15 	stw	r2,-4(fp)
   2ce9c:	00000606 	br	2ceb8 <_do_dtors+0x38>
   2cea0:	e0bfff17 	ldw	r2,-4(fp)
   2cea4:	10800017 	ldw	r2,0(r2)
   2cea8:	103ee83a 	callr	r2
   2ceac:	e0bfff17 	ldw	r2,-4(fp)
   2ceb0:	10bfff04 	addi	r2,r2,-4
   2ceb4:	e0bfff15 	stw	r2,-4(fp)
   2ceb8:	e0ffff17 	ldw	r3,-4(fp)
   2cebc:	008000f4 	movhi	r2,3
   2cec0:	10b8bf04 	addi	r2,r2,-7428
   2cec4:	18bff62e 	bgeu	r3,r2,2cea0 <_do_dtors+0x20>
   2cec8:	e037883a 	mov	sp,fp
   2cecc:	dfc00117 	ldw	ra,4(sp)
   2ced0:	df000017 	ldw	fp,0(sp)
   2ced4:	dec00204 	addi	sp,sp,8
   2ced8:	f800283a 	ret

0002cedc <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
   2cedc:	defffa04 	addi	sp,sp,-24
   2cee0:	dfc00515 	stw	ra,20(sp)
   2cee4:	df000415 	stw	fp,16(sp)
   2cee8:	df000404 	addi	fp,sp,16
   2ceec:	e13ffe15 	stw	r4,-8(fp)
   2cef0:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
   2cef4:	e0bfff17 	ldw	r2,-4(fp)
   2cef8:	10800017 	ldw	r2,0(r2)
   2cefc:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
   2cf00:	e13ffe17 	ldw	r4,-8(fp)
   2cf04:	00197140 	call	19714 <strlen>
   2cf08:	10800044 	addi	r2,r2,1
   2cf0c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   2cf10:	00000d06 	br	2cf48 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
   2cf14:	e0bffc17 	ldw	r2,-16(fp)
   2cf18:	10c00217 	ldw	r3,8(r2)
   2cf1c:	e0bffd17 	ldw	r2,-12(fp)
   2cf20:	1809883a 	mov	r4,r3
   2cf24:	e17ffe17 	ldw	r5,-8(fp)
   2cf28:	100d883a 	mov	r6,r2
   2cf2c:	00191740 	call	19174 <memcmp>
   2cf30:	1000021e 	bne	r2,zero,2cf3c <alt_find_dev+0x60>
    {
      /* match found */

      return next;
   2cf34:	e0bffc17 	ldw	r2,-16(fp)
   2cf38:	00000706 	br	2cf58 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
   2cf3c:	e0bffc17 	ldw	r2,-16(fp)
   2cf40:	10800017 	ldw	r2,0(r2)
   2cf44:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   2cf48:	e0fffc17 	ldw	r3,-16(fp)
   2cf4c:	e0bfff17 	ldw	r2,-4(fp)
   2cf50:	18bff01e 	bne	r3,r2,2cf14 <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
   2cf54:	0005883a 	mov	r2,zero
}
   2cf58:	e037883a 	mov	sp,fp
   2cf5c:	dfc00117 	ldw	ra,4(sp)
   2cf60:	df000017 	ldw	fp,0(sp)
   2cf64:	dec00204 	addi	sp,sp,8
   2cf68:	f800283a 	ret

0002cf6c <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
   2cf6c:	defffc04 	addi	sp,sp,-16
   2cf70:	dfc00315 	stw	ra,12(sp)
   2cf74:	df000215 	stw	fp,8(sp)
   2cf78:	df000204 	addi	fp,sp,8
   2cf7c:	e13fff15 	stw	r4,-4(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
   2cf80:	e13fff17 	ldw	r4,-4(fp)
   2cf84:	d1601e04 	addi	r5,gp,-32648
   2cf88:	002cedc0 	call	2cedc <alt_find_dev>
   2cf8c:	e0bffe15 	stw	r2,-8(fp)

  if ((dev) && dev->open)
   2cf90:	e0bffe17 	ldw	r2,-8(fp)
   2cf94:	10000926 	beq	r2,zero,2cfbc <alt_flash_open_dev+0x50>
   2cf98:	e0bffe17 	ldw	r2,-8(fp)
   2cf9c:	10800317 	ldw	r2,12(r2)
   2cfa0:	10000626 	beq	r2,zero,2cfbc <alt_flash_open_dev+0x50>
  {
    return dev->open(dev, name);
   2cfa4:	e0bffe17 	ldw	r2,-8(fp)
   2cfa8:	10800317 	ldw	r2,12(r2)
   2cfac:	e13ffe17 	ldw	r4,-8(fp)
   2cfb0:	e17fff17 	ldw	r5,-4(fp)
   2cfb4:	103ee83a 	callr	r2
   2cfb8:	00000106 	br	2cfc0 <alt_flash_open_dev+0x54>
  }

  return dev;
   2cfbc:	e0bffe17 	ldw	r2,-8(fp)
}
   2cfc0:	e037883a 	mov	sp,fp
   2cfc4:	dfc00117 	ldw	ra,4(sp)
   2cfc8:	df000017 	ldw	fp,0(sp)
   2cfcc:	dec00204 	addi	sp,sp,8
   2cfd0:	f800283a 	ret

0002cfd4 <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
   2cfd4:	defffd04 	addi	sp,sp,-12
   2cfd8:	dfc00215 	stw	ra,8(sp)
   2cfdc:	df000115 	stw	fp,4(sp)
   2cfe0:	df000104 	addi	fp,sp,4
   2cfe4:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
   2cfe8:	e0bfff17 	ldw	r2,-4(fp)
   2cfec:	10000726 	beq	r2,zero,2d00c <alt_flash_close_dev+0x38>
   2cff0:	e0bfff17 	ldw	r2,-4(fp)
   2cff4:	10800417 	ldw	r2,16(r2)
   2cff8:	10000426 	beq	r2,zero,2d00c <alt_flash_close_dev+0x38>
  {
    fd->close(fd);
   2cffc:	e0bfff17 	ldw	r2,-4(fp)
   2d000:	10800417 	ldw	r2,16(r2)
   2d004:	e13fff17 	ldw	r4,-4(fp)
   2d008:	103ee83a 	callr	r2
  }
  return;
   2d00c:	0001883a 	nop
}
   2d010:	e037883a 	mov	sp,fp
   2d014:	dfc00117 	ldw	ra,4(sp)
   2d018:	df000017 	ldw	fp,0(sp)
   2d01c:	dec00204 	addi	sp,sp,8
   2d020:	f800283a 	ret

0002d024 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
   2d024:	defffe04 	addi	sp,sp,-8
   2d028:	dfc00115 	stw	ra,4(sp)
   2d02c:	df000015 	stw	fp,0(sp)
   2d030:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
   2d034:	0009883a 	mov	r4,zero
   2d038:	01440004 	movi	r5,4096
   2d03c:	002de5c0 	call	2de5c <alt_icache_flush>
#endif
}
   2d040:	e037883a 	mov	sp,fp
   2d044:	dfc00117 	ldw	ra,4(sp)
   2d048:	df000017 	ldw	fp,0(sp)
   2d04c:	dec00204 	addi	sp,sp,8
   2d050:	f800283a 	ret

0002d054 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
   2d054:	defff904 	addi	sp,sp,-28
   2d058:	dfc00615 	stw	ra,24(sp)
   2d05c:	df000515 	stw	fp,20(sp)
   2d060:	df000504 	addi	fp,sp,20
   2d064:	e13ffc15 	stw	r4,-16(fp)
   2d068:	e17ffd15 	stw	r5,-12(fp)
   2d06c:	e1bffe15 	stw	r6,-8(fp)
   2d070:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
   2d074:	e13ffd17 	ldw	r4,-12(fp)
   2d078:	e17ffe17 	ldw	r5,-8(fp)
   2d07c:	e1bfff17 	ldw	r6,-4(fp)
   2d080:	002d2a80 	call	2d2a8 <open>
   2d084:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
   2d088:	e0bffb17 	ldw	r2,-20(fp)
   2d08c:	10001c16 	blt	r2,zero,2d100 <alt_open_fd+0xac>
  {
    fd->dev      = alt_fd_list[old].dev;
   2d090:	00c000f4 	movhi	r3,3
   2d094:	18cfaa04 	addi	r3,r3,16040
   2d098:	e0bffb17 	ldw	r2,-20(fp)
   2d09c:	10800324 	muli	r2,r2,12
   2d0a0:	1885883a 	add	r2,r3,r2
   2d0a4:	10c00017 	ldw	r3,0(r2)
   2d0a8:	e0bffc17 	ldw	r2,-16(fp)
   2d0ac:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
   2d0b0:	00c000f4 	movhi	r3,3
   2d0b4:	18cfaa04 	addi	r3,r3,16040
   2d0b8:	e0bffb17 	ldw	r2,-20(fp)
   2d0bc:	10800324 	muli	r2,r2,12
   2d0c0:	1885883a 	add	r2,r3,r2
   2d0c4:	10800104 	addi	r2,r2,4
   2d0c8:	10c00017 	ldw	r3,0(r2)
   2d0cc:	e0bffc17 	ldw	r2,-16(fp)
   2d0d0:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
   2d0d4:	00c000f4 	movhi	r3,3
   2d0d8:	18cfaa04 	addi	r3,r3,16040
   2d0dc:	e0bffb17 	ldw	r2,-20(fp)
   2d0e0:	10800324 	muli	r2,r2,12
   2d0e4:	1885883a 	add	r2,r3,r2
   2d0e8:	10800204 	addi	r2,r2,8
   2d0ec:	10c00017 	ldw	r3,0(r2)
   2d0f0:	e0bffc17 	ldw	r2,-16(fp)
   2d0f4:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
   2d0f8:	e13ffb17 	ldw	r4,-20(fp)
   2d0fc:	00220e00 	call	220e0 <alt_release_fd>
  }
} 
   2d100:	e037883a 	mov	sp,fp
   2d104:	dfc00117 	ldw	ra,4(sp)
   2d108:	df000017 	ldw	fp,0(sp)
   2d10c:	dec00204 	addi	sp,sp,8
   2d110:	f800283a 	ret

0002d114 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
   2d114:	defffb04 	addi	sp,sp,-20
   2d118:	dfc00415 	stw	ra,16(sp)
   2d11c:	df000315 	stw	fp,12(sp)
   2d120:	df000304 	addi	fp,sp,12
   2d124:	e13ffd15 	stw	r4,-12(fp)
   2d128:	e17ffe15 	stw	r5,-8(fp)
   2d12c:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
   2d130:	010000f4 	movhi	r4,3
   2d134:	210fad04 	addi	r4,r4,16052
   2d138:	e17ffd17 	ldw	r5,-12(fp)
   2d13c:	01800044 	movi	r6,1
   2d140:	01c07fc4 	movi	r7,511
   2d144:	002d0540 	call	2d054 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
   2d148:	010000f4 	movhi	r4,3
   2d14c:	210faa04 	addi	r4,r4,16040
   2d150:	e17ffe17 	ldw	r5,-8(fp)
   2d154:	000d883a 	mov	r6,zero
   2d158:	01c07fc4 	movi	r7,511
   2d15c:	002d0540 	call	2d054 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
   2d160:	010000f4 	movhi	r4,3
   2d164:	210fb004 	addi	r4,r4,16064
   2d168:	e17fff17 	ldw	r5,-4(fp)
   2d16c:	01800044 	movi	r6,1
   2d170:	01c07fc4 	movi	r7,511
   2d174:	002d0540 	call	2d054 <alt_open_fd>
}  
   2d178:	e037883a 	mov	sp,fp
   2d17c:	dfc00117 	ldw	ra,4(sp)
   2d180:	df000017 	ldw	fp,0(sp)
   2d184:	dec00204 	addi	sp,sp,8
   2d188:	f800283a 	ret

0002d18c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   2d18c:	defffe04 	addi	sp,sp,-8
   2d190:	dfc00115 	stw	ra,4(sp)
   2d194:	df000015 	stw	fp,0(sp)
   2d198:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   2d19c:	008000f4 	movhi	r2,3
   2d1a0:	10958804 	addi	r2,r2,22048
   2d1a4:	10800017 	ldw	r2,0(r2)
   2d1a8:	10000526 	beq	r2,zero,2d1c0 <alt_get_errno+0x34>
   2d1ac:	008000f4 	movhi	r2,3
   2d1b0:	10958804 	addi	r2,r2,22048
   2d1b4:	10800017 	ldw	r2,0(r2)
   2d1b8:	103ee83a 	callr	r2
   2d1bc:	00000206 	br	2d1c8 <alt_get_errno+0x3c>
   2d1c0:	008000f4 	movhi	r2,3
   2d1c4:	109e4904 	addi	r2,r2,31012
}
   2d1c8:	e037883a 	mov	sp,fp
   2d1cc:	dfc00117 	ldw	ra,4(sp)
   2d1d0:	df000017 	ldw	fp,0(sp)
   2d1d4:	dec00204 	addi	sp,sp,8
   2d1d8:	f800283a 	ret

0002d1dc <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
   2d1dc:	defffd04 	addi	sp,sp,-12
   2d1e0:	df000215 	stw	fp,8(sp)
   2d1e4:	df000204 	addi	fp,sp,8
   2d1e8:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
   2d1ec:	e0bfff17 	ldw	r2,-4(fp)
   2d1f0:	10800217 	ldw	r2,8(r2)
   2d1f4:	10d00034 	orhi	r3,r2,16384
   2d1f8:	e0bfff17 	ldw	r2,-4(fp)
   2d1fc:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
   2d200:	e03ffe15 	stw	zero,-8(fp)
   2d204:	00001d06 	br	2d27c <alt_file_locked+0xa0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
   2d208:	00c000f4 	movhi	r3,3
   2d20c:	18cfaa04 	addi	r3,r3,16040
   2d210:	e0bffe17 	ldw	r2,-8(fp)
   2d214:	10800324 	muli	r2,r2,12
   2d218:	1885883a 	add	r2,r3,r2
   2d21c:	10c00017 	ldw	r3,0(r2)
   2d220:	e0bfff17 	ldw	r2,-4(fp)
   2d224:	10800017 	ldw	r2,0(r2)
   2d228:	1880111e 	bne	r3,r2,2d270 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
   2d22c:	00c000f4 	movhi	r3,3
   2d230:	18cfaa04 	addi	r3,r3,16040
   2d234:	e0bffe17 	ldw	r2,-8(fp)
   2d238:	10800324 	muli	r2,r2,12
   2d23c:	1885883a 	add	r2,r3,r2
   2d240:	10800204 	addi	r2,r2,8
   2d244:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
   2d248:	1000090e 	bge	r2,zero,2d270 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
   2d24c:	e0bffe17 	ldw	r2,-8(fp)
   2d250:	10c00324 	muli	r3,r2,12
   2d254:	008000f4 	movhi	r2,3
   2d258:	108faa04 	addi	r2,r2,16040
   2d25c:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
   2d260:	e0bfff17 	ldw	r2,-4(fp)
   2d264:	18800226 	beq	r3,r2,2d270 <alt_file_locked+0x94>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
   2d268:	00bffcc4 	movi	r2,-13
   2d26c:	00000a06 	br	2d298 <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
   2d270:	e0bffe17 	ldw	r2,-8(fp)
   2d274:	10800044 	addi	r2,r2,1
   2d278:	e0bffe15 	stw	r2,-8(fp)
   2d27c:	008000f4 	movhi	r2,3
   2d280:	10958704 	addi	r2,r2,22044
   2d284:	10800017 	ldw	r2,0(r2)
   2d288:	1007883a 	mov	r3,r2
   2d28c:	e0bffe17 	ldw	r2,-8(fp)
   2d290:	18bfdd2e 	bgeu	r3,r2,2d208 <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
   2d294:	0005883a 	mov	r2,zero
}
   2d298:	e037883a 	mov	sp,fp
   2d29c:	df000017 	ldw	fp,0(sp)
   2d2a0:	dec00104 	addi	sp,sp,4
   2d2a4:	f800283a 	ret

0002d2a8 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
   2d2a8:	defff604 	addi	sp,sp,-40
   2d2ac:	dfc00915 	stw	ra,36(sp)
   2d2b0:	df000815 	stw	fp,32(sp)
   2d2b4:	df000804 	addi	fp,sp,32
   2d2b8:	e13ffd15 	stw	r4,-12(fp)
   2d2bc:	e17ffe15 	stw	r5,-8(fp)
   2d2c0:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
   2d2c4:	00bfffc4 	movi	r2,-1
   2d2c8:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
   2d2cc:	00bffb44 	movi	r2,-19
   2d2d0:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
   2d2d4:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
   2d2d8:	e13ffd17 	ldw	r4,-12(fp)
   2d2dc:	014000f4 	movhi	r5,3
   2d2e0:	29558504 	addi	r5,r5,22036
   2d2e4:	002cedc0 	call	2cedc <alt_find_dev>
   2d2e8:	e0bff815 	stw	r2,-32(fp)
   2d2ec:	e0bff817 	ldw	r2,-32(fp)
   2d2f0:	1000051e 	bne	r2,zero,2d308 <open+0x60>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
   2d2f4:	e13ffd17 	ldw	r4,-12(fp)
   2d2f8:	002dc940 	call	2dc94 <alt_find_file>
   2d2fc:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
   2d300:	00800044 	movi	r2,1
   2d304:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
   2d308:	e0bff817 	ldw	r2,-32(fp)
   2d30c:	10002926 	beq	r2,zero,2d3b4 <open+0x10c>
  {
    if ((index = alt_get_fd (dev)) < 0)
   2d310:	e13ff817 	ldw	r4,-32(fp)
   2d314:	002dda80 	call	2dda8 <alt_get_fd>
   2d318:	e0bff915 	stw	r2,-28(fp)
   2d31c:	e0bff917 	ldw	r2,-28(fp)
   2d320:	1000030e 	bge	r2,zero,2d330 <open+0x88>
    {
      status = index;
   2d324:	e0bff917 	ldw	r2,-28(fp)
   2d328:	e0bffa15 	stw	r2,-24(fp)
   2d32c:	00002306 	br	2d3bc <open+0x114>
    }
    else
    {
      fd = &alt_fd_list[index];
   2d330:	e0bff917 	ldw	r2,-28(fp)
   2d334:	10c00324 	muli	r3,r2,12
   2d338:	008000f4 	movhi	r2,3
   2d33c:	108faa04 	addi	r2,r2,16040
   2d340:	1885883a 	add	r2,r3,r2
   2d344:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
   2d348:	e0fffe17 	ldw	r3,-8(fp)
   2d34c:	00900034 	movhi	r2,16384
   2d350:	10bfffc4 	addi	r2,r2,-1
   2d354:	1886703a 	and	r3,r3,r2
   2d358:	e0bffc17 	ldw	r2,-16(fp)
   2d35c:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
   2d360:	e0bffb17 	ldw	r2,-20(fp)
   2d364:	1000051e 	bne	r2,zero,2d37c <open+0xd4>
   2d368:	e13ffc17 	ldw	r4,-16(fp)
   2d36c:	002d1dc0 	call	2d1dc <alt_file_locked>
   2d370:	e0bffa15 	stw	r2,-24(fp)
   2d374:	e0bffa17 	ldw	r2,-24(fp)
   2d378:	10001016 	blt	r2,zero,2d3bc <open+0x114>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
   2d37c:	e0bff817 	ldw	r2,-32(fp)
   2d380:	10800317 	ldw	r2,12(r2)
   2d384:	10000826 	beq	r2,zero,2d3a8 <open+0x100>
   2d388:	e0bff817 	ldw	r2,-32(fp)
   2d38c:	10800317 	ldw	r2,12(r2)
   2d390:	e13ffc17 	ldw	r4,-16(fp)
   2d394:	e17ffd17 	ldw	r5,-12(fp)
   2d398:	e1bffe17 	ldw	r6,-8(fp)
   2d39c:	e1ffff17 	ldw	r7,-4(fp)
   2d3a0:	103ee83a 	callr	r2
   2d3a4:	00000106 	br	2d3ac <open+0x104>
   2d3a8:	0005883a 	mov	r2,zero
   2d3ac:	e0bffa15 	stw	r2,-24(fp)
   2d3b0:	00000206 	br	2d3bc <open+0x114>
      }
    }
  }
  else
  {
    status = -ENODEV;
   2d3b4:	00bffb44 	movi	r2,-19
   2d3b8:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
   2d3bc:	e0bffa17 	ldw	r2,-24(fp)
   2d3c0:	1000080e 	bge	r2,zero,2d3e4 <open+0x13c>
  {
    alt_release_fd (index);  
   2d3c4:	e13ff917 	ldw	r4,-28(fp)
   2d3c8:	00220e00 	call	220e0 <alt_release_fd>
    ALT_ERRNO = -status;
   2d3cc:	002d18c0 	call	2d18c <alt_get_errno>
   2d3d0:	e0fffa17 	ldw	r3,-24(fp)
   2d3d4:	00c7c83a 	sub	r3,zero,r3
   2d3d8:	10c00015 	stw	r3,0(r2)
    return -1;
   2d3dc:	00bfffc4 	movi	r2,-1
   2d3e0:	00000106 	br	2d3e8 <open+0x140>
  }
  
  /* return the reference upon success */

  return index;
   2d3e4:	e0bff917 	ldw	r2,-28(fp)
}
   2d3e8:	e037883a 	mov	sp,fp
   2d3ec:	dfc00117 	ldw	ra,4(sp)
   2d3f0:	df000017 	ldw	fp,0(sp)
   2d3f4:	dec00204 	addi	sp,sp,8
   2d3f8:	f800283a 	ret

0002d3fc <alt_program_amd>:
   2d3fc:	defff704 	addi	sp,sp,-36
   2d400:	dfc00815 	stw	ra,32(sp)
   2d404:	df000715 	stw	fp,28(sp)
   2d408:	df000704 	addi	fp,sp,28
   2d40c:	e13ffc15 	stw	r4,-16(fp)
   2d410:	e17ffd15 	stw	r5,-12(fp)
   2d414:	e1bffe15 	stw	r6,-8(fp)
   2d418:	e1ffff15 	stw	r7,-4(fp)
   2d41c:	e03ffa15 	stw	zero,-24(fp)
   2d420:	e0bffc17 	ldw	r2,-16(fp)
   2d424:	e0bffb15 	stw	r2,-20(fp)
   2d428:	008000f4 	movhi	r2,3
   2d42c:	10b5e404 	addi	r2,r2,-10352
   2d430:	d8800015 	stw	r2,0(sp)
   2d434:	e13ffb17 	ldw	r4,-20(fp)
   2d438:	e17ffe17 	ldw	r5,-8(fp)
   2d43c:	e1bfff17 	ldw	r6,-4(fp)
   2d440:	e1c00217 	ldw	r7,8(fp)
   2d444:	0022d800 	call	22d80 <alt_flash_program_block>
   2d448:	e0bffa15 	stw	r2,-24(fp)
   2d44c:	e0bffa17 	ldw	r2,-24(fp)
   2d450:	e037883a 	mov	sp,fp
   2d454:	dfc00117 	ldw	ra,4(sp)
   2d458:	df000017 	ldw	fp,0(sp)
   2d45c:	dec00204 	addi	sp,sp,8
   2d460:	f800283a 	ret

0002d464 <alt_erase_block_amd>:
   2d464:	defff804 	addi	sp,sp,-32
   2d468:	dfc00715 	stw	ra,28(sp)
   2d46c:	df000615 	stw	fp,24(sp)
   2d470:	df000604 	addi	fp,sp,24
   2d474:	e13ffe15 	stw	r4,-8(fp)
   2d478:	e17fff15 	stw	r5,-4(fp)
   2d47c:	e03ffa15 	stw	zero,-24(fp)
   2d480:	e0bffe17 	ldw	r2,-8(fp)
   2d484:	e0bffc15 	stw	r2,-16(fp)
   2d488:	e0bffc17 	ldw	r2,-16(fp)
   2d48c:	10c03317 	ldw	r3,204(r2)
   2d490:	e0bffc17 	ldw	r2,-16(fp)
   2d494:	10800a17 	ldw	r2,40(r2)
   2d498:	1009883a 	mov	r4,r2
   2d49c:	01415544 	movi	r5,1365
   2d4a0:	01802a84 	movi	r6,170
   2d4a4:	183ee83a 	callr	r3
   2d4a8:	e0bffc17 	ldw	r2,-16(fp)
   2d4ac:	10c03317 	ldw	r3,204(r2)
   2d4b0:	e0bffc17 	ldw	r2,-16(fp)
   2d4b4:	10800a17 	ldw	r2,40(r2)
   2d4b8:	1009883a 	mov	r4,r2
   2d4bc:	0140aa84 	movi	r5,682
   2d4c0:	01801544 	movi	r6,85
   2d4c4:	183ee83a 	callr	r3
   2d4c8:	e0bffc17 	ldw	r2,-16(fp)
   2d4cc:	10c03317 	ldw	r3,204(r2)
   2d4d0:	e0bffc17 	ldw	r2,-16(fp)
   2d4d4:	10800a17 	ldw	r2,40(r2)
   2d4d8:	1009883a 	mov	r4,r2
   2d4dc:	01415544 	movi	r5,1365
   2d4e0:	01802004 	movi	r6,128
   2d4e4:	183ee83a 	callr	r3
   2d4e8:	e0bffc17 	ldw	r2,-16(fp)
   2d4ec:	10c03317 	ldw	r3,204(r2)
   2d4f0:	e0bffc17 	ldw	r2,-16(fp)
   2d4f4:	10800a17 	ldw	r2,40(r2)
   2d4f8:	1009883a 	mov	r4,r2
   2d4fc:	01415544 	movi	r5,1365
   2d500:	01802a84 	movi	r6,170
   2d504:	183ee83a 	callr	r3
   2d508:	e0bffc17 	ldw	r2,-16(fp)
   2d50c:	10c03317 	ldw	r3,204(r2)
   2d510:	e0bffc17 	ldw	r2,-16(fp)
   2d514:	10800a17 	ldw	r2,40(r2)
   2d518:	1009883a 	mov	r4,r2
   2d51c:	0140aa84 	movi	r5,682
   2d520:	01801544 	movi	r6,85
   2d524:	183ee83a 	callr	r3
   2d528:	e0bffc17 	ldw	r2,-16(fp)
   2d52c:	10c03517 	ldw	r3,212(r2)
   2d530:	e0bffc17 	ldw	r2,-16(fp)
   2d534:	11000a17 	ldw	r4,40(r2)
   2d538:	e0bfff17 	ldw	r2,-4(fp)
   2d53c:	2085883a 	add	r2,r4,r2
   2d540:	1009883a 	mov	r4,r2
   2d544:	01400c04 	movi	r5,48
   2d548:	183ee83a 	callr	r3
   2d54c:	0109c404 	movi	r4,10000
   2d550:	00224a80 	call	224a8 <usleep>
   2d554:	00800c84 	movi	r2,50
   2d558:	e0bffb15 	stw	r2,-20(fp)
   2d55c:	e0bffc17 	ldw	r2,-16(fp)
   2d560:	10c00a17 	ldw	r3,40(r2)
   2d564:	e0bfff17 	ldw	r2,-4(fp)
   2d568:	1885883a 	add	r2,r3,r2
   2d56c:	10800023 	ldbuio	r2,0(r2)
   2d570:	10803fcc 	andi	r2,r2,255
   2d574:	e0bffd05 	stb	r2,-12(fp)
   2d578:	0100fa04 	movi	r4,1000
   2d57c:	00224a80 	call	224a8 <usleep>
   2d580:	e0bffb17 	ldw	r2,-20(fp)
   2d584:	10bfffc4 	addi	r2,r2,-1
   2d588:	e0bffb15 	stw	r2,-20(fp)
   2d58c:	e0bffd03 	ldbu	r2,-12(fp)
   2d590:	10803fcc 	andi	r2,r2,255
   2d594:	1080020c 	andi	r2,r2,8
   2d598:	1000021e 	bne	r2,zero,2d5a4 <alt_erase_block_amd+0x140>
   2d59c:	e0bffb17 	ldw	r2,-20(fp)
   2d5a0:	00bfee16 	blt	zero,r2,2d55c <alt_erase_block_amd+0xf8>
   2d5a4:	e0bffc17 	ldw	r2,-16(fp)
   2d5a8:	10803117 	ldw	r2,196(r2)
   2d5ac:	e0bffb15 	stw	r2,-20(fp)
   2d5b0:	00001506 	br	2d608 <alt_erase_block_amd+0x1a4>
   2d5b4:	e0bffc17 	ldw	r2,-16(fp)
   2d5b8:	10c00a17 	ldw	r3,40(r2)
   2d5bc:	e0bfff17 	ldw	r2,-4(fp)
   2d5c0:	1885883a 	add	r2,r3,r2
   2d5c4:	10800023 	ldbuio	r2,0(r2)
   2d5c8:	10803fcc 	andi	r2,r2,255
   2d5cc:	e0bffd05 	stb	r2,-12(fp)
   2d5d0:	e0bffd03 	ldbu	r2,-12(fp)
   2d5d4:	10803fcc 	andi	r2,r2,255
   2d5d8:	1080201c 	xori	r2,r2,128
   2d5dc:	10bfe004 	addi	r2,r2,-128
   2d5e0:	10000b16 	blt	r2,zero,2d610 <alt_erase_block_amd+0x1ac>
   2d5e4:	e0bffd03 	ldbu	r2,-12(fp)
   2d5e8:	10803fcc 	andi	r2,r2,255
   2d5ec:	1080080c 	andi	r2,r2,32
   2d5f0:	1000071e 	bne	r2,zero,2d610 <alt_erase_block_amd+0x1ac>
   2d5f4:	0100fa04 	movi	r4,1000
   2d5f8:	00224a80 	call	224a8 <usleep>
   2d5fc:	e0bffb17 	ldw	r2,-20(fp)
   2d600:	10bf0604 	addi	r2,r2,-1000
   2d604:	e0bffb15 	stw	r2,-20(fp)
   2d608:	e0bffb17 	ldw	r2,-20(fp)
   2d60c:	00bfe916 	blt	zero,r2,2d5b4 <alt_erase_block_amd+0x150>
   2d610:	e0bffb17 	ldw	r2,-20(fp)
   2d614:	00800316 	blt	zero,r2,2d624 <alt_erase_block_amd+0x1c0>
   2d618:	00bfe304 	movi	r2,-116
   2d61c:	e0bffa15 	stw	r2,-24(fp)
   2d620:	00000e06 	br	2d65c <alt_erase_block_amd+0x1f8>
   2d624:	e0bffc17 	ldw	r2,-16(fp)
   2d628:	10c00a17 	ldw	r3,40(r2)
   2d62c:	e0bfff17 	ldw	r2,-4(fp)
   2d630:	1885883a 	add	r2,r3,r2
   2d634:	10800023 	ldbuio	r2,0(r2)
   2d638:	10803fcc 	andi	r2,r2,255
   2d63c:	e0bffd05 	stb	r2,-12(fp)
   2d640:	e0bffd03 	ldbu	r2,-12(fp)
   2d644:	10803fcc 	andi	r2,r2,255
   2d648:	1080201c 	xori	r2,r2,128
   2d64c:	10bfe004 	addi	r2,r2,-128
   2d650:	10000216 	blt	r2,zero,2d65c <alt_erase_block_amd+0x1f8>
   2d654:	00bffec4 	movi	r2,-5
   2d658:	e0bffa15 	stw	r2,-24(fp)
   2d65c:	e0bffa17 	ldw	r2,-24(fp)
   2d660:	e037883a 	mov	sp,fp
   2d664:	dfc00117 	ldw	ra,4(sp)
   2d668:	df000017 	ldw	fp,0(sp)
   2d66c:	dec00204 	addi	sp,sp,8
   2d670:	f800283a 	ret

0002d674 <alt_wait_for_command_to_complete_amd>:
   2d674:	defff804 	addi	sp,sp,-32
   2d678:	dfc00715 	stw	ra,28(sp)
   2d67c:	df000615 	stw	fp,24(sp)
   2d680:	df000604 	addi	fp,sp,24
   2d684:	e13ffd15 	stw	r4,-12(fp)
   2d688:	e17ffe15 	stw	r5,-8(fp)
   2d68c:	3005883a 	mov	r2,r6
   2d690:	e0bfff05 	stb	r2,-4(fp)
   2d694:	e0bffd17 	ldw	r2,-12(fp)
   2d698:	10803017 	ldw	r2,192(r2)
   2d69c:	10801924 	muli	r2,r2,100
   2d6a0:	e0bffa15 	stw	r2,-24(fp)
   2d6a4:	e03ffb15 	stw	zero,-20(fp)
   2d6a8:	e0bffd17 	ldw	r2,-12(fp)
   2d6ac:	10c00a17 	ldw	r3,40(r2)
   2d6b0:	e0bffe17 	ldw	r2,-8(fp)
   2d6b4:	1885883a 	add	r2,r3,r2
   2d6b8:	10800023 	ldbuio	r2,0(r2)
   2d6bc:	10803fcc 	andi	r2,r2,255
   2d6c0:	e0bffc05 	stb	r2,-16(fp)
   2d6c4:	00001606 	br	2d720 <alt_wait_for_command_to_complete_amd+0xac>
   2d6c8:	e0bffc03 	ldbu	r2,-16(fp)
   2d6cc:	10c03fcc 	andi	r3,r2,255
   2d6d0:	e0bfff03 	ldbu	r2,-4(fp)
   2d6d4:	1884f03a 	xor	r2,r3,r2
   2d6d8:	1080200c 	andi	r2,r2,128
   2d6dc:	10001226 	beq	r2,zero,2d728 <alt_wait_for_command_to_complete_amd+0xb4>
   2d6e0:	e0bffc03 	ldbu	r2,-16(fp)
   2d6e4:	10803fcc 	andi	r2,r2,255
   2d6e8:	1080080c 	andi	r2,r2,32
   2d6ec:	10000e1e 	bne	r2,zero,2d728 <alt_wait_for_command_to_complete_amd+0xb4>
   2d6f0:	01000044 	movi	r4,1
   2d6f4:	00224a80 	call	224a8 <usleep>
   2d6f8:	e0bffa17 	ldw	r2,-24(fp)
   2d6fc:	10bfffc4 	addi	r2,r2,-1
   2d700:	e0bffa15 	stw	r2,-24(fp)
   2d704:	e0bffd17 	ldw	r2,-12(fp)
   2d708:	10c00a17 	ldw	r3,40(r2)
   2d70c:	e0bffe17 	ldw	r2,-8(fp)
   2d710:	1885883a 	add	r2,r3,r2
   2d714:	10800023 	ldbuio	r2,0(r2)
   2d718:	10803fcc 	andi	r2,r2,255
   2d71c:	e0bffc05 	stb	r2,-16(fp)
   2d720:	e0bffa17 	ldw	r2,-24(fp)
   2d724:	00bfe816 	blt	zero,r2,2d6c8 <alt_wait_for_command_to_complete_amd+0x54>
   2d728:	e0bffa17 	ldw	r2,-24(fp)
   2d72c:	1000031e 	bne	r2,zero,2d73c <alt_wait_for_command_to_complete_amd+0xc8>
   2d730:	00bfe304 	movi	r2,-116
   2d734:	e0bffb15 	stw	r2,-20(fp)
   2d738:	00000f06 	br	2d778 <alt_wait_for_command_to_complete_amd+0x104>
   2d73c:	e0bffd17 	ldw	r2,-12(fp)
   2d740:	10c00a17 	ldw	r3,40(r2)
   2d744:	e0bffe17 	ldw	r2,-8(fp)
   2d748:	1885883a 	add	r2,r3,r2
   2d74c:	10800023 	ldbuio	r2,0(r2)
   2d750:	10803fcc 	andi	r2,r2,255
   2d754:	e0bffc05 	stb	r2,-16(fp)
   2d758:	e0bffc03 	ldbu	r2,-16(fp)
   2d75c:	10c03fcc 	andi	r3,r2,255
   2d760:	e0bfff03 	ldbu	r2,-4(fp)
   2d764:	1884f03a 	xor	r2,r3,r2
   2d768:	1080200c 	andi	r2,r2,128
   2d76c:	10000226 	beq	r2,zero,2d778 <alt_wait_for_command_to_complete_amd+0x104>
   2d770:	00bffec4 	movi	r2,-5
   2d774:	e0bffb15 	stw	r2,-20(fp)
   2d778:	e0bffb17 	ldw	r2,-20(fp)
   2d77c:	e037883a 	mov	sp,fp
   2d780:	dfc00117 	ldw	ra,4(sp)
   2d784:	df000017 	ldw	fp,0(sp)
   2d788:	dec00204 	addi	sp,sp,8
   2d78c:	f800283a 	ret

0002d790 <alt_write_word_amd>:
   2d790:	defff904 	addi	sp,sp,-28
   2d794:	dfc00615 	stw	ra,24(sp)
   2d798:	df000515 	stw	fp,20(sp)
   2d79c:	df000504 	addi	fp,sp,20
   2d7a0:	e13ffd15 	stw	r4,-12(fp)
   2d7a4:	e17ffe15 	stw	r5,-8(fp)
   2d7a8:	e1bfff15 	stw	r6,-4(fp)
   2d7ac:	e03ffb15 	stw	zero,-20(fp)
   2d7b0:	e0bffd17 	ldw	r2,-12(fp)
   2d7b4:	10c03317 	ldw	r3,204(r2)
   2d7b8:	e0bffd17 	ldw	r2,-12(fp)
   2d7bc:	10800a17 	ldw	r2,40(r2)
   2d7c0:	1009883a 	mov	r4,r2
   2d7c4:	01415544 	movi	r5,1365
   2d7c8:	01802a84 	movi	r6,170
   2d7cc:	183ee83a 	callr	r3
   2d7d0:	e0bffd17 	ldw	r2,-12(fp)
   2d7d4:	10c03317 	ldw	r3,204(r2)
   2d7d8:	e0bffd17 	ldw	r2,-12(fp)
   2d7dc:	10800a17 	ldw	r2,40(r2)
   2d7e0:	1009883a 	mov	r4,r2
   2d7e4:	0140aa84 	movi	r5,682
   2d7e8:	01801544 	movi	r6,85
   2d7ec:	183ee83a 	callr	r3
   2d7f0:	e0bffd17 	ldw	r2,-12(fp)
   2d7f4:	10c03317 	ldw	r3,204(r2)
   2d7f8:	e0bffd17 	ldw	r2,-12(fp)
   2d7fc:	10800a17 	ldw	r2,40(r2)
   2d800:	1009883a 	mov	r4,r2
   2d804:	01415544 	movi	r5,1365
   2d808:	01802804 	movi	r6,160
   2d80c:	183ee83a 	callr	r3
   2d810:	e0bfff17 	ldw	r2,-4(fp)
   2d814:	10800003 	ldbu	r2,0(r2)
   2d818:	e0bffc05 	stb	r2,-16(fp)
   2d81c:	e13ffd17 	ldw	r4,-12(fp)
   2d820:	e17ffe17 	ldw	r5,-8(fp)
   2d824:	e1bfff17 	ldw	r6,-4(fp)
   2d828:	0022c280 	call	22c28 <alt_write_value_to_flash>
   2d82c:	e0bffc03 	ldbu	r2,-16(fp)
   2d830:	e13ffd17 	ldw	r4,-12(fp)
   2d834:	e17ffe17 	ldw	r5,-8(fp)
   2d838:	100d883a 	mov	r6,r2
   2d83c:	002d6740 	call	2d674 <alt_wait_for_command_to_complete_amd>
   2d840:	e0bffb15 	stw	r2,-20(fp)
   2d844:	e0bffb17 	ldw	r2,-20(fp)
   2d848:	e037883a 	mov	sp,fp
   2d84c:	dfc00117 	ldw	ra,4(sp)
   2d850:	df000017 	ldw	fp,0(sp)
   2d854:	dec00204 	addi	sp,sp,8
   2d858:	f800283a 	ret

0002d85c <alt_program_intel>:
   2d85c:	defff704 	addi	sp,sp,-36
   2d860:	dfc00815 	stw	ra,32(sp)
   2d864:	df000715 	stw	fp,28(sp)
   2d868:	df000704 	addi	fp,sp,28
   2d86c:	e13ffc15 	stw	r4,-16(fp)
   2d870:	e17ffd15 	stw	r5,-12(fp)
   2d874:	e1bffe15 	stw	r6,-8(fp)
   2d878:	e1ffff15 	stw	r7,-4(fp)
   2d87c:	e03ffa15 	stw	zero,-24(fp)
   2d880:	e0bffc17 	ldw	r2,-16(fp)
   2d884:	e0bffb15 	stw	r2,-20(fp)
   2d888:	e13ffb17 	ldw	r4,-20(fp)
   2d88c:	e17ffd17 	ldw	r5,-12(fp)
   2d890:	002da440 	call	2da44 <alt_unlock_block_intel>
   2d894:	e0bffa15 	stw	r2,-24(fp)
   2d898:	e0bffa17 	ldw	r2,-24(fp)
   2d89c:	1000091e 	bne	r2,zero,2d8c4 <alt_program_intel+0x68>
   2d8a0:	008000f4 	movhi	r2,3
   2d8a4:	10b6f004 	addi	r2,r2,-9280
   2d8a8:	d8800015 	stw	r2,0(sp)
   2d8ac:	e13ffb17 	ldw	r4,-20(fp)
   2d8b0:	e17ffe17 	ldw	r5,-8(fp)
   2d8b4:	e1bfff17 	ldw	r6,-4(fp)
   2d8b8:	e1c00217 	ldw	r7,8(fp)
   2d8bc:	0022d800 	call	22d80 <alt_flash_program_block>
   2d8c0:	e0bffa15 	stw	r2,-24(fp)
   2d8c4:	e0bffa17 	ldw	r2,-24(fp)
   2d8c8:	e037883a 	mov	sp,fp
   2d8cc:	dfc00117 	ldw	ra,4(sp)
   2d8d0:	df000017 	ldw	fp,0(sp)
   2d8d4:	dec00204 	addi	sp,sp,8
   2d8d8:	f800283a 	ret

0002d8dc <alt_erase_block_intel>:
   2d8dc:	defff804 	addi	sp,sp,-32
   2d8e0:	dfc00715 	stw	ra,28(sp)
   2d8e4:	df000615 	stw	fp,24(sp)
   2d8e8:	df000604 	addi	fp,sp,24
   2d8ec:	e13ffe15 	stw	r4,-8(fp)
   2d8f0:	e17fff15 	stw	r5,-4(fp)
   2d8f4:	e03ffa15 	stw	zero,-24(fp)
   2d8f8:	e0bffe17 	ldw	r2,-8(fp)
   2d8fc:	e0bffc15 	stw	r2,-16(fp)
   2d900:	e0bffc17 	ldw	r2,-16(fp)
   2d904:	10803117 	ldw	r2,196(r2)
   2d908:	e0bffb15 	stw	r2,-20(fp)
   2d90c:	e13ffc17 	ldw	r4,-16(fp)
   2d910:	e17fff17 	ldw	r5,-4(fp)
   2d914:	002da440 	call	2da44 <alt_unlock_block_intel>
   2d918:	e0bffa15 	stw	r2,-24(fp)
   2d91c:	e0bffa17 	ldw	r2,-24(fp)
   2d920:	1000421e 	bne	r2,zero,2da2c <alt_erase_block_intel+0x150>
   2d924:	e0bffc17 	ldw	r2,-16(fp)
   2d928:	10c03517 	ldw	r3,212(r2)
   2d92c:	e0bffc17 	ldw	r2,-16(fp)
   2d930:	11000a17 	ldw	r4,40(r2)
   2d934:	e0bfff17 	ldw	r2,-4(fp)
   2d938:	2085883a 	add	r2,r4,r2
   2d93c:	1009883a 	mov	r4,r2
   2d940:	01400804 	movi	r5,32
   2d944:	183ee83a 	callr	r3
   2d948:	e0bffc17 	ldw	r2,-16(fp)
   2d94c:	10c03517 	ldw	r3,212(r2)
   2d950:	e0bffc17 	ldw	r2,-16(fp)
   2d954:	11000a17 	ldw	r4,40(r2)
   2d958:	e0bfff17 	ldw	r2,-4(fp)
   2d95c:	2085883a 	add	r2,r4,r2
   2d960:	1009883a 	mov	r4,r2
   2d964:	01403404 	movi	r5,208
   2d968:	183ee83a 	callr	r3
   2d96c:	e0bffc17 	ldw	r2,-16(fp)
   2d970:	10c00a17 	ldw	r3,40(r2)
   2d974:	e0bfff17 	ldw	r2,-4(fp)
   2d978:	1885883a 	add	r2,r3,r2
   2d97c:	10800023 	ldbuio	r2,0(r2)
   2d980:	10803fcc 	andi	r2,r2,255
   2d984:	e0bffd05 	stb	r2,-12(fp)
   2d988:	e0bffd03 	ldbu	r2,-12(fp)
   2d98c:	10803fcc 	andi	r2,r2,255
   2d990:	1080201c 	xori	r2,r2,128
   2d994:	10bfe004 	addi	r2,r2,-128
   2d998:	10000816 	blt	r2,zero,2d9bc <alt_erase_block_intel+0xe0>
   2d99c:	0100fa04 	movi	r4,1000
   2d9a0:	00224a80 	call	224a8 <usleep>
   2d9a4:	e0bffb17 	ldw	r2,-20(fp)
   2d9a8:	10bf0604 	addi	r2,r2,-1000
   2d9ac:	e0bffb15 	stw	r2,-20(fp)
   2d9b0:	e0bffb17 	ldw	r2,-20(fp)
   2d9b4:	00bfed16 	blt	zero,r2,2d96c <alt_erase_block_intel+0x90>
   2d9b8:	00000106 	br	2d9c0 <alt_erase_block_intel+0xe4>
   2d9bc:	0001883a 	nop
   2d9c0:	e0bffb17 	ldw	r2,-20(fp)
   2d9c4:	00800316 	blt	zero,r2,2d9d4 <alt_erase_block_intel+0xf8>
   2d9c8:	00bfe304 	movi	r2,-116
   2d9cc:	e0bffa15 	stw	r2,-24(fp)
   2d9d0:	00000d06 	br	2da08 <alt_erase_block_intel+0x12c>
   2d9d4:	e0bffd03 	ldbu	r2,-12(fp)
   2d9d8:	10803fcc 	andi	r2,r2,255
   2d9dc:	10801fcc 	andi	r2,r2,127
   2d9e0:	10000926 	beq	r2,zero,2da08 <alt_erase_block_intel+0x12c>
   2d9e4:	00bffec4 	movi	r2,-5
   2d9e8:	e0bffa15 	stw	r2,-24(fp)
   2d9ec:	e0bffc17 	ldw	r2,-16(fp)
   2d9f0:	10c00a17 	ldw	r3,40(r2)
   2d9f4:	e0bfff17 	ldw	r2,-4(fp)
   2d9f8:	1885883a 	add	r2,r3,r2
   2d9fc:	10800023 	ldbuio	r2,0(r2)
   2da00:	10803fcc 	andi	r2,r2,255
   2da04:	e0bffd05 	stb	r2,-12(fp)
   2da08:	e0bffc17 	ldw	r2,-16(fp)
   2da0c:	10c03517 	ldw	r3,212(r2)
   2da10:	e0bffc17 	ldw	r2,-16(fp)
   2da14:	11000a17 	ldw	r4,40(r2)
   2da18:	e0bfff17 	ldw	r2,-4(fp)
   2da1c:	2085883a 	add	r2,r4,r2
   2da20:	1009883a 	mov	r4,r2
   2da24:	01403fc4 	movi	r5,255
   2da28:	183ee83a 	callr	r3
   2da2c:	e0bffa17 	ldw	r2,-24(fp)
   2da30:	e037883a 	mov	sp,fp
   2da34:	dfc00117 	ldw	ra,4(sp)
   2da38:	df000017 	ldw	fp,0(sp)
   2da3c:	dec00204 	addi	sp,sp,8
   2da40:	f800283a 	ret

0002da44 <alt_unlock_block_intel>:
   2da44:	defff904 	addi	sp,sp,-28
   2da48:	dfc00615 	stw	ra,24(sp)
   2da4c:	df000515 	stw	fp,20(sp)
   2da50:	df000504 	addi	fp,sp,20
   2da54:	e13ffe15 	stw	r4,-8(fp)
   2da58:	e17fff15 	stw	r5,-4(fp)
   2da5c:	e03ffb15 	stw	zero,-20(fp)
   2da60:	e0bffe17 	ldw	r2,-8(fp)
   2da64:	10803017 	ldw	r2,192(r2)
   2da68:	10801924 	muli	r2,r2,100
   2da6c:	e0bffc15 	stw	r2,-16(fp)
   2da70:	e0bffe17 	ldw	r2,-8(fp)
   2da74:	10c03517 	ldw	r3,212(r2)
   2da78:	e0bffe17 	ldw	r2,-8(fp)
   2da7c:	11000a17 	ldw	r4,40(r2)
   2da80:	e0bfff17 	ldw	r2,-4(fp)
   2da84:	2085883a 	add	r2,r4,r2
   2da88:	1009883a 	mov	r4,r2
   2da8c:	01402404 	movi	r5,144
   2da90:	183ee83a 	callr	r3
   2da94:	e0bffe17 	ldw	r2,-8(fp)
   2da98:	10c00a17 	ldw	r3,40(r2)
   2da9c:	e0bfff17 	ldw	r2,-4(fp)
   2daa0:	10800104 	addi	r2,r2,4
   2daa4:	1885883a 	add	r2,r3,r2
   2daa8:	10800023 	ldbuio	r2,0(r2)
   2daac:	10803fcc 	andi	r2,r2,255
   2dab0:	e0bffd05 	stb	r2,-12(fp)
   2dab4:	e0bffd03 	ldbu	r2,-12(fp)
   2dab8:	1080004c 	andi	r2,r2,1
   2dabc:	10003126 	beq	r2,zero,2db84 <alt_unlock_block_intel+0x140>
   2dac0:	e0bffe17 	ldw	r2,-8(fp)
   2dac4:	10c03517 	ldw	r3,212(r2)
   2dac8:	e0bffe17 	ldw	r2,-8(fp)
   2dacc:	11000a17 	ldw	r4,40(r2)
   2dad0:	e0bfff17 	ldw	r2,-4(fp)
   2dad4:	2085883a 	add	r2,r4,r2
   2dad8:	1009883a 	mov	r4,r2
   2dadc:	01401804 	movi	r5,96
   2dae0:	183ee83a 	callr	r3
   2dae4:	e0bffe17 	ldw	r2,-8(fp)
   2dae8:	10c03517 	ldw	r3,212(r2)
   2daec:	e0bffe17 	ldw	r2,-8(fp)
   2daf0:	11000a17 	ldw	r4,40(r2)
   2daf4:	e0bfff17 	ldw	r2,-4(fp)
   2daf8:	2085883a 	add	r2,r4,r2
   2dafc:	1009883a 	mov	r4,r2
   2db00:	01403404 	movi	r5,208
   2db04:	183ee83a 	callr	r3
   2db08:	e0bffe17 	ldw	r2,-8(fp)
   2db0c:	10c00a17 	ldw	r3,40(r2)
   2db10:	e0bfff17 	ldw	r2,-4(fp)
   2db14:	1885883a 	add	r2,r3,r2
   2db18:	10800023 	ldbuio	r2,0(r2)
   2db1c:	10803fcc 	andi	r2,r2,255
   2db20:	e0bffd45 	stb	r2,-11(fp)
   2db24:	e0bffd43 	ldbu	r2,-11(fp)
   2db28:	10803fcc 	andi	r2,r2,255
   2db2c:	1080201c 	xori	r2,r2,128
   2db30:	10bfe004 	addi	r2,r2,-128
   2db34:	10000816 	blt	r2,zero,2db58 <alt_unlock_block_intel+0x114>
   2db38:	e0bffc17 	ldw	r2,-16(fp)
   2db3c:	10bfffc4 	addi	r2,r2,-1
   2db40:	e0bffc15 	stw	r2,-16(fp)
   2db44:	01000044 	movi	r4,1
   2db48:	00224a80 	call	224a8 <usleep>
   2db4c:	e0bffc17 	ldw	r2,-16(fp)
   2db50:	00bfed16 	blt	zero,r2,2db08 <alt_unlock_block_intel+0xc4>
   2db54:	00000106 	br	2db5c <alt_unlock_block_intel+0x118>
   2db58:	0001883a 	nop
   2db5c:	e0bffc17 	ldw	r2,-16(fp)
   2db60:	1000031e 	bne	r2,zero,2db70 <alt_unlock_block_intel+0x12c>
   2db64:	00bfe304 	movi	r2,-116
   2db68:	e0bffb15 	stw	r2,-20(fp)
   2db6c:	00000506 	br	2db84 <alt_unlock_block_intel+0x140>
   2db70:	e0bffd43 	ldbu	r2,-11(fp)
   2db74:	10801fcc 	andi	r2,r2,127
   2db78:	10000226 	beq	r2,zero,2db84 <alt_unlock_block_intel+0x140>
   2db7c:	00bffec4 	movi	r2,-5
   2db80:	e0bffb15 	stw	r2,-20(fp)
   2db84:	e0bffe17 	ldw	r2,-8(fp)
   2db88:	10c03517 	ldw	r3,212(r2)
   2db8c:	e0bffe17 	ldw	r2,-8(fp)
   2db90:	11000a17 	ldw	r4,40(r2)
   2db94:	e0bfff17 	ldw	r2,-4(fp)
   2db98:	2085883a 	add	r2,r4,r2
   2db9c:	1009883a 	mov	r4,r2
   2dba0:	01403fc4 	movi	r5,255
   2dba4:	183ee83a 	callr	r3
   2dba8:	e0bffb17 	ldw	r2,-20(fp)
   2dbac:	e037883a 	mov	sp,fp
   2dbb0:	dfc00117 	ldw	ra,4(sp)
   2dbb4:	df000017 	ldw	fp,0(sp)
   2dbb8:	dec00204 	addi	sp,sp,8
   2dbbc:	f800283a 	ret

0002dbc0 <alt_write_word_intel>:
   2dbc0:	defff904 	addi	sp,sp,-28
   2dbc4:	dfc00615 	stw	ra,24(sp)
   2dbc8:	df000515 	stw	fp,20(sp)
   2dbcc:	df000504 	addi	fp,sp,20
   2dbd0:	e13ffd15 	stw	r4,-12(fp)
   2dbd4:	e17ffe15 	stw	r5,-8(fp)
   2dbd8:	e1bfff15 	stw	r6,-4(fp)
   2dbdc:	e03ffb15 	stw	zero,-20(fp)
   2dbe0:	e0bffd17 	ldw	r2,-12(fp)
   2dbe4:	10c03517 	ldw	r3,212(r2)
   2dbe8:	e0bffd17 	ldw	r2,-12(fp)
   2dbec:	11000a17 	ldw	r4,40(r2)
   2dbf0:	e0bffe17 	ldw	r2,-8(fp)
   2dbf4:	2085883a 	add	r2,r4,r2
   2dbf8:	1009883a 	mov	r4,r2
   2dbfc:	01401004 	movi	r5,64
   2dc00:	183ee83a 	callr	r3
   2dc04:	e13ffd17 	ldw	r4,-12(fp)
   2dc08:	e17ffe17 	ldw	r5,-8(fp)
   2dc0c:	e1bfff17 	ldw	r6,-4(fp)
   2dc10:	0022c280 	call	22c28 <alt_write_value_to_flash>
   2dc14:	e0bffd17 	ldw	r2,-12(fp)
   2dc18:	10c00a17 	ldw	r3,40(r2)
   2dc1c:	e0bffe17 	ldw	r2,-8(fp)
   2dc20:	1885883a 	add	r2,r3,r2
   2dc24:	10800023 	ldbuio	r2,0(r2)
   2dc28:	10803fcc 	andi	r2,r2,255
   2dc2c:	e0bffc05 	stb	r2,-16(fp)
   2dc30:	e0bffc03 	ldbu	r2,-16(fp)
   2dc34:	10803fcc 	andi	r2,r2,255
   2dc38:	1080201c 	xori	r2,r2,128
   2dc3c:	10bfe004 	addi	r2,r2,-128
   2dc40:	103ff40e 	bge	r2,zero,2dc14 <alt_write_word_intel+0x54>
   2dc44:	e0bffc03 	ldbu	r2,-16(fp)
   2dc48:	10801fcc 	andi	r2,r2,127
   2dc4c:	10000226 	beq	r2,zero,2dc58 <alt_write_word_intel+0x98>
   2dc50:	00bffec4 	movi	r2,-5
   2dc54:	e0bffb15 	stw	r2,-20(fp)
   2dc58:	e0bffd17 	ldw	r2,-12(fp)
   2dc5c:	10c03517 	ldw	r3,212(r2)
   2dc60:	e0bffd17 	ldw	r2,-12(fp)
   2dc64:	11000a17 	ldw	r4,40(r2)
   2dc68:	e0bffe17 	ldw	r2,-8(fp)
   2dc6c:	2085883a 	add	r2,r4,r2
   2dc70:	1009883a 	mov	r4,r2
   2dc74:	01403fc4 	movi	r5,255
   2dc78:	183ee83a 	callr	r3
   2dc7c:	e0bffb17 	ldw	r2,-20(fp)
   2dc80:	e037883a 	mov	sp,fp
   2dc84:	dfc00117 	ldw	ra,4(sp)
   2dc88:	df000017 	ldw	fp,0(sp)
   2dc8c:	dec00204 	addi	sp,sp,8
   2dc90:	f800283a 	ret

0002dc94 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
   2dc94:	defffb04 	addi	sp,sp,-20
   2dc98:	dfc00415 	stw	ra,16(sp)
   2dc9c:	df000315 	stw	fp,12(sp)
   2dca0:	df000304 	addi	fp,sp,12
   2dca4:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
   2dca8:	008000f4 	movhi	r2,3
   2dcac:	10958304 	addi	r2,r2,22028
   2dcb0:	10800017 	ldw	r2,0(r2)
   2dcb4:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
   2dcb8:	00003106 	br	2dd80 <alt_find_file+0xec>
  {
    len = strlen(next->name);
   2dcbc:	e0bffd17 	ldw	r2,-12(fp)
   2dcc0:	10800217 	ldw	r2,8(r2)
   2dcc4:	1009883a 	mov	r4,r2
   2dcc8:	00197140 	call	19714 <strlen>
   2dccc:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
   2dcd0:	e0bffd17 	ldw	r2,-12(fp)
   2dcd4:	10c00217 	ldw	r3,8(r2)
   2dcd8:	e0bffe17 	ldw	r2,-8(fp)
   2dcdc:	10bfffc4 	addi	r2,r2,-1
   2dce0:	1885883a 	add	r2,r3,r2
   2dce4:	10800003 	ldbu	r2,0(r2)
   2dce8:	10803fcc 	andi	r2,r2,255
   2dcec:	1080201c 	xori	r2,r2,128
   2dcf0:	10bfe004 	addi	r2,r2,-128
   2dcf4:	10800bd8 	cmpnei	r2,r2,47
   2dcf8:	1000031e 	bne	r2,zero,2dd08 <alt_find_file+0x74>
    {
      len -= 1;
   2dcfc:	e0bffe17 	ldw	r2,-8(fp)
   2dd00:	10bfffc4 	addi	r2,r2,-1
   2dd04:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
   2dd08:	e0bffe17 	ldw	r2,-8(fp)
   2dd0c:	e0ffff17 	ldw	r3,-4(fp)
   2dd10:	1885883a 	add	r2,r3,r2
   2dd14:	10800003 	ldbu	r2,0(r2)
   2dd18:	10803fcc 	andi	r2,r2,255
   2dd1c:	1080201c 	xori	r2,r2,128
   2dd20:	10bfe004 	addi	r2,r2,-128
   2dd24:	10800be0 	cmpeqi	r2,r2,47
   2dd28:	1000081e 	bne	r2,zero,2dd4c <alt_find_file+0xb8>
   2dd2c:	e0bffe17 	ldw	r2,-8(fp)
   2dd30:	e0ffff17 	ldw	r3,-4(fp)
   2dd34:	1885883a 	add	r2,r3,r2
   2dd38:	10800003 	ldbu	r2,0(r2)
   2dd3c:	10803fcc 	andi	r2,r2,255
   2dd40:	1080201c 	xori	r2,r2,128
   2dd44:	10bfe004 	addi	r2,r2,-128
   2dd48:	10000a1e 	bne	r2,zero,2dd74 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
   2dd4c:	e0bffd17 	ldw	r2,-12(fp)
   2dd50:	10c00217 	ldw	r3,8(r2)
   2dd54:	e0bffe17 	ldw	r2,-8(fp)
   2dd58:	1809883a 	mov	r4,r3
   2dd5c:	e17fff17 	ldw	r5,-4(fp)
   2dd60:	100d883a 	mov	r6,r2
   2dd64:	00191740 	call	19174 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
   2dd68:	1000021e 	bne	r2,zero,2dd74 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
   2dd6c:	e0bffd17 	ldw	r2,-12(fp)
   2dd70:	00000806 	br	2dd94 <alt_find_file+0x100>
    }
    next = (alt_dev*) next->llist.next;
   2dd74:	e0bffd17 	ldw	r2,-12(fp)
   2dd78:	10800017 	ldw	r2,0(r2)
   2dd7c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
   2dd80:	e0fffd17 	ldw	r3,-12(fp)
   2dd84:	008000f4 	movhi	r2,3
   2dd88:	10958304 	addi	r2,r2,22028
   2dd8c:	18bfcb1e 	bne	r3,r2,2dcbc <alt_find_file+0x28>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
   2dd90:	0005883a 	mov	r2,zero
}
   2dd94:	e037883a 	mov	sp,fp
   2dd98:	dfc00117 	ldw	ra,4(sp)
   2dd9c:	df000017 	ldw	fp,0(sp)
   2dda0:	dec00204 	addi	sp,sp,8
   2dda4:	f800283a 	ret

0002dda8 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
   2dda8:	defffc04 	addi	sp,sp,-16
   2ddac:	df000315 	stw	fp,12(sp)
   2ddb0:	df000304 	addi	fp,sp,12
   2ddb4:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
   2ddb8:	00bffa04 	movi	r2,-24
   2ddbc:	e0bffe15 	stw	r2,-8(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
   2ddc0:	e03ffd15 	stw	zero,-12(fp)
   2ddc4:	00001d06 	br	2de3c <alt_get_fd+0x94>
  {
    if (!alt_fd_list[i].dev)
   2ddc8:	00c000f4 	movhi	r3,3
   2ddcc:	18cfaa04 	addi	r3,r3,16040
   2ddd0:	e0bffd17 	ldw	r2,-12(fp)
   2ddd4:	10800324 	muli	r2,r2,12
   2ddd8:	1885883a 	add	r2,r3,r2
   2dddc:	10800017 	ldw	r2,0(r2)
   2dde0:	1000131e 	bne	r2,zero,2de30 <alt_get_fd+0x88>
    {
      alt_fd_list[i].dev = dev;
   2dde4:	00c000f4 	movhi	r3,3
   2dde8:	18cfaa04 	addi	r3,r3,16040
   2ddec:	e0bffd17 	ldw	r2,-12(fp)
   2ddf0:	10800324 	muli	r2,r2,12
   2ddf4:	1885883a 	add	r2,r3,r2
   2ddf8:	e0ffff17 	ldw	r3,-4(fp)
   2ddfc:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
   2de00:	008000f4 	movhi	r2,3
   2de04:	10958704 	addi	r2,r2,22044
   2de08:	10c00017 	ldw	r3,0(r2)
   2de0c:	e0bffd17 	ldw	r2,-12(fp)
   2de10:	1880040e 	bge	r3,r2,2de24 <alt_get_fd+0x7c>
      {
        alt_max_fd = i;
   2de14:	008000f4 	movhi	r2,3
   2de18:	10958704 	addi	r2,r2,22044
   2de1c:	e0fffd17 	ldw	r3,-12(fp)
   2de20:	10c00015 	stw	r3,0(r2)
      }
      rc = i;
   2de24:	e0bffd17 	ldw	r2,-12(fp)
   2de28:	e0bffe15 	stw	r2,-8(fp)
      goto alt_get_fd_exit;
   2de2c:	00000606 	br	2de48 <alt_get_fd+0xa0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
   2de30:	e0bffd17 	ldw	r2,-12(fp)
   2de34:	10800044 	addi	r2,r2,1
   2de38:	e0bffd15 	stw	r2,-12(fp)
   2de3c:	e0bffd17 	ldw	r2,-12(fp)
   2de40:	10800810 	cmplti	r2,r2,32
   2de44:	103fe01e 	bne	r2,zero,2ddc8 <alt_get_fd+0x20>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
   2de48:	e0bffe17 	ldw	r2,-8(fp)
}
   2de4c:	e037883a 	mov	sp,fp
   2de50:	df000017 	ldw	fp,0(sp)
   2de54:	dec00104 	addi	sp,sp,4
   2de58:	f800283a 	ret

0002de5c <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
   2de5c:	defffb04 	addi	sp,sp,-20
   2de60:	df000415 	stw	fp,16(sp)
   2de64:	df000404 	addi	fp,sp,16
   2de68:	e13ffe15 	stw	r4,-8(fp)
   2de6c:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
   2de70:	e0bfff17 	ldw	r2,-4(fp)
   2de74:	10840070 	cmpltui	r2,r2,4097
   2de78:	1000021e 	bne	r2,zero,2de84 <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
   2de7c:	00840004 	movi	r2,4096
   2de80:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
   2de84:	e0fffe17 	ldw	r3,-8(fp)
   2de88:	e0bfff17 	ldw	r2,-4(fp)
   2de8c:	1885883a 	add	r2,r3,r2
   2de90:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
   2de94:	e0bffe17 	ldw	r2,-8(fp)
   2de98:	e0bffc15 	stw	r2,-16(fp)
   2de9c:	00000506 	br	2deb4 <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
   2dea0:	e0bffc17 	ldw	r2,-16(fp)
   2dea4:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
   2dea8:	e0bffc17 	ldw	r2,-16(fp)
   2deac:	10800804 	addi	r2,r2,32
   2deb0:	e0bffc15 	stw	r2,-16(fp)
   2deb4:	e0fffc17 	ldw	r3,-16(fp)
   2deb8:	e0bffd17 	ldw	r2,-12(fp)
   2debc:	18bff836 	bltu	r3,r2,2dea0 <alt_icache_flush+0x44>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
   2dec0:	e0bffe17 	ldw	r2,-8(fp)
   2dec4:	108007cc 	andi	r2,r2,31
   2dec8:	10000226 	beq	r2,zero,2ded4 <alt_icache_flush+0x78>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
   2decc:	e0bffc17 	ldw	r2,-16(fp)
   2ded0:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
   2ded4:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
   2ded8:	e037883a 	mov	sp,fp
   2dedc:	df000017 	ldw	fp,0(sp)
   2dee0:	dec00104 	addi	sp,sp,4
   2dee4:	f800283a 	ret

0002dee8 <atexit>:
   2dee8:	200b883a 	mov	r5,r4
   2deec:	000d883a 	mov	r6,zero
   2def0:	0009883a 	mov	r4,zero
   2def4:	000f883a 	mov	r7,zero
   2def8:	002dff01 	jmpi	2dff0 <__register_exitproc>

0002defc <exit>:
   2defc:	defffe04 	addi	sp,sp,-8
   2df00:	000b883a 	mov	r5,zero
   2df04:	dc000015 	stw	r16,0(sp)
   2df08:	dfc00115 	stw	ra,4(sp)
   2df0c:	2021883a 	mov	r16,r4
   2df10:	002e1200 	call	2e120 <__call_exitprocs>
   2df14:	008000f4 	movhi	r2,3
   2df18:	10957e04 	addi	r2,r2,22008
   2df1c:	11000017 	ldw	r4,0(r2)
   2df20:	20800f17 	ldw	r2,60(r4)
   2df24:	10000126 	beq	r2,zero,2df2c <exit+0x30>
   2df28:	103ee83a 	callr	r2
   2df2c:	8009883a 	mov	r4,r16
   2df30:	002e2c00 	call	2e2c0 <_exit>

0002df34 <malloc>:
   2df34:	008000f4 	movhi	r2,3
   2df38:	10957f04 	addi	r2,r2,22012
   2df3c:	200b883a 	mov	r5,r4
   2df40:	11000017 	ldw	r4,0(r2)
   2df44:	001e3a01 	jmpi	1e3a0 <_malloc_r>

0002df48 <free>:
   2df48:	008000f4 	movhi	r2,3
   2df4c:	10957f04 	addi	r2,r2,22012
   2df50:	200b883a 	mov	r5,r4
   2df54:	11000017 	ldw	r4,0(r2)
   2df58:	001d8081 	jmpi	1d808 <_free_r>

0002df5c <strcpy>:
   2df5c:	2906b03a 	or	r3,r5,r4
   2df60:	18c000cc 	andi	r3,r3,3
   2df64:	2005883a 	mov	r2,r4
   2df68:	18001a1e 	bne	r3,zero,2dfd4 <strcpy+0x78>
   2df6c:	29800017 	ldw	r6,0(r5)
   2df70:	02bfbff4 	movhi	r10,65279
   2df74:	52bfbfc4 	addi	r10,r10,-257
   2df78:	02602074 	movhi	r9,32897
   2df7c:	4a602004 	addi	r9,r9,-32640
   2df80:	0188303a 	nor	r4,zero,r6
   2df84:	3287883a 	add	r3,r6,r10
   2df88:	20c6703a 	and	r3,r4,r3
   2df8c:	1a46703a 	and	r3,r3,r9
   2df90:	1800101e 	bne	r3,zero,2dfd4 <strcpy+0x78>
   2df94:	1007883a 	mov	r3,r2
   2df98:	19800015 	stw	r6,0(r3)
   2df9c:	29400104 	addi	r5,r5,4
   2dfa0:	29800017 	ldw	r6,0(r5)
   2dfa4:	18c00104 	addi	r3,r3,4
   2dfa8:	0190303a 	nor	r8,zero,r6
   2dfac:	328f883a 	add	r7,r6,r10
   2dfb0:	41ce703a 	and	r7,r8,r7
   2dfb4:	3a4e703a 	and	r7,r7,r9
   2dfb8:	383ff726 	beq	r7,zero,2df98 <strcpy+0x3c>
   2dfbc:	29800007 	ldb	r6,0(r5)
   2dfc0:	18c00044 	addi	r3,r3,1
   2dfc4:	29400044 	addi	r5,r5,1
   2dfc8:	19bfffc5 	stb	r6,-1(r3)
   2dfcc:	3000021e 	bne	r6,zero,2dfd8 <strcpy+0x7c>
   2dfd0:	f800283a 	ret
   2dfd4:	1007883a 	mov	r3,r2
   2dfd8:	29800007 	ldb	r6,0(r5)
   2dfdc:	18c00044 	addi	r3,r3,1
   2dfe0:	29400044 	addi	r5,r5,1
   2dfe4:	19bfffc5 	stb	r6,-1(r3)
   2dfe8:	303ffb1e 	bne	r6,zero,2dfd8 <strcpy+0x7c>
   2dfec:	f800283a 	ret

0002dff0 <__register_exitproc>:
   2dff0:	defffa04 	addi	sp,sp,-24
   2dff4:	008000f4 	movhi	r2,3
   2dff8:	10957e04 	addi	r2,r2,22008
   2dffc:	dc000315 	stw	r16,12(sp)
   2e000:	14000017 	ldw	r16,0(r2)
   2e004:	dc400415 	stw	r17,16(sp)
   2e008:	dfc00515 	stw	ra,20(sp)
   2e00c:	80805217 	ldw	r2,328(r16)
   2e010:	2023883a 	mov	r17,r4
   2e014:	10003e26 	beq	r2,zero,2e110 <__register_exitproc+0x120>
   2e018:	10c00117 	ldw	r3,4(r2)
   2e01c:	020007c4 	movi	r8,31
   2e020:	40c0180e 	bge	r8,r3,2e084 <__register_exitproc+0x94>
   2e024:	008000f4 	movhi	r2,3
   2e028:	10b7cd04 	addi	r2,r2,-8396
   2e02c:	1000061e 	bne	r2,zero,2e048 <__register_exitproc+0x58>
   2e030:	00bfffc4 	movi	r2,-1
   2e034:	dfc00517 	ldw	ra,20(sp)
   2e038:	dc400417 	ldw	r17,16(sp)
   2e03c:	dc000317 	ldw	r16,12(sp)
   2e040:	dec00604 	addi	sp,sp,24
   2e044:	f800283a 	ret
   2e048:	01006404 	movi	r4,400
   2e04c:	d9400015 	stw	r5,0(sp)
   2e050:	d9800115 	stw	r6,4(sp)
   2e054:	d9c00215 	stw	r7,8(sp)
   2e058:	002df340 	call	2df34 <malloc>
   2e05c:	d9400017 	ldw	r5,0(sp)
   2e060:	d9800117 	ldw	r6,4(sp)
   2e064:	d9c00217 	ldw	r7,8(sp)
   2e068:	103ff126 	beq	r2,zero,2e030 <__register_exitproc+0x40>
   2e06c:	80c05217 	ldw	r3,328(r16)
   2e070:	10000115 	stw	zero,4(r2)
   2e074:	10c00015 	stw	r3,0(r2)
   2e078:	80805215 	stw	r2,328(r16)
   2e07c:	10006215 	stw	zero,392(r2)
   2e080:	10006315 	stw	zero,396(r2)
   2e084:	10c00117 	ldw	r3,4(r2)
   2e088:	88000d1e 	bne	r17,zero,2e0c0 <__register_exitproc+0xd0>
   2e08c:	19000084 	addi	r4,r3,2
   2e090:	2109883a 	add	r4,r4,r4
   2e094:	18c00044 	addi	r3,r3,1
   2e098:	2109883a 	add	r4,r4,r4
   2e09c:	1109883a 	add	r4,r2,r4
   2e0a0:	10c00115 	stw	r3,4(r2)
   2e0a4:	0005883a 	mov	r2,zero
   2e0a8:	21400015 	stw	r5,0(r4)
   2e0ac:	dfc00517 	ldw	ra,20(sp)
   2e0b0:	dc400417 	ldw	r17,16(sp)
   2e0b4:	dc000317 	ldw	r16,12(sp)
   2e0b8:	dec00604 	addi	sp,sp,24
   2e0bc:	f800283a 	ret
   2e0c0:	02400044 	movi	r9,1
   2e0c4:	12806217 	ldw	r10,392(r2)
   2e0c8:	48d2983a 	sll	r9,r9,r3
   2e0cc:	19000804 	addi	r4,r3,32
   2e0d0:	18d1883a 	add	r8,r3,r3
   2e0d4:	2109883a 	add	r4,r4,r4
   2e0d8:	4211883a 	add	r8,r8,r8
   2e0dc:	2109883a 	add	r4,r4,r4
   2e0e0:	1109883a 	add	r4,r2,r4
   2e0e4:	1211883a 	add	r8,r2,r8
   2e0e8:	5254b03a 	or	r10,r10,r9
   2e0ec:	21c02215 	stw	r7,136(r4)
   2e0f0:	41802215 	stw	r6,136(r8)
   2e0f4:	12806215 	stw	r10,392(r2)
   2e0f8:	01000084 	movi	r4,2
   2e0fc:	893fe31e 	bne	r17,r4,2e08c <__register_exitproc+0x9c>
   2e100:	11006317 	ldw	r4,396(r2)
   2e104:	2252b03a 	or	r9,r4,r9
   2e108:	12406315 	stw	r9,396(r2)
   2e10c:	003fdf06 	br	2e08c <__register_exitproc+0x9c>
   2e110:	00800234 	movhi	r2,8
   2e114:	10842204 	addi	r2,r2,4232
   2e118:	80805215 	stw	r2,328(r16)
   2e11c:	003fbe06 	br	2e018 <__register_exitproc+0x28>

0002e120 <__call_exitprocs>:
   2e120:	008000f4 	movhi	r2,3
   2e124:	10957e04 	addi	r2,r2,22008
   2e128:	10800017 	ldw	r2,0(r2)
   2e12c:	defff304 	addi	sp,sp,-52
   2e130:	df000b15 	stw	fp,44(sp)
   2e134:	d8800015 	stw	r2,0(sp)
   2e138:	10805204 	addi	r2,r2,328
   2e13c:	dd400815 	stw	r21,32(sp)
   2e140:	dfc00c15 	stw	ra,48(sp)
   2e144:	ddc00a15 	stw	r23,40(sp)
   2e148:	dd800915 	stw	r22,36(sp)
   2e14c:	dd000715 	stw	r20,28(sp)
   2e150:	dcc00615 	stw	r19,24(sp)
   2e154:	dc800515 	stw	r18,20(sp)
   2e158:	dc400415 	stw	r17,16(sp)
   2e15c:	dc000315 	stw	r16,12(sp)
   2e160:	d9000115 	stw	r4,4(sp)
   2e164:	2839883a 	mov	fp,r5
   2e168:	d8800215 	stw	r2,8(sp)
   2e16c:	057fffc4 	movi	r21,-1
   2e170:	d8800017 	ldw	r2,0(sp)
   2e174:	ddc00217 	ldw	r23,8(sp)
   2e178:	14805217 	ldw	r18,328(r2)
   2e17c:	90001726 	beq	r18,zero,2e1dc <__call_exitprocs+0xbc>
   2e180:	94400117 	ldw	r17,4(r18)
   2e184:	8c3fffc4 	addi	r16,r17,-1
   2e188:	80001116 	blt	r16,zero,2e1d0 <__call_exitprocs+0xb0>
   2e18c:	8c400044 	addi	r17,r17,1
   2e190:	8427883a 	add	r19,r16,r16
   2e194:	8c63883a 	add	r17,r17,r17
   2e198:	95802204 	addi	r22,r18,136
   2e19c:	9ce7883a 	add	r19,r19,r19
   2e1a0:	8c63883a 	add	r17,r17,r17
   2e1a4:	b4e7883a 	add	r19,r22,r19
   2e1a8:	9463883a 	add	r17,r18,r17
   2e1ac:	e0001726 	beq	fp,zero,2e20c <__call_exitprocs+0xec>
   2e1b0:	8c87c83a 	sub	r3,r17,r18
   2e1b4:	b0c7883a 	add	r3,r22,r3
   2e1b8:	18c01e17 	ldw	r3,120(r3)
   2e1bc:	1f001326 	beq	r3,fp,2e20c <__call_exitprocs+0xec>
   2e1c0:	843fffc4 	addi	r16,r16,-1
   2e1c4:	9cffff04 	addi	r19,r19,-4
   2e1c8:	8c7fff04 	addi	r17,r17,-4
   2e1cc:	857ff71e 	bne	r16,r21,2e1ac <__call_exitprocs+0x8c>
   2e1d0:	008000f4 	movhi	r2,3
   2e1d4:	10b7d204 	addi	r2,r2,-8376
   2e1d8:	10002a1e 	bne	r2,zero,2e284 <__call_exitprocs+0x164>
   2e1dc:	dfc00c17 	ldw	ra,48(sp)
   2e1e0:	df000b17 	ldw	fp,44(sp)
   2e1e4:	ddc00a17 	ldw	r23,40(sp)
   2e1e8:	dd800917 	ldw	r22,36(sp)
   2e1ec:	dd400817 	ldw	r21,32(sp)
   2e1f0:	dd000717 	ldw	r20,28(sp)
   2e1f4:	dcc00617 	ldw	r19,24(sp)
   2e1f8:	dc800517 	ldw	r18,20(sp)
   2e1fc:	dc400417 	ldw	r17,16(sp)
   2e200:	dc000317 	ldw	r16,12(sp)
   2e204:	dec00d04 	addi	sp,sp,52
   2e208:	f800283a 	ret
   2e20c:	91000117 	ldw	r4,4(r18)
   2e210:	88c00017 	ldw	r3,0(r17)
   2e214:	213fffc4 	addi	r4,r4,-1
   2e218:	24001526 	beq	r4,r16,2e270 <__call_exitprocs+0x150>
   2e21c:	88000015 	stw	zero,0(r17)
   2e220:	183fe726 	beq	r3,zero,2e1c0 <__call_exitprocs+0xa0>
   2e224:	00800044 	movi	r2,1
   2e228:	1408983a 	sll	r4,r2,r16
   2e22c:	91406217 	ldw	r5,392(r18)
   2e230:	95000117 	ldw	r20,4(r18)
   2e234:	214a703a 	and	r5,r4,r5
   2e238:	28000b26 	beq	r5,zero,2e268 <__call_exitprocs+0x148>
   2e23c:	91406317 	ldw	r5,396(r18)
   2e240:	2148703a 	and	r4,r4,r5
   2e244:	20000c1e 	bne	r4,zero,2e278 <__call_exitprocs+0x158>
   2e248:	99400017 	ldw	r5,0(r19)
   2e24c:	d9000117 	ldw	r4,4(sp)
   2e250:	183ee83a 	callr	r3
   2e254:	90c00117 	ldw	r3,4(r18)
   2e258:	1d3fc51e 	bne	r3,r20,2e170 <__call_exitprocs+0x50>
   2e25c:	b8c00017 	ldw	r3,0(r23)
   2e260:	1cbfd726 	beq	r3,r18,2e1c0 <__call_exitprocs+0xa0>
   2e264:	003fc206 	br	2e170 <__call_exitprocs+0x50>
   2e268:	183ee83a 	callr	r3
   2e26c:	003ff906 	br	2e254 <__call_exitprocs+0x134>
   2e270:	94000115 	stw	r16,4(r18)
   2e274:	003fea06 	br	2e220 <__call_exitprocs+0x100>
   2e278:	99000017 	ldw	r4,0(r19)
   2e27c:	183ee83a 	callr	r3
   2e280:	003ff406 	br	2e254 <__call_exitprocs+0x134>
   2e284:	90c00117 	ldw	r3,4(r18)
   2e288:	1800071e 	bne	r3,zero,2e2a8 <__call_exitprocs+0x188>
   2e28c:	90c00017 	ldw	r3,0(r18)
   2e290:	18000926 	beq	r3,zero,2e2b8 <__call_exitprocs+0x198>
   2e294:	9009883a 	mov	r4,r18
   2e298:	b8c00015 	stw	r3,0(r23)
   2e29c:	002df480 	call	2df48 <free>
   2e2a0:	bc800017 	ldw	r18,0(r23)
   2e2a4:	003fb506 	br	2e17c <__call_exitprocs+0x5c>
   2e2a8:	90c00017 	ldw	r3,0(r18)
   2e2ac:	902f883a 	mov	r23,r18
   2e2b0:	1825883a 	mov	r18,r3
   2e2b4:	003fb106 	br	2e17c <__call_exitprocs+0x5c>
   2e2b8:	0007883a 	mov	r3,zero
   2e2bc:	003ffb06 	br	2e2ac <__call_exitprocs+0x18c>

0002e2c0 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
   2e2c0:	defffc04 	addi	sp,sp,-16
   2e2c4:	df000315 	stw	fp,12(sp)
   2e2c8:	df000304 	addi	fp,sp,12
   2e2cc:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
   2e2d0:	0001883a 	nop
   2e2d4:	e0bfff17 	ldw	r2,-4(fp)
   2e2d8:	e0bffd15 	stw	r2,-12(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  int r2 = exit_code;
   2e2dc:	e0bffd17 	ldw	r2,-12(fp)
   2e2e0:	e0bffe15 	stw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "D02"(r2), "D03"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
   2e2e4:	e0bffe17 	ldw	r2,-8(fp)
   2e2e8:	10000226 	beq	r2,zero,2e2f4 <_exit+0x34>
    ALT_SIM_FAIL();
   2e2ec:	002af070 	cmpltui	zero,zero,43969
   2e2f0:	00000106 	br	2e2f8 <_exit+0x38>
  } else {
    ALT_SIM_PASS();
   2e2f4:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
   2e2f8:	003fff06 	br	2e2f8 <_exit+0x38>
