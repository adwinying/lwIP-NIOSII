
lwIP_NIOS_II_Example.elf:     file format elf32-littlenios2
lwIP_NIOS_II_Example.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00000020

Program Header:
    LOAD off    0x00001020 vaddr 0x00000020 paddr 0x00000020 align 2**12
         filesz 0x00027638 memsz 0x00027638 flags r-x
    LOAD off    0x00028658 vaddr 0x00027658 paddr 0x00029878 align 2**12
         filesz 0x00002220 memsz 0x00002220 flags rw-
    LOAD off    0x0002aa98 vaddr 0x0002ba98 paddr 0x0002ba98 align 2**12
         filesz 0x00000000 memsz 0x000499ac flags rw-
    LOAD off    0x0002b000 vaddr 0x05000000 paddr 0x05000000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  05000000  05000000  0002b000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .text         0002350c  00000020  00000020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000412c  0002352c  0002352c  0002452c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .rwdata       00002220  00027658  00029878  00028658  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  4 .bss          000499ac  0002ba98  0002ba98  0002aa98  2**2
                  ALLOC, SMALL_DATA
  5 .comment      00000023  00000000  00000000  0002b020  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 000016b0  00000000  00000000  0002b048  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00049de0  00000000  00000000  0002c6f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000f63e  00000000  00000000  000764d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000134c8  00000000  00000000  00085b16  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00003d2c  00000000  00000000  00098fe0  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000083be  00000000  00000000  0009cd0c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000246b8  00000000  00000000  000a50ca  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_alt_sim_info 00000050  00000000  00000000  000c9784  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00001e78  00000000  00000000  000c97d8  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .thread_model 00000003  00000000  00000000  000d25f0  2**0
                  CONTENTS, READONLY
 16 .cpu          00000003  00000000  00000000  000d25f3  2**0
                  CONTENTS, READONLY
 17 .qsys         00000001  00000000  00000000  000d25f6  2**0
                  CONTENTS, READONLY
 18 .simulation_enabled 00000001  00000000  00000000  000d25f7  2**0
                  CONTENTS, READONLY
 19 .sysid_hash   00000004  00000000  00000000  000d25f8  2**0
                  CONTENTS, READONLY
 20 .sysid_base   00000004  00000000  00000000  000d25fc  2**0
                  CONTENTS, READONLY
 21 .sysid_time   00000004  00000000  00000000  000d2600  2**0
                  CONTENTS, READONLY
 22 .stderr_dev   00000009  00000000  00000000  000d2604  2**0
                  CONTENTS, READONLY
 23 .stdin_dev    00000009  00000000  00000000  000d260d  2**0
                  CONTENTS, READONLY
 24 .stdout_dev   00000009  00000000  00000000  000d2616  2**0
                  CONTENTS, READONLY
 25 .sopc_system_name 0000000c  00000000  00000000  000d261f  2**0
                  CONTENTS, READONLY
 26 .quartus_project_dir 0000002e  00000000  00000000  000d262b  2**0
                  CONTENTS, READONLY
 27 .jdi          00005066  00000000  00000000  000d2659  2**0
                  CONTENTS, READONLY
 28 .sopcinfo     001a200d  00000000  00000000  000d76bf  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
05000000 l    d  .entry	00000000 .entry
00000020 l    d  .text	00000000 .text
0002352c l    d  .rodata	00000000 .rodata
00027658 l    d  .rwdata	00000000 .rwdata
0002ba98 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../lwIP_NIOS_II_Example_bsp/obj/HAL/src/crt0.o
00000098 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alteraTseEthernetif.c
00000000 l    df *ABS*	00000000 fs.c
00023610 l     O .rodata	00000671 data_index_html
00023c81 l     O .rodata	00000298 data_404_html
00023f19 l     O .rodata	00000345 data_img_sics_gif
00000000 l    df *ABS*	00000000 fsdata.c
00000000 l    df *ABS*	00000000 httpd.c
00000444 l     F .text	000000cc http_accept
00000630 l     F .text	00000198 http_recv
00000510 l     F .text	00000004 conn_err
00000810 l     F .text	00000090 http_poll
00000514 l     F .text	000000c4 send_data
000005d8 l     F .text	00000058 close_conn
000007c8 l     F .text	00000048 http_sent
00000000 l    df *ABS*	00000000 lwip_tse_mac.c
00000000 l    df *ABS*	00000000 tse_my_system.c
00000000 l    df *ABS*	00000000 echo.c
00000000 l    df *ABS*	00000000 histogram.c
00000000 l    df *ABS*	00000000 api_lib.c
00000000 l    df *ABS*	00000000 api_msg.c
00000000 l    df *ABS*	00000000 err.c
00000000 l    df *ABS*	00000000 netbuf.c
00000000 l    df *ABS*	00000000 netdb.c
00000000 l    df *ABS*	00000000 netifapi.c
00000000 l    df *ABS*	00000000 sockets.c
00000000 l    df *ABS*	00000000 tcpip.c
00000000 l    df *ABS*	00000000 def.c
00000000 l    df *ABS*	00000000 dhcp.c
00001430 l     F .text	00000058 dhcp_check
00001488 l     F .text	000001ec dhcp_bind
00001674 l     F .text	00000078 dhcp_option
000016ec l     F .text	0000005c dhcp_option_byte
00001748 l     F .text	000000e0 dhcp_option_trailer
00001828 l     F .text	00000078 dhcp_option_short
000018a0 l     F .text	000000a8 dhcp_option_long
00001948 l     F .text	000002ec dhcp_create_msg
000297f8 l     O .rwdata	00000004 xid.3565
00001c34 l     F .text	000000ac dhcp_delete_msg
00001ce0 l     F .text	00000170 dhcp_reboot
00001e50 l     F .text	00000170 dhcp_discover
00001fc0 l     F .text	000001ec dhcp_select
000021ac l     F .text	00000ab4 dhcp_recv
00002c60 l     F .text	00000130 dhcp_rebind
00000000 l    df *ABS*	00000000 dns.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 autoip.c
00000000 l    df *ABS*	00000000 icmp.c
00003880 l     F .text	00000130 icmp_send_response
00000000 l    df *ABS*	00000000 igmp.c
00000000 l    df *ABS*	00000000 inet.c
00000000 l    df *ABS*	00000000 inet_chksum.c
00003dc0 l     F .text	000000c0 lwip_standard_chksum
00000000 l    df *ABS*	00000000 ip.c
0002baa4 l     O .bss	00000002 ip_id
00000000 l    df *ABS*	00000000 ip_addr.c
0002cb1c l     O .bss	00000010 str.3022
00000000 l    df *ABS*	00000000 ip_frag.c
00004df4 l     F .text	00000074 ip_reass_dequeue_datagram
0002bab8 l     O .bss	00000004 reassdatagrams
00004e68 l     F .text	000001b8 ip_reass_free_complete_datagram
0002babc l     O .bss	00000002 ip_reass_pbufcount
00005020 l     F .text	000000f4 ip_reass_remove_oldest_datagram
0002cb2c l     O .bss	000005e0 buf
00000000 l    df *ABS*	00000000 mem.c
0002bac4 l     O .bss	00000004 ram_end
0002bac0 l     O .bss	00000004 ram
0002bac8 l     O .bss	00000004 lfree
00000000 l    df *ABS*	00000000 memp.c
00024e50 l     O .rodata	00000012 memp_num
0002d10c l     O .bss	0000cdcf memp_memory
00039edc l     O .bss	00000024 memp_tab
00024e62 l     O .rodata	00000012 memp_sizes
00000000 l    df *ABS*	00000000 netif.c
0002bacc l     O .bss	00000001 netif_num
00000000 l    df *ABS*	00000000 pbuf.c
00000000 l    df *ABS*	00000000 raw.c
0002badc l     O .bss	00000004 raw_pcbs
00000000 l    df *ABS*	00000000 asn1_dec.c
00000000 l    df *ABS*	00000000 asn1_enc.c
00000000 l    df *ABS*	00000000 mib2.c
00000000 l    df *ABS*	00000000 mib_structs.c
00000000 l    df *ABS*	00000000 msg_in.c
00000000 l    df *ABS*	00000000 msg_out.c
00000000 l    df *ABS*	00000000 stats.c
00000000 l    df *ABS*	00000000 sys.c
00000000 l    df *ABS*	00000000 tcp.c
00007a7c l     F .text	00000008 tcp_accept_null
00007a84 l     F .text	00000088 tcp_new_port
0002980c l     O .rwdata	00000002 tcp_port
0002bae1 l     O .bss	00000001 tcp_timer_ctr
00029810 l     O .rwdata	00000004 iss.3697
00008bb8 l     F .text	00000298 tcp_close_shutdown
0002bae0 l     O .bss	00000001 tcp_timer
00000000 l    df *ABS*	00000000 tcp_in.c
0000a3ec l     F .text	000000c4 tcp_parseopt
0002bb00 l     O .bss	00000004 tcphdr
0000a4b0 l     F .text	000000e0 tcp_oos_insert_segment
0002bb04 l     O .bss	00000004 seqno
0000a590 l     F .text	00000e38 tcp_receive
0002bb0c l     O .bss	00000001 flags
0002bb08 l     O .bss	00000004 ackno
0002bb0e l     O .bss	00000002 tcplen
00039f00 l     O .bss	00000010 inseg
0002bb10 l     O .bss	00000004 recv_data
0002bb14 l     O .bss	00000001 recv_flags
0002bafc l     O .bss	00000004 iphdr
00000000 l    df *ABS*	00000000 tcp_out.c
0000b3c8 l     F .text	000000ec tcp_pbuf_prealloc
0000b4b4 l     F .text	00000190 tcp_create_segment
0000b644 l     F .text	0000010c tcp_output_alloc_header.constprop.0
00000000 l    df *ABS*	00000000 timers.c
00000000 l    df *ABS*	00000000 udp.c
00029814 l     O .rwdata	00000002 udp_port
00000000 l    df *ABS*	00000000 etharp.c
0000d8e4 l     F .text	000000dc etharp_free_entry
00039f10 l     O .bss	000000c8 arp_table
0000d9c0 l     F .text	00000294 etharp_find_entry
0000dc54 l     F .text	000000bc etharp_send_ip
0000dd10 l     F .text	00000188 etharp_update_arp_entry
0002bb20 l     O .bss	00000001 etharp_cached_entry
0000e5c0 l     F .text	000000d8 etharp_output_to_arp_index
00000000 l    df *ABS*	00000000 ethernetif.c
00000000 l    df *ABS*	00000000 auth.c
00000000 l    df *ABS*	00000000 chap.c
00000000 l    df *ABS*	00000000 chpms.c
00000000 l    df *ABS*	00000000 fsm.c
00000000 l    df *ABS*	00000000 ipcp.c
00000000 l    df *ABS*	00000000 lcp.c
00000000 l    df *ABS*	00000000 magic.c
00000000 l    df *ABS*	00000000 md5.c
00000000 l    df *ABS*	00000000 pap.c
00000000 l    df *ABS*	00000000 ppp.c
00000000 l    df *ABS*	00000000 ppp_oe.c
00000000 l    df *ABS*	00000000 randm.c
00000000 l    df *ABS*	00000000 vj.c
00000000 l    df *ABS*	00000000 slipif.c
00000000 l    df *ABS*	00000000 main.c
0002bb24 l     O .bss	00000004 lwipProcessTimerFlag
0002bb28 l     O .bss	00000004 lwipTicksPer250mS
0002bb2c l     O .bss	00000004 lwip250mStimer
00039fd8 l     O .bss	00000018 lwipAlarm
0002bb30 l     O .bss	00000004 ip_zero.3933
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fp-bit.c
0000f13c l     F .text	00000354 _fpadd_parts
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 impure.c
00027898 l     O .rwdata	00000400 impure_data
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 vfprintf.c
000108e4 l     F .text	00000034 __sprint_r
000260eb l     O .rodata	00000010 blanks.3515
000260fb l     O .rodata	00000010 zeroes.3516
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 dtoa.c
00012a00 l     F .text	00000208 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
0001443c l     F .text	00000008 __fp_lock
00014444 l     F .text	00000008 __fp_unlock
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 locale.c
0002612c l     O .rodata	00000030 lconv
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
00026274 l     O .rodata	0000000c p05.2435
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 s_isinfd.c
00000000 l    df *ABS*	00000000 s_isnand.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00018758 l     F .text	00000074 udivmodsi4
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_close.c
000189f4 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dev.c
00018b0c l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
00018b38 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_isatty.c
00018c34 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_load.c
00018d24 l     F .text	0000006c alt_load_section
00000000 l    df *ABS*	00000000 alt_lseek.c
00018e10 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_read.c
00018fe8 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_remap_uncached.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
00029850 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_uncached_malloc.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
00019520 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
0001965c l     F .text	00000038 alt_dev_reg
00028254 l     O .rwdata	0000009c vic_0
000282f0 l     O .rwdata	000000d8 ext_flash
000283c8 l     O .rwdata	00001060 jtag_uart
00029428 l     O .rwdata	00000120 lcd
00029548 l     O .rwdata	00000030 sgdma_rx
00029578 l     O .rwdata	00000030 sgdma_tx
000295a8 l     O .rwdata	000000c4 rs232
0002966c l     O .rwdata	000000c4 uart_0
00029730 l     O .rwdata	000000c4 uart_1
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash.c
0001980c l     F .text	00000038 alt_flash_device_register
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_table.c
0001a644 l     F .text	00000080 alt_read_16bit_query_entry
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
0001b6f4 l     F .text	00000204 altera_avalon_jtag_uart_irq
0001b8f8 l     F .text	000000a4 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207.c
0002985c l     O .rwdata	00000004 colstart
0001bf8c l     F .text	000000b4 lcd_write_command
0001c040 l     F .text	000000d0 lcd_write_data
0001c110 l     F .text	000000cc lcd_clear_screen
0001c1dc l     F .text	000001ec lcd_repaint_screen
0001c3c8 l     F .text	000000cc lcd_scroll_up
0001c494 l     F .text	000002bc lcd_handle_escape
0001cc34 l     F .text	000000ac alt_lcd_16207_timeout
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_sgdma.c
0001ce78 l     F .text	00000050 alt_get_errno
0001da1c l     F .text	000000e4 alt_avalon_sgdma_irq
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
0001dba4 l     F .text	000000a0 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_timer_ts.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_vars.c
00000000 l    df *ABS*	00000000 altera_avalon_tse.c
0002bb72 l     O .bss	00000001 tse_system_count.3776
0002bb73 l     O .bss	00000001 is_init.3858
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
00021154 l     F .text	00000098 altera_avalon_uart_irq
000211ec l     F .text	000000d8 altera_avalon_uart_rxirq
000212c4 l     F .text	0000013c altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
00021454 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
00021700 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 altera_vic_irq_init.c
000273b4 l     O .rodata	00000020 VEC_SIZE_ARRAY.1688
00000000 l    df *ABS*	00000000 altera_vic_isr_register.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00021f64 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
00022284 l     F .text	000000c0 alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
000223bc l     F .text	00000050 alt_get_errno
0002240c l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_amd.c
000229c0 l     F .text	000000cc alt_write_word_amd
000228a4 l     F .text	0000011c alt_wait_for_command_to_complete_amd
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_intel.c
00022c74 l     F .text	0000017c alt_unlock_block_intel
00022df0 l     F .text	000000d4 alt_write_word_intel
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 ctype_.c
000274d5 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
00000000 l    df *ABS*	00000000 
0002baa8 g     O .bss	00000004 current_iphdr_src
00004184 g     F .text	00000020 inet_chksum
000077dc g     F .text	00000024 raw_bind
00016bc0 g     F .text	00000074 _mprec_log10
00005178 g     F .text	000005e4 ip_reass
0001e640 g     F .text	0000006c alt_tse_get_mac_info
00006914 g     F .text	00000174 pbuf_realloc
00016cb0 g     F .text	00000084 __any_on
0001787c g     F .text	00000064 _isatty_r
0002615c g     O .rodata	00000028 __mprec_tinytens
00018f30 g     F .text	00000078 alt_main
0002318c g     F .text	00000094 strcpy
00009158 g     F .text	00000014 tcp_next_iss
00010178 g     F .text	00000044 __ashldi3
00010620 g     F .text	00000084 _puts_r
0001a11c g     F .text	00000040 alt_read_query_entry_32bit
0000664c g     F .text	0000004c pbuf_free_ooseq
00007d50 g     F .text	000000a8 tcp_update_rcv_ann_wnd
000178e0 g     F .text	0000006c _lseek_r
0002bad0 g     O .bss	00000004 netif_list
000198d4 g     F .text	000002ac alt_flash_cfi_write
00002e4c g     F .text	00000058 dhcp_cleanup
000235e0 g     O .rodata	00000010 file_index_html
00029878 g       *ABS*	00000000 __flash_rwdata_start
00020f08 g     F .text	00000094 marvell_cfg_rgmii
0001850c g     F .text	0000005c __eqdf2
0000c99c g     F .text	000001d0 tcp_rst
000075d8 g     F .text	000000a0 pbuf_memfind
0001eabc g     F .text	00000008 alt_tse_phy_print_profile
00075444 g       *ABS*	00000000 __alt_heap_start
0001de34 g     F .text	00000064 marvell_phy_cfg
0000e0a0 g     F .text	00000280 etharp_request
00010438 g     F .text	0000003c printf
000036c4 g     F .text	00000194 dhcp_start
0001cfec g     F .text	00000110 alt_avalon_sgdma_do_sync_transfer
00008044 g     F .text	00000048 tcp_err
00029800 g     O .rwdata	00000004 ip_addr_any
00003e80 g     F .text	00000150 inet_chksum_pseudo
00002fd8 g     F .text	00000090 dhcp_network_changed
05000000 g       *ABS*	00000000 __alt_mem_sram
000174d4 g     F .text	0000005c __sseek
000144cc g     F .text	0000010c __sinit
0000d848 g     F .text	00000054 udp_remove
00012734 g     F .text	0000013c __swbuf_r
00004614 g     F .text	00000264 ip_output_if
00015164 g     F .text	0000009c _setlocale_r
00014458 g     F .text	00000064 __sfmoreglue
0000618c g     F .text	00000080 memp_free
00018fc8 g     F .text	00000020 __malloc_unlock
000067d8 g     F .text	0000013c pbuf_free
00007fb4 g     F .text	00000048 tcp_recv
0002000c g     F .text	00000538 getPHYSpeed
00006e04 g     F .text	000000bc pbuf_cat
00075240 g     O .bss	00000034 alteraTseNetif
0001d6d8 g     F .text	00000344 alt_avalon_sgdma_construct_descriptor_burst
0002bb6c g     O .bss	00000004 altera_avalon_timer_ts_freq
00015c64 g     F .text	00000128 memmove
00004878 g     F .text	000000cc ip_output
0000df60 g     F .text	00000080 etharp_cleanup_netif
0000d6d8 g     F .text	00000074 udp_sendto
000144bc g     F .text	00000010 _cleanup
00015d8c g     F .text	000000a8 _Balloc
00004cc0 g     F .text	00000034 ipaddr_addr
0000cd4c g     F .text	000000fc tcp_keepalive
0000de98 g     F .text	000000c8 etharp_tmr
0001f820 g     F .text	00000140 alt_tse_phy_set_adv_1000
00029868 g     O .rwdata	00000001 max_mac_system
000089f4 g     F .text	000001bc tcp_alloc
0001e154 g     F .text	00000330 alt_tse_system_add_sys
000185c4 g     F .text	00000064 __gtdf2
00000000  w      *UND*	00000000 __errno
0000d4cc g     F .text	0000020c udp_sendto_if
0001a2a8 g     F .text	0000004c alt_write_flash_command_32bit_device_16bit_mode
05000000 g     F .entry	0000001c __reset
00007fac g     F .text	00000008 tcp_arg
00000f9c g     F .text	000000c0 udpecho_recv
0002bae2 g     O .bss	00000001 tcp_active_pcbs_changed
0002bae4 g     O .bss	00000004 tcp_active_pcbs
0001d248 g     F .text	00000074 alt_avalon_sgdma_construct_stream_to_mem_desc_burst
00000020 g       *ABS*	00000000 __flash_exceptions_start
00017814 g     F .text	00000068 _fstat_r
0002bb1c g     O .bss	00000004 udp_pcbs
00027658 g     O .rwdata	00000240 tse_mac_device
00019dc8 g     F .text	000002d8 alt_flash_program_block
0002bb50 g     O .bss	00000004 errno
0000e93c g     F .text	000004a4 ethernet_input
00008e50 g     F .text	000000ac tcp_shutdown
000208b8 g     F .text	000004c0 alt_tse_phy_set_common_speed
00006df0 g     F .text	00000014 pbuf_ref
00075274 g     O .bss	00000020 pmac_groups
000064b4 g     F .text	0000001c netif_set_netmask
0002bb58 g     O .bss	00000004 alt_argv
000317f4 g       *ABS*	00000000 _gp
00008f1c g     F .text	00000054 tcp_recv_null
000194f0 g     F .text	00000030 usleep
0002baac g     O .bss	00000004 current_netif
0000bf74 g     F .text	000002e4 tcp_enqueue_flags
00008efc g     F .text	00000020 tcp_close
00007df8 g     F .text	000000e0 tcp_recved
00019498 g     F .text	00000058 alt_uncached_malloc
000080e0 g     F .text	00000078 tcp_pcb_purge
0001deb0 g     F .text	0000001c tse_mac_initTransInfo2
000280d4 g     O .rwdata	00000180 alt_fd_list
00004de4 g     F .text	00000010 ipaddr_ntoa
00029804 g     O .rwdata	00000007 tcp_persist_backoff
00021950 g       .text	00000000 VIC_0_VECTOR_TABLE
0002210c g     F .text	00000090 alt_find_dev
00010238 g     F .text	000000f8 memcpy
00005a10 g     F .text	000001c4 mem_free
0001dff4 g     F .text	0000001c tse_mac_setMIImode
0002bae8 g     O .bss	00000004 tcp_ticks
0002baec g     O .bss	00000004 tcp_listen_pcbs
0001e764 g     F .text	0000001c alt_tse_phy_rd_mdio_addr
0000cb6c g     F .text	0000004c tcp_rexmit_rto
0001444c g     F .text	0000000c _cleanup_r
00018684 g     F .text	000000d4 __floatsidf
0001decc g     F .text	00000090 tse_mac_sTxWrite
00022344 g     F .text	00000078 alt_io_redirect
00008bb0 g     F .text	00000008 tcp_new
00018628 g     F .text	0000005c __ltdf2
0000d824 g     F .text	00000018 udp_disconnect
000071bc g     F .text	00000124 pbuf_copy_partial
0002352c g       *ABS*	00000000 __DTOR_END__
000106a4 g     F .text	00000014 puts
0000339c g     F .text	00000144 dhcp_release
00016b1c g     F .text	000000a4 __ratio
00025698 g     O .rodata	0000002c tcp_state_str
000079b8 g     F .text	00000008 raw_send
000041a4 g     F .text	000000d8 inet_chksum_pbuf
000072e0 g     F .text	00000158 pbuf_take
0001d338 g     F .text	00000088 alt_avalon_sgdma_construct_mem_to_stream_desc_burst
0001baf8 g     F .text	00000244 altera_avalon_jtag_uart_read
00023164 g     F .text	00000014 malloc
0001040c g     F .text	0000002c _printf_r
0002bab0 g     O .bss	00000004 current_iphdr_dest
00018878 g     F .text	00000008 __udivsi3
0003a018 g     O .bss	00000100 tse
00018c84 g     F .text	000000a0 isatty
0001e484 g     F .text	000000f4 alt_tse_sys_enable_mdio_sharing
000039b0 g     F .text	000003f8 icmp_input
000261ac g     O .rodata	000000c8 __mprec_tens
0001e5fc g     F .text	00000044 alt_tse_get_mac_info_index
0003a118 g     O .bss	0003a980 histcb_table
000063c8 g     F .text	000000d0 netif_add
00015200 g     F .text	0000000c __locale_charset
0000f0b8 g     F .text	00000084 __fixunsdfsi
00007f20 g     F .text	00000030 tcp_segs_free
0002308c g     F .text	0000008c alt_icache_flush
0002bb4c g     O .bss	00000004 __malloc_top_pad
000003c0 g     F .text	00000084 fs_open
0002982c g     O .rwdata	00000004 __mb_cur_max
0001520c g     F .text	0000000c _localeconv_r
00006264 g     F .text	000000e4 netif_set_ipaddr
0001618c g     F .text	0000003c __i2b
00014b20 g     F .text	000004e4 __sfvwrite_r
0001d464 g     F .text	00000058 alt_avalon_sgdma_stop
0001e7a4 g     F .text	00000090 alt_tse_phy_wr_mdio_reg
00017394 g     F .text	00000064 _sbrk_r
00022a8c g     F .text	00000080 alt_program_intel
0001eac4 g     F .text	00000210 alt_tse_mac_group_init
00001128 g     F .text	00000058 init_hist
0000b750 g     F .text	00000824 tcp_write
0000097c g     F .text	000003d4 tse_mac_init
0000dfe0 g     F .text	000000c0 etharp_find_addr
0001794c g     F .text	0000006c _read_r
00021f24 g     F .text	00000024 alt_dcache_flush
00001100 g     F .text	00000028 get_utm
00027c98 g     O .rwdata	0000000c __lc_ctype
00029848 g     O .rwdata	00000004 alt_max_fd
0001a0a0 g     F .text	0000003c alt_read_query_entry_8bit
0000ff60 g     F .text	00000104 __unpack_d
000176c4 g     F .text	0000013c _fclose_r
00022b0c g     F .text	00000168 alt_erase_block_intel
00007b10 g     F .text	00000114 tcp_bind
0001440c g     F .text	00000030 fflush
0002bb48 g     O .bss	00000004 __malloc_max_sbrked_mem
00003db4 g     F .text	0000000c icmp_time_exceeded
000089ec g     F .text	00000008 tcp_abort
0000105c g     F .text	000000a4 udpecho_init
0000575c g     F .text	00000264 ip_frag
0000f490 g     F .text	00000054 __adddf3
00023600 g     O .rodata	00000010 file_img_sics_gif
00016890 g     F .text	00000148 __b2d
00017f80 g     F .text	0000058c __umoddi3
00018e60 g     F .text	000000d0 lseek
00007830 g     F .text	00000188 raw_sendto
0001e8a0 g     F .text	0000021c alt_tse_phy_add_profile_default
0001f4d0 g     F .text	00000350 alt_tse_phy_get_cap
00029824 g     O .rwdata	00000004 _global_impure_ptr
00016d34 g     F .text	000005fc _realloc_r
00075444 g       *ABS*	00000000 __bss_end
0001cec8 g     F .text	00000124 alt_avalon_sgdma_do_async_transfer
00019394 g     F .text	00000104 alt_tick
000179b8 g     F .text	000005c8 __udivdi3
0000361c g     F .text	000000a8 dhcp_stop
0001f2e4 g     F .text	000001ec alt_tse_phy_check_link
00026184 g     O .rodata	00000028 __mprec_bigtens
00015f70 g     F .text	00000104 __s2b
0000fb14 g     F .text	0000011c __floatunsidf
00020e78 g     F .text	00000090 marvell_cfg_sgmii
00006fc0 g     F .text	000001fc pbuf_copy
0001f0a0 g     F .text	00000244 alt_tse_phy_restart_an
00016630 g     F .text	00000058 __mcmp
0000cbb8 g     F .text	000000d0 tcp_rexmit
000210ac g     F .text	000000a8 altera_avalon_uart_init
00029874 g     O .rwdata	00000004 __ctype_ptr
000146e4 g     F .text	00000018 __fp_lock_all
00075294 g     O .bss	00000020 pphy_profiles
000064d8 g     F .text	0000002c netif_set_up
000192d0 g     F .text	000000c4 alt_alarm_stop
02001000 g       *ABS*	00000000 __alt_mem_descriptor_memory
00025678 g     O .rodata	00000010 tcp_pcb_lists
000280ac g     O .rwdata	00000028 alt_dev_null
00004994 g     F .text	0000006c ip4_addr_netmask_valid
0002baf0 g     O .bss	00000004 tcp_tmp_pcb
0001ff04 g     F .text	00000108 alt_tse_phy_init
0000ede0 g     F .text	00000010 lwipAlarmCallback
0001a5a8 g     F .text	0000009c alt_set_flash_algorithm_func
0001d4bc g     F .text	00000064 alt_avalon_sgdma_check_descriptor_status
00021f48 g     F .text	0000001c alt_dcache_flush_all
00016074 g     F .text	00000068 __hi0bits
0000fa40 g     F .text	000000d4 __fixdfsi
00000d50 g     F .text	000000ec tse_mac_raw_send
000059c0 g     F .text	00000050 mem_init
00021b50 g       .text	00000000 alt_shadow_non_preemptive_interrupt
0001a15c g     F .text	00000044 alt_write_flash_command_8bit_device_8bit_mode
0000c258 g     F .text	00000050 tcp_send_fin
00029878 g       *ABS*	00000000 __ram_rwdata_end
0000c38c g     F .text	00000610 tcp_output
00029840 g     O .rwdata	00000008 alt_dev_list
00019570 g     F .text	000000ec write
00005bd4 g     F .text	00000174 mem_trim
0001d5f8 g     F .text	00000080 alt_avalon_sgdma_enable_desc_poll
00010474 g     F .text	000000bc _putc_r
0001dde4 g     F .text	00000028 alt_timestamp_freq
00027658 g       *ABS*	00000000 __ram_rodata_end
00018b88 g     F .text	000000ac fstat
00010134 g     F .text	00000044 __lshrdi3
0002bb18 g     O .bss	00000004 tcp_input_pcb
000076e8 g     F .text	000000f4 raw_input
0001de0c g     F .text	00000028 DP83848C_link_status_read
0000c2a8 g     F .text	000000e4 tcp_send_empty_ack
0001b3fc g     F .text	000000d4 alt_check_primary_table
0000cc88 g     F .text	000000c4 tcp_rexmit_fast
000163a8 g     F .text	0000012c __pow5mult
0002bb40 g     O .bss	00000004 __nlocale_changed
00018880 g     F .text	00000008 __umodsi3
00019c0c g     F .text	00000064 alt_flash_cfi_read
0001a340 g     F .text	00000038 alt_write_native_8bit
00004a00 g     F .text	000002c0 ipaddr_aton
00004944 g     F .text	00000050 ip4_addr_isbroadcast
000064d0 g     F .text	00000008 netif_set_default
0000d83c g     F .text	0000000c udp_recv
0001d2bc g     F .text	0000007c alt_avalon_sgdma_construct_mem_to_stream_desc
0001d3c0 g     F .text	00000050 alt_avalon_sgdma_register_callback
00075444 g       *ABS*	00000000 end
0001a1a0 g     F .text	00000074 alt_write_flash_command_16bit_device_8bit_mode
0001c750 g     F .text	000004e4 altera_avalon_lcd_16207_write
000008a0 g     F .text	00000060 httpd_init
00006504 g     F .text	00000028 netif_set_down
00006a88 g     F .text	0000034c pbuf_alloc
000065c4 g     F .text	0000006c netif_set_link_up
00021750 g     F .text	00000200 altera_avalon_uart_write
0001e028 g     F .text	0000012c alt_tse_phy_add_profile
0001a6c4 g     F .text	000005c8 alt_read_cfi_table
0001b634 g     F .text	000000c0 altera_avalon_jtag_uart_init
0002352c g       *ABS*	00000000 __CTOR_LIST__
02000000 g       *ABS*	00000000 __alt_stack_pointer
0001d678 g     F .text	00000060 alt_avalon_sgdma_disable_desc_poll
0001dc44 g     F .text	00000088 alt_avalon_timer_sc_init
00020ffc g     F .text	00000060 altera_avalon_uart_write_fd
0000fc90 g     F .text	000000ac __clzsi2
0002105c g     F .text	00000050 altera_avalon_uart_close_fd
0001bd3c g     F .text	00000250 altera_avalon_jtag_uart_write
0001d0fc g     F .text	00000070 alt_avalon_sgdma_construct_mem_to_mem_desc
00019844 g     F .text	00000090 alt_flash_cfi_init
000146d4 g     F .text	00000004 __sfp_lock_acquire
00015b6c g     F .text	000000f8 memchr
000297fc g     O .rwdata	00000004 ip_addr_broadcast
00010918 g     F .text	00001df8 ___vfprintf_internal_r
00005114 g     F .text	00000064 ip_reass_tmr
0001d1ec g     F .text	0000005c alt_avalon_sgdma_construct_stream_to_mem_desc
000235f0 g     O .rodata	00000010 file_404_html
00014850 g     F .text	000002d0 _free_r
0000d758 g     F .text	000000cc udp_connect
00023350 g     F .text	000001a0 __call_exitprocs
0000132c g     F .text	00000104 print_hist
0002bab4 g     O .bss	00000004 current_header
00000f48 g     F .text	00000054 tse_sgdmaRx_isr
0000edf0 g     F .text	000000b0 lwipProcessTimers
0002bb3c g     O .bss	00000004 __mlocale_changed
00000e3c g     F .text	0000010c tse_mac_rcv
00006348 g     F .text	00000080 netif_set_addr
00003068 g     F .text	00000148 dhcp_arp_reply
00029830 g     O .rwdata	00000004 __malloc_sbrk_base
00000020 g     F .text	0000007c _start
0002bb60 g     O .bss	00000004 _alt_tick_rate
00007678 g     F .text	00000070 pbuf_strstr
0001d520 g     F .text	00000050 alt_avalon_sgdma_open
000060a4 g     F .text	000000e8 memp_malloc
000164d4 g     F .text	0000015c __lshift
0000ce48 g     F .text	00000160 tcp_zero_window_probe
0002bb64 g     O .bss	00000004 _alt_nticks
0001e834 g     F .text	0000006c alt_tse_phy_rd_mdio_reg
00019038 g     F .text	000000f0 read
000196d4 g     F .text	00000138 alt_sys_init
000034e0 g     F .text	0000013c dhcp_fine_tmr
00074a98 g     O .bss	0000000a dhcp_rx_options_given
00023220 g     F .text	00000130 __register_exitproc
0002bb71 g     O .bss	00000001 phy_profile_count
000107e8 g     F .text	000000fc strncmp
0001e5b4 g     F .text	00000048 alt_tse_get_mac_group_index
0001a0dc g     F .text	00000040 alt_read_query_entry_16bit
00019188 g     F .text	00000040 alt_remap_uncached
00004cf4 g     F .text	000000f0 ipaddr_ntoa_r
000161c8 g     F .text	000001e0 __multiply
0001b99c g     F .text	00000068 altera_avalon_jtag_uart_close
00027658 g       *ABS*	00000000 __ram_rwdata_start
0002352c g       *ABS*	00000000 __ram_rodata_start
00039ff0 g     O .bss	00000028 __malloc_current_mallinfo
0002baf4 g     O .bss	00000004 tcp_bound_pcbs
0001a3e4 g     F .text	000001c4 alt_set_flash_width_func
000169d8 g     F .text	00000144 __d2b
00007ed8 g     F .text	00000048 tcp_seg_free
0000751c g     F .text	000000bc pbuf_memcmp
0001e780 g     F .text	00000024 alt_tse_phy_wr_mdio_addr
0001b4d0 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
00022fd8 g     F .text	000000b4 alt_get_fd
00021dfc g     F .text	00000128 alt_busy_sleep
00010064 g     F .text	000000d0 __fpcmp_parts_d
00007b0c g     F .text	00000004 tcp_init
000091d0 g     F .text	0000020c tcp_connect
00003fd0 g     F .text	000001b4 inet_chksum_pseudo_partial
00017660 g     F .text	00000064 _close_r
00005d48 g     F .text	00000218 mem_malloc
00020544 g     F .text	00000304 alt_tse_phy_get_common_speed
00022694 g     F .text	00000210 alt_erase_block_amd
000101bc g     F .text	0000007c memcmp
0001b590 g     F .text	00000050 altera_avalon_jtag_uart_close_fd
00075444 g       *ABS*	00000000 __alt_stack_base
0001b5e0 g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
0002bb70 g     O .bss	00000001 mac_group_count
00006630 g     F .text	0000001c netif_set_link_down
000031b0 g     F .text	0000012c dhcp_renew
0001288c g     F .text	00000174 __swsetup_r
0001ac8c g     F .text	00000770 alt_read_cfi_width
00000900 g     F .text	0000007c tse_sgdma_read_init
0000f828 g     F .text	000001b4 __divdf3
000145d8 g     F .text	000000fc __sfp
00016c34 g     F .text	0000007c __copybits
0000916c g     F .text	00000064 tcp_eff_send_mss
00027ca4 g     O .rwdata	00000408 __malloc_av_
000146e0 g     F .text	00000004 __sinit_lock_release
0000f544 g     F .text	000002e4 __muldf3
000173f8 g     F .text	00000054 __sread
0001fc28 g     F .text	000002dc alt_tse_mac_get_phy
00022ec4 g     F .text	00000114 alt_find_file
00021fb4 g     F .text	000000a0 alt_dev_llist_insert
00018fa8 g     F .text	00000020 __malloc_lock
000191c8 g     F .text	00000108 sbrk
0001d410 g     F .text	00000054 alt_avalon_sgdma_start
00002ea4 g     F .text	00000134 dhcp_inform
00014224 g     F .text	000001e8 _fflush_r
0001e720 g     F .text	00000044 alt_tse_mac_set_duplex
000175a4 g     F .text	000000bc _calloc_r
00007800 g     F .text	00000024 raw_connect
0002986c g     O .rwdata	00000008 alt_flash_dev_list
0001a260 g     F .text	00000048 alt_write_flash_command_16bit_device_16bit_mode
0002ba98 g       *ABS*	00000000 __bss_start
00010330 g     F .text	000000dc memset
0000eea0 g     F .text	00000218 main
0002bb5c g     O .bss	00000004 alt_envp
0002bb44 g     O .bss	00000004 __malloc_max_total_mem
0001b530 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
00012870 g     F .text	0000001c __swbuf
00003da8 g     F .text	0000000c icmp_dest_unreach
0001cce0 g     F .text	00000138 altera_avalon_lcd_16207_init
00029860 g     O .rwdata	00000008 alt_sgdma_list
00007ffc g     F .text	00000048 tcp_sent
00017530 g     F .text	00000008 __sclose
000074d0 g     F .text	0000004c pbuf_get_at
02000000 g       *ABS*	00000000 __alt_heap_limit
00017800 g     F .text	00000014 fclose
0002ba98 g     O .bss	00000004 printed_flg
0001dccc g     F .text	00000088 alt_timestamp_start
000752b4 g     O .bss	00000190 _atexit0
00012c08 g     F .text	0000161c _dtoa_r
000153e8 g     F .text	00000784 _malloc_r
00007a14 g     F .text	00000064 raw_new
0001dfbc g     F .text	00000038 tse_mac_SwReset
0000009c g     F .text	000001d4 ethernetif_input
0002984c g     O .rwdata	00000004 alt_errno
0001a2f4 g     F .text	0000004c alt_write_flash_command_32bit_device_32bit_mode
00015004 g     F .text	000000a8 _fwalk
00019c70 g     F .text	00000158 alt_write_value_to_flash
0001a378 g     F .text	00000038 alt_write_native_16bit
00010530 g     F .text	000000f0 putc
000187cc g     F .text	00000050 __divsi3
00020d78 g     F .text	00000070 alt_tse_mac_set_common_speed
000079c0 g     F .text	00000054 raw_remove
00025f98 g     O .rodata	00000014 __thenan_df
00014714 g     F .text	0000013c _malloc_trim_r
0002352c g       *ABS*	00000000 __CTOR_END__
0002bad8 g     O .bss	00000001 pbuf_free_ooseq_pending
0000d368 g     F .text	00000164 udp_bind
0002bb74 g     O .bss	00000004 alt_vic_dev_list
00009120 g     F .text	00000038 tcp_tmr
0000e320 g     F .text	000002a0 etharp_query
000106b8 g     F .text	000000a4 strcmp
00003858 g     F .text	00000028 lwip_init
0002352c g       *ABS*	00000000 __flash_rodata_start
0002352c g       *ABS*	00000000 __DTOR_LIST__
0000e698 g     F .text	000002a4 etharp_output
0002ba9c g     O .bss	00000004 measuring_flg
00018568 g     F .text	0000005c __nedf2
00019694 g     F .text	00000040 alt_irq_init
00020848 g     F .text	00000070 alt_tse_mac_get_common_speed
00019128 g     F .text	00000060 alt_release_fd
00006498 g     F .text	0000001c netif_set_gw
00025fac g     O .rodata	00000100 __clz_tab
00006dd4 g     F .text	0000001c pbuf_clen
0002bb38 g     O .bss	00000004 _PathLocale
00023118 g     F .text	00000014 atexit
00017538 g     F .text	0000006c _write_r
00007f50 g     F .text	00000008 tcp_setprio
0000d74c g     F .text	0000000c udp_send
00015218 g     F .text	0000001c setlocale
00007438 g     F .text	00000098 pbuf_coalesce
00007824 g     F .text	0000000c raw_recv
0000652c g     F .text	00000098 netif_remove
00029828 g     O .rwdata	00000004 _impure_ptr
0002bb54 g     O .bss	00000004 alt_argc
00008158 g     F .text	000005d4 tcp_slowtmr
0002bb68 g     O .bss	00000004 altera_avalon_timer_ts_base
000220b0 g     F .text	0000005c _do_dtors
00021b68 g     F .text	0000013c alt_vic_irq_init
00016830 g     F .text	00000060 __ulp
00017330 g     F .text	00000038 __isinfd
0000808c g     F .text	00000008 tcp_accept
000146fc g     F .text	00000018 __fp_unlock_all
0001ce18 g     F .text	00000060 altera_avalon_lcd_16207_write_fd
00000270 g     F .text	00000150 ethernetif_init
00029838 g     O .rwdata	00000008 alt_fs_list
0001a214 g     F .text	0000004c alt_write_flash_command_32bit_device_8bit_mode
00000020 g       *ABS*	00000000 __ram_exceptions_start
00015234 g     F .text	0000000c localeconv
0001dd54 g     F .text	00000090 alt_timestamp
0a000000 g       *ABS*	00000000 __alt_mem_onchip_memory2
000297f4 g     O .rwdata	00000004 histid
0002baf8 g     O .bss	00000004 tcp_tw_pcbs
0001fae8 g     F .text	00000140 alt_tse_phy_set_adv_10
00021ca4 g     F .text	00000158 alt_ic_isr_register
0000cfb0 g     F .text	000003b8 udp_input
00029878 g       *ABS*	00000000 _edata
00020f9c g     F .text	00000060 altera_avalon_uart_read_fd
00075444 g       *ABS*	00000000 _end
0002219c g     F .text	00000068 alt_flash_open_dev
0001ecd4 g     F .text	00000278 alt_tse_mac_associate_phy
0000620c g     F .text	00000004 netif_init
00001180 g     F .text	00000074 begin_measure
00000020 g       *ABS*	00000000 __ram_exceptions_end
0001ba04 g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
0000427c g     F .text	00000070 ip_route
0002bb78 g     O .bss	00000fa4 histarea
00007c24 g     F .text	0000012c tcp_listen_with_backlog
00075120 g     O .bss	0000011e lwip_stats
00006698 g     F .text	00000140 pbuf_header
0002bad4 g     O .bss	00000004 netif_default
0000872c g     F .text	00000144 tcp_pcb_remove
0002bb34 g     O .bss	00000004 lwipStaticIp
0001d570 g     F .text	00000088 alt_avalon_sgdma_construct_descriptor
0001744c g     F .text	00000088 __swrite
00029834 g     O .rwdata	00000004 __malloc_trim_threshold
00006ec0 g     F .text	00000034 pbuf_chain
0002312c g     F .text	00000038 exit
00008870 g     F .text	0000017c tcp_abandon
000093dc g     F .text	0000001c tcp_debug_state_str
0000cfa8 g     F .text	00000004 tcp_timer_needed
000150ac g     F .text	000000b8 _fwalk_reent
00005fc4 g     F .text	000000e0 memp_init
00002d90 g     F .text	000000bc dhcp_set_struct
00016688 g     F .text	000001a8 __mdiff
00005f60 g     F .text	00000064 mem_calloc
00009078 g     F .text	000000a8 tcp_fasttmr
00022204 g     F .text	00000050 alt_flash_close_dev
0001881c g     F .text	0000005c __modsi3
00008f70 g     F .text	00000108 tcp_process_refused_data
0001e010 g     F .text	00000018 tse_mac_setGMIImode
00020de8 g     F .text	00000090 marvell_cfg_gmii
02000000 g       *ABS*	00000000 __alt_data_end
000146d8 g     F .text	00000004 __sfp_lock_release
00000000 g       *ABS*	00000000 __alt_mem_sdram
0001ef4c g     F .text	00000154 alt_tse_phy_cfg_pcs
00074aa4 g     O .bss	00000028 dhcp_rx_options_val
000273d4 g     O .rodata	00000101 _ctype_
04000000 g       *ABS*	00000000 __alt_mem_ext_flash
00021400 g     F .text	00000054 altera_avalon_uart_close
000234f0 g     F .text	0000003c _exit
00017368 g     F .text	0000002c __isnand
000032dc g     F .text	000000c0 dhcp_coarse_tmr
00018888 g     F .text	0000016c alt_alarm_start
00007f58 g     F .text	00000054 tcp_seg_copy
0000fc30 g     F .text	00000060 __muldi3
00015240 g     F .text	000001a8 __smakebuf_r
0001a3b0 g     F .text	00000034 alt_write_native_32bit
00008094 g     F .text	0000004c tcp_poll
0001075c g     F .text	0000008c strlen
000224d8 g     F .text	00000154 open
0000cfac g     F .text	00000004 udp_init
00074acc g     O .bss	00000654 ram_heap
0000f9dc g     F .text	00000064 __gedf2
0000d89c g     F .text	00000048 udp_new
00019b80 g     F .text	0000008c alt_flash_cfi_get_info
00022254 g     F .text	00000030 alt_icache_flush_all
0001df5c g     F .text	00000060 tse_mac_aRxRead
0002981c g     O .rwdata	00000006 ethbroadcast
00025688 g     O .rodata	0000000d tcp_backoff
00012710 g     F .text	00000024 __vfprintf_internal
000214a4 g     F .text	0000025c altera_avalon_uart_read
0002baa0 g     O .bss	00000004 timestamp_freq
0001e6ac g     F .text	00000074 alt_tse_mac_set_speed
0001d16c g     F .text	00000080 alt_avalon_sgdma_construct_mem_to_mem_desc_burst
0000f4e4 g     F .text	00000060 __subdf3
000160dc g     F .text	000000b0 __lo0bits
00029854 g     O .rwdata	00000008 alt_alarm_list
00022054 g     F .text	0000005c _do_ctors
0001f960 g     F .text	00000188 alt_tse_phy_set_adv_100
000093f8 g     F .text	00000ff4 tcp_input
00018a44 g     F .text	000000c8 close
0002262c g     F .text	00000068 alt_program_amd
000042ec g     F .text	00000328 ip_input
00018d90 g     F .text	00000080 alt_load
00029816 g     O .rwdata	00000006 ethzero
0000fd3c g     F .text	00000224 __pack_d
00007a78 g     F .text	00000004 stats_init
0001e578 g     F .text	0000003c alt_tse_get_system_index
0001db00 g     F .text	000000a4 alt_avalon_sgdma_init
00023178 g     F .text	00000014 free
00006210 g     F .text	00000054 netif_find
000146dc g     F .text	00000004 __sinit_lock_acquire
00015e5c g     F .text	00000114 __multadd
00015e34 g     F .text	00000028 _Bfree
0001de98 g     F .text	00000018 no_printf
000011f4 g     F .text	00000138 end_measure
00006ef4 g     F .text	000000cc pbuf_dechain



Disassembly of section .entry:

05000000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && !defined(ALT_SIM_OPTIMIZE)
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
 5000000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
 5000004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
 5000008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
 500000c:	00bffd16 	blt	zero,r2,5000004 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 5000010:	00400034 	movhi	at,0
    ori r1, r1, %lo(_start)
 5000014:	08400814 	ori	at,at,32
    jmp r1
 5000018:	0800683a 	jmp	at
 500001c:	00000000 	call	0 <__alt_mem_sdram>

Disassembly of section .text:

00000020 <_start>:
     * writing zero to SSTATUS register and executing an ERET instruction
     * to set STATUS.CRS to 0.
     */
    
    /* Get the current register set number (STATUS.CRS). */
    rdctl r2, status
      20:	0005303a 	rdctl	r2,status
    andi r2, r2, NIOS2_STATUS_CRS_MSK
      24:	10bf000c 	andi	r2,r2,64512
    
    /* Skip switching register set if STATUS.CRS is 0.  */
    beq r2, zero, 0f
      28:	10000426 	beq	r2,zero,3c <_start+0x1c>

    /* Set SSTATUS to 0 to get to set SSTATUS.PRS to 0. */
    .set nobreak
    movui sstatus, 0
      2c:	07800014 	movui	ba,0
    .set break

    /* Switch to register set 0 and jump to label. */
    movhi ea, %hi(0f)
      30:	07400034 	movhi	ea,0
    ori ea, ea, %lo(0f)
      34:	ef400f14 	ori	ea,ea,60
    eret
      38:	ef80083a 	eret

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
      3c:	06c08034 	movhi	sp,512
    ori sp, sp, %lo(__alt_stack_pointer)
      40:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
      44:	068000f4 	movhi	gp,3
    ori gp, gp, %lo(_gp)
      48:	d685fd14 	ori	gp,gp,6132
    /* 
     * Setup registers in shadow register sets
     * from 1 to NIOS2_NUM_OF_SHADOW_REG_SETS.
     */

    movui r2, 0     /* Contains value written into STATUS */
      4c:	00800014 	movui	r2,0
    movui r3, NIOS2_NUM_OF_SHADOW_REG_SETS  /* counter */
      50:	00c00054 	movui	r3,1
    movhi r4, 1     /* Constant to increment STATUS.PRS */
      54:	01000074 	movhi	r4,1
    
.Linitialize_shadow_registers:
    /* Increment STATUS.PRS */
    add r2, r2, r4
      58:	1105883a 	add	r2,r2,r4
    wrctl status, r2
      5c:	1001703a 	wrctl	status,r2

    /* Clear r0 in the shadow register set (not done by hardware) */
    wrprs r0, r0
      60:	0000a03a 	wrprs	zero,zero

    /* Write the GP in previous register set */
    wrprs gp, gp
      64:	d034a03a 	wrprs	gp,gp
    wrprs r30, r0    /* ba */
    wrprs r31, r0    /* ra */
#endif /* NIOS2_ECC_PRESENT */

    /* Decrement shadow register set counter */
    addi r3, r3, -1
      68:	18ffffc4 	addi	r3,r3,-1

    /* Done if index is 0. */
    bne r3, zero, .Linitialize_shadow_registers
      6c:	183ffa1e 	bne	r3,zero,58 <_start+0x38>
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
      70:	008000b4 	movhi	r2,2
    ori r2, r2, %lo(__bss_start)
      74:	10aea614 	ori	r2,r2,47768

    movhi r3, %hi(__bss_end)
      78:	00c001f4 	movhi	r3,7
    ori r3, r3, %lo(__bss_end)
      7c:	18d51114 	ori	r3,r3,21572

    beq r2, r3, 1f
      80:	10c00326 	beq	r2,r3,90 <_start+0x70>

0:
    stw zero, (r2)
      84:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
      88:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
      8c:	10fffd36 	bltu	r2,r3,84 <_start+0x64>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
      90:	0018d900 	call	18d90 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
      94:	0018f300 	call	18f30 <alt_main>

00000098 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
      98:	003fff06 	br	98 <alt_after_alt_main>

0000009c <ethernetif_input>:
 *
 * @param netif the lwip network interface structure for this ethernetif
 */
void
ethernetif_input(struct netif *netif)
{
      9c:	defffb04 	addi	sp,sp,-20
      a0:	dc000015 	stw	r16,0(sp)
 *         NULL on memory error
 */
static struct pbuf *
low_level_input(struct netif *netif)
{
  struct ethernetif *ethernetif = netif->state;
      a4:	24000717 	ldw	r16,28(r4)
 *
 * @param netif the lwip network interface structure for this ethernetif
 */
void
ethernetif_input(struct netif *netif)
{
      a8:	dc800215 	stw	r18,8(sp)
      ac:	dfc00415 	stw	ra,16(sp)
{
  struct ethernetif *ethernetif = netif->state;
  struct pbuf *p, *nextPkt;
  u32_t cpu_sr;

    if(ethernetif->lwipRxCount == 0)
      b0:	80801517 	ldw	r2,84(r16)
 *
 * @param netif the lwip network interface structure for this ethernetif
 */
void
ethernetif_input(struct netif *netif)
{
      b4:	dcc00315 	stw	r19,12(sp)
      b8:	dc400115 	stw	r17,4(sp)
      bc:	2025883a 	mov	r18,r4
{
  struct ethernetif *ethernetif = netif->state;
  struct pbuf *p, *nextPkt;
  u32_t cpu_sr;

    if(ethernetif->lwipRxCount == 0)
      c0:	10004c26 	beq	r2,zero,1f4 <ethernetif_input+0x158>
        return NULL;
    //  Dump current packet if there is no memory for the next packet.
    //  The lwipRxPbuf must contain pointers to pbufs at all times.
    nextPkt = pbuf_alloc(PBUF_RAW,  PBUF_POOL_BUFSIZE, PBUF_POOL);
      c4:	010000c4 	movi	r4,3
      c8:	01417b04 	movi	r5,1516
      cc:	200d883a 	mov	r6,r4
      d0:	0006a880 	call	6a88 <pbuf_alloc>
    if(nextPkt == NULL)
      d4:	10003f26 	beq	r2,zero,1d4 <ethernetif_input+0x138>
        {
        LINK_STATS_INC(link.memerr);
        LINK_STATS_INC(link.drop);
        return NULL;
        }
    nextPkt = (void *) alt_remap_uncached(nextPkt,sizeof *nextPkt);
      d8:	1009883a 	mov	r4,r2
      dc:	01400404 	movi	r5,16
      e0:	00191880 	call	19188 <alt_remap_uncached>
    nextPkt->payload = (void *) alt_remap_uncached(nextPkt->payload, PBUF_POOL_BUFSIZE);
      e4:	11000117 	ldw	r4,4(r2)
      e8:	01417b04 	movi	r5,1516
        {
        LINK_STATS_INC(link.memerr);
        LINK_STATS_INC(link.drop);
        return NULL;
        }
    nextPkt = (void *) alt_remap_uncached(nextPkt,sizeof *nextPkt);
      ec:	1027883a 	mov	r19,r2
    nextPkt->payload = (void *) alt_remap_uncached(nextPkt->payload, PBUF_POOL_BUFSIZE);
      f0:	00191880 	call	19188 <alt_remap_uncached>
      f4:	98800115 	stw	r2,4(r19)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
      f8:	0005303a 	rdctl	r2,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
      fc:	00ffff84 	movi	r3,-2
     100:	10c8703a 	and	r4,r2,r3
     104:	2001703a 	wrctl	status,r4
    cpu_sr = alt_irq_disable_all();
    --ethernetif->lwipRxCount;
     108:	81001517 	ldw	r4,84(r16)
     10c:	213fffc4 	addi	r4,r4,-1
     110:	81001515 	stw	r4,84(r16)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
     114:	0009303a 	rdctl	r4,status
  
  status &= ~NIOS2_STATUS_PIE_MSK;
     118:	20c6703a 	and	r3,r4,r3
  status |= (context & NIOS2_STATUS_PIE_MSK);
     11c:	1080004c 	andi	r2,r2,1
     120:	10c4b03a 	or	r2,r2,r3
  
  NIOS2_WRITE_STATUS (status);
     124:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(cpu_sr);
    p = ethernetif->lwipRxPbuf[ ethernetif->lwipRxIndex ];
     128:	80801417 	ldw	r2,80(r16)
     12c:	10c001c4 	addi	r3,r2,7
     130:	18c7883a 	add	r3,r3,r3
     134:	18c7883a 	add	r3,r3,r3
     138:	80c7883a 	add	r3,r16,r3
     13c:	1c400017 	ldw	r17,0(r3)
    ethernetif->lwipRxPbuf[ ethernetif->lwipRxIndex ] = nextPkt;
    if(++ethernetif->lwipRxIndex >= LWIP_RX_ETH_BUFFER)
     140:	10800044 	addi	r2,r2,1
    nextPkt->payload = (void *) alt_remap_uncached(nextPkt->payload, PBUF_POOL_BUFSIZE);
    cpu_sr = alt_irq_disable_all();
    --ethernetif->lwipRxCount;
    alt_irq_enable_all(cpu_sr);
    p = ethernetif->lwipRxPbuf[ ethernetif->lwipRxIndex ];
    ethernetif->lwipRxPbuf[ ethernetif->lwipRxIndex ] = nextPkt;
     144:	1cc00015 	stw	r19,0(r3)
    if(++ethernetif->lwipRxIndex >= LWIP_RX_ETH_BUFFER)
     148:	00c002c4 	movi	r3,11
     14c:	18801616 	blt	r3,r2,1a8 <ethernetif_input+0x10c>
     150:	80801415 	stw	r2,80(r16)
        ethernetif->lwipRxIndex = 0;
    LWIP_ASSERT("low_level_input: pbuf in rx buffer is NULL", p != NULL );
     154:	88001626 	beq	r17,zero,1b0 <ethernetif_input+0x114>
    LWIP_ASSERT("low_level_input: pbuf->len in rx buffer is 0", p->len != 0 );
     158:	8880028b 	ldhu	r2,10(r17)
     15c:	10003b26 	beq	r2,zero,24c <ethernetif_input+0x1b0>
  /* no packet could be read, silently ignore this */
  if (p == NULL) return;
  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = p->payload;

  switch (htons(ethhdr->type)) {
     160:	88800117 	ldw	r2,4(r17)
     164:	1080038b 	ldhu	r2,14(r2)
     168:	1006923a 	slli	r3,r2,8
     16c:	1004d23a 	srli	r2,r2,8
     170:	18ffffcc 	andi	r3,r3,65535
     174:	1884b03a 	or	r2,r3,r2
     178:	00c20004 	movi	r3,2048
     17c:	10c02426 	beq	r2,r3,210 <ethernetif_input+0x174>
     180:	00c20184 	movi	r3,2054
     184:	10c02226 	beq	r2,r3,210 <ethernetif_input+0x174>
       p = NULL;
     }
    break;

  default:
    pbuf_free(p);
     188:	8809883a 	mov	r4,r17
    p = NULL;
    break;
  }
}
     18c:	dfc00417 	ldw	ra,16(sp)
     190:	dcc00317 	ldw	r19,12(sp)
     194:	dc800217 	ldw	r18,8(sp)
     198:	dc400117 	ldw	r17,4(sp)
     19c:	dc000017 	ldw	r16,0(sp)
     1a0:	dec00504 	addi	sp,sp,20
       p = NULL;
     }
    break;

  default:
    pbuf_free(p);
     1a4:	00067d81 	jmpi	67d8 <pbuf_free>
    --ethernetif->lwipRxCount;
    alt_irq_enable_all(cpu_sr);
    p = ethernetif->lwipRxPbuf[ ethernetif->lwipRxIndex ];
    ethernetif->lwipRxPbuf[ ethernetif->lwipRxIndex ] = nextPkt;
    if(++ethernetif->lwipRxIndex >= LWIP_RX_ETH_BUFFER)
        ethernetif->lwipRxIndex = 0;
     1a8:	80001415 	stw	zero,80(r16)
    LWIP_ASSERT("low_level_input: pbuf in rx buffer is NULL", p != NULL );
     1ac:	883fea1e 	bne	r17,zero,158 <ethernetif_input+0xbc>
     1b0:	010000b4 	movhi	r4,2
     1b4:	210d4b04 	addi	r4,r4,13612
     1b8:	014000b4 	movhi	r5,2
     1bc:	294d5504 	addi	r5,r5,13652
     1c0:	01801e44 	movi	r6,121
     1c4:	01c000b4 	movhi	r7,2
     1c8:	39cd6004 	addi	r7,r7,13696
     1cc:	00104380 	call	10438 <printf>
     1d0:	003fff06 	br	1d0 <ethernetif_input+0x134>
    //  Dump current packet if there is no memory for the next packet.
    //  The lwipRxPbuf must contain pointers to pbufs at all times.
    nextPkt = pbuf_alloc(PBUF_RAW,  PBUF_POOL_BUFSIZE, PBUF_POOL);
    if(nextPkt == NULL)
        {
        LINK_STATS_INC(link.memerr);
     1d4:	008001f4 	movhi	r2,7
     1d8:	10944804 	addi	r2,r2,20768
     1dc:	1100030b 	ldhu	r4,12(r2)
        LINK_STATS_INC(link.drop);
     1e0:	10c0018b 	ldhu	r3,6(r2)
    //  Dump current packet if there is no memory for the next packet.
    //  The lwipRxPbuf must contain pointers to pbufs at all times.
    nextPkt = pbuf_alloc(PBUF_RAW,  PBUF_POOL_BUFSIZE, PBUF_POOL);
    if(nextPkt == NULL)
        {
        LINK_STATS_INC(link.memerr);
     1e4:	21000044 	addi	r4,r4,1
        LINK_STATS_INC(link.drop);
     1e8:	18c00044 	addi	r3,r3,1
    //  Dump current packet if there is no memory for the next packet.
    //  The lwipRxPbuf must contain pointers to pbufs at all times.
    nextPkt = pbuf_alloc(PBUF_RAW,  PBUF_POOL_BUFSIZE, PBUF_POOL);
    if(nextPkt == NULL)
        {
        LINK_STATS_INC(link.memerr);
     1ec:	1100030d 	sth	r4,12(r2)
        LINK_STATS_INC(link.drop);
     1f0:	10c0018d 	sth	r3,6(r2)
  default:
    pbuf_free(p);
    p = NULL;
    break;
  }
}
     1f4:	dfc00417 	ldw	ra,16(sp)
     1f8:	dcc00317 	ldw	r19,12(sp)
     1fc:	dc800217 	ldw	r18,8(sp)
     200:	dc400117 	ldw	r17,4(sp)
     204:	dc000017 	ldw	r16,0(sp)
     208:	dec00504 	addi	sp,sp,20
     20c:	f800283a 	ret
  /* PPPoE packet? */
  case ETHTYPE_PPPOEDISC:
  case ETHTYPE_PPPOE:
#endif /* PPPOE_SUPPORT */
    /* full packet send to tcpip_thread to process */
    if (netif->input(p, netif)!=ERR_OK)
     210:	90800417 	ldw	r2,16(r18)
     214:	8809883a 	mov	r4,r17
     218:	900b883a 	mov	r5,r18
     21c:	103ee83a 	callr	r2
     220:	10803fcc 	andi	r2,r2,255
     224:	1080201c 	xori	r2,r2,128
     228:	10bfe004 	addi	r2,r2,-128
     22c:	103fd61e 	bne	r2,zero,188 <ethernetif_input+0xec>
  default:
    pbuf_free(p);
    p = NULL;
    break;
  }
}
     230:	dfc00417 	ldw	ra,16(sp)
     234:	dcc00317 	ldw	r19,12(sp)
     238:	dc800217 	ldw	r18,8(sp)
     23c:	dc400117 	ldw	r17,4(sp)
     240:	dc000017 	ldw	r16,0(sp)
     244:	dec00504 	addi	sp,sp,20
     248:	f800283a 	ret
    p = ethernetif->lwipRxPbuf[ ethernetif->lwipRxIndex ];
    ethernetif->lwipRxPbuf[ ethernetif->lwipRxIndex ] = nextPkt;
    if(++ethernetif->lwipRxIndex >= LWIP_RX_ETH_BUFFER)
        ethernetif->lwipRxIndex = 0;
    LWIP_ASSERT("low_level_input: pbuf in rx buffer is NULL", p != NULL );
    LWIP_ASSERT("low_level_input: pbuf->len in rx buffer is 0", p->len != 0 );
     24c:	010000b4 	movhi	r4,2
     250:	210d4b04 	addi	r4,r4,13612
     254:	014000b4 	movhi	r5,2
     258:	294d6804 	addi	r5,r5,13728
     25c:	01801e84 	movi	r6,122
     260:	01c000b4 	movhi	r7,2
     264:	39cd6004 	addi	r7,r7,13696
     268:	00104380 	call	10438 <printf>
     26c:	003fff06 	br	26c <ethernetif_input+0x1d0>

00000270 <ethernetif_init>:
 *         ERR_MEM if private data couldn't be allocated
 *         any other err_t on error
 */
err_t
ethernetif_init(struct netif *netif)
{
     270:	defffa04 	addi	sp,sp,-24
     274:	dcc00315 	stw	r19,12(sp)
     278:	dfc00515 	stw	ra,20(sp)
     27c:	dd000415 	stw	r20,16(sp)
     280:	dc800215 	stw	r18,8(sp)
     284:	dc400115 	stw	r17,4(sp)
     288:	dc000015 	stw	r16,0(sp)
     28c:	2027883a 	mov	r19,r4
  int idx;
  struct pbuf *p;
  struct ethernetif *ethernetif;
  err_t tse_mac_raw_send(struct netif *netif, struct pbuf *p);  

  LWIP_ASSERT("netif != NULL", (netif != NULL));
     290:	20004226 	beq	r4,zero,39c <ethernetif_init+0x12c>
    
  ethernetif = mem_malloc(sizeof(struct ethernetif));
     294:	01001704 	movi	r4,92
     298:	0005d480 	call	5d48 <mem_malloc>
     29c:	1029883a 	mov	r20,r2
  if (ethernetif == NULL) {
     2a0:	10003526 	beq	r2,zero,378 <ethernetif_init+0x108>
   * The last argument should be replaced with your link speed, in units
   * of bits per second.
   */
  NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, LINK_SPEED_OF_YOUR_NETIF_IN_BPS);

  netif->state = ethernetif;
     2a4:	98800715 	stw	r2,28(r19)
  netif->name[0] = IFNAME0;
     2a8:	00801944 	movi	r2,101
     2ac:	98800b85 	stb	r2,46(r19)
  netif->name[1] = IFNAME1;
     2b0:	00801b84 	movi	r2,110
     2b4:	98800bc5 	stb	r2,47(r19)
  /* We directly use etharp_output() here to save a function call.
   * You can instead declare your own function an call etharp_output()
   * from it if you have to do some checks before sending (e.g. if link
   * is available...) */
  netif->output = etharp_output;
     2b8:	00800074 	movhi	r2,1
     2bc:	10b9a604 	addi	r2,r2,-6504
     2c0:	98800515 	stw	r2,20(r19)
  netif->linkoutput = tse_mac_raw_send;
     2c4:	00800034 	movhi	r2,0
     2c8:	10835404 	addi	r2,r2,3408
     2cc:	98800615 	stw	r2,24(r19)
  
  ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
     2d0:	988009c4 	addi	r2,r19,39
     2d4:	a0800015 	stw	r2,0(r20)
 * @return ERR_OK if the loopif is initialized
 *         ERR_MEM if private data couldn't be allocated
 *         any other err_t on error
 */
err_t
ethernetif_init(struct netif *netif)
     2d8:	a4800704 	addi	r18,r20,28
     2dc:	04400304 	movi	r17,12
  ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  
  /* initialize the rx buffer for access by the TSE ISR */
  for(idx = 0; idx < LWIP_RX_ETH_BUFFER; ++idx)
    {
    p = pbuf_alloc(PBUF_RAW, PBUF_POOL_BUFSIZE, PBUF_POOL);
     2e0:	010000c4 	movi	r4,3
     2e4:	200d883a 	mov	r6,r4
     2e8:	01417b04 	movi	r5,1516
     2ec:	0006a880 	call	6a88 <pbuf_alloc>
    if (p == NULL)
      return ERR_MEM;
    p = (void *) alt_remap_uncached(p,sizeof *p);
     2f0:	1009883a 	mov	r4,r2
     2f4:	01400404 	movi	r5,16
     2f8:	8c7fffc4 	addi	r17,r17,-1
  
  /* initialize the rx buffer for access by the TSE ISR */
  for(idx = 0; idx < LWIP_RX_ETH_BUFFER; ++idx)
    {
    p = pbuf_alloc(PBUF_RAW, PBUF_POOL_BUFSIZE, PBUF_POOL);
    if (p == NULL)
     2fc:	10001e26 	beq	r2,zero,378 <ethernetif_init+0x108>
      return ERR_MEM;
    p = (void *) alt_remap_uncached(p,sizeof *p);
     300:	00191880 	call	19188 <alt_remap_uncached>
    p->payload = (void *) alt_remap_uncached(p->payload,PBUF_POOL_BUFSIZE);
     304:	11000117 	ldw	r4,4(r2)
     308:	01417b04 	movi	r5,1516
  for(idx = 0; idx < LWIP_RX_ETH_BUFFER; ++idx)
    {
    p = pbuf_alloc(PBUF_RAW, PBUF_POOL_BUFSIZE, PBUF_POOL);
    if (p == NULL)
      return ERR_MEM;
    p = (void *) alt_remap_uncached(p,sizeof *p);
     30c:	1021883a 	mov	r16,r2
    p->payload = (void *) alt_remap_uncached(p->payload,PBUF_POOL_BUFSIZE);
     310:	00191880 	call	19188 <alt_remap_uncached>
     314:	94800104 	addi	r18,r18,4
     318:	80800115 	stw	r2,4(r16)
    ethernetif->lwipRxPbuf[idx] = p;
     31c:	943fff15 	stw	r16,-4(r18)
  netif->linkoutput = tse_mac_raw_send;
  
  ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  
  /* initialize the rx buffer for access by the TSE ISR */
  for(idx = 0; idx < LWIP_RX_ETH_BUFFER; ++idx)
     320:	883fef1e 	bne	r17,zero,2e0 <ethernetif_init+0x70>
 *        for this ethernetif
 */
static void
low_level_init(struct netif *netif)
{
  struct ethernetif *ethernetif = netif->state;
     324:	99400717 	ldw	r5,28(r19)
  
  /* set MAC hardware address length */
  netif->hwaddr_len = ETHARP_HWADDR_LEN;
     328:	00800184 	movi	r2,6
      return ERR_MEM;
    p = (void *) alt_remap_uncached(p,sizeof *p);
    p->payload = (void *) alt_remap_uncached(p->payload,PBUF_POOL_BUFSIZE);
    ethernetif->lwipRxPbuf[idx] = p;
    }
  ethernetif->lwipRxCount = 0;
     32c:	a0001515 	stw	zero,84(r20)
  ethernetif->lwipRxIndex = 0;
     330:	a0001415 	stw	zero,80(r20)
  ethernetif->lwipRxIndexIsr = 0;
     334:	a0001315 	stw	zero,76(r20)
low_level_init(struct netif *netif)
{
  struct ethernetif *ethernetif = netif->state;
  
  /* set MAC hardware address length */
  netif->hwaddr_len = ETHARP_HWADDR_LEN;
     338:	98800985 	stb	r2,38(r19)

  /* maximum transfer unit */
  netif->mtu = 1500;
     33c:	00817704 	movi	r2,1500
     340:	9880090d 	sth	r2,36(r19)
  
  /* device capabilities */
  /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
     344:	00800c84 	movi	r2,50
     348:	98800b45 	stb	r2,45(r19)
  
  tse_mac_init(0, ethernetif) != 0;
     34c:	0009883a 	mov	r4,zero
     350:	000097c0 	call	97c <tse_mac_init>
  ethernetif->lwipRxIndex = 0;
  ethernetif->lwipRxIndexIsr = 0;
                  
  /* initialize the low level hardware */
  low_level_init(netif);
  return ERR_OK;
     354:	0005883a 	mov	r2,zero
}
     358:	dfc00517 	ldw	ra,20(sp)
     35c:	dd000417 	ldw	r20,16(sp)
     360:	dcc00317 	ldw	r19,12(sp)
     364:	dc800217 	ldw	r18,8(sp)
     368:	dc400117 	ldw	r17,4(sp)
     36c:	dc000017 	ldw	r16,0(sp)
     370:	dec00604 	addi	sp,sp,24
     374:	f800283a 	ret
  LWIP_ASSERT("netif != NULL", (netif != NULL));
    
  ethernetif = mem_malloc(sizeof(struct ethernetif));
  if (ethernetif == NULL) {
    LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_init: out of memory\n"));
    return ERR_MEM;
     378:	00bfffc4 	movi	r2,-1
  ethernetif->lwipRxIndexIsr = 0;
                  
  /* initialize the low level hardware */
  low_level_init(netif);
  return ERR_OK;
}
     37c:	dfc00517 	ldw	ra,20(sp)
     380:	dd000417 	ldw	r20,16(sp)
     384:	dcc00317 	ldw	r19,12(sp)
     388:	dc800217 	ldw	r18,8(sp)
     38c:	dc400117 	ldw	r17,4(sp)
     390:	dc000017 	ldw	r16,0(sp)
     394:	dec00604 	addi	sp,sp,24
     398:	f800283a 	ret
  int idx;
  struct pbuf *p;
  struct ethernetif *ethernetif;
  err_t tse_mac_raw_send(struct netif *netif, struct pbuf *p);  

  LWIP_ASSERT("netif != NULL", (netif != NULL));
     39c:	010000b4 	movhi	r4,2
     3a0:	210d4b04 	addi	r4,r4,13612
     3a4:	014000b4 	movhi	r5,2
     3a8:	294d7404 	addi	r5,r5,13776
     3ac:	01803144 	movi	r6,197
     3b0:	01c000b4 	movhi	r7,2
     3b4:	39cd6004 	addi	r7,r7,13696
     3b8:	00104380 	call	10438 <printf>
     3bc:	003fff06 	br	3bc <ethernetif_init+0x14c>

000003c0 <fs_open>:


/*-----------------------------------------------------------------------------------*/
int
fs_open(const char *name, struct fs_file *file)
{
     3c0:	defffc04 	addi	sp,sp,-16
     3c4:	dc800215 	stw	r18,8(sp)
     3c8:	dc400115 	stw	r17,4(sp)
     3cc:	dc000015 	stw	r16,0(sp)
     3d0:	dfc00315 	stw	ra,12(sp)
     3d4:	2023883a 	mov	r17,r4
     3d8:	2825883a 	mov	r18,r5
  const struct fsdata_file *f;

  for(f = FS_ROOT;
     3dc:	040000b4 	movhi	r16,2
     3e0:	840d7804 	addi	r16,r16,13792
      f != NULL;
      f = f->next) {
    if (!strcmp(name, (const char*)f->name)) {
     3e4:	81400117 	ldw	r5,4(r16)
     3e8:	8809883a 	mov	r4,r17
     3ec:	00106b80 	call	106b8 <strcmp>
     3f0:	10000926 	beq	r2,zero,418 <fs_open+0x58>
{
  const struct fsdata_file *f;

  for(f = FS_ROOT;
      f != NULL;
      f = f->next) {
     3f4:	84000017 	ldw	r16,0(r16)
int
fs_open(const char *name, struct fs_file *file)
{
  const struct fsdata_file *f;

  for(f = FS_ROOT;
     3f8:	803ffa1e 	bne	r16,zero,3e4 <fs_open+0x24>
      file->data = f->data;
      file->len = f->len;
      return 1;
    }
  }
  return 0;
     3fc:	0005883a 	mov	r2,zero
}
     400:	dfc00317 	ldw	ra,12(sp)
     404:	dc800217 	ldw	r18,8(sp)
     408:	dc400117 	ldw	r17,4(sp)
     40c:	dc000017 	ldw	r16,0(sp)
     410:	dec00404 	addi	sp,sp,16
     414:	f800283a 	ret

  for(f = FS_ROOT;
      f != NULL;
      f = f->next) {
    if (!strcmp(name, (const char*)f->name)) {
      file->data = f->data;
     418:	81000217 	ldw	r4,8(r16)
      file->len = f->len;
     41c:	80c00317 	ldw	r3,12(r16)
      return 1;
     420:	00800044 	movi	r2,1

  for(f = FS_ROOT;
      f != NULL;
      f = f->next) {
    if (!strcmp(name, (const char*)f->name)) {
      file->data = f->data;
     424:	91000015 	stw	r4,0(r18)
      file->len = f->len;
     428:	90c00115 	stw	r3,4(r18)
      return 1;
    }
  }
  return 0;
}
     42c:	dfc00317 	ldw	ra,12(sp)
     430:	dc800217 	ldw	r18,8(sp)
     434:	dc400117 	ldw	r17,4(sp)
     438:	dc000017 	ldw	r16,0(sp)
     43c:	dec00404 	addi	sp,sp,16
     440:	f800283a 	ret

00000444 <http_accept>:
  struct tcp_pcb_listen *lpcb = (struct tcp_pcb_listen*)arg;

  LWIP_UNUSED_ARG(err);

  /* Decrease the listen backlog counter */
  tcp_accepted(lpcb);
     444:	20800617 	ldw	r2,24(r4)
  return ERR_OK;
}
/*-----------------------------------------------------------------------------------*/
static err_t
http_accept(void *arg, struct tcp_pcb *pcb, err_t err)
{
     448:	defffe04 	addi	sp,sp,-8
     44c:	dc000015 	stw	r16,0(sp)
     450:	dfc00115 	stw	ra,4(sp)
  struct tcp_pcb_listen *lpcb = (struct tcp_pcb_listen*)arg;

  LWIP_UNUSED_ARG(err);

  /* Decrease the listen backlog counter */
  tcp_accepted(lpcb);
     454:	00c00044 	movi	r3,1
  return ERR_OK;
}
/*-----------------------------------------------------------------------------------*/
static err_t
http_accept(void *arg, struct tcp_pcb *pcb, err_t err)
{
     458:	2821883a 	mov	r16,r5
  struct tcp_pcb_listen *lpcb = (struct tcp_pcb_listen*)arg;

  LWIP_UNUSED_ARG(err);

  /* Decrease the listen backlog counter */
  tcp_accepted(lpcb);
     45c:	10c00926 	beq	r2,r3,484 <http_accept+0x40>
     460:	010000b4 	movhi	r4,2
     464:	210d4b04 	addi	r4,r4,13612
     468:	014000b4 	movhi	r5,2
     46c:	29509804 	addi	r5,r5,16992
     470:	01803584 	movi	r6,214
     474:	01c000b4 	movhi	r7,2
     478:	39d0a404 	addi	r7,r7,17040
     47c:	00104380 	call	10438 <printf>
     480:	003fff06 	br	480 <http_accept+0x3c>

  tcp_setprio(pcb, TCP_PRIO_MIN);
     484:	2809883a 	mov	r4,r5
     488:	100b883a 	mov	r5,r2
     48c:	0007f500 	call	7f50 <tcp_setprio>
  
  /* Allocate memory for the structure that holds the state of the
     connection. */
  hs = (struct http_state *)mem_malloc(sizeof(struct http_state));
     490:	01000304 	movi	r4,12
     494:	0005d480 	call	5d48 <mem_malloc>

  if (hs == NULL) {
     498:	10001826 	beq	r2,zero,4fc <http_accept+0xb8>
  hs->left = 0;
  hs->retries = 0;
  
  /* Tell TCP that this is the structure we wish to be passed for our
     callbacks. */
  tcp_arg(pcb, hs);
     49c:	100b883a 	mov	r5,r2
    printf("http_accept: Out of memory\n");
    return ERR_MEM;
  }
  
  /* Initialize the structure. */
  hs->file = NULL;
     4a0:	10000115 	stw	zero,4(r2)
  hs->left = 0;
     4a4:	10000015 	stw	zero,0(r2)
  hs->retries = 0;
     4a8:	10000205 	stb	zero,8(r2)
  
  /* Tell TCP that this is the structure we wish to be passed for our
     callbacks. */
  tcp_arg(pcb, hs);
     4ac:	8009883a 	mov	r4,r16
     4b0:	0007fac0 	call	7fac <tcp_arg>

  /* Tell TCP that we wish to be informed of incoming data by a call
     to the http_recv() function. */
  tcp_recv(pcb, http_recv);
     4b4:	8009883a 	mov	r4,r16
     4b8:	01400034 	movhi	r5,0
     4bc:	29418c04 	addi	r5,r5,1584
     4c0:	0007fb40 	call	7fb4 <tcp_recv>

  tcp_err(pcb, conn_err);
     4c4:	8009883a 	mov	r4,r16
     4c8:	01400034 	movhi	r5,0
     4cc:	29414404 	addi	r5,r5,1296
     4d0:	00080440 	call	8044 <tcp_err>
  
  tcp_poll(pcb, http_poll, 4);
     4d4:	8009883a 	mov	r4,r16
     4d8:	01400034 	movhi	r5,0
     4dc:	29420404 	addi	r5,r5,2064
     4e0:	01800104 	movi	r6,4
     4e4:	00080940 	call	8094 <tcp_poll>

  return ERR_OK;
     4e8:	0005883a 	mov	r2,zero
}
     4ec:	dfc00117 	ldw	ra,4(sp)
     4f0:	dc000017 	ldw	r16,0(sp)
     4f4:	dec00204 	addi	sp,sp,8
     4f8:	f800283a 	ret
  /* Allocate memory for the structure that holds the state of the
     connection. */
  hs = (struct http_state *)mem_malloc(sizeof(struct http_state));

  if (hs == NULL) {
    printf("http_accept: Out of memory\n");
     4fc:	010000b4 	movhi	r4,2
     500:	2110a804 	addi	r4,r4,17056
     504:	00106a40 	call	106a4 <puts>
    return ERR_MEM;
     508:	00bfffc4 	movi	r2,-1
     50c:	003ff706 	br	4ec <http_accept+0xa8>

00000510 <conn_err>:
  struct http_state *hs;

  LWIP_UNUSED_ARG(err);

  hs = arg;
  mem_free(hs);
     510:	0005a101 	jmpi	5a10 <mem_free>

00000514 <send_data>:
  tcp_close(pcb);
}
/*-----------------------------------------------------------------------------------*/
static void
send_data(struct tcp_pcb *pcb, struct http_state *hs)
{
     514:	defffa04 	addi	sp,sp,-24
     518:	dc000015 	stw	r16,0(sp)
  err_t err;
  u32_t len;

  /* We cannot send more data than space available in the send
     buffer. */     
  if (tcp_sndbuf(pcb) < hs->left) {
     51c:	28800017 	ldw	r2,0(r5)
     520:	24001a8b 	ldhu	r16,106(r4)
  tcp_close(pcb);
}
/*-----------------------------------------------------------------------------------*/
static void
send_data(struct tcp_pcb *pcb, struct http_state *hs)
{
     524:	dcc00315 	stw	r19,12(sp)
     528:	dc400115 	stw	r17,4(sp)
     52c:	dfc00515 	stw	ra,20(sp)
     530:	dd000415 	stw	r20,16(sp)
     534:	dc800215 	stw	r18,8(sp)
     538:	2027883a 	mov	r19,r4
     53c:	2823883a 	mov	r17,r5
     540:	1400012e 	bgeu	r2,r16,548 <send_data+0x34>
     544:	1021883a 	mov	r16,r2
    LWIP_ASSERT((len == hs->left), "hs->left did not fit into u16_t!");
  }

  do {
    err = tcp_write(pcb, hs->file, len, 0);
    if (err == ERR_MEM) {
     548:	04bfffc4 	movi	r18,-1
      len /= 2;
    }
  } while (err == ERR_MEM && len > 1);  
     54c:	05000044 	movi	r20,1
    len = hs->left;
    LWIP_ASSERT((len == hs->left), "hs->left did not fit into u16_t!");
  }

  do {
    err = tcp_write(pcb, hs->file, len, 0);
     550:	89400117 	ldw	r5,4(r17)
     554:	81bfffcc 	andi	r6,r16,65535
     558:	9809883a 	mov	r4,r19
     55c:	000f883a 	mov	r7,zero
     560:	000b7500 	call	b750 <tcp_write>
    if (err == ERR_MEM) {
     564:	10803fcc 	andi	r2,r2,255
     568:	1080201c 	xori	r2,r2,128
     56c:	10bfe004 	addi	r2,r2,-128
     570:	14800f26 	beq	r2,r18,5b0 <send_data+0x9c>
      len /= 2;
    }
  } while (err == ERR_MEM && len > 1);  
  
  if (err == ERR_OK) {
     574:	1000061e 	bne	r2,zero,590 <send_data+0x7c>
    hs->file += len;
     578:	88800117 	ldw	r2,4(r17)
    hs->left -= len;
     57c:	88c00017 	ldw	r3,0(r17)
      len /= 2;
    }
  } while (err == ERR_MEM && len > 1);  
  
  if (err == ERR_OK) {
    hs->file += len;
     580:	1405883a 	add	r2,r2,r16
    hs->left -= len;
     584:	1c21c83a 	sub	r16,r3,r16
      len /= 2;
    }
  } while (err == ERR_MEM && len > 1);  
  
  if (err == ERR_OK) {
    hs->file += len;
     588:	88800115 	stw	r2,4(r17)
    hs->left -= len;
     58c:	8c000015 	stw	r16,0(r17)
    /*  } else {
    printf("send_data: error %s len %d %d\n", lwip_strerr(err), len, tcp_sndbuf(pcb));*/
  }
}
     590:	dfc00517 	ldw	ra,20(sp)
     594:	dd000417 	ldw	r20,16(sp)
     598:	dcc00317 	ldw	r19,12(sp)
     59c:	dc800217 	ldw	r18,8(sp)
     5a0:	dc400117 	ldw	r17,4(sp)
     5a4:	dc000017 	ldw	r16,0(sp)
     5a8:	dec00604 	addi	sp,sp,24
     5ac:	f800283a 	ret
  }

  do {
    err = tcp_write(pcb, hs->file, len, 0);
    if (err == ERR_MEM) {
      len /= 2;
     5b0:	8020d07a 	srli	r16,r16,1
    }
  } while (err == ERR_MEM && len > 1);  
     5b4:	a43fe636 	bltu	r20,r16,550 <send_data+0x3c>
    hs->file += len;
    hs->left -= len;
    /*  } else {
    printf("send_data: error %s len %d %d\n", lwip_strerr(err), len, tcp_sndbuf(pcb));*/
  }
}
     5b8:	dfc00517 	ldw	ra,20(sp)
     5bc:	dd000417 	ldw	r20,16(sp)
     5c0:	dcc00317 	ldw	r19,12(sp)
     5c4:	dc800217 	ldw	r18,8(sp)
     5c8:	dc400117 	ldw	r17,4(sp)
     5cc:	dc000017 	ldw	r16,0(sp)
     5d0:	dec00604 	addi	sp,sp,24
     5d4:	f800283a 	ret

000005d8 <close_conn>:
  mem_free(hs);
}
/*-----------------------------------------------------------------------------------*/
static void
close_conn(struct tcp_pcb *pcb, struct http_state *hs)
{
     5d8:	defffd04 	addi	sp,sp,-12
     5dc:	dc400115 	stw	r17,4(sp)
     5e0:	2823883a 	mov	r17,r5
  tcp_arg(pcb, NULL);
     5e4:	000b883a 	mov	r5,zero
  mem_free(hs);
}
/*-----------------------------------------------------------------------------------*/
static void
close_conn(struct tcp_pcb *pcb, struct http_state *hs)
{
     5e8:	dfc00215 	stw	ra,8(sp)
     5ec:	dc000015 	stw	r16,0(sp)
     5f0:	2021883a 	mov	r16,r4
  tcp_arg(pcb, NULL);
     5f4:	0007fac0 	call	7fac <tcp_arg>
  tcp_sent(pcb, NULL);
     5f8:	8009883a 	mov	r4,r16
     5fc:	000b883a 	mov	r5,zero
     600:	0007ffc0 	call	7ffc <tcp_sent>
  tcp_recv(pcb, NULL);
     604:	8009883a 	mov	r4,r16
     608:	000b883a 	mov	r5,zero
     60c:	0007fb40 	call	7fb4 <tcp_recv>
  mem_free(hs);
     610:	8809883a 	mov	r4,r17
     614:	0005a100 	call	5a10 <mem_free>
  tcp_close(pcb);
     618:	8009883a 	mov	r4,r16
}
     61c:	dfc00217 	ldw	ra,8(sp)
     620:	dc400117 	ldw	r17,4(sp)
     624:	dc000017 	ldw	r16,0(sp)
     628:	dec00304 	addi	sp,sp,12
{
  tcp_arg(pcb, NULL);
  tcp_sent(pcb, NULL);
  tcp_recv(pcb, NULL);
  mem_free(hs);
  tcp_close(pcb);
     62c:	0008efc1 	jmpi	8efc <tcp_close>

00000630 <http_recv>:
  struct fs_file file;
  struct http_state *hs;

  hs = arg;

  if (err == ERR_OK && p != NULL) {
     630:	39c03fcc 	andi	r7,r7,255
  return ERR_OK;
}
/*-----------------------------------------------------------------------------------*/
static err_t
http_recv(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
     634:	defff904 	addi	sp,sp,-28
  struct fs_file file;
  struct http_state *hs;

  hs = arg;

  if (err == ERR_OK && p != NULL) {
     638:	39c0201c 	xori	r7,r7,128
  return ERR_OK;
}
/*-----------------------------------------------------------------------------------*/
static err_t
http_recv(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
     63c:	dc800415 	stw	r18,16(sp)
     640:	dc400315 	stw	r17,12(sp)
     644:	dc000215 	stw	r16,8(sp)
     648:	dfc00615 	stw	ra,24(sp)
     64c:	dcc00515 	stw	r19,20(sp)
  struct fs_file file;
  struct http_state *hs;

  hs = arg;

  if (err == ERR_OK && p != NULL) {
     650:	39ffe004 	addi	r7,r7,-128
  return ERR_OK;
}
/*-----------------------------------------------------------------------------------*/
static err_t
http_recv(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
     654:	2023883a 	mov	r17,r4
     658:	2825883a 	mov	r18,r5
     65c:	3021883a 	mov	r16,r6
  struct fs_file file;
  struct http_state *hs;

  hs = arg;

  if (err == ERR_OK && p != NULL) {
     660:	3800081e 	bne	r7,zero,684 <http_recv+0x54>
     664:	30000f26 	beq	r6,zero,6a4 <http_recv+0x74>

    /* Inform TCP that we have taken the data. */
    tcp_recved(pcb, p->tot_len);
     668:	3140020b 	ldhu	r5,8(r6)
     66c:	9009883a 	mov	r4,r18
     670:	0007df80 	call	7df8 <tcp_recved>
    
    if (hs->file == NULL) {
     674:	88800117 	ldw	r2,4(r17)
     678:	10001526 	beq	r2,zero,6d0 <http_recv+0xa0>
      } else {
        pbuf_free(p);
        close_conn(pcb, hs);
      }
    } else {
      pbuf_free(p);
     67c:	8009883a 	mov	r4,r16
     680:	00067d80 	call	67d8 <pbuf_free>

  if (err == ERR_OK && p == NULL) {
    close_conn(pcb, hs);
  }
  return ERR_OK;
}
     684:	0005883a 	mov	r2,zero
     688:	dfc00617 	ldw	ra,24(sp)
     68c:	dcc00517 	ldw	r19,20(sp)
     690:	dc800417 	ldw	r18,16(sp)
     694:	dc400317 	ldw	r17,12(sp)
     698:	dc000217 	ldw	r16,8(sp)
     69c:	dec00704 	addi	sp,sp,28
     6a0:	f800283a 	ret
      pbuf_free(p);
    }
  }

  if (err == ERR_OK && p == NULL) {
    close_conn(pcb, hs);
     6a4:	2809883a 	mov	r4,r5
     6a8:	880b883a 	mov	r5,r17
     6ac:	00005d80 	call	5d8 <close_conn>
  }
  return ERR_OK;
}
     6b0:	0005883a 	mov	r2,zero
     6b4:	dfc00617 	ldw	ra,24(sp)
     6b8:	dcc00517 	ldw	r19,20(sp)
     6bc:	dc800417 	ldw	r18,16(sp)
     6c0:	dc400317 	ldw	r17,12(sp)
     6c4:	dc000217 	ldw	r16,8(sp)
     6c8:	dec00704 	addi	sp,sp,28
     6cc:	f800283a 	ret

    /* Inform TCP that we have taken the data. */
    tcp_recved(pcb, p->tot_len);
    
    if (hs->file == NULL) {
      data = p->payload;
     6d0:	84c00117 	ldw	r19,4(r16)
      
      if (strncmp(data, "GET ", 4) == 0) {
     6d4:	014000b4 	movhi	r5,2
     6d8:	2950af04 	addi	r5,r5,17084
     6dc:	01800104 	movi	r6,4
     6e0:	9809883a 	mov	r4,r19
     6e4:	00107e80 	call	107e8 <strncmp>
     6e8:	1000311e 	bne	r2,zero,7b0 <http_recv+0x180>

  return ERR_OK;
}
/*-----------------------------------------------------------------------------------*/
static err_t
http_recv(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
     6ec:	99000104 	addi	r4,r19,4
     6f0:	2005883a 	mov	r2,r4
     6f4:	000f883a 	mov	r7,zero
     6f8:	02400344 	movi	r9,13
     6fc:	01800804 	movi	r6,32
     700:	01400284 	movi	r5,10
    
    if (hs->file == NULL) {
      data = p->payload;
      
      if (strncmp(data, "GET ", 4) == 0) {
        for(i = 0; i < 40; i++) {
     704:	02000a04 	movi	r8,40
     708:	00000406 	br	71c <http_recv+0xec>
     70c:	19800626 	beq	r3,r6,728 <http_recv+0xf8>
     710:	19400526 	beq	r3,r5,728 <http_recv+0xf8>
     714:	10800044 	addi	r2,r2,1
     718:	3a000526 	beq	r7,r8,730 <http_recv+0x100>
     71c:	10c00007 	ldb	r3,0(r2)
     720:	39c00044 	addi	r7,r7,1
     724:	1a7ff91e 	bne	r3,r9,70c <http_recv+0xdc>
          if (((char *)data + 4)[i] == ' ' ||
             ((char *)data + 4)[i] == '\r' ||
             ((char *)data + 4)[i] == '\n') {
            ((char *)data + 4)[i] = 0;
     728:	10000005 	stb	zero,0(r2)
     72c:	003ff906 	br	714 <http_recv+0xe4>
          }
        }

        if (*(char *)(data + 4) == '/' &&
     730:	98c00107 	ldb	r3,4(r19)
     734:	00800bc4 	movi	r2,47
     738:	18801126 	beq	r3,r2,780 <http_recv+0x150>
           *(char *)(data + 5) == 0) {
          fs_open("/index.html", &file);
        } else if (!fs_open((char *)data + 4, &file)) {
     73c:	d80b883a 	mov	r5,sp
     740:	00003c00 	call	3c0 <fs_open>
     744:	10001526 	beq	r2,zero,79c <http_recv+0x16c>
          fs_open("/404.html", &file);
        }

        hs->file = file.data;
     748:	d8800017 	ldw	r2,0(sp)
        LWIP_ASSERT((file.len >= 0), "File length must be positive!");
        hs->left = file.len;
        /* printf("data %p len %ld\n", hs->file, hs->left);*/

        pbuf_free(p);
     74c:	8009883a 	mov	r4,r16
          fs_open("/index.html", &file);
        } else if (!fs_open((char *)data + 4, &file)) {
          fs_open("/404.html", &file);
        }

        hs->file = file.data;
     750:	88800115 	stw	r2,4(r17)
        LWIP_ASSERT((file.len >= 0), "File length must be positive!");
        hs->left = file.len;
     754:	d8800117 	ldw	r2,4(sp)
     758:	88800015 	stw	r2,0(r17)
        /* printf("data %p len %ld\n", hs->file, hs->left);*/

        pbuf_free(p);
     75c:	00067d80 	call	67d8 <pbuf_free>
        send_data(pcb, hs);
     760:	9009883a 	mov	r4,r18
     764:	880b883a 	mov	r5,r17
     768:	00005140 	call	514 <send_data>

        /* Tell TCP that we wish be to informed of data that has been
           successfully sent by a call to the http_sent() function. */
        tcp_sent(pcb, http_sent);
     76c:	9009883a 	mov	r4,r18
     770:	01400034 	movhi	r5,0
     774:	2941f204 	addi	r5,r5,1992
     778:	0007ffc0 	call	7ffc <tcp_sent>
     77c:	003fc106 	br	684 <http_recv+0x54>
             ((char *)data + 4)[i] == '\n') {
            ((char *)data + 4)[i] = 0;
          }
        }

        if (*(char *)(data + 4) == '/' &&
     780:	98800147 	ldb	r2,5(r19)
     784:	103fed1e 	bne	r2,zero,73c <http_recv+0x10c>
           *(char *)(data + 5) == 0) {
          fs_open("/index.html", &file);
     788:	010000b4 	movhi	r4,2
     78c:	2110b104 	addi	r4,r4,17092
     790:	d80b883a 	mov	r5,sp
     794:	00003c00 	call	3c0 <fs_open>
     798:	003feb06 	br	748 <http_recv+0x118>
        } else if (!fs_open((char *)data + 4, &file)) {
          fs_open("/404.html", &file);
     79c:	010000b4 	movhi	r4,2
     7a0:	2110b404 	addi	r4,r4,17104
     7a4:	d80b883a 	mov	r5,sp
     7a8:	00003c00 	call	3c0 <fs_open>
     7ac:	003fe606 	br	748 <http_recv+0x118>

        /* Tell TCP that we wish be to informed of data that has been
           successfully sent by a call to the http_sent() function. */
        tcp_sent(pcb, http_sent);
      } else {
        pbuf_free(p);
     7b0:	8009883a 	mov	r4,r16
     7b4:	00067d80 	call	67d8 <pbuf_free>
        close_conn(pcb, hs);
     7b8:	9009883a 	mov	r4,r18
     7bc:	880b883a 	mov	r5,r17
     7c0:	00005d80 	call	5d8 <close_conn>
     7c4:	003faf06 	br	684 <http_recv+0x54>

000007c8 <http_sent>:
  return ERR_OK;
}
/*-----------------------------------------------------------------------------------*/
static err_t
http_sent(void *arg, struct tcp_pcb *pcb, u16_t len)
{
     7c8:	deffff04 	addi	sp,sp,-4

  hs = arg;

  hs->retries = 0;
  
  if (hs->left > 0) {    
     7cc:	20c00017 	ldw	r3,0(r4)
  return ERR_OK;
}
/*-----------------------------------------------------------------------------------*/
static err_t
http_sent(void *arg, struct tcp_pcb *pcb, u16_t len)
{
     7d0:	dfc00015 	stw	ra,0(sp)
     7d4:	2005883a 	mov	r2,r4

  LWIP_UNUSED_ARG(len);

  hs = arg;

  hs->retries = 0;
     7d8:	20000205 	stb	zero,8(r4)
  return ERR_OK;
}
/*-----------------------------------------------------------------------------------*/
static err_t
http_sent(void *arg, struct tcp_pcb *pcb, u16_t len)
{
     7dc:	2809883a 	mov	r4,r5
  hs = arg;

  hs->retries = 0;
  
  if (hs->left > 0) {    
    send_data(pcb, hs);
     7e0:	100b883a 	mov	r5,r2

  hs = arg;

  hs->retries = 0;
  
  if (hs->left > 0) {    
     7e4:	1800051e 	bne	r3,zero,7fc <http_sent+0x34>
    send_data(pcb, hs);
  } else {
    close_conn(pcb, hs);
     7e8:	00005d80 	call	5d8 <close_conn>
  }

  return ERR_OK;
}
     7ec:	0005883a 	mov	r2,zero
     7f0:	dfc00017 	ldw	ra,0(sp)
     7f4:	dec00104 	addi	sp,sp,4
     7f8:	f800283a 	ret
  hs = arg;

  hs->retries = 0;
  
  if (hs->left > 0) {    
    send_data(pcb, hs);
     7fc:	00005140 	call	514 <send_data>
  } else {
    close_conn(pcb, hs);
  }

  return ERR_OK;
}
     800:	0005883a 	mov	r2,zero
     804:	dfc00017 	ldw	ra,0(sp)
     808:	dec00104 	addi	sp,sp,4
     80c:	f800283a 	ret

00000810 <http_poll>:
  }
}
/*-----------------------------------------------------------------------------------*/
static err_t
http_poll(void *arg, struct tcp_pcb *pcb)
{
     810:	defffd04 	addi	sp,sp,-12
     814:	dc400115 	stw	r17,4(sp)
     818:	dc000015 	stw	r16,0(sp)
     81c:	dfc00215 	stw	ra,8(sp)
     820:	2021883a 	mov	r16,r4
     824:	2823883a 	mov	r17,r5
  struct http_state *hs;

  hs = arg;
  
  /*  printf("Polll\n");*/
  if ((hs == NULL) && (pcb->state == ESTABLISHED)) {
     828:	20000f26 	beq	r4,zero,868 <http_poll+0x58>
    /*    printf("Null, close\n");*/
    tcp_abort(pcb);
    return ERR_ABRT;
  } else if (hs != NULL) {
    ++hs->retries;
     82c:	20800203 	ldbu	r2,8(r4)
    if (hs->retries == 4) {
     830:	00c00104 	movi	r3,4
  if ((hs == NULL) && (pcb->state == ESTABLISHED)) {
    /*    printf("Null, close\n");*/
    tcp_abort(pcb);
    return ERR_ABRT;
  } else if (hs != NULL) {
    ++hs->retries;
     834:	10800044 	addi	r2,r2,1
     838:	20800205 	stb	r2,8(r4)
    if (hs->retries == 4) {
     83c:	10803fcc 	andi	r2,r2,255
     840:	10c01126 	beq	r2,r3,888 <http_poll+0x78>
      tcp_arg(pcb, NULL);
      mem_free(hs);
      tcp_abort(pcb);
      return ERR_ABRT;
    }
    send_data(pcb, hs);
     844:	2809883a 	mov	r4,r5
     848:	800b883a 	mov	r5,r16
     84c:	00005140 	call	514 <send_data>
  }

  return ERR_OK;
     850:	0005883a 	mov	r2,zero
}
     854:	dfc00217 	ldw	ra,8(sp)
     858:	dc400117 	ldw	r17,4(sp)
     85c:	dc000017 	ldw	r16,0(sp)
     860:	dec00304 	addi	sp,sp,12
     864:	f800283a 	ret
  struct http_state *hs;

  hs = arg;
  
  /*  printf("Polll\n");*/
  if ((hs == NULL) && (pcb->state == ESTABLISHED)) {
     868:	29000617 	ldw	r4,24(r5)
     86c:	00c00104 	movi	r3,4
      return ERR_ABRT;
    }
    send_data(pcb, hs);
  }

  return ERR_OK;
     870:	0005883a 	mov	r2,zero
  struct http_state *hs;

  hs = arg;
  
  /*  printf("Polll\n");*/
  if ((hs == NULL) && (pcb->state == ESTABLISHED)) {
     874:	20fff71e 	bne	r4,r3,854 <http_poll+0x44>
  } else if (hs != NULL) {
    ++hs->retries;
    if (hs->retries == 4) {
      tcp_arg(pcb, NULL);
      mem_free(hs);
      tcp_abort(pcb);
     878:	8809883a 	mov	r4,r17
     87c:	00089ec0 	call	89ec <tcp_abort>
     880:	00bffd84 	movi	r2,-10
     884:	003ff306 	br	854 <http_poll+0x44>
    tcp_abort(pcb);
    return ERR_ABRT;
  } else if (hs != NULL) {
    ++hs->retries;
    if (hs->retries == 4) {
      tcp_arg(pcb, NULL);
     888:	8809883a 	mov	r4,r17
     88c:	000b883a 	mov	r5,zero
     890:	0007fac0 	call	7fac <tcp_arg>
      mem_free(hs);
     894:	8009883a 	mov	r4,r16
     898:	0005a100 	call	5a10 <mem_free>
     89c:	003ff606 	br	878 <http_poll+0x68>

000008a0 <httpd_init>:
  return ERR_OK;
}
/*-----------------------------------------------------------------------------------*/
void
httpd_init(void)
{
     8a0:	defffe04 	addi	sp,sp,-8
     8a4:	dfc00115 	stw	ra,4(sp)
     8a8:	dc000015 	stw	r16,0(sp)
  struct tcp_pcb *pcb;

  pcb = tcp_new();
     8ac:	0008bb00 	call	8bb0 <tcp_new>
  tcp_bind(pcb, IP_ADDR_ANY, 80);
     8b0:	01801404 	movi	r6,80
     8b4:	1009883a 	mov	r4,r2
     8b8:	014000f4 	movhi	r5,3
     8bc:	29660004 	addi	r5,r5,-26624
void
httpd_init(void)
{
  struct tcp_pcb *pcb;

  pcb = tcp_new();
     8c0:	1021883a 	mov	r16,r2
  tcp_bind(pcb, IP_ADDR_ANY, 80);
     8c4:	0007b100 	call	7b10 <tcp_bind>
  pcb = tcp_listen(pcb);
     8c8:	8009883a 	mov	r4,r16
     8cc:	01403fc4 	movi	r5,255
     8d0:	0007c240 	call	7c24 <tcp_listen_with_backlog>
  tcp_arg(pcb, pcb);
     8d4:	1009883a 	mov	r4,r2
     8d8:	100b883a 	mov	r5,r2
{
  struct tcp_pcb *pcb;

  pcb = tcp_new();
  tcp_bind(pcb, IP_ADDR_ANY, 80);
  pcb = tcp_listen(pcb);
     8dc:	1021883a 	mov	r16,r2
  tcp_arg(pcb, pcb);
     8e0:	0007fac0 	call	7fac <tcp_arg>
  tcp_accept(pcb, http_accept);
     8e4:	8009883a 	mov	r4,r16
     8e8:	01400034 	movhi	r5,0
     8ec:	29411104 	addi	r5,r5,1092
}
     8f0:	dfc00117 	ldw	ra,4(sp)
     8f4:	dc000017 	ldw	r16,0(sp)
     8f8:	dec00204 	addi	sp,sp,8

  pcb = tcp_new();
  tcp_bind(pcb, IP_ADDR_ANY, 80);
  pcb = tcp_listen(pcb);
  tcp_arg(pcb, pcb);
  tcp_accept(pcb, http_accept);
     8fc:	000808c1 	jmpi	808c <tcp_accept>

00000900 <tse_sgdma_read_init>:
 */
int tse_sgdma_read_init(lwip_tse_info* tse_ptr)
{     
   struct ethernetif *ethernetif;
  
   ethernetif = tse_ptr->ethernetif;
     900:	20800617 	ldw	r2,24(r4)
  
   alt_avalon_sgdma_construct_stream_to_mem_desc(
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
     904:	21400517 	ldw	r5,20(r4)
 * 
 * @API TYPE - Internal
 * @return SUCCESS on success 
 */
int tse_sgdma_read_init(lwip_tse_info* tse_ptr)
{     
     908:	defffd04 	addi	sp,sp,-12
   ethernetif = tse_ptr->ethernetif;
  
   alt_avalon_sgdma_construct_stream_to_mem_desc(
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST],  // pointer to "next"
         (alt_u32 *) ethernetif->lwipRxPbuf[tse_ptr->ethernetif->lwipRxIndexIsr]->payload,          // starting write_address
     90c:	10c01317 	ldw	r3,76(r2)
{     
   struct ethernetif *ethernetif;
  
   ethernetif = tse_ptr->ethernetif;
  
   alt_avalon_sgdma_construct_stream_to_mem_desc(
     910:	000f883a 	mov	r7,zero
 * 
 * @API TYPE - Internal
 * @return SUCCESS on success 
 */
int tse_sgdma_read_init(lwip_tse_info* tse_ptr)
{     
     914:	dc000115 	stw	r16,4(sp)
   ethernetif = tse_ptr->ethernetif;
  
   alt_avalon_sgdma_construct_stream_to_mem_desc(
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
         (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST],  // pointer to "next"
         (alt_u32 *) ethernetif->lwipRxPbuf[tse_ptr->ethernetif->lwipRxIndexIsr]->payload,          // starting write_address
     918:	18c001c4 	addi	r3,r3,7
     91c:	18c7883a 	add	r3,r3,r3
     920:	18c7883a 	add	r3,r3,r3
     924:	10c5883a 	add	r2,r2,r3
     928:	10800017 	ldw	r2,0(r2)
 * 
 * @API TYPE - Internal
 * @return SUCCESS on success 
 */
int tse_sgdma_read_init(lwip_tse_info* tse_ptr)
{     
     92c:	2021883a 	mov	r16,r4
   struct ethernetif *ethernetif;
  
   ethernetif = tse_ptr->ethernetif;
  
   alt_avalon_sgdma_construct_stream_to_mem_desc(
     930:	29001004 	addi	r4,r5,64
     934:	11800117 	ldw	r6,4(r2)
     938:	29401804 	addi	r5,r5,96
     93c:	d8000015 	stw	zero,0(sp)
 * 
 * @API TYPE - Internal
 * @return SUCCESS on success 
 */
int tse_sgdma_read_init(lwip_tse_info* tse_ptr)
{     
     940:	dfc00215 	stw	ra,8(sp)
   struct ethernetif *ethernetif;
  
   ethernetif = tse_ptr->ethernetif;
  
   alt_avalon_sgdma_construct_stream_to_mem_desc(
     944:	001d1ec0 	call	1d1ec <alt_avalon_sgdma_construct_stream_to_mem_desc>
         (alt_u32 *) ethernetif->lwipRxPbuf[tse_ptr->ethernetif->lwipRxIndexIsr]->payload,          // starting write_address
         0,                                  // read until EOP
         0);          // don't write to constant address


   printf("[tse_sgdma_read_init] RX descriptor chain desc (%d depth) created\n",0); 
     948:	010000b4 	movhi	r4,2
     94c:	2110b704 	addi	r4,r4,17116
     950:	000b883a 	mov	r5,zero
     954:	00104380 	call	10438 <printf>
   
   tse_mac_aRxRead( &tse_ptr->mi, &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
     958:	81400517 	ldw	r5,20(r16)
     95c:	8009883a 	mov	r4,r16
     960:	29401004 	addi	r5,r5,64
     964:	001df5c0 	call	1df5c <tse_mac_aRxRead>
  
   return SUCCESS;
}
     968:	0005883a 	mov	r2,zero
     96c:	dfc00217 	ldw	ra,8(sp)
     970:	dc000117 	ldw	r16,4(sp)
     974:	dec00304 	addi	sp,sp,12
     978:	f800283a 	ret

0000097c <tse_mac_init>:
 * @API TYPE: Internal
 * @Param iface index of the NET structure associated with TSE instance
 * @Return 0 if ok, else -1 if error
 */
int tse_mac_init(int iface, struct ethernetif *ethernetif)
{
     97c:	defff404 	addi	sp,sp,-48
     980:	dc000215 	stw	r16,8(sp)
     984:	2021883a 	mov	r16,r4
     988:	dcc00515 	stw	r19,20(sp)
     98c:	dc400315 	stw	r17,12(sp)
   alt_sgdma_dev *sgdma_rx_dev;
   alt_tse_system_info* tse_hw = (alt_tse_system_info *) tse[iface].tse;
   np_tse_mac *mi_base;
   alt_tse_mac_info *pmac_info;
   
   dprintf(("[tse_mac_init]\n"));
     990:	010000b4 	movhi	r4,2
     994:	2110c804 	addi	r4,r4,17184
#ifdef PRINTIF
   dprintf(("tse_mac_init %d\n", iface));
#endif    
   // These lines were done in prep_tse_mac 
   tse_hw = &tse_mac_device[iface];	
   tse[iface].tse = tse_hw;
     998:	8026917a 	slli	r19,r16,5
   dprintf(("[tse_mac_init]\n"));
#ifdef PRINTIF
   dprintf(("tse_mac_init %d\n", iface));
#endif    
   // These lines were done in prep_tse_mac 
   tse_hw = &tse_mac_device[iface];	
     99c:	84401224 	muli	r17,r16,72
 * @API TYPE: Internal
 * @Param iface index of the NET structure associated with TSE instance
 * @Return 0 if ok, else -1 if error
 */
int tse_mac_init(int iface, struct ethernetif *ethernetif)
{
     9a0:	dd400715 	stw	r21,28(sp)
     9a4:	dd000615 	stw	r20,24(sp)
     9a8:	dc800415 	stw	r18,16(sp)
     9ac:	dfc00b15 	stw	ra,44(sp)
     9b0:	2825883a 	mov	r18,r5
     9b4:	df000a15 	stw	fp,40(sp)
     9b8:	ddc00915 	stw	r23,36(sp)
     9bc:	dd800815 	stw	r22,32(sp)
   alt_sgdma_dev *sgdma_rx_dev;
   alt_tse_system_info* tse_hw = (alt_tse_system_info *) tse[iface].tse;
   np_tse_mac *mi_base;
   alt_tse_mac_info *pmac_info;
   
   dprintf(("[tse_mac_init]\n"));
     9c0:	00106a40 	call	106a4 <puts>
#ifdef PRINTIF
   dprintf(("tse_mac_init %d\n", iface));
#endif    
   // These lines were done in prep_tse_mac 
   tse_hw = &tse_mac_device[iface];	
     9c4:	008000b4 	movhi	r2,2
     9c8:	109d9604 	addi	r2,r2,30296
   tse[iface].tse = tse_hw;
     9cc:	05000134 	movhi	r20,4
     9d0:	a5280604 	addi	r20,r20,-24552
     9d4:	a4eb883a 	add	r21,r20,r19
   dprintf(("[tse_mac_init]\n"));
#ifdef PRINTIF
   dprintf(("tse_mac_init %d\n", iface));
#endif    
   // These lines were done in prep_tse_mac 
   tse_hw = &tse_mac_device[iface];	
     9d8:	88a3883a 	add	r17,r17,r2
   tse[iface].tse = tse_hw;
     9dc:	ac400715 	stw	r17,28(r21)
	
   // Store ethernetif for access, and the tse in ethernetif for access in tse_mac_raw_send/tse_mac_rcv
   tse[iface].ethernetif = ethernetif;
     9e0:	ac800615 	stw	r18,24(r21)
   ethernetif->iface = iface;
     9e4:	94000115 	stw	r16,4(r18)
   ethernetif->tse_info = &tse[iface];
     9e8:	95401615 	stw	r21,88(r18)

   if (tse_hw->ext_desc_mem == 1)
     9ec:	88c00783 	ldbu	r3,30(r17)
     9f0:	00800044 	movi	r2,1
     9f4:	1880ac26 	beq	r3,r2,ca8 <tse_mac_init+0x32c>
      tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
   else
      {
      unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
     9f8:	01002804 	movi	r4,160
     9fc:	00194980 	call	19498 <alt_uncached_malloc>
    
      while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
     a00:	10c007cc 	andi	r3,r2,31
     a04:	18000326 	beq	r3,zero,a14 <tse_mac_init+0x98>
         temp_desc++;
     a08:	10800044 	addi	r2,r2,1
      tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
   else
      {
      unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
    
      while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
     a0c:	10c007cc 	andi	r3,r2,31
     a10:	183ffd1e 	bne	r3,zero,a08 <tse_mac_init+0x8c>
         temp_desc++;
      tse[iface].desc = (alt_sgdma_descriptor *) temp_desc;
     a14:	a4c7883a 	add	r3,r20,r19
     a18:	18800515 	stw	r2,20(r3)
      }

   
   /* Get the Rx and Tx SGDMA addresses */
   sgdma_tx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_tx);
     a1c:	89000517 	ldw	r4,20(r17)
     a20:	001d5200 	call	1d520 <alt_avalon_sgdma_open>
     a24:	1021883a 	mov	r16,r2
   if(!sgdma_tx_dev) 
     a28:	1000c426 	beq	r2,zero,d3c <tse_mac_init+0x3c0>
      {
      dprintf(("[triple_speed_ethernet_init] Error opening TX SGDMA\n"));
      return ENP_RESOURCE;
      }
  
   sgdma_rx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_rx);
     a2c:	89000617 	ldw	r4,24(r17)
     a30:	001d5200 	call	1d520 <alt_avalon_sgdma_open>
   if(!sgdma_rx_dev) 
     a34:	1000bc26 	beq	r2,zero,d28 <tse_mac_init+0x3ac>
      }


   /* Initialize mtip_mac_trans_info structure with values from <system.h>*/

   tse_mac_initTransInfo2(&tse[iface].mi, (int)tse_hw->tse_mac_base,
     a38:	89400017 	ldw	r5,0(r17)
     a3c:	a4f9883a 	add	fp,r20,r19
     a40:	e009883a 	mov	r4,fp
     a44:	d8000015 	stw	zero,0(sp)
     a48:	800d883a 	mov	r6,r16
     a4c:	100f883a 	mov	r7,r2
     a50:	001deb00 	call	1deb0 <tse_mac_initTransInfo2>
                                   (unsigned int)sgdma_tx_dev,            
                                   (unsigned int)sgdma_rx_dev,
                                   0);
   mi_base = tse[iface].mi.base;

   IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base,ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
     a54:	e0800204 	addi	r2,fp,8
     a58:	10c00017 	ldw	r3,0(r2)

   tse_mac_initTransInfo2(&tse[iface].mi, (int)tse_hw->tse_mac_base,
                                   (unsigned int)sgdma_tx_dev,            
                                   (unsigned int)sgdma_rx_dev,
                                   0);
   mi_base = tse[iface].mi.base;
     a5c:	e5c00017 	ldw	r23,0(fp)

   IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base,ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
     a60:	01000074 	movhi	r4,1
     a64:	18c00317 	ldw	r3,12(r3)
     a68:	19000435 	stwio	r4,16(r3)
   IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base, 0x0);
     a6c:	10800017 	ldw	r2,0(r2)
     a70:	10800317 	ldw	r2,12(r2)
     a74:	10000435 	stwio	zero,16(r2)
   
   /* reset the PHY if necessary */
   result = getPHYSpeed(tse[iface].mi.base);
     a78:	e1000017 	ldw	r4,0(fp)
     a7c:	002000c0 	call	2000c <getPHYSpeed>
     a80:	102d883a 	mov	r22,r2
   speed  = (result >> 1) & 0x07;
   duplex = result & 0x01;

   /* reset the mac */ 
   IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base,
     a84:	e0800017 	ldw	r2,0(fp)
   IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base, 0x0);
   
   /* reset the PHY if necessary */
   result = getPHYSpeed(tse[iface].mi.base);
   speed  = (result >> 1) & 0x07;
   duplex = result & 0x01;
     a88:	b0c0004c 	andi	r3,r22,1
     a8c:	d8c00115 	stw	r3,4(sp)

   /* reset the mac */ 
   IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base,
     a90:	00c800c4 	movi	r3,8195
     a94:	10c00235 	stwio	r3,8(r2)
                             mmac_cc_SW_RESET_mask | 
                             mmac_cc_TX_ENA_mask | 
                             mmac_cc_RX_ENA_mask);
  
   x=0;
     a98:	0021883a 	mov	r16,zero
   while(IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) & 
     a9c:	e00b883a 	mov	r5,fp
         ALTERA_TSEMAC_CMD_SW_RESET_MSK) 
      {
      if( x++ > 10000 ) 
     aa0:	0189c484 	movi	r6,10002
                             mmac_cc_SW_RESET_mask | 
                             mmac_cc_TX_ENA_mask | 
                             mmac_cc_RX_ENA_mask);
  
   x=0;
   while(IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) & 
     aa4:	00000206 	br	ab0 <tse_mac_init+0x134>
         ALTERA_TSEMAC_CMD_SW_RESET_MSK) 
      {
      if( x++ > 10000 ) 
     aa8:	84000044 	addi	r16,r16,1
     aac:	81808426 	beq	r16,r6,cc0 <tse_mac_init+0x344>
                             mmac_cc_SW_RESET_mask | 
                             mmac_cc_TX_ENA_mask | 
                             mmac_cc_RX_ENA_mask);
  
   x=0;
   while(IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) & 
     ab0:	28c00017 	ldw	r3,0(r5)
     ab4:	18c00237 	ldwio	r3,8(r3)
     ab8:	18c8000c 	andi	r3,r3,8192
     abc:	183ffa1e 	bne	r3,zero,aa8 <tse_mac_init+0x12c>
      {
      if( x++ > 10000 ) 
         break;
      }
  
   if(x >= 10000)
     ac0:	0089c3c4 	movi	r2,9999
     ac4:	14007e16 	blt	r2,r16,cc0 <tse_mac_init+0x344>
      dprintf(("TSEMAC SW reset bit never cleared!\n"));

   dat = IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base);
     ac8:	a4c5883a 	add	r2,r20,r19
     acc:	10800017 	ldw	r2,0(r2)
     ad0:	11800237 	ldwio	r6,8(r2)
   if( (dat & 0x03) != 0 ) 
     ad4:	308000cc 	andi	r2,r6,3
     ad8:	10006e1e 	bne	r2,zero,c94 <tse_mac_init+0x318>
      printf("WARN: RX/TX not disabled after reset... missing PHY clock? CMD_CONFIG=0x%08x\n", dat);
   else
      printf("OK, x=%d, CMD_CONFIG=0x%08x\n", x, dat);
     adc:	010000b4 	movhi	r4,2
     ae0:	21110304 	addi	r4,r4,17420
     ae4:	800b883a 	mov	r5,r16
     ae8:	00104380 	call	10438 <printf>
  
   /* Initialize MAC registers */
   IOWR_ALTERA_TSEMAC_FRM_LENGTH(mi_base, PBUF_POOL_BUFSIZE+ETH_PAD_SIZE); 
     aec:	00817b84 	movi	r2,1518
     af0:	b8800535 	stwio	r2,20(r23)
   IOWR_ALTERA_TSEMAC_RX_ALMOST_EMPTY(mi_base, 8);
     af4:	00c00204 	movi	r3,8
     af8:	b8c00b35 	stwio	r3,44(r23)
   IOWR_ALTERA_TSEMAC_RX_ALMOST_FULL(mi_base, 8);
     afc:	b8c00c35 	stwio	r3,48(r23)
   IOWR_ALTERA_TSEMAC_TX_ALMOST_EMPTY(mi_base, 8);
     b00:	b8c00d35 	stwio	r3,52(r23)
   IOWR_ALTERA_TSEMAC_TX_ALMOST_FULL(mi_base,  3);
     b04:	008000c4 	movi	r2,3
     b08:	b8800e35 	stwio	r2,56(r23)
   IOWR_ALTERA_TSEMAC_TX_SECTION_EMPTY(mi_base, tse_hw->tse_tx_depth - 16); //1024/4;  
     b0c:	8880010b 	ldhu	r2,4(r17)
     b10:	10bffc04 	addi	r2,r2,-16
     b14:	b8800935 	stwio	r2,36(r23)
   IOWR_ALTERA_TSEMAC_TX_SECTION_FULL(mi_base,  0); //32/4; // start transmit when there are 48 bytes
     b18:	b8000a35 	stwio	zero,40(r23)
   IOWR_ALTERA_TSEMAC_RX_SECTION_EMPTY(mi_base, tse_hw->tse_rx_depth - 16); //4000/4);
     b1c:	8880018b 	ldhu	r2,6(r17)
     b20:	10bffc04 	addi	r2,r2,-16
     b24:	b8800735 	stwio	r2,28(r23)
   IOWR_ALTERA_TSEMAC_RX_SECTION_FULL(mi_base,  0);
     b28:	b8000835 	stwio	zero,32(r23)
   
   /* Enable TX shift 16 for removing two bytes from the start of all transmitted frames */
   IOWR_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK);
     b2c:	a4c7883a 	add	r3,r20,r19
     b30:	18800017 	ldw	r2,0(r3)
     b34:	01000134 	movhi	r4,4
     b38:	11003a35 	stwio	r4,232(r2)
 
   /*
    * check if the MAC supports the 16-bit shift option allowing us
    * to send BIASed frames without copying. Used by the send function later.
    */
   if((IORD_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK) == 0)
     b3c:	18800017 	ldw	r2,0(r3)
     b40:	11003a37 	ldwio	r4,232(r2)
     b44:	2100012c 	andhi	r4,r4,4
     b48:	20007326 	beq	r4,zero,d18 <tse_mac_init+0x39c>
      dprintf(("[tse_mac_init] Error: Incompatible %d value with TX_CMD_STAT register return TxShift16 value. \n",ETH_PAD_SIZE));
      return ERR_IF;
      }
  
   /* Enable RX shift 16 for alignment of all received frames on 16-bit start address */
   IOWR_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK);
     b4c:	01008034 	movhi	r4,512
     b50:	11003b35 	stwio	r4,236(r2)
 
   /* check if the MAC supports the 16-bit shift option at the RX CMD STATUS Register  */ 
   if((IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK) == 0)
     b54:	18800017 	ldw	r2,0(r3)
     b58:	10803b37 	ldwio	r2,236(r2)
     b5c:	1104703a 	and	r2,r2,r4
     b60:	10006d26 	beq	r2,zero,d18 <tse_mac_init+0x39c>
         ALTERA_TSEMAC_CMD_LOOPBACK_MSK     |     // promiscuous mode
#endif
         ALTERA_TSEMAC_CMD_TX_ADDR_INS_MSK  |
         ALTERA_TSEMAC_CMD_RX_ERR_DISC_MSK;  /* automatically discard frames with CRC errors */
    
   if((result & ALT_TSE_E_AN_NOT_COMPLETE) == 0) 
     b64:	b080022c 	andhi	r2,r22,8
     b68:	1000081e 	bne	r2,zero,b8c <tse_mac_init+0x210>
      {
	  speed = (result >> 1) & 0x07;
     b6c:	b00fd07a 	srai	r7,r22,1
	  duplex = result & 0x01;
  
      /* 1000 Mbps */
      if(speed == 0x01)
     b70:	00800044 	movi	r2,1
         ALTERA_TSEMAC_CMD_TX_ADDR_INS_MSK  |
         ALTERA_TSEMAC_CMD_RX_ERR_DISC_MSK;  /* automatically discard frames with CRC errors */
    
   if((result & ALT_TSE_E_AN_NOT_COMPLETE) == 0) 
      {
	  speed = (result >> 1) & 0x07;
     b74:	39c001cc 	andi	r7,r7,7
	  duplex = result & 0x01;
  
      /* 1000 Mbps */
      if(speed == 0x01)
     b78:	38805b26 	beq	r7,r2,ce8 <tse_mac_init+0x36c>
         dat |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
         dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
         tse[iface].ethernetif->link_speed = 1000;
         }
      /* 100 Mbps */
      else if(speed == 0x02)
     b7c:	00800084 	movi	r2,2
     b80:	38805f26 	beq	r7,r2,d00 <tse_mac_init+0x384>
         dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
         dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
         tse[iface].ethernetif->link_speed = 100;
         }
      /* 10 Mbps */
      else if(speed == 0x04)
     b84:	00800104 	movi	r2,4
     b88:	38805126 	beq	r7,r2,cd0 <tse_mac_init+0x354>
     b8c:	18800617 	ldw	r2,24(r3)
      dprintf(("[tse_mac_init] Error: Incompatible %d value with RX_CMD_STAT register return RxShift16 value. \n",ETH_PAD_SIZE));
      return ERR_IF;
      }
   
   /* enable MAC */
   dat = ALTERA_TSEMAC_CMD_TX_ENA_MSK       |
     b90:	00c10034 	movhi	r3,1024
     b94:	18c080c4 	addi	r3,r3,515
      dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
      dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
      }
  
   /* Half Duplex */
   if(duplex == TSE_PHY_DUPLEX_HALF)
     b98:	d9000117 	ldw	r4,4(sp)
     b9c:	2000451e 	bne	r4,zero,cb4 <tse_mac_init+0x338>
      {
      dat |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
     ba0:	18c10014 	ori	r3,r3,1024
      tse[iface].ethernetif->full_duplex = 0;
     ba4:	10000415 	stw	zero,16(r2)
      {
      dat &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
      tse[iface].ethernetif->full_duplex = 1;
      }
          
   IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base, dat);
     ba8:	a4e7883a 	add	r19,r20,r19
     bac:	98800017 	ldw	r2,0(r19)
     bb0:	10c00235 	stwio	r3,8(r2)
   printf("\nMAC post-initialization: CMD_CONFIG=0x%08x\n", 
     bb4:	98800017 	ldw	r2,0(r19)
     bb8:	11400237 	ldwio	r5,8(r2)
     bbc:	010000b4 	movhi	r4,2
     bc0:	21110b04 	addi	r4,r4,17452
     bc4:	00104380 	call	10438 <printf>
    IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base));
  
   /* Set the MAC address */
     IOWR_ALTERA_TSEMAC_MAC_0(mi_base,
     bc8:	90800017 	ldw	r2,0(r18)
     bcc:	11800043 	ldbu	r6,1(r2)
     bd0:	11400083 	ldbu	r5,2(r2)
     bd4:	10c000c3 	ldbu	r3,3(r2)
     bd8:	300c923a 	slli	r6,r6,8
     bdc:	280a943a 	slli	r5,r5,16
     be0:	11000003 	ldbu	r4,0(r2)
     be4:	1806963a 	slli	r3,r3,24
     be8:	3144b03a 	or	r2,r6,r5
     bec:	1104b03a 	or	r2,r2,r4
     bf0:	10c4b03a 	or	r2,r2,r3
     bf4:	b8800335 	stwio	r2,12(r23)
                             ((int)((unsigned char) ethernetif->ethaddr->addr[0]) |
                              (int)((unsigned char) ethernetif->ethaddr->addr[1] <<  8) |
                              (int)((unsigned char) ethernetif->ethaddr->addr[2] << 16) |
                              (int)((unsigned char) ethernetif->ethaddr->addr[3] << 24)));

     IOWR_ALTERA_TSEMAC_MAC_1(mi_base,
     bf8:	90800017 	ldw	r2,0(r18)
     bfc:	11000143 	ldbu	r4,5(r2)
     c00:	10c00103 	ldbu	r3,4(r2)
     c04:	2004923a 	slli	r2,r4,8
     c08:	10c4b03a 	or	r2,r2,r3
     c0c:	b8800435 	stwio	r2,16(r23)
                             (((int)((unsigned char) ethernetif->ethaddr->addr[4]) |
                               (int)((unsigned char) ethernetif->ethaddr->addr[5] <<  8)) & 0xFFFF));
                                
   alt_avalon_sgdma_register_callback(tse[iface].mi.rx_sgdma,
     c10:	99000217 	ldw	r4,8(r19)
     c14:	01800604 	movi	r6,24
     c18:	a80f883a 	mov	r7,r21
     c1c:	01400034 	movhi	r5,0
     c20:	2943d204 	addi	r5,r5,3912
     c24:	001d3c00 	call	1d3c0 <alt_avalon_sgdma_register_callback>
#else
        (alt_avalon_sgdma_callback)&ALTERA_TSE_IRQ_R,
#endif
        (alt_u16)ALTERA_TSE_SGDMA_INTR_MASK,(void*)(&tse[iface]));
    
   tse_sgdma_read_init(&tse[iface]);
     c28:	a809883a 	mov	r4,r21
     c2c:	00009000 	call	900 <tse_sgdma_read_init>
   //tse_sgdma_write_init(&tse[iface]);
   

   pmac_info = alt_tse_get_mac_info(mi_base);
     c30:	b809883a 	mov	r4,r23
     c34:	001e6400 	call	1e640 <alt_tse_get_mac_info>
   alt_tse_phy_wr_mdio_addr(pmac_info->pphy_info, pmac_info->pphy_info->mdio_address);
     c38:	11000117 	ldw	r4,4(r2)
    
   tse_sgdma_read_init(&tse[iface]);
   //tse_sgdma_write_init(&tse[iface]);
   

   pmac_info = alt_tse_get_mac_info(mi_base);
     c3c:	1021883a 	mov	r16,r2
   alt_tse_phy_wr_mdio_addr(pmac_info->pphy_info, pmac_info->pphy_info->mdio_address);
     c40:	21400003 	ldbu	r5,0(r4)
     c44:	001e7800 	call	1e780 <alt_tse_phy_wr_mdio_addr>
   ethernetif->link_alive = alt_tse_phy_rd_mdio_reg(pmac_info->pphy_info, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) != 0;
     c48:	81000117 	ldw	r4,4(r16)
     c4c:	01400044 	movi	r5,1
     c50:	01800144 	movi	r6,5
     c54:	280f883a 	mov	r7,r5
     c58:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
     c5c:	1004c03a 	cmpne	r2,r2,zero
     c60:	90800215 	stw	r2,8(r18)
   //IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base, 0x0);
   //IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma, 0xff);
   

   return ethernetif->link_alive;
}
     c64:	dfc00b17 	ldw	ra,44(sp)
     c68:	df000a17 	ldw	fp,40(sp)
     c6c:	ddc00917 	ldw	r23,36(sp)
     c70:	dd800817 	ldw	r22,32(sp)
     c74:	dd400717 	ldw	r21,28(sp)
     c78:	dd000617 	ldw	r20,24(sp)
     c7c:	dcc00517 	ldw	r19,20(sp)
     c80:	dc800417 	ldw	r18,16(sp)
     c84:	dc400317 	ldw	r17,12(sp)
     c88:	dc000217 	ldw	r16,8(sp)
     c8c:	dec00c04 	addi	sp,sp,48
     c90:	f800283a 	ret
   if(x >= 10000)
      dprintf(("TSEMAC SW reset bit never cleared!\n"));

   dat = IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base);
   if( (dat & 0x03) != 0 ) 
      printf("WARN: RX/TX not disabled after reset... missing PHY clock? CMD_CONFIG=0x%08x\n", dat);
     c94:	010000b4 	movhi	r4,2
     c98:	2110ef04 	addi	r4,r4,17340
     c9c:	300b883a 	mov	r5,r6
     ca0:	00104380 	call	10438 <printf>
     ca4:	003f9106 	br	aec <tse_mac_init+0x170>
   tse[iface].ethernetif = ethernetif;
   ethernetif->iface = iface;
   ethernetif->tse_info = &tse[iface];

   if (tse_hw->ext_desc_mem == 1)
      tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
     ca8:	88800817 	ldw	r2,32(r17)
     cac:	a8800515 	stw	r2,20(r21)
     cb0:	003f5a06 	br	a1c <tse_mac_init+0xa0>
      }
   /* Full Duplex */
   else
      {
      dat &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
      tse[iface].ethernetif->full_duplex = 1;
     cb4:	01000044 	movi	r4,1
     cb8:	11000415 	stw	r4,16(r2)
     cbc:	003fba06 	br	ba8 <tse_mac_init+0x22c>
      if( x++ > 10000 ) 
         break;
      }
  
   if(x >= 10000)
      dprintf(("TSEMAC SW reset bit never cleared!\n"));
     cc0:	010000b4 	movhi	r4,2
     cc4:	2110e604 	addi	r4,r4,17304
     cc8:	00106a40 	call	106a4 <puts>
     ccc:	003f7e06 	br	ac8 <tse_mac_init+0x14c>
      /* 10 Mbps */
      else if(speed == 0x04)
         {
         dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
         dat |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
         tse[iface].ethernetif->link_speed = 10;
     cd0:	18800617 	ldw	r2,24(r3)
     cd4:	01000284 	movi	r4,10
         }
      /* 10 Mbps */
      else if(speed == 0x04)
         {
         dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
         dat |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
     cd8:	00c18034 	movhi	r3,1536
     cdc:	18c080c4 	addi	r3,r3,515
         tse[iface].ethernetif->link_speed = 10;
     ce0:	11000315 	stw	r4,12(r2)
     ce4:	003fac06 	br	b98 <tse_mac_init+0x21c>
      /* 1000 Mbps */
      if(speed == 0x01)
         {
         dat |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
         dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
         tse[iface].ethernetif->link_speed = 1000;
     ce8:	18800617 	ldw	r2,24(r3)
     cec:	0100fa04 	movi	r4,1000
  
      /* 1000 Mbps */
      if(speed == 0x01)
         {
         dat |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
         dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
     cf0:	00c10034 	movhi	r3,1024
     cf4:	18c082c4 	addi	r3,r3,523
         tse[iface].ethernetif->link_speed = 1000;
     cf8:	11000315 	stw	r4,12(r2)
     cfc:	003fa606 	br	b98 <tse_mac_init+0x21c>
      /* 100 Mbps */
      else if(speed == 0x02)
         {
         dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
         dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
         tse[iface].ethernetif->link_speed = 100;
     d00:	18800617 	ldw	r2,24(r3)
     d04:	01001904 	movi	r4,100
         }
      /* 100 Mbps */
      else if(speed == 0x02)
         {
         dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
         dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
     d08:	00c10034 	movhi	r3,1024
     d0c:	18c080c4 	addi	r3,r3,515
         tse[iface].ethernetif->link_speed = 100;
     d10:	11000315 	stw	r4,12(r2)
     d14:	003fa006 	br	b98 <tse_mac_init+0x21c>
    * check if the MAC supports the 16-bit shift option allowing us
    * to send BIASed frames without copying. Used by the send function later.
    */
   if((IORD_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK) == 0)
      {
      dprintf(("[tse_mac_init] Error: Incompatible %d value with TX_CMD_STAT register return TxShift16 value. \n",ETH_PAD_SIZE));
     d18:	01000084 	movi	r4,2
     d1c:	00104380 	call	10438 <printf>
      return ERR_IF;
     d20:	00bffc44 	movi	r2,-15
     d24:	003fcf06 	br	c64 <tse_mac_init+0x2e8>
      }
  
   sgdma_rx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_rx);
   if(!sgdma_rx_dev) 
      {
      dprintf(("[triple_speed_ethernet_init] Error opening RX SGDMA\n"));
     d28:	010000b4 	movhi	r4,2
     d2c:	2110d904 	addi	r4,r4,17252
     d30:	00106a40 	call	106a4 <puts>
      return ENP_RESOURCE;
     d34:	00bffa84 	movi	r2,-22
     d38:	003fca06 	br	c64 <tse_mac_init+0x2e8>
   
   /* Get the Rx and Tx SGDMA addresses */
   sgdma_tx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_tx);
   if(!sgdma_tx_dev) 
      {
      dprintf(("[triple_speed_ethernet_init] Error opening TX SGDMA\n"));
     d3c:	010000b4 	movhi	r4,2
     d40:	2110cc04 	addi	r4,r4,17200
     d44:	00106a40 	call	106a4 <puts>
      return ENP_RESOURCE;
     d48:	00bffa84 	movi	r2,-22
     d4c:	003fc506 	br	c64 <tse_mac_init+0x2e8>

00000d50 <tse_mac_raw_send>:
 * @param  data - pointer to the data payload
 * @param  data_bytes - number of bytes of the data payload to be sent to the MAC
 * @return SUCCESS if success, else a negative value
 */
err_t tse_mac_raw_send(struct netif *netif, struct pbuf *pkt)
{
     d50:	defe7004 	addi	sp,sp,-1600
     d54:	dcc18d15 	stw	r19,1588(sp)
   struct ethernetif  *ethernetif;
   unsigned int       *ActualData;

   /* Intermediate buffers used for temporary copy of frames that cannot be directrly DMA'ed*/
   char buf2[1560];
   ethernetif = netif->state;
     d58:	24c00717 	ldw	r19,28(r4)
 * @param  data - pointer to the data payload
 * @param  data_bytes - number of bytes of the data payload to be sent to the MAC
 * @return SUCCESS if success, else a negative value
 */
err_t tse_mac_raw_send(struct netif *netif, struct pbuf *pkt)
{
     d5c:	dd018e15 	stw	r20,1592(sp)
     d60:	dc818c15 	stw	r18,1584(sp)
     d64:	dc018a15 	stw	r16,1576(sp)
     d68:	dfc18f15 	stw	ra,1596(sp)
     d6c:	dc418b15 	stw	r17,1580(sp)
     d70:	2829883a 	mov	r20,r5
   char buf2[1560];
   ethernetif = netif->state;
   tse_ptr = ethernetif->tse_info;
   mi = &tse_ptr->mi;
  
   for(p = pkt; p != NULL; p = p->next)
     d74:	2821883a 	mov	r16,r5
   unsigned int       *ActualData;

   /* Intermediate buffers used for temporary copy of frames that cannot be directrly DMA'ed*/
   char buf2[1560];
   ethernetif = netif->state;
   tse_ptr = ethernetif->tse_info;
     d78:	9c801617 	ldw	r18,88(r19)
   mi = &tse_ptr->mi;
  
   for(p = pkt; p != NULL; p = p->next)
     d7c:	2800181e 	bne	r5,zero,de0 <tse_mac_raw_send+0x90>
     d80:	00002006 	br	e04 <tse_mac_raw_send+0xb4>
          */
         memcpy(buf2,data,len);
         data = (alt_u32 *)buf2;
         }  
       
      ActualData = (void *)alt_remap_uncached (data, len);
     d84:	2809883a 	mov	r4,r5
     d88:	880b883a 	mov	r5,r17
     d8c:	00191880 	call	19188 <alt_remap_uncached>
      /* Write data to Tx FIFO using the DMA */
      alt_avalon_sgdma_construct_mem_to_stream_desc(
     d90:	8507003a 	cmpeq	r3,r16,r20
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST], // descriptor I want to work with
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_TX_SGDMA_DESC_OFST],// pointer to "next"
     d94:	91000517 	ldw	r4,20(r18)
         data = (alt_u32 *)buf2;
         }  
       
      ActualData = (void *)alt_remap_uncached (data, len);
      /* Write data to Tx FIFO using the DMA */
      alt_avalon_sgdma_construct_mem_to_stream_desc(
     d98:	d8000015 	stw	zero,0(sp)
     d9c:	d8c00115 	stw	r3,4(sp)
     da0:	80c00017 	ldw	r3,0(r16)
     da4:	21400804 	addi	r5,r4,32
     da8:	100d883a 	mov	r6,r2
     dac:	1807003a 	cmpeq	r3,r3,zero
     db0:	d8c00215 	stw	r3,8(sp)
     db4:	880f883a 	mov	r7,r17
     db8:	d8000315 	stw	zero,12(sp)
     dbc:	001d2bc0 	call	1d2bc <alt_avalon_sgdma_construct_mem_to_stream_desc>
           0,                                       // don't read from constant address
           p == pkt,                                // generate sop
           p->next == NULL,                         // generate endofpacket signal
           0);                                      // atlantic channel (don't know/don't care: set to 0)

      tx_length = tse_mac_sTxWrite(mi,&tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST]);
     dc0:	91400517 	ldw	r5,20(r18)
     dc4:	9009883a 	mov	r4,r18
     dc8:	001decc0 	call	1decc <tse_mac_sTxWrite>

      ethernetif->bytes_sent += tx_length;
     dcc:	98c00517 	ldw	r3,20(r19)
   char buf2[1560];
   ethernetif = netif->state;
   tse_ptr = ethernetif->tse_info;
   mi = &tse_ptr->mi;
  
   for(p = pkt; p != NULL; p = p->next)
     dd0:	84000017 	ldw	r16,0(r16)
           p->next == NULL,                         // generate endofpacket signal
           0);                                      // atlantic channel (don't know/don't care: set to 0)

      tx_length = tse_mac_sTxWrite(mi,&tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST]);

      ethernetif->bytes_sent += tx_length;
     dd4:	1885883a 	add	r2,r3,r2
     dd8:	98800515 	stw	r2,20(r19)
   char buf2[1560];
   ethernetif = netif->state;
   tse_ptr = ethernetif->tse_info;
   mi = &tse_ptr->mi;
  
   for(p = pkt; p != NULL; p = p->next)
     ddc:	80000926 	beq	r16,zero,e04 <tse_mac_raw_send+0xb4>
      {
      data = p->payload;
     de0:	81400117 	ldw	r5,4(r16)
      len = p->len;
     de4:	8440028b 	ldhu	r17,10(r16)
       
      if(((unsigned long)data & 0x03) != 0) 
     de8:	28c000cc 	andi	r3,r5,3
     dec:	183fe526 	beq	r3,zero,d84 <tse_mac_raw_send+0x34>
         /* 
          * Copy data to temporary buffer <buf2>. This is done because of allignment 
          * issues. The SGDMA cannot copy the data directly from (data + ETH_PAD_SIZE)
          * because it needs a 32-bit alligned address space. 
          */
         memcpy(buf2,data,len);
     df0:	880d883a 	mov	r6,r17
     df4:	d9000404 	addi	r4,sp,16
     df8:	00102380 	call	10238 <memcpy>
         data = (alt_u32 *)buf2;
     dfc:	d9400404 	addi	r5,sp,16
     e00:	003fe006 	br	d84 <tse_mac_raw_send+0x34>

      tx_length = tse_mac_sTxWrite(mi,&tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST]);

      ethernetif->bytes_sent += tx_length;
      }
   LINK_STATS_INC(link.xmit);
     e04:	008001f4 	movhi	r2,7
     e08:	10944804 	addi	r2,r2,20768
     e0c:	10c0000b 	ldhu	r3,0(r2)
     e10:	18c00044 	addi	r3,r3,1
     e14:	10c0000d 	sth	r3,0(r2)

   return ERR_OK;
}
     e18:	0005883a 	mov	r2,zero
     e1c:	dfc18f17 	ldw	ra,1596(sp)
     e20:	dd018e17 	ldw	r20,1592(sp)
     e24:	dcc18d17 	ldw	r19,1588(sp)
     e28:	dc818c17 	ldw	r18,1584(sp)
     e2c:	dc418b17 	ldw	r17,1580(sp)
     e30:	dc018a17 	ldw	r16,1576(sp)
     e34:	dec19004 	addi	sp,sp,1600
     e38:	f800283a 	ret

00000e3c <tse_mac_rcv>:
 * 
 * @API TYPE        - callback internal function
 * @return SUCCESS on success
 */
int tse_mac_rcv(struct ethernetif *ethernetif)
{     
     e3c:	defffc04 	addi	sp,sp,-16
     e40:	dc400215 	stw	r17,8(sp)
   int pklen;
   lwip_tse_info* tse_ptr;
   alt_u32 *uncached_packet_payload;
   struct pbuf *p;
  
   tse_ptr = ethernetif->tse_info;
     e44:	24401617 	ldw	r17,88(r4)
 * 
 * @API TYPE        - callback internal function
 * @return SUCCESS on success
 */
int tse_mac_rcv(struct ethernetif *ethernetif)
{     
     e48:	dc000115 	stw	r16,4(sp)
     e4c:	2021883a 	mov	r16,r4
   lwip_tse_info* tse_ptr;
   alt_u32 *uncached_packet_payload;
   struct pbuf *p;
  
   tse_ptr = ethernetif->tse_info;
   pklen = IORD_16DIRECT(&(tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST].actual_bytes_transferred),0);
     e50:	89400517 	ldw	r5,20(r17)
 * 
 * @API TYPE        - callback internal function
 * @return SUCCESS on success
 */
int tse_mac_rcv(struct ethernetif *ethernetif)
{     
     e54:	dfc00315 	stw	ra,12(sp)
   lwip_tse_info* tse_ptr;
   alt_u32 *uncached_packet_payload;
   struct pbuf *p;
  
   tse_ptr = ethernetif->tse_info;
   pklen = IORD_16DIRECT(&(tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST].actual_bytes_transferred),0);
     e58:	28c01704 	addi	r3,r5,92
     e5c:	1880002b 	ldhuio	r2,0(r3)
   p = ethernetif->lwipRxPbuf[ethernetif->lwipRxIndexIsr];
     e60:	21801317 	ldw	r6,76(r4)
   lwip_tse_info* tse_ptr;
   alt_u32 *uncached_packet_payload;
   struct pbuf *p;
  
   tse_ptr = ethernetif->tse_info;
   pklen = IORD_16DIRECT(&(tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST].actual_bytes_transferred),0);
     e64:	11ffffcc 	andi	r7,r2,65535
   p = ethernetif->lwipRxPbuf[ethernetif->lwipRxIndexIsr];
     e68:	310001c4 	addi	r4,r6,7
     e6c:	2109883a 	add	r4,r4,r4
     e70:	2109883a 	add	r4,r4,r4
     e74:	8109883a 	add	r4,r16,r4
     e78:	21000017 	ldw	r4,0(r4)
   p->tot_len = pklen;
     e7c:	2080020d 	sth	r2,8(r4)
   p->len = pklen;
     e80:	2080028d 	sth	r2,10(r4)
   if ((IORD_ALTERA_TSE_SGDMA_DESC_STATUS(&tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]) & ( ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_CRC_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_PARITY_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK )) == 0)
     e84:	18800037 	ldwio	r2,0(r3)
     e88:	1005d43a 	srai	r2,r2,16
     e8c:	10801fcc 	andi	r2,r2,127
     e90:	10001e1e 	bne	r2,zero,f0c <tse_mac_rcv+0xd0>
      {
      if( ethernetif->lwipRxCount > LWIP_RX_ETH_BUFFER )
     e94:	80801517 	ldw	r2,84(r16)
     e98:	00c00304 	movi	r3,12
     e9c:	18801d16 	blt	r3,r2,f14 <tse_mac_rcv+0xd8>
         LINK_STATS_INC(link.drop);
         dprintf(("No free buffers for rx\n"));
         }
      else 
         {
         ethernetif->bytes_recv += pklen;
     ea0:	80c00617 	ldw	r3,24(r16)
         //  Set up DMA for the next pbuf in the buffer
         ++ethernetif->lwipRxCount;
     ea4:	10800044 	addi	r2,r2,1
     ea8:	80801515 	stw	r2,84(r16)
         LINK_STATS_INC(link.drop);
         dprintf(("No free buffers for rx\n"));
         }
      else 
         {
         ethernetif->bytes_recv += pklen;
     eac:	19cf883a 	add	r7,r3,r7
     eb0:	81c00615 	stw	r7,24(r16)
         //  Set up DMA for the next pbuf in the buffer
         ++ethernetif->lwipRxCount;
         if( ++ethernetif->lwipRxIndexIsr >= LWIP_RX_ETH_BUFFER )
     eb4:	30800044 	addi	r2,r6,1
     eb8:	00c002c4 	movi	r3,11
     ebc:	1880200e 	bge	r3,r2,f40 <tse_mac_rcv+0x104>
            ethernetif->lwipRxIndexIsr = 0;
     ec0:	80001315 	stw	zero,76(r16)
     ec4:	0005883a 	mov	r2,zero
         }
      }      

   uncached_packet_payload = (alt_u32 *) ethernetif->lwipRxPbuf[ethernetif->lwipRxIndexIsr]->payload;
     ec8:	108001c4 	addi	r2,r2,7
     ecc:	1085883a 	add	r2,r2,r2
     ed0:	1085883a 	add	r2,r2,r2
     ed4:	80a1883a 	add	r16,r16,r2
     ed8:	80800017 	ldw	r2,0(r16)
   alt_avalon_sgdma_construct_stream_to_mem_desc(
     edc:	29001004 	addi	r4,r5,64
     ee0:	000f883a 	mov	r7,zero
     ee4:	11800117 	ldw	r6,4(r2)
     ee8:	29401804 	addi	r5,r5,96
     eec:	d8000015 	stw	zero,0(sp)
     ef0:	001d1ec0 	call	1d1ec <alt_avalon_sgdma_construct_stream_to_mem_desc>
         uncached_packet_payload,            // starting write_address
         0,                                  // read until EOP
         0);          // don't write to constant address

   return ERR_OK;
}
     ef4:	0005883a 	mov	r2,zero
     ef8:	dfc00317 	ldw	ra,12(sp)
     efc:	dc400217 	ldw	r17,8(sp)
     f00:	dc000117 	ldw	r16,4(sp)
     f04:	dec00404 	addi	sp,sp,16
     f08:	f800283a 	ret
     f0c:	3005883a 	mov	r2,r6
     f10:	003fed06 	br	ec8 <tse_mac_rcv+0x8c>
   p->len = pklen;
   if ((IORD_ALTERA_TSE_SGDMA_DESC_STATUS(&tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]) & ( ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_CRC_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_PARITY_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK )) == 0)
      {
      if( ethernetif->lwipRxCount > LWIP_RX_ETH_BUFFER )
         {    
         LINK_STATS_INC(link.drop);
     f14:	008001f4 	movhi	r2,7
     f18:	10944804 	addi	r2,r2,20768
     f1c:	10c0018b 	ldhu	r3,6(r2)
         dprintf(("No free buffers for rx\n"));
     f20:	010000b4 	movhi	r4,2
     f24:	21111704 	addi	r4,r4,17500
   p->len = pklen;
   if ((IORD_ALTERA_TSE_SGDMA_DESC_STATUS(&tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]) & ( ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_CRC_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_PARITY_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK )) == 0)
      {
      if( ethernetif->lwipRxCount > LWIP_RX_ETH_BUFFER )
         {    
         LINK_STATS_INC(link.drop);
     f28:	18c00044 	addi	r3,r3,1
     f2c:	10c0018d 	sth	r3,6(r2)
         dprintf(("No free buffers for rx\n"));
     f30:	00106a40 	call	106a4 <puts>
     f34:	80801317 	ldw	r2,76(r16)
     f38:	89400517 	ldw	r5,20(r17)
     f3c:	003fe206 	br	ec8 <tse_mac_rcv+0x8c>
      else 
         {
         ethernetif->bytes_recv += pklen;
         //  Set up DMA for the next pbuf in the buffer
         ++ethernetif->lwipRxCount;
         if( ++ethernetif->lwipRxIndexIsr >= LWIP_RX_ETH_BUFFER )
     f40:	80801315 	stw	r2,76(r16)
     f44:	003fe006 	br	ec8 <tse_mac_rcv+0x8c>

00000f48 <tse_sgdmaRx_isr>:
 */
int tse_sgdmaRx_isr(void * context, u_long intnum)
{
   lwip_tse_info* tse_ptr = (lwip_tse_info *) context;

   IOWR_ALTERA_AVALON_SGDMA_CONTROL(&tse_ptr->mi.rx_sgdma->base,ALTERA_AVALON_SGDMA_CONTROL_CLEAR_INTERRUPT_MSK);
     f48:	20800217 	ldw	r2,8(r4)
 * @API TYPE - callback
 * @param  context  - context of the TSE MAC instance
 * @param  intnum - temporary storage
 */
int tse_sgdmaRx_isr(void * context, u_long intnum)
{
     f4c:	defffe04 	addi	sp,sp,-8
     f50:	dc000015 	stw	r16,0(sp)
     f54:	dfc00115 	stw	ra,4(sp)
     f58:	2021883a 	mov	r16,r4
   lwip_tse_info* tse_ptr = (lwip_tse_info *) context;

   IOWR_ALTERA_AVALON_SGDMA_CONTROL(&tse_ptr->mi.rx_sgdma->base,ALTERA_AVALON_SGDMA_CONTROL_CLEAR_INTERRUPT_MSK);
     f5c:	00e00034 	movhi	r3,32768
     f60:	10c00735 	stwio	r3,28(r2)
   tse_mac_rcv(tse_ptr->ethernetif);    
     f64:	21000617 	ldw	r4,24(r4)
     f68:	0000e3c0 	call	e3c <tse_mac_rcv>
   tse_mac_aRxRead( &tse_ptr->mi, &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
     f6c:	81400517 	ldw	r5,20(r16)
     f70:	8009883a 	mov	r4,r16
     f74:	29401004 	addi	r5,r5,64
     f78:	001df5c0 	call	1df5c <tse_mac_aRxRead>
   IOWR_ALTERA_AVALON_SGDMA_CONTROL(&tse_ptr->mi.rx_sgdma->base, ALTERA_TSE_SGDMA_INTR_MASK);
     f7c:	80800217 	ldw	r2,8(r16)
     f80:	00c00604 	movi	r3,24
     f84:	10c00735 	stwio	r3,28(r2)
  
   return SUCCESS;
}
     f88:	0005883a 	mov	r2,zero
     f8c:	dfc00117 	ldw	ra,4(sp)
     f90:	dc000017 	ldw	r16,0(sp)
     f94:	dec00204 	addi	sp,sp,8
     f98:	f800283a 	ret

00000f9c <udpecho_recv>:
boolean         printed_flg = FALSE;
#endif

void udpecho_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct 
ip_addr *addr, u16_t port)
{
     f9c:	defffe04 	addi	sp,sp,-8
     fa0:	dc000015 	stw	r16,0(sp)
     fa4:	dfc00115 	stw	ra,4(sp)
     fa8:	3021883a 	mov	r16,r6
     fac:	d880020b 	ldhu	r2,8(sp)
        begin_measure(histid);
        measuring_flg = TRUE;
    }
#endif

    if (p != NULL) {
     fb0:	30000726 	beq	r6,zero,fd0 <udpecho_recv+0x34>
        /* send received packet back to sender */
        udp_sendto(pcb, p, addr, port);
     fb4:	2809883a 	mov	r4,r5
     fb8:	300b883a 	mov	r5,r6
     fbc:	380d883a 	mov	r6,r7
     fc0:	11ffffcc 	andi	r7,r2,65535
     fc4:	000d6d80 	call	d6d8 <udp_sendto>
        /* free the pbuf */
        pbuf_free(p);
     fc8:	8009883a 	mov	r4,r16
     fcc:	00067d80 	call	67d8 <pbuf_free>
    }

//#if 0
#if TEST_HISTOGRAM
    // End histogram measure
    if (histid <= TNUM_HIST && measuring_flg == TRUE) {
     fd0:	d1600017 	ldw	r5,-32768(gp)
     fd4:	0089c404 	movi	r2,10000
     fd8:	11401436 	bltu	r2,r5,102c <udpecho_recv+0x90>
     fdc:	d0e8aa17 	ldw	r3,-23896(gp)
     fe0:	00800044 	movi	r2,1
     fe4:	18800426 	beq	r3,r2,ff8 <udpecho_recv+0x5c>
        printed_flg = TRUE;
        print_hist(TNUM_HIST);
    }
#endif

}
     fe8:	dfc00117 	ldw	ra,4(sp)
     fec:	dc000017 	ldw	r16,0(sp)
     ff0:	dec00204 	addi	sp,sp,8
     ff4:	f800283a 	ret
//#if 0
#if TEST_HISTOGRAM
    // End histogram measure
    if (histid <= TNUM_HIST && measuring_flg == TRUE) {
        //printf("[histid: %d] Histogram measuring ending...\n", histid);
        if (end_measure(histid++)) {
     ff8:	2885883a 	add	r2,r5,r2
     ffc:	2809883a 	mov	r4,r5
    1000:	d0a00015 	stw	r2,-32768(gp)
    1004:	00011f40 	call	11f4 <end_measure>
    1008:	1000041e 	bne	r2,zero,101c <udpecho_recv+0x80>
            //printf("%d OK\n", histid);
        } else {
            printf("%d ERR\n", histid);
    100c:	d1600017 	ldw	r5,-32768(gp)
    1010:	010000b4 	movhi	r4,2
    1014:	21112504 	addi	r4,r4,17556
    1018:	00104380 	call	10438 <printf>
        }
        measuring_flg = FALSE;
    }

    // Print histogram results
    if (histid > TNUM_HIST && printed_flg == FALSE) {
    101c:	d1600017 	ldw	r5,-32768(gp)
        if (end_measure(histid++)) {
            //printf("%d OK\n", histid);
        } else {
            printf("%d ERR\n", histid);
        }
        measuring_flg = FALSE;
    1020:	d028aa15 	stw	zero,-23896(gp)
    }

    // Print histogram results
    if (histid > TNUM_HIST && printed_flg == FALSE) {
    1024:	0089c404 	movi	r2,10000
    1028:	117fef2e 	bgeu	r2,r5,fe8 <udpecho_recv+0x4c>
    102c:	d0a8a917 	ldw	r2,-23900(gp)
    1030:	103fed1e 	bne	r2,zero,fe8 <udpecho_recv+0x4c>
        printf("[histid: %d] Printing...\n", histid);
    1034:	010000b4 	movhi	r4,2
    1038:	21112704 	addi	r4,r4,17564
    103c:	00104380 	call	10438 <printf>
        printed_flg = TRUE;
    1040:	00800044 	movi	r2,1
        print_hist(TNUM_HIST);
    1044:	0109c404 	movi	r4,10000
    }

    // Print histogram results
    if (histid > TNUM_HIST && printed_flg == FALSE) {
        printf("[histid: %d] Printing...\n", histid);
        printed_flg = TRUE;
    1048:	d0a8a915 	stw	r2,-23900(gp)
        print_hist(TNUM_HIST);
    }
#endif

}
    104c:	dfc00117 	ldw	ra,4(sp)
    1050:	dc000017 	ldw	r16,0(sp)
    1054:	dec00204 	addi	sp,sp,8

    // Print histogram results
    if (histid > TNUM_HIST && printed_flg == FALSE) {
        printf("[histid: %d] Printing...\n", histid);
        printed_flg = TRUE;
        print_hist(TNUM_HIST);
    1058:	000132c1 	jmpi	132c <print_hist>

0000105c <udpecho_init>:

}


void udpecho_init(void)
{
    105c:	defffe04 	addi	sp,sp,-8
    struct udp_pcb * pcb;
    printf("Initializing udp_init()...\n");
    1060:	010000b4 	movhi	r4,2
    1064:	21112e04 	addi	r4,r4,17592

}


void udpecho_init(void)
{
    1068:	dfc00115 	stw	ra,4(sp)
    106c:	dc000015 	stw	r16,0(sp)
    struct udp_pcb * pcb;
    printf("Initializing udp_init()...\n");
    1070:	00106a40 	call	106a4 <puts>

    /* get new pcb */
    pcb = udp_new();
    1074:	000d89c0 	call	d89c <udp_new>
    1078:	1021883a 	mov	r16,r2
    if (pcb == NULL) {
    107c:	10001a26 	beq	r2,zero,10e8 <udpecho_init+0x8c>
        printf("udp_new failed!\n");
        return;
    }

    /* bind to any IP address on port 7 */
    if (udp_bind(pcb, IP_ADDR_ANY, 7) != ERR_OK) {
    1080:	1009883a 	mov	r4,r2
    1084:	014000f4 	movhi	r5,3
    1088:	29660004 	addi	r5,r5,-26624
    108c:	018001c4 	movi	r6,7
    1090:	000d3680 	call	d368 <udp_bind>
    1094:	10803fcc 	andi	r2,r2,255
    1098:	1080201c 	xori	r2,r2,128
    109c:	10bfe004 	addi	r2,r2,-128
    10a0:	10000b1e 	bne	r2,zero,10d0 <udpecho_init+0x74>
        return;
    }

    /* set udpecho_recv() as callback function
       for received packets */
    printf("Ready to accept UDP packets on port 7\n");
    10a4:	010000b4 	movhi	r4,2
    10a8:	21113e04 	addi	r4,r4,17656
    10ac:	00106a40 	call	106a4 <puts>
    udp_recv(pcb, udpecho_recv, NULL);
    10b0:	8009883a 	mov	r4,r16
    10b4:	01400034 	movhi	r5,0
    10b8:	2943e704 	addi	r5,r5,3996
    10bc:	000d883a 	mov	r6,zero
}
    10c0:	dfc00117 	ldw	ra,4(sp)
    10c4:	dc000017 	ldw	r16,0(sp)
    10c8:	dec00204 	addi	sp,sp,8
    }

    /* set udpecho_recv() as callback function
       for received packets */
    printf("Ready to accept UDP packets on port 7\n");
    udp_recv(pcb, udpecho_recv, NULL);
    10cc:	000d83c1 	jmpi	d83c <udp_recv>
        return;
    }

    /* bind to any IP address on port 7 */
    if (udp_bind(pcb, IP_ADDR_ANY, 7) != ERR_OK) {
        printf("udp_bind failed!\n");
    10d0:	010000b4 	movhi	r4,2
    10d4:	21113904 	addi	r4,r4,17636

    /* set udpecho_recv() as callback function
       for received packets */
    printf("Ready to accept UDP packets on port 7\n");
    udp_recv(pcb, udpecho_recv, NULL);
}
    10d8:	dfc00117 	ldw	ra,4(sp)
    10dc:	dc000017 	ldw	r16,0(sp)
    10e0:	dec00204 	addi	sp,sp,8
        return;
    }

    /* bind to any IP address on port 7 */
    if (udp_bind(pcb, IP_ADDR_ANY, 7) != ERR_OK) {
        printf("udp_bind failed!\n");
    10e4:	00106a41 	jmpi	106a4 <puts>
    printf("Initializing udp_init()...\n");

    /* get new pcb */
    pcb = udp_new();
    if (pcb == NULL) {
        printf("udp_new failed!\n");
    10e8:	010000b4 	movhi	r4,2
    10ec:	21113504 	addi	r4,r4,17620

    /* set udpecho_recv() as callback function
       for received packets */
    printf("Ready to accept UDP packets on port 7\n");
    udp_recv(pcb, udpecho_recv, NULL);
}
    10f0:	dfc00117 	ldw	ra,4(sp)
    10f4:	dc000017 	ldw	r16,0(sp)
    10f8:	dec00204 	addi	sp,sp,8
        return;
    }

    /* bind to any IP address on port 7 */
    if (udp_bind(pcb, IP_ADDR_ANY, 7) != ERR_OK) {
        printf("udp_bind failed!\n");
    10fc:	00106a41 	jmpi	106a4 <puts>

00001100 <get_utm>:
//#ifndef HIST_BM_HOOK                /* svOs */
//#define HIST_BM_HOOK()
//#endif /* HIST_BM_HOOK */

void get_utm(HISTTIM *p_time)
{
    1100:	defffe04 	addi	sp,sp,-8
    1104:	dc000015 	stw	r16,0(sp)
    1108:	dfc00115 	stw	ra,4(sp)
    110c:	2021883a 	mov	r16,r4
	//*p_time = (HISTTIM) ((double)alt_timestamp() / (double)timestamp_freq * (double)1000000);
	*p_time = (HISTTIM)alt_timestamp();
    1110:	001dd540 	call	1dd54 <alt_timestamp>
    1114:	80800015 	stw	r2,0(r16)
	//printf("%d\n", *p_time);
}
    1118:	dfc00117 	ldw	ra,4(sp)
    111c:	dc000017 	ldw	r16,0(sp)
    1120:	dec00204 	addi	sp,sp,8
    1124:	f800283a 	ret

00001128 <init_hist>:
	HISTCB	*p_histcb;
	uint32	i;
	boolean ret = TRUE;

	/* szvIDFALSE */
	if ((histid < TMIN_HISTID) || (histid > TMAX_HISTID)) {
    1128:	213fffc4 	addi	r4,r4,-1
    112c:	0089c3c4 	movi	r2,9999
    1130:	11001136 	bltu	r2,r4,1178 <init_hist+0x50>
		ret = FALSE;
	}
	else {
		p_histcb = &(histcb_table[histid - TMIN_HISTID]);
    1134:	21000624 	muli	r4,r4,24
    1138:	00800134 	movhi	r2,4
    113c:	10a84604 	addi	r2,r2,-24296
    1140:	3007883a 	mov	r3,r6
    1144:	2089883a 	add	r4,r4,r2

		for (i = 0U; i <= maxval; i++) {
    1148:	0005883a 	mov	r2,zero
			histarea[i] = 0U;
    114c:	18000015 	stw	zero,0(r3)
		ret = FALSE;
	}
	else {
		p_histcb = &(histcb_table[histid - TMIN_HISTID]);

		for (i = 0U; i <= maxval; i++) {
    1150:	10800044 	addi	r2,r2,1
    1154:	18c00104 	addi	r3,r3,4
    1158:	28bffc2e 	bgeu	r5,r2,114c <init_hist+0x24>
		}
		p_histcb->maxval = maxval;
		p_histcb->histarea = histarea;
		p_histcb->over = 0U;
		p_histcb->under = 0U;
		p_histcb->initialized = TRUE;
    115c:	00800044 	movi	r2,1
		p_histcb = &(histcb_table[histid - TMIN_HISTID]);

		for (i = 0U; i <= maxval; i++) {
			histarea[i] = 0U;
		}
		p_histcb->maxval = maxval;
    1160:	21400115 	stw	r5,4(r4)
		p_histcb->histarea = histarea;
    1164:	21800215 	stw	r6,8(r4)
		p_histcb->over = 0U;
    1168:	20000315 	stw	zero,12(r4)
		p_histcb->under = 0U;
    116c:	20000415 	stw	zero,16(r4)
		p_histcb->initialized = TRUE;
    1170:	20800515 	stw	r2,20(r4)
    1174:	f800283a 	ret
	uint32	i;
	boolean ret = TRUE;

	/* szvIDFALSE */
	if ((histid < TMIN_HISTID) || (histid > TMAX_HISTID)) {
		ret = FALSE;
    1178:	0005883a 	mov	r2,zero
		p_histcb->over = 0U;
		p_histcb->under = 0U;
		p_histcb->initialized = TRUE;
	}
	return(ret);
}
    117c:	f800283a 	ret

00001180 <begin_measure>:
boolean
begin_measure(ObjectIDType histid)
{
	HISTCB	*p_histcb;
	boolean ret = TRUE;
	if((int)histid % 500 == 1) {
    1180:	00c07d04 	movi	r3,500
    1184:	20c7283a 	div	r3,r4,r3
    1188:	18c07d24 	muli	r3,r3,500
/*
 *  svJn
 */
boolean
begin_measure(ObjectIDType histid)
{
    118c:	defffe04 	addi	sp,sp,-8
    1190:	dfc00115 	stw	ra,4(sp)
	HISTCB	*p_histcb;
	boolean ret = TRUE;
	if((int)histid % 500 == 1) {
    1194:	20bfffc4 	addi	r2,r4,-1
    1198:	18801226 	beq	r3,r2,11e4 <begin_measure+0x64>
		alt_timestamp_start();
	}

	/* szvIDFALSE */
	if ((histid < TMIN_HISTID) || (histid > TMAX_HISTID)) {
    119c:	213fffc4 	addi	r4,r4,-1
    11a0:	0089c3c4 	movi	r2,9999
    11a4:	11000636 	bltu	r2,r4,11c0 <begin_measure+0x40>
		ret = FALSE;
	}
	else {
		p_histcb = &(histcb_table[histid - TMIN_HISTID]);
    11a8:	21000624 	muli	r4,r4,24
    11ac:	00800134 	movhi	r2,4
    11b0:	10a84604 	addi	r2,r2,-24296
    11b4:	2089883a 	add	r4,r4,r2

		/* FALSE */
		if (p_histcb->initialized == FALSE)	{
    11b8:	20800517 	ldw	r2,20(r4)
    11bc:	1000041e 	bne	r2,zero,11d0 <begin_measure+0x50>
		alt_timestamp_start();
	}

	/* szvIDFALSE */
	if ((histid < TMIN_HISTID) || (histid > TMAX_HISTID)) {
		ret = FALSE;
    11c0:	0005883a 	mov	r2,zero
			//HIST_BM_HOOK();
			HIST_GET_TIM(&(p_histcb->begin_time));
		}
	}
	return(ret);
}
    11c4:	dfc00117 	ldw	ra,4(sp)
    11c8:	dec00204 	addi	sp,sp,8
    11cc:	f800283a 	ret
		if (p_histcb->initialized == FALSE)	{
			ret = FALSE;
		}
		else {
			//HIST_BM_HOOK();
			HIST_GET_TIM(&(p_histcb->begin_time));
    11d0:	00011000 	call	1100 <get_utm>
 */
boolean
begin_measure(ObjectIDType histid)
{
	HISTCB	*p_histcb;
	boolean ret = TRUE;
    11d4:	00800044 	movi	r2,1
			//HIST_BM_HOOK();
			HIST_GET_TIM(&(p_histcb->begin_time));
		}
	}
	return(ret);
}
    11d8:	dfc00117 	ldw	ra,4(sp)
    11dc:	dec00204 	addi	sp,sp,8
    11e0:	f800283a 	ret
begin_measure(ObjectIDType histid)
{
	HISTCB	*p_histcb;
	boolean ret = TRUE;
	if((int)histid % 500 == 1) {
		alt_timestamp_start();
    11e4:	d9000015 	stw	r4,0(sp)
    11e8:	001dccc0 	call	1dccc <alt_timestamp_start>
    11ec:	d9000017 	ldw	r4,0(sp)
    11f0:	003fea06 	br	119c <begin_measure+0x1c>

000011f4 <end_measure>:
/*
 *  svI
 */
boolean
end_measure(ObjectIDType histid)
{
    11f4:	defffb04 	addi	sp,sp,-20
    11f8:	dc000115 	stw	r16,4(sp)
    11fc:	2021883a 	mov	r16,r4
	HISTCB	*p_histcb;
	HISTTIM	end_time;
	uint32	val;
	boolean ret = TRUE;

	HIST_GET_TIM(&end_time);
    1200:	d809883a 	mov	r4,sp
/*
 *  svI
 */
boolean
end_measure(ObjectIDType histid)
{
    1204:	dfc00415 	stw	ra,16(sp)
    1208:	dc800315 	stw	r18,12(sp)
    120c:	dc400215 	stw	r17,8(sp)
	HISTCB	*p_histcb;
	HISTTIM	end_time;
	uint32	val;
	boolean ret = TRUE;

	HIST_GET_TIM(&end_time);
    1210:	00011000 	call	1100 <get_utm>

	/* szvIDFALSE */
	if ((histid < TMIN_HISTID) || (histid > TMAX_HISTID)) {
    1214:	813fffc4 	addi	r4,r16,-1
    1218:	0089c3c4 	movi	r2,9999
    121c:	11002936 	bltu	r2,r4,12c4 <end_measure+0xd0>
		ret = FALSE;
	}
	else {
		p_histcb = &(histcb_table[histid - TMIN_HISTID]);
    1220:	21000624 	muli	r4,r4,24
    1224:	00800134 	movhi	r2,4
    1228:	10a84604 	addi	r2,r2,-24296
    122c:	20a1883a 	add	r16,r4,r2

		/* FALSE */
		if (p_histcb->initialized == FALSE)	{
    1230:	80800517 	ldw	r2,20(r16)
    1234:	10002326 	beq	r2,zero,12c4 <end_measure+0xd0>
			ret = FALSE;
		}
		else {
			//val = HIST_CONV_TIM(end_time - p_histcb->begin_time);
			val = (uint32) ((double)HIST_CONV_TIM(end_time - p_histcb->begin_time) / (double)timestamp_freq * (double)1000000);
    1238:	80800017 	ldw	r2,0(r16)
    123c:	d9000017 	ldw	r4,0(sp)
    1240:	2089c83a 	sub	r4,r4,r2
    1244:	000fb140 	call	fb14 <__floatunsidf>
    1248:	d128ab17 	ldw	r4,-23892(gp)
    124c:	1025883a 	mov	r18,r2
    1250:	1823883a 	mov	r17,r3
    1254:	000fb140 	call	fb14 <__floatunsidf>
    1258:	9009883a 	mov	r4,r18
    125c:	880b883a 	mov	r5,r17
    1260:	100d883a 	mov	r6,r2
    1264:	180f883a 	mov	r7,r3
    1268:	000f8280 	call	f828 <__divdf3>
    126c:	1009883a 	mov	r4,r2
    1270:	180b883a 	mov	r5,r3
    1274:	000d883a 	mov	r6,zero
    1278:	01d04bf4 	movhi	r7,16687
    127c:	39e12004 	addi	r7,r7,-31616
    1280:	000f5440 	call	f544 <__muldf3>
    1284:	180b883a 	mov	r5,r3
    1288:	1009883a 	mov	r4,r2
    128c:	000f0b80 	call	f0b8 <__fixunsdfsi>
			//printf("timediff: %d\n", val);
			if (val <= p_histcb->maxval) {
    1290:	80c00117 	ldw	r3,4(r16)
    1294:	1880172e 	bgeu	r3,r2,12f4 <end_measure+0x100>
				p_histcb->histarea[val]++;
			}
			else if (val <= ((uint32) 0x7fffffff)) {
    1298:	10001116 	blt	r2,zero,12e0 <end_measure+0xec>
				p_histcb->over++;
    129c:	80c00317 	ldw	r3,12(r16)
end_measure(ObjectIDType histid)
{
	HISTCB	*p_histcb;
	HISTTIM	end_time;
	uint32	val;
	boolean ret = TRUE;
    12a0:	00800044 	movi	r2,1
			//printf("timediff: %d\n", val);
			if (val <= p_histcb->maxval) {
				p_histcb->histarea[val]++;
			}
			else if (val <= ((uint32) 0x7fffffff)) {
				p_histcb->over++;
    12a4:	1887883a 	add	r3,r3,r2
    12a8:	80c00315 	stw	r3,12(r16)
				p_histcb->under++;
			}
		}
	}
	return(ret);
}
    12ac:	dfc00417 	ldw	ra,16(sp)
    12b0:	dc800317 	ldw	r18,12(sp)
    12b4:	dc400217 	ldw	r17,8(sp)
    12b8:	dc000117 	ldw	r16,4(sp)
    12bc:	dec00504 	addi	sp,sp,20
    12c0:	f800283a 	ret

	HIST_GET_TIM(&end_time);

	/* szvIDFALSE */
	if ((histid < TMIN_HISTID) || (histid > TMAX_HISTID)) {
		ret = FALSE;
    12c4:	0005883a 	mov	r2,zero
				p_histcb->under++;
			}
		}
	}
	return(ret);
}
    12c8:	dfc00417 	ldw	ra,16(sp)
    12cc:	dc800317 	ldw	r18,12(sp)
    12d0:	dc400217 	ldw	r17,8(sp)
    12d4:	dc000117 	ldw	r16,4(sp)
    12d8:	dec00504 	addi	sp,sp,20
    12dc:	f800283a 	ret
			}
			else if (val <= ((uint32) 0x7fffffff)) {
				p_histcb->over++;
			}
			else {
				p_histcb->under++;
    12e0:	80c00417 	ldw	r3,16(r16)
end_measure(ObjectIDType histid)
{
	HISTCB	*p_histcb;
	HISTTIM	end_time;
	uint32	val;
	boolean ret = TRUE;
    12e4:	00800044 	movi	r2,1
			}
			else if (val <= ((uint32) 0x7fffffff)) {
				p_histcb->over++;
			}
			else {
				p_histcb->under++;
    12e8:	1887883a 	add	r3,r3,r2
    12ec:	80c00415 	stw	r3,16(r16)
    12f0:	003ff506 	br	12c8 <end_measure+0xd4>
		else {
			//val = HIST_CONV_TIM(end_time - p_histcb->begin_time);
			val = (uint32) ((double)HIST_CONV_TIM(end_time - p_histcb->begin_time) / (double)timestamp_freq * (double)1000000);
			//printf("timediff: %d\n", val);
			if (val <= p_histcb->maxval) {
				p_histcb->histarea[val]++;
    12f4:	80c00217 	ldw	r3,8(r16)
    12f8:	1085883a 	add	r2,r2,r2
    12fc:	1085883a 	add	r2,r2,r2
    1300:	1887883a 	add	r3,r3,r2
    1304:	19000017 	ldw	r4,0(r3)
end_measure(ObjectIDType histid)
{
	HISTCB	*p_histcb;
	HISTTIM	end_time;
	uint32	val;
	boolean ret = TRUE;
    1308:	00800044 	movi	r2,1
		else {
			//val = HIST_CONV_TIM(end_time - p_histcb->begin_time);
			val = (uint32) ((double)HIST_CONV_TIM(end_time - p_histcb->begin_time) / (double)timestamp_freq * (double)1000000);
			//printf("timediff: %d\n", val);
			if (val <= p_histcb->maxval) {
				p_histcb->histarea[val]++;
    130c:	2089883a 	add	r4,r4,r2
    1310:	19000015 	stw	r4,0(r3)
				p_histcb->under++;
			}
		}
	}
	return(ret);
}
    1314:	dfc00417 	ldw	ra,16(sp)
    1318:	dc800317 	ldw	r18,12(sp)
    131c:	dc400217 	ldw	r17,8(sp)
    1320:	dc000117 	ldw	r16,4(sp)
    1324:	dec00504 	addi	sp,sp,20
    1328:	f800283a 	ret

0000132c <print_hist>:
/*
 *  szv\
 */
boolean
print_hist(ObjectIDType histid)
{
    132c:	defffc04 	addi	sp,sp,-16
    1330:	dfc00315 	stw	ra,12(sp)
    1334:	dc800215 	stw	r18,8(sp)
    1338:	dc400115 	stw	r17,4(sp)
    133c:	dc000015 	stw	r16,0(sp)
	HISTCB	*p_histcb;
	int		i;
	boolean ret = TRUE;

	/* szvIDFALSE */
	if ((histid < TMIN_HISTID) || (histid > TMAX_HISTID)) {
    1340:	213fffc4 	addi	r4,r4,-1
    1344:	0089c3c4 	movi	r2,9999
    1348:	11002436 	bltu	r2,r4,13dc <print_hist+0xb0>
		ret = FALSE;
	}
	else {
		p_histcb = &(histcb_table[histid - TMIN_HISTID]);
    134c:	24800624 	muli	r18,r4,24
    1350:	00800134 	movhi	r2,4
    1354:	10a84604 	addi	r2,r2,-24296
    1358:	90a5883a 	add	r18,r18,r2

		/* FALSE */
		if (p_histcb->initialized == FALSE)	{
    135c:	90800517 	ldw	r2,20(r18)
    1360:	10001e26 	beq	r2,zero,13dc <print_hist+0xb0>
			ret = FALSE;
		}
		else {
			for (i = 0U; i <= (int)p_histcb->maxval; i++) {
    1364:	91400117 	ldw	r5,4(r18)
    1368:	28001116 	blt	r5,zero,13b0 <print_hist+0x84>
    136c:	0023883a 	mov	r17,zero
    1370:	0021883a 	mov	r16,zero
    1374:	00000206 	br	1380 <print_hist+0x54>
    1378:	84000044 	addi	r16,r16,1
    137c:	2c000c16 	blt	r5,r16,13b0 <print_hist+0x84>
				if ((int)p_histcb->histarea[i] > 0U) {
    1380:	90800217 	ldw	r2,8(r18)
    1384:	1445883a 	add	r2,r2,r17
    1388:	11800017 	ldw	r6,0(r2)
    138c:	8c400104 	addi	r17,r17,4
    1390:	303ff926 	beq	r6,zero,1378 <print_hist+0x4c>
#ifndef MEASURE_100_NANO
					printf("%d : %d\n", i, (int)p_histcb->histarea[i]);
    1394:	800b883a 	mov	r5,r16
    1398:	010000b4 	movhi	r4,2
    139c:	21114804 	addi	r4,r4,17696
    13a0:	00104380 	call	10438 <printf>
    13a4:	91400117 	ldw	r5,4(r18)
		/* FALSE */
		if (p_histcb->initialized == FALSE)	{
			ret = FALSE;
		}
		else {
			for (i = 0U; i <= (int)p_histcb->maxval; i++) {
    13a8:	84000044 	addi	r16,r16,1
    13ac:	2c3ff40e 	bge	r5,r16,1380 <print_hist+0x54>
#else
					printf("%d.%d : %d\n", i / 10, i % 10, (int)p_histcb->histarea[i]);
#endif /* MEASURE_100_NANO */
				}
			}
			if (p_histcb->over > 0U) {
    13b0:	91800317 	ldw	r6,12(r18)
    13b4:	30001a1e 	bne	r6,zero,1420 <print_hist+0xf4>
				printf("> %d : %d\n", (int)p_histcb->maxval, (int)p_histcb->over);
			}
			if (p_histcb->under > 0U) {
    13b8:	91400417 	ldw	r5,16(r18)
    13bc:	28000e1e 	bne	r5,zero,13f8 <print_hist+0xcc>
boolean
print_hist(ObjectIDType histid)
{
	HISTCB	*p_histcb;
	int		i;
	boolean ret = TRUE;
    13c0:	00800044 	movi	r2,1
			}
		}
	}

	return(ret);
}
    13c4:	dfc00317 	ldw	ra,12(sp)
    13c8:	dc800217 	ldw	r18,8(sp)
    13cc:	dc400117 	ldw	r17,4(sp)
    13d0:	dc000017 	ldw	r16,0(sp)
    13d4:	dec00404 	addi	sp,sp,16
    13d8:	f800283a 	ret
	int		i;
	boolean ret = TRUE;

	/* szvIDFALSE */
	if ((histid < TMIN_HISTID) || (histid > TMAX_HISTID)) {
		ret = FALSE;
    13dc:	0005883a 	mov	r2,zero
			}
		}
	}

	return(ret);
}
    13e0:	dfc00317 	ldw	ra,12(sp)
    13e4:	dc800217 	ldw	r18,8(sp)
    13e8:	dc400117 	ldw	r17,4(sp)
    13ec:	dc000017 	ldw	r16,0(sp)
    13f0:	dec00404 	addi	sp,sp,16
    13f4:	f800283a 	ret
			}
			if (p_histcb->over > 0U) {
				printf("> %d : %d\n", (int)p_histcb->maxval, (int)p_histcb->over);
			}
			if (p_histcb->under > 0U) {
				printf("> 0x7fffffff : %d\n", (int)p_histcb->under);
    13f8:	010000b4 	movhi	r4,2
    13fc:	21114e04 	addi	r4,r4,17720
    1400:	00104380 	call	10438 <printf>
boolean
print_hist(ObjectIDType histid)
{
	HISTCB	*p_histcb;
	int		i;
	boolean ret = TRUE;
    1404:	00800044 	movi	r2,1
			}
		}
	}

	return(ret);
}
    1408:	dfc00317 	ldw	ra,12(sp)
    140c:	dc800217 	ldw	r18,8(sp)
    1410:	dc400117 	ldw	r17,4(sp)
    1414:	dc000017 	ldw	r16,0(sp)
    1418:	dec00404 	addi	sp,sp,16
    141c:	f800283a 	ret
					printf("%d.%d : %d\n", i / 10, i % 10, (int)p_histcb->histarea[i]);
#endif /* MEASURE_100_NANO */
				}
			}
			if (p_histcb->over > 0U) {
				printf("> %d : %d\n", (int)p_histcb->maxval, (int)p_histcb->over);
    1420:	010000b4 	movhi	r4,2
    1424:	21114b04 	addi	r4,r4,17708
    1428:	00104380 	call	10438 <printf>
    142c:	003fe206 	br	13b8 <print_hist+0x8c>

00001430 <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
    1430:	defffe04 	addi	sp,sp,-8
    1434:	dc000015 	stw	r16,0(sp)
  struct dhcp *dhcp = netif->dhcp;
    1438:	24000817 	ldw	r16,32(r4)
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
    143c:	dfc00115 	stw	ra,4(sp)
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
    1440:	00800204 	movi	r2,8
    1444:	80c00303 	ldbu	r3,12(r16)
    1448:	18800326 	beq	r3,r2,1458 <dhcp_check+0x28>
    dhcp->state = new_state;
    144c:	80800305 	stb	r2,12(r16)
    dhcp->tries = 0;
    1450:	80000345 	stb	zero,13(r16)
    dhcp->request_timeout = 0;
    1454:	8000068d 	sth	zero,26(r16)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  dhcp_set_state(dhcp, DHCP_CHECKING);
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
    1458:	81400904 	addi	r5,r16,36
    145c:	000d883a 	mov	r6,zero
    1460:	000e3200 	call	e320 <etharp_query>
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
    1464:	80800343 	ldbu	r2,13(r16)
  msecs = 500;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    1468:	00c00044 	movi	r3,1
    146c:	80c0068d 	sth	r3,26(r16)
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
    1470:	10800044 	addi	r2,r2,1
    1474:	80800345 	stb	r2,13(r16)
  msecs = 500;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
}
    1478:	dfc00117 	ldw	ra,4(sp)
    147c:	dc000017 	ldw	r16,0(sp)
    1480:	dec00204 	addi	sp,sp,8
    1484:	f800283a 	ret

00001488 <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
    1488:	defffb04 	addi	sp,sp,-20
    148c:	dc400315 	stw	r17,12(sp)
    1490:	dfc00415 	stw	ra,16(sp)
    1494:	dc000215 	stw	r16,8(sp)
    1498:	2023883a 	mov	r17,r4
  u32_t timeout;
  struct dhcp *dhcp;
  ip_addr_t sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
    149c:	20006526 	beq	r4,zero,1634 <dhcp_bind+0x1ac>
  dhcp = netif->dhcp;
    14a0:	24000817 	ldw	r16,32(r4)
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
    14a4:	80005a26 	beq	r16,zero,1610 <dhcp_bind+0x188>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
    14a8:	80800d17 	ldw	r2,52(r16)
    14ac:	013fffc4 	movi	r4,-1
    14b0:	11004e26 	beq	r2,r4,15ec <dhcp_bind+0x164>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
    14b4:	10800784 	addi	r2,r2,30
    14b8:	00c00f04 	movi	r3,60
    14bc:	10c7203a 	divu	r3,r2,r3
    if(timeout > 0xffff) {
    14c0:	00bfffd4 	movui	r2,65535
    14c4:	10c0312e 	bgeu	r2,r3,158c <dhcp_bind+0x104>
      timeout = 0xffff;
    }
    dhcp->t1_timeout = (u16_t)timeout;
    14c8:	8100070d 	sth	r4,28(r16)
      dhcp->t1_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
    14cc:	80c00e17 	ldw	r3,56(r16)
    14d0:	017fffc4 	movi	r5,-1
    14d4:	19403526 	beq	r3,r5,15ac <dhcp_bind+0x124>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
    14d8:	18c00784 	addi	r3,r3,30
    14dc:	01000f04 	movi	r4,60
    14e0:	1909203a 	divu	r4,r3,r4
    if(timeout > 0xffff) {
    14e4:	00ffffd4 	movui	r3,65535
    14e8:	19003e36 	bltu	r3,r4,15e4 <dhcp_bind+0x15c>
      timeout = 0xffff;
    }
    dhcp->t2_timeout = (u16_t)timeout;
    if (dhcp->t2_timeout == 0) {
    14ec:	20ffffcc 	andi	r3,r4,65535
    14f0:	18005e1e 	bne	r3,zero,166c <dhcp_bind+0x1e4>
      dhcp->t2_timeout = 1;
    14f4:	00c00044 	movi	r3,1
    14f8:	80c0078d 	sth	r3,30(r16)
    14fc:	00c00044 	movi	r3,1
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }

  /* If we have sub 1 minute lease, t2 and t1 will kick in at the same time. */
  if ((dhcp->t1_timeout >= dhcp->t2_timeout) && (dhcp->t2_timeout > 0)) {
    1500:	10c02d2e 	bgeu	r2,r3,15b8 <dhcp_bind+0x130>
    dhcp->t1_timeout = 0;
  }

  if (dhcp->subnet_mask_given) {
    1504:	80800383 	ldbu	r2,14(r16)
    1508:	10002e26 	beq	r2,zero,15c4 <dhcp_bind+0x13c>
    /* copy offered network mask */
    ip_addr_copy(sn_mask, dhcp->offered_sn_mask);
    150c:	80800a17 	ldw	r2,40(r16)
    1510:	d8800115 	stw	r2,4(sp)
    } else {
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffff0000UL));
    }
  }

  ip_addr_copy(gw_addr, dhcp->offered_gw_addr);
    1514:	80800b17 	ldw	r2,44(r16)
    1518:	d8800015 	stw	r2,0(sp)
  /* gateway address not given? */
  if (ip_addr_isany(&gw_addr)) {
    151c:	1000051e 	bne	r2,zero,1534 <dhcp_bind+0xac>
    /* copy network address */
    ip_addr_get_network(&gw_addr, &dhcp->offered_ip_addr, &sn_mask);
    1520:	80800917 	ldw	r2,36(r16)
    1524:	d8c00117 	ldw	r3,4(sp)
    1528:	1884703a 	and	r2,r3,r2
    /* use first host address on network as gateway */
    ip4_addr_set_u32(&gw_addr, ip4_addr_get_u32(&gw_addr) | PP_HTONL(0x00000001UL));
    152c:	10804034 	orhi	r2,r2,256
    1530:	d8800015 	stw	r2,0(sp)
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n",
    ip4_addr_get_u32(&dhcp->offered_ip_addr)));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
    1534:	81400904 	addi	r5,r16,36
    1538:	8809883a 	mov	r4,r17
    153c:	00062640 	call	6264 <netif_set_ipaddr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n",
    ip4_addr_get_u32(&sn_mask)));
  netif_set_netmask(netif, &sn_mask);
    1540:	8809883a 	mov	r4,r17
    1544:	d9400104 	addi	r5,sp,4
    1548:	00064b40 	call	64b4 <netif_set_netmask>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n",
    ip4_addr_get_u32(&gw_addr)));
  netif_set_gw(netif, &gw_addr);
    154c:	8809883a 	mov	r4,r17
    1550:	d80b883a 	mov	r5,sp
    1554:	00064980 	call	6498 <netif_set_gw>
  /* bring the interface up */
  netif_set_up(netif);
    1558:	8809883a 	mov	r4,r17
    155c:	00064d80 	call	64d8 <netif_set_up>
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
    1560:	80c00303 	ldbu	r3,12(r16)
    1564:	00800284 	movi	r2,10
    1568:	18800326 	beq	r3,r2,1578 <dhcp_bind+0xf0>
    dhcp->state = new_state;
    156c:	80800305 	stb	r2,12(r16)
    dhcp->tries = 0;
    1570:	80000345 	stb	zero,13(r16)
    dhcp->request_timeout = 0;
    1574:	8000068d 	sth	zero,26(r16)
  netif_set_gw(netif, &gw_addr);
  /* bring the interface up */
  netif_set_up(netif);
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
}
    1578:	dfc00417 	ldw	ra,16(sp)
    157c:	dc400317 	ldw	r17,12(sp)
    1580:	dc000217 	ldw	r16,8(sp)
    1584:	dec00504 	addi	sp,sp,20
    1588:	f800283a 	ret
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t1_timeout = (u16_t)timeout;
    if (dhcp->t1_timeout == 0) {
    158c:	18bfffcc 	andi	r2,r3,65535
    1590:	1000341e 	bne	r2,zero,1664 <dhcp_bind+0x1dc>
      dhcp->t1_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
    1594:	80c00e17 	ldw	r3,56(r16)
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t1_timeout = (u16_t)timeout;
    if (dhcp->t1_timeout == 0) {
      dhcp->t1_timeout = 1;
    1598:	00800044 	movi	r2,1
    159c:	8080070d 	sth	r2,28(r16)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
    15a0:	017fffc4 	movi	r5,-1
    15a4:	00800044 	movi	r2,1
    15a8:	197fcb1e 	bne	r3,r5,14d8 <dhcp_bind+0x50>
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }

  /* If we have sub 1 minute lease, t2 and t1 will kick in at the same time. */
  if ((dhcp->t1_timeout >= dhcp->t2_timeout) && (dhcp->t2_timeout > 0)) {
    15ac:	80c0078b 	ldhu	r3,30(r16)
    15b0:	10ffd436 	bltu	r2,r3,1504 <dhcp_bind+0x7c>
    15b4:	183fd326 	beq	r3,zero,1504 <dhcp_bind+0x7c>
    dhcp->t1_timeout = 0;
  }

  if (dhcp->subnet_mask_given) {
    15b8:	80800383 	ldbu	r2,14(r16)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }

  /* If we have sub 1 minute lease, t2 and t1 will kick in at the same time. */
  if ((dhcp->t1_timeout >= dhcp->t2_timeout) && (dhcp->t2_timeout > 0)) {
    dhcp->t1_timeout = 0;
    15bc:	8000070d 	sth	zero,28(r16)
  }

  if (dhcp->subnet_mask_given) {
    15c0:	103fd21e 	bne	r2,zero,150c <dhcp_bind+0x84>
    /* copy offered network mask */
    ip_addr_copy(sn_mask, dhcp->offered_sn_mask);
  } else {
    /* subnet mask not given, choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&dhcp->offered_ip_addr);
    15c4:	80800903 	ldbu	r2,36(r16)
    if (first_octet <= 127) {
    15c8:	10c03fcc 	andi	r3,r2,255
    15cc:	18c0201c 	xori	r3,r3,128
    15d0:	18ffe004 	addi	r3,r3,-128
    15d4:	18000716 	blt	r3,zero,15f4 <dhcp_bind+0x16c>
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xff000000UL));
    15d8:	00803fc4 	movi	r2,255
    15dc:	d8800115 	stw	r2,4(sp)
    15e0:	003fcc06 	br	1514 <dhcp_bind+0x8c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t2_timeout = (u16_t)timeout;
    15e4:	8140078d 	sth	r5,30(r16)
    15e8:	003fc506 	br	1500 <dhcp_bind+0x78>
    15ec:	8080070b 	ldhu	r2,28(r16)
    15f0:	003fb606 	br	14cc <dhcp_bind+0x44>
  } else {
    /* subnet mask not given, choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&dhcp->offered_ip_addr);
    if (first_octet <= 127) {
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xff000000UL));
    } else if (first_octet >= 192) {
    15f4:	10803fcc 	andi	r2,r2,255
    15f8:	00c02fc4 	movi	r3,191
    15fc:	1880162e 	bgeu	r3,r2,1658 <dhcp_bind+0x1d0>
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffffff00UL));
    1600:	00804034 	movhi	r2,256
    1604:	10bfffc4 	addi	r2,r2,-1
    1608:	d8800115 	stw	r2,4(sp)
    160c:	003fc106 	br	1514 <dhcp_bind+0x8c>
  u32_t timeout;
  struct dhcp *dhcp;
  ip_addr_t sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  dhcp = netif->dhcp;
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
    1610:	010000b4 	movhi	r4,2
    1614:	210d4b04 	addi	r4,r4,13612
    1618:	014000b4 	movhi	r5,2
    161c:	29516004 	addi	r5,r5,17792
    1620:	0180e984 	movi	r6,934
    1624:	01c000b4 	movhi	r7,2
    1628:	39d15a04 	addi	r7,r7,17768
    162c:	00104380 	call	10438 <printf>
    1630:	003fff06 	br	1630 <dhcp_bind+0x1a8>
dhcp_bind(struct netif *netif)
{
  u32_t timeout;
  struct dhcp *dhcp;
  ip_addr_t sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
    1634:	010000b4 	movhi	r4,2
    1638:	210d4b04 	addi	r4,r4,13612
    163c:	014000b4 	movhi	r5,2
    1640:	29515304 	addi	r5,r5,17740
    1644:	0180e904 	movi	r6,932
    1648:	01c000b4 	movhi	r7,2
    164c:	39d15a04 	addi	r7,r7,17768
    1650:	00104380 	call	10438 <printf>
    1654:	003fff06 	br	1654 <dhcp_bind+0x1cc>
    if (first_octet <= 127) {
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xff000000UL));
    } else if (first_octet >= 192) {
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffffff00UL));
    } else {
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffff0000UL));
    1658:	00bfffd4 	movui	r2,65535
    165c:	d8800115 	stw	r2,4(sp)
    1660:	003fac06 	br	1514 <dhcp_bind+0x8c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t1_timeout = (u16_t)timeout;
    1664:	80c0070d 	sth	r3,28(r16)
    1668:	003f9806 	br	14cc <dhcp_bind+0x44>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t2_timeout = (u16_t)timeout;
    166c:	8100078d 	sth	r4,30(r16)
    1670:	003fa306 	br	1500 <dhcp_bind+0x78>

00001674 <dhcp_option>:
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
    1674:	2080060b 	ldhu	r2,24(r4)
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
    1678:	deffff04 	addi	sp,sp,-4
    167c:	dfc00015 	stw	ra,0(sp)
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
    1680:	10ffffcc 	andi	r3,r2,65535
    1684:	19c00084 	addi	r7,r3,2
    1688:	398f883a 	add	r7,r7,r6
    168c:	02001104 	movi	r8,68
    1690:	41c00d36 	bltu	r8,r7,16c8 <dhcp_option+0x54>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
    1694:	22000517 	ldw	r8,20(r4)
    1698:	11c00044 	addi	r7,r2,1
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
    169c:	39ffffcc 	andi	r7,r7,65535
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
    16a0:	40c7883a 	add	r3,r8,r3
    16a4:	19403c05 	stb	r5,240(r3)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
    16a8:	20c00517 	ldw	r3,20(r4)
    16ac:	10800084 	addi	r2,r2,2
    16b0:	19c7883a 	add	r3,r3,r7
    16b4:	19803c05 	stb	r6,240(r3)
    16b8:	2080060d 	sth	r2,24(r4)
}
    16bc:	dfc00017 	ldw	ra,0(sp)
    16c0:	dec00104 	addi	sp,sp,4
    16c4:	f800283a 	ret
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
    16c8:	010000b4 	movhi	r4,2
    16cc:	210d4b04 	addi	r4,r4,13612
    16d0:	014000b4 	movhi	r5,2
    16d4:	29516604 	addi	r5,r5,17816
    16d8:	01813d84 	movi	r6,1270
    16dc:	01c000b4 	movhi	r7,2
    16e0:	39d15a04 	addi	r7,r7,17768
    16e4:	00104380 	call	10438 <printf>
    16e8:	003fff06 	br	16e8 <dhcp_option+0x74>

000016ec <dhcp_option_byte>:
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    16ec:	2080060b 	ldhu	r2,24(r4)
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
    16f0:	deffff04 	addi	sp,sp,-4
    16f4:	dfc00015 	stw	ra,0(sp)
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    16f8:	10ffffcc 	andi	r3,r2,65535
    16fc:	018010c4 	movi	r6,67
    1700:	30c00836 	bltu	r6,r3,1724 <dhcp_option_byte+0x38>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
    1704:	21800517 	ldw	r6,20(r4)
    1708:	10800044 	addi	r2,r2,1
    170c:	30c7883a 	add	r3,r6,r3
    1710:	19403c05 	stb	r5,240(r3)
    1714:	2080060d 	sth	r2,24(r4)
}
    1718:	dfc00017 	ldw	ra,0(sp)
    171c:	dec00104 	addi	sp,sp,4
    1720:	f800283a 	ret
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    1724:	010000b4 	movhi	r4,2
    1728:	210d4b04 	addi	r4,r4,13612
    172c:	014000b4 	movhi	r5,2
    1730:	29517804 	addi	r5,r5,17888
    1734:	01814044 	movi	r6,1281
    1738:	01c000b4 	movhi	r7,2
    173c:	39d15a04 	addi	r7,r7,17768
    1740:	00104380 	call	10438 <printf>
    1744:	003fff06 	br	1744 <dhcp_option_byte+0x58>

00001748 <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
    1748:	deffff04 	addi	sp,sp,-4
    174c:	dfc00015 	stw	ra,0(sp)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
    1750:	20002c26 	beq	r4,zero,1804 <dhcp_option_trailer+0xbc>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
    1754:	21400517 	ldw	r5,20(r4)
    1758:	28002126 	beq	r5,zero,17e0 <dhcp_option_trailer+0x98>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    175c:	20c0060b 	ldhu	r3,24(r4)
    1760:	018010c4 	movi	r6,67
    1764:	18bfffcc 	andi	r2,r3,65535
    1768:	30801436 	bltu	r6,r2,17bc <dhcp_option_trailer+0x74>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
    176c:	2885883a 	add	r2,r5,r2
    1770:	017fffc4 	movi	r5,-1
    1774:	18c00044 	addi	r3,r3,1
    1778:	11403c05 	stb	r5,240(r2)
    177c:	20c0060d 	sth	r3,24(r4)
    1780:	1805883a 	mov	r2,r3
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
    1784:	01c01104 	movi	r7,68
    1788:	18ffffcc 	andi	r3,r3,65535
    178c:	19c00826 	beq	r3,r7,17b0 <dhcp_option_trailer+0x68>
         (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
    1790:	21800517 	ldw	r6,20(r4)
    1794:	11400044 	addi	r5,r2,1
    1798:	2805883a 	mov	r2,r5
    179c:	30c7883a 	add	r3,r6,r3
    17a0:	18003c05 	stb	zero,240(r3)
    17a4:	2140060d 	sth	r5,24(r4)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
    17a8:	28ffffcc 	andi	r3,r5,65535
    17ac:	19fff81e 	bne	r3,r7,1790 <dhcp_option_trailer+0x48>
         (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
    17b0:	dfc00017 	ldw	ra,0(sp)
    17b4:	dec00104 	addi	sp,sp,4
    17b8:	f800283a 	ret
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    17bc:	010000b4 	movhi	r4,2
    17c0:	210d4b04 	addi	r4,r4,13612
    17c4:	014000b4 	movhi	r5,2
    17c8:	29519b04 	addi	r5,r5,18028
    17cc:	0181b804 	movi	r6,1760
    17d0:	01c000b4 	movhi	r7,2
    17d4:	39d15a04 	addi	r7,r7,17768
    17d8:	00104380 	call	10438 <printf>
    17dc:	003fff06 	br	17dc <dhcp_option_trailer+0x94>
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
    17e0:	010000b4 	movhi	r4,2
    17e4:	210d4b04 	addi	r4,r4,13612
    17e8:	014000b4 	movhi	r5,2
    17ec:	29519004 	addi	r5,r5,17984
    17f0:	0181b7c4 	movi	r6,1759
    17f4:	01c000b4 	movhi	r7,2
    17f8:	39d15a04 	addi	r7,r7,17768
    17fc:	00104380 	call	10438 <printf>
    1800:	003fff06 	br	1800 <dhcp_option_trailer+0xb8>
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
    1804:	010000b4 	movhi	r4,2
    1808:	210d4b04 	addi	r4,r4,13612
    180c:	014000b4 	movhi	r5,2
    1810:	29518704 	addi	r5,r5,17948
    1814:	0181b784 	movi	r6,1758
    1818:	01c000b4 	movhi	r7,2
    181c:	39d15a04 	addi	r7,r7,17768
    1820:	00104380 	call	10438 <printf>
    1824:	003fff06 	br	1824 <dhcp_option_trailer+0xdc>

00001828 <dhcp_option_short>:
}

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
    1828:	2080060b 	ldhu	r2,24(r4)
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
}

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
    182c:	deffff04 	addi	sp,sp,-4
    1830:	dfc00015 	stw	ra,0(sp)
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
    1834:	10ffffcc 	andi	r3,r2,65535
    1838:	19800084 	addi	r6,r3,2
    183c:	01c01104 	movi	r7,68
    1840:	39800e36 	bltu	r7,r6,187c <dhcp_option_short+0x54>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
    1844:	22000517 	ldw	r8,20(r4)
    1848:	280cd23a 	srli	r6,r5,8
    184c:	11c00044 	addi	r7,r2,1
    1850:	40c7883a 	add	r3,r8,r3
    1854:	19803c05 	stb	r6,240(r3)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
    1858:	21800517 	ldw	r6,20(r4)
    185c:	38ffffcc 	andi	r3,r7,65535
    1860:	10800084 	addi	r2,r2,2
    1864:	30c7883a 	add	r3,r6,r3
    1868:	19403c05 	stb	r5,240(r3)
    186c:	2080060d 	sth	r2,24(r4)
}
    1870:	dfc00017 	ldw	ra,0(sp)
    1874:	dec00104 	addi	sp,sp,4
    1878:	f800283a 	ret
}

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
    187c:	010000b4 	movhi	r4,2
    1880:	210d4b04 	addi	r4,r4,13612
    1884:	014000b4 	movhi	r5,2
    1888:	2951ab04 	addi	r5,r5,18092
    188c:	01814204 	movi	r6,1288
    1890:	01c000b4 	movhi	r7,2
    1894:	39d15a04 	addi	r7,r7,17768
    1898:	00104380 	call	10438 <printf>
    189c:	003fff06 	br	189c <dhcp_option_short+0x74>

000018a0 <dhcp_option_long>:
}

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
    18a0:	2080060b 	ldhu	r2,24(r4)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
}

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
    18a4:	deffff04 	addi	sp,sp,-4
    18a8:	dfc00015 	stw	ra,0(sp)
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
    18ac:	10ffffcc 	andi	r3,r2,65535
    18b0:	19800104 	addi	r6,r3,4
    18b4:	01c01104 	movi	r7,68
    18b8:	39801a36 	bltu	r7,r6,1924 <dhcp_option_long+0x84>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
    18bc:	21c00517 	ldw	r7,20(r4)
    18c0:	280cd63a 	srli	r6,r5,24
    18c4:	12000044 	addi	r8,r2,1
    18c8:	38c7883a 	add	r3,r7,r3
    18cc:	19803c05 	stb	r6,240(r3)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
    18d0:	21c00517 	ldw	r7,20(r4)
    18d4:	280cd43a 	srli	r6,r5,16
    18d8:	40ffffcc 	andi	r3,r8,65535
    18dc:	38c7883a 	add	r3,r7,r3
    18e0:	19803c05 	stb	r6,240(r3)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
    18e4:	21c00517 	ldw	r7,20(r4)
    18e8:	280cd23a 	srli	r6,r5,8
static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
    18ec:	10c00084 	addi	r3,r2,2
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
    18f0:	18ffffcc 	andi	r3,r3,65535
    18f4:	38c7883a 	add	r3,r7,r3
    18f8:	19803c05 	stb	r6,240(r3)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
    18fc:	21800517 	ldw	r6,20(r4)
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
    1900:	10c000c4 	addi	r3,r2,3
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
    1904:	18ffffcc 	andi	r3,r3,65535
    1908:	30c7883a 	add	r3,r6,r3
    190c:	19403c05 	stb	r5,240(r3)
    1910:	10800104 	addi	r2,r2,4
    1914:	2080060d 	sth	r2,24(r4)
}
    1918:	dfc00017 	ldw	ra,0(sp)
    191c:	dec00104 	addi	sp,sp,4
    1920:	f800283a 	ret
}

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
    1924:	010000b4 	movhi	r4,2
    1928:	210d4b04 	addi	r4,r4,13612
    192c:	014000b4 	movhi	r5,2
    1930:	2951bc04 	addi	r5,r5,18160
    1934:	01814404 	movi	r6,1296
    1938:	01c000b4 	movhi	r7,2
    193c:	39d15a04 	addi	r7,r7,17768
    1940:	00104380 	call	10438 <printf>
    1944:	003fff06 	br	1944 <dhcp_option_long+0xa4>

00001948 <dhcp_create_msg>:
 * @param dhcp dhcp control struct
 * @param message_type message type of the request
 */
static err_t
dhcp_create_msg(struct netif *netif, struct dhcp *dhcp, u8_t message_type)
{
    1948:	defffc04 	addi	sp,sp,-16
    194c:	dc800215 	stw	r18,8(sp)
    1950:	dc400115 	stw	r17,4(sp)
    1954:	dc000015 	stw	r16,0(sp)
    1958:	dfc00315 	stw	ra,12(sp)
    195c:	2023883a 	mov	r17,r4
    1960:	2821883a 	mov	r16,r5
    1964:	3025883a 	mov	r18,r6
  if (!xid_initialised) {
    xid = DHCP_GLOBAL_XID;
    xid_initialised = !xid_initialised;
  }
#endif
  LWIP_ERROR("dhcp_create_msg: netif != NULL", (netif != NULL), return ERR_ARG;);
    1968:	20000c26 	beq	r4,zero,199c <dhcp_create_msg+0x54>
  LWIP_ERROR("dhcp_create_msg: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
    196c:	28009f26 	beq	r5,zero,1bec <dhcp_create_msg+0x2a4>
  LWIP_ASSERT("dhcp_create_msg: dhcp->p_out == NULL", dhcp->p_out == NULL);
    1970:	28800417 	ldw	r2,16(r5)
    1974:	10001226 	beq	r2,zero,19c0 <dhcp_create_msg+0x78>
    1978:	010000b4 	movhi	r4,2
    197c:	210d4b04 	addi	r4,r4,13612
    1980:	014000b4 	movhi	r5,2
    1984:	2951dc04 	addi	r5,r5,18288
    1988:	01819f84 	movi	r6,1662
    198c:	01c000b4 	movhi	r7,2
    1990:	39d15a04 	addi	r7,r7,17768
    1994:	00104380 	call	10438 <printf>
    1998:	003fff06 	br	1998 <dhcp_create_msg+0x50>
  if (!xid_initialised) {
    xid = DHCP_GLOBAL_XID;
    xid_initialised = !xid_initialised;
  }
#endif
  LWIP_ERROR("dhcp_create_msg: netif != NULL", (netif != NULL), return ERR_ARG;);
    199c:	010000b4 	movhi	r4,2
    19a0:	210d4b04 	addi	r4,r4,13612
    19a4:	014000b4 	movhi	r5,2
    19a8:	2951cc04 	addi	r5,r5,18224
    19ac:	01819f04 	movi	r6,1660
    19b0:	01c000b4 	movhi	r7,2
    19b4:	39d15a04 	addi	r7,r7,17768
    19b8:	00104380 	call	10438 <printf>
    19bc:	003fff06 	br	19bc <dhcp_create_msg+0x74>
  LWIP_ERROR("dhcp_create_msg: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  LWIP_ASSERT("dhcp_create_msg: dhcp->p_out == NULL", dhcp->p_out == NULL);
  LWIP_ASSERT("dhcp_create_msg: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
    19c0:	28800517 	ldw	r2,20(r5)
    19c4:	10000926 	beq	r2,zero,19ec <dhcp_create_msg+0xa4>
    19c8:	010000b4 	movhi	r4,2
    19cc:	210d4b04 	addi	r4,r4,13612
    19d0:	014000b4 	movhi	r5,2
    19d4:	2951e604 	addi	r5,r5,18328
    19d8:	01819fc4 	movi	r6,1663
    19dc:	01c000b4 	movhi	r7,2
    19e0:	39d15a04 	addi	r7,r7,17768
    19e4:	00104380 	call	10438 <printf>
    19e8:	003fff06 	br	19e8 <dhcp_create_msg+0xa0>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
    19ec:	0009883a 	mov	r4,zero
    19f0:	01404d04 	movi	r5,308
    19f4:	000d883a 	mov	r6,zero
    19f8:	0006a880 	call	6a88 <pbuf_alloc>
    19fc:	80800415 	stw	r2,16(r16)
  if (dhcp->p_out == NULL) {
    1a00:	10007326 	beq	r2,zero,1bd0 <dhcp_create_msg+0x288>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_create_msg(): could not allocate pbuf\n"));
    return ERR_MEM;
  }
  LWIP_ASSERT("dhcp_create_msg: check that first pbuf can hold struct dhcp_msg",
    1a04:	10c0028b 	ldhu	r3,10(r2)
    1a08:	01004cc4 	movi	r4,307
    1a0c:	20c0802e 	bgeu	r4,r3,1c10 <dhcp_create_msg+0x2c8>
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* reuse transaction identifier in retransmissions */
  if (dhcp->tries == 0) {
    1a10:	80c00343 	ldbu	r3,13(r16)
    1a14:	18006a26 	beq	r3,zero,1bc0 <dhcp_create_msg+0x278>
    1a18:	d0e00117 	ldw	r3,-32764(gp)
  }
  dhcp->xid = xid;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
              ("transaction id xid(%"X32_F")\n", xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
    1a1c:	11000117 	ldw	r4,4(r2)
    xid = LWIP_RAND();
#else /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
    xid++;
#endif /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
  }
  dhcp->xid = xid;
    1a20:	80c00015 	stw	r3,0(r16)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
              ("transaction id xid(%"X32_F")\n", xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
    1a24:	00800044 	movi	r2,1
  }
  dhcp->xid = xid;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
              ("transaction id xid(%"X32_F")\n", xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
    1a28:	81000515 	stw	r4,20(r16)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
    1a2c:	20800005 	stb	r2,0(r4)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
    1a30:	80c00517 	ldw	r3,20(r16)
  /* we don't need the broadcast flag since we can receive unicast traffic
     before being fully configured! */
  dhcp->msg_out->flags = 0;
  ip_addr_set_zero(&dhcp->msg_out->ciaddr);
  /* set ciaddr to netif->ip_addr based on message_type and state */
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) ||
    1a34:	94803fcc 	andi	r18,r18,255

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
    1a38:	18800045 	stb	r2,1(r3)
  dhcp->msg_out->hlen = netif->hwaddr_len;
    1a3c:	80800517 	ldw	r2,20(r16)
    1a40:	88c00983 	ldbu	r3,38(r17)
    1a44:	10c00085 	stb	r3,2(r2)
  dhcp->msg_out->hops = 0;
    1a48:	80800517 	ldw	r2,20(r16)
    1a4c:	100000c5 	stb	zero,3(r2)
  dhcp->msg_out->xid = htonl(dhcp->xid);
    1a50:	80c00017 	ldw	r3,0(r16)
    1a54:	80800517 	ldw	r2,20(r16)
    1a58:	180c963a 	slli	r6,r3,24
    1a5c:	180ad63a 	srli	r5,r3,24
    1a60:	1808d23a 	srli	r4,r3,8
    1a64:	18ffc00c 	andi	r3,r3,65280
    1a68:	1806923a 	slli	r3,r3,8
    1a6c:	314ab03a 	or	r5,r6,r5
    1a70:	213fc00c 	andi	r4,r4,65280
    1a74:	2908b03a 	or	r4,r5,r4
    1a78:	20c6b03a 	or	r3,r4,r3
    1a7c:	1808d43a 	srli	r4,r3,16
    1a80:	10c0010d 	sth	r3,4(r2)
  dhcp->msg_out->secs = 0;
    1a84:	1000020d 	sth	zero,8(r2)
  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  dhcp->msg_out->hlen = netif->hwaddr_len;
  dhcp->msg_out->hops = 0;
  dhcp->msg_out->xid = htonl(dhcp->xid);
    1a88:	1100018d 	sth	r4,6(r2)
  dhcp->msg_out->secs = 0;
  /* we don't need the broadcast flag since we can receive unicast traffic
     before being fully configured! */
  dhcp->msg_out->flags = 0;
    1a8c:	1000028d 	sth	zero,10(r2)
  ip_addr_set_zero(&dhcp->msg_out->ciaddr);
    1a90:	1000030d 	sth	zero,12(r2)
    1a94:	1000038d 	sth	zero,14(r2)
  /* set ciaddr to netif->ip_addr based on message_type and state */
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) ||
    1a98:	00c00204 	movi	r3,8
    1a9c:	90c04326 	beq	r18,r3,1bac <dhcp_create_msg+0x264>
    1aa0:	00c00104 	movi	r3,4
    1aa4:	90c04126 	beq	r18,r3,1bac <dhcp_create_msg+0x264>
    1aa8:	00c000c4 	movi	r3,3
    1aac:	90c03a26 	beq	r18,r3,1b98 <dhcp_create_msg+0x250>
      ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
       ((dhcp->state==DHCP_RENEWING) || dhcp->state==DHCP_REBINDING))) {
    ip_addr_copy(dhcp->msg_out->ciaddr, netif->ip_addr);
  }
  ip_addr_set_zero(&dhcp->msg_out->yiaddr);
    1ab0:	1000040d 	sth	zero,16(r2)
    1ab4:	1000048d 	sth	zero,18(r2)
  ip_addr_set_zero(&dhcp->msg_out->siaddr);
    1ab8:	1000050d 	sth	zero,20(r2)
    1abc:	1000058d 	sth	zero,22(r2)
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
    1ac0:	1000060d 	sth	zero,24(r2)
    1ac4:	1000068d 	sth	zero,26(r2)
 * @param netif the netif under DHCP control
 * @param dhcp dhcp control struct
 * @param message_type message type of the request
 */
static err_t
dhcp_create_msg(struct netif *netif, struct dhcp *dhcp, u8_t message_type)
    1ac8:	890009c4 	addi	r4,r17,39
    1acc:	0007883a 	mov	r3,zero
    ip_addr_copy(dhcp->msg_out->ciaddr, netif->ip_addr);
  }
  ip_addr_set_zero(&dhcp->msg_out->yiaddr);
  ip_addr_set_zero(&dhcp->msg_out->siaddr);
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    1ad0:	01800404 	movi	r6,16
    1ad4:	00000106 	br	1adc <dhcp_create_msg+0x194>
    1ad8:	80800517 	ldw	r2,20(r16)
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
    1adc:	89c00983 	ldbu	r7,38(r17)
    1ae0:	1a3fffcc 	andi	r8,r3,65535
    1ae4:	000b883a 	mov	r5,zero
    1ae8:	41c0012e 	bgeu	r8,r7,1af0 <dhcp_create_msg+0x1a8>
    1aec:	21400003 	ldbu	r5,0(r4)
    1af0:	10c5883a 	add	r2,r2,r3
    1af4:	11400705 	stb	r5,28(r2)
    1af8:	18c00044 	addi	r3,r3,1
    1afc:	21000044 	addi	r4,r4,1
    ip_addr_copy(dhcp->msg_out->ciaddr, netif->ip_addr);
  }
  ip_addr_set_zero(&dhcp->msg_out->yiaddr);
  ip_addr_set_zero(&dhcp->msg_out->siaddr);
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    1b00:	19bff51e 	bne	r3,r6,1ad8 <dhcp_create_msg+0x190>
    1b04:	0005883a 	mov	r2,zero
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    1b08:	00c01004 	movi	r3,64
    dhcp->msg_out->sname[i] = 0;
    1b0c:	81000517 	ldw	r4,20(r16)
    1b10:	2089883a 	add	r4,r4,r2
    1b14:	20000b05 	stb	zero,44(r4)
    1b18:	10800044 	addi	r2,r2,1
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    1b1c:	10fffb1e 	bne	r2,r3,1b0c <dhcp_create_msg+0x1c4>
    1b20:	0005883a 	mov	r2,zero
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    1b24:	00c02004 	movi	r3,128
    dhcp->msg_out->file[i] = 0;
    1b28:	81000517 	ldw	r4,20(r16)
    1b2c:	2089883a 	add	r4,r4,r2
    1b30:	20001b05 	stb	zero,108(r4)
    1b34:	10800044 	addi	r2,r2,1
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    1b38:	10fffb1e 	bne	r2,r3,1b28 <dhcp_create_msg+0x1e0>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
    1b3c:	80c00517 	ldw	r3,20(r16)
    1b40:	00a098c4 	movi	r2,-32157
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    1b44:	01001104 	movi	r4,68
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
    1b48:	18803b0d 	sth	r2,236(r3)
    1b4c:	0098d4c4 	movi	r2,25427
    1b50:	18803b8d 	sth	r2,238(r3)
  dhcp->options_out_len = 0;
    1b54:	8000060d 	sth	zero,24(r16)
    1b58:	0005883a 	mov	r2,zero
    1b5c:	00000106 	br	1b64 <dhcp_create_msg+0x21c>
    1b60:	80c00517 	ldw	r3,20(r16)
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
    1b64:	1887883a 	add	r3,r3,r2
    1b68:	18803c05 	stb	r2,240(r3)
    1b6c:	10800044 	addi	r2,r2,1
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    1b70:	113ffb1e 	bne	r2,r4,1b60 <dhcp_create_msg+0x218>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  /* Add option MESSAGE_TYPE */
  dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
    1b74:	01800044 	movi	r6,1
    1b78:	8009883a 	mov	r4,r16
    1b7c:	01400d44 	movi	r5,53
    1b80:	00016740 	call	1674 <dhcp_option>
  dhcp_option_byte(dhcp, message_type);
    1b84:	8009883a 	mov	r4,r16
    1b88:	900b883a 	mov	r5,r18
    1b8c:	00016ec0 	call	16ec <dhcp_option_byte>
  return ERR_OK;
    1b90:	0005883a 	mov	r2,zero
    1b94:	00000f06 	br	1bd4 <dhcp_create_msg+0x28c>
  dhcp->msg_out->flags = 0;
  ip_addr_set_zero(&dhcp->msg_out->ciaddr);
  /* set ciaddr to netif->ip_addr based on message_type and state */
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) ||
      ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
       ((dhcp->state==DHCP_RENEWING) || dhcp->state==DHCP_REBINDING))) {
    1b98:	80c00303 	ldbu	r3,12(r16)
     before being fully configured! */
  dhcp->msg_out->flags = 0;
  ip_addr_set_zero(&dhcp->msg_out->ciaddr);
  /* set ciaddr to netif->ip_addr based on message_type and state */
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) ||
      ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
    1b9c:	01000044 	movi	r4,1
       ((dhcp->state==DHCP_RENEWING) || dhcp->state==DHCP_REBINDING))) {
    1ba0:	18ffff04 	addi	r3,r3,-4
     before being fully configured! */
  dhcp->msg_out->flags = 0;
  ip_addr_set_zero(&dhcp->msg_out->ciaddr);
  /* set ciaddr to netif->ip_addr based on message_type and state */
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) ||
      ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
    1ba4:	18c03fcc 	andi	r3,r3,255
    1ba8:	20ffc136 	bltu	r4,r3,1ab0 <dhcp_create_msg+0x168>
       ((dhcp->state==DHCP_RENEWING) || dhcp->state==DHCP_REBINDING))) {
    ip_addr_copy(dhcp->msg_out->ciaddr, netif->ip_addr);
    1bac:	88c0010b 	ldhu	r3,4(r17)
    1bb0:	10c0030d 	sth	r3,12(r2)
    1bb4:	88c0018b 	ldhu	r3,6(r17)
    1bb8:	10c0038d 	sth	r3,14(r2)
    1bbc:	003fbc06 	br	1ab0 <dhcp_create_msg+0x168>
  /* reuse transaction identifier in retransmissions */
  if (dhcp->tries == 0) {
#if DHCP_CREATE_RAND_XID && defined(LWIP_RAND)
    xid = LWIP_RAND();
#else /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
    xid++;
    1bc0:	d0e00117 	ldw	r3,-32764(gp)
    1bc4:	18c00044 	addi	r3,r3,1
    1bc8:	d0e00115 	stw	r3,-32764(gp)
    1bcc:	003f9306 	br	1a1c <dhcp_create_msg+0xd4>
  LWIP_ASSERT("dhcp_create_msg: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  if (dhcp->p_out == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_create_msg(): could not allocate pbuf\n"));
    return ERR_MEM;
    1bd0:	00bfffc4 	movi	r2,-1
  }
  /* Add option MESSAGE_TYPE */
  dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  dhcp_option_byte(dhcp, message_type);
  return ERR_OK;
}
    1bd4:	dfc00317 	ldw	ra,12(sp)
    1bd8:	dc800217 	ldw	r18,8(sp)
    1bdc:	dc400117 	ldw	r17,4(sp)
    1be0:	dc000017 	ldw	r16,0(sp)
    1be4:	dec00404 	addi	sp,sp,16
    1be8:	f800283a 	ret
    xid = DHCP_GLOBAL_XID;
    xid_initialised = !xid_initialised;
  }
#endif
  LWIP_ERROR("dhcp_create_msg: netif != NULL", (netif != NULL), return ERR_ARG;);
  LWIP_ERROR("dhcp_create_msg: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
    1bec:	010000b4 	movhi	r4,2
    1bf0:	210d4b04 	addi	r4,r4,13612
    1bf4:	014000b4 	movhi	r5,2
    1bf8:	2951d404 	addi	r5,r5,18256
    1bfc:	01819f44 	movi	r6,1661
    1c00:	01c000b4 	movhi	r7,2
    1c04:	39d15a04 	addi	r7,r7,17768
    1c08:	00104380 	call	10438 <printf>
    1c0c:	003fff06 	br	1c0c <dhcp_create_msg+0x2c4>
  if (dhcp->p_out == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_create_msg(): could not allocate pbuf\n"));
    return ERR_MEM;
  }
  LWIP_ASSERT("dhcp_create_msg: check that first pbuf can hold struct dhcp_msg",
    1c10:	010000b4 	movhi	r4,2
    1c14:	210d4b04 	addi	r4,r4,13612
    1c18:	014000b4 	movhi	r5,2
    1c1c:	2951f004 	addi	r5,r5,18368
    1c20:	0181a1c4 	movi	r6,1671
    1c24:	01c000b4 	movhi	r7,2
    1c28:	39d15a04 	addi	r7,r7,17768
    1c2c:	00104380 	call	10438 <printf>
    1c30:	003fff06 	br	1c30 <dhcp_create_msg+0x2e8>

00001c34 <dhcp_delete_msg>:
 *
 * @param dhcp the dhcp struct to free the request from
 */
static void
dhcp_delete_msg(struct dhcp *dhcp)
{
    1c34:	defffe04 	addi	sp,sp,-8
    1c38:	dc000015 	stw	r16,0(sp)
    1c3c:	dfc00115 	stw	ra,4(sp)
    1c40:	2021883a 	mov	r16,r4
  LWIP_ERROR("dhcp_delete_msg: dhcp != NULL", (dhcp != NULL), return;);
    1c44:	20000b26 	beq	r4,zero,1c74 <dhcp_delete_msg+0x40>
  LWIP_ASSERT("dhcp_delete_msg: dhcp->p_out != NULL", dhcp->p_out != NULL);
    1c48:	21000417 	ldw	r4,16(r4)
    1c4c:	20001226 	beq	r4,zero,1c98 <dhcp_delete_msg+0x64>
  LWIP_ASSERT("dhcp_delete_msg: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
    1c50:	80800517 	ldw	r2,20(r16)
    1c54:	10001926 	beq	r2,zero,1cbc <dhcp_delete_msg+0x88>
  if (dhcp->p_out != NULL) {
    pbuf_free(dhcp->p_out);
    1c58:	00067d80 	call	67d8 <pbuf_free>
  }
  dhcp->p_out = NULL;
    1c5c:	80000415 	stw	zero,16(r16)
  dhcp->msg_out = NULL;
    1c60:	80000515 	stw	zero,20(r16)
}
    1c64:	dfc00117 	ldw	ra,4(sp)
    1c68:	dc000017 	ldw	r16,0(sp)
    1c6c:	dec00204 	addi	sp,sp,8
    1c70:	f800283a 	ret
 * @param dhcp the dhcp struct to free the request from
 */
static void
dhcp_delete_msg(struct dhcp *dhcp)
{
  LWIP_ERROR("dhcp_delete_msg: dhcp != NULL", (dhcp != NULL), return;);
    1c74:	010000b4 	movhi	r4,2
    1c78:	210d4b04 	addi	r4,r4,13612
    1c7c:	014000b4 	movhi	r5,2
    1c80:	29520004 	addi	r5,r5,18432
    1c84:	0181b244 	movi	r6,1737
    1c88:	01c000b4 	movhi	r7,2
    1c8c:	39d15a04 	addi	r7,r7,17768
    1c90:	00104380 	call	10438 <printf>
    1c94:	003fff06 	br	1c94 <dhcp_delete_msg+0x60>
  LWIP_ASSERT("dhcp_delete_msg: dhcp->p_out != NULL", dhcp->p_out != NULL);
    1c98:	010000b4 	movhi	r4,2
    1c9c:	210d4b04 	addi	r4,r4,13612
    1ca0:	014000b4 	movhi	r5,2
    1ca4:	29520804 	addi	r5,r5,18464
    1ca8:	0181b284 	movi	r6,1738
    1cac:	01c000b4 	movhi	r7,2
    1cb0:	39d15a04 	addi	r7,r7,17768
    1cb4:	00104380 	call	10438 <printf>
    1cb8:	003fff06 	br	1cb8 <dhcp_delete_msg+0x84>
  LWIP_ASSERT("dhcp_delete_msg: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
    1cbc:	010000b4 	movhi	r4,2
    1cc0:	210d4b04 	addi	r4,r4,13612
    1cc4:	014000b4 	movhi	r5,2
    1cc8:	29521204 	addi	r5,r5,18504
    1ccc:	0181b2c4 	movi	r6,1739
    1cd0:	01c000b4 	movhi	r7,2
    1cd4:	39d15a04 	addi	r7,r7,17768
    1cd8:	00104380 	call	10438 <printf>
    1cdc:	003fff06 	br	1cdc <dhcp_delete_msg+0xa8>

00001ce0 <dhcp_reboot>:
 *
 * @param netif network interface which must reboot
 */
static err_t
dhcp_reboot(struct netif *netif)
{
    1ce0:	defffb04 	addi	sp,sp,-20
    1ce4:	dc000115 	stw	r16,4(sp)
  struct dhcp *dhcp = netif->dhcp;
    1ce8:	24000817 	ldw	r16,32(r4)
 *
 * @param netif network interface which must reboot
 */
static err_t
dhcp_reboot(struct netif *netif)
{
    1cec:	dc400215 	stw	r17,8(sp)
    1cf0:	dfc00415 	stw	ra,16(sp)
    1cf4:	dc800315 	stw	r18,12(sp)
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
    1cf8:	80c00303 	ldbu	r3,12(r16)
    1cfc:	008000c4 	movi	r2,3
 *
 * @param netif network interface which must reboot
 */
static err_t
dhcp_reboot(struct netif *netif)
{
    1d00:	2023883a 	mov	r17,r4
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
    1d04:	18800326 	beq	r3,r2,1d14 <dhcp_reboot+0x34>
    dhcp->state = new_state;
    1d08:	80800305 	stb	r2,12(r16)
    dhcp->tries = 0;
    1d0c:	80000345 	stb	zero,13(r16)
    dhcp->request_timeout = 0;
    1d10:	8000068d 	sth	zero,26(r16)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot()\n"));
  dhcp_set_state(dhcp, DHCP_REBOOTING);

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
    1d14:	8809883a 	mov	r4,r17
    1d18:	800b883a 	mov	r5,r16
    1d1c:	018000c4 	movi	r6,3
    1d20:	00019480 	call	1948 <dhcp_create_msg>
    1d24:	1025883a 	mov	r18,r2
  if (result == ERR_OK) {
    1d28:	90803fcc 	andi	r2,r18,255
    1d2c:	1080201c 	xori	r2,r2,128
    1d30:	10bfe004 	addi	r2,r2,-128
    1d34:	10001e26 	beq	r2,zero,1db0 <dhcp_reboot+0xd0>
    dhcp_delete_msg(dhcp);
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot: REBOOTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_reboot: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    1d38:	80800343 	ldbu	r2,13(r16)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    1d3c:	01000244 	movi	r4,9
    dhcp_delete_msg(dhcp);
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot: REBOOTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_reboot: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    1d40:	10800044 	addi	r2,r2,1
    1d44:	1007883a 	mov	r3,r2
    1d48:	80800345 	stb	r2,13(r16)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    1d4c:	10803fcc 	andi	r2,r2,255
    1d50:	20800e36 	bltu	r4,r2,1d8c <dhcp_reboot+0xac>
    1d54:	18803fcc 	andi	r2,r3,255
    1d58:	1080fa24 	muli	r2,r2,1000
    1d5c:	01007d04 	movi	r4,500
    1d60:	10bfffcc 	andi	r2,r2,65535
    1d64:	10807cc4 	addi	r2,r2,499
    1d68:	1105283a 	div	r2,r2,r4
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    1d6c:	8080068d 	sth	r2,26(r16)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
    1d70:	9005883a 	mov	r2,r18
    1d74:	dfc00417 	ldw	ra,16(sp)
    1d78:	dc800317 	ldw	r18,12(sp)
    1d7c:	dc400217 	ldw	r17,8(sp)
    1d80:	dc000117 	ldw	r16,4(sp)
    1d84:	dec00504 	addi	sp,sp,20
    1d88:	f800283a 	ret
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot: REBOOTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_reboot: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    1d8c:	00800504 	movi	r2,20
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    1d90:	8080068d 	sth	r2,26(r16)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
    1d94:	9005883a 	mov	r2,r18
    1d98:	dfc00417 	ldw	ra,16(sp)
    1d9c:	dc800317 	ldw	r18,12(sp)
    1da0:	dc400217 	ldw	r17,8(sp)
    1da4:	dc000117 	ldw	r16,4(sp)
    1da8:	dec00504 	addi	sp,sp,20
    1dac:	f800283a 	ret
  dhcp_set_state(dhcp, DHCP_REBOOTING);

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
  if (result == ERR_OK) {
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    1db0:	01800084 	movi	r6,2
    1db4:	8009883a 	mov	r4,r16
    1db8:	01400e44 	movi	r5,57
    1dbc:	00016740 	call	1674 <dhcp_option>
    dhcp_option_short(dhcp, 576);
    1dc0:	8009883a 	mov	r4,r16
    1dc4:	01409004 	movi	r5,576
    1dc8:	00018280 	call	1828 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    1dcc:	8009883a 	mov	r4,r16
    1dd0:	01800104 	movi	r6,4
    1dd4:	01400c84 	movi	r5,50
    1dd8:	00016740 	call	1674 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
    1ddc:	80800917 	ldw	r2,36(r16)
    1de0:	8009883a 	mov	r4,r16
    1de4:	100c963a 	slli	r6,r2,24
    1de8:	100ad63a 	srli	r5,r2,24
    1dec:	1006d23a 	srli	r3,r2,8
    1df0:	10bfc00c 	andi	r2,r2,65280
    1df4:	1004923a 	slli	r2,r2,8
    1df8:	18ffc00c 	andi	r3,r3,65280
    1dfc:	314ab03a 	or	r5,r6,r5
    1e00:	28cab03a 	or	r5,r5,r3
    1e04:	288ab03a 	or	r5,r5,r2
    1e08:	00018a00 	call	18a0 <dhcp_option_long>

    dhcp_option_trailer(dhcp);
    1e0c:	8009883a 	mov	r4,r16
    1e10:	00017480 	call	1748 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    1e14:	8140060b 	ldhu	r5,24(r16)
    1e18:	81000417 	ldw	r4,16(r16)
    1e1c:	29403c04 	addi	r5,r5,240
    1e20:	297fffcc 	andi	r5,r5,65535
    1e24:	00069140 	call	6914 <pbuf_realloc>

    /* broadcast to server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    1e28:	81000117 	ldw	r4,4(r16)
    1e2c:	81400417 	ldw	r5,16(r16)
    1e30:	018000f4 	movhi	r6,3
    1e34:	31a5ff04 	addi	r6,r6,-26628
    1e38:	dc400015 	stw	r17,0(sp)
    1e3c:	01c010c4 	movi	r7,67
    1e40:	000d4cc0 	call	d4cc <udp_sendto_if>
    dhcp_delete_msg(dhcp);
    1e44:	8009883a 	mov	r4,r16
    1e48:	0001c340 	call	1c34 <dhcp_delete_msg>
    1e4c:	003fba06 	br	1d38 <dhcp_reboot+0x58>

00001e50 <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
    1e50:	defffb04 	addi	sp,sp,-20
    1e54:	dc000115 	stw	r16,4(sp)
  struct dhcp *dhcp = netif->dhcp;
    1e58:	24000817 	ldw	r16,32(r4)
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
    1e5c:	dc400215 	stw	r17,8(sp)
    1e60:	dfc00415 	stw	ra,16(sp)
    1e64:	dc800315 	stw	r18,12(sp)
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
    1e68:	80c00303 	ldbu	r3,12(r16)
    1e6c:	00800184 	movi	r2,6
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover()\n"));
  ip_addr_set_any(&dhcp->offered_ip_addr);
    1e70:	80000915 	stw	zero,36(r16)
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
    1e74:	2023883a 	mov	r17,r4
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
    1e78:	18800326 	beq	r3,r2,1e88 <dhcp_discover+0x38>
    dhcp->state = new_state;
    1e7c:	80800305 	stb	r2,12(r16)
    dhcp->tries = 0;
    1e80:	80000345 	stb	zero,13(r16)
    dhcp->request_timeout = 0;
    1e84:	8000068d 	sth	zero,26(r16)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover()\n"));
  ip_addr_set_any(&dhcp->offered_ip_addr);
  dhcp_set_state(dhcp, DHCP_SELECTING);
  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_DISCOVER);
    1e88:	8809883a 	mov	r4,r17
    1e8c:	800b883a 	mov	r5,r16
    1e90:	01800044 	movi	r6,1
    1e94:	00019480 	call	1948 <dhcp_create_msg>
    1e98:	1025883a 	mov	r18,r2
  if (result == ERR_OK) {
    1e9c:	90803fcc 	andi	r2,r18,255
    1ea0:	1080201c 	xori	r2,r2,128
    1ea4:	10bfe004 	addi	r2,r2,-128
    1ea8:	10001d26 	beq	r2,zero,1f20 <dhcp_discover+0xd0>
    dhcp_delete_msg(dhcp);
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    1eac:	80800343 	ldbu	r2,13(r16)
  if(dhcp->tries >= LWIP_DHCP_AUTOIP_COOP_TRIES && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
    1eb0:	00c00144 	movi	r3,5
    dhcp_delete_msg(dhcp);
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    1eb4:	10800044 	addi	r2,r2,1
    1eb8:	80800345 	stb	r2,13(r16)
  if(dhcp->tries >= LWIP_DHCP_AUTOIP_COOP_TRIES && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
    1ebc:	10803fcc 	andi	r2,r2,255
    1ec0:	18800e36 	bltu	r3,r2,1efc <dhcp_discover+0xac>
    1ec4:	00c0fa04 	movi	r3,1000
    1ec8:	1884983a 	sll	r2,r3,r2
    1ecc:	00c07d04 	movi	r3,500
    1ed0:	10bfffcc 	andi	r2,r2,65535
    1ed4:	10807cc4 	addi	r2,r2,499
    1ed8:	10c5283a 	div	r2,r2,r3
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    1edc:	8080068d 	sth	r2,26(r16)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
    1ee0:	9005883a 	mov	r2,r18
    1ee4:	dfc00417 	ldw	ra,16(sp)
    1ee8:	dc800317 	ldw	r18,12(sp)
    1eec:	dc400217 	ldw	r17,8(sp)
    1ef0:	dc000117 	ldw	r16,4(sp)
    1ef4:	dec00504 	addi	sp,sp,20
    1ef8:	f800283a 	ret
  if(dhcp->tries >= LWIP_DHCP_AUTOIP_COOP_TRIES && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
    1efc:	00801e04 	movi	r2,120
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    1f00:	8080068d 	sth	r2,26(r16)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
    1f04:	9005883a 	mov	r2,r18
    1f08:	dfc00417 	ldw	ra,16(sp)
    1f0c:	dc800317 	ldw	r18,12(sp)
    1f10:	dc400217 	ldw	r17,8(sp)
    1f14:	dc000117 	ldw	r16,4(sp)
    1f18:	dec00504 	addi	sp,sp,20
    1f1c:	f800283a 	ret
  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_DISCOVER);
  if (result == ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    1f20:	01800084 	movi	r6,2
    1f24:	8009883a 	mov	r4,r16
    1f28:	01400e44 	movi	r5,57
    1f2c:	00016740 	call	1674 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    1f30:	8940090b 	ldhu	r5,36(r17)
    1f34:	8009883a 	mov	r4,r16
    1f38:	00018280 	call	1828 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
    1f3c:	01800104 	movi	r6,4
    1f40:	8009883a 	mov	r4,r16
    1f44:	01400dc4 	movi	r5,55
    1f48:	00016740 	call	1674 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
    1f4c:	8009883a 	mov	r4,r16
    1f50:	01400044 	movi	r5,1
    1f54:	00016ec0 	call	16ec <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
    1f58:	8009883a 	mov	r4,r16
    1f5c:	014000c4 	movi	r5,3
    1f60:	00016ec0 	call	16ec <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
    1f64:	8009883a 	mov	r4,r16
    1f68:	01400704 	movi	r5,28
    1f6c:	00016ec0 	call	16ec <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
    1f70:	8009883a 	mov	r4,r16
    1f74:	01400184 	movi	r5,6
    1f78:	00016ec0 	call	16ec <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
    1f7c:	8009883a 	mov	r4,r16
    1f80:	00017480 	call	1748 <dhcp_option_trailer>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    1f84:	8140060b 	ldhu	r5,24(r16)
    1f88:	81000417 	ldw	r4,16(r16)
    1f8c:	29403c04 	addi	r5,r5,240
    1f90:	297fffcc 	andi	r5,r5,65535
    1f94:	00069140 	call	6914 <pbuf_realloc>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    1f98:	81000117 	ldw	r4,4(r16)
    1f9c:	81400417 	ldw	r5,16(r16)
    1fa0:	018000f4 	movhi	r6,3
    1fa4:	31a5ff04 	addi	r6,r6,-26628
    1fa8:	dc400015 	stw	r17,0(sp)
    1fac:	01c010c4 	movi	r7,67
    1fb0:	000d4cc0 	call	d4cc <udp_sendto_if>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_msg(dhcp);
    1fb4:	8009883a 	mov	r4,r16
    1fb8:	0001c340 	call	1c34 <dhcp_delete_msg>
    1fbc:	003fbb06 	br	1eac <dhcp_discover+0x5c>

00001fc0 <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
    1fc0:	defffb04 	addi	sp,sp,-20
    1fc4:	dc000115 	stw	r16,4(sp)
  struct dhcp *dhcp = netif->dhcp;
    1fc8:	24000817 	ldw	r16,32(r4)
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
    1fcc:	dc400215 	stw	r17,8(sp)
    1fd0:	dfc00415 	stw	ra,16(sp)
    1fd4:	dc800315 	stw	r18,12(sp)
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
    1fd8:	80c00303 	ldbu	r3,12(r16)
    1fdc:	00800044 	movi	r2,1
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
    1fe0:	2023883a 	mov	r17,r4
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
    1fe4:	18800326 	beq	r3,r2,1ff4 <dhcp_select+0x34>
    dhcp->state = new_state;
    1fe8:	80800305 	stb	r2,12(r16)
    dhcp->tries = 0;
    1fec:	80000345 	stb	zero,13(r16)
    dhcp->request_timeout = 0;
    1ff0:	8000068d 	sth	zero,26(r16)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  dhcp_set_state(dhcp, DHCP_REQUESTING);

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
    1ff4:	8809883a 	mov	r4,r17
    1ff8:	800b883a 	mov	r5,r16
    1ffc:	018000c4 	movi	r6,3
    2000:	00019480 	call	1948 <dhcp_create_msg>
    2004:	1025883a 	mov	r18,r2
  if (result == ERR_OK) {
    2008:	90803fcc 	andi	r2,r18,255
    200c:	1080201c 	xori	r2,r2,128
    2010:	10bfe004 	addi	r2,r2,-128
    2014:	10001d26 	beq	r2,zero,208c <dhcp_select+0xcc>
    dhcp_delete_msg(dhcp);
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    2018:	80800343 	ldbu	r2,13(r16)
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
    201c:	00c00144 	movi	r3,5
    dhcp_delete_msg(dhcp);
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    2020:	10800044 	addi	r2,r2,1
    2024:	80800345 	stb	r2,13(r16)
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
    2028:	10803fcc 	andi	r2,r2,255
    202c:	18800e36 	bltu	r3,r2,2068 <dhcp_select+0xa8>
    2030:	00c0fa04 	movi	r3,1000
    2034:	1884983a 	sll	r2,r3,r2
    2038:	00c07d04 	movi	r3,500
    203c:	10bfffcc 	andi	r2,r2,65535
    2040:	10807cc4 	addi	r2,r2,499
    2044:	10c5283a 	div	r2,r2,r3
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    2048:	8080068d 	sth	r2,26(r16)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
    204c:	9005883a 	mov	r2,r18
    2050:	dfc00417 	ldw	ra,16(sp)
    2054:	dc800317 	ldw	r18,12(sp)
    2058:	dc400217 	ldw	r17,8(sp)
    205c:	dc000117 	ldw	r16,4(sp)
    2060:	dec00504 	addi	sp,sp,20
    2064:	f800283a 	ret
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
    2068:	00801e04 	movi	r2,120
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    206c:	8080068d 	sth	r2,26(r16)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
    2070:	9005883a 	mov	r2,r18
    2074:	dfc00417 	ldw	ra,16(sp)
    2078:	dc800317 	ldw	r18,12(sp)
    207c:	dc400217 	ldw	r17,8(sp)
    2080:	dc000117 	ldw	r16,4(sp)
    2084:	dec00504 	addi	sp,sp,20
    2088:	f800283a 	ret
  dhcp_set_state(dhcp, DHCP_REQUESTING);

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
  if (result == ERR_OK) {
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    208c:	01800084 	movi	r6,2
    2090:	8009883a 	mov	r4,r16
    2094:	01400e44 	movi	r5,57
    2098:	00016740 	call	1674 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    209c:	8940090b 	ldhu	r5,36(r17)
    20a0:	8009883a 	mov	r4,r16
    20a4:	00018280 	call	1828 <dhcp_option_short>

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    20a8:	8009883a 	mov	r4,r16
    20ac:	01800104 	movi	r6,4
    20b0:	01400c84 	movi	r5,50
    20b4:	00016740 	call	1674 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
    20b8:	80800917 	ldw	r2,36(r16)
    20bc:	8009883a 	mov	r4,r16
    20c0:	100c963a 	slli	r6,r2,24
    20c4:	100ad63a 	srli	r5,r2,24
    20c8:	1006d23a 	srli	r3,r2,8
    20cc:	10bfc00c 	andi	r2,r2,65280
    20d0:	1004923a 	slli	r2,r2,8
    20d4:	18ffc00c 	andi	r3,r3,65280
    20d8:	314ab03a 	or	r5,r6,r5
    20dc:	28cab03a 	or	r5,r5,r3
    20e0:	288ab03a 	or	r5,r5,r2
    20e4:	00018a00 	call	18a0 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    20e8:	8009883a 	mov	r4,r16
    20ec:	01800104 	movi	r6,4
    20f0:	01400d84 	movi	r5,54
    20f4:	00016740 	call	1674 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->server_ip_addr)));
    20f8:	80800817 	ldw	r2,32(r16)
    20fc:	8009883a 	mov	r4,r16
    2100:	100c963a 	slli	r6,r2,24
    2104:	100ad63a 	srli	r5,r2,24
    2108:	1006d23a 	srli	r3,r2,8
    210c:	10bfc00c 	andi	r2,r2,65280
    2110:	1004923a 	slli	r2,r2,8
    2114:	18ffc00c 	andi	r3,r3,65280
    2118:	314ab03a 	or	r5,r6,r5
    211c:	28cab03a 	or	r5,r5,r3
    2120:	288ab03a 	or	r5,r5,r2
    2124:	00018a00 	call	18a0 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
    2128:	01800104 	movi	r6,4
    212c:	8009883a 	mov	r4,r16
    2130:	01400dc4 	movi	r5,55
    2134:	00016740 	call	1674 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
    2138:	8009883a 	mov	r4,r16
    213c:	01400044 	movi	r5,1
    2140:	00016ec0 	call	16ec <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
    2144:	8009883a 	mov	r4,r16
    2148:	014000c4 	movi	r5,3
    214c:	00016ec0 	call	16ec <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
    2150:	8009883a 	mov	r4,r16
    2154:	01400704 	movi	r5,28
    2158:	00016ec0 	call	16ec <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
    215c:	8009883a 	mov	r4,r16
    2160:	01400184 	movi	r5,6
    2164:	00016ec0 	call	16ec <dhcp_option_byte>

#if LWIP_NETIF_HOSTNAME
    dhcp_option_hostname(dhcp, netif);
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
    2168:	8009883a 	mov	r4,r16
    216c:	00017480 	call	1748 <dhcp_option_trailer>
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    2170:	8140060b 	ldhu	r5,24(r16)
    2174:	81000417 	ldw	r4,16(r16)
    2178:	29403c04 	addi	r5,r5,240
    217c:	297fffcc 	andi	r5,r5,65535
    2180:	00069140 	call	6914 <pbuf_realloc>

    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    2184:	81000117 	ldw	r4,4(r16)
    2188:	81400417 	ldw	r5,16(r16)
    218c:	018000f4 	movhi	r6,3
    2190:	31a5ff04 	addi	r6,r6,-26628
    2194:	dc400015 	stw	r17,0(sp)
    2198:	01c010c4 	movi	r7,67
    219c:	000d4cc0 	call	d4cc <udp_sendto_if>
    dhcp_delete_msg(dhcp);
    21a0:	8009883a 	mov	r4,r16
    21a4:	0001c340 	call	1c34 <dhcp_delete_msg>
    21a8:	003f9b06 	br	2018 <dhcp_select+0x58>

000021ac <dhcp_recv>:
/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void
dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *addr, u16_t port)
{
    21ac:	deffeb04 	addi	sp,sp,-84
    21b0:	dd401015 	stw	r21,64(sp)
  struct netif *netif = (struct netif *)arg;
  struct dhcp *dhcp = netif->dhcp;
    21b4:	25400817 	ldw	r21,32(r4)
/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void
dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *addr, u16_t port)
{
    21b8:	dd801115 	stw	r22,68(sp)
    21bc:	dc800d15 	stw	r18,52(sp)
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);

  LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL);
    21c0:	a8c00217 	ldw	r3,8(r21)
/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void
dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *addr, u16_t port)
{
    21c4:	dfc01415 	stw	ra,80(sp)
    21c8:	df001315 	stw	fp,76(sp)
    21cc:	ddc01215 	stw	r23,72(sp)
    21d0:	dd000f15 	stw	r20,60(sp)
    21d4:	dcc00e15 	stw	r19,56(sp)
    21d8:	dc400c15 	stw	r17,48(sp)
    21dc:	dc000b15 	stw	r16,44(sp)
    21e0:	2025883a 	mov	r18,r4
    21e4:	302d883a 	mov	r22,r6
  struct netif *netif = (struct netif *)arg;
  struct dhcp *dhcp = netif->dhcp;
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
    21e8:	30800117 	ldw	r2,4(r6)
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);

  LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL);
    21ec:	18000926 	beq	r3,zero,2214 <dhcp_recv+0x68>
    21f0:	010000b4 	movhi	r4,2
    21f4:	210d4b04 	addi	r4,r4,13612
    21f8:	014000b4 	movhi	r5,2
    21fc:	29521c04 	addi	r5,r5,18544
    2200:	01818444 	movi	r6,1553
    2204:	01c000b4 	movhi	r7,2
    2208:	39d15a04 	addi	r7,r7,17768
    220c:	00104380 	call	10438 <printf>
    2210:	003fff06 	br	2210 <dhcp_recv+0x64>

  if (p->len < DHCP_MIN_REPLY_LEN) {
    2214:	3100028b 	ldhu	r4,10(r6)
    2218:	00c00ac4 	movi	r3,43
    221c:	217fffcc 	andi	r5,r4,65535
    2220:	1940032e 	bgeu	r3,r5,2230 <dhcp_recv+0x84>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP reply message or pbuf too short\n"));
    goto free_pbuf_and_return;
  }

  if (reply_msg->op != DHCP_BOOTREPLY) {
    2224:	11800003 	ldbu	r6,0(r2)
    2228:	00c00084 	movi	r3,2
    222c:	30c00f26 	beq	r6,r3,226c <dhcp_recv+0xc0>
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  dhcp->msg_in = NULL;
    2230:	a8000215 	stw	zero,8(r21)
  pbuf_free(p);
    2234:	b009883a 	mov	r4,r22
    2238:	00067d80 	call	67d8 <pbuf_free>
}
    223c:	dfc01417 	ldw	ra,80(sp)
    2240:	df001317 	ldw	fp,76(sp)
    2244:	ddc01217 	ldw	r23,72(sp)
    2248:	dd801117 	ldw	r22,68(sp)
    224c:	dd401017 	ldw	r21,64(sp)
    2250:	dd000f17 	ldw	r20,60(sp)
    2254:	dcc00e17 	ldw	r19,56(sp)
    2258:	dc800d17 	ldw	r18,52(sp)
    225c:	dc400c17 	ldw	r17,48(sp)
    2260:	dc000b17 	ldw	r16,44(sp)
    2264:	dec01504 	addi	sp,sp,84
    2268:	f800283a 	ret
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
    226c:	90c00983 	ldbu	r3,38(r18)
    2270:	19803fcc 	andi	r6,r3,255
    2274:	30001026 	beq	r6,zero,22b8 <dhcp_recv+0x10c>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
    2278:	91c009c3 	ldbu	r7,39(r18)
    227c:	11800703 	ldbu	r6,28(r2)
    2280:	39bfeb1e 	bne	r7,r6,2230 <dhcp_recv+0x84>

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void
dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *addr, u16_t port)
    2284:	18ffffc4 	addi	r3,r3,-1
    2288:	19c03fcc 	andi	r7,r3,255
    228c:	39c00a04 	addi	r7,r7,40
    2290:	90c00a04 	addi	r3,r18,40
    2294:	91cf883a 	add	r7,r18,r7
    2298:	11800744 	addi	r6,r2,29
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
    229c:	19c00626 	beq	r3,r7,22b8 <dhcp_recv+0x10c>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
    22a0:	1a400003 	ldbu	r9,0(r3)
    22a4:	32000003 	ldbu	r8,0(r6)
    22a8:	18c00044 	addi	r3,r3,1
    22ac:	31800044 	addi	r6,r6,1
    22b0:	4a3fdf1e 	bne	r9,r8,2230 <dhcp_recv+0x84>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
    22b4:	19fffa1e 	bne	r3,r7,22a0 <dhcp_recv+0xf4>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
    22b8:	1180018b 	ldhu	r6,6(r2)
    22bc:	1080010b 	ldhu	r2,4(r2)
    22c0:	a8c00017 	ldw	r3,0(r21)
    22c4:	300c943a 	slli	r6,r6,16
    22c8:	3084b03a 	or	r2,r6,r2
    22cc:	1010963a 	slli	r8,r2,24
    22d0:	100ed63a 	srli	r7,r2,24
    22d4:	100cd23a 	srli	r6,r2,8
    22d8:	10bfc00c 	andi	r2,r2,65280
    22dc:	1004923a 	slli	r2,r2,8
    22e0:	41ceb03a 	or	r7,r8,r7
    22e4:	31bfc00c 	andi	r6,r6,65280
    22e8:	398cb03a 	or	r6,r7,r6
    22ec:	3084b03a 	or	r2,r6,r2
    22f0:	10ffcf1e 	bne	r2,r3,2230 <dhcp_recv+0x84>
  struct pbuf *q;
  int parse_file_as_options = 0;
  int parse_sname_as_options = 0;

  /* clear received options */
  dhcp_clear_all_options(dhcp);
    22f4:	040001f4 	movhi	r16,7
    22f8:	8412a604 	addi	r16,r16,19096
    22fc:	80000005 	stb	zero,0(r16)
    2300:	80000045 	stb	zero,1(r16)
    2304:	80000085 	stb	zero,2(r16)
    2308:	800000c5 	stb	zero,3(r16)
    230c:	80000105 	stb	zero,4(r16)
    2310:	80000145 	stb	zero,5(r16)
    2314:	80000185 	stb	zero,6(r16)
    2318:	800001c5 	stb	zero,7(r16)
    231c:	80000205 	stb	zero,8(r16)
    2320:	80000245 	stb	zero,9(r16)
  /* parse options */

  /* start with options field */
  options_idx = DHCP_OPTIONS_OFS;
  /* parse options to the end of the received packet */
  options_idx_max = p->tot_len;
    2324:	b200020b 	ldhu	r8,8(r22)
  dhcp_clear_all_options(dhcp);
  /* check that beginning of dhcp_msg (up to and including chaddr) is in first pbuf */
  if (p->len < DHCP_SNAME_OFS) {
    return ERR_BUF;
  }
  dhcp->msg_in = (struct dhcp_msg *)p->payload;
    2328:	b0800117 	ldw	r2,4(r22)
    232c:	dd400115 	stw	r21,4(sp)
      u16_t copy_len;
decode_next:
      LWIP_ASSERT("check decode_idx", decode_idx >= 0 && decode_idx < DHCP_OPTION_IDX_MAX);
      if (!dhcp_option_given(dhcp, decode_idx)) {
        copy_len = LWIP_MIN(decode_len, 4);
        pbuf_copy_partial(q, &value, copy_len, val_offset);
    2330:	05c00104 	movi	r23,4
  dhcp_clear_all_options(dhcp);
  /* check that beginning of dhcp_msg (up to and including chaddr) is in first pbuf */
  if (p->len < DHCP_SNAME_OFS) {
    return ERR_BUF;
  }
  dhcp->msg_in = (struct dhcp_msg *)p->payload;
    2334:	a8800215 	stw	r2,8(r21)
  u16_t offset_max;
  u16_t options_idx;
  u16_t options_idx_max;
  struct pbuf *q;
  int parse_file_as_options = 0;
  int parse_sname_as_options = 0;
    2338:	0015883a 	mov	r10,zero
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* parse options */

  /* start with options field */
  options_idx = DHCP_OPTIONS_OFS;
    233c:	05003c04 	movi	r20,240
    2340:	402b883a 	mov	r21,r8
    2344:	dc800215 	stw	r18,8(sp)
    2348:	b027883a 	mov	r19,r22
  /* parse options to the end of the received packet */
  options_idx_max = p->tot_len;
again:
  q = p;
  while((q != NULL) && (options_idx >= q->len)) {
    234c:	a0bfffcc 	andi	r2,r20,65535
    2350:	11400736 	bltu	r2,r5,2370 <dhcp_recv+0x1c4>
    options_idx -= q->len;
    options_idx_max -= q->len;
    q = q->next;
    2354:	9cc00017 	ldw	r19,0(r19)
  /* parse options to the end of the received packet */
  options_idx_max = p->tot_len;
again:
  q = p;
  while((q != NULL) && (options_idx >= q->len)) {
    options_idx -= q->len;
    2358:	a129c83a 	sub	r20,r20,r4
    options_idx_max -= q->len;
    235c:	a92bc83a 	sub	r21,r21,r4
  options_idx = DHCP_OPTIONS_OFS;
  /* parse options to the end of the received packet */
  options_idx_max = p->tot_len;
again:
  q = p;
  while((q != NULL) && (options_idx >= q->len)) {
    2360:	98005926 	beq	r19,zero,24c8 <dhcp_recv+0x31c>
    2364:	9900028b 	ldhu	r4,10(r19)
    2368:	217fffcc 	andi	r5,r4,65535
    236c:	003ff706 	br	234c <dhcp_recv+0x1a0>
  if (q == NULL) {
    return ERR_BUF;
  }
  offset = options_idx;
  offset_max = options_idx_max;
  options = (u8_t*)q->payload;
    2370:	9f000117 	ldw	fp,4(r19)
    2374:	b01d883a 	mov	r14,r22
    2378:	a813883a 	mov	r9,r21
    237c:	e02d883a 	mov	r22,fp
  /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
  while((q != NULL) && (options[offset] != DHCP_OPTION_END) && (offset < offset_max)) {
    2380:	b08f883a 	add	r7,r22,r2
    2384:	39400003 	ldbu	r5,0(r7)
    2388:	00c03fc4 	movi	r3,255
    238c:	28c17d26 	beq	r5,r3,2984 <dhcp_recv+0x7d8>
    2390:	48ffffcc 	andi	r3,r9,65535
    2394:	10c17b2e 	bgeu	r2,r3,2984 <dhcp_recv+0x7d8>
    u8_t len;
    u8_t decode_len = 0;
    int decode_idx = -1;
    u16_t val_offset = offset + 2;
    /* len byte might be in the next pbuf */
    if (offset + 1 < q->len) {
    2398:	98c0028b 	ldhu	r3,10(r19)
  while((q != NULL) && (options[offset] != DHCP_OPTION_END) && (offset < offset_max)) {
    u8_t op = options[offset];
    u8_t len;
    u8_t decode_len = 0;
    int decode_idx = -1;
    u16_t val_offset = offset + 2;
    239c:	a1800084 	addi	r6,r20,2
    /* len byte might be in the next pbuf */
    if (offset + 1 < q->len) {
    23a0:	10800044 	addi	r2,r2,1
    23a4:	193fffcc 	andi	r4,r3,65535
  while((q != NULL) && (options[offset] != DHCP_OPTION_END) && (offset < offset_max)) {
    u8_t op = options[offset];
    u8_t len;
    u8_t decode_len = 0;
    int decode_idx = -1;
    u16_t val_offset = offset + 2;
    23a8:	3011883a 	mov	r8,r6
    /* len byte might be in the next pbuf */
    if (offset + 1 < q->len) {
    23ac:	1101700e 	bge	r2,r4,2970 <dhcp_recv+0x7c4>
      len = options[offset + 1];
    23b0:	38800043 	ldbu	r2,1(r7)
    } else {
      len = (q->next != NULL ? ((u8_t*)q->next->payload)[0] : 0);
    }
    /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
    decode_len = len;
    switch(op) {
    23b4:	01c00ec4 	movi	r7,59
    23b8:	39421e36 	bltu	r7,r5,2c34 <dhcp_recv+0xa88>
    23bc:	294b883a 	add	r5,r5,r5
    23c0:	294b883a 	add	r5,r5,r5
    23c4:	01c00034 	movhi	r7,0
    23c8:	39c8f604 	addi	r7,r7,9176
    23cc:	29cb883a 	add	r5,r5,r7
    23d0:	29400017 	ldw	r5,0(r5)
    23d4:	2800683a 	jmp	r5
    23d8:	00002864 	muli	zero,zero,161
    23dc:	00002890 	cmplti	zero,zero,162
    23e0:	00002c34 	movhi	zero,176
    23e4:	00002874 	movhi	zero,161
    23e8:	00002c34 	movhi	zero,176
    23ec:	00002c34 	movhi	zero,176
    23f0:	000028ec 	andhi	zero,zero,163
    23f4:	00002c34 	movhi	zero,176
    23f8:	00002c34 	movhi	zero,176
    23fc:	00002c34 	movhi	zero,176
    2400:	00002c34 	movhi	zero,176
    2404:	00002c34 	movhi	zero,176
    2408:	00002c34 	movhi	zero,176
    240c:	00002c34 	movhi	zero,176
    2410:	00002c34 	movhi	zero,176
    2414:	00002c34 	movhi	zero,176
    2418:	00002c34 	movhi	zero,176
    241c:	00002c34 	movhi	zero,176
    2420:	00002c34 	movhi	zero,176
    2424:	00002c34 	movhi	zero,176
    2428:	00002c34 	movhi	zero,176
    242c:	00002c34 	movhi	zero,176
    2430:	00002c34 	movhi	zero,176
    2434:	00002c34 	movhi	zero,176
    2438:	00002c34 	movhi	zero,176
    243c:	00002c34 	movhi	zero,176
    2440:	00002c34 	movhi	zero,176
    2444:	00002c34 	movhi	zero,176
    2448:	00002c34 	movhi	zero,176
    244c:	00002c34 	movhi	zero,176
    2450:	00002c34 	movhi	zero,176
    2454:	00002c34 	movhi	zero,176
    2458:	00002c34 	movhi	zero,176
    245c:	00002c34 	movhi	zero,176
    2460:	00002c34 	movhi	zero,176
    2464:	00002c34 	movhi	zero,176
    2468:	00002c34 	movhi	zero,176
    246c:	00002c34 	movhi	zero,176
    2470:	00002c34 	movhi	zero,176
    2474:	00002c34 	movhi	zero,176
    2478:	00002c34 	movhi	zero,176
    247c:	00002c34 	movhi	zero,176
    2480:	00002c34 	movhi	zero,176
    2484:	00002c34 	movhi	zero,176
    2488:	00002c34 	movhi	zero,176
    248c:	00002c34 	movhi	zero,176
    2490:	00002c34 	movhi	zero,176
    2494:	00002c34 	movhi	zero,176
    2498:	00002c34 	movhi	zero,176
    249c:	00002c34 	movhi	zero,176
    24a0:	00002c34 	movhi	zero,176
    24a4:	00002850 	cmplti	zero,zero,161
    24a8:	0000276c 	andhi	zero,zero,157
    24ac:	00002758 	cmpnei	zero,zero,157
    24b0:	000026fc 	xorhi	zero,zero,155
    24b4:	00002c34 	movhi	zero,176
    24b8:	00002c34 	movhi	zero,176
    24bc:	00002c34 	movhi	zero,176
    24c0:	000026e8 	cmpgeui	zero,zero,155
    24c4:	000024d0 	cmplti	zero,zero,147
    24c8:	dd400117 	ldw	r21,4(sp)
    24cc:	003f5806 	br	2230 <dhcp_recv+0x84>
      case(DHCP_OPTION_T1):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
        decode_idx = DHCP_OPTION_IDX_T1;
        break;
      case(DHCP_OPTION_T2):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    24d0:	11403fcc 	andi	r5,r2,255
    24d4:	2dc02f1e 	bne	r5,r23,2594 <dhcp_recv+0x3e8>
    24d8:	b829883a 	mov	r20,r23
        decode_idx = DHCP_OPTION_IDX_T2;
    24dc:	04400144 	movi	r17,5
      default:
        decode_len = 0;
        LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", op));
        break;
    }
    offset += len + 2;
    24e0:	3529883a 	add	r20,r6,r20
    if (decode_len > 0) {
      u32_t value = 0;
    24e4:	d8000015 	stw	zero,0(sp)
    24e8:	1025883a 	mov	r18,r2
      u16_t copy_len;
decode_next:
      LWIP_ASSERT("check decode_idx", decode_idx >= 0 && decode_idx < DHCP_OPTION_IDX_MAX);
      if (!dhcp_option_given(dhcp, decode_idx)) {
    24ec:	8445883a 	add	r2,r16,r17
    24f0:	10800003 	ldbu	r2,0(r2)
    24f4:	10001c1e 	bne	r2,zero,2568 <dhcp_recv+0x3bc>
        copy_len = LWIP_MIN(decode_len, 4);
    24f8:	95403fcc 	andi	r21,r18,255
    24fc:	008000c4 	movi	r2,3
    2500:	15403f36 	bltu	r2,r21,2600 <dhcp_recv+0x454>
    2504:	070001f4 	movhi	fp,7
    2508:	e712a904 	addi	fp,fp,19108
        pbuf_copy_partial(q, &value, copy_len, val_offset);
    250c:	9809883a 	mov	r4,r19
    2510:	d80b883a 	mov	r5,sp
    2514:	a80d883a 	mov	r6,r21
    2518:	41ffffcc 	andi	r7,r8,65535
    251c:	da400915 	stw	r9,36(sp)
    2520:	da800815 	stw	r10,32(sp)
    2524:	db800a15 	stw	r14,40(sp)
    2528:	00071bc0 	call	71bc <pbuf_copy_partial>
    252c:	da400917 	ldw	r9,36(sp)
    2530:	da800817 	ldw	r10,32(sp)
    2534:	db800a17 	ldw	r14,40(sp)
          decode_idx++;
          goto decode_next;
        } else if (decode_len == 4) {
          value = ntohl(value);
        } else {
          LWIP_ERROR("invalid decode_len", decode_len == 1, return ERR_VAL;);
    2538:	00800044 	movi	r2,1
    253c:	a880271e 	bne	r21,r2,25dc <dhcp_recv+0x430>
          value = ((u8_t*)&value)[0];
    2540:	d8800003 	ldbu	r2,0(sp)
        }
        dhcp_got_option(dhcp, decode_idx);
    2544:	8447883a 	add	r3,r16,r17
    2548:	01000044 	movi	r4,1
    254c:	19000005 	stb	r4,0(r3)
    2550:	98c0028b 	ldhu	r3,10(r19)
        dhcp_set_option_value(dhcp, decode_idx, value);
    2554:	8c63883a 	add	r17,r17,r17
    2558:	8c63883a 	add	r17,r17,r17
    255c:	e479883a 	add	fp,fp,r17
    2560:	e0800015 	stw	r2,0(fp)
    2564:	193fffcc 	andi	r4,r3,65535
      }
    }
    if (offset >= q->len) {
    2568:	a0bfffcc 	andi	r2,r20,65535
    256c:	113f8436 	bltu	r2,r4,2380 <dhcp_recv+0x1d4>
      offset -= q->len;
    2570:	a0e9c83a 	sub	r20,r20,r3
      offset_max -= q->len;
    2574:	48d3c83a 	sub	r9,r9,r3
      if ((offset < offset_max) && offset_max) {
    2578:	a0bfffcc 	andi	r2,r20,65535
    257c:	48ffffcc 	andi	r3,r9,65535
    2580:	10c1002e 	bgeu	r2,r3,2984 <dhcp_recv+0x7d8>
        q = q->next;
    2584:	9cc00017 	ldw	r19,0(r19)
        LWIP_ASSERT("next pbuf was null", q);
    2588:	98000b26 	beq	r19,zero,25b8 <dhcp_recv+0x40c>
        options = (u8_t*)q->payload;
    258c:	9d800117 	ldw	r22,4(r19)
    2590:	003f7b06 	br	2380 <dhcp_recv+0x1d4>
      case(DHCP_OPTION_T1):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
        decode_idx = DHCP_OPTION_IDX_T1;
        break;
      case(DHCP_OPTION_T2):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    2594:	010000b4 	movhi	r4,2
    2598:	210d4b04 	addi	r4,r4,13612
    259c:	014000b4 	movhi	r5,2
    25a0:	29522104 	addi	r5,r5,18564
    25a4:	01816804 	movi	r6,1440
    25a8:	01c000b4 	movhi	r7,2
    25ac:	39d15a04 	addi	r7,r7,17768
    25b0:	00104380 	call	10438 <printf>
    25b4:	003fff06 	br	25b4 <dhcp_recv+0x408>
    if (offset >= q->len) {
      offset -= q->len;
      offset_max -= q->len;
      if ((offset < offset_max) && offset_max) {
        q = q->next;
        LWIP_ASSERT("next pbuf was null", q);
    25b8:	010000b4 	movhi	r4,2
    25bc:	210d4b04 	addi	r4,r4,13612
    25c0:	014000b4 	movhi	r5,2
    25c4:	29523f04 	addi	r5,r5,18684
    25c8:	01817244 	movi	r6,1481
    25cc:	01c000b4 	movhi	r7,2
    25d0:	39d15a04 	addi	r7,r7,17768
    25d4:	00104380 	call	10438 <printf>
    25d8:	003fff06 	br	25d8 <dhcp_recv+0x42c>
          decode_idx++;
          goto decode_next;
        } else if (decode_len == 4) {
          value = ntohl(value);
        } else {
          LWIP_ERROR("invalid decode_len", decode_len == 1, return ERR_VAL;);
    25dc:	010000b4 	movhi	r4,2
    25e0:	210d4b04 	addi	r4,r4,13612
    25e4:	014000b4 	movhi	r5,2
    25e8:	29523a04 	addi	r5,r5,18664
    25ec:	01816f44 	movi	r6,1469
    25f0:	01c000b4 	movhi	r7,2
    25f4:	39d15a04 	addi	r7,r7,17768
    25f8:	00104380 	call	10438 <printf>
    25fc:	003fff06 	br	25fc <dhcp_recv+0x450>

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void
dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *addr, u16_t port)
    2600:	8c47883a 	add	r3,r17,r17
    2604:	18c7883a 	add	r3,r3,r3
    2608:	070001f4 	movhi	fp,7
    260c:	e712a904 	addi	fp,fp,19108
    2610:	e0c7883a 	add	r3,fp,r3
        copy_len = LWIP_MIN(decode_len, 4);
        pbuf_copy_partial(q, &value, copy_len, val_offset);
        if (decode_len > 4) {
          /* decode more than one u32_t */
          LWIP_ERROR("decode_len % 4 == 0", decode_len % 4 == 0, return ERR_VAL;);
          dhcp_got_option(dhcp, decode_idx);
    2614:	03400044 	movi	r13,1
    offset += len + 2;
    if (decode_len > 0) {
      u32_t value = 0;
      u16_t copy_len;
decode_next:
      LWIP_ASSERT("check decode_idx", decode_idx >= 0 && decode_idx < DHCP_OPTION_IDX_MAX);
    2618:	03000284 	movi	r12,10
      if (!dhcp_option_given(dhcp, decode_idx)) {
        copy_len = LWIP_MIN(decode_len, 4);
    261c:	1017883a 	mov	r11,r2
        pbuf_copy_partial(q, &value, copy_len, val_offset);
    2620:	41ffffcc 	andi	r7,r8,65535
    2624:	9809883a 	mov	r4,r19
    2628:	d80b883a 	mov	r5,sp
    262c:	01800104 	movi	r6,4
    2630:	d8c00715 	stw	r3,28(sp)
    2634:	da000615 	stw	r8,24(sp)
    2638:	da400915 	stw	r9,36(sp)
    263c:	da800815 	stw	r10,32(sp)
    2640:	dac00515 	stw	r11,20(sp)
    2644:	db000415 	stw	r12,16(sp)
    2648:	db400315 	stw	r13,12(sp)
    264c:	db800a15 	stw	r14,40(sp)
    2650:	00071bc0 	call	71bc <pbuf_copy_partial>
        if (decode_len > 4) {
    2654:	d8c00717 	ldw	r3,28(sp)
    2658:	da000617 	ldw	r8,24(sp)
    265c:	da400917 	ldw	r9,36(sp)
    2660:	da800817 	ldw	r10,32(sp)
    2664:	dac00517 	ldw	r11,20(sp)
    2668:	db000417 	ldw	r12,16(sp)
    266c:	db400317 	ldw	r13,12(sp)
    2670:	db800a17 	ldw	r14,40(sp)
    2674:	bd40692e 	bgeu	r23,r21,281c <dhcp_recv+0x670>
          /* decode more than one u32_t */
          LWIP_ERROR("decode_len % 4 == 0", decode_len % 4 == 0, return ERR_VAL;);
    2678:	908000cc 	andi	r2,r18,3
    267c:	10005e1e 	bne	r2,zero,27f8 <dhcp_recv+0x64c>
          dhcp_got_option(dhcp, decode_idx);
          dhcp_set_option_value(dhcp, decode_idx, htonl(value));
    2680:	d8800017 	ldw	r2,0(sp)

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void
dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *addr, u16_t port)
    2684:	8449883a 	add	r4,r16,r17
        copy_len = LWIP_MIN(decode_len, 4);
        pbuf_copy_partial(q, &value, copy_len, val_offset);
        if (decode_len > 4) {
          /* decode more than one u32_t */
          LWIP_ERROR("decode_len % 4 == 0", decode_len % 4 == 0, return ERR_VAL;);
          dhcp_got_option(dhcp, decode_idx);
    2688:	23400005 	stb	r13,0(r4)
          dhcp_set_option_value(dhcp, decode_idx, htonl(value));
    268c:	100c963a 	slli	r6,r2,24
    2690:	100ad63a 	srli	r5,r2,24
    2694:	1008d23a 	srli	r4,r2,8
    2698:	10bfc00c 	andi	r2,r2,65280
    269c:	1004923a 	slli	r2,r2,8
    26a0:	314ab03a 	or	r5,r6,r5
    26a4:	213fc00c 	andi	r4,r4,65280
    26a8:	2908b03a 	or	r4,r5,r4
    26ac:	2084b03a 	or	r2,r4,r2
    26b0:	18800015 	stw	r2,0(r3)
          decode_len -= 4;
          val_offset += 4;
          decode_idx++;
    26b4:	8c400044 	addi	r17,r17,1
        if (decode_len > 4) {
          /* decode more than one u32_t */
          LWIP_ERROR("decode_len % 4 == 0", decode_len % 4 == 0, return ERR_VAL;);
          dhcp_got_option(dhcp, decode_idx);
          dhcp_set_option_value(dhcp, decode_idx, htonl(value));
          decode_len -= 4;
    26b8:	94bfff04 	addi	r18,r18,-4
          val_offset += 4;
    26bc:	42000104 	addi	r8,r8,4
    offset += len + 2;
    if (decode_len > 0) {
      u32_t value = 0;
      u16_t copy_len;
decode_next:
      LWIP_ASSERT("check decode_idx", decode_idx >= 0 && decode_idx < DHCP_OPTION_IDX_MAX);
    26c0:	8b004426 	beq	r17,r12,27d4 <dhcp_recv+0x628>

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void
dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *addr, u16_t port)
    26c4:	010001f4 	movhi	r4,7
    26c8:	2112a604 	addi	r4,r4,19096
    26cc:	8905883a 	add	r2,r17,r4
    if (decode_len > 0) {
      u32_t value = 0;
      u16_t copy_len;
decode_next:
      LWIP_ASSERT("check decode_idx", decode_idx >= 0 && decode_idx < DHCP_OPTION_IDX_MAX);
      if (!dhcp_option_given(dhcp, decode_idx)) {
    26d0:	10800003 	ldbu	r2,0(r2)
    26d4:	10003c1e 	bne	r2,zero,27c8 <dhcp_recv+0x61c>
        copy_len = LWIP_MIN(decode_len, 4);
    26d8:	95403fcc 	andi	r21,r18,255
    26dc:	18c00104 	addi	r3,r3,4
    26e0:	5d7fcf36 	bltu	r11,r21,2620 <dhcp_recv+0x474>
    26e4:	003f8906 	br	250c <dhcp_recv+0x360>
      case(DHCP_OPTION_SERVER_ID):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
        decode_idx = DHCP_OPTION_IDX_SERVER_ID;
        break;
      case(DHCP_OPTION_T1):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    26e8:	11403fcc 	andi	r5,r2,255
    26ec:	2dc0081e 	bne	r5,r23,2710 <dhcp_recv+0x564>
    26f0:	b829883a 	mov	r20,r23
        decode_idx = DHCP_OPTION_IDX_T1;
    26f4:	b823883a 	mov	r17,r23
    26f8:	003f7906 	br	24e0 <dhcp_recv+0x334>
      case(DHCP_OPTION_MESSAGE_TYPE):
        LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
        decode_idx = DHCP_OPTION_IDX_MSG_TYPE;
        break;
      case(DHCP_OPTION_SERVER_ID):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    26fc:	11403fcc 	andi	r5,r2,255
    2700:	2dc00c1e 	bne	r5,r23,2734 <dhcp_recv+0x588>
    2704:	b829883a 	mov	r20,r23
        decode_idx = DHCP_OPTION_IDX_SERVER_ID;
    2708:	04400084 	movi	r17,2
    270c:	003f7406 	br	24e0 <dhcp_recv+0x334>
        break;
      case(DHCP_OPTION_T1):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    2710:	010000b4 	movhi	r4,2
    2714:	210d4b04 	addi	r4,r4,13612
    2718:	014000b4 	movhi	r5,2
    271c:	29522104 	addi	r5,r5,18564
    2720:	01816704 	movi	r6,1436
    2724:	01c000b4 	movhi	r7,2
    2728:	39d15a04 	addi	r7,r7,17768
    272c:	00104380 	call	10438 <printf>
    2730:	003fff06 	br	2730 <dhcp_recv+0x584>
      case(DHCP_OPTION_MESSAGE_TYPE):
        LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
        decode_idx = DHCP_OPTION_IDX_MSG_TYPE;
        break;
      case(DHCP_OPTION_SERVER_ID):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    2734:	010000b4 	movhi	r4,2
    2738:	210d4b04 	addi	r4,r4,13612
    273c:	014000b4 	movhi	r5,2
    2740:	29522104 	addi	r5,r5,18564
    2744:	01816604 	movi	r6,1432
    2748:	01c000b4 	movhi	r7,2
    274c:	39d15a04 	addi	r7,r7,17768
    2750:	00104380 	call	10438 <printf>
    2754:	003fff06 	br	2754 <dhcp_recv+0x5a8>
      case(DHCP_OPTION_OVERLOAD):
        LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
        decode_idx = DHCP_OPTION_IDX_OVERLOAD;
        break;
      case(DHCP_OPTION_MESSAGE_TYPE):
        LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
    2758:	14403fcc 	andi	r17,r2,255
    275c:	01400044 	movi	r5,1
    2760:	8940071e 	bne	r17,r5,2780 <dhcp_recv+0x5d4>
    2764:	8829883a 	mov	r20,r17
    2768:	003f5d06 	br	24e0 <dhcp_recv+0x334>
      case(DHCP_OPTION_LEASE_TIME):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
        decode_idx = DHCP_OPTION_IDX_LEASE_TIME;
        break;
      case(DHCP_OPTION_OVERLOAD):
        LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
    276c:	15003fcc 	andi	r20,r2,255
    2770:	01400044 	movi	r5,1
    2774:	a1400b1e 	bne	r20,r5,27a4 <dhcp_recv+0x5f8>
        decode_idx = DHCP_OPTION_IDX_OVERLOAD;
    2778:	0023883a 	mov	r17,zero
    277c:	003f5806 	br	24e0 <dhcp_recv+0x334>
        break;
      case(DHCP_OPTION_MESSAGE_TYPE):
        LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
    2780:	010000b4 	movhi	r4,2
    2784:	210d4b04 	addi	r4,r4,13612
    2788:	014000b4 	movhi	r5,2
    278c:	29522d04 	addi	r5,r5,18612
    2790:	01816504 	movi	r6,1428
    2794:	01c000b4 	movhi	r7,2
    2798:	39d15a04 	addi	r7,r7,17768
    279c:	00104380 	call	10438 <printf>
    27a0:	003fff06 	br	27a0 <dhcp_recv+0x5f4>
      case(DHCP_OPTION_LEASE_TIME):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
        decode_idx = DHCP_OPTION_IDX_LEASE_TIME;
        break;
      case(DHCP_OPTION_OVERLOAD):
        LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
    27a4:	010000b4 	movhi	r4,2
    27a8:	210d4b04 	addi	r4,r4,13612
    27ac:	014000b4 	movhi	r5,2
    27b0:	29522d04 	addi	r5,r5,18612
    27b4:	01816404 	movi	r6,1424
    27b8:	01c000b4 	movhi	r7,2
    27bc:	39d15a04 	addi	r7,r7,17768
    27c0:	00104380 	call	10438 <printf>
    27c4:	003fff06 	br	27c4 <dhcp_recv+0x618>
    27c8:	98c0028b 	ldhu	r3,10(r19)
    27cc:	193fffcc 	andi	r4,r3,65535
    27d0:	003f6506 	br	2568 <dhcp_recv+0x3bc>
    offset += len + 2;
    if (decode_len > 0) {
      u32_t value = 0;
      u16_t copy_len;
decode_next:
      LWIP_ASSERT("check decode_idx", decode_idx >= 0 && decode_idx < DHCP_OPTION_IDX_MAX);
    27d4:	010000b4 	movhi	r4,2
    27d8:	210d4b04 	addi	r4,r4,13612
    27dc:	014000b4 	movhi	r5,2
    27e0:	29523004 	addi	r5,r5,18624
    27e4:	01816b44 	movi	r6,1453
    27e8:	01c000b4 	movhi	r7,2
    27ec:	39d15a04 	addi	r7,r7,17768
    27f0:	00104380 	call	10438 <printf>
    27f4:	003fff06 	br	27f4 <dhcp_recv+0x648>
      if (!dhcp_option_given(dhcp, decode_idx)) {
        copy_len = LWIP_MIN(decode_len, 4);
        pbuf_copy_partial(q, &value, copy_len, val_offset);
        if (decode_len > 4) {
          /* decode more than one u32_t */
          LWIP_ERROR("decode_len % 4 == 0", decode_len % 4 == 0, return ERR_VAL;);
    27f8:	010000b4 	movhi	r4,2
    27fc:	210d4b04 	addi	r4,r4,13612
    2800:	014000b4 	movhi	r5,2
    2804:	29523504 	addi	r5,r5,18644
    2808:	01816cc4 	movi	r6,1459
    280c:	01c000b4 	movhi	r7,2
    2810:	39d15a04 	addi	r7,r7,17768
    2814:	00104380 	call	10438 <printf>
    2818:	003fff06 	br	2818 <dhcp_recv+0x66c>
          dhcp_set_option_value(dhcp, decode_idx, htonl(value));
          decode_len -= 4;
          val_offset += 4;
          decode_idx++;
          goto decode_next;
        } else if (decode_len == 4) {
    281c:	01c00104 	movi	r7,4
    2820:	a9ff451e 	bne	r21,r7,2538 <dhcp_recv+0x38c>
          value = ntohl(value);
    2824:	d8800017 	ldw	r2,0(sp)
    2828:	100a963a 	slli	r5,r2,24
    282c:	1008d63a 	srli	r4,r2,24
    2830:	1006d23a 	srli	r3,r2,8
    2834:	10bfc00c 	andi	r2,r2,65280
    2838:	1004923a 	slli	r2,r2,8
    283c:	2908b03a 	or	r4,r5,r4
    2840:	18ffc00c 	andi	r3,r3,65280
    2844:	20c6b03a 	or	r3,r4,r3
    2848:	1884b03a 	or	r2,r3,r2
    284c:	003f3d06 	br	2544 <dhcp_recv+0x398>
        decode_len = LWIP_MIN(len, 4 * DNS_MAX_SERVERS);
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
        decode_idx = DHCP_OPTION_IDX_DNS_SERVER;
        break;
      case(DHCP_OPTION_LEASE_TIME):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    2850:	11403fcc 	andi	r5,r2,255
    2854:	2dc0f91e 	bne	r5,r23,2c3c <dhcp_recv+0xa90>
    2858:	b829883a 	mov	r20,r23
        decode_idx = DHCP_OPTION_IDX_LEASE_TIME;
    285c:	044000c4 	movi	r17,3
    2860:	003f1f06 	br	24e0 <dhcp_recv+0x334>
    2864:	a2000044 	addi	r8,r20,1
    2868:	0005883a 	mov	r2,zero
      default:
        decode_len = 0;
        LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", op));
        break;
    }
    offset += len + 2;
    286c:	40a9883a 	add	r20,r8,r2
    2870:	003f3d06 	br	2568 <dhcp_recv+0x3bc>
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
        decode_idx = DHCP_OPTION_IDX_SUBNET_MASK;
        break;
      case(DHCP_OPTION_ROUTER):
        decode_len = 4; /* only copy the first given router */
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
    2874:	11403fcc 	andi	r5,r2,255
    2878:	01c000c4 	movi	r7,3
    287c:	3940092e 	bgeu	r7,r5,28a4 <dhcp_recv+0x6f8>
    2880:	15003fcc 	andi	r20,r2,255
        decode_idx = DHCP_OPTION_IDX_ROUTER;
    2884:	044001c4 	movi	r17,7
      case(DHCP_OPTION_SUBNET_MASK):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
        decode_idx = DHCP_OPTION_IDX_SUBNET_MASK;
        break;
      case(DHCP_OPTION_ROUTER):
        decode_len = 4; /* only copy the first given router */
    2888:	00800104 	movi	r2,4
    288c:	003f1406 	br	24e0 <dhcp_recv+0x334>
        decode_len = len = 0;
        /* will be increased below */
        offset--;
        break;
      case(DHCP_OPTION_SUBNET_MASK):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    2890:	11403fcc 	andi	r5,r2,255
    2894:	2dc00c1e 	bne	r5,r23,28c8 <dhcp_recv+0x71c>
    2898:	b829883a 	mov	r20,r23
        decode_idx = DHCP_OPTION_IDX_SUBNET_MASK;
    289c:	04400184 	movi	r17,6
    28a0:	003f0f06 	br	24e0 <dhcp_recv+0x334>
        break;
      case(DHCP_OPTION_ROUTER):
        decode_len = 4; /* only copy the first given router */
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
    28a4:	010000b4 	movhi	r4,2
    28a8:	210d4b04 	addi	r4,r4,13612
    28ac:	014000b4 	movhi	r5,2
    28b0:	29522404 	addi	r5,r5,18576
    28b4:	01816004 	movi	r6,1408
    28b8:	01c000b4 	movhi	r7,2
    28bc:	39d15a04 	addi	r7,r7,17768
    28c0:	00104380 	call	10438 <printf>
    28c4:	003fff06 	br	28c4 <dhcp_recv+0x718>
        decode_len = len = 0;
        /* will be increased below */
        offset--;
        break;
      case(DHCP_OPTION_SUBNET_MASK):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    28c8:	010000b4 	movhi	r4,2
    28cc:	210d4b04 	addi	r4,r4,13612
    28d0:	014000b4 	movhi	r5,2
    28d4:	29522104 	addi	r5,r5,18564
    28d8:	01815ec4 	movi	r6,1403
    28dc:	01c000b4 	movhi	r7,2
    28e0:	39d15a04 	addi	r7,r7,17768
    28e4:	00104380 	call	10438 <printf>
    28e8:	003fff06 	br	28e8 <dhcp_recv+0x73c>
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
        decode_idx = DHCP_OPTION_IDX_ROUTER;
        break;
      case(DHCP_OPTION_DNS_SERVER):
        /* special case: there might be more than one server */
        LWIP_ERROR("len % 4 == 0", len % 4 == 0, return ERR_VAL;);
    28ec:	114000cc 	andi	r5,r2,3
    28f0:	28000d1e 	bne	r5,zero,2928 <dhcp_recv+0x77c>
        /* limit number of DNS servers */
        decode_len = LWIP_MIN(len, 4 * DNS_MAX_SERVERS);
    28f4:	11c03fcc 	andi	r7,r2,255
    28f8:	01400204 	movi	r5,8
    28fc:	1025883a 	mov	r18,r2
    2900:	29c0012e 	bgeu	r5,r7,2908 <dhcp_recv+0x75c>
    2904:	2825883a 	mov	r18,r5
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
    2908:	91403fcc 	andi	r5,r18,255
    290c:	39400f36 	bltu	r7,r5,294c <dhcp_recv+0x7a0>
      default:
        decode_len = 0;
        LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", op));
        break;
    }
    offset += len + 2;
    2910:	10803fcc 	andi	r2,r2,255
    2914:	30a9883a 	add	r20,r6,r2
    if (decode_len > 0) {
    2918:	283f1326 	beq	r5,zero,2568 <dhcp_recv+0x3bc>
      u32_t value = 0;
    291c:	d8000015 	stw	zero,0(sp)
        /* special case: there might be more than one server */
        LWIP_ERROR("len % 4 == 0", len % 4 == 0, return ERR_VAL;);
        /* limit number of DNS servers */
        decode_len = LWIP_MIN(len, 4 * DNS_MAX_SERVERS);
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
        decode_idx = DHCP_OPTION_IDX_DNS_SERVER;
    2920:	04400204 	movi	r17,8
    2924:	003ef106 	br	24ec <dhcp_recv+0x340>
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
        decode_idx = DHCP_OPTION_IDX_ROUTER;
        break;
      case(DHCP_OPTION_DNS_SERVER):
        /* special case: there might be more than one server */
        LWIP_ERROR("len % 4 == 0", len % 4 == 0, return ERR_VAL;);
    2928:	010000b4 	movhi	r4,2
    292c:	210d4b04 	addi	r4,r4,13612
    2930:	014000b4 	movhi	r5,2
    2934:	29522904 	addi	r5,r5,18596
    2938:	01816144 	movi	r6,1413
    293c:	01c000b4 	movhi	r7,2
    2940:	39d15a04 	addi	r7,r7,17768
    2944:	00104380 	call	10438 <printf>
    2948:	003fff06 	br	2948 <dhcp_recv+0x79c>
        /* limit number of DNS servers */
        decode_len = LWIP_MIN(len, 4 * DNS_MAX_SERVERS);
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
    294c:	010000b4 	movhi	r4,2
    2950:	210d4b04 	addi	r4,r4,13612
    2954:	014000b4 	movhi	r5,2
    2958:	29522404 	addi	r5,r5,18576
    295c:	01816204 	movi	r6,1416
    2960:	01c000b4 	movhi	r7,2
    2964:	39d15a04 	addi	r7,r7,17768
    2968:	00104380 	call	10438 <printf>
    296c:	003fff06 	br	296c <dhcp_recv+0x7c0>
    u16_t val_offset = offset + 2;
    /* len byte might be in the next pbuf */
    if (offset + 1 < q->len) {
      len = options[offset + 1];
    } else {
      len = (q->next != NULL ? ((u8_t*)q->next->payload)[0] : 0);
    2970:	98800017 	ldw	r2,0(r19)
    2974:	1000ad26 	beq	r2,zero,2c2c <dhcp_recv+0xa80>
    2978:	10800117 	ldw	r2,4(r2)
    297c:	10800003 	ldbu	r2,0(r2)
    2980:	003e8c06 	br	23b4 <dhcp_recv+0x208>
        break;
      }
    }
  }
  /* is this an overloaded message? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_OVERLOAD)) {
    2984:	80800003 	ldbu	r2,0(r16)
    2988:	702d883a 	mov	r22,r14
    298c:	10000c26 	beq	r2,zero,29c0 <dhcp_recv+0x814>
    u32_t overload = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_OVERLOAD);
    2990:	00c001f4 	movhi	r3,7
    2994:	18d2a904 	addi	r3,r3,19108
    2998:	18800017 	ldw	r2,0(r3)
    dhcp_clear_option(dhcp, DHCP_OPTION_IDX_OVERLOAD);
    299c:	010001f4 	movhi	r4,7
    29a0:	2112a604 	addi	r4,r4,19096
    29a4:	20000005 	stb	zero,0(r4)
    if (overload == DHCP_OVERLOAD_FILE) {
    29a8:	00c00044 	movi	r3,1
    29ac:	10c03526 	beq	r2,r3,2a84 <dhcp_recv+0x8d8>
      parse_file_as_options = 1;
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded file field\n"));
    } else if (overload == DHCP_OVERLOAD_SNAME) {
    29b0:	01000084 	movi	r4,2
    29b4:	11000326 	beq	r2,r4,29c4 <dhcp_recv+0x818>
      parse_sname_as_options = 1;
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded sname field\n"));
    } else if (overload == DHCP_OVERLOAD_SNAME_FILE) {
    29b8:	010000c4 	movi	r4,3
    29bc:	11003026 	beq	r2,r4,2a80 <dhcp_recv+0x8d4>
    /* if both are overloaded, parse file first and then sname (RFC 2131 ch. 4.1) */
    parse_file_as_options = 0;
    options_idx = DHCP_FILE_OFS;
    options_idx_max = DHCP_FILE_OFS + DHCP_FILE_LEN;
    goto again;
  } else if (parse_sname_as_options) {
    29c0:	50000626 	beq	r10,zero,29dc <dhcp_recv+0x830>
    parse_sname_as_options = 0;
    29c4:	0015883a 	mov	r10,zero
    options_idx = DHCP_SNAME_OFS;
    options_idx_max = DHCP_SNAME_OFS + DHCP_SNAME_LEN;
    29c8:	05401b04 	movi	r21,108
    options_idx = DHCP_FILE_OFS;
    options_idx_max = DHCP_FILE_OFS + DHCP_FILE_LEN;
    goto again;
  } else if (parse_sname_as_options) {
    parse_sname_as_options = 0;
    options_idx = DHCP_SNAME_OFS;
    29cc:	05000b04 	movi	r20,44
    29d0:	b100028b 	ldhu	r4,10(r22)
    29d4:	217fffcc 	andi	r5,r4,65535
    29d8:	003e5b06 	br	2348 <dhcp_recv+0x19c>
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  if (!dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE)) {
    29dc:	80800043 	ldbu	r2,1(r16)
    29e0:	dd400117 	ldw	r21,4(sp)
    29e4:	dc800217 	ldw	r18,8(sp)
    29e8:	010001f4 	movhi	r4,7
    29ec:	2112a604 	addi	r4,r4,19096
    29f0:	103e0f26 	beq	r2,zero,2230 <dhcp_recv+0x84>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  }

  /* read DHCP message type */
  msg_type = (u8_t)dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_MSG_TYPE);
    29f4:	00c001f4 	movhi	r3,7
    29f8:	18d2a904 	addi	r3,r3,19108
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
    29fc:	18800103 	ldbu	r2,4(r3)
    2a00:	01400144 	movi	r5,5
    2a04:	11404126 	beq	r2,r5,2b0c <dhcp_recv+0x960>
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
    2a08:	01400184 	movi	r5,6
    2a0c:	11402026 	beq	r2,r5,2a90 <dhcp_recv+0x8e4>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_NAK received\n"));
    dhcp_handle_nak(netif);
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
    2a10:	01800084 	movi	r6,2
    2a14:	11be061e 	bne	r2,r6,2230 <dhcp_recv+0x84>
    2a18:	a8800303 	ldbu	r2,12(r21)
    2a1c:	117e041e 	bne	r2,r5,2230 <dhcp_recv+0x84>
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* obtain the server address */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SERVER_ID)) {
    2a20:	20800083 	ldbu	r2,2(r4)
    dhcp_handle_nak(netif);
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
    2a24:	a800068d 	sth	zero,26(r21)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
    2a28:	91400817 	ldw	r5,32(r18)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* obtain the server address */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SERVER_ID)) {
    2a2c:	103e0026 	beq	r2,zero,2230 <dhcp_recv+0x84>
    ip4_addr_set_u32(&dhcp->server_ip_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SERVER_ID)));
    2a30:	18800217 	ldw	r2,8(r3)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n",
      ip4_addr_get_u32(&dhcp->server_ip_addr)));
    /* remember offered address */
    ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
    2a34:	28c00217 	ldw	r3,8(r5)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n",
      ip4_addr_get_u32(&dhcp->offered_ip_addr)));

    dhcp_select(netif);
    2a38:	9009883a 	mov	r4,r18
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* obtain the server address */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SERVER_ID)) {
    ip4_addr_set_u32(&dhcp->server_ip_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SERVER_ID)));
    2a3c:	1010963a 	slli	r8,r2,24
    2a40:	100ed63a 	srli	r7,r2,24
    2a44:	100cd23a 	srli	r6,r2,8
    2a48:	10bfc00c 	andi	r2,r2,65280
    2a4c:	1004923a 	slli	r2,r2,8
    2a50:	41ceb03a 	or	r7,r8,r7
    2a54:	31bfc00c 	andi	r6,r6,65280
    2a58:	398cb03a 	or	r6,r7,r6
    2a5c:	3084b03a 	or	r2,r6,r2
    2a60:	28800815 	stw	r2,32(r5)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n",
      ip4_addr_get_u32(&dhcp->server_ip_addr)));
    /* remember offered address */
    ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
    2a64:	1980048b 	ldhu	r6,18(r3)
    2a68:	1880040b 	ldhu	r2,16(r3)
    2a6c:	3006943a 	slli	r3,r6,16
    2a70:	1884b03a 	or	r2,r3,r2
    2a74:	28800915 	stw	r2,36(r5)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n",
      ip4_addr_get_u32(&dhcp->offered_ip_addr)));

    dhcp_select(netif);
    2a78:	0001fc00 	call	1fc0 <dhcp_select>
    2a7c:	003dec06 	br	2230 <dhcp_recv+0x84>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded file field\n"));
    } else if (overload == DHCP_OVERLOAD_SNAME) {
      parse_sname_as_options = 1;
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded sname field\n"));
    } else if (overload == DHCP_OVERLOAD_SNAME_FILE) {
      parse_sname_as_options = 1;
    2a80:	1815883a 	mov	r10,r3
  }
  if (parse_file_as_options) {
    /* if both are overloaded, parse file first and then sname (RFC 2131 ch. 4.1) */
    parse_file_as_options = 0;
    options_idx = DHCP_FILE_OFS;
    options_idx_max = DHCP_FILE_OFS + DHCP_FILE_LEN;
    2a84:	05403b04 	movi	r21,236
#endif /* LWIP_DHCP_BOOTP_FILE */
  }
  if (parse_file_as_options) {
    /* if both are overloaded, parse file first and then sname (RFC 2131 ch. 4.1) */
    parse_file_as_options = 0;
    options_idx = DHCP_FILE_OFS;
    2a88:	05001b04 	movi	r20,108
    2a8c:	003fd006 	br	29d0 <dhcp_recv+0x824>
    2a90:	a8800303 	ldbu	r2,12(r21)
    2a94:	00c00044 	movi	r3,1
    2a98:	10c00426 	beq	r2,r3,2aac <dhcp_recv+0x900>
    2a9c:	103de426 	beq	r2,zero,2230 <dhcp_recv+0x84>
    2aa0:	10bfff44 	addi	r2,r2,-3
    2aa4:	00c00084 	movi	r3,2
    2aa8:	18bde136 	bltu	r3,r2,2230 <dhcp_recv+0x84>
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
    2aac:	9009883a 	mov	r4,r18
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
    2ab0:	94000817 	ldw	r16,32(r18)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
    2ab4:	00065040 	call	6504 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
    2ab8:	9009883a 	mov	r4,r18
    2abc:	014000f4 	movhi	r5,3
    2ac0:	29660004 	addi	r5,r5,-26624
    2ac4:	00062640 	call	6264 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
    2ac8:	9009883a 	mov	r4,r18
    2acc:	014000f4 	movhi	r5,3
    2ad0:	29660004 	addi	r5,r5,-26624
    2ad4:	00064980 	call	6498 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
    2ad8:	9009883a 	mov	r4,r18
    2adc:	014000f4 	movhi	r5,3
    2ae0:	29660004 	addi	r5,r5,-26624
    2ae4:	00064b40 	call	64b4 <netif_set_netmask>
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
    2ae8:	80c00303 	ldbu	r3,12(r16)
    2aec:	00800304 	movi	r2,12
    2af0:	18800326 	beq	r3,r2,2b00 <dhcp_recv+0x954>
    dhcp->state = new_state;
    2af4:	80800305 	stb	r2,12(r16)
    dhcp->tries = 0;
    2af8:	80000345 	stb	zero,13(r16)
    dhcp->request_timeout = 0;
    2afc:	8000068d 	sth	zero,26(r16)
  netif_set_gw(netif, IP_ADDR_ANY);
  netif_set_netmask(netif, IP_ADDR_ANY); 
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  /* We can immediately restart discovery */
  dhcp_discover(netif);
    2b00:	9009883a 	mov	r4,r18
    2b04:	0001e500 	call	1e50 <dhcp_discover>
    2b08:	003dc906 	br	2230 <dhcp_recv+0x84>
  msg_type = (u8_t)dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_MSG_TYPE);
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
    2b0c:	a8800303 	ldbu	r2,12(r21)
    2b10:	01400044 	movi	r5,1
    2b14:	11803fcc 	andi	r6,r2,255
    2b18:	31400726 	beq	r6,r5,2b38 <dhcp_recv+0x98c>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
    2b1c:	10bfff44 	addi	r2,r2,-3
    2b20:	10803fcc 	andi	r2,r2,255
    2b24:	00c00084 	movi	r3,2
    2b28:	18bdc136 	bltu	r3,r2,2230 <dhcp_recv+0x84>
      dhcp_bind(netif);
    2b2c:	9009883a 	mov	r4,r18
    2b30:	00014880 	call	1488 <dhcp_bind>
    2b34:	003dbe06 	br	2230 <dhcp_recv+0x84>
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
    2b38:	90800817 	ldw	r2,32(r18)
#if LWIP_DHCP_BOOTP_FILE
  ip_addr_set_zero(&dhcp->offered_si_addr);
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* lease time given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_LEASE_TIME)) {
    2b3c:	210000c3 	ldbu	r4,3(r4)
#if LWIP_DNS
  u8_t n;
#endif /* LWIP_DNS */

  /* clear options we might not get from the ACK */
  ip_addr_set_zero(&dhcp->offered_sn_mask);
    2b40:	10000a15 	stw	zero,40(r2)
  ip_addr_set_zero(&dhcp->offered_gw_addr);
    2b44:	10000b15 	stw	zero,44(r2)
#if LWIP_DHCP_BOOTP_FILE
  ip_addr_set_zero(&dhcp->offered_si_addr);
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* lease time given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_LEASE_TIME)) {
    2b48:	20000226 	beq	r4,zero,2b54 <dhcp_recv+0x9a8>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_LEASE_TIME);
    2b4c:	19000317 	ldw	r4,12(r3)
    2b50:	11000c15 	stw	r4,48(r2)
  }
  /* renewal period given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T1)) {
    2b54:	81000103 	ldbu	r4,4(r16)
    2b58:	20003026 	beq	r4,zero,2c1c <dhcp_recv+0xa70>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T1);
    2b5c:	19000417 	ldw	r4,16(r3)
    2b60:	11000d15 	stw	r4,52(r2)
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  }

  /* renewal period given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T2)) {
    2b64:	81000143 	ldbu	r4,5(r16)
    2b68:	20002926 	beq	r4,zero,2c10 <dhcp_recv+0xa64>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T2);
    2b6c:	19000517 	ldw	r4,20(r3)
    2b70:	11000e15 	stw	r4,56(r2)
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  }

  /* (y)our internet address */
  ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
    2b74:	11000217 	ldw	r4,8(r2)
     boot file name copied in dhcp_parse_reply if not overloaded */
  ip_addr_copy(dhcp->offered_si_addr, dhcp->msg_in->siaddr);
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* subnet mask given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)) {
    2b78:	81400183 	ldbu	r5,6(r16)
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  }

  /* (y)our internet address */
  ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
    2b7c:	2180048b 	ldhu	r6,18(r4)
    2b80:	2100040b 	ldhu	r4,16(r4)
    2b84:	300c943a 	slli	r6,r6,16
    2b88:	3108b03a 	or	r4,r6,r4
    2b8c:	11000915 	stw	r4,36(r2)
     boot file name copied in dhcp_parse_reply if not overloaded */
  ip_addr_copy(dhcp->offered_si_addr, dhcp->msg_in->siaddr);
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* subnet mask given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)) {
    2b90:	28001d26 	beq	r5,zero,2c08 <dhcp_recv+0xa5c>
    /* remember given subnet mask */
    ip4_addr_set_u32(&dhcp->offered_sn_mask, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)));
    2b94:	19000617 	ldw	r4,24(r3)
    dhcp->subnet_mask_given = 1;
    2b98:	01400044 	movi	r5,1
    2b9c:	11400385 	stb	r5,14(r2)
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* subnet mask given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)) {
    /* remember given subnet mask */
    ip4_addr_set_u32(&dhcp->offered_sn_mask, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)));
    2ba0:	200e963a 	slli	r7,r4,24
    2ba4:	200cd63a 	srli	r6,r4,24
    2ba8:	200ad23a 	srli	r5,r4,8
    2bac:	213fc00c 	andi	r4,r4,65280
    2bb0:	2008923a 	slli	r4,r4,8
    2bb4:	398cb03a 	or	r6,r7,r6
    2bb8:	297fc00c 	andi	r5,r5,65280
    2bbc:	314ab03a 	or	r5,r6,r5
    2bc0:	2908b03a 	or	r4,r5,r4
    2bc4:	11000a15 	stw	r4,40(r2)
  } else {
    dhcp->subnet_mask_given = 0;
  }

  /* gateway router */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_ROUTER)) {
    2bc8:	810001c3 	ldbu	r4,7(r16)
    2bcc:	20000b26 	beq	r4,zero,2bfc <dhcp_recv+0xa50>
    ip4_addr_set_u32(&dhcp->offered_gw_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_ROUTER)));
    2bd0:	18c00717 	ldw	r3,28(r3)
    2bd4:	180c963a 	slli	r6,r3,24
    2bd8:	180ad63a 	srli	r5,r3,24
    2bdc:	1808d23a 	srli	r4,r3,8
    2be0:	18ffc00c 	andi	r3,r3,65280
    2be4:	1806923a 	slli	r3,r3,8
    2be8:	314ab03a 	or	r5,r6,r5
    2bec:	213fc00c 	andi	r4,r4,65280
    2bf0:	2908b03a 	or	r4,r5,r4
    2bf4:	20c6b03a 	or	r3,r4,r3
    2bf8:	10c00b15 	stw	r3,44(r2)
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
      dhcp_handle_ack(netif);
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
    2bfc:	9009883a 	mov	r4,r18
    2c00:	00014300 	call	1430 <dhcp_check>
    2c04:	003d8a06 	br	2230 <dhcp_recv+0x84>
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)) {
    /* remember given subnet mask */
    ip4_addr_set_u32(&dhcp->offered_sn_mask, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)));
    dhcp->subnet_mask_given = 1;
  } else {
    dhcp->subnet_mask_given = 0;
    2c08:	10000385 	stb	zero,14(r2)
    2c0c:	003fee06 	br	2bc8 <dhcp_recv+0xa1c>
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T2)) {
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T2);
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
    2c10:	11000c17 	ldw	r4,48(r2)
    2c14:	11000e15 	stw	r4,56(r2)
    2c18:	003fd606 	br	2b74 <dhcp_recv+0x9c8>
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T1)) {
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T1);
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
    2c1c:	11000c17 	ldw	r4,48(r2)
    2c20:	2008d07a 	srli	r4,r4,1
    2c24:	11000d15 	stw	r4,52(r2)
    2c28:	003fce06 	br	2b64 <dhcp_recv+0x9b8>
    u16_t val_offset = offset + 2;
    /* len byte might be in the next pbuf */
    if (offset + 1 < q->len) {
      len = options[offset + 1];
    } else {
      len = (q->next != NULL ? ((u8_t*)q->next->payload)[0] : 0);
    2c2c:	0005883a 	mov	r2,zero
    2c30:	003de006 	br	23b4 <dhcp_recv+0x208>
    2c34:	10803fcc 	andi	r2,r2,255
    2c38:	003f0c06 	br	286c <dhcp_recv+0x6c0>
        decode_len = LWIP_MIN(len, 4 * DNS_MAX_SERVERS);
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
        decode_idx = DHCP_OPTION_IDX_DNS_SERVER;
        break;
      case(DHCP_OPTION_LEASE_TIME):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    2c3c:	010000b4 	movhi	r4,2
    2c40:	210d4b04 	addi	r4,r4,13612
    2c44:	014000b4 	movhi	r5,2
    2c48:	29522104 	addi	r5,r5,18564
    2c4c:	01816304 	movi	r6,1420
    2c50:	01c000b4 	movhi	r7,2
    2c54:	39d15a04 	addi	r7,r7,17768
    2c58:	00104380 	call	10438 <printf>
    2c5c:	003fff06 	br	2c5c <dhcp_recv+0xab0>

00002c60 <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
    2c60:	defffb04 	addi	sp,sp,-20
    2c64:	dc000115 	stw	r16,4(sp)
  struct dhcp *dhcp = netif->dhcp;
    2c68:	24000817 	ldw	r16,32(r4)
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
    2c6c:	dc400215 	stw	r17,8(sp)
    2c70:	dfc00415 	stw	ra,16(sp)
    2c74:	dc800315 	stw	r18,12(sp)
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
    2c78:	80c00303 	ldbu	r3,12(r16)
    2c7c:	00800104 	movi	r2,4
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
    2c80:	2023883a 	mov	r17,r4
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
    2c84:	18800326 	beq	r3,r2,2c94 <dhcp_rebind+0x34>
    dhcp->state = new_state;
    2c88:	80800305 	stb	r2,12(r16)
    dhcp->tries = 0;
    2c8c:	80000345 	stb	zero,13(r16)
    dhcp->request_timeout = 0;
    2c90:	8000068d 	sth	zero,26(r16)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
    2c94:	8809883a 	mov	r4,r17
    2c98:	800b883a 	mov	r5,r16
    2c9c:	018000c4 	movi	r6,3
    2ca0:	00019480 	call	1948 <dhcp_create_msg>
    2ca4:	1025883a 	mov	r18,r2
  if (result == ERR_OK) {
    2ca8:	90803fcc 	andi	r2,r18,255
    2cac:	1080201c 	xori	r2,r2,128
    2cb0:	10bfe004 	addi	r2,r2,-128
    2cb4:	10001e26 	beq	r2,zero,2d30 <dhcp_rebind+0xd0>
    dhcp_delete_msg(dhcp);
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    2cb8:	80800343 	ldbu	r2,13(r16)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    2cbc:	01000244 	movi	r4,9
    dhcp_delete_msg(dhcp);
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    2cc0:	10800044 	addi	r2,r2,1
    2cc4:	1007883a 	mov	r3,r2
    2cc8:	80800345 	stb	r2,13(r16)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    2ccc:	10803fcc 	andi	r2,r2,255
    2cd0:	20800e36 	bltu	r4,r2,2d0c <dhcp_rebind+0xac>
    2cd4:	18803fcc 	andi	r2,r3,255
    2cd8:	1080fa24 	muli	r2,r2,1000
    2cdc:	01007d04 	movi	r4,500
    2ce0:	10bfffcc 	andi	r2,r2,65535
    2ce4:	10807cc4 	addi	r2,r2,499
    2ce8:	1105283a 	div	r2,r2,r4
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    2cec:	8080068d 	sth	r2,26(r16)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
    2cf0:	9005883a 	mov	r2,r18
    2cf4:	dfc00417 	ldw	ra,16(sp)
    2cf8:	dc800317 	ldw	r18,12(sp)
    2cfc:	dc400217 	ldw	r17,8(sp)
    2d00:	dc000117 	ldw	r16,4(sp)
    2d04:	dec00504 	addi	sp,sp,20
    2d08:	f800283a 	ret
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    2d0c:	00800504 	movi	r2,20
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    2d10:	8080068d 	sth	r2,26(r16)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
    2d14:	9005883a 	mov	r2,r18
    2d18:	dfc00417 	ldw	ra,16(sp)
    2d1c:	dc800317 	ldw	r18,12(sp)
    2d20:	dc400217 	ldw	r17,8(sp)
    2d24:	dc000117 	ldw	r16,4(sp)
    2d28:	dec00504 	addi	sp,sp,20
    2d2c:	f800283a 	ret
  dhcp_set_state(dhcp, DHCP_REBINDING);

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
  if (result == ERR_OK) {
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    2d30:	01800084 	movi	r6,2
    2d34:	8009883a 	mov	r4,r16
    2d38:	01400e44 	movi	r5,57
    2d3c:	00016740 	call	1674 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    2d40:	8940090b 	ldhu	r5,36(r17)
    2d44:	8009883a 	mov	r4,r16
    2d48:	00018280 	call	1828 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
    2d4c:	8009883a 	mov	r4,r16
    2d50:	00017480 	call	1748 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    2d54:	8140060b 	ldhu	r5,24(r16)
    2d58:	81000417 	ldw	r4,16(r16)
    2d5c:	29403c04 	addi	r5,r5,240
    2d60:	297fffcc 	andi	r5,r5,65535
    2d64:	00069140 	call	6914 <pbuf_realloc>

    /* broadcast to server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    2d68:	81000117 	ldw	r4,4(r16)
    2d6c:	81400417 	ldw	r5,16(r16)
    2d70:	018000f4 	movhi	r6,3
    2d74:	31a5ff04 	addi	r6,r6,-26628
    2d78:	dc400015 	stw	r17,0(sp)
    2d7c:	01c010c4 	movi	r7,67
    2d80:	000d4cc0 	call	d4cc <udp_sendto_if>
    dhcp_delete_msg(dhcp);
    2d84:	8009883a 	mov	r4,r16
    2d88:	0001c340 	call	1c34 <dhcp_delete_msg>
    2d8c:	003fca06 	br	2cb8 <dhcp_rebind+0x58>

00002d90 <dhcp_set_struct>:
 * @param netif the netif for which to set the struct dhcp
 * @param dhcp (uninitialised) dhcp struct allocated by the application
 */
void
dhcp_set_struct(struct netif *netif, struct dhcp *dhcp)
{
    2d90:	defffd04 	addi	sp,sp,-12
    2d94:	dc400115 	stw	r17,4(sp)
    2d98:	dc000015 	stw	r16,0(sp)
    2d9c:	dfc00215 	stw	ra,8(sp)
    2da0:	2021883a 	mov	r16,r4
    2da4:	2823883a 	mov	r17,r5
  LWIP_ASSERT("netif != NULL", netif != NULL);
    2da8:	20001f26 	beq	r4,zero,2e28 <dhcp_set_struct+0x98>
  LWIP_ASSERT("dhcp != NULL", dhcp != NULL);
    2dac:	28001526 	beq	r5,zero,2e04 <dhcp_set_struct+0x74>
  LWIP_ASSERT("netif already has a struct dhcp set", netif->dhcp == NULL);
    2db0:	20800817 	ldw	r2,32(r4)
    2db4:	10000926 	beq	r2,zero,2ddc <dhcp_set_struct+0x4c>
    2db8:	010000b4 	movhi	r4,2
    2dbc:	210d4b04 	addi	r4,r4,13612
    2dc0:	014000b4 	movhi	r5,2
    2dc4:	29524804 	addi	r5,r5,18720
    2dc8:	018093c4 	movi	r6,591
    2dcc:	01c000b4 	movhi	r7,2
    2dd0:	39d15a04 	addi	r7,r7,17768
    2dd4:	00104380 	call	10438 <printf>
    2dd8:	003fff06 	br	2dd8 <dhcp_set_struct+0x48>

  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
    2ddc:	2809883a 	mov	r4,r5
    2de0:	01800f04 	movi	r6,60
    2de4:	000b883a 	mov	r5,zero
    2de8:	00103300 	call	10330 <memset>
  /* dhcp_set_state(&dhcp, DHCP_OFF); */
  netif->dhcp = dhcp;
    2dec:	84400815 	stw	r17,32(r16)
}
    2df0:	dfc00217 	ldw	ra,8(sp)
    2df4:	dc400117 	ldw	r17,4(sp)
    2df8:	dc000017 	ldw	r16,0(sp)
    2dfc:	dec00304 	addi	sp,sp,12
    2e00:	f800283a 	ret
 */
void
dhcp_set_struct(struct netif *netif, struct dhcp *dhcp)
{
  LWIP_ASSERT("netif != NULL", netif != NULL);
  LWIP_ASSERT("dhcp != NULL", dhcp != NULL);
    2e04:	010000b4 	movhi	r4,2
    2e08:	210d4b04 	addi	r4,r4,13612
    2e0c:	014000b4 	movhi	r5,2
    2e10:	29524404 	addi	r5,r5,18704
    2e14:	01809384 	movi	r6,590
    2e18:	01c000b4 	movhi	r7,2
    2e1c:	39d15a04 	addi	r7,r7,17768
    2e20:	00104380 	call	10438 <printf>
    2e24:	003fff06 	br	2e24 <dhcp_set_struct+0x94>
 * @param dhcp (uninitialised) dhcp struct allocated by the application
 */
void
dhcp_set_struct(struct netif *netif, struct dhcp *dhcp)
{
  LWIP_ASSERT("netif != NULL", netif != NULL);
    2e28:	010000b4 	movhi	r4,2
    2e2c:	210d4b04 	addi	r4,r4,13612
    2e30:	014000b4 	movhi	r5,2
    2e34:	294d7404 	addi	r5,r5,13776
    2e38:	01809344 	movi	r6,589
    2e3c:	01c000b4 	movhi	r7,2
    2e40:	39d15a04 	addi	r7,r7,17768
    2e44:	00104380 	call	10438 <printf>
    2e48:	003fff06 	br	2e48 <dhcp_set_struct+0xb8>

00002e4c <dhcp_cleanup>:
 *            struct dhcp since the memory is passed back to the heap.
 *
 * @param netif the netif from which to remove the struct dhcp
 */
void dhcp_cleanup(struct netif *netif)
{
    2e4c:	defffe04 	addi	sp,sp,-8
    2e50:	dc000015 	stw	r16,0(sp)
    2e54:	dfc00115 	stw	ra,4(sp)
    2e58:	2021883a 	mov	r16,r4
  LWIP_ASSERT("netif != NULL", netif != NULL);
    2e5c:	20000826 	beq	r4,zero,2e80 <dhcp_cleanup+0x34>

  if (netif->dhcp != NULL) {
    2e60:	21000817 	ldw	r4,32(r4)
    2e64:	20000226 	beq	r4,zero,2e70 <dhcp_cleanup+0x24>
    mem_free(netif->dhcp);
    2e68:	0005a100 	call	5a10 <mem_free>
    netif->dhcp = NULL;
    2e6c:	80000815 	stw	zero,32(r16)
  }
}
    2e70:	dfc00117 	ldw	ra,4(sp)
    2e74:	dc000017 	ldw	r16,0(sp)
    2e78:	dec00204 	addi	sp,sp,8
    2e7c:	f800283a 	ret
 *
 * @param netif the netif from which to remove the struct dhcp
 */
void dhcp_cleanup(struct netif *netif)
{
  LWIP_ASSERT("netif != NULL", netif != NULL);
    2e80:	010000b4 	movhi	r4,2
    2e84:	210d4b04 	addi	r4,r4,13612
    2e88:	014000b4 	movhi	r5,2
    2e8c:	294d7404 	addi	r5,r5,13776
    2e90:	01809804 	movi	r6,608
    2e94:	01c000b4 	movhi	r7,2
    2e98:	39d15a04 	addi	r7,r7,17768
    2e9c:	00104380 	call	10438 <printf>
    2ea0:	003fff06 	br	2ea0 <dhcp_cleanup+0x54>

00002ea4 <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
    2ea4:	deffed04 	addi	sp,sp,-76
    2ea8:	dc401115 	stw	r17,68(sp)
    2eac:	dfc01215 	stw	ra,72(sp)
    2eb0:	dc001015 	stw	r16,64(sp)
    2eb4:	2023883a 	mov	r17,r4
  struct dhcp dhcp;
  err_t result = ERR_OK;
  struct udp_pcb *pcb;

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
    2eb8:	20003e26 	beq	r4,zero,2fb4 <dhcp_inform+0x110>

  memset(&dhcp, 0, sizeof(struct dhcp));
    2ebc:	d9000104 	addi	r4,sp,4
    2ec0:	000b883a 	mov	r5,zero
    2ec4:	01800f04 	movi	r6,60
    2ec8:	00103300 	call	10330 <memset>
  dhcp_set_state(&dhcp, DHCP_INFORM);

  if ((netif->dhcp != NULL) && (netif->dhcp->pcb != NULL)) {
    2ecc:	88800817 	ldw	r2,32(r17)
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
    dhcp->state = new_state;
    2ed0:	00c00204 	movi	r3,8
    2ed4:	d8c00405 	stb	r3,16(sp)
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);

  memset(&dhcp, 0, sizeof(struct dhcp));
  dhcp_set_state(&dhcp, DHCP_INFORM);

  if ((netif->dhcp != NULL) && (netif->dhcp->pcb != NULL)) {
    2ed8:	10002926 	beq	r2,zero,2f80 <dhcp_inform+0xdc>
    2edc:	14000117 	ldw	r16,4(r2)
    2ee0:	80002726 	beq	r16,zero,2f80 <dhcp_inform+0xdc>
    ip_set_option(dhcp.pcb, SOF_BROADCAST);
    udp_bind(dhcp.pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  }
  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, &dhcp, DHCP_INFORM);
    2ee4:	8809883a 	mov	r4,r17
    2ee8:	d9400104 	addi	r5,sp,4
    2eec:	01800204 	movi	r6,8
    2ef0:	00019480 	call	1948 <dhcp_create_msg>
  if (result == ERR_OK) {
    2ef4:	10803fcc 	andi	r2,r2,255
    2ef8:	1080201c 	xori	r2,r2,128
    2efc:	10bfe004 	addi	r2,r2,-128
    2f00:	1000171e 	bne	r2,zero,2f60 <dhcp_inform+0xbc>
    dhcp_option(&dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    2f04:	01800084 	movi	r6,2
    2f08:	01400e44 	movi	r5,57
    2f0c:	d9000104 	addi	r4,sp,4
    2f10:	00016740 	call	1674 <dhcp_option>
    dhcp_option_short(&dhcp, DHCP_MAX_MSG_LEN(netif));
    2f14:	8940090b 	ldhu	r5,36(r17)
    2f18:	d9000104 	addi	r4,sp,4
    2f1c:	00018280 	call	1828 <dhcp_option_short>

    dhcp_option_trailer(&dhcp);
    2f20:	d9000104 	addi	r4,sp,4
    2f24:	00017480 	call	1748 <dhcp_option_trailer>

    pbuf_realloc(dhcp.p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp.options_out_len);
    2f28:	d940070b 	ldhu	r5,28(sp)
    2f2c:	d9000517 	ldw	r4,20(sp)
    2f30:	29403c04 	addi	r5,r5,240
    2f34:	297fffcc 	andi	r5,r5,65535
    2f38:	00069140 	call	6914 <pbuf_realloc>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(pcb, dhcp.p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    2f3c:	d9400517 	ldw	r5,20(sp)
    2f40:	8009883a 	mov	r4,r16
    2f44:	dc400015 	stw	r17,0(sp)
    2f48:	018000f4 	movhi	r6,3
    2f4c:	31a5ff04 	addi	r6,r6,-26628
    2f50:	01c010c4 	movi	r7,67
    2f54:	000d4cc0 	call	d4cc <udp_sendto_if>
    dhcp_delete_msg(&dhcp);
    2f58:	d9000104 	addi	r4,sp,4
    2f5c:	0001c340 	call	1c34 <dhcp_delete_msg>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp.pcb != NULL) {
    2f60:	d9000217 	ldw	r4,8(sp)
    2f64:	20000126 	beq	r4,zero,2f6c <dhcp_inform+0xc8>
    /* otherwise, the existing pcb was used */
    udp_remove(dhcp.pcb);
    2f68:	000d8480 	call	d848 <udp_remove>
  }
}
    2f6c:	dfc01217 	ldw	ra,72(sp)
    2f70:	dc401117 	ldw	r17,68(sp)
    2f74:	dc001017 	ldw	r16,64(sp)
    2f78:	dec01304 	addi	sp,sp,76
    2f7c:	f800283a 	ret

  if ((netif->dhcp != NULL) && (netif->dhcp->pcb != NULL)) {
    /* re-use existing pcb */
    pcb = netif->dhcp->pcb;
  } else {
    pcb = udp_new();
    2f80:	000d89c0 	call	d89c <udp_new>
    2f84:	1021883a 	mov	r16,r2
    if (pcb == NULL) {
    2f88:	103ff826 	beq	r2,zero,2f6c <dhcp_inform+0xc8>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform(): could not obtain pcb"));
      return;
    }
    dhcp.pcb = pcb;
    ip_set_option(dhcp.pcb, SOF_BROADCAST);
    2f8c:	10800203 	ldbu	r2,8(r2)
    udp_bind(dhcp.pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
    2f90:	8009883a 	mov	r4,r16
    2f94:	014000f4 	movhi	r5,3
    2f98:	29660004 	addi	r5,r5,-26624
    if (pcb == NULL) {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform(): could not obtain pcb"));
      return;
    }
    dhcp.pcb = pcb;
    ip_set_option(dhcp.pcb, SOF_BROADCAST);
    2f9c:	10800814 	ori	r2,r2,32
    2fa0:	80800205 	stb	r2,8(r16)
    udp_bind(dhcp.pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
    2fa4:	01801104 	movi	r6,68
    pcb = udp_new();
    if (pcb == NULL) {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform(): could not obtain pcb"));
      return;
    }
    dhcp.pcb = pcb;
    2fa8:	dc000215 	stw	r16,8(sp)
    ip_set_option(dhcp.pcb, SOF_BROADCAST);
    udp_bind(dhcp.pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
    2fac:	000d3680 	call	d368 <udp_bind>
    2fb0:	003fcc06 	br	2ee4 <dhcp_inform+0x40>
{
  struct dhcp dhcp;
  err_t result = ERR_OK;
  struct udp_pcb *pcb;

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
    2fb4:	010000b4 	movhi	r4,2
    2fb8:	210d4b04 	addi	r4,r4,13612
    2fbc:	014000b4 	movhi	r5,2
    2fc0:	294d7404 	addi	r5,r5,13776
    2fc4:	0180b384 	movi	r6,718
    2fc8:	01c000b4 	movhi	r7,2
    2fcc:	39d15a04 	addi	r7,r7,17768
    2fd0:	00104380 	call	10438 <printf>
    2fd4:	003fff06 	br	2fd4 <dhcp_inform+0x130>

00002fd8 <dhcp_network_changed>:
 * This enters the REBOOTING state to verify that the currently bound
 * address is still valid.
 */
void
dhcp_network_changed(struct netif *netif)
{
    2fd8:	defffd04 	addi	sp,sp,-12
    2fdc:	dc000015 	stw	r16,0(sp)
  struct dhcp *dhcp = netif->dhcp;
    2fe0:	24000817 	ldw	r16,32(r4)
 * This enters the REBOOTING state to verify that the currently bound
 * address is still valid.
 */
void
dhcp_network_changed(struct netif *netif)
{
    2fe4:	dc400115 	stw	r17,4(sp)
    2fe8:	dfc00215 	stw	ra,8(sp)
    2fec:	2023883a 	mov	r17,r4
  struct dhcp *dhcp = netif->dhcp;
  if (!dhcp)
    2ff0:	80000f26 	beq	r16,zero,3030 <dhcp_network_changed+0x58>
    return;
  switch (dhcp->state) {
    2ff4:	80800303 	ldbu	r2,12(r16)
    2ff8:	00c00144 	movi	r3,5
    2ffc:	1880092e 	bgeu	r3,r2,3024 <dhcp_network_changed+0x4c>
    3000:	00c00284 	movi	r3,10
    3004:	10c00f26 	beq	r2,r3,3044 <dhcp_network_changed+0x6c>
    if(dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_ON) {
      autoip_stop(netif);
      dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
    }
#endif /* LWIP_DHCP_AUTOIP_COOP */
    dhcp_discover(netif);
    3008:	8809883a 	mov	r4,r17
    break;
  case DHCP_OFF:
    /* stay off */
    break;
  default:
    dhcp->tries = 0;
    300c:	80000345 	stb	zero,13(r16)
    }
#endif /* LWIP_DHCP_AUTOIP_COOP */
    dhcp_discover(netif);
    break;
  }
}
    3010:	dfc00217 	ldw	ra,8(sp)
    3014:	dc400117 	ldw	r17,4(sp)
    3018:	dc000017 	ldw	r16,0(sp)
    301c:	dec00304 	addi	sp,sp,12
    if(dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_ON) {
      autoip_stop(netif);
      dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
    }
#endif /* LWIP_DHCP_AUTOIP_COOP */
    dhcp_discover(netif);
    3020:	0001e501 	jmpi	1e50 <dhcp_discover>
dhcp_network_changed(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  if (!dhcp)
    return;
  switch (dhcp->state) {
    3024:	00c000c4 	movi	r3,3
    3028:	10c0062e 	bgeu	r2,r3,3044 <dhcp_network_changed+0x6c>
    302c:	103ff61e 	bne	r2,zero,3008 <dhcp_network_changed+0x30>
    }
#endif /* LWIP_DHCP_AUTOIP_COOP */
    dhcp_discover(netif);
    break;
  }
}
    3030:	dfc00217 	ldw	ra,8(sp)
    3034:	dc400117 	ldw	r17,4(sp)
    3038:	dc000017 	ldw	r16,0(sp)
    303c:	dec00304 	addi	sp,sp,12
    3040:	f800283a 	ret
  switch (dhcp->state) {
  case DHCP_REBINDING:
  case DHCP_RENEWING:
  case DHCP_BOUND:
  case DHCP_REBOOTING:
    netif_set_down(netif);
    3044:	8809883a 	mov	r4,r17
    3048:	00065040 	call	6504 <netif_set_down>
    dhcp->tries = 0;
    dhcp_reboot(netif);
    304c:	8809883a 	mov	r4,r17
  case DHCP_REBINDING:
  case DHCP_RENEWING:
  case DHCP_BOUND:
  case DHCP_REBOOTING:
    netif_set_down(netif);
    dhcp->tries = 0;
    3050:	80000345 	stb	zero,13(r16)
    }
#endif /* LWIP_DHCP_AUTOIP_COOP */
    dhcp_discover(netif);
    break;
  }
}
    3054:	dfc00217 	ldw	ra,8(sp)
    3058:	dc400117 	ldw	r17,4(sp)
    305c:	dc000017 	ldw	r16,0(sp)
    3060:	dec00304 	addi	sp,sp,12
  case DHCP_RENEWING:
  case DHCP_BOUND:
  case DHCP_REBOOTING:
    netif_set_down(netif);
    dhcp->tries = 0;
    dhcp_reboot(netif);
    3064:	0001ce01 	jmpi	1ce0 <dhcp_reboot>

00003068 <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, ip_addr_t *addr)
{
    3068:	defffc04 	addi	sp,sp,-16
    306c:	dc400215 	stw	r17,8(sp)
    3070:	dfc00315 	stw	ra,12(sp)
    3074:	dc000115 	stw	r16,4(sp)
    3078:	2023883a 	mov	r17,r4
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
    307c:	20002226 	beq	r4,zero,3108 <dhcp_arp_reply+0xa0>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
    3080:	24000817 	ldw	r16,32(r4)
    3084:	80000326 	beq	r16,zero,3094 <dhcp_arp_reply+0x2c>
    3088:	80c00303 	ldbu	r3,12(r16)
    308c:	00800204 	movi	r2,8
    3090:	18800526 	beq	r3,r2,30a8 <dhcp_arp_reply+0x40>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
        ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
    }
  }
}
    3094:	dfc00317 	ldw	ra,12(sp)
    3098:	dc400217 	ldw	r17,8(sp)
    309c:	dc000117 	ldw	r16,4(sp)
    30a0:	dec00404 	addi	sp,sp,16
    30a4:	f800283a 	ret
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n",
      ip4_addr_get_u32(addr)));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
    30a8:	28c00017 	ldw	r3,0(r5)
    30ac:	80800917 	ldw	r2,36(r16)
    30b0:	18bff81e 	bne	r3,r2,3094 <dhcp_arp_reply+0x2c>
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
    dhcp->state = new_state;
    30b4:	00800304 	movi	r2,12
    30b8:	80800305 	stb	r2,12(r16)
    dhcp->tries = 0;
    30bc:	80000345 	stb	zero,13(r16)
    dhcp->request_timeout = 0;
    30c0:	8000068d 	sth	zero,26(r16)
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_DECLINE);
    30c4:	800b883a 	mov	r5,r16
    30c8:	01800104 	movi	r6,4
    30cc:	00019480 	call	1948 <dhcp_create_msg>
  if (result == ERR_OK) {
    30d0:	10803fcc 	andi	r2,r2,255
    30d4:	1080201c 	xori	r2,r2,128
    30d8:	10bfe004 	addi	r2,r2,-128
    30dc:	10001326 	beq	r2,zero,312c <dhcp_arp_reply+0xc4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    30e0:	80800343 	ldbu	r2,13(r16)
  msecs = 10*1000;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    30e4:	00c00504 	movi	r3,20
    30e8:	80c0068d 	sth	r3,26(r16)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    30ec:	10800044 	addi	r2,r2,1
    30f0:	80800345 	stb	r2,13(r16)
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
        ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
    }
  }
}
    30f4:	dfc00317 	ldw	ra,12(sp)
    30f8:	dc400217 	ldw	r17,8(sp)
    30fc:	dc000117 	ldw	r16,4(sp)
    3100:	dec00404 	addi	sp,sp,16
    3104:	f800283a 	ret
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, ip_addr_t *addr)
{
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
    3108:	010000b4 	movhi	r4,2
    310c:	210d4b04 	addi	r4,r4,13612
    3110:	014000b4 	movhi	r5,2
    3114:	294d7404 	addi	r5,r5,13776
    3118:	0180c944 	movi	r6,805
    311c:	01c000b4 	movhi	r7,2
    3120:	39d15a04 	addi	r7,r7,17768
    3124:	00104380 	call	10438 <printf>
    3128:	003fff06 	br	3128 <dhcp_arp_reply+0xc0>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_DECLINE);
  if (result == ERR_OK) {
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
    312c:	8009883a 	mov	r4,r16
    3130:	01800104 	movi	r6,4
    3134:	01400c84 	movi	r5,50
    3138:	00016740 	call	1674 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
    313c:	80800917 	ldw	r2,36(r16)
    3140:	8009883a 	mov	r4,r16
    3144:	100c963a 	slli	r6,r2,24
    3148:	100ad63a 	srli	r5,r2,24
    314c:	1006d23a 	srli	r3,r2,8
    3150:	10bfc00c 	andi	r2,r2,65280
    3154:	1004923a 	slli	r2,r2,8
    3158:	18ffc00c 	andi	r3,r3,65280
    315c:	314ab03a 	or	r5,r6,r5
    3160:	28cab03a 	or	r5,r5,r3
    3164:	288ab03a 	or	r5,r5,r2
    3168:	00018a00 	call	18a0 <dhcp_option_long>

    dhcp_option_trailer(dhcp);
    316c:	8009883a 	mov	r4,r16
    3170:	00017480 	call	1748 <dhcp_option_trailer>
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    3174:	8140060b 	ldhu	r5,24(r16)
    3178:	81000417 	ldw	r4,16(r16)
    317c:	29403c04 	addi	r5,r5,240
    3180:	297fffcc 	andi	r5,r5,65535
    3184:	00069140 	call	6914 <pbuf_realloc>

    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
    3188:	81000117 	ldw	r4,4(r16)
    318c:	81400417 	ldw	r5,16(r16)
    3190:	018000f4 	movhi	r6,3
    3194:	31a5ff04 	addi	r6,r6,-26628
    3198:	dc400015 	stw	r17,0(sp)
    319c:	01c010c4 	movi	r7,67
    31a0:	000d4cc0 	call	d4cc <udp_sendto_if>
    dhcp_delete_msg(dhcp);
    31a4:	8009883a 	mov	r4,r16
    31a8:	0001c340 	call	1c34 <dhcp_delete_msg>
    31ac:	003fcc06 	br	30e0 <dhcp_arp_reply+0x78>

000031b0 <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
    31b0:	defffb04 	addi	sp,sp,-20
    31b4:	dc000115 	stw	r16,4(sp)
  struct dhcp *dhcp = netif->dhcp;
    31b8:	24000817 	ldw	r16,32(r4)
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
    31bc:	dc400215 	stw	r17,8(sp)
    31c0:	dfc00415 	stw	ra,16(sp)
    31c4:	dc800315 	stw	r18,12(sp)
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
    31c8:	80c00303 	ldbu	r3,12(r16)
    31cc:	00800144 	movi	r2,5
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
    31d0:	2023883a 	mov	r17,r4
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
    31d4:	18800326 	beq	r3,r2,31e4 <dhcp_renew+0x34>
    dhcp->state = new_state;
    31d8:	80800305 	stb	r2,12(r16)
    dhcp->tries = 0;
    31dc:	80000345 	stb	zero,13(r16)
    dhcp->request_timeout = 0;
    31e0:	8000068d 	sth	zero,26(r16)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
    31e4:	8809883a 	mov	r4,r17
    31e8:	800b883a 	mov	r5,r16
    31ec:	018000c4 	movi	r6,3
    31f0:	00019480 	call	1948 <dhcp_create_msg>
    31f4:	1025883a 	mov	r18,r2
  if (result == ERR_OK) {
    31f8:	90803fcc 	andi	r2,r18,255
    31fc:	1080201c 	xori	r2,r2,128
    3200:	10bfe004 	addi	r2,r2,-128
    3204:	10001e26 	beq	r2,zero,3280 <dhcp_renew+0xd0>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    3208:	80800343 	ldbu	r2,13(r16)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
    320c:	01000244 	movi	r4,9

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    3210:	10800044 	addi	r2,r2,1
    3214:	1007883a 	mov	r3,r2
    3218:	80800345 	stb	r2,13(r16)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
    321c:	10803fcc 	andi	r2,r2,255
    3220:	20800e36 	bltu	r4,r2,325c <dhcp_renew+0xac>
    3224:	18803fcc 	andi	r2,r3,255
    3228:	1081f424 	muli	r2,r2,2000
    322c:	01007d04 	movi	r4,500
    3230:	10bfffcc 	andi	r2,r2,65535
    3234:	10807cc4 	addi	r2,r2,499
    3238:	1105283a 	div	r2,r2,r4
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    323c:	8080068d 	sth	r2,26(r16)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
    3240:	9005883a 	mov	r2,r18
    3244:	dfc00417 	ldw	ra,16(sp)
    3248:	dc800317 	ldw	r18,12(sp)
    324c:	dc400217 	ldw	r17,8(sp)
    3250:	dc000117 	ldw	r16,4(sp)
    3254:	dec00504 	addi	sp,sp,20
    3258:	f800283a 	ret
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
    325c:	00800a04 	movi	r2,40
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    3260:	8080068d 	sth	r2,26(r16)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
    3264:	9005883a 	mov	r2,r18
    3268:	dfc00417 	ldw	ra,16(sp)
    326c:	dc800317 	ldw	r18,12(sp)
    3270:	dc400217 	ldw	r17,8(sp)
    3274:	dc000117 	ldw	r16,4(sp)
    3278:	dec00504 	addi	sp,sp,20
    327c:	f800283a 	ret
  dhcp_set_state(dhcp, DHCP_RENEWING);

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
  if (result == ERR_OK) {
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
    3280:	01800084 	movi	r6,2
    3284:	8009883a 	mov	r4,r16
    3288:	01400e44 	movi	r5,57
    328c:	00016740 	call	1674 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
    3290:	8940090b 	ldhu	r5,36(r17)
    3294:	8009883a 	mov	r4,r16
    3298:	00018280 	call	1828 <dhcp_option_short>
#if LWIP_NETIF_HOSTNAME
    dhcp_option_hostname(dhcp, netif);
#endif /* LWIP_NETIF_HOSTNAME */

    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
    329c:	8009883a 	mov	r4,r16
    32a0:	00017480 	call	1748 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    32a4:	8140060b 	ldhu	r5,24(r16)
    32a8:	81000417 	ldw	r4,16(r16)
    32ac:	29403c04 	addi	r5,r5,240
    32b0:	297fffcc 	andi	r5,r5,65535
    32b4:	00069140 	call	6914 <pbuf_realloc>

    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
    32b8:	81000117 	ldw	r4,4(r16)
    32bc:	81400417 	ldw	r5,16(r16)
    32c0:	81800804 	addi	r6,r16,32
    32c4:	dc400015 	stw	r17,0(sp)
    32c8:	01c010c4 	movi	r7,67
    32cc:	000d4cc0 	call	d4cc <udp_sendto_if>
    dhcp_delete_msg(dhcp);
    32d0:	8009883a 	mov	r4,r16
    32d4:	0001c340 	call	1c34 <dhcp_delete_msg>
    32d8:	003fcb06 	br	3208 <dhcp_renew+0x58>

000032dc <dhcp_coarse_tmr>:
/**
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 */
void
dhcp_coarse_tmr()
{
    32dc:	defffb04 	addi	sp,sp,-20
  struct netif *netif = netif_list;
    32e0:	008000f4 	movhi	r2,3
    32e4:	10aeb404 	addi	r2,r2,-17712
/**
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 */
void
dhcp_coarse_tmr()
{
    32e8:	dc000015 	stw	r16,0(sp)
  struct netif *netif = netif_list;
    32ec:	14000017 	ldw	r16,0(r2)
/**
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 */
void
dhcp_coarse_tmr()
{
    32f0:	dfc00415 	stw	ra,16(sp)
    32f4:	dcc00315 	stw	r19,12(sp)
    32f8:	dc800215 	stw	r18,8(sp)
    32fc:	dc400115 	stw	r17,4(sp)
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
    3300:	80001826 	beq	r16,zero,3364 <dhcp_coarse_tmr+0x88>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
    3304:	04400044 	movi	r17,1
    3308:	04800144 	movi	r18,5
    330c:	04c00284 	movi	r19,10
    3310:	00000606 	br	332c <dhcp_coarse_tmr+0x50>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
    3314:	10c0070b 	ldhu	r3,28(r2)
    3318:	193fffc4 	addi	r4,r3,-1
    331c:	1100070d 	sth	r4,28(r2)
    3320:	1c401726 	beq	r3,r17,3380 <dhcp_coarse_tmr+0xa4>
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
      }
    }
    /* proceed to next netif */
    netif = netif->next;
    3324:	84000017 	ldw	r16,0(r16)
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
    3328:	80000e26 	beq	r16,zero,3364 <dhcp_coarse_tmr+0x88>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
    332c:	80800817 	ldw	r2,32(r16)
    3330:	103ffc26 	beq	r2,zero,3324 <dhcp_coarse_tmr+0x48>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
    3334:	10c0078b 	ldhu	r3,30(r2)
    3338:	193fffc4 	addi	r4,r3,-1
    333c:	1100078d 	sth	r4,30(r2)
    3340:	1c7ff41e 	bne	r3,r17,3314 <dhcp_coarse_tmr+0x38>
    3344:	10800303 	ldbu	r2,12(r2)
    3348:	14800226 	beq	r2,r18,3354 <dhcp_coarse_tmr+0x78>
    334c:	14c00126 	beq	r2,r19,3354 <dhcp_coarse_tmr+0x78>
    3350:	147ff41e 	bne	r2,r17,3324 <dhcp_coarse_tmr+0x48>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
                ("dhcp_t2_timeout(): must rebind\n"));
    /* This slightly different to RFC2131: DHCPREQUEST will be sent from state
       DHCP_REBINDING, not DHCP_BOUND */
    dhcp_rebind(netif);
    3354:	8009883a 	mov	r4,r16
    3358:	0002c600 	call	2c60 <dhcp_rebind>
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
      }
    }
    /* proceed to next netif */
    netif = netif->next;
    335c:	84000017 	ldw	r16,0(r16)
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
    3360:	803ff21e 	bne	r16,zero,332c <dhcp_coarse_tmr+0x50>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
    3364:	dfc00417 	ldw	ra,16(sp)
    3368:	dcc00317 	ldw	r19,12(sp)
    336c:	dc800217 	ldw	r18,8(sp)
    3370:	dc400117 	ldw	r17,4(sp)
    3374:	dc000017 	ldw	r16,0(sp)
    3378:	dec00504 	addi	sp,sp,20
    337c:	f800283a 	ret
    3380:	10800303 	ldbu	r2,12(r2)
    3384:	14800226 	beq	r2,r18,3390 <dhcp_coarse_tmr+0xb4>
    3388:	14c00126 	beq	r2,r19,3390 <dhcp_coarse_tmr+0xb4>
    338c:	147fe51e 	bne	r2,r17,3324 <dhcp_coarse_tmr+0x48>
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
                ("dhcp_t1_timeout(): must renew\n"));
    /* This slightly different to RFC2131: DHCPREQUEST will be sent from state
       DHCP_RENEWING, not DHCP_BOUND */
    dhcp_renew(netif);
    3390:	8009883a 	mov	r4,r16
    3394:	00031b00 	call	31b0 <dhcp_renew>
    3398:	003fe206 	br	3324 <dhcp_coarse_tmr+0x48>

0000339c <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
    339c:	defffb04 	addi	sp,sp,-20
    33a0:	dc000115 	stw	r16,4(sp)
  struct dhcp *dhcp = netif->dhcp;
    33a4:	24000817 	ldw	r16,32(r4)
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
    33a8:	dc400215 	stw	r17,8(sp)
    33ac:	dfc00415 	stw	ra,16(sp)
    33b0:	dc800315 	stw	r18,12(sp)
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
    33b4:	80800303 	ldbu	r2,12(r16)
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
    33b8:	2023883a 	mov	r17,r4
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
    33bc:	10000326 	beq	r2,zero,33cc <dhcp_release+0x30>
    dhcp->state = new_state;
    33c0:	80000305 	stb	zero,12(r16)
    dhcp->tries = 0;
    33c4:	80000345 	stb	zero,13(r16)
    dhcp->request_timeout = 0;
    33c8:	8000068d 	sth	zero,26(r16)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
  /* clean old DHCP offer */
  ip_addr_set_zero(&dhcp->server_ip_addr);
    33cc:	80000815 	stw	zero,32(r16)
  ip_addr_set_zero(&dhcp->offered_ip_addr);
    33d0:	80000915 	stw	zero,36(r16)
  ip_addr_set_zero(&dhcp->offered_sn_mask);
    33d4:	80000a15 	stw	zero,40(r16)
  ip_addr_set_zero(&dhcp->offered_gw_addr);
    33d8:	80000b15 	stw	zero,44(r16)
#if LWIP_DHCP_BOOTP_FILE
  ip_addr_set_zero(&dhcp->offered_si_addr);
#endif /* LWIP_DHCP_BOOTP_FILE */
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
    33dc:	80000e15 	stw	zero,56(r16)
    33e0:	80000d15 	stw	zero,52(r16)
    33e4:	80000c15 	stw	zero,48(r16)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_RELEASE);
    33e8:	8809883a 	mov	r4,r17
    33ec:	800b883a 	mov	r5,r16
    33f0:	018001c4 	movi	r6,7
    33f4:	00019480 	call	1948 <dhcp_create_msg>
    33f8:	1025883a 	mov	r18,r2
  if (result == ERR_OK) {
    33fc:	90803fcc 	andi	r2,r18,255
    3400:	1080201c 	xori	r2,r2,128
    3404:	10bfe004 	addi	r2,r2,-128
    3408:	10002526 	beq	r2,zero,34a0 <dhcp_release+0x104>
    dhcp_delete_msg(dhcp);
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    340c:	80800343 	ldbu	r2,13(r16)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    3410:	01000244 	movi	r4,9
    dhcp_delete_msg(dhcp);
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    3414:	10800044 	addi	r2,r2,1
    3418:	1007883a 	mov	r3,r2
    341c:	80800345 	stb	r2,13(r16)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    3420:	10803fcc 	andi	r2,r2,255
    3424:	20801c36 	bltu	r4,r2,3498 <dhcp_release+0xfc>
    3428:	18803fcc 	andi	r2,r3,255
    342c:	1080fa24 	muli	r2,r2,1000
    3430:	01007d04 	movi	r4,500
    3434:	10bfffcc 	andi	r2,r2,65535
    3438:	10807cc4 	addi	r2,r2,499
    343c:	1105283a 	div	r2,r2,r4
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    3440:	8080068d 	sth	r2,26(r16)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
    3444:	8809883a 	mov	r4,r17
    3448:	00065040 	call	6504 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
    344c:	8809883a 	mov	r4,r17
    3450:	014000f4 	movhi	r5,3
    3454:	29660004 	addi	r5,r5,-26624
    3458:	00062640 	call	6264 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
    345c:	8809883a 	mov	r4,r17
    3460:	014000f4 	movhi	r5,3
    3464:	29660004 	addi	r5,r5,-26624
    3468:	00064980 	call	6498 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
    346c:	8809883a 	mov	r4,r17
    3470:	014000f4 	movhi	r5,3
    3474:	29660004 	addi	r5,r5,-26624
    3478:	00064b40 	call	64b4 <netif_set_netmask>
  
  return result;
}
    347c:	9005883a 	mov	r2,r18
    3480:	dfc00417 	ldw	ra,16(sp)
    3484:	dc800317 	ldw	r18,12(sp)
    3488:	dc400217 	ldw	r17,8(sp)
    348c:	dc000117 	ldw	r16,4(sp)
    3490:	dec00504 	addi	sp,sp,20
    3494:	f800283a 	ret
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    3498:	00800504 	movi	r2,20
    349c:	003fe806 	br	3440 <dhcp_release+0xa4>
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_RELEASE);
  if (result == ERR_OK) {
    dhcp_option_trailer(dhcp);
    34a0:	8009883a 	mov	r4,r16
    34a4:	00017480 	call	1748 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
    34a8:	8140060b 	ldhu	r5,24(r16)
    34ac:	81000417 	ldw	r4,16(r16)
    34b0:	29403c04 	addi	r5,r5,240
    34b4:	297fffcc 	andi	r5,r5,65535
    34b8:	00069140 	call	6914 <pbuf_realloc>

    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
    34bc:	81000117 	ldw	r4,4(r16)
    34c0:	81400417 	ldw	r5,16(r16)
    34c4:	81800804 	addi	r6,r16,32
    34c8:	dc400015 	stw	r17,0(sp)
    34cc:	01c010c4 	movi	r7,67
    34d0:	000d4cc0 	call	d4cc <udp_sendto_if>
    dhcp_delete_msg(dhcp);
    34d4:	8009883a 	mov	r4,r16
    34d8:	0001c340 	call	1c34 <dhcp_delete_msg>
    34dc:	003fcb06 	br	340c <dhcp_release+0x70>

000034e0 <dhcp_fine_tmr>:
 * A DHCP server is expected to respond within a short period of time.
 * This timer checks whether an outstanding DHCP request is timed out.
 */
void
dhcp_fine_tmr()
{
    34e0:	defff904 	addi	sp,sp,-28
  struct netif *netif = netif_list;
    34e4:	008000f4 	movhi	r2,3
    34e8:	10aeb404 	addi	r2,r2,-17712
 * A DHCP server is expected to respond within a short period of time.
 * This timer checks whether an outstanding DHCP request is timed out.
 */
void
dhcp_fine_tmr()
{
    34ec:	dc000015 	stw	r16,0(sp)
  struct netif *netif = netif_list;
    34f0:	14000017 	ldw	r16,0(r2)
 * A DHCP server is expected to respond within a short period of time.
 * This timer checks whether an outstanding DHCP request is timed out.
 */
void
dhcp_fine_tmr()
{
    34f4:	dfc00615 	stw	ra,24(sp)
    34f8:	dd400515 	stw	r21,20(sp)
    34fc:	dd000415 	stw	r20,16(sp)
    3500:	dcc00315 	stw	r19,12(sp)
    3504:	dc800215 	stw	r18,8(sp)
    3508:	dc400115 	stw	r17,4(sp)
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
    350c:	80002026 	beq	r16,zero,3590 <dhcp_fine_tmr+0xb0>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
    3510:	04400044 	movi	r17,1
dhcp_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
    3514:	04800304 	movi	r18,12
    3518:	04c00184 	movi	r19,6
      dhcp_release(netif);
      dhcp_discover(netif);
    }
#if DHCP_DOES_ARP_CHECK
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
    351c:	05000204 	movi	r20,8
      dhcp_bind(netif);
    }
#endif /* DHCP_DOES_ARP_CHECK */
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
    3520:	05400144 	movi	r21,5
    3524:	00000406 	br	3538 <dhcp_fine_tmr+0x58>
  while (netif != NULL) {
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
        netif->dhcp->request_timeout--;
    3528:	18ffffc4 	addi	r3,r3,-1
    352c:	10c0068d 	sth	r3,26(r2)
        /* this client's request timeout triggered */
        dhcp_timeout(netif);
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
    3530:	84000017 	ldw	r16,0(r16)
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
    3534:	80001626 	beq	r16,zero,3590 <dhcp_fine_tmr+0xb0>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
    3538:	80800817 	ldw	r2,32(r16)
    353c:	103ffc26 	beq	r2,zero,3530 <dhcp_fine_tmr+0x50>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
    3540:	10c0068b 	ldhu	r3,26(r2)
    3544:	193fffcc 	andi	r4,r3,65535
    3548:	893ff736 	bltu	r17,r4,3528 <dhcp_fine_tmr+0x48>
        netif->dhcp->request_timeout--;
      }
      else if (netif->dhcp->request_timeout == 1) {
    354c:	247ff81e 	bne	r4,r17,3530 <dhcp_fine_tmr+0x50>
dhcp_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
    3550:	10c00303 	ldbu	r3,12(r2)
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
        netif->dhcp->request_timeout--;
      }
      else if (netif->dhcp->request_timeout == 1) {
        netif->dhcp->request_timeout--;
    3554:	1000068d 	sth	zero,26(r2)
dhcp_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
    3558:	1c801c26 	beq	r3,r18,35cc <dhcp_fine_tmr+0xec>
    355c:	1cc01b26 	beq	r3,r19,35cc <dhcp_fine_tmr+0xec>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
    3560:	1c401426 	beq	r3,r17,35b4 <dhcp_fine_tmr+0xd4>
      dhcp_release(netif);
      dhcp_discover(netif);
    }
#if DHCP_DOES_ARP_CHECK
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
    3564:	1d001c26 	beq	r3,r20,35d8 <dhcp_fine_tmr+0xf8>
      dhcp_bind(netif);
    }
#endif /* DHCP_DOES_ARP_CHECK */
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
    3568:	1d402726 	beq	r3,r21,3608 <dhcp_fine_tmr+0x128>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
    356c:	01000104 	movi	r4,4
    3570:	19001e26 	beq	r3,r4,35ec <dhcp_fine_tmr+0x10c>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
      dhcp_discover(netif);
    }
  } else if (dhcp->state == DHCP_REBOOTING) {
    3574:	010000c4 	movi	r4,3
    3578:	193fed1e 	bne	r3,r4,3530 <dhcp_fine_tmr+0x50>
    if (dhcp->tries < REBOOT_TRIES) {
    357c:	10800343 	ldbu	r2,13(r2)
      dhcp_reboot(netif);
    3580:	8009883a 	mov	r4,r16
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
      dhcp_discover(netif);
    }
  } else if (dhcp->state == DHCP_REBOOTING) {
    if (dhcp->tries < REBOOT_TRIES) {
    3584:	8880232e 	bgeu	r17,r2,3614 <dhcp_fine_tmr+0x134>
      dhcp_reboot(netif);
    } else {
      dhcp_discover(netif);
    3588:	0001e500 	call	1e50 <dhcp_discover>
    358c:	003fe806 	br	3530 <dhcp_fine_tmr+0x50>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
    3590:	dfc00617 	ldw	ra,24(sp)
    3594:	dd400517 	ldw	r21,20(sp)
    3598:	dd000417 	ldw	r20,16(sp)
    359c:	dcc00317 	ldw	r19,12(sp)
    35a0:	dc800217 	ldw	r18,8(sp)
    35a4:	dc400117 	ldw	r17,4(sp)
    35a8:	dc000017 	ldw	r16,0(sp)
    35ac:	dec00704 	addi	sp,sp,28
    35b0:	f800283a 	ret
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
    35b4:	10800343 	ldbu	r2,13(r2)
      dhcp_select(netif);
    35b8:	8009883a 	mov	r4,r16
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
    35bc:	a8800236 	bltu	r21,r2,35c8 <dhcp_fine_tmr+0xe8>
      dhcp_select(netif);
    35c0:	0001fc00 	call	1fc0 <dhcp_select>
    35c4:	003fda06 	br	3530 <dhcp_fine_tmr+0x50>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
      dhcp_rebind(netif);
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
    35c8:	000339c0 	call	339c <dhcp_release>
      dhcp_discover(netif);
    35cc:	8009883a 	mov	r4,r16
    35d0:	0001e500 	call	1e50 <dhcp_discover>
    35d4:	003fd606 	br	3530 <dhcp_fine_tmr+0x50>
    }
#if DHCP_DOES_ARP_CHECK
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
    35d8:	10800343 	ldbu	r2,13(r2)
      dhcp_check(netif);
    35dc:	8009883a 	mov	r4,r16
    }
#if DHCP_DOES_ARP_CHECK
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
    35e0:	8880072e 	bgeu	r17,r2,3600 <dhcp_fine_tmr+0x120>
      dhcp_check(netif);
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
    35e4:	00014880 	call	1488 <dhcp_bind>
    35e8:	003fd106 	br	3530 <dhcp_fine_tmr+0x50>
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
    35ec:	10800343 	ldbu	r2,13(r2)
      dhcp_rebind(netif);
    35f0:	8009883a 	mov	r4,r16
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
    35f4:	a0bff436 	bltu	r20,r2,35c8 <dhcp_fine_tmr+0xe8>
      dhcp_rebind(netif);
    35f8:	0002c600 	call	2c60 <dhcp_rebind>
    35fc:	003fcc06 	br	3530 <dhcp_fine_tmr+0x50>
#if DHCP_DOES_ARP_CHECK
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
      dhcp_check(netif);
    3600:	00014300 	call	1430 <dhcp_check>
    3604:	003fca06 	br	3530 <dhcp_fine_tmr+0x50>
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
    3608:	8009883a 	mov	r4,r16
    360c:	00031b00 	call	31b0 <dhcp_renew>
    3610:	003fc706 	br	3530 <dhcp_fine_tmr+0x50>
      dhcp_release(netif);
      dhcp_discover(netif);
    }
  } else if (dhcp->state == DHCP_REBOOTING) {
    if (dhcp->tries < REBOOT_TRIES) {
      dhcp_reboot(netif);
    3614:	0001ce00 	call	1ce0 <dhcp_reboot>
    3618:	003fc506 	br	3530 <dhcp_fine_tmr+0x50>

0000361c <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
    361c:	defffe04 	addi	sp,sp,-8
    3620:	dfc00115 	stw	ra,4(sp)
    3624:	dc000015 	stw	r16,0(sp)
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
    3628:	20001d26 	beq	r4,zero,36a0 <dhcp_stop+0x84>
  dhcp = netif->dhcp;
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
    362c:	20800b43 	ldbu	r2,45(r4)
void
dhcp_stop(struct netif *netif)
{
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  dhcp = netif->dhcp;
    3630:	24000817 	ldw	r16,32(r4)
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
    3634:	10803dcc 	andi	r2,r2,247
    3638:	20800b45 	stb	r2,45(r4)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
    363c:	80001426 	beq	r16,zero,3690 <dhcp_stop+0x74>
      autoip_stop(netif);
      dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
    }
#endif /* LWIP_DHCP_AUTOIP_COOP */

    if (dhcp->pcb != NULL) {
    3640:	81000117 	ldw	r4,4(r16)
    3644:	20000226 	beq	r4,zero,3650 <dhcp_stop+0x34>
      udp_remove(dhcp->pcb);
    3648:	000d8480 	call	d848 <udp_remove>
      dhcp->pcb = NULL;
    364c:	80000115 	stw	zero,4(r16)
    }
    LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL);
    3650:	80800217 	ldw	r2,8(r16)
    3654:	10000926 	beq	r2,zero,367c <dhcp_stop+0x60>
    3658:	010000b4 	movhi	r4,2
    365c:	210d4b04 	addi	r4,r4,13612
    3660:	014000b4 	movhi	r5,2
    3664:	29521c04 	addi	r5,r5,18544
    3668:	01813684 	movi	r6,1242
    366c:	01c000b4 	movhi	r7,2
    3670:	39d15a04 	addi	r7,r7,17768
    3674:	00104380 	call	10438 <printf>
    3678:	003fff06 	br	3678 <dhcp_stop+0x5c>
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  if (new_state != dhcp->state) {
    367c:	80800303 	ldbu	r2,12(r16)
    3680:	10000326 	beq	r2,zero,3690 <dhcp_stop+0x74>
    dhcp->state = new_state;
    3684:	80000305 	stb	zero,12(r16)
    dhcp->tries = 0;
    3688:	80000345 	stb	zero,13(r16)
    dhcp->request_timeout = 0;
    368c:	8000068d 	sth	zero,26(r16)
      dhcp->pcb = NULL;
    }
    LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL);
    dhcp_set_state(dhcp, DHCP_OFF);
  }
}
    3690:	dfc00117 	ldw	ra,4(sp)
    3694:	dc000017 	ldw	r16,0(sp)
    3698:	dec00204 	addi	sp,sp,8
    369c:	f800283a 	ret
 */
void
dhcp_stop(struct netif *netif)
{
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
    36a0:	010000b4 	movhi	r4,2
    36a4:	210d4b04 	addi	r4,r4,13612
    36a8:	014000b4 	movhi	r5,2
    36ac:	29525104 	addi	r5,r5,18756
    36b0:	018131c4 	movi	r6,1223
    36b4:	01c000b4 	movhi	r7,2
    36b8:	39d15a04 	addi	r7,r7,17768
    36bc:	00104380 	call	10438 <printf>
    36c0:	003fff06 	br	36c0 <dhcp_stop+0xa4>

000036c4 <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
    36c4:	defffd04 	addi	sp,sp,-12
    36c8:	dc400115 	stw	r17,4(sp)
    36cc:	dfc00215 	stw	ra,8(sp)
    36d0:	dc000015 	stw	r16,0(sp)
    36d4:	2023883a 	mov	r17,r4
  struct dhcp *dhcp;
  err_t result = ERR_OK;

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
    36d8:	20001926 	beq	r4,zero,3740 <dhcp_start+0x7c>
  dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
    36dc:	20800b43 	ldbu	r2,45(r4)
{
  struct dhcp *dhcp;
  err_t result = ERR_OK;

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  dhcp = netif->dhcp;
    36e0:	24000817 	ldw	r16,32(r4)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
    36e4:	10c03dcc 	andi	r3,r2,247

  /* check hwtype of the netif */
  if ((netif->flags & NETIF_FLAG_ETHARP) == 0) {
    36e8:	1080080c 	andi	r2,r2,32
  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
    36ec:	20c00b45 	stb	r3,45(r4)

  /* check hwtype of the netif */
  if ((netif->flags & NETIF_FLAG_ETHARP) == 0) {
    36f0:	10803fcc 	andi	r2,r2,255
    36f4:	10005626 	beq	r2,zero,3850 <dhcp_start+0x18c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): No ETHARP netif\n"));
    return ERR_ARG;
  }

  /* check MTU of the netif */
  if (netif->mtu < DHCP_MAX_MSG_LEN_MIN_REQUIRED) {
    36f8:	2080090b 	ldhu	r2,36(r4)
    36fc:	00c08fc4 	movi	r3,575
    3700:	1880512e 	bgeu	r3,r2,3848 <dhcp_start+0x184>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): Cannot use this netif with DHCP: MTU is too small\n"));
    return ERR_MEM;
  }

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
    3704:	80002226 	beq	r16,zero,3790 <dhcp_start+0xcc>
    netif->dhcp = dhcp;
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): allocated dhcp"));
  /* already has DHCP client attached */
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(): restarting DHCP configuration\n"));
    if (dhcp->pcb != NULL) {
    3708:	81000117 	ldw	r4,4(r16)
    370c:	20000126 	beq	r4,zero,3714 <dhcp_start+0x50>
      udp_remove(dhcp->pcb);
    3710:	000d8480 	call	d848 <udp_remove>
    }
    LWIP_ASSERT("pbuf p_out wasn't freed", dhcp->p_out == NULL);
    3714:	80800417 	ldw	r2,16(r16)
    3718:	10001226 	beq	r2,zero,3764 <dhcp_start+0xa0>
    371c:	010000b4 	movhi	r4,2
    3720:	210d4b04 	addi	r4,r4,13612
    3724:	014000b4 	movhi	r5,2
    3728:	29525804 	addi	r5,r5,18784
    372c:	0180a784 	movi	r6,670
    3730:	01c000b4 	movhi	r7,2
    3734:	39d15a04 	addi	r7,r7,17768
    3738:	00104380 	call	10438 <printf>
    373c:	003fff06 	br	373c <dhcp_start+0x78>
dhcp_start(struct netif *netif)
{
  struct dhcp *dhcp;
  err_t result = ERR_OK;

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
    3740:	010000b4 	movhi	r4,2
    3744:	210d4b04 	addi	r4,r4,13612
    3748:	014000b4 	movhi	r5,2
    374c:	294d7404 	addi	r5,r5,13776
    3750:	01809e84 	movi	r6,634
    3754:	01c000b4 	movhi	r7,2
    3758:	39d15a04 	addi	r7,r7,17768
    375c:	00104380 	call	10438 <printf>
    3760:	003fff06 	br	3760 <dhcp_start+0x9c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(): restarting DHCP configuration\n"));
    if (dhcp->pcb != NULL) {
      udp_remove(dhcp->pcb);
    }
    LWIP_ASSERT("pbuf p_out wasn't freed", dhcp->p_out == NULL);
    LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL );
    3764:	80800217 	ldw	r2,8(r16)
    3768:	10000e26 	beq	r2,zero,37a4 <dhcp_start+0xe0>
    376c:	010000b4 	movhi	r4,2
    3770:	210d4b04 	addi	r4,r4,13612
    3774:	014000b4 	movhi	r5,2
    3778:	29521c04 	addi	r5,r5,18544
    377c:	0180a7c4 	movi	r6,671
    3780:	01c000b4 	movhi	r7,2
    3784:	39d15a04 	addi	r7,r7,17768
    3788:	00104380 	call	10438 <printf>
    378c:	003fff06 	br	378c <dhcp_start+0xc8>
  }

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = (struct dhcp *)mem_malloc(sizeof(struct dhcp));
    3790:	01000f04 	movi	r4,60
    3794:	0005d480 	call	5d48 <mem_malloc>
    3798:	1021883a 	mov	r16,r2
    if (dhcp == NULL) {
    379c:	10002a26 	beq	r2,zero,3848 <dhcp_start+0x184>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
    37a0:	88800815 	stw	r2,32(r17)
    LWIP_ASSERT("pbuf p_out wasn't freed", dhcp->p_out == NULL);
    LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL );
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
    37a4:	8009883a 	mov	r4,r16
    37a8:	000b883a 	mov	r5,zero
    37ac:	01800f04 	movi	r6,60
    37b0:	00103300 	call	10330 <memset>
  /* dhcp_set_state(&dhcp, DHCP_OFF); */
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
    37b4:	000d89c0 	call	d89c <udp_new>
    37b8:	80800115 	stw	r2,4(r16)
  if (dhcp->pcb == NULL) {
    37bc:	10002226 	beq	r2,zero,3848 <dhcp_start+0x184>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    return ERR_MEM;
  }
  ip_set_option(dhcp->pcb, SOF_BROADCAST);
    37c0:	10c00203 	ldbu	r3,8(r2)
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
    37c4:	014000f4 	movhi	r5,3
    37c8:	29660004 	addi	r5,r5,-26624
    37cc:	01801104 	movi	r6,68
  dhcp->pcb = udp_new();
  if (dhcp->pcb == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    return ERR_MEM;
  }
  ip_set_option(dhcp->pcb, SOF_BROADCAST);
    37d0:	18c00814 	ori	r3,r3,32
    37d4:	10c00205 	stb	r3,8(r2)
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
    37d8:	81000117 	ldw	r4,4(r16)
    37dc:	000d3680 	call	d368 <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
    37e0:	81000117 	ldw	r4,4(r16)
    37e4:	014000f4 	movhi	r5,3
    37e8:	29660004 	addi	r5,r5,-26624
    37ec:	018010c4 	movi	r6,67
    37f0:	000d7580 	call	d758 <udp_connect>
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
    37f4:	81000117 	ldw	r4,4(r16)
    37f8:	01400034 	movhi	r5,0
    37fc:	29486b04 	addi	r5,r5,8620
    3800:	880d883a 	mov	r6,r17
    3804:	000d83c0 	call	d83c <udp_recv>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
    3808:	8809883a 	mov	r4,r17
    380c:	0001e500 	call	1e50 <dhcp_discover>
  if (result != ERR_OK) {
    3810:	10c03fcc 	andi	r3,r2,255
    3814:	18c0201c 	xori	r3,r3,128
    3818:	18ffe004 	addi	r3,r3,-128
    381c:	1800081e 	bne	r3,zero,3840 <dhcp_start+0x17c>
    /* free resources allocated above */
    dhcp_stop(netif);
    return ERR_MEM;
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
    3820:	88c00b43 	ldbu	r3,45(r17)
    3824:	18c00214 	ori	r3,r3,8
    3828:	88c00b45 	stb	r3,45(r17)
  return result;
}
    382c:	dfc00217 	ldw	ra,8(sp)
    3830:	dc400117 	ldw	r17,4(sp)
    3834:	dc000017 	ldw	r16,0(sp)
    3838:	dec00304 	addi	sp,sp,12
    383c:	f800283a 	ret
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  if (result != ERR_OK) {
    /* free resources allocated above */
    dhcp_stop(netif);
    3840:	8809883a 	mov	r4,r17
    3844:	000361c0 	call	361c <dhcp_stop>
    return ERR_MEM;
    3848:	00bfffc4 	movi	r2,-1
    384c:	003ff706 	br	382c <dhcp_start+0x168>
  netif->flags &= ~NETIF_FLAG_DHCP;

  /* check hwtype of the netif */
  if ((netif->flags & NETIF_FLAG_ETHARP) == 0) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): No ETHARP netif\n"));
    return ERR_ARG;
    3850:	00bffc84 	movi	r2,-14
    3854:	003ff506 	br	382c <dhcp_start+0x168>

00003858 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
    3858:	deffff04 	addi	sp,sp,-4
    385c:	dfc00015 	stw	ra,0(sp)
  /* Modules initialization */
  stats_init();
    3860:	0007a780 	call	7a78 <stats_init>
#if !NO_SYS
  sys_init();
#endif /* !NO_SYS */
  mem_init();
    3864:	00059c00 	call	59c0 <mem_init>
  memp_init();
    3868:	0005fc40 	call	5fc4 <memp_init>
  pbuf_init();
  netif_init();
    386c:	000620c0 	call	620c <netif_init>
#endif /* LWIP_ARP */
#if LWIP_RAW
  raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
  udp_init();
    3870:	000cfac0 	call	cfac <udp_init>
#endif /* LWIP_DNS */

#if LWIP_TIMERS
  sys_timeouts_init();
#endif /* LWIP_TIMERS */
}
    3874:	dfc00017 	ldw	ra,0(sp)
    3878:	dec00104 	addi	sp,sp,4
#endif /* LWIP_RAW */
#if LWIP_UDP
  udp_init();
#endif /* LWIP_UDP */
#if LWIP_TCP
  tcp_init();
    387c:	0007b0c1 	jmpi	7b0c <tcp_init>

00003880 <icmp_send_response>:
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
    3880:	defff504 	addi	sp,sp,-44
    3884:	dc800515 	stw	r18,20(sp)
  /* we can use the echo header here */
  struct icmp_echo_hdr *icmphdr;
  ip_addr_t iphdr_src;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
    3888:	04800044 	movi	r18,1
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
    388c:	dd800915 	stw	r22,36(sp)
    3890:	dd400815 	stw	r21,32(sp)
    3894:	dd000715 	stw	r20,28(sp)
    3898:	282d883a 	mov	r22,r5
    389c:	2029883a 	mov	r20,r4
    38a0:	302b883a 	mov	r21,r6
  /* we can use the echo header here */
  struct icmp_echo_hdr *icmphdr;
  ip_addr_t iphdr_src;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
    38a4:	9009883a 	mov	r4,r18
    38a8:	01400904 	movi	r5,36
    38ac:	000d883a 	mov	r6,zero
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
    38b0:	dc000315 	stw	r16,12(sp)
    38b4:	dfc00a15 	stw	ra,40(sp)
    38b8:	dcc00615 	stw	r19,24(sp)
    38bc:	dc400415 	stw	r17,16(sp)
  /* we can use the echo header here */
  struct icmp_echo_hdr *icmphdr;
  ip_addr_t iphdr_src;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
    38c0:	0006a880 	call	6a88 <pbuf_alloc>
    38c4:	1021883a 	mov	r16,r2
                 PBUF_RAM);
  if (q == NULL) {
    38c8:	10002f26 	beq	r2,zero,3988 <icmp_send_response+0x108>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
    38cc:	1080028b 	ldhu	r2,10(r2)
    38d0:	00c008c4 	movi	r3,35
    38d4:	18800936 	bltu	r3,r2,38fc <icmp_send_response+0x7c>
    38d8:	010000b4 	movhi	r4,2
    38dc:	210d4b04 	addi	r4,r4,13612
    38e0:	014000b4 	movhi	r5,2
    38e4:	29525e04 	addi	r5,r5,18808
    38e8:	01804cc4 	movi	r6,307
    38ec:	01c000b4 	movhi	r7,2
    38f0:	39d26904 	addi	r7,r7,18852
    38f4:	00104380 	call	10438 <printf>
    38f8:	003fff06 	br	38f8 <icmp_send_response+0x78>
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
    38fc:	84400117 	ldw	r17,4(r16)
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
             (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = (struct ip_hdr *)p->payload;
    3900:	a4c00117 	ldw	r19,4(r20)
  icmphdr->code = code;
  icmphdr->id = 0;
  icmphdr->seqno = 0;

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
    3904:	01800704 	movi	r6,28
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
  icmphdr->type = type;
    3908:	8d800005 	stb	r22,0(r17)
  icmphdr->code = code;
    390c:	8d400045 	stb	r21,1(r17)
  icmphdr->id = 0;
  icmphdr->seqno = 0;

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
    3910:	81000117 	ldw	r4,4(r16)
    3914:	a1400117 	ldw	r5,4(r20)
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
  icmphdr->type = type;
  icmphdr->code = code;
  icmphdr->id = 0;
    3918:	8800010d 	sth	zero,4(r17)
  icmphdr->seqno = 0;

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
    391c:	21000204 	addi	r4,r4,8

  icmphdr = (struct icmp_echo_hdr *)q->payload;
  icmphdr->type = type;
  icmphdr->code = code;
  icmphdr->id = 0;
  icmphdr->seqno = 0;
    3920:	8800018d 	sth	zero,6(r17)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
    3924:	00102380 	call	10238 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  icmphdr->chksum = 0;
  icmphdr->chksum = inet_chksum(icmphdr, q->len);
    3928:	8140028b 	ldhu	r5,10(r16)
    392c:	8809883a 	mov	r4,r17
  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  icmphdr->chksum = 0;
    3930:	8800008d 	sth	zero,2(r17)
  icmphdr->chksum = inet_chksum(icmphdr, q->len);
    3934:	00041840 	call	4184 <inet_chksum>
  ICMP_STATS_INC(icmp.xmit);
    3938:	00c001f4 	movhi	r3,7
    393c:	18d44804 	addi	r3,r3,20768
    3940:	1940180b 	ldhu	r5,96(r3)
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  icmphdr->chksum = 0;
  icmphdr->chksum = inet_chksum(icmphdr, q->len);
    3944:	8880008d 	sth	r2,2(r17)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_addr_copy(iphdr_src, iphdr->src);
  ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
    3948:	8009883a 	mov	r4,r16
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  icmphdr->chksum = 0;
  icmphdr->chksum = inet_chksum(icmphdr, q->len);
  ICMP_STATS_INC(icmp.xmit);
    394c:	29400044 	addi	r5,r5,1
    3950:	1940180d 	sth	r5,96(r3)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_addr_copy(iphdr_src, iphdr->src);
    3954:	98c0038b 	ldhu	r3,14(r19)
    3958:	9880030b 	ldhu	r2,12(r19)
  ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
    395c:	000b883a 	mov	r5,zero
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_addr_copy(iphdr_src, iphdr->src);
    3960:	1806943a 	slli	r3,r3,16
  ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
    3964:	d8000015 	stw	zero,0(sp)
    3968:	dc800115 	stw	r18,4(sp)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_addr_copy(iphdr_src, iphdr->src);
    396c:	1884b03a 	or	r2,r3,r2
  ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
    3970:	d9800204 	addi	r6,sp,8
    3974:	01c03fc4 	movi	r7,255
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_addr_copy(iphdr_src, iphdr->src);
    3978:	d8800215 	stw	r2,8(sp)
  ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
    397c:	00048780 	call	4878 <ip_output>
  pbuf_free(q);
    3980:	8009883a 	mov	r4,r16
    3984:	00067d80 	call	67d8 <pbuf_free>
}
    3988:	dfc00a17 	ldw	ra,40(sp)
    398c:	dd800917 	ldw	r22,36(sp)
    3990:	dd400817 	ldw	r21,32(sp)
    3994:	dd000717 	ldw	r20,28(sp)
    3998:	dcc00617 	ldw	r19,24(sp)
    399c:	dc800517 	ldw	r18,20(sp)
    39a0:	dc400417 	ldw	r17,16(sp)
    39a4:	dc000317 	ldw	r16,12(sp)
    39a8:	dec00b04 	addi	sp,sp,44
    39ac:	f800283a 	ret

000039b0 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
    39b0:	defff404 	addi	sp,sp,-48
    39b4:	dc000315 	stw	r16,12(sp)
#endif /* LWIP_DEBUG */
  struct icmp_echo_hdr *iecho;
  struct ip_hdr *iphdr;
  s16_t hlen;

  ICMP_STATS_INC(icmp.recv);
    39b8:	040001f4 	movhi	r16,7
    39bc:	84144804 	addi	r16,r16,20768
    39c0:	8080188b 	ldhu	r2,98(r16)
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
    39c4:	dc800515 	stw	r18,20(sp)

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = (struct ip_hdr *)p->payload;
    39c8:	24800117 	ldw	r18,4(r4)
#endif /* LWIP_DEBUG */
  struct icmp_echo_hdr *iecho;
  struct ip_hdr *iphdr;
  s16_t hlen;

  ICMP_STATS_INC(icmp.recv);
    39cc:	10800044 	addi	r2,r2,1
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
    39d0:	dd400815 	stw	r21,32(sp)
    39d4:	dd000715 	stw	r20,28(sp)
    39d8:	dcc00615 	stw	r19,24(sp)
    39dc:	dc400415 	stw	r17,16(sp)
    39e0:	dfc00b15 	stw	ra,44(sp)
    39e4:	ddc00a15 	stw	r23,40(sp)
    39e8:	dd800915 	stw	r22,36(sp)
#endif /* LWIP_DEBUG */
  struct icmp_echo_hdr *iecho;
  struct ip_hdr *iphdr;
  s16_t hlen;

  ICMP_STATS_INC(icmp.recv);
    39ec:	8080188d 	sth	r2,98(r16)
  snmp_inc_icmpinmsgs();


  iphdr = (struct ip_hdr *)p->payload;
  hlen = IPH_HL(iphdr) * 4;
    39f0:	90800003 	ldbu	r2,0(r18)
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
    39f4:	2829883a 	mov	r20,r5
    39f8:	2023883a 	mov	r17,r4
  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = (struct ip_hdr *)p->payload;
  hlen = IPH_HL(iphdr) * 4;
    39fc:	108003cc 	andi	r2,r2,15
    3a00:	1085883a 	add	r2,r2,r2
    3a04:	1085883a 	add	r2,r2,r2
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
    3a08:	00a7c83a 	sub	r19,zero,r2
    3a0c:	9cffffcc 	andi	r19,r19,65535
    3a10:	9ce0001c 	xori	r19,r19,32768
    3a14:	9ce00004 	addi	r19,r19,-32768
    3a18:	980b883a 	mov	r5,r19
  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = (struct ip_hdr *)p->payload;
  hlen = IPH_HL(iphdr) * 4;
    3a1c:	102b883a 	mov	r21,r2
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
    3a20:	00066980 	call	6698 <pbuf_header>
    3a24:	10803fcc 	andi	r2,r2,255
    3a28:	10001a1e 	bne	r2,zero,3a94 <icmp_input+0xe4>
    3a2c:	88c0020b 	ldhu	r3,8(r17)
    3a30:	010000c4 	movi	r4,3
    3a34:	20c0172e 	bgeu	r4,r3,3a94 <icmp_input+0xe4>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
    3a38:	88800117 	ldw	r2,4(r17)
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
    3a3c:	10800003 	ldbu	r2,0(r2)
    3a40:	10000826 	beq	r2,zero,3a64 <icmp_input+0xb4>
    3a44:	00c00204 	movi	r3,8
    3a48:	10c02226 	beq	r2,r3,3ad4 <icmp_input+0x124>
    }
    break;
  default:
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    3a4c:	80c01c0b 	ldhu	r3,112(r16)
    ICMP_STATS_INC(icmp.drop);
    3a50:	8080198b 	ldhu	r2,102(r16)
    }
    break;
  default:
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    3a54:	18c00044 	addi	r3,r3,1
    ICMP_STATS_INC(icmp.drop);
    3a58:	10800044 	addi	r2,r2,1
    }
    break;
  default:
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    3a5c:	80c01c0d 	sth	r3,112(r16)
    ICMP_STATS_INC(icmp.drop);
    3a60:	8080198d 	sth	r2,102(r16)
  }
  pbuf_free(p);
    3a64:	8809883a 	mov	r4,r17
  pbuf_free(p);
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
}
    3a68:	dfc00b17 	ldw	ra,44(sp)
    3a6c:	ddc00a17 	ldw	r23,40(sp)
    3a70:	dd800917 	ldw	r22,36(sp)
    3a74:	dd400817 	ldw	r21,32(sp)
    3a78:	dd000717 	ldw	r20,28(sp)
    3a7c:	dcc00617 	ldw	r19,24(sp)
    3a80:	dc800517 	ldw	r18,20(sp)
    3a84:	dc400417 	ldw	r17,16(sp)
    3a88:	dc000317 	ldw	r16,12(sp)
    3a8c:	dec00c04 	addi	sp,sp,48
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
    3a90:	00067d81 	jmpi	67d8 <pbuf_free>
  return;
lenerr:
  pbuf_free(p);
    3a94:	8809883a 	mov	r4,r17
    3a98:	00067d80 	call	67d8 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
    3a9c:	80801a8b 	ldhu	r2,106(r16)
    3aa0:	10800044 	addi	r2,r2,1
    3aa4:	80801a8d 	sth	r2,106(r16)
  pbuf_free(p);
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
}
    3aa8:	dfc00b17 	ldw	ra,44(sp)
    3aac:	ddc00a17 	ldw	r23,40(sp)
    3ab0:	dd800917 	ldw	r22,36(sp)
    3ab4:	dd400817 	ldw	r21,32(sp)
    3ab8:	dd000717 	ldw	r20,28(sp)
    3abc:	dcc00617 	ldw	r19,24(sp)
    3ac0:	dc800517 	ldw	r18,20(sp)
    3ac4:	dc400417 	ldw	r17,16(sp)
    3ac8:	dc000317 	ldw	r16,12(sp)
    3acc:	dec00c04 	addi	sp,sp,48
    3ad0:	f800283a 	ret
#if !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
    {
      int accepted = 1;
#if !LWIP_MULTICAST_PING
      /* multicast destination address? */
      if (ip_addr_ismulticast(&current_iphdr_dest)) {
    3ad4:	058000f4 	movhi	r22,3
    3ad8:	b5aeac04 	addi	r22,r22,-17744
    3adc:	b5c00017 	ldw	r23,0(r22)
        accepted = 0;
      }
#endif /* LWIP_MULTICAST_PING */
#if !LWIP_BROADCAST_PING
      /* broadcast destination address? */
      if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
    3ae0:	a00b883a 	mov	r5,r20
    3ae4:	b809883a 	mov	r4,r23
    3ae8:	00049440 	call	4944 <ip4_addr_isbroadcast>
    3aec:	10803fcc 	andi	r2,r2,255
    3af0:	10000526 	beq	r2,zero,3b08 <icmp_input+0x158>
      }
#endif /* LWIP_BROADCAST_PING */
      /* broadcast or multicast destination address not acceptd? */
      if (!accepted) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
        ICMP_STATS_INC(icmp.err);
    3af4:	80801d0b 	ldhu	r2,116(r16)
        pbuf_free(p);
    3af8:	8809883a 	mov	r4,r17
      }
#endif /* LWIP_BROADCAST_PING */
      /* broadcast or multicast destination address not acceptd? */
      if (!accepted) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
        ICMP_STATS_INC(icmp.err);
    3afc:	10800044 	addi	r2,r2,1
    3b00:	80801d0d 	sth	r2,116(r16)
    3b04:	003fd806 	br	3a68 <icmp_input+0xb8>
#if !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
    {
      int accepted = 1;
#if !LWIP_MULTICAST_PING
      /* multicast destination address? */
      if (ip_addr_ismulticast(&current_iphdr_dest)) {
    3b08:	bdc03c0c 	andi	r23,r23,240
      if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
        accepted = 0;
      }
#endif /* LWIP_BROADCAST_PING */
      /* broadcast or multicast destination address not acceptd? */
      if (!accepted) {
    3b0c:	00803804 	movi	r2,224
    3b10:	b8bff826 	beq	r23,r2,3af4 <icmp_input+0x144>
        return;
      }
    }
#endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
    3b14:	8880020b 	ldhu	r2,8(r17)
    3b18:	00c001c4 	movi	r3,7
    3b1c:	18bfdd2e 	bgeu	r3,r2,3a94 <icmp_input+0xe4>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
    3b20:	8809883a 	mov	r4,r17
    3b24:	00041a40 	call	41a4 <inet_chksum_pbuf>
    3b28:	10bfffcc 	andi	r2,r2,65535
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
    3b2c:	8809883a 	mov	r4,r17
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
    3b30:	1000141e 	bne	r2,zero,3b84 <icmp_input+0x1d4>
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
    }
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
    3b34:	01400884 	movi	r5,34
    3b38:	00066980 	call	6698 <pbuf_header>
    3b3c:	10803fcc 	andi	r2,r2,255
    3b40:	10001526 	beq	r2,zero,3b98 <icmp_input+0x1e8>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
    3b44:	acbfffcc 	andi	r18,r21,65535
    3b48:	8809883a 	mov	r4,r17
    3b4c:	900b883a 	mov	r5,r18
    3b50:	00066980 	call	6698 <pbuf_header>
    3b54:	10803fcc 	andi	r2,r2,255
    3b58:	902f883a 	mov	r23,r18
    3b5c:	10005726 	beq	r2,zero,3cbc <icmp_input+0x30c>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
    3b60:	010000b4 	movhi	r4,2
    3b64:	210d4b04 	addi	r4,r4,13612
    3b68:	014000b4 	movhi	r5,2
    3b6c:	29527004 	addi	r5,r5,18880
    3b70:	01802604 	movi	r6,152
    3b74:	01c000b4 	movhi	r7,2
    3b78:	39d26904 	addi	r7,r7,18852
    3b7c:	00104380 	call	10438 <printf>
    3b80:	003fff06 	br	3b80 <icmp_input+0x1d0>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
    3b84:	00067d80 	call	67d8 <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
    3b88:	80801a0b 	ldhu	r2,104(r16)
    3b8c:	10800044 	addi	r2,r2,1
    3b90:	80801a0d 	sth	r2,104(r16)
      snmp_inc_icmpinerrors();
      return;
    3b94:	003fc406 	br	3aa8 <icmp_input+0xf8>
      pbuf_free(p);
      /* we now have an identical copy of p that has room for link headers */
      p = r;
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
    3b98:	8809883a 	mov	r4,r17
    3b9c:	017ff784 	movi	r5,-34
    3ba0:	00066980 	call	6698 <pbuf_header>
    3ba4:	10803fcc 	andi	r2,r2,255
    3ba8:	10003b1e 	bne	r2,zero,3c98 <icmp_input+0x2e8>
    3bac:	adffffcc 	andi	r23,r21,65535
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = (struct icmp_echo_hdr *)p->payload;
    ip_addr_copy(iphdr->src, *ip_current_dest_addr());
    3bb0:	b100000b 	ldhu	r4,0(r22)
    }
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = (struct icmp_echo_hdr *)p->payload;
    3bb4:	88800117 	ldw	r2,4(r17)
    ip_addr_copy(iphdr->src, *ip_current_dest_addr());
    ip_addr_copy(iphdr->dest, *ip_current_src_addr());
    3bb8:	00c000f4 	movhi	r3,3
    3bbc:	18eeaa04 	addi	r3,r3,-17752
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = (struct icmp_echo_hdr *)p->payload;
    ip_addr_copy(iphdr->src, *ip_current_dest_addr());
    3bc0:	9100030d 	sth	r4,12(r18)
    3bc4:	b1000017 	ldw	r4,0(r22)
    ip_addr_copy(iphdr->dest, *ip_current_src_addr());
    ICMPH_TYPE_SET(iecho, ICMP_ER);
#if CHECKSUM_GEN_ICMP
    /* adjust the checksum */
    if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
    3bc8:	017ffd94 	movui	r5,65526
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = (struct icmp_echo_hdr *)p->payload;
    ip_addr_copy(iphdr->src, *ip_current_dest_addr());
    3bcc:	2008d43a 	srli	r4,r4,16
    3bd0:	9100038d 	sth	r4,14(r18)
    ip_addr_copy(iphdr->dest, *ip_current_src_addr());
    3bd4:	1900000b 	ldhu	r4,0(r3)
    3bd8:	9100040d 	sth	r4,16(r18)
    3bdc:	18c00017 	ldw	r3,0(r3)
    3be0:	1806d43a 	srli	r3,r3,16
    3be4:	90c0048d 	sth	r3,18(r18)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
#if CHECKSUM_GEN_ICMP
    /* adjust the checksum */
    if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
    3be8:	10c0008b 	ldhu	r3,2(r2)
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = (struct icmp_echo_hdr *)p->payload;
    ip_addr_copy(iphdr->src, *ip_current_dest_addr());
    ip_addr_copy(iphdr->dest, *ip_current_src_addr());
    ICMPH_TYPE_SET(iecho, ICMP_ER);
    3bec:	10000005 	stb	zero,0(r2)
#if CHECKSUM_GEN_ICMP
    /* adjust the checksum */
    if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
    3bf0:	193fffcc 	andi	r4,r3,65535
    3bf4:	2900252e 	bgeu	r5,r4,3c8c <icmp_input+0x2dc>
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
    3bf8:	18c00244 	addi	r3,r3,9
    3bfc:	10c0008d 	sth	r3,2(r2)
#else /* CHECKSUM_GEN_ICMP */
    iecho->chksum = 0;
#endif /* CHECKSUM_GEN_ICMP */

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
    3c00:	00bfffc4 	movi	r2,-1
    IPH_CHKSUM_SET(iphdr, 0);
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    3c04:	9009883a 	mov	r4,r18
    3c08:	01400504 	movi	r5,20
#else /* CHECKSUM_GEN_ICMP */
    iecho->chksum = 0;
#endif /* CHECKSUM_GEN_ICMP */

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
    3c0c:	90800205 	stb	r2,8(r18)
    IPH_CHKSUM_SET(iphdr, 0);
    3c10:	9000028d 	sth	zero,10(r18)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    3c14:	00041840 	call	4184 <inet_chksum>
#endif /* CHECKSUM_GEN_IP */

    ICMP_STATS_INC(icmp.xmit);
    3c18:	80c0180b 	ldhu	r3,96(r16)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
    3c1c:	8809883a 	mov	r4,r17

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
    IPH_CHKSUM_SET(iphdr, 0);
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    3c20:	9080028d 	sth	r2,10(r18)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
    3c24:	b80b883a 	mov	r5,r23
    IPH_CHKSUM_SET(iphdr, 0);
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
#endif /* CHECKSUM_GEN_IP */

    ICMP_STATS_INC(icmp.xmit);
    3c28:	18800044 	addi	r2,r3,1
    3c2c:	8080180d 	sth	r2,96(r16)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
    3c30:	00066980 	call	6698 <pbuf_header>
    3c34:	10803fcc 	andi	r2,r2,255
    3c38:	10000926 	beq	r2,zero,3c60 <icmp_input+0x2b0>
      LWIP_ASSERT("Can't move over header in packet", 0);
    3c3c:	010000b4 	movhi	r4,2
    3c40:	210d4b04 	addi	r4,r4,13612
    3c44:	014000b4 	movhi	r5,2
    3c48:	2952a204 	addi	r5,r5,19080
    3c4c:	01803684 	movi	r6,218
    3c50:	01c000b4 	movhi	r7,2
    3c54:	39d26904 	addi	r7,r7,18852
    3c58:	00104380 	call	10438 <printf>
    3c5c:	003fff06 	br	3c5c <icmp_input+0x2ac>
    } else {
      err_t ret;
      /* send an ICMP packet, src addr is the dest addr of the curren packet */
      ret = ip_output_if(p, ip_current_dest_addr(), IP_HDRINCL,
    3c60:	00800044 	movi	r2,1
    3c64:	d8000015 	stw	zero,0(sp)
    3c68:	d8800115 	stw	r2,4(sp)
    3c6c:	dd000215 	stw	r20,8(sp)
    3c70:	8809883a 	mov	r4,r17
    3c74:	014000f4 	movhi	r5,3
    3c78:	296eac04 	addi	r5,r5,-17744
    3c7c:	000d883a 	mov	r6,zero
    3c80:	01c03fc4 	movi	r7,255
    3c84:	00046140 	call	4614 <ip_output_if>
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
      }
    }
    break;
    3c88:	003f7606 	br	3a64 <icmp_input+0xb4>
#if CHECKSUM_GEN_ICMP
    /* adjust the checksum */
    if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
    } else {
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
    3c8c:	18c00204 	addi	r3,r3,8
    3c90:	10c0008d 	sth	r3,2(r2)
    3c94:	003fda06 	br	3c00 <icmp_input+0x250>
      /* we now have an identical copy of p that has room for link headers */
      p = r;
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
    3c98:	010000b4 	movhi	r4,2
    3c9c:	210d4b04 	addi	r4,r4,13612
    3ca0:	014000b4 	movhi	r5,2
    3ca4:	29529504 	addi	r5,r5,19028
    3ca8:	01802d44 	movi	r6,181
    3cac:	01c000b4 	movhi	r7,2
    3cb0:	39d26904 	addi	r7,r7,18852
    3cb4:	00104380 	call	10438 <printf>
    3cb8:	003fff06 	br	3cb8 <icmp_input+0x308>
      if (pbuf_header(p, hlen)) {
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
    3cbc:	8940020b 	ldhu	r5,8(r17)
    3cc0:	01000084 	movi	r4,2
    3cc4:	000d883a 	mov	r6,zero
    3cc8:	0006a880 	call	6a88 <pbuf_alloc>
    3ccc:	102b883a 	mov	r21,r2
      if (r == NULL) {
    3cd0:	10002f26 	beq	r2,zero,3d90 <icmp_input+0x3e0>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
    3cd4:	1080028b 	ldhu	r2,10(r2)
    3cd8:	94800204 	addi	r18,r18,8
    3cdc:	1480092e 	bgeu	r2,r18,3d04 <icmp_input+0x354>
    3ce0:	010000b4 	movhi	r4,2
    3ce4:	210d4b04 	addi	r4,r4,13612
    3ce8:	014000b4 	movhi	r5,2
    3cec:	29527d04 	addi	r5,r5,18932
    3cf0:	01802884 	movi	r6,162
    3cf4:	01c000b4 	movhi	r7,2
    3cf8:	39d26904 	addi	r7,r7,18852
    3cfc:	00104380 	call	10438 <printf>
    3d00:	003fff06 	br	3d00 <icmp_input+0x350>
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
    3d04:	a809883a 	mov	r4,r21
    3d08:	880b883a 	mov	r5,r17
    3d0c:	0006fc00 	call	6fc0 <pbuf_copy>
    3d10:	10803fcc 	andi	r2,r2,255
    3d14:	1080201c 	xori	r2,r2,128
    3d18:	10bfe004 	addi	r2,r2,-128
    3d1c:	10000926 	beq	r2,zero,3d44 <icmp_input+0x394>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
    3d20:	010000b4 	movhi	r4,2
    3d24:	210d4b04 	addi	r4,r4,13612
    3d28:	014000b4 	movhi	r5,2
    3d2c:	29528b04 	addi	r5,r5,18988
    3d30:	01802944 	movi	r6,165
    3d34:	01c000b4 	movhi	r7,2
    3d38:	39d26904 	addi	r7,r7,18852
    3d3c:	00104380 	call	10438 <printf>
    3d40:	003fff06 	br	3d40 <icmp_input+0x390>
        goto memerr;
      }
      iphdr = (struct ip_hdr *)r->payload;
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
    3d44:	a809883a 	mov	r4,r21
    3d48:	980b883a 	mov	r5,r19
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
        goto memerr;
      }
      iphdr = (struct ip_hdr *)r->payload;
    3d4c:	ac800117 	ldw	r18,4(r21)
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
    3d50:	00066980 	call	6698 <pbuf_header>
    3d54:	10803fcc 	andi	r2,r2,255
    3d58:	10000926 	beq	r2,zero,3d80 <icmp_input+0x3d0>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
    3d5c:	010000b4 	movhi	r4,2
    3d60:	210d4b04 	addi	r4,r4,13612
    3d64:	014000b4 	movhi	r5,2
    3d68:	29529504 	addi	r5,r5,19028
    3d6c:	01802ac4 	movi	r6,171
    3d70:	01c000b4 	movhi	r7,2
    3d74:	39d26904 	addi	r7,r7,18852
    3d78:	00104380 	call	10438 <printf>
    3d7c:	003fff06 	br	3d7c <icmp_input+0x3cc>
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
    3d80:	8809883a 	mov	r4,r17
    3d84:	00067d80 	call	67d8 <pbuf_free>
    3d88:	a823883a 	mov	r17,r21
    3d8c:	003f8806 	br	3bb0 <icmp_input+0x200>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
memerr:
  pbuf_free(p);
    3d90:	8809883a 	mov	r4,r17
    3d94:	00067d80 	call	67d8 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
    3d98:	80801d0b 	ldhu	r2,116(r16)
    3d9c:	10800044 	addi	r2,r2,1
    3da0:	80801d0d 	sth	r2,116(r16)
  snmp_inc_icmpinerrors();
  return;
    3da4:	003f4006 	br	3aa8 <icmp_input+0xf8>

00003da8 <icmp_dest_unreach>:
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_addr_copy(iphdr_src, iphdr->src);
  ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
  pbuf_free(q);
}
    3da8:	29803fcc 	andi	r6,r5,255
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  icmp_send_response(p, ICMP_DUR, t);
    3dac:	014000c4 	movi	r5,3
    3db0:	00038801 	jmpi	3880 <icmp_send_response>

00003db4 <icmp_time_exceeded>:
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_addr_copy(iphdr_src, iphdr->src);
  ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
  pbuf_free(q);
}
    3db4:	29803fcc 	andi	r6,r5,255
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  icmp_send_response(p, ICMP_TE, t);
    3db8:	014002c4 	movi	r5,11
    3dbc:	00038801 	jmpi	3880 <icmp_send_response>

00003dc0 <lwip_standard_chksum>:
 * @return host order (!) lwip checksum (non-inverted Internet sum) 
 */

static u16_t
lwip_standard_chksum(void *dataptr, int len)
{
    3dc0:	deffff04 	addi	sp,sp,-4
  u8_t *pb = (u8_t *)dataptr;
  u16_t *ps, t = 0;
    3dc4:	d800000d 	sth	zero,0(sp)
  u32_t sum = 0;
  int odd = ((mem_ptr_t)pb & 1);
    3dc8:	2240004c 	andi	r9,r4,1

  /* Get aligned to u16_t */
  if (odd && len > 0) {
    3dcc:	48000526 	beq	r9,zero,3de4 <lwip_standard_chksum+0x24>
    3dd0:	0140290e 	bge	zero,r5,3e78 <lwip_standard_chksum+0xb8>
    ((u8_t *)&t)[1] = *pb++;
    3dd4:	20800003 	ldbu	r2,0(r4)
    len--;
    3dd8:	297fffc4 	addi	r5,r5,-1
  u32_t sum = 0;
  int odd = ((mem_ptr_t)pb & 1);

  /* Get aligned to u16_t */
  if (odd && len > 0) {
    ((u8_t *)&t)[1] = *pb++;
    3ddc:	21000044 	addi	r4,r4,1
    3de0:	d8800045 	stb	r2,1(sp)
    len--;
  }

  /* Add the bulk of the data */
  ps = (u16_t *)(void *)pb;
  while (len > 1) {
    3de4:	02000044 	movi	r8,1
    3de8:	4140230e 	bge	r8,r5,3e78 <lwip_standard_chksum+0xb8>
    3dec:	2007883a 	mov	r3,r4
    3df0:	2805883a 	mov	r2,r5
    3df4:	000d883a 	mov	r6,zero
    sum += *ps++;
    3df8:	19c0000b 	ldhu	r7,0(r3)
    len -= 2;
    3dfc:	10bfff84 	addi	r2,r2,-2
  }

  /* Add the bulk of the data */
  ps = (u16_t *)(void *)pb;
  while (len > 1) {
    sum += *ps++;
    3e00:	18c00084 	addi	r3,r3,2
    3e04:	31cd883a 	add	r6,r6,r7
    len--;
  }

  /* Add the bulk of the data */
  ps = (u16_t *)(void *)pb;
  while (len > 1) {
    3e08:	40bffb16 	blt	r8,r2,3df8 <lwip_standard_chksum+0x38>
 * @param len length of data to be summed
 * @return host order (!) lwip checksum (non-inverted Internet sum) 
 */

static u16_t
lwip_standard_chksum(void *dataptr, int len)
    3e0c:	297fff84 	addi	r5,r5,-2
    3e10:	2804d07a 	srli	r2,r5,1
    3e14:	10c00044 	addi	r3,r2,1
    3e18:	18c7883a 	add	r3,r3,r3
    3e1c:	288bc83a 	sub	r5,r5,r2
    3e20:	20c9883a 	add	r4,r4,r3
    3e24:	288bc83a 	sub	r5,r5,r2
    sum += *ps++;
    len -= 2;
  }

  /* Consume left-over byte, if any */
  if (len > 0) {
    3e28:	00800044 	movi	r2,1
    3e2c:	2880021e 	bne	r5,r2,3e38 <lwip_standard_chksum+0x78>
    ((u8_t *)&t)[0] = *(u8_t *)ps;
    3e30:	20800003 	ldbu	r2,0(r4)
    3e34:	d8800005 	stb	r2,0(sp)
  }

  /* Add end bytes */
  sum += t;
    3e38:	d880000b 	ldhu	r2,0(sp)
    3e3c:	308d883a 	add	r6,r6,r2

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  sum = FOLD_U32T(sum);
    3e40:	3004d43a 	srli	r2,r6,16
    3e44:	31bfffcc 	andi	r6,r6,65535
    3e48:	308d883a 	add	r6,r6,r2
  sum = FOLD_U32T(sum);
    3e4c:	3006d43a 	srli	r3,r6,16
    3e50:	30bfffcc 	andi	r2,r6,65535
    3e54:	10c5883a 	add	r2,r2,r3

  /* Swap if alignment was odd */
  if (odd) {
    3e58:	48000526 	beq	r9,zero,3e70 <lwip_standard_chksum+0xb0>
    sum = SWAP_BYTES_IN_WORD(sum);
    3e5c:	10ffc00c 	andi	r3,r2,65280
    3e60:	1004923a 	slli	r2,r2,8
    3e64:	1806d23a 	srli	r3,r3,8
    3e68:	10bfffcc 	andi	r2,r2,65535
    3e6c:	10c4b03a 	or	r2,r2,r3
  }

  return (u16_t)sum;
}
    3e70:	dec00104 	addi	sp,sp,4
    3e74:	f800283a 	ret
static u16_t
lwip_standard_chksum(void *dataptr, int len)
{
  u8_t *pb = (u8_t *)dataptr;
  u16_t *ps, t = 0;
  u32_t sum = 0;
    3e78:	000d883a 	mov	r6,zero
    3e7c:	003fea06 	br	3e28 <lwip_standard_chksum+0x68>

00003e80 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       ip_addr_t *src, ip_addr_t *dest,
       u8_t proto, u16_t proto_len)
{
    3e80:	defff704 	addi	sp,sp,-36
    3e84:	ddc00715 	stw	r23,28(sp)
    3e88:	dd800615 	stw	r22,24(sp)
    3e8c:	dd400515 	stw	r21,20(sp)
    3e90:	dd000415 	stw	r20,16(sp)
    3e94:	dfc00815 	stw	ra,32(sp)
    3e98:	dcc00315 	stw	r19,12(sp)
    3e9c:	dc800215 	stw	r18,8(sp)
    3ea0:	dc400115 	stw	r17,4(sp)
    3ea4:	dc000015 	stw	r16,0(sp)
    3ea8:	282f883a 	mov	r23,r5
    3eac:	302d883a 	mov	r22,r6
    3eb0:	3829883a 	mov	r20,r7
    3eb4:	dd40090b 	ldhu	r21,36(sp)
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
    3eb8:	20004326 	beq	r4,zero,3fc8 <inet_chksum_pseudo+0x148>
    3ebc:	2021883a 	mov	r16,r4
    3ec0:	0025883a 	mov	r18,zero
    3ec4:	0023883a 	mov	r17,zero
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
    if (q->len % 2 != 0) {
      swapped = 1 - swapped;
    3ec8:	04c00044 	movi	r19,1
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
    3ecc:	81000117 	ldw	r4,4(r16)
    3ed0:	8140028b 	ldhu	r5,10(r16)
    3ed4:	0003dc00 	call	3dc0 <lwip_standard_chksum>
    3ed8:	10bfffcc 	andi	r2,r2,65535
    3edc:	88a3883a 	add	r17,r17,r2
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
    3ee0:	8806d43a 	srli	r3,r17,16
    if (q->len % 2 != 0) {
    3ee4:	8080028b 	ldhu	r2,10(r16)
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
    3ee8:	8c7fffcc 	andi	r17,r17,65535
    3eec:	88e3883a 	add	r17,r17,r3
    if (q->len % 2 != 0) {
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    3ef0:	88ffc00c 	andi	r3,r17,65280
    acc += LWIP_CHKSUM(q->payload, q->len);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
    if (q->len % 2 != 0) {
    3ef4:	1080004c 	andi	r2,r2,1
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    3ef8:	8808923a 	slli	r4,r17,8
    3efc:	1806d23a 	srli	r3,r3,8
    acc += LWIP_CHKSUM(q->payload, q->len);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
    if (q->len % 2 != 0) {
    3f00:	10000326 	beq	r2,zero,3f10 <inet_chksum_pseudo+0x90>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    3f04:	247fffcc 	andi	r17,r4,65535
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
    if (q->len % 2 != 0) {
      swapped = 1 - swapped;
    3f08:	9ca5c83a 	sub	r18,r19,r18
      acc = SWAP_BYTES_IN_WORD(acc);
    3f0c:	88e2b03a 	or	r17,r17,r3
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
    3f10:	84000017 	ldw	r16,0(r16)
    3f14:	803fed1e 	bne	r16,zero,3ecc <inet_chksum_pseudo+0x4c>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
    3f18:	94803fcc 	andi	r18,r18,255
    3f1c:	90000526 	beq	r18,zero,3f34 <inet_chksum_pseudo+0xb4>
    acc = SWAP_BYTES_IN_WORD(acc);
    3f20:	88bfc00c 	andi	r2,r17,65280
    3f24:	8822923a 	slli	r17,r17,8
    3f28:	1004d23a 	srli	r2,r2,8
    3f2c:	8c7fffcc 	andi	r17,r17,65535
    3f30:	88a2b03a 	or	r17,r17,r2
  }
  addr = ip4_addr_get_u32(src);
    3f34:	b8c00017 	ldw	r3,0(r23)
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
  addr = ip4_addr_get_u32(dest);
    3f38:	b0800017 	ldw	r2,0(r22)
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
  acc += (u32_t)htons((u16_t)proto);
  acc += (u32_t)htons(proto_len);
    3f3c:	ad7fffcc 	andi	r21,r21,65535
  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  addr = ip4_addr_get_u32(src);
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
    3f40:	180ed43a 	srli	r7,r3,16
  addr = ip4_addr_get_u32(dest);
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
    3f44:	100cd43a 	srli	r6,r2,16
  acc += (u32_t)htons((u16_t)proto);
  acc += (u32_t)htons(proto_len);
    3f48:	a80a923a 	slli	r5,r21,8
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
  addr = ip4_addr_get_u32(dest);
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
  acc += (u32_t)htons((u16_t)proto);
    3f4c:	a1003fcc 	andi	r4,r20,255

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  addr = ip4_addr_get_u32(src);
  acc += (addr & 0xffffUL);
    3f50:	18ffffcc 	andi	r3,r3,65535
    3f54:	38c7883a 	add	r3,r7,r3
  acc += ((addr >> 16) & 0xffffUL);
  addr = ip4_addr_get_u32(dest);
  acc += (addr & 0xffffUL);
    3f58:	10bfffcc 	andi	r2,r2,65535
  acc += ((addr >> 16) & 0xffffUL);
  acc += (u32_t)htons((u16_t)proto);
    3f5c:	2008923a 	slli	r4,r4,8
  acc += (u32_t)htons(proto_len);
    3f60:	a82ad23a 	srli	r21,r21,8
  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  addr = ip4_addr_get_u32(src);
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
    3f64:	18a9883a 	add	r20,r3,r2
  addr = ip4_addr_get_u32(dest);
  acc += (addr & 0xffffUL);
    3f68:	a1a9883a 	add	r20,r20,r6
  acc += ((addr >> 16) & 0xffffUL);
  acc += (u32_t)htons((u16_t)proto);
  acc += (u32_t)htons(proto_len);
    3f6c:	28ffffcc 	andi	r3,r5,65535
  addr = ip4_addr_get_u32(src);
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
  addr = ip4_addr_get_u32(dest);
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
    3f70:	a129883a 	add	r20,r20,r4
  acc += (u32_t)htons((u16_t)proto);
  acc += (u32_t)htons(proto_len);
    3f74:	1d6ab03a 	or	r21,r3,r21
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
  addr = ip4_addr_get_u32(dest);
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
  acc += (u32_t)htons((u16_t)proto);
    3f78:	a56b883a 	add	r21,r20,r21
  acc += (u32_t)htons(proto_len);
    3f7c:	ac63883a 	add	r17,r21,r17

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
    3f80:	8804d43a 	srli	r2,r17,16
    3f84:	8c7fffcc 	andi	r17,r17,65535
    3f88:	88a3883a 	add	r17,r17,r2
  acc = FOLD_U32T(acc);
    3f8c:	8804d43a 	srli	r2,r17,16
    3f90:	8c7fffcc 	andi	r17,r17,65535
    3f94:	8885883a 	add	r2,r17,r2
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
}
    3f98:	0084303a 	nor	r2,zero,r2
    3f9c:	dfc00817 	ldw	ra,32(sp)
    3fa0:	ddc00717 	ldw	r23,28(sp)
    3fa4:	dd800617 	ldw	r22,24(sp)
    3fa8:	dd400517 	ldw	r21,20(sp)
    3fac:	dd000417 	ldw	r20,16(sp)
    3fb0:	dcc00317 	ldw	r19,12(sp)
    3fb4:	dc800217 	ldw	r18,8(sp)
    3fb8:	dc400117 	ldw	r17,4(sp)
    3fbc:	dc000017 	ldw	r16,0(sp)
    3fc0:	dec00904 	addi	sp,sp,36
    3fc4:	f800283a 	ret
  u32_t acc;
  u32_t addr;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
    3fc8:	0023883a 	mov	r17,zero
    3fcc:	003fd906 	br	3f34 <inet_chksum_pseudo+0xb4>

00003fd0 <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       ip_addr_t *src, ip_addr_t *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
    3fd0:	defff504 	addi	sp,sp,-44
    3fd4:	ddc00815 	stw	r23,32(sp)
    3fd8:	dd800715 	stw	r22,28(sp)
    3fdc:	dd400615 	stw	r21,24(sp)
    3fe0:	dd000515 	stw	r20,20(sp)
    3fe4:	dfc00a15 	stw	ra,40(sp)
    3fe8:	df000915 	stw	fp,36(sp)
    3fec:	dcc00415 	stw	r19,16(sp)
    3ff0:	dc800315 	stw	r18,12(sp)
    3ff4:	dc400215 	stw	r17,8(sp)
    3ff8:	dc000115 	stw	r16,4(sp)
    3ffc:	d9c00005 	stb	r7,0(sp)
    4000:	282f883a 	mov	r23,r5
    4004:	302d883a 	mov	r22,r6
    4008:	dd400b0b 	ldhu	r21,44(sp)
    400c:	dd000c0b 	ldhu	r20,48(sp)
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
    4010:	20005a26 	beq	r4,zero,417c <inet_chksum_pseudo_partial+0x1ac>
    4014:	a17fffcc 	andi	r5,r20,65535
    4018:	28005826 	beq	r5,zero,417c <inet_chksum_pseudo_partial+0x1ac>
    401c:	2023883a 	mov	r17,r4
    4020:	0025883a 	mov	r18,zero
    4024:	0021883a 	mov	r16,zero
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
    4028:	04dfff84 	movi	r19,32766
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
    if (q->len % 2 != 0) {
      swapped = 1 - swapped;
    402c:	07000044 	movi	fp,1
    4030:	00000d06 	br	4068 <inet_chksum_pseudo_partial+0x98>
    acc += LWIP_CHKSUM(q->payload, chklen);
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
    4034:	8121883a 	add	r16,r16,r4
    if (q->len % 2 != 0) {
    4038:	8880028b 	ldhu	r2,10(r17)
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    403c:	8008923a 	slli	r4,r16,8
    4040:	81bfc00c 	andi	r6,r16,65280
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
    if (q->len % 2 != 0) {
    4044:	1080004c 	andi	r2,r2,1
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    4048:	300cd23a 	srli	r6,r6,8
    404c:	213fffcc 	andi	r4,r4,65535
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
    if (q->len % 2 != 0) {
    4050:	10000226 	beq	r2,zero,405c <inet_chksum_pseudo_partial+0x8c>
      swapped = 1 - swapped;
    4054:	e4a5c83a 	sub	r18,fp,r18
      acc = SWAP_BYTES_IN_WORD(acc);
    4058:	21a0b03a 	or	r16,r4,r6
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
    405c:	8c400017 	ldw	r17,0(r17)
    4060:	88001926 	beq	r17,zero,40c8 <inet_chksum_pseudo_partial+0xf8>
    4064:	28001826 	beq	r5,zero,40c8 <inet_chksum_pseudo_partial+0xf8>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
    4068:	8900028b 	ldhu	r4,10(r17)
    406c:	a005883a 	mov	r2,r20
    4070:	21bfffcc 	andi	r6,r4,65535
    4074:	3140012e 	bgeu	r6,r5,407c <inet_chksum_pseudo_partial+0xac>
    4078:	2005883a 	mov	r2,r4
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
    407c:	89000117 	ldw	r4,4(r17)
    4080:	117fffcc 	andi	r5,r2,65535
    chksum_len -= chklen;
    4084:	a0a9c83a 	sub	r20,r20,r2
      (void *)q, (void *)q->next));
    chklen = q->len;
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
    4088:	0003dc00 	call	3dc0 <lwip_standard_chksum>
    408c:	10bfffcc 	andi	r2,r2,65535
    4090:	8085883a 	add	r2,r16,r2
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
    4094:	a17fffcc 	andi	r5,r20,65535
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
    4098:	1008d43a 	srli	r4,r2,16
    409c:	143fffcc 	andi	r16,r2,65535
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
    40a0:	997fe42e 	bgeu	r19,r5,4034 <inet_chksum_pseudo_partial+0x64>
    40a4:	010000b4 	movhi	r4,2
    40a8:	210d4b04 	addi	r4,r4,13612
    40ac:	014000b4 	movhi	r5,2
    40b0:	2952ab04 	addi	r5,r5,19116
    40b4:	01805884 	movi	r6,354
    40b8:	01c000b4 	movhi	r7,2
    40bc:	39d2ae04 	addi	r7,r7,19128
    40c0:	00104380 	call	10438 <printf>
    40c4:	003fff06 	br	40c4 <inet_chksum_pseudo_partial+0xf4>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
    40c8:	94803fcc 	andi	r18,r18,255
    40cc:	90000526 	beq	r18,zero,40e4 <inet_chksum_pseudo_partial+0x114>
    acc = SWAP_BYTES_IN_WORD(acc);
    40d0:	80bfc00c 	andi	r2,r16,65280
    40d4:	8020923a 	slli	r16,r16,8
    40d8:	1004d23a 	srli	r2,r2,8
    40dc:	843fffcc 	andi	r16,r16,65535
    40e0:	80a0b03a 	or	r16,r16,r2
  }
  addr = ip4_addr_get_u32(src);
    40e4:	b8c00017 	ldw	r3,0(r23)
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
  addr = ip4_addr_get_u32(dest);
    40e8:	b0800017 	ldw	r2,0(r22)
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
  acc += (u32_t)htons((u16_t)proto);
    40ec:	dd000003 	ldbu	r20,0(sp)
  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  addr = ip4_addr_get_u32(src);
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
    40f0:	180cd43a 	srli	r6,r3,16
  addr = ip4_addr_get_u32(dest);
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
  acc += (u32_t)htons((u16_t)proto);
  acc += (u32_t)htons(proto_len);
    40f4:	ad7fffcc 	andi	r21,r21,65535
    40f8:	a80a923a 	slli	r5,r21,8

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  addr = ip4_addr_get_u32(src);
  acc += (addr & 0xffffUL);
    40fc:	18ffffcc 	andi	r3,r3,65535
  acc += ((addr >> 16) & 0xffffUL);
  addr = ip4_addr_get_u32(dest);
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
    4100:	1008d43a 	srli	r4,r2,16

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  addr = ip4_addr_get_u32(src);
  acc += (addr & 0xffffUL);
    4104:	30cd883a 	add	r6,r6,r3
  acc += ((addr >> 16) & 0xffffUL);
  addr = ip4_addr_get_u32(dest);
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
  acc += (u32_t)htons((u16_t)proto);
  acc += (u32_t)htons(proto_len);
    4108:	a82ad23a 	srli	r21,r21,8
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
  addr = ip4_addr_get_u32(dest);
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
  acc += (u32_t)htons((u16_t)proto);
    410c:	a006923a 	slli	r3,r20,8
  }
  addr = ip4_addr_get_u32(src);
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
  addr = ip4_addr_get_u32(dest);
  acc += (addr & 0xffffUL);
    4110:	10bfffcc 	andi	r2,r2,65535
  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  addr = ip4_addr_get_u32(src);
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
    4114:	3085883a 	add	r2,r6,r2
  addr = ip4_addr_get_u32(dest);
  acc += (addr & 0xffffUL);
    4118:	1109883a 	add	r4,r2,r4
  acc += ((addr >> 16) & 0xffffUL);
  acc += (u32_t)htons((u16_t)proto);
  acc += (u32_t)htons(proto_len);
    411c:	28bfffcc 	andi	r2,r5,65535
  addr = ip4_addr_get_u32(src);
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
  addr = ip4_addr_get_u32(dest);
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
    4120:	20c7883a 	add	r3,r4,r3
  acc += (u32_t)htons((u16_t)proto);
  acc += (u32_t)htons(proto_len);
    4124:	1544b03a 	or	r2,r2,r21
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
  addr = ip4_addr_get_u32(dest);
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
  acc += (u32_t)htons((u16_t)proto);
    4128:	1885883a 	add	r2,r3,r2
  acc += (u32_t)htons(proto_len);
    412c:	1421883a 	add	r16,r2,r16

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
    4130:	8004d43a 	srli	r2,r16,16
    4134:	843fffcc 	andi	r16,r16,65535
    4138:	8085883a 	add	r2,r16,r2
  acc = FOLD_U32T(acc);
    413c:	1006d43a 	srli	r3,r2,16
    4140:	10bfffcc 	andi	r2,r2,65535
    4144:	10c5883a 	add	r2,r2,r3
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
}
    4148:	0084303a 	nor	r2,zero,r2
    414c:	dfc00a17 	ldw	ra,40(sp)
    4150:	df000917 	ldw	fp,36(sp)
    4154:	ddc00817 	ldw	r23,32(sp)
    4158:	dd800717 	ldw	r22,28(sp)
    415c:	dd400617 	ldw	r21,24(sp)
    4160:	dd000517 	ldw	r20,20(sp)
    4164:	dcc00417 	ldw	r19,16(sp)
    4168:	dc800317 	ldw	r18,12(sp)
    416c:	dc400217 	ldw	r17,8(sp)
    4170:	dc000117 	ldw	r16,4(sp)
    4174:	dec00b04 	addi	sp,sp,44
    4178:	f800283a 	ret
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
    417c:	0021883a 	mov	r16,zero
    4180:	003fd806 	br	40e4 <inet_chksum_pseudo_partial+0x114>

00004184 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
    4184:	deffff04 	addi	sp,sp,-4
  return ~LWIP_CHKSUM(dataptr, len);
    4188:	297fffcc 	andi	r5,r5,65535
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
    418c:	dfc00015 	stw	ra,0(sp)
  return ~LWIP_CHKSUM(dataptr, len);
    4190:	0003dc00 	call	3dc0 <lwip_standard_chksum>
}
    4194:	0084303a 	nor	r2,zero,r2
    4198:	dfc00017 	ldw	ra,0(sp)
    419c:	dec00104 	addi	sp,sp,4
    41a0:	f800283a 	ret

000041a4 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
    41a4:	defffb04 	addi	sp,sp,-20
    41a8:	dfc00415 	stw	ra,16(sp)
    41ac:	dcc00315 	stw	r19,12(sp)
    41b0:	dc800215 	stw	r18,8(sp)
    41b4:	dc400115 	stw	r17,4(sp)
    41b8:	dc000015 	stw	r16,0(sp)
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
    41bc:	20002d26 	beq	r4,zero,4274 <inet_chksum_pbuf+0xd0>
    41c0:	2021883a 	mov	r16,r4
    41c4:	0025883a 	mov	r18,zero
    41c8:	0023883a 	mov	r17,zero
    acc += LWIP_CHKSUM(q->payload, q->len);
    acc = FOLD_U32T(acc);
    if (q->len % 2 != 0) {
      swapped = 1 - swapped;
    41cc:	04c00044 	movi	r19,1
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
    acc += LWIP_CHKSUM(q->payload, q->len);
    41d0:	81000117 	ldw	r4,4(r16)
    41d4:	8140028b 	ldhu	r5,10(r16)
    41d8:	0003dc00 	call	3dc0 <lwip_standard_chksum>
    41dc:	10bfffcc 	andi	r2,r2,65535
    41e0:	88a3883a 	add	r17,r17,r2
    acc = FOLD_U32T(acc);
    41e4:	8806d43a 	srli	r3,r17,16
    if (q->len % 2 != 0) {
    41e8:	8080028b 	ldhu	r2,10(r16)

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
    acc += LWIP_CHKSUM(q->payload, q->len);
    acc = FOLD_U32T(acc);
    41ec:	8c7fffcc 	andi	r17,r17,65535
    41f0:	88e3883a 	add	r17,r17,r3
    if (q->len % 2 != 0) {
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    41f4:	88ffc00c 	andi	r3,r17,65280
  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
    acc += LWIP_CHKSUM(q->payload, q->len);
    acc = FOLD_U32T(acc);
    if (q->len % 2 != 0) {
    41f8:	1080004c 	andi	r2,r2,1
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    41fc:	8808923a 	slli	r4,r17,8
    4200:	1806d23a 	srli	r3,r3,8
  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
    acc += LWIP_CHKSUM(q->payload, q->len);
    acc = FOLD_U32T(acc);
    if (q->len % 2 != 0) {
    4204:	10000326 	beq	r2,zero,4214 <inet_chksum_pbuf+0x70>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    4208:	247fffcc 	andi	r17,r4,65535
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
    acc += LWIP_CHKSUM(q->payload, q->len);
    acc = FOLD_U32T(acc);
    if (q->len % 2 != 0) {
      swapped = 1 - swapped;
    420c:	9ca5c83a 	sub	r18,r19,r18
      acc = SWAP_BYTES_IN_WORD(acc);
    4210:	88e2b03a 	or	r17,r17,r3
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
    4214:	84000017 	ldw	r16,0(r16)
    4218:	803fed1e 	bne	r16,zero,41d0 <inet_chksum_pbuf+0x2c>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
    421c:	94803fcc 	andi	r18,r18,255
    4220:	90000c26 	beq	r18,zero,4254 <inet_chksum_pbuf+0xb0>
    acc = SWAP_BYTES_IN_WORD(acc);
    4224:	88ffc00c 	andi	r3,r17,65280
    4228:	8804923a 	slli	r2,r17,8
    422c:	1806d23a 	srli	r3,r3,8
    4230:	10bfffcc 	andi	r2,r2,65535
    4234:	10c4303a 	nor	r2,r2,r3
  }
  return (u16_t)~(acc & 0xffffUL);
}
    4238:	dfc00417 	ldw	ra,16(sp)
    423c:	dcc00317 	ldw	r19,12(sp)
    4240:	dc800217 	ldw	r18,8(sp)
    4244:	dc400117 	ldw	r17,4(sp)
    4248:	dc000017 	ldw	r16,0(sp)
    424c:	dec00504 	addi	sp,sp,20
    4250:	f800283a 	ret
    4254:	0444303a 	nor	r2,zero,r17
    4258:	dfc00417 	ldw	ra,16(sp)
    425c:	dcc00317 	ldw	r19,12(sp)
    4260:	dc800217 	ldw	r18,8(sp)
    4264:	dc400117 	ldw	r17,4(sp)
    4268:	dc000017 	ldw	r16,0(sp)
    426c:	dec00504 	addi	sp,sp,20
    4270:	f800283a 	ret
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
    4274:	00bfffc4 	movi	r2,-1
    4278:	003fef06 	br	4238 <inet_chksum_pbuf+0x94>

0000427c <ip_route>:
    return netif;
  }
#endif

  /* iterate through netifs */
  for (netif = netif_list; netif != NULL; netif = netif->next) {
    427c:	008000f4 	movhi	r2,3
    4280:	10aeb404 	addi	r2,r2,-17712
    4284:	10800017 	ldw	r2,0(r2)
    4288:	10000a26 	beq	r2,zero,42b4 <ip_route+0x38>
    /* network mask matches? */
    if (netif_is_up(netif)) {
    428c:	10c00b43 	ldbu	r3,45(r2)
    4290:	18c0004c 	andi	r3,r3,1
    4294:	183ffb26 	beq	r3,zero,4284 <ip_route+0x8>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
    4298:	11800117 	ldw	r6,4(r2)
    429c:	20c00017 	ldw	r3,0(r4)
    42a0:	11400217 	ldw	r5,8(r2)
    42a4:	30c6f03a 	xor	r3,r6,r3
    42a8:	1946703a 	and	r3,r3,r5
    42ac:	183ff51e 	bne	r3,zero,4284 <ip_route+0x8>
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
}
    42b0:	f800283a 	ret
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
    42b4:	008000f4 	movhi	r2,3
    42b8:	10aeb504 	addi	r2,r2,-17708
    42bc:	10800017 	ldw	r2,0(r2)
    42c0:	10000326 	beq	r2,zero,42d0 <ip_route+0x54>
    42c4:	10c00b43 	ldbu	r3,45(r2)
    42c8:	18c0004c 	andi	r3,r3,1
    42cc:	183ff81e 	bne	r3,zero,42b0 <ip_route+0x34>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_route: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
    42d0:	00c001f4 	movhi	r3,7
    42d4:	18d44804 	addi	r3,r3,20768
    42d8:	1900158b 	ldhu	r4,86(r3)
    snmp_inc_ipoutnoroutes();
    return NULL;
    42dc:	0005883a 	mov	r2,zero
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_route: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
    42e0:	21000044 	addi	r4,r4,1
    42e4:	1900158d 	sth	r4,86(r3)
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
}
    42e8:	f800283a 	ret

000042ec <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
    42ec:	defff704 	addi	sp,sp,-36
    42f0:	dc000015 	stw	r16,0(sp)
  u16_t iphdr_len;
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  int check_ip_src=1;
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */

  IP_STATS_INC(ip.recv);
    42f4:	040001f4 	movhi	r16,7
    42f8:	84144804 	addi	r16,r16,20768
    42fc:	8080128b 	ldhu	r2,74(r16)
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
    4300:	dcc00315 	stw	r19,12(sp)

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
    4304:	24c00117 	ldw	r19,4(r4)
  u16_t iphdr_len;
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  int check_ip_src=1;
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */

  IP_STATS_INC(ip.recv);
    4308:	10800044 	addi	r2,r2,1
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
    430c:	dd000415 	stw	r20,16(sp)
    4310:	dc800215 	stw	r18,8(sp)
    4314:	dfc00815 	stw	ra,32(sp)
    4318:	ddc00715 	stw	r23,28(sp)
    431c:	dd800615 	stw	r22,24(sp)
    4320:	dd400515 	stw	r21,20(sp)
    4324:	dc400115 	stw	r17,4(sp)
  u16_t iphdr_len;
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  int check_ip_src=1;
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */

  IP_STATS_INC(ip.recv);
    4328:	8080128d 	sth	r2,74(r16)
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
  if (IPH_V(iphdr) != 4) {
    432c:	98800003 	ldbu	r2,0(r19)
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
    4330:	2829883a 	mov	r20,r5
  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
  if (IPH_V(iphdr) != 4) {
    4334:	00c00104 	movi	r3,4
    4338:	11403fcc 	andi	r5,r2,255
    433c:	280ad13a 	srli	r5,r5,4
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
    4340:	2025883a 	mov	r18,r4
  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
  if (IPH_V(iphdr) != 4) {
    4344:	28c0201e 	bne	r5,r3,43c8 <ip_input+0xdc>
  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
    4348:	98c0008b 	ldhu	r3,2(r19)
    return ERR_OK;
  }
#endif

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
    434c:	108003cc 	andi	r2,r2,15
  iphdr_hlen *= 4;
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
    4350:	2100028b 	ldhu	r4,10(r4)
  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
    4354:	180a923a 	slli	r5,r3,8
    4358:	1806d23a 	srli	r3,r3,8
#endif

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
    435c:	1085883a 	add	r2,r2,r2
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
    4360:	10ad883a 	add	r22,r2,r2
  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
    4364:	28c6b03a 	or	r3,r5,r3

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
    4368:	25800336 	bltu	r4,r22,4378 <ip_input+0x8c>
    436c:	9080020b 	ldhu	r2,8(r18)
    4370:	1c7fffcc 	andi	r17,r3,65535
    4374:	14401c2e 	bgeu	r2,r17,43e8 <ip_input+0xfc>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
        iphdr_len, p->tot_len));
    }
    /* free (drop) packet pbufs */
    pbuf_free(p);
    4378:	9009883a 	mov	r4,r18
    437c:	00067d80 	call	67d8 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
    4380:	80c0148b 	ldhu	r3,82(r16)
    IP_STATS_INC(ip.drop);
    4384:	8080138b 	ldhu	r2,78(r16)
        ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
        iphdr_len, p->tot_len));
    }
    /* free (drop) packet pbufs */
    pbuf_free(p);
    IP_STATS_INC(ip.lenerr);
    4388:	18c00044 	addi	r3,r3,1
    IP_STATS_INC(ip.drop);
    438c:	10800044 	addi	r2,r2,1
        ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
        iphdr_len, p->tot_len));
    }
    /* free (drop) packet pbufs */
    pbuf_free(p);
    IP_STATS_INC(ip.lenerr);
    4390:	80c0148d 	sth	r3,82(r16)
    IP_STATS_INC(ip.drop);
    4394:	8080138d 	sth	r2,78(r16)
  current_header = NULL;
  ip_addr_set_any(&current_iphdr_src);
  ip_addr_set_any(&current_iphdr_dest);

  return ERR_OK;
}
    4398:	0005883a 	mov	r2,zero
    439c:	dfc00817 	ldw	ra,32(sp)
    43a0:	ddc00717 	ldw	r23,28(sp)
    43a4:	dd800617 	ldw	r22,24(sp)
    43a8:	dd400517 	ldw	r21,20(sp)
    43ac:	dd000417 	ldw	r20,16(sp)
    43b0:	dcc00317 	ldw	r19,12(sp)
    43b4:	dc800217 	ldw	r18,8(sp)
    43b8:	dc400117 	ldw	r17,4(sp)
    43bc:	dc000017 	ldw	r16,0(sp)
    43c0:	dec00904 	addi	sp,sp,36
    43c4:	f800283a 	ret
  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
  if (IPH_V(iphdr) != 4) {
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
    43c8:	00067d80 	call	67d8 <pbuf_free>
    IP_STATS_INC(ip.err);
    43cc:	80c0170b 	ldhu	r3,92(r16)
    IP_STATS_INC(ip.drop);
    43d0:	8080138b 	ldhu	r2,78(r16)
  iphdr = (struct ip_hdr *)p->payload;
  if (IPH_V(iphdr) != 4) {
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
    IP_STATS_INC(ip.err);
    43d4:	18c00044 	addi	r3,r3,1
    IP_STATS_INC(ip.drop);
    43d8:	10800044 	addi	r2,r2,1
  iphdr = (struct ip_hdr *)p->payload;
  if (IPH_V(iphdr) != 4) {
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
    IP_STATS_INC(ip.err);
    43dc:	80c0170d 	sth	r3,92(r16)
    IP_STATS_INC(ip.drop);
    43e0:	8080138d 	sth	r2,78(r16)
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
    43e4:	003fec06 	br	4398 <ip_input+0xac>
    return ERR_OK;
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
    43e8:	9809883a 	mov	r4,r19
    43ec:	b00b883a 	mov	r5,r22
    43f0:	00041840 	call	4184 <inet_chksum>
    43f4:	10bfffcc 	andi	r2,r2,65535

    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
      ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
    43f8:	9009883a 	mov	r4,r18
    return ERR_OK;
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
    43fc:	10005a1e 	bne	r2,zero,4568 <ip_input+0x27c>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
    4400:	880b883a 	mov	r5,r17
    4404:	00069140 	call	6914 <pbuf_realloc>

  /* copy IP addresses to aligned ip_addr_t */
  ip_addr_copy(current_iphdr_dest, iphdr->dest);
    4408:	9880048b 	ldhu	r2,18(r19)
    440c:	98c0040b 	ldhu	r3,16(r19)
  ip_addr_copy(current_iphdr_src, iphdr->src);
    4410:	a023883a 	mov	r17,r20
  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);

  /* copy IP addresses to aligned ip_addr_t */
  ip_addr_copy(current_iphdr_dest, iphdr->dest);
    4414:	1004943a 	slli	r2,r2,16
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
    4418:	05400044 	movi	r21,1
        }
#endif /* LWIP_AUTOIP */
      }
      if (first) {
        first = 0;
        netif = netif_list;
    441c:	05c000f4 	movhi	r23,3
    4420:	bdeeb404 	addi	r23,r23,-17712
  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);

  /* copy IP addresses to aligned ip_addr_t */
  ip_addr_copy(current_iphdr_dest, iphdr->dest);
    4424:	10c4b03a 	or	r2,r2,r3
    4428:	d0a8af15 	stw	r2,-23876(gp)
  ip_addr_copy(current_iphdr_src, iphdr->src);
    442c:	9880038b 	ldhu	r2,14(r19)
    4430:	98c0030b 	ldhu	r3,12(r19)
    4434:	1004943a 	slli	r2,r2,16
    4438:	10c4b03a 	or	r2,r2,r3
    443c:	d0a8ad15 	stw	r2,-23884(gp)
          ip4_addr_get_u32(&iphdr->dest) & ip4_addr_get_u32(&netif->netmask),
          ip4_addr_get_u32(&netif->ip_addr) & ip4_addr_get_u32(&netif->netmask),
          ip4_addr_get_u32(&iphdr->dest) & ~ip4_addr_get_u32(&netif->netmask)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
    4440:	88c00b43 	ldbu	r3,45(r17)
    4444:	18c0004c 	andi	r3,r3,1
    4448:	18000826 	beq	r3,zero,446c <ip_input+0x180>
    444c:	88800117 	ldw	r2,4(r17)
    4450:	10000626 	beq	r2,zero,446c <ip_input+0x180>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
    4454:	d128af17 	ldw	r4,-23876(gp)
    4458:	11000c26 	beq	r2,r4,448c <ip_input+0x1a0>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&current_iphdr_dest, netif)) {
    445c:	880b883a 	mov	r5,r17
    4460:	00049440 	call	4944 <ip4_addr_isbroadcast>
          ip4_addr_get_u32(&iphdr->dest) & ~ip4_addr_get_u32(&netif->netmask)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
    4464:	10803fcc 	andi	r2,r2,255
    4468:	1000081e 	bne	r2,zero,448c <ip_input+0x1a0>
          /* break out of for loop */
          break;
        }
#endif /* LWIP_AUTOIP */
      }
      if (first) {
    446c:	a8003a26 	beq	r21,zero,4558 <ip_input+0x26c>
        first = 0;
        netif = netif_list;
    4470:	bc400017 	ldw	r17,0(r23)
      } else {
        netif = netif->next;
      }
      if (netif == inp) {
    4474:	8d003a26 	beq	r17,r20,4560 <ip_input+0x274>
    4478:	002b883a 	mov	r21,zero
        netif = netif->next;
      }
    } while(netif != NULL);
    447c:	883ff01e 	bne	r17,zero,4440 <ip_input+0x154>
   *
   * #define LWIP_IP_ACCEPT_UDP_PORT(dst_port) ((dst_port) == PP_NTOHS(12345))
   */
  if (netif == NULL) {
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
    4480:	98c00243 	ldbu	r3,9(r19)
    4484:	00800444 	movi	r2,17
    4488:	18805926 	beq	r3,r2,45f0 <ip_input+0x304>
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
  if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
    448c:	d128ad17 	ldw	r4,-23884(gp)
    4490:	20003d1e 	bne	r4,zero,4588 <ip_input+0x29c>
      return ERR_OK;
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
    4494:	88005c26 	beq	r17,zero,4608 <ip_input+0x31c>
    }
    pbuf_free(p);
    return ERR_OK;
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
    4498:	9880018b 	ldhu	r2,6(r19)
    449c:	10bfcfcc 	andi	r2,r2,65343
    44a0:	10000526 	beq	r2,zero,44b8 <ip_input+0x1cc>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & PP_HTONS(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
    44a4:	9009883a 	mov	r4,r18
    44a8:	00051780 	call	5178 <ip_reass>
    44ac:	1025883a 	mov	r18,r2
    /* packet not fully reassembled yet? */
    if (p == NULL) {
    44b0:	103fb926 	beq	r2,zero,4398 <ip_input+0xac>
      return ERR_OK;
    }
    iphdr = (struct ip_hdr *)p->payload;
    44b4:	14c00117 	ldw	r19,4(r2)
  current_netif = inp;
  current_header = iphdr;

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
    44b8:	9009883a 	mov	r4,r18
    44bc:	a00b883a 	mov	r5,r20
  /* send to upper layers */
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: \n"));
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

  current_netif = inp;
    44c0:	d528ae15 	stw	r20,-23880(gp)
  current_header = iphdr;
    44c4:	d4e8b015 	stw	r19,-23872(gp)

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
    44c8:	00076e80 	call	76e8 <raw_input>
    44cc:	10803fcc 	andi	r2,r2,255
    44d0:	10001c1e 	bne	r2,zero,4544 <ip_input+0x258>
#endif /* LWIP_RAW */
  {
    switch (IPH_PROTO(iphdr)) {
    44d4:	98800243 	ldbu	r2,9(r19)
    44d8:	00c00184 	movi	r3,6
    44dc:	10c03c26 	beq	r2,r3,45d0 <ip_input+0x2e4>
    44e0:	00c00444 	movi	r3,17
    44e4:	10c03626 	beq	r2,r3,45c0 <ip_input+0x2d4>
    44e8:	00c00044 	movi	r3,1
    44ec:	10c03c26 	beq	r2,r3,45e0 <ip_input+0x2f4>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) &&
    44f0:	d128af17 	ldw	r4,-23876(gp)
    44f4:	a00b883a 	mov	r5,r20
    44f8:	00049440 	call	4944 <ip4_addr_isbroadcast>
    44fc:	10803fcc 	andi	r2,r2,255
    4500:	1000081e 	bne	r2,zero,4524 <ip_input+0x238>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
    4504:	d0e8af17 	ldw	r3,-23876(gp)
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) &&
    4508:	00803804 	movi	r2,224
          !ip_addr_ismulticast(&current_iphdr_dest)) {
    450c:	18c03c0c 	andi	r3,r3,240
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) &&
    4510:	18800426 	beq	r3,r2,4524 <ip_input+0x238>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
        p->payload = iphdr;
    4514:	94c00115 	stw	r19,4(r18)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
    4518:	9009883a 	mov	r4,r18
    451c:	01400084 	movi	r5,2
    4520:	0003da80 	call	3da8 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
    4524:	9009883a 	mov	r4,r18
    4528:	00067d80 	call	67d8 <pbuf_free>

      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Unsupported transport protocol %"U16_F"\n", IPH_PROTO(iphdr)));

      IP_STATS_INC(ip.proterr);
    452c:	80c0160b 	ldhu	r3,88(r16)
      IP_STATS_INC(ip.drop);
    4530:	8080138b 	ldhu	r2,78(r16)
#endif /* LWIP_ICMP */
      pbuf_free(p);

      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Unsupported transport protocol %"U16_F"\n", IPH_PROTO(iphdr)));

      IP_STATS_INC(ip.proterr);
    4534:	18c00044 	addi	r3,r3,1
      IP_STATS_INC(ip.drop);
    4538:	10800044 	addi	r2,r2,1
#endif /* LWIP_ICMP */
      pbuf_free(p);

      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Unsupported transport protocol %"U16_F"\n", IPH_PROTO(iphdr)));

      IP_STATS_INC(ip.proterr);
    453c:	80c0160d 	sth	r3,88(r16)
      IP_STATS_INC(ip.drop);
    4540:	8080138d 	sth	r2,78(r16)
      snmp_inc_ipinunknownprotos();
    }
  }

  current_netif = NULL;
    4544:	d028ae15 	stw	zero,-23880(gp)
  current_header = NULL;
    4548:	d028b015 	stw	zero,-23872(gp)
  ip_addr_set_any(&current_iphdr_src);
    454c:	d028ad15 	stw	zero,-23884(gp)
  ip_addr_set_any(&current_iphdr_dest);
    4550:	d028af15 	stw	zero,-23876(gp)

  return ERR_OK;
    4554:	003f9006 	br	4398 <ip_input+0xac>
      }
      if (first) {
        first = 0;
        netif = netif_list;
      } else {
        netif = netif->next;
    4558:	8c400017 	ldw	r17,0(r17)
      }
      if (netif == inp) {
    455c:	8d3fc61e 	bne	r17,r20,4478 <ip_input+0x18c>
        netif = netif->next;
    4560:	8c400017 	ldw	r17,0(r17)
    4564:	003fc406 	br	4478 <ip_input+0x18c>
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {

    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
      ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
    4568:	00067d80 	call	67d8 <pbuf_free>
    IP_STATS_INC(ip.chkerr);
    456c:	80c0140b 	ldhu	r3,80(r16)
    IP_STATS_INC(ip.drop);
    4570:	8080138b 	ldhu	r2,78(r16)

    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
      ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
    IP_STATS_INC(ip.chkerr);
    4574:	18c00044 	addi	r3,r3,1
    IP_STATS_INC(ip.drop);
    4578:	10800044 	addi	r2,r2,1

    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
      ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
    IP_STATS_INC(ip.chkerr);
    457c:	80c0140d 	sth	r3,80(r16)
    IP_STATS_INC(ip.drop);
    4580:	8080138d 	sth	r2,78(r16)
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
    4584:	003f8406 	br	4398 <ip_input+0xac>
  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
  if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
  {  if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) ||
    4588:	a00b883a 	mov	r5,r20
    458c:	00049440 	call	4944 <ip4_addr_isbroadcast>
    4590:	10803fcc 	andi	r2,r2,255
    4594:	1000041e 	bne	r2,zero,45a8 <ip_input+0x2bc>
         (ip_addr_ismulticast(&current_iphdr_src))) {
    4598:	d0e8ad17 	ldw	r3,-23884(gp)
  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
  if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
  {  if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) ||
    459c:	00803804 	movi	r2,224
         (ip_addr_ismulticast(&current_iphdr_src))) {
    45a0:	18c03c0c 	andi	r3,r3,240
  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
  if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
  {  if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) ||
    45a4:	18bfbb1e 	bne	r3,r2,4494 <ip_input+0x1a8>
         (ip_addr_ismulticast(&current_iphdr_src))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
    45a8:	9009883a 	mov	r4,r18
    45ac:	00067d80 	call	67d8 <pbuf_free>
      IP_STATS_INC(ip.drop);
    45b0:	8080138b 	ldhu	r2,78(r16)
    45b4:	10800044 	addi	r2,r2,1
    45b8:	8080138d 	sth	r2,78(r16)
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
    45bc:	003f7606 	br	4398 <ip_input+0xac>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
    45c0:	9009883a 	mov	r4,r18
    45c4:	a00b883a 	mov	r5,r20
    45c8:	000cfb00 	call	cfb0 <udp_input>
      break;
    45cc:	003fdd06 	br	4544 <ip_input+0x258>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
    45d0:	9009883a 	mov	r4,r18
    45d4:	a00b883a 	mov	r5,r20
    45d8:	00093f80 	call	93f8 <tcp_input>
      break;
    45dc:	003fd906 	br	4544 <ip_input+0x258>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
    45e0:	9009883a 	mov	r4,r18
    45e4:	a00b883a 	mov	r5,r20
    45e8:	00039b00 	call	39b0 <icmp_input>
      break;
    45ec:	003fd506 	br	4544 <ip_input+0x258>
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
      struct udp_hdr *udphdr = (struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen);
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(udphdr->dest)));
      if (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr->dest)) {
    45f0:	9dad883a 	add	r22,r19,r22
    45f4:	b0c0008b 	ldhu	r3,2(r22)
    45f8:	00910004 	movi	r2,17408
    45fc:	18bfa31e 	bne	r3,r2,448c <ip_input+0x1a0>
    4600:	a023883a 	mov	r17,r20
    4604:	003fa306 	br	4494 <ip_input+0x1a8>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
    4608:	9009883a 	mov	r4,r18
    460c:	00067d80 	call	67d8 <pbuf_free>
    return ERR_OK;
    4610:	003f6106 	br	4398 <ip_input+0xac>

00004614 <ip_output_if>:
  u32_t chk_sum = 0;
#endif /* CHECKSUM_GEN_IP_INLINE */

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);
    4614:	2080038b 	ldhu	r2,14(r4)
 */
err_t
ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
    4618:	defff404 	addi	sp,sp,-48
    461c:	df000a15 	stw	fp,40(sp)
    4620:	dd000615 	stw	r20,24(sp)
    4624:	dcc00515 	stw	r19,20(sp)
    4628:	dc800415 	stw	r18,16(sp)
    462c:	dc400315 	stw	r17,12(sp)
    4630:	dc000215 	stw	r16,8(sp)
    4634:	dfc00b15 	stw	ra,44(sp)
    4638:	ddc00915 	stw	r23,36(sp)
    463c:	dd800815 	stw	r22,32(sp)
    4640:	dd400715 	stw	r21,28(sp)
  u32_t chk_sum = 0;
#endif /* CHECKSUM_GEN_IP_INLINE */

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);
    4644:	00c00044 	movi	r3,1
 */
err_t
ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
    4648:	2021883a 	mov	r16,r4
    464c:	dc800c17 	ldw	r18,48(sp)
    4650:	dcc00d17 	ldw	r19,52(sp)
    4654:	3839883a 	mov	fp,r7
    4658:	2829883a 	mov	r20,r5
    465c:	dc400e17 	ldw	r17,56(sp)
  u32_t chk_sum = 0;
#endif /* CHECKSUM_GEN_IP_INLINE */

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);
    4660:	10c00926 	beq	r2,r3,4688 <ip_output_if+0x74>
    4664:	010000b4 	movhi	r4,2
    4668:	210d4b04 	addi	r4,r4,13612
    466c:	014000b4 	movhi	r5,2
    4670:	2952b704 	addi	r5,r5,19164
    4674:	0180a704 	movi	r6,668
    4678:	01c000b4 	movhi	r7,2
    467c:	39d2ba04 	addi	r7,r7,19176
    4680:	00104380 	call	10438 <printf>
    4684:	003fff06 	br	4684 <ip_output_if+0x70>

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
    4688:	30004226 	beq	r6,zero,4794 <ip_output_if+0x180>
      }
#endif /* CHECKSUM_GEN_IP_INLINE */
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
    468c:	01400504 	movi	r5,20
    4690:	d9800115 	stw	r6,4(sp)
    4694:	00066980 	call	6698 <pbuf_header>
    4698:	10803fcc 	andi	r2,r2,255
    469c:	d9800117 	ldw	r6,4(sp)
    46a0:	10006e1e 	bne	r2,zero,485c <ip_output_if+0x248>
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = (struct ip_hdr *)p->payload;
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
    46a4:	80c0028b 	ldhu	r3,10(r16)
    46a8:	010004c4 	movi	r4,19
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = (struct ip_hdr *)p->payload;
    46ac:	80800117 	ldw	r2,4(r16)
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
    46b0:	20c0612e 	bgeu	r4,r3,4838 <ip_output_if+0x224>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
    46b4:	17000205 	stb	fp,8(r2)
    IPH_PROTO_SET(iphdr, proto);
    46b8:	14c00245 	stb	r19,9(r2)
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(proto, ttl);
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip_addr_copy(iphdr->dest, *dest);
    46bc:	31400017 	ldw	r5,0(r6)
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    46c0:	00c01144 	movi	r3,69
    46c4:	10c00005 	stb	r3,0(r2)
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(proto, ttl);
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip_addr_copy(iphdr->dest, *dest);
    46c8:	280ed43a 	srli	r7,r5,16
    46cc:	297fffcc 	andi	r5,r5,65535
    46d0:	1140040d 	sth	r5,16(r2)
    46d4:	11c0048d 	sth	r7,18(r2)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
    IPH_ID_SET(iphdr, htons(ip_id));
    46d8:	d228ac0b 	ldhu	r8,-23888(gp)
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    IPH_TOS_SET(iphdr, tos);
    46dc:	14800045 	stb	r18,1(r2)
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, htons(p->tot_len));
    46e0:	8280020b 	ldhu	r10,8(r16)
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
    IPH_ID_SET(iphdr, htons(ip_id));
    46e4:	427fffcc 	andi	r9,r8,65535
    46e8:	4818923a 	slli	r12,r9,8
    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    IPH_TOS_SET(iphdr, tos);
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, htons(p->tot_len));
    46ec:	5008923a 	slli	r4,r10,8
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
    IPH_ID_SET(iphdr, htons(ip_id));
    46f0:	4806d23a 	srli	r3,r9,8
    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    IPH_TOS_SET(iphdr, tos);
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, htons(p->tot_len));
    46f4:	5014d23a 	srli	r10,r10,8
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
    IPH_PROTO_SET(iphdr, proto);
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(proto, ttl);
    46f8:	9ac03fcc 	andi	r11,r19,255
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    IPH_TOS_SET(iphdr, tos);
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
    46fc:	92403fcc 	andi	r9,r18,255
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
    IPH_PROTO_SET(iphdr, proto);
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(proto, ttl);
    4700:	5816923a 	slli	r11,r11,8
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    IPH_TOS_SET(iphdr, tos);
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
    4704:	4812923a 	slli	r9,r9,8
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, htons(p->tot_len));
    4708:	2288b03a 	or	r4,r4,r10
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
    IPH_ID_SET(iphdr, htons(ip_id));
    470c:	60c6b03a 	or	r3,r12,r3
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
    4710:	42000044 	addi	r8,r8,1
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
    IPH_PROTO_SET(iphdr, proto);
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(proto, ttl);
    4714:	e5403fcc 	andi	r21,fp,255
    IPH_OFFSET_SET(iphdr, 0);
    IPH_ID_SET(iphdr, htons(ip_id));
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
    4718:	d228ac0d 	sth	r8,-23888(gp)
    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    IPH_TOS_SET(iphdr, tos);
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, htons(p->tot_len));
    471c:	1100008d 	sth	r4,2(r2)
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
    4720:	1000018d 	sth	zero,6(r2)
    IPH_ID_SET(iphdr, htons(ip_id));
    4724:	10c0010d 	sth	r3,4(r2)
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
    IPH_PROTO_SET(iphdr, proto);
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(proto, ttl);
    4728:	5d50b03a 	or	r8,r11,r21
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    IPH_TOS_SET(iphdr, tos);
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
    472c:	4a401154 	ori	r9,r9,69
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, htons(p->tot_len));
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
    4730:	22ffffcc 	andi	r11,r4,65535
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
    IPH_ID_SET(iphdr, htons(ip_id));
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
    4734:	1abfffcc 	andi	r10,r3,65535
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;

    if (ip_addr_isany(src)) {
    4738:	a0000226 	beq	r20,zero,4744 <ip_output_if+0x130>
    473c:	a0c00017 	ldw	r3,0(r20)
    4740:	1800381e 	bne	r3,zero,4824 <ip_output_if+0x210>
      ip_addr_copy(iphdr->src, netif->ip_addr);
    4744:	88c00117 	ldw	r3,4(r17)
    4748:	1808d43a 	srli	r4,r3,16
    474c:	18ffffcc 	andi	r3,r3,65535
    4750:	10c0030d 	sth	r3,12(r2)
    4754:	1100038d 	sth	r4,14(r2)
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip_addr_copy(iphdr->dest, *dest);
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
    4758:	394b883a 	add	r5,r7,r5
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
    475c:	2acb883a 	add	r5,r5,r11
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    IPH_TOS_SET(iphdr, tos);
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
    4760:	2a8b883a 	add	r5,r5,r10
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, htons(p->tot_len));
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
    4764:	2a4b883a 	add	r5,r5,r9
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
    IPH_ID_SET(iphdr, htons(ip_id));
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
    4768:	2a0b883a 	add	r5,r5,r8
      /* src cannot be NULL here */
      ip_addr_copy(iphdr->src, *src);
    }

#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
    476c:	28c7883a 	add	r3,r5,r3
    chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
    4770:	1909883a 	add	r4,r3,r4
    chk_sum = (chk_sum >> 16) + (chk_sum & 0xFFFF);
    4774:	2006d43a 	srli	r3,r4,16
    4778:	213fffcc 	andi	r4,r4,65535
    477c:	20c7883a 	add	r3,r4,r3
    chk_sum = (chk_sum >> 16) + chk_sum;
    4780:	1808d43a 	srli	r4,r3,16
    4784:	20c7883a 	add	r3,r4,r3
    chk_sum = ~chk_sum;
    4788:	00c6303a 	nor	r3,zero,r3
    iphdr->_chksum = chk_sum; /* network order */
    478c:	10c0028d 	sth	r3,10(r2)
    4790:	00000706 	br	47b0 <ip_output_if+0x19c>
#endif
#endif /* CHECKSUM_GEN_IP_INLINE */
  } else {
    /* IP header already included in p */
    iphdr = (struct ip_hdr *)p->payload;
    ip_addr_copy(dest_addr, iphdr->dest);
    4794:	20800117 	ldw	r2,4(r4)
    dest = &dest_addr;
    4798:	d80d883a 	mov	r6,sp
#endif
#endif /* CHECKSUM_GEN_IP_INLINE */
  } else {
    /* IP header already included in p */
    iphdr = (struct ip_hdr *)p->payload;
    ip_addr_copy(dest_addr, iphdr->dest);
    479c:	10c0048b 	ldhu	r3,18(r2)
    47a0:	1080040b 	ldhu	r2,16(r2)
    47a4:	1806943a 	slli	r3,r3,16
    47a8:	1884b03a 	or	r2,r3,r2
    47ac:	d8800015 	stw	r2,0(sp)
    dest = &dest_addr;
  }

  IP_STATS_INC(ip.xmit);
    47b0:	00c001f4 	movhi	r3,7
    47b4:	18d44804 	addi	r3,r3,20768
    47b8:	1900120b 	ldhu	r4,72(r3)
  }
#endif /* LWIP_IGMP */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
    47bc:	8880090b 	ldhu	r2,36(r17)
    iphdr = (struct ip_hdr *)p->payload;
    ip_addr_copy(dest_addr, iphdr->dest);
    dest = &dest_addr;
  }

  IP_STATS_INC(ip.xmit);
    47c0:	21000044 	addi	r4,r4,1
    47c4:	1900120d 	sth	r4,72(r3)
  }
#endif /* LWIP_IGMP */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
    47c8:	10000226 	beq	r2,zero,47d4 <ip_output_if+0x1c0>
    47cc:	80c0020b 	ldhu	r3,8(r16)
    47d0:	10c01036 	bltu	r2,r3,4814 <ip_output_if+0x200>
    return ip_frag(p, netif, dest);
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
  return netif->output(netif, p, dest);
    47d4:	88800517 	ldw	r2,20(r17)
    47d8:	8809883a 	mov	r4,r17
    47dc:	800b883a 	mov	r5,r16
    47e0:	103ee83a 	callr	r2
}
    47e4:	dfc00b17 	ldw	ra,44(sp)
    47e8:	df000a17 	ldw	fp,40(sp)
    47ec:	ddc00917 	ldw	r23,36(sp)
    47f0:	dd800817 	ldw	r22,32(sp)
    47f4:	dd400717 	ldw	r21,28(sp)
    47f8:	dd000617 	ldw	r20,24(sp)
    47fc:	dcc00517 	ldw	r19,20(sp)
    4800:	dc800417 	ldw	r18,16(sp)
    4804:	dc400317 	ldw	r17,12(sp)
    4808:	dc000217 	ldw	r16,8(sp)
    480c:	dec00c04 	addi	sp,sp,48
    4810:	f800283a 	ret
#endif /* LWIP_IGMP */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
    return ip_frag(p, netif, dest);
    4814:	8009883a 	mov	r4,r16
    4818:	880b883a 	mov	r5,r17
    481c:	000575c0 	call	575c <ip_frag>
    4820:	003ff006 	br	47e4 <ip_output_if+0x1d0>

    if (ip_addr_isany(src)) {
      ip_addr_copy(iphdr->src, netif->ip_addr);
    } else {
      /* src cannot be NULL here */
      ip_addr_copy(iphdr->src, *src);
    4824:	1808d43a 	srli	r4,r3,16
    4828:	18ffffcc 	andi	r3,r3,65535
    482c:	10c0030d 	sth	r3,12(r2)
    4830:	1100038d 	sth	r4,14(r2)
    4834:	003fc806 	br	4758 <ip_output_if+0x144>
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = (struct ip_hdr *)p->payload;
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
    4838:	010000b4 	movhi	r4,2
    483c:	210d4b04 	addi	r4,r4,13612
    4840:	014000b4 	movhi	r5,2
    4844:	2952c004 	addi	r5,r5,19200
    4848:	0180b284 	movi	r6,714
    484c:	01c000b4 	movhi	r7,2
    4850:	39d2ba04 	addi	r7,r7,19176
    4854:	00104380 	call	10438 <printf>
    4858:	003fff06 	br	4858 <ip_output_if+0x244>
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
    485c:	00c001f4 	movhi	r3,7
    4860:	18d44804 	addi	r3,r3,20768
    4864:	1900170b 	ldhu	r4,92(r3)
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    4868:	00bfff84 	movi	r2,-2
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
    486c:	21000044 	addi	r4,r4,1
    4870:	1900170d 	sth	r4,92(r3)
    4874:	003fdb06 	br	47e4 <ip_output_if+0x1d0>

00004878 <ip_output>:
{
  struct netif *netif;

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);
    4878:	2080038b 	ldhu	r2,14(r4)
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
    487c:	defff604 	addi	sp,sp,-40
    4880:	dcc00815 	stw	r19,32(sp)
    4884:	dc800715 	stw	r18,28(sp)
    4888:	dc400615 	stw	r17,24(sp)
    488c:	dc000515 	stw	r16,20(sp)
    4890:	dfc00915 	stw	ra,36(sp)
  struct netif *netif;

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);
    4894:	00c00044 	movi	r3,1
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
    4898:	2021883a 	mov	r16,r4
    489c:	3827883a 	mov	r19,r7
    48a0:	dc800a03 	ldbu	r18,40(sp)
    48a4:	dc400b03 	ldbu	r17,44(sp)
  struct netif *netif;

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);
    48a8:	10c00926 	beq	r2,r3,48d0 <ip_output+0x58>
    48ac:	010000b4 	movhi	r4,2
    48b0:	210d4b04 	addi	r4,r4,13612
    48b4:	014000b4 	movhi	r5,2
    48b8:	2952b704 	addi	r5,r5,19164
    48bc:	0180ce44 	movi	r6,825
    48c0:	01c000b4 	movhi	r7,2
    48c4:	39d2ba04 	addi	r7,r7,19176
    48c8:	00104380 	call	10438 <printf>
    48cc:	003fff06 	br	48cc <ip_output+0x54>

  if ((netif = ip_route(dest)) == NULL) {
    48d0:	3009883a 	mov	r4,r6
    48d4:	d9400315 	stw	r5,12(sp)
    48d8:	d9800415 	stw	r6,16(sp)
    48dc:	000427c0 	call	427c <ip_route>
    48e0:	d9400317 	ldw	r5,12(sp)
    48e4:	d9800417 	ldw	r6,16(sp)
    48e8:	10000f26 	beq	r2,zero,4928 <ip_output+0xb0>
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
    48ec:	94803fcc 	andi	r18,r18,255
    48f0:	8c403fcc 	andi	r17,r17,255
    48f4:	dc800015 	stw	r18,0(sp)
    48f8:	dc400115 	stw	r17,4(sp)
    48fc:	d8800215 	stw	r2,8(sp)
    4900:	8009883a 	mov	r4,r16
    4904:	99c03fcc 	andi	r7,r19,255
    4908:	00046140 	call	4614 <ip_output_if>
}
    490c:	dfc00917 	ldw	ra,36(sp)
    4910:	dcc00817 	ldw	r19,32(sp)
    4914:	dc800717 	ldw	r18,28(sp)
    4918:	dc400617 	ldw	r17,24(sp)
    491c:	dc000517 	ldw	r16,20(sp)
    4920:	dec00a04 	addi	sp,sp,40
    4924:	f800283a 	ret
  LWIP_ASSERT("p->ref == 1", p->ref == 1);

  if ((netif = ip_route(dest)) == NULL) {
    LWIP_DEBUGF(IP_DEBUG, ("ip_output: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
    4928:	00c001f4 	movhi	r3,7
    492c:	18d44804 	addi	r3,r3,20768
    4930:	1900158b 	ldhu	r4,86(r3)
    return ERR_RTE;
    4934:	00bfff04 	movi	r2,-4
  LWIP_ASSERT("p->ref == 1", p->ref == 1);

  if ((netif = ip_route(dest)) == NULL) {
    LWIP_DEBUGF(IP_DEBUG, ("ip_output: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
    4938:	21000044 	addi	r4,r4,1
    493c:	1900158d 	sth	r4,86(r3)
    return ERR_RTE;
    4940:	003ff206 	br	490c <ip_output+0x94>

00004944 <ip4_addr_isbroadcast>:
{
  ip_addr_t ipaddr;
  ip4_addr_set_u32(&ipaddr, addr);

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
    4944:	20bfffc4 	addi	r2,r4,-1
    4948:	00ffff44 	movi	r3,-3
    494c:	18800f36 	bltu	r3,r2,498c <ip4_addr_isbroadcast+0x48>
      (addr == IPADDR_ANY)) {
    return 1;
  /* no broadcast support on this network interface? */
  } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
    4950:	28800b43 	ldbu	r2,45(r5)
    4954:	1080008c 	andi	r2,r2,2
    4958:	10803fcc 	andi	r2,r2,255
    495c:	10000926 	beq	r2,zero,4984 <ip4_addr_isbroadcast+0x40>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  } else if (addr == ip4_addr_get_u32(&netif->ip_addr)) {
    4960:	28800117 	ldw	r2,4(r5)
    4964:	11000726 	beq	r2,r4,4984 <ip4_addr_isbroadcast+0x40>
    return 0;
  /*  on the same (sub) network... */
  } else if (ip_addr_netcmp(&ipaddr, &(netif->ip_addr), &(netif->netmask))
    4968:	28c00217 	ldw	r3,8(r5)
    496c:	2084f03a 	xor	r2,r4,r2
    4970:	10c4703a 	and	r2,r2,r3
    4974:	1000031e 	bne	r2,zero,4984 <ip4_addr_isbroadcast+0x40>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr & ~ip4_addr_get_u32(&netif->netmask)) ==
    4978:	00c6303a 	nor	r3,zero,r3
    497c:	20c8703a 	and	r4,r4,r3
    4980:	19000226 	beq	r3,r4,498c <ip4_addr_isbroadcast+0x48>
    return 1;
  /* no broadcast support on this network interface? */
  } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
    4984:	0005883a 	mov	r2,zero
    /* => network broadcast address */
    return 1;
  } else {
    return 0;
  }
}
    4988:	f800283a 	ret
  ip4_addr_set_u32(&ipaddr, addr);

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
      (addr == IPADDR_ANY)) {
    return 1;
    498c:	00800044 	movi	r2,1
    4990:	f800283a 	ret

00004994 <ip4_addr_netmask_valid>:
 */
u8_t
ip4_addr_netmask_valid(u32_t netmask)
{
  u32_t mask;
  u32_t nm_hostorder = lwip_htonl(netmask);
    4994:	2006d63a 	srli	r3,r4,24
    4998:	200a963a 	slli	r5,r4,24
    499c:	2004d23a 	srli	r2,r4,8
    49a0:	213fc00c 	andi	r4,r4,65280
    49a4:	2008923a 	slli	r4,r4,8
    49a8:	28cab03a 	or	r5,r5,r3
    49ac:	10bfc00c 	andi	r2,r2,65280
    49b0:	288ab03a 	or	r5,r5,r2
    49b4:	290ab03a 	or	r5,r5,r4
    49b8:	00c00804 	movi	r3,32

  /* first, check for the first zero */
  for (mask = 1UL << 31 ; mask != 0; mask >>= 1) {
    49bc:	00a00034 	movhi	r2,32768
    49c0:	00000206 	br	49cc <ip4_addr_netmask_valid+0x38>
    49c4:	1004d07a 	srli	r2,r2,1
    49c8:	18000926 	beq	r3,zero,49f0 <ip4_addr_netmask_valid+0x5c>
    if ((nm_hostorder & mask) == 0) {
    49cc:	1148703a 	and	r4,r2,r5
    49d0:	18ffffc4 	addi	r3,r3,-1
    49d4:	203ffb1e 	bne	r4,zero,49c4 <ip4_addr_netmask_valid+0x30>
      break;
    }
  }
  /* then check that there is no one */
  for (; mask != 0; mask >>= 1) {
    49d8:	1000021e 	bne	r2,zero,49e4 <ip4_addr_netmask_valid+0x50>
    49dc:	00000406 	br	49f0 <ip4_addr_netmask_valid+0x5c>
    if ((nm_hostorder & mask) != 0) {
    49e0:	1800051e 	bne	r3,zero,49f8 <ip4_addr_netmask_valid+0x64>
    if ((nm_hostorder & mask) == 0) {
      break;
    }
  }
  /* then check that there is no one */
  for (; mask != 0; mask >>= 1) {
    49e4:	1004d07a 	srli	r2,r2,1
    if ((nm_hostorder & mask) != 0) {
    49e8:	2886703a 	and	r3,r5,r2
    if ((nm_hostorder & mask) == 0) {
      break;
    }
  }
  /* then check that there is no one */
  for (; mask != 0; mask >>= 1) {
    49ec:	103ffc1e 	bne	r2,zero,49e0 <ip4_addr_netmask_valid+0x4c>
      /* there is a one after the first zero -> invalid */
      return 0;
    }
  }
  /* no one after the first zero -> valid */
  return 1;
    49f0:	00800044 	movi	r2,1
    49f4:	f800283a 	ret
  }
  /* then check that there is no one */
  for (; mask != 0; mask >>= 1) {
    if ((nm_hostorder & mask) != 0) {
      /* there is a one after the first zero -> invalid */
      return 0;
    49f8:	0005883a 	mov	r2,zero
    }
  }
  /* no one after the first zero -> valid */
  return 1;
}
    49fc:	f800283a 	ret

00004a00 <ipaddr_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
ipaddr_aton(const char *cp, ip_addr_t *addr)
{
    4a00:	defff604 	addi	sp,sp,-40
    4a04:	dfc00915 	stw	ra,36(sp)
    4a08:	dd000815 	stw	r20,32(sp)
    4a0c:	dcc00715 	stw	r19,28(sp)
    4a10:	dc800615 	stw	r18,24(sp)
    4a14:	dc400515 	stw	r17,20(sp)
    4a18:	dc000415 	stw	r16,16(sp)
  u8_t base;
  char c;
  u32_t parts[4];
  u32_t *pp = parts;

  c = *cp;
    4a1c:	20800003 	ldbu	r2,0(r4)
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
    4a20:	02800244 	movi	r10,9
    4a24:	d81f883a 	mov	r15,sp
    4a28:	11fff404 	addi	r7,r2,-48
    4a2c:	38c03fcc 	andi	r3,r7,255
    4a30:	50c03b36 	bltu	r10,r3,4b20 <ipaddr_aton+0x120>
      return (0);
    val = 0;
    base = 10;
    if (c == '0') {
    4a34:	04800c04 	movi	r18,48
      c = *++cp;
      if (c == 'x' || c == 'X') {
    4a38:	04c01e04 	movi	r19,120
    4a3c:	05001604 	movi	r20,88
    }
    for (;;) {
      if (isdigit(c)) {
        val = (val * base) + (int)(c - '0');
        c = *++cp;
      } else if (base == 16 && isxdigit(c)) {
    4a40:	03000404 	movi	r12,16
    4a44:	03400144 	movi	r13,5
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
    4a48:	03800644 	movi	r14,25
        c = *++cp;
      } else
        break;
    }
    if (c == '.') {
    4a4c:	04400b84 	movi	r17,46
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
ipaddr_aton(const char *cp, ip_addr_t *addr)
    4a50:	dc000304 	addi	r16,sp,12
     */
    if (!isdigit(c))
      return (0);
    val = 0;
    base = 10;
    if (c == '0') {
    4a54:	11803fcc 	andi	r6,r2,255
    4a58:	3180201c 	xori	r6,r6,128
    4a5c:	31bfe004 	addi	r6,r6,-128
    4a60:	34803826 	beq	r6,r18,4b44 <ipaddr_aton+0x144>
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
      return (0);
    val = 0;
    base = 10;
    4a64:	02c00284 	movi	r11,10
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
ipaddr_aton(const char *cp, ip_addr_t *addr)
    4a68:	20c00044 	addi	r3,r4,1
    4a6c:	1809883a 	mov	r4,r3
    4a70:	0011883a 	mov	r8,zero
    4a74:	5ac03fcc 	andi	r11,r11,255
    4a78:	00000a06 	br	4aa4 <ipaddr_aton+0xa4>
      } else
        base = 8;
    }
    for (;;) {
      if (isdigit(c)) {
        val = (val * base) + (int)(c - '0');
    4a7c:	42d1383a 	mul	r8,r8,r11
        c = *++cp;
    4a80:	20800003 	ldbu	r2,0(r4)
      } else
        base = 8;
    }
    for (;;) {
      if (isdigit(c)) {
        val = (val * base) + (int)(c - '0');
    4a84:	4191883a 	add	r8,r8,r6
    4a88:	423ff404 	addi	r8,r8,-48
    4a8c:	11803fcc 	andi	r6,r2,255
    4a90:	3180201c 	xori	r6,r6,128
    4a94:	18c00044 	addi	r3,r3,1
    4a98:	21000044 	addi	r4,r4,1
    4a9c:	11fff404 	addi	r7,r2,-48
    4aa0:	31bfe004 	addi	r6,r6,-128
        c = *++cp;
      } else
        base = 8;
    }
    for (;;) {
      if (isdigit(c)) {
    4aa4:	39c03fcc 	andi	r7,r7,255
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
ipaddr_aton(const char *cp, ip_addr_t *addr)
    4aa8:	1a7fffc4 	addi	r9,r3,-1
        c = *++cp;
      } else
        base = 8;
    }
    for (;;) {
      if (isdigit(c)) {
    4aac:	51fff32e 	bgeu	r10,r7,4a7c <ipaddr_aton+0x7c>
        val = (val * base) + (int)(c - '0');
        c = *++cp;
      } else if (base == 16 && isxdigit(c)) {
    4ab0:	5b00121e 	bne	r11,r12,4afc <ipaddr_aton+0xfc>
    4ab4:	11ffe7c4 	addi	r7,r2,-97
    4ab8:	39c03fcc 	andi	r7,r7,255
    4abc:	69c00b2e 	bgeu	r13,r7,4aec <ipaddr_aton+0xec>
    4ac0:	10bfefc4 	addi	r2,r2,-65
    4ac4:	10803fcc 	andi	r2,r2,255
    4ac8:	68800c36 	bltu	r13,r2,4afc <ipaddr_aton+0xfc>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
    4acc:	4010913a 	slli	r8,r8,4
    4ad0:	31800284 	addi	r6,r6,10
    4ad4:	71c0072e 	bgeu	r14,r7,4af4 <ipaddr_aton+0xf4>
    4ad8:	00801044 	movi	r2,65
    4adc:	308dc83a 	sub	r6,r6,r2
    4ae0:	3210b03a 	or	r8,r6,r8
        c = *++cp;
    4ae4:	20800003 	ldbu	r2,0(r4)
    4ae8:	003fe806 	br	4a8c <ipaddr_aton+0x8c>
    for (;;) {
      if (isdigit(c)) {
        val = (val * base) + (int)(c - '0');
        c = *++cp;
      } else if (base == 16 && isxdigit(c)) {
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
    4aec:	4010913a 	slli	r8,r8,4
    4af0:	31800284 	addi	r6,r6,10
    4af4:	00801844 	movi	r2,97
    4af8:	003ff806 	br	4adc <ipaddr_aton+0xdc>
        c = *++cp;
      } else
        break;
    }
    if (c == '.') {
    4afc:	3440231e 	bne	r6,r17,4b8c <ipaddr_aton+0x18c>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3) {
    4b00:	7c000726 	beq	r15,r16,4b20 <ipaddr_aton+0x120>
        return (0);
      }
      *pp++ = val;
    4b04:	7a000015 	stw	r8,0(r15)
      c = *++cp;
    4b08:	48800043 	ldbu	r2,1(r9)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3) {
        return (0);
      }
      *pp++ = val;
    4b0c:	7bc00104 	addi	r15,r15,4
      c = *++cp;
    4b10:	49000044 	addi	r4,r9,1
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
    4b14:	11fff404 	addi	r7,r2,-48
    4b18:	38c03fcc 	andi	r3,r7,255
    4b1c:	50ffcd2e 	bgeu	r10,r3,4a54 <ipaddr_aton+0x54>
   * the number of parts specified.
   */
  switch (pp - parts + 1) {

  case 0:
    return (0);       /* initial nondigit */
    4b20:	0005883a 	mov	r2,zero
  }
  if (addr) {
    ip4_addr_set_u32(addr, htonl(val));
  }
  return (1);
}
    4b24:	dfc00917 	ldw	ra,36(sp)
    4b28:	dd000817 	ldw	r20,32(sp)
    4b2c:	dcc00717 	ldw	r19,28(sp)
    4b30:	dc800617 	ldw	r18,24(sp)
    4b34:	dc400517 	ldw	r17,20(sp)
    4b38:	dc000417 	ldw	r16,16(sp)
    4b3c:	dec00a04 	addi	sp,sp,40
    4b40:	f800283a 	ret
    if (!isdigit(c))
      return (0);
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
    4b44:	20800043 	ldbu	r2,1(r4)
      if (c == 'x' || c == 'X') {
    4b48:	11803fcc 	andi	r6,r2,255
    4b4c:	3180201c 	xori	r6,r6,128
    4b50:	31bfe004 	addi	r6,r6,-128
    4b54:	34c00526 	beq	r6,r19,4b6c <ipaddr_aton+0x16c>
    4b58:	35000426 	beq	r6,r20,4b6c <ipaddr_aton+0x16c>
    if (!isdigit(c))
      return (0);
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
    4b5c:	21000044 	addi	r4,r4,1
      if (c == 'x' || c == 'X') {
        base = 16;
        c = *++cp;
      } else
        base = 8;
    4b60:	02c00204 	movi	r11,8
    4b64:	11fff404 	addi	r7,r2,-48
    4b68:	003fbf06 	br	4a68 <ipaddr_aton+0x68>
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
        base = 16;
        c = *++cp;
    4b6c:	20800083 	ldbu	r2,2(r4)
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
        base = 16;
    4b70:	02c00404 	movi	r11,16
        c = *++cp;
    4b74:	21000084 	addi	r4,r4,2
    4b78:	11803fcc 	andi	r6,r2,255
    4b7c:	3180201c 	xori	r6,r6,128
    4b80:	11fff404 	addi	r7,r2,-48
    4b84:	31bfe004 	addi	r6,r6,-128
    4b88:	003fb706 	br	4a68 <ipaddr_aton+0x68>
    4b8c:	00800344 	movi	r2,13
    4b90:	11801016 	blt	r2,r6,4bd4 <ipaddr_aton+0x1d4>
    4b94:	00800244 	movi	r2,9
    4b98:	30801d16 	blt	r6,r2,4c10 <ipaddr_aton+0x210>
  }
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  switch (pp - parts + 1) {
    4b9c:	7ec5c83a 	sub	r2,r15,sp
    4ba0:	1005d0ba 	srai	r2,r2,2
    4ba4:	00c00104 	movi	r3,4
    4ba8:	10800044 	addi	r2,r2,1
    4bac:	18800c2e 	bgeu	r3,r2,4be0 <ipaddr_aton+0x1e0>
      return (0);
    }
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
    break;
  default:
    LWIP_ASSERT("unhandled", 0);
    4bb0:	010000b4 	movhi	r4,2
    4bb4:	210d4b04 	addi	r4,r4,13612
    4bb8:	014000b4 	movhi	r5,2
    4bbc:	2952cc04 	addi	r5,r5,19248
    4bc0:	01803cc4 	movi	r6,243
    4bc4:	01c000b4 	movhi	r7,2
    4bc8:	39d2cf04 	addi	r7,r7,19260
    4bcc:	00104380 	call	10438 <printf>
    4bd0:	003fff06 	br	4bd0 <ipaddr_aton+0x1d0>
    4bd4:	00800804 	movi	r2,32
    4bd8:	30bfd11e 	bne	r6,r2,4b20 <ipaddr_aton+0x120>
    4bdc:	003fef06 	br	4b9c <ipaddr_aton+0x19c>
  }
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  switch (pp - parts + 1) {
    4be0:	1085883a 	add	r2,r2,r2
    4be4:	1085883a 	add	r2,r2,r2
    4be8:	00c00034 	movhi	r3,0
    4bec:	18d2ff04 	addi	r3,r3,19452
    4bf0:	10c5883a 	add	r2,r2,r3
    4bf4:	10800017 	ldw	r2,0(r2)
    4bf8:	1000683a 	jmp	r2
    4bfc:	00004b20 	cmpeqi	zero,zero,300
    4c00:	00004c38 	rdprs	zero,zero,304
    4c04:	00004c9c 	xori	zero,zero,306
    4c08:	00004c18 	cmpnei	zero,zero,304
    4c0c:	00004c6c 	andhi	zero,zero,305
    4c10:	303fe226 	beq	r6,zero,4b9c <ipaddr_aton+0x19c>
    4c14:	003fc206 	br	4b20 <ipaddr_aton+0x120>
    }
    val |= parts[0] << 24;
    break;

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff) {
    4c18:	00bfffd4 	movui	r2,65535
    4c1c:	123fc036 	bltu	r2,r8,4b20 <ipaddr_aton+0x120>
      return (0);
    }
    val |= (parts[0] << 24) | (parts[1] << 16);
    4c20:	d8c00117 	ldw	r3,4(sp)
    4c24:	d8800017 	ldw	r2,0(sp)
    4c28:	1806943a 	slli	r3,r3,16
    4c2c:	1004963a 	slli	r2,r2,24
    4c30:	1884b03a 	or	r2,r3,r2
    4c34:	1210b03a 	or	r8,r2,r8
    break;
  default:
    LWIP_ASSERT("unhandled", 0);
    break;
  }
  if (addr) {
    4c38:	28001f26 	beq	r5,zero,4cb8 <ipaddr_aton+0x2b8>
    ip4_addr_set_u32(addr, htonl(val));
    4c3c:	400c963a 	slli	r6,r8,24
    4c40:	4008d63a 	srli	r4,r8,24
    4c44:	4006d23a 	srli	r3,r8,8
    4c48:	40bfc00c 	andi	r2,r8,65280
    4c4c:	1004923a 	slli	r2,r2,8
    4c50:	3108b03a 	or	r4,r6,r4
    4c54:	18ffc00c 	andi	r3,r3,65280
    4c58:	20c6b03a 	or	r3,r4,r3
    4c5c:	1884b03a 	or	r2,r3,r2
    4c60:	28800015 	stw	r2,0(r5)
  }
  return (1);
    4c64:	00800044 	movi	r2,1
    4c68:	003fae06 	br	4b24 <ipaddr_aton+0x124>
    }
    val |= (parts[0] << 24) | (parts[1] << 16);
    break;

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff) {
    4c6c:	00803fc4 	movi	r2,255
    4c70:	123fab36 	bltu	r2,r8,4b20 <ipaddr_aton+0x120>
      return (0);
    }
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
    4c74:	d9000117 	ldw	r4,4(sp)
    4c78:	d8c00017 	ldw	r3,0(sp)
    4c7c:	d8800217 	ldw	r2,8(sp)
    4c80:	2008943a 	slli	r4,r4,16
    4c84:	1806963a 	slli	r3,r3,24
    4c88:	1004923a 	slli	r2,r2,8
    4c8c:	20c6b03a 	or	r3,r4,r3
    4c90:	1884b03a 	or	r2,r3,r2
    4c94:	1210b03a 	or	r8,r2,r8
    break;
    4c98:	003fe706 	br	4c38 <ipaddr_aton+0x238>

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL) {
    4c9c:	00804034 	movhi	r2,256
    4ca0:	10bfffc4 	addi	r2,r2,-1
    4ca4:	123f9e36 	bltu	r2,r8,4b20 <ipaddr_aton+0x120>
      return (0);
    }
    val |= parts[0] << 24;
    4ca8:	d8800017 	ldw	r2,0(sp)
    4cac:	1004963a 	slli	r2,r2,24
    4cb0:	4090b03a 	or	r8,r8,r2
    break;
    4cb4:	003fe006 	br	4c38 <ipaddr_aton+0x238>
    break;
  }
  if (addr) {
    ip4_addr_set_u32(addr, htonl(val));
  }
  return (1);
    4cb8:	00800044 	movi	r2,1
    4cbc:	003f9906 	br	4b24 <ipaddr_aton+0x124>

00004cc0 <ipaddr_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
ipaddr_addr(const char *cp)
{
    4cc0:	defffe04 	addi	sp,sp,-8
  ip_addr_t val;

  if (ipaddr_aton(cp, &val)) {
    4cc4:	d80b883a 	mov	r5,sp
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
ipaddr_addr(const char *cp)
{
    4cc8:	dfc00115 	stw	ra,4(sp)
  ip_addr_t val;

  if (ipaddr_aton(cp, &val)) {
    4ccc:	0004a000 	call	4a00 <ipaddr_aton>
    4cd0:	1000041e 	bne	r2,zero,4ce4 <ipaddr_addr+0x24>
    return ip4_addr_get_u32(&val);
  }
  return (IPADDR_NONE);
    4cd4:	00bfffc4 	movi	r2,-1
}
    4cd8:	dfc00117 	ldw	ra,4(sp)
    4cdc:	dec00204 	addi	sp,sp,8
    4ce0:	f800283a 	ret
ipaddr_addr(const char *cp)
{
  ip_addr_t val;

  if (ipaddr_aton(cp, &val)) {
    return ip4_addr_get_u32(&val);
    4ce4:	d8800017 	ldw	r2,0(sp)
  }
  return (IPADDR_NONE);
}
    4ce8:	dfc00117 	ldw	ra,4(sp)
    4cec:	dec00204 	addi	sp,sp,8
    4cf0:	f800283a 	ret

00004cf4 <ipaddr_ntoa_r>:
  u8_t rem;
  u8_t n;
  u8_t i;
  int len = 0;

  s_addr = ip4_addr_get_u32(addr);
    4cf4:	20c00017 	ldw	r3,0(r4)
 * @param buflen length of buf
 * @return either pointer to buf which now holds the ASCII
 *         representation of addr or NULL if buf was too small
 */
char *ipaddr_ntoa_r(const ip_addr_t *addr, char *buf, int buflen)
{
    4cf8:	defffd04 	addi	sp,sp,-12
    4cfc:	dc000215 	stw	r16,8(sp)
    4d00:	2805883a 	mov	r2,r5
  u8_t rem;
  u8_t n;
  u8_t i;
  int len = 0;

  s_addr = ip4_addr_get_u32(addr);
    4d04:	d8c00015 	stw	r3,0(sp)
  char *rp;
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;
  int len = 0;
    4d08:	0021883a 	mov	r16,zero

  s_addr = ip4_addr_get_u32(addr);

  rp = buf;
    4d0c:	2807883a 	mov	r3,r5
  ap = (u8_t *)&s_addr;
    4d10:	d81f883a 	mov	r15,sp
    4d14:	dac00104 	addi	r11,sp,4
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
    4d18:	03800284 	movi	r14,10
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--) {
    4d1c:	03403fc4 	movi	r13,255
      *rp++ = inv[i];
    }
    if (len++ >= buflen) {
      return NULL;
    }
    *rp++ = '.';
    4d20:	01400b84 	movi	r5,46
  int len = 0;

  s_addr = ip4_addr_get_u32(addr);

  rp = buf;
  ap = (u8_t *)&s_addr;
    4d24:	000f883a 	mov	r7,zero
    4d28:	79000003 	ldbu	r4,0(r15)
    4d2c:	00000106 	br	4d34 <ipaddr_ntoa_r+0x40>
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    4d30:	500f883a 	mov	r7,r10
  rp = buf;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
    4d34:	2393203a 	divu	r9,r4,r14
    4d38:	4a0002a4 	muli	r8,r9,10
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    4d3c:	3b003fcc 	andi	r12,r7,255
    4d40:	5b19883a 	add	r12,r11,r12
  rp = buf;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
    4d44:	2211c83a 	sub	r8,r4,r8
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    4d48:	42000c04 	addi	r8,r8,48
    4d4c:	62000005 	stb	r8,0(r12)
    } while(*ap);
    4d50:	4809883a 	mov	r4,r9
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    4d54:	3a800044 	addi	r10,r7,1
    } while(*ap);
    4d58:	203ff51e 	bne	r4,zero,4d30 <ipaddr_ntoa_r+0x3c>
    4d5c:	78000005 	stb	zero,0(r15)
    while(i--) {
    4d60:	52403fcc 	andi	r9,r10,255
    4d64:	48001d26 	beq	r9,zero,4ddc <ipaddr_ntoa_r+0xe8>
      if (len++ >= buflen) {
    4d68:	82400044 	addi	r9,r16,1
    4d6c:	8180170e 	bge	r16,r6,4dcc <ipaddr_ntoa_r+0xd8>
 * @param buf target buffer where the string is stored
 * @param buflen length of buf
 * @return either pointer to buf which now holds the ASCII
 *         representation of addr or NULL if buf was too small
 */
char *ipaddr_ntoa_r(const ip_addr_t *addr, char *buf, int buflen)
    4d70:	3415c83a 	sub	r10,r6,r16
    4d74:	39ffffc4 	addi	r7,r7,-1
    4d78:	1a95883a 	add	r10,r3,r10
    4d7c:	00000406 	br	4d90 <ipaddr_ntoa_r+0x9c>
    4d80:	39ffffc4 	addi	r7,r7,-1
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--) {
      if (len++ >= buflen) {
    4d84:	4a400044 	addi	r9,r9,1
    4d88:	1a801026 	beq	r3,r10,4dcc <ipaddr_ntoa_r+0xd8>
    4d8c:	42000003 	ldbu	r8,0(r8)
        return NULL;
      }
      *rp++ = inv[i];
    4d90:	1a000005 	stb	r8,0(r3)
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--) {
    4d94:	39003fcc 	andi	r4,r7,255
    4d98:	5911883a 	add	r8,r11,r4
      if (len++ >= buflen) {
        return NULL;
      }
      *rp++ = inv[i];
    4d9c:	18c00044 	addi	r3,r3,1
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--) {
    4da0:	237ff71e 	bne	r4,r13,4d80 <ipaddr_ntoa_r+0x8c>
      if (len++ >= buflen) {
        return NULL;
      }
      *rp++ = inv[i];
    }
    if (len++ >= buflen) {
    4da4:	4c000044 	addi	r16,r9,1
    4da8:	4980080e 	bge	r9,r6,4dcc <ipaddr_ntoa_r+0xd8>
      return NULL;
    }
    *rp++ = '.';
    4dac:	19400005 	stb	r5,0(r3)
    ap++;
    4db0:	7bc00044 	addi	r15,r15,1
      *rp++ = inv[i];
    }
    if (len++ >= buflen) {
      return NULL;
    }
    *rp++ = '.';
    4db4:	18c00044 	addi	r3,r3,1

  s_addr = ip4_addr_get_u32(addr);

  rp = buf;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    4db8:	7affda1e 	bne	r15,r11,4d24 <ipaddr_ntoa_r+0x30>
      return NULL;
    }
    *rp++ = '.';
    ap++;
  }
  *--rp = 0;
    4dbc:	183fffc5 	stb	zero,-1(r3)
  return buf;
}
    4dc0:	dc000217 	ldw	r16,8(sp)
    4dc4:	dec00304 	addi	sp,sp,12
    4dc8:	f800283a 	ret
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--) {
      if (len++ >= buflen) {
        return NULL;
    4dcc:	0005883a 	mov	r2,zero
    *rp++ = '.';
    ap++;
  }
  *--rp = 0;
  return buf;
}
    4dd0:	dc000217 	ldw	r16,8(sp)
    4dd4:	dec00304 	addi	sp,sp,12
    4dd8:	f800283a 	ret
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--) {
    4ddc:	8013883a 	mov	r9,r16
    4de0:	003ff006 	br	4da4 <ipaddr_ntoa_r+0xb0>

00004de4 <ipaddr_ntoa>:
 */
char *
ipaddr_ntoa(const ip_addr_t *addr)
{
  static char str[16];
  return ipaddr_ntoa_r(addr, str, 16);
    4de4:	014000f4 	movhi	r5,3
    4de8:	2972c704 	addi	r5,r5,-13540
    4dec:	01800404 	movi	r6,16
    4df0:	0004cf41 	jmpi	4cf4 <ipaddr_ntoa_r>

00004df4 <ip_reass_dequeue_datagram>:
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
    4df4:	d0e8b117 	ldw	r3,-23868(gp)
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
    4df8:	deffff04 	addi	sp,sp,-4
    4dfc:	dfc00015 	stw	ra,0(sp)
    4e00:	2005883a 	mov	r2,r4
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
    4e04:	19000826 	beq	r3,r4,4e28 <ip_reass_dequeue_datagram+0x34>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    4e08:	28000e26 	beq	r5,zero,4e44 <ip_reass_dequeue_datagram+0x50>
    prev->next = ipr->next;
    4e0c:	20c00017 	ldw	r3,0(r4)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
    4e10:	01000144 	movi	r4,5
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    prev->next = ipr->next;
    4e14:	28c00015 	stw	r3,0(r5)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
    4e18:	100b883a 	mov	r5,r2
}
    4e1c:	dfc00017 	ldw	ra,0(sp)
    4e20:	dec00104 	addi	sp,sp,4
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    prev->next = ipr->next;
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
    4e24:	000618c1 	jmpi	618c <memp_free>
{
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
    /* it was the first in the list */
    reassdatagrams = ipr->next;
    4e28:	20c00017 	ldw	r3,0(r4)
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    prev->next = ipr->next;
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
    4e2c:	100b883a 	mov	r5,r2
    4e30:	01000144 	movi	r4,5
{
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
    /* it was the first in the list */
    reassdatagrams = ipr->next;
    4e34:	d0e8b115 	stw	r3,-23868(gp)
    prev->next = ipr->next;
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
}
    4e38:	dfc00017 	ldw	ra,0(sp)
    4e3c:	dec00104 	addi	sp,sp,4
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    prev->next = ipr->next;
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
    4e40:	000618c1 	jmpi	618c <memp_free>
  if (reassdatagrams == ipr) {
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    4e44:	010000b4 	movhi	r4,2
    4e48:	210d4b04 	addi	r4,r4,13612
    4e4c:	014000b4 	movhi	r5,2
    4e50:	2952d704 	addi	r5,r5,19292
    4e54:	01804e44 	movi	r6,313
    4e58:	01c000b4 	movhi	r7,2
    4e5c:	39d2de04 	addi	r7,r7,19320
    4e60:	00104380 	call	10438 <printf>
    4e64:	003fff06 	br	4e64 <ip_reass_dequeue_datagram+0x70>

00004e68 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
    4e68:	defff904 	addi	sp,sp,-28
    4e6c:	dcc00315 	stw	r19,12(sp)
    4e70:	dc400115 	stw	r17,4(sp)
    4e74:	dfc00615 	stw	ra,24(sp)
    4e78:	dd400515 	stw	r21,20(sp)
    4e7c:	dd000415 	stw	r20,16(sp)
    4e80:	dc800215 	stw	r18,8(sp)
    4e84:	dc000015 	stw	r16,0(sp)
    4e88:	2023883a 	mov	r17,r4
    4e8c:	2827883a 	mov	r19,r5
  u16_t pbufs_freed = 0;
  u8_t clen;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
    4e90:	29002d26 	beq	r5,r4,4f48 <ip_reass_free_complete_datagram+0xe0>
  if (prev != NULL) {
    4e94:	28000b26 	beq	r5,zero,4ec4 <ip_reass_free_complete_datagram+0x5c>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
    4e98:	28800017 	ldw	r2,0(r5)
    4e9c:	11000926 	beq	r2,r4,4ec4 <ip_reass_free_complete_datagram+0x5c>
    4ea0:	010000b4 	movhi	r4,2
    4ea4:	210d4b04 	addi	r4,r4,13612
    4ea8:	014000b4 	movhi	r5,2
    4eac:	2952e904 	addi	r5,r5,19364
    4eb0:	018029c4 	movi	r6,167
    4eb4:	01c000b4 	movhi	r7,2
    4eb8:	39d2de04 	addi	r7,r7,19320
    4ebc:	00104380 	call	10438 <printf>
    4ec0:	003fff06 	br	4ec0 <ip_reass_free_complete_datagram+0x58>
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
    4ec4:	8c000117 	ldw	r16,4(r17)
    4ec8:	81000117 	ldw	r4,4(r16)
  if (iprh->start == 0) {
    4ecc:	2080010b 	ldhu	r2,4(r4)
    4ed0:	10002626 	beq	r2,zero,4f6c <ip_reass_free_complete_datagram+0x104>
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  u16_t pbufs_freed = 0;
    4ed4:	0025883a 	mov	r18,zero
    iprh = (struct ip_reass_helper *)p->payload;
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
    clen = pbuf_clen(pcur);
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    4ed8:	053fffd4 	movui	r20,65535
    4edc:	00000306 	br	4eec <ip_reass_free_complete_datagram+0x84>
    pbufs_freed += clen;
    4ee0:	14a5883a 	add	r18,r2,r18
    pbuf_free(pcur);
    4ee4:	00067d80 	call	67d8 <pbuf_free>
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
    4ee8:	a8003226 	beq	r21,zero,4fb4 <ip_reass_free_complete_datagram+0x14c>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
    4eec:	80800117 	ldw	r2,4(r16)
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
    clen = pbuf_clen(pcur);
    4ef0:	8009883a 	mov	r4,r16
  while (p != NULL) {
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
    4ef4:	1540008b 	ldhu	r21,2(r2)
    4ef8:	1080000b 	ldhu	r2,0(r2)
    4efc:	a82a943a 	slli	r21,r21,16
    4f00:	a8aab03a 	or	r21,r21,r2
    clen = pbuf_clen(pcur);
    4f04:	0006dd40 	call	6dd4 <pbuf_clen>
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    4f08:	913fffcc 	andi	r4,r18,65535
    4f0c:	10c03fcc 	andi	r3,r2,255
    4f10:	20c7883a 	add	r3,r4,r3
    pbufs_freed += clen;
    4f14:	10803fcc 	andi	r2,r2,255
    pbuf_free(pcur);
    4f18:	8009883a 	mov	r4,r16
  while (p != NULL) {
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
    4f1c:	a821883a 	mov	r16,r21
    clen = pbuf_clen(pcur);
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    4f20:	a0ffef0e 	bge	r20,r3,4ee0 <ip_reass_free_complete_datagram+0x78>
    4f24:	010000b4 	movhi	r4,2
    4f28:	210d4b04 	addi	r4,r4,13612
    4f2c:	014000b4 	movhi	r5,2
    4f30:	2952ee04 	addi	r5,r5,19384
    4f34:	01803184 	movi	r6,198
    4f38:	01c000b4 	movhi	r7,2
    4f3c:	39d2de04 	addi	r7,r7,19320
    4f40:	00104380 	call	10438 <printf>
    4f44:	003fff06 	br	4f44 <ip_reass_free_complete_datagram+0xdc>
  u16_t pbufs_freed = 0;
  u8_t clen;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
    4f48:	010000b4 	movhi	r4,2
    4f4c:	210d4b04 	addi	r4,r4,13612
    4f50:	014000b4 	movhi	r5,2
    4f54:	2952e604 	addi	r5,r5,19352
    4f58:	01802944 	movi	r6,165
    4f5c:	01c000b4 	movhi	r7,2
    4f60:	39d2de04 	addi	r7,r7,19320
    4f64:	00104380 	call	10438 <printf>
    4f68:	003fff06 	br	4f68 <ip_reass_free_complete_datagram+0x100>
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  if (iprh->start == 0) {
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    ipr->p = iprh->next_pbuf;
    4f6c:	20c0008b 	ldhu	r3,2(r4)
    4f70:	2080000b 	ldhu	r2,0(r4)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
    4f74:	01800504 	movi	r6,20
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  if (iprh->start == 0) {
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    ipr->p = iprh->next_pbuf;
    4f78:	1806943a 	slli	r3,r3,16
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
    4f7c:	89400204 	addi	r5,r17,8
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  if (iprh->start == 0) {
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    ipr->p = iprh->next_pbuf;
    4f80:	1884b03a 	or	r2,r3,r2
    4f84:	88800115 	stw	r2,4(r17)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
    4f88:	00102380 	call	10238 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
    4f8c:	8009883a 	mov	r4,r16
    4f90:	01400044 	movi	r5,1
    4f94:	0003db40 	call	3db4 <icmp_time_exceeded>
    clen = pbuf_clen(p);
    4f98:	8009883a 	mov	r4,r16
    4f9c:	0006dd40 	call	6dd4 <pbuf_clen>
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
    pbuf_free(p);
    4fa0:	8009883a 	mov	r4,r16
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
    icmp_time_exceeded(p, ICMP_TE_FRAG);
    clen = pbuf_clen(p);
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
    4fa4:	14803fcc 	andi	r18,r2,255
    pbuf_free(p);
    4fa8:	00067d80 	call	67d8 <pbuf_free>
    4fac:	8c000117 	ldw	r16,4(r17)
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
    4fb0:	803fc91e 	bne	r16,zero,4ed8 <ip_reass_free_complete_datagram+0x70>
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
    pbuf_free(pcur);
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
    4fb4:	8809883a 	mov	r4,r17
    4fb8:	980b883a 	mov	r5,r19
    4fbc:	0004df40 	call	4df4 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
    4fc0:	d0e8b20b 	ldhu	r3,-23864(gp)
    4fc4:	90bfffcc 	andi	r2,r18,65535
    4fc8:	193fffcc 	andi	r4,r3,65535
    4fcc:	20800b36 	bltu	r4,r2,4ffc <ip_reass_free_complete_datagram+0x194>
  ip_reass_pbufcount -= pbufs_freed;
    4fd0:	1c87c83a 	sub	r3,r3,r18
    4fd4:	d0e8b20d 	sth	r3,-23864(gp)

  return pbufs_freed;
}
    4fd8:	dfc00617 	ldw	ra,24(sp)
    4fdc:	dd400517 	ldw	r21,20(sp)
    4fe0:	dd000417 	ldw	r20,16(sp)
    4fe4:	dcc00317 	ldw	r19,12(sp)
    4fe8:	dc800217 	ldw	r18,8(sp)
    4fec:	dc400117 	ldw	r17,4(sp)
    4ff0:	dc000017 	ldw	r16,0(sp)
    4ff4:	dec00704 	addi	sp,sp,28
    4ff8:	f800283a 	ret
    pbufs_freed += clen;
    pbuf_free(pcur);
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
    4ffc:	010000b4 	movhi	r4,2
    5000:	210d4b04 	addi	r4,r4,13612
    5004:	014000b4 	movhi	r5,2
    5008:	2952f604 	addi	r5,r5,19416
    500c:	01803304 	movi	r6,204
    5010:	01c000b4 	movhi	r7,2
    5014:	39d2de04 	addi	r7,r7,19320
    5018:	00104380 	call	10438 <printf>
    501c:	003fff06 	br	501c <ip_reass_free_complete_datagram+0x1b4>

00005020 <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
    5020:	defffa04 	addi	sp,sp,-24
    5024:	dd000415 	stw	r20,16(sp)
    5028:	dcc00315 	stw	r19,12(sp)
    502c:	dc800215 	stw	r18,8(sp)
    5030:	dc400115 	stw	r17,4(sp)
    5034:	dfc00515 	stw	ra,20(sp)
    5038:	dc000015 	stw	r16,0(sp)
    503c:	2027883a 	mov	r19,r4
    5040:	2823883a 	mov	r17,r5
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
    5044:	0029883a 	mov	r20,zero
    }
    if (oldest != NULL) {
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
      pbufs_freed += pbufs_freed_current;
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
    5048:	04800044 	movi	r18,1
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    504c:	d0e8b117 	ldw	r3,-23868(gp)
    while (r != NULL) {
    5050:	18002726 	beq	r3,zero,50f0 <ip_reass_remove_oldest_datagram+0xd0>
    5054:	9a00038b 	ldhu	r8,14(r19)
    5058:	9880030b 	ldhu	r2,12(r19)
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
    505c:	19800517 	ldw	r6,20(r3)
    5060:	4010943a 	slli	r8,r8,16
  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    5064:	0021883a 	mov	r16,zero

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    5068:	000b883a 	mov	r5,zero
    506c:	4090b03a 	or	r8,r8,r2
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    5070:	0009883a 	mov	r4,zero
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
    5074:	32000b26 	beq	r6,r8,50a4 <ip_reass_remove_oldest_datagram+0x84>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
    5078:	84000044 	addi	r16,r16,1
        if (oldest == NULL) {
    507c:	20001426 	beq	r4,zero,50d0 <ip_reass_remove_oldest_datagram+0xb0>
          oldest = r;
        } else if (r->timer <= oldest->timer) {
    5080:	198007c3 	ldbu	r6,31(r3)
    5084:	21c007c3 	ldbu	r7,31(r4)
    5088:	3980112e 	bgeu	r7,r6,50d0 <ip_reass_remove_oldest_datagram+0xb0>
          /* older than the previous oldest */
          oldest = r;
        }
      }
      if (r->next != NULL) {
    508c:	19800017 	ldw	r6,0(r3)
    5090:	30001226 	beq	r6,zero,50dc <ip_reass_remove_oldest_datagram+0xbc>
    5094:	180b883a 	mov	r5,r3
    5098:	3007883a 	mov	r3,r6
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
    509c:	19800517 	ldw	r6,20(r3)
    50a0:	323ff51e 	bne	r6,r8,5078 <ip_reass_remove_oldest_datagram+0x58>
    50a4:	9980048b 	ldhu	r6,18(r19)
    50a8:	9a40040b 	ldhu	r9,16(r19)
    50ac:	19c00617 	ldw	r7,24(r3)
    50b0:	300c943a 	slli	r6,r6,16
    50b4:	324cb03a 	or	r6,r6,r9
    50b8:	39bfef1e 	bne	r7,r6,5078 <ip_reass_remove_oldest_datagram+0x58>
    50bc:	1980030b 	ldhu	r6,12(r3)
    50c0:	9880010b 	ldhu	r2,4(r19)
    50c4:	30bff126 	beq	r6,r2,508c <ip_reass_remove_oldest_datagram+0x6c>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
    50c8:	84000044 	addi	r16,r16,1
        if (oldest == NULL) {
    50cc:	203fec1e 	bne	r4,zero,5080 <ip_reass_remove_oldest_datagram+0x60>
        } else if (r->timer <= oldest->timer) {
          /* older than the previous oldest */
          oldest = r;
        }
      }
      if (r->next != NULL) {
    50d0:	19800017 	ldw	r6,0(r3)
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
        /* Not the same datagram as fraghdr */
        other_datagrams++;
        if (oldest == NULL) {
          oldest = r;
        } else if (r->timer <= oldest->timer) {
    50d4:	1809883a 	mov	r4,r3
          /* older than the previous oldest */
          oldest = r;
        }
      }
      if (r->next != NULL) {
    50d8:	303fee1e 	bne	r6,zero,5094 <ip_reass_remove_oldest_datagram+0x74>
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
    50dc:	20000226 	beq	r4,zero,50e8 <ip_reass_remove_oldest_datagram+0xc8>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
    50e0:	0004e680 	call	4e68 <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
    50e4:	a0a9883a 	add	r20,r20,r2
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
    50e8:	a440010e 	bge	r20,r17,50f0 <ip_reass_remove_oldest_datagram+0xd0>
    50ec:	943fd716 	blt	r18,r16,504c <ip_reass_remove_oldest_datagram+0x2c>
  return pbufs_freed;
}
    50f0:	a005883a 	mov	r2,r20
    50f4:	dfc00517 	ldw	ra,20(sp)
    50f8:	dd000417 	ldw	r20,16(sp)
    50fc:	dcc00317 	ldw	r19,12(sp)
    5100:	dc800217 	ldw	r18,8(sp)
    5104:	dc400117 	ldw	r17,4(sp)
    5108:	dc000017 	ldw	r16,0(sp)
    510c:	dec00604 	addi	sp,sp,24
    5110:	f800283a 	ret

00005114 <ip_reass_tmr>:
void
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
    5114:	d128b117 	ldw	r4,-23868(gp)
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
    5118:	defffd04 	addi	sp,sp,-12
    511c:	dc000015 	stw	r16,0(sp)
    5120:	dfc00215 	stw	ra,8(sp)
    5124:	dc400115 	stw	r17,4(sp)
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
    5128:	0021883a 	mov	r16,zero
    512c:	20000826 	beq	r4,zero,5150 <ip_reass_tmr+0x3c>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
    5130:	208007c3 	ldbu	r2,31(r4)
    5134:	10c03fcc 	andi	r3,r2,255
      r->timer--;
    5138:	10bfffc4 	addi	r2,r2,-1

  r = reassdatagrams;
  while (r != NULL) {
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
    513c:	18000926 	beq	r3,zero,5164 <ip_reass_tmr+0x50>
      r->timer--;
    5140:	208007c5 	stb	r2,31(r4)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
      r = r->next;
    5144:	2021883a 	mov	r16,r4
    5148:	21000017 	ldw	r4,0(r4)
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
    514c:	203ff81e 	bne	r4,zero,5130 <ip_reass_tmr+0x1c>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
    5150:	dfc00217 	ldw	ra,8(sp)
    5154:	dc400117 	ldw	r17,4(sp)
    5158:	dc000017 	ldw	r16,0(sp)
    515c:	dec00304 	addi	sp,sp,12
    5160:	f800283a 	ret
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
    5164:	24400017 	ldw	r17,0(r4)
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
    5168:	800b883a 	mov	r5,r16
    516c:	0004e680 	call	4e68 <ip_reass_free_complete_datagram>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
    5170:	8809883a 	mov	r4,r17
    5174:	003fed06 	br	512c <ip_reass_tmr+0x18>

00005178 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
    5178:	defff504 	addi	sp,sp,-44
    517c:	df000915 	stw	fp,36(sp)
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
    5180:	070001f4 	movhi	fp,7
    5184:	e7144804 	addi	fp,fp,20768
    5188:	e0800c8b 	ldhu	r2,50(fp)
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
    518c:	dc400215 	stw	r17,8(sp)
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
    5190:	24400117 	ldw	r17,4(r4)
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
    5194:	ddc00815 	stw	r23,32(sp)
    5198:	dfc00a15 	stw	ra,40(sp)
    519c:	dd800715 	stw	r22,28(sp)
    51a0:	dd400615 	stw	r21,24(sp)
    51a4:	dd000515 	stw	r20,20(sp)
    51a8:	dcc00415 	stw	r19,16(sp)
    51ac:	dc800315 	stw	r18,12(sp)
    51b0:	dc000115 	stw	r16,4(sp)
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
    51b4:	10800044 	addi	r2,r2,1
    51b8:	e0800c8d 	sth	r2,50(fp)
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
    51bc:	8c800003 	ldbu	r18,0(r17)
    51c0:	00c00504 	movi	r3,20
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
    51c4:	202f883a 	mov	r23,r4
  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
    51c8:	948003cc 	andi	r18,r18,15
    51cc:	90803fcc 	andi	r2,r18,255
    51d0:	1085883a 	add	r2,r2,r2
    51d4:	1085883a 	add	r2,r2,r2
    51d8:	10c09e1e 	bne	r2,r3,5454 <ip_reass+0x2dc>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    51dc:	8880018b 	ldhu	r2,6(r17)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    51e0:	8d80008b 	ldhu	r22,2(r17)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
    51e4:	04000284 	movi	r16,10
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    51e8:	d880000d 	sth	r2,0(sp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
    51ec:	0006dd40 	call	6dd4 <pbuf_clen>
    51f0:	1029883a 	mov	r20,r2
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
    51f4:	d0a8b20b 	ldhu	r2,-23864(gp)
    51f8:	a5403fcc 	andi	r21,r20,255
    51fc:	1545883a 	add	r2,r2,r21
    5200:	8080aa16 	blt	r16,r2,54ac <ip_reass+0x334>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
    5204:	d428b117 	ldw	r16,-23868(gp)
    5208:	80002b26 	beq	r16,zero,52b8 <ip_reass+0x140>
    520c:	88c0038b 	ldhu	r3,14(r17)
    5210:	8880030b 	ldhu	r2,12(r17)
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
    5214:	0027883a 	mov	r19,zero
    5218:	1806943a 	slli	r3,r3,16
    521c:	1884b03a 	or	r2,r3,r2
    5220:	00000406 	br	5234 <ip_reass+0xbc>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
    5224:	80c00017 	ldw	r3,0(r16)
    5228:	8027883a 	mov	r19,r16
    522c:	18002326 	beq	r3,zero,52bc <ip_reass+0x144>
    5230:	1821883a 	mov	r16,r3
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
    5234:	80c00517 	ldw	r3,20(r16)
    5238:	18bffa1e 	bne	r3,r2,5224 <ip_reass+0xac>
    523c:	88c0048b 	ldhu	r3,18(r17)
    5240:	8980040b 	ldhu	r6,16(r17)
    5244:	81000617 	ldw	r4,24(r16)
    5248:	1806943a 	slli	r3,r3,16
    524c:	1986b03a 	or	r3,r3,r6
    5250:	20fff41e 	bne	r4,r3,5224 <ip_reass+0xac>
    5254:	8100030b 	ldhu	r4,12(r16)
    5258:	88c0010b 	ldhu	r3,4(r17)
    525c:	20fff11e 	bne	r4,r3,5224 <ip_reass+0xac>
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
    5260:	8880018b 	ldhu	r2,6(r17)
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
        ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
    5264:	e140118b 	ldhu	r5,70(fp)
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
    5268:	10ffffcc 	andi	r3,r2,65535
    526c:	1808923a 	slli	r4,r3,8
    5270:	1806d23a 	srli	r3,r3,8
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
        ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
    5274:	29400044 	addi	r5,r5,1
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
    5278:	2107c00c 	andi	r4,r4,7936
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
        ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
    527c:	e140118d 	sth	r5,70(fp)
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
    5280:	20c6b03a 	or	r3,r4,r3
    5284:	18001f1e 	bne	r3,zero,5304 <ip_reass+0x18c>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
    5288:	80c0038b 	ldhu	r3,14(r16)
    528c:	1808923a 	slli	r4,r3,8
    5290:	1806d23a 	srli	r3,r3,8
    5294:	2107c00c 	andi	r4,r4,7936
    5298:	20c6b03a 	or	r3,r4,r3
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
    529c:	18001926 	beq	r3,zero,5304 <ip_reass+0x18c>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
    52a0:	81000204 	addi	r4,r16,8
    52a4:	880b883a 	mov	r5,r17
    52a8:	01800504 	movi	r6,20
    52ac:	00102380 	call	10238 <memcpy>
    52b0:	8880018b 	ldhu	r2,6(r17)
    52b4:	00001306 	br	5304 <ip_reass+0x18c>
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
    52b8:	0027883a 	mov	r19,zero
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
    52bc:	01000144 	movi	r4,5
    52c0:	00060a40 	call	60a4 <memp_malloc>
    52c4:	1021883a 	mov	r16,r2
  if (ipr == NULL) {
    52c8:	10008026 	beq	r2,zero,54cc <ip_reass+0x354>
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
    52cc:	8009883a 	mov	r4,r16
    52d0:	000b883a 	mov	r5,zero
    52d4:	01800804 	movi	r6,32
    52d8:	00103300 	call	10330 <memset>
  ipr->timer = IP_REASS_MAXAGE;
    52dc:	008000c4 	movi	r2,3
    52e0:	808007c5 	stb	r2,31(r16)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
    52e4:	d0a8b117 	ldw	r2,-23868(gp)
  reassdatagrams = ipr;
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
    52e8:	81000204 	addi	r4,r16,8
    52ec:	880b883a 	mov	r5,r17
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  ipr->timer = IP_REASS_MAXAGE;

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
    52f0:	80800015 	stw	r2,0(r16)
  reassdatagrams = ipr;
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
    52f4:	01800504 	movi	r6,20
  memset(ipr, 0, sizeof(struct ip_reassdata));
  ipr->timer = IP_REASS_MAXAGE;

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  reassdatagrams = ipr;
    52f8:	d428b115 	stw	r16,-23868(gp)
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
    52fc:	00102380 	call	10238 <memcpy>
    5300:	8880018b 	ldhu	r2,6(r17)
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
    5304:	d0e8b20b 	ldhu	r3,-23864(gp)
    5308:	a4403fcc 	andi	r17,r20,255

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
    530c:	1080080c 	andi	r2,r2,32
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
    5310:	88e3883a 	add	r17,r17,r3
    5314:	d468b20d 	sth	r17,-23864(gp)

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
    5318:	10bfffcc 	andi	r2,r2,65535
    531c:	1000121e 	bne	r2,zero,5368 <ip_reass+0x1f0>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    5320:	dd40000b 	ldhu	r21,0(sp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    5324:	b5bfffcc 	andi	r22,r22,65535
    5328:	b00a923a 	slli	r5,r22,8
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    532c:	a804923a 	slli	r2,r21,8
    5330:	a82ad23a 	srli	r21,r21,8
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    5334:	b02cd23a 	srli	r22,r22,8
    5338:	91003fcc 	andi	r4,r18,255
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    533c:	1087c00c 	andi	r2,r2,7936
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    5340:	213fff24 	muli	r4,r4,-4
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    5344:	1544b03a 	or	r2,r2,r21
  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
    5348:	80c00783 	ldbu	r3,30(r16)
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    534c:	100490fa 	slli	r2,r2,3
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    5350:	2d8ab03a 	or	r5,r5,r22
    5354:	2909883a 	add	r4,r5,r4
  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
    5358:	18c00054 	ori	r3,r3,1
    ipr->datagram_len = offset + len;
    535c:	2085883a 	add	r2,r4,r2
  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
    5360:	80c00785 	stb	r3,30(r16)
    ipr->datagram_len = offset + len;
    5364:	8080070d 	sth	r2,28(r16)
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
    5368:	b9400117 	ldw	r5,4(r23)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    536c:	28c0018b 	ldhu	r3,6(r5)
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    5370:	2880008b 	ldhu	r2,2(r5)
    5374:	29000003 	ldbu	r4,0(r5)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    5378:	180e923a 	slli	r7,r3,8
    537c:	1806d23a 	srli	r3,r3,8
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    5380:	100c923a 	slli	r6,r2,8
    5384:	210003cc 	andi	r4,r4,15
    5388:	1004d23a 	srli	r2,r2,8
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    538c:	39c7c00c 	andi	r7,r7,7936
    5390:	38ceb03a 	or	r7,r7,r3
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    5394:	213fff24 	muli	r4,r4,-4
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    5398:	380e90fa 	slli	r7,r7,3
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    539c:	3084b03a 	or	r2,r6,r2
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  iprh->next_pbuf = NULL;
    53a0:	2800000d 	sth	zero,0(r5)
    53a4:	2800008d 	sth	zero,2(r5)
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    53a8:	80c00117 	ldw	r3,4(r16)
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    53ac:	1105883a 	add	r2,r2,r4
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  iprh->next_pbuf = NULL;
  iprh->start = offset;
  iprh->end = offset + len;
    53b0:	11c5883a 	add	r2,r2,r7
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  iprh->next_pbuf = NULL;
  iprh->start = offset;
    53b4:	29c0010d 	sth	r7,4(r5)
  iprh->end = offset + len;
    53b8:	2880018d 	sth	r2,6(r5)
    53bc:	1015883a 	mov	r10,r2

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    53c0:	18008926 	beq	r3,zero,55e8 <ip_reass+0x470>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
    53c4:	18800117 	ldw	r2,4(r3)
    if (iprh->start < iprh_tmp->start) {
    53c8:	39ffffcc 	andi	r7,r7,65535
    53cc:	1100010b 	ldhu	r4,4(r2)
    53d0:	39008b36 	bltu	r7,r4,5600 <ip_reass+0x488>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
    53d4:	39004526 	beq	r7,r4,54ec <ip_reass+0x374>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
    53d8:	10c0018b 	ldhu	r3,6(r2)
    53dc:	38c04336 	bltu	r7,r3,54ec <ip_reass+0x374>
    53e0:	02400044 	movi	r9,1
           * and the previous fragment */
          valid = 0;
        }
      }
    }
    q = iprh_tmp->next_pbuf;
    53e4:	1200008b 	ldhu	r8,2(r2)
    53e8:	10c0000b 	ldhu	r3,0(r2)
    53ec:	4010943a 	slli	r8,r8,16
    53f0:	40d0b03a 	or	r8,r8,r3
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    53f4:	40000f26 	beq	r8,zero,5434 <ip_reass+0x2bc>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
    53f8:	41800117 	ldw	r6,4(r8)
    if (iprh->start < iprh_tmp->start) {
    53fc:	30c0010b 	ldhu	r3,4(r6)
    5400:	38c04336 	bltu	r7,r3,5510 <ip_reass+0x398>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
    5404:	38c03926 	beq	r7,r3,54ec <ip_reass+0x374>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
    5408:	3100018b 	ldhu	r4,6(r6)
    540c:	39003736 	bltu	r7,r4,54ec <ip_reass+0x374>
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
        if (iprh_prev->end != iprh_tmp->start) {
    5410:	1100018b 	ldhu	r4,6(r2)
      break;
    } else if(iprh->start == iprh_tmp->start) {
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
    5414:	3005883a 	mov	r2,r6
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
        if (iprh_prev->end != iprh_tmp->start) {
    5418:	193ff226 	beq	r3,r4,53e4 <ip_reass+0x26c>
           * and the previous fragment */
          valid = 0;
        }
      }
    }
    q = iprh_tmp->next_pbuf;
    541c:	1200008b 	ldhu	r8,2(r2)
    5420:	10c0000b 	ldhu	r3,0(r2)
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
        if (iprh_prev->end != iprh_tmp->start) {
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
    5424:	0013883a 	mov	r9,zero
        }
      }
    }
    q = iprh_tmp->next_pbuf;
    5428:	4010943a 	slli	r8,r8,16
    542c:	40d0b03a 	or	r8,r8,r3
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    5430:	403ff11e 	bne	r8,zero,53f8 <ip_reass+0x280>
  if (q == NULL) {
    if (iprh_prev != NULL) {
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
    5434:	10c0018b 	ldhu	r3,6(r2)
    5438:	38c07736 	bltu	r7,r3,5618 <ip_reass+0x4a0>
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
    543c:	b808d43a 	srli	r4,r23,16
    5440:	15c0000d 	sth	r23,0(r2)
    5444:	1100008d 	sth	r4,2(r2)
      if (iprh_prev->end != iprh->start) {
    5448:	38c03b26 	beq	r7,r3,5538 <ip_reass+0x3c0>
    /* Return the pbuf chain */
    return p;
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
    544c:	0029883a 	mov	r20,zero
    5450:	00000906 	br	5478 <ip_reass+0x300>

  fraghdr = (struct ip_hdr*)p->payload;

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    5454:	e080110b 	ldhu	r2,68(fp)
    5458:	10800044 	addi	r2,r2,1
    545c:	e080110d 	sth	r2,68(fp)
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
    5460:	e0800d8b 	ldhu	r2,54(fp)
  pbuf_free(p);
    5464:	b809883a 	mov	r4,r23
  return NULL;
    5468:	0029883a 	mov	r20,zero
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
    546c:	10800044 	addi	r2,r2,1
    5470:	e0800d8d 	sth	r2,54(fp)
  pbuf_free(p);
    5474:	00067d80 	call	67d8 <pbuf_free>
  return NULL;
}
    5478:	a005883a 	mov	r2,r20
    547c:	dfc00a17 	ldw	ra,40(sp)
    5480:	df000917 	ldw	fp,36(sp)
    5484:	ddc00817 	ldw	r23,32(sp)
    5488:	dd800717 	ldw	r22,28(sp)
    548c:	dd400617 	ldw	r21,24(sp)
    5490:	dd000517 	ldw	r20,20(sp)
    5494:	dcc00417 	ldw	r19,16(sp)
    5498:	dc800317 	ldw	r18,12(sp)
    549c:	dc400217 	ldw	r17,8(sp)
    54a0:	dc000117 	ldw	r16,4(sp)
    54a4:	dec00b04 	addi	sp,sp,44
    54a8:	f800283a 	ret

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
    54ac:	8809883a 	mov	r4,r17
    54b0:	a80b883a 	mov	r5,r21
    54b4:	00050200 	call	5020 <ip_reass_remove_oldest_datagram>
    54b8:	10000826 	beq	r2,zero,54dc <ip_reass+0x364>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
    54bc:	d0a8b20b 	ldhu	r2,-23864(gp)
    54c0:	a885883a 	add	r2,r21,r2

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
    54c4:	80bf4f0e 	bge	r16,r2,5204 <ip_reass+0x8c>
    54c8:	00000406 	br	54dc <ip_reass+0x364>
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
  if (ipr == NULL) {
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
    54cc:	8809883a 	mov	r4,r17
    54d0:	a80b883a 	mov	r5,r21
    54d4:	00050200 	call	5020 <ip_reass_remove_oldest_datagram>
    54d8:	1540580e 	bge	r2,r21,563c <ip_reass+0x4c4>
      ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
    }
    if (ipr == NULL)
#endif /* IP_REASS_FREE_OLDEST */
    {
      IPFRAG_STATS_INC(ip_frag.memerr);
    54dc:	e0800f0b 	ldhu	r2,60(fp)
    54e0:	10800044 	addi	r2,r2,1
    54e4:	e0800f0d 	sth	r2,60(fp)
    54e8:	003fdd06 	br	5460 <ip_reass+0x2e8>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
    54ec:	b809883a 	mov	r4,r23
    54f0:	0006dd40 	call	6dd4 <pbuf_clen>
    54f4:	10803fcc 	andi	r2,r2,255
    54f8:	88a3c83a 	sub	r17,r17,r2
  pbuf_free(new_p);
    54fc:	b809883a 	mov	r4,r23
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
    5500:	d468b20d 	sth	r17,-23864(gp)
    /* Return the pbuf chain */
    return p;
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
    5504:	0029883a 	mov	r20,zero
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
  pbuf_free(new_p);
    5508:	00067d80 	call	67d8 <pbuf_free>
    550c:	003fda06 	br	5478 <ip_reass+0x300>
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
    if (iprh->start < iprh_tmp->start) {
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
    5510:	4008d43a 	srli	r4,r8,16
    5514:	2a00000d 	sth	r8,0(r5)
    5518:	2900008d 	sth	r4,2(r5)
      if (iprh_prev != NULL) {
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
    551c:	1100018b 	ldhu	r4,6(r2)
    5520:	393ff236 	bltu	r7,r4,54ec <ip_reass+0x374>
    5524:	52bfffcc 	andi	r10,r10,65535
    5528:	1abff036 	bltu	r3,r10,54ec <ip_reass+0x374>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
    552c:	b806d43a 	srli	r3,r23,16
    5530:	15c0000d 	sth	r23,0(r2)
    5534:	10c0008d 	sth	r3,2(r2)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
    5538:	80800783 	ldbu	r2,30(r16)
    553c:	1080004c 	andi	r2,r2,1
    5540:	103fc226 	beq	r2,zero,544c <ip_reass+0x2d4>
    /* and had no wholes so far */
    if (valid) {
    5544:	483fc126 	beq	r9,zero,544c <ip_reass+0x2d4>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
    5548:	80800117 	ldw	r2,4(r16)
    554c:	14800117 	ldw	r18,4(r2)
    5550:	9080010b 	ldhu	r2,4(r18)
    5554:	103fbd1e 	bne	r2,zero,544c <ip_reass+0x2d4>
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
    5558:	28c0008b 	ldhu	r3,2(r5)
    555c:	2880000b 	ldhu	r2,0(r5)
    5560:	1806943a 	slli	r3,r3,16
    5564:	1884b03a 	or	r2,r3,r2
        while (q != NULL) {
    5568:	10001026 	beq	r2,zero,55ac <ip_reass+0x434>
          iprh = (struct ip_reass_helper*)q->payload;
    556c:	10800117 	ldw	r2,4(r2)
          if (iprh_prev->end != iprh->start) {
    5570:	2900018b 	ldhu	r4,6(r5)
    5574:	10c0010b 	ldhu	r3,4(r2)
    5578:	20c00626 	beq	r4,r3,5594 <ip_reass+0x41c>
    557c:	003fb306 	br	544c <ip_reass+0x2d4>
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
    5580:	18c00117 	ldw	r3,4(r3)
          if (iprh_prev->end != iprh->start) {
    5584:	1140018b 	ldhu	r5,6(r2)
    5588:	1900010b 	ldhu	r4,4(r3)
    558c:	1805883a 	mov	r2,r3
    5590:	293fae1e 	bne	r5,r4,544c <ip_reass+0x2d4>
            valid = 0;
            break;
          }
          iprh_prev = iprh;
          q = iprh->next_pbuf;
    5594:	1100008b 	ldhu	r4,2(r2)
    5598:	10c0000b 	ldhu	r3,0(r2)
    559c:	2008943a 	slli	r4,r4,16
    55a0:	20c6b03a 	or	r3,r4,r3
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
    55a4:	183ff61e 	bne	r3,zero,5580 <ip_reass+0x408>
    55a8:	100b883a 	mov	r5,r2
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
          LWIP_ASSERT("sanity check",
    55ac:	91406226 	beq	r18,r5,5738 <ip_reass+0x5c0>
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
    55b0:	28c0008b 	ldhu	r3,2(r5)
    55b4:	2880000b 	ldhu	r2,0(r5)
    55b8:	1806943a 	slli	r3,r3,16
    55bc:	1884b03a 	or	r2,r3,r2
    55c0:	10002326 	beq	r2,zero,5650 <ip_reass+0x4d8>
    55c4:	010000b4 	movhi	r4,2
    55c8:	210d4b04 	addi	r4,r4,13612
    55cc:	014000b4 	movhi	r5,2
    55d0:	29530904 	addi	r5,r5,19492
    55d4:	01807004 	movi	r6,448
    55d8:	01c000b4 	movhi	r7,2
    55dc:	39d2de04 	addi	r7,r7,19320
    55e0:	00104380 	call	10438 <printf>
    55e4:	003fff06 	br	55e4 <ip_reass+0x46c>
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
    55e8:	80800783 	ldbu	r2,30(r16)
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
    55ec:	85c00115 	stw	r23,4(r16)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
    55f0:	1080004c 	andi	r2,r2,1
    55f4:	103fd41e 	bne	r2,zero,5548 <ip_reass+0x3d0>
    /* Return the pbuf chain */
    return p;
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
    55f8:	0029883a 	mov	r20,zero
    55fc:	003f9e06 	br	5478 <ip_reass+0x300>
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
    if (iprh->start < iprh_tmp->start) {
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
    5600:	1804d43a 	srli	r2,r3,16
    5604:	28c0000d 	sth	r3,0(r5)
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
    5608:	02400044 	movi	r9,1
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
    if (iprh->start < iprh_tmp->start) {
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
    560c:	2880008d 	sth	r2,2(r5)
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
    5610:	85c00115 	stw	r23,4(r16)
    5614:	003fc806 	br	5538 <ip_reass+0x3c0>
  if (q == NULL) {
    if (iprh_prev != NULL) {
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
    5618:	010000b4 	movhi	r4,2
    561c:	210d4b04 	addi	r4,r4,13612
    5620:	014000b4 	movhi	r5,2
    5624:	2952fd04 	addi	r5,r5,19444
    5628:	018064c4 	movi	r6,403
    562c:	01c000b4 	movhi	r7,2
    5630:	39d2de04 	addi	r7,r7,19320
    5634:	00104380 	call	10438 <printf>
    5638:	003fff06 	br	5638 <ip_reass+0x4c0>
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
  if (ipr == NULL) {
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
      ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
    563c:	01000144 	movi	r4,5
    5640:	00060a40 	call	60a4 <memp_malloc>
    5644:	1021883a 	mov	r16,r2
    }
    if (ipr == NULL)
    5648:	103f201e 	bne	r2,zero,52cc <ip_reass+0x154>
    564c:	003fa306 	br	54dc <ip_reass+0x364>
          LWIP_ASSERT("sanity check", ipr->p != NULL);
          LWIP_ASSERT("sanity check",
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
    5650:	2880018b 	ldhu	r2,6(r5)
    5654:	80c0070b 	ldhu	r3,28(r16)
    5658:	113fffcc 	andi	r4,r2,65535
    565c:	20c00926 	beq	r4,r3,5684 <ip_reass+0x50c>
    5660:	010000b4 	movhi	r4,2
    5664:	210d4b04 	addi	r4,r4,13612
    5668:	014000b4 	movhi	r5,2
    566c:	29531204 	addi	r5,r5,19528
    5670:	01807084 	movi	r6,450
    5674:	01c000b4 	movhi	r7,2
    5678:	39d2de04 	addi	r7,r7,19320
    567c:	00104380 	call	10438 <printf>
    5680:	003fff06 	br	5680 <ip_reass+0x508>
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
    5684:	10800504 	addi	r2,r2,20
    5688:	8080070d 	sth	r2,28(r16)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
    568c:	9440008b 	ldhu	r17,2(r18)
    5690:	9080000b 	ldhu	r2,0(r18)

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
    5694:	9009883a 	mov	r4,r18
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
    5698:	8822943a 	slli	r17,r17,16

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
    569c:	81400204 	addi	r5,r16,8
    56a0:	01800504 	movi	r6,20
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
    56a4:	88a2b03a 	or	r17,r17,r2

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
    56a8:	00102380 	call	10238 <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
    56ac:	8080070b 	ldhu	r2,28(r16)
    IPH_OFFSET_SET(fraghdr, 0);
    IPH_CHKSUM_SET(fraghdr, 0);
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
    56b0:	9009883a 	mov	r4,r18

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
    IPH_OFFSET_SET(fraghdr, 0);
    56b4:	9000018d 	sth	zero,6(r18)
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
    56b8:	1006923a 	slli	r3,r2,8
    56bc:	1004d23a 	srli	r2,r2,8
    IPH_OFFSET_SET(fraghdr, 0);
    IPH_CHKSUM_SET(fraghdr, 0);
    56c0:	9000028d 	sth	zero,10(r18)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
    56c4:	01400504 	movi	r5,20
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
    56c8:	1884b03a 	or	r2,r3,r2
    56cc:	9080008d 	sth	r2,2(r18)
    IPH_OFFSET_SET(fraghdr, 0);
    IPH_CHKSUM_SET(fraghdr, 0);
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
    56d0:	00041840 	call	4184 <inet_chksum>
    56d4:	9080028d 	sth	r2,10(r18)

    p = ipr->p;
    56d8:	85000117 	ldw	r20,4(r16)

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
    56dc:	88000c26 	beq	r17,zero,5710 <ip_reass+0x598>
      iprh = (struct ip_reass_helper*)r->payload;
    56e0:	8c800117 	ldw	r18,4(r17)

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
    56e4:	8809883a 	mov	r4,r17
    56e8:	017ffb04 	movi	r5,-20
    56ec:	00066980 	call	6698 <pbuf_header>
      pbuf_cat(p, r);
    56f0:	880b883a 	mov	r5,r17
    56f4:	a009883a 	mov	r4,r20
    56f8:	0006e040 	call	6e04 <pbuf_cat>
      r = iprh->next_pbuf;
    56fc:	9440008b 	ldhu	r17,2(r18)
    5700:	90c0000b 	ldhu	r3,0(r18)
    5704:	8822943a 	slli	r17,r17,16
    5708:	88e2b03a 	or	r17,r17,r3
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
    570c:	883ff41e 	bne	r17,zero,56e0 <ip_reass+0x568>
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
    5710:	8009883a 	mov	r4,r16
    5714:	980b883a 	mov	r5,r19
    5718:	0004df40 	call	4df4 <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
    571c:	a009883a 	mov	r4,r20
    5720:	d428b20b 	ldhu	r16,-23864(gp)
    5724:	0006dd40 	call	6dd4 <pbuf_clen>
    5728:	10803fcc 	andi	r2,r2,255
    572c:	80a1c83a 	sub	r16,r16,r2
    5730:	d428b20d 	sth	r16,-23864(gp)

    /* Return the pbuf chain */
    return p;
    5734:	003f5006 	br	5478 <ip_reass+0x300>
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
          LWIP_ASSERT("sanity check",
    5738:	010000b4 	movhi	r4,2
    573c:	210d4b04 	addi	r4,r4,13612
    5740:	014000b4 	movhi	r5,2
    5744:	29530504 	addi	r5,r5,19476
    5748:	01806f84 	movi	r6,446
    574c:	01c000b4 	movhi	r7,2
    5750:	39d2de04 	addi	r7,r7,19320
    5754:	00104380 	call	10438 <printf>
    5758:	003fff06 	br	5758 <ip_reass+0x5e0>

0000575c <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, ip_addr_t *dest)
{
    575c:	deffec04 	addi	sp,sp,-80
    5760:	d9000215 	stw	r4,8(sp)
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
    5764:	01000084 	movi	r4,2
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, ip_addr_t *dest)
{
    5768:	dd000e15 	stw	r20,56(sp)
    576c:	d9800615 	stw	r6,24(sp)
    5770:	2829883a 	mov	r20,r5
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
    5774:	200d883a 	mov	r6,r4
    5778:	000b883a 	mov	r5,zero
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, ip_addr_t *dest)
{
    577c:	dc800c15 	stw	r18,48(sp)
    5780:	dfc01315 	stw	ra,76(sp)
    5784:	df001215 	stw	fp,72(sp)
    5788:	ddc01115 	stw	r23,68(sp)
    578c:	dd801015 	stw	r22,64(sp)
    5790:	dd400f15 	stw	r21,60(sp)
    5794:	dcc00d15 	stw	r19,52(sp)
    5798:	dc400b15 	stw	r17,44(sp)
    579c:	dc000a15 	stw	r16,40(sp)
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
    57a0:	a480090b 	ldhu	r18,36(r20)
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
    57a4:	0006a880 	call	6a88 <pbuf_alloc>
    57a8:	d8800115 	stw	r2,4(sp)
  if (rambuf == NULL) {
    57ac:	10008226 	beq	r2,zero,59b8 <ip_frag+0x25c>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
    57b0:	00bfff04 	movi	r2,-4
    57b4:	040000f4 	movhi	r16,3
    57b8:	8432cbc4 	addi	r16,r16,-13521
    57bc:	80a0703a 	and	r16,r16,r2
    57c0:	d8800117 	ldw	r2,4(sp)

  /* Copy the IP header in it */
  iphdr = (struct ip_hdr *)rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
    57c4:	d8c00217 	ldw	r3,8(sp)
    57c8:	8009883a 	mov	r4,r16
  if (rambuf == NULL) {
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
    57cc:	14000115 	stw	r16,4(r2)

  /* Copy the IP header in it */
  iphdr = (struct ip_hdr *)rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
    57d0:	19400117 	ldw	r5,4(r3)
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  if (rambuf == NULL) {
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
    57d4:	1480028d 	sth	r18,10(r2)
    57d8:	1480020d 	sth	r18,8(r2)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);

  /* Copy the IP header in it */
  iphdr = (struct ip_hdr *)rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
    57dc:	01800504 	movi	r6,20
    57e0:	00102380 	call	10238 <memcpy>
  original_iphdr = (struct ip_hdr *)p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
    57e4:	8080018b 	ldhu	r2,6(r16)
  ofo = tmp & IP_OFFMASK;
  omf = tmp & IP_MF;

  left = p->tot_len - IP_HLEN;
    57e8:	d8c00217 	ldw	r3,8(sp)

  nfb = (mtu - IP_HLEN) / 8;
    57ec:	94bfffcc 	andi	r18,r18,65535
  original_iphdr = (struct ip_hdr *)p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
    57f0:	1008923a 	slli	r4,r2,8
  ofo = tmp & IP_OFFMASK;
  omf = tmp & IP_MF;

  left = p->tot_len - IP_HLEN;
    57f4:	1c40020b 	ldhu	r17,8(r3)
  original_iphdr = (struct ip_hdr *)p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
    57f8:	1006d23a 	srli	r3,r2,8
  ofo = tmp & IP_OFFMASK;
  omf = tmp & IP_MF;

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;
    57fc:	90bffb04 	addi	r2,r18,-20
  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  ofo = tmp & IP_OFFMASK;
  omf = tmp & IP_MF;

  left = p->tot_len - IP_HLEN;
    5800:	8c7ffb04 	addi	r17,r17,-20
  original_iphdr = (struct ip_hdr *)p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
    5804:	20c6b03a 	or	r3,r4,r3
  ofo = tmp & IP_OFFMASK;
    5808:	1cc7ffcc 	andi	r19,r3,8191
  omf = tmp & IP_MF;
    580c:	18c8000c 	andi	r3,r3,8192
    5810:	d8c0030d 	sth	r3,12(sp)

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;
    5814:	10006616 	blt	r2,zero,59b0 <ip_frag+0x254>
    5818:	1005d0fa 	srai	r2,r2,3

  while (left) {
    581c:	88ffffcc 	andi	r3,r17,65535
  ofo = tmp & IP_OFFMASK;
  omf = tmp & IP_MF;

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;
    5820:	d880070d 	sth	r2,28(sp)

  while (left) {
    5824:	18004f26 	beq	r3,zero,5964 <ip_frag+0x208>
    if (!last) {
      tmp = tmp | IP_MF;
    }

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
    5828:	100490fa 	slli	r2,r2,3
    582c:	94bffb44 	addi	r18,r18,-19
    5830:	dc800415 	stw	r18,16(sp)
    5834:	d880080d 	sth	r2,32(sp)
    5838:	80800504 	addi	r2,r16,20
    583c:	d8800515 	stw	r2,20(sp)
    5840:	d880080b 	ldhu	r2,32(sp)
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
    5844:	04800504 	movi	r18,20
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
    if (header != NULL) {
      pbuf_chain(header, rambuf);
      netif->output(netif, header, dest);
      IPFRAG_STATS_INC(ip_frag.xmit);
    5848:	058001f4 	movhi	r22,7
    584c:	b5944804 	addi	r22,r22,20768
    5850:	d8800915 	stw	r2,36(sp)
    5854:	00003406 	br	5928 <ip_frag+0x1cc>
    if (!last) {
      tmp = tmp | IP_MF;
    }

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
    5858:	d8c0080b 	ldhu	r3,32(sp)
    last = (left <= mtu - IP_HLEN);

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last) {
      tmp = tmp | IP_MF;
    585c:	dd400917 	ldw	r21,36(sp)
    5860:	15c80014 	ori	r23,r2,8192
    }

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
    5864:	d8c0000d 	sth	r3,0(sp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
    5868:	d9000217 	ldw	r4,8(sp)
    586c:	d9400517 	ldw	r5,20(sp)
    5870:	91ffffcc 	andi	r7,r18,65535
    5874:	a80d883a 	mov	r6,r21
    5878:	00071bc0 	call	71bc <pbuf_copy_partial>
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
    587c:	a8c00504 	addi	r3,r21,20
    poff = newpbuflen;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    5880:	b93fffcc 	andi	r4,r23,65535
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
    5884:	19ffc00c 	andi	r7,r3,65280
    poff = newpbuflen;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    5888:	2012923a 	slli	r9,r4,8
    588c:	200cd23a 	srli	r6,r4,8
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
    5890:	380fd23a 	srai	r7,r7,8
    5894:	1806923a 	slli	r3,r3,8
    poff = newpbuflen;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    5898:	498cb03a 	or	r6,r9,r6
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
    IPH_CHKSUM_SET(iphdr, 0);
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    589c:	8009883a 	mov	r4,r16
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
    58a0:	38c6b03a 	or	r3,r7,r3
    IPH_CHKSUM_SET(iphdr, 0);
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    58a4:	01400504 	movi	r5,20
    poff = newpbuflen;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    58a8:	8180018d 	sth	r6,6(r16)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
    58ac:	80c0008d 	sth	r3,2(r16)
    IPH_CHKSUM_SET(iphdr, 0);
    58b0:	8000028d 	sth	zero,10(r16)

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
    58b4:	14a5883a 	add	r18,r2,r18

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
    IPH_CHKSUM_SET(iphdr, 0);
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    58b8:	00041840 	call	4184 <inet_chksum>
    58bc:	8080028d 	sth	r2,10(r16)

#if IP_FRAG_USES_STATIC_BUF
    if (last) {
    58c0:	e000231e 	bne	fp,zero,5950 <ip_frag+0x1f4>
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    58c4:	d8c0000b 	ldhu	r3,0(sp)
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
    58c8:	01000084 	movi	r4,2
    58cc:	000b883a 	mov	r5,zero
    58d0:	000d883a 	mov	r6,zero
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    58d4:	88e3c83a 	sub	r17,r17,r3
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
    58d8:	0006a880 	call	6a88 <pbuf_alloc>
    58dc:	102b883a 	mov	r21,r2
    if (header != NULL) {
      pbuf_chain(header, rambuf);
    58e0:	1009883a 	mov	r4,r2
    58e4:	d9400117 	ldw	r5,4(sp)
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
    if (header != NULL) {
    58e8:	10002d26 	beq	r2,zero,59a0 <ip_frag+0x244>
      pbuf_chain(header, rambuf);
    58ec:	0006ec00 	call	6ec0 <pbuf_chain>
      netif->output(netif, header, dest);
    58f0:	d9800617 	ldw	r6,24(sp)
    58f4:	a0800517 	ldw	r2,20(r20)
    58f8:	a009883a 	mov	r4,r20
    58fc:	a80b883a 	mov	r5,r21
    5900:	103ee83a 	callr	r2
      IPFRAG_STATS_INC(ip_frag.xmit);
    5904:	b0800c0b 	ldhu	r2,48(r22)
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
    5908:	d8c0070b 	ldhu	r3,28(sp)
    if (header != NULL) {
      pbuf_chain(header, rambuf);
      netif->output(netif, header, dest);
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    590c:	a809883a 	mov	r4,r21
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
    if (header != NULL) {
      pbuf_chain(header, rambuf);
      netif->output(netif, header, dest);
      IPFRAG_STATS_INC(ip_frag.xmit);
    5910:	10800044 	addi	r2,r2,1
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
    5914:	98e7883a 	add	r19,r19,r3
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
    if (header != NULL) {
      pbuf_chain(header, rambuf);
      netif->output(netif, header, dest);
      IPFRAG_STATS_INC(ip_frag.xmit);
    5918:	b0800c0d 	sth	r2,48(r22)
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    591c:	00067d80 	call	67d8 <pbuf_free>

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
    5920:	88ffffcc 	andi	r3,r17,65535
    5924:	18000f26 	beq	r3,zero,5964 <ip_frag+0x208>
    last = (left <= mtu - IP_HLEN);
    5928:	182b883a 	mov	r21,r3

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
    592c:	d8c0030b 	ldhu	r3,12(sp)
    5930:	9887ffcc 	andi	r2,r19,8191
    5934:	10c4b03a 	or	r2,r2,r3
    if (!last) {
    5938:	d8c00417 	ldw	r3,16(sp)

  while (left) {
    last = (left <= mtu - IP_HLEN);

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
    593c:	102f883a 	mov	r23,r2
    if (!last) {
    5940:	a8f8803a 	cmplt	fp,r21,r3
    5944:	e03fc426 	beq	fp,zero,5858 <ip_frag+0xfc>
    5948:	dc40000d 	sth	r17,0(sp)
    594c:	003fc606 	br	5868 <ip_frag+0x10c>
    IPH_CHKSUM_SET(iphdr, 0);
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));

#if IP_FRAG_USES_STATIC_BUF
    if (last) {
      pbuf_realloc(rambuf, left + IP_HLEN);
    5950:	d9000117 	ldw	r4,4(sp)
    5954:	89400504 	addi	r5,r17,20
    5958:	297fffcc 	andi	r5,r5,65535
    595c:	00069140 	call	6914 <pbuf_realloc>
    5960:	003fd806 	br	58c4 <ip_frag+0x168>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
    5964:	d9000117 	ldw	r4,4(sp)
    5968:	00067d80 	call	67d8 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
    596c:	0005883a 	mov	r2,zero
}
    5970:	dfc01317 	ldw	ra,76(sp)
    5974:	df001217 	ldw	fp,72(sp)
    5978:	ddc01117 	ldw	r23,68(sp)
    597c:	dd801017 	ldw	r22,64(sp)
    5980:	dd400f17 	ldw	r21,60(sp)
    5984:	dd000e17 	ldw	r20,56(sp)
    5988:	dcc00d17 	ldw	r19,52(sp)
    598c:	dc800c17 	ldw	r18,48(sp)
    5990:	dc400b17 	ldw	r17,44(sp)
    5994:	dc000a17 	ldw	r16,40(sp)
    5998:	dec01404 	addi	sp,sp,80
    599c:	f800283a 	ret
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
    59a0:	d9000117 	ldw	r4,4(sp)
    59a4:	00067d80 	call	67d8 <pbuf_free>
      return ERR_MEM;
    59a8:	00bfffc4 	movi	r2,-1
    59ac:	003ff006 	br	5970 <ip_frag+0x214>
  ofo = tmp & IP_OFFMASK;
  omf = tmp & IP_MF;

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;
    59b0:	90bffcc4 	addi	r2,r18,-13
    59b4:	003f9806 	br	5818 <ip_frag+0xbc>
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  if (rambuf == NULL) {
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
    59b8:	00bfffc4 	movi	r2,-1
    59bc:	003fec06 	br	5970 <ip_frag+0x214>

000059c0 <mem_init>:

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
    59c0:	00c001f4 	movhi	r3,7
    59c4:	18d2b3c4 	addi	r3,r3,19151
    59c8:	00bfff04 	movi	r2,-4
    59cc:	1884703a 	and	r2,r3,r2
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  mem->prev = 0;
  mem->used = 0;
  /* initialize the end of the heap */
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
    59d0:	11019004 	addi	r4,r2,1600

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
    59d4:	00c19004 	movi	r3,1600
  mem->prev = 0;
  mem->used = 0;
  /* initialize the end of the heap */
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
    59d8:	d128b415 	stw	r4,-23856(gp)
  ram_end->used = 1;
    59dc:	01000044 	movi	r4,1

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
    59e0:	10c0000d 	sth	r3,0(r2)

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
    59e4:	d0a8b315 	stw	r2,-23860(gp)
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  mem->prev = 0;
    59e8:	1000008d 	sth	zero,2(r2)
  mem->used = 0;
    59ec:	10000105 	stb	zero,4(r2)
  /* initialize the end of the heap */
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
  ram_end->used = 1;
    59f0:	11019105 	stb	r4,1604(r2)
  ram_end->next = MEM_SIZE_ALIGNED;
    59f4:	10c1900d 	sth	r3,1600(r2)
  ram_end->prev = MEM_SIZE_ALIGNED;
    59f8:	10c1908d 	sth	r3,1602(r2)

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;
    59fc:	d0a8b515 	stw	r2,-23852(gp)

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
    5a00:	008001f4 	movhi	r2,7
    5a04:	10944804 	addi	r2,r2,20768
    5a08:	10c02a0d 	sth	r3,168(r2)
    5a0c:	f800283a 	ret

00005a10 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
    5a10:	deffff04 	addi	sp,sp,-4
    5a14:	dfc00015 	stw	ra,0(sp)
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
    5a18:	20003526 	beq	r4,zero,5af0 <mem_free+0xe0>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
    5a1c:	208000cc 	andi	r2,r4,3
    5a20:	10003f1e 	bne	r2,zero,5b20 <mem_free+0x110>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
    5a24:	d0e8b317 	ldw	r3,-23860(gp)
    5a28:	20c03436 	bltu	r4,r3,5afc <mem_free+0xec>
    5a2c:	d1a8b417 	ldw	r6,-23856(gp)
    5a30:	2180322e 	bgeu	r4,r6,5afc <mem_free+0xec>
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
    5a34:	217fff03 	ldbu	r5,-4(r4)
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
    5a38:	20bffe04 	addi	r2,r4,-8
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
    5a3c:	28004126 	beq	r5,zero,5b44 <mem_free+0x134>
  /* ... and is now unused. */
  mem->used = 0;

  if (mem < lfree) {
    5a40:	d168b517 	ldw	r5,-23852(gp)
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;
    5a44:	203fff05 	stb	zero,-4(r4)

  if (mem < lfree) {
    5a48:	1140012e 	bgeu	r2,r5,5a50 <mem_free+0x40>
    /* the newly freed struct is now the lowest */
    lfree = mem;
    5a4c:	d0a8b515 	stw	r2,-23852(gp)
  }

  MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));
    5a50:	020001f4 	movhi	r8,7
    5a54:	42144804 	addi	r8,r8,20768
    5a58:	217ffe0b 	ldhu	r5,-8(r4)
    5a5c:	42402a8b 	ldhu	r9,170(r8)
    5a60:	10cfc83a 	sub	r7,r2,r3
    5a64:	4953c83a 	sub	r9,r9,r5
    5a68:	49d3883a 	add	r9,r9,r7
    5a6c:	42402a8d 	sth	r9,170(r8)
plug_holes(struct mem *mem)
{
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
    5a70:	10c04f36 	bltu	r2,r3,5bb0 <mem_free+0x1a0>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
    5a74:	1180452e 	bgeu	r2,r6,5b8c <mem_free+0x17c>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
    5a78:	297fffcc 	andi	r5,r5,65535
    5a7c:	02019004 	movi	r8,1600
    5a80:	41403936 	bltu	r8,r5,5b68 <mem_free+0x158>

  nmem = (struct mem *)(void *)&ram[mem->next];
    5a84:	194b883a 	add	r5,r3,r5
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
    5a88:	11400b26 	beq	r2,r5,5ab8 <mem_free+0xa8>
    5a8c:	2a000103 	ldbu	r8,4(r5)
    5a90:	4000091e 	bne	r8,zero,5ab8 <mem_free+0xa8>
    5a94:	31400826 	beq	r6,r5,5ab8 <mem_free+0xa8>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
    5a98:	d1a8b517 	ldw	r6,-23852(gp)
    5a9c:	2980011e 	bne	r5,r6,5aa4 <mem_free+0x94>
      lfree = mem;
    5aa0:	d0a8b515 	stw	r2,-23852(gp)
    }
    mem->next = nmem->next;
    5aa4:	2980000b 	ldhu	r6,0(r5)
    5aa8:	21bffe0d 	sth	r6,-8(r4)
    ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
    5aac:	2940000b 	ldhu	r5,0(r5)
    5ab0:	194b883a 	add	r5,r3,r5
    5ab4:	29c0008d 	sth	r7,2(r5)
  }

  /* plug hole backward */
  pmem = (struct mem *)(void *)&ram[mem->prev];
    5ab8:	217ffe8b 	ldhu	r5,-6(r4)
    5abc:	194b883a 	add	r5,r3,r5
  if (pmem != mem && pmem->used == 0) {
    5ac0:	11400b26 	beq	r2,r5,5af0 <mem_free+0xe0>
    5ac4:	29800103 	ldbu	r6,4(r5)
    5ac8:	3000091e 	bne	r6,zero,5af0 <mem_free+0xe0>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
    5acc:	d1a8b517 	ldw	r6,-23852(gp)
    5ad0:	1180011e 	bne	r2,r6,5ad8 <mem_free+0xc8>
      lfree = pmem;
    5ad4:	d168b515 	stw	r5,-23852(gp)
    }
    pmem->next = mem->next;
    5ad8:	21bffe0b 	ldhu	r6,-8(r4)
    ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
    5adc:	28c5c83a 	sub	r2,r5,r3
  if (pmem != mem && pmem->used == 0) {
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
      lfree = pmem;
    }
    pmem->next = mem->next;
    5ae0:	2980000d 	sth	r6,0(r5)
    ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
    5ae4:	213ffe0b 	ldhu	r4,-8(r4)
    5ae8:	1907883a 	add	r3,r3,r4
    5aec:	1880008d 	sth	r2,2(r3)
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
    5af0:	dfc00017 	ldw	ra,0(sp)
    5af4:	dec00104 	addi	sp,sp,4
    5af8:	f800283a 	ret
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
    5afc:	010000b4 	movhi	r4,2
    5b00:	210d4b04 	addi	r4,r4,13612
    5b04:	014000b4 	movhi	r5,2
    5b08:	29532c04 	addi	r5,r5,19632
    5b0c:	018050c4 	movi	r6,323
    5b10:	01c000b4 	movhi	r7,2
    5b14:	39d32704 	addi	r7,r7,19612
    5b18:	00104380 	call	10438 <printf>
    5b1c:	003fff06 	br	5b1c <mem_free+0x10c>

  if (rmem == NULL) {
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
    5b20:	010000b4 	movhi	r4,2
    5b24:	210d4b04 	addi	r4,r4,13612
    5b28:	014000b4 	movhi	r5,2
    5b2c:	29531e04 	addi	r5,r5,19576
    5b30:	01805004 	movi	r6,320
    5b34:	01c000b4 	movhi	r7,2
    5b38:	39d32704 	addi	r7,r7,19612
    5b3c:	00104380 	call	10438 <printf>
    5b40:	003fff06 	br	5b40 <mem_free+0x130>
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
    5b44:	010000b4 	movhi	r4,2
    5b48:	210d4b04 	addi	r4,r4,13612
    5b4c:	014000b4 	movhi	r5,2
    5b50:	29533204 	addi	r5,r5,19656
    5b54:	018054c4 	movi	r6,339
    5b58:	01c000b4 	movhi	r7,2
    5b5c:	39d32704 	addi	r7,r7,19612
    5b60:	00104380 	call	10438 <printf>
    5b64:	003fff06 	br	5b64 <mem_free+0x154>
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
    5b68:	010000b4 	movhi	r4,2
    5b6c:	210d4b04 	addi	r4,r4,13612
    5b70:	014000b4 	movhi	r5,2
    5b74:	29534404 	addi	r5,r5,19728
    5b78:	01803d84 	movi	r6,246
    5b7c:	01c000b4 	movhi	r7,2
    5b80:	39d32704 	addi	r7,r7,19612
    5b84:	00104380 	call	10438 <printf>
    5b88:	003fff06 	br	5b88 <mem_free+0x178>
{
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
    5b8c:	010000b4 	movhi	r4,2
    5b90:	210d4b04 	addi	r4,r4,13612
    5b94:	014000b4 	movhi	r5,2
    5b98:	29533d04 	addi	r5,r5,19700
    5b9c:	01803c84 	movi	r6,242
    5ba0:	01c000b4 	movhi	r7,2
    5ba4:	39d32704 	addi	r7,r7,19612
    5ba8:	00104380 	call	10438 <printf>
    5bac:	003fff06 	br	5bac <mem_free+0x19c>
plug_holes(struct mem *mem)
{
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
    5bb0:	010000b4 	movhi	r4,2
    5bb4:	210d4b04 	addi	r4,r4,13612
    5bb8:	014000b4 	movhi	r5,2
    5bbc:	29533704 	addi	r5,r5,19676
    5bc0:	01803c44 	movi	r6,241
    5bc4:	01c000b4 	movhi	r7,2
    5bc8:	39d32704 	addi	r7,r7,19612
    5bcc:	00104380 	call	10438 <printf>
    5bd0:	003fff06 	br	5bd0 <mem_free+0x1c0>

00005bd4 <mem_trim>:
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
    5bd4:	00bfff04 	movi	r2,-4
    5bd8:	294000c4 	addi	r5,r5,3
    5bdc:	288a703a 	and	r5,r5,r2
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_trim(void *rmem, mem_size_t newsize)
{
    5be0:	deffff04 	addi	sp,sp,-4
    5be4:	dfc00015 	stw	ra,0(sp)

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);

  if(newsize < MIN_SIZE_ALIGNED) {
    5be8:	29bfffcc 	andi	r6,r5,65535
    5bec:	00c002c4 	movi	r3,11
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_trim(void *rmem, mem_size_t newsize)
{
    5bf0:	2005883a 	mov	r2,r4

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);

  if(newsize < MIN_SIZE_ALIGNED) {
    5bf4:	19802c2e 	bgeu	r3,r6,5ca8 <mem_trim+0xd4>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
    5bf8:	00c19004 	movi	r3,1600
    5bfc:	19803736 	bltu	r3,r6,5cdc <mem_trim+0x108>
    return NULL;
  }

  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
    5c00:	d0e8b317 	ldw	r3,-23860(gp)
    5c04:	10c02c36 	bltu	r2,r3,5cb8 <mem_trim+0xe4>
    5c08:	d128b417 	ldw	r4,-23856(gp)
    5c0c:	11002a2e 	bgeu	r2,r4,5cb8 <mem_trim+0xe4>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... and its offset pointer */
  ptr = (mem_size_t)((u8_t *)mem - ram);

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
    5c10:	123ffe0b 	ldhu	r8,-8(r2)
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
    5c14:	113ffe04 	addi	r4,r2,-8
  /* ... and its offset pointer */
  ptr = (mem_size_t)((u8_t *)mem - ram);
    5c18:	20c9c83a 	sub	r4,r4,r3

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
    5c1c:	41fffe04 	addi	r7,r8,-8
    5c20:	390fc83a 	sub	r7,r7,r4
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
    5c24:	3a7fffcc 	andi	r9,r7,65535
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... and its offset pointer */
  ptr = (mem_size_t)((u8_t *)mem - ram);
    5c28:	2017883a 	mov	r11,r4

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
    5c2c:	49803d36 	bltu	r9,r6,5d24 <mem_trim+0x150>
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
    5c30:	32402b26 	beq	r6,r9,5ce0 <mem_trim+0x10c>
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();

  mem2 = (struct mem *)(void *)&ram[mem->next];
    5c34:	42bfffcc 	andi	r10,r8,65535
    5c38:	1a95883a 	add	r10,r3,r10
  if(mem2->used == 0) {
    5c3c:	53000103 	ldbu	r12,4(r10)
    5c40:	60002e1e 	bne	r12,zero,5cfc <mem_trim+0x128>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    5c44:	21000204 	addi	r4,r4,8
    5c48:	214d883a 	add	r6,r4,r5
    if (lfree == mem2) {
    5c4c:	d128b517 	ldw	r4,-23852(gp)
  mem2 = (struct mem *)(void *)&ram[mem->next];
  if(mem2->used == 0) {
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
    5c50:	5200000b 	ldhu	r8,0(r10)
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    if (lfree == mem2) {
    5c54:	22802526 	beq	r4,r10,5cec <mem_trim+0x118>
    5c58:	313fffcc 	andi	r4,r6,65535
    5c5c:	1909883a 	add	r4,r3,r4
    mem2 = (struct mem *)(void *)&ram[ptr2];
    if (mem2 < lfree) {
      lfree = mem2;
    }
    mem2->used = 0;
    mem2->next = mem->next;
    5c60:	2200000d 	sth	r8,0(r4)
    mem2->prev = ptr;
    mem->next = ptr2;
    5c64:	11bffe0d 	sth	r6,-8(r2)
    if (mem2->next != MEM_SIZE_ALIGNED) {
    5c68:	2200000b 	ldhu	r8,0(r4)
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    mem2 = (struct mem *)(void *)&ram[ptr2];
    if (mem2 < lfree) {
      lfree = mem2;
    }
    mem2->used = 0;
    5c6c:	20000105 	stb	zero,4(r4)
    mem2->next = mem->next;
    mem2->prev = ptr;
    5c70:	22c0008d 	sth	r11,2(r4)
    mem->next = ptr2;
    if (mem2->next != MEM_SIZE_ALIGNED) {
    5c74:	01019004 	movi	r4,1600
    5c78:	41000226 	beq	r8,r4,5c84 <mem_trim+0xb0>
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    5c7c:	1a07883a 	add	r3,r3,r8
    5c80:	1980008d 	sth	r6,2(r3)
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
    5c84:	00c001f4 	movhi	r3,7
    5c88:	18d44804 	addi	r3,r3,20768
    5c8c:	19002a8b 	ldhu	r4,170(r3)
    5c90:	21cfc83a 	sub	r7,r4,r7
    5c94:	394b883a 	add	r5,r7,r5
    5c98:	19402a8d 	sth	r5,170(r3)
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
}
    5c9c:	dfc00017 	ldw	ra,0(sp)
    5ca0:	dec00104 	addi	sp,sp,4
    5ca4:	f800283a 	ret

  if (newsize > MEM_SIZE_ALIGNED) {
    return NULL;
  }

  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
    5ca8:	d0e8b317 	ldw	r3,-23860(gp)
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);

  if(newsize < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
    5cac:	01400304 	movi	r5,12
    5cb0:	01800304 	movi	r6,12

  if (newsize > MEM_SIZE_ALIGNED) {
    return NULL;
  }

  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
    5cb4:	10ffd42e 	bgeu	r2,r3,5c08 <mem_trim+0x34>
    5cb8:	010000b4 	movhi	r4,2
    5cbc:	210d4b04 	addi	r4,r4,13612
    5cc0:	014000b4 	movhi	r5,2
    5cc4:	29534f04 	addi	r5,r5,19772
    5cc8:	018061c4 	movi	r6,391
    5ccc:	01c000b4 	movhi	r7,2
    5cd0:	39d32704 	addi	r7,r7,19612
    5cd4:	00104380 	call	10438 <printf>
    5cd8:	003fff06 	br	5cd8 <mem_trim+0x104>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
    return NULL;
    5cdc:	0005883a 	mov	r2,zero
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
}
    5ce0:	dfc00017 	ldw	ra,0(sp)
    5ce4:	dec00104 	addi	sp,sp,4
    5ce8:	f800283a 	ret
    /* remember the old next pointer */
    next = mem2->next;
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    if (lfree == mem2) {
      lfree = (struct mem *)(void *)&ram[ptr2];
    5cec:	313fffcc 	andi	r4,r6,65535
    5cf0:	1909883a 	add	r4,r3,r4
    5cf4:	d128b515 	stw	r4,-23852(gp)
    5cf8:	003fd906 	br	5c60 <mem_trim+0x8c>
    if (mem2->next != MEM_SIZE_ALIGNED) {
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
    5cfc:	31800504 	addi	r6,r6,20
    5d00:	49bff736 	bltu	r9,r6,5ce0 <mem_trim+0x10c>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    5d04:	21000204 	addi	r4,r4,8
    5d08:	214d883a 	add	r6,r4,r5
    mem2 = (struct mem *)(void *)&ram[ptr2];
    if (mem2 < lfree) {
    5d0c:	d268b517 	ldw	r9,-23852(gp)
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    mem2 = (struct mem *)(void *)&ram[ptr2];
    5d10:	313fffcc 	andi	r4,r6,65535
    5d14:	1909883a 	add	r4,r3,r4
    if (mem2 < lfree) {
    5d18:	227fd12e 	bgeu	r4,r9,5c60 <mem_trim+0x8c>
      lfree = mem2;
    5d1c:	d128b515 	stw	r4,-23852(gp)
    5d20:	003fcf06 	br	5c60 <mem_trim+0x8c>
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... and its offset pointer */
  ptr = (mem_size_t)((u8_t *)mem - ram);

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
    5d24:	010000b4 	movhi	r4,2
    5d28:	210d4b04 	addi	r4,r4,13612
    5d2c:	014000b4 	movhi	r5,2
    5d30:	29535504 	addi	r5,r5,19796
    5d34:	01806604 	movi	r6,408
    5d38:	01c000b4 	movhi	r7,2
    5d3c:	39d32704 	addi	r7,r7,19612
    5d40:	00104380 	call	10438 <printf>
    5d44:	003fff06 	br	5d44 <mem_trim+0x170>

00005d48 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
    5d48:	deffff04 	addi	sp,sp,-4
    5d4c:	dfc00015 	stw	ra,0(sp)
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
    5d50:	20bfffcc 	andi	r2,r4,65535
    5d54:	10006726 	beq	r2,zero,5ef4 <mem_malloc+0x1ac>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
    5d58:	00bfff04 	movi	r2,-4
    5d5c:	210000c4 	addi	r4,r4,3
    5d60:	2096703a 	and	r11,r4,r2

  if(size < MIN_SIZE_ALIGNED) {
    5d64:	58bfffcc 	andi	r2,r11,65535
    5d68:	00c002c4 	movi	r3,11
    5d6c:	1880222e 	bgeu	r3,r2,5df8 <mem_malloc+0xb0>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
    5d70:	01c19004 	movi	r7,1600
    5d74:	38805f36 	bltu	r7,r2,5ef4 <mem_malloc+0x1ac>
    5d78:	388fc83a 	sub	r7,r7,r2
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
    5d7c:	d268b517 	ldw	r9,-23852(gp)
    5d80:	d1a8b317 	ldw	r6,-23860(gp)
    5d84:	4989c83a 	sub	r4,r9,r6
    5d88:	20bfffcc 	andi	r2,r4,65535
    5d8c:	11c0110e 	bge	r2,r7,5dd4 <mem_malloc+0x8c>
    5d90:	20ffffcc 	andi	r3,r4,65535
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
    5d94:	5abfffcc 	andi	r10,r11,65535
    5d98:	00000806 	br	5dbc <mem_malloc+0x74>
    5d9c:	1140000b 	ldhu	r5,0(r2)
    5da0:	2a3fffcc 	andi	r8,r5,65535
    5da4:	423ffe04 	addi	r8,r8,-8
    5da8:	40c7c83a 	sub	r3,r8,r3
        local_mem_free_count = 1;
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
    5dac:	1a80152e 	bgeu	r3,r10,5e04 <mem_malloc+0xbc>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
    5db0:	2809883a 	mov	r4,r5
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
    5db4:	20ffffcc 	andi	r3,r4,65535
    5db8:	19c0060e 	bge	r3,r7,5dd4 <mem_malloc+0x8c>
         ptr = ((struct mem *)(void *)&ram[ptr])->next) {
      mem = (struct mem *)(void *)&ram[ptr];
    5dbc:	30c5883a 	add	r2,r6,r3
        local_mem_free_count = 1;
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
    5dc0:	11400103 	ldbu	r5,4(r2)
    5dc4:	283ff526 	beq	r5,zero,5d9c <mem_malloc+0x54>
    5dc8:	1100000b 	ldhu	r4,0(r2)
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
    5dcc:	20ffffcc 	andi	r3,r4,65535
    5dd0:	19fffa16 	blt	r3,r7,5dbc <mem_malloc+0x74>
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
    /* if we got interrupted by a mem_free, try again */
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
    5dd4:	00c001f4 	movhi	r3,7
    5dd8:	18d44804 	addi	r3,r3,20768
    5ddc:	19002b8b 	ldhu	r4,174(r3)
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
  return NULL;
    5de0:	0005883a 	mov	r2,zero
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
    /* if we got interrupted by a mem_free, try again */
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
    5de4:	21000044 	addi	r4,r4,1
    5de8:	19002b8d 	sth	r4,174(r3)
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
  return NULL;
}
    5dec:	dfc00017 	ldw	ra,0(sp)
    5df0:	dec00104 	addi	sp,sp,4
    5df4:	f800283a 	ret

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);

  if(size < MIN_SIZE_ALIGNED) {
    5df8:	01c18d04 	movi	r7,1588
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
    5dfc:	02c00304 	movi	r11,12
    5e00:	003fde06 	br	5d7c <mem_malloc+0x34>
      if ((!mem->used) &&
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
    5e04:	51c00504 	addi	r7,r10,20
    5e08:	19c02336 	bltu	r3,r7,5e98 <mem_malloc+0x150>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
    5e0c:	59c00204 	addi	r7,r11,8
    5e10:	390f883a 	add	r7,r7,r4
          /* create mem2 struct */
          mem2 = (struct mem *)(void *)&ram[ptr2];
    5e14:	38ffffcc 	andi	r3,r7,65535
    5e18:	30c7883a 	add	r3,r6,r3
          mem2->used = 0;
          mem2->next = mem->next;
    5e1c:	1940000d 	sth	r5,0(r3)
          mem2->prev = ptr;
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
    5e20:	11c0000d 	sth	r7,0(r2)
          mem->used = 1;

          if (mem2->next != MEM_SIZE_ALIGNED) {
    5e24:	1940000b 	ldhu	r5,0(r3)
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
          /* create mem2 struct */
          mem2 = (struct mem *)(void *)&ram[ptr2];
          mem2->used = 0;
    5e28:	18000105 	stb	zero,4(r3)
          mem2->next = mem->next;
          mem2->prev = ptr;
    5e2c:	1900008d 	sth	r4,2(r3)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
          mem->used = 1;
    5e30:	00c00044 	movi	r3,1
    5e34:	10c00105 	stb	r3,4(r2)

          if (mem2->next != MEM_SIZE_ALIGNED) {
    5e38:	00c19004 	movi	r3,1600
    5e3c:	28c00226 	beq	r5,r3,5e48 <mem_malloc+0x100>
            ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    5e40:	314b883a 	add	r5,r6,r5
    5e44:	29c0008d 	sth	r7,2(r5)
          }
          MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
    5e48:	00c001f4 	movhi	r3,7
    5e4c:	18d44804 	addi	r3,r3,20768
    5e50:	19002a8b 	ldhu	r4,170(r3)
    5e54:	19402b0b 	ldhu	r5,172(r3)
    5e58:	21000204 	addi	r4,r4,8
    5e5c:	22d7883a 	add	r11,r4,r11
    5e60:	1ac02a8d 	sth	r11,170(r3)
    5e64:	593fffcc 	andi	r4,r11,65535
    5e68:	29002f36 	bltu	r5,r4,5f28 <mem_malloc+0x1e0>
          MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
        }
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
    5e6c:	48801826 	beq	r9,r2,5ed0 <mem_malloc+0x188>
    5e70:	d0e8b417 	ldw	r3,-23856(gp)
          lfree = cur;
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_mutex_unlock(&mem_mutex);
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
    5e74:	51000204 	addi	r4,r10,8
    5e78:	2089883a 	add	r4,r4,r2
    5e7c:	19002c36 	bltu	r3,r4,5f30 <mem_malloc+0x1e8>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
    5e80:	10c000cc 	andi	r3,r2,3
    5e84:	18001f1e 	bne	r3,zero,5f04 <mem_malloc+0x1bc>
         ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
    5e88:	10800204 	addi	r2,r2,8
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
  return NULL;
}
    5e8c:	dfc00017 	ldw	ra,0(sp)
    5e90:	dec00104 	addi	sp,sp,4
    5e94:	f800283a 	ret
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
    5e98:	00c00044 	movi	r3,1
    5e9c:	10c00105 	stb	r3,4(r2)
          MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
    5ea0:	00c001f4 	movhi	r3,7
    5ea4:	18d44804 	addi	r3,r3,20768
    5ea8:	1a002a8b 	ldhu	r8,170(r3)
    5eac:	1189c83a 	sub	r4,r2,r6
    5eb0:	19c02b0b 	ldhu	r7,172(r3)
    5eb4:	2a0b883a 	add	r5,r5,r8
    5eb8:	2909c83a 	sub	r4,r5,r4
    5ebc:	19002a8d 	sth	r4,170(r3)
    5ec0:	217fffcc 	andi	r5,r4,65535
    5ec4:	397fe92e 	bgeu	r7,r5,5e6c <mem_malloc+0x124>
    5ec8:	19002b0d 	sth	r4,172(r3)
        }
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
    5ecc:	48bfe81e 	bne	r9,r2,5e70 <mem_malloc+0x128>
          struct mem *cur = lfree;
          /* Find next free block after mem and update lowest free pointer */
          while (cur->used && cur != ram_end) {
    5ed0:	48c00103 	ldbu	r3,4(r9)
    5ed4:	18001f26 	beq	r3,zero,5f54 <mem_malloc+0x20c>
    5ed8:	d0e8b417 	ldw	r3,-23856(gp)
    5edc:	48c01e26 	beq	r9,r3,5f58 <mem_malloc+0x210>
              /* If mem_free or mem_trim have run, we have to restart since they
                 could have altered our current struct mem or lfree. */
              goto mem_malloc_adjust_lfree;
            }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
            cur = (struct mem *)(void *)&ram[cur->next];
    5ee0:	4a40000b 	ldhu	r9,0(r9)
    5ee4:	3253883a 	add	r9,r6,r9
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
          struct mem *cur = lfree;
          /* Find next free block after mem and update lowest free pointer */
          while (cur->used && cur != ram_end) {
    5ee8:	49000103 	ldbu	r4,4(r9)
    5eec:	203ffb1e 	bne	r4,zero,5edc <mem_malloc+0x194>
    5ef0:	00001906 	br	5f58 <mem_malloc+0x210>
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
    return NULL;
    5ef4:	0005883a 	mov	r2,zero
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
  return NULL;
}
    5ef8:	dfc00017 	ldw	ra,0(sp)
    5efc:	dec00104 	addi	sp,sp,4
    5f00:	f800283a 	ret
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_mutex_unlock(&mem_mutex);
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
    5f04:	010000b4 	movhi	r4,2
    5f08:	210d4b04 	addi	r4,r4,13612
    5f0c:	014000b4 	movhi	r5,2
    5f10:	29536904 	addi	r5,r5,19876
    5f14:	01809a44 	movi	r6,617
    5f18:	01c000b4 	movhi	r7,2
    5f1c:	39d32704 	addi	r7,r7,19612
    5f20:	00104380 	call	10438 <printf>
    5f24:	003fff06 	br	5f24 <mem_malloc+0x1dc>
          mem->used = 1;

          if (mem2->next != MEM_SIZE_ALIGNED) {
            ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
          }
          MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
    5f28:	1ac02b0d 	sth	r11,172(r3)
    5f2c:	003fcf06 	br	5e6c <mem_malloc+0x124>
          lfree = cur;
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_mutex_unlock(&mem_mutex);
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
    5f30:	010000b4 	movhi	r4,2
    5f34:	210d4b04 	addi	r4,r4,13612
    5f38:	014000b4 	movhi	r5,2
    5f3c:	29535d04 	addi	r5,r5,19828
    5f40:	018099c4 	movi	r6,615
    5f44:	01c000b4 	movhi	r7,2
    5f48:	39d32704 	addi	r7,r7,19612
    5f4c:	00104380 	call	10438 <printf>
    5f50:	003fff06 	br	5f50 <mem_malloc+0x208>
    5f54:	d0e8b417 	ldw	r3,-23856(gp)
              goto mem_malloc_adjust_lfree;
            }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
            cur = (struct mem *)(void *)&ram[cur->next];
          }
          lfree = cur;
    5f58:	d268b515 	stw	r9,-23852(gp)
    5f5c:	003fc506 	br	5e74 <mem_malloc+0x12c>

00005f60 <mem_calloc>:
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
    5f60:	2905383a 	mul	r2,r5,r4
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
    5f64:	defffc04 	addi	sp,sp,-16
    5f68:	dc800215 	stw	r18,8(sp)
    5f6c:	2025883a 	mov	r18,r4
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
    5f70:	113fffcc 	andi	r4,r2,65535
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
    5f74:	dc400115 	stw	r17,4(sp)
    5f78:	dc000015 	stw	r16,0(sp)
    5f7c:	dfc00315 	stw	ra,12(sp)
    5f80:	2823883a 	mov	r17,r5
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
    5f84:	0005d480 	call	5d48 <mem_malloc>
    5f88:	1021883a 	mov	r16,r2
  if (p) {
    5f8c:	10000626 	beq	r2,zero,5fa8 <mem_calloc+0x48>
    /* zero the memory */
    memset(p, 0, count * size);
    5f90:	91bfffcc 	andi	r6,r18,65535
    5f94:	8c7fffcc 	andi	r17,r17,65535
    5f98:	344d383a 	mul	r6,r6,r17
    5f9c:	1009883a 	mov	r4,r2
    5fa0:	000b883a 	mov	r5,zero
    5fa4:	00103300 	call	10330 <memset>
  }
  return p;
}
    5fa8:	8005883a 	mov	r2,r16
    5fac:	dfc00317 	ldw	ra,12(sp)
    5fb0:	dc800217 	ldw	r18,8(sp)
    5fb4:	dc400117 	ldw	r17,4(sp)
    5fb8:	dc000017 	ldw	r16,0(sp)
    5fbc:	dec00404 	addi	sp,sp,16
    5fc0:	f800283a 	ret

00005fc4 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
    5fc4:	008001f4 	movhi	r2,7
    5fc8:	10947504 	addi	r2,r2,20948
    5fcc:	034000b4 	movhi	r13,2
    5fd0:	6b539404 	addi	r13,r13,20048
    5fd4:	10c00084 	addi	r3,r2,2
    5fd8:	6809883a 	mov	r4,r13
 * Initialize this module.
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
    5fdc:	11801684 	addi	r6,r2,90

  for (i = 0; i < MEMP_MAX; ++i) {
    MEMP_STATS_AVAIL(used, i, 0);
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
    5fe0:	2140000b 	ldhu	r5,0(r4)
{
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
    MEMP_STATS_AVAIL(used, i, 0);
    5fe4:	1000000d 	sth	zero,0(r2)
    MEMP_STATS_AVAIL(max, i, 0);
    5fe8:	1800000d 	sth	zero,0(r3)
    MEMP_STATS_AVAIL(err, i, 0);
    5fec:	1800008d 	sth	zero,2(r3)
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
    5ff0:	117fff8d 	sth	r5,-2(r2)
    5ff4:	10800284 	addi	r2,r2,10
    5ff8:	18c00284 	addi	r3,r3,10
    5ffc:	21000084 	addi	r4,r4,2
memp_init(void)
{
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
    6000:	11bff71e 	bne	r2,r6,5fe0 <memp_init+0x1c>
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

#if !MEMP_SEPARATE_POOLS
  memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
    6004:	00bfff04 	movi	r2,-4
    6008:	02c000f4 	movhi	r11,3
    600c:	5af443c4 	addi	r11,r11,-12017
    6010:	5896703a 	and	r11,r11,r2
    6014:	02800134 	movhi	r10,4
    6018:	52a7b704 	addi	r10,r10,-24868
    601c:	0013883a 	mov	r9,zero
 * Initialize this module.
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
    6020:	03c000b4 	movhi	r15,2
    6024:	7bd39884 	addi	r15,r15,20066

#if !MEMP_SEPARATE_POOLS
  memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
#endif /* !MEMP_SEPARATE_POOLS */
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    6028:	03800484 	movi	r14,18
 * Initialize this module.
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
    602c:	6a45883a 	add	r2,r13,r9
    memp_tab[i] = NULL;
#if MEMP_SEPARATE_POOLS
    memp = (struct memp*)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
    6030:	1300000b 	ldhu	r12,0(r2)
#if !MEMP_SEPARATE_POOLS
  memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
#endif /* !MEMP_SEPARATE_POOLS */
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    6034:	50000015 	stw	zero,0(r10)
#if MEMP_SEPARATE_POOLS
    memp = (struct memp*)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
    6038:	623fffcc 	andi	r8,r12,65535
    603c:	40001526 	beq	r8,zero,6094 <memp_init+0xd0>
 * Initialize this module.
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
    6040:	4bc5883a 	add	r2,r9,r15
    6044:	11c0000b 	ldhu	r7,0(r2)
    6048:	0009883a 	mov	r4,zero
    604c:	5805883a 	mov	r2,r11
    memp_tab[i] = NULL;
#if MEMP_SEPARATE_POOLS
    memp = (struct memp*)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
    6050:	0007883a 	mov	r3,zero
    6054:	00000106 	br	605c <memp_init+0x98>
      memp->next = memp_tab[i];
      memp_tab[i] = memp;
      memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
    6058:	3005883a 	mov	r2,r6
    memp_tab[i] = NULL;
#if MEMP_SEPARATE_POOLS
    memp = (struct memp*)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
    605c:	18c00044 	addi	r3,r3,1
      memp->next = memp_tab[i];
    6060:	11000015 	stw	r4,0(r2)
    memp_tab[i] = NULL;
#if MEMP_SEPARATE_POOLS
    memp = (struct memp*)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
    6064:	197fffcc 	andi	r5,r3,65535
      memp->next = memp_tab[i];
      memp_tab[i] = memp;
      memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
    6068:	11cd883a 	add	r6,r2,r7
    606c:	1009883a 	mov	r4,r2
    memp_tab[i] = NULL;
#if MEMP_SEPARATE_POOLS
    memp = (struct memp*)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
    6070:	2a3ff91e 	bne	r5,r8,6058 <memp_init+0x94>
 * Initialize this module.
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
    6074:	633fffc4 	addi	r12,r12,-1
    6078:	633fffcc 	andi	r12,r12,65535
    607c:	60800044 	addi	r2,r12,1
    6080:	61d9383a 	mul	r12,r12,r7
    6084:	11cf383a 	mul	r7,r2,r7
    6088:	5b19883a 	add	r12,r11,r12
    608c:	53000015 	stw	r12,0(r10)
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
      memp->next = memp_tab[i];
      memp_tab[i] = memp;
      memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
    6090:	59d7883a 	add	r11,r11,r7
    6094:	4a400084 	addi	r9,r9,2
    6098:	52800104 	addi	r10,r10,4

#if !MEMP_SEPARATE_POOLS
  memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
#endif /* !MEMP_SEPARATE_POOLS */
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    609c:	4bbfe31e 	bne	r9,r14,602c <memp_init+0x68>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
    60a0:	f800283a 	ret

000060a4 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
    60a4:	deffff04 	addi	sp,sp,-4
    60a8:	dfc00015 	stw	ra,0(sp)
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
    60ac:	00800204 	movi	r2,8
    60b0:	11001b36 	bltu	r2,r4,6120 <memp_malloc+0x7c>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
    60b4:	210d883a 	add	r6,r4,r4
    60b8:	00800134 	movhi	r2,4
    60bc:	10a7b704 	addi	r2,r2,-24868
    60c0:	318d883a 	add	r6,r6,r6
    60c4:	118d883a 	add	r6,r2,r6
    60c8:	30800017 	ldw	r2,0(r6)
#if MEMP_OVERFLOW_CHECK
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    60cc:	210002a4 	muli	r4,r4,10
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  
  if (memp != NULL) {
    60d0:	10002526 	beq	r2,zero,6168 <memp_malloc+0xc4>
#if MEMP_OVERFLOW_CHECK
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    60d4:	00c001f4 	movhi	r3,7
    60d8:	18d44804 	addi	r3,r3,20768
    60dc:	1909883a 	add	r4,r3,r4
    60e0:	21402d04 	addi	r5,r4,180
    60e4:	28c0000b 	ldhu	r3,0(r5)
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  
  if (memp != NULL) {
    memp_tab[type] = memp->next;
    60e8:	12000017 	ldw	r8,0(r2)
#if MEMP_OVERFLOW_CHECK
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    60ec:	21002d84 	addi	r4,r4,182
    60f0:	21c0000b 	ldhu	r7,0(r4)
    60f4:	18c00044 	addi	r3,r3,1
    60f8:	28c0000d 	sth	r3,0(r5)
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  
  if (memp != NULL) {
    memp_tab[type] = memp->next;
    60fc:	32000015 	stw	r8,0(r6)
#if MEMP_OVERFLOW_CHECK
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    6100:	197fffcc 	andi	r5,r3,65535
    6104:	3940012e 	bgeu	r7,r5,610c <memp_malloc+0x68>
    6108:	20c0000d 	sth	r3,0(r4)
    LWIP_ASSERT("memp_malloc: memp properly aligned",
    610c:	10c000cc 	andi	r3,r2,3
    6110:	18000c1e 	bne	r3,zero,6144 <memp_malloc+0xa0>
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
    6114:	dfc00017 	ldw	ra,0(sp)
    6118:	dec00104 	addi	sp,sp,4
    611c:	f800283a 	ret
#endif
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
    6120:	010000b4 	movhi	r4,2
    6124:	210d4b04 	addi	r4,r4,13612
    6128:	014000b4 	movhi	r5,2
    612c:	29537504 	addi	r5,r5,19924
    6130:	01806384 	movi	r6,398
    6134:	01c000b4 	movhi	r7,2
    6138:	39d37d04 	addi	r7,r7,19956
    613c:	00104380 	call	10438 <printf>
    6140:	003fff06 	br	6140 <memp_malloc+0x9c>
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
    6144:	010000b4 	movhi	r4,2
    6148:	210d4b04 	addi	r4,r4,13612
    614c:	014000b4 	movhi	r5,2
    6150:	29538304 	addi	r5,r5,19980
    6154:	01806804 	movi	r6,416
    6158:	01c000b4 	movhi	r7,2
    615c:	39d37d04 	addi	r7,r7,19956
    6160:	00104380 	call	10438 <printf>
    6164:	003fff06 	br	6164 <memp_malloc+0xc0>
                ((mem_ptr_t)memp % MEM_ALIGNMENT) == 0);
    memp = (struct memp*)(void *)((u8_t*)memp + MEMP_SIZE);
  } else {
    LWIP_DEBUGF(MEMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("memp_malloc: out of memory in pool %s\n", memp_desc[type]));
    MEMP_STATS_INC(err, type);
    6168:	00c001f4 	movhi	r3,7
    616c:	18d47604 	addi	r3,r3,20952
    6170:	20c7883a 	add	r3,r4,r3
    6174:	1900000b 	ldhu	r4,0(r3)
    6178:	21000044 	addi	r4,r4,1
    617c:	1900000d 	sth	r4,0(r3)
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
    6180:	dfc00017 	ldw	ra,0(sp)
    6184:	dec00104 	addi	sp,sp,4
    6188:	f800283a 	ret

0000618c <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
    618c:	deffff04 	addi	sp,sp,-4
    6190:	dfc00015 	stw	ra,0(sp)
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
    6194:	28001126 	beq	r5,zero,61dc <memp_free+0x50>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
    6198:	288000cc 	andi	r2,r5,3
    619c:	1000121e 	bne	r2,zero,61e8 <memp_free+0x5c>
  memp_overflow_check_element_overflow(memp, type);
  memp_overflow_check_element_underflow(memp, type);
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
    61a0:	20c002a4 	muli	r3,r4,10
    61a4:	008001f4 	movhi	r2,7
    61a8:	10947504 	addi	r2,r2,20948
  
  memp->next = memp_tab[type]; 
    61ac:	2109883a 	add	r4,r4,r4
  memp_overflow_check_element_overflow(memp, type);
  memp_overflow_check_element_underflow(memp, type);
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
    61b0:	1887883a 	add	r3,r3,r2
    61b4:	1980000b 	ldhu	r6,0(r3)
  
  memp->next = memp_tab[type]; 
    61b8:	2109883a 	add	r4,r4,r4
    61bc:	00800134 	movhi	r2,4
    61c0:	10a7b704 	addi	r2,r2,-24868
    61c4:	1105883a 	add	r2,r2,r4
    61c8:	11000017 	ldw	r4,0(r2)
  memp_overflow_check_element_overflow(memp, type);
  memp_overflow_check_element_underflow(memp, type);
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
    61cc:	31bfffc4 	addi	r6,r6,-1
    61d0:	1980000d 	sth	r6,0(r3)
  
  memp->next = memp_tab[type]; 
    61d4:	29000015 	stw	r4,0(r5)
  memp_tab[type] = memp;
    61d8:	11400015 	stw	r5,0(r2)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
    61dc:	dfc00017 	ldw	ra,0(sp)
    61e0:	dec00104 	addi	sp,sp,4
    61e4:	f800283a 	ret
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
    61e8:	010000b4 	movhi	r4,2
    61ec:	210d4b04 	addi	r4,r4,13612
    61f0:	014000b4 	movhi	r5,2
    61f4:	29538c04 	addi	r5,r5,20016
    61f8:	01806f04 	movi	r6,444
    61fc:	01c000b4 	movhi	r7,2
    6200:	39d37d04 	addi	r7,r7,19956
    6204:	00104380 	call	10438 <printf>
    6208:	003fff06 	br	6208 <memp_free+0x7c>

0000620c <netif_init>:
}
#endif /* LWIP_HAVE_LOOPIF */

void
netif_init(void)
{
    620c:	f800283a 	ret

00006210 <netif_find>:
netif_find(char *name)
{
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
    6210:	20001226 	beq	r4,zero,625c <netif_find+0x4c>
    return NULL;
  }

  num = name[2] - '0';
    6214:	21400083 	ldbu	r5,2(r4)

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    6218:	d0a8b717 	ldw	r2,-23844(gp)

  if (name == NULL) {
    return NULL;
  }

  num = name[2] - '0';
    621c:	297ff404 	addi	r5,r5,-48

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    6220:	10000c26 	beq	r2,zero,6254 <netif_find+0x44>
    6224:	29403fcc 	andi	r5,r5,255
    6228:	00000206 	br	6234 <netif_find+0x24>
    622c:	10800017 	ldw	r2,0(r2)
    6230:	10000926 	beq	r2,zero,6258 <netif_find+0x48>
    if (num == netif->num &&
    6234:	10c00c03 	ldbu	r3,48(r2)
    6238:	197ffc1e 	bne	r3,r5,622c <netif_find+0x1c>
    623c:	10c00b87 	ldb	r3,46(r2)
    6240:	21800007 	ldb	r6,0(r4)
    6244:	30fff91e 	bne	r6,r3,622c <netif_find+0x1c>
       name[0] == netif->name[0] &&
    6248:	10c00bc7 	ldb	r3,47(r2)
    624c:	21800047 	ldb	r6,1(r4)
    6250:	30fff61e 	bne	r6,r3,622c <netif_find+0x1c>
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
}
    6254:	f800283a 	ret
    6258:	f800283a 	ret
{
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
    return NULL;
    625c:	0005883a 	mov	r2,zero
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
}
    6260:	f800283a 	ret

00006264 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, ip_addr_t *ipaddr)
{
    6264:	defffc04 	addi	sp,sp,-16
    6268:	dc400115 	stw	r17,4(sp)
    626c:	dc000015 	stw	r16,0(sp)
    6270:	dfc00315 	stw	ra,12(sp)
    6274:	dc800215 	stw	r18,8(sp)
    6278:	2823883a 	mov	r17,r5
    627c:	2021883a 	mov	r16,r4
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
    6280:	28002926 	beq	r5,zero,6328 <netif_set_ipaddr+0xc4>
    6284:	29800017 	ldw	r6,0(r5)
    6288:	20c00117 	ldw	r3,4(r4)
    628c:	30c01f26 	beq	r6,r3,630c <netif_set_ipaddr+0xa8>
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    6290:	008000f4 	movhi	r2,3
    6294:	10aeb904 	addi	r2,r2,-17692
    6298:	11000017 	ldw	r4,0(r2)
    while (pcb != NULL) {
    629c:	20000c26 	beq	r4,zero,62d0 <netif_set_ipaddr+0x6c>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
    62a0:	21800017 	ldw	r6,0(r4)
    62a4:	30c00526 	beq	r6,r3,62bc <netif_set_ipaddr+0x58>
        struct tcp_pcb *next = pcb->next;
        LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
        pcb = next;
      } else {
        pcb = pcb->next;
    62a8:	21000317 	ldw	r4,12(r4)
  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
    62ac:	20000726 	beq	r4,zero,62cc <netif_set_ipaddr+0x68>
    62b0:	80c00117 	ldw	r3,4(r16)
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
    62b4:	21800017 	ldw	r6,0(r4)
    62b8:	30fffb1e 	bne	r6,r3,62a8 <netif_set_ipaddr+0x44>
        /* connections to link-local addresses must persist (RFC3927 ch. 1.9) */
        && !ip_addr_islinklocal(&(pcb->local_ip))
#endif /* LWIP_AUTOIP */
        ) {
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
    62bc:	24800317 	ldw	r18,12(r4)
        LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
    62c0:	00089ec0 	call	89ec <tcp_abort>
        pcb = next;
    62c4:	9009883a 	mov	r4,r18
  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
    62c8:	203ff91e 	bne	r4,zero,62b0 <netif_set_ipaddr+0x4c>
    62cc:	89800017 	ldw	r6,0(r17)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    62d0:	008000f4 	movhi	r2,3
    62d4:	10aebb04 	addi	r2,r2,-17684
    62d8:	10800017 	ldw	r2,0(r2)
    62dc:	1000031e 	bne	r2,zero,62ec <netif_set_ipaddr+0x88>
    62e0:	00000a06 	br	630c <netif_set_ipaddr+0xa8>
    62e4:	10800317 	ldw	r2,12(r2)
    62e8:	10000826 	beq	r2,zero,630c <netif_set_ipaddr+0xa8>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
    62ec:	10c00017 	ldw	r3,0(r2)
    62f0:	183ffc26 	beq	r3,zero,62e4 <netif_set_ipaddr+0x80>
    62f4:	81000117 	ldw	r4,4(r16)
    62f8:	193ffa1e 	bne	r3,r4,62e4 <netif_set_ipaddr+0x80>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
    62fc:	11800015 	stw	r6,0(r2)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    6300:	10800317 	ldw	r2,12(r2)
    6304:	89800017 	ldw	r6,0(r17)
    6308:	103ff81e 	bne	r2,zero,62ec <netif_set_ipaddr+0x88>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
    630c:	81800115 	stw	r6,4(r16)
    netif->name[0], netif->name[1],
    ip4_addr1_16(&netif->ip_addr),
    ip4_addr2_16(&netif->ip_addr),
    ip4_addr3_16(&netif->ip_addr),
    ip4_addr4_16(&netif->ip_addr)));
}
    6310:	dfc00317 	ldw	ra,12(sp)
    6314:	dc800217 	ldw	r18,8(sp)
    6318:	dc400117 	ldw	r17,4(sp)
    631c:	dc000017 	ldw	r16,0(sp)
    6320:	dec00404 	addi	sp,sp,16
    6324:	f800283a 	ret
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
    6328:	000d883a 	mov	r6,zero
    632c:	81800115 	stw	r6,4(r16)
    netif->name[0], netif->name[1],
    ip4_addr1_16(&netif->ip_addr),
    ip4_addr2_16(&netif->ip_addr),
    ip4_addr3_16(&netif->ip_addr),
    ip4_addr4_16(&netif->ip_addr)));
}
    6330:	dfc00317 	ldw	ra,12(sp)
    6334:	dc800217 	ldw	r18,8(sp)
    6338:	dc400117 	ldw	r17,4(sp)
    633c:	dc000017 	ldw	r16,0(sp)
    6340:	dec00404 	addi	sp,sp,16
    6344:	f800283a 	ret

00006348 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
    ip_addr_t *gw)
{
    6348:	defffc04 	addi	sp,sp,-16
    634c:	dc800215 	stw	r18,8(sp)
    6350:	3025883a 	mov	r18,r6
    6354:	dc400115 	stw	r17,4(sp)
    6358:	dc000015 	stw	r16,0(sp)
    635c:	dfc00315 	stw	ra,12(sp)
    6360:	2021883a 	mov	r16,r4
    6364:	3823883a 	mov	r17,r7
  netif_set_ipaddr(netif, ipaddr);
    6368:	00062640 	call	6264 <netif_set_ipaddr>
void
netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
{
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
    636c:	90000b26 	beq	r18,zero,639c <netif_set_addr+0x54>
    6370:	90800017 	ldw	r2,0(r18)
    6374:	80800215 	stw	r2,8(r16)
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, ip_addr_t *gw)
{
  ip_addr_set(&(netif->gw), gw);
    6378:	88000b26 	beq	r17,zero,63a8 <netif_set_addr+0x60>
    637c:	88800017 	ldw	r2,0(r17)
    6380:	80800315 	stw	r2,12(r16)
    ip_addr_t *gw)
{
  netif_set_ipaddr(netif, ipaddr);
  netif_set_netmask(netif, netmask);
  netif_set_gw(netif, gw);
}
    6384:	dfc00317 	ldw	ra,12(sp)
    6388:	dc800217 	ldw	r18,8(sp)
    638c:	dc400117 	ldw	r17,4(sp)
    6390:	dc000017 	ldw	r16,0(sp)
    6394:	dec00404 	addi	sp,sp,16
    6398:	f800283a 	ret
void
netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
{
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
    639c:	0005883a 	mov	r2,zero
    63a0:	80800215 	stw	r2,8(r16)
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, ip_addr_t *gw)
{
  ip_addr_set(&(netif->gw), gw);
    63a4:	883ff51e 	bne	r17,zero,637c <netif_set_addr+0x34>
    63a8:	0005883a 	mov	r2,zero
    63ac:	80800315 	stw	r2,12(r16)
    ip_addr_t *gw)
{
  netif_set_ipaddr(netif, ipaddr);
  netif_set_netmask(netif, netmask);
  netif_set_gw(netif, gw);
}
    63b0:	dfc00317 	ldw	ra,12(sp)
    63b4:	dc800217 	ldw	r18,8(sp)
    63b8:	dc400117 	ldw	r17,4(sp)
    63bc:	dc000017 	ldw	r16,0(sp)
    63c0:	dec00404 	addi	sp,sp,16
    63c4:	f800283a 	ret

000063c8 <netif_add>:
 * @return netif, or NULL if failed.
 */
struct netif *
netif_add(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
  ip_addr_t *gw, void *state, netif_init_fn init, netif_input_fn input)
{
    63c8:	defffd04 	addi	sp,sp,-12
    63cc:	dc400115 	stw	r17,4(sp)
    63d0:	dc400417 	ldw	r17,16(sp)
    63d4:	dc000015 	stw	r16,0(sp)
    63d8:	dfc00215 	stw	ra,8(sp)
    63dc:	2021883a 	mov	r16,r4

  LWIP_ASSERT("No init function given", init != NULL);
    63e0:	88001d26 	beq	r17,zero,6458 <netif_add+0x90>
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  netif->num = netif_num++;
    63e4:	d0a8b603 	ldbu	r2,-23848(gp)
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
    63e8:	da000317 	ldw	r8,12(sp)
{

  LWIP_ASSERT("No init function given", init != NULL);

  /* reset new interface configuration state */
  ip_addr_set_zero(&netif->ip_addr);
    63ec:	20000115 	stw	zero,4(r4)
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  netif->num = netif_num++;
    63f0:	10c00044 	addi	r3,r2,1
    63f4:	20800c05 	stb	r2,48(r4)
  netif->input = input;
    63f8:	d8800517 	ldw	r2,20(sp)
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
    63fc:	22000715 	stw	r8,28(r4)

  LWIP_ASSERT("No init function given", init != NULL);

  /* reset new interface configuration state */
  ip_addr_set_zero(&netif->ip_addr);
  ip_addr_set_zero(&netif->netmask);
    6400:	20000215 	stw	zero,8(r4)
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  netif->num = netif_num++;
  netif->input = input;
    6404:	20800415 	stw	r2,16(r4)
  LWIP_ASSERT("No init function given", init != NULL);

  /* reset new interface configuration state */
  ip_addr_set_zero(&netif->ip_addr);
  ip_addr_set_zero(&netif->netmask);
  ip_addr_set_zero(&netif->gw);
    6408:	20000315 	stw	zero,12(r4)
  netif->flags = 0;
    640c:	20000b45 	stb	zero,45(r4)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
    6410:	20000815 	stw	zero,32(r4)
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  netif->num = netif_num++;
    6414:	d0e8b605 	stb	r3,-23848(gp)
  NETIF_SET_HWADDRHINT(netif, NULL);
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
    6418:	00063480 	call	6348 <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
    641c:	8009883a 	mov	r4,r16
    6420:	883ee83a 	callr	r17
    6424:	10803fcc 	andi	r2,r2,255
    6428:	1080201c 	xori	r2,r2,128
    642c:	10bfe004 	addi	r2,r2,-128
    6430:	1000121e 	bne	r2,zero,647c <netif_add+0xb4>
    return NULL;
  }

  /* add this netif to the list */
  netif->next = netif_list;
    6434:	d0a8b717 	ldw	r2,-23844(gp)
    6438:	80800015 	stw	r2,0(r16)
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
}
    643c:	8005883a 	mov	r2,r16
    return NULL;
  }

  /* add this netif to the list */
  netif->next = netif_list;
  netif_list = netif;
    6440:	d428b715 	stw	r16,-23844(gp)
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
}
    6444:	dfc00217 	ldw	ra,8(sp)
    6448:	dc400117 	ldw	r17,4(sp)
    644c:	dc000017 	ldw	r16,0(sp)
    6450:	dec00304 	addi	sp,sp,12
    6454:	f800283a 	ret
struct netif *
netif_add(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
  ip_addr_t *gw, void *state, netif_init_fn init, netif_input_fn input)
{

  LWIP_ASSERT("No init function given", init != NULL);
    6458:	010000b4 	movhi	r4,2
    645c:	210d4b04 	addi	r4,r4,13612
    6460:	014000b4 	movhi	r5,2
    6464:	29539d04 	addi	r5,r5,20084
    6468:	018023c4 	movi	r6,143
    646c:	01c000b4 	movhi	r7,2
    6470:	39d3a304 	addi	r7,r7,20108
    6474:	00104380 	call	10438 <printf>
    6478:	003fff06 	br	6478 <netif_add+0xb0>

  netif_set_addr(netif, ipaddr, netmask, gw);

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
    return NULL;
    647c:	0021883a 	mov	r16,zero
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
}
    6480:	8005883a 	mov	r2,r16
    6484:	dfc00217 	ldw	ra,8(sp)
    6488:	dc400117 	ldw	r17,4(sp)
    648c:	dc000017 	ldw	r16,0(sp)
    6490:	dec00304 	addi	sp,sp,12
    6494:	f800283a 	ret

00006498 <netif_set_gw>:
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, ip_addr_t *gw)
{
  ip_addr_set(&(netif->gw), gw);
    6498:	28000326 	beq	r5,zero,64a8 <netif_set_gw+0x10>
    649c:	28800017 	ldw	r2,0(r5)
    64a0:	20800315 	stw	r2,12(r4)
    64a4:	f800283a 	ret
    64a8:	0005883a 	mov	r2,zero
    64ac:	20800315 	stw	r2,12(r4)
    64b0:	f800283a 	ret

000064b4 <netif_set_netmask>:
void
netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
{
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
    64b4:	28000326 	beq	r5,zero,64c4 <netif_set_netmask+0x10>
    64b8:	28800017 	ldw	r2,0(r5)
    64bc:	20800215 	stw	r2,8(r4)
    64c0:	f800283a 	ret
    64c4:	0005883a 	mov	r2,zero
    64c8:	20800215 	stw	r2,8(r4)
    64cc:	f800283a 	ret

000064d0 <netif_set_default>:
    snmp_delete_iprteidx_tree(1, netif);
  } else {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
    64d0:	d128b815 	stw	r4,-23840(gp)
    64d4:	f800283a 	ret

000064d8 <netif_set_up>:
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  if (!(netif->flags & NETIF_FLAG_UP)) {
    64d8:	20800b43 	ldbu	r2,45(r4)
    64dc:	10c0004c 	andi	r3,r2,1
    64e0:	1800051e 	bne	r3,zero,64f8 <netif_set_up+0x20>
    netif->flags |= NETIF_FLAG_UP;
    64e4:	10c00054 	ori	r3,r2,1
    64e8:	20c00b45 	stb	r3,45(r4)
    NETIF_STATUS_CALLBACK(netif);

    if (netif->flags & NETIF_FLAG_LINK_UP) {
#if LWIP_ARP
      /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
      if (netif->flags & (NETIF_FLAG_ETHARP)) {
    64ec:	10800c0c 	andi	r2,r2,48
    64f0:	00c00c04 	movi	r3,48
    64f4:	10c00126 	beq	r2,r3,64fc <netif_set_up+0x24>
    64f8:	f800283a 	ret
        etharp_gratuitous(netif);
    64fc:	21400104 	addi	r5,r4,4
    6500:	000e0a01 	jmpi	e0a0 <etharp_request>

00006504 <netif_set_down>:
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  if (netif->flags & NETIF_FLAG_UP) {
    6504:	20800b43 	ldbu	r2,45(r4)
    6508:	1140004c 	andi	r5,r2,1
    650c:	28000526 	beq	r5,zero,6524 <netif_set_down+0x20>
    netif->flags &= ~NETIF_FLAG_UP;
    6510:	11403f8c 	andi	r5,r2,254
#if LWIP_SNMP
    snmp_get_sysuptime(&netif->ts);
#endif

#if LWIP_ARP
    if (netif->flags & NETIF_FLAG_ETHARP) {
    6514:	1080080c 	andi	r2,r2,32
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  if (netif->flags & NETIF_FLAG_UP) {
    netif->flags &= ~NETIF_FLAG_UP;
    6518:	21400b45 	stb	r5,45(r4)
#if LWIP_SNMP
    snmp_get_sysuptime(&netif->ts);
#endif

#if LWIP_ARP
    if (netif->flags & NETIF_FLAG_ETHARP) {
    651c:	10803fcc 	andi	r2,r2,255
    6520:	1000011e 	bne	r2,zero,6528 <netif_set_down+0x24>
    6524:	f800283a 	ret
      etharp_cleanup_netif(netif);
    6528:	000df601 	jmpi	df60 <etharp_cleanup_netif>

0000652c <netif_remove>:
 *
 * @param netif the network interface to remove
 */
void
netif_remove(struct netif *netif)
{
    652c:	defffe04 	addi	sp,sp,-8
    6530:	dc000015 	stw	r16,0(sp)
    6534:	dfc00115 	stw	ra,4(sp)
    6538:	2021883a 	mov	r16,r4
  if (netif == NULL) {
    653c:	20000d26 	beq	r4,zero,6574 <netif_remove+0x48>
  /* stop IGMP processing */
  if (netif->flags & NETIF_FLAG_IGMP) {
    igmp_stop(netif);
  }
#endif /* LWIP_IGMP */
  if (netif_is_up(netif)) {
    6540:	20800b43 	ldbu	r2,45(r4)
    6544:	1080004c 	andi	r2,r2,1
    6548:	1000181e 	bne	r2,zero,65ac <netif_remove+0x80>
  }

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
    654c:	d0e8b717 	ldw	r3,-23844(gp)
    6550:	1c001926 	beq	r3,r16,65b8 <netif_remove+0x8c>
    netif_list = netif->next;
  } else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
    6554:	18000726 	beq	r3,zero,6574 <netif_remove+0x48>
      if (tmpNetif->next == netif) {
    6558:	18800017 	ldw	r2,0(r3)
    655c:	14000926 	beq	r2,r16,6584 <netif_remove+0x58>
  if (netif_list == netif) {
    netif_list = netif->next;
  } else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
    6560:	10000426 	beq	r2,zero,6574 <netif_remove+0x48>
      if (tmpNetif->next == netif) {
    6564:	10c00017 	ldw	r3,0(r2)
    6568:	1c000726 	beq	r3,r16,6588 <netif_remove+0x5c>
    656c:	1805883a 	mov	r2,r3
  if (netif_list == netif) {
    netif_list = netif->next;
  } else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
    6570:	103ffc1e 	bne	r2,zero,6564 <netif_remove+0x38>
  if (netif->remove_callback) {
    netif->remove_callback(netif);
  }
#endif /* LWIP_NETIF_REMOVE_CALLBACK */
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
    6574:	dfc00117 	ldw	ra,4(sp)
    6578:	dc000017 	ldw	r16,0(sp)
    657c:	dec00204 	addi	sp,sp,8
    6580:	f800283a 	ret
    netif_list = netif->next;
  } else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
      if (tmpNetif->next == netif) {
    6584:	1805883a 	mov	r2,r3
        tmpNetif->next = netif->next;
    6588:	80c00017 	ldw	r3,0(r16)
    658c:	10c00015 	stw	r3,0(r2)
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  }
  snmp_dec_iflist();
  /* this netif is default? */
  if (netif_default == netif) {
    6590:	d0a8b817 	ldw	r2,-23840(gp)
    6594:	143ff71e 	bne	r2,r16,6574 <netif_remove+0x48>
    snmp_delete_iprteidx_tree(1, netif);
  } else {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
    6598:	d028b815 	stw	zero,-23840(gp)
  if (netif->remove_callback) {
    netif->remove_callback(netif);
  }
#endif /* LWIP_NETIF_REMOVE_CALLBACK */
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
    659c:	dfc00117 	ldw	ra,4(sp)
    65a0:	dc000017 	ldw	r16,0(sp)
    65a4:	dec00204 	addi	sp,sp,8
    65a8:	f800283a 	ret
    igmp_stop(netif);
  }
#endif /* LWIP_IGMP */
  if (netif_is_up(netif)) {
    /* set netif down before removing (call callback function) */
    netif_set_down(netif);
    65ac:	00065040 	call	6504 <netif_set_down>
  }

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
    65b0:	d0e8b717 	ldw	r3,-23844(gp)
    65b4:	1c3fe71e 	bne	r3,r16,6554 <netif_remove+0x28>
    netif_list = netif->next;
    65b8:	80800017 	ldw	r2,0(r16)
    65bc:	d0a8b715 	stw	r2,-23844(gp)
    65c0:	003ff306 	br	6590 <netif_remove+0x64>

000065c4 <netif_set_link_up>:

/**
 * Called by a driver when its link goes up
 */
void netif_set_link_up(struct netif *netif )
{
    65c4:	defffe04 	addi	sp,sp,-8
    65c8:	dc000015 	stw	r16,0(sp)
    65cc:	dfc00115 	stw	ra,4(sp)
  if (!(netif->flags & NETIF_FLAG_LINK_UP)) {
    65d0:	20800b43 	ldbu	r2,45(r4)

/**
 * Called by a driver when its link goes up
 */
void netif_set_link_up(struct netif *netif )
{
    65d4:	2021883a 	mov	r16,r4
  if (!(netif->flags & NETIF_FLAG_LINK_UP)) {
    65d8:	10c0040c 	andi	r3,r2,16
    65dc:	18c03fcc 	andi	r3,r3,255
    65e0:	1800091e 	bne	r3,zero,6608 <netif_set_link_up+0x44>
    netif->flags |= NETIF_FLAG_LINK_UP;

#if LWIP_DHCP
    if (netif->dhcp) {
    65e4:	20c00817 	ldw	r3,32(r4)
 * Called by a driver when its link goes up
 */
void netif_set_link_up(struct netif *netif )
{
  if (!(netif->flags & NETIF_FLAG_LINK_UP)) {
    netif->flags |= NETIF_FLAG_LINK_UP;
    65e8:	10800414 	ori	r2,r2,16
    65ec:	20800b45 	stb	r2,45(r4)

#if LWIP_DHCP
    if (netif->dhcp) {
    65f0:	18000226 	beq	r3,zero,65fc <netif_set_link_up+0x38>
      dhcp_network_changed(netif);
    65f4:	0002fd80 	call	2fd8 <dhcp_network_changed>
    65f8:	80800b43 	ldbu	r2,45(r16)
#endif /* LWIP_AUTOIP */

    if (netif->flags & NETIF_FLAG_UP) {
#if LWIP_ARP
      /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
      if (netif->flags & NETIF_FLAG_ETHARP) {
    65fc:	1080084c 	andi	r2,r2,33
    6600:	00c00844 	movi	r3,33
    6604:	10c00426 	beq	r2,r3,6618 <netif_set_link_up+0x54>
      }
#endif /* LWIP_IGMP */
    }
    NETIF_LINK_CALLBACK(netif);
  }
}
    6608:	dfc00117 	ldw	ra,4(sp)
    660c:	dc000017 	ldw	r16,0(sp)
    6610:	dec00204 	addi	sp,sp,8
    6614:	f800283a 	ret

    if (netif->flags & NETIF_FLAG_UP) {
#if LWIP_ARP
      /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
      if (netif->flags & NETIF_FLAG_ETHARP) {
        etharp_gratuitous(netif);
    6618:	8009883a 	mov	r4,r16
    661c:	81400104 	addi	r5,r16,4
      }
#endif /* LWIP_IGMP */
    }
    NETIF_LINK_CALLBACK(netif);
  }
}
    6620:	dfc00117 	ldw	ra,4(sp)
    6624:	dc000017 	ldw	r16,0(sp)
    6628:	dec00204 	addi	sp,sp,8

    if (netif->flags & NETIF_FLAG_UP) {
#if LWIP_ARP
      /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
      if (netif->flags & NETIF_FLAG_ETHARP) {
        etharp_gratuitous(netif);
    662c:	000e0a01 	jmpi	e0a0 <etharp_request>

00006630 <netif_set_link_down>:
/**
 * Called by a driver when its link goes down
 */
void netif_set_link_down(struct netif *netif )
{
  if (netif->flags & NETIF_FLAG_LINK_UP) {
    6630:	20800b43 	ldbu	r2,45(r4)
    6634:	10c0040c 	andi	r3,r2,16
    6638:	18c03fcc 	andi	r3,r3,255
    663c:	18000226 	beq	r3,zero,6648 <netif_set_link_down+0x18>
    netif->flags &= ~NETIF_FLAG_LINK_UP;
    6640:	10803bcc 	andi	r2,r2,239
    6644:	20800b45 	stb	r2,45(r4)
    6648:	f800283a 	ret

0000664c <pbuf_free_ooseq>:
#if !NO_SYS
static
#endif /* !NO_SYS */
void
pbuf_free_ooseq(void)
{
    664c:	defffe04 	addi	sp,sp,-8

  SYS_ARCH_PROTECT(old_level);
  pbuf_free_ooseq_pending = 0;
  SYS_ARCH_UNPROTECT(old_level);

  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
    6650:	008000f4 	movhi	r2,3
    6654:	10aeb904 	addi	r2,r2,-17692
#if !NO_SYS
static
#endif /* !NO_SYS */
void
pbuf_free_ooseq(void)
{
    6658:	dc000015 	stw	r16,0(sp)

  SYS_ARCH_PROTECT(old_level);
  pbuf_free_ooseq_pending = 0;
  SYS_ARCH_UNPROTECT(old_level);

  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
    665c:	14000017 	ldw	r16,0(r2)
#if !NO_SYS
static
#endif /* !NO_SYS */
void
pbuf_free_ooseq(void)
{
    6660:	dfc00115 	stw	ra,4(sp)
  struct tcp_pcb* pcb;
  SYS_ARCH_DECL_PROTECT(old_level);

  SYS_ARCH_PROTECT(old_level);
  pbuf_free_ooseq_pending = 0;
    6664:	d028b905 	stb	zero,-23836(gp)
  SYS_ARCH_UNPROTECT(old_level);

  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
    6668:	8000031e 	bne	r16,zero,6678 <pbuf_free_ooseq+0x2c>
    666c:	00000606 	br	6688 <pbuf_free_ooseq+0x3c>
    6670:	84000317 	ldw	r16,12(r16)
    6674:	80000426 	beq	r16,zero,6688 <pbuf_free_ooseq+0x3c>
    if (NULL != pcb->ooseq) {
    6678:	81001e17 	ldw	r4,120(r16)
    667c:	203ffc26 	beq	r4,zero,6670 <pbuf_free_ooseq+0x24>
      /** Free the ooseq pbufs of one PCB only */
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free_ooseq: freeing out-of-sequence pbufs\n"));
      tcp_segs_free(pcb->ooseq);
    6680:	0007f200 	call	7f20 <tcp_segs_free>
      pcb->ooseq = NULL;
    6684:	80001e15 	stw	zero,120(r16)
      return;
    }
  }
}
    6688:	dfc00117 	ldw	ra,4(sp)
    668c:	dc000017 	ldw	r16,0(sp)
    6690:	dec00204 	addi	sp,sp,8
    6694:	f800283a 	ret

00006698 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
    6698:	deffff04 	addi	sp,sp,-4
    669c:	dfc00015 	stw	ra,0(sp)
    66a0:	2807883a 	mov	r3,r5
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
    66a4:	20003f26 	beq	r4,zero,67a4 <pbuf_header+0x10c>
  if ((header_size_increment == 0) || (p == NULL)) {
    66a8:	18ffffcc 	andi	r3,r3,65535
    66ac:	18e0001c 	xori	r3,r3,32768
    66b0:	18e00004 	addi	r3,r3,-32768
    66b4:	18002226 	beq	r3,zero,6740 <pbuf_header+0xa8>
    return 0;
  }
 
  if (header_size_increment < 0){
    66b8:	18001416 	blt	r3,zero,670c <pbuf_header+0x74>
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
    66bc:	280d883a 	mov	r6,r5
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
    66c0:	20800303 	ldbu	r2,12(r4)
  /* remember current payload pointer */
  payload = p->payload;
    66c4:	21c00117 	ldw	r7,4(r4)

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    66c8:	123fffcc 	andi	r8,r2,65535
    66cc:	40002026 	beq	r8,zero,6750 <pbuf_header+0xb8>
    66d0:	024000c4 	movi	r9,3
    66d4:	42401e26 	beq	r8,r9,6750 <pbuf_header+0xb8>
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    66d8:	10bfffc4 	addi	r2,r2,-1
    66dc:	123fffcc 	andi	r8,r2,65535
    66e0:	00800044 	movi	r2,1
    66e4:	1200282e 	bgeu	r2,r8,6788 <pbuf_header+0xf0>
       * bail out unsuccesfully */
      return 1;
    }
  } else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    66e8:	010000b4 	movhi	r4,2
    66ec:	210d4b04 	addi	r4,r4,13612
    66f0:	014000b4 	movhi	r5,2
    66f4:	2953b704 	addi	r5,r5,20188
    66f8:	01808ec4 	movi	r6,571
    66fc:	01c000b4 	movhi	r7,2
    6700:	39d3a904 	addi	r7,r7,20132
    6704:	00104380 	call	10438 <printf>
    6708:	003fff06 	br	6708 <pbuf_header+0x70>
  }
 
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
    670c:	21c0028b 	ldhu	r7,10(r4)
  if ((header_size_increment == 0) || (p == NULL)) {
    return 0;
  }
 
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
    6710:	014dc83a 	sub	r6,zero,r5
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
    6714:	30bfffcc 	andi	r2,r6,65535
    6718:	38bfe92e 	bgeu	r7,r2,66c0 <pbuf_header+0x28>
    671c:	010000b4 	movhi	r4,2
    6720:	210d4b04 	addi	r4,r4,13612
    6724:	014000b4 	movhi	r5,2
    6728:	2953af04 	addi	r5,r5,20156
    672c:	01808344 	movi	r6,525
    6730:	01c000b4 	movhi	r7,2
    6734:	39d3a904 	addi	r7,r7,20132
    6738:	00104380 	call	10438 <printf>
    673c:	003fff06 	br	673c <pbuf_header+0xa4>
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL)) {
    return 0;
    6740:	0005883a 	mov	r2,zero

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
}
    6744:	dfc00017 	ldw	ra,0(sp)
    6748:	dec00104 	addi	sp,sp,4
    674c:	f800283a 	ret
  payload = p->payload;

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
    6750:	38c7c83a 	sub	r3,r7,r3
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
    6754:	20800404 	addi	r2,r4,16
    6758:	18801b36 	bltu	r3,r2,67c8 <pbuf_header+0x130>
  payload = p->payload;

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
    675c:	20c00115 	stw	r3,4(r4)
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
    6760:	20c0028b 	ldhu	r3,10(r4)
  p->tot_len += header_size_increment;
    6764:	2180020b 	ldhu	r6,8(r4)

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
    6768:	0005883a 	mov	r2,zero
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
    676c:	28c7883a 	add	r3,r5,r3
  p->tot_len += header_size_increment;
    6770:	298b883a 	add	r5,r5,r6
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
    6774:	20c0028d 	sth	r3,10(r4)
  p->tot_len += header_size_increment;
    6778:	2140020d 	sth	r5,8(r4)

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
}
    677c:	dfc00017 	ldw	ra,0(sp)
    6780:	dec00104 	addi	sp,sp,4
    6784:	f800283a 	ret
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
    6788:	183fee0e 	bge	r3,zero,6744 <pbuf_header+0xac>
    678c:	2200028b 	ldhu	r8,10(r4)
    6790:	31bfffcc 	andi	r6,r6,65535
    6794:	41bfeb36 	bltu	r8,r6,6744 <pbuf_header+0xac>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    6798:	38c7c83a 	sub	r3,r7,r3
    679c:	20c00115 	stw	r3,4(r4)
    67a0:	003fef06 	br	6760 <pbuf_header+0xc8>
{
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
    67a4:	010000b4 	movhi	r4,2
    67a8:	210d4b04 	addi	r4,r4,13612
    67ac:	014000b4 	movhi	r5,2
    67b0:	2951d904 	addi	r5,r5,18276
    67b4:	01808144 	movi	r6,517
    67b8:	01c000b4 	movhi	r7,2
    67bc:	39d3a904 	addi	r7,r7,20132
    67c0:	00104380 	call	10438 <printf>
    67c4:	003fff06 	br	67c4 <pbuf_header+0x12c>
        ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload, (void *)(p + 1)));
      /* restore old payload pointer */
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    67c8:	00800044 	movi	r2,1

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
}
    67cc:	dfc00017 	ldw	ra,0(sp)
    67d0:	dec00104 	addi	sp,sp,4
    67d4:	f800283a 	ret

000067d8 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
    67d8:	defffb04 	addi	sp,sp,-20
    67dc:	dfc00415 	stw	ra,16(sp)
    67e0:	dcc00315 	stw	r19,12(sp)
    67e4:	dc800215 	stw	r18,8(sp)
    67e8:	dc400115 	stw	r17,4(sp)
    67ec:	dc000015 	stw	r16,0(sp)
    67f0:	200b883a 	mov	r5,r4
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
    67f4:	20003e26 	beq	r4,zero,68f0 <pbuf_free+0x118>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
    67f8:	20c00303 	ldbu	r3,12(r4)
    67fc:	008000c4 	movi	r2,3
    6800:	10c02c36 	bltu	r2,r3,68b4 <pbuf_free+0xdc>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    6804:	2900038b 	ldhu	r4,14(r5)
        pc->custom_free_function(p);
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
    6808:	1025883a 	mov	r18,r2
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
    680c:	0021883a 	mov	r16,zero
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
    6810:	20ffffc4 	addi	r3,r4,-1
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    6814:	213fffcc 	andi	r4,r4,65535
      {
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
          memp_free(MEMP_PBUF_POOL, p);
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
    6818:	04400044 	movi	r17,1
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
    681c:	18bfffcc 	andi	r2,r3,65535
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    6820:	20001b26 	beq	r4,zero,6890 <pbuf_free+0xb8>
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
    6824:	28c0038d 	sth	r3,14(r5)
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
    6828:	10000826 	beq	r2,zero,684c <pbuf_free+0x74>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
    682c:	8005883a 	mov	r2,r16
    6830:	dfc00417 	ldw	ra,16(sp)
    6834:	dcc00317 	ldw	r19,12(sp)
    6838:	dc800217 	ldw	r18,8(sp)
    683c:	dc400117 	ldw	r17,4(sp)
    6840:	dc000017 	ldw	r16,0(sp)
    6844:	dec00504 	addi	sp,sp,20
    6848:	f800283a 	ret
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
      /* remember next pbuf in chain for next iteration */
      q = p->next;
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
    684c:	28c00303 	ldbu	r3,12(r5)
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
          memp_free(MEMP_PBUF, p);
        /* type == PBUF_RAM */
        } else {
          mem_free(p);
    6850:	2809883a 	mov	r4,r5
    ref = --(p->ref);
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
      /* remember next pbuf in chain for next iteration */
      q = p->next;
    6854:	2cc00017 	ldw	r19,0(r5)
      {
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
          memp_free(MEMP_PBUF_POOL, p);
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
    6858:	18bfffc4 	addi	r2,r3,-1
        pc->custom_free_function(p);
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
    685c:	18ffffcc 	andi	r3,r3,65535
          memp_free(MEMP_PBUF_POOL, p);
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
    6860:	10bfffcc 	andi	r2,r2,65535
        pc->custom_free_function(p);
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
    6864:	1c801f26 	beq	r3,r18,68e4 <pbuf_free+0x10c>
          memp_free(MEMP_PBUF_POOL, p);
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
    6868:	88801b2e 	bgeu	r17,r2,68d8 <pbuf_free+0x100>
          memp_free(MEMP_PBUF, p);
        /* type == PBUF_RAM */
        } else {
          mem_free(p);
    686c:	0005a100 	call	5a10 <mem_free>
        }
      }
      count++;
      /* proceed to next pbuf */
      p = q;
    6870:	980b883a 	mov	r5,r19
        /* type == PBUF_RAM */
        } else {
          mem_free(p);
        }
      }
      count++;
    6874:	84000044 	addi	r16,r16,1
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
    6878:	983fec26 	beq	r19,zero,682c <pbuf_free+0x54>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    687c:	2900038b 	ldhu	r4,14(r5)
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
    6880:	20ffffc4 	addi	r3,r4,-1
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    6884:	213fffcc 	andi	r4,r4,65535
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
    6888:	18bfffcc 	andi	r2,r3,65535
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    688c:	203fe51e 	bne	r4,zero,6824 <pbuf_free+0x4c>
    6890:	010000b4 	movhi	r4,2
    6894:	210d4b04 	addi	r4,r4,13612
    6898:	014000b4 	movhi	r5,2
    689c:	2953c104 	addi	r5,r5,20228
    68a0:	0180a284 	movi	r6,650
    68a4:	01c000b4 	movhi	r7,2
    68a8:	39d3a904 	addi	r7,r7,20132
    68ac:	00104380 	call	10438 <printf>
    68b0:	003fff06 	br	68b0 <pbuf_free+0xd8>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
    68b4:	010000b4 	movhi	r4,2
    68b8:	210d4b04 	addi	r4,r4,13612
    68bc:	014000b4 	movhi	r5,2
    68c0:	2953bb04 	addi	r5,r5,20204
    68c4:	01809f44 	movi	r6,637
    68c8:	01c000b4 	movhi	r7,2
    68cc:	39d3a904 	addi	r7,r7,20132
    68d0:	00104380 	call	10438 <printf>
    68d4:	003fff06 	br	68d4 <pbuf_free+0xfc>
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
          memp_free(MEMP_PBUF_POOL, p);
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
          memp_free(MEMP_PBUF, p);
    68d8:	010001c4 	movi	r4,7
    68dc:	000618c0 	call	618c <memp_free>
    68e0:	003fe306 	br	6870 <pbuf_free+0x98>
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
          memp_free(MEMP_PBUF_POOL, p);
    68e4:	01000204 	movi	r4,8
    68e8:	000618c0 	call	618c <memp_free>
    68ec:	003fe006 	br	6870 <pbuf_free+0x98>
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
    LWIP_ASSERT("p != NULL", p != NULL);
    68f0:	010000b4 	movhi	r4,2
    68f4:	210d4b04 	addi	r4,r4,13612
    68f8:	014000b4 	movhi	r5,2
    68fc:	2951d904 	addi	r5,r5,18276
    6900:	01809c44 	movi	r6,625
    6904:	01c000b4 	movhi	r7,2
    6908:	39d3a904 	addi	r7,r7,20132
    690c:	00104380 	call	10438 <printf>
    6910:	003fff06 	br	6910 <pbuf_free+0x138>

00006914 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
    6914:	defffd04 	addi	sp,sp,-12
    6918:	dfc00215 	stw	ra,8(sp)
    691c:	dc400115 	stw	r17,4(sp)
    6920:	dc000015 	stw	r16,0(sp)
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
    6924:	20003d26 	beq	r4,zero,6a1c <pbuf_realloc+0x108>
    6928:	20800303 	ldbu	r2,12(r4)
    692c:	00c000c4 	movi	r3,3
    6930:	1880092e 	bgeu	r3,r2,6958 <pbuf_realloc+0x44>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
    6934:	010000b4 	movhi	r4,2
    6938:	210d4b04 	addi	r4,r4,13612
    693c:	014000b4 	movhi	r5,2
    6940:	2953cd04 	addi	r5,r5,20276
    6944:	01806e04 	movi	r6,440
    6948:	01c000b4 	movhi	r7,2
    694c:	39d3a904 	addi	r7,r7,20132
    6950:	00104380 	call	10438 <printf>
    6954:	003fff06 	br	6954 <pbuf_realloc+0x40>
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
    6958:	2080020b 	ldhu	r2,8(r4)
    695c:	29bfffcc 	andi	r6,r5,65535
    6960:	3080292e 	bgeu	r6,r2,6a08 <pbuf_realloc+0xf4>

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
    6964:	2823883a 	mov	r17,r5
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
    6968:	308dc83a 	sub	r6,r6,r2

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
    696c:	2021883a 	mov	r16,r4
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
    6970:	017fff94 	movui	r5,65534

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
    6974:	8100028b 	ldhu	r4,10(r16)
    6978:	88ffffcc 	andi	r3,r17,65535
    697c:	20bfffcc 	andi	r2,r4,65535
    6980:	10c0102e 	bgeu	r2,r3,69c4 <pbuf_realloc+0xb0>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
    6984:	8923c83a 	sub	r17,r17,r4
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
    6988:	29802d16 	blt	r5,r6,6a40 <pbuf_realloc+0x12c>
    q->tot_len += (u16_t)grow;
    698c:	8080020b 	ldhu	r2,8(r16)
    6990:	3085883a 	add	r2,r6,r2
    6994:	8080020d 	sth	r2,8(r16)
    /* proceed to next pbuf in chain */
    q = q->next;
    6998:	84000017 	ldw	r16,0(r16)
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
    699c:	803ff51e 	bne	r16,zero,6974 <pbuf_realloc+0x60>
    69a0:	010000b4 	movhi	r4,2
    69a4:	210d4b04 	addi	r4,r4,13612
    69a8:	014000b4 	movhi	r5,2
    69ac:	2953d904 	addi	r5,r5,20324
    69b0:	01807404 	movi	r6,464
    69b4:	01c000b4 	movhi	r7,2
    69b8:	39d3a904 	addi	r7,r7,20132
    69bc:	00104380 	call	10438 <printf>
    69c0:	003fff06 	br	69c0 <pbuf_realloc+0xac>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
    69c4:	81000303 	ldbu	r4,12(r16)
    69c8:	2000091e 	bne	r4,zero,69f0 <pbuf_realloc+0xdc>
    69cc:	18800826 	beq	r3,r2,69f0 <pbuf_realloc+0xdc>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
    69d0:	81400117 	ldw	r5,4(r16)
    69d4:	8009883a 	mov	r4,r16
    69d8:	2c0bc83a 	sub	r5,r5,r16
    69dc:	2c4b883a 	add	r5,r5,r17
    69e0:	297fffcc 	andi	r5,r5,65535
    69e4:	0005bd40 	call	5bd4 <mem_trim>
    69e8:	1021883a 	mov	r16,r2
    LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
    69ec:	10001d26 	beq	r2,zero,6a64 <pbuf_realloc+0x150>
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  q->tot_len = q->len;

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
    69f0:	81000017 	ldw	r4,0(r16)
    /* reallocate and adjust the length of the pbuf that will be split */
    q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
    LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
    69f4:	8440028d 	sth	r17,10(r16)
  q->tot_len = q->len;
    69f8:	8440020d 	sth	r17,8(r16)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
    69fc:	20000126 	beq	r4,zero,6a04 <pbuf_realloc+0xf0>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
    6a00:	00067d80 	call	67d8 <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
    6a04:	80000015 	stw	zero,0(r16)

}
    6a08:	dfc00217 	ldw	ra,8(sp)
    6a0c:	dc400117 	ldw	r17,4(sp)
    6a10:	dc000017 	ldw	r16,0(sp)
    6a14:	dec00304 	addi	sp,sp,12
    6a18:	f800283a 	ret
{
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
    6a1c:	010000b4 	movhi	r4,2
    6a20:	210d4b04 	addi	r4,r4,13612
    6a24:	014000b4 	movhi	r5,2
    6a28:	2953c704 	addi	r5,r5,20252
    6a2c:	01806d04 	movi	r6,436
    6a30:	01c000b4 	movhi	r7,2
    6a34:	39d3a904 	addi	r7,r7,20132
    6a38:	00104380 	call	10438 <printf>
    6a3c:	003fff06 	br	6a3c <pbuf_realloc+0x128>
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
    6a40:	010000b4 	movhi	r4,2
    6a44:	210d4b04 	addi	r4,r4,13612
    6a48:	014000b4 	movhi	r5,2
    6a4c:	2953d404 	addi	r5,r5,20304
    6a50:	01807304 	movi	r6,460
    6a54:	01c000b4 	movhi	r7,2
    6a58:	39d3a904 	addi	r7,r7,20132
    6a5c:	00104380 	call	10438 <printf>
    6a60:	003fff06 	br	6a60 <pbuf_realloc+0x14c>
  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
    /* reallocate and adjust the length of the pbuf that will be split */
    q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
    LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
    6a64:	010000b4 	movhi	r4,2
    6a68:	210d4b04 	addi	r4,r4,13612
    6a6c:	014000b4 	movhi	r5,2
    6a70:	2953df04 	addi	r5,r5,20348
    6a74:	01807684 	movi	r6,474
    6a78:	01c000b4 	movhi	r7,2
    6a7c:	39d3a904 	addi	r7,r7,20132
    6a80:	00104380 	call	10438 <printf>
    6a84:	003fff06 	br	6a84 <pbuf_realloc+0x170>

00006a88 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
    6a88:	defff704 	addi	sp,sp,-36
    6a8c:	dcc00315 	stw	r19,12(sp)
    6a90:	dc400115 	stw	r17,4(sp)
    6a94:	dfc00815 	stw	ra,32(sp)
    6a98:	ddc00715 	stw	r23,28(sp)
    6a9c:	dd800615 	stw	r22,24(sp)
    6aa0:	dd400515 	stw	r21,20(sp)
    6aa4:	dd000415 	stw	r20,16(sp)
    6aa8:	dc800215 	stw	r18,8(sp)
    6aac:	dc000015 	stw	r16,0(sp)
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  switch (layer) {
    6ab0:	00800044 	movi	r2,1
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
    6ab4:	3027883a 	mov	r19,r6
    6ab8:	2823883a 	mov	r17,r5
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  switch (layer) {
    6abc:	2080a126 	beq	r4,r2,6d44 <pbuf_alloc+0x2bc>
    6ac0:	2000261e 	bne	r4,zero,6b5c <pbuf_alloc+0xd4>
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
    6ac4:	04800d84 	movi	r18,54
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
  }

  switch (type) {
    6ac8:	00800084 	movi	r2,2
    6acc:	14c03036 	bltu	r2,r19,6b90 <pbuf_alloc+0x108>
    6ad0:	9800921e 	bne	r19,zero,6d1c <pbuf_alloc+0x294>
    /*r->next = NULL;*/

    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
    6ad4:	04ffff04 	movi	r19,-4
    6ad8:	288000c4 	addi	r2,r5,3
    6adc:	910004c4 	addi	r4,r18,19
    6ae0:	14c4703a 	and	r2,r2,r19
    6ae4:	24c8703a 	and	r4,r4,r19
    6ae8:	2089883a 	add	r4,r4,r2
    6aec:	213fffcc 	andi	r4,r4,65535
    6af0:	0005d480 	call	5d48 <mem_malloc>
    6af4:	1021883a 	mov	r16,r2
    if (p == NULL) {
    6af8:	1000a226 	beq	r2,zero,6d84 <pbuf_alloc+0x2fc>
      return NULL;
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
    6afc:	90bfffcc 	andi	r2,r18,65535
    6b00:	8085883a 	add	r2,r16,r2
    6b04:	108004c4 	addi	r2,r2,19
    6b08:	14e6703a 	and	r19,r2,r19
    6b0c:	84c00115 	stw	r19,4(r16)
    p->len = p->tot_len = length;
    6b10:	8440020d 	sth	r17,8(r16)
    6b14:	8440028d 	sth	r17,10(r16)
    p->next = NULL;
    6b18:	80000015 	stw	zero,0(r16)
    p->type = type;
    6b1c:	80000305 	stb	zero,12(r16)
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
    6b20:	00800044 	movi	r2,1
    6b24:	8080038d 	sth	r2,14(r16)
  /* set flags */
  p->flags = 0;
    6b28:	80000345 	stb	zero,13(r16)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
}
    6b2c:	8005883a 	mov	r2,r16
    6b30:	dfc00817 	ldw	ra,32(sp)
    6b34:	ddc00717 	ldw	r23,28(sp)
    6b38:	dd800617 	ldw	r22,24(sp)
    6b3c:	dd400517 	ldw	r21,20(sp)
    6b40:	dd000417 	ldw	r20,16(sp)
    6b44:	dcc00317 	ldw	r19,12(sp)
    6b48:	dc800217 	ldw	r18,8(sp)
    6b4c:	dc400117 	ldw	r17,4(sp)
    6b50:	dc000017 	ldw	r16,0(sp)
    6b54:	dec00904 	addi	sp,sp,36
    6b58:	f800283a 	ret
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  switch (layer) {
    6b5c:	00800084 	movi	r2,2
    6b60:	20806c26 	beq	r4,r2,6d14 <pbuf_alloc+0x28c>
    6b64:	008000c4 	movi	r2,3
    6b68:	20807826 	beq	r4,r2,6d4c <pbuf_alloc+0x2c4>
    break;
  case PBUF_RAW:
    offset = 0;
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    6b6c:	010000b4 	movhi	r4,2
    6b70:	210d4b04 	addi	r4,r4,13612
    6b74:	014000b4 	movhi	r5,2
    6b78:	2953e604 	addi	r5,r5,20376
    6b7c:	01803a04 	movi	r6,232
    6b80:	01c000b4 	movhi	r7,2
    6b84:	39d3a904 	addi	r7,r7,20132
    6b88:	00104380 	call	10438 <printf>
    6b8c:	003fff06 	br	6b8c <pbuf_alloc+0x104>
    return NULL;
  }

  switch (type) {
    6b90:	008000c4 	movi	r2,3
    6b94:	98800926 	beq	r19,r2,6bbc <pbuf_alloc+0x134>
    p->len = p->tot_len = length;
    p->next = NULL;
    p->type = type;
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
    6b98:	010000b4 	movhi	r4,2
    6b9c:	210d4b04 	addi	r4,r4,13612
    6ba0:	014000b4 	movhi	r5,2
    6ba4:	29540b04 	addi	r5,r5,20524
    6ba8:	01805504 	movi	r6,340
    6bac:	01c000b4 	movhi	r7,2
    6bb0:	39d3a904 	addi	r7,r7,20132
    6bb4:	00104380 	call	10438 <printf>
    6bb8:	003fff06 	br	6bb8 <pbuf_alloc+0x130>
  }

  switch (type) {
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
    p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
    6bbc:	01000204 	movi	r4,8
    6bc0:	00060a40 	call	60a4 <memp_malloc>
    6bc4:	1021883a 	mov	r16,r2
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
    6bc8:	10006226 	beq	r2,zero,6d54 <pbuf_alloc+0x2cc>
    }
    p->type = type;
    p->next = NULL;

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
    6bcc:	94bfffcc 	andi	r18,r18,65535
    6bd0:	1487883a 	add	r3,r2,r18
    6bd4:	18c004c4 	addi	r3,r3,19
    6bd8:	00bfff04 	movi	r2,-4
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
    6bdc:	948000c4 	addi	r18,r18,3
    }
    p->type = type;
    p->next = NULL;

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
    6be0:	1886703a 	and	r3,r3,r2
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
    6be4:	01017b04 	movi	r4,1516
    6be8:	9084703a 	and	r2,r18,r2
    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
    6bec:	8440020d 	sth	r17,8(r16)
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
      PBUF_POOL_IS_EMPTY();
      return NULL;
    }
    p->type = type;
    6bf0:	84c00305 	stb	r19,12(r16)
    p->next = NULL;
    6bf4:	80000015 	stw	zero,0(r16)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
    6bf8:	80c00115 	stw	r3,4(r16)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
    6bfc:	8c7fffcc 	andi	r17,r17,65535
    6c00:	2085c83a 	sub	r2,r4,r2
    6c04:	8880010e 	bge	r17,r2,6c0c <pbuf_alloc+0x184>
    6c08:	8805883a 	mov	r2,r17
    6c0c:	8080028d 	sth	r2,10(r16)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
    6c10:	84c17f04 	addi	r19,r16,1532
    6c14:	1887883a 	add	r3,r3,r2
    6c18:	98c05136 	bltu	r19,r3,6d60 <pbuf_alloc+0x2d8>
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
      (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
    6c1c:	00c00044 	movi	r3,1
    6c20:	80c0038d 	sth	r3,14(r16)
    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    6c24:	88a3c83a 	sub	r17,r17,r2
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
    6c28:	047fbd0e 	bge	zero,r17,6b20 <pbuf_alloc+0x98>
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
    6c2c:	01000204 	movi	r4,8
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
    6c30:	1829883a 	mov	r20,r3
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
    6c34:	00060a40 	call	60a4 <memp_malloc>
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
    6c38:	8025883a 	mov	r18,r16
        /* free chain so far allocated */
        pbuf_free(p);
        /* bail out unsuccesfully */
        return NULL;
      }
      q->type = type;
    6c3c:	05c000c4 	movi	r23,3
      q->flags = 0;
      q->next = NULL;
      /* make previous pbuf point to this pbuf */
      r->next = q;
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
    6c40:	05bfffd4 	movui	r22,65535
      q->tot_len = (u16_t)rem_len;
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
    6c44:	05417ac4 	movi	r21,1515
    6c48:	88ffffcc 	andi	r3,r17,65535
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
      if (q == NULL) {
    6c4c:	1000191e 	bne	r2,zero,6cb4 <pbuf_alloc+0x22c>
        PBUF_POOL_IS_EMPTY();
        /* free chain so far allocated */
        pbuf_free(p);
    6c50:	8009883a 	mov	r4,r16
pbuf_pool_is_empty(void)
{
#ifndef PBUF_POOL_FREE_OOSEQ_QUEUE_CALL
  SYS_ARCH_DECL_PROTECT(old_level);
  SYS_ARCH_PROTECT(old_level);
  pbuf_free_ooseq_pending = 1;
    6c54:	00800044 	movi	r2,1
      if (q == NULL) {
        PBUF_POOL_IS_EMPTY();
        /* free chain so far allocated */
        pbuf_free(p);
        /* bail out unsuccesfully */
        return NULL;
    6c58:	0021883a 	mov	r16,zero
pbuf_pool_is_empty(void)
{
#ifndef PBUF_POOL_FREE_OOSEQ_QUEUE_CALL
  SYS_ARCH_DECL_PROTECT(old_level);
  SYS_ARCH_PROTECT(old_level);
  pbuf_free_ooseq_pending = 1;
    6c5c:	d0a8b905 	stb	r2,-23836(gp)
    while (rem_len > 0) {
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
      if (q == NULL) {
        PBUF_POOL_IS_EMPTY();
        /* free chain so far allocated */
        pbuf_free(p);
    6c60:	00067d80 	call	67d8 <pbuf_free>
        /* bail out unsuccesfully */
        return NULL;
    6c64:	003fb106 	br	6b2c <pbuf_alloc+0xa4>
      r->next = q;
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
    6c68:	8807883a 	mov	r3,r17
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
    6c6c:	11000404 	addi	r4,r2,16
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
    6c70:	197fffcc 	andi	r5,r3,65535
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
    6c74:	11000115 	stw	r4,4(r2)
      r->next = q;
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
    6c78:	10c0028d 	sth	r3,10(r2)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
    6c7c:	210000cc 	andi	r4,r4,3
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
    6c80:	8963c83a 	sub	r17,r17,r5
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
    6c84:	20001a1e 	bne	r4,zero,6cf0 <pbuf_alloc+0x268>
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
    6c88:	80c0028b 	ldhu	r3,10(r16)
    6c8c:	81000117 	ldw	r4,4(r16)
    6c90:	1025883a 	mov	r18,r2
    6c94:	20c7883a 	add	r3,r4,r3
    6c98:	98c03c36 	bltu	r19,r3,6d8c <pbuf_alloc+0x304>
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
    6c9c:	1500038d 	sth	r20,14(r2)
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
    6ca0:	047f9f0e 	bge	zero,r17,6b20 <pbuf_alloc+0x98>
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
    6ca4:	01000204 	movi	r4,8
    6ca8:	00060a40 	call	60a4 <memp_malloc>
      r->next = q;
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
    6cac:	88ffffcc 	andi	r3,r17,65535
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
      if (q == NULL) {
    6cb0:	103fe726 	beq	r2,zero,6c50 <pbuf_alloc+0x1c8>
        /* bail out unsuccesfully */
        return NULL;
      }
      q->type = type;
      q->flags = 0;
      q->next = NULL;
    6cb4:	10000015 	stw	zero,0(r2)
      /* make previous pbuf point to this pbuf */
      r->next = q;
    6cb8:	90800015 	stw	r2,0(r18)
        /* free chain so far allocated */
        pbuf_free(p);
        /* bail out unsuccesfully */
        return NULL;
      }
      q->type = type;
    6cbc:	15c00305 	stb	r23,12(r2)
      q->flags = 0;
    6cc0:	10000345 	stb	zero,13(r2)
      q->next = NULL;
      /* make previous pbuf point to this pbuf */
      r->next = q;
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
    6cc4:	8d803a26 	beq	r17,r22,6db0 <pbuf_alloc+0x328>
      q->tot_len = (u16_t)rem_len;
    6cc8:	1440020d 	sth	r17,8(r2)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
    6ccc:	a8ffe62e 	bgeu	r21,r3,6c68 <pbuf_alloc+0x1e0>
    6cd0:	00c17b04 	movi	r3,1516
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
    6cd4:	11000404 	addi	r4,r2,16
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
    6cd8:	197fffcc 	andi	r5,r3,65535
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
    6cdc:	11000115 	stw	r4,4(r2)
      r->next = q;
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
    6ce0:	10c0028d 	sth	r3,10(r2)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
    6ce4:	210000cc 	andi	r4,r4,3
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
    6ce8:	8963c83a 	sub	r17,r17,r5
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
    6cec:	203fe626 	beq	r4,zero,6c88 <pbuf_alloc+0x200>
    6cf0:	010000b4 	movhi	r4,2
    6cf4:	210d4b04 	addi	r4,r4,13612
    6cf8:	014000b4 	movhi	r5,2
    6cfc:	2953ff04 	addi	r5,r5,20476
    6d00:	01804904 	movi	r6,292
    6d04:	01c000b4 	movhi	r7,2
    6d08:	39d3a904 	addi	r7,r7,20132
    6d0c:	00104380 	call	10438 <printf>
    6d10:	003fff06 	br	6d10 <pbuf_alloc+0x288>
    /* add room for IP layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
    break;
  case PBUF_LINK:
    /* add room for link layer header */
    offset = PBUF_LINK_HLEN;
    6d14:	04800384 	movi	r18,14
    break;
    6d18:	003f6b06 	br	6ac8 <pbuf_alloc+0x40>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = (struct pbuf *)memp_malloc(MEMP_PBUF);
    6d1c:	010001c4 	movi	r4,7
    6d20:	00060a40 	call	60a4 <memp_malloc>
    6d24:	1021883a 	mov	r16,r2
    if (p == NULL) {
    6d28:	10001626 	beq	r2,zero,6d84 <pbuf_alloc+0x2fc>
                  ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
    6d2c:	10000115 	stw	zero,4(r2)
    p->len = p->tot_len = length;
    6d30:	1440020d 	sth	r17,8(r2)
    6d34:	1440028d 	sth	r17,10(r2)
    p->next = NULL;
    6d38:	10000015 	stw	zero,0(r2)
    p->type = type;
    6d3c:	14c00305 	stb	r19,12(r2)
    break;
    6d40:	003f7706 	br	6b20 <pbuf_alloc+0x98>
    /* add room for transport (often TCP) layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
    break;
  case PBUF_IP:
    /* add room for IP layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
    6d44:	04800884 	movi	r18,34
    6d48:	003f5f06 	br	6ac8 <pbuf_alloc+0x40>
  case PBUF_LINK:
    /* add room for link layer header */
    offset = PBUF_LINK_HLEN;
    break;
  case PBUF_RAW:
    offset = 0;
    6d4c:	0025883a 	mov	r18,zero
    break;
    6d50:	003f5d06 	br	6ac8 <pbuf_alloc+0x40>
pbuf_pool_is_empty(void)
{
#ifndef PBUF_POOL_FREE_OOSEQ_QUEUE_CALL
  SYS_ARCH_DECL_PROTECT(old_level);
  SYS_ARCH_PROTECT(old_level);
  pbuf_free_ooseq_pending = 1;
    6d54:	00800044 	movi	r2,1
    6d58:	d0a8b905 	stb	r2,-23836(gp)
    /* allocate head of pbuf chain into p */
    p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
      PBUF_POOL_IS_EMPTY();
      return NULL;
    6d5c:	003f7306 	br	6b2c <pbuf_alloc+0xa4>
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
    6d60:	010000b4 	movhi	r4,2
    6d64:	210d4b04 	addi	r4,r4,13612
    6d68:	014000b4 	movhi	r5,2
    6d6c:	2953ed04 	addi	r5,r5,20404
    6d70:	01804084 	movi	r6,258
    6d74:	01c000b4 	movhi	r7,2
    6d78:	39d3a904 	addi	r7,r7,20132
    6d7c:	00104380 	call	10438 <printf>
    6d80:	003fff06 	br	6d80 <pbuf_alloc+0x2f8>
    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
    if (p == NULL) {
      return NULL;
    6d84:	0021883a 	mov	r16,zero
    6d88:	003f6806 	br	6b2c <pbuf_alloc+0xa4>
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
    6d8c:	010000b4 	movhi	r4,2
    6d90:	210d4b04 	addi	r4,r4,13612
    6d94:	014000b4 	movhi	r5,2
    6d98:	2953ed04 	addi	r5,r5,20404
    6d9c:	018049c4 	movi	r6,295
    6da0:	01c000b4 	movhi	r7,2
    6da4:	39d3a904 	addi	r7,r7,20132
    6da8:	00104380 	call	10438 <printf>
    6dac:	003fff06 	br	6dac <pbuf_alloc+0x324>
      q->flags = 0;
      q->next = NULL;
      /* make previous pbuf point to this pbuf */
      r->next = q;
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
    6db0:	010000b4 	movhi	r4,2
    6db4:	210d4b04 	addi	r4,r4,13612
    6db8:	014000b4 	movhi	r5,2
    6dbc:	2953fa04 	addi	r5,r5,20456
    6dc0:	01804784 	movi	r6,286
    6dc4:	01c000b4 	movhi	r7,2
    6dc8:	39d3a904 	addi	r7,r7,20132
    6dcc:	00104380 	call	10438 <printf>
    6dd0:	003fff06 	br	6dd0 <pbuf_alloc+0x348>

00006dd4 <pbuf_clen>:
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
    6dd4:	0005883a 	mov	r2,zero
    6dd8:	20000426 	beq	r4,zero,6dec <pbuf_clen+0x18>
    ++len;
    p = p->next;
    6ddc:	21000017 	ldw	r4,0(r4)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
    ++len;
    6de0:	10800044 	addi	r2,r2,1
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
    6de4:	203ffd1e 	bne	r4,zero,6ddc <pbuf_clen+0x8>
    6de8:	f800283a 	ret
    ++len;
    p = p->next;
  }
  return len;
}
    6dec:	f800283a 	ret

00006df0 <pbuf_ref>:
void
pbuf_ref(struct pbuf *p)
{
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
    6df0:	20000326 	beq	r4,zero,6e00 <pbuf_ref+0x10>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
    6df4:	2080038b 	ldhu	r2,14(r4)
    6df8:	10800044 	addi	r2,r2,1
    6dfc:	2080038d 	sth	r2,14(r4)
    6e00:	f800283a 	ret

00006e04 <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
    6e04:	deffff04 	addi	sp,sp,-4
    6e08:	dfc00015 	stw	ra,0(sp)
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
    6e0c:	20001826 	beq	r4,zero,6e70 <pbuf_cat+0x6c>
    6e10:	28001726 	beq	r5,zero,6e70 <pbuf_cat+0x6c>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    6e14:	20800017 	ldw	r2,0(r4)
    6e18:	2007883a 	mov	r3,r4
    6e1c:	1000021e 	bne	r2,zero,6e28 <pbuf_cat+0x24>
    6e20:	00002506 	br	6eb8 <pbuf_cat+0xb4>
    6e24:	2005883a 	mov	r2,r4
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
    6e28:	1980020b 	ldhu	r6,8(r3)
    6e2c:	29c0020b 	ldhu	r7,8(r5)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    6e30:	11000017 	ldw	r4,0(r2)
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
    6e34:	398d883a 	add	r6,r7,r6
    6e38:	1980020d 	sth	r6,8(r3)
    6e3c:	1007883a 	mov	r3,r2

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    6e40:	203ff81e 	bne	r4,zero,6e24 <pbuf_cat+0x20>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
    6e44:	10c0020b 	ldhu	r3,8(r2)
    6e48:	1100028b 	ldhu	r4,10(r2)
    6e4c:	19bfffcc 	andi	r6,r3,65535
    6e50:	3100101e 	bne	r6,r4,6e94 <pbuf_cat+0x90>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
    6e54:	2900020b 	ldhu	r4,8(r5)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
    6e58:	11400015 	stw	r5,0(r2)
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
    6e5c:	20c7883a 	add	r3,r4,r3
    6e60:	10c0020d 	sth	r3,8(r2)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
    6e64:	dfc00017 	ldw	ra,0(sp)
    6e68:	dec00104 	addi	sp,sp,4
    6e6c:	f800283a 	ret
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
    6e70:	010000b4 	movhi	r4,2
    6e74:	210d4b04 	addi	r4,r4,13612
    6e78:	014000b4 	movhi	r5,2
    6e7c:	29541204 	addi	r5,r5,20552
    6e80:	0180bb84 	movi	r6,750
    6e84:	01c000b4 	movhi	r7,2
    6e88:	39d3a904 	addi	r7,r7,20132
    6e8c:	00104380 	call	10438 <printf>
    6e90:	003fff06 	br	6e90 <pbuf_cat+0x8c>
  for (p = h; p->next != NULL; p = p->next) {
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
    6e94:	010000b4 	movhi	r4,2
    6e98:	210d4b04 	addi	r4,r4,13612
    6e9c:	014000b4 	movhi	r5,2
    6ea0:	29542004 	addi	r5,r5,20608
    6ea4:	0180bd84 	movi	r6,758
    6ea8:	01c000b4 	movhi	r7,2
    6eac:	39d3a904 	addi	r7,r7,20132
    6eb0:	00104380 	call	10438 <printf>
    6eb4:	003fff06 	br	6eb4 <pbuf_cat+0xb0>

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    6eb8:	2005883a 	mov	r2,r4
    6ebc:	003fe106 	br	6e44 <pbuf_cat+0x40>

00006ec0 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
    6ec0:	defffe04 	addi	sp,sp,-8
    6ec4:	dc000015 	stw	r16,0(sp)
    6ec8:	2821883a 	mov	r16,r5
    6ecc:	dfc00115 	stw	ra,4(sp)
  pbuf_cat(h, t);
    6ed0:	0006e040 	call	6e04 <pbuf_cat>
void
pbuf_ref(struct pbuf *p)
{
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
    6ed4:	80000326 	beq	r16,zero,6ee4 <pbuf_chain+0x24>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
    6ed8:	8080038b 	ldhu	r2,14(r16)
    6edc:	10800044 	addi	r2,r2,1
    6ee0:	8080038d 	sth	r2,14(r16)
{
  pbuf_cat(h, t);
  /* t is now referenced by h */
  pbuf_ref(t);
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
    6ee4:	dfc00117 	ldw	ra,4(sp)
    6ee8:	dc000017 	ldw	r16,0(sp)
    6eec:	dec00204 	addi	sp,sp,8
    6ef0:	f800283a 	ret

00006ef4 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
    6ef4:	defffd04 	addi	sp,sp,-12
    6ef8:	dc400115 	stw	r17,4(sp)
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
    6efc:	24400017 	ldw	r17,0(r4)
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
    6f00:	dc000015 	stw	r16,0(sp)
    6f04:	dfc00215 	stw	ra,8(sp)
    6f08:	2021883a 	mov	r16,r4
  /* tail */
  q = p->next;
  /* pbuf has successor in chain? */
  if (q != NULL) {
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
    6f0c:	20c0020b 	ldhu	r3,8(r4)
    6f10:	2080028b 	ldhu	r2,10(r4)
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
  /* pbuf has successor in chain? */
  if (q != NULL) {
    6f14:	88000e26 	beq	r17,zero,6f50 <pbuf_dechain+0x5c>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
    6f18:	8940020b 	ldhu	r5,8(r17)
    6f1c:	19bfffcc 	andi	r6,r3,65535
    6f20:	113fffcc 	andi	r4,r2,65535
    6f24:	3109c83a 	sub	r4,r6,r4
    6f28:	29001326 	beq	r5,r4,6f78 <pbuf_dechain+0x84>
    6f2c:	010000b4 	movhi	r4,2
    6f30:	210d4b04 	addi	r4,r4,13612
    6f34:	014000b4 	movhi	r5,2
    6f38:	29542c04 	addi	r5,r5,20656
    6f3c:	0180cb04 	movi	r6,812
    6f40:	01c000b4 	movhi	r7,2
    6f44:	39d3a904 	addi	r7,r7,20132
    6f48:	00104380 	call	10438 <printf>
    6f4c:	003fff06 	br	6f4c <pbuf_dechain+0x58>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
    6f50:	18801426 	beq	r3,r2,6fa4 <pbuf_dechain+0xb0>
    6f54:	010000b4 	movhi	r4,2
    6f58:	210d4b04 	addi	r4,r4,13612
    6f5c:	014000b4 	movhi	r5,2
    6f60:	29543504 	addi	r5,r5,20692
    6f64:	0180cf44 	movi	r6,829
    6f68:	01c000b4 	movhi	r7,2
    6f6c:	39d3a904 	addi	r7,r7,20132
    6f70:	00104380 	call	10438 <printf>
    6f74:	003fff06 	br	6f74 <pbuf_dechain+0x80>
  /* pbuf has successor in chain? */
  if (q != NULL) {
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
    6f78:	1887c83a 	sub	r3,r3,r2
    6f7c:	88c0020d 	sth	r3,8(r17)
    p->next = NULL;
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
    6f80:	8809883a 	mov	r4,r17
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
    /* decouple pbuf from remainder */
    p->next = NULL;
    6f84:	80000015 	stw	zero,0(r16)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
    6f88:	8080020d 	sth	r2,8(r16)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
    6f8c:	00067d80 	call	67d8 <pbuf_free>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
    6f90:	8100020b 	ldhu	r4,8(r16)
    6f94:	80c0028b 	ldhu	r3,10(r16)
    6f98:	20ffee1e 	bne	r4,r3,6f54 <pbuf_dechain+0x60>
  return ((tail_gone > 0) ? NULL : q);
    6f9c:	10803fcc 	andi	r2,r2,255
    6fa0:	10000126 	beq	r2,zero,6fa8 <pbuf_dechain+0xb4>
    6fa4:	0023883a 	mov	r17,zero
}
    6fa8:	8805883a 	mov	r2,r17
    6fac:	dfc00217 	ldw	ra,8(sp)
    6fb0:	dc400117 	ldw	r17,4(sp)
    6fb4:	dc000017 	ldw	r16,0(sp)
    6fb8:	dec00304 	addi	sp,sp,12
    6fbc:	f800283a 	ret

00006fc0 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
    6fc0:	defffa04 	addi	sp,sp,-24
    6fc4:	dc400115 	stw	r17,4(sp)
    6fc8:	dc000015 	stw	r16,0(sp)
    6fcc:	dfc00515 	stw	ra,20(sp)
    6fd0:	dd000415 	stw	r20,16(sp)
    6fd4:	dcc00315 	stw	r19,12(sp)
    6fd8:	dc800215 	stw	r18,8(sp)
    6fdc:	2023883a 	mov	r17,r4
    6fe0:	2821883a 	mov	r16,r5

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
    6fe4:	20000426 	beq	r4,zero,6ff8 <pbuf_copy+0x38>
    6fe8:	28000326 	beq	r5,zero,6ff8 <pbuf_copy+0x38>
    6fec:	20c0020b 	ldhu	r3,8(r4)
    6ff0:	2880020b 	ldhu	r2,8(r5)
    6ff4:	1880092e 	bgeu	r3,r2,701c <pbuf_copy+0x5c>
    6ff8:	010000b4 	movhi	r4,2
    6ffc:	210d4b04 	addi	r4,r4,13612
    7000:	014000b4 	movhi	r5,2
    7004:	29543b04 	addi	r5,r5,20716
    7008:	0180d744 	movi	r6,861
    700c:	01c000b4 	movhi	r7,2
    7010:	39d3a904 	addi	r7,r7,20132
    7014:	00104380 	call	10438 <printf>
    7018:	003fff06 	br	7018 <pbuf_copy+0x58>
    701c:	0027883a 	mov	r19,zero
    7020:	0025883a 	mov	r18,zero

  /* iterate through pbuf chain */
  do
  {
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
    7024:	8900028b 	ldhu	r4,10(r17)
    7028:	8500028b 	ldhu	r20,10(r16)
    702c:	90bfffcc 	andi	r2,r18,65535
    7030:	21bfffcc 	andi	r6,r4,65535
    7034:	a17fffcc 	andi	r5,r20,65535
    7038:	98ffffcc 	andi	r3,r19,65535
    703c:	308dc83a 	sub	r6,r6,r2
    7040:	28cbc83a 	sub	r5,r5,r3
    7044:	31402b16 	blt	r6,r5,70f4 <pbuf_copy+0x134>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
    7048:	a4e9c83a 	sub	r20,r20,r19
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    704c:	89000117 	ldw	r4,4(r17)
    7050:	81400117 	ldw	r5,4(r16)
    7054:	a1bfffcc 	andi	r6,r20,65535
    7058:	2089883a 	add	r4,r4,r2
    705c:	28cb883a 	add	r5,r5,r3
    7060:	00102380 	call	10238 <memcpy>
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    7064:	88c0028b 	ldhu	r3,10(r17)
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    7068:	a4a5883a 	add	r18,r20,r18
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    706c:	90bfffcc 	andi	r2,r18,65535
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
    7070:	a4e7883a 	add	r19,r20,r19
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    7074:	18802c36 	bltu	r3,r2,7128 <pbuf_copy+0x168>
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    7078:	8100028b 	ldhu	r4,10(r16)
    707c:	997fffcc 	andi	r5,r19,65535
    7080:	21403c36 	bltu	r4,r5,7174 <pbuf_copy+0x1b4>
    if (offset_from >= p_from->len) {
    7084:	29000236 	bltu	r5,r4,7090 <pbuf_copy+0xd0>
      /* on to next p_from (if any) */
      offset_from = 0;
      p_from = p_from->next;
    7088:	84000017 	ldw	r16,0(r16)
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
      /* on to next p_from (if any) */
      offset_from = 0;
    708c:	0027883a 	mov	r19,zero
      p_from = p_from->next;
    }
    if (offset_to == p_to->len) {
    7090:	10c01426 	beq	r2,r3,70e4 <pbuf_copy+0x124>
      offset_to = 0;
      p_to = p_to->next;
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
    7094:	80000326 	beq	r16,zero,70a4 <pbuf_copy+0xe4>
    7098:	80c0028b 	ldhu	r3,10(r16)
    709c:	8080020b 	ldhu	r2,8(r16)
    70a0:	18801626 	beq	r3,r2,70fc <pbuf_copy+0x13c>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
    70a4:	88c0028b 	ldhu	r3,10(r17)
    70a8:	8880020b 	ldhu	r2,8(r17)
    70ac:	18800226 	beq	r3,r2,70b8 <pbuf_copy+0xf8>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
    70b0:	803fdc1e 	bne	r16,zero,7024 <pbuf_copy+0x64>
    70b4:	00002606 	br	7150 <pbuf_copy+0x190>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
    70b8:	88800017 	ldw	r2,0(r17)
    70bc:	103ffc26 	beq	r2,zero,70b0 <pbuf_copy+0xf0>
    70c0:	010000b4 	movhi	r4,2
    70c4:	210d4b04 	addi	r4,r4,13612
    70c8:	014000b4 	movhi	r5,2
    70cc:	29545804 	addi	r5,r5,20832
    70d0:	0180e0c4 	movi	r6,899
    70d4:	01c000b4 	movhi	r7,2
    70d8:	39d3a904 	addi	r7,r7,20132
    70dc:	00104380 	call	10438 <printf>
    70e0:	003fff06 	br	70e0 <pbuf_copy+0x120>
      p_from = p_from->next;
    }
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
    70e4:	8c400017 	ldw	r17,0(r17)
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
    70e8:	88001826 	beq	r17,zero,714c <pbuf_copy+0x18c>
      offset_from = 0;
      p_from = p_from->next;
    }
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
    70ec:	0025883a 	mov	r18,zero
    70f0:	003fe806 	br	7094 <pbuf_copy+0xd4>
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    70f4:	24a9c83a 	sub	r20,r4,r18
    70f8:	003fd406 	br	704c <pbuf_copy+0x8c>
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
    70fc:	80800017 	ldw	r2,0(r16)
    7100:	103fe826 	beq	r2,zero,70a4 <pbuf_copy+0xe4>
    7104:	010000b4 	movhi	r4,2
    7108:	210d4b04 	addi	r4,r4,13612
    710c:	014000b4 	movhi	r5,2
    7110:	29545804 	addi	r5,r5,20832
    7114:	0180df84 	movi	r6,894
    7118:	01c000b4 	movhi	r7,2
    711c:	39d3a904 	addi	r7,r7,20132
    7120:	00104380 	call	10438 <printf>
    7124:	003fff06 	br	7124 <pbuf_copy+0x164>
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    7128:	010000b4 	movhi	r4,2
    712c:	210d4b04 	addi	r4,r4,13612
    7130:	014000b4 	movhi	r5,2
    7134:	29544704 	addi	r5,r5,20764
    7138:	0180db44 	movi	r6,877
    713c:	01c000b4 	movhi	r7,2
    7140:	39d3a904 	addi	r7,r7,20132
    7144:	00104380 	call	10438 <printf>
    7148:	003fff06 	br	7148 <pbuf_copy+0x188>
    }
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
    714c:	8000121e 	bne	r16,zero,7198 <pbuf_copy+0x1d8>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
    7150:	0005883a 	mov	r2,zero
    7154:	dfc00517 	ldw	ra,20(sp)
    7158:	dd000417 	ldw	r20,16(sp)
    715c:	dcc00317 	ldw	r19,12(sp)
    7160:	dc800217 	ldw	r18,8(sp)
    7164:	dc400117 	ldw	r17,4(sp)
    7168:	dc000017 	ldw	r16,0(sp)
    716c:	dec00604 	addi	sp,sp,24
    7170:	f800283a 	ret
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    7174:	010000b4 	movhi	r4,2
    7178:	210d4b04 	addi	r4,r4,13612
    717c:	014000b4 	movhi	r5,2
    7180:	29544d04 	addi	r5,r5,20788
    7184:	0180db84 	movi	r6,878
    7188:	01c000b4 	movhi	r7,2
    718c:	39d3a904 	addi	r7,r7,20132
    7190:	00104380 	call	10438 <printf>
    7194:	003fff06 	br	7194 <pbuf_copy+0x1d4>
    }
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
    7198:	010000b4 	movhi	r4,2
    719c:	210d4b04 	addi	r4,r4,13612
    71a0:	014000b4 	movhi	r5,2
    71a4:	29545404 	addi	r5,r5,20816
    71a8:	0180de04 	movi	r6,888
    71ac:	01c000b4 	movhi	r7,2
    71b0:	39d3a904 	addi	r7,r7,20132
    71b4:	00104380 	call	10438 <printf>
    71b8:	003fff06 	br	71b8 <pbuf_copy+0x1f8>

000071bc <pbuf_copy_partial>:
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
    71bc:	defff904 	addi	sp,sp,-28
    71c0:	dd000415 	stw	r20,16(sp)
    71c4:	dc800215 	stw	r18,8(sp)
    71c8:	dfc00615 	stw	ra,24(sp)
    71cc:	dd400515 	stw	r21,20(sp)
    71d0:	dcc00315 	stw	r19,12(sp)
    71d4:	dc400115 	stw	r17,4(sp)
    71d8:	dc000015 	stw	r16,0(sp)
    71dc:	2829883a 	mov	r20,r5
    71e0:	3025883a 	mov	r18,r6
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
    71e4:	20002c26 	beq	r4,zero,7298 <pbuf_copy_partial+0xdc>
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
    71e8:	28003426 	beq	r5,zero,72bc <pbuf_copy_partial+0x100>
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    71ec:	323fffcc 	andi	r8,r6,65535
    71f0:	002b883a 	mov	r21,zero
    71f4:	40001e26 	beq	r8,zero,7270 <pbuf_copy_partial+0xb4>
    71f8:	2021883a 	mov	r16,r4
    71fc:	002b883a 	mov	r21,zero
    7200:	0027883a 	mov	r19,zero
    7204:	00000606 	br	7220 <pbuf_copy_partial+0x64>
    if ((offset != 0) && (offset >= p->len)) {
    7208:	88bfffcc 	andi	r2,r17,65535
    720c:	18800936 	bltu	r3,r2,7234 <pbuf_copy_partial+0x78>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
    7210:	3c4fc83a 	sub	r7,r7,r17
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    7214:	84000017 	ldw	r16,0(r16)
    7218:	40001526 	beq	r8,zero,7270 <pbuf_copy_partial+0xb4>
    721c:	80001426 	beq	r16,zero,7270 <pbuf_copy_partial+0xb4>
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
    7220:	993fffcc 	andi	r4,r19,65535
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    if ((offset != 0) && (offset >= p->len)) {
    7224:	38ffffcc 	andi	r3,r7,65535
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
    7228:	a109883a 	add	r4,r20,r4
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    if ((offset != 0) && (offset >= p->len)) {
    722c:	8440028b 	ldhu	r17,10(r16)
    7230:	183ff51e 	bne	r3,zero,7208 <pbuf_copy_partial+0x4c>
    7234:	89e3c83a 	sub	r17,r17,r7
    7238:	89bfffcc 	andi	r6,r17,65535
    723c:	4180022e 	bgeu	r8,r6,7248 <pbuf_copy_partial+0x8c>
    7240:	9023883a 	mov	r17,r18
    7244:	91bfffcc 	andi	r6,r18,65535
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
    7248:	81400117 	ldw	r5,4(r16)
      copied_total += buf_copy_len;
      left += buf_copy_len;
      len -= buf_copy_len;
    724c:	9465c83a 	sub	r18,r18,r17
      buf_copy_len = p->len - offset;
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
      copied_total += buf_copy_len;
    7250:	8d6b883a 	add	r21,r17,r21
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
    7254:	28cb883a 	add	r5,r5,r3
    7258:	00102380 	call	10238 <memcpy>
    725c:	923fffcc 	andi	r8,r18,65535
      copied_total += buf_copy_len;
      left += buf_copy_len;
    7260:	8ce7883a 	add	r19,r17,r19
      len -= buf_copy_len;
      offset = 0;
    7264:	000f883a 	mov	r7,zero
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    7268:	84000017 	ldw	r16,0(r16)
    726c:	403feb1e 	bne	r8,zero,721c <pbuf_copy_partial+0x60>
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
}
    7270:	a805883a 	mov	r2,r21
    7274:	dfc00617 	ldw	ra,24(sp)
    7278:	dd400517 	ldw	r21,20(sp)
    727c:	dd000417 	ldw	r20,16(sp)
    7280:	dcc00317 	ldw	r19,12(sp)
    7284:	dc800217 	ldw	r18,8(sp)
    7288:	dc400117 	ldw	r17,4(sp)
    728c:	dc000017 	ldw	r16,0(sp)
    7290:	dec00704 	addi	sp,sp,28
    7294:	f800283a 	ret
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
    7298:	010000b4 	movhi	r4,2
    729c:	210d4b04 	addi	r4,r4,13612
    72a0:	014000b4 	movhi	r5,2
    72a4:	29546304 	addi	r5,r5,20876
    72a8:	0180e744 	movi	r6,925
    72ac:	01c000b4 	movhi	r7,2
    72b0:	39d3a904 	addi	r7,r7,20132
    72b4:	00104380 	call	10438 <printf>
    72b8:	003fff06 	br	72b8 <pbuf_copy_partial+0xfc>
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
    72bc:	010000b4 	movhi	r4,2
    72c0:	210d4b04 	addi	r4,r4,13612
    72c4:	014000b4 	movhi	r5,2
    72c8:	29546b04 	addi	r5,r5,20908
    72cc:	0180e784 	movi	r6,926
    72d0:	01c000b4 	movhi	r7,2
    72d4:	39d3a904 	addi	r7,r7,20132
    72d8:	00104380 	call	10438 <printf>
    72dc:	003fff06 	br	72dc <pbuf_copy_partial+0x120>

000072e0 <pbuf_take>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
{
    72e0:	defff904 	addi	sp,sp,-28
    72e4:	dd400515 	stw	r21,20(sp)
    72e8:	dfc00615 	stw	ra,24(sp)
    72ec:	dd000415 	stw	r20,16(sp)
    72f0:	dcc00315 	stw	r19,12(sp)
    72f4:	dc800215 	stw	r18,8(sp)
    72f8:	dc400115 	stw	r17,4(sp)
    72fc:	dc000015 	stw	r16,0(sp)
    7300:	282b883a 	mov	r21,r5
  struct pbuf *p;
  u16_t buf_copy_len;
  u16_t total_copy_len = len;
  u16_t copied_total = 0;

  LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return 0;);
    7304:	20002e26 	beq	r4,zero,73c0 <pbuf_take+0xe0>
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return 0;);
    7308:	28004226 	beq	r5,zero,7414 <pbuf_take+0x134>

  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
    730c:	2080020b 	ldhu	r2,8(r4)
    7310:	353fffcc 	andi	r20,r6,65535
    7314:	15003d36 	bltu	r2,r20,740c <pbuf_take+0x12c>
    return ERR_ARG;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; total_copy_len != 0; p = p->next) {
    7318:	a0003226 	beq	r20,zero,73e4 <pbuf_take+0x104>
    731c:	3023883a 	mov	r17,r6
    7320:	2021883a 	mov	r16,r4
    7324:	0027883a 	mov	r19,zero
    7328:	a005883a 	mov	r2,r20
    732c:	00000106 	br	7334 <pbuf_take+0x54>
    LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
    7330:	80001a26 	beq	r16,zero,739c <pbuf_take+0xbc>
    buf_copy_len = total_copy_len;
    if (buf_copy_len > p->len) {
    7334:	80c0028b 	ldhu	r3,10(r16)
      /* this pbuf cannot hold all remaining data */
      buf_copy_len = p->len;
    }
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
    7338:	997fffcc 	andi	r5,r19,65535
    733c:	a94b883a 	add	r5,r21,r5
    7340:	193fffcc 	andi	r4,r3,65535
    7344:	8825883a 	mov	r18,r17
    7348:	2080012e 	bgeu	r4,r2,7350 <pbuf_take+0x70>
    734c:	1825883a 	mov	r18,r3
    7350:	81000117 	ldw	r4,4(r16)
    7354:	91bfffcc 	andi	r6,r18,65535
    total_copy_len -= buf_copy_len;
    7358:	8ca3c83a 	sub	r17,r17,r18
    if (buf_copy_len > p->len) {
      /* this pbuf cannot hold all remaining data */
      buf_copy_len = p->len;
    }
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
    735c:	00102380 	call	10238 <memcpy>
  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
    return ERR_ARG;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; total_copy_len != 0; p = p->next) {
    7360:	88bfffcc 	andi	r2,r17,65535
    7364:	84000017 	ldw	r16,0(r16)
      buf_copy_len = p->len;
    }
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
    total_copy_len -= buf_copy_len;
    copied_total += buf_copy_len;
    7368:	94e7883a 	add	r19,r18,r19
  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
    return ERR_ARG;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; total_copy_len != 0; p = p->next) {
    736c:	103ff01e 	bne	r2,zero,7330 <pbuf_take+0x50>
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
    total_copy_len -= buf_copy_len;
    copied_total += buf_copy_len;
  }
  LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
    7370:	9cffffcc 	andi	r19,r19,65535
    7374:	a4c01b26 	beq	r20,r19,73e4 <pbuf_take+0x104>
    7378:	010000b4 	movhi	r4,2
    737c:	210d4b04 	addi	r4,r4,13612
    7380:	014000b4 	movhi	r5,2
    7384:	29548704 	addi	r5,r5,21020
    7388:	0180f844 	movi	r6,993
    738c:	01c000b4 	movhi	r7,2
    7390:	39d3a904 	addi	r7,r7,20132
    7394:	00104380 	call	10438 <printf>
    7398:	003fff06 	br	7398 <pbuf_take+0xb8>
    return ERR_ARG;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; total_copy_len != 0; p = p->next) {
    LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
    739c:	010000b4 	movhi	r4,2
    73a0:	210d4b04 	addi	r4,r4,13612
    73a4:	014000b4 	movhi	r5,2
    73a8:	29548104 	addi	r5,r5,20996
    73ac:	0180f584 	movi	r6,982
    73b0:	01c000b4 	movhi	r7,2
    73b4:	39d3a904 	addi	r7,r7,20132
    73b8:	00104380 	call	10438 <printf>
    73bc:	003fff06 	br	73bc <pbuf_take+0xdc>
  struct pbuf *p;
  u16_t buf_copy_len;
  u16_t total_copy_len = len;
  u16_t copied_total = 0;

  LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return 0;);
    73c0:	010000b4 	movhi	r4,2
    73c4:	210d4b04 	addi	r4,r4,13612
    73c8:	014000b4 	movhi	r5,2
    73cc:	29547404 	addi	r5,r5,20944
    73d0:	0180f344 	movi	r6,973
    73d4:	01c000b4 	movhi	r7,2
    73d8:	39d3a904 	addi	r7,r7,20132
    73dc:	00104380 	call	10438 <printf>
    73e0:	003fff06 	br	73e0 <pbuf_take+0x100>
    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
    total_copy_len -= buf_copy_len;
    copied_total += buf_copy_len;
  }
  LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
  return ERR_OK;
    73e4:	0005883a 	mov	r2,zero
}
    73e8:	dfc00617 	ldw	ra,24(sp)
    73ec:	dd400517 	ldw	r21,20(sp)
    73f0:	dd000417 	ldw	r20,16(sp)
    73f4:	dcc00317 	ldw	r19,12(sp)
    73f8:	dc800217 	ldw	r18,8(sp)
    73fc:	dc400117 	ldw	r17,4(sp)
    7400:	dc000017 	ldw	r16,0(sp)
    7404:	dec00704 	addi	sp,sp,28
    7408:	f800283a 	ret

  LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return 0;);
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return 0;);

  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
    return ERR_ARG;
    740c:	00bffc84 	movi	r2,-14
    7410:	003ff506 	br	73e8 <pbuf_take+0x108>
  u16_t buf_copy_len;
  u16_t total_copy_len = len;
  u16_t copied_total = 0;

  LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return 0;);
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return 0;);
    7414:	010000b4 	movhi	r4,2
    7418:	210d4b04 	addi	r4,r4,13612
    741c:	014000b4 	movhi	r5,2
    7420:	29547a04 	addi	r5,r5,20968
    7424:	0180f384 	movi	r6,974
    7428:	01c000b4 	movhi	r7,2
    742c:	39d3a904 	addi	r7,r7,20132
    7430:	00104380 	call	10438 <printf>
    7434:	003fff06 	br	7434 <pbuf_take+0x154>

00007438 <pbuf_coalesce>:
struct pbuf*
pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
{
  struct pbuf *q;
  err_t err;
  if (p->next == NULL) {
    7438:	20800017 	ldw	r2,0(r4)
 * @return a new, single pbuf (p->next is NULL)
 *         or the old pbuf if allocation fails
 */
struct pbuf*
pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
{
    743c:	defffd04 	addi	sp,sp,-12
    7440:	dc000015 	stw	r16,0(sp)
    7444:	dfc00215 	stw	ra,8(sp)
    7448:	dc400115 	stw	r17,4(sp)
    744c:	2021883a 	mov	r16,r4
    7450:	2809883a 	mov	r4,r5
  struct pbuf *q;
  err_t err;
  if (p->next == NULL) {
    7454:	10001826 	beq	r2,zero,74b8 <pbuf_coalesce+0x80>
    return p;
  }
  q = pbuf_alloc(layer, p->tot_len, PBUF_RAM);
    7458:	8140020b 	ldhu	r5,8(r16)
    745c:	000d883a 	mov	r6,zero
    7460:	0006a880 	call	6a88 <pbuf_alloc>
    7464:	1023883a 	mov	r17,r2
  if (q == NULL) {
    7468:	10001326 	beq	r2,zero,74b8 <pbuf_coalesce+0x80>
    /* @todo: what do we do now? */
    return p;
  }
  err = pbuf_copy(q, p);
    746c:	1009883a 	mov	r4,r2
    7470:	800b883a 	mov	r5,r16
    7474:	0006fc00 	call	6fc0 <pbuf_copy>
  LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
    7478:	10803fcc 	andi	r2,r2,255
    747c:	1080201c 	xori	r2,r2,128
    7480:	10bfe004 	addi	r2,r2,-128
    7484:	10000926 	beq	r2,zero,74ac <pbuf_coalesce+0x74>
    7488:	010000b4 	movhi	r4,2
    748c:	210d4b04 	addi	r4,r4,13612
    7490:	014000b4 	movhi	r5,2
    7494:	29548d04 	addi	r5,r5,21044
    7498:	0180ffc4 	movi	r6,1023
    749c:	01c000b4 	movhi	r7,2
    74a0:	39d3a904 	addi	r7,r7,20132
    74a4:	00104380 	call	10438 <printf>
    74a8:	003fff06 	br	74a8 <pbuf_coalesce+0x70>
  pbuf_free(p);
    74ac:	8009883a 	mov	r4,r16
    74b0:	00067d80 	call	67d8 <pbuf_free>
  return q;
    74b4:	8821883a 	mov	r16,r17
}
    74b8:	8005883a 	mov	r2,r16
    74bc:	dfc00217 	ldw	ra,8(sp)
    74c0:	dc400117 	ldw	r17,4(sp)
    74c4:	dc000017 	ldw	r16,0(sp)
    74c8:	dec00304 	addi	sp,sp,12
    74cc:	f800283a 	ret

000074d0 <pbuf_get_at>:
{
  u16_t copy_from = offset;
  struct pbuf* q = p;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= copy_from)) {
    74d0:	20000c26 	beq	r4,zero,7504 <pbuf_get_at+0x34>
    74d4:	2080028b 	ldhu	r2,10(r4)
    74d8:	28ffffcc 	andi	r3,r5,65535
    74dc:	11bfffcc 	andi	r6,r2,65535
    74e0:	1980042e 	bgeu	r3,r6,74f4 <pbuf_get_at+0x24>
    74e4:	00000906 	br	750c <pbuf_get_at+0x3c>
    74e8:	2080028b 	ldhu	r2,10(r4)
    74ec:	11bfffcc 	andi	r6,r2,65535
    74f0:	19800636 	bltu	r3,r6,750c <pbuf_get_at+0x3c>
    copy_from -= q->len;
    q = q->next;
    74f4:	21000017 	ldw	r4,0(r4)
  u16_t copy_from = offset;
  struct pbuf* q = p;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= copy_from)) {
    copy_from -= q->len;
    74f8:	288bc83a 	sub	r5,r5,r2
{
  u16_t copy_from = offset;
  struct pbuf* q = p;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= copy_from)) {
    74fc:	28ffffcc 	andi	r3,r5,65535
    7500:	203ff91e 	bne	r4,zero,74e8 <pbuf_get_at+0x18>
  }
  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > copy_from)) {
    return ((u8_t*)q->payload)[copy_from];
  }
  return 0;
    7504:	0005883a 	mov	r2,zero
    7508:	f800283a 	ret
    copy_from -= q->len;
    q = q->next;
  }
  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > copy_from)) {
    return ((u8_t*)q->payload)[copy_from];
    750c:	20800117 	ldw	r2,4(r4)
    7510:	10c7883a 	add	r3,r2,r3
    7514:	18800003 	ldbu	r2,0(r3)
  }
  return 0;
}
    7518:	f800283a 	ret

0000751c <pbuf_memcmp>:
{
  u16_t start = offset;
  struct pbuf* q = p;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= start)) {
    751c:	20000c26 	beq	r4,zero,7550 <pbuf_memcmp+0x34>
    7520:	2080028b 	ldhu	r2,10(r4)
    7524:	28ffffcc 	andi	r3,r5,65535
    7528:	123fffcc 	andi	r8,r2,65535
    752c:	1a00042e 	bgeu	r3,r8,7540 <pbuf_memcmp+0x24>
    7530:	00000906 	br	7558 <pbuf_memcmp+0x3c>
    7534:	2080028b 	ldhu	r2,10(r4)
    7538:	123fffcc 	andi	r8,r2,65535
    753c:	1a000636 	bltu	r3,r8,7558 <pbuf_memcmp+0x3c>
    start -= q->len;
    q = q->next;
    7540:	21000017 	ldw	r4,0(r4)
  u16_t start = offset;
  struct pbuf* q = p;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= start)) {
    start -= q->len;
    7544:	288bc83a 	sub	r5,r5,r2
{
  u16_t start = offset;
  struct pbuf* q = p;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= start)) {
    7548:	28ffffcc 	andi	r3,r5,65535
    754c:	203ff91e 	bne	r4,zero,7534 <pbuf_memcmp+0x18>
        return i+1;
      }
    }
    return 0;
  }
  return 0xffff;
    7550:	00bfffc4 	movi	r2,-1
    7554:	f800283a 	ret
    q = q->next;
  }
  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > start)) {
    u16_t i;
    for(i = 0; i < n; i++) {
    7558:	39ffffcc 	andi	r7,r7,65535
    755c:	0019883a 	mov	r12,zero
    7560:	38001226 	beq	r7,zero,75ac <pbuf_memcmp+0x90>
    7564:	6005883a 	mov	r2,r12
 * @param n length of buffer to compare
 * @return zero if equal, nonzero otherwise
 *         (0xffff if p is too short, diffoffset+1 otherwise)
 */
u16_t
pbuf_memcmp(struct pbuf* p, u16_t offset, const void* s2, u16_t n)
    7568:	6151883a 	add	r8,r12,r5
    756c:	2007883a 	mov	r3,r4
{
  u16_t copy_from = offset;
  struct pbuf* q = p;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= copy_from)) {
    7570:	1a40028b 	ldhu	r9,10(r3)
    7574:	42bfffcc 	andi	r10,r8,65535
    7578:	4affffcc 	andi	r11,r9,65535
    757c:	52c00d36 	bltu	r10,r11,75b4 <pbuf_memcmp+0x98>
    copy_from -= q->len;
    q = q->next;
    7580:	18c00017 	ldw	r3,0(r3)
  u16_t copy_from = offset;
  struct pbuf* q = p;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= copy_from)) {
    copy_from -= q->len;
    7584:	4251c83a 	sub	r8,r8,r9
{
  u16_t copy_from = offset;
  struct pbuf* q = p;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= copy_from)) {
    7588:	183ff91e 	bne	r3,zero,7570 <pbuf_memcmp+0x54>
 * @param n length of buffer to compare
 * @return zero if equal, nonzero otherwise
 *         (0xffff if p is too short, diffoffset+1 otherwise)
 */
u16_t
pbuf_memcmp(struct pbuf* p, u16_t offset, const void* s2, u16_t n)
    758c:	3311883a 	add	r8,r6,r12
  if ((q != NULL) && (q->len > start)) {
    u16_t i;
    for(i = 0; i < n; i++) {
      u8_t a = pbuf_get_at(q, start + i);
      u8_t b = ((u8_t*)s2)[i];
      if (a != b) {
    7590:	42000003 	ldbu	r8,0(r8)
  }
  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > copy_from)) {
    return ((u8_t*)q->payload)[copy_from];
  }
  return 0;
    7594:	0007883a 	mov	r3,zero
  if ((q != NULL) && (q->len > start)) {
    u16_t i;
    for(i = 0; i < n; i++) {
      u8_t a = pbuf_get_at(q, start + i);
      u8_t b = ((u8_t*)s2)[i];
      if (a != b) {
    7598:	18c03fcc 	andi	r3,r3,255
    759c:	40c00c1e 	bne	r8,r3,75d0 <pbuf_memcmp+0xb4>
    75a0:	63000044 	addi	r12,r12,1
    q = q->next;
  }
  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > start)) {
    u16_t i;
    for(i = 0; i < n; i++) {
    75a4:	60bfffcc 	andi	r2,r12,65535
    75a8:	11ffee36 	bltu	r2,r7,7564 <pbuf_memcmp+0x48>
      u8_t b = ((u8_t*)s2)[i];
      if (a != b) {
        return i+1;
      }
    }
    return 0;
    75ac:	0005883a 	mov	r2,zero
  }
  return 0xffff;
}
    75b0:	f800283a 	ret
    copy_from -= q->len;
    q = q->next;
  }
  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > copy_from)) {
    return ((u8_t*)q->payload)[copy_from];
    75b4:	18c00117 	ldw	r3,4(r3)
 * @param n length of buffer to compare
 * @return zero if equal, nonzero otherwise
 *         (0xffff if p is too short, diffoffset+1 otherwise)
 */
u16_t
pbuf_memcmp(struct pbuf* p, u16_t offset, const void* s2, u16_t n)
    75b8:	3311883a 	add	r8,r6,r12
  if ((q != NULL) && (q->len > start)) {
    u16_t i;
    for(i = 0; i < n; i++) {
      u8_t a = pbuf_get_at(q, start + i);
      u8_t b = ((u8_t*)s2)[i];
      if (a != b) {
    75bc:	42000003 	ldbu	r8,0(r8)
    copy_from -= q->len;
    q = q->next;
  }
  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > copy_from)) {
    return ((u8_t*)q->payload)[copy_from];
    75c0:	1a95883a 	add	r10,r3,r10
    75c4:	50c00003 	ldbu	r3,0(r10)
  if ((q != NULL) && (q->len > start)) {
    u16_t i;
    for(i = 0; i < n; i++) {
      u8_t a = pbuf_get_at(q, start + i);
      u8_t b = ((u8_t*)s2)[i];
      if (a != b) {
    75c8:	18c03fcc 	andi	r3,r3,255
    75cc:	40fff426 	beq	r8,r3,75a0 <pbuf_memcmp+0x84>
        return i+1;
    75d0:	10800044 	addi	r2,r2,1
    75d4:	f800283a 	ret

000075d8 <pbuf_memfind>:
 */
u16_t
pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
{
  u16_t i;
  u16_t max = p->tot_len - mem_len;
    75d8:	20c0020b 	ldhu	r3,8(r4)
 * @param start_offset offset into p at which to start searching
 * @return 0xFFFF if substr was not found in p or the index where it was found
 */
u16_t
pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
{
    75dc:	defffa04 	addi	sp,sp,-24
    75e0:	dc400115 	stw	r17,4(sp)
  u16_t i;
  u16_t max = p->tot_len - mem_len;
  if (p->tot_len >= mem_len + start_offset) {
    75e4:	38bfffcc 	andi	r2,r7,65535
    75e8:	347fffcc 	andi	r17,r6,65535
 * @param start_offset offset into p at which to start searching
 * @return 0xFFFF if substr was not found in p or the index where it was found
 */
u16_t
pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
{
    75ec:	dcc00315 	stw	r19,12(sp)
    75f0:	dc800215 	stw	r18,8(sp)
    75f4:	dfc00515 	stw	ra,20(sp)
    75f8:	2025883a 	mov	r18,r4
    75fc:	dd000415 	stw	r20,16(sp)
    7600:	dc000015 	stw	r16,0(sp)
  u16_t i;
  u16_t max = p->tot_len - mem_len;
  if (p->tot_len >= mem_len + start_offset) {
    7604:	1a3fffcc 	andi	r8,r3,65535
    7608:	8889883a 	add	r4,r17,r2
 * @param start_offset offset into p at which to start searching
 * @return 0xFFFF if substr was not found in p or the index where it was found
 */
u16_t
pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
{
    760c:	2827883a 	mov	r19,r5
  u16_t i;
  u16_t max = p->tot_len - mem_len;
  if (p->tot_len >= mem_len + start_offset) {
    7610:	41000a0e 	bge	r8,r4,763c <pbuf_memfind+0x64>
      } else {
        i += plus;
      }
    }
  }
  return 0xFFFF;
    7614:	043fffc4 	movi	r16,-1
}
    7618:	8005883a 	mov	r2,r16
    761c:	dfc00517 	ldw	ra,20(sp)
    7620:	dd000417 	ldw	r20,16(sp)
    7624:	dcc00317 	ldw	r19,12(sp)
    7628:	dc800217 	ldw	r18,8(sp)
    762c:	dc400117 	ldw	r17,4(sp)
    7630:	dc000017 	ldw	r16,0(sp)
    7634:	dec00604 	addi	sp,sp,24
    7638:	f800283a 	ret
 */
u16_t
pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
{
  u16_t i;
  u16_t max = p->tot_len - mem_len;
    763c:	19a9c83a 	sub	r20,r3,r6
  if (p->tot_len >= mem_len + start_offset) {
    for(i = start_offset; i <= max; ) {
    7640:	a53fffcc 	andi	r20,r20,65535
    7644:	a0bff336 	bltu	r20,r2,7614 <pbuf_memfind+0x3c>
    7648:	3821883a 	mov	r16,r7
    764c:	100b883a 	mov	r5,r2
      u16_t plus = pbuf_memcmp(p, i, mem, mem_len);
    7650:	9009883a 	mov	r4,r18
    7654:	980d883a 	mov	r6,r19
    7658:	880f883a 	mov	r7,r17
    765c:	000751c0 	call	751c <pbuf_memcmp>
      if (plus == 0) {
    7660:	10ffffcc 	andi	r3,r2,65535
    7664:	183fec26 	beq	r3,zero,7618 <pbuf_memfind+0x40>
        return i;
      } else {
        i += plus;
    7668:	80a1883a 	add	r16,r16,r2
pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
{
  u16_t i;
  u16_t max = p->tot_len - mem_len;
  if (p->tot_len >= mem_len + start_offset) {
    for(i = start_offset; i <= max; ) {
    766c:	817fffcc 	andi	r5,r16,65535
    7670:	a17ff72e 	bgeu	r20,r5,7650 <pbuf_memfind+0x78>
    7674:	003fe706 	br	7614 <pbuf_memfind+0x3c>

00007678 <pbuf_strstr>:
 * @param substr string to search for in p, maximum length is 0xFFFE
 * @return 0xFFFF if substr was not found in p or the index where it was found
 */
u16_t
pbuf_strstr(struct pbuf* p, const char* substr)
{
    7678:	defffd04 	addi	sp,sp,-12
    767c:	dc000115 	stw	r16,4(sp)
    7680:	dfc00215 	stw	ra,8(sp)
    7684:	2021883a 	mov	r16,r4
  size_t substr_len;
  if ((substr == NULL) || (substr[0] == 0) || (p->tot_len == 0xFFFF)) {
    7688:	28000226 	beq	r5,zero,7694 <pbuf_strstr+0x1c>
    768c:	28800007 	ldb	r2,0(r5)
    7690:	1000051e 	bne	r2,zero,76a8 <pbuf_strstr+0x30>
  substr_len = strlen(substr);
  if (substr_len >= 0xFFFF) {
    return 0xFFFF;
  }
  return pbuf_memfind(p, substr, (u16_t)substr_len, 0);
}
    7694:	00bfffc4 	movi	r2,-1
    7698:	dfc00217 	ldw	ra,8(sp)
    769c:	dc000117 	ldw	r16,4(sp)
    76a0:	dec00304 	addi	sp,sp,12
    76a4:	f800283a 	ret
 */
u16_t
pbuf_strstr(struct pbuf* p, const char* substr)
{
  size_t substr_len;
  if ((substr == NULL) || (substr[0] == 0) || (p->tot_len == 0xFFFF)) {
    76a8:	20c0020b 	ldhu	r3,8(r4)
    76ac:	00bfffd4 	movui	r2,65535
    76b0:	18bff826 	beq	r3,r2,7694 <pbuf_strstr+0x1c>
    return 0xFFFF;
  }
  substr_len = strlen(substr);
    76b4:	2809883a 	mov	r4,r5
    76b8:	d9400015 	stw	r5,0(sp)
    76bc:	001075c0 	call	1075c <strlen>
  if (substr_len >= 0xFFFF) {
    76c0:	00ffff94 	movui	r3,65534
    76c4:	d9400017 	ldw	r5,0(sp)
    76c8:	18bff236 	bltu	r3,r2,7694 <pbuf_strstr+0x1c>
    return 0xFFFF;
  }
  return pbuf_memfind(p, substr, (u16_t)substr_len, 0);
    76cc:	8009883a 	mov	r4,r16
    76d0:	100d883a 	mov	r6,r2
    76d4:	000f883a 	mov	r7,zero
}
    76d8:	dfc00217 	ldw	ra,8(sp)
    76dc:	dc000117 	ldw	r16,4(sp)
    76e0:	dec00304 	addi	sp,sp,12
  }
  substr_len = strlen(substr);
  if (substr_len >= 0xFFFF) {
    return 0xFFFF;
  }
  return pbuf_memfind(p, substr, (u16_t)substr_len, 0);
    76e4:	00075d81 	jmpi	75d8 <pbuf_memfind>

000076e8 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
    76e8:	defffa04 	addi	sp,sp,-24
    76ec:	dc000015 	stw	r16,0(sp)
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = (struct ip_hdr *)p->payload;
  proto = IPH_PROTO(iphdr);
    76f0:	20800117 	ldw	r2,4(r4)

  prev = NULL;
  pcb = raw_pcbs;
    76f4:	d428ba17 	ldw	r16,-23832(gp)
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
    76f8:	dcc00315 	stw	r19,12(sp)
    76fc:	dfc00515 	stw	ra,20(sp)
    7700:	dd000415 	stw	r20,16(sp)
    7704:	dc800215 	stw	r18,8(sp)
    7708:	dc400115 	stw	r17,4(sp)
    770c:	2027883a 	mov	r19,r4
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = (struct ip_hdr *)p->payload;
  proto = IPH_PROTO(iphdr);
    7710:	14800243 	ldbu	r18,9(r2)

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    7714:	80002826 	beq	r16,zero,77b8 <raw_input+0xd0>
    7718:	0023883a 	mov	r17,zero
    771c:	94803fcc 	andi	r18,r18,255
    if ((pcb->protocol == proto) &&
        (ip_addr_isany(&pcb->local_ip) ||
         ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest))) {
    7720:	050000f4 	movhi	r20,3
    7724:	a52eac04 	addi	r20,r20,-17744
    7728:	00000406 	br	773c <raw_input+0x54>
        /* no receive callback function was set for this raw PCB */
      }
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
    772c:	80800317 	ldw	r2,12(r16)
    7730:	8023883a 	mov	r17,r16

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    7734:	10002026 	beq	r2,zero,77b8 <raw_input+0xd0>
        /* no receive callback function was set for this raw PCB */
      }
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
    7738:	1021883a 	mov	r16,r2
  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if ((pcb->protocol == proto) &&
    773c:	80800403 	ldbu	r2,16(r16)
    7740:	90bffa1e 	bne	r18,r2,772c <raw_input+0x44>
        (ip_addr_isany(&pcb->local_ip) ||
    7744:	80800017 	ldw	r2,0(r16)
#endif /* IP_SOF_BROADCAST_RECV */
      {
        /* receive callback function available? */
        if (pcb->recv != NULL) {
          /* the receive callback function did not eat the packet? */
          if (pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr()) != 0) {
    7748:	800b883a 	mov	r5,r16
    774c:	980d883a 	mov	r6,r19
    7750:	01c000f4 	movhi	r7,3
    7754:	39eeaa04 	addi	r7,r7,-17752
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if ((pcb->protocol == proto) &&
        (ip_addr_isany(&pcb->local_ip) ||
    7758:	10000226 	beq	r2,zero,7764 <raw_input+0x7c>
    775c:	a0c00017 	ldw	r3,0(r20)
    7760:	10fff21e 	bne	r2,r3,772c <raw_input+0x44>
      /* broadcast filter? */
      if (ip_get_option(pcb, SOF_BROADCAST) || !ip_addr_isbroadcast(&current_iphdr_dest, inp))
#endif /* IP_SOF_BROADCAST_RECV */
      {
        /* receive callback function available? */
        if (pcb->recv != NULL) {
    7764:	80800517 	ldw	r2,20(r16)
    7768:	103ff026 	beq	r2,zero,772c <raw_input+0x44>
          /* the receive callback function did not eat the packet? */
          if (pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr()) != 0) {
    776c:	81000617 	ldw	r4,24(r16)
    7770:	103ee83a 	callr	r2
    7774:	10803fcc 	andi	r2,r2,255
    7778:	103fec26 	beq	r2,zero,772c <raw_input+0x44>
            /* receive function ate the packet */
            p = NULL;
            eaten = 1;
            if (prev != NULL) {
    777c:	88000526 	beq	r17,zero,7794 <raw_input+0xac>
            /* move the pcb to the front of raw_pcbs so that is
               found faster next time */
              prev->next = pcb->next;
    7780:	80c00317 	ldw	r3,12(r16)
              pcb->next = raw_pcbs;
    7784:	d0a8ba17 	ldw	r2,-23832(gp)
              raw_pcbs = pcb;
    7788:	d428ba15 	stw	r16,-23832(gp)
            p = NULL;
            eaten = 1;
            if (prev != NULL) {
            /* move the pcb to the front of raw_pcbs so that is
               found faster next time */
              prev->next = pcb->next;
    778c:	88c00315 	stw	r3,12(r17)
              pcb->next = raw_pcbs;
    7790:	80800315 	stw	r2,12(r16)
        /* no receive callback function was set for this raw PCB */
      }
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
    7794:	00800044 	movi	r2,1
  }
  return eaten;
}
    7798:	dfc00517 	ldw	ra,20(sp)
    779c:	dd000417 	ldw	r20,16(sp)
    77a0:	dcc00317 	ldw	r19,12(sp)
    77a4:	dc800217 	ldw	r18,8(sp)
    77a8:	dc400117 	ldw	r17,4(sp)
    77ac:	dc000017 	ldw	r16,0(sp)
    77b0:	dec00604 	addi	sp,sp,24
    77b4:	f800283a 	ret
        /* no receive callback function was set for this raw PCB */
      }
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
    77b8:	0005883a 	mov	r2,zero
  }
  return eaten;
}
    77bc:	dfc00517 	ldw	ra,20(sp)
    77c0:	dd000417 	ldw	r20,16(sp)
    77c4:	dcc00317 	ldw	r19,12(sp)
    77c8:	dc800217 	ldw	r18,8(sp)
    77cc:	dc400117 	ldw	r17,4(sp)
    77d0:	dc000017 	ldw	r16,0(sp)
    77d4:	dec00604 	addi	sp,sp,24
    77d8:	f800283a 	ret

000077dc <raw_bind>:
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, ip_addr_t *ipaddr)
{
  ip_addr_set(&pcb->local_ip, ipaddr);
    77dc:	28000426 	beq	r5,zero,77f0 <raw_bind+0x14>
    77e0:	28800017 	ldw	r2,0(r5)
    77e4:	20800015 	stw	r2,0(r4)
  return ERR_OK;
}
    77e8:	0005883a 	mov	r2,zero
    77ec:	f800283a 	ret
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, ip_addr_t *ipaddr)
{
  ip_addr_set(&pcb->local_ip, ipaddr);
    77f0:	0005883a 	mov	r2,zero
    77f4:	20800015 	stw	r2,0(r4)
  return ERR_OK;
}
    77f8:	0005883a 	mov	r2,zero
    77fc:	f800283a 	ret

00007800 <raw_connect>:
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, ip_addr_t *ipaddr)
{
  ip_addr_set(&pcb->remote_ip, ipaddr);
    7800:	28000426 	beq	r5,zero,7814 <raw_connect+0x14>
    7804:	28800017 	ldw	r2,0(r5)
    7808:	20800115 	stw	r2,4(r4)
  return ERR_OK;
}
    780c:	0005883a 	mov	r2,zero
    7810:	f800283a 	ret
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, ip_addr_t *ipaddr)
{
  ip_addr_set(&pcb->remote_ip, ipaddr);
    7814:	0005883a 	mov	r2,zero
    7818:	20800115 	stw	r2,4(r4)
  return ERR_OK;
}
    781c:	0005883a 	mov	r2,zero
    7820:	f800283a 	ret

00007824 <raw_recv>:
 */
void
raw_recv(struct raw_pcb *pcb, raw_recv_fn recv, void *recv_arg)
{
  /* remember recv() callback and user data */
  pcb->recv = recv;
    7824:	21400515 	stw	r5,20(r4)
  pcb->recv_arg = recv_arg;
    7828:	21800615 	stw	r6,24(r4)
    782c:	f800283a 	ret

00007830 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, ip_addr_t *ipaddr)
{
    7830:	defff804 	addi	sp,sp,-32
    7834:	dc400415 	stw	r17,16(sp)
    7838:	2823883a 	mov	r17,r5
    783c:	dc800515 	stw	r18,20(sp)
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
    7840:	01400504 	movi	r5,20
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, ip_addr_t *ipaddr)
{
    7844:	2025883a 	mov	r18,r4
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
    7848:	8809883a 	mov	r4,r17
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, ip_addr_t *ipaddr)
{
    784c:	dcc00615 	stw	r19,24(sp)
    7850:	dfc00715 	stw	ra,28(sp)
    7854:	dc000315 	stw	r16,12(sp)
    7858:	3027883a 	mov	r19,r6
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
    785c:	00066980 	call	6698 <pbuf_header>
    7860:	10803fcc 	andi	r2,r2,255
    7864:	10002626 	beq	r2,zero,7900 <raw_sendto+0xd0>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
    7868:	01000044 	movi	r4,1
    786c:	000b883a 	mov	r5,zero
    7870:	000d883a 	mov	r6,zero
    7874:	0006a880 	call	6a88 <pbuf_alloc>
    7878:	1021883a 	mov	r16,r2
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
    787c:	10004526 	beq	r2,zero,7994 <raw_sendto+0x164>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    if (p->tot_len != 0) {
    7880:	8880020b 	ldhu	r2,8(r17)
    7884:	1000311e 	bne	r2,zero,794c <raw_sendto+0x11c>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }

  if ((netif = ip_route(ipaddr)) == NULL) {
    7888:	9809883a 	mov	r4,r19
    788c:	000427c0 	call	427c <ip_route>
    7890:	10003426 	beq	r2,zero,7964 <raw_sendto+0x134>
    }
    return ERR_VAL;
  }
#endif /* IP_SOF_BROADCAST */

  if (ip_addr_isany(&pcb->local_ip)) {
    7894:	900b883a 	mov	r5,r18
    7898:	90001726 	beq	r18,zero,78f8 <raw_sendto+0xc8>
    789c:	90c00017 	ldw	r3,0(r18)
    78a0:	18001526 	beq	r3,zero,78f8 <raw_sendto+0xc8>
    /* use RAW PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
  }

  NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
    78a4:	91000243 	ldbu	r4,9(r18)
    78a8:	90c00403 	ldbu	r3,16(r18)
    78ac:	91c00283 	ldbu	r7,10(r18)
    78b0:	980d883a 	mov	r6,r19
    78b4:	d9000015 	stw	r4,0(sp)
    78b8:	d8800215 	stw	r2,8(sp)
    78bc:	d8c00115 	stw	r3,4(sp)
    78c0:	8009883a 	mov	r4,r16
    78c4:	00046140 	call	4614 <ip_output_if>
    78c8:	1025883a 	mov	r18,r2
  NETIF_SET_HWADDRHINT(netif, NULL);

  /* did we chain a header earlier? */
  if (q != p) {
    78cc:	84400226 	beq	r16,r17,78d8 <raw_sendto+0xa8>
    /* free the header */
    pbuf_free(q);
    78d0:	8009883a 	mov	r4,r16
    78d4:	00067d80 	call	67d8 <pbuf_free>
  }
  return err;
}
    78d8:	9005883a 	mov	r2,r18
    78dc:	dfc00717 	ldw	ra,28(sp)
    78e0:	dcc00617 	ldw	r19,24(sp)
    78e4:	dc800517 	ldw	r18,20(sp)
    78e8:	dc400417 	ldw	r17,16(sp)
    78ec:	dc000317 	ldw	r16,12(sp)
    78f0:	dec00804 	addi	sp,sp,32
    78f4:	f800283a 	ret
  }
#endif /* IP_SOF_BROADCAST */

  if (ip_addr_isany(&pcb->local_ip)) {
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
    78f8:	11400104 	addi	r5,r2,4
    78fc:	003fe906 	br	78a4 <raw_sendto+0x74>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
    if(pbuf_header(q, -IP_HLEN)) {
    7900:	8809883a 	mov	r4,r17
    7904:	017ffb04 	movi	r5,-20
    7908:	00066980 	call	6698 <pbuf_header>
    790c:	10803fcc 	andi	r2,r2,255
    7910:	1000051e 	bne	r2,zero,7928 <raw_sendto+0xf8>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }

  if ((netif = ip_route(ipaddr)) == NULL) {
    7914:	9809883a 	mov	r4,r19
    7918:	000427c0 	call	427c <ip_route>
    791c:	10001426 	beq	r2,zero,7970 <raw_sendto+0x140>
    7920:	8821883a 	mov	r16,r17
    7924:	003fdb06 	br	7894 <raw_sendto+0x64>
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
    if(pbuf_header(q, -IP_HLEN)) {
      LWIP_ASSERT("Can't restore header we just removed!", 0);
    7928:	010000b4 	movhi	r4,2
    792c:	210d4b04 	addi	r4,r4,13612
    7930:	014000b4 	movhi	r5,2
    7934:	29549204 	addi	r5,r5,21064
    7938:	018039c4 	movi	r6,231
    793c:	01c000b4 	movhi	r7,2
    7940:	39d49c04 	addi	r7,r7,21104
    7944:	00104380 	call	10438 <printf>
    7948:	003fff06 	br	7948 <raw_sendto+0x118>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    if (p->tot_len != 0) {
      /* chain header q in front of given pbuf p */
      pbuf_chain(q, p);
    794c:	8009883a 	mov	r4,r16
    7950:	880b883a 	mov	r5,r17
    7954:	0006ec00 	call	6ec0 <pbuf_chain>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }

  if ((netif = ip_route(ipaddr)) == NULL) {
    7958:	9809883a 	mov	r4,r19
    795c:	000427c0 	call	427c <ip_route>
    7960:	103fcc1e 	bne	r2,zero,7894 <raw_sendto+0x64>
    LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_LEVEL_WARNING, ("raw_sendto: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr)));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
    7964:	8c000226 	beq	r17,r16,7970 <raw_sendto+0x140>
      pbuf_free(q);
    7968:	8009883a 	mov	r4,r16
    796c:	00067d80 	call	67d8 <pbuf_free>
    }
    return ERR_RTE;
    7970:	04bfff04 	movi	r18,-4
  if (q != p) {
    /* free the header */
    pbuf_free(q);
  }
  return err;
}
    7974:	9005883a 	mov	r2,r18
    7978:	dfc00717 	ldw	ra,28(sp)
    797c:	dcc00617 	ldw	r19,24(sp)
    7980:	dc800517 	ldw	r18,20(sp)
    7984:	dc400417 	ldw	r17,16(sp)
    7988:	dc000317 	ldw	r16,12(sp)
    798c:	dec00804 	addi	sp,sp,32
    7990:	f800283a 	ret
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    7994:	04bfffc4 	movi	r18,-1
  if (q != p) {
    /* free the header */
    pbuf_free(q);
  }
  return err;
}
    7998:	9005883a 	mov	r2,r18
    799c:	dfc00717 	ldw	ra,28(sp)
    79a0:	dcc00617 	ldw	r19,24(sp)
    79a4:	dc800517 	ldw	r18,20(sp)
    79a8:	dc400417 	ldw	r17,16(sp)
    79ac:	dc000317 	ldw	r16,12(sp)
    79b0:	dec00804 	addi	sp,sp,32
    79b4:	f800283a 	ret

000079b8 <raw_send>:
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  return raw_sendto(pcb, p, &pcb->remote_ip);
    79b8:	21800104 	addi	r6,r4,4
    79bc:	00078301 	jmpi	7830 <raw_sendto>

000079c0 <raw_remove>:
void
raw_remove(struct raw_pcb *pcb)
{
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
    79c0:	d0e8ba17 	ldw	r3,-23832(gp)
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
    79c4:	200b883a 	mov	r5,r4
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
    79c8:	19000e26 	beq	r3,r4,7a04 <raw_remove+0x44>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
    79cc:	18000626 	beq	r3,zero,79e8 <raw_remove+0x28>
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
    79d0:	18800317 	ldw	r2,12(r3)
    79d4:	10000426 	beq	r2,zero,79e8 <raw_remove+0x28>
    79d8:	28800526 	beq	r5,r2,79f0 <raw_remove+0x30>
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
    79dc:	1007883a 	mov	r3,r2
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
    79e0:	18800317 	ldw	r2,12(r3)
    79e4:	103ffc1e 	bne	r2,zero,79d8 <raw_remove+0x18>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
    79e8:	0009883a 	mov	r4,zero
    79ec:	000618c1 	jmpi	618c <memp_free>
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
    79f0:	28800317 	ldw	r2,12(r5)
    79f4:	18800315 	stw	r2,12(r3)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
    79f8:	103ffb26 	beq	r2,zero,79e8 <raw_remove+0x28>
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
    79fc:	1007883a 	mov	r3,r2
    7a00:	003ff706 	br	79e0 <raw_remove+0x20>
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    7a04:	20800317 	ldw	r2,12(r4)
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
    7a08:	0009883a 	mov	r4,zero
{
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    7a0c:	d0a8ba15 	stw	r2,-23832(gp)
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
    7a10:	000618c1 	jmpi	618c <memp_free>

00007a14 <raw_new>:
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto)
{
    7a14:	defffd04 	addi	sp,sp,-12
    7a18:	dc400115 	stw	r17,4(sp)
    7a1c:	2023883a 	mov	r17,r4
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_new\n"));

  pcb = (struct raw_pcb *)memp_malloc(MEMP_RAW_PCB);
    7a20:	0009883a 	mov	r4,zero
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto)
{
    7a24:	dc000015 	stw	r16,0(sp)
    7a28:	dfc00215 	stw	ra,8(sp)
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_new\n"));

  pcb = (struct raw_pcb *)memp_malloc(MEMP_RAW_PCB);
    7a2c:	00060a40 	call	60a4 <memp_malloc>
    7a30:	1021883a 	mov	r16,r2
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
    7a34:	10000a26 	beq	r2,zero,7a60 <raw_new+0x4c>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
    7a38:	1009883a 	mov	r4,r2
    7a3c:	000b883a 	mov	r5,zero
    7a40:	01800704 	movi	r6,28
    7a44:	00103300 	call	10330 <memset>
    pcb->protocol = proto;
    pcb->ttl = RAW_TTL;
    7a48:	00bfffc4 	movi	r2,-1
    7a4c:	80800285 	stb	r2,10(r16)
    pcb->next = raw_pcbs;
    7a50:	d0a8ba17 	ldw	r2,-23832(gp)
  pcb = (struct raw_pcb *)memp_malloc(MEMP_RAW_PCB);
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
    pcb->protocol = proto;
    7a54:	84400405 	stb	r17,16(r16)
    pcb->ttl = RAW_TTL;
    pcb->next = raw_pcbs;
    raw_pcbs = pcb;
    7a58:	d428ba15 	stw	r16,-23832(gp)
  if (pcb != NULL) {
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
    pcb->protocol = proto;
    pcb->ttl = RAW_TTL;
    pcb->next = raw_pcbs;
    7a5c:	80800315 	stw	r2,12(r16)
    raw_pcbs = pcb;
  }
  return pcb;
}
    7a60:	8005883a 	mov	r2,r16
    7a64:	dfc00217 	ldw	ra,8(sp)
    7a68:	dc400117 	ldw	r17,4(sp)
    7a6c:	dc000017 	ldw	r16,0(sp)
    7a70:	dec00304 	addi	sp,sp,12
    7a74:	f800283a 	ret

00007a78 <stats_init>:
#include <string.h>

struct stats_ lwip_stats;

void stats_init(void)
{
    7a78:	f800283a 	ret

00007a7c <tcp_accept_null>:
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
    7a7c:	00bffd84 	movi	r2,-10
    7a80:	f800283a 	ret

00007a84 <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
    7a84:	d0a0060b 	ldhu	r2,-32744(gp)
    7a88:	02100004 	movi	r8,16384
  u8_t i;
  u16_t n = 0;
  struct tcp_pcb *pcb;
  
again:
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
    7a8c:	027fffd4 	movui	r9,65535
    7a90:	11ffffcc 	andi	r7,r2,65535
 * Allocate a new local TCP port.
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
    7a94:	028000b4 	movhi	r10,2
    7a98:	5295a204 	addi	r10,r10,22152
  u8_t i;
  u16_t n = 0;
  struct tcp_pcb *pcb;
  
again:
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
    7a9c:	3a401926 	beq	r7,r9,7b04 <tcp_new_port+0x80>
    7aa0:	10800044 	addi	r2,r2,1
    7aa4:	018000b4 	movhi	r6,2
    7aa8:	31959e04 	addi	r6,r6,22136
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
    for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
      if (pcb->local_port == tcp_port) {
    7aac:	117fffcc 	andi	r5,r2,65535
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
    for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
    7ab0:	30c00017 	ldw	r3,0(r6)
    7ab4:	18c00017 	ldw	r3,0(r3)
    7ab8:	18000826 	beq	r3,zero,7adc <tcp_new_port+0x58>
      if (pcb->local_port == tcp_port) {
    7abc:	1900078b 	ldhu	r4,30(r3)
    7ac0:	280f883a 	mov	r7,r5
    7ac4:	2140031e 	bne	r4,r5,7ad4 <tcp_new_port+0x50>
    7ac8:	00000806 	br	7aec <tcp_new_port+0x68>
    7acc:	1900078b 	ldhu	r4,30(r3)
    7ad0:	21400626 	beq	r4,r5,7aec <tcp_new_port+0x68>
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
    for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
    7ad4:	18c00317 	ldw	r3,12(r3)
    7ad8:	183ffc1e 	bne	r3,zero,7acc <tcp_new_port+0x48>
    7adc:	31800104 	addi	r6,r6,4
again:
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
    7ae0:	32bff31e 	bne	r6,r10,7ab0 <tcp_new_port+0x2c>
    7ae4:	d0a0060d 	sth	r2,-32744(gp)
        goto again;
      }
    }
  }
  return tcp_port;
}
    7ae8:	f800283a 	ret
    7aec:	423fffc4 	addi	r8,r8,-1
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
    for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
      if (pcb->local_port == tcp_port) {
        if (++n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
    7af0:	40ffffcc 	andi	r3,r8,65535
    7af4:	183fe91e 	bne	r3,zero,7a9c <tcp_new_port+0x18>
    7af8:	d0a0060d 	sth	r2,-32744(gp)
          return 0;
    7afc:	0005883a 	mov	r2,zero
    7b00:	f800283a 	ret
  u8_t i;
  u16_t n = 0;
  struct tcp_pcb *pcb;
  
again:
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
    7b04:	00b00004 	movi	r2,-16384
    7b08:	003fe606 	br	7aa4 <tcp_new_port+0x20>

00007b0c <tcp_init>:
/**
 * Initialize this module.
 */
void
tcp_init(void)
{
    7b0c:	f800283a 	ret

00007b10 <tcp_bind>:
{
  int i;
  int max_pcb_list = NUM_TCP_PCB_LISTS;
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
    7b10:	20c00617 	ldw	r3,24(r4)
 *         ERR_VAL if bind failed because the PCB is not in a valid state
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
    7b14:	defffd04 	addi	sp,sp,-12
    7b18:	dc400115 	stw	r17,4(sp)
    7b1c:	dc000015 	stw	r16,0(sp)
    7b20:	dfc00215 	stw	ra,8(sp)
    7b24:	2021883a 	mov	r16,r4
    7b28:	2823883a 	mov	r17,r5
    7b2c:	3005883a 	mov	r2,r6
  int i;
  int max_pcb_list = NUM_TCP_PCB_LISTS;
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
    7b30:	1800331e 	bne	r3,zero,7c00 <tcp_bind+0xf0>
  if (ip_get_option(pcb, SOF_REUSEADDR)) {
    max_pcb_list = NUM_TCP_PCB_LISTS_NO_TIME_WAIT;
  }
#endif /* SO_REUSE */

  if (port == 0) {
    7b34:	323fffcc 	andi	r8,r6,65535
    7b38:	40002826 	beq	r8,zero,7bdc <tcp_bind+0xcc>
    7b3c:	024000b4 	movhi	r9,2
    7b40:	4a559e04 	addi	r9,r9,22136
 * @return ERR_USE if the port is already in use
 *         ERR_VAL if bind failed because the PCB is not in a valid state
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
    7b44:	4a800404 	addi	r10,r9,16
    }
  }

  /* Check if the address already is in use (on all lists) */
  for (i = 0; i < max_pcb_list; i++) {
    for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
    7b48:	48c00017 	ldw	r3,0(r9)
    7b4c:	18c00017 	ldw	r3,0(r3)
    7b50:	1800031e 	bne	r3,zero,7b60 <tcp_bind+0x50>
    7b54:	00001006 	br	7b98 <tcp_bind+0x88>
    7b58:	18c00317 	ldw	r3,12(r3)
    7b5c:	18000e26 	beq	r3,zero,7b98 <tcp_bind+0x88>
      if (cpcb->local_port == port) {
    7b60:	19c0078b 	ldhu	r7,30(r3)
    7b64:	3a3ffc1e 	bne	r7,r8,7b58 <tcp_bind+0x48>
           tcp_connect. */
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
            !ip_get_option(cpcb, SOF_REUSEADDR))
#endif /* SO_REUSE */
        {
          if (ip_addr_isany(&(cpcb->local_ip)) ||
    7b68:	19c00017 	ldw	r7,0(r3)
    7b6c:	38000426 	beq	r7,zero,7b80 <tcp_bind+0x70>
    7b70:	88000326 	beq	r17,zero,7b80 <tcp_bind+0x70>
              ip_addr_isany(ipaddr) ||
    7b74:	89800017 	ldw	r6,0(r17)
    7b78:	30000126 	beq	r6,zero,7b80 <tcp_bind+0x70>
    7b7c:	39bff61e 	bne	r7,r6,7b58 <tcp_bind+0x48>
              ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
            return ERR_USE;
    7b80:	00bffe04 	movi	r2,-8
  }
  pcb->local_port = port;
  TCP_REG(&tcp_bound_pcbs, pcb);
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
}
    7b84:	dfc00217 	ldw	ra,8(sp)
    7b88:	dc400117 	ldw	r17,4(sp)
    7b8c:	dc000017 	ldw	r16,0(sp)
    7b90:	dec00304 	addi	sp,sp,12
    7b94:	f800283a 	ret
    7b98:	4a400104 	addi	r9,r9,4
      return ERR_BUF;
    }
  }

  /* Check if the address already is in use (on all lists) */
  for (i = 0; i < max_pcb_list; i++) {
    7b9c:	4abfea1e 	bne	r9,r10,7b48 <tcp_bind+0x38>
        }
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
    7ba0:	88000326 	beq	r17,zero,7bb0 <tcp_bind+0xa0>
    7ba4:	88c00017 	ldw	r3,0(r17)
    7ba8:	18000126 	beq	r3,zero,7bb0 <tcp_bind+0xa0>
    pcb->local_ip = *ipaddr;
    7bac:	80c00015 	stw	r3,0(r16)
  }
  pcb->local_port = port;
  TCP_REG(&tcp_bound_pcbs, pcb);
    7bb0:	d0e8c017 	ldw	r3,-23808(gp)
  }

  if (!ip_addr_isany(ipaddr)) {
    pcb->local_ip = *ipaddr;
  }
  pcb->local_port = port;
    7bb4:	8080078d 	sth	r2,30(r16)
  TCP_REG(&tcp_bound_pcbs, pcb);
    7bb8:	d428c015 	stw	r16,-23808(gp)
    7bbc:	80c00315 	stw	r3,12(r16)
    7bc0:	000cfa80 	call	cfa8 <tcp_timer_needed>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
    7bc4:	0005883a 	mov	r2,zero
}
    7bc8:	dfc00217 	ldw	ra,8(sp)
    7bcc:	dc400117 	ldw	r17,4(sp)
    7bd0:	dc000017 	ldw	r16,0(sp)
    7bd4:	dec00304 	addi	sp,sp,12
    7bd8:	f800283a 	ret
    max_pcb_list = NUM_TCP_PCB_LISTS_NO_TIME_WAIT;
  }
#endif /* SO_REUSE */

  if (port == 0) {
    port = tcp_new_port();
    7bdc:	0007a840 	call	7a84 <tcp_new_port>
    if (port == 0) {
    7be0:	123fffcc 	andi	r8,r2,65535
    7be4:	403fd51e 	bne	r8,zero,7b3c <tcp_bind+0x2c>
      return ERR_BUF;
    7be8:	00bfff84 	movi	r2,-2
  }
  pcb->local_port = port;
  TCP_REG(&tcp_bound_pcbs, pcb);
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
}
    7bec:	dfc00217 	ldw	ra,8(sp)
    7bf0:	dc400117 	ldw	r17,4(sp)
    7bf4:	dc000017 	ldw	r16,0(sp)
    7bf8:	dec00304 	addi	sp,sp,12
    7bfc:	f800283a 	ret
{
  int i;
  int max_pcb_list = NUM_TCP_PCB_LISTS;
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
    7c00:	010000b4 	movhi	r4,2
    7c04:	210d4b04 	addi	r4,r4,13612
    7c08:	014000b4 	movhi	r5,2
    7c0c:	2954a104 	addi	r5,r5,21124
    7c10:	01806dc4 	movi	r6,439
    7c14:	01c000b4 	movhi	r7,2
    7c18:	39d4ab04 	addi	r7,r7,21164
    7c1c:	00104380 	call	10438 <printf>
    7c20:	003fff06 	br	7c20 <tcp_bind+0x110>

00007c24 <tcp_listen_with_backlog>:
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
    7c24:	20800617 	ldw	r2,24(r4)
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
    7c28:	defffd04 	addi	sp,sp,-12
    7c2c:	dc400115 	stw	r17,4(sp)
    7c30:	dfc00215 	stw	ra,8(sp)
    7c34:	dc000015 	stw	r16,0(sp)
    7c38:	2023883a 	mov	r17,r4
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
    7c3c:	1000341e 	bne	r2,zero,7d10 <tcp_listen_with_backlog+0xec>
        }
      }
    }
  }
#endif /* SO_REUSE */
  lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
    7c40:	010000c4 	movi	r4,3
    7c44:	00060a40 	call	60a4 <memp_malloc>
    7c48:	1021883a 	mov	r16,r2
  if (lpcb == NULL) {
    7c4c:	10002a26 	beq	r2,zero,7cf8 <tcp_listen_with_backlog+0xd4>
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
  lpcb->local_port = pcb->local_port;
    7c50:	88c0078b 	ldhu	r3,30(r17)
#endif /* SO_REUSE */
  lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
  if (lpcb == NULL) {
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
    7c54:	89000417 	ldw	r4,16(r17)
  lpcb->local_port = pcb->local_port;
    7c58:	10c0078d 	sth	r3,30(r2)
  lpcb->state = LISTEN;
    7c5c:	00c00044 	movi	r3,1
#endif /* SO_REUSE */
  lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
  if (lpcb == NULL) {
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
    7c60:	11000415 	stw	r4,16(r2)
  lpcb->local_port = pcb->local_port;
  lpcb->state = LISTEN;
    7c64:	10c00615 	stw	r3,24(r2)
  lpcb->prio = pcb->prio;
    7c68:	88c00703 	ldbu	r3,28(r17)
    7c6c:	10c00705 	stb	r3,28(r2)
  lpcb->so_options = pcb->so_options;
  ip_set_option(lpcb, SOF_ACCEPTCONN);
    7c70:	88c00203 	ldbu	r3,8(r17)
    7c74:	18c00094 	ori	r3,r3,2
    7c78:	10c00205 	stb	r3,8(r2)
  lpcb->ttl = pcb->ttl;
    7c7c:	88c00283 	ldbu	r3,10(r17)
    7c80:	10c00285 	stb	r3,10(r2)
  lpcb->tos = pcb->tos;
    7c84:	88c00243 	ldbu	r3,9(r17)
    7c88:	10c00245 	stb	r3,9(r2)
  ip_addr_copy(lpcb->local_ip, pcb->local_ip);
    7c8c:	89000017 	ldw	r4,0(r17)
  if (pcb->local_port != 0) {
    7c90:	88c0078b 	ldhu	r3,30(r17)
  lpcb->prio = pcb->prio;
  lpcb->so_options = pcb->so_options;
  ip_set_option(lpcb, SOF_ACCEPTCONN);
  lpcb->ttl = pcb->ttl;
  lpcb->tos = pcb->tos;
  ip_addr_copy(lpcb->local_ip, pcb->local_ip);
    7c94:	11000015 	stw	r4,0(r2)
  if (pcb->local_port != 0) {
    7c98:	18000d26 	beq	r3,zero,7cd0 <tcp_listen_with_backlog+0xac>
    TCP_RMV(&tcp_bound_pcbs, pcb);
    7c9c:	d0e8c017 	ldw	r3,-23808(gp)
    7ca0:	1c402426 	beq	r3,r17,7d34 <tcp_listen_with_backlog+0x110>
    7ca4:	d0e8bf15 	stw	r3,-23812(gp)
    7ca8:	18000826 	beq	r3,zero,7ccc <tcp_listen_with_backlog+0xa8>
    7cac:	19000317 	ldw	r4,12(r3)
    7cb0:	2440031e 	bne	r4,r17,7cc0 <tcp_listen_with_backlog+0x9c>
    7cb4:	00002306 	br	7d44 <tcp_listen_with_backlog+0x120>
    7cb8:	19000317 	ldw	r4,12(r3)
    7cbc:	24402026 	beq	r4,r17,7d40 <tcp_listen_with_backlog+0x11c>
    7cc0:	2007883a 	mov	r3,r4
    7cc4:	203ffc1e 	bne	r4,zero,7cb8 <tcp_listen_with_backlog+0x94>
    7cc8:	d028bf15 	stw	zero,-23812(gp)
    7ccc:	88000315 	stw	zero,12(r17)
  }
  memp_free(MEMP_TCP_PCB, pcb);
    7cd0:	01000084 	movi	r4,2
    7cd4:	880b883a 	mov	r5,r17
    7cd8:	000618c0 	call	618c <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
    7cdc:	00c00034 	movhi	r3,0
    7ce0:	18de9f04 	addi	r3,r3,31356
    7ce4:	80c00515 	stw	r3,20(r16)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
    7ce8:	d0e8be17 	ldw	r3,-23816(gp)
    7cec:	d428be15 	stw	r16,-23816(gp)
    7cf0:	80c00315 	stw	r3,12(r16)
    7cf4:	000cfa80 	call	cfa8 <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
}
    7cf8:	8005883a 	mov	r2,r16
    7cfc:	dfc00217 	ldw	ra,8(sp)
    7d00:	dc400117 	ldw	r17,4(sp)
    7d04:	dc000017 	ldw	r16,0(sp)
    7d08:	dec00304 	addi	sp,sp,12
    7d0c:	f800283a 	ret
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
    7d10:	010000b4 	movhi	r4,2
    7d14:	210d4b04 	addi	r4,r4,13612
    7d18:	014000b4 	movhi	r5,2
    7d1c:	2954b004 	addi	r5,r5,21184
    7d20:	01808304 	movi	r6,524
    7d24:	01c000b4 	movhi	r7,2
    7d28:	39d4ab04 	addi	r7,r7,21164
    7d2c:	00104380 	call	10438 <printf>
    7d30:	003fff06 	br	7d30 <tcp_listen_with_backlog+0x10c>
  ip_set_option(lpcb, SOF_ACCEPTCONN);
  lpcb->ttl = pcb->ttl;
  lpcb->tos = pcb->tos;
  ip_addr_copy(lpcb->local_ip, pcb->local_ip);
  if (pcb->local_port != 0) {
    TCP_RMV(&tcp_bound_pcbs, pcb);
    7d34:	88c00317 	ldw	r3,12(r17)
    7d38:	d0e8c015 	stw	r3,-23808(gp)
    7d3c:	003fe306 	br	7ccc <tcp_listen_with_backlog+0xa8>
    7d40:	d0e8bf15 	stw	r3,-23812(gp)
    7d44:	89000317 	ldw	r4,12(r17)
    7d48:	19000315 	stw	r4,12(r3)
    7d4c:	003fdf06 	br	7ccc <tcp_listen_with_backlog+0xa8>

00007d50 <tcp_update_rcv_ann_wnd>:
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
    7d50:	21800c0b 	ldhu	r6,48(r4)

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    7d54:	21c00e8b 	ldhu	r7,58(r4)
 *
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
    7d58:	deffff04 	addi	sp,sp,-4
    7d5c:	dfc00015 	stw	ra,0(sp)
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    7d60:	00810004 	movi	r2,1024
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
    7d64:	20c00b17 	ldw	r3,44(r4)
    7d68:	323fffcc 	andi	r8,r6,65535

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    7d6c:	21400d17 	ldw	r5,52(r4)
    7d70:	11c0012e 	bgeu	r2,r7,7d78 <tcp_update_rcv_ann_wnd+0x28>
    7d74:	100f883a 	mov	r7,r2
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
    7d78:	4145c83a 	sub	r2,r8,r5

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    7d7c:	10c5883a 	add	r2,r2,r3
    7d80:	11cfc83a 	sub	r7,r2,r7
    7d84:	38000416 	blt	r7,zero,7d98 <tcp_update_rcv_ann_wnd+0x48>
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
    7d88:	21800c8d 	sth	r6,50(r4)
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
      pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
    }
    return 0;
  }
}
    7d8c:	dfc00017 	ldw	ra,0(sp)
    7d90:	dec00104 	addi	sp,sp,4
    7d94:	f800283a 	ret
  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
    return new_right_edge - pcb->rcv_ann_right_edge;
  } else {
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
    7d98:	1945c83a 	sub	r2,r3,r5
    7d9c:	0080050e 	bge	zero,r2,7db4 <tcp_update_rcv_ann_wnd+0x64>
      /* keep the right edge of window constant */
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
      pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
    }
    return 0;
    7da0:	0005883a 	mov	r2,zero
    return new_right_edge - pcb->rcv_ann_right_edge;
  } else {
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
      /* Can happen due to other end sending out of advertised window,
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
    7da4:	20000c8d 	sth	zero,50(r4)
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
      pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
    }
    return 0;
  }
}
    7da8:	dfc00017 	ldw	ra,0(sp)
    7dac:	dec00104 	addi	sp,sp,4
    7db0:	f800283a 	ret
      /* Can happen due to other end sending out of advertised window,
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
    } else {
      /* keep the right edge of window constant */
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
    7db4:	28c7c83a 	sub	r3,r5,r3
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
    7db8:	00bfffd4 	movui	r2,65535
    7dbc:	10c00536 	bltu	r2,r3,7dd4 <tcp_update_rcv_ann_wnd+0x84>
      pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
    }
    return 0;
    7dc0:	0005883a 	mov	r2,zero
      pcb->rcv_ann_wnd = 0;
    } else {
      /* keep the right edge of window constant */
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
      pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
    7dc4:	20c00c8d 	sth	r3,50(r4)
    }
    return 0;
  }
}
    7dc8:	dfc00017 	ldw	ra,0(sp)
    7dcc:	dec00104 	addi	sp,sp,4
    7dd0:	f800283a 	ret
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
    } else {
      /* keep the right edge of window constant */
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
    7dd4:	010000b4 	movhi	r4,2
    7dd8:	210d4b04 	addi	r4,r4,13612
    7ddc:	014000b4 	movhi	r5,2
    7de0:	2954b904 	addi	r5,r5,21220
    7de4:	018094c4 	movi	r6,595
    7de8:	01c000b4 	movhi	r7,2
    7dec:	39d4ab04 	addi	r7,r7,21164
    7df0:	00104380 	call	10438 <printf>
    7df4:	003fff06 	br	7df4 <tcp_update_rcv_ann_wnd+0xa4>

00007df8 <tcp_recved>:
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  int wnd_inflation;

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
    7df8:	20800617 	ldw	r2,24(r4)
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
    7dfc:	defffe04 	addi	sp,sp,-8
    7e00:	dc000015 	stw	r16,0(sp)
    7e04:	dfc00115 	stw	ra,4(sp)
    7e08:	2021883a 	mov	r16,r4
  int wnd_inflation;

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
    7e0c:	01000044 	movi	r4,1
    7e10:	11002826 	beq	r2,r4,7eb4 <tcp_recved+0xbc>
    pcb->state != LISTEN);
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
    7e14:	80800c0b 	ldhu	r2,48(r16)
    7e18:	28ffffcc 	andi	r3,r5,65535
    7e1c:	0088303a 	nor	r4,zero,r2
    7e20:	213fffcc 	andi	r4,r4,65535
    7e24:	20c01a16 	blt	r4,r3,7e90 <tcp_recved+0x98>
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
    7e28:	2887883a 	add	r3,r5,r2
  if (pcb->rcv_wnd > TCP_WND) {
    7e2c:	193fffcc 	andi	r4,r3,65535
    7e30:	00820004 	movi	r2,2048
    7e34:	11000936 	bltu	r2,r4,7e5c <tcp_recved+0x64>
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
    pcb->state != LISTEN);
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
    7e38:	80c00c0d 	sth	r3,48(r16)
  if (pcb->rcv_wnd > TCP_WND) {
    pcb->rcv_wnd = TCP_WND;
  }

  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
    7e3c:	8009883a 	mov	r4,r16
    7e40:	0007d500 	call	7d50 <tcp_update_rcv_ann_wnd>

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
    7e44:	00c07fc4 	movi	r3,511
    7e48:	18800916 	blt	r3,r2,7e70 <tcp_recved+0x78>
    tcp_output(pcb);
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
    7e4c:	dfc00117 	ldw	ra,4(sp)
    7e50:	dc000017 	ldw	r16,0(sp)
    7e54:	dec00204 	addi	sp,sp,8
    7e58:	f800283a 	ret
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
  if (pcb->rcv_wnd > TCP_WND) {
    pcb->rcv_wnd = TCP_WND;
    7e5c:	80800c0d 	sth	r2,48(r16)
  }

  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
    7e60:	8009883a 	mov	r4,r16
    7e64:	0007d500 	call	7d50 <tcp_update_rcv_ann_wnd>

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
    7e68:	00c07fc4 	movi	r3,511
    7e6c:	18bff70e 	bge	r3,r2,7e4c <tcp_recved+0x54>
    tcp_ack_now(pcb);
    7e70:	80800883 	ldbu	r2,34(r16)
    tcp_output(pcb);
    7e74:	8009883a 	mov	r4,r16
  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
    tcp_ack_now(pcb);
    7e78:	10800094 	ori	r2,r2,2
    7e7c:	80800885 	stb	r2,34(r16)
    tcp_output(pcb);
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
    7e80:	dfc00117 	ldw	ra,4(sp)
    7e84:	dc000017 	ldw	r16,0(sp)
    7e88:	dec00204 	addi	sp,sp,8
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
    tcp_ack_now(pcb);
    tcp_output(pcb);
    7e8c:	000c38c1 	jmpi	c38c <tcp_output>
  int wnd_inflation;

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
    pcb->state != LISTEN);
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
    7e90:	010000b4 	movhi	r4,2
    7e94:	210d4b04 	addi	r4,r4,13612
    7e98:	014000b4 	movhi	r5,2
    7e9c:	2954ca04 	addi	r5,r5,21288
    7ea0:	01809ac4 	movi	r6,619
    7ea4:	01c000b4 	movhi	r7,2
    7ea8:	39d4ab04 	addi	r7,r7,21164
    7eac:	00104380 	call	10438 <printf>
    7eb0:	003fff06 	br	7eb0 <tcp_recved+0xb8>
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  int wnd_inflation;

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
    7eb4:	010000b4 	movhi	r4,2
    7eb8:	210d4b04 	addi	r4,r4,13612
    7ebc:	014000b4 	movhi	r5,2
    7ec0:	2954c004 	addi	r5,r5,21248
    7ec4:	01809a44 	movi	r6,617
    7ec8:	01c000b4 	movhi	r7,2
    7ecc:	39d4ab04 	addi	r7,r7,21164
    7ed0:	00104380 	call	10438 <printf>
    7ed4:	003fff06 	br	7ed4 <tcp_recved+0xdc>

00007ed8 <tcp_seg_free>:
 *
 * @param seg single tcp_seg to free
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
    7ed8:	defffe04 	addi	sp,sp,-8
    7edc:	dc000015 	stw	r16,0(sp)
    7ee0:	dfc00115 	stw	ra,4(sp)
    7ee4:	2021883a 	mov	r16,r4
  if (seg != NULL) {
    7ee8:	20000926 	beq	r4,zero,7f10 <tcp_seg_free+0x38>
    if (seg->p != NULL) {
    7eec:	21000117 	ldw	r4,4(r4)
    7ef0:	20000126 	beq	r4,zero,7ef8 <tcp_seg_free+0x20>
      pbuf_free(seg->p);
    7ef4:	00067d80 	call	67d8 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
    7ef8:	01000104 	movi	r4,4
    7efc:	800b883a 	mov	r5,r16
  }
}
    7f00:	dfc00117 	ldw	ra,4(sp)
    7f04:	dc000017 	ldw	r16,0(sp)
    7f08:	dec00204 	addi	sp,sp,8
      pbuf_free(seg->p);
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
    7f0c:	000618c1 	jmpi	618c <memp_free>
  }
}
    7f10:	dfc00117 	ldw	ra,4(sp)
    7f14:	dc000017 	ldw	r16,0(sp)
    7f18:	dec00204 	addi	sp,sp,8
    7f1c:	f800283a 	ret

00007f20 <tcp_segs_free>:
 *
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
    7f20:	defffe04 	addi	sp,sp,-8
    7f24:	dfc00115 	stw	ra,4(sp)
    7f28:	dc000015 	stw	r16,0(sp)
  while (seg != NULL) {
    7f2c:	20000426 	beq	r4,zero,7f40 <tcp_segs_free+0x20>
    struct tcp_seg *next = seg->next;
    7f30:	24000017 	ldw	r16,0(r4)
    tcp_seg_free(seg);
    7f34:	0007ed80 	call	7ed8 <tcp_seg_free>
    seg = next;
    7f38:	8009883a 	mov	r4,r16
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
    7f3c:	803ffc1e 	bne	r16,zero,7f30 <tcp_segs_free+0x10>
    struct tcp_seg *next = seg->next;
    tcp_seg_free(seg);
    seg = next;
  }
}
    7f40:	dfc00117 	ldw	ra,4(sp)
    7f44:	dc000017 	ldw	r16,0(sp)
    7f48:	dec00204 	addi	sp,sp,8
    7f4c:	f800283a 	ret

00007f50 <tcp_setprio>:
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  pcb->prio = prio;
    7f50:	21400705 	stb	r5,28(r4)
    7f54:	f800283a 	ret

00007f58 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
    7f58:	defffd04 	addi	sp,sp,-12
    7f5c:	dc400115 	stw	r17,4(sp)
    7f60:	2023883a 	mov	r17,r4
  struct tcp_seg *cseg;

  cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
    7f64:	01000104 	movi	r4,4
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
    7f68:	dc000015 	stw	r16,0(sp)
    7f6c:	dfc00215 	stw	ra,8(sp)
  struct tcp_seg *cseg;

  cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
    7f70:	00060a40 	call	60a4 <memp_malloc>
    7f74:	1021883a 	mov	r16,r2
  if (cseg == NULL) {
    7f78:	10000626 	beq	r2,zero,7f94 <tcp_seg_copy+0x3c>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
    7f7c:	1009883a 	mov	r4,r2
    7f80:	880b883a 	mov	r5,r17
    7f84:	01800404 	movi	r6,16
    7f88:	00102380 	call	10238 <memcpy>
  pbuf_ref(cseg->p);
    7f8c:	81000117 	ldw	r4,4(r16)
    7f90:	0006df00 	call	6df0 <pbuf_ref>
  return cseg;
}
    7f94:	8005883a 	mov	r2,r16
    7f98:	dfc00217 	ldw	ra,8(sp)
    7f9c:	dc400117 	ldw	r17,4(sp)
    7fa0:	dc000017 	ldw	r16,0(sp)
    7fa4:	dec00304 	addi	sp,sp,12
    7fa8:	f800283a 	ret

00007fac <tcp_arg>:
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  pcb->callback_arg = arg;
    7fac:	21400415 	stw	r5,16(r4)
    7fb0:	f800283a 	ret

00007fb4 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
  LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
    7fb4:	20800617 	ldw	r2,24(r4)
 * @param pcb tcp_pcb to set the recv callback
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
    7fb8:	deffff04 	addi	sp,sp,-4
    7fbc:	dfc00015 	stw	ra,0(sp)
  LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
    7fc0:	00c00044 	movi	r3,1
    7fc4:	10c00426 	beq	r2,r3,7fd8 <tcp_recv+0x24>
  pcb->recv = recv;
    7fc8:	21402115 	stw	r5,132(r4)
}
    7fcc:	dfc00017 	ldw	ra,0(sp)
    7fd0:	dec00104 	addi	sp,sp,4
    7fd4:	f800283a 	ret
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
  LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
    7fd8:	010000b4 	movhi	r4,2
    7fdc:	210d4b04 	addi	r4,r4,13612
    7fe0:	014000b4 	movhi	r5,2
    7fe4:	2954d304 	addi	r5,r5,21324
    7fe8:	01815c84 	movi	r6,1394
    7fec:	01c000b4 	movhi	r7,2
    7ff0:	39d4ab04 	addi	r7,r7,21164
    7ff4:	00104380 	call	10438 <printf>
    7ff8:	003fff06 	br	7ff8 <tcp_recv+0x44>

00007ffc <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
  LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
    7ffc:	20800617 	ldw	r2,24(r4)
 * @param pcb tcp_pcb to set the sent callback
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
    8000:	deffff04 	addi	sp,sp,-4
    8004:	dfc00015 	stw	ra,0(sp)
  LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
    8008:	00c00044 	movi	r3,1
    800c:	10c00426 	beq	r2,r3,8020 <tcp_sent+0x24>
  pcb->sent = sent;
    8010:	21402015 	stw	r5,128(r4)
}
    8014:	dfc00017 	ldw	ra,0(sp)
    8018:	dec00104 	addi	sp,sp,4
    801c:	f800283a 	ret
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
  LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
    8020:	010000b4 	movhi	r4,2
    8024:	210d4b04 	addi	r4,r4,13612
    8028:	014000b4 	movhi	r5,2
    802c:	2954dd04 	addi	r5,r5,21364
    8030:	01816004 	movi	r6,1408
    8034:	01c000b4 	movhi	r7,2
    8038:	39d4ab04 	addi	r7,r7,21164
    803c:	00104380 	call	10438 <printf>
    8040:	003fff06 	br	8040 <tcp_sent+0x44>

00008044 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
  LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
    8044:	20800617 	ldw	r2,24(r4)
 * @param err callback function to call for this pcb when a fatal error
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
    8048:	deffff04 	addi	sp,sp,-4
    804c:	dfc00015 	stw	ra,0(sp)
  LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
    8050:	00c00044 	movi	r3,1
    8054:	10c00426 	beq	r2,r3,8068 <tcp_err+0x24>
  pcb->errf = err;
    8058:	21402415 	stw	r5,144(r4)
}
    805c:	dfc00017 	ldw	ra,0(sp)
    8060:	dec00104 	addi	sp,sp,4
    8064:	f800283a 	ret
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
  LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
    8068:	010000b4 	movhi	r4,2
    806c:	210d4b04 	addi	r4,r4,13612
    8070:	014000b4 	movhi	r5,2
    8074:	2954e704 	addi	r5,r5,21404
    8078:	018163c4 	movi	r6,1423
    807c:	01c000b4 	movhi	r7,2
    8080:	39d4ab04 	addi	r7,r7,21164
    8084:	00104380 	call	10438 <printf>
    8088:	003fff06 	br	8088 <tcp_err+0x44>

0000808c <tcp_accept>:
void
tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
{
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  pcb->accept = accept;
    808c:	21400515 	stw	r5,20(r4)
    8090:	f800283a 	ret

00008094 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
    8094:	20800617 	ldw	r2,24(r4)
 * timer interval, which is called twice a second.
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
    8098:	deffff04 	addi	sp,sp,-4
    809c:	dfc00015 	stw	ra,0(sp)
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
    80a0:	00c00044 	movi	r3,1
    80a4:	10c00526 	beq	r2,r3,80bc <tcp_poll+0x28>
#if LWIP_CALLBACK_API
  pcb->poll = poll;
    80a8:	21402315 	stw	r5,140(r4)
#else /* LWIP_CALLBACK_API */  
  LWIP_UNUSED_ARG(poll);
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
    80ac:	21800905 	stb	r6,36(r4)
}
    80b0:	dfc00017 	ldw	ra,0(sp)
    80b4:	dec00104 	addi	sp,sp,4
    80b8:	f800283a 	ret
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
    80bc:	010000b4 	movhi	r4,2
    80c0:	210d4b04 	addi	r4,r4,13612
    80c4:	014000b4 	movhi	r5,2
    80c8:	2954f104 	addi	r5,r5,21444
    80cc:	01816b84 	movi	r6,1454
    80d0:	01c000b4 	movhi	r7,2
    80d4:	39d4ab04 	addi	r7,r7,21164
    80d8:	00104380 	call	10438 <printf>
    80dc:	003fff06 	br	80dc <tcp_poll+0x48>

000080e0 <tcp_pcb_purge>:
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
    80e0:	20800617 	ldw	r2,24(r4)
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
    80e4:	defffe04 	addi	sp,sp,-8
    80e8:	dc000015 	stw	r16,0(sp)
    80ec:	dfc00115 	stw	ra,4(sp)
    80f0:	2021883a 	mov	r16,r4
  if (pcb->state != CLOSED &&
    80f4:	10001426 	beq	r2,zero,8148 <tcp_pcb_purge+0x68>
    80f8:	00c00284 	movi	r3,10
    80fc:	10c01226 	beq	r2,r3,8148 <tcp_pcb_purge+0x68>
     pcb->state != TIME_WAIT &&
    8100:	00c00044 	movi	r3,1
    8104:	10c01026 	beq	r2,r3,8148 <tcp_pcb_purge+0x68>
      }
    }
#endif /* TCP_LISTEN_BACKLOG */


    if (pcb->refused_data != NULL) {
    8108:	21001f17 	ldw	r4,124(r4)
    810c:	20000226 	beq	r4,zero,8118 <tcp_pcb_purge+0x38>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
    8110:	00067d80 	call	67d8 <pbuf_free>
      pcb->refused_data = NULL;
    8114:	80001f15 	stw	zero,124(r16)
    }
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }
    tcp_segs_free(pcb->ooseq);
    8118:	81001e17 	ldw	r4,120(r16)
    811c:	0007f200 	call	7f20 <tcp_segs_free>

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;

    tcp_segs_free(pcb->unsent);
    8120:	81001c17 	ldw	r4,112(r16)
    pcb->ooseq = NULL;
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
    8124:	00bfffc4 	movi	r2,-1
    8128:	80800e0d 	sth	r2,56(r16)
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }
    tcp_segs_free(pcb->ooseq);
    pcb->ooseq = NULL;
    812c:	80001e15 	stw	zero,120(r16)

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;

    tcp_segs_free(pcb->unsent);
    8130:	0007f200 	call	7f20 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
    8134:	81001d17 	ldw	r4,116(r16)
    8138:	0007f200 	call	7f20 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
    813c:	80001c15 	stw	zero,112(r16)
    8140:	80001d15 	stw	zero,116(r16)
#if TCP_OVERSIZE
    pcb->unsent_oversize = 0;
    8144:	80001b8d 	sth	zero,110(r16)
#endif /* TCP_OVERSIZE */
  }
}
    8148:	dfc00117 	ldw	ra,4(sp)
    814c:	dc000017 	ldw	r16,0(sp)
    8150:	dec00204 	addi	sp,sp,8
    8154:	f800283a 	ret

00008158 <tcp_slowtmr>:
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
    8158:	d0e8bd17 	ldw	r3,-23820(gp)
  ++tcp_timer_ctr;
    815c:	d0a8bb43 	ldbu	r2,-23827(gp)
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
    8160:	defff404 	addi	sp,sp,-48
    8164:	dc400315 	stw	r17,12(sp)
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    8168:	04400044 	movi	r17,1
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
    816c:	1c47883a 	add	r3,r3,r17
  ++tcp_timer_ctr;
    8170:	1445883a 	add	r2,r2,r17
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
    8174:	ddc00915 	stw	r23,36(sp)
    8178:	dd800815 	stw	r22,32(sp)
    817c:	dd400715 	stw	r21,28(sp)
    8180:	dfc00b15 	stw	ra,44(sp)
    8184:	df000a15 	stw	fp,40(sp)
    8188:	dd000615 	stw	r20,24(sp)
    818c:	dcc00515 	stw	r19,20(sp)
    8190:	dc800415 	stw	r18,16(sp)
    8194:	dc000215 	stw	r16,8(sp)
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
    8198:	d0e8bd15 	stw	r3,-23820(gp)
  ++tcp_timer_ctr;
    819c:	d0a8bb45 	stb	r2,-23827(gp)
    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
       ((pcb->state == ESTABLISHED) ||
        (pcb->state == CLOSE_WAIT))) {
      if((u32_t)(tcp_ticks - pcb->tmr) >
         (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
    81a0:	05c002b4 	movhi	r23,10
    81a4:	bdd32e04 	addi	r23,r23,19640
        
        ++pcb_remove;
        ++pcb_reset;
      }
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
    81a8:	05800074 	movhi	r22,1
    81ac:	b5893e04 	addi	r22,r22,9464
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
    81b0:	054000b4 	movhi	r21,2
    81b4:	ad55a204 	addi	r21,r21,22152
  ++tcp_timer_ctr;

tcp_slowtmr_start:
  /* Steps through all of the active PCBs. */
  prev = NULL;
  pcb = tcp_active_pcbs;
    81b8:	d428bc17 	ldw	r16,-23824(gp)
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    81bc:	8000a426 	beq	r16,zero,8450 <tcp_slowtmr+0x2f8>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    81c0:	80800617 	ldw	r2,24(r16)
    81c4:	10011826 	beq	r2,zero,8628 <tcp_slowtmr+0x4d0>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    81c8:	14410a26 	beq	r2,r17,85f4 <tcp_slowtmr+0x49c>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
    81cc:	00c00284 	movi	r3,10
    81d0:	10c05526 	beq	r2,r3,8328 <tcp_slowtmr+0x1d0>
    81d4:	0025883a 	mov	r18,zero
    pcb->last_timer = tcp_timer_ctr;

    pcb_remove = 0;
    pcb_reset = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
    81d8:	04c00084 	movi	r19,2
  while (pcb != NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
    if (pcb->last_timer == tcp_timer_ctr) {
    81dc:	d0e8bb43 	ldbu	r3,-23827(gp)
    81e0:	81400943 	ldbu	r5,37(r16)
    81e4:	19003fcc 	andi	r4,r3,255
    81e8:	29009726 	beq	r5,r4,8448 <tcp_slowtmr+0x2f0>
      /* skip this pcb, we have already processed it */
      pcb = pcb->next;
      continue;
    }
    pcb->last_timer = tcp_timer_ctr;
    81ec:	80c00945 	stb	r3,37(r16)

    pcb_remove = 0;
    pcb_reset = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
    81f0:	80c01283 	ldbu	r3,74(r16)
    81f4:	14c0ba26 	beq	r2,r19,84e0 <tcp_slowtmr+0x388>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
    81f8:	01000304 	movi	r4,12
    81fc:	1900ba26 	beq	r3,r4,84e8 <tcp_slowtmr+0x390>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
    8200:	81402643 	ldbu	r5,153(r16)
    8204:	29003fcc 	andi	r4,r5,255
    8208:	20005b26 	beq	r4,zero,8378 <tcp_slowtmr+0x220>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
    820c:	80802603 	ldbu	r2,152(r16)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
    8210:	d1a00404 	addi	r6,gp,-32752
    8214:	3107883a 	add	r3,r6,r4
    8218:	18ffffc3 	ldbu	r3,-1(r3)
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
    821c:	10800044 	addi	r2,r2,1
    8220:	80802605 	stb	r2,152(r16)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
    8224:	10803fcc 	andi	r2,r2,255
    8228:	10c07836 	bltu	r2,r3,840c <tcp_slowtmr+0x2b4>
          pcb->persist_cnt = 0;
    822c:	80002605 	stb	zero,152(r16)
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
    8230:	00800184 	movi	r2,6
    8234:	11000236 	bltu	r2,r4,8240 <tcp_slowtmr+0xe8>
            pcb->persist_backoff++;
    8238:	29400044 	addi	r5,r5,1
    823c:	81402645 	stb	r5,153(r16)
          }
          tcp_zero_window_probe(pcb);
    8240:	8009883a 	mov	r4,r16
    8244:	000ce480 	call	ce48 <tcp_zero_window_probe>
      pcb = pcb->next;
      continue;
    }
    pcb->last_timer = tcp_timer_ctr;

    pcb_remove = 0;
    8248:	0039883a 	mov	fp,zero
          tcp_rexmit_rto(pcb);
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
    824c:	80800617 	ldw	r2,24(r16)
    8250:	00c00184 	movi	r3,6
    8254:	10c07126 	beq	r2,r3,841c <tcp_slowtmr+0x2c4>
        }
      }
    }

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
    8258:	80c00203 	ldbu	r3,8(r16)
    825c:	18c0020c 	andi	r3,r3,8
    8260:	18c03fcc 	andi	r3,r3,255
    8264:	18000426 	beq	r3,zero,8278 <tcp_slowtmr+0x120>
    8268:	00c00104 	movi	r3,4
    826c:	10c03726 	beq	r2,r3,834c <tcp_slowtmr+0x1f4>
       ((pcb->state == ESTABLISHED) ||
    8270:	00c001c4 	movi	r3,7
    8274:	10c03526 	beq	r2,r3,834c <tcp_slowtmr+0x1f4>
      continue;
    }
    pcb->last_timer = tcp_timer_ctr;

    pcb_remove = 0;
    pcb_reset = 0;
    8278:	0029883a 	mov	r20,zero

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL &&
    827c:	81001e17 	ldw	r4,120(r16)
    8280:	20000626 	beq	r4,zero,829c <tcp_slowtmr+0x144>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
    8284:	8080120f 	ldh	r2,72(r16)
    8288:	81400a17 	ldw	r5,40(r16)
    828c:	d1a8bd17 	ldw	r6,-23820(gp)
    8290:	108001a4 	muli	r2,r2,6
    8294:	314bc83a 	sub	r5,r6,r5

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL &&
    8298:	2880b82e 	bgeu	r5,r2,857c <tcp_slowtmr+0x424>
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
    829c:	80800617 	ldw	r2,24(r16)
    82a0:	010000c4 	movi	r4,3
    82a4:	1100ae26 	beq	r2,r4,8560 <tcp_slowtmr+0x408>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
    82a8:	01000244 	movi	r4,9
    82ac:	11009026 	beq	r2,r4,84f0 <tcp_slowtmr+0x398>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
    82b0:	e7003fcc 	andi	fp,fp,255
    82b4:	e000931e 	bne	fp,zero,8504 <tcp_slowtmr+0x3ac>
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
      pcb = pcb->next;

      /* We check if we should poll the connection. */
      ++prev->polltmr;
    82b8:	808008c3 	ldbu	r2,35(r16)
      if (prev->polltmr >= prev->pollinterval) {
    82bc:	80c00903 	ldbu	r3,36(r16)
        goto tcp_slowtmr_start;
      }
    } else {
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
      pcb = pcb->next;
    82c0:	87000317 	ldw	fp,12(r16)

      /* We check if we should poll the connection. */
      ++prev->polltmr;
    82c4:	10800044 	addi	r2,r2,1
    82c8:	808008c5 	stb	r2,35(r16)
      if (prev->polltmr >= prev->pollinterval) {
    82cc:	10803fcc 	andi	r2,r2,255
    82d0:	10c00d36 	bltu	r2,r3,8308 <tcp_slowtmr+0x1b0>
        prev->polltmr = 0;
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        tcp_active_pcbs_changed = 0;
        TCP_EVENT_POLL(prev, err);
    82d4:	80802317 	ldw	r2,140(r16)
      pcb = pcb->next;

      /* We check if we should poll the connection. */
      ++prev->polltmr;
      if (prev->polltmr >= prev->pollinterval) {
        prev->polltmr = 0;
    82d8:	800008c5 	stb	zero,35(r16)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        tcp_active_pcbs_changed = 0;
    82dc:	d028bb85 	stb	zero,-23826(gp)
        TCP_EVENT_POLL(prev, err);
    82e0:	1000a926 	beq	r2,zero,8588 <tcp_slowtmr+0x430>
    82e4:	81000417 	ldw	r4,16(r16)
    82e8:	800b883a 	mov	r5,r16
    82ec:	103ee83a 	callr	r2
        if (tcp_active_pcbs_changed) {
    82f0:	d0e8bb83 	ldbu	r3,-23826(gp)
    82f4:	183fb01e 	bne	r3,zero,81b8 <tcp_slowtmr+0x60>
          goto tcp_slowtmr_start;
        }
        /* if err == ERR_ABRT, 'prev' is already deallocated */
        if (err == ERR_OK) {
    82f8:	10803fcc 	andi	r2,r2,255
    82fc:	1080201c 	xori	r2,r2,128
    8300:	10bfe004 	addi	r2,r2,-128
    8304:	1000a026 	beq	r2,zero,8588 <tcp_slowtmr+0x430>
      prev = pcb;
      pcb = pcb->next;

      /* We check if we should poll the connection. */
      ++prev->polltmr;
      if (prev->polltmr >= prev->pollinterval) {
    8308:	8025883a 	mov	r18,r16
        goto tcp_slowtmr_start;
      }
    } else {
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
      pcb = pcb->next;
    830c:	e021883a 	mov	r16,fp
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    8310:	80004f26 	beq	r16,zero,8450 <tcp_slowtmr+0x2f8>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    8314:	80800617 	ldw	r2,24(r16)
    8318:	1000c326 	beq	r2,zero,8628 <tcp_slowtmr+0x4d0>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    831c:	1440b526 	beq	r2,r17,85f4 <tcp_slowtmr+0x49c>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
    8320:	00c00284 	movi	r3,10
    8324:	10ffad1e 	bne	r2,r3,81dc <tcp_slowtmr+0x84>
    8328:	010000b4 	movhi	r4,2
    832c:	210d4b04 	addi	r4,r4,13612
    8330:	014000b4 	movhi	r5,2
    8334:	29550f04 	addi	r5,r5,21564
    8338:	0180cb04 	movi	r6,812
    833c:	01c000b4 	movhi	r7,2
    8340:	39d4ab04 	addi	r7,r7,21164
    8344:	00104380 	call	10438 <printf>
    8348:	003fff06 	br	8348 <tcp_slowtmr+0x1f0>
    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
       ((pcb->state == ESTABLISHED) ||
        (pcb->state == CLOSE_WAIT))) {
      if((u32_t)(tcp_ticks - pcb->tmr) >
         (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
    834c:	81002517 	ldw	r4,148(r16)

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
       ((pcb->state == ESTABLISHED) ||
        (pcb->state == CLOSE_WAIT))) {
      if((u32_t)(tcp_ticks - pcb->tmr) >
    8350:	80800a17 	ldw	r2,40(r16)
    8354:	d1a8bd17 	ldw	r6,-23820(gp)
         (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
    8358:	25cb883a 	add	r5,r4,r23
    835c:	00c07d04 	movi	r3,500

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
       ((pcb->state == ESTABLISHED) ||
        (pcb->state == CLOSE_WAIT))) {
      if((u32_t)(tcp_ticks - pcb->tmr) >
    8360:	3085c83a 	sub	r2,r6,r2
         (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
    8364:	28cb203a 	divu	r5,r5,r3

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
       ((pcb->state == ESTABLISHED) ||
        (pcb->state == CLOSE_WAIT))) {
      if((u32_t)(tcp_ticks - pcb->tmr) >
    8368:	28808c2e 	bgeu	r5,r2,859c <tcp_slowtmr+0x444>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                                ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
        
        ++pcb_remove;
    836c:	e7000044 	addi	fp,fp,1
        ++pcb_reset;
    8370:	05000044 	movi	r20,1
    8374:	003fc106 	br	827c <tcp_slowtmr+0x124>
          }
          tcp_zero_window_probe(pcb);
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0) {
    8378:	81000e0b 	ldhu	r4,56(r16)
    837c:	217fffcc 	andi	r5,r4,65535
    8380:	2960001c 	xori	r5,r5,32768
    8384:	29600004 	addi	r5,r5,-32768
    8388:	28000216 	blt	r5,zero,8394 <tcp_slowtmr+0x23c>
          ++pcb->rtime;
    838c:	21000044 	addi	r4,r4,1
    8390:	81000e0d 	sth	r4,56(r16)
        }

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
    8394:	81001d17 	ldw	r4,116(r16)
    8398:	20001c26 	beq	r4,zero,840c <tcp_slowtmr+0x2b4>
    839c:	81400e0f 	ldh	r5,56(r16)
    83a0:	8100120f 	ldh	r4,72(r16)
    83a4:	29001916 	blt	r5,r4,840c <tcp_slowtmr+0x2b4>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
    83a8:	14c00826 	beq	r2,r19,83cc <tcp_slowtmr+0x274>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
    83ac:	8140110f 	ldh	r5,68(r16)
    83b0:	a8c5883a 	add	r2,r21,r3
    83b4:	8100118f 	ldh	r4,70(r16)
    83b8:	2807d0fa 	srai	r3,r5,3
    83bc:	10800003 	ldbu	r2,0(r2)
    83c0:	1907883a 	add	r3,r3,r4
    83c4:	1884983a 	sll	r2,r3,r2
    83c8:	8080120d 	sth	r2,72(r16)

          /* Reset the retransmission timer. */
          pcb->rtime = 0;

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
    83cc:	80c0140b 	ldhu	r3,80(r16)
    83d0:	8080190b 	ldhu	r2,100(r16)
          if (pcb->state != SYN_SENT) {
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
    83d4:	80000e0d 	sth	zero,56(r16)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
    83d8:	10c0012e 	bgeu	r2,r3,83e0 <tcp_slowtmr+0x288>
    83dc:	1007883a 	mov	r3,r2
          pcb->ssthresh = eff_wnd >> 1;
          if (pcb->ssthresh < (pcb->mss << 1)) {
    83e0:	80800e8b 	ldhu	r2,58(r16)
          /* Reset the retransmission timer. */
          pcb->rtime = 0;

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
    83e4:	1806d07a 	srli	r3,r3,1
          if (pcb->ssthresh < (pcb->mss << 1)) {
    83e8:	113fffcc 	andi	r4,r2,65535
          /* Reset the retransmission timer. */
          pcb->rtime = 0;

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
    83ec:	80c0148d 	sth	r3,82(r16)
          if (pcb->ssthresh < (pcb->mss << 1)) {
    83f0:	2109883a 	add	r4,r4,r4
    83f4:	1900020e 	bge	r3,r4,8400 <tcp_slowtmr+0x2a8>
            pcb->ssthresh = (pcb->mss << 1);
    83f8:	1087883a 	add	r3,r2,r2
    83fc:	80c0148d 	sth	r3,82(r16)
          }
          pcb->cwnd = pcb->mss;
    8400:	8080140d 	sth	r2,80(r16)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
    8404:	8009883a 	mov	r4,r16
    8408:	000cb6c0 	call	cb6c <tcp_rexmit_rto>
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
    840c:	80800617 	ldw	r2,24(r16)
    8410:	00c00184 	movi	r3,6
      pcb = pcb->next;
      continue;
    }
    pcb->last_timer = tcp_timer_ctr;

    pcb_remove = 0;
    8414:	0039883a 	mov	fp,zero
          tcp_rexmit_rto(pcb);
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
    8418:	10ff8f1e 	bne	r2,r3,8258 <tcp_slowtmr+0x100>
      /* If this PCB is in FIN_WAIT_2 because of SHUT_WR don't let it time out. */
      if (pcb->flags & TF_RXCLOSED) {
    841c:	80800883 	ldbu	r2,34(r16)
    8420:	1080040c 	andi	r2,r2,16
    8424:	10803fcc 	andi	r2,r2,255
    8428:	103f9326 	beq	r2,zero,8278 <tcp_slowtmr+0x120>
        /* PCB was fully closed (either through close() or SHUT_RDWR):
           normal FIN-WAIT timeout handling. */
        if ((u32_t)(tcp_ticks - pcb->tmr) >
    842c:	d0e8bd17 	ldw	r3,-23820(gp)
    8430:	80800a17 	ldw	r2,40(r16)
    8434:	1885c83a 	sub	r2,r3,r2
    8438:	00c00a04 	movi	r3,40
    843c:	18bf8e2e 	bgeu	r3,r2,8278 <tcp_slowtmr+0x120>
            TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
          ++pcb_remove;
    8440:	e7000044 	addi	fp,fp,1
    8444:	003f8c06 	br	8278 <tcp_slowtmr+0x120>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
    if (pcb->last_timer == tcp_timer_ctr) {
      /* skip this pcb, we have already processed it */
      pcb = pcb->next;
    8448:	84000317 	ldw	r16,12(r16)
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    844c:	803fb11e 	bne	r16,zero,8314 <tcp_slowtmr+0x1bc>
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
  pcb = tcp_tw_pcbs;
    8450:	d428c117 	ldw	r16,-23804(gp)
  while (pcb != NULL) {
    8454:	80008026 	beq	r16,zero,8658 <tcp_slowtmr+0x500>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
    8458:	80800617 	ldw	r2,24(r16)
    845c:	00c00284 	movi	r3,10
    8460:	0023883a 	mov	r17,zero
    8464:	10c0151e 	bne	r2,r3,84bc <tcp_slowtmr+0x364>
    pcb_remove = 0;

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
    8468:	04c03c04 	movi	r19,240
  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
    846c:	1025883a 	mov	r18,r2
    pcb_remove = 0;

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
    8470:	80800a17 	ldw	r2,40(r16)
    8474:	d0e8bd17 	ldw	r3,-23820(gp)
    8478:	1885c83a 	sub	r2,r3,r2
    847c:	9880732e 	bgeu	r19,r2,864c <tcp_slowtmr+0x4f4>


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
      struct tcp_pcb *pcb2;
      tcp_pcb_purge(pcb);
    8480:	8009883a 	mov	r4,r16
    8484:	00080e00 	call	80e0 <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
    8488:	88007f26 	beq	r17,zero,8688 <tcp_slowtmr+0x530>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
    848c:	d0a8c117 	ldw	r2,-23804(gp)
    8490:	80808226 	beq	r16,r2,869c <tcp_slowtmr+0x544>
        prev->next = pcb->next;
    8494:	80800317 	ldw	r2,12(r16)
    8498:	88800315 	stw	r2,12(r17)
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
        tcp_tw_pcbs = pcb->next;
      }
      pcb2 = pcb;
      pcb = pcb->next;
    849c:	85000317 	ldw	r20,12(r16)
      memp_free(MEMP_TCP_PCB, pcb2);
    84a0:	800b883a 	mov	r5,r16
    84a4:	01000084 	movi	r4,2
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
        tcp_tw_pcbs = pcb->next;
      }
      pcb2 = pcb;
      pcb = pcb->next;
    84a8:	a021883a 	mov	r16,r20
      memp_free(MEMP_TCP_PCB, pcb2);
    84ac:	000618c0 	call	618c <memp_free>

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
    84b0:	80006926 	beq	r16,zero,8658 <tcp_slowtmr+0x500>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
    84b4:	80800617 	ldw	r2,24(r16)
    84b8:	14bfed26 	beq	r2,r18,8470 <tcp_slowtmr+0x318>
    84bc:	010000b4 	movhi	r4,2
    84c0:	210d4b04 	addi	r4,r4,13612
    84c4:	014000b4 	movhi	r5,2
    84c8:	29553104 	addi	r5,r5,21700
    84cc:	0180fb84 	movi	r6,1006
    84d0:	01c000b4 	movhi	r7,2
    84d4:	39d4ab04 	addi	r7,r7,21164
    84d8:	00104380 	call	10438 <printf>
    84dc:	003fff06 	br	84dc <tcp_slowtmr+0x384>
    pcb->last_timer = tcp_timer_ctr;

    pcb_remove = 0;
    pcb_reset = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
    84e0:	01000184 	movi	r4,6
    84e4:	193f441e 	bne	r3,r4,81f8 <tcp_slowtmr+0xa0>
      ++pcb_remove;
    84e8:	07000044 	movi	fp,1
    84ec:	003f5706 	br	824c <tcp_slowtmr+0xf4>
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
    84f0:	d128bd17 	ldw	r4,-23820(gp)
    84f4:	80800a17 	ldw	r2,40(r16)
    84f8:	2085c83a 	sub	r2,r4,r2
    84fc:	01003c04 	movi	r4,240
    8500:	20bf6b2e 	bgeu	r4,r2,82b0 <tcp_slowtmr+0x158>
    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
      struct tcp_pcb *pcb2;
      tcp_err_fn err_fn;
      void *err_arg;
      tcp_pcb_purge(pcb);
    8504:	8009883a 	mov	r4,r16
    8508:	00080e00 	call	80e0 <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
    850c:	d0a8bc17 	ldw	r2,-23824(gp)
      struct tcp_pcb *pcb2;
      tcp_err_fn err_fn;
      void *err_arg;
      tcp_pcb_purge(pcb);
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
    8510:	90004126 	beq	r18,zero,8618 <tcp_slowtmr+0x4c0>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
    8514:	80807326 	beq	r16,r2,86e4 <tcp_slowtmr+0x58c>
        prev->next = pcb->next;
    8518:	80800317 	ldw	r2,12(r16)
    851c:	90800315 	stw	r2,12(r18)
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
      }

      if (pcb_reset) {
    8520:	a0c03fcc 	andi	r3,r20,255
    8524:	1800291e 	bne	r3,zero,85cc <tcp_slowtmr+0x474>
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
          pcb->local_port, pcb->remote_port);
      }

      err_fn = pcb->errf;
    8528:	87002417 	ldw	fp,144(r16)
      err_arg = pcb->callback_arg;
      pcb2 = pcb;
      pcb = pcb->next;
      memp_free(MEMP_TCP_PCB, pcb2);
    852c:	800b883a 	mov	r5,r16
    8530:	01000084 	movi	r4,2
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
          pcb->local_port, pcb->remote_port);
      }

      err_fn = pcb->errf;
      err_arg = pcb->callback_arg;
    8534:	85000417 	ldw	r20,16(r16)
      pcb2 = pcb;
      pcb = pcb->next;
    8538:	84000317 	ldw	r16,12(r16)
      memp_free(MEMP_TCP_PCB, pcb2);
    853c:	000618c0 	call	618c <memp_free>

      tcp_active_pcbs_changed = 0;
    8540:	d028bb85 	stb	zero,-23826(gp)
      TCP_EVENT_ERR(err_fn, err_arg, ERR_ABRT);
    8544:	e03f7226 	beq	fp,zero,8310 <tcp_slowtmr+0x1b8>
    8548:	a009883a 	mov	r4,r20
    854c:	017ffd84 	movi	r5,-10
    8550:	e03ee83a 	callr	fp
      if (tcp_active_pcbs_changed) {
    8554:	d0a8bb83 	ldbu	r2,-23826(gp)
    8558:	103f6d26 	beq	r2,zero,8310 <tcp_slowtmr+0x1b8>
    855c:	003f1606 	br	81b8 <tcp_slowtmr+0x60>
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
      if ((u32_t)(tcp_ticks - pcb->tmr) >
    8560:	d128bd17 	ldw	r4,-23820(gp)
    8564:	80800a17 	ldw	r2,40(r16)
    8568:	2085c83a 	sub	r2,r4,r2
    856c:	01000a04 	movi	r4,40
    8570:	20bf4f2e 	bgeu	r4,r2,82b0 <tcp_slowtmr+0x158>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
    8574:	e7000044 	addi	fp,fp,1
    8578:	003f4d06 	br	82b0 <tcp_slowtmr+0x158>
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL &&
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
    857c:	0007f200 	call	7f20 <tcp_segs_free>
      pcb->ooseq = NULL;
    8580:	80001e15 	stw	zero,120(r16)
    8584:	003f4506 	br	829c <tcp_slowtmr+0x144>
        if (tcp_active_pcbs_changed) {
          goto tcp_slowtmr_start;
        }
        /* if err == ERR_ABRT, 'prev' is already deallocated */
        if (err == ERR_OK) {
          tcp_output(prev);
    8588:	8009883a 	mov	r4,r16
    858c:	8025883a 	mov	r18,r16
    8590:	000c38c0 	call	c38c <tcp_output>
        goto tcp_slowtmr_start;
      }
    } else {
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
      pcb = pcb->next;
    8594:	e021883a 	mov	r16,fp
    8598:	003f5d06 	br	8310 <tcp_slowtmr+0x1b8>
        
        ++pcb_remove;
        ++pcb_reset;
      }
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
    859c:	81402683 	ldbu	r5,154(r16)
    85a0:	2d8b383a 	mul	r5,r5,r22
    85a4:	2909883a 	add	r4,r5,r4
              / TCP_SLOW_INTERVAL)
    85a8:	20c7203a 	divu	r3,r4,r3
                                ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
        
        ++pcb_remove;
        ++pcb_reset;
      }
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
    85ac:	18bf322e 	bgeu	r3,r2,8278 <tcp_slowtmr+0x120>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
              / TCP_SLOW_INTERVAL)
      {
        tcp_keepalive(pcb);
    85b0:	8009883a 	mov	r4,r16
    85b4:	000cd4c0 	call	cd4c <tcp_keepalive>
        pcb->keep_cnt_sent++;
    85b8:	80802683 	ldbu	r2,154(r16)
      continue;
    }
    pcb->last_timer = tcp_timer_ctr;

    pcb_remove = 0;
    pcb_reset = 0;
    85bc:	0029883a 	mov	r20,zero
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
              / TCP_SLOW_INTERVAL)
      {
        tcp_keepalive(pcb);
        pcb->keep_cnt_sent++;
    85c0:	10800044 	addi	r2,r2,1
    85c4:	80802685 	stb	r2,154(r16)
    85c8:	003f2c06 	br	827c <tcp_slowtmr+0x124>
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
      }

      if (pcb_reset) {
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
    85cc:	8080078b 	ldhu	r2,30(r16)
    85d0:	81001517 	ldw	r4,84(r16)
    85d4:	81400b17 	ldw	r5,44(r16)
    85d8:	d8800015 	stw	r2,0(sp)
    85dc:	8080080b 	ldhu	r2,32(r16)
    85e0:	800d883a 	mov	r6,r16
    85e4:	81c00104 	addi	r7,r16,4
    85e8:	d8800115 	stw	r2,4(sp)
    85ec:	000c99c0 	call	c99c <tcp_rst>
    85f0:	003fcd06 	br	8528 <tcp_slowtmr+0x3d0>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    85f4:	010000b4 	movhi	r4,2
    85f8:	210d4b04 	addi	r4,r4,13612
    85fc:	014000b4 	movhi	r5,2
    8600:	29550404 	addi	r5,r5,21520
    8604:	0180cac4 	movi	r6,811
    8608:	01c000b4 	movhi	r7,2
    860c:	39d4ab04 	addi	r7,r7,21164
    8610:	00104380 	call	10438 <printf>
    8614:	003fff06 	br	8614 <tcp_slowtmr+0x4bc>
      if (prev != NULL) {
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
        prev->next = pcb->next;
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
    8618:	14003b1e 	bne	r2,r16,8708 <tcp_slowtmr+0x5b0>
        tcp_active_pcbs = pcb->next;
    861c:	80800317 	ldw	r2,12(r16)
    8620:	d0a8bc15 	stw	r2,-23824(gp)
    8624:	003fbe06 	br	8520 <tcp_slowtmr+0x3c8>
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    8628:	010000b4 	movhi	r4,2
    862c:	210d4b04 	addi	r4,r4,13612
    8630:	014000b4 	movhi	r5,2
    8634:	2954f904 	addi	r5,r5,21476
    8638:	0180ca84 	movi	r6,810
    863c:	01c000b4 	movhi	r7,2
    8640:	39d4ab04 	addi	r7,r7,21164
    8644:	00104380 	call	10438 <printf>
    8648:	003fff06 	br	8648 <tcp_slowtmr+0x4f0>
      pcb2 = pcb;
      pcb = pcb->next;
      memp_free(MEMP_TCP_PCB, pcb2);
    } else {
      prev = pcb;
      pcb = pcb->next;
    864c:	8023883a 	mov	r17,r16
    8650:	84000317 	ldw	r16,12(r16)

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
    8654:	803f971e 	bne	r16,zero,84b4 <tcp_slowtmr+0x35c>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
    8658:	dfc00b17 	ldw	ra,44(sp)
    865c:	df000a17 	ldw	fp,40(sp)
    8660:	ddc00917 	ldw	r23,36(sp)
    8664:	dd800817 	ldw	r22,32(sp)
    8668:	dd400717 	ldw	r21,28(sp)
    866c:	dd000617 	ldw	r20,24(sp)
    8670:	dcc00517 	ldw	r19,20(sp)
    8674:	dc800417 	ldw	r18,16(sp)
    8678:	dc400317 	ldw	r17,12(sp)
    867c:	dc000217 	ldw	r16,8(sp)
    8680:	dec00c04 	addi	sp,sp,48
    8684:	f800283a 	ret
      if (prev != NULL) {
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
        prev->next = pcb->next;
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
    8688:	d0a8c117 	ldw	r2,-23804(gp)
    868c:	14000c1e 	bne	r2,r16,86c0 <tcp_slowtmr+0x568>
        tcp_tw_pcbs = pcb->next;
    8690:	80800317 	ldw	r2,12(r16)
    8694:	d0a8c115 	stw	r2,-23804(gp)
    8698:	003f8006 	br	849c <tcp_slowtmr+0x344>
    if (pcb_remove) {
      struct tcp_pcb *pcb2;
      tcp_pcb_purge(pcb);
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
    869c:	010000b4 	movhi	r4,2
    86a0:	210d4b04 	addi	r4,r4,13612
    86a4:	014000b4 	movhi	r5,2
    86a8:	29553d04 	addi	r5,r5,21748
    86ac:	0180ff84 	movi	r6,1022
    86b0:	01c000b4 	movhi	r7,2
    86b4:	39d4ab04 	addi	r7,r7,21164
    86b8:	00104380 	call	10438 <printf>
    86bc:	003fff06 	br	86bc <tcp_slowtmr+0x564>
        prev->next = pcb->next;
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
    86c0:	010000b4 	movhi	r4,2
    86c4:	210d4b04 	addi	r4,r4,13612
    86c8:	014000b4 	movhi	r5,2
    86cc:	29554704 	addi	r5,r5,21788
    86d0:	01810084 	movi	r6,1026
    86d4:	01c000b4 	movhi	r7,2
    86d8:	39d4ab04 	addi	r7,r7,21164
    86dc:	00104380 	call	10438 <printf>
    86e0:	003fff06 	br	86e0 <tcp_slowtmr+0x588>
      tcp_err_fn err_fn;
      void *err_arg;
      tcp_pcb_purge(pcb);
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
    86e4:	010000b4 	movhi	r4,2
    86e8:	210d4b04 	addi	r4,r4,13612
    86ec:	014000b4 	movhi	r5,2
    86f0:	29551b04 	addi	r5,r5,21612
    86f4:	0180ee84 	movi	r6,954
    86f8:	01c000b4 	movhi	r7,2
    86fc:	39d4ab04 	addi	r7,r7,21164
    8700:	00104380 	call	10438 <printf>
    8704:	003fff06 	br	8704 <tcp_slowtmr+0x5ac>
        prev->next = pcb->next;
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
    8708:	010000b4 	movhi	r4,2
    870c:	210d4b04 	addi	r4,r4,13612
    8710:	014000b4 	movhi	r5,2
    8714:	29552604 	addi	r5,r5,21656
    8718:	0180ef84 	movi	r6,958
    871c:	01c000b4 	movhi	r7,2
    8720:	39d4ab04 	addi	r7,r7,21164
    8724:	00104380 	call	10438 <printf>
    8728:	003fff06 	br	8728 <tcp_slowtmr+0x5d0>

0000872c <tcp_pcb_remove>:
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  TCP_RMV(pcblist, pcb);
    872c:	20800017 	ldw	r2,0(r4)
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
    8730:	defffd04 	addi	sp,sp,-12
    8734:	dc000015 	stw	r16,0(sp)
    8738:	dfc00215 	stw	ra,8(sp)
    873c:	dc400115 	stw	r17,4(sp)
    8740:	2821883a 	mov	r16,r5
  TCP_RMV(pcblist, pcb);
    8744:	11402526 	beq	r2,r5,87dc <tcp_pcb_remove+0xb0>
    8748:	d0a8bf15 	stw	r2,-23812(gp)
    874c:	10000826 	beq	r2,zero,8770 <tcp_pcb_remove+0x44>
    8750:	10c00317 	ldw	r3,12(r2)
    8754:	19401e26 	beq	r3,r5,87d0 <tcp_pcb_remove+0xa4>
    8758:	18000426 	beq	r3,zero,876c <tcp_pcb_remove+0x40>
    875c:	18800317 	ldw	r2,12(r3)
    8760:	14001926 	beq	r2,r16,87c8 <tcp_pcb_remove+0x9c>
    8764:	1007883a 	mov	r3,r2
    8768:	183ffc1e 	bne	r3,zero,875c <tcp_pcb_remove+0x30>
    876c:	d028bf15 	stw	zero,-23812(gp)
    8770:	80000315 	stw	zero,12(r16)

  tcp_pcb_purge(pcb);
    8774:	8009883a 	mov	r4,r16
    8778:	00080e00 	call	80e0 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
    877c:	80800617 	ldw	r2,24(r16)
    8780:	00c00284 	movi	r3,10
    8784:	10c00526 	beq	r2,r3,879c <tcp_pcb_remove+0x70>
    8788:	04400044 	movi	r17,1
    878c:	14403226 	beq	r2,r17,8858 <tcp_pcb_remove+0x12c>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
    8790:	80800883 	ldbu	r2,34(r16)

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
    8794:	1446703a 	and	r3,r2,r17
    8798:	1800291e 	bne	r3,zero,8840 <tcp_pcb_remove+0x114>
    pcb->flags |= TF_ACK_NOW;
    tcp_output(pcb);
  }

  if (pcb->state != LISTEN) {
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
    879c:	80801c17 	ldw	r2,112(r16)
    87a0:	10001126 	beq	r2,zero,87e8 <tcp_pcb_remove+0xbc>
    87a4:	010000b4 	movhi	r4,2
    87a8:	210d4b04 	addi	r4,r4,13612
    87ac:	014000b4 	movhi	r5,2
    87b0:	29555104 	addi	r5,r5,21828
    87b4:	01818444 	movi	r6,1553
    87b8:	01c000b4 	movhi	r7,2
    87bc:	39d4ab04 	addi	r7,r7,21164
    87c0:	00104380 	call	10438 <printf>
    87c4:	003fff06 	br	87c4 <tcp_pcb_remove+0x98>
    87c8:	d0e8bf15 	stw	r3,-23812(gp)
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  TCP_RMV(pcblist, pcb);
    87cc:	1805883a 	mov	r2,r3
    87d0:	80c00317 	ldw	r3,12(r16)
    87d4:	10c00315 	stw	r3,12(r2)
    87d8:	003fe506 	br	8770 <tcp_pcb_remove+0x44>
    87dc:	28800317 	ldw	r2,12(r5)
    87e0:	20800015 	stw	r2,0(r4)
    87e4:	003fe206 	br	8770 <tcp_pcb_remove+0x44>
    tcp_output(pcb);
  }

  if (pcb->state != LISTEN) {
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
    87e8:	80801d17 	ldw	r2,116(r16)
    87ec:	10000926 	beq	r2,zero,8814 <tcp_pcb_remove+0xe8>
    87f0:	010000b4 	movhi	r4,2
    87f4:	210d4b04 	addi	r4,r4,13612
    87f8:	014000b4 	movhi	r5,2
    87fc:	29555704 	addi	r5,r5,21852
    8800:	01818484 	movi	r6,1554
    8804:	01c000b4 	movhi	r7,2
    8808:	39d4ab04 	addi	r7,r7,21164
    880c:	00104380 	call	10438 <printf>
    8810:	003fff06 	br	8810 <tcp_pcb_remove+0xe4>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
    8814:	80801e17 	ldw	r2,120(r16)
    8818:	10000f26 	beq	r2,zero,8858 <tcp_pcb_remove+0x12c>
    881c:	010000b4 	movhi	r4,2
    8820:	210d4b04 	addi	r4,r4,13612
    8824:	014000b4 	movhi	r5,2
    8828:	29555e04 	addi	r5,r5,21880
    882c:	01818504 	movi	r6,1556
    8830:	01c000b4 	movhi	r7,2
    8834:	39d4ab04 	addi	r7,r7,21164
    8838:	00104380 	call	10438 <printf>
    883c:	003fff06 	br	883c <tcp_pcb_remove+0x110>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
    8840:	10800094 	ori	r2,r2,2
    8844:	80800885 	stb	r2,34(r16)
    tcp_output(pcb);
    8848:	8009883a 	mov	r4,r16
    884c:	000c38c0 	call	c38c <tcp_output>
  }

  if (pcb->state != LISTEN) {
    8850:	80800617 	ldw	r2,24(r16)
    8854:	147fd11e 	bne	r2,r17,879c <tcp_pcb_remove+0x70>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
    8858:	80000615 	stw	zero,24(r16)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
    885c:	dfc00217 	ldw	ra,8(sp)
    8860:	dc400117 	ldw	r17,4(sp)
    8864:	dc000017 	ldw	r16,0(sp)
    8868:	dec00304 	addi	sp,sp,12
    886c:	f800283a 	ret

00008870 <tcp_abandon>:
  tcp_err_fn errf;
#endif /* LWIP_CALLBACK_API */
  void *errf_arg;

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
    8870:	20800617 	ldw	r2,24(r4)
 * @param pcb the tcp_pcb to abort
 * @param reset boolean to indicate whether a reset should be sent
 */
void
tcp_abandon(struct tcp_pcb *pcb, int reset)
{
    8874:	defff604 	addi	sp,sp,-40
    8878:	dd400715 	stw	r21,28(sp)
    887c:	dc800415 	stw	r18,16(sp)
    8880:	dc000215 	stw	r16,8(sp)
    8884:	dfc00915 	stw	ra,36(sp)
    8888:	dd800815 	stw	r22,32(sp)
    888c:	dd000615 	stw	r20,24(sp)
    8890:	dcc00515 	stw	r19,20(sp)
    8894:	dc400315 	stw	r17,12(sp)
  tcp_err_fn errf;
#endif /* LWIP_CALLBACK_API */
  void *errf_arg;

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
    8898:	04800044 	movi	r18,1
 * @param pcb the tcp_pcb to abort
 * @param reset boolean to indicate whether a reset should be sent
 */
void
tcp_abandon(struct tcp_pcb *pcb, int reset)
{
    889c:	2021883a 	mov	r16,r4
    88a0:	282b883a 	mov	r21,r5
  tcp_err_fn errf;
#endif /* LWIP_CALLBACK_API */
  void *errf_arg;

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
    88a4:	14802526 	beq	r2,r18,893c <tcp_abandon+0xcc>
    pcb->state != LISTEN);
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
    88a8:	00c00284 	movi	r3,10
    88ac:	10c04026 	beq	r2,r3,89b0 <tcp_abandon+0x140>
    ackno = pcb->rcv_nxt;
#if LWIP_CALLBACK_API
    errf = pcb->errf;
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
    TCP_PCB_REMOVE_ACTIVE(pcb);
    88b0:	d128bc04 	addi	r4,gp,-23824
    88b4:	800b883a 	mov	r5,r16
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
  } else {
    seqno = pcb->snd_nxt;
    88b8:	85801517 	ldw	r22,84(r16)
    ackno = pcb->rcv_nxt;
    88bc:	85000b17 	ldw	r20,44(r16)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
    88c0:	84402417 	ldw	r17,144(r16)
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
    88c4:	84c00417 	ldw	r19,16(r16)
    TCP_PCB_REMOVE_ACTIVE(pcb);
    88c8:	000872c0 	call	872c <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
    88cc:	81001d17 	ldw	r4,116(r16)
    ackno = pcb->rcv_nxt;
#if LWIP_CALLBACK_API
    errf = pcb->errf;
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
    TCP_PCB_REMOVE_ACTIVE(pcb);
    88d0:	d4a8bb85 	stb	r18,-23826(gp)
    if (pcb->unacked != NULL) {
    88d4:	20000126 	beq	r4,zero,88dc <tcp_abandon+0x6c>
      tcp_segs_free(pcb->unacked);
    88d8:	0007f200 	call	7f20 <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
    88dc:	81001c17 	ldw	r4,112(r16)
    88e0:	20000126 	beq	r4,zero,88e8 <tcp_abandon+0x78>
      tcp_segs_free(pcb->unsent);
    88e4:	0007f200 	call	7f20 <tcp_segs_free>
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
    88e8:	81001e17 	ldw	r4,120(r16)
    88ec:	20000126 	beq	r4,zero,88f4 <tcp_abandon+0x84>
      tcp_segs_free(pcb->ooseq);
    88f0:	0007f200 	call	7f20 <tcp_segs_free>
    }
#endif /* TCP_QUEUE_OOSEQ */
    if (reset) {
    88f4:	a800241e 	bne	r21,zero,8988 <tcp_abandon+0x118>
      LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    }
    memp_free(MEMP_TCP_PCB, pcb);
    88f8:	01000084 	movi	r4,2
    88fc:	800b883a 	mov	r5,r16
    8900:	000618c0 	call	618c <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
    8904:	88001626 	beq	r17,zero,8960 <tcp_abandon+0xf0>
    8908:	9809883a 	mov	r4,r19
    890c:	017ffd84 	movi	r5,-10
    8910:	8805883a 	mov	r2,r17
  }
}
    8914:	dfc00917 	ldw	ra,36(sp)
    8918:	dd800817 	ldw	r22,32(sp)
    891c:	dd400717 	ldw	r21,28(sp)
    8920:	dd000617 	ldw	r20,24(sp)
    8924:	dcc00517 	ldw	r19,20(sp)
    8928:	dc800417 	ldw	r18,16(sp)
    892c:	dc400317 	ldw	r17,12(sp)
    8930:	dc000217 	ldw	r16,8(sp)
    8934:	dec00a04 	addi	sp,sp,40
    if (reset) {
      LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    }
    memp_free(MEMP_TCP_PCB, pcb);
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
    8938:	1000683a 	jmp	r2
  tcp_err_fn errf;
#endif /* LWIP_CALLBACK_API */
  void *errf_arg;

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
    893c:	010000b4 	movhi	r4,2
    8940:	210d4b04 	addi	r4,r4,13612
    8944:	014000b4 	movhi	r5,2
    8948:	29556404 	addi	r5,r5,21904
    894c:	01805bc4 	movi	r6,367
    8950:	01c000b4 	movhi	r7,2
    8954:	39d4ab04 	addi	r7,r7,21164
    8958:	00104380 	call	10438 <printf>
    895c:	003fff06 	br	895c <tcp_abandon+0xec>
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    }
    memp_free(MEMP_TCP_PCB, pcb);
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  }
}
    8960:	dfc00917 	ldw	ra,36(sp)
    8964:	dd800817 	ldw	r22,32(sp)
    8968:	dd400717 	ldw	r21,28(sp)
    896c:	dd000617 	ldw	r20,24(sp)
    8970:	dcc00517 	ldw	r19,20(sp)
    8974:	dc800417 	ldw	r18,16(sp)
    8978:	dc400317 	ldw	r17,12(sp)
    897c:	dc000217 	ldw	r16,8(sp)
    8980:	dec00a04 	addi	sp,sp,40
    8984:	f800283a 	ret
      tcp_segs_free(pcb->ooseq);
    }
#endif /* TCP_QUEUE_OOSEQ */
    if (reset) {
      LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    8988:	80c0078b 	ldhu	r3,30(r16)
    898c:	8080080b 	ldhu	r2,32(r16)
    8990:	b009883a 	mov	r4,r22
    8994:	d8c00015 	stw	r3,0(sp)
    8998:	d8800115 	stw	r2,4(sp)
    899c:	a00b883a 	mov	r5,r20
    89a0:	800d883a 	mov	r6,r16
    89a4:	81c00104 	addi	r7,r16,4
    89a8:	000c99c0 	call	c99c <tcp_rst>
    89ac:	003fd206 	br	88f8 <tcp_abandon+0x88>
    pcb->state != LISTEN);
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
    89b0:	800b883a 	mov	r5,r16
    89b4:	d128c104 	addi	r4,gp,-23804
    89b8:	000872c0 	call	872c <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
    89bc:	01000084 	movi	r4,2
    89c0:	800b883a 	mov	r5,r16
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    }
    memp_free(MEMP_TCP_PCB, pcb);
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  }
}
    89c4:	dfc00917 	ldw	ra,36(sp)
    89c8:	dd800817 	ldw	r22,32(sp)
    89cc:	dd400717 	ldw	r21,28(sp)
    89d0:	dd000617 	ldw	r20,24(sp)
    89d4:	dcc00517 	ldw	r19,20(sp)
    89d8:	dc800417 	ldw	r18,16(sp)
    89dc:	dc400317 	ldw	r17,12(sp)
    89e0:	dc000217 	ldw	r16,8(sp)
    89e4:	dec00a04 	addi	sp,sp,40
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
    89e8:	000618c1 	jmpi	618c <memp_free>

000089ec <tcp_abort>:
 * @param pcb the tcp pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  tcp_abandon(pcb, 1);
    89ec:	01400044 	movi	r5,1
    89f0:	00088701 	jmpi	8870 <tcp_abandon>

000089f4 <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
    89f4:	defffd04 	addi	sp,sp,-12
    89f8:	dc400115 	stw	r17,4(sp)
    89fc:	2023883a 	mov	r17,r4
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    8a00:	01000084 	movi	r4,2
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
    8a04:	dc000015 	stw	r16,0(sp)
    8a08:	dfc00215 	stw	ra,8(sp)
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    8a0c:	00060a40 	call	60a4 <memp_malloc>
    8a10:	1021883a 	mov	r16,r2
  if (pcb == NULL) {
    8a14:	10002e26 	beq	r2,zero,8ad0 <tcp_alloc+0xdc>
      /* adjust err stats: timewait PCB was freed above */
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
    }
  }
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
    8a18:	8009883a 	mov	r4,r16
    8a1c:	000b883a 	mov	r5,zero
    8a20:	01802704 	movi	r6,156
    8a24:	00103300 	call	10330 <memset>
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
    8a28:	d0e8bd17 	ldw	r3,-23820(gp)
    8a2c:	d0a00717 	ldw	r2,-32740(gp)
    }
  }
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
    pcb->prio = prio;
    pcb->snd_buf = TCP_SND_BUF;
    8a30:	01100004 	movi	r4,16384
    8a34:	81001a8d 	sth	r4,106(r16)
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
    8a38:	1885883a 	add	r2,r3,r2
    8a3c:	d0a00715 	stw	r2,-32740(gp)
    pcb->sa = 0;
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
    pcb->rtime = -1;
    pcb->cwnd = 1;
    iss = tcp_next_iss();
    pcb->snd_wl2 = iss;
    8a40:	80801715 	stw	r2,92(r16)
    pcb->snd_nxt = iss;
    8a44:	80801515 	stw	r2,84(r16)
    pcb->lastack = iss;
    8a48:	80801315 	stw	r2,76(r16)
    pcb->snd_lbb = iss;   
    8a4c:	80801815 	stw	r2,96(r16)
    pcb->tmr = tcp_ticks;
    pcb->last_timer = tcp_timer_ctr;
    8a50:	d0a8bb43 	ldbu	r2,-23827(gp)
    pcb->snd_buf = TCP_SND_BUF;
    pcb->snd_queuelen = 0;
    pcb->rcv_wnd = TCP_WND;
    pcb->rcv_ann_wnd = TCP_WND;
    pcb->tos = 0;
    pcb->ttl = TCP_TTL;
    8a54:	013fffc4 	movi	r4,-1
    8a58:	81000285 	stb	r4,10(r16)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    8a5c:	01008604 	movi	r4,536
    8a60:	81000e8d 	sth	r4,58(r16)
    pcb->snd_wl2 = iss;
    pcb->snd_nxt = iss;
    pcb->lastack = iss;
    pcb->snd_lbb = iss;   
    pcb->tmr = tcp_ticks;
    pcb->last_timer = tcp_timer_ctr;
    8a64:	80800945 	stb	r2,37(r16)
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
    pcb->sa = 0;
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
    pcb->rtime = -1;
    8a68:	013fffc4 	movi	r4,-1
    pcb->last_timer = tcp_timer_ctr;

    pcb->polltmr = 0;

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
    8a6c:	00800074 	movhi	r2,1
    8a70:	10a3c704 	addi	r2,r2,-28900
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
    pcb->prio = prio;
    pcb->snd_buf = TCP_SND_BUF;
    pcb->snd_queuelen = 0;
    pcb->rcv_wnd = TCP_WND;
    8a74:	01820004 	movi	r6,2048
    pcb->tos = 0;
    pcb->ttl = TCP_TTL;
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
    8a78:	01400184 	movi	r5,6
    pcb->sa = 0;
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
    pcb->rtime = -1;
    8a7c:	81000e0d 	sth	r4,56(r16)
    pcb->last_timer = tcp_timer_ctr;

    pcb->polltmr = 0;

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
    8a80:	80802115 	stw	r2,132(r16)
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
    pcb->sa = 0;
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
    pcb->rtime = -1;
    pcb->cwnd = 1;
    8a84:	01000044 	movi	r4,1
#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
    8a88:	00801bb4 	movhi	r2,110
    8a8c:	10b74004 	addi	r2,r2,-8960
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
    }
  }
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
    pcb->prio = prio;
    8a90:	84400705 	stb	r17,28(r16)
    pcb->snd_buf = TCP_SND_BUF;
    pcb->snd_queuelen = 0;
    pcb->rcv_wnd = TCP_WND;
    8a94:	81800c0d 	sth	r6,48(r16)
    pcb->rcv_ann_wnd = TCP_WND;
    8a98:	81800c8d 	sth	r6,50(r16)
    pcb->tos = 0;
    pcb->ttl = TCP_TTL;
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
    8a9c:	8140120d 	sth	r5,72(r16)
    pcb->sa = 0;
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
    8aa0:	8140118d 	sth	r5,70(r16)
    pcb->rtime = -1;
    pcb->cwnd = 1;
    8aa4:	8100140d 	sth	r4,80(r16)
    iss = tcp_next_iss();
    pcb->snd_wl2 = iss;
    pcb->snd_nxt = iss;
    pcb->lastack = iss;
    pcb->snd_lbb = iss;   
    pcb->tmr = tcp_ticks;
    8aa8:	80c00a15 	stw	r3,40(r16)
    pcb->last_timer = tcp_timer_ctr;

    pcb->polltmr = 0;
    8aac:	800008c5 	stb	zero,35(r16)
#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
    8ab0:	80802515 	stw	r2,148(r16)
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
    8ab4:	80002685 	stb	zero,154(r16)
  }
  return pcb;
}
    8ab8:	8005883a 	mov	r2,r16
    8abc:	dfc00217 	ldw	ra,8(sp)
    8ac0:	dc400117 	ldw	r17,4(sp)
    8ac4:	dc000017 	ldw	r16,0(sp)
    8ac8:	dec00304 	addi	sp,sp,12
    8acc:	f800283a 	ret
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    8ad0:	d0a8c117 	ldw	r2,-23804(gp)
    8ad4:	10000d26 	beq	r2,zero,8b0c <tcp_alloc+0x118>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    8ad8:	d1a8bd17 	ldw	r6,-23820(gp)
    8adc:	11400a17 	ldw	r5,40(r2)
    8ae0:	1009883a 	mov	r4,r2
    8ae4:	314bc83a 	sub	r5,r6,r5
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    8ae8:	10800317 	ldw	r2,12(r2)
    8aec:	10000626 	beq	r2,zero,8b08 <tcp_alloc+0x114>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    8af0:	10c00a17 	ldw	r3,40(r2)
    8af4:	30c7c83a 	sub	r3,r6,r3
    8af8:	197ffb36 	bltu	r3,r5,8ae8 <tcp_alloc+0xf4>
    8afc:	180b883a 	mov	r5,r3
    8b00:	1009883a 	mov	r4,r2
    8b04:	003ff806 	br	8ae8 <tcp_alloc+0xf4>
    }
  }
  if (inactive != NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
    8b08:	00089ec0 	call	89ec <tcp_abort>
  if (pcb == NULL) {
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
    /* Try to allocate a tcp_pcb again. */
    pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    8b0c:	01000084 	movi	r4,2
    8b10:	00060a40 	call	60a4 <memp_malloc>
    8b14:	1021883a 	mov	r16,r2
    if (pcb == NULL) {
    8b18:	10000626 	beq	r2,zero,8b34 <tcp_alloc+0x140>
    8b1c:	008001f4 	movhi	r2,7
    8b20:	10944804 	addi	r2,r2,20768
    8b24:	10c0330b 	ldhu	r3,204(r2)
        MEMP_STATS_DEC(err, MEMP_TCP_PCB);
      }
    }
    if (pcb != NULL) {
      /* adjust err stats: timewait PCB was freed above */
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
    8b28:	18ffffc4 	addi	r3,r3,-1
    8b2c:	10c0330d 	sth	r3,204(r2)
    8b30:	003fb906 	br	8a18 <tcp_alloc+0x24>
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    8b34:	d0a8bc17 	ldw	r2,-23824(gp)
    8b38:	10001426 	beq	r2,zero,8b8c <tcp_alloc+0x198>
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    8b3c:	d2a8bd17 	ldw	r10,-23820(gp)

  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
    8b40:	0009883a 	mov	r4,zero


  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
    8b44:	0013883a 	mov	r9,zero
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
    8b48:	01c01fc4 	movi	r7,127
    8b4c:	8a003fcc 	andi	r8,r17,255
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
    8b50:	11400703 	ldbu	r5,28(r2)
    8b54:	39803fcc 	andi	r6,r7,255
    8b58:	28c03fcc 	andi	r3,r5,255
    8b5c:	40c00736 	bltu	r8,r3,8b7c <tcp_alloc+0x188>
    8b60:	30c00636 	bltu	r6,r3,8b7c <tcp_alloc+0x188>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    8b64:	10c00a17 	ldw	r3,40(r2)
    8b68:	50c7c83a 	sub	r3,r10,r3
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
    8b6c:	1a400336 	bltu	r3,r9,8b7c <tcp_alloc+0x188>
    8b70:	1009883a 	mov	r4,r2
    8b74:	280f883a 	mov	r7,r5
    8b78:	1813883a 	mov	r9,r3
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    8b7c:	10800317 	ldw	r2,12(r2)
    8b80:	103ff31e 	bne	r2,zero,8b50 <tcp_alloc+0x15c>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
    8b84:	20000126 	beq	r4,zero,8b8c <tcp_alloc+0x198>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
    8b88:	00089ec0 	call	89ec <tcp_abort>
    if (pcb == NULL) {
      /* Try killing active connections with lower priority than the new one. */
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing connection with prio lower than %d\n", prio));
      tcp_kill_prio(prio);
      /* Try to allocate a tcp_pcb again. */
      pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    8b8c:	01000084 	movi	r4,2
    8b90:	00060a40 	call	60a4 <memp_malloc>
    8b94:	1021883a 	mov	r16,r2
      if (pcb != NULL) {
    8b98:	103fc726 	beq	r2,zero,8ab8 <tcp_alloc+0xc4>
        /* adjust err stats: memp_malloc failed twice before */
        MEMP_STATS_DEC(err, MEMP_TCP_PCB);
    8b9c:	008001f4 	movhi	r2,7
    8ba0:	10944804 	addi	r2,r2,20768
    8ba4:	10c0330b 	ldhu	r3,204(r2)
    8ba8:	18ffffc4 	addi	r3,r3,-1
    8bac:	003fde06 	br	8b28 <tcp_alloc+0x134>

00008bb0 <tcp_new>:
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
  return tcp_alloc(TCP_PRIO_NORMAL);
    8bb0:	01001004 	movi	r4,64
    8bb4:	00089f41 	jmpi	89f4 <tcp_alloc>

00008bb8 <tcp_close_shutdown>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
static err_t
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
    8bb8:	defffc04 	addi	sp,sp,-16
    8bbc:	dc000215 	stw	r16,8(sp)
    8bc0:	dfc00315 	stw	ra,12(sp)
    8bc4:	2021883a 	mov	r16,r4
  err_t err;

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
    8bc8:	20800617 	ldw	r2,24(r4)
    8bcc:	28001626 	beq	r5,zero,8c28 <tcp_close_shutdown+0x70>
    8bd0:	00c00104 	movi	r3,4
    8bd4:	10c00226 	beq	r2,r3,8be0 <tcp_close_shutdown+0x28>
    8bd8:	00c001c4 	movi	r3,7
    8bdc:	10c0121e 	bne	r2,r3,8c28 <tcp_close_shutdown+0x70>
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
    8be0:	80c01f17 	ldw	r3,124(r16)
    8be4:	18000d26 	beq	r3,zero,8c1c <tcp_close_shutdown+0x64>
      /* Not all data received by application, send RST to tell the remote
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
    8be8:	80800883 	ldbu	r2,34(r16)
    8bec:	1080040c 	andi	r2,r2,16
    8bf0:	10803fcc 	andi	r2,r2,255
    8bf4:	1000541e 	bne	r2,zero,8d48 <tcp_close_shutdown+0x190>
    8bf8:	010000b4 	movhi	r4,2
    8bfc:	210d4b04 	addi	r4,r4,13612
    8c00:	014000b4 	movhi	r5,2
    8c04:	29557104 	addi	r5,r5,21956
    8c08:	01802c84 	movi	r6,178
    8c0c:	01c000b4 	movhi	r7,2
    8c10:	39d4ab04 	addi	r7,r7,21164
    8c14:	00104380 	call	10438 <printf>
    8c18:	003fff06 	br	8c18 <tcp_close_shutdown+0x60>
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
  err_t err;

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
    8c1c:	81000c0b 	ldhu	r4,48(r16)
    8c20:	00c20004 	movi	r3,2048
    8c24:	20fff01e 	bne	r4,r3,8be8 <tcp_close_shutdown+0x30>
      }
      return ERR_OK;
    }
  }

  switch (pcb->state) {
    8c28:	00c001c4 	movi	r3,7
    8c2c:	18801936 	bltu	r3,r2,8c94 <tcp_close_shutdown+0xdc>
    8c30:	1085883a 	add	r2,r2,r2
    8c34:	1085883a 	add	r2,r2,r2
    8c38:	00c00074 	movhi	r3,1
    8c3c:	18e31304 	addi	r3,r3,-29620
    8c40:	10c5883a 	add	r2,r2,r3
    8c44:	10800017 	ldw	r2,0(r2)
    8c48:	1000683a 	jmp	r2
    8c4c:	00008d0c 	andi	zero,zero,564
    8c50:	00008cf0 	cmpltui	zero,zero,563
    8c54:	00008ccc 	andi	zero,zero,563
    8c58:	00008c6c 	andhi	zero,zero,561
    8c5c:	00008c6c 	andhi	zero,zero,561
    8c60:	00008c94 	movui	zero,562
    8c64:	00008c94 	movui	zero,562
    8c68:	00008ca8 	cmpgeui	zero,zero,562
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
    }
    break;
  case ESTABLISHED:
    err = tcp_send_fin(pcb);
    8c6c:	8009883a 	mov	r4,r16
    8c70:	000c2580 	call	c258 <tcp_send_fin>
    if (err == ERR_OK) {
    8c74:	10c03fcc 	andi	r3,r2,255
    8c78:	18c0201c 	xori	r3,r3,128
    8c7c:	18ffe004 	addi	r3,r3,-128
    8c80:	1800051e 	bne	r3,zero,8c98 <tcp_close_shutdown+0xe0>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
    8c84:	00800144 	movi	r2,5
    8c88:	80800615 	stw	r2,24(r16)
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent and acked before close returns.
       This can only be valid for sequential APIs, not for the raw API. */
    tcp_output(pcb);
    8c8c:	8009883a 	mov	r4,r16
    8c90:	000c38c0 	call	c38c <tcp_output>
    8c94:	0005883a 	mov	r2,zero
  }
  return err;
}
    8c98:	dfc00317 	ldw	ra,12(sp)
    8c9c:	dc000217 	ldw	r16,8(sp)
    8ca0:	dec00404 	addi	sp,sp,16
    8ca4:	f800283a 	ret
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
    }
    break;
  case CLOSE_WAIT:
    err = tcp_send_fin(pcb);
    8ca8:	8009883a 	mov	r4,r16
    8cac:	000c2580 	call	c258 <tcp_send_fin>
    if (err == ERR_OK) {
    8cb0:	10c03fcc 	andi	r3,r2,255
    8cb4:	18c0201c 	xori	r3,r3,128
    8cb8:	18ffe004 	addi	r3,r3,-128
    8cbc:	183ff61e 	bne	r3,zero,8c98 <tcp_close_shutdown+0xe0>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
    8cc0:	00800244 	movi	r2,9
    8cc4:	80800615 	stw	r2,24(r16)
    8cc8:	003ff006 	br	8c8c <tcp_close_shutdown+0xd4>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    pcb = NULL;
    break;
  case SYN_SENT:
    err = ERR_OK;
    TCP_PCB_REMOVE_ACTIVE(pcb);
    8ccc:	800b883a 	mov	r5,r16
    8cd0:	d128bc04 	addi	r4,gp,-23824
    8cd4:	000872c0 	call	872c <tcp_pcb_remove>
    8cd8:	00800044 	movi	r2,1
    memp_free(MEMP_TCP_PCB, pcb);
    8cdc:	01000084 	movi	r4,2
    8ce0:	800b883a 	mov	r5,r16
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    pcb = NULL;
    break;
  case SYN_SENT:
    err = ERR_OK;
    TCP_PCB_REMOVE_ACTIVE(pcb);
    8ce4:	d0a8bb85 	stb	r2,-23826(gp)
    memp_free(MEMP_TCP_PCB, pcb);
    8ce8:	000618c0 	call	618c <memp_free>
    pcb = NULL;
    snmp_inc_tcpattemptfails();
    break;
    8cec:	003fe906 	br	8c94 <tcp_close_shutdown+0xdc>
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    break;
  case LISTEN:
    err = ERR_OK;
    tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
    8cf0:	800b883a 	mov	r5,r16
    8cf4:	d128be04 	addi	r4,gp,-23816
    8cf8:	000872c0 	call	872c <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    8cfc:	010000c4 	movi	r4,3
    8d00:	800b883a 	mov	r5,r16
    8d04:	000618c0 	call	618c <memp_free>
    pcb = NULL;
    break;
    8d08:	003fe206 	br	8c94 <tcp_close_shutdown+0xdc>
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    if (pcb->local_port != 0) {
    8d0c:	8080078b 	ldhu	r2,30(r16)
    8d10:	10003526 	beq	r2,zero,8de8 <tcp_close_shutdown+0x230>
      TCP_RMV(&tcp_bound_pcbs, pcb);
    8d14:	d0a8c017 	ldw	r2,-23808(gp)
    8d18:	14003026 	beq	r2,r16,8ddc <tcp_close_shutdown+0x224>
    8d1c:	d0a8bf15 	stw	r2,-23812(gp)
    8d20:	10003026 	beq	r2,zero,8de4 <tcp_close_shutdown+0x22c>
    8d24:	10c00317 	ldw	r3,12(r2)
    8d28:	1c00031e 	bne	r3,r16,8d38 <tcp_close_shutdown+0x180>
    8d2c:	00004506 	br	8e44 <tcp_close_shutdown+0x28c>
    8d30:	10c00317 	ldw	r3,12(r2)
    8d34:	1c004226 	beq	r3,r16,8e40 <tcp_close_shutdown+0x288>
    8d38:	1805883a 	mov	r2,r3
    8d3c:	183ffc1e 	bne	r3,zero,8d30 <tcp_close_shutdown+0x178>
    8d40:	d028bf15 	stw	zero,-23812(gp)
    8d44:	00002706 	br	8de4 <tcp_close_shutdown+0x22c>
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);

      /* don't call tcp_abort here: we must not deallocate the pcb since
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
    8d48:	8080080b 	ldhu	r2,32(r16)
    8d4c:	80c0078b 	ldhu	r3,30(r16)
    8d50:	81001517 	ldw	r4,84(r16)
    8d54:	81400b17 	ldw	r5,44(r16)
    8d58:	800d883a 	mov	r6,r16
    8d5c:	d8800115 	stw	r2,4(sp)
    8d60:	81c00104 	addi	r7,r16,4
    8d64:	d8c00015 	stw	r3,0(sp)
    8d68:	000c99c0 	call	c99c <tcp_rst>
        pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
    8d6c:	8009883a 	mov	r4,r16
    8d70:	00080e00 	call	80e0 <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
    8d74:	d0a8bc17 	ldw	r2,-23824(gp)
    8d78:	14002e26 	beq	r2,r16,8e34 <tcp_close_shutdown+0x27c>
    8d7c:	d0a8bf15 	stw	r2,-23812(gp)
    8d80:	10000826 	beq	r2,zero,8da4 <tcp_close_shutdown+0x1ec>
    8d84:	10c00317 	ldw	r3,12(r2)
    8d88:	1c00031e 	bne	r3,r16,8d98 <tcp_close_shutdown+0x1e0>
    8d8c:	00002606 	br	8e28 <tcp_close_shutdown+0x270>
    8d90:	10c00317 	ldw	r3,12(r2)
    8d94:	1c002326 	beq	r3,r16,8e24 <tcp_close_shutdown+0x26c>
    8d98:	1805883a 	mov	r2,r3
    8d9c:	183ffc1e 	bne	r3,zero,8d90 <tcp_close_shutdown+0x1d8>
    8da0:	d028bf15 	stw	zero,-23812(gp)
      if (pcb->state == ESTABLISHED) {
    8da4:	80c00617 	ldw	r3,24(r16)
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
        pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
    8da8:	00800044 	movi	r2,1
    8dac:	d0a8bb85 	stb	r2,-23826(gp)
    8db0:	80000315 	stw	zero,12(r16)
      if (pcb->state == ESTABLISHED) {
    8db4:	00800104 	movi	r2,4
    8db8:	18800f26 	beq	r3,r2,8df8 <tcp_close_shutdown+0x240>
        /* move to TIME_WAIT since we close actively */
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        /* CLOSE_WAIT: deallocate the pcb since we already sent a RST for it */
        memp_free(MEMP_TCP_PCB, pcb);
    8dbc:	01000084 	movi	r4,2
    8dc0:	800b883a 	mov	r5,r16
    8dc4:	000618c0 	call	618c <memp_free>
      }
      return ERR_OK;
    8dc8:	0005883a 	mov	r2,zero
       If SOF_LINGER is set, the data should be sent and acked before close returns.
       This can only be valid for sequential APIs, not for the raw API. */
    tcp_output(pcb);
  }
  return err;
}
    8dcc:	dfc00317 	ldw	ra,12(sp)
    8dd0:	dc000217 	ldw	r16,8(sp)
    8dd4:	dec00404 	addi	sp,sp,16
    8dd8:	f800283a 	ret
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    if (pcb->local_port != 0) {
      TCP_RMV(&tcp_bound_pcbs, pcb);
    8ddc:	80800317 	ldw	r2,12(r16)
    8de0:	d0a8c015 	stw	r2,-23808(gp)
    8de4:	80000315 	stw	zero,12(r16)
    }
    memp_free(MEMP_TCP_PCB, pcb);
    8de8:	01000084 	movi	r4,2
    8dec:	800b883a 	mov	r5,r16
    8df0:	000618c0 	call	618c <memp_free>
    pcb = NULL;
    break;
    8df4:	003fa706 	br	8c94 <tcp_close_shutdown+0xdc>

      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      if (pcb->state == ESTABLISHED) {
        /* move to TIME_WAIT since we close actively */
        pcb->state = TIME_WAIT;
    8df8:	00800284 	movi	r2,10
    8dfc:	80800615 	stw	r2,24(r16)
        TCP_REG(&tcp_tw_pcbs, pcb);
    8e00:	d0a8c117 	ldw	r2,-23804(gp)
    8e04:	d428c115 	stw	r16,-23804(gp)
    8e08:	80800315 	stw	r2,12(r16)
    8e0c:	000cfa80 	call	cfa8 <tcp_timer_needed>
      } else {
        /* CLOSE_WAIT: deallocate the pcb since we already sent a RST for it */
        memp_free(MEMP_TCP_PCB, pcb);
      }
      return ERR_OK;
    8e10:	0005883a 	mov	r2,zero
       If SOF_LINGER is set, the data should be sent and acked before close returns.
       This can only be valid for sequential APIs, not for the raw API. */
    tcp_output(pcb);
  }
  return err;
}
    8e14:	dfc00317 	ldw	ra,12(sp)
    8e18:	dc000217 	ldw	r16,8(sp)
    8e1c:	dec00404 	addi	sp,sp,16
    8e20:	f800283a 	ret
    8e24:	d0a8bf15 	stw	r2,-23812(gp)
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
        pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
    8e28:	80c00317 	ldw	r3,12(r16)
    8e2c:	10c00315 	stw	r3,12(r2)
    8e30:	003fdc06 	br	8da4 <tcp_close_shutdown+0x1ec>
    8e34:	80800317 	ldw	r2,12(r16)
    8e38:	d0a8bc15 	stw	r2,-23824(gp)
    8e3c:	003fd906 	br	8da4 <tcp_close_shutdown+0x1ec>
    8e40:	d0a8bf15 	stw	r2,-23812(gp)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    if (pcb->local_port != 0) {
      TCP_RMV(&tcp_bound_pcbs, pcb);
    8e44:	80c00317 	ldw	r3,12(r16)
    8e48:	10c00315 	stw	r3,12(r2)
    8e4c:	003fe506 	br	8de4 <tcp_close_shutdown+0x22c>

00008e50 <tcp_shutdown>:
 *         another err_t on error.
 */
err_t
tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx)
{
  if (pcb->state == LISTEN) {
    8e50:	20800617 	ldw	r2,24(r4)
 * @return ERR_OK if shutdown succeeded (or the PCB has already been shut down)
 *         another err_t on error.
 */
err_t
tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx)
{
    8e54:	defffe04 	addi	sp,sp,-8
    8e58:	dc000015 	stw	r16,0(sp)
    8e5c:	dfc00115 	stw	ra,4(sp)
  if (pcb->state == LISTEN) {
    8e60:	00c00044 	movi	r3,1
 * @return ERR_OK if shutdown succeeded (or the PCB has already been shut down)
 *         another err_t on error.
 */
err_t
tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx)
{
    8e64:	2021883a 	mov	r16,r4
  if (pcb->state == LISTEN) {
    8e68:	10c01126 	beq	r2,r3,8eb0 <tcp_shutdown+0x60>
    return ERR_CONN;
  }
  if (shut_rx) {
    8e6c:	28000d26 	beq	r5,zero,8ea4 <tcp_shutdown+0x54>
    /* shut down the receive side: set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
    8e70:	20800883 	ldbu	r2,34(r4)
    8e74:	10800414 	ori	r2,r2,16
    8e78:	20800885 	stb	r2,34(r4)
    if (shut_tx) {
    8e7c:	30001a1e 	bne	r6,zero,8ee8 <tcp_shutdown+0x98>
      /* shutting down the tx AND rx side is the same as closing for the raw API */
      return tcp_close_shutdown(pcb, 1);
    }
    /* ... and free buffered data */
    if (pcb->refused_data != NULL) {
    8e80:	21001f17 	ldw	r4,124(r4)
    8e84:	20000226 	beq	r4,zero,8e90 <tcp_shutdown+0x40>
      pbuf_free(pcb->refused_data);
    8e88:	00067d80 	call	67d8 <pbuf_free>
      pcb->refused_data = NULL;
    8e8c:	80001f15 	stw	zero,124(r16)
      /* Not (yet?) connected, cannot shutdown the TX side as that would bring us
        into CLOSED state, where the PCB is deallocated. */
      return ERR_CONN;
    }
  }
  return ERR_OK;
    8e90:	0005883a 	mov	r2,zero
}
    8e94:	dfc00117 	ldw	ra,4(sp)
    8e98:	dc000017 	ldw	r16,0(sp)
    8e9c:	dec00204 	addi	sp,sp,8
    8ea0:	f800283a 	ret
    if (pcb->refused_data != NULL) {
      pbuf_free(pcb->refused_data);
      pcb->refused_data = NULL;
    }
  }
  if (shut_tx) {
    8ea4:	303ffa26 	beq	r6,zero,8e90 <tcp_shutdown+0x40>
    /* This can't happen twice since if it succeeds, the pcb's state is changed.
       Only close in these states as the others directly deallocate the PCB */
    switch (pcb->state) {
    8ea8:	00c000c4 	movi	r3,3
    8eac:	10c0022e 	bgeu	r2,r3,8eb8 <tcp_shutdown+0x68>
    case CLOSE_WAIT:
      return tcp_close_shutdown(pcb, shut_rx);
    default:
      /* Not (yet?) connected, cannot shutdown the TX side as that would bring us
        into CLOSED state, where the PCB is deallocated. */
      return ERR_CONN;
    8eb0:	00bffcc4 	movi	r2,-13
    8eb4:	003ff706 	br	8e94 <tcp_shutdown+0x44>
    }
  }
  if (shut_tx) {
    /* This can't happen twice since if it succeeds, the pcb's state is changed.
       Only close in these states as the others directly deallocate the PCB */
    switch (pcb->state) {
    8eb8:	00c00104 	movi	r3,4
    8ebc:	18800636 	bltu	r3,r2,8ed8 <tcp_shutdown+0x88>
    case SYN_RCVD:
    case ESTABLISHED:
    case CLOSE_WAIT:
      return tcp_close_shutdown(pcb, shut_rx);
    8ec0:	8009883a 	mov	r4,r16
    8ec4:	000b883a 	mov	r5,zero
        into CLOSED state, where the PCB is deallocated. */
      return ERR_CONN;
    }
  }
  return ERR_OK;
}
    8ec8:	dfc00117 	ldw	ra,4(sp)
    8ecc:	dc000017 	ldw	r16,0(sp)
    8ed0:	dec00204 	addi	sp,sp,8
       Only close in these states as the others directly deallocate the PCB */
    switch (pcb->state) {
    case SYN_RCVD:
    case ESTABLISHED:
    case CLOSE_WAIT:
      return tcp_close_shutdown(pcb, shut_rx);
    8ed4:	0008bb81 	jmpi	8bb8 <tcp_close_shutdown>
    }
  }
  if (shut_tx) {
    /* This can't happen twice since if it succeeds, the pcb's state is changed.
       Only close in these states as the others directly deallocate the PCB */
    switch (pcb->state) {
    8ed8:	00c001c4 	movi	r3,7
    8edc:	10fff826 	beq	r2,r3,8ec0 <tcp_shutdown+0x70>
    case CLOSE_WAIT:
      return tcp_close_shutdown(pcb, shut_rx);
    default:
      /* Not (yet?) connected, cannot shutdown the TX side as that would bring us
        into CLOSED state, where the PCB is deallocated. */
      return ERR_CONN;
    8ee0:	00bffcc4 	movi	r2,-13
    8ee4:	003feb06 	br	8e94 <tcp_shutdown+0x44>
  if (shut_rx) {
    /* shut down the receive side: set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
    if (shut_tx) {
      /* shutting down the tx AND rx side is the same as closing for the raw API */
      return tcp_close_shutdown(pcb, 1);
    8ee8:	180b883a 	mov	r5,r3
        into CLOSED state, where the PCB is deallocated. */
      return ERR_CONN;
    }
  }
  return ERR_OK;
}
    8eec:	dfc00117 	ldw	ra,4(sp)
    8ef0:	dc000017 	ldw	r16,0(sp)
    8ef4:	dec00204 	addi	sp,sp,8
       Only close in these states as the others directly deallocate the PCB */
    switch (pcb->state) {
    case SYN_RCVD:
    case ESTABLISHED:
    case CLOSE_WAIT:
      return tcp_close_shutdown(pcb, shut_rx);
    8ef8:	0008bb81 	jmpi	8bb8 <tcp_close_shutdown>

00008efc <tcp_close>:
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  if (pcb->state != LISTEN) {
    8efc:	20c00617 	ldw	r3,24(r4)
    8f00:	00800044 	movi	r2,1
    8f04:	18800326 	beq	r3,r2,8f14 <tcp_close+0x18>
    /* Set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
    8f08:	20800883 	ldbu	r2,34(r4)
    8f0c:	10800414 	ori	r2,r2,16
    8f10:	20800885 	stb	r2,34(r4)
  }
  /* ... and close */
  return tcp_close_shutdown(pcb, 1);
    8f14:	01400044 	movi	r5,1
    8f18:	0008bb81 	jmpi	8bb8 <tcp_close_shutdown>

00008f1c <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
    8f1c:	defffe04 	addi	sp,sp,-8
    8f20:	dfc00115 	stw	ra,4(sp)
    8f24:	2809883a 	mov	r4,r5
  LWIP_UNUSED_ARG(arg);
  if (p != NULL) {
    8f28:	30000a26 	beq	r6,zero,8f54 <tcp_recv_null+0x38>
    tcp_recved(pcb, p->tot_len);
    8f2c:	3140020b 	ldhu	r5,8(r6)
    8f30:	d9800015 	stw	r6,0(sp)
    8f34:	0007df80 	call	7df8 <tcp_recved>
    pbuf_free(p);
    8f38:	d9800017 	ldw	r6,0(sp)
    8f3c:	3009883a 	mov	r4,r6
    8f40:	00067d80 	call	67d8 <pbuf_free>
  } else if (err == ERR_OK) {
    return tcp_close(pcb);
  }
  return ERR_OK;
}
    8f44:	0005883a 	mov	r2,zero
    8f48:	dfc00117 	ldw	ra,4(sp)
    8f4c:	dec00204 	addi	sp,sp,8
    8f50:	f800283a 	ret
{
  LWIP_UNUSED_ARG(arg);
  if (p != NULL) {
    tcp_recved(pcb, p->tot_len);
    pbuf_free(p);
  } else if (err == ERR_OK) {
    8f54:	39c03fcc 	andi	r7,r7,255
    8f58:	39c0201c 	xori	r7,r7,128
    8f5c:	39ffe004 	addi	r7,r7,-128
    8f60:	383ff81e 	bne	r7,zero,8f44 <tcp_recv_null+0x28>
    return tcp_close(pcb);
  }
  return ERR_OK;
}
    8f64:	dfc00117 	ldw	ra,4(sp)
    8f68:	dec00204 	addi	sp,sp,8
  LWIP_UNUSED_ARG(arg);
  if (p != NULL) {
    tcp_recved(pcb, p->tot_len);
    pbuf_free(p);
  } else if (err == ERR_OK) {
    return tcp_close(pcb);
    8f6c:	0008efc1 	jmpi	8efc <tcp_close>

00008f70 <tcp_process_refused_data>:
}

/** Pass pcb->refused_data to the recv callback */
err_t
tcp_process_refused_data(struct tcp_pcb *pcb)
{
    8f70:	defffc04 	addi	sp,sp,-16
    8f74:	dc400115 	stw	r17,4(sp)
  err_t err;
  u8_t refused_flags = pcb->refused_data->flags;
    8f78:	24401f17 	ldw	r17,124(r4)
     closes the pcb */
  struct pbuf *refused_data = pcb->refused_data;
  pcb->refused_data = NULL;
  /* Notify again application with data previously received. */
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
  TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
    8f7c:	20802117 	ldw	r2,132(r4)
}

/** Pass pcb->refused_data to the recv callback */
err_t
tcp_process_refused_data(struct tcp_pcb *pcb)
{
    8f80:	dc000015 	stw	r16,0(sp)
    8f84:	dfc00315 	stw	ra,12(sp)
    8f88:	dc800215 	stw	r18,8(sp)
  err_t err;
  u8_t refused_flags = pcb->refused_data->flags;
    8f8c:	8c800343 	ldbu	r18,13(r17)
  /* set pcb->refused_data to NULL in case the callback frees it and then
     closes the pcb */
  struct pbuf *refused_data = pcb->refused_data;
  pcb->refused_data = NULL;
    8f90:	20001f15 	stw	zero,124(r4)
}

/** Pass pcb->refused_data to the recv callback */
err_t
tcp_process_refused_data(struct tcp_pcb *pcb)
{
    8f94:	2021883a 	mov	r16,r4
     closes the pcb */
  struct pbuf *refused_data = pcb->refused_data;
  pcb->refused_data = NULL;
  /* Notify again application with data previously received. */
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
  TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
    8f98:	10002f26 	beq	r2,zero,9058 <tcp_process_refused_data+0xe8>
    8f9c:	21000417 	ldw	r4,16(r4)
    8fa0:	800b883a 	mov	r5,r16
    8fa4:	880d883a 	mov	r6,r17
    8fa8:	000f883a 	mov	r7,zero
    8fac:	103ee83a 	callr	r2
  if (err == ERR_OK) {
    8fb0:	10803fcc 	andi	r2,r2,255
    8fb4:	1080201c 	xori	r2,r2,128
    8fb8:	10bfe004 	addi	r2,r2,-128
    8fbc:	10001c1e 	bne	r2,zero,9030 <tcp_process_refused_data+0xc0>
    /* did refused_data include a FIN? */
    if (refused_flags & PBUF_FLAG_TCP_FIN) {
    8fc0:	9480080c 	andi	r18,r18,32
    8fc4:	94803fcc 	andi	r18,r18,255
    8fc8:	90001226 	beq	r18,zero,9014 <tcp_process_refused_data+0xa4>
      /* correct rcv_wnd as the application won't call tcp_recved()
         for the FIN's seqno */
      if (pcb->rcv_wnd != TCP_WND) {
    8fcc:	80800c0b 	ldhu	r2,48(r16)
    8fd0:	00c20004 	movi	r3,2048
    8fd4:	113fffcc 	andi	r4,r2,65535
    8fd8:	20c00226 	beq	r4,r3,8fe4 <tcp_process_refused_data+0x74>
        pcb->rcv_wnd++;
    8fdc:	10800044 	addi	r2,r2,1
    8fe0:	80800c0d 	sth	r2,48(r16)
      }
      TCP_EVENT_CLOSED(pcb, err);
    8fe4:	80802117 	ldw	r2,132(r16)
    8fe8:	10000a26 	beq	r2,zero,9014 <tcp_process_refused_data+0xa4>
    8fec:	81000417 	ldw	r4,16(r16)
    8ff0:	800b883a 	mov	r5,r16
    8ff4:	000d883a 	mov	r6,zero
    8ff8:	000f883a 	mov	r7,zero
    8ffc:	103ee83a 	callr	r2
      if (err == ERR_ABRT) {
    9000:	10803fcc 	andi	r2,r2,255
    9004:	1080201c 	xori	r2,r2,128
    9008:	10bfe004 	addi	r2,r2,-128
    900c:	00fffd84 	movi	r3,-10
    9010:	10c01726 	beq	r2,r3,9070 <tcp_process_refused_data+0x100>
    return ERR_ABRT;
  } else {
    /* data is still refused, pbuf is still valid (go on for ACK-only packets) */
    pcb->refused_data = refused_data;
  }
  return ERR_OK;
    9014:	0005883a 	mov	r2,zero
}
    9018:	dfc00317 	ldw	ra,12(sp)
    901c:	dc800217 	ldw	r18,8(sp)
    9020:	dc400117 	ldw	r17,4(sp)
    9024:	dc000017 	ldw	r16,0(sp)
    9028:	dec00404 	addi	sp,sp,16
    902c:	f800283a 	ret
      TCP_EVENT_CLOSED(pcb, err);
      if (err == ERR_ABRT) {
        return ERR_ABRT;
      }
    }
  } else if (err == ERR_ABRT) {
    9030:	00fffd84 	movi	r3,-10
    9034:	10c00e26 	beq	r2,r3,9070 <tcp_process_refused_data+0x100>
       segment contains data). */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
    return ERR_ABRT;
  } else {
    /* data is still refused, pbuf is still valid (go on for ACK-only packets) */
    pcb->refused_data = refused_data;
    9038:	84401f15 	stw	r17,124(r16)
  }
  return ERR_OK;
    903c:	0005883a 	mov	r2,zero
}
    9040:	dfc00317 	ldw	ra,12(sp)
    9044:	dc800217 	ldw	r18,8(sp)
    9048:	dc400117 	ldw	r17,4(sp)
    904c:	dc000017 	ldw	r16,0(sp)
    9050:	dec00404 	addi	sp,sp,16
    9054:	f800283a 	ret
     closes the pcb */
  struct pbuf *refused_data = pcb->refused_data;
  pcb->refused_data = NULL;
  /* Notify again application with data previously received. */
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
  TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
    9058:	0009883a 	mov	r4,zero
    905c:	800b883a 	mov	r5,r16
    9060:	880d883a 	mov	r6,r17
    9064:	000f883a 	mov	r7,zero
    9068:	0008f1c0 	call	8f1c <tcp_recv_null>
    906c:	003fd006 	br	8fb0 <tcp_process_refused_data+0x40>
      if (pcb->rcv_wnd != TCP_WND) {
        pcb->rcv_wnd++;
      }
      TCP_EVENT_CLOSED(pcb, err);
      if (err == ERR_ABRT) {
        return ERR_ABRT;
    9070:	00bffd84 	movi	r2,-10
    9074:	003ff206 	br	9040 <tcp_process_refused_data+0xd0>

00009078 <tcp_fasttmr>:
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  ++tcp_timer_ctr;
    9078:	d0a8bb43 	ldbu	r2,-23827(gp)
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
    907c:	defffd04 	addi	sp,sp,-12
    9080:	dc000015 	stw	r16,0(sp)
  struct tcp_pcb *pcb;

  ++tcp_timer_ctr;

tcp_fasttmr_start:
  pcb = tcp_active_pcbs;
    9084:	d428bc17 	ldw	r16,-23824(gp)
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  ++tcp_timer_ctr;
    9088:	10800044 	addi	r2,r2,1
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
    908c:	dc400115 	stw	r17,4(sp)
    9090:	dfc00215 	stw	ra,8(sp)
      /* send delayed ACKs */
      if (pcb->flags & TF_ACK_DELAY) {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
        tcp_ack_now(pcb);
        tcp_output(pcb);
        pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    9094:	047fff04 	movi	r17,-4
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  ++tcp_timer_ctr;
    9098:	d0a8bb45 	stb	r2,-23827(gp)

tcp_fasttmr_start:
  pcb = tcp_active_pcbs;

  while(pcb != NULL) {
    909c:	80001326 	beq	r16,zero,90ec <tcp_fasttmr+0x74>
    if (pcb->last_timer != tcp_timer_ctr) {
    90a0:	d0a8bb43 	ldbu	r2,-23827(gp)
    90a4:	81000943 	ldbu	r4,37(r16)
    90a8:	10c03fcc 	andi	r3,r2,255
    90ac:	20c0011e 	bne	r4,r3,90b4 <tcp_fasttmr+0x3c>
    90b0:	003fff06 	br	90b0 <tcp_fasttmr+0x38>
      struct tcp_pcb *next;
      pcb->last_timer = tcp_timer_ctr;
      /* send delayed ACKs */
      if (pcb->flags & TF_ACK_DELAY) {
    90b4:	80c00883 	ldbu	r3,34(r16)
  pcb = tcp_active_pcbs;

  while(pcb != NULL) {
    if (pcb->last_timer != tcp_timer_ctr) {
      struct tcp_pcb *next;
      pcb->last_timer = tcp_timer_ctr;
    90b8:	80800945 	stb	r2,37(r16)
      /* send delayed ACKs */
      if (pcb->flags & TF_ACK_DELAY) {
    90bc:	1880004c 	andi	r2,r3,1
    90c0:	10000f1e 	bne	r2,zero,9100 <tcp_fasttmr+0x88>
      }

      next = pcb->next;

      /* If there is data which was previously "refused" by upper layer */
      if (pcb->refused_data != NULL) {
    90c4:	80801f17 	ldw	r2,124(r16)
        tcp_active_pcbs_changed = 0;
        tcp_process_refused_data(pcb);
    90c8:	8009883a 	mov	r4,r16
        tcp_ack_now(pcb);
        tcp_output(pcb);
        pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
      }

      next = pcb->next;
    90cc:	84000317 	ldw	r16,12(r16)

      /* If there is data which was previously "refused" by upper layer */
      if (pcb->refused_data != NULL) {
    90d0:	103ff226 	beq	r2,zero,909c <tcp_fasttmr+0x24>
        tcp_active_pcbs_changed = 0;
    90d4:	d028bb85 	stb	zero,-23826(gp)
        tcp_process_refused_data(pcb);
    90d8:	0008f700 	call	8f70 <tcp_process_refused_data>
        if (tcp_active_pcbs_changed) {
    90dc:	d0a8bb83 	ldbu	r2,-23826(gp)
    90e0:	103fee26 	beq	r2,zero,909c <tcp_fasttmr+0x24>
  struct tcp_pcb *pcb;

  ++tcp_timer_ctr;

tcp_fasttmr_start:
  pcb = tcp_active_pcbs;
    90e4:	d428bc17 	ldw	r16,-23824(gp)
    90e8:	003fec06 	br	909c <tcp_fasttmr+0x24>
        }
      }
      pcb = next;
    }
  }
}
    90ec:	dfc00217 	ldw	ra,8(sp)
    90f0:	dc400117 	ldw	r17,4(sp)
    90f4:	dc000017 	ldw	r16,0(sp)
    90f8:	dec00304 	addi	sp,sp,12
    90fc:	f800283a 	ret
      struct tcp_pcb *next;
      pcb->last_timer = tcp_timer_ctr;
      /* send delayed ACKs */
      if (pcb->flags & TF_ACK_DELAY) {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
        tcp_ack_now(pcb);
    9100:	18c00094 	ori	r3,r3,2
        tcp_output(pcb);
    9104:	8009883a 	mov	r4,r16
      struct tcp_pcb *next;
      pcb->last_timer = tcp_timer_ctr;
      /* send delayed ACKs */
      if (pcb->flags & TF_ACK_DELAY) {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
        tcp_ack_now(pcb);
    9108:	80c00885 	stb	r3,34(r16)
        tcp_output(pcb);
    910c:	000c38c0 	call	c38c <tcp_output>
        pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    9110:	80800883 	ldbu	r2,34(r16)
    9114:	1444703a 	and	r2,r2,r17
    9118:	80800885 	stb	r2,34(r16)
    911c:	003fe906 	br	90c4 <tcp_fasttmr+0x4c>

00009120 <tcp_tmr>:
/**
 * Called periodically to dispatch TCP timers.
 */
void
tcp_tmr(void)
{
    9120:	deffff04 	addi	sp,sp,-4
    9124:	dfc00015 	stw	ra,0(sp)
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
    9128:	00090780 	call	9078 <tcp_fasttmr>

  if (++tcp_timer & 1) {
    912c:	d0a8bb03 	ldbu	r2,-23828(gp)
    9130:	10800044 	addi	r2,r2,1
    9134:	d0a8bb05 	stb	r2,-23828(gp)
    9138:	1080004c 	andi	r2,r2,1
    913c:	1000031e 	bne	r2,zero,914c <tcp_tmr+0x2c>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  }
}
    9140:	dfc00017 	ldw	ra,0(sp)
    9144:	dec00104 	addi	sp,sp,4
    9148:	f800283a 	ret
    914c:	dfc00017 	ldw	ra,0(sp)
    9150:	dec00104 	addi	sp,sp,4
  tcp_fasttmr();

  if (++tcp_timer & 1) {
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
    9154:	00081581 	jmpi	8158 <tcp_slowtmr>

00009158 <tcp_next_iss>:
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
    9158:	d0a00717 	ldw	r2,-32740(gp)
    915c:	d0e8bd17 	ldw	r3,-23820(gp)
    9160:	1885883a 	add	r2,r3,r2
    9164:	d0a00715 	stw	r2,-32740(gp)
  return iss;
}
    9168:	f800283a 	ret

0000916c <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, ip_addr_t *addr)
{
    916c:	defffe04 	addi	sp,sp,-8
    9170:	dc000015 	stw	r16,0(sp)
    9174:	2021883a 	mov	r16,r4
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
    9178:	2809883a 	mov	r4,r5
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, ip_addr_t *addr)
{
    917c:	dfc00115 	stw	ra,4(sp)
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
    9180:	000427c0 	call	427c <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
    9184:	10000726 	beq	r2,zero,91a4 <tcp_eff_send_mss+0x38>
    9188:	1080090b 	ldhu	r2,36(r2)
    918c:	10ffffcc 	andi	r3,r2,65535
    9190:	18000426 	beq	r3,zero,91a4 <tcp_eff_send_mss+0x38>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
    9194:	10bff604 	addi	r2,r2,-40
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * We correct for TCP options in tcp_write(), and don't support IP options.
     */
    sendmss = LWIP_MIN(sendmss, mss_s);
    9198:	80ffffcc 	andi	r3,r16,65535
    919c:	113fffcc 	andi	r4,r2,65535
    91a0:	20c00536 	bltu	r4,r3,91b8 <tcp_eff_send_mss+0x4c>
  }
  return sendmss;
}
    91a4:	8005883a 	mov	r2,r16
    91a8:	dfc00117 	ldw	ra,4(sp)
    91ac:	dc000017 	ldw	r16,0(sp)
    91b0:	dec00204 	addi	sp,sp,8
    91b4:	f800283a 	ret
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * We correct for TCP options in tcp_write(), and don't support IP options.
     */
    sendmss = LWIP_MIN(sendmss, mss_s);
    91b8:	1021883a 	mov	r16,r2
  }
  return sendmss;
}
    91bc:	8005883a 	mov	r2,r16
    91c0:	dfc00117 	ldw	ra,4(sp)
    91c4:	dc000017 	ldw	r16,0(sp)
    91c8:	dec00204 	addi	sp,sp,8
    91cc:	f800283a 	ret

000091d0 <tcp_connect>:
{
  err_t ret;
  u32_t iss;
  u16_t old_local_port;

  LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
    91d0:	20800617 	ldw	r2,24(r4)
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port,
      tcp_connected_fn connected)
{
    91d4:	defffa04 	addi	sp,sp,-24
    91d8:	dd000415 	stw	r20,16(sp)
    91dc:	dc400115 	stw	r17,4(sp)
    91e0:	dc000015 	stw	r16,0(sp)
    91e4:	dfc00515 	stw	ra,20(sp)
    91e8:	dcc00315 	stw	r19,12(sp)
    91ec:	dc800215 	stw	r18,8(sp)
    91f0:	2021883a 	mov	r16,r4
    91f4:	2823883a 	mov	r17,r5
    91f8:	3829883a 	mov	r20,r7
  err_t ret;
  u32_t iss;
  u16_t old_local_port;

  LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
    91fc:	1000531e 	bne	r2,zero,934c <tcp_connect+0x17c>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    9200:	28005b26 	beq	r5,zero,9370 <tcp_connect+0x1a0>
    pcb->remote_ip = *ipaddr;
    9204:	28c00017 	ldw	r3,0(r5)
    return ERR_VAL;
  }
  pcb->remote_port = port;

  /* check if we have a route to the remote host */
  if (ip_addr_isany(&(pcb->local_ip))) {
    9208:	20800017 	ldw	r2,0(r4)
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
    920c:	2180080d 	sth	r6,32(r4)

  LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
    9210:	20c00115 	stw	r3,4(r4)
    return ERR_VAL;
  }
  pcb->remote_port = port;

  /* check if we have a route to the remote host */
  if (ip_addr_isany(&(pcb->local_ip))) {
    9214:	1000051e 	bne	r2,zero,922c <tcp_connect+0x5c>
    /* no local IP address set, yet. */
    struct netif *netif = ip_route(&(pcb->remote_ip));
    9218:	21000104 	addi	r4,r4,4
    921c:	000427c0 	call	427c <ip_route>
    if (netif == NULL) {
    9220:	10006c26 	beq	r2,zero,93d4 <tcp_connect+0x204>
      /* Don't even try to send a SYN packet if we have no route
         since that will fail. */
      return ERR_RTE;
    }
    /* Use the netif's IP address as local address. */
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
    9224:	10800117 	ldw	r2,4(r2)
    9228:	80800015 	stw	r2,0(r16)
  }

  old_local_port = pcb->local_port;
  if (pcb->local_port == 0) {
    922c:	8480078b 	ldhu	r18,30(r16)
    9230:	9000041e 	bne	r18,zero,9244 <tcp_connect+0x74>
    pcb->local_port = tcp_new_port();
    9234:	0007a840 	call	7a84 <tcp_new_port>
    9238:	8080078d 	sth	r2,30(r16)
    if (pcb->local_port == 0) {
    923c:	10bfffcc 	andi	r2,r2,65535
    9240:	10006226 	beq	r2,zero,93cc <tcp_connect+0x1fc>
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
    9244:	d0a00717 	ldw	r2,-32740(gp)
    9248:	d128bd17 	ldw	r4,-23820(gp)
  iss = tcp_next_iss();
  pcb->rcv_nxt = 0;
  pcb->snd_nxt = iss;
  pcb->lastack = iss - 1;
  pcb->snd_lbb = iss - 1;
  pcb->rcv_wnd = TCP_WND;
    924c:	00c20004 	movi	r3,2048
    9250:	80c00c0d 	sth	r3,48(r16)
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
    9254:	2085883a 	add	r2,r4,r2
  }
#endif /* SO_REUSE */
  iss = tcp_next_iss();
  pcb->rcv_nxt = 0;
  pcb->snd_nxt = iss;
  pcb->lastack = iss - 1;
    9258:	11bfffc4 	addi	r6,r2,-1
  pcb->snd_lbb = iss - 1;
  pcb->rcv_wnd = TCP_WND;
  pcb->rcv_ann_wnd = TCP_WND;
    925c:	80c00c8d 	sth	r3,50(r16)
  pcb->rcv_ann_right_edge = pcb->rcv_nxt;
  pcb->snd_wnd = TCP_WND;
    9260:	80c0190d 	sth	r3,100(r16)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    9264:	00c08604 	movi	r3,536
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
    9268:	880b883a 	mov	r5,r17
    926c:	01008604 	movi	r4,536
  }
#endif /* SO_REUSE */
  iss = tcp_next_iss();
  pcb->rcv_nxt = 0;
  pcb->snd_nxt = iss;
  pcb->lastack = iss - 1;
    9270:	81801315 	stw	r6,76(r16)
  pcb->snd_lbb = iss - 1;
    9274:	81801815 	stw	r6,96(r16)
  pcb->rcv_ann_wnd = TCP_WND;
  pcb->rcv_ann_right_edge = pcb->rcv_nxt;
  pcb->snd_wnd = TCP_WND;
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    9278:	80c00e8d 	sth	r3,58(r16)
      }
    }
  }
#endif /* SO_REUSE */
  iss = tcp_next_iss();
  pcb->rcv_nxt = 0;
    927c:	80000b15 	stw	zero,44(r16)
  pcb->snd_nxt = iss;
    9280:	80801515 	stw	r2,84(r16)
  pcb->lastack = iss - 1;
  pcb->snd_lbb = iss - 1;
  pcb->rcv_wnd = TCP_WND;
  pcb->rcv_ann_wnd = TCP_WND;
  pcb->rcv_ann_right_edge = pcb->rcv_nxt;
    9284:	80000d15 	stw	zero,52(r16)
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
    9288:	d0a00715 	stw	r2,-32740(gp)
  pcb->snd_wnd = TCP_WND;
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
    928c:	000916c0 	call	916c <tcp_eff_send_mss>
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  pcb->ssthresh = pcb->mss * 10;
    9290:	10c002a4 	muli	r3,r2,10
  pcb->snd_wnd = TCP_WND;
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
    9294:	80800e8d 	sth	r2,58(r16)
#else /* LWIP_CALLBACK_API */  
  LWIP_UNUSED_ARG(connected);
#endif /* LWIP_CALLBACK_API */

  /* Send a SYN together with the MSS option. */
  ret = tcp_enqueue_flags(pcb, TCP_SYN);
    9298:	04c00084 	movi	r19,2
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
    929c:	00800044 	movi	r2,1
    92a0:	8080140d 	sth	r2,80(r16)
  pcb->ssthresh = pcb->mss * 10;
    92a4:	80c0148d 	sth	r3,82(r16)
#if LWIP_CALLBACK_API
  pcb->connected = connected;
    92a8:	85002215 	stw	r20,136(r16)
#else /* LWIP_CALLBACK_API */  
  LWIP_UNUSED_ARG(connected);
#endif /* LWIP_CALLBACK_API */

  /* Send a SYN together with the MSS option. */
  ret = tcp_enqueue_flags(pcb, TCP_SYN);
    92ac:	8009883a 	mov	r4,r16
    92b0:	980b883a 	mov	r5,r19
    92b4:	000bf740 	call	bf74 <tcp_enqueue_flags>
    92b8:	1023883a 	mov	r17,r2
  if (ret == ERR_OK) {
    92bc:	88803fcc 	andi	r2,r17,255
    92c0:	1080201c 	xori	r2,r2,128
    92c4:	10bfe004 	addi	r2,r2,-128
    92c8:	1000171e 	bne	r2,zero,9328 <tcp_connect+0x158>
    /* SYN segment was enqueued, changed the pcbs state now */
    pcb->state = SYN_SENT;
    92cc:	84c00615 	stw	r19,24(r16)
    if (old_local_port != 0) {
    92d0:	90000d26 	beq	r18,zero,9308 <tcp_connect+0x138>
      TCP_RMV(&tcp_bound_pcbs, pcb);
    92d4:	d0e8c017 	ldw	r3,-23808(gp)
    92d8:	1c003126 	beq	r3,r16,93a0 <tcp_connect+0x1d0>
    92dc:	d0e8bf15 	stw	r3,-23812(gp)
    92e0:	18000926 	beq	r3,zero,9308 <tcp_connect+0x138>
    92e4:	18800317 	ldw	r2,12(r3)
    92e8:	14000526 	beq	r2,r16,9300 <tcp_connect+0x130>
    92ec:	1007883a 	mov	r3,r2
    92f0:	10002126 	beq	r2,zero,9378 <tcp_connect+0x1a8>
    92f4:	18800317 	ldw	r2,12(r3)
    92f8:	143ffc1e 	bne	r2,r16,92ec <tcp_connect+0x11c>
    92fc:	d0e8bf15 	stw	r3,-23812(gp)
    9300:	80800317 	ldw	r2,12(r16)
    9304:	18800315 	stw	r2,12(r3)
    }
    TCP_REG_ACTIVE(pcb);
    9308:	d0a8bc17 	ldw	r2,-23824(gp)
    930c:	d428bc15 	stw	r16,-23824(gp)
    9310:	80800315 	stw	r2,12(r16)
    9314:	000cfa80 	call	cfa8 <tcp_timer_needed>
    9318:	00800044 	movi	r2,1
    snmp_inc_tcpactiveopens();

    tcp_output(pcb);
    931c:	8009883a 	mov	r4,r16
    /* SYN segment was enqueued, changed the pcbs state now */
    pcb->state = SYN_SENT;
    if (old_local_port != 0) {
      TCP_RMV(&tcp_bound_pcbs, pcb);
    }
    TCP_REG_ACTIVE(pcb);
    9320:	d0a8bb85 	stb	r2,-23826(gp)
    snmp_inc_tcpactiveopens();

    tcp_output(pcb);
    9324:	000c38c0 	call	c38c <tcp_output>
  }
  return ret;
}
    9328:	8805883a 	mov	r2,r17
    932c:	dfc00517 	ldw	ra,20(sp)
    9330:	dd000417 	ldw	r20,16(sp)
    9334:	dcc00317 	ldw	r19,12(sp)
    9338:	dc800217 	ldw	r18,8(sp)
    933c:	dc400117 	ldw	r17,4(sp)
    9340:	dc000017 	ldw	r16,0(sp)
    9344:	dec00604 	addi	sp,sp,24
    9348:	f800283a 	ret
{
  err_t ret;
  u32_t iss;
  u16_t old_local_port;

  LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
    934c:	010000b4 	movhi	r4,2
    9350:	210d4b04 	addi	r4,r4,13612
    9354:	014000b4 	movhi	r5,2
    9358:	29557804 	addi	r5,r5,21984
    935c:	0180acc4 	movi	r6,691
    9360:	01c000b4 	movhi	r7,2
    9364:	39d4ab04 	addi	r7,r7,21164
    9368:	00104380 	call	10438 <printf>
    936c:	003fff06 	br	936c <tcp_connect+0x19c>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
  } else {
    return ERR_VAL;
    9370:	047ffe84 	movi	r17,-6
    9374:	003fec06 	br	9328 <tcp_connect+0x158>
    /* SYN segment was enqueued, changed the pcbs state now */
    pcb->state = SYN_SENT;
    if (old_local_port != 0) {
      TCP_RMV(&tcp_bound_pcbs, pcb);
    }
    TCP_REG_ACTIVE(pcb);
    9378:	d0a8bc17 	ldw	r2,-23824(gp)
    937c:	d028bf15 	stw	zero,-23812(gp)
    9380:	d428bc15 	stw	r16,-23824(gp)
    9384:	80800315 	stw	r2,12(r16)
    9388:	000cfa80 	call	cfa8 <tcp_timer_needed>
    snmp_inc_tcpactiveopens();

    tcp_output(pcb);
    938c:	8009883a 	mov	r4,r16
    /* SYN segment was enqueued, changed the pcbs state now */
    pcb->state = SYN_SENT;
    if (old_local_port != 0) {
      TCP_RMV(&tcp_bound_pcbs, pcb);
    }
    TCP_REG_ACTIVE(pcb);
    9390:	00800044 	movi	r2,1
    9394:	d0a8bb85 	stb	r2,-23826(gp)
    snmp_inc_tcpactiveopens();

    tcp_output(pcb);
    9398:	000c38c0 	call	c38c <tcp_output>
    939c:	003fe206 	br	9328 <tcp_connect+0x158>
  ret = tcp_enqueue_flags(pcb, TCP_SYN);
  if (ret == ERR_OK) {
    /* SYN segment was enqueued, changed the pcbs state now */
    pcb->state = SYN_SENT;
    if (old_local_port != 0) {
      TCP_RMV(&tcp_bound_pcbs, pcb);
    93a0:	80800317 	ldw	r2,12(r16)
    93a4:	d0a8c015 	stw	r2,-23808(gp)
    }
    TCP_REG_ACTIVE(pcb);
    93a8:	d0a8bc17 	ldw	r2,-23824(gp)
    93ac:	d428bc15 	stw	r16,-23824(gp)
    93b0:	80800315 	stw	r2,12(r16)
    93b4:	000cfa80 	call	cfa8 <tcp_timer_needed>
    snmp_inc_tcpactiveopens();

    tcp_output(pcb);
    93b8:	8009883a 	mov	r4,r16
    /* SYN segment was enqueued, changed the pcbs state now */
    pcb->state = SYN_SENT;
    if (old_local_port != 0) {
      TCP_RMV(&tcp_bound_pcbs, pcb);
    }
    TCP_REG_ACTIVE(pcb);
    93bc:	00800044 	movi	r2,1
    93c0:	d0a8bb85 	stb	r2,-23826(gp)
    snmp_inc_tcpactiveopens();

    tcp_output(pcb);
    93c4:	000c38c0 	call	c38c <tcp_output>
    93c8:	003fd706 	br	9328 <tcp_connect+0x158>

  old_local_port = pcb->local_port;
  if (pcb->local_port == 0) {
    pcb->local_port = tcp_new_port();
    if (pcb->local_port == 0) {
      return ERR_BUF;
    93cc:	047fff84 	movi	r17,-2
    93d0:	003fd506 	br	9328 <tcp_connect+0x158>
    /* no local IP address set, yet. */
    struct netif *netif = ip_route(&(pcb->remote_ip));
    if (netif == NULL) {
      /* Don't even try to send a SYN packet if we have no route
         since that will fail. */
      return ERR_RTE;
    93d4:	047fff04 	movi	r17,-4
    93d8:	003fd306 	br	9328 <tcp_connect+0x158>

000093dc <tcp_debug_state_str>:
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

const char*
tcp_debug_state_str(enum tcp_state s)
{
  return tcp_state_str[s];
    93dc:	2109883a 	add	r4,r4,r4
    93e0:	008000b4 	movhi	r2,2
    93e4:	1095a604 	addi	r2,r2,22168
    93e8:	2109883a 	add	r4,r4,r4
    93ec:	1109883a 	add	r4,r2,r4
}
    93f0:	20800017 	ldw	r2,0(r4)
    93f4:	f800283a 	ret

000093f8 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
    93f8:	defff204 	addi	sp,sp,-56
    93fc:	dc000415 	stw	r16,16(sp)
  u8_t hdrlen;
  err_t err;

  PERF_START;

  TCP_STATS_INC(tcp.recv);
    9400:	040001f4 	movhi	r16,7
    9404:	84144804 	addi	r16,r16,20768
    9408:	80c0248b 	ldhu	r3,146(r16)
  snmp_inc_tcpinsegs();

  iphdr = (struct ip_hdr *)p->payload;
    940c:	20800117 	ldw	r2,4(r4)
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
    9410:	dc800615 	stw	r18,24(sp)
    9414:	dc400515 	stw	r17,20(sp)
    9418:	dfc00d15 	stw	ra,52(sp)
    941c:	df000c15 	stw	fp,48(sp)
    9420:	ddc00b15 	stw	r23,44(sp)
    9424:	dd800a15 	stw	r22,40(sp)
    9428:	dd400915 	stw	r21,36(sp)
    942c:	dd000815 	stw	r20,32(sp)
    9430:	dcc00715 	stw	r19,28(sp)
  u8_t hdrlen;
  err_t err;

  PERF_START;

  TCP_STATS_INC(tcp.recv);
    9434:	18c00044 	addi	r3,r3,1
    9438:	80c0248d 	sth	r3,146(r16)
  snmp_inc_tcpinsegs();

  iphdr = (struct ip_hdr *)p->payload;
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
    943c:	10c00003 	ldbu	r3,0(r2)
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
    9440:	2825883a 	mov	r18,r5
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = (struct ip_hdr *)p->payload;
    9444:	d0a8c215 	stw	r2,-23800(gp)
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
    9448:	18c003cc 	andi	r3,r3,15
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
    944c:	19803fcc 	andi	r6,r3,255
    9450:	318d883a 	add	r6,r6,r6
    9454:	318d883a 	add	r6,r6,r6
    9458:	018bc83a 	sub	r5,zero,r6

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = (struct ip_hdr *)p->payload;
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
    945c:	18c03fcc 	andi	r3,r3,255
    9460:	18c7883a 	add	r3,r3,r3
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
    9464:	297fffcc 	andi	r5,r5,65535

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = (struct ip_hdr *)p->payload;
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
    9468:	18c7883a 	add	r3,r3,r3
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
    946c:	2960001c 	xori	r5,r5,32768

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = (struct ip_hdr *)p->payload;
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
    9470:	10c5883a 	add	r2,r2,r3
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
    9474:	29600004 	addi	r5,r5,-32768
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
    9478:	2023883a 	mov	r17,r4

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = (struct ip_hdr *)p->payload;
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
    947c:	d0a8c315 	stw	r2,-23796(gp)
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
    9480:	00066980 	call	6698 <pbuf_header>
    9484:	10803fcc 	andi	r2,r2,255
    9488:	1000031e 	bne	r2,zero,9498 <tcp_input+0xa0>
    948c:	8880020b 	ldhu	r2,8(r17)
    9490:	00c004c4 	movi	r3,19
    9494:	18801336 	bltu	r3,r2,94e4 <tcp_input+0xec>
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  if(pbuf_header(p, -(hdrlen * 4))){
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    9498:	8080268b 	ldhu	r2,154(r16)
    949c:	10800044 	addi	r2,r2,1
    94a0:	8080268d 	sth	r2,154(r16)

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
dropped:
  TCP_STATS_INC(tcp.drop);
    94a4:	8080258b 	ldhu	r2,150(r16)
  snmp_inc_tcpinerrs();
  pbuf_free(p);
    94a8:	8809883a 	mov	r4,r17

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
dropped:
  TCP_STATS_INC(tcp.drop);
    94ac:	10800044 	addi	r2,r2,1
    94b0:	8080258d 	sth	r2,150(r16)
  snmp_inc_tcpinerrs();
  pbuf_free(p);
}
    94b4:	dfc00d17 	ldw	ra,52(sp)
    94b8:	df000c17 	ldw	fp,48(sp)
    94bc:	ddc00b17 	ldw	r23,44(sp)
    94c0:	dd800a17 	ldw	r22,40(sp)
    94c4:	dd400917 	ldw	r21,36(sp)
    94c8:	dd000817 	ldw	r20,32(sp)
    94cc:	dcc00717 	ldw	r19,28(sp)
    94d0:	dc800617 	ldw	r18,24(sp)
    94d4:	dc400517 	ldw	r17,20(sp)
    94d8:	dc000417 	ldw	r16,16(sp)
    94dc:	dec00e04 	addi	sp,sp,56
  PERF_STOP("tcp_input");
  return;
dropped:
  TCP_STATS_INC(tcp.drop);
  snmp_inc_tcpinerrs();
  pbuf_free(p);
    94e0:	00067d81 	jmpi	67d8 <pbuf_free>
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
    94e4:	04c000f4 	movhi	r19,3
    94e8:	9ceeac04 	addi	r19,r19,-17744
    94ec:	99000017 	ldw	r4,0(r19)
    94f0:	900b883a 	mov	r5,r18
    94f4:	00049440 	call	4944 <ip4_addr_isbroadcast>
    94f8:	10803fcc 	andi	r2,r2,255
    94fc:	1000121e 	bne	r2,zero,9548 <tcp_input+0x150>
      ip_addr_ismulticast(&current_iphdr_dest)) {
    9500:	98c00017 	ldw	r3,0(r19)
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
    9504:	00803804 	movi	r2,224
      ip_addr_ismulticast(&current_iphdr_dest)) {
    9508:	18c03c0c 	andi	r3,r3,240
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
    950c:	18800e26 	beq	r3,r2,9548 <tcp_input+0x150>
    goto dropped;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
    9510:	8880020b 	ldhu	r2,8(r17)
    9514:	8809883a 	mov	r4,r17
    9518:	014000f4 	movhi	r5,3
    951c:	296eaa04 	addi	r5,r5,-17752
    9520:	d8800015 	stw	r2,0(sp)
    9524:	980d883a 	mov	r6,r19
    9528:	01c00184 	movi	r7,6
    952c:	0003e800 	call	3e80 <inet_chksum_pseudo>
    9530:	10bfffcc 	andi	r2,r2,65535
    9534:	10000826 	beq	r2,zero,9558 <tcp_input+0x160>
        inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
      IP_PROTO_TCP, p->tot_len)));
#if TCP_DEBUG
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
    9538:	8080260b 	ldhu	r2,152(r16)
    953c:	10800044 	addi	r2,r2,1
    9540:	8080260d 	sth	r2,152(r16)
    goto dropped;
    9544:	003fd706 	br	94a4 <tcp_input+0xac>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
      ip_addr_ismulticast(&current_iphdr_dest)) {
    TCP_STATS_INC(tcp.proterr);
    9548:	8080280b 	ldhu	r2,160(r16)
    954c:	10800044 	addi	r2,r2,1
    9550:	8080280d 	sth	r2,160(r16)
    goto dropped;
    9554:	003fd306 	br	94a4 <tcp_input+0xac>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
    9558:	d0a8c317 	ldw	r2,-23796(gp)
  if(pbuf_header(p, -(hdrlen * 4))){
    955c:	8809883a 	mov	r4,r17
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
    9560:	1140030b 	ldhu	r5,12(r2)
    9564:	280ad13a 	srli	r5,r5,4
    9568:	294003cc 	andi	r5,r5,15
  if(pbuf_header(p, -(hdrlen * 4))){
    956c:	297fff24 	muli	r5,r5,-4
    9570:	00066980 	call	6698 <pbuf_header>
    9574:	10803fcc 	andi	r2,r2,255
    9578:	103fc71e 	bne	r2,zero,9498 <tcp_input+0xa0>
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
    957c:	d0a8c317 	ldw	r2,-23796(gp)
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    9580:	050000f4 	movhi	r20,3
    9584:	a52eb904 	addi	r20,r20,-17692
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  tcphdr->dest = ntohs(tcphdr->dest);
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
    9588:	1140018b 	ldhu	r5,6(r2)
    958c:	10c0010b 	ldhu	r3,4(r2)
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
    9590:	1100000b 	ldhu	r4,0(r2)
  tcphdr->dest = ntohs(tcphdr->dest);
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
    9594:	280a943a 	slli	r5,r5,16
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  tcphdr->wnd = ntohs(tcphdr->wnd);

  flags = TCPH_FLAGS(tcphdr);
    9598:	11c0030b 	ldhu	r7,12(r2)
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
    959c:	2016923a 	slli	r11,r4,8
  tcphdr->dest = ntohs(tcphdr->dest);
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
    95a0:	28c6b03a 	or	r3,r5,r3
    95a4:	1812963a 	slli	r9,r3,24
    95a8:	180cd63a 	srli	r6,r3,24
    95ac:	180ad23a 	srli	r5,r3,8
    95b0:	18ffc00c 	andi	r3,r3,65280
    95b4:	1806923a 	slli	r3,r3,8
    95b8:	498cb03a 	or	r6,r9,r6
    95bc:	297fc00c 	andi	r5,r5,65280
    95c0:	314ab03a 	or	r5,r6,r5
    95c4:	28cab03a 	or	r5,r5,r3
    95c8:	2806d43a 	srli	r3,r5,16
    95cc:	1140010d 	sth	r5,4(r2)
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
    95d0:	2012d23a 	srli	r9,r4,8
  tcphdr->dest = ntohs(tcphdr->dest);
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
    95d4:	10c0018d 	sth	r3,6(r2)
    95d8:	d168c415 	stw	r5,-23792(gp)
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
    95dc:	1280028b 	ldhu	r10,10(r2)
    95e0:	10c0020b 	ldhu	r3,8(r2)
    goto dropped;
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  tcphdr->dest = ntohs(tcphdr->dest);
    95e4:	1200008b 	ldhu	r8,2(r2)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
    95e8:	5014943a 	slli	r10,r10,16
  tcphdr->wnd = ntohs(tcphdr->wnd);
    95ec:	1180038b 	ldhu	r6,14(r2)

  flags = TCPH_FLAGS(tcphdr);
    95f0:	380ed23a 	srli	r7,r7,8

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  tcphdr->dest = ntohs(tcphdr->dest);
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
    95f4:	50c6b03a 	or	r3,r10,r3
    95f8:	1818963a 	slli	r12,r3,24
    95fc:	1814d63a 	srli	r10,r3,24
    9600:	1808d23a 	srli	r4,r3,8
    9604:	18ffc00c 	andi	r3,r3,65280
    9608:	1806923a 	slli	r3,r3,8
    960c:	6294b03a 	or	r10,r12,r10
    9610:	213fc00c 	andi	r4,r4,65280
    9614:	5108b03a 	or	r4,r10,r4
    9618:	20c8b03a 	or	r4,r4,r3
    961c:	2006d43a 	srli	r3,r4,16
    9620:	1100020d 	sth	r4,8(r2)
    goto dropped;
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  tcphdr->dest = ntohs(tcphdr->dest);
    9624:	4018923a 	slli	r12,r8,8
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
    9628:	10c0028d 	sth	r3,10(r2)
  tcphdr->wnd = ntohs(tcphdr->wnd);

  flags = TCPH_FLAGS(tcphdr);
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
    962c:	8d80020b 	ldhu	r22,8(r17)
  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  tcphdr->dest = ntohs(tcphdr->dest);
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  tcphdr->wnd = ntohs(tcphdr->wnd);
    9630:	3006923a 	slli	r3,r6,8
    goto dropped;
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  tcphdr->dest = ntohs(tcphdr->dest);
    9634:	4010d23a 	srli	r8,r8,8
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  tcphdr->wnd = ntohs(tcphdr->wnd);
    9638:	300cd23a 	srli	r6,r6,8

  flags = TCPH_FLAGS(tcphdr);
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
    963c:	3b4000cc 	andi	r13,r7,3
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    9640:	a2800017 	ldw	r10,0(r20)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  tcphdr->wnd = ntohs(tcphdr->wnd);

  flags = TCPH_FLAGS(tcphdr);
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
    9644:	681ac03a 	cmpne	r13,r13,zero
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
    9648:	5a56b03a 	or	r11,r11,r9
  tcphdr->dest = ntohs(tcphdr->dest);
    964c:	6218b03a 	or	r12,r12,r8
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  tcphdr->wnd = ntohs(tcphdr->wnd);

  flags = TCPH_FLAGS(tcphdr);
    9650:	3d400fcc 	andi	r21,r7,63
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
    9654:	6d9b883a 	add	r13,r13,r22
  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  tcphdr->dest = ntohs(tcphdr->dest);
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  tcphdr->wnd = ntohs(tcphdr->wnd);
    9658:	1986b03a 	or	r3,r3,r6
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
    965c:	12c0000d 	sth	r11,0(r2)
  tcphdr->dest = ntohs(tcphdr->dest);
    9660:	1300008d 	sth	r12,2(r2)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
    9664:	d128c515 	stw	r4,-23788(gp)
  tcphdr->wnd = ntohs(tcphdr->wnd);
    9668:	10c0038d 	sth	r3,14(r2)

  flags = TCPH_FLAGS(tcphdr);
    966c:	d568c605 	stb	r21,-23784(gp)
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
    9670:	d368c68d 	sth	r13,-23782(gp)
  tcphdr->dest = ntohs(tcphdr->dest);
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  tcphdr->wnd = ntohs(tcphdr->wnd);

  flags = TCPH_FLAGS(tcphdr);
    9674:	d9c0020d 	sth	r7,8(sp)
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    9678:	50009426 	beq	r10,zero,98cc <tcp_input+0x4d4>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    967c:	50c00617 	ldw	r3,24(r10)
    9680:	18008926 	beq	r3,zero,98a8 <tcp_input+0x4b0>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    9684:	01800284 	movi	r6,10
    9688:	19807e26 	beq	r3,r6,9884 <tcp_input+0x48c>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    968c:	01800044 	movi	r6,1
    9690:	19807326 	beq	r3,r6,9860 <tcp_input+0x468>
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
    9694:	00c000f4 	movhi	r3,3
    9698:	18eeaa04 	addi	r3,r3,-17752
    969c:	1f000017 	ldw	fp,0(r3)
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
    96a0:	60ffffcc 	andi	r3,r12,65535
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
       ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
    96a4:	9dc00017 	ldw	r23,0(r19)
    96a8:	5025883a 	mov	r18,r10
  flags = TCPH_FLAGS(tcphdr);
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
    96ac:	0013883a 	mov	r9,zero
    96b0:	5a3fffcc 	andi	r8,r11,65535
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
    96b4:	d8c00315 	stw	r3,12(sp)
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    96b8:	03c00284 	movi	r15,10
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    96bc:	03800044 	movi	r14,1
    96c0:	00000806 	br	96e4 <tcp_input+0x2ec>
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    96c4:	90c00317 	ldw	r3,12(r18)
    96c8:	18008026 	beq	r3,zero,98cc <tcp_input+0x4d4>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    96cc:	19800617 	ldw	r6,24(r3)
    96d0:	30007526 	beq	r6,zero,98a8 <tcp_input+0x4b0>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    96d4:	33c06b26 	beq	r6,r15,9884 <tcp_input+0x48c>
    96d8:	9013883a 	mov	r9,r18
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    96dc:	33806026 	beq	r6,r14,9860 <tcp_input+0x468>
    96e0:	1825883a 	mov	r18,r3
    if (pcb->remote_port == tcphdr->src &&
    96e4:	90c0080b 	ldhu	r3,32(r18)
    96e8:	40fff61e 	bne	r8,r3,96c4 <tcp_input+0x2cc>
    96ec:	90c0078b 	ldhu	r3,30(r18)
    96f0:	d9800317 	ldw	r6,12(sp)
    96f4:	30fff31e 	bne	r6,r3,96c4 <tcp_input+0x2cc>
       pcb->local_port == tcphdr->dest &&
    96f8:	90c00117 	ldw	r3,4(r18)
    96fc:	1f3ff11e 	bne	r3,fp,96c4 <tcp_input+0x2cc>
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
    9700:	90c00017 	ldw	r3,0(r18)
    9704:	1dffef1e 	bne	r3,r23,96c4 <tcp_input+0x2cc>
       ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
    9708:	90c00317 	ldw	r3,12(r18)
    970c:	1c814626 	beq	r3,r18,9c28 <tcp_input+0x830>
      if (prev != NULL) {
    9710:	48000426 	beq	r9,zero,9724 <tcp_input+0x32c>
        prev->next = pcb->next;
    9714:	48c00315 	stw	r3,12(r9)
        pcb->next = tcp_active_pcbs;
    9718:	92800315 	stw	r10,12(r18)
        tcp_active_pcbs = pcb;
    971c:	a4800015 	stw	r18,0(r20)
    9720:	5007883a 	mov	r3,r10
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
    9724:	1c813726 	beq	r3,r18,9c04 <tcp_input+0x80c>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
    9728:	04c00134 	movhi	r19,4
    972c:	9ce7c004 	addi	r19,r19,-24832
    inseg.tcphdr = tcphdr;

    recv_data = NULL;
    recv_flags = 0;

    if (flags & TCP_PSH) {
    9730:	39c0020c 	andi	r7,r7,8

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
    inseg.len = p->tot_len;
    inseg.p = p;
    inseg.tcphdr = tcphdr;
    9734:	98800315 	stw	r2,12(r19)
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
    9738:	98000015 	stw	zero,0(r19)
    inseg.len = p->tot_len;
    973c:	9d80020d 	sth	r22,8(r19)
    inseg.p = p;
    9740:	9c400115 	stw	r17,4(r19)
    inseg.tcphdr = tcphdr;

    recv_data = NULL;
    9744:	d028c715 	stw	zero,-23780(gp)
    recv_flags = 0;
    9748:	d028c805 	stb	zero,-23776(gp)

    if (flags & TCP_PSH) {
    974c:	38803fcc 	andi	r2,r7,255
    9750:	10000326 	beq	r2,zero,9760 <tcp_input+0x368>
      p->flags |= PBUF_FLAG_PUSH;
    9754:	88800343 	ldbu	r2,13(r17)
    9758:	10800054 	ori	r2,r2,1
    975c:	88800345 	stb	r2,13(r17)
    }

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
    9760:	90801f17 	ldw	r2,124(r18)
    9764:	10000c26 	beq	r2,zero,9798 <tcp_input+0x3a0>
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
    9768:	9009883a 	mov	r4,r18
    976c:	0008f700 	call	8f70 <tcp_process_refused_data>
    9770:	10803fcc 	andi	r2,r2,255
    9774:	1080201c 	xori	r2,r2,128
    9778:	10bfe004 	addi	r2,r2,-128
    977c:	00fffd84 	movi	r3,-10
    9780:	10c11c26 	beq	r2,r3,9bf4 <tcp_input+0x7fc>
    9784:	90801f17 	ldw	r2,124(r18)
    9788:	10000226 	beq	r2,zero,9794 <tcp_input+0x39c>
        ((pcb->refused_data != NULL) && (tcplen > 0))) {
    978c:	d0a8c68b 	ldhu	r2,-23782(gp)
    9790:	1001181e 	bne	r2,zero,9bf4 <tcp_input+0x7fc>
    9794:	d568c603 	ldbu	r21,-23784(gp)
  err_t err;

  err = ERR_OK;

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
    9798:	a880010c 	andi	r2,r21,4
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        goto aborted;
      }
    }
    tcp_input_pcb = pcb;
    979c:	d4a8c915 	stw	r18,-23772(gp)
  err_t err;

  err = ERR_OK;

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
    97a0:	10803fcc 	andi	r2,r2,255
    97a4:	10018d26 	beq	r2,zero,9ddc <tcp_input+0x9e4>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
    97a8:	90800617 	ldw	r2,24(r18)
    97ac:	00c00084 	movi	r3,2
    97b0:	10c13326 	beq	r2,r3,9c80 <tcp_input+0x888>
      if (ackno == pcb->snd_nxt) {
        acceptable = 1;
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
    97b4:	90c00b17 	ldw	r3,44(r18)
    97b8:	d128c417 	ldw	r4,-23792(gp)
    97bc:	20c7c83a 	sub	r3,r4,r3
    97c0:	18000316 	blt	r3,zero,97d0 <tcp_input+0x3d8>
    97c4:	91000c0b 	ldhu	r4,48(r18)
    97c8:	1907c83a 	sub	r3,r3,r4
    97cc:	00c18f0e 	bge	zero,r3,9e0c <tcp_input+0xa14>
    97d0:	d0a8c803 	ldbu	r2,-23776(gp)
    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
      if (recv_flags & TF_RESET) {
    97d4:	10c0020c 	andi	r3,r2,8
    97d8:	18c03fcc 	andi	r3,r3,255
    97dc:	18011b26 	beq	r3,zero,9c4c <tcp_input+0x854>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
    97e0:	90802417 	ldw	r2,144(r18)
    97e4:	10000326 	beq	r2,zero,97f4 <tcp_input+0x3fc>
    97e8:	91000417 	ldw	r4,16(r18)
    97ec:	017ffd44 	movi	r5,-11
    97f0:	103ee83a 	callr	r2
          /* Connection closed although the application has only shut down the
             tx side: call the PCB's err callback and indicate the closure to
             ensure the application doesn't continue using the PCB. */
          TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
        }
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
    97f4:	900b883a 	mov	r5,r18
    97f8:	010000f4 	movhi	r4,3
    97fc:	212eb904 	addi	r4,r4,-17692
    9800:	000872c0 	call	872c <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
    9804:	01000084 	movi	r4,2
    9808:	900b883a 	mov	r5,r18
    980c:	000618c0 	call	618c <memp_free>
aborted:
    tcp_input_pcb = NULL;
    recv_data = NULL;

    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
    9810:	99000117 	ldw	r4,4(r19)
      }
    }
    /* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).
       Below this line, 'pcb' may not be dereferenced! */
aborted:
    tcp_input_pcb = NULL;
    9814:	d028c915 	stw	zero,-23772(gp)
    recv_data = NULL;
    9818:	d028c715 	stw	zero,-23780(gp)

    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
    981c:	20000426 	beq	r4,zero,9830 <tcp_input+0x438>
    {
      pbuf_free(inseg.p);
    9820:	00067d80 	call	67d8 <pbuf_free>
      inseg.p = NULL;
    9824:	00800134 	movhi	r2,4
    9828:	10a7c004 	addi	r2,r2,-24832
    982c:	10000115 	stw	zero,4(r2)
  return;
dropped:
  TCP_STATS_INC(tcp.drop);
  snmp_inc_tcpinerrs();
  pbuf_free(p);
}
    9830:	dfc00d17 	ldw	ra,52(sp)
    9834:	df000c17 	ldw	fp,48(sp)
    9838:	ddc00b17 	ldw	r23,44(sp)
    983c:	dd800a17 	ldw	r22,40(sp)
    9840:	dd400917 	ldw	r21,36(sp)
    9844:	dd000817 	ldw	r20,32(sp)
    9848:	dcc00717 	ldw	r19,28(sp)
    984c:	dc800617 	ldw	r18,24(sp)
    9850:	dc400517 	ldw	r17,20(sp)
    9854:	dc000417 	ldw	r16,16(sp)
    9858:	dec00e04 	addi	sp,sp,56
    985c:	f800283a 	ret

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    9860:	010000b4 	movhi	r4,2
    9864:	210d4b04 	addi	r4,r4,13612
    9868:	014000b4 	movhi	r5,2
    986c:	29562504 	addi	r5,r5,22676
    9870:	01802b44 	movi	r6,173
    9874:	01c000b4 	movhi	r7,2
    9878:	39d5b804 	addi	r7,r7,22240
    987c:	00104380 	call	10438 <printf>
    9880:	003fff06 	br	9880 <tcp_input+0x488>
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    9884:	010000b4 	movhi	r4,2
    9888:	210d4b04 	addi	r4,r4,13612
    988c:	014000b4 	movhi	r5,2
    9890:	29561a04 	addi	r5,r5,22632
    9894:	01802b04 	movi	r6,172
    9898:	01c000b4 	movhi	r7,2
    989c:	39d5b804 	addi	r7,r7,22240
    98a0:	00104380 	call	10438 <printf>
    98a4:	003fff06 	br	98a4 <tcp_input+0x4ac>
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    98a8:	010000b4 	movhi	r4,2
    98ac:	210d4b04 	addi	r4,r4,13612
    98b0:	014000b4 	movhi	r5,2
    98b4:	29561004 	addi	r5,r5,22592
    98b8:	01802ac4 	movi	r6,171
    98bc:	01c000b4 	movhi	r7,2
    98c0:	39d5b804 	addi	r7,r7,22240
    98c4:	00104380 	call	10438 <printf>
    98c8:	003fff06 	br	98c8 <tcp_input+0x4d0>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    98cc:	008000f4 	movhi	r2,3
    98d0:	10aebe04 	addi	r2,r2,-17672
    98d4:	10800017 	ldw	r2,0(r2)
    98d8:	10004726 	beq	r2,zero,99f8 <tcp_input+0x600>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
    98dc:	10c00617 	ldw	r3,24(r2)
    98e0:	01800284 	movi	r6,10
    98e4:	19803b1e 	bne	r3,r6,99d4 <tcp_input+0x5dc>
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
    98e8:	018000f4 	movhi	r6,3
    98ec:	31aeaa04 	addi	r6,r6,-17752
    98f0:	32800017 	ldw	r10,0(r6)
         ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
    98f4:	9a400017 	ldw	r9,0(r19)
    98f8:	5a3fffcc 	andi	r8,r11,65535
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
    98fc:	61bfffcc 	andi	r6,r12,65535
    9900:	00000406 	br	9914 <tcp_input+0x51c>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    9904:	10800317 	ldw	r2,12(r2)
    9908:	10003b26 	beq	r2,zero,99f8 <tcp_input+0x600>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
    990c:	13800617 	ldw	r14,24(r2)
    9910:	70c0301e 	bne	r14,r3,99d4 <tcp_input+0x5dc>
      if (pcb->remote_port == tcphdr->src &&
    9914:	1380080b 	ldhu	r14,32(r2)
    9918:	43bffa1e 	bne	r8,r14,9904 <tcp_input+0x50c>
    991c:	1380078b 	ldhu	r14,30(r2)
    9920:	33bff81e 	bne	r6,r14,9904 <tcp_input+0x50c>
         pcb->local_port == tcphdr->dest &&
    9924:	13800117 	ldw	r14,4(r2)
    9928:	72bff61e 	bne	r14,r10,9904 <tcp_input+0x50c>
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
    992c:	13800017 	ldw	r14,0(r2)
    9930:	727ff41e 	bne	r14,r9,9904 <tcp_input+0x50c>
  /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
  /* RFC 793 3.9 Event Processing - Segment Arrives:
   * - first check sequence number - we skip that one in TIME_WAIT (always
   *   acceptable since we only send ACKs)
   * - second check the RST bit (... return) */
  if (flags & TCP_RST)  {
    9934:	38c0010c 	andi	r3,r7,4
    9938:	18c03fcc 	andi	r3,r3,255
    993c:	18000c1e 	bne	r3,zero,9970 <tcp_input+0x578>
    return ERR_OK;
  }
  /* - fourth, check the SYN bit, */
  if (flags & TCP_SYN) {
    9940:	38c0008c 	andi	r3,r7,2
    9944:	18c03fcc 	andi	r3,r3,255
    9948:	18000b26 	beq	r3,zero,9978 <tcp_input+0x580>
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
    994c:	10c00b17 	ldw	r3,44(r2)
    9950:	28cfc83a 	sub	r7,r5,r3
    9954:	38000416 	blt	r7,zero,9968 <tcp_input+0x570>
    9958:	11c00c0b 	ldhu	r7,48(r2)
 *
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
    995c:	19c7883a 	add	r3,r3,r7
  }
  /* - fourth, check the SYN bit, */
  if (flags & TCP_SYN) {
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
    9960:	28c7c83a 	sub	r3,r5,r3
    9964:	00c00b0e 	bge	zero,r3,9994 <tcp_input+0x59c>
    /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
         Restart the 2 MSL time-wait timeout.*/
    pcb->tmr = tcp_ticks;
  }

  if ((tcplen > 0))  {
    9968:	6b7fffcc 	andi	r13,r13,65535
    996c:	6800131e 	bne	r13,zero,99bc <tcp_input+0x5c4>
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
        pbuf_free(p);
    9970:	8809883a 	mov	r4,r17
    9974:	003ecf06 	br	94b4 <tcp_input+0xbc>
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
      return ERR_OK;
    }
  } else if (flags & TCP_FIN) {
    9978:	39c0004c 	andi	r7,r7,1
    997c:	383ffa26 	beq	r7,zero,9968 <tcp_input+0x570>
    /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
         Restart the 2 MSL time-wait timeout.*/
    pcb->tmr = tcp_ticks;
    9980:	00c000f4 	movhi	r3,3
    9984:	18eeba04 	addi	r3,r3,-17688
    9988:	18c00017 	ldw	r3,0(r3)
    998c:	10c00a15 	stw	r3,40(r2)
    9990:	003ff506 	br	9968 <tcp_input+0x570>
  if (flags & TCP_SYN) {
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
    9994:	6b7fffcc 	andi	r13,r13,65535
    9998:	d9800015 	stw	r6,0(sp)
    999c:	da000115 	stw	r8,4(sp)
    99a0:	694b883a 	add	r5,r13,r5
    99a4:	018000f4 	movhi	r6,3
    99a8:	31aeac04 	addi	r6,r6,-17744
    99ac:	01c000f4 	movhi	r7,3
    99b0:	39eeaa04 	addi	r7,r7,-17752
    99b4:	000c99c0 	call	c99c <tcp_rst>
    99b8:	003fed06 	br	9970 <tcp_input+0x578>
    pcb->tmr = tcp_ticks;
  }

  if ((tcplen > 0))  {
    /* Acknowledge data, FIN or out-of-window SYN */
    pcb->flags |= TF_ACK_NOW;
    99bc:	10c00883 	ldbu	r3,34(r2)
    return tcp_output(pcb);
    99c0:	1009883a 	mov	r4,r2
    pcb->tmr = tcp_ticks;
  }

  if ((tcplen > 0))  {
    /* Acknowledge data, FIN or out-of-window SYN */
    pcb->flags |= TF_ACK_NOW;
    99c4:	18c00094 	ori	r3,r3,2
    99c8:	10c00885 	stb	r3,34(r2)
    return tcp_output(pcb);
    99cc:	000c38c0 	call	c38c <tcp_output>
    99d0:	003fe706 	br	9970 <tcp_input+0x578>

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
    99d4:	010000b4 	movhi	r4,2
    99d8:	210d4b04 	addi	r4,r4,13612
    99dc:	014000b4 	movhi	r5,2
    99e0:	29564504 	addi	r5,r5,22804
    99e4:	01803184 	movi	r6,198
    99e8:	01c000b4 	movhi	r7,2
    99ec:	39d5b804 	addi	r7,r7,22240
    99f0:	00104380 	call	10438 <printf>
    99f4:	003fff06 	br	99f4 <tcp_input+0x5fc>
    }

    /* Finally, if we still did not get a match, we check all PCBs that
       are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    99f8:	020000f4 	movhi	r8,3
    99fc:	422ebb04 	addi	r8,r8,-17684
    9a00:	40c00017 	ldw	r3,0(r8)
    9a04:	18005726 	beq	r3,zero,9b64 <tcp_input+0x76c>
          /* found an ANY-match */
          lpcb_any = lpcb;
          lpcb_prev = prev;
        }
#else /* SO_REUSE */
        if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) ||
    9a08:	9a800017 	ldw	r10,0(r19)
    9a0c:	182b883a 	mov	r21,r3
      }
    }

    /* Finally, if we still did not get a match, we check all PCBs that
       are LISTENing for incoming connections. */
    prev = NULL;
    9a10:	0005883a 	mov	r2,zero
    9a14:	61bfffcc 	andi	r6,r12,65535
    9a18:	00000406 	br	9a2c <tcp_input+0x634>
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    9a1c:	aa400317 	ldw	r9,12(r21)
    9a20:	a805883a 	mov	r2,r21
    9a24:	48004f26 	beq	r9,zero,9b64 <tcp_input+0x76c>
    9a28:	482b883a 	mov	r21,r9
      if (lpcb->local_port == tcphdr->dest) {
    9a2c:	aa40078b 	ldhu	r9,30(r21)
    9a30:	327ffa1e 	bne	r6,r9,9a1c <tcp_input+0x624>
          /* found an ANY-match */
          lpcb_any = lpcb;
          lpcb_prev = prev;
        }
#else /* SO_REUSE */
        if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) ||
    9a34:	aa400017 	ldw	r9,0(r21)
    9a38:	4a800126 	beq	r9,r10,9a40 <tcp_input+0x648>
            ip_addr_isany(&(lpcb->local_ip))) {
    9a3c:	483ff71e 	bne	r9,zero,9a1c <tcp_input+0x624>
#endif /* SO_REUSE */
    if (lpcb != NULL) {
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      if (prev != NULL) {
    9a40:	10000426 	beq	r2,zero,9a54 <tcp_input+0x65c>
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
    9a44:	aa400317 	ldw	r9,12(r21)
              /* our successor is the remainder of the listening list */
        lpcb->next = tcp_listen_pcbs.listen_pcbs;
              /* put this listening pcb at the head of the listening list */
        tcp_listen_pcbs.listen_pcbs = lpcb;
    9a48:	45400015 	stw	r21,0(r8)
    if (lpcb != NULL) {
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      if (prev != NULL) {
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
    9a4c:	12400315 	stw	r9,12(r2)
              /* our successor is the remainder of the listening list */
        lpcb->next = tcp_listen_pcbs.listen_pcbs;
    9a50:	a8c00315 	stw	r3,12(r21)
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
  struct tcp_pcb *npcb;
  err_t rc;

  if (flags & TCP_RST) {
    9a54:	3880010c 	andi	r2,r7,4
    9a58:	10803fcc 	andi	r2,r2,255
    9a5c:	103fc41e 	bne	r2,zero,9970 <tcp_input+0x578>
    return ERR_OK;
  }

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    9a60:	3880040c 	andi	r2,r7,16
    9a64:	10803fcc 	andi	r2,r2,255
    9a68:	1000571e 	bne	r2,zero,9bc8 <tcp_input+0x7d0>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
      ip_current_src_addr(), tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
    9a6c:	3880008c 	andi	r2,r7,2
    9a70:	10803fcc 	andi	r2,r2,255
    9a74:	103fbe26 	beq	r2,zero,9970 <tcp_input+0x578>
    if (pcb->accepts_pending >= pcb->backlog) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: listen backlog exceeded for port %"U16_F"\n", tcphdr->dest));
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
    9a78:	a9000703 	ldbu	r4,28(r21)
    9a7c:	00089f40 	call	89f4 <tcp_alloc>
    9a80:	1025883a 	mov	r18,r2
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
    9a84:	10004c26 	beq	r2,zero,9bb8 <tcp_input+0x7c0>
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    npcb->local_port = pcb->local_port;
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    npcb->remote_port = tcphdr->src;
    9a88:	d0a8c317 	ldw	r2,-23796(gp)
    npcb->state = SYN_RCVD;
    npcb->rcv_nxt = seqno + 1;
    9a8c:	d128c417 	ldw	r4,-23792(gp)
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    npcb->local_port = pcb->local_port;
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    9a90:	00c000f4 	movhi	r3,3
    9a94:	18eeaa04 	addi	r3,r3,-17752
    npcb->remote_port = tcphdr->src;
    9a98:	11c0000b 	ldhu	r7,0(r2)
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    npcb->local_port = pcb->local_port;
    9a9c:	aa40078b 	ldhu	r9,30(r21)
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
    npcb->snd_wnd = tcphdr->wnd;
    npcb->snd_wnd_max = tcphdr->wnd;
    npcb->ssthresh = npcb->snd_wnd;
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
    npcb->callback_arg = pcb->callback_arg;
    9aa0:	a9800417 	ldw	r6,16(r21)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
    9aa4:	a9400517 	ldw	r5,20(r21)
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    npcb->remote_port = tcphdr->src;
    npcb->state = SYN_RCVD;
    npcb->rcv_nxt = seqno + 1;
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
    npcb->snd_wnd = tcphdr->wnd;
    9aa8:	1080038b 	ldhu	r2,14(r2)
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    npcb->local_port = pcb->local_port;
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    9aac:	1a000017 	ldw	r8,0(r3)
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    9ab0:	9a800017 	ldw	r10,0(r19)
    npcb->local_port = pcb->local_port;
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    npcb->remote_port = tcphdr->src;
    npcb->state = SYN_RCVD;
    npcb->rcv_nxt = seqno + 1;
    9ab4:	20c00044 	addi	r3,r4,1
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    npcb->local_port = pcb->local_port;
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    npcb->remote_port = tcphdr->src;
    9ab8:	91c0080d 	sth	r7,32(r18)
    npcb->rcv_nxt = seqno + 1;
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
    npcb->snd_wnd = tcphdr->wnd;
    npcb->snd_wnd_max = tcphdr->wnd;
    npcb->ssthresh = npcb->snd_wnd;
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
    9abc:	213fffc4 	addi	r4,r4,-1
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    npcb->local_port = pcb->local_port;
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    npcb->remote_port = tcphdr->src;
    npcb->state = SYN_RCVD;
    9ac0:	01c000c4 	movi	r7,3
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    9ac4:	92800015 	stw	r10,0(r18)
    npcb->local_port = pcb->local_port;
    9ac8:	9240078d 	sth	r9,30(r18)
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    9acc:	92000115 	stw	r8,4(r18)
    npcb->remote_port = tcphdr->src;
    npcb->state = SYN_RCVD;
    9ad0:	91c00615 	stw	r7,24(r18)
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
    npcb->snd_wnd = tcphdr->wnd;
    npcb->snd_wnd_max = tcphdr->wnd;
    npcb->ssthresh = npcb->snd_wnd;
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
    npcb->callback_arg = pcb->callback_arg;
    9ad4:	91800415 	stw	r6,16(r18)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
    9ad8:	91400515 	stw	r5,20(r18)
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    npcb->remote_port = tcphdr->src;
    npcb->state = SYN_RCVD;
    npcb->rcv_nxt = seqno + 1;
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
    npcb->snd_wnd = tcphdr->wnd;
    9adc:	9080190d 	sth	r2,100(r18)
    npcb->snd_wnd_max = tcphdr->wnd;
    9ae0:	9080198d 	sth	r2,102(r18)
    npcb->ssthresh = npcb->snd_wnd;
    9ae4:	9080148d 	sth	r2,82(r18)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
    9ae8:	91001615 	stw	r4,88(r18)
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    npcb->local_port = pcb->local_port;
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    npcb->remote_port = tcphdr->src;
    npcb->state = SYN_RCVD;
    npcb->rcv_nxt = seqno + 1;
    9aec:	90c00b15 	stw	r3,44(r18)
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
    9af0:	90c00d15 	stw	r3,52(r18)
    npcb->callback_arg = pcb->callback_arg;
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & SOF_INHERITED;
    9af4:	a8c00203 	ldbu	r3,8(r21)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG_ACTIVE(npcb);
    9af8:	a0800017 	ldw	r2,0(r20)
    9afc:	a4800015 	stw	r18,0(r20)
    npcb->callback_arg = pcb->callback_arg;
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & SOF_INHERITED;
    9b00:	18c0230c 	andi	r3,r3,140
    9b04:	90c00205 	stb	r3,8(r18)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG_ACTIVE(npcb);
    9b08:	90800315 	stw	r2,12(r18)
    9b0c:	000cfa80 	call	cfa8 <tcp_timer_needed>
    9b10:	00c00044 	movi	r3,1
    9b14:	008000f4 	movhi	r2,3
    9b18:	10aeb884 	addi	r2,r2,-17694

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
    9b1c:	9009883a 	mov	r4,r18
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & SOF_INHERITED;
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG_ACTIVE(npcb);
    9b20:	10c00005 	stb	r3,0(r2)

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
    9b24:	000a3ec0 	call	a3ec <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
    9b28:	91000e8b 	ldhu	r4,58(r18)
    9b2c:	91400104 	addi	r5,r18,4
    9b30:	000916c0 	call	916c <tcp_eff_send_mss>
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Send a SYN|ACK together with the MSS option. */
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
    9b34:	9009883a 	mov	r4,r18
    TCP_REG_ACTIVE(npcb);

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
    9b38:	90800e8d 	sth	r2,58(r18)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Send a SYN|ACK together with the MSS option. */
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
    9b3c:	01400484 	movi	r5,18
    9b40:	000bf740 	call	bf74 <tcp_enqueue_flags>
    if (rc != ERR_OK) {
    9b44:	10803fcc 	andi	r2,r2,255
    9b48:	1080201c 	xori	r2,r2,128
    9b4c:	10bfe004 	addi	r2,r2,-128
      tcp_abandon(npcb, 0);
    9b50:	9009883a 	mov	r4,r18

    snmp_inc_tcppassiveopens();

    /* Send a SYN|ACK together with the MSS option. */
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
    if (rc != ERR_OK) {
    9b54:	103f9d26 	beq	r2,zero,99cc <tcp_input+0x5d4>
      tcp_abandon(npcb, 0);
    9b58:	000b883a 	mov	r5,zero
    9b5c:	00088700 	call	8870 <tcp_abandon>
    9b60:	003f8306 	br	9970 <tcp_input+0x578>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
    9b64:	d8c0020b 	ldhu	r3,8(sp)
    9b68:	1880010c 	andi	r2,r3,4
    9b6c:	103f801e 	bne	r2,zero,9970 <tcp_input+0x578>
      TCP_STATS_INC(tcp.proterr);
    9b70:	80c0280b 	ldhu	r3,160(r16)
      TCP_STATS_INC(tcp.drop);
    9b74:	8080258b 	ldhu	r2,150(r16)
      tcp_rst(ackno, seqno + tcplen,
    9b78:	633fffcc 	andi	r12,r12,65535
    9b7c:	5affffcc 	andi	r11,r11,65535
    9b80:	db000015 	stw	r12,0(sp)
    9b84:	dac00115 	stw	r11,4(sp)
    9b88:	6b7fffcc 	andi	r13,r13,65535

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
    9b8c:	18c00044 	addi	r3,r3,1
      TCP_STATS_INC(tcp.drop);
    9b90:	10800044 	addi	r2,r2,1
      tcp_rst(ackno, seqno + tcplen,
    9b94:	694b883a 	add	r5,r13,r5
    9b98:	018000f4 	movhi	r6,3
    9b9c:	31aeac04 	addi	r6,r6,-17744
    9ba0:	01c000f4 	movhi	r7,3
    9ba4:	39eeaa04 	addi	r7,r7,-17752

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
    9ba8:	80c0280d 	sth	r3,160(r16)
      TCP_STATS_INC(tcp.drop);
    9bac:	8080258d 	sth	r2,150(r16)
      tcp_rst(ackno, seqno + tcplen,
    9bb0:	000c99c0 	call	c99c <tcp_rst>
    9bb4:	003f6e06 	br	9970 <tcp_input+0x578>
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
      TCP_STATS_INC(tcp.memerr);
    9bb8:	8080270b 	ldhu	r2,156(r16)
    9bbc:	10800044 	addi	r2,r2,1
    9bc0:	8080270d 	sth	r2,156(r16)
    9bc4:	003f6a06 	br	9970 <tcp_input+0x578>
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
    9bc8:	6b7fffcc 	andi	r13,r13,65535
    9bcc:	5affffcc 	andi	r11,r11,65535
    9bd0:	d9800015 	stw	r6,0(sp)
    9bd4:	dac00115 	stw	r11,4(sp)
    9bd8:	694b883a 	add	r5,r13,r5
    9bdc:	018000f4 	movhi	r6,3
    9be0:	31aeac04 	addi	r6,r6,-17744
    9be4:	01c000f4 	movhi	r7,3
    9be8:	39eeaa04 	addi	r7,r7,-17752
    9bec:	000c99c0 	call	c99c <tcp_rst>
    9bf0:	003f5f06 	br	9970 <tcp_input+0x578>
    if (pcb->refused_data != NULL) {
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
        ((pcb->refused_data != NULL) && (tcplen > 0))) {
        /* pcb has been aborted or refused data is still refused and the new
           segment contains data */
        TCP_STATS_INC(tcp.drop);
    9bf4:	8080258b 	ldhu	r2,150(r16)
    9bf8:	10800044 	addi	r2,r2,1
    9bfc:	8080258d 	sth	r2,150(r16)
        snmp_inc_tcpinerrs();
        goto aborted;
    9c00:	003f0306 	br	9810 <tcp_input+0x418>
      if (prev != NULL) {
        prev->next = pcb->next;
        pcb->next = tcp_active_pcbs;
        tcp_active_pcbs = pcb;
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
    9c04:	010000b4 	movhi	r4,2
    9c08:	210d4b04 	addi	r4,r4,13612
    9c0c:	014000b4 	movhi	r5,2
    9c10:	29563a04 	addi	r5,r5,22760
    9c14:	01802f04 	movi	r6,188
    9c18:	01c000b4 	movhi	r7,2
    9c1c:	39d5b804 	addi	r7,r7,22240
    9c20:	00104380 	call	10438 <printf>
    9c24:	003fff06 	br	9c24 <tcp_input+0x82c>
       ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
    9c28:	010000b4 	movhi	r4,2
    9c2c:	210d4b04 	addi	r4,r4,13612
    9c30:	014000b4 	movhi	r5,2
    9c34:	29562f04 	addi	r5,r5,22716
    9c38:	01802d84 	movi	r6,182
    9c3c:	01c000b4 	movhi	r7,2
    9c40:	39d5b804 	addi	r7,r7,22240
    9c44:	00104380 	call	10438 <printf>
    9c48:	003fff06 	br	9c48 <tcp_input+0x850>
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
        memp_free(MEMP_TCP_PCB, pcb);
      } else if (recv_flags & TF_CLOSED) {
    9c4c:	1080040c 	andi	r2,r2,16
    9c50:	10803fcc 	andi	r2,r2,255
    9c54:	10001526 	beq	r2,zero,9cac <tcp_input+0x8b4>
        /* The connection has been closed and we will deallocate the
           PCB. */
        if (!(pcb->flags & TF_RXCLOSED)) {
    9c58:	90800883 	ldbu	r2,34(r18)
    9c5c:	1080040c 	andi	r2,r2,16
    9c60:	10803fcc 	andi	r2,r2,255
    9c64:	103ee31e 	bne	r2,zero,97f4 <tcp_input+0x3fc>
          /* Connection closed although the application has only shut down the
             tx side: call the PCB's err callback and indicate the closure to
             ensure the application doesn't continue using the PCB. */
          TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
    9c68:	90802417 	ldw	r2,144(r18)
    9c6c:	103ee126 	beq	r2,zero,97f4 <tcp_input+0x3fc>
    9c70:	91000417 	ldw	r4,16(r18)
    9c74:	017ffd04 	movi	r5,-12
    9c78:	103ee83a 	callr	r2
    9c7c:	003edd06 	br	97f4 <tcp_input+0x3fc>

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
      if (ackno == pcb->snd_nxt) {
    9c80:	90c01517 	ldw	r3,84(r18)
    9c84:	d0a8c517 	ldw	r2,-23788(gp)
    9c88:	18bed11e 	bne	r3,r2,97d0 <tcp_input+0x3d8>

    if (acceptable) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
      recv_flags |= TF_RESET;
      pcb->flags &= ~TF_ACK_DELAY;
    9c8c:	91000883 	ldbu	r4,34(r18)
    }

    if (acceptable) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
      recv_flags |= TF_RESET;
    9c90:	d0e8c803 	ldbu	r3,-23776(gp)
      pcb->flags &= ~TF_ACK_DELAY;
    9c94:	21003f8c 	andi	r4,r4,254
    }

    if (acceptable) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
      recv_flags |= TF_RESET;
    9c98:	18c00214 	ori	r3,r3,8
    9c9c:	1805883a 	mov	r2,r3
    9ca0:	d0e8c805 	stb	r3,-23776(gp)
      pcb->flags &= ~TF_ACK_DELAY;
    9ca4:	91000885 	stb	r4,34(r18)
    9ca8:	003eca06 	br	97d4 <tcp_input+0x3dc>
      } else {
        err = ERR_OK;
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
    9cac:	91801a0b 	ldhu	r6,104(r18)
    9cb0:	30002c1e 	bne	r6,zero,9d64 <tcp_input+0x96c>
          if (err == ERR_ABRT) {
            goto aborted;
          }
        }

        if (recv_data != NULL) {
    9cb4:	d1a8c717 	ldw	r6,-23780(gp)
    9cb8:	30001d26 	beq	r6,zero,9d30 <tcp_input+0x938>
          LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
    9cbc:	90801f17 	ldw	r2,124(r18)
    9cc0:	10000926 	beq	r2,zero,9ce8 <tcp_input+0x8f0>
    9cc4:	010000b4 	movhi	r4,2
    9cc8:	210d4b04 	addi	r4,r4,13612
    9ccc:	014000b4 	movhi	r5,2
    9cd0:	29566404 	addi	r5,r5,22928
    9cd4:	01805504 	movi	r6,340
    9cd8:	01c000b4 	movhi	r7,2
    9cdc:	39d5b804 	addi	r7,r7,22240
    9ce0:	00104380 	call	10438 <printf>
    9ce4:	003fff06 	br	9ce4 <tcp_input+0x8ec>
          if (pcb->flags & TF_RXCLOSED) {
    9ce8:	90800883 	ldbu	r2,34(r18)
    9cec:	1080040c 	andi	r2,r2,16
    9cf0:	10803fcc 	andi	r2,r2,255
    9cf4:	1000721e 	bne	r2,zero,9ec0 <tcp_input+0xac8>
            tcp_abort(pcb);
            goto aborted;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
    9cf8:	90802117 	ldw	r2,132(r18)
    9cfc:	10006b26 	beq	r2,zero,9eac <tcp_input+0xab4>
    9d00:	91000417 	ldw	r4,16(r18)
    9d04:	900b883a 	mov	r5,r18
    9d08:	000f883a 	mov	r7,zero
    9d0c:	103ee83a 	callr	r2
          if (err == ERR_ABRT) {
    9d10:	10803fcc 	andi	r2,r2,255
    9d14:	1080201c 	xori	r2,r2,128
    9d18:	10bfe004 	addi	r2,r2,-128
    9d1c:	00fffd84 	movi	r3,-10
    9d20:	10febb26 	beq	r2,r3,9810 <tcp_input+0x418>
            goto aborted;
          }

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
    9d24:	10000226 	beq	r2,zero,9d30 <tcp_input+0x938>
            pcb->refused_data = recv_data;
    9d28:	d0a8c717 	ldw	r2,-23780(gp)
    9d2c:	90801f15 	stw	r2,124(r18)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
    9d30:	d0a8c803 	ldbu	r2,-23776(gp)
    9d34:	1080080c 	andi	r2,r2,32
    9d38:	10803fcc 	andi	r2,r2,255
    9d3c:	10000526 	beq	r2,zero,9d54 <tcp_input+0x95c>
          if (pcb->refused_data != NULL) {
    9d40:	90801f17 	ldw	r2,124(r18)
    9d44:	10001226 	beq	r2,zero,9d90 <tcp_input+0x998>
            /* Delay this if we have refused data. */
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
    9d48:	10c00343 	ldbu	r3,13(r2)
    9d4c:	18c00814 	ori	r3,r3,32
    9d50:	10c00345 	stb	r3,13(r2)
          }
        }

        tcp_input_pcb = NULL;
        /* Try to send something out. */
        tcp_output(pcb);
    9d54:	9009883a 	mov	r4,r18
              goto aborted;
            }
          }
        }

        tcp_input_pcb = NULL;
    9d58:	d028c915 	stw	zero,-23772(gp)
        /* Try to send something out. */
        tcp_output(pcb);
    9d5c:	000c38c0 	call	c38c <tcp_output>
    9d60:	003eab06 	br	9810 <tcp_input+0x418>
        err = ERR_OK;
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
          TCP_EVENT_SENT(pcb, pcb->acked, err);
    9d64:	90802017 	ldw	r2,128(r18)
    9d68:	103fd226 	beq	r2,zero,9cb4 <tcp_input+0x8bc>
    9d6c:	91000417 	ldw	r4,16(r18)
    9d70:	900b883a 	mov	r5,r18
    9d74:	103ee83a 	callr	r2
          if (err == ERR_ABRT) {
    9d78:	10803fcc 	andi	r2,r2,255
    9d7c:	1080201c 	xori	r2,r2,128
    9d80:	10bfe004 	addi	r2,r2,-128
    9d84:	00fffd84 	movi	r3,-10
    9d88:	10ffca1e 	bne	r2,r3,9cb4 <tcp_input+0x8bc>
    9d8c:	003ea006 	br	9810 <tcp_input+0x418>
            /* Delay this if we have refused data. */
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
          } else {
            /* correct rcv_wnd as the application won't call tcp_recved()
               for the FIN's seqno */
            if (pcb->rcv_wnd != TCP_WND) {
    9d90:	90800c0b 	ldhu	r2,48(r18)
    9d94:	00c20004 	movi	r3,2048
    9d98:	113fffcc 	andi	r4,r2,65535
    9d9c:	20c00226 	beq	r4,r3,9da8 <tcp_input+0x9b0>
              pcb->rcv_wnd++;
    9da0:	10800044 	addi	r2,r2,1
    9da4:	90800c0d 	sth	r2,48(r18)
            }
            TCP_EVENT_CLOSED(pcb, err);
    9da8:	90802117 	ldw	r2,132(r18)
    9dac:	103fe926 	beq	r2,zero,9d54 <tcp_input+0x95c>
    9db0:	91000417 	ldw	r4,16(r18)
    9db4:	900b883a 	mov	r5,r18
    9db8:	000d883a 	mov	r6,zero
    9dbc:	000f883a 	mov	r7,zero
    9dc0:	103ee83a 	callr	r2
            if (err == ERR_ABRT) {
    9dc4:	10803fcc 	andi	r2,r2,255
    9dc8:	1080201c 	xori	r2,r2,128
    9dcc:	10bfe004 	addi	r2,r2,-128
    9dd0:	00fffd84 	movi	r3,-10
    9dd4:	10ffdf1e 	bne	r2,r3,9d54 <tcp_input+0x95c>
    9dd8:	003e8d06 	br	9810 <tcp_input+0x418>
       seqno, pcb->rcv_nxt));
      return ERR_OK;
    }
  }

  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) { 
    9ddc:	ac00008c 	andi	r16,r21,2
    9de0:	84003fcc 	andi	r16,r16,255
    9de4:	80001326 	beq	r16,zero,9e34 <tcp_input+0xa3c>
    9de8:	90800617 	ldw	r2,24(r18)
    9dec:	00c00044 	movi	r3,1
    9df0:	10bfff84 	addi	r2,r2,-2
    9df4:	18800f2e 	bgeu	r3,r2,9e34 <tcp_input+0xa3c>
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
      if (err == ERR_ABRT) {
        return ERR_ABRT;
      }
      tcp_ack_now(pcb);
    9df8:	90c00883 	ldbu	r3,34(r18)
    9dfc:	d0a8c803 	ldbu	r2,-23776(gp)
    9e00:	18c00094 	ori	r3,r3,2
    9e04:	90c00885 	stb	r3,34(r18)
    9e08:	003e7206 	br	97d4 <tcp_input+0x3dc>
      }
    }

    if (acceptable) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
    9e0c:	103f9f1e 	bne	r2,zero,9c8c <tcp_input+0x894>
    9e10:	010000b4 	movhi	r4,2
    9e14:	210d4b04 	addi	r4,r4,13612
    9e18:	014000b4 	movhi	r5,2
    9e1c:	29565104 	addi	r5,r5,22852
    9e20:	018095c4 	movi	r6,599
    9e24:	01c000b4 	movhi	r7,2
    9e28:	39d5b804 	addi	r7,r7,22240
    9e2c:	00104380 	call	10438 <printf>
    9e30:	003fff06 	br	9e30 <tcp_input+0xa38>
    /* Cope with new connection attempt after remote end crashed */
    tcp_ack_now(pcb);
    return ERR_OK;
  }
  
  if ((pcb->flags & TF_RXCLOSED) == 0) {
    9e34:	90800883 	ldbu	r2,34(r18)
    9e38:	1080040c 	andi	r2,r2,16
    9e3c:	10803fcc 	andi	r2,r2,255
    9e40:	1000041e 	bne	r2,zero,9e54 <tcp_input+0xa5c>
    /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
    pcb->tmr = tcp_ticks;
    9e44:	008000f4 	movhi	r2,3
    9e48:	10aeba04 	addi	r2,r2,-17688
    9e4c:	10800017 	ldw	r2,0(r2)
    9e50:	90800a15 	stw	r2,40(r18)
  }
  pcb->keep_cnt_sent = 0;
    9e54:	90002685 	stb	zero,154(r18)

  tcp_parseopt(pcb);
    9e58:	9009883a 	mov	r4,r18
    9e5c:	000a3ec0 	call	a3ec <tcp_parseopt>

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
    9e60:	90800617 	ldw	r2,24(r18)
    9e64:	00c00244 	movi	r3,9
    9e68:	18be5936 	bltu	r3,r2,97d0 <tcp_input+0x3d8>
    9e6c:	100490ba 	slli	r2,r2,2
    9e70:	00c00074 	movhi	r3,1
    9e74:	18e7a104 	addi	r3,r3,-24956
    9e78:	10c5883a 	add	r2,r2,r3
    9e7c:	10800017 	ldw	r2,0(r2)
    9e80:	1000683a 	jmp	r2
    9e84:	000097d0 	cmplti	zero,zero,607
    9e88:	000097d0 	cmplti	zero,zero,607
    9e8c:	0000a1a0 	cmpeqi	zero,zero,646
    9e90:	0000a09c 	xori	zero,zero,642
    9e94:	0000a128 	cmpgeui	zero,zero,644
    9e98:	0000a028 	cmpgeui	zero,zero,640
    9e9c:	00009fac 	andhi	zero,zero,638
    9ea0:	0000a128 	cmpgeui	zero,zero,644
    9ea4:	00009f0c 	andi	zero,zero,636
    9ea8:	00009ed4 	movui	zero,635
            tcp_abort(pcb);
            goto aborted;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
    9eac:	0009883a 	mov	r4,zero
    9eb0:	900b883a 	mov	r5,r18
    9eb4:	000f883a 	mov	r7,zero
    9eb8:	0008f1c0 	call	8f1c <tcp_recv_null>
    9ebc:	003f9406 	br	9d10 <tcp_input+0x918>
        if (recv_data != NULL) {
          LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
          if (pcb->flags & TF_RXCLOSED) {
            /* received data although already closed -> abort (send RST) to
               notify the remote host that not all data has been processed */
            pbuf_free(recv_data);
    9ec0:	3009883a 	mov	r4,r6
    9ec4:	00067d80 	call	67d8 <pbuf_free>
            tcp_abort(pcb);
    9ec8:	9009883a 	mov	r4,r18
    9ecc:	00089ec0 	call	89ec <tcp_abort>
            goto aborted;
    9ed0:	003e4f06 	br	9810 <tcp_input+0x418>
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
  case LAST_ACK:
    tcp_receive(pcb);
    9ed4:	9009883a 	mov	r4,r18
    9ed8:	000a5900 	call	a590 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
    9edc:	d0a8c603 	ldbu	r2,-23784(gp)
    9ee0:	1080040c 	andi	r2,r2,16
    9ee4:	10803fcc 	andi	r2,r2,255
    9ee8:	103e3926 	beq	r2,zero,97d0 <tcp_input+0x3d8>
    9eec:	90c01517 	ldw	r3,84(r18)
    9ef0:	d0a8c517 	ldw	r2,-23788(gp)
    9ef4:	18be361e 	bne	r3,r2,97d0 <tcp_input+0x3d8>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags |= TF_CLOSED;
    9ef8:	d0e8c803 	ldbu	r3,-23776(gp)
    9efc:	18c00414 	ori	r3,r3,16
    9f00:	1805883a 	mov	r2,r3
    9f04:	d0e8c805 	stb	r3,-23776(gp)
    9f08:	003e3206 	br	97d4 <tcp_input+0x3dc>
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
  case CLOSING:
    tcp_receive(pcb);
    9f0c:	9009883a 	mov	r4,r18
    9f10:	000a5900 	call	a590 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
    9f14:	d0a8c603 	ldbu	r2,-23784(gp)
    9f18:	1080040c 	andi	r2,r2,16
    9f1c:	10803fcc 	andi	r2,r2,255
    9f20:	103e2b26 	beq	r2,zero,97d0 <tcp_input+0x3d8>
    9f24:	90c01517 	ldw	r3,84(r18)
    9f28:	d0a8c517 	ldw	r2,-23788(gp)
    9f2c:	18be281e 	bne	r3,r2,97d0 <tcp_input+0x3d8>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
    9f30:	9009883a 	mov	r4,r18
    9f34:	00080e00 	call	80e0 <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
    9f38:	a0c00017 	ldw	r3,0(r20)
    9f3c:	90c03326 	beq	r18,r3,a00c <tcp_input+0xc14>
    9f40:	008000f4 	movhi	r2,3
    9f44:	10aebc04 	addi	r2,r2,-17680
    9f48:	10c00015 	stw	r3,0(r2)
    9f4c:	18000926 	beq	r3,zero,9f74 <tcp_input+0xb7c>
    9f50:	19000317 	ldw	r4,12(r3)
    9f54:	91000526 	beq	r18,r4,9f6c <tcp_input+0xb74>
    9f58:	2007883a 	mov	r3,r4
    9f5c:	20003026 	beq	r4,zero,a020 <tcp_input+0xc28>
    9f60:	19000317 	ldw	r4,12(r3)
    9f64:	913ffc1e 	bne	r18,r4,9f58 <tcp_input+0xb60>
    9f68:	10c00015 	stw	r3,0(r2)
    9f6c:	90800317 	ldw	r2,12(r18)
    9f70:	18800315 	stw	r2,12(r3)
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    9f74:	008000f4 	movhi	r2,3
    9f78:	10aebe04 	addi	r2,r2,-17672
    9f7c:	10c00017 	ldw	r3,0(r2)
    tcp_receive(pcb);
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      pcb->state = TIME_WAIT;
    9f80:	01000284 	movi	r4,10
    9f84:	91000615 	stw	r4,24(r18)
      TCP_REG(&tcp_tw_pcbs, pcb);
    9f88:	90c00315 	stw	r3,12(r18)
  case CLOSING:
    tcp_receive(pcb);
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
    9f8c:	01000044 	movi	r4,1
    9f90:	00c000f4 	movhi	r3,3
    9f94:	18eeb884 	addi	r3,r3,-17694
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    9f98:	14800015 	stw	r18,0(r2)
  case CLOSING:
    tcp_receive(pcb);
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
    9f9c:	19000005 	stb	r4,0(r3)
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    9fa0:	000cfa80 	call	cfa8 <tcp_timer_needed>
    9fa4:	d0a8c803 	ldbu	r2,-23776(gp)
    9fa8:	003e0a06 	br	97d4 <tcp_input+0x3dc>
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
  case FIN_WAIT_2:
    tcp_receive(pcb);
    9fac:	9009883a 	mov	r4,r18
    9fb0:	000a5900 	call	a590 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
    9fb4:	d0a8c803 	ldbu	r2,-23776(gp)
    9fb8:	10c0080c 	andi	r3,r2,32
    9fbc:	18c03fcc 	andi	r3,r3,255
    9fc0:	183e0426 	beq	r3,zero,97d4 <tcp_input+0x3dc>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
    9fc4:	90800883 	ldbu	r2,34(r18)
      tcp_pcb_purge(pcb);
    9fc8:	9009883a 	mov	r4,r18
    break;
  case FIN_WAIT_2:
    tcp_receive(pcb);
    if (recv_flags & TF_GOT_FIN) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
    9fcc:	10800094 	ori	r2,r2,2
    9fd0:	90800885 	stb	r2,34(r18)
      tcp_pcb_purge(pcb);
    9fd4:	00080e00 	call	80e0 <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
    9fd8:	a0c00017 	ldw	r3,0(r20)
    9fdc:	90c00b26 	beq	r18,r3,a00c <tcp_input+0xc14>
    9fe0:	008000f4 	movhi	r2,3
    9fe4:	10aebc04 	addi	r2,r2,-17680
    9fe8:	10c00015 	stw	r3,0(r2)
    9fec:	183fe126 	beq	r3,zero,9f74 <tcp_input+0xb7c>
    9ff0:	19000317 	ldw	r4,12(r3)
    9ff4:	913fdd26 	beq	r18,r4,9f6c <tcp_input+0xb74>
    9ff8:	2007883a 	mov	r3,r4
    9ffc:	20000826 	beq	r4,zero,a020 <tcp_input+0xc28>
    a000:	19000317 	ldw	r4,12(r3)
    a004:	913ffc1e 	bne	r18,r4,9ff8 <tcp_input+0xc00>
    a008:	003fd706 	br	9f68 <tcp_input+0xb70>
  case CLOSING:
    tcp_receive(pcb);
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
    a00c:	90c00317 	ldw	r3,12(r18)
    a010:	008000f4 	movhi	r2,3
    a014:	10aeb904 	addi	r2,r2,-17692
    a018:	10c00015 	stw	r3,0(r2)
    a01c:	003fd506 	br	9f74 <tcp_input+0xb7c>
    a020:	10000015 	stw	zero,0(r2)
    a024:	003fd306 	br	9f74 <tcp_input+0xb7c>
      tcp_ack_now(pcb);
      pcb->state = CLOSE_WAIT;
    }
    break;
  case FIN_WAIT_1:
    tcp_receive(pcb);
    a028:	9009883a 	mov	r4,r18
    a02c:	000a5900 	call	a590 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
    a030:	d0a8c803 	ldbu	r2,-23776(gp)
    a034:	10c0080c 	andi	r3,r2,32
    a038:	18c03fcc 	andi	r3,r3,255
    a03c:	18000d26 	beq	r3,zero,a074 <tcp_input+0xc7c>
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
    a040:	d0e8c603 	ldbu	r3,-23784(gp)
    a044:	18c0040c 	andi	r3,r3,16
    a048:	18c03fcc 	andi	r3,r3,255
    a04c:	18000326 	beq	r3,zero,a05c <tcp_input+0xc64>
    a050:	91001517 	ldw	r4,84(r18)
    a054:	d0e8c517 	ldw	r3,-23788(gp)
    a058:	20c03f26 	beq	r4,r3,a158 <tcp_input+0xd60>
        tcp_pcb_purge(pcb);
        TCP_RMV_ACTIVE(pcb);
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
    a05c:	90c00883 	ldbu	r3,34(r18)
        pcb->state = CLOSING;
    a060:	01000204 	movi	r4,8
    a064:	91000615 	stw	r4,24(r18)
        tcp_pcb_purge(pcb);
        TCP_RMV_ACTIVE(pcb);
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
    a068:	18c00094 	ori	r3,r3,2
    a06c:	90c00885 	stb	r3,34(r18)
    a070:	003dd806 	br	97d4 <tcp_input+0x3dc>
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
    a074:	d0e8c603 	ldbu	r3,-23784(gp)
    a078:	18c0040c 	andi	r3,r3,16
    a07c:	18c03fcc 	andi	r3,r3,255
    a080:	183dd426 	beq	r3,zero,97d4 <tcp_input+0x3dc>
    a084:	91001517 	ldw	r4,84(r18)
    a088:	d0e8c517 	ldw	r3,-23788(gp)
    a08c:	20fdd11e 	bne	r4,r3,97d4 <tcp_input+0x3dc>
      pcb->state = FIN_WAIT_2;
    a090:	00c00184 	movi	r3,6
    a094:	90c00615 	stw	r3,24(r18)
    a098:	003dce06 	br	97d4 <tcp_input+0x3dc>
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK) {
    a09c:	a880040c 	andi	r2,r21,16
    a0a0:	10803fcc 	andi	r2,r2,255
    a0a4:	10001726 	beq	r2,zero,a104 <tcp_input+0xd0c>
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
    a0a8:	90801317 	ldw	r2,76(r18)
    a0ac:	d128c517 	ldw	r4,-23788(gp)
    a0b0:	0084303a 	nor	r2,zero,r2
    a0b4:	1105883a 	add	r2,r2,r4
    a0b8:	10000316 	blt	r2,zero,a0c8 <tcp_input+0xcd0>
    a0bc:	90801517 	ldw	r2,84(r18)
    a0c0:	2085c83a 	sub	r2,r4,r2
    a0c4:	00804c0e 	bge	zero,r2,a1f8 <tcp_input+0xe00>
          pcb->state = CLOSE_WAIT;
        }
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
                tcphdr->dest, tcphdr->src);
    a0c8:	d0a8c317 	ldw	r2,-23796(gp)
          tcp_ack_now(pcb);
          pcb->state = CLOSE_WAIT;
        }
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
    a0cc:	d1a8c68b 	ldhu	r6,-23782(gp)
    a0d0:	d168c417 	ldw	r5,-23792(gp)
    a0d4:	10c0008b 	ldhu	r3,2(r2)
    a0d8:	01c000f4 	movhi	r7,3
    a0dc:	39eeaa04 	addi	r7,r7,-17752
    a0e0:	314b883a 	add	r5,r6,r5
    a0e4:	d8c00015 	stw	r3,0(sp)
    a0e8:	1080000b 	ldhu	r2,0(r2)
    a0ec:	018000f4 	movhi	r6,3
    a0f0:	31aeac04 	addi	r6,r6,-17744
    a0f4:	d8800115 	stw	r2,4(sp)
    a0f8:	000c99c0 	call	c99c <tcp_rst>
    a0fc:	d0a8c803 	ldbu	r2,-23776(gp)
    a100:	003db406 	br	97d4 <tcp_input+0x3dc>
                tcphdr->dest, tcphdr->src);
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
    a104:	803db226 	beq	r16,zero,97d0 <tcp_input+0x3d8>
    a108:	90c00b17 	ldw	r3,44(r18)
    a10c:	d0a8c417 	ldw	r2,-23792(gp)
    a110:	18ffffc4 	addi	r3,r3,-1
    a114:	18bdae1e 	bne	r3,r2,97d0 <tcp_input+0x3d8>
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    a118:	9009883a 	mov	r4,r18
    a11c:	000cbb80 	call	cbb8 <tcp_rexmit>
    a120:	d0a8c803 	ldbu	r2,-23776(gp)
    a124:	003dab06 	br	97d4 <tcp_input+0x3dc>
    }
    break;
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    tcp_receive(pcb);
    a128:	9009883a 	mov	r4,r18
    a12c:	000a5900 	call	a590 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) { /* passive close */
    a130:	d0a8c803 	ldbu	r2,-23776(gp)
    a134:	10c0080c 	andi	r3,r2,32
    a138:	18c03fcc 	andi	r3,r3,255
    a13c:	183da526 	beq	r3,zero,97d4 <tcp_input+0x3dc>
      tcp_ack_now(pcb);
    a140:	90c00883 	ldbu	r3,34(r18)
      pcb->state = CLOSE_WAIT;
    a144:	010001c4 	movi	r4,7
    a148:	91000615 	stw	r4,24(r18)
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    tcp_receive(pcb);
    if (recv_flags & TF_GOT_FIN) { /* passive close */
      tcp_ack_now(pcb);
    a14c:	18c00094 	ori	r3,r3,2
    a150:	90c00885 	stb	r3,34(r18)
    a154:	003d9f06 	br	97d4 <tcp_input+0x3dc>
    tcp_receive(pcb);
    if (recv_flags & TF_GOT_FIN) {
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
    a158:	90800883 	ldbu	r2,34(r18)
        tcp_pcb_purge(pcb);
    a15c:	9009883a 	mov	r4,r18
    tcp_receive(pcb);
    if (recv_flags & TF_GOT_FIN) {
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
    a160:	10800094 	ori	r2,r2,2
    a164:	90800885 	stb	r2,34(r18)
        tcp_pcb_purge(pcb);
    a168:	00080e00 	call	80e0 <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
    a16c:	a0c00017 	ldw	r3,0(r20)
    a170:	90ffa626 	beq	r18,r3,a00c <tcp_input+0xc14>
    a174:	008000f4 	movhi	r2,3
    a178:	10aebc04 	addi	r2,r2,-17680
    a17c:	10c00015 	stw	r3,0(r2)
    a180:	183f7c26 	beq	r3,zero,9f74 <tcp_input+0xb7c>
    a184:	19000317 	ldw	r4,12(r3)
    a188:	24bf7826 	beq	r4,r18,9f6c <tcp_input+0xb74>
    a18c:	2007883a 	mov	r3,r4
    a190:	203fa326 	beq	r4,zero,a020 <tcp_input+0xc28>
    a194:	19000317 	ldw	r4,12(r3)
    a198:	913ffc1e 	bne	r18,r4,a18c <tcp_input+0xd94>
    a19c:	003f7206 	br	9f68 <tcp_input+0xb70>
  switch (pcb->state) {
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
    a1a0:	a8c0048c 	andi	r3,r21,18
    a1a4:	00800484 	movi	r2,18
    a1a8:	18802226 	beq	r3,r2,a234 <tcp_input+0xe3c>
        return ERR_ABRT;
      }
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
    a1ac:	a880040c 	andi	r2,r21,16
    a1b0:	10803fcc 	andi	r2,r2,255
    a1b4:	103d8626 	beq	r2,zero,97d0 <tcp_input+0x3d8>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
    a1b8:	d0a8c317 	ldw	r2,-23796(gp)
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
    a1bc:	d168c68b 	ldhu	r5,-23782(gp)
    a1c0:	d128c517 	ldw	r4,-23788(gp)
    a1c4:	10c0008b 	ldhu	r3,2(r2)
    a1c8:	018000f4 	movhi	r6,3
    a1cc:	31aeac04 	addi	r6,r6,-17744
    a1d0:	01c000f4 	movhi	r7,3
    a1d4:	39eeaa04 	addi	r7,r7,-17752
    a1d8:	d8c00015 	stw	r3,0(sp)
    a1dc:	1080000b 	ldhu	r2,0(r2)
    a1e0:	d0e8c417 	ldw	r3,-23792(gp)
    a1e4:	d8800115 	stw	r2,4(sp)
    a1e8:	28cb883a 	add	r5,r5,r3
    a1ec:	000c99c0 	call	c99c <tcp_rst>
    a1f0:	d0a8c803 	ldbu	r2,-23776(gp)
    a1f4:	003d7706 	br	97d4 <tcp_input+0x3dc>
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
    a1f8:	90800517 	ldw	r2,20(r18)
  case SYN_RCVD:
    if (flags & TCP_ACK) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
    a1fc:	00c00104 	movi	r3,4
    a200:	90c00615 	stw	r3,24(r18)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
    a204:	10006d26 	beq	r2,zero,a3bc <tcp_input+0xfc4>
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
    a208:	91000417 	ldw	r4,16(r18)
    a20c:	900b883a 	mov	r5,r18
    a210:	000d883a 	mov	r6,zero
    a214:	103ee83a 	callr	r2
        if (err != ERR_OK) {
    a218:	10803fcc 	andi	r2,r2,255
    a21c:	1080201c 	xori	r2,r2,128
    a220:	10bfe004 	addi	r2,r2,-128
    a224:	10005226 	beq	r2,zero,a370 <tcp_input+0xf78>
          /* If the accept function returns with an error, we abort
           * the connection. */
          /* Already aborted? */
          if (err != ERR_ABRT) {
    a228:	00fffd84 	movi	r3,-10
    a22c:	10ff261e 	bne	r2,r3,9ec8 <tcp_input+0xad0>
    a230:	003d7706 	br	9810 <tcp_input+0x418>
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
    a234:	90801d17 	ldw	r2,116(r18)
    a238:	10800317 	ldw	r2,12(r2)
    a23c:	10c0018b 	ldhu	r3,6(r2)
    a240:	1080010b 	ldhu	r2,4(r2)
    a244:	1806943a 	slli	r3,r3,16
    a248:	1884b03a 	or	r2,r3,r2
    a24c:	100a963a 	slli	r5,r2,24
    a250:	1008d63a 	srli	r4,r2,24
    a254:	1006d23a 	srli	r3,r2,8
    a258:	10bfc00c 	andi	r2,r2,65280
    a25c:	1004923a 	slli	r2,r2,8
    a260:	2908b03a 	or	r4,r5,r4
    a264:	18ffc00c 	andi	r3,r3,65280
    a268:	20c6b03a 	or	r3,r4,r3
    a26c:	1886b03a 	or	r3,r3,r2
    a270:	d0a8c517 	ldw	r2,-23788(gp)
    a274:	18c00044 	addi	r3,r3,1
    a278:	18bfcc1e 	bne	r3,r2,a1ac <tcp_input+0xdb4>
      pcb->snd_buf++;
      pcb->rcv_nxt = seqno + 1;
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
      pcb->lastack = ackno;
      pcb->snd_wnd = tcphdr->wnd;
    a27c:	d0a8c317 	ldw	r2,-23796(gp)
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
    a280:	91c01a8b 	ldhu	r7,106(r18)
      pcb->rcv_nxt = seqno + 1;
    a284:	d1a8c417 	ldw	r6,-23792(gp)
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
      pcb->lastack = ackno;
      pcb->snd_wnd = tcphdr->wnd;
    a288:	1080038b 	ldhu	r2,14(r2)
      pcb->snd_wnd_max = tcphdr->wnd;
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
      pcb->state = ESTABLISHED;

#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
    a28c:	91000e8b 	ldhu	r4,58(r18)
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
      pcb->rcv_nxt = seqno + 1;
    a290:	31400044 	addi	r5,r6,1
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
    a294:	39c00044 	addi	r7,r7,1
      pcb->rcv_nxt = seqno + 1;
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
      pcb->lastack = ackno;
      pcb->snd_wnd = tcphdr->wnd;
      pcb->snd_wnd_max = tcphdr->wnd;
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
    a298:	31bfffc4 	addi	r6,r6,-1
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
      pcb->rcv_nxt = seqno + 1;
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
      pcb->lastack = ackno;
      pcb->snd_wnd = tcphdr->wnd;
    a29c:	9080190d 	sth	r2,100(r18)
      pcb->snd_wnd_max = tcphdr->wnd;
    a2a0:	9080198d 	sth	r2,102(r18)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
      pcb->state = ESTABLISHED;
    a2a4:	00800104 	movi	r2,4
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
      pcb->rcv_nxt = seqno + 1;
    a2a8:	91400b15 	stw	r5,44(r18)
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
    a2ac:	91400d15 	stw	r5,52(r18)
      pcb->lastack = ackno;
    a2b0:	90c01315 	stw	r3,76(r18)
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
    a2b4:	91c01a8d 	sth	r7,106(r18)
      pcb->rcv_nxt = seqno + 1;
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
      pcb->lastack = ackno;
      pcb->snd_wnd = tcphdr->wnd;
      pcb->snd_wnd_max = tcphdr->wnd;
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
    a2b8:	91801615 	stw	r6,88(r18)
      pcb->state = ESTABLISHED;
    a2bc:	90800615 	stw	r2,24(r18)

#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
    a2c0:	908b883a 	add	r5,r18,r2
    a2c4:	000916c0 	call	916c <tcp_eff_send_mss>
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
    a2c8:	10c002a4 	muli	r3,r2,10

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
    a2cc:	9100140b 	ldhu	r4,80(r18)
      pcb->snd_wnd_max = tcphdr->wnd;
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
      pcb->state = ESTABLISHED;

#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
    a2d0:	90800e8d 	sth	r2,58(r18)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
    a2d4:	90c0148d 	sth	r3,82(r18)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
    a2d8:	00c00044 	movi	r3,1
    a2dc:	20c0011e 	bne	r4,r3,a2e4 <tcp_input+0xeec>
    a2e0:	1085883a 	add	r2,r2,r2
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
    a2e4:	90c01b0b 	ldhu	r3,108(r18)

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
    a2e8:	9080140d 	sth	r2,80(r18)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
    a2ec:	18bfffcc 	andi	r2,r3,65535
    a2f0:	1000091e 	bne	r2,zero,a318 <tcp_input+0xf20>
    a2f4:	010000b4 	movhi	r4,2
    a2f8:	210d4b04 	addi	r4,r4,13612
    a2fc:	014000b4 	movhi	r5,2
    a300:	29565904 	addi	r5,r5,22884
    a304:	0180a304 	movi	r6,652
    a308:	01c000b4 	movhi	r7,2
    a30c:	39d5b804 	addi	r7,r7,22240
    a310:	00104380 	call	10438 <printf>
    a314:	003fff06 	br	a314 <tcp_input+0xf1c>
      --pcb->snd_queuelen;
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
    a318:	91001d17 	ldw	r4,116(r18)
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
      --pcb->snd_queuelen;
    a31c:	18ffffc4 	addi	r3,r3,-1
    a320:	90c01b0d 	sth	r3,108(r18)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
      pcb->unacked = rseg->next;
    a324:	20800017 	ldw	r2,0(r4)
    a328:	90801d15 	stw	r2,116(r18)
      tcp_seg_free(rseg);
    a32c:	0007ed80 	call	7ed8 <tcp_seg_free>

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
    a330:	90801d17 	ldw	r2,116(r18)
    a334:	10002a26 	beq	r2,zero,a3e0 <tcp_input+0xfe8>
        pcb->rtime = -1;
      else {
        pcb->rtime = 0;
    a338:	90000e0d 	sth	zero,56(r18)
        pcb->nrtx = 0;
    a33c:	90001285 	stb	zero,74(r18)
      }

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
    a340:	90802217 	ldw	r2,136(r18)
    a344:	103eac26 	beq	r2,zero,9df8 <tcp_input+0xa00>
    a348:	91000417 	ldw	r4,16(r18)
    a34c:	900b883a 	mov	r5,r18
    a350:	000d883a 	mov	r6,zero
    a354:	103ee83a 	callr	r2
      if (err == ERR_ABRT) {
    a358:	10803fcc 	andi	r2,r2,255
    a35c:	1080201c 	xori	r2,r2,128
    a360:	10bfe004 	addi	r2,r2,-128
    a364:	00fffd84 	movi	r3,-10
    a368:	10fea31e 	bne	r2,r3,9df8 <tcp_input+0xa00>
    a36c:	003d2806 	br	9810 <tcp_input+0x418>
          return ERR_ABRT;
        }
        old_cwnd = pcb->cwnd;
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        tcp_receive(pcb);
    a370:	9009883a 	mov	r4,r18
          if (err != ERR_ABRT) {
            tcp_abort(pcb);
          }
          return ERR_ABRT;
        }
        old_cwnd = pcb->cwnd;
    a374:	9400140b 	ldhu	r16,80(r18)
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        tcp_receive(pcb);
    a378:	000a5900 	call	a590 <tcp_receive>

        /* Prevent ACK for SYN to generate a sent event */
        if (pcb->acked != 0) {
    a37c:	90801a0b 	ldhu	r2,104(r18)
    a380:	10ffffcc 	andi	r3,r2,65535
    a384:	18000226 	beq	r3,zero,a390 <tcp_input+0xf98>
          pcb->acked--;
    a388:	10bfffc4 	addi	r2,r2,-1
    a38c:	90801a0d 	sth	r2,104(r18)
        }

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
    a390:	843fffcc 	andi	r16,r16,65535
    a394:	00800044 	movi	r2,1
    a398:	90c00e8b 	ldhu	r3,58(r18)
    a39c:	8080011e 	bne	r16,r2,a3a4 <tcp_input+0xfac>
    a3a0:	18c7883a 	add	r3,r3,r3

        if (recv_flags & TF_GOT_FIN) {
    a3a4:	d0a8c803 	ldbu	r2,-23776(gp)
        /* Prevent ACK for SYN to generate a sent event */
        if (pcb->acked != 0) {
          pcb->acked--;
        }

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
    a3a8:	90c0140d 	sth	r3,80(r18)

        if (recv_flags & TF_GOT_FIN) {
    a3ac:	10c0080c 	andi	r3,r2,32
    a3b0:	18c03fcc 	andi	r3,r3,255
    a3b4:	183d0726 	beq	r3,zero,97d4 <tcp_input+0x3dc>
    a3b8:	003f6106 	br	a140 <tcp_input+0xd48>
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
    a3bc:	010000b4 	movhi	r4,2
    a3c0:	210d4b04 	addi	r4,r4,13612
    a3c4:	014000b4 	movhi	r5,2
    a3c8:	29565f04 	addi	r5,r5,22908
    a3cc:	0180acc4 	movi	r6,691
    a3d0:	01c000b4 	movhi	r7,2
    a3d4:	39d5b804 	addi	r7,r7,22240
    a3d8:	00104380 	call	10438 <printf>
    a3dc:	003fff06 	br	a3dc <tcp_input+0xfe4>
      tcp_seg_free(rseg);

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
        pcb->rtime = -1;
    a3e0:	00bfffc4 	movi	r2,-1
    a3e4:	90800e0d 	sth	r2,56(r18)
    a3e8:	003fd506 	br	a340 <tcp_input+0xf48>

0000a3ec <tcp_parseopt>:
  u8_t *opts, opt;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  opts = (u8_t *)tcphdr + TCP_HLEN;
    a3ec:	d268c317 	ldw	r9,-23796(gp)

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    a3f0:	00800144 	movi	r2,5
    a3f4:	49c0030b 	ldhu	r7,12(r9)
    a3f8:	380ed13a 	srli	r7,r7,4
    a3fc:	39c003cc 	andi	r7,r7,15
    a400:	11c02a0e 	bge	r2,r7,a4ac <tcp_parseopt+0xc0>
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    a404:	39fffec4 	addi	r7,r7,-5
    a408:	39cf883a 	add	r7,r7,r7
    a40c:	39cf883a 	add	r7,r7,r7
  u8_t *opts, opt;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  opts = (u8_t *)tcphdr + TCP_HLEN;
    a410:	4a400504 	addi	r9,r9,20

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    for (c = 0; c < max_c; ) {
    a414:	000d883a 	mov	r6,zero
    a418:	39ffffcc 	andi	r7,r7,65535
      opt = opts[c];
      switch (opt) {
    a41c:	02000044 	movi	r8,1
    a420:	02c00084 	movi	r11,2
        ++c;
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
        break;
      case 0x02:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
        if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
    a424:	03000104 	movi	r12,4
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
    a428:	03416cc4 	movi	r13,1459
  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    for (c = 0; c < max_c; ) {
    a42c:	00001d06 	br	a4a4 <tcp_parseopt+0xb8>
      opt = opts[c];
    a430:	488b883a 	add	r5,r9,r2
      switch (opt) {
    a434:	28c00003 	ldbu	r3,0(r5)
    a438:	1a000426 	beq	r3,r8,a44c <tcp_parseopt+0x60>
    a43c:	18001b26 	beq	r3,zero,a4ac <tcp_parseopt+0xc0>
    a440:	2a800044 	addi	r10,r5,1
    a444:	1ac0121e 	bne	r3,r11,a490 <tcp_parseopt+0xa4>
    a448:	00000206 	br	a454 <tcp_parseopt+0x68>
        /* End of options. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
        return;
      case 0x01:
        /* NOP option. */
        ++c;
    a44c:	31800044 	addi	r6,r6,1
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
        break;
    a450:	00001406 	br	a4a4 <tcp_parseopt+0xb8>
      case 0x02:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
        if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
    a454:	50c00003 	ldbu	r3,0(r10)
    a458:	1b00141e 	bne	r3,r12,a4ac <tcp_parseopt+0xc0>
    a45c:	108000c4 	addi	r2,r2,3
    a460:	11c0120e 	bge	r2,r7,a4ac <tcp_parseopt+0xc0>
          /* Bad length */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
    a464:	28800083 	ldbu	r2,2(r5)
    a468:	28c000c3 	ldbu	r3,3(r5)
    a46c:	1004923a 	slli	r2,r2,8
    a470:	10c4b03a 	or	r2,r2,r3
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
    a474:	10ffffc4 	addi	r3,r2,-1
    a478:	18ffffcc 	andi	r3,r3,65535
    a47c:	68c0012e 	bgeu	r13,r3,a484 <tcp_parseopt+0x98>
    a480:	00816d04 	movi	r2,1460
    a484:	20800e8d 	sth	r2,58(r4)
        /* Advance to next option */
        c += 0x04;
    a488:	31800104 	addi	r6,r6,4
        break;
    a48c:	00000506 	br	a4a4 <tcp_parseopt+0xb8>
        c += 0x0A;
        break;
#endif
      default:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        if (opts[c + 1] == 0) {
    a490:	50800003 	ldbu	r2,0(r10)
    a494:	10c03fcc 	andi	r3,r2,255
    a498:	18000426 	beq	r3,zero,a4ac <tcp_parseopt+0xc0>
             and we don't process them further. */
          return;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
    a49c:	10803fcc 	andi	r2,r2,255
    a4a0:	118d883a 	add	r6,r2,r6
  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    for (c = 0; c < max_c; ) {
    a4a4:	30bfffcc 	andi	r2,r6,65535
    a4a8:	11ffe136 	bltu	r2,r7,a430 <tcp_parseopt+0x44>
    a4ac:	f800283a 	ret

0000a4b0 <tcp_oos_insert_segment>:
static void
tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
{
  struct tcp_seg *old_seg;

  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
    a4b0:	20800317 	ldw	r2,12(r4)
 *
 * Called from tcp_receive()
 */
static void
tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
{
    a4b4:	defffd04 	addi	sp,sp,-12
    a4b8:	dc400115 	stw	r17,4(sp)
  struct tcp_seg *old_seg;

  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
    a4bc:	1080030b 	ldhu	r2,12(r2)
 *
 * Called from tcp_receive()
 */
static void
tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
{
    a4c0:	dc000015 	stw	r16,0(sp)
    a4c4:	dfc00215 	stw	ra,8(sp)
  struct tcp_seg *old_seg;

  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
    a4c8:	1004d23a 	srli	r2,r2,8
 *
 * Called from tcp_receive()
 */
static void
tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
{
    a4cc:	2023883a 	mov	r17,r4
    a4d0:	2821883a 	mov	r16,r5
  struct tcp_seg *old_seg;

  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
    a4d4:	1080004c 	andi	r2,r2,1
    a4d8:	10000e26 	beq	r2,zero,a514 <tcp_oos_insert_segment+0x64>
    /* received segment overlaps all following segments */
    tcp_segs_free(next);
    a4dc:	2809883a 	mov	r4,r5
    a4e0:	0007f200 	call	7f20 <tcp_segs_free>
    next = NULL;
    a4e4:	0021883a 	mov	r16,zero
    a4e8:	00001e06 	br	a564 <tcp_oos_insert_segment+0xb4>
       oos queue may have segments with FIN flag */
    while (next &&
           TCP_SEQ_GEQ((seqno + cseg->len),
                      (next->tcphdr->seqno + next->len))) {
      /* cseg with FIN already processed */
      if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
    a4ec:	1080030b 	ldhu	r2,12(r2)
    a4f0:	1004d23a 	srli	r2,r2,8
    a4f4:	1080004c 	andi	r2,r2,1
    a4f8:	10000426 	beq	r2,zero,a50c <tcp_oos_insert_segment+0x5c>
        TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
    a4fc:	88800317 	ldw	r2,12(r17)
    a500:	10c0030b 	ldhu	r3,12(r2)
    a504:	18c04014 	ori	r3,r3,256
    a508:	10c0030d 	sth	r3,12(r2)
      }
      old_seg = next;
      next = next->next;
    a50c:	84000017 	ldw	r16,0(r16)
      tcp_seg_free(old_seg);
    a510:	0007ed80 	call	7ed8 <tcp_seg_free>
    a514:	8009883a 	mov	r4,r16
    next = NULL;
  }
  else {
    /* delete some following segments
       oos queue may have segments with FIN flag */
    while (next &&
    a518:	80001226 	beq	r16,zero,a564 <tcp_oos_insert_segment+0xb4>
           TCP_SEQ_GEQ((seqno + cseg->len),
    a51c:	80800317 	ldw	r2,12(r16)
    a520:	8980020b 	ldhu	r6,8(r17)
    a524:	d168c417 	ldw	r5,-23792(gp)
    a528:	10c0018b 	ldhu	r3,6(r2)
    a52c:	11c0010b 	ldhu	r7,4(r2)
    a530:	8200020b 	ldhu	r8,8(r16)
    a534:	1806943a 	slli	r3,r3,16
    a538:	19c6b03a 	or	r3,r3,r7
    a53c:	30cfc83a 	sub	r7,r6,r3
    a540:	394f883a 	add	r7,r7,r5
    a544:	3a0fc83a 	sub	r7,r7,r8
    next = NULL;
  }
  else {
    /* delete some following segments
       oos queue may have segments with FIN flag */
    while (next &&
    a548:	383fe80e 	bge	r7,zero,a4ec <tcp_oos_insert_segment+0x3c>
    a54c:	00000706 	br	a56c <tcp_oos_insert_segment+0xbc>
    }
    if (next &&
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
      /* We need to trim the incoming segment. */
      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
      pbuf_realloc(cseg->p, cseg->len);
    a550:	89000117 	ldw	r4,4(r17)
      tcp_seg_free(old_seg);
    }
    if (next &&
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
      /* We need to trim the incoming segment. */
      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
    a554:	194bc83a 	sub	r5,r3,r5
    a558:	8940020d 	sth	r5,8(r17)
      pbuf_realloc(cseg->p, cseg->len);
    a55c:	297fffcc 	andi	r5,r5,65535
    a560:	00069140 	call	6914 <pbuf_realloc>
    }
  }
  cseg->next = next;
    a564:	8c000015 	stw	r16,0(r17)
    a568:	00000406 	br	a57c <tcp_oos_insert_segment+0xcc>
      old_seg = next;
      next = next->next;
      tcp_seg_free(old_seg);
    }
    if (next &&
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
    a56c:	314d883a 	add	r6,r6,r5
    a570:	30cdc83a 	sub	r6,r6,r3
      }
      old_seg = next;
      next = next->next;
      tcp_seg_free(old_seg);
    }
    if (next &&
    a574:	01bff616 	blt	zero,r6,a550 <tcp_oos_insert_segment+0xa0>
    a578:	003ffa06 	br	a564 <tcp_oos_insert_segment+0xb4>
      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
      pbuf_realloc(cseg->p, cseg->len);
    }
  }
  cseg->next = next;
}
    a57c:	dfc00217 	ldw	ra,8(sp)
    a580:	dc400117 	ldw	r17,4(sp)
    a584:	dc000017 	ldw	r16,0(sp)
    a588:	dec00304 	addi	sp,sp,12
    a58c:	f800283a 	ret

0000a590 <tcp_receive>:
#if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
  u32_t ooseq_blen;
  u16_t ooseq_qlen;
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */

  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
    a590:	20800617 	ldw	r2,24(r4)
 *
 * Called from tcp_process().
 */
static void
tcp_receive(struct tcp_pcb *pcb)
{
    a594:	defffb04 	addi	sp,sp,-20
    a598:	dc000015 	stw	r16,0(sp)
    a59c:	dfc00415 	stw	ra,16(sp)
    a5a0:	dcc00315 	stw	r19,12(sp)
    a5a4:	dc800215 	stw	r18,8(sp)
    a5a8:	dc400115 	stw	r17,4(sp)
#if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
  u32_t ooseq_blen;
  u16_t ooseq_qlen;
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */

  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
    a5ac:	00c000c4 	movi	r3,3
 *
 * Called from tcp_process().
 */
static void
tcp_receive(struct tcp_pcb *pcb)
{
    a5b0:	2021883a 	mov	r16,r4
#if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
  u32_t ooseq_blen;
  u16_t ooseq_qlen;
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */

  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
    a5b4:	18800936 	bltu	r3,r2,a5dc <tcp_receive+0x4c>
    a5b8:	010000b4 	movhi	r4,2
    a5bc:	210d4b04 	addi	r4,r4,13612
    a5c0:	014000b4 	movhi	r5,2
    a5c4:	2955b104 	addi	r5,r5,22212
    a5c8:	0180d804 	movi	r6,864
    a5cc:	01c000b4 	movhi	r7,2
    a5d0:	39d5b804 	addi	r7,r7,22240
    a5d4:	00104380 	call	10438 <printf>
    a5d8:	003fff06 	br	a5d8 <tcp_receive+0x48>

  if (flags & TCP_ACK) {
    a5dc:	d0a8c603 	ldbu	r2,-23784(gp)
    a5e0:	1080040c 	andi	r2,r2,16
    a5e4:	10803fcc 	andi	r2,r2,255
    a5e8:	10013426 	beq	r2,zero,aabc <tcp_receive+0x52c>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
    a5ec:	20c01617 	ldw	r3,88(r4)
    a5f0:	d168c417 	ldw	r5,-23792(gp)
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */

  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
    a5f4:	2180190b 	ldhu	r6,100(r4)
    a5f8:	d0a8c517 	ldw	r2,-23788(gp)

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
    a5fc:	194fc83a 	sub	r7,r3,r5
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */

  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
    a600:	21001717 	ldw	r4,92(r4)

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
    a604:	38000816 	blt	r7,zero,a628 <tcp_receive+0x98>
    a608:	1940021e 	bne	r3,r5,a614 <tcp_receive+0x84>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
    a60c:	2087c83a 	sub	r3,r4,r2
    a610:	18000516 	blt	r3,zero,a628 <tcp_receive+0x98>
    a614:	2080171e 	bne	r4,r2,a674 <tcp_receive+0xe4>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
    a618:	d0e8c317 	ldw	r3,-23796(gp)
    a61c:	31ffffcc 	andi	r7,r6,65535
    a620:	18c0038b 	ldhu	r3,14(r3)
    a624:	38c0132e 	bgeu	r7,r3,a674 <tcp_receive+0xe4>
      pcb->snd_wnd = tcphdr->wnd;
    a628:	d0e8c317 	ldw	r3,-23796(gp)
      /* keep track of the biggest window announced by the remote host to calculate
         the maximum segment size */
      if (pcb->snd_wnd_max < tcphdr->wnd) {
    a62c:	8200198b 	ldhu	r8,102(r16)

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
      pcb->snd_wnd = tcphdr->wnd;
    a630:	18c0038b 	ldhu	r3,14(r3)
    a634:	80c0190d 	sth	r3,100(r16)
      /* keep track of the biggest window announced by the remote host to calculate
         the maximum segment size */
      if (pcb->snd_wnd_max < tcphdr->wnd) {
    a638:	19ffffcc 	andi	r7,r3,65535
    a63c:	41c0012e 	bgeu	r8,r7,a644 <tcp_receive+0xb4>
        pcb->snd_wnd_max = tcphdr->wnd;
    a640:	80c0198d 	sth	r3,102(r16)
      }
      pcb->snd_wl1 = seqno;
    a644:	81401615 	stw	r5,88(r16)
      pcb->snd_wl2 = ackno;
    a648:	80801715 	stw	r2,92(r16)
      if (pcb->snd_wnd == 0) {
    a64c:	18ffffcc 	andi	r3,r3,65535
    a650:	81402643 	ldbu	r5,153(r16)
    a654:	1800051e 	bne	r3,zero,a66c <tcp_receive+0xdc>
        if (pcb->persist_backoff == 0) {
    a658:	2800061e 	bne	r5,zero,a674 <tcp_receive+0xe4>
          /* start persist timer */
          pcb->persist_cnt = 0;
          pcb->persist_backoff = 1;
    a65c:	00c00044 	movi	r3,1
      pcb->snd_wl1 = seqno;
      pcb->snd_wl2 = ackno;
      if (pcb->snd_wnd == 0) {
        if (pcb->persist_backoff == 0) {
          /* start persist timer */
          pcb->persist_cnt = 0;
    a660:	80002605 	stb	zero,152(r16)
          pcb->persist_backoff = 1;
    a664:	80c02645 	stb	r3,153(r16)
    a668:	00000206 	br	a674 <tcp_receive+0xe4>
        }
      } else if (pcb->persist_backoff > 0) {
    a66c:	28000126 	beq	r5,zero,a674 <tcp_receive+0xe4>
        /* stop persist timer */
          pcb->persist_backoff = 0;
    a670:	80002645 	stb	zero,153(r16)
     * If it only passes 1, should reset dupack counter
     *
     */

    /* Clause 1 */
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
    a674:	80c01317 	ldw	r3,76(r16)
    a678:	10cbc83a 	sub	r5,r2,r3
    a67c:	01402016 	blt	zero,r5,a700 <tcp_receive+0x170>
      pcb->acked = 0;
      /* Clause 2 */
      if (tcplen == 0) {
    a680:	d168c68b 	ldhu	r5,-23782(gp)
     *
     */

    /* Clause 1 */
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
      pcb->acked = 0;
    a684:	80001a0d 	sth	zero,104(r16)
      /* Clause 2 */
      if (tcplen == 0) {
    a688:	2803411e 	bne	r5,zero,b390 <tcp_receive+0xe00>
        /* Clause 3 */
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
    a68c:	81c0190b 	ldhu	r7,100(r16)
    a690:	81401717 	ldw	r5,92(r16)
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */

  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
    a694:	31bfffcc 	andi	r6,r6,65535
    a698:	3109883a 	add	r4,r6,r4
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
      pcb->acked = 0;
      /* Clause 2 */
      if (tcplen == 0) {
        /* Clause 3 */
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
    a69c:	394b883a 	add	r5,r7,r5
    a6a0:	29033b1e 	bne	r5,r4,b390 <tcp_receive+0xe00>
          /* Clause 4 */
          if (pcb->rtime >= 0) {
    a6a4:	81000e0f 	ldh	r4,56(r16)
    a6a8:	20033916 	blt	r4,zero,b390 <tcp_receive+0xe00>
            /* Clause 5 */
            if (pcb->lastack == ackno) {
    a6ac:	10c3381e 	bne	r2,r3,b390 <tcp_receive+0xe00>
              found_dupack = 1;
              if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
    a6b0:	80c012c3 	ldbu	r3,75(r16)
    a6b4:	18800044 	addi	r2,r3,1
    a6b8:	11003fcc 	andi	r4,r2,255
    a6bc:	1900012e 	bgeu	r3,r4,a6c4 <tcp_receive+0x134>
                ++pcb->dupacks;
    a6c0:	808012c5 	stb	r2,75(r16)
              }
              if (pcb->dupacks > 3) {
    a6c4:	80c012c3 	ldbu	r3,75(r16)
    a6c8:	008000c4 	movi	r2,3
    a6cc:	10c0082e 	bgeu	r2,r3,a6f0 <tcp_receive+0x160>
                /* Inflate the congestion window, but not if it means that
                   the value overflows. */
                if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
    a6d0:	8080140b 	ldhu	r2,80(r16)
    a6d4:	80c00e8b 	ldhu	r3,58(r16)
    a6d8:	1009883a 	mov	r4,r2
    a6dc:	10c5883a 	add	r2,r2,r3
    a6e0:	10ffffcc 	andi	r3,r2,65535
    a6e4:	20c0b12e 	bgeu	r4,r3,a9ac <tcp_receive+0x41c>
                  pcb->cwnd += pcb->mss;
    a6e8:	8080140d 	sth	r2,80(r16)
    a6ec:	0000af06 	br	a9ac <tcp_receive+0x41c>
                }
              } else if (pcb->dupacks == 3) {
    a6f0:	1880ae1e 	bne	r3,r2,a9ac <tcp_receive+0x41c>
                /* Do fast retransmit */
                tcp_rexmit_fast(pcb);
    a6f4:	8009883a 	mov	r4,r16
    a6f8:	000cc880 	call	cc88 <tcp_rexmit_fast>
    a6fc:	0000ab06 	br	a9ac <tcp_receive+0x41c>
      /* If Clause (1) or more is true, but not a duplicate ack, reset
       * count of consecutive duplicate acks */
      if (!found_dupack) {
        pcb->dupacks = 0;
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)){
    a700:	00c8303a 	nor	r4,zero,r3
    a704:	2089883a 	add	r4,r4,r2
    a708:	20007316 	blt	r4,zero,a8d8 <tcp_receive+0x348>
    a70c:	81001517 	ldw	r4,84(r16)
    a710:	1109c83a 	sub	r4,r2,r4
    a714:	01007016 	blt	zero,r4,a8d8 <tcp_receive+0x348>
      /* We come here when the ACK acknowledges new data. */

      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
    a718:	81000883 	ldbu	r4,34(r16)
    a71c:	2140010c 	andi	r5,r4,4
    a720:	29403fcc 	andi	r5,r5,255
    a724:	28000426 	beq	r5,zero,a738 <tcp_receive+0x1a8>
        pcb->flags &= ~TF_INFR;
        pcb->cwnd = pcb->ssthresh;
    a728:	8140148b 	ldhu	r5,82(r16)

      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
        pcb->flags &= ~TF_INFR;
    a72c:	21003ecc 	andi	r4,r4,251
    a730:	81000885 	stb	r4,34(r16)
        pcb->cwnd = pcb->ssthresh;
    a734:	8140140d 	sth	r5,80(r16)

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
    a738:	8200110f 	ldh	r8,68(r16)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);

      pcb->snd_buf += pcb->acked;
    a73c:	81801a8b 	ldhu	r6,106(r16)

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
    a740:	81c0118b 	ldhu	r7,70(r16)
    a744:	4011d0fa 	srai	r8,r8,3
      pcb->lastack = ackno;

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
        if (pcb->cwnd < pcb->ssthresh) {
    a748:	8100140b 	ldhu	r4,80(r16)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
    a74c:	10c7c83a 	sub	r3,r2,r3
      pcb->lastack = ackno;

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
        if (pcb->cwnd < pcb->ssthresh) {
    a750:	8140148b 	ldhu	r5,82(r16)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);

      pcb->snd_buf += pcb->acked;
    a754:	198d883a 	add	r6,r3,r6

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
    a758:	41cf883a 	add	r7,r8,r7

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
    a75c:	80c01a0d 	sth	r3,104(r16)

      pcb->snd_buf += pcb->acked;

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
      pcb->lastack = ackno;
    a760:	80801315 	stw	r2,76(r16)
        pcb->flags &= ~TF_INFR;
        pcb->cwnd = pcb->ssthresh;
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
    a764:	80001285 	stb	zero,74(r16)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
    a768:	81c0120d 	sth	r7,72(r16)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);

      pcb->snd_buf += pcb->acked;
    a76c:	81801a8d 	sth	r6,106(r16)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
    a770:	800012c5 	stb	zero,75(r16)
      pcb->lastack = ackno;

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
        if (pcb->cwnd < pcb->ssthresh) {
    a774:	20bfffcc 	andi	r2,r4,65535
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
    a778:	80c00e8b 	ldhu	r3,58(r16)
      pcb->lastack = ackno;

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
        if (pcb->cwnd < pcb->ssthresh) {
    a77c:	1140012e 	bgeu	r2,r5,a784 <tcp_receive+0x1f4>
    a780:	00000206 	br	a78c <tcp_receive+0x1fc>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
            pcb->cwnd += pcb->mss;
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
    a784:	18c7383a 	mul	r3,r3,r3
    a788:	1887283a 	div	r3,r3,r2
    a78c:	1909883a 	add	r4,r3,r4
          if (new_cwnd > pcb->cwnd) {
    a790:	20ffffcc 	andi	r3,r4,65535
    a794:	10c0332e 	bgeu	r2,r3,a864 <tcp_receive+0x2d4>
            pcb->cwnd = new_cwnd;
    a798:	8100140d 	sth	r4,80(r16)
    a79c:	00003106 	br	a864 <tcp_receive+0x2d4>
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
        pcb->unacked = pcb->unacked->next;
    a7a0:	88800017 	ldw	r2,0(r17)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
    a7a4:	89000117 	ldw	r4,4(r17)
    a7a8:	84801b0b 	ldhu	r18,108(r16)
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
        pcb->unacked = pcb->unacked->next;
    a7ac:	80801d15 	stw	r2,116(r16)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
    a7b0:	0006dd40 	call	6dd4 <pbuf_clen>
    a7b4:	10803fcc 	andi	r2,r2,255
    a7b8:	9080092e 	bgeu	r18,r2,a7e0 <tcp_receive+0x250>
    a7bc:	010000b4 	movhi	r4,2
    a7c0:	210d4b04 	addi	r4,r4,13612
    a7c4:	014000b4 	movhi	r5,2
    a7c8:	2955be04 	addi	r5,r5,22264
    a7cc:	0180ff04 	movi	r6,1020
    a7d0:	01c000b4 	movhi	r7,2
    a7d4:	39d5b804 	addi	r7,r7,22240
    a7d8:	00104380 	call	10438 <printf>
    a7dc:	003fff06 	br	a7dc <tcp_receive+0x24c>
        /* Prevent ACK for FIN to generate a sent event */
        if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
    a7e0:	80801a0b 	ldhu	r2,104(r16)
    a7e4:	10ffffcc 	andi	r3,r2,65535
    a7e8:	18000726 	beq	r3,zero,a808 <tcp_receive+0x278>
    a7ec:	88c00317 	ldw	r3,12(r17)
          pcb->acked--;
    a7f0:	10bfffc4 	addi	r2,r2,-1
        pcb->unacked = pcb->unacked->next;

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
        /* Prevent ACK for FIN to generate a sent event */
        if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
    a7f4:	18c0030b 	ldhu	r3,12(r3)
    a7f8:	1806d23a 	srli	r3,r3,8
    a7fc:	18c0004c 	andi	r3,r3,1
    a800:	18000126 	beq	r3,zero,a808 <tcp_receive+0x278>
          pcb->acked--;
    a804:	80801a0d 	sth	r2,104(r16)
        }

        pcb->snd_queuelen -= pbuf_clen(next->p);
    a808:	89000117 	ldw	r4,4(r17)
    a80c:	84801b0b 	ldhu	r18,108(r16)
    a810:	0006dd40 	call	6dd4 <pbuf_clen>
    a814:	10803fcc 	andi	r2,r2,255
    a818:	90a5c83a 	sub	r18,r18,r2
    a81c:	84801b0d 	sth	r18,108(r16)
        tcp_seg_free(next);
    a820:	8809883a 	mov	r4,r17
    a824:	0007ed80 	call	7ed8 <tcp_seg_free>

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
    a828:	80801b0b 	ldhu	r2,108(r16)
    a82c:	10000d26 	beq	r2,zero,a864 <tcp_receive+0x2d4>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
    a830:	80801d17 	ldw	r2,116(r16)
    a834:	10000b1e 	bne	r2,zero,a864 <tcp_receive+0x2d4>
    a838:	80801c17 	ldw	r2,112(r16)
    a83c:	1000091e 	bne	r2,zero,a864 <tcp_receive+0x2d4>
    a840:	010000b4 	movhi	r4,2
    a844:	210d4b04 	addi	r4,r4,13612
    a848:	014000b4 	movhi	r5,2
    a84c:	2955c804 	addi	r5,r5,22304
    a850:	01810204 	movi	r6,1032
    a854:	01c000b4 	movhi	r7,2
    a858:	39d5b804 	addi	r7,r7,22240
    a85c:	00104380 	call	10438 <printf>
    a860:	003fff06 	br	a860 <tcp_receive+0x2d0>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
    a864:	84401d17 	ldw	r17,116(r16)
    a868:	8802cb26 	beq	r17,zero,b398 <tcp_receive+0xe08>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
    a86c:	88c00317 	ldw	r3,12(r17)
    a870:	8900020b 	ldhu	r4,8(r17)
    a874:	1940018b 	ldhu	r5,6(r3)
    a878:	1880010b 	ldhu	r2,4(r3)
    a87c:	1980030b 	ldhu	r6,12(r3)
    a880:	2806943a 	slli	r3,r5,16
    a884:	300cd23a 	srli	r6,r6,8
    a888:	1884b03a 	or	r2,r3,r2
    a88c:	1010963a 	slli	r8,r2,24
    a890:	100ad63a 	srli	r5,r2,24
    a894:	100ed23a 	srli	r7,r2,8
    a898:	10bfc00c 	andi	r2,r2,65280
    a89c:	1006923a 	slli	r3,r2,8
    a8a0:	414ab03a 	or	r5,r8,r5
    a8a4:	38bfc00c 	andi	r2,r7,65280
    a8a8:	288ab03a 	or	r5,r5,r2
    a8ac:	28cab03a 	or	r5,r5,r3
    a8b0:	d0e8c517 	ldw	r3,-23788(gp)
    a8b4:	308000cc 	andi	r2,r6,3
    a8b8:	1004c03a 	cmpne	r2,r2,zero
    a8bc:	28c7c83a 	sub	r3,r5,r3
    a8c0:	2085883a 	add	r2,r4,r2
    a8c4:	1885883a 	add	r2,r3,r2
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
    a8c8:	00bfb50e 	bge	zero,r2,a7a0 <tcp_receive+0x210>
    a8cc:	0002b506 	br	b3a4 <tcp_receive+0xe14>
      if(pcb->unacked == NULL)
        pcb->rtime = -1;
      else
        pcb->rtime = 0;

      pcb->polltmr = 0;
    a8d0:	800008c5 	stb	zero,35(r16)
    a8d4:	00003506 	br	a9ac <tcp_receive+0x41c>
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
    a8d8:	80001a0d 	sth	zero,104(r16)
    a8dc:	00003306 	br	a9ac <tcp_receive+0x41c>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
      pcb->unsent = pcb->unsent->next;
    a8e0:	88800017 	ldw	r2,0(r17)
    a8e4:	80801c15 	stw	r2,112(r16)
#if TCP_OVERSIZE
      if (pcb->unsent == NULL) {
    a8e8:	1000011e 	bne	r2,zero,a8f0 <tcp_receive+0x360>
        pcb->unsent_oversize = 0;
    a8ec:	80001b8d 	sth	zero,110(r16)
      }
#endif /* TCP_OVERSIZE */ 
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
    a8f0:	89000117 	ldw	r4,4(r17)
    a8f4:	84801b0b 	ldhu	r18,108(r16)
    a8f8:	0006dd40 	call	6dd4 <pbuf_clen>
    a8fc:	10803fcc 	andi	r2,r2,255
    a900:	9080092e 	bgeu	r18,r2,a928 <tcp_receive+0x398>
    a904:	010000b4 	movhi	r4,2
    a908:	210d4b04 	addi	r4,r4,13612
    a90c:	014000b4 	movhi	r5,2
    a910:	2955be04 	addi	r5,r5,22264
    a914:	01810b84 	movi	r6,1070
    a918:	01c000b4 	movhi	r7,2
    a91c:	39d5b804 	addi	r7,r7,22240
    a920:	00104380 	call	10438 <printf>
    a924:	003fff06 	br	a924 <tcp_receive+0x394>
      /* Prevent ACK for FIN to generate a sent event */
      if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
    a928:	80801a0b 	ldhu	r2,104(r16)
    a92c:	10ffffcc 	andi	r3,r2,65535
    a930:	18000726 	beq	r3,zero,a950 <tcp_receive+0x3c0>
    a934:	88c00317 	ldw	r3,12(r17)
    a938:	18c0030b 	ldhu	r3,12(r3)
    a93c:	1806d23a 	srli	r3,r3,8
    a940:	18c0004c 	andi	r3,r3,1
    a944:	18000226 	beq	r3,zero,a950 <tcp_receive+0x3c0>
        pcb->acked--;
    a948:	10bfffc4 	addi	r2,r2,-1
    a94c:	80801a0d 	sth	r2,104(r16)
      }
      pcb->snd_queuelen -= pbuf_clen(next->p);
    a950:	89000117 	ldw	r4,4(r17)
    a954:	84801b0b 	ldhu	r18,108(r16)
    a958:	0006dd40 	call	6dd4 <pbuf_clen>
    a95c:	10803fcc 	andi	r2,r2,255
    a960:	90a5c83a 	sub	r18,r18,r2
    a964:	84801b0d 	sth	r18,108(r16)
      tcp_seg_free(next);
    a968:	8809883a 	mov	r4,r17
    a96c:	0007ed80 	call	7ed8 <tcp_seg_free>
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
    a970:	80801b0b 	ldhu	r2,108(r16)
    a974:	10000d26 	beq	r2,zero,a9ac <tcp_receive+0x41c>
        LWIP_ASSERT("tcp_receive: valid queue length",
    a978:	80801d17 	ldw	r2,116(r16)
    a97c:	10000b1e 	bne	r2,zero,a9ac <tcp_receive+0x41c>
    a980:	80801c17 	ldw	r2,112(r16)
    a984:	1000091e 	bne	r2,zero,a9ac <tcp_receive+0x41c>
    a988:	010000b4 	movhi	r4,2
    a98c:	210d4b04 	addi	r4,r4,13612
    a990:	014000b4 	movhi	r5,2
    a994:	2955c804 	addi	r5,r5,22304
    a998:	01810e04 	movi	r6,1080
    a99c:	01c000b4 	movhi	r7,2
    a9a0:	39d5b804 	addi	r7,r7,22240
    a9a4:	00104380 	call	10438 <printf>
    a9a8:	003fff06 	br	a9a8 <tcp_receive+0x418>
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
    a9ac:	84401c17 	ldw	r17,112(r16)
    a9b0:	88001b26 	beq	r17,zero,aa20 <tcp_receive+0x490>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
    a9b4:	88c00317 	ldw	r3,12(r17)
    a9b8:	d128c517 	ldw	r4,-23788(gp)
    a9bc:	8940020b 	ldhu	r5,8(r17)
    a9c0:	1980018b 	ldhu	r6,6(r3)
    a9c4:	1880010b 	ldhu	r2,4(r3)
    a9c8:	19c0030b 	ldhu	r7,12(r3)
    a9cc:	3006943a 	slli	r3,r6,16
    a9d0:	380ed23a 	srli	r7,r7,8
    a9d4:	1884b03a 	or	r2,r3,r2
    a9d8:	1012963a 	slli	r9,r2,24
    a9dc:	100cd63a 	srli	r6,r2,24
    a9e0:	1010d23a 	srli	r8,r2,8
    a9e4:	10bfc00c 	andi	r2,r2,65280
    a9e8:	1006923a 	slli	r3,r2,8
    a9ec:	498cb03a 	or	r6,r9,r6
    a9f0:	40bfc00c 	andi	r2,r8,65280
    a9f4:	308cb03a 	or	r6,r6,r2
    a9f8:	388000cc 	andi	r2,r7,3
    a9fc:	30c6b03a 	or	r3,r6,r3
    aa00:	1004c03a 	cmpne	r2,r2,zero
    aa04:	20c7c83a 	sub	r3,r4,r3
    aa08:	2885883a 	add	r2,r5,r2
    aa0c:	1885c83a 	sub	r2,r3,r2
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
    aa10:	10000316 	blt	r2,zero,aa20 <tcp_receive+0x490>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
    aa14:	80801517 	ldw	r2,84(r16)
    aa18:	2089c83a 	sub	r4,r4,r2
    aa1c:	013fb00e 	bge	zero,r4,a8e0 <tcp_receive+0x350>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
    aa20:	80800f17 	ldw	r2,60(r16)
    aa24:	10002526 	beq	r2,zero,aabc <tcp_receive+0x52c>
    aa28:	81001017 	ldw	r4,64(r16)
    aa2c:	d0e8c517 	ldw	r3,-23788(gp)
    aa30:	20c7c83a 	sub	r3,r4,r3
    aa34:	1800210e 	bge	r3,zero,aabc <tcp_receive+0x52c>

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
    aa38:	8100110b 	ldhu	r4,68(r16)
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
    aa3c:	00c000f4 	movhi	r3,3
    aa40:	18eeba04 	addi	r3,r3,-17688
    aa44:	19400017 	ldw	r5,0(r3)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
    aa48:	20ffffcc 	andi	r3,r4,65535
    aa4c:	18e0001c 	xori	r3,r3,32768
    aa50:	18e00004 	addi	r3,r3,-32768
    aa54:	1807d0fa 	srai	r3,r3,3
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
    aa58:	2885c83a 	sub	r2,r5,r2

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
    aa5c:	10c7c83a 	sub	r3,r2,r3
    aa60:	1805883a 	mov	r2,r3
      pcb->sa += m;
      if (m < 0) {
    aa64:	117fffcc 	andi	r5,r2,65535
      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
      pcb->sa += m;
    aa68:	1909883a 	add	r4,r3,r4
      if (m < 0) {
    aa6c:	2960001c 	xori	r5,r5,32768
      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
      pcb->sa += m;
    aa70:	8100110d 	sth	r4,68(r16)
      if (m < 0) {
    aa74:	29600004 	addi	r5,r5,-32768
    aa78:	2800010e 	bge	r5,zero,aa80 <tcp_receive+0x4f0>
        m = -m;
    aa7c:	00c5c83a 	sub	r2,zero,r3
      }
      m = m - (pcb->sv >> 2);
    aa80:	80c0118b 	ldhu	r3,70(r16)
      pcb->sv += m;
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
    aa84:	213fffcc 	andi	r4,r4,65535
    aa88:	2120001c 	xori	r4,r4,32768
      m = m - (pcb->sa >> 3);
      pcb->sa += m;
      if (m < 0) {
        m = -m;
      }
      m = m - (pcb->sv >> 2);
    aa8c:	197fffcc 	andi	r5,r3,65535
    aa90:	2960001c 	xori	r5,r5,32768
    aa94:	29600004 	addi	r5,r5,-32768
    aa98:	280bd0ba 	srai	r5,r5,2
      pcb->sv += m;
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
    aa9c:	21200004 	addi	r4,r4,-32768
    aaa0:	2009d0fa 	srai	r4,r4,3
      m = m - (pcb->sa >> 3);
      pcb->sa += m;
      if (m < 0) {
        m = -m;
      }
      m = m - (pcb->sv >> 2);
    aaa4:	1947c83a 	sub	r3,r3,r5
      pcb->sv += m;
    aaa8:	1885883a 	add	r2,r3,r2
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
    aaac:	1107883a 	add	r3,r2,r4

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
    aab0:	80000f15 	stw	zero,60(r16)
      pcb->sa += m;
      if (m < 0) {
        m = -m;
      }
      m = m - (pcb->sv >> 2);
      pcb->sv += m;
    aab4:	8080118d 	sth	r2,70(r16)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
    aab8:	80c0120d 	sth	r3,72(r16)

  /* If the incoming segment contains data, we must process it
     further unless the pcb already received a FIN.
     (RFC 793, chapeter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
     LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
  if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
    aabc:	d128c68b 	ldhu	r4,-23782(gp)
    aac0:	d0e8c417 	ldw	r3,-23792(gp)
    aac4:	80800b17 	ldw	r2,44(r16)
    aac8:	20022626 	beq	r4,zero,b364 <tcp_receive+0xdd4>
    aacc:	81400617 	ldw	r5,24(r16)
    aad0:	01800184 	movi	r6,6
    aad4:	31422336 	bltu	r6,r5,b364 <tcp_receive+0xdd4>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
    aad8:	00ca303a 	nor	r5,zero,r3
    aadc:	288b883a 	add	r5,r5,r2
    aae0:	28005f16 	blt	r5,zero,ac60 <tcp_receive+0x6d0>
    aae4:	11400044 	addi	r5,r2,1
    aae8:	28cbc83a 	sub	r5,r5,r3
    aaec:	2909c83a 	sub	r4,r5,r4
    aaf0:	01005b16 	blt	zero,r4,ac60 <tcp_receive+0x6d0>
         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
      p = inseg.p;
    aaf4:	04400134 	movhi	r17,4
    aaf8:	8c67c004 	addi	r17,r17,-24832
    aafc:	89000117 	ldw	r4,4(r17)

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
    ab00:	10c5c83a 	sub	r2,r2,r3
      p = inseg.p;
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
    ab04:	2000091e 	bne	r4,zero,ab2c <tcp_receive+0x59c>
    ab08:	010000b4 	movhi	r4,2
    ab0c:	210d4b04 	addi	r4,r4,13612
    ab10:	014000b4 	movhi	r5,2
    ab14:	2955d004 	addi	r5,r5,22336
    ab18:	01812584 	movi	r6,1174
    ab1c:	01c000b4 	movhi	r7,2
    ab20:	39d5b804 	addi	r7,r7,22240
    ab24:	00104380 	call	10438 <printf>
    ab28:	003fff06 	br	ab28 <tcp_receive+0x598>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
    ab2c:	00dfff84 	movi	r3,32766
    ab30:	1880090e 	bge	r3,r2,ab58 <tcp_receive+0x5c8>
    ab34:	010000b4 	movhi	r4,2
    ab38:	210d4b04 	addi	r4,r4,13612
    ab3c:	014000b4 	movhi	r5,2
    ab40:	2955d404 	addi	r5,r5,22352
    ab44:	018125c4 	movi	r6,1175
    ab48:	01c000b4 	movhi	r7,2
    ab4c:	39d5b804 	addi	r7,r7,22240
    ab50:	00104380 	call	10438 <printf>
    ab54:	003fff06 	br	ab54 <tcp_receive+0x5c4>
      if (inseg.p->len < off) {
    ab58:	20c0028b 	ldhu	r3,10(r4)
    ab5c:	1880240e 	bge	r3,r2,abf0 <tcp_receive+0x660>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
    ab60:	20c0020b 	ldhu	r3,8(r4)
    ab64:	197fffcc 	andi	r5,r3,65535
    ab68:	2880090e 	bge	r5,r2,ab90 <tcp_receive+0x600>
    ab6c:	010000b4 	movhi	r4,2
    ab70:	210d4b04 	addi	r4,r4,13612
    ab74:	014000b4 	movhi	r5,2
    ab78:	2955d804 	addi	r5,r5,22368
    ab7c:	01812644 	movi	r6,1177
    ab80:	01c000b4 	movhi	r7,2
    ab84:	39d5b804 	addi	r7,r7,22240
    ab88:	00104380 	call	10438 <printf>
    ab8c:	003fff06 	br	ab8c <tcp_receive+0x5fc>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
    ab90:	1887c83a 	sub	r3,r3,r2
        while (p->len < off) {
    ab94:	00000406 	br	aba8 <tcp_receive+0x618>
          off -= p->len;
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
    ab98:	20c0020d 	sth	r3,8(r4)
          p->len = 0;
    ab9c:	2000028d 	sth	zero,10(r4)
          p = p->next;
    aba0:	21000017 	ldw	r4,0(r4)
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
          off -= p->len;
    aba4:	1145c83a 	sub	r2,r2,r5
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
    aba8:	2140028b 	ldhu	r5,10(r4)
    abac:	28bffa16 	blt	r5,r2,ab98 <tcp_receive+0x608>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
    abb0:	008bc83a 	sub	r5,zero,r2
    abb4:	297fffcc 	andi	r5,r5,65535
    abb8:	2960001c 	xori	r5,r5,32768
    abbc:	29600004 	addi	r5,r5,-32768
    abc0:	00066980 	call	6698 <pbuf_header>
    abc4:	10803fcc 	andi	r2,r2,255
    abc8:	10001926 	beq	r2,zero,ac30 <tcp_receive+0x6a0>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
    abcc:	010000b4 	movhi	r4,2
    abd0:	210d4b04 	addi	r4,r4,13612
    abd4:	014000b4 	movhi	r5,2
    abd8:	2955dc04 	addi	r5,r5,22384
    abdc:	01812984 	movi	r6,1190
    abe0:	01c000b4 	movhi	r7,2
    abe4:	39d5b804 	addi	r7,r7,22240
    abe8:	00104380 	call	10438 <printf>
    abec:	003fff06 	br	abec <tcp_receive+0x65c>
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
    abf0:	008bc83a 	sub	r5,zero,r2
    abf4:	297fffcc 	andi	r5,r5,65535
    abf8:	2960001c 	xori	r5,r5,32768
    abfc:	29600004 	addi	r5,r5,-32768
    ac00:	00066980 	call	6698 <pbuf_header>
    ac04:	10803fcc 	andi	r2,r2,255
    ac08:	10000926 	beq	r2,zero,ac30 <tcp_receive+0x6a0>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
    ac0c:	010000b4 	movhi	r4,2
    ac10:	210d4b04 	addi	r4,r4,13612
    ac14:	014000b4 	movhi	r5,2
    ac18:	2955dc04 	addi	r5,r5,22384
    ac1c:	01812ac4 	movi	r6,1195
    ac20:	01c000b4 	movhi	r7,2
    ac24:	39d5b804 	addi	r7,r7,22240
    ac28:	00104380 	call	10438 <printf>
    ac2c:	003fff06 	br	ac2c <tcp_receive+0x69c>
        }
      }
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
    ac30:	80800b17 	ldw	r2,44(r16)
    ac34:	8940020b 	ldhu	r5,8(r17)
    ac38:	d1a8c417 	ldw	r6,-23792(gp)
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
    ac3c:	88c00317 	ldw	r3,12(r17)
    ac40:	1008d43a 	srli	r4,r2,16
        if(pbuf_header(inseg.p, (s16_t)-off)) {
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      }
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
    ac44:	314b883a 	add	r5,r6,r5
    ac48:	288bc83a 	sub	r5,r5,r2
    ac4c:	8940020d 	sth	r5,8(r17)
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
    ac50:	d0a8c415 	stw	r2,-23792(gp)
    ac54:	1880010d 	sth	r2,4(r3)
    ac58:	1900018d 	sth	r4,6(r3)
    ac5c:	00000506 	br	ac74 <tcp_receive+0x6e4>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
    ac60:	1885c83a 	sub	r2,r3,r2
    ac64:	1000030e 	bge	r2,zero,ac74 <tcp_receive+0x6e4>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
    ac68:	80800883 	ldbu	r2,34(r16)
    ac6c:	10800094 	ori	r2,r2,2
    ac70:	80800885 	stb	r2,34(r16)
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
    ac74:	d128c417 	ldw	r4,-23792(gp)
    ac78:	80c00b17 	ldw	r3,44(r16)
    ac7c:	20c5c83a 	sub	r2,r4,r3
    ac80:	1001b016 	blt	r2,zero,b344 <tcp_receive+0xdb4>
    ac84:	80800c0b 	ldhu	r2,48(r16)
    ac88:	21800044 	addi	r6,r4,1
    ac8c:	30cdc83a 	sub	r6,r6,r3
    ac90:	117fffcc 	andi	r5,r2,65535
    ac94:	314dc83a 	sub	r6,r6,r5
    ac98:	0181aa16 	blt	zero,r6,b344 <tcp_receive+0xdb4>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
    ac9c:	20c1081e 	bne	r4,r3,b0c0 <tcp_receive+0xb30>
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
        tcplen = TCP_TCPLEN(&inseg);
    aca0:	04400134 	movhi	r17,4
    aca4:	8c67c004 	addi	r17,r17,-24832
    aca8:	88c00317 	ldw	r3,12(r17)
    acac:	8a00020b 	ldhu	r8,8(r17)
    acb0:	1900030b 	ldhu	r4,12(r3)
    acb4:	21bfffcc 	andi	r6,r4,65535
    acb8:	300e923a 	slli	r7,r6,8
    acbc:	300cd23a 	srli	r6,r6,8
    acc0:	39ffffcc 	andi	r7,r7,65535
    acc4:	398eb03a 	or	r7,r7,r6
    acc8:	3a4000cc 	andi	r9,r7,3
    accc:	4812c03a 	cmpne	r9,r9,zero
    acd0:	4a11883a 	add	r8,r9,r8
    acd4:	d228c68d 	sth	r8,-23782(gp)

        if (tcplen > pcb->rcv_wnd) {
    acd8:	423fffcc 	andi	r8,r8,65535
    acdc:	2a002c2e 	bgeu	r5,r8,ad90 <tcp_receive+0x800>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                      ("tcp_receive: other end overran receive window"
                       "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                       seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
    ace0:	39c0004c 	andi	r7,r7,1
    ace4:	38000626 	beq	r7,zero,ad00 <tcp_receive+0x770>
            /* Must remove the FIN from the header as we're trimming 
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
    ace8:	31400f8c 	andi	r5,r6,62
    acec:	280a923a 	slli	r5,r5,8
    acf0:	01b03fc4 	movi	r6,-16129
    acf4:	2188703a 	and	r4,r4,r6
    acf8:	2908b03a 	or	r4,r5,r4
    acfc:	1900030d 	sth	r4,12(r3)
          }
          /* Adjust length of segment to fit in the window. */
          inseg.len = pcb->rcv_wnd;
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
    ad00:	18c0030b 	ldhu	r3,12(r3)
            /* Must remove the FIN from the header as we're trimming 
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
          }
          /* Adjust length of segment to fit in the window. */
          inseg.len = pcb->rcv_wnd;
    ad04:	8880020d 	sth	r2,8(r17)
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
    ad08:	1806d23a 	srli	r3,r3,8
    ad0c:	18c0008c 	andi	r3,r3,2
    ad10:	18000426 	beq	r3,zero,ad24 <tcp_receive+0x794>
            inseg.len -= 1;
    ad14:	10bfffc4 	addi	r2,r2,-1
    ad18:	00c00134 	movhi	r3,4
    ad1c:	18e7c004 	addi	r3,r3,-24832
    ad20:	1880020d 	sth	r2,8(r3)
          }
          pbuf_realloc(inseg.p, inseg.len);
    ad24:	89000117 	ldw	r4,4(r17)
    ad28:	8940020b 	ldhu	r5,8(r17)
    ad2c:	00069140 	call	6914 <pbuf_realloc>
          tcplen = TCP_TCPLEN(&inseg);
    ad30:	88c00317 	ldw	r3,12(r17)
    ad34:	8880020b 	ldhu	r2,8(r17)
          LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
    ad38:	81400c0b 	ldhu	r5,48(r16)
          inseg.len = pcb->rcv_wnd;
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
            inseg.len -= 1;
          }
          pbuf_realloc(inseg.p, inseg.len);
          tcplen = TCP_TCPLEN(&inseg);
    ad3c:	1900030b 	ldhu	r4,12(r3)
          LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
    ad40:	80c00b17 	ldw	r3,44(r16)
          inseg.len = pcb->rcv_wnd;
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
            inseg.len -= 1;
          }
          pbuf_realloc(inseg.p, inseg.len);
          tcplen = TCP_TCPLEN(&inseg);
    ad44:	2008d23a 	srli	r4,r4,8
          LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
    ad48:	28c7883a 	add	r3,r5,r3
          inseg.len = pcb->rcv_wnd;
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
            inseg.len -= 1;
          }
          pbuf_realloc(inseg.p, inseg.len);
          tcplen = TCP_TCPLEN(&inseg);
    ad4c:	210000cc 	andi	r4,r4,3
    ad50:	2008c03a 	cmpne	r4,r4,zero
    ad54:	2085883a 	add	r2,r4,r2
          LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
    ad58:	113fffcc 	andi	r4,r2,65535
          inseg.len = pcb->rcv_wnd;
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
            inseg.len -= 1;
          }
          pbuf_realloc(inseg.p, inseg.len);
          tcplen = TCP_TCPLEN(&inseg);
    ad5c:	d0a8c68d 	sth	r2,-23782(gp)
          LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
    ad60:	d0a8c417 	ldw	r2,-23792(gp)
    ad64:	2085883a 	add	r2,r4,r2
    ad68:	10c00926 	beq	r2,r3,ad90 <tcp_receive+0x800>
    ad6c:	010000b4 	movhi	r4,2
    ad70:	210d4b04 	addi	r4,r4,13612
    ad74:	014000b4 	movhi	r5,2
    ad78:	2955e104 	addi	r5,r5,22404
    ad7c:	01813604 	movi	r6,1240
    ad80:	01c000b4 	movhi	r7,2
    ad84:	39d5b804 	addi	r7,r7,22240
    ad88:	00104380 	call	10438 <printf>
    ad8c:	003fff06 	br	ad8c <tcp_receive+0x7fc>
        }
#if TCP_QUEUE_OOSEQ
        /* Received in-sequence data, adjust ooseq data if:
           - FIN has been received or
           - inseq overlaps with ooseq */
        if (pcb->ooseq != NULL) {
    ad90:	84801e17 	ldw	r18,120(r16)
    ad94:	90005a26 	beq	r18,zero,af00 <tcp_receive+0x970>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
    ad98:	88800317 	ldw	r2,12(r17)
    ad9c:	1080030b 	ldhu	r2,12(r2)
    ada0:	1004d23a 	srli	r2,r2,8
    ada4:	1080004c 	andi	r2,r2,1
    ada8:	1000041e 	bne	r2,zero,adbc <tcp_receive+0x82c>
    adac:	00001906 	br	ae14 <tcp_receive+0x884>
            /* Received in-order FIN means anything that was received
             * out of order must now have been received in-order, so
             * bin the ooseq queue */
            while (pcb->ooseq != NULL) {
              struct tcp_seg *old_ooseq = pcb->ooseq;
              pcb->ooseq = pcb->ooseq->next;
    adb0:	10800017 	ldw	r2,0(r2)
    adb4:	80801e15 	stw	r2,120(r16)
              tcp_seg_free(old_ooseq);
    adb8:	0007ed80 	call	7ed8 <tcp_seg_free>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                        ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
            /* Received in-order FIN means anything that was received
             * out of order must now have been received in-order, so
             * bin the ooseq queue */
            while (pcb->ooseq != NULL) {
    adbc:	80801e17 	ldw	r2,120(r16)
              struct tcp_seg *old_ooseq = pcb->ooseq;
              pcb->ooseq = pcb->ooseq->next;
              tcp_seg_free(old_ooseq);
    adc0:	1009883a 	mov	r4,r2
            LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                        ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
            /* Received in-order FIN means anything that was received
             * out of order must now have been received in-order, so
             * bin the ooseq queue */
            while (pcb->ooseq != NULL) {
    adc4:	103ffa1e 	bne	r2,zero,adb0 <tcp_receive+0x820>
    adc8:	00004d06 	br	af00 <tcp_receive+0x970>
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              /* inseg cannot have FIN here (already processed above) */
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
    adcc:	2880030b 	ldhu	r2,12(r5)
    add0:	1004d23a 	srli	r2,r2,8
    add4:	1080004c 	andi	r2,r2,1
    add8:	10000a26 	beq	r2,zero,ae04 <tcp_receive+0x874>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
    addc:	88800317 	ldw	r2,12(r17)
    ade0:	10c0030b 	ldhu	r3,12(r2)
    ade4:	180ad23a 	srli	r5,r3,8
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
    ade8:	18c04014 	ori	r3,r3,256
            while (next &&
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              /* inseg cannot have FIN here (already processed above) */
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
    adec:	2940008c 	andi	r5,r5,2
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              /* inseg cannot have FIN here (already processed above) */
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
    adf0:	2800041e 	bne	r5,zero,ae04 <tcp_receive+0x874>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
                tcplen = TCP_TCPLEN(&inseg);
    adf4:	9940020b 	ldhu	r5,8(r19)
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              /* inseg cannot have FIN here (already processed above) */
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
    adf8:	10c0030d 	sth	r3,12(r2)
                tcplen = TCP_TCPLEN(&inseg);
    adfc:	28800044 	addi	r2,r5,1
    ae00:	d0a8c68d 	sth	r2,-23782(gp)
              }
              prev = next;
              next = next->next;
    ae04:	94800017 	ldw	r18,0(r18)
              tcp_seg_free(prev);
    ae08:	0007ed80 	call	7ed8 <tcp_seg_free>
            }
          } else {
            next = pcb->ooseq;
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
    ae0c:	9000031e 	bne	r18,zero,ae1c <tcp_receive+0x88c>
    ae10:	00003a06 	br	aefc <tcp_receive+0x96c>
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              /* inseg cannot have FIN here (already processed above) */
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
    ae14:	04c00134 	movhi	r19,4
    ae18:	9ce7c004 	addi	r19,r19,-24832
          } else {
            next = pcb->ooseq;
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
                   TCP_SEQ_GEQ(seqno + tcplen,
    ae1c:	91400317 	ldw	r5,12(r18)
    ae20:	d1a8c68b 	ldhu	r6,-23782(gp)
    ae24:	d0a8c417 	ldw	r2,-23792(gp)
    ae28:	2a00018b 	ldhu	r8,6(r5)
    ae2c:	28c0010b 	ldhu	r3,4(r5)
    ae30:	91c0020b 	ldhu	r7,8(r18)
    ae34:	4010943a 	slli	r8,r8,16
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
                tcplen = TCP_TCPLEN(&inseg);
              }
              prev = next;
              next = next->next;
              tcp_seg_free(prev);
    ae38:	9009883a 	mov	r4,r18
          } else {
            next = pcb->ooseq;
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
                   TCP_SEQ_GEQ(seqno + tcplen,
    ae3c:	40c6b03a 	or	r3,r8,r3
    ae40:	30d1c83a 	sub	r8,r6,r3
    ae44:	4091883a 	add	r8,r8,r2
    ae48:	41cfc83a 	sub	r7,r8,r7
            }
          } else {
            next = pcb->ooseq;
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
    ae4c:	383fdf0e 	bge	r7,zero,adcc <tcp_receive+0x83c>
              tcp_seg_free(prev);
            }
            /* Now trim right side of inseg if it overlaps with the first
             * segment on ooseq */
            if (next &&
                TCP_SEQ_GT(seqno + tcplen,
    ae50:	3089883a 	add	r4,r6,r2
    ae54:	20c9c83a 	sub	r4,r4,r3
              next = next->next;
              tcp_seg_free(prev);
            }
            /* Now trim right side of inseg if it overlaps with the first
             * segment on ooseq */
            if (next &&
    ae58:	0100280e 	bge	zero,r4,aefc <tcp_receive+0x96c>
                TCP_SEQ_GT(seqno + tcplen,
                           next->tcphdr->seqno)) {
              /* inseg cannot have FIN here (already processed above) */
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
    ae5c:	89000317 	ldw	r4,12(r17)
             * segment on ooseq */
            if (next &&
                TCP_SEQ_GT(seqno + tcplen,
                           next->tcphdr->seqno)) {
              /* inseg cannot have FIN here (already processed above) */
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
    ae60:	1885c83a 	sub	r2,r3,r2
    ae64:	8880020d 	sth	r2,8(r17)
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
    ae68:	20c0030b 	ldhu	r3,12(r4)
    ae6c:	1806d23a 	srli	r3,r3,8
    ae70:	18c0008c 	andi	r3,r3,2
    ae74:	18000426 	beq	r3,zero,ae88 <tcp_receive+0x8f8>
                inseg.len -= 1;
    ae78:	10bfffc4 	addi	r2,r2,-1
    ae7c:	00c00134 	movhi	r3,4
    ae80:	18e7c004 	addi	r3,r3,-24832
    ae84:	1880020d 	sth	r2,8(r3)
              }
              pbuf_realloc(inseg.p, inseg.len);
    ae88:	89000117 	ldw	r4,4(r17)
    ae8c:	8940020b 	ldhu	r5,8(r17)
    ae90:	00069140 	call	6914 <pbuf_realloc>
              tcplen = TCP_TCPLEN(&inseg);
    ae94:	89000317 	ldw	r4,12(r17)
    ae98:	8880020b 	ldhu	r2,8(r17)
              LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
    ae9c:	90c00317 	ldw	r3,12(r18)
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
                inseg.len -= 1;
              }
              pbuf_realloc(inseg.p, inseg.len);
              tcplen = TCP_TCPLEN(&inseg);
    aea0:	2100030b 	ldhu	r4,12(r4)
    aea4:	2008d23a 	srli	r4,r4,8
    aea8:	210000cc 	andi	r4,r4,3
    aeac:	2008c03a 	cmpne	r4,r4,zero
    aeb0:	2085883a 	add	r2,r4,r2
    aeb4:	d0a8c68d 	sth	r2,-23782(gp)
              LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
    aeb8:	1980018b 	ldhu	r6,6(r3)
    aebc:	1900010b 	ldhu	r4,4(r3)
    aec0:	117fffcc 	andi	r5,r2,65535
    aec4:	d0e8c417 	ldw	r3,-23792(gp)
    aec8:	3004943a 	slli	r2,r6,16
    aecc:	28c7883a 	add	r3,r5,r3
    aed0:	1104b03a 	or	r2,r2,r4
    aed4:	18800926 	beq	r3,r2,aefc <tcp_receive+0x96c>
    aed8:	010000b4 	movhi	r4,2
    aedc:	210d4b04 	addi	r4,r4,13612
    aee0:	014000b4 	movhi	r5,2
    aee4:	2955ef04 	addi	r5,r5,22460
    aee8:	01814204 	movi	r6,1288
    aeec:	01c000b4 	movhi	r7,2
    aef0:	39d5b804 	addi	r7,r7,22240
    aef4:	00104380 	call	10438 <printf>
    aef8:	003fff06 	br	aef8 <tcp_receive+0x968>
                          (seqno + tcplen) == next->tcphdr->seqno);
            }
            pcb->ooseq = next;
    aefc:	84801e15 	stw	r18,120(r16)
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;
    af00:	d0a8c68b 	ldhu	r2,-23782(gp)
    af04:	d168c417 	ldw	r5,-23792(gp)

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
    af08:	80c00c0b 	ldhu	r3,48(r16)
            pcb->ooseq = next;
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;
    af0c:	113fffcc 	andi	r4,r2,65535
    af10:	214b883a 	add	r5,r4,r5
    af14:	81400b15 	stw	r5,44(r16)

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
    af18:	197fffcc 	andi	r5,r3,65535
    af1c:	2900092e 	bgeu	r5,r4,af44 <tcp_receive+0x9b4>
    af20:	010000b4 	movhi	r4,2
    af24:	210d4b04 	addi	r4,r4,13612
    af28:	014000b4 	movhi	r5,2
    af2c:	2955fe04 	addi	r5,r5,22520
    af30:	01814484 	movi	r6,1298
    af34:	01c000b4 	movhi	r7,2
    af38:	39d5b804 	addi	r7,r7,22240
    af3c:	00104380 	call	10438 <printf>
    af40:	003fff06 	br	af40 <tcp_receive+0x9b0>
        pcb->rcv_wnd -= tcplen;
    af44:	1885c83a 	sub	r2,r3,r2
    af48:	80800c0d 	sth	r2,48(r16)

        tcp_update_rcv_ann_wnd(pcb);
    af4c:	8009883a 	mov	r4,r16
    af50:	0007d500 	call	7d50 <tcp_update_rcv_ann_wnd>
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
    af54:	88800117 	ldw	r2,4(r17)
    af58:	10c0020b 	ldhu	r3,8(r2)
    af5c:	18000426 	beq	r3,zero,af70 <tcp_receive+0x9e0>
          recv_data = inseg.p;
    af60:	d0a8c715 	stw	r2,-23780(gp)
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
    af64:	00800134 	movhi	r2,4
    af68:	10a7c004 	addi	r2,r2,-24832
    af6c:	10000115 	stw	zero,4(r2)
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
    af70:	88800317 	ldw	r2,12(r17)
    af74:	1080030b 	ldhu	r2,12(r2)
    af78:	1004d23a 	srli	r2,r2,8
    af7c:	1080004c 	andi	r2,r2,1
    af80:	10003926 	beq	r2,zero,b068 <tcp_receive+0xad8>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags |= TF_GOT_FIN;
    af84:	d0a8c803 	ldbu	r2,-23776(gp)
    af88:	10800814 	ori	r2,r2,32
    af8c:	d0a8c805 	stb	r2,-23776(gp)
    af90:	00003506 	br	b068 <tcp_receive+0xad8>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
          seqno = pcb->ooseq->tcphdr->seqno;

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
    af94:	1980030b 	ldhu	r6,12(r3)
    af98:	88c0020b 	ldhu	r3,8(r17)
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
    af9c:	81000c0b 	ldhu	r4,48(r16)
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
          seqno = pcb->ooseq->tcphdr->seqno;

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
    afa0:	300cd23a 	srli	r6,r6,8
    afa4:	197fffcc 	andi	r5,r3,65535
           are now in sequence. */
        while (pcb->ooseq != NULL &&
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
          seqno = pcb->ooseq->tcphdr->seqno;
    afa8:	d0a8c415 	stw	r2,-23792(gp)

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
    afac:	318000cc 	andi	r6,r6,3
    afb0:	300cc03a 	cmpne	r6,r6,zero
    afb4:	314b883a 	add	r5,r6,r5
    afb8:	2885883a 	add	r2,r5,r2
    afbc:	80800b15 	stw	r2,44(r16)
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
    afc0:	21ffffcc 	andi	r7,r4,65535
    afc4:	3940090e 	bge	r7,r5,afec <tcp_receive+0xa5c>
    afc8:	010000b4 	movhi	r4,2
    afcc:	210d4b04 	addi	r4,r4,13612
    afd0:	014000b4 	movhi	r5,2
    afd4:	29560604 	addi	r5,r5,22552
    afd8:	01814dc4 	movi	r6,1335
    afdc:	01c000b4 	movhi	r7,2
    afe0:	39d5b804 	addi	r7,r7,22240
    afe4:	00104380 	call	10438 <printf>
    afe8:	003fff06 	br	afe8 <tcp_receive+0xa58>
                      pcb->rcv_wnd >= TCP_TCPLEN(cseg));
          pcb->rcv_wnd -= TCP_TCPLEN(cseg);
    afec:	20c7c83a 	sub	r3,r4,r3
    aff0:	30803fcc 	andi	r2,r6,255
    aff4:	1885c83a 	sub	r2,r3,r2
    aff8:	80800c0d 	sth	r2,48(r16)

          tcp_update_rcv_ann_wnd(pcb);
    affc:	8009883a 	mov	r4,r16
    b000:	0007d500 	call	7d50 <tcp_update_rcv_ann_wnd>

          if (cseg->p->tot_len > 0) {
    b004:	89400117 	ldw	r5,4(r17)
    b008:	2880020b 	ldhu	r2,8(r5)
    b00c:	10000626 	beq	r2,zero,b028 <tcp_receive+0xa98>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
    b010:	d128c717 	ldw	r4,-23780(gp)
    b014:	20000226 	beq	r4,zero,b020 <tcp_receive+0xa90>
              pbuf_cat(recv_data, cseg->p);
    b018:	0006e040 	call	6e04 <pbuf_cat>
    b01c:	00000106 	br	b024 <tcp_receive+0xa94>
            } else {
              recv_data = cseg->p;
    b020:	d168c715 	stw	r5,-23780(gp)
            }
            cseg->p = NULL;
    b024:	88000115 	stw	zero,4(r17)
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
    b028:	88800317 	ldw	r2,12(r17)
    b02c:	1080030b 	ldhu	r2,12(r2)
    b030:	1004d23a 	srli	r2,r2,8
    b034:	1080004c 	andi	r2,r2,1
    b038:	10000626 	beq	r2,zero,b054 <tcp_receive+0xac4>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags |= TF_GOT_FIN;
    b03c:	d0e8c803 	ldbu	r3,-23776(gp)
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
    b040:	80800617 	ldw	r2,24(r16)
            }
            cseg->p = NULL;
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags |= TF_GOT_FIN;
    b044:	18c00814 	ori	r3,r3,32
    b048:	d0e8c805 	stb	r3,-23776(gp)
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
    b04c:	14c0011e 	bne	r2,r19,b054 <tcp_receive+0xac4>
              pcb->state = CLOSE_WAIT;
    b050:	84800615 	stw	r18,24(r16)
            } 
          }

          pcb->ooseq = cseg->next;
    b054:	88800017 	ldw	r2,0(r17)
          tcp_seg_free(cseg);
    b058:	8809883a 	mov	r4,r17
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
              pcb->state = CLOSE_WAIT;
            } 
          }

          pcb->ooseq = cseg->next;
    b05c:	80801e15 	stw	r2,120(r16)
          tcp_seg_free(cseg);
    b060:	0007ed80 	call	7ed8 <tcp_seg_free>
    b064:	00000206 	br	b070 <tcp_receive+0xae0>
            cseg->p = NULL;
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags |= TF_GOT_FIN;
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
    b068:	04c00104 	movi	r19,4
              pcb->state = CLOSE_WAIT;
    b06c:	048001c4 	movi	r18,7
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
    b070:	84401e17 	ldw	r17,120(r16)
    b074:	88000726 	beq	r17,zero,b094 <tcp_receive+0xb04>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
    b078:	88c00317 	ldw	r3,12(r17)
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
    b07c:	81000b17 	ldw	r4,44(r16)
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
    b080:	1940018b 	ldhu	r5,6(r3)
    b084:	1880010b 	ldhu	r2,4(r3)
    b088:	280a943a 	slli	r5,r5,16
    b08c:	2884b03a 	or	r2,r5,r2
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
    b090:	113fc026 	beq	r2,r4,af94 <tcp_receive+0xa04>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
    b094:	80800883 	ldbu	r2,34(r16)
    b098:	10c0004c 	andi	r3,r2,1
    b09c:	18000526 	beq	r3,zero,b0b4 <tcp_receive+0xb24>
    b0a0:	00ffff84 	movi	r3,-2
    b0a4:	10c4703a 	and	r2,r2,r3
    b0a8:	10800094 	ori	r2,r2,2
    b0ac:	80800885 	stb	r2,34(r16)
    b0b0:	0000be06 	br	b3ac <tcp_receive+0xe1c>
    b0b4:	10800054 	ori	r2,r2,1
    b0b8:	80800885 	stb	r2,34(r16)
    b0bc:	0000bb06 	br	b3ac <tcp_receive+0xe1c>

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_send_empty_ack(pcb);
    b0c0:	8009883a 	mov	r4,r16
    b0c4:	000c2a80 	call	c2a8 <tcp_send_empty_ack>
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
    b0c8:	84401e17 	ldw	r17,120(r16)
    b0cc:	8800051e 	bne	r17,zero,b0e4 <tcp_receive+0xb54>
          pcb->ooseq = tcp_seg_copy(&inseg);
    b0d0:	01000134 	movhi	r4,4
    b0d4:	2127c004 	addi	r4,r4,-24832
    b0d8:	0007f580 	call	7f58 <tcp_seg_copy>
    b0dc:	80801e15 	stw	r2,120(r16)
    b0e0:	0000b206 	br	b3ac <tcp_receive+0xe1c>
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
    b0e4:	d0a8c417 	ldw	r2,-23792(gp)
                  break;
                }
              } else {
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
    b0e8:	0025883a 	mov	r18,zero
    b0ec:	11800044 	addi	r6,r2,1
    b0f0:	00000106 	br	b0f8 <tcp_receive+0xb68>
                }
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
    b0f4:	2823883a 	mov	r17,r5
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
    b0f8:	89000317 	ldw	r4,12(r17)
    b0fc:	2140018b 	ldhu	r5,6(r4)
    b100:	20c0010b 	ldhu	r3,4(r4)
    b104:	280a943a 	slli	r5,r5,16
    b108:	28c6b03a 	or	r3,r5,r3
                  break;
                }
              } else {
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
    b10c:	30cfc83a 	sub	r7,r6,r3
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
    b110:	18800d1e 	bne	r3,r2,b148 <tcp_receive+0xbb8>
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
    b114:	01000134 	movhi	r4,4
    b118:	2127c004 	addi	r4,r4,-24832
    b11c:	2080020b 	ldhu	r2,8(r4)
    b120:	88c0020b 	ldhu	r3,8(r17)
    b124:	1880a12e 	bgeu	r3,r2,b3ac <tcp_receive+0xe1c>
                /* The incoming segment is larger than the old
                   segment. We replace some segments with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
    b128:	0007f580 	call	7f58 <tcp_seg_copy>
                if (cseg != NULL) {
    b12c:	10009f26 	beq	r2,zero,b3ac <tcp_receive+0xe1c>
                  if (prev != NULL) {
    b130:	90000226 	beq	r18,zero,b13c <tcp_receive+0xbac>
                    prev->next = cseg;
    b134:	90800015 	stw	r2,0(r18)
    b138:	00000106 	br	b140 <tcp_receive+0xbb0>
                  } else {
                    pcb->ooseq = cseg;
    b13c:	80801e15 	stw	r2,120(r16)
                  }
                  tcp_oos_insert_segment(cseg, next);
    b140:	1009883a 	mov	r4,r2
    b144:	00002606 	br	b1e0 <tcp_receive+0xc50>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
    b148:	9000071e 	bne	r18,zero,b168 <tcp_receive+0xbd8>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
    b14c:	10cbc83a 	sub	r5,r2,r3
    b150:	28002b0e 	bge	r5,zero,b200 <tcp_receive+0xc70>
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */
                  cseg = tcp_seg_copy(&inseg);
    b154:	01000134 	movhi	r4,4
    b158:	2127c004 	addi	r4,r4,-24832
    b15c:	0007f580 	call	7f58 <tcp_seg_copy>
                  if (cseg != NULL) {
    b160:	10009226 	beq	r2,zero,b3ac <tcp_receive+0xe1c>
    b164:	003ff506 	br	b13c <tcp_receive+0xbac>
                  break;
                }
              } else {
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
    b168:	91400317 	ldw	r5,12(r18)
    b16c:	2a00018b 	ldhu	r8,6(r5)
    b170:	2940010b 	ldhu	r5,4(r5)
    b174:	4010943a 	slli	r8,r8,16
    b178:	414a303a 	nor	r5,r8,r5
    b17c:	288b883a 	add	r5,r5,r2
    b180:	28001f16 	blt	r5,zero,b200 <tcp_receive+0xc70>
    b184:	01c01e16 	blt	zero,r7,b200 <tcp_receive+0xc70>
                  /* The sequence number of the incoming segment is in
                     between the sequence numbers of the previous and
                     the next segment on ->ooseq. We trim trim the previous
                     segment, delete next segments that included in received segment
                     and trim received, if needed. */
                  cseg = tcp_seg_copy(&inseg);
    b188:	01000134 	movhi	r4,4
    b18c:	2127c004 	addi	r4,r4,-24832
    b190:	0007f580 	call	7f58 <tcp_seg_copy>
    b194:	1021883a 	mov	r16,r2
                  if (cseg != NULL) {
    b198:	10008426 	beq	r2,zero,b3ac <tcp_receive+0xe1c>
                    if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
    b19c:	90800317 	ldw	r2,12(r18)
    b1a0:	d0e8c417 	ldw	r3,-23792(gp)
    b1a4:	9100020b 	ldhu	r4,8(r18)
    b1a8:	1140018b 	ldhu	r5,6(r2)
    b1ac:	1080010b 	ldhu	r2,4(r2)
    b1b0:	20c9c83a 	sub	r4,r4,r3
    b1b4:	280a943a 	slli	r5,r5,16
    b1b8:	2884b03a 	or	r2,r5,r2
    b1bc:	2089883a 	add	r4,r4,r2
    b1c0:	0100050e 	bge	zero,r4,b1d8 <tcp_receive+0xc48>
                      /* We need to trim the prev segment. */
                      prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
                      pbuf_realloc(prev->p, prev->len);
    b1c4:	91000117 	ldw	r4,4(r18)
                     and trim received, if needed. */
                  cseg = tcp_seg_copy(&inseg);
                  if (cseg != NULL) {
                    if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
                      /* We need to trim the prev segment. */
                      prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
    b1c8:	188bc83a 	sub	r5,r3,r2
    b1cc:	9140020d 	sth	r5,8(r18)
                      pbuf_realloc(prev->p, prev->len);
    b1d0:	297fffcc 	andi	r5,r5,65535
    b1d4:	00069140 	call	6914 <pbuf_realloc>
                    }
                    prev->next = cseg;
    b1d8:	94000015 	stw	r16,0(r18)
                    tcp_oos_insert_segment(cseg, next);
    b1dc:	8009883a 	mov	r4,r16
    b1e0:	880b883a 	mov	r5,r17
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
      tcp_ack_now(pcb);
    }
  }
}
    b1e4:	dfc00417 	ldw	ra,16(sp)
    b1e8:	dcc00317 	ldw	r19,12(sp)
    b1ec:	dc800217 	ldw	r18,8(sp)
    b1f0:	dc400117 	ldw	r17,4(sp)
    b1f4:	dc000017 	ldw	r16,0(sp)
    b1f8:	dec00504 	addi	sp,sp,20
                      /* We need to trim the prev segment. */
                      prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
                      pbuf_realloc(prev->p, prev->len);
                    }
                    prev->next = cseg;
                    tcp_oos_insert_segment(cseg, next);
    b1fc:	000a4b01 	jmpi	a4b0 <tcp_oos_insert_segment>
                }
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
    b200:	89400017 	ldw	r5,0(r17)
    b204:	8825883a 	mov	r18,r17
    b208:	283fba1e 	bne	r5,zero,b0f4 <tcp_receive+0xb64>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
    b20c:	10c5c83a 	sub	r2,r2,r3
                }
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
    b210:	0080660e 	bge	zero,r2,b3ac <tcp_receive+0xe1c>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
    b214:	2080030b 	ldhu	r2,12(r4)
    b218:	1004d23a 	srli	r2,r2,8
    b21c:	1080004c 	andi	r2,r2,1
    b220:	1000621e 	bne	r2,zero,b3ac <tcp_receive+0xe1c>
                  /* segment "next" already contains all data */
                  break;
                }
                next->next = tcp_seg_copy(&inseg);
    b224:	01000134 	movhi	r4,4
    b228:	2127c004 	addi	r4,r4,-24832
    b22c:	0007f580 	call	7f58 <tcp_seg_copy>
    b230:	88800015 	stw	r2,0(r17)
                if (next->next != NULL) {
    b234:	10005d26 	beq	r2,zero,b3ac <tcp_receive+0xe1c>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
    b238:	88800317 	ldw	r2,12(r17)
    b23c:	d0e8c417 	ldw	r3,-23792(gp)
    b240:	8900020b 	ldhu	r4,8(r17)
    b244:	1140018b 	ldhu	r5,6(r2)
    b248:	1080010b 	ldhu	r2,4(r2)
    b24c:	20c9c83a 	sub	r4,r4,r3
    b250:	280a943a 	slli	r5,r5,16
    b254:	2884b03a 	or	r2,r5,r2
    b258:	2089883a 	add	r4,r4,r2
    b25c:	0100050e 	bge	zero,r4,b274 <tcp_receive+0xce4>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
                    pbuf_realloc(next->p, next->len);
    b260:	89000117 	ldw	r4,4(r17)
                }
                next->next = tcp_seg_copy(&inseg);
                if (next->next != NULL) {
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
    b264:	188bc83a 	sub	r5,r3,r2
    b268:	8940020d 	sth	r5,8(r17)
                    pbuf_realloc(next->p, next->len);
    b26c:	297fffcc 	andi	r5,r5,65535
    b270:	00069140 	call	6914 <pbuf_realloc>
                  }
                  /* check if the remote side overruns our receive window */
                  if ((u32_t)tcplen + seqno > pcb->rcv_nxt + (u32_t)pcb->rcv_wnd) {
    b274:	81000c0b 	ldhu	r4,48(r16)
    b278:	d0e8c417 	ldw	r3,-23792(gp)
    b27c:	81400b17 	ldw	r5,44(r16)
    b280:	d0a8c68b 	ldhu	r2,-23782(gp)
    b284:	21bfffcc 	andi	r6,r4,65535
    b288:	314d883a 	add	r6,r6,r5
    b28c:	10c5883a 	add	r2,r2,r3
    b290:	3080462e 	bgeu	r6,r2,b3ac <tcp_receive+0xe1c>
                    LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                                ("tcp_receive: other end overran receive window"
                                 "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                                 seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
                    if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
    b294:	88800017 	ldw	r2,0(r17)
    b298:	11800317 	ldw	r6,12(r2)
    b29c:	31c0030b 	ldhu	r7,12(r6)
    b2a0:	3a3fffcc 	andi	r8,r7,65535
    b2a4:	4010d23a 	srli	r8,r8,8
    b2a8:	4240004c 	andi	r9,r8,1
    b2ac:	48000626 	beq	r9,zero,b2c8 <tcp_receive+0xd38>
                      /* Must remove the FIN from the header as we're trimming 
                       * that byte of sequence-space from the packet */
                      TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) &~ TCP_FIN);
    b2b0:	42000f8c 	andi	r8,r8,62
    b2b4:	4010923a 	slli	r8,r8,8
    b2b8:	02703fc4 	movi	r9,-16129
    b2bc:	3a4e703a 	and	r7,r7,r9
    b2c0:	41ceb03a 	or	r7,r8,r7
    b2c4:	31c0030d 	sth	r7,12(r6)
                    }
                    /* Adjust length of segment to fit in the window. */
                    next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
    b2c8:	290b883a 	add	r5,r5,r4
                    pbuf_realloc(next->next->p, next->next->len);
    b2cc:	11000117 	ldw	r4,4(r2)
                      /* Must remove the FIN from the header as we're trimming 
                       * that byte of sequence-space from the packet */
                      TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) &~ TCP_FIN);
                    }
                    /* Adjust length of segment to fit in the window. */
                    next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
    b2d0:	28cbc83a 	sub	r5,r5,r3
    b2d4:	1140020d 	sth	r5,8(r2)
                    pbuf_realloc(next->next->p, next->next->len);
    b2d8:	297fffcc 	andi	r5,r5,65535
    b2dc:	00069140 	call	6914 <pbuf_realloc>
                    tcplen = TCP_TCPLEN(next->next);
    b2e0:	88800017 	ldw	r2,0(r17)
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
    b2e4:	81400c0b 	ldhu	r5,48(r16)
    b2e8:	80c00b17 	ldw	r3,44(r16)
                      TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) &~ TCP_FIN);
                    }
                    /* Adjust length of segment to fit in the window. */
                    next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
                    pbuf_realloc(next->next->p, next->next->len);
                    tcplen = TCP_TCPLEN(next->next);
    b2ec:	11000317 	ldw	r4,12(r2)
    b2f0:	1080020b 	ldhu	r2,8(r2)
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
    b2f4:	28c7883a 	add	r3,r5,r3
                      TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) &~ TCP_FIN);
                    }
                    /* Adjust length of segment to fit in the window. */
                    next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
                    pbuf_realloc(next->next->p, next->next->len);
                    tcplen = TCP_TCPLEN(next->next);
    b2f8:	2100030b 	ldhu	r4,12(r4)
    b2fc:	2008d23a 	srli	r4,r4,8
    b300:	210000cc 	andi	r4,r4,3
    b304:	2008c03a 	cmpne	r4,r4,zero
    b308:	2085883a 	add	r2,r4,r2
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
    b30c:	113fffcc 	andi	r4,r2,65535
                      TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) &~ TCP_FIN);
                    }
                    /* Adjust length of segment to fit in the window. */
                    next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
                    pbuf_realloc(next->next->p, next->next->len);
                    tcplen = TCP_TCPLEN(next->next);
    b310:	d0a8c68d 	sth	r2,-23782(gp)
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
    b314:	d0a8c417 	ldw	r2,-23792(gp)
    b318:	2085883a 	add	r2,r4,r2
    b31c:	10c02326 	beq	r2,r3,b3ac <tcp_receive+0xe1c>
    b320:	010000b4 	movhi	r4,2
    b324:	210d4b04 	addi	r4,r4,13612
    b328:	014000b4 	movhi	r5,2
    b32c:	2955e104 	addi	r5,r5,22404
    b330:	01817284 	movi	r6,1482
    b334:	01c000b4 	movhi	r7,2
    b338:	39d5b804 	addi	r7,r7,22240
    b33c:	00104380 	call	10438 <printf>
    b340:	003fff06 	br	b340 <tcp_receive+0xdb0>
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */
#endif /* TCP_QUEUE_OOSEQ */
      }
    } else {
      /* The incoming segment is not withing the window. */
      tcp_send_empty_ack(pcb);
    b344:	8009883a 	mov	r4,r16
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
      tcp_ack_now(pcb);
    }
  }
}
    b348:	dfc00417 	ldw	ra,16(sp)
    b34c:	dcc00317 	ldw	r19,12(sp)
    b350:	dc800217 	ldw	r18,8(sp)
    b354:	dc400117 	ldw	r17,4(sp)
    b358:	dc000017 	ldw	r16,0(sp)
    b35c:	dec00504 	addi	sp,sp,20
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */
#endif /* TCP_QUEUE_OOSEQ */
      }
    } else {
      /* The incoming segment is not withing the window. */
      tcp_send_empty_ack(pcb);
    b360:	000c2a81 	jmpi	c2a8 <tcp_send_empty_ack>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
    b364:	1889c83a 	sub	r4,r3,r2
    b368:	20000516 	blt	r4,zero,b380 <tcp_receive+0xdf0>
    b36c:	81000c0b 	ldhu	r4,48(r16)
    b370:	18c00044 	addi	r3,r3,1
    b374:	1885c83a 	sub	r2,r3,r2
    b378:	1105c83a 	sub	r2,r2,r4
    b37c:	00800b0e 	bge	zero,r2,b3ac <tcp_receive+0xe1c>
      tcp_ack_now(pcb);
    b380:	80800883 	ldbu	r2,34(r16)
    b384:	10800094 	ori	r2,r2,2
    b388:	80800885 	stb	r2,34(r16)
    b38c:	00000706 	br	b3ac <tcp_receive+0xe1c>
        }
      }
      /* If Clause (1) or more is true, but not a duplicate ack, reset
       * count of consecutive duplicate acks */
      if (!found_dupack) {
        pcb->dupacks = 0;
    b390:	800012c5 	stb	zero,75(r16)
    b394:	003d8506 	br	a9ac <tcp_receive+0x41c>
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
        pcb->rtime = -1;
    b398:	00bfffc4 	movi	r2,-1
    b39c:	80800e0d 	sth	r2,56(r16)
    b3a0:	003d4b06 	br	a8d0 <tcp_receive+0x340>
      else
        pcb->rtime = 0;
    b3a4:	80000e0d 	sth	zero,56(r16)
    b3a8:	003d4906 	br	a8d0 <tcp_receive+0x340>
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
      tcp_ack_now(pcb);
    }
  }
}
    b3ac:	dfc00417 	ldw	ra,16(sp)
    b3b0:	dcc00317 	ldw	r19,12(sp)
    b3b4:	dc800217 	ldw	r18,8(sp)
    b3b8:	dc400117 	ldw	r17,4(sp)
    b3bc:	dc000017 	ldw	r16,0(sp)
    b3c0:	dec00504 	addi	sp,sp,20
    b3c4:	f800283a 	ret

0000b3c8 <tcp_pbuf_prealloc>:
#if TCP_OVERSIZE
static struct pbuf *
tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
                  u16_t *oversize, struct tcp_pcb *pcb, u8_t apiflags,
                  u8_t first_seg)
{
    b3c8:	defffc04 	addi	sp,sp,-16
    b3cc:	dc800215 	stw	r18,8(sp)
    b3d0:	dc400115 	stw	r17,4(sp)
    b3d4:	dc000015 	stw	r16,0(sp)
  LWIP_UNUSED_ARG(apiflags);
  LWIP_UNUSED_ARG(first_seg);
  /* always create MSS-sized pbufs */
  alloc = max_length;
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (length < max_length) {
    b3d8:	28ffffcc 	andi	r3,r5,65535
#if TCP_OVERSIZE
static struct pbuf *
tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
                  u16_t *oversize, struct tcp_pcb *pcb, u8_t apiflags,
                  u8_t first_seg)
{
    b3dc:	dfc00315 	stw	ra,12(sp)
    b3e0:	2821883a 	mov	r16,r5
    b3e4:	2823883a 	mov	r17,r5
    b3e8:	3825883a 	mov	r18,r7
    b3ec:	d8800417 	ldw	r2,16(sp)
    b3f0:	da000517 	ldw	r8,20(sp)
    b3f4:	d9400603 	ldbu	r5,24(sp)
  LWIP_UNUSED_ARG(apiflags);
  LWIP_UNUSED_ARG(first_seg);
  /* always create MSS-sized pbufs */
  alloc = max_length;
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (length < max_length) {
    b3f8:	1980212e 	bgeu	r3,r6,b480 <tcp_pbuf_prealloc+0xb8>
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
    b3fc:	4200008c 	andi	r8,r8,2
    b400:	42003fcc 	andi	r8,r8,255
    b404:	4000081e 	bne	r8,zero,b428 <tcp_pbuf_prealloc+0x60>
        (!(pcb->flags & TF_NODELAY) &&
    b408:	12000883 	ldbu	r8,34(r2)
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
    b40c:	4200100c 	andi	r8,r8,64
    b410:	42003fcc 	andi	r8,r8,255
    b414:	40001a1e 	bne	r8,zero,b480 <tcp_pbuf_prealloc+0xb8>
        (!(pcb->flags & TF_NODELAY) &&
    b418:	29403fcc 	andi	r5,r5,255
    b41c:	28000226 	beq	r5,zero,b428 <tcp_pbuf_prealloc+0x60>
         (!first_seg ||
    b420:	11401c17 	ldw	r5,112(r2)
    b424:	28001426 	beq	r5,zero,b478 <tcp_pbuf_prealloc+0xb0>
          pcb->unsent != NULL ||
          pcb->unacked != NULL))) {
      alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(length + TCP_OVERSIZE));
    b428:	18c16dc4 	addi	r3,r3,1463
    b42c:	00bfff04 	movi	r2,-4
    b430:	188a703a 	and	r5,r3,r2
    b434:	3140010e 	bge	r6,r5,b43c <tcp_pbuf_prealloc+0x74>
    b438:	300b883a 	mov	r5,r6
    }
  }
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
    b43c:	297fffcc 	andi	r5,r5,65535
    b440:	000d883a 	mov	r6,zero
    b444:	0006a880 	call	6a88 <pbuf_alloc>
  if (p == NULL) {
    b448:	10001426 	beq	r2,zero,b49c <tcp_pbuf_prealloc+0xd4>
    return NULL;
  }
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
    b44c:	10c00017 	ldw	r3,0(r2)
    b450:	18000d26 	beq	r3,zero,b488 <tcp_pbuf_prealloc+0xc0>
    b454:	010000b4 	movhi	r4,2
    b458:	210d4b04 	addi	r4,r4,13612
    b45c:	014000b4 	movhi	r5,2
    b460:	29566b04 	addi	r5,r5,22956
    b464:	018040c4 	movi	r6,259
    b468:	01c000b4 	movhi	r7,2
    b46c:	39d67004 	addi	r7,r7,22976
    b470:	00104380 	call	10438 <printf>
    b474:	003fff06 	br	b474 <tcp_pbuf_prealloc+0xac>
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
        (!(pcb->flags & TF_NODELAY) &&
         (!first_seg ||
          pcb->unsent != NULL ||
    b478:	10801d17 	ldw	r2,116(r2)
    b47c:	103fea1e 	bne	r2,zero,b428 <tcp_pbuf_prealloc+0x60>
    b480:	800b883a 	mov	r5,r16
    b484:	003fed06 	br	b43c <tcp_pbuf_prealloc+0x74>
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
  if (p == NULL) {
    return NULL;
  }
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
  *oversize = p->len - length;
    b488:	10c0028b 	ldhu	r3,10(r2)
    b48c:	1c21c83a 	sub	r16,r3,r16
    b490:	9400000d 	sth	r16,0(r18)
  /* trim p->len to the currently used size */
  p->len = p->tot_len = length;
    b494:	1440020d 	sth	r17,8(r2)
    b498:	1440028d 	sth	r17,10(r2)
  return p;
}
    b49c:	dfc00317 	ldw	ra,12(sp)
    b4a0:	dc800217 	ldw	r18,8(sp)
    b4a4:	dc400117 	ldw	r17,4(sp)
    b4a8:	dc000017 	ldw	r16,0(sp)
    b4ac:	dec00404 	addi	sp,sp,16
    b4b0:	f800283a 	ret

0000b4b4 <tcp_create_segment>:
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
    b4b4:	defff804 	addi	sp,sp,-32
    b4b8:	d8800817 	ldw	r2,32(sp)
    b4bc:	dd000415 	stw	r20,16(sp)
    b4c0:	2029883a 	mov	r20,r4
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
    b4c4:	1100008c 	andi	r4,r2,2
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
    b4c8:	dd800615 	stw	r22,24(sp)
    b4cc:	dd400515 	stw	r21,20(sp)
    b4d0:	dc800215 	stw	r18,8(sp)
    b4d4:	dc400115 	stw	r17,4(sp)
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
    b4d8:	10c0004c 	andi	r3,r2,1
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
    b4dc:	dfc00715 	stw	ra,28(sp)
    b4e0:	dcc00315 	stw	r19,12(sp)
    b4e4:	dc000015 	stw	r16,0(sp)
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
    b4e8:	21003fcc 	andi	r4,r4,255
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
    b4ec:	2825883a 	mov	r18,r5
    b4f0:	3823883a 	mov	r17,r7
    b4f4:	302b883a 	mov	r21,r6
    b4f8:	102d883a 	mov	r22,r2
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
    b4fc:	180690ba 	slli	r3,r3,2
    b500:	20004226 	beq	r4,zero,b60c <tcp_create_segment+0x158>
    b504:	04c00304 	movi	r19,12

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
    b508:	01000104 	movi	r4,4
 */
static struct tcp_seg *
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
    b50c:	98e7883a 	add	r19,r19,r3

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
    b510:	00060a40 	call	60a4 <memp_malloc>
    b514:	1021883a 	mov	r16,r2
    b518:	10004726 	beq	r2,zero,b638 <tcp_create_segment+0x184>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
    return NULL;
  }
  seg->flags = optflags;
    b51c:	15800285 	stb	r22,10(r2)
  seg->next = NULL;
  seg->p = p;
  seg->len = p->tot_len - optlen;
    b520:	90c0020b 	ldhu	r3,8(r18)
    b524:	98803fcc 	andi	r2,r19,255
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
    return NULL;
  }
  seg->flags = optflags;
  seg->next = NULL;
    b528:	80000015 	stw	zero,0(r16)
  seg->p = p;
  seg->len = p->tot_len - optlen;
    b52c:	1885c83a 	sub	r2,r3,r2
    pbuf_free(p);
    return NULL;
  }
  seg->flags = optflags;
  seg->next = NULL;
  seg->p = p;
    b530:	84800115 	stw	r18,4(r16)
  seg->len = p->tot_len - optlen;
    b534:	8080020d 	sth	r2,8(r16)
  LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
              (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_header(p, TCP_HLEN)) {
    b538:	9009883a 	mov	r4,r18
    b53c:	01400504 	movi	r5,20
    b540:	00066980 	call	6698 <pbuf_header>
    b544:	10803fcc 	andi	r2,r2,255
    b548:	1000321e 	bne	r2,zero,b614 <tcp_create_segment+0x160>
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
  seg->tcphdr->src = htons(pcb->local_port);
  seg->tcphdr->dest = htons(pcb->remote_port);
  seg->tcphdr->seqno = htonl(seqno);
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
    b54c:	99803fcc 	andi	r6,r19,255
    b550:	300cd0ba 	srli	r6,r6,2
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
  seg->tcphdr->src = htons(pcb->local_port);
  seg->tcphdr->dest = htons(pcb->remote_port);
  seg->tcphdr->seqno = htonl(seqno);
    b554:	8812963a 	slli	r9,r17,24
    b558:	8810d63a 	srli	r8,r17,24
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
    b55c:	31800144 	addi	r6,r6,5
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
  seg->tcphdr->src = htons(pcb->local_port);
  seg->tcphdr->dest = htons(pcb->remote_port);
  seg->tcphdr->seqno = htonl(seqno);
    b560:	880ed23a 	srli	r7,r17,8
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
    b564:	300c933a 	slli	r6,r6,12
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
  seg->tcphdr->src = htons(pcb->local_port);
  seg->tcphdr->dest = htons(pcb->remote_port);
  seg->tcphdr->seqno = htonl(seqno);
    b568:	8c7fc00c 	andi	r17,r17,65280
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
  seg->tcphdr->src = htons(pcb->local_port);
    b56c:	a100078b 	ldhu	r4,30(r20)
  seg->tcphdr->dest = htons(pcb->remote_port);
    b570:	a0c0080b 	ldhu	r3,32(r20)
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
    b574:	80800117 	ldw	r2,4(r16)
  seg->tcphdr->src = htons(pcb->local_port);
  seg->tcphdr->dest = htons(pcb->remote_port);
  seg->tcphdr->seqno = htonl(seqno);
    b578:	880a923a 	slli	r5,r17,8
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
    b57c:	ad403fcc 	andi	r21,r21,255
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
  seg->tcphdr->src = htons(pcb->local_port);
  seg->tcphdr->dest = htons(pcb->remote_port);
  seg->tcphdr->seqno = htonl(seqno);
    b580:	4a22b03a 	or	r17,r9,r8
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
    b584:	354cb03a 	or	r6,r6,r21
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
  seg->tcphdr->src = htons(pcb->local_port);
  seg->tcphdr->dest = htons(pcb->remote_port);
  seg->tcphdr->seqno = htonl(seqno);
    b588:	39ffc00c 	andi	r7,r7,65280
    b58c:	89e2b03a 	or	r17,r17,r7
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
    b590:	31ffc00c 	andi	r7,r6,65280
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
    b594:	10800117 	ldw	r2,4(r2)
  seg->tcphdr->src = htons(pcb->local_port);
  seg->tcphdr->dest = htons(pcb->remote_port);
  seg->tcphdr->seqno = htonl(seqno);
    b598:	8962b03a 	or	r17,r17,r5
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
  seg->tcphdr->src = htons(pcb->local_port);
    b59c:	2012923a 	slli	r9,r4,8
  seg->tcphdr->dest = htons(pcb->remote_port);
    b5a0:	1810923a 	slli	r8,r3,8
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
  seg->tcphdr->src = htons(pcb->local_port);
    b5a4:	2008d23a 	srli	r4,r4,8
  seg->tcphdr->dest = htons(pcb->remote_port);
    b5a8:	1806d23a 	srli	r3,r3,8
  seg->tcphdr->seqno = htonl(seqno);
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
    b5ac:	380fd23a 	srai	r7,r7,8
    b5b0:	300c923a 	slli	r6,r6,8
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
  seg->tcphdr->src = htons(pcb->local_port);
  seg->tcphdr->dest = htons(pcb->remote_port);
  seg->tcphdr->seqno = htonl(seqno);
    b5b4:	880ad43a 	srli	r5,r17,16
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
    b5b8:	80800315 	stw	r2,12(r16)
  seg->tcphdr->src = htons(pcb->local_port);
    b5bc:	4908b03a 	or	r4,r9,r4
  seg->tcphdr->dest = htons(pcb->remote_port);
    b5c0:	40c6b03a 	or	r3,r8,r3
  seg->tcphdr->seqno = htonl(seqno);
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
    b5c4:	398cb03a 	or	r6,r7,r6
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
  seg->tcphdr->src = htons(pcb->local_port);
    b5c8:	1100000d 	sth	r4,0(r2)
  seg->tcphdr->dest = htons(pcb->remote_port);
    b5cc:	10c0008d 	sth	r3,2(r2)
  seg->tcphdr->seqno = htonl(seqno);
    b5d0:	1440010d 	sth	r17,4(r2)
    b5d4:	1140018d 	sth	r5,6(r2)
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
    b5d8:	1180030d 	sth	r6,12(r2)
  /* wnd and chksum are set in tcp_output */
  seg->tcphdr->urgp = 0;
    b5dc:	1000048d 	sth	zero,18(r2)
  return seg;
} 
    b5e0:	8005883a 	mov	r2,r16
    b5e4:	dfc00717 	ldw	ra,28(sp)
    b5e8:	dd800617 	ldw	r22,24(sp)
    b5ec:	dd400517 	ldw	r21,20(sp)
    b5f0:	dd000417 	ldw	r20,16(sp)
    b5f4:	dcc00317 	ldw	r19,12(sp)
    b5f8:	dc800217 	ldw	r18,8(sp)
    b5fc:	dc400117 	ldw	r17,4(sp)
    b600:	dc000017 	ldw	r16,0(sp)
    b604:	dec00804 	addi	sp,sp,32
    b608:	f800283a 	ret
 */
static struct tcp_seg *
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
    b60c:	0027883a 	mov	r19,zero
    b610:	003fbd06 	br	b508 <tcp_create_segment+0x54>
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_header(p, TCP_HLEN)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    b614:	008001f4 	movhi	r2,7
    b618:	10944804 	addi	r2,r2,20768
    b61c:	10c0290b 	ldhu	r3,164(r2)
    tcp_seg_free(seg);
    b620:	8009883a 	mov	r4,r16
    return NULL;
    b624:	0021883a 	mov	r16,zero
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_header(p, TCP_HLEN)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    b628:	18c00044 	addi	r3,r3,1
    b62c:	10c0290d 	sth	r3,164(r2)
    tcp_seg_free(seg);
    b630:	0007ed80 	call	7ed8 <tcp_seg_free>
    return NULL;
    b634:	003fea06 	br	b5e0 <tcp_create_segment+0x12c>
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
    b638:	9009883a 	mov	r4,r18
    b63c:	00067d80 	call	67d8 <pbuf_free>
    return NULL;
    b640:	003fe706 	br	b5e0 <tcp_create_segment+0x12c>

0000b644 <tcp_output_alloc_header.constprop.0>:
 * @param datalen length of tcp data to reserve in pbuf
 * @param seqno_be seqno in network byte order (big-endian)
 * @return pbuf with p->payload being the tcp_hdr
 */
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
    b644:	defffd04 	addi	sp,sp,-12
                      u32_t seqno_be /* already in network byte order */)
{
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
    b648:	29400504 	addi	r5,r5,20
 * @param datalen length of tcp data to reserve in pbuf
 * @param seqno_be seqno in network byte order (big-endian)
 * @return pbuf with p->payload being the tcp_hdr
 */
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
    b64c:	dc400115 	stw	r17,4(sp)
    b650:	dc000015 	stw	r16,0(sp)
    b654:	3023883a 	mov	r17,r6
    b658:	2021883a 	mov	r16,r4
                      u32_t seqno_be /* already in network byte order */)
{
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
    b65c:	297fffcc 	andi	r5,r5,65535
    b660:	01000044 	movi	r4,1
    b664:	000d883a 	mov	r6,zero
 * @param datalen length of tcp data to reserve in pbuf
 * @param seqno_be seqno in network byte order (big-endian)
 * @return pbuf with p->payload being the tcp_hdr
 */
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
    b668:	dfc00215 	stw	ra,8(sp)
                      u32_t seqno_be /* already in network byte order */)
{
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
    b66c:	0006a880 	call	6a88 <pbuf_alloc>
  if (p != NULL) {
    b670:	10002926 	beq	r2,zero,b718 <tcp_output_alloc_header.constprop.0+0xd4>
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
    b674:	10c0028b 	ldhu	r3,10(r2)
    b678:	010004c4 	movi	r4,19
    b67c:	20c02b0e 	bge	r4,r3,b72c <tcp_output_alloc_header.constprop.0+0xe8>
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
    b680:	10c00117 	ldw	r3,4(r2)
    tcphdr->src = htons(pcb->local_port);
    tcphdr->dest = htons(pcb->remote_port);
    tcphdr->seqno = seqno_be;
    b684:	8808d43a 	srli	r4,r17,16
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
  if (p != NULL) {
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
    tcphdr->src = htons(pcb->local_port);
    b688:	8140078b 	ldhu	r5,30(r16)
    tcphdr->dest = htons(pcb->remote_port);
    b68c:	8180080b 	ldhu	r6,32(r16)
    tcphdr->seqno = seqno_be;
    b690:	1c40010d 	sth	r17,4(r3)
    b694:	1900018d 	sth	r4,6(r3)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
    b698:	81000b17 	ldw	r4,44(r16)
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
  if (p != NULL) {
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
    tcphdr->src = htons(pcb->local_port);
    b69c:	2812923a 	slli	r9,r5,8
    b6a0:	2810d23a 	srli	r8,r5,8
    tcphdr->dest = htons(pcb->remote_port);
    tcphdr->seqno = seqno_be;
    tcphdr->ackno = htonl(pcb->rcv_nxt);
    b6a4:	2016963a 	slli	r11,r4,24
    b6a8:	2014d63a 	srli	r10,r4,24
    b6ac:	200ed23a 	srli	r7,r4,8
    b6b0:	217fc00c 	andi	r5,r4,65280
    b6b4:	280a923a 	slli	r5,r5,8
    b6b8:	5a94b03a 	or	r10,r11,r10
    b6bc:	39ffc00c 	andi	r7,r7,65280
    b6c0:	51ceb03a 	or	r7,r10,r7
    b6c4:	394ab03a 	or	r5,r7,r5
    b6c8:	280ed43a 	srli	r7,r5,16
    b6cc:	1940020d 	sth	r5,8(r3)
  if (p != NULL) {
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
    tcphdr->src = htons(pcb->local_port);
    tcphdr->dest = htons(pcb->remote_port);
    b6d0:	3014923a 	slli	r10,r6,8
    tcphdr->seqno = seqno_be;
    tcphdr->ackno = htonl(pcb->rcv_nxt);
    b6d4:	19c0028d 	sth	r7,10(r3)
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
    b6d8:	81400c8b 	ldhu	r5,50(r16)
  if (p != NULL) {
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
    tcphdr->src = htons(pcb->local_port);
    tcphdr->dest = htons(pcb->remote_port);
    b6dc:	300ed23a 	srli	r7,r6,8
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
  if (p != NULL) {
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
    tcphdr->src = htons(pcb->local_port);
    b6e0:	4a10b03a 	or	r8,r9,r8
    tcphdr->dest = htons(pcb->remote_port);
    tcphdr->seqno = seqno_be;
    tcphdr->ackno = htonl(pcb->rcv_nxt);
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
    b6e4:	280c923a 	slli	r6,r5,8
    b6e8:	2812d23a 	srli	r9,r5,8
  if (p != NULL) {
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
    tcphdr->src = htons(pcb->local_port);
    tcphdr->dest = htons(pcb->remote_port);
    b6ec:	51ceb03a 	or	r7,r10,r7
    b6f0:	19c0008d 	sth	r7,2(r3)
    tcphdr->seqno = seqno_be;
    tcphdr->ackno = htonl(pcb->rcv_nxt);
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
    b6f4:	324cb03a 	or	r6,r6,r9
    tcphdr = (struct tcp_hdr *)p->payload;
    tcphdr->src = htons(pcb->local_port);
    tcphdr->dest = htons(pcb->remote_port);
    tcphdr->seqno = seqno_be;
    tcphdr->ackno = htonl(pcb->rcv_nxt);
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
    b6f8:	01c41404 	movi	r7,4176
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
  if (p != NULL) {
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
    tcphdr->src = htons(pcb->local_port);
    b6fc:	1a00000d 	sth	r8,0(r3)
    tcphdr->dest = htons(pcb->remote_port);
    tcphdr->seqno = seqno_be;
    tcphdr->ackno = htonl(pcb->rcv_nxt);
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
    b700:	19c0030d 	sth	r7,12(r3)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
    b704:	1980038d 	sth	r6,14(r3)
    tcphdr->chksum = 0;
    b708:	1800040d 	sth	zero,16(r3)
    tcphdr->urgp = 0;
    b70c:	1800048d 	sth	zero,18(r3)

    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
    b710:	2909883a 	add	r4,r5,r4
    b714:	81000d15 	stw	r4,52(r16)
  }
  return p;
}
    b718:	dfc00217 	ldw	ra,8(sp)
    b71c:	dc400117 	ldw	r17,4(sp)
    b720:	dc000017 	ldw	r16,0(sp)
    b724:	dec00304 	addi	sp,sp,12
    b728:	f800283a 	ret
                      u32_t seqno_be /* already in network byte order */)
{
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
  if (p != NULL) {
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
    b72c:	010000b4 	movhi	r4,2
    b730:	210d4b04 	addi	r4,r4,13612
    b734:	014000b4 	movhi	r5,2
    b738:	29567604 	addi	r5,r5,23000
    b73c:	01801944 	movi	r6,101
    b740:	01c000b4 	movhi	r7,2
    b744:	39d67004 	addi	r7,r7,22976
    b748:	00104380 	call	10438 <printf>
    b74c:	003fff06 	br	b74c <tcp_output_alloc_header.constprop.0+0x108>

0000b750 <tcp_write>:
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
    b750:	deffe404 	addi	sp,sp,-112
    b754:	df001a15 	stw	fp,104(sp)
    b758:	2039883a 	mov	fp,r4
  u8_t concat_chksum_swapped = 0;
  u16_t concat_chksummed = 0;
#endif /* TCP_CHECKSUM_ON_COPY */
  err_t err;
  /* don't allocate segments bigger than half the maximum window we ever received */
  u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max/2);
    b75c:	2100198b 	ldhu	r4,102(r4)
    b760:	e0800e8b 	ldhu	r2,58(fp)
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
    b764:	dfc01b15 	stw	ra,108(sp)
  u8_t concat_chksum_swapped = 0;
  u16_t concat_chksummed = 0;
#endif /* TCP_CHECKSUM_ON_COPY */
  err_t err;
  /* don't allocate segments bigger than half the maximum window we ever received */
  u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max/2);
    b768:	2008d07a 	srli	r4,r4,1
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
    b76c:	ddc01915 	stw	r23,100(sp)
    b770:	dd801815 	stw	r22,96(sp)
  u8_t concat_chksum_swapped = 0;
  u16_t concat_chksummed = 0;
#endif /* TCP_CHECKSUM_ON_COPY */
  err_t err;
  /* don't allocate segments bigger than half the maximum window we ever received */
  u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max/2);
    b774:	20ffffcc 	andi	r3,r4,65535
    b778:	d8c00715 	stw	r3,28(sp)
    b77c:	d8c00717 	ldw	r3,28(sp)
    b780:	d900060d 	sth	r4,24(sp)
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
    b784:	dd401715 	stw	r21,92(sp)
    b788:	dd001615 	stw	r20,88(sp)
    b78c:	dcc01515 	stw	r19,84(sp)
    b790:	dc801415 	stw	r18,80(sp)
    b794:	dc401315 	stw	r17,76(sp)
    b798:	dc001215 	stw	r16,72(sp)
    b79c:	d9800b15 	stw	r6,44(sp)
    b7a0:	d9c00815 	stw	r7,32(sp)
  u16_t pos = 0; /* position in 'arg' data */
  u16_t queuelen;
  u8_t optlen = 0;
  u8_t optflags = 0;
#if TCP_OVERSIZE
  u16_t oversize = 0;
    b7a4:	d800030d 	sth	zero,12(sp)
  u8_t concat_chksum_swapped = 0;
  u16_t concat_chksummed = 0;
#endif /* TCP_CHECKSUM_ON_COPY */
  err_t err;
  /* don't allocate segments bigger than half the maximum window we ever received */
  u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max/2);
    b7a8:	113fffcc 	andi	r4,r2,65535
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
    b7ac:	d9400515 	stw	r5,20(sp)
    b7b0:	d9800a0d 	sth	r6,40(sp)
    b7b4:	d9c00405 	stb	r7,16(sp)
  u8_t concat_chksum_swapped = 0;
  u16_t concat_chksummed = 0;
#endif /* TCP_CHECKSUM_ON_COPY */
  err_t err;
  /* don't allocate segments bigger than half the maximum window we ever received */
  u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max/2);
    b7b8:	20c0012e 	bgeu	r4,r3,b7c0 <tcp_write+0x70>
    b7bc:	d880060d 	sth	r2,24(sp)
  apiflags |= TCP_WRITE_FLAG_COPY;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)apiflags));
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)", 
    b7c0:	d9000517 	ldw	r4,20(sp)
    b7c4:	20016a26 	beq	r4,zero,bd70 <tcp_write+0x620>
    b7c8:	e0800617 	ldw	r2,24(fp)
    b7cc:	01000084 	movi	r4,2
    b7d0:	11000d2e 	bgeu	r2,r4,b808 <tcp_write+0xb8>
  if ((pcb->state != ESTABLISHED) &&
      (pcb->state != CLOSE_WAIT) &&
      (pcb->state != SYN_SENT) &&
      (pcb->state != SYN_RCVD)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
    b7d4:	00bffcc4 	movi	r2,-13
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
}
    b7d8:	dfc01b17 	ldw	ra,108(sp)
    b7dc:	df001a17 	ldw	fp,104(sp)
    b7e0:	ddc01917 	ldw	r23,100(sp)
    b7e4:	dd801817 	ldw	r22,96(sp)
    b7e8:	dd401717 	ldw	r21,92(sp)
    b7ec:	dd001617 	ldw	r20,88(sp)
    b7f0:	dcc01517 	ldw	r19,84(sp)
    b7f4:	dc801417 	ldw	r18,80(sp)
    b7f8:	dc401317 	ldw	r17,76(sp)
    b7fc:	dc001217 	ldw	r16,72(sp)
    b800:	dec01c04 	addi	sp,sp,112
    b804:	f800283a 	ret
    b808:	01000104 	movi	r4,4
    b80c:	20804b36 	bltu	r4,r2,b93c <tcp_write+0x1ec>
      (pcb->state != CLOSE_WAIT) &&
      (pcb->state != SYN_SENT) &&
      (pcb->state != SYN_RCVD)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  } else if (len == 0) {
    b810:	dd800a0b 	ldhu	r22,40(sp)
    b814:	b0001426 	beq	r22,zero,b868 <tcp_write+0x118>
    return ERR_OK;
  }

  /* fail on too much data */
  if (len > pcb->snd_buf) {
    b818:	e0801a8b 	ldhu	r2,106(fp)
    b81c:	15816836 	bltu	r2,r22,bdc0 <tcp_write+0x670>
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    b820:	e5001b0b 	ldhu	r20,108(fp)
    b824:	00800ac4 	movi	r2,43
    b828:	a2bfffcc 	andi	r10,r20,65535
    b82c:	12815936 	bltu	r2,r10,bd94 <tcp_write+0x644>
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
    b830:	e0801d17 	ldw	r2,116(fp)
      pcb->snd_queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }
  if (pcb->snd_queuelen != 0) {
    b834:	50003726 	beq	r10,zero,b914 <tcp_write+0x1c4>
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
    b838:	10000c1e 	bne	r2,zero,b86c <tcp_write+0x11c>
    b83c:	e4001c17 	ldw	r16,112(fp)
    b840:	80000e1e 	bne	r16,zero,b87c <tcp_write+0x12c>
    b844:	010000b4 	movhi	r4,2
    b848:	210d4b04 	addi	r4,r4,13612
    b84c:	014000b4 	movhi	r5,2
    b850:	29568f04 	addi	r5,r5,23100
    b854:	01805244 	movi	r6,329
    b858:	01c000b4 	movhi	r7,2
    b85c:	39d67004 	addi	r7,r7,22976
    b860:	00104380 	call	10438 <printf>
    b864:	003fff06 	br	b864 <tcp_write+0x114>
    b868:	e5001b0b 	ldhu	r20,108(fp)
   *
   * pos records progress as data is segmented.
   */

  /* Find the tail of the unsent queue. */
  if (pcb->unsent != NULL) {
    b86c:	e4001c17 	ldw	r16,112(fp)
    b870:	8000021e 	bne	r16,zero,b87c <tcp_write+0x12c>
    b874:	00016e06 	br	be30 <tcp_write+0x6e0>
    u16_t space;
    u16_t unsent_optlen;

    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
         last_unsent = last_unsent->next);
    b878:	1021883a 	mov	r16,r2
  if (pcb->unsent != NULL) {
    u16_t space;
    u16_t unsent_optlen;

    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
    b87c:	80800017 	ldw	r2,0(r16)
    b880:	103ffd1e 	bne	r2,zero,b878 <tcp_write+0x128>
         last_unsent = last_unsent->next);

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
    b884:	80800283 	ldbu	r2,10(r16)
    b888:	1100008c 	andi	r4,r2,2
    b88c:	21003fcc 	andi	r4,r4,255
    b890:	1080004c 	andi	r2,r2,1
    b894:	100490ba 	slli	r2,r2,2
    b898:	20013326 	beq	r4,zero,bd68 <tcp_write+0x618>
    b89c:	01800304 	movi	r6,12
    space = mss_local - (last_unsent->len + unsent_optlen);
    b8a0:	8140020b 	ldhu	r5,8(r16)
    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
         last_unsent = last_unsent->next);

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
    b8a4:	d8c0060b 	ldhu	r3,24(sp)
#if TCP_OVERSIZE_DBGCHECK
    /* check that pcb->unsent_oversize matches last_unsent->unsent_oversize */
    LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
                pcb->unsent_oversize == last_unsent->oversize_left);
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
    b8a8:	e1001b8b 	ldhu	r4,110(fp)
    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
         last_unsent = last_unsent->next);

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
    b8ac:	194fc83a 	sub	r7,r3,r5
    space = mss_local - (last_unsent->len + unsent_optlen);
    b8b0:	3885c83a 	sub	r2,r7,r2
    b8b4:	118dc83a 	sub	r6,r2,r6
#if TCP_OVERSIZE_DBGCHECK
    /* check that pcb->unsent_oversize matches last_unsent->unsent_oversize */
    LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
                pcb->unsent_oversize == last_unsent->oversize_left);
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
    b8b8:	d900030d 	sth	r4,12(sp)
    if (oversize > 0) {
    b8bc:	21ffffcc 	andi	r7,r4,65535
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
         last_unsent = last_unsent->next);

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
    space = mss_local - (last_unsent->len + unsent_optlen);
    b8c0:	3005883a 	mov	r2,r6
    /* check that pcb->unsent_oversize matches last_unsent->unsent_oversize */
    LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
                pcb->unsent_oversize == last_unsent->oversize_left);
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
    if (oversize > 0) {
    b8c4:	38002026 	beq	r7,zero,b948 <tcp_write+0x1f8>
      LWIP_ASSERT("inconsistent oversize vs. space", oversize_used <= space);
      seg = last_unsent;
      oversize_used = oversize < len ? oversize : len;
    b8c8:	ddc00a0b 	ldhu	r23,40(sp)
    b8cc:	3d80012e 	bgeu	r7,r22,b8d4 <tcp_write+0x184>
    b8d0:	202f883a 	mov	r23,r4
      pos += oversize_used;
      oversize -= oversize_used;
    b8d4:	25c9c83a 	sub	r4,r4,r23
    b8d8:	d900030d 	sth	r4,12(sp)
      space -= oversize_used;
    }
    /* now we are either finished or oversize is zero */
    LWIP_ASSERT("inconsistend oversize vs. len", (oversize == 0) || (pos == len));
    b8dc:	213fffcc 	andi	r4,r4,65535
      LWIP_ASSERT("inconsistent oversize vs. space", oversize_used <= space);
      seg = last_unsent;
      oversize_used = oversize < len ? oversize : len;
      pos += oversize_used;
      oversize -= oversize_used;
      space -= oversize_used;
    b8e0:	35c5c83a 	sub	r2,r6,r23
    }
    /* now we are either finished or oversize is zero */
    LWIP_ASSERT("inconsistend oversize vs. len", (oversize == 0) || (pos == len));
    b8e4:	20014d26 	beq	r4,zero,be1c <tcp_write+0x6cc>
    b8e8:	bcffffcc 	andi	r19,r23,65535
    b8ec:	b4c15726 	beq	r22,r19,be4c <tcp_write+0x6fc>
    b8f0:	010000b4 	movhi	r4,2
    b8f4:	210d4b04 	addi	r4,r4,13612
    b8f8:	014000b4 	movhi	r5,2
    b8fc:	2956ab04 	addi	r5,r5,23212
    b900:	01807244 	movi	r6,457
    b904:	01c000b4 	movhi	r7,2
    b908:	39d67004 	addi	r7,r7,22976
    b90c:	00104380 	call	10438 <printf>
    b910:	003fff06 	br	b910 <tcp_write+0x1c0>
  }
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
    b914:	10014426 	beq	r2,zero,be28 <tcp_write+0x6d8>
    b918:	010000b4 	movhi	r4,2
    b91c:	210d4b04 	addi	r4,r4,13612
    b920:	014000b4 	movhi	r5,2
    b924:	29569e04 	addi	r5,r5,23160
    b928:	01805304 	movi	r6,332
    b92c:	01c000b4 	movhi	r7,2
    b930:	39d67004 	addi	r7,r7,22976
    b934:	00104380 	call	10438 <printf>
    b938:	003fff06 	br	b938 <tcp_write+0x1e8>
    b93c:	010001c4 	movi	r4,7
    b940:	113fa41e 	bne	r2,r4,b7d4 <tcp_write+0x84>
    b944:	003fb206 	br	b810 <tcp_write+0xc0>
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
  struct pbuf *concat_p = NULL;
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
  u16_t pos = 0; /* position in 'arg' data */
    b948:	0025883a 	mov	r18,zero
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
  struct pbuf *concat_p = NULL;
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
    b94c:	000f883a 	mov	r7,zero
     *
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
     * the end.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
    b950:	94ffffcc 	andi	r19,r18,65535
    b954:	9d80ff2e 	bgeu	r19,r22,bd54 <tcp_write+0x604>
    b958:	11bfffcc 	andi	r6,r2,65535
    b95c:	30006d26 	beq	r6,zero,bb14 <tcp_write+0x3c4>
    b960:	297fffcc 	andi	r5,r5,65535
    b964:	28006b26 	beq	r5,zero,bb14 <tcp_write+0x3c4>
      u16_t seglen = space < len - pos ? space : len - pos;
    b968:	b4cbc83a 	sub	r5,r22,r19
    b96c:	3140010e 	bge	r6,r5,b974 <tcp_write+0x224>
    b970:	300b883a 	mov	r5,r6
      seg = last_unsent;

      /* Create a pbuf with a copy or reference to seglen bytes. We
       * can use PBUF_RAW here since the data appears in the middle of
       * a segment. A header will never be prepended. */
      if (apiflags & TCP_WRITE_FLAG_COPY) {
    b974:	d8800817 	ldw	r2,32(sp)
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
     * the end.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
      u16_t seglen = space < len - pos ? space : len - pos;
    b978:	282b883a 	mov	r21,r5
      seg = last_unsent;

      /* Create a pbuf with a copy or reference to seglen bytes. We
       * can use PBUF_RAW here since the data appears in the middle of
       * a segment. A header will never be prepended. */
      if (apiflags & TCP_WRITE_FLAG_COPY) {
    b97c:	1100004c 	andi	r4,r2,1
    b980:	20014f26 	beq	r4,zero,bec0 <tcp_write+0x770>
        /* Data is copied */
        if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
    b984:	d9000403 	ldbu	r4,16(sp)
    b988:	2dffffcc 	andi	r23,r5,65535
    b98c:	df000015 	stw	fp,0(sp)
    b990:	d9000115 	stw	r4,4(sp)
    b994:	01000044 	movi	r4,1
    b998:	d9000215 	stw	r4,8(sp)
    b99c:	b80b883a 	mov	r5,r23
    b9a0:	010000c4 	movi	r4,3
    b9a4:	d9c00304 	addi	r7,sp,12
    b9a8:	000b3c80 	call	b3c8 <tcp_pbuf_prealloc>
    b9ac:	1023883a 	mov	r17,r2
    b9b0:	10015626 	beq	r2,zero,bf0c <tcp_write+0x7bc>
          goto memerr;
        }
#if TCP_OVERSIZE_DBGCHECK
        last_unsent->oversize_left += oversize;
#endif /* TCP_OVERSIZE_DBGCHECK */
        TCP_DATA_COPY2(concat_p->payload, (u8_t*)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
    b9b4:	d8c00517 	ldw	r3,20(sp)
    b9b8:	11000117 	ldw	r4,4(r2)
    b9bc:	b80d883a 	mov	r6,r23
    b9c0:	1ccb883a 	add	r5,r3,r19
    b9c4:	00102380 	call	10238 <memcpy>
        /* reference the non-volatile payload data */
        concat_p->payload = (u8_t*)arg + pos;
      }

      pos += seglen;
      queuelen += pbuf_clen(concat_p);
    b9c8:	8809883a 	mov	r4,r17
    b9cc:	0006dd40 	call	6dd4 <pbuf_clen>
#endif /* TCP_CHECKSUM_ON_COPY */
        /* reference the non-volatile payload data */
        concat_p->payload = (u8_t*)arg + pos;
      }

      pos += seglen;
    b9d0:	acab883a 	add	r21,r21,r18
      queuelen += pbuf_clen(concat_p);
    b9d4:	10803fcc 	andi	r2,r2,255
    b9d8:	902f883a 	mov	r23,r18
    b9dc:	1529883a 	add	r20,r2,r20
#endif /* TCP_CHECKSUM_ON_COPY */
        /* reference the non-volatile payload data */
        concat_p->payload = (u8_t*)arg + pos;
      }

      pos += seglen;
    b9e0:	a825883a 	mov	r18,r21
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
    b9e4:	94ffffcc 	andi	r19,r18,65535
    b9e8:	9d804c36 	bltu	r19,r22,bb1c <tcp_write+0x3cc>
    b9ec:	800f883a 	mov	r7,r16
    b9f0:	002b883a 	mov	r21,zero
    b9f4:	a2bfffcc 	andi	r10,r20,65535
    b9f8:	bcffffcc 	andi	r19,r23,65535
  /*
   * Phase 1: If data has been added to the preallocated tail of
   * last_unsent, we update the length fields of the pbuf chain.
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
    b9fc:	98001f26 	beq	r19,zero,ba7c <tcp_write+0x32c>
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
    ba00:	84800117 	ldw	r18,4(r16)
    ba04:	90001a26 	beq	r18,zero,ba70 <tcp_write+0x320>
      p->tot_len += oversize_used;
    ba08:	90c0020b 	ldhu	r3,8(r18)
      if (p->next == NULL) {
    ba0c:	90800017 	ldw	r2,0(r18)
#if TCP_OVERSIZE
  if (oversize_used > 0) {
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
      p->tot_len += oversize_used;
    ba10:	b8c7883a 	add	r3,r23,r3
    ba14:	90c0020d 	sth	r3,8(r18)
      if (p->next == NULL) {
    ba18:	10000626 	beq	r2,zero,ba34 <tcp_write+0x2e4>
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
    ba1c:	1025883a 	mov	r18,r2
#if TCP_OVERSIZE
  if (oversize_used > 0) {
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
      p->tot_len += oversize_used;
    ba20:	90c0020b 	ldhu	r3,8(r18)
      if (p->next == NULL) {
    ba24:	90800017 	ldw	r2,0(r18)
#if TCP_OVERSIZE
  if (oversize_used > 0) {
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
      p->tot_len += oversize_used;
    ba28:	b8c7883a 	add	r3,r23,r3
    ba2c:	90c0020d 	sth	r3,8(r18)
      if (p->next == NULL) {
    ba30:	103ffa1e 	bne	r2,zero,ba1c <tcp_write+0x2cc>
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
    ba34:	9080028b 	ldhu	r2,10(r18)
    ba38:	91000117 	ldw	r4,4(r18)
    ba3c:	d9400517 	ldw	r5,20(sp)
    ba40:	980d883a 	mov	r6,r19
    ba44:	2089883a 	add	r4,r4,r2
    ba48:	d9c01015 	stw	r7,64(sp)
    ba4c:	da801115 	stw	r10,68(sp)
    ba50:	00102380 	call	10238 <memcpy>
        p->len += oversize_used;
    ba54:	90c0028b 	ldhu	r3,10(r18)
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
    ba58:	90800017 	ldw	r2,0(r18)
    ba5c:	d9c01017 	ldw	r7,64(sp)
      p->tot_len += oversize_used;
      if (p->next == NULL) {
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
        p->len += oversize_used;
    ba60:	b8c7883a 	add	r3,r23,r3
    ba64:	90c0028d 	sth	r3,10(r18)
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
    ba68:	da801117 	ldw	r10,68(sp)
    ba6c:	103feb1e 	bne	r2,zero,ba1c <tcp_write+0x2cc>
      if (p->next == NULL) {
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
        p->len += oversize_used;
      }
    }
    last_unsent->len += oversize_used;
    ba70:	8080020b 	ldhu	r2,8(r16)
    ba74:	b891883a 	add	r8,r23,r2
    ba78:	8200020d 	sth	r8,8(r16)
    LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
                last_unsent->oversize_left >= oversize_used);
    last_unsent->oversize_left -= oversize_used;
#endif /* TCP_OVERSIZE_DBGCHECK */
  }
  pcb->unsent_oversize = oversize;
    ba7c:	d880030b 	ldhu	r2,12(sp)
    ba80:	e0801b8d 	sth	r2,110(fp)
#endif /* TCP_OVERSIZE */

  /*
   * Phase 2: concat_p can be concatenated onto last_unsent->p
   */
  if (concat_p != NULL) {
    ba84:	88013626 	beq	r17,zero,bf60 <tcp_write+0x810>
    LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
    ba88:	80011726 	beq	r16,zero,bee8 <tcp_write+0x798>
      (last_unsent != NULL));
    pbuf_cat(last_unsent->p, concat_p);
    ba8c:	81000117 	ldw	r4,4(r16)
    ba90:	880b883a 	mov	r5,r17
    ba94:	d9c01015 	stw	r7,64(sp)
    ba98:	da801115 	stw	r10,68(sp)
    ba9c:	0006e040 	call	6e04 <pbuf_cat>
    last_unsent->len += concat_p->tot_len;
    baa0:	8900020b 	ldhu	r4,8(r17)
    baa4:	8080020b 	ldhu	r2,8(r16)
    baa8:	d9c01017 	ldw	r7,64(sp)
    baac:	da801117 	ldw	r10,68(sp)
    bab0:	2085883a 	add	r2,r4,r2
    bab4:	8080020d 	sth	r2,8(r16)
   * is harmless
   */
  if (last_unsent == NULL) {
    pcb->unsent = queue;
  } else {
    last_unsent->next = queue;
    bab8:	85400015 	stw	r21,0(r16)
  }

  /*
   * Finally update the pcb state.
   */
  pcb->snd_lbb += len;
    babc:	e1001817 	ldw	r4,96(fp)
  pcb->snd_buf -= len;
    bac0:	e0801a8b 	ldhu	r2,106(fp)
  pcb->snd_queuelen = queuelen;
    bac4:	e5001b0d 	sth	r20,108(fp)
  }

  /*
   * Finally update the pcb state.
   */
  pcb->snd_lbb += len;
    bac8:	25ad883a 	add	r22,r4,r22
  pcb->snd_buf -= len;
    bacc:	d9000b17 	ldw	r4,44(sp)
  }

  /*
   * Finally update the pcb state.
   */
  pcb->snd_lbb += len;
    bad0:	e5801815 	stw	r22,96(fp)
  pcb->snd_buf -= len;
    bad4:	1105c83a 	sub	r2,r2,r4
    bad8:	e0801a8d 	sth	r2,106(fp)
  pcb->snd_queuelen = queuelen;

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: %"S16_F" (after enqueued)\n",
    pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
    badc:	50000226 	beq	r10,zero,bae8 <tcp_write+0x398>
    LWIP_ASSERT("tcp_write: valid queue length",
    bae0:	e0801d17 	ldw	r2,116(fp)
    bae4:	10011326 	beq	r2,zero,bf34 <tcp_write+0x7e4>
                pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued. */
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
    bae8:	38012026 	beq	r7,zero,bf6c <tcp_write+0x81c>
    baec:	38c00317 	ldw	r3,12(r7)
    baf0:	18011e26 	beq	r3,zero,bf6c <tcp_write+0x81c>
    baf4:	d9000817 	ldw	r4,32(sp)
    baf8:	2080008c 	andi	r2,r4,2
    bafc:	10803fcc 	andi	r2,r2,255
    bb00:	10011a1e 	bne	r2,zero,bf6c <tcp_write+0x81c>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
    bb04:	1900030b 	ldhu	r4,12(r3)
    bb08:	21020014 	ori	r4,r4,2048
    bb0c:	1900030d 	sth	r4,12(r3)
    bb10:	003f3106 	br	b7d8 <tcp_write+0x88>
     *
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
     * the end.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
    bb14:	902f883a 	mov	r23,r18
    bb18:	0023883a 	mov	r17,zero
    bb1c:	d8c0060b 	ldhu	r3,24(sp)
#endif /* TCP_CHECKSUM_ON_COPY */
        /* reference the non-volatile payload data */
        concat_p->payload = (u8_t*)arg + pos;
      }

      pos += seglen;
    bb20:	002b883a 	mov	r21,zero
    bb24:	d8000915 	stw	zero,36(sp)
    bb28:	d8c00715 	stw	r3,28(sp)
    bb2c:	d8c00817 	ldw	r3,32(sp)
    bb30:	dc000f15 	stw	r16,60(sp)
    bb34:	18c0004c 	andi	r3,r3,1
    bb38:	d8c00c15 	stw	r3,48(sp)
    bb3c:	d8c00717 	ldw	r3,28(sp)
    bb40:	d8c00d15 	stw	r3,52(sp)
#endif /* TCP_CHECKSUM_ON_COPY */

    if (apiflags & TCP_WRITE_FLAG_COPY) {
      /* If copy is set, memory should be allocated and data copied
       * into pbuf */
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
    bb44:	d8c00403 	ldbu	r3,16(sp)
    bb48:	dc400415 	stw	r17,16(sp)
    bb4c:	d8c00e15 	stw	r3,56(sp)
    bb50:	00003006 	br	bc14 <tcp_write+0x4c4>
       * sent out on the link (as it has to be ACKed by the remote
       * party) we can safely use PBUF_ROM instead of PBUF_REF here.
       */
      struct pbuf *p2;
#if TCP_OVERSIZE
      LWIP_ASSERT("oversize == 0", oversize == 0);
    bb54:	d880030b 	ldhu	r2,12(sp)
    bb58:	1000a71e 	bne	r2,zero,bdf8 <tcp_write+0x6a8>
#endif /* TCP_OVERSIZE */
      if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
    bb5c:	0009883a 	mov	r4,zero
    bb60:	180b883a 	mov	r5,r3
    bb64:	01800044 	movi	r6,1
    bb68:	0006a880 	call	6a88 <pbuf_alloc>
    bb6c:	100f883a 	mov	r7,r2
    bb70:	10009f26 	beq	r2,zero,bdf0 <tcp_write+0x6a0>
#if TCP_CHECKSUM_ON_COPY
      /* calculate the checksum of nocopy-data */
      chksum = ~inet_chksum((u8_t*)arg + pos, seglen);
#endif /* TCP_CHECKSUM_ON_COPY */
      /* reference the non-volatile payload data */
      p2->payload = (u8_t*)arg + pos;
    bb74:	d8c00517 	ldw	r3,20(sp)

      /* Second, allocate a pbuf for the headers. */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
    bb78:	0009883a 	mov	r4,zero
    bb7c:	000b883a 	mov	r5,zero
#if TCP_CHECKSUM_ON_COPY
      /* calculate the checksum of nocopy-data */
      chksum = ~inet_chksum((u8_t*)arg + pos, seglen);
#endif /* TCP_CHECKSUM_ON_COPY */
      /* reference the non-volatile payload data */
      p2->payload = (u8_t*)arg + pos;
    bb80:	1cc5883a 	add	r2,r3,r19
    bb84:	38800115 	stw	r2,4(r7)

      /* Second, allocate a pbuf for the headers. */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
    bb88:	000d883a 	mov	r6,zero
    bb8c:	d9c01015 	stw	r7,64(sp)
    bb90:	0006a880 	call	6a88 <pbuf_alloc>
    bb94:	1021883a 	mov	r16,r2
    bb98:	d9c01017 	ldw	r7,64(sp)
    bb9c:	10009026 	beq	r2,zero,bde0 <tcp_write+0x690>
        pbuf_free(p2);
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for header pbuf\n"));
        goto memerr;
      }
      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(p/*header*/, p2/*data*/);
    bba0:	1009883a 	mov	r4,r2
    bba4:	380b883a 	mov	r5,r7
    bba8:	0006e040 	call	6e04 <pbuf_cat>
    }

    queuelen += pbuf_clen(p);
    bbac:	8009883a 	mov	r4,r16
    bbb0:	0006dd40 	call	6dd4 <pbuf_clen>
    bbb4:	10803fcc 	andi	r2,r2,255
    bbb8:	a0a9883a 	add	r20,r20,r2

    /* Now that there are more segments queued, we check again if the
     * length of the queue exceeds the configured maximum or
     * overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    bbbc:	a2bfffcc 	andi	r10,r20,65535
    bbc0:	01000b04 	movi	r4,44
    bbc4:	22803836 	bltu	r4,r10,bca8 <tcp_write+0x558>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      pbuf_free(p);
      goto memerr;
    }

    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
    bbc8:	e1c01817 	ldw	r7,96(fp)
    bbcc:	e009883a 	mov	r4,fp
    bbd0:	d8000015 	stw	zero,0(sp)
    bbd4:	800b883a 	mov	r5,r16
    bbd8:	000d883a 	mov	r6,zero
    bbdc:	99cf883a 	add	r7,r19,r7
    bbe0:	da801115 	stw	r10,68(sp)
    bbe4:	000b4b40 	call	b4b4 <tcp_create_segment>
    bbe8:	da801117 	ldw	r10,68(sp)
    bbec:	10008026 	beq	r2,zero,bdf0 <tcp_write+0x6a0>
    seg->chksum_swapped = chksum_swapped;
    seg->flags |= TF_SEG_DATA_CHECKSUMMED;
#endif /* TCP_CHECKSUM_ON_COPY */

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
    bbf0:	a8004e26 	beq	r21,zero,bd2c <tcp_write+0x5dc>
      queue = seg;
    } else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
    bbf4:	d8c00917 	ldw	r3,36(sp)
    bbf8:	18009f26 	beq	r3,zero,be78 <tcp_write+0x728>
      prev_seg->next = seg;
    bbfc:	d8c00917 	ldw	r3,36(sp)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));

    pos += seglen;
    bc00:	8ca5883a 	add	r18,r17,r18
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
    bc04:	94ffffcc 	andi	r19,r18,65535
    if (queue == NULL) {
      queue = seg;
    } else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
      prev_seg->next = seg;
    bc08:	18800015 	stw	r2,0(r3)
    bc0c:	d8800915 	stw	r2,36(sp)
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
    bc10:	9d804b2e 	bgeu	r19,r22,bd40 <tcp_write+0x5f0>
    struct pbuf *p;
    u16_t left = len - pos;
    u16_t max_len = mss_local - optlen;
    u16_t seglen = left > max_len ? max_len : left;
    bc14:	d8c00a0b 	ldhu	r3,40(sp)
    bc18:	d9000717 	ldw	r4,28(sp)
    bc1c:	1ca3c83a 	sub	r17,r3,r18
    bc20:	88ffffcc 	andi	r3,r17,65535
    bc24:	20c0022e 	bgeu	r4,r3,bc30 <tcp_write+0x4e0>
    bc28:	dc40060b 	ldhu	r17,24(sp)
    bc2c:	d8c00d17 	ldw	r3,52(sp)
#if TCP_CHECKSUM_ON_COPY
    u16_t chksum = 0;
    u8_t chksum_swapped = 0;
#endif /* TCP_CHECKSUM_ON_COPY */

    if (apiflags & TCP_WRITE_FLAG_COPY) {
    bc30:	d8800c17 	ldw	r2,48(sp)
    bc34:	103fc726 	beq	r2,zero,bb54 <tcp_write+0x404>
      /* If copy is set, memory should be allocated and data copied
       * into pbuf */
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
    bc38:	d9000e17 	ldw	r4,56(sp)
    bc3c:	d9800717 	ldw	r6,28(sp)
    bc40:	a805003a 	cmpeq	r2,r21,zero
    bc44:	d9000115 	stw	r4,4(sp)
    bc48:	180b883a 	mov	r5,r3
    bc4c:	df000015 	stw	fp,0(sp)
    bc50:	d8800215 	stw	r2,8(sp)
    bc54:	0009883a 	mov	r4,zero
    bc58:	d9c00304 	addi	r7,sp,12
    bc5c:	d8c01015 	stw	r3,64(sp)
    bc60:	000b3c80 	call	b3c8 <tcp_pbuf_prealloc>
    bc64:	1021883a 	mov	r16,r2
    bc68:	d8c01017 	ldw	r3,64(sp)
    bc6c:	10006026 	beq	r2,zero,bdf0 <tcp_write+0x6a0>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
    bc70:	1080028b 	ldhu	r2,10(r2)
    bc74:	10c08936 	bltu	r2,r3,be9c <tcp_write+0x74c>
                  (p->len >= seglen));
      TCP_DATA_COPY2((char *)p->payload + optlen, (u8_t*)arg + pos, seglen, &chksum, &chksum_swapped);
    bc78:	d8800517 	ldw	r2,20(sp)
    bc7c:	81000117 	ldw	r4,4(r16)
    bc80:	180d883a 	mov	r6,r3
    bc84:	14cb883a 	add	r5,r2,r19
    bc88:	00102380 	call	10238 <memcpy>
      }
      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(p/*header*/, p2/*data*/);
    }

    queuelen += pbuf_clen(p);
    bc8c:	8009883a 	mov	r4,r16
    bc90:	0006dd40 	call	6dd4 <pbuf_clen>
    bc94:	10803fcc 	andi	r2,r2,255
    bc98:	a0a9883a 	add	r20,r20,r2

    /* Now that there are more segments queued, we check again if the
     * length of the queue exceeds the configured maximum or
     * overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    bc9c:	a2bfffcc 	andi	r10,r20,65535
    bca0:	01000b04 	movi	r4,44
    bca4:	22bfc82e 	bgeu	r4,r10,bbc8 <tcp_write+0x478>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      pbuf_free(p);
    bca8:	8009883a 	mov	r4,r16
    bcac:	dc400417 	ldw	r17,16(sp)
    bcb0:	00067d80 	call	67d8 <pbuf_free>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
    bcb4:	e1400883 	ldbu	r5,34(fp)
    bcb8:	013fe004 	movi	r4,-128
  TCP_STATS_INC(tcp.memerr);
    bcbc:	008001f4 	movhi	r2,7
    bcc0:	10944804 	addi	r2,r2,20768
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
    bcc4:	2908b03a 	or	r4,r5,r4
    bcc8:	e1000885 	stb	r4,34(fp)
  TCP_STATS_INC(tcp.memerr);
    bccc:	1100270b 	ldhu	r4,156(r2)
    bcd0:	21000044 	addi	r4,r4,1
    bcd4:	1100270d 	sth	r4,156(r2)

  if (concat_p != NULL) {
    bcd8:	88000226 	beq	r17,zero,bce4 <tcp_write+0x594>
    pbuf_free(concat_p);
    bcdc:	8809883a 	mov	r4,r17
    bce0:	00067d80 	call	67d8 <pbuf_free>
  }
  if (queue != NULL) {
    bce4:	a8000226 	beq	r21,zero,bcf0 <tcp_write+0x5a0>
    tcp_segs_free(queue);
    bce8:	a809883a 	mov	r4,r21
    bcec:	0007f200 	call	7f20 <tcp_segs_free>
  }
  if (pcb->snd_queuelen != 0) {
    bcf0:	e0801b0b 	ldhu	r2,108(fp)
    bcf4:	10003826 	beq	r2,zero,bdd8 <tcp_write+0x688>
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
    bcf8:	e0801d17 	ldw	r2,116(fp)
    bcfc:	1000361e 	bne	r2,zero,bdd8 <tcp_write+0x688>
    bd00:	e0801c17 	ldw	r2,112(fp)
    bd04:	1000341e 	bne	r2,zero,bdd8 <tcp_write+0x688>
    bd08:	010000b4 	movhi	r4,2
    bd0c:	210d4b04 	addi	r4,r4,13612
    bd10:	014000b4 	movhi	r5,2
    bd14:	2956e604 	addi	r5,r5,23448
    bd18:	0180b044 	movi	r6,705
    bd1c:	01c000b4 	movhi	r7,2
    bd20:	39d67004 	addi	r7,r7,22976
    bd24:	00104380 	call	10438 <printf>
    bd28:	003fff06 	br	bd28 <tcp_write+0x5d8>

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));

    pos += seglen;
    bd2c:	8ca5883a 	add	r18,r17,r18
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
    bd30:	94ffffcc 	andi	r19,r18,65535
    bd34:	d8800915 	stw	r2,36(sp)
    seg->chksum_swapped = chksum_swapped;
    seg->flags |= TF_SEG_DATA_CHECKSUMMED;
#endif /* TCP_CHECKSUM_ON_COPY */

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
    bd38:	102b883a 	mov	r21,r2
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
    bd3c:	9dbfb536 	bltu	r19,r22,bc14 <tcp_write+0x4c4>
    bd40:	dc400417 	ldw	r17,16(sp)
    bd44:	dc000f17 	ldw	r16,60(sp)
    bd48:	100f883a 	mov	r7,r2
    bd4c:	bcffffcc 	andi	r19,r23,65535
    bd50:	003f2a06 	br	b9fc <tcp_write+0x2ac>
     *
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
     * the end.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
    bd54:	902f883a 	mov	r23,r18
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
    bd58:	0023883a 	mov	r17,zero
    bd5c:	002b883a 	mov	r21,zero
    bd60:	a2bfffcc 	andi	r10,r20,65535
    bd64:	003f2506 	br	b9fc <tcp_write+0x2ac>
    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
         last_unsent = last_unsent->next);

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
    bd68:	000d883a 	mov	r6,zero
    bd6c:	003ecc06 	br	b8a0 <tcp_write+0x150>
  apiflags |= TCP_WRITE_FLAG_COPY;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)apiflags));
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)", 
    bd70:	010000b4 	movhi	r4,2
    bd74:	210d4b04 	addi	r4,r4,13612
    bd78:	014000b4 	movhi	r5,2
    bd7c:	29568204 	addi	r5,r5,23048
    bd80:	01805fc4 	movi	r6,383
    bd84:	01c000b4 	movhi	r7,2
    bd88:	39d67004 	addi	r7,r7,22976
    bd8c:	00104380 	call	10438 <printf>
    bd90:	003fff06 	br	bd90 <tcp_write+0x640>
   * configured maximum, return an error */
  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too long queue %"U16_F" (max %"U16_F")\n",
      pcb->snd_queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    bd94:	010001f4 	movhi	r4,7
    bd98:	21144804 	addi	r4,r4,20768
    bd9c:	2140270b 	ldhu	r5,156(r4)
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
    bda0:	00bfffc4 	movi	r2,-1
   * configured maximum, return an error */
  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too long queue %"U16_F" (max %"U16_F")\n",
      pcb->snd_queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    bda4:	29400044 	addi	r5,r5,1
    bda8:	2140270d 	sth	r5,156(r4)
    pcb->flags |= TF_NAGLEMEMERR;
    bdac:	e1400883 	ldbu	r5,34(fp)
    bdb0:	013fe004 	movi	r4,-128
    bdb4:	2908b03a 	or	r4,r5,r4
    bdb8:	e1000885 	stb	r4,34(fp)
    bdbc:	003e8606 	br	b7d8 <tcp_write+0x88>

  /* fail on too much data */
  if (len > pcb->snd_buf) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n",
      len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
    bdc0:	e1400883 	ldbu	r5,34(fp)
    bdc4:	013fe004 	movi	r4,-128
    return ERR_MEM;
    bdc8:	00bfffc4 	movi	r2,-1

  /* fail on too much data */
  if (len > pcb->snd_buf) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n",
      len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
    bdcc:	2908b03a 	or	r4,r5,r4
    bdd0:	e1000885 	stb	r4,34(fp)
    bdd4:	003e8006 	br	b7d8 <tcp_write+0x88>
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
    bdd8:	00bfffc4 	movi	r2,-1
    bddc:	003e7e06 	br	b7d8 <tcp_write+0x88>

      /* Second, allocate a pbuf for the headers. */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p2);
    bde0:	3809883a 	mov	r4,r7
    bde4:	dc400417 	ldw	r17,16(sp)
    bde8:	00067d80 	call	67d8 <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for header pbuf\n"));
        goto memerr;
    bdec:	003fb106 	br	bcb4 <tcp_write+0x564>
    bdf0:	dc400417 	ldw	r17,16(sp)
    bdf4:	003faf06 	br	bcb4 <tcp_write+0x564>
       * sent out on the link (as it has to be ACKed by the remote
       * party) we can safely use PBUF_ROM instead of PBUF_REF here.
       */
      struct pbuf *p2;
#if TCP_OVERSIZE
      LWIP_ASSERT("oversize == 0", oversize == 0);
    bdf8:	010000b4 	movhi	r4,2
    bdfc:	210d4b04 	addi	r4,r4,13612
    be00:	014000b4 	movhi	r5,2
    be04:	2956cf04 	addi	r5,r5,23356
    be08:	01808984 	movi	r6,550
    be0c:	01c000b4 	movhi	r7,2
    be10:	39d67004 	addi	r7,r7,22976
    be14:	00104380 	call	10438 <printf>
    be18:	003fff06 	br	be18 <tcp_write+0x6c8>
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
    if (oversize > 0) {
      LWIP_ASSERT("inconsistent oversize vs. space", oversize_used <= space);
      seg = last_unsent;
      oversize_used = oversize < len ? oversize : len;
    be1c:	b825883a 	mov	r18,r23
      pos += oversize_used;
      oversize -= oversize_used;
      space -= oversize_used;
    }
    /* now we are either finished or oversize is zero */
    LWIP_ASSERT("inconsistend oversize vs. len", (oversize == 0) || (pos == len));
    be20:	800f883a 	mov	r7,r16
    be24:	003eca06 	br	b950 <tcp_write+0x200>
  }
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
    be28:	e0801c17 	ldw	r2,112(fp)
    be2c:	103eba1e 	bne	r2,zero,b918 <tcp_write+0x1c8>
      pos += seglen;
      queuelen += pbuf_clen(concat_p);
    }
  } else {
#if TCP_OVERSIZE
    LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
    be30:	e0801b8b 	ldhu	r2,110(fp)
    be34:	1000071e 	bne	r2,zero,be54 <tcp_write+0x704>
  u16_t queuelen;
  u8_t optlen = 0;
  u8_t optflags = 0;
#if TCP_OVERSIZE
  u16_t oversize = 0;
  u16_t oversize_used = 0;
    be38:	002f883a 	mov	r23,zero
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
  struct pbuf *concat_p = NULL;
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
  u16_t pos = 0; /* position in 'arg' data */
    be3c:	0025883a 	mov	r18,zero
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
  struct pbuf *concat_p = NULL;
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
    be40:	0021883a 	mov	r16,zero
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
  struct pbuf *concat_p = NULL;
    be44:	0023883a 	mov	r17,zero
    be48:	003ee606 	br	b9e4 <tcp_write+0x294>
      pos += oversize_used;
      oversize -= oversize_used;
      space -= oversize_used;
    }
    /* now we are either finished or oversize is zero */
    LWIP_ASSERT("inconsistend oversize vs. len", (oversize == 0) || (pos == len));
    be4c:	800f883a 	mov	r7,r16
    be50:	003fc106 	br	bd58 <tcp_write+0x608>
      pos += seglen;
      queuelen += pbuf_clen(concat_p);
    }
  } else {
#if TCP_OVERSIZE
    LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
    be54:	010000b4 	movhi	r4,2
    be58:	210d4b04 	addi	r4,r4,13612
    be5c:	014000b4 	movhi	r5,2
    be60:	2956b304 	addi	r5,r5,23244
    be64:	01808004 	movi	r6,512
    be68:	01c000b4 	movhi	r7,2
    be6c:	39d67004 	addi	r7,r7,22976
    be70:	00104380 	call	10438 <printf>
    be74:	003fff06 	br	be74 <tcp_write+0x724>
    /* first segment of to-be-queued data? */
    if (queue == NULL) {
      queue = seg;
    } else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
    be78:	010000b4 	movhi	r4,2
    be7c:	210d4b04 	addi	r4,r4,13612
    be80:	014000b4 	movhi	r5,2
    be84:	2956d304 	addi	r5,r5,23372
    be88:	018096c4 	movi	r6,603
    be8c:	01c000b4 	movhi	r7,2
    be90:	39d67004 	addi	r7,r7,22976
    be94:	00104380 	call	10438 <printf>
    be98:	003fff06 	br	be98 <tcp_write+0x748>
       * into pbuf */
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
    be9c:	010000b4 	movhi	r4,2
    bea0:	210d4b04 	addi	r4,r4,13612
    bea4:	014000b4 	movhi	r5,2
    bea8:	2956bf04 	addi	r5,r5,23292
    beac:	01808704 	movi	r6,540
    beb0:	01c000b4 	movhi	r7,2
    beb4:	39d67004 	addi	r7,r7,22976
    beb8:	00104380 	call	10438 <printf>
    bebc:	003fff06 	br	bebc <tcp_write+0x76c>
#if TCP_CHECKSUM_ON_COPY
        concat_chksummed += seglen;
#endif /* TCP_CHECKSUM_ON_COPY */
      } else {
        /* Data is not copied */
        if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
    bec0:	010000c4 	movi	r4,3
    bec4:	297fffcc 	andi	r5,r5,65535
    bec8:	01800044 	movi	r6,1
    becc:	0006a880 	call	6a88 <pbuf_alloc>
    bed0:	1023883a 	mov	r17,r2
    bed4:	10000d26 	beq	r2,zero,bf0c <tcp_write+0x7bc>
        tcp_seg_add_chksum(~inet_chksum((u8_t*)arg + pos, seglen), seglen,
          &concat_chksum, &concat_chksum_swapped);
        concat_chksummed += seglen;
#endif /* TCP_CHECKSUM_ON_COPY */
        /* reference the non-volatile payload data */
        concat_p->payload = (u8_t*)arg + pos;
    bed8:	d9000517 	ldw	r4,20(sp)
    bedc:	24e7883a 	add	r19,r4,r19
    bee0:	14c00115 	stw	r19,4(r2)
    bee4:	003eb806 	br	b9c8 <tcp_write+0x278>

  /*
   * Phase 2: concat_p can be concatenated onto last_unsent->p
   */
  if (concat_p != NULL) {
    LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
    bee8:	010000b4 	movhi	r4,2
    beec:	210d4b04 	addi	r4,r4,13612
    bef0:	014000b4 	movhi	r5,2
    bef4:	2956d804 	addi	r5,r5,23392
    bef8:	0180a2c4 	movi	r6,651
    befc:	01c000b4 	movhi	r7,2
    bf00:	39d67004 	addi	r7,r7,22976
    bf04:	00104380 	call	10438 <printf>
    bf08:	003fff06 	br	bf08 <tcp_write+0x7b8>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
    bf0c:	e1400883 	ldbu	r5,34(fp)
    bf10:	013fe004 	movi	r4,-128
  TCP_STATS_INC(tcp.memerr);
    bf14:	008001f4 	movhi	r2,7
    bf18:	10944804 	addi	r2,r2,20768
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
    bf1c:	2908b03a 	or	r4,r5,r4
    bf20:	e1000885 	stb	r4,34(fp)
  TCP_STATS_INC(tcp.memerr);
    bf24:	1100270b 	ldhu	r4,156(r2)
    bf28:	21000044 	addi	r4,r4,1
    bf2c:	1100270d 	sth	r4,156(r2)
    bf30:	003f6f06 	br	bcf0 <tcp_write+0x5a0>
  pcb->snd_queuelen = queuelen;

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: %"S16_F" (after enqueued)\n",
    pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_write: valid queue length",
    bf34:	e0801c17 	ldw	r2,112(fp)
    bf38:	103eeb1e 	bne	r2,zero,bae8 <tcp_write+0x398>
    bf3c:	010000b4 	movhi	r4,2
    bf40:	210d4b04 	addi	r4,r4,13612
    bf44:	014000b4 	movhi	r5,2
    bf48:	2956e604 	addi	r5,r5,23448
    bf4c:	0180ab04 	movi	r6,684
    bf50:	01c000b4 	movhi	r7,2
    bf54:	39d67004 	addi	r7,r7,22976
    bf58:	00104380 	call	10438 <printf>
    bf5c:	003fff06 	br	bf5c <tcp_write+0x80c>

  /*
   * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
   * is harmless
   */
  if (last_unsent == NULL) {
    bf60:	803ed51e 	bne	r16,zero,bab8 <tcp_write+0x368>
    pcb->unsent = queue;
    bf64:	e5401c15 	stw	r21,112(fp)
    bf68:	003ed406 	br	babc <tcp_write+0x36c>
  /* Set the PSH flag in the last segment that we enqueued. */
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
    bf6c:	0005883a 	mov	r2,zero
    bf70:	003e1906 	br	b7d8 <tcp_write+0x88>

0000bf74 <tcp_enqueue_flags>:
 * @param optdata pointer to TCP options, or NULL.
 * @param optlen length of TCP options in bytes.
 */
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
    bf74:	defff904 	addi	sp,sp,-28
    bf78:	dd000515 	stw	r20,20(sp)
    bf7c:	dc400215 	stw	r17,8(sp)
    bf80:	dc000115 	stw	r16,4(sp)
    bf84:	dfc00615 	stw	ra,24(sp)
    bf88:	dcc00415 	stw	r19,16(sp)
    bf8c:	dc800315 	stw	r18,12(sp)
  u8_t optflags = 0;
  u8_t optlen = 0;

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
    bf90:	288000cc 	andi	r2,r5,3
 * @param optdata pointer to TCP options, or NULL.
 * @param optlen length of TCP options in bytes.
 */
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
    bf94:	2823883a 	mov	r17,r5
    bf98:	2021883a 	mov	r16,r4
    bf9c:	2829883a 	mov	r20,r5
  u8_t optflags = 0;
  u8_t optlen = 0;

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
    bfa0:	10006126 	beq	r2,zero,c128 <tcp_enqueue_flags+0x1b4>
              (flags & (TCP_SYN | TCP_FIN)) != 0);

  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    bfa4:	20801b0b 	ldhu	r2,108(r4)
    bfa8:	00c00ac4 	movi	r3,43
    bfac:	18806736 	bltu	r3,r2,c14c <tcp_enqueue_flags+0x1d8>
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }

  if (flags & TCP_SYN) {
    bfb0:	2880008c 	andi	r2,r5,2
    bfb4:	10803fcc 	andi	r2,r2,255
    bfb8:	10004926 	beq	r2,zero,c0e0 <tcp_enqueue_flags+0x16c>

  /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
   * We need one available snd_buf byte to do that.
   * This means we can't send FIN while snd_buf==0. A better fix would be to
   * not include SYN and FIN sequence numbers in the snd_buf count. */
  if (pcb->snd_buf == 0) {
    bfbc:	80801a8b 	ldhu	r2,106(r16)
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }

  if (flags & TCP_SYN) {
    optflags = TF_SEG_OPTS_MSS;
    bfc0:	04c00044 	movi	r19,1
#if LWIP_TCP_TIMESTAMPS
  if ((pcb->flags & TF_TIMESTAMP)) {
    optflags |= TF_SEG_OPTS_TS;
  }
#endif /* LWIP_TCP_TIMESTAMPS */
  optlen = LWIP_TCP_OPT_LENGTH(optflags);
    bfc4:	04800104 	movi	r18,4

  /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
   * We need one available snd_buf byte to do that.
   * This means we can't send FIN while snd_buf==0. A better fix would be to
   * not include SYN and FIN sequence numbers in the snd_buf count. */
  if (pcb->snd_buf == 0) {
    bfc8:	10004926 	beq	r2,zero,c0f0 <tcp_enqueue_flags+0x17c>
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
  }

  /* Allocate pbuf with room for TCP header + options */
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
    bfcc:	91403fcc 	andi	r5,r18,255
    bfd0:	0009883a 	mov	r4,zero
    bfd4:	000d883a 	mov	r6,zero
    bfd8:	0006a880 	call	6a88 <pbuf_alloc>
    bfdc:	10008326 	beq	r2,zero,c1ec <tcp_enqueue_flags+0x278>
    pcb->flags |= TF_NAGLEMEMERR;
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
    bfe0:	1100028b 	ldhu	r4,10(r2)
    bfe4:	90c03fcc 	andi	r3,r18,255
    bfe8:	18ffffcc 	andi	r3,r3,65535
    bfec:	20c0092e 	bgeu	r4,r3,c014 <tcp_enqueue_flags+0xa0>
    bff0:	010000b4 	movhi	r4,2
    bff4:	210d4b04 	addi	r4,r4,13612
    bff8:	014000b4 	movhi	r5,2
    bffc:	29570404 	addi	r5,r5,23568
    c000:	0180c084 	movi	r6,770
    c004:	01c000b4 	movhi	r7,2
    c008:	39d67004 	addi	r7,r7,22976
    c00c:	00104380 	call	10438 <printf>
    c010:	003fff06 	br	c010 <tcp_enqueue_flags+0x9c>
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
    c014:	81c01817 	ldw	r7,96(r16)
    c018:	9cc03fcc 	andi	r19,r19,255
    c01c:	dcc00015 	stw	r19,0(sp)
    c020:	8009883a 	mov	r4,r16
    c024:	100b883a 	mov	r5,r2
    c028:	a1803fcc 	andi	r6,r20,255
    c02c:	000b4b40 	call	b4b4 <tcp_create_segment>
    c030:	10006e26 	beq	r2,zero,c1ec <tcp_enqueue_flags+0x278>
    pcb->flags |= TF_NAGLEMEMERR;
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % MEM_ALIGNMENT) == 0);
    c034:	10c00317 	ldw	r3,12(r2)
    c038:	18c000cc 	andi	r3,r3,3
    c03c:	18007d1e 	bne	r3,zero,c234 <tcp_enqueue_flags+0x2c0>
  LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
    c040:	10c0020b 	ldhu	r3,8(r2)
    c044:	1800601e 	bne	r3,zero,c1c8 <tcp_enqueue_flags+0x254>
               ntohl(seg->tcphdr->seqno),
               ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
    c048:	80c01c17 	ldw	r3,112(r16)
    c04c:	1800021e 	bne	r3,zero,c058 <tcp_enqueue_flags+0xe4>
    c050:	00005006 	br	c194 <tcp_enqueue_flags+0x220>
    pcb->unsent = seg;
  } else {
    struct tcp_seg *useg;
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
    c054:	2007883a 	mov	r3,r4
    c058:	19000017 	ldw	r4,0(r3)
    c05c:	203ffd1e 	bne	r4,zero,c054 <tcp_enqueue_flags+0xe0>
    useg->next = seg;
    c060:	18800015 	stw	r2,0(r3)
  pcb->unsent_oversize = 0;
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    pcb->snd_lbb++;
    c064:	81001817 	ldw	r4,96(r16)
    /* optlen does not influence snd_buf */
    pcb->snd_buf--;
    c068:	80c01a8b 	ldhu	r3,106(r16)
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
    useg->next = seg;
  }
#if TCP_OVERSIZE
  /* The new unsent tail has no space */
  pcb->unsent_oversize = 0;
    c06c:	80001b8d 	sth	zero,110(r16)
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    pcb->snd_lbb++;
    c070:	21000044 	addi	r4,r4,1
    /* optlen does not influence snd_buf */
    pcb->snd_buf--;
    c074:	18ffffc4 	addi	r3,r3,-1
  pcb->unsent_oversize = 0;
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    pcb->snd_lbb++;
    c078:	81001815 	stw	r4,96(r16)
    /* optlen does not influence snd_buf */
    pcb->snd_buf--;
    c07c:	80c01a8d 	sth	r3,106(r16)
  }
  if (flags & TCP_FIN) {
    c080:	8c40004c 	andi	r17,r17,1
    c084:	88000326 	beq	r17,zero,c094 <tcp_enqueue_flags+0x120>
    pcb->flags |= TF_FIN;
    c088:	80c00883 	ldbu	r3,34(r16)
    c08c:	18c00814 	ori	r3,r3,32
    c090:	80c00885 	stb	r3,34(r16)
  }

  /* update number of segments on the queues */
  pcb->snd_queuelen += pbuf_clen(seg->p);
    c094:	11000117 	ldw	r4,4(r2)
    c098:	84401b0b 	ldhu	r17,108(r16)
    c09c:	0006dd40 	call	6dd4 <pbuf_clen>
    c0a0:	10803fcc 	andi	r2,r2,255
    c0a4:	1445883a 	add	r2,r2,r17
    c0a8:	80801b0d 	sth	r2,108(r16)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
    c0ac:	10bfffcc 	andi	r2,r2,65535
    c0b0:	10000226 	beq	r2,zero,c0bc <tcp_enqueue_flags+0x148>
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
    c0b4:	80801d17 	ldw	r2,116(r16)
    c0b8:	10003826 	beq	r2,zero,c19c <tcp_enqueue_flags+0x228>
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
    c0bc:	0005883a 	mov	r2,zero
}
    c0c0:	dfc00617 	ldw	ra,24(sp)
    c0c4:	dd000517 	ldw	r20,20(sp)
    c0c8:	dcc00417 	ldw	r19,16(sp)
    c0cc:	dc800317 	ldw	r18,12(sp)
    c0d0:	dc400217 	ldw	r17,8(sp)
    c0d4:	dc000117 	ldw	r16,4(sp)
    c0d8:	dec00704 	addi	sp,sp,28
    c0dc:	f800283a 	ret

  /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
   * We need one available snd_buf byte to do that.
   * This means we can't send FIN while snd_buf==0. A better fix would be to
   * not include SYN and FIN sequence numbers in the snd_buf count. */
  if (pcb->snd_buf == 0) {
    c0e0:	80801a8b 	ldhu	r2,106(r16)
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
  struct pbuf *p;
  struct tcp_seg *seg;
  u8_t optflags = 0;
    c0e4:	0027883a 	mov	r19,zero
#if LWIP_TCP_TIMESTAMPS
  if ((pcb->flags & TF_TIMESTAMP)) {
    optflags |= TF_SEG_OPTS_TS;
  }
#endif /* LWIP_TCP_TIMESTAMPS */
  optlen = LWIP_TCP_OPT_LENGTH(optflags);
    c0e8:	0025883a 	mov	r18,zero

  /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
   * We need one available snd_buf byte to do that.
   * This means we can't send FIN while snd_buf==0. A better fix would be to
   * not include SYN and FIN sequence numbers in the snd_buf count. */
  if (pcb->snd_buf == 0) {
    c0ec:	103fb71e 	bne	r2,zero,bfcc <tcp_enqueue_flags+0x58>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: no send buffer available\n"));
    TCP_STATS_INC(tcp.memerr);
    c0f0:	00c001f4 	movhi	r3,7
    c0f4:	18d44804 	addi	r3,r3,20768
    c0f8:	1900270b 	ldhu	r4,156(r3)
    return ERR_MEM;
    c0fc:	00bfffc4 	movi	r2,-1
   * We need one available snd_buf byte to do that.
   * This means we can't send FIN while snd_buf==0. A better fix would be to
   * not include SYN and FIN sequence numbers in the snd_buf count. */
  if (pcb->snd_buf == 0) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: no send buffer available\n"));
    TCP_STATS_INC(tcp.memerr);
    c100:	21000044 	addi	r4,r4,1
    c104:	1900270d 	sth	r4,156(r3)
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
}
    c108:	dfc00617 	ldw	ra,24(sp)
    c10c:	dd000517 	ldw	r20,20(sp)
    c110:	dcc00417 	ldw	r19,16(sp)
    c114:	dc800317 	ldw	r18,12(sp)
    c118:	dc400217 	ldw	r17,8(sp)
    c11c:	dc000117 	ldw	r16,4(sp)
    c120:	dec00704 	addi	sp,sp,28
    c124:	f800283a 	ret
  u8_t optflags = 0;
  u8_t optlen = 0;

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
    c128:	010000b4 	movhi	r4,2
    c12c:	210d4b04 	addi	r4,r4,13612
    c130:	014000b4 	movhi	r5,2
    c134:	2956ee04 	addi	r5,r5,23480
    c138:	0180b704 	movi	r6,732
    c13c:	01c000b4 	movhi	r7,2
    c140:	39d67004 	addi	r7,r7,22976
    c144:	00104380 	call	10438 <printf>
    c148:	003fff06 	br	c148 <tcp_enqueue_flags+0x1d4>

  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: too long queue %"U16_F" (max %"U16_F")\n",
                                       pcb->snd_queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    c14c:	00c001f4 	movhi	r3,7
    c150:	18d44804 	addi	r3,r3,20768
    c154:	1900270b 	ldhu	r4,156(r3)
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
    c158:	00bfffc4 	movi	r2,-1

  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: too long queue %"U16_F" (max %"U16_F")\n",
                                       pcb->snd_queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    c15c:	21000044 	addi	r4,r4,1
    c160:	1900270d 	sth	r4,156(r3)
    pcb->flags |= TF_NAGLEMEMERR;
    c164:	81000883 	ldbu	r4,34(r16)
    c168:	00ffe004 	movi	r3,-128
    c16c:	20c6b03a 	or	r3,r4,r3
    c170:	80c00885 	stb	r3,34(r16)
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
}
    c174:	dfc00617 	ldw	ra,24(sp)
    c178:	dd000517 	ldw	r20,20(sp)
    c17c:	dcc00417 	ldw	r19,16(sp)
    c180:	dc800317 	ldw	r18,12(sp)
    c184:	dc400217 	ldw	r17,8(sp)
    c188:	dc000117 	ldw	r16,4(sp)
    c18c:	dec00704 	addi	sp,sp,28
    c190:	f800283a 	ret
               ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
    pcb->unsent = seg;
    c194:	80801c15 	stw	r2,112(r16)
    c198:	003fb206 	br	c064 <tcp_enqueue_flags+0xf0>

  /* update number of segments on the queues */
  pcb->snd_queuelen += pbuf_clen(seg->p);
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
    c19c:	80c01c17 	ldw	r3,112(r16)
    c1a0:	183ff41e 	bne	r3,zero,c174 <tcp_enqueue_flags+0x200>
    c1a4:	010000b4 	movhi	r4,2
    c1a8:	210d4b04 	addi	r4,r4,13612
    c1ac:	014000b4 	movhi	r5,2
    c1b0:	29572404 	addi	r5,r5,23696
    c1b4:	0180cbc4 	movi	r6,815
    c1b8:	01c000b4 	movhi	r7,2
    c1bc:	39d67004 	addi	r7,r7,22976
    c1c0:	00104380 	call	10438 <printf>
    c1c4:	003fff06 	br	c1c4 <tcp_enqueue_flags+0x250>
    pcb->flags |= TF_NAGLEMEMERR;
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % MEM_ALIGNMENT) == 0);
  LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
    c1c8:	010000b4 	movhi	r4,2
    c1cc:	210d4b04 	addi	r4,r4,13612
    c1d0:	014000b4 	movhi	r5,2
    c1d4:	29571904 	addi	r5,r5,23652
    c1d8:	0180c2c4 	movi	r6,779
    c1dc:	01c000b4 	movhi	r7,2
    c1e0:	39d67004 	addi	r7,r7,22976
    c1e4:	00104380 	call	10438 <printf>
    c1e8:	003fff06 	br	c1e8 <tcp_enqueue_flags+0x274>
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
    pcb->flags |= TF_NAGLEMEMERR;
    c1ec:	81000883 	ldbu	r4,34(r16)
    c1f0:	00bfe004 	movi	r2,-128
    TCP_STATS_INC(tcp.memerr);
    c1f4:	00c001f4 	movhi	r3,7
    c1f8:	18d44804 	addi	r3,r3,20768
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
    pcb->flags |= TF_NAGLEMEMERR;
    c1fc:	2084b03a 	or	r2,r4,r2
    c200:	80800885 	stb	r2,34(r16)
    TCP_STATS_INC(tcp.memerr);
    c204:	1900270b 	ldhu	r4,156(r3)
    return ERR_MEM;
    c208:	00bfffc4 	movi	r2,-1
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
    pcb->flags |= TF_NAGLEMEMERR;
    TCP_STATS_INC(tcp.memerr);
    c20c:	21000044 	addi	r4,r4,1
    c210:	1900270d 	sth	r4,156(r3)
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
}
    c214:	dfc00617 	ldw	ra,24(sp)
    c218:	dd000517 	ldw	r20,20(sp)
    c21c:	dcc00417 	ldw	r19,16(sp)
    c220:	dc800317 	ldw	r18,12(sp)
    c224:	dc400217 	ldw	r17,8(sp)
    c228:	dc000117 	ldw	r16,4(sp)
    c22c:	dec00704 	addi	sp,sp,28
    c230:	f800283a 	ret
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
    pcb->flags |= TF_NAGLEMEMERR;
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % MEM_ALIGNMENT) == 0);
    c234:	010000b4 	movhi	r4,2
    c238:	210d4b04 	addi	r4,r4,13612
    c23c:	014000b4 	movhi	r5,2
    c240:	29571304 	addi	r5,r5,23628
    c244:	0180c284 	movi	r6,778
    c248:	01c000b4 	movhi	r7,2
    c24c:	39d67004 	addi	r7,r7,22976
    c250:	00104380 	call	10438 <printf>
    c254:	003fff06 	br	c254 <tcp_enqueue_flags+0x2e0>

0000c258 <tcp_send_fin>:
 */
err_t
tcp_send_fin(struct tcp_pcb *pcb)
{
  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
    c258:	20c01c17 	ldw	r3,112(r4)
    c25c:	1800021e 	bne	r3,zero,c268 <tcp_send_fin+0x10>
    c260:	00000806 	br	c284 <tcp_send_fin+0x2c>
    struct tcp_seg *last_unsent;
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
         last_unsent = last_unsent->next);
    c264:	1007883a 	mov	r3,r2
tcp_send_fin(struct tcp_pcb *pcb)
{
  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
    struct tcp_seg *last_unsent;
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
    c268:	18800017 	ldw	r2,0(r3)
    c26c:	103ffd1e 	bne	r2,zero,c264 <tcp_send_fin+0xc>
         last_unsent = last_unsent->next);

    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
    c270:	18800317 	ldw	r2,12(r3)
    c274:	10c0030b 	ldhu	r3,12(r2)
    c278:	180ad23a 	srli	r5,r3,8
    c27c:	294001cc 	andi	r5,r5,7
    c280:	28000226 	beq	r5,zero,c28c <tcp_send_fin+0x34>
      pcb->flags |= TF_FIN;
      return ERR_OK;
    }
  }
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue_flags(pcb, TCP_FIN);
    c284:	01400044 	movi	r5,1
    c288:	000bf741 	jmpi	bf74 <tcp_enqueue_flags>
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
         last_unsent = last_unsent->next);

    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
      /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
    c28c:	18c04014 	ori	r3,r3,256
    c290:	10c0030d 	sth	r3,12(r2)
      pcb->flags |= TF_FIN;
    c294:	20800883 	ldbu	r2,34(r4)
    c298:	10800814 	ori	r2,r2,32
    c29c:	20800885 	stb	r2,34(r4)
      return ERR_OK;
    }
  }
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue_flags(pcb, TCP_FIN);
}
    c2a0:	0005883a 	mov	r2,zero
    c2a4:	f800283a 	ret

0000c2a8 <tcp_send_empty_ack>:
  if (pcb->flags & TF_TIMESTAMP) {
    optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
  }
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
    c2a8:	20801517 	ldw	r2,84(r4)
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
    c2ac:	defff804 	addi	sp,sp,-32
  if (pcb->flags & TF_TIMESTAMP) {
    optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
  }
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
    c2b0:	000b883a 	mov	r5,zero
    c2b4:	100e963a 	slli	r7,r2,24
    c2b8:	100cd63a 	srli	r6,r2,24
    c2bc:	1006d23a 	srli	r3,r2,8
    c2c0:	10bfc00c 	andi	r2,r2,65280
    c2c4:	1004923a 	slli	r2,r2,8
    c2c8:	398cb03a 	or	r6,r7,r6
    c2cc:	18ffc00c 	andi	r3,r3,65280
    c2d0:	30ccb03a 	or	r6,r6,r3
    c2d4:	308cb03a 	or	r6,r6,r2
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
    c2d8:	dc400315 	stw	r17,12(sp)
    c2dc:	dc000215 	stw	r16,8(sp)
    c2e0:	dfc00715 	stw	ra,28(sp)
    c2e4:	dd000615 	stw	r20,24(sp)
    c2e8:	dcc00515 	stw	r19,20(sp)
    c2ec:	dc800415 	stw	r18,16(sp)
    c2f0:	2021883a 	mov	r16,r4
  if (pcb->flags & TF_TIMESTAMP) {
    optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
  }
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
    c2f4:	000b6440 	call	b644 <tcp_output_alloc_header.constprop.0>
    c2f8:	1023883a 	mov	r17,r2
  if (p == NULL) {
    c2fc:	10002126 	beq	r2,zero,c384 <tcp_send_empty_ack+0xdc>
  }
  tcphdr = (struct tcp_hdr *)p->payload;
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  /* remove ACK flags from the PCB, as we send an empty ACK now */
  pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    c300:	80800883 	ldbu	r2,34(r16)
  p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
  if (p == NULL) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
    c304:	8d000117 	ldw	r20,4(r17)
    tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
  }
#endif 

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
    c308:	84c00104 	addi	r19,r16,4
  }
  tcphdr = (struct tcp_hdr *)p->payload;
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  /* remove ACK flags from the PCB, as we send an empty ACK now */
  pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    c30c:	10803f0c 	andi	r2,r2,252
    c310:	80800885 	stb	r2,34(r16)
    tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
  }
#endif 

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
    c314:	8880020b 	ldhu	r2,8(r17)
    c318:	04800184 	movi	r18,6
    c31c:	8809883a 	mov	r4,r17
    c320:	800b883a 	mov	r5,r16
    c324:	980d883a 	mov	r6,r19
    c328:	900f883a 	mov	r7,r18
    c32c:	d8800015 	stw	r2,0(sp)
    c330:	0003e800 	call	3e80 <inet_chksum_pseudo>
    c334:	a080040d 	sth	r2,16(r20)
#endif
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
    c338:	80800243 	ldbu	r2,9(r16)
    c33c:	81c00283 	ldbu	r7,10(r16)
    c340:	800b883a 	mov	r5,r16
    c344:	980d883a 	mov	r6,r19
    c348:	8809883a 	mov	r4,r17
    c34c:	d8800015 	stw	r2,0(sp)
    c350:	dc800115 	stw	r18,4(sp)
    c354:	00048780 	call	4878 <ip_output>
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
  pbuf_free(p);
    c358:	8809883a 	mov	r4,r17
    c35c:	00067d80 	call	67d8 <pbuf_free>

  return ERR_OK;
    c360:	0005883a 	mov	r2,zero
}
    c364:	dfc00717 	ldw	ra,28(sp)
    c368:	dd000617 	ldw	r20,24(sp)
    c36c:	dcc00517 	ldw	r19,20(sp)
    c370:	dc800417 	ldw	r18,16(sp)
    c374:	dc400317 	ldw	r17,12(sp)
    c378:	dc000217 	ldw	r16,8(sp)
    c37c:	dec00804 	addi	sp,sp,32
    c380:	f800283a 	ret
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
  if (p == NULL) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
    c384:	00bfff84 	movi	r2,-2
    c388:	003ff606 	br	c364 <tcp_send_empty_ack+0xbc>

0000c38c <tcp_output>:
#if TCP_CWND_DEBUG
  s16_t i = 0;
#endif /* TCP_CWND_DEBUG */

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_output for listen-pcbs",
    c38c:	20c00617 	ldw	r3,24(r4)
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
    c390:	defff304 	addi	sp,sp,-52
    c394:	dc000315 	stw	r16,12(sp)
    c398:	dfc00c15 	stw	ra,48(sp)
    c39c:	df000b15 	stw	fp,44(sp)
    c3a0:	ddc00a15 	stw	r23,40(sp)
    c3a4:	dd800915 	stw	r22,36(sp)
    c3a8:	dd400815 	stw	r21,32(sp)
    c3ac:	dd000715 	stw	r20,28(sp)
    c3b0:	dcc00615 	stw	r19,24(sp)
    c3b4:	dc800515 	stw	r18,20(sp)
    c3b8:	dc400415 	stw	r17,16(sp)
#if TCP_CWND_DEBUG
  s16_t i = 0;
#endif /* TCP_CWND_DEBUG */

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_output for listen-pcbs",
    c3bc:	00800044 	movi	r2,1
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
    c3c0:	2021883a 	mov	r16,r4
#if TCP_CWND_DEBUG
  s16_t i = 0;
#endif /* TCP_CWND_DEBUG */

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_output for listen-pcbs",
    c3c4:	18816c26 	beq	r3,r2,c978 <tcp_output+0x5ec>

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
    c3c8:	008000f4 	movhi	r2,3
    c3cc:	10aec604 	addi	r2,r2,-17640
    c3d0:	10800017 	ldw	r2,0(r2)
    c3d4:	1100e926 	beq	r2,r4,c77c <tcp_output+0x3f0>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
    c3d8:	2500190b 	ldhu	r20,100(r4)
    c3dc:	2080140b 	ldhu	r2,80(r4)
    c3e0:	15015536 	bltu	r2,r20,c938 <tcp_output+0x5ac>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
    c3e4:	80c00883 	ldbu	r3,34(r16)
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);

  seg = pcb->unsent;
    c3e8:	84401c17 	ldw	r17,112(r16)
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
    c3ec:	1880008c 	andi	r2,r3,2
    c3f0:	10803fcc 	andi	r2,r2,255
    c3f4:	10002126 	beq	r2,zero,c47c <tcp_output+0xf0>
    c3f8:	88001326 	beq	r17,zero,c448 <tcp_output+0xbc>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    c3fc:	88800317 	ldw	r2,12(r17)
    c400:	8980020b 	ldhu	r6,8(r17)
    c404:	81001317 	ldw	r4,76(r16)
    c408:	1140018b 	ldhu	r5,6(r2)
    c40c:	1080010b 	ldhu	r2,4(r2)
    c410:	3109c83a 	sub	r4,r6,r4
    c414:	280a943a 	slli	r5,r5,16
    c418:	2884b03a 	or	r2,r5,r2
    c41c:	100e963a 	slli	r7,r2,24
    c420:	100cd63a 	srli	r6,r2,24
    c424:	100ad23a 	srli	r5,r2,8
    c428:	10bfc00c 	andi	r2,r2,65280
    c42c:	1004923a 	slli	r2,r2,8
    c430:	398cb03a 	or	r6,r7,r6
    c434:	297fc00c 	andi	r5,r5,65280
    c438:	314ab03a 	or	r5,r6,r5
    c43c:	2884b03a 	or	r2,r5,r2
    c440:	2085883a 	add	r2,r4,r2
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
    c444:	a0800d2e 	bgeu	r20,r2,c47c <tcp_output+0xf0>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
     return tcp_send_empty_ack(pcb);
    c448:	8009883a 	mov	r4,r16
  }
#endif /* TCP_OVERSIZE */

  pcb->flags &= ~TF_NAGLEMEMERR;
  return ERR_OK;
}
    c44c:	dfc00c17 	ldw	ra,48(sp)
    c450:	df000b17 	ldw	fp,44(sp)
    c454:	ddc00a17 	ldw	r23,40(sp)
    c458:	dd800917 	ldw	r22,36(sp)
    c45c:	dd400817 	ldw	r21,32(sp)
    c460:	dd000717 	ldw	r20,28(sp)
    c464:	dcc00617 	ldw	r19,24(sp)
    c468:	dc800517 	ldw	r18,20(sp)
    c46c:	dc400417 	ldw	r17,16(sp)
    c470:	dc000317 	ldw	r16,12(sp)
    c474:	dec00d04 	addi	sp,sp,52
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
     return tcp_send_empty_ack(pcb);
    c478:	000c2a81 	jmpi	c2a8 <tcp_send_empty_ack>
  }

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
    c47c:	85801d17 	ldw	r22,116(r16)
  if (useg != NULL) {
    c480:	b000021e 	bne	r22,zero,c48c <tcp_output+0x100>
    c484:	00000306 	br	c494 <tcp_output+0x108>
    for (; useg->next != NULL; useg = useg->next);
    c488:	102d883a 	mov	r22,r2
    c48c:	b0800017 	ldw	r2,0(r22)
    c490:	103ffd1e 	bne	r2,zero,c488 <tcp_output+0xfc>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
    c494:	8800cd26 	beq	r17,zero,c7cc <tcp_output+0x440>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    c498:	88800317 	ldw	r2,12(r17)
    c49c:	89c0020b 	ldhu	r7,8(r17)
    c4a0:	81401317 	ldw	r5,76(r16)
    c4a4:	1180018b 	ldhu	r6,6(r2)
    c4a8:	1100010b 	ldhu	r4,4(r2)
    c4ac:	394bc83a 	sub	r5,r7,r5
    c4b0:	300c943a 	slli	r6,r6,16
    c4b4:	3108b03a 	or	r4,r6,r4
    c4b8:	2012963a 	slli	r9,r4,24
    c4bc:	200ed63a 	srli	r7,r4,24
    c4c0:	21bfc00c 	andi	r6,r4,65280
    c4c4:	300c923a 	slli	r6,r6,8
    c4c8:	2008d23a 	srli	r4,r4,8
    c4cc:	49ceb03a 	or	r7,r9,r7
    c4d0:	398cb03a 	or	r6,r7,r6
    c4d4:	213fc00c 	andi	r4,r4,65280
    c4d8:	3108b03a 	or	r4,r6,r4
    c4dc:	2909883a 	add	r4,r5,r4
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
    c4e0:	a100a436 	bltu	r20,r4,c774 <tcp_output+0x3e8>
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
    c4e4:	80c01d04 	addi	r3,r16,116
     packets, so ignore it here */
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
  if (seg->flags & TF_SEG_OPTS_MSS) {
    u16_t mss;
#if TCP_CALCULATE_EFF_SEND_MSS
    mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
    c4e8:	84800104 	addi	r18,r16,4
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
         &(pcb->remote_ip),
         IP_PROTO_TCP, seg->p->tot_len);
#endif /* TCP_CHECKSUM_ON_COPY */
#endif /* CHECKSUM_GEN_TCP */
  TCP_STATS_INC(tcp.xmit);
    c4ec:	04c001f4 	movhi	r19,7
    c4f0:	9cd44804 	addi	r19,r19,20768
    }
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
  }

  if (pcb->rttest == 0) {
    pcb->rttest = tcp_ticks;
    c4f4:	054000f4 	movhi	r21,3
    c4f8:	ad6eba04 	addi	r21,r21,-17688
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
    c4fc:	d8c00215 	stw	r3,8(sp)
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
    c500:	1100030b 	ldhu	r4,12(r2)
    c504:	2006d23a 	srli	r3,r4,8
    c508:	18c0010c 	andi	r3,r3,4
    c50c:	1801111e 	bne	r3,zero,c954 <tcp_output+0x5c8>
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
    c510:	80c01d17 	ldw	r3,116(r16)
    c514:	18000626 	beq	r3,zero,c530 <tcp_output+0x1a4>
    c518:	80c00883 	ldbu	r3,34(r16)
    c51c:	1940110c 	andi	r5,r3,68
    c520:	2800031e 	bne	r5,zero,c530 <tcp_output+0x1a4>
    c524:	8800f926 	beq	r17,zero,c90c <tcp_output+0x580>
    c528:	89400017 	ldw	r5,0(r17)
    c52c:	2800f426 	beq	r5,zero,c900 <tcp_output+0x574>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
    c530:	88c00017 	ldw	r3,0(r17)

    if (pcb->state != SYN_SENT) {
    c534:	81400617 	ldw	r5,24(r16)
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
    c538:	80c01c15 	stw	r3,112(r16)

    if (pcb->state != SYN_SENT) {
    c53c:	00c00084 	movi	r3,2
    c540:	28c00526 	beq	r5,r3,c558 <tcp_output+0x1cc>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
    c544:	21040014 	ori	r4,r4,4096
    c548:	1100030d 	sth	r4,12(r2)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    c54c:	80800883 	ldbu	r2,34(r16)
    c550:	10803f0c 	andi	r2,r2,252
    c554:	80800885 	stb	r2,34(r16)
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
    c558:	80800b17 	ldw	r2,44(r16)
    c55c:	8f000317 	ldw	fp,12(r17)
    c560:	100c963a 	slli	r6,r2,24
    c564:	100ad63a 	srli	r5,r2,24
    c568:	1008d23a 	srli	r4,r2,8
    c56c:	10ffc00c 	andi	r3,r2,65280
    c570:	1806923a 	slli	r3,r3,8
    c574:	314ab03a 	or	r5,r6,r5
    c578:	213fc00c 	andi	r4,r4,65280
    c57c:	2908b03a 	or	r4,r5,r4
    c580:	20c6b03a 	or	r3,r4,r3
    c584:	1808d43a 	srli	r4,r3,16
    c588:	e0c0020d 	sth	r3,8(fp)
    c58c:	e100028d 	sth	r4,10(fp)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
    c590:	80c00c8b 	ldhu	r3,50(r16)
    c594:	180a923a 	slli	r5,r3,8
    c598:	1808d23a 	srli	r4,r3,8

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
    c59c:	1885883a 	add	r2,r3,r2
  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
    c5a0:	2906b03a 	or	r3,r5,r4
    c5a4:	e0c0038d 	sth	r3,14(fp)

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
    c5a8:	80800d15 	stw	r2,52(r16)

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
  if (seg->flags & TF_SEG_OPTS_MSS) {
    c5ac:	88800283 	ldbu	r2,10(r17)
    c5b0:	1080004c 	andi	r2,r2,1
    c5b4:	10009d1e 	bne	r2,zero,c82c <tcp_output+0x4a0>
  }
#endif

  /* Set retransmission timer running if it is not currently enabled 
     This must be set before checking the route. */
  if (pcb->rtime == -1) {
    c5b8:	80c00e0f 	ldh	r3,56(r16)
    c5bc:	00bfffc4 	movi	r2,-1
    c5c0:	18809826 	beq	r3,r2,c824 <tcp_output+0x498>
    pcb->rtime = 0;
  }

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
    c5c4:	80800017 	ldw	r2,0(r16)
    c5c8:	1000051e 	bne	r2,zero,c5e0 <tcp_output+0x254>
    netif = ip_route(&(pcb->remote_ip));
    c5cc:	9009883a 	mov	r4,r18
    c5d0:	000427c0 	call	427c <ip_route>
    if (netif == NULL) {
    c5d4:	10002326 	beq	r2,zero,c664 <tcp_output+0x2d8>
      return;
    }
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
    c5d8:	10800117 	ldw	r2,4(r2)
    c5dc:	80800015 	stw	r2,0(r16)
  }

  if (pcb->rttest == 0) {
    c5e0:	80800f17 	ldw	r2,60(r16)
    c5e4:	10007d26 	beq	r2,zero,c7dc <tcp_output+0x450>
    c5e8:	8f000317 	ldw	fp,12(r17)
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
    c5ec:	89000117 	ldw	r4,4(r17)
      seg->tcphdr->chksum = chksum_slow;
    }
#endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
  }
#else /* TCP_CHECKSUM_ON_COPY */
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
    c5f0:	05c00184 	movi	r23,6
    c5f4:	800b883a 	mov	r5,r16
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
    c5f8:	20800117 	ldw	r2,4(r4)

  seg->p->len -= len;
  seg->p->tot_len -= len;
    c5fc:	21c0020b 	ldhu	r7,8(r4)
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);

  seg->p->len -= len;
    c600:	2180028b 	ldhu	r6,10(r4)
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
    c604:	e085c83a 	sub	r2,fp,r2

  seg->p->len -= len;
  seg->p->tot_len -= len;

  seg->p->payload = seg->tcphdr;
    c608:	27000115 	stw	fp,4(r4)
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);

  seg->p->len -= len;
    c60c:	308dc83a 	sub	r6,r6,r2
  seg->p->tot_len -= len;
    c610:	3885c83a 	sub	r2,r7,r2
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);

  seg->p->len -= len;
    c614:	2180028d 	sth	r6,10(r4)
  seg->p->tot_len -= len;
    c618:	2080020d 	sth	r2,8(r4)

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
    c61c:	e000040d 	sth	zero,16(fp)
      seg->tcphdr->chksum = chksum_slow;
    }
#endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
  }
#else /* TCP_CHECKSUM_ON_COPY */
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
    c620:	10bfffcc 	andi	r2,r2,65535
    c624:	900d883a 	mov	r6,r18
    c628:	b80f883a 	mov	r7,r23
    c62c:	d8800015 	stw	r2,0(sp)
    c630:	0003e800 	call	3e80 <inet_chksum_pseudo>
         &(pcb->remote_ip),
         IP_PROTO_TCP, seg->p->tot_len);
#endif /* TCP_CHECKSUM_ON_COPY */
#endif /* CHECKSUM_GEN_TCP */
  TCP_STATS_INC(tcp.xmit);
    c634:	9940240b 	ldhu	r5,144(r19)
      seg->tcphdr->chksum = chksum_slow;
    }
#endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
  }
#else /* TCP_CHECKSUM_ON_COPY */
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
    c638:	e080040d 	sth	r2,16(fp)

#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
    c63c:	89000117 	ldw	r4,4(r17)
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
         &(pcb->remote_ip),
         IP_PROTO_TCP, seg->p->tot_len);
#endif /* TCP_CHECKSUM_ON_COPY */
#endif /* CHECKSUM_GEN_TCP */
  TCP_STATS_INC(tcp.xmit);
    c640:	29400044 	addi	r5,r5,1
    c644:	9940240d 	sth	r5,144(r19)

#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
    c648:	80800243 	ldbu	r2,9(r16)
    c64c:	81c00283 	ldbu	r7,10(r16)
    c650:	800b883a 	mov	r5,r16
    c654:	ddc00115 	stw	r23,4(sp)
    c658:	d8800015 	stw	r2,0(sp)
    c65c:	900d883a 	mov	r6,r18
    c660:	00048780 	call	4878 <ip_output>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }

    tcp_output_segment(seg, pcb);
    snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
    c664:	88c00317 	ldw	r3,12(r17)
    c668:	8980020b 	ldhu	r6,8(r17)
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
    c66c:	81401517 	ldw	r5,84(r16)
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }

    tcp_output_segment(seg, pcb);
    snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
    c670:	1900018b 	ldhu	r4,6(r3)
    c674:	1880010b 	ldhu	r2,4(r3)
    c678:	1a40030b 	ldhu	r9,12(r3)
    c67c:	2006943a 	slli	r3,r4,16
    c680:	4812d23a 	srli	r9,r9,8
    c684:	1884b03a 	or	r2,r3,r2
    c688:	1014963a 	slli	r10,r2,24
    c68c:	100ed63a 	srli	r7,r2,24
    c690:	1008d23a 	srli	r4,r2,8
    c694:	10bfc00c 	andi	r2,r2,65280
    c698:	1006923a 	slli	r3,r2,8
    c69c:	51ceb03a 	or	r7,r10,r7
    c6a0:	213fc00c 	andi	r4,r4,65280
    c6a4:	488000cc 	andi	r2,r9,3
    c6a8:	3908b03a 	or	r4,r7,r4
    c6ac:	1004c03a 	cmpne	r2,r2,zero
    c6b0:	20c8b03a 	or	r4,r4,r3
    c6b4:	3085883a 	add	r2,r6,r2
    c6b8:	1107883a 	add	r3,r2,r4
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
    c6bc:	28cbc83a 	sub	r5,r5,r3
    c6c0:	28003b16 	blt	r5,zero,c7b0 <tcp_output+0x424>
      pcb->snd_nxt = snd_nxt;
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
    c6c4:	10003c26 	beq	r2,zero,c7b8 <tcp_output+0x42c>
      seg->next = NULL;
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
    c6c8:	80801d17 	ldw	r2,116(r16)
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
      pcb->snd_nxt = snd_nxt;
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
      seg->next = NULL;
    c6cc:	88000015 	stw	zero,0(r17)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
    c6d0:	10008826 	beq	r2,zero,c8f4 <tcp_output+0x568>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
    c6d4:	b0c00317 	ldw	r3,12(r22)
    c6d8:	1940018b 	ldhu	r5,6(r3)
    c6dc:	18c0010b 	ldhu	r3,4(r3)
    c6e0:	280a943a 	slli	r5,r5,16
    c6e4:	28c6b03a 	or	r3,r5,r3
    c6e8:	180e963a 	slli	r7,r3,24
    c6ec:	180cd63a 	srli	r6,r3,24
    c6f0:	180ad23a 	srli	r5,r3,8
    c6f4:	18ffc00c 	andi	r3,r3,65280
    c6f8:	1806923a 	slli	r3,r3,8
    c6fc:	398cb03a 	or	r6,r7,r6
    c700:	297fc00c 	andi	r5,r5,65280
    c704:	314ab03a 	or	r5,r6,r5
    c708:	28c6b03a 	or	r3,r5,r3
    c70c:	20c7c83a 	sub	r3,r4,r3
    c710:	18005016 	blt	r3,zero,c854 <tcp_output+0x4c8>
          }
          seg->next = (*cur_seg);
          (*cur_seg) = seg;
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
    c714:	b4400015 	stw	r17,0(r22)
    c718:	882d883a 	mov	r22,r17
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
    c71c:	84401c17 	ldw	r17,112(r16)
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
    c720:	88002926 	beq	r17,zero,c7c8 <tcp_output+0x43c>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    c724:	88800317 	ldw	r2,12(r17)
    c728:	8980020b 	ldhu	r6,8(r17)
    c72c:	81001317 	ldw	r4,76(r16)
    c730:	1140018b 	ldhu	r5,6(r2)
    c734:	10c0010b 	ldhu	r3,4(r2)
    c738:	3109c83a 	sub	r4,r6,r4
    c73c:	280a943a 	slli	r5,r5,16
    c740:	28c6b03a 	or	r3,r5,r3
    c744:	180e963a 	slli	r7,r3,24
    c748:	180cd63a 	srli	r6,r3,24
    c74c:	180ad23a 	srli	r5,r3,8
    c750:	18ffc00c 	andi	r3,r3,65280
    c754:	1806923a 	slli	r3,r3,8
    c758:	398cb03a 	or	r6,r7,r6
    c75c:	297fc00c 	andi	r5,r5,65280
    c760:	314ab03a 	or	r5,r6,r5
    c764:	28c6b03a 	or	r3,r5,r3
    c768:	20c7883a 	add	r3,r4,r3
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
    c76c:	a0ff642e 	bgeu	r20,r3,c500 <tcp_output+0x174>
    c770:	80c00883 	ldbu	r3,34(r16)
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
  }
#endif /* TCP_OVERSIZE */

  pcb->flags &= ~TF_NAGLEMEMERR;
    c774:	18c01fcc 	andi	r3,r3,127
    c778:	80c00885 	stb	r3,34(r16)
  return ERR_OK;
}
    c77c:	0005883a 	mov	r2,zero
    c780:	dfc00c17 	ldw	ra,48(sp)
    c784:	df000b17 	ldw	fp,44(sp)
    c788:	ddc00a17 	ldw	r23,40(sp)
    c78c:	dd800917 	ldw	r22,36(sp)
    c790:	dd400817 	ldw	r21,32(sp)
    c794:	dd000717 	ldw	r20,28(sp)
    c798:	dcc00617 	ldw	r19,24(sp)
    c79c:	dc800517 	ldw	r18,20(sp)
    c7a0:	dc400417 	ldw	r17,16(sp)
    c7a4:	dc000317 	ldw	r16,12(sp)
    c7a8:	dec00d04 	addi	sp,sp,52
    c7ac:	f800283a 	ret
    }

    tcp_output_segment(seg, pcb);
    snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
      pcb->snd_nxt = snd_nxt;
    c7b0:	80c01515 	stw	r3,84(r16)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
    c7b4:	103fc41e 	bne	r2,zero,c6c8 <tcp_output+0x33c>
          useg = useg->next;
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
    c7b8:	8809883a 	mov	r4,r17
    c7bc:	0007ed80 	call	7ed8 <tcp_seg_free>
    }
    seg = pcb->unsent;
    c7c0:	84401c17 	ldw	r17,112(r16)
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
    c7c4:	883fd71e 	bne	r17,zero,c724 <tcp_output+0x398>
    c7c8:	80c00883 	ldbu	r3,34(r16)
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
  }
#endif /* TCP_OVERSIZE */

  pcb->flags &= ~TF_NAGLEMEMERR;
    c7cc:	18c01fcc 	andi	r3,r3,127
    seg = pcb->unsent;
  }
#if TCP_OVERSIZE
  if (pcb->unsent == NULL) {
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
    c7d0:	80001b8d 	sth	zero,110(r16)
  }
#endif /* TCP_OVERSIZE */

  pcb->flags &= ~TF_NAGLEMEMERR;
    c7d4:	80c00885 	stb	r3,34(r16)
    c7d8:	003fe806 	br	c77c <tcp_output+0x3f0>
    }
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
  }

  if (pcb->rttest == 0) {
    pcb->rttest = tcp_ticks;
    c7dc:	a8800017 	ldw	r2,0(r21)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
    c7e0:	8f000317 	ldw	fp,12(r17)
    }
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
  }

  if (pcb->rttest == 0) {
    pcb->rttest = tcp_ticks;
    c7e4:	80800f15 	stw	r2,60(r16)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
    c7e8:	e0c0018b 	ldhu	r3,6(fp)
    c7ec:	e080010b 	ldhu	r2,4(fp)
    c7f0:	1806943a 	slli	r3,r3,16
    c7f4:	1884b03a 	or	r2,r3,r2
    c7f8:	100a963a 	slli	r5,r2,24
    c7fc:	1008d63a 	srli	r4,r2,24
    c800:	1006d23a 	srli	r3,r2,8
    c804:	10bfc00c 	andi	r2,r2,65280
    c808:	1004923a 	slli	r2,r2,8
    c80c:	2908b03a 	or	r4,r5,r4
    c810:	18ffc00c 	andi	r3,r3,65280
    c814:	20c6b03a 	or	r3,r4,r3
    c818:	1884b03a 	or	r2,r3,r2
    c81c:	80801015 	stw	r2,64(r16)
    c820:	003f7206 	br	c5ec <tcp_output+0x260>
#endif

  /* Set retransmission timer running if it is not currently enabled 
     This must be set before checking the route. */
  if (pcb->rtime == -1) {
    pcb->rtime = 0;
    c824:	80000e0d 	sth	zero,56(r16)
    c828:	003f6606 	br	c5c4 <tcp_output+0x238>
     packets, so ignore it here */
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
  if (seg->flags & TF_SEG_OPTS_MSS) {
    u16_t mss;
#if TCP_CALCULATE_EFF_SEND_MSS
    mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
    c82c:	01016d04 	movi	r4,1460
    c830:	900b883a 	mov	r5,r18
    c834:	000916c0 	call	916c <tcp_eff_send_mss>
#else /* TCP_CALCULATE_EFF_SEND_MSS */
    mss = TCP_MSS;
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
    *opts = TCP_BUILD_MSS_OPTION(mss);
    c838:	1006963a 	slli	r3,r2,24
    c83c:	10bfc00c 	andi	r2,r2,65280
    c840:	1004923a 	slli	r2,r2,8
    c844:	18c10094 	ori	r3,r3,1026
    c848:	1884b03a 	or	r2,r3,r2
    c84c:	e0800515 	stw	r2,20(fp)
    c850:	003f5906 	br	c5b8 <tcp_output+0x22c>
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    c854:	10c00317 	ldw	r3,12(r2)
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
    c858:	da400217 	ldw	r9,8(sp)
          while (*cur_seg &&
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    c85c:	1940018b 	ldhu	r5,6(r3)
    c860:	18c0010b 	ldhu	r3,4(r3)
    c864:	280a943a 	slli	r5,r5,16
    c868:	28c6b03a 	or	r3,r5,r3
    c86c:	180ed63a 	srli	r7,r3,24
    c870:	180c963a 	slli	r6,r3,24
    c874:	197fc00c 	andi	r5,r3,65280
    c878:	280a923a 	slli	r5,r5,8
    c87c:	1806d23a 	srli	r3,r3,8
    c880:	398cb03a 	or	r6,r7,r6
    c884:	314ab03a 	or	r5,r6,r5
    c888:	18ffc00c 	andi	r3,r3,65280
    c88c:	28c6b03a 	or	r3,r5,r3
    c890:	1907c83a 	sub	r3,r3,r4
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
    c894:	18001116 	blt	r3,zero,c8dc <tcp_output+0x550>
    c898:	00001306 	br	c8e8 <tcp_output+0x55c>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    c89c:	10c00317 	ldw	r3,12(r2)
    c8a0:	1940018b 	ldhu	r5,6(r3)
    c8a4:	18c0010b 	ldhu	r3,4(r3)
    c8a8:	280a943a 	slli	r5,r5,16
    c8ac:	28c6b03a 	or	r3,r5,r3
    c8b0:	180e963a 	slli	r7,r3,24
    c8b4:	180cd63a 	srli	r6,r3,24
    c8b8:	180ad23a 	srli	r5,r3,8
    c8bc:	18ffc00c 	andi	r3,r3,65280
    c8c0:	1806923a 	slli	r3,r3,8
    c8c4:	398cb03a 	or	r6,r7,r6
    c8c8:	297fc00c 	andi	r5,r5,65280
    c8cc:	314ab03a 	or	r5,r6,r5
    c8d0:	28c6b03a 	or	r3,r5,r3
    c8d4:	1907c83a 	sub	r3,r3,r4
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
    c8d8:	1800030e 	bge	r3,zero,c8e8 <tcp_output+0x55c>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
              cur_seg = &((*cur_seg)->next );
    c8dc:	1013883a 	mov	r9,r2
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
    c8e0:	10800017 	ldw	r2,0(r2)
    c8e4:	103fed1e 	bne	r2,zero,c89c <tcp_output+0x510>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
              cur_seg = &((*cur_seg)->next );
          }
          seg->next = (*cur_seg);
    c8e8:	88800015 	stw	r2,0(r17)
          (*cur_seg) = seg;
    c8ec:	4c400015 	stw	r17,0(r9)
    c8f0:	003f8a06 	br	c71c <tcp_output+0x390>
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
      seg->next = NULL;
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
        pcb->unacked = seg;
    c8f4:	84401d15 	stw	r17,116(r16)
    c8f8:	882d883a 	mov	r22,r17
    c8fc:	003f8706 	br	c71c <tcp_output+0x390>
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
    c900:	8980020b 	ldhu	r6,8(r17)
    c904:	81400e8b 	ldhu	r5,58(r16)
    c908:	317f092e 	bgeu	r6,r5,c530 <tcp_output+0x1a4>
    c90c:	81401a8b 	ldhu	r5,106(r16)
    c910:	283f0726 	beq	r5,zero,c530 <tcp_output+0x1a4>
    c914:	81401b0b 	ldhu	r5,108(r16)
    c918:	01800ac4 	movi	r6,43
    c91c:	317f0436 	bltu	r6,r5,c530 <tcp_output+0x1a4>
    c920:	1940280c 	andi	r5,r3,160
    c924:	283f021e 	bne	r5,zero,c530 <tcp_output+0x1a4>
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }
#if TCP_OVERSIZE
  if (pcb->unsent == NULL) {
    c928:	883fa826 	beq	r17,zero,c7cc <tcp_output+0x440>
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
  }
#endif /* TCP_OVERSIZE */

  pcb->flags &= ~TF_NAGLEMEMERR;
    c92c:	18c01fcc 	andi	r3,r3,127
    c930:	80c00885 	stb	r3,34(r16)
    c934:	003f9106 	br	c77c <tcp_output+0x3f0>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
    c938:	80c00883 	ldbu	r3,34(r16)
    c93c:	1029883a 	mov	r20,r2
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);

  seg = pcb->unsent;
    c940:	84401c17 	ldw	r17,112(r16)
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
    c944:	1880008c 	andi	r2,r3,2
    c948:	10803fcc 	andi	r2,r2,255
    c94c:	103ecb26 	beq	r2,zero,c47c <tcp_output+0xf0>
    c950:	003ea906 	br	c3f8 <tcp_output+0x6c>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
    c954:	010000b4 	movhi	r4,2
    c958:	210d4b04 	addi	r4,r4,13612
    c95c:	014000b4 	movhi	r5,2
    c960:	29573804 	addi	r5,r5,23776
    c964:	0180f144 	movi	r6,965
    c968:	01c000b4 	movhi	r7,2
    c96c:	39d67004 	addi	r7,r7,22976
    c970:	00104380 	call	10438 <printf>
    c974:	003fff06 	br	c974 <tcp_output+0x5e8>
#if TCP_CWND_DEBUG
  s16_t i = 0;
#endif /* TCP_CWND_DEBUG */

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_output for listen-pcbs",
    c978:	010000b4 	movhi	r4,2
    c97c:	210d4b04 	addi	r4,r4,13612
    c980:	014000b4 	movhi	r5,2
    c984:	29572e04 	addi	r5,r5,23736
    c988:	0180e304 	movi	r6,908
    c98c:	01c000b4 	movhi	r7,2
    c990:	39d67004 	addi	r7,r7,22976
    c994:	00104380 	call	10438 <printf>
    c998:	003fff06 	br	c998 <tcp_output+0x60c>

0000c99c <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  ip_addr_t *local_ip, ip_addr_t *remote_ip,
  u16_t local_port, u16_t remote_port)
{
    c99c:	defff604 	addi	sp,sp,-40
    c9a0:	dd000615 	stw	r20,24(sp)
    c9a4:	dc800415 	stw	r18,16(sp)
    c9a8:	dc000215 	stw	r16,8(sp)
    c9ac:	2025883a 	mov	r18,r4
    c9b0:	2821883a 	mov	r16,r5
    c9b4:	3029883a 	mov	r20,r6
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
    c9b8:	01000044 	movi	r4,1
    c9bc:	01400504 	movi	r5,20
    c9c0:	000d883a 	mov	r6,zero
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  ip_addr_t *local_ip, ip_addr_t *remote_ip,
  u16_t local_port, u16_t remote_port)
{
    c9c4:	dd800815 	stw	r22,32(sp)
    c9c8:	dd400715 	stw	r21,28(sp)
    c9cc:	dcc00515 	stw	r19,20(sp)
    c9d0:	dc400315 	stw	r17,12(sp)
    c9d4:	dfc00915 	stw	ra,36(sp)
    c9d8:	3827883a 	mov	r19,r7
    c9dc:	dd800a0b 	ldhu	r22,40(sp)
    c9e0:	dd400b0b 	ldhu	r21,44(sp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
    c9e4:	0006a880 	call	6a88 <pbuf_alloc>
    c9e8:	1023883a 	mov	r17,r2
  if (p == NULL) {
    c9ec:	10005526 	beq	r2,zero,cb44 <tcp_rst+0x1a8>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
    c9f0:	1080028b 	ldhu	r2,10(r2)
    c9f4:	00c004c4 	movi	r3,19
    c9f8:	18800936 	bltu	r3,r2,ca20 <tcp_rst+0x84>
    c9fc:	010000b4 	movhi	r4,2
    ca00:	210d4b04 	addi	r4,r4,13612
    ca04:	014000b4 	movhi	r5,2
    ca08:	29567604 	addi	r5,r5,23000
    ca0c:	01812dc4 	movi	r6,1207
    ca10:	01c000b4 	movhi	r7,2
    ca14:	39d67004 	addi	r7,r7,22976
    ca18:	00104380 	call	10438 <printf>
    ca1c:	003fff06 	br	ca1c <tcp_rst+0x80>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
  tcphdr->src = htons(local_port);
  tcphdr->dest = htons(remote_port);
  tcphdr->seqno = htonl(seqno);
    ca20:	9012963a 	slli	r9,r18,24
  tcphdr->ackno = htonl(ackno);
    ca24:	8010963a 	slli	r8,r16,24
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
  tcphdr->src = htons(local_port);
  tcphdr->dest = htons(remote_port);
  tcphdr->seqno = htonl(seqno);
    ca28:	900ed63a 	srli	r7,r18,24
    ca2c:	900ad23a 	srli	r5,r18,8
  tcphdr->ackno = htonl(ackno);
    ca30:	800cd63a 	srli	r6,r16,24
    ca34:	8008d23a 	srli	r4,r16,8
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
  tcphdr->src = htons(local_port);
  tcphdr->dest = htons(remote_port);
  tcphdr->seqno = htonl(seqno);
    ca38:	90ffc00c 	andi	r3,r18,65280
  tcphdr->ackno = htonl(ackno);
    ca3c:	80bfc00c 	andi	r2,r16,65280
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
  tcphdr->src = htons(local_port);
  tcphdr->dest = htons(remote_port);
  tcphdr->seqno = htonl(seqno);
    ca40:	1806923a 	slli	r3,r3,8
  tcphdr->ackno = htonl(ackno);
    ca44:	1004923a 	slli	r2,r2,8
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
  tcphdr->src = htons(local_port);
  tcphdr->dest = htons(remote_port);
  tcphdr->seqno = htonl(seqno);
    ca48:	49ceb03a 	or	r7,r9,r7
  tcphdr->ackno = htonl(ackno);
    ca4c:	418cb03a 	or	r6,r8,r6
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
  tcphdr->src = htons(local_port);
  tcphdr->dest = htons(remote_port);
  tcphdr->seqno = htonl(seqno);
    ca50:	297fc00c 	andi	r5,r5,65280
  tcphdr->ackno = htonl(ackno);
    ca54:	213fc00c 	andi	r4,r4,65280
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
  tcphdr->src = htons(local_port);
  tcphdr->dest = htons(remote_port);
  tcphdr->seqno = htonl(seqno);
    ca58:	394ab03a 	or	r5,r7,r5
  tcphdr->ackno = htonl(ackno);
    ca5c:	3108b03a 	or	r4,r6,r4
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
  tcphdr->src = htons(local_port);
  tcphdr->dest = htons(remote_port);
  tcphdr->seqno = htonl(seqno);
    ca60:	28c6b03a 	or	r3,r5,r3
  tcphdr->ackno = htonl(ackno);
    ca64:	2084b03a 	or	r2,r4,r2
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
  tcphdr->src = htons(local_port);
  tcphdr->dest = htons(remote_port);
    ca68:	a93fffcc 	andi	r4,r21,65535
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
    ca6c:	8c000117 	ldw	r16,4(r17)
  tcphdr->src = htons(local_port);
  tcphdr->dest = htons(remote_port);
  tcphdr->seqno = htonl(seqno);
    ca70:	1812d43a 	srli	r9,r3,16
  tcphdr->ackno = htonl(ackno);
    ca74:	1010d43a 	srli	r8,r2,16
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
  tcphdr->src = htons(local_port);
  tcphdr->dest = htons(remote_port);
    ca78:	200c923a 	slli	r6,r4,8
    ca7c:	2008d23a 	srli	r4,r4,8
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
  tcphdr->src = htons(local_port);
    ca80:	b17fffcc 	andi	r5,r22,65535
    ca84:	280e923a 	slli	r7,r5,8
    ca88:	280ad23a 	srli	r5,r5,8
  tcphdr->dest = htons(remote_port);
  tcphdr->seqno = htonl(seqno);
    ca8c:	80c0010d 	sth	r3,4(r16)
    ca90:	8240018d 	sth	r9,6(r16)
  tcphdr->ackno = htonl(ackno);
    ca94:	8200028d 	sth	r8,10(r16)
    ca98:	8080020d 	sth	r2,8(r16)
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
  tcphdr->src = htons(local_port);
  tcphdr->dest = htons(remote_port);
    ca9c:	3106b03a 	or	r3,r6,r4
  tcphdr->wnd = PP_HTONS(TCP_WND);
  tcphdr->chksum = 0;
  tcphdr->urgp = 0;

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
    caa0:	8880020b 	ldhu	r2,8(r17)
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
  tcphdr->src = htons(local_port);
  tcphdr->dest = htons(remote_port);
    caa4:	80c0008d 	sth	r3,2(r16)
  tcphdr->seqno = htonl(seqno);
  tcphdr->ackno = htonl(ackno);
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
    caa8:	00c51404 	movi	r3,5200
    caac:	80c0030d 	sth	r3,12(r16)
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
  tcphdr->src = htons(local_port);
    cab0:	394ab03a 	or	r5,r7,r5
  tcphdr->dest = htons(remote_port);
  tcphdr->seqno = htonl(seqno);
  tcphdr->ackno = htonl(ackno);
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
  tcphdr->wnd = PP_HTONS(TCP_WND);
    cab4:	00c00204 	movi	r3,8
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
  tcphdr->src = htons(local_port);
    cab8:	8140000d 	sth	r5,0(r16)
  tcphdr->dest = htons(remote_port);
  tcphdr->seqno = htonl(seqno);
  tcphdr->ackno = htonl(ackno);
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
  tcphdr->wnd = PP_HTONS(TCP_WND);
    cabc:	80c0038d 	sth	r3,14(r16)
  tcphdr->chksum = 0;
    cac0:	8000040d 	sth	zero,16(r16)
  tcphdr->urgp = 0;
    cac4:	8000048d 	sth	zero,18(r16)

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
    cac8:	04800184 	movi	r18,6
    cacc:	8809883a 	mov	r4,r17
    cad0:	a00b883a 	mov	r5,r20
    cad4:	980d883a 	mov	r6,r19
    cad8:	900f883a 	mov	r7,r18
    cadc:	d8800015 	stw	r2,0(sp)
    cae0:	0003e800 	call	3e80 <inet_chksum_pseudo>
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
    cae4:	00c001f4 	movhi	r3,7
    cae8:	18d44804 	addi	r3,r3,20768
    caec:	1900240b 	ldhu	r4,144(r3)
  tcphdr->wnd = PP_HTONS(TCP_WND);
  tcphdr->chksum = 0;
  tcphdr->urgp = 0;

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
    caf0:	8080040d 	sth	r2,16(r16)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
    caf4:	d8000015 	stw	zero,0(sp)

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
    caf8:	20800044 	addi	r2,r4,1
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
    cafc:	dc800115 	stw	r18,4(sp)
    cb00:	8809883a 	mov	r4,r17
    cb04:	a00b883a 	mov	r5,r20
    cb08:	980d883a 	mov	r6,r19
    cb0c:	01c03fc4 	movi	r7,255

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
    cb10:	1880240d 	sth	r2,144(r3)
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
    cb14:	00048780 	call	4878 <ip_output>
  pbuf_free(p);
    cb18:	8809883a 	mov	r4,r17
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
    cb1c:	dfc00917 	ldw	ra,36(sp)
    cb20:	dd800817 	ldw	r22,32(sp)
    cb24:	dd400717 	ldw	r21,28(sp)
    cb28:	dd000617 	ldw	r20,24(sp)
    cb2c:	dcc00517 	ldw	r19,20(sp)
    cb30:	dc800417 	ldw	r18,16(sp)
    cb34:	dc400317 	ldw	r17,12(sp)
    cb38:	dc000217 	ldw	r16,8(sp)
    cb3c:	dec00a04 	addi	sp,sp,40
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  pbuf_free(p);
    cb40:	00067d81 	jmpi	67d8 <pbuf_free>
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
    cb44:	dfc00917 	ldw	ra,36(sp)
    cb48:	dd800817 	ldw	r22,32(sp)
    cb4c:	dd400717 	ldw	r21,28(sp)
    cb50:	dd000617 	ldw	r20,24(sp)
    cb54:	dcc00517 	ldw	r19,20(sp)
    cb58:	dc800417 	ldw	r18,16(sp)
    cb5c:	dc400317 	ldw	r17,12(sp)
    cb60:	dc000217 	ldw	r16,8(sp)
    cb64:	dec00a04 	addi	sp,sp,40
    cb68:	f800283a 	ret

0000cb6c <tcp_rexmit_rto>:
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
    cb6c:	21801d17 	ldw	r6,116(r4)
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
    cb70:	200b883a 	mov	r5,r4
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
    cb74:	30000f26 	beq	r6,zero,cbb4 <tcp_rexmit_rto+0x48>
    cb78:	3007883a 	mov	r3,r6
    cb7c:	00000106 	br	cb84 <tcp_rexmit_rto+0x18>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
    cb80:	1007883a 	mov	r3,r2
    cb84:	18800017 	ldw	r2,0(r3)
    cb88:	103ffd1e 	bne	r2,zero,cb80 <tcp_rexmit_rto+0x14>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
    cb8c:	28801c17 	ldw	r2,112(r5)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;

  /* Do the actual retransmission */
  tcp_output(pcb);
    cb90:	2809883a 	mov	r4,r5
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
    cb94:	18800015 	stw	r2,0(r3)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  /* last unsent hasn't changed, no need to reset unsent_oversize */

  /* increment number of retransmissions */
  ++pcb->nrtx;
    cb98:	28801283 	ldbu	r2,74(r5)
  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
    cb9c:	29801c15 	stw	r6,112(r5)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
    cba0:	28001d15 	stw	zero,116(r5)
  /* last unsent hasn't changed, no need to reset unsent_oversize */

  /* increment number of retransmissions */
  ++pcb->nrtx;
    cba4:	10800044 	addi	r2,r2,1
    cba8:	28801285 	stb	r2,74(r5)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
    cbac:	28000f15 	stw	zero,60(r5)

  /* Do the actual retransmission */
  tcp_output(pcb);
    cbb0:	000c38c1 	jmpi	c38c <tcp_output>
    cbb4:	f800283a 	ret

0000cbb8 <tcp_rexmit>:
tcp_rexmit(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
    cbb8:	22c01d17 	ldw	r11,116(r4)
    cbbc:	58002f26 	beq	r11,zero,cc7c <tcp_rexmit+0xc4>
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;
    cbc0:	58c00017 	ldw	r3,0(r11)

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
    cbc4:	20801c17 	ldw	r2,112(r4)
  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
    cbc8:	22401c04 	addi	r9,r4,112
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;
    cbcc:	20c01d15 	stw	r3,116(r4)

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
    cbd0:	10002226 	beq	r2,zero,cc5c <tcp_rexmit+0xa4>
    cbd4:	59400317 	ldw	r5,12(r11)
    cbd8:	28c0018b 	ldhu	r3,6(r5)
    cbdc:	2940010b 	ldhu	r5,4(r5)
    cbe0:	1806943a 	slli	r3,r3,16
    cbe4:	1946b03a 	or	r3,r3,r5
    cbe8:	180cd63a 	srli	r6,r3,24
    cbec:	180ad23a 	srli	r5,r3,8
    cbf0:	1814963a 	slli	r10,r3,24
    cbf4:	18ffc00c 	andi	r3,r3,65280
    cbf8:	1806923a 	slli	r3,r3,8
    cbfc:	297fc00c 	andi	r5,r5,65280
    cc00:	5194b03a 	or	r10,r10,r6
    cc04:	5154b03a 	or	r10,r10,r5
    cc08:	50d4b03a 	or	r10,r10,r3
    cc0c:	00000306 	br	cc1c <tcp_rexmit+0x64>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
    cc10:	1013883a 	mov	r9,r2
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
    cc14:	10800017 	ldw	r2,0(r2)
    cc18:	10001026 	beq	r2,zero,cc5c <tcp_rexmit+0xa4>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    cc1c:	11400317 	ldw	r5,12(r2)
    cc20:	28c0018b 	ldhu	r3,6(r5)
    cc24:	2940010b 	ldhu	r5,4(r5)
    cc28:	1806943a 	slli	r3,r3,16
    cc2c:	1946b03a 	or	r3,r3,r5
    cc30:	1810963a 	slli	r8,r3,24
    cc34:	180ed63a 	srli	r7,r3,24
    cc38:	180cd23a 	srli	r6,r3,8
    cc3c:	18ffc00c 	andi	r3,r3,65280
    cc40:	180a923a 	slli	r5,r3,8
    cc44:	31bfc00c 	andi	r6,r6,65280
    cc48:	41c6b03a 	or	r3,r8,r7
    cc4c:	1986b03a 	or	r3,r3,r6
    cc50:	1946b03a 	or	r3,r3,r5
    cc54:	1a87c83a 	sub	r3,r3,r10
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
    cc58:	183fed16 	blt	r3,zero,cc10 <tcp_rexmit+0x58>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
  }
  seg->next = *cur_seg;
    cc5c:	58800015 	stw	r2,0(r11)
  *cur_seg = seg;
    cc60:	4ac00015 	stw	r11,0(r9)
#if TCP_OVERSIZE
  if (seg->next == NULL) {
    cc64:	58800017 	ldw	r2,0(r11)
    cc68:	10000526 	beq	r2,zero,cc80 <tcp_rexmit+0xc8>
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
  }
#endif /* TCP_OVERSIZE */

  ++pcb->nrtx;
    cc6c:	20801283 	ldbu	r2,74(r4)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
    cc70:	20000f15 	stw	zero,60(r4)
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
  }
#endif /* TCP_OVERSIZE */

  ++pcb->nrtx;
    cc74:	10800044 	addi	r2,r2,1
    cc78:	20801285 	stb	r2,74(r4)
    cc7c:	f800283a 	ret
  seg->next = *cur_seg;
  *cur_seg = seg;
#if TCP_OVERSIZE
  if (seg->next == NULL) {
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
    cc80:	20001b8d 	sth	zero,110(r4)
    cc84:	003ff906 	br	cc6c <tcp_rexmit+0xb4>

0000cc88 <tcp_rexmit_fast>:
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void 
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
    cc88:	20801d17 	ldw	r2,116(r4)
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void 
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
    cc8c:	defffe04 	addi	sp,sp,-8
    cc90:	dc000015 	stw	r16,0(sp)
    cc94:	dfc00115 	stw	ra,4(sp)
    cc98:	2021883a 	mov	r16,r4
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
    cc9c:	10000426 	beq	r2,zero,ccb0 <tcp_rexmit_fast+0x28>
    cca0:	20800883 	ldbu	r2,34(r4)
    cca4:	1080010c 	andi	r2,r2,4
    cca8:	10803fcc 	andi	r2,r2,255
    ccac:	10000426 	beq	r2,zero,ccc0 <tcp_rexmit_fast+0x38>
    }
    
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
    pcb->flags |= TF_INFR;
  } 
}
    ccb0:	dfc00117 	ldw	ra,4(sp)
    ccb4:	dc000017 	ldw	r16,0(sp)
    ccb8:	dec00204 	addi	sp,sp,8
    ccbc:	f800283a 	ret
    LWIP_DEBUGF(TCP_FR_DEBUG, 
                ("tcp_receive: dupacks %"U16_F" (%"U32_F
                 "), fast retransmit %"U32_F"\n",
                 (u16_t)pcb->dupacks, pcb->lastack,
                 ntohl(pcb->unacked->tcphdr->seqno)));
    tcp_rexmit(pcb);
    ccc0:	000cbb80 	call	cbb8 <tcp_rexmit>

    /* Set ssthresh to half of the minimum of the current
     * cwnd and the advertised window */
    if (pcb->cwnd > pcb->snd_wnd) {
    ccc4:	8080140b 	ldhu	r2,80(r16)
    ccc8:	80c0190b 	ldhu	r3,100(r16)
    cccc:	18801336 	bltu	r3,r2,cd1c <tcp_rexmit_fast+0x94>
      pcb->ssthresh = pcb->snd_wnd / 2;
    } else {
      pcb->ssthresh = pcb->cwnd / 2;
    ccd0:	1004d07a 	srli	r2,r2,1
    ccd4:	1007883a 	mov	r3,r2
    ccd8:	8080148d 	sth	r2,82(r16)
    }
    
    /* The minimum value for ssthresh should be 2 MSS */
    if (pcb->ssthresh < 2*pcb->mss) {
    ccdc:	80800e8b 	ldhu	r2,58(r16)
    cce0:	197fffcc 	andi	r5,r3,65535
    cce4:	113fffcc 	andi	r4,r2,65535
    cce8:	2109883a 	add	r4,r4,r4
    ccec:	29001316 	blt	r5,r4,cd3c <tcp_rexmit_fast+0xb4>
    ccf0:	1089883a 	add	r4,r2,r2
                   pcb->ssthresh, 2*pcb->mss));
      pcb->ssthresh = 2*pcb->mss;
    }
    
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
    pcb->flags |= TF_INFR;
    ccf4:	81400883 	ldbu	r5,34(r16)
                   " should be min 2 mss %"U16_F"...\n",
                   pcb->ssthresh, 2*pcb->mss));
      pcb->ssthresh = 2*pcb->mss;
    }
    
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
    ccf8:	2085883a 	add	r2,r4,r2
    ccfc:	1887883a 	add	r3,r3,r2
    pcb->flags |= TF_INFR;
    cd00:	29400114 	ori	r5,r5,4
                   " should be min 2 mss %"U16_F"...\n",
                   pcb->ssthresh, 2*pcb->mss));
      pcb->ssthresh = 2*pcb->mss;
    }
    
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
    cd04:	80c0140d 	sth	r3,80(r16)
    pcb->flags |= TF_INFR;
    cd08:	81400885 	stb	r5,34(r16)
  } 
}
    cd0c:	dfc00117 	ldw	ra,4(sp)
    cd10:	dc000017 	ldw	r16,0(sp)
    cd14:	dec00204 	addi	sp,sp,8
    cd18:	f800283a 	ret
    tcp_rexmit(pcb);

    /* Set ssthresh to half of the minimum of the current
     * cwnd and the advertised window */
    if (pcb->cwnd > pcb->snd_wnd) {
      pcb->ssthresh = pcb->snd_wnd / 2;
    cd1c:	1804d07a 	srli	r2,r3,1
    cd20:	1007883a 	mov	r3,r2
    cd24:	8080148d 	sth	r2,82(r16)
    } else {
      pcb->ssthresh = pcb->cwnd / 2;
    }
    
    /* The minimum value for ssthresh should be 2 MSS */
    if (pcb->ssthresh < 2*pcb->mss) {
    cd28:	80800e8b 	ldhu	r2,58(r16)
    cd2c:	197fffcc 	andi	r5,r3,65535
    cd30:	113fffcc 	andi	r4,r2,65535
    cd34:	2109883a 	add	r4,r4,r4
    cd38:	293fed0e 	bge	r5,r4,ccf0 <tcp_rexmit_fast+0x68>
      LWIP_DEBUGF(TCP_FR_DEBUG, 
                  ("tcp_receive: The minimum value for ssthresh %"U16_F
                   " should be min 2 mss %"U16_F"...\n",
                   pcb->ssthresh, 2*pcb->mss));
      pcb->ssthresh = 2*pcb->mss;
    cd3c:	1089883a 	add	r4,r2,r2
    cd40:	2007883a 	mov	r3,r4
    cd44:	8100148d 	sth	r4,82(r16)
    cd48:	003fea06 	br	ccf4 <tcp_rexmit_fast+0x6c>

0000cd4c <tcp_keepalive>:
                          ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
    cd4c:	20801517 	ldw	r2,84(r4)
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
    cd50:	defff804 	addi	sp,sp,-32
                          ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
    cd54:	000b883a 	mov	r5,zero
    cd58:	10bfffc4 	addi	r2,r2,-1
    cd5c:	100e963a 	slli	r7,r2,24
    cd60:	100cd63a 	srli	r6,r2,24
    cd64:	1006d23a 	srli	r3,r2,8
    cd68:	10bfc00c 	andi	r2,r2,65280
    cd6c:	1004923a 	slli	r2,r2,8
    cd70:	398cb03a 	or	r6,r7,r6
    cd74:	18ffc00c 	andi	r3,r3,65280
    cd78:	30ccb03a 	or	r6,r6,r3
    cd7c:	308cb03a 	or	r6,r6,r2
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
    cd80:	dc400315 	stw	r17,12(sp)
    cd84:	dc000215 	stw	r16,8(sp)
    cd88:	dfc00715 	stw	ra,28(sp)
    cd8c:	dd000615 	stw	r20,24(sp)
    cd90:	dcc00515 	stw	r19,20(sp)
    cd94:	dc800415 	stw	r18,16(sp)
    cd98:	2023883a 	mov	r17,r4
                          ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
    cd9c:	000b6440 	call	b644 <tcp_output_alloc_header.constprop.0>
    cda0:	1021883a 	mov	r16,r2
  if(p == NULL) {
    cda4:	10002026 	beq	r2,zero,ce28 <tcp_keepalive+0xdc>
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
    cda8:	1080020b 	ldhu	r2,8(r2)
    cdac:	8c800104 	addi	r18,r17,4
    cdb0:	04c00184 	movi	r19,6
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
    cdb4:	85000117 	ldw	r20,4(r16)

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
    cdb8:	8009883a 	mov	r4,r16
    cdbc:	880b883a 	mov	r5,r17
    cdc0:	900d883a 	mov	r6,r18
    cdc4:	980f883a 	mov	r7,r19
    cdc8:	d8800015 	stw	r2,0(sp)
    cdcc:	0003e800 	call	3e80 <inet_chksum_pseudo>
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
    cdd0:	00c001f4 	movhi	r3,7
    cdd4:	18d44804 	addi	r3,r3,20768
    cdd8:	1900240b 	ldhu	r4,144(r3)
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
    cddc:	a080040d 	sth	r2,16(r20)
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
    cde0:	d8000015 	stw	zero,0(sp)

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
    cde4:	21000044 	addi	r4,r4,1
    cde8:	1900240d 	sth	r4,144(r3)
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
    cdec:	89c00283 	ldbu	r7,10(r17)
    cdf0:	8009883a 	mov	r4,r16
    cdf4:	dcc00115 	stw	r19,4(sp)
    cdf8:	880b883a 	mov	r5,r17
    cdfc:	900d883a 	mov	r6,r18
    ce00:	00048780 	call	4878 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
    ce04:	8009883a 	mov	r4,r16

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
    ce08:	dfc00717 	ldw	ra,28(sp)
    ce0c:	dd000617 	ldw	r20,24(sp)
    ce10:	dcc00517 	ldw	r19,20(sp)
    ce14:	dc800417 	ldw	r18,16(sp)
    ce18:	dc400317 	ldw	r17,12(sp)
    ce1c:	dc000217 	ldw	r16,8(sp)
    ce20:	dec00804 	addi	sp,sp,32
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
    ce24:	00067d81 	jmpi	67d8 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
    ce28:	dfc00717 	ldw	ra,28(sp)
    ce2c:	dd000617 	ldw	r20,24(sp)
    ce30:	dcc00517 	ldw	r19,20(sp)
    ce34:	dc800417 	ldw	r18,16(sp)
    ce38:	dc400317 	ldw	r17,12(sp)
    ce3c:	dc000217 	ldw	r16,8(sp)
    ce40:	dec00804 	addi	sp,sp,32
    ce44:	f800283a 	ret

0000ce48 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
    ce48:	defff804 	addi	sp,sp,-32
    ce4c:	dc800415 	stw	r18,16(sp)
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
    ce50:	24801d17 	ldw	r18,116(r4)
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
    ce54:	dc000215 	stw	r16,8(sp)
    ce58:	dfc00715 	stw	ra,28(sp)
    ce5c:	dd000615 	stw	r20,24(sp)
    ce60:	dcc00515 	stw	r19,20(sp)
    ce64:	dc400315 	stw	r17,12(sp)
    ce68:	2021883a 	mov	r16,r4
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;

  if(seg == NULL) {
    ce6c:	90004426 	beq	r18,zero,cf80 <tcp_zero_window_probe+0x138>
  }
  if(seg == NULL) {
    return;
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
    ce70:	90800317 	ldw	r2,12(r18)
    ce74:	10c0030b 	ldhu	r3,12(r2)
    ce78:	1806d23a 	srli	r3,r3,8
    ce7c:	18c0004c 	andi	r3,r3,1
    ce80:	1800311e 	bne	r3,zero,cf48 <tcp_zero_window_probe+0x100>
    ce84:	01400044 	movi	r5,1
    ce88:	0027883a 	mov	r19,zero
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;

  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
    ce8c:	1180018b 	ldhu	r6,6(r2)
    ce90:	1080010b 	ldhu	r2,4(r2)
    ce94:	8009883a 	mov	r4,r16
    ce98:	300c943a 	slli	r6,r6,16
    ce9c:	308cb03a 	or	r6,r6,r2
    cea0:	000b6440 	call	b644 <tcp_output_alloc_header.constprop.0>
    cea4:	1023883a 	mov	r17,r2
  if(p == NULL) {
    cea8:	10003726 	beq	r2,zero,cf88 <tcp_zero_window_probe+0x140>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;

  if (is_fin) {
    ceac:	98803fcc 	andi	r2,r19,255
  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
    ceb0:	8cc00117 	ldw	r19,4(r17)

  if (is_fin) {
    ceb4:	10002926 	beq	r2,zero,cf5c <tcp_zero_window_probe+0x114>
    /* FIN segment, no data */
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
    ceb8:	98c0030b 	ldhu	r3,12(r19)
    cebc:	00b03fc4 	movi	r2,-16129
    cec0:	1884703a 	and	r2,r3,r2
    cec4:	10844014 	ori	r2,r2,4352
    cec8:	9880030d 	sth	r2,12(r19)
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
  }

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
    cecc:	8880020b 	ldhu	r2,8(r17)
    ced0:	84800104 	addi	r18,r16,4
    ced4:	05000184 	movi	r20,6
    ced8:	8809883a 	mov	r4,r17
    cedc:	800b883a 	mov	r5,r16
    cee0:	900d883a 	mov	r6,r18
    cee4:	a00f883a 	mov	r7,r20
    cee8:	d8800015 	stw	r2,0(sp)
    ceec:	0003e800 	call	3e80 <inet_chksum_pseudo>
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
    cef0:	00c001f4 	movhi	r3,7
    cef4:	18d44804 	addi	r3,r3,20768
    cef8:	1900240b 	ldhu	r4,144(r3)
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
  }

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
    cefc:	9880040d 	sth	r2,16(r19)
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
    cf00:	d8000015 	stw	zero,0(sp)

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
    cf04:	21000044 	addi	r4,r4,1
    cf08:	1900240d 	sth	r4,144(r3)
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
    cf0c:	81c00283 	ldbu	r7,10(r16)
    cf10:	8809883a 	mov	r4,r17
    cf14:	dd000115 	stw	r20,4(sp)
    cf18:	800b883a 	mov	r5,r16
    cf1c:	900d883a 	mov	r6,r18
    cf20:	00048780 	call	4878 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
    cf24:	8809883a 	mov	r4,r17

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
    cf28:	dfc00717 	ldw	ra,28(sp)
    cf2c:	dd000617 	ldw	r20,24(sp)
    cf30:	dcc00517 	ldw	r19,20(sp)
    cf34:	dc800417 	ldw	r18,16(sp)
    cf38:	dc400317 	ldw	r17,12(sp)
    cf3c:	dc000217 	ldw	r16,8(sp)
    cf40:	dec00804 	addi	sp,sp,32
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
    cf44:	00067d81 	jmpi	67d8 <pbuf_free>
  }
  if(seg == NULL) {
    return;
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
    cf48:	90c0020b 	ldhu	r3,8(r18)
    cf4c:	183fcd1e 	bne	r3,zero,ce84 <tcp_zero_window_probe+0x3c>
    cf50:	000b883a 	mov	r5,zero
    cf54:	04c00044 	movi	r19,1
    cf58:	003fcc06 	br	ce8c <tcp_zero_window_probe+0x44>
    /* Data segment, copy in one byte from the head of the unacked queue */
    char *d = ((char *)p->payload + TCP_HLEN);
    /* Depending on whether the segment has already been sent (unacked) or not
       (unsent), seg->p->payload points to the IP header or TCP header.
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
    cf5c:	91000117 	ldw	r4,4(r18)
    cf60:	9080020b 	ldhu	r2,8(r18)
    cf64:	99400504 	addi	r5,r19,20
    cf68:	21c0020b 	ldhu	r7,8(r4)
    cf6c:	01800044 	movi	r6,1
    cf70:	388fc83a 	sub	r7,r7,r2
    cf74:	39ffffcc 	andi	r7,r7,65535
    cf78:	00071bc0 	call	71bc <pbuf_copy_partial>
    cf7c:	003fd306 	br	cecc <tcp_zero_window_probe+0x84>
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;

  if(seg == NULL) {
    seg = pcb->unsent;
    cf80:	24801c17 	ldw	r18,112(r4)
  }
  if(seg == NULL) {
    cf84:	903fba1e 	bne	r18,zero,ce70 <tcp_zero_window_probe+0x28>
  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
    cf88:	dfc00717 	ldw	ra,28(sp)
    cf8c:	dd000617 	ldw	r20,24(sp)
    cf90:	dcc00517 	ldw	r19,20(sp)
    cf94:	dc800417 	ldw	r18,16(sp)
    cf98:	dc400317 	ldw	r17,12(sp)
    cf9c:	dc000217 	ldw	r16,8(sp)
    cfa0:	dec00804 	addi	sp,sp,32
    cfa4:	f800283a 	ret

0000cfa8 <tcp_timer_needed>:

#else /* LWIP_TIMERS */
/* Satisfy the TCP code which calls this function */
void
tcp_timer_needed(void)
{
    cfa8:	f800283a 	ret

0000cfac <udp_init>:
/**
 * Initialize this module.
 */
void
udp_init(void)
{
    cfac:	f800283a 	ret

0000cfb0 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
    cfb0:	defff504 	addi	sp,sp,-44
    cfb4:	dc400215 	stw	r17,8(sp)
  u8_t local_match;
  u8_t broadcast;

  PERF_START;

  UDP_STATS_INC(udp.recv);
    cfb8:	044001f4 	movhi	r17,7
    cfbc:	8c544804 	addi	r17,r17,20768
    cfc0:	88801e8b 	ldhu	r2,122(r17)
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
    cfc4:	dcc00415 	stw	r19,16(sp)

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = (struct ip_hdr *)p->payload;
    cfc8:	24c00117 	ldw	r19,4(r4)
  u8_t local_match;
  u8_t broadcast;

  PERF_START;

  UDP_STATS_INC(udp.recv);
    cfcc:	10800044 	addi	r2,r2,1
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
    cfd0:	dd800715 	stw	r22,28(sp)
    cfd4:	dc800315 	stw	r18,12(sp)
    cfd8:	dfc00a15 	stw	ra,40(sp)
    cfdc:	df000915 	stw	fp,36(sp)
    cfe0:	ddc00815 	stw	r23,32(sp)
    cfe4:	dd400615 	stw	r21,24(sp)
    cfe8:	dd000515 	stw	r20,20(sp)
    cfec:	dc000115 	stw	r16,4(sp)
  u8_t local_match;
  u8_t broadcast;

  PERF_START;

  UDP_STATS_INC(udp.recv);
    cff0:	88801e8d 	sth	r2,122(r17)

  iphdr = (struct ip_hdr *)p->payload;

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
    cff4:	98800003 	ldbu	r2,0(r19)
    cff8:	2180020b 	ldhu	r6,8(r4)
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
    cffc:	2025883a 	mov	r18,r4

  iphdr = (struct ip_hdr *)p->payload;

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
    d000:	108003cc 	andi	r2,r2,15
    d004:	10c03fcc 	andi	r3,r2,255
    d008:	18c00084 	addi	r3,r3,2
    d00c:	18c7883a 	add	r3,r3,r3
    d010:	18c7883a 	add	r3,r3,r3
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
    d014:	282d883a 	mov	r22,r5

  iphdr = (struct ip_hdr *)p->payload;

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
    d018:	30c00a16 	blt	r6,r3,d044 <udp_input+0x94>
    d01c:	10803fcc 	andi	r2,r2,255
    d020:	1085883a 	add	r2,r2,r2
    d024:	1085883a 	add	r2,r2,r2
    d028:	008bc83a 	sub	r5,zero,r2
    d02c:	297fffcc 	andi	r5,r5,65535
    d030:	2960001c 	xori	r5,r5,32768
    d034:	29600004 	addi	r5,r5,-32768
    d038:	00066980 	call	6698 <pbuf_header>
    d03c:	10803fcc 	andi	r2,r2,255
    d040:	10001326 	beq	r2,zero,d090 <udp_input+0xe0>
    /* drop short packets */
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    d044:	88c0208b 	ldhu	r3,130(r17)
    UDP_STATS_INC(udp.drop);
    d048:	88801f8b 	ldhu	r2,126(r17)
    snmp_inc_udpinerrors();
    pbuf_free(p);
    d04c:	9009883a 	mov	r4,r18
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
    /* drop short packets */
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    d050:	18c00044 	addi	r3,r3,1
    UDP_STATS_INC(udp.drop);
    d054:	10800044 	addi	r2,r2,1
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
    /* drop short packets */
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    d058:	88c0208d 	sth	r3,130(r17)
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
        icmp_dest_unreach(p, ICMP_DUR_PORT);
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
    d05c:	88801f8d 	sth	r2,126(r17)
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
    d060:	dfc00a17 	ldw	ra,40(sp)
    d064:	df000917 	ldw	fp,36(sp)
    d068:	ddc00817 	ldw	r23,32(sp)
    d06c:	dd800717 	ldw	r22,28(sp)
    d070:	dd400617 	ldw	r21,24(sp)
    d074:	dd000517 	ldw	r20,20(sp)
    d078:	dcc00417 	ldw	r19,16(sp)
    d07c:	dc800317 	ldw	r18,12(sp)
    d080:	dc400217 	ldw	r17,8(sp)
    d084:	dc000117 	ldw	r16,4(sp)
    d088:	dec00b04 	addi	sp,sp,44
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
    d08c:	00067d81 	jmpi	67d8 <pbuf_free>
  }

  udphdr = (struct udp_hdr *)p->payload;

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
    d090:	054000f4 	movhi	r21,3
    d094:	ad6eac04 	addi	r21,r21,-17744
    d098:	a9000017 	ldw	r4,0(r21)
    snmp_inc_udpinerrors();
    pbuf_free(p);
    goto end;
  }

  udphdr = (struct udp_hdr *)p->payload;
    d09c:	97000117 	ldw	fp,4(r18)

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
    d0a0:	b00b883a 	mov	r5,r22
    d0a4:	00049440 	call	4944 <ip4_addr_isbroadcast>

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
  dest = ntohs(udphdr->dest);
    d0a8:	e0c0008b 	ldhu	r3,2(fp)
  }

  udphdr = (struct udp_hdr *)p->payload;

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
    d0ac:	1029883a 	mov	r20,r2

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
    d0b0:	e080000b 	ldhu	r2,0(fp)
  dest = ntohs(udphdr->dest);
    d0b4:	180c923a 	slli	r6,r3,8
    d0b8:	1806d23a 	srli	r3,r3,8
  broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
    d0bc:	102e923a 	slli	r23,r2,8
    d0c0:	1004d23a 	srli	r2,r2,8
  dest = ntohs(udphdr->dest);
    d0c4:	30ccb03a 	or	r6,r6,r3

#if LWIP_DHCP
  pcb = NULL;
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
    d0c8:	31bfffcc 	andi	r6,r6,65535
  broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
    d0cc:	b8aeb03a 	or	r23,r23,r2

#if LWIP_DHCP
  pcb = NULL;
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
    d0d0:	00801104 	movi	r2,68
    d0d4:	30805a26 	beq	r6,r2,d240 <udp_input+0x290>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    d0d8:	d168ca17 	ldw	r5,-23768(gp)
    d0dc:	28006526 	beq	r5,zero,d274 <udp_input+0x2c4>
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
    d0e0:	008000f4 	movhi	r2,3
    d0e4:	10aeaa04 	addi	r2,r2,-17752
    d0e8:	12800017 	ldw	r10,0(r2)

      /* compare PCB local addr+port to UDP destination addr+port */
      if (pcb->local_port == dest) {
        if (
           (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest) ||
    d0ec:	a9c00017 	ldw	r7,0(r21)
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
    d0f0:	2821883a 	mov	r16,r5
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
    local_match = 0;
    uncon_pcb = NULL;
    d0f4:	0005883a 	mov	r2,zero
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
    d0f8:	0009883a 	mov	r4,zero
                   ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                   ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if (pcb->local_port == dest) {
        if (
    d0fc:	a2003fcc 	andi	r8,r20,255
            uncon_pcb = pcb;
          }
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
    d100:	ba7fffcc 	andi	r9,r23,65535
    d104:	00000406 	br	d118 <udp_input+0x168>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    d108:	80c00317 	ldw	r3,12(r16)
    d10c:	8009883a 	mov	r4,r16
    d110:	18002026 	beq	r3,zero,d194 <udp_input+0x1e4>
    d114:	1821883a 	mov	r16,r3
                   ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip), pcb->local_port,
                   ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                   ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if (pcb->local_port == dest) {
    d118:	80c0048b 	ldhu	r3,18(r16)
    d11c:	19bffa1e 	bne	r3,r6,d108 <udp_input+0x158>
        if (
           (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
    d120:	80c00017 	ldw	r3,0(r16)
                   ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                   ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if (pcb->local_port == dest) {
        if (
    d124:	40001226 	beq	r8,zero,d170 <udp_input+0x1c0>
           (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
    d128:	19c00526 	beq	r3,r7,d140 <udp_input+0x190>
            (broadcast && ip_get_option(pcb, SOF_BROADCAST) &&
             (ip_addr_isany(&pcb->local_ip) ||
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#else /* IP_SOF_BROADCAST_RECV */
            (broadcast &&
             (ip_addr_isany(&pcb->local_ip) ||
    d12c:	18000426 	beq	r3,zero,d140 <udp_input+0x190>
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
    d130:	b2c00217 	ldw	r11,8(r22)
    d134:	19c6f03a 	xor	r3,r3,r7
    d138:	1ac6703a 	and	r3,r3,r11
            (broadcast && ip_get_option(pcb, SOF_BROADCAST) &&
             (ip_addr_isany(&pcb->local_ip) ||
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#else /* IP_SOF_BROADCAST_RECV */
            (broadcast &&
             (ip_addr_isany(&pcb->local_ip) ||
    d13c:	183ff21e 	bne	r3,zero,d108 <udp_input+0x158>
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#endif /* IP_SOF_BROADCAST_RECV */ 
          local_match = 1;
          if ((uncon_pcb == NULL) && 
    d140:	10000e26 	beq	r2,zero,d17c <udp_input+0x1cc>
            uncon_pcb = pcb;
          }
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
    d144:	80c0050b 	ldhu	r3,20(r16)
    d148:	1a7fef1e 	bne	r3,r9,d108 <udp_input+0x158>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
    d14c:	80c00117 	ldw	r3,4(r16)
    d150:	18000126 	beq	r3,zero,d158 <udp_input+0x1a8>
    d154:	1abfec1e 	bne	r3,r10,d108 <udp_input+0x158>
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
    d158:	20007f26 	beq	r4,zero,d358 <udp_input+0x3a8>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
    d15c:	80800317 	ldw	r2,12(r16)
          pcb->next = udp_pcbs;
          udp_pcbs = pcb;
    d160:	d428ca15 	stw	r16,-23768(gp)
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
    d164:	20800315 	stw	r2,12(r4)
          pcb->next = udp_pcbs;
    d168:	81400315 	stw	r5,12(r16)
    d16c:	00000b06 	br	d19c <udp_input+0x1ec>
                   ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if (pcb->local_port == dest) {
        if (
           (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
    d170:	183ff326 	beq	r3,zero,d140 <udp_input+0x190>
    d174:	38ffe41e 	bne	r7,r3,d108 <udp_input+0x158>
    d178:	003ff106 	br	d140 <udp_input+0x190>
             (ip_addr_isany(&pcb->local_ip) ||
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#endif /* IP_SOF_BROADCAST_RECV */ 
          local_match = 1;
          if ((uncon_pcb == NULL) && 
              ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
    d17c:	80c00403 	ldbu	r3,16(r16)
            (broadcast &&
             (ip_addr_isany(&pcb->local_ip) ||
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#endif /* IP_SOF_BROADCAST_RECV */ 
          local_match = 1;
          if ((uncon_pcb == NULL) && 
    d180:	18c0010c 	andi	r3,r3,4
    d184:	18c03fcc 	andi	r3,r3,255
    d188:	183fee1e 	bne	r3,zero,d144 <udp_input+0x194>
    d18c:	8005883a 	mov	r2,r16
    d190:	003fec06 	br	d144 <udp_input+0x194>
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
    d194:	1021883a 	mov	r16,r2
    d198:	10003626 	beq	r2,zero,d274 <udp_input+0x2c4>
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
    d19c:	e080018b 	ldhu	r2,6(fp)
    d1a0:	10000b26 	beq	r2,zero,d1d0 <udp_input+0x220>
        if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
    d1a4:	9080020b 	ldhu	r2,8(r18)
    d1a8:	9009883a 	mov	r4,r18
    d1ac:	014000f4 	movhi	r5,3
    d1b0:	296eaa04 	addi	r5,r5,-17752
    d1b4:	d8800015 	stw	r2,0(sp)
    d1b8:	018000f4 	movhi	r6,3
    d1bc:	31aeac04 	addi	r6,r6,-17744
    d1c0:	01c00444 	movi	r7,17
    d1c4:	0003e800 	call	3e80 <inet_chksum_pseudo>
    d1c8:	10bfffcc 	andi	r2,r2,65535
    d1cc:	10005b1e 	bne	r2,zero,d33c <udp_input+0x38c>
          goto end;
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
    d1d0:	9009883a 	mov	r4,r18
    d1d4:	017ffe04 	movi	r5,-8
    d1d8:	00066980 	call	6698 <pbuf_header>
    d1dc:	10803fcc 	andi	r2,r2,255
    d1e0:	1000291e 	bne	r2,zero,d288 <udp_input+0x2d8>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
    d1e4:	80003326 	beq	r16,zero,d2b4 <udp_input+0x304>
          pbuf_header(p, -(s16_t)((IPH_HL(iphdr) * 4) + UDP_HLEN));
        }
      }
#endif /* SO_REUSE && SO_REUSE_RXTOALL */
      /* callback */
      if (pcb->recv != NULL) {
    d1e8:	80800617 	ldw	r2,24(r16)
    d1ec:	10002f26 	beq	r2,zero,d2ac <udp_input+0x2fc>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
    d1f0:	81000717 	ldw	r4,28(r16)
    d1f4:	bdffffcc 	andi	r23,r23,65535
    d1f8:	ddc00015 	stw	r23,0(sp)
    d1fc:	800b883a 	mov	r5,r16
    d200:	900d883a 	mov	r6,r18
    d204:	01c000f4 	movhi	r7,3
    d208:	39eeaa04 	addi	r7,r7,-17752
    d20c:	103ee83a 	callr	r2
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
    d210:	dfc00a17 	ldw	ra,40(sp)
    d214:	df000917 	ldw	fp,36(sp)
    d218:	ddc00817 	ldw	r23,32(sp)
    d21c:	dd800717 	ldw	r22,28(sp)
    d220:	dd400617 	ldw	r21,24(sp)
    d224:	dd000517 	ldw	r20,20(sp)
    d228:	dcc00417 	ldw	r19,16(sp)
    d22c:	dc800317 	ldw	r18,12(sp)
    d230:	dc400217 	ldw	r17,8(sp)
    d234:	dc000117 	ldw	r16,4(sp)
    d238:	dec00b04 	addi	sp,sp,44
    d23c:	f800283a 	ret
  pcb = NULL;
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
    d240:	b8ffffcc 	andi	r3,r23,65535
    d244:	008010c4 	movi	r2,67
    d248:	18800a1e 	bne	r3,r2,d274 <udp_input+0x2c4>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
    d24c:	b0800817 	ldw	r2,32(r22)
    d250:	10000826 	beq	r2,zero,d274 <udp_input+0x2c4>
    d254:	14000117 	ldw	r16,4(r2)
    d258:	80000626 	beq	r16,zero,d274 <udp_input+0x2c4>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
    d25c:	80800117 	ldw	r2,4(r16)
    d260:	103fce26 	beq	r2,zero,d19c <udp_input+0x1ec>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &current_iphdr_src))) {
    d264:	00c000f4 	movhi	r3,3
    d268:	18eeaa04 	addi	r3,r3,-17752
    if (src == DHCP_SERVER_PORT) {
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
    d26c:	18c00017 	ldw	r3,0(r3)
    d270:	10ffca26 	beq	r2,r3,d19c <udp_input+0x1ec>
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
    d274:	b0c00117 	ldw	r3,4(r22)
    d278:	a8800017 	ldw	r2,0(r21)
    d27c:	18800b1e 	bne	r3,r2,d2ac <udp_input+0x2fc>
    d280:	0021883a 	mov	r16,zero
    d284:	003fc506 	br	d19c <udp_input+0x1ec>
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
    d288:	010000b4 	movhi	r4,2
    d28c:	210d4b04 	addi	r4,r4,13612
    d290:	014000b4 	movhi	r5,2
    d294:	29573e04 	addi	r5,r5,23800
    d298:	01805604 	movi	r6,344
    d29c:	01c000b4 	movhi	r7,2
    d2a0:	39d74304 	addi	r7,r7,23820
    d2a4:	00104380 	call	10438 <printf>
    d2a8:	003fff06 	br	d2a8 <udp_input+0x2f8>
      if (pcb->recv != NULL) {
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
    d2ac:	9009883a 	mov	r4,r18
    d2b0:	003f6b06 	br	d060 <udp_input+0xb0>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!broadcast &&
    d2b4:	a5003fcc 	andi	r20,r20,255
    d2b8:	a000191e 	bne	r20,zero,d320 <udp_input+0x370>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
    d2bc:	a8c00017 	ldw	r3,0(r21)
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!broadcast &&
    d2c0:	00803804 	movi	r2,224
          !ip_addr_ismulticast(&current_iphdr_dest)) {
    d2c4:	18c03c0c 	andi	r3,r3,240
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!broadcast &&
    d2c8:	18801526 	beq	r3,r2,d320 <udp_input+0x370>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
    d2cc:	99400003 	ldbu	r5,0(r19)
    d2d0:	9009883a 	mov	r4,r18
    d2d4:	294003cc 	andi	r5,r5,15
    d2d8:	29400084 	addi	r5,r5,2
    d2dc:	294b883a 	add	r5,r5,r5
    d2e0:	294b883a 	add	r5,r5,r5
    d2e4:	00066980 	call	6698 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
    d2e8:	90800117 	ldw	r2,4(r18)
    d2ec:	14c00926 	beq	r2,r19,d314 <udp_input+0x364>
    d2f0:	010000b4 	movhi	r4,2
    d2f4:	210d4b04 	addi	r4,r4,13612
    d2f8:	014000b4 	movhi	r5,2
    d2fc:	29574804 	addi	r5,r5,23840
    d300:	018068c4 	movi	r6,419
    d304:	01c000b4 	movhi	r7,2
    d308:	39d74304 	addi	r7,r7,23820
    d30c:	00104380 	call	10438 <printf>
    d310:	003fff06 	br	d310 <udp_input+0x360>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
    d314:	9009883a 	mov	r4,r18
    d318:	014000c4 	movi	r5,3
    d31c:	0003da80 	call	3da8 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
    d320:	88c0220b 	ldhu	r3,136(r17)
      UDP_STATS_INC(udp.drop);
    d324:	88801f8b 	ldhu	r2,126(r17)
      snmp_inc_udpnoports();
      pbuf_free(p);
    d328:	9009883a 	mov	r4,r18
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
        icmp_dest_unreach(p, ICMP_DUR_PORT);
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
    d32c:	18c00044 	addi	r3,r3,1
      UDP_STATS_INC(udp.drop);
    d330:	10800044 	addi	r2,r2,1
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
        icmp_dest_unreach(p, ICMP_DUR_PORT);
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
    d334:	88c0220d 	sth	r3,136(r17)
    d338:	003f4806 	br	d05c <udp_input+0xac>
      if (udphdr->chksum != 0) {
        if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
                               IP_PROTO_UDP, p->tot_len) != 0) {
          LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
    d33c:	88c0200b 	ldhu	r3,128(r17)
          UDP_STATS_INC(udp.drop);
    d340:	88801f8b 	ldhu	r2,126(r17)
          snmp_inc_udpinerrors();
          pbuf_free(p);
    d344:	9009883a 	mov	r4,r18
      if (udphdr->chksum != 0) {
        if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
                               IP_PROTO_UDP, p->tot_len) != 0) {
          LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
    d348:	18c00044 	addi	r3,r3,1
          UDP_STATS_INC(udp.drop);
    d34c:	10800044 	addi	r2,r2,1
      if (udphdr->chksum != 0) {
        if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
                               IP_PROTO_UDP, p->tot_len) != 0) {
          LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
    d350:	88c0200d 	sth	r3,128(r17)
    d354:	003f4106 	br	d05c <udp_input+0xac>
             found faster next time */
          prev->next = pcb->next;
          pcb->next = udp_pcbs;
          udp_pcbs = pcb;
        } else {
          UDP_STATS_INC(udp.cachehit);
    d358:	8880238b 	ldhu	r2,142(r17)
    d35c:	10800044 	addi	r2,r2,1
    d360:	8880238d 	sth	r2,142(r17)
    d364:	003f8d06 	br	d19c <udp_input+0x1ec>

0000d368 <udp_bind>:
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    d368:	d2a8ca17 	ldw	r10,-23768(gp)
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
    d36c:	deffff04 	addi	sp,sp,-4
    d370:	dfc00015 	stw	ra,0(sp)
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    d374:	50005126 	beq	r10,zero,d4bc <udp_bind+0x154>
    d378:	5005883a 	mov	r2,r10
    d37c:	0013883a 	mov	r9,zero
    d380:	31ffffcc 	andi	r7,r6,65535
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
    d384:	20801b26 	beq	r4,r2,d3f4 <udp_bind+0x8c>
             !ip_get_option(ipcb, SOF_REUSEADDR)) {
#else /* SO_REUSE */
    /* port matches that of PCB in list and REUSEADDR not set -> reject */
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
    d388:	10c0048b 	ldhu	r3,18(r2)
    d38c:	19c00f26 	beq	r3,r7,d3cc <udp_bind+0x64>
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    d390:	10800317 	ldw	r2,12(r2)
    d394:	103ffb1e 	bne	r2,zero,d384 <udp_bind+0x1c>
        return ERR_USE;
      }
    }
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
    d398:	28001e26 	beq	r5,zero,d414 <udp_bind+0xac>
    d39c:	28800017 	ldw	r2,0(r5)
    d3a0:	20800015 	stw	r2,0(r4)

  /* no port specified? */
  if (port == 0) {
    d3a4:	38001e26 	beq	r7,zero,d420 <udp_bind+0xb8>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
    d3a8:	2180048d 	sth	r6,18(r4)
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
    d3ac:	4a403fcc 	andi	r9,r9,255
    d3b0:	4800141e 	bne	r9,zero,d404 <udp_bind+0x9c>
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));
  return ERR_OK;
    d3b4:	0005883a 	mov	r2,zero
  pcb->local_port = port;
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
    d3b8:	22800315 	stw	r10,12(r4)
    udp_pcbs = pcb;
    d3bc:	d128ca15 	stw	r4,-23768(gp)
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));
  return ERR_OK;
}
    d3c0:	dfc00017 	ldw	ra,0(sp)
    d3c4:	dec00104 	addi	sp,sp,4
    d3c8:	f800283a 	ret
    /* port matches that of PCB in list and REUSEADDR not set -> reject */
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
          /* IP address matches, or one is IP_ADDR_ANY? */
          (ip_addr_isany(&(ipcb->local_ip)) ||
    d3cc:	12000017 	ldw	r8,0(r2)
    d3d0:	40000426 	beq	r8,zero,d3e4 <udp_bind+0x7c>
    d3d4:	28000326 	beq	r5,zero,d3e4 <udp_bind+0x7c>
           ip_addr_isany(ipaddr) ||
    d3d8:	28c00017 	ldw	r3,0(r5)
    d3dc:	18000126 	beq	r3,zero,d3e4 <udp_bind+0x7c>
    d3e0:	40ffeb1e 	bne	r8,r3,d390 <udp_bind+0x28>
           ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
        /* other PCB already binds to this local IP and port */
        LWIP_DEBUGF(UDP_DEBUG,
                    ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
        return ERR_USE;
    d3e4:	00bffe04 	movi	r2,-8
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));
  return ERR_OK;
}
    d3e8:	dfc00017 	ldw	ra,0(sp)
    d3ec:	dec00104 	addi	sp,sp,4
    d3f0:	f800283a 	ret
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
    d3f4:	4a403fcc 	andi	r9,r9,255
    d3f8:	4800231e 	bne	r9,zero,d488 <udp_bind+0x120>
      /* pcb already in list, just rebind */
      rebind = 1;
    d3fc:	02400044 	movi	r9,1
    d400:	003fe306 	br	d390 <udp_bind+0x28>
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));
  return ERR_OK;
    d404:	0005883a 	mov	r2,zero
}
    d408:	dfc00017 	ldw	ra,0(sp)
    d40c:	dec00104 	addi	sp,sp,4
    d410:	f800283a 	ret
        return ERR_USE;
      }
    }
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
    d414:	0005883a 	mov	r2,zero
    d418:	20800015 	stw	r2,0(r4)

  /* no port specified? */
  if (port == 0) {
    d41c:	383fe21e 	bne	r7,zero,d3a8 <udp_bind+0x40>
    d420:	d1a0080b 	ldhu	r6,-32736(gp)
    d424:	01500004 	movi	r5,16384
{
  u16_t n = 0;
  struct udp_pcb *pcb;
  
again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
    d428:	023fffd4 	movui	r8,65535
    d42c:	30bfffcc 	andi	r2,r6,65535
    d430:	31800044 	addi	r6,r6,1
    d434:	12000d26 	beq	r2,r8,d46c <udp_bind+0x104>
    udp_port = UDP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCBs. */
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    d438:	50001c26 	beq	r10,zero,d4ac <udp_bind+0x144>
    if (pcb->local_port == udp_port) {
    d43c:	5080048b 	ldhu	r2,18(r10)
    d440:	31ffffcc 	andi	r7,r6,65535
    d444:	38800b26 	beq	r7,r2,d474 <udp_bind+0x10c>
    d448:	5005883a 	mov	r2,r10
    d44c:	00000206 	br	d458 <udp_bind+0xf0>
    d450:	10c0048b 	ldhu	r3,18(r2)
    d454:	38c00726 	beq	r7,r3,d474 <udp_bind+0x10c>
again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
    udp_port = UDP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCBs. */
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    d458:	10800317 	ldw	r2,12(r2)
    d45c:	103ffc1e 	bne	r2,zero,d450 <udp_bind+0xe8>
    d460:	d1a0080d 	sth	r6,-32736(gp)
  ip_addr_set(&pcb->local_ip, ipaddr);

  /* no port specified? */
  if (port == 0) {
    port = udp_new_port();
    if (port == 0) {
    d464:	383fd01e 	bne	r7,zero,d3a8 <udp_bind+0x40>
    d468:	003fde06 	br	d3e4 <udp_bind+0x7c>
{
  u16_t n = 0;
  struct udp_pcb *pcb;
  
again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
    d46c:	01b00004 	movi	r6,-16384
    d470:	003ff106 	br	d438 <udp_bind+0xd0>
    d474:	297fffc4 	addi	r5,r5,-1
    udp_port = UDP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCBs. */
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == udp_port) {
      if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
    d478:	28bfffcc 	andi	r2,r5,65535
    d47c:	103feb1e 	bne	r2,zero,d42c <udp_bind+0xc4>
    d480:	d1a0080d 	sth	r6,-32736(gp)
    d484:	003fd706 	br	d3e4 <udp_bind+0x7c>
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
    d488:	010000b4 	movhi	r4,2
    d48c:	210d4b04 	addi	r4,r4,13612
    d490:	014000b4 	movhi	r5,2
    d494:	29574d04 	addi	r5,r5,23860
    d498:	0180c344 	movi	r6,781
    d49c:	01c000b4 	movhi	r7,2
    d4a0:	39d74304 	addi	r7,r7,23820
    d4a4:	00104380 	call	10438 <printf>
    d4a8:	003fff06 	br	d4a8 <udp_bind+0x140>
    d4ac:	d1a0080d 	sth	r6,-32736(gp)
    d4b0:	31ffffcc 	andi	r7,r6,65535
  ip_addr_set(&pcb->local_ip, ipaddr);

  /* no port specified? */
  if (port == 0) {
    port = udp_new_port();
    if (port == 0) {
    d4b4:	383fbc1e 	bne	r7,zero,d3a8 <udp_bind+0x40>
    d4b8:	003fca06 	br	d3e4 <udp_bind+0x7c>

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
    d4bc:	0013883a 	mov	r9,zero
    d4c0:	31ffffcc 	andi	r7,r6,65535
        return ERR_USE;
      }
    }
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
    d4c4:	283fb51e 	bne	r5,zero,d39c <udp_bind+0x34>
    d4c8:	003fd206 	br	d414 <udp_bind+0xac>

0000d4cc <udp_sendto_if>:
    return ERR_VAL;
  }
#endif /* IP_SOF_BROADCAST */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
    d4cc:	2080048b 	ldhu	r2,18(r4)
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif)
{
    d4d0:	defff504 	addi	sp,sp,-44
    d4d4:	dd800915 	stw	r22,36(sp)
    d4d8:	dd400815 	stw	r21,32(sp)
    d4dc:	dd000715 	stw	r20,28(sp)
    d4e0:	dc800515 	stw	r18,20(sp)
    d4e4:	dc400415 	stw	r17,16(sp)
    d4e8:	dfc00a15 	stw	ra,40(sp)
    d4ec:	dcc00615 	stw	r19,24(sp)
    d4f0:	dc000315 	stw	r16,12(sp)
    d4f4:	2023883a 	mov	r17,r4
    d4f8:	2825883a 	mov	r18,r5
    d4fc:	302d883a 	mov	r22,r6
    d500:	dd000b17 	ldw	r20,44(sp)
    d504:	382b883a 	mov	r21,r7
    return ERR_VAL;
  }
#endif /* IP_SOF_BROADCAST */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
    d508:	1000081e 	bne	r2,zero,d52c <udp_sendto_if+0x60>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
    d50c:	200b883a 	mov	r5,r4
    d510:	000d883a 	mov	r6,zero
    d514:	000d3680 	call	d368 <udp_bind>
    d518:	1027883a 	mov	r19,r2
    if (err != ERR_OK) {
    d51c:	98803fcc 	andi	r2,r19,255
    d520:	1080201c 	xori	r2,r2,128
    d524:	10bfe004 	addi	r2,r2,-128
    d528:	1000331e 	bne	r2,zero,d5f8 <udp_sendto_if+0x12c>
      return err;
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
    d52c:	9009883a 	mov	r4,r18
    d530:	01400204 	movi	r5,8
    d534:	00066980 	call	6698 <pbuf_header>
    d538:	10803fcc 	andi	r2,r2,255
    d53c:	1000491e 	bne	r2,zero,d664 <udp_sendto_if+0x198>
    d540:	9021883a 	mov	r16,r18
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
    d544:	8080028b 	ldhu	r2,10(r16)
    d548:	00c001c4 	movi	r3,7
    d54c:	18803c2e 	bgeu	r3,r2,d640 <udp_sendto_if+0x174>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = (struct udp_hdr *)q->payload;
  udphdr->src = htons(pcb->local_port);
    d550:	8880048b 	ldhu	r2,18(r17)
  udphdr->dest = htons(dst_port);
    d554:	a9ffffcc 	andi	r7,r21,65535
    d558:	3806923a 	slli	r3,r7,8
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = (struct udp_hdr *)q->payload;
  udphdr->src = htons(pcb->local_port);
    d55c:	100a923a 	slli	r5,r2,8
    d560:	1008d23a 	srli	r4,r2,8
  udphdr->dest = htons(dst_port);
    d564:	380ed23a 	srli	r7,r7,8
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = (struct udp_hdr *)q->payload;
    d568:	84c00117 	ldw	r19,4(r16)
  }
#endif /* LWIP_IGMP */


  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
    d56c:	88800017 	ldw	r2,0(r17)
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = (struct udp_hdr *)q->payload;
  udphdr->src = htons(pcb->local_port);
    d570:	2908b03a 	or	r4,r5,r4
  udphdr->dest = htons(dst_port);
    d574:	19c6b03a 	or	r3,r3,r7
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = (struct udp_hdr *)q->payload;
  udphdr->src = htons(pcb->local_port);
    d578:	9900000d 	sth	r4,0(r19)
  udphdr->dest = htons(dst_port);
    d57c:	98c0008d 	sth	r3,2(r19)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
    d580:	9800018d 	sth	zero,6(r19)
  }
#endif /* LWIP_IGMP */


  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
    d584:	1000271e 	bne	r2,zero,d624 <udp_sendto_if+0x158>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
    d588:	a5400104 	addi	r21,r20,4
    NETIF_SET_HWADDRHINT(netif, NULL);
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
    d58c:	8080020b 	ldhu	r2,8(r16)
    d590:	1008923a 	slli	r4,r2,8
    d594:	1006d23a 	srli	r3,r2,8
    d598:	20c6b03a 	or	r3,r4,r3
    d59c:	98c0010d 	sth	r3,4(r19)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
    d5a0:	88c00403 	ldbu	r3,16(r17)
    d5a4:	18c0004c 	andi	r3,r3,1
    d5a8:	18003a26 	beq	r3,zero,d694 <udp_sendto_if+0x1c8>
#endif /* CHECKSUM_GEN_UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04"X16_F"\n", udphdr->chksum));
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
    NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
    d5ac:	88800243 	ldbu	r2,9(r17)
    d5b0:	89c00283 	ldbu	r7,10(r17)
    d5b4:	00c00444 	movi	r3,17
    d5b8:	d8c00115 	stw	r3,4(sp)
    d5bc:	d8800015 	stw	r2,0(sp)
    d5c0:	dd000215 	stw	r20,8(sp)
    d5c4:	8009883a 	mov	r4,r16
    d5c8:	a80b883a 	mov	r5,r21
    d5cc:	b00d883a 	mov	r6,r22
    d5d0:	00046140 	call	4614 <ip_output_if>
    d5d4:	1027883a 	mov	r19,r2
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
    d5d8:	84800226 	beq	r16,r18,d5e4 <udp_sendto_if+0x118>
    /* free the header pbuf */
    pbuf_free(q);
    d5dc:	8009883a 	mov	r4,r16
    d5e0:	00067d80 	call	67d8 <pbuf_free>
    q = NULL;
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
    d5e4:	008001f4 	movhi	r2,7
    d5e8:	10944804 	addi	r2,r2,20768
    d5ec:	10c01e0b 	ldhu	r3,120(r2)
    d5f0:	18c00044 	addi	r3,r3,1
    d5f4:	10c01e0d 	sth	r3,120(r2)
  return err;
}
    d5f8:	9805883a 	mov	r2,r19
    d5fc:	dfc00a17 	ldw	ra,40(sp)
    d600:	dd800917 	ldw	r22,36(sp)
    d604:	dd400817 	ldw	r21,32(sp)
    d608:	dd000717 	ldw	r20,28(sp)
    d60c:	dcc00617 	ldw	r19,24(sp)
    d610:	dc800517 	ldw	r18,20(sp)
    d614:	dc400417 	ldw	r17,16(sp)
    d618:	dc000317 	ldw	r16,12(sp)
    d61c:	dec00b04 	addi	sp,sp,44
    d620:	f800283a 	ret
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
    d624:	a0c00117 	ldw	r3,4(r20)
    d628:	10c02926 	beq	r2,r3,d6d0 <udp_sendto_if+0x204>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
    d62c:	84802626 	beq	r16,r18,d6c8 <udp_sendto_if+0x1fc>
        /* free the header pbuf */
        pbuf_free(q);
    d630:	8009883a 	mov	r4,r16
    d634:	00067d80 	call	67d8 <pbuf_free>
        q = NULL;
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
    d638:	04fffe84 	movi	r19,-6
    d63c:	003fee06 	br	d5f8 <udp_sendto_if+0x12c>
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
    d640:	010000b4 	movhi	r4,2
    d644:	210d4b04 	addi	r4,r4,13612
    d648:	014000b4 	movhi	r5,2
    d64c:	29575004 	addi	r5,r5,23872
    d650:	01809884 	movi	r6,610
    d654:	01c000b4 	movhi	r7,2
    d658:	39d74304 	addi	r7,r7,23820
    d65c:	00104380 	call	10438 <printf>
    d660:	003fff06 	br	d660 <udp_sendto_if+0x194>
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
    d664:	01000044 	movi	r4,1
    d668:	01400204 	movi	r5,8
    d66c:	000d883a 	mov	r6,zero
    d670:	0006a880 	call	6a88 <pbuf_alloc>
    d674:	1021883a 	mov	r16,r2
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
    d678:	10001126 	beq	r2,zero,d6c0 <udp_sendto_if+0x1f4>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
    }
    if (p->tot_len != 0) {
    d67c:	9080020b 	ldhu	r2,8(r18)
    d680:	103fb026 	beq	r2,zero,d544 <udp_sendto_if+0x78>
      /* chain header q in front of given pbuf p (only if p contains data) */
      pbuf_chain(q, p);
    d684:	8009883a 	mov	r4,r16
    d688:	900b883a 	mov	r5,r18
    d68c:	0006ec00 	call	6ec0 <pbuf_chain>
    d690:	003fac06 	br	d544 <udp_sendto_if+0x78>
        acc = udpchksum + (u16_t)~(chksum);
        udpchksum = FOLD_U32T(acc);
      } else
#endif /* LWIP_CHECKSUM_ON_COPY */
      {
        udpchksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
    d694:	d8800015 	stw	r2,0(sp)
    d698:	8009883a 	mov	r4,r16
    d69c:	a80b883a 	mov	r5,r21
    d6a0:	b00d883a 	mov	r6,r22
    d6a4:	01c00444 	movi	r7,17
    d6a8:	0003e800 	call	3e80 <inet_chksum_pseudo>
      }

      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udpchksum == 0x0000) {
    d6ac:	10ffffcc 	andi	r3,r2,65535
    d6b0:	1800011e 	bne	r3,zero,d6b8 <udp_sendto_if+0x1ec>
        udpchksum = 0xffff;
    d6b4:	00bfffc4 	movi	r2,-1
      }
      udphdr->chksum = udpchksum;
    d6b8:	9880018d 	sth	r2,6(r19)
    d6bc:	003fbb06 	br	d5ac <udp_sendto_if+0xe0>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
    d6c0:	04ffffc4 	movi	r19,-1
    d6c4:	003fcc06 	br	d5f8 <udp_sendto_if+0x12c>
        /* free the header pbuf */
        pbuf_free(q);
        q = NULL;
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
    d6c8:	04fffe84 	movi	r19,-6
    d6cc:	003fca06 	br	d5f8 <udp_sendto_if+0x12c>
  }
#endif /* LWIP_IGMP */


  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
    d6d0:	882b883a 	mov	r21,r17
    d6d4:	003fad06 	br	d58c <udp_sendto_if+0xc0>

0000d6d8 <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  ip_addr_t *dst_ip, u16_t dst_port)
{
    d6d8:	defffa04 	addi	sp,sp,-24
    d6dc:	dc000315 	stw	r16,12(sp)
    d6e0:	2021883a 	mov	r16,r4

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
    d6e4:	3009883a 	mov	r4,r6
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  ip_addr_t *dst_ip, u16_t dst_port)
{
    d6e8:	dc400415 	stw	r17,16(sp)

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
    d6ec:	d9400115 	stw	r5,4(sp)
    d6f0:	d9800215 	stw	r6,8(sp)
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  ip_addr_t *dst_ip, u16_t dst_port)
{
    d6f4:	dfc00515 	stw	ra,20(sp)
    d6f8:	3823883a 	mov	r17,r7

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
    d6fc:	000427c0 	call	427c <ip_route>
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
    d700:	d9400117 	ldw	r5,4(sp)
    d704:	d9800217 	ldw	r6,8(sp)
    d708:	10000926 	beq	r2,zero,d730 <udp_sendto+0x58>
    return ERR_RTE;
  }
#if LWIP_CHECKSUM_ON_COPY
  return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum);
#else /* LWIP_CHECKSUM_ON_COPY */
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
    d70c:	d8800015 	stw	r2,0(sp)
    d710:	8009883a 	mov	r4,r16
    d714:	89ffffcc 	andi	r7,r17,65535
    d718:	000d4cc0 	call	d4cc <udp_sendto_if>
#endif /* LWIP_CHECKSUM_ON_COPY */
}
    d71c:	dfc00517 	ldw	ra,20(sp)
    d720:	dc400417 	ldw	r17,16(sp)
    d724:	dc000317 	ldw	r16,12(sp)
    d728:	dec00604 	addi	sp,sp,24
    d72c:	f800283a 	ret

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dst_ip), ip4_addr2_16(dst_ip), ip4_addr3_16(dst_ip), ip4_addr4_16(dst_ip)));
    UDP_STATS_INC(udp.rterr);
    d730:	00c001f4 	movhi	r3,7
    d734:	18d44804 	addi	r3,r3,20768
    d738:	1900218b 	ldhu	r4,134(r3)
    return ERR_RTE;
    d73c:	00bfff04 	movi	r2,-4

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dst_ip), ip4_addr2_16(dst_ip), ip4_addr3_16(dst_ip), ip4_addr4_16(dst_ip)));
    UDP_STATS_INC(udp.rterr);
    d740:	21000044 	addi	r4,r4,1
    d744:	1900218d 	sth	r4,134(r3)
    return ERR_RTE;
    d748:	003ff406 	br	d71c <udp_sendto+0x44>

0000d74c <udp_send>:
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
    d74c:	21c0050b 	ldhu	r7,20(r4)
    d750:	21800104 	addi	r6,r4,4
    d754:	000d6d81 	jmpi	d6d8 <udp_sendto>

0000d758 <udp_connect>:
err_t
udp_connect(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
    d758:	2080048b 	ldhu	r2,18(r4)
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
    d75c:	defffc04 	addi	sp,sp,-16
    d760:	dc800215 	stw	r18,8(sp)
    d764:	dc400115 	stw	r17,4(sp)
    d768:	dc000015 	stw	r16,0(sp)
    d76c:	dfc00315 	stw	ra,12(sp)
    d770:	2021883a 	mov	r16,r4
    d774:	2823883a 	mov	r17,r5
    d778:	3025883a 	mov	r18,r6
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
    d77c:	10001826 	beq	r2,zero,d7e0 <udp_connect+0x88>
    if (err != ERR_OK) {
      return err;
    }
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
    d780:	88001f26 	beq	r17,zero,d800 <udp_connect+0xa8>
    d784:	89000017 	ldw	r4,0(r17)
  pcb->remote_port = port;
  pcb->flags |= UDP_FLAGS_CONNECTED;
    d788:	80800403 	ldbu	r2,16(r16)
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    d78c:	d0e8ca17 	ldw	r3,-23768(gp)
    if (err != ERR_OK) {
      return err;
    }
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
    d790:	81000115 	stw	r4,4(r16)
  pcb->remote_port = port;
  pcb->flags |= UDP_FLAGS_CONNECTED;
    d794:	10800114 	ori	r2,r2,4
      return err;
    }
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  pcb->remote_port = port;
    d798:	8480050d 	sth	r18,20(r16)
  pcb->flags |= UDP_FLAGS_CONNECTED;
    d79c:	80800405 	stb	r2,16(r16)
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    d7a0:	18000626 	beq	r3,zero,d7bc <udp_connect+0x64>
    if (pcb == ipcb) {
    d7a4:	80c01826 	beq	r16,r3,d808 <udp_connect+0xb0>
    d7a8:	1805883a 	mov	r2,r3
    d7ac:	00000106 	br	d7b4 <udp_connect+0x5c>
    d7b0:	80801526 	beq	r16,r2,d808 <udp_connect+0xb0>
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    d7b4:	10800317 	ldw	r2,12(r2)
    d7b8:	103ffd1e 	bne	r2,zero,d7b0 <udp_connect+0x58>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
    d7bc:	80c00315 	stw	r3,12(r16)
  udp_pcbs = pcb;
    d7c0:	d428ca15 	stw	r16,-23768(gp)
  return ERR_OK;
    d7c4:	0005883a 	mov	r2,zero
}
    d7c8:	dfc00317 	ldw	ra,12(sp)
    d7cc:	dc800217 	ldw	r18,8(sp)
    d7d0:	dc400117 	ldw	r17,4(sp)
    d7d4:	dc000017 	ldw	r16,0(sp)
    d7d8:	dec00404 	addi	sp,sp,16
    d7dc:	f800283a 	ret
udp_connect(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
    d7e0:	200b883a 	mov	r5,r4
    d7e4:	000d883a 	mov	r6,zero
    d7e8:	000d3680 	call	d368 <udp_bind>
    if (err != ERR_OK) {
    d7ec:	10c03fcc 	andi	r3,r2,255
    d7f0:	18c0201c 	xori	r3,r3,128
    d7f4:	18ffe004 	addi	r3,r3,-128
    d7f8:	183ff31e 	bne	r3,zero,d7c8 <udp_connect+0x70>
      return err;
    }
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
    d7fc:	883fe11e 	bne	r17,zero,d784 <udp_connect+0x2c>
    d800:	0009883a 	mov	r4,zero
    d804:	003fe006 	br	d788 <udp_connect+0x30>

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    if (pcb == ipcb) {
      /* already on the list, just return */
      return ERR_OK;
    d808:	0005883a 	mov	r2,zero
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  udp_pcbs = pcb;
  return ERR_OK;
}
    d80c:	dfc00317 	ldw	ra,12(sp)
    d810:	dc800217 	ldw	r18,8(sp)
    d814:	dc400117 	ldw	r17,4(sp)
    d818:	dc000017 	ldw	r16,0(sp)
    d81c:	dec00404 	addi	sp,sp,16
    d820:	f800283a 	ret

0000d824 <udp_disconnect>:
{
  /* reset remote address association */
  ip_addr_set_any(&pcb->remote_ip);
  pcb->remote_port = 0;
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
    d824:	20800403 	ldbu	r2,16(r4)
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  /* reset remote address association */
  ip_addr_set_any(&pcb->remote_ip);
    d828:	20000115 	stw	zero,4(r4)
  pcb->remote_port = 0;
    d82c:	2000050d 	sth	zero,20(r4)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
    d830:	10803ecc 	andi	r2,r2,251
    d834:	20800405 	stb	r2,16(r4)
    d838:	f800283a 	ret

0000d83c <udp_recv>:
 */
void
udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
  /* remember recv() callback and user data */
  pcb->recv = recv;
    d83c:	21400615 	stw	r5,24(r4)
  pcb->recv_arg = recv_arg;
    d840:	21800715 	stw	r6,28(r4)
    d844:	f800283a 	ret

0000d848 <udp_remove>:
{
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
    d848:	d0e8ca17 	ldw	r3,-23768(gp)
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
    d84c:	200b883a 	mov	r5,r4
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
    d850:	19000e26 	beq	r3,r4,d88c <udp_remove+0x44>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
    d854:	18000626 	beq	r3,zero,d870 <udp_remove+0x28>
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
    d858:	18800317 	ldw	r2,12(r3)
    d85c:	10000426 	beq	r2,zero,d870 <udp_remove+0x28>
    d860:	28800526 	beq	r5,r2,d878 <udp_remove+0x30>
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
    d864:	1007883a 	mov	r3,r2
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
    d868:	18800317 	ldw	r2,12(r3)
    d86c:	103ffc1e 	bne	r2,zero,d860 <udp_remove+0x18>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
    d870:	01000044 	movi	r4,1
    d874:	000618c1 	jmpi	618c <memp_free>
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
    d878:	28800317 	ldw	r2,12(r5)
    d87c:	18800315 	stw	r2,12(r3)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
    d880:	103ffb26 	beq	r2,zero,d870 <udp_remove+0x28>
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
    d884:	1007883a 	mov	r3,r2
    d888:	003ff706 	br	d868 <udp_remove+0x20>

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    d88c:	20800317 	ldw	r2,12(r4)
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
    d890:	01000044 	movi	r4,1

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    d894:	d0a8ca15 	stw	r2,-23768(gp)
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
    d898:	000618c1 	jmpi	618c <memp_free>

0000d89c <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
    d89c:	defffe04 	addi	sp,sp,-8
  struct udp_pcb *pcb;
  pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
    d8a0:	01000044 	movi	r4,1
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
    d8a4:	dc000015 	stw	r16,0(sp)
    d8a8:	dfc00115 	stw	ra,4(sp)
  struct udp_pcb *pcb;
  pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
    d8ac:	00060a40 	call	60a4 <memp_malloc>
    d8b0:	1021883a 	mov	r16,r2
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
    d8b4:	10000626 	beq	r2,zero,d8d0 <udp_new+0x34>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
    d8b8:	1009883a 	mov	r4,r2
    d8bc:	000b883a 	mov	r5,zero
    d8c0:	01800804 	movi	r6,32
    d8c4:	00103300 	call	10330 <memset>
    pcb->ttl = UDP_TTL;
    d8c8:	00bfffc4 	movi	r2,-1
    d8cc:	80800285 	stb	r2,10(r16)
  }
  return pcb;
}
    d8d0:	8005883a 	mov	r2,r16
    d8d4:	dfc00117 	ldw	ra,4(sp)
    d8d8:	dc000017 	ldw	r16,0(sp)
    d8dc:	dec00204 	addi	sp,sp,8
    d8e0:	f800283a 	ret

0000d8e4 <etharp_free_entry>:
#endif /* ARP_QUEUEING */

/** Clean up ARP table entries */
static void
etharp_free_entry(int i)
{
    d8e4:	defffb04 	addi	sp,sp,-20
    d8e8:	dc800215 	stw	r18,8(sp)
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
    d8ec:	24800524 	muli	r18,r4,20
#endif /* ARP_QUEUEING */

/** Clean up ARP table entries */
static void
etharp_free_entry(int i)
{
    d8f0:	dc400115 	stw	r17,4(sp)
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
    d8f4:	04400134 	movhi	r17,4
    d8f8:	8c67c404 	addi	r17,r17,-24816
    d8fc:	8c85883a 	add	r2,r17,r18
#endif /* ARP_QUEUEING */

/** Clean up ARP table entries */
static void
etharp_free_entry(int i)
{
    d900:	dcc00315 	stw	r19,12(sp)
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
    d904:	14c00017 	ldw	r19,0(r2)
#endif /* ARP_QUEUEING */

/** Clean up ARP table entries */
static void
etharp_free_entry(int i)
{
    d908:	dfc00415 	stw	ra,16(sp)
    d90c:	dc000015 	stw	r16,0(sp)
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
    d910:	98001026 	beq	r19,zero,d954 <etharp_free_entry+0x70>
static void
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
    d914:	99000117 	ldw	r4,4(r19)
    d918:	20002026 	beq	r4,zero,d99c <etharp_free_entry+0xb8>
  while (q) {
    r = q;
    q = q->next;
    d91c:	9c000017 	ldw	r16,0(r19)
    d920:	00000506 	br	d938 <etharp_free_entry+0x54>
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    d924:	81000117 	ldw	r4,4(r16)
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
    r = q;
    q = q->next;
    d928:	80800017 	ldw	r2,0(r16)
    d92c:	8027883a 	mov	r19,r16
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    d930:	20001126 	beq	r4,zero,d978 <etharp_free_entry+0x94>
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
    r = q;
    q = q->next;
    d934:	1021883a 	mov	r16,r2
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    d938:	00067d80 	call	67d8 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
    d93c:	980b883a 	mov	r5,r19
    d940:	01000184 	movi	r4,6
    d944:	000618c0 	call	618c <memp_free>
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
    d948:	803ff61e 	bne	r16,zero,d924 <etharp_free_entry+0x40>
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
    arp_table[i].q = NULL;
    d94c:	8c85883a 	add	r2,r17,r18
    d950:	10000015 	stw	zero,0(r2)
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
    d954:	8ca3883a 	add	r17,r17,r18
    d958:	88000485 	stb	zero,18(r17)
  arp_table[i].ctime = 0;
  arp_table[i].netif = NULL;
  ip_addr_set_zero(&arp_table[i].ipaddr);
  arp_table[i].ethaddr = ethzero;
#endif /* LWIP_DEBUG */
}
    d95c:	dfc00417 	ldw	ra,16(sp)
    d960:	dcc00317 	ldw	r19,12(sp)
    d964:	dc800217 	ldw	r18,8(sp)
    d968:	dc400117 	ldw	r17,4(sp)
    d96c:	dc000017 	ldw	r16,0(sp)
    d970:	dec00504 	addi	sp,sp,20
    d974:	f800283a 	ret
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
    r = q;
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    d978:	010000b4 	movhi	r4,2
    d97c:	210d4b04 	addi	r4,r4,13612
    d980:	014000b4 	movhi	r5,2
    d984:	29576604 	addi	r5,r5,23960
    d988:	018028c4 	movi	r6,163
    d98c:	01c000b4 	movhi	r7,2
    d990:	39d76004 	addi	r7,r7,23936
    d994:	00104380 	call	10438 <printf>
    d998:	003fff06 	br	d998 <etharp_free_entry+0xb4>
static void
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
    d99c:	010000b4 	movhi	r4,2
    d9a0:	210d4b04 	addi	r4,r4,13612
    d9a4:	014000b4 	movhi	r5,2
    d9a8:	29575c04 	addi	r5,r5,23920
    d9ac:	018027c4 	movi	r6,159
    d9b0:	01c000b4 	movhi	r7,2
    d9b4:	39d76004 	addi	r7,r7,23936
    d9b8:	00104380 	call	10438 <printf>
    d9bc:	003fff06 	br	d9bc <etharp_free_entry+0xd8>

0000d9c0 <etharp_find_entry>:
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
    d9c0:	defffa04 	addi	sp,sp,-24
    d9c4:	00c00134 	movhi	r3,4
    d9c8:	18e7c884 	addi	r3,r3,-24798
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
    d9cc:	03000284 	movi	r12,10
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
    d9d0:	dc400115 	stw	r17,4(sp)
    d9d4:	1c7ffb84 	addi	r17,r3,-18
    d9d8:	dd000415 	stw	r20,16(sp)
    d9dc:	dcc00315 	stw	r19,12(sp)
    d9e0:	dc800215 	stw	r18,8(sp)
    d9e4:	dc000015 	stw	r16,0(sp)
    d9e8:	dfc00515 	stw	ra,20(sp)
    d9ec:	2021883a 	mov	r16,r4
    d9f0:	8811883a 	mov	r8,r17
    d9f4:	89c00104 	addi	r7,r17,4
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
  /* its age */
  u8_t age_queue = 0;
    d9f8:	0029883a 	mov	r20,zero
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
    d9fc:	0027883a 	mov	r19,zero
    da00:	0025883a 	mov	r18,zero
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    da04:	0005883a 	mov	r2,zero
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  s8_t empty = ARP_TABLE_SIZE;
    da08:	6017883a 	mov	r11,r12
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
    da0c:	601b883a 	mov	r13,r12
    da10:	6009883a 	mov	r4,r12
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
    da14:	01800284 	movi	r6,10
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
    da18:	03800044 	movi	r14,1
    da1c:	00000706 	br	da3c <etharp_find_entry+0x7c>
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    } else if (state != ETHARP_STATE_EMPTY) {
    da20:	48002e1e 	bne	r9,zero,dadc <etharp_find_entry+0x11c>
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    da24:	10800044 	addi	r2,r2,1
    da28:	12403fcc 	andi	r9,r2,255
    da2c:	18c00504 	addi	r3,r3,20
    da30:	42000504 	addi	r8,r8,20
    da34:	39c00504 	addi	r7,r7,20
    da38:	49800e26 	beq	r9,r6,da74 <etharp_find_entry+0xb4>
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
    da3c:	5a803fcc 	andi	r10,r11,255
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
    da40:	1a400003 	ldbu	r9,0(r3)
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
    da44:	5280201c 	xori	r10,r10,128
    da48:	52bfe004 	addi	r10,r10,-128
    da4c:	4a403fcc 	andi	r9,r9,255
    da50:	51bff31e 	bne	r10,r6,da20 <etharp_find_entry+0x60>
    da54:	4800211e 	bne	r9,zero,dadc <etharp_find_entry+0x11c>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    da58:	1017883a 	mov	r11,r2
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    da5c:	10800044 	addi	r2,r2,1
    da60:	12403fcc 	andi	r9,r2,255
    da64:	18c00504 	addi	r3,r3,20
    da68:	42000504 	addi	r8,r8,20
    da6c:	39c00504 	addi	r7,r7,20
    da70:	49bff21e 	bne	r9,r6,da3c <etharp_find_entry+0x7c>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
    da74:	2880008c 	andi	r2,r5,2
    da78:	10803fcc 	andi	r2,r2,255
    da7c:	10006c1e 	bne	r2,zero,dc30 <etharp_find_entry+0x270>
    da80:	5c803fcc 	andi	r18,r11,255
    da84:	9480201c 	xori	r18,r18,128
    da88:	94bfe004 	addi	r18,r18,-128
    da8c:	91803226 	beq	r18,r6,db58 <etharp_find_entry+0x198>
   * { ETHARP_FLAG_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
    da90:	5827883a 	mov	r19,r11
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
    etharp_free_entry(i);
  }

  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
    da94:	94800524 	muli	r18,r18,20
    da98:	8c85883a 	add	r2,r17,r18
    da9c:	10c00483 	ldbu	r3,18(r2)
    daa0:	1800241e 	bne	r3,zero,db34 <etharp_find_entry+0x174>
    arp_table[i].state == ETHARP_STATE_EMPTY);

  /* IP address given? */
  if (ipaddr != NULL) {
    daa4:	80000226 	beq	r16,zero,dab0 <etharp_find_entry+0xf0>
    /* set IP address */
    ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
    daa8:	80c00017 	ldw	r3,0(r16)
    daac:	10c00115 	stw	r3,4(r2)
  }
  arp_table[i].ctime = 0;
    dab0:	8ca3883a 	add	r17,r17,r18
    dab4:	880004c5 	stb	zero,19(r17)
  return (err_t)i;
    dab8:	9805883a 	mov	r2,r19
}
    dabc:	dfc00517 	ldw	ra,20(sp)
    dac0:	dd000417 	ldw	r20,16(sp)
    dac4:	dcc00317 	ldw	r19,12(sp)
    dac8:	dc800217 	ldw	r18,8(sp)
    dacc:	dc400117 	ldw	r17,4(sp)
    dad0:	dc000017 	ldw	r16,0(sp)
    dad4:	dec00604 	addi	sp,sp,24
    dad8:	f800283a 	ret
      empty = i;
    } else if (state != ETHARP_STATE_EMPTY) {
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
        state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
    dadc:	80000326 	beq	r16,zero,daec <etharp_find_entry+0x12c>
    dae0:	83c00017 	ldw	r15,0(r16)
    dae4:	3a800017 	ldw	r10,0(r7)
    dae8:	7abff426 	beq	r15,r10,dabc <etharp_find_entry+0xfc>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
    daec:	4b800826 	beq	r9,r14,db10 <etharp_find_entry+0x150>
            old_pending = i;
            age_pending = arp_table[i].ctime;
          }
        }
      /* stable entry? */
      } else if (state >= ETHARP_STATE_STABLE) {
    daf0:	727fcc2e 	bgeu	r14,r9,da24 <etharp_find_entry+0x64>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
    daf4:	1a400043 	ldbu	r9,1(r3)
    daf8:	9a803fcc 	andi	r10,r19,255
    dafc:	4bc03fcc 	andi	r15,r9,255
    db00:	7abfc836 	bltu	r15,r10,da24 <etharp_find_entry+0x64>
            old_stable = i;
    db04:	101b883a 	mov	r13,r2
    db08:	4827883a 	mov	r19,r9
    db0c:	003fc506 	br	da24 <etharp_find_entry+0x64>
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
    db10:	42400017 	ldw	r9,0(r8)
    db14:	48003f26 	beq	r9,zero,dc14 <etharp_find_entry+0x254>
          if (arp_table[i].ctime >= age_queue) {
    db18:	1a400043 	ldbu	r9,1(r3)
    db1c:	a2803fcc 	andi	r10,r20,255
    db20:	4bc03fcc 	andi	r15,r9,255
    db24:	7abfbf36 	bltu	r15,r10,da24 <etharp_find_entry+0x64>
            old_queue = i;
    db28:	1019883a 	mov	r12,r2
    db2c:	4829883a 	mov	r20,r9
    db30:	003fbc06 	br	da24 <etharp_find_entry+0x64>
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
    etharp_free_entry(i);
  }

  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
    db34:	010000b4 	movhi	r4,2
    db38:	210d4b04 	addi	r4,r4,13612
    db3c:	014000b4 	movhi	r5,2
    db40:	29577504 	addi	r5,r5,24020
    db44:	01806244 	movi	r6,393
    db48:	01c000b4 	movhi	r7,2
    db4c:	39d76004 	addi	r7,r7,23936
    db50:	00104380 	call	10438 <printf>
    db54:	003fff06 	br	db54 <etharp_find_entry+0x194>
  /* { we have no match } => try to create a new entry */
   
  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
      /* or no empty entry found and not allowed to recycle? */
      ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
    db58:	2940004c 	andi	r5,r5,1
    db5c:	28003426 	beq	r5,zero,dc30 <etharp_find_entry+0x270>
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  } else {
    /* 2) found recyclable stable entry? */
    if (old_stable < ARP_TABLE_SIZE) {
    db60:	68803fcc 	andi	r2,r13,255
    db64:	1080201c 	xori	r2,r2,128
    db68:	10bfe004 	addi	r2,r2,-128
    db6c:	11800e26 	beq	r2,r6,dba8 <etharp_find_entry+0x1e8>
      /* recycle oldest stable*/
      i = old_stable;
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
      /* no queued packets should exist on stable entries */
      LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
    db70:	10800524 	muli	r2,r2,20
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  } else {
    /* 2) found recyclable stable entry? */
    if (old_stable < ARP_TABLE_SIZE) {
      /* recycle oldest stable*/
      i = old_stable;
    db74:	6827883a 	mov	r19,r13
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
      /* no queued packets should exist on stable entries */
      LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
    db78:	8885883a 	add	r2,r17,r2
    db7c:	10800017 	ldw	r2,0(r2)
    db80:	10001a26 	beq	r2,zero,dbec <etharp_find_entry+0x22c>
    db84:	010000b4 	movhi	r4,2
    db88:	210d4b04 	addi	r4,r4,13612
    db8c:	014000b4 	movhi	r5,2
    db90:	29576a04 	addi	r5,r5,23976
    db94:	01805c44 	movi	r6,369
    db98:	01c000b4 	movhi	r7,2
    db9c:	39d76004 	addi	r7,r7,23936
    dba0:	00104380 	call	10438 <printf>
    dba4:	003fff06 	br	dba4 <etharp_find_entry+0x1e4>
    /* 3) found recyclable pending entry without queued packets? */
    } else if (old_pending < ARP_TABLE_SIZE) {
    dba8:	20803fcc 	andi	r2,r4,255
    dbac:	1080201c 	xori	r2,r2,128
    dbb0:	10bfe004 	addi	r2,r2,-128
    dbb4:	11801126 	beq	r2,r6,dbfc <etharp_find_entry+0x23c>
      /* recycle oldest pending */
      i = old_pending;
    dbb8:	2027883a 	mov	r19,r4
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty or recyclable entries found\n"));
      return (s8_t)ERR_MEM;
    }

    /* { empty or recyclable entry found } */
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
    dbbc:	9c803fcc 	andi	r18,r19,255
    dbc0:	00800244 	movi	r2,9
    dbc4:	14800a2e 	bgeu	r2,r18,dbf0 <etharp_find_entry+0x230>
    dbc8:	010000b4 	movhi	r4,2
    dbcc:	210d4b04 	addi	r4,r4,13612
    dbd0:	014000b4 	movhi	r5,2
    dbd4:	29577004 	addi	r5,r5,24000
    dbd8:	018060c4 	movi	r6,387
    dbdc:	01c000b4 	movhi	r7,2
    dbe0:	39d76004 	addi	r7,r7,23936
    dbe4:	00104380 	call	10438 <printf>
    dbe8:	003fff06 	br	dbe8 <etharp_find_entry+0x228>
    dbec:	6c803fcc 	andi	r18,r13,255
    etharp_free_entry(i);
    dbf0:	9009883a 	mov	r4,r18
    dbf4:	000d8e40 	call	d8e4 <etharp_free_entry>
    dbf8:	003fa606 	br	da94 <etharp_find_entry+0xd4>
    } else if (old_pending < ARP_TABLE_SIZE) {
      /* recycle oldest pending */
      i = old_pending;
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
    /* 4) found recyclable pending entry with queued packets? */
    } else if (old_queue < ARP_TABLE_SIZE) {
    dbfc:	60803fcc 	andi	r2,r12,255
    dc00:	1080201c 	xori	r2,r2,128
    dc04:	10bfe004 	addi	r2,r2,-128
    dc08:	11800926 	beq	r2,r6,dc30 <etharp_find_entry+0x270>
      /* recycle oldest pending (queued packets are free in etharp_free_entry) */
      i = old_queue;
    dc0c:	6027883a 	mov	r19,r12
    dc10:	003fea06 	br	dbbc <etharp_find_entry+0x1fc>
            age_queue = arp_table[i].ctime;
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
    dc14:	1a400043 	ldbu	r9,1(r3)
    dc18:	92803fcc 	andi	r10,r18,255
    dc1c:	4bc03fcc 	andi	r15,r9,255
    dc20:	7abf8036 	bltu	r15,r10,da24 <etharp_find_entry+0x64>
            old_pending = i;
    dc24:	1009883a 	mov	r4,r2
    dc28:	4825883a 	mov	r18,r9
    dc2c:	003f7d06 	br	da24 <etharp_find_entry+0x64>
  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
      /* or no empty entry found and not allowed to recycle? */
      ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
    dc30:	00bfffc4 	movi	r2,-1
    /* set IP address */
    ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
  }
  arp_table[i].ctime = 0;
  return (err_t)i;
}
    dc34:	dfc00517 	ldw	ra,20(sp)
    dc38:	dd000417 	ldw	r20,16(sp)
    dc3c:	dcc00317 	ldw	r19,12(sp)
    dc40:	dc800217 	ldw	r18,8(sp)
    dc44:	dc400117 	ldw	r17,4(sp)
    dc48:	dc000017 	ldw	r16,0(sp)
    dc4c:	dec00604 	addi	sp,sp,24
    dc50:	f800283a 	ret

0000dc54 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
    dc54:	deffff04 	addi	sp,sp,-4
    dc58:	dfc00015 	stw	ra,0(sp)
  struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
    dc5c:	20800983 	ldbu	r2,38(r4)
    dc60:	00c00184 	movi	r3,6
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
    dc64:	2a000117 	ldw	r8,4(r5)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
    dc68:	10c00926 	beq	r2,r3,dc90 <etharp_send_ip+0x3c>
    dc6c:	010000b4 	movhi	r4,2
    dc70:	210d4b04 	addi	r4,r4,13612
    dc74:	014000b4 	movhi	r5,2
    dc78:	29578004 	addi	r5,r5,24064
    dc7c:	01806904 	movi	r6,420
    dc80:	01c000b4 	movhi	r7,2
    dc84:	39d76004 	addi	r7,r7,23936
    dc88:	00104380 	call	10438 <printf>
    dc8c:	003fff06 	br	dc8c <etharp_send_ip+0x38>
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  ETHADDR32_COPY(&ethhdr->dest, dst);
    dc90:	3a800003 	ldbu	r10,0(r7)
    dc94:	40c00084 	addi	r3,r8,2
  ETHADDR16_COPY(&ethhdr->src, src);
    dc98:	40800204 	addi	r2,r8,8
{
  struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  ETHADDR32_COPY(&ethhdr->dest, dst);
    dc9c:	1a800005 	stb	r10,0(r3)
    dca0:	3a800043 	ldbu	r10,1(r7)
    dca4:	428000c5 	stb	r10,3(r8)
    dca8:	3a800083 	ldbu	r10,2(r7)
    dcac:	42800105 	stb	r10,4(r8)
    dcb0:	3a8000c3 	ldbu	r10,3(r7)
    dcb4:	42800145 	stb	r10,5(r8)
    dcb8:	3a800103 	ldbu	r10,4(r7)
    dcbc:	42800185 	stb	r10,6(r8)
    dcc0:	39c00143 	ldbu	r7,5(r7)
    dcc4:	41c001c5 	stb	r7,7(r8)
  ETHADDR16_COPY(&ethhdr->src, src);
    dcc8:	30c00003 	ldbu	r3,0(r6)
    dccc:	10c00005 	stb	r3,0(r2)
    dcd0:	30c00043 	ldbu	r3,1(r6)
    dcd4:	40c00245 	stb	r3,9(r8)
    dcd8:	30c00083 	ldbu	r3,2(r6)
    dcdc:	40c00285 	stb	r3,10(r8)
    dce0:	30c000c3 	ldbu	r3,3(r6)
    dce4:	40c002c5 	stb	r3,11(r8)
    dce8:	30c00103 	ldbu	r3,4(r6)
    dcec:	40c00305 	stb	r3,12(r8)
    dcf0:	30c00143 	ldbu	r3,5(r6)
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
    dcf4:	01800204 	movi	r6,8
    dcf8:	4180038d 	sth	r6,14(r8)
  struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  ETHADDR32_COPY(&ethhdr->dest, dst);
  ETHADDR16_COPY(&ethhdr->src, src);
    dcfc:	40c00345 	stb	r3,13(r8)
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
    dd00:	20800617 	ldw	r2,24(r4)
}
    dd04:	dfc00017 	ldw	ra,0(sp)
    dd08:	dec00104 	addi	sp,sp,4
  ETHADDR32_COPY(&ethhdr->dest, dst);
  ETHADDR16_COPY(&ethhdr->src, src);
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
    dd0c:	1000683a 	jmp	r2

0000dd10 <etharp_update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
etharp_update_arp_entry(struct netif *netif, ip_addr_t *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
    dd10:	defffa04 	addi	sp,sp,-24
    dd14:	dcc00315 	stw	r19,12(sp)
    dd18:	dc800215 	stw	r18,8(sp)
    dd1c:	dc400115 	stw	r17,4(sp)
    dd20:	dc000015 	stw	r16,0(sp)
    dd24:	dfc00515 	stw	ra,20(sp)
    dd28:	dd000415 	stw	r20,16(sp)
  s8_t i;
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
    dd2c:	20800983 	ldbu	r2,38(r4)
    dd30:	00c00184 	movi	r3,6
 *
 * @see pbuf_free()
 */
static err_t
etharp_update_arp_entry(struct netif *netif, ip_addr_t *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
    dd34:	2023883a 	mov	r17,r4
    dd38:	2825883a 	mov	r18,r5
    dd3c:	3021883a 	mov	r16,r6
    dd40:	3827883a 	mov	r19,r7
  s8_t i;
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
    dd44:	10c00926 	beq	r2,r3,dd6c <etharp_update_arp_entry+0x5c>
    dd48:	010000b4 	movhi	r4,2
    dd4c:	210d4b04 	addi	r4,r4,13612
    dd50:	014000b4 	movhi	r5,2
    dd54:	29579104 	addi	r5,r5,24132
    dd58:	018070c4 	movi	r6,451
    dd5c:	01c000b4 	movhi	r7,2
    dd60:	39d76004 	addi	r7,r7,23936
    dd64:	00104380 	call	10438 <printf>
    dd68:	003fff06 	br	dd68 <etharp_update_arp_entry+0x58>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
    dd6c:	28004126 	beq	r5,zero,de74 <etharp_update_arp_entry+0x164>
    dd70:	29000017 	ldw	r4,0(r5)
    dd74:	20003f26 	beq	r4,zero,de74 <etharp_update_arp_entry+0x164>
      ip_addr_isbroadcast(ipaddr, netif) ||
    dd78:	880b883a 	mov	r5,r17
    dd7c:	00049440 	call	4944 <ip4_addr_isbroadcast>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
    dd80:	10803fcc 	andi	r2,r2,255
    dd84:	10003b1e 	bne	r2,zero,de74 <etharp_update_arp_entry+0x164>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
    dd88:	90c00017 	ldw	r3,0(r18)
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
    dd8c:	00803804 	movi	r2,224
      ip_addr_ismulticast(ipaddr)) {
    dd90:	18c03c0c 	andi	r3,r3,240
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
    dd94:	18803726 	beq	r3,r2,de74 <etharp_update_arp_entry+0x164>
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  }
  /* find or create ARP entry */
  i = etharp_find_entry(ipaddr, flags);
    dd98:	9009883a 	mov	r4,r18
    dd9c:	99403fcc 	andi	r5,r19,255
    dda0:	000d9c00 	call	d9c0 <etharp_find_entry>
  /* bail out if no entry could be found */
  if (i < 0) {
    dda4:	10c03fcc 	andi	r3,r2,255
    dda8:	18c0201c 	xori	r3,r3,128
    ddac:	18ffe004 	addi	r3,r3,-128
    ddb0:	18002816 	blt	r3,zero,de54 <etharp_update_arp_entry+0x144>
    arp_table[i].state = ETHARP_STATE_STATIC;
  } else
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
  {
    /* mark it stable */
    arp_table[i].state = ETHARP_STATE_STABLE;
    ddb4:	18c00524 	muli	r3,r3,20
    ddb8:	00800134 	movhi	r2,4
    ddbc:	10a7c404 	addi	r2,r2,-24816
    ddc0:	10c7883a 	add	r3,r2,r3
    ddc4:	00800084 	movi	r2,2
    ddc8:	18800485 	stb	r2,18(r3)
  }

  /* record network interface */
  arp_table[i].netif = netif;
    ddcc:	1c400215 	stw	r17,8(r3)
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
    ddd0:	81800003 	ldbu	r6,0(r16)
    ddd4:	18800304 	addi	r2,r3,12
  /* reset time stamp */
  arp_table[i].ctime = 0;
  /* this is where we will send out queued packets! */
#if ARP_QUEUEING
  while (arp_table[i].q != NULL) {
    ddd8:	19400017 	ldw	r5,0(r3)
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
    dddc:	11800005 	stb	r6,0(r2)
    dde0:	81800043 	ldbu	r6,1(r16)
    dde4:	19800345 	stb	r6,13(r3)
    dde8:	81800083 	ldbu	r6,2(r16)
    ddec:	19800385 	stb	r6,14(r3)
    ddf0:	818000c3 	ldbu	r6,3(r16)
    ddf4:	198003c5 	stb	r6,15(r3)
    ddf8:	81800103 	ldbu	r6,4(r16)
    ddfc:	19800405 	stb	r6,16(r3)
    de00:	81800143 	ldbu	r6,5(r16)
  /* reset time stamp */
  arp_table[i].ctime = 0;
    de04:	180004c5 	stb	zero,19(r3)
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
    de08:	19800445 	stb	r6,17(r3)
  /* reset time stamp */
  arp_table[i].ctime = 0;
  /* this is where we will send out queued packets! */
#if ARP_QUEUEING
  while (arp_table[i].q != NULL) {
    de0c:	28001026 	beq	r5,zero,de50 <etharp_update_arp_entry+0x140>
    de10:	8cc009c4 	addi	r19,r17,39
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
    /* pop first item off the queue */
    arp_table[i].q = q->next;
    de14:	1829883a 	mov	r20,r3
    de18:	28800017 	ldw	r2,0(r5)
    /* get the packet pointer */
    p = q->p;
    de1c:	2c800117 	ldw	r18,4(r5)
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
    de20:	01000184 	movi	r4,6
  while (arp_table[i].q != NULL) {
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
    /* pop first item off the queue */
    arp_table[i].q = q->next;
    de24:	a0800015 	stw	r2,0(r20)
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
    de28:	000618c0 	call	618c <memp_free>
  if (arp_table[i].q != NULL) {
    struct pbuf *p = arp_table[i].q;
    arp_table[i].q = NULL;
#endif /* ARP_QUEUEING */
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
    de2c:	900b883a 	mov	r5,r18
    de30:	8809883a 	mov	r4,r17
    de34:	980d883a 	mov	r6,r19
    de38:	800f883a 	mov	r7,r16
    de3c:	000dc540 	call	dc54 <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
    de40:	9009883a 	mov	r4,r18
    de44:	00067d80 	call	67d8 <pbuf_free>
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
  /* reset time stamp */
  arp_table[i].ctime = 0;
  /* this is where we will send out queued packets! */
#if ARP_QUEUEING
  while (arp_table[i].q != NULL) {
    de48:	a1400017 	ldw	r5,0(r20)
    de4c:	283ff21e 	bne	r5,zero,de18 <etharp_update_arp_entry+0x108>
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
    /* free the queued IP packet */
    pbuf_free(p);
  }
  return ERR_OK;
    de50:	0005883a 	mov	r2,zero
}
    de54:	dfc00517 	ldw	ra,20(sp)
    de58:	dd000417 	ldw	r20,16(sp)
    de5c:	dcc00317 	ldw	r19,12(sp)
    de60:	dc800217 	ldw	r18,8(sp)
    de64:	dc400117 	ldw	r17,4(sp)
    de68:	dc000017 	ldw	r16,0(sp)
    de6c:	dec00604 	addi	sp,sp,24
    de70:	f800283a 	ret
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
    de74:	00bffc84 	movi	r2,-14
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
    /* free the queued IP packet */
    pbuf_free(p);
  }
  return ERR_OK;
}
    de78:	dfc00517 	ldw	ra,20(sp)
    de7c:	dd000417 	ldw	r20,16(sp)
    de80:	dcc00317 	ldw	r19,12(sp)
    de84:	dc800217 	ldw	r18,8(sp)
    de88:	dc400117 	ldw	r17,4(sp)
    de8c:	dc000017 	ldw	r16,0(sp)
    de90:	dec00604 	addi	sp,sp,24
    de94:	f800283a 	ret

0000de98 <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL milliseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
    de98:	defff804 	addi	sp,sp,-32
    de9c:	dd800615 	stw	r22,24(sp)
    dea0:	dd400515 	stw	r21,20(sp)
    dea4:	dd000415 	stw	r20,16(sp)
    dea8:	dcc00315 	stw	r19,12(sp)
    deac:	dc800215 	stw	r18,8(sp)
    deb0:	dc400115 	stw	r17,4(sp)
    deb4:	dc000015 	stw	r16,0(sp)
    deb8:	dfc00715 	stw	ra,28(sp)
    debc:	04000134 	movhi	r16,4
    dec0:	8427c884 	addi	r16,r16,-24798
    dec4:	0023883a 	mov	r17,zero
#if ETHARP_SUPPORT_STATIC_ENTRIES
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
    dec8:	05403bc4 	movi	r21,239
    decc:	05800044 	movi	r22,1
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %"U16_F".\n",
             arp_table[i].state >= ETHARP_STATE_STABLE ? "stable" : "pending", (u16_t)i));
        /* clean up entries that have just been expired */
        etharp_free_entry(i);
      }
      else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
    ded0:	04c000c4 	movi	r19,3
        /* Reset state to stable, so that the next transmitted packet will
           re-send an ARP request. */
        arp_table[i].state = ETHARP_STATE_STABLE;
    ded4:	05000084 	movi	r20,2
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    ded8:	04800284 	movi	r18,10
    dedc:	00000506 	br	def4 <etharp_tmr+0x5c>
#if ETHARP_SUPPORT_STATIC_ENTRIES
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
    dee0:	15801a26 	beq	r2,r22,df4c <etharp_tmr+0xb4>
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %"U16_F".\n",
             arp_table[i].state >= ETHARP_STATE_STABLE ? "stable" : "pending", (u16_t)i));
        /* clean up entries that have just been expired */
        etharp_free_entry(i);
      }
      else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
    dee4:	14c01c26 	beq	r2,r19,df58 <etharp_tmr+0xc0>
    dee8:	8c400044 	addi	r17,r17,1
    deec:	84000504 	addi	r16,r16,20
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    def0:	8c800c26 	beq	r17,r18,df24 <etharp_tmr+0x8c>
    u8_t state = arp_table[i].state;
    if (state != ETHARP_STATE_EMPTY
    def4:	80800003 	ldbu	r2,0(r16)
    def8:	103ffb26 	beq	r2,zero,dee8 <etharp_tmr+0x50>
#if ETHARP_SUPPORT_STATIC_ENTRIES
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
    defc:	80c00043 	ldbu	r3,1(r16)
           (arp_table[i].ctime >= ARP_MAXPENDING))) {
        /* pending or stable entry has become old! */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %"U16_F".\n",
             arp_table[i].state >= ETHARP_STATE_STABLE ? "stable" : "pending", (u16_t)i));
        /* clean up entries that have just been expired */
        etharp_free_entry(i);
    df00:	8809883a 	mov	r4,r17
    if (state != ETHARP_STATE_EMPTY
#if ETHARP_SUPPORT_STATIC_ENTRIES
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
    df04:	18c00044 	addi	r3,r3,1
    df08:	80c00045 	stb	r3,1(r16)
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
    df0c:	18c03fcc 	andi	r3,r3,255
    df10:	a8fff32e 	bgeu	r21,r3,dee0 <etharp_tmr+0x48>
           (arp_table[i].ctime >= ARP_MAXPENDING))) {
        /* pending or stable entry has become old! */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %"U16_F".\n",
             arp_table[i].state >= ETHARP_STATE_STABLE ? "stable" : "pending", (u16_t)i));
        /* clean up entries that have just been expired */
        etharp_free_entry(i);
    df14:	000d8e40 	call	d8e4 <etharp_free_entry>
    df18:	8c400044 	addi	r17,r17,1
    df1c:	84000504 	addi	r16,r16,20
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    df20:	8cbff41e 	bne	r17,r18,def4 <etharp_tmr+0x5c>
        /* resend an ARP query here? */
      }
#endif /* ARP_QUEUEING */
    }
  }
}
    df24:	dfc00717 	ldw	ra,28(sp)
    df28:	dd800617 	ldw	r22,24(sp)
    df2c:	dd400517 	ldw	r21,20(sp)
    df30:	dd000417 	ldw	r20,16(sp)
    df34:	dcc00317 	ldw	r19,12(sp)
    df38:	dc800217 	ldw	r18,8(sp)
    df3c:	dc400117 	ldw	r17,4(sp)
    df40:	dc000017 	ldw	r16,0(sp)
    df44:	dec00804 	addi	sp,sp,32
    df48:	f800283a 	ret
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
    df4c:	b0ffe62e 	bgeu	r22,r3,dee8 <etharp_tmr+0x50>
           (arp_table[i].ctime >= ARP_MAXPENDING))) {
        /* pending or stable entry has become old! */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %"U16_F".\n",
             arp_table[i].state >= ETHARP_STATE_STABLE ? "stable" : "pending", (u16_t)i));
        /* clean up entries that have just been expired */
        etharp_free_entry(i);
    df50:	000d8e40 	call	d8e4 <etharp_free_entry>
    df54:	003ff006 	br	df18 <etharp_tmr+0x80>
      }
      else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
        /* Reset state to stable, so that the next transmitted packet will
           re-send an ARP request. */
        arp_table[i].state = ETHARP_STATE_STABLE;
    df58:	85000005 	stb	r20,0(r16)
    df5c:	003fe206 	br	dee8 <etharp_tmr+0x50>

0000df60 <etharp_cleanup_netif>:
 * Remove all ARP table entries of the specified netif.
 *
 * @param netif points to a network interface
 */
void etharp_cleanup_netif(struct netif *netif)
{
    df60:	defffa04 	addi	sp,sp,-24
    df64:	dc000015 	stw	r16,0(sp)
    df68:	04000134 	movhi	r16,4
    df6c:	8427c884 	addi	r16,r16,-24798
    df70:	dd000415 	stw	r20,16(sp)
    df74:	dcc00315 	stw	r19,12(sp)
    df78:	dc800215 	stw	r18,8(sp)
    df7c:	dc400115 	stw	r17,4(sp)
    df80:	dfc00515 	stw	ra,20(sp)
    df84:	2029883a 	mov	r20,r4
    df88:	84bffd84 	addi	r18,r16,-10
    df8c:	0023883a 	mov	r17,zero
  u8_t i;

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    df90:	04c00284 	movi	r19,10
    u8_t state = arp_table[i].state;
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
    df94:	80800003 	ldbu	r2,0(r16)
    df98:	84000504 	addi	r16,r16,20
    df9c:	10000226 	beq	r2,zero,dfa8 <etharp_cleanup_netif+0x48>
    dfa0:	90800017 	ldw	r2,0(r18)
    dfa4:	15000b26 	beq	r2,r20,dfd4 <etharp_cleanup_netif+0x74>
    dfa8:	8c400044 	addi	r17,r17,1
    dfac:	94800504 	addi	r18,r18,20
 */
void etharp_cleanup_netif(struct netif *netif)
{
  u8_t i;

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    dfb0:	8cfff81e 	bne	r17,r19,df94 <etharp_cleanup_netif+0x34>
    u8_t state = arp_table[i].state;
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
      etharp_free_entry(i);
    }
  }
}
    dfb4:	dfc00517 	ldw	ra,20(sp)
    dfb8:	dd000417 	ldw	r20,16(sp)
    dfbc:	dcc00317 	ldw	r19,12(sp)
    dfc0:	dc800217 	ldw	r18,8(sp)
    dfc4:	dc400117 	ldw	r17,4(sp)
    dfc8:	dc000017 	ldw	r16,0(sp)
    dfcc:	dec00604 	addi	sp,sp,24
    dfd0:	f800283a 	ret
  u8_t i;

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
      etharp_free_entry(i);
    dfd4:	8809883a 	mov	r4,r17
    dfd8:	000d8e40 	call	d8e4 <etharp_free_entry>
    dfdc:	003ff206 	br	dfa8 <etharp_cleanup_netif+0x48>

0000dfe0 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, ip_addr_t *ipaddr,
         struct eth_addr **eth_ret, ip_addr_t **ip_ret)
{
    dfe0:	defffd04 	addi	sp,sp,-12
    dfe4:	dc400115 	stw	r17,4(sp)
    dfe8:	dc000015 	stw	r16,0(sp)
    dfec:	dfc00215 	stw	ra,8(sp)
    dff0:	3023883a 	mov	r17,r6
    dff4:	2809883a 	mov	r4,r5
    dff8:	3821883a 	mov	r16,r7
  s8_t i;

  LWIP_ASSERT("eth_ret != NULL && ip_ret != NULL",
    dffc:	30001926 	beq	r6,zero,e064 <etharp_find_addr+0x84>
    e000:	38001826 	beq	r7,zero,e064 <etharp_find_addr+0x84>
    eth_ret != NULL && ip_ret != NULL);

  LWIP_UNUSED_ARG(netif);

  i = etharp_find_entry(ipaddr, ETHARP_FLAG_FIND_ONLY);
    e004:	01400084 	movi	r5,2
    e008:	000d9c00 	call	d9c0 <etharp_find_entry>
  if((i >= 0) && (arp_table[i].state >= ETHARP_STATE_STABLE)) {
    e00c:	11003fcc 	andi	r4,r2,255
    e010:	2100201c 	xori	r4,r4,128
    e014:	213fe004 	addi	r4,r4,-128
    e018:	20001b16 	blt	r4,zero,e088 <etharp_find_addr+0xa8>
    e01c:	21000524 	muli	r4,r4,20
    e020:	00c00134 	movhi	r3,4
    e024:	18e7c404 	addi	r3,r3,-24816
    e028:	02000044 	movi	r8,1
    e02c:	190b883a 	add	r5,r3,r4
    e030:	29400483 	ldbu	r5,18(r5)
    e034:	4140142e 	bgeu	r8,r5,e088 <etharp_find_addr+0xa8>
      *eth_ret = &arp_table[i].ethaddr;
    e038:	21400304 	addi	r5,r4,12
    e03c:	28cb883a 	add	r5,r5,r3
      *ip_ret = &arp_table[i].ipaddr;
    e040:	21000104 	addi	r4,r4,4

  LWIP_UNUSED_ARG(netif);

  i = etharp_find_entry(ipaddr, ETHARP_FLAG_FIND_ONLY);
  if((i >= 0) && (arp_table[i].state >= ETHARP_STATE_STABLE)) {
      *eth_ret = &arp_table[i].ethaddr;
    e044:	89400015 	stw	r5,0(r17)
      *ip_ret = &arp_table[i].ipaddr;
    e048:	20c7883a 	add	r3,r4,r3
    e04c:	80c00015 	stw	r3,0(r16)
      return i;
  }
  return -1;
}
    e050:	dfc00217 	ldw	ra,8(sp)
    e054:	dc400117 	ldw	r17,4(sp)
    e058:	dc000017 	ldw	r16,0(sp)
    e05c:	dec00304 	addi	sp,sp,12
    e060:	f800283a 	ret
etharp_find_addr(struct netif *netif, ip_addr_t *ipaddr,
         struct eth_addr **eth_ret, ip_addr_t **ip_ret)
{
  s8_t i;

  LWIP_ASSERT("eth_ret != NULL && ip_ret != NULL",
    e064:	010000b4 	movhi	r4,2
    e068:	210d4b04 	addi	r4,r4,13612
    e06c:	014000b4 	movhi	r5,2
    e070:	29579b04 	addi	r5,r5,24172
    e074:	01809844 	movi	r6,609
    e078:	01c000b4 	movhi	r7,2
    e07c:	39d76004 	addi	r7,r7,23936
    e080:	00104380 	call	10438 <printf>
    e084:	003fff06 	br	e084 <etharp_find_addr+0xa4>
  if((i >= 0) && (arp_table[i].state >= ETHARP_STATE_STABLE)) {
      *eth_ret = &arp_table[i].ethaddr;
      *ip_ret = &arp_table[i].ipaddr;
      return i;
  }
  return -1;
    e088:	00bfffc4 	movi	r2,-1
}
    e08c:	dfc00217 	ldw	ra,8(sp)
    e090:	dc400117 	ldw	r17,4(sp)
    e094:	dc000017 	ldw	r16,0(sp)
    e098:	dec00304 	addi	sp,sp,12
    e09c:	f800283a 	ret

0000e0a0 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
    e0a0:	defffa04 	addi	sp,sp,-24
    e0a4:	dc800315 	stw	r18,12(sp)
    e0a8:	dc000115 	stw	r16,4(sp)
    e0ac:	dfc00515 	stw	ra,20(sp)
    e0b0:	dcc00415 	stw	r19,16(sp)
    e0b4:	dc400215 	stw	r17,8(sp)
    e0b8:	2021883a 	mov	r16,r4
    e0bc:	2825883a 	mov	r18,r5
  struct etharp_hdr *hdr;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ASSERT("netif != NULL", netif != NULL);
    e0c0:	20002126 	beq	r4,zero,e148 <etharp_request+0xa8>

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
    e0c4:	010000c4 	movi	r4,3
    e0c8:	01400b04 	movi	r5,44
    e0cc:	000d883a 	mov	r6,zero
    e0d0:	0006a880 	call	6a88 <pbuf_alloc>
    e0d4:	1023883a 	mov	r17,r2
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
    e0d8:	10008a26 	beq	r2,zero,e304 <etharp_request+0x264>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
    e0dc:	1080028b 	ldhu	r2,10(r2)
    e0e0:	00c00ac4 	movi	r3,43
    e0e4:	18800f2e 	bgeu	r3,r2,e124 <etharp_request+0x84>
              (p->len >= SIZEOF_ETHARP_PACKET));

  ethhdr = (struct eth_hdr *)p->payload;
    e0e8:	88c00117 	ldw	r3,4(r17)
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
    e0ec:	02c04004 	movi	r11,256

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
    e0f0:	00800184 	movi	r2,6
              (p->len >= SIZEOF_ETHARP_PACKET));

  ethhdr = (struct eth_hdr *)p->payload;
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
    e0f4:	1ac0058d 	sth	r11,22(r3)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
    e0f8:	82800983 	ldbu	r10,38(r16)
    e0fc:	50801b26 	beq	r10,r2,e16c <etharp_request+0xcc>
    e100:	010000b4 	movhi	r4,2
    e104:	210d4b04 	addi	r4,r4,13612
    e108:	014000b4 	movhi	r5,2
    e10c:	29578004 	addi	r5,r5,24064
    e110:	01812e44 	movi	r6,1209
    e114:	01c000b4 	movhi	r7,2
    e118:	39d76004 	addi	r7,r7,23936
    e11c:	00104380 	call	10438 <printf>
    e120:	003fff06 	br	e120 <etharp_request+0x80>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
    e124:	010000b4 	movhi	r4,2
    e128:	210d4b04 	addi	r4,r4,13612
    e12c:	014000b4 	movhi	r5,2
    e130:	2957a404 	addi	r5,r5,24208
    e134:	01812c44 	movi	r6,1201
    e138:	01c000b4 	movhi	r7,2
    e13c:	39d76004 	addi	r7,r7,23936
    e140:	00104380 	call	10438 <printf>
    e144:	003fff06 	br	e144 <etharp_request+0xa4>
  struct etharp_hdr *hdr;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ASSERT("netif != NULL", netif != NULL);
    e148:	010000b4 	movhi	r4,2
    e14c:	210d4b04 	addi	r4,r4,13612
    e150:	014000b4 	movhi	r5,2
    e154:	294d7404 	addi	r5,r5,13776
    e158:	01812944 	movi	r6,1189
    e15c:	01c000b4 	movhi	r7,2
    e160:	39d76004 	addi	r7,r7,23936
    e164:	00104380 	call	10438 <printf>
    e168:	003fff06 	br	e168 <etharp_request+0xc8>
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
    e16c:	818009c4 	addi	r6,r16,39
   * 'sender IP address' MUST be sent using link-layer broadcast instead of
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
    e170:	30800003 	ldbu	r2,0(r6)
    e174:	19c00604 	addi	r7,r3,24
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
    e178:	d1200884 	addi	r4,gp,-32734
   * 'sender IP address' MUST be sent using link-layer broadcast instead of
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
    e17c:	38800005 	stb	r2,0(r7)
    e180:	81400a03 	ldbu	r5,40(r16)
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
    e184:	22000043 	ldbu	r8,1(r4)
    e188:	23c00083 	ldbu	r15,2(r4)
   * 'sender IP address' MUST be sent using link-layer broadcast instead of
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
    e18c:	19400645 	stb	r5,25(r3)
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
    e190:	da000005 	stb	r8,0(sp)
   * 'sender IP address' MUST be sent using link-layer broadcast instead of
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
    e194:	81400a43 	ldbu	r5,41(r16)
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
    e198:	238000c3 	ldbu	r14,3(r4)
    e19c:	23400103 	ldbu	r13,4(r4)
   * 'sender IP address' MUST be sent using link-layer broadcast instead of
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
    e1a0:	19400685 	stb	r5,26(r3)
    e1a4:	81400a83 	ldbu	r5,42(r16)
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
    e1a8:	23000143 	ldbu	r12,5(r4)
    e1ac:	d1e00883 	ldbu	r7,-32734(gp)
   * 'sender IP address' MUST be sent using link-layer broadcast instead of
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
    e1b0:	194006c5 	stb	r5,27(r3)
    e1b4:	81000ac3 	ldbu	r4,43(r16)
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
  /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
  ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
    e1b8:	d0a00a04 	addi	r2,gp,-32728
    e1bc:	12400043 	ldbu	r9,1(r2)
   * 'sender IP address' MUST be sent using link-layer broadcast instead of
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
    e1c0:	19000705 	stb	r4,28(r3)
    e1c4:	84c00b03 	ldbu	r19,44(r16)
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
    e1c8:	19c00885 	stb	r7,34(r3)
    e1cc:	d9c00003 	ldbu	r7,0(sp)
  /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
  ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
    e1d0:	12000083 	ldbu	r8,2(r2)
    e1d4:	1a4000c5 	stb	r9,3(r3)
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
    e1d8:	19c008c5 	stb	r7,35(r3)
  /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
  ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
    e1dc:	d1e00a03 	ldbu	r7,-32728(gp)
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
    e1e0:	1b0009c5 	stb	r12,39(r3)
   * 'sender IP address' MUST be sent using link-layer broadcast instead of
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
    e1e4:	1cc00745 	stb	r19,29(r3)
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
  /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
  ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
    e1e8:	19c00085 	stb	r7,2(r3)
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
    e1ec:	1bc00905 	stb	r15,36(r3)
    e1f0:	1b800945 	stb	r14,37(r3)
    e1f4:	1b400985 	stb	r13,38(r3)
  /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
  ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
    e1f8:	114000c3 	ldbu	r5,3(r2)
    e1fc:	11000103 	ldbu	r4,4(r2)
    e200:	1a000105 	stb	r8,4(r3)
    e204:	10800143 	ldbu	r2,5(r2)
    e208:	19400145 	stb	r5,5(r3)
    e20c:	19000185 	stb	r4,6(r3)
    e210:	188001c5 	stb	r2,7(r3)
#endif /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
    e214:	31000003 	ldbu	r4,0(r6)
    e218:	19c00204 	addi	r7,r3,8
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
    e21c:	82400104 	addi	r9,r16,4
#if LWIP_AUTOIP
  ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
#endif /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
    e220:	39000005 	stb	r4,0(r7)
    e224:	81000a03 	ldbu	r4,40(r16)
  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
    e228:	1a000784 	addi	r8,r3,30
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
    e22c:	18800a04 	addi	r2,r3,40
#if LWIP_AUTOIP
  ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
#endif /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
    e230:	19000245 	stb	r4,9(r3)
    e234:	81400a43 	ldbu	r5,41(r16)
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
  hdr->proto = PP_HTONS(ETHTYPE_IP);
    e238:	01c00204 	movi	r7,8
  hdr->hwlen = ETHARP_HWADDR_LEN;
  hdr->protolen = sizeof(ip_addr_t);

  ethhdr->type = PP_HTONS(ETHTYPE_ARP);
  /* send ARP query */
  result = netif->linkoutput(netif, p);
    e23c:	8009883a 	mov	r4,r16
#if LWIP_AUTOIP
  ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
#endif /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
    e240:	19400285 	stb	r5,10(r3)
    e244:	83000a83 	ldbu	r12,42(r16)
  hdr->hwlen = ETHARP_HWADDR_LEN;
  hdr->protolen = sizeof(ip_addr_t);

  ethhdr->type = PP_HTONS(ETHTYPE_ARP);
  /* send ARP query */
  result = netif->linkoutput(netif, p);
    e248:	880b883a 	mov	r5,r17
#if LWIP_AUTOIP
  ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
#endif /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
    e24c:	1b0002c5 	stb	r12,11(r3)
    e250:	83000ac3 	ldbu	r12,43(r16)
    e254:	1b000305 	stb	r12,12(r3)
    e258:	81800b03 	ldbu	r6,44(r16)
    e25c:	19800345 	stb	r6,13(r3)
  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
    e260:	49800003 	ldbu	r6,0(r9)
    e264:	41800005 	stb	r6,0(r8)
    e268:	81800143 	ldbu	r6,5(r16)
    e26c:	198007c5 	stb	r6,31(r3)
    e270:	81800183 	ldbu	r6,6(r16)
    e274:	19800805 	stb	r6,32(r3)
    e278:	818001c3 	ldbu	r6,7(r16)
    e27c:	19800845 	stb	r6,33(r3)
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
    e280:	91800003 	ldbu	r6,0(r18)
    e284:	11800005 	stb	r6,0(r2)
    e288:	91800043 	ldbu	r6,1(r18)

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
  hdr->proto = PP_HTONS(ETHTYPE_IP);
  /* set hwlen and protolen */
  hdr->hwlen = ETHARP_HWADDR_LEN;
  hdr->protolen = sizeof(ip_addr_t);
    e28c:	00800104 	movi	r2,4
#endif /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
    e290:	19800a45 	stb	r6,41(r3)
    e294:	91800083 	ldbu	r6,2(r18)
    e298:	19800a85 	stb	r6,42(r3)
    e29c:	918000c3 	ldbu	r6,3(r18)

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
    e2a0:	1ac0040d 	sth	r11,16(r3)
  hdr->proto = PP_HTONS(ETHTYPE_IP);
    e2a4:	19c0048d 	sth	r7,18(r3)
#endif /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
    e2a8:	19800ac5 	stb	r6,43(r3)

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
  hdr->proto = PP_HTONS(ETHTYPE_IP);
  /* set hwlen and protolen */
  hdr->hwlen = ETHARP_HWADDR_LEN;
    e2ac:	1a800505 	stb	r10,20(r3)
  hdr->protolen = sizeof(ip_addr_t);
    e2b0:	18800545 	stb	r2,21(r3)

  ethhdr->type = PP_HTONS(ETHTYPE_ARP);
  /* send ARP query */
  result = netif->linkoutput(netif, p);
    e2b4:	80800617 	ldw	r2,24(r16)
  hdr->proto = PP_HTONS(ETHTYPE_IP);
  /* set hwlen and protolen */
  hdr->hwlen = ETHARP_HWADDR_LEN;
  hdr->protolen = sizeof(ip_addr_t);

  ethhdr->type = PP_HTONS(ETHTYPE_ARP);
    e2b8:	01818204 	movi	r6,1544
    e2bc:	1980038d 	sth	r6,14(r3)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
    e2c0:	103ee83a 	callr	r2
    e2c4:	1021883a 	mov	r16,r2
  ETHARP_STATS_INC(etharp.xmit);
    e2c8:	008001f4 	movhi	r2,7
    e2cc:	10944804 	addi	r2,r2,20768
    e2d0:	10c0060b 	ldhu	r3,24(r2)
  /* free ARP query packet */
  pbuf_free(p);
    e2d4:	8809883a 	mov	r4,r17
  hdr->protolen = sizeof(ip_addr_t);

  ethhdr->type = PP_HTONS(ETHTYPE_ARP);
  /* send ARP query */
  result = netif->linkoutput(netif, p);
  ETHARP_STATS_INC(etharp.xmit);
    e2d8:	18c00044 	addi	r3,r3,1
    e2dc:	10c0060d 	sth	r3,24(r2)
  /* free ARP query packet */
  pbuf_free(p);
    e2e0:	00067d80 	call	67d8 <pbuf_free>
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
    e2e4:	8005883a 	mov	r2,r16
    e2e8:	dfc00517 	ldw	ra,20(sp)
    e2ec:	dcc00417 	ldw	r19,16(sp)
    e2f0:	dc800317 	ldw	r18,12(sp)
    e2f4:	dc400217 	ldw	r17,8(sp)
    e2f8:	dc000117 	ldw	r16,4(sp)
    e2fc:	dec00604 	addi	sp,sp,24
    e300:	f800283a 	ret
  p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    e304:	008001f4 	movhi	r2,7
    e308:	10944804 	addi	r2,r2,20768
    e30c:	10c0090b 	ldhu	r3,36(r2)
    return ERR_MEM;
    e310:	043fffc4 	movi	r16,-1
  p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    e314:	18c00044 	addi	r3,r3,1
    e318:	10c0090d 	sth	r3,36(r2)
    e31c:	003ff106 	br	e2e4 <etharp_request+0x244>

0000e320 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, ip_addr_t *ipaddr, struct pbuf *q)
{
    e320:	defff804 	addi	sp,sp,-32
    e324:	dcc00315 	stw	r19,12(sp)
    e328:	2027883a 	mov	r19,r4
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
    e32c:	29000017 	ldw	r4,0(r5)
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, ip_addr_t *ipaddr, struct pbuf *q)
{
    e330:	dc800215 	stw	r18,8(sp)
    e334:	2825883a 	mov	r18,r5
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
    e338:	980b883a 	mov	r5,r19
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, ip_addr_t *ipaddr, struct pbuf *q)
{
    e33c:	dc400115 	stw	r17,4(sp)
    e340:	dfc00715 	stw	ra,28(sp)
    e344:	dd800615 	stw	r22,24(sp)
    e348:	dd400515 	stw	r21,20(sp)
    e34c:	dd000415 	stw	r20,16(sp)
    e350:	dc000015 	stw	r16,0(sp)
    e354:	3023883a 	mov	r17,r6
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
    e358:	00049440 	call	4944 <ip4_addr_isbroadcast>
    e35c:	10803fcc 	andi	r2,r2,255
    e360:	1000511e 	bne	r2,zero,e4a8 <etharp_query+0x188>
      ip_addr_ismulticast(ipaddr) ||
    e364:	90800017 	ldw	r2,0(r18)
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
    e368:	00c03804 	movi	r3,224
      ip_addr_ismulticast(ipaddr) ||
    e36c:	11003c0c 	andi	r4,r2,240
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
    e370:	20c04d26 	beq	r4,r3,e4a8 <etharp_query+0x188>
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
    e374:	10004c26 	beq	r2,zero,e4a8 <etharp_query+0x188>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  }

  /* find entry in ARP cache, ask to create entry if queueing packet */
  i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);
    e378:	05800044 	movi	r22,1
    e37c:	9009883a 	mov	r4,r18
    e380:	b00b883a 	mov	r5,r22
    e384:	000d9c00 	call	d9c0 <etharp_find_entry>
    e388:	1021883a 	mov	r16,r2

  /* could not find or create entry? */
  if (i < 0) {
    e38c:	85403fcc 	andi	r21,r16,255
    e390:	ad40201c 	xori	r21,r21,128
    e394:	ad7fe004 	addi	r21,r21,-128
    e398:	a8003016 	blt	r21,zero,e45c <etharp_query+0x13c>
    }
    return (err_t)i;
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
    e39c:	ad400524 	muli	r21,r21,20
    e3a0:	05000134 	movhi	r20,4
    e3a4:	a527c404 	addi	r20,r20,-24816
    e3a8:	a547883a 	add	r3,r20,r21
    e3ac:	18800483 	ldbu	r2,18(r3)
    e3b0:	18c00404 	addi	r3,r3,16
    e3b4:	1000161e 	bne	r2,zero,e410 <etharp_query+0xf0>
    arp_table[i].state = ETHARP_STATE_PENDING;
    e3b8:	1d800085 	stb	r22,2(r3)
   (arp_table[i].state >= ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
    e3bc:	9809883a 	mov	r4,r19
    e3c0:	900b883a 	mov	r5,r18
    e3c4:	000e0a00 	call	e0a0 <etharp_request>
      /* ARP request couldn't be sent */
      /* We don't re-send arp request in etharp_tmr, but we still queue packets,
         since this failure could be temporary, and the next packet calling
         etharp_query again could lead to sending the queued packets. */
    }
    if (q == NULL) {
    e3c8:	88000526 	beq	r17,zero,e3e0 <etharp_query+0xc0>
  }

  /* packet given? */
  LWIP_ASSERT("q != NULL", q != NULL);
  /* stable entry? */
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
    e3cc:	a547883a 	add	r3,r20,r21
    e3d0:	18c00483 	ldbu	r3,18(r3)
    e3d4:	01000044 	movi	r4,1
    e3d8:	20c01036 	bltu	r4,r3,e41c <etharp_query+0xfc>
    /* we have a valid IP->Ethernet address mapping */
    ETHARP_SET_HINT(netif, i);
    /* send the packet */
    result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  /* pending entry? (either just created or already pending */
  } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
    e3dc:	19003426 	beq	r3,r4,e4b0 <etharp_query+0x190>
   (arp_table[i].state >= ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
    e3e0:	1021883a 	mov	r16,r2
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
      result = ERR_MEM;
    }
  }
  return result;
}
    e3e4:	8005883a 	mov	r2,r16
    e3e8:	dfc00717 	ldw	ra,28(sp)
    e3ec:	dd800617 	ldw	r22,24(sp)
    e3f0:	dd400517 	ldw	r21,20(sp)
    e3f4:	dd000417 	ldw	r20,16(sp)
    e3f8:	dcc00317 	ldw	r19,12(sp)
    e3fc:	dc800217 	ldw	r18,8(sp)
    e400:	dc400117 	ldw	r17,4(sp)
    e404:	dc000017 	ldw	r16,0(sp)
    e408:	dec00804 	addi	sp,sp,32
    e40c:	f800283a 	ret
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state >= ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    e410:	15bfea26 	beq	r2,r22,e3bc <etharp_query+0x9c>
    e414:	88001826 	beq	r17,zero,e478 <etharp_query+0x158>
  }

  /* packet given? */
  LWIP_ASSERT("q != NULL", q != NULL);
  /* stable entry? */
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
    e418:	b080392e 	bgeu	r22,r2,e500 <etharp_query+0x1e0>
    /* we have a valid IP->Ethernet address mapping */
    ETHARP_SET_HINT(netif, i);
    /* send the packet */
    result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
    e41c:	a9c00304 	addi	r7,r21,12
    e420:	9809883a 	mov	r4,r19
    e424:	880b883a 	mov	r5,r17
    e428:	998009c4 	addi	r6,r19,39
    e42c:	a1cf883a 	add	r7,r20,r7
  /* packet given? */
  LWIP_ASSERT("q != NULL", q != NULL);
  /* stable entry? */
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
    /* we have a valid IP->Ethernet address mapping */
    ETHARP_SET_HINT(netif, i);
    e430:	d428cb05 	stb	r16,-23764(gp)
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
      result = ERR_MEM;
    }
  }
  return result;
}
    e434:	dfc00717 	ldw	ra,28(sp)
    e438:	dd800617 	ldw	r22,24(sp)
    e43c:	dd400517 	ldw	r21,20(sp)
    e440:	dd000417 	ldw	r20,16(sp)
    e444:	dcc00317 	ldw	r19,12(sp)
    e448:	dc800217 	ldw	r18,8(sp)
    e44c:	dc400117 	ldw	r17,4(sp)
    e450:	dc000017 	ldw	r16,0(sp)
    e454:	dec00804 	addi	sp,sp,32
  /* stable entry? */
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
    /* we have a valid IP->Ethernet address mapping */
    ETHARP_SET_HINT(netif, i);
    /* send the packet */
    result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
    e458:	000dc541 	jmpi	dc54 <etharp_send_ip>
  i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);

  /* could not find or create entry? */
  if (i < 0) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
    if (q) {
    e45c:	883fe126 	beq	r17,zero,e3e4 <etharp_query+0xc4>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
      ETHARP_STATS_INC(etharp.memerr);
    e460:	008001f4 	movhi	r2,7
    e464:	10944804 	addi	r2,r2,20768
    e468:	10c0090b 	ldhu	r3,36(r2)
    e46c:	1d87883a 	add	r3,r3,r22
    e470:	10c0090d 	sth	r3,36(r2)
    e474:	003fdb06 	br	e3e4 <etharp_query+0xc4>
   (arp_table[i].state >= ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
    e478:	9809883a 	mov	r4,r19
    e47c:	900b883a 	mov	r5,r18
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
      result = ERR_MEM;
    }
  }
  return result;
}
    e480:	dfc00717 	ldw	ra,28(sp)
    e484:	dd800617 	ldw	r22,24(sp)
    e488:	dd400517 	ldw	r21,20(sp)
    e48c:	dd000417 	ldw	r20,16(sp)
    e490:	dcc00317 	ldw	r19,12(sp)
    e494:	dc800217 	ldw	r18,8(sp)
    e498:	dc400117 	ldw	r17,4(sp)
    e49c:	dc000017 	ldw	r16,0(sp)
    e4a0:	dec00804 	addi	sp,sp,32
   (arp_table[i].state >= ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
    e4a4:	000e0a01 	jmpi	e0a0 <etharp_request>
  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
    e4a8:	043ffc84 	movi	r16,-14
    e4ac:	003fcd06 	br	e3e4 <etharp_query+0xc4>
    /* we have a valid IP->Ethernet address mapping */
    ETHARP_SET_HINT(netif, i);
    /* send the packet */
    result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  /* pending entry? (either just created or already pending */
  } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
    e4b0:	8805883a 	mov	r2,r17
    e4b4:	00000406 	br	e4c8 <etharp_query+0x1a8>
     * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
     * PBUF_ROMs can be left as they are, since ROM must not get changed. */
    p = q;
    while (p) {
      LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
      if(p->type != PBUF_ROM) {
    e4b8:	11000303 	ldbu	r4,12(r2)
    e4bc:	20c0241e 	bne	r4,r3,e550 <etharp_query+0x230>
        copy_needed = 1;
        break;
      }
      p = p->next;
    e4c0:	10800017 	ldw	r2,0(r2)
    int copy_needed = 0;
    /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
     * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
     * PBUF_ROMs can be left as they are, since ROM must not get changed. */
    p = q;
    while (p) {
    e4c4:	10001026 	beq	r2,zero,e508 <etharp_query+0x1e8>
      LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
    e4c8:	1100028b 	ldhu	r4,10(r2)
    e4cc:	1140020b 	ldhu	r5,8(r2)
    e4d0:	217ff91e 	bne	r4,r5,e4b8 <etharp_query+0x198>
    e4d4:	11000017 	ldw	r4,0(r2)
    e4d8:	203ff726 	beq	r4,zero,e4b8 <etharp_query+0x198>
    e4dc:	010000b4 	movhi	r4,2
    e4e0:	210d4b04 	addi	r4,r4,13612
    e4e4:	014000b4 	movhi	r5,2
    e4e8:	2957b104 	addi	r5,r5,24260
    e4ec:	01810f84 	movi	r6,1086
    e4f0:	01c000b4 	movhi	r7,2
    e4f4:	39d76004 	addi	r7,r7,23936
    e4f8:	00104380 	call	10438 <printf>
    e4fc:	003fff06 	br	e4fc <etharp_query+0x1dc>
 */
err_t
etharp_query(struct netif *netif, ip_addr_t *ipaddr, struct pbuf *q)
{
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
    e500:	043fffc4 	movi	r16,-1
    e504:	003fb706 	br	e3e4 <etharp_query+0xc4>
        }
      }
    } else {
      /* referencing the old pbuf is enough */
      p = q;
      pbuf_ref(p);
    e508:	8809883a 	mov	r4,r17
    e50c:	0006df00 	call	6df0 <pbuf_ref>
    e510:	8821883a 	mov	r16,r17
    if (p != NULL) {
      /* queue packet ... */
#if ARP_QUEUEING
      struct etharp_q_entry *new_entry;
      /* allocate a new arp queue entry */
      new_entry = (struct etharp_q_entry *)memp_malloc(MEMP_ARP_QUEUE);
    e514:	01000184 	movi	r4,6
    e518:	00060a40 	call	60a4 <memp_malloc>
      if (new_entry != NULL) {
    e51c:	10002426 	beq	r2,zero,e5b0 <etharp_query+0x290>
        new_entry->next = 0;
        new_entry->p = p;
        if(arp_table[i].q != NULL) {
    e520:	a569883a 	add	r20,r20,r21
    e524:	a0c00017 	ldw	r3,0(r20)
#if ARP_QUEUEING
      struct etharp_q_entry *new_entry;
      /* allocate a new arp queue entry */
      new_entry = (struct etharp_q_entry *)memp_malloc(MEMP_ARP_QUEUE);
      if (new_entry != NULL) {
        new_entry->next = 0;
    e528:	10000015 	stw	zero,0(r2)
        new_entry->p = p;
    e52c:	14000115 	stw	r16,4(r2)
        if(arp_table[i].q != NULL) {
    e530:	1800021e 	bne	r3,zero,e53c <etharp_query+0x21c>
    e534:	00001b06 	br	e5a4 <etharp_query+0x284>
          /* queue was already existent, append the new entry to the end */
          struct etharp_q_entry *r;
          r = arp_table[i].q;
          while (r->next != NULL) {
            r = r->next;
    e538:	2007883a 	mov	r3,r4
        new_entry->p = p;
        if(arp_table[i].q != NULL) {
          /* queue was already existent, append the new entry to the end */
          struct etharp_q_entry *r;
          r = arp_table[i].q;
          while (r->next != NULL) {
    e53c:	19000017 	ldw	r4,0(r3)
    e540:	203ffd1e 	bne	r4,zero,e538 <etharp_query+0x218>
            r = r->next;
          }
          r->next = new_entry;
    e544:	18800015 	stw	r2,0(r3)
        } else {
          /* queue did not exist, first item in queue */
          arp_table[i].q = new_entry;
        }
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
        result = ERR_OK;
    e548:	0021883a 	mov	r16,zero
    e54c:	003fa506 	br	e3e4 <etharp_query+0xc4>
      }
      p = p->next;
    }
    if(copy_needed) {
      /* copy the whole packet into new pbufs */
      p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
    e550:	010000c4 	movi	r4,3
    e554:	000d883a 	mov	r6,zero
    e558:	0006a880 	call	6a88 <pbuf_alloc>
    e55c:	1021883a 	mov	r16,r2
      if(p != NULL) {
    e560:	10000926 	beq	r2,zero,e588 <etharp_query+0x268>
        if (pbuf_copy(p, q) != ERR_OK) {
    e564:	8009883a 	mov	r4,r16
    e568:	880b883a 	mov	r5,r17
    e56c:	0006fc00 	call	6fc0 <pbuf_copy>
    e570:	10803fcc 	andi	r2,r2,255
    e574:	1080201c 	xori	r2,r2,128
    e578:	10bfe004 	addi	r2,r2,-128
    e57c:	103fe526 	beq	r2,zero,e514 <etharp_query+0x1f4>
          pbuf_free(p);
    e580:	8009883a 	mov	r4,r16
    e584:	00067d80 	call	67d8 <pbuf_free>
      arp_table[i].q = p;
      result = ERR_OK;
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
#endif /* ARP_QUEUEING */
    } else {
      ETHARP_STATS_INC(etharp.memerr);
    e588:	008001f4 	movhi	r2,7
    e58c:	10944804 	addi	r2,r2,20768
    e590:	10c0090b 	ldhu	r3,36(r2)
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
      result = ERR_MEM;
    e594:	043fffc4 	movi	r16,-1
      arp_table[i].q = p;
      result = ERR_OK;
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
#endif /* ARP_QUEUEING */
    } else {
      ETHARP_STATS_INC(etharp.memerr);
    e598:	18c00044 	addi	r3,r3,1
    e59c:	10c0090d 	sth	r3,36(r2)
    e5a0:	003f9006 	br	e3e4 <etharp_query+0xc4>
            r = r->next;
          }
          r->next = new_entry;
        } else {
          /* queue did not exist, first item in queue */
          arp_table[i].q = new_entry;
    e5a4:	a0800015 	stw	r2,0(r20)
        }
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
        result = ERR_OK;
    e5a8:	0021883a 	mov	r16,zero
    e5ac:	003f8d06 	br	e3e4 <etharp_query+0xc4>
      } else {
        /* the pool MEMP_ARP_QUEUE is empty */
        pbuf_free(p);
    e5b0:	8009883a 	mov	r4,r16
    e5b4:	00067d80 	call	67d8 <pbuf_free>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
        result = ERR_MEM;
    e5b8:	043fffc4 	movi	r16,-1
    e5bc:	003f8906 	br	e3e4 <etharp_query+0xc4>

0000e5c0 <etharp_output_to_arp_index>:
/** Just a small helper function that sends a pbuf to an ethernet address
 * in the arp_table specified by the index 'arp_idx'.
 */
static err_t
etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
{
    e5c0:	defffa04 	addi	sp,sp,-24
    e5c4:	dd000415 	stw	r20,16(sp)
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
    e5c8:	35000524 	muli	r20,r6,20
/** Just a small helper function that sends a pbuf to an ethernet address
 * in the arp_table specified by the index 'arp_idx'.
 */
static err_t
etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
{
    e5cc:	dc000015 	stw	r16,0(sp)
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
    e5d0:	04000134 	movhi	r16,4
    e5d4:	8427c404 	addi	r16,r16,-24816
/** Just a small helper function that sends a pbuf to an ethernet address
 * in the arp_table specified by the index 'arp_idx'.
 */
static err_t
etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
{
    e5d8:	dc400115 	stw	r17,4(sp)
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
    e5dc:	8523883a 	add	r17,r16,r20
/** Just a small helper function that sends a pbuf to an ethernet address
 * in the arp_table specified by the index 'arp_idx'.
 */
static err_t
etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
{
    e5e0:	dcc00315 	stw	r19,12(sp)
    e5e4:	dc800215 	stw	r18,8(sp)
    e5e8:	dfc00515 	stw	ra,20(sp)
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
    e5ec:	8c400404 	addi	r17,r17,16
    e5f0:	88800083 	ldbu	r2,2(r17)
    e5f4:	00c00044 	movi	r3,1
/** Just a small helper function that sends a pbuf to an ethernet address
 * in the arp_table specified by the index 'arp_idx'.
 */
static err_t
etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
{
    e5f8:	2027883a 	mov	r19,r4
    e5fc:	2825883a 	mov	r18,r5
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
    e600:	18801c2e 	bgeu	r3,r2,e674 <etharp_output_to_arp_index+0xb4>
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
    e604:	00c00084 	movi	r3,2
    e608:	10c00d26 	beq	r2,r3,e640 <etharp_output_to_arp_index+0x80>
    if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
      arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
    }
  }
  
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
    e60c:	a1c00304 	addi	r7,r20,12
    e610:	9809883a 	mov	r4,r19
    e614:	900b883a 	mov	r5,r18
    e618:	998009c4 	addi	r6,r19,39
    e61c:	81cf883a 	add	r7,r16,r7
    &arp_table[arp_idx].ethaddr);
}
    e620:	dfc00517 	ldw	ra,20(sp)
    e624:	dd000417 	ldw	r20,16(sp)
    e628:	dcc00317 	ldw	r19,12(sp)
    e62c:	dc800217 	ldw	r18,8(sp)
    e630:	dc400117 	ldw	r17,4(sp)
    e634:	dc000017 	ldw	r16,0(sp)
    e638:	dec00604 	addi	sp,sp,24
    if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
      arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
    }
  }
  
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
    e63c:	000dc541 	jmpi	dc54 <etharp_send_ip>
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
    e640:	888000c3 	ldbu	r2,3(r17)
    e644:	00c038c4 	movi	r3,227
    e648:	18bff02e 	bgeu	r3,r2,e60c <etharp_output_to_arp_index+0x4c>
      (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
    if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
    e64c:	a1400104 	addi	r5,r20,4
    e650:	814b883a 	add	r5,r16,r5
    e654:	000e0a00 	call	e0a0 <etharp_request>
    e658:	10803fcc 	andi	r2,r2,255
    e65c:	1080201c 	xori	r2,r2,128
    e660:	10bfe004 	addi	r2,r2,-128
    e664:	103fe91e 	bne	r2,zero,e60c <etharp_output_to_arp_index+0x4c>
      arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
    e668:	008000c4 	movi	r2,3
    e66c:	88800085 	stb	r2,2(r17)
    e670:	003fe606 	br	e60c <etharp_output_to_arp_index+0x4c>
 * in the arp_table specified by the index 'arp_idx'.
 */
static err_t
etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
{
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
    e674:	010000b4 	movhi	r4,2
    e678:	210d4b04 	addi	r4,r4,13612
    e67c:	014000b4 	movhi	r5,2
    e680:	2957b804 	addi	r5,r5,24288
    e684:	0180d344 	movi	r6,845
    e688:	01c000b4 	movhi	r7,2
    e68c:	39d76004 	addi	r7,r7,23936
    e690:	00104380 	call	10438 <printf>
    e694:	003fff06 	br	e694 <etharp_output_to_arp_index+0xd4>

0000e698 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, ip_addr_t *ipaddr)
{
    e698:	defffa04 	addi	sp,sp,-24
    e69c:	dc800415 	stw	r18,16(sp)
    e6a0:	dc400315 	stw	r17,12(sp)
    e6a4:	dc000215 	stw	r16,8(sp)
    e6a8:	dfc00515 	stw	ra,20(sp)
    e6ac:	2021883a 	mov	r16,r4
    e6b0:	2825883a 	mov	r18,r5
    e6b4:	3023883a 	mov	r17,r6
  struct eth_addr *dest;
  struct eth_addr mcastaddr;
  ip_addr_t *dst_addr = ipaddr;

  LWIP_ASSERT("netif != NULL", netif != NULL);
    e6b8:	20007926 	beq	r4,zero,e8a0 <etharp_output+0x208>
  LWIP_ASSERT("q != NULL", q != NULL);
    e6bc:	28008826 	beq	r5,zero,e8e0 <etharp_output+0x248>
  LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
    e6c0:	30006e26 	beq	r6,zero,e87c <etharp_output+0x1e4>

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
    e6c4:	2809883a 	mov	r4,r5
    e6c8:	01400404 	movi	r5,16
    e6cc:	00066980 	call	6698 <pbuf_header>
    e6d0:	10803fcc 	andi	r2,r2,255
    e6d4:	10005d1e 	bne	r2,zero,e84c <etharp_output+0x1b4>

  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
    e6d8:	89000017 	ldw	r4,0(r17)
    e6dc:	800b883a 	mov	r5,r16
    e6e0:	00049440 	call	4944 <ip4_addr_isbroadcast>
    e6e4:	10803fcc 	andi	r2,r2,255
    e6e8:	10004b1e 	bne	r2,zero,e818 <etharp_output+0x180>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
    e6ec:	88800017 	ldw	r2,0(r17)
    e6f0:	00c03804 	movi	r3,224
    e6f4:	11003c0c 	andi	r4,r2,240
    e6f8:	20c02e26 	beq	r4,r3,e7b4 <etharp_output+0x11c>
  /* unicast destination IP address? */
  } else {
    s8_t i;
    /* outside local network? if so, this can neither be a global broadcast nor
       a subnet broadcast. */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
    e6fc:	81000117 	ldw	r4,4(r16)
    e700:	80c00217 	ldw	r3,8(r16)
    e704:	1108f03a 	xor	r4,r2,r4
    e708:	20c6703a 	and	r3,r4,r3
    e70c:	18004026 	beq	r3,zero,e810 <etharp_output+0x178>
        !ip_addr_islinklocal(ipaddr)) {
    e710:	10bfffcc 	andi	r2,r2,65535
  /* unicast destination IP address? */
  } else {
    s8_t i;
    /* outside local network? if so, this can neither be a global broadcast nor
       a subnet broadcast. */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
    e714:	00ffaa54 	movui	r3,65193
    e718:	10c03d26 	beq	r2,r3,e810 <etharp_output+0x178>
         router for forwarding". */
      if (!ip_addr_islinklocal(&iphdr->src))
#endif /* LWIP_AUTOIP */
      {
        /* interface has default gateway? */
        if (!ip_addr_isany(&netif->gw)) {
    e71c:	80800317 	ldw	r2,12(r16)
    e720:	81400304 	addi	r5,r16,12
    e724:	10006726 	beq	r2,zero,e8c4 <etharp_output+0x22c>
    if (netif->addr_hint != NULL) {
      /* per-pcb cached entry was given */
      u8_t etharp_cached_entry = *(netif->addr_hint);
      if (etharp_cached_entry < ARP_TABLE_SIZE) {
#endif /* LWIP_NETIF_HWADDRHINT */
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
    e728:	d1a8cb03 	ldbu	r6,-23764(gp)
    e72c:	00c00134 	movhi	r3,4
    e730:	18e7c404 	addi	r3,r3,-24816
    e734:	01000044 	movi	r4,1
    e738:	30800524 	muli	r2,r6,20
    e73c:	1885883a 	add	r2,r3,r2
    e740:	10c00483 	ldbu	r3,18(r2)
    e744:	20c0032e 	bgeu	r4,r3,e754 <etharp_output+0xbc>
    e748:	28c00017 	ldw	r3,0(r5)
    e74c:	10800117 	ldw	r2,4(r2)
    e750:	18806c26 	beq	r3,r2,e904 <etharp_output+0x26c>
    e754:	00c00134 	movhi	r3,4
    e758:	18e7c884 	addi	r3,r3,-24798
    e75c:	193ffc84 	addi	r4,r3,-14
  /* unicast destination IP address? */
  } else {
    s8_t i;
    /* outside local network? if so, this can neither be a global broadcast nor
       a subnet broadcast. */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
    e760:	0005883a 	mov	r2,zero
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
    e764:	01c00044 	movi	r7,1
    }
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
    e768:	01800284 	movi	r6,10
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
    e76c:	1a000003 	ldbu	r8,0(r3)
    e770:	18c00504 	addi	r3,r3,20
    e774:	3a00032e 	bgeu	r7,r8,e784 <etharp_output+0xec>
    e778:	22000017 	ldw	r8,0(r4)
    e77c:	2a400017 	ldw	r9,0(r5)
    e780:	4a002726 	beq	r9,r8,e820 <etharp_output+0x188>
    e784:	10800044 	addi	r2,r2,1
    e788:	21000504 	addi	r4,r4,20
    }
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
    e78c:	11bff71e 	bne	r2,r6,e76c <etharp_output+0xd4>
        return etharp_output_to_arp_index(netif, q, i);
      }
    }
    /* no stable entry found, use the (slower) query function:
       queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, dst_addr, q);
    e790:	8009883a 	mov	r4,r16
    e794:	900d883a 	mov	r6,r18
    e798:	000e3200 	call	e320 <etharp_query>

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
}
    e79c:	dfc00517 	ldw	ra,20(sp)
    e7a0:	dc800417 	ldw	r18,16(sp)
    e7a4:	dc400317 	ldw	r17,12(sp)
    e7a8:	dc000217 	ldw	r16,8(sp)
    e7ac:	dec00604 	addi	sp,sp,24
    e7b0:	f800283a 	ret
  } else if (ip_addr_ismulticast(ipaddr)) {
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
    mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
    mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
    e7b4:	89000043 	ldbu	r4,1(r17)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
    e7b8:	88c00083 	ldbu	r3,2(r17)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
    e7bc:	888000c3 	ldbu	r2,3(r17)
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
    e7c0:	01400044 	movi	r5,1
    mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
    mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
    e7c4:	21001fcc 	andi	r4,r4,127
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
    e7c8:	d9400005 	stb	r5,0(sp)
    mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
    mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
    e7cc:	01401784 	movi	r5,94
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
    mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
    e7d0:	d8000045 	stb	zero,1(sp)
    mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
    e7d4:	d9400085 	stb	r5,2(sp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
    e7d8:	d90000c5 	stb	r4,3(sp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
    e7dc:	d8c00105 	stb	r3,4(sp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
    e7e0:	d8800145 	stb	r2,5(sp)
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
    e7e4:	d80f883a 	mov	r7,sp
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
    e7e8:	8009883a 	mov	r4,r16
    e7ec:	900b883a 	mov	r5,r18
    e7f0:	818009c4 	addi	r6,r16,39
    e7f4:	000dc540 	call	dc54 <etharp_send_ip>
}
    e7f8:	dfc00517 	ldw	ra,20(sp)
    e7fc:	dc800417 	ldw	r18,16(sp)
    e800:	dc400317 	ldw	r17,12(sp)
    e804:	dc000217 	ldw	r16,8(sp)
    e808:	dec00604 	addi	sp,sp,24
    e80c:	f800283a 	ret
  /* unicast destination IP address? */
  } else {
    s8_t i;
    /* outside local network? if so, this can neither be a global broadcast nor
       a subnet broadcast. */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
    e810:	880b883a 	mov	r5,r17
    e814:	003fc406 	br	e728 <etharp_output+0x90>
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
    e818:	d1e00a04 	addi	r7,gp,-32728
    e81c:	003ff206 	br	e7e8 <etharp_output+0x150>
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
          (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
        /* found an existing, stable entry */
        ETHARP_SET_HINT(netif, i);
        return etharp_output_to_arp_index(netif, q, i);
    e820:	8009883a 	mov	r4,r16
    e824:	900b883a 	mov	r5,r18
    e828:	100d883a 	mov	r6,r2
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
          (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
        /* found an existing, stable entry */
        ETHARP_SET_HINT(netif, i);
    e82c:	d0a8cb05 	stb	r2,-23764(gp)
        return etharp_output_to_arp_index(netif, q, i);
    e830:	000e5c00 	call	e5c0 <etharp_output_to_arp_index>

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
}
    e834:	dfc00517 	ldw	ra,20(sp)
    e838:	dc800417 	ldw	r18,16(sp)
    e83c:	dc400317 	ldw	r17,12(sp)
    e840:	dc000217 	ldw	r16,8(sp)
    e844:	dec00604 	addi	sp,sp,24
    e848:	f800283a 	ret
  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
    e84c:	00c001f4 	movhi	r3,7
    e850:	18d44804 	addi	r3,r3,20768
    e854:	1900028b 	ldhu	r4,10(r3)
    return ERR_BUF;
    e858:	00bfff84 	movi	r2,-2
  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
    e85c:	21000044 	addi	r4,r4,1
    e860:	1900028d 	sth	r4,10(r3)

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
}
    e864:	dfc00517 	ldw	ra,20(sp)
    e868:	dc800417 	ldw	r18,16(sp)
    e86c:	dc400317 	ldw	r17,12(sp)
    e870:	dc000217 	ldw	r16,8(sp)
    e874:	dec00604 	addi	sp,sp,24
    e878:	f800283a 	ret
  struct eth_addr mcastaddr;
  ip_addr_t *dst_addr = ipaddr;

  LWIP_ASSERT("netif != NULL", netif != NULL);
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
    e87c:	010000b4 	movhi	r4,2
    e880:	210d4b04 	addi	r4,r4,13612
    e884:	014000b4 	movhi	r5,2
    e888:	2957c704 	addi	r5,r5,24348
    e88c:	0180ddc4 	movi	r6,887
    e890:	01c000b4 	movhi	r7,2
    e894:	39d76004 	addi	r7,r7,23936
    e898:	00104380 	call	10438 <printf>
    e89c:	003fff06 	br	e89c <etharp_output+0x204>
{
  struct eth_addr *dest;
  struct eth_addr mcastaddr;
  ip_addr_t *dst_addr = ipaddr;

  LWIP_ASSERT("netif != NULL", netif != NULL);
    e8a0:	010000b4 	movhi	r4,2
    e8a4:	210d4b04 	addi	r4,r4,13612
    e8a8:	014000b4 	movhi	r5,2
    e8ac:	294d7404 	addi	r5,r5,13776
    e8b0:	0180dd44 	movi	r6,885
    e8b4:	01c000b4 	movhi	r7,2
    e8b8:	39d76004 	addi	r7,r7,23936
    e8bc:	00104380 	call	10438 <printf>
    e8c0:	003fff06 	br	e8c0 <etharp_output+0x228>
          /* send to hardware address of default gateway IP address */
          dst_addr = &(netif->gw);
        /* no default gateway available */
        } else {
          /* no route to destination error (default gateway missing) */
          return ERR_RTE;
    e8c4:	00bfff04 	movi	r2,-4

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
}
    e8c8:	dfc00517 	ldw	ra,20(sp)
    e8cc:	dc800417 	ldw	r18,16(sp)
    e8d0:	dc400317 	ldw	r17,12(sp)
    e8d4:	dc000217 	ldw	r16,8(sp)
    e8d8:	dec00604 	addi	sp,sp,24
    e8dc:	f800283a 	ret
  struct eth_addr *dest;
  struct eth_addr mcastaddr;
  ip_addr_t *dst_addr = ipaddr;

  LWIP_ASSERT("netif != NULL", netif != NULL);
  LWIP_ASSERT("q != NULL", q != NULL);
    e8e0:	010000b4 	movhi	r4,2
    e8e4:	210d4b04 	addi	r4,r4,13612
    e8e8:	014000b4 	movhi	r5,2
    e8ec:	2957c404 	addi	r5,r5,24336
    e8f0:	0180dd84 	movi	r6,886
    e8f4:	01c000b4 	movhi	r7,2
    e8f8:	39d76004 	addi	r7,r7,23936
    e8fc:	00104380 	call	10438 <printf>
    e900:	003fff06 	br	e900 <etharp_output+0x268>
      if (etharp_cached_entry < ARP_TABLE_SIZE) {
#endif /* LWIP_NETIF_HWADDRHINT */
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
            (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
          /* the per-pcb-cached entry is stable and the right one! */
          ETHARP_STATS_INC(etharp.cachehit);
    e904:	008001f4 	movhi	r2,7
    e908:	10944804 	addi	r2,r2,20768
    e90c:	10c00b8b 	ldhu	r3,46(r2)
          return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
    e910:	8009883a 	mov	r4,r16
    e914:	900b883a 	mov	r5,r18
      if (etharp_cached_entry < ARP_TABLE_SIZE) {
#endif /* LWIP_NETIF_HWADDRHINT */
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
            (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
          /* the per-pcb-cached entry is stable and the right one! */
          ETHARP_STATS_INC(etharp.cachehit);
    e918:	18c00044 	addi	r3,r3,1
    e91c:	10c00b8d 	sth	r3,46(r2)
          return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
    e920:	000e5c00 	call	e5c0 <etharp_output_to_arp_index>

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
}
    e924:	dfc00517 	ldw	ra,20(sp)
    e928:	dc800417 	ldw	r18,16(sp)
    e92c:	dc400317 	ldw	r17,12(sp)
    e930:	dc000217 	ldw	r16,8(sp)
    e934:	dec00604 	addi	sp,sp,24
    e938:	f800283a 	ret

0000e93c <ethernet_input>:
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
#if TEST_HISTOGRAM
//#if 0
  if (histid <= TNUM_HIST && measuring_flg == FALSE) {
    e93c:	008000f4 	movhi	r2,3
    e940:	10a5fd04 	addi	r2,r2,-26636
    e944:	10800017 	ldw	r2,0(r2)
 */
#include "../../../histogram.h"
#include "../../../echo.h"
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
    e948:	defff404 	addi	sp,sp,-48
    e94c:	dcc00515 	stw	r19,20(sp)
    e950:	dc800415 	stw	r18,16(sp)
    e954:	dfc00b15 	stw	ra,44(sp)
    e958:	df000a15 	stw	fp,40(sp)
    e95c:	ddc00915 	stw	r23,36(sp)
    e960:	dd800815 	stw	r22,32(sp)
    e964:	dd400715 	stw	r21,28(sp)
    e968:	dd000615 	stw	r20,24(sp)
    e96c:	dc400315 	stw	r17,12(sp)
    e970:	dc000215 	stw	r16,8(sp)
#if TEST_HISTOGRAM
//#if 0
  if (histid <= TNUM_HIST && measuring_flg == FALSE) {
    e974:	00c9c404 	movi	r3,10000
 */
#include "../../../histogram.h"
#include "../../../echo.h"
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
    e978:	2025883a 	mov	r18,r4
    e97c:	2827883a 	mov	r19,r5
#if TEST_HISTOGRAM
//#if 0
  if (histid <= TNUM_HIST && measuring_flg == FALSE) {
    e980:	18800436 	bltu	r3,r2,e994 <ethernet_input+0x58>
    e984:	040000f4 	movhi	r16,3
    e988:	842ea704 	addi	r16,r16,-17764
    e98c:	80c00017 	ldw	r3,0(r16)
    e990:	18004b26 	beq	r3,zero,eac0 <ethernet_input+0x184>
  u16_t type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN
  s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

  if (p->len <= SIZEOF_ETH_HDR) {
    e994:	9400028b 	ldhu	r16,10(r18)
    e998:	00800404 	movi	r2,16
    e99c:	1400152e 	bgeu	r2,r16,e9f4 <ethernet_input+0xb8>
    ETHARP_STATS_INC(etharp.drop);
    goto free_and_return;
  }

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = (struct eth_hdr *)p->payload;
    e9a0:	94400117 	ldw	r17,4(r18)

#if LWIP_ARP_FILTER_NETIF
  netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
    e9a4:	88800083 	ldbu	r2,2(r17)
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  type = ethhdr->type;
    e9a8:	8d00038b 	ldhu	r20,14(r17)

#if LWIP_ARP_FILTER_NETIF
  netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
    e9ac:	10c0004c 	andi	r3,r2,1
    e9b0:	18000b26 	beq	r3,zero,e9e0 <ethernet_input+0xa4>
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
    e9b4:	10803fcc 	andi	r2,r2,255
    e9b8:	00c00044 	movi	r3,1
    e9bc:	10c05926 	beq	r2,r3,eb24 <ethernet_input+0x1e8>
      if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
          (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
        /* mark the pbuf as link-layer multicast */
        p->flags |= PBUF_FLAG_LLMCAST;
      }
    } else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
    e9c0:	89000084 	addi	r4,r17,2
    e9c4:	d1600a04 	addi	r5,gp,-32728
    e9c8:	01800184 	movi	r6,6
    e9cc:	00101bc0 	call	101bc <memcmp>
    e9d0:	1000031e 	bne	r2,zero,e9e0 <ethernet_input+0xa4>
      /* mark the pbuf as link-layer broadcast */
      p->flags |= PBUF_FLAG_LLBCAST;
    e9d4:	90800343 	ldbu	r2,13(r18)
    e9d8:	10800214 	ori	r2,r2,8
    e9dc:	90800345 	stb	r2,13(r18)
    }
  }

  switch (type) {
    e9e0:	a0ffffcc 	andi	r3,r20,65535
    e9e4:	00800204 	movi	r2,8
    e9e8:	18801926 	beq	r3,r2,ea50 <ethernet_input+0x114>
    e9ec:	01018204 	movi	r4,1544
    e9f0:	19003826 	beq	r3,r4,ead4 <ethernet_input+0x198>
      pppoe_data_input(netif, p);
      break;
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
    e9f4:	008001f4 	movhi	r2,7
    e9f8:	10944804 	addi	r2,r2,20768
    e9fc:	11000a0b 	ldhu	r4,40(r2)
      ETHARP_STATS_INC(etharp.drop);
    ea00:	10c0078b 	ldhu	r3,30(r2)
      pppoe_data_input(netif, p);
      break;
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
    ea04:	21000044 	addi	r4,r4,1
      ETHARP_STATS_INC(etharp.drop);
    ea08:	18c00044 	addi	r3,r3,1
      pppoe_data_input(netif, p);
      break;
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
    ea0c:	11000a0d 	sth	r4,40(r2)
      ETHARP_STATS_INC(etharp.drop);
    ea10:	10c0078d 	sth	r3,30(r2)
  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;

free_and_return:
  pbuf_free(p);
    ea14:	9009883a 	mov	r4,r18
    ea18:	00067d80 	call	67d8 <pbuf_free>
  return ERR_OK;
}
    ea1c:	0005883a 	mov	r2,zero
    ea20:	dfc00b17 	ldw	ra,44(sp)
    ea24:	df000a17 	ldw	fp,40(sp)
    ea28:	ddc00917 	ldw	r23,36(sp)
    ea2c:	dd800817 	ldw	r22,32(sp)
    ea30:	dd400717 	ldw	r21,28(sp)
    ea34:	dd000617 	ldw	r20,24(sp)
    ea38:	dcc00517 	ldw	r19,20(sp)
    ea3c:	dc800417 	ldw	r18,16(sp)
    ea40:	dc400317 	ldw	r17,12(sp)
    ea44:	dc000217 	ldw	r16,8(sp)
    ea48:	dec00c04 	addi	sp,sp,48
    ea4c:	f800283a 	ret

  switch (type) {
#if LWIP_ARP
    /* IP packet? */
    case PP_HTONS(ETHTYPE_IP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
    ea50:	98800b43 	ldbu	r2,45(r19)
    ea54:	1080080c 	andi	r2,r2,32
    ea58:	10803fcc 	andi	r2,r2,255
    ea5c:	103fed26 	beq	r2,zero,ea14 <ethernet_input+0xd8>
  if (ethhdr->type == PP_HTONS(ETHTYPE_VLAN)) {
    iphdr = (struct ip_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  ip_addr_copy(iphdr_src, iphdr->src);
    ea60:	8940078b 	ldhu	r5,30(r17)
    ea64:	8880070b 	ldhu	r2,28(r17)

  /* source is not on the local network? */
  if (!ip_addr_netcmp(&iphdr_src, &(netif->ip_addr), &(netif->netmask))) {
    ea68:	99000117 	ldw	r4,4(r19)
  if (ethhdr->type == PP_HTONS(ETHTYPE_VLAN)) {
    iphdr = (struct ip_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  ip_addr_copy(iphdr_src, iphdr->src);
    ea6c:	280a943a 	slli	r5,r5,16

  /* source is not on the local network? */
  if (!ip_addr_netcmp(&iphdr_src, &(netif->ip_addr), &(netif->netmask))) {
    ea70:	98c00217 	ldw	r3,8(r19)
  if (ethhdr->type == PP_HTONS(ETHTYPE_VLAN)) {
    iphdr = (struct ip_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  ip_addr_copy(iphdr_src, iphdr->src);
    ea74:	2884b03a 	or	r2,r5,r2

  /* source is not on the local network? */
  if (!ip_addr_netcmp(&iphdr_src, &(netif->ip_addr), &(netif->netmask))) {
    ea78:	1108f03a 	xor	r4,r2,r4
  if (ethhdr->type == PP_HTONS(ETHTYPE_VLAN)) {
    iphdr = (struct ip_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  ip_addr_copy(iphdr_src, iphdr->src);
    ea7c:	d8800015 	stw	r2,0(sp)

  /* source is not on the local network? */
  if (!ip_addr_netcmp(&iphdr_src, &(netif->ip_addr), &(netif->netmask))) {
    ea80:	20c4703a 	and	r2,r4,r3
    ea84:	10003426 	beq	r2,zero,eb58 <ethernet_input+0x21c>
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -ip_hdr_offset)) {
    ea88:	9009883a 	mov	r4,r18
    ea8c:	017ffc04 	movi	r5,-16
    ea90:	00066980 	call	6698 <pbuf_header>
    ea94:	10803fcc 	andi	r2,r2,255
    ea98:	10002b26 	beq	r2,zero,eb48 <ethernet_input+0x20c>
        LWIP_ASSERT("Can't move over header in packet", 0);
    ea9c:	010000b4 	movhi	r4,2
    eaa0:	210d4b04 	addi	r4,r4,13612
    eaa4:	014000b4 	movhi	r5,2
    eaa8:	2952a204 	addi	r5,r5,19080
    eaac:	01815644 	movi	r6,1369
    eab0:	01c000b4 	movhi	r7,2
    eab4:	39d76004 	addi	r7,r7,23936
    eab8:	00104380 	call	10438 <printf>
    eabc:	003fff06 	br	eabc <ethernet_input+0x180>
{
#if TEST_HISTOGRAM
//#if 0
  if (histid <= TNUM_HIST && measuring_flg == FALSE) {
      //printf("[histid: %d] Histogram measuring starting...\n", histid);
      begin_measure(histid);
    eac0:	1009883a 	mov	r4,r2
    eac4:	00011800 	call	1180 <begin_measure>
      measuring_flg = TRUE;
    eac8:	00800044 	movi	r2,1
    eacc:	80800015 	stw	r2,0(r16)
    ead0:	003fb006 	br	e994 <ethernet_input+0x58>
        ip_input(p, netif);
      }
      break;
      
    case PP_HTONS(ETHTYPE_ARP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
    ead4:	98c00b43 	ldbu	r3,45(r19)
    ead8:	18c0080c 	andi	r3,r3,32
    eadc:	18c03fcc 	andi	r3,r3,255
    eae0:	183fcc26 	beq	r3,zero,ea14 <ethernet_input+0xd8>

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);

  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < SIZEOF_ETHARP_PACKET) {
    eae4:	00c00ac4 	movi	r3,43
    eae8:	1c00522e 	bgeu	r3,r16,ec34 <ethernet_input+0x2f8>
    hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
    eaec:	8900040b 	ldhu	r4,16(r17)
    eaf0:	00c04004 	movi	r3,256
    eaf4:	20c01e26 	beq	r4,r3,eb70 <ethernet_input+0x234>
      (hdr->protolen != sizeof(ip_addr_t)) ||
      (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, hdr->hwlen, hdr->proto, hdr->protolen));
    ETHARP_STATS_INC(etharp.proterr);
    eaf8:	008001f4 	movhi	r2,7
    eafc:	10944804 	addi	r2,r2,20768
    eb00:	11400a0b 	ldhu	r5,40(r2)
    ETHARP_STATS_INC(etharp.drop);
    eb04:	10c0078b 	ldhu	r3,30(r2)
    pbuf_free(p);
    eb08:	9009883a 	mov	r4,r18
      (hdr->protolen != sizeof(ip_addr_t)) ||
      (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, hdr->hwlen, hdr->proto, hdr->protolen));
    ETHARP_STATS_INC(etharp.proterr);
    eb0c:	29400044 	addi	r5,r5,1
    ETHARP_STATS_INC(etharp.drop);
    eb10:	18c00044 	addi	r3,r3,1
      (hdr->protolen != sizeof(ip_addr_t)) ||
      (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, hdr->hwlen, hdr->proto, hdr->protolen));
    ETHARP_STATS_INC(etharp.proterr);
    eb14:	11400a0d 	sth	r5,40(r2)
    ETHARP_STATS_INC(etharp.drop);
    eb18:	10c0078d 	sth	r3,30(r2)
    pbuf_free(p);
    eb1c:	00067d80 	call	67d8 <pbuf_free>
    eb20:	003fbe06 	br	ea1c <ethernet_input+0xe0>
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
      if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
    eb24:	888000c3 	ldbu	r2,3(r17)
    eb28:	103fad1e 	bne	r2,zero,e9e0 <ethernet_input+0xa4>
    eb2c:	88c00103 	ldbu	r3,4(r17)
    eb30:	00801784 	movi	r2,94
    eb34:	18bfaa1e 	bne	r3,r2,e9e0 <ethernet_input+0xa4>
          (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
        /* mark the pbuf as link-layer multicast */
        p->flags |= PBUF_FLAG_LLMCAST;
    eb38:	90800343 	ldbu	r2,13(r18)
    eb3c:	10800414 	ori	r2,r2,16
    eb40:	90800345 	stb	r2,13(r18)
    eb44:	003fa606 	br	e9e0 <ethernet_input+0xa4>
      if(pbuf_header(p, -ip_hdr_offset)) {
        LWIP_ASSERT("Can't move over header in packet", 0);
        goto free_and_return;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
    eb48:	9009883a 	mov	r4,r18
    eb4c:	980b883a 	mov	r5,r19
    eb50:	00042ec0 	call	42ec <ip_input>
      }
      break;
    eb54:	003fb106 	br	ea1c <ethernet_input+0xe0>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update the source IP address in the cache, if present */
  /* @todo We could use ETHARP_FLAG_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  etharp_update_arp_entry(netif, &iphdr_src, &(ethhdr->src), ETHARP_FLAG_FIND_ONLY);
    eb58:	9809883a 	mov	r4,r19
    eb5c:	d80b883a 	mov	r5,sp
    eb60:	89800204 	addi	r6,r17,8
    eb64:	01c00084 	movi	r7,2
    eb68:	000dd100 	call	dd10 <etharp_update_arp_entry>
    eb6c:	003fc606 	br	ea88 <ethernet_input+0x14c>
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
    eb70:	8900050b 	ldhu	r4,20(r17)
    eb74:	00c10184 	movi	r3,1030
    eb78:	20ffdf1e 	bne	r4,r3,eaf8 <ethernet_input+0x1bc>
      (hdr->protolen != sizeof(ip_addr_t)) ||
    eb7c:	88c0048b 	ldhu	r3,18(r17)
    eb80:	18bfdd1e 	bne	r3,r2,eaf8 <ethernet_input+0x1bc>
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
    return;
  }
  ETHARP_STATS_INC(etharp.recv);
    eb84:	05c001f4 	movhi	r23,7
    eb88:	bdd44804 	addi	r23,r23,20768
    eb8c:	b880068b 	ldhu	r2,26(r23)
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
    eb90:	8d000784 	addi	r20,r17,30
  IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
    eb94:	8d400a04 	addi	r21,r17,40
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
    return;
  }
  ETHARP_STATS_INC(etharp.recv);
    eb98:	10800044 	addi	r2,r2,1
    eb9c:	b880068d 	sth	r2,26(r23)
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
    eba0:	a0c00003 	ldbu	r3,0(r20)
  IPADDR2_COPY(&dipaddr, &hdr->dipaddr);

  /* this interface is not configured? */
  if (ip_addr_isany(&netif->ip_addr)) {
    eba4:	98800117 	ldw	r2,4(r19)
    eba8:	9d800104 	addi	r22,r19,4
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
    ebac:	d8c00105 	stb	r3,4(sp)
    ebb0:	a0c00043 	ldbu	r3,1(r20)
  /* ARP message directed to us?
      -> add IP address in ARP cache; assume requester wants to talk to us,
         can result in directly sending the queued packets for this host.
     ARP message not directed to us?
      ->  update the source IP address in the cache, if present */
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
    ebb4:	8c000604 	addi	r16,r17,24
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
    ebb8:	d8c00145 	stb	r3,5(sp)
    ebbc:	a0c00083 	ldbu	r3,2(r20)
    ebc0:	d8c00185 	stb	r3,6(sp)
    ebc4:	a0c000c3 	ldbu	r3,3(r20)
    ebc8:	d8c001c5 	stb	r3,7(sp)
  IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
    ebcc:	a8c00003 	ldbu	r3,0(r21)
    ebd0:	d8c00005 	stb	r3,0(sp)
    ebd4:	a8c00043 	ldbu	r3,1(r21)
    ebd8:	d8c00045 	stb	r3,1(sp)
    ebdc:	a8c00083 	ldbu	r3,2(r21)
    ebe0:	d8c00085 	stb	r3,2(sp)
    ebe4:	a8c000c3 	ldbu	r3,3(r21)
    ebe8:	d8c000c5 	stb	r3,3(sp)

  /* this interface is not configured? */
  if (ip_addr_isany(&netif->ip_addr)) {
    ebec:	10007926 	beq	r2,zero,edd4 <ethernet_input+0x498>
  /* ARP message directed to us?
      -> add IP address in ARP cache; assume requester wants to talk to us,
         can result in directly sending the queued packets for this host.
     ARP message not directed to us?
      ->  update the source IP address in the cache, if present */
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
    ebf0:	d8c00017 	ldw	r3,0(sp)
    ebf4:	10c0771e 	bne	r2,r3,edd4 <ethernet_input+0x498>
    ebf8:	07000044 	movi	fp,1
    ebfc:	01c00044 	movi	r7,1
    ec00:	9809883a 	mov	r4,r19
    ec04:	d9400104 	addi	r5,sp,4
    ec08:	800d883a 	mov	r6,r16
    ec0c:	000dd100 	call	dd10 <etharp_update_arp_entry>
                   for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);

  /* now act on the message itself */
  switch (hdr->opcode) {
    ec10:	8880058b 	ldhu	r2,22(r17)
    ec14:	00c04004 	movi	r3,256
    ec18:	10c01526 	beq	r2,r3,ec70 <ethernet_input+0x334>
    ec1c:	00c08004 	movi	r3,512
    ec20:	10c00f26 	beq	r2,r3,ec60 <ethernet_input+0x324>
    dhcp_arp_reply(netif, &sipaddr);
#endif /* (LWIP_DHCP && DHCP_DOES_ARP_CHECK) */
    break;
  default:
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    ec24:	b8800b0b 	ldhu	r2,44(r23)
    ec28:	10800044 	addi	r2,r2,1
    ec2c:	b8800b0d 	sth	r2,44(r23)
    ec30:	003f7806 	br	ea14 <ethernet_input+0xd8>
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < SIZEOF_ETHARP_PACKET) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len,
      (s16_t)SIZEOF_ETHARP_PACKET));
    ETHARP_STATS_INC(etharp.lenerr);
    ec34:	008001f4 	movhi	r2,7
    ec38:	10944804 	addi	r2,r2,20768
    ec3c:	1140088b 	ldhu	r5,34(r2)
    ETHARP_STATS_INC(etharp.drop);
    ec40:	10c0078b 	ldhu	r3,30(r2)
    pbuf_free(p);
    ec44:	9009883a 	mov	r4,r18
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < SIZEOF_ETHARP_PACKET) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len,
      (s16_t)SIZEOF_ETHARP_PACKET));
    ETHARP_STATS_INC(etharp.lenerr);
    ec48:	29400044 	addi	r5,r5,1
    ETHARP_STATS_INC(etharp.drop);
    ec4c:	18c00044 	addi	r3,r3,1
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < SIZEOF_ETHARP_PACKET) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len,
      (s16_t)SIZEOF_ETHARP_PACKET));
    ETHARP_STATS_INC(etharp.lenerr);
    ec50:	1140088d 	sth	r5,34(r2)
    ETHARP_STATS_INC(etharp.drop);
    ec54:	10c0078d 	sth	r3,30(r2)
    pbuf_free(p);
    ec58:	00067d80 	call	67d8 <pbuf_free>
    ec5c:	003f6f06 	br	ea1c <ethernet_input+0xe0>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
    ec60:	9809883a 	mov	r4,r19
    ec64:	d9400104 	addi	r5,sp,4
    ec68:	00030680 	call	3068 <dhcp_arp_reply>
    ec6c:	003f6906 	br	ea14 <ethernet_input+0xd8>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
    ec70:	e7003fcc 	andi	fp,fp,255
    ec74:	e03f6726 	beq	fp,zero,ea14 <ethernet_input+0xd8>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
    ec78:	00808004 	movi	r2,512
    ec7c:	8880058d 	sth	r2,22(r17)

      IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
    ec80:	a0800003 	ldbu	r2,0(r20)
    ec84:	a8800005 	stb	r2,0(r21)
    ec88:	a0800043 	ldbu	r2,1(r20)
    ec8c:	a8800045 	stb	r2,1(r21)
    ec90:	a0800083 	ldbu	r2,2(r20)
    ec94:	a8800085 	stb	r2,2(r21)
    ec98:	a08000c3 	ldbu	r2,3(r20)
    ec9c:	a88000c5 	stb	r2,3(r21)
      IPADDR2_COPY(&hdr->sipaddr, &netif->ip_addr);
    eca0:	b0800003 	ldbu	r2,0(r22)
    eca4:	a0800005 	stb	r2,0(r20)
    eca8:	b0800043 	ldbu	r2,1(r22)
    ecac:	a0800045 	stb	r2,1(r20)
    ecb0:	b0800083 	ldbu	r2,2(r22)
    ecb4:	a0800085 	stb	r2,2(r20)
    ecb8:	b08000c3 	ldbu	r2,3(r22)
    ecbc:	a08000c5 	stb	r2,3(r20)

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
    ecc0:	98c00983 	ldbu	r3,38(r19)
    ecc4:	00800184 	movi	r2,6
    ecc8:	18800926 	beq	r3,r2,ecf0 <ethernet_input+0x3b4>
    eccc:	010000b4 	movhi	r4,2
    ecd0:	210d4b04 	addi	r4,r4,13612
    ecd4:	014000b4 	movhi	r5,2
    ecd8:	29578004 	addi	r5,r5,24064
    ecdc:	0180c484 	movi	r6,786
    ece0:	01c000b4 	movhi	r7,2
    ece4:	39d76004 	addi	r7,r7,23936
    ece8:	00104380 	call	10438 <printf>
    ecec:	003fff06 	br	ecec <ethernet_input+0x3b0>
       * 'sender IP address' MUST be sent using link-layer broadcast instead of
       * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
      ethdst_hwaddr = ip_addr_islinklocal(&netif->ip_addr) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
    ecf0:	80800003 	ldbu	r2,0(r16)
    ecf4:	89800884 	addi	r6,r17,34
#if LWIP_AUTOIP
      ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
      ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
    ecf8:	88c00084 	addi	r3,r17,2
       * 'sender IP address' MUST be sent using link-layer broadcast instead of
       * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
      ethdst_hwaddr = ip_addr_islinklocal(&netif->ip_addr) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
    ecfc:	30800005 	stb	r2,0(r6)
    ed00:	81000043 	ldbu	r4,1(r16)
    case PP_HTONS(ETHTYPE_ARP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
        goto free_and_return;
      }
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
    ed04:	988009c4 	addi	r2,r19,39
      ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
      ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
#endif /* LWIP_AUTOIP */
      ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
      ETHADDR16_COPY(&ethhdr->src, ethaddr);
    ed08:	8c400204 	addi	r17,r17,8
       * 'sender IP address' MUST be sent using link-layer broadcast instead of
       * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
      ethdst_hwaddr = ip_addr_islinklocal(&netif->ip_addr) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
    ed0c:	31000045 	stb	r4,1(r6)
    ed10:	81c00083 	ldbu	r7,2(r16)

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
    ed14:	9809883a 	mov	r4,r19
    ed18:	900b883a 	mov	r5,r18
       * 'sender IP address' MUST be sent using link-layer broadcast instead of
       * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
      ethdst_hwaddr = ip_addr_islinklocal(&netif->ip_addr) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
    ed1c:	31c00085 	stb	r7,2(r6)
    ed20:	81c000c3 	ldbu	r7,3(r16)
    ed24:	31c000c5 	stb	r7,3(r6)
    ed28:	81c00103 	ldbu	r7,4(r16)
    ed2c:	31c00105 	stb	r7,4(r6)
    ed30:	81c00143 	ldbu	r7,5(r16)
    ed34:	31c00145 	stb	r7,5(r6)
#if LWIP_AUTOIP
      ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
      ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
    ed38:	81800003 	ldbu	r6,0(r16)
    ed3c:	19800005 	stb	r6,0(r3)
    ed40:	81800043 	ldbu	r6,1(r16)
    ed44:	19800045 	stb	r6,1(r3)
    ed48:	81800083 	ldbu	r6,2(r16)
    ed4c:	19800085 	stb	r6,2(r3)
    ed50:	818000c3 	ldbu	r6,3(r16)
    ed54:	198000c5 	stb	r6,3(r3)
    ed58:	81800103 	ldbu	r6,4(r16)
    ed5c:	19800105 	stb	r6,4(r3)
    ed60:	81800143 	ldbu	r6,5(r16)
    ed64:	19800145 	stb	r6,5(r3)
#endif /* LWIP_AUTOIP */
      ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
    ed68:	10c00003 	ldbu	r3,0(r2)
    ed6c:	80c00005 	stb	r3,0(r16)
    ed70:	98c00a03 	ldbu	r3,40(r19)
    ed74:	80c00045 	stb	r3,1(r16)
    ed78:	98c00a43 	ldbu	r3,41(r19)
    ed7c:	80c00085 	stb	r3,2(r16)
    ed80:	98c00a83 	ldbu	r3,42(r19)
    ed84:	80c000c5 	stb	r3,3(r16)
    ed88:	98c00ac3 	ldbu	r3,43(r19)
    ed8c:	80c00105 	stb	r3,4(r16)
    ed90:	98c00b03 	ldbu	r3,44(r19)
    ed94:	80c00145 	stb	r3,5(r16)
      ETHADDR16_COPY(&ethhdr->src, ethaddr);
    ed98:	10c00003 	ldbu	r3,0(r2)
    ed9c:	88c00005 	stb	r3,0(r17)
    eda0:	98c00a03 	ldbu	r3,40(r19)
    eda4:	88c00045 	stb	r3,1(r17)
    eda8:	98c00a43 	ldbu	r3,41(r19)
    edac:	88c00085 	stb	r3,2(r17)
    edb0:	98c00a83 	ldbu	r3,42(r19)
    edb4:	88c000c5 	stb	r3,3(r17)
    edb8:	98c00ac3 	ldbu	r3,43(r19)
    edbc:	88c00105 	stb	r3,4(r17)
    edc0:	98800b03 	ldbu	r2,44(r19)
    edc4:	88800145 	stb	r2,5(r17)

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
    edc8:	98800617 	ldw	r2,24(r19)
    edcc:	103ee83a 	callr	r2
    edd0:	003f1006 	br	ea14 <ethernet_input+0xd8>
  /* ARP message directed to us?
      -> add IP address in ARP cache; assume requester wants to talk to us,
         can result in directly sending the queued packets for this host.
     ARP message not directed to us?
      ->  update the source IP address in the cache, if present */
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
    edd4:	0039883a 	mov	fp,zero
    edd8:	01c00084 	movi	r7,2
    eddc:	003f8806 	br	ec00 <ethernet_input+0x2c4>

0000ede0 <lwipAlarmCallback>:
static alt_u32  lwip250mStimer;

//  Alarm callback function.
alt_u32 lwipAlarmCallback(void* context)
{
    lwipProcessTimerFlag = 1;          //  Set flag to process timers
    ede0:	00800044 	movi	r2,1
    ede4:	d0a8cc15 	stw	r2,-23760(gp)
    return lwipTicksPer250mS;
}
    ede8:	d0a8cd17 	ldw	r2,-23756(gp)
    edec:	f800283a 	ret

0000edf0 <lwipProcessTimers>:

//  Run this every 250mS to update lwIP timers
void        lwipProcessTimers(void)
{
    lwipProcessTimerFlag = 0;
    lwip250mStimer += 250;
    edf0:	d0a8ce17 	ldw	r2,-23752(gp)
    if( (lwip250mStimer % TCP_TMR_INTERVAL) == 0 ) { tcp_tmr(); }
    edf4:	00c03e84 	movi	r3,250
    return 0;
}

//  Run this every 250mS to update lwIP timers
void        lwipProcessTimers(void)
{
    edf8:	deffff04 	addi	sp,sp,-4
    lwipProcessTimerFlag = 0;
    lwip250mStimer += 250;
    edfc:	10803e84 	addi	r2,r2,250
    if( (lwip250mStimer % TCP_TMR_INTERVAL) == 0 ) { tcp_tmr(); }
    ee00:	10c7203a 	divu	r3,r2,r3
    ee04:	18c03ea4 	muli	r3,r3,250
    return 0;
}

//  Run this every 250mS to update lwIP timers
void        lwipProcessTimers(void)
{
    ee08:	dfc00015 	stw	ra,0(sp)
    lwipProcessTimerFlag = 0;
    ee0c:	d028cc15 	stw	zero,-23760(gp)
    lwip250mStimer += 250;
    ee10:	d0a8ce15 	stw	r2,-23752(gp)
    if( (lwip250mStimer % TCP_TMR_INTERVAL) == 0 ) { tcp_tmr(); }
    ee14:	10c01f26 	beq	r2,r3,ee94 <lwipProcessTimers+0xa4>
    if( (lwip250mStimer % ARP_TMR_INTERVAL) == 0 ) { etharp_tmr(); }
    ee18:	00c4e204 	movi	r3,5000
    ee1c:	10c7203a 	divu	r3,r2,r3
    ee20:	18c4e224 	muli	r3,r3,5000
    ee24:	10c01826 	beq	r2,r3,ee88 <lwipProcessTimers+0x98>
#if IP_REASSEMBLY
    if( (lwip250mStimer % IP_TMR_INTERVAL) == 0 ) { ip_reass_tmr(); }
    ee28:	00c0fa04 	movi	r3,1000
    ee2c:	10c7203a 	divu	r3,r2,r3
    ee30:	18c0fa24 	muli	r3,r3,1000
    ee34:	10c01126 	beq	r2,r3,ee7c <lwipProcessTimers+0x8c>
#endif
#if LWIP_IGMP
    if( (lwip250mStimer % IGMP_TMR_INTERVAL ) == 0 ) { igmp_tmr(); } 
#endif
#if LWIP_DHCP
    if( (lwip250mStimer % DHCP_FINE_TIMER_MSECS ) == 0 ) { dhcp_fine_tmr(); }
    ee38:	00c07d04 	movi	r3,500
    ee3c:	10c7203a 	divu	r3,r2,r3
    ee40:	18c07d24 	muli	r3,r3,500
    ee44:	10c00a26 	beq	r2,r3,ee70 <lwipProcessTimers+0x80>
    if( (lwip250mStimer % (DHCP_COARSE_TIMER_SECS*1000) ) == 0 ) { dhcp_coarse_tmr(); }
    ee48:	00fa9814 	movui	r3,60000
    ee4c:	10c9203a 	divu	r4,r2,r3
    ee50:	20c7383a 	mul	r3,r4,r3
    ee54:	10c00326 	beq	r2,r3,ee64 <lwipProcessTimers+0x74>
#endif
#if LWIP_DNS
    if( (lwip250mStimer % DNS_TMR_INTERVAL) == 0 ) { dns_tmr(); }
#endif
}
    ee58:	dfc00017 	ldw	ra,0(sp)
    ee5c:	dec00104 	addi	sp,sp,4
    ee60:	f800283a 	ret
    ee64:	dfc00017 	ldw	ra,0(sp)
    ee68:	dec00104 	addi	sp,sp,4
#if LWIP_IGMP
    if( (lwip250mStimer % IGMP_TMR_INTERVAL ) == 0 ) { igmp_tmr(); } 
#endif
#if LWIP_DHCP
    if( (lwip250mStimer % DHCP_FINE_TIMER_MSECS ) == 0 ) { dhcp_fine_tmr(); }
    if( (lwip250mStimer % (DHCP_COARSE_TIMER_SECS*1000) ) == 0 ) { dhcp_coarse_tmr(); }
    ee6c:	00032dc1 	jmpi	32dc <dhcp_coarse_tmr>
#endif
#if LWIP_IGMP
    if( (lwip250mStimer % IGMP_TMR_INTERVAL ) == 0 ) { igmp_tmr(); } 
#endif
#if LWIP_DHCP
    if( (lwip250mStimer % DHCP_FINE_TIMER_MSECS ) == 0 ) { dhcp_fine_tmr(); }
    ee70:	00034e00 	call	34e0 <dhcp_fine_tmr>
    ee74:	d0a8ce17 	ldw	r2,-23752(gp)
    ee78:	003ff306 	br	ee48 <lwipProcessTimers+0x58>
    lwipProcessTimerFlag = 0;
    lwip250mStimer += 250;
    if( (lwip250mStimer % TCP_TMR_INTERVAL) == 0 ) { tcp_tmr(); }
    if( (lwip250mStimer % ARP_TMR_INTERVAL) == 0 ) { etharp_tmr(); }
#if IP_REASSEMBLY
    if( (lwip250mStimer % IP_TMR_INTERVAL) == 0 ) { ip_reass_tmr(); }
    ee7c:	00051140 	call	5114 <ip_reass_tmr>
    ee80:	d0a8ce17 	ldw	r2,-23752(gp)
    ee84:	003fec06 	br	ee38 <lwipProcessTimers+0x48>
void        lwipProcessTimers(void)
{
    lwipProcessTimerFlag = 0;
    lwip250mStimer += 250;
    if( (lwip250mStimer % TCP_TMR_INTERVAL) == 0 ) { tcp_tmr(); }
    if( (lwip250mStimer % ARP_TMR_INTERVAL) == 0 ) { etharp_tmr(); }
    ee88:	000de980 	call	de98 <etharp_tmr>
    ee8c:	d0a8ce17 	ldw	r2,-23752(gp)
    ee90:	003fe506 	br	ee28 <lwipProcessTimers+0x38>
//  Run this every 250mS to update lwIP timers
void        lwipProcessTimers(void)
{
    lwipProcessTimerFlag = 0;
    lwip250mStimer += 250;
    if( (lwip250mStimer % TCP_TMR_INTERVAL) == 0 ) { tcp_tmr(); }
    ee94:	00091200 	call	9120 <tcp_tmr>
    ee98:	d0a8ce17 	ldw	r2,-23752(gp)
    ee9c:	003fde06 	br	ee18 <lwipProcessTimers+0x28>

0000eea0 <main>:

//  Define netif for lwIP
struct netif    alteraTseNetif;

int main()
{
    eea0:	defff904 	addi	sp,sp,-28
    eea4:	dc400415 	stw	r17,16(sp)
    eea8:	dc000315 	stw	r16,12(sp)
    eeac:	dfc00615 	stw	ra,24(sp)
    eeb0:	dc800515 	stw	r18,20(sp)
void udpecho_init(void);

// Enable/disable this in echo.h
#if TEST_HISTOGRAM
    // Get timestamp freq
    timestamp_freq = alt_timestamp_freq();
    eeb4:	001dde40 	call	1dde4 <alt_timestamp_freq>
    eeb8:	00c000f4 	movhi	r3,3
    eebc:	18eea804 	addi	r3,r3,-17760
    eec0:	18800015 	stw	r2,0(r3)
    // Init histogram
	int i;
    for (i = 1; i <= TNUM_HIST; i++){
    eec4:	04000044 	movi	r16,1
    eec8:	0449c444 	movi	r17,10001
    eecc:	00000206 	br	eed8 <main+0x38>
    eed0:	84000044 	addi	r16,r16,1
    eed4:	84400c26 	beq	r16,r17,ef08 <main+0x68>
        if(init_hist(i, MAX_HIST_VAL, histarea)){
    eed8:	8009883a 	mov	r4,r16
    eedc:	0140fa04 	movi	r5,1000
    eee0:	018000f4 	movhi	r6,3
    eee4:	31aede04 	addi	r6,r6,-17544
    eee8:	00011280 	call	1128 <init_hist>
    eeec:	103ff81e 	bne	r2,zero,eed0 <main+0x30>
        	//printf("%d OK\n", i);
        } else {
        	printf("%d ERR\n", i);
    eef0:	800b883a 	mov	r5,r16
    eef4:	010000b4 	movhi	r4,2
    eef8:	21112504 	addi	r4,r4,17556
#if TEST_HISTOGRAM
    // Get timestamp freq
    timestamp_freq = alt_timestamp_freq();
    // Init histogram
	int i;
    for (i = 1; i <= TNUM_HIST; i++){
    eefc:	84000044 	addi	r16,r16,1
        if(init_hist(i, MAX_HIST_VAL, histarea)){
        	//printf("%d OK\n", i);
        } else {
        	printf("%d ERR\n", i);
    ef00:	00104380 	call	10438 <printf>
#if TEST_HISTOGRAM
    // Get timestamp freq
    timestamp_freq = alt_timestamp_freq();
    // Init histogram
	int i;
    for (i = 1; i <= TNUM_HIST; i++){
    ef04:	847ff41e 	bne	r16,r17,eed8 <main+0x38>
        	printf("%d ERR\n", i);
        }
    }
#endif /* TEST_HISTOGRAM */

    printf("Running...\n");
    ef08:	010000b4 	movhi	r4,2
    ef0c:	2117cb04 	addi	r4,r4,24364
    ef10:	00106a40 	call	106a4 <puts>
    lwip250mStimer = 0;
    lwipProcessTimerFlag = 0;
    lwipTicksPer250mS = alt_ticks_per_second() / 4;
    ef14:	008000f4 	movhi	r2,3
    ef18:	10aed804 	addi	r2,r2,-17568
    ef1c:	10800017 	ldw	r2,0(r2)
    if (alt_alarm_start (&lwipAlarm, lwipTicksPer250mS, lwipAlarmCallback, NULL) < 0)
    ef20:	01000134 	movhi	r4,4
    ef24:	2127f604 	addi	r4,r4,-24616
    ef28:	01800074 	movhi	r6,1
    ef2c:	31bb7804 	addi	r6,r6,-4640
#endif /* TEST_HISTOGRAM */

    printf("Running...\n");
    lwip250mStimer = 0;
    lwipProcessTimerFlag = 0;
    lwipTicksPer250mS = alt_ticks_per_second() / 4;
    ef30:	1004d0ba 	srli	r2,r2,2
    if (alt_alarm_start (&lwipAlarm, lwipTicksPer250mS, lwipAlarmCallback, NULL) < 0)
    ef34:	000f883a 	mov	r7,zero
        }
    }
#endif /* TEST_HISTOGRAM */

    printf("Running...\n");
    lwip250mStimer = 0;
    ef38:	d028ce15 	stw	zero,-23752(gp)
    lwipProcessTimerFlag = 0;
    lwipTicksPer250mS = alt_ticks_per_second() / 4;
    if (alt_alarm_start (&lwipAlarm, lwipTicksPer250mS, lwipAlarmCallback, NULL) < 0)
    ef3c:	100b883a 	mov	r5,r2
    }
#endif /* TEST_HISTOGRAM */

    printf("Running...\n");
    lwip250mStimer = 0;
    lwipProcessTimerFlag = 0;
    ef40:	d028cc15 	stw	zero,-23760(gp)
    lwipTicksPer250mS = alt_ticks_per_second() / 4;
    ef44:	d0a8cd15 	stw	r2,-23756(gp)
    if (alt_alarm_start (&lwipAlarm, lwipTicksPer250mS, lwipAlarmCallback, NULL) < 0)
    ef48:	00188880 	call	18888 <alt_alarm_start>
    ef4c:	10005216 	blt	r2,zero,f098 <main+0x1f8>
        printf ("System clock is required!\n");
        for(;;);
        }
    
    //  Load platform specific MAC address into netif
    alteraTseNetif.hwaddr[0] = 0x00;
    ef50:	040001f4 	movhi	r16,7
    ef54:	84149004 	addi	r16,r16,21056
    alteraTseNetif.hwaddr[1] = 0x07;
    ef58:	008001c4 	movi	r2,7
    ef5c:	80800a05 	stb	r2,40(r16)
    alteraTseNetif.hwaddr[2] = 0xab;
    ef60:	00bfeac4 	movi	r2,-85
    ef64:	80800a45 	stb	r2,41(r16)
    alteraTseNetif.hwaddr[3] = 0xf0;
    ef68:	00bffc04 	movi	r2,-16
    ef6c:	80800a85 	stb	r2,42(r16)
    alteraTseNetif.hwaddr[4] = 0x0d;
    ef70:	00800344 	movi	r2,13
    ef74:	80800ac5 	stb	r2,43(r16)
    alteraTseNetif.hwaddr[5] = 0xba;
    ef78:	00bfee84 	movi	r2,-70
    ef7c:	80800b05 	stb	r2,44(r16)
        printf ("System clock is required!\n");
        for(;;);
        }
    
    //  Load platform specific MAC address into netif
    alteraTseNetif.hwaddr[0] = 0x00;
    ef80:	800009c5 	stb	zero,39(r16)
    alteraTseNetif.hwaddr[3] = 0xf0;
    alteraTseNetif.hwaddr[4] = 0x0d;
    alteraTseNetif.hwaddr[5] = 0xba;

    //  Initialize lwIP, Altera TSE and the ethernetif
    lwip_init();
    ef84:	00038580 	call	3858 <lwip_init>
    if(netif_add(&alteraTseNetif, &ip_zero, &ip_zero, &ip_zero, alteraTseNetif.state, ethernetif_init, ethernet_input) == NULL)
    ef88:	80800717 	ldw	r2,28(r16)
    ef8c:	d168cf04 	addi	r5,gp,-23748
    ef90:	8009883a 	mov	r4,r16
    ef94:	d8800015 	stw	r2,0(sp)
    ef98:	00800034 	movhi	r2,0
    ef9c:	10809c04 	addi	r2,r2,624
    efa0:	d8800115 	stw	r2,4(sp)
    efa4:	00800074 	movhi	r2,1
    efa8:	10ba4f04 	addi	r2,r2,-5828
    efac:	d8800215 	stw	r2,8(sp)
    efb0:	280d883a 	mov	r6,r5
    efb4:	280f883a 	mov	r7,r5
    efb8:	00063c80 	call	63c8 <netif_add>
    efbc:	10003a26 	beq	r2,zero,f0a8 <main+0x208>
        {
        printf( "Fatal error initializing...\n" );
        for(;;);
        }
    netif_set_default(&alteraTseNetif);
    efc0:	8009883a 	mov	r4,r16
    efc4:	00064d00 	call	64d0 <netif_set_default>
    
    // Initialize Altera TSE in a loop if waiting for a link
    printf("Waiting for link...");
    efc8:	010000b4 	movhi	r4,2
    efcc:	2117dc04 	addi	r4,r4,24432
    efd0:	00104380 	call	10438 <printf>
    while(((struct ethernetif *) alteraTseNetif.state)->link_alive!=1)
    efd4:	80c00717 	ldw	r3,28(r16)
    efd8:	00800044 	movi	r2,1
    efdc:	18c00217 	ldw	r3,8(r3)
    efe0:	18801026 	beq	r3,r2,f024 <main+0x184>
    efe4:	044000f4 	movhi	r17,3
    efe8:	8c660a04 	addi	r17,r17,-26584
    efec:	1025883a 	mov	r18,r2
        {
        mSdelay(1000);
    eff0:	010003f4 	movhi	r4,15
    eff4:	21109004 	addi	r4,r4,16960
    eff8:	00194f00 	call	194f0 <usleep>
        putchar('.');
    effc:	88800017 	ldw	r2,0(r17)
    f000:	01000b84 	movi	r4,46
    f004:	11400217 	ldw	r5,8(r2)
    f008:	00105300 	call	10530 <putc>
        tse_mac_init(0, alteraTseNetif.state);
    f00c:	81400717 	ldw	r5,28(r16)
    f010:	0009883a 	mov	r4,zero
    f014:	000097c0 	call	97c <tse_mac_init>
        }
    netif_set_default(&alteraTseNetif);
    
    // Initialize Altera TSE in a loop if waiting for a link
    printf("Waiting for link...");
    while(((struct ethernetif *) alteraTseNetif.state)->link_alive!=1)
    f018:	80800717 	ldw	r2,28(r16)
    f01c:	10800217 	ldw	r2,8(r2)
    f020:	14bff31e 	bne	r2,r18,eff0 <main+0x150>
        {
        mSdelay(1000);
        putchar('.');
        tse_mac_init(0, alteraTseNetif.state);
        }
    printf("OK\n");
    f024:	010000b4 	movhi	r4,2
    f028:	2117e104 	addi	r4,r4,24452
    f02c:	00106a40 	call	106a4 <puts>
        //  Poll lwIP for incoming packets.
        ethernetif_input(&alteraTseNetif);
        }
#else
    STATIC_IP;
    netif_set_ipaddr(&alteraTseNetif, &lwipStaticIp);
    f030:	d168d004 	addi	r5,gp,-23744
            lwipProcessTimers();
        //  Poll lwIP for incoming packets.
        ethernetif_input(&alteraTseNetif);
        }
#else
    STATIC_IP;
    f034:	008802f4 	movhi	r2,8203
    f038:	10862b04 	addi	r2,r2,6316
    netif_set_ipaddr(&alteraTseNetif, &lwipStaticIp);
    f03c:	010001f4 	movhi	r4,7
    f040:	21149004 	addi	r4,r4,21056
            lwipProcessTimers();
        //  Poll lwIP for incoming packets.
        ethernetif_input(&alteraTseNetif);
        }
#else
    STATIC_IP;
    f044:	d0a8d015 	stw	r2,-23744(gp)
    netif_set_ipaddr(&alteraTseNetif, &lwipStaticIp);
    f048:	00062640 	call	6264 <netif_set_ipaddr>
    netif_set_up(&alteraTseNetif);
    f04c:	010001f4 	movhi	r4,7
    f050:	21149004 	addi	r4,r4,21056
    f054:	00064d80 	call	64d8 <netif_set_up>
#endif
    printf("IP address: %s\n", ip_ntoa(&alteraTseNetif.ip_addr));
    f058:	010001f4 	movhi	r4,7
    f05c:	21149104 	addi	r4,r4,21060
    f060:	0004de40 	call	4de4 <ipaddr_ntoa>
    f064:	010000b4 	movhi	r4,2
    f068:	2117e204 	addi	r4,r4,24456
    f06c:	100b883a 	mov	r5,r2
    f070:	00104380 	call	10438 <printf>

#if BUILD_HTTPD
    httpd_init();
#endif
    udpecho_init();
    f074:	000105c0 	call	105c <udpecho_init>
    f078:	00000306 	br	f088 <main+0x1e8>
        {
        //  Process lwIP timer dependent code
        if(lwipProcessTimerFlag)
            lwipProcessTimers();
        //  Poll lwIP for incoming packets.
        ethernetif_input(&alteraTseNetif);
    f07c:	010001f4 	movhi	r4,7
    f080:	21149004 	addi	r4,r4,21056
    f084:	000009c0 	call	9c <ethernetif_input>
    udpecho_init();
    //  This is the main loop for lwIP - other processing can be done by calling application functions.
    for(;;)
        {
        //  Process lwIP timer dependent code
        if(lwipProcessTimerFlag)
    f088:	d0a8cc17 	ldw	r2,-23760(gp)
    f08c:	103ffb26 	beq	r2,zero,f07c <main+0x1dc>
            lwipProcessTimers();
    f090:	000edf00 	call	edf0 <lwipProcessTimers>
    f094:	003ff906 	br	f07c <main+0x1dc>
    lwip250mStimer = 0;
    lwipProcessTimerFlag = 0;
    lwipTicksPer250mS = alt_ticks_per_second() / 4;
    if (alt_alarm_start (&lwipAlarm, lwipTicksPer250mS, lwipAlarmCallback, NULL) < 0)
        {
        printf ("System clock is required!\n");
    f098:	010000b4 	movhi	r4,2
    f09c:	2117ce04 	addi	r4,r4,24376
    f0a0:	00106a40 	call	106a4 <puts>
    f0a4:	003fff06 	br	f0a4 <main+0x204>

    //  Initialize lwIP, Altera TSE and the ethernetif
    lwip_init();
    if(netif_add(&alteraTseNetif, &ip_zero, &ip_zero, &ip_zero, alteraTseNetif.state, ethernetif_init, ethernet_input) == NULL)
        {
        printf( "Fatal error initializing...\n" );
    f0a8:	010000b4 	movhi	r4,2
    f0ac:	2117d504 	addi	r4,r4,24404
    f0b0:	00106a40 	call	106a4 <puts>
    f0b4:	003fff06 	br	f0b4 <main+0x214>

0000f0b8 <__fixunsdfsi>:
    f0b8:	defffd04 	addi	sp,sp,-12
    f0bc:	000d883a 	mov	r6,zero
    f0c0:	01d07834 	movhi	r7,16864
    f0c4:	dc400115 	stw	r17,4(sp)
    f0c8:	dc000015 	stw	r16,0(sp)
    f0cc:	dfc00215 	stw	ra,8(sp)
    f0d0:	2023883a 	mov	r17,r4
    f0d4:	2821883a 	mov	r16,r5
    f0d8:	000f9dc0 	call	f9dc <__gedf2>
    f0dc:	1000080e 	bge	r2,zero,f100 <__fixunsdfsi+0x48>
    f0e0:	8809883a 	mov	r4,r17
    f0e4:	800b883a 	mov	r5,r16
    f0e8:	000fa400 	call	fa40 <__fixdfsi>
    f0ec:	dfc00217 	ldw	ra,8(sp)
    f0f0:	dc400117 	ldw	r17,4(sp)
    f0f4:	dc000017 	ldw	r16,0(sp)
    f0f8:	dec00304 	addi	sp,sp,12
    f0fc:	f800283a 	ret
    f100:	000d883a 	mov	r6,zero
    f104:	01d07834 	movhi	r7,16864
    f108:	8809883a 	mov	r4,r17
    f10c:	800b883a 	mov	r5,r16
    f110:	000f4e40 	call	f4e4 <__subdf3>
    f114:	180b883a 	mov	r5,r3
    f118:	1009883a 	mov	r4,r2
    f11c:	000fa400 	call	fa40 <__fixdfsi>
    f120:	00e00034 	movhi	r3,32768
    f124:	10c5883a 	add	r2,r2,r3
    f128:	dfc00217 	ldw	ra,8(sp)
    f12c:	dc400117 	ldw	r17,4(sp)
    f130:	dc000017 	ldw	r16,0(sp)
    f134:	dec00304 	addi	sp,sp,12
    f138:	f800283a 	ret

0000f13c <_fpadd_parts>:
    f13c:	2005883a 	mov	r2,r4
    f140:	21000017 	ldw	r4,0(r4)
    f144:	01c00044 	movi	r7,1
    f148:	3900622e 	bgeu	r7,r4,f2d4 <_fpadd_parts+0x198>
    f14c:	28c00017 	ldw	r3,0(r5)
    f150:	38c05f2e 	bgeu	r7,r3,f2d0 <_fpadd_parts+0x194>
    f154:	01c00104 	movi	r7,4
    f158:	21c0c626 	beq	r4,r7,f474 <_fpadd_parts+0x338>
    f15c:	19c05c26 	beq	r3,r7,f2d0 <_fpadd_parts+0x194>
    f160:	01c00084 	movi	r7,2
    f164:	19c06b26 	beq	r3,r7,f314 <_fpadd_parts+0x1d8>
    f168:	21c05926 	beq	r4,r7,f2d0 <_fpadd_parts+0x194>
    f16c:	11c00217 	ldw	r7,8(r2)
    f170:	2ac00217 	ldw	r11,8(r5)
    f174:	13000317 	ldw	r12,12(r2)
    f178:	13400417 	ldw	r13,16(r2)
    f17c:	3ac9c83a 	sub	r4,r7,r11
    f180:	2a000317 	ldw	r8,12(r5)
    f184:	2a400417 	ldw	r9,16(r5)
    f188:	2015883a 	mov	r10,r4
    f18c:	20007516 	blt	r4,zero,f364 <_fpadd_parts+0x228>
    f190:	00c00fc4 	movi	r3,63
    f194:	1a805016 	blt	r3,r10,f2d8 <_fpadd_parts+0x19c>
    f198:	0100870e 	bge	zero,r4,f3b8 <_fpadd_parts+0x27c>
    f19c:	50fff804 	addi	r3,r10,-32
    f1a0:	18009916 	blt	r3,zero,f408 <_fpadd_parts+0x2cc>
    f1a4:	48d6d83a 	srl	r11,r9,r3
    f1a8:	001d883a 	mov	r14,zero
    f1ac:	18009e16 	blt	r3,zero,f428 <_fpadd_parts+0x2ec>
    f1b0:	01000044 	movi	r4,1
    f1b4:	20c6983a 	sll	r3,r4,r3
    f1b8:	0015883a 	mov	r10,zero
    f1bc:	513fffc4 	addi	r4,r10,-1
    f1c0:	2295403a 	cmpgeu	r10,r4,r10
    f1c4:	1a87c83a 	sub	r3,r3,r10
    f1c8:	1a52703a 	and	r9,r3,r9
    f1cc:	2210703a 	and	r8,r4,r8
    f1d0:	4250b03a 	or	r8,r8,r9
    f1d4:	4010c03a 	cmpne	r8,r8,zero
    f1d8:	42d0b03a 	or	r8,r8,r11
    f1dc:	7013883a 	mov	r9,r14
    f1e0:	11000117 	ldw	r4,4(r2)
    f1e4:	28800117 	ldw	r2,4(r5)
    f1e8:	20804126 	beq	r4,r2,f2f0 <_fpadd_parts+0x1b4>
    f1ec:	20006326 	beq	r4,zero,f37c <_fpadd_parts+0x240>
    f1f0:	4305c83a 	sub	r2,r8,r12
    f1f4:	4091803a 	cmpltu	r8,r8,r2
    f1f8:	4b47c83a 	sub	r3,r9,r13
    f1fc:	1a07c83a 	sub	r3,r3,r8
    f200:	18006316 	blt	r3,zero,f390 <_fpadd_parts+0x254>
    f204:	30000115 	stw	zero,4(r6)
    f208:	31c00215 	stw	r7,8(r6)
    f20c:	30800315 	stw	r2,12(r6)
    f210:	30c00415 	stw	r3,16(r6)
    f214:	11ffffc4 	addi	r7,r2,-1
    f218:	388b403a 	cmpgeu	r5,r7,r2
    f21c:	194bc83a 	sub	r5,r3,r5
    f220:	01040034 	movhi	r4,4096
    f224:	213fffc4 	addi	r4,r4,-1
    f228:	21401736 	bltu	r4,r5,f288 <_fpadd_parts+0x14c>
    f22c:	29008226 	beq	r5,r4,f438 <_fpadd_parts+0x2fc>
    f230:	31400217 	ldw	r5,8(r6)
    f234:	02840034 	movhi	r10,4096
    f238:	52bfffc4 	addi	r10,r10,-1
    f23c:	033fff84 	movi	r12,-2
    f240:	297fffc4 	addi	r5,r5,-1
    f244:	00000106 	br	f24c <_fpadd_parts+0x110>
    f248:	3a804a26 	beq	r7,r10,f374 <_fpadd_parts+0x238>
    f24c:	1089883a 	add	r4,r2,r2
    f250:	2091803a 	cmpltu	r8,r4,r2
    f254:	18c7883a 	add	r3,r3,r3
    f258:	227fffc4 	addi	r9,r4,-1
    f25c:	40d1883a 	add	r8,r8,r3
    f260:	490f403a 	cmpgeu	r7,r9,r4
    f264:	41cfc83a 	sub	r7,r8,r7
    f268:	2817883a 	mov	r11,r5
    f26c:	2005883a 	mov	r2,r4
    f270:	4007883a 	mov	r3,r8
    f274:	297fffc4 	addi	r5,r5,-1
    f278:	51fff32e 	bgeu	r10,r7,f248 <_fpadd_parts+0x10c>
    f27c:	31000315 	stw	r4,12(r6)
    f280:	32000415 	stw	r8,16(r6)
    f284:	32c00215 	stw	r11,8(r6)
    f288:	010000c4 	movi	r4,3
    f28c:	31000015 	stw	r4,0(r6)
    f290:	01080034 	movhi	r4,8192
    f294:	213fffc4 	addi	r4,r4,-1
    f298:	20c00b2e 	bgeu	r4,r3,f2c8 <_fpadd_parts+0x18c>
    f29c:	180e97fa 	slli	r7,r3,31
    f2a0:	1008d07a 	srli	r4,r2,1
    f2a4:	31400217 	ldw	r5,8(r6)
    f2a8:	1806d07a 	srli	r3,r3,1
    f2ac:	1080004c 	andi	r2,r2,1
    f2b0:	3908b03a 	or	r4,r7,r4
    f2b4:	1108b03a 	or	r4,r2,r4
    f2b8:	29400044 	addi	r5,r5,1
    f2bc:	31000315 	stw	r4,12(r6)
    f2c0:	30c00415 	stw	r3,16(r6)
    f2c4:	31400215 	stw	r5,8(r6)
    f2c8:	3005883a 	mov	r2,r6
    f2cc:	f800283a 	ret
    f2d0:	2805883a 	mov	r2,r5
    f2d4:	f800283a 	ret
    f2d8:	59c01e0e 	bge	r11,r7,f354 <_fpadd_parts+0x218>
    f2dc:	11000117 	ldw	r4,4(r2)
    f2e0:	28800117 	ldw	r2,4(r5)
    f2e4:	0011883a 	mov	r8,zero
    f2e8:	0013883a 	mov	r9,zero
    f2ec:	20bfbf1e 	bne	r4,r2,f1ec <_fpadd_parts+0xb0>
    f2f0:	4305883a 	add	r2,r8,r12
    f2f4:	1207803a 	cmpltu	r3,r2,r8
    f2f8:	4b53883a 	add	r9,r9,r13
    f2fc:	1a47883a 	add	r3,r3,r9
    f300:	31000115 	stw	r4,4(r6)
    f304:	31c00215 	stw	r7,8(r6)
    f308:	30800315 	stw	r2,12(r6)
    f30c:	30c00415 	stw	r3,16(r6)
    f310:	003fdd06 	br	f288 <_fpadd_parts+0x14c>
    f314:	20ffef1e 	bne	r4,r3,f2d4 <_fpadd_parts+0x198>
    f318:	31000015 	stw	r4,0(r6)
    f31c:	10c00117 	ldw	r3,4(r2)
    f320:	30c00115 	stw	r3,4(r6)
    f324:	10c00217 	ldw	r3,8(r2)
    f328:	11000117 	ldw	r4,4(r2)
    f32c:	29400117 	ldw	r5,4(r5)
    f330:	30c00215 	stw	r3,8(r6)
    f334:	10c00317 	ldw	r3,12(r2)
    f338:	2908703a 	and	r4,r5,r4
    f33c:	30c00315 	stw	r3,12(r6)
    f340:	10c00417 	ldw	r3,16(r2)
    f344:	31000115 	stw	r4,4(r6)
    f348:	3005883a 	mov	r2,r6
    f34c:	30c00415 	stw	r3,16(r6)
    f350:	f800283a 	ret
    f354:	580f883a 	mov	r7,r11
    f358:	0019883a 	mov	r12,zero
    f35c:	001b883a 	mov	r13,zero
    f360:	003f9f06 	br	f1e0 <_fpadd_parts+0xa4>
    f364:	0115c83a 	sub	r10,zero,r4
    f368:	00c00fc4 	movi	r3,63
    f36c:	1abfda16 	blt	r3,r10,f2d8 <_fpadd_parts+0x19c>
    f370:	003f8906 	br	f198 <_fpadd_parts+0x5c>
    f374:	627fb52e 	bgeu	r12,r9,f24c <_fpadd_parts+0x110>
    f378:	003fc006 	br	f27c <_fpadd_parts+0x140>
    f37c:	6205c83a 	sub	r2,r12,r8
    f380:	6099803a 	cmpltu	r12,r12,r2
    f384:	6a47c83a 	sub	r3,r13,r9
    f388:	1b07c83a 	sub	r3,r3,r12
    f38c:	183f9d0e 	bge	r3,zero,f204 <_fpadd_parts+0xc8>
    f390:	0085c83a 	sub	r2,zero,r2
    f394:	1008c03a 	cmpne	r4,r2,zero
    f398:	00c7c83a 	sub	r3,zero,r3
    f39c:	1907c83a 	sub	r3,r3,r4
    f3a0:	01000044 	movi	r4,1
    f3a4:	31000115 	stw	r4,4(r6)
    f3a8:	31c00215 	stw	r7,8(r6)
    f3ac:	30800315 	stw	r2,12(r6)
    f3b0:	30c00415 	stw	r3,16(r6)
    f3b4:	003f9706 	br	f214 <_fpadd_parts+0xd8>
    f3b8:	203f8926 	beq	r4,zero,f1e0 <_fpadd_parts+0xa4>
    f3bc:	50fff804 	addi	r3,r10,-32
    f3c0:	3a8f883a 	add	r7,r7,r10
    f3c4:	18002316 	blt	r3,zero,f454 <_fpadd_parts+0x318>
    f3c8:	68d6d83a 	srl	r11,r13,r3
    f3cc:	001d883a 	mov	r14,zero
    f3d0:	18001c16 	blt	r3,zero,f444 <_fpadd_parts+0x308>
    f3d4:	01000044 	movi	r4,1
    f3d8:	20c6983a 	sll	r3,r4,r3
    f3dc:	0015883a 	mov	r10,zero
    f3e0:	513fffc4 	addi	r4,r10,-1
    f3e4:	2295403a 	cmpgeu	r10,r4,r10
    f3e8:	1a87c83a 	sub	r3,r3,r10
    f3ec:	1b5a703a 	and	r13,r3,r13
    f3f0:	2318703a 	and	r12,r4,r12
    f3f4:	6358b03a 	or	r12,r12,r13
    f3f8:	6018c03a 	cmpne	r12,r12,zero
    f3fc:	62d8b03a 	or	r12,r12,r11
    f400:	701b883a 	mov	r13,r14
    f404:	003f7606 	br	f1e0 <_fpadd_parts+0xa4>
    f408:	4808907a 	slli	r4,r9,1
    f40c:	02c007c4 	movi	r11,31
    f410:	5a97c83a 	sub	r11,r11,r10
    f414:	22c8983a 	sll	r4,r4,r11
    f418:	4296d83a 	srl	r11,r8,r10
    f41c:	4a9cd83a 	srl	r14,r9,r10
    f420:	22d6b03a 	or	r11,r4,r11
    f424:	003f6106 	br	f1ac <_fpadd_parts+0x70>
    f428:	00c00044 	movi	r3,1
    f42c:	1a94983a 	sll	r10,r3,r10
    f430:	0007883a 	mov	r3,zero
    f434:	003f6106 	br	f1bc <_fpadd_parts+0x80>
    f438:	013fff84 	movi	r4,-2
    f43c:	21ff7c2e 	bgeu	r4,r7,f230 <_fpadd_parts+0xf4>
    f440:	003f9106 	br	f288 <_fpadd_parts+0x14c>
    f444:	00c00044 	movi	r3,1
    f448:	1a94983a 	sll	r10,r3,r10
    f44c:	0007883a 	mov	r3,zero
    f450:	003fe306 	br	f3e0 <_fpadd_parts+0x2a4>
    f454:	6816907a 	slli	r11,r13,1
    f458:	010007c4 	movi	r4,31
    f45c:	2289c83a 	sub	r4,r4,r10
    f460:	5908983a 	sll	r4,r11,r4
    f464:	6296d83a 	srl	r11,r12,r10
    f468:	6a9cd83a 	srl	r14,r13,r10
    f46c:	22d6b03a 	or	r11,r4,r11
    f470:	003fd706 	br	f3d0 <_fpadd_parts+0x294>
    f474:	193f971e 	bne	r3,r4,f2d4 <_fpadd_parts+0x198>
    f478:	11000117 	ldw	r4,4(r2)
    f47c:	28c00117 	ldw	r3,4(r5)
    f480:	20ff9426 	beq	r4,r3,f2d4 <_fpadd_parts+0x198>
    f484:	008000b4 	movhi	r2,2
    f488:	1097e604 	addi	r2,r2,24472
    f48c:	f800283a 	ret

0000f490 <__adddf3>:
    f490:	deffec04 	addi	sp,sp,-80
    f494:	d9001115 	stw	r4,68(sp)
    f498:	d9401215 	stw	r5,72(sp)
    f49c:	d9001104 	addi	r4,sp,68
    f4a0:	d9400a04 	addi	r5,sp,40
    f4a4:	dfc01315 	stw	ra,76(sp)
    f4a8:	d9c01015 	stw	r7,64(sp)
    f4ac:	d9800f15 	stw	r6,60(sp)
    f4b0:	000ff600 	call	ff60 <__unpack_d>
    f4b4:	d9000f04 	addi	r4,sp,60
    f4b8:	d9400504 	addi	r5,sp,20
    f4bc:	000ff600 	call	ff60 <__unpack_d>
    f4c0:	d9000a04 	addi	r4,sp,40
    f4c4:	d9400504 	addi	r5,sp,20
    f4c8:	d80d883a 	mov	r6,sp
    f4cc:	000f13c0 	call	f13c <_fpadd_parts>
    f4d0:	1009883a 	mov	r4,r2
    f4d4:	000fd3c0 	call	fd3c <__pack_d>
    f4d8:	dfc01317 	ldw	ra,76(sp)
    f4dc:	dec01404 	addi	sp,sp,80
    f4e0:	f800283a 	ret

0000f4e4 <__subdf3>:
    f4e4:	deffec04 	addi	sp,sp,-80
    f4e8:	d9001115 	stw	r4,68(sp)
    f4ec:	d9401215 	stw	r5,72(sp)
    f4f0:	d9001104 	addi	r4,sp,68
    f4f4:	d9400a04 	addi	r5,sp,40
    f4f8:	dfc01315 	stw	ra,76(sp)
    f4fc:	d9c01015 	stw	r7,64(sp)
    f500:	d9800f15 	stw	r6,60(sp)
    f504:	000ff600 	call	ff60 <__unpack_d>
    f508:	d9000f04 	addi	r4,sp,60
    f50c:	d9400504 	addi	r5,sp,20
    f510:	000ff600 	call	ff60 <__unpack_d>
    f514:	d8800617 	ldw	r2,24(sp)
    f518:	d9000a04 	addi	r4,sp,40
    f51c:	d9400504 	addi	r5,sp,20
    f520:	d80d883a 	mov	r6,sp
    f524:	1080005c 	xori	r2,r2,1
    f528:	d8800615 	stw	r2,24(sp)
    f52c:	000f13c0 	call	f13c <_fpadd_parts>
    f530:	1009883a 	mov	r4,r2
    f534:	000fd3c0 	call	fd3c <__pack_d>
    f538:	dfc01317 	ldw	ra,76(sp)
    f53c:	dec01404 	addi	sp,sp,80
    f540:	f800283a 	ret

0000f544 <__muldf3>:
    f544:	deffe404 	addi	sp,sp,-112
    f548:	d9001115 	stw	r4,68(sp)
    f54c:	d9401215 	stw	r5,72(sp)
    f550:	d9001104 	addi	r4,sp,68
    f554:	d9400a04 	addi	r5,sp,40
    f558:	dfc01b15 	stw	ra,108(sp)
    f55c:	d9800f15 	stw	r6,60(sp)
    f560:	d9c01015 	stw	r7,64(sp)
    f564:	ddc01a15 	stw	r23,104(sp)
    f568:	dd801915 	stw	r22,100(sp)
    f56c:	dd401815 	stw	r21,96(sp)
    f570:	dd001715 	stw	r20,92(sp)
    f574:	dcc01615 	stw	r19,88(sp)
    f578:	dc801515 	stw	r18,84(sp)
    f57c:	dc401415 	stw	r17,80(sp)
    f580:	dc001315 	stw	r16,76(sp)
    f584:	000ff600 	call	ff60 <__unpack_d>
    f588:	d9000f04 	addi	r4,sp,60
    f58c:	d9400504 	addi	r5,sp,20
    f590:	000ff600 	call	ff60 <__unpack_d>
    f594:	d8c00a17 	ldw	r3,40(sp)
    f598:	00800044 	movi	r2,1
    f59c:	10c01136 	bltu	r2,r3,f5e4 <__muldf3+0xa0>
    f5a0:	d8c00b17 	ldw	r3,44(sp)
    f5a4:	d8800617 	ldw	r2,24(sp)
    f5a8:	d9000a04 	addi	r4,sp,40
    f5ac:	1884c03a 	cmpne	r2,r3,r2
    f5b0:	d8800b15 	stw	r2,44(sp)
    f5b4:	000fd3c0 	call	fd3c <__pack_d>
    f5b8:	dfc01b17 	ldw	ra,108(sp)
    f5bc:	ddc01a17 	ldw	r23,104(sp)
    f5c0:	dd801917 	ldw	r22,100(sp)
    f5c4:	dd401817 	ldw	r21,96(sp)
    f5c8:	dd001717 	ldw	r20,92(sp)
    f5cc:	dcc01617 	ldw	r19,88(sp)
    f5d0:	dc801517 	ldw	r18,84(sp)
    f5d4:	dc401417 	ldw	r17,80(sp)
    f5d8:	dc001317 	ldw	r16,76(sp)
    f5dc:	dec01c04 	addi	sp,sp,112
    f5e0:	f800283a 	ret
    f5e4:	d9000517 	ldw	r4,20(sp)
    f5e8:	11000636 	bltu	r2,r4,f604 <__muldf3+0xc0>
    f5ec:	d8800617 	ldw	r2,24(sp)
    f5f0:	d8c00b17 	ldw	r3,44(sp)
    f5f4:	d9000504 	addi	r4,sp,20
    f5f8:	1884c03a 	cmpne	r2,r3,r2
    f5fc:	d8800615 	stw	r2,24(sp)
    f600:	003fec06 	br	f5b4 <__muldf3+0x70>
    f604:	00800104 	movi	r2,4
    f608:	1880051e 	bne	r3,r2,f620 <__muldf3+0xdc>
    f60c:	00800084 	movi	r2,2
    f610:	20bfe31e 	bne	r4,r2,f5a0 <__muldf3+0x5c>
    f614:	010000b4 	movhi	r4,2
    f618:	2117e604 	addi	r4,r4,24472
    f61c:	003fe506 	br	f5b4 <__muldf3+0x70>
    f620:	2080031e 	bne	r4,r2,f630 <__muldf3+0xec>
    f624:	00800084 	movi	r2,2
    f628:	18bffa26 	beq	r3,r2,f614 <__muldf3+0xd0>
    f62c:	003fef06 	br	f5ec <__muldf3+0xa8>
    f630:	00800084 	movi	r2,2
    f634:	18bfda26 	beq	r3,r2,f5a0 <__muldf3+0x5c>
    f638:	20bfec26 	beq	r4,r2,f5ec <__muldf3+0xa8>
    f63c:	dc000d17 	ldw	r16,52(sp)
    f640:	dd000817 	ldw	r20,32(sp)
    f644:	dc800917 	ldw	r18,36(sp)
    f648:	8009883a 	mov	r4,r16
    f64c:	000b883a 	mov	r5,zero
    f650:	a00d883a 	mov	r6,r20
    f654:	000f883a 	mov	r7,zero
    f658:	000fc300 	call	fc30 <__muldi3>
    f65c:	dc400e17 	ldw	r17,56(sp)
    f660:	9009883a 	mov	r4,r18
    f664:	800d883a 	mov	r6,r16
    f668:	000b883a 	mov	r5,zero
    f66c:	000f883a 	mov	r7,zero
    f670:	102f883a 	mov	r23,r2
    f674:	1827883a 	mov	r19,r3
    f678:	000fc300 	call	fc30 <__muldi3>
    f67c:	900d883a 	mov	r6,r18
    f680:	8809883a 	mov	r4,r17
    f684:	000b883a 	mov	r5,zero
    f688:	000f883a 	mov	r7,zero
    f68c:	102b883a 	mov	r21,r2
    f690:	1821883a 	mov	r16,r3
    f694:	000fc300 	call	fc30 <__muldi3>
    f698:	8809883a 	mov	r4,r17
    f69c:	000b883a 	mov	r5,zero
    f6a0:	a00d883a 	mov	r6,r20
    f6a4:	000f883a 	mov	r7,zero
    f6a8:	102d883a 	mov	r22,r2
    f6ac:	1825883a 	mov	r18,r3
    f6b0:	000fc300 	call	fc30 <__muldi3>
    f6b4:	154b883a 	add	r5,r2,r21
    f6b8:	2889803a 	cmpltu	r4,r5,r2
    f6bc:	1c07883a 	add	r3,r3,r16
    f6c0:	20c9883a 	add	r4,r4,r3
    f6c4:	24004b36 	bltu	r4,r16,f7f4 <__muldf3+0x2b0>
    f6c8:	8100011e 	bne	r16,r4,f6d0 <__muldf3+0x18c>
    f6cc:	2d404936 	bltu	r5,r21,f7f4 <__muldf3+0x2b0>
    f6d0:	0011883a 	mov	r8,zero
    f6d4:	0007883a 	mov	r3,zero
    f6d8:	2ccb883a 	add	r5,r5,r19
    f6dc:	b80d883a 	mov	r6,r23
    f6e0:	2cc0012e 	bgeu	r5,r19,f6e8 <__muldf3+0x1a4>
    f6e4:	02000044 	movi	r8,1
    f6e8:	258f883a 	add	r7,r4,r22
    f6ec:	3909803a 	cmpltu	r4,r7,r4
    f6f0:	da400c17 	ldw	r9,48(sp)
    f6f4:	2489883a 	add	r4,r4,r18
    f6f8:	d8800717 	ldw	r2,28(sp)
    f6fc:	20c9883a 	add	r4,r4,r3
    f700:	da800b17 	ldw	r10,44(sp)
    f704:	d8c00617 	ldw	r3,24(sp)
    f708:	3a11883a 	add	r8,r7,r8
    f70c:	4885883a 	add	r2,r9,r2
    f710:	50c6c03a 	cmpne	r3,r10,r3
    f714:	41cf803a 	cmpltu	r7,r8,r7
    f718:	12400104 	addi	r9,r2,4
    f71c:	d8c00115 	stw	r3,4(sp)
    f720:	3909883a 	add	r4,r7,r4
    f724:	da400215 	stw	r9,8(sp)
    f728:	03480034 	movhi	r13,8192
    f72c:	6b7fffc4 	addi	r13,r13,-1
    f730:	4007883a 	mov	r3,r8
    f734:	6900102e 	bgeu	r13,r4,f778 <__muldf3+0x234>
    f738:	10800144 	addi	r2,r2,5
    f73c:	180ed07a 	srli	r7,r3,1
    f740:	18c0004c 	andi	r3,r3,1
    f744:	201097fa 	slli	r8,r4,31
    f748:	281697fa 	slli	r11,r5,31
    f74c:	2008d07a 	srli	r4,r4,1
    f750:	3014d07a 	srli	r10,r6,1
    f754:	2812d07a 	srli	r9,r5,1
    f758:	1019883a 	mov	r12,r2
    f75c:	18000226 	beq	r3,zero,f768 <__muldf3+0x224>
    f760:	5a8cb03a 	or	r6,r11,r10
    f764:	49600034 	orhi	r5,r9,32768
    f768:	41c6b03a 	or	r3,r8,r7
    f76c:	10800044 	addi	r2,r2,1
    f770:	693ff236 	bltu	r13,r4,f73c <__muldf3+0x1f8>
    f774:	db000215 	stw	r12,8(sp)
    f778:	03440034 	movhi	r13,4096
    f77c:	6b7fffc4 	addi	r13,r13,-1
    f780:	69001336 	bltu	r13,r4,f7d0 <__muldf3+0x28c>
    f784:	d8800217 	ldw	r2,8(sp)
    f788:	10bfffc4 	addi	r2,r2,-1
    f78c:	18d3883a 	add	r9,r3,r3
    f790:	48c7803a 	cmpltu	r3,r9,r3
    f794:	2109883a 	add	r4,r4,r4
    f798:	190f883a 	add	r7,r3,r4
    f79c:	3191883a 	add	r8,r6,r6
    f7a0:	4197803a 	cmpltu	r11,r8,r6
    f7a4:	2955883a 	add	r10,r5,r5
    f7a8:	1019883a 	mov	r12,r2
    f7ac:	4807883a 	mov	r3,r9
    f7b0:	3809883a 	mov	r4,r7
    f7b4:	2800010e 	bge	r5,zero,f7bc <__muldf3+0x278>
    f7b8:	48c00054 	ori	r3,r9,1
    f7bc:	400d883a 	mov	r6,r8
    f7c0:	5a8b883a 	add	r5,r11,r10
    f7c4:	10bfffc4 	addi	r2,r2,-1
    f7c8:	69fff02e 	bgeu	r13,r7,f78c <__muldf3+0x248>
    f7cc:	db000215 	stw	r12,8(sp)
    f7d0:	18803fcc 	andi	r2,r3,255
    f7d4:	01c02004 	movi	r7,128
    f7d8:	11c00926 	beq	r2,r7,f800 <__muldf3+0x2bc>
    f7dc:	008000c4 	movi	r2,3
    f7e0:	d9000415 	stw	r4,16(sp)
    f7e4:	d8c00315 	stw	r3,12(sp)
    f7e8:	d8800015 	stw	r2,0(sp)
    f7ec:	d809883a 	mov	r4,sp
    f7f0:	003f7006 	br	f5b4 <__muldf3+0x70>
    f7f4:	0011883a 	mov	r8,zero
    f7f8:	00c00044 	movi	r3,1
    f7fc:	003fb606 	br	f6d8 <__muldf3+0x194>
    f800:	19c0400c 	andi	r7,r3,256
    f804:	383ff51e 	bne	r7,zero,f7dc <__muldf3+0x298>
    f808:	314ab03a 	or	r5,r6,r5
    f80c:	283ff326 	beq	r5,zero,f7dc <__muldf3+0x298>
    f810:	1885883a 	add	r2,r3,r2
    f814:	10cb803a 	cmpltu	r5,r2,r3
    f818:	00ffc004 	movi	r3,-256
    f81c:	10c6703a 	and	r3,r2,r3
    f820:	2909883a 	add	r4,r5,r4
    f824:	003fed06 	br	f7dc <__muldf3+0x298>

0000f828 <__divdf3>:
    f828:	defff104 	addi	sp,sp,-60
    f82c:	d9000c15 	stw	r4,48(sp)
    f830:	d9400d15 	stw	r5,52(sp)
    f834:	d9000c04 	addi	r4,sp,48
    f838:	d9400504 	addi	r5,sp,20
    f83c:	dfc00e15 	stw	ra,56(sp)
    f840:	d9800a15 	stw	r6,40(sp)
    f844:	d9c00b15 	stw	r7,44(sp)
    f848:	000ff600 	call	ff60 <__unpack_d>
    f84c:	d9000a04 	addi	r4,sp,40
    f850:	d80b883a 	mov	r5,sp
    f854:	000ff600 	call	ff60 <__unpack_d>
    f858:	d8c00517 	ldw	r3,20(sp)
    f85c:	00800044 	movi	r2,1
    f860:	10c00536 	bltu	r2,r3,f878 <__divdf3+0x50>
    f864:	d9000504 	addi	r4,sp,20
    f868:	000fd3c0 	call	fd3c <__pack_d>
    f86c:	dfc00e17 	ldw	ra,56(sp)
    f870:	dec00f04 	addi	sp,sp,60
    f874:	f800283a 	ret
    f878:	d9000017 	ldw	r4,0(sp)
    f87c:	11000536 	bltu	r2,r4,f894 <__divdf3+0x6c>
    f880:	d809883a 	mov	r4,sp
    f884:	000fd3c0 	call	fd3c <__pack_d>
    f888:	dfc00e17 	ldw	ra,56(sp)
    f88c:	dec00f04 	addi	sp,sp,60
    f890:	f800283a 	ret
    f894:	d9800617 	ldw	r6,24(sp)
    f898:	d9400117 	ldw	r5,4(sp)
    f89c:	00800104 	movi	r2,4
    f8a0:	314af03a 	xor	r5,r6,r5
    f8a4:	d9400615 	stw	r5,24(sp)
    f8a8:	18800226 	beq	r3,r2,f8b4 <__divdf3+0x8c>
    f8ac:	01400084 	movi	r5,2
    f8b0:	1940041e 	bne	r3,r5,f8c4 <__divdf3+0x9c>
    f8b4:	193feb1e 	bne	r3,r4,f864 <__divdf3+0x3c>
    f8b8:	010000b4 	movhi	r4,2
    f8bc:	2117e604 	addi	r4,r4,24472
    f8c0:	003fe906 	br	f868 <__divdf3+0x40>
    f8c4:	20803326 	beq	r4,r2,f994 <__divdf3+0x16c>
    f8c8:	21403726 	beq	r4,r5,f9a8 <__divdf3+0x180>
    f8cc:	d8800217 	ldw	r2,8(sp)
    f8d0:	d9000717 	ldw	r4,28(sp)
    f8d4:	d8c00917 	ldw	r3,36(sp)
    f8d8:	da000417 	ldw	r8,16(sp)
    f8dc:	2089c83a 	sub	r4,r4,r2
    f8e0:	d9000715 	stw	r4,28(sp)
    f8e4:	d8800817 	ldw	r2,32(sp)
    f8e8:	dbc00317 	ldw	r15,12(sp)
    f8ec:	1a000236 	bltu	r3,r8,f8f8 <__divdf3+0xd0>
    f8f0:	40c0081e 	bne	r8,r3,f914 <__divdf3+0xec>
    f8f4:	13c0072e 	bgeu	r2,r15,f914 <__divdf3+0xec>
    f8f8:	108b883a 	add	r5,r2,r2
    f8fc:	288d803a 	cmpltu	r6,r5,r2
    f900:	18c7883a 	add	r3,r3,r3
    f904:	213fffc4 	addi	r4,r4,-1
    f908:	2805883a 	mov	r2,r5
    f90c:	30c7883a 	add	r3,r6,r3
    f910:	d9000715 	stw	r4,28(sp)
    f914:	01400f44 	movi	r5,61
    f918:	000f883a 	mov	r7,zero
    f91c:	01040034 	movhi	r4,4096
    f920:	0019883a 	mov	r12,zero
    f924:	001b883a 	mov	r13,zero
    f928:	201697fa 	slli	r11,r4,31
    f92c:	3814d07a 	srli	r10,r7,1
    f930:	297fffc4 	addi	r5,r5,-1
    f934:	1a000936 	bltu	r3,r8,f95c <__divdf3+0x134>
    f938:	13cdc83a 	sub	r6,r2,r15
    f93c:	1193803a 	cmpltu	r9,r2,r6
    f940:	1a1dc83a 	sub	r14,r3,r8
    f944:	40c0011e 	bne	r8,r3,f94c <__divdf3+0x124>
    f948:	13c00436 	bltu	r2,r15,f95c <__divdf3+0x134>
    f94c:	3005883a 	mov	r2,r6
    f950:	7247c83a 	sub	r3,r14,r9
    f954:	61d8b03a 	or	r12,r12,r7
    f958:	691ab03a 	or	r13,r13,r4
    f95c:	108d883a 	add	r6,r2,r2
    f960:	3093803a 	cmpltu	r9,r6,r2
    f964:	18c7883a 	add	r3,r3,r3
    f968:	5a8eb03a 	or	r7,r11,r10
    f96c:	2008d07a 	srli	r4,r4,1
    f970:	3005883a 	mov	r2,r6
    f974:	48c7883a 	add	r3,r9,r3
    f978:	283feb1e 	bne	r5,zero,f928 <__divdf3+0x100>
    f97c:	61003fcc 	andi	r4,r12,255
    f980:	01402004 	movi	r5,128
    f984:	21400b26 	beq	r4,r5,f9b4 <__divdf3+0x18c>
    f988:	db000815 	stw	r12,32(sp)
    f98c:	db400915 	stw	r13,36(sp)
    f990:	003fb406 	br	f864 <__divdf3+0x3c>
    f994:	d8000815 	stw	zero,32(sp)
    f998:	d8000915 	stw	zero,36(sp)
    f99c:	d8000715 	stw	zero,28(sp)
    f9a0:	d9000504 	addi	r4,sp,20
    f9a4:	003fb006 	br	f868 <__divdf3+0x40>
    f9a8:	d8800515 	stw	r2,20(sp)
    f9ac:	d9000504 	addi	r4,sp,20
    f9b0:	003fad06 	br	f868 <__divdf3+0x40>
    f9b4:	6140400c 	andi	r5,r12,256
    f9b8:	283ff31e 	bne	r5,zero,f988 <__divdf3+0x160>
    f9bc:	30c4b03a 	or	r2,r6,r3
    f9c0:	103ff126 	beq	r2,zero,f988 <__divdf3+0x160>
    f9c4:	6109883a 	add	r4,r12,r4
    f9c8:	2305803a 	cmpltu	r2,r4,r12
    f9cc:	033fc004 	movi	r12,-256
    f9d0:	2318703a 	and	r12,r4,r12
    f9d4:	135b883a 	add	r13,r2,r13
    f9d8:	003feb06 	br	f988 <__divdf3+0x160>

0000f9dc <__gedf2>:
    f9dc:	defff104 	addi	sp,sp,-60
    f9e0:	d9000c15 	stw	r4,48(sp)
    f9e4:	d9400d15 	stw	r5,52(sp)
    f9e8:	d9000c04 	addi	r4,sp,48
    f9ec:	d9400504 	addi	r5,sp,20
    f9f0:	dfc00e15 	stw	ra,56(sp)
    f9f4:	d9800a15 	stw	r6,40(sp)
    f9f8:	d9c00b15 	stw	r7,44(sp)
    f9fc:	000ff600 	call	ff60 <__unpack_d>
    fa00:	d9000a04 	addi	r4,sp,40
    fa04:	d80b883a 	mov	r5,sp
    fa08:	000ff600 	call	ff60 <__unpack_d>
    fa0c:	d8c00517 	ldw	r3,20(sp)
    fa10:	00800044 	movi	r2,1
    fa14:	10c0082e 	bgeu	r2,r3,fa38 <__gedf2+0x5c>
    fa18:	d8c00017 	ldw	r3,0(sp)
    fa1c:	10c0062e 	bgeu	r2,r3,fa38 <__gedf2+0x5c>
    fa20:	d9000504 	addi	r4,sp,20
    fa24:	d80b883a 	mov	r5,sp
    fa28:	00100640 	call	10064 <__fpcmp_parts_d>
    fa2c:	dfc00e17 	ldw	ra,56(sp)
    fa30:	dec00f04 	addi	sp,sp,60
    fa34:	f800283a 	ret
    fa38:	00bfffc4 	movi	r2,-1
    fa3c:	003ffb06 	br	fa2c <__gedf2+0x50>

0000fa40 <__fixdfsi>:
    fa40:	defff804 	addi	sp,sp,-32
    fa44:	d9000515 	stw	r4,20(sp)
    fa48:	d9400615 	stw	r5,24(sp)
    fa4c:	d9000504 	addi	r4,sp,20
    fa50:	d80b883a 	mov	r5,sp
    fa54:	dfc00715 	stw	ra,28(sp)
    fa58:	000ff600 	call	ff60 <__unpack_d>
    fa5c:	d8800017 	ldw	r2,0(sp)
    fa60:	00c00084 	movi	r3,2
    fa64:	10c01c26 	beq	r2,r3,fad8 <__fixdfsi+0x98>
    fa68:	00c00044 	movi	r3,1
    fa6c:	18801a2e 	bgeu	r3,r2,fad8 <__fixdfsi+0x98>
    fa70:	00c00104 	movi	r3,4
    fa74:	10c01126 	beq	r2,r3,fabc <__fixdfsi+0x7c>
    fa78:	d8800217 	ldw	r2,8(sp)
    fa7c:	10001616 	blt	r2,zero,fad8 <__fixdfsi+0x98>
    fa80:	00c00784 	movi	r3,30
    fa84:	18800d16 	blt	r3,r2,fabc <__fixdfsi+0x7c>
    fa88:	00c00f04 	movi	r3,60
    fa8c:	1885c83a 	sub	r2,r3,r2
    fa90:	10fff804 	addi	r3,r2,-32
    fa94:	d9400317 	ldw	r5,12(sp)
    fa98:	d9000417 	ldw	r4,16(sp)
    fa9c:	18001616 	blt	r3,zero,faf8 <__fixdfsi+0xb8>
    faa0:	20c4d83a 	srl	r2,r4,r3
    faa4:	d8c00117 	ldw	r3,4(sp)
    faa8:	18000126 	beq	r3,zero,fab0 <__fixdfsi+0x70>
    faac:	0085c83a 	sub	r2,zero,r2
    fab0:	dfc00717 	ldw	ra,28(sp)
    fab4:	dec00804 	addi	sp,sp,32
    fab8:	f800283a 	ret
    fabc:	d8800117 	ldw	r2,4(sp)
    fac0:	1000091e 	bne	r2,zero,fae8 <__fixdfsi+0xa8>
    fac4:	00a00034 	movhi	r2,32768
    fac8:	10bfffc4 	addi	r2,r2,-1
    facc:	dfc00717 	ldw	ra,28(sp)
    fad0:	dec00804 	addi	sp,sp,32
    fad4:	f800283a 	ret
    fad8:	0005883a 	mov	r2,zero
    fadc:	dfc00717 	ldw	ra,28(sp)
    fae0:	dec00804 	addi	sp,sp,32
    fae4:	f800283a 	ret
    fae8:	00a00034 	movhi	r2,32768
    faec:	dfc00717 	ldw	ra,28(sp)
    faf0:	dec00804 	addi	sp,sp,32
    faf4:	f800283a 	ret
    faf8:	2008907a 	slli	r4,r4,1
    fafc:	018007c4 	movi	r6,31
    fb00:	308dc83a 	sub	r6,r6,r2
    fb04:	2188983a 	sll	r4,r4,r6
    fb08:	2884d83a 	srl	r2,r5,r2
    fb0c:	2084b03a 	or	r2,r4,r2
    fb10:	003fe406 	br	faa4 <__fixdfsi+0x64>

0000fb14 <__floatunsidf>:
    fb14:	defff904 	addi	sp,sp,-28
    fb18:	dc000515 	stw	r16,20(sp)
    fb1c:	dfc00615 	stw	ra,24(sp)
    fb20:	d8000115 	stw	zero,4(sp)
    fb24:	2021883a 	mov	r16,r4
    fb28:	20001726 	beq	r4,zero,fb88 <__floatunsidf+0x74>
    fb2c:	008000c4 	movi	r2,3
    fb30:	d8800015 	stw	r2,0(sp)
    fb34:	00800f04 	movi	r2,60
    fb38:	d8800215 	stw	r2,8(sp)
    fb3c:	000fc900 	call	fc90 <__clzsi2>
    fb40:	10c00744 	addi	r3,r2,29
    fb44:	18001816 	blt	r3,zero,fba8 <__floatunsidf+0x94>
    fb48:	18002d26 	beq	r3,zero,fc00 <__floatunsidf+0xec>
    fb4c:	113fff44 	addi	r4,r2,-3
    fb50:	20002e16 	blt	r4,zero,fc0c <__floatunsidf+0xf8>
    fb54:	8108983a 	sll	r4,r16,r4
    fb58:	0021883a 	mov	r16,zero
    fb5c:	014007c4 	movi	r5,31
    fb60:	2885c83a 	sub	r2,r5,r2
    fb64:	dc000315 	stw	r16,12(sp)
    fb68:	d9000415 	stw	r4,16(sp)
    fb6c:	d8800215 	stw	r2,8(sp)
    fb70:	d809883a 	mov	r4,sp
    fb74:	000fd3c0 	call	fd3c <__pack_d>
    fb78:	dfc00617 	ldw	ra,24(sp)
    fb7c:	dc000517 	ldw	r16,20(sp)
    fb80:	dec00704 	addi	sp,sp,28
    fb84:	f800283a 	ret
    fb88:	00800084 	movi	r2,2
    fb8c:	d809883a 	mov	r4,sp
    fb90:	d8800015 	stw	r2,0(sp)
    fb94:	000fd3c0 	call	fd3c <__pack_d>
    fb98:	dfc00617 	ldw	ra,24(sp)
    fb9c:	dc000517 	ldw	r16,20(sp)
    fba0:	dec00704 	addi	sp,sp,28
    fba4:	f800283a 	ret
    fba8:	00c7c83a 	sub	r3,zero,r3
    fbac:	193ff804 	addi	r4,r3,-32
    fbb0:	20001c16 	blt	r4,zero,fc24 <__floatunsidf+0x110>
    fbb4:	000b883a 	mov	r5,zero
    fbb8:	2009d7fa 	srai	r4,r4,31
    fbbc:	80c6d83a 	srl	r3,r16,r3
    fbc0:	297fffc4 	addi	r5,r5,-1
    fbc4:	2c20703a 	and	r16,r5,r16
    fbc8:	8020c03a 	cmpne	r16,r16,zero
    fbcc:	1906703a 	and	r3,r3,r4
    fbd0:	010007c4 	movi	r4,31
    fbd4:	80c6b03a 	or	r3,r16,r3
    fbd8:	2085c83a 	sub	r2,r4,r2
    fbdc:	d809883a 	mov	r4,sp
    fbe0:	d8c00315 	stw	r3,12(sp)
    fbe4:	d8000415 	stw	zero,16(sp)
    fbe8:	d8800215 	stw	r2,8(sp)
    fbec:	000fd3c0 	call	fd3c <__pack_d>
    fbf0:	dfc00617 	ldw	ra,24(sp)
    fbf4:	dc000517 	ldw	r16,20(sp)
    fbf8:	dec00704 	addi	sp,sp,28
    fbfc:	f800283a 	ret
    fc00:	dc000315 	stw	r16,12(sp)
    fc04:	d8000415 	stw	zero,16(sp)
    fc08:	003fd906 	br	fb70 <__floatunsidf+0x5c>
    fc0c:	800ad07a 	srli	r5,r16,1
    fc10:	010007c4 	movi	r4,31
    fc14:	20c9c83a 	sub	r4,r4,r3
    fc18:	2908d83a 	srl	r4,r5,r4
    fc1c:	80e0983a 	sll	r16,r16,r3
    fc20:	003fce06 	br	fb5c <__floatunsidf+0x48>
    fc24:	01400044 	movi	r5,1
    fc28:	28ca983a 	sll	r5,r5,r3
    fc2c:	003fe206 	br	fbb8 <__floatunsidf+0xa4>

0000fc30 <__muldi3>:
    fc30:	20bfffcc 	andi	r2,r4,65535
    fc34:	2010d43a 	srli	r8,r4,16
    fc38:	30ffffcc 	andi	r3,r6,65535
    fc3c:	3014d43a 	srli	r10,r6,16
    fc40:	1893383a 	mul	r9,r3,r2
    fc44:	1a07383a 	mul	r3,r3,r8
    fc48:	5085383a 	mul	r2,r10,r2
    fc4c:	4816d43a 	srli	r11,r9,16
    fc50:	5211383a 	mul	r8,r10,r8
    fc54:	1885883a 	add	r2,r3,r2
    fc58:	12c5883a 	add	r2,r2,r11
    fc5c:	10c0022e 	bgeu	r2,r3,fc68 <__muldi3+0x38>
    fc60:	00c00074 	movhi	r3,1
    fc64:	40d1883a 	add	r8,r8,r3
    fc68:	1014d43a 	srli	r10,r2,16
    fc6c:	21c9383a 	mul	r4,r4,r7
    fc70:	314d383a 	mul	r6,r6,r5
    fc74:	1004943a 	slli	r2,r2,16
    fc78:	4291883a 	add	r8,r8,r10
    fc7c:	4a7fffcc 	andi	r9,r9,65535
    fc80:	2187883a 	add	r3,r4,r6
    fc84:	1245883a 	add	r2,r2,r9
    fc88:	1a07883a 	add	r3,r3,r8
    fc8c:	f800283a 	ret

0000fc90 <__clzsi2>:
    fc90:	00bfffd4 	movui	r2,65535
    fc94:	11000b36 	bltu	r2,r4,fcc4 <__clzsi2+0x34>
    fc98:	00803fc4 	movi	r2,255
    fc9c:	11001e2e 	bgeu	r2,r4,fd18 <__clzsi2+0x88>
    fca0:	00c00204 	movi	r3,8
    fca4:	20c8d83a 	srl	r4,r4,r3
    fca8:	00c000b4 	movhi	r3,2
    fcac:	18d7eb04 	addi	r3,r3,24492
    fcb0:	00800604 	movi	r2,24
    fcb4:	1909883a 	add	r4,r3,r4
    fcb8:	20c00003 	ldbu	r3,0(r4)
    fcbc:	10c5c83a 	sub	r2,r2,r3
    fcc0:	f800283a 	ret
    fcc4:	00804034 	movhi	r2,256
    fcc8:	10bfffc4 	addi	r2,r2,-1
    fccc:	11000936 	bltu	r2,r4,fcf4 <__clzsi2+0x64>
    fcd0:	00800404 	movi	r2,16
    fcd4:	1007883a 	mov	r3,r2
    fcd8:	20c8d83a 	srl	r4,r4,r3
    fcdc:	00c000b4 	movhi	r3,2
    fce0:	18d7eb04 	addi	r3,r3,24492
    fce4:	1909883a 	add	r4,r3,r4
    fce8:	20c00003 	ldbu	r3,0(r4)
    fcec:	10c5c83a 	sub	r2,r2,r3
    fcf0:	f800283a 	ret
    fcf4:	00c00604 	movi	r3,24
    fcf8:	20c8d83a 	srl	r4,r4,r3
    fcfc:	00c000b4 	movhi	r3,2
    fd00:	18d7eb04 	addi	r3,r3,24492
    fd04:	00800204 	movi	r2,8
    fd08:	1909883a 	add	r4,r3,r4
    fd0c:	20c00003 	ldbu	r3,0(r4)
    fd10:	10c5c83a 	sub	r2,r2,r3
    fd14:	f800283a 	ret
    fd18:	0007883a 	mov	r3,zero
    fd1c:	20c8d83a 	srl	r4,r4,r3
    fd20:	00c000b4 	movhi	r3,2
    fd24:	18d7eb04 	addi	r3,r3,24492
    fd28:	00800804 	movi	r2,32
    fd2c:	1909883a 	add	r4,r3,r4
    fd30:	20c00003 	ldbu	r3,0(r4)
    fd34:	10c5c83a 	sub	r2,r2,r3
    fd38:	f800283a 	ret

0000fd3c <__pack_d>:
    fd3c:	20800017 	ldw	r2,0(r4)
    fd40:	defff804 	addi	sp,sp,-32
    fd44:	dcc00315 	stw	r19,12(sp)
    fd48:	dc800215 	stw	r18,8(sp)
    fd4c:	dfc00715 	stw	ra,28(sp)
    fd50:	dd800615 	stw	r22,24(sp)
    fd54:	dd400515 	stw	r21,20(sp)
    fd58:	dd000415 	stw	r20,16(sp)
    fd5c:	dc400115 	stw	r17,4(sp)
    fd60:	dc000015 	stw	r16,0(sp)
    fd64:	04800044 	movi	r18,1
    fd68:	24400317 	ldw	r17,12(r4)
    fd6c:	24000417 	ldw	r16,16(r4)
    fd70:	24c00117 	ldw	r19,4(r4)
    fd74:	9080422e 	bgeu	r18,r2,fe80 <__pack_d+0x144>
    fd78:	00c00104 	movi	r3,4
    fd7c:	10c03c26 	beq	r2,r3,fe70 <__pack_d+0x134>
    fd80:	00c00084 	movi	r3,2
    fd84:	10c01926 	beq	r2,r3,fdec <__pack_d+0xb0>
    fd88:	8c04b03a 	or	r2,r17,r16
    fd8c:	10001726 	beq	r2,zero,fdec <__pack_d+0xb0>
    fd90:	21000217 	ldw	r4,8(r4)
    fd94:	00bf0084 	movi	r2,-1022
    fd98:	20804016 	blt	r4,r2,fe9c <__pack_d+0x160>
    fd9c:	0080ffc4 	movi	r2,1023
    fda0:	11003316 	blt	r2,r4,fe70 <__pack_d+0x134>
    fda4:	88803fcc 	andi	r2,r17,255
    fda8:	00c02004 	movi	r3,128
    fdac:	10c02926 	beq	r2,r3,fe54 <__pack_d+0x118>
    fdb0:	88801fc4 	addi	r2,r17,127
    fdb4:	1463803a 	cmpltu	r17,r2,r17
    fdb8:	8c21883a 	add	r16,r17,r16
    fdbc:	1023883a 	mov	r17,r2
    fdc0:	00880034 	movhi	r2,8192
    fdc4:	10bfffc4 	addi	r2,r2,-1
    fdc8:	14001c36 	bltu	r2,r16,fe3c <__pack_d+0x100>
    fdcc:	2100ffc4 	addi	r4,r4,1023
    fdd0:	8006963a 	slli	r3,r16,24
    fdd4:	8804d23a 	srli	r2,r17,8
    fdd8:	8020913a 	slli	r16,r16,4
    fddc:	2101ffcc 	andi	r4,r4,2047
    fde0:	1884b03a 	or	r2,r3,r2
    fde4:	8020d33a 	srli	r16,r16,12
    fde8:	00000306 	br	fdf8 <__pack_d+0xbc>
    fdec:	0009883a 	mov	r4,zero
    fdf0:	0005883a 	mov	r2,zero
    fdf4:	0021883a 	mov	r16,zero
    fdf8:	2008953a 	slli	r4,r4,20
    fdfc:	982697fa 	slli	r19,r19,31
    fe00:	00c00434 	movhi	r3,16
    fe04:	18ffffc4 	addi	r3,r3,-1
    fe08:	80e0703a 	and	r16,r16,r3
    fe0c:	8106b03a 	or	r3,r16,r4
    fe10:	1cc6b03a 	or	r3,r3,r19
    fe14:	dfc00717 	ldw	ra,28(sp)
    fe18:	dd800617 	ldw	r22,24(sp)
    fe1c:	dd400517 	ldw	r21,20(sp)
    fe20:	dd000417 	ldw	r20,16(sp)
    fe24:	dcc00317 	ldw	r19,12(sp)
    fe28:	dc800217 	ldw	r18,8(sp)
    fe2c:	dc400117 	ldw	r17,4(sp)
    fe30:	dc000017 	ldw	r16,0(sp)
    fe34:	dec00804 	addi	sp,sp,32
    fe38:	f800283a 	ret
    fe3c:	800697fa 	slli	r3,r16,31
    fe40:	8804d07a 	srli	r2,r17,1
    fe44:	21010004 	addi	r4,r4,1024
    fe48:	8020d07a 	srli	r16,r16,1
    fe4c:	18a2b03a 	or	r17,r3,r2
    fe50:	003fdf06 	br	fdd0 <__pack_d+0x94>
    fe54:	88c0400c 	andi	r3,r17,256
    fe58:	183fd926 	beq	r3,zero,fdc0 <__pack_d+0x84>
    fe5c:	8885883a 	add	r2,r17,r2
    fe60:	1463803a 	cmpltu	r17,r2,r17
    fe64:	8c21883a 	add	r16,r17,r16
    fe68:	1023883a 	mov	r17,r2
    fe6c:	003fd406 	br	fdc0 <__pack_d+0x84>
    fe70:	0101ffc4 	movi	r4,2047
    fe74:	0005883a 	mov	r2,zero
    fe78:	0021883a 	mov	r16,zero
    fe7c:	003fde06 	br	fdf8 <__pack_d+0xbc>
    fe80:	84000234 	orhi	r16,r16,8
    fe84:	00c00434 	movhi	r3,16
    fe88:	18ffffc4 	addi	r3,r3,-1
    fe8c:	8805883a 	mov	r2,r17
    fe90:	80e0703a 	and	r16,r16,r3
    fe94:	0101ffc4 	movi	r4,2047
    fe98:	003fd706 	br	fdf8 <__pack_d+0xbc>
    fe9c:	1129c83a 	sub	r20,r2,r4
    fea0:	00800e04 	movi	r2,56
    fea4:	15002716 	blt	r2,r20,ff44 <__pack_d+0x208>
    fea8:	800b883a 	mov	r5,r16
    feac:	a00d883a 	mov	r6,r20
    feb0:	8809883a 	mov	r4,r17
    feb4:	00101340 	call	10134 <__lshrdi3>
    feb8:	9009883a 	mov	r4,r18
    febc:	000b883a 	mov	r5,zero
    fec0:	a00d883a 	mov	r6,r20
    fec4:	102d883a 	mov	r22,r2
    fec8:	182b883a 	mov	r21,r3
    fecc:	00101780 	call	10178 <__ashldi3>
    fed0:	1009003a 	cmpeq	r4,r2,zero
    fed4:	1907c83a 	sub	r3,r3,r4
    fed8:	10bfffc4 	addi	r2,r2,-1
    fedc:	1c20703a 	and	r16,r3,r16
    fee0:	1444703a 	and	r2,r2,r17
    fee4:	1404b03a 	or	r2,r2,r16
    fee8:	1004c03a 	cmpne	r2,r2,zero
    feec:	1584b03a 	or	r2,r2,r22
    fef0:	11003fcc 	andi	r4,r2,255
    fef4:	01402004 	movi	r5,128
    fef8:	a807883a 	mov	r3,r21
    fefc:	2140131e 	bne	r4,r5,ff4c <__pack_d+0x210>
    ff00:	1140400c 	andi	r5,r2,256
    ff04:	28000426 	beq	r5,zero,ff18 <__pack_d+0x1dc>
    ff08:	1109883a 	add	r4,r2,r4
    ff0c:	2085803a 	cmpltu	r2,r4,r2
    ff10:	1547883a 	add	r3,r2,r21
    ff14:	2005883a 	mov	r2,r4
    ff18:	1808963a 	slli	r4,r3,24
    ff1c:	1004d23a 	srli	r2,r2,8
    ff20:	1820913a 	slli	r16,r3,4
    ff24:	01440034 	movhi	r5,4096
    ff28:	297fffc4 	addi	r5,r5,-1
    ff2c:	2084b03a 	or	r2,r4,r2
    ff30:	8020d33a 	srli	r16,r16,12
    ff34:	01000044 	movi	r4,1
    ff38:	28ffaf36 	bltu	r5,r3,fdf8 <__pack_d+0xbc>
    ff3c:	0009883a 	mov	r4,zero
    ff40:	003fad06 	br	fdf8 <__pack_d+0xbc>
    ff44:	0005883a 	mov	r2,zero
    ff48:	0007883a 	mov	r3,zero
    ff4c:	11001fc4 	addi	r4,r2,127
    ff50:	2085803a 	cmpltu	r2,r4,r2
    ff54:	10c7883a 	add	r3,r2,r3
    ff58:	2005883a 	mov	r2,r4
    ff5c:	003fee06 	br	ff18 <__pack_d+0x1dc>

0000ff60 <__unpack_d>:
    ff60:	21800117 	ldw	r6,4(r4)
    ff64:	20c00017 	ldw	r3,0(r4)
    ff68:	3004d7fa 	srli	r2,r6,31
    ff6c:	3008d53a 	srli	r4,r6,20
    ff70:	28800115 	stw	r2,4(r5)
    ff74:	2101ffcc 	andi	r4,r4,2047
    ff78:	00800434 	movhi	r2,16
    ff7c:	10bfffc4 	addi	r2,r2,-1
    ff80:	3084703a 	and	r2,r6,r2
    ff84:	20001a1e 	bne	r4,zero,fff0 <__unpack_d+0x90>
    ff88:	1888b03a 	or	r4,r3,r2
    ff8c:	20002626 	beq	r4,zero,10028 <__unpack_d+0xc8>
    ff90:	1808d63a 	srli	r4,r3,24
    ff94:	1004923a 	slli	r2,r2,8
    ff98:	01bf0084 	movi	r6,-1022
    ff9c:	29800215 	stw	r6,8(r5)
    ffa0:	2084b03a 	or	r2,r4,r2
    ffa4:	010000c4 	movi	r4,3
    ffa8:	29000015 	stw	r4,0(r5)
    ffac:	02040034 	movhi	r8,4096
    ffb0:	423fffc4 	addi	r8,r8,-1
    ffb4:	1806923a 	slli	r3,r3,8
    ffb8:	40801836 	bltu	r8,r2,1001c <__unpack_d+0xbc>
    ffbc:	013f0044 	movi	r4,-1023
    ffc0:	18cd883a 	add	r6,r3,r3
    ffc4:	30c7803a 	cmpltu	r3,r6,r3
    ffc8:	1085883a 	add	r2,r2,r2
    ffcc:	1885883a 	add	r2,r3,r2
    ffd0:	200f883a 	mov	r7,r4
    ffd4:	3007883a 	mov	r3,r6
    ffd8:	213fffc4 	addi	r4,r4,-1
    ffdc:	40bff82e 	bgeu	r8,r2,ffc0 <__unpack_d+0x60>
    ffe0:	29c00215 	stw	r7,8(r5)
    ffe4:	28c00315 	stw	r3,12(r5)
    ffe8:	28800415 	stw	r2,16(r5)
    ffec:	f800283a 	ret
    fff0:	01c1ffc4 	movi	r7,2047
    fff4:	21c00f26 	beq	r4,r7,10034 <__unpack_d+0xd4>
    fff8:	180cd63a 	srli	r6,r3,24
    fffc:	1004923a 	slli	r2,r2,8
   10000:	213f0044 	addi	r4,r4,-1023
   10004:	1806923a 	slli	r3,r3,8
   10008:	3084b03a 	or	r2,r6,r2
   1000c:	29000215 	stw	r4,8(r5)
   10010:	010000c4 	movi	r4,3
   10014:	10840034 	orhi	r2,r2,4096
   10018:	29000015 	stw	r4,0(r5)
   1001c:	28c00315 	stw	r3,12(r5)
   10020:	28800415 	stw	r2,16(r5)
   10024:	f800283a 	ret
   10028:	00800084 	movi	r2,2
   1002c:	28800015 	stw	r2,0(r5)
   10030:	f800283a 	ret
   10034:	1888b03a 	or	r4,r3,r2
   10038:	20000526 	beq	r4,zero,10050 <__unpack_d+0xf0>
   1003c:	3180022c 	andhi	r6,r6,8
   10040:	30000626 	beq	r6,zero,1005c <__unpack_d+0xfc>
   10044:	01000044 	movi	r4,1
   10048:	29000015 	stw	r4,0(r5)
   1004c:	003ff306 	br	1001c <__unpack_d+0xbc>
   10050:	00800104 	movi	r2,4
   10054:	28800015 	stw	r2,0(r5)
   10058:	f800283a 	ret
   1005c:	28000015 	stw	zero,0(r5)
   10060:	003fee06 	br	1001c <__unpack_d+0xbc>

00010064 <__fpcmp_parts_d>:
   10064:	20c00017 	ldw	r3,0(r4)
   10068:	00800044 	movi	r2,1
   1006c:	10c0142e 	bgeu	r2,r3,100c0 <__fpcmp_parts_d+0x5c>
   10070:	29800017 	ldw	r6,0(r5)
   10074:	1180122e 	bgeu	r2,r6,100c0 <__fpcmp_parts_d+0x5c>
   10078:	01c00104 	movi	r7,4
   1007c:	19c02826 	beq	r3,r7,10120 <__fpcmp_parts_d+0xbc>
   10080:	31c00926 	beq	r6,r7,100a8 <__fpcmp_parts_d+0x44>
   10084:	01c00084 	movi	r7,2
   10088:	19c00626 	beq	r3,r7,100a4 <__fpcmp_parts_d+0x40>
   1008c:	31c00a26 	beq	r6,r7,100b8 <__fpcmp_parts_d+0x54>
   10090:	20c00117 	ldw	r3,4(r4)
   10094:	29800117 	ldw	r6,4(r5)
   10098:	19800b26 	beq	r3,r6,100c8 <__fpcmp_parts_d+0x64>
   1009c:	1800041e 	bne	r3,zero,100b0 <__fpcmp_parts_d+0x4c>
   100a0:	f800283a 	ret
   100a4:	30c01a26 	beq	r6,r3,10110 <__fpcmp_parts_d+0xac>
   100a8:	28800117 	ldw	r2,4(r5)
   100ac:	1000041e 	bne	r2,zero,100c0 <__fpcmp_parts_d+0x5c>
   100b0:	00bfffc4 	movi	r2,-1
   100b4:	f800283a 	ret
   100b8:	20800117 	ldw	r2,4(r4)
   100bc:	103ffc1e 	bne	r2,zero,100b0 <__fpcmp_parts_d+0x4c>
   100c0:	00800044 	movi	r2,1
   100c4:	f800283a 	ret
   100c8:	21c00217 	ldw	r7,8(r4)
   100cc:	29800217 	ldw	r6,8(r5)
   100d0:	31c0020e 	bge	r6,r7,100dc <__fpcmp_parts_d+0x78>
   100d4:	183ff61e 	bne	r3,zero,100b0 <__fpcmp_parts_d+0x4c>
   100d8:	f800283a 	ret
   100dc:	39800a16 	blt	r7,r6,10108 <__fpcmp_parts_d+0xa4>
   100e0:	20800417 	ldw	r2,16(r4)
   100e4:	29800417 	ldw	r6,16(r5)
   100e8:	21c00317 	ldw	r7,12(r4)
   100ec:	29000317 	ldw	r4,12(r5)
   100f0:	30800936 	bltu	r6,r2,10118 <__fpcmp_parts_d+0xb4>
   100f4:	1180011e 	bne	r2,r6,100fc <__fpcmp_parts_d+0x98>
   100f8:	21c00736 	bltu	r4,r7,10118 <__fpcmp_parts_d+0xb4>
   100fc:	11800236 	bltu	r2,r6,10108 <__fpcmp_parts_d+0xa4>
   10100:	3080031e 	bne	r6,r2,10110 <__fpcmp_parts_d+0xac>
   10104:	3900022e 	bgeu	r7,r4,10110 <__fpcmp_parts_d+0xac>
   10108:	183fe926 	beq	r3,zero,100b0 <__fpcmp_parts_d+0x4c>
   1010c:	003fec06 	br	100c0 <__fpcmp_parts_d+0x5c>
   10110:	0005883a 	mov	r2,zero
   10114:	f800283a 	ret
   10118:	183fe926 	beq	r3,zero,100c0 <__fpcmp_parts_d+0x5c>
   1011c:	003fe406 	br	100b0 <__fpcmp_parts_d+0x4c>
   10120:	30ffe51e 	bne	r6,r3,100b8 <__fpcmp_parts_d+0x54>
   10124:	28c00117 	ldw	r3,4(r5)
   10128:	20800117 	ldw	r2,4(r4)
   1012c:	1885c83a 	sub	r2,r3,r2
   10130:	f800283a 	ret

00010134 <__lshrdi3>:
   10134:	2005883a 	mov	r2,r4
   10138:	2807883a 	mov	r3,r5
   1013c:	30000826 	beq	r6,zero,10160 <__lshrdi3+0x2c>
   10140:	01000804 	movi	r4,32
   10144:	2189c83a 	sub	r4,r4,r6
   10148:	0100060e 	bge	zero,r4,10164 <__lshrdi3+0x30>
   1014c:	1184d83a 	srl	r2,r2,r6
   10150:	2908983a 	sll	r4,r5,r4
   10154:	298cd83a 	srl	r6,r5,r6
   10158:	2084b03a 	or	r2,r4,r2
   1015c:	3007883a 	mov	r3,r6
   10160:	f800283a 	ret
   10164:	0105c83a 	sub	r2,zero,r4
   10168:	000d883a 	mov	r6,zero
   1016c:	2884d83a 	srl	r2,r5,r2
   10170:	3007883a 	mov	r3,r6
   10174:	003ffa06 	br	10160 <__lshrdi3+0x2c>

00010178 <__ashldi3>:
   10178:	2005883a 	mov	r2,r4
   1017c:	2807883a 	mov	r3,r5
   10180:	30000826 	beq	r6,zero,101a4 <__ashldi3+0x2c>
   10184:	01000804 	movi	r4,32
   10188:	2189c83a 	sub	r4,r4,r6
   1018c:	0100060e 	bge	zero,r4,101a8 <__ashldi3+0x30>
   10190:	1108d83a 	srl	r4,r2,r4
   10194:	2986983a 	sll	r3,r5,r6
   10198:	118c983a 	sll	r6,r2,r6
   1019c:	20c6b03a 	or	r3,r4,r3
   101a0:	3005883a 	mov	r2,r6
   101a4:	f800283a 	ret
   101a8:	0107c83a 	sub	r3,zero,r4
   101ac:	000d883a 	mov	r6,zero
   101b0:	10c6983a 	sll	r3,r2,r3
   101b4:	3005883a 	mov	r2,r6
   101b8:	003ffa06 	br	101a4 <__ashldi3+0x2c>

000101bc <memcmp>:
   101bc:	01c000c4 	movi	r7,3
   101c0:	3980192e 	bgeu	r7,r6,10228 <memcmp+0x6c>
   101c4:	2904b03a 	or	r2,r5,r4
   101c8:	11c4703a 	and	r2,r2,r7
   101cc:	10000f26 	beq	r2,zero,1020c <memcmp+0x50>
   101d0:	20c00003 	ldbu	r3,0(r4)
   101d4:	28800003 	ldbu	r2,0(r5)
   101d8:	1880151e 	bne	r3,r2,10230 <memcmp+0x74>
   101dc:	31bfff84 	addi	r6,r6,-2
   101e0:	01ffffc4 	movi	r7,-1
   101e4:	00000406 	br	101f8 <memcmp+0x3c>
   101e8:	20c00003 	ldbu	r3,0(r4)
   101ec:	28800003 	ldbu	r2,0(r5)
   101f0:	31bfffc4 	addi	r6,r6,-1
   101f4:	18800e1e 	bne	r3,r2,10230 <memcmp+0x74>
   101f8:	21000044 	addi	r4,r4,1
   101fc:	29400044 	addi	r5,r5,1
   10200:	31fff91e 	bne	r6,r7,101e8 <memcmp+0x2c>
   10204:	0005883a 	mov	r2,zero
   10208:	f800283a 	ret
   1020c:	20c00017 	ldw	r3,0(r4)
   10210:	28800017 	ldw	r2,0(r5)
   10214:	1880041e 	bne	r3,r2,10228 <memcmp+0x6c>
   10218:	31bfff04 	addi	r6,r6,-4
   1021c:	21000104 	addi	r4,r4,4
   10220:	29400104 	addi	r5,r5,4
   10224:	39bff936 	bltu	r7,r6,1020c <memcmp+0x50>
   10228:	303fe91e 	bne	r6,zero,101d0 <memcmp+0x14>
   1022c:	003ff506 	br	10204 <memcmp+0x48>
   10230:	1885c83a 	sub	r2,r3,r2
   10234:	f800283a 	ret

00010238 <memcpy>:
   10238:	00c003c4 	movi	r3,15
   1023c:	2005883a 	mov	r2,r4
   10240:	3009883a 	mov	r4,r6
   10244:	1980032e 	bgeu	r3,r6,10254 <memcpy+0x1c>
   10248:	2886b03a 	or	r3,r5,r2
   1024c:	18c000cc 	andi	r3,r3,3
   10250:	18000926 	beq	r3,zero,10278 <memcpy+0x40>
   10254:	1007883a 	mov	r3,r2
   10258:	290f883a 	add	r7,r5,r4
   1025c:	20000526 	beq	r4,zero,10274 <memcpy+0x3c>
   10260:	29800003 	ldbu	r6,0(r5)
   10264:	18c00044 	addi	r3,r3,1
   10268:	29400044 	addi	r5,r5,1
   1026c:	19bfffc5 	stb	r6,-1(r3)
   10270:	29fffb1e 	bne	r5,r7,10260 <memcpy+0x28>
   10274:	f800283a 	ret
   10278:	327ffc04 	addi	r9,r6,-16
   1027c:	4812d13a 	srli	r9,r9,4
   10280:	11000404 	addi	r4,r2,16
   10284:	1007883a 	mov	r3,r2
   10288:	4810913a 	slli	r8,r9,4
   1028c:	280f883a 	mov	r7,r5
   10290:	2209883a 	add	r4,r4,r8
   10294:	3a000017 	ldw	r8,0(r7)
   10298:	18c00404 	addi	r3,r3,16
   1029c:	39c00404 	addi	r7,r7,16
   102a0:	1a3ffc15 	stw	r8,-16(r3)
   102a4:	3a3ffd17 	ldw	r8,-12(r7)
   102a8:	1a3ffd15 	stw	r8,-12(r3)
   102ac:	3a3ffe17 	ldw	r8,-8(r7)
   102b0:	1a3ffe15 	stw	r8,-8(r3)
   102b4:	3a3fff17 	ldw	r8,-4(r7)
   102b8:	1a3fff15 	stw	r8,-4(r3)
   102bc:	193ff51e 	bne	r3,r4,10294 <memcpy+0x5c>
   102c0:	49c00044 	addi	r7,r9,1
   102c4:	380e913a 	slli	r7,r7,4
   102c8:	310003cc 	andi	r4,r6,15
   102cc:	018000c4 	movi	r6,3
   102d0:	11c7883a 	add	r3,r2,r7
   102d4:	29cb883a 	add	r5,r5,r7
   102d8:	313fdf2e 	bgeu	r6,r4,10258 <memcpy+0x20>
   102dc:	213fff04 	addi	r4,r4,-4
   102e0:	2014d0ba 	srli	r10,r4,2
   102e4:	1a400104 	addi	r9,r3,4
   102e8:	180d883a 	mov	r6,r3
   102ec:	528f883a 	add	r7,r10,r10
   102f0:	39cf883a 	add	r7,r7,r7
   102f4:	49d3883a 	add	r9,r9,r7
   102f8:	280f883a 	mov	r7,r5
   102fc:	3a000017 	ldw	r8,0(r7)
   10300:	31800104 	addi	r6,r6,4
   10304:	39c00104 	addi	r7,r7,4
   10308:	323fff15 	stw	r8,-4(r6)
   1030c:	327ffb1e 	bne	r6,r9,102fc <memcpy+0xc4>
   10310:	51800044 	addi	r6,r10,1
   10314:	52bfff24 	muli	r10,r10,-4
   10318:	318d883a 	add	r6,r6,r6
   1031c:	318d883a 	add	r6,r6,r6
   10320:	5109883a 	add	r4,r10,r4
   10324:	298b883a 	add	r5,r5,r6
   10328:	1987883a 	add	r3,r3,r6
   1032c:	003fca06 	br	10258 <memcpy+0x20>

00010330 <memset>:
   10330:	00c000c4 	movi	r3,3
   10334:	2005883a 	mov	r2,r4
   10338:	29403fcc 	andi	r5,r5,255
   1033c:	19802d2e 	bgeu	r3,r6,103f4 <memset+0xc4>
   10340:	20c6703a 	and	r3,r4,r3
   10344:	18002e1e 	bne	r3,zero,10400 <memset+0xd0>
   10348:	2806923a 	slli	r3,r5,8
   1034c:	010003c4 	movi	r4,15
   10350:	3011883a 	mov	r8,r6
   10354:	1946b03a 	or	r3,r3,r5
   10358:	180e943a 	slli	r7,r3,16
   1035c:	38ceb03a 	or	r7,r7,r3
   10360:	1007883a 	mov	r3,r2
   10364:	21800f2e 	bgeu	r4,r6,103a4 <memset+0x74>
   10368:	19c00015 	stw	r7,0(r3)
   1036c:	19c00115 	stw	r7,4(r3)
   10370:	19c00215 	stw	r7,8(r3)
   10374:	19c00315 	stw	r7,12(r3)
   10378:	423ffc04 	addi	r8,r8,-16
   1037c:	18c00404 	addi	r3,r3,16
   10380:	223ff936 	bltu	r4,r8,10368 <memset+0x38>
   10384:	30fffc04 	addi	r3,r6,-16
   10388:	1806d13a 	srli	r3,r3,4
   1038c:	318003cc 	andi	r6,r6,15
   10390:	010000c4 	movi	r4,3
   10394:	18c00044 	addi	r3,r3,1
   10398:	1806913a 	slli	r3,r3,4
   1039c:	10c7883a 	add	r3,r2,r3
   103a0:	21800e2e 	bgeu	r4,r6,103dc <memset+0xac>
   103a4:	1813883a 	mov	r9,r3
   103a8:	3011883a 	mov	r8,r6
   103ac:	010000c4 	movi	r4,3
   103b0:	49c00015 	stw	r7,0(r9)
   103b4:	423fff04 	addi	r8,r8,-4
   103b8:	4a400104 	addi	r9,r9,4
   103bc:	223ffc36 	bltu	r4,r8,103b0 <memset+0x80>
   103c0:	313fff04 	addi	r4,r6,-4
   103c4:	2008d0ba 	srli	r4,r4,2
   103c8:	318000cc 	andi	r6,r6,3
   103cc:	21000044 	addi	r4,r4,1
   103d0:	2109883a 	add	r4,r4,r4
   103d4:	2109883a 	add	r4,r4,r4
   103d8:	1907883a 	add	r3,r3,r4
   103dc:	30000a26 	beq	r6,zero,10408 <memset+0xd8>
   103e0:	198d883a 	add	r6,r3,r6
   103e4:	19400005 	stb	r5,0(r3)
   103e8:	18c00044 	addi	r3,r3,1
   103ec:	19bffd1e 	bne	r3,r6,103e4 <memset+0xb4>
   103f0:	f800283a 	ret
   103f4:	2007883a 	mov	r3,r4
   103f8:	303ff91e 	bne	r6,zero,103e0 <memset+0xb0>
   103fc:	00000206 	br	10408 <memset+0xd8>
   10400:	2007883a 	mov	r3,r4
   10404:	003ff606 	br	103e0 <memset+0xb0>
   10408:	f800283a 	ret

0001040c <_printf_r>:
   1040c:	defffd04 	addi	sp,sp,-12
   10410:	dfc00015 	stw	ra,0(sp)
   10414:	d9800115 	stw	r6,4(sp)
   10418:	d9c00215 	stw	r7,8(sp)
   1041c:	280d883a 	mov	r6,r5
   10420:	21400217 	ldw	r5,8(r4)
   10424:	d9c00104 	addi	r7,sp,4
   10428:	00109180 	call	10918 <___vfprintf_internal_r>
   1042c:	dfc00017 	ldw	ra,0(sp)
   10430:	dec00304 	addi	sp,sp,12
   10434:	f800283a 	ret

00010438 <printf>:
   10438:	defffc04 	addi	sp,sp,-16
   1043c:	dfc00015 	stw	ra,0(sp)
   10440:	d9400115 	stw	r5,4(sp)
   10444:	d9800215 	stw	r6,8(sp)
   10448:	d9c00315 	stw	r7,12(sp)
   1044c:	008000f4 	movhi	r2,3
   10450:	10a60a04 	addi	r2,r2,-26584
   10454:	10800017 	ldw	r2,0(r2)
   10458:	200b883a 	mov	r5,r4
   1045c:	d9800104 	addi	r6,sp,4
   10460:	11000217 	ldw	r4,8(r2)
   10464:	00127100 	call	12710 <__vfprintf_internal>
   10468:	dfc00017 	ldw	ra,0(sp)
   1046c:	dec00404 	addi	sp,sp,16
   10470:	f800283a 	ret

00010474 <_putc_r>:
   10474:	defffc04 	addi	sp,sp,-16
   10478:	dc000215 	stw	r16,8(sp)
   1047c:	dfc00315 	stw	ra,12(sp)
   10480:	2021883a 	mov	r16,r4
   10484:	20000226 	beq	r4,zero,10490 <_putc_r+0x1c>
   10488:	20800e17 	ldw	r2,56(r4)
   1048c:	10001d26 	beq	r2,zero,10504 <_putc_r+0x90>
   10490:	30800217 	ldw	r2,8(r6)
   10494:	10bfffc4 	addi	r2,r2,-1
   10498:	30800215 	stw	r2,8(r6)
   1049c:	10000a16 	blt	r2,zero,104c8 <_putc_r+0x54>
   104a0:	30800017 	ldw	r2,0(r6)
   104a4:	11400005 	stb	r5,0(r2)
   104a8:	30800017 	ldw	r2,0(r6)
   104ac:	10c00044 	addi	r3,r2,1
   104b0:	10800003 	ldbu	r2,0(r2)
   104b4:	30c00015 	stw	r3,0(r6)
   104b8:	dfc00317 	ldw	ra,12(sp)
   104bc:	dc000217 	ldw	r16,8(sp)
   104c0:	dec00404 	addi	sp,sp,16
   104c4:	f800283a 	ret
   104c8:	30c00617 	ldw	r3,24(r6)
   104cc:	10c01316 	blt	r2,r3,1051c <_putc_r+0xa8>
   104d0:	30800017 	ldw	r2,0(r6)
   104d4:	01000284 	movi	r4,10
   104d8:	11400005 	stb	r5,0(r2)
   104dc:	30c00017 	ldw	r3,0(r6)
   104e0:	19400003 	ldbu	r5,0(r3)
   104e4:	29000d26 	beq	r5,r4,1051c <_putc_r+0xa8>
   104e8:	18c00044 	addi	r3,r3,1
   104ec:	2805883a 	mov	r2,r5
   104f0:	30c00015 	stw	r3,0(r6)
   104f4:	dfc00317 	ldw	ra,12(sp)
   104f8:	dc000217 	ldw	r16,8(sp)
   104fc:	dec00404 	addi	sp,sp,16
   10500:	f800283a 	ret
   10504:	d9400015 	stw	r5,0(sp)
   10508:	d9800115 	stw	r6,4(sp)
   1050c:	00144cc0 	call	144cc <__sinit>
   10510:	d9800117 	ldw	r6,4(sp)
   10514:	d9400017 	ldw	r5,0(sp)
   10518:	003fdd06 	br	10490 <_putc_r+0x1c>
   1051c:	8009883a 	mov	r4,r16
   10520:	dfc00317 	ldw	ra,12(sp)
   10524:	dc000217 	ldw	r16,8(sp)
   10528:	dec00404 	addi	sp,sp,16
   1052c:	00127341 	jmpi	12734 <__swbuf_r>

00010530 <putc>:
   10530:	defffc04 	addi	sp,sp,-16
   10534:	dc400115 	stw	r17,4(sp)
   10538:	044000f4 	movhi	r17,3
   1053c:	8c660a04 	addi	r17,r17,-26584
   10540:	88800017 	ldw	r2,0(r17)
   10544:	dc800215 	stw	r18,8(sp)
   10548:	dc000015 	stw	r16,0(sp)
   1054c:	dfc00315 	stw	ra,12(sp)
   10550:	2025883a 	mov	r18,r4
   10554:	2821883a 	mov	r16,r5
   10558:	10000226 	beq	r2,zero,10564 <putc+0x34>
   1055c:	10c00e17 	ldw	r3,56(r2)
   10560:	18002126 	beq	r3,zero,105e8 <putc+0xb8>
   10564:	80800217 	ldw	r2,8(r16)
   10568:	10bfffc4 	addi	r2,r2,-1
   1056c:	80800215 	stw	r2,8(r16)
   10570:	10000c16 	blt	r2,zero,105a4 <putc+0x74>
   10574:	80800017 	ldw	r2,0(r16)
   10578:	14800005 	stb	r18,0(r2)
   1057c:	80800017 	ldw	r2,0(r16)
   10580:	10c00044 	addi	r3,r2,1
   10584:	10800003 	ldbu	r2,0(r2)
   10588:	80c00015 	stw	r3,0(r16)
   1058c:	dfc00317 	ldw	ra,12(sp)
   10590:	dc800217 	ldw	r18,8(sp)
   10594:	dc400117 	ldw	r17,4(sp)
   10598:	dc000017 	ldw	r16,0(sp)
   1059c:	dec00404 	addi	sp,sp,16
   105a0:	f800283a 	ret
   105a4:	80c00617 	ldw	r3,24(r16)
   105a8:	10c01216 	blt	r2,r3,105f4 <putc+0xc4>
   105ac:	80800017 	ldw	r2,0(r16)
   105b0:	01000284 	movi	r4,10
   105b4:	14800005 	stb	r18,0(r2)
   105b8:	80c00017 	ldw	r3,0(r16)
   105bc:	19400003 	ldbu	r5,0(r3)
   105c0:	29001526 	beq	r5,r4,10618 <putc+0xe8>
   105c4:	18c00044 	addi	r3,r3,1
   105c8:	2805883a 	mov	r2,r5
   105cc:	80c00015 	stw	r3,0(r16)
   105d0:	dfc00317 	ldw	ra,12(sp)
   105d4:	dc800217 	ldw	r18,8(sp)
   105d8:	dc400117 	ldw	r17,4(sp)
   105dc:	dc000017 	ldw	r16,0(sp)
   105e0:	dec00404 	addi	sp,sp,16
   105e4:	f800283a 	ret
   105e8:	1009883a 	mov	r4,r2
   105ec:	00144cc0 	call	144cc <__sinit>
   105f0:	003fdc06 	br	10564 <putc+0x34>
   105f4:	89000017 	ldw	r4,0(r17)
   105f8:	900b883a 	mov	r5,r18
   105fc:	800d883a 	mov	r6,r16
   10600:	dfc00317 	ldw	ra,12(sp)
   10604:	dc800217 	ldw	r18,8(sp)
   10608:	dc400117 	ldw	r17,4(sp)
   1060c:	dc000017 	ldw	r16,0(sp)
   10610:	dec00404 	addi	sp,sp,16
   10614:	00127341 	jmpi	12734 <__swbuf_r>
   10618:	89000017 	ldw	r4,0(r17)
   1061c:	003ff706 	br	105fc <putc+0xcc>

00010620 <_puts_r>:
   10620:	defff604 	addi	sp,sp,-40
   10624:	dc400815 	stw	r17,32(sp)
   10628:	2023883a 	mov	r17,r4
   1062c:	2809883a 	mov	r4,r5
   10630:	dc000715 	stw	r16,28(sp)
   10634:	dfc00915 	stw	ra,36(sp)
   10638:	2821883a 	mov	r16,r5
   1063c:	001075c0 	call	1075c <strlen>
   10640:	10c00044 	addi	r3,r2,1
   10644:	d8800115 	stw	r2,4(sp)
   10648:	89400217 	ldw	r5,8(r17)
   1064c:	008000b4 	movhi	r2,2
   10650:	1099fa04 	addi	r2,r2,26600
   10654:	d8800215 	stw	r2,8(sp)
   10658:	00800044 	movi	r2,1
   1065c:	d8800315 	stw	r2,12(sp)
   10660:	8809883a 	mov	r4,r17
   10664:	00800084 	movi	r2,2
   10668:	d9800404 	addi	r6,sp,16
   1066c:	dc000015 	stw	r16,0(sp)
   10670:	d8c00615 	stw	r3,24(sp)
   10674:	dec00415 	stw	sp,16(sp)
   10678:	d8800515 	stw	r2,20(sp)
   1067c:	0014b200 	call	14b20 <__sfvwrite_r>
   10680:	1000061e 	bne	r2,zero,1069c <_puts_r+0x7c>
   10684:	00800284 	movi	r2,10
   10688:	dfc00917 	ldw	ra,36(sp)
   1068c:	dc400817 	ldw	r17,32(sp)
   10690:	dc000717 	ldw	r16,28(sp)
   10694:	dec00a04 	addi	sp,sp,40
   10698:	f800283a 	ret
   1069c:	00bfffc4 	movi	r2,-1
   106a0:	003ff906 	br	10688 <_puts_r+0x68>

000106a4 <puts>:
   106a4:	008000f4 	movhi	r2,3
   106a8:	10a60a04 	addi	r2,r2,-26584
   106ac:	200b883a 	mov	r5,r4
   106b0:	11000017 	ldw	r4,0(r2)
   106b4:	00106201 	jmpi	10620 <_puts_r>

000106b8 <strcmp>:
   106b8:	2904b03a 	or	r2,r5,r4
   106bc:	108000cc 	andi	r2,r2,3
   106c0:	1000171e 	bne	r2,zero,10720 <strcmp+0x68>
   106c4:	20800017 	ldw	r2,0(r4)
   106c8:	28c00017 	ldw	r3,0(r5)
   106cc:	10c0141e 	bne	r2,r3,10720 <strcmp+0x68>
   106d0:	027fbff4 	movhi	r9,65279
   106d4:	4a7fbfc4 	addi	r9,r9,-257
   106d8:	1247883a 	add	r3,r2,r9
   106dc:	0084303a 	nor	r2,zero,r2
   106e0:	1884703a 	and	r2,r3,r2
   106e4:	02202074 	movhi	r8,32897
   106e8:	42202004 	addi	r8,r8,-32640
   106ec:	1204703a 	and	r2,r2,r8
   106f0:	10000226 	beq	r2,zero,106fc <strcmp+0x44>
   106f4:	00001706 	br	10754 <strcmp+0x9c>
   106f8:	3000161e 	bne	r6,zero,10754 <strcmp+0x9c>
   106fc:	21000104 	addi	r4,r4,4
   10700:	20800017 	ldw	r2,0(r4)
   10704:	29400104 	addi	r5,r5,4
   10708:	28c00017 	ldw	r3,0(r5)
   1070c:	124f883a 	add	r7,r2,r9
   10710:	008c303a 	nor	r6,zero,r2
   10714:	398c703a 	and	r6,r7,r6
   10718:	320c703a 	and	r6,r6,r8
   1071c:	10fff626 	beq	r2,r3,106f8 <strcmp+0x40>
   10720:	20800007 	ldb	r2,0(r4)
   10724:	1000051e 	bne	r2,zero,1073c <strcmp+0x84>
   10728:	00000606 	br	10744 <strcmp+0x8c>
   1072c:	21000044 	addi	r4,r4,1
   10730:	20800007 	ldb	r2,0(r4)
   10734:	29400044 	addi	r5,r5,1
   10738:	10000226 	beq	r2,zero,10744 <strcmp+0x8c>
   1073c:	28c00007 	ldb	r3,0(r5)
   10740:	10fffa26 	beq	r2,r3,1072c <strcmp+0x74>
   10744:	20c00003 	ldbu	r3,0(r4)
   10748:	28800003 	ldbu	r2,0(r5)
   1074c:	1885c83a 	sub	r2,r3,r2
   10750:	f800283a 	ret
   10754:	0005883a 	mov	r2,zero
   10758:	f800283a 	ret

0001075c <strlen>:
   1075c:	208000cc 	andi	r2,r4,3
   10760:	10001f1e 	bne	r2,zero,107e0 <strlen+0x84>
   10764:	20800017 	ldw	r2,0(r4)
   10768:	01ffbff4 	movhi	r7,65279
   1076c:	39ffbfc4 	addi	r7,r7,-257
   10770:	01a02074 	movhi	r6,32897
   10774:	31a02004 	addi	r6,r6,-32640
   10778:	11c7883a 	add	r3,r2,r7
   1077c:	0084303a 	nor	r2,zero,r2
   10780:	1886703a 	and	r3,r3,r2
   10784:	1986703a 	and	r3,r3,r6
   10788:	2005883a 	mov	r2,r4
   1078c:	1800101e 	bne	r3,zero,107d0 <strlen+0x74>
   10790:	10800104 	addi	r2,r2,4
   10794:	10c00017 	ldw	r3,0(r2)
   10798:	19cb883a 	add	r5,r3,r7
   1079c:	00c6303a 	nor	r3,zero,r3
   107a0:	28c6703a 	and	r3,r5,r3
   107a4:	1986703a 	and	r3,r3,r6
   107a8:	1800091e 	bne	r3,zero,107d0 <strlen+0x74>
   107ac:	10800104 	addi	r2,r2,4
   107b0:	10c00017 	ldw	r3,0(r2)
   107b4:	19cb883a 	add	r5,r3,r7
   107b8:	00c6303a 	nor	r3,zero,r3
   107bc:	28c6703a 	and	r3,r5,r3
   107c0:	1986703a 	and	r3,r3,r6
   107c4:	183ff226 	beq	r3,zero,10790 <strlen+0x34>
   107c8:	00000106 	br	107d0 <strlen+0x74>
   107cc:	10800044 	addi	r2,r2,1
   107d0:	10c00007 	ldb	r3,0(r2)
   107d4:	183ffd1e 	bne	r3,zero,107cc <strlen+0x70>
   107d8:	1105c83a 	sub	r2,r2,r4
   107dc:	f800283a 	ret
   107e0:	2005883a 	mov	r2,r4
   107e4:	003ffa06 	br	107d0 <strlen+0x74>

000107e8 <strncmp>:
   107e8:	30001826 	beq	r6,zero,1084c <strncmp+0x64>
   107ec:	2904b03a 	or	r2,r5,r4
   107f0:	108000cc 	andi	r2,r2,3
   107f4:	10001726 	beq	r2,zero,10854 <strncmp+0x6c>
   107f8:	31bfffc4 	addi	r6,r6,-1
   107fc:	20800007 	ldb	r2,0(r4)
   10800:	28c00007 	ldb	r3,0(r5)
   10804:	10c0331e 	bne	r2,r3,108d4 <strncmp+0xec>
   10808:	30001026 	beq	r6,zero,1084c <strncmp+0x64>
   1080c:	10000f26 	beq	r2,zero,1084c <strncmp+0x64>
   10810:	20800044 	addi	r2,r4,1
   10814:	29400044 	addi	r5,r5,1
   10818:	2189883a 	add	r4,r4,r6
   1081c:	00000406 	br	10830 <strncmp+0x48>
   10820:	11000a26 	beq	r2,r4,1084c <strncmp+0x64>
   10824:	18000926 	beq	r3,zero,1084c <strncmp+0x64>
   10828:	10800044 	addi	r2,r2,1
   1082c:	29400044 	addi	r5,r5,1
   10830:	10c00007 	ldb	r3,0(r2)
   10834:	29800007 	ldb	r6,0(r5)
   10838:	19bff926 	beq	r3,r6,10820 <strncmp+0x38>
   1083c:	10c00003 	ldbu	r3,0(r2)
   10840:	28800003 	ldbu	r2,0(r5)
   10844:	1885c83a 	sub	r2,r3,r2
   10848:	f800283a 	ret
   1084c:	0005883a 	mov	r2,zero
   10850:	f800283a 	ret
   10854:	024000c4 	movi	r9,3
   10858:	49bfe72e 	bgeu	r9,r6,107f8 <strncmp+0x10>
   1085c:	20800017 	ldw	r2,0(r4)
   10860:	28c00017 	ldw	r3,0(r5)
   10864:	10ffe41e 	bne	r2,r3,107f8 <strncmp+0x10>
   10868:	30ffff04 	addi	r3,r6,-4
   1086c:	183ff726 	beq	r3,zero,1084c <strncmp+0x64>
   10870:	02ffbff4 	movhi	r11,65279
   10874:	5affbfc4 	addi	r11,r11,-257
   10878:	12cd883a 	add	r6,r2,r11
   1087c:	0084303a 	nor	r2,zero,r2
   10880:	3084703a 	and	r2,r6,r2
   10884:	02a02074 	movhi	r10,32897
   10888:	52a02004 	addi	r10,r10,-32640
   1088c:	1284703a 	and	r2,r2,r10
   10890:	10000b26 	beq	r2,zero,108c0 <strncmp+0xd8>
   10894:	003fed06 	br	1084c <strncmp+0x64>
   10898:	21800017 	ldw	r6,0(r4)
   1089c:	28800017 	ldw	r2,0(r5)
   108a0:	32d1883a 	add	r8,r6,r11
   108a4:	018e303a 	nor	r7,zero,r6
   108a8:	41ce703a 	and	r7,r8,r7
   108ac:	3a8e703a 	and	r7,r7,r10
   108b0:	30800a1e 	bne	r6,r2,108dc <strncmp+0xf4>
   108b4:	18ffff04 	addi	r3,r3,-4
   108b8:	183fe426 	beq	r3,zero,1084c <strncmp+0x64>
   108bc:	383fe31e 	bne	r7,zero,1084c <strncmp+0x64>
   108c0:	21000104 	addi	r4,r4,4
   108c4:	29400104 	addi	r5,r5,4
   108c8:	48fff336 	bltu	r9,r3,10898 <strncmp+0xb0>
   108cc:	19bfffc4 	addi	r6,r3,-1
   108d0:	183fca1e 	bne	r3,zero,107fc <strncmp+0x14>
   108d4:	2005883a 	mov	r2,r4
   108d8:	003fd806 	br	1083c <strncmp+0x54>
   108dc:	19bfffc4 	addi	r6,r3,-1
   108e0:	003fc606 	br	107fc <strncmp+0x14>

000108e4 <__sprint_r>:
   108e4:	30800217 	ldw	r2,8(r6)
   108e8:	defffe04 	addi	sp,sp,-8
   108ec:	dc000015 	stw	r16,0(sp)
   108f0:	dfc00115 	stw	ra,4(sp)
   108f4:	3021883a 	mov	r16,r6
   108f8:	10000226 	beq	r2,zero,10904 <__sprint_r+0x20>
   108fc:	0014b200 	call	14b20 <__sfvwrite_r>
   10900:	80000215 	stw	zero,8(r16)
   10904:	80000115 	stw	zero,4(r16)
   10908:	dfc00117 	ldw	ra,4(sp)
   1090c:	dc000017 	ldw	r16,0(sp)
   10910:	dec00204 	addi	sp,sp,8
   10914:	f800283a 	ret

00010918 <___vfprintf_internal_r>:
   10918:	defeb904 	addi	sp,sp,-1308
   1091c:	dc013d15 	stw	r16,1268(sp)
   10920:	d9013015 	stw	r4,1216(sp)
   10924:	dfc14615 	stw	ra,1304(sp)
   10928:	df014515 	stw	fp,1300(sp)
   1092c:	ddc14415 	stw	r23,1296(sp)
   10930:	dd814315 	stw	r22,1292(sp)
   10934:	dd414215 	stw	r21,1288(sp)
   10938:	dd014115 	stw	r20,1284(sp)
   1093c:	dcc14015 	stw	r19,1280(sp)
   10940:	dc813f15 	stw	r18,1276(sp)
   10944:	dc413e15 	stw	r17,1272(sp)
   10948:	d9412915 	stw	r5,1188(sp)
   1094c:	3021883a 	mov	r16,r6
   10950:	d9c12d15 	stw	r7,1204(sp)
   10954:	001520c0 	call	1520c <_localeconv_r>
   10958:	10800017 	ldw	r2,0(r2)
   1095c:	d9013017 	ldw	r4,1216(sp)
   10960:	d8013315 	stw	zero,1228(sp)
   10964:	d8813715 	stw	r2,1244(sp)
   10968:	d8013415 	stw	zero,1232(sp)
   1096c:	20000226 	beq	r4,zero,10978 <___vfprintf_internal_r+0x60>
   10970:	20800e17 	ldw	r2,56(r4)
   10974:	10019826 	beq	r2,zero,10fd8 <___vfprintf_internal_r+0x6c0>
   10978:	da012917 	ldw	r8,1188(sp)
   1097c:	4080030b 	ldhu	r2,12(r8)
   10980:	10c0020c 	andi	r3,r2,8
   10984:	18ffffcc 	andi	r3,r3,65535
   10988:	18e0001c 	xori	r3,r3,32768
   1098c:	18e00004 	addi	r3,r3,-32768
   10990:	18013a26 	beq	r3,zero,10e7c <___vfprintf_internal_r+0x564>
   10994:	40c00417 	ldw	r3,16(r8)
   10998:	18013826 	beq	r3,zero,10e7c <___vfprintf_internal_r+0x564>
   1099c:	1100068c 	andi	r4,r2,26
   109a0:	00c00284 	movi	r3,10
   109a4:	20c13e26 	beq	r4,r3,10ea0 <___vfprintf_internal_r+0x588>
   109a8:	da010dc4 	addi	r8,sp,1079
   109ac:	d8800404 	addi	r2,sp,16
   109b0:	da012615 	stw	r8,1176(sp)
   109b4:	d8811b15 	stw	r2,1132(sp)
   109b8:	1013883a 	mov	r9,r2
   109bc:	d8812617 	ldw	r2,1176(sp)
   109c0:	da010e04 	addi	r8,sp,1080
   109c4:	dc413017 	ldw	r17,1216(sp)
   109c8:	da012715 	stw	r8,1180(sp)
   109cc:	4091c83a 	sub	r8,r8,r2
   109d0:	d8011d15 	stw	zero,1140(sp)
   109d4:	d8011c15 	stw	zero,1136(sp)
   109d8:	802b883a 	mov	r21,r16
   109dc:	d8013215 	stw	zero,1224(sp)
   109e0:	d8013615 	stw	zero,1240(sp)
   109e4:	d8013515 	stw	zero,1236(sp)
   109e8:	d8012c15 	stw	zero,1200(sp)
   109ec:	da013915 	stw	r8,1252(sp)
   109f0:	a8800007 	ldb	r2,0(r21)
   109f4:	1002ec26 	beq	r2,zero,115a8 <___vfprintf_internal_r+0xc90>
   109f8:	00c00944 	movi	r3,37
   109fc:	a825883a 	mov	r18,r21
   10a00:	10c0021e 	bne	r2,r3,10a0c <___vfprintf_internal_r+0xf4>
   10a04:	00001406 	br	10a58 <___vfprintf_internal_r+0x140>
   10a08:	10c00326 	beq	r2,r3,10a18 <___vfprintf_internal_r+0x100>
   10a0c:	94800044 	addi	r18,r18,1
   10a10:	90800007 	ldb	r2,0(r18)
   10a14:	103ffc1e 	bne	r2,zero,10a08 <___vfprintf_internal_r+0xf0>
   10a18:	9561c83a 	sub	r16,r18,r21
   10a1c:	80000e26 	beq	r16,zero,10a58 <___vfprintf_internal_r+0x140>
   10a20:	da011d17 	ldw	r8,1140(sp)
   10a24:	d8c11c17 	ldw	r3,1136(sp)
   10a28:	4d400015 	stw	r21,0(r9)
   10a2c:	4c000115 	stw	r16,4(r9)
   10a30:	4411883a 	add	r8,r8,r16
   10a34:	18c00044 	addi	r3,r3,1
   10a38:	da011d15 	stw	r8,1140(sp)
   10a3c:	d8c11c15 	stw	r3,1136(sp)
   10a40:	008001c4 	movi	r2,7
   10a44:	10c15d16 	blt	r2,r3,10fbc <___vfprintf_internal_r+0x6a4>
   10a48:	4a400204 	addi	r9,r9,8
   10a4c:	d8812c17 	ldw	r2,1200(sp)
   10a50:	1405883a 	add	r2,r2,r16
   10a54:	d8812c15 	stw	r2,1200(sp)
   10a58:	90800007 	ldb	r2,0(r18)
   10a5c:	10013b26 	beq	r2,zero,10f4c <___vfprintf_internal_r+0x634>
   10a60:	95400044 	addi	r21,r18,1
   10a64:	94800047 	ldb	r18,1(r18)
   10a68:	d8012585 	stb	zero,1174(sp)
   10a6c:	073fffc4 	movi	fp,-1
   10a70:	d8012e15 	stw	zero,1208(sp)
   10a74:	0021883a 	mov	r16,zero
   10a78:	00c01604 	movi	r3,88
   10a7c:	01400244 	movi	r5,9
   10a80:	02800a84 	movi	r10,42
   10a84:	01c01b04 	movi	r7,108
   10a88:	01800ac4 	movi	r6,43
   10a8c:	02c00804 	movi	r11,32
   10a90:	ad400044 	addi	r21,r21,1
   10a94:	90bff804 	addi	r2,r18,-32
   10a98:	1880092e 	bgeu	r3,r2,10ac0 <___vfprintf_internal_r+0x1a8>
   10a9c:	90012b26 	beq	r18,zero,10f4c <___vfprintf_internal_r+0x634>
   10aa0:	00c00044 	movi	r3,1
   10aa4:	d8c12815 	stw	r3,1184(sp)
   10aa8:	dc810405 	stb	r18,1040(sp)
   10aac:	d8012585 	stb	zero,1174(sp)
   10ab0:	d8c12b15 	stw	r3,1196(sp)
   10ab4:	dcc10404 	addi	r19,sp,1040
   10ab8:	d8013115 	stw	zero,1220(sp)
   10abc:	00008806 	br	10ce0 <___vfprintf_internal_r+0x3c8>
   10ac0:	1085883a 	add	r2,r2,r2
   10ac4:	1085883a 	add	r2,r2,r2
   10ac8:	01000074 	movhi	r4,1
   10acc:	2102b704 	addi	r4,r4,2780
   10ad0:	1105883a 	add	r2,r2,r4
   10ad4:	10800017 	ldw	r2,0(r2)
   10ad8:	1000683a 	jmp	r2
   10adc:	00011090 	cmplti	zero,zero,1090
   10ae0:	00010a9c 	xori	zero,zero,1066
   10ae4:	00010a9c 	xori	zero,zero,1066
   10ae8:	000110a4 	muli	zero,zero,1090
   10aec:	00010a9c 	xori	zero,zero,1066
   10af0:	00010a9c 	xori	zero,zero,1066
   10af4:	00010a9c 	xori	zero,zero,1066
   10af8:	00010a9c 	xori	zero,zero,1066
   10afc:	00010a9c 	xori	zero,zero,1066
   10b00:	00010a9c 	xori	zero,zero,1066
   10b04:	0001118c 	andi	zero,zero,1094
   10b08:	00011048 	cmpgei	zero,zero,1089
   10b0c:	00010a9c 	xori	zero,zero,1066
   10b10:	00010e70 	cmpltui	zero,zero,1081
   10b14:	00011054 	movui	zero,1089
   10b18:	00010a9c 	xori	zero,zero,1066
   10b1c:	000110b0 	cmpltui	zero,zero,1090
   10b20:	000111b0 	cmpltui	zero,zero,1094
   10b24:	000111b0 	cmpltui	zero,zero,1094
   10b28:	000111b0 	cmpltui	zero,zero,1094
   10b2c:	000111b0 	cmpltui	zero,zero,1094
   10b30:	000111b0 	cmpltui	zero,zero,1094
   10b34:	000111b0 	cmpltui	zero,zero,1094
   10b38:	000111b0 	cmpltui	zero,zero,1094
   10b3c:	000111b0 	cmpltui	zero,zero,1094
   10b40:	000111b0 	cmpltui	zero,zero,1094
   10b44:	00010a9c 	xori	zero,zero,1066
   10b48:	00010a9c 	xori	zero,zero,1066
   10b4c:	00010a9c 	xori	zero,zero,1066
   10b50:	00010a9c 	xori	zero,zero,1066
   10b54:	00010a9c 	xori	zero,zero,1066
   10b58:	00010a9c 	xori	zero,zero,1066
   10b5c:	00010a9c 	xori	zero,zero,1066
   10b60:	00010a9c 	xori	zero,zero,1066
   10b64:	00010a9c 	xori	zero,zero,1066
   10b68:	00010a9c 	xori	zero,zero,1066
   10b6c:	00010e0c 	andi	zero,zero,1080
   10b70:	000111d8 	cmpnei	zero,zero,1095
   10b74:	00010a9c 	xori	zero,zero,1066
   10b78:	000111d8 	cmpnei	zero,zero,1095
   10b7c:	00010a9c 	xori	zero,zero,1066
   10b80:	00010a9c 	xori	zero,zero,1066
   10b84:	00010a9c 	xori	zero,zero,1066
   10b88:	00010a9c 	xori	zero,zero,1066
   10b8c:	00011348 	cmpgei	zero,zero,1101
   10b90:	00010a9c 	xori	zero,zero,1066
   10b94:	00010a9c 	xori	zero,zero,1066
   10b98:	00010dd4 	movui	zero,1079
   10b9c:	00010a9c 	xori	zero,zero,1066
   10ba0:	00010a9c 	xori	zero,zero,1066
   10ba4:	00010a9c 	xori	zero,zero,1066
   10ba8:	00010a9c 	xori	zero,zero,1066
   10bac:	00010a9c 	xori	zero,zero,1066
   10bb0:	00010c40 	call	10c4 <udpecho_init+0x68>
   10bb4:	00010a9c 	xori	zero,zero,1066
   10bb8:	00010a9c 	xori	zero,zero,1066
   10bbc:	000110bc 	xorhi	zero,zero,1090
   10bc0:	00010a9c 	xori	zero,zero,1066
   10bc4:	00010a9c 	xori	zero,zero,1066
   10bc8:	00010a9c 	xori	zero,zero,1066
   10bcc:	00010a9c 	xori	zero,zero,1066
   10bd0:	00010a9c 	xori	zero,zero,1066
   10bd4:	00010a9c 	xori	zero,zero,1066
   10bd8:	00010a9c 	xori	zero,zero,1066
   10bdc:	00010a9c 	xori	zero,zero,1066
   10be0:	00010a9c 	xori	zero,zero,1066
   10be4:	00010a9c 	xori	zero,zero,1066
   10be8:	00011130 	cmpltui	zero,zero,1092
   10bec:	00010e10 	cmplti	zero,zero,1080
   10bf0:	000111d8 	cmpnei	zero,zero,1095
   10bf4:	000111d8 	cmpnei	zero,zero,1095
   10bf8:	000111d8 	cmpnei	zero,zero,1095
   10bfc:	00011110 	cmplti	zero,zero,1092
   10c00:	00010e10 	cmplti	zero,zero,1080
   10c04:	00010a9c 	xori	zero,zero,1066
   10c08:	00010a9c 	xori	zero,zero,1066
   10c0c:	0001111c 	xori	zero,zero,1092
   10c10:	00010a9c 	xori	zero,zero,1066
   10c14:	00011160 	cmpeqi	zero,zero,1093
   10c18:	00010dd8 	cmpnei	zero,zero,1079
   10c1c:	00011260 	cmpeqi	zero,zero,1097
   10c20:	000112ac 	andhi	zero,zero,1098
   10c24:	00010a9c 	xori	zero,zero,1066
   10c28:	000112b8 	rdprs	zero,zero,1098
   10c2c:	00010a9c 	xori	zero,zero,1066
   10c30:	00010c44 	movi	zero,1073
   10c34:	00010a9c 	xori	zero,zero,1066
   10c38:	00010a9c 	xori	zero,zero,1066
   10c3c:	00011314 	movui	zero,1100
   10c40:	84000414 	ori	r16,r16,16
   10c44:	8080080c 	andi	r2,r16,32
   10c48:	1000f51e 	bne	r2,zero,11020 <___vfprintf_internal_r+0x708>
   10c4c:	8080040c 	andi	r2,r16,16
   10c50:	10042c26 	beq	r2,zero,11d04 <___vfprintf_internal_r+0x13ec>
   10c54:	da012d17 	ldw	r8,1204(sp)
   10c58:	002d883a 	mov	r22,zero
   10c5c:	00c00044 	movi	r3,1
   10c60:	45c00017 	ldw	r23,0(r8)
   10c64:	42000104 	addi	r8,r8,4
   10c68:	da012d15 	stw	r8,1204(sp)
   10c6c:	b805883a 	mov	r2,r23
   10c70:	d8012585 	stb	zero,1174(sp)
   10c74:	e0000216 	blt	fp,zero,10c80 <___vfprintf_internal_r+0x368>
   10c78:	013fdfc4 	movi	r4,-129
   10c7c:	8120703a 	and	r16,r16,r4
   10c80:	1002671e 	bne	r2,zero,11620 <___vfprintf_internal_r+0xd08>
   10c84:	e002661e 	bne	fp,zero,11620 <___vfprintf_internal_r+0xd08>
   10c88:	18c03fcc 	andi	r3,r3,255
   10c8c:	1803561e 	bne	r3,zero,119e8 <___vfprintf_internal_r+0x10d0>
   10c90:	8080004c 	andi	r2,r16,1
   10c94:	10035426 	beq	r2,zero,119e8 <___vfprintf_internal_r+0x10d0>
   10c98:	da013917 	ldw	r8,1252(sp)
   10c9c:	00800c04 	movi	r2,48
   10ca0:	d8810dc5 	stb	r2,1079(sp)
   10ca4:	da012b15 	stw	r8,1196(sp)
   10ca8:	dcc10dc4 	addi	r19,sp,1079
   10cac:	d8812b17 	ldw	r2,1196(sp)
   10cb0:	d8812815 	stw	r2,1184(sp)
   10cb4:	1700010e 	bge	r2,fp,10cbc <___vfprintf_internal_r+0x3a4>
   10cb8:	df012815 	stw	fp,1184(sp)
   10cbc:	d8812583 	ldbu	r2,1174(sp)
   10cc0:	df013115 	stw	fp,1220(sp)
   10cc4:	10803fcc 	andi	r2,r2,255
   10cc8:	1080201c 	xori	r2,r2,128
   10ccc:	10bfe004 	addi	r2,r2,-128
   10cd0:	10000326 	beq	r2,zero,10ce0 <___vfprintf_internal_r+0x3c8>
   10cd4:	da012817 	ldw	r8,1184(sp)
   10cd8:	42000044 	addi	r8,r8,1
   10cdc:	da012815 	stw	r8,1184(sp)
   10ce0:	80c0008c 	andi	r3,r16,2
   10ce4:	d8c12a15 	stw	r3,1192(sp)
   10ce8:	18000326 	beq	r3,zero,10cf8 <___vfprintf_internal_r+0x3e0>
   10cec:	da012817 	ldw	r8,1184(sp)
   10cf0:	42000084 	addi	r8,r8,2
   10cf4:	da012815 	stw	r8,1184(sp)
   10cf8:	80c0210c 	andi	r3,r16,132
   10cfc:	d8c12f15 	stw	r3,1212(sp)
   10d00:	1801941e 	bne	r3,zero,11354 <___vfprintf_internal_r+0xa3c>
   10d04:	da012e17 	ldw	r8,1208(sp)
   10d08:	d8c12817 	ldw	r3,1184(sp)
   10d0c:	40edc83a 	sub	r22,r8,r3
   10d10:	0581900e 	bge	zero,r22,11354 <___vfprintf_internal_r+0xa3c>
   10d14:	02800404 	movi	r10,16
   10d18:	da011d17 	ldw	r8,1140(sp)
   10d1c:	d8c11c17 	ldw	r3,1136(sp)
   10d20:	05c000b4 	movhi	r23,2
   10d24:	bdd83ac4 	addi	r23,r23,24811
   10d28:	5580200e 	bge	r10,r22,10dac <___vfprintf_internal_r+0x494>
   10d2c:	dc813815 	stw	r18,1248(sp)
   10d30:	5039883a 	mov	fp,r10
   10d34:	b825883a 	mov	r18,r23
   10d38:	050001c4 	movi	r20,7
   10d3c:	b02f883a 	mov	r23,r22
   10d40:	802d883a 	mov	r22,r16
   10d44:	dc012917 	ldw	r16,1188(sp)
   10d48:	00000306 	br	10d58 <___vfprintf_internal_r+0x440>
   10d4c:	bdfffc04 	addi	r23,r23,-16
   10d50:	4a400204 	addi	r9,r9,8
   10d54:	e5c0110e 	bge	fp,r23,10d9c <___vfprintf_internal_r+0x484>
   10d58:	4c800015 	stw	r18,0(r9)
   10d5c:	4f000115 	stw	fp,4(r9)
   10d60:	42000404 	addi	r8,r8,16
   10d64:	18c00044 	addi	r3,r3,1
   10d68:	da011d15 	stw	r8,1140(sp)
   10d6c:	d8c11c15 	stw	r3,1136(sp)
   10d70:	a0fff60e 	bge	r20,r3,10d4c <___vfprintf_internal_r+0x434>
   10d74:	8809883a 	mov	r4,r17
   10d78:	800b883a 	mov	r5,r16
   10d7c:	d9811b04 	addi	r6,sp,1132
   10d80:	00108e40 	call	108e4 <__sprint_r>
   10d84:	1000771e 	bne	r2,zero,10f64 <___vfprintf_internal_r+0x64c>
   10d88:	bdfffc04 	addi	r23,r23,-16
   10d8c:	da011d17 	ldw	r8,1140(sp)
   10d90:	d8c11c17 	ldw	r3,1136(sp)
   10d94:	da400404 	addi	r9,sp,16
   10d98:	e5ffef16 	blt	fp,r23,10d58 <___vfprintf_internal_r+0x440>
   10d9c:	b021883a 	mov	r16,r22
   10da0:	b82d883a 	mov	r22,r23
   10da4:	902f883a 	mov	r23,r18
   10da8:	dc813817 	ldw	r18,1248(sp)
   10dac:	4dc00015 	stw	r23,0(r9)
   10db0:	4d800115 	stw	r22,4(r9)
   10db4:	4591883a 	add	r8,r8,r22
   10db8:	18c00044 	addi	r3,r3,1
   10dbc:	da011d15 	stw	r8,1140(sp)
   10dc0:	d8c11c15 	stw	r3,1136(sp)
   10dc4:	008001c4 	movi	r2,7
   10dc8:	10c36d16 	blt	r2,r3,11b80 <___vfprintf_internal_r+0x1268>
   10dcc:	4a400204 	addi	r9,r9,8
   10dd0:	00016206 	br	1135c <___vfprintf_internal_r+0xa44>
   10dd4:	84000414 	ori	r16,r16,16
   10dd8:	8080080c 	andi	r2,r16,32
   10ddc:	1000801e 	bne	r2,zero,10fe0 <___vfprintf_internal_r+0x6c8>
   10de0:	8080040c 	andi	r2,r16,16
   10de4:	1003da26 	beq	r2,zero,11d50 <___vfprintf_internal_r+0x1438>
   10de8:	d8c12d17 	ldw	r3,1204(sp)
   10dec:	002d883a 	mov	r22,zero
   10df0:	1dc00017 	ldw	r23,0(r3)
   10df4:	18c00104 	addi	r3,r3,4
   10df8:	d8c12d15 	stw	r3,1204(sp)
   10dfc:	b805883a 	mov	r2,r23
   10e00:	0007883a 	mov	r3,zero
   10e04:	d8012585 	stb	zero,1174(sp)
   10e08:	003f9a06 	br	10c74 <___vfprintf_internal_r+0x35c>
   10e0c:	84000414 	ori	r16,r16,16
   10e10:	8080080c 	andi	r2,r16,32
   10e14:	10007b1e 	bne	r2,zero,11004 <___vfprintf_internal_r+0x6ec>
   10e18:	8080040c 	andi	r2,r16,16
   10e1c:	1003ed26 	beq	r2,zero,11dd4 <___vfprintf_internal_r+0x14bc>
   10e20:	d9012d17 	ldw	r4,1204(sp)
   10e24:	25c00017 	ldw	r23,0(r4)
   10e28:	21000104 	addi	r4,r4,4
   10e2c:	d9012d15 	stw	r4,1204(sp)
   10e30:	b82dd7fa 	srai	r22,r23,31
   10e34:	b005883a 	mov	r2,r22
   10e38:	1003230e 	bge	r2,zero,11ac8 <___vfprintf_internal_r+0x11b0>
   10e3c:	05efc83a 	sub	r23,zero,r23
   10e40:	b804c03a 	cmpne	r2,r23,zero
   10e44:	05adc83a 	sub	r22,zero,r22
   10e48:	b0adc83a 	sub	r22,r22,r2
   10e4c:	00800b44 	movi	r2,45
   10e50:	d8812585 	stb	r2,1174(sp)
   10e54:	00c00044 	movi	r3,1
   10e58:	bd84b03a 	or	r2,r23,r22
   10e5c:	003f8506 	br	10c74 <___vfprintf_internal_r+0x35c>
   10e60:	da012e17 	ldw	r8,1208(sp)
   10e64:	d8812d15 	stw	r2,1204(sp)
   10e68:	0211c83a 	sub	r8,zero,r8
   10e6c:	da012e15 	stw	r8,1208(sp)
   10e70:	84000114 	ori	r16,r16,4
   10e74:	ac800007 	ldb	r18,0(r21)
   10e78:	003f0506 	br	10a90 <___vfprintf_internal_r+0x178>
   10e7c:	d9013017 	ldw	r4,1216(sp)
   10e80:	d9412917 	ldw	r5,1188(sp)
   10e84:	001288c0 	call	1288c <__swsetup_r>
   10e88:	10003d1e 	bne	r2,zero,10f80 <___vfprintf_internal_r+0x668>
   10e8c:	d8c12917 	ldw	r3,1188(sp)
   10e90:	1880030b 	ldhu	r2,12(r3)
   10e94:	00c00284 	movi	r3,10
   10e98:	1100068c 	andi	r4,r2,26
   10e9c:	20fec21e 	bne	r4,r3,109a8 <___vfprintf_internal_r+0x90>
   10ea0:	d9012917 	ldw	r4,1188(sp)
   10ea4:	20c0038b 	ldhu	r3,14(r4)
   10ea8:	193fffcc 	andi	r4,r3,65535
   10eac:	2120001c 	xori	r4,r4,32768
   10eb0:	21200004 	addi	r4,r4,-32768
   10eb4:	203ebc16 	blt	r4,zero,109a8 <___vfprintf_internal_r+0x90>
   10eb8:	da012917 	ldw	r8,1188(sp)
   10ebc:	d9013017 	ldw	r4,1216(sp)
   10ec0:	d9c12d17 	ldw	r7,1204(sp)
   10ec4:	42800717 	ldw	r10,28(r8)
   10ec8:	42400917 	ldw	r9,36(r8)
   10ecc:	10bfff4c 	andi	r2,r2,65533
   10ed0:	02010004 	movi	r8,1024
   10ed4:	d881070d 	sth	r2,1052(sp)
   10ed8:	d9410404 	addi	r5,sp,1040
   10edc:	d8800404 	addi	r2,sp,16
   10ee0:	800d883a 	mov	r6,r16
   10ee4:	d8c1078d 	sth	r3,1054(sp)
   10ee8:	da810b15 	stw	r10,1068(sp)
   10eec:	da410d15 	stw	r9,1076(sp)
   10ef0:	d8810415 	stw	r2,1040(sp)
   10ef4:	d8810815 	stw	r2,1056(sp)
   10ef8:	da010615 	stw	r8,1048(sp)
   10efc:	da010915 	stw	r8,1060(sp)
   10f00:	d8010a15 	stw	zero,1064(sp)
   10f04:	00109180 	call	10918 <___vfprintf_internal_r>
   10f08:	d8812c15 	stw	r2,1200(sp)
   10f0c:	10000416 	blt	r2,zero,10f20 <___vfprintf_internal_r+0x608>
   10f10:	d9013017 	ldw	r4,1216(sp)
   10f14:	d9410404 	addi	r5,sp,1040
   10f18:	00142240 	call	14224 <_fflush_r>
   10f1c:	1005d81e 	bne	r2,zero,12680 <___vfprintf_internal_r+0x1d68>
   10f20:	d881070b 	ldhu	r2,1052(sp)
   10f24:	1080100c 	andi	r2,r2,64
   10f28:	10bfffcc 	andi	r2,r2,65535
   10f2c:	10a0001c 	xori	r2,r2,32768
   10f30:	10a00004 	addi	r2,r2,-32768
   10f34:	10001426 	beq	r2,zero,10f88 <___vfprintf_internal_r+0x670>
   10f38:	d8c12917 	ldw	r3,1188(sp)
   10f3c:	1880030b 	ldhu	r2,12(r3)
   10f40:	10801014 	ori	r2,r2,64
   10f44:	1880030d 	sth	r2,12(r3)
   10f48:	00000f06 	br	10f88 <___vfprintf_internal_r+0x670>
   10f4c:	d8811d17 	ldw	r2,1140(sp)
   10f50:	10000426 	beq	r2,zero,10f64 <___vfprintf_internal_r+0x64c>
   10f54:	d9013017 	ldw	r4,1216(sp)
   10f58:	d9412917 	ldw	r5,1188(sp)
   10f5c:	d9811b04 	addi	r6,sp,1132
   10f60:	00108e40 	call	108e4 <__sprint_r>
   10f64:	d8c12917 	ldw	r3,1188(sp)
   10f68:	1880030b 	ldhu	r2,12(r3)
   10f6c:	1080100c 	andi	r2,r2,64
   10f70:	10bfffcc 	andi	r2,r2,65535
   10f74:	10a0001c 	xori	r2,r2,32768
   10f78:	10a00004 	addi	r2,r2,-32768
   10f7c:	10000226 	beq	r2,zero,10f88 <___vfprintf_internal_r+0x670>
   10f80:	00bfffc4 	movi	r2,-1
   10f84:	d8812c15 	stw	r2,1200(sp)
   10f88:	d8812c17 	ldw	r2,1200(sp)
   10f8c:	dfc14617 	ldw	ra,1304(sp)
   10f90:	df014517 	ldw	fp,1300(sp)
   10f94:	ddc14417 	ldw	r23,1296(sp)
   10f98:	dd814317 	ldw	r22,1292(sp)
   10f9c:	dd414217 	ldw	r21,1288(sp)
   10fa0:	dd014117 	ldw	r20,1284(sp)
   10fa4:	dcc14017 	ldw	r19,1280(sp)
   10fa8:	dc813f17 	ldw	r18,1276(sp)
   10fac:	dc413e17 	ldw	r17,1272(sp)
   10fb0:	dc013d17 	ldw	r16,1268(sp)
   10fb4:	dec14704 	addi	sp,sp,1308
   10fb8:	f800283a 	ret
   10fbc:	d9412917 	ldw	r5,1188(sp)
   10fc0:	8809883a 	mov	r4,r17
   10fc4:	d9811b04 	addi	r6,sp,1132
   10fc8:	00108e40 	call	108e4 <__sprint_r>
   10fcc:	103fe51e 	bne	r2,zero,10f64 <___vfprintf_internal_r+0x64c>
   10fd0:	da400404 	addi	r9,sp,16
   10fd4:	003e9d06 	br	10a4c <___vfprintf_internal_r+0x134>
   10fd8:	00144cc0 	call	144cc <__sinit>
   10fdc:	003e6606 	br	10978 <___vfprintf_internal_r+0x60>
   10fe0:	d8812d17 	ldw	r2,1204(sp)
   10fe4:	0007883a 	mov	r3,zero
   10fe8:	15c00017 	ldw	r23,0(r2)
   10fec:	15800117 	ldw	r22,4(r2)
   10ff0:	10800204 	addi	r2,r2,8
   10ff4:	d8812d15 	stw	r2,1204(sp)
   10ff8:	d8012585 	stb	zero,1174(sp)
   10ffc:	bd84b03a 	or	r2,r23,r22
   11000:	003f1c06 	br	10c74 <___vfprintf_internal_r+0x35c>
   11004:	d8c12d17 	ldw	r3,1204(sp)
   11008:	18800117 	ldw	r2,4(r3)
   1100c:	1dc00017 	ldw	r23,0(r3)
   11010:	18c00204 	addi	r3,r3,8
   11014:	d8c12d15 	stw	r3,1204(sp)
   11018:	102d883a 	mov	r22,r2
   1101c:	003f8606 	br	10e38 <___vfprintf_internal_r+0x520>
   11020:	d8c12d17 	ldw	r3,1204(sp)
   11024:	d9012d17 	ldw	r4,1204(sp)
   11028:	1dc00017 	ldw	r23,0(r3)
   1102c:	1d800117 	ldw	r22,4(r3)
   11030:	21000204 	addi	r4,r4,8
   11034:	00c00044 	movi	r3,1
   11038:	d9012d15 	stw	r4,1204(sp)
   1103c:	bd84b03a 	or	r2,r23,r22
   11040:	d8012585 	stb	zero,1174(sp)
   11044:	003f0b06 	br	10c74 <___vfprintf_internal_r+0x35c>
   11048:	d9812585 	stb	r6,1174(sp)
   1104c:	ac800007 	ldb	r18,0(r21)
   11050:	003e8f06 	br	10a90 <___vfprintf_internal_r+0x178>
   11054:	ac800007 	ldb	r18,0(r21)
   11058:	a9000044 	addi	r4,r21,1
   1105c:	92857d26 	beq	r18,r10,12654 <___vfprintf_internal_r+0x1d3c>
   11060:	90bff404 	addi	r2,r18,-48
   11064:	0039883a 	mov	fp,zero
   11068:	28800736 	bltu	r5,r2,11088 <___vfprintf_internal_r+0x770>
   1106c:	24800007 	ldb	r18,0(r4)
   11070:	e70002a4 	muli	fp,fp,10
   11074:	21000044 	addi	r4,r4,1
   11078:	1739883a 	add	fp,r2,fp
   1107c:	90bff404 	addi	r2,r18,-48
   11080:	28bffa2e 	bgeu	r5,r2,1106c <___vfprintf_internal_r+0x754>
   11084:	e0044216 	blt	fp,zero,12190 <___vfprintf_internal_r+0x1878>
   11088:	202b883a 	mov	r21,r4
   1108c:	003e8106 	br	10a94 <___vfprintf_internal_r+0x17c>
   11090:	d8812587 	ldb	r2,1174(sp)
   11094:	1003581e 	bne	r2,zero,11df8 <___vfprintf_internal_r+0x14e0>
   11098:	dac12585 	stb	r11,1174(sp)
   1109c:	ac800007 	ldb	r18,0(r21)
   110a0:	003e7b06 	br	10a90 <___vfprintf_internal_r+0x178>
   110a4:	84000054 	ori	r16,r16,1
   110a8:	ac800007 	ldb	r18,0(r21)
   110ac:	003e7806 	br	10a90 <___vfprintf_internal_r+0x178>
   110b0:	84002014 	ori	r16,r16,128
   110b4:	ac800007 	ldb	r18,0(r21)
   110b8:	003e7506 	br	10a90 <___vfprintf_internal_r+0x178>
   110bc:	020000b4 	movhi	r8,2
   110c0:	42182f04 	addi	r8,r8,24764
   110c4:	da013615 	stw	r8,1240(sp)
   110c8:	8080080c 	andi	r2,r16,32
   110cc:	10009626 	beq	r2,zero,11328 <___vfprintf_internal_r+0xa10>
   110d0:	d8812d17 	ldw	r2,1204(sp)
   110d4:	15c00017 	ldw	r23,0(r2)
   110d8:	15800117 	ldw	r22,4(r2)
   110dc:	10800204 	addi	r2,r2,8
   110e0:	d8812d15 	stw	r2,1204(sp)
   110e4:	8080004c 	andi	r2,r16,1
   110e8:	1002ae26 	beq	r2,zero,11ba4 <___vfprintf_internal_r+0x128c>
   110ec:	bd84b03a 	or	r2,r23,r22
   110f0:	10032a26 	beq	r2,zero,11d9c <___vfprintf_internal_r+0x1484>
   110f4:	00c00c04 	movi	r3,48
   110f8:	d8c12505 	stb	r3,1172(sp)
   110fc:	dc812545 	stb	r18,1173(sp)
   11100:	84000094 	ori	r16,r16,2
   11104:	00c00084 	movi	r3,2
   11108:	d8012585 	stb	zero,1174(sp)
   1110c:	003ed906 	br	10c74 <___vfprintf_internal_r+0x35c>
   11110:	84001014 	ori	r16,r16,64
   11114:	ac800007 	ldb	r18,0(r21)
   11118:	003e5d06 	br	10a90 <___vfprintf_internal_r+0x178>
   1111c:	ac800007 	ldb	r18,0(r21)
   11120:	a805883a 	mov	r2,r21
   11124:	91c43226 	beq	r18,r7,121f0 <___vfprintf_internal_r+0x18d8>
   11128:	84000414 	ori	r16,r16,16
   1112c:	003e5806 	br	10a90 <___vfprintf_internal_r+0x178>
   11130:	d8c12d17 	ldw	r3,1204(sp)
   11134:	02000044 	movi	r8,1
   11138:	da012815 	stw	r8,1184(sp)
   1113c:	18800017 	ldw	r2,0(r3)
   11140:	18c00104 	addi	r3,r3,4
   11144:	d8012585 	stb	zero,1174(sp)
   11148:	d8810405 	stb	r2,1040(sp)
   1114c:	d8c12d15 	stw	r3,1204(sp)
   11150:	da012b15 	stw	r8,1196(sp)
   11154:	dcc10404 	addi	r19,sp,1040
   11158:	d8013115 	stw	zero,1220(sp)
   1115c:	003ee006 	br	10ce0 <___vfprintf_internal_r+0x3c8>
   11160:	8080080c 	andi	r2,r16,32
   11164:	10031026 	beq	r2,zero,11da8 <___vfprintf_internal_r+0x1490>
   11168:	d9012d17 	ldw	r4,1204(sp)
   1116c:	da012c17 	ldw	r8,1200(sp)
   11170:	20800017 	ldw	r2,0(r4)
   11174:	4007d7fa 	srai	r3,r8,31
   11178:	21000104 	addi	r4,r4,4
   1117c:	d9012d15 	stw	r4,1204(sp)
   11180:	12000015 	stw	r8,0(r2)
   11184:	10c00115 	stw	r3,4(r2)
   11188:	003e1906 	br	109f0 <___vfprintf_internal_r+0xd8>
   1118c:	da012d17 	ldw	r8,1204(sp)
   11190:	d9012d17 	ldw	r4,1204(sp)
   11194:	42000017 	ldw	r8,0(r8)
   11198:	20800104 	addi	r2,r4,4
   1119c:	da012e15 	stw	r8,1208(sp)
   111a0:	403f2f16 	blt	r8,zero,10e60 <___vfprintf_internal_r+0x548>
   111a4:	d8812d15 	stw	r2,1204(sp)
   111a8:	ac800007 	ldb	r18,0(r21)
   111ac:	003e3806 	br	10a90 <___vfprintf_internal_r+0x178>
   111b0:	0009883a 	mov	r4,zero
   111b4:	90bff404 	addi	r2,r18,-48
   111b8:	ac800007 	ldb	r18,0(r21)
   111bc:	210002a4 	muli	r4,r4,10
   111c0:	ad400044 	addi	r21,r21,1
   111c4:	2089883a 	add	r4,r4,r2
   111c8:	90bff404 	addi	r2,r18,-48
   111cc:	28bffa2e 	bgeu	r5,r2,111b8 <___vfprintf_internal_r+0x8a0>
   111d0:	d9012e15 	stw	r4,1208(sp)
   111d4:	003e2f06 	br	10a94 <___vfprintf_internal_r+0x17c>
   111d8:	8080020c 	andi	r2,r16,8
   111dc:	1002d426 	beq	r2,zero,11d30 <___vfprintf_internal_r+0x1418>
   111e0:	d8c12d17 	ldw	r3,1204(sp)
   111e4:	1d800017 	ldw	r22,0(r3)
   111e8:	1d000117 	ldw	r20,4(r3)
   111ec:	18c00204 	addi	r3,r3,8
   111f0:	d8c12d15 	stw	r3,1204(sp)
   111f4:	dd813315 	stw	r22,1228(sp)
   111f8:	dd013415 	stw	r20,1232(sp)
   111fc:	b009883a 	mov	r4,r22
   11200:	a00b883a 	mov	r5,r20
   11204:	da413c15 	stw	r9,1264(sp)
   11208:	00173300 	call	17330 <__isinfd>
   1120c:	da413c17 	ldw	r9,1264(sp)
   11210:	b009883a 	mov	r4,r22
   11214:	a00b883a 	mov	r5,r20
   11218:	10035726 	beq	r2,zero,11f78 <___vfprintf_internal_r+0x1660>
   1121c:	000d883a 	mov	r6,zero
   11220:	000f883a 	mov	r7,zero
   11224:	00186280 	call	18628 <__ltdf2>
   11228:	da413c17 	ldw	r9,1264(sp)
   1122c:	10041b16 	blt	r2,zero,1229c <___vfprintf_internal_r+0x1984>
   11230:	d8812583 	ldbu	r2,1174(sp)
   11234:	00c011c4 	movi	r3,71
   11238:	1c830b16 	blt	r3,r18,11e68 <___vfprintf_internal_r+0x1550>
   1123c:	04c000b4 	movhi	r19,2
   11240:	9cd82b04 	addi	r19,r19,24748
   11244:	020000c4 	movi	r8,3
   11248:	00ffdfc4 	movi	r3,-129
   1124c:	da012815 	stw	r8,1184(sp)
   11250:	80e0703a 	and	r16,r16,r3
   11254:	da012b15 	stw	r8,1196(sp)
   11258:	d8013115 	stw	zero,1220(sp)
   1125c:	003e9906 	br	10cc4 <___vfprintf_internal_r+0x3ac>
   11260:	d8812d17 	ldw	r2,1204(sp)
   11264:	d8c12d17 	ldw	r3,1204(sp)
   11268:	020000b4 	movhi	r8,2
   1126c:	42183404 	addi	r8,r8,24784
   11270:	15c00017 	ldw	r23,0(r2)
   11274:	00800c04 	movi	r2,48
   11278:	18c00104 	addi	r3,r3,4
   1127c:	d8812505 	stb	r2,1172(sp)
   11280:	00801e04 	movi	r2,120
   11284:	d8812545 	stb	r2,1173(sp)
   11288:	d8c12d15 	stw	r3,1204(sp)
   1128c:	002d883a 	mov	r22,zero
   11290:	84000094 	ori	r16,r16,2
   11294:	da013615 	stw	r8,1240(sp)
   11298:	00c00084 	movi	r3,2
   1129c:	04801e04 	movi	r18,120
   112a0:	b805883a 	mov	r2,r23
   112a4:	d8012585 	stb	zero,1174(sp)
   112a8:	003e7206 	br	10c74 <___vfprintf_internal_r+0x35c>
   112ac:	84000814 	ori	r16,r16,32
   112b0:	ac800007 	ldb	r18,0(r21)
   112b4:	003df606 	br	10a90 <___vfprintf_internal_r+0x178>
   112b8:	d8812d17 	ldw	r2,1204(sp)
   112bc:	d8012585 	stb	zero,1174(sp)
   112c0:	14c00017 	ldw	r19,0(r2)
   112c4:	15c00104 	addi	r23,r2,4
   112c8:	98040126 	beq	r19,zero,122d0 <___vfprintf_internal_r+0x19b8>
   112cc:	9809883a 	mov	r4,r19
   112d0:	e003dd16 	blt	fp,zero,12248 <___vfprintf_internal_r+0x1930>
   112d4:	000b883a 	mov	r5,zero
   112d8:	e00d883a 	mov	r6,fp
   112dc:	da413c15 	stw	r9,1264(sp)
   112e0:	0015b6c0 	call	15b6c <memchr>
   112e4:	da413c17 	ldw	r9,1264(sp)
   112e8:	10042e26 	beq	r2,zero,123a4 <___vfprintf_internal_r+0x1a8c>
   112ec:	14c5c83a 	sub	r2,r2,r19
   112f0:	d8812b15 	stw	r2,1196(sp)
   112f4:	e083790e 	bge	fp,r2,120dc <___vfprintf_internal_r+0x17c4>
   112f8:	df012815 	stw	fp,1184(sp)
   112fc:	e0049516 	blt	fp,zero,12554 <___vfprintf_internal_r+0x1c3c>
   11300:	d8812583 	ldbu	r2,1174(sp)
   11304:	df012b15 	stw	fp,1196(sp)
   11308:	ddc12d15 	stw	r23,1204(sp)
   1130c:	d8013115 	stw	zero,1220(sp)
   11310:	003e6c06 	br	10cc4 <___vfprintf_internal_r+0x3ac>
   11314:	020000b4 	movhi	r8,2
   11318:	42183404 	addi	r8,r8,24784
   1131c:	da013615 	stw	r8,1240(sp)
   11320:	8080080c 	andi	r2,r16,32
   11324:	103f6a1e 	bne	r2,zero,110d0 <___vfprintf_internal_r+0x7b8>
   11328:	8080040c 	andi	r2,r16,16
   1132c:	10029326 	beq	r2,zero,11d7c <___vfprintf_internal_r+0x1464>
   11330:	d8c12d17 	ldw	r3,1204(sp)
   11334:	002d883a 	mov	r22,zero
   11338:	1dc00017 	ldw	r23,0(r3)
   1133c:	18c00104 	addi	r3,r3,4
   11340:	d8c12d15 	stw	r3,1204(sp)
   11344:	003f6706 	br	110e4 <___vfprintf_internal_r+0x7cc>
   11348:	84000214 	ori	r16,r16,8
   1134c:	ac800007 	ldb	r18,0(r21)
   11350:	003dcf06 	br	10a90 <___vfprintf_internal_r+0x178>
   11354:	da011d17 	ldw	r8,1140(sp)
   11358:	d8c11c17 	ldw	r3,1136(sp)
   1135c:	d8812587 	ldb	r2,1174(sp)
   11360:	10000b26 	beq	r2,zero,11390 <___vfprintf_internal_r+0xa78>
   11364:	d8812584 	addi	r2,sp,1174
   11368:	48800015 	stw	r2,0(r9)
   1136c:	00800044 	movi	r2,1
   11370:	48800115 	stw	r2,4(r9)
   11374:	4091883a 	add	r8,r8,r2
   11378:	1887883a 	add	r3,r3,r2
   1137c:	da011d15 	stw	r8,1140(sp)
   11380:	d8c11c15 	stw	r3,1136(sp)
   11384:	008001c4 	movi	r2,7
   11388:	10c18516 	blt	r2,r3,119a0 <___vfprintf_internal_r+0x1088>
   1138c:	4a400204 	addi	r9,r9,8
   11390:	d9012a17 	ldw	r4,1192(sp)
   11394:	20000b26 	beq	r4,zero,113c4 <___vfprintf_internal_r+0xaac>
   11398:	d8812504 	addi	r2,sp,1172
   1139c:	48800015 	stw	r2,0(r9)
   113a0:	00800084 	movi	r2,2
   113a4:	48800115 	stw	r2,4(r9)
   113a8:	4091883a 	add	r8,r8,r2
   113ac:	18c00044 	addi	r3,r3,1
   113b0:	da011d15 	stw	r8,1140(sp)
   113b4:	d8c11c15 	stw	r3,1136(sp)
   113b8:	008001c4 	movi	r2,7
   113bc:	10c18116 	blt	r2,r3,119c4 <___vfprintf_internal_r+0x10ac>
   113c0:	4a400204 	addi	r9,r9,8
   113c4:	d9012f17 	ldw	r4,1212(sp)
   113c8:	00802004 	movi	r2,128
   113cc:	2080fc26 	beq	r4,r2,117c0 <___vfprintf_internal_r+0xea8>
   113d0:	d8813117 	ldw	r2,1220(sp)
   113d4:	d9012b17 	ldw	r4,1196(sp)
   113d8:	112fc83a 	sub	r23,r2,r4
   113dc:	05c02a0e 	bge	zero,r23,11488 <___vfprintf_internal_r+0xb70>
   113e0:	07000404 	movi	fp,16
   113e4:	050000b4 	movhi	r20,2
   113e8:	a5183ec4 	addi	r20,r20,24827
   113ec:	e5c01d0e 	bge	fp,r23,11464 <___vfprintf_internal_r+0xb4c>
   113f0:	dc812a15 	stw	r18,1192(sp)
   113f4:	058001c4 	movi	r22,7
   113f8:	a025883a 	mov	r18,r20
   113fc:	8029883a 	mov	r20,r16
   11400:	dc012917 	ldw	r16,1188(sp)
   11404:	00000306 	br	11414 <___vfprintf_internal_r+0xafc>
   11408:	bdfffc04 	addi	r23,r23,-16
   1140c:	4a400204 	addi	r9,r9,8
   11410:	e5c0110e 	bge	fp,r23,11458 <___vfprintf_internal_r+0xb40>
   11414:	4c800015 	stw	r18,0(r9)
   11418:	4f000115 	stw	fp,4(r9)
   1141c:	42000404 	addi	r8,r8,16
   11420:	18c00044 	addi	r3,r3,1
   11424:	da011d15 	stw	r8,1140(sp)
   11428:	d8c11c15 	stw	r3,1136(sp)
   1142c:	b0fff60e 	bge	r22,r3,11408 <___vfprintf_internal_r+0xaf0>
   11430:	8809883a 	mov	r4,r17
   11434:	800b883a 	mov	r5,r16
   11438:	d9811b04 	addi	r6,sp,1132
   1143c:	00108e40 	call	108e4 <__sprint_r>
   11440:	103ec81e 	bne	r2,zero,10f64 <___vfprintf_internal_r+0x64c>
   11444:	bdfffc04 	addi	r23,r23,-16
   11448:	da011d17 	ldw	r8,1140(sp)
   1144c:	d8c11c17 	ldw	r3,1136(sp)
   11450:	da400404 	addi	r9,sp,16
   11454:	e5ffef16 	blt	fp,r23,11414 <___vfprintf_internal_r+0xafc>
   11458:	a021883a 	mov	r16,r20
   1145c:	9029883a 	mov	r20,r18
   11460:	dc812a17 	ldw	r18,1192(sp)
   11464:	4d000015 	stw	r20,0(r9)
   11468:	4dc00115 	stw	r23,4(r9)
   1146c:	45d1883a 	add	r8,r8,r23
   11470:	18c00044 	addi	r3,r3,1
   11474:	da011d15 	stw	r8,1140(sp)
   11478:	d8c11c15 	stw	r3,1136(sp)
   1147c:	008001c4 	movi	r2,7
   11480:	10c13e16 	blt	r2,r3,1197c <___vfprintf_internal_r+0x1064>
   11484:	4a400204 	addi	r9,r9,8
   11488:	8080400c 	andi	r2,r16,256
   1148c:	1000831e 	bne	r2,zero,1169c <___vfprintf_internal_r+0xd84>
   11490:	d8812b17 	ldw	r2,1196(sp)
   11494:	4cc00015 	stw	r19,0(r9)
   11498:	48800115 	stw	r2,4(r9)
   1149c:	4091883a 	add	r8,r8,r2
   114a0:	18c00044 	addi	r3,r3,1
   114a4:	da011d15 	stw	r8,1140(sp)
   114a8:	d8c11c15 	stw	r3,1136(sp)
   114ac:	008001c4 	movi	r2,7
   114b0:	10c05316 	blt	r2,r3,11600 <___vfprintf_internal_r+0xce8>
   114b4:	4a400204 	addi	r9,r9,8
   114b8:	8400010c 	andi	r16,r16,4
   114bc:	80002e26 	beq	r16,zero,11578 <___vfprintf_internal_r+0xc60>
   114c0:	d8812e17 	ldw	r2,1208(sp)
   114c4:	d8c12817 	ldw	r3,1184(sp)
   114c8:	10e1c83a 	sub	r16,r2,r3
   114cc:	04002a0e 	bge	zero,r16,11578 <___vfprintf_internal_r+0xc60>
   114d0:	04800404 	movi	r18,16
   114d4:	d8c11c17 	ldw	r3,1136(sp)
   114d8:	05c000b4 	movhi	r23,2
   114dc:	bdd83ac4 	addi	r23,r23,24811
   114e0:	9400170e 	bge	r18,r16,11540 <___vfprintf_internal_r+0xc28>
   114e4:	04c001c4 	movi	r19,7
   114e8:	dd012917 	ldw	r20,1188(sp)
   114ec:	00000306 	br	114fc <___vfprintf_internal_r+0xbe4>
   114f0:	843ffc04 	addi	r16,r16,-16
   114f4:	4a400204 	addi	r9,r9,8
   114f8:	9400110e 	bge	r18,r16,11540 <___vfprintf_internal_r+0xc28>
   114fc:	4dc00015 	stw	r23,0(r9)
   11500:	4c800115 	stw	r18,4(r9)
   11504:	42000404 	addi	r8,r8,16
   11508:	18c00044 	addi	r3,r3,1
   1150c:	da011d15 	stw	r8,1140(sp)
   11510:	d8c11c15 	stw	r3,1136(sp)
   11514:	98fff60e 	bge	r19,r3,114f0 <___vfprintf_internal_r+0xbd8>
   11518:	8809883a 	mov	r4,r17
   1151c:	a00b883a 	mov	r5,r20
   11520:	d9811b04 	addi	r6,sp,1132
   11524:	00108e40 	call	108e4 <__sprint_r>
   11528:	103e8e1e 	bne	r2,zero,10f64 <___vfprintf_internal_r+0x64c>
   1152c:	843ffc04 	addi	r16,r16,-16
   11530:	da011d17 	ldw	r8,1140(sp)
   11534:	d8c11c17 	ldw	r3,1136(sp)
   11538:	da400404 	addi	r9,sp,16
   1153c:	943fef16 	blt	r18,r16,114fc <___vfprintf_internal_r+0xbe4>
   11540:	4dc00015 	stw	r23,0(r9)
   11544:	4c000115 	stw	r16,4(r9)
   11548:	8211883a 	add	r8,r16,r8
   1154c:	18c00044 	addi	r3,r3,1
   11550:	da011d15 	stw	r8,1140(sp)
   11554:	d8c11c15 	stw	r3,1136(sp)
   11558:	008001c4 	movi	r2,7
   1155c:	10c0060e 	bge	r2,r3,11578 <___vfprintf_internal_r+0xc60>
   11560:	d9412917 	ldw	r5,1188(sp)
   11564:	8809883a 	mov	r4,r17
   11568:	d9811b04 	addi	r6,sp,1132
   1156c:	00108e40 	call	108e4 <__sprint_r>
   11570:	103e7c1e 	bne	r2,zero,10f64 <___vfprintf_internal_r+0x64c>
   11574:	da011d17 	ldw	r8,1140(sp)
   11578:	dd012817 	ldw	r20,1184(sp)
   1157c:	d9012e17 	ldw	r4,1208(sp)
   11580:	a100010e 	bge	r20,r4,11588 <___vfprintf_internal_r+0xc70>
   11584:	2029883a 	mov	r20,r4
   11588:	d8812c17 	ldw	r2,1200(sp)
   1158c:	1505883a 	add	r2,r2,r20
   11590:	d8812c15 	stw	r2,1200(sp)
   11594:	4000b91e 	bne	r8,zero,1187c <___vfprintf_internal_r+0xf64>
   11598:	d8011c15 	stw	zero,1136(sp)
   1159c:	a8800007 	ldb	r2,0(r21)
   115a0:	da400404 	addi	r9,sp,16
   115a4:	103d141e 	bne	r2,zero,109f8 <___vfprintf_internal_r+0xe0>
   115a8:	a825883a 	mov	r18,r21
   115ac:	003d2a06 	br	10a58 <___vfprintf_internal_r+0x140>
   115b0:	d9412917 	ldw	r5,1188(sp)
   115b4:	8809883a 	mov	r4,r17
   115b8:	d9811b04 	addi	r6,sp,1132
   115bc:	00108e40 	call	108e4 <__sprint_r>
   115c0:	103e681e 	bne	r2,zero,10f64 <___vfprintf_internal_r+0x64c>
   115c4:	da011d17 	ldw	r8,1140(sp)
   115c8:	da400404 	addi	r9,sp,16
   115cc:	8080004c 	andi	r2,r16,1
   115d0:	103fb926 	beq	r2,zero,114b8 <___vfprintf_internal_r+0xba0>
   115d4:	d8c11c17 	ldw	r3,1136(sp)
   115d8:	d9013717 	ldw	r4,1244(sp)
   115dc:	00800044 	movi	r2,1
   115e0:	48800115 	stw	r2,4(r9)
   115e4:	49000015 	stw	r4,0(r9)
   115e8:	4091883a 	add	r8,r8,r2
   115ec:	1887883a 	add	r3,r3,r2
   115f0:	da011d15 	stw	r8,1140(sp)
   115f4:	d8c11c15 	stw	r3,1136(sp)
   115f8:	008001c4 	movi	r2,7
   115fc:	10ffad0e 	bge	r2,r3,114b4 <___vfprintf_internal_r+0xb9c>
   11600:	d9412917 	ldw	r5,1188(sp)
   11604:	8809883a 	mov	r4,r17
   11608:	d9811b04 	addi	r6,sp,1132
   1160c:	00108e40 	call	108e4 <__sprint_r>
   11610:	103e541e 	bne	r2,zero,10f64 <___vfprintf_internal_r+0x64c>
   11614:	da400404 	addi	r9,sp,16
   11618:	da011d17 	ldw	r8,1140(sp)
   1161c:	003fa606 	br	114b8 <___vfprintf_internal_r+0xba0>
   11620:	18803fcc 	andi	r2,r3,255
   11624:	00c00044 	movi	r3,1
   11628:	10c10126 	beq	r2,r3,11a30 <___vfprintf_internal_r+0x1118>
   1162c:	00c00084 	movi	r3,2
   11630:	10c0f026 	beq	r2,r3,119f4 <___vfprintf_internal_r+0x10dc>
   11634:	d8c10dc4 	addi	r3,sp,1079
   11638:	b808d0fa 	srli	r4,r23,3
   1163c:	b00a977a 	slli	r5,r22,29
   11640:	b02cd0fa 	srli	r22,r22,3
   11644:	bdc001cc 	andi	r23,r23,7
   11648:	b8800c04 	addi	r2,r23,48
   1164c:	292eb03a 	or	r23,r5,r4
   11650:	18800005 	stb	r2,0(r3)
   11654:	bd88b03a 	or	r4,r23,r22
   11658:	1827883a 	mov	r19,r3
   1165c:	18ffffc4 	addi	r3,r3,-1
   11660:	203ff51e 	bne	r4,zero,11638 <___vfprintf_internal_r+0xd20>
   11664:	8100004c 	andi	r4,r16,1
   11668:	980b883a 	mov	r5,r19
   1166c:	20000726 	beq	r4,zero,1168c <___vfprintf_internal_r+0xd74>
   11670:	10803fcc 	andi	r2,r2,255
   11674:	1080201c 	xori	r2,r2,128
   11678:	10bfe004 	addi	r2,r2,-128
   1167c:	01000c04 	movi	r4,48
   11680:	11000226 	beq	r2,r4,1168c <___vfprintf_internal_r+0xd74>
   11684:	1827883a 	mov	r19,r3
   11688:	293fffc5 	stb	r4,-1(r5)
   1168c:	d8812717 	ldw	r2,1180(sp)
   11690:	14c5c83a 	sub	r2,r2,r19
   11694:	d8812b15 	stw	r2,1196(sp)
   11698:	003d8406 	br	10cac <___vfprintf_internal_r+0x394>
   1169c:	00801944 	movi	r2,101
   116a0:	14807c0e 	bge	r2,r18,11894 <___vfprintf_internal_r+0xf7c>
   116a4:	d9013317 	ldw	r4,1228(sp)
   116a8:	d9413417 	ldw	r5,1232(sp)
   116ac:	000d883a 	mov	r6,zero
   116b0:	000f883a 	mov	r7,zero
   116b4:	d8c13b15 	stw	r3,1260(sp)
   116b8:	da013a15 	stw	r8,1256(sp)
   116bc:	da413c15 	stw	r9,1264(sp)
   116c0:	001850c0 	call	1850c <__eqdf2>
   116c4:	d8c13b17 	ldw	r3,1260(sp)
   116c8:	da013a17 	ldw	r8,1256(sp)
   116cc:	da413c17 	ldw	r9,1264(sp)
   116d0:	1001001e 	bne	r2,zero,11ad4 <___vfprintf_internal_r+0x11bc>
   116d4:	008000b4 	movhi	r2,2
   116d8:	1096d204 	addi	r2,r2,23368
   116dc:	48800015 	stw	r2,0(r9)
   116e0:	00800044 	movi	r2,1
   116e4:	48800115 	stw	r2,4(r9)
   116e8:	4091883a 	add	r8,r8,r2
   116ec:	1887883a 	add	r3,r3,r2
   116f0:	da011d15 	stw	r8,1140(sp)
   116f4:	d8c11c15 	stw	r3,1136(sp)
   116f8:	008001c4 	movi	r2,7
   116fc:	10c1dd16 	blt	r2,r3,11e74 <___vfprintf_internal_r+0x155c>
   11700:	4a400204 	addi	r9,r9,8
   11704:	d8812417 	ldw	r2,1168(sp)
   11708:	d8c13217 	ldw	r3,1224(sp)
   1170c:	10c00216 	blt	r2,r3,11718 <___vfprintf_internal_r+0xe00>
   11710:	8080004c 	andi	r2,r16,1
   11714:	103f6826 	beq	r2,zero,114b8 <___vfprintf_internal_r+0xba0>
   11718:	d8c11c17 	ldw	r3,1136(sp)
   1171c:	d9013717 	ldw	r4,1244(sp)
   11720:	00800044 	movi	r2,1
   11724:	48800115 	stw	r2,4(r9)
   11728:	49000015 	stw	r4,0(r9)
   1172c:	4091883a 	add	r8,r8,r2
   11730:	1887883a 	add	r3,r3,r2
   11734:	da011d15 	stw	r8,1140(sp)
   11738:	d8c11c15 	stw	r3,1136(sp)
   1173c:	008001c4 	movi	r2,7
   11740:	10c2af16 	blt	r2,r3,12200 <___vfprintf_internal_r+0x18e8>
   11744:	4a400204 	addi	r9,r9,8
   11748:	d8813217 	ldw	r2,1224(sp)
   1174c:	14bfffc4 	addi	r18,r2,-1
   11750:	04bf590e 	bge	zero,r18,114b8 <___vfprintf_internal_r+0xba0>
   11754:	04c00404 	movi	r19,16
   11758:	d8c11c17 	ldw	r3,1136(sp)
   1175c:	050000b4 	movhi	r20,2
   11760:	a5183ec4 	addi	r20,r20,24827
   11764:	9c81630e 	bge	r19,r18,11cf4 <___vfprintf_internal_r+0x13dc>
   11768:	058001c4 	movi	r22,7
   1176c:	ddc12917 	ldw	r23,1188(sp)
   11770:	00000306 	br	11780 <___vfprintf_internal_r+0xe68>
   11774:	4a400204 	addi	r9,r9,8
   11778:	94bffc04 	addi	r18,r18,-16
   1177c:	9c815d0e 	bge	r19,r18,11cf4 <___vfprintf_internal_r+0x13dc>
   11780:	4d000015 	stw	r20,0(r9)
   11784:	4cc00115 	stw	r19,4(r9)
   11788:	42000404 	addi	r8,r8,16
   1178c:	18c00044 	addi	r3,r3,1
   11790:	da011d15 	stw	r8,1140(sp)
   11794:	d8c11c15 	stw	r3,1136(sp)
   11798:	b0fff60e 	bge	r22,r3,11774 <___vfprintf_internal_r+0xe5c>
   1179c:	8809883a 	mov	r4,r17
   117a0:	b80b883a 	mov	r5,r23
   117a4:	d9811b04 	addi	r6,sp,1132
   117a8:	00108e40 	call	108e4 <__sprint_r>
   117ac:	103ded1e 	bne	r2,zero,10f64 <___vfprintf_internal_r+0x64c>
   117b0:	da011d17 	ldw	r8,1140(sp)
   117b4:	d8c11c17 	ldw	r3,1136(sp)
   117b8:	da400404 	addi	r9,sp,16
   117bc:	003fee06 	br	11778 <___vfprintf_internal_r+0xe60>
   117c0:	d8812e17 	ldw	r2,1208(sp)
   117c4:	d9012817 	ldw	r4,1184(sp)
   117c8:	112fc83a 	sub	r23,r2,r4
   117cc:	05ff000e 	bge	zero,r23,113d0 <___vfprintf_internal_r+0xab8>
   117d0:	07000404 	movi	fp,16
   117d4:	050000b4 	movhi	r20,2
   117d8:	a5183ec4 	addi	r20,r20,24827
   117dc:	e5c01d0e 	bge	fp,r23,11854 <___vfprintf_internal_r+0xf3c>
   117e0:	dc812a15 	stw	r18,1192(sp)
   117e4:	058001c4 	movi	r22,7
   117e8:	a025883a 	mov	r18,r20
   117ec:	8029883a 	mov	r20,r16
   117f0:	dc012917 	ldw	r16,1188(sp)
   117f4:	00000306 	br	11804 <___vfprintf_internal_r+0xeec>
   117f8:	bdfffc04 	addi	r23,r23,-16
   117fc:	4a400204 	addi	r9,r9,8
   11800:	e5c0110e 	bge	fp,r23,11848 <___vfprintf_internal_r+0xf30>
   11804:	4c800015 	stw	r18,0(r9)
   11808:	4f000115 	stw	fp,4(r9)
   1180c:	42000404 	addi	r8,r8,16
   11810:	18c00044 	addi	r3,r3,1
   11814:	da011d15 	stw	r8,1140(sp)
   11818:	d8c11c15 	stw	r3,1136(sp)
   1181c:	b0fff60e 	bge	r22,r3,117f8 <___vfprintf_internal_r+0xee0>
   11820:	8809883a 	mov	r4,r17
   11824:	800b883a 	mov	r5,r16
   11828:	d9811b04 	addi	r6,sp,1132
   1182c:	00108e40 	call	108e4 <__sprint_r>
   11830:	103dcc1e 	bne	r2,zero,10f64 <___vfprintf_internal_r+0x64c>
   11834:	bdfffc04 	addi	r23,r23,-16
   11838:	da011d17 	ldw	r8,1140(sp)
   1183c:	d8c11c17 	ldw	r3,1136(sp)
   11840:	da400404 	addi	r9,sp,16
   11844:	e5ffef16 	blt	fp,r23,11804 <___vfprintf_internal_r+0xeec>
   11848:	a021883a 	mov	r16,r20
   1184c:	9029883a 	mov	r20,r18
   11850:	dc812a17 	ldw	r18,1192(sp)
   11854:	4d000015 	stw	r20,0(r9)
   11858:	4dc00115 	stw	r23,4(r9)
   1185c:	45d1883a 	add	r8,r8,r23
   11860:	18c00044 	addi	r3,r3,1
   11864:	da011d15 	stw	r8,1140(sp)
   11868:	d8c11c15 	stw	r3,1136(sp)
   1186c:	008001c4 	movi	r2,7
   11870:	10c11716 	blt	r2,r3,11cd0 <___vfprintf_internal_r+0x13b8>
   11874:	4a400204 	addi	r9,r9,8
   11878:	003ed506 	br	113d0 <___vfprintf_internal_r+0xab8>
   1187c:	d9412917 	ldw	r5,1188(sp)
   11880:	8809883a 	mov	r4,r17
   11884:	d9811b04 	addi	r6,sp,1132
   11888:	00108e40 	call	108e4 <__sprint_r>
   1188c:	103f4226 	beq	r2,zero,11598 <___vfprintf_internal_r+0xc80>
   11890:	003db406 	br	10f64 <___vfprintf_internal_r+0x64c>
   11894:	d9013217 	ldw	r4,1224(sp)
   11898:	00800044 	movi	r2,1
   1189c:	4cc00015 	stw	r19,0(r9)
   118a0:	1100e10e 	bge	r2,r4,11c28 <___vfprintf_internal_r+0x1310>
   118a4:	00800044 	movi	r2,1
   118a8:	48800115 	stw	r2,4(r9)
   118ac:	4091883a 	add	r8,r8,r2
   118b0:	1887883a 	add	r3,r3,r2
   118b4:	da011d15 	stw	r8,1140(sp)
   118b8:	d8c11c15 	stw	r3,1136(sp)
   118bc:	008001c4 	movi	r2,7
   118c0:	10c0ed16 	blt	r2,r3,11c78 <___vfprintf_internal_r+0x1360>
   118c4:	4a400204 	addi	r9,r9,8
   118c8:	d8813717 	ldw	r2,1244(sp)
   118cc:	48800015 	stw	r2,0(r9)
   118d0:	00800044 	movi	r2,1
   118d4:	48800115 	stw	r2,4(r9)
   118d8:	4091883a 	add	r8,r8,r2
   118dc:	1887883a 	add	r3,r3,r2
   118e0:	da011d15 	stw	r8,1140(sp)
   118e4:	d8c11c15 	stw	r3,1136(sp)
   118e8:	008001c4 	movi	r2,7
   118ec:	10c0eb16 	blt	r2,r3,11c9c <___vfprintf_internal_r+0x1384>
   118f0:	4c800204 	addi	r18,r9,8
   118f4:	d9013317 	ldw	r4,1228(sp)
   118f8:	d9413417 	ldw	r5,1232(sp)
   118fc:	000d883a 	mov	r6,zero
   11900:	000f883a 	mov	r7,zero
   11904:	d8c13b15 	stw	r3,1260(sp)
   11908:	da013a15 	stw	r8,1256(sp)
   1190c:	00185680 	call	18568 <__nedf2>
   11910:	d8c13b17 	ldw	r3,1260(sp)
   11914:	da013a17 	ldw	r8,1256(sp)
   11918:	1000a626 	beq	r2,zero,11bb4 <___vfprintf_internal_r+0x129c>
   1191c:	d9013217 	ldw	r4,1224(sp)
   11920:	9cc00044 	addi	r19,r19,1
   11924:	94c00015 	stw	r19,0(r18)
   11928:	20bfffc4 	addi	r2,r4,-1
   1192c:	90800115 	stw	r2,4(r18)
   11930:	4091883a 	add	r8,r8,r2
   11934:	18c00044 	addi	r3,r3,1
   11938:	da011d15 	stw	r8,1140(sp)
   1193c:	d8c11c15 	stw	r3,1136(sp)
   11940:	008001c4 	movi	r2,7
   11944:	10c0c316 	blt	r2,r3,11c54 <___vfprintf_internal_r+0x133c>
   11948:	94800204 	addi	r18,r18,8
   1194c:	d9013517 	ldw	r4,1236(sp)
   11950:	d8811fc4 	addi	r2,sp,1151
   11954:	90800015 	stw	r2,0(r18)
   11958:	91000115 	stw	r4,4(r18)
   1195c:	4111883a 	add	r8,r8,r4
   11960:	18c00044 	addi	r3,r3,1
   11964:	da011d15 	stw	r8,1140(sp)
   11968:	d8c11c15 	stw	r3,1136(sp)
   1196c:	008001c4 	movi	r2,7
   11970:	10ff2316 	blt	r2,r3,11600 <___vfprintf_internal_r+0xce8>
   11974:	92400204 	addi	r9,r18,8
   11978:	003ecf06 	br	114b8 <___vfprintf_internal_r+0xba0>
   1197c:	d9412917 	ldw	r5,1188(sp)
   11980:	8809883a 	mov	r4,r17
   11984:	d9811b04 	addi	r6,sp,1132
   11988:	00108e40 	call	108e4 <__sprint_r>
   1198c:	103d751e 	bne	r2,zero,10f64 <___vfprintf_internal_r+0x64c>
   11990:	da011d17 	ldw	r8,1140(sp)
   11994:	d8c11c17 	ldw	r3,1136(sp)
   11998:	da400404 	addi	r9,sp,16
   1199c:	003eba06 	br	11488 <___vfprintf_internal_r+0xb70>
   119a0:	d9412917 	ldw	r5,1188(sp)
   119a4:	8809883a 	mov	r4,r17
   119a8:	d9811b04 	addi	r6,sp,1132
   119ac:	00108e40 	call	108e4 <__sprint_r>
   119b0:	103d6c1e 	bne	r2,zero,10f64 <___vfprintf_internal_r+0x64c>
   119b4:	da011d17 	ldw	r8,1140(sp)
   119b8:	d8c11c17 	ldw	r3,1136(sp)
   119bc:	da400404 	addi	r9,sp,16
   119c0:	003e7306 	br	11390 <___vfprintf_internal_r+0xa78>
   119c4:	d9412917 	ldw	r5,1188(sp)
   119c8:	8809883a 	mov	r4,r17
   119cc:	d9811b04 	addi	r6,sp,1132
   119d0:	00108e40 	call	108e4 <__sprint_r>
   119d4:	103d631e 	bne	r2,zero,10f64 <___vfprintf_internal_r+0x64c>
   119d8:	da011d17 	ldw	r8,1140(sp)
   119dc:	d8c11c17 	ldw	r3,1136(sp)
   119e0:	da400404 	addi	r9,sp,16
   119e4:	003e7706 	br	113c4 <___vfprintf_internal_r+0xaac>
   119e8:	d8012b15 	stw	zero,1196(sp)
   119ec:	dcc10e04 	addi	r19,sp,1080
   119f0:	003cae06 	br	10cac <___vfprintf_internal_r+0x394>
   119f4:	d9413617 	ldw	r5,1240(sp)
   119f8:	d8810dc4 	addi	r2,sp,1079
   119fc:	b8c003cc 	andi	r3,r23,15
   11a00:	b008973a 	slli	r4,r22,28
   11a04:	28c7883a 	add	r3,r5,r3
   11a08:	b82ed13a 	srli	r23,r23,4
   11a0c:	18c00003 	ldbu	r3,0(r3)
   11a10:	b02cd13a 	srli	r22,r22,4
   11a14:	25eeb03a 	or	r23,r4,r23
   11a18:	10c00005 	stb	r3,0(r2)
   11a1c:	bd86b03a 	or	r3,r23,r22
   11a20:	1027883a 	mov	r19,r2
   11a24:	10bfffc4 	addi	r2,r2,-1
   11a28:	183ff41e 	bne	r3,zero,119fc <___vfprintf_internal_r+0x10e4>
   11a2c:	003f1706 	br	1168c <___vfprintf_internal_r+0xd74>
   11a30:	b0025826 	beq	r22,zero,12394 <___vfprintf_internal_r+0x1a7c>
   11a34:	b807883a 	mov	r3,r23
   11a38:	d8810dc4 	addi	r2,sp,1079
   11a3c:	882f883a 	mov	r23,r17
   11a40:	04c00244 	movi	r19,9
   11a44:	8023883a 	mov	r17,r16
   11a48:	da412815 	stw	r9,1184(sp)
   11a4c:	1821883a 	mov	r16,r3
   11a50:	8009883a 	mov	r4,r16
   11a54:	b00b883a 	mov	r5,r22
   11a58:	01800284 	movi	r6,10
   11a5c:	000f883a 	mov	r7,zero
   11a60:	1029883a 	mov	r20,r2
   11a64:	0017f800 	call	17f80 <__umoddi3>
   11a68:	10800c04 	addi	r2,r2,48
   11a6c:	8009883a 	mov	r4,r16
   11a70:	b00b883a 	mov	r5,r22
   11a74:	a0800005 	stb	r2,0(r20)
   11a78:	01800284 	movi	r6,10
   11a7c:	000f883a 	mov	r7,zero
   11a80:	00179b80 	call	179b8 <__udivdi3>
   11a84:	1021883a 	mov	r16,r2
   11a88:	182d883a 	mov	r22,r3
   11a8c:	a0bfffc4 	addi	r2,r20,-1
   11a90:	183fef1e 	bne	r3,zero,11a50 <___vfprintf_internal_r+0x1138>
   11a94:	9c3fee36 	bltu	r19,r16,11a50 <___vfprintf_internal_r+0x1138>
   11a98:	da412817 	ldw	r9,1184(sp)
   11a9c:	8005883a 	mov	r2,r16
   11aa0:	8821883a 	mov	r16,r17
   11aa4:	b823883a 	mov	r17,r23
   11aa8:	102f883a 	mov	r23,r2
   11aac:	d8812717 	ldw	r2,1180(sp)
   11ab0:	a4ffffc4 	addi	r19,r20,-1
   11ab4:	bdc00c04 	addi	r23,r23,48
   11ab8:	14c5c83a 	sub	r2,r2,r19
   11abc:	a5ffffc5 	stb	r23,-1(r20)
   11ac0:	d8812b15 	stw	r2,1196(sp)
   11ac4:	003c7906 	br	10cac <___vfprintf_internal_r+0x394>
   11ac8:	00c00044 	movi	r3,1
   11acc:	bd84b03a 	or	r2,r23,r22
   11ad0:	003c6806 	br	10c74 <___vfprintf_internal_r+0x35c>
   11ad4:	dc812417 	ldw	r18,1168(sp)
   11ad8:	0480ee0e 	bge	zero,r18,11e94 <___vfprintf_internal_r+0x157c>
   11adc:	d9013217 	ldw	r4,1224(sp)
   11ae0:	4cc00015 	stw	r19,0(r9)
   11ae4:	9100c616 	blt	r18,r4,11e00 <___vfprintf_internal_r+0x14e8>
   11ae8:	49000115 	stw	r4,4(r9)
   11aec:	4111883a 	add	r8,r8,r4
   11af0:	18c00044 	addi	r3,r3,1
   11af4:	da011d15 	stw	r8,1140(sp)
   11af8:	d8c11c15 	stw	r3,1136(sp)
   11afc:	008001c4 	movi	r2,7
   11b00:	10c20916 	blt	r2,r3,12328 <___vfprintf_internal_r+0x1a10>
   11b04:	4a400204 	addi	r9,r9,8
   11b08:	d8813217 	ldw	r2,1224(sp)
   11b0c:	90a5c83a 	sub	r18,r18,r2
   11b10:	04beae0e 	bge	zero,r18,115cc <___vfprintf_internal_r+0xcb4>
   11b14:	04c00404 	movi	r19,16
   11b18:	d8c11c17 	ldw	r3,1136(sp)
   11b1c:	050000b4 	movhi	r20,2
   11b20:	a5183ec4 	addi	r20,r20,24827
   11b24:	9c81be0e 	bge	r19,r18,12220 <___vfprintf_internal_r+0x1908>
   11b28:	058001c4 	movi	r22,7
   11b2c:	ddc12917 	ldw	r23,1188(sp)
   11b30:	00000306 	br	11b40 <___vfprintf_internal_r+0x1228>
   11b34:	4a400204 	addi	r9,r9,8
   11b38:	94bffc04 	addi	r18,r18,-16
   11b3c:	9c81b80e 	bge	r19,r18,12220 <___vfprintf_internal_r+0x1908>
   11b40:	4d000015 	stw	r20,0(r9)
   11b44:	4cc00115 	stw	r19,4(r9)
   11b48:	42000404 	addi	r8,r8,16
   11b4c:	18c00044 	addi	r3,r3,1
   11b50:	da011d15 	stw	r8,1140(sp)
   11b54:	d8c11c15 	stw	r3,1136(sp)
   11b58:	b0fff60e 	bge	r22,r3,11b34 <___vfprintf_internal_r+0x121c>
   11b5c:	8809883a 	mov	r4,r17
   11b60:	b80b883a 	mov	r5,r23
   11b64:	d9811b04 	addi	r6,sp,1132
   11b68:	00108e40 	call	108e4 <__sprint_r>
   11b6c:	103cfd1e 	bne	r2,zero,10f64 <___vfprintf_internal_r+0x64c>
   11b70:	da011d17 	ldw	r8,1140(sp)
   11b74:	d8c11c17 	ldw	r3,1136(sp)
   11b78:	da400404 	addi	r9,sp,16
   11b7c:	003fee06 	br	11b38 <___vfprintf_internal_r+0x1220>
   11b80:	d9412917 	ldw	r5,1188(sp)
   11b84:	8809883a 	mov	r4,r17
   11b88:	d9811b04 	addi	r6,sp,1132
   11b8c:	00108e40 	call	108e4 <__sprint_r>
   11b90:	103cf41e 	bne	r2,zero,10f64 <___vfprintf_internal_r+0x64c>
   11b94:	da011d17 	ldw	r8,1140(sp)
   11b98:	d8c11c17 	ldw	r3,1136(sp)
   11b9c:	da400404 	addi	r9,sp,16
   11ba0:	003dee06 	br	1135c <___vfprintf_internal_r+0xa44>
   11ba4:	00c00084 	movi	r3,2
   11ba8:	bd84b03a 	or	r2,r23,r22
   11bac:	d8012585 	stb	zero,1174(sp)
   11bb0:	003c3006 	br	10c74 <___vfprintf_internal_r+0x35c>
   11bb4:	d8813217 	ldw	r2,1224(sp)
   11bb8:	14ffffc4 	addi	r19,r2,-1
   11bbc:	04ff630e 	bge	zero,r19,1194c <___vfprintf_internal_r+0x1034>
   11bc0:	05800404 	movi	r22,16
   11bc4:	050000b4 	movhi	r20,2
   11bc8:	a5183ec4 	addi	r20,r20,24827
   11bcc:	b4c03c0e 	bge	r22,r19,11cc0 <___vfprintf_internal_r+0x13a8>
   11bd0:	05c001c4 	movi	r23,7
   11bd4:	df012917 	ldw	fp,1188(sp)
   11bd8:	00000306 	br	11be8 <___vfprintf_internal_r+0x12d0>
   11bdc:	94800204 	addi	r18,r18,8
   11be0:	9cfffc04 	addi	r19,r19,-16
   11be4:	b4c0360e 	bge	r22,r19,11cc0 <___vfprintf_internal_r+0x13a8>
   11be8:	95000015 	stw	r20,0(r18)
   11bec:	95800115 	stw	r22,4(r18)
   11bf0:	42000404 	addi	r8,r8,16
   11bf4:	18c00044 	addi	r3,r3,1
   11bf8:	da011d15 	stw	r8,1140(sp)
   11bfc:	d8c11c15 	stw	r3,1136(sp)
   11c00:	b8fff60e 	bge	r23,r3,11bdc <___vfprintf_internal_r+0x12c4>
   11c04:	8809883a 	mov	r4,r17
   11c08:	e00b883a 	mov	r5,fp
   11c0c:	d9811b04 	addi	r6,sp,1132
   11c10:	00108e40 	call	108e4 <__sprint_r>
   11c14:	103cd31e 	bne	r2,zero,10f64 <___vfprintf_internal_r+0x64c>
   11c18:	da011d17 	ldw	r8,1140(sp)
   11c1c:	d8c11c17 	ldw	r3,1136(sp)
   11c20:	dc800404 	addi	r18,sp,16
   11c24:	003fee06 	br	11be0 <___vfprintf_internal_r+0x12c8>
   11c28:	8088703a 	and	r4,r16,r2
   11c2c:	203f1d1e 	bne	r4,zero,118a4 <___vfprintf_internal_r+0xf8c>
   11c30:	48800115 	stw	r2,4(r9)
   11c34:	42000044 	addi	r8,r8,1
   11c38:	18c00044 	addi	r3,r3,1
   11c3c:	da011d15 	stw	r8,1140(sp)
   11c40:	d8c11c15 	stw	r3,1136(sp)
   11c44:	008001c4 	movi	r2,7
   11c48:	10c00216 	blt	r2,r3,11c54 <___vfprintf_internal_r+0x133c>
   11c4c:	4c800204 	addi	r18,r9,8
   11c50:	003f3e06 	br	1194c <___vfprintf_internal_r+0x1034>
   11c54:	d9412917 	ldw	r5,1188(sp)
   11c58:	8809883a 	mov	r4,r17
   11c5c:	d9811b04 	addi	r6,sp,1132
   11c60:	00108e40 	call	108e4 <__sprint_r>
   11c64:	103cbf1e 	bne	r2,zero,10f64 <___vfprintf_internal_r+0x64c>
   11c68:	dc800404 	addi	r18,sp,16
   11c6c:	da011d17 	ldw	r8,1140(sp)
   11c70:	d8c11c17 	ldw	r3,1136(sp)
   11c74:	003f3506 	br	1194c <___vfprintf_internal_r+0x1034>
   11c78:	d9412917 	ldw	r5,1188(sp)
   11c7c:	8809883a 	mov	r4,r17
   11c80:	d9811b04 	addi	r6,sp,1132
   11c84:	00108e40 	call	108e4 <__sprint_r>
   11c88:	103cb61e 	bne	r2,zero,10f64 <___vfprintf_internal_r+0x64c>
   11c8c:	da011d17 	ldw	r8,1140(sp)
   11c90:	d8c11c17 	ldw	r3,1136(sp)
   11c94:	da400404 	addi	r9,sp,16
   11c98:	003f0b06 	br	118c8 <___vfprintf_internal_r+0xfb0>
   11c9c:	d9412917 	ldw	r5,1188(sp)
   11ca0:	8809883a 	mov	r4,r17
   11ca4:	d9811b04 	addi	r6,sp,1132
   11ca8:	00108e40 	call	108e4 <__sprint_r>
   11cac:	103cad1e 	bne	r2,zero,10f64 <___vfprintf_internal_r+0x64c>
   11cb0:	da011d17 	ldw	r8,1140(sp)
   11cb4:	d8c11c17 	ldw	r3,1136(sp)
   11cb8:	dc800404 	addi	r18,sp,16
   11cbc:	003f0d06 	br	118f4 <___vfprintf_internal_r+0xfdc>
   11cc0:	95000015 	stw	r20,0(r18)
   11cc4:	94c00115 	stw	r19,4(r18)
   11cc8:	44d1883a 	add	r8,r8,r19
   11ccc:	003f1906 	br	11934 <___vfprintf_internal_r+0x101c>
   11cd0:	d9412917 	ldw	r5,1188(sp)
   11cd4:	8809883a 	mov	r4,r17
   11cd8:	d9811b04 	addi	r6,sp,1132
   11cdc:	00108e40 	call	108e4 <__sprint_r>
   11ce0:	103ca01e 	bne	r2,zero,10f64 <___vfprintf_internal_r+0x64c>
   11ce4:	da011d17 	ldw	r8,1140(sp)
   11ce8:	d8c11c17 	ldw	r3,1136(sp)
   11cec:	da400404 	addi	r9,sp,16
   11cf0:	003db706 	br	113d0 <___vfprintf_internal_r+0xab8>
   11cf4:	4d000015 	stw	r20,0(r9)
   11cf8:	4c800115 	stw	r18,4(r9)
   11cfc:	4491883a 	add	r8,r8,r18
   11d00:	003de706 	br	114a0 <___vfprintf_internal_r+0xb88>
   11d04:	8080100c 	andi	r2,r16,64
   11d08:	10010226 	beq	r2,zero,12114 <___vfprintf_internal_r+0x17fc>
   11d0c:	d8812d17 	ldw	r2,1204(sp)
   11d10:	002d883a 	mov	r22,zero
   11d14:	00c00044 	movi	r3,1
   11d18:	15c0000b 	ldhu	r23,0(r2)
   11d1c:	10800104 	addi	r2,r2,4
   11d20:	d8812d15 	stw	r2,1204(sp)
   11d24:	d8012585 	stb	zero,1174(sp)
   11d28:	b805883a 	mov	r2,r23
   11d2c:	003bd106 	br	10c74 <___vfprintf_internal_r+0x35c>
   11d30:	d9012d17 	ldw	r4,1204(sp)
   11d34:	25800017 	ldw	r22,0(r4)
   11d38:	25000117 	ldw	r20,4(r4)
   11d3c:	21000204 	addi	r4,r4,8
   11d40:	d9012d15 	stw	r4,1204(sp)
   11d44:	dd813315 	stw	r22,1228(sp)
   11d48:	dd013415 	stw	r20,1232(sp)
   11d4c:	003d2b06 	br	111fc <___vfprintf_internal_r+0x8e4>
   11d50:	8080100c 	andi	r2,r16,64
   11d54:	1000fe26 	beq	r2,zero,12150 <___vfprintf_internal_r+0x1838>
   11d58:	d9012d17 	ldw	r4,1204(sp)
   11d5c:	002d883a 	mov	r22,zero
   11d60:	0007883a 	mov	r3,zero
   11d64:	25c0000b 	ldhu	r23,0(r4)
   11d68:	21000104 	addi	r4,r4,4
   11d6c:	d9012d15 	stw	r4,1204(sp)
   11d70:	b805883a 	mov	r2,r23
   11d74:	d8012585 	stb	zero,1174(sp)
   11d78:	003bbe06 	br	10c74 <___vfprintf_internal_r+0x35c>
   11d7c:	8080100c 	andi	r2,r16,64
   11d80:	1000ed26 	beq	r2,zero,12138 <___vfprintf_internal_r+0x1820>
   11d84:	d9012d17 	ldw	r4,1204(sp)
   11d88:	002d883a 	mov	r22,zero
   11d8c:	25c0000b 	ldhu	r23,0(r4)
   11d90:	21000104 	addi	r4,r4,4
   11d94:	d9012d15 	stw	r4,1204(sp)
   11d98:	003cd206 	br	110e4 <___vfprintf_internal_r+0x7cc>
   11d9c:	00c00084 	movi	r3,2
   11da0:	d8012585 	stb	zero,1174(sp)
   11da4:	003bb306 	br	10c74 <___vfprintf_internal_r+0x35c>
   11da8:	8080040c 	andi	r2,r16,16
   11dac:	1000f11e 	bne	r2,zero,12174 <___vfprintf_internal_r+0x185c>
   11db0:	8400100c 	andi	r16,r16,64
   11db4:	80015526 	beq	r16,zero,1230c <___vfprintf_internal_r+0x19f4>
   11db8:	da012d17 	ldw	r8,1204(sp)
   11dbc:	d8c12c17 	ldw	r3,1200(sp)
   11dc0:	40800017 	ldw	r2,0(r8)
   11dc4:	42000104 	addi	r8,r8,4
   11dc8:	da012d15 	stw	r8,1204(sp)
   11dcc:	10c0000d 	sth	r3,0(r2)
   11dd0:	003b0706 	br	109f0 <___vfprintf_internal_r+0xd8>
   11dd4:	8080100c 	andi	r2,r16,64
   11dd8:	1000c726 	beq	r2,zero,120f8 <___vfprintf_internal_r+0x17e0>
   11ddc:	da012d17 	ldw	r8,1204(sp)
   11de0:	45c0000f 	ldh	r23,0(r8)
   11de4:	42000104 	addi	r8,r8,4
   11de8:	da012d15 	stw	r8,1204(sp)
   11dec:	b82dd7fa 	srai	r22,r23,31
   11df0:	b005883a 	mov	r2,r22
   11df4:	003c1006 	br	10e38 <___vfprintf_internal_r+0x520>
   11df8:	ac800007 	ldb	r18,0(r21)
   11dfc:	003b2406 	br	10a90 <___vfprintf_internal_r+0x178>
   11e00:	4c800115 	stw	r18,4(r9)
   11e04:	9211883a 	add	r8,r18,r8
   11e08:	18c00044 	addi	r3,r3,1
   11e0c:	da011d15 	stw	r8,1140(sp)
   11e10:	d8c11c15 	stw	r3,1136(sp)
   11e14:	008001c4 	movi	r2,7
   11e18:	10c15416 	blt	r2,r3,1236c <___vfprintf_internal_r+0x1a54>
   11e1c:	4a400204 	addi	r9,r9,8
   11e20:	d8813717 	ldw	r2,1244(sp)
   11e24:	9ca7883a 	add	r19,r19,r18
   11e28:	48800015 	stw	r2,0(r9)
   11e2c:	00800044 	movi	r2,1
   11e30:	48800115 	stw	r2,4(r9)
   11e34:	4091883a 	add	r8,r8,r2
   11e38:	1887883a 	add	r3,r3,r2
   11e3c:	da011d15 	stw	r8,1140(sp)
   11e40:	d8c11c15 	stw	r3,1136(sp)
   11e44:	008001c4 	movi	r2,7
   11e48:	10c14016 	blt	r2,r3,1234c <___vfprintf_internal_r+0x1a34>
   11e4c:	4a400204 	addi	r9,r9,8
   11e50:	d9013217 	ldw	r4,1224(sp)
   11e54:	da011d17 	ldw	r8,1140(sp)
   11e58:	d8c11c17 	ldw	r3,1136(sp)
   11e5c:	24a5c83a 	sub	r18,r4,r18
   11e60:	4cc00015 	stw	r19,0(r9)
   11e64:	003fa406 	br	11cf8 <___vfprintf_internal_r+0x13e0>
   11e68:	04c000b4 	movhi	r19,2
   11e6c:	9cd82c04 	addi	r19,r19,24752
   11e70:	003cf406 	br	11244 <___vfprintf_internal_r+0x92c>
   11e74:	d9412917 	ldw	r5,1188(sp)
   11e78:	8809883a 	mov	r4,r17
   11e7c:	d9811b04 	addi	r6,sp,1132
   11e80:	00108e40 	call	108e4 <__sprint_r>
   11e84:	103c371e 	bne	r2,zero,10f64 <___vfprintf_internal_r+0x64c>
   11e88:	da011d17 	ldw	r8,1140(sp)
   11e8c:	da400404 	addi	r9,sp,16
   11e90:	003e1c06 	br	11704 <___vfprintf_internal_r+0xdec>
   11e94:	008000b4 	movhi	r2,2
   11e98:	1096d204 	addi	r2,r2,23368
   11e9c:	48800015 	stw	r2,0(r9)
   11ea0:	00800044 	movi	r2,1
   11ea4:	48800115 	stw	r2,4(r9)
   11ea8:	4091883a 	add	r8,r8,r2
   11eac:	1887883a 	add	r3,r3,r2
   11eb0:	da011d15 	stw	r8,1140(sp)
   11eb4:	d8c11c15 	stw	r3,1136(sp)
   11eb8:	008001c4 	movi	r2,7
   11ebc:	10c0c316 	blt	r2,r3,121cc <___vfprintf_internal_r+0x18b4>
   11ec0:	4a400204 	addi	r9,r9,8
   11ec4:	9000041e 	bne	r18,zero,11ed8 <___vfprintf_internal_r+0x15c0>
   11ec8:	d8c13217 	ldw	r3,1224(sp)
   11ecc:	1800021e 	bne	r3,zero,11ed8 <___vfprintf_internal_r+0x15c0>
   11ed0:	8080004c 	andi	r2,r16,1
   11ed4:	103d7826 	beq	r2,zero,114b8 <___vfprintf_internal_r+0xba0>
   11ed8:	d8c11c17 	ldw	r3,1136(sp)
   11edc:	d9013717 	ldw	r4,1244(sp)
   11ee0:	00800044 	movi	r2,1
   11ee4:	48800115 	stw	r2,4(r9)
   11ee8:	49000015 	stw	r4,0(r9)
   11eec:	4091883a 	add	r8,r8,r2
   11ef0:	1887883a 	add	r3,r3,r2
   11ef4:	da011d15 	stw	r8,1140(sp)
   11ef8:	d8c11c15 	stw	r3,1136(sp)
   11efc:	008001c4 	movi	r2,7
   11f00:	10c12e16 	blt	r2,r3,123bc <___vfprintf_internal_r+0x1aa4>
   11f04:	4a400204 	addi	r9,r9,8
   11f08:	04a5c83a 	sub	r18,zero,r18
   11f0c:	0480de0e 	bge	zero,r18,12288 <___vfprintf_internal_r+0x1970>
   11f10:	05800404 	movi	r22,16
   11f14:	050000b4 	movhi	r20,2
   11f18:	a5183ec4 	addi	r20,r20,24827
   11f1c:	b480e20e 	bge	r22,r18,122a8 <___vfprintf_internal_r+0x1990>
   11f20:	05c001c4 	movi	r23,7
   11f24:	df012917 	ldw	fp,1188(sp)
   11f28:	00000306 	br	11f38 <___vfprintf_internal_r+0x1620>
   11f2c:	4a400204 	addi	r9,r9,8
   11f30:	94bffc04 	addi	r18,r18,-16
   11f34:	b480dc0e 	bge	r22,r18,122a8 <___vfprintf_internal_r+0x1990>
   11f38:	4d000015 	stw	r20,0(r9)
   11f3c:	4d800115 	stw	r22,4(r9)
   11f40:	42000404 	addi	r8,r8,16
   11f44:	18c00044 	addi	r3,r3,1
   11f48:	da011d15 	stw	r8,1140(sp)
   11f4c:	d8c11c15 	stw	r3,1136(sp)
   11f50:	b8fff60e 	bge	r23,r3,11f2c <___vfprintf_internal_r+0x1614>
   11f54:	8809883a 	mov	r4,r17
   11f58:	e00b883a 	mov	r5,fp
   11f5c:	d9811b04 	addi	r6,sp,1132
   11f60:	00108e40 	call	108e4 <__sprint_r>
   11f64:	103bff1e 	bne	r2,zero,10f64 <___vfprintf_internal_r+0x64c>
   11f68:	da011d17 	ldw	r8,1140(sp)
   11f6c:	d8c11c17 	ldw	r3,1136(sp)
   11f70:	da400404 	addi	r9,sp,16
   11f74:	003fee06 	br	11f30 <___vfprintf_internal_r+0x1618>
   11f78:	da413c15 	stw	r9,1264(sp)
   11f7c:	00173680 	call	17368 <__isnand>
   11f80:	da413c17 	ldw	r9,1264(sp)
   11f84:	1000851e 	bne	r2,zero,1219c <___vfprintf_internal_r+0x1884>
   11f88:	00bfffc4 	movi	r2,-1
   11f8c:	e0817626 	beq	fp,r2,12568 <___vfprintf_internal_r+0x1c50>
   11f90:	008019c4 	movi	r2,103
   11f94:	90817126 	beq	r18,r2,1255c <___vfprintf_internal_r+0x1c44>
   11f98:	008011c4 	movi	r2,71
   11f9c:	90816f26 	beq	r18,r2,1255c <___vfprintf_internal_r+0x1c44>
   11fa0:	82004014 	ori	r8,r16,256
   11fa4:	da012a15 	stw	r8,1192(sp)
   11fa8:	a0017116 	blt	r20,zero,12570 <___vfprintf_internal_r+0x1c58>
   11fac:	d8012f05 	stb	zero,1212(sp)
   11fb0:	00801984 	movi	r2,102
   11fb4:	90811226 	beq	r18,r2,12400 <___vfprintf_internal_r+0x1ae8>
   11fb8:	00801184 	movi	r2,70
   11fbc:	90811026 	beq	r18,r2,12400 <___vfprintf_internal_r+0x1ae8>
   11fc0:	00801944 	movi	r2,101
   11fc4:	90819b26 	beq	r18,r2,12634 <___vfprintf_internal_r+0x1d1c>
   11fc8:	00801144 	movi	r2,69
   11fcc:	90819926 	beq	r18,r2,12634 <___vfprintf_internal_r+0x1d1c>
   11fd0:	e02f883a 	mov	r23,fp
   11fd4:	d8812404 	addi	r2,sp,1168
   11fd8:	d8800115 	stw	r2,4(sp)
   11fdc:	d8812304 	addi	r2,sp,1164
   11fe0:	d8800215 	stw	r2,8(sp)
   11fe4:	d8812204 	addi	r2,sp,1160
   11fe8:	ddc00015 	stw	r23,0(sp)
   11fec:	d8800315 	stw	r2,12(sp)
   11ff0:	8809883a 	mov	r4,r17
   11ff4:	b00b883a 	mov	r5,r22
   11ff8:	a00d883a 	mov	r6,r20
   11ffc:	01c00084 	movi	r7,2
   12000:	da413c15 	stw	r9,1264(sp)
   12004:	0012c080 	call	12c08 <_dtoa_r>
   12008:	1027883a 	mov	r19,r2
   1200c:	008019c4 	movi	r2,103
   12010:	da413c17 	ldw	r9,1264(sp)
   12014:	90818c1e 	bne	r18,r2,12648 <___vfprintf_internal_r+0x1d30>
   12018:	8080004c 	andi	r2,r16,1
   1201c:	10017926 	beq	r2,zero,12604 <___vfprintf_internal_r+0x1cec>
   12020:	00801184 	movi	r2,70
   12024:	9dc7883a 	add	r3,r19,r23
   12028:	90810626 	beq	r18,r2,12444 <___vfprintf_internal_r+0x1b2c>
   1202c:	b009883a 	mov	r4,r22
   12030:	a00b883a 	mov	r5,r20
   12034:	000d883a 	mov	r6,zero
   12038:	000f883a 	mov	r7,zero
   1203c:	d8c13b15 	stw	r3,1260(sp)
   12040:	da413c15 	stw	r9,1264(sp)
   12044:	001850c0 	call	1850c <__eqdf2>
   12048:	d8c13b17 	ldw	r3,1260(sp)
   1204c:	da413c17 	ldw	r9,1264(sp)
   12050:	10000726 	beq	r2,zero,12070 <___vfprintf_internal_r+0x1758>
   12054:	d8812217 	ldw	r2,1160(sp)
   12058:	10c1962e 	bgeu	r2,r3,126b4 <___vfprintf_internal_r+0x1d9c>
   1205c:	01000c04 	movi	r4,48
   12060:	11000005 	stb	r4,0(r2)
   12064:	10800044 	addi	r2,r2,1
   12068:	d8812215 	stw	r2,1160(sp)
   1206c:	10fffc1e 	bne	r2,r3,12060 <___vfprintf_internal_r+0x1748>
   12070:	1cc7c83a 	sub	r3,r3,r19
   12074:	d8c13215 	stw	r3,1224(sp)
   12078:	008019c4 	movi	r2,103
   1207c:	90810626 	beq	r18,r2,12498 <___vfprintf_internal_r+0x1b80>
   12080:	008011c4 	movi	r2,71
   12084:	90810426 	beq	r18,r2,12498 <___vfprintf_internal_r+0x1b80>
   12088:	00801984 	movi	r2,102
   1208c:	90819a1e 	bne	r18,r2,126f8 <___vfprintf_internal_r+0x1de0>
   12090:	d8812417 	ldw	r2,1168(sp)
   12094:	d8812b15 	stw	r2,1196(sp)
   12098:	0081880e 	bge	zero,r2,126bc <___vfprintf_internal_r+0x1da4>
   1209c:	e000021e 	bne	fp,zero,120a8 <___vfprintf_internal_r+0x1790>
   120a0:	8400004c 	andi	r16,r16,1
   120a4:	80000426 	beq	r16,zero,120b8 <___vfprintf_internal_r+0x17a0>
   120a8:	d8812b17 	ldw	r2,1196(sp)
   120ac:	e2000044 	addi	r8,fp,1
   120b0:	1205883a 	add	r2,r2,r8
   120b4:	d8812b15 	stw	r2,1196(sp)
   120b8:	d8812815 	stw	r2,1184(sp)
   120bc:	10011716 	blt	r2,zero,1251c <___vfprintf_internal_r+0x1c04>
   120c0:	ddc12f07 	ldb	r23,1212(sp)
   120c4:	b800ca26 	beq	r23,zero,123f0 <___vfprintf_internal_r+0x1ad8>
   120c8:	00800b44 	movi	r2,45
   120cc:	d8812585 	stb	r2,1174(sp)
   120d0:	dc012a17 	ldw	r16,1192(sp)
   120d4:	d8013115 	stw	zero,1220(sp)
   120d8:	003afe06 	br	10cd4 <___vfprintf_internal_r+0x3bc>
   120dc:	d8812b17 	ldw	r2,1196(sp)
   120e0:	d8812815 	stw	r2,1184(sp)
   120e4:	10005e16 	blt	r2,zero,12260 <___vfprintf_internal_r+0x1948>
   120e8:	d8812583 	ldbu	r2,1174(sp)
   120ec:	ddc12d15 	stw	r23,1204(sp)
   120f0:	d8013115 	stw	zero,1220(sp)
   120f4:	003af306 	br	10cc4 <___vfprintf_internal_r+0x3ac>
   120f8:	d8812d17 	ldw	r2,1204(sp)
   120fc:	15c00017 	ldw	r23,0(r2)
   12100:	10800104 	addi	r2,r2,4
   12104:	d8812d15 	stw	r2,1204(sp)
   12108:	b82dd7fa 	srai	r22,r23,31
   1210c:	b005883a 	mov	r2,r22
   12110:	003b4906 	br	10e38 <___vfprintf_internal_r+0x520>
   12114:	d8c12d17 	ldw	r3,1204(sp)
   12118:	002d883a 	mov	r22,zero
   1211c:	1dc00017 	ldw	r23,0(r3)
   12120:	18c00104 	addi	r3,r3,4
   12124:	d8c12d15 	stw	r3,1204(sp)
   12128:	b805883a 	mov	r2,r23
   1212c:	00c00044 	movi	r3,1
   12130:	d8012585 	stb	zero,1174(sp)
   12134:	003acf06 	br	10c74 <___vfprintf_internal_r+0x35c>
   12138:	da012d17 	ldw	r8,1204(sp)
   1213c:	002d883a 	mov	r22,zero
   12140:	45c00017 	ldw	r23,0(r8)
   12144:	42000104 	addi	r8,r8,4
   12148:	da012d15 	stw	r8,1204(sp)
   1214c:	003be506 	br	110e4 <___vfprintf_internal_r+0x7cc>
   12150:	da012d17 	ldw	r8,1204(sp)
   12154:	002d883a 	mov	r22,zero
   12158:	0007883a 	mov	r3,zero
   1215c:	45c00017 	ldw	r23,0(r8)
   12160:	42000104 	addi	r8,r8,4
   12164:	da012d15 	stw	r8,1204(sp)
   12168:	b805883a 	mov	r2,r23
   1216c:	d8012585 	stb	zero,1174(sp)
   12170:	003ac006 	br	10c74 <___vfprintf_internal_r+0x35c>
   12174:	d8c12d17 	ldw	r3,1204(sp)
   12178:	d9012c17 	ldw	r4,1200(sp)
   1217c:	18800017 	ldw	r2,0(r3)
   12180:	18c00104 	addi	r3,r3,4
   12184:	d8c12d15 	stw	r3,1204(sp)
   12188:	11000015 	stw	r4,0(r2)
   1218c:	003a1806 	br	109f0 <___vfprintf_internal_r+0xd8>
   12190:	073fffc4 	movi	fp,-1
   12194:	202b883a 	mov	r21,r4
   12198:	003a3e06 	br	10a94 <___vfprintf_internal_r+0x17c>
   1219c:	008011c4 	movi	r2,71
   121a0:	14809016 	blt	r2,r18,123e4 <___vfprintf_internal_r+0x1acc>
   121a4:	04c000b4 	movhi	r19,2
   121a8:	9cd82d04 	addi	r19,r19,24756
   121ac:	00c000c4 	movi	r3,3
   121b0:	00bfdfc4 	movi	r2,-129
   121b4:	80a0703a 	and	r16,r16,r2
   121b8:	d8c12815 	stw	r3,1184(sp)
   121bc:	d8812583 	ldbu	r2,1174(sp)
   121c0:	d8c12b15 	stw	r3,1196(sp)
   121c4:	d8013115 	stw	zero,1220(sp)
   121c8:	003abe06 	br	10cc4 <___vfprintf_internal_r+0x3ac>
   121cc:	d9412917 	ldw	r5,1188(sp)
   121d0:	8809883a 	mov	r4,r17
   121d4:	d9811b04 	addi	r6,sp,1132
   121d8:	00108e40 	call	108e4 <__sprint_r>
   121dc:	103b611e 	bne	r2,zero,10f64 <___vfprintf_internal_r+0x64c>
   121e0:	dc812417 	ldw	r18,1168(sp)
   121e4:	da011d17 	ldw	r8,1140(sp)
   121e8:	da400404 	addi	r9,sp,16
   121ec:	003f3506 	br	11ec4 <___vfprintf_internal_r+0x15ac>
   121f0:	ad400044 	addi	r21,r21,1
   121f4:	84000814 	ori	r16,r16,32
   121f8:	14800047 	ldb	r18,1(r2)
   121fc:	003a2406 	br	10a90 <___vfprintf_internal_r+0x178>
   12200:	d9412917 	ldw	r5,1188(sp)
   12204:	8809883a 	mov	r4,r17
   12208:	d9811b04 	addi	r6,sp,1132
   1220c:	00108e40 	call	108e4 <__sprint_r>
   12210:	103b541e 	bne	r2,zero,10f64 <___vfprintf_internal_r+0x64c>
   12214:	da011d17 	ldw	r8,1140(sp)
   12218:	da400404 	addi	r9,sp,16
   1221c:	003d4a06 	br	11748 <___vfprintf_internal_r+0xe30>
   12220:	4d000015 	stw	r20,0(r9)
   12224:	4c800115 	stw	r18,4(r9)
   12228:	4491883a 	add	r8,r8,r18
   1222c:	18c00044 	addi	r3,r3,1
   12230:	da011d15 	stw	r8,1140(sp)
   12234:	d8c11c15 	stw	r3,1136(sp)
   12238:	008001c4 	movi	r2,7
   1223c:	10fcdc16 	blt	r2,r3,115b0 <___vfprintf_internal_r+0xc98>
   12240:	4a400204 	addi	r9,r9,8
   12244:	003ce106 	br	115cc <___vfprintf_internal_r+0xcb4>
   12248:	da413c15 	stw	r9,1264(sp)
   1224c:	001075c0 	call	1075c <strlen>
   12250:	d8812b15 	stw	r2,1196(sp)
   12254:	d8812815 	stw	r2,1184(sp)
   12258:	da413c17 	ldw	r9,1264(sp)
   1225c:	103fa20e 	bge	r2,zero,120e8 <___vfprintf_internal_r+0x17d0>
   12260:	d8012815 	stw	zero,1184(sp)
   12264:	003fa006 	br	120e8 <___vfprintf_internal_r+0x17d0>
   12268:	d9412917 	ldw	r5,1188(sp)
   1226c:	8809883a 	mov	r4,r17
   12270:	d9811b04 	addi	r6,sp,1132
   12274:	00108e40 	call	108e4 <__sprint_r>
   12278:	103b3a1e 	bne	r2,zero,10f64 <___vfprintf_internal_r+0x64c>
   1227c:	da011d17 	ldw	r8,1140(sp)
   12280:	d8c11c17 	ldw	r3,1136(sp)
   12284:	da400404 	addi	r9,sp,16
   12288:	d8813217 	ldw	r2,1224(sp)
   1228c:	4cc00015 	stw	r19,0(r9)
   12290:	48800115 	stw	r2,4(r9)
   12294:	4091883a 	add	r8,r8,r2
   12298:	003c8106 	br	114a0 <___vfprintf_internal_r+0xb88>
   1229c:	00800b44 	movi	r2,45
   122a0:	d8812585 	stb	r2,1174(sp)
   122a4:	003be306 	br	11234 <___vfprintf_internal_r+0x91c>
   122a8:	4d000015 	stw	r20,0(r9)
   122ac:	4c800115 	stw	r18,4(r9)
   122b0:	4491883a 	add	r8,r8,r18
   122b4:	18c00044 	addi	r3,r3,1
   122b8:	da011d15 	stw	r8,1140(sp)
   122bc:	d8c11c15 	stw	r3,1136(sp)
   122c0:	008001c4 	movi	r2,7
   122c4:	10ffe816 	blt	r2,r3,12268 <___vfprintf_internal_r+0x1950>
   122c8:	4a400204 	addi	r9,r9,8
   122cc:	003fee06 	br	12288 <___vfprintf_internal_r+0x1970>
   122d0:	df012b15 	stw	fp,1196(sp)
   122d4:	00800184 	movi	r2,6
   122d8:	1700072e 	bgeu	r2,fp,122f8 <___vfprintf_internal_r+0x19e0>
   122dc:	d8812b15 	stw	r2,1196(sp)
   122e0:	d8812815 	stw	r2,1184(sp)
   122e4:	ddc12d15 	stw	r23,1204(sp)
   122e8:	04c000b4 	movhi	r19,2
   122ec:	9cd83904 	addi	r19,r19,24804
   122f0:	d8013115 	stw	zero,1220(sp)
   122f4:	003a7a06 	br	10ce0 <___vfprintf_internal_r+0x3c8>
   122f8:	d8812b17 	ldw	r2,1196(sp)
   122fc:	d8812815 	stw	r2,1184(sp)
   12300:	103ff80e 	bge	r2,zero,122e4 <___vfprintf_internal_r+0x19cc>
   12304:	d8012815 	stw	zero,1184(sp)
   12308:	003ff606 	br	122e4 <___vfprintf_internal_r+0x19cc>
   1230c:	d9012d17 	ldw	r4,1204(sp)
   12310:	da012c17 	ldw	r8,1200(sp)
   12314:	20800017 	ldw	r2,0(r4)
   12318:	21000104 	addi	r4,r4,4
   1231c:	d9012d15 	stw	r4,1204(sp)
   12320:	12000015 	stw	r8,0(r2)
   12324:	0039b206 	br	109f0 <___vfprintf_internal_r+0xd8>
   12328:	d9412917 	ldw	r5,1188(sp)
   1232c:	8809883a 	mov	r4,r17
   12330:	d9811b04 	addi	r6,sp,1132
   12334:	00108e40 	call	108e4 <__sprint_r>
   12338:	103b0a1e 	bne	r2,zero,10f64 <___vfprintf_internal_r+0x64c>
   1233c:	dc812417 	ldw	r18,1168(sp)
   12340:	da011d17 	ldw	r8,1140(sp)
   12344:	da400404 	addi	r9,sp,16
   12348:	003def06 	br	11b08 <___vfprintf_internal_r+0x11f0>
   1234c:	d9412917 	ldw	r5,1188(sp)
   12350:	8809883a 	mov	r4,r17
   12354:	d9811b04 	addi	r6,sp,1132
   12358:	00108e40 	call	108e4 <__sprint_r>
   1235c:	103b011e 	bne	r2,zero,10f64 <___vfprintf_internal_r+0x64c>
   12360:	dc812417 	ldw	r18,1168(sp)
   12364:	da400404 	addi	r9,sp,16
   12368:	003eb906 	br	11e50 <___vfprintf_internal_r+0x1538>
   1236c:	d9412917 	ldw	r5,1188(sp)
   12370:	8809883a 	mov	r4,r17
   12374:	d9811b04 	addi	r6,sp,1132
   12378:	00108e40 	call	108e4 <__sprint_r>
   1237c:	103af91e 	bne	r2,zero,10f64 <___vfprintf_internal_r+0x64c>
   12380:	dc812417 	ldw	r18,1168(sp)
   12384:	da011d17 	ldw	r8,1140(sp)
   12388:	d8c11c17 	ldw	r3,1136(sp)
   1238c:	da400404 	addi	r9,sp,16
   12390:	003ea306 	br	11e20 <___vfprintf_internal_r+0x1508>
   12394:	00800244 	movi	r2,9
   12398:	15fda636 	bltu	r2,r23,11a34 <___vfprintf_internal_r+0x111c>
   1239c:	dd010e04 	addi	r20,sp,1080
   123a0:	003dc206 	br	11aac <___vfprintf_internal_r+0x1194>
   123a4:	df012815 	stw	fp,1184(sp)
   123a8:	d8812583 	ldbu	r2,1174(sp)
   123ac:	df012b15 	stw	fp,1196(sp)
   123b0:	ddc12d15 	stw	r23,1204(sp)
   123b4:	d8013115 	stw	zero,1220(sp)
   123b8:	003a4206 	br	10cc4 <___vfprintf_internal_r+0x3ac>
   123bc:	d9412917 	ldw	r5,1188(sp)
   123c0:	8809883a 	mov	r4,r17
   123c4:	d9811b04 	addi	r6,sp,1132
   123c8:	00108e40 	call	108e4 <__sprint_r>
   123cc:	103ae51e 	bne	r2,zero,10f64 <___vfprintf_internal_r+0x64c>
   123d0:	dc812417 	ldw	r18,1168(sp)
   123d4:	da011d17 	ldw	r8,1140(sp)
   123d8:	d8c11c17 	ldw	r3,1136(sp)
   123dc:	da400404 	addi	r9,sp,16
   123e0:	003ec906 	br	11f08 <___vfprintf_internal_r+0x15f0>
   123e4:	04c000b4 	movhi	r19,2
   123e8:	9cd82e04 	addi	r19,r19,24760
   123ec:	003f6f06 	br	121ac <___vfprintf_internal_r+0x1894>
   123f0:	d8812583 	ldbu	r2,1174(sp)
   123f4:	dc012a17 	ldw	r16,1192(sp)
   123f8:	d8013115 	stw	zero,1220(sp)
   123fc:	003a3106 	br	10cc4 <___vfprintf_internal_r+0x3ac>
   12400:	d8812404 	addi	r2,sp,1168
   12404:	d8800115 	stw	r2,4(sp)
   12408:	d8812304 	addi	r2,sp,1164
   1240c:	d8800215 	stw	r2,8(sp)
   12410:	d8812204 	addi	r2,sp,1160
   12414:	df000015 	stw	fp,0(sp)
   12418:	d8800315 	stw	r2,12(sp)
   1241c:	8809883a 	mov	r4,r17
   12420:	b00b883a 	mov	r5,r22
   12424:	a00d883a 	mov	r6,r20
   12428:	01c000c4 	movi	r7,3
   1242c:	da413c15 	stw	r9,1264(sp)
   12430:	0012c080 	call	12c08 <_dtoa_r>
   12434:	da413c17 	ldw	r9,1264(sp)
   12438:	1027883a 	mov	r19,r2
   1243c:	1707883a 	add	r3,r2,fp
   12440:	e02f883a 	mov	r23,fp
   12444:	99000007 	ldb	r4,0(r19)
   12448:	00800c04 	movi	r2,48
   1244c:	20800326 	beq	r4,r2,1245c <___vfprintf_internal_r+0x1b44>
   12450:	da812417 	ldw	r10,1168(sp)
   12454:	1a87883a 	add	r3,r3,r10
   12458:	003ef406 	br	1202c <___vfprintf_internal_r+0x1714>
   1245c:	b009883a 	mov	r4,r22
   12460:	a00b883a 	mov	r5,r20
   12464:	000d883a 	mov	r6,zero
   12468:	000f883a 	mov	r7,zero
   1246c:	d8c13b15 	stw	r3,1260(sp)
   12470:	da413c15 	stw	r9,1264(sp)
   12474:	00185680 	call	18568 <__nedf2>
   12478:	d8c13b17 	ldw	r3,1260(sp)
   1247c:	da413c17 	ldw	r9,1264(sp)
   12480:	103ff326 	beq	r2,zero,12450 <___vfprintf_internal_r+0x1b38>
   12484:	00800044 	movi	r2,1
   12488:	15d5c83a 	sub	r10,r2,r23
   1248c:	da812415 	stw	r10,1168(sp)
   12490:	1a87883a 	add	r3,r3,r10
   12494:	003ee506 	br	1202c <___vfprintf_internal_r+0x1714>
   12498:	d8812417 	ldw	r2,1168(sp)
   1249c:	d8812b15 	stw	r2,1196(sp)
   124a0:	1029883a 	mov	r20,r2
   124a4:	00bfff44 	movi	r2,-3
   124a8:	a0800116 	blt	r20,r2,124b0 <___vfprintf_internal_r+0x1b98>
   124ac:	e5001d0e 	bge	fp,r20,12524 <___vfprintf_internal_r+0x1c0c>
   124b0:	94bfff84 	addi	r18,r18,-2
   124b4:	a53fffc4 	addi	r20,r20,-1
   124b8:	dd012415 	stw	r20,1168(sp)
   124bc:	dc811fc5 	stb	r18,1151(sp)
   124c0:	a0007816 	blt	r20,zero,126a4 <___vfprintf_internal_r+0x1d8c>
   124c4:	00800ac4 	movi	r2,43
   124c8:	d8812005 	stb	r2,1152(sp)
   124cc:	00800244 	movi	r2,9
   124d0:	15002b16 	blt	r2,r20,12580 <___vfprintf_internal_r+0x1c68>
   124d4:	00800c04 	movi	r2,48
   124d8:	a5000c04 	addi	r20,r20,48
   124dc:	d8812045 	stb	r2,1153(sp)
   124e0:	dd012085 	stb	r20,1154(sp)
   124e4:	d8c120c4 	addi	r3,sp,1155
   124e8:	d8811fc4 	addi	r2,sp,1151
   124ec:	da013217 	ldw	r8,1224(sp)
   124f0:	1885c83a 	sub	r2,r3,r2
   124f4:	d8813515 	stw	r2,1236(sp)
   124f8:	4085883a 	add	r2,r8,r2
   124fc:	d8812b15 	stw	r2,1196(sp)
   12500:	00800044 	movi	r2,1
   12504:	1200610e 	bge	r2,r8,1268c <___vfprintf_internal_r+0x1d74>
   12508:	d8812b17 	ldw	r2,1196(sp)
   1250c:	10800044 	addi	r2,r2,1
   12510:	d8812b15 	stw	r2,1196(sp)
   12514:	d8812815 	stw	r2,1184(sp)
   12518:	103ee90e 	bge	r2,zero,120c0 <___vfprintf_internal_r+0x17a8>
   1251c:	d8012815 	stw	zero,1184(sp)
   12520:	003ee706 	br	120c0 <___vfprintf_internal_r+0x17a8>
   12524:	d8812b17 	ldw	r2,1196(sp)
   12528:	da013217 	ldw	r8,1224(sp)
   1252c:	12003716 	blt	r2,r8,1260c <___vfprintf_internal_r+0x1cf4>
   12530:	8400004c 	andi	r16,r16,1
   12534:	80000326 	beq	r16,zero,12544 <___vfprintf_internal_r+0x1c2c>
   12538:	d8812b17 	ldw	r2,1196(sp)
   1253c:	10800044 	addi	r2,r2,1
   12540:	d8812b15 	stw	r2,1196(sp)
   12544:	d8812815 	stw	r2,1184(sp)
   12548:	10003716 	blt	r2,zero,12628 <___vfprintf_internal_r+0x1d10>
   1254c:	048019c4 	movi	r18,103
   12550:	003edb06 	br	120c0 <___vfprintf_internal_r+0x17a8>
   12554:	d8012815 	stw	zero,1184(sp)
   12558:	003b6906 	br	11300 <___vfprintf_internal_r+0x9e8>
   1255c:	e03e901e 	bne	fp,zero,11fa0 <___vfprintf_internal_r+0x1688>
   12560:	07000044 	movi	fp,1
   12564:	003e8e06 	br	11fa0 <___vfprintf_internal_r+0x1688>
   12568:	07000184 	movi	fp,6
   1256c:	003e8c06 	br	11fa0 <___vfprintf_internal_r+0x1688>
   12570:	00c00b44 	movi	r3,45
   12574:	a520003c 	xorhi	r20,r20,32768
   12578:	d8c12f05 	stb	r3,1212(sp)
   1257c:	003e8c06 	br	11fb0 <___vfprintf_internal_r+0x1698>
   12580:	d8c11f84 	addi	r3,sp,1150
   12584:	102f883a 	mov	r23,r2
   12588:	4839883a 	mov	fp,r9
   1258c:	a009883a 	mov	r4,r20
   12590:	01400284 	movi	r5,10
   12594:	182d883a 	mov	r22,r3
   12598:	001881c0 	call	1881c <__modsi3>
   1259c:	10800c04 	addi	r2,r2,48
   125a0:	a009883a 	mov	r4,r20
   125a4:	b0800005 	stb	r2,0(r22)
   125a8:	01400284 	movi	r5,10
   125ac:	00187cc0 	call	187cc <__divsi3>
   125b0:	1029883a 	mov	r20,r2
   125b4:	b0ffffc4 	addi	r3,r22,-1
   125b8:	b8bff416 	blt	r23,r2,1258c <___vfprintf_internal_r+0x1c74>
   125bc:	11400c04 	addi	r5,r2,48
   125c0:	b17fffc5 	stb	r5,-1(r22)
   125c4:	d8811fc4 	addi	r2,sp,1151
   125c8:	e013883a 	mov	r9,fp
   125cc:	1880482e 	bgeu	r3,r2,126f0 <___vfprintf_internal_r+0x1dd8>
   125d0:	b007883a 	mov	r3,r22
   125d4:	d9012044 	addi	r4,sp,1153
   125d8:	00000206 	br	125e4 <___vfprintf_internal_r+0x1ccc>
   125dc:	19400003 	ldbu	r5,0(r3)
   125e0:	18c00044 	addi	r3,r3,1
   125e4:	21400005 	stb	r5,0(r4)
   125e8:	21000044 	addi	r4,r4,1
   125ec:	10fffb1e 	bne	r2,r3,125dc <___vfprintf_internal_r+0x1cc4>
   125f0:	d8c12004 	addi	r3,sp,1152
   125f4:	1d87c83a 	sub	r3,r3,r22
   125f8:	d9012044 	addi	r4,sp,1153
   125fc:	20c7883a 	add	r3,r4,r3
   12600:	003fba06 	br	124ec <___vfprintf_internal_r+0x1bd4>
   12604:	d8c12217 	ldw	r3,1160(sp)
   12608:	003e9906 	br	12070 <___vfprintf_internal_r+0x1758>
   1260c:	05000b0e 	bge	zero,r20,1263c <___vfprintf_internal_r+0x1d24>
   12610:	05000044 	movi	r20,1
   12614:	da013217 	ldw	r8,1224(sp)
   12618:	a229883a 	add	r20,r20,r8
   1261c:	dd012b15 	stw	r20,1196(sp)
   12620:	dd012815 	stw	r20,1184(sp)
   12624:	a03fc90e 	bge	r20,zero,1254c <___vfprintf_internal_r+0x1c34>
   12628:	d8012815 	stw	zero,1184(sp)
   1262c:	048019c4 	movi	r18,103
   12630:	003ea306 	br	120c0 <___vfprintf_internal_r+0x17a8>
   12634:	e5c00044 	addi	r23,fp,1
   12638:	003e6606 	br	11fd4 <___vfprintf_internal_r+0x16bc>
   1263c:	00800084 	movi	r2,2
   12640:	1529c83a 	sub	r20,r2,r20
   12644:	003ff306 	br	12614 <___vfprintf_internal_r+0x1cfc>
   12648:	008011c4 	movi	r2,71
   1264c:	90be7226 	beq	r18,r2,12018 <___vfprintf_internal_r+0x1700>
   12650:	003e7306 	br	12020 <___vfprintf_internal_r+0x1708>
   12654:	d8812d17 	ldw	r2,1204(sp)
   12658:	ac800043 	ldbu	r18,1(r21)
   1265c:	202b883a 	mov	r21,r4
   12660:	17000017 	ldw	fp,0(r2)
   12664:	10800104 	addi	r2,r2,4
   12668:	d8812d15 	stw	r2,1204(sp)
   1266c:	e0001b16 	blt	fp,zero,126dc <___vfprintf_internal_r+0x1dc4>
   12670:	94803fcc 	andi	r18,r18,255
   12674:	9480201c 	xori	r18,r18,128
   12678:	94bfe004 	addi	r18,r18,-128
   1267c:	00390406 	br	10a90 <___vfprintf_internal_r+0x178>
   12680:	00bfffc4 	movi	r2,-1
   12684:	d8812c15 	stw	r2,1200(sp)
   12688:	003a2506 	br	10f20 <___vfprintf_internal_r+0x608>
   1268c:	80a0703a 	and	r16,r16,r2
   12690:	803f9d1e 	bne	r16,zero,12508 <___vfprintf_internal_r+0x1bf0>
   12694:	d8812b17 	ldw	r2,1196(sp)
   12698:	d8812815 	stw	r2,1184(sp)
   1269c:	103e880e 	bge	r2,zero,120c0 <___vfprintf_internal_r+0x17a8>
   126a0:	003f9e06 	br	1251c <___vfprintf_internal_r+0x1c04>
   126a4:	00800b44 	movi	r2,45
   126a8:	0529c83a 	sub	r20,zero,r20
   126ac:	d8812005 	stb	r2,1152(sp)
   126b0:	003f8606 	br	124cc <___vfprintf_internal_r+0x1bb4>
   126b4:	1007883a 	mov	r3,r2
   126b8:	003e6d06 	br	12070 <___vfprintf_internal_r+0x1758>
   126bc:	e000021e 	bne	fp,zero,126c8 <___vfprintf_internal_r+0x1db0>
   126c0:	8400004c 	andi	r16,r16,1
   126c4:	80000e26 	beq	r16,zero,12700 <___vfprintf_internal_r+0x1de8>
   126c8:	e7000084 	addi	fp,fp,2
   126cc:	df012b15 	stw	fp,1196(sp)
   126d0:	df012815 	stw	fp,1184(sp)
   126d4:	e03e7a0e 	bge	fp,zero,120c0 <___vfprintf_internal_r+0x17a8>
   126d8:	003f9006 	br	1251c <___vfprintf_internal_r+0x1c04>
   126dc:	94803fcc 	andi	r18,r18,255
   126e0:	9480201c 	xori	r18,r18,128
   126e4:	073fffc4 	movi	fp,-1
   126e8:	94bfe004 	addi	r18,r18,-128
   126ec:	0038e806 	br	10a90 <___vfprintf_internal_r+0x178>
   126f0:	d8c12044 	addi	r3,sp,1153
   126f4:	003f7d06 	br	124ec <___vfprintf_internal_r+0x1bd4>
   126f8:	dd012417 	ldw	r20,1168(sp)
   126fc:	003f6d06 	br	124b4 <___vfprintf_internal_r+0x1b9c>
   12700:	00c00044 	movi	r3,1
   12704:	d8c12815 	stw	r3,1184(sp)
   12708:	d8c12b15 	stw	r3,1196(sp)
   1270c:	003e6c06 	br	120c0 <___vfprintf_internal_r+0x17a8>

00012710 <__vfprintf_internal>:
   12710:	008000f4 	movhi	r2,3
   12714:	10a60a04 	addi	r2,r2,-26584
   12718:	2007883a 	mov	r3,r4
   1271c:	11000017 	ldw	r4,0(r2)
   12720:	2805883a 	mov	r2,r5
   12724:	300f883a 	mov	r7,r6
   12728:	180b883a 	mov	r5,r3
   1272c:	100d883a 	mov	r6,r2
   12730:	00109181 	jmpi	10918 <___vfprintf_internal_r>

00012734 <__swbuf_r>:
   12734:	defffc04 	addi	sp,sp,-16
   12738:	dc800215 	stw	r18,8(sp)
   1273c:	dc400115 	stw	r17,4(sp)
   12740:	dc000015 	stw	r16,0(sp)
   12744:	dfc00315 	stw	ra,12(sp)
   12748:	2023883a 	mov	r17,r4
   1274c:	2825883a 	mov	r18,r5
   12750:	3021883a 	mov	r16,r6
   12754:	20000226 	beq	r4,zero,12760 <__swbuf_r+0x2c>
   12758:	20800e17 	ldw	r2,56(r4)
   1275c:	10003b26 	beq	r2,zero,1284c <__swbuf_r+0x118>
   12760:	8080030b 	ldhu	r2,12(r16)
   12764:	80c00617 	ldw	r3,24(r16)
   12768:	1080020c 	andi	r2,r2,8
   1276c:	10bfffcc 	andi	r2,r2,65535
   12770:	10a0001c 	xori	r2,r2,32768
   12774:	80c00215 	stw	r3,8(r16)
   12778:	10a00004 	addi	r2,r2,-32768
   1277c:	10002226 	beq	r2,zero,12808 <__swbuf_r+0xd4>
   12780:	80800417 	ldw	r2,16(r16)
   12784:	10002026 	beq	r2,zero,12808 <__swbuf_r+0xd4>
   12788:	80c00017 	ldw	r3,0(r16)
   1278c:	81000517 	ldw	r4,20(r16)
   12790:	94803fcc 	andi	r18,r18,255
   12794:	1885c83a 	sub	r2,r3,r2
   12798:	1100250e 	bge	r2,r4,12830 <__swbuf_r+0xfc>
   1279c:	10800044 	addi	r2,r2,1
   127a0:	81400217 	ldw	r5,8(r16)
   127a4:	19000044 	addi	r4,r3,1
   127a8:	297fffc4 	addi	r5,r5,-1
   127ac:	81400215 	stw	r5,8(r16)
   127b0:	1c800005 	stb	r18,0(r3)
   127b4:	80c00517 	ldw	r3,20(r16)
   127b8:	81000015 	stw	r4,0(r16)
   127bc:	18800c26 	beq	r3,r2,127f0 <__swbuf_r+0xbc>
   127c0:	8080030b 	ldhu	r2,12(r16)
   127c4:	1080004c 	andi	r2,r2,1
   127c8:	10000226 	beq	r2,zero,127d4 <__swbuf_r+0xa0>
   127cc:	00800284 	movi	r2,10
   127d0:	90800726 	beq	r18,r2,127f0 <__swbuf_r+0xbc>
   127d4:	9005883a 	mov	r2,r18
   127d8:	dfc00317 	ldw	ra,12(sp)
   127dc:	dc800217 	ldw	r18,8(sp)
   127e0:	dc400117 	ldw	r17,4(sp)
   127e4:	dc000017 	ldw	r16,0(sp)
   127e8:	dec00404 	addi	sp,sp,16
   127ec:	f800283a 	ret
   127f0:	8809883a 	mov	r4,r17
   127f4:	800b883a 	mov	r5,r16
   127f8:	00142240 	call	14224 <_fflush_r>
   127fc:	103ff526 	beq	r2,zero,127d4 <__swbuf_r+0xa0>
   12800:	04bfffc4 	movi	r18,-1
   12804:	003ff306 	br	127d4 <__swbuf_r+0xa0>
   12808:	8809883a 	mov	r4,r17
   1280c:	800b883a 	mov	r5,r16
   12810:	001288c0 	call	1288c <__swsetup_r>
   12814:	10000f1e 	bne	r2,zero,12854 <__swbuf_r+0x120>
   12818:	80800417 	ldw	r2,16(r16)
   1281c:	80c00017 	ldw	r3,0(r16)
   12820:	81000517 	ldw	r4,20(r16)
   12824:	94803fcc 	andi	r18,r18,255
   12828:	1885c83a 	sub	r2,r3,r2
   1282c:	113fdb16 	blt	r2,r4,1279c <__swbuf_r+0x68>
   12830:	8809883a 	mov	r4,r17
   12834:	800b883a 	mov	r5,r16
   12838:	00142240 	call	14224 <_fflush_r>
   1283c:	103ff01e 	bne	r2,zero,12800 <__swbuf_r+0xcc>
   12840:	80c00017 	ldw	r3,0(r16)
   12844:	00800044 	movi	r2,1
   12848:	003fd506 	br	127a0 <__swbuf_r+0x6c>
   1284c:	00144cc0 	call	144cc <__sinit>
   12850:	003fc306 	br	12760 <__swbuf_r+0x2c>
   12854:	8080030b 	ldhu	r2,12(r16)
   12858:	04bfffc4 	movi	r18,-1
   1285c:	10801014 	ori	r2,r2,64
   12860:	8080030d 	sth	r2,12(r16)
   12864:	00800244 	movi	r2,9
   12868:	88800015 	stw	r2,0(r17)
   1286c:	003fd906 	br	127d4 <__swbuf_r+0xa0>

00012870 <__swbuf>:
   12870:	00c000f4 	movhi	r3,3
   12874:	18e60a04 	addi	r3,r3,-26584
   12878:	2005883a 	mov	r2,r4
   1287c:	19000017 	ldw	r4,0(r3)
   12880:	280d883a 	mov	r6,r5
   12884:	100b883a 	mov	r5,r2
   12888:	00127341 	jmpi	12734 <__swbuf_r>

0001288c <__swsetup_r>:
   1288c:	008000f4 	movhi	r2,3
   12890:	10a60a04 	addi	r2,r2,-26584
   12894:	10800017 	ldw	r2,0(r2)
   12898:	defffd04 	addi	sp,sp,-12
   1289c:	dc400115 	stw	r17,4(sp)
   128a0:	dc000015 	stw	r16,0(sp)
   128a4:	dfc00215 	stw	ra,8(sp)
   128a8:	2023883a 	mov	r17,r4
   128ac:	2821883a 	mov	r16,r5
   128b0:	10000226 	beq	r2,zero,128bc <__swsetup_r+0x30>
   128b4:	10c00e17 	ldw	r3,56(r2)
   128b8:	18003d26 	beq	r3,zero,129b0 <__swsetup_r+0x124>
   128bc:	8080030b 	ldhu	r2,12(r16)
   128c0:	10c0020c 	andi	r3,r2,8
   128c4:	18ffffcc 	andi	r3,r3,65535
   128c8:	18e0001c 	xori	r3,r3,32768
   128cc:	18e00004 	addi	r3,r3,-32768
   128d0:	18001226 	beq	r3,zero,1291c <__swsetup_r+0x90>
   128d4:	80c00417 	ldw	r3,16(r16)
   128d8:	18001f26 	beq	r3,zero,12958 <__swsetup_r+0xcc>
   128dc:	1100004c 	andi	r4,r2,1
   128e0:	2000261e 	bne	r4,zero,1297c <__swsetup_r+0xf0>
   128e4:	1080008c 	andi	r2,r2,2
   128e8:	10bfffcc 	andi	r2,r2,65535
   128ec:	10a0001c 	xori	r2,r2,32768
   128f0:	10a00004 	addi	r2,r2,-32768
   128f4:	1000311e 	bne	r2,zero,129bc <__swsetup_r+0x130>
   128f8:	80800517 	ldw	r2,20(r16)
   128fc:	80800215 	stw	r2,8(r16)
   12900:	18002326 	beq	r3,zero,12990 <__swsetup_r+0x104>
   12904:	0005883a 	mov	r2,zero
   12908:	dfc00217 	ldw	ra,8(sp)
   1290c:	dc400117 	ldw	r17,4(sp)
   12910:	dc000017 	ldw	r16,0(sp)
   12914:	dec00304 	addi	sp,sp,12
   12918:	f800283a 	ret
   1291c:	10c0040c 	andi	r3,r2,16
   12920:	18ffffcc 	andi	r3,r3,65535
   12924:	18e0001c 	xori	r3,r3,32768
   12928:	18e00004 	addi	r3,r3,-32768
   1292c:	18001e26 	beq	r3,zero,129a8 <__swsetup_r+0x11c>
   12930:	10c0010c 	andi	r3,r2,4
   12934:	18ffffcc 	andi	r3,r3,65535
   12938:	18e0001c 	xori	r3,r3,32768
   1293c:	18e00004 	addi	r3,r3,-32768
   12940:	1800211e 	bne	r3,zero,129c8 <__swsetup_r+0x13c>
   12944:	80c00417 	ldw	r3,16(r16)
   12948:	11400214 	ori	r5,r2,8
   1294c:	8140030d 	sth	r5,12(r16)
   12950:	2805883a 	mov	r2,r5
   12954:	183fe11e 	bne	r3,zero,128dc <__swsetup_r+0x50>
   12958:	1140a00c 	andi	r5,r2,640
   1295c:	01008004 	movi	r4,512
   12960:	293fde26 	beq	r5,r4,128dc <__swsetup_r+0x50>
   12964:	8809883a 	mov	r4,r17
   12968:	800b883a 	mov	r5,r16
   1296c:	00152400 	call	15240 <__smakebuf_r>
   12970:	8080030b 	ldhu	r2,12(r16)
   12974:	80c00417 	ldw	r3,16(r16)
   12978:	003fd806 	br	128dc <__swsetup_r+0x50>
   1297c:	80800517 	ldw	r2,20(r16)
   12980:	80000215 	stw	zero,8(r16)
   12984:	0085c83a 	sub	r2,zero,r2
   12988:	80800615 	stw	r2,24(r16)
   1298c:	183fdd1e 	bne	r3,zero,12904 <__swsetup_r+0x78>
   12990:	8080030b 	ldhu	r2,12(r16)
   12994:	1080200c 	andi	r2,r2,128
   12998:	10bfffcc 	andi	r2,r2,65535
   1299c:	10a0001c 	xori	r2,r2,32768
   129a0:	10a00004 	addi	r2,r2,-32768
   129a4:	103fd826 	beq	r2,zero,12908 <__swsetup_r+0x7c>
   129a8:	00bfffc4 	movi	r2,-1
   129ac:	003fd606 	br	12908 <__swsetup_r+0x7c>
   129b0:	1009883a 	mov	r4,r2
   129b4:	00144cc0 	call	144cc <__sinit>
   129b8:	003fc006 	br	128bc <__swsetup_r+0x30>
   129bc:	0005883a 	mov	r2,zero
   129c0:	80800215 	stw	r2,8(r16)
   129c4:	003fce06 	br	12900 <__swsetup_r+0x74>
   129c8:	81400c17 	ldw	r5,48(r16)
   129cc:	28000626 	beq	r5,zero,129e8 <__swsetup_r+0x15c>
   129d0:	80c01004 	addi	r3,r16,64
   129d4:	28c00326 	beq	r5,r3,129e4 <__swsetup_r+0x158>
   129d8:	8809883a 	mov	r4,r17
   129dc:	00148500 	call	14850 <_free_r>
   129e0:	8080030b 	ldhu	r2,12(r16)
   129e4:	80000c15 	stw	zero,48(r16)
   129e8:	80c00417 	ldw	r3,16(r16)
   129ec:	013ff6c4 	movi	r4,-37
   129f0:	2084703a 	and	r2,r4,r2
   129f4:	80000115 	stw	zero,4(r16)
   129f8:	80c00015 	stw	r3,0(r16)
   129fc:	003fd206 	br	12948 <__swsetup_r+0xbc>

00012a00 <quorem>:
   12a00:	defff704 	addi	sp,sp,-36
   12a04:	dc400115 	stw	r17,4(sp)
   12a08:	20800417 	ldw	r2,16(r4)
   12a0c:	2c400417 	ldw	r17,16(r5)
   12a10:	dd800615 	stw	r22,24(sp)
   12a14:	dd400515 	stw	r21,20(sp)
   12a18:	dfc00815 	stw	ra,32(sp)
   12a1c:	ddc00715 	stw	r23,28(sp)
   12a20:	dd000415 	stw	r20,16(sp)
   12a24:	dcc00315 	stw	r19,12(sp)
   12a28:	dc800215 	stw	r18,8(sp)
   12a2c:	dc000015 	stw	r16,0(sp)
   12a30:	202b883a 	mov	r21,r4
   12a34:	282d883a 	mov	r22,r5
   12a38:	14407116 	blt	r2,r17,12c00 <quorem+0x200>
   12a3c:	88800104 	addi	r2,r17,4
   12a40:	1085883a 	add	r2,r2,r2
   12a44:	1085883a 	add	r2,r2,r2
   12a48:	28a7883a 	add	r19,r5,r2
   12a4c:	2085883a 	add	r2,r4,r2
   12a50:	15c00017 	ldw	r23,0(r2)
   12a54:	99400017 	ldw	r5,0(r19)
   12a58:	8c7fffc4 	addi	r17,r17,-1
   12a5c:	b809883a 	mov	r4,r23
   12a60:	29400044 	addi	r5,r5,1
   12a64:	00188780 	call	18878 <__udivsi3>
   12a68:	1025883a 	mov	r18,r2
   12a6c:	b4000504 	addi	r16,r22,20
   12a70:	ad000504 	addi	r20,r21,20
   12a74:	10002d26 	beq	r2,zero,12b2c <quorem+0x12c>
   12a78:	800d883a 	mov	r6,r16
   12a7c:	a007883a 	mov	r3,r20
   12a80:	000f883a 	mov	r7,zero
   12a84:	0005883a 	mov	r2,zero
   12a88:	32c00017 	ldw	r11,0(r6)
   12a8c:	1a400017 	ldw	r9,0(r3)
   12a90:	31800104 	addi	r6,r6,4
   12a94:	5abfffcc 	andi	r10,r11,65535
   12a98:	5495383a 	mul	r10,r10,r18
   12a9c:	5816d43a 	srli	r11,r11,16
   12aa0:	4a3fffcc 	andi	r8,r9,65535
   12aa4:	3a95883a 	add	r10,r7,r10
   12aa8:	500ed43a 	srli	r7,r10,16
   12aac:	5c97383a 	mul	r11,r11,r18
   12ab0:	4085883a 	add	r2,r8,r2
   12ab4:	52bfffcc 	andi	r10,r10,65535
   12ab8:	1291c83a 	sub	r8,r2,r10
   12abc:	4804d43a 	srli	r2,r9,16
   12ac0:	3acf883a 	add	r7,r7,r11
   12ac4:	4015d43a 	srai	r10,r8,16
   12ac8:	393fffcc 	andi	r4,r7,65535
   12acc:	1105c83a 	sub	r2,r2,r4
   12ad0:	1285883a 	add	r2,r2,r10
   12ad4:	1880008d 	sth	r2,2(r3)
   12ad8:	1a00000d 	sth	r8,0(r3)
   12adc:	380ed43a 	srli	r7,r7,16
   12ae0:	1005d43a 	srai	r2,r2,16
   12ae4:	18c00104 	addi	r3,r3,4
   12ae8:	99bfe72e 	bgeu	r19,r6,12a88 <quorem+0x88>
   12aec:	b8000f1e 	bne	r23,zero,12b2c <quorem+0x12c>
   12af0:	88800144 	addi	r2,r17,5
   12af4:	1085883a 	add	r2,r2,r2
   12af8:	1085883a 	add	r2,r2,r2
   12afc:	a887883a 	add	r3,r21,r2
   12b00:	18bfff04 	addi	r2,r3,-4
   12b04:	a080082e 	bgeu	r20,r2,12b28 <quorem+0x128>
   12b08:	18ffff17 	ldw	r3,-4(r3)
   12b0c:	18000326 	beq	r3,zero,12b1c <quorem+0x11c>
   12b10:	00000506 	br	12b28 <quorem+0x128>
   12b14:	10c00017 	ldw	r3,0(r2)
   12b18:	1800031e 	bne	r3,zero,12b28 <quorem+0x128>
   12b1c:	10bfff04 	addi	r2,r2,-4
   12b20:	8c7fffc4 	addi	r17,r17,-1
   12b24:	a0bffb36 	bltu	r20,r2,12b14 <quorem+0x114>
   12b28:	ac400415 	stw	r17,16(r21)
   12b2c:	a809883a 	mov	r4,r21
   12b30:	b00b883a 	mov	r5,r22
   12b34:	00166300 	call	16630 <__mcmp>
   12b38:	10002516 	blt	r2,zero,12bd0 <quorem+0x1d0>
   12b3c:	94800044 	addi	r18,r18,1
   12b40:	a007883a 	mov	r3,r20
   12b44:	000b883a 	mov	r5,zero
   12b48:	1a000017 	ldw	r8,0(r3)
   12b4c:	81c00017 	ldw	r7,0(r16)
   12b50:	84000104 	addi	r16,r16,4
   12b54:	41bfffcc 	andi	r6,r8,65535
   12b58:	38bfffcc 	andi	r2,r7,65535
   12b5c:	314b883a 	add	r5,r6,r5
   12b60:	288dc83a 	sub	r6,r5,r2
   12b64:	380ed43a 	srli	r7,r7,16
   12b68:	400ad43a 	srli	r5,r8,16
   12b6c:	3005d43a 	srai	r2,r6,16
   12b70:	1980000d 	sth	r6,0(r3)
   12b74:	29cbc83a 	sub	r5,r5,r7
   12b78:	288b883a 	add	r5,r5,r2
   12b7c:	1940008d 	sth	r5,2(r3)
   12b80:	280bd43a 	srai	r5,r5,16
   12b84:	18c00104 	addi	r3,r3,4
   12b88:	9c3fef2e 	bgeu	r19,r16,12b48 <quorem+0x148>
   12b8c:	88800144 	addi	r2,r17,5
   12b90:	1085883a 	add	r2,r2,r2
   12b94:	1085883a 	add	r2,r2,r2
   12b98:	a885883a 	add	r2,r21,r2
   12b9c:	10c00017 	ldw	r3,0(r2)
   12ba0:	18000b1e 	bne	r3,zero,12bd0 <quorem+0x1d0>
   12ba4:	10ffff04 	addi	r3,r2,-4
   12ba8:	a0c0082e 	bgeu	r20,r3,12bcc <quorem+0x1cc>
   12bac:	10bfff17 	ldw	r2,-4(r2)
   12bb0:	10000326 	beq	r2,zero,12bc0 <quorem+0x1c0>
   12bb4:	00000506 	br	12bcc <quorem+0x1cc>
   12bb8:	18800017 	ldw	r2,0(r3)
   12bbc:	1000031e 	bne	r2,zero,12bcc <quorem+0x1cc>
   12bc0:	18ffff04 	addi	r3,r3,-4
   12bc4:	8c7fffc4 	addi	r17,r17,-1
   12bc8:	a0fffb36 	bltu	r20,r3,12bb8 <quorem+0x1b8>
   12bcc:	ac400415 	stw	r17,16(r21)
   12bd0:	9005883a 	mov	r2,r18
   12bd4:	dfc00817 	ldw	ra,32(sp)
   12bd8:	ddc00717 	ldw	r23,28(sp)
   12bdc:	dd800617 	ldw	r22,24(sp)
   12be0:	dd400517 	ldw	r21,20(sp)
   12be4:	dd000417 	ldw	r20,16(sp)
   12be8:	dcc00317 	ldw	r19,12(sp)
   12bec:	dc800217 	ldw	r18,8(sp)
   12bf0:	dc400117 	ldw	r17,4(sp)
   12bf4:	dc000017 	ldw	r16,0(sp)
   12bf8:	dec00904 	addi	sp,sp,36
   12bfc:	f800283a 	ret
   12c00:	0005883a 	mov	r2,zero
   12c04:	003ff306 	br	12bd4 <quorem+0x1d4>

00012c08 <_dtoa_r>:
   12c08:	20801017 	ldw	r2,64(r4)
   12c0c:	deffdf04 	addi	sp,sp,-132
   12c10:	dcc01a15 	stw	r19,104(sp)
   12c14:	dc801915 	stw	r18,100(sp)
   12c18:	dc401815 	stw	r17,96(sp)
   12c1c:	dc001715 	stw	r16,92(sp)
   12c20:	dfc02015 	stw	ra,128(sp)
   12c24:	df001f15 	stw	fp,124(sp)
   12c28:	ddc01e15 	stw	r23,120(sp)
   12c2c:	dd801d15 	stw	r22,116(sp)
   12c30:	dd401c15 	stw	r21,112(sp)
   12c34:	dd001b15 	stw	r20,108(sp)
   12c38:	d9400315 	stw	r5,12(sp)
   12c3c:	d9c00415 	stw	r7,16(sp)
   12c40:	2021883a 	mov	r16,r4
   12c44:	3025883a 	mov	r18,r6
   12c48:	dcc02317 	ldw	r19,140(sp)
   12c4c:	3023883a 	mov	r17,r6
   12c50:	10000826 	beq	r2,zero,12c74 <_dtoa_r+0x6c>
   12c54:	20c01117 	ldw	r3,68(r4)
   12c58:	01800044 	movi	r6,1
   12c5c:	100b883a 	mov	r5,r2
   12c60:	30cc983a 	sll	r6,r6,r3
   12c64:	10c00115 	stw	r3,4(r2)
   12c68:	11800215 	stw	r6,8(r2)
   12c6c:	0015e340 	call	15e34 <_Bfree>
   12c70:	80001015 	stw	zero,64(r16)
   12c74:	90002f16 	blt	r18,zero,12d34 <_dtoa_r+0x12c>
   12c78:	98000015 	stw	zero,0(r19)
   12c7c:	90dffc2c 	andhi	r3,r18,32752
   12c80:	009ffc34 	movhi	r2,32752
   12c84:	18801c26 	beq	r3,r2,12cf8 <_dtoa_r+0xf0>
   12c88:	d9000317 	ldw	r4,12(sp)
   12c8c:	880b883a 	mov	r5,r17
   12c90:	000d883a 	mov	r6,zero
   12c94:	000f883a 	mov	r7,zero
   12c98:	001850c0 	call	1850c <__eqdf2>
   12c9c:	10002c1e 	bne	r2,zero,12d50 <_dtoa_r+0x148>
   12ca0:	d9002217 	ldw	r4,136(sp)
   12ca4:	d9c02417 	ldw	r7,144(sp)
   12ca8:	00800044 	movi	r2,1
   12cac:	20800015 	stw	r2,0(r4)
   12cb0:	38019426 	beq	r7,zero,13304 <_dtoa_r+0x6fc>
   12cb4:	008000b4 	movhi	r2,2
   12cb8:	1096d244 	addi	r2,r2,23369
   12cbc:	38800015 	stw	r2,0(r7)
   12cc0:	15ffffc4 	addi	r23,r2,-1
   12cc4:	b805883a 	mov	r2,r23
   12cc8:	dfc02017 	ldw	ra,128(sp)
   12ccc:	df001f17 	ldw	fp,124(sp)
   12cd0:	ddc01e17 	ldw	r23,120(sp)
   12cd4:	dd801d17 	ldw	r22,116(sp)
   12cd8:	dd401c17 	ldw	r21,112(sp)
   12cdc:	dd001b17 	ldw	r20,108(sp)
   12ce0:	dcc01a17 	ldw	r19,104(sp)
   12ce4:	dc801917 	ldw	r18,100(sp)
   12ce8:	dc401817 	ldw	r17,96(sp)
   12cec:	dc001717 	ldw	r16,92(sp)
   12cf0:	dec02104 	addi	sp,sp,132
   12cf4:	f800283a 	ret
   12cf8:	d8c02217 	ldw	r3,136(sp)
   12cfc:	d9000317 	ldw	r4,12(sp)
   12d00:	0089c3c4 	movi	r2,9999
   12d04:	18800015 	stw	r2,0(r3)
   12d08:	20016c26 	beq	r4,zero,132bc <_dtoa_r+0x6b4>
   12d0c:	05c000b4 	movhi	r23,2
   12d10:	bdd84604 	addi	r23,r23,24856
   12d14:	d9c02417 	ldw	r7,144(sp)
   12d18:	383fea26 	beq	r7,zero,12cc4 <_dtoa_r+0xbc>
   12d1c:	b88000c7 	ldb	r2,3(r23)
   12d20:	10016d1e 	bne	r2,zero,132d8 <_dtoa_r+0x6d0>
   12d24:	b88000c4 	addi	r2,r23,3
   12d28:	d8c02417 	ldw	r3,144(sp)
   12d2c:	18800015 	stw	r2,0(r3)
   12d30:	003fe406 	br	12cc4 <_dtoa_r+0xbc>
   12d34:	04600034 	movhi	r17,32768
   12d38:	8c7fffc4 	addi	r17,r17,-1
   12d3c:	9462703a 	and	r17,r18,r17
   12d40:	00800044 	movi	r2,1
   12d44:	98800015 	stw	r2,0(r19)
   12d48:	8825883a 	mov	r18,r17
   12d4c:	003fcb06 	br	12c7c <_dtoa_r+0x74>
   12d50:	d9400317 	ldw	r5,12(sp)
   12d54:	9028d53a 	srli	r20,r18,20
   12d58:	d8800204 	addi	r2,sp,8
   12d5c:	d8800015 	stw	r2,0(sp)
   12d60:	8009883a 	mov	r4,r16
   12d64:	880d883a 	mov	r6,r17
   12d68:	d9c00104 	addi	r7,sp,4
   12d6c:	00169d80 	call	169d8 <__d2b>
   12d70:	a501ffcc 	andi	r20,r20,2047
   12d74:	1039883a 	mov	fp,r2
   12d78:	a001591e 	bne	r20,zero,132e0 <_dtoa_r+0x6d8>
   12d7c:	dd400217 	ldw	r21,8(sp)
   12d80:	dd000117 	ldw	r20,4(sp)
   12d84:	00befbc4 	movi	r2,-1041
   12d88:	ad29883a 	add	r20,r21,r20
   12d8c:	a082d216 	blt	r20,r2,138d8 <_dtoa_r+0xcd0>
   12d90:	d8c00317 	ldw	r3,12(sp)
   12d94:	013f0384 	movi	r4,-1010
   12d98:	2509c83a 	sub	r4,r4,r20
   12d9c:	a0810484 	addi	r2,r20,1042
   12da0:	9124983a 	sll	r18,r18,r4
   12da4:	1884d83a 	srl	r2,r3,r2
   12da8:	9088b03a 	or	r4,r18,r2
   12dac:	000fb140 	call	fb14 <__floatunsidf>
   12db0:	1009883a 	mov	r4,r2
   12db4:	017f8434 	movhi	r5,65040
   12db8:	00800044 	movi	r2,1
   12dbc:	194b883a 	add	r5,r3,r5
   12dc0:	a53fffc4 	addi	r20,r20,-1
   12dc4:	d8800f15 	stw	r2,60(sp)
   12dc8:	000d883a 	mov	r6,zero
   12dcc:	01cffe34 	movhi	r7,16376
   12dd0:	000f4e40 	call	f4e4 <__subdf3>
   12dd4:	1009883a 	mov	r4,r2
   12dd8:	180b883a 	mov	r5,r3
   12ddc:	0198dbf4 	movhi	r6,25455
   12de0:	3190d844 	addi	r6,r6,17249
   12de4:	01cff4f4 	movhi	r7,16339
   12de8:	39e1e9c4 	addi	r7,r7,-30809
   12dec:	000f5440 	call	f544 <__muldf3>
   12df0:	180b883a 	mov	r5,r3
   12df4:	01a2d874 	movhi	r6,35681
   12df8:	31b22cc4 	addi	r6,r6,-14157
   12dfc:	01cff1f4 	movhi	r7,16327
   12e00:	39e28a04 	addi	r7,r7,-30168
   12e04:	1009883a 	mov	r4,r2
   12e08:	000f4900 	call	f490 <__adddf3>
   12e0c:	a009883a 	mov	r4,r20
   12e10:	1027883a 	mov	r19,r2
   12e14:	1825883a 	mov	r18,r3
   12e18:	00186840 	call	18684 <__floatsidf>
   12e1c:	1009883a 	mov	r4,r2
   12e20:	180b883a 	mov	r5,r3
   12e24:	019427f4 	movhi	r6,20639
   12e28:	319e7ec4 	addi	r6,r6,31227
   12e2c:	01cff4f4 	movhi	r7,16339
   12e30:	39d104c4 	addi	r7,r7,17427
   12e34:	000f5440 	call	f544 <__muldf3>
   12e38:	9809883a 	mov	r4,r19
   12e3c:	900b883a 	mov	r5,r18
   12e40:	100d883a 	mov	r6,r2
   12e44:	180f883a 	mov	r7,r3
   12e48:	000f4900 	call	f490 <__adddf3>
   12e4c:	1009883a 	mov	r4,r2
   12e50:	180b883a 	mov	r5,r3
   12e54:	1027883a 	mov	r19,r2
   12e58:	1825883a 	mov	r18,r3
   12e5c:	000fa400 	call	fa40 <__fixdfsi>
   12e60:	9809883a 	mov	r4,r19
   12e64:	900b883a 	mov	r5,r18
   12e68:	000d883a 	mov	r6,zero
   12e6c:	000f883a 	mov	r7,zero
   12e70:	d8800615 	stw	r2,24(sp)
   12e74:	00186280 	call	18628 <__ltdf2>
   12e78:	10027e16 	blt	r2,zero,13874 <_dtoa_r+0xc6c>
   12e7c:	d8c00617 	ldw	r3,24(sp)
   12e80:	00800584 	movi	r2,22
   12e84:	10c26c36 	bltu	r2,r3,13838 <_dtoa_r+0xc30>
   12e88:	180490fa 	slli	r2,r3,3
   12e8c:	00c000b4 	movhi	r3,2
   12e90:	18d86b04 	addi	r3,r3,25004
   12e94:	d9800317 	ldw	r6,12(sp)
   12e98:	1885883a 	add	r2,r3,r2
   12e9c:	11000017 	ldw	r4,0(r2)
   12ea0:	11400117 	ldw	r5,4(r2)
   12ea4:	880f883a 	mov	r7,r17
   12ea8:	00185c40 	call	185c4 <__gtdf2>
   12eac:	00828f0e 	bge	zero,r2,138ec <_dtoa_r+0xce4>
   12eb0:	d8800617 	ldw	r2,24(sp)
   12eb4:	d8000d15 	stw	zero,52(sp)
   12eb8:	10bfffc4 	addi	r2,r2,-1
   12ebc:	d8800615 	stw	r2,24(sp)
   12ec0:	ad29c83a 	sub	r20,r21,r20
   12ec4:	a53fffc4 	addi	r20,r20,-1
   12ec8:	a0026616 	blt	r20,zero,13864 <_dtoa_r+0xc5c>
   12ecc:	dd000715 	stw	r20,28(sp)
   12ed0:	d8000815 	stw	zero,32(sp)
   12ed4:	d8800617 	ldw	r2,24(sp)
   12ed8:	10025a16 	blt	r2,zero,13844 <_dtoa_r+0xc3c>
   12edc:	d8c00717 	ldw	r3,28(sp)
   12ee0:	d8800b15 	stw	r2,44(sp)
   12ee4:	d8000a15 	stw	zero,40(sp)
   12ee8:	1887883a 	add	r3,r3,r2
   12eec:	d8c00715 	stw	r3,28(sp)
   12ef0:	d9c00417 	ldw	r7,16(sp)
   12ef4:	00800244 	movi	r2,9
   12ef8:	11c10536 	bltu	r2,r7,13310 <_dtoa_r+0x708>
   12efc:	00800144 	movi	r2,5
   12f00:	11c4c60e 	bge	r2,r7,1421c <_dtoa_r+0x1614>
   12f04:	39ffff04 	addi	r7,r7,-4
   12f08:	d9c00415 	stw	r7,16(sp)
   12f0c:	0027883a 	mov	r19,zero
   12f10:	d9c00417 	ldw	r7,16(sp)
   12f14:	008000c4 	movi	r2,3
   12f18:	3883a226 	beq	r7,r2,13da4 <_dtoa_r+0x119c>
   12f1c:	11c2bc16 	blt	r2,r7,13a10 <_dtoa_r+0xe08>
   12f20:	00800084 	movi	r2,2
   12f24:	3880fb1e 	bne	r7,r2,13314 <_dtoa_r+0x70c>
   12f28:	d8000c15 	stw	zero,48(sp)
   12f2c:	d9002117 	ldw	r4,132(sp)
   12f30:	0103ae0e 	bge	zero,r4,13dec <_dtoa_r+0x11e4>
   12f34:	2025883a 	mov	r18,r4
   12f38:	d9000e15 	stw	r4,56(sp)
   12f3c:	d9000915 	stw	r4,36(sp)
   12f40:	80001115 	stw	zero,68(r16)
   12f44:	008005c4 	movi	r2,23
   12f48:	1484b22e 	bgeu	r2,r18,14214 <_dtoa_r+0x160c>
   12f4c:	00c00044 	movi	r3,1
   12f50:	00800104 	movi	r2,4
   12f54:	1085883a 	add	r2,r2,r2
   12f58:	11000504 	addi	r4,r2,20
   12f5c:	180b883a 	mov	r5,r3
   12f60:	18c00044 	addi	r3,r3,1
   12f64:	913ffb2e 	bgeu	r18,r4,12f54 <_dtoa_r+0x34c>
   12f68:	81401115 	stw	r5,68(r16)
   12f6c:	8009883a 	mov	r4,r16
   12f70:	0015d8c0 	call	15d8c <_Balloc>
   12f74:	102f883a 	mov	r23,r2
   12f78:	80801015 	stw	r2,64(r16)
   12f7c:	00800384 	movi	r2,14
   12f80:	1480f036 	bltu	r2,r18,13344 <_dtoa_r+0x73c>
   12f84:	9800ef26 	beq	r19,zero,13344 <_dtoa_r+0x73c>
   12f88:	d8800617 	ldw	r2,24(sp)
   12f8c:	00839c0e 	bge	zero,r2,13e00 <_dtoa_r+0x11f8>
   12f90:	d8c00617 	ldw	r3,24(sp)
   12f94:	108003cc 	andi	r2,r2,15
   12f98:	100490fa 	slli	r2,r2,3
   12f9c:	182bd13a 	srai	r21,r3,4
   12fa0:	00c000b4 	movhi	r3,2
   12fa4:	18d86b04 	addi	r3,r3,25004
   12fa8:	1885883a 	add	r2,r3,r2
   12fac:	a8c0040c 	andi	r3,r21,16
   12fb0:	12800017 	ldw	r10,0(r2)
   12fb4:	15800117 	ldw	r22,4(r2)
   12fb8:	18038726 	beq	r3,zero,13dd8 <_dtoa_r+0x11d0>
   12fbc:	008000b4 	movhi	r2,2
   12fc0:	10986104 	addi	r2,r2,24964
   12fc4:	11800817 	ldw	r6,32(r2)
   12fc8:	11c00917 	ldw	r7,36(r2)
   12fcc:	d9000317 	ldw	r4,12(sp)
   12fd0:	880b883a 	mov	r5,r17
   12fd4:	da801515 	stw	r10,84(sp)
   12fd8:	000f8280 	call	f828 <__divdf3>
   12fdc:	da801517 	ldw	r10,84(sp)
   12fe0:	d8801015 	stw	r2,64(sp)
   12fe4:	1829883a 	mov	r20,r3
   12fe8:	ad4003cc 	andi	r21,r21,15
   12fec:	048000c4 	movi	r18,3
   12ff0:	a8001126 	beq	r21,zero,13038 <_dtoa_r+0x430>
   12ff4:	04c000b4 	movhi	r19,2
   12ff8:	9cd86104 	addi	r19,r19,24964
   12ffc:	5005883a 	mov	r2,r10
   13000:	b007883a 	mov	r3,r22
   13004:	a980004c 	andi	r6,r21,1
   13008:	1009883a 	mov	r4,r2
   1300c:	a82bd07a 	srai	r21,r21,1
   13010:	180b883a 	mov	r5,r3
   13014:	30000426 	beq	r6,zero,13028 <_dtoa_r+0x420>
   13018:	99800017 	ldw	r6,0(r19)
   1301c:	99c00117 	ldw	r7,4(r19)
   13020:	94800044 	addi	r18,r18,1
   13024:	000f5440 	call	f544 <__muldf3>
   13028:	9cc00204 	addi	r19,r19,8
   1302c:	a83ff51e 	bne	r21,zero,13004 <_dtoa_r+0x3fc>
   13030:	1015883a 	mov	r10,r2
   13034:	182d883a 	mov	r22,r3
   13038:	d9001017 	ldw	r4,64(sp)
   1303c:	a00b883a 	mov	r5,r20
   13040:	500d883a 	mov	r6,r10
   13044:	b00f883a 	mov	r7,r22
   13048:	000f8280 	call	f828 <__divdf3>
   1304c:	1027883a 	mov	r19,r2
   13050:	1829883a 	mov	r20,r3
   13054:	d8c00d17 	ldw	r3,52(sp)
   13058:	18000626 	beq	r3,zero,13074 <_dtoa_r+0x46c>
   1305c:	9809883a 	mov	r4,r19
   13060:	a00b883a 	mov	r5,r20
   13064:	000d883a 	mov	r6,zero
   13068:	01cffc34 	movhi	r7,16368
   1306c:	00186280 	call	18628 <__ltdf2>
   13070:	10040e16 	blt	r2,zero,140ac <_dtoa_r+0x14a4>
   13074:	9009883a 	mov	r4,r18
   13078:	00186840 	call	18684 <__floatsidf>
   1307c:	1009883a 	mov	r4,r2
   13080:	180b883a 	mov	r5,r3
   13084:	980d883a 	mov	r6,r19
   13088:	a00f883a 	mov	r7,r20
   1308c:	000f5440 	call	f544 <__muldf3>
   13090:	1009883a 	mov	r4,r2
   13094:	180b883a 	mov	r5,r3
   13098:	000d883a 	mov	r6,zero
   1309c:	01d00734 	movhi	r7,16412
   130a0:	000f4900 	call	f490 <__adddf3>
   130a4:	057f3034 	movhi	r21,64704
   130a8:	1d6b883a 	add	r21,r3,r21
   130ac:	d8c00917 	ldw	r3,36(sp)
   130b0:	1025883a 	mov	r18,r2
   130b4:	18031f26 	beq	r3,zero,13d34 <_dtoa_r+0x112c>
   130b8:	d8800617 	ldw	r2,24(sp)
   130bc:	dac00917 	ldw	r11,36(sp)
   130c0:	d8801315 	stw	r2,76(sp)
   130c4:	d8c00c17 	ldw	r3,48(sp)
   130c8:	18039026 	beq	r3,zero,13f0c <_dtoa_r+0x1304>
   130cc:	58bfffc4 	addi	r2,r11,-1
   130d0:	100490fa 	slli	r2,r2,3
   130d4:	00c000b4 	movhi	r3,2
   130d8:	18d86b04 	addi	r3,r3,25004
   130dc:	0009883a 	mov	r4,zero
   130e0:	1885883a 	add	r2,r3,r2
   130e4:	11800017 	ldw	r6,0(r2)
   130e8:	11c00117 	ldw	r7,4(r2)
   130ec:	014ff834 	movhi	r5,16352
   130f0:	dac01615 	stw	r11,88(sp)
   130f4:	000f8280 	call	f828 <__divdf3>
   130f8:	900d883a 	mov	r6,r18
   130fc:	a80f883a 	mov	r7,r21
   13100:	1009883a 	mov	r4,r2
   13104:	180b883a 	mov	r5,r3
   13108:	000f4e40 	call	f4e4 <__subdf3>
   1310c:	a00b883a 	mov	r5,r20
   13110:	9809883a 	mov	r4,r19
   13114:	182b883a 	mov	r21,r3
   13118:	d8801015 	stw	r2,64(sp)
   1311c:	000fa400 	call	fa40 <__fixdfsi>
   13120:	1009883a 	mov	r4,r2
   13124:	d8801515 	stw	r2,84(sp)
   13128:	00186840 	call	18684 <__floatsidf>
   1312c:	9809883a 	mov	r4,r19
   13130:	a00b883a 	mov	r5,r20
   13134:	100d883a 	mov	r6,r2
   13138:	180f883a 	mov	r7,r3
   1313c:	000f4e40 	call	f4e4 <__subdf3>
   13140:	da401517 	ldw	r9,84(sp)
   13144:	d9001017 	ldw	r4,64(sp)
   13148:	a80b883a 	mov	r5,r21
   1314c:	4d000c04 	addi	r20,r9,48
   13150:	bd000005 	stb	r20,0(r23)
   13154:	100d883a 	mov	r6,r2
   13158:	180f883a 	mov	r7,r3
   1315c:	bd800044 	addi	r22,r23,1
   13160:	1025883a 	mov	r18,r2
   13164:	1827883a 	mov	r19,r3
   13168:	00185c40 	call	185c4 <__gtdf2>
   1316c:	00842216 	blt	zero,r2,141f8 <_dtoa_r+0x15f0>
   13170:	0009883a 	mov	r4,zero
   13174:	014ffc34 	movhi	r5,16368
   13178:	900d883a 	mov	r6,r18
   1317c:	980f883a 	mov	r7,r19
   13180:	000f4e40 	call	f4e4 <__subdf3>
   13184:	d9001017 	ldw	r4,64(sp)
   13188:	a80b883a 	mov	r5,r21
   1318c:	100d883a 	mov	r6,r2
   13190:	180f883a 	mov	r7,r3
   13194:	00185c40 	call	185c4 <__gtdf2>
   13198:	dac01617 	ldw	r11,88(sp)
   1319c:	00841316 	blt	zero,r2,141ec <_dtoa_r+0x15e4>
   131a0:	00800044 	movi	r2,1
   131a4:	12c0670e 	bge	r2,r11,13344 <_dtoa_r+0x73c>
   131a8:	bad7883a 	add	r11,r23,r11
   131ac:	df001115 	stw	fp,68(sp)
   131b0:	dc401215 	stw	r17,72(sp)
   131b4:	5839883a 	mov	fp,r11
   131b8:	dc401017 	ldw	r17,64(sp)
   131bc:	00000806 	br	131e0 <_dtoa_r+0x5d8>
   131c0:	000f4e40 	call	f4e4 <__subdf3>
   131c4:	1009883a 	mov	r4,r2
   131c8:	180b883a 	mov	r5,r3
   131cc:	880d883a 	mov	r6,r17
   131d0:	a80f883a 	mov	r7,r21
   131d4:	00186280 	call	18628 <__ltdf2>
   131d8:	1003ee16 	blt	r2,zero,14194 <_dtoa_r+0x158c>
   131dc:	b703f126 	beq	r22,fp,141a4 <_dtoa_r+0x159c>
   131e0:	8809883a 	mov	r4,r17
   131e4:	a80b883a 	mov	r5,r21
   131e8:	000d883a 	mov	r6,zero
   131ec:	01d00934 	movhi	r7,16420
   131f0:	000f5440 	call	f544 <__muldf3>
   131f4:	000d883a 	mov	r6,zero
   131f8:	01d00934 	movhi	r7,16420
   131fc:	9009883a 	mov	r4,r18
   13200:	980b883a 	mov	r5,r19
   13204:	1023883a 	mov	r17,r2
   13208:	182b883a 	mov	r21,r3
   1320c:	000f5440 	call	f544 <__muldf3>
   13210:	180b883a 	mov	r5,r3
   13214:	1009883a 	mov	r4,r2
   13218:	1825883a 	mov	r18,r3
   1321c:	1027883a 	mov	r19,r2
   13220:	000fa400 	call	fa40 <__fixdfsi>
   13224:	1009883a 	mov	r4,r2
   13228:	1029883a 	mov	r20,r2
   1322c:	00186840 	call	18684 <__floatsidf>
   13230:	9809883a 	mov	r4,r19
   13234:	900b883a 	mov	r5,r18
   13238:	100d883a 	mov	r6,r2
   1323c:	180f883a 	mov	r7,r3
   13240:	000f4e40 	call	f4e4 <__subdf3>
   13244:	a5000c04 	addi	r20,r20,48
   13248:	b5000005 	stb	r20,0(r22)
   1324c:	1009883a 	mov	r4,r2
   13250:	180b883a 	mov	r5,r3
   13254:	880d883a 	mov	r6,r17
   13258:	a80f883a 	mov	r7,r21
   1325c:	1025883a 	mov	r18,r2
   13260:	1827883a 	mov	r19,r3
   13264:	00186280 	call	18628 <__ltdf2>
   13268:	b5800044 	addi	r22,r22,1
   1326c:	0009883a 	mov	r4,zero
   13270:	014ffc34 	movhi	r5,16368
   13274:	900d883a 	mov	r6,r18
   13278:	980f883a 	mov	r7,r19
   1327c:	103fd00e 	bge	r2,zero,131c0 <_dtoa_r+0x5b8>
   13280:	d9001317 	ldw	r4,76(sp)
   13284:	df001117 	ldw	fp,68(sp)
   13288:	d9000615 	stw	r4,24(sp)
   1328c:	8009883a 	mov	r4,r16
   13290:	e00b883a 	mov	r5,fp
   13294:	0015e340 	call	15e34 <_Bfree>
   13298:	d9c00617 	ldw	r7,24(sp)
   1329c:	d8c02217 	ldw	r3,136(sp)
   132a0:	d9002417 	ldw	r4,144(sp)
   132a4:	b0000005 	stb	zero,0(r22)
   132a8:	38800044 	addi	r2,r7,1
   132ac:	18800015 	stw	r2,0(r3)
   132b0:	203e8426 	beq	r4,zero,12cc4 <_dtoa_r+0xbc>
   132b4:	25800015 	stw	r22,0(r4)
   132b8:	003e8206 	br	12cc4 <_dtoa_r+0xbc>
   132bc:	00800434 	movhi	r2,16
   132c0:	10bfffc4 	addi	r2,r2,-1
   132c4:	90a4703a 	and	r18,r18,r2
   132c8:	903e901e 	bne	r18,zero,12d0c <_dtoa_r+0x104>
   132cc:	05c000b4 	movhi	r23,2
   132d0:	bdd84304 	addi	r23,r23,24844
   132d4:	003e8f06 	br	12d14 <_dtoa_r+0x10c>
   132d8:	b8800204 	addi	r2,r23,8
   132dc:	003e9206 	br	12d28 <_dtoa_r+0x120>
   132e0:	01400434 	movhi	r5,16
   132e4:	297fffc4 	addi	r5,r5,-1
   132e8:	894a703a 	and	r5,r17,r5
   132ec:	d9000317 	ldw	r4,12(sp)
   132f0:	294ffc34 	orhi	r5,r5,16368
   132f4:	a53f0044 	addi	r20,r20,-1023
   132f8:	dd400217 	ldw	r21,8(sp)
   132fc:	d8000f15 	stw	zero,60(sp)
   13300:	003eb106 	br	12dc8 <_dtoa_r+0x1c0>
   13304:	05c000b4 	movhi	r23,2
   13308:	bdd6d204 	addi	r23,r23,23368
   1330c:	003e6d06 	br	12cc4 <_dtoa_r+0xbc>
   13310:	d8000415 	stw	zero,16(sp)
   13314:	80001115 	stw	zero,68(r16)
   13318:	8009883a 	mov	r4,r16
   1331c:	000b883a 	mov	r5,zero
   13320:	0015d8c0 	call	15d8c <_Balloc>
   13324:	01ffffc4 	movi	r7,-1
   13328:	102f883a 	mov	r23,r2
   1332c:	80801015 	stw	r2,64(r16)
   13330:	00800044 	movi	r2,1
   13334:	d9c00915 	stw	r7,36(sp)
   13338:	d8002115 	stw	zero,132(sp)
   1333c:	d9c00e15 	stw	r7,56(sp)
   13340:	d8800c15 	stw	r2,48(sp)
   13344:	d8800117 	ldw	r2,4(sp)
   13348:	10008b16 	blt	r2,zero,13578 <_dtoa_r+0x970>
   1334c:	d9000617 	ldw	r4,24(sp)
   13350:	00c00384 	movi	r3,14
   13354:	19008816 	blt	r3,r4,13578 <_dtoa_r+0x970>
   13358:	200490fa 	slli	r2,r4,3
   1335c:	d9c02117 	ldw	r7,132(sp)
   13360:	00c000b4 	movhi	r3,2
   13364:	18d86b04 	addi	r3,r3,25004
   13368:	1885883a 	add	r2,r3,r2
   1336c:	14800017 	ldw	r18,0(r2)
   13370:	14c00117 	ldw	r19,4(r2)
   13374:	3801c916 	blt	r7,zero,13a9c <_dtoa_r+0xe94>
   13378:	d9000317 	ldw	r4,12(sp)
   1337c:	900d883a 	mov	r6,r18
   13380:	980f883a 	mov	r7,r19
   13384:	880b883a 	mov	r5,r17
   13388:	000f8280 	call	f828 <__divdf3>
   1338c:	180b883a 	mov	r5,r3
   13390:	1009883a 	mov	r4,r2
   13394:	000fa400 	call	fa40 <__fixdfsi>
   13398:	1009883a 	mov	r4,r2
   1339c:	102b883a 	mov	r21,r2
   133a0:	00186840 	call	18684 <__floatsidf>
   133a4:	1009883a 	mov	r4,r2
   133a8:	180b883a 	mov	r5,r3
   133ac:	900d883a 	mov	r6,r18
   133b0:	980f883a 	mov	r7,r19
   133b4:	000f5440 	call	f544 <__muldf3>
   133b8:	d9000317 	ldw	r4,12(sp)
   133bc:	880b883a 	mov	r5,r17
   133c0:	100d883a 	mov	r6,r2
   133c4:	180f883a 	mov	r7,r3
   133c8:	000f4e40 	call	f4e4 <__subdf3>
   133cc:	d9c00917 	ldw	r7,36(sp)
   133d0:	1009883a 	mov	r4,r2
   133d4:	a8800c04 	addi	r2,r21,48
   133d8:	b8800005 	stb	r2,0(r23)
   133dc:	01800044 	movi	r6,1
   133e0:	180b883a 	mov	r5,r3
   133e4:	2005883a 	mov	r2,r4
   133e8:	bd800044 	addi	r22,r23,1
   133ec:	39803726 	beq	r7,r6,134cc <_dtoa_r+0x8c4>
   133f0:	000d883a 	mov	r6,zero
   133f4:	01d00934 	movhi	r7,16420
   133f8:	000f5440 	call	f544 <__muldf3>
   133fc:	1009883a 	mov	r4,r2
   13400:	180b883a 	mov	r5,r3
   13404:	000d883a 	mov	r6,zero
   13408:	000f883a 	mov	r7,zero
   1340c:	1029883a 	mov	r20,r2
   13410:	1823883a 	mov	r17,r3
   13414:	001850c0 	call	1850c <__eqdf2>
   13418:	103f9c26 	beq	r2,zero,1328c <_dtoa_r+0x684>
   1341c:	dd400917 	ldw	r21,36(sp)
   13420:	dc000415 	stw	r16,16(sp)
   13424:	00000906 	br	1344c <_dtoa_r+0x844>
   13428:	000f5440 	call	f544 <__muldf3>
   1342c:	1009883a 	mov	r4,r2
   13430:	180b883a 	mov	r5,r3
   13434:	000d883a 	mov	r6,zero
   13438:	000f883a 	mov	r7,zero
   1343c:	1029883a 	mov	r20,r2
   13440:	1823883a 	mov	r17,r3
   13444:	001850c0 	call	1850c <__eqdf2>
   13448:	10022926 	beq	r2,zero,13cf0 <_dtoa_r+0x10e8>
   1344c:	900d883a 	mov	r6,r18
   13450:	980f883a 	mov	r7,r19
   13454:	a009883a 	mov	r4,r20
   13458:	880b883a 	mov	r5,r17
   1345c:	000f8280 	call	f828 <__divdf3>
   13460:	180b883a 	mov	r5,r3
   13464:	1009883a 	mov	r4,r2
   13468:	000fa400 	call	fa40 <__fixdfsi>
   1346c:	1009883a 	mov	r4,r2
   13470:	1021883a 	mov	r16,r2
   13474:	00186840 	call	18684 <__floatsidf>
   13478:	1009883a 	mov	r4,r2
   1347c:	180b883a 	mov	r5,r3
   13480:	900d883a 	mov	r6,r18
   13484:	980f883a 	mov	r7,r19
   13488:	000f5440 	call	f544 <__muldf3>
   1348c:	a009883a 	mov	r4,r20
   13490:	880b883a 	mov	r5,r17
   13494:	100d883a 	mov	r6,r2
   13498:	180f883a 	mov	r7,r3
   1349c:	000f4e40 	call	f4e4 <__subdf3>
   134a0:	82400c04 	addi	r9,r16,48
   134a4:	b2400005 	stb	r9,0(r22)
   134a8:	b5800044 	addi	r22,r22,1
   134ac:	b5d3c83a 	sub	r9,r22,r23
   134b0:	000d883a 	mov	r6,zero
   134b4:	01d00934 	movhi	r7,16420
   134b8:	1009883a 	mov	r4,r2
   134bc:	180b883a 	mov	r5,r3
   134c0:	aa7fd91e 	bne	r21,r9,13428 <_dtoa_r+0x820>
   134c4:	802b883a 	mov	r21,r16
   134c8:	dc000417 	ldw	r16,16(sp)
   134cc:	1009883a 	mov	r4,r2
   134d0:	180b883a 	mov	r5,r3
   134d4:	100d883a 	mov	r6,r2
   134d8:	180f883a 	mov	r7,r3
   134dc:	000f4900 	call	f490 <__adddf3>
   134e0:	9009883a 	mov	r4,r18
   134e4:	980b883a 	mov	r5,r19
   134e8:	100d883a 	mov	r6,r2
   134ec:	180f883a 	mov	r7,r3
   134f0:	1023883a 	mov	r17,r2
   134f4:	1829883a 	mov	r20,r3
   134f8:	00186280 	call	18628 <__ltdf2>
   134fc:	10000816 	blt	r2,zero,13520 <_dtoa_r+0x918>
   13500:	9009883a 	mov	r4,r18
   13504:	980b883a 	mov	r5,r19
   13508:	880d883a 	mov	r6,r17
   1350c:	a00f883a 	mov	r7,r20
   13510:	001850c0 	call	1850c <__eqdf2>
   13514:	103f5d1e 	bne	r2,zero,1328c <_dtoa_r+0x684>
   13518:	ad40004c 	andi	r21,r21,1
   1351c:	a83f5b26 	beq	r21,zero,1328c <_dtoa_r+0x684>
   13520:	b53fffc3 	ldbu	r20,-1(r22)
   13524:	b0ffff84 	addi	r3,r22,-2
   13528:	01400e44 	movi	r5,57
   1352c:	00000306 	br	1353c <_dtoa_r+0x934>
   13530:	1d000003 	ldbu	r20,0(r3)
   13534:	102d883a 	mov	r22,r2
   13538:	18ffffc4 	addi	r3,r3,-1
   1353c:	a1003fcc 	andi	r4,r20,255
   13540:	2100201c 	xori	r4,r4,128
   13544:	213fe004 	addi	r4,r4,-128
   13548:	b0bfffc4 	addi	r2,r22,-1
   1354c:	2142ca1e 	bne	r4,r5,14078 <_dtoa_r+0x1470>
   13550:	b8bff71e 	bne	r23,r2,13530 <_dtoa_r+0x928>
   13554:	d8800617 	ldw	r2,24(sp)
   13558:	05000c44 	movi	r20,49
   1355c:	10800044 	addi	r2,r2,1
   13560:	d8800615 	stw	r2,24(sp)
   13564:	00800c04 	movi	r2,48
   13568:	b8800005 	stb	r2,0(r23)
   1356c:	b805883a 	mov	r2,r23
   13570:	15000005 	stb	r20,0(r2)
   13574:	003f4506 	br	1328c <_dtoa_r+0x684>
   13578:	d9c00c17 	ldw	r7,48(sp)
   1357c:	3800c926 	beq	r7,zero,138a4 <_dtoa_r+0xc9c>
   13580:	d9c00417 	ldw	r7,16(sp)
   13584:	00c00044 	movi	r3,1
   13588:	19c16c0e 	bge	r3,r7,13b3c <_dtoa_r+0xf34>
   1358c:	d9000917 	ldw	r4,36(sp)
   13590:	d9c00a17 	ldw	r7,40(sp)
   13594:	24ffffc4 	addi	r19,r4,-1
   13598:	3cc20716 	blt	r7,r19,13db8 <_dtoa_r+0x11b0>
   1359c:	3ce7c83a 	sub	r19,r7,r19
   135a0:	d9c00917 	ldw	r7,36(sp)
   135a4:	3802ae16 	blt	r7,zero,14060 <_dtoa_r+0x1458>
   135a8:	dc800817 	ldw	r18,32(sp)
   135ac:	d8800917 	ldw	r2,36(sp)
   135b0:	d8c00817 	ldw	r3,32(sp)
   135b4:	d9c00717 	ldw	r7,28(sp)
   135b8:	8009883a 	mov	r4,r16
   135bc:	1887883a 	add	r3,r3,r2
   135c0:	388f883a 	add	r7,r7,r2
   135c4:	01400044 	movi	r5,1
   135c8:	d8c00815 	stw	r3,32(sp)
   135cc:	d9c00715 	stw	r7,28(sp)
   135d0:	001618c0 	call	1618c <__i2b>
   135d4:	102b883a 	mov	r21,r2
   135d8:	90000a26 	beq	r18,zero,13604 <_dtoa_r+0x9fc>
   135dc:	d8800717 	ldw	r2,28(sp)
   135e0:	0080080e 	bge	zero,r2,13604 <_dtoa_r+0x9fc>
   135e4:	90812b16 	blt	r18,r2,13a94 <_dtoa_r+0xe8c>
   135e8:	d8c00817 	ldw	r3,32(sp)
   135ec:	d9000717 	ldw	r4,28(sp)
   135f0:	90a5c83a 	sub	r18,r18,r2
   135f4:	1887c83a 	sub	r3,r3,r2
   135f8:	2089c83a 	sub	r4,r4,r2
   135fc:	d8c00815 	stw	r3,32(sp)
   13600:	d9000715 	stw	r4,28(sp)
   13604:	d9c00a17 	ldw	r7,40(sp)
   13608:	01c0140e 	bge	zero,r7,1365c <_dtoa_r+0xa54>
   1360c:	d8800c17 	ldw	r2,48(sp)
   13610:	1001de26 	beq	r2,zero,13d8c <_dtoa_r+0x1184>
   13614:	04c00e0e 	bge	zero,r19,13650 <_dtoa_r+0xa48>
   13618:	a80b883a 	mov	r5,r21
   1361c:	8009883a 	mov	r4,r16
   13620:	980d883a 	mov	r6,r19
   13624:	00163a80 	call	163a8 <__pow5mult>
   13628:	e00d883a 	mov	r6,fp
   1362c:	8009883a 	mov	r4,r16
   13630:	100b883a 	mov	r5,r2
   13634:	102b883a 	mov	r21,r2
   13638:	00161c80 	call	161c8 <__multiply>
   1363c:	1029883a 	mov	r20,r2
   13640:	e00b883a 	mov	r5,fp
   13644:	8009883a 	mov	r4,r16
   13648:	0015e340 	call	15e34 <_Bfree>
   1364c:	a039883a 	mov	fp,r20
   13650:	d8c00a17 	ldw	r3,40(sp)
   13654:	1ccdc83a 	sub	r6,r3,r19
   13658:	3001291e 	bne	r6,zero,13b00 <_dtoa_r+0xef8>
   1365c:	8009883a 	mov	r4,r16
   13660:	01400044 	movi	r5,1
   13664:	001618c0 	call	1618c <__i2b>
   13668:	d9000b17 	ldw	r4,44(sp)
   1366c:	1029883a 	mov	r20,r2
   13670:	0100050e 	bge	zero,r4,13688 <_dtoa_r+0xa80>
   13674:	d9800b17 	ldw	r6,44(sp)
   13678:	8009883a 	mov	r4,r16
   1367c:	100b883a 	mov	r5,r2
   13680:	00163a80 	call	163a8 <__pow5mult>
   13684:	1029883a 	mov	r20,r2
   13688:	d9c00417 	ldw	r7,16(sp)
   1368c:	00800044 	movi	r2,1
   13690:	11c0f00e 	bge	r2,r7,13a54 <_dtoa_r+0xe4c>
   13694:	0023883a 	mov	r17,zero
   13698:	d8800b17 	ldw	r2,44(sp)
   1369c:	1001741e 	bne	r2,zero,13c70 <_dtoa_r+0x1068>
   136a0:	00800044 	movi	r2,1
   136a4:	d8c00717 	ldw	r3,28(sp)
   136a8:	10c5883a 	add	r2,r2,r3
   136ac:	108007cc 	andi	r2,r2,31
   136b0:	10008026 	beq	r2,zero,138b4 <_dtoa_r+0xcac>
   136b4:	01000804 	movi	r4,32
   136b8:	2089c83a 	sub	r4,r4,r2
   136bc:	00c00104 	movi	r3,4
   136c0:	1902d00e 	bge	r3,r4,14204 <_dtoa_r+0x15fc>
   136c4:	d9000817 	ldw	r4,32(sp)
   136c8:	d9c00717 	ldw	r7,28(sp)
   136cc:	00c00704 	movi	r3,28
   136d0:	1885c83a 	sub	r2,r3,r2
   136d4:	2089883a 	add	r4,r4,r2
   136d8:	388f883a 	add	r7,r7,r2
   136dc:	d9000815 	stw	r4,32(sp)
   136e0:	90a5883a 	add	r18,r18,r2
   136e4:	d9c00715 	stw	r7,28(sp)
   136e8:	d9c00817 	ldw	r7,32(sp)
   136ec:	01c0050e 	bge	zero,r7,13704 <_dtoa_r+0xafc>
   136f0:	e00b883a 	mov	r5,fp
   136f4:	8009883a 	mov	r4,r16
   136f8:	380d883a 	mov	r6,r7
   136fc:	00164d40 	call	164d4 <__lshift>
   13700:	1039883a 	mov	fp,r2
   13704:	d8800717 	ldw	r2,28(sp)
   13708:	0080050e 	bge	zero,r2,13720 <_dtoa_r+0xb18>
   1370c:	a00b883a 	mov	r5,r20
   13710:	8009883a 	mov	r4,r16
   13714:	100d883a 	mov	r6,r2
   13718:	00164d40 	call	164d4 <__lshift>
   1371c:	1029883a 	mov	r20,r2
   13720:	d8c00d17 	ldw	r3,52(sp)
   13724:	1801401e 	bne	r3,zero,13c28 <_dtoa_r+0x1020>
   13728:	d8800917 	ldw	r2,36(sp)
   1372c:	00815a0e 	bge	zero,r2,13c98 <_dtoa_r+0x1090>
   13730:	d8c00c17 	ldw	r3,48(sp)
   13734:	18006f1e 	bne	r3,zero,138f4 <_dtoa_r+0xcec>
   13738:	b823883a 	mov	r17,r23
   1373c:	dc800917 	ldw	r18,36(sp)
   13740:	00000206 	br	1374c <_dtoa_r+0xb44>
   13744:	0015e5c0 	call	15e5c <__multadd>
   13748:	1039883a 	mov	fp,r2
   1374c:	e009883a 	mov	r4,fp
   13750:	a00b883a 	mov	r5,r20
   13754:	0012a000 	call	12a00 <quorem>
   13758:	10800c04 	addi	r2,r2,48
   1375c:	88800005 	stb	r2,0(r17)
   13760:	8c400044 	addi	r17,r17,1
   13764:	8dc7c83a 	sub	r3,r17,r23
   13768:	8009883a 	mov	r4,r16
   1376c:	e00b883a 	mov	r5,fp
   13770:	01800284 	movi	r6,10
   13774:	000f883a 	mov	r7,zero
   13778:	1cbff216 	blt	r3,r18,13744 <_dtoa_r+0xb3c>
   1377c:	dd800917 	ldw	r22,36(sp)
   13780:	1007883a 	mov	r3,r2
   13784:	05823a0e 	bge	zero,r22,14070 <_dtoa_r+0x1468>
   13788:	bdad883a 	add	r22,r23,r22
   1378c:	0023883a 	mov	r17,zero
   13790:	e00b883a 	mov	r5,fp
   13794:	01800044 	movi	r6,1
   13798:	8009883a 	mov	r4,r16
   1379c:	d8c01515 	stw	r3,84(sp)
   137a0:	00164d40 	call	164d4 <__lshift>
   137a4:	1009883a 	mov	r4,r2
   137a8:	a00b883a 	mov	r5,r20
   137ac:	1039883a 	mov	fp,r2
   137b0:	00166300 	call	16630 <__mcmp>
   137b4:	d8c01517 	ldw	r3,84(sp)
   137b8:	0080d60e 	bge	zero,r2,13b14 <_dtoa_r+0xf0c>
   137bc:	b13fffc3 	ldbu	r4,-1(r22)
   137c0:	b0ffff84 	addi	r3,r22,-2
   137c4:	01800e44 	movi	r6,57
   137c8:	00000306 	br	137d8 <_dtoa_r+0xbd0>
   137cc:	19000003 	ldbu	r4,0(r3)
   137d0:	102d883a 	mov	r22,r2
   137d4:	18ffffc4 	addi	r3,r3,-1
   137d8:	21403fcc 	andi	r5,r4,255
   137dc:	2940201c 	xori	r5,r5,128
   137e0:	297fe004 	addi	r5,r5,-128
   137e4:	b0bfffc4 	addi	r2,r22,-1
   137e8:	2981a71e 	bne	r5,r6,13e88 <_dtoa_r+0x1280>
   137ec:	b8bff71e 	bne	r23,r2,137cc <_dtoa_r+0xbc4>
   137f0:	d8800617 	ldw	r2,24(sp)
   137f4:	10800044 	addi	r2,r2,1
   137f8:	d8800615 	stw	r2,24(sp)
   137fc:	00800c44 	movi	r2,49
   13800:	b8800005 	stb	r2,0(r23)
   13804:	8009883a 	mov	r4,r16
   13808:	a00b883a 	mov	r5,r20
   1380c:	0015e340 	call	15e34 <_Bfree>
   13810:	a83e9e26 	beq	r21,zero,1328c <_dtoa_r+0x684>
   13814:	88000426 	beq	r17,zero,13828 <_dtoa_r+0xc20>
   13818:	8d400326 	beq	r17,r21,13828 <_dtoa_r+0xc20>
   1381c:	8009883a 	mov	r4,r16
   13820:	880b883a 	mov	r5,r17
   13824:	0015e340 	call	15e34 <_Bfree>
   13828:	8009883a 	mov	r4,r16
   1382c:	a80b883a 	mov	r5,r21
   13830:	0015e340 	call	15e34 <_Bfree>
   13834:	003e9506 	br	1328c <_dtoa_r+0x684>
   13838:	00c00044 	movi	r3,1
   1383c:	d8c00d15 	stw	r3,52(sp)
   13840:	003d9f06 	br	12ec0 <_dtoa_r+0x2b8>
   13844:	d9000817 	ldw	r4,32(sp)
   13848:	d8800617 	ldw	r2,24(sp)
   1384c:	d8000b15 	stw	zero,44(sp)
   13850:	2089c83a 	sub	r4,r4,r2
   13854:	0087c83a 	sub	r3,zero,r2
   13858:	d9000815 	stw	r4,32(sp)
   1385c:	d8c00a15 	stw	r3,40(sp)
   13860:	003da306 	br	12ef0 <_dtoa_r+0x2e8>
   13864:	0529c83a 	sub	r20,zero,r20
   13868:	dd000815 	stw	r20,32(sp)
   1386c:	d8000715 	stw	zero,28(sp)
   13870:	003d9806 	br	12ed4 <_dtoa_r+0x2cc>
   13874:	d9000617 	ldw	r4,24(sp)
   13878:	00186840 	call	18684 <__floatsidf>
   1387c:	1009883a 	mov	r4,r2
   13880:	180b883a 	mov	r5,r3
   13884:	980d883a 	mov	r6,r19
   13888:	900f883a 	mov	r7,r18
   1388c:	00185680 	call	18568 <__nedf2>
   13890:	103d7a26 	beq	r2,zero,12e7c <_dtoa_r+0x274>
   13894:	d8800617 	ldw	r2,24(sp)
   13898:	10bfffc4 	addi	r2,r2,-1
   1389c:	d8800615 	stw	r2,24(sp)
   138a0:	003d7606 	br	12e7c <_dtoa_r+0x274>
   138a4:	dcc00a17 	ldw	r19,40(sp)
   138a8:	dc800817 	ldw	r18,32(sp)
   138ac:	002b883a 	mov	r21,zero
   138b0:	003f4906 	br	135d8 <_dtoa_r+0x9d0>
   138b4:	00800704 	movi	r2,28
   138b8:	d8c00817 	ldw	r3,32(sp)
   138bc:	d9000717 	ldw	r4,28(sp)
   138c0:	90a5883a 	add	r18,r18,r2
   138c4:	1887883a 	add	r3,r3,r2
   138c8:	2089883a 	add	r4,r4,r2
   138cc:	d8c00815 	stw	r3,32(sp)
   138d0:	d9000715 	stw	r4,28(sp)
   138d4:	003f8406 	br	136e8 <_dtoa_r+0xae0>
   138d8:	d9c00317 	ldw	r7,12(sp)
   138dc:	013efb84 	movi	r4,-1042
   138e0:	2509c83a 	sub	r4,r4,r20
   138e4:	3908983a 	sll	r4,r7,r4
   138e8:	003d3006 	br	12dac <_dtoa_r+0x1a4>
   138ec:	d8000d15 	stw	zero,52(sp)
   138f0:	003d7306 	br	12ec0 <_dtoa_r+0x2b8>
   138f4:	0480050e 	bge	zero,r18,1390c <_dtoa_r+0xd04>
   138f8:	a80b883a 	mov	r5,r21
   138fc:	8009883a 	mov	r4,r16
   13900:	900d883a 	mov	r6,r18
   13904:	00164d40 	call	164d4 <__lshift>
   13908:	102b883a 	mov	r21,r2
   1390c:	8801611e 	bne	r17,zero,13e94 <_dtoa_r+0x128c>
   13910:	a827883a 	mov	r19,r21
   13914:	d8c00317 	ldw	r3,12(sp)
   13918:	d9000917 	ldw	r4,36(sp)
   1391c:	b8bfffc4 	addi	r2,r23,-1
   13920:	18c0004c 	andi	r3,r3,1
   13924:	1105883a 	add	r2,r2,r4
   13928:	b825883a 	mov	r18,r23
   1392c:	d8800515 	stw	r2,20(sp)
   13930:	a823883a 	mov	r17,r21
   13934:	d8c00315 	stw	r3,12(sp)
   13938:	ddc00715 	stw	r23,28(sp)
   1393c:	e009883a 	mov	r4,fp
   13940:	a00b883a 	mov	r5,r20
   13944:	0012a000 	call	12a00 <quorem>
   13948:	e009883a 	mov	r4,fp
   1394c:	880b883a 	mov	r5,r17
   13950:	102d883a 	mov	r22,r2
   13954:	00166300 	call	16630 <__mcmp>
   13958:	980d883a 	mov	r6,r19
   1395c:	8009883a 	mov	r4,r16
   13960:	a00b883a 	mov	r5,r20
   13964:	102b883a 	mov	r21,r2
   13968:	00166880 	call	16688 <__mdiff>
   1396c:	100d883a 	mov	r6,r2
   13970:	10800317 	ldw	r2,12(r2)
   13974:	b5c00c04 	addi	r23,r22,48
   13978:	10008c26 	beq	r2,zero,13bac <_dtoa_r+0xfa4>
   1397c:	8009883a 	mov	r4,r16
   13980:	300b883a 	mov	r5,r6
   13984:	0015e340 	call	15e34 <_Bfree>
   13988:	00800044 	movi	r2,1
   1398c:	a8007116 	blt	r21,zero,13b54 <_dtoa_r+0xf4c>
   13990:	a800041e 	bne	r21,zero,139a4 <_dtoa_r+0xd9c>
   13994:	d9c00417 	ldw	r7,16(sp)
   13998:	3800021e 	bne	r7,zero,139a4 <_dtoa_r+0xd9c>
   1399c:	d8c00317 	ldw	r3,12(sp)
   139a0:	18006c26 	beq	r3,zero,13b54 <_dtoa_r+0xf4c>
   139a4:	00814c16 	blt	zero,r2,13ed8 <_dtoa_r+0x12d0>
   139a8:	d8c00517 	ldw	r3,20(sp)
   139ac:	95400044 	addi	r21,r18,1
   139b0:	95c00005 	stb	r23,0(r18)
   139b4:	a82d883a 	mov	r22,r21
   139b8:	90c14d26 	beq	r18,r3,13ef0 <_dtoa_r+0x12e8>
   139bc:	e00b883a 	mov	r5,fp
   139c0:	8009883a 	mov	r4,r16
   139c4:	01800284 	movi	r6,10
   139c8:	000f883a 	mov	r7,zero
   139cc:	0015e5c0 	call	15e5c <__multadd>
   139d0:	1039883a 	mov	fp,r2
   139d4:	8cc08b26 	beq	r17,r19,13c04 <_dtoa_r+0xffc>
   139d8:	880b883a 	mov	r5,r17
   139dc:	01800284 	movi	r6,10
   139e0:	000f883a 	mov	r7,zero
   139e4:	8009883a 	mov	r4,r16
   139e8:	0015e5c0 	call	15e5c <__multadd>
   139ec:	980b883a 	mov	r5,r19
   139f0:	8009883a 	mov	r4,r16
   139f4:	01800284 	movi	r6,10
   139f8:	000f883a 	mov	r7,zero
   139fc:	1023883a 	mov	r17,r2
   13a00:	0015e5c0 	call	15e5c <__multadd>
   13a04:	1027883a 	mov	r19,r2
   13a08:	a825883a 	mov	r18,r21
   13a0c:	003fcb06 	br	1393c <_dtoa_r+0xd34>
   13a10:	d9c00417 	ldw	r7,16(sp)
   13a14:	00800104 	movi	r2,4
   13a18:	3880e426 	beq	r7,r2,13dac <_dtoa_r+0x11a4>
   13a1c:	00800144 	movi	r2,5
   13a20:	38be3c1e 	bne	r7,r2,13314 <_dtoa_r+0x70c>
   13a24:	00c00044 	movi	r3,1
   13a28:	d8c00c15 	stw	r3,48(sp)
   13a2c:	d9c02117 	ldw	r7,132(sp)
   13a30:	d8800617 	ldw	r2,24(sp)
   13a34:	388f883a 	add	r7,r7,r2
   13a38:	3c800044 	addi	r18,r7,1
   13a3c:	d9c00e15 	stw	r7,56(sp)
   13a40:	dc800915 	stw	r18,36(sp)
   13a44:	04bd3e16 	blt	zero,r18,12f40 <_dtoa_r+0x338>
   13a48:	80001115 	stw	zero,68(r16)
   13a4c:	000b883a 	mov	r5,zero
   13a50:	003d4606 	br	12f6c <_dtoa_r+0x364>
   13a54:	d8c00317 	ldw	r3,12(sp)
   13a58:	183f0e1e 	bne	r3,zero,13694 <_dtoa_r+0xa8c>
   13a5c:	00c00434 	movhi	r3,16
   13a60:	18ffffc4 	addi	r3,r3,-1
   13a64:	88c6703a 	and	r3,r17,r3
   13a68:	183f0a1e 	bne	r3,zero,13694 <_dtoa_r+0xa8c>
   13a6c:	8c5ffc2c 	andhi	r17,r17,32752
   13a70:	883f0826 	beq	r17,zero,13694 <_dtoa_r+0xa8c>
   13a74:	d9000817 	ldw	r4,32(sp)
   13a78:	d9c00717 	ldw	r7,28(sp)
   13a7c:	1023883a 	mov	r17,r2
   13a80:	2089883a 	add	r4,r4,r2
   13a84:	388f883a 	add	r7,r7,r2
   13a88:	d9000815 	stw	r4,32(sp)
   13a8c:	d9c00715 	stw	r7,28(sp)
   13a90:	003f0106 	br	13698 <_dtoa_r+0xa90>
   13a94:	9005883a 	mov	r2,r18
   13a98:	003ed306 	br	135e8 <_dtoa_r+0x9e0>
   13a9c:	d8800917 	ldw	r2,36(sp)
   13aa0:	00be3516 	blt	zero,r2,13378 <_dtoa_r+0x770>
   13aa4:	1000b61e 	bne	r2,zero,13d80 <_dtoa_r+0x1178>
   13aa8:	9009883a 	mov	r4,r18
   13aac:	980b883a 	mov	r5,r19
   13ab0:	000d883a 	mov	r6,zero
   13ab4:	01d00534 	movhi	r7,16404
   13ab8:	000f5440 	call	f544 <__muldf3>
   13abc:	d9800317 	ldw	r6,12(sp)
   13ac0:	1009883a 	mov	r4,r2
   13ac4:	180b883a 	mov	r5,r3
   13ac8:	880f883a 	mov	r7,r17
   13acc:	000f9dc0 	call	f9dc <__gedf2>
   13ad0:	0029883a 	mov	r20,zero
   13ad4:	002b883a 	mov	r21,zero
   13ad8:	10007e16 	blt	r2,zero,13cd4 <_dtoa_r+0x10cc>
   13adc:	d8802117 	ldw	r2,132(sp)
   13ae0:	b82d883a 	mov	r22,r23
   13ae4:	0084303a 	nor	r2,zero,r2
   13ae8:	d8800615 	stw	r2,24(sp)
   13aec:	8009883a 	mov	r4,r16
   13af0:	a00b883a 	mov	r5,r20
   13af4:	0015e340 	call	15e34 <_Bfree>
   13af8:	a83f4b1e 	bne	r21,zero,13828 <_dtoa_r+0xc20>
   13afc:	003de306 	br	1328c <_dtoa_r+0x684>
   13b00:	e00b883a 	mov	r5,fp
   13b04:	8009883a 	mov	r4,r16
   13b08:	00163a80 	call	163a8 <__pow5mult>
   13b0c:	1039883a 	mov	fp,r2
   13b10:	003ed206 	br	1365c <_dtoa_r+0xa54>
   13b14:	1000021e 	bne	r2,zero,13b20 <_dtoa_r+0xf18>
   13b18:	18c0004c 	andi	r3,r3,1
   13b1c:	183f271e 	bne	r3,zero,137bc <_dtoa_r+0xbb4>
   13b20:	01000c04 	movi	r4,48
   13b24:	00000106 	br	13b2c <_dtoa_r+0xf24>
   13b28:	102d883a 	mov	r22,r2
   13b2c:	b0bfffc4 	addi	r2,r22,-1
   13b30:	10c00007 	ldb	r3,0(r2)
   13b34:	193ffc26 	beq	r3,r4,13b28 <_dtoa_r+0xf20>
   13b38:	003f3206 	br	13804 <_dtoa_r+0xbfc>
   13b3c:	d8c00f17 	ldw	r3,60(sp)
   13b40:	18015026 	beq	r3,zero,14084 <_dtoa_r+0x147c>
   13b44:	10810cc4 	addi	r2,r2,1075
   13b48:	dcc00a17 	ldw	r19,40(sp)
   13b4c:	dc800817 	ldw	r18,32(sp)
   13b50:	003e9706 	br	135b0 <_dtoa_r+0x9a8>
   13b54:	b807883a 	mov	r3,r23
   13b58:	182b883a 	mov	r21,r3
   13b5c:	ddc00717 	ldw	r23,28(sp)
   13b60:	00800e0e 	bge	zero,r2,13b9c <_dtoa_r+0xf94>
   13b64:	e00b883a 	mov	r5,fp
   13b68:	01800044 	movi	r6,1
   13b6c:	8009883a 	mov	r4,r16
   13b70:	d8c01515 	stw	r3,84(sp)
   13b74:	00164d40 	call	164d4 <__lshift>
   13b78:	1009883a 	mov	r4,r2
   13b7c:	a00b883a 	mov	r5,r20
   13b80:	1039883a 	mov	fp,r2
   13b84:	00166300 	call	16630 <__mcmp>
   13b88:	d8c01517 	ldw	r3,84(sp)
   13b8c:	0081880e 	bge	zero,r2,141b0 <_dtoa_r+0x15a8>
   13b90:	00800e44 	movi	r2,57
   13b94:	b0c00c44 	addi	r3,r22,49
   13b98:	a8816326 	beq	r21,r2,14128 <_dtoa_r+0x1520>
   13b9c:	90c00005 	stb	r3,0(r18)
   13ba0:	95800044 	addi	r22,r18,1
   13ba4:	982b883a 	mov	r21,r19
   13ba8:	003f1606 	br	13804 <_dtoa_r+0xbfc>
   13bac:	300b883a 	mov	r5,r6
   13bb0:	e009883a 	mov	r4,fp
   13bb4:	d9801515 	stw	r6,84(sp)
   13bb8:	00166300 	call	16630 <__mcmp>
   13bbc:	d9801517 	ldw	r6,84(sp)
   13bc0:	8009883a 	mov	r4,r16
   13bc4:	d8801515 	stw	r2,84(sp)
   13bc8:	300b883a 	mov	r5,r6
   13bcc:	0015e340 	call	15e34 <_Bfree>
   13bd0:	d8801517 	ldw	r2,84(sp)
   13bd4:	103f6d1e 	bne	r2,zero,1398c <_dtoa_r+0xd84>
   13bd8:	d9c00417 	ldw	r7,16(sp)
   13bdc:	383f6b1e 	bne	r7,zero,1398c <_dtoa_r+0xd84>
   13be0:	d8c00317 	ldw	r3,12(sp)
   13be4:	183f691e 	bne	r3,zero,1398c <_dtoa_r+0xd84>
   13be8:	b807883a 	mov	r3,r23
   13bec:	00800e44 	movi	r2,57
   13bf0:	ddc00717 	ldw	r23,28(sp)
   13bf4:	18814c26 	beq	r3,r2,14128 <_dtoa_r+0x1520>
   13bf8:	057fe80e 	bge	zero,r21,13b9c <_dtoa_r+0xf94>
   13bfc:	b0c00c44 	addi	r3,r22,49
   13c00:	003fe606 	br	13b9c <_dtoa_r+0xf94>
   13c04:	880b883a 	mov	r5,r17
   13c08:	8009883a 	mov	r4,r16
   13c0c:	01800284 	movi	r6,10
   13c10:	000f883a 	mov	r7,zero
   13c14:	0015e5c0 	call	15e5c <__multadd>
   13c18:	1023883a 	mov	r17,r2
   13c1c:	1027883a 	mov	r19,r2
   13c20:	a825883a 	mov	r18,r21
   13c24:	003f4506 	br	1393c <_dtoa_r+0xd34>
   13c28:	e009883a 	mov	r4,fp
   13c2c:	a00b883a 	mov	r5,r20
   13c30:	00166300 	call	16630 <__mcmp>
   13c34:	103ebc0e 	bge	r2,zero,13728 <_dtoa_r+0xb20>
   13c38:	e00b883a 	mov	r5,fp
   13c3c:	8009883a 	mov	r4,r16
   13c40:	01800284 	movi	r6,10
   13c44:	000f883a 	mov	r7,zero
   13c48:	0015e5c0 	call	15e5c <__multadd>
   13c4c:	1039883a 	mov	fp,r2
   13c50:	d8800617 	ldw	r2,24(sp)
   13c54:	d8c00c17 	ldw	r3,48(sp)
   13c58:	10bfffc4 	addi	r2,r2,-1
   13c5c:	d8800615 	stw	r2,24(sp)
   13c60:	1801571e 	bne	r3,zero,141c0 <_dtoa_r+0x15b8>
   13c64:	d9c00e17 	ldw	r7,56(sp)
   13c68:	d9c00915 	stw	r7,36(sp)
   13c6c:	003eae06 	br	13728 <_dtoa_r+0xb20>
   13c70:	a0800417 	ldw	r2,16(r20)
   13c74:	10800104 	addi	r2,r2,4
   13c78:	1085883a 	add	r2,r2,r2
   13c7c:	1085883a 	add	r2,r2,r2
   13c80:	a085883a 	add	r2,r20,r2
   13c84:	11000017 	ldw	r4,0(r2)
   13c88:	00160740 	call	16074 <__hi0bits>
   13c8c:	00c00804 	movi	r3,32
   13c90:	1885c83a 	sub	r2,r3,r2
   13c94:	003e8306 	br	136a4 <_dtoa_r+0xa9c>
   13c98:	d9c00417 	ldw	r7,16(sp)
   13c9c:	00800084 	movi	r2,2
   13ca0:	11fea30e 	bge	r2,r7,13730 <_dtoa_r+0xb28>
   13ca4:	d8800917 	ldw	r2,36(sp)
   13ca8:	103f8c1e 	bne	r2,zero,13adc <_dtoa_r+0xed4>
   13cac:	a00b883a 	mov	r5,r20
   13cb0:	8009883a 	mov	r4,r16
   13cb4:	01800144 	movi	r6,5
   13cb8:	000f883a 	mov	r7,zero
   13cbc:	0015e5c0 	call	15e5c <__multadd>
   13cc0:	e009883a 	mov	r4,fp
   13cc4:	100b883a 	mov	r5,r2
   13cc8:	1029883a 	mov	r20,r2
   13ccc:	00166300 	call	16630 <__mcmp>
   13cd0:	00bf820e 	bge	zero,r2,13adc <_dtoa_r+0xed4>
   13cd4:	00800c44 	movi	r2,49
   13cd8:	b8800005 	stb	r2,0(r23)
   13cdc:	d8800617 	ldw	r2,24(sp)
   13ce0:	bd800044 	addi	r22,r23,1
   13ce4:	10800044 	addi	r2,r2,1
   13ce8:	d8800615 	stw	r2,24(sp)
   13cec:	003f7f06 	br	13aec <_dtoa_r+0xee4>
   13cf0:	dc000417 	ldw	r16,16(sp)
   13cf4:	003d6506 	br	1328c <_dtoa_r+0x684>
   13cf8:	9009883a 	mov	r4,r18
   13cfc:	00186840 	call	18684 <__floatsidf>
   13d00:	1009883a 	mov	r4,r2
   13d04:	180b883a 	mov	r5,r3
   13d08:	980d883a 	mov	r6,r19
   13d0c:	a00f883a 	mov	r7,r20
   13d10:	000f5440 	call	f544 <__muldf3>
   13d14:	1009883a 	mov	r4,r2
   13d18:	180b883a 	mov	r5,r3
   13d1c:	000d883a 	mov	r6,zero
   13d20:	01d00734 	movhi	r7,16412
   13d24:	000f4900 	call	f490 <__adddf3>
   13d28:	057f3034 	movhi	r21,64704
   13d2c:	1025883a 	mov	r18,r2
   13d30:	1d6b883a 	add	r21,r3,r21
   13d34:	9809883a 	mov	r4,r19
   13d38:	a00b883a 	mov	r5,r20
   13d3c:	000d883a 	mov	r6,zero
   13d40:	01d00534 	movhi	r7,16404
   13d44:	000f4e40 	call	f4e4 <__subdf3>
   13d48:	1009883a 	mov	r4,r2
   13d4c:	180b883a 	mov	r5,r3
   13d50:	900d883a 	mov	r6,r18
   13d54:	a80f883a 	mov	r7,r21
   13d58:	1027883a 	mov	r19,r2
   13d5c:	1829883a 	mov	r20,r3
   13d60:	00185c40 	call	185c4 <__gtdf2>
   13d64:	00806616 	blt	zero,r2,13f00 <_dtoa_r+0x12f8>
   13d68:	a9e0003c 	xorhi	r7,r21,32768
   13d6c:	9809883a 	mov	r4,r19
   13d70:	a00b883a 	mov	r5,r20
   13d74:	900d883a 	mov	r6,r18
   13d78:	00186280 	call	18628 <__ltdf2>
   13d7c:	103d710e 	bge	r2,zero,13344 <_dtoa_r+0x73c>
   13d80:	0029883a 	mov	r20,zero
   13d84:	002b883a 	mov	r21,zero
   13d88:	003f5406 	br	13adc <_dtoa_r+0xed4>
   13d8c:	d9800a17 	ldw	r6,40(sp)
   13d90:	e00b883a 	mov	r5,fp
   13d94:	8009883a 	mov	r4,r16
   13d98:	00163a80 	call	163a8 <__pow5mult>
   13d9c:	1039883a 	mov	fp,r2
   13da0:	003e2e06 	br	1365c <_dtoa_r+0xa54>
   13da4:	d8000c15 	stw	zero,48(sp)
   13da8:	003f2006 	br	13a2c <_dtoa_r+0xe24>
   13dac:	00800044 	movi	r2,1
   13db0:	d8800c15 	stw	r2,48(sp)
   13db4:	003c5d06 	br	12f2c <_dtoa_r+0x324>
   13db8:	d8c00a17 	ldw	r3,40(sp)
   13dbc:	d9000b17 	ldw	r4,44(sp)
   13dc0:	dcc00a15 	stw	r19,40(sp)
   13dc4:	98c5c83a 	sub	r2,r19,r3
   13dc8:	2089883a 	add	r4,r4,r2
   13dcc:	d9000b15 	stw	r4,44(sp)
   13dd0:	0027883a 	mov	r19,zero
   13dd4:	003df206 	br	135a0 <_dtoa_r+0x998>
   13dd8:	d9000317 	ldw	r4,12(sp)
   13ddc:	8829883a 	mov	r20,r17
   13de0:	04800084 	movi	r18,2
   13de4:	d9001015 	stw	r4,64(sp)
   13de8:	003c8106 	br	12ff0 <_dtoa_r+0x3e8>
   13dec:	04800044 	movi	r18,1
   13df0:	dc800e15 	stw	r18,56(sp)
   13df4:	dc800915 	stw	r18,36(sp)
   13df8:	dc802115 	stw	r18,132(sp)
   13dfc:	003f1206 	br	13a48 <_dtoa_r+0xe40>
   13e00:	d8800617 	ldw	r2,24(sp)
   13e04:	00abc83a 	sub	r21,zero,r2
   13e08:	a800a426 	beq	r21,zero,1409c <_dtoa_r+0x1494>
   13e0c:	a88003cc 	andi	r2,r21,15
   13e10:	100490fa 	slli	r2,r2,3
   13e14:	00c000b4 	movhi	r3,2
   13e18:	18d86b04 	addi	r3,r3,25004
   13e1c:	d9000317 	ldw	r4,12(sp)
   13e20:	1885883a 	add	r2,r3,r2
   13e24:	11800017 	ldw	r6,0(r2)
   13e28:	11c00117 	ldw	r7,4(r2)
   13e2c:	a82bd13a 	srai	r21,r21,4
   13e30:	880b883a 	mov	r5,r17
   13e34:	000f5440 	call	f544 <__muldf3>
   13e38:	1027883a 	mov	r19,r2
   13e3c:	1829883a 	mov	r20,r3
   13e40:	a800e826 	beq	r21,zero,141e4 <_dtoa_r+0x15dc>
   13e44:	058000b4 	movhi	r22,2
   13e48:	b5986104 	addi	r22,r22,24964
   13e4c:	04800084 	movi	r18,2
   13e50:	a980004c 	andi	r6,r21,1
   13e54:	1009883a 	mov	r4,r2
   13e58:	a82bd07a 	srai	r21,r21,1
   13e5c:	180b883a 	mov	r5,r3
   13e60:	30000426 	beq	r6,zero,13e74 <_dtoa_r+0x126c>
   13e64:	b1800017 	ldw	r6,0(r22)
   13e68:	b1c00117 	ldw	r7,4(r22)
   13e6c:	94800044 	addi	r18,r18,1
   13e70:	000f5440 	call	f544 <__muldf3>
   13e74:	b5800204 	addi	r22,r22,8
   13e78:	a83ff51e 	bne	r21,zero,13e50 <_dtoa_r+0x1248>
   13e7c:	1027883a 	mov	r19,r2
   13e80:	1829883a 	mov	r20,r3
   13e84:	003c7306 	br	13054 <_dtoa_r+0x44c>
   13e88:	21000044 	addi	r4,r4,1
   13e8c:	11000005 	stb	r4,0(r2)
   13e90:	003e5c06 	br	13804 <_dtoa_r+0xbfc>
   13e94:	a9400117 	ldw	r5,4(r21)
   13e98:	8009883a 	mov	r4,r16
   13e9c:	0015d8c0 	call	15d8c <_Balloc>
   13ea0:	a9800417 	ldw	r6,16(r21)
   13ea4:	11000304 	addi	r4,r2,12
   13ea8:	a9400304 	addi	r5,r21,12
   13eac:	31800084 	addi	r6,r6,2
   13eb0:	318d883a 	add	r6,r6,r6
   13eb4:	318d883a 	add	r6,r6,r6
   13eb8:	1023883a 	mov	r17,r2
   13ebc:	00102380 	call	10238 <memcpy>
   13ec0:	8009883a 	mov	r4,r16
   13ec4:	880b883a 	mov	r5,r17
   13ec8:	01800044 	movi	r6,1
   13ecc:	00164d40 	call	164d4 <__lshift>
   13ed0:	1027883a 	mov	r19,r2
   13ed4:	003e8f06 	br	13914 <_dtoa_r+0xd0c>
   13ed8:	b807883a 	mov	r3,r23
   13edc:	00800e44 	movi	r2,57
   13ee0:	ddc00717 	ldw	r23,28(sp)
   13ee4:	18809026 	beq	r3,r2,14128 <_dtoa_r+0x1520>
   13ee8:	18c00044 	addi	r3,r3,1
   13eec:	003f2b06 	br	13b9c <_dtoa_r+0xf94>
   13ef0:	b807883a 	mov	r3,r23
   13ef4:	982b883a 	mov	r21,r19
   13ef8:	ddc00717 	ldw	r23,28(sp)
   13efc:	003e2406 	br	13790 <_dtoa_r+0xb88>
   13f00:	0029883a 	mov	r20,zero
   13f04:	002b883a 	mov	r21,zero
   13f08:	003f7206 	br	13cd4 <_dtoa_r+0x10cc>
   13f0c:	593fffc4 	addi	r4,r11,-1
   13f10:	200490fa 	slli	r2,r4,3
   13f14:	00c000b4 	movhi	r3,2
   13f18:	18d86b04 	addi	r3,r3,25004
   13f1c:	d9001015 	stw	r4,64(sp)
   13f20:	1885883a 	add	r2,r3,r2
   13f24:	11000017 	ldw	r4,0(r2)
   13f28:	11400117 	ldw	r5,4(r2)
   13f2c:	900d883a 	mov	r6,r18
   13f30:	a80f883a 	mov	r7,r21
   13f34:	dac01615 	stw	r11,88(sp)
   13f38:	000f5440 	call	f544 <__muldf3>
   13f3c:	a00b883a 	mov	r5,r20
   13f40:	9809883a 	mov	r4,r19
   13f44:	d8c01215 	stw	r3,72(sp)
   13f48:	d8801115 	stw	r2,68(sp)
   13f4c:	000fa400 	call	fa40 <__fixdfsi>
   13f50:	1009883a 	mov	r4,r2
   13f54:	1025883a 	mov	r18,r2
   13f58:	00186840 	call	18684 <__floatsidf>
   13f5c:	9809883a 	mov	r4,r19
   13f60:	a00b883a 	mov	r5,r20
   13f64:	100d883a 	mov	r6,r2
   13f68:	180f883a 	mov	r7,r3
   13f6c:	94800c04 	addi	r18,r18,48
   13f70:	000f4e40 	call	f4e4 <__subdf3>
   13f74:	bc800005 	stb	r18,0(r23)
   13f78:	dac01617 	ldw	r11,88(sp)
   13f7c:	102b883a 	mov	r21,r2
   13f80:	00800044 	movi	r2,1
   13f84:	bd800044 	addi	r22,r23,1
   13f88:	1815883a 	mov	r10,r3
   13f8c:	58802226 	beq	r11,r2,14018 <_dtoa_r+0x1410>
   13f90:	bad7883a 	add	r11,r23,r11
   13f94:	dc001415 	stw	r16,80(sp)
   13f98:	a805883a 	mov	r2,r21
   13f9c:	b027883a 	mov	r19,r22
   13fa0:	5821883a 	mov	r16,r11
   13fa4:	882b883a 	mov	r21,r17
   13fa8:	000d883a 	mov	r6,zero
   13fac:	01d00934 	movhi	r7,16420
   13fb0:	1009883a 	mov	r4,r2
   13fb4:	180b883a 	mov	r5,r3
   13fb8:	000f5440 	call	f544 <__muldf3>
   13fbc:	180b883a 	mov	r5,r3
   13fc0:	1009883a 	mov	r4,r2
   13fc4:	1829883a 	mov	r20,r3
   13fc8:	1023883a 	mov	r17,r2
   13fcc:	000fa400 	call	fa40 <__fixdfsi>
   13fd0:	1009883a 	mov	r4,r2
   13fd4:	1025883a 	mov	r18,r2
   13fd8:	00186840 	call	18684 <__floatsidf>
   13fdc:	8809883a 	mov	r4,r17
   13fe0:	a00b883a 	mov	r5,r20
   13fe4:	100d883a 	mov	r6,r2
   13fe8:	180f883a 	mov	r7,r3
   13fec:	94800c04 	addi	r18,r18,48
   13ff0:	000f4e40 	call	f4e4 <__subdf3>
   13ff4:	9cc00044 	addi	r19,r19,1
   13ff8:	9cbfffc5 	stb	r18,-1(r19)
   13ffc:	9c3fea1e 	bne	r19,r16,13fa8 <_dtoa_r+0x13a0>
   14000:	1815883a 	mov	r10,r3
   14004:	d8c01017 	ldw	r3,64(sp)
   14008:	dc001417 	ldw	r16,80(sp)
   1400c:	a823883a 	mov	r17,r21
   14010:	b0ed883a 	add	r22,r22,r3
   14014:	102b883a 	mov	r21,r2
   14018:	d9001117 	ldw	r4,68(sp)
   1401c:	d9401217 	ldw	r5,72(sp)
   14020:	000d883a 	mov	r6,zero
   14024:	01cff834 	movhi	r7,16352
   14028:	da801515 	stw	r10,84(sp)
   1402c:	000f4900 	call	f490 <__adddf3>
   14030:	da801517 	ldw	r10,84(sp)
   14034:	1009883a 	mov	r4,r2
   14038:	180b883a 	mov	r5,r3
   1403c:	500f883a 	mov	r7,r10
   14040:	a80d883a 	mov	r6,r21
   14044:	00186280 	call	18628 <__ltdf2>
   14048:	da801517 	ldw	r10,84(sp)
   1404c:	10003b0e 	bge	r2,zero,1413c <_dtoa_r+0x1534>
   14050:	d9c01317 	ldw	r7,76(sp)
   14054:	b53fffc3 	ldbu	r20,-1(r22)
   14058:	d9c00615 	stw	r7,24(sp)
   1405c:	003d3106 	br	13524 <_dtoa_r+0x91c>
   14060:	d8800817 	ldw	r2,32(sp)
   14064:	11e5c83a 	sub	r18,r2,r7
   14068:	0005883a 	mov	r2,zero
   1406c:	003d5006 	br	135b0 <_dtoa_r+0x9a8>
   14070:	05800044 	movi	r22,1
   14074:	003dc406 	br	13788 <_dtoa_r+0xb80>
   14078:	a5000044 	addi	r20,r20,1
   1407c:	15000005 	stb	r20,0(r2)
   14080:	003c8206 	br	1328c <_dtoa_r+0x684>
   14084:	d8800217 	ldw	r2,8(sp)
   14088:	00c00d84 	movi	r3,54
   1408c:	dcc00a17 	ldw	r19,40(sp)
   14090:	1885c83a 	sub	r2,r3,r2
   14094:	dc800817 	ldw	r18,32(sp)
   14098:	003d4506 	br	135b0 <_dtoa_r+0x9a8>
   1409c:	dcc00317 	ldw	r19,12(sp)
   140a0:	8829883a 	mov	r20,r17
   140a4:	04800084 	movi	r18,2
   140a8:	003bea06 	br	13054 <_dtoa_r+0x44c>
   140ac:	d9000917 	ldw	r4,36(sp)
   140b0:	203f1126 	beq	r4,zero,13cf8 <_dtoa_r+0x10f0>
   140b4:	d9c00e17 	ldw	r7,56(sp)
   140b8:	01fca20e 	bge	zero,r7,13344 <_dtoa_r+0x73c>
   140bc:	a00b883a 	mov	r5,r20
   140c0:	9809883a 	mov	r4,r19
   140c4:	000d883a 	mov	r6,zero
   140c8:	01d00934 	movhi	r7,16420
   140cc:	000f5440 	call	f544 <__muldf3>
   140d0:	91000044 	addi	r4,r18,1
   140d4:	1027883a 	mov	r19,r2
   140d8:	1829883a 	mov	r20,r3
   140dc:	00186840 	call	18684 <__floatsidf>
   140e0:	9809883a 	mov	r4,r19
   140e4:	a00b883a 	mov	r5,r20
   140e8:	100d883a 	mov	r6,r2
   140ec:	180f883a 	mov	r7,r3
   140f0:	000f5440 	call	f544 <__muldf3>
   140f4:	1009883a 	mov	r4,r2
   140f8:	180b883a 	mov	r5,r3
   140fc:	000d883a 	mov	r6,zero
   14100:	01d00734 	movhi	r7,16412
   14104:	000f4900 	call	f490 <__adddf3>
   14108:	1025883a 	mov	r18,r2
   1410c:	d8800617 	ldw	r2,24(sp)
   14110:	057f3034 	movhi	r21,64704
   14114:	1d6b883a 	add	r21,r3,r21
   14118:	10bfffc4 	addi	r2,r2,-1
   1411c:	d8801315 	stw	r2,76(sp)
   14120:	dac00e17 	ldw	r11,56(sp)
   14124:	003be706 	br	130c4 <_dtoa_r+0x4bc>
   14128:	01000e44 	movi	r4,57
   1412c:	91000005 	stb	r4,0(r18)
   14130:	95800044 	addi	r22,r18,1
   14134:	982b883a 	mov	r21,r19
   14138:	003da106 	br	137c0 <_dtoa_r+0xbb8>
   1413c:	d9801117 	ldw	r6,68(sp)
   14140:	d9c01217 	ldw	r7,72(sp)
   14144:	0009883a 	mov	r4,zero
   14148:	014ff834 	movhi	r5,16352
   1414c:	da801515 	stw	r10,84(sp)
   14150:	000f4e40 	call	f4e4 <__subdf3>
   14154:	da801517 	ldw	r10,84(sp)
   14158:	1009883a 	mov	r4,r2
   1415c:	180b883a 	mov	r5,r3
   14160:	a80d883a 	mov	r6,r21
   14164:	500f883a 	mov	r7,r10
   14168:	00185c40 	call	185c4 <__gtdf2>
   1416c:	00bc750e 	bge	zero,r2,13344 <_dtoa_r+0x73c>
   14170:	01000c04 	movi	r4,48
   14174:	00000106 	br	1417c <_dtoa_r+0x1574>
   14178:	102d883a 	mov	r22,r2
   1417c:	b0bfffc4 	addi	r2,r22,-1
   14180:	10c00007 	ldb	r3,0(r2)
   14184:	193ffc26 	beq	r3,r4,14178 <_dtoa_r+0x1570>
   14188:	d8801317 	ldw	r2,76(sp)
   1418c:	d8800615 	stw	r2,24(sp)
   14190:	003c3e06 	br	1328c <_dtoa_r+0x684>
   14194:	d9001317 	ldw	r4,76(sp)
   14198:	df001117 	ldw	fp,68(sp)
   1419c:	d9000615 	stw	r4,24(sp)
   141a0:	003ce006 	br	13524 <_dtoa_r+0x91c>
   141a4:	df001117 	ldw	fp,68(sp)
   141a8:	dc401217 	ldw	r17,72(sp)
   141ac:	003c6506 	br	13344 <_dtoa_r+0x73c>
   141b0:	103e7a1e 	bne	r2,zero,13b9c <_dtoa_r+0xf94>
   141b4:	1880004c 	andi	r2,r3,1
   141b8:	103e7826 	beq	r2,zero,13b9c <_dtoa_r+0xf94>
   141bc:	003e7406 	br	13b90 <_dtoa_r+0xf88>
   141c0:	8009883a 	mov	r4,r16
   141c4:	a80b883a 	mov	r5,r21
   141c8:	01800284 	movi	r6,10
   141cc:	000f883a 	mov	r7,zero
   141d0:	0015e5c0 	call	15e5c <__multadd>
   141d4:	d9000e17 	ldw	r4,56(sp)
   141d8:	102b883a 	mov	r21,r2
   141dc:	d9000915 	stw	r4,36(sp)
   141e0:	003d5106 	br	13728 <_dtoa_r+0xb20>
   141e4:	04800084 	movi	r18,2
   141e8:	003b9a06 	br	13054 <_dtoa_r+0x44c>
   141ec:	d8c01317 	ldw	r3,76(sp)
   141f0:	d8c00615 	stw	r3,24(sp)
   141f4:	003ccb06 	br	13524 <_dtoa_r+0x91c>
   141f8:	d8c01317 	ldw	r3,76(sp)
   141fc:	d8c00615 	stw	r3,24(sp)
   14200:	003c2206 	br	1328c <_dtoa_r+0x684>
   14204:	20fd3826 	beq	r4,r3,136e8 <_dtoa_r+0xae0>
   14208:	00c00f04 	movi	r3,60
   1420c:	1885c83a 	sub	r2,r3,r2
   14210:	003da906 	br	138b8 <_dtoa_r+0xcb0>
   14214:	000b883a 	mov	r5,zero
   14218:	003b5406 	br	12f6c <_dtoa_r+0x364>
   1421c:	04c00044 	movi	r19,1
   14220:	003b3b06 	br	12f10 <_dtoa_r+0x308>

00014224 <_fflush_r>:
   14224:	defffb04 	addi	sp,sp,-20
   14228:	dcc00315 	stw	r19,12(sp)
   1422c:	dc400115 	stw	r17,4(sp)
   14230:	dfc00415 	stw	ra,16(sp)
   14234:	dc800215 	stw	r18,8(sp)
   14238:	dc000015 	stw	r16,0(sp)
   1423c:	2027883a 	mov	r19,r4
   14240:	2823883a 	mov	r17,r5
   14244:	20000226 	beq	r4,zero,14250 <_fflush_r+0x2c>
   14248:	20800e17 	ldw	r2,56(r4)
   1424c:	10005726 	beq	r2,zero,143ac <_fflush_r+0x188>
   14250:	8880030b 	ldhu	r2,12(r17)
   14254:	10c0020c 	andi	r3,r2,8
   14258:	18ffffcc 	andi	r3,r3,65535
   1425c:	18e0001c 	xori	r3,r3,32768
   14260:	18e00004 	addi	r3,r3,-32768
   14264:	1800311e 	bne	r3,zero,1432c <_fflush_r+0x108>
   14268:	89000117 	ldw	r4,4(r17)
   1426c:	10c20014 	ori	r3,r2,2048
   14270:	88c0030d 	sth	r3,12(r17)
   14274:	180b883a 	mov	r5,r3
   14278:	0100520e 	bge	zero,r4,143c4 <_fflush_r+0x1a0>
   1427c:	88c00a17 	ldw	r3,40(r17)
   14280:	18002226 	beq	r3,zero,1430c <_fflush_r+0xe8>
   14284:	1084000c 	andi	r2,r2,4096
   14288:	10bfffcc 	andi	r2,r2,65535
   1428c:	10a0001c 	xori	r2,r2,32768
   14290:	10a00004 	addi	r2,r2,-32768
   14294:	10004e26 	beq	r2,zero,143d0 <_fflush_r+0x1ac>
   14298:	8c001417 	ldw	r16,80(r17)
   1429c:	2940010c 	andi	r5,r5,4
   142a0:	297fffcc 	andi	r5,r5,65535
   142a4:	2960001c 	xori	r5,r5,32768
   142a8:	29600004 	addi	r5,r5,-32768
   142ac:	28000626 	beq	r5,zero,142c8 <_fflush_r+0xa4>
   142b0:	89000117 	ldw	r4,4(r17)
   142b4:	88800c17 	ldw	r2,48(r17)
   142b8:	8121c83a 	sub	r16,r16,r4
   142bc:	10000226 	beq	r2,zero,142c8 <_fflush_r+0xa4>
   142c0:	88800f17 	ldw	r2,60(r17)
   142c4:	80a1c83a 	sub	r16,r16,r2
   142c8:	89400717 	ldw	r5,28(r17)
   142cc:	9809883a 	mov	r4,r19
   142d0:	800d883a 	mov	r6,r16
   142d4:	000f883a 	mov	r7,zero
   142d8:	183ee83a 	callr	r3
   142dc:	8080281e 	bne	r16,r2,14380 <_fflush_r+0x15c>
   142e0:	8880030b 	ldhu	r2,12(r17)
   142e4:	88c00417 	ldw	r3,16(r17)
   142e8:	88000115 	stw	zero,4(r17)
   142ec:	113dffcc 	andi	r4,r2,63487
   142f0:	1084000c 	andi	r2,r2,4096
   142f4:	10bfffcc 	andi	r2,r2,65535
   142f8:	10a0001c 	xori	r2,r2,32768
   142fc:	8900030d 	sth	r4,12(r17)
   14300:	88c00015 	stw	r3,0(r17)
   14304:	10a00004 	addi	r2,r2,-32768
   14308:	10002c1e 	bne	r2,zero,143bc <_fflush_r+0x198>
   1430c:	0005883a 	mov	r2,zero
   14310:	dfc00417 	ldw	ra,16(sp)
   14314:	dcc00317 	ldw	r19,12(sp)
   14318:	dc800217 	ldw	r18,8(sp)
   1431c:	dc400117 	ldw	r17,4(sp)
   14320:	dc000017 	ldw	r16,0(sp)
   14324:	dec00504 	addi	sp,sp,20
   14328:	f800283a 	ret
   1432c:	8c800417 	ldw	r18,16(r17)
   14330:	903ff626 	beq	r18,zero,1430c <_fflush_r+0xe8>
   14334:	8c000017 	ldw	r16,0(r17)
   14338:	108000cc 	andi	r2,r2,3
   1433c:	8c800015 	stw	r18,0(r17)
   14340:	84a1c83a 	sub	r16,r16,r18
   14344:	10001b1e 	bne	r2,zero,143b4 <_fflush_r+0x190>
   14348:	88800517 	ldw	r2,20(r17)
   1434c:	88800215 	stw	r2,8(r17)
   14350:	04000316 	blt	zero,r16,14360 <_fflush_r+0x13c>
   14354:	003fed06 	br	1430c <_fflush_r+0xe8>
   14358:	90a5883a 	add	r18,r18,r2
   1435c:	043feb0e 	bge	zero,r16,1430c <_fflush_r+0xe8>
   14360:	88800917 	ldw	r2,36(r17)
   14364:	89400717 	ldw	r5,28(r17)
   14368:	800f883a 	mov	r7,r16
   1436c:	900d883a 	mov	r6,r18
   14370:	9809883a 	mov	r4,r19
   14374:	103ee83a 	callr	r2
   14378:	80a1c83a 	sub	r16,r16,r2
   1437c:	00bff616 	blt	zero,r2,14358 <_fflush_r+0x134>
   14380:	88c0030b 	ldhu	r3,12(r17)
   14384:	00bfffc4 	movi	r2,-1
   14388:	18c01014 	ori	r3,r3,64
   1438c:	88c0030d 	sth	r3,12(r17)
   14390:	dfc00417 	ldw	ra,16(sp)
   14394:	dcc00317 	ldw	r19,12(sp)
   14398:	dc800217 	ldw	r18,8(sp)
   1439c:	dc400117 	ldw	r17,4(sp)
   143a0:	dc000017 	ldw	r16,0(sp)
   143a4:	dec00504 	addi	sp,sp,20
   143a8:	f800283a 	ret
   143ac:	00144cc0 	call	144cc <__sinit>
   143b0:	003fa706 	br	14250 <_fflush_r+0x2c>
   143b4:	0005883a 	mov	r2,zero
   143b8:	003fe406 	br	1434c <_fflush_r+0x128>
   143bc:	8c001415 	stw	r16,80(r17)
   143c0:	003fd206 	br	1430c <_fflush_r+0xe8>
   143c4:	88c00f17 	ldw	r3,60(r17)
   143c8:	00ffac16 	blt	zero,r3,1427c <_fflush_r+0x58>
   143cc:	003fcf06 	br	1430c <_fflush_r+0xe8>
   143d0:	89400717 	ldw	r5,28(r17)
   143d4:	9809883a 	mov	r4,r19
   143d8:	000d883a 	mov	r6,zero
   143dc:	01c00044 	movi	r7,1
   143e0:	183ee83a 	callr	r3
   143e4:	1021883a 	mov	r16,r2
   143e8:	00bfffc4 	movi	r2,-1
   143ec:	80800326 	beq	r16,r2,143fc <_fflush_r+0x1d8>
   143f0:	8940030b 	ldhu	r5,12(r17)
   143f4:	88c00a17 	ldw	r3,40(r17)
   143f8:	003fa806 	br	1429c <_fflush_r+0x78>
   143fc:	98c00017 	ldw	r3,0(r19)
   14400:	00800744 	movi	r2,29
   14404:	18bfde1e 	bne	r3,r2,14380 <_fflush_r+0x15c>
   14408:	003fc006 	br	1430c <_fflush_r+0xe8>

0001440c <fflush>:
   1440c:	200b883a 	mov	r5,r4
   14410:	20000426 	beq	r4,zero,14424 <fflush+0x18>
   14414:	008000f4 	movhi	r2,3
   14418:	10a60a04 	addi	r2,r2,-26584
   1441c:	11000017 	ldw	r4,0(r2)
   14420:	00142241 	jmpi	14224 <_fflush_r>
   14424:	008000f4 	movhi	r2,3
   14428:	10a60904 	addi	r2,r2,-26588
   1442c:	11000017 	ldw	r4,0(r2)
   14430:	01400074 	movhi	r5,1
   14434:	29508904 	addi	r5,r5,16932
   14438:	00150ac1 	jmpi	150ac <_fwalk_reent>

0001443c <__fp_lock>:
   1443c:	0005883a 	mov	r2,zero
   14440:	f800283a 	ret

00014444 <__fp_unlock>:
   14444:	0005883a 	mov	r2,zero
   14448:	f800283a 	ret

0001444c <_cleanup_r>:
   1444c:	01400074 	movhi	r5,1
   14450:	295e0004 	addi	r5,r5,30720
   14454:	00150041 	jmpi	15004 <_fwalk>

00014458 <__sfmoreglue>:
   14458:	defffc04 	addi	sp,sp,-16
   1445c:	dc400115 	stw	r17,4(sp)
   14460:	2c401724 	muli	r17,r5,92
   14464:	dc800215 	stw	r18,8(sp)
   14468:	2825883a 	mov	r18,r5
   1446c:	89400304 	addi	r5,r17,12
   14470:	dc000015 	stw	r16,0(sp)
   14474:	dfc00315 	stw	ra,12(sp)
   14478:	00153e80 	call	153e8 <_malloc_r>
   1447c:	1021883a 	mov	r16,r2
   14480:	10000726 	beq	r2,zero,144a0 <__sfmoreglue+0x48>
   14484:	11000304 	addi	r4,r2,12
   14488:	10000015 	stw	zero,0(r2)
   1448c:	14800115 	stw	r18,4(r2)
   14490:	11000215 	stw	r4,8(r2)
   14494:	000b883a 	mov	r5,zero
   14498:	880d883a 	mov	r6,r17
   1449c:	00103300 	call	10330 <memset>
   144a0:	8005883a 	mov	r2,r16
   144a4:	dfc00317 	ldw	ra,12(sp)
   144a8:	dc800217 	ldw	r18,8(sp)
   144ac:	dc400117 	ldw	r17,4(sp)
   144b0:	dc000017 	ldw	r16,0(sp)
   144b4:	dec00404 	addi	sp,sp,16
   144b8:	f800283a 	ret

000144bc <_cleanup>:
   144bc:	008000f4 	movhi	r2,3
   144c0:	10a60904 	addi	r2,r2,-26588
   144c4:	11000017 	ldw	r4,0(r2)
   144c8:	001444c1 	jmpi	1444c <_cleanup_r>

000144cc <__sinit>:
   144cc:	20800e17 	ldw	r2,56(r4)
   144d0:	1000401e 	bne	r2,zero,145d4 <__sinit+0x108>
   144d4:	21400117 	ldw	r5,4(r4)
   144d8:	01800074 	movhi	r6,1
   144dc:	31911304 	addi	r6,r6,17484
   144e0:	20c00217 	ldw	r3,8(r4)
   144e4:	21800f15 	stw	r6,60(r4)
   144e8:	2080bb04 	addi	r2,r4,748
   144ec:	02400044 	movi	r9,1
   144f0:	018000c4 	movi	r6,3
   144f4:	2180b915 	stw	r6,740(r4)
   144f8:	2080ba15 	stw	r2,744(r4)
   144fc:	22400e15 	stw	r9,56(r4)
   14500:	20800317 	ldw	r2,12(r4)
   14504:	2000b815 	stw	zero,736(r4)
   14508:	02000074 	movhi	r8,1
   1450c:	421cfe04 	addi	r8,r8,29688
   14510:	01c00074 	movhi	r7,1
   14514:	39dd1304 	addi	r7,r7,29772
   14518:	01800074 	movhi	r6,1
   1451c:	319d3504 	addi	r6,r6,29908
   14520:	01000074 	movhi	r4,1
   14524:	211d4c04 	addi	r4,r4,30000
   14528:	02800104 	movi	r10,4
   1452c:	28000015 	stw	zero,0(r5)
   14530:	28000115 	stw	zero,4(r5)
   14534:	28000215 	stw	zero,8(r5)
   14538:	2a80030d 	sth	r10,12(r5)
   1453c:	2800038d 	sth	zero,14(r5)
   14540:	28000415 	stw	zero,16(r5)
   14544:	28000515 	stw	zero,20(r5)
   14548:	28000615 	stw	zero,24(r5)
   1454c:	29400715 	stw	r5,28(r5)
   14550:	2a000815 	stw	r8,32(r5)
   14554:	29c00915 	stw	r7,36(r5)
   14558:	29800a15 	stw	r6,40(r5)
   1455c:	29000b15 	stw	r4,44(r5)
   14560:	01400284 	movi	r5,10
   14564:	18000015 	stw	zero,0(r3)
   14568:	18000115 	stw	zero,4(r3)
   1456c:	18000215 	stw	zero,8(r3)
   14570:	1940030d 	sth	r5,12(r3)
   14574:	1a40038d 	sth	r9,14(r3)
   14578:	18000415 	stw	zero,16(r3)
   1457c:	18000515 	stw	zero,20(r3)
   14580:	18000615 	stw	zero,24(r3)
   14584:	18c00715 	stw	r3,28(r3)
   14588:	1a000815 	stw	r8,32(r3)
   1458c:	19c00915 	stw	r7,36(r3)
   14590:	19800a15 	stw	r6,40(r3)
   14594:	19000b15 	stw	r4,44(r3)
   14598:	00c00484 	movi	r3,18
   1459c:	10c0030d 	sth	r3,12(r2)
   145a0:	00c00084 	movi	r3,2
   145a4:	10000015 	stw	zero,0(r2)
   145a8:	10000115 	stw	zero,4(r2)
   145ac:	10000215 	stw	zero,8(r2)
   145b0:	10c0038d 	sth	r3,14(r2)
   145b4:	10000415 	stw	zero,16(r2)
   145b8:	10000515 	stw	zero,20(r2)
   145bc:	10000615 	stw	zero,24(r2)
   145c0:	10800715 	stw	r2,28(r2)
   145c4:	12000815 	stw	r8,32(r2)
   145c8:	11c00915 	stw	r7,36(r2)
   145cc:	11800a15 	stw	r6,40(r2)
   145d0:	11000b15 	stw	r4,44(r2)
   145d4:	f800283a 	ret

000145d8 <__sfp>:
   145d8:	defffc04 	addi	sp,sp,-16
   145dc:	008000f4 	movhi	r2,3
   145e0:	10a60904 	addi	r2,r2,-26588
   145e4:	dc400115 	stw	r17,4(sp)
   145e8:	14400017 	ldw	r17,0(r2)
   145ec:	dc800215 	stw	r18,8(sp)
   145f0:	dfc00315 	stw	ra,12(sp)
   145f4:	88800e17 	ldw	r2,56(r17)
   145f8:	dc000015 	stw	r16,0(sp)
   145fc:	2025883a 	mov	r18,r4
   14600:	10002826 	beq	r2,zero,146a4 <__sfp+0xcc>
   14604:	8c40b804 	addi	r17,r17,736
   14608:	043fffc4 	movi	r16,-1
   1460c:	89400117 	ldw	r5,4(r17)
   14610:	88800217 	ldw	r2,8(r17)
   14614:	297fffc4 	addi	r5,r5,-1
   14618:	28000a16 	blt	r5,zero,14644 <__sfp+0x6c>
   1461c:	10c0030f 	ldh	r3,12(r2)
   14620:	18000c26 	beq	r3,zero,14654 <__sfp+0x7c>
   14624:	10c01a04 	addi	r3,r2,104
   14628:	00000206 	br	14634 <__sfp+0x5c>
   1462c:	19bfe90f 	ldh	r6,-92(r3)
   14630:	30000826 	beq	r6,zero,14654 <__sfp+0x7c>
   14634:	297fffc4 	addi	r5,r5,-1
   14638:	18bffd04 	addi	r2,r3,-12
   1463c:	18c01704 	addi	r3,r3,92
   14640:	2c3ffa1e 	bne	r5,r16,1462c <__sfp+0x54>
   14644:	88800017 	ldw	r2,0(r17)
   14648:	10001926 	beq	r2,zero,146b0 <__sfp+0xd8>
   1464c:	1023883a 	mov	r17,r2
   14650:	003fee06 	br	1460c <__sfp+0x34>
   14654:	00ffffc4 	movi	r3,-1
   14658:	10c0038d 	sth	r3,14(r2)
   1465c:	00c00044 	movi	r3,1
   14660:	10c0030d 	sth	r3,12(r2)
   14664:	10000015 	stw	zero,0(r2)
   14668:	10000215 	stw	zero,8(r2)
   1466c:	10000115 	stw	zero,4(r2)
   14670:	10000415 	stw	zero,16(r2)
   14674:	10000515 	stw	zero,20(r2)
   14678:	10000615 	stw	zero,24(r2)
   1467c:	10000c15 	stw	zero,48(r2)
   14680:	10000d15 	stw	zero,52(r2)
   14684:	10001115 	stw	zero,68(r2)
   14688:	10001215 	stw	zero,72(r2)
   1468c:	dfc00317 	ldw	ra,12(sp)
   14690:	dc800217 	ldw	r18,8(sp)
   14694:	dc400117 	ldw	r17,4(sp)
   14698:	dc000017 	ldw	r16,0(sp)
   1469c:	dec00404 	addi	sp,sp,16
   146a0:	f800283a 	ret
   146a4:	8809883a 	mov	r4,r17
   146a8:	00144cc0 	call	144cc <__sinit>
   146ac:	003fd506 	br	14604 <__sfp+0x2c>
   146b0:	9009883a 	mov	r4,r18
   146b4:	01400104 	movi	r5,4
   146b8:	00144580 	call	14458 <__sfmoreglue>
   146bc:	88800015 	stw	r2,0(r17)
   146c0:	103fe21e 	bne	r2,zero,1464c <__sfp+0x74>
   146c4:	00800304 	movi	r2,12
   146c8:	90800015 	stw	r2,0(r18)
   146cc:	0005883a 	mov	r2,zero
   146d0:	003fee06 	br	1468c <__sfp+0xb4>

000146d4 <__sfp_lock_acquire>:
   146d4:	f800283a 	ret

000146d8 <__sfp_lock_release>:
   146d8:	f800283a 	ret

000146dc <__sinit_lock_acquire>:
   146dc:	f800283a 	ret

000146e0 <__sinit_lock_release>:
   146e0:	f800283a 	ret

000146e4 <__fp_lock_all>:
   146e4:	008000f4 	movhi	r2,3
   146e8:	10a60a04 	addi	r2,r2,-26584
   146ec:	11000017 	ldw	r4,0(r2)
   146f0:	01400074 	movhi	r5,1
   146f4:	29510f04 	addi	r5,r5,17468
   146f8:	00150041 	jmpi	15004 <_fwalk>

000146fc <__fp_unlock_all>:
   146fc:	008000f4 	movhi	r2,3
   14700:	10a60a04 	addi	r2,r2,-26584
   14704:	11000017 	ldw	r4,0(r2)
   14708:	01400074 	movhi	r5,1
   1470c:	29511104 	addi	r5,r5,17476
   14710:	00150041 	jmpi	15004 <_fwalk>

00014714 <_malloc_trim_r>:
   14714:	defffb04 	addi	sp,sp,-20
   14718:	dcc00315 	stw	r19,12(sp)
   1471c:	dc800215 	stw	r18,8(sp)
   14720:	dc400115 	stw	r17,4(sp)
   14724:	dc000015 	stw	r16,0(sp)
   14728:	2827883a 	mov	r19,r5
   1472c:	dfc00415 	stw	ra,16(sp)
   14730:	044000b4 	movhi	r17,2
   14734:	8c5f2904 	addi	r17,r17,31908
   14738:	2021883a 	mov	r16,r4
   1473c:	0018fa80 	call	18fa8 <__malloc_lock>
   14740:	88800217 	ldw	r2,8(r17)
   14744:	14800117 	ldw	r18,4(r2)
   14748:	00bfff04 	movi	r2,-4
   1474c:	90a4703a 	and	r18,r18,r2
   14750:	9083fbc4 	addi	r2,r18,4079
   14754:	14e7c83a 	sub	r19,r2,r19
   14758:	9826d33a 	srli	r19,r19,12
   1475c:	0083ffc4 	movi	r2,4095
   14760:	9cffffc4 	addi	r19,r19,-1
   14764:	9826933a 	slli	r19,r19,12
   14768:	14c0060e 	bge	r2,r19,14784 <_malloc_trim_r+0x70>
   1476c:	8009883a 	mov	r4,r16
   14770:	000b883a 	mov	r5,zero
   14774:	00173940 	call	17394 <_sbrk_r>
   14778:	88c00217 	ldw	r3,8(r17)
   1477c:	1c87883a 	add	r3,r3,r18
   14780:	10c00a26 	beq	r2,r3,147ac <_malloc_trim_r+0x98>
   14784:	8009883a 	mov	r4,r16
   14788:	0018fc80 	call	18fc8 <__malloc_unlock>
   1478c:	0005883a 	mov	r2,zero
   14790:	dfc00417 	ldw	ra,16(sp)
   14794:	dcc00317 	ldw	r19,12(sp)
   14798:	dc800217 	ldw	r18,8(sp)
   1479c:	dc400117 	ldw	r17,4(sp)
   147a0:	dc000017 	ldw	r16,0(sp)
   147a4:	dec00504 	addi	sp,sp,20
   147a8:	f800283a 	ret
   147ac:	8009883a 	mov	r4,r16
   147b0:	04cbc83a 	sub	r5,zero,r19
   147b4:	00173940 	call	17394 <_sbrk_r>
   147b8:	00ffffc4 	movi	r3,-1
   147bc:	10c01326 	beq	r2,r3,1480c <_malloc_trim_r+0xf8>
   147c0:	00800134 	movhi	r2,4
   147c4:	10a7fc04 	addi	r2,r2,-24592
   147c8:	11000017 	ldw	r4,0(r2)
   147cc:	88c00217 	ldw	r3,8(r17)
   147d0:	94e5c83a 	sub	r18,r18,r19
   147d4:	94800054 	ori	r18,r18,1
   147d8:	24e7c83a 	sub	r19,r4,r19
   147dc:	1c800115 	stw	r18,4(r3)
   147e0:	8009883a 	mov	r4,r16
   147e4:	14c00015 	stw	r19,0(r2)
   147e8:	0018fc80 	call	18fc8 <__malloc_unlock>
   147ec:	00800044 	movi	r2,1
   147f0:	dfc00417 	ldw	ra,16(sp)
   147f4:	dcc00317 	ldw	r19,12(sp)
   147f8:	dc800217 	ldw	r18,8(sp)
   147fc:	dc400117 	ldw	r17,4(sp)
   14800:	dc000017 	ldw	r16,0(sp)
   14804:	dec00504 	addi	sp,sp,20
   14808:	f800283a 	ret
   1480c:	8009883a 	mov	r4,r16
   14810:	000b883a 	mov	r5,zero
   14814:	00173940 	call	17394 <_sbrk_r>
   14818:	88c00217 	ldw	r3,8(r17)
   1481c:	014003c4 	movi	r5,15
   14820:	10c9c83a 	sub	r4,r2,r3
   14824:	293fd70e 	bge	r5,r4,14784 <_malloc_trim_r+0x70>
   14828:	014000f4 	movhi	r5,3
   1482c:	29660c04 	addi	r5,r5,-26576
   14830:	29400017 	ldw	r5,0(r5)
   14834:	21000054 	ori	r4,r4,1
   14838:	19000115 	stw	r4,4(r3)
   1483c:	1145c83a 	sub	r2,r2,r5
   14840:	01400134 	movhi	r5,4
   14844:	2967fc04 	addi	r5,r5,-24592
   14848:	28800015 	stw	r2,0(r5)
   1484c:	003fcd06 	br	14784 <_malloc_trim_r+0x70>

00014850 <_free_r>:
   14850:	defffd04 	addi	sp,sp,-12
   14854:	dc400115 	stw	r17,4(sp)
   14858:	dc000015 	stw	r16,0(sp)
   1485c:	dfc00215 	stw	ra,8(sp)
   14860:	2821883a 	mov	r16,r5
   14864:	2023883a 	mov	r17,r4
   14868:	28004b26 	beq	r5,zero,14998 <_free_r+0x148>
   1486c:	0018fa80 	call	18fa8 <__malloc_lock>
   14870:	823fff17 	ldw	r8,-4(r16)
   14874:	00bfff84 	movi	r2,-2
   14878:	81bffe04 	addi	r6,r16,-8
   1487c:	4084703a 	and	r2,r8,r2
   14880:	3087883a 	add	r3,r6,r2
   14884:	014000b4 	movhi	r5,2
   14888:	295f2904 	addi	r5,r5,31908
   1488c:	1a400117 	ldw	r9,4(r3)
   14890:	29000217 	ldw	r4,8(r5)
   14894:	01ffff04 	movi	r7,-4
   14898:	49ce703a 	and	r7,r9,r7
   1489c:	20c06526 	beq	r4,r3,14a34 <_free_r+0x1e4>
   148a0:	19c00115 	stw	r7,4(r3)
   148a4:	4200004c 	andi	r8,r8,1
   148a8:	40003026 	beq	r8,zero,1496c <_free_r+0x11c>
   148ac:	0009883a 	mov	r4,zero
   148b0:	19d1883a 	add	r8,r3,r7
   148b4:	42000117 	ldw	r8,4(r8)
   148b8:	4200004c 	andi	r8,r8,1
   148bc:	4000061e 	bne	r8,zero,148d8 <_free_r+0x88>
   148c0:	11c5883a 	add	r2,r2,r7
   148c4:	19c00217 	ldw	r7,8(r3)
   148c8:	20004e26 	beq	r4,zero,14a04 <_free_r+0x1b4>
   148cc:	18c00317 	ldw	r3,12(r3)
   148d0:	38c00315 	stw	r3,12(r7)
   148d4:	19c00215 	stw	r7,8(r3)
   148d8:	11c00054 	ori	r7,r2,1
   148dc:	3087883a 	add	r3,r6,r2
   148e0:	31c00115 	stw	r7,4(r6)
   148e4:	18800015 	stw	r2,0(r3)
   148e8:	20001a1e 	bne	r4,zero,14954 <_free_r+0x104>
   148ec:	00c07fc4 	movi	r3,511
   148f0:	18802e2e 	bgeu	r3,r2,149ac <_free_r+0x15c>
   148f4:	1006d27a 	srli	r3,r2,9
   148f8:	01000104 	movi	r4,4
   148fc:	20c06636 	bltu	r4,r3,14a98 <_free_r+0x248>
   14900:	1008d1ba 	srli	r4,r2,6
   14904:	21000e04 	addi	r4,r4,56
   14908:	210f883a 	add	r7,r4,r4
   1490c:	39cf883a 	add	r7,r7,r7
   14910:	39cf883a 	add	r7,r7,r7
   14914:	29cf883a 	add	r7,r5,r7
   14918:	38c00217 	ldw	r3,8(r7)
   1491c:	014000b4 	movhi	r5,2
   14920:	295f2904 	addi	r5,r5,31908
   14924:	19c06126 	beq	r3,r7,14aac <_free_r+0x25c>
   14928:	013fff04 	movi	r4,-4
   1492c:	19400117 	ldw	r5,4(r3)
   14930:	290a703a 	and	r5,r5,r4
   14934:	1140022e 	bgeu	r2,r5,14940 <_free_r+0xf0>
   14938:	18c00217 	ldw	r3,8(r3)
   1493c:	38fffb1e 	bne	r7,r3,1492c <_free_r+0xdc>
   14940:	18800317 	ldw	r2,12(r3)
   14944:	30800315 	stw	r2,12(r6)
   14948:	30c00215 	stw	r3,8(r6)
   1494c:	11800215 	stw	r6,8(r2)
   14950:	19800315 	stw	r6,12(r3)
   14954:	8809883a 	mov	r4,r17
   14958:	dfc00217 	ldw	ra,8(sp)
   1495c:	dc400117 	ldw	r17,4(sp)
   14960:	dc000017 	ldw	r16,0(sp)
   14964:	dec00304 	addi	sp,sp,12
   14968:	0018fc81 	jmpi	18fc8 <__malloc_unlock>
   1496c:	813ffe17 	ldw	r4,-8(r16)
   14970:	2a400204 	addi	r9,r5,8
   14974:	310dc83a 	sub	r6,r6,r4
   14978:	32000217 	ldw	r8,8(r6)
   1497c:	1105883a 	add	r2,r2,r4
   14980:	42404326 	beq	r8,r9,14a90 <_free_r+0x240>
   14984:	32400317 	ldw	r9,12(r6)
   14988:	0009883a 	mov	r4,zero
   1498c:	42400315 	stw	r9,12(r8)
   14990:	4a000215 	stw	r8,8(r9)
   14994:	003fc606 	br	148b0 <_free_r+0x60>
   14998:	dfc00217 	ldw	ra,8(sp)
   1499c:	dc400117 	ldw	r17,4(sp)
   149a0:	dc000017 	ldw	r16,0(sp)
   149a4:	dec00304 	addi	sp,sp,12
   149a8:	f800283a 	ret
   149ac:	1004d0fa 	srli	r2,r2,3
   149b0:	02000044 	movi	r8,1
   149b4:	29c00117 	ldw	r7,4(r5)
   149b8:	1087883a 	add	r3,r2,r2
   149bc:	18c7883a 	add	r3,r3,r3
   149c0:	1005d0ba 	srai	r2,r2,2
   149c4:	18c7883a 	add	r3,r3,r3
   149c8:	28c7883a 	add	r3,r5,r3
   149cc:	19000217 	ldw	r4,8(r3)
   149d0:	4084983a 	sll	r2,r8,r2
   149d4:	30c00315 	stw	r3,12(r6)
   149d8:	31000215 	stw	r4,8(r6)
   149dc:	11c4b03a 	or	r2,r2,r7
   149e0:	21800315 	stw	r6,12(r4)
   149e4:	8809883a 	mov	r4,r17
   149e8:	28800115 	stw	r2,4(r5)
   149ec:	19800215 	stw	r6,8(r3)
   149f0:	dfc00217 	ldw	ra,8(sp)
   149f4:	dc400117 	ldw	r17,4(sp)
   149f8:	dc000017 	ldw	r16,0(sp)
   149fc:	dec00304 	addi	sp,sp,12
   14a00:	0018fc81 	jmpi	18fc8 <__malloc_unlock>
   14a04:	020000b4 	movhi	r8,2
   14a08:	421f2b04 	addi	r8,r8,31916
   14a0c:	3a3faf1e 	bne	r7,r8,148cc <_free_r+0x7c>
   14a10:	29800515 	stw	r6,20(r5)
   14a14:	29800415 	stw	r6,16(r5)
   14a18:	11000054 	ori	r4,r2,1
   14a1c:	3087883a 	add	r3,r6,r2
   14a20:	31c00315 	stw	r7,12(r6)
   14a24:	31c00215 	stw	r7,8(r6)
   14a28:	31000115 	stw	r4,4(r6)
   14a2c:	18800015 	stw	r2,0(r3)
   14a30:	003fc806 	br	14954 <_free_r+0x104>
   14a34:	4200004c 	andi	r8,r8,1
   14a38:	3885883a 	add	r2,r7,r2
   14a3c:	4000071e 	bne	r8,zero,14a5c <_free_r+0x20c>
   14a40:	81fffe17 	ldw	r7,-8(r16)
   14a44:	31cdc83a 	sub	r6,r6,r7
   14a48:	30c00317 	ldw	r3,12(r6)
   14a4c:	31000217 	ldw	r4,8(r6)
   14a50:	11c5883a 	add	r2,r2,r7
   14a54:	20c00315 	stw	r3,12(r4)
   14a58:	19000215 	stw	r4,8(r3)
   14a5c:	00c000f4 	movhi	r3,3
   14a60:	18e60d04 	addi	r3,r3,-26572
   14a64:	18c00017 	ldw	r3,0(r3)
   14a68:	11000054 	ori	r4,r2,1
   14a6c:	31000115 	stw	r4,4(r6)
   14a70:	29800215 	stw	r6,8(r5)
   14a74:	10ffb736 	bltu	r2,r3,14954 <_free_r+0x104>
   14a78:	008000f4 	movhi	r2,3
   14a7c:	10aed304 	addi	r2,r2,-17588
   14a80:	11400017 	ldw	r5,0(r2)
   14a84:	8809883a 	mov	r4,r17
   14a88:	00147140 	call	14714 <_malloc_trim_r>
   14a8c:	003fb106 	br	14954 <_free_r+0x104>
   14a90:	01000044 	movi	r4,1
   14a94:	003f8606 	br	148b0 <_free_r+0x60>
   14a98:	01000504 	movi	r4,20
   14a9c:	20c00b36 	bltu	r4,r3,14acc <_free_r+0x27c>
   14aa0:	190016c4 	addi	r4,r3,91
   14aa4:	210f883a 	add	r7,r4,r4
   14aa8:	003f9806 	br	1490c <_free_r+0xbc>
   14aac:	2009d0ba 	srai	r4,r4,2
   14ab0:	00800044 	movi	r2,1
   14ab4:	29c00117 	ldw	r7,4(r5)
   14ab8:	1108983a 	sll	r4,r2,r4
   14abc:	1805883a 	mov	r2,r3
   14ac0:	21c8b03a 	or	r4,r4,r7
   14ac4:	29000115 	stw	r4,4(r5)
   14ac8:	003f9e06 	br	14944 <_free_r+0xf4>
   14acc:	01001504 	movi	r4,84
   14ad0:	20c00436 	bltu	r4,r3,14ae4 <_free_r+0x294>
   14ad4:	1008d33a 	srli	r4,r2,12
   14ad8:	21001b84 	addi	r4,r4,110
   14adc:	210f883a 	add	r7,r4,r4
   14ae0:	003f8a06 	br	1490c <_free_r+0xbc>
   14ae4:	01005504 	movi	r4,340
   14ae8:	20c00436 	bltu	r4,r3,14afc <_free_r+0x2ac>
   14aec:	1008d3fa 	srli	r4,r2,15
   14af0:	21001dc4 	addi	r4,r4,119
   14af4:	210f883a 	add	r7,r4,r4
   14af8:	003f8406 	br	1490c <_free_r+0xbc>
   14afc:	01015504 	movi	r4,1364
   14b00:	20c00436 	bltu	r4,r3,14b14 <_free_r+0x2c4>
   14b04:	1008d4ba 	srli	r4,r2,18
   14b08:	21001f04 	addi	r4,r4,124
   14b0c:	210f883a 	add	r7,r4,r4
   14b10:	003f7e06 	br	1490c <_free_r+0xbc>
   14b14:	01c03f04 	movi	r7,252
   14b18:	01001f84 	movi	r4,126
   14b1c:	003f7b06 	br	1490c <_free_r+0xbc>

00014b20 <__sfvwrite_r>:
   14b20:	30800217 	ldw	r2,8(r6)
   14b24:	defff504 	addi	sp,sp,-44
   14b28:	dd400615 	stw	r21,24(sp)
   14b2c:	dd000515 	stw	r20,20(sp)
   14b30:	dc000115 	stw	r16,4(sp)
   14b34:	dfc00a15 	stw	ra,40(sp)
   14b38:	df000915 	stw	fp,36(sp)
   14b3c:	ddc00815 	stw	r23,32(sp)
   14b40:	dd800715 	stw	r22,28(sp)
   14b44:	dcc00415 	stw	r19,16(sp)
   14b48:	dc800315 	stw	r18,12(sp)
   14b4c:	dc400215 	stw	r17,8(sp)
   14b50:	3029883a 	mov	r20,r6
   14b54:	202b883a 	mov	r21,r4
   14b58:	2821883a 	mov	r16,r5
   14b5c:	10002126 	beq	r2,zero,14be4 <__sfvwrite_r+0xc4>
   14b60:	2880030b 	ldhu	r2,12(r5)
   14b64:	10c0020c 	andi	r3,r2,8
   14b68:	18ffffcc 	andi	r3,r3,65535
   14b6c:	18e0001c 	xori	r3,r3,32768
   14b70:	18e00004 	addi	r3,r3,-32768
   14b74:	18002826 	beq	r3,zero,14c18 <__sfvwrite_r+0xf8>
   14b78:	28c00417 	ldw	r3,16(r5)
   14b7c:	18002626 	beq	r3,zero,14c18 <__sfvwrite_r+0xf8>
   14b80:	10c0008c 	andi	r3,r2,2
   14b84:	18ffffcc 	andi	r3,r3,65535
   14b88:	18e0001c 	xori	r3,r3,32768
   14b8c:	18e00004 	addi	r3,r3,-32768
   14b90:	a4400017 	ldw	r17,0(r20)
   14b94:	18002b26 	beq	r3,zero,14c44 <__sfvwrite_r+0x124>
   14b98:	0027883a 	mov	r19,zero
   14b9c:	0025883a 	mov	r18,zero
   14ba0:	05810004 	movi	r22,1024
   14ba4:	980d883a 	mov	r6,r19
   14ba8:	a809883a 	mov	r4,r21
   14bac:	90004f26 	beq	r18,zero,14cec <__sfvwrite_r+0x1cc>
   14bb0:	900f883a 	mov	r7,r18
   14bb4:	81400717 	ldw	r5,28(r16)
   14bb8:	b480012e 	bgeu	r22,r18,14bc0 <__sfvwrite_r+0xa0>
   14bbc:	01c10004 	movi	r7,1024
   14bc0:	80800917 	ldw	r2,36(r16)
   14bc4:	103ee83a 	callr	r2
   14bc8:	0080540e 	bge	zero,r2,14d1c <__sfvwrite_r+0x1fc>
   14bcc:	a0c00217 	ldw	r3,8(r20)
   14bd0:	98a7883a 	add	r19,r19,r2
   14bd4:	90a5c83a 	sub	r18,r18,r2
   14bd8:	1885c83a 	sub	r2,r3,r2
   14bdc:	a0800215 	stw	r2,8(r20)
   14be0:	103ff01e 	bne	r2,zero,14ba4 <__sfvwrite_r+0x84>
   14be4:	0005883a 	mov	r2,zero
   14be8:	dfc00a17 	ldw	ra,40(sp)
   14bec:	df000917 	ldw	fp,36(sp)
   14bf0:	ddc00817 	ldw	r23,32(sp)
   14bf4:	dd800717 	ldw	r22,28(sp)
   14bf8:	dd400617 	ldw	r21,24(sp)
   14bfc:	dd000517 	ldw	r20,20(sp)
   14c00:	dcc00417 	ldw	r19,16(sp)
   14c04:	dc800317 	ldw	r18,12(sp)
   14c08:	dc400217 	ldw	r17,8(sp)
   14c0c:	dc000117 	ldw	r16,4(sp)
   14c10:	dec00b04 	addi	sp,sp,44
   14c14:	f800283a 	ret
   14c18:	a809883a 	mov	r4,r21
   14c1c:	800b883a 	mov	r5,r16
   14c20:	001288c0 	call	1288c <__swsetup_r>
   14c24:	1000f01e 	bne	r2,zero,14fe8 <__sfvwrite_r+0x4c8>
   14c28:	8080030b 	ldhu	r2,12(r16)
   14c2c:	a4400017 	ldw	r17,0(r20)
   14c30:	10c0008c 	andi	r3,r2,2
   14c34:	18ffffcc 	andi	r3,r3,65535
   14c38:	18e0001c 	xori	r3,r3,32768
   14c3c:	18e00004 	addi	r3,r3,-32768
   14c40:	183fd51e 	bne	r3,zero,14b98 <__sfvwrite_r+0x78>
   14c44:	10c0004c 	andi	r3,r2,1
   14c48:	002d883a 	mov	r22,zero
   14c4c:	1800381e 	bne	r3,zero,14d30 <__sfvwrite_r+0x210>
   14c50:	0025883a 	mov	r18,zero
   14c54:	90002126 	beq	r18,zero,14cdc <__sfvwrite_r+0x1bc>
   14c58:	10c0800c 	andi	r3,r2,512
   14c5c:	18ffffcc 	andi	r3,r3,65535
   14c60:	18e0001c 	xori	r3,r3,32768
   14c64:	18e00004 	addi	r3,r3,-32768
   14c68:	84c00217 	ldw	r19,8(r16)
   14c6c:	18006b26 	beq	r3,zero,14e1c <__sfvwrite_r+0x2fc>
   14c70:	980f883a 	mov	r7,r19
   14c74:	94c08636 	bltu	r18,r19,14e90 <__sfvwrite_r+0x370>
   14c78:	10c1200c 	andi	r3,r2,1152
   14c7c:	18009f1e 	bne	r3,zero,14efc <__sfvwrite_r+0x3dc>
   14c80:	81000017 	ldw	r4,0(r16)
   14c84:	982f883a 	mov	r23,r19
   14c88:	9039883a 	mov	fp,r18
   14c8c:	9027883a 	mov	r19,r18
   14c90:	380d883a 	mov	r6,r7
   14c94:	b00b883a 	mov	r5,r22
   14c98:	d9c00015 	stw	r7,0(sp)
   14c9c:	0015c640 	call	15c64 <memmove>
   14ca0:	d9c00017 	ldw	r7,0(sp)
   14ca4:	81000217 	ldw	r4,8(r16)
   14ca8:	80800017 	ldw	r2,0(r16)
   14cac:	25efc83a 	sub	r23,r4,r23
   14cb0:	11cf883a 	add	r7,r2,r7
   14cb4:	85c00215 	stw	r23,8(r16)
   14cb8:	81c00015 	stw	r7,0(r16)
   14cbc:	a0800217 	ldw	r2,8(r20)
   14cc0:	b72d883a 	add	r22,r22,fp
   14cc4:	9725c83a 	sub	r18,r18,fp
   14cc8:	14e7c83a 	sub	r19,r2,r19
   14ccc:	a4c00215 	stw	r19,8(r20)
   14cd0:	983fc426 	beq	r19,zero,14be4 <__sfvwrite_r+0xc4>
   14cd4:	8080030b 	ldhu	r2,12(r16)
   14cd8:	903fdf1e 	bne	r18,zero,14c58 <__sfvwrite_r+0x138>
   14cdc:	8d800017 	ldw	r22,0(r17)
   14ce0:	8c800117 	ldw	r18,4(r17)
   14ce4:	8c400204 	addi	r17,r17,8
   14ce8:	003fda06 	br	14c54 <__sfvwrite_r+0x134>
   14cec:	8cc00017 	ldw	r19,0(r17)
   14cf0:	8c800117 	ldw	r18,4(r17)
   14cf4:	8c400204 	addi	r17,r17,8
   14cf8:	003faa06 	br	14ba4 <__sfvwrite_r+0x84>
   14cfc:	0016d340 	call	16d34 <_realloc_r>
   14d00:	102f883a 	mov	r23,r2
   14d04:	10009f1e 	bne	r2,zero,14f84 <__sfvwrite_r+0x464>
   14d08:	81400417 	ldw	r5,16(r16)
   14d0c:	a809883a 	mov	r4,r21
   14d10:	00148500 	call	14850 <_free_r>
   14d14:	00800304 	movi	r2,12
   14d18:	a8800015 	stw	r2,0(r21)
   14d1c:	80c0030b 	ldhu	r3,12(r16)
   14d20:	00bfffc4 	movi	r2,-1
   14d24:	18c01014 	ori	r3,r3,64
   14d28:	80c0030d 	sth	r3,12(r16)
   14d2c:	003fae06 	br	14be8 <__sfvwrite_r+0xc8>
   14d30:	0007883a 	mov	r3,zero
   14d34:	0039883a 	mov	fp,zero
   14d38:	0025883a 	mov	r18,zero
   14d3c:	90001e26 	beq	r18,zero,14db8 <__sfvwrite_r+0x298>
   14d40:	18006526 	beq	r3,zero,14ed8 <__sfvwrite_r+0x3b8>
   14d44:	b02f883a 	mov	r23,r22
   14d48:	9580012e 	bgeu	r18,r22,14d50 <__sfvwrite_r+0x230>
   14d4c:	902f883a 	mov	r23,r18
   14d50:	81000017 	ldw	r4,0(r16)
   14d54:	80800417 	ldw	r2,16(r16)
   14d58:	84c00217 	ldw	r19,8(r16)
   14d5c:	81c00517 	ldw	r7,20(r16)
   14d60:	1100022e 	bgeu	r2,r4,14d6c <__sfvwrite_r+0x24c>
   14d64:	99e7883a 	add	r19,r19,r7
   14d68:	9dc01816 	blt	r19,r23,14dcc <__sfvwrite_r+0x2ac>
   14d6c:	b9c03b16 	blt	r23,r7,14e5c <__sfvwrite_r+0x33c>
   14d70:	80800917 	ldw	r2,36(r16)
   14d74:	81400717 	ldw	r5,28(r16)
   14d78:	a809883a 	mov	r4,r21
   14d7c:	d8c00015 	stw	r3,0(sp)
   14d80:	e00d883a 	mov	r6,fp
   14d84:	103ee83a 	callr	r2
   14d88:	1027883a 	mov	r19,r2
   14d8c:	d8c00017 	ldw	r3,0(sp)
   14d90:	00bfe20e 	bge	zero,r2,14d1c <__sfvwrite_r+0x1fc>
   14d94:	b4edc83a 	sub	r22,r22,r19
   14d98:	b0001a26 	beq	r22,zero,14e04 <__sfvwrite_r+0x2e4>
   14d9c:	a0800217 	ldw	r2,8(r20)
   14da0:	e4f9883a 	add	fp,fp,r19
   14da4:	94e5c83a 	sub	r18,r18,r19
   14da8:	14e7c83a 	sub	r19,r2,r19
   14dac:	a4c00215 	stw	r19,8(r20)
   14db0:	983f8c26 	beq	r19,zero,14be4 <__sfvwrite_r+0xc4>
   14db4:	903fe21e 	bne	r18,zero,14d40 <__sfvwrite_r+0x220>
   14db8:	8f000017 	ldw	fp,0(r17)
   14dbc:	8c800117 	ldw	r18,4(r17)
   14dc0:	0007883a 	mov	r3,zero
   14dc4:	8c400204 	addi	r17,r17,8
   14dc8:	003fdc06 	br	14d3c <__sfvwrite_r+0x21c>
   14dcc:	e00b883a 	mov	r5,fp
   14dd0:	980d883a 	mov	r6,r19
   14dd4:	d8c00015 	stw	r3,0(sp)
   14dd8:	0015c640 	call	15c64 <memmove>
   14ddc:	80800017 	ldw	r2,0(r16)
   14de0:	a809883a 	mov	r4,r21
   14de4:	800b883a 	mov	r5,r16
   14de8:	14c5883a 	add	r2,r2,r19
   14dec:	80800015 	stw	r2,0(r16)
   14df0:	00142240 	call	14224 <_fflush_r>
   14df4:	d8c00017 	ldw	r3,0(sp)
   14df8:	103fc81e 	bne	r2,zero,14d1c <__sfvwrite_r+0x1fc>
   14dfc:	b4edc83a 	sub	r22,r22,r19
   14e00:	b03fe61e 	bne	r22,zero,14d9c <__sfvwrite_r+0x27c>
   14e04:	a809883a 	mov	r4,r21
   14e08:	800b883a 	mov	r5,r16
   14e0c:	00142240 	call	14224 <_fflush_r>
   14e10:	103fc21e 	bne	r2,zero,14d1c <__sfvwrite_r+0x1fc>
   14e14:	0007883a 	mov	r3,zero
   14e18:	003fe006 	br	14d9c <__sfvwrite_r+0x27c>
   14e1c:	81000017 	ldw	r4,0(r16)
   14e20:	80800417 	ldw	r2,16(r16)
   14e24:	1100022e 	bgeu	r2,r4,14e30 <__sfvwrite_r+0x310>
   14e28:	9839883a 	mov	fp,r19
   14e2c:	9c806036 	bltu	r19,r18,14fb0 <__sfvwrite_r+0x490>
   14e30:	81c00517 	ldw	r7,20(r16)
   14e34:	91c01c36 	bltu	r18,r7,14ea8 <__sfvwrite_r+0x388>
   14e38:	80800917 	ldw	r2,36(r16)
   14e3c:	81400717 	ldw	r5,28(r16)
   14e40:	a809883a 	mov	r4,r21
   14e44:	b00d883a 	mov	r6,r22
   14e48:	103ee83a 	callr	r2
   14e4c:	1027883a 	mov	r19,r2
   14e50:	00bfb20e 	bge	zero,r2,14d1c <__sfvwrite_r+0x1fc>
   14e54:	1039883a 	mov	fp,r2
   14e58:	003f9806 	br	14cbc <__sfvwrite_r+0x19c>
   14e5c:	b80d883a 	mov	r6,r23
   14e60:	e00b883a 	mov	r5,fp
   14e64:	d8c00015 	stw	r3,0(sp)
   14e68:	0015c640 	call	15c64 <memmove>
   14e6c:	80800217 	ldw	r2,8(r16)
   14e70:	81000017 	ldw	r4,0(r16)
   14e74:	b827883a 	mov	r19,r23
   14e78:	15c5c83a 	sub	r2,r2,r23
   14e7c:	25ef883a 	add	r23,r4,r23
   14e80:	80800215 	stw	r2,8(r16)
   14e84:	85c00015 	stw	r23,0(r16)
   14e88:	d8c00017 	ldw	r3,0(sp)
   14e8c:	003fc106 	br	14d94 <__sfvwrite_r+0x274>
   14e90:	81000017 	ldw	r4,0(r16)
   14e94:	902f883a 	mov	r23,r18
   14e98:	9039883a 	mov	fp,r18
   14e9c:	9027883a 	mov	r19,r18
   14ea0:	900f883a 	mov	r7,r18
   14ea4:	003f7a06 	br	14c90 <__sfvwrite_r+0x170>
   14ea8:	b00b883a 	mov	r5,r22
   14eac:	900d883a 	mov	r6,r18
   14eb0:	0015c640 	call	15c64 <memmove>
   14eb4:	80c00217 	ldw	r3,8(r16)
   14eb8:	80800017 	ldw	r2,0(r16)
   14ebc:	9027883a 	mov	r19,r18
   14ec0:	1c87c83a 	sub	r3,r3,r18
   14ec4:	1485883a 	add	r2,r2,r18
   14ec8:	80c00215 	stw	r3,8(r16)
   14ecc:	80800015 	stw	r2,0(r16)
   14ed0:	9039883a 	mov	fp,r18
   14ed4:	003f7906 	br	14cbc <__sfvwrite_r+0x19c>
   14ed8:	e009883a 	mov	r4,fp
   14edc:	01400284 	movi	r5,10
   14ee0:	900d883a 	mov	r6,r18
   14ee4:	0015b6c0 	call	15b6c <memchr>
   14ee8:	10003c26 	beq	r2,zero,14fdc <__sfvwrite_r+0x4bc>
   14eec:	15800044 	addi	r22,r2,1
   14ef0:	b72dc83a 	sub	r22,r22,fp
   14ef4:	00c00044 	movi	r3,1
   14ef8:	003f9206 	br	14d44 <__sfvwrite_r+0x224>
   14efc:	81000517 	ldw	r4,20(r16)
   14f00:	81400417 	ldw	r5,16(r16)
   14f04:	80c00017 	ldw	r3,0(r16)
   14f08:	210d883a 	add	r6,r4,r4
   14f0c:	3109883a 	add	r4,r6,r4
   14f10:	2026d7fa 	srli	r19,r4,31
   14f14:	1979c83a 	sub	fp,r3,r5
   14f18:	e1800044 	addi	r6,fp,1
   14f1c:	9909883a 	add	r4,r19,r4
   14f20:	2027d07a 	srai	r19,r4,1
   14f24:	3489883a 	add	r4,r6,r18
   14f28:	980d883a 	mov	r6,r19
   14f2c:	9900022e 	bgeu	r19,r4,14f38 <__sfvwrite_r+0x418>
   14f30:	2027883a 	mov	r19,r4
   14f34:	200d883a 	mov	r6,r4
   14f38:	1081000c 	andi	r2,r2,1024
   14f3c:	10bfffcc 	andi	r2,r2,65535
   14f40:	10a0001c 	xori	r2,r2,32768
   14f44:	10a00004 	addi	r2,r2,-32768
   14f48:	a809883a 	mov	r4,r21
   14f4c:	103f6b26 	beq	r2,zero,14cfc <__sfvwrite_r+0x1dc>
   14f50:	300b883a 	mov	r5,r6
   14f54:	00153e80 	call	153e8 <_malloc_r>
   14f58:	102f883a 	mov	r23,r2
   14f5c:	103f6d26 	beq	r2,zero,14d14 <__sfvwrite_r+0x1f4>
   14f60:	81400417 	ldw	r5,16(r16)
   14f64:	1009883a 	mov	r4,r2
   14f68:	e00d883a 	mov	r6,fp
   14f6c:	00102380 	call	10238 <memcpy>
   14f70:	8080030b 	ldhu	r2,12(r16)
   14f74:	00fedfc4 	movi	r3,-1153
   14f78:	10c4703a 	and	r2,r2,r3
   14f7c:	10802014 	ori	r2,r2,128
   14f80:	8080030d 	sth	r2,12(r16)
   14f84:	bf09883a 	add	r4,r23,fp
   14f88:	9f07c83a 	sub	r3,r19,fp
   14f8c:	85c00415 	stw	r23,16(r16)
   14f90:	84c00515 	stw	r19,20(r16)
   14f94:	81000015 	stw	r4,0(r16)
   14f98:	902f883a 	mov	r23,r18
   14f9c:	80c00215 	stw	r3,8(r16)
   14fa0:	9039883a 	mov	fp,r18
   14fa4:	9027883a 	mov	r19,r18
   14fa8:	900f883a 	mov	r7,r18
   14fac:	003f3806 	br	14c90 <__sfvwrite_r+0x170>
   14fb0:	b00b883a 	mov	r5,r22
   14fb4:	980d883a 	mov	r6,r19
   14fb8:	0015c640 	call	15c64 <memmove>
   14fbc:	80800017 	ldw	r2,0(r16)
   14fc0:	a809883a 	mov	r4,r21
   14fc4:	800b883a 	mov	r5,r16
   14fc8:	14c5883a 	add	r2,r2,r19
   14fcc:	80800015 	stw	r2,0(r16)
   14fd0:	00142240 	call	14224 <_fflush_r>
   14fd4:	103f3926 	beq	r2,zero,14cbc <__sfvwrite_r+0x19c>
   14fd8:	003f5006 	br	14d1c <__sfvwrite_r+0x1fc>
   14fdc:	95800044 	addi	r22,r18,1
   14fe0:	00c00044 	movi	r3,1
   14fe4:	003f5706 	br	14d44 <__sfvwrite_r+0x224>
   14fe8:	80c0030b 	ldhu	r3,12(r16)
   14fec:	00bfffc4 	movi	r2,-1
   14ff0:	18c01014 	ori	r3,r3,64
   14ff4:	80c0030d 	sth	r3,12(r16)
   14ff8:	00c00244 	movi	r3,9
   14ffc:	a8c00015 	stw	r3,0(r21)
   15000:	003ef906 	br	14be8 <__sfvwrite_r+0xc8>

00015004 <_fwalk>:
   15004:	defff904 	addi	sp,sp,-28
   15008:	dcc00315 	stw	r19,12(sp)
   1500c:	24c0b804 	addi	r19,r4,736
   15010:	dd400515 	stw	r21,20(sp)
   15014:	dd000415 	stw	r20,16(sp)
   15018:	dfc00615 	stw	ra,24(sp)
   1501c:	dc800215 	stw	r18,8(sp)
   15020:	dc400115 	stw	r17,4(sp)
   15024:	dc000015 	stw	r16,0(sp)
   15028:	282b883a 	mov	r21,r5
   1502c:	0029883a 	mov	r20,zero
   15030:	00146d40 	call	146d4 <__sfp_lock_acquire>
   15034:	98001226 	beq	r19,zero,15080 <_fwalk+0x7c>
   15038:	04bfffc4 	movi	r18,-1
   1503c:	9c400117 	ldw	r17,4(r19)
   15040:	9c000217 	ldw	r16,8(r19)
   15044:	8c7fffc4 	addi	r17,r17,-1
   15048:	88000b16 	blt	r17,zero,15078 <_fwalk+0x74>
   1504c:	84000304 	addi	r16,r16,12
   15050:	80c0000f 	ldh	r3,0(r16)
   15054:	8c7fffc4 	addi	r17,r17,-1
   15058:	813ffd04 	addi	r4,r16,-12
   1505c:	18000426 	beq	r3,zero,15070 <_fwalk+0x6c>
   15060:	80c0008f 	ldh	r3,2(r16)
   15064:	1c800226 	beq	r3,r18,15070 <_fwalk+0x6c>
   15068:	a83ee83a 	callr	r21
   1506c:	a0a8b03a 	or	r20,r20,r2
   15070:	84001704 	addi	r16,r16,92
   15074:	8cbff61e 	bne	r17,r18,15050 <_fwalk+0x4c>
   15078:	9cc00017 	ldw	r19,0(r19)
   1507c:	983fef1e 	bne	r19,zero,1503c <_fwalk+0x38>
   15080:	00146d80 	call	146d8 <__sfp_lock_release>
   15084:	a005883a 	mov	r2,r20
   15088:	dfc00617 	ldw	ra,24(sp)
   1508c:	dd400517 	ldw	r21,20(sp)
   15090:	dd000417 	ldw	r20,16(sp)
   15094:	dcc00317 	ldw	r19,12(sp)
   15098:	dc800217 	ldw	r18,8(sp)
   1509c:	dc400117 	ldw	r17,4(sp)
   150a0:	dc000017 	ldw	r16,0(sp)
   150a4:	dec00704 	addi	sp,sp,28
   150a8:	f800283a 	ret

000150ac <_fwalk_reent>:
   150ac:	defff804 	addi	sp,sp,-32
   150b0:	dcc00315 	stw	r19,12(sp)
   150b4:	24c0b804 	addi	r19,r4,736
   150b8:	dd800615 	stw	r22,24(sp)
   150bc:	dd400515 	stw	r21,20(sp)
   150c0:	dd000415 	stw	r20,16(sp)
   150c4:	dfc00715 	stw	ra,28(sp)
   150c8:	dc800215 	stw	r18,8(sp)
   150cc:	dc400115 	stw	r17,4(sp)
   150d0:	dc000015 	stw	r16,0(sp)
   150d4:	2029883a 	mov	r20,r4
   150d8:	282b883a 	mov	r21,r5
   150dc:	002d883a 	mov	r22,zero
   150e0:	00146d40 	call	146d4 <__sfp_lock_acquire>
   150e4:	98001326 	beq	r19,zero,15134 <_fwalk_reent+0x88>
   150e8:	04bfffc4 	movi	r18,-1
   150ec:	9c400117 	ldw	r17,4(r19)
   150f0:	9c000217 	ldw	r16,8(r19)
   150f4:	8c7fffc4 	addi	r17,r17,-1
   150f8:	88000c16 	blt	r17,zero,1512c <_fwalk_reent+0x80>
   150fc:	84000304 	addi	r16,r16,12
   15100:	80c0000f 	ldh	r3,0(r16)
   15104:	8c7fffc4 	addi	r17,r17,-1
   15108:	817ffd04 	addi	r5,r16,-12
   1510c:	18000526 	beq	r3,zero,15124 <_fwalk_reent+0x78>
   15110:	80c0008f 	ldh	r3,2(r16)
   15114:	a009883a 	mov	r4,r20
   15118:	1c800226 	beq	r3,r18,15124 <_fwalk_reent+0x78>
   1511c:	a83ee83a 	callr	r21
   15120:	b0acb03a 	or	r22,r22,r2
   15124:	84001704 	addi	r16,r16,92
   15128:	8cbff51e 	bne	r17,r18,15100 <_fwalk_reent+0x54>
   1512c:	9cc00017 	ldw	r19,0(r19)
   15130:	983fee1e 	bne	r19,zero,150ec <_fwalk_reent+0x40>
   15134:	00146d80 	call	146d8 <__sfp_lock_release>
   15138:	b005883a 	mov	r2,r22
   1513c:	dfc00717 	ldw	ra,28(sp)
   15140:	dd800617 	ldw	r22,24(sp)
   15144:	dd400517 	ldw	r21,20(sp)
   15148:	dd000417 	ldw	r20,16(sp)
   1514c:	dcc00317 	ldw	r19,12(sp)
   15150:	dc800217 	ldw	r18,8(sp)
   15154:	dc400117 	ldw	r17,4(sp)
   15158:	dc000017 	ldw	r16,0(sp)
   1515c:	dec00804 	addi	sp,sp,32
   15160:	f800283a 	ret

00015164 <_setlocale_r>:
   15164:	defffc04 	addi	sp,sp,-16
   15168:	dc800215 	stw	r18,8(sp)
   1516c:	dc400115 	stw	r17,4(sp)
   15170:	dc000015 	stw	r16,0(sp)
   15174:	dfc00315 	stw	ra,12(sp)
   15178:	3021883a 	mov	r16,r6
   1517c:	2023883a 	mov	r17,r4
   15180:	2825883a 	mov	r18,r5
   15184:	30001626 	beq	r6,zero,151e0 <_setlocale_r+0x7c>
   15188:	3009883a 	mov	r4,r6
   1518c:	014000b4 	movhi	r5,2
   15190:	2959b004 	addi	r5,r5,26304
   15194:	00106b80 	call	106b8 <strcmp>
   15198:	10000a1e 	bne	r2,zero,151c4 <_setlocale_r+0x60>
   1519c:	8c800c15 	stw	r18,48(r17)
   151a0:	8c000d15 	stw	r16,52(r17)
   151a4:	008000b4 	movhi	r2,2
   151a8:	1099b004 	addi	r2,r2,26304
   151ac:	dfc00317 	ldw	ra,12(sp)
   151b0:	dc800217 	ldw	r18,8(sp)
   151b4:	dc400117 	ldw	r17,4(sp)
   151b8:	dc000017 	ldw	r16,0(sp)
   151bc:	dec00404 	addi	sp,sp,16
   151c0:	f800283a 	ret
   151c4:	8009883a 	mov	r4,r16
   151c8:	014000b4 	movhi	r5,2
   151cc:	295c7e04 	addi	r5,r5,29176
   151d0:	00106b80 	call	106b8 <strcmp>
   151d4:	103ff126 	beq	r2,zero,1519c <_setlocale_r+0x38>
   151d8:	0005883a 	mov	r2,zero
   151dc:	003ff306 	br	151ac <_setlocale_r+0x48>
   151e0:	008000b4 	movhi	r2,2
   151e4:	1099b004 	addi	r2,r2,26304
   151e8:	dfc00317 	ldw	ra,12(sp)
   151ec:	dc800217 	ldw	r18,8(sp)
   151f0:	dc400117 	ldw	r17,4(sp)
   151f4:	dc000017 	ldw	r16,0(sp)
   151f8:	dec00404 	addi	sp,sp,16
   151fc:	f800283a 	ret

00015200 <__locale_charset>:
   15200:	008000b4 	movhi	r2,2
   15204:	10984704 	addi	r2,r2,24860
   15208:	f800283a 	ret

0001520c <_localeconv_r>:
   1520c:	008000b4 	movhi	r2,2
   15210:	10984b04 	addi	r2,r2,24876
   15214:	f800283a 	ret

00015218 <setlocale>:
   15218:	00c000f4 	movhi	r3,3
   1521c:	18e60a04 	addi	r3,r3,-26584
   15220:	2005883a 	mov	r2,r4
   15224:	19000017 	ldw	r4,0(r3)
   15228:	280d883a 	mov	r6,r5
   1522c:	100b883a 	mov	r5,r2
   15230:	00151641 	jmpi	15164 <_setlocale_r>

00015234 <localeconv>:
   15234:	008000b4 	movhi	r2,2
   15238:	10984b04 	addi	r2,r2,24876
   1523c:	f800283a 	ret

00015240 <__smakebuf_r>:
   15240:	2880030b 	ldhu	r2,12(r5)
   15244:	deffed04 	addi	sp,sp,-76
   15248:	dc401015 	stw	r17,64(sp)
   1524c:	10c0008c 	andi	r3,r2,2
   15250:	18ffffcc 	andi	r3,r3,65535
   15254:	18e0001c 	xori	r3,r3,32768
   15258:	dc000f15 	stw	r16,60(sp)
   1525c:	dfc01215 	stw	ra,72(sp)
   15260:	dc801115 	stw	r18,68(sp)
   15264:	18e00004 	addi	r3,r3,-32768
   15268:	2821883a 	mov	r16,r5
   1526c:	2023883a 	mov	r17,r4
   15270:	1800381e 	bne	r3,zero,15354 <__smakebuf_r+0x114>
   15274:	2940038f 	ldh	r5,14(r5)
   15278:	28002d16 	blt	r5,zero,15330 <__smakebuf_r+0xf0>
   1527c:	d80d883a 	mov	r6,sp
   15280:	00178140 	call	17814 <_fstat_r>
   15284:	10002916 	blt	r2,zero,1532c <__smakebuf_r+0xec>
   15288:	d8800117 	ldw	r2,4(sp)
   1528c:	00e00014 	movui	r3,32768
   15290:	10bc000c 	andi	r2,r2,61440
   15294:	10c03c26 	beq	r2,r3,15388 <__smakebuf_r+0x148>
   15298:	80c0030b 	ldhu	r3,12(r16)
   1529c:	18c20014 	ori	r3,r3,2048
   152a0:	80c0030d 	sth	r3,12(r16)
   152a4:	00c80004 	movi	r3,8192
   152a8:	10c00c1e 	bne	r2,r3,152dc <__smakebuf_r+0x9c>
   152ac:	8140038f 	ldh	r5,14(r16)
   152b0:	8809883a 	mov	r4,r17
   152b4:	001787c0 	call	1787c <_isatty_r>
   152b8:	10000826 	beq	r2,zero,152dc <__smakebuf_r+0x9c>
   152bc:	80c0030b 	ldhu	r3,12(r16)
   152c0:	808010c4 	addi	r2,r16,67
   152c4:	80800015 	stw	r2,0(r16)
   152c8:	18c00054 	ori	r3,r3,1
   152cc:	80800415 	stw	r2,16(r16)
   152d0:	00800044 	movi	r2,1
   152d4:	80c0030d 	sth	r3,12(r16)
   152d8:	80800515 	stw	r2,20(r16)
   152dc:	04810004 	movi	r18,1024
   152e0:	8809883a 	mov	r4,r17
   152e4:	900b883a 	mov	r5,r18
   152e8:	00153e80 	call	153e8 <_malloc_r>
   152ec:	10003026 	beq	r2,zero,153b0 <__smakebuf_r+0x170>
   152f0:	80c0030b 	ldhu	r3,12(r16)
   152f4:	01000074 	movhi	r4,1
   152f8:	21111304 	addi	r4,r4,17484
   152fc:	89000f15 	stw	r4,60(r17)
   15300:	18c02014 	ori	r3,r3,128
   15304:	80c0030d 	sth	r3,12(r16)
   15308:	80800015 	stw	r2,0(r16)
   1530c:	80800415 	stw	r2,16(r16)
   15310:	84800515 	stw	r18,20(r16)
   15314:	dfc01217 	ldw	ra,72(sp)
   15318:	dc801117 	ldw	r18,68(sp)
   1531c:	dc401017 	ldw	r17,64(sp)
   15320:	dc000f17 	ldw	r16,60(sp)
   15324:	dec01304 	addi	sp,sp,76
   15328:	f800283a 	ret
   1532c:	8080030b 	ldhu	r2,12(r16)
   15330:	10c0200c 	andi	r3,r2,128
   15334:	18ffffcc 	andi	r3,r3,65535
   15338:	18e0001c 	xori	r3,r3,32768
   1533c:	18e00004 	addi	r3,r3,-32768
   15340:	18000f1e 	bne	r3,zero,15380 <__smakebuf_r+0x140>
   15344:	04810004 	movi	r18,1024
   15348:	10820014 	ori	r2,r2,2048
   1534c:	8080030d 	sth	r2,12(r16)
   15350:	003fe306 	br	152e0 <__smakebuf_r+0xa0>
   15354:	288010c4 	addi	r2,r5,67
   15358:	28800015 	stw	r2,0(r5)
   1535c:	28800415 	stw	r2,16(r5)
   15360:	00800044 	movi	r2,1
   15364:	28800515 	stw	r2,20(r5)
   15368:	dfc01217 	ldw	ra,72(sp)
   1536c:	dc801117 	ldw	r18,68(sp)
   15370:	dc401017 	ldw	r17,64(sp)
   15374:	dc000f17 	ldw	r16,60(sp)
   15378:	dec01304 	addi	sp,sp,76
   1537c:	f800283a 	ret
   15380:	04801004 	movi	r18,64
   15384:	003ff006 	br	15348 <__smakebuf_r+0x108>
   15388:	81000a17 	ldw	r4,40(r16)
   1538c:	00c00074 	movhi	r3,1
   15390:	18dd3504 	addi	r3,r3,29908
   15394:	20ffc01e 	bne	r4,r3,15298 <__smakebuf_r+0x58>
   15398:	8080030b 	ldhu	r2,12(r16)
   1539c:	00c10004 	movi	r3,1024
   153a0:	80c01315 	stw	r3,76(r16)
   153a4:	10c4b03a 	or	r2,r2,r3
   153a8:	8080030d 	sth	r2,12(r16)
   153ac:	003fcb06 	br	152dc <__smakebuf_r+0x9c>
   153b0:	8080030b 	ldhu	r2,12(r16)
   153b4:	10c0800c 	andi	r3,r2,512
   153b8:	18ffffcc 	andi	r3,r3,65535
   153bc:	18e0001c 	xori	r3,r3,32768
   153c0:	18e00004 	addi	r3,r3,-32768
   153c4:	183fd31e 	bne	r3,zero,15314 <__smakebuf_r+0xd4>
   153c8:	10800094 	ori	r2,r2,2
   153cc:	80c010c4 	addi	r3,r16,67
   153d0:	8080030d 	sth	r2,12(r16)
   153d4:	00800044 	movi	r2,1
   153d8:	80c00015 	stw	r3,0(r16)
   153dc:	80c00415 	stw	r3,16(r16)
   153e0:	80800515 	stw	r2,20(r16)
   153e4:	003fcb06 	br	15314 <__smakebuf_r+0xd4>

000153e8 <_malloc_r>:
   153e8:	defff604 	addi	sp,sp,-40
   153ec:	dc800215 	stw	r18,8(sp)
   153f0:	dfc00915 	stw	ra,36(sp)
   153f4:	df000815 	stw	fp,32(sp)
   153f8:	ddc00715 	stw	r23,28(sp)
   153fc:	dd800615 	stw	r22,24(sp)
   15400:	dd400515 	stw	r21,20(sp)
   15404:	dd000415 	stw	r20,16(sp)
   15408:	dcc00315 	stw	r19,12(sp)
   1540c:	dc400115 	stw	r17,4(sp)
   15410:	dc000015 	stw	r16,0(sp)
   15414:	288002c4 	addi	r2,r5,11
   15418:	00c00584 	movi	r3,22
   1541c:	2025883a 	mov	r18,r4
   15420:	18802b2e 	bgeu	r3,r2,154d0 <_malloc_r+0xe8>
   15424:	047ffe04 	movi	r17,-8
   15428:	1462703a 	and	r17,r2,r17
   1542c:	88002a16 	blt	r17,zero,154d8 <_malloc_r+0xf0>
   15430:	89402936 	bltu	r17,r5,154d8 <_malloc_r+0xf0>
   15434:	9009883a 	mov	r4,r18
   15438:	0018fa80 	call	18fa8 <__malloc_lock>
   1543c:	00807dc4 	movi	r2,503
   15440:	14402936 	bltu	r2,r17,154e8 <_malloc_r+0x100>
   15444:	8808d0fa 	srli	r4,r17,3
   15448:	04c000b4 	movhi	r19,2
   1544c:	9cdf2904 	addi	r19,r19,31908
   15450:	2105883a 	add	r2,r4,r4
   15454:	1085883a 	add	r2,r2,r2
   15458:	1085883a 	add	r2,r2,r2
   1545c:	9885883a 	add	r2,r19,r2
   15460:	14000317 	ldw	r16,12(r2)
   15464:	80815526 	beq	r16,r2,159bc <_malloc_r+0x5d4>
   15468:	81000117 	ldw	r4,4(r16)
   1546c:	00bfff04 	movi	r2,-4
   15470:	80c00317 	ldw	r3,12(r16)
   15474:	2084703a 	and	r2,r4,r2
   15478:	8085883a 	add	r2,r16,r2
   1547c:	11800117 	ldw	r6,4(r2)
   15480:	81400217 	ldw	r5,8(r16)
   15484:	9009883a 	mov	r4,r18
   15488:	31800054 	ori	r6,r6,1
   1548c:	11800115 	stw	r6,4(r2)
   15490:	28c00315 	stw	r3,12(r5)
   15494:	19400215 	stw	r5,8(r3)
   15498:	0018fc80 	call	18fc8 <__malloc_unlock>
   1549c:	80800204 	addi	r2,r16,8
   154a0:	dfc00917 	ldw	ra,36(sp)
   154a4:	df000817 	ldw	fp,32(sp)
   154a8:	ddc00717 	ldw	r23,28(sp)
   154ac:	dd800617 	ldw	r22,24(sp)
   154b0:	dd400517 	ldw	r21,20(sp)
   154b4:	dd000417 	ldw	r20,16(sp)
   154b8:	dcc00317 	ldw	r19,12(sp)
   154bc:	dc800217 	ldw	r18,8(sp)
   154c0:	dc400117 	ldw	r17,4(sp)
   154c4:	dc000017 	ldw	r16,0(sp)
   154c8:	dec00a04 	addi	sp,sp,40
   154cc:	f800283a 	ret
   154d0:	04400404 	movi	r17,16
   154d4:	897fd72e 	bgeu	r17,r5,15434 <_malloc_r+0x4c>
   154d8:	00800304 	movi	r2,12
   154dc:	90800015 	stw	r2,0(r18)
   154e0:	0005883a 	mov	r2,zero
   154e4:	003fee06 	br	154a0 <_malloc_r+0xb8>
   154e8:	8808d27a 	srli	r4,r17,9
   154ec:	20007126 	beq	r4,zero,156b4 <_malloc_r+0x2cc>
   154f0:	00800104 	movi	r2,4
   154f4:	1100eb36 	bltu	r2,r4,158a4 <_malloc_r+0x4bc>
   154f8:	8808d1ba 	srli	r4,r17,6
   154fc:	21000e04 	addi	r4,r4,56
   15500:	210b883a 	add	r5,r4,r4
   15504:	294b883a 	add	r5,r5,r5
   15508:	294b883a 	add	r5,r5,r5
   1550c:	04c000b4 	movhi	r19,2
   15510:	9cdf2904 	addi	r19,r19,31908
   15514:	994b883a 	add	r5,r19,r5
   15518:	2c000317 	ldw	r16,12(r5)
   1551c:	2c000e26 	beq	r5,r16,15558 <_malloc_r+0x170>
   15520:	80c00117 	ldw	r3,4(r16)
   15524:	01ffff04 	movi	r7,-4
   15528:	018003c4 	movi	r6,15
   1552c:	19c6703a 	and	r3,r3,r7
   15530:	1c45c83a 	sub	r2,r3,r17
   15534:	30800716 	blt	r6,r2,15554 <_malloc_r+0x16c>
   15538:	1000610e 	bge	r2,zero,156c0 <_malloc_r+0x2d8>
   1553c:	84000317 	ldw	r16,12(r16)
   15540:	2c000526 	beq	r5,r16,15558 <_malloc_r+0x170>
   15544:	80c00117 	ldw	r3,4(r16)
   15548:	19c6703a 	and	r3,r3,r7
   1554c:	1c45c83a 	sub	r2,r3,r17
   15550:	30bff90e 	bge	r6,r2,15538 <_malloc_r+0x150>
   15554:	213fffc4 	addi	r4,r4,-1
   15558:	21000044 	addi	r4,r4,1
   1555c:	9c000417 	ldw	r16,16(r19)
   15560:	00c000b4 	movhi	r3,2
   15564:	18df2904 	addi	r3,r3,31908
   15568:	1a400204 	addi	r9,r3,8
   1556c:	8240ff26 	beq	r16,r9,1596c <_malloc_r+0x584>
   15570:	81400117 	ldw	r5,4(r16)
   15574:	00bfff04 	movi	r2,-4
   15578:	018003c4 	movi	r6,15
   1557c:	2884703a 	and	r2,r5,r2
   15580:	144bc83a 	sub	r5,r2,r17
   15584:	3140ea16 	blt	r6,r5,15930 <_malloc_r+0x548>
   15588:	1a400515 	stw	r9,20(r3)
   1558c:	1a400415 	stw	r9,16(r3)
   15590:	2800570e 	bge	r5,zero,156f0 <_malloc_r+0x308>
   15594:	01407fc4 	movi	r5,511
   15598:	2880ca36 	bltu	r5,r2,158c4 <_malloc_r+0x4dc>
   1559c:	1004d0fa 	srli	r2,r2,3
   155a0:	02000044 	movi	r8,1
   155a4:	19c00117 	ldw	r7,4(r3)
   155a8:	108b883a 	add	r5,r2,r2
   155ac:	294b883a 	add	r5,r5,r5
   155b0:	1005d0ba 	srai	r2,r2,2
   155b4:	294b883a 	add	r5,r5,r5
   155b8:	28cb883a 	add	r5,r5,r3
   155bc:	29800217 	ldw	r6,8(r5)
   155c0:	4084983a 	sll	r2,r8,r2
   155c4:	81400315 	stw	r5,12(r16)
   155c8:	81800215 	stw	r6,8(r16)
   155cc:	11c4b03a 	or	r2,r2,r7
   155d0:	18800115 	stw	r2,4(r3)
   155d4:	2c000215 	stw	r16,8(r5)
   155d8:	34000315 	stw	r16,12(r6)
   155dc:	200bd0ba 	srai	r5,r4,2
   155e0:	00c00044 	movi	r3,1
   155e4:	194a983a 	sll	r5,r3,r5
   155e8:	11404936 	bltu	r2,r5,15710 <_malloc_r+0x328>
   155ec:	1146703a 	and	r3,r2,r5
   155f0:	18000a1e 	bne	r3,zero,1561c <_malloc_r+0x234>
   155f4:	00ffff04 	movi	r3,-4
   155f8:	294b883a 	add	r5,r5,r5
   155fc:	20c8703a 	and	r4,r4,r3
   15600:	1146703a 	and	r3,r2,r5
   15604:	21000104 	addi	r4,r4,4
   15608:	1800041e 	bne	r3,zero,1561c <_malloc_r+0x234>
   1560c:	294b883a 	add	r5,r5,r5
   15610:	1146703a 	and	r3,r2,r5
   15614:	21000104 	addi	r4,r4,4
   15618:	183ffc26 	beq	r3,zero,1560c <_malloc_r+0x224>
   1561c:	023fff04 	movi	r8,-4
   15620:	01c003c4 	movi	r7,15
   15624:	2105883a 	add	r2,r4,r4
   15628:	1085883a 	add	r2,r2,r2
   1562c:	1085883a 	add	r2,r2,r2
   15630:	9899883a 	add	r12,r19,r2
   15634:	62800304 	addi	r10,r12,12
   15638:	2017883a 	mov	r11,r4
   1563c:	54000017 	ldw	r16,0(r10)
   15640:	51bffd04 	addi	r6,r10,-12
   15644:	8180041e 	bne	r16,r6,15658 <_malloc_r+0x270>
   15648:	0000ca06 	br	15974 <_malloc_r+0x58c>
   1564c:	10001c0e 	bge	r2,zero,156c0 <_malloc_r+0x2d8>
   15650:	84000317 	ldw	r16,12(r16)
   15654:	8180c726 	beq	r16,r6,15974 <_malloc_r+0x58c>
   15658:	80c00117 	ldw	r3,4(r16)
   1565c:	1a06703a 	and	r3,r3,r8
   15660:	1c45c83a 	sub	r2,r3,r17
   15664:	38bff90e 	bge	r7,r2,1564c <_malloc_r+0x264>
   15668:	81000317 	ldw	r4,12(r16)
   1566c:	81400217 	ldw	r5,8(r16)
   15670:	8447883a 	add	r3,r16,r17
   15674:	8c400054 	ori	r17,r17,1
   15678:	29000315 	stw	r4,12(r5)
   1567c:	21400215 	stw	r5,8(r4)
   15680:	84400115 	stw	r17,4(r16)
   15684:	1889883a 	add	r4,r3,r2
   15688:	11400054 	ori	r5,r2,1
   1568c:	98c00515 	stw	r3,20(r19)
   15690:	98c00415 	stw	r3,16(r19)
   15694:	20800015 	stw	r2,0(r4)
   15698:	1a400315 	stw	r9,12(r3)
   1569c:	1a400215 	stw	r9,8(r3)
   156a0:	19400115 	stw	r5,4(r3)
   156a4:	9009883a 	mov	r4,r18
   156a8:	0018fc80 	call	18fc8 <__malloc_unlock>
   156ac:	80800204 	addi	r2,r16,8
   156b0:	003f7b06 	br	154a0 <_malloc_r+0xb8>
   156b4:	8808d0fa 	srli	r4,r17,3
   156b8:	210b883a 	add	r5,r4,r4
   156bc:	003f9106 	br	15504 <_malloc_r+0x11c>
   156c0:	80c7883a 	add	r3,r16,r3
   156c4:	19400117 	ldw	r5,4(r3)
   156c8:	80800317 	ldw	r2,12(r16)
   156cc:	81000217 	ldw	r4,8(r16)
   156d0:	29400054 	ori	r5,r5,1
   156d4:	19400115 	stw	r5,4(r3)
   156d8:	20800315 	stw	r2,12(r4)
   156dc:	11000215 	stw	r4,8(r2)
   156e0:	9009883a 	mov	r4,r18
   156e4:	0018fc80 	call	18fc8 <__malloc_unlock>
   156e8:	80800204 	addi	r2,r16,8
   156ec:	003f6c06 	br	154a0 <_malloc_r+0xb8>
   156f0:	8085883a 	add	r2,r16,r2
   156f4:	10c00117 	ldw	r3,4(r2)
   156f8:	9009883a 	mov	r4,r18
   156fc:	18c00054 	ori	r3,r3,1
   15700:	10c00115 	stw	r3,4(r2)
   15704:	0018fc80 	call	18fc8 <__malloc_unlock>
   15708:	80800204 	addi	r2,r16,8
   1570c:	003f6406 	br	154a0 <_malloc_r+0xb8>
   15710:	9c000217 	ldw	r16,8(r19)
   15714:	00bfff04 	movi	r2,-4
   15718:	85400117 	ldw	r21,4(r16)
   1571c:	a8aa703a 	and	r21,r21,r2
   15720:	ac400336 	bltu	r21,r17,15730 <_malloc_r+0x348>
   15724:	ac45c83a 	sub	r2,r21,r17
   15728:	00c003c4 	movi	r3,15
   1572c:	18805316 	blt	r3,r2,1587c <_malloc_r+0x494>
   15730:	d5e8d617 	ldw	r23,-23720(gp)
   15734:	d0e00f17 	ldw	r3,-32708(gp)
   15738:	00bfffc4 	movi	r2,-1
   1573c:	8579883a 	add	fp,r16,r21
   15740:	8def883a 	add	r23,r17,r23
   15744:	1880d226 	beq	r3,r2,15a90 <_malloc_r+0x6a8>
   15748:	bdc403c4 	addi	r23,r23,4111
   1574c:	00bc0004 	movi	r2,-4096
   15750:	b8ae703a 	and	r23,r23,r2
   15754:	9009883a 	mov	r4,r18
   15758:	b80b883a 	mov	r5,r23
   1575c:	00173940 	call	17394 <_sbrk_r>
   15760:	1029883a 	mov	r20,r2
   15764:	00bfffc4 	movi	r2,-1
   15768:	a080d126 	beq	r20,r2,15ab0 <_malloc_r+0x6c8>
   1576c:	a7009f36 	bltu	r20,fp,159ec <_malloc_r+0x604>
   15770:	05800134 	movhi	r22,4
   15774:	b5a7fc04 	addi	r22,r22,-24592
   15778:	b0800017 	ldw	r2,0(r22)
   1577c:	b885883a 	add	r2,r23,r2
   15780:	b0800015 	stw	r2,0(r22)
   15784:	e500cf26 	beq	fp,r20,15ac4 <_malloc_r+0x6dc>
   15788:	d1200f17 	ldw	r4,-32708(gp)
   1578c:	00ffffc4 	movi	r3,-1
   15790:	20c0e026 	beq	r4,r3,15b14 <_malloc_r+0x72c>
   15794:	a739c83a 	sub	fp,r20,fp
   15798:	1705883a 	add	r2,r2,fp
   1579c:	b0800015 	stw	r2,0(r22)
   157a0:	a08001cc 	andi	r2,r20,7
   157a4:	1000a526 	beq	r2,zero,15a3c <_malloc_r+0x654>
   157a8:	a0a9c83a 	sub	r20,r20,r2
   157ac:	00c40204 	movi	r3,4104
   157b0:	a5000204 	addi	r20,r20,8
   157b4:	1885c83a 	sub	r2,r3,r2
   157b8:	a5c7883a 	add	r3,r20,r23
   157bc:	18c3ffcc 	andi	r3,r3,4095
   157c0:	10efc83a 	sub	r23,r2,r3
   157c4:	9009883a 	mov	r4,r18
   157c8:	b80b883a 	mov	r5,r23
   157cc:	00173940 	call	17394 <_sbrk_r>
   157d0:	00ffffc4 	movi	r3,-1
   157d4:	10c0cc26 	beq	r2,r3,15b08 <_malloc_r+0x720>
   157d8:	1505c83a 	sub	r2,r2,r20
   157dc:	b887883a 	add	r3,r23,r2
   157e0:	18c00054 	ori	r3,r3,1
   157e4:	b0800017 	ldw	r2,0(r22)
   157e8:	9d000215 	stw	r20,8(r19)
   157ec:	a0c00115 	stw	r3,4(r20)
   157f0:	b885883a 	add	r2,r23,r2
   157f4:	b0800015 	stw	r2,0(r22)
   157f8:	84c00e26 	beq	r16,r19,15834 <_malloc_r+0x44c>
   157fc:	00c003c4 	movi	r3,15
   15800:	1d40902e 	bgeu	r3,r21,15a44 <_malloc_r+0x65c>
   15804:	ad7ffd04 	addi	r21,r21,-12
   15808:	013ffe04 	movi	r4,-8
   1580c:	a908703a 	and	r4,r21,r4
   15810:	810b883a 	add	r5,r16,r4
   15814:	01800144 	movi	r6,5
   15818:	29800115 	stw	r6,4(r5)
   1581c:	29800215 	stw	r6,8(r5)
   15820:	81400117 	ldw	r5,4(r16)
   15824:	2940004c 	andi	r5,r5,1
   15828:	214ab03a 	or	r5,r4,r5
   1582c:	81400115 	stw	r5,4(r16)
   15830:	1900ae36 	bltu	r3,r4,15aec <_malloc_r+0x704>
   15834:	d0e8d517 	ldw	r3,-23724(gp)
   15838:	1880012e 	bgeu	r3,r2,15840 <_malloc_r+0x458>
   1583c:	d0a8d515 	stw	r2,-23724(gp)
   15840:	d0e8d417 	ldw	r3,-23728(gp)
   15844:	9c000217 	ldw	r16,8(r19)
   15848:	1880012e 	bgeu	r3,r2,15850 <_malloc_r+0x468>
   1584c:	d0a8d415 	stw	r2,-23728(gp)
   15850:	80c00117 	ldw	r3,4(r16)
   15854:	00bfff04 	movi	r2,-4
   15858:	1886703a 	and	r3,r3,r2
   1585c:	1c45c83a 	sub	r2,r3,r17
   15860:	1c400236 	bltu	r3,r17,1586c <_malloc_r+0x484>
   15864:	00c003c4 	movi	r3,15
   15868:	18800416 	blt	r3,r2,1587c <_malloc_r+0x494>
   1586c:	9009883a 	mov	r4,r18
   15870:	0018fc80 	call	18fc8 <__malloc_unlock>
   15874:	0005883a 	mov	r2,zero
   15878:	003f0906 	br	154a0 <_malloc_r+0xb8>
   1587c:	88c00054 	ori	r3,r17,1
   15880:	10800054 	ori	r2,r2,1
   15884:	80c00115 	stw	r3,4(r16)
   15888:	8463883a 	add	r17,r16,r17
   1588c:	88800115 	stw	r2,4(r17)
   15890:	9009883a 	mov	r4,r18
   15894:	9c400215 	stw	r17,8(r19)
   15898:	0018fc80 	call	18fc8 <__malloc_unlock>
   1589c:	80800204 	addi	r2,r16,8
   158a0:	003eff06 	br	154a0 <_malloc_r+0xb8>
   158a4:	00800504 	movi	r2,20
   158a8:	1100492e 	bgeu	r2,r4,159d0 <_malloc_r+0x5e8>
   158ac:	00801504 	movi	r2,84
   158b0:	11005c36 	bltu	r2,r4,15a24 <_malloc_r+0x63c>
   158b4:	8808d33a 	srli	r4,r17,12
   158b8:	21001b84 	addi	r4,r4,110
   158bc:	210b883a 	add	r5,r4,r4
   158c0:	003f1006 	br	15504 <_malloc_r+0x11c>
   158c4:	1006d27a 	srli	r3,r2,9
   158c8:	01400104 	movi	r5,4
   158cc:	28c0432e 	bgeu	r5,r3,159dc <_malloc_r+0x5f4>
   158d0:	01400504 	movi	r5,20
   158d4:	28c07036 	bltu	r5,r3,15a98 <_malloc_r+0x6b0>
   158d8:	194016c4 	addi	r5,r3,91
   158dc:	294d883a 	add	r6,r5,r5
   158e0:	318d883a 	add	r6,r6,r6
   158e4:	318d883a 	add	r6,r6,r6
   158e8:	998d883a 	add	r6,r19,r6
   158ec:	30c00217 	ldw	r3,8(r6)
   158f0:	01c000b4 	movhi	r7,2
   158f4:	39df2904 	addi	r7,r7,31908
   158f8:	19805726 	beq	r3,r6,15a58 <_malloc_r+0x670>
   158fc:	01ffff04 	movi	r7,-4
   15900:	19400117 	ldw	r5,4(r3)
   15904:	29ca703a 	and	r5,r5,r7
   15908:	1140022e 	bgeu	r2,r5,15914 <_malloc_r+0x52c>
   1590c:	18c00217 	ldw	r3,8(r3)
   15910:	30fffb1e 	bne	r6,r3,15900 <_malloc_r+0x518>
   15914:	19400317 	ldw	r5,12(r3)
   15918:	98800117 	ldw	r2,4(r19)
   1591c:	81400315 	stw	r5,12(r16)
   15920:	80c00215 	stw	r3,8(r16)
   15924:	2c000215 	stw	r16,8(r5)
   15928:	1c000315 	stw	r16,12(r3)
   1592c:	003f2b06 	br	155dc <_malloc_r+0x1f4>
   15930:	8445883a 	add	r2,r16,r17
   15934:	8c400054 	ori	r17,r17,1
   15938:	18800515 	stw	r2,20(r3)
   1593c:	18800415 	stw	r2,16(r3)
   15940:	29000054 	ori	r4,r5,1
   15944:	1147883a 	add	r3,r2,r5
   15948:	84400115 	stw	r17,4(r16)
   1594c:	11000115 	stw	r4,4(r2)
   15950:	12400315 	stw	r9,12(r2)
   15954:	12400215 	stw	r9,8(r2)
   15958:	19400015 	stw	r5,0(r3)
   1595c:	9009883a 	mov	r4,r18
   15960:	0018fc80 	call	18fc8 <__malloc_unlock>
   15964:	80800204 	addi	r2,r16,8
   15968:	003ecd06 	br	154a0 <_malloc_r+0xb8>
   1596c:	18800117 	ldw	r2,4(r3)
   15970:	003f1a06 	br	155dc <_malloc_r+0x1f4>
   15974:	5ac00044 	addi	r11,r11,1
   15978:	588000cc 	andi	r2,r11,3
   1597c:	52800204 	addi	r10,r10,8
   15980:	103f2e1e 	bne	r2,zero,1563c <_malloc_r+0x254>
   15984:	20c000cc 	andi	r3,r4,3
   15988:	60bffe04 	addi	r2,r12,-8
   1598c:	18006f26 	beq	r3,zero,15b4c <_malloc_r+0x764>
   15990:	63000017 	ldw	r12,0(r12)
   15994:	213fffc4 	addi	r4,r4,-1
   15998:	60bffa26 	beq	r12,r2,15984 <_malloc_r+0x59c>
   1599c:	98800117 	ldw	r2,4(r19)
   159a0:	294b883a 	add	r5,r5,r5
   159a4:	117f5a36 	bltu	r2,r5,15710 <_malloc_r+0x328>
   159a8:	283f5926 	beq	r5,zero,15710 <_malloc_r+0x328>
   159ac:	1146703a 	and	r3,r2,r5
   159b0:	18001626 	beq	r3,zero,15a0c <_malloc_r+0x624>
   159b4:	5809883a 	mov	r4,r11
   159b8:	003f1a06 	br	15624 <_malloc_r+0x23c>
   159bc:	80800204 	addi	r2,r16,8
   159c0:	84000517 	ldw	r16,20(r16)
   159c4:	143ea81e 	bne	r2,r16,15468 <_malloc_r+0x80>
   159c8:	21000084 	addi	r4,r4,2
   159cc:	003ee306 	br	1555c <_malloc_r+0x174>
   159d0:	210016c4 	addi	r4,r4,91
   159d4:	210b883a 	add	r5,r4,r4
   159d8:	003eca06 	br	15504 <_malloc_r+0x11c>
   159dc:	100ad1ba 	srli	r5,r2,6
   159e0:	29400e04 	addi	r5,r5,56
   159e4:	294d883a 	add	r6,r5,r5
   159e8:	003fbd06 	br	158e0 <_malloc_r+0x4f8>
   159ec:	84ff6026 	beq	r16,r19,15770 <_malloc_r+0x388>
   159f0:	008000b4 	movhi	r2,2
   159f4:	109f2904 	addi	r2,r2,31908
   159f8:	14000217 	ldw	r16,8(r2)
   159fc:	00bfff04 	movi	r2,-4
   15a00:	80c00117 	ldw	r3,4(r16)
   15a04:	1886703a 	and	r3,r3,r2
   15a08:	003f9406 	br	1585c <_malloc_r+0x474>
   15a0c:	294b883a 	add	r5,r5,r5
   15a10:	1146703a 	and	r3,r2,r5
   15a14:	5ac00104 	addi	r11,r11,4
   15a18:	183ffc26 	beq	r3,zero,15a0c <_malloc_r+0x624>
   15a1c:	5809883a 	mov	r4,r11
   15a20:	003f0006 	br	15624 <_malloc_r+0x23c>
   15a24:	00805504 	movi	r2,340
   15a28:	11001336 	bltu	r2,r4,15a78 <_malloc_r+0x690>
   15a2c:	8808d3fa 	srli	r4,r17,15
   15a30:	21001dc4 	addi	r4,r4,119
   15a34:	210b883a 	add	r5,r4,r4
   15a38:	003eb206 	br	15504 <_malloc_r+0x11c>
   15a3c:	00840004 	movi	r2,4096
   15a40:	003f5d06 	br	157b8 <_malloc_r+0x3d0>
   15a44:	00800044 	movi	r2,1
   15a48:	a0800115 	stw	r2,4(r20)
   15a4c:	a021883a 	mov	r16,r20
   15a50:	0007883a 	mov	r3,zero
   15a54:	003f8106 	br	1585c <_malloc_r+0x474>
   15a58:	280bd0ba 	srai	r5,r5,2
   15a5c:	01800044 	movi	r6,1
   15a60:	38800117 	ldw	r2,4(r7)
   15a64:	314c983a 	sll	r6,r6,r5
   15a68:	180b883a 	mov	r5,r3
   15a6c:	3084b03a 	or	r2,r6,r2
   15a70:	38800115 	stw	r2,4(r7)
   15a74:	003fa906 	br	1591c <_malloc_r+0x534>
   15a78:	00815504 	movi	r2,1364
   15a7c:	11001836 	bltu	r2,r4,15ae0 <_malloc_r+0x6f8>
   15a80:	8808d4ba 	srli	r4,r17,18
   15a84:	21001f04 	addi	r4,r4,124
   15a88:	210b883a 	add	r5,r4,r4
   15a8c:	003e9d06 	br	15504 <_malloc_r+0x11c>
   15a90:	bdc00404 	addi	r23,r23,16
   15a94:	003f2f06 	br	15754 <_malloc_r+0x36c>
   15a98:	01401504 	movi	r5,84
   15a9c:	28c01f36 	bltu	r5,r3,15b1c <_malloc_r+0x734>
   15aa0:	100ad33a 	srli	r5,r2,12
   15aa4:	29401b84 	addi	r5,r5,110
   15aa8:	294d883a 	add	r6,r5,r5
   15aac:	003f8c06 	br	158e0 <_malloc_r+0x4f8>
   15ab0:	9c000217 	ldw	r16,8(r19)
   15ab4:	00bfff04 	movi	r2,-4
   15ab8:	80c00117 	ldw	r3,4(r16)
   15abc:	1886703a 	and	r3,r3,r2
   15ac0:	003f6606 	br	1585c <_malloc_r+0x474>
   15ac4:	e0c3ffcc 	andi	r3,fp,4095
   15ac8:	183f2f1e 	bne	r3,zero,15788 <_malloc_r+0x3a0>
   15acc:	98c00217 	ldw	r3,8(r19)
   15ad0:	bd49883a 	add	r4,r23,r21
   15ad4:	21000054 	ori	r4,r4,1
   15ad8:	19000115 	stw	r4,4(r3)
   15adc:	003f5506 	br	15834 <_malloc_r+0x44c>
   15ae0:	01403f04 	movi	r5,252
   15ae4:	01001f84 	movi	r4,126
   15ae8:	003e8606 	br	15504 <_malloc_r+0x11c>
   15aec:	9009883a 	mov	r4,r18
   15af0:	81400204 	addi	r5,r16,8
   15af4:	00148500 	call	14850 <_free_r>
   15af8:	00800134 	movhi	r2,4
   15afc:	10a7fc04 	addi	r2,r2,-24592
   15b00:	10800017 	ldw	r2,0(r2)
   15b04:	003f4b06 	br	15834 <_malloc_r+0x44c>
   15b08:	00c00044 	movi	r3,1
   15b0c:	002f883a 	mov	r23,zero
   15b10:	003f3406 	br	157e4 <_malloc_r+0x3fc>
   15b14:	d5200f15 	stw	r20,-32708(gp)
   15b18:	003f2106 	br	157a0 <_malloc_r+0x3b8>
   15b1c:	01405504 	movi	r5,340
   15b20:	28c00436 	bltu	r5,r3,15b34 <_malloc_r+0x74c>
   15b24:	100ad3fa 	srli	r5,r2,15
   15b28:	29401dc4 	addi	r5,r5,119
   15b2c:	294d883a 	add	r6,r5,r5
   15b30:	003f6b06 	br	158e0 <_malloc_r+0x4f8>
   15b34:	01415504 	movi	r5,1364
   15b38:	28c00936 	bltu	r5,r3,15b60 <_malloc_r+0x778>
   15b3c:	100ad4ba 	srli	r5,r2,18
   15b40:	29401f04 	addi	r5,r5,124
   15b44:	294d883a 	add	r6,r5,r5
   15b48:	003f6506 	br	158e0 <_malloc_r+0x4f8>
   15b4c:	98800117 	ldw	r2,4(r19)
   15b50:	0146303a 	nor	r3,zero,r5
   15b54:	1884703a 	and	r2,r3,r2
   15b58:	98800115 	stw	r2,4(r19)
   15b5c:	003f9006 	br	159a0 <_malloc_r+0x5b8>
   15b60:	01803f04 	movi	r6,252
   15b64:	01401f84 	movi	r5,126
   15b68:	003f5d06 	br	158e0 <_malloc_r+0x4f8>

00015b6c <memchr>:
   15b6c:	008000c4 	movi	r2,3
   15b70:	29403fcc 	andi	r5,r5,255
   15b74:	1180282e 	bgeu	r2,r6,15c18 <memchr+0xac>
   15b78:	2086703a 	and	r3,r4,r2
   15b7c:	1800351e 	bne	r3,zero,15c54 <memchr+0xe8>
   15b80:	2816923a 	slli	r11,r5,8
   15b84:	2093883a 	add	r9,r4,r2
   15b88:	22000084 	addi	r8,r4,2
   15b8c:	5957883a 	add	r11,r11,r5
   15b90:	5816923a 	slli	r11,r11,8
   15b94:	20c00044 	addi	r3,r4,1
   15b98:	037fbff4 	movhi	r13,65279
   15b9c:	6b7fbfc4 	addi	r13,r13,-257
   15ba0:	5957883a 	add	r11,r11,r5
   15ba4:	5816923a 	slli	r11,r11,8
   15ba8:	03202074 	movhi	r12,32897
   15bac:	63202004 	addi	r12,r12,-32640
   15bb0:	101d883a 	mov	r14,r2
   15bb4:	5957883a 	add	r11,r11,r5
   15bb8:	21c00017 	ldw	r7,0(r4)
   15bbc:	31bfff04 	addi	r6,r6,-4
   15bc0:	1805883a 	mov	r2,r3
   15bc4:	3acef03a 	xor	r7,r7,r11
   15bc8:	3b55883a 	add	r10,r7,r13
   15bcc:	01ce303a 	nor	r7,zero,r7
   15bd0:	51ce703a 	and	r7,r10,r7
   15bd4:	3b0e703a 	and	r7,r7,r12
   15bd8:	38000a26 	beq	r7,zero,15c04 <memchr+0x98>
   15bdc:	21c00003 	ldbu	r7,0(r4)
   15be0:	39401e26 	beq	r7,r5,15c5c <memchr+0xf0>
   15be4:	19c00003 	ldbu	r7,0(r3)
   15be8:	39401926 	beq	r7,r5,15c50 <memchr+0xe4>
   15bec:	41c00003 	ldbu	r7,0(r8)
   15bf0:	4005883a 	mov	r2,r8
   15bf4:	39401626 	beq	r7,r5,15c50 <memchr+0xe4>
   15bf8:	49c00003 	ldbu	r7,0(r9)
   15bfc:	4805883a 	mov	r2,r9
   15c00:	39401326 	beq	r7,r5,15c50 <memchr+0xe4>
   15c04:	21000104 	addi	r4,r4,4
   15c08:	4a400104 	addi	r9,r9,4
   15c0c:	42000104 	addi	r8,r8,4
   15c10:	18c00104 	addi	r3,r3,4
   15c14:	71bfe836 	bltu	r14,r6,15bb8 <memchr+0x4c>
   15c18:	2005883a 	mov	r2,r4
   15c1c:	30000a26 	beq	r6,zero,15c48 <memchr+0xdc>
   15c20:	10c00003 	ldbu	r3,0(r2)
   15c24:	19400a26 	beq	r3,r5,15c50 <memchr+0xe4>
   15c28:	10c00044 	addi	r3,r2,1
   15c2c:	118d883a 	add	r6,r2,r6
   15c30:	00000306 	br	15c40 <memchr+0xd4>
   15c34:	11000003 	ldbu	r4,0(r2)
   15c38:	18c00044 	addi	r3,r3,1
   15c3c:	21400426 	beq	r4,r5,15c50 <memchr+0xe4>
   15c40:	1805883a 	mov	r2,r3
   15c44:	19bffb1e 	bne	r3,r6,15c34 <memchr+0xc8>
   15c48:	0005883a 	mov	r2,zero
   15c4c:	f800283a 	ret
   15c50:	f800283a 	ret
   15c54:	2005883a 	mov	r2,r4
   15c58:	003ff106 	br	15c20 <memchr+0xb4>
   15c5c:	2005883a 	mov	r2,r4
   15c60:	f800283a 	ret

00015c64 <memmove>:
   15c64:	2005883a 	mov	r2,r4
   15c68:	300f883a 	mov	r7,r6
   15c6c:	29000b2e 	bgeu	r5,r4,15c9c <memmove+0x38>
   15c70:	2987883a 	add	r3,r5,r6
   15c74:	20c0092e 	bgeu	r4,r3,15c9c <memmove+0x38>
   15c78:	218b883a 	add	r5,r4,r6
   15c7c:	198fc83a 	sub	r7,r3,r6
   15c80:	30003f26 	beq	r6,zero,15d80 <memmove+0x11c>
   15c84:	18ffffc4 	addi	r3,r3,-1
   15c88:	19000003 	ldbu	r4,0(r3)
   15c8c:	297fffc4 	addi	r5,r5,-1
   15c90:	29000005 	stb	r4,0(r5)
   15c94:	19fffb1e 	bne	r3,r7,15c84 <memmove+0x20>
   15c98:	f800283a 	ret
   15c9c:	00c003c4 	movi	r3,15
   15ca0:	1980382e 	bgeu	r3,r6,15d84 <memmove+0x120>
   15ca4:	2886b03a 	or	r3,r5,r2
   15ca8:	18c000cc 	andi	r3,r3,3
   15cac:	1800351e 	bne	r3,zero,15d84 <memmove+0x120>
   15cb0:	327ffc04 	addi	r9,r6,-16
   15cb4:	4812d13a 	srli	r9,r9,4
   15cb8:	12000404 	addi	r8,r2,16
   15cbc:	1007883a 	mov	r3,r2
   15cc0:	4808913a 	slli	r4,r9,4
   15cc4:	280f883a 	mov	r7,r5
   15cc8:	4111883a 	add	r8,r8,r4
   15ccc:	39000017 	ldw	r4,0(r7)
   15cd0:	18c00404 	addi	r3,r3,16
   15cd4:	39c00404 	addi	r7,r7,16
   15cd8:	193ffc15 	stw	r4,-16(r3)
   15cdc:	393ffd17 	ldw	r4,-12(r7)
   15ce0:	193ffd15 	stw	r4,-12(r3)
   15ce4:	393ffe17 	ldw	r4,-8(r7)
   15ce8:	193ffe15 	stw	r4,-8(r3)
   15cec:	393fff17 	ldw	r4,-4(r7)
   15cf0:	193fff15 	stw	r4,-4(r3)
   15cf4:	1a3ff51e 	bne	r3,r8,15ccc <memmove+0x68>
   15cf8:	49000044 	addi	r4,r9,1
   15cfc:	2008913a 	slli	r4,r4,4
   15d00:	31c003cc 	andi	r7,r6,15
   15d04:	1107883a 	add	r3,r2,r4
   15d08:	290b883a 	add	r5,r5,r4
   15d0c:	010000c4 	movi	r4,3
   15d10:	21c0142e 	bgeu	r4,r7,15d64 <memmove+0x100>
   15d14:	39ffff04 	addi	r7,r7,-4
   15d18:	3814d0ba 	srli	r10,r7,2
   15d1c:	1a400104 	addi	r9,r3,4
   15d20:	180d883a 	mov	r6,r3
   15d24:	5289883a 	add	r4,r10,r10
   15d28:	2109883a 	add	r4,r4,r4
   15d2c:	4913883a 	add	r9,r9,r4
   15d30:	2809883a 	mov	r4,r5
   15d34:	22000017 	ldw	r8,0(r4)
   15d38:	31800104 	addi	r6,r6,4
   15d3c:	21000104 	addi	r4,r4,4
   15d40:	323fff15 	stw	r8,-4(r6)
   15d44:	327ffb1e 	bne	r6,r9,15d34 <memmove+0xd0>
   15d48:	51000044 	addi	r4,r10,1
   15d4c:	52bfff24 	muli	r10,r10,-4
   15d50:	2109883a 	add	r4,r4,r4
   15d54:	2109883a 	add	r4,r4,r4
   15d58:	51cf883a 	add	r7,r10,r7
   15d5c:	290b883a 	add	r5,r5,r4
   15d60:	1907883a 	add	r3,r3,r4
   15d64:	38000626 	beq	r7,zero,15d80 <memmove+0x11c>
   15d68:	19cf883a 	add	r7,r3,r7
   15d6c:	29800003 	ldbu	r6,0(r5)
   15d70:	18c00044 	addi	r3,r3,1
   15d74:	29400044 	addi	r5,r5,1
   15d78:	19bfffc5 	stb	r6,-1(r3)
   15d7c:	19fffb1e 	bne	r3,r7,15d6c <memmove+0x108>
   15d80:	f800283a 	ret
   15d84:	1007883a 	mov	r3,r2
   15d88:	003ff606 	br	15d64 <memmove+0x100>

00015d8c <_Balloc>:
   15d8c:	20801317 	ldw	r2,76(r4)
   15d90:	defffc04 	addi	sp,sp,-16
   15d94:	dc400115 	stw	r17,4(sp)
   15d98:	dc000015 	stw	r16,0(sp)
   15d9c:	dfc00315 	stw	ra,12(sp)
   15da0:	dc800215 	stw	r18,8(sp)
   15da4:	2023883a 	mov	r17,r4
   15da8:	2821883a 	mov	r16,r5
   15dac:	10000f26 	beq	r2,zero,15dec <_Balloc+0x60>
   15db0:	8407883a 	add	r3,r16,r16
   15db4:	18c7883a 	add	r3,r3,r3
   15db8:	10c7883a 	add	r3,r2,r3
   15dbc:	18800017 	ldw	r2,0(r3)
   15dc0:	10001126 	beq	r2,zero,15e08 <_Balloc+0x7c>
   15dc4:	11000017 	ldw	r4,0(r2)
   15dc8:	19000015 	stw	r4,0(r3)
   15dcc:	10000415 	stw	zero,16(r2)
   15dd0:	10000315 	stw	zero,12(r2)
   15dd4:	dfc00317 	ldw	ra,12(sp)
   15dd8:	dc800217 	ldw	r18,8(sp)
   15ddc:	dc400117 	ldw	r17,4(sp)
   15de0:	dc000017 	ldw	r16,0(sp)
   15de4:	dec00404 	addi	sp,sp,16
   15de8:	f800283a 	ret
   15dec:	01400104 	movi	r5,4
   15df0:	01800404 	movi	r6,16
   15df4:	00175a40 	call	175a4 <_calloc_r>
   15df8:	88801315 	stw	r2,76(r17)
   15dfc:	103fec1e 	bne	r2,zero,15db0 <_Balloc+0x24>
   15e00:	0005883a 	mov	r2,zero
   15e04:	003ff306 	br	15dd4 <_Balloc+0x48>
   15e08:	01400044 	movi	r5,1
   15e0c:	2c24983a 	sll	r18,r5,r16
   15e10:	8809883a 	mov	r4,r17
   15e14:	91800144 	addi	r6,r18,5
   15e18:	318d883a 	add	r6,r6,r6
   15e1c:	318d883a 	add	r6,r6,r6
   15e20:	00175a40 	call	175a4 <_calloc_r>
   15e24:	103ff626 	beq	r2,zero,15e00 <_Balloc+0x74>
   15e28:	14000115 	stw	r16,4(r2)
   15e2c:	14800215 	stw	r18,8(r2)
   15e30:	003fe606 	br	15dcc <_Balloc+0x40>

00015e34 <_Bfree>:
   15e34:	28000826 	beq	r5,zero,15e58 <_Bfree+0x24>
   15e38:	28c00117 	ldw	r3,4(r5)
   15e3c:	20801317 	ldw	r2,76(r4)
   15e40:	18c7883a 	add	r3,r3,r3
   15e44:	18c7883a 	add	r3,r3,r3
   15e48:	10c5883a 	add	r2,r2,r3
   15e4c:	10c00017 	ldw	r3,0(r2)
   15e50:	28c00015 	stw	r3,0(r5)
   15e54:	11400015 	stw	r5,0(r2)
   15e58:	f800283a 	ret

00015e5c <__multadd>:
   15e5c:	defffa04 	addi	sp,sp,-24
   15e60:	dc000115 	stw	r16,4(sp)
   15e64:	2c000417 	ldw	r16,16(r5)
   15e68:	dc800315 	stw	r18,12(sp)
   15e6c:	dc400215 	stw	r17,8(sp)
   15e70:	dfc00515 	stw	ra,20(sp)
   15e74:	dcc00415 	stw	r19,16(sp)
   15e78:	2823883a 	mov	r17,r5
   15e7c:	2025883a 	mov	r18,r4
   15e80:	28c00504 	addi	r3,r5,20
   15e84:	0011883a 	mov	r8,zero
   15e88:	1a800017 	ldw	r10,0(r3)
   15e8c:	18c00104 	addi	r3,r3,4
   15e90:	42000044 	addi	r8,r8,1
   15e94:	527fffcc 	andi	r9,r10,65535
   15e98:	4993383a 	mul	r9,r9,r6
   15e9c:	5014d43a 	srli	r10,r10,16
   15ea0:	49d3883a 	add	r9,r9,r7
   15ea4:	480ed43a 	srli	r7,r9,16
   15ea8:	5195383a 	mul	r10,r10,r6
   15eac:	4a7fffcc 	andi	r9,r9,65535
   15eb0:	3a8f883a 	add	r7,r7,r10
   15eb4:	3814943a 	slli	r10,r7,16
   15eb8:	380ed43a 	srli	r7,r7,16
   15ebc:	5253883a 	add	r9,r10,r9
   15ec0:	1a7fff15 	stw	r9,-4(r3)
   15ec4:	443ff016 	blt	r8,r16,15e88 <__multadd+0x2c>
   15ec8:	38000926 	beq	r7,zero,15ef0 <__multadd+0x94>
   15ecc:	88800217 	ldw	r2,8(r17)
   15ed0:	80800f0e 	bge	r16,r2,15f10 <__multadd+0xb4>
   15ed4:	80800144 	addi	r2,r16,5
   15ed8:	1085883a 	add	r2,r2,r2
   15edc:	1085883a 	add	r2,r2,r2
   15ee0:	8885883a 	add	r2,r17,r2
   15ee4:	84000044 	addi	r16,r16,1
   15ee8:	11c00015 	stw	r7,0(r2)
   15eec:	8c000415 	stw	r16,16(r17)
   15ef0:	8805883a 	mov	r2,r17
   15ef4:	dfc00517 	ldw	ra,20(sp)
   15ef8:	dcc00417 	ldw	r19,16(sp)
   15efc:	dc800317 	ldw	r18,12(sp)
   15f00:	dc400217 	ldw	r17,8(sp)
   15f04:	dc000117 	ldw	r16,4(sp)
   15f08:	dec00604 	addi	sp,sp,24
   15f0c:	f800283a 	ret
   15f10:	89400117 	ldw	r5,4(r17)
   15f14:	9009883a 	mov	r4,r18
   15f18:	d9c00015 	stw	r7,0(sp)
   15f1c:	29400044 	addi	r5,r5,1
   15f20:	0015d8c0 	call	15d8c <_Balloc>
   15f24:	89800417 	ldw	r6,16(r17)
   15f28:	89400304 	addi	r5,r17,12
   15f2c:	11000304 	addi	r4,r2,12
   15f30:	31800084 	addi	r6,r6,2
   15f34:	318d883a 	add	r6,r6,r6
   15f38:	318d883a 	add	r6,r6,r6
   15f3c:	1027883a 	mov	r19,r2
   15f40:	00102380 	call	10238 <memcpy>
   15f44:	88c00117 	ldw	r3,4(r17)
   15f48:	90801317 	ldw	r2,76(r18)
   15f4c:	d9c00017 	ldw	r7,0(sp)
   15f50:	18c7883a 	add	r3,r3,r3
   15f54:	18c7883a 	add	r3,r3,r3
   15f58:	10c5883a 	add	r2,r2,r3
   15f5c:	10c00017 	ldw	r3,0(r2)
   15f60:	88c00015 	stw	r3,0(r17)
   15f64:	14400015 	stw	r17,0(r2)
   15f68:	9823883a 	mov	r17,r19
   15f6c:	003fd906 	br	15ed4 <__multadd+0x78>

00015f70 <__s2b>:
   15f70:	defff904 	addi	sp,sp,-28
   15f74:	dd000415 	stw	r20,16(sp)
   15f78:	dc400115 	stw	r17,4(sp)
   15f7c:	2829883a 	mov	r20,r5
   15f80:	2023883a 	mov	r17,r4
   15f84:	01400244 	movi	r5,9
   15f88:	39000204 	addi	r4,r7,8
   15f8c:	dcc00315 	stw	r19,12(sp)
   15f90:	dc800215 	stw	r18,8(sp)
   15f94:	dfc00615 	stw	ra,24(sp)
   15f98:	dd400515 	stw	r21,20(sp)
   15f9c:	dc000015 	stw	r16,0(sp)
   15fa0:	3825883a 	mov	r18,r7
   15fa4:	3027883a 	mov	r19,r6
   15fa8:	00187cc0 	call	187cc <__divsi3>
   15fac:	00c00044 	movi	r3,1
   15fb0:	000b883a 	mov	r5,zero
   15fb4:	1880030e 	bge	r3,r2,15fc4 <__s2b+0x54>
   15fb8:	18c7883a 	add	r3,r3,r3
   15fbc:	29400044 	addi	r5,r5,1
   15fc0:	18bffd16 	blt	r3,r2,15fb8 <__s2b+0x48>
   15fc4:	8809883a 	mov	r4,r17
   15fc8:	0015d8c0 	call	15d8c <_Balloc>
   15fcc:	d8c00717 	ldw	r3,28(sp)
   15fd0:	10c00515 	stw	r3,20(r2)
   15fd4:	00c00044 	movi	r3,1
   15fd8:	10c00415 	stw	r3,16(r2)
   15fdc:	00c00244 	movi	r3,9
   15fe0:	1cc0210e 	bge	r3,r19,16068 <__s2b+0xf8>
   15fe4:	a0eb883a 	add	r21,r20,r3
   15fe8:	a821883a 	mov	r16,r21
   15fec:	a4e9883a 	add	r20,r20,r19
   15ff0:	81c00007 	ldb	r7,0(r16)
   15ff4:	8809883a 	mov	r4,r17
   15ff8:	84000044 	addi	r16,r16,1
   15ffc:	100b883a 	mov	r5,r2
   16000:	01800284 	movi	r6,10
   16004:	39fff404 	addi	r7,r7,-48
   16008:	0015e5c0 	call	15e5c <__multadd>
   1600c:	853ff81e 	bne	r16,r20,15ff0 <__s2b+0x80>
   16010:	ace1883a 	add	r16,r21,r19
   16014:	843ffe04 	addi	r16,r16,-8
   16018:	9c800a0e 	bge	r19,r18,16044 <__s2b+0xd4>
   1601c:	94e5c83a 	sub	r18,r18,r19
   16020:	84a5883a 	add	r18,r16,r18
   16024:	81c00007 	ldb	r7,0(r16)
   16028:	8809883a 	mov	r4,r17
   1602c:	84000044 	addi	r16,r16,1
   16030:	100b883a 	mov	r5,r2
   16034:	01800284 	movi	r6,10
   16038:	39fff404 	addi	r7,r7,-48
   1603c:	0015e5c0 	call	15e5c <__multadd>
   16040:	84bff81e 	bne	r16,r18,16024 <__s2b+0xb4>
   16044:	dfc00617 	ldw	ra,24(sp)
   16048:	dd400517 	ldw	r21,20(sp)
   1604c:	dd000417 	ldw	r20,16(sp)
   16050:	dcc00317 	ldw	r19,12(sp)
   16054:	dc800217 	ldw	r18,8(sp)
   16058:	dc400117 	ldw	r17,4(sp)
   1605c:	dc000017 	ldw	r16,0(sp)
   16060:	dec00704 	addi	sp,sp,28
   16064:	f800283a 	ret
   16068:	a4000284 	addi	r16,r20,10
   1606c:	1827883a 	mov	r19,r3
   16070:	003fe906 	br	16018 <__s2b+0xa8>

00016074 <__hi0bits>:
   16074:	20bfffec 	andhi	r2,r4,65535
   16078:	1000141e 	bne	r2,zero,160cc <__hi0bits+0x58>
   1607c:	2008943a 	slli	r4,r4,16
   16080:	00800404 	movi	r2,16
   16084:	20ffc02c 	andhi	r3,r4,65280
   16088:	1800021e 	bne	r3,zero,16094 <__hi0bits+0x20>
   1608c:	2008923a 	slli	r4,r4,8
   16090:	10800204 	addi	r2,r2,8
   16094:	20fc002c 	andhi	r3,r4,61440
   16098:	1800021e 	bne	r3,zero,160a4 <__hi0bits+0x30>
   1609c:	2008913a 	slli	r4,r4,4
   160a0:	10800104 	addi	r2,r2,4
   160a4:	20f0002c 	andhi	r3,r4,49152
   160a8:	1800031e 	bne	r3,zero,160b8 <__hi0bits+0x44>
   160ac:	2109883a 	add	r4,r4,r4
   160b0:	10800084 	addi	r2,r2,2
   160b4:	2109883a 	add	r4,r4,r4
   160b8:	20000316 	blt	r4,zero,160c8 <__hi0bits+0x54>
   160bc:	2110002c 	andhi	r4,r4,16384
   160c0:	2000041e 	bne	r4,zero,160d4 <__hi0bits+0x60>
   160c4:	00800804 	movi	r2,32
   160c8:	f800283a 	ret
   160cc:	0005883a 	mov	r2,zero
   160d0:	003fec06 	br	16084 <__hi0bits+0x10>
   160d4:	10800044 	addi	r2,r2,1
   160d8:	f800283a 	ret

000160dc <__lo0bits>:
   160dc:	20c00017 	ldw	r3,0(r4)
   160e0:	188001cc 	andi	r2,r3,7
   160e4:	10000826 	beq	r2,zero,16108 <__lo0bits+0x2c>
   160e8:	1880004c 	andi	r2,r3,1
   160ec:	1000211e 	bne	r2,zero,16174 <__lo0bits+0x98>
   160f0:	1880008c 	andi	r2,r3,2
   160f4:	1000211e 	bne	r2,zero,1617c <__lo0bits+0xa0>
   160f8:	1806d0ba 	srli	r3,r3,2
   160fc:	00800084 	movi	r2,2
   16100:	20c00015 	stw	r3,0(r4)
   16104:	f800283a 	ret
   16108:	18bfffcc 	andi	r2,r3,65535
   1610c:	10001326 	beq	r2,zero,1615c <__lo0bits+0x80>
   16110:	0005883a 	mov	r2,zero
   16114:	19403fcc 	andi	r5,r3,255
   16118:	2800021e 	bne	r5,zero,16124 <__lo0bits+0x48>
   1611c:	1806d23a 	srli	r3,r3,8
   16120:	10800204 	addi	r2,r2,8
   16124:	194003cc 	andi	r5,r3,15
   16128:	2800021e 	bne	r5,zero,16134 <__lo0bits+0x58>
   1612c:	1806d13a 	srli	r3,r3,4
   16130:	10800104 	addi	r2,r2,4
   16134:	194000cc 	andi	r5,r3,3
   16138:	2800021e 	bne	r5,zero,16144 <__lo0bits+0x68>
   1613c:	1806d0ba 	srli	r3,r3,2
   16140:	10800084 	addi	r2,r2,2
   16144:	1940004c 	andi	r5,r3,1
   16148:	2800081e 	bne	r5,zero,1616c <__lo0bits+0x90>
   1614c:	1806d07a 	srli	r3,r3,1
   16150:	1800051e 	bne	r3,zero,16168 <__lo0bits+0x8c>
   16154:	00800804 	movi	r2,32
   16158:	f800283a 	ret
   1615c:	1806d43a 	srli	r3,r3,16
   16160:	00800404 	movi	r2,16
   16164:	003feb06 	br	16114 <__lo0bits+0x38>
   16168:	10800044 	addi	r2,r2,1
   1616c:	20c00015 	stw	r3,0(r4)
   16170:	f800283a 	ret
   16174:	0005883a 	mov	r2,zero
   16178:	f800283a 	ret
   1617c:	1806d07a 	srli	r3,r3,1
   16180:	00800044 	movi	r2,1
   16184:	20c00015 	stw	r3,0(r4)
   16188:	f800283a 	ret

0001618c <__i2b>:
   1618c:	defffd04 	addi	sp,sp,-12
   16190:	dc000015 	stw	r16,0(sp)
   16194:	04000044 	movi	r16,1
   16198:	dc400115 	stw	r17,4(sp)
   1619c:	2823883a 	mov	r17,r5
   161a0:	800b883a 	mov	r5,r16
   161a4:	dfc00215 	stw	ra,8(sp)
   161a8:	0015d8c0 	call	15d8c <_Balloc>
   161ac:	14400515 	stw	r17,20(r2)
   161b0:	14000415 	stw	r16,16(r2)
   161b4:	dfc00217 	ldw	ra,8(sp)
   161b8:	dc400117 	ldw	r17,4(sp)
   161bc:	dc000017 	ldw	r16,0(sp)
   161c0:	dec00304 	addi	sp,sp,12
   161c4:	f800283a 	ret

000161c8 <__multiply>:
   161c8:	defffa04 	addi	sp,sp,-24
   161cc:	dcc00315 	stw	r19,12(sp)
   161d0:	dc400115 	stw	r17,4(sp)
   161d4:	34c00417 	ldw	r19,16(r6)
   161d8:	2c400417 	ldw	r17,16(r5)
   161dc:	dd000415 	stw	r20,16(sp)
   161e0:	dc800215 	stw	r18,8(sp)
   161e4:	dfc00515 	stw	ra,20(sp)
   161e8:	dc000015 	stw	r16,0(sp)
   161ec:	2825883a 	mov	r18,r5
   161f0:	3029883a 	mov	r20,r6
   161f4:	8cc0050e 	bge	r17,r19,1620c <__multiply+0x44>
   161f8:	8807883a 	mov	r3,r17
   161fc:	3025883a 	mov	r18,r6
   16200:	9823883a 	mov	r17,r19
   16204:	2829883a 	mov	r20,r5
   16208:	1827883a 	mov	r19,r3
   1620c:	90800217 	ldw	r2,8(r18)
   16210:	8ce1883a 	add	r16,r17,r19
   16214:	91400117 	ldw	r5,4(r18)
   16218:	1400010e 	bge	r2,r16,16220 <__multiply+0x58>
   1621c:	29400044 	addi	r5,r5,1
   16220:	0015d8c0 	call	15d8c <_Balloc>
   16224:	83c00144 	addi	r15,r16,5
   16228:	7bdf883a 	add	r15,r15,r15
   1622c:	7bdf883a 	add	r15,r15,r15
   16230:	13800504 	addi	r14,r2,20
   16234:	13df883a 	add	r15,r2,r15
   16238:	7007883a 	mov	r3,r14
   1623c:	73c0032e 	bgeu	r14,r15,1624c <__multiply+0x84>
   16240:	18000015 	stw	zero,0(r3)
   16244:	18c00104 	addi	r3,r3,4
   16248:	1bfffd36 	bltu	r3,r15,16240 <__multiply+0x78>
   1624c:	99800144 	addi	r6,r19,5
   16250:	8b000144 	addi	r12,r17,5
   16254:	318d883a 	add	r6,r6,r6
   16258:	6319883a 	add	r12,r12,r12
   1625c:	318d883a 	add	r6,r6,r6
   16260:	6319883a 	add	r12,r12,r12
   16264:	a3400504 	addi	r13,r20,20
   16268:	a18d883a 	add	r6,r20,r6
   1626c:	94400504 	addi	r17,r18,20
   16270:	9319883a 	add	r12,r18,r12
   16274:	6980392e 	bgeu	r13,r6,1635c <__multiply+0x194>
   16278:	6a800017 	ldw	r10,0(r13)
   1627c:	52ffffcc 	andi	r11,r10,65535
   16280:	58001826 	beq	r11,zero,162e4 <__multiply+0x11c>
   16284:	7007883a 	mov	r3,r14
   16288:	8809883a 	mov	r4,r17
   1628c:	000b883a 	mov	r5,zero
   16290:	22400017 	ldw	r9,0(r4)
   16294:	1a000017 	ldw	r8,0(r3)
   16298:	21000104 	addi	r4,r4,4
   1629c:	49ffffcc 	andi	r7,r9,65535
   162a0:	3acf383a 	mul	r7,r7,r11
   162a4:	4812d43a 	srli	r9,r9,16
   162a8:	42bfffcc 	andi	r10,r8,65535
   162ac:	3a8f883a 	add	r7,r7,r10
   162b0:	394f883a 	add	r7,r7,r5
   162b4:	4010d43a 	srli	r8,r8,16
   162b8:	4acb383a 	mul	r5,r9,r11
   162bc:	3814d43a 	srli	r10,r7,16
   162c0:	19c0000d 	sth	r7,0(r3)
   162c4:	2a0b883a 	add	r5,r5,r8
   162c8:	2a8b883a 	add	r5,r5,r10
   162cc:	1940008d 	sth	r5,2(r3)
   162d0:	280ad43a 	srli	r5,r5,16
   162d4:	18c00104 	addi	r3,r3,4
   162d8:	233fed36 	bltu	r4,r12,16290 <__multiply+0xc8>
   162dc:	19400015 	stw	r5,0(r3)
   162e0:	6a800017 	ldw	r10,0(r13)
   162e4:	5014d43a 	srli	r10,r10,16
   162e8:	50001926 	beq	r10,zero,16350 <__multiply+0x188>
   162ec:	71400017 	ldw	r5,0(r14)
   162f0:	7007883a 	mov	r3,r14
   162f4:	8809883a 	mov	r4,r17
   162f8:	280f883a 	mov	r7,r5
   162fc:	0017883a 	mov	r11,zero
   16300:	22400017 	ldw	r9,0(r4)
   16304:	380ed43a 	srli	r7,r7,16
   16308:	1940000d 	sth	r5,0(r3)
   1630c:	4a3fffcc 	andi	r8,r9,65535
   16310:	4291383a 	mul	r8,r8,r10
   16314:	4812d43a 	srli	r9,r9,16
   16318:	18c00104 	addi	r3,r3,4
   1631c:	41d1883a 	add	r8,r8,r7
   16320:	19c00017 	ldw	r7,0(r3)
   16324:	42d1883a 	add	r8,r8,r11
   16328:	4a93383a 	mul	r9,r9,r10
   1632c:	1a3fff8d 	sth	r8,-2(r3)
   16330:	4010d43a 	srli	r8,r8,16
   16334:	397fffcc 	andi	r5,r7,65535
   16338:	2a4b883a 	add	r5,r5,r9
   1633c:	2a0b883a 	add	r5,r5,r8
   16340:	21000104 	addi	r4,r4,4
   16344:	2816d43a 	srli	r11,r5,16
   16348:	233fed36 	bltu	r4,r12,16300 <__multiply+0x138>
   1634c:	19400015 	stw	r5,0(r3)
   16350:	6b400104 	addi	r13,r13,4
   16354:	73800104 	addi	r14,r14,4
   16358:	69bfc736 	bltu	r13,r6,16278 <__multiply+0xb0>
   1635c:	0400090e 	bge	zero,r16,16384 <__multiply+0x1bc>
   16360:	78ffff17 	ldw	r3,-4(r15)
   16364:	7bffff04 	addi	r15,r15,-4
   16368:	18000326 	beq	r3,zero,16378 <__multiply+0x1b0>
   1636c:	00000506 	br	16384 <__multiply+0x1bc>
   16370:	78c00017 	ldw	r3,0(r15)
   16374:	1800031e 	bne	r3,zero,16384 <__multiply+0x1bc>
   16378:	843fffc4 	addi	r16,r16,-1
   1637c:	7bffff04 	addi	r15,r15,-4
   16380:	803ffb1e 	bne	r16,zero,16370 <__multiply+0x1a8>
   16384:	14000415 	stw	r16,16(r2)
   16388:	dfc00517 	ldw	ra,20(sp)
   1638c:	dd000417 	ldw	r20,16(sp)
   16390:	dcc00317 	ldw	r19,12(sp)
   16394:	dc800217 	ldw	r18,8(sp)
   16398:	dc400117 	ldw	r17,4(sp)
   1639c:	dc000017 	ldw	r16,0(sp)
   163a0:	dec00604 	addi	sp,sp,24
   163a4:	f800283a 	ret

000163a8 <__pow5mult>:
   163a8:	defffb04 	addi	sp,sp,-20
   163ac:	dcc00315 	stw	r19,12(sp)
   163b0:	dc800215 	stw	r18,8(sp)
   163b4:	dc000015 	stw	r16,0(sp)
   163b8:	dfc00415 	stw	ra,16(sp)
   163bc:	dc400115 	stw	r17,4(sp)
   163c0:	308000cc 	andi	r2,r6,3
   163c4:	3021883a 	mov	r16,r6
   163c8:	2027883a 	mov	r19,r4
   163cc:	2825883a 	mov	r18,r5
   163d0:	10002e1e 	bne	r2,zero,1648c <__pow5mult+0xe4>
   163d4:	8021d0ba 	srai	r16,r16,2
   163d8:	80001a26 	beq	r16,zero,16444 <__pow5mult+0x9c>
   163dc:	9c401217 	ldw	r17,72(r19)
   163e0:	8800061e 	bne	r17,zero,163fc <__pow5mult+0x54>
   163e4:	00003406 	br	164b8 <__pow5mult+0x110>
   163e8:	8021d07a 	srai	r16,r16,1
   163ec:	80001526 	beq	r16,zero,16444 <__pow5mult+0x9c>
   163f0:	88c00017 	ldw	r3,0(r17)
   163f4:	18001b26 	beq	r3,zero,16464 <__pow5mult+0xbc>
   163f8:	1823883a 	mov	r17,r3
   163fc:	80c0004c 	andi	r3,r16,1
   16400:	183ff926 	beq	r3,zero,163e8 <__pow5mult+0x40>
   16404:	900b883a 	mov	r5,r18
   16408:	880d883a 	mov	r6,r17
   1640c:	9809883a 	mov	r4,r19
   16410:	00161c80 	call	161c8 <__multiply>
   16414:	90001b26 	beq	r18,zero,16484 <__pow5mult+0xdc>
   16418:	91000117 	ldw	r4,4(r18)
   1641c:	98c01317 	ldw	r3,76(r19)
   16420:	8021d07a 	srai	r16,r16,1
   16424:	2109883a 	add	r4,r4,r4
   16428:	2109883a 	add	r4,r4,r4
   1642c:	1907883a 	add	r3,r3,r4
   16430:	19000017 	ldw	r4,0(r3)
   16434:	91000015 	stw	r4,0(r18)
   16438:	1c800015 	stw	r18,0(r3)
   1643c:	1025883a 	mov	r18,r2
   16440:	803feb1e 	bne	r16,zero,163f0 <__pow5mult+0x48>
   16444:	9005883a 	mov	r2,r18
   16448:	dfc00417 	ldw	ra,16(sp)
   1644c:	dcc00317 	ldw	r19,12(sp)
   16450:	dc800217 	ldw	r18,8(sp)
   16454:	dc400117 	ldw	r17,4(sp)
   16458:	dc000017 	ldw	r16,0(sp)
   1645c:	dec00504 	addi	sp,sp,20
   16460:	f800283a 	ret
   16464:	880b883a 	mov	r5,r17
   16468:	880d883a 	mov	r6,r17
   1646c:	9809883a 	mov	r4,r19
   16470:	00161c80 	call	161c8 <__multiply>
   16474:	88800015 	stw	r2,0(r17)
   16478:	10000015 	stw	zero,0(r2)
   1647c:	1023883a 	mov	r17,r2
   16480:	003fde06 	br	163fc <__pow5mult+0x54>
   16484:	1025883a 	mov	r18,r2
   16488:	003fd706 	br	163e8 <__pow5mult+0x40>
   1648c:	10bfffc4 	addi	r2,r2,-1
   16490:	1085883a 	add	r2,r2,r2
   16494:	00c000b4 	movhi	r3,2
   16498:	18d89d04 	addi	r3,r3,25204
   1649c:	1085883a 	add	r2,r2,r2
   164a0:	1885883a 	add	r2,r3,r2
   164a4:	11800017 	ldw	r6,0(r2)
   164a8:	000f883a 	mov	r7,zero
   164ac:	0015e5c0 	call	15e5c <__multadd>
   164b0:	1025883a 	mov	r18,r2
   164b4:	003fc706 	br	163d4 <__pow5mult+0x2c>
   164b8:	9809883a 	mov	r4,r19
   164bc:	01409c44 	movi	r5,625
   164c0:	001618c0 	call	1618c <__i2b>
   164c4:	98801215 	stw	r2,72(r19)
   164c8:	1023883a 	mov	r17,r2
   164cc:	10000015 	stw	zero,0(r2)
   164d0:	003fca06 	br	163fc <__pow5mult+0x54>

000164d4 <__lshift>:
   164d4:	defff904 	addi	sp,sp,-28
   164d8:	dd400515 	stw	r21,20(sp)
   164dc:	dc400115 	stw	r17,4(sp)
   164e0:	2d400417 	ldw	r21,16(r5)
   164e4:	3023d17a 	srai	r17,r6,5
   164e8:	28800217 	ldw	r2,8(r5)
   164ec:	dd000415 	stw	r20,16(sp)
   164f0:	8d6b883a 	add	r21,r17,r21
   164f4:	dcc00315 	stw	r19,12(sp)
   164f8:	dc800215 	stw	r18,8(sp)
   164fc:	dc000015 	stw	r16,0(sp)
   16500:	dfc00615 	stw	ra,24(sp)
   16504:	ac000044 	addi	r16,r21,1
   16508:	2825883a 	mov	r18,r5
   1650c:	3029883a 	mov	r20,r6
   16510:	2027883a 	mov	r19,r4
   16514:	29400117 	ldw	r5,4(r5)
   16518:	1400030e 	bge	r2,r16,16528 <__lshift+0x54>
   1651c:	1085883a 	add	r2,r2,r2
   16520:	29400044 	addi	r5,r5,1
   16524:	143ffd16 	blt	r2,r16,1651c <__lshift+0x48>
   16528:	9809883a 	mov	r4,r19
   1652c:	0015d8c0 	call	15d8c <_Balloc>
   16530:	10c00504 	addi	r3,r2,20
   16534:	0440090e 	bge	zero,r17,1655c <__lshift+0x88>
   16538:	000f883a 	mov	r7,zero
   1653c:	18000015 	stw	zero,0(r3)
   16540:	39c00044 	addi	r7,r7,1
   16544:	18c00104 	addi	r3,r3,4
   16548:	3c7ffc1e 	bne	r7,r17,1653c <__lshift+0x68>
   1654c:	38c00144 	addi	r3,r7,5
   16550:	18c7883a 	add	r3,r3,r3
   16554:	18c7883a 	add	r3,r3,r3
   16558:	10c7883a 	add	r3,r2,r3
   1655c:	92000417 	ldw	r8,16(r18)
   16560:	a18007cc 	andi	r6,r20,31
   16564:	91c00504 	addi	r7,r18,20
   16568:	42000144 	addi	r8,r8,5
   1656c:	4211883a 	add	r8,r8,r8
   16570:	4211883a 	add	r8,r8,r8
   16574:	9211883a 	add	r8,r18,r8
   16578:	30002226 	beq	r6,zero,16604 <__lshift+0x130>
   1657c:	02800804 	movi	r10,32
   16580:	5195c83a 	sub	r10,r10,r6
   16584:	000b883a 	mov	r5,zero
   16588:	3a400017 	ldw	r9,0(r7)
   1658c:	18c00104 	addi	r3,r3,4
   16590:	39c00104 	addi	r7,r7,4
   16594:	4992983a 	sll	r9,r9,r6
   16598:	2a4ab03a 	or	r5,r5,r9
   1659c:	197fff15 	stw	r5,-4(r3)
   165a0:	397fff17 	ldw	r5,-4(r7)
   165a4:	2a8ad83a 	srl	r5,r5,r10
   165a8:	3a3ff736 	bltu	r7,r8,16588 <__lshift+0xb4>
   165ac:	19400015 	stw	r5,0(r3)
   165b0:	28000126 	beq	r5,zero,165b8 <__lshift+0xe4>
   165b4:	ac000084 	addi	r16,r21,2
   165b8:	91000117 	ldw	r4,4(r18)
   165bc:	98c01317 	ldw	r3,76(r19)
   165c0:	843fffc4 	addi	r16,r16,-1
   165c4:	2109883a 	add	r4,r4,r4
   165c8:	2109883a 	add	r4,r4,r4
   165cc:	1907883a 	add	r3,r3,r4
   165d0:	19000017 	ldw	r4,0(r3)
   165d4:	14000415 	stw	r16,16(r2)
   165d8:	91000015 	stw	r4,0(r18)
   165dc:	1c800015 	stw	r18,0(r3)
   165e0:	dfc00617 	ldw	ra,24(sp)
   165e4:	dd400517 	ldw	r21,20(sp)
   165e8:	dd000417 	ldw	r20,16(sp)
   165ec:	dcc00317 	ldw	r19,12(sp)
   165f0:	dc800217 	ldw	r18,8(sp)
   165f4:	dc400117 	ldw	r17,4(sp)
   165f8:	dc000017 	ldw	r16,0(sp)
   165fc:	dec00704 	addi	sp,sp,28
   16600:	f800283a 	ret
   16604:	39400017 	ldw	r5,0(r7)
   16608:	18c00104 	addi	r3,r3,4
   1660c:	39c00104 	addi	r7,r7,4
   16610:	197fff15 	stw	r5,-4(r3)
   16614:	3a3fe82e 	bgeu	r7,r8,165b8 <__lshift+0xe4>
   16618:	39400017 	ldw	r5,0(r7)
   1661c:	18c00104 	addi	r3,r3,4
   16620:	39c00104 	addi	r7,r7,4
   16624:	197fff15 	stw	r5,-4(r3)
   16628:	3a3ff636 	bltu	r7,r8,16604 <__lshift+0x130>
   1662c:	003fe206 	br	165b8 <__lshift+0xe4>

00016630 <__mcmp>:
   16630:	20800417 	ldw	r2,16(r4)
   16634:	28c00417 	ldw	r3,16(r5)
   16638:	10c5c83a 	sub	r2,r2,r3
   1663c:	10000f1e 	bne	r2,zero,1667c <__mcmp+0x4c>
   16640:	18c00144 	addi	r3,r3,5
   16644:	18c7883a 	add	r3,r3,r3
   16648:	18c7883a 	add	r3,r3,r3
   1664c:	21c00504 	addi	r7,r4,20
   16650:	28cb883a 	add	r5,r5,r3
   16654:	20c9883a 	add	r4,r4,r3
   16658:	213fff04 	addi	r4,r4,-4
   1665c:	297fff04 	addi	r5,r5,-4
   16660:	21800017 	ldw	r6,0(r4)
   16664:	28c00017 	ldw	r3,0(r5)
   16668:	30c0021e 	bne	r6,r3,16674 <__mcmp+0x44>
   1666c:	393ffa36 	bltu	r7,r4,16658 <__mcmp+0x28>
   16670:	f800283a 	ret
   16674:	30c00236 	bltu	r6,r3,16680 <__mcmp+0x50>
   16678:	00800044 	movi	r2,1
   1667c:	f800283a 	ret
   16680:	00bfffc4 	movi	r2,-1
   16684:	f800283a 	ret

00016688 <__mdiff>:
   16688:	defffb04 	addi	sp,sp,-20
   1668c:	dc000015 	stw	r16,0(sp)
   16690:	2821883a 	mov	r16,r5
   16694:	dc800215 	stw	r18,8(sp)
   16698:	300b883a 	mov	r5,r6
   1669c:	2025883a 	mov	r18,r4
   166a0:	8009883a 	mov	r4,r16
   166a4:	dc400115 	stw	r17,4(sp)
   166a8:	dfc00415 	stw	ra,16(sp)
   166ac:	dcc00315 	stw	r19,12(sp)
   166b0:	3023883a 	mov	r17,r6
   166b4:	00166300 	call	16630 <__mcmp>
   166b8:	10005026 	beq	r2,zero,167fc <__mdiff+0x174>
   166bc:	10004a16 	blt	r2,zero,167e8 <__mdiff+0x160>
   166c0:	0027883a 	mov	r19,zero
   166c4:	81400117 	ldw	r5,4(r16)
   166c8:	9009883a 	mov	r4,r18
   166cc:	0015d8c0 	call	15d8c <_Balloc>
   166d0:	82400417 	ldw	r9,16(r16)
   166d4:	89800417 	ldw	r6,16(r17)
   166d8:	14c00315 	stw	r19,12(r2)
   166dc:	4b800144 	addi	r14,r9,5
   166e0:	31800144 	addi	r6,r6,5
   166e4:	739d883a 	add	r14,r14,r14
   166e8:	318d883a 	add	r6,r6,r6
   166ec:	739d883a 	add	r14,r14,r14
   166f0:	318d883a 	add	r6,r6,r6
   166f4:	81c00504 	addi	r7,r16,20
   166f8:	839d883a 	add	r14,r16,r14
   166fc:	8a000504 	addi	r8,r17,20
   16700:	898d883a 	add	r6,r17,r6
   16704:	10c00504 	addi	r3,r2,20
   16708:	0009883a 	mov	r4,zero
   1670c:	3b000017 	ldw	r12,0(r7)
   16710:	42c00017 	ldw	r11,0(r8)
   16714:	42000104 	addi	r8,r8,4
   16718:	62bfffcc 	andi	r10,r12,65535
   1671c:	5b7fffcc 	andi	r13,r11,65535
   16720:	5109883a 	add	r4,r10,r4
   16724:	2355c83a 	sub	r10,r4,r13
   16728:	5816d43a 	srli	r11,r11,16
   1672c:	6008d43a 	srli	r4,r12,16
   16730:	501bd43a 	srai	r13,r10,16
   16734:	1a80000d 	sth	r10,0(r3)
   16738:	22c9c83a 	sub	r4,r4,r11
   1673c:	2349883a 	add	r4,r4,r13
   16740:	1900008d 	sth	r4,2(r3)
   16744:	39c00104 	addi	r7,r7,4
   16748:	2009d43a 	srai	r4,r4,16
   1674c:	18c00104 	addi	r3,r3,4
   16750:	41bfee36 	bltu	r8,r6,1670c <__mdiff+0x84>
   16754:	180b883a 	mov	r5,r3
   16758:	3815883a 	mov	r10,r7
   1675c:	3b80132e 	bgeu	r7,r14,167ac <__mdiff+0x124>
   16760:	3a000017 	ldw	r8,0(r7)
   16764:	18c00104 	addi	r3,r3,4
   16768:	39c00104 	addi	r7,r7,4
   1676c:	41bfffcc 	andi	r6,r8,65535
   16770:	310d883a 	add	r6,r6,r4
   16774:	3009d43a 	srai	r4,r6,16
   16778:	4010d43a 	srli	r8,r8,16
   1677c:	19bfff0d 	sth	r6,-4(r3)
   16780:	2209883a 	add	r4,r4,r8
   16784:	193fff8d 	sth	r4,-2(r3)
   16788:	2009d43a 	srai	r4,r4,16
   1678c:	3bbff436 	bltu	r7,r14,16760 <__mdiff+0xd8>
   16790:	0286303a 	nor	r3,zero,r10
   16794:	1b87883a 	add	r3,r3,r14
   16798:	1806d0ba 	srli	r3,r3,2
   1679c:	18c00044 	addi	r3,r3,1
   167a0:	18c7883a 	add	r3,r3,r3
   167a4:	18c7883a 	add	r3,r3,r3
   167a8:	28c7883a 	add	r3,r5,r3
   167ac:	193fff17 	ldw	r4,-4(r3)
   167b0:	18ffff04 	addi	r3,r3,-4
   167b4:	2000041e 	bne	r4,zero,167c8 <__mdiff+0x140>
   167b8:	18ffff04 	addi	r3,r3,-4
   167bc:	19000017 	ldw	r4,0(r3)
   167c0:	4a7fffc4 	addi	r9,r9,-1
   167c4:	203ffc26 	beq	r4,zero,167b8 <__mdiff+0x130>
   167c8:	12400415 	stw	r9,16(r2)
   167cc:	dfc00417 	ldw	ra,16(sp)
   167d0:	dcc00317 	ldw	r19,12(sp)
   167d4:	dc800217 	ldw	r18,8(sp)
   167d8:	dc400117 	ldw	r17,4(sp)
   167dc:	dc000017 	ldw	r16,0(sp)
   167e0:	dec00504 	addi	sp,sp,20
   167e4:	f800283a 	ret
   167e8:	8005883a 	mov	r2,r16
   167ec:	04c00044 	movi	r19,1
   167f0:	8821883a 	mov	r16,r17
   167f4:	1023883a 	mov	r17,r2
   167f8:	003fb206 	br	166c4 <__mdiff+0x3c>
   167fc:	9009883a 	mov	r4,r18
   16800:	000b883a 	mov	r5,zero
   16804:	0015d8c0 	call	15d8c <_Balloc>
   16808:	00c00044 	movi	r3,1
   1680c:	10c00415 	stw	r3,16(r2)
   16810:	10000515 	stw	zero,20(r2)
   16814:	dfc00417 	ldw	ra,16(sp)
   16818:	dcc00317 	ldw	r19,12(sp)
   1681c:	dc800217 	ldw	r18,8(sp)
   16820:	dc400117 	ldw	r17,4(sp)
   16824:	dc000017 	ldw	r16,0(sp)
   16828:	dec00504 	addi	sp,sp,20
   1682c:	f800283a 	ret

00016830 <__ulp>:
   16830:	295ffc2c 	andhi	r5,r5,32752
   16834:	00bf3034 	movhi	r2,64704
   16838:	2887883a 	add	r3,r5,r2
   1683c:	00c0020e 	bge	zero,r3,16848 <__ulp+0x18>
   16840:	0005883a 	mov	r2,zero
   16844:	f800283a 	ret
   16848:	00c7c83a 	sub	r3,zero,r3
   1684c:	1805d53a 	srai	r2,r3,20
   16850:	00c004c4 	movi	r3,19
   16854:	18800a0e 	bge	r3,r2,16880 <__ulp+0x50>
   16858:	01000c84 	movi	r4,50
   1685c:	0007883a 	mov	r3,zero
   16860:	20800516 	blt	r4,r2,16878 <__ulp+0x48>
   16864:	01000cc4 	movi	r4,51
   16868:	2085c83a 	sub	r2,r4,r2
   1686c:	01000044 	movi	r4,1
   16870:	2084983a 	sll	r2,r4,r2
   16874:	f800283a 	ret
   16878:	00800044 	movi	r2,1
   1687c:	f800283a 	ret
   16880:	00c00234 	movhi	r3,8
   16884:	1887d83a 	sra	r3,r3,r2
   16888:	0005883a 	mov	r2,zero
   1688c:	f800283a 	ret

00016890 <__b2d>:
   16890:	defffa04 	addi	sp,sp,-24
   16894:	dc000015 	stw	r16,0(sp)
   16898:	24000417 	ldw	r16,16(r4)
   1689c:	dc400115 	stw	r17,4(sp)
   168a0:	dcc00315 	stw	r19,12(sp)
   168a4:	84000144 	addi	r16,r16,5
   168a8:	8421883a 	add	r16,r16,r16
   168ac:	8421883a 	add	r16,r16,r16
   168b0:	2421883a 	add	r16,r4,r16
   168b4:	847fff17 	ldw	r17,-4(r16)
   168b8:	24c00504 	addi	r19,r4,20
   168bc:	dd000415 	stw	r20,16(sp)
   168c0:	8809883a 	mov	r4,r17
   168c4:	dc800215 	stw	r18,8(sp)
   168c8:	2829883a 	mov	r20,r5
   168cc:	dfc00515 	stw	ra,20(sp)
   168d0:	00160740 	call	16074 <__hi0bits>
   168d4:	00c00804 	movi	r3,32
   168d8:	1887c83a 	sub	r3,r3,r2
   168dc:	a0c00015 	stw	r3,0(r20)
   168e0:	00c00284 	movi	r3,10
   168e4:	84bfff04 	addi	r18,r16,-4
   168e8:	18801216 	blt	r3,r2,16934 <__b2d+0xa4>
   168ec:	010002c4 	movi	r4,11
   168f0:	2089c83a 	sub	r4,r4,r2
   168f4:	8906d83a 	srl	r3,r17,r4
   168f8:	18cffc34 	orhi	r3,r3,16368
   168fc:	9c80322e 	bgeu	r19,r18,169c8 <__b2d+0x138>
   16900:	817ffe17 	ldw	r5,-8(r16)
   16904:	2908d83a 	srl	r4,r5,r4
   16908:	10800544 	addi	r2,r2,21
   1690c:	88a2983a 	sll	r17,r17,r2
   16910:	2444b03a 	or	r2,r4,r17
   16914:	dfc00517 	ldw	ra,20(sp)
   16918:	dd000417 	ldw	r20,16(sp)
   1691c:	dcc00317 	ldw	r19,12(sp)
   16920:	dc800217 	ldw	r18,8(sp)
   16924:	dc400117 	ldw	r17,4(sp)
   16928:	dc000017 	ldw	r16,0(sp)
   1692c:	dec00604 	addi	sp,sp,24
   16930:	f800283a 	ret
   16934:	9c801636 	bltu	r19,r18,16990 <__b2d+0x100>
   16938:	113ffd44 	addi	r4,r2,-11
   1693c:	000b883a 	mov	r5,zero
   16940:	20001726 	beq	r4,zero,169a0 <__b2d+0x110>
   16944:	00c00ac4 	movi	r3,43
   16948:	1885c83a 	sub	r2,r3,r2
   1694c:	8906983a 	sll	r3,r17,r4
   16950:	288cd83a 	srl	r6,r5,r2
   16954:	18cffc34 	orhi	r3,r3,16368
   16958:	1986b03a 	or	r3,r3,r6
   1695c:	9c801c2e 	bgeu	r19,r18,169d0 <__b2d+0x140>
   16960:	91bfff17 	ldw	r6,-4(r18)
   16964:	3084d83a 	srl	r2,r6,r2
   16968:	2908983a 	sll	r4,r5,r4
   1696c:	1104b03a 	or	r2,r2,r4
   16970:	dfc00517 	ldw	ra,20(sp)
   16974:	dd000417 	ldw	r20,16(sp)
   16978:	dcc00317 	ldw	r19,12(sp)
   1697c:	dc800217 	ldw	r18,8(sp)
   16980:	dc400117 	ldw	r17,4(sp)
   16984:	dc000017 	ldw	r16,0(sp)
   16988:	dec00604 	addi	sp,sp,24
   1698c:	f800283a 	ret
   16990:	113ffd44 	addi	r4,r2,-11
   16994:	84bffe04 	addi	r18,r16,-8
   16998:	817ffe17 	ldw	r5,-8(r16)
   1699c:	203fe91e 	bne	r4,zero,16944 <__b2d+0xb4>
   169a0:	88cffc34 	orhi	r3,r17,16368
   169a4:	2805883a 	mov	r2,r5
   169a8:	dfc00517 	ldw	ra,20(sp)
   169ac:	dd000417 	ldw	r20,16(sp)
   169b0:	dcc00317 	ldw	r19,12(sp)
   169b4:	dc800217 	ldw	r18,8(sp)
   169b8:	dc400117 	ldw	r17,4(sp)
   169bc:	dc000017 	ldw	r16,0(sp)
   169c0:	dec00604 	addi	sp,sp,24
   169c4:	f800283a 	ret
   169c8:	0009883a 	mov	r4,zero
   169cc:	003fce06 	br	16908 <__b2d+0x78>
   169d0:	0005883a 	mov	r2,zero
   169d4:	003fe406 	br	16968 <__b2d+0xd8>

000169d8 <__d2b>:
   169d8:	defff804 	addi	sp,sp,-32
   169dc:	dc400315 	stw	r17,12(sp)
   169e0:	3023883a 	mov	r17,r6
   169e4:	dc800415 	stw	r18,16(sp)
   169e8:	8824907a 	slli	r18,r17,1
   169ec:	dcc00515 	stw	r19,20(sp)
   169f0:	2827883a 	mov	r19,r5
   169f4:	9024d57a 	srli	r18,r18,21
   169f8:	01400044 	movi	r5,1
   169fc:	dd000615 	stw	r20,24(sp)
   16a00:	dc000215 	stw	r16,8(sp)
   16a04:	dfc00715 	stw	ra,28(sp)
   16a08:	3829883a 	mov	r20,r7
   16a0c:	0015d8c0 	call	15d8c <_Balloc>
   16a10:	1021883a 	mov	r16,r2
   16a14:	00800434 	movhi	r2,16
   16a18:	10bfffc4 	addi	r2,r2,-1
   16a1c:	88a2703a 	and	r17,r17,r2
   16a20:	90000126 	beq	r18,zero,16a28 <__d2b+0x50>
   16a24:	8c400434 	orhi	r17,r17,16
   16a28:	dc400015 	stw	r17,0(sp)
   16a2c:	98002226 	beq	r19,zero,16ab8 <__d2b+0xe0>
   16a30:	d9000104 	addi	r4,sp,4
   16a34:	dcc00115 	stw	r19,4(sp)
   16a38:	00160dc0 	call	160dc <__lo0bits>
   16a3c:	d8c00017 	ldw	r3,0(sp)
   16a40:	10002d1e 	bne	r2,zero,16af8 <__d2b+0x120>
   16a44:	d9000117 	ldw	r4,4(sp)
   16a48:	81000515 	stw	r4,20(r16)
   16a4c:	1823003a 	cmpeq	r17,r3,zero
   16a50:	01000084 	movi	r4,2
   16a54:	2463c83a 	sub	r17,r4,r17
   16a58:	80c00615 	stw	r3,24(r16)
   16a5c:	84400415 	stw	r17,16(r16)
   16a60:	90001d1e 	bne	r18,zero,16ad8 <__d2b+0x100>
   16a64:	88c00104 	addi	r3,r17,4
   16a68:	18c7883a 	add	r3,r3,r3
   16a6c:	18c7883a 	add	r3,r3,r3
   16a70:	80c7883a 	add	r3,r16,r3
   16a74:	19000017 	ldw	r4,0(r3)
   16a78:	10bef384 	addi	r2,r2,-1074
   16a7c:	a0800015 	stw	r2,0(r20)
   16a80:	00160740 	call	16074 <__hi0bits>
   16a84:	8822917a 	slli	r17,r17,5
   16a88:	d8c00817 	ldw	r3,32(sp)
   16a8c:	8885c83a 	sub	r2,r17,r2
   16a90:	18800015 	stw	r2,0(r3)
   16a94:	8005883a 	mov	r2,r16
   16a98:	dfc00717 	ldw	ra,28(sp)
   16a9c:	dd000617 	ldw	r20,24(sp)
   16aa0:	dcc00517 	ldw	r19,20(sp)
   16aa4:	dc800417 	ldw	r18,16(sp)
   16aa8:	dc400317 	ldw	r17,12(sp)
   16aac:	dc000217 	ldw	r16,8(sp)
   16ab0:	dec00804 	addi	sp,sp,32
   16ab4:	f800283a 	ret
   16ab8:	d809883a 	mov	r4,sp
   16abc:	00160dc0 	call	160dc <__lo0bits>
   16ac0:	d8c00017 	ldw	r3,0(sp)
   16ac4:	04400044 	movi	r17,1
   16ac8:	84400415 	stw	r17,16(r16)
   16acc:	80c00515 	stw	r3,20(r16)
   16ad0:	10800804 	addi	r2,r2,32
   16ad4:	903fe326 	beq	r18,zero,16a64 <__d2b+0x8c>
   16ad8:	00c00d44 	movi	r3,53
   16adc:	94bef344 	addi	r18,r18,-1075
   16ae0:	90a5883a 	add	r18,r18,r2
   16ae4:	1885c83a 	sub	r2,r3,r2
   16ae8:	d8c00817 	ldw	r3,32(sp)
   16aec:	a4800015 	stw	r18,0(r20)
   16af0:	18800015 	stw	r2,0(r3)
   16af4:	003fe706 	br	16a94 <__d2b+0xbc>
   16af8:	01000804 	movi	r4,32
   16afc:	2089c83a 	sub	r4,r4,r2
   16b00:	1908983a 	sll	r4,r3,r4
   16b04:	d9400117 	ldw	r5,4(sp)
   16b08:	1886d83a 	srl	r3,r3,r2
   16b0c:	2148b03a 	or	r4,r4,r5
   16b10:	81000515 	stw	r4,20(r16)
   16b14:	d8c00015 	stw	r3,0(sp)
   16b18:	003fcc06 	br	16a4c <__d2b+0x74>

00016b1c <__ratio>:
   16b1c:	defff904 	addi	sp,sp,-28
   16b20:	dc400315 	stw	r17,12(sp)
   16b24:	2823883a 	mov	r17,r5
   16b28:	d9400104 	addi	r5,sp,4
   16b2c:	dfc00615 	stw	ra,24(sp)
   16b30:	dcc00515 	stw	r19,20(sp)
   16b34:	dc800415 	stw	r18,16(sp)
   16b38:	2027883a 	mov	r19,r4
   16b3c:	dc000215 	stw	r16,8(sp)
   16b40:	00168900 	call	16890 <__b2d>
   16b44:	8809883a 	mov	r4,r17
   16b48:	d80b883a 	mov	r5,sp
   16b4c:	1025883a 	mov	r18,r2
   16b50:	1821883a 	mov	r16,r3
   16b54:	00168900 	call	16890 <__b2d>
   16b58:	99400417 	ldw	r5,16(r19)
   16b5c:	89000417 	ldw	r4,16(r17)
   16b60:	d9800117 	ldw	r6,4(sp)
   16b64:	2909c83a 	sub	r4,r5,r4
   16b68:	d9400017 	ldw	r5,0(sp)
   16b6c:	2008917a 	slli	r4,r4,5
   16b70:	314bc83a 	sub	r5,r6,r5
   16b74:	290b883a 	add	r5,r5,r4
   16b78:	01400e0e 	bge	zero,r5,16bb4 <__ratio+0x98>
   16b7c:	280a953a 	slli	r5,r5,20
   16b80:	2c21883a 	add	r16,r5,r16
   16b84:	9009883a 	mov	r4,r18
   16b88:	800b883a 	mov	r5,r16
   16b8c:	100d883a 	mov	r6,r2
   16b90:	180f883a 	mov	r7,r3
   16b94:	000f8280 	call	f828 <__divdf3>
   16b98:	dfc00617 	ldw	ra,24(sp)
   16b9c:	dcc00517 	ldw	r19,20(sp)
   16ba0:	dc800417 	ldw	r18,16(sp)
   16ba4:	dc400317 	ldw	r17,12(sp)
   16ba8:	dc000217 	ldw	r16,8(sp)
   16bac:	dec00704 	addi	sp,sp,28
   16bb0:	f800283a 	ret
   16bb4:	280a953a 	slli	r5,r5,20
   16bb8:	1947c83a 	sub	r3,r3,r5
   16bbc:	003ff106 	br	16b84 <__ratio+0x68>

00016bc0 <_mprec_log10>:
   16bc0:	defffe04 	addi	sp,sp,-8
   16bc4:	dc000015 	stw	r16,0(sp)
   16bc8:	dfc00115 	stw	ra,4(sp)
   16bcc:	008005c4 	movi	r2,23
   16bd0:	2021883a 	mov	r16,r4
   16bd4:	11000d0e 	bge	r2,r4,16c0c <_mprec_log10+0x4c>
   16bd8:	0005883a 	mov	r2,zero
   16bdc:	00cffc34 	movhi	r3,16368
   16be0:	843fffc4 	addi	r16,r16,-1
   16be4:	1009883a 	mov	r4,r2
   16be8:	180b883a 	mov	r5,r3
   16bec:	000d883a 	mov	r6,zero
   16bf0:	01d00934 	movhi	r7,16420
   16bf4:	000f5440 	call	f544 <__muldf3>
   16bf8:	803ff91e 	bne	r16,zero,16be0 <_mprec_log10+0x20>
   16bfc:	dfc00117 	ldw	ra,4(sp)
   16c00:	dc000017 	ldw	r16,0(sp)
   16c04:	dec00204 	addi	sp,sp,8
   16c08:	f800283a 	ret
   16c0c:	202090fa 	slli	r16,r4,3
   16c10:	008000b4 	movhi	r2,2
   16c14:	10986b04 	addi	r2,r2,25004
   16c18:	1421883a 	add	r16,r2,r16
   16c1c:	80800017 	ldw	r2,0(r16)
   16c20:	80c00117 	ldw	r3,4(r16)
   16c24:	dfc00117 	ldw	ra,4(sp)
   16c28:	dc000017 	ldw	r16,0(sp)
   16c2c:	dec00204 	addi	sp,sp,8
   16c30:	f800283a 	ret

00016c34 <__copybits>:
   16c34:	297fffc4 	addi	r5,r5,-1
   16c38:	31c00417 	ldw	r7,16(r6)
   16c3c:	2811d17a 	srai	r8,r5,5
   16c40:	30800504 	addi	r2,r6,20
   16c44:	39c00144 	addi	r7,r7,5
   16c48:	42000044 	addi	r8,r8,1
   16c4c:	39cf883a 	add	r7,r7,r7
   16c50:	4211883a 	add	r8,r8,r8
   16c54:	39cf883a 	add	r7,r7,r7
   16c58:	4211883a 	add	r8,r8,r8
   16c5c:	31cf883a 	add	r7,r6,r7
   16c60:	2211883a 	add	r8,r4,r8
   16c64:	11c00d2e 	bgeu	r2,r7,16c9c <__copybits+0x68>
   16c68:	2007883a 	mov	r3,r4
   16c6c:	11400017 	ldw	r5,0(r2)
   16c70:	18c00104 	addi	r3,r3,4
   16c74:	10800104 	addi	r2,r2,4
   16c78:	197fff15 	stw	r5,-4(r3)
   16c7c:	11fffb36 	bltu	r2,r7,16c6c <__copybits+0x38>
   16c80:	3985c83a 	sub	r2,r7,r6
   16c84:	10bffac4 	addi	r2,r2,-21
   16c88:	1004d0ba 	srli	r2,r2,2
   16c8c:	10800044 	addi	r2,r2,1
   16c90:	1085883a 	add	r2,r2,r2
   16c94:	1085883a 	add	r2,r2,r2
   16c98:	2089883a 	add	r4,r4,r2
   16c9c:	2200032e 	bgeu	r4,r8,16cac <__copybits+0x78>
   16ca0:	20000015 	stw	zero,0(r4)
   16ca4:	21000104 	addi	r4,r4,4
   16ca8:	223ffd36 	bltu	r4,r8,16ca0 <__copybits+0x6c>
   16cac:	f800283a 	ret

00016cb0 <__any_on>:
   16cb0:	21800417 	ldw	r6,16(r4)
   16cb4:	2805d17a 	srai	r2,r5,5
   16cb8:	20c00504 	addi	r3,r4,20
   16cbc:	30800f0e 	bge	r6,r2,16cfc <__any_on+0x4c>
   16cc0:	3005883a 	mov	r2,r6
   16cc4:	10800144 	addi	r2,r2,5
   16cc8:	1085883a 	add	r2,r2,r2
   16ccc:	1085883a 	add	r2,r2,r2
   16cd0:	2089883a 	add	r4,r4,r2
   16cd4:	1900152e 	bgeu	r3,r4,16d2c <__any_on+0x7c>
   16cd8:	20bfff17 	ldw	r2,-4(r4)
   16cdc:	213fff04 	addi	r4,r4,-4
   16ce0:	1000041e 	bne	r2,zero,16cf4 <__any_on+0x44>
   16ce4:	1900112e 	bgeu	r3,r4,16d2c <__any_on+0x7c>
   16ce8:	213fff04 	addi	r4,r4,-4
   16cec:	20800017 	ldw	r2,0(r4)
   16cf0:	103ffc26 	beq	r2,zero,16ce4 <__any_on+0x34>
   16cf4:	00800044 	movi	r2,1
   16cf8:	f800283a 	ret
   16cfc:	11bff10e 	bge	r2,r6,16cc4 <__any_on+0x14>
   16d00:	294007cc 	andi	r5,r5,31
   16d04:	283fef26 	beq	r5,zero,16cc4 <__any_on+0x14>
   16d08:	11800144 	addi	r6,r2,5
   16d0c:	318d883a 	add	r6,r6,r6
   16d10:	318d883a 	add	r6,r6,r6
   16d14:	218d883a 	add	r6,r4,r6
   16d18:	31800017 	ldw	r6,0(r6)
   16d1c:	314ed83a 	srl	r7,r6,r5
   16d20:	394a983a 	sll	r5,r7,r5
   16d24:	29bff31e 	bne	r5,r6,16cf4 <__any_on+0x44>
   16d28:	003fe606 	br	16cc4 <__any_on+0x14>
   16d2c:	0005883a 	mov	r2,zero
   16d30:	f800283a 	ret

00016d34 <_realloc_r>:
   16d34:	defff504 	addi	sp,sp,-44
   16d38:	dd400615 	stw	r21,24(sp)
   16d3c:	dc800315 	stw	r18,12(sp)
   16d40:	dc000115 	stw	r16,4(sp)
   16d44:	dfc00a15 	stw	ra,40(sp)
   16d48:	df000915 	stw	fp,36(sp)
   16d4c:	ddc00815 	stw	r23,32(sp)
   16d50:	dd800715 	stw	r22,28(sp)
   16d54:	dd000515 	stw	r20,20(sp)
   16d58:	dcc00415 	stw	r19,16(sp)
   16d5c:	dc400215 	stw	r17,8(sp)
   16d60:	2821883a 	mov	r16,r5
   16d64:	202b883a 	mov	r21,r4
   16d68:	3025883a 	mov	r18,r6
   16d6c:	28009626 	beq	r5,zero,16fc8 <_realloc_r+0x294>
   16d70:	0018fa80 	call	18fa8 <__malloc_lock>
   16d74:	80bfff17 	ldw	r2,-4(r16)
   16d78:	04ffff04 	movi	r19,-4
   16d7c:	90c002c4 	addi	r3,r18,11
   16d80:	01000584 	movi	r4,22
   16d84:	85bffe04 	addi	r22,r16,-8
   16d88:	14e6703a 	and	r19,r2,r19
   16d8c:	20c0372e 	bgeu	r4,r3,16e6c <_realloc_r+0x138>
   16d90:	047ffe04 	movi	r17,-8
   16d94:	1c62703a 	and	r17,r3,r17
   16d98:	8807883a 	mov	r3,r17
   16d9c:	88005a16 	blt	r17,zero,16f08 <_realloc_r+0x1d4>
   16da0:	8c805936 	bltu	r17,r18,16f08 <_realloc_r+0x1d4>
   16da4:	98c0340e 	bge	r19,r3,16e78 <_realloc_r+0x144>
   16da8:	070000b4 	movhi	fp,2
   16dac:	e71f2904 	addi	fp,fp,31908
   16db0:	e1400217 	ldw	r5,8(fp)
   16db4:	b4c9883a 	add	r4,r22,r19
   16db8:	29009026 	beq	r5,r4,16ffc <_realloc_r+0x2c8>
   16dbc:	21800117 	ldw	r6,4(r4)
   16dc0:	01ffff84 	movi	r7,-2
   16dc4:	31ce703a 	and	r7,r6,r7
   16dc8:	21cf883a 	add	r7,r4,r7
   16dcc:	39c00117 	ldw	r7,4(r7)
   16dd0:	39c0004c 	andi	r7,r7,1
   16dd4:	38004326 	beq	r7,zero,16ee4 <_realloc_r+0x1b0>
   16dd8:	000d883a 	mov	r6,zero
   16ddc:	0009883a 	mov	r4,zero
   16de0:	1080004c 	andi	r2,r2,1
   16de4:	10005a1e 	bne	r2,zero,16f50 <_realloc_r+0x21c>
   16de8:	85fffe17 	ldw	r23,-8(r16)
   16dec:	00bfff04 	movi	r2,-4
   16df0:	b5efc83a 	sub	r23,r22,r23
   16df4:	b9c00117 	ldw	r7,4(r23)
   16df8:	388e703a 	and	r7,r7,r2
   16dfc:	3ccf883a 	add	r7,r7,r19
   16e00:	20005226 	beq	r4,zero,16f4c <_realloc_r+0x218>
   16e04:	31e9883a 	add	r20,r6,r7
   16e08:	2140c726 	beq	r4,r5,17128 <_realloc_r+0x3f4>
   16e0c:	a0c04f16 	blt	r20,r3,16f4c <_realloc_r+0x218>
   16e10:	20800317 	ldw	r2,12(r4)
   16e14:	20c00217 	ldw	r3,8(r4)
   16e18:	99bfff04 	addi	r6,r19,-4
   16e1c:	01000904 	movi	r4,36
   16e20:	18800315 	stw	r2,12(r3)
   16e24:	10c00215 	stw	r3,8(r2)
   16e28:	b8c00217 	ldw	r3,8(r23)
   16e2c:	b8800317 	ldw	r2,12(r23)
   16e30:	bc800204 	addi	r18,r23,8
   16e34:	18800315 	stw	r2,12(r3)
   16e38:	10c00215 	stw	r3,8(r2)
   16e3c:	2180ed36 	bltu	r4,r6,171f4 <_realloc_r+0x4c0>
   16e40:	008004c4 	movi	r2,19
   16e44:	11809b2e 	bgeu	r2,r6,170b4 <_realloc_r+0x380>
   16e48:	80800017 	ldw	r2,0(r16)
   16e4c:	b8800215 	stw	r2,8(r23)
   16e50:	80800117 	ldw	r2,4(r16)
   16e54:	b8800315 	stw	r2,12(r23)
   16e58:	008006c4 	movi	r2,27
   16e5c:	1180f936 	bltu	r2,r6,17244 <_realloc_r+0x510>
   16e60:	b8800404 	addi	r2,r23,16
   16e64:	80c00204 	addi	r3,r16,8
   16e68:	00009406 	br	170bc <_realloc_r+0x388>
   16e6c:	00c00404 	movi	r3,16
   16e70:	1823883a 	mov	r17,r3
   16e74:	003fca06 	br	16da0 <_realloc_r+0x6c>
   16e78:	9829883a 	mov	r20,r19
   16e7c:	a447c83a 	sub	r3,r20,r17
   16e80:	010003c4 	movi	r4,15
   16e84:	1080004c 	andi	r2,r2,1
   16e88:	20c02336 	bltu	r4,r3,16f18 <_realloc_r+0x1e4>
   16e8c:	1504b03a 	or	r2,r2,r20
   16e90:	b0800115 	stw	r2,4(r22)
   16e94:	b52d883a 	add	r22,r22,r20
   16e98:	b0800117 	ldw	r2,4(r22)
   16e9c:	10800054 	ori	r2,r2,1
   16ea0:	b0800115 	stw	r2,4(r22)
   16ea4:	a809883a 	mov	r4,r21
   16ea8:	0018fc80 	call	18fc8 <__malloc_unlock>
   16eac:	8025883a 	mov	r18,r16
   16eb0:	9005883a 	mov	r2,r18
   16eb4:	dfc00a17 	ldw	ra,40(sp)
   16eb8:	df000917 	ldw	fp,36(sp)
   16ebc:	ddc00817 	ldw	r23,32(sp)
   16ec0:	dd800717 	ldw	r22,28(sp)
   16ec4:	dd400617 	ldw	r21,24(sp)
   16ec8:	dd000517 	ldw	r20,20(sp)
   16ecc:	dcc00417 	ldw	r19,16(sp)
   16ed0:	dc800317 	ldw	r18,12(sp)
   16ed4:	dc400217 	ldw	r17,8(sp)
   16ed8:	dc000117 	ldw	r16,4(sp)
   16edc:	dec00b04 	addi	sp,sp,44
   16ee0:	f800283a 	ret
   16ee4:	01ffff04 	movi	r7,-4
   16ee8:	31cc703a 	and	r6,r6,r7
   16eec:	34e9883a 	add	r20,r6,r19
   16ef0:	a0ffbb16 	blt	r20,r3,16de0 <_realloc_r+0xac>
   16ef4:	20c00317 	ldw	r3,12(r4)
   16ef8:	21000217 	ldw	r4,8(r4)
   16efc:	20c00315 	stw	r3,12(r4)
   16f00:	19000215 	stw	r4,8(r3)
   16f04:	003fdd06 	br	16e7c <_realloc_r+0x148>
   16f08:	00800304 	movi	r2,12
   16f0c:	a8800015 	stw	r2,0(r21)
   16f10:	0025883a 	mov	r18,zero
   16f14:	003fe606 	br	16eb0 <_realloc_r+0x17c>
   16f18:	1444b03a 	or	r2,r2,r17
   16f1c:	b0800115 	stw	r2,4(r22)
   16f20:	b44b883a 	add	r5,r22,r17
   16f24:	18800054 	ori	r2,r3,1
   16f28:	28800115 	stw	r2,4(r5)
   16f2c:	28c7883a 	add	r3,r5,r3
   16f30:	18800117 	ldw	r2,4(r3)
   16f34:	a809883a 	mov	r4,r21
   16f38:	29400204 	addi	r5,r5,8
   16f3c:	10800054 	ori	r2,r2,1
   16f40:	18800115 	stw	r2,4(r3)
   16f44:	00148500 	call	14850 <_free_r>
   16f48:	003fd606 	br	16ea4 <_realloc_r+0x170>
   16f4c:	38c0330e 	bge	r7,r3,1701c <_realloc_r+0x2e8>
   16f50:	900b883a 	mov	r5,r18
   16f54:	a809883a 	mov	r4,r21
   16f58:	00153e80 	call	153e8 <_malloc_r>
   16f5c:	1025883a 	mov	r18,r2
   16f60:	10001626 	beq	r2,zero,16fbc <_realloc_r+0x288>
   16f64:	80bfff17 	ldw	r2,-4(r16)
   16f68:	00ffff84 	movi	r3,-2
   16f6c:	913ffe04 	addi	r4,r18,-8
   16f70:	10c6703a 	and	r3,r2,r3
   16f74:	b0c7883a 	add	r3,r22,r3
   16f78:	20c09926 	beq	r4,r3,171e0 <_realloc_r+0x4ac>
   16f7c:	99bfff04 	addi	r6,r19,-4
   16f80:	00800904 	movi	r2,36
   16f84:	11806436 	bltu	r2,r6,17118 <_realloc_r+0x3e4>
   16f88:	00c004c4 	movi	r3,19
   16f8c:	19804036 	bltu	r3,r6,17090 <_realloc_r+0x35c>
   16f90:	9005883a 	mov	r2,r18
   16f94:	8007883a 	mov	r3,r16
   16f98:	19000017 	ldw	r4,0(r3)
   16f9c:	11000015 	stw	r4,0(r2)
   16fa0:	19000117 	ldw	r4,4(r3)
   16fa4:	11000115 	stw	r4,4(r2)
   16fa8:	18c00217 	ldw	r3,8(r3)
   16fac:	10c00215 	stw	r3,8(r2)
   16fb0:	a809883a 	mov	r4,r21
   16fb4:	800b883a 	mov	r5,r16
   16fb8:	00148500 	call	14850 <_free_r>
   16fbc:	a809883a 	mov	r4,r21
   16fc0:	0018fc80 	call	18fc8 <__malloc_unlock>
   16fc4:	003fba06 	br	16eb0 <_realloc_r+0x17c>
   16fc8:	300b883a 	mov	r5,r6
   16fcc:	dfc00a17 	ldw	ra,40(sp)
   16fd0:	df000917 	ldw	fp,36(sp)
   16fd4:	ddc00817 	ldw	r23,32(sp)
   16fd8:	dd800717 	ldw	r22,28(sp)
   16fdc:	dd400617 	ldw	r21,24(sp)
   16fe0:	dd000517 	ldw	r20,20(sp)
   16fe4:	dcc00417 	ldw	r19,16(sp)
   16fe8:	dc800317 	ldw	r18,12(sp)
   16fec:	dc400217 	ldw	r17,8(sp)
   16ff0:	dc000117 	ldw	r16,4(sp)
   16ff4:	dec00b04 	addi	sp,sp,44
   16ff8:	00153e81 	jmpi	153e8 <_malloc_r>
   16ffc:	29800117 	ldw	r6,4(r5)
   17000:	013fff04 	movi	r4,-4
   17004:	89c00404 	addi	r7,r17,16
   17008:	310c703a 	and	r6,r6,r4
   1700c:	34c9883a 	add	r4,r6,r19
   17010:	21c0340e 	bge	r4,r7,170e4 <_realloc_r+0x3b0>
   17014:	2809883a 	mov	r4,r5
   17018:	003f7106 	br	16de0 <_realloc_r+0xac>
   1701c:	b8800317 	ldw	r2,12(r23)
   17020:	b8c00217 	ldw	r3,8(r23)
   17024:	99bfff04 	addi	r6,r19,-4
   17028:	01000904 	movi	r4,36
   1702c:	18800315 	stw	r2,12(r3)
   17030:	10c00215 	stw	r3,8(r2)
   17034:	bc800204 	addi	r18,r23,8
   17038:	21807836 	bltu	r4,r6,1721c <_realloc_r+0x4e8>
   1703c:	008004c4 	movi	r2,19
   17040:	1180732e 	bgeu	r2,r6,17210 <_realloc_r+0x4dc>
   17044:	80800017 	ldw	r2,0(r16)
   17048:	b8800215 	stw	r2,8(r23)
   1704c:	80800117 	ldw	r2,4(r16)
   17050:	b8800315 	stw	r2,12(r23)
   17054:	008006c4 	movi	r2,27
   17058:	11808936 	bltu	r2,r6,17280 <_realloc_r+0x54c>
   1705c:	b8800404 	addi	r2,r23,16
   17060:	80c00204 	addi	r3,r16,8
   17064:	19000017 	ldw	r4,0(r3)
   17068:	9021883a 	mov	r16,r18
   1706c:	3829883a 	mov	r20,r7
   17070:	11000015 	stw	r4,0(r2)
   17074:	19000117 	ldw	r4,4(r3)
   17078:	b82d883a 	mov	r22,r23
   1707c:	11000115 	stw	r4,4(r2)
   17080:	18c00217 	ldw	r3,8(r3)
   17084:	10c00215 	stw	r3,8(r2)
   17088:	b8800117 	ldw	r2,4(r23)
   1708c:	003f7b06 	br	16e7c <_realloc_r+0x148>
   17090:	80c00017 	ldw	r3,0(r16)
   17094:	90c00015 	stw	r3,0(r18)
   17098:	80c00117 	ldw	r3,4(r16)
   1709c:	90c00115 	stw	r3,4(r18)
   170a0:	00c006c4 	movi	r3,27
   170a4:	19804636 	bltu	r3,r6,171c0 <_realloc_r+0x48c>
   170a8:	90800204 	addi	r2,r18,8
   170ac:	80c00204 	addi	r3,r16,8
   170b0:	003fb906 	br	16f98 <_realloc_r+0x264>
   170b4:	9005883a 	mov	r2,r18
   170b8:	8007883a 	mov	r3,r16
   170bc:	19000017 	ldw	r4,0(r3)
   170c0:	9021883a 	mov	r16,r18
   170c4:	b82d883a 	mov	r22,r23
   170c8:	11000015 	stw	r4,0(r2)
   170cc:	19000117 	ldw	r4,4(r3)
   170d0:	11000115 	stw	r4,4(r2)
   170d4:	18c00217 	ldw	r3,8(r3)
   170d8:	10c00215 	stw	r3,8(r2)
   170dc:	b8800117 	ldw	r2,4(r23)
   170e0:	003f6606 	br	16e7c <_realloc_r+0x148>
   170e4:	2445c83a 	sub	r2,r4,r17
   170e8:	b46d883a 	add	r22,r22,r17
   170ec:	10800054 	ori	r2,r2,1
   170f0:	b0800115 	stw	r2,4(r22)
   170f4:	80bfff17 	ldw	r2,-4(r16)
   170f8:	a809883a 	mov	r4,r21
   170fc:	e5800215 	stw	r22,8(fp)
   17100:	1080004c 	andi	r2,r2,1
   17104:	88a2b03a 	or	r17,r17,r2
   17108:	847fff15 	stw	r17,-4(r16)
   1710c:	0018fc80 	call	18fc8 <__malloc_unlock>
   17110:	8025883a 	mov	r18,r16
   17114:	003f6606 	br	16eb0 <_realloc_r+0x17c>
   17118:	9009883a 	mov	r4,r18
   1711c:	800b883a 	mov	r5,r16
   17120:	0015c640 	call	15c64 <memmove>
   17124:	003fa206 	br	16fb0 <_realloc_r+0x27c>
   17128:	88800404 	addi	r2,r17,16
   1712c:	a0bf8716 	blt	r20,r2,16f4c <_realloc_r+0x218>
   17130:	b8800317 	ldw	r2,12(r23)
   17134:	b8c00217 	ldw	r3,8(r23)
   17138:	99bfff04 	addi	r6,r19,-4
   1713c:	01000904 	movi	r4,36
   17140:	18800315 	stw	r2,12(r3)
   17144:	10c00215 	stw	r3,8(r2)
   17148:	bc800204 	addi	r18,r23,8
   1714c:	21806536 	bltu	r4,r6,172e4 <_realloc_r+0x5b0>
   17150:	008004c4 	movi	r2,19
   17154:	1180592e 	bgeu	r2,r6,172bc <_realloc_r+0x588>
   17158:	80800017 	ldw	r2,0(r16)
   1715c:	b8800215 	stw	r2,8(r23)
   17160:	80800117 	ldw	r2,4(r16)
   17164:	b8800315 	stw	r2,12(r23)
   17168:	008006c4 	movi	r2,27
   1716c:	11806136 	bltu	r2,r6,172f4 <_realloc_r+0x5c0>
   17170:	b8800404 	addi	r2,r23,16
   17174:	80c00204 	addi	r3,r16,8
   17178:	19000017 	ldw	r4,0(r3)
   1717c:	11000015 	stw	r4,0(r2)
   17180:	19000117 	ldw	r4,4(r3)
   17184:	11000115 	stw	r4,4(r2)
   17188:	18c00217 	ldw	r3,8(r3)
   1718c:	10c00215 	stw	r3,8(r2)
   17190:	a447c83a 	sub	r3,r20,r17
   17194:	bc45883a 	add	r2,r23,r17
   17198:	18c00054 	ori	r3,r3,1
   1719c:	10c00115 	stw	r3,4(r2)
   171a0:	b8c00117 	ldw	r3,4(r23)
   171a4:	e0800215 	stw	r2,8(fp)
   171a8:	a809883a 	mov	r4,r21
   171ac:	1880004c 	andi	r2,r3,1
   171b0:	88a2b03a 	or	r17,r17,r2
   171b4:	bc400115 	stw	r17,4(r23)
   171b8:	0018fc80 	call	18fc8 <__malloc_unlock>
   171bc:	003f3c06 	br	16eb0 <_realloc_r+0x17c>
   171c0:	80c00217 	ldw	r3,8(r16)
   171c4:	90c00215 	stw	r3,8(r18)
   171c8:	80c00317 	ldw	r3,12(r16)
   171cc:	90c00315 	stw	r3,12(r18)
   171d0:	30802426 	beq	r6,r2,17264 <_realloc_r+0x530>
   171d4:	90800404 	addi	r2,r18,16
   171d8:	80c00404 	addi	r3,r16,16
   171dc:	003f6e06 	br	16f98 <_realloc_r+0x264>
   171e0:	953fff17 	ldw	r20,-4(r18)
   171e4:	00ffff04 	movi	r3,-4
   171e8:	a0e8703a 	and	r20,r20,r3
   171ec:	a4e9883a 	add	r20,r20,r19
   171f0:	003f2206 	br	16e7c <_realloc_r+0x148>
   171f4:	800b883a 	mov	r5,r16
   171f8:	9009883a 	mov	r4,r18
   171fc:	0015c640 	call	15c64 <memmove>
   17200:	9021883a 	mov	r16,r18
   17204:	b8800117 	ldw	r2,4(r23)
   17208:	b82d883a 	mov	r22,r23
   1720c:	003f1b06 	br	16e7c <_realloc_r+0x148>
   17210:	9005883a 	mov	r2,r18
   17214:	8007883a 	mov	r3,r16
   17218:	003f9206 	br	17064 <_realloc_r+0x330>
   1721c:	800b883a 	mov	r5,r16
   17220:	9009883a 	mov	r4,r18
   17224:	d9c00015 	stw	r7,0(sp)
   17228:	0015c640 	call	15c64 <memmove>
   1722c:	d9c00017 	ldw	r7,0(sp)
   17230:	9021883a 	mov	r16,r18
   17234:	b8800117 	ldw	r2,4(r23)
   17238:	3829883a 	mov	r20,r7
   1723c:	b82d883a 	mov	r22,r23
   17240:	003f0e06 	br	16e7c <_realloc_r+0x148>
   17244:	80800217 	ldw	r2,8(r16)
   17248:	b8800415 	stw	r2,16(r23)
   1724c:	80800317 	ldw	r2,12(r16)
   17250:	b8800515 	stw	r2,20(r23)
   17254:	31001226 	beq	r6,r4,172a0 <_realloc_r+0x56c>
   17258:	b8800604 	addi	r2,r23,24
   1725c:	80c00404 	addi	r3,r16,16
   17260:	003f9606 	br	170bc <_realloc_r+0x388>
   17264:	81000417 	ldw	r4,16(r16)
   17268:	90800604 	addi	r2,r18,24
   1726c:	80c00604 	addi	r3,r16,24
   17270:	91000415 	stw	r4,16(r18)
   17274:	81000517 	ldw	r4,20(r16)
   17278:	91000515 	stw	r4,20(r18)
   1727c:	003f4606 	br	16f98 <_realloc_r+0x264>
   17280:	80800217 	ldw	r2,8(r16)
   17284:	b8800415 	stw	r2,16(r23)
   17288:	80800317 	ldw	r2,12(r16)
   1728c:	b8800515 	stw	r2,20(r23)
   17290:	31000d26 	beq	r6,r4,172c8 <_realloc_r+0x594>
   17294:	b8800604 	addi	r2,r23,24
   17298:	80c00404 	addi	r3,r16,16
   1729c:	003f7106 	br	17064 <_realloc_r+0x330>
   172a0:	81000417 	ldw	r4,16(r16)
   172a4:	b8800804 	addi	r2,r23,32
   172a8:	80c00604 	addi	r3,r16,24
   172ac:	b9000615 	stw	r4,24(r23)
   172b0:	81000517 	ldw	r4,20(r16)
   172b4:	b9000715 	stw	r4,28(r23)
   172b8:	003f8006 	br	170bc <_realloc_r+0x388>
   172bc:	9005883a 	mov	r2,r18
   172c0:	8007883a 	mov	r3,r16
   172c4:	003fac06 	br	17178 <_realloc_r+0x444>
   172c8:	81000417 	ldw	r4,16(r16)
   172cc:	b8800804 	addi	r2,r23,32
   172d0:	80c00604 	addi	r3,r16,24
   172d4:	b9000615 	stw	r4,24(r23)
   172d8:	81000517 	ldw	r4,20(r16)
   172dc:	b9000715 	stw	r4,28(r23)
   172e0:	003f6006 	br	17064 <_realloc_r+0x330>
   172e4:	9009883a 	mov	r4,r18
   172e8:	800b883a 	mov	r5,r16
   172ec:	0015c640 	call	15c64 <memmove>
   172f0:	003fa706 	br	17190 <_realloc_r+0x45c>
   172f4:	80800217 	ldw	r2,8(r16)
   172f8:	b8800415 	stw	r2,16(r23)
   172fc:	80800317 	ldw	r2,12(r16)
   17300:	b8800515 	stw	r2,20(r23)
   17304:	31000326 	beq	r6,r4,17314 <_realloc_r+0x5e0>
   17308:	b8800604 	addi	r2,r23,24
   1730c:	80c00404 	addi	r3,r16,16
   17310:	003f9906 	br	17178 <_realloc_r+0x444>
   17314:	81000417 	ldw	r4,16(r16)
   17318:	b8800804 	addi	r2,r23,32
   1731c:	80c00604 	addi	r3,r16,24
   17320:	b9000615 	stw	r4,24(r23)
   17324:	81000517 	ldw	r4,20(r16)
   17328:	b9000715 	stw	r4,28(r23)
   1732c:	003f9206 	br	17178 <_realloc_r+0x444>

00017330 <__isinfd>:
   17330:	0105c83a 	sub	r2,zero,r4
   17334:	1108b03a 	or	r4,r2,r4
   17338:	2004d7fa 	srli	r2,r4,31
   1733c:	00e00034 	movhi	r3,32768
   17340:	18ffffc4 	addi	r3,r3,-1
   17344:	28ca703a 	and	r5,r5,r3
   17348:	1144b03a 	or	r2,r2,r5
   1734c:	00dffc34 	movhi	r3,32752
   17350:	1885c83a 	sub	r2,r3,r2
   17354:	0087c83a 	sub	r3,zero,r2
   17358:	1884b03a 	or	r2,r3,r2
   1735c:	1005d7fa 	srai	r2,r2,31
   17360:	10800044 	addi	r2,r2,1
   17364:	f800283a 	ret

00017368 <__isnand>:
   17368:	0105c83a 	sub	r2,zero,r4
   1736c:	1108b03a 	or	r4,r2,r4
   17370:	2004d7fa 	srli	r2,r4,31
   17374:	00e00034 	movhi	r3,32768
   17378:	18ffffc4 	addi	r3,r3,-1
   1737c:	28ca703a 	and	r5,r5,r3
   17380:	1144b03a 	or	r2,r2,r5
   17384:	00dffc34 	movhi	r3,32752
   17388:	1885c83a 	sub	r2,r3,r2
   1738c:	1004d7fa 	srli	r2,r2,31
   17390:	f800283a 	ret

00017394 <_sbrk_r>:
   17394:	defffd04 	addi	sp,sp,-12
   17398:	dc400115 	stw	r17,4(sp)
   1739c:	dc000015 	stw	r16,0(sp)
   173a0:	2023883a 	mov	r17,r4
   173a4:	040000f4 	movhi	r16,3
   173a8:	842ed404 	addi	r16,r16,-17584
   173ac:	2809883a 	mov	r4,r5
   173b0:	dfc00215 	stw	ra,8(sp)
   173b4:	80000015 	stw	zero,0(r16)
   173b8:	00191c80 	call	191c8 <sbrk>
   173bc:	00ffffc4 	movi	r3,-1
   173c0:	10c00526 	beq	r2,r3,173d8 <_sbrk_r+0x44>
   173c4:	dfc00217 	ldw	ra,8(sp)
   173c8:	dc400117 	ldw	r17,4(sp)
   173cc:	dc000017 	ldw	r16,0(sp)
   173d0:	dec00304 	addi	sp,sp,12
   173d4:	f800283a 	ret
   173d8:	80c00017 	ldw	r3,0(r16)
   173dc:	183ff926 	beq	r3,zero,173c4 <_sbrk_r+0x30>
   173e0:	88c00015 	stw	r3,0(r17)
   173e4:	dfc00217 	ldw	ra,8(sp)
   173e8:	dc400117 	ldw	r17,4(sp)
   173ec:	dc000017 	ldw	r16,0(sp)
   173f0:	dec00304 	addi	sp,sp,12
   173f4:	f800283a 	ret

000173f8 <__sread>:
   173f8:	defffe04 	addi	sp,sp,-8
   173fc:	dc000015 	stw	r16,0(sp)
   17400:	2821883a 	mov	r16,r5
   17404:	2940038f 	ldh	r5,14(r5)
   17408:	dfc00115 	stw	ra,4(sp)
   1740c:	001794c0 	call	1794c <_read_r>
   17410:	10000716 	blt	r2,zero,17430 <__sread+0x38>
   17414:	80c01417 	ldw	r3,80(r16)
   17418:	1887883a 	add	r3,r3,r2
   1741c:	80c01415 	stw	r3,80(r16)
   17420:	dfc00117 	ldw	ra,4(sp)
   17424:	dc000017 	ldw	r16,0(sp)
   17428:	dec00204 	addi	sp,sp,8
   1742c:	f800283a 	ret
   17430:	80c0030b 	ldhu	r3,12(r16)
   17434:	18fbffcc 	andi	r3,r3,61439
   17438:	80c0030d 	sth	r3,12(r16)
   1743c:	dfc00117 	ldw	ra,4(sp)
   17440:	dc000017 	ldw	r16,0(sp)
   17444:	dec00204 	addi	sp,sp,8
   17448:	f800283a 	ret

0001744c <__swrite>:
   1744c:	2880030b 	ldhu	r2,12(r5)
   17450:	defffb04 	addi	sp,sp,-20
   17454:	dcc00315 	stw	r19,12(sp)
   17458:	10c0400c 	andi	r3,r2,256
   1745c:	18ffffcc 	andi	r3,r3,65535
   17460:	18e0001c 	xori	r3,r3,32768
   17464:	dc800215 	stw	r18,8(sp)
   17468:	dc400115 	stw	r17,4(sp)
   1746c:	dc000015 	stw	r16,0(sp)
   17470:	dfc00415 	stw	ra,16(sp)
   17474:	18e00004 	addi	r3,r3,-32768
   17478:	2821883a 	mov	r16,r5
   1747c:	2027883a 	mov	r19,r4
   17480:	3025883a 	mov	r18,r6
   17484:	3823883a 	mov	r17,r7
   17488:	18000526 	beq	r3,zero,174a0 <__swrite+0x54>
   1748c:	2940038f 	ldh	r5,14(r5)
   17490:	000d883a 	mov	r6,zero
   17494:	01c00084 	movi	r7,2
   17498:	00178e00 	call	178e0 <_lseek_r>
   1749c:	8080030b 	ldhu	r2,12(r16)
   174a0:	8140038f 	ldh	r5,14(r16)
   174a4:	10bbffcc 	andi	r2,r2,61439
   174a8:	9809883a 	mov	r4,r19
   174ac:	900d883a 	mov	r6,r18
   174b0:	880f883a 	mov	r7,r17
   174b4:	8080030d 	sth	r2,12(r16)
   174b8:	dfc00417 	ldw	ra,16(sp)
   174bc:	dcc00317 	ldw	r19,12(sp)
   174c0:	dc800217 	ldw	r18,8(sp)
   174c4:	dc400117 	ldw	r17,4(sp)
   174c8:	dc000017 	ldw	r16,0(sp)
   174cc:	dec00504 	addi	sp,sp,20
   174d0:	00175381 	jmpi	17538 <_write_r>

000174d4 <__sseek>:
   174d4:	defffe04 	addi	sp,sp,-8
   174d8:	dc000015 	stw	r16,0(sp)
   174dc:	2821883a 	mov	r16,r5
   174e0:	2940038f 	ldh	r5,14(r5)
   174e4:	dfc00115 	stw	ra,4(sp)
   174e8:	00178e00 	call	178e0 <_lseek_r>
   174ec:	00ffffc4 	movi	r3,-1
   174f0:	10c00826 	beq	r2,r3,17514 <__sseek+0x40>
   174f4:	80c0030b 	ldhu	r3,12(r16)
   174f8:	80801415 	stw	r2,80(r16)
   174fc:	18c40014 	ori	r3,r3,4096
   17500:	80c0030d 	sth	r3,12(r16)
   17504:	dfc00117 	ldw	ra,4(sp)
   17508:	dc000017 	ldw	r16,0(sp)
   1750c:	dec00204 	addi	sp,sp,8
   17510:	f800283a 	ret
   17514:	80c0030b 	ldhu	r3,12(r16)
   17518:	18fbffcc 	andi	r3,r3,61439
   1751c:	80c0030d 	sth	r3,12(r16)
   17520:	dfc00117 	ldw	ra,4(sp)
   17524:	dc000017 	ldw	r16,0(sp)
   17528:	dec00204 	addi	sp,sp,8
   1752c:	f800283a 	ret

00017530 <__sclose>:
   17530:	2940038f 	ldh	r5,14(r5)
   17534:	00176601 	jmpi	17660 <_close_r>

00017538 <_write_r>:
   17538:	defffd04 	addi	sp,sp,-12
   1753c:	dc400115 	stw	r17,4(sp)
   17540:	dc000015 	stw	r16,0(sp)
   17544:	2023883a 	mov	r17,r4
   17548:	040000f4 	movhi	r16,3
   1754c:	842ed404 	addi	r16,r16,-17584
   17550:	2809883a 	mov	r4,r5
   17554:	300b883a 	mov	r5,r6
   17558:	380d883a 	mov	r6,r7
   1755c:	dfc00215 	stw	ra,8(sp)
   17560:	80000015 	stw	zero,0(r16)
   17564:	00195700 	call	19570 <write>
   17568:	00ffffc4 	movi	r3,-1
   1756c:	10c00526 	beq	r2,r3,17584 <_write_r+0x4c>
   17570:	dfc00217 	ldw	ra,8(sp)
   17574:	dc400117 	ldw	r17,4(sp)
   17578:	dc000017 	ldw	r16,0(sp)
   1757c:	dec00304 	addi	sp,sp,12
   17580:	f800283a 	ret
   17584:	80c00017 	ldw	r3,0(r16)
   17588:	183ff926 	beq	r3,zero,17570 <_write_r+0x38>
   1758c:	88c00015 	stw	r3,0(r17)
   17590:	dfc00217 	ldw	ra,8(sp)
   17594:	dc400117 	ldw	r17,4(sp)
   17598:	dc000017 	ldw	r16,0(sp)
   1759c:	dec00304 	addi	sp,sp,12
   175a0:	f800283a 	ret

000175a4 <_calloc_r>:
   175a4:	314b383a 	mul	r5,r6,r5
   175a8:	defffe04 	addi	sp,sp,-8
   175ac:	dc000015 	stw	r16,0(sp)
   175b0:	dfc00115 	stw	ra,4(sp)
   175b4:	00153e80 	call	153e8 <_malloc_r>
   175b8:	1021883a 	mov	r16,r2
   175bc:	10000c26 	beq	r2,zero,175f0 <_calloc_r+0x4c>
   175c0:	11bfff17 	ldw	r6,-4(r2)
   175c4:	00ffff04 	movi	r3,-4
   175c8:	00800904 	movi	r2,36
   175cc:	30cc703a 	and	r6,r6,r3
   175d0:	30cd883a 	add	r6,r6,r3
   175d4:	11801436 	bltu	r2,r6,17628 <_calloc_r+0x84>
   175d8:	00c004c4 	movi	r3,19
   175dc:	19800936 	bltu	r3,r6,17604 <_calloc_r+0x60>
   175e0:	8005883a 	mov	r2,r16
   175e4:	10000015 	stw	zero,0(r2)
   175e8:	10000115 	stw	zero,4(r2)
   175ec:	10000215 	stw	zero,8(r2)
   175f0:	8005883a 	mov	r2,r16
   175f4:	dfc00117 	ldw	ra,4(sp)
   175f8:	dc000017 	ldw	r16,0(sp)
   175fc:	dec00204 	addi	sp,sp,8
   17600:	f800283a 	ret
   17604:	80000015 	stw	zero,0(r16)
   17608:	80000115 	stw	zero,4(r16)
   1760c:	00c006c4 	movi	r3,27
   17610:	19800d2e 	bgeu	r3,r6,17648 <_calloc_r+0xa4>
   17614:	80000215 	stw	zero,8(r16)
   17618:	80000315 	stw	zero,12(r16)
   1761c:	30800c26 	beq	r6,r2,17650 <_calloc_r+0xac>
   17620:	80800404 	addi	r2,r16,16
   17624:	003fef06 	br	175e4 <_calloc_r+0x40>
   17628:	8009883a 	mov	r4,r16
   1762c:	000b883a 	mov	r5,zero
   17630:	00103300 	call	10330 <memset>
   17634:	8005883a 	mov	r2,r16
   17638:	dfc00117 	ldw	ra,4(sp)
   1763c:	dc000017 	ldw	r16,0(sp)
   17640:	dec00204 	addi	sp,sp,8
   17644:	f800283a 	ret
   17648:	80800204 	addi	r2,r16,8
   1764c:	003fe506 	br	175e4 <_calloc_r+0x40>
   17650:	80000415 	stw	zero,16(r16)
   17654:	80000515 	stw	zero,20(r16)
   17658:	80800604 	addi	r2,r16,24
   1765c:	003fe106 	br	175e4 <_calloc_r+0x40>

00017660 <_close_r>:
   17660:	defffd04 	addi	sp,sp,-12
   17664:	dc400115 	stw	r17,4(sp)
   17668:	dc000015 	stw	r16,0(sp)
   1766c:	2023883a 	mov	r17,r4
   17670:	040000f4 	movhi	r16,3
   17674:	842ed404 	addi	r16,r16,-17584
   17678:	2809883a 	mov	r4,r5
   1767c:	dfc00215 	stw	ra,8(sp)
   17680:	80000015 	stw	zero,0(r16)
   17684:	0018a440 	call	18a44 <close>
   17688:	00ffffc4 	movi	r3,-1
   1768c:	10c00526 	beq	r2,r3,176a4 <_close_r+0x44>
   17690:	dfc00217 	ldw	ra,8(sp)
   17694:	dc400117 	ldw	r17,4(sp)
   17698:	dc000017 	ldw	r16,0(sp)
   1769c:	dec00304 	addi	sp,sp,12
   176a0:	f800283a 	ret
   176a4:	80c00017 	ldw	r3,0(r16)
   176a8:	183ff926 	beq	r3,zero,17690 <_close_r+0x30>
   176ac:	88c00015 	stw	r3,0(r17)
   176b0:	dfc00217 	ldw	ra,8(sp)
   176b4:	dc400117 	ldw	r17,4(sp)
   176b8:	dc000017 	ldw	r16,0(sp)
   176bc:	dec00304 	addi	sp,sp,12
   176c0:	f800283a 	ret

000176c4 <_fclose_r>:
   176c4:	defffc04 	addi	sp,sp,-16
   176c8:	dc400115 	stw	r17,4(sp)
   176cc:	dc000015 	stw	r16,0(sp)
   176d0:	dfc00315 	stw	ra,12(sp)
   176d4:	dc800215 	stw	r18,8(sp)
   176d8:	2821883a 	mov	r16,r5
   176dc:	2023883a 	mov	r17,r4
   176e0:	28003426 	beq	r5,zero,177b4 <_fclose_r+0xf0>
   176e4:	00146d40 	call	146d4 <__sfp_lock_acquire>
   176e8:	88000226 	beq	r17,zero,176f4 <_fclose_r+0x30>
   176ec:	88800e17 	ldw	r2,56(r17)
   176f0:	10003826 	beq	r2,zero,177d4 <_fclose_r+0x110>
   176f4:	8080030f 	ldh	r2,12(r16)
   176f8:	10002526 	beq	r2,zero,17790 <_fclose_r+0xcc>
   176fc:	8809883a 	mov	r4,r17
   17700:	800b883a 	mov	r5,r16
   17704:	00142240 	call	14224 <_fflush_r>
   17708:	1025883a 	mov	r18,r2
   1770c:	80800b17 	ldw	r2,44(r16)
   17710:	10000426 	beq	r2,zero,17724 <_fclose_r+0x60>
   17714:	81400717 	ldw	r5,28(r16)
   17718:	8809883a 	mov	r4,r17
   1771c:	103ee83a 	callr	r2
   17720:	10003516 	blt	r2,zero,177f8 <_fclose_r+0x134>
   17724:	8080030b 	ldhu	r2,12(r16)
   17728:	1080200c 	andi	r2,r2,128
   1772c:	10bfffcc 	andi	r2,r2,65535
   17730:	10a0001c 	xori	r2,r2,32768
   17734:	10a00004 	addi	r2,r2,-32768
   17738:	10002b1e 	bne	r2,zero,177e8 <_fclose_r+0x124>
   1773c:	81400c17 	ldw	r5,48(r16)
   17740:	28000526 	beq	r5,zero,17758 <_fclose_r+0x94>
   17744:	80801004 	addi	r2,r16,64
   17748:	28800226 	beq	r5,r2,17754 <_fclose_r+0x90>
   1774c:	8809883a 	mov	r4,r17
   17750:	00148500 	call	14850 <_free_r>
   17754:	80000c15 	stw	zero,48(r16)
   17758:	81401117 	ldw	r5,68(r16)
   1775c:	28000326 	beq	r5,zero,1776c <_fclose_r+0xa8>
   17760:	8809883a 	mov	r4,r17
   17764:	00148500 	call	14850 <_free_r>
   17768:	80001115 	stw	zero,68(r16)
   1776c:	8000030d 	sth	zero,12(r16)
   17770:	00146d80 	call	146d8 <__sfp_lock_release>
   17774:	9005883a 	mov	r2,r18
   17778:	dfc00317 	ldw	ra,12(sp)
   1777c:	dc800217 	ldw	r18,8(sp)
   17780:	dc400117 	ldw	r17,4(sp)
   17784:	dc000017 	ldw	r16,0(sp)
   17788:	dec00404 	addi	sp,sp,16
   1778c:	f800283a 	ret
   17790:	00146d80 	call	146d8 <__sfp_lock_release>
   17794:	0025883a 	mov	r18,zero
   17798:	9005883a 	mov	r2,r18
   1779c:	dfc00317 	ldw	ra,12(sp)
   177a0:	dc800217 	ldw	r18,8(sp)
   177a4:	dc400117 	ldw	r17,4(sp)
   177a8:	dc000017 	ldw	r16,0(sp)
   177ac:	dec00404 	addi	sp,sp,16
   177b0:	f800283a 	ret
   177b4:	0025883a 	mov	r18,zero
   177b8:	9005883a 	mov	r2,r18
   177bc:	dfc00317 	ldw	ra,12(sp)
   177c0:	dc800217 	ldw	r18,8(sp)
   177c4:	dc400117 	ldw	r17,4(sp)
   177c8:	dc000017 	ldw	r16,0(sp)
   177cc:	dec00404 	addi	sp,sp,16
   177d0:	f800283a 	ret
   177d4:	8809883a 	mov	r4,r17
   177d8:	00144cc0 	call	144cc <__sinit>
   177dc:	8080030f 	ldh	r2,12(r16)
   177e0:	103fc61e 	bne	r2,zero,176fc <_fclose_r+0x38>
   177e4:	003fea06 	br	17790 <_fclose_r+0xcc>
   177e8:	81400417 	ldw	r5,16(r16)
   177ec:	8809883a 	mov	r4,r17
   177f0:	00148500 	call	14850 <_free_r>
   177f4:	003fd106 	br	1773c <_fclose_r+0x78>
   177f8:	04bfffc4 	movi	r18,-1
   177fc:	003fc906 	br	17724 <_fclose_r+0x60>

00017800 <fclose>:
   17800:	008000f4 	movhi	r2,3
   17804:	10a60a04 	addi	r2,r2,-26584
   17808:	200b883a 	mov	r5,r4
   1780c:	11000017 	ldw	r4,0(r2)
   17810:	00176c41 	jmpi	176c4 <_fclose_r>

00017814 <_fstat_r>:
   17814:	defffd04 	addi	sp,sp,-12
   17818:	dc400115 	stw	r17,4(sp)
   1781c:	dc000015 	stw	r16,0(sp)
   17820:	2023883a 	mov	r17,r4
   17824:	040000f4 	movhi	r16,3
   17828:	842ed404 	addi	r16,r16,-17584
   1782c:	2809883a 	mov	r4,r5
   17830:	300b883a 	mov	r5,r6
   17834:	dfc00215 	stw	ra,8(sp)
   17838:	80000015 	stw	zero,0(r16)
   1783c:	0018b880 	call	18b88 <fstat>
   17840:	00ffffc4 	movi	r3,-1
   17844:	10c00526 	beq	r2,r3,1785c <_fstat_r+0x48>
   17848:	dfc00217 	ldw	ra,8(sp)
   1784c:	dc400117 	ldw	r17,4(sp)
   17850:	dc000017 	ldw	r16,0(sp)
   17854:	dec00304 	addi	sp,sp,12
   17858:	f800283a 	ret
   1785c:	80c00017 	ldw	r3,0(r16)
   17860:	183ff926 	beq	r3,zero,17848 <_fstat_r+0x34>
   17864:	88c00015 	stw	r3,0(r17)
   17868:	dfc00217 	ldw	ra,8(sp)
   1786c:	dc400117 	ldw	r17,4(sp)
   17870:	dc000017 	ldw	r16,0(sp)
   17874:	dec00304 	addi	sp,sp,12
   17878:	f800283a 	ret

0001787c <_isatty_r>:
   1787c:	defffd04 	addi	sp,sp,-12
   17880:	dc400115 	stw	r17,4(sp)
   17884:	dc000015 	stw	r16,0(sp)
   17888:	2023883a 	mov	r17,r4
   1788c:	040000f4 	movhi	r16,3
   17890:	842ed404 	addi	r16,r16,-17584
   17894:	2809883a 	mov	r4,r5
   17898:	dfc00215 	stw	ra,8(sp)
   1789c:	80000015 	stw	zero,0(r16)
   178a0:	0018c840 	call	18c84 <isatty>
   178a4:	00ffffc4 	movi	r3,-1
   178a8:	10c00526 	beq	r2,r3,178c0 <_isatty_r+0x44>
   178ac:	dfc00217 	ldw	ra,8(sp)
   178b0:	dc400117 	ldw	r17,4(sp)
   178b4:	dc000017 	ldw	r16,0(sp)
   178b8:	dec00304 	addi	sp,sp,12
   178bc:	f800283a 	ret
   178c0:	80c00017 	ldw	r3,0(r16)
   178c4:	183ff926 	beq	r3,zero,178ac <_isatty_r+0x30>
   178c8:	88c00015 	stw	r3,0(r17)
   178cc:	dfc00217 	ldw	ra,8(sp)
   178d0:	dc400117 	ldw	r17,4(sp)
   178d4:	dc000017 	ldw	r16,0(sp)
   178d8:	dec00304 	addi	sp,sp,12
   178dc:	f800283a 	ret

000178e0 <_lseek_r>:
   178e0:	defffd04 	addi	sp,sp,-12
   178e4:	dc400115 	stw	r17,4(sp)
   178e8:	dc000015 	stw	r16,0(sp)
   178ec:	2023883a 	mov	r17,r4
   178f0:	040000f4 	movhi	r16,3
   178f4:	842ed404 	addi	r16,r16,-17584
   178f8:	2809883a 	mov	r4,r5
   178fc:	300b883a 	mov	r5,r6
   17900:	380d883a 	mov	r6,r7
   17904:	dfc00215 	stw	ra,8(sp)
   17908:	80000015 	stw	zero,0(r16)
   1790c:	0018e600 	call	18e60 <lseek>
   17910:	00ffffc4 	movi	r3,-1
   17914:	10c00526 	beq	r2,r3,1792c <_lseek_r+0x4c>
   17918:	dfc00217 	ldw	ra,8(sp)
   1791c:	dc400117 	ldw	r17,4(sp)
   17920:	dc000017 	ldw	r16,0(sp)
   17924:	dec00304 	addi	sp,sp,12
   17928:	f800283a 	ret
   1792c:	80c00017 	ldw	r3,0(r16)
   17930:	183ff926 	beq	r3,zero,17918 <_lseek_r+0x38>
   17934:	88c00015 	stw	r3,0(r17)
   17938:	dfc00217 	ldw	ra,8(sp)
   1793c:	dc400117 	ldw	r17,4(sp)
   17940:	dc000017 	ldw	r16,0(sp)
   17944:	dec00304 	addi	sp,sp,12
   17948:	f800283a 	ret

0001794c <_read_r>:
   1794c:	defffd04 	addi	sp,sp,-12
   17950:	dc400115 	stw	r17,4(sp)
   17954:	dc000015 	stw	r16,0(sp)
   17958:	2023883a 	mov	r17,r4
   1795c:	040000f4 	movhi	r16,3
   17960:	842ed404 	addi	r16,r16,-17584
   17964:	2809883a 	mov	r4,r5
   17968:	300b883a 	mov	r5,r6
   1796c:	380d883a 	mov	r6,r7
   17970:	dfc00215 	stw	ra,8(sp)
   17974:	80000015 	stw	zero,0(r16)
   17978:	00190380 	call	19038 <read>
   1797c:	00ffffc4 	movi	r3,-1
   17980:	10c00526 	beq	r2,r3,17998 <_read_r+0x4c>
   17984:	dfc00217 	ldw	ra,8(sp)
   17988:	dc400117 	ldw	r17,4(sp)
   1798c:	dc000017 	ldw	r16,0(sp)
   17990:	dec00304 	addi	sp,sp,12
   17994:	f800283a 	ret
   17998:	80c00017 	ldw	r3,0(r16)
   1799c:	183ff926 	beq	r3,zero,17984 <_read_r+0x38>
   179a0:	88c00015 	stw	r3,0(r17)
   179a4:	dfc00217 	ldw	ra,8(sp)
   179a8:	dc400117 	ldw	r17,4(sp)
   179ac:	dc000017 	ldw	r16,0(sp)
   179b0:	dec00304 	addi	sp,sp,12
   179b4:	f800283a 	ret

000179b8 <__udivdi3>:
   179b8:	defff504 	addi	sp,sp,-44
   179bc:	dd000515 	stw	r20,20(sp)
   179c0:	dcc00415 	stw	r19,16(sp)
   179c4:	dc800315 	stw	r18,12(sp)
   179c8:	dc400215 	stw	r17,8(sp)
   179cc:	dc000115 	stw	r16,4(sp)
   179d0:	dfc00a15 	stw	ra,40(sp)
   179d4:	df000915 	stw	fp,36(sp)
   179d8:	ddc00815 	stw	r23,32(sp)
   179dc:	dd800715 	stw	r22,28(sp)
   179e0:	dd400615 	stw	r21,24(sp)
   179e4:	2025883a 	mov	r18,r4
   179e8:	2823883a 	mov	r17,r5
   179ec:	3021883a 	mov	r16,r6
   179f0:	2027883a 	mov	r19,r4
   179f4:	2829883a 	mov	r20,r5
   179f8:	3800401e 	bne	r7,zero,17afc <__udivdi3+0x144>
   179fc:	2980602e 	bgeu	r5,r6,17b80 <__udivdi3+0x1c8>
   17a00:	00bfffd4 	movui	r2,65535
   17a04:	1180aa36 	bltu	r2,r6,17cb0 <__udivdi3+0x2f8>
   17a08:	00803fc4 	movi	r2,255
   17a0c:	11814436 	bltu	r2,r6,17f20 <__udivdi3+0x568>
   17a10:	0005883a 	mov	r2,zero
   17a14:	0007883a 	mov	r3,zero
   17a18:	3084d83a 	srl	r2,r6,r2
   17a1c:	010000b4 	movhi	r4,2
   17a20:	2117eb04 	addi	r4,r4,24492
   17a24:	2085883a 	add	r2,r4,r2
   17a28:	10800003 	ldbu	r2,0(r2)
   17a2c:	10c7883a 	add	r3,r2,r3
   17a30:	00800804 	movi	r2,32
   17a34:	10c5c83a 	sub	r2,r2,r3
   17a38:	10000526 	beq	r2,zero,17a50 <__udivdi3+0x98>
   17a3c:	88a2983a 	sll	r17,r17,r2
   17a40:	90c6d83a 	srl	r3,r18,r3
   17a44:	30a0983a 	sll	r16,r6,r2
   17a48:	90a6983a 	sll	r19,r18,r2
   17a4c:	88e8b03a 	or	r20,r17,r3
   17a50:	8022d43a 	srli	r17,r16,16
   17a54:	a009883a 	mov	r4,r20
   17a58:	857fffcc 	andi	r21,r16,65535
   17a5c:	880b883a 	mov	r5,r17
   17a60:	00188800 	call	18880 <__umodsi3>
   17a64:	a009883a 	mov	r4,r20
   17a68:	880b883a 	mov	r5,r17
   17a6c:	102d883a 	mov	r22,r2
   17a70:	00188780 	call	18878 <__udivsi3>
   17a74:	b02c943a 	slli	r22,r22,16
   17a78:	9806d43a 	srli	r3,r19,16
   17a7c:	1549383a 	mul	r4,r2,r21
   17a80:	1025883a 	mov	r18,r2
   17a84:	b0c6b03a 	or	r3,r22,r3
   17a88:	1900052e 	bgeu	r3,r4,17aa0 <__udivdi3+0xe8>
   17a8c:	1c07883a 	add	r3,r3,r16
   17a90:	10bfffc4 	addi	r2,r2,-1
   17a94:	1c000136 	bltu	r3,r16,17a9c <__udivdi3+0xe4>
   17a98:	19013636 	bltu	r3,r4,17f74 <__udivdi3+0x5bc>
   17a9c:	1025883a 	mov	r18,r2
   17aa0:	1929c83a 	sub	r20,r3,r4
   17aa4:	a009883a 	mov	r4,r20
   17aa8:	880b883a 	mov	r5,r17
   17aac:	00188800 	call	18880 <__umodsi3>
   17ab0:	102d883a 	mov	r22,r2
   17ab4:	a009883a 	mov	r4,r20
   17ab8:	880b883a 	mov	r5,r17
   17abc:	00188780 	call	18878 <__udivsi3>
   17ac0:	b02c943a 	slli	r22,r22,16
   17ac4:	156b383a 	mul	r21,r2,r21
   17ac8:	9cffffcc 	andi	r19,r19,65535
   17acc:	b4e6b03a 	or	r19,r22,r19
   17ad0:	1009883a 	mov	r4,r2
   17ad4:	9d40052e 	bgeu	r19,r21,17aec <__udivdi3+0x134>
   17ad8:	9c27883a 	add	r19,r19,r16
   17adc:	10bfffc4 	addi	r2,r2,-1
   17ae0:	9c00f736 	bltu	r19,r16,17ec0 <__udivdi3+0x508>
   17ae4:	9d40f62e 	bgeu	r19,r21,17ec0 <__udivdi3+0x508>
   17ae8:	213fff84 	addi	r4,r4,-2
   17aec:	9004943a 	slli	r2,r18,16
   17af0:	0007883a 	mov	r3,zero
   17af4:	2084b03a 	or	r2,r4,r2
   17af8:	00001506 	br	17b50 <__udivdi3+0x198>
   17afc:	29c06536 	bltu	r5,r7,17c94 <__udivdi3+0x2dc>
   17b00:	00bfffd4 	movui	r2,65535
   17b04:	11c0652e 	bgeu	r2,r7,17c9c <__udivdi3+0x2e4>
   17b08:	00804034 	movhi	r2,256
   17b0c:	10bfffc4 	addi	r2,r2,-1
   17b10:	11c0f736 	bltu	r2,r7,17ef0 <__udivdi3+0x538>
   17b14:	00c00404 	movi	r3,16
   17b18:	180b883a 	mov	r5,r3
   17b1c:	38c6d83a 	srl	r3,r7,r3
   17b20:	010000b4 	movhi	r4,2
   17b24:	2117eb04 	addi	r4,r4,24492
   17b28:	04000804 	movi	r16,32
   17b2c:	20c7883a 	add	r3,r4,r3
   17b30:	18800003 	ldbu	r2,0(r3)
   17b34:	1145883a 	add	r2,r2,r5
   17b38:	80a1c83a 	sub	r16,r16,r2
   17b3c:	8000691e 	bne	r16,zero,17ce4 <__udivdi3+0x32c>
   17b40:	0007883a 	mov	r3,zero
   17b44:	3c406536 	bltu	r7,r17,17cdc <__udivdi3+0x324>
   17b48:	9180642e 	bgeu	r18,r6,17cdc <__udivdi3+0x324>
   17b4c:	0005883a 	mov	r2,zero
   17b50:	dfc00a17 	ldw	ra,40(sp)
   17b54:	df000917 	ldw	fp,36(sp)
   17b58:	ddc00817 	ldw	r23,32(sp)
   17b5c:	dd800717 	ldw	r22,28(sp)
   17b60:	dd400617 	ldw	r21,24(sp)
   17b64:	dd000517 	ldw	r20,20(sp)
   17b68:	dcc00417 	ldw	r19,16(sp)
   17b6c:	dc800317 	ldw	r18,12(sp)
   17b70:	dc400217 	ldw	r17,8(sp)
   17b74:	dc000117 	ldw	r16,4(sp)
   17b78:	dec00b04 	addi	sp,sp,44
   17b7c:	f800283a 	ret
   17b80:	3000041e 	bne	r6,zero,17b94 <__udivdi3+0x1dc>
   17b84:	01000044 	movi	r4,1
   17b88:	000b883a 	mov	r5,zero
   17b8c:	00188780 	call	18878 <__udivsi3>
   17b90:	1021883a 	mov	r16,r2
   17b94:	00bfffd4 	movui	r2,65535
   17b98:	14004b2e 	bgeu	r2,r16,17cc8 <__udivdi3+0x310>
   17b9c:	00804034 	movhi	r2,256
   17ba0:	10bfffc4 	addi	r2,r2,-1
   17ba4:	1400d836 	bltu	r2,r16,17f08 <__udivdi3+0x550>
   17ba8:	00800404 	movi	r2,16
   17bac:	1007883a 	mov	r3,r2
   17bb0:	8084d83a 	srl	r2,r16,r2
   17bb4:	010000b4 	movhi	r4,2
   17bb8:	2117eb04 	addi	r4,r4,24492
   17bbc:	2085883a 	add	r2,r4,r2
   17bc0:	10800003 	ldbu	r2,0(r2)
   17bc4:	10c7883a 	add	r3,r2,r3
   17bc8:	00800804 	movi	r2,32
   17bcc:	10c5c83a 	sub	r2,r2,r3
   17bd0:	1000891e 	bne	r2,zero,17df8 <__udivdi3+0x440>
   17bd4:	8028d43a 	srli	r20,r16,16
   17bd8:	8c23c83a 	sub	r17,r17,r16
   17bdc:	84bfffcc 	andi	r18,r16,65535
   17be0:	00c00044 	movi	r3,1
   17be4:	8809883a 	mov	r4,r17
   17be8:	a00b883a 	mov	r5,r20
   17bec:	d8c00015 	stw	r3,0(sp)
   17bf0:	00188800 	call	18880 <__umodsi3>
   17bf4:	8809883a 	mov	r4,r17
   17bf8:	a00b883a 	mov	r5,r20
   17bfc:	102b883a 	mov	r21,r2
   17c00:	00188780 	call	18878 <__udivsi3>
   17c04:	a82a943a 	slli	r21,r21,16
   17c08:	9808d43a 	srli	r4,r19,16
   17c0c:	148b383a 	mul	r5,r2,r18
   17c10:	1023883a 	mov	r17,r2
   17c14:	a908b03a 	or	r4,r21,r4
   17c18:	d8c00017 	ldw	r3,0(sp)
   17c1c:	2140052e 	bgeu	r4,r5,17c34 <__udivdi3+0x27c>
   17c20:	2409883a 	add	r4,r4,r16
   17c24:	10bfffc4 	addi	r2,r2,-1
   17c28:	24000136 	bltu	r4,r16,17c30 <__udivdi3+0x278>
   17c2c:	2140ce36 	bltu	r4,r5,17f68 <__udivdi3+0x5b0>
   17c30:	1023883a 	mov	r17,r2
   17c34:	216bc83a 	sub	r21,r4,r5
   17c38:	a809883a 	mov	r4,r21
   17c3c:	a00b883a 	mov	r5,r20
   17c40:	d8c00015 	stw	r3,0(sp)
   17c44:	00188800 	call	18880 <__umodsi3>
   17c48:	102d883a 	mov	r22,r2
   17c4c:	a809883a 	mov	r4,r21
   17c50:	a00b883a 	mov	r5,r20
   17c54:	00188780 	call	18878 <__udivsi3>
   17c58:	b02c943a 	slli	r22,r22,16
   17c5c:	14a5383a 	mul	r18,r2,r18
   17c60:	9cffffcc 	andi	r19,r19,65535
   17c64:	b4e6b03a 	or	r19,r22,r19
   17c68:	1009883a 	mov	r4,r2
   17c6c:	d8c00017 	ldw	r3,0(sp)
   17c70:	9c80052e 	bgeu	r19,r18,17c88 <__udivdi3+0x2d0>
   17c74:	9c27883a 	add	r19,r19,r16
   17c78:	10bfffc4 	addi	r2,r2,-1
   17c7c:	9c009236 	bltu	r19,r16,17ec8 <__udivdi3+0x510>
   17c80:	9c80912e 	bgeu	r19,r18,17ec8 <__udivdi3+0x510>
   17c84:	213fff84 	addi	r4,r4,-2
   17c88:	8804943a 	slli	r2,r17,16
   17c8c:	2084b03a 	or	r2,r4,r2
   17c90:	003faf06 	br	17b50 <__udivdi3+0x198>
   17c94:	0007883a 	mov	r3,zero
   17c98:	003fac06 	br	17b4c <__udivdi3+0x194>
   17c9c:	00803fc4 	movi	r2,255
   17ca0:	11c09636 	bltu	r2,r7,17efc <__udivdi3+0x544>
   17ca4:	0007883a 	mov	r3,zero
   17ca8:	000b883a 	mov	r5,zero
   17cac:	003f9b06 	br	17b1c <__udivdi3+0x164>
   17cb0:	00804034 	movhi	r2,256
   17cb4:	10bfffc4 	addi	r2,r2,-1
   17cb8:	11809636 	bltu	r2,r6,17f14 <__udivdi3+0x55c>
   17cbc:	00800404 	movi	r2,16
   17cc0:	1007883a 	mov	r3,r2
   17cc4:	003f5406 	br	17a18 <__udivdi3+0x60>
   17cc8:	00803fc4 	movi	r2,255
   17ccc:	14009736 	bltu	r2,r16,17f2c <__udivdi3+0x574>
   17cd0:	0005883a 	mov	r2,zero
   17cd4:	0007883a 	mov	r3,zero
   17cd8:	003fb506 	br	17bb0 <__udivdi3+0x1f8>
   17cdc:	00800044 	movi	r2,1
   17ce0:	003f9b06 	br	17b50 <__udivdi3+0x198>
   17ce4:	3086d83a 	srl	r3,r6,r2
   17ce8:	3c0e983a 	sll	r7,r7,r16
   17cec:	88aad83a 	srl	r21,r17,r2
   17cf0:	9084d83a 	srl	r2,r18,r2
   17cf4:	38e6b03a 	or	r19,r7,r3
   17cf8:	9828d43a 	srli	r20,r19,16
   17cfc:	8c22983a 	sll	r17,r17,r16
   17d00:	a809883a 	mov	r4,r21
   17d04:	a00b883a 	mov	r5,r20
   17d08:	342c983a 	sll	r22,r6,r16
   17d0c:	88a2b03a 	or	r17,r17,r2
   17d10:	00188800 	call	18880 <__umodsi3>
   17d14:	a809883a 	mov	r4,r21
   17d18:	a00b883a 	mov	r5,r20
   17d1c:	1039883a 	mov	fp,r2
   17d20:	00188780 	call	18878 <__udivsi3>
   17d24:	102b883a 	mov	r21,r2
   17d28:	9dffffcc 	andi	r23,r19,65535
   17d2c:	e008943a 	slli	r4,fp,16
   17d30:	8804d43a 	srli	r2,r17,16
   17d34:	adcd383a 	mul	r6,r21,r23
   17d38:	2088b03a 	or	r4,r4,r2
   17d3c:	2180042e 	bgeu	r4,r6,17d50 <__udivdi3+0x398>
   17d40:	24c9883a 	add	r4,r4,r19
   17d44:	a8bfffc4 	addi	r2,r21,-1
   17d48:	24c07f2e 	bgeu	r4,r19,17f48 <__udivdi3+0x590>
   17d4c:	102b883a 	mov	r21,r2
   17d50:	21b9c83a 	sub	fp,r4,r6
   17d54:	e009883a 	mov	r4,fp
   17d58:	a00b883a 	mov	r5,r20
   17d5c:	00188800 	call	18880 <__umodsi3>
   17d60:	e009883a 	mov	r4,fp
   17d64:	a00b883a 	mov	r5,r20
   17d68:	d8800015 	stw	r2,0(sp)
   17d6c:	00188780 	call	18878 <__udivsi3>
   17d70:	d8c00017 	ldw	r3,0(sp)
   17d74:	15cb383a 	mul	r5,r2,r23
   17d78:	8c7fffcc 	andi	r17,r17,65535
   17d7c:	1806943a 	slli	r3,r3,16
   17d80:	1009883a 	mov	r4,r2
   17d84:	1c46b03a 	or	r3,r3,r17
   17d88:	1940042e 	bgeu	r3,r5,17d9c <__udivdi3+0x3e4>
   17d8c:	1cc7883a 	add	r3,r3,r19
   17d90:	10bfffc4 	addi	r2,r2,-1
   17d94:	1cc0682e 	bgeu	r3,r19,17f38 <__udivdi3+0x580>
   17d98:	1009883a 	mov	r4,r2
   17d9c:	a804943a 	slli	r2,r21,16
   17da0:	b1ffffcc 	andi	r7,r22,65535
   17da4:	b02cd43a 	srli	r22,r22,16
   17da8:	2084b03a 	or	r2,r4,r2
   17dac:	113fffcc 	andi	r4,r2,65535
   17db0:	100cd43a 	srli	r6,r2,16
   17db4:	21d1383a 	mul	r8,r4,r7
   17db8:	2589383a 	mul	r4,r4,r22
   17dbc:	31cf383a 	mul	r7,r6,r7
   17dc0:	4012d43a 	srli	r9,r8,16
   17dc4:	1947c83a 	sub	r3,r3,r5
   17dc8:	3909883a 	add	r4,r7,r4
   17dcc:	2249883a 	add	r4,r4,r9
   17dd0:	35ad383a 	mul	r22,r6,r22
   17dd4:	21c0022e 	bgeu	r4,r7,17de0 <__udivdi3+0x428>
   17dd8:	01400074 	movhi	r5,1
   17ddc:	b16d883a 	add	r22,r22,r5
   17de0:	200ad43a 	srli	r5,r4,16
   17de4:	b16d883a 	add	r22,r22,r5
   17de8:	1d803e36 	bltu	r3,r22,17ee4 <__udivdi3+0x52c>
   17dec:	1d803826 	beq	r3,r22,17ed0 <__udivdi3+0x518>
   17df0:	0007883a 	mov	r3,zero
   17df4:	003f5606 	br	17b50 <__udivdi3+0x198>
   17df8:	80a0983a 	sll	r16,r16,r2
   17dfc:	88ead83a 	srl	r21,r17,r3
   17e00:	90c6d83a 	srl	r3,r18,r3
   17e04:	8028d43a 	srli	r20,r16,16
   17e08:	88a2983a 	sll	r17,r17,r2
   17e0c:	a809883a 	mov	r4,r21
   17e10:	a00b883a 	mov	r5,r20
   17e14:	88ecb03a 	or	r22,r17,r3
   17e18:	90a6983a 	sll	r19,r18,r2
   17e1c:	00188800 	call	18880 <__umodsi3>
   17e20:	a809883a 	mov	r4,r21
   17e24:	a00b883a 	mov	r5,r20
   17e28:	1023883a 	mov	r17,r2
   17e2c:	00188780 	call	18878 <__udivsi3>
   17e30:	102b883a 	mov	r21,r2
   17e34:	84bfffcc 	andi	r18,r16,65535
   17e38:	8808943a 	slli	r4,r17,16
   17e3c:	b004d43a 	srli	r2,r22,16
   17e40:	ac87383a 	mul	r3,r21,r18
   17e44:	2088b03a 	or	r4,r4,r2
   17e48:	20c0062e 	bgeu	r4,r3,17e64 <__udivdi3+0x4ac>
   17e4c:	2409883a 	add	r4,r4,r16
   17e50:	a8bfffc4 	addi	r2,r21,-1
   17e54:	24004236 	bltu	r4,r16,17f60 <__udivdi3+0x5a8>
   17e58:	20c0412e 	bgeu	r4,r3,17f60 <__udivdi3+0x5a8>
   17e5c:	ad7fff84 	addi	r21,r21,-2
   17e60:	2409883a 	add	r4,r4,r16
   17e64:	20efc83a 	sub	r23,r4,r3
   17e68:	b809883a 	mov	r4,r23
   17e6c:	a00b883a 	mov	r5,r20
   17e70:	00188800 	call	18880 <__umodsi3>
   17e74:	1023883a 	mov	r17,r2
   17e78:	a00b883a 	mov	r5,r20
   17e7c:	b809883a 	mov	r4,r23
   17e80:	00188780 	call	18878 <__udivsi3>
   17e84:	8822943a 	slli	r17,r17,16
   17e88:	148b383a 	mul	r5,r2,r18
   17e8c:	b5bfffcc 	andi	r22,r22,65535
   17e90:	8da2b03a 	or	r17,r17,r22
   17e94:	8940062e 	bgeu	r17,r5,17eb0 <__udivdi3+0x4f8>
   17e98:	8c23883a 	add	r17,r17,r16
   17e9c:	10ffffc4 	addi	r3,r2,-1
   17ea0:	8c002d36 	bltu	r17,r16,17f58 <__udivdi3+0x5a0>
   17ea4:	89402c2e 	bgeu	r17,r5,17f58 <__udivdi3+0x5a0>
   17ea8:	10bfff84 	addi	r2,r2,-2
   17eac:	8c23883a 	add	r17,r17,r16
   17eb0:	a806943a 	slli	r3,r21,16
   17eb4:	8963c83a 	sub	r17,r17,r5
   17eb8:	10c6b03a 	or	r3,r2,r3
   17ebc:	003f4906 	br	17be4 <__udivdi3+0x22c>
   17ec0:	1009883a 	mov	r4,r2
   17ec4:	003f0906 	br	17aec <__udivdi3+0x134>
   17ec8:	1009883a 	mov	r4,r2
   17ecc:	003f6e06 	br	17c88 <__udivdi3+0x2d0>
   17ed0:	2008943a 	slli	r4,r4,16
   17ed4:	9420983a 	sll	r16,r18,r16
   17ed8:	423fffcc 	andi	r8,r8,65535
   17edc:	2209883a 	add	r4,r4,r8
   17ee0:	813fc32e 	bgeu	r16,r4,17df0 <__udivdi3+0x438>
   17ee4:	10bfffc4 	addi	r2,r2,-1
   17ee8:	0007883a 	mov	r3,zero
   17eec:	003f1806 	br	17b50 <__udivdi3+0x198>
   17ef0:	00c00604 	movi	r3,24
   17ef4:	180b883a 	mov	r5,r3
   17ef8:	003f0806 	br	17b1c <__udivdi3+0x164>
   17efc:	00c00204 	movi	r3,8
   17f00:	180b883a 	mov	r5,r3
   17f04:	003f0506 	br	17b1c <__udivdi3+0x164>
   17f08:	00800604 	movi	r2,24
   17f0c:	1007883a 	mov	r3,r2
   17f10:	003f2706 	br	17bb0 <__udivdi3+0x1f8>
   17f14:	00800604 	movi	r2,24
   17f18:	1007883a 	mov	r3,r2
   17f1c:	003ebe06 	br	17a18 <__udivdi3+0x60>
   17f20:	00800204 	movi	r2,8
   17f24:	1007883a 	mov	r3,r2
   17f28:	003ebb06 	br	17a18 <__udivdi3+0x60>
   17f2c:	00800204 	movi	r2,8
   17f30:	1007883a 	mov	r3,r2
   17f34:	003f1e06 	br	17bb0 <__udivdi3+0x1f8>
   17f38:	197f972e 	bgeu	r3,r5,17d98 <__udivdi3+0x3e0>
   17f3c:	213fff84 	addi	r4,r4,-2
   17f40:	1cc7883a 	add	r3,r3,r19
   17f44:	003f9506 	br	17d9c <__udivdi3+0x3e4>
   17f48:	21bf802e 	bgeu	r4,r6,17d4c <__udivdi3+0x394>
   17f4c:	ad7fff84 	addi	r21,r21,-2
   17f50:	24c9883a 	add	r4,r4,r19
   17f54:	003f7e06 	br	17d50 <__udivdi3+0x398>
   17f58:	1805883a 	mov	r2,r3
   17f5c:	003fd406 	br	17eb0 <__udivdi3+0x4f8>
   17f60:	102b883a 	mov	r21,r2
   17f64:	003fbf06 	br	17e64 <__udivdi3+0x4ac>
   17f68:	8c7fff84 	addi	r17,r17,-2
   17f6c:	2409883a 	add	r4,r4,r16
   17f70:	003f3006 	br	17c34 <__udivdi3+0x27c>
   17f74:	94bfff84 	addi	r18,r18,-2
   17f78:	1c07883a 	add	r3,r3,r16
   17f7c:	003ec806 	br	17aa0 <__udivdi3+0xe8>

00017f80 <__umoddi3>:
   17f80:	defff504 	addi	sp,sp,-44
   17f84:	dd000515 	stw	r20,20(sp)
   17f88:	dcc00415 	stw	r19,16(sp)
   17f8c:	dc800315 	stw	r18,12(sp)
   17f90:	dc400215 	stw	r17,8(sp)
   17f94:	dc000115 	stw	r16,4(sp)
   17f98:	dfc00a15 	stw	ra,40(sp)
   17f9c:	df000915 	stw	fp,36(sp)
   17fa0:	ddc00815 	stw	r23,32(sp)
   17fa4:	dd800715 	stw	r22,28(sp)
   17fa8:	dd400615 	stw	r21,24(sp)
   17fac:	2025883a 	mov	r18,r4
   17fb0:	2823883a 	mov	r17,r5
   17fb4:	3021883a 	mov	r16,r6
   17fb8:	2027883a 	mov	r19,r4
   17fbc:	2829883a 	mov	r20,r5
   17fc0:	3800351e 	bne	r7,zero,18098 <__umoddi3+0x118>
   17fc4:	29804d2e 	bgeu	r5,r6,180fc <__umoddi3+0x17c>
   17fc8:	00bfffd4 	movui	r2,65535
   17fcc:	11809a36 	bltu	r2,r6,18238 <__umoddi3+0x2b8>
   17fd0:	00803fc4 	movi	r2,255
   17fd4:	11813936 	bltu	r2,r6,184bc <__umoddi3+0x53c>
   17fd8:	0005883a 	mov	r2,zero
   17fdc:	0009883a 	mov	r4,zero
   17fe0:	3084d83a 	srl	r2,r6,r2
   17fe4:	00c000b4 	movhi	r3,2
   17fe8:	18d7eb04 	addi	r3,r3,24492
   17fec:	05400804 	movi	r21,32
   17ff0:	1885883a 	add	r2,r3,r2
   17ff4:	10800003 	ldbu	r2,0(r2)
   17ff8:	1109883a 	add	r4,r2,r4
   17ffc:	a92bc83a 	sub	r21,r21,r4
   18000:	a800ec26 	beq	r21,zero,183b4 <__umoddi3+0x434>
   18004:	8d62983a 	sll	r17,r17,r21
   18008:	9108d83a 	srl	r4,r18,r4
   1800c:	3560983a 	sll	r16,r6,r21
   18010:	9566983a 	sll	r19,r18,r21
   18014:	8928b03a 	or	r20,r17,r4
   18018:	8022d43a 	srli	r17,r16,16
   1801c:	a009883a 	mov	r4,r20
   18020:	84bfffcc 	andi	r18,r16,65535
   18024:	880b883a 	mov	r5,r17
   18028:	00188800 	call	18880 <__umodsi3>
   1802c:	a009883a 	mov	r4,r20
   18030:	880b883a 	mov	r5,r17
   18034:	102d883a 	mov	r22,r2
   18038:	00188780 	call	18878 <__udivsi3>
   1803c:	b02c943a 	slli	r22,r22,16
   18040:	9806d43a 	srli	r3,r19,16
   18044:	1485383a 	mul	r2,r2,r18
   18048:	b0c6b03a 	or	r3,r22,r3
   1804c:	1880042e 	bgeu	r3,r2,18060 <__umoddi3+0xe0>
   18050:	1c07883a 	add	r3,r3,r16
   18054:	1c000236 	bltu	r3,r16,18060 <__umoddi3+0xe0>
   18058:	1880012e 	bgeu	r3,r2,18060 <__umoddi3+0xe0>
   1805c:	1c07883a 	add	r3,r3,r16
   18060:	18a9c83a 	sub	r20,r3,r2
   18064:	a009883a 	mov	r4,r20
   18068:	880b883a 	mov	r5,r17
   1806c:	00188800 	call	18880 <__umodsi3>
   18070:	102d883a 	mov	r22,r2
   18074:	a009883a 	mov	r4,r20
   18078:	880b883a 	mov	r5,r17
   1807c:	00188780 	call	18878 <__udivsi3>
   18080:	b02c943a 	slli	r22,r22,16
   18084:	1485383a 	mul	r2,r2,r18
   18088:	9cffffcc 	andi	r19,r19,65535
   1808c:	b4e6b03a 	or	r19,r22,r19
   18090:	9880522e 	bgeu	r19,r2,181dc <__umoddi3+0x25c>
   18094:	00004d06 	br	181cc <__umoddi3+0x24c>
   18098:	29c05436 	bltu	r5,r7,181ec <__umoddi3+0x26c>
   1809c:	00bfffd4 	movui	r2,65535
   180a0:	11c0602e 	bgeu	r2,r7,18224 <__umoddi3+0x2a4>
   180a4:	00804034 	movhi	r2,256
   180a8:	10bfffc4 	addi	r2,r2,-1
   180ac:	11c0f736 	bltu	r2,r7,1848c <__umoddi3+0x50c>
   180b0:	00c00404 	movi	r3,16
   180b4:	1827883a 	mov	r19,r3
   180b8:	38c6d83a 	srl	r3,r7,r3
   180bc:	010000b4 	movhi	r4,2
   180c0:	2117eb04 	addi	r4,r4,24492
   180c4:	04000804 	movi	r16,32
   180c8:	20c7883a 	add	r3,r4,r3
   180cc:	18800003 	ldbu	r2,0(r3)
   180d0:	14e7883a 	add	r19,r2,r19
   180d4:	84e1c83a 	sub	r16,r16,r19
   180d8:	8000621e 	bne	r16,zero,18264 <__umoddi3+0x2e4>
   180dc:	3c400136 	bltu	r7,r17,180e4 <__umoddi3+0x164>
   180e0:	91810336 	bltu	r18,r6,184f0 <__umoddi3+0x570>
   180e4:	9185c83a 	sub	r2,r18,r6
   180e8:	89e3c83a 	sub	r17,r17,r7
   180ec:	90a5803a 	cmpltu	r18,r18,r2
   180f0:	8ca9c83a 	sub	r20,r17,r18
   180f4:	a007883a 	mov	r3,r20
   180f8:	00003e06 	br	181f4 <__umoddi3+0x274>
   180fc:	3000041e 	bne	r6,zero,18110 <__umoddi3+0x190>
   18100:	01000044 	movi	r4,1
   18104:	000b883a 	mov	r5,zero
   18108:	00188780 	call	18878 <__udivsi3>
   1810c:	1021883a 	mov	r16,r2
   18110:	00bfffd4 	movui	r2,65535
   18114:	14004e2e 	bgeu	r2,r16,18250 <__umoddi3+0x2d0>
   18118:	00804034 	movhi	r2,256
   1811c:	10bfffc4 	addi	r2,r2,-1
   18120:	1400e336 	bltu	r2,r16,184b0 <__umoddi3+0x530>
   18124:	00800404 	movi	r2,16
   18128:	1007883a 	mov	r3,r2
   1812c:	8084d83a 	srl	r2,r16,r2
   18130:	010000b4 	movhi	r4,2
   18134:	2117eb04 	addi	r4,r4,24492
   18138:	05400804 	movi	r21,32
   1813c:	2085883a 	add	r2,r4,r2
   18140:	10800003 	ldbu	r2,0(r2)
   18144:	10c7883a 	add	r3,r2,r3
   18148:	a8ebc83a 	sub	r21,r21,r3
   1814c:	a8009b1e 	bne	r21,zero,183bc <__umoddi3+0x43c>
   18150:	8028d43a 	srli	r20,r16,16
   18154:	8c23c83a 	sub	r17,r17,r16
   18158:	85bfffcc 	andi	r22,r16,65535
   1815c:	8809883a 	mov	r4,r17
   18160:	a00b883a 	mov	r5,r20
   18164:	00188800 	call	18880 <__umodsi3>
   18168:	8809883a 	mov	r4,r17
   1816c:	a00b883a 	mov	r5,r20
   18170:	1025883a 	mov	r18,r2
   18174:	00188780 	call	18878 <__udivsi3>
   18178:	9024943a 	slli	r18,r18,16
   1817c:	9806d43a 	srli	r3,r19,16
   18180:	1585383a 	mul	r2,r2,r22
   18184:	90c6b03a 	or	r3,r18,r3
   18188:	1880032e 	bgeu	r3,r2,18198 <__umoddi3+0x218>
   1818c:	1c07883a 	add	r3,r3,r16
   18190:	1c000136 	bltu	r3,r16,18198 <__umoddi3+0x218>
   18194:	1880d436 	bltu	r3,r2,184e8 <__umoddi3+0x568>
   18198:	18a3c83a 	sub	r17,r3,r2
   1819c:	8809883a 	mov	r4,r17
   181a0:	a00b883a 	mov	r5,r20
   181a4:	00188800 	call	18880 <__umodsi3>
   181a8:	1025883a 	mov	r18,r2
   181ac:	8809883a 	mov	r4,r17
   181b0:	a00b883a 	mov	r5,r20
   181b4:	00188780 	call	18878 <__udivsi3>
   181b8:	9024943a 	slli	r18,r18,16
   181bc:	1585383a 	mul	r2,r2,r22
   181c0:	9cffffcc 	andi	r19,r19,65535
   181c4:	94e6b03a 	or	r19,r18,r19
   181c8:	9880042e 	bgeu	r19,r2,181dc <__umoddi3+0x25c>
   181cc:	9c27883a 	add	r19,r19,r16
   181d0:	9c000236 	bltu	r19,r16,181dc <__umoddi3+0x25c>
   181d4:	9880012e 	bgeu	r19,r2,181dc <__umoddi3+0x25c>
   181d8:	9c27883a 	add	r19,r19,r16
   181dc:	98a7c83a 	sub	r19,r19,r2
   181e0:	9d44d83a 	srl	r2,r19,r21
   181e4:	0007883a 	mov	r3,zero
   181e8:	00000206 	br	181f4 <__umoddi3+0x274>
   181ec:	2005883a 	mov	r2,r4
   181f0:	2807883a 	mov	r3,r5
   181f4:	dfc00a17 	ldw	ra,40(sp)
   181f8:	df000917 	ldw	fp,36(sp)
   181fc:	ddc00817 	ldw	r23,32(sp)
   18200:	dd800717 	ldw	r22,28(sp)
   18204:	dd400617 	ldw	r21,24(sp)
   18208:	dd000517 	ldw	r20,20(sp)
   1820c:	dcc00417 	ldw	r19,16(sp)
   18210:	dc800317 	ldw	r18,12(sp)
   18214:	dc400217 	ldw	r17,8(sp)
   18218:	dc000117 	ldw	r16,4(sp)
   1821c:	dec00b04 	addi	sp,sp,44
   18220:	f800283a 	ret
   18224:	00803fc4 	movi	r2,255
   18228:	11c09536 	bltu	r2,r7,18480 <__umoddi3+0x500>
   1822c:	0007883a 	mov	r3,zero
   18230:	0027883a 	mov	r19,zero
   18234:	003fa006 	br	180b8 <__umoddi3+0x138>
   18238:	00804034 	movhi	r2,256
   1823c:	10bfffc4 	addi	r2,r2,-1
   18240:	11809536 	bltu	r2,r6,18498 <__umoddi3+0x518>
   18244:	00800404 	movi	r2,16
   18248:	1009883a 	mov	r4,r2
   1824c:	003f6406 	br	17fe0 <__umoddi3+0x60>
   18250:	00803fc4 	movi	r2,255
   18254:	14009336 	bltu	r2,r16,184a4 <__umoddi3+0x524>
   18258:	0005883a 	mov	r2,zero
   1825c:	0007883a 	mov	r3,zero
   18260:	003fb206 	br	1812c <__umoddi3+0x1ac>
   18264:	34c4d83a 	srl	r2,r6,r19
   18268:	3c0e983a 	sll	r7,r7,r16
   1826c:	8ceed83a 	srl	r23,r17,r19
   18270:	8c22983a 	sll	r17,r17,r16
   18274:	38a8b03a 	or	r20,r7,r2
   18278:	a02ad43a 	srli	r21,r20,16
   1827c:	94c4d83a 	srl	r2,r18,r19
   18280:	b809883a 	mov	r4,r23
   18284:	a80b883a 	mov	r5,r21
   18288:	88a2b03a 	or	r17,r17,r2
   1828c:	342c983a 	sll	r22,r6,r16
   18290:	00188800 	call	18880 <__umodsi3>
   18294:	b809883a 	mov	r4,r23
   18298:	a80b883a 	mov	r5,r21
   1829c:	d8800015 	stw	r2,0(sp)
   182a0:	00188780 	call	18878 <__udivsi3>
   182a4:	d8c00017 	ldw	r3,0(sp)
   182a8:	102f883a 	mov	r23,r2
   182ac:	a73fffcc 	andi	fp,r20,65535
   182b0:	180a943a 	slli	r5,r3,16
   182b4:	8804d43a 	srli	r2,r17,16
   182b8:	bf09383a 	mul	r4,r23,fp
   182bc:	9424983a 	sll	r18,r18,r16
   182c0:	288ab03a 	or	r5,r5,r2
   182c4:	2900042e 	bgeu	r5,r4,182d8 <__umoddi3+0x358>
   182c8:	2d0b883a 	add	r5,r5,r20
   182cc:	b8bfffc4 	addi	r2,r23,-1
   182d0:	2d00812e 	bgeu	r5,r20,184d8 <__umoddi3+0x558>
   182d4:	102f883a 	mov	r23,r2
   182d8:	2907c83a 	sub	r3,r5,r4
   182dc:	1809883a 	mov	r4,r3
   182e0:	a80b883a 	mov	r5,r21
   182e4:	d8c00015 	stw	r3,0(sp)
   182e8:	00188800 	call	18880 <__umodsi3>
   182ec:	d8c00017 	ldw	r3,0(sp)
   182f0:	a80b883a 	mov	r5,r21
   182f4:	d8800015 	stw	r2,0(sp)
   182f8:	1809883a 	mov	r4,r3
   182fc:	00188780 	call	18878 <__udivsi3>
   18300:	d9800017 	ldw	r6,0(sp)
   18304:	8c7fffcc 	andi	r17,r17,65535
   18308:	3008943a 	slli	r4,r6,16
   1830c:	170d383a 	mul	r6,r2,fp
   18310:	2448b03a 	or	r4,r4,r17
   18314:	2180042e 	bgeu	r4,r6,18328 <__umoddi3+0x3a8>
   18318:	2509883a 	add	r4,r4,r20
   1831c:	10ffffc4 	addi	r3,r2,-1
   18320:	2500692e 	bgeu	r4,r20,184c8 <__umoddi3+0x548>
   18324:	1805883a 	mov	r2,r3
   18328:	b82e943a 	slli	r23,r23,16
   1832c:	b010d43a 	srli	r8,r22,16
   18330:	b1ffffcc 	andi	r7,r22,65535
   18334:	15eeb03a 	or	r23,r2,r23
   18338:	b8bfffcc 	andi	r2,r23,65535
   1833c:	b82ed43a 	srli	r23,r23,16
   18340:	11c7383a 	mul	r3,r2,r7
   18344:	1205383a 	mul	r2,r2,r8
   18348:	b9cf383a 	mul	r7,r23,r7
   1834c:	400b883a 	mov	r5,r8
   18350:	1810d43a 	srli	r8,r3,16
   18354:	3885883a 	add	r2,r7,r2
   18358:	2189c83a 	sub	r4,r4,r6
   1835c:	1205883a 	add	r2,r2,r8
   18360:	b94b383a 	mul	r5,r23,r5
   18364:	11c0022e 	bgeu	r2,r7,18370 <__umoddi3+0x3f0>
   18368:	01800074 	movhi	r6,1
   1836c:	298b883a 	add	r5,r5,r6
   18370:	100cd43a 	srli	r6,r2,16
   18374:	1004943a 	slli	r2,r2,16
   18378:	18ffffcc 	andi	r3,r3,65535
   1837c:	298b883a 	add	r5,r5,r6
   18380:	10c5883a 	add	r2,r2,r3
   18384:	21403836 	bltu	r4,r5,18468 <__umoddi3+0x4e8>
   18388:	21405c26 	beq	r4,r5,184fc <__umoddi3+0x57c>
   1838c:	2147c83a 	sub	r3,r4,r5
   18390:	102d883a 	mov	r22,r2
   18394:	95adc83a 	sub	r22,r18,r22
   18398:	95a5803a 	cmpltu	r18,r18,r22
   1839c:	1c87c83a 	sub	r3,r3,r18
   183a0:	1cc4983a 	sll	r2,r3,r19
   183a4:	b42cd83a 	srl	r22,r22,r16
   183a8:	1c06d83a 	srl	r3,r3,r16
   183ac:	1584b03a 	or	r2,r2,r22
   183b0:	003f9006 	br	181f4 <__umoddi3+0x274>
   183b4:	002b883a 	mov	r21,zero
   183b8:	003f1706 	br	18018 <__umoddi3+0x98>
   183bc:	8560983a 	sll	r16,r16,r21
   183c0:	88e6d83a 	srl	r19,r17,r3
   183c4:	90c6d83a 	srl	r3,r18,r3
   183c8:	8028d43a 	srli	r20,r16,16
   183cc:	8d62983a 	sll	r17,r17,r21
   183d0:	9809883a 	mov	r4,r19
   183d4:	a00b883a 	mov	r5,r20
   183d8:	88eeb03a 	or	r23,r17,r3
   183dc:	00188800 	call	18880 <__umodsi3>
   183e0:	9809883a 	mov	r4,r19
   183e4:	a00b883a 	mov	r5,r20
   183e8:	1023883a 	mov	r17,r2
   183ec:	00188780 	call	18878 <__udivsi3>
   183f0:	85bfffcc 	andi	r22,r16,65535
   183f4:	880a943a 	slli	r5,r17,16
   183f8:	b806d43a 	srli	r3,r23,16
   183fc:	1585383a 	mul	r2,r2,r22
   18400:	9566983a 	sll	r19,r18,r21
   18404:	28cab03a 	or	r5,r5,r3
   18408:	2880042e 	bgeu	r5,r2,1841c <__umoddi3+0x49c>
   1840c:	2c0b883a 	add	r5,r5,r16
   18410:	2c000236 	bltu	r5,r16,1841c <__umoddi3+0x49c>
   18414:	2880012e 	bgeu	r5,r2,1841c <__umoddi3+0x49c>
   18418:	2c0b883a 	add	r5,r5,r16
   1841c:	28a5c83a 	sub	r18,r5,r2
   18420:	9009883a 	mov	r4,r18
   18424:	a00b883a 	mov	r5,r20
   18428:	00188800 	call	18880 <__umodsi3>
   1842c:	1023883a 	mov	r17,r2
   18430:	9009883a 	mov	r4,r18
   18434:	a00b883a 	mov	r5,r20
   18438:	00188780 	call	18878 <__udivsi3>
   1843c:	8822943a 	slli	r17,r17,16
   18440:	1585383a 	mul	r2,r2,r22
   18444:	bdffffcc 	andi	r23,r23,65535
   18448:	8de2b03a 	or	r17,r17,r23
   1844c:	8880042e 	bgeu	r17,r2,18460 <__umoddi3+0x4e0>
   18450:	8c23883a 	add	r17,r17,r16
   18454:	8c000236 	bltu	r17,r16,18460 <__umoddi3+0x4e0>
   18458:	8880012e 	bgeu	r17,r2,18460 <__umoddi3+0x4e0>
   1845c:	8c23883a 	add	r17,r17,r16
   18460:	88a3c83a 	sub	r17,r17,r2
   18464:	003f3d06 	br	1815c <__umoddi3+0x1dc>
   18468:	15adc83a 	sub	r22,r2,r22
   1846c:	2d07c83a 	sub	r3,r5,r20
   18470:	1585803a 	cmpltu	r2,r2,r22
   18474:	1887c83a 	sub	r3,r3,r2
   18478:	20c7c83a 	sub	r3,r4,r3
   1847c:	003fc506 	br	18394 <__umoddi3+0x414>
   18480:	00c00204 	movi	r3,8
   18484:	1827883a 	mov	r19,r3
   18488:	003f0b06 	br	180b8 <__umoddi3+0x138>
   1848c:	00c00604 	movi	r3,24
   18490:	1827883a 	mov	r19,r3
   18494:	003f0806 	br	180b8 <__umoddi3+0x138>
   18498:	00800604 	movi	r2,24
   1849c:	1009883a 	mov	r4,r2
   184a0:	003ecf06 	br	17fe0 <__umoddi3+0x60>
   184a4:	00800204 	movi	r2,8
   184a8:	1007883a 	mov	r3,r2
   184ac:	003f1f06 	br	1812c <__umoddi3+0x1ac>
   184b0:	00800604 	movi	r2,24
   184b4:	1007883a 	mov	r3,r2
   184b8:	003f1c06 	br	1812c <__umoddi3+0x1ac>
   184bc:	00800204 	movi	r2,8
   184c0:	1009883a 	mov	r4,r2
   184c4:	003ec606 	br	17fe0 <__umoddi3+0x60>
   184c8:	21bf962e 	bgeu	r4,r6,18324 <__umoddi3+0x3a4>
   184cc:	10bfff84 	addi	r2,r2,-2
   184d0:	2509883a 	add	r4,r4,r20
   184d4:	003f9406 	br	18328 <__umoddi3+0x3a8>
   184d8:	293f7e2e 	bgeu	r5,r4,182d4 <__umoddi3+0x354>
   184dc:	bdffff84 	addi	r23,r23,-2
   184e0:	2d0b883a 	add	r5,r5,r20
   184e4:	003f7c06 	br	182d8 <__umoddi3+0x358>
   184e8:	1c07883a 	add	r3,r3,r16
   184ec:	003f2a06 	br	18198 <__umoddi3+0x218>
   184f0:	9005883a 	mov	r2,r18
   184f4:	a007883a 	mov	r3,r20
   184f8:	003f3e06 	br	181f4 <__umoddi3+0x274>
   184fc:	90bfda36 	bltu	r18,r2,18468 <__umoddi3+0x4e8>
   18500:	102d883a 	mov	r22,r2
   18504:	0007883a 	mov	r3,zero
   18508:	003fa206 	br	18394 <__umoddi3+0x414>

0001850c <__eqdf2>:
   1850c:	defff104 	addi	sp,sp,-60
   18510:	d9000c15 	stw	r4,48(sp)
   18514:	d9400d15 	stw	r5,52(sp)
   18518:	d9000c04 	addi	r4,sp,48
   1851c:	d9400504 	addi	r5,sp,20
   18520:	dfc00e15 	stw	ra,56(sp)
   18524:	d9800a15 	stw	r6,40(sp)
   18528:	d9c00b15 	stw	r7,44(sp)
   1852c:	000ff600 	call	ff60 <__unpack_d>
   18530:	d9000a04 	addi	r4,sp,40
   18534:	d80b883a 	mov	r5,sp
   18538:	000ff600 	call	ff60 <__unpack_d>
   1853c:	d8c00517 	ldw	r3,20(sp)
   18540:	00800044 	movi	r2,1
   18544:	10c0052e 	bgeu	r2,r3,1855c <__eqdf2+0x50>
   18548:	d8c00017 	ldw	r3,0(sp)
   1854c:	10c0032e 	bgeu	r2,r3,1855c <__eqdf2+0x50>
   18550:	d9000504 	addi	r4,sp,20
   18554:	d80b883a 	mov	r5,sp
   18558:	00100640 	call	10064 <__fpcmp_parts_d>
   1855c:	dfc00e17 	ldw	ra,56(sp)
   18560:	dec00f04 	addi	sp,sp,60
   18564:	f800283a 	ret

00018568 <__nedf2>:
   18568:	defff104 	addi	sp,sp,-60
   1856c:	d9000c15 	stw	r4,48(sp)
   18570:	d9400d15 	stw	r5,52(sp)
   18574:	d9000c04 	addi	r4,sp,48
   18578:	d9400504 	addi	r5,sp,20
   1857c:	dfc00e15 	stw	ra,56(sp)
   18580:	d9800a15 	stw	r6,40(sp)
   18584:	d9c00b15 	stw	r7,44(sp)
   18588:	000ff600 	call	ff60 <__unpack_d>
   1858c:	d9000a04 	addi	r4,sp,40
   18590:	d80b883a 	mov	r5,sp
   18594:	000ff600 	call	ff60 <__unpack_d>
   18598:	d8c00517 	ldw	r3,20(sp)
   1859c:	00800044 	movi	r2,1
   185a0:	10c0052e 	bgeu	r2,r3,185b8 <__nedf2+0x50>
   185a4:	d8c00017 	ldw	r3,0(sp)
   185a8:	10c0032e 	bgeu	r2,r3,185b8 <__nedf2+0x50>
   185ac:	d9000504 	addi	r4,sp,20
   185b0:	d80b883a 	mov	r5,sp
   185b4:	00100640 	call	10064 <__fpcmp_parts_d>
   185b8:	dfc00e17 	ldw	ra,56(sp)
   185bc:	dec00f04 	addi	sp,sp,60
   185c0:	f800283a 	ret

000185c4 <__gtdf2>:
   185c4:	defff104 	addi	sp,sp,-60
   185c8:	d9000c15 	stw	r4,48(sp)
   185cc:	d9400d15 	stw	r5,52(sp)
   185d0:	d9000c04 	addi	r4,sp,48
   185d4:	d9400504 	addi	r5,sp,20
   185d8:	dfc00e15 	stw	ra,56(sp)
   185dc:	d9800a15 	stw	r6,40(sp)
   185e0:	d9c00b15 	stw	r7,44(sp)
   185e4:	000ff600 	call	ff60 <__unpack_d>
   185e8:	d9000a04 	addi	r4,sp,40
   185ec:	d80b883a 	mov	r5,sp
   185f0:	000ff600 	call	ff60 <__unpack_d>
   185f4:	d8c00517 	ldw	r3,20(sp)
   185f8:	00800044 	movi	r2,1
   185fc:	10c0082e 	bgeu	r2,r3,18620 <__gtdf2+0x5c>
   18600:	d8c00017 	ldw	r3,0(sp)
   18604:	10c0062e 	bgeu	r2,r3,18620 <__gtdf2+0x5c>
   18608:	d9000504 	addi	r4,sp,20
   1860c:	d80b883a 	mov	r5,sp
   18610:	00100640 	call	10064 <__fpcmp_parts_d>
   18614:	dfc00e17 	ldw	ra,56(sp)
   18618:	dec00f04 	addi	sp,sp,60
   1861c:	f800283a 	ret
   18620:	00bfffc4 	movi	r2,-1
   18624:	003ffb06 	br	18614 <__gtdf2+0x50>

00018628 <__ltdf2>:
   18628:	defff104 	addi	sp,sp,-60
   1862c:	d9000c15 	stw	r4,48(sp)
   18630:	d9400d15 	stw	r5,52(sp)
   18634:	d9000c04 	addi	r4,sp,48
   18638:	d9400504 	addi	r5,sp,20
   1863c:	dfc00e15 	stw	ra,56(sp)
   18640:	d9800a15 	stw	r6,40(sp)
   18644:	d9c00b15 	stw	r7,44(sp)
   18648:	000ff600 	call	ff60 <__unpack_d>
   1864c:	d9000a04 	addi	r4,sp,40
   18650:	d80b883a 	mov	r5,sp
   18654:	000ff600 	call	ff60 <__unpack_d>
   18658:	d8c00517 	ldw	r3,20(sp)
   1865c:	00800044 	movi	r2,1
   18660:	10c0052e 	bgeu	r2,r3,18678 <__ltdf2+0x50>
   18664:	d8c00017 	ldw	r3,0(sp)
   18668:	10c0032e 	bgeu	r2,r3,18678 <__ltdf2+0x50>
   1866c:	d9000504 	addi	r4,sp,20
   18670:	d80b883a 	mov	r5,sp
   18674:	00100640 	call	10064 <__fpcmp_parts_d>
   18678:	dfc00e17 	ldw	ra,56(sp)
   1867c:	dec00f04 	addi	sp,sp,60
   18680:	f800283a 	ret

00018684 <__floatsidf>:
   18684:	2004d7fa 	srli	r2,r4,31
   18688:	defff904 	addi	sp,sp,-28
   1868c:	00c000c4 	movi	r3,3
   18690:	dfc00615 	stw	ra,24(sp)
   18694:	dc000515 	stw	r16,20(sp)
   18698:	d8c00015 	stw	r3,0(sp)
   1869c:	d8800115 	stw	r2,4(sp)
   186a0:	2000081e 	bne	r4,zero,186c4 <__floatsidf+0x40>
   186a4:	00800084 	movi	r2,2
   186a8:	d8800015 	stw	r2,0(sp)
   186ac:	d809883a 	mov	r4,sp
   186b0:	000fd3c0 	call	fd3c <__pack_d>
   186b4:	dfc00617 	ldw	ra,24(sp)
   186b8:	dc000517 	ldw	r16,20(sp)
   186bc:	dec00704 	addi	sp,sp,28
   186c0:	f800283a 	ret
   186c4:	00c00f04 	movi	r3,60
   186c8:	d8c00215 	stw	r3,8(sp)
   186cc:	10000f1e 	bne	r2,zero,1870c <__floatsidf+0x88>
   186d0:	2021883a 	mov	r16,r4
   186d4:	8009883a 	mov	r4,r16
   186d8:	000fc900 	call	fc90 <__clzsi2>
   186dc:	11000744 	addi	r4,r2,29
   186e0:	0100110e 	bge	zero,r4,18728 <__floatsidf+0xa4>
   186e4:	10ffff44 	addi	r3,r2,-3
   186e8:	18001216 	blt	r3,zero,18734 <__floatsidf+0xb0>
   186ec:	80c6983a 	sll	r3,r16,r3
   186f0:	0009883a 	mov	r4,zero
   186f4:	014007c4 	movi	r5,31
   186f8:	2885c83a 	sub	r2,r5,r2
   186fc:	d9000315 	stw	r4,12(sp)
   18700:	d8c00415 	stw	r3,16(sp)
   18704:	d8800215 	stw	r2,8(sp)
   18708:	003fe806 	br	186ac <__floatsidf+0x28>
   1870c:	00a00034 	movhi	r2,32768
   18710:	20800e26 	beq	r4,r2,1874c <__floatsidf+0xc8>
   18714:	0121c83a 	sub	r16,zero,r4
   18718:	8009883a 	mov	r4,r16
   1871c:	000fc900 	call	fc90 <__clzsi2>
   18720:	11000744 	addi	r4,r2,29
   18724:	013fef16 	blt	zero,r4,186e4 <__floatsidf+0x60>
   18728:	dc000315 	stw	r16,12(sp)
   1872c:	d8000415 	stw	zero,16(sp)
   18730:	003fde06 	br	186ac <__floatsidf+0x28>
   18734:	800ad07a 	srli	r5,r16,1
   18738:	00c007c4 	movi	r3,31
   1873c:	1907c83a 	sub	r3,r3,r4
   18740:	28c6d83a 	srl	r3,r5,r3
   18744:	8108983a 	sll	r4,r16,r4
   18748:	003fea06 	br	186f4 <__floatsidf+0x70>
   1874c:	0005883a 	mov	r2,zero
   18750:	00f07834 	movhi	r3,49632
   18754:	003fd706 	br	186b4 <__floatsidf+0x30>

00018758 <udivmodsi4>:
   18758:	2005883a 	mov	r2,r4
   1875c:	2900182e 	bgeu	r5,r4,187c0 <udivmodsi4+0x68>
   18760:	28001716 	blt	r5,zero,187c0 <udivmodsi4+0x68>
   18764:	01000804 	movi	r4,32
   18768:	00c00044 	movi	r3,1
   1876c:	00000206 	br	18778 <udivmodsi4+0x20>
   18770:	20001126 	beq	r4,zero,187b8 <udivmodsi4+0x60>
   18774:	28000516 	blt	r5,zero,1878c <udivmodsi4+0x34>
   18778:	294b883a 	add	r5,r5,r5
   1877c:	213fffc4 	addi	r4,r4,-1
   18780:	18c7883a 	add	r3,r3,r3
   18784:	28bffa36 	bltu	r5,r2,18770 <udivmodsi4+0x18>
   18788:	18000b26 	beq	r3,zero,187b8 <udivmodsi4+0x60>
   1878c:	0009883a 	mov	r4,zero
   18790:	11400236 	bltu	r2,r5,1879c <udivmodsi4+0x44>
   18794:	1145c83a 	sub	r2,r2,r5
   18798:	20c8b03a 	or	r4,r4,r3
   1879c:	1806d07a 	srli	r3,r3,1
   187a0:	280ad07a 	srli	r5,r5,1
   187a4:	183ffa1e 	bne	r3,zero,18790 <udivmodsi4+0x38>
   187a8:	3000021e 	bne	r6,zero,187b4 <udivmodsi4+0x5c>
   187ac:	2005883a 	mov	r2,r4
   187b0:	f800283a 	ret
   187b4:	f800283a 	ret
   187b8:	0009883a 	mov	r4,zero
   187bc:	003ffa06 	br	187a8 <udivmodsi4+0x50>
   187c0:	00c00044 	movi	r3,1
   187c4:	0009883a 	mov	r4,zero
   187c8:	003ff106 	br	18790 <udivmodsi4+0x38>

000187cc <__divsi3>:
   187cc:	defffe04 	addi	sp,sp,-8
   187d0:	dfc00115 	stw	ra,4(sp)
   187d4:	dc000015 	stw	r16,0(sp)
   187d8:	20000a16 	blt	r4,zero,18804 <__divsi3+0x38>
   187dc:	0021883a 	mov	r16,zero
   187e0:	28000b16 	blt	r5,zero,18810 <__divsi3+0x44>
   187e4:	000d883a 	mov	r6,zero
   187e8:	00187580 	call	18758 <udivmodsi4>
   187ec:	80000126 	beq	r16,zero,187f4 <__divsi3+0x28>
   187f0:	0085c83a 	sub	r2,zero,r2
   187f4:	dfc00117 	ldw	ra,4(sp)
   187f8:	dc000017 	ldw	r16,0(sp)
   187fc:	dec00204 	addi	sp,sp,8
   18800:	f800283a 	ret
   18804:	0109c83a 	sub	r4,zero,r4
   18808:	04000044 	movi	r16,1
   1880c:	283ff50e 	bge	r5,zero,187e4 <__divsi3+0x18>
   18810:	014bc83a 	sub	r5,zero,r5
   18814:	8400005c 	xori	r16,r16,1
   18818:	003ff206 	br	187e4 <__divsi3+0x18>

0001881c <__modsi3>:
   1881c:	deffff04 	addi	sp,sp,-4
   18820:	dfc00015 	stw	ra,0(sp)
   18824:	20000516 	blt	r4,zero,1883c <__modsi3+0x20>
   18828:	28000c16 	blt	r5,zero,1885c <__modsi3+0x40>
   1882c:	01800044 	movi	r6,1
   18830:	dfc00017 	ldw	ra,0(sp)
   18834:	dec00104 	addi	sp,sp,4
   18838:	00187581 	jmpi	18758 <udivmodsi4>
   1883c:	0109c83a 	sub	r4,zero,r4
   18840:	28000b16 	blt	r5,zero,18870 <__modsi3+0x54>
   18844:	01800044 	movi	r6,1
   18848:	00187580 	call	18758 <udivmodsi4>
   1884c:	0085c83a 	sub	r2,zero,r2
   18850:	dfc00017 	ldw	ra,0(sp)
   18854:	dec00104 	addi	sp,sp,4
   18858:	f800283a 	ret
   1885c:	014bc83a 	sub	r5,zero,r5
   18860:	01800044 	movi	r6,1
   18864:	dfc00017 	ldw	ra,0(sp)
   18868:	dec00104 	addi	sp,sp,4
   1886c:	00187581 	jmpi	18758 <udivmodsi4>
   18870:	014bc83a 	sub	r5,zero,r5
   18874:	003ff306 	br	18844 <__modsi3+0x28>

00018878 <__udivsi3>:
   18878:	000d883a 	mov	r6,zero
   1887c:	00187581 	jmpi	18758 <udivmodsi4>

00018880 <__umodsi3>:
   18880:	01800044 	movi	r6,1
   18884:	00187581 	jmpi	18758 <udivmodsi4>

00018888 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
   18888:	defff404 	addi	sp,sp,-48
   1888c:	df000b15 	stw	fp,44(sp)
   18890:	df000b04 	addi	fp,sp,44
   18894:	e13ffc15 	stw	r4,-16(fp)
   18898:	e17ffd15 	stw	r5,-12(fp)
   1889c:	e1bffe15 	stw	r6,-8(fp)
   188a0:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
   188a4:	e03ff515 	stw	zero,-44(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
   188a8:	008000f4 	movhi	r2,3
   188ac:	10aed804 	addi	r2,r2,-17568
   188b0:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
   188b4:	10004a26 	beq	r2,zero,189e0 <alt_alarm_start+0x158>
  {
    if (alarm)
   188b8:	e0bffc17 	ldw	r2,-16(fp)
   188bc:	10004626 	beq	r2,zero,189d8 <alt_alarm_start+0x150>
    {
      alarm->callback = callback;
   188c0:	e0bffc17 	ldw	r2,-16(fp)
   188c4:	e0fffe17 	ldw	r3,-8(fp)
   188c8:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
   188cc:	e0bffc17 	ldw	r2,-16(fp)
   188d0:	e0ffff17 	ldw	r3,-4(fp)
   188d4:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   188d8:	0005303a 	rdctl	r2,status
   188dc:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   188e0:	e0fff717 	ldw	r3,-36(fp)
   188e4:	00bfff84 	movi	r2,-2
   188e8:	1884703a 	and	r2,r3,r2
   188ec:	1001703a 	wrctl	status,r2
  
  return context;
   188f0:	e0bff717 	ldw	r2,-36(fp)
 
      irq_context = alt_irq_disable_all ();
   188f4:	e0bff615 	stw	r2,-40(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
   188f8:	008000f4 	movhi	r2,3
   188fc:	10aed904 	addi	r2,r2,-17564
   18900:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
   18904:	e0bff515 	stw	r2,-44(fp)
      
      alarm->time = nticks + current_nticks + 1; 
   18908:	e0fffd17 	ldw	r3,-12(fp)
   1890c:	e0bff517 	ldw	r2,-44(fp)
   18910:	1885883a 	add	r2,r3,r2
   18914:	10c00044 	addi	r3,r2,1
   18918:	e0bffc17 	ldw	r2,-16(fp)
   1891c:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
   18920:	e0bffc17 	ldw	r2,-16(fp)
   18924:	10c00217 	ldw	r3,8(r2)
   18928:	e0bff517 	ldw	r2,-44(fp)
   1892c:	1880042e 	bgeu	r3,r2,18940 <alt_alarm_start+0xb8>
      {
        alarm->rollover = 1;
   18930:	e0bffc17 	ldw	r2,-16(fp)
   18934:	00c00044 	movi	r3,1
   18938:	10c00405 	stb	r3,16(r2)
   1893c:	00000206 	br	18948 <alt_alarm_start+0xc0>
      }
      else
      {
        alarm->rollover = 0;
   18940:	e0bffc17 	ldw	r2,-16(fp)
   18944:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
   18948:	e0bffc17 	ldw	r2,-16(fp)
   1894c:	00c000f4 	movhi	r3,3
   18950:	18e61504 	addi	r3,r3,-26540
   18954:	e0fff815 	stw	r3,-32(fp)
   18958:	e0bff915 	stw	r2,-28(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
   1895c:	e0bff917 	ldw	r2,-28(fp)
   18960:	e0fff817 	ldw	r3,-32(fp)
   18964:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
   18968:	e0bff817 	ldw	r2,-32(fp)
   1896c:	10c00017 	ldw	r3,0(r2)
   18970:	e0bff917 	ldw	r2,-28(fp)
   18974:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
   18978:	e0bff817 	ldw	r2,-32(fp)
   1897c:	10800017 	ldw	r2,0(r2)
   18980:	e0fff917 	ldw	r3,-28(fp)
   18984:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
   18988:	e0bff817 	ldw	r2,-32(fp)
   1898c:	e0fff917 	ldw	r3,-28(fp)
   18990:	10c00015 	stw	r3,0(r2)
   18994:	e0bff617 	ldw	r2,-40(fp)
   18998:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   1899c:	0005303a 	rdctl	r2,status
   189a0:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   189a4:	e0fffb17 	ldw	r3,-20(fp)
   189a8:	00bfff84 	movi	r2,-2
   189ac:	1884703a 	and	r2,r3,r2
   189b0:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   189b4:	e0bffa17 	ldw	r2,-24(fp)
   189b8:	1080004c 	andi	r2,r2,1
   189bc:	e0fffb17 	ldw	r3,-20(fp)
   189c0:	1884b03a 	or	r2,r3,r2
   189c4:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
   189c8:	e0bffb17 	ldw	r2,-20(fp)
   189cc:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
   189d0:	0005883a 	mov	r2,zero
   189d4:	00000306 	br	189e4 <alt_alarm_start+0x15c>
    }
    else
    {
      return -EINVAL;
   189d8:	00bffa84 	movi	r2,-22
   189dc:	00000106 	br	189e4 <alt_alarm_start+0x15c>
    }
  }
  else
  {
    return -ENOTSUP;
   189e0:	00bfde84 	movi	r2,-134
  }
}
   189e4:	e037883a 	mov	sp,fp
   189e8:	df000017 	ldw	fp,0(sp)
   189ec:	dec00104 	addi	sp,sp,4
   189f0:	f800283a 	ret

000189f4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   189f4:	defffe04 	addi	sp,sp,-8
   189f8:	dfc00115 	stw	ra,4(sp)
   189fc:	df000015 	stw	fp,0(sp)
   18a00:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   18a04:	008000f4 	movhi	r2,3
   18a08:	10a61304 	addi	r2,r2,-26548
   18a0c:	10800017 	ldw	r2,0(r2)
   18a10:	10000526 	beq	r2,zero,18a28 <alt_get_errno+0x34>
   18a14:	008000f4 	movhi	r2,3
   18a18:	10a61304 	addi	r2,r2,-26548
   18a1c:	10800017 	ldw	r2,0(r2)
   18a20:	103ee83a 	callr	r2
   18a24:	00000206 	br	18a30 <alt_get_errno+0x3c>
   18a28:	008000f4 	movhi	r2,3
   18a2c:	10aed404 	addi	r2,r2,-17584
}
   18a30:	e037883a 	mov	sp,fp
   18a34:	dfc00117 	ldw	ra,4(sp)
   18a38:	df000017 	ldw	fp,0(sp)
   18a3c:	dec00204 	addi	sp,sp,8
   18a40:	f800283a 	ret

00018a44 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
   18a44:	defffb04 	addi	sp,sp,-20
   18a48:	dfc00415 	stw	ra,16(sp)
   18a4c:	df000315 	stw	fp,12(sp)
   18a50:	df000304 	addi	fp,sp,12
   18a54:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
   18a58:	e0bfff17 	ldw	r2,-4(fp)
   18a5c:	10000616 	blt	r2,zero,18a78 <close+0x34>
   18a60:	e0bfff17 	ldw	r2,-4(fp)
   18a64:	10c00324 	muli	r3,r2,12
   18a68:	008000f4 	movhi	r2,3
   18a6c:	10a03504 	addi	r2,r2,-32556
   18a70:	1885883a 	add	r2,r3,r2
   18a74:	00000106 	br	18a7c <close+0x38>
   18a78:	0005883a 	mov	r2,zero
   18a7c:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
   18a80:	e0bffd17 	ldw	r2,-12(fp)
   18a84:	10001826 	beq	r2,zero,18ae8 <close+0xa4>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
   18a88:	e0bffd17 	ldw	r2,-12(fp)
   18a8c:	10800017 	ldw	r2,0(r2)
   18a90:	10800417 	ldw	r2,16(r2)
   18a94:	10000626 	beq	r2,zero,18ab0 <close+0x6c>
   18a98:	e0bffd17 	ldw	r2,-12(fp)
   18a9c:	10800017 	ldw	r2,0(r2)
   18aa0:	10800417 	ldw	r2,16(r2)
   18aa4:	e13ffd17 	ldw	r4,-12(fp)
   18aa8:	103ee83a 	callr	r2
   18aac:	00000106 	br	18ab4 <close+0x70>
   18ab0:	0005883a 	mov	r2,zero
   18ab4:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
   18ab8:	e13fff17 	ldw	r4,-4(fp)
   18abc:	00191280 	call	19128 <alt_release_fd>
    if (rval < 0)
   18ac0:	e0bffe17 	ldw	r2,-8(fp)
   18ac4:	1000060e 	bge	r2,zero,18ae0 <close+0x9c>
    {
      ALT_ERRNO = -rval;
   18ac8:	00189f40 	call	189f4 <alt_get_errno>
   18acc:	e0fffe17 	ldw	r3,-8(fp)
   18ad0:	00c7c83a 	sub	r3,zero,r3
   18ad4:	10c00015 	stw	r3,0(r2)
      return -1;
   18ad8:	00bfffc4 	movi	r2,-1
   18adc:	00000606 	br	18af8 <close+0xb4>
    }
    return 0;
   18ae0:	0005883a 	mov	r2,zero
   18ae4:	00000406 	br	18af8 <close+0xb4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
   18ae8:	00189f40 	call	189f4 <alt_get_errno>
   18aec:	00c01444 	movi	r3,81
   18af0:	10c00015 	stw	r3,0(r2)
    return -1;
   18af4:	00bfffc4 	movi	r2,-1
  }
}
   18af8:	e037883a 	mov	sp,fp
   18afc:	dfc00117 	ldw	ra,4(sp)
   18b00:	df000017 	ldw	fp,0(sp)
   18b04:	dec00204 	addi	sp,sp,8
   18b08:	f800283a 	ret

00018b0c <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
   18b0c:	defffc04 	addi	sp,sp,-16
   18b10:	df000315 	stw	fp,12(sp)
   18b14:	df000304 	addi	fp,sp,12
   18b18:	e13ffd15 	stw	r4,-12(fp)
   18b1c:	e17ffe15 	stw	r5,-8(fp)
   18b20:	e1bfff15 	stw	r6,-4(fp)
  return len;
   18b24:	e0bfff17 	ldw	r2,-4(fp)
}
   18b28:	e037883a 	mov	sp,fp
   18b2c:	df000017 	ldw	fp,0(sp)
   18b30:	dec00104 	addi	sp,sp,4
   18b34:	f800283a 	ret

00018b38 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   18b38:	defffe04 	addi	sp,sp,-8
   18b3c:	dfc00115 	stw	ra,4(sp)
   18b40:	df000015 	stw	fp,0(sp)
   18b44:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   18b48:	008000f4 	movhi	r2,3
   18b4c:	10a61304 	addi	r2,r2,-26548
   18b50:	10800017 	ldw	r2,0(r2)
   18b54:	10000526 	beq	r2,zero,18b6c <alt_get_errno+0x34>
   18b58:	008000f4 	movhi	r2,3
   18b5c:	10a61304 	addi	r2,r2,-26548
   18b60:	10800017 	ldw	r2,0(r2)
   18b64:	103ee83a 	callr	r2
   18b68:	00000206 	br	18b74 <alt_get_errno+0x3c>
   18b6c:	008000f4 	movhi	r2,3
   18b70:	10aed404 	addi	r2,r2,-17584
}
   18b74:	e037883a 	mov	sp,fp
   18b78:	dfc00117 	ldw	ra,4(sp)
   18b7c:	df000017 	ldw	fp,0(sp)
   18b80:	dec00204 	addi	sp,sp,8
   18b84:	f800283a 	ret

00018b88 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
   18b88:	defffb04 	addi	sp,sp,-20
   18b8c:	dfc00415 	stw	ra,16(sp)
   18b90:	df000315 	stw	fp,12(sp)
   18b94:	df000304 	addi	fp,sp,12
   18b98:	e13ffe15 	stw	r4,-8(fp)
   18b9c:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   18ba0:	e0bffe17 	ldw	r2,-8(fp)
   18ba4:	10000616 	blt	r2,zero,18bc0 <fstat+0x38>
   18ba8:	e0bffe17 	ldw	r2,-8(fp)
   18bac:	10c00324 	muli	r3,r2,12
   18bb0:	008000f4 	movhi	r2,3
   18bb4:	10a03504 	addi	r2,r2,-32556
   18bb8:	1885883a 	add	r2,r3,r2
   18bbc:	00000106 	br	18bc4 <fstat+0x3c>
   18bc0:	0005883a 	mov	r2,zero
   18bc4:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
   18bc8:	e0bffd17 	ldw	r2,-12(fp)
   18bcc:	10001026 	beq	r2,zero,18c10 <fstat+0x88>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
   18bd0:	e0bffd17 	ldw	r2,-12(fp)
   18bd4:	10800017 	ldw	r2,0(r2)
   18bd8:	10800817 	ldw	r2,32(r2)
   18bdc:	10000726 	beq	r2,zero,18bfc <fstat+0x74>
    {
      return fd->dev->fstat(fd, st);
   18be0:	e0bffd17 	ldw	r2,-12(fp)
   18be4:	10800017 	ldw	r2,0(r2)
   18be8:	10800817 	ldw	r2,32(r2)
   18bec:	e13ffd17 	ldw	r4,-12(fp)
   18bf0:	e17fff17 	ldw	r5,-4(fp)
   18bf4:	103ee83a 	callr	r2
   18bf8:	00000906 	br	18c20 <fstat+0x98>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
   18bfc:	e0bfff17 	ldw	r2,-4(fp)
   18c00:	00c80004 	movi	r3,8192
   18c04:	10c00115 	stw	r3,4(r2)
      return 0;
   18c08:	0005883a 	mov	r2,zero
   18c0c:	00000406 	br	18c20 <fstat+0x98>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
   18c10:	0018b380 	call	18b38 <alt_get_errno>
   18c14:	00c01444 	movi	r3,81
   18c18:	10c00015 	stw	r3,0(r2)
    return -1;
   18c1c:	00bfffc4 	movi	r2,-1
  }
}
   18c20:	e037883a 	mov	sp,fp
   18c24:	dfc00117 	ldw	ra,4(sp)
   18c28:	df000017 	ldw	fp,0(sp)
   18c2c:	dec00204 	addi	sp,sp,8
   18c30:	f800283a 	ret

00018c34 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   18c34:	defffe04 	addi	sp,sp,-8
   18c38:	dfc00115 	stw	ra,4(sp)
   18c3c:	df000015 	stw	fp,0(sp)
   18c40:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   18c44:	008000f4 	movhi	r2,3
   18c48:	10a61304 	addi	r2,r2,-26548
   18c4c:	10800017 	ldw	r2,0(r2)
   18c50:	10000526 	beq	r2,zero,18c68 <alt_get_errno+0x34>
   18c54:	008000f4 	movhi	r2,3
   18c58:	10a61304 	addi	r2,r2,-26548
   18c5c:	10800017 	ldw	r2,0(r2)
   18c60:	103ee83a 	callr	r2
   18c64:	00000206 	br	18c70 <alt_get_errno+0x3c>
   18c68:	008000f4 	movhi	r2,3
   18c6c:	10aed404 	addi	r2,r2,-17584
}
   18c70:	e037883a 	mov	sp,fp
   18c74:	dfc00117 	ldw	ra,4(sp)
   18c78:	df000017 	ldw	fp,0(sp)
   18c7c:	dec00204 	addi	sp,sp,8
   18c80:	f800283a 	ret

00018c84 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
   18c84:	deffed04 	addi	sp,sp,-76
   18c88:	dfc01215 	stw	ra,72(sp)
   18c8c:	df001115 	stw	fp,68(sp)
   18c90:	df001104 	addi	fp,sp,68
   18c94:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   18c98:	e0bfff17 	ldw	r2,-4(fp)
   18c9c:	10000616 	blt	r2,zero,18cb8 <isatty+0x34>
   18ca0:	e0bfff17 	ldw	r2,-4(fp)
   18ca4:	10c00324 	muli	r3,r2,12
   18ca8:	008000f4 	movhi	r2,3
   18cac:	10a03504 	addi	r2,r2,-32556
   18cb0:	1885883a 	add	r2,r3,r2
   18cb4:	00000106 	br	18cbc <isatty+0x38>
   18cb8:	0005883a 	mov	r2,zero
   18cbc:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
   18cc0:	e0bfef17 	ldw	r2,-68(fp)
   18cc4:	10000e26 	beq	r2,zero,18d00 <isatty+0x7c>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
   18cc8:	e0bfef17 	ldw	r2,-68(fp)
   18ccc:	10800017 	ldw	r2,0(r2)
   18cd0:	10800817 	ldw	r2,32(r2)
   18cd4:	1000021e 	bne	r2,zero,18ce0 <isatty+0x5c>
    {
      return 1;
   18cd8:	00800044 	movi	r2,1
   18cdc:	00000c06 	br	18d10 <isatty+0x8c>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
   18ce0:	e0bff004 	addi	r2,fp,-64
   18ce4:	e13fff17 	ldw	r4,-4(fp)
   18ce8:	100b883a 	mov	r5,r2
   18cec:	0018b880 	call	18b88 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
   18cf0:	e0bff117 	ldw	r2,-60(fp)
   18cf4:	10880020 	cmpeqi	r2,r2,8192
   18cf8:	10803fcc 	andi	r2,r2,255
   18cfc:	00000406 	br	18d10 <isatty+0x8c>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
   18d00:	0018c340 	call	18c34 <alt_get_errno>
   18d04:	00c01444 	movi	r3,81
   18d08:	10c00015 	stw	r3,0(r2)
    return 0;
   18d0c:	0005883a 	mov	r2,zero
  }
}
   18d10:	e037883a 	mov	sp,fp
   18d14:	dfc00117 	ldw	ra,4(sp)
   18d18:	df000017 	ldw	fp,0(sp)
   18d1c:	dec00204 	addi	sp,sp,8
   18d20:	f800283a 	ret

00018d24 <alt_load_section>:
   18d24:	defffc04 	addi	sp,sp,-16
   18d28:	df000315 	stw	fp,12(sp)
   18d2c:	df000304 	addi	fp,sp,12
   18d30:	e13ffd15 	stw	r4,-12(fp)
   18d34:	e17ffe15 	stw	r5,-8(fp)
   18d38:	e1bfff15 	stw	r6,-4(fp)
   18d3c:	e0fffe17 	ldw	r3,-8(fp)
   18d40:	e0bffd17 	ldw	r2,-12(fp)
   18d44:	18800e26 	beq	r3,r2,18d80 <alt_load_section+0x5c>
   18d48:	00000a06 	br	18d74 <alt_load_section+0x50>
   18d4c:	e0bffd17 	ldw	r2,-12(fp)
   18d50:	10c00017 	ldw	r3,0(r2)
   18d54:	e0bffe17 	ldw	r2,-8(fp)
   18d58:	10c00015 	stw	r3,0(r2)
   18d5c:	e0bffe17 	ldw	r2,-8(fp)
   18d60:	10800104 	addi	r2,r2,4
   18d64:	e0bffe15 	stw	r2,-8(fp)
   18d68:	e0bffd17 	ldw	r2,-12(fp)
   18d6c:	10800104 	addi	r2,r2,4
   18d70:	e0bffd15 	stw	r2,-12(fp)
   18d74:	e0fffe17 	ldw	r3,-8(fp)
   18d78:	e0bfff17 	ldw	r2,-4(fp)
   18d7c:	18bff31e 	bne	r3,r2,18d4c <alt_load_section+0x28>
   18d80:	e037883a 	mov	sp,fp
   18d84:	df000017 	ldw	fp,0(sp)
   18d88:	dec00104 	addi	sp,sp,4
   18d8c:	f800283a 	ret

00018d90 <alt_load>:
   18d90:	defffe04 	addi	sp,sp,-8
   18d94:	dfc00115 	stw	ra,4(sp)
   18d98:	df000015 	stw	fp,0(sp)
   18d9c:	d839883a 	mov	fp,sp
   18da0:	010000f4 	movhi	r4,3
   18da4:	21261e04 	addi	r4,r4,-26504
   18da8:	014000b4 	movhi	r5,2
   18dac:	295d9604 	addi	r5,r5,30296
   18db0:	018000f4 	movhi	r6,3
   18db4:	31a61e04 	addi	r6,r6,-26504
   18db8:	0018d240 	call	18d24 <alt_load_section>
   18dbc:	01000034 	movhi	r4,0
   18dc0:	21000804 	addi	r4,r4,32
   18dc4:	01400034 	movhi	r5,0
   18dc8:	29400804 	addi	r5,r5,32
   18dcc:	01800034 	movhi	r6,0
   18dd0:	31800804 	addi	r6,r6,32
   18dd4:	0018d240 	call	18d24 <alt_load_section>
   18dd8:	010000b4 	movhi	r4,2
   18ddc:	210d4b04 	addi	r4,r4,13612
   18de0:	014000b4 	movhi	r5,2
   18de4:	294d4b04 	addi	r5,r5,13612
   18de8:	018000b4 	movhi	r6,2
   18dec:	319d9604 	addi	r6,r6,30296
   18df0:	0018d240 	call	18d24 <alt_load_section>
   18df4:	0021f480 	call	21f48 <alt_dcache_flush_all>
   18df8:	00222540 	call	22254 <alt_icache_flush_all>
   18dfc:	e037883a 	mov	sp,fp
   18e00:	dfc00117 	ldw	ra,4(sp)
   18e04:	df000017 	ldw	fp,0(sp)
   18e08:	dec00204 	addi	sp,sp,8
   18e0c:	f800283a 	ret

00018e10 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   18e10:	defffe04 	addi	sp,sp,-8
   18e14:	dfc00115 	stw	ra,4(sp)
   18e18:	df000015 	stw	fp,0(sp)
   18e1c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   18e20:	008000f4 	movhi	r2,3
   18e24:	10a61304 	addi	r2,r2,-26548
   18e28:	10800017 	ldw	r2,0(r2)
   18e2c:	10000526 	beq	r2,zero,18e44 <alt_get_errno+0x34>
   18e30:	008000f4 	movhi	r2,3
   18e34:	10a61304 	addi	r2,r2,-26548
   18e38:	10800017 	ldw	r2,0(r2)
   18e3c:	103ee83a 	callr	r2
   18e40:	00000206 	br	18e4c <alt_get_errno+0x3c>
   18e44:	008000f4 	movhi	r2,3
   18e48:	10aed404 	addi	r2,r2,-17584
}
   18e4c:	e037883a 	mov	sp,fp
   18e50:	dfc00117 	ldw	ra,4(sp)
   18e54:	df000017 	ldw	fp,0(sp)
   18e58:	dec00204 	addi	sp,sp,8
   18e5c:	f800283a 	ret

00018e60 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
   18e60:	defff904 	addi	sp,sp,-28
   18e64:	dfc00615 	stw	ra,24(sp)
   18e68:	df000515 	stw	fp,20(sp)
   18e6c:	df000504 	addi	fp,sp,20
   18e70:	e13ffd15 	stw	r4,-12(fp)
   18e74:	e17ffe15 	stw	r5,-8(fp)
   18e78:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
   18e7c:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   18e80:	e0bffd17 	ldw	r2,-12(fp)
   18e84:	10000616 	blt	r2,zero,18ea0 <lseek+0x40>
   18e88:	e0bffd17 	ldw	r2,-12(fp)
   18e8c:	10c00324 	muli	r3,r2,12
   18e90:	008000f4 	movhi	r2,3
   18e94:	10a03504 	addi	r2,r2,-32556
   18e98:	1885883a 	add	r2,r3,r2
   18e9c:	00000106 	br	18ea4 <lseek+0x44>
   18ea0:	0005883a 	mov	r2,zero
   18ea4:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
   18ea8:	e0bffc17 	ldw	r2,-16(fp)
   18eac:	10001026 	beq	r2,zero,18ef0 <lseek+0x90>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
   18eb0:	e0bffc17 	ldw	r2,-16(fp)
   18eb4:	10800017 	ldw	r2,0(r2)
   18eb8:	10800717 	ldw	r2,28(r2)
   18ebc:	10000926 	beq	r2,zero,18ee4 <lseek+0x84>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
   18ec0:	e0bffc17 	ldw	r2,-16(fp)
   18ec4:	10800017 	ldw	r2,0(r2)
   18ec8:	10800717 	ldw	r2,28(r2)
   18ecc:	e13ffc17 	ldw	r4,-16(fp)
   18ed0:	e17ffe17 	ldw	r5,-8(fp)
   18ed4:	e1bfff17 	ldw	r6,-4(fp)
   18ed8:	103ee83a 	callr	r2
   18edc:	e0bffb15 	stw	r2,-20(fp)
   18ee0:	00000506 	br	18ef8 <lseek+0x98>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
   18ee4:	00bfde84 	movi	r2,-134
   18ee8:	e0bffb15 	stw	r2,-20(fp)
   18eec:	00000206 	br	18ef8 <lseek+0x98>
    }
  }
  else  
  {
    rc = -EBADFD;
   18ef0:	00bfebc4 	movi	r2,-81
   18ef4:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
   18ef8:	e0bffb17 	ldw	r2,-20(fp)
   18efc:	1000060e 	bge	r2,zero,18f18 <lseek+0xb8>
  {
    ALT_ERRNO = -rc;
   18f00:	0018e100 	call	18e10 <alt_get_errno>
   18f04:	e0fffb17 	ldw	r3,-20(fp)
   18f08:	00c7c83a 	sub	r3,zero,r3
   18f0c:	10c00015 	stw	r3,0(r2)
    rc = -1;
   18f10:	00bfffc4 	movi	r2,-1
   18f14:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
   18f18:	e0bffb17 	ldw	r2,-20(fp)
}
   18f1c:	e037883a 	mov	sp,fp
   18f20:	dfc00117 	ldw	ra,4(sp)
   18f24:	df000017 	ldw	fp,0(sp)
   18f28:	dec00204 	addi	sp,sp,8
   18f2c:	f800283a 	ret

00018f30 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
   18f30:	defffd04 	addi	sp,sp,-12
   18f34:	dfc00215 	stw	ra,8(sp)
   18f38:	df000115 	stw	fp,4(sp)
   18f3c:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
   18f40:	0009883a 	mov	r4,zero
   18f44:	00196940 	call	19694 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
   18f48:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
   18f4c:	00196d40 	call	196d4 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
   18f50:	010000b4 	movhi	r4,2
   18f54:	2118a304 	addi	r4,r4,25228
   18f58:	014000b4 	movhi	r5,2
   18f5c:	2958a304 	addi	r5,r5,25228
   18f60:	018000b4 	movhi	r6,2
   18f64:	3198a304 	addi	r6,r6,25228
   18f68:	00223440 	call	22344 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
   18f6c:	00220540 	call	22054 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
   18f70:	010000b4 	movhi	r4,2
   18f74:	21082c04 	addi	r4,r4,8368
   18f78:	00231180 	call	23118 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
   18f7c:	d128d817 	ldw	r4,-23712(gp)
   18f80:	d0e8d917 	ldw	r3,-23708(gp)
   18f84:	d0a8da17 	ldw	r2,-23704(gp)
   18f88:	180b883a 	mov	r5,r3
   18f8c:	100d883a 	mov	r6,r2
   18f90:	000eea00 	call	eea0 <main>
   18f94:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
   18f98:	01000044 	movi	r4,1
   18f9c:	0018a440 	call	18a44 <close>
  exit (result);
   18fa0:	e13fff17 	ldw	r4,-4(fp)
   18fa4:	002312c0 	call	2312c <exit>

00018fa8 <__malloc_lock>:
   18fa8:	defffe04 	addi	sp,sp,-8
   18fac:	df000115 	stw	fp,4(sp)
   18fb0:	df000104 	addi	fp,sp,4
   18fb4:	e13fff15 	stw	r4,-4(fp)
   18fb8:	e037883a 	mov	sp,fp
   18fbc:	df000017 	ldw	fp,0(sp)
   18fc0:	dec00104 	addi	sp,sp,4
   18fc4:	f800283a 	ret

00018fc8 <__malloc_unlock>:
   18fc8:	defffe04 	addi	sp,sp,-8
   18fcc:	df000115 	stw	fp,4(sp)
   18fd0:	df000104 	addi	fp,sp,4
   18fd4:	e13fff15 	stw	r4,-4(fp)
   18fd8:	e037883a 	mov	sp,fp
   18fdc:	df000017 	ldw	fp,0(sp)
   18fe0:	dec00104 	addi	sp,sp,4
   18fe4:	f800283a 	ret

00018fe8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   18fe8:	defffe04 	addi	sp,sp,-8
   18fec:	dfc00115 	stw	ra,4(sp)
   18ff0:	df000015 	stw	fp,0(sp)
   18ff4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   18ff8:	008000f4 	movhi	r2,3
   18ffc:	10a61304 	addi	r2,r2,-26548
   19000:	10800017 	ldw	r2,0(r2)
   19004:	10000526 	beq	r2,zero,1901c <alt_get_errno+0x34>
   19008:	008000f4 	movhi	r2,3
   1900c:	10a61304 	addi	r2,r2,-26548
   19010:	10800017 	ldw	r2,0(r2)
   19014:	103ee83a 	callr	r2
   19018:	00000206 	br	19024 <alt_get_errno+0x3c>
   1901c:	008000f4 	movhi	r2,3
   19020:	10aed404 	addi	r2,r2,-17584
}
   19024:	e037883a 	mov	sp,fp
   19028:	dfc00117 	ldw	ra,4(sp)
   1902c:	df000017 	ldw	fp,0(sp)
   19030:	dec00204 	addi	sp,sp,8
   19034:	f800283a 	ret

00019038 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
   19038:	defff904 	addi	sp,sp,-28
   1903c:	dfc00615 	stw	ra,24(sp)
   19040:	df000515 	stw	fp,20(sp)
   19044:	df000504 	addi	fp,sp,20
   19048:	e13ffd15 	stw	r4,-12(fp)
   1904c:	e17ffe15 	stw	r5,-8(fp)
   19050:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   19054:	e0bffd17 	ldw	r2,-12(fp)
   19058:	10000616 	blt	r2,zero,19074 <read+0x3c>
   1905c:	e0bffd17 	ldw	r2,-12(fp)
   19060:	10c00324 	muli	r3,r2,12
   19064:	008000f4 	movhi	r2,3
   19068:	10a03504 	addi	r2,r2,-32556
   1906c:	1885883a 	add	r2,r3,r2
   19070:	00000106 	br	19078 <read+0x40>
   19074:	0005883a 	mov	r2,zero
   19078:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
   1907c:	e0bffb17 	ldw	r2,-20(fp)
   19080:	10002026 	beq	r2,zero,19104 <read+0xcc>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
   19084:	e0bffb17 	ldw	r2,-20(fp)
   19088:	10800217 	ldw	r2,8(r2)
   1908c:	108000cc 	andi	r2,r2,3
   19090:	10800060 	cmpeqi	r2,r2,1
   19094:	1000171e 	bne	r2,zero,190f4 <read+0xbc>
        (fd->dev->read))
   19098:	e0bffb17 	ldw	r2,-20(fp)
   1909c:	10800017 	ldw	r2,0(r2)
   190a0:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
   190a4:	10001326 	beq	r2,zero,190f4 <read+0xbc>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
   190a8:	e0bffb17 	ldw	r2,-20(fp)
   190ac:	10800017 	ldw	r2,0(r2)
   190b0:	10c00517 	ldw	r3,20(r2)
   190b4:	e0bfff17 	ldw	r2,-4(fp)
   190b8:	e13ffb17 	ldw	r4,-20(fp)
   190bc:	e17ffe17 	ldw	r5,-8(fp)
   190c0:	100d883a 	mov	r6,r2
   190c4:	183ee83a 	callr	r3
   190c8:	e0bffc15 	stw	r2,-16(fp)
   190cc:	e0bffc17 	ldw	r2,-16(fp)
   190d0:	1000060e 	bge	r2,zero,190ec <read+0xb4>
        {
          ALT_ERRNO = -rval;
   190d4:	0018fe80 	call	18fe8 <alt_get_errno>
   190d8:	e0fffc17 	ldw	r3,-16(fp)
   190dc:	00c7c83a 	sub	r3,zero,r3
   190e0:	10c00015 	stw	r3,0(r2)
          return -1;
   190e4:	00bfffc4 	movi	r2,-1
   190e8:	00000a06 	br	19114 <read+0xdc>
        }
        return rval;
   190ec:	e0bffc17 	ldw	r2,-16(fp)
   190f0:	00000806 	br	19114 <read+0xdc>
      }
      else
      {
        ALT_ERRNO = EACCES;
   190f4:	0018fe80 	call	18fe8 <alt_get_errno>
   190f8:	00c00344 	movi	r3,13
   190fc:	10c00015 	stw	r3,0(r2)
   19100:	00000306 	br	19110 <read+0xd8>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
   19104:	0018fe80 	call	18fe8 <alt_get_errno>
   19108:	00c01444 	movi	r3,81
   1910c:	10c00015 	stw	r3,0(r2)
  }
  return -1;
   19110:	00bfffc4 	movi	r2,-1
}
   19114:	e037883a 	mov	sp,fp
   19118:	dfc00117 	ldw	ra,4(sp)
   1911c:	df000017 	ldw	fp,0(sp)
   19120:	dec00204 	addi	sp,sp,8
   19124:	f800283a 	ret

00019128 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
   19128:	defffe04 	addi	sp,sp,-8
   1912c:	df000115 	stw	fp,4(sp)
   19130:	df000104 	addi	fp,sp,4
   19134:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
   19138:	e0bfff17 	ldw	r2,-4(fp)
   1913c:	108000d0 	cmplti	r2,r2,3
   19140:	10000d1e 	bne	r2,zero,19178 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
   19144:	00c000f4 	movhi	r3,3
   19148:	18e03504 	addi	r3,r3,-32556
   1914c:	e0bfff17 	ldw	r2,-4(fp)
   19150:	10800324 	muli	r2,r2,12
   19154:	1885883a 	add	r2,r3,r2
   19158:	10800204 	addi	r2,r2,8
   1915c:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
   19160:	00c000f4 	movhi	r3,3
   19164:	18e03504 	addi	r3,r3,-32556
   19168:	e0bfff17 	ldw	r2,-4(fp)
   1916c:	10800324 	muli	r2,r2,12
   19170:	1885883a 	add	r2,r3,r2
   19174:	10000015 	stw	zero,0(r2)
  }
}
   19178:	e037883a 	mov	sp,fp
   1917c:	df000017 	ldw	fp,0(sp)
   19180:	dec00104 	addi	sp,sp,4
   19184:	f800283a 	ret

00019188 <alt_remap_uncached>:
 * Convert a pointer to a block of cached memory, into a block of
 * uncached memory.
 */

volatile void* alt_remap_uncached (void* ptr, alt_u32 len)
{
   19188:	defffc04 	addi	sp,sp,-16
   1918c:	dfc00315 	stw	ra,12(sp)
   19190:	df000215 	stw	fp,8(sp)
   19194:	df000204 	addi	fp,sp,8
   19198:	e13ffe15 	stw	r4,-8(fp)
   1919c:	e17fff15 	stw	r5,-4(fp)
  alt_dcache_flush (ptr, len);
   191a0:	e13ffe17 	ldw	r4,-8(fp)
   191a4:	e17fff17 	ldw	r5,-4(fp)
   191a8:	0021f240 	call	21f24 <alt_dcache_flush>
  return (volatile void*) (((alt_u32) ptr) | BYPASS_DCACHE_MASK);
   191ac:	e0bffe17 	ldw	r2,-8(fp)
   191b0:	10a00034 	orhi	r2,r2,32768
}
   191b4:	e037883a 	mov	sp,fp
   191b8:	dfc00117 	ldw	ra,4(sp)
   191bc:	df000017 	ldw	fp,0(sp)
   191c0:	dec00204 	addi	sp,sp,8
   191c4:	f800283a 	ret

000191c8 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
   191c8:	defff704 	addi	sp,sp,-36
   191cc:	df000815 	stw	fp,32(sp)
   191d0:	df000804 	addi	fp,sp,32
   191d4:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   191d8:	0005303a 	rdctl	r2,status
   191dc:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   191e0:	e0fffa17 	ldw	r3,-24(fp)
   191e4:	00bfff84 	movi	r2,-2
   191e8:	1884703a 	and	r2,r3,r2
   191ec:	1001703a 	wrctl	status,r2
  
  return context;
   191f0:	e0bffa17 	ldw	r2,-24(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
   191f4:	e0bff815 	stw	r2,-32(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
   191f8:	d0a01717 	ldw	r2,-32676(gp)
   191fc:	10c000c4 	addi	r3,r2,3
   19200:	00bfff04 	movi	r2,-4
   19204:	1884703a 	and	r2,r3,r2
   19208:	d0a01715 	stw	r2,-32676(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
   1920c:	d0e01717 	ldw	r3,-32676(gp)
   19210:	e0bfff17 	ldw	r2,-4(fp)
   19214:	1885883a 	add	r2,r3,r2
   19218:	00c08034 	movhi	r3,512
   1921c:	18c00004 	addi	r3,r3,0
   19220:	1880112e 	bgeu	r3,r2,19268 <sbrk+0xa0>
   19224:	e0bff817 	ldw	r2,-32(fp)
   19228:	e0bffb15 	stw	r2,-20(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   1922c:	0005303a 	rdctl	r2,status
   19230:	e0bffc15 	stw	r2,-16(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   19234:	e0fffc17 	ldw	r3,-16(fp)
   19238:	00bfff84 	movi	r2,-2
   1923c:	1884703a 	and	r2,r3,r2
   19240:	e0bffc15 	stw	r2,-16(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   19244:	e0bffb17 	ldw	r2,-20(fp)
   19248:	1080004c 	andi	r2,r2,1
   1924c:	e0fffc17 	ldw	r3,-16(fp)
   19250:	1884b03a 	or	r2,r3,r2
   19254:	e0bffc15 	stw	r2,-16(fp)
  
  NIOS2_WRITE_STATUS (status);
   19258:	e0bffc17 	ldw	r2,-16(fp)
   1925c:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
   19260:	00bfffc4 	movi	r2,-1
   19264:	00001606 	br	192c0 <sbrk+0xf8>
  }
#endif

  prev_heap_end = heap_end; 
   19268:	d0a01717 	ldw	r2,-32676(gp)
   1926c:	e0bff915 	stw	r2,-28(fp)
  heap_end += incr; 
   19270:	d0e01717 	ldw	r3,-32676(gp)
   19274:	e0bfff17 	ldw	r2,-4(fp)
   19278:	1885883a 	add	r2,r3,r2
   1927c:	d0a01715 	stw	r2,-32676(gp)
   19280:	e0bff817 	ldw	r2,-32(fp)
   19284:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   19288:	0005303a 	rdctl	r2,status
   1928c:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   19290:	e0fffe17 	ldw	r3,-8(fp)
   19294:	00bfff84 	movi	r2,-2
   19298:	1884703a 	and	r2,r3,r2
   1929c:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   192a0:	e0bffd17 	ldw	r2,-12(fp)
   192a4:	1080004c 	andi	r2,r2,1
   192a8:	e0fffe17 	ldw	r3,-8(fp)
   192ac:	1884b03a 	or	r2,r3,r2
   192b0:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
   192b4:	e0bffe17 	ldw	r2,-8(fp)
   192b8:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
   192bc:	e0bff917 	ldw	r2,-28(fp)
} 
   192c0:	e037883a 	mov	sp,fp
   192c4:	df000017 	ldw	fp,0(sp)
   192c8:	dec00104 	addi	sp,sp,4
   192cc:	f800283a 	ret

000192d0 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
   192d0:	defff904 	addi	sp,sp,-28
   192d4:	df000615 	stw	fp,24(sp)
   192d8:	df000604 	addi	fp,sp,24
   192dc:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   192e0:	0005303a 	rdctl	r2,status
   192e4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   192e8:	e0fffb17 	ldw	r3,-20(fp)
   192ec:	00bfff84 	movi	r2,-2
   192f0:	1884703a 	and	r2,r3,r2
   192f4:	1001703a 	wrctl	status,r2
  
  return context;
   192f8:	e0bffb17 	ldw	r2,-20(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
   192fc:	e0bffa15 	stw	r2,-24(fp)
  alt_llist_remove (&alarm->llist);
   19300:	e0bfff17 	ldw	r2,-4(fp)
   19304:	e0bffc15 	stw	r2,-16(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
   19308:	e0bffc17 	ldw	r2,-16(fp)
   1930c:	10800017 	ldw	r2,0(r2)
   19310:	e0fffc17 	ldw	r3,-16(fp)
   19314:	18c00117 	ldw	r3,4(r3)
   19318:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
   1931c:	e0bffc17 	ldw	r2,-16(fp)
   19320:	10800117 	ldw	r2,4(r2)
   19324:	e0fffc17 	ldw	r3,-16(fp)
   19328:	18c00017 	ldw	r3,0(r3)
   1932c:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
   19330:	e0bffc17 	ldw	r2,-16(fp)
   19334:	e0fffc17 	ldw	r3,-16(fp)
   19338:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
   1933c:	e0bffc17 	ldw	r2,-16(fp)
   19340:	e0fffc17 	ldw	r3,-16(fp)
   19344:	10c00015 	stw	r3,0(r2)
   19348:	e0bffa17 	ldw	r2,-24(fp)
   1934c:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   19350:	0005303a 	rdctl	r2,status
   19354:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   19358:	e0fffe17 	ldw	r3,-8(fp)
   1935c:	00bfff84 	movi	r2,-2
   19360:	1884703a 	and	r2,r3,r2
   19364:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   19368:	e0bffd17 	ldw	r2,-12(fp)
   1936c:	1080004c 	andi	r2,r2,1
   19370:	e0fffe17 	ldw	r3,-8(fp)
   19374:	1884b03a 	or	r2,r3,r2
   19378:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
   1937c:	e0bffe17 	ldw	r2,-8(fp)
   19380:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
   19384:	e037883a 	mov	sp,fp
   19388:	df000017 	ldw	fp,0(sp)
   1938c:	dec00104 	addi	sp,sp,4
   19390:	f800283a 	ret

00019394 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
   19394:	defffb04 	addi	sp,sp,-20
   19398:	dfc00415 	stw	ra,16(sp)
   1939c:	df000315 	stw	fp,12(sp)
   193a0:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
   193a4:	d0a01817 	ldw	r2,-32672(gp)
   193a8:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
   193ac:	d0a8dc17 	ldw	r2,-23696(gp)
   193b0:	10800044 	addi	r2,r2,1
   193b4:	d0a8dc15 	stw	r2,-23696(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
   193b8:	00002e06 	br	19474 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
   193bc:	e0bffd17 	ldw	r2,-12(fp)
   193c0:	10800017 	ldw	r2,0(r2)
   193c4:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
   193c8:	e0bffd17 	ldw	r2,-12(fp)
   193cc:	10800403 	ldbu	r2,16(r2)
   193d0:	10803fcc 	andi	r2,r2,255
   193d4:	10000426 	beq	r2,zero,193e8 <alt_tick+0x54>
   193d8:	d0a8dc17 	ldw	r2,-23696(gp)
   193dc:	1000021e 	bne	r2,zero,193e8 <alt_tick+0x54>
    {
      alarm->rollover = 0;
   193e0:	e0bffd17 	ldw	r2,-12(fp)
   193e4:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
   193e8:	e0bffd17 	ldw	r2,-12(fp)
   193ec:	10800217 	ldw	r2,8(r2)
   193f0:	d0e8dc17 	ldw	r3,-23696(gp)
   193f4:	18801d36 	bltu	r3,r2,1946c <alt_tick+0xd8>
   193f8:	e0bffd17 	ldw	r2,-12(fp)
   193fc:	10800403 	ldbu	r2,16(r2)
   19400:	10803fcc 	andi	r2,r2,255
   19404:	1000191e 	bne	r2,zero,1946c <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
   19408:	e0bffd17 	ldw	r2,-12(fp)
   1940c:	10c00317 	ldw	r3,12(r2)
   19410:	e0bffd17 	ldw	r2,-12(fp)
   19414:	10800517 	ldw	r2,20(r2)
   19418:	1009883a 	mov	r4,r2
   1941c:	183ee83a 	callr	r3
   19420:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
   19424:	e0bfff17 	ldw	r2,-4(fp)
   19428:	1000031e 	bne	r2,zero,19438 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
   1942c:	e13ffd17 	ldw	r4,-12(fp)
   19430:	00192d00 	call	192d0 <alt_alarm_stop>
   19434:	00000d06 	br	1946c <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
   19438:	e0bffd17 	ldw	r2,-12(fp)
   1943c:	10c00217 	ldw	r3,8(r2)
   19440:	e0bfff17 	ldw	r2,-4(fp)
   19444:	1887883a 	add	r3,r3,r2
   19448:	e0bffd17 	ldw	r2,-12(fp)
   1944c:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
   19450:	e0bffd17 	ldw	r2,-12(fp)
   19454:	10c00217 	ldw	r3,8(r2)
   19458:	d0a8dc17 	ldw	r2,-23696(gp)
   1945c:	1880032e 	bgeu	r3,r2,1946c <alt_tick+0xd8>
        {
          alarm->rollover = 1;
   19460:	e0bffd17 	ldw	r2,-12(fp)
   19464:	00c00044 	movi	r3,1
   19468:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
   1946c:	e0bffe17 	ldw	r2,-8(fp)
   19470:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
   19474:	e0fffd17 	ldw	r3,-12(fp)
   19478:	d0a01804 	addi	r2,gp,-32672
   1947c:	18bfcf1e 	bne	r3,r2,193bc <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
   19480:	0001883a 	nop
}
   19484:	e037883a 	mov	sp,fp
   19488:	dfc00117 	ldw	ra,4(sp)
   1948c:	df000017 	ldw	fp,0(sp)
   19490:	dec00204 	addi	sp,sp,8
   19494:	f800283a 	ret

00019498 <alt_uncached_malloc>:
/*
 * Allocate a block of uncached memory.
 */

volatile void* alt_uncached_malloc (size_t size)
{
   19498:	defffc04 	addi	sp,sp,-16
   1949c:	dfc00315 	stw	ra,12(sp)
   194a0:	df000215 	stw	fp,8(sp)
   194a4:	df000204 	addi	fp,sp,8
   194a8:	e13fff15 	stw	r4,-4(fp)
  void* ptr;

  ptr = malloc (size);
   194ac:	e13fff17 	ldw	r4,-4(fp)
   194b0:	00231640 	call	23164 <malloc>
   194b4:	e0bffe15 	stw	r2,-8(fp)

  alt_dcache_flush (ptr, size);
   194b8:	e13ffe17 	ldw	r4,-8(fp)
   194bc:	e17fff17 	ldw	r5,-4(fp)
   194c0:	0021f240 	call	21f24 <alt_dcache_flush>

  return ptr ? (volatile void*) (((alt_u32) ptr) | BYPASS_DCACHE_MASK) : NULL;
   194c4:	e0bffe17 	ldw	r2,-8(fp)
   194c8:	10000326 	beq	r2,zero,194d8 <alt_uncached_malloc+0x40>
   194cc:	e0bffe17 	ldw	r2,-8(fp)
   194d0:	10a00034 	orhi	r2,r2,32768
   194d4:	00000106 	br	194dc <alt_uncached_malloc+0x44>
   194d8:	0005883a 	mov	r2,zero
}
   194dc:	e037883a 	mov	sp,fp
   194e0:	dfc00117 	ldw	ra,4(sp)
   194e4:	df000017 	ldw	fp,0(sp)
   194e8:	dec00204 	addi	sp,sp,8
   194ec:	f800283a 	ret

000194f0 <usleep>:
   194f0:	defffd04 	addi	sp,sp,-12
   194f4:	dfc00215 	stw	ra,8(sp)
   194f8:	df000115 	stw	fp,4(sp)
   194fc:	df000104 	addi	fp,sp,4
   19500:	e13fff15 	stw	r4,-4(fp)
   19504:	e13fff17 	ldw	r4,-4(fp)
   19508:	0021dfc0 	call	21dfc <alt_busy_sleep>
   1950c:	e037883a 	mov	sp,fp
   19510:	dfc00117 	ldw	ra,4(sp)
   19514:	df000017 	ldw	fp,0(sp)
   19518:	dec00204 	addi	sp,sp,8
   1951c:	f800283a 	ret

00019520 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   19520:	defffe04 	addi	sp,sp,-8
   19524:	dfc00115 	stw	ra,4(sp)
   19528:	df000015 	stw	fp,0(sp)
   1952c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   19530:	008000f4 	movhi	r2,3
   19534:	10a61304 	addi	r2,r2,-26548
   19538:	10800017 	ldw	r2,0(r2)
   1953c:	10000526 	beq	r2,zero,19554 <alt_get_errno+0x34>
   19540:	008000f4 	movhi	r2,3
   19544:	10a61304 	addi	r2,r2,-26548
   19548:	10800017 	ldw	r2,0(r2)
   1954c:	103ee83a 	callr	r2
   19550:	00000206 	br	1955c <alt_get_errno+0x3c>
   19554:	008000f4 	movhi	r2,3
   19558:	10aed404 	addi	r2,r2,-17584
}
   1955c:	e037883a 	mov	sp,fp
   19560:	dfc00117 	ldw	ra,4(sp)
   19564:	df000017 	ldw	fp,0(sp)
   19568:	dec00204 	addi	sp,sp,8
   1956c:	f800283a 	ret

00019570 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
   19570:	defff904 	addi	sp,sp,-28
   19574:	dfc00615 	stw	ra,24(sp)
   19578:	df000515 	stw	fp,20(sp)
   1957c:	df000504 	addi	fp,sp,20
   19580:	e13ffd15 	stw	r4,-12(fp)
   19584:	e17ffe15 	stw	r5,-8(fp)
   19588:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   1958c:	e0bffd17 	ldw	r2,-12(fp)
   19590:	10000616 	blt	r2,zero,195ac <write+0x3c>
   19594:	e0bffd17 	ldw	r2,-12(fp)
   19598:	10c00324 	muli	r3,r2,12
   1959c:	008000f4 	movhi	r2,3
   195a0:	10a03504 	addi	r2,r2,-32556
   195a4:	1885883a 	add	r2,r3,r2
   195a8:	00000106 	br	195b0 <write+0x40>
   195ac:	0005883a 	mov	r2,zero
   195b0:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
   195b4:	e0bffb17 	ldw	r2,-20(fp)
   195b8:	10001f26 	beq	r2,zero,19638 <write+0xc8>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
   195bc:	e0bffb17 	ldw	r2,-20(fp)
   195c0:	10800217 	ldw	r2,8(r2)
   195c4:	108000cc 	andi	r2,r2,3
   195c8:	10001726 	beq	r2,zero,19628 <write+0xb8>
   195cc:	e0bffb17 	ldw	r2,-20(fp)
   195d0:	10800017 	ldw	r2,0(r2)
   195d4:	10800617 	ldw	r2,24(r2)
   195d8:	10001326 	beq	r2,zero,19628 <write+0xb8>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
   195dc:	e0bffb17 	ldw	r2,-20(fp)
   195e0:	10800017 	ldw	r2,0(r2)
   195e4:	10c00617 	ldw	r3,24(r2)
   195e8:	e0bfff17 	ldw	r2,-4(fp)
   195ec:	e13ffb17 	ldw	r4,-20(fp)
   195f0:	e17ffe17 	ldw	r5,-8(fp)
   195f4:	100d883a 	mov	r6,r2
   195f8:	183ee83a 	callr	r3
   195fc:	e0bffc15 	stw	r2,-16(fp)
   19600:	e0bffc17 	ldw	r2,-16(fp)
   19604:	1000060e 	bge	r2,zero,19620 <write+0xb0>
      {
        ALT_ERRNO = -rval;
   19608:	00195200 	call	19520 <alt_get_errno>
   1960c:	e0fffc17 	ldw	r3,-16(fp)
   19610:	00c7c83a 	sub	r3,zero,r3
   19614:	10c00015 	stw	r3,0(r2)
        return -1;
   19618:	00bfffc4 	movi	r2,-1
   1961c:	00000a06 	br	19648 <write+0xd8>
      }
      return rval;
   19620:	e0bffc17 	ldw	r2,-16(fp)
   19624:	00000806 	br	19648 <write+0xd8>
    }
    else
    {
      ALT_ERRNO = EACCES;
   19628:	00195200 	call	19520 <alt_get_errno>
   1962c:	00c00344 	movi	r3,13
   19630:	10c00015 	stw	r3,0(r2)
   19634:	00000306 	br	19644 <write+0xd4>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
   19638:	00195200 	call	19520 <alt_get_errno>
   1963c:	00c01444 	movi	r3,81
   19640:	10c00015 	stw	r3,0(r2)
  }
  return -1;
   19644:	00bfffc4 	movi	r2,-1
}
   19648:	e037883a 	mov	sp,fp
   1964c:	dfc00117 	ldw	ra,4(sp)
   19650:	df000017 	ldw	fp,0(sp)
   19654:	dec00204 	addi	sp,sp,8
   19658:	f800283a 	ret

0001965c <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
   1965c:	defffd04 	addi	sp,sp,-12
   19660:	dfc00215 	stw	ra,8(sp)
   19664:	df000115 	stw	fp,4(sp)
   19668:	df000104 	addi	fp,sp,4
   1966c:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
   19670:	e13fff17 	ldw	r4,-4(fp)
   19674:	014000f4 	movhi	r5,3
   19678:	29661004 	addi	r5,r5,-26560
   1967c:	0021fb40 	call	21fb4 <alt_dev_llist_insert>
}
   19680:	e037883a 	mov	sp,fp
   19684:	dfc00117 	ldw	ra,4(sp)
   19688:	df000017 	ldw	fp,0(sp)
   1968c:	dec00204 	addi	sp,sp,8
   19690:	f800283a 	ret

00019694 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
   19694:	defffd04 	addi	sp,sp,-12
   19698:	dfc00215 	stw	ra,8(sp)
   1969c:	df000115 	stw	fp,4(sp)
   196a0:	df000104 	addi	fp,sp,4
   196a4:	e13fff15 	stw	r4,-4(fp)
    ALTERA_VIC_IRQ_INIT ( VIC_0, vic_0);
   196a8:	010000f4 	movhi	r4,3
   196ac:	21209504 	addi	r4,r4,-32172
   196b0:	0021b680 	call	21b68 <alt_vic_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
   196b4:	00802034 	movhi	r2,128
   196b8:	10800044 	addi	r2,r2,1
   196bc:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
   196c0:	e037883a 	mov	sp,fp
   196c4:	dfc00117 	ldw	ra,4(sp)
   196c8:	df000017 	ldw	fp,0(sp)
   196cc:	dec00204 	addi	sp,sp,8
   196d0:	f800283a 	ret

000196d4 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
   196d4:	defffe04 	addi	sp,sp,-8
   196d8:	dfc00115 	stw	ra,4(sp)
   196dc:	df000015 	stw	fp,0(sp)
   196e0:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( SYS_CLK_TIMER, sys_clk_timer);
   196e4:	01020034 	movhi	r4,2048
   196e8:	21005804 	addi	r4,r4,352
   196ec:	000b883a 	mov	r5,zero
   196f0:	000d883a 	mov	r6,zero
   196f4:	01c0fa04 	movi	r7,1000
   196f8:	001dc440 	call	1dc44 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
   196fc:	008000f4 	movhi	r2,3
   19700:	10aeda04 	addi	r2,r2,-17560
   19704:	00c20034 	movhi	r3,2048
   19708:	18c08004 	addi	r3,r3,512
   1970c:	10c00015 	stw	r3,0(r2)
   19710:	008000f4 	movhi	r2,3
   19714:	10aedb04 	addi	r2,r2,-17556
   19718:	00c0e534 	movhi	r3,916
   1971c:	18e1c004 	addi	r3,r3,-30976
   19720:	10c00015 	stw	r3,0(r2)
    ALTERA_AVALON_TIMER_INIT ( TIMER_5, timer_5);
    ALTERA_AVALON_TIMER_INIT ( TIMER_6, timer_6);
    ALTERA_AVALON_TIMER_INIT ( TIMER_7, timer_7);
    ALTERA_AVALON_TIMER_INIT ( TIMER_8, timer_8);
    ALTERA_AVALON_TIMER_INIT ( TIMER_9, timer_9);
    ALTERA_AVALON_CFI_FLASH_INIT ( EXT_FLASH, ext_flash);
   19724:	010000f4 	movhi	r4,3
   19728:	2120bc04 	addi	r4,r4,-32016
   1972c:	00198440 	call	19844 <alt_flash_cfi_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
   19730:	010000f4 	movhi	r4,3
   19734:	2120fc04 	addi	r4,r4,-31760
   19738:	000b883a 	mov	r5,zero
   1973c:	01800044 	movi	r6,1
   19740:	001b6340 	call	1b634 <altera_avalon_jtag_uart_init>
   19744:	010000f4 	movhi	r4,3
   19748:	2120f204 	addi	r4,r4,-31800
   1974c:	001965c0 	call	1965c <alt_dev_reg>
    ALTERA_AVALON_LCD_16207_INIT ( LCD, lcd);
   19750:	010000f4 	movhi	r4,3
   19754:	21251404 	addi	r4,r4,-27568
   19758:	001cce00 	call	1cce0 <altera_avalon_lcd_16207_init>
   1975c:	010000f4 	movhi	r4,3
   19760:	21250a04 	addi	r4,r4,-27608
   19764:	001965c0 	call	1965c <alt_dev_reg>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
   19768:	010000f4 	movhi	r4,3
   1976c:	21255204 	addi	r4,r4,-27320
   19770:	000b883a 	mov	r5,zero
   19774:	01800304 	movi	r6,12
   19778:	001db000 	call	1db00 <alt_avalon_sgdma_init>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TX, sgdma_tx);
   1977c:	010000f4 	movhi	r4,3
   19780:	21255e04 	addi	r4,r4,-27272
   19784:	000b883a 	mov	r5,zero
   19788:	01800344 	movi	r6,13
   1978c:	001db000 	call	1db00 <alt_avalon_sgdma_init>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, sysid);
   19790:	0001883a 	nop
    ALTERA_AVALON_UART_INIT ( RS232, rs232);
   19794:	010000f4 	movhi	r4,3
   19798:	21257404 	addi	r4,r4,-27184
   1979c:	000b883a 	mov	r5,zero
   197a0:	018001c4 	movi	r6,7
   197a4:	00210ac0 	call	210ac <altera_avalon_uart_init>
   197a8:	010000f4 	movhi	r4,3
   197ac:	21256a04 	addi	r4,r4,-27224
   197b0:	001965c0 	call	1965c <alt_dev_reg>
    ALTERA_AVALON_UART_INIT ( UART_0, uart_0);
   197b4:	010000f4 	movhi	r4,3
   197b8:	2125a504 	addi	r4,r4,-26988
   197bc:	000b883a 	mov	r5,zero
   197c0:	018000c4 	movi	r6,3
   197c4:	00210ac0 	call	210ac <altera_avalon_uart_init>
   197c8:	010000f4 	movhi	r4,3
   197cc:	21259b04 	addi	r4,r4,-27028
   197d0:	001965c0 	call	1965c <alt_dev_reg>
    ALTERA_AVALON_UART_INIT ( UART_1, uart_1);
   197d4:	010000f4 	movhi	r4,3
   197d8:	2125d604 	addi	r4,r4,-26792
   197dc:	000b883a 	mov	r5,zero
   197e0:	01800104 	movi	r6,4
   197e4:	00210ac0 	call	210ac <altera_avalon_uart_init>
   197e8:	010000f4 	movhi	r4,3
   197ec:	2125cc04 	addi	r4,r4,-26832
   197f0:	001965c0 	call	1965c <alt_dev_reg>
    ALTERA_ETH_TSE_INIT ( TSE_MAC, tse_mac);
   197f4:	0001883a 	nop
}
   197f8:	e037883a 	mov	sp,fp
   197fc:	dfc00117 	ldw	ra,4(sp)
   19800:	df000017 	ldw	fp,0(sp)
   19804:	dec00204 	addi	sp,sp,8
   19808:	f800283a 	ret

0001980c <alt_flash_device_register>:
   1980c:	defffd04 	addi	sp,sp,-12
   19810:	dfc00215 	stw	ra,8(sp)
   19814:	df000115 	stw	fp,4(sp)
   19818:	df000104 	addi	fp,sp,4
   1981c:	e13fff15 	stw	r4,-4(fp)
   19820:	e13fff17 	ldw	r4,-4(fp)
   19824:	014000f4 	movhi	r5,3
   19828:	29661b04 	addi	r5,r5,-26516
   1982c:	0021fb40 	call	21fb4 <alt_dev_llist_insert>
   19830:	e037883a 	mov	sp,fp
   19834:	dfc00117 	ldw	ra,4(sp)
   19838:	df000017 	ldw	fp,0(sp)
   1983c:	dec00204 	addi	sp,sp,8
   19840:	f800283a 	ret

00019844 <alt_flash_cfi_init>:
   19844:	defffc04 	addi	sp,sp,-16
   19848:	dfc00315 	stw	ra,12(sp)
   1984c:	df000215 	stw	fp,8(sp)
   19850:	df000204 	addi	fp,sp,8
   19854:	e13fff15 	stw	r4,-4(fp)
   19858:	e03ffe15 	stw	zero,-8(fp)
   1985c:	e13fff17 	ldw	r4,-4(fp)
   19860:	001ac8c0 	call	1ac8c <alt_read_cfi_width>
   19864:	e0bffe15 	stw	r2,-8(fp)
   19868:	e0bffe17 	ldw	r2,-8(fp)
   1986c:	1000031e 	bne	r2,zero,1987c <alt_flash_cfi_init+0x38>
   19870:	e13fff17 	ldw	r4,-4(fp)
   19874:	001a3e40 	call	1a3e4 <alt_set_flash_width_func>
   19878:	e0bffe15 	stw	r2,-8(fp)
   1987c:	e0bffe17 	ldw	r2,-8(fp)
   19880:	1000031e 	bne	r2,zero,19890 <alt_flash_cfi_init+0x4c>
   19884:	e13fff17 	ldw	r4,-4(fp)
   19888:	001a6c40 	call	1a6c4 <alt_read_cfi_table>
   1988c:	e0bffe15 	stw	r2,-8(fp)
   19890:	e0bffe17 	ldw	r2,-8(fp)
   19894:	1000031e 	bne	r2,zero,198a4 <alt_flash_cfi_init+0x60>
   19898:	e13fff17 	ldw	r4,-4(fp)
   1989c:	001a5a80 	call	1a5a8 <alt_set_flash_algorithm_func>
   198a0:	e0bffe15 	stw	r2,-8(fp)
   198a4:	e0bffe17 	ldw	r2,-8(fp)
   198a8:	1000041e 	bne	r2,zero,198bc <alt_flash_cfi_init+0x78>
   198ac:	e0bfff17 	ldw	r2,-4(fp)
   198b0:	1009883a 	mov	r4,r2
   198b4:	001980c0 	call	1980c <alt_flash_device_register>
   198b8:	e0bffe15 	stw	r2,-8(fp)
   198bc:	e0bffe17 	ldw	r2,-8(fp)
   198c0:	e037883a 	mov	sp,fp
   198c4:	dfc00117 	ldw	ra,4(sp)
   198c8:	df000017 	ldw	fp,0(sp)
   198cc:	dec00204 	addi	sp,sp,8
   198d0:	f800283a 	ret

000198d4 <alt_flash_cfi_write>:
   198d4:	defff104 	addi	sp,sp,-60
   198d8:	dfc00e15 	stw	ra,56(sp)
   198dc:	df000d15 	stw	fp,52(sp)
   198e0:	df000d04 	addi	fp,sp,52
   198e4:	e13ffc15 	stw	r4,-16(fp)
   198e8:	e17ffd15 	stw	r5,-12(fp)
   198ec:	e1bffe15 	stw	r6,-8(fp)
   198f0:	e1ffff15 	stw	r7,-4(fp)
   198f4:	e03ff415 	stw	zero,-48(fp)
   198f8:	e0bfff17 	ldw	r2,-4(fp)
   198fc:	e0bff815 	stw	r2,-32(fp)
   19900:	e0bffd17 	ldw	r2,-12(fp)
   19904:	e0bff915 	stw	r2,-28(fp)
   19908:	e0bffc17 	ldw	r2,-16(fp)
   1990c:	e0bffa15 	stw	r2,-24(fp)
   19910:	e03ff515 	stw	zero,-44(fp)
   19914:	00008806 	br	19b38 <alt_flash_cfi_write+0x264>
   19918:	e0fffa17 	ldw	r3,-24(fp)
   1991c:	e0bff517 	ldw	r2,-44(fp)
   19920:	1004913a 	slli	r2,r2,4
   19924:	1885883a 	add	r2,r3,r2
   19928:	10800d04 	addi	r2,r2,52
   1992c:	10800017 	ldw	r2,0(r2)
   19930:	e0fffd17 	ldw	r3,-12(fp)
   19934:	18807d16 	blt	r3,r2,19b2c <alt_flash_cfi_write+0x258>
   19938:	e0fffa17 	ldw	r3,-24(fp)
   1993c:	e0bff517 	ldw	r2,-44(fp)
   19940:	1004913a 	slli	r2,r2,4
   19944:	1885883a 	add	r2,r3,r2
   19948:	10800d04 	addi	r2,r2,52
   1994c:	10c00017 	ldw	r3,0(r2)
   19950:	e13ffa17 	ldw	r4,-24(fp)
   19954:	e0bff517 	ldw	r2,-44(fp)
   19958:	1004913a 	slli	r2,r2,4
   1995c:	2085883a 	add	r2,r4,r2
   19960:	10800e04 	addi	r2,r2,56
   19964:	10800017 	ldw	r2,0(r2)
   19968:	1885883a 	add	r2,r3,r2
   1996c:	e0fffd17 	ldw	r3,-12(fp)
   19970:	18806e0e 	bge	r3,r2,19b2c <alt_flash_cfi_write+0x258>
   19974:	e0fffa17 	ldw	r3,-24(fp)
   19978:	e0bff517 	ldw	r2,-44(fp)
   1997c:	1004913a 	slli	r2,r2,4
   19980:	1885883a 	add	r2,r3,r2
   19984:	10800d04 	addi	r2,r2,52
   19988:	10800017 	ldw	r2,0(r2)
   1998c:	e0bff715 	stw	r2,-36(fp)
   19990:	e03ff615 	stw	zero,-40(fp)
   19994:	00005d06 	br	19b0c <alt_flash_cfi_write+0x238>
   19998:	e0fffd17 	ldw	r3,-12(fp)
   1999c:	e0bff717 	ldw	r2,-36(fp)
   199a0:	18804e16 	blt	r3,r2,19adc <alt_flash_cfi_write+0x208>
   199a4:	e0fffa17 	ldw	r3,-24(fp)
   199a8:	e0bff517 	ldw	r2,-44(fp)
   199ac:	10800104 	addi	r2,r2,4
   199b0:	1004913a 	slli	r2,r2,4
   199b4:	1885883a 	add	r2,r3,r2
   199b8:	10c00017 	ldw	r3,0(r2)
   199bc:	e0bff717 	ldw	r2,-36(fp)
   199c0:	1885883a 	add	r2,r3,r2
   199c4:	e0fffd17 	ldw	r3,-12(fp)
   199c8:	1880440e 	bge	r3,r2,19adc <alt_flash_cfi_write+0x208>
   199cc:	e0fffa17 	ldw	r3,-24(fp)
   199d0:	e0bff517 	ldw	r2,-44(fp)
   199d4:	10800104 	addi	r2,r2,4
   199d8:	1004913a 	slli	r2,r2,4
   199dc:	1885883a 	add	r2,r3,r2
   199e0:	10c00017 	ldw	r3,0(r2)
   199e4:	e0bff717 	ldw	r2,-36(fp)
   199e8:	1887883a 	add	r3,r3,r2
   199ec:	e0bffd17 	ldw	r2,-12(fp)
   199f0:	1885c83a 	sub	r2,r3,r2
   199f4:	e0bffb15 	stw	r2,-20(fp)
   199f8:	e0fffb17 	ldw	r3,-20(fp)
   199fc:	e0bfff17 	ldw	r2,-4(fp)
   19a00:	1880010e 	bge	r3,r2,19a08 <alt_flash_cfi_write+0x134>
   19a04:	1805883a 	mov	r2,r3
   19a08:	e0bffb15 	stw	r2,-20(fp)
   19a0c:	e0bffa17 	ldw	r2,-24(fp)
   19a10:	10c00a17 	ldw	r3,40(r2)
   19a14:	e0bffd17 	ldw	r2,-12(fp)
   19a18:	1887883a 	add	r3,r3,r2
   19a1c:	e0bffb17 	ldw	r2,-20(fp)
   19a20:	e13ffe17 	ldw	r4,-8(fp)
   19a24:	180b883a 	mov	r5,r3
   19a28:	100d883a 	mov	r6,r2
   19a2c:	00101bc0 	call	101bc <memcmp>
   19a30:	10001426 	beq	r2,zero,19a84 <alt_flash_cfi_write+0x1b0>
   19a34:	e0bffa17 	ldw	r2,-24(fp)
   19a38:	10c00817 	ldw	r3,32(r2)
   19a3c:	e0bffa17 	ldw	r2,-24(fp)
   19a40:	1009883a 	mov	r4,r2
   19a44:	e17ff717 	ldw	r5,-36(fp)
   19a48:	183ee83a 	callr	r3
   19a4c:	e0bff415 	stw	r2,-48(fp)
   19a50:	e0bff417 	ldw	r2,-48(fp)
   19a54:	10000b1e 	bne	r2,zero,19a84 <alt_flash_cfi_write+0x1b0>
   19a58:	e0bffa17 	ldw	r2,-24(fp)
   19a5c:	10c00917 	ldw	r3,36(r2)
   19a60:	e0bffa17 	ldw	r2,-24(fp)
   19a64:	e13ffb17 	ldw	r4,-20(fp)
   19a68:	d9000015 	stw	r4,0(sp)
   19a6c:	1009883a 	mov	r4,r2
   19a70:	e17ff717 	ldw	r5,-36(fp)
   19a74:	e1bffd17 	ldw	r6,-12(fp)
   19a78:	e1fffe17 	ldw	r7,-8(fp)
   19a7c:	183ee83a 	callr	r3
   19a80:	e0bff415 	stw	r2,-48(fp)
   19a84:	e0ffff17 	ldw	r3,-4(fp)
   19a88:	e0bffb17 	ldw	r2,-20(fp)
   19a8c:	18802e26 	beq	r3,r2,19b48 <alt_flash_cfi_write+0x274>
   19a90:	e0bff417 	ldw	r2,-48(fp)
   19a94:	10002c1e 	bne	r2,zero,19b48 <alt_flash_cfi_write+0x274>
   19a98:	e0ffff17 	ldw	r3,-4(fp)
   19a9c:	e0bffb17 	ldw	r2,-20(fp)
   19aa0:	1885c83a 	sub	r2,r3,r2
   19aa4:	e0bfff15 	stw	r2,-4(fp)
   19aa8:	e0fffa17 	ldw	r3,-24(fp)
   19aac:	e0bff517 	ldw	r2,-44(fp)
   19ab0:	10800104 	addi	r2,r2,4
   19ab4:	1004913a 	slli	r2,r2,4
   19ab8:	1885883a 	add	r2,r3,r2
   19abc:	10c00017 	ldw	r3,0(r2)
   19ac0:	e0bff717 	ldw	r2,-36(fp)
   19ac4:	1885883a 	add	r2,r3,r2
   19ac8:	e0bffd15 	stw	r2,-12(fp)
   19acc:	e0bffb17 	ldw	r2,-20(fp)
   19ad0:	e0fffe17 	ldw	r3,-8(fp)
   19ad4:	1885883a 	add	r2,r3,r2
   19ad8:	e0bffe15 	stw	r2,-8(fp)
   19adc:	e0fffa17 	ldw	r3,-24(fp)
   19ae0:	e0bff517 	ldw	r2,-44(fp)
   19ae4:	10800104 	addi	r2,r2,4
   19ae8:	1004913a 	slli	r2,r2,4
   19aec:	1885883a 	add	r2,r3,r2
   19af0:	10800017 	ldw	r2,0(r2)
   19af4:	e0fff717 	ldw	r3,-36(fp)
   19af8:	1885883a 	add	r2,r3,r2
   19afc:	e0bff715 	stw	r2,-36(fp)
   19b00:	e0bff617 	ldw	r2,-40(fp)
   19b04:	10800044 	addi	r2,r2,1
   19b08:	e0bff615 	stw	r2,-40(fp)
   19b0c:	e0fffa17 	ldw	r3,-24(fp)
   19b10:	e0bff517 	ldw	r2,-44(fp)
   19b14:	1004913a 	slli	r2,r2,4
   19b18:	1885883a 	add	r2,r3,r2
   19b1c:	10800f04 	addi	r2,r2,60
   19b20:	10800017 	ldw	r2,0(r2)
   19b24:	e0fff617 	ldw	r3,-40(fp)
   19b28:	18bf9b16 	blt	r3,r2,19998 <alt_flash_cfi_write+0xc4>
   19b2c:	e0bff517 	ldw	r2,-44(fp)
   19b30:	10800044 	addi	r2,r2,1
   19b34:	e0bff515 	stw	r2,-44(fp)
   19b38:	e0bffa17 	ldw	r2,-24(fp)
   19b3c:	10800c17 	ldw	r2,48(r2)
   19b40:	e0fff517 	ldw	r3,-44(fp)
   19b44:	18bf7416 	blt	r3,r2,19918 <alt_flash_cfi_write+0x44>
   19b48:	e0bffa17 	ldw	r2,-24(fp)
   19b4c:	10c00a17 	ldw	r3,40(r2)
   19b50:	e0bff917 	ldw	r2,-28(fp)
   19b54:	1887883a 	add	r3,r3,r2
   19b58:	e0bff817 	ldw	r2,-32(fp)
   19b5c:	1809883a 	mov	r4,r3
   19b60:	100b883a 	mov	r5,r2
   19b64:	0021f240 	call	21f24 <alt_dcache_flush>
   19b68:	e0bff417 	ldw	r2,-48(fp)
   19b6c:	e037883a 	mov	sp,fp
   19b70:	dfc00117 	ldw	ra,4(sp)
   19b74:	df000017 	ldw	fp,0(sp)
   19b78:	dec00204 	addi	sp,sp,8
   19b7c:	f800283a 	ret

00019b80 <alt_flash_cfi_get_info>:
   19b80:	defffa04 	addi	sp,sp,-24
   19b84:	df000515 	stw	fp,20(sp)
   19b88:	df000504 	addi	fp,sp,20
   19b8c:	e13ffd15 	stw	r4,-12(fp)
   19b90:	e17ffe15 	stw	r5,-8(fp)
   19b94:	e1bfff15 	stw	r6,-4(fp)
   19b98:	e03ffb15 	stw	zero,-20(fp)
   19b9c:	e0bffd17 	ldw	r2,-12(fp)
   19ba0:	e0bffc15 	stw	r2,-16(fp)
   19ba4:	e0bffc17 	ldw	r2,-16(fp)
   19ba8:	10c00c17 	ldw	r3,48(r2)
   19bac:	e0bfff17 	ldw	r2,-4(fp)
   19bb0:	10c00015 	stw	r3,0(r2)
   19bb4:	e0bffc17 	ldw	r2,-16(fp)
   19bb8:	10800c17 	ldw	r2,48(r2)
   19bbc:	1000031e 	bne	r2,zero,19bcc <alt_flash_cfi_get_info+0x4c>
   19bc0:	00bffec4 	movi	r2,-5
   19bc4:	e0bffb15 	stw	r2,-20(fp)
   19bc8:	00000b06 	br	19bf8 <alt_flash_cfi_get_info+0x78>
   19bcc:	e0bffc17 	ldw	r2,-16(fp)
   19bd0:	10800c17 	ldw	r2,48(r2)
   19bd4:	10800250 	cmplti	r2,r2,9
   19bd8:	1000031e 	bne	r2,zero,19be8 <alt_flash_cfi_get_info+0x68>
   19bdc:	00bffd04 	movi	r2,-12
   19be0:	e0bffb15 	stw	r2,-20(fp)
   19be4:	00000406 	br	19bf8 <alt_flash_cfi_get_info+0x78>
   19be8:	e0bffc17 	ldw	r2,-16(fp)
   19bec:	10c00d04 	addi	r3,r2,52
   19bf0:	e0bffe17 	ldw	r2,-8(fp)
   19bf4:	10c00015 	stw	r3,0(r2)
   19bf8:	e0bffb17 	ldw	r2,-20(fp)
   19bfc:	e037883a 	mov	sp,fp
   19c00:	df000017 	ldw	fp,0(sp)
   19c04:	dec00104 	addi	sp,sp,4
   19c08:	f800283a 	ret

00019c0c <alt_flash_cfi_read>:
   19c0c:	defff904 	addi	sp,sp,-28
   19c10:	dfc00615 	stw	ra,24(sp)
   19c14:	df000515 	stw	fp,20(sp)
   19c18:	df000504 	addi	fp,sp,20
   19c1c:	e13ffc15 	stw	r4,-16(fp)
   19c20:	e17ffd15 	stw	r5,-12(fp)
   19c24:	e1bffe15 	stw	r6,-8(fp)
   19c28:	e1ffff15 	stw	r7,-4(fp)
   19c2c:	e0bffc17 	ldw	r2,-16(fp)
   19c30:	e0bffb15 	stw	r2,-20(fp)
   19c34:	e0bffb17 	ldw	r2,-20(fp)
   19c38:	10c00a17 	ldw	r3,40(r2)
   19c3c:	e0bffd17 	ldw	r2,-12(fp)
   19c40:	1887883a 	add	r3,r3,r2
   19c44:	e0bfff17 	ldw	r2,-4(fp)
   19c48:	e13ffe17 	ldw	r4,-8(fp)
   19c4c:	180b883a 	mov	r5,r3
   19c50:	100d883a 	mov	r6,r2
   19c54:	00102380 	call	10238 <memcpy>
   19c58:	0005883a 	mov	r2,zero
   19c5c:	e037883a 	mov	sp,fp
   19c60:	dfc00117 	ldw	ra,4(sp)
   19c64:	df000017 	ldw	fp,0(sp)
   19c68:	dec00204 	addi	sp,sp,8
   19c6c:	f800283a 	ret

00019c70 <alt_write_value_to_flash>:
   19c70:	defffa04 	addi	sp,sp,-24
   19c74:	df000515 	stw	fp,20(sp)
   19c78:	df000504 	addi	fp,sp,20
   19c7c:	e13ffd15 	stw	r4,-12(fp)
   19c80:	e17ffe15 	stw	r5,-8(fp)
   19c84:	e1bfff15 	stw	r6,-4(fp)
   19c88:	e0bffd17 	ldw	r2,-12(fp)
   19c8c:	10802e17 	ldw	r2,184(r2)
   19c90:	10800058 	cmpnei	r2,r2,1
   19c94:	1000091e 	bne	r2,zero,19cbc <alt_write_value_to_flash+0x4c>
   19c98:	e0bffd17 	ldw	r2,-12(fp)
   19c9c:	10c00a17 	ldw	r3,40(r2)
   19ca0:	e0bffe17 	ldw	r2,-8(fp)
   19ca4:	1885883a 	add	r2,r3,r2
   19ca8:	e0ffff17 	ldw	r3,-4(fp)
   19cac:	18c00003 	ldbu	r3,0(r3)
   19cb0:	18c03fcc 	andi	r3,r3,255
   19cb4:	10c00025 	stbio	r3,0(r2)
   19cb8:	00003e06 	br	19db4 <alt_write_value_to_flash+0x144>
   19cbc:	e0bffd17 	ldw	r2,-12(fp)
   19cc0:	10802e17 	ldw	r2,184(r2)
   19cc4:	10800098 	cmpnei	r2,r2,2
   19cc8:	1000141e 	bne	r2,zero,19d1c <alt_write_value_to_flash+0xac>
   19ccc:	e0bfff17 	ldw	r2,-4(fp)
   19cd0:	10800003 	ldbu	r2,0(r2)
   19cd4:	10803fcc 	andi	r2,r2,255
   19cd8:	e0bffb0d 	sth	r2,-20(fp)
   19cdc:	e0bfff17 	ldw	r2,-4(fp)
   19ce0:	10800044 	addi	r2,r2,1
   19ce4:	10800003 	ldbu	r2,0(r2)
   19ce8:	10803fcc 	andi	r2,r2,255
   19cec:	1004923a 	slli	r2,r2,8
   19cf0:	1007883a 	mov	r3,r2
   19cf4:	e0bffb0b 	ldhu	r2,-20(fp)
   19cf8:	1884b03a 	or	r2,r3,r2
   19cfc:	e0bffb0d 	sth	r2,-20(fp)
   19d00:	e0bffd17 	ldw	r2,-12(fp)
   19d04:	10c00a17 	ldw	r3,40(r2)
   19d08:	e0bffe17 	ldw	r2,-8(fp)
   19d0c:	1885883a 	add	r2,r3,r2
   19d10:	e0fffb0b 	ldhu	r3,-20(fp)
   19d14:	10c0002d 	sthio	r3,0(r2)
   19d18:	00002606 	br	19db4 <alt_write_value_to_flash+0x144>
   19d1c:	e0bffd17 	ldw	r2,-12(fp)
   19d20:	10802e17 	ldw	r2,184(r2)
   19d24:	10800118 	cmpnei	r2,r2,4
   19d28:	1000221e 	bne	r2,zero,19db4 <alt_write_value_to_flash+0x144>
   19d2c:	e0bfff17 	ldw	r2,-4(fp)
   19d30:	10800003 	ldbu	r2,0(r2)
   19d34:	10803fcc 	andi	r2,r2,255
   19d38:	e0bffc15 	stw	r2,-16(fp)
   19d3c:	e0bfff17 	ldw	r2,-4(fp)
   19d40:	10800044 	addi	r2,r2,1
   19d44:	10800003 	ldbu	r2,0(r2)
   19d48:	10803fcc 	andi	r2,r2,255
   19d4c:	1004923a 	slli	r2,r2,8
   19d50:	e0fffc17 	ldw	r3,-16(fp)
   19d54:	1884b03a 	or	r2,r3,r2
   19d58:	e0bffc15 	stw	r2,-16(fp)
   19d5c:	e0bfff17 	ldw	r2,-4(fp)
   19d60:	10800084 	addi	r2,r2,2
   19d64:	10800003 	ldbu	r2,0(r2)
   19d68:	10803fcc 	andi	r2,r2,255
   19d6c:	1004943a 	slli	r2,r2,16
   19d70:	e0fffc17 	ldw	r3,-16(fp)
   19d74:	1884b03a 	or	r2,r3,r2
   19d78:	e0bffc15 	stw	r2,-16(fp)
   19d7c:	e0bfff17 	ldw	r2,-4(fp)
   19d80:	108000c4 	addi	r2,r2,3
   19d84:	10800003 	ldbu	r2,0(r2)
   19d88:	10803fcc 	andi	r2,r2,255
   19d8c:	1004963a 	slli	r2,r2,24
   19d90:	e0fffc17 	ldw	r3,-16(fp)
   19d94:	1884b03a 	or	r2,r3,r2
   19d98:	e0bffc15 	stw	r2,-16(fp)
   19d9c:	e0bffd17 	ldw	r2,-12(fp)
   19da0:	10c00a17 	ldw	r3,40(r2)
   19da4:	e0bffe17 	ldw	r2,-8(fp)
   19da8:	1885883a 	add	r2,r3,r2
   19dac:	e0fffc17 	ldw	r3,-16(fp)
   19db0:	10c00035 	stwio	r3,0(r2)
   19db4:	0001883a 	nop
   19db8:	e037883a 	mov	sp,fp
   19dbc:	df000017 	ldw	fp,0(sp)
   19dc0:	dec00104 	addi	sp,sp,4
   19dc4:	f800283a 	ret

00019dc8 <alt_flash_program_block>:
   19dc8:	defff304 	addi	sp,sp,-52
   19dcc:	dfc00c15 	stw	ra,48(sp)
   19dd0:	df000b15 	stw	fp,44(sp)
   19dd4:	df000b04 	addi	fp,sp,44
   19dd8:	e13ffc15 	stw	r4,-16(fp)
   19ddc:	e17ffd15 	stw	r5,-12(fp)
   19de0:	e1bffe15 	stw	r6,-8(fp)
   19de4:	e1ffff15 	stw	r7,-4(fp)
   19de8:	e03ff515 	stw	zero,-44(fp)
   19dec:	e0bffc17 	ldw	r2,-16(fp)
   19df0:	10c00a17 	ldw	r3,40(r2)
   19df4:	e0bffd17 	ldw	r2,-12(fp)
   19df8:	1885883a 	add	r2,r3,r2
   19dfc:	e0fffc17 	ldw	r3,-16(fp)
   19e00:	18c02e17 	ldw	r3,184(r3)
   19e04:	10c9283a 	div	r4,r2,r3
   19e08:	20c7383a 	mul	r3,r4,r3
   19e0c:	10c5c83a 	sub	r2,r2,r3
   19e10:	e0bff815 	stw	r2,-32(fp)
   19e14:	e0bff817 	ldw	r2,-32(fp)
   19e18:	10003b26 	beq	r2,zero,19f08 <alt_flash_program_block+0x140>
   19e1c:	e0bffc17 	ldw	r2,-16(fp)
   19e20:	10c02e17 	ldw	r3,184(r2)
   19e24:	e0bff817 	ldw	r2,-32(fp)
   19e28:	1885c83a 	sub	r2,r3,r2
   19e2c:	e0bff915 	stw	r2,-28(fp)
   19e30:	e03ff615 	stw	zero,-40(fp)
   19e34:	00001206 	br	19e80 <alt_flash_program_block+0xb8>
   19e38:	e0bffc17 	ldw	r2,-16(fp)
   19e3c:	10c00a17 	ldw	r3,40(r2)
   19e40:	e13ffd17 	ldw	r4,-12(fp)
   19e44:	e0bff817 	ldw	r2,-32(fp)
   19e48:	2089c83a 	sub	r4,r4,r2
   19e4c:	e0bff617 	ldw	r2,-40(fp)
   19e50:	2085883a 	add	r2,r4,r2
   19e54:	1885883a 	add	r2,r3,r2
   19e58:	10800023 	ldbuio	r2,0(r2)
   19e5c:	10803fcc 	andi	r2,r2,255
   19e60:	1007883a 	mov	r3,r2
   19e64:	e13ffb04 	addi	r4,fp,-20
   19e68:	e0bff617 	ldw	r2,-40(fp)
   19e6c:	2085883a 	add	r2,r4,r2
   19e70:	10c00005 	stb	r3,0(r2)
   19e74:	e0bff617 	ldw	r2,-40(fp)
   19e78:	10800044 	addi	r2,r2,1
   19e7c:	e0bff615 	stw	r2,-40(fp)
   19e80:	e0fff617 	ldw	r3,-40(fp)
   19e84:	e0bff817 	ldw	r2,-32(fp)
   19e88:	18bfeb16 	blt	r3,r2,19e38 <alt_flash_program_block+0x70>
   19e8c:	e03ff615 	stw	zero,-40(fp)
   19e90:	00000d06 	br	19ec8 <alt_flash_program_block+0x100>
   19e94:	e0fff817 	ldw	r3,-32(fp)
   19e98:	e0bff617 	ldw	r2,-40(fp)
   19e9c:	1885883a 	add	r2,r3,r2
   19ea0:	e0fff617 	ldw	r3,-40(fp)
   19ea4:	e13ffe17 	ldw	r4,-8(fp)
   19ea8:	20c7883a 	add	r3,r4,r3
   19eac:	18c00003 	ldbu	r3,0(r3)
   19eb0:	e13ffb04 	addi	r4,fp,-20
   19eb4:	2085883a 	add	r2,r4,r2
   19eb8:	10c00005 	stb	r3,0(r2)
   19ebc:	e0bff617 	ldw	r2,-40(fp)
   19ec0:	10800044 	addi	r2,r2,1
   19ec4:	e0bff615 	stw	r2,-40(fp)
   19ec8:	e0fff617 	ldw	r3,-40(fp)
   19ecc:	e0bff917 	ldw	r2,-28(fp)
   19ed0:	18bff016 	blt	r3,r2,19e94 <alt_flash_program_block+0xcc>
   19ed4:	e0fffd17 	ldw	r3,-12(fp)
   19ed8:	e0bff817 	ldw	r2,-32(fp)
   19edc:	1887c83a 	sub	r3,r3,r2
   19ee0:	e0bffb04 	addi	r2,fp,-20
   19ee4:	e1c00217 	ldw	r7,8(fp)
   19ee8:	e13ffc17 	ldw	r4,-16(fp)
   19eec:	180b883a 	mov	r5,r3
   19ef0:	100d883a 	mov	r6,r2
   19ef4:	383ee83a 	callr	r7
   19ef8:	e0bff515 	stw	r2,-44(fp)
   19efc:	e0bff917 	ldw	r2,-28(fp)
   19f00:	e0bff615 	stw	r2,-40(fp)
   19f04:	00000106 	br	19f0c <alt_flash_program_block+0x144>
   19f08:	e03ff615 	stw	zero,-40(fp)
   19f0c:	e0fffd17 	ldw	r3,-12(fp)
   19f10:	e0bfff17 	ldw	r2,-4(fp)
   19f14:	1885883a 	add	r2,r3,r2
   19f18:	e0fffc17 	ldw	r3,-16(fp)
   19f1c:	18c02e17 	ldw	r3,184(r3)
   19f20:	10c9283a 	div	r4,r2,r3
   19f24:	20c7383a 	mul	r3,r4,r3
   19f28:	10c5c83a 	sub	r2,r2,r3
   19f2c:	e0bffa15 	stw	r2,-24(fp)
   19f30:	00001106 	br	19f78 <alt_flash_program_block+0x1b0>
   19f34:	e0fffd17 	ldw	r3,-12(fp)
   19f38:	e0bff617 	ldw	r2,-40(fp)
   19f3c:	1887883a 	add	r3,r3,r2
   19f40:	e0bff617 	ldw	r2,-40(fp)
   19f44:	e13ffe17 	ldw	r4,-8(fp)
   19f48:	2085883a 	add	r2,r4,r2
   19f4c:	e1c00217 	ldw	r7,8(fp)
   19f50:	e13ffc17 	ldw	r4,-16(fp)
   19f54:	180b883a 	mov	r5,r3
   19f58:	100d883a 	mov	r6,r2
   19f5c:	383ee83a 	callr	r7
   19f60:	e0bff515 	stw	r2,-44(fp)
   19f64:	e0bffc17 	ldw	r2,-16(fp)
   19f68:	10802e17 	ldw	r2,184(r2)
   19f6c:	e0fff617 	ldw	r3,-40(fp)
   19f70:	1885883a 	add	r2,r3,r2
   19f74:	e0bff615 	stw	r2,-40(fp)
   19f78:	e0bff517 	ldw	r2,-44(fp)
   19f7c:	1000051e 	bne	r2,zero,19f94 <alt_flash_program_block+0x1cc>
   19f80:	e0ffff17 	ldw	r3,-4(fp)
   19f84:	e0bffa17 	ldw	r2,-24(fp)
   19f88:	1885c83a 	sub	r2,r3,r2
   19f8c:	e0fff617 	ldw	r3,-40(fp)
   19f90:	18bfe816 	blt	r3,r2,19f34 <alt_flash_program_block+0x16c>
   19f94:	e0bffa17 	ldw	r2,-24(fp)
   19f98:	10003b26 	beq	r2,zero,1a088 <alt_flash_program_block+0x2c0>
   19f9c:	e0bff517 	ldw	r2,-44(fp)
   19fa0:	1000391e 	bne	r2,zero,1a088 <alt_flash_program_block+0x2c0>
   19fa4:	e0bffc17 	ldw	r2,-16(fp)
   19fa8:	10c02e17 	ldw	r3,184(r2)
   19fac:	e0bffa17 	ldw	r2,-24(fp)
   19fb0:	1885c83a 	sub	r2,r3,r2
   19fb4:	e0bff815 	stw	r2,-32(fp)
   19fb8:	e03ff715 	stw	zero,-36(fp)
   19fbc:	00000d06 	br	19ff4 <alt_flash_program_block+0x22c>
   19fc0:	e0fff617 	ldw	r3,-40(fp)
   19fc4:	e0bff717 	ldw	r2,-36(fp)
   19fc8:	1885883a 	add	r2,r3,r2
   19fcc:	e0fffe17 	ldw	r3,-8(fp)
   19fd0:	1885883a 	add	r2,r3,r2
   19fd4:	10c00003 	ldbu	r3,0(r2)
   19fd8:	e13ffb04 	addi	r4,fp,-20
   19fdc:	e0bff717 	ldw	r2,-36(fp)
   19fe0:	2085883a 	add	r2,r4,r2
   19fe4:	10c00005 	stb	r3,0(r2)
   19fe8:	e0bff717 	ldw	r2,-36(fp)
   19fec:	10800044 	addi	r2,r2,1
   19ff0:	e0bff715 	stw	r2,-36(fp)
   19ff4:	e0fff717 	ldw	r3,-36(fp)
   19ff8:	e0bffa17 	ldw	r2,-24(fp)
   19ffc:	18bff016 	blt	r3,r2,19fc0 <alt_flash_program_block+0x1f8>
   1a000:	e03ff715 	stw	zero,-36(fp)
   1a004:	00001306 	br	1a054 <alt_flash_program_block+0x28c>
   1a008:	e0fffa17 	ldw	r3,-24(fp)
   1a00c:	e0bff717 	ldw	r2,-36(fp)
   1a010:	1885883a 	add	r2,r3,r2
   1a014:	e0fffc17 	ldw	r3,-16(fp)
   1a018:	19000a17 	ldw	r4,40(r3)
   1a01c:	e17ffd17 	ldw	r5,-12(fp)
   1a020:	e0ffff17 	ldw	r3,-4(fp)
   1a024:	28cb883a 	add	r5,r5,r3
   1a028:	e0fff717 	ldw	r3,-36(fp)
   1a02c:	28c7883a 	add	r3,r5,r3
   1a030:	20c7883a 	add	r3,r4,r3
   1a034:	18c00023 	ldbuio	r3,0(r3)
   1a038:	18c03fcc 	andi	r3,r3,255
   1a03c:	e13ffb04 	addi	r4,fp,-20
   1a040:	2085883a 	add	r2,r4,r2
   1a044:	10c00005 	stb	r3,0(r2)
   1a048:	e0bff717 	ldw	r2,-36(fp)
   1a04c:	10800044 	addi	r2,r2,1
   1a050:	e0bff715 	stw	r2,-36(fp)
   1a054:	e0fff717 	ldw	r3,-36(fp)
   1a058:	e0bff817 	ldw	r2,-32(fp)
   1a05c:	18bfea16 	blt	r3,r2,1a008 <alt_flash_program_block+0x240>
   1a060:	e0fffd17 	ldw	r3,-12(fp)
   1a064:	e0bff617 	ldw	r2,-40(fp)
   1a068:	1887883a 	add	r3,r3,r2
   1a06c:	e0bffb04 	addi	r2,fp,-20
   1a070:	e1c00217 	ldw	r7,8(fp)
   1a074:	e13ffc17 	ldw	r4,-16(fp)
   1a078:	180b883a 	mov	r5,r3
   1a07c:	100d883a 	mov	r6,r2
   1a080:	383ee83a 	callr	r7
   1a084:	e0bff515 	stw	r2,-44(fp)
   1a088:	e0bff517 	ldw	r2,-44(fp)
   1a08c:	e037883a 	mov	sp,fp
   1a090:	dfc00117 	ldw	ra,4(sp)
   1a094:	df000017 	ldw	fp,0(sp)
   1a098:	dec00204 	addi	sp,sp,8
   1a09c:	f800283a 	ret

0001a0a0 <alt_read_query_entry_8bit>:
   1a0a0:	defffd04 	addi	sp,sp,-12
   1a0a4:	df000215 	stw	fp,8(sp)
   1a0a8:	df000204 	addi	fp,sp,8
   1a0ac:	e13ffe15 	stw	r4,-8(fp)
   1a0b0:	e17fff15 	stw	r5,-4(fp)
   1a0b4:	e0bffe17 	ldw	r2,-8(fp)
   1a0b8:	10c00a17 	ldw	r3,40(r2)
   1a0bc:	e0bfff17 	ldw	r2,-4(fp)
   1a0c0:	1885883a 	add	r2,r3,r2
   1a0c4:	10800023 	ldbuio	r2,0(r2)
   1a0c8:	10803fcc 	andi	r2,r2,255
   1a0cc:	e037883a 	mov	sp,fp
   1a0d0:	df000017 	ldw	fp,0(sp)
   1a0d4:	dec00104 	addi	sp,sp,4
   1a0d8:	f800283a 	ret

0001a0dc <alt_read_query_entry_16bit>:
   1a0dc:	defffd04 	addi	sp,sp,-12
   1a0e0:	df000215 	stw	fp,8(sp)
   1a0e4:	df000204 	addi	fp,sp,8
   1a0e8:	e13ffe15 	stw	r4,-8(fp)
   1a0ec:	e17fff15 	stw	r5,-4(fp)
   1a0f0:	e0bffe17 	ldw	r2,-8(fp)
   1a0f4:	10c00a17 	ldw	r3,40(r2)
   1a0f8:	e0bfff17 	ldw	r2,-4(fp)
   1a0fc:	1085883a 	add	r2,r2,r2
   1a100:	1885883a 	add	r2,r3,r2
   1a104:	1080002b 	ldhuio	r2,0(r2)
   1a108:	10bfffcc 	andi	r2,r2,65535
   1a10c:	e037883a 	mov	sp,fp
   1a110:	df000017 	ldw	fp,0(sp)
   1a114:	dec00104 	addi	sp,sp,4
   1a118:	f800283a 	ret

0001a11c <alt_read_query_entry_32bit>:
   1a11c:	defffd04 	addi	sp,sp,-12
   1a120:	df000215 	stw	fp,8(sp)
   1a124:	df000204 	addi	fp,sp,8
   1a128:	e13ffe15 	stw	r4,-8(fp)
   1a12c:	e17fff15 	stw	r5,-4(fp)
   1a130:	e0bffe17 	ldw	r2,-8(fp)
   1a134:	10c00a17 	ldw	r3,40(r2)
   1a138:	e0bfff17 	ldw	r2,-4(fp)
   1a13c:	1085883a 	add	r2,r2,r2
   1a140:	1085883a 	add	r2,r2,r2
   1a144:	1885883a 	add	r2,r3,r2
   1a148:	10800037 	ldwio	r2,0(r2)
   1a14c:	e037883a 	mov	sp,fp
   1a150:	df000017 	ldw	fp,0(sp)
   1a154:	dec00104 	addi	sp,sp,4
   1a158:	f800283a 	ret

0001a15c <alt_write_flash_command_8bit_device_8bit_mode>:
   1a15c:	defffc04 	addi	sp,sp,-16
   1a160:	df000315 	stw	fp,12(sp)
   1a164:	df000304 	addi	fp,sp,12
   1a168:	e13ffd15 	stw	r4,-12(fp)
   1a16c:	e17ffe15 	stw	r5,-8(fp)
   1a170:	3005883a 	mov	r2,r6
   1a174:	e0bfff05 	stb	r2,-4(fp)
   1a178:	e0bffe17 	ldw	r2,-8(fp)
   1a17c:	e0fffd17 	ldw	r3,-12(fp)
   1a180:	1885883a 	add	r2,r3,r2
   1a184:	e0ffff03 	ldbu	r3,-4(fp)
   1a188:	10c00025 	stbio	r3,0(r2)
   1a18c:	0001883a 	nop
   1a190:	e037883a 	mov	sp,fp
   1a194:	df000017 	ldw	fp,0(sp)
   1a198:	dec00104 	addi	sp,sp,4
   1a19c:	f800283a 	ret

0001a1a0 <alt_write_flash_command_16bit_device_8bit_mode>:
   1a1a0:	defffc04 	addi	sp,sp,-16
   1a1a4:	df000315 	stw	fp,12(sp)
   1a1a8:	df000304 	addi	fp,sp,12
   1a1ac:	e13ffd15 	stw	r4,-12(fp)
   1a1b0:	e17ffe15 	stw	r5,-8(fp)
   1a1b4:	3005883a 	mov	r2,r6
   1a1b8:	e0bfff05 	stb	r2,-4(fp)
   1a1bc:	e0bffe17 	ldw	r2,-8(fp)
   1a1c0:	1080004c 	andi	r2,r2,1
   1a1c4:	10000726 	beq	r2,zero,1a1e4 <alt_write_flash_command_16bit_device_8bit_mode+0x44>
   1a1c8:	e0bffe17 	ldw	r2,-8(fp)
   1a1cc:	1085883a 	add	r2,r2,r2
   1a1d0:	e0fffd17 	ldw	r3,-12(fp)
   1a1d4:	1885883a 	add	r2,r3,r2
   1a1d8:	e0ffff03 	ldbu	r3,-4(fp)
   1a1dc:	10c00025 	stbio	r3,0(r2)
   1a1e0:	00000706 	br	1a200 <alt_write_flash_command_16bit_device_8bit_mode+0x60>
   1a1e4:	e0bffe17 	ldw	r2,-8(fp)
   1a1e8:	1085883a 	add	r2,r2,r2
   1a1ec:	10800044 	addi	r2,r2,1
   1a1f0:	e0fffd17 	ldw	r3,-12(fp)
   1a1f4:	1885883a 	add	r2,r3,r2
   1a1f8:	e0ffff03 	ldbu	r3,-4(fp)
   1a1fc:	10c00025 	stbio	r3,0(r2)
   1a200:	0001883a 	nop
   1a204:	e037883a 	mov	sp,fp
   1a208:	df000017 	ldw	fp,0(sp)
   1a20c:	dec00104 	addi	sp,sp,4
   1a210:	f800283a 	ret

0001a214 <alt_write_flash_command_32bit_device_8bit_mode>:
   1a214:	defffc04 	addi	sp,sp,-16
   1a218:	df000315 	stw	fp,12(sp)
   1a21c:	df000304 	addi	fp,sp,12
   1a220:	e13ffd15 	stw	r4,-12(fp)
   1a224:	e17ffe15 	stw	r5,-8(fp)
   1a228:	3005883a 	mov	r2,r6
   1a22c:	e0bfff05 	stb	r2,-4(fp)
   1a230:	e0bffe17 	ldw	r2,-8(fp)
   1a234:	1085883a 	add	r2,r2,r2
   1a238:	1085883a 	add	r2,r2,r2
   1a23c:	e0fffd17 	ldw	r3,-12(fp)
   1a240:	1885883a 	add	r2,r3,r2
   1a244:	e0ffff03 	ldbu	r3,-4(fp)
   1a248:	10c00025 	stbio	r3,0(r2)
   1a24c:	0001883a 	nop
   1a250:	e037883a 	mov	sp,fp
   1a254:	df000017 	ldw	fp,0(sp)
   1a258:	dec00104 	addi	sp,sp,4
   1a25c:	f800283a 	ret

0001a260 <alt_write_flash_command_16bit_device_16bit_mode>:
   1a260:	defffc04 	addi	sp,sp,-16
   1a264:	df000315 	stw	fp,12(sp)
   1a268:	df000304 	addi	fp,sp,12
   1a26c:	e13ffd15 	stw	r4,-12(fp)
   1a270:	e17ffe15 	stw	r5,-8(fp)
   1a274:	3005883a 	mov	r2,r6
   1a278:	e0bfff05 	stb	r2,-4(fp)
   1a27c:	e0bffe17 	ldw	r2,-8(fp)
   1a280:	1085883a 	add	r2,r2,r2
   1a284:	e0fffd17 	ldw	r3,-12(fp)
   1a288:	1885883a 	add	r2,r3,r2
   1a28c:	e0ffff03 	ldbu	r3,-4(fp)
   1a290:	10c0002d 	sthio	r3,0(r2)
   1a294:	0001883a 	nop
   1a298:	e037883a 	mov	sp,fp
   1a29c:	df000017 	ldw	fp,0(sp)
   1a2a0:	dec00104 	addi	sp,sp,4
   1a2a4:	f800283a 	ret

0001a2a8 <alt_write_flash_command_32bit_device_16bit_mode>:
   1a2a8:	defffc04 	addi	sp,sp,-16
   1a2ac:	df000315 	stw	fp,12(sp)
   1a2b0:	df000304 	addi	fp,sp,12
   1a2b4:	e13ffd15 	stw	r4,-12(fp)
   1a2b8:	e17ffe15 	stw	r5,-8(fp)
   1a2bc:	3005883a 	mov	r2,r6
   1a2c0:	e0bfff05 	stb	r2,-4(fp)
   1a2c4:	e0bffe17 	ldw	r2,-8(fp)
   1a2c8:	1085883a 	add	r2,r2,r2
   1a2cc:	1085883a 	add	r2,r2,r2
   1a2d0:	e0fffd17 	ldw	r3,-12(fp)
   1a2d4:	1885883a 	add	r2,r3,r2
   1a2d8:	e0ffff03 	ldbu	r3,-4(fp)
   1a2dc:	10c0002d 	sthio	r3,0(r2)
   1a2e0:	0001883a 	nop
   1a2e4:	e037883a 	mov	sp,fp
   1a2e8:	df000017 	ldw	fp,0(sp)
   1a2ec:	dec00104 	addi	sp,sp,4
   1a2f0:	f800283a 	ret

0001a2f4 <alt_write_flash_command_32bit_device_32bit_mode>:
   1a2f4:	defffc04 	addi	sp,sp,-16
   1a2f8:	df000315 	stw	fp,12(sp)
   1a2fc:	df000304 	addi	fp,sp,12
   1a300:	e13ffd15 	stw	r4,-12(fp)
   1a304:	e17ffe15 	stw	r5,-8(fp)
   1a308:	3005883a 	mov	r2,r6
   1a30c:	e0bfff05 	stb	r2,-4(fp)
   1a310:	e0bffe17 	ldw	r2,-8(fp)
   1a314:	1085883a 	add	r2,r2,r2
   1a318:	1085883a 	add	r2,r2,r2
   1a31c:	e0fffd17 	ldw	r3,-12(fp)
   1a320:	1885883a 	add	r2,r3,r2
   1a324:	e0ffff03 	ldbu	r3,-4(fp)
   1a328:	10c00035 	stwio	r3,0(r2)
   1a32c:	0001883a 	nop
   1a330:	e037883a 	mov	sp,fp
   1a334:	df000017 	ldw	fp,0(sp)
   1a338:	dec00104 	addi	sp,sp,4
   1a33c:	f800283a 	ret

0001a340 <alt_write_native_8bit>:
   1a340:	defffd04 	addi	sp,sp,-12
   1a344:	df000215 	stw	fp,8(sp)
   1a348:	df000204 	addi	fp,sp,8
   1a34c:	e13ffe15 	stw	r4,-8(fp)
   1a350:	e17fff15 	stw	r5,-4(fp)
   1a354:	e0bfff17 	ldw	r2,-4(fp)
   1a358:	10c03fcc 	andi	r3,r2,255
   1a35c:	e0bffe17 	ldw	r2,-8(fp)
   1a360:	10c00025 	stbio	r3,0(r2)
   1a364:	0001883a 	nop
   1a368:	e037883a 	mov	sp,fp
   1a36c:	df000017 	ldw	fp,0(sp)
   1a370:	dec00104 	addi	sp,sp,4
   1a374:	f800283a 	ret

0001a378 <alt_write_native_16bit>:
   1a378:	defffd04 	addi	sp,sp,-12
   1a37c:	df000215 	stw	fp,8(sp)
   1a380:	df000204 	addi	fp,sp,8
   1a384:	e13ffe15 	stw	r4,-8(fp)
   1a388:	e17fff15 	stw	r5,-4(fp)
   1a38c:	e0bfff17 	ldw	r2,-4(fp)
   1a390:	10ffffcc 	andi	r3,r2,65535
   1a394:	e0bffe17 	ldw	r2,-8(fp)
   1a398:	10c0002d 	sthio	r3,0(r2)
   1a39c:	0001883a 	nop
   1a3a0:	e037883a 	mov	sp,fp
   1a3a4:	df000017 	ldw	fp,0(sp)
   1a3a8:	dec00104 	addi	sp,sp,4
   1a3ac:	f800283a 	ret

0001a3b0 <alt_write_native_32bit>:
   1a3b0:	defffd04 	addi	sp,sp,-12
   1a3b4:	df000215 	stw	fp,8(sp)
   1a3b8:	df000204 	addi	fp,sp,8
   1a3bc:	e13ffe15 	stw	r4,-8(fp)
   1a3c0:	e17fff15 	stw	r5,-4(fp)
   1a3c4:	e0ffff17 	ldw	r3,-4(fp)
   1a3c8:	e0bffe17 	ldw	r2,-8(fp)
   1a3cc:	10c00035 	stwio	r3,0(r2)
   1a3d0:	0001883a 	nop
   1a3d4:	e037883a 	mov	sp,fp
   1a3d8:	df000017 	ldw	fp,0(sp)
   1a3dc:	dec00104 	addi	sp,sp,4
   1a3e0:	f800283a 	ret

0001a3e4 <alt_set_flash_width_func>:
   1a3e4:	defffd04 	addi	sp,sp,-12
   1a3e8:	df000215 	stw	fp,8(sp)
   1a3ec:	df000204 	addi	fp,sp,8
   1a3f0:	e13fff15 	stw	r4,-4(fp)
   1a3f4:	e03ffe15 	stw	zero,-8(fp)
   1a3f8:	e0bfff17 	ldw	r2,-4(fp)
   1a3fc:	10802e17 	ldw	r2,184(r2)
   1a400:	10c000a0 	cmpeqi	r3,r2,2
   1a404:	1800231e 	bne	r3,zero,1a494 <alt_set_flash_width_func+0xb0>
   1a408:	10c00120 	cmpeqi	r3,r2,4
   1a40c:	1800371e 	bne	r3,zero,1a4ec <alt_set_flash_width_func+0x108>
   1a410:	10800060 	cmpeqi	r2,r2,1
   1a414:	10003e26 	beq	r2,zero,1a510 <alt_set_flash_width_func+0x12c>
   1a418:	e0bfff17 	ldw	r2,-4(fp)
   1a41c:	00c000b4 	movhi	r3,2
   1a420:	18e8d004 	addi	r3,r3,-23744
   1a424:	10c03515 	stw	r3,212(r2)
   1a428:	e0bfff17 	ldw	r2,-4(fp)
   1a42c:	10802f17 	ldw	r2,188(r2)
   1a430:	10800058 	cmpnei	r2,r2,1
   1a434:	1000051e 	bne	r2,zero,1a44c <alt_set_flash_width_func+0x68>
   1a438:	e0bfff17 	ldw	r2,-4(fp)
   1a43c:	00c000b4 	movhi	r3,2
   1a440:	18e85704 	addi	r3,r3,-24228
   1a444:	10c03315 	stw	r3,204(r2)
   1a448:	00003406 	br	1a51c <alt_set_flash_width_func+0x138>
   1a44c:	e0bfff17 	ldw	r2,-4(fp)
   1a450:	10802f17 	ldw	r2,188(r2)
   1a454:	10800098 	cmpnei	r2,r2,2
   1a458:	1000051e 	bne	r2,zero,1a470 <alt_set_flash_width_func+0x8c>
   1a45c:	e0bfff17 	ldw	r2,-4(fp)
   1a460:	00c000b4 	movhi	r3,2
   1a464:	18e86804 	addi	r3,r3,-24160
   1a468:	10c03315 	stw	r3,204(r2)
   1a46c:	00002b06 	br	1a51c <alt_set_flash_width_func+0x138>
   1a470:	e0bfff17 	ldw	r2,-4(fp)
   1a474:	10802f17 	ldw	r2,188(r2)
   1a478:	10800118 	cmpnei	r2,r2,4
   1a47c:	1000271e 	bne	r2,zero,1a51c <alt_set_flash_width_func+0x138>
   1a480:	e0bfff17 	ldw	r2,-4(fp)
   1a484:	00c000b4 	movhi	r3,2
   1a488:	18e88504 	addi	r3,r3,-24044
   1a48c:	10c03315 	stw	r3,204(r2)
   1a490:	00002206 	br	1a51c <alt_set_flash_width_func+0x138>
   1a494:	e0bfff17 	ldw	r2,-4(fp)
   1a498:	00c000b4 	movhi	r3,2
   1a49c:	18e8de04 	addi	r3,r3,-23688
   1a4a0:	10c03515 	stw	r3,212(r2)
   1a4a4:	e0bfff17 	ldw	r2,-4(fp)
   1a4a8:	10802f17 	ldw	r2,188(r2)
   1a4ac:	10800098 	cmpnei	r2,r2,2
   1a4b0:	1000051e 	bne	r2,zero,1a4c8 <alt_set_flash_width_func+0xe4>
   1a4b4:	e0bfff17 	ldw	r2,-4(fp)
   1a4b8:	00c000b4 	movhi	r3,2
   1a4bc:	18e89804 	addi	r3,r3,-23968
   1a4c0:	10c03315 	stw	r3,204(r2)
   1a4c4:	00001706 	br	1a524 <alt_set_flash_width_func+0x140>
   1a4c8:	e0bfff17 	ldw	r2,-4(fp)
   1a4cc:	10802f17 	ldw	r2,188(r2)
   1a4d0:	10800118 	cmpnei	r2,r2,4
   1a4d4:	1000131e 	bne	r2,zero,1a524 <alt_set_flash_width_func+0x140>
   1a4d8:	e0bfff17 	ldw	r2,-4(fp)
   1a4dc:	00c000b4 	movhi	r3,2
   1a4e0:	18e8aa04 	addi	r3,r3,-23896
   1a4e4:	10c03315 	stw	r3,204(r2)
   1a4e8:	00000e06 	br	1a524 <alt_set_flash_width_func+0x140>
   1a4ec:	e0bfff17 	ldw	r2,-4(fp)
   1a4f0:	00c000b4 	movhi	r3,2
   1a4f4:	18e8ec04 	addi	r3,r3,-23632
   1a4f8:	10c03515 	stw	r3,212(r2)
   1a4fc:	e0bfff17 	ldw	r2,-4(fp)
   1a500:	00c000b4 	movhi	r3,2
   1a504:	18e8bd04 	addi	r3,r3,-23820
   1a508:	10c03315 	stw	r3,204(r2)
   1a50c:	00000606 	br	1a528 <alt_set_flash_width_func+0x144>
   1a510:	00bffcc4 	movi	r2,-13
   1a514:	e0bffe15 	stw	r2,-8(fp)
   1a518:	00000306 	br	1a528 <alt_set_flash_width_func+0x144>
   1a51c:	0001883a 	nop
   1a520:	00000106 	br	1a528 <alt_set_flash_width_func+0x144>
   1a524:	0001883a 	nop
   1a528:	e0bffe17 	ldw	r2,-8(fp)
   1a52c:	1000191e 	bne	r2,zero,1a594 <alt_set_flash_width_func+0x1b0>
   1a530:	e0bfff17 	ldw	r2,-4(fp)
   1a534:	10802f17 	ldw	r2,188(r2)
   1a538:	10c000a0 	cmpeqi	r3,r2,2
   1a53c:	1800091e 	bne	r3,zero,1a564 <alt_set_flash_width_func+0x180>
   1a540:	10c00120 	cmpeqi	r3,r2,4
   1a544:	18000c1e 	bne	r3,zero,1a578 <alt_set_flash_width_func+0x194>
   1a548:	10800060 	cmpeqi	r2,r2,1
   1a54c:	10000f26 	beq	r2,zero,1a58c <alt_set_flash_width_func+0x1a8>
   1a550:	e0bfff17 	ldw	r2,-4(fp)
   1a554:	00c000b4 	movhi	r3,2
   1a558:	18e82804 	addi	r3,r3,-24416
   1a55c:	10c03415 	stw	r3,208(r2)
   1a560:	00000c06 	br	1a594 <alt_set_flash_width_func+0x1b0>
   1a564:	e0bfff17 	ldw	r2,-4(fp)
   1a568:	00c000b4 	movhi	r3,2
   1a56c:	18e83704 	addi	r3,r3,-24356
   1a570:	10c03415 	stw	r3,208(r2)
   1a574:	00000706 	br	1a594 <alt_set_flash_width_func+0x1b0>
   1a578:	e0bfff17 	ldw	r2,-4(fp)
   1a57c:	00c000b4 	movhi	r3,2
   1a580:	18e84704 	addi	r3,r3,-24292
   1a584:	10c03415 	stw	r3,208(r2)
   1a588:	00000206 	br	1a594 <alt_set_flash_width_func+0x1b0>
   1a58c:	00bffcc4 	movi	r2,-13
   1a590:	e0bffe15 	stw	r2,-8(fp)
   1a594:	e0bffe17 	ldw	r2,-8(fp)
   1a598:	e037883a 	mov	sp,fp
   1a59c:	df000017 	ldw	fp,0(sp)
   1a5a0:	dec00104 	addi	sp,sp,4
   1a5a4:	f800283a 	ret

0001a5a8 <alt_set_flash_algorithm_func>:
   1a5a8:	defffd04 	addi	sp,sp,-12
   1a5ac:	df000215 	stw	fp,8(sp)
   1a5b0:	df000204 	addi	fp,sp,8
   1a5b4:	e13fff15 	stw	r4,-4(fp)
   1a5b8:	e03ffe15 	stw	zero,-8(fp)
   1a5bc:	e0bfff17 	ldw	r2,-4(fp)
   1a5c0:	10802d17 	ldw	r2,180(r2)
   1a5c4:	10c000a0 	cmpeqi	r3,r2,2
   1a5c8:	1800051e 	bne	r3,zero,1a5e0 <alt_set_flash_algorithm_func+0x38>
   1a5cc:	10c000e0 	cmpeqi	r3,r2,3
   1a5d0:	18000c1e 	bne	r3,zero,1a604 <alt_set_flash_algorithm_func+0x5c>
   1a5d4:	10800060 	cmpeqi	r2,r2,1
   1a5d8:	10000a1e 	bne	r2,zero,1a604 <alt_set_flash_algorithm_func+0x5c>
   1a5dc:	00001206 	br	1a628 <alt_set_flash_algorithm_func+0x80>
   1a5e0:	e0bfff17 	ldw	r2,-4(fp)
   1a5e4:	00c000b4 	movhi	r3,2
   1a5e8:	18c9a504 	addi	r3,r3,9876
   1a5ec:	10c00815 	stw	r3,32(r2)
   1a5f0:	e0bfff17 	ldw	r2,-4(fp)
   1a5f4:	00c000b4 	movhi	r3,2
   1a5f8:	18c98b04 	addi	r3,r3,9772
   1a5fc:	10c00915 	stw	r3,36(r2)
   1a600:	00000b06 	br	1a630 <alt_set_flash_algorithm_func+0x88>
   1a604:	e0bfff17 	ldw	r2,-4(fp)
   1a608:	00c000b4 	movhi	r3,2
   1a60c:	18cac304 	addi	r3,r3,11020
   1a610:	10c00815 	stw	r3,32(r2)
   1a614:	e0bfff17 	ldw	r2,-4(fp)
   1a618:	00c000b4 	movhi	r3,2
   1a61c:	18caa304 	addi	r3,r3,10892
   1a620:	10c00915 	stw	r3,36(r2)
   1a624:	00000206 	br	1a630 <alt_set_flash_algorithm_func+0x88>
   1a628:	00bffec4 	movi	r2,-5
   1a62c:	e0bffe15 	stw	r2,-8(fp)
   1a630:	e0bffe17 	ldw	r2,-8(fp)
   1a634:	e037883a 	mov	sp,fp
   1a638:	df000017 	ldw	fp,0(sp)
   1a63c:	dec00104 	addi	sp,sp,4
   1a640:	f800283a 	ret

0001a644 <alt_read_16bit_query_entry>:
   1a644:	defffb04 	addi	sp,sp,-20
   1a648:	dfc00415 	stw	ra,16(sp)
   1a64c:	df000315 	stw	fp,12(sp)
   1a650:	df000304 	addi	fp,sp,12
   1a654:	e13ffe15 	stw	r4,-8(fp)
   1a658:	e17fff15 	stw	r5,-4(fp)
   1a65c:	e0bffe17 	ldw	r2,-8(fp)
   1a660:	10803417 	ldw	r2,208(r2)
   1a664:	e13ffe17 	ldw	r4,-8(fp)
   1a668:	e17fff17 	ldw	r5,-4(fp)
   1a66c:	103ee83a 	callr	r2
   1a670:	10803fcc 	andi	r2,r2,255
   1a674:	e0bffd0d 	sth	r2,-12(fp)
   1a678:	e0bffe17 	ldw	r2,-8(fp)
   1a67c:	10c03417 	ldw	r3,208(r2)
   1a680:	e0bfff17 	ldw	r2,-4(fp)
   1a684:	10800044 	addi	r2,r2,1
   1a688:	e13ffe17 	ldw	r4,-8(fp)
   1a68c:	100b883a 	mov	r5,r2
   1a690:	183ee83a 	callr	r3
   1a694:	10803fcc 	andi	r2,r2,255
   1a698:	1004923a 	slli	r2,r2,8
   1a69c:	1007883a 	mov	r3,r2
   1a6a0:	e0bffd0b 	ldhu	r2,-12(fp)
   1a6a4:	1884b03a 	or	r2,r3,r2
   1a6a8:	e0bffd0d 	sth	r2,-12(fp)
   1a6ac:	e0bffd0b 	ldhu	r2,-12(fp)
   1a6b0:	e037883a 	mov	sp,fp
   1a6b4:	dfc00117 	ldw	ra,4(sp)
   1a6b8:	df000017 	ldw	fp,0(sp)
   1a6bc:	dec00204 	addi	sp,sp,8
   1a6c0:	f800283a 	ret

0001a6c4 <alt_read_cfi_table>:
   1a6c4:	defff304 	addi	sp,sp,-52
   1a6c8:	dfc00c15 	stw	ra,48(sp)
   1a6cc:	df000b15 	stw	fp,44(sp)
   1a6d0:	df000b04 	addi	fp,sp,44
   1a6d4:	e13fff15 	stw	r4,-4(fp)
   1a6d8:	e03ff715 	stw	zero,-36(fp)
   1a6dc:	e03ff815 	stw	zero,-32(fp)
   1a6e0:	e03ff915 	stw	zero,-28(fp)
   1a6e4:	e13fff17 	ldw	r4,-4(fp)
   1a6e8:	001b3fc0 	call	1b3fc <alt_check_primary_table>
   1a6ec:	e0bff715 	stw	r2,-36(fp)
   1a6f0:	e0bff717 	ldw	r2,-36(fp)
   1a6f4:	10015f1e 	bne	r2,zero,1ac74 <alt_read_cfi_table+0x5b0>
   1a6f8:	e0bfff17 	ldw	r2,-4(fp)
   1a6fc:	10803417 	ldw	r2,208(r2)
   1a700:	e13fff17 	ldw	r4,-4(fp)
   1a704:	014004c4 	movi	r5,19
   1a708:	103ee83a 	callr	r2
   1a70c:	10c03fcc 	andi	r3,r2,255
   1a710:	e0bfff17 	ldw	r2,-4(fp)
   1a714:	10c02d15 	stw	r3,180(r2)
   1a718:	e0bfff17 	ldw	r2,-4(fp)
   1a71c:	10803417 	ldw	r2,208(r2)
   1a720:	e13fff17 	ldw	r4,-4(fp)
   1a724:	014007c4 	movi	r5,31
   1a728:	103ee83a 	callr	r2
   1a72c:	10803fcc 	andi	r2,r2,255
   1a730:	e0bffa15 	stw	r2,-24(fp)
   1a734:	e0bfff17 	ldw	r2,-4(fp)
   1a738:	10803417 	ldw	r2,208(r2)
   1a73c:	e13fff17 	ldw	r4,-4(fp)
   1a740:	014008c4 	movi	r5,35
   1a744:	103ee83a 	callr	r2
   1a748:	10803fcc 	andi	r2,r2,255
   1a74c:	e0bffb15 	stw	r2,-20(fp)
   1a750:	e0bffa17 	ldw	r2,-24(fp)
   1a754:	10000226 	beq	r2,zero,1a760 <alt_read_cfi_table+0x9c>
   1a758:	e0bffb17 	ldw	r2,-20(fp)
   1a75c:	1000041e 	bne	r2,zero,1a770 <alt_read_cfi_table+0xac>
   1a760:	e0bfff17 	ldw	r2,-4(fp)
   1a764:	00c0fa04 	movi	r3,1000
   1a768:	10c03015 	stw	r3,192(r2)
   1a76c:	00000706 	br	1a78c <alt_read_cfi_table+0xc8>
   1a770:	00c00044 	movi	r3,1
   1a774:	e0bffa17 	ldw	r2,-24(fp)
   1a778:	1886983a 	sll	r3,r3,r2
   1a77c:	e0bffb17 	ldw	r2,-20(fp)
   1a780:	1886983a 	sll	r3,r3,r2
   1a784:	e0bfff17 	ldw	r2,-4(fp)
   1a788:	10c03015 	stw	r3,192(r2)
   1a78c:	e0bfff17 	ldw	r2,-4(fp)
   1a790:	10803417 	ldw	r2,208(r2)
   1a794:	e13fff17 	ldw	r4,-4(fp)
   1a798:	01400844 	movi	r5,33
   1a79c:	103ee83a 	callr	r2
   1a7a0:	10803fcc 	andi	r2,r2,255
   1a7a4:	e0bffa15 	stw	r2,-24(fp)
   1a7a8:	e0bfff17 	ldw	r2,-4(fp)
   1a7ac:	10803417 	ldw	r2,208(r2)
   1a7b0:	e13fff17 	ldw	r4,-4(fp)
   1a7b4:	01400944 	movi	r5,37
   1a7b8:	103ee83a 	callr	r2
   1a7bc:	10803fcc 	andi	r2,r2,255
   1a7c0:	e0bffb15 	stw	r2,-20(fp)
   1a7c4:	e0bffa17 	ldw	r2,-24(fp)
   1a7c8:	10000226 	beq	r2,zero,1a7d4 <alt_read_cfi_table+0x110>
   1a7cc:	e0bffb17 	ldw	r2,-20(fp)
   1a7d0:	1000051e 	bne	r2,zero,1a7e8 <alt_read_cfi_table+0x124>
   1a7d4:	e0bfff17 	ldw	r2,-4(fp)
   1a7d8:	00c04c74 	movhi	r3,305
   1a7dc:	18cb4004 	addi	r3,r3,11520
   1a7e0:	10c03115 	stw	r3,196(r2)
   1a7e4:	00000806 	br	1a808 <alt_read_cfi_table+0x144>
   1a7e8:	00c00044 	movi	r3,1
   1a7ec:	e0bffa17 	ldw	r2,-24(fp)
   1a7f0:	1886983a 	sll	r3,r3,r2
   1a7f4:	e0bffb17 	ldw	r2,-20(fp)
   1a7f8:	1884983a 	sll	r2,r3,r2
   1a7fc:	10c0fa24 	muli	r3,r2,1000
   1a800:	e0bfff17 	ldw	r2,-4(fp)
   1a804:	10c03115 	stw	r3,196(r2)
   1a808:	e0bfff17 	ldw	r2,-4(fp)
   1a80c:	10803417 	ldw	r2,208(r2)
   1a810:	e13fff17 	ldw	r4,-4(fp)
   1a814:	014009c4 	movi	r5,39
   1a818:	103ee83a 	callr	r2
   1a81c:	10803fcc 	andi	r2,r2,255
   1a820:	00c00044 	movi	r3,1
   1a824:	1884983a 	sll	r2,r3,r2
   1a828:	e0bffc15 	stw	r2,-16(fp)
   1a82c:	e0bfff17 	ldw	r2,-4(fp)
   1a830:	10803417 	ldw	r2,208(r2)
   1a834:	e13fff17 	ldw	r4,-4(fp)
   1a838:	01400b04 	movi	r5,44
   1a83c:	103ee83a 	callr	r2
   1a840:	10c03fcc 	andi	r3,r2,255
   1a844:	e0bfff17 	ldw	r2,-4(fp)
   1a848:	10c00c15 	stw	r3,48(r2)
   1a84c:	e0bfff17 	ldw	r2,-4(fp)
   1a850:	10800c17 	ldw	r2,48(r2)
   1a854:	10800250 	cmplti	r2,r2,9
   1a858:	1000031e 	bne	r2,zero,1a868 <alt_read_cfi_table+0x1a4>
   1a85c:	00bffd04 	movi	r2,-12
   1a860:	e0bff715 	stw	r2,-36(fp)
   1a864:	00006006 	br	1a9e8 <alt_read_cfi_table+0x324>
   1a868:	e03ff515 	stw	zero,-44(fp)
   1a86c:	00005506 	br	1a9c4 <alt_read_cfi_table+0x300>
   1a870:	e0bff517 	ldw	r2,-44(fp)
   1a874:	1085883a 	add	r2,r2,r2
   1a878:	1085883a 	add	r2,r2,r2
   1a87c:	10800b44 	addi	r2,r2,45
   1a880:	e13fff17 	ldw	r4,-4(fp)
   1a884:	100b883a 	mov	r5,r2
   1a888:	001a6440 	call	1a644 <alt_read_16bit_query_entry>
   1a88c:	10ffffcc 	andi	r3,r2,65535
   1a890:	e13fff17 	ldw	r4,-4(fp)
   1a894:	e0bff517 	ldw	r2,-44(fp)
   1a898:	1004913a 	slli	r2,r2,4
   1a89c:	2085883a 	add	r2,r4,r2
   1a8a0:	10800f04 	addi	r2,r2,60
   1a8a4:	10c00015 	stw	r3,0(r2)
   1a8a8:	e0ffff17 	ldw	r3,-4(fp)
   1a8ac:	e0bff517 	ldw	r2,-44(fp)
   1a8b0:	1004913a 	slli	r2,r2,4
   1a8b4:	1885883a 	add	r2,r3,r2
   1a8b8:	10800f04 	addi	r2,r2,60
   1a8bc:	10800017 	ldw	r2,0(r2)
   1a8c0:	10c00044 	addi	r3,r2,1
   1a8c4:	e13fff17 	ldw	r4,-4(fp)
   1a8c8:	e0bff517 	ldw	r2,-44(fp)
   1a8cc:	1004913a 	slli	r2,r2,4
   1a8d0:	2085883a 	add	r2,r4,r2
   1a8d4:	10800f04 	addi	r2,r2,60
   1a8d8:	10c00015 	stw	r3,0(r2)
   1a8dc:	e0bff517 	ldw	r2,-44(fp)
   1a8e0:	1085883a 	add	r2,r2,r2
   1a8e4:	1085883a 	add	r2,r2,r2
   1a8e8:	10800bc4 	addi	r2,r2,47
   1a8ec:	e13fff17 	ldw	r4,-4(fp)
   1a8f0:	100b883a 	mov	r5,r2
   1a8f4:	001a6440 	call	1a644 <alt_read_16bit_query_entry>
   1a8f8:	10ffffcc 	andi	r3,r2,65535
   1a8fc:	e13fff17 	ldw	r4,-4(fp)
   1a900:	e0bff517 	ldw	r2,-44(fp)
   1a904:	10800104 	addi	r2,r2,4
   1a908:	1004913a 	slli	r2,r2,4
   1a90c:	2085883a 	add	r2,r4,r2
   1a910:	10c00015 	stw	r3,0(r2)
   1a914:	e0ffff17 	ldw	r3,-4(fp)
   1a918:	e0bff517 	ldw	r2,-44(fp)
   1a91c:	10800104 	addi	r2,r2,4
   1a920:	1004913a 	slli	r2,r2,4
   1a924:	1885883a 	add	r2,r3,r2
   1a928:	10800017 	ldw	r2,0(r2)
   1a92c:	1006923a 	slli	r3,r2,8
   1a930:	e13fff17 	ldw	r4,-4(fp)
   1a934:	e0bff517 	ldw	r2,-44(fp)
   1a938:	10800104 	addi	r2,r2,4
   1a93c:	1004913a 	slli	r2,r2,4
   1a940:	2085883a 	add	r2,r4,r2
   1a944:	10c00015 	stw	r3,0(r2)
   1a948:	e0ffff17 	ldw	r3,-4(fp)
   1a94c:	e0bff517 	ldw	r2,-44(fp)
   1a950:	1004913a 	slli	r2,r2,4
   1a954:	1885883a 	add	r2,r3,r2
   1a958:	10800f04 	addi	r2,r2,60
   1a95c:	10c00017 	ldw	r3,0(r2)
   1a960:	e13fff17 	ldw	r4,-4(fp)
   1a964:	e0bff517 	ldw	r2,-44(fp)
   1a968:	10800104 	addi	r2,r2,4
   1a96c:	1004913a 	slli	r2,r2,4
   1a970:	2085883a 	add	r2,r4,r2
   1a974:	10800017 	ldw	r2,0(r2)
   1a978:	1887383a 	mul	r3,r3,r2
   1a97c:	e13fff17 	ldw	r4,-4(fp)
   1a980:	e0bff517 	ldw	r2,-44(fp)
   1a984:	1004913a 	slli	r2,r2,4
   1a988:	2085883a 	add	r2,r4,r2
   1a98c:	10800e04 	addi	r2,r2,56
   1a990:	10c00015 	stw	r3,0(r2)
   1a994:	e0ffff17 	ldw	r3,-4(fp)
   1a998:	e0bff517 	ldw	r2,-44(fp)
   1a99c:	1004913a 	slli	r2,r2,4
   1a9a0:	1885883a 	add	r2,r3,r2
   1a9a4:	10800e04 	addi	r2,r2,56
   1a9a8:	10800017 	ldw	r2,0(r2)
   1a9ac:	e0fff817 	ldw	r3,-32(fp)
   1a9b0:	1885883a 	add	r2,r3,r2
   1a9b4:	e0bff815 	stw	r2,-32(fp)
   1a9b8:	e0bff517 	ldw	r2,-44(fp)
   1a9bc:	10800044 	addi	r2,r2,1
   1a9c0:	e0bff515 	stw	r2,-44(fp)
   1a9c4:	e0bfff17 	ldw	r2,-4(fp)
   1a9c8:	10800c17 	ldw	r2,48(r2)
   1a9cc:	e0fff517 	ldw	r3,-44(fp)
   1a9d0:	18bfa716 	blt	r3,r2,1a870 <alt_read_cfi_table+0x1ac>
   1a9d4:	e0fff817 	ldw	r3,-32(fp)
   1a9d8:	e0bffc17 	ldw	r2,-16(fp)
   1a9dc:	18800226 	beq	r3,r2,1a9e8 <alt_read_cfi_table+0x324>
   1a9e0:	00bffb44 	movi	r2,-19
   1a9e4:	e0bff715 	stw	r2,-36(fp)
   1a9e8:	e0bfff17 	ldw	r2,-4(fp)
   1a9ec:	10c03417 	ldw	r3,208(r2)
   1a9f0:	e0bfff17 	ldw	r2,-4(fp)
   1a9f4:	10803217 	ldw	r2,200(r2)
   1a9f8:	108003c4 	addi	r2,r2,15
   1a9fc:	e13fff17 	ldw	r4,-4(fp)
   1aa00:	100b883a 	mov	r5,r2
   1aa04:	183ee83a 	callr	r3
   1aa08:	e0bffd05 	stb	r2,-12(fp)
   1aa0c:	e0bfff17 	ldw	r2,-4(fp)
   1aa10:	10802d17 	ldw	r2,180(r2)
   1aa14:	10800098 	cmpnei	r2,r2,2
   1aa18:	1000601e 	bne	r2,zero,1ab9c <alt_read_cfi_table+0x4d8>
   1aa1c:	e0bffd03 	ldbu	r2,-12(fp)
   1aa20:	108000d8 	cmpnei	r2,r2,3
   1aa24:	10005d1e 	bne	r2,zero,1ab9c <alt_read_cfi_table+0x4d8>
   1aa28:	e0bfff17 	ldw	r2,-4(fp)
   1aa2c:	10800c17 	ldw	r2,48(r2)
   1aa30:	10bfffc4 	addi	r2,r2,-1
   1aa34:	e0bff515 	stw	r2,-44(fp)
   1aa38:	e03ff615 	stw	zero,-40(fp)
   1aa3c:	00005406 	br	1ab90 <alt_read_cfi_table+0x4cc>
   1aa40:	e0ffff17 	ldw	r3,-4(fp)
   1aa44:	e0bff517 	ldw	r2,-44(fp)
   1aa48:	1004913a 	slli	r2,r2,4
   1aa4c:	1885883a 	add	r2,r3,r2
   1aa50:	10800e04 	addi	r2,r2,56
   1aa54:	10800017 	ldw	r2,0(r2)
   1aa58:	e0bffe15 	stw	r2,-8(fp)
   1aa5c:	e0ffff17 	ldw	r3,-4(fp)
   1aa60:	e0bff617 	ldw	r2,-40(fp)
   1aa64:	1004913a 	slli	r2,r2,4
   1aa68:	1885883a 	add	r2,r3,r2
   1aa6c:	10800e04 	addi	r2,r2,56
   1aa70:	10c00017 	ldw	r3,0(r2)
   1aa74:	e13fff17 	ldw	r4,-4(fp)
   1aa78:	e0bff517 	ldw	r2,-44(fp)
   1aa7c:	1004913a 	slli	r2,r2,4
   1aa80:	2085883a 	add	r2,r4,r2
   1aa84:	10800e04 	addi	r2,r2,56
   1aa88:	10c00015 	stw	r3,0(r2)
   1aa8c:	e0ffff17 	ldw	r3,-4(fp)
   1aa90:	e0bff617 	ldw	r2,-40(fp)
   1aa94:	1004913a 	slli	r2,r2,4
   1aa98:	1885883a 	add	r2,r3,r2
   1aa9c:	10800e04 	addi	r2,r2,56
   1aaa0:	e0fffe17 	ldw	r3,-8(fp)
   1aaa4:	10c00015 	stw	r3,0(r2)
   1aaa8:	e0ffff17 	ldw	r3,-4(fp)
   1aaac:	e0bff517 	ldw	r2,-44(fp)
   1aab0:	10800104 	addi	r2,r2,4
   1aab4:	1004913a 	slli	r2,r2,4
   1aab8:	1885883a 	add	r2,r3,r2
   1aabc:	10800017 	ldw	r2,0(r2)
   1aac0:	e0bffe15 	stw	r2,-8(fp)
   1aac4:	e0ffff17 	ldw	r3,-4(fp)
   1aac8:	e0bff617 	ldw	r2,-40(fp)
   1aacc:	10800104 	addi	r2,r2,4
   1aad0:	1004913a 	slli	r2,r2,4
   1aad4:	1885883a 	add	r2,r3,r2
   1aad8:	10c00017 	ldw	r3,0(r2)
   1aadc:	e13fff17 	ldw	r4,-4(fp)
   1aae0:	e0bff517 	ldw	r2,-44(fp)
   1aae4:	10800104 	addi	r2,r2,4
   1aae8:	1004913a 	slli	r2,r2,4
   1aaec:	2085883a 	add	r2,r4,r2
   1aaf0:	10c00015 	stw	r3,0(r2)
   1aaf4:	e0ffff17 	ldw	r3,-4(fp)
   1aaf8:	e0bff617 	ldw	r2,-40(fp)
   1aafc:	10800104 	addi	r2,r2,4
   1ab00:	1004913a 	slli	r2,r2,4
   1ab04:	1885883a 	add	r2,r3,r2
   1ab08:	e0fffe17 	ldw	r3,-8(fp)
   1ab0c:	10c00015 	stw	r3,0(r2)
   1ab10:	e0ffff17 	ldw	r3,-4(fp)
   1ab14:	e0bff517 	ldw	r2,-44(fp)
   1ab18:	1004913a 	slli	r2,r2,4
   1ab1c:	1885883a 	add	r2,r3,r2
   1ab20:	10800f04 	addi	r2,r2,60
   1ab24:	10800017 	ldw	r2,0(r2)
   1ab28:	e0bffe15 	stw	r2,-8(fp)
   1ab2c:	e0ffff17 	ldw	r3,-4(fp)
   1ab30:	e0bff617 	ldw	r2,-40(fp)
   1ab34:	1004913a 	slli	r2,r2,4
   1ab38:	1885883a 	add	r2,r3,r2
   1ab3c:	10800f04 	addi	r2,r2,60
   1ab40:	10c00017 	ldw	r3,0(r2)
   1ab44:	e13fff17 	ldw	r4,-4(fp)
   1ab48:	e0bff517 	ldw	r2,-44(fp)
   1ab4c:	1004913a 	slli	r2,r2,4
   1ab50:	2085883a 	add	r2,r4,r2
   1ab54:	10800f04 	addi	r2,r2,60
   1ab58:	10c00015 	stw	r3,0(r2)
   1ab5c:	e0ffff17 	ldw	r3,-4(fp)
   1ab60:	e0bff617 	ldw	r2,-40(fp)
   1ab64:	1004913a 	slli	r2,r2,4
   1ab68:	1885883a 	add	r2,r3,r2
   1ab6c:	10800f04 	addi	r2,r2,60
   1ab70:	e0fffe17 	ldw	r3,-8(fp)
   1ab74:	10c00015 	stw	r3,0(r2)
   1ab78:	e0bff517 	ldw	r2,-44(fp)
   1ab7c:	10bfffc4 	addi	r2,r2,-1
   1ab80:	e0bff515 	stw	r2,-44(fp)
   1ab84:	e0bff617 	ldw	r2,-40(fp)
   1ab88:	10800044 	addi	r2,r2,1
   1ab8c:	e0bff615 	stw	r2,-40(fp)
   1ab90:	e0bff617 	ldw	r2,-40(fp)
   1ab94:	e0fff517 	ldw	r3,-44(fp)
   1ab98:	18bfa90e 	bge	r3,r2,1aa40 <alt_read_cfi_table+0x37c>
   1ab9c:	e03ff515 	stw	zero,-44(fp)
   1aba0:	00001306 	br	1abf0 <alt_read_cfi_table+0x52c>
   1aba4:	e0ffff17 	ldw	r3,-4(fp)
   1aba8:	e0bff517 	ldw	r2,-44(fp)
   1abac:	1004913a 	slli	r2,r2,4
   1abb0:	1885883a 	add	r2,r3,r2
   1abb4:	10800d04 	addi	r2,r2,52
   1abb8:	e0fff917 	ldw	r3,-28(fp)
   1abbc:	10c00015 	stw	r3,0(r2)
   1abc0:	e0ffff17 	ldw	r3,-4(fp)
   1abc4:	e0bff517 	ldw	r2,-44(fp)
   1abc8:	1004913a 	slli	r2,r2,4
   1abcc:	1885883a 	add	r2,r3,r2
   1abd0:	10800e04 	addi	r2,r2,56
   1abd4:	10800017 	ldw	r2,0(r2)
   1abd8:	e0fff917 	ldw	r3,-28(fp)
   1abdc:	1885883a 	add	r2,r3,r2
   1abe0:	e0bff915 	stw	r2,-28(fp)
   1abe4:	e0bff517 	ldw	r2,-44(fp)
   1abe8:	10800044 	addi	r2,r2,1
   1abec:	e0bff515 	stw	r2,-44(fp)
   1abf0:	e0bfff17 	ldw	r2,-4(fp)
   1abf4:	10800c17 	ldw	r2,48(r2)
   1abf8:	e0fff517 	ldw	r3,-44(fp)
   1abfc:	18bfe916 	blt	r3,r2,1aba4 <alt_read_cfi_table+0x4e0>
   1ac00:	e0bfff17 	ldw	r2,-4(fp)
   1ac04:	10802d17 	ldw	r2,180(r2)
   1ac08:	10c000a0 	cmpeqi	r3,r2,2
   1ac0c:	1800051e 	bne	r3,zero,1ac24 <alt_read_cfi_table+0x560>
   1ac10:	10c000e0 	cmpeqi	r3,r2,3
   1ac14:	18000c1e 	bne	r3,zero,1ac48 <alt_read_cfi_table+0x584>
   1ac18:	10800060 	cmpeqi	r2,r2,1
   1ac1c:	10000a1e 	bne	r2,zero,1ac48 <alt_read_cfi_table+0x584>
   1ac20:	00001206 	br	1ac6c <alt_read_cfi_table+0x5a8>
   1ac24:	e0bfff17 	ldw	r2,-4(fp)
   1ac28:	10c03317 	ldw	r3,204(r2)
   1ac2c:	e0bfff17 	ldw	r2,-4(fp)
   1ac30:	10800a17 	ldw	r2,40(r2)
   1ac34:	1009883a 	mov	r4,r2
   1ac38:	01401544 	movi	r5,85
   1ac3c:	01803c04 	movi	r6,240
   1ac40:	183ee83a 	callr	r3
   1ac44:	00000b06 	br	1ac74 <alt_read_cfi_table+0x5b0>
   1ac48:	e0bfff17 	ldw	r2,-4(fp)
   1ac4c:	10c03317 	ldw	r3,204(r2)
   1ac50:	e0bfff17 	ldw	r2,-4(fp)
   1ac54:	10800a17 	ldw	r2,40(r2)
   1ac58:	1009883a 	mov	r4,r2
   1ac5c:	01401544 	movi	r5,85
   1ac60:	01803fc4 	movi	r6,255
   1ac64:	183ee83a 	callr	r3
   1ac68:	00000206 	br	1ac74 <alt_read_cfi_table+0x5b0>
   1ac6c:	00bffec4 	movi	r2,-5
   1ac70:	e0bff715 	stw	r2,-36(fp)
   1ac74:	e0bff717 	ldw	r2,-36(fp)
   1ac78:	e037883a 	mov	sp,fp
   1ac7c:	dfc00117 	ldw	ra,4(sp)
   1ac80:	df000017 	ldw	fp,0(sp)
   1ac84:	dec00204 	addi	sp,sp,8
   1ac88:	f800283a 	ret

0001ac8c <alt_read_cfi_width>:
   1ac8c:	defff704 	addi	sp,sp,-36
   1ac90:	dfc00815 	stw	ra,32(sp)
   1ac94:	df000715 	stw	fp,28(sp)
   1ac98:	df000704 	addi	fp,sp,28
   1ac9c:	e13fff15 	stw	r4,-4(fp)
   1aca0:	e03ffa15 	stw	zero,-24(fp)
   1aca4:	e0bfff17 	ldw	r2,-4(fp)
   1aca8:	10800a17 	ldw	r2,40(r2)
   1acac:	1009883a 	mov	r4,r2
   1acb0:	01401544 	movi	r5,85
   1acb4:	01802604 	movi	r6,152
   1acb8:	001a15c0 	call	1a15c <alt_write_flash_command_8bit_device_8bit_mode>
   1acbc:	e03ff915 	stw	zero,-28(fp)
   1acc0:	00000f06 	br	1ad00 <alt_read_cfi_width+0x74>
   1acc4:	e0bfff17 	ldw	r2,-4(fp)
   1acc8:	10c00a17 	ldw	r3,40(r2)
   1accc:	e0bff917 	ldw	r2,-28(fp)
   1acd0:	10800404 	addi	r2,r2,16
   1acd4:	1885883a 	add	r2,r3,r2
   1acd8:	10800023 	ldbuio	r2,0(r2)
   1acdc:	10803fcc 	andi	r2,r2,255
   1ace0:	1007883a 	mov	r3,r2
   1ace4:	e13ffb84 	addi	r4,fp,-18
   1ace8:	e0bff917 	ldw	r2,-28(fp)
   1acec:	2085883a 	add	r2,r4,r2
   1acf0:	10c00005 	stb	r3,0(r2)
   1acf4:	e0bff917 	ldw	r2,-28(fp)
   1acf8:	10800044 	addi	r2,r2,1
   1acfc:	e0bff915 	stw	r2,-28(fp)
   1ad00:	e0bff917 	ldw	r2,-28(fp)
   1ad04:	108000d0 	cmplti	r2,r2,3
   1ad08:	103fee1e 	bne	r2,zero,1acc4 <alt_read_cfi_width+0x38>
   1ad0c:	e0bffb83 	ldbu	r2,-18(fp)
   1ad10:	10803fcc 	andi	r2,r2,255
   1ad14:	10801458 	cmpnei	r2,r2,81
   1ad18:	10001d1e 	bne	r2,zero,1ad90 <alt_read_cfi_width+0x104>
   1ad1c:	e0bffbc3 	ldbu	r2,-17(fp)
   1ad20:	10803fcc 	andi	r2,r2,255
   1ad24:	10801498 	cmpnei	r2,r2,82
   1ad28:	1000191e 	bne	r2,zero,1ad90 <alt_read_cfi_width+0x104>
   1ad2c:	e0bffc03 	ldbu	r2,-16(fp)
   1ad30:	10803fcc 	andi	r2,r2,255
   1ad34:	10801658 	cmpnei	r2,r2,89
   1ad38:	1000151e 	bne	r2,zero,1ad90 <alt_read_cfi_width+0x104>
   1ad3c:	e0bfff17 	ldw	r2,-4(fp)
   1ad40:	00c00044 	movi	r3,1
   1ad44:	10c02e15 	stw	r3,184(r2)
   1ad48:	e0bfff17 	ldw	r2,-4(fp)
   1ad4c:	00c00044 	movi	r3,1
   1ad50:	10c02f15 	stw	r3,188(r2)
   1ad54:	e0bfff17 	ldw	r2,-4(fp)
   1ad58:	10800a17 	ldw	r2,40(r2)
   1ad5c:	10800a04 	addi	r2,r2,40
   1ad60:	1080002b 	ldhuio	r2,0(r2)
   1ad64:	10bfffcc 	andi	r2,r2,65535
   1ad68:	e0bffb0d 	sth	r2,-20(fp)
   1ad6c:	e0bffb0b 	ldhu	r2,-20(fp)
   1ad70:	10800044 	addi	r2,r2,1
   1ad74:	e0bffb0d 	sth	r2,-20(fp)
   1ad78:	e0bffb0b 	ldhu	r2,-20(fp)
   1ad7c:	1080004c 	andi	r2,r2,1
   1ad80:	1001981e 	bne	r2,zero,1b3e4 <alt_read_cfi_width+0x758>
   1ad84:	00bffb44 	movi	r2,-19
   1ad88:	e0bffa15 	stw	r2,-24(fp)
   1ad8c:	00019506 	br	1b3e4 <alt_read_cfi_width+0x758>
   1ad90:	e0bfff17 	ldw	r2,-4(fp)
   1ad94:	10800a17 	ldw	r2,40(r2)
   1ad98:	1009883a 	mov	r4,r2
   1ad9c:	01401544 	movi	r5,85
   1ada0:	01802604 	movi	r6,152
   1ada4:	001a1a00 	call	1a1a0 <alt_write_flash_command_16bit_device_8bit_mode>
   1ada8:	e03ff915 	stw	zero,-28(fp)
   1adac:	00000f06 	br	1adec <alt_read_cfi_width+0x160>
   1adb0:	e0bfff17 	ldw	r2,-4(fp)
   1adb4:	10c00a17 	ldw	r3,40(r2)
   1adb8:	e0bff917 	ldw	r2,-28(fp)
   1adbc:	10800804 	addi	r2,r2,32
   1adc0:	1885883a 	add	r2,r3,r2
   1adc4:	10800023 	ldbuio	r2,0(r2)
   1adc8:	10803fcc 	andi	r2,r2,255
   1adcc:	1007883a 	mov	r3,r2
   1add0:	e13ffb84 	addi	r4,fp,-18
   1add4:	e0bff917 	ldw	r2,-28(fp)
   1add8:	2085883a 	add	r2,r4,r2
   1addc:	10c00005 	stb	r3,0(r2)
   1ade0:	e0bff917 	ldw	r2,-28(fp)
   1ade4:	10800044 	addi	r2,r2,1
   1ade8:	e0bff915 	stw	r2,-28(fp)
   1adec:	e0bff917 	ldw	r2,-28(fp)
   1adf0:	10800190 	cmplti	r2,r2,6
   1adf4:	103fee1e 	bne	r2,zero,1adb0 <alt_read_cfi_width+0x124>
   1adf8:	e0bffb83 	ldbu	r2,-18(fp)
   1adfc:	10803fcc 	andi	r2,r2,255
   1ae00:	10801458 	cmpnei	r2,r2,81
   1ae04:	1000291e 	bne	r2,zero,1aeac <alt_read_cfi_width+0x220>
   1ae08:	e0bffbc3 	ldbu	r2,-17(fp)
   1ae0c:	10803fcc 	andi	r2,r2,255
   1ae10:	10801458 	cmpnei	r2,r2,81
   1ae14:	1000251e 	bne	r2,zero,1aeac <alt_read_cfi_width+0x220>
   1ae18:	e0bffc03 	ldbu	r2,-16(fp)
   1ae1c:	10803fcc 	andi	r2,r2,255
   1ae20:	10801498 	cmpnei	r2,r2,82
   1ae24:	1000211e 	bne	r2,zero,1aeac <alt_read_cfi_width+0x220>
   1ae28:	e0bffc43 	ldbu	r2,-15(fp)
   1ae2c:	10803fcc 	andi	r2,r2,255
   1ae30:	10801498 	cmpnei	r2,r2,82
   1ae34:	10001d1e 	bne	r2,zero,1aeac <alt_read_cfi_width+0x220>
   1ae38:	e0bffc83 	ldbu	r2,-14(fp)
   1ae3c:	10803fcc 	andi	r2,r2,255
   1ae40:	10801658 	cmpnei	r2,r2,89
   1ae44:	1000191e 	bne	r2,zero,1aeac <alt_read_cfi_width+0x220>
   1ae48:	e0bffcc3 	ldbu	r2,-13(fp)
   1ae4c:	10803fcc 	andi	r2,r2,255
   1ae50:	10801658 	cmpnei	r2,r2,89
   1ae54:	1000151e 	bne	r2,zero,1aeac <alt_read_cfi_width+0x220>
   1ae58:	e0bfff17 	ldw	r2,-4(fp)
   1ae5c:	00c00044 	movi	r3,1
   1ae60:	10c02e15 	stw	r3,184(r2)
   1ae64:	e0bfff17 	ldw	r2,-4(fp)
   1ae68:	00c00084 	movi	r3,2
   1ae6c:	10c02f15 	stw	r3,188(r2)
   1ae70:	e0bfff17 	ldw	r2,-4(fp)
   1ae74:	10800a17 	ldw	r2,40(r2)
   1ae78:	10801404 	addi	r2,r2,80
   1ae7c:	1080002b 	ldhuio	r2,0(r2)
   1ae80:	10bfffcc 	andi	r2,r2,65535
   1ae84:	e0bffb0d 	sth	r2,-20(fp)
   1ae88:	e0bffb0b 	ldhu	r2,-20(fp)
   1ae8c:	10800044 	addi	r2,r2,1
   1ae90:	e0bffb0d 	sth	r2,-20(fp)
   1ae94:	e0bffb0b 	ldhu	r2,-20(fp)
   1ae98:	1080004c 	andi	r2,r2,1
   1ae9c:	1001511e 	bne	r2,zero,1b3e4 <alt_read_cfi_width+0x758>
   1aea0:	00bffb44 	movi	r2,-19
   1aea4:	e0bffa15 	stw	r2,-24(fp)
   1aea8:	00014e06 	br	1b3e4 <alt_read_cfi_width+0x758>
   1aeac:	e0bfff17 	ldw	r2,-4(fp)
   1aeb0:	10800a17 	ldw	r2,40(r2)
   1aeb4:	1009883a 	mov	r4,r2
   1aeb8:	01401544 	movi	r5,85
   1aebc:	01802604 	movi	r6,152
   1aec0:	001a2600 	call	1a260 <alt_write_flash_command_16bit_device_16bit_mode>
   1aec4:	e03ff915 	stw	zero,-28(fp)
   1aec8:	00000f06 	br	1af08 <alt_read_cfi_width+0x27c>
   1aecc:	e0bfff17 	ldw	r2,-4(fp)
   1aed0:	10c00a17 	ldw	r3,40(r2)
   1aed4:	e0bff917 	ldw	r2,-28(fp)
   1aed8:	10800804 	addi	r2,r2,32
   1aedc:	1885883a 	add	r2,r3,r2
   1aee0:	10800023 	ldbuio	r2,0(r2)
   1aee4:	10803fcc 	andi	r2,r2,255
   1aee8:	1007883a 	mov	r3,r2
   1aeec:	e13ffb84 	addi	r4,fp,-18
   1aef0:	e0bff917 	ldw	r2,-28(fp)
   1aef4:	2085883a 	add	r2,r4,r2
   1aef8:	10c00005 	stb	r3,0(r2)
   1aefc:	e0bff917 	ldw	r2,-28(fp)
   1af00:	10800044 	addi	r2,r2,1
   1af04:	e0bff915 	stw	r2,-28(fp)
   1af08:	e0bff917 	ldw	r2,-28(fp)
   1af0c:	10800190 	cmplti	r2,r2,6
   1af10:	103fee1e 	bne	r2,zero,1aecc <alt_read_cfi_width+0x240>
   1af14:	e0bffb83 	ldbu	r2,-18(fp)
   1af18:	10803fcc 	andi	r2,r2,255
   1af1c:	10801458 	cmpnei	r2,r2,81
   1af20:	1000261e 	bne	r2,zero,1afbc <alt_read_cfi_width+0x330>
   1af24:	e0bffbc3 	ldbu	r2,-17(fp)
   1af28:	10803fcc 	andi	r2,r2,255
   1af2c:	1000231e 	bne	r2,zero,1afbc <alt_read_cfi_width+0x330>
   1af30:	e0bffc03 	ldbu	r2,-16(fp)
   1af34:	10803fcc 	andi	r2,r2,255
   1af38:	10801498 	cmpnei	r2,r2,82
   1af3c:	10001f1e 	bne	r2,zero,1afbc <alt_read_cfi_width+0x330>
   1af40:	e0bffc43 	ldbu	r2,-15(fp)
   1af44:	10803fcc 	andi	r2,r2,255
   1af48:	10001c1e 	bne	r2,zero,1afbc <alt_read_cfi_width+0x330>
   1af4c:	e0bffc83 	ldbu	r2,-14(fp)
   1af50:	10803fcc 	andi	r2,r2,255
   1af54:	10801658 	cmpnei	r2,r2,89
   1af58:	1000181e 	bne	r2,zero,1afbc <alt_read_cfi_width+0x330>
   1af5c:	e0bffcc3 	ldbu	r2,-13(fp)
   1af60:	10803fcc 	andi	r2,r2,255
   1af64:	1000151e 	bne	r2,zero,1afbc <alt_read_cfi_width+0x330>
   1af68:	e0bfff17 	ldw	r2,-4(fp)
   1af6c:	00c00084 	movi	r3,2
   1af70:	10c02e15 	stw	r3,184(r2)
   1af74:	e0bfff17 	ldw	r2,-4(fp)
   1af78:	00c00084 	movi	r3,2
   1af7c:	10c02f15 	stw	r3,188(r2)
   1af80:	e0bfff17 	ldw	r2,-4(fp)
   1af84:	10800a17 	ldw	r2,40(r2)
   1af88:	10801404 	addi	r2,r2,80
   1af8c:	1080002b 	ldhuio	r2,0(r2)
   1af90:	10bfffcc 	andi	r2,r2,65535
   1af94:	e0bffb0d 	sth	r2,-20(fp)
   1af98:	e0bffb0b 	ldhu	r2,-20(fp)
   1af9c:	10800044 	addi	r2,r2,1
   1afa0:	e0bffb0d 	sth	r2,-20(fp)
   1afa4:	e0bffb0b 	ldhu	r2,-20(fp)
   1afa8:	1080008c 	andi	r2,r2,2
   1afac:	10010d1e 	bne	r2,zero,1b3e4 <alt_read_cfi_width+0x758>
   1afb0:	00bffb44 	movi	r2,-19
   1afb4:	e0bffa15 	stw	r2,-24(fp)
   1afb8:	00010a06 	br	1b3e4 <alt_read_cfi_width+0x758>
   1afbc:	e0bfff17 	ldw	r2,-4(fp)
   1afc0:	10800a17 	ldw	r2,40(r2)
   1afc4:	1009883a 	mov	r4,r2
   1afc8:	01401544 	movi	r5,85
   1afcc:	01802604 	movi	r6,152
   1afd0:	001a2f40 	call	1a2f4 <alt_write_flash_command_32bit_device_32bit_mode>
   1afd4:	e03ff915 	stw	zero,-28(fp)
   1afd8:	00000f06 	br	1b018 <alt_read_cfi_width+0x38c>
   1afdc:	e0bfff17 	ldw	r2,-4(fp)
   1afe0:	10c00a17 	ldw	r3,40(r2)
   1afe4:	e0bff917 	ldw	r2,-28(fp)
   1afe8:	10801004 	addi	r2,r2,64
   1afec:	1885883a 	add	r2,r3,r2
   1aff0:	10800023 	ldbuio	r2,0(r2)
   1aff4:	10803fcc 	andi	r2,r2,255
   1aff8:	1007883a 	mov	r3,r2
   1affc:	e13ffb84 	addi	r4,fp,-18
   1b000:	e0bff917 	ldw	r2,-28(fp)
   1b004:	2085883a 	add	r2,r4,r2
   1b008:	10c00005 	stb	r3,0(r2)
   1b00c:	e0bff917 	ldw	r2,-28(fp)
   1b010:	10800044 	addi	r2,r2,1
   1b014:	e0bff915 	stw	r2,-28(fp)
   1b018:	e0bff917 	ldw	r2,-28(fp)
   1b01c:	10800310 	cmplti	r2,r2,12
   1b020:	103fee1e 	bne	r2,zero,1afdc <alt_read_cfi_width+0x350>
   1b024:	e0bffb83 	ldbu	r2,-18(fp)
   1b028:	10803fcc 	andi	r2,r2,255
   1b02c:	10801458 	cmpnei	r2,r2,81
   1b030:	1000371e 	bne	r2,zero,1b110 <alt_read_cfi_width+0x484>
   1b034:	e0bffbc3 	ldbu	r2,-17(fp)
   1b038:	10803fcc 	andi	r2,r2,255
   1b03c:	1000341e 	bne	r2,zero,1b110 <alt_read_cfi_width+0x484>
   1b040:	e0bffc03 	ldbu	r2,-16(fp)
   1b044:	10803fcc 	andi	r2,r2,255
   1b048:	1000311e 	bne	r2,zero,1b110 <alt_read_cfi_width+0x484>
   1b04c:	e0bffc43 	ldbu	r2,-15(fp)
   1b050:	10803fcc 	andi	r2,r2,255
   1b054:	10002e1e 	bne	r2,zero,1b110 <alt_read_cfi_width+0x484>
   1b058:	e0bffc83 	ldbu	r2,-14(fp)
   1b05c:	10803fcc 	andi	r2,r2,255
   1b060:	10801498 	cmpnei	r2,r2,82
   1b064:	10002a1e 	bne	r2,zero,1b110 <alt_read_cfi_width+0x484>
   1b068:	e0bffcc3 	ldbu	r2,-13(fp)
   1b06c:	10803fcc 	andi	r2,r2,255
   1b070:	1000271e 	bne	r2,zero,1b110 <alt_read_cfi_width+0x484>
   1b074:	e0bffd03 	ldbu	r2,-12(fp)
   1b078:	10803fcc 	andi	r2,r2,255
   1b07c:	1000241e 	bne	r2,zero,1b110 <alt_read_cfi_width+0x484>
   1b080:	e0bffd43 	ldbu	r2,-11(fp)
   1b084:	10803fcc 	andi	r2,r2,255
   1b088:	1000211e 	bne	r2,zero,1b110 <alt_read_cfi_width+0x484>
   1b08c:	e0bffd83 	ldbu	r2,-10(fp)
   1b090:	10803fcc 	andi	r2,r2,255
   1b094:	10801658 	cmpnei	r2,r2,89
   1b098:	10001d1e 	bne	r2,zero,1b110 <alt_read_cfi_width+0x484>
   1b09c:	e0bffdc3 	ldbu	r2,-9(fp)
   1b0a0:	10803fcc 	andi	r2,r2,255
   1b0a4:	10001a1e 	bne	r2,zero,1b110 <alt_read_cfi_width+0x484>
   1b0a8:	e0bffe03 	ldbu	r2,-8(fp)
   1b0ac:	10803fcc 	andi	r2,r2,255
   1b0b0:	1000171e 	bne	r2,zero,1b110 <alt_read_cfi_width+0x484>
   1b0b4:	e0bffe43 	ldbu	r2,-7(fp)
   1b0b8:	10803fcc 	andi	r2,r2,255
   1b0bc:	1000141e 	bne	r2,zero,1b110 <alt_read_cfi_width+0x484>
   1b0c0:	e0bfff17 	ldw	r2,-4(fp)
   1b0c4:	00c00104 	movi	r3,4
   1b0c8:	10c02e15 	stw	r3,184(r2)
   1b0cc:	e0bfff17 	ldw	r2,-4(fp)
   1b0d0:	00c00104 	movi	r3,4
   1b0d4:	10c02f15 	stw	r3,188(r2)
   1b0d8:	e0bfff17 	ldw	r2,-4(fp)
   1b0dc:	10800a17 	ldw	r2,40(r2)
   1b0e0:	10802804 	addi	r2,r2,160
   1b0e4:	10800037 	ldwio	r2,0(r2)
   1b0e8:	e0bffb0d 	sth	r2,-20(fp)
   1b0ec:	e0bffb0b 	ldhu	r2,-20(fp)
   1b0f0:	10800044 	addi	r2,r2,1
   1b0f4:	e0bffb0d 	sth	r2,-20(fp)
   1b0f8:	e0bffb0b 	ldhu	r2,-20(fp)
   1b0fc:	1080010c 	andi	r2,r2,4
   1b100:	1000b81e 	bne	r2,zero,1b3e4 <alt_read_cfi_width+0x758>
   1b104:	00bffb44 	movi	r2,-19
   1b108:	e0bffa15 	stw	r2,-24(fp)
   1b10c:	0000b506 	br	1b3e4 <alt_read_cfi_width+0x758>
   1b110:	e0bfff17 	ldw	r2,-4(fp)
   1b114:	10800a17 	ldw	r2,40(r2)
   1b118:	1009883a 	mov	r4,r2
   1b11c:	01401544 	movi	r5,85
   1b120:	01802604 	movi	r6,152
   1b124:	001a2a80 	call	1a2a8 <alt_write_flash_command_32bit_device_16bit_mode>
   1b128:	e03ff915 	stw	zero,-28(fp)
   1b12c:	00000f06 	br	1b16c <alt_read_cfi_width+0x4e0>
   1b130:	e0bfff17 	ldw	r2,-4(fp)
   1b134:	10c00a17 	ldw	r3,40(r2)
   1b138:	e0bff917 	ldw	r2,-28(fp)
   1b13c:	10801004 	addi	r2,r2,64
   1b140:	1885883a 	add	r2,r3,r2
   1b144:	10800023 	ldbuio	r2,0(r2)
   1b148:	10803fcc 	andi	r2,r2,255
   1b14c:	1007883a 	mov	r3,r2
   1b150:	e13ffb84 	addi	r4,fp,-18
   1b154:	e0bff917 	ldw	r2,-28(fp)
   1b158:	2085883a 	add	r2,r4,r2
   1b15c:	10c00005 	stb	r3,0(r2)
   1b160:	e0bff917 	ldw	r2,-28(fp)
   1b164:	10800044 	addi	r2,r2,1
   1b168:	e0bff915 	stw	r2,-28(fp)
   1b16c:	e0bff917 	ldw	r2,-28(fp)
   1b170:	10800310 	cmplti	r2,r2,12
   1b174:	103fee1e 	bne	r2,zero,1b130 <alt_read_cfi_width+0x4a4>
   1b178:	e0bffb83 	ldbu	r2,-18(fp)
   1b17c:	10803fcc 	andi	r2,r2,255
   1b180:	10801458 	cmpnei	r2,r2,81
   1b184:	10003a1e 	bne	r2,zero,1b270 <alt_read_cfi_width+0x5e4>
   1b188:	e0bffbc3 	ldbu	r2,-17(fp)
   1b18c:	10803fcc 	andi	r2,r2,255
   1b190:	1000371e 	bne	r2,zero,1b270 <alt_read_cfi_width+0x5e4>
   1b194:	e0bffc03 	ldbu	r2,-16(fp)
   1b198:	10803fcc 	andi	r2,r2,255
   1b19c:	10801458 	cmpnei	r2,r2,81
   1b1a0:	1000331e 	bne	r2,zero,1b270 <alt_read_cfi_width+0x5e4>
   1b1a4:	e0bffc43 	ldbu	r2,-15(fp)
   1b1a8:	10803fcc 	andi	r2,r2,255
   1b1ac:	1000301e 	bne	r2,zero,1b270 <alt_read_cfi_width+0x5e4>
   1b1b0:	e0bffc83 	ldbu	r2,-14(fp)
   1b1b4:	10803fcc 	andi	r2,r2,255
   1b1b8:	10801498 	cmpnei	r2,r2,82
   1b1bc:	10002c1e 	bne	r2,zero,1b270 <alt_read_cfi_width+0x5e4>
   1b1c0:	e0bffcc3 	ldbu	r2,-13(fp)
   1b1c4:	10803fcc 	andi	r2,r2,255
   1b1c8:	1000291e 	bne	r2,zero,1b270 <alt_read_cfi_width+0x5e4>
   1b1cc:	e0bffd03 	ldbu	r2,-12(fp)
   1b1d0:	10803fcc 	andi	r2,r2,255
   1b1d4:	10801498 	cmpnei	r2,r2,82
   1b1d8:	1000251e 	bne	r2,zero,1b270 <alt_read_cfi_width+0x5e4>
   1b1dc:	e0bffd43 	ldbu	r2,-11(fp)
   1b1e0:	10803fcc 	andi	r2,r2,255
   1b1e4:	1000221e 	bne	r2,zero,1b270 <alt_read_cfi_width+0x5e4>
   1b1e8:	e0bffd83 	ldbu	r2,-10(fp)
   1b1ec:	10803fcc 	andi	r2,r2,255
   1b1f0:	10801658 	cmpnei	r2,r2,89
   1b1f4:	10001e1e 	bne	r2,zero,1b270 <alt_read_cfi_width+0x5e4>
   1b1f8:	e0bffdc3 	ldbu	r2,-9(fp)
   1b1fc:	10803fcc 	andi	r2,r2,255
   1b200:	10001b1e 	bne	r2,zero,1b270 <alt_read_cfi_width+0x5e4>
   1b204:	e0bffe03 	ldbu	r2,-8(fp)
   1b208:	10803fcc 	andi	r2,r2,255
   1b20c:	10801658 	cmpnei	r2,r2,89
   1b210:	1000171e 	bne	r2,zero,1b270 <alt_read_cfi_width+0x5e4>
   1b214:	e0bffe43 	ldbu	r2,-7(fp)
   1b218:	10803fcc 	andi	r2,r2,255
   1b21c:	1000141e 	bne	r2,zero,1b270 <alt_read_cfi_width+0x5e4>
   1b220:	e0bfff17 	ldw	r2,-4(fp)
   1b224:	00c00084 	movi	r3,2
   1b228:	10c02e15 	stw	r3,184(r2)
   1b22c:	e0bfff17 	ldw	r2,-4(fp)
   1b230:	00c00104 	movi	r3,4
   1b234:	10c02f15 	stw	r3,188(r2)
   1b238:	e0bfff17 	ldw	r2,-4(fp)
   1b23c:	10800a17 	ldw	r2,40(r2)
   1b240:	10802804 	addi	r2,r2,160
   1b244:	10800037 	ldwio	r2,0(r2)
   1b248:	e0bffb0d 	sth	r2,-20(fp)
   1b24c:	e0bffb0b 	ldhu	r2,-20(fp)
   1b250:	10800044 	addi	r2,r2,1
   1b254:	e0bffb0d 	sth	r2,-20(fp)
   1b258:	e0bffb0b 	ldhu	r2,-20(fp)
   1b25c:	1080010c 	andi	r2,r2,4
   1b260:	1000601e 	bne	r2,zero,1b3e4 <alt_read_cfi_width+0x758>
   1b264:	00bffb44 	movi	r2,-19
   1b268:	e0bffa15 	stw	r2,-24(fp)
   1b26c:	00005d06 	br	1b3e4 <alt_read_cfi_width+0x758>
   1b270:	e0bfff17 	ldw	r2,-4(fp)
   1b274:	10800a17 	ldw	r2,40(r2)
   1b278:	1009883a 	mov	r4,r2
   1b27c:	01401544 	movi	r5,85
   1b280:	01802604 	movi	r6,152
   1b284:	001a2140 	call	1a214 <alt_write_flash_command_32bit_device_8bit_mode>
   1b288:	e03ff915 	stw	zero,-28(fp)
   1b28c:	00000f06 	br	1b2cc <alt_read_cfi_width+0x640>
   1b290:	e0bfff17 	ldw	r2,-4(fp)
   1b294:	10c00a17 	ldw	r3,40(r2)
   1b298:	e0bff917 	ldw	r2,-28(fp)
   1b29c:	10801004 	addi	r2,r2,64
   1b2a0:	1885883a 	add	r2,r3,r2
   1b2a4:	10800023 	ldbuio	r2,0(r2)
   1b2a8:	10803fcc 	andi	r2,r2,255
   1b2ac:	1007883a 	mov	r3,r2
   1b2b0:	e13ffb84 	addi	r4,fp,-18
   1b2b4:	e0bff917 	ldw	r2,-28(fp)
   1b2b8:	2085883a 	add	r2,r4,r2
   1b2bc:	10c00005 	stb	r3,0(r2)
   1b2c0:	e0bff917 	ldw	r2,-28(fp)
   1b2c4:	10800044 	addi	r2,r2,1
   1b2c8:	e0bff915 	stw	r2,-28(fp)
   1b2cc:	e0bff917 	ldw	r2,-28(fp)
   1b2d0:	10800310 	cmplti	r2,r2,12
   1b2d4:	103fee1e 	bne	r2,zero,1b290 <alt_read_cfi_width+0x604>
   1b2d8:	e0bffb83 	ldbu	r2,-18(fp)
   1b2dc:	10803fcc 	andi	r2,r2,255
   1b2e0:	10801458 	cmpnei	r2,r2,81
   1b2e4:	10003f1e 	bne	r2,zero,1b3e4 <alt_read_cfi_width+0x758>
   1b2e8:	e0bffbc3 	ldbu	r2,-17(fp)
   1b2ec:	10803fcc 	andi	r2,r2,255
   1b2f0:	10801458 	cmpnei	r2,r2,81
   1b2f4:	10003b1e 	bne	r2,zero,1b3e4 <alt_read_cfi_width+0x758>
   1b2f8:	e0bffc03 	ldbu	r2,-16(fp)
   1b2fc:	10803fcc 	andi	r2,r2,255
   1b300:	10801458 	cmpnei	r2,r2,81
   1b304:	1000371e 	bne	r2,zero,1b3e4 <alt_read_cfi_width+0x758>
   1b308:	e0bffc43 	ldbu	r2,-15(fp)
   1b30c:	10803fcc 	andi	r2,r2,255
   1b310:	10801458 	cmpnei	r2,r2,81
   1b314:	1000331e 	bne	r2,zero,1b3e4 <alt_read_cfi_width+0x758>
   1b318:	e0bffc83 	ldbu	r2,-14(fp)
   1b31c:	10803fcc 	andi	r2,r2,255
   1b320:	10801498 	cmpnei	r2,r2,82
   1b324:	10002f1e 	bne	r2,zero,1b3e4 <alt_read_cfi_width+0x758>
   1b328:	e0bffcc3 	ldbu	r2,-13(fp)
   1b32c:	10803fcc 	andi	r2,r2,255
   1b330:	10801498 	cmpnei	r2,r2,82
   1b334:	10002b1e 	bne	r2,zero,1b3e4 <alt_read_cfi_width+0x758>
   1b338:	e0bffd03 	ldbu	r2,-12(fp)
   1b33c:	10803fcc 	andi	r2,r2,255
   1b340:	10801498 	cmpnei	r2,r2,82
   1b344:	1000271e 	bne	r2,zero,1b3e4 <alt_read_cfi_width+0x758>
   1b348:	e0bffd43 	ldbu	r2,-11(fp)
   1b34c:	10803fcc 	andi	r2,r2,255
   1b350:	10801498 	cmpnei	r2,r2,82
   1b354:	1000231e 	bne	r2,zero,1b3e4 <alt_read_cfi_width+0x758>
   1b358:	e0bffd83 	ldbu	r2,-10(fp)
   1b35c:	10803fcc 	andi	r2,r2,255
   1b360:	10801658 	cmpnei	r2,r2,89
   1b364:	10001f1e 	bne	r2,zero,1b3e4 <alt_read_cfi_width+0x758>
   1b368:	e0bffdc3 	ldbu	r2,-9(fp)
   1b36c:	10803fcc 	andi	r2,r2,255
   1b370:	10801658 	cmpnei	r2,r2,89
   1b374:	10001b1e 	bne	r2,zero,1b3e4 <alt_read_cfi_width+0x758>
   1b378:	e0bffe03 	ldbu	r2,-8(fp)
   1b37c:	10803fcc 	andi	r2,r2,255
   1b380:	10801658 	cmpnei	r2,r2,89
   1b384:	1000171e 	bne	r2,zero,1b3e4 <alt_read_cfi_width+0x758>
   1b388:	e0bffe43 	ldbu	r2,-7(fp)
   1b38c:	10803fcc 	andi	r2,r2,255
   1b390:	10801658 	cmpnei	r2,r2,89
   1b394:	1000131e 	bne	r2,zero,1b3e4 <alt_read_cfi_width+0x758>
   1b398:	e0bfff17 	ldw	r2,-4(fp)
   1b39c:	00c00044 	movi	r3,1
   1b3a0:	10c02e15 	stw	r3,184(r2)
   1b3a4:	e0bfff17 	ldw	r2,-4(fp)
   1b3a8:	00c00104 	movi	r3,4
   1b3ac:	10c02f15 	stw	r3,188(r2)
   1b3b0:	e0bfff17 	ldw	r2,-4(fp)
   1b3b4:	10800a17 	ldw	r2,40(r2)
   1b3b8:	10802804 	addi	r2,r2,160
   1b3bc:	10800037 	ldwio	r2,0(r2)
   1b3c0:	e0bffb0d 	sth	r2,-20(fp)
   1b3c4:	e0bffb0b 	ldhu	r2,-20(fp)
   1b3c8:	10800044 	addi	r2,r2,1
   1b3cc:	e0bffb0d 	sth	r2,-20(fp)
   1b3d0:	e0bffb0b 	ldhu	r2,-20(fp)
   1b3d4:	1080010c 	andi	r2,r2,4
   1b3d8:	1000021e 	bne	r2,zero,1b3e4 <alt_read_cfi_width+0x758>
   1b3dc:	00bffb44 	movi	r2,-19
   1b3e0:	e0bffa15 	stw	r2,-24(fp)
   1b3e4:	e0bffa17 	ldw	r2,-24(fp)
   1b3e8:	e037883a 	mov	sp,fp
   1b3ec:	dfc00117 	ldw	ra,4(sp)
   1b3f0:	df000017 	ldw	fp,0(sp)
   1b3f4:	dec00204 	addi	sp,sp,8
   1b3f8:	f800283a 	ret

0001b3fc <alt_check_primary_table>:
   1b3fc:	defffa04 	addi	sp,sp,-24
   1b400:	dfc00515 	stw	ra,20(sp)
   1b404:	df000415 	stw	fp,16(sp)
   1b408:	df000404 	addi	fp,sp,16
   1b40c:	e13fff15 	stw	r4,-4(fp)
   1b410:	e03ffd15 	stw	zero,-12(fp)
   1b414:	e13fff17 	ldw	r4,-4(fp)
   1b418:	01400544 	movi	r5,21
   1b41c:	001a6440 	call	1a644 <alt_read_16bit_query_entry>
   1b420:	10ffffcc 	andi	r3,r2,65535
   1b424:	e0bfff17 	ldw	r2,-4(fp)
   1b428:	10c03215 	stw	r3,200(r2)
   1b42c:	e03ffc15 	stw	zero,-16(fp)
   1b430:	00001006 	br	1b474 <alt_check_primary_table+0x78>
   1b434:	e0bfff17 	ldw	r2,-4(fp)
   1b438:	10c03417 	ldw	r3,208(r2)
   1b43c:	e0bfff17 	ldw	r2,-4(fp)
   1b440:	11003217 	ldw	r4,200(r2)
   1b444:	e0bffc17 	ldw	r2,-16(fp)
   1b448:	2085883a 	add	r2,r4,r2
   1b44c:	e13fff17 	ldw	r4,-4(fp)
   1b450:	100b883a 	mov	r5,r2
   1b454:	183ee83a 	callr	r3
   1b458:	e13ffe04 	addi	r4,fp,-8
   1b45c:	e0fffc17 	ldw	r3,-16(fp)
   1b460:	20c7883a 	add	r3,r4,r3
   1b464:	18800005 	stb	r2,0(r3)
   1b468:	e0bffc17 	ldw	r2,-16(fp)
   1b46c:	10800044 	addi	r2,r2,1
   1b470:	e0bffc15 	stw	r2,-16(fp)
   1b474:	e0bffc17 	ldw	r2,-16(fp)
   1b478:	108000d0 	cmplti	r2,r2,3
   1b47c:	103fed1e 	bne	r2,zero,1b434 <alt_check_primary_table+0x38>
   1b480:	e0bffe03 	ldbu	r2,-8(fp)
   1b484:	10803fcc 	andi	r2,r2,255
   1b488:	10801418 	cmpnei	r2,r2,80
   1b48c:	1000081e 	bne	r2,zero,1b4b0 <alt_check_primary_table+0xb4>
   1b490:	e0bffe43 	ldbu	r2,-7(fp)
   1b494:	10803fcc 	andi	r2,r2,255
   1b498:	10801498 	cmpnei	r2,r2,82
   1b49c:	1000041e 	bne	r2,zero,1b4b0 <alt_check_primary_table+0xb4>
   1b4a0:	e0bffe83 	ldbu	r2,-6(fp)
   1b4a4:	10803fcc 	andi	r2,r2,255
   1b4a8:	10801260 	cmpeqi	r2,r2,73
   1b4ac:	1000021e 	bne	r2,zero,1b4b8 <alt_check_primary_table+0xbc>
   1b4b0:	00bffb44 	movi	r2,-19
   1b4b4:	e0bffd15 	stw	r2,-12(fp)
   1b4b8:	e0bffd17 	ldw	r2,-12(fp)
   1b4bc:	e037883a 	mov	sp,fp
   1b4c0:	dfc00117 	ldw	ra,4(sp)
   1b4c4:	df000017 	ldw	fp,0(sp)
   1b4c8:	dec00204 	addi	sp,sp,8
   1b4cc:	f800283a 	ret

0001b4d0 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
   1b4d0:	defffa04 	addi	sp,sp,-24
   1b4d4:	dfc00515 	stw	ra,20(sp)
   1b4d8:	df000415 	stw	fp,16(sp)
   1b4dc:	df000404 	addi	fp,sp,16
   1b4e0:	e13ffd15 	stw	r4,-12(fp)
   1b4e4:	e17ffe15 	stw	r5,-8(fp)
   1b4e8:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   1b4ec:	e0bffd17 	ldw	r2,-12(fp)
   1b4f0:	10800017 	ldw	r2,0(r2)
   1b4f4:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
   1b4f8:	e0bffc17 	ldw	r2,-16(fp)
   1b4fc:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
   1b500:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
   1b504:	10800217 	ldw	r2,8(r2)
   1b508:	1809883a 	mov	r4,r3
   1b50c:	e17ffe17 	ldw	r5,-8(fp)
   1b510:	e1bfff17 	ldw	r6,-4(fp)
   1b514:	100f883a 	mov	r7,r2
   1b518:	001baf80 	call	1baf8 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
   1b51c:	e037883a 	mov	sp,fp
   1b520:	dfc00117 	ldw	ra,4(sp)
   1b524:	df000017 	ldw	fp,0(sp)
   1b528:	dec00204 	addi	sp,sp,8
   1b52c:	f800283a 	ret

0001b530 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
   1b530:	defffa04 	addi	sp,sp,-24
   1b534:	dfc00515 	stw	ra,20(sp)
   1b538:	df000415 	stw	fp,16(sp)
   1b53c:	df000404 	addi	fp,sp,16
   1b540:	e13ffd15 	stw	r4,-12(fp)
   1b544:	e17ffe15 	stw	r5,-8(fp)
   1b548:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   1b54c:	e0bffd17 	ldw	r2,-12(fp)
   1b550:	10800017 	ldw	r2,0(r2)
   1b554:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
   1b558:	e0bffc17 	ldw	r2,-16(fp)
   1b55c:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
   1b560:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
   1b564:	10800217 	ldw	r2,8(r2)
   1b568:	1809883a 	mov	r4,r3
   1b56c:	e17ffe17 	ldw	r5,-8(fp)
   1b570:	e1bfff17 	ldw	r6,-4(fp)
   1b574:	100f883a 	mov	r7,r2
   1b578:	001bd3c0 	call	1bd3c <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
   1b57c:	e037883a 	mov	sp,fp
   1b580:	dfc00117 	ldw	ra,4(sp)
   1b584:	df000017 	ldw	fp,0(sp)
   1b588:	dec00204 	addi	sp,sp,8
   1b58c:	f800283a 	ret

0001b590 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
   1b590:	defffc04 	addi	sp,sp,-16
   1b594:	dfc00315 	stw	ra,12(sp)
   1b598:	df000215 	stw	fp,8(sp)
   1b59c:	df000204 	addi	fp,sp,8
   1b5a0:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   1b5a4:	e0bfff17 	ldw	r2,-4(fp)
   1b5a8:	10800017 	ldw	r2,0(r2)
   1b5ac:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
   1b5b0:	e0bffe17 	ldw	r2,-8(fp)
   1b5b4:	10c00a04 	addi	r3,r2,40
   1b5b8:	e0bfff17 	ldw	r2,-4(fp)
   1b5bc:	10800217 	ldw	r2,8(r2)
   1b5c0:	1809883a 	mov	r4,r3
   1b5c4:	100b883a 	mov	r5,r2
   1b5c8:	001b99c0 	call	1b99c <altera_avalon_jtag_uart_close>
}
   1b5cc:	e037883a 	mov	sp,fp
   1b5d0:	dfc00117 	ldw	ra,4(sp)
   1b5d4:	df000017 	ldw	fp,0(sp)
   1b5d8:	dec00204 	addi	sp,sp,8
   1b5dc:	f800283a 	ret

0001b5e0 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
   1b5e0:	defffa04 	addi	sp,sp,-24
   1b5e4:	dfc00515 	stw	ra,20(sp)
   1b5e8:	df000415 	stw	fp,16(sp)
   1b5ec:	df000404 	addi	fp,sp,16
   1b5f0:	e13ffd15 	stw	r4,-12(fp)
   1b5f4:	e17ffe15 	stw	r5,-8(fp)
   1b5f8:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
   1b5fc:	e0bffd17 	ldw	r2,-12(fp)
   1b600:	10800017 	ldw	r2,0(r2)
   1b604:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
   1b608:	e0bffc17 	ldw	r2,-16(fp)
   1b60c:	10800a04 	addi	r2,r2,40
   1b610:	1009883a 	mov	r4,r2
   1b614:	e17ffe17 	ldw	r5,-8(fp)
   1b618:	e1bfff17 	ldw	r6,-4(fp)
   1b61c:	001ba040 	call	1ba04 <altera_avalon_jtag_uart_ioctl>
}
   1b620:	e037883a 	mov	sp,fp
   1b624:	dfc00117 	ldw	ra,4(sp)
   1b628:	df000017 	ldw	fp,0(sp)
   1b62c:	dec00204 	addi	sp,sp,8
   1b630:	f800283a 	ret

0001b634 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
   1b634:	defffa04 	addi	sp,sp,-24
   1b638:	dfc00515 	stw	ra,20(sp)
   1b63c:	df000415 	stw	fp,16(sp)
   1b640:	df000404 	addi	fp,sp,16
   1b644:	e13ffd15 	stw	r4,-12(fp)
   1b648:	e17ffe15 	stw	r5,-8(fp)
   1b64c:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
   1b650:	e0bffd17 	ldw	r2,-12(fp)
   1b654:	00c00044 	movi	r3,1
   1b658:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
   1b65c:	e0bffd17 	ldw	r2,-12(fp)
   1b660:	10800017 	ldw	r2,0(r2)
   1b664:	10800104 	addi	r2,r2,4
   1b668:	e0fffd17 	ldw	r3,-12(fp)
   1b66c:	18c00817 	ldw	r3,32(r3)
   1b670:	10c00035 	stwio	r3,0(r2)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
   1b674:	e0fffe17 	ldw	r3,-8(fp)
   1b678:	e0bfff17 	ldw	r2,-4(fp)
   1b67c:	d8000015 	stw	zero,0(sp)
   1b680:	1809883a 	mov	r4,r3
   1b684:	100b883a 	mov	r5,r2
   1b688:	018000b4 	movhi	r6,2
   1b68c:	31adbd04 	addi	r6,r6,-18700
   1b690:	e1fffd17 	ldw	r7,-12(fp)
   1b694:	0021ca40 	call	21ca4 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
   1b698:	e0bffd17 	ldw	r2,-12(fp)
   1b69c:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
   1b6a0:	e0bffd17 	ldw	r2,-12(fp)
   1b6a4:	10c00204 	addi	r3,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
   1b6a8:	008000f4 	movhi	r2,3
   1b6ac:	10aed804 	addi	r2,r2,-17568
   1b6b0:	10800017 	ldw	r2,0(r2)
   1b6b4:	1809883a 	mov	r4,r3
   1b6b8:	100b883a 	mov	r5,r2
   1b6bc:	018000b4 	movhi	r6,2
   1b6c0:	31ae3e04 	addi	r6,r6,-18184
   1b6c4:	e1fffd17 	ldw	r7,-12(fp)
   1b6c8:	00188880 	call	18888 <alt_alarm_start>
   1b6cc:	1000040e 	bge	r2,zero,1b6e0 <altera_avalon_jtag_uart_init+0xac>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
   1b6d0:	e0bffd17 	ldw	r2,-12(fp)
   1b6d4:	00e00034 	movhi	r3,32768
   1b6d8:	18ffffc4 	addi	r3,r3,-1
   1b6dc:	10c00115 	stw	r3,4(r2)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
   1b6e0:	e037883a 	mov	sp,fp
   1b6e4:	dfc00117 	ldw	ra,4(sp)
   1b6e8:	df000017 	ldw	fp,0(sp)
   1b6ec:	dec00204 	addi	sp,sp,8
   1b6f0:	f800283a 	ret

0001b6f4 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
   1b6f4:	defff804 	addi	sp,sp,-32
   1b6f8:	df000715 	stw	fp,28(sp)
   1b6fc:	df000704 	addi	fp,sp,28
   1b700:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
   1b704:	e0bfff17 	ldw	r2,-4(fp)
   1b708:	e0bffb15 	stw	r2,-20(fp)
  unsigned int base = sp->base;
   1b70c:	e0bffb17 	ldw	r2,-20(fp)
   1b710:	10800017 	ldw	r2,0(r2)
   1b714:	e0bffc15 	stw	r2,-16(fp)
   1b718:	00000106 	br	1b720 <altera_avalon_jtag_uart_irq+0x2c>
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
   1b71c:	0001883a 	nop
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
   1b720:	e0bffc17 	ldw	r2,-16(fp)
   1b724:	10800104 	addi	r2,r2,4
   1b728:	10800037 	ldwio	r2,0(r2)
   1b72c:	e0bffd15 	stw	r2,-12(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
   1b730:	e0bffd17 	ldw	r2,-12(fp)
   1b734:	1080c00c 	andi	r2,r2,768
   1b738:	10006a26 	beq	r2,zero,1b8e4 <altera_avalon_jtag_uart_irq+0x1f0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
   1b73c:	e0bffd17 	ldw	r2,-12(fp)
   1b740:	1080400c 	andi	r2,r2,256
   1b744:	10003326 	beq	r2,zero,1b814 <altera_avalon_jtag_uart_irq+0x120>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
   1b748:	00800074 	movhi	r2,1
   1b74c:	e0bff915 	stw	r2,-28(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   1b750:	e0bffb17 	ldw	r2,-20(fp)
   1b754:	10800a17 	ldw	r2,40(r2)
   1b758:	10800044 	addi	r2,r2,1
   1b75c:	1081ffcc 	andi	r2,r2,2047
   1b760:	e0bffe15 	stw	r2,-8(fp)
        if (next == sp->rx_out)
   1b764:	e0bffb17 	ldw	r2,-20(fp)
   1b768:	10c00b17 	ldw	r3,44(r2)
   1b76c:	e0bffe17 	ldw	r2,-8(fp)
   1b770:	18801426 	beq	r3,r2,1b7c4 <altera_avalon_jtag_uart_irq+0xd0>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
   1b774:	e0bffc17 	ldw	r2,-16(fp)
   1b778:	10800037 	ldwio	r2,0(r2)
   1b77c:	e0bff915 	stw	r2,-28(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
   1b780:	e0bff917 	ldw	r2,-28(fp)
   1b784:	10a0000c 	andi	r2,r2,32768
   1b788:	10001026 	beq	r2,zero,1b7cc <altera_avalon_jtag_uart_irq+0xd8>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
   1b78c:	e0bffb17 	ldw	r2,-20(fp)
   1b790:	10800a17 	ldw	r2,40(r2)
   1b794:	e0fff917 	ldw	r3,-28(fp)
   1b798:	e13ffb17 	ldw	r4,-20(fp)
   1b79c:	2085883a 	add	r2,r4,r2
   1b7a0:	10800e04 	addi	r2,r2,56
   1b7a4:	10c00005 	stb	r3,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   1b7a8:	e0bffb17 	ldw	r2,-20(fp)
   1b7ac:	10800a17 	ldw	r2,40(r2)
   1b7b0:	10800044 	addi	r2,r2,1
   1b7b4:	10c1ffcc 	andi	r3,r2,2047
   1b7b8:	e0bffb17 	ldw	r2,-20(fp)
   1b7bc:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
   1b7c0:	003fe306 	br	1b750 <altera_avalon_jtag_uart_irq+0x5c>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
   1b7c4:	0001883a 	nop
   1b7c8:	00000106 	br	1b7d0 <altera_avalon_jtag_uart_irq+0xdc>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
   1b7cc:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
   1b7d0:	e0bff917 	ldw	r2,-28(fp)
   1b7d4:	10bfffec 	andhi	r2,r2,65535
   1b7d8:	10000e26 	beq	r2,zero,1b814 <altera_avalon_jtag_uart_irq+0x120>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
   1b7dc:	e0bffb17 	ldw	r2,-20(fp)
   1b7e0:	10c00817 	ldw	r3,32(r2)
   1b7e4:	00bfff84 	movi	r2,-2
   1b7e8:	1886703a 	and	r3,r3,r2
   1b7ec:	e0bffb17 	ldw	r2,-20(fp)
   1b7f0:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
   1b7f4:	e0bffc17 	ldw	r2,-16(fp)
   1b7f8:	10800104 	addi	r2,r2,4
   1b7fc:	e0fffb17 	ldw	r3,-20(fp)
   1b800:	18c00817 	ldw	r3,32(r3)
   1b804:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
   1b808:	e0bffc17 	ldw	r2,-16(fp)
   1b80c:	10800104 	addi	r2,r2,4
   1b810:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
   1b814:	e0bffd17 	ldw	r2,-12(fp)
   1b818:	1080800c 	andi	r2,r2,512
   1b81c:	103fbf26 	beq	r2,zero,1b71c <altera_avalon_jtag_uart_irq+0x28>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
   1b820:	e0bffd17 	ldw	r2,-12(fp)
   1b824:	1004d43a 	srli	r2,r2,16
   1b828:	e0bffa15 	stw	r2,-24(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
   1b82c:	00001406 	br	1b880 <altera_avalon_jtag_uart_irq+0x18c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
   1b830:	e0bffc17 	ldw	r2,-16(fp)
   1b834:	e0fffb17 	ldw	r3,-20(fp)
   1b838:	18c00d17 	ldw	r3,52(r3)
   1b83c:	e13ffb17 	ldw	r4,-20(fp)
   1b840:	20c7883a 	add	r3,r4,r3
   1b844:	18c20e04 	addi	r3,r3,2104
   1b848:	18c00003 	ldbu	r3,0(r3)
   1b84c:	18c03fcc 	andi	r3,r3,255
   1b850:	18c0201c 	xori	r3,r3,128
   1b854:	18ffe004 	addi	r3,r3,-128
   1b858:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   1b85c:	e0bffb17 	ldw	r2,-20(fp)
   1b860:	10800d17 	ldw	r2,52(r2)
   1b864:	10800044 	addi	r2,r2,1
   1b868:	10c1ffcc 	andi	r3,r2,2047
   1b86c:	e0bffb17 	ldw	r2,-20(fp)
   1b870:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
   1b874:	e0bffa17 	ldw	r2,-24(fp)
   1b878:	10bfffc4 	addi	r2,r2,-1
   1b87c:	e0bffa15 	stw	r2,-24(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
   1b880:	e0bffa17 	ldw	r2,-24(fp)
   1b884:	10000526 	beq	r2,zero,1b89c <altera_avalon_jtag_uart_irq+0x1a8>
   1b888:	e0bffb17 	ldw	r2,-20(fp)
   1b88c:	10c00d17 	ldw	r3,52(r2)
   1b890:	e0bffb17 	ldw	r2,-20(fp)
   1b894:	10800c17 	ldw	r2,48(r2)
   1b898:	18bfe51e 	bne	r3,r2,1b830 <altera_avalon_jtag_uart_irq+0x13c>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
   1b89c:	e0bffa17 	ldw	r2,-24(fp)
   1b8a0:	103f9e26 	beq	r2,zero,1b71c <altera_avalon_jtag_uart_irq+0x28>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
   1b8a4:	e0bffb17 	ldw	r2,-20(fp)
   1b8a8:	10c00817 	ldw	r3,32(r2)
   1b8ac:	00bfff44 	movi	r2,-3
   1b8b0:	1886703a 	and	r3,r3,r2
   1b8b4:	e0bffb17 	ldw	r2,-20(fp)
   1b8b8:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
   1b8bc:	e0bffb17 	ldw	r2,-20(fp)
   1b8c0:	10800017 	ldw	r2,0(r2)
   1b8c4:	10800104 	addi	r2,r2,4
   1b8c8:	e0fffb17 	ldw	r3,-20(fp)
   1b8cc:	18c00817 	ldw	r3,32(r3)
   1b8d0:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
   1b8d4:	e0bffc17 	ldw	r2,-16(fp)
   1b8d8:	10800104 	addi	r2,r2,4
   1b8dc:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
   1b8e0:	003f8e06 	br	1b71c <altera_avalon_jtag_uart_irq+0x28>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
   1b8e4:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
   1b8e8:	e037883a 	mov	sp,fp
   1b8ec:	df000017 	ldw	fp,0(sp)
   1b8f0:	dec00104 	addi	sp,sp,4
   1b8f4:	f800283a 	ret

0001b8f8 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
   1b8f8:	defffc04 	addi	sp,sp,-16
   1b8fc:	df000315 	stw	fp,12(sp)
   1b900:	df000304 	addi	fp,sp,12
   1b904:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
   1b908:	e0bfff17 	ldw	r2,-4(fp)
   1b90c:	e0bffd15 	stw	r2,-12(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
   1b910:	e0bffd17 	ldw	r2,-12(fp)
   1b914:	10800017 	ldw	r2,0(r2)
   1b918:	10800104 	addi	r2,r2,4
   1b91c:	10800037 	ldwio	r2,0(r2)
   1b920:	e0bffe15 	stw	r2,-8(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
   1b924:	e0bffe17 	ldw	r2,-8(fp)
   1b928:	1081000c 	andi	r2,r2,1024
   1b92c:	10000a26 	beq	r2,zero,1b958 <altera_avalon_jtag_uart_timeout+0x60>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
   1b930:	e0bffd17 	ldw	r2,-12(fp)
   1b934:	10800017 	ldw	r2,0(r2)
   1b938:	10800104 	addi	r2,r2,4
   1b93c:	e0fffd17 	ldw	r3,-12(fp)
   1b940:	18c00817 	ldw	r3,32(r3)
   1b944:	18c10014 	ori	r3,r3,1024
   1b948:	10c00035 	stwio	r3,0(r2)
    sp->host_inactive = 0;
   1b94c:	e0bffd17 	ldw	r2,-12(fp)
   1b950:	10000915 	stw	zero,36(r2)
   1b954:	00000a06 	br	1b980 <altera_avalon_jtag_uart_timeout+0x88>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
   1b958:	e0bffd17 	ldw	r2,-12(fp)
   1b95c:	10800917 	ldw	r2,36(r2)
   1b960:	00e00034 	movhi	r3,32768
   1b964:	18ffff04 	addi	r3,r3,-4
   1b968:	18800536 	bltu	r3,r2,1b980 <altera_avalon_jtag_uart_timeout+0x88>
    sp->host_inactive++;
   1b96c:	e0bffd17 	ldw	r2,-12(fp)
   1b970:	10800917 	ldw	r2,36(r2)
   1b974:	10c00044 	addi	r3,r2,1
   1b978:	e0bffd17 	ldw	r2,-12(fp)
   1b97c:	10c00915 	stw	r3,36(r2)
   1b980:	008000f4 	movhi	r2,3
   1b984:	10aed804 	addi	r2,r2,-17568
   1b988:	10800017 	ldw	r2,0(r2)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
   1b98c:	e037883a 	mov	sp,fp
   1b990:	df000017 	ldw	fp,0(sp)
   1b994:	dec00104 	addi	sp,sp,4
   1b998:	f800283a 	ret

0001b99c <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
   1b99c:	defffd04 	addi	sp,sp,-12
   1b9a0:	df000215 	stw	fp,8(sp)
   1b9a4:	df000204 	addi	fp,sp,8
   1b9a8:	e13ffe15 	stw	r4,-8(fp)
   1b9ac:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
   1b9b0:	00000506 	br	1b9c8 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
   1b9b4:	e0bfff17 	ldw	r2,-4(fp)
   1b9b8:	1090000c 	andi	r2,r2,16384
   1b9bc:	10000226 	beq	r2,zero,1b9c8 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
   1b9c0:	00bffd44 	movi	r2,-11
   1b9c4:	00000b06 	br	1b9f4 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
   1b9c8:	e0bffe17 	ldw	r2,-8(fp)
   1b9cc:	10c00d17 	ldw	r3,52(r2)
   1b9d0:	e0bffe17 	ldw	r2,-8(fp)
   1b9d4:	10800c17 	ldw	r2,48(r2)
   1b9d8:	18800526 	beq	r3,r2,1b9f0 <altera_avalon_jtag_uart_close+0x54>
   1b9dc:	e0bffe17 	ldw	r2,-8(fp)
   1b9e0:	10c00917 	ldw	r3,36(r2)
   1b9e4:	e0bffe17 	ldw	r2,-8(fp)
   1b9e8:	10800117 	ldw	r2,4(r2)
   1b9ec:	18bff136 	bltu	r3,r2,1b9b4 <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
   1b9f0:	0005883a 	mov	r2,zero
}
   1b9f4:	e037883a 	mov	sp,fp
   1b9f8:	df000017 	ldw	fp,0(sp)
   1b9fc:	dec00104 	addi	sp,sp,4
   1ba00:	f800283a 	ret

0001ba04 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
   1ba04:	defffa04 	addi	sp,sp,-24
   1ba08:	df000515 	stw	fp,20(sp)
   1ba0c:	df000504 	addi	fp,sp,20
   1ba10:	e13ffd15 	stw	r4,-12(fp)
   1ba14:	e17ffe15 	stw	r5,-8(fp)
   1ba18:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
   1ba1c:	00bff9c4 	movi	r2,-25
   1ba20:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
   1ba24:	e0bffe17 	ldw	r2,-8(fp)
   1ba28:	10da8060 	cmpeqi	r3,r2,27137
   1ba2c:	1800031e 	bne	r3,zero,1ba3c <altera_avalon_jtag_uart_ioctl+0x38>
   1ba30:	109a80a0 	cmpeqi	r2,r2,27138
   1ba34:	1000181e 	bne	r2,zero,1ba98 <altera_avalon_jtag_uart_ioctl+0x94>
   1ba38:	00002606 	br	1bad4 <altera_avalon_jtag_uart_ioctl+0xd0>
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
   1ba3c:	e0bffd17 	ldw	r2,-12(fp)
   1ba40:	10c00117 	ldw	r3,4(r2)
   1ba44:	00a00034 	movhi	r2,32768
   1ba48:	10bfffc4 	addi	r2,r2,-1
   1ba4c:	18802226 	beq	r3,r2,1bad8 <altera_avalon_jtag_uart_ioctl+0xd4>
    {
      int timeout = *((int *)arg);
   1ba50:	e0bfff17 	ldw	r2,-4(fp)
   1ba54:	10800017 	ldw	r2,0(r2)
   1ba58:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
   1ba5c:	e0bffc17 	ldw	r2,-16(fp)
   1ba60:	10800090 	cmplti	r2,r2,2
   1ba64:	1000061e 	bne	r2,zero,1ba80 <altera_avalon_jtag_uart_ioctl+0x7c>
   1ba68:	e0fffc17 	ldw	r3,-16(fp)
   1ba6c:	00a00034 	movhi	r2,32768
   1ba70:	10bfffc4 	addi	r2,r2,-1
   1ba74:	18800226 	beq	r3,r2,1ba80 <altera_avalon_jtag_uart_ioctl+0x7c>
   1ba78:	e0bffc17 	ldw	r2,-16(fp)
   1ba7c:	00000206 	br	1ba88 <altera_avalon_jtag_uart_ioctl+0x84>
   1ba80:	00a00034 	movhi	r2,32768
   1ba84:	10bfff84 	addi	r2,r2,-2
   1ba88:	e0fffd17 	ldw	r3,-12(fp)
   1ba8c:	18800115 	stw	r2,4(r3)
      rc = 0;
   1ba90:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
   1ba94:	00001006 	br	1bad8 <altera_avalon_jtag_uart_ioctl+0xd4>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
   1ba98:	e0bffd17 	ldw	r2,-12(fp)
   1ba9c:	10c00117 	ldw	r3,4(r2)
   1baa0:	00a00034 	movhi	r2,32768
   1baa4:	10bfffc4 	addi	r2,r2,-1
   1baa8:	18800d26 	beq	r3,r2,1bae0 <altera_avalon_jtag_uart_ioctl+0xdc>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
   1baac:	e0bffd17 	ldw	r2,-12(fp)
   1bab0:	10c00917 	ldw	r3,36(r2)
   1bab4:	e0bffd17 	ldw	r2,-12(fp)
   1bab8:	10800117 	ldw	r2,4(r2)
   1babc:	1885803a 	cmpltu	r2,r3,r2
   1bac0:	10c03fcc 	andi	r3,r2,255
   1bac4:	e0bfff17 	ldw	r2,-4(fp)
   1bac8:	10c00015 	stw	r3,0(r2)
      rc = 0;
   1bacc:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
   1bad0:	00000306 	br	1bae0 <altera_avalon_jtag_uart_ioctl+0xdc>

  default:
    break;
   1bad4:	00000306 	br	1bae4 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
   1bad8:	0001883a 	nop
   1badc:	00000106 	br	1bae4 <altera_avalon_jtag_uart_ioctl+0xe0>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
   1bae0:	0001883a 	nop

  default:
    break;
  }

  return rc;
   1bae4:	e0bffb17 	ldw	r2,-20(fp)
}
   1bae8:	e037883a 	mov	sp,fp
   1baec:	df000017 	ldw	fp,0(sp)
   1baf0:	dec00104 	addi	sp,sp,4
   1baf4:	f800283a 	ret

0001baf8 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
   1baf8:	defff204 	addi	sp,sp,-56
   1bafc:	dfc00d15 	stw	ra,52(sp)
   1bb00:	df000c15 	stw	fp,48(sp)
   1bb04:	df000c04 	addi	fp,sp,48
   1bb08:	e13ffc15 	stw	r4,-16(fp)
   1bb0c:	e17ffd15 	stw	r5,-12(fp)
   1bb10:	e1bffe15 	stw	r6,-8(fp)
   1bb14:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
   1bb18:	e0bffd17 	ldw	r2,-12(fp)
   1bb1c:	e0bff415 	stw	r2,-48(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
   1bb20:	00004706 	br	1bc40 <altera_avalon_jtag_uart_read+0x148>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
   1bb24:	e0bffc17 	ldw	r2,-16(fp)
   1bb28:	10800a17 	ldw	r2,40(r2)
   1bb2c:	e0bff615 	stw	r2,-40(fp)
      out = sp->rx_out;
   1bb30:	e0bffc17 	ldw	r2,-16(fp)
   1bb34:	10800b17 	ldw	r2,44(r2)
   1bb38:	e0bff715 	stw	r2,-36(fp)

      if (in >= out)
   1bb3c:	e0fff617 	ldw	r3,-40(fp)
   1bb40:	e0bff717 	ldw	r2,-36(fp)
   1bb44:	18800536 	bltu	r3,r2,1bb5c <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
   1bb48:	e0fff617 	ldw	r3,-40(fp)
   1bb4c:	e0bff717 	ldw	r2,-36(fp)
   1bb50:	1885c83a 	sub	r2,r3,r2
   1bb54:	e0bff515 	stw	r2,-44(fp)
   1bb58:	00000406 	br	1bb6c <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
   1bb5c:	00c20004 	movi	r3,2048
   1bb60:	e0bff717 	ldw	r2,-36(fp)
   1bb64:	1885c83a 	sub	r2,r3,r2
   1bb68:	e0bff515 	stw	r2,-44(fp)

      if (n == 0)
   1bb6c:	e0bff517 	ldw	r2,-44(fp)
   1bb70:	10001e26 	beq	r2,zero,1bbec <altera_avalon_jtag_uart_read+0xf4>
        break; /* No more data available */

      if (n > space)
   1bb74:	e0fffe17 	ldw	r3,-8(fp)
   1bb78:	e0bff517 	ldw	r2,-44(fp)
   1bb7c:	1880022e 	bgeu	r3,r2,1bb88 <altera_avalon_jtag_uart_read+0x90>
        n = space;
   1bb80:	e0bffe17 	ldw	r2,-8(fp)
   1bb84:	e0bff515 	stw	r2,-44(fp)

      memcpy(ptr, sp->rx_buf + out, n);
   1bb88:	e0bff717 	ldw	r2,-36(fp)
   1bb8c:	10800e04 	addi	r2,r2,56
   1bb90:	e0fffc17 	ldw	r3,-16(fp)
   1bb94:	1885883a 	add	r2,r3,r2
   1bb98:	e13ff417 	ldw	r4,-48(fp)
   1bb9c:	100b883a 	mov	r5,r2
   1bba0:	e1bff517 	ldw	r6,-44(fp)
   1bba4:	00102380 	call	10238 <memcpy>
      ptr   += n;
   1bba8:	e0fff417 	ldw	r3,-48(fp)
   1bbac:	e0bff517 	ldw	r2,-44(fp)
   1bbb0:	1885883a 	add	r2,r3,r2
   1bbb4:	e0bff415 	stw	r2,-48(fp)
      space -= n;
   1bbb8:	e0fffe17 	ldw	r3,-8(fp)
   1bbbc:	e0bff517 	ldw	r2,-44(fp)
   1bbc0:	1885c83a 	sub	r2,r3,r2
   1bbc4:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   1bbc8:	e0fff717 	ldw	r3,-36(fp)
   1bbcc:	e0bff517 	ldw	r2,-44(fp)
   1bbd0:	1885883a 	add	r2,r3,r2
   1bbd4:	10c1ffcc 	andi	r3,r2,2047
   1bbd8:	e0bffc17 	ldw	r2,-16(fp)
   1bbdc:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
   1bbe0:	e0bffe17 	ldw	r2,-8(fp)
   1bbe4:	00bfcf16 	blt	zero,r2,1bb24 <altera_avalon_jtag_uart_read+0x2c>
   1bbe8:	00000106 	br	1bbf0 <altera_avalon_jtag_uart_read+0xf8>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
   1bbec:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
   1bbf0:	e0fff417 	ldw	r3,-48(fp)
   1bbf4:	e0bffd17 	ldw	r2,-12(fp)
   1bbf8:	1880141e 	bne	r3,r2,1bc4c <altera_avalon_jtag_uart_read+0x154>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
   1bbfc:	e0bfff17 	ldw	r2,-4(fp)
   1bc00:	1090000c 	andi	r2,r2,16384
   1bc04:	1000131e 	bne	r2,zero,1bc54 <altera_avalon_jtag_uart_read+0x15c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
   1bc08:	0001883a 	nop
   1bc0c:	e0bffc17 	ldw	r2,-16(fp)
   1bc10:	10c00a17 	ldw	r3,40(r2)
   1bc14:	e0bff617 	ldw	r2,-40(fp)
   1bc18:	1880051e 	bne	r3,r2,1bc30 <altera_avalon_jtag_uart_read+0x138>
   1bc1c:	e0bffc17 	ldw	r2,-16(fp)
   1bc20:	10c00917 	ldw	r3,36(r2)
   1bc24:	e0bffc17 	ldw	r2,-16(fp)
   1bc28:	10800117 	ldw	r2,4(r2)
   1bc2c:	18bff736 	bltu	r3,r2,1bc0c <altera_avalon_jtag_uart_read+0x114>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
   1bc30:	e0bffc17 	ldw	r2,-16(fp)
   1bc34:	10c00a17 	ldw	r3,40(r2)
   1bc38:	e0bff617 	ldw	r2,-40(fp)
   1bc3c:	18800726 	beq	r3,r2,1bc5c <altera_avalon_jtag_uart_read+0x164>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
   1bc40:	e0bffe17 	ldw	r2,-8(fp)
   1bc44:	00bfb716 	blt	zero,r2,1bb24 <altera_avalon_jtag_uart_read+0x2c>
   1bc48:	00000506 	br	1bc60 <altera_avalon_jtag_uart_read+0x168>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
   1bc4c:	0001883a 	nop
   1bc50:	00000306 	br	1bc60 <altera_avalon_jtag_uart_read+0x168>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
   1bc54:	0001883a 	nop
   1bc58:	00000106 	br	1bc60 <altera_avalon_jtag_uart_read+0x168>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
   1bc5c:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
   1bc60:	e0fff417 	ldw	r3,-48(fp)
   1bc64:	e0bffd17 	ldw	r2,-12(fp)
   1bc68:	18802226 	beq	r3,r2,1bcf4 <altera_avalon_jtag_uart_read+0x1fc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   1bc6c:	0005303a 	rdctl	r2,status
   1bc70:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   1bc74:	e0fff917 	ldw	r3,-28(fp)
   1bc78:	00bfff84 	movi	r2,-2
   1bc7c:	1884703a 	and	r2,r3,r2
   1bc80:	1001703a 	wrctl	status,r2
  
  return context;
   1bc84:	e0bff917 	ldw	r2,-28(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
   1bc88:	e0bff815 	stw	r2,-32(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
   1bc8c:	e0bffc17 	ldw	r2,-16(fp)
   1bc90:	10800817 	ldw	r2,32(r2)
   1bc94:	10c00054 	ori	r3,r2,1
   1bc98:	e0bffc17 	ldw	r2,-16(fp)
   1bc9c:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
   1bca0:	e0bffc17 	ldw	r2,-16(fp)
   1bca4:	10800017 	ldw	r2,0(r2)
   1bca8:	10800104 	addi	r2,r2,4
   1bcac:	e0fffc17 	ldw	r3,-16(fp)
   1bcb0:	18c00817 	ldw	r3,32(r3)
   1bcb4:	10c00035 	stwio	r3,0(r2)
   1bcb8:	e0bff817 	ldw	r2,-32(fp)
   1bcbc:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   1bcc0:	0005303a 	rdctl	r2,status
   1bcc4:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   1bcc8:	e0fffb17 	ldw	r3,-20(fp)
   1bccc:	00bfff84 	movi	r2,-2
   1bcd0:	1884703a 	and	r2,r3,r2
   1bcd4:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   1bcd8:	e0bffa17 	ldw	r2,-24(fp)
   1bcdc:	1080004c 	andi	r2,r2,1
   1bce0:	e0fffb17 	ldw	r3,-20(fp)
   1bce4:	1884b03a 	or	r2,r3,r2
   1bce8:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
   1bcec:	e0bffb17 	ldw	r2,-20(fp)
   1bcf0:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
   1bcf4:	e0fff417 	ldw	r3,-48(fp)
   1bcf8:	e0bffd17 	ldw	r2,-12(fp)
   1bcfc:	18800426 	beq	r3,r2,1bd10 <altera_avalon_jtag_uart_read+0x218>
    return ptr - buffer;
   1bd00:	e0fff417 	ldw	r3,-48(fp)
   1bd04:	e0bffd17 	ldw	r2,-12(fp)
   1bd08:	1885c83a 	sub	r2,r3,r2
   1bd0c:	00000606 	br	1bd28 <altera_avalon_jtag_uart_read+0x230>
  else if (flags & O_NONBLOCK)
   1bd10:	e0bfff17 	ldw	r2,-4(fp)
   1bd14:	1090000c 	andi	r2,r2,16384
   1bd18:	10000226 	beq	r2,zero,1bd24 <altera_avalon_jtag_uart_read+0x22c>
    return -EWOULDBLOCK;
   1bd1c:	00bffd44 	movi	r2,-11
   1bd20:	00000106 	br	1bd28 <altera_avalon_jtag_uart_read+0x230>
  else
    return -EIO;
   1bd24:	00bffec4 	movi	r2,-5
}
   1bd28:	e037883a 	mov	sp,fp
   1bd2c:	dfc00117 	ldw	ra,4(sp)
   1bd30:	df000017 	ldw	fp,0(sp)
   1bd34:	dec00204 	addi	sp,sp,8
   1bd38:	f800283a 	ret

0001bd3c <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
   1bd3c:	defff204 	addi	sp,sp,-56
   1bd40:	dfc00d15 	stw	ra,52(sp)
   1bd44:	df000c15 	stw	fp,48(sp)
   1bd48:	df000c04 	addi	fp,sp,48
   1bd4c:	e13ffc15 	stw	r4,-16(fp)
   1bd50:	e17ffd15 	stw	r5,-12(fp)
   1bd54:	e1bffe15 	stw	r6,-8(fp)
   1bd58:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
   1bd5c:	e03ff415 	stw	zero,-48(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
   1bd60:	e0bffd17 	ldw	r2,-12(fp)
   1bd64:	e0bff615 	stw	r2,-40(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
   1bd68:	00003706 	br	1be48 <altera_avalon_jtag_uart_write+0x10c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
   1bd6c:	e0bffc17 	ldw	r2,-16(fp)
   1bd70:	10800c17 	ldw	r2,48(r2)
   1bd74:	e0bff715 	stw	r2,-36(fp)
      out = sp->tx_out;
   1bd78:	e0bffc17 	ldw	r2,-16(fp)
   1bd7c:	10800d17 	ldw	r2,52(r2)
   1bd80:	e0bff415 	stw	r2,-48(fp)

      if (in < out)
   1bd84:	e0fff717 	ldw	r3,-36(fp)
   1bd88:	e0bff417 	ldw	r2,-48(fp)
   1bd8c:	1880062e 	bgeu	r3,r2,1bda8 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
   1bd90:	e0fff417 	ldw	r3,-48(fp)
   1bd94:	e0bff717 	ldw	r2,-36(fp)
   1bd98:	1885c83a 	sub	r2,r3,r2
   1bd9c:	10bfffc4 	addi	r2,r2,-1
   1bda0:	e0bff515 	stw	r2,-44(fp)
   1bda4:	00000b06 	br	1bdd4 <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
   1bda8:	e0bff417 	ldw	r2,-48(fp)
   1bdac:	10000526 	beq	r2,zero,1bdc4 <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
   1bdb0:	00c20004 	movi	r3,2048
   1bdb4:	e0bff717 	ldw	r2,-36(fp)
   1bdb8:	1885c83a 	sub	r2,r3,r2
   1bdbc:	e0bff515 	stw	r2,-44(fp)
   1bdc0:	00000406 	br	1bdd4 <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
   1bdc4:	00c1ffc4 	movi	r3,2047
   1bdc8:	e0bff717 	ldw	r2,-36(fp)
   1bdcc:	1885c83a 	sub	r2,r3,r2
   1bdd0:	e0bff515 	stw	r2,-44(fp)

      if (n == 0)
   1bdd4:	e0bff517 	ldw	r2,-44(fp)
   1bdd8:	10001e26 	beq	r2,zero,1be54 <altera_avalon_jtag_uart_write+0x118>
        break;

      if (n > count)
   1bddc:	e0fffe17 	ldw	r3,-8(fp)
   1bde0:	e0bff517 	ldw	r2,-44(fp)
   1bde4:	1880022e 	bgeu	r3,r2,1bdf0 <altera_avalon_jtag_uart_write+0xb4>
        n = count;
   1bde8:	e0bffe17 	ldw	r2,-8(fp)
   1bdec:	e0bff515 	stw	r2,-44(fp)

      memcpy(sp->tx_buf + in, ptr, n);
   1bdf0:	e0bff717 	ldw	r2,-36(fp)
   1bdf4:	10820e04 	addi	r2,r2,2104
   1bdf8:	e0fffc17 	ldw	r3,-16(fp)
   1bdfc:	1885883a 	add	r2,r3,r2
   1be00:	1009883a 	mov	r4,r2
   1be04:	e17ffd17 	ldw	r5,-12(fp)
   1be08:	e1bff517 	ldw	r6,-44(fp)
   1be0c:	00102380 	call	10238 <memcpy>
      ptr   += n;
   1be10:	e0fffd17 	ldw	r3,-12(fp)
   1be14:	e0bff517 	ldw	r2,-44(fp)
   1be18:	1885883a 	add	r2,r3,r2
   1be1c:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
   1be20:	e0fffe17 	ldw	r3,-8(fp)
   1be24:	e0bff517 	ldw	r2,-44(fp)
   1be28:	1885c83a 	sub	r2,r3,r2
   1be2c:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   1be30:	e0fff717 	ldw	r3,-36(fp)
   1be34:	e0bff517 	ldw	r2,-44(fp)
   1be38:	1885883a 	add	r2,r3,r2
   1be3c:	10c1ffcc 	andi	r3,r2,2047
   1be40:	e0bffc17 	ldw	r2,-16(fp)
   1be44:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
   1be48:	e0bffe17 	ldw	r2,-8(fp)
   1be4c:	00bfc716 	blt	zero,r2,1bd6c <altera_avalon_jtag_uart_write+0x30>
   1be50:	00000106 	br	1be58 <altera_avalon_jtag_uart_write+0x11c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
   1be54:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   1be58:	0005303a 	rdctl	r2,status
   1be5c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   1be60:	e0fff917 	ldw	r3,-28(fp)
   1be64:	00bfff84 	movi	r2,-2
   1be68:	1884703a 	and	r2,r3,r2
   1be6c:	1001703a 	wrctl	status,r2
  
  return context;
   1be70:	e0bff917 	ldw	r2,-28(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
   1be74:	e0bff815 	stw	r2,-32(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
   1be78:	e0bffc17 	ldw	r2,-16(fp)
   1be7c:	10800817 	ldw	r2,32(r2)
   1be80:	10c00094 	ori	r3,r2,2
   1be84:	e0bffc17 	ldw	r2,-16(fp)
   1be88:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
   1be8c:	e0bffc17 	ldw	r2,-16(fp)
   1be90:	10800017 	ldw	r2,0(r2)
   1be94:	10800104 	addi	r2,r2,4
   1be98:	e0fffc17 	ldw	r3,-16(fp)
   1be9c:	18c00817 	ldw	r3,32(r3)
   1bea0:	10c00035 	stwio	r3,0(r2)
   1bea4:	e0bff817 	ldw	r2,-32(fp)
   1bea8:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   1beac:	0005303a 	rdctl	r2,status
   1beb0:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   1beb4:	e0fffb17 	ldw	r3,-20(fp)
   1beb8:	00bfff84 	movi	r2,-2
   1bebc:	1884703a 	and	r2,r3,r2
   1bec0:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   1bec4:	e0bffa17 	ldw	r2,-24(fp)
   1bec8:	1080004c 	andi	r2,r2,1
   1becc:	e0fffb17 	ldw	r3,-20(fp)
   1bed0:	1884b03a 	or	r2,r3,r2
   1bed4:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
   1bed8:	e0bffb17 	ldw	r2,-20(fp)
   1bedc:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
   1bee0:	e0bffe17 	ldw	r2,-8(fp)
   1bee4:	0080110e 	bge	zero,r2,1bf2c <altera_avalon_jtag_uart_write+0x1f0>
    {
      if (flags & O_NONBLOCK)
   1bee8:	e0bfff17 	ldw	r2,-4(fp)
   1beec:	1090000c 	andi	r2,r2,16384
   1bef0:	1000111e 	bne	r2,zero,1bf38 <altera_avalon_jtag_uart_write+0x1fc>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
   1bef4:	0001883a 	nop
   1bef8:	e0bffc17 	ldw	r2,-16(fp)
   1befc:	10c00d17 	ldw	r3,52(r2)
   1bf00:	e0bff417 	ldw	r2,-48(fp)
   1bf04:	1880051e 	bne	r3,r2,1bf1c <altera_avalon_jtag_uart_write+0x1e0>
   1bf08:	e0bffc17 	ldw	r2,-16(fp)
   1bf0c:	10c00917 	ldw	r3,36(r2)
   1bf10:	e0bffc17 	ldw	r2,-16(fp)
   1bf14:	10800117 	ldw	r2,4(r2)
   1bf18:	18bff736 	bltu	r3,r2,1bef8 <altera_avalon_jtag_uart_write+0x1bc>
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
   1bf1c:	e0bffc17 	ldw	r2,-16(fp)
   1bf20:	10c00d17 	ldw	r3,52(r2)
   1bf24:	e0bff417 	ldw	r2,-48(fp)
   1bf28:	18800526 	beq	r3,r2,1bf40 <altera_avalon_jtag_uart_write+0x204>
         break;
    }
  }
  while (count > 0);
   1bf2c:	e0bffe17 	ldw	r2,-8(fp)
   1bf30:	00bfc516 	blt	zero,r2,1be48 <altera_avalon_jtag_uart_write+0x10c>
   1bf34:	00000306 	br	1bf44 <altera_avalon_jtag_uart_write+0x208>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
   1bf38:	0001883a 	nop
   1bf3c:	00000106 	br	1bf44 <altera_avalon_jtag_uart_write+0x208>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
         break;
   1bf40:	0001883a 	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
   1bf44:	e0fffd17 	ldw	r3,-12(fp)
   1bf48:	e0bff617 	ldw	r2,-40(fp)
   1bf4c:	18800426 	beq	r3,r2,1bf60 <altera_avalon_jtag_uart_write+0x224>
    return ptr - start;
   1bf50:	e0fffd17 	ldw	r3,-12(fp)
   1bf54:	e0bff617 	ldw	r2,-40(fp)
   1bf58:	1885c83a 	sub	r2,r3,r2
   1bf5c:	00000606 	br	1bf78 <altera_avalon_jtag_uart_write+0x23c>
  else if (flags & O_NONBLOCK)
   1bf60:	e0bfff17 	ldw	r2,-4(fp)
   1bf64:	1090000c 	andi	r2,r2,16384
   1bf68:	10000226 	beq	r2,zero,1bf74 <altera_avalon_jtag_uart_write+0x238>
    return -EWOULDBLOCK;
   1bf6c:	00bffd44 	movi	r2,-11
   1bf70:	00000106 	br	1bf78 <altera_avalon_jtag_uart_write+0x23c>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
   1bf74:	00bffec4 	movi	r2,-5
}
   1bf78:	e037883a 	mov	sp,fp
   1bf7c:	dfc00117 	ldw	ra,4(sp)
   1bf80:	df000017 	ldw	fp,0(sp)
   1bf84:	dec00204 	addi	sp,sp,8
   1bf88:	f800283a 	ret

0001bf8c <lcd_write_command>:

/* --------------------------------------------------------------------- */

static void lcd_write_command(altera_avalon_lcd_16207_state* sp, 
  unsigned char command)
{
   1bf8c:	defffa04 	addi	sp,sp,-24
   1bf90:	dfc00515 	stw	ra,20(sp)
   1bf94:	df000415 	stw	fp,16(sp)
   1bf98:	df000404 	addi	fp,sp,16
   1bf9c:	e13ffe15 	stw	r4,-8(fp)
   1bfa0:	2805883a 	mov	r2,r5
   1bfa4:	e0bfff05 	stb	r2,-4(fp)
  unsigned int base = sp->base;
   1bfa8:	e0bffe17 	ldw	r2,-8(fp)
   1bfac:	10800017 	ldw	r2,0(r2)
   1bfb0:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
   1bfb4:	008003f4 	movhi	r2,15
   1bfb8:	10909004 	addi	r2,r2,16960
   1bfbc:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
   1bfc0:	e0bffe17 	ldw	r2,-8(fp)
   1bfc4:	10800803 	ldbu	r2,32(r2)
   1bfc8:	10803fcc 	andi	r2,r2,255
   1bfcc:	1080201c 	xori	r2,r2,128
   1bfd0:	10bfe004 	addi	r2,r2,-128
   1bfd4:	10000a26 	beq	r2,zero,1c000 <lcd_write_command+0x74>
    return;
   1bfd8:	00001406 	br	1c02c <lcd_write_command+0xa0>

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
    if (--i == 0)
   1bfdc:	e0bffc17 	ldw	r2,-16(fp)
   1bfe0:	10bfffc4 	addi	r2,r2,-1
   1bfe4:	e0bffc15 	stw	r2,-16(fp)
   1bfe8:	e0bffc17 	ldw	r2,-16(fp)
   1bfec:	1000051e 	bne	r2,zero,1c004 <lcd_write_command+0x78>
    {
      sp->broken = 1;
   1bff0:	e0bffe17 	ldw	r2,-8(fp)
   1bff4:	00c00044 	movi	r3,1
   1bff8:	10c00805 	stb	r3,32(r2)
      return;
   1bffc:	00000b06 	br	1c02c <lcd_write_command+0xa0>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
   1c000:	0001883a 	nop
   1c004:	e0bffd17 	ldw	r2,-12(fp)
   1c008:	10800104 	addi	r2,r2,4
   1c00c:	10800037 	ldwio	r2,0(r2)
   1c010:	1080200c 	andi	r2,r2,128
   1c014:	103ff11e 	bne	r2,zero,1bfdc <lcd_write_command+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
   1c018:	01001904 	movi	r4,100
   1c01c:	00194f00 	call	194f0 <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, command);
   1c020:	e0bffd17 	ldw	r2,-12(fp)
   1c024:	e0ffff03 	ldbu	r3,-4(fp)
   1c028:	10c00035 	stwio	r3,0(r2)
}
   1c02c:	e037883a 	mov	sp,fp
   1c030:	dfc00117 	ldw	ra,4(sp)
   1c034:	df000017 	ldw	fp,0(sp)
   1c038:	dec00204 	addi	sp,sp,8
   1c03c:	f800283a 	ret

0001c040 <lcd_write_data>:

/* --------------------------------------------------------------------- */

static void lcd_write_data(altera_avalon_lcd_16207_state* sp, 
  unsigned char data)
{
   1c040:	defffa04 	addi	sp,sp,-24
   1c044:	dfc00515 	stw	ra,20(sp)
   1c048:	df000415 	stw	fp,16(sp)
   1c04c:	df000404 	addi	fp,sp,16
   1c050:	e13ffe15 	stw	r4,-8(fp)
   1c054:	2805883a 	mov	r2,r5
   1c058:	e0bfff05 	stb	r2,-4(fp)
  unsigned int base = sp->base;
   1c05c:	e0bffe17 	ldw	r2,-8(fp)
   1c060:	10800017 	ldw	r2,0(r2)
   1c064:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
   1c068:	008003f4 	movhi	r2,15
   1c06c:	10909004 	addi	r2,r2,16960
   1c070:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
   1c074:	e0bffe17 	ldw	r2,-8(fp)
   1c078:	10800803 	ldbu	r2,32(r2)
   1c07c:	10803fcc 	andi	r2,r2,255
   1c080:	1080201c 	xori	r2,r2,128
   1c084:	10bfe004 	addi	r2,r2,-128
   1c088:	10000a26 	beq	r2,zero,1c0b4 <lcd_write_data+0x74>
    return;
   1c08c:	00001b06 	br	1c0fc <lcd_write_data+0xbc>

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
    if (--i == 0)
   1c090:	e0bffc17 	ldw	r2,-16(fp)
   1c094:	10bfffc4 	addi	r2,r2,-1
   1c098:	e0bffc15 	stw	r2,-16(fp)
   1c09c:	e0bffc17 	ldw	r2,-16(fp)
   1c0a0:	1000051e 	bne	r2,zero,1c0b8 <lcd_write_data+0x78>
    {
      sp->broken = 1;
   1c0a4:	e0bffe17 	ldw	r2,-8(fp)
   1c0a8:	00c00044 	movi	r3,1
   1c0ac:	10c00805 	stb	r3,32(r2)
      return;
   1c0b0:	00001206 	br	1c0fc <lcd_write_data+0xbc>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
   1c0b4:	0001883a 	nop
   1c0b8:	e0bffd17 	ldw	r2,-12(fp)
   1c0bc:	10800104 	addi	r2,r2,4
   1c0c0:	10800037 	ldwio	r2,0(r2)
   1c0c4:	1080200c 	andi	r2,r2,128
   1c0c8:	103ff11e 	bne	r2,zero,1c090 <lcd_write_data+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
   1c0cc:	01001904 	movi	r4,100
   1c0d0:	00194f00 	call	194f0 <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_DATA(base, data);
   1c0d4:	e0bffd17 	ldw	r2,-12(fp)
   1c0d8:	10800204 	addi	r2,r2,8
   1c0dc:	e0ffff03 	ldbu	r3,-4(fp)
   1c0e0:	10c00035 	stwio	r3,0(r2)

  sp->address++;
   1c0e4:	e0bffe17 	ldw	r2,-8(fp)
   1c0e8:	108008c3 	ldbu	r2,35(r2)
   1c0ec:	10800044 	addi	r2,r2,1
   1c0f0:	1007883a 	mov	r3,r2
   1c0f4:	e0bffe17 	ldw	r2,-8(fp)
   1c0f8:	10c008c5 	stb	r3,35(r2)
}
   1c0fc:	e037883a 	mov	sp,fp
   1c100:	dfc00117 	ldw	ra,4(sp)
   1c104:	df000017 	ldw	fp,0(sp)
   1c108:	dec00204 	addi	sp,sp,8
   1c10c:	f800283a 	ret

0001c110 <lcd_clear_screen>:

/* --------------------------------------------------------------------- */

static void lcd_clear_screen(altera_avalon_lcd_16207_state* sp)
{
   1c110:	defffc04 	addi	sp,sp,-16
   1c114:	dfc00315 	stw	ra,12(sp)
   1c118:	df000215 	stw	fp,8(sp)
   1c11c:	df000204 	addi	fp,sp,8
   1c120:	e13fff15 	stw	r4,-4(fp)
  int y;

  lcd_write_command(sp, LCD_CMD_CLEAR);
   1c124:	e13fff17 	ldw	r4,-4(fp)
   1c128:	01400044 	movi	r5,1
   1c12c:	001bf8c0 	call	1bf8c <lcd_write_command>

  sp->x = 0;
   1c130:	e0bfff17 	ldw	r2,-4(fp)
   1c134:	10000845 	stb	zero,33(r2)
  sp->y = 0;
   1c138:	e0bfff17 	ldw	r2,-4(fp)
   1c13c:	10000885 	stb	zero,34(r2)
  sp->address = 0;
   1c140:	e0bfff17 	ldw	r2,-4(fp)
   1c144:	100008c5 	stb	zero,35(r2)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   1c148:	e03ffe15 	stw	zero,-8(fp)
   1c14c:	00001b06 	br	1c1bc <lcd_clear_screen+0xac>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
   1c150:	e0bffe17 	ldw	r2,-8(fp)
   1c154:	108018e4 	muli	r2,r2,99
   1c158:	10801004 	addi	r2,r2,64
   1c15c:	e0ffff17 	ldw	r3,-4(fp)
   1c160:	1885883a 	add	r2,r3,r2
   1c164:	1009883a 	mov	r4,r2
   1c168:	01400804 	movi	r5,32
   1c16c:	01801444 	movi	r6,81
   1c170:	00103300 	call	10330 <memset>
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
   1c174:	e0bffe17 	ldw	r2,-8(fp)
   1c178:	108018e4 	muli	r2,r2,99
   1c17c:	10800c04 	addi	r2,r2,48
   1c180:	e0ffff17 	ldw	r3,-4(fp)
   1c184:	1885883a 	add	r2,r3,r2
   1c188:	1009883a 	mov	r4,r2
   1c18c:	01400804 	movi	r5,32
   1c190:	01800404 	movi	r6,16
   1c194:	00103300 	call	10330 <memset>
    sp->line[y].width = 0;
   1c198:	e0ffff17 	ldw	r3,-4(fp)
   1c19c:	e0bffe17 	ldw	r2,-8(fp)
   1c1a0:	108018e4 	muli	r2,r2,99
   1c1a4:	1885883a 	add	r2,r3,r2
   1c1a8:	10802404 	addi	r2,r2,144
   1c1ac:	10000045 	stb	zero,1(r2)

  sp->x = 0;
  sp->y = 0;
  sp->address = 0;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   1c1b0:	e0bffe17 	ldw	r2,-8(fp)
   1c1b4:	10800044 	addi	r2,r2,1
   1c1b8:	e0bffe15 	stw	r2,-8(fp)
   1c1bc:	e0bffe17 	ldw	r2,-8(fp)
   1c1c0:	10800090 	cmplti	r2,r2,2
   1c1c4:	103fe21e 	bne	r2,zero,1c150 <lcd_clear_screen+0x40>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
    sp->line[y].width = 0;
  }
}
   1c1c8:	e037883a 	mov	sp,fp
   1c1cc:	dfc00117 	ldw	ra,4(sp)
   1c1d0:	df000017 	ldw	fp,0(sp)
   1c1d4:	dec00204 	addi	sp,sp,8
   1c1d8:	f800283a 	ret

0001c1dc <lcd_repaint_screen>:

/* --------------------------------------------------------------------- */

static void lcd_repaint_screen(altera_avalon_lcd_16207_state* sp)
{
   1c1dc:	defff704 	addi	sp,sp,-36
   1c1e0:	dfc00815 	stw	ra,32(sp)
   1c1e4:	df000715 	stw	fp,28(sp)
   1c1e8:	df000704 	addi	fp,sp,28
   1c1ec:	e13fff15 	stw	r4,-4(fp)
  /* scrollpos controls how much the lines have scrolled round.  The speed
   * each line scrolls at is controlled by its speed variable - while
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;
   1c1f0:	e0bfff17 	ldw	r2,-4(fp)
   1c1f4:	10800943 	ldbu	r2,37(r2)
   1c1f8:	10803fcc 	andi	r2,r2,255
   1c1fc:	e0bffc15 	stw	r2,-16(fp)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   1c200:	e03ff915 	stw	zero,-28(fp)
   1c204:	00006806 	br	1c3a8 <lcd_repaint_screen+0x1cc>
  {
    int width  = sp->line[y].width;
   1c208:	e0ffff17 	ldw	r3,-4(fp)
   1c20c:	e0bff917 	ldw	r2,-28(fp)
   1c210:	108018e4 	muli	r2,r2,99
   1c214:	1885883a 	add	r2,r3,r2
   1c218:	10802404 	addi	r2,r2,144
   1c21c:	10800043 	ldbu	r2,1(r2)
   1c220:	10803fcc 	andi	r2,r2,255
   1c224:	1080201c 	xori	r2,r2,128
   1c228:	10bfe004 	addi	r2,r2,-128
   1c22c:	e0bffd15 	stw	r2,-12(fp)
    int offset = (scrollpos * sp->line[y].speed) >> 8;
   1c230:	e0ffff17 	ldw	r3,-4(fp)
   1c234:	e0bff917 	ldw	r2,-28(fp)
   1c238:	108018e4 	muli	r2,r2,99
   1c23c:	1885883a 	add	r2,r3,r2
   1c240:	10802404 	addi	r2,r2,144
   1c244:	10800083 	ldbu	r2,2(r2)
   1c248:	10c03fcc 	andi	r3,r2,255
   1c24c:	e0bffc17 	ldw	r2,-16(fp)
   1c250:	1885383a 	mul	r2,r3,r2
   1c254:	1005d23a 	srai	r2,r2,8
   1c258:	e0bffb15 	stw	r2,-20(fp)
    if (offset >= width)
   1c25c:	e0fffb17 	ldw	r3,-20(fp)
   1c260:	e0bffd17 	ldw	r2,-12(fp)
   1c264:	18800116 	blt	r3,r2,1c26c <lcd_repaint_screen+0x90>
      offset = 0;
   1c268:	e03ffb15 	stw	zero,-20(fp)

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
   1c26c:	e03ffa15 	stw	zero,-24(fp)
   1c270:	00004706 	br	1c390 <lcd_repaint_screen+0x1b4>
    {
      char c = sp->line[y].data[(x + offset) % width];
   1c274:	e0fffa17 	ldw	r3,-24(fp)
   1c278:	e0bffb17 	ldw	r2,-20(fp)
   1c27c:	1885883a 	add	r2,r3,r2
   1c280:	e0fffd17 	ldw	r3,-12(fp)
   1c284:	10c9283a 	div	r4,r2,r3
   1c288:	e0fffd17 	ldw	r3,-12(fp)
   1c28c:	20c7383a 	mul	r3,r4,r3
   1c290:	10c5c83a 	sub	r2,r2,r3
   1c294:	e13fff17 	ldw	r4,-4(fp)
   1c298:	e0fff917 	ldw	r3,-28(fp)
   1c29c:	18c018e4 	muli	r3,r3,99
   1c2a0:	20c7883a 	add	r3,r4,r3
   1c2a4:	1885883a 	add	r2,r3,r2
   1c2a8:	10801004 	addi	r2,r2,64
   1c2ac:	10800003 	ldbu	r2,0(r2)
   1c2b0:	e0bffe05 	stb	r2,-8(fp)

      /* Writing data takes 40us, so don't do it unless required */
      if (sp->line[y].visible[x] != c)
   1c2b4:	e0ffff17 	ldw	r3,-4(fp)
   1c2b8:	e0bff917 	ldw	r2,-28(fp)
   1c2bc:	108018e4 	muli	r2,r2,99
   1c2c0:	1887883a 	add	r3,r3,r2
   1c2c4:	e0bffa17 	ldw	r2,-24(fp)
   1c2c8:	1885883a 	add	r2,r3,r2
   1c2cc:	10800c04 	addi	r2,r2,48
   1c2d0:	10800003 	ldbu	r2,0(r2)
   1c2d4:	10c03fcc 	andi	r3,r2,255
   1c2d8:	18c0201c 	xori	r3,r3,128
   1c2dc:	18ffe004 	addi	r3,r3,-128
   1c2e0:	e0bffe07 	ldb	r2,-8(fp)
   1c2e4:	18802726 	beq	r3,r2,1c384 <lcd_repaint_screen+0x1a8>
      {
        unsigned char address = x + colstart[y];
   1c2e8:	e0fff917 	ldw	r3,-28(fp)
   1c2ec:	d0a01a04 	addi	r2,gp,-32664
   1c2f0:	1885883a 	add	r2,r3,r2
   1c2f4:	10800003 	ldbu	r2,0(r2)
   1c2f8:	1007883a 	mov	r3,r2
   1c2fc:	e0bffa17 	ldw	r2,-24(fp)
   1c300:	1885883a 	add	r2,r3,r2
   1c304:	e0bffe45 	stb	r2,-7(fp)

        if (address != sp->address)
   1c308:	e0fffe43 	ldbu	r3,-7(fp)
   1c30c:	e0bfff17 	ldw	r2,-4(fp)
   1c310:	108008c3 	ldbu	r2,35(r2)
   1c314:	10803fcc 	andi	r2,r2,255
   1c318:	1080201c 	xori	r2,r2,128
   1c31c:	10bfe004 	addi	r2,r2,-128
   1c320:	18800a26 	beq	r3,r2,1c34c <lcd_repaint_screen+0x170>
        {
          lcd_write_command(sp, LCD_CMD_WRITE_DATA | address);
   1c324:	e0fffe43 	ldbu	r3,-7(fp)
   1c328:	00bfe004 	movi	r2,-128
   1c32c:	1884b03a 	or	r2,r3,r2
   1c330:	10803fcc 	andi	r2,r2,255
   1c334:	e13fff17 	ldw	r4,-4(fp)
   1c338:	100b883a 	mov	r5,r2
   1c33c:	001bf8c0 	call	1bf8c <lcd_write_command>
          sp->address = address;
   1c340:	e0fffe43 	ldbu	r3,-7(fp)
   1c344:	e0bfff17 	ldw	r2,-4(fp)
   1c348:	10c008c5 	stb	r3,35(r2)
        }

        lcd_write_data(sp, c);
   1c34c:	e0bffe03 	ldbu	r2,-8(fp)
   1c350:	10803fcc 	andi	r2,r2,255
   1c354:	e13fff17 	ldw	r4,-4(fp)
   1c358:	100b883a 	mov	r5,r2
   1c35c:	001c0400 	call	1c040 <lcd_write_data>
        sp->line[y].visible[x] = c;
   1c360:	e0ffff17 	ldw	r3,-4(fp)
   1c364:	e0bff917 	ldw	r2,-28(fp)
   1c368:	108018e4 	muli	r2,r2,99
   1c36c:	1887883a 	add	r3,r3,r2
   1c370:	e0bffa17 	ldw	r2,-24(fp)
   1c374:	1885883a 	add	r2,r3,r2
   1c378:	10800c04 	addi	r2,r2,48
   1c37c:	e0fffe03 	ldbu	r3,-8(fp)
   1c380:	10c00005 	stb	r3,0(r2)
    int width  = sp->line[y].width;
    int offset = (scrollpos * sp->line[y].speed) >> 8;
    if (offset >= width)
      offset = 0;

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
   1c384:	e0bffa17 	ldw	r2,-24(fp)
   1c388:	10800044 	addi	r2,r2,1
   1c38c:	e0bffa15 	stw	r2,-24(fp)
   1c390:	e0bffa17 	ldw	r2,-24(fp)
   1c394:	10800410 	cmplti	r2,r2,16
   1c398:	103fb61e 	bne	r2,zero,1c274 <lcd_repaint_screen+0x98>
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   1c39c:	e0bff917 	ldw	r2,-28(fp)
   1c3a0:	10800044 	addi	r2,r2,1
   1c3a4:	e0bff915 	stw	r2,-28(fp)
   1c3a8:	e0bff917 	ldw	r2,-28(fp)
   1c3ac:	10800090 	cmplti	r2,r2,2
   1c3b0:	103f951e 	bne	r2,zero,1c208 <lcd_repaint_screen+0x2c>
        lcd_write_data(sp, c);
        sp->line[y].visible[x] = c;
      }
    }
  }
}
   1c3b4:	e037883a 	mov	sp,fp
   1c3b8:	dfc00117 	ldw	ra,4(sp)
   1c3bc:	df000017 	ldw	fp,0(sp)
   1c3c0:	dec00204 	addi	sp,sp,8
   1c3c4:	f800283a 	ret

0001c3c8 <lcd_scroll_up>:

/* --------------------------------------------------------------------- */

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
   1c3c8:	defffc04 	addi	sp,sp,-16
   1c3cc:	dfc00315 	stw	ra,12(sp)
   1c3d0:	df000215 	stw	fp,8(sp)
   1c3d4:	df000204 	addi	fp,sp,8
   1c3d8:	e13fff15 	stw	r4,-4(fp)
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   1c3dc:	e03ffe15 	stw	zero,-8(fp)
   1c3e0:	00001e06 	br	1c45c <lcd_scroll_up+0x94>
  {
    if (y < ALT_LCD_HEIGHT-1)
   1c3e4:	e0bffe17 	ldw	r2,-8(fp)
   1c3e8:	00801016 	blt	zero,r2,1c42c <lcd_scroll_up+0x64>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
   1c3ec:	e0bffe17 	ldw	r2,-8(fp)
   1c3f0:	108018e4 	muli	r2,r2,99
   1c3f4:	10801004 	addi	r2,r2,64
   1c3f8:	e0ffff17 	ldw	r3,-4(fp)
   1c3fc:	1887883a 	add	r3,r3,r2
   1c400:	e0bffe17 	ldw	r2,-8(fp)
   1c404:	10800044 	addi	r2,r2,1
   1c408:	108018e4 	muli	r2,r2,99
   1c40c:	10801004 	addi	r2,r2,64
   1c410:	e13fff17 	ldw	r4,-4(fp)
   1c414:	2085883a 	add	r2,r4,r2
   1c418:	1809883a 	mov	r4,r3
   1c41c:	100b883a 	mov	r5,r2
   1c420:	01801404 	movi	r6,80
   1c424:	00102380 	call	10238 <memcpy>
   1c428:	00000906 	br	1c450 <lcd_scroll_up+0x88>
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
   1c42c:	e0bffe17 	ldw	r2,-8(fp)
   1c430:	108018e4 	muli	r2,r2,99
   1c434:	10801004 	addi	r2,r2,64
   1c438:	e0ffff17 	ldw	r3,-4(fp)
   1c43c:	1885883a 	add	r2,r3,r2
   1c440:	1009883a 	mov	r4,r2
   1c444:	01400804 	movi	r5,32
   1c448:	01801404 	movi	r6,80
   1c44c:	00103300 	call	10330 <memset>

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   1c450:	e0bffe17 	ldw	r2,-8(fp)
   1c454:	10800044 	addi	r2,r2,1
   1c458:	e0bffe15 	stw	r2,-8(fp)
   1c45c:	e0bffe17 	ldw	r2,-8(fp)
   1c460:	10800090 	cmplti	r2,r2,2
   1c464:	103fdf1e 	bne	r2,zero,1c3e4 <lcd_scroll_up+0x1c>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
  }

  sp->y--;
   1c468:	e0bfff17 	ldw	r2,-4(fp)
   1c46c:	10800883 	ldbu	r2,34(r2)
   1c470:	10bfffc4 	addi	r2,r2,-1
   1c474:	1007883a 	mov	r3,r2
   1c478:	e0bfff17 	ldw	r2,-4(fp)
   1c47c:	10c00885 	stb	r3,34(r2)
}
   1c480:	e037883a 	mov	sp,fp
   1c484:	dfc00117 	ldw	ra,4(sp)
   1c488:	df000017 	ldw	fp,0(sp)
   1c48c:	dec00204 	addi	sp,sp,8
   1c490:	f800283a 	ret

0001c494 <lcd_handle_escape>:

/* --------------------------------------------------------------------- */

static void lcd_handle_escape(altera_avalon_lcd_16207_state* sp, char c)
{
   1c494:	defff904 	addi	sp,sp,-28
   1c498:	dfc00615 	stw	ra,24(sp)
   1c49c:	df000515 	stw	fp,20(sp)
   1c4a0:	df000504 	addi	fp,sp,20
   1c4a4:	e13ffe15 	stw	r4,-8(fp)
   1c4a8:	2805883a 	mov	r2,r5
   1c4ac:	e0bfff05 	stb	r2,-4(fp)
  int parm1 = 0, parm2 = 0;
   1c4b0:	e03ffb15 	stw	zero,-20(fp)
   1c4b4:	e03ffc15 	stw	zero,-16(fp)

  if (sp->escape[0] == '[')
   1c4b8:	e0bffe17 	ldw	r2,-8(fp)
   1c4bc:	10800a03 	ldbu	r2,40(r2)
   1c4c0:	10803fcc 	andi	r2,r2,255
   1c4c4:	1080201c 	xori	r2,r2,128
   1c4c8:	10bfe004 	addi	r2,r2,-128
   1c4cc:	108016d8 	cmpnei	r2,r2,91
   1c4d0:	1000441e 	bne	r2,zero,1c5e4 <lcd_handle_escape+0x150>
  {
    char * ptr = sp->escape+1;
   1c4d4:	e0bffe17 	ldw	r2,-8(fp)
   1c4d8:	10800a44 	addi	r2,r2,41
   1c4dc:	e0bffd15 	stw	r2,-12(fp)
    while (isdigit(*ptr))
   1c4e0:	00000d06 	br	1c518 <lcd_handle_escape+0x84>
      parm1 = (parm1 * 10) + (*ptr++ - '0');
   1c4e4:	e0bffb17 	ldw	r2,-20(fp)
   1c4e8:	10c002a4 	muli	r3,r2,10
   1c4ec:	e0bffd17 	ldw	r2,-12(fp)
   1c4f0:	10800003 	ldbu	r2,0(r2)
   1c4f4:	10803fcc 	andi	r2,r2,255
   1c4f8:	1080201c 	xori	r2,r2,128
   1c4fc:	10bfe004 	addi	r2,r2,-128
   1c500:	10bff404 	addi	r2,r2,-48
   1c504:	1885883a 	add	r2,r3,r2
   1c508:	e0bffb15 	stw	r2,-20(fp)
   1c50c:	e0bffd17 	ldw	r2,-12(fp)
   1c510:	10800044 	addi	r2,r2,1
   1c514:	e0bffd15 	stw	r2,-12(fp)
  int parm1 = 0, parm2 = 0;

  if (sp->escape[0] == '[')
  {
    char * ptr = sp->escape+1;
    while (isdigit(*ptr))
   1c518:	008000f4 	movhi	r2,3
   1c51c:	10a61d04 	addi	r2,r2,-26508
   1c520:	10c00017 	ldw	r3,0(r2)
   1c524:	e0bffd17 	ldw	r2,-12(fp)
   1c528:	10800003 	ldbu	r2,0(r2)
   1c52c:	10803fcc 	andi	r2,r2,255
   1c530:	1080201c 	xori	r2,r2,128
   1c534:	10bfe004 	addi	r2,r2,-128
   1c538:	1885883a 	add	r2,r3,r2
   1c53c:	10800003 	ldbu	r2,0(r2)
   1c540:	10803fcc 	andi	r2,r2,255
   1c544:	1080010c 	andi	r2,r2,4
   1c548:	103fe61e 	bne	r2,zero,1c4e4 <lcd_handle_escape+0x50>
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
   1c54c:	e0bffd17 	ldw	r2,-12(fp)
   1c550:	10800003 	ldbu	r2,0(r2)
   1c554:	10803fcc 	andi	r2,r2,255
   1c558:	1080201c 	xori	r2,r2,128
   1c55c:	10bfe004 	addi	r2,r2,-128
   1c560:	10800ed8 	cmpnei	r2,r2,59
   1c564:	1000211e 	bne	r2,zero,1c5ec <lcd_handle_escape+0x158>
    {
      ptr++;
   1c568:	e0bffd17 	ldw	r2,-12(fp)
   1c56c:	10800044 	addi	r2,r2,1
   1c570:	e0bffd15 	stw	r2,-12(fp)
      while (isdigit(*ptr))
   1c574:	00000d06 	br	1c5ac <lcd_handle_escape+0x118>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
   1c578:	e0bffc17 	ldw	r2,-16(fp)
   1c57c:	10c002a4 	muli	r3,r2,10
   1c580:	e0bffd17 	ldw	r2,-12(fp)
   1c584:	10800003 	ldbu	r2,0(r2)
   1c588:	10803fcc 	andi	r2,r2,255
   1c58c:	1080201c 	xori	r2,r2,128
   1c590:	10bfe004 	addi	r2,r2,-128
   1c594:	10bff404 	addi	r2,r2,-48
   1c598:	1885883a 	add	r2,r3,r2
   1c59c:	e0bffc15 	stw	r2,-16(fp)
   1c5a0:	e0bffd17 	ldw	r2,-12(fp)
   1c5a4:	10800044 	addi	r2,r2,1
   1c5a8:	e0bffd15 	stw	r2,-12(fp)
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
    {
      ptr++;
      while (isdigit(*ptr))
   1c5ac:	008000f4 	movhi	r2,3
   1c5b0:	10a61d04 	addi	r2,r2,-26508
   1c5b4:	10c00017 	ldw	r3,0(r2)
   1c5b8:	e0bffd17 	ldw	r2,-12(fp)
   1c5bc:	10800003 	ldbu	r2,0(r2)
   1c5c0:	10803fcc 	andi	r2,r2,255
   1c5c4:	1080201c 	xori	r2,r2,128
   1c5c8:	10bfe004 	addi	r2,r2,-128
   1c5cc:	1885883a 	add	r2,r3,r2
   1c5d0:	10800003 	ldbu	r2,0(r2)
   1c5d4:	10803fcc 	andi	r2,r2,255
   1c5d8:	1080010c 	andi	r2,r2,4
   1c5dc:	103fe61e 	bne	r2,zero,1c578 <lcd_handle_escape+0xe4>
   1c5e0:	00000206 	br	1c5ec <lcd_handle_escape+0x158>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
    }
  }
  else
    parm1 = -1;
   1c5e4:	00bfffc4 	movi	r2,-1
   1c5e8:	e0bffb15 	stw	r2,-20(fp)

  switch (c)
   1c5ec:	e0bfff07 	ldb	r2,-4(fp)
   1c5f0:	10c012a0 	cmpeqi	r3,r2,74
   1c5f4:	18002a1e 	bne	r3,zero,1c6a0 <lcd_handle_escape+0x20c>
   1c5f8:	10c012c8 	cmpgei	r3,r2,75
   1c5fc:	1800031e 	bne	r3,zero,1c60c <lcd_handle_escape+0x178>
   1c600:	10801220 	cmpeqi	r2,r2,72
   1c604:	1000051e 	bne	r2,zero,1c61c <lcd_handle_escape+0x188>
   1c608:	00004c06 	br	1c73c <lcd_handle_escape+0x2a8>
   1c60c:	10c012e0 	cmpeqi	r3,r2,75
   1c610:	1800291e 	bne	r3,zero,1c6b8 <lcd_handle_escape+0x224>
   1c614:	108019a0 	cmpeqi	r2,r2,102
   1c618:	10004826 	beq	r2,zero,1c73c <lcd_handle_escape+0x2a8>
  {
  case 'H': /* ESC '[' <y> ';' <x> 'H'  : Move cursor to location */
  case 'f': /* Same as above */
    if (parm2 > 0)
   1c61c:	e0bffc17 	ldw	r2,-16(fp)
   1c620:	0080050e 	bge	zero,r2,1c638 <lcd_handle_escape+0x1a4>
      sp->x = parm2 - 1;
   1c624:	e0bffc17 	ldw	r2,-16(fp)
   1c628:	10bfffc4 	addi	r2,r2,-1
   1c62c:	1007883a 	mov	r3,r2
   1c630:	e0bffe17 	ldw	r2,-8(fp)
   1c634:	10c00845 	stb	r3,33(r2)
    if (parm1 > 0)
   1c638:	e0bffb17 	ldw	r2,-20(fp)
   1c63c:	00803a0e 	bge	zero,r2,1c728 <lcd_handle_escape+0x294>
    {
      sp->y = parm1 - 1;
   1c640:	e0bffb17 	ldw	r2,-20(fp)
   1c644:	10bfffc4 	addi	r2,r2,-1
   1c648:	1007883a 	mov	r3,r2
   1c64c:	e0bffe17 	ldw	r2,-8(fp)
   1c650:	10c00885 	stb	r3,34(r2)
      if (sp->y > ALT_LCD_HEIGHT * 2)
   1c654:	e0bffe17 	ldw	r2,-8(fp)
   1c658:	10800883 	ldbu	r2,34(r2)
   1c65c:	10803fcc 	andi	r2,r2,255
   1c660:	10800170 	cmpltui	r2,r2,5
   1c664:	1000071e 	bne	r2,zero,1c684 <lcd_handle_escape+0x1f0>
        sp->y = ALT_LCD_HEIGHT * 2;
   1c668:	e0bffe17 	ldw	r2,-8(fp)
   1c66c:	00c00104 	movi	r3,4
   1c670:	10c00885 	stb	r3,34(r2)
      while (sp->y > ALT_LCD_HEIGHT)
   1c674:	00000306 	br	1c684 <lcd_handle_escape+0x1f0>
        lcd_scroll_up(sp);
   1c678:	e13ffe17 	ldw	r4,-8(fp)
   1c67c:	001c3c80 	call	1c3c8 <lcd_scroll_up>
   1c680:	00000106 	br	1c688 <lcd_handle_escape+0x1f4>
    if (parm1 > 0)
    {
      sp->y = parm1 - 1;
      if (sp->y > ALT_LCD_HEIGHT * 2)
        sp->y = ALT_LCD_HEIGHT * 2;
      while (sp->y > ALT_LCD_HEIGHT)
   1c684:	0001883a 	nop
   1c688:	e0bffe17 	ldw	r2,-8(fp)
   1c68c:	10800883 	ldbu	r2,34(r2)
   1c690:	10803fcc 	andi	r2,r2,255
   1c694:	108000e8 	cmpgeui	r2,r2,3
   1c698:	103ff71e 	bne	r2,zero,1c678 <lcd_handle_escape+0x1e4>
        lcd_scroll_up(sp);
    }
    break;
   1c69c:	00002206 	br	1c728 <lcd_handle_escape+0x294>
    /*   ESC J      is clear to beginning of line    [unimplemented]
     *   ESC [ 0 J  is clear to bottom of screen     [unimplemented]
     *   ESC [ 1 J  is clear to beginning of screen  [unimplemented]
     *   ESC [ 2 J  is clear screen
     */
    if (parm1 == 2)
   1c6a0:	e0bffb17 	ldw	r2,-20(fp)
   1c6a4:	10800098 	cmpnei	r2,r2,2
   1c6a8:	1000211e 	bne	r2,zero,1c730 <lcd_handle_escape+0x29c>
      lcd_clear_screen(sp);
   1c6ac:	e13ffe17 	ldw	r4,-8(fp)
   1c6b0:	001c1100 	call	1c110 <lcd_clear_screen>
    break;
   1c6b4:	00001e06 	br	1c730 <lcd_handle_escape+0x29c>
    /*   ESC K      is clear to end of line
     *   ESC [ 0 K  is clear to end of line
     *   ESC [ 1 K  is clear to beginning of line    [unimplemented]
     *   ESC [ 2 K  is clear line                    [unimplemented]
     */
    if (parm1 < 1)
   1c6b8:	e0bffb17 	ldw	r2,-20(fp)
   1c6bc:	00801e16 	blt	zero,r2,1c738 <lcd_handle_escape+0x2a4>
    {
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
   1c6c0:	e0bffe17 	ldw	r2,-8(fp)
   1c6c4:	10800843 	ldbu	r2,33(r2)
   1c6c8:	10803fcc 	andi	r2,r2,255
   1c6cc:	10801428 	cmpgeui	r2,r2,80
   1c6d0:	1000191e 	bne	r2,zero,1c738 <lcd_handle_escape+0x2a4>
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
   1c6d4:	e0bffe17 	ldw	r2,-8(fp)
   1c6d8:	10800883 	ldbu	r2,34(r2)
   1c6dc:	10803fcc 	andi	r2,r2,255
   1c6e0:	108018e4 	muli	r2,r2,99
   1c6e4:	10801004 	addi	r2,r2,64
   1c6e8:	e0fffe17 	ldw	r3,-8(fp)
   1c6ec:	1887883a 	add	r3,r3,r2
   1c6f0:	e0bffe17 	ldw	r2,-8(fp)
   1c6f4:	10800843 	ldbu	r2,33(r2)
   1c6f8:	10803fcc 	andi	r2,r2,255
   1c6fc:	1887883a 	add	r3,r3,r2
   1c700:	e0bffe17 	ldw	r2,-8(fp)
   1c704:	10800843 	ldbu	r2,33(r2)
   1c708:	10803fcc 	andi	r2,r2,255
   1c70c:	01001404 	movi	r4,80
   1c710:	2085c83a 	sub	r2,r4,r2
   1c714:	1809883a 	mov	r4,r3
   1c718:	01400804 	movi	r5,32
   1c71c:	100d883a 	mov	r6,r2
   1c720:	00103300 	call	10330 <memset>
    }
    break;
   1c724:	00000406 	br	1c738 <lcd_handle_escape+0x2a4>
      if (sp->y > ALT_LCD_HEIGHT * 2)
        sp->y = ALT_LCD_HEIGHT * 2;
      while (sp->y > ALT_LCD_HEIGHT)
        lcd_scroll_up(sp);
    }
    break;
   1c728:	0001883a 	nop
   1c72c:	00000306 	br	1c73c <lcd_handle_escape+0x2a8>
     *   ESC [ 1 J  is clear to beginning of screen  [unimplemented]
     *   ESC [ 2 J  is clear screen
     */
    if (parm1 == 2)
      lcd_clear_screen(sp);
    break;
   1c730:	0001883a 	nop
   1c734:	00000106 	br	1c73c <lcd_handle_escape+0x2a8>
    if (parm1 < 1)
    {
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
    }
    break;
   1c738:	0001883a 	nop
  }
}
   1c73c:	e037883a 	mov	sp,fp
   1c740:	dfc00117 	ldw	ra,4(sp)
   1c744:	df000017 	ldw	fp,0(sp)
   1c748:	dec00204 	addi	sp,sp,8
   1c74c:	f800283a 	ret

0001c750 <altera_avalon_lcd_16207_write>:

/* --------------------------------------------------------------------- */

int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp, 
  const char* ptr, int len, int flags)
{
   1c750:	defff304 	addi	sp,sp,-52
   1c754:	dfc00c15 	stw	ra,48(sp)
   1c758:	df000b15 	stw	fp,44(sp)
   1c75c:	df000b04 	addi	fp,sp,44
   1c760:	e13ffc15 	stw	r4,-16(fp)
   1c764:	e17ffd15 	stw	r5,-12(fp)
   1c768:	e1bffe15 	stw	r6,-8(fp)
   1c76c:	e1ffff15 	stw	r7,-4(fp)
  const char* end = ptr + len;
   1c770:	e0bffe17 	ldw	r2,-8(fp)
   1c774:	e0fffd17 	ldw	r3,-12(fp)
   1c778:	1885883a 	add	r2,r3,r2
   1c77c:	e0bff815 	stw	r2,-32(fp)

  ALT_SEM_PEND (sp->write_lock, 0);

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;
   1c780:	e0bffc17 	ldw	r2,-16(fp)
   1c784:	00c00044 	movi	r3,1
   1c788:	10c009c5 	stb	r3,39(r2)

  for ( ; ptr < end ; ptr++)
   1c78c:	00009d06 	br	1ca04 <altera_avalon_lcd_16207_write+0x2b4>
  {
    char c = *ptr;
   1c790:	e0bffd17 	ldw	r2,-12(fp)
   1c794:	10800003 	ldbu	r2,0(r2)
   1c798:	e0bff905 	stb	r2,-28(fp)

    if (sp->esccount >= 0)
   1c79c:	e0bffc17 	ldw	r2,-16(fp)
   1c7a0:	10800903 	ldbu	r2,36(r2)
   1c7a4:	10803fcc 	andi	r2,r2,255
   1c7a8:	1080201c 	xori	r2,r2,128
   1c7ac:	10bfe004 	addi	r2,r2,-128
   1c7b0:	10003816 	blt	r2,zero,1c894 <altera_avalon_lcd_16207_write+0x144>
    {
      unsigned int esccount = sp->esccount;
   1c7b4:	e0bffc17 	ldw	r2,-16(fp)
   1c7b8:	10800903 	ldbu	r2,36(r2)
   1c7bc:	10803fcc 	andi	r2,r2,255
   1c7c0:	1080201c 	xori	r2,r2,128
   1c7c4:	10bfe004 	addi	r2,r2,-128
   1c7c8:	e0bffa15 	stw	r2,-24(fp)

      /* Single character escape sequences can end with any character
       * Multi character escape sequences start with '[' and contain
       * digits and semicolons before terminating
       */
      if ((esccount == 0 && c != '[') ||
   1c7cc:	e0bffa17 	ldw	r2,-24(fp)
   1c7d0:	1000031e 	bne	r2,zero,1c7e0 <altera_avalon_lcd_16207_write+0x90>
   1c7d4:	e0bff907 	ldb	r2,-28(fp)
   1c7d8:	108016d8 	cmpnei	r2,r2,91
   1c7dc:	10000e1e 	bne	r2,zero,1c818 <altera_avalon_lcd_16207_write+0xc8>
   1c7e0:	e0bffa17 	ldw	r2,-24(fp)
   1c7e4:	10001926 	beq	r2,zero,1c84c <altera_avalon_lcd_16207_write+0xfc>
          (esccount > 0 && !isdigit(c) && c != ';'))
   1c7e8:	008000f4 	movhi	r2,3
   1c7ec:	10a61d04 	addi	r2,r2,-26508
   1c7f0:	10c00017 	ldw	r3,0(r2)
   1c7f4:	e0bff907 	ldb	r2,-28(fp)
   1c7f8:	1885883a 	add	r2,r3,r2
   1c7fc:	10800003 	ldbu	r2,0(r2)
   1c800:	10803fcc 	andi	r2,r2,255
   1c804:	1080010c 	andi	r2,r2,4
   1c808:	1000101e 	bne	r2,zero,1c84c <altera_avalon_lcd_16207_write+0xfc>
   1c80c:	e0bff907 	ldb	r2,-28(fp)
   1c810:	10800ee0 	cmpeqi	r2,r2,59
   1c814:	10000d1e 	bne	r2,zero,1c84c <altera_avalon_lcd_16207_write+0xfc>
      {
        sp->escape[esccount] = 0;
   1c818:	e0fffc17 	ldw	r3,-16(fp)
   1c81c:	e0bffa17 	ldw	r2,-24(fp)
   1c820:	1885883a 	add	r2,r3,r2
   1c824:	10800a04 	addi	r2,r2,40
   1c828:	10000005 	stb	zero,0(r2)

        lcd_handle_escape(sp, c);
   1c82c:	e0bff907 	ldb	r2,-28(fp)
   1c830:	e13ffc17 	ldw	r4,-16(fp)
   1c834:	100b883a 	mov	r5,r2
   1c838:	001c4940 	call	1c494 <lcd_handle_escape>

        sp->esccount = -1;
   1c83c:	e0bffc17 	ldw	r2,-16(fp)
   1c840:	00ffffc4 	movi	r3,-1
   1c844:	10c00905 	stb	r3,36(r2)
   1c848:	00006b06 	br	1c9f8 <altera_avalon_lcd_16207_write+0x2a8>
      }
      else if (sp->esccount < sizeof(sp->escape)-1)
   1c84c:	e0bffc17 	ldw	r2,-16(fp)
   1c850:	10800903 	ldbu	r2,36(r2)
   1c854:	10803fcc 	andi	r2,r2,255
   1c858:	108001e8 	cmpgeui	r2,r2,7
   1c85c:	1000651e 	bne	r2,zero,1c9f4 <altera_avalon_lcd_16207_write+0x2a4>
      {
        sp->escape[esccount] = c;
   1c860:	e0fffc17 	ldw	r3,-16(fp)
   1c864:	e0bffa17 	ldw	r2,-24(fp)
   1c868:	1885883a 	add	r2,r3,r2
   1c86c:	10800a04 	addi	r2,r2,40
   1c870:	e0fff903 	ldbu	r3,-28(fp)
   1c874:	10c00005 	stb	r3,0(r2)
        sp->esccount++;
   1c878:	e0bffc17 	ldw	r2,-16(fp)
   1c87c:	10800903 	ldbu	r2,36(r2)
   1c880:	10800044 	addi	r2,r2,1
   1c884:	1007883a 	mov	r3,r2
   1c888:	e0bffc17 	ldw	r2,-16(fp)
   1c88c:	10c00905 	stb	r3,36(r2)
   1c890:	00005806 	br	1c9f4 <altera_avalon_lcd_16207_write+0x2a4>
      }
    }
    else if (c == 27) /* ESC */
   1c894:	e0bff907 	ldb	r2,-28(fp)
   1c898:	108006d8 	cmpnei	r2,r2,27
   1c89c:	1000031e 	bne	r2,zero,1c8ac <altera_avalon_lcd_16207_write+0x15c>
    {
      sp->esccount = 0;
   1c8a0:	e0bffc17 	ldw	r2,-16(fp)
   1c8a4:	10000905 	stb	zero,36(r2)
   1c8a8:	00005306 	br	1c9f8 <altera_avalon_lcd_16207_write+0x2a8>
    }
    else if (c == '\r')
   1c8ac:	e0bff907 	ldb	r2,-28(fp)
   1c8b0:	10800358 	cmpnei	r2,r2,13
   1c8b4:	1000031e 	bne	r2,zero,1c8c4 <altera_avalon_lcd_16207_write+0x174>
    {
      sp->x = 0;
   1c8b8:	e0bffc17 	ldw	r2,-16(fp)
   1c8bc:	10000845 	stb	zero,33(r2)
   1c8c0:	00004d06 	br	1c9f8 <altera_avalon_lcd_16207_write+0x2a8>
    }
    else if (c == '\n')
   1c8c4:	e0bff907 	ldb	r2,-28(fp)
   1c8c8:	10800298 	cmpnei	r2,r2,10
   1c8cc:	1000101e 	bne	r2,zero,1c910 <altera_avalon_lcd_16207_write+0x1c0>
    {
      sp->x = 0;
   1c8d0:	e0bffc17 	ldw	r2,-16(fp)
   1c8d4:	10000845 	stb	zero,33(r2)
      sp->y++;
   1c8d8:	e0bffc17 	ldw	r2,-16(fp)
   1c8dc:	10800883 	ldbu	r2,34(r2)
   1c8e0:	10800044 	addi	r2,r2,1
   1c8e4:	1007883a 	mov	r3,r2
   1c8e8:	e0bffc17 	ldw	r2,-16(fp)
   1c8ec:	10c00885 	stb	r3,34(r2)

      /* Let the cursor sit at X=0, Y=HEIGHT without scrolling so the user
       * can print two lines of data without losing one.
       */
      if (sp->y > ALT_LCD_HEIGHT)
   1c8f0:	e0bffc17 	ldw	r2,-16(fp)
   1c8f4:	10800883 	ldbu	r2,34(r2)
   1c8f8:	10803fcc 	andi	r2,r2,255
   1c8fc:	108000f0 	cmpltui	r2,r2,3
   1c900:	10003d1e 	bne	r2,zero,1c9f8 <altera_avalon_lcd_16207_write+0x2a8>
        lcd_scroll_up(sp);
   1c904:	e13ffc17 	ldw	r4,-16(fp)
   1c908:	001c3c80 	call	1c3c8 <lcd_scroll_up>
   1c90c:	00003a06 	br	1c9f8 <altera_avalon_lcd_16207_write+0x2a8>
    }
    else if (c == '\b')
   1c910:	e0bff907 	ldb	r2,-28(fp)
   1c914:	10800218 	cmpnei	r2,r2,8
   1c918:	10000b1e 	bne	r2,zero,1c948 <altera_avalon_lcd_16207_write+0x1f8>
    {
      if (sp->x > 0)
   1c91c:	e0bffc17 	ldw	r2,-16(fp)
   1c920:	10800843 	ldbu	r2,33(r2)
   1c924:	10803fcc 	andi	r2,r2,255
   1c928:	10003326 	beq	r2,zero,1c9f8 <altera_avalon_lcd_16207_write+0x2a8>
        sp->x--;
   1c92c:	e0bffc17 	ldw	r2,-16(fp)
   1c930:	10800843 	ldbu	r2,33(r2)
   1c934:	10bfffc4 	addi	r2,r2,-1
   1c938:	1007883a 	mov	r3,r2
   1c93c:	e0bffc17 	ldw	r2,-16(fp)
   1c940:	10c00845 	stb	r3,33(r2)
   1c944:	00002c06 	br	1c9f8 <altera_avalon_lcd_16207_write+0x2a8>
    }
    else if (isprint(c))
   1c948:	008000f4 	movhi	r2,3
   1c94c:	10a61d04 	addi	r2,r2,-26508
   1c950:	10c00017 	ldw	r3,0(r2)
   1c954:	e0bff907 	ldb	r2,-28(fp)
   1c958:	1885883a 	add	r2,r3,r2
   1c95c:	10800003 	ldbu	r2,0(r2)
   1c960:	10803fcc 	andi	r2,r2,255
   1c964:	1080201c 	xori	r2,r2,128
   1c968:	10bfe004 	addi	r2,r2,-128
   1c96c:	108025cc 	andi	r2,r2,151
   1c970:	10002126 	beq	r2,zero,1c9f8 <altera_avalon_lcd_16207_write+0x2a8>
    {
      /* If we didn't scroll on the last linefeed then we might need to do
       * it now. */
      if (sp->y >= ALT_LCD_HEIGHT)
   1c974:	e0bffc17 	ldw	r2,-16(fp)
   1c978:	10800883 	ldbu	r2,34(r2)
   1c97c:	10803fcc 	andi	r2,r2,255
   1c980:	108000b0 	cmpltui	r2,r2,2
   1c984:	1000021e 	bne	r2,zero,1c990 <altera_avalon_lcd_16207_write+0x240>
        lcd_scroll_up(sp);
   1c988:	e13ffc17 	ldw	r4,-16(fp)
   1c98c:	001c3c80 	call	1c3c8 <lcd_scroll_up>

      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
   1c990:	e0bffc17 	ldw	r2,-16(fp)
   1c994:	10800843 	ldbu	r2,33(r2)
   1c998:	10803fcc 	andi	r2,r2,255
   1c99c:	10801428 	cmpgeui	r2,r2,80
   1c9a0:	10000d1e 	bne	r2,zero,1c9d8 <altera_avalon_lcd_16207_write+0x288>
        sp->line[sp->y].data[sp->x] = c;
   1c9a4:	e0bffc17 	ldw	r2,-16(fp)
   1c9a8:	10800883 	ldbu	r2,34(r2)
   1c9ac:	10c03fcc 	andi	r3,r2,255
   1c9b0:	e0bffc17 	ldw	r2,-16(fp)
   1c9b4:	10800843 	ldbu	r2,33(r2)
   1c9b8:	10803fcc 	andi	r2,r2,255
   1c9bc:	e13ffc17 	ldw	r4,-16(fp)
   1c9c0:	18c018e4 	muli	r3,r3,99
   1c9c4:	20c7883a 	add	r3,r4,r3
   1c9c8:	1885883a 	add	r2,r3,r2
   1c9cc:	10801004 	addi	r2,r2,64
   1c9d0:	e0fff903 	ldbu	r3,-28(fp)
   1c9d4:	10c00005 	stb	r3,0(r2)

      sp->x++;
   1c9d8:	e0bffc17 	ldw	r2,-16(fp)
   1c9dc:	10800843 	ldbu	r2,33(r2)
   1c9e0:	10800044 	addi	r2,r2,1
   1c9e4:	1007883a 	mov	r3,r2
   1c9e8:	e0bffc17 	ldw	r2,-16(fp)
   1c9ec:	10c00845 	stb	r3,33(r2)
   1c9f0:	00000106 	br	1c9f8 <altera_avalon_lcd_16207_write+0x2a8>
        sp->esccount = -1;
      }
      else if (sp->esccount < sizeof(sp->escape)-1)
      {
        sp->escape[esccount] = c;
        sp->esccount++;
   1c9f4:	0001883a 	nop

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;

  for ( ; ptr < end ; ptr++)
   1c9f8:	e0bffd17 	ldw	r2,-12(fp)
   1c9fc:	10800044 	addi	r2,r2,1
   1ca00:	e0bffd15 	stw	r2,-12(fp)
   1ca04:	e0fffd17 	ldw	r3,-12(fp)
   1ca08:	e0bff817 	ldw	r2,-32(fp)
   1ca0c:	18bf6036 	bltu	r3,r2,1c790 <altera_avalon_lcd_16207_write+0x40>
      sp->x++;
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
   1ca10:	00800404 	movi	r2,16
   1ca14:	e0bff615 	stw	r2,-40(fp)
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   1ca18:	e03ff515 	stw	zero,-44(fp)
   1ca1c:	00003706 	br	1cafc <altera_avalon_lcd_16207_write+0x3ac>
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
   1ca20:	00801404 	movi	r2,80
   1ca24:	e0bff715 	stw	r2,-36(fp)
   1ca28:	00001106 	br	1ca70 <altera_avalon_lcd_16207_write+0x320>
      if (sp->line[y].data[width-1] != ' ')
   1ca2c:	e0bff717 	ldw	r2,-36(fp)
   1ca30:	10bfffc4 	addi	r2,r2,-1
   1ca34:	e13ffc17 	ldw	r4,-16(fp)
   1ca38:	e0fff517 	ldw	r3,-44(fp)
   1ca3c:	18c018e4 	muli	r3,r3,99
   1ca40:	20c7883a 	add	r3,r4,r3
   1ca44:	1885883a 	add	r2,r3,r2
   1ca48:	10801004 	addi	r2,r2,64
   1ca4c:	10800003 	ldbu	r2,0(r2)
   1ca50:	10803fcc 	andi	r2,r2,255
   1ca54:	1080201c 	xori	r2,r2,128
   1ca58:	10bfe004 	addi	r2,r2,-128
   1ca5c:	10800820 	cmpeqi	r2,r2,32
   1ca60:	10000626 	beq	r2,zero,1ca7c <altera_avalon_lcd_16207_write+0x32c>
  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
   1ca64:	e0bff717 	ldw	r2,-36(fp)
   1ca68:	10bfffc4 	addi	r2,r2,-1
   1ca6c:	e0bff715 	stw	r2,-36(fp)
   1ca70:	e0bff717 	ldw	r2,-36(fp)
   1ca74:	00bfed16 	blt	zero,r2,1ca2c <altera_avalon_lcd_16207_write+0x2dc>
   1ca78:	00000106 	br	1ca80 <altera_avalon_lcd_16207_write+0x330>
      if (sp->line[y].data[width-1] != ' ')
        break;
   1ca7c:	0001883a 	nop

    /* The minimum width is the size of the LCD panel.  If the real width
     * is long enough to require scrolling then add an extra space so the
     * end of the message doesn't run into the beginning of it.
     */
    if (width <= ALT_LCD_WIDTH)
   1ca80:	e0bff717 	ldw	r2,-36(fp)
   1ca84:	10800448 	cmpgei	r2,r2,17
   1ca88:	1000031e 	bne	r2,zero,1ca98 <altera_avalon_lcd_16207_write+0x348>
      width = ALT_LCD_WIDTH;
   1ca8c:	00800404 	movi	r2,16
   1ca90:	e0bff715 	stw	r2,-36(fp)
   1ca94:	00000306 	br	1caa4 <altera_avalon_lcd_16207_write+0x354>
    else
      width++;
   1ca98:	e0bff717 	ldw	r2,-36(fp)
   1ca9c:	10800044 	addi	r2,r2,1
   1caa0:	e0bff715 	stw	r2,-36(fp)

    sp->line[y].width = width;
   1caa4:	e0bff717 	ldw	r2,-36(fp)
   1caa8:	1007883a 	mov	r3,r2
   1caac:	e13ffc17 	ldw	r4,-16(fp)
   1cab0:	e0bff517 	ldw	r2,-44(fp)
   1cab4:	108018e4 	muli	r2,r2,99
   1cab8:	2085883a 	add	r2,r4,r2
   1cabc:	10802404 	addi	r2,r2,144
   1cac0:	10c00045 	stb	r3,1(r2)
    if (widthmax < width)
   1cac4:	e0fff617 	ldw	r3,-40(fp)
   1cac8:	e0bff717 	ldw	r2,-36(fp)
   1cacc:	1880020e 	bge	r3,r2,1cad8 <altera_avalon_lcd_16207_write+0x388>
      widthmax = width;
   1cad0:	e0bff717 	ldw	r2,-36(fp)
   1cad4:	e0bff615 	stw	r2,-40(fp)
    sp->line[y].speed = 0; /* By default lines don't scroll */
   1cad8:	e0fffc17 	ldw	r3,-16(fp)
   1cadc:	e0bff517 	ldw	r2,-44(fp)
   1cae0:	108018e4 	muli	r2,r2,99
   1cae4:	1885883a 	add	r2,r3,r2
   1cae8:	10802404 	addi	r2,r2,144
   1caec:	10000085 	stb	zero,2(r2)
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   1caf0:	e0bff517 	ldw	r2,-44(fp)
   1caf4:	10800044 	addi	r2,r2,1
   1caf8:	e0bff515 	stw	r2,-44(fp)
   1cafc:	e0bff517 	ldw	r2,-44(fp)
   1cb00:	10800090 	cmplti	r2,r2,2
   1cb04:	103fc61e 	bne	r2,zero,1ca20 <altera_avalon_lcd_16207_write+0x2d0>
    if (widthmax < width)
      widthmax = width;
    sp->line[y].speed = 0; /* By default lines don't scroll */
  }

  if (widthmax <= ALT_LCD_WIDTH)
   1cb08:	e0bff617 	ldw	r2,-40(fp)
   1cb0c:	10800448 	cmpgei	r2,r2,17
   1cb10:	1000031e 	bne	r2,zero,1cb20 <altera_avalon_lcd_16207_write+0x3d0>
    sp->scrollmax = 0;
   1cb14:	e0bffc17 	ldw	r2,-16(fp)
   1cb18:	10000985 	stb	zero,38(r2)
   1cb1c:	00002d06 	br	1cbd4 <altera_avalon_lcd_16207_write+0x484>
  else
  {
    widthmax *= 2;
   1cb20:	e0bff617 	ldw	r2,-40(fp)
   1cb24:	1085883a 	add	r2,r2,r2
   1cb28:	e0bff615 	stw	r2,-40(fp)
    sp->scrollmax = widthmax;
   1cb2c:	e0bff617 	ldw	r2,-40(fp)
   1cb30:	1007883a 	mov	r3,r2
   1cb34:	e0bffc17 	ldw	r2,-16(fp)
   1cb38:	10c00985 	stb	r3,38(r2)

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   1cb3c:	e03ff515 	stw	zero,-44(fp)
   1cb40:	00002106 	br	1cbc8 <altera_avalon_lcd_16207_write+0x478>
      if (sp->line[y].width > ALT_LCD_WIDTH)
   1cb44:	e0fffc17 	ldw	r3,-16(fp)
   1cb48:	e0bff517 	ldw	r2,-44(fp)
   1cb4c:	108018e4 	muli	r2,r2,99
   1cb50:	1885883a 	add	r2,r3,r2
   1cb54:	10802404 	addi	r2,r2,144
   1cb58:	10800043 	ldbu	r2,1(r2)
   1cb5c:	10803fcc 	andi	r2,r2,255
   1cb60:	1080201c 	xori	r2,r2,128
   1cb64:	10bfe004 	addi	r2,r2,-128
   1cb68:	10800450 	cmplti	r2,r2,17
   1cb6c:	1000131e 	bne	r2,zero,1cbbc <altera_avalon_lcd_16207_write+0x46c>
         */
#if 1
        /* This option makes all the lines scroll round at different speeds
         * which are chosen so that all the scrolls finish at the same time.
         */
        sp->line[y].speed = 256 * sp->line[y].width / widthmax;
   1cb70:	e0fffc17 	ldw	r3,-16(fp)
   1cb74:	e0bff517 	ldw	r2,-44(fp)
   1cb78:	108018e4 	muli	r2,r2,99
   1cb7c:	1885883a 	add	r2,r3,r2
   1cb80:	10802404 	addi	r2,r2,144
   1cb84:	10800043 	ldbu	r2,1(r2)
   1cb88:	10803fcc 	andi	r2,r2,255
   1cb8c:	1080201c 	xori	r2,r2,128
   1cb90:	10bfe004 	addi	r2,r2,-128
   1cb94:	1006923a 	slli	r3,r2,8
   1cb98:	e0bff617 	ldw	r2,-40(fp)
   1cb9c:	1885283a 	div	r2,r3,r2
   1cba0:	1007883a 	mov	r3,r2
   1cba4:	e13ffc17 	ldw	r4,-16(fp)
   1cba8:	e0bff517 	ldw	r2,-44(fp)
   1cbac:	108018e4 	muli	r2,r2,99
   1cbb0:	2085883a 	add	r2,r4,r2
   1cbb4:	10802404 	addi	r2,r2,144
   1cbb8:	10c00085 	stb	r3,2(r2)
  {
    widthmax *= 2;
    sp->scrollmax = widthmax;

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   1cbbc:	e0bff517 	ldw	r2,-44(fp)
   1cbc0:	10800044 	addi	r2,r2,1
   1cbc4:	e0bff515 	stw	r2,-44(fp)
   1cbc8:	e0bff517 	ldw	r2,-44(fp)
   1cbcc:	10800090 	cmplti	r2,r2,2
   1cbd0:	103fdc1e 	bne	r2,zero,1cb44 <altera_avalon_lcd_16207_write+0x3f4>
   * (because active was set when the timer interrupt occurred).  If there
   * has been a missed repaint then paint again.  And again.  etc.
   */
  for ( ; ; )
  {
    int old_scrollpos = sp->scrollpos;
   1cbd4:	e0bffc17 	ldw	r2,-16(fp)
   1cbd8:	10800943 	ldbu	r2,37(r2)
   1cbdc:	10803fcc 	andi	r2,r2,255
   1cbe0:	e0bffb15 	stw	r2,-20(fp)

    lcd_repaint_screen(sp);
   1cbe4:	e13ffc17 	ldw	r4,-16(fp)
   1cbe8:	001c1dc0 	call	1c1dc <lcd_repaint_screen>

    /* Let the timer routines repaint the display again */
    sp->active = 0;
   1cbec:	e0bffc17 	ldw	r2,-16(fp)
   1cbf0:	100009c5 	stb	zero,39(r2)

    /* Have the timer routines tried to scroll while we were painting?
     * If not then we can exit */
    if (sp->scrollpos == old_scrollpos)
   1cbf4:	e0bffc17 	ldw	r2,-16(fp)
   1cbf8:	10800943 	ldbu	r2,37(r2)
   1cbfc:	10c03fcc 	andi	r3,r2,255
   1cc00:	e0bffb17 	ldw	r2,-20(fp)
   1cc04:	18800426 	beq	r3,r2,1cc18 <altera_avalon_lcd_16207_write+0x4c8>
      break;

    /* We need to repaint again since the display scrolled while we were
     * painting last time */
    sp->active = 1;
   1cc08:	e0bffc17 	ldw	r2,-16(fp)
   1cc0c:	00c00044 	movi	r3,1
   1cc10:	10c009c5 	stb	r3,39(r2)
  }
   1cc14:	003fef06 	br	1cbd4 <altera_avalon_lcd_16207_write+0x484>
    sp->active = 0;

    /* Have the timer routines tried to scroll while we were painting?
     * If not then we can exit */
    if (sp->scrollpos == old_scrollpos)
      break;
   1cc18:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);

  return len;
   1cc1c:	e0bffe17 	ldw	r2,-8(fp)
}
   1cc20:	e037883a 	mov	sp,fp
   1cc24:	dfc00117 	ldw	ra,4(sp)
   1cc28:	df000017 	ldw	fp,0(sp)
   1cc2c:	dec00204 	addi	sp,sp,8
   1cc30:	f800283a 	ret

0001cc34 <alt_lcd_16207_timeout>:
/*
 * Timeout routine is called every second
 */

static alt_u32 alt_lcd_16207_timeout(void* context) 
{
   1cc34:	defffc04 	addi	sp,sp,-16
   1cc38:	dfc00315 	stw	ra,12(sp)
   1cc3c:	df000215 	stw	fp,8(sp)
   1cc40:	df000204 	addi	fp,sp,8
   1cc44:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_lcd_16207_state* sp = (altera_avalon_lcd_16207_state*)context;
   1cc48:	e0bfff17 	ldw	r2,-4(fp)
   1cc4c:	e0bffe15 	stw	r2,-8(fp)

  /* Update the scrolling position */
  if (sp->scrollpos + 1 >= sp->scrollmax)
   1cc50:	e0bffe17 	ldw	r2,-8(fp)
   1cc54:	10800943 	ldbu	r2,37(r2)
   1cc58:	10803fcc 	andi	r2,r2,255
   1cc5c:	10c00044 	addi	r3,r2,1
   1cc60:	e0bffe17 	ldw	r2,-8(fp)
   1cc64:	10800983 	ldbu	r2,38(r2)
   1cc68:	10803fcc 	andi	r2,r2,255
   1cc6c:	18800316 	blt	r3,r2,1cc7c <alt_lcd_16207_timeout+0x48>
    sp->scrollpos = 0;
   1cc70:	e0bffe17 	ldw	r2,-8(fp)
   1cc74:	10000945 	stb	zero,37(r2)
   1cc78:	00000606 	br	1cc94 <alt_lcd_16207_timeout+0x60>
  else
    sp->scrollpos = sp->scrollpos + 1;
   1cc7c:	e0bffe17 	ldw	r2,-8(fp)
   1cc80:	10800943 	ldbu	r2,37(r2)
   1cc84:	10800044 	addi	r2,r2,1
   1cc88:	1007883a 	mov	r3,r2
   1cc8c:	e0bffe17 	ldw	r2,-8(fp)
   1cc90:	10c00945 	stb	r3,37(r2)

  /* Repaint the panel unless the foreground will do it again soon */
  if (sp->scrollmax > 0 && !sp->active)
   1cc94:	e0bffe17 	ldw	r2,-8(fp)
   1cc98:	10800983 	ldbu	r2,38(r2)
   1cc9c:	10803fcc 	andi	r2,r2,255
   1cca0:	10000826 	beq	r2,zero,1ccc4 <alt_lcd_16207_timeout+0x90>
   1cca4:	e0bffe17 	ldw	r2,-8(fp)
   1cca8:	108009c3 	ldbu	r2,39(r2)
   1ccac:	10803fcc 	andi	r2,r2,255
   1ccb0:	1080201c 	xori	r2,r2,128
   1ccb4:	10bfe004 	addi	r2,r2,-128
   1ccb8:	1000021e 	bne	r2,zero,1ccc4 <alt_lcd_16207_timeout+0x90>
    lcd_repaint_screen(sp);
   1ccbc:	e13ffe17 	ldw	r4,-8(fp)
   1ccc0:	001c1dc0 	call	1c1dc <lcd_repaint_screen>

  return sp->period;
   1ccc4:	e0bffe17 	ldw	r2,-8(fp)
   1ccc8:	10800717 	ldw	r2,28(r2)
}
   1cccc:	e037883a 	mov	sp,fp
   1ccd0:	dfc00117 	ldw	ra,4(sp)
   1ccd4:	df000017 	ldw	fp,0(sp)
   1ccd8:	dec00204 	addi	sp,sp,8
   1ccdc:	f800283a 	ret

0001cce0 <altera_avalon_lcd_16207_init>:

/*
 * Called at boot time to initialise the LCD driver
 */
void altera_avalon_lcd_16207_init(altera_avalon_lcd_16207_state* sp)
{
   1cce0:	defffc04 	addi	sp,sp,-16
   1cce4:	dfc00315 	stw	ra,12(sp)
   1cce8:	df000215 	stw	fp,8(sp)
   1ccec:	df000204 	addi	fp,sp,8
   1ccf0:	e13fff15 	stw	r4,-4(fp)
  unsigned int base = sp->base;
   1ccf4:	e0bfff17 	ldw	r2,-4(fp)
   1ccf8:	10800017 	ldw	r2,0(r2)
   1ccfc:	e0bffe15 	stw	r2,-8(fp)

  /* Mark the device as functional */
  sp->broken = 0;
   1cd00:	e0bfff17 	ldw	r2,-4(fp)
   1cd04:	10000805 	stb	zero,32(r2)
   * the BUSY bit in the status register doesn't work until the display
   * has been reset three times.
   */

  /* Wait for 15 ms then reset */
  usleep(15000);
   1cd08:	010ea604 	movi	r4,15000
   1cd0c:	00194f00 	call	194f0 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
   1cd10:	e0bffe17 	ldw	r2,-8(fp)
   1cd14:	00c00c04 	movi	r3,48
   1cd18:	10c00035 	stwio	r3,0(r2)

  /* Wait for another 4.1ms and reset again */
  usleep(4100);  
   1cd1c:	01040104 	movi	r4,4100
   1cd20:	00194f00 	call	194f0 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
   1cd24:	e0bffe17 	ldw	r2,-8(fp)
   1cd28:	00c00c04 	movi	r3,48
   1cd2c:	10c00035 	stwio	r3,0(r2)

  /* Wait a further 1 ms and reset a third time */
  usleep(1000);
   1cd30:	0100fa04 	movi	r4,1000
   1cd34:	00194f00 	call	194f0 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
   1cd38:	e0bffe17 	ldw	r2,-8(fp)
   1cd3c:	00c00c04 	movi	r3,48
   1cd40:	10c00035 	stwio	r3,0(r2)

  /* Setup interface parameters: 8 bit bus, 2 rows, 5x7 font */
  lcd_write_command(sp, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT | LCD_CMD_TWO_LINE);
   1cd44:	e13fff17 	ldw	r4,-4(fp)
   1cd48:	01400e04 	movi	r5,56
   1cd4c:	001bf8c0 	call	1bf8c <lcd_write_command>
  
  /* Turn display off */
  lcd_write_command(sp, LCD_CMD_ONOFF);
   1cd50:	e13fff17 	ldw	r4,-4(fp)
   1cd54:	01400204 	movi	r5,8
   1cd58:	001bf8c0 	call	1bf8c <lcd_write_command>

  /* Clear display */
  lcd_clear_screen(sp);
   1cd5c:	e13fff17 	ldw	r4,-4(fp)
   1cd60:	001c1100 	call	1c110 <lcd_clear_screen>
  
  /* Set mode: increment after writing, don't shift display */
  lcd_write_command(sp, LCD_CMD_MODES | LCD_CMD_MODE_INC);
   1cd64:	e13fff17 	ldw	r4,-4(fp)
   1cd68:	01400184 	movi	r5,6
   1cd6c:	001bf8c0 	call	1bf8c <lcd_write_command>

  /* Turn display on */
  lcd_write_command(sp, LCD_CMD_ONOFF | LCD_CMD_ENABLE_DISP);
   1cd70:	e13fff17 	ldw	r4,-4(fp)
   1cd74:	01400304 	movi	r5,12
   1cd78:	001bf8c0 	call	1bf8c <lcd_write_command>

  sp->esccount = -1;
   1cd7c:	e0bfff17 	ldw	r2,-4(fp)
   1cd80:	00ffffc4 	movi	r3,-1
   1cd84:	10c00905 	stb	r3,36(r2)
  memset(sp->escape, 0, sizeof(sp->escape));
   1cd88:	e0bfff17 	ldw	r2,-4(fp)
   1cd8c:	10800a04 	addi	r2,r2,40
   1cd90:	1009883a 	mov	r4,r2
   1cd94:	000b883a 	mov	r5,zero
   1cd98:	01800204 	movi	r6,8
   1cd9c:	00103300 	call	10330 <memset>

  sp->scrollpos = 0;
   1cda0:	e0bfff17 	ldw	r2,-4(fp)
   1cda4:	10000945 	stb	zero,37(r2)
  sp->scrollmax = 0;
   1cda8:	e0bfff17 	ldw	r2,-4(fp)
   1cdac:	10000985 	stb	zero,38(r2)
  sp->active = 0;
   1cdb0:	e0bfff17 	ldw	r2,-4(fp)
   1cdb4:	100009c5 	stb	zero,39(r2)
   1cdb8:	008000f4 	movhi	r2,3
   1cdbc:	10aed804 	addi	r2,r2,-17568
   1cdc0:	10800017 	ldw	r2,0(r2)

  sp->period = alt_ticks_per_second() / 10; /* Call every 100ms */
   1cdc4:	1007883a 	mov	r3,r2
   1cdc8:	00800284 	movi	r2,10
   1cdcc:	1885203a 	divu	r2,r3,r2
   1cdd0:	1007883a 	mov	r3,r2
   1cdd4:	e0bfff17 	ldw	r2,-4(fp)
   1cdd8:	10c00715 	stw	r3,28(r2)

  alt_alarm_start(&sp->alarm, sp->period, &alt_lcd_16207_timeout, sp);
   1cddc:	e0bfff17 	ldw	r2,-4(fp)
   1cde0:	10c00104 	addi	r3,r2,4
   1cde4:	e0bfff17 	ldw	r2,-4(fp)
   1cde8:	10800717 	ldw	r2,28(r2)
   1cdec:	1809883a 	mov	r4,r3
   1cdf0:	100b883a 	mov	r5,r2
   1cdf4:	018000b4 	movhi	r6,2
   1cdf8:	31b30d04 	addi	r6,r6,-13260
   1cdfc:	e1ffff17 	ldw	r7,-4(fp)
   1ce00:	00188880 	call	18888 <alt_alarm_start>
}
   1ce04:	e037883a 	mov	sp,fp
   1ce08:	dfc00117 	ldw	ra,4(sp)
   1ce0c:	df000017 	ldw	fp,0(sp)
   1ce10:	dec00204 	addi	sp,sp,8
   1ce14:	f800283a 	ret

0001ce18 <altera_avalon_lcd_16207_write_fd>:
extern int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp,
  const char* ptr, int count, int flags);

int 
altera_avalon_lcd_16207_write_fd(alt_fd* fd, const char* buffer, int space)
{
   1ce18:	defffa04 	addi	sp,sp,-24
   1ce1c:	dfc00515 	stw	ra,20(sp)
   1ce20:	df000415 	stw	fp,16(sp)
   1ce24:	df000404 	addi	fp,sp,16
   1ce28:	e13ffd15 	stw	r4,-12(fp)
   1ce2c:	e17ffe15 	stw	r5,-8(fp)
   1ce30:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_lcd_16207_dev* dev = (altera_avalon_lcd_16207_dev*) fd->dev; 
   1ce34:	e0bffd17 	ldw	r2,-12(fp)
   1ce38:	10800017 	ldw	r2,0(r2)
   1ce3c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_lcd_16207_write(&dev->state, buffer, space,
   1ce40:	e0bffc17 	ldw	r2,-16(fp)
   1ce44:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
   1ce48:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_lcd_16207_write_fd(alt_fd* fd, const char* buffer, int space)
{
    altera_avalon_lcd_16207_dev* dev = (altera_avalon_lcd_16207_dev*) fd->dev; 

    return altera_avalon_lcd_16207_write(&dev->state, buffer, space,
   1ce4c:	10800217 	ldw	r2,8(r2)
   1ce50:	1809883a 	mov	r4,r3
   1ce54:	e17ffe17 	ldw	r5,-8(fp)
   1ce58:	e1bfff17 	ldw	r6,-4(fp)
   1ce5c:	100f883a 	mov	r7,r2
   1ce60:	001c7500 	call	1c750 <altera_avalon_lcd_16207_write>
      fd->fd_flags);
}
   1ce64:	e037883a 	mov	sp,fp
   1ce68:	dfc00117 	ldw	ra,4(sp)
   1ce6c:	df000017 	ldw	fp,0(sp)
   1ce70:	dec00204 	addi	sp,sp,8
   1ce74:	f800283a 	ret

0001ce78 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   1ce78:	defffe04 	addi	sp,sp,-8
   1ce7c:	dfc00115 	stw	ra,4(sp)
   1ce80:	df000015 	stw	fp,0(sp)
   1ce84:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   1ce88:	008000f4 	movhi	r2,3
   1ce8c:	10a61304 	addi	r2,r2,-26548
   1ce90:	10800017 	ldw	r2,0(r2)
   1ce94:	10000526 	beq	r2,zero,1ceac <alt_get_errno+0x34>
   1ce98:	008000f4 	movhi	r2,3
   1ce9c:	10a61304 	addi	r2,r2,-26548
   1cea0:	10800017 	ldw	r2,0(r2)
   1cea4:	103ee83a 	callr	r2
   1cea8:	00000206 	br	1ceb4 <alt_get_errno+0x3c>
   1ceac:	008000f4 	movhi	r2,3
   1ceb0:	10aed404 	addi	r2,r2,-17584
}
   1ceb4:	e037883a 	mov	sp,fp
   1ceb8:	dfc00117 	ldw	ra,4(sp)
   1cebc:	df000017 	ldw	fp,0(sp)
   1cec0:	dec00204 	addi	sp,sp,8
   1cec4:	f800283a 	ret

0001cec8 <alt_avalon_sgdma_do_async_transfer>:
 * - 0 for success, or various errors defined in <errno.h>
 */
int alt_avalon_sgdma_do_async_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
   1cec8:	defffc04 	addi	sp,sp,-16
   1cecc:	df000315 	stw	fp,12(sp)
   1ced0:	df000304 	addi	fp,sp,12
   1ced4:	e13ffe15 	stw	r4,-8(fp)
   1ced8:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
   1cedc:	e0bffe17 	ldw	r2,-8(fp)
   1cee0:	10800317 	ldw	r2,12(r2)
   1cee4:	10800037 	ldwio	r2,0(r2)
   1cee8:	1080040c 	andi	r2,r2,16
   1ceec:	10000226 	beq	r2,zero,1cef8 <alt_avalon_sgdma_do_async_transfer+0x30>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
   1cef0:	00bffc04 	movi	r2,-16
   1cef4:	00003906 	br	1cfdc <alt_avalon_sgdma_do_async_transfer+0x114>
  }

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
   1cef8:	e0bffe17 	ldw	r2,-8(fp)
   1cefc:	10800317 	ldw	r2,12(r2)
   1cf00:	10800404 	addi	r2,r2,16
   1cf04:	e0fffe17 	ldw	r3,-8(fp)
   1cf08:	18c00317 	ldw	r3,12(r3)
   1cf0c:	18c00404 	addi	r3,r3,16
   1cf10:	19000037 	ldwio	r4,0(r3)
   1cf14:	00fff7c4 	movi	r3,-33
   1cf18:	20c6703a 	and	r3,r4,r3
   1cf1c:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
   1cf20:	e0bffe17 	ldw	r2,-8(fp)
   1cf24:	10800317 	ldw	r2,12(r2)
   1cf28:	00c03fc4 	movi	r3,255
   1cf2c:	10c00035 	stwio	r3,0(r2)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
   1cf30:	e0bffe17 	ldw	r2,-8(fp)
   1cf34:	10800317 	ldw	r2,12(r2)
   1cf38:	10800804 	addi	r2,r2,32
   1cf3c:	e0ffff17 	ldw	r3,-4(fp)
   1cf40:	10c00035 	stwio	r3,0(r2)
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
   1cf44:	e0bffe17 	ldw	r2,-8(fp)
   1cf48:	10800917 	ldw	r2,36(r2)
   1cf4c:	10001126 	beq	r2,zero,1cf94 <alt_avalon_sgdma_do_async_transfer+0xcc>
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   1cf50:	e0bffe17 	ldw	r2,-8(fp)
   1cf54:	10800317 	ldw	r2,12(r2)
   1cf58:	10800404 	addi	r2,r2,16
   1cf5c:	10800037 	ldwio	r2,0(r2)
   1cf60:	e0bffd15 	stw	r2,-12(fp)

    control |= (dev->chain_control                          |
   1cf64:	e0bffe17 	ldw	r2,-8(fp)
   1cf68:	10c00b17 	ldw	r3,44(r2)
   1cf6c:	e0bffd17 	ldw	r2,-12(fp)
   1cf70:	1884b03a 	or	r2,r3,r2
   1cf74:	10801814 	ori	r2,r2,96
   1cf78:	e0bffd15 	stw	r2,-12(fp)
                ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK  );

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   1cf7c:	e0bffe17 	ldw	r2,-8(fp)
   1cf80:	10800317 	ldw	r2,12(r2)
   1cf84:	10800404 	addi	r2,r2,16
   1cf88:	e0fffd17 	ldw	r3,-12(fp)
   1cf8c:	10c00035 	stwio	r3,0(r2)
   1cf90:	00001106 	br	1cfd8 <alt_avalon_sgdma_do_async_transfer+0x110>
   *   - Run
   *   - Stop on an error with any particular descriptor
   *   - Disable interrupt generation
   */
  else {
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   1cf94:	e0bffe17 	ldw	r2,-8(fp)
   1cf98:	10800317 	ldw	r2,12(r2)
   1cf9c:	10800404 	addi	r2,r2,16
   1cfa0:	10800037 	ldwio	r2,0(r2)
   1cfa4:	e0bffd15 	stw	r2,-12(fp)

    control |= (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
   1cfa8:	e0bffd17 	ldw	r2,-12(fp)
   1cfac:	10801814 	ori	r2,r2,96
   1cfb0:	e0bffd15 	stw	r2,-12(fp)
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK );
    control &= ~ALTERA_AVALON_SGDMA_CONTROL_IE_GLOBAL_MSK;
   1cfb4:	e0fffd17 	ldw	r3,-12(fp)
   1cfb8:	00bffbc4 	movi	r2,-17
   1cfbc:	1884703a 	and	r2,r3,r2
   1cfc0:	e0bffd15 	stw	r2,-12(fp)

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   1cfc4:	e0bffe17 	ldw	r2,-8(fp)
   1cfc8:	10800317 	ldw	r2,12(r2)
   1cfcc:	10800404 	addi	r2,r2,16
   1cfd0:	e0fffd17 	ldw	r3,-12(fp)
   1cfd4:	10c00035 	stwio	r3,0(r2)

  /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
  return 0;
   1cfd8:	0005883a 	mov	r2,zero
}
   1cfdc:	e037883a 	mov	sp,fp
   1cfe0:	df000017 	ldw	fp,0(sp)
   1cfe4:	dec00104 	addi	sp,sp,4
   1cfe8:	f800283a 	ret

0001cfec <alt_avalon_sgdma_do_sync_transfer>:
 * - status: Content of SGDMA status register.
 */
alt_u8 alt_avalon_sgdma_do_sync_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
   1cfec:	defffc04 	addi	sp,sp,-16
   1cff0:	df000315 	stw	fp,12(sp)
   1cff4:	df000304 	addi	fp,sp,12
   1cff8:	e13ffe15 	stw	r4,-8(fp)
   1cffc:	e17fff15 	stw	r5,-4(fp)
  alt_u8 status;

  /* Wait for any pending transfers to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
   1d000:	0001883a 	nop
   1d004:	e0bffe17 	ldw	r2,-8(fp)
   1d008:	10800317 	ldw	r2,12(r2)
   1d00c:	10800037 	ldwio	r2,0(r2)
   1d010:	1080040c 	andi	r2,r2,16
   1d014:	103ffb1e 	bne	r2,zero,1d004 <alt_avalon_sgdma_do_sync_transfer+0x18>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );


  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
   1d018:	e0bffe17 	ldw	r2,-8(fp)
   1d01c:	10800317 	ldw	r2,12(r2)
   1d020:	10800404 	addi	r2,r2,16
   1d024:	e0fffe17 	ldw	r3,-8(fp)
   1d028:	18c00317 	ldw	r3,12(r3)
   1d02c:	18c00404 	addi	r3,r3,16
   1d030:	19000037 	ldwio	r4,0(r3)
   1d034:	00fff7c4 	movi	r3,-33
   1d038:	20c6703a 	and	r3,r4,r3
   1d03c:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
   1d040:	e0bffe17 	ldw	r2,-8(fp)
   1d044:	10800317 	ldw	r2,12(r2)
   1d048:	00c03fc4 	movi	r3,255
   1d04c:	10c00035 	stwio	r3,0(r2)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
   1d050:	e0bffe17 	ldw	r2,-8(fp)
   1d054:	10800317 	ldw	r2,12(r2)
   1d058:	10800804 	addi	r2,r2,32
   1d05c:	e0ffff17 	ldw	r3,-4(fp)
   1d060:	10c00035 	stwio	r3,0(r2)
   * Set up SGDMA controller to:
   * - Disable interrupt generation
   * - Run once a valid descriptor is written to controller
   * - Stop on an error with any particular descriptor
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
   1d064:	e0bffe17 	ldw	r2,-8(fp)
   1d068:	10800317 	ldw	r2,12(r2)
   1d06c:	10800404 	addi	r2,r2,16
   1d070:	e0fffe17 	ldw	r3,-8(fp)
   1d074:	18c00317 	ldw	r3,12(r3)
   1d078:	18c00404 	addi	r3,r3,16
   1d07c:	18c00037 	ldwio	r3,0(r3)
   1d080:	18c01814 	ori	r3,r3,96
   1d084:	10c00035 	stwio	r3,0(r2)
    (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK |
     ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK | 
     IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base)) );

  /* Wait for the descriptor (chain) to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
   1d088:	0001883a 	nop
   1d08c:	e0bffe17 	ldw	r2,-8(fp)
   1d090:	10800317 	ldw	r2,12(r2)
   1d094:	10800037 	ldwio	r2,0(r2)
   1d098:	1080040c 	andi	r2,r2,16
   1d09c:	103ffb1e 	bne	r2,zero,1d08c <alt_avalon_sgdma_do_sync_transfer+0xa0>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
   1d0a0:	e0bffe17 	ldw	r2,-8(fp)
   1d0a4:	10800317 	ldw	r2,12(r2)
   1d0a8:	10800404 	addi	r2,r2,16
   1d0ac:	e0fffe17 	ldw	r3,-8(fp)
   1d0b0:	18c00317 	ldw	r3,12(r3)
   1d0b4:	18c00404 	addi	r3,r3,16
   1d0b8:	19000037 	ldwio	r4,0(r3)
   1d0bc:	00fff7c4 	movi	r3,-33
   1d0c0:	20c6703a 	and	r3,r4,r3
   1d0c4:	10c00035 	stwio	r3,0(r2)
    (IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) &
     ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK) );

  /* Get & clear status register contents */
  status = IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base);
   1d0c8:	e0bffe17 	ldw	r2,-8(fp)
   1d0cc:	10800317 	ldw	r2,12(r2)
   1d0d0:	10800037 	ldwio	r2,0(r2)
   1d0d4:	e0bffd05 	stb	r2,-12(fp)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
   1d0d8:	e0bffe17 	ldw	r2,-8(fp)
   1d0dc:	10800317 	ldw	r2,12(r2)
   1d0e0:	00c03fc4 	movi	r3,255
   1d0e4:	10c00035 	stwio	r3,0(r2)

  return status;
   1d0e8:	e0bffd03 	ldbu	r2,-12(fp)
}
   1d0ec:	e037883a 	mov	sp,fp
   1d0f0:	df000017 	ldw	fp,0(sp)
   1d0f4:	dec00104 	addi	sp,sp,4
   1d0f8:	f800283a 	ret

0001d0fc <alt_avalon_sgdma_construct_mem_to_mem_desc>:
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
   1d0fc:	defff404 	addi	sp,sp,-48
   1d100:	dfc00b15 	stw	ra,44(sp)
   1d104:	df000a15 	stw	fp,40(sp)
   1d108:	df000a04 	addi	fp,sp,40
   1d10c:	e13ffb15 	stw	r4,-20(fp)
   1d110:	e17ffc15 	stw	r5,-16(fp)
   1d114:	e1bffd15 	stw	r6,-12(fp)
   1d118:	e1fffe15 	stw	r7,-8(fp)
   1d11c:	e0800217 	ldw	r2,8(fp)
   1d120:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
   1d124:	e0bfff0b 	ldhu	r2,-4(fp)
   1d128:	d8800015 	stw	r2,0(sp)
   1d12c:	e0800317 	ldw	r2,12(fp)
   1d130:	d8800115 	stw	r2,4(sp)
   1d134:	e0800417 	ldw	r2,16(fp)
   1d138:	d8800215 	stw	r2,8(sp)
   1d13c:	d8000315 	stw	zero,12(sp)
   1d140:	d8000415 	stw	zero,16(sp)
   1d144:	e13ffb17 	ldw	r4,-20(fp)
   1d148:	e17ffc17 	ldw	r5,-16(fp)
   1d14c:	e1bffd17 	ldw	r6,-12(fp)
   1d150:	e1fffe17 	ldw	r7,-8(fp)
   1d154:	001d16c0 	call	1d16c <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>
    write_addr, length, read_fixed, write_fixed, 0, 0);
}
   1d158:	e037883a 	mov	sp,fp
   1d15c:	dfc00117 	ldw	ra,4(sp)
   1d160:	df000017 	ldw	fp,0(sp)
   1d164:	dec00204 	addi	sp,sp,8
   1d168:	f800283a 	ret

0001d16c <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>:
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
   1d16c:	defff204 	addi	sp,sp,-56
   1d170:	dfc00d15 	stw	ra,52(sp)
   1d174:	df000c15 	stw	fp,48(sp)
   1d178:	df000c04 	addi	fp,sp,48
   1d17c:	e13ffb15 	stw	r4,-20(fp)
   1d180:	e17ffc15 	stw	r5,-16(fp)
   1d184:	e1bffd15 	stw	r6,-12(fp)
   1d188:	e1fffe15 	stw	r7,-8(fp)
   1d18c:	e0800217 	ldw	r2,8(fp)
   1d190:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
   1d194:	e0bfff0b 	ldhu	r2,-4(fp)
   1d198:	d8800015 	stw	r2,0(sp)
   1d19c:	d8000115 	stw	zero,4(sp)
   1d1a0:	e0800317 	ldw	r2,12(fp)
   1d1a4:	d8800215 	stw	r2,8(sp)
   1d1a8:	e0800417 	ldw	r2,16(fp)
   1d1ac:	d8800315 	stw	r2,12(sp)
   1d1b0:	e0800517 	ldw	r2,20(fp)
   1d1b4:	d8800415 	stw	r2,16(sp)
   1d1b8:	e0800617 	ldw	r2,24(fp)
   1d1bc:	d8800515 	stw	r2,20(sp)
   1d1c0:	d8000615 	stw	zero,24(sp)
   1d1c4:	e13ffb17 	ldw	r4,-20(fp)
   1d1c8:	e17ffc17 	ldw	r5,-16(fp)
   1d1cc:	e1bffd17 	ldw	r6,-12(fp)
   1d1d0:	e1fffe17 	ldw	r7,-8(fp)
   1d1d4:	001d6d80 	call	1d6d8 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    write_fixed,
    read_burst,
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in mem-to-mem mode
}
   1d1d8:	e037883a 	mov	sp,fp
   1d1dc:	dfc00117 	ldw	ra,4(sp)
   1d1e0:	df000017 	ldw	fp,0(sp)
   1d1e4:	dec00204 	addi	sp,sp,8
   1d1e8:	f800283a 	ret

0001d1ec <alt_avalon_sgdma_construct_stream_to_mem_desc>:
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
   1d1ec:	defff804 	addi	sp,sp,-32
   1d1f0:	dfc00715 	stw	ra,28(sp)
   1d1f4:	df000615 	stw	fp,24(sp)
   1d1f8:	df000604 	addi	fp,sp,24
   1d1fc:	e13ffc15 	stw	r4,-16(fp)
   1d200:	e17ffd15 	stw	r5,-12(fp)
   1d204:	e1bffe15 	stw	r6,-8(fp)
   1d208:	3805883a 	mov	r2,r7
   1d20c:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
   1d210:	e0bfff0b 	ldhu	r2,-4(fp)
   1d214:	e0c00217 	ldw	r3,8(fp)
   1d218:	d8c00015 	stw	r3,0(sp)
   1d21c:	d8000115 	stw	zero,4(sp)
   1d220:	e13ffc17 	ldw	r4,-16(fp)
   1d224:	e17ffd17 	ldw	r5,-12(fp)
   1d228:	e1bffe17 	ldw	r6,-8(fp)
   1d22c:	100f883a 	mov	r7,r2
   1d230:	001d2480 	call	1d248 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>
    length_or_eop, write_fixed, 0);
}
   1d234:	e037883a 	mov	sp,fp
   1d238:	dfc00117 	ldw	ra,4(sp)
   1d23c:	df000017 	ldw	fp,0(sp)
   1d240:	dec00204 	addi	sp,sp,8
   1d244:	f800283a 	ret

0001d248 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>:
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
   1d248:	defff304 	addi	sp,sp,-52
   1d24c:	dfc00c15 	stw	ra,48(sp)
   1d250:	df000b15 	stw	fp,44(sp)
   1d254:	df000b04 	addi	fp,sp,44
   1d258:	e13ffc15 	stw	r4,-16(fp)
   1d25c:	e17ffd15 	stw	r5,-12(fp)
   1d260:	e1bffe15 	stw	r6,-8(fp)
   1d264:	3805883a 	mov	r2,r7
   1d268:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
   1d26c:	e0bfff0b 	ldhu	r2,-4(fp)
   1d270:	d8800015 	stw	r2,0(sp)
   1d274:	d8000115 	stw	zero,4(sp)
   1d278:	d8000215 	stw	zero,8(sp)
   1d27c:	e0800217 	ldw	r2,8(fp)
   1d280:	d8800315 	stw	r2,12(sp)
   1d284:	d8000415 	stw	zero,16(sp)
   1d288:	e0800317 	ldw	r2,12(fp)
   1d28c:	d8800515 	stw	r2,20(sp)
   1d290:	d8000615 	stw	zero,24(sp)
   1d294:	e13ffc17 	ldw	r4,-16(fp)
   1d298:	e17ffd17 	ldw	r5,-12(fp)
   1d29c:	000d883a 	mov	r6,zero
   1d2a0:	e1fffe17 	ldw	r7,-8(fp)
   1d2a4:	001d6d80 	call	1d6d8 <alt_avalon_sgdma_construct_descriptor_burst>
    0x0,            // Read fixed: N/A in stream-to-mem mode
    write_fixed,
    0,              // Read_burst : N/A in stream-to-mem mode
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in stream-to-mem mode
}
   1d2a8:	e037883a 	mov	sp,fp
   1d2ac:	dfc00117 	ldw	ra,4(sp)
   1d2b0:	df000017 	ldw	fp,0(sp)
   1d2b4:	dec00204 	addi	sp,sp,8
   1d2b8:	f800283a 	ret

0001d2bc <alt_avalon_sgdma_construct_mem_to_stream_desc>:
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
   1d2bc:	defff404 	addi	sp,sp,-48
   1d2c0:	dfc00b15 	stw	ra,44(sp)
   1d2c4:	df000a15 	stw	fp,40(sp)
   1d2c8:	df000a04 	addi	fp,sp,40
   1d2cc:	e13ffb15 	stw	r4,-20(fp)
   1d2d0:	e17ffc15 	stw	r5,-16(fp)
   1d2d4:	e1bffd15 	stw	r6,-12(fp)
   1d2d8:	3805883a 	mov	r2,r7
   1d2dc:	e0c00517 	ldw	r3,20(fp)
   1d2e0:	e0bffe0d 	sth	r2,-8(fp)
   1d2e4:	e0ffff05 	stb	r3,-4(fp)
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
   1d2e8:	e0bffe0b 	ldhu	r2,-8(fp)
   1d2ec:	e0ffff03 	ldbu	r3,-4(fp)
   1d2f0:	e1000217 	ldw	r4,8(fp)
   1d2f4:	d9000015 	stw	r4,0(sp)
   1d2f8:	e1000317 	ldw	r4,12(fp)
   1d2fc:	d9000115 	stw	r4,4(sp)
   1d300:	e1000417 	ldw	r4,16(fp)
   1d304:	d9000215 	stw	r4,8(sp)
   1d308:	d8000315 	stw	zero,12(sp)
   1d30c:	d8c00415 	stw	r3,16(sp)
   1d310:	e13ffb17 	ldw	r4,-20(fp)
   1d314:	e17ffc17 	ldw	r5,-16(fp)
   1d318:	e1bffd17 	ldw	r6,-12(fp)
   1d31c:	100f883a 	mov	r7,r2
   1d320:	001d3380 	call	1d338 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>
    length, read_fixed, generate_sop, generate_eop, 0, atlantic_channel);

}
   1d324:	e037883a 	mov	sp,fp
   1d328:	dfc00117 	ldw	ra,4(sp)
   1d32c:	df000017 	ldw	fp,0(sp)
   1d330:	dec00204 	addi	sp,sp,8
   1d334:	f800283a 	ret

0001d338 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>:
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
   1d338:	defff204 	addi	sp,sp,-56
   1d33c:	dfc00d15 	stw	ra,52(sp)
   1d340:	df000c15 	stw	fp,48(sp)
   1d344:	df000c04 	addi	fp,sp,48
   1d348:	e13ffb15 	stw	r4,-20(fp)
   1d34c:	e17ffc15 	stw	r5,-16(fp)
   1d350:	e1bffd15 	stw	r6,-12(fp)
   1d354:	3805883a 	mov	r2,r7
   1d358:	e0c00617 	ldw	r3,24(fp)
   1d35c:	e0bffe0d 	sth	r2,-8(fp)
   1d360:	e0ffff05 	stb	r3,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
   1d364:	e0fffe0b 	ldhu	r3,-8(fp)
   1d368:	e0bfff03 	ldbu	r2,-4(fp)
   1d36c:	d8c00015 	stw	r3,0(sp)
   1d370:	e0c00417 	ldw	r3,16(fp)
   1d374:	d8c00115 	stw	r3,4(sp)
   1d378:	e0c00217 	ldw	r3,8(fp)
   1d37c:	d8c00215 	stw	r3,8(sp)
   1d380:	e0c00317 	ldw	r3,12(fp)
   1d384:	d8c00315 	stw	r3,12(sp)
   1d388:	e0c00517 	ldw	r3,20(fp)
   1d38c:	d8c00415 	stw	r3,16(sp)
   1d390:	d8000515 	stw	zero,20(sp)
   1d394:	d8800615 	stw	r2,24(sp)
   1d398:	e13ffb17 	ldw	r4,-20(fp)
   1d39c:	e17ffc17 	ldw	r5,-16(fp)
   1d3a0:	e1bffd17 	ldw	r6,-12(fp)
   1d3a4:	000f883a 	mov	r7,zero
   1d3a8:	001d6d80 	call	1d6d8 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    generate_sop,
    read_burst,
    0,                 // Write_burst : N/A in mem-to-stream mode
    atlantic_channel);
}
   1d3ac:	e037883a 	mov	sp,fp
   1d3b0:	dfc00117 	ldw	ra,4(sp)
   1d3b4:	df000017 	ldw	fp,0(sp)
   1d3b8:	dec00204 	addi	sp,sp,8
   1d3bc:	f800283a 	ret

0001d3c0 <alt_avalon_sgdma_register_callback>:
void alt_avalon_sgdma_register_callback(
  alt_sgdma_dev *dev,
  alt_avalon_sgdma_callback callback,
  alt_u32 chain_control,
  void *context)
{
   1d3c0:	defffb04 	addi	sp,sp,-20
   1d3c4:	df000415 	stw	fp,16(sp)
   1d3c8:	df000404 	addi	fp,sp,16
   1d3cc:	e13ffc15 	stw	r4,-16(fp)
   1d3d0:	e17ffd15 	stw	r5,-12(fp)
   1d3d4:	e1bffe15 	stw	r6,-8(fp)
   1d3d8:	e1ffff15 	stw	r7,-4(fp)
  dev->callback         = callback;
   1d3dc:	e0bffc17 	ldw	r2,-16(fp)
   1d3e0:	e0fffd17 	ldw	r3,-12(fp)
   1d3e4:	10c00915 	stw	r3,36(r2)
  dev->callback_context = context;
   1d3e8:	e0bffc17 	ldw	r2,-16(fp)
   1d3ec:	e0ffff17 	ldw	r3,-4(fp)
   1d3f0:	10c00a15 	stw	r3,40(r2)
  dev->chain_control    = chain_control;
   1d3f4:	e0bffc17 	ldw	r2,-16(fp)
   1d3f8:	e0fffe17 	ldw	r3,-8(fp)
   1d3fc:	10c00b15 	stw	r3,44(r2)
}
   1d400:	e037883a 	mov	sp,fp
   1d404:	df000017 	ldw	fp,0(sp)
   1d408:	dec00104 	addi	sp,sp,4
   1d40c:	f800283a 	ret

0001d410 <alt_avalon_sgdma_start>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct.
 */
void alt_avalon_sgdma_start(alt_sgdma_dev *dev)
{
   1d410:	defffd04 	addi	sp,sp,-12
   1d414:	df000215 	stw	fp,8(sp)
   1d418:	df000204 	addi	fp,sp,8
   1d41c:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   1d420:	e0bfff17 	ldw	r2,-4(fp)
   1d424:	10800317 	ldw	r2,12(r2)
   1d428:	10800404 	addi	r2,r2,16
   1d42c:	10800037 	ldwio	r2,0(r2)
   1d430:	e0bffe15 	stw	r2,-8(fp)
  control |= ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
   1d434:	e0bffe17 	ldw	r2,-8(fp)
   1d438:	10800814 	ori	r2,r2,32
   1d43c:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   1d440:	e0bfff17 	ldw	r2,-4(fp)
   1d444:	10800317 	ldw	r2,12(r2)
   1d448:	10800404 	addi	r2,r2,16
   1d44c:	e0fffe17 	ldw	r3,-8(fp)
   1d450:	10c00035 	stwio	r3,0(r2)
}
   1d454:	e037883a 	mov	sp,fp
   1d458:	df000017 	ldw	fp,0(sp)
   1d45c:	dec00104 	addi	sp,sp,4
   1d460:	f800283a 	ret

0001d464 <alt_avalon_sgdma_stop>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct
 */
void alt_avalon_sgdma_stop(alt_sgdma_dev *dev)
{
   1d464:	defffd04 	addi	sp,sp,-12
   1d468:	df000215 	stw	fp,8(sp)
   1d46c:	df000204 	addi	fp,sp,8
   1d470:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   1d474:	e0bfff17 	ldw	r2,-4(fp)
   1d478:	10800317 	ldw	r2,12(r2)
   1d47c:	10800404 	addi	r2,r2,16
   1d480:	10800037 	ldwio	r2,0(r2)
   1d484:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
   1d488:	e0fffe17 	ldw	r3,-8(fp)
   1d48c:	00bff7c4 	movi	r2,-33
   1d490:	1884703a 	and	r2,r3,r2
   1d494:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   1d498:	e0bfff17 	ldw	r2,-4(fp)
   1d49c:	10800317 	ldw	r2,12(r2)
   1d4a0:	10800404 	addi	r2,r2,16
   1d4a4:	e0fffe17 	ldw	r3,-8(fp)
   1d4a8:	10c00035 	stwio	r3,0(r2)
}
   1d4ac:	e037883a 	mov	sp,fp
   1d4b0:	df000017 	ldw	fp,0(sp)
   1d4b4:	dec00104 	addi	sp,sp,4
   1d4b8:	f800283a 	ret

0001d4bc <alt_avalon_sgdma_check_descriptor_status>:
 * - 0 if the descriptor is error-free, not "owned by hardware", or
 *   a previously requested transfer has appeared to have completed
 *   normally. Or, various error conditions defined in <errno.h>
 */
int alt_avalon_sgdma_check_descriptor_status(alt_sgdma_descriptor *desc)
{
   1d4bc:	defffe04 	addi	sp,sp,-8
   1d4c0:	df000115 	stw	fp,4(sp)
   1d4c4:	df000104 	addi	fp,sp,4
   1d4c8:	e13fff15 	stw	r4,-4(fp)
  /* Errors take precedence */
  if( IORD_8DIRECT(&desc->status, 0) &
   1d4cc:	e0bfff17 	ldw	r2,-4(fp)
   1d4d0:	10800784 	addi	r2,r2,30
   1d4d4:	10800023 	ldbuio	r2,0(r2)
   1d4d8:	10803fcc 	andi	r2,r2,255
   1d4dc:	10801fcc 	andi	r2,r2,127
   1d4e0:	10000226 	beq	r2,zero,1d4ec <alt_avalon_sgdma_check_descriptor_status+0x30>
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
   1d4e4:	00bffec4 	movi	r2,-5
   1d4e8:	00000906 	br	1d510 <alt_avalon_sgdma_check_descriptor_status+0x54>
  }

  if( IORD_8DIRECT(&desc->control, 0) &
   1d4ec:	e0bfff17 	ldw	r2,-4(fp)
   1d4f0:	108007c4 	addi	r2,r2,31
   1d4f4:	10800023 	ldbuio	r2,0(r2)
   1d4f8:	10803fcc 	andi	r2,r2,255
   1d4fc:	1080200c 	andi	r2,r2,128
   1d500:	10000226 	beq	r2,zero,1d50c <alt_avalon_sgdma_check_descriptor_status+0x50>
      ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK) {
    return -EINPROGRESS;
   1d504:	00bfe244 	movi	r2,-119
   1d508:	00000106 	br	1d510 <alt_avalon_sgdma_check_descriptor_status+0x54>
  }

    return 0;
   1d50c:	0005883a 	mov	r2,zero
}
   1d510:	e037883a 	mov	sp,fp
   1d514:	df000017 	ldw	fp,0(sp)
   1d518:	dec00104 	addi	sp,sp,4
   1d51c:	f800283a 	ret

0001d520 <alt_avalon_sgdma_open>:
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
   1d520:	defffc04 	addi	sp,sp,-16
   1d524:	dfc00315 	stw	ra,12(sp)
   1d528:	df000215 	stw	fp,8(sp)
   1d52c:	df000204 	addi	fp,sp,8
   1d530:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
   1d534:	e13fff17 	ldw	r4,-4(fp)
   1d538:	d1601b04 	addi	r5,gp,-32660
   1d53c:	002210c0 	call	2210c <alt_find_dev>
   1d540:	e0bffe15 	stw	r2,-8(fp)

  if (NULL == dev) {
   1d544:	e0bffe17 	ldw	r2,-8(fp)
   1d548:	1000031e 	bne	r2,zero,1d558 <alt_avalon_sgdma_open+0x38>
    ALT_ERRNO = ENODEV;
   1d54c:	001ce780 	call	1ce78 <alt_get_errno>
   1d550:	00c004c4 	movi	r3,19
   1d554:	10c00015 	stw	r3,0(r2)
  }

  return dev;
   1d558:	e0bffe17 	ldw	r2,-8(fp)
}
   1d55c:	e037883a 	mov	sp,fp
   1d560:	dfc00117 	ldw	ra,4(sp)
   1d564:	df000017 	ldw	fp,0(sp)
   1d568:	dec00204 	addi	sp,sp,8
   1d56c:	f800283a 	ret

0001d570 <alt_avalon_sgdma_construct_descriptor>:
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
   1d570:	defff104 	addi	sp,sp,-60
   1d574:	dfc00e15 	stw	ra,56(sp)
   1d578:	df000d15 	stw	fp,52(sp)
   1d57c:	df000d04 	addi	fp,sp,52
   1d580:	e13ffa15 	stw	r4,-24(fp)
   1d584:	e17ffb15 	stw	r5,-20(fp)
   1d588:	e1bffc15 	stw	r6,-16(fp)
   1d58c:	e1fffd15 	stw	r7,-12(fp)
   1d590:	e0c00217 	ldw	r3,8(fp)
   1d594:	e0800617 	ldw	r2,24(fp)
   1d598:	e0fffe0d 	sth	r3,-8(fp)
   1d59c:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
   1d5a0:	e0fffe0b 	ldhu	r3,-8(fp)
   1d5a4:	e0bfff03 	ldbu	r2,-4(fp)
   1d5a8:	d8c00015 	stw	r3,0(sp)
   1d5ac:	e0c00317 	ldw	r3,12(fp)
   1d5b0:	d8c00115 	stw	r3,4(sp)
   1d5b4:	e0c00417 	ldw	r3,16(fp)
   1d5b8:	d8c00215 	stw	r3,8(sp)
   1d5bc:	e0c00517 	ldw	r3,20(fp)
   1d5c0:	d8c00315 	stw	r3,12(sp)
   1d5c4:	d8000415 	stw	zero,16(sp)
   1d5c8:	d8000515 	stw	zero,20(sp)
   1d5cc:	d8800615 	stw	r2,24(sp)
   1d5d0:	e13ffa17 	ldw	r4,-24(fp)
   1d5d4:	e17ffb17 	ldw	r5,-20(fp)
   1d5d8:	e1bffc17 	ldw	r6,-16(fp)
   1d5dc:	e1fffd17 	ldw	r7,-12(fp)
   1d5e0:	001d6d80 	call	1d6d8 <alt_avalon_sgdma_construct_descriptor_burst>
    write_addr, length_or_eop, generate_eop, read_fixed, write_fixed_or_sop, 
    0, 0, atlantic_channel);
}
   1d5e4:	e037883a 	mov	sp,fp
   1d5e8:	dfc00117 	ldw	ra,4(sp)
   1d5ec:	df000017 	ldw	fp,0(sp)
   1d5f0:	dec00204 	addi	sp,sp,8
   1d5f4:	f800283a 	ret

0001d5f8 <alt_avalon_sgdma_enable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_enable_desc_poll(alt_sgdma_dev *dev, alt_u32 frequency)
{
   1d5f8:	defffc04 	addi	sp,sp,-16
   1d5fc:	df000315 	stw	fp,12(sp)
   1d600:	df000304 	addi	fp,sp,12
   1d604:	e13ffe15 	stw	r4,-8(fp)
   1d608:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   1d60c:	e0bffe17 	ldw	r2,-8(fp)
   1d610:	10800317 	ldw	r2,12(r2)
   1d614:	10800404 	addi	r2,r2,16
   1d618:	10800037 	ldwio	r2,0(r2)
   1d61c:	e0bffd15 	stw	r2,-12(fp)
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
   1d620:	e0fffd17 	ldw	r3,-12(fp)
   1d624:	00a00434 	movhi	r2,32784
   1d628:	10bfffc4 	addi	r2,r2,-1
   1d62c:	1884703a 	and	r2,r3,r2
   1d630:	e0bffd15 	stw	r2,-12(fp)
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
   1d634:	e0bfff17 	ldw	r2,-4(fp)
   1d638:	1004953a 	slli	r2,r2,20
   1d63c:	10dffc2c 	andhi	r3,r2,32752

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
   1d640:	e0bffd17 	ldw	r2,-12(fp)
   1d644:	1884b03a 	or	r2,r3,r2
   1d648:	10800134 	orhi	r2,r2,4
   1d64c:	e0bffd15 	stw	r2,-12(fp)
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   1d650:	e0bffe17 	ldw	r2,-8(fp)
   1d654:	10800317 	ldw	r2,12(r2)
   1d658:	10800404 	addi	r2,r2,16
   1d65c:	e0fffd17 	ldw	r3,-12(fp)
   1d660:	10c00035 	stwio	r3,0(r2)
  
  return;
   1d664:	0001883a 	nop
}
   1d668:	e037883a 	mov	sp,fp
   1d66c:	df000017 	ldw	fp,0(sp)
   1d670:	dec00104 	addi	sp,sp,4
   1d674:	f800283a 	ret

0001d678 <alt_avalon_sgdma_disable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_disable_desc_poll(alt_sgdma_dev *dev)
{
   1d678:	defffd04 	addi	sp,sp,-12
   1d67c:	df000215 	stw	fp,8(sp)
   1d680:	df000204 	addi	fp,sp,8
   1d684:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   1d688:	e0bfff17 	ldw	r2,-4(fp)
   1d68c:	10800317 	ldw	r2,12(r2)
   1d690:	10800404 	addi	r2,r2,16
   1d694:	10800037 	ldwio	r2,0(r2)
   1d698:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK;
   1d69c:	e0fffe17 	ldw	r3,-8(fp)
   1d6a0:	00bfff34 	movhi	r2,65532
   1d6a4:	10bfffc4 	addi	r2,r2,-1
   1d6a8:	1884703a 	and	r2,r3,r2
   1d6ac:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   1d6b0:	e0bfff17 	ldw	r2,-4(fp)
   1d6b4:	10800317 	ldw	r2,12(r2)
   1d6b8:	10800404 	addi	r2,r2,16
   1d6bc:	e0fffe17 	ldw	r3,-8(fp)
   1d6c0:	10c00035 	stwio	r3,0(r2)
  
  return;
   1d6c4:	0001883a 	nop
}
   1d6c8:	e037883a 	mov	sp,fp
   1d6cc:	df000017 	ldw	fp,0(sp)
   1d6d0:	dec00104 	addi	sp,sp,4
   1d6d4:	f800283a 	ret

0001d6d8 <alt_avalon_sgdma_construct_descriptor_burst>:
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
   1d6d8:	defff804 	addi	sp,sp,-32
   1d6dc:	dfc00715 	stw	ra,28(sp)
   1d6e0:	df000615 	stw	fp,24(sp)
   1d6e4:	df000604 	addi	fp,sp,24
   1d6e8:	e13ffa15 	stw	r4,-24(fp)
   1d6ec:	e17ffb15 	stw	r5,-20(fp)
   1d6f0:	e1bffc15 	stw	r6,-16(fp)
   1d6f4:	e1fffd15 	stw	r7,-12(fp)
   1d6f8:	e0c00217 	ldw	r3,8(fp)
   1d6fc:	e0800817 	ldw	r2,32(fp)
   1d700:	e0fffe0d 	sth	r3,-8(fp)
   1d704:	e0bfff05 	stb	r2,-4(fp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
   1d708:	e0bffb17 	ldw	r2,-20(fp)
   1d70c:	108007c4 	addi	r2,r2,31
   1d710:	e0fffb17 	ldw	r3,-20(fp)
   1d714:	18c007c3 	ldbu	r3,31(r3)
   1d718:	19003fcc 	andi	r4,r3,255
   1d71c:	00ffdfc4 	movi	r3,-129
   1d720:	20c6703a 	and	r3,r4,r3
   1d724:	10c00025 	stbio	r3,0(r2)
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
   1d728:	e0bffa17 	ldw	r2,-24(fp)
   1d72c:	e0fffc17 	ldw	r3,-16(fp)
   1d730:	18c03fcc 	andi	r3,r3,255
   1d734:	11000003 	ldbu	r4,0(r2)
   1d738:	2008703a 	and	r4,r4,zero
   1d73c:	20c6b03a 	or	r3,r4,r3
   1d740:	10c00005 	stb	r3,0(r2)
   1d744:	e0fffc17 	ldw	r3,-16(fp)
   1d748:	1806d23a 	srli	r3,r3,8
   1d74c:	18c03fcc 	andi	r3,r3,255
   1d750:	11000043 	ldbu	r4,1(r2)
   1d754:	2008703a 	and	r4,r4,zero
   1d758:	20c6b03a 	or	r3,r4,r3
   1d75c:	10c00045 	stb	r3,1(r2)
   1d760:	e0fffc17 	ldw	r3,-16(fp)
   1d764:	1806d43a 	srli	r3,r3,16
   1d768:	18c03fcc 	andi	r3,r3,255
   1d76c:	11000083 	ldbu	r4,2(r2)
   1d770:	2008703a 	and	r4,r4,zero
   1d774:	20c6b03a 	or	r3,r4,r3
   1d778:	10c00085 	stb	r3,2(r2)
   1d77c:	e0fffc17 	ldw	r3,-16(fp)
   1d780:	1806d63a 	srli	r3,r3,24
   1d784:	110000c3 	ldbu	r4,3(r2)
   1d788:	2008703a 	and	r4,r4,zero
   1d78c:	20c6b03a 	or	r3,r4,r3
   1d790:	10c000c5 	stb	r3,3(r2)
  desc->write_addr               = write_addr;
   1d794:	e0bffa17 	ldw	r2,-24(fp)
   1d798:	e0fffd17 	ldw	r3,-12(fp)
   1d79c:	18c03fcc 	andi	r3,r3,255
   1d7a0:	11000203 	ldbu	r4,8(r2)
   1d7a4:	2008703a 	and	r4,r4,zero
   1d7a8:	20c6b03a 	or	r3,r4,r3
   1d7ac:	10c00205 	stb	r3,8(r2)
   1d7b0:	e0fffd17 	ldw	r3,-12(fp)
   1d7b4:	1806d23a 	srli	r3,r3,8
   1d7b8:	18c03fcc 	andi	r3,r3,255
   1d7bc:	11000243 	ldbu	r4,9(r2)
   1d7c0:	2008703a 	and	r4,r4,zero
   1d7c4:	20c6b03a 	or	r3,r4,r3
   1d7c8:	10c00245 	stb	r3,9(r2)
   1d7cc:	e0fffd17 	ldw	r3,-12(fp)
   1d7d0:	1806d43a 	srli	r3,r3,16
   1d7d4:	18c03fcc 	andi	r3,r3,255
   1d7d8:	11000283 	ldbu	r4,10(r2)
   1d7dc:	2008703a 	and	r4,r4,zero
   1d7e0:	20c6b03a 	or	r3,r4,r3
   1d7e4:	10c00285 	stb	r3,10(r2)
   1d7e8:	e0fffd17 	ldw	r3,-12(fp)
   1d7ec:	1806d63a 	srli	r3,r3,24
   1d7f0:	110002c3 	ldbu	r4,11(r2)
   1d7f4:	2008703a 	and	r4,r4,zero
   1d7f8:	20c6b03a 	or	r3,r4,r3
   1d7fc:	10c002c5 	stb	r3,11(r2)
  desc->next                     = (alt_u32 *) next;
   1d800:	e0bffa17 	ldw	r2,-24(fp)
   1d804:	e0fffb17 	ldw	r3,-20(fp)
   1d808:	18c03fcc 	andi	r3,r3,255
   1d80c:	11000403 	ldbu	r4,16(r2)
   1d810:	2008703a 	and	r4,r4,zero
   1d814:	20c6b03a 	or	r3,r4,r3
   1d818:	10c00405 	stb	r3,16(r2)
   1d81c:	e0fffb17 	ldw	r3,-20(fp)
   1d820:	1806d23a 	srli	r3,r3,8
   1d824:	18c03fcc 	andi	r3,r3,255
   1d828:	11000443 	ldbu	r4,17(r2)
   1d82c:	2008703a 	and	r4,r4,zero
   1d830:	20c6b03a 	or	r3,r4,r3
   1d834:	10c00445 	stb	r3,17(r2)
   1d838:	e0fffb17 	ldw	r3,-20(fp)
   1d83c:	1806d43a 	srli	r3,r3,16
   1d840:	18c03fcc 	andi	r3,r3,255
   1d844:	11000483 	ldbu	r4,18(r2)
   1d848:	2008703a 	and	r4,r4,zero
   1d84c:	20c6b03a 	or	r3,r4,r3
   1d850:	10c00485 	stb	r3,18(r2)
   1d854:	e0fffb17 	ldw	r3,-20(fp)
   1d858:	1806d63a 	srli	r3,r3,24
   1d85c:	110004c3 	ldbu	r4,19(r2)
   1d860:	2008703a 	and	r4,r4,zero
   1d864:	20c6b03a 	or	r3,r4,r3
   1d868:	10c004c5 	stb	r3,19(r2)
  desc->read_addr_pad            = 0x0;
   1d86c:	e0bffa17 	ldw	r2,-24(fp)
   1d870:	10c00103 	ldbu	r3,4(r2)
   1d874:	1806703a 	and	r3,r3,zero
   1d878:	10c00105 	stb	r3,4(r2)
   1d87c:	10c00143 	ldbu	r3,5(r2)
   1d880:	1806703a 	and	r3,r3,zero
   1d884:	10c00145 	stb	r3,5(r2)
   1d888:	10c00183 	ldbu	r3,6(r2)
   1d88c:	1806703a 	and	r3,r3,zero
   1d890:	10c00185 	stb	r3,6(r2)
   1d894:	10c001c3 	ldbu	r3,7(r2)
   1d898:	1806703a 	and	r3,r3,zero
   1d89c:	10c001c5 	stb	r3,7(r2)
  desc->write_addr_pad           = 0x0;
   1d8a0:	e0bffa17 	ldw	r2,-24(fp)
   1d8a4:	10c00303 	ldbu	r3,12(r2)
   1d8a8:	1806703a 	and	r3,r3,zero
   1d8ac:	10c00305 	stb	r3,12(r2)
   1d8b0:	10c00343 	ldbu	r3,13(r2)
   1d8b4:	1806703a 	and	r3,r3,zero
   1d8b8:	10c00345 	stb	r3,13(r2)
   1d8bc:	10c00383 	ldbu	r3,14(r2)
   1d8c0:	1806703a 	and	r3,r3,zero
   1d8c4:	10c00385 	stb	r3,14(r2)
   1d8c8:	10c003c3 	ldbu	r3,15(r2)
   1d8cc:	1806703a 	and	r3,r3,zero
   1d8d0:	10c003c5 	stb	r3,15(r2)
  desc->next_pad                 = 0x0;
   1d8d4:	e0bffa17 	ldw	r2,-24(fp)
   1d8d8:	10c00503 	ldbu	r3,20(r2)
   1d8dc:	1806703a 	and	r3,r3,zero
   1d8e0:	10c00505 	stb	r3,20(r2)
   1d8e4:	10c00543 	ldbu	r3,21(r2)
   1d8e8:	1806703a 	and	r3,r3,zero
   1d8ec:	10c00545 	stb	r3,21(r2)
   1d8f0:	10c00583 	ldbu	r3,22(r2)
   1d8f4:	1806703a 	and	r3,r3,zero
   1d8f8:	10c00585 	stb	r3,22(r2)
   1d8fc:	10c005c3 	ldbu	r3,23(r2)
   1d900:	1806703a 	and	r3,r3,zero
   1d904:	10c005c5 	stb	r3,23(r2)
  desc->bytes_to_transfer        = length_or_eop;
   1d908:	e0bffa17 	ldw	r2,-24(fp)
   1d90c:	e0fffe0b 	ldhu	r3,-8(fp)
   1d910:	18c03fcc 	andi	r3,r3,255
   1d914:	11000603 	ldbu	r4,24(r2)
   1d918:	2008703a 	and	r4,r4,zero
   1d91c:	20c6b03a 	or	r3,r4,r3
   1d920:	10c00605 	stb	r3,24(r2)
   1d924:	e0fffe0b 	ldhu	r3,-8(fp)
   1d928:	1806d23a 	srli	r3,r3,8
   1d92c:	18ffffcc 	andi	r3,r3,65535
   1d930:	11000643 	ldbu	r4,25(r2)
   1d934:	2008703a 	and	r4,r4,zero
   1d938:	20c6b03a 	or	r3,r4,r3
   1d93c:	10c00645 	stb	r3,25(r2)
  desc->actual_bytes_transferred = 0;
   1d940:	e0bffa17 	ldw	r2,-24(fp)
   1d944:	10c00703 	ldbu	r3,28(r2)
   1d948:	1806703a 	and	r3,r3,zero
   1d94c:	10c00705 	stb	r3,28(r2)
   1d950:	10c00743 	ldbu	r3,29(r2)
   1d954:	1806703a 	and	r3,r3,zero
   1d958:	10c00745 	stb	r3,29(r2)
  desc->status                   = 0x0;
   1d95c:	e0bffa17 	ldw	r2,-24(fp)
   1d960:	10000785 	stb	zero,30(r2)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
   1d964:	e0800617 	ldw	r2,24(fp)
   1d968:	1007883a 	mov	r3,r2
   1d96c:	e0bffa17 	ldw	r2,-24(fp)
   1d970:	10c00685 	stb	r3,26(r2)
  desc->write_burst              = write_burst;
   1d974:	e0800717 	ldw	r2,28(fp)
   1d978:	1007883a 	mov	r3,r2
   1d97c:	e0bffa17 	ldw	r2,-24(fp)
   1d980:	10c006c5 	stb	r3,27(r2)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
   1d984:	e0800317 	ldw	r2,12(fp)
   1d988:	10000226 	beq	r2,zero,1d994 <alt_avalon_sgdma_construct_descriptor_burst+0x2bc>
   1d98c:	00ffe044 	movi	r3,-127
   1d990:	00000106 	br	1d998 <alt_avalon_sgdma_construct_descriptor_burst+0x2c0>
   1d994:	00ffe004 	movi	r3,-128
   1d998:	e0800417 	ldw	r2,16(fp)
   1d99c:	10000226 	beq	r2,zero,1d9a8 <alt_avalon_sgdma_construct_descriptor_burst+0x2d0>
   1d9a0:	00800084 	movi	r2,2
   1d9a4:	00000106 	br	1d9ac <alt_avalon_sgdma_construct_descriptor_burst+0x2d4>
   1d9a8:	0005883a 	mov	r2,zero
   1d9ac:	1884b03a 	or	r2,r3,r2
   1d9b0:	1007883a 	mov	r3,r2
   1d9b4:	e0800517 	ldw	r2,20(fp)
   1d9b8:	10000226 	beq	r2,zero,1d9c4 <alt_avalon_sgdma_construct_descriptor_burst+0x2ec>
   1d9bc:	00800104 	movi	r2,4
   1d9c0:	00000106 	br	1d9c8 <alt_avalon_sgdma_construct_descriptor_burst+0x2f0>
   1d9c4:	0005883a 	mov	r2,zero
   1d9c8:	1884b03a 	or	r2,r3,r2
   1d9cc:	1007883a 	mov	r3,r2
   1d9d0:	e0bfff03 	ldbu	r2,-4(fp)
   1d9d4:	10000426 	beq	r2,zero,1d9e8 <alt_avalon_sgdma_construct_descriptor_burst+0x310>
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_GENERATE_EOP_MSK : 0x0)        |
    (read_fixed ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_READ_FIXED_ADDRESS_MSK : 0x0)  |
    (write_fixed_or_sop ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_WRITE_FIXED_ADDRESS_MSK : 0x0) |
    (atlantic_channel ? ( (atlantic_channel & 0x0F) << 3) : 0)
   1d9d8:	e0bfff03 	ldbu	r2,-4(fp)
   1d9dc:	108003cc 	andi	r2,r2,15
   1d9e0:	100490fa 	slli	r2,r2,3
   1d9e4:	00000106 	br	1d9ec <alt_avalon_sgdma_construct_descriptor_burst+0x314>
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
   1d9e8:	0005883a 	mov	r2,zero
   1d9ec:	1884b03a 	or	r2,r3,r2
   1d9f0:	1007883a 	mov	r3,r2
   1d9f4:	e0bffa17 	ldw	r2,-24(fp)
   1d9f8:	10c007c5 	stb	r3,31(r2)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to
   */
  alt_remap_uncached(desc, sizeof(alt_sgdma_descriptor));
   1d9fc:	e13ffa17 	ldw	r4,-24(fp)
   1da00:	01400804 	movi	r5,32
   1da04:	00191880 	call	19188 <alt_remap_uncached>
}
   1da08:	e037883a 	mov	sp,fp
   1da0c:	dfc00117 	ldw	ra,4(sp)
   1da10:	df000017 	ldw	fp,0(sp)
   1da14:	dec00204 	addi	sp,sp,8
   1da18:	f800283a 	ret

0001da1c <alt_avalon_sgdma_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_sgdma_irq(void *context)
#else
static void alt_avalon_sgdma_irq(void *context, alt_u32 id)
#endif
{
   1da1c:	defff804 	addi	sp,sp,-32
   1da20:	dfc00715 	stw	ra,28(sp)
   1da24:	df000615 	stw	fp,24(sp)
   1da28:	df000604 	addi	fp,sp,24
   1da2c:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev *dev = (alt_sgdma_dev *) context;
   1da30:	e0bfff17 	ldw	r2,-4(fp)
   1da34:	e0bffa15 	stw	r2,-24(fp)
   * Note: This is explicitly done before calling user interrupt-handling
   * code rather than after; if user ISR code initiates another SGDMA
   * transfer which completes quickly, reading the control register after
   * the callback routine may result in a lost interrupt.
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
   1da38:	e0bffa17 	ldw	r2,-24(fp)
   1da3c:	10800317 	ldw	r2,12(r2)
   1da40:	10800404 	addi	r2,r2,16
   1da44:	e0fffa17 	ldw	r3,-24(fp)
   1da48:	18c00317 	ldw	r3,12(r3)
   1da4c:	18c00404 	addi	r3,r3,16
   1da50:	18c00037 	ldwio	r3,0(r3)
   1da54:	18e00034 	orhi	r3,r3,32768
   1da58:	10c00035 	stwio	r3,0(r2)
    IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) | 0x80000000);
  
  /* Dummy read to ensure IRQ is negated before the ISR returns */
  IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   1da5c:	e0bffa17 	ldw	r2,-24(fp)
   1da60:	10800317 	ldw	r2,12(r2)
   1da64:	10800404 	addi	r2,r2,16
   1da68:	10800037 	ldwio	r2,0(r2)
   * Other interrupts are explicitly disabled if callbacks
   * are registered because there is no guarantee that they are 
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
   1da6c:	e0bffa17 	ldw	r2,-24(fp)
   1da70:	10800917 	ldw	r2,36(r2)
   1da74:	10001d26 	beq	r2,zero,1daec <alt_avalon_sgdma_irq+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   1da78:	0005303a 	rdctl	r2,status
   1da7c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   1da80:	e0fffc17 	ldw	r3,-16(fp)
   1da84:	00bfff84 	movi	r2,-2
   1da88:	1884703a 	and	r2,r3,r2
   1da8c:	1001703a 	wrctl	status,r2
  
  return context;
   1da90:	e0bffc17 	ldw	r2,-16(fp)
    cpu_sr = alt_irq_disable_all();
   1da94:	e0bffb15 	stw	r2,-20(fp)
    (dev->callback)(dev->callback_context);
   1da98:	e0bffa17 	ldw	r2,-24(fp)
   1da9c:	10c00917 	ldw	r3,36(r2)
   1daa0:	e0bffa17 	ldw	r2,-24(fp)
   1daa4:	10800a17 	ldw	r2,40(r2)
   1daa8:	1009883a 	mov	r4,r2
   1daac:	183ee83a 	callr	r3
   1dab0:	e0bffb17 	ldw	r2,-20(fp)
   1dab4:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   1dab8:	0005303a 	rdctl	r2,status
   1dabc:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   1dac0:	e0fffe17 	ldw	r3,-8(fp)
   1dac4:	00bfff84 	movi	r2,-2
   1dac8:	1884703a 	and	r2,r3,r2
   1dacc:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   1dad0:	e0bffd17 	ldw	r2,-12(fp)
   1dad4:	1080004c 	andi	r2,r2,1
   1dad8:	e0fffe17 	ldw	r3,-8(fp)
   1dadc:	1884b03a 	or	r2,r3,r2
   1dae0:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
   1dae4:	e0bffe17 	ldw	r2,-8(fp)
   1dae8:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(cpu_sr);
  }
}
   1daec:	e037883a 	mov	sp,fp
   1daf0:	dfc00117 	ldw	ra,4(sp)
   1daf4:	df000017 	ldw	fp,0(sp)
   1daf8:	dec00204 	addi	sp,sp,8
   1dafc:	f800283a 	ret

0001db00 <alt_avalon_sgdma_init>:
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
   1db00:	defffa04 	addi	sp,sp,-24
   1db04:	dfc00515 	stw	ra,20(sp)
   1db08:	df000415 	stw	fp,16(sp)
   1db0c:	df000404 	addi	fp,sp,16
   1db10:	e13ffd15 	stw	r4,-12(fp)
   1db14:	e17ffe15 	stw	r5,-8(fp)
   1db18:	e1bfff15 	stw	r6,-4(fp)

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
   1db1c:	e0bffd17 	ldw	r2,-12(fp)
   1db20:	10800317 	ldw	r2,12(r2)
   1db24:	10800404 	addi	r2,r2,16
   1db28:	00c00074 	movhi	r3,1
   1db2c:	10c00035 	stwio	r3,0(r2)
    ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
   1db30:	e0bffd17 	ldw	r2,-12(fp)
   1db34:	10800317 	ldw	r2,12(r2)
   1db38:	10800404 	addi	r2,r2,16
   1db3c:	00c00074 	movhi	r3,1
   1db40:	10c00035 	stwio	r3,0(r2)

  /*
   * Disable interrupts, halt future descriptor processing,
   * and clear status register content
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 0x0);
   1db44:	e0bffd17 	ldw	r2,-12(fp)
   1db48:	10800317 	ldw	r2,12(r2)
   1db4c:	10800404 	addi	r2,r2,16
   1db50:	0007883a 	mov	r3,zero
   1db54:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
   1db58:	e0bffd17 	ldw	r2,-12(fp)
   1db5c:	10800317 	ldw	r2,12(r2)
   1db60:	00c03fc4 	movi	r3,255
   1db64:	10c00035 	stwio	r3,0(r2)

  /* Register this instance of the SGDMA controller with HAL */
  alt_dev_llist_insert((alt_dev_llist*) dev, &alt_sgdma_list);
   1db68:	e13ffd17 	ldw	r4,-12(fp)
   1db6c:	d1601b04 	addi	r5,gp,-32660
   1db70:	0021fb40 	call	21fb4 <alt_dev_llist_insert>

  /* Install IRQ handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(ic_id, irq, alt_avalon_sgdma_irq, dev, 0x0);
   1db74:	d8000015 	stw	zero,0(sp)
   1db78:	e13ffe17 	ldw	r4,-8(fp)
   1db7c:	e17fff17 	ldw	r5,-4(fp)
   1db80:	018000b4 	movhi	r6,2
   1db84:	31b68704 	addi	r6,r6,-9700
   1db88:	e1fffd17 	ldw	r7,-12(fp)
   1db8c:	0021ca40 	call	21ca4 <alt_ic_isr_register>
#else
  alt_irq_register(irq, dev, alt_avalon_sgdma_irq);
#endif  
}
   1db90:	e037883a 	mov	sp,fp
   1db94:	dfc00117 	ldw	ra,4(sp)
   1db98:	df000017 	ldw	fp,0(sp)
   1db9c:	dec00204 	addi	sp,sp,8
   1dba0:	f800283a 	ret

0001dba4 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
   1dba4:	defff904 	addi	sp,sp,-28
   1dba8:	dfc00615 	stw	ra,24(sp)
   1dbac:	df000515 	stw	fp,20(sp)
   1dbb0:	df000504 	addi	fp,sp,20
   1dbb4:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
   1dbb8:	0007883a 	mov	r3,zero
   1dbbc:	e0bfff17 	ldw	r2,-4(fp)
   1dbc0:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
   1dbc4:	e0bfff17 	ldw	r2,-4(fp)
   1dbc8:	10800104 	addi	r2,r2,4
   1dbcc:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   1dbd0:	0005303a 	rdctl	r2,status
   1dbd4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   1dbd8:	e0fffc17 	ldw	r3,-16(fp)
   1dbdc:	00bfff84 	movi	r2,-2
   1dbe0:	1884703a 	and	r2,r3,r2
   1dbe4:	1001703a 	wrctl	status,r2
  
  return context;
   1dbe8:	e0bffc17 	ldw	r2,-16(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
   1dbec:	e0bffb15 	stw	r2,-20(fp)
  alt_tick ();
   1dbf0:	00193940 	call	19394 <alt_tick>
   1dbf4:	e0bffb17 	ldw	r2,-20(fp)
   1dbf8:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   1dbfc:	0005303a 	rdctl	r2,status
   1dc00:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   1dc04:	e0fffe17 	ldw	r3,-8(fp)
   1dc08:	00bfff84 	movi	r2,-2
   1dc0c:	1884703a 	and	r2,r3,r2
   1dc10:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   1dc14:	e0bffd17 	ldw	r2,-12(fp)
   1dc18:	1080004c 	andi	r2,r2,1
   1dc1c:	e0fffe17 	ldw	r3,-8(fp)
   1dc20:	1884b03a 	or	r2,r3,r2
   1dc24:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
   1dc28:	e0bffe17 	ldw	r2,-8(fp)
   1dc2c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
   1dc30:	e037883a 	mov	sp,fp
   1dc34:	dfc00117 	ldw	ra,4(sp)
   1dc38:	df000017 	ldw	fp,0(sp)
   1dc3c:	dec00204 	addi	sp,sp,8
   1dc40:	f800283a 	ret

0001dc44 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
   1dc44:	defff804 	addi	sp,sp,-32
   1dc48:	dfc00715 	stw	ra,28(sp)
   1dc4c:	df000615 	stw	fp,24(sp)
   1dc50:	df000604 	addi	fp,sp,24
   1dc54:	e13ffc15 	stw	r4,-16(fp)
   1dc58:	e17ffd15 	stw	r5,-12(fp)
   1dc5c:	e1bffe15 	stw	r6,-8(fp)
   1dc60:	e1ffff15 	stw	r7,-4(fp)
   1dc64:	e0bfff17 	ldw	r2,-4(fp)
   1dc68:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
   1dc6c:	008000f4 	movhi	r2,3
   1dc70:	10aed804 	addi	r2,r2,-17568
   1dc74:	10800017 	ldw	r2,0(r2)
   1dc78:	1000041e 	bne	r2,zero,1dc8c <alt_avalon_timer_sc_init+0x48>
  {
    _alt_tick_rate = nticks;
   1dc7c:	008000f4 	movhi	r2,3
   1dc80:	10aed804 	addi	r2,r2,-17568
   1dc84:	e0fffb17 	ldw	r3,-20(fp)
   1dc88:	10c00015 	stw	r3,0(r2)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
   1dc8c:	e0bffc17 	ldw	r2,-16(fp)
   1dc90:	10800104 	addi	r2,r2,4
   1dc94:	00c001c4 	movi	r3,7
   1dc98:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
   1dc9c:	d8000015 	stw	zero,0(sp)
   1dca0:	e13ffd17 	ldw	r4,-12(fp)
   1dca4:	e17ffe17 	ldw	r5,-8(fp)
   1dca8:	018000b4 	movhi	r6,2
   1dcac:	31b6e904 	addi	r6,r6,-9308
   1dcb0:	e1fffc17 	ldw	r7,-16(fp)
   1dcb4:	0021ca40 	call	21ca4 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
   1dcb8:	e037883a 	mov	sp,fp
   1dcbc:	dfc00117 	ldw	ra,4(sp)
   1dcc0:	df000017 	ldw	fp,0(sp)
   1dcc4:	dec00204 	addi	sp,sp,8
   1dcc8:	f800283a 	ret

0001dccc <alt_timestamp_start>:
 * The return value of this function is 0 upon sucess and -1 if in timestamp
 * device has not been registered. 
 */

int alt_timestamp_start(void)
{
   1dccc:	defffe04 	addi	sp,sp,-8
   1dcd0:	df000115 	stw	fp,4(sp)
   1dcd4:	df000104 	addi	fp,sp,4
  void* base = altera_avalon_timer_ts_base;
   1dcd8:	008000f4 	movhi	r2,3
   1dcdc:	10aeda04 	addi	r2,r2,-17560
   1dce0:	10800017 	ldw	r2,0(r2)
   1dce4:	e0bfff15 	stw	r2,-4(fp)

  if (!altera_avalon_timer_ts_freq)
   1dce8:	008000f4 	movhi	r2,3
   1dcec:	10aedb04 	addi	r2,r2,-17556
   1dcf0:	10800017 	ldw	r2,0(r2)
   1dcf4:	1000021e 	bne	r2,zero,1dd00 <alt_timestamp_start+0x34>
  {
    return -1;
   1dcf8:	00bfffc4 	movi	r2,-1
   1dcfc:	00001106 	br	1dd44 <alt_timestamp_start+0x78>
        IOWR_ALTERA_AVALON_TIMER_PERIOD_1 (base, 0xFFFF);;
        IOWR_ALTERA_AVALON_TIMER_PERIOD_2 (base, 0xFFFF);
        IOWR_ALTERA_AVALON_TIMER_PERIOD_3 (base, 0xFFFF);
        IOWR_ALTERA_AVALON_TIMER_CONTROL (base, ALTERA_AVALON_TIMER_CONTROL_START_MSK);
    } else {
        IOWR_ALTERA_AVALON_TIMER_CONTROL (base,ALTERA_AVALON_TIMER_CONTROL_STOP_MSK);
   1dd00:	e0bfff17 	ldw	r2,-4(fp)
   1dd04:	10800104 	addi	r2,r2,4
   1dd08:	00c00204 	movi	r3,8
   1dd0c:	10c00035 	stwio	r3,0(r2)
        IOWR_ALTERA_AVALON_TIMER_PERIODL (base, 0xFFFF);
   1dd10:	e0bfff17 	ldw	r2,-4(fp)
   1dd14:	10800204 	addi	r2,r2,8
   1dd18:	00ffffd4 	movui	r3,65535
   1dd1c:	10c00035 	stwio	r3,0(r2)
        IOWR_ALTERA_AVALON_TIMER_PERIODH (base, 0xFFFF);
   1dd20:	e0bfff17 	ldw	r2,-4(fp)
   1dd24:	10800304 	addi	r2,r2,12
   1dd28:	00ffffd4 	movui	r3,65535
   1dd2c:	10c00035 	stwio	r3,0(r2)
        IOWR_ALTERA_AVALON_TIMER_CONTROL (base, ALTERA_AVALON_TIMER_CONTROL_START_MSK); 
   1dd30:	e0bfff17 	ldw	r2,-4(fp)
   1dd34:	10800104 	addi	r2,r2,4
   1dd38:	00c00104 	movi	r3,4
   1dd3c:	10c00035 	stwio	r3,0(r2)
    } 
  }
  return 0;
   1dd40:	0005883a 	mov	r2,zero
}
   1dd44:	e037883a 	mov	sp,fp
   1dd48:	df000017 	ldw	fp,0(sp)
   1dd4c:	dec00104 	addi	sp,sp,4
   1dd50:	f800283a 	ret

0001dd54 <alt_timestamp>:
 * The returned timestamp counts up from the last time the period register
 * was reset. 
 */

alt_timestamp_type alt_timestamp(void)
{
   1dd54:	defffc04 	addi	sp,sp,-16
   1dd58:	df000315 	stw	fp,12(sp)
   1dd5c:	df000304 	addi	fp,sp,12

  void* base = altera_avalon_timer_ts_base;
   1dd60:	008000f4 	movhi	r2,3
   1dd64:	10aeda04 	addi	r2,r2,-17560
   1dd68:	10800017 	ldw	r2,0(r2)
   1dd6c:	e0bffd15 	stw	r2,-12(fp)

  if (!altera_avalon_timer_ts_freq)
   1dd70:	008000f4 	movhi	r2,3
   1dd74:	10aedb04 	addi	r2,r2,-17556
   1dd78:	10800017 	ldw	r2,0(r2)
   1dd7c:	1000021e 	bne	r2,zero,1dd88 <alt_timestamp+0x34>
  {
	if(ALT_TIMESTAMP_COUNTER_SIZE == 64) {
        return 0xFFFFFFFFFFFFFFFFULL;
    } else {
        return 0xFFFFFFFF;
   1dd80:	00bfffc4 	movi	r2,-1
   1dd84:	00001306 	br	1ddd4 <alt_timestamp+0x80>
        alt_timestamp_type snap_2 = IORD_ALTERA_AVALON_TIMER_SNAP_2(base) & ALTERA_AVALON_TIMER_SNAP_2_MSK;
        alt_timestamp_type snap_3 = IORD_ALTERA_AVALON_TIMER_SNAP_3(base) & ALTERA_AVALON_TIMER_SNAP_3_MSK;
        
        return (0xFFFFFFFFFFFFFFFFULL - ( (snap_3 << 48) | (snap_2 << 32) | (snap_1 << 16) | (snap_0) ));
    } else {
        IOWR_ALTERA_AVALON_TIMER_SNAPL (base, 0);
   1dd88:	e0bffd17 	ldw	r2,-12(fp)
   1dd8c:	10800404 	addi	r2,r2,16
   1dd90:	0007883a 	mov	r3,zero
   1dd94:	10c00035 	stwio	r3,0(r2)
        alt_timestamp_type lower = IORD_ALTERA_AVALON_TIMER_SNAPL(base) & ALTERA_AVALON_TIMER_SNAPL_MSK;
   1dd98:	e0bffd17 	ldw	r2,-12(fp)
   1dd9c:	10800404 	addi	r2,r2,16
   1dda0:	10800037 	ldwio	r2,0(r2)
   1dda4:	10bfffcc 	andi	r2,r2,65535
   1dda8:	e0bffe15 	stw	r2,-8(fp)
        alt_timestamp_type upper = IORD_ALTERA_AVALON_TIMER_SNAPH(base) & ALTERA_AVALON_TIMER_SNAPH_MSK;
   1ddac:	e0bffd17 	ldw	r2,-12(fp)
   1ddb0:	10800504 	addi	r2,r2,20
   1ddb4:	10800037 	ldwio	r2,0(r2)
   1ddb8:	10bfffcc 	andi	r2,r2,65535
   1ddbc:	e0bfff15 	stw	r2,-4(fp)
        
        return (0xFFFFFFFF - ((upper << 16) | lower)); 
   1ddc0:	e0bfff17 	ldw	r2,-4(fp)
   1ddc4:	1006943a 	slli	r3,r2,16
   1ddc8:	e0bffe17 	ldw	r2,-8(fp)
   1ddcc:	1884b03a 	or	r2,r3,r2
   1ddd0:	0084303a 	nor	r2,zero,r2
    }  
  }
}
   1ddd4:	e037883a 	mov	sp,fp
   1ddd8:	df000017 	ldw	fp,0(sp)
   1dddc:	dec00104 	addi	sp,sp,4
   1dde0:	f800283a 	ret

0001dde4 <alt_timestamp_freq>:
 * Return the number of timestamp ticks per second. This will be 0 if no
 * timestamp device has been registered.
 */

alt_u32 alt_timestamp_freq(void)
{
   1dde4:	deffff04 	addi	sp,sp,-4
   1dde8:	df000015 	stw	fp,0(sp)
   1ddec:	d839883a 	mov	fp,sp
  return altera_avalon_timer_ts_freq;
   1ddf0:	008000f4 	movhi	r2,3
   1ddf4:	10aedb04 	addi	r2,r2,-17556
   1ddf8:	10800017 	ldw	r2,0(r2)
}
   1ddfc:	e037883a 	mov	sp,fp
   1de00:	df000017 	ldw	fp,0(sp)
   1de04:	dec00104 	addi	sp,sp,4
   1de08:	f800283a 	ret

0001de0c <DP83848C_link_status_read>:
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_u32 DP83848C_link_status_read(np_tse_mac *pmac) {
	alt_u32 link_status = 0;
	alt_u32 reg_status = IORD(&pmac->mdio1.reg10, 0);
   1de0c:	20c0b037 	ldwio	r3,704(r4)
	
	/* If speed == 10 Mbps */
	if(reg_status & 0x2) {
   1de10:	1880008c 	andi	r2,r3,2
   1de14:	10000526 	beq	r2,zero,1de2c <DP83848C_link_status_read+0x20>
		link_status |= 0x8;
   1de18:	00800204 	movi	r2,8
	else {
		link_status |= 0x4;
	}
	
	/* If duplex == Full */
	if(reg_status & 0x4) {
   1de1c:	18c0010c 	andi	r3,r3,4
   1de20:	18000126 	beq	r3,zero,1de28 <DP83848C_link_status_read+0x1c>
		link_status |= 0x1;
   1de24:	10800054 	ori	r2,r2,1
	}
	
	return link_status;
}
   1de28:	f800283a 	ret
	if(reg_status & 0x2) {
		link_status |= 0x8;
	}
	/* Else speed = 100 Mbps */
	else {
		link_status |= 0x4;
   1de2c:	00800104 	movi	r2,4
   1de30:	003ffa06 	br	1de1c <DP83848C_link_status_read+0x10>

0001de34 <marvell_phy_cfg>:

/* @Function Description: Additional configuration for Marvell PHY
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address of MAC group
 */
alt_32 marvell_phy_cfg(np_tse_mac *pmac) {
   1de34:	defffe04 	addi	sp,sp,-8
   1de38:	dc000015 	stw	r16,0(sp)
   1de3c:	2021883a 	mov	r16,r4
   1de40:	dfc00115 	stw	ra,4(sp)
    
	alt_u16 dat;
    
    /* If there is no link yet, we enable auto crossover and reset the PHY */
    if((IORD(&pmac->mdio1.STATUS, 0) & PCS_ST_an_done) == 0) {
   1de44:	2080a137 	ldwio	r2,644(r4)
   1de48:	1080080c 	andi	r2,r2,32
   1de4c:	10000d1e 	bne	r2,zero,1de84 <marvell_phy_cfg+0x50>
        tse_dprintf(5, "MARVELL : Enabling auto crossover\n");
   1de50:	010000b4 	movhi	r4,2
   1de54:	2118c304 	addi	r4,r4,25356
   1de58:	00106a40 	call	106a4 <puts>
        IOWR(&pmac->mdio1.CONTROL, 16, 0x0078);
   1de5c:	00801e04 	movi	r2,120
   1de60:	8080b035 	stwio	r2,704(r16)
        tse_dprintf(5, "MARVELL : PHY reset\n");
   1de64:	010000b4 	movhi	r4,2
   1de68:	2118cc04 	addi	r4,r4,25392
   1de6c:	00106a40 	call	106a4 <puts>
        dat = IORD(&pmac->mdio1.CONTROL, 0); 
   1de70:	8400a004 	addi	r16,r16,640
   1de74:	80800037 	ldwio	r2,0(r16)
        IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);        
   1de78:	10bfffcc 	andi	r2,r2,65535
   1de7c:	10a00014 	ori	r2,r2,32768
   1de80:	80800035 	stwio	r2,0(r16)
    }
    
    return 0;
}
   1de84:	0005883a 	mov	r2,zero
   1de88:	dfc00117 	ldw	ra,4(sp)
   1de8c:	dc000017 	ldw	r16,0(sp)
   1de90:	dec00204 	addi	sp,sp,8
   1de94:	f800283a 	ret

0001de98 <no_printf>:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void no_printf (char *fmt, ...) {}
   1de98:	defffd04 	addi	sp,sp,-12
   1de9c:	d9400015 	stw	r5,0(sp)
   1dea0:	d9800115 	stw	r6,4(sp)
   1dea4:	d9c00215 	stw	r7,8(sp)
   1dea8:	dec00304 	addi	sp,sp,12
   1deac:	f800283a 	ret

0001deb0 <tse_mac_initTransInfo2>:
                                        alt_32 cfgflags) {
                                              
        mi->base     = (np_tse_mac*)mac_base;
        mi->tx_sgdma = (alt_sgdma_dev *)tx_sgdma;
        mi->rx_sgdma = (alt_sgdma_dev *)rx_sgdma;
        mi->cfgflags = cfgflags;     
   1deb0:	d8800017 	ldw	r2,0(sp)
                                        alt_u32 mac_base,
                                        alt_32 tx_sgdma,
                                        alt_32 rx_sgdma,
                                        alt_32 cfgflags) {
                                              
        mi->base     = (np_tse_mac*)mac_base;
   1deb4:	21400015 	stw	r5,0(r4)
        mi->tx_sgdma = (alt_sgdma_dev *)tx_sgdma;
   1deb8:	21800115 	stw	r6,4(r4)
        mi->rx_sgdma = (alt_sgdma_dev *)rx_sgdma;
        mi->cfgflags = cfgflags;     
   1debc:	20800415 	stw	r2,16(r4)
                                        alt_32 rx_sgdma,
                                        alt_32 cfgflags) {
                                              
        mi->base     = (np_tse_mac*)mac_base;
        mi->tx_sgdma = (alt_sgdma_dev *)tx_sgdma;
        mi->rx_sgdma = (alt_sgdma_dev *)rx_sgdma;
   1dec0:	21c00215 	stw	r7,8(r4)
        mi->cfgflags = cfgflags;     
        return SUCCESS;
}
   1dec4:	0005883a 	mov	r2,zero
   1dec8:	f800283a 	ret

0001decc <tse_mac_sTxWrite>:
  * @param txDesc           Pointer to the transmit SGDMA descriptor
  * @return actual bytes transferred if ok, else error (-1)
  */
alt_32 tse_mac_sTxWrite( tse_mac_trans_info *mi, 
                       alt_sgdma_descriptor *txDesc)   
{ 
   1decc:	defffe04 	addi	sp,sp,-8
   1ded0:	dc000015 	stw	r16,0(sp)
   1ded4:	dfc00115 	stw	ra,4(sp)
   1ded8:	2821883a 	mov	r16,r5
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
   1dedc:	008003f4 	movhi	r2,15
   1dee0:	10909044 	addi	r2,r2,16961
   1dee4:	21c00117 	ldw	r7,4(r4)
   1dee8:	00000106 	br	1def0 <tse_mac_sTxWrite+0x24>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
           if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
   1deec:	10001326 	beq	r2,zero,1df3c <tse_mac_sTxWrite+0x70>
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
   1def0:	38c00317 	ldw	r3,12(r7)
   1def4:	19800037 	ldwio	r6,0(r3)
   1def8:	3180040c 	andi	r6,r6,16
   1defc:	10bfffc4 	addi	r2,r2,-1
   1df00:	303ffa1e 	bne	r6,zero,1deec <tse_mac_sTxWrite+0x20>
           }
  }

  // Set up the SGDMA
  // Clear the status and control bits of the SGDMA descriptor
  IOWR_ALTERA_AVALON_SGDMA_CONTROL (mi->tx_sgdma->base, 0);
   1df04:	18000435 	stwio	zero,16(r3)
  IOWR_ALTERA_AVALON_SGDMA_STATUS (mi->tx_sgdma->base, 0xFF);
   1df08:	20800117 	ldw	r2,4(r4)
   1df0c:	00c03fc4 	movi	r3,255
   1df10:	10800317 	ldw	r2,12(r2)
   1df14:	10c00035 	stwio	r3,0(r2)
  
  // Start SGDMA (blocking call)
  result = alt_avalon_sgdma_do_sync_transfer(
   1df18:	21000117 	ldw	r4,4(r4)
   1df1c:	800b883a 	mov	r5,r16
   1df20:	001cfec0 	call	1cfec <alt_avalon_sgdma_do_sync_transfer>
                mi->tx_sgdma, 
                (alt_sgdma_descriptor *) &txDesc[0]);
  
  /* perform cache save read to obtain actual bytes transferred for current sgdma descriptor */
  actualBytesTransferred = IORD_ALTERA_TSE_SGDMA_DESC_ACTUAL_BYTES_TRANSFERRED(&txDesc[0]);
   1df24:	80800737 	ldwio	r2,28(r16)

  return actualBytesTransferred;
   1df28:	10bfffcc 	andi	r2,r2,65535
}
   1df2c:	dfc00117 	ldw	ra,4(sp)
   1df30:	dc000017 	ldw	r16,0(sp)
   1df34:	dec00204 	addi	sp,sp,8
   1df38:	f800283a 	ret
  timeout = 0;
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
           if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
            tse_dprintf(4, "WARNING : TX SGDMA Timeout\n");
   1df3c:	010000b4 	movhi	r4,2
   1df40:	2118d104 	addi	r4,r4,25412
   1df44:	00106a40 	call	106a4 <puts>
            return ENP_RESOURCE;  // avoid being stuck here
   1df48:	00bffa84 	movi	r2,-22
  
  /* perform cache save read to obtain actual bytes transferred for current sgdma descriptor */
  actualBytesTransferred = IORD_ALTERA_TSE_SGDMA_DESC_ACTUAL_BYTES_TRANSFERRED(&txDesc[0]);

  return actualBytesTransferred;
}
   1df4c:	dfc00117 	ldw	ra,4(sp)
   1df50:	dc000017 	ldw	r16,0(sp)
   1df54:	dec00204 	addi	sp,sp,8
   1df58:	f800283a 	ret

0001df5c <tse_mac_aRxRead>:
  *        the actual bytes transferred for current descriptor
  */
alt_32 tse_mac_aRxRead( 
  tse_mac_trans_info *mi,       
  alt_sgdma_descriptor *rxDesc)  
{
   1df5c:	deffff04 	addi	sp,sp,-4
   1df60:	dfc00015 	stw	ra,0(sp)
  alt_u8 result = 0;
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
   1df64:	008003f4 	movhi	r2,15
   1df68:	10909044 	addi	r2,r2,16961
   1df6c:	21000217 	ldw	r4,8(r4)
   1df70:	00000106 	br	1df78 <tse_mac_aRxRead+0x1c>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
   1df74:	10000a26 	beq	r2,zero,1dfa0 <tse_mac_aRxRead+0x44>
  alt_u8 result = 0;
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
   1df78:	20c00317 	ldw	r3,12(r4)
   1df7c:	18c00037 	ldwio	r3,0(r3)
   1df80:	18c0040c 	andi	r3,r3,16
   1df84:	10bfffc4 	addi	r2,r2,-1
   1df88:	183ffa1e 	bne	r3,zero,1df74 <tse_mac_aRxRead+0x18>
    }
  }

 
  // SGDMA operation invoked for RX (non-blocking call)
  result = alt_avalon_sgdma_do_async_transfer(
   1df8c:	001cec80 	call	1cec8 <alt_avalon_sgdma_do_async_transfer>
                mi->rx_sgdma, 
                (alt_sgdma_descriptor *) &rxDesc[0]);

 
  return SUCCESS;
   1df90:	0005883a 	mov	r2,zero
}
   1df94:	dfc00017 	ldw	ra,0(sp)
   1df98:	dec00104 	addi	sp,sp,4
   1df9c:	f800283a 	ret
  timeout = 0;
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
        tse_dprintf(4, "WARNING : RX SGDMA Timeout\n");
   1dfa0:	010000b4 	movhi	r4,2
   1dfa4:	2118d804 	addi	r4,r4,25440
   1dfa8:	00106a40 	call	106a4 <puts>
        return ENP_RESOURCE;  // avoid being stuck here
   1dfac:	00bffa84 	movi	r2,-22
                mi->rx_sgdma, 
                (alt_sgdma_descriptor *) &rxDesc[0]);

 
  return SUCCESS;
}
   1dfb0:	dfc00017 	ldw	ra,0(sp)
   1dfb4:	dec00104 	addi	sp,sp,4
   1dfb8:	f800283a 	ret

0001dfbc <tse_mac_SwReset>:
alt_32 tse_mac_SwReset(np_tse_mac *pmac) 
{
	alt_32 timeout;
	alt_32 cc;
        
    cc = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
   1dfbc:	21000204 	addi	r4,r4,8
   1dfc0:	21400037 	ldwio	r5,0(r4)
    
    // set reset and Gig-Speed bits to make sure we have an incoming clock on
    // tx side. If there is a 10/100 PHY, we will still have a valid clock on
    // tx_clk no matter what setting we have here, but on a Gig phy the
    // MII clock may be missing.
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,(ALTERA_TSEMAC_CMD_SW_RESET_MSK | ALTERA_TSEMAC_CMD_ETH_SPEED_MSK));
   1dfc4:	00880204 	movi	r2,8200
   1dfc8:	20800035 	stwio	r2,0(r4)

    
    // wait for completion with fallback in case there is no PHY or it is
    // not connected and hence might not provide any clocks at all.
    timeout=0;
    while( (IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac) & ALTERA_TSEMAC_CMD_SW_RESET_MSK) != 0 && timeout < ALTERA_TSE_SW_RESET_TIME_OUT_CNT) timeout++;
   1dfcc:	0089c444 	movi	r2,10001
   1dfd0:	00000106 	br	1dfd8 <tse_mac_SwReset+0x1c>
   1dfd4:	10000426 	beq	r2,zero,1dfe8 <tse_mac_SwReset+0x2c>
   1dfd8:	20c00037 	ldwio	r3,0(r4)
   1dfdc:	18c8000c 	andi	r3,r3,8192
   1dfe0:	10bfffc4 	addi	r2,r2,-1
   1dfe4:	183ffb1e 	bne	r3,zero,1dfd4 <tse_mac_SwReset+0x18>
   
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,cc); // Restore
   1dfe8:	21400035 	stwio	r5,0(r4)
    return SUCCESS;
}
   1dfec:	0005883a 	mov	r2,zero
   1dff0:	f800283a 	ret

0001dff4 <tse_mac_setMIImode>:
*/
alt_32 tse_mac_setMIImode(np_tse_mac *pmac)
{
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
   1dff4:	21000204 	addi	r4,r4,8
   1dff8:	20c00037 	ldwio	r3,0(r4)
  helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK; 
   1dffc:	00bffdc4 	movi	r2,-9
   1e000:	1884703a 	and	r2,r3,r2
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
   1e004:	20800035 	stwio	r2,0(r4)
  return SUCCESS;
}
   1e008:	0005883a 	mov	r2,zero
   1e00c:	f800283a 	ret

0001e010 <tse_mac_setGMIImode>:
 */
alt_32 tse_mac_setGMIImode(np_tse_mac *pmac)
{
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
   1e010:	21000204 	addi	r4,r4,8
   1e014:	20800037 	ldwio	r2,0(r4)
  helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
   1e018:	10800214 	ori	r2,r2,8

  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
   1e01c:	20800035 	stwio	r2,0(r4)
  return SUCCESS;
}
   1e020:	0005883a 	mov	r2,zero
   1e024:	f800283a 	ret

0001e028 <alt_tse_phy_add_profile>:
 * @param  phy  pointer to alt_tse_phy_profile structure describing PHY registers
 * @return      index of PHY added in PHY profile on success, else return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 * PHY which are currently supported by default :  Marvell 88E1111, Marvell Quad PHY 88E1145, National DP83865, and National DP83848C
 */
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
   1e028:	defff904 	addi	sp,sp,-28
   1e02c:	dd000415 	stw	r20,16(sp)
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
   1e030:	d528df43 	ldbu	r20,-23683(gp)
 * @param  phy  pointer to alt_tse_phy_profile structure describing PHY registers
 * @return      index of PHY added in PHY profile on success, else return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 * PHY which are currently supported by default :  Marvell 88E1111, Marvell Quad PHY 88E1145, National DP83865, and National DP83848C
 */
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
   1e034:	dcc00315 	stw	r19,12(sp)
   1e038:	dfc00615 	stw	ra,24(sp)
   1e03c:	dd400515 	stw	r21,20(sp)
   1e040:	dc800215 	stw	r18,8(sp)
   1e044:	dc400115 	stw	r17,4(sp)
   1e048:	dc000015 	stw	r16,0(sp)
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
   1e04c:	a0803fcc 	andi	r2,r20,255
 * @param  phy  pointer to alt_tse_phy_profile structure describing PHY registers
 * @return      index of PHY added in PHY profile on success, else return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 * PHY which are currently supported by default :  Marvell 88E1111, Marvell Quad PHY 88E1145, National DP83865, and National DP83848C
 */
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
   1e050:	2027883a 	mov	r19,r4
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
   1e054:	10003526 	beq	r2,zero,1e12c <alt_tse_phy_add_profile+0x104>
   1e058:	054001f4 	movhi	r21,7
   1e05c:	ad54a504 	addi	r21,r21,21140
   1e060:	a823883a 	mov	r17,r21
   1e064:	0021883a 	mov	r16,zero
   1e068:	00000206 	br	1e074 <alt_tse_phy_add_profile+0x4c>
   1e06c:	a4803fcc 	andi	r18,r20,255
   1e070:	8480120e 	bge	r16,r18,1e0bc <alt_tse_phy_add_profile+0x94>
    {
        if(pphy_profiles[i]->oui == phy->oui && pphy_profiles[i]->model_number == phy->model_number)
   1e074:	88800017 	ldw	r2,0(r17)
   1e078:	99801417 	ldw	r6,80(r19)
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
   1e07c:	84000044 	addi	r16,r16,1
    {
        if(pphy_profiles[i]->oui == phy->oui && pphy_profiles[i]->model_number == phy->model_number)
   1e080:	11401417 	ldw	r5,80(r2)
   1e084:	8c400104 	addi	r17,r17,4
   1e088:	29bff81e 	bne	r5,r6,1e06c <alt_tse_phy_add_profile+0x44>
   1e08c:	11801503 	ldbu	r6,84(r2)
   1e090:	98801503 	ldbu	r2,84(r19)
   1e094:	30bff51e 	bne	r6,r2,1e06c <alt_tse_phy_add_profile+0x44>
        {
            tse_dprintf(4, "WARNING : PHY OUI 0x%06x, PHY Model Number 0x%02x already exist in PHY profile\n", (int) phy->oui, phy->model_number);
   1e098:	010000b4 	movhi	r4,2
   1e09c:	2118df04 	addi	r4,r4,25468
   1e0a0:	00104380 	call	10438 <printf>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
   1e0a4:	010000b4 	movhi	r4,2
   1e0a8:	2118f304 	addi	r4,r4,25548
   1e0ac:	00106a40 	call	106a4 <puts>
   1e0b0:	d528df43 	ldbu	r20,-23683(gp)
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
   1e0b4:	a4803fcc 	andi	r18,r20,255
   1e0b8:	84bfee16 	blt	r16,r18,1e074 <alt_tse_phy_add_profile+0x4c>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
        }
    }

    /* Allocate memory space to store the profile */    
    pphy_profiles[phy_profile_count] = (alt_tse_phy_profile *) malloc(sizeof(alt_tse_phy_profile));
   1e0bc:	01001904 	movi	r4,100
   1e0c0:	00231640 	call	23164 <malloc>
   1e0c4:	1007883a 	mov	r3,r2
   1e0c8:	9485883a 	add	r2,r18,r18
   1e0cc:	1085883a 	add	r2,r2,r2
   1e0d0:	a8ab883a 	add	r21,r21,r2
   1e0d4:	a8c00015 	stw	r3,0(r21)
    if(!pphy_profiles[phy_profile_count]) {
   1e0d8:	18001826 	beq	r3,zero,1e13c <alt_tse_phy_add_profile+0x114>
        tse_dprintf(1, "ERROR   : Unable to allocate memory for pphy_profile[%d]\n", phy_profile_count);
        return ALTERA_TSE_MALLOC_FAILED;
    }

    /* Store PHY information */
    *pphy_profiles[phy_profile_count] = *phy;
   1e0dc:	1809883a 	mov	r4,r3
   1e0e0:	01801904 	movi	r6,100
   1e0e4:	980b883a 	mov	r5,r19
   1e0e8:	00102380 	call	10238 <memcpy>
    strcpy(pphy_profiles[phy_profile_count]->name, phy->name);
   1e0ec:	1009883a 	mov	r4,r2
   1e0f0:	980b883a 	mov	r5,r19
   1e0f4:	002318c0 	call	2318c <strcpy>
    
    phy_profile_count++;
   1e0f8:	a5000044 	addi	r20,r20,1
    
    return phy_profile_count - 1;
   1e0fc:	a0803fcc 	andi	r2,r20,255

    /* Store PHY information */
    *pphy_profiles[phy_profile_count] = *phy;
    strcpy(pphy_profiles[phy_profile_count]->name, phy->name);
    
    phy_profile_count++;
   1e100:	d528df45 	stb	r20,-23683(gp)
    
    return phy_profile_count - 1;
   1e104:	10bfffc4 	addi	r2,r2,-1
}
   1e108:	dfc00617 	ldw	ra,24(sp)
   1e10c:	dd400517 	ldw	r21,20(sp)
   1e110:	dd000417 	ldw	r20,16(sp)
   1e114:	dcc00317 	ldw	r19,12(sp)
   1e118:	dc800217 	ldw	r18,8(sp)
   1e11c:	dc400117 	ldw	r17,4(sp)
   1e120:	dc000017 	ldw	r16,0(sp)
   1e124:	dec00704 	addi	sp,sp,28
   1e128:	f800283a 	ret
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
   1e12c:	0025883a 	mov	r18,zero
   1e130:	054001f4 	movhi	r21,7
   1e134:	ad54a504 	addi	r21,r21,21140
   1e138:	003fe006 	br	1e0bc <alt_tse_phy_add_profile+0x94>
    }

    /* Allocate memory space to store the profile */    
    pphy_profiles[phy_profile_count] = (alt_tse_phy_profile *) malloc(sizeof(alt_tse_phy_profile));
    if(!pphy_profiles[phy_profile_count]) {
        tse_dprintf(1, "ERROR   : Unable to allocate memory for pphy_profile[%d]\n", phy_profile_count);
   1e13c:	010000b4 	movhi	r4,2
   1e140:	21190b04 	addi	r4,r4,25644
   1e144:	900b883a 	mov	r5,r18
   1e148:	00104380 	call	10438 <printf>
        return ALTERA_TSE_MALLOC_FAILED;
   1e14c:	00bfffc4 	movi	r2,-1
   1e150:	003fed06 	br	1e108 <alt_tse_phy_add_profile+0xe0>

0001e154 <alt_tse_system_add_sys>:
alt_32 alt_tse_system_add_sys(
	alt_tse_system_mac					*psys_mac,
	alt_tse_system_sgdma				*psys_sgdma,
	alt_tse_system_desc_mem				*psys_mem,
	alt_tse_system_shared_fifo			*psys_shared_fifo,
	alt_tse_system_phy 					*psys_phy ) {
   1e154:	defff304 	addi	sp,sp,-52
   1e158:	df000b15 	stw	fp,44(sp)
   1e15c:	dfc00c15 	stw	ra,48(sp)
   1e160:	ddc00a15 	stw	r23,40(sp)
   1e164:	dd800915 	stw	r22,36(sp)
   1e168:	dd400815 	stw	r21,32(sp)
   1e16c:	dd000715 	stw	r20,28(sp)
   1e170:	dcc00615 	stw	r19,24(sp)
   1e174:	dc800515 	stw	r18,20(sp)
   1e178:	dc400415 	stw	r17,16(sp)
   1e17c:	dc000315 	stw	r16,12(sp)
	
	static alt_8 tse_system_count = 0;
	
	/* Determine number of loop */
	/* Run at least one for non-multi-channel MAC */
	if(pmac->tse_num_of_channel == 0) {
   1e180:	25c00303 	ldbu	r23,12(r4)
alt_32 alt_tse_system_add_sys(
	alt_tse_system_mac					*psys_mac,
	alt_tse_system_sgdma				*psys_sgdma,
	alt_tse_system_desc_mem				*psys_mem,
	alt_tse_system_shared_fifo			*psys_shared_fifo,
	alt_tse_system_phy 					*psys_phy ) {
   1e184:	2039883a 	mov	fp,r4
	
	static alt_8 tse_system_count = 0;
	
	/* Determine number of loop */
	/* Run at least one for non-multi-channel MAC */
	if(pmac->tse_num_of_channel == 0) {
   1e188:	b800a61e 	bne	r23,zero,1e424 <alt_tse_system_add_sys+0x2d0>
		loop_end = 1;
   1e18c:	00c00044 	movi	r3,1
   1e190:	d8c00115 	stw	r3,4(sp)
   1e194:	d4e8df83 	ldbu	r19,-23682(gp)
   1e198:	dd400d17 	ldw	r21,52(sp)
   1e19c:	382d883a 	mov	r22,r7
   1e1a0:	302f883a 	mov	r23,r6
   1e1a4:	2821883a 	mov	r16,r5
   1e1a8:	0023883a 	mov	r17,zero
	}

	for(i = 0; i < loop_end; i++) {
		
		/* Make sure the boundary of array is not exceeded */
		if(tse_system_count >= MAXNETS) {
   1e1ac:	98803fcc 	andi	r2,r19,255
   1e1b0:	1080201c 	xori	r2,r2,128
   1e1b4:	10bfe004 	addi	r2,r2,-128
   1e1b8:	d8800015 	stw	r2,0(sp)
   1e1bc:	00c001c4 	movi	r3,7
   1e1c0:	18807516 	blt	r3,r2,1e398 <alt_tse_system_add_sys+0x244>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys()\n");
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
		}		
		
		tse_mac_device[tse_system_count].tse_mac_base 					= pmac->tse_mac_base + (i * 0x400);
   1e1c4:	d8c00017 	ldw	r3,0(sp)
   1e1c8:	e2c00017 	ldw	r11,0(fp)
 * @param		psys_phy  pointer to alt_tse_system_phy structure describing PHY of the system
 * @return      SUCCESS on success
 * 				ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 * 				ALTERA_TSE_SYSTEM_DEF_ERROR if definition of system incorrect or pointer == NULL
 */
alt_32 alt_tse_system_add_sys(
   1e1cc:	880c92ba 	slli	r6,r17,10
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys()\n");
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
		}		
		
		tse_mac_device[tse_system_count].tse_mac_base 					= pmac->tse_mac_base + (i * 0x400);
   1e1d0:	1c801224 	muli	r18,r3,72
		tse_mac_device[tse_system_count].tse_tx_depth 					= pmac->tse_tx_depth;
   1e1d4:	e140010b 	ldhu	r5,4(fp)
		tse_mac_device[tse_system_count].tse_rx_depth 					= pmac->tse_rx_depth;
   1e1d8:	e100018b 	ldhu	r4,6(fp)
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys()\n");
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
		}		
		
		tse_mac_device[tse_system_count].tse_mac_base 					= pmac->tse_mac_base + (i * 0x400);
   1e1dc:	008000b4 	movhi	r2,2
   1e1e0:	109d9604 	addi	r2,r2,30296
   1e1e4:	14a9883a 	add	r20,r2,r18
		tse_mac_device[tse_system_count].tse_tx_depth 					= pmac->tse_tx_depth;
   1e1e8:	a0800104 	addi	r2,r20,4
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys()\n");
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
		}		
		
		tse_mac_device[tse_system_count].tse_mac_base 					= pmac->tse_mac_base + (i * 0x400);
   1e1ec:	598d883a 	add	r6,r11,r6
		tse_mac_device[tse_system_count].tse_tx_depth 					= pmac->tse_tx_depth;
   1e1f0:	1140000d 	sth	r5,0(r2)
		tse_mac_device[tse_system_count].tse_rx_depth 					= pmac->tse_rx_depth;
   1e1f4:	a100018d 	sth	r4,6(r20)
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys()\n");
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
		}		
		
		tse_mac_device[tse_system_count].tse_mac_base 					= pmac->tse_mac_base + (i * 0x400);
   1e1f8:	a1800015 	stw	r6,0(r20)
		tse_mac_device[tse_system_count].tse_tx_depth 					= pmac->tse_tx_depth;
		tse_mac_device[tse_system_count].tse_rx_depth 					= pmac->tse_rx_depth;
		tse_mac_device[tse_system_count].tse_use_mdio 					= pmac->tse_use_mdio;
   1e1fc:	e1400203 	ldbu	r5,8(fp)
   1e200:	a1000204 	addi	r4,r20,8
		tse_mac_device[tse_system_count].tse_en_maclite 				= pmac->tse_en_maclite;
		tse_mac_device[tse_system_count].tse_maclite_gige 				= pmac->tse_maclite_gige;
		tse_mac_device[tse_system_count].tse_multichannel_mac 			= pmac->tse_multichannel_mac;
		tse_mac_device[tse_system_count].tse_num_of_channel 			= pmac->tse_num_of_channel;
   1e204:	a0800304 	addi	r2,r20,12
		}		
		
		tse_mac_device[tse_system_count].tse_mac_base 					= pmac->tse_mac_base + (i * 0x400);
		tse_mac_device[tse_system_count].tse_tx_depth 					= pmac->tse_tx_depth;
		tse_mac_device[tse_system_count].tse_rx_depth 					= pmac->tse_rx_depth;
		tse_mac_device[tse_system_count].tse_use_mdio 					= pmac->tse_use_mdio;
   1e208:	21400005 	stb	r5,0(r4)
		tse_mac_device[tse_system_count].tse_en_maclite 				= pmac->tse_en_maclite;
   1e20c:	e1400243 	ldbu	r5,9(fp)
   1e210:	a1400245 	stb	r5,9(r20)
		tse_mac_device[tse_system_count].tse_maclite_gige 				= pmac->tse_maclite_gige;
   1e214:	e1400283 	ldbu	r5,10(fp)
   1e218:	a1400285 	stb	r5,10(r20)
		tse_mac_device[tse_system_count].tse_multichannel_mac 			= pmac->tse_multichannel_mac;
   1e21c:	e14002c3 	ldbu	r5,11(fp)
   1e220:	a14002c5 	stb	r5,11(r20)
		tse_mac_device[tse_system_count].tse_num_of_channel 			= pmac->tse_num_of_channel;
   1e224:	e1000303 	ldbu	r4,12(fp)
   1e228:	11000005 	stb	r4,0(r2)
		tse_mac_device[tse_system_count].tse_mdio_shared 				= pmac->tse_mdio_shared;
   1e22c:	e1000343 	ldbu	r4,13(fp)
   1e230:	a1000345 	stb	r4,13(r20)
		tse_mac_device[tse_system_count].tse_number_of_mac_mdio_shared	= pmac->tse_number_of_mac_mdio_shared;
   1e234:	e1000383 	ldbu	r4,14(fp)
   1e238:	a1000385 	stb	r4,14(r20)
		tse_mac_device[tse_system_count].tse_pcs_ena 					= pmac->tse_pcs_ena;
   1e23c:	e10003c3 	ldbu	r4,15(fp)
   1e240:	a10003c5 	stb	r4,15(r20)
		tse_mac_device[tse_system_count].tse_pcs_sgmii 					= pmac->tse_pcs_sgmii;
   1e244:	e0800403 	ldbu	r2,16(fp)
   1e248:	a0800405 	stb	r2,16(r20)
		
		/* Add SGDMA info to alt_tse_system_info structure */
		if(psgdma == 0) {
   1e24c:	80007826 	beq	r16,zero,1e430 <alt_tse_system_add_sys+0x2dc>
			tse_dprintf(2, "ERROR   : SGDMA system structure == NULL\n");
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys() for tse_mac_device[%d]\n", tse_system_count);
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
		}
		
		tse_mac_device[tse_system_count].tse_sgdma_tx = (char *) malloc(strlen(psgdma->tse_sgdma_tx) + 1);
   1e250:	81400017 	ldw	r5,0(r16)
   1e254:	2809883a 	mov	r4,r5
   1e258:	d9400215 	stw	r5,8(sp)
   1e25c:	001075c0 	call	1075c <strlen>
   1e260:	11000044 	addi	r4,r2,1
   1e264:	00231640 	call	23164 <malloc>
   1e268:	a0800515 	stw	r2,20(r20)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_tx) {
   1e26c:	d9400217 	ldw	r5,8(sp)
   1e270:	10007826 	beq	r2,zero,1e454 <alt_tse_system_add_sys+0x300>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_tx\n", tse_system_count);
	        return ALTERA_TSE_MALLOC_FAILED;
	    }   
		strcpy(tse_mac_device[tse_system_count].tse_sgdma_tx, psgdma->tse_sgdma_tx);
   1e274:	1009883a 	mov	r4,r2
   1e278:	002318c0 	call	2318c <strcpy>
		
		tse_mac_device[tse_system_count].tse_sgdma_rx = (char *) malloc(strlen(psgdma->tse_sgdma_rx) + 1);
   1e27c:	81400117 	ldw	r5,4(r16)
   1e280:	2809883a 	mov	r4,r5
   1e284:	d9400215 	stw	r5,8(sp)
   1e288:	001075c0 	call	1075c <strlen>
   1e28c:	11000044 	addi	r4,r2,1
   1e290:	00231640 	call	23164 <malloc>
   1e294:	a0800615 	stw	r2,24(r20)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_rx) {
   1e298:	d9400217 	ldw	r5,8(sp)
   1e29c:	10007326 	beq	r2,zero,1e46c <alt_tse_system_add_sys+0x318>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_rx\n", tse_system_count);
	        return ALTERA_TSE_MALLOC_FAILED;
	    }
	    strcpy(tse_mac_device[tse_system_count].tse_sgdma_rx, psgdma->tse_sgdma_rx);
   1e2a0:	1009883a 	mov	r4,r2
   1e2a4:	002318c0 	call	2318c <strcpy>
	    
		tse_mac_device[tse_system_count].tse_sgdma_rx_irq = psgdma->tse_sgdma_rx_irq;
   1e2a8:	8100020b 	ldhu	r4,8(r16)
   1e2ac:	a0800704 	addi	r2,r20,28
   1e2b0:	1100000d 	sth	r4,0(r2)
		
		/* Add descriptor memory info to alt_tse_system_info structure */
		if(pmem == 0) {
   1e2b4:	b8005826 	beq	r23,zero,1e418 <alt_tse_system_add_sys+0x2c4>
			tse_mac_device[tse_system_count].ext_desc_mem	= TSE_INT_DESC_MEM;
			tse_mac_device[tse_system_count].desc_mem_base	= TSE_INT_DESC_MEM;
		}
		else {
			tse_mac_device[tse_system_count].ext_desc_mem	= pmem->ext_desc_mem;
   1e2b8:	b9000003 	ldbu	r4,0(r23)
   1e2bc:	11000085 	stb	r4,2(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= pmem->desc_mem_base;
   1e2c0:	b8800117 	ldw	r2,4(r23)
   1e2c4:	a0800815 	stw	r2,32(r20)
		}
		
		/* Add shared fifo info to alt_tse_system_info structure */
		if(pfifo == 0) {
   1e2c8:	b0004826 	beq	r22,zero,1e3ec <alt_tse_system_add_sys+0x298>
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= TSE_NO_SHARED_FIFO;
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= TSE_NO_SHARED_FIFO;
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = TSE_NO_SHARED_FIFO;
		}
		else {
			tse_mac_device[tse_system_count].use_shared_fifo                = pfifo->use_shared_fifo;
   1e2cc:	b1000003 	ldbu	r4,0(r22)
   1e2d0:	00c000b4 	movhi	r3,2
   1e2d4:	18dd9604 	addi	r3,r3,30296
   1e2d8:	1c85883a 	add	r2,r3,r18
   1e2dc:	11000905 	stb	r4,36(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= pfifo->tse_shared_fifo_tx_ctrl_base;
   1e2e0:	b3000117 	ldw	r12,4(r22)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= pfifo->tse_shared_fifo_tx_stat_base;
   1e2e4:	b2c00217 	ldw	r11,8(r22)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = pfifo->tse_shared_fifo_tx_depth;
   1e2e8:	b2000317 	ldw	r8,12(r22)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= pfifo->tse_shared_fifo_rx_ctrl_base;
   1e2ec:	b1800417 	ldw	r6,16(r22)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= pfifo->tse_shared_fifo_rx_stat_base;
   1e2f0:	b1400517 	ldw	r5,20(r22)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = pfifo->tse_shared_fifo_rx_depth;
   1e2f4:	b1000617 	ldw	r4,24(r22)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= TSE_NO_SHARED_FIFO;
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = TSE_NO_SHARED_FIFO;
		}
		else {
			tse_mac_device[tse_system_count].use_shared_fifo                = pfifo->use_shared_fifo;
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= pfifo->tse_shared_fifo_tx_ctrl_base;
   1e2f8:	13000a15 	stw	r12,40(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= pfifo->tse_shared_fifo_tx_stat_base;
   1e2fc:	12c00b15 	stw	r11,44(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = pfifo->tse_shared_fifo_tx_depth;
   1e300:	12000c15 	stw	r8,48(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= pfifo->tse_shared_fifo_rx_ctrl_base;
   1e304:	11800d15 	stw	r6,52(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= pfifo->tse_shared_fifo_rx_stat_base;
   1e308:	11400e15 	stw	r5,56(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = pfifo->tse_shared_fifo_rx_depth;
   1e30c:	11000f15 	stw	r4,60(r2)
		}
		
		/* Add PHY info to alt_tse_system_info structure */
		if(pphy == 0) {
   1e310:	a8002f26 	beq	r21,zero,1e3d0 <alt_tse_system_add_sys+0x27c>
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= TSE_PHY_AUTO_ADDRESS;
			tse_mac_device[tse_system_count].tse_phy_cfg 			= 0;
		}
		else {
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= pphy->tse_phy_mdio_address;
   1e314:	a9000017 	ldw	r4,0(r21)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= pphy->tse_phy_cfg;
   1e318:	a8800117 	ldw	r2,4(r21)
		if(pphy == 0) {
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= TSE_PHY_AUTO_ADDRESS;
			tse_mac_device[tse_system_count].tse_phy_cfg 			= 0;
		}
		else {
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= pphy->tse_phy_mdio_address;
   1e31c:	00c000b4 	movhi	r3,2
   1e320:	18dd9604 	addi	r3,r3,30296
   1e324:	1ca5883a 	add	r18,r3,r18
   1e328:	91001015 	stw	r4,64(r18)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= pphy->tse_phy_cfg;
   1e32c:	90801115 	stw	r2,68(r18)
		}
		
		/* Point to next structure */
		psgdma++;
   1e330:	84000304 	addi	r16,r16,12
		if(pmem) pmem++;
   1e334:	b8000126 	beq	r23,zero,1e33c <alt_tse_system_add_sys+0x1e8>
   1e338:	bdc00204 	addi	r23,r23,8
		if(pfifo) pfifo++;
   1e33c:	b0000126 	beq	r22,zero,1e344 <alt_tse_system_add_sys+0x1f0>
   1e340:	b5800704 	addi	r22,r22,28
		if(pphy) pphy++;
   1e344:	a8000126 	beq	r21,zero,1e34c <alt_tse_system_add_sys+0x1f8>
   1e348:	ad400204 	addi	r21,r21,8
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
	}

	for(i = 0; i < loop_end; i++) {
   1e34c:	d8c00117 	ldw	r3,4(sp)
		psgdma++;
		if(pmem) pmem++;
		if(pfifo) pfifo++;
		if(pphy) pphy++;
		
		tse_system_count++;
   1e350:	9cc00044 	addi	r19,r19,1
   1e354:	d4e8df85 	stb	r19,-23682(gp)
		max_mac_system = tse_system_count;
   1e358:	d4e01d05 	stb	r19,-32652(gp)
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
	}

	for(i = 0; i < loop_end; i++) {
   1e35c:	8c400044 	addi	r17,r17,1
   1e360:	88ff9216 	blt	r17,r3,1e1ac <alt_tse_system_add_sys+0x58>
		
		tse_system_count++;
		max_mac_system = tse_system_count;
	}
	
	return SUCCESS;
   1e364:	0005883a 	mov	r2,zero
	
}
   1e368:	dfc00c17 	ldw	ra,48(sp)
   1e36c:	df000b17 	ldw	fp,44(sp)
   1e370:	ddc00a17 	ldw	r23,40(sp)
   1e374:	dd800917 	ldw	r22,36(sp)
   1e378:	dd400817 	ldw	r21,32(sp)
   1e37c:	dd000717 	ldw	r20,28(sp)
   1e380:	dcc00617 	ldw	r19,24(sp)
   1e384:	dc800517 	ldw	r18,20(sp)
   1e388:	dc400417 	ldw	r17,16(sp)
   1e38c:	dc000317 	ldw	r16,12(sp)
   1e390:	dec00d04 	addi	sp,sp,52
   1e394:	f800283a 	ret

	for(i = 0; i < loop_end; i++) {
		
		/* Make sure the boundary of array is not exceeded */
		if(tse_system_count >= MAXNETS) {
			tse_dprintf(2, "ERROR   : Number of TSE System added exceed the size of array!\n");
   1e398:	010000b4 	movhi	r4,2
   1e39c:	21191a04 	addi	r4,r4,25704
   1e3a0:	00106a40 	call	106a4 <puts>
			tse_dprintf(2, "ERROR   : Size of array = %d, Number of TSE System = %d\n", MAXNETS, tse_system_count);
   1e3a4:	d1a8df87 	ldb	r6,-23682(gp)
   1e3a8:	010000b4 	movhi	r4,2
   1e3ac:	21192a04 	addi	r4,r4,25768
   1e3b0:	01400204 	movi	r5,8
   1e3b4:	00104380 	call	10438 <printf>
   1e3b8:	d4e8df83 	ldbu	r19,-23682(gp)
   1e3bc:	98803fcc 	andi	r2,r19,255
   1e3c0:	1080201c 	xori	r2,r2,128
   1e3c4:	10bfe004 	addi	r2,r2,-128
   1e3c8:	d8800015 	stw	r2,0(sp)
   1e3cc:	003f7d06 	br	1e1c4 <alt_tse_system_add_sys+0x70>
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = pfifo->tse_shared_fifo_rx_depth;
		}
		
		/* Add PHY info to alt_tse_system_info structure */
		if(pphy == 0) {
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= TSE_PHY_AUTO_ADDRESS;
   1e3d0:	008000b4 	movhi	r2,2
   1e3d4:	109d9604 	addi	r2,r2,30296
   1e3d8:	14a5883a 	add	r18,r2,r18
   1e3dc:	00ffffc4 	movi	r3,-1
   1e3e0:	90c01015 	stw	r3,64(r18)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= 0;
   1e3e4:	90001115 	stw	zero,68(r18)
   1e3e8:	003fd106 	br	1e330 <alt_tse_system_add_sys+0x1dc>
			tse_mac_device[tse_system_count].desc_mem_base	= pmem->desc_mem_base;
		}
		
		/* Add shared fifo info to alt_tse_system_info structure */
		if(pfifo == 0) {
			tse_mac_device[tse_system_count].use_shared_fifo                = TSE_NO_SHARED_FIFO;
   1e3ec:	00c000b4 	movhi	r3,2
   1e3f0:	18dd9604 	addi	r3,r3,30296
   1e3f4:	1c85883a 	add	r2,r3,r18
   1e3f8:	10000905 	stb	zero,36(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= TSE_NO_SHARED_FIFO;
   1e3fc:	10000a15 	stw	zero,40(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= TSE_NO_SHARED_FIFO;
   1e400:	10000b15 	stw	zero,44(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = TSE_NO_SHARED_FIFO;
   1e404:	10000c15 	stw	zero,48(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= TSE_NO_SHARED_FIFO;
   1e408:	10000d15 	stw	zero,52(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= TSE_NO_SHARED_FIFO;
   1e40c:	10000e15 	stw	zero,56(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = TSE_NO_SHARED_FIFO;
   1e410:	10000f15 	stw	zero,60(r2)
   1e414:	003fbe06 	br	1e310 <alt_tse_system_add_sys+0x1bc>
	    
		tse_mac_device[tse_system_count].tse_sgdma_rx_irq = psgdma->tse_sgdma_rx_irq;
		
		/* Add descriptor memory info to alt_tse_system_info structure */
		if(pmem == 0) {
			tse_mac_device[tse_system_count].ext_desc_mem	= TSE_INT_DESC_MEM;
   1e418:	10000085 	stb	zero,2(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= TSE_INT_DESC_MEM;
   1e41c:	a0000815 	stw	zero,32(r20)
   1e420:	003fa906 	br	1e2c8 <alt_tse_system_add_sys+0x174>
	/* Run at least one for non-multi-channel MAC */
	if(pmac->tse_num_of_channel == 0) {
		loop_end = 1;
	}
	else if(pmac->tse_num_of_channel > 0) {
		loop_end = pmac->tse_num_of_channel; 
   1e424:	ddc00115 	stw	r23,4(sp)
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
	}

	for(i = 0; i < loop_end; i++) {
   1e428:	05ff5a16 	blt	zero,r23,1e194 <alt_tse_system_add_sys+0x40>
   1e42c:	003fcd06 	br	1e364 <alt_tse_system_add_sys+0x210>
		tse_mac_device[tse_system_count].tse_pcs_ena 					= pmac->tse_pcs_ena;
		tse_mac_device[tse_system_count].tse_pcs_sgmii 					= pmac->tse_pcs_sgmii;
		
		/* Add SGDMA info to alt_tse_system_info structure */
		if(psgdma == 0) {
			tse_dprintf(2, "ERROR   : SGDMA system structure == NULL\n");
   1e430:	010000b4 	movhi	r4,2
   1e434:	21193904 	addi	r4,r4,25828
   1e438:	00106a40 	call	106a4 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys() for tse_mac_device[%d]\n", tse_system_count);
   1e43c:	d168df87 	ldb	r5,-23682(gp)
   1e440:	010000b4 	movhi	r4,2
   1e444:	21194404 	addi	r4,r4,25872
   1e448:	00104380 	call	10438 <printf>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
   1e44c:	00bfffc4 	movi	r2,-1
   1e450:	003fc506 	br	1e368 <alt_tse_system_add_sys+0x214>
		}
		
		tse_mac_device[tse_system_count].tse_sgdma_tx = (char *) malloc(strlen(psgdma->tse_sgdma_tx) + 1);
	    if(!tse_mac_device[tse_system_count].tse_sgdma_tx) {
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_tx\n", tse_system_count);
   1e454:	d9400017 	ldw	r5,0(sp)
   1e458:	010000b4 	movhi	r4,2
   1e45c:	21195c04 	addi	r4,r4,25968
   1e460:	00104380 	call	10438 <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
   1e464:	00bfffc4 	movi	r2,-1
   1e468:	003fbf06 	br	1e368 <alt_tse_system_add_sys+0x214>
	    }   
		strcpy(tse_mac_device[tse_system_count].tse_sgdma_tx, psgdma->tse_sgdma_tx);
		
		tse_mac_device[tse_system_count].tse_sgdma_rx = (char *) malloc(strlen(psgdma->tse_sgdma_rx) + 1);
	    if(!tse_mac_device[tse_system_count].tse_sgdma_rx) {
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_rx\n", tse_system_count);
   1e46c:	d9400017 	ldw	r5,0(sp)
   1e470:	010000b4 	movhi	r4,2
   1e474:	21196f04 	addi	r4,r4,26044
   1e478:	00104380 	call	10438 <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
   1e47c:	00bfffc4 	movi	r2,-1
   1e480:	003fb906 	br	1e368 <alt_tse_system_add_sys+0x214>

0001e484 <alt_tse_sys_enable_mdio_sharing>:
 * @param		number_of_mac  number of MAC sharing MDIO block
 * @return      SUCCESS on success
 * 				ALTERA_TSE_SYSTEM_DEF_ERROR if definition of system incorrect or pointer == NULL
 * Multi-channel MAC not supported
 */
alt_32 alt_tse_sys_enable_mdio_sharing(alt_tse_system_mac **psys_mac_list, alt_u8 number_of_mac) {
   1e484:	deffff04 	addi	sp,sp,-4
   1e488:	dfc00015 	stw	ra,0(sp)
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
   1e48c:	2b803fcc 	andi	r14,r5,255
   1e490:	70003526 	beq	r14,zero,1e568 <alt_tse_sys_enable_mdio_sharing+0xe4>
		psys_mac = psys_mac_list[i];
   1e494:	22400017 	ldw	r9,0(r4)
		
		if(psys_mac == 0) {
   1e498:	48001f26 	beq	r9,zero,1e518 <alt_tse_sys_enable_mdio_sharing+0x94>
   1e49c:	d2a01d03 	ldbu	r10,-32652(gp)
 * @param		number_of_mac  number of MAC sharing MDIO block
 * @return      SUCCESS on success
 * 				ALTERA_TSE_SYSTEM_DEF_ERROR if definition of system incorrect or pointer == NULL
 * Multi-channel MAC not supported
 */
alt_32 alt_tse_sys_enable_mdio_sharing(alt_tse_system_mac **psys_mac_list, alt_u8 number_of_mac) {
   1e4a0:	23400104 	addi	r13,r4,4
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
   1e4a4:	0019883a 	mov	r12,zero
					tse_dprintf(2, "ERROR   : MDIO sharing supported by default for Multi-channel MAC\n");
					tse_dprintf(2, "ERROR   : Do not include Multi-channel MAC in the MAC List\n");
					return ALTERA_TSE_SYSTEM_DEF_ERROR;
				}
				
				tse_mac_device[j].tse_mdio_shared = 1;
   1e4a8:	02c00044 	movi	r11,1
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
		}
		
		for(j = 0; j < max_mac_system; j++) {
   1e4ac:	50001526 	beq	r10,zero,1e504 <alt_tse_sys_enable_mdio_sharing+0x80>
   1e4b0:	008000b4 	movhi	r2,2
   1e4b4:	109d9604 	addi	r2,r2,30296
   1e4b8:	11000344 	addi	r4,r2,13
   1e4bc:	118002c4 	addi	r6,r2,11
   1e4c0:	0007883a 	mov	r3,zero
   1e4c4:	00000306 	br	1e4d4 <alt_tse_sys_enable_mdio_sharing+0x50>
   1e4c8:	21001204 	addi	r4,r4,72
   1e4cc:	31801204 	addi	r6,r6,72
   1e4d0:	1a800c0e 	bge	r3,r10,1e504 <alt_tse_sys_enable_mdio_sharing+0x80>
			
			if(psys_mac->tse_mac_base == tse_mac_device[j].tse_mac_base) {
   1e4d4:	11c00017 	ldw	r7,0(r2)
   1e4d8:	4a000017 	ldw	r8,0(r9)
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
		}
		
		for(j = 0; j < max_mac_system; j++) {
   1e4dc:	18c00044 	addi	r3,r3,1
   1e4e0:	10801204 	addi	r2,r2,72
			
			if(psys_mac->tse_mac_base == tse_mac_device[j].tse_mac_base) {
   1e4e4:	41fff81e 	bne	r8,r7,1e4c8 <alt_tse_sys_enable_mdio_sharing+0x44>
				if(tse_mac_device[j].tse_multichannel_mac) {
   1e4e8:	31c00003 	ldbu	r7,0(r6)
   1e4ec:	3800141e 	bne	r7,zero,1e540 <alt_tse_sys_enable_mdio_sharing+0xbc>
					tse_dprintf(2, "ERROR   : MDIO sharing supported by default for Multi-channel MAC\n");
					tse_dprintf(2, "ERROR   : Do not include Multi-channel MAC in the MAC List\n");
					return ALTERA_TSE_SYSTEM_DEF_ERROR;
				}
				
				tse_mac_device[j].tse_mdio_shared = 1;
   1e4f0:	22c00005 	stb	r11,0(r4)
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
   1e4f4:	21400045 	stb	r5,1(r4)
   1e4f8:	31801204 	addi	r6,r6,72
   1e4fc:	21001204 	addi	r4,r4,72
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
		}
		
		for(j = 0; j < max_mac_system; j++) {
   1e500:	1abff416 	blt	r3,r10,1e4d4 <alt_tse_sys_enable_mdio_sharing+0x50>
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
   1e504:	63000044 	addi	r12,r12,1
   1e508:	6380170e 	bge	r12,r14,1e568 <alt_tse_sys_enable_mdio_sharing+0xe4>
   1e50c:	6b400104 	addi	r13,r13,4
		psys_mac = psys_mac_list[i];
   1e510:	6a7fff17 	ldw	r9,-4(r13)
		
		if(psys_mac == 0) {
   1e514:	483fe51e 	bne	r9,zero,1e4ac <alt_tse_sys_enable_mdio_sharing+0x28>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
   1e518:	010000b4 	movhi	r4,2
   1e51c:	21198204 	addi	r4,r4,26120
   1e520:	00106a40 	call	106a4 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
   1e524:	010000b4 	movhi	r4,2
   1e528:	21198c04 	addi	r4,r4,26160
   1e52c:	00106a40 	call	106a4 <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
   1e530:	00bfffc4 	movi	r2,-1
			}
		}	
	}
	
	return SUCCESS;
}
   1e534:	dfc00017 	ldw	ra,0(sp)
   1e538:	dec00104 	addi	sp,sp,4
   1e53c:	f800283a 	ret
		
		for(j = 0; j < max_mac_system; j++) {
			
			if(psys_mac->tse_mac_base == tse_mac_device[j].tse_mac_base) {
				if(tse_mac_device[j].tse_multichannel_mac) {
					tse_dprintf(2, "ERROR   : MDIO sharing supported by default for Multi-channel MAC\n");
   1e540:	010000b4 	movhi	r4,2
   1e544:	2119a004 	addi	r4,r4,26240
   1e548:	00106a40 	call	106a4 <puts>
					tse_dprintf(2, "ERROR   : Do not include Multi-channel MAC in the MAC List\n");
   1e54c:	010000b4 	movhi	r4,2
   1e550:	2119b104 	addi	r4,r4,26308
   1e554:	00106a40 	call	106a4 <puts>
					return ALTERA_TSE_SYSTEM_DEF_ERROR;
   1e558:	00bfffc4 	movi	r2,-1
			}
		}	
	}
	
	return SUCCESS;
}
   1e55c:	dfc00017 	ldw	ra,0(sp)
   1e560:	dec00104 	addi	sp,sp,4
   1e564:	f800283a 	ret
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
			}
		}	
	}
	
	return SUCCESS;
   1e568:	0005883a 	mov	r2,zero
}
   1e56c:	dfc00017 	ldw	ra,0(sp)
   1e570:	dec00104 	addi	sp,sp,4
   1e574:	f800283a 	ret

0001e578 <alt_tse_get_system_index>:
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
   1e578:	d1601d03 	ldbu	r5,-32652(gp)
   1e57c:	28000a26 	beq	r5,zero,1e5a8 <alt_tse_get_system_index+0x30>
        if(psys_info == &tse_mac_device[i]) {
   1e580:	018000b4 	movhi	r6,2
   1e584:	319d9604 	addi	r6,r6,30296
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
   1e588:	0005883a 	mov	r2,zero
        if(psys_info == &tse_mac_device[i]) {
   1e58c:	2180031e 	bne	r4,r6,1e59c <alt_tse_get_system_index+0x24>
   1e590:	00000706 	br	1e5b0 <alt_tse_get_system_index+0x38>
   1e594:	30c7883a 	add	r3,r6,r3
   1e598:	20c00526 	beq	r4,r3,1e5b0 <alt_tse_get_system_index+0x38>
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
   1e59c:	10800044 	addi	r2,r2,1
        if(psys_info == &tse_mac_device[i]) {
   1e5a0:	10c01224 	muli	r3,r2,72
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
   1e5a4:	117ffb16 	blt	r2,r5,1e594 <alt_tse_get_system_index+0x1c>
        if(psys_info == &tse_mac_device[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
   1e5a8:	00bfffc4 	movi	r2,-1
   1e5ac:	f800283a 	ret
}
   1e5b0:	f800283a 	ret

0001e5b4 <alt_tse_get_mac_group_index>:
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   1e5b4:	d1a8df03 	ldbu	r6,-23684(gp)
   1e5b8:	30000c26 	beq	r6,zero,1e5ec <alt_tse_get_mac_group_index+0x38>
        if(pmac_group == pmac_groups[i]) {
   1e5bc:	00c001f4 	movhi	r3,7
   1e5c0:	18d49d04 	addi	r3,r3,21108
   1e5c4:	18800017 	ldw	r2,0(r3)
   1e5c8:	11000a26 	beq	r2,r4,1e5f4 <alt_tse_get_mac_group_index+0x40>
   1e5cc:	18c00104 	addi	r3,r3,4
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   1e5d0:	0005883a 	mov	r2,zero
   1e5d4:	00000206 	br	1e5e0 <alt_tse_get_mac_group_index+0x2c>
        if(pmac_group == pmac_groups[i]) {
   1e5d8:	197fff17 	ldw	r5,-4(r3)
   1e5dc:	29000626 	beq	r5,r4,1e5f8 <alt_tse_get_mac_group_index+0x44>
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   1e5e0:	10800044 	addi	r2,r2,1
   1e5e4:	18c00104 	addi	r3,r3,4
   1e5e8:	11bffb16 	blt	r2,r6,1e5d8 <alt_tse_get_mac_group_index+0x24>
        if(pmac_group == pmac_groups[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
   1e5ec:	00bfffc4 	movi	r2,-1
   1e5f0:	f800283a 	ret
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   1e5f4:	0005883a 	mov	r2,zero
        if(pmac_group == pmac_groups[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
}
   1e5f8:	f800283a 	ret

0001e5fc <alt_tse_get_mac_info_index>:
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1e5fc:	20c00317 	ldw	r3,12(r4)
   1e600:	19800003 	ldbu	r6,0(r3)
   1e604:	30000a26 	beq	r6,zero,1e630 <alt_tse_get_mac_info_index+0x34>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   1e608:	18800117 	ldw	r2,4(r3)
   1e60c:	11000a26 	beq	r2,r4,1e638 <alt_tse_get_mac_info_index+0x3c>
/* @Function Description: Get the index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_info structure
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
   1e610:	18c00204 	addi	r3,r3,8
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1e614:	0005883a 	mov	r2,zero
   1e618:	00000206 	br	1e624 <alt_tse_get_mac_info_index+0x28>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   1e61c:	197fff17 	ldw	r5,-4(r3)
   1e620:	29000626 	beq	r5,r4,1e63c <alt_tse_get_mac_info_index+0x40>
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1e624:	10800044 	addi	r2,r2,1
   1e628:	18c00104 	addi	r3,r3,4
   1e62c:	11bffb16 	blt	r2,r6,1e61c <alt_tse_get_mac_info_index+0x20>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
            return i;
        }
    }
    
    return ALTERA_TSE_NO_INDEX_FOUND;
   1e630:	00bfffc4 	movi	r2,-1
   1e634:	f800283a 	ret
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1e638:	0005883a 	mov	r2,zero
            return i;
        }
    }
    
    return ALTERA_TSE_NO_INDEX_FOUND;
}
   1e63c:	f800283a 	ret

0001e640 <alt_tse_get_mac_info>:
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
   1e640:	d2a8df03 	ldbu	r10,-23684(gp)
   1e644:	50001726 	beq	r10,zero,1e6a4 <alt_tse_get_mac_info+0x64>
   1e648:	020001f4 	movhi	r8,7
   1e64c:	42149d04 	addi	r8,r8,21108
   1e650:	0013883a 	mov	r9,zero
        pmac_group = pmac_groups[i];
   1e654:	41400017 	ldw	r5,0(r8)
        for(j = 0; j < pmac_group->channel; j++) {
   1e658:	29c00003 	ldbu	r7,0(r5)
   1e65c:	38000e26 	beq	r7,zero,1e698 <alt_tse_get_mac_info+0x58>
            pmac_info = pmac_group->pmac_info[j];
   1e660:	28800117 	ldw	r2,4(r5)
            if(((np_tse_mac *) pmac_info->psys_info->tse_mac_base) == pmac) {
   1e664:	10c00217 	ldw	r3,8(r2)
   1e668:	18c00017 	ldw	r3,0(r3)
   1e66c:	20c00e26 	beq	r4,r3,1e6a8 <alt_tse_get_mac_info+0x68>
/* @Function Description: Get the pointer of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac        Pointer to the TSE MAC Control Interface Base address
 * @return            Pointer to alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_tse_mac_info *alt_tse_get_mac_info(np_tse_mac *pmac) {
   1e670:	29400204 	addi	r5,r5,8
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
        pmac_group = pmac_groups[i];
        for(j = 0; j < pmac_group->channel; j++) {
   1e674:	0007883a 	mov	r3,zero
   1e678:	00000506 	br	1e690 <alt_tse_get_mac_info+0x50>
            pmac_info = pmac_group->pmac_info[j];
   1e67c:	28800017 	ldw	r2,0(r5)
   1e680:	29400104 	addi	r5,r5,4
            if(((np_tse_mac *) pmac_info->psys_info->tse_mac_base) == pmac) {
   1e684:	11800217 	ldw	r6,8(r2)
   1e688:	31800017 	ldw	r6,0(r6)
   1e68c:	21800626 	beq	r4,r6,1e6a8 <alt_tse_get_mac_info+0x68>
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
        pmac_group = pmac_groups[i];
        for(j = 0; j < pmac_group->channel; j++) {
   1e690:	18c00044 	addi	r3,r3,1
   1e694:	19fff916 	blt	r3,r7,1e67c <alt_tse_get_mac_info+0x3c>
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
   1e698:	4a400044 	addi	r9,r9,1
   1e69c:	42000104 	addi	r8,r8,4
   1e6a0:	4abfec16 	blt	r9,r10,1e654 <alt_tse_get_mac_info+0x14>
                return pmac_info;
            }
        }        
    }
    
    return 0;
   1e6a4:	0005883a 	mov	r2,zero
}
   1e6a8:	f800283a 	ret

0001e6ac <alt_tse_mac_set_speed>:
 */
alt_32 alt_tse_mac_set_speed(np_tse_mac *pmac, alt_u8 speed)
{
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
   1e6ac:	21000204 	addi	r4,r4,8
   1e6b0:	20c00037 	ldwio	r3,0(r4)
  
  /* 1000 Mbps */
  if(speed == TSE_PHY_SPEED_1000) {
   1e6b4:	00800084 	movi	r2,2
   1e6b8:	29403fcc 	andi	r5,r5,255
   1e6bc:	28800926 	beq	r5,r2,1e6e4 <alt_tse_mac_set_speed+0x38>
    helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
  }
  /* 100 Mbps */
  else if(speed == TSE_PHY_SPEED_100) {
   1e6c0:	00800044 	movi	r2,1
   1e6c4:	28800e26 	beq	r5,r2,1e700 <alt_tse_mac_set_speed+0x54>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
  }
  /* 10 Mbps */
  else if(speed == TSE_PHY_SPEED_10) {
   1e6c8:	2800131e 	bne	r5,zero,1e718 <alt_tse_mac_set_speed+0x6c>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
   1e6cc:	00bffdc4 	movi	r2,-9
   1e6d0:	1886703a 	and	r3,r3,r2
	helpvar |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
   1e6d4:	18c08034 	orhi	r3,r3,512
  }  
  else {
    return ENP_PARAM;
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
   1e6d8:	20c00035 	stwio	r3,0(r4)
  return SUCCESS;
   1e6dc:	0005883a 	mov	r2,zero
   1e6e0:	f800283a 	ret
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
  
  /* 1000 Mbps */
  if(speed == TSE_PHY_SPEED_1000) {
    helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
   1e6e4:	00bf8034 	movhi	r2,65024
   1e6e8:	10bfffc4 	addi	r2,r2,-1
   1e6ec:	1886703a 	and	r3,r3,r2
   1e6f0:	18c00214 	ori	r3,r3,8
  }  
  else {
    return ENP_PARAM;
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
   1e6f4:	20c00035 	stwio	r3,0(r4)
  return SUCCESS;
   1e6f8:	0005883a 	mov	r2,zero
   1e6fc:	f800283a 	ret
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
  }
  /* 100 Mbps */
  else if(speed == TSE_PHY_SPEED_100) {
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
   1e700:	00bf8034 	movhi	r2,65024
   1e704:	10bffdc4 	addi	r2,r2,-9
   1e708:	1886703a 	and	r3,r3,r2
  }  
  else {
    return ENP_PARAM;
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
   1e70c:	20c00035 	stwio	r3,0(r4)
  return SUCCESS;
   1e710:	0005883a 	mov	r2,zero
   1e714:	f800283a 	ret
  else if(speed == TSE_PHY_SPEED_10) {
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
	helpvar |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
  }  
  else {
    return ENP_PARAM;
   1e718:	00bffd84 	movi	r2,-10
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
  return SUCCESS;
}
   1e71c:	f800283a 	ret

0001e720 <alt_tse_mac_set_duplex>:
 */
alt_32 alt_tse_mac_set_duplex(np_tse_mac *pmac, alt_u8 duplex)
{
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
   1e720:	21000204 	addi	r4,r4,8
   1e724:	20800037 	ldwio	r2,0(r4)
  
  /* Half Duplex */
  if(duplex == TSE_PHY_DUPLEX_HALF) {
   1e728:	29403fcc 	andi	r5,r5,255
   1e72c:	2800041e 	bne	r5,zero,1e740 <alt_tse_mac_set_duplex+0x20>
    helpvar |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
   1e730:	10810014 	ori	r2,r2,1024
  }
  else {
    return ENP_PARAM;
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
   1e734:	20800035 	stwio	r2,0(r4)
  return SUCCESS;
   1e738:	0005883a 	mov	r2,zero
   1e73c:	f800283a 	ret
  /* Half Duplex */
  if(duplex == TSE_PHY_DUPLEX_HALF) {
    helpvar |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
  } 
  /* Full Duplex */
  else if(duplex == TSE_PHY_DUPLEX_FULL) {
   1e740:	00c00044 	movi	r3,1
   1e744:	28c0051e 	bne	r5,r3,1e75c <alt_tse_mac_set_duplex+0x3c>
    helpvar &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
   1e748:	00feffc4 	movi	r3,-1025
   1e74c:	10c4703a 	and	r2,r2,r3
  }
  else {
    return ENP_PARAM;
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
   1e750:	20800035 	stwio	r2,0(r4)
  return SUCCESS;
   1e754:	0005883a 	mov	r2,zero
   1e758:	f800283a 	ret
  /* Full Duplex */
  else if(duplex == TSE_PHY_DUPLEX_FULL) {
    helpvar &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
  }
  else {
    return ENP_PARAM;
   1e75c:	00bffd84 	movi	r2,-10
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
  return SUCCESS;

}
   1e760:	f800283a 	ret

0001e764 <alt_tse_phy_rd_mdio_addr>:
 * @API Type:    Internal
 * @param pmac   Pointer to the alt_tse_phy_info structure
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_rd_mdio_addr(alt_tse_phy_info *pphy) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1e764:	20800617 	ldw	r2,24(r4)
   1e768:	10800317 	ldw	r2,12(r2)
   1e76c:	10800117 	ldw	r2,4(r2)
   1e770:	10800217 	ldw	r2,8(r2)
    return IORD(&pmac_group_base->MDIO_ADDR1, 0);
   1e774:	10800017 	ldw	r2,0(r2)
}
   1e778:	10801037 	ldwio	r2,64(r2)
   1e77c:	f800283a 	ret

0001e780 <alt_tse_phy_wr_mdio_addr>:
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1e780:	20800617 	ldw	r2,24(r4)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
   1e784:	29403fcc 	andi	r5,r5,255
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1e788:	10800317 	ldw	r2,12(r2)
   1e78c:	10800117 	ldw	r2,4(r2)
   1e790:	10800217 	ldw	r2,8(r2)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
   1e794:	10800017 	ldw	r2,0(r2)
   1e798:	11401035 	stwio	r5,64(r2)
    
    return SUCCESS;
}
   1e79c:	0005883a 	mov	r2,zero
   1e7a0:	f800283a 	ret

0001e7a4 <alt_tse_phy_wr_mdio_reg>:
{
    
    alt_u16 temp_data;
    alt_u16 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1e7a4:	20800617 	ldw	r2,24(r4)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
   1e7a8:	39c03fcc 	andi	r7,r7,255
  * @param  bit_length       number of bits to be written to the register.
  * @param  data             data to be written to the register at specific bit location of register.
  * @return SUCCESS 
  */
alt_32 alt_tse_phy_wr_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length, alt_u16 data)
{
   1e7ac:	d900000b 	ldhu	r4,0(sp)
    
    alt_u16 temp_data;
    alt_u16 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1e7b0:	10800317 	ldw	r2,12(r2)
   1e7b4:	10800117 	ldw	r2,4(r2)
   1e7b8:	10800217 	ldw	r2,8(r2)
   1e7bc:	12000017 	ldw	r8,0(r2)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
   1e7c0:	38001926 	beq	r7,zero,1e828 <alt_tse_phy_wr_mdio_reg+0x84>
   1e7c4:	0007883a 	mov	r3,zero
   1e7c8:	0005883a 	mov	r2,zero
    {
        bit_mask <<= 1;
   1e7cc:	1085883a 	add	r2,r2,r2
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
   1e7d0:	18c00044 	addi	r3,r3,1
    {
        bit_mask <<= 1;
        bit_mask |= 0x01;        
   1e7d4:	10800054 	ori	r2,r2,1
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
   1e7d8:	19fffc16 	blt	r3,r7,1e7cc <alt_tse_phy_wr_mdio_reg+0x28>
   1e7dc:	31803fcc 	andi	r6,r6,255
   1e7e0:	10bfffcc 	andi	r2,r2,65535
   1e7e4:	213fffcc 	andi	r4,r4,65535
   1e7e8:	1184983a 	sll	r2,r2,r6
   1e7ec:	218c983a 	sll	r6,r4,r6
   1e7f0:	008e303a 	nor	r7,zero,r2
   1e7f4:	1184703a 	and	r2,r2,r6
    
    /* shifting mask to left by bit_num */
    bit_mask <<= lsb_num;

    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
   1e7f8:	28c03fcc 	andi	r3,r5,255
   1e7fc:	18c7883a 	add	r3,r3,r3
   1e800:	4140a004 	addi	r5,r8,640
   1e804:	18c7883a 	add	r3,r3,r3
   1e808:	28c7883a 	add	r3,r5,r3
   1e80c:	19000037 	ldwio	r4,0(r3)
    
    /* clear bits to be written */
    temp_data &= ~bit_mask;
   1e810:	21c8703a 	and	r4,r4,r7
    
    /* OR-ed together corresponding bits data */
    temp_data |= ((data << lsb_num) & bit_mask);    
   1e814:	2084b03a 	or	r2,r4,r2
    
    /* write data to MDIO register */
    IOWR(&pmac->mdio1, reg_num, temp_data);
   1e818:	10bfffcc 	andi	r2,r2,65535
   1e81c:	18800035 	stwio	r2,0(r3)
    
    return SUCCESS;
    
}
   1e820:	0005883a 	mov	r2,zero
   1e824:	f800283a 	ret
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
   1e828:	0005883a 	mov	r2,zero
   1e82c:	01ffffc4 	movi	r7,-1
   1e830:	003ff106 	br	1e7f8 <alt_tse_phy_wr_mdio_reg+0x54>

0001e834 <alt_tse_phy_rd_mdio_reg>:
alt_u32 alt_tse_phy_rd_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length)
{
    alt_u16 temp_data;
    alt_u32 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1e834:	20800617 	ldw	r2,24(r4)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
   1e838:	39c03fcc 	andi	r7,r7,255
alt_u32 alt_tse_phy_rd_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length)
{
    alt_u16 temp_data;
    alt_u32 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1e83c:	10800317 	ldw	r2,12(r2)
   1e840:	10800117 	ldw	r2,4(r2)
   1e844:	10800217 	ldw	r2,8(r2)
   1e848:	11000017 	ldw	r4,0(r2)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
   1e84c:	38001226 	beq	r7,zero,1e898 <alt_tse_phy_rd_mdio_reg+0x64>
   1e850:	0007883a 	mov	r3,zero
   1e854:	0005883a 	mov	r2,zero
    {
        bit_mask <<= 1;
   1e858:	1085883a 	add	r2,r2,r2
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
   1e85c:	18c00044 	addi	r3,r3,1
    {
        bit_mask <<= 1;
        bit_mask |= 0x01;        
   1e860:	10800054 	ori	r2,r2,1
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
   1e864:	19fffc16 	blt	r3,r7,1e858 <alt_tse_phy_rd_mdio_reg+0x24>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
   1e868:	29403fcc 	andi	r5,r5,255
   1e86c:	294b883a 	add	r5,r5,r5
   1e870:	20c0a004 	addi	r3,r4,640
   1e874:	294b883a 	add	r5,r5,r5
   1e878:	194b883a 	add	r5,r3,r5
   1e87c:	28c00037 	ldwio	r3,0(r5)
    
    /* shifting read data */
    temp_data >>= lsb_num;
   1e880:	31803fcc 	andi	r6,r6,255
   1e884:	18ffffcc 	andi	r3,r3,65535
   1e888:	1987d83a 	sra	r3,r3,r6
	if(reg_status & 0x4) {
		link_status |= 0x1;
	}
	
	return link_status;
}
   1e88c:	18ffffcc 	andi	r3,r3,65535
    
    /* shifting read data */
    temp_data >>= lsb_num;
    
    return (temp_data & bit_mask);
}
   1e890:	1884703a 	and	r2,r3,r2
   1e894:	f800283a 	ret
    alt_u16 temp_data;
    alt_u32 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
    
    bit_mask = 0x00;
   1e898:	0005883a 	mov	r2,zero
   1e89c:	003ff206 	br	1e868 <alt_tse_phy_rd_mdio_reg+0x34>

0001e8a0 <alt_tse_phy_add_profile_default>:
 * @param pmac  N/A
 * @return      Number of PHY in profile
 * 
 * User might add their own PHY by calling alt_tse_phy_add_profile()
 */
alt_32 alt_tse_phy_add_profile_default() {
   1e8a0:	deff9104 	addi	sp,sp,-444
   1e8a4:	dc006515 	stw	r16,404(sp)
        
    /* ------------------------------ */
    /* Marvell PHY on PHYWORKX board  */
    /* ------------------------------ */
    
    alt_tse_phy_profile MV88E1111 = {"Marvell 88E1111",      /* Marvell 88E1111                                  */
   1e8a8:	04001904 	movi	r16,100
   1e8ac:	d9004b04 	addi	r4,sp,300
   1e8b0:	800d883a 	mov	r6,r16
   1e8b4:	000b883a 	mov	r5,zero
 * @param pmac  N/A
 * @return      Number of PHY in profile
 * 
 * User might add their own PHY by calling alt_tse_phy_add_profile()
 */
alt_32 alt_tse_phy_add_profile_default() {
   1e8b8:	dfc06e15 	stw	ra,440(sp)
   1e8bc:	df006d15 	stw	fp,436(sp)
   1e8c0:	ddc06c15 	stw	r23,432(sp)
   1e8c4:	dd806b15 	stw	r22,428(sp)
   1e8c8:	dd406a15 	stw	r21,424(sp)
   1e8cc:	dd006915 	stw	r20,420(sp)
   1e8d0:	dcc06815 	stw	r19,416(sp)
   1e8d4:	dc806715 	stw	r18,412(sp)
   1e8d8:	dc406615 	stw	r17,408(sp)
        
    /* ------------------------------ */
    /* Marvell PHY on PHYWORKX board  */
    /* ------------------------------ */
    
    alt_tse_phy_profile MV88E1111 = {"Marvell 88E1111",      /* Marvell 88E1111                                  */
   1e8dc:	00103300 	call	10330 <memset>
   1e8e0:	008c5174 	movhi	r2,12613
   1e8e4:	108e0e04 	addi	r2,r2,14392
   1e8e8:	00dd9cb4 	movhi	r3,30322
   1e8ec:	18d85344 	addi	r3,r3,24909
   1e8f0:	07081b34 	movhi	fp,8300
   1e8f4:	e71b1944 	addi	fp,fp,27749
   1e8f8:	d9004f04 	addi	r4,sp,316
   1e8fc:	d8804d15 	stw	r2,308(sp)
   1e900:	000b883a 	mov	r5,zero
   1e904:	01801004 	movi	r6,64
   1e908:	00800c74 	movhi	r2,49
   1e90c:	108c4c44 	addi	r2,r2,12593
   1e910:	d8c04b15 	stw	r3,300(sp)
   1e914:	d8c06415 	stw	r3,400(sp)
   1e918:	df004c15 	stw	fp,304(sp)
   1e91c:	d8804e15 	stw	r2,312(sp)
   1e920:	00103300 	call	10330 <memset>
   1e924:	04400084 	movi	r17,2
   1e928:	04800444 	movi	r18,17
   1e92c:	05000344 	movi	r20,13
   1e930:	04c00284 	movi	r19,10
   1e934:	05d410c4 	movi	r23,20547
   1e938:	05800384 	movi	r22,14
   1e93c:	054000b4 	movhi	r21,2
   1e940:	ad778d04 	addi	r21,r21,-8652
    
    /* ---------------------------------- */
    /* Marvell Quad PHY on PHYWORKX board */
    /* ---------------------------------- */
    
    alt_tse_phy_profile MV88E1145 = {"Marvell Quad PHY 88E1145",      /* Marvell 88E1145                                  */
   1e944:	d9003204 	addi	r4,sp,200
   1e948:	800d883a 	mov	r6,r16
   1e94c:	000b883a 	mov	r5,zero
        
    /* ------------------------------ */
    /* Marvell PHY on PHYWORKX board  */
    /* ------------------------------ */
    
    alt_tse_phy_profile MV88E1111 = {"Marvell 88E1111",      /* Marvell 88E1111                                  */
   1e950:	00800304 	movi	r2,12
   1e954:	ddc05f15 	stw	r23,380(sp)
   1e958:	d8806005 	stb	r2,384(sp)
   1e95c:	dc406045 	stb	r17,385(sp)
   1e960:	dc806085 	stb	r18,386(sp)
   1e964:	dd8060c5 	stb	r22,387(sp)
   1e968:	dd006105 	stb	r20,388(sp)
   1e96c:	dcc06145 	stb	r19,389(sp)
   1e970:	dd406215 	stw	r21,392(sp)
    
    /* ---------------------------------- */
    /* Marvell Quad PHY on PHYWORKX board */
    /* ---------------------------------- */
    
    alt_tse_phy_profile MV88E1145 = {"Marvell Quad PHY 88E1145",      /* Marvell 88E1145                                  */
   1e974:	00103300 	call	10330 <memset>
   1e978:	00991874 	movhi	r2,25697
   1e97c:	109d5444 	addi	r2,r2,30033
   1e980:	d8c06417 	ldw	r3,400(sp)
   1e984:	d8803415 	stw	r2,208(sp)
   1e988:	00965234 	movhi	r2,22856
   1e98c:	10940804 	addi	r2,r2,20512
   1e990:	d8803515 	stw	r2,212(sp)
   1e994:	00914e34 	movhi	r2,17720
   1e998:	108e0804 	addi	r2,r2,14368
                      
    /* ------------------------------ */
    /* National PHY on PHYWORKX board */
    /* ------------------------------ */  
    
    alt_tse_phy_profile DP83865 = {"National DP83865",     /* National DP83865                                 */
   1e99c:	dc09883a 	add	r4,sp,r16
   1e9a0:	800d883a 	mov	r6,r16
    
    /* ---------------------------------- */
    /* Marvell Quad PHY on PHYWORKX board */
    /* ---------------------------------- */
    
    alt_tse_phy_profile MV88E1145 = {"Marvell Quad PHY 88E1145",      /* Marvell 88E1145                                  */
   1e9a4:	d8803615 	stw	r2,216(sp)
                      
    /* ------------------------------ */
    /* National PHY on PHYWORKX board */
    /* ------------------------------ */  
    
    alt_tse_phy_profile DP83865 = {"National DP83865",     /* National DP83865                                 */
   1e9a8:	000b883a 	mov	r5,zero
    
    /* ---------------------------------- */
    /* Marvell Quad PHY on PHYWORKX board */
    /* ---------------------------------- */
    
    alt_tse_phy_profile MV88E1145 = {"Marvell Quad PHY 88E1145",      /* Marvell 88E1145                                  */
   1e9ac:	008d4d34 	movhi	r2,13620
   1e9b0:	108c4c44 	addi	r2,r2,12593
   1e9b4:	d8c03215 	stw	r3,200(sp)
   1e9b8:	df003315 	stw	fp,204(sp)
   1e9bc:	d8803715 	stw	r2,220(sp)
   1e9c0:	ddc04615 	stw	r23,280(sp)
   1e9c4:	dd004705 	stb	r20,284(sp)
   1e9c8:	dc404745 	stb	r17,285(sp)
   1e9cc:	dc804785 	stb	r18,286(sp)
   1e9d0:	dd8047c5 	stb	r22,287(sp)
   1e9d4:	dd004805 	stb	r20,288(sp)
   1e9d8:	dcc04845 	stb	r19,289(sp)
   1e9dc:	dd404915 	stw	r21,292(sp)
                      
    /* ------------------------------ */
    /* National PHY on PHYWORKX board */
    /* ------------------------------ */  
    
    alt_tse_phy_profile DP83865 = {"National DP83865",     /* National DP83865                                 */
   1e9e0:	00103300 	call	10330 <memset>
   1e9e4:	009a5d34 	movhi	r2,26996
   1e9e8:	10985384 	addi	r2,r2,24910
   1e9ec:	d8801915 	stw	r2,100(sp)
   1e9f0:	009b1874 	movhi	r2,27745
   1e9f4:	109b9bc4 	addi	r2,r2,28271
   1e9f8:	d8801a15 	stw	r2,104(sp)
   1e9fc:	008e1434 	movhi	r2,14416
   1ea00:	10910804 	addi	r2,r2,17440
   1ea04:	d9001e04 	addi	r4,sp,120
   1ea08:	d8801b15 	stw	r2,108(sp)
   1ea0c:	000b883a 	mov	r5,zero
   1ea10:	01800f04 	movi	r6,60
   1ea14:	008d4db4 	movhi	r2,13622
   1ea18:	108e0cc4 	addi	r2,r2,14387
   1ea1c:	d8801c15 	stw	r2,112(sp)
   1ea20:	00103300 	call	10330 <memset>
   1ea24:	00800234 	movhi	r2,8
   1ea28:	108005c4 	addi	r2,r2,23
   1ea2c:	d8802d15 	stw	r2,180(sp)
   1ea30:	008001c4 	movi	r2,7
   1ea34:	d8802e05 	stb	r2,184(sp)
   1ea38:	008000c4 	movi	r2,3
                      
    /* -------------------------------------- */
    /* National 10/100 PHY on PHYWORKX board  */
    /* -------------------------------------- */ 
                      
    alt_tse_phy_profile DP83848C = {"National DP83848C",  /* National DP83848C                                          */
   1ea3c:	014000b4 	movhi	r5,2
   1ea40:	295cd404 	addi	r5,r5,29520
   1ea44:	800d883a 	mov	r6,r16
   1ea48:	d809883a 	mov	r4,sp
                      
    /* ------------------------------ */
    /* National PHY on PHYWORKX board */
    /* ------------------------------ */  
    
    alt_tse_phy_profile DP83865 = {"National DP83865",     /* National DP83865                                 */
   1ea4c:	d8802ec5 	stb	r2,187(sp)
   1ea50:	00800044 	movi	r2,1
   1ea54:	dcc02e45 	stb	r19,185(sp)
   1ea58:	dc802e85 	stb	r18,186(sp)
   1ea5c:	d8802f05 	stb	r2,188(sp)
   1ea60:	dc402f45 	stb	r17,189(sp)
                      
    /* -------------------------------------- */
    /* National 10/100 PHY on PHYWORKX board  */
    /* -------------------------------------- */ 
                      
    alt_tse_phy_profile DP83848C = {"National DP83848C",  /* National DP83848C                                          */
   1ea64:	00102380 	call	10238 <memcpy>
						   0,                              /* No function pointer configure National DP83848C            */
						   &DP83848C_link_status_read      /* Function pointer to read from PHY specific status register */           
                          };
                      
    /* add supported PHY to profile */                          
    alt_tse_phy_add_profile(&MV88E1111);
   1ea68:	d9004b04 	addi	r4,sp,300
   1ea6c:	001e0280 	call	1e028 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&MV88E1145);
   1ea70:	d9003204 	addi	r4,sp,200
   1ea74:	001e0280 	call	1e028 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83865);
   1ea78:	dc09883a 	add	r4,sp,r16
   1ea7c:	001e0280 	call	1e028 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83848C);
   1ea80:	d809883a 	mov	r4,sp
   1ea84:	001e0280 	call	1e028 <alt_tse_phy_add_profile>
    
    
    return phy_profile_count;
}
   1ea88:	d0a8df43 	ldbu	r2,-23683(gp)
   1ea8c:	dfc06e17 	ldw	ra,440(sp)
   1ea90:	df006d17 	ldw	fp,436(sp)
   1ea94:	ddc06c17 	ldw	r23,432(sp)
   1ea98:	dd806b17 	ldw	r22,428(sp)
   1ea9c:	dd406a17 	ldw	r21,424(sp)
   1eaa0:	dd006917 	ldw	r20,420(sp)
   1eaa4:	dcc06817 	ldw	r19,416(sp)
   1eaa8:	dc806717 	ldw	r18,412(sp)
   1eaac:	dc406617 	ldw	r17,408(sp)
   1eab0:	dc006517 	ldw	r16,404(sp)
   1eab4:	dec06f04 	addi	sp,sp,444
   1eab8:	f800283a 	ret

0001eabc <alt_tse_phy_print_profile>:
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
 
    }
    
    return phy_profile_count;
}
   1eabc:	d0a8df43 	ldbu	r2,-23683(gp)
   1eac0:	f800283a 	ret

0001eac4 <alt_tse_mac_group_init>:

    /* reset number of MAC group */
    mac_group_count = 0;
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
   1eac4:	d1201d03 	ldbu	r4,-32652(gp)
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      return SUCCESS
 *              return ALTERA_TSE_SYSTEM_DEF_ERROR if alt_tse_system_info structure definition error
 */
alt_32 alt_tse_mac_group_init() {
   1eac8:	defff604 	addi	sp,sp,-40
   1eacc:	dfc00915 	stw	ra,36(sp)
   1ead0:	df000815 	stw	fp,32(sp)
   1ead4:	ddc00715 	stw	r23,28(sp)
   1ead8:	dd800615 	stw	r22,24(sp)
   1eadc:	dd400515 	stw	r21,20(sp)
   1eae0:	dd000415 	stw	r20,16(sp)
   1eae4:	dcc00315 	stw	r19,12(sp)
   1eae8:	dc800215 	stw	r18,8(sp)
   1eaec:	dc400115 	stw	r17,4(sp)
   1eaf0:	dc000015 	stw	r16,0(sp)
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    alt_tse_system_info *psys = 0;

    /* reset number of MAC group */
    mac_group_count = 0;
   1eaf4:	d028df05 	stb	zero,-23684(gp)
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
   1eaf8:	20005026 	beq	r4,zero,1ec3c <alt_tse_mac_group_init+0x178>
   1eafc:	0023883a 	mov	r17,zero
   1eb00:	0027883a 	mov	r19,zero
   1eb04:	048000b4 	movhi	r18,2
   1eb08:	949d9604 	addi	r18,r18,30296
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
            }
            
            /* store the pointer in global variable */
            pmac_groups[mac_group_count] = pmac_group;
   1eb0c:	058001f4 	movhi	r22,7
   1eb10:	b5949d04 	addi	r22,r22,21108
                if(pmac_info->psys_info->tse_en_maclite) {
                    if(pmac_info->psys_info->tse_maclite_gige) {
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_1000;
                    }
                    else {
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_10_100;
   1eb14:	05000044 	movi	r20,1
    /* reset number of MAC group */
    mac_group_count = 0;
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
        psys = &tse_mac_device[i];
   1eb18:	8c001224 	muli	r16,r17,72
   1eb1c:	9421883a 	add	r16,r18,r16

        if((psys->tse_sgdma_tx != 0) && (psys->tse_sgdma_rx != 0)) {    	
   1eb20:	80800517 	ldw	r2,20(r16)
   1eb24:	10004026 	beq	r2,zero,1ec28 <alt_tse_mac_group_init+0x164>
   1eb28:	80800617 	ldw	r2,24(r16)
   1eb2c:	10003e26 	beq	r2,zero,1ec28 <alt_tse_mac_group_init+0x164>
            tse_dprintf(5, "INFO    : TSE MAC %d found at address 0x%08x\n", mac_group_count, (int) psys->tse_mac_base);
   1eb30:	d168df03 	ldbu	r5,-23684(gp)
   1eb34:	81800017 	ldw	r6,0(r16)
   1eb38:	010000b4 	movhi	r4,2
   1eb3c:	2119c004 	addi	r4,r4,26368
   1eb40:	00104380 	call	10438 <printf>
            
            /* Allocate memory for the structure */
            pmac_group = (alt_tse_mac_group *) malloc(sizeof(alt_tse_mac_group));
   1eb44:	01000904 	movi	r4,36
   1eb48:	00231640 	call	23164 <malloc>
   1eb4c:	102f883a 	mov	r23,r2
            if(!pmac_group) {
   1eb50:	10005a26 	beq	r2,zero,1ecbc <alt_tse_mac_group_init+0x1f8>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]\n", mac_group_count);
                return ALTERA_TSE_MALLOC_FAILED;
            }
           
            /* Non-multi-channel MAC considered as 1 channel */
            if(psys->tse_multichannel_mac) {
   1eb54:	808002c3 	ldbu	r2,11(r16)
   1eb58:	10003a26 	beq	r2,zero,1ec44 <alt_tse_mac_group_init+0x180>
                pmac_group->channel = psys->tse_num_of_channel;
   1eb5c:	80c00303 	ldbu	r3,12(r16)
   1eb60:	b8c00005 	stb	r3,0(r23)
                pmac_group->channel = 1;
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
   1eb64:	18803fcc 	andi	r2,r3,255
   1eb68:	10002426 	beq	r2,zero,1ebfc <alt_tse_mac_group_init+0x138>

    /* reset number of MAC group */
    mac_group_count = 0;
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
   1eb6c:	07000044 	movi	fp,1
   1eb70:	0021883a 	mov	r16,zero
                }
                
                /* MAC type detection */
                if(pmac_info->psys_info->tse_en_maclite) {
                    if(pmac_info->psys_info->tse_maclite_gige) {
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_1000;
   1eb74:	05400084 	movi	r21,2
   1eb78:	00000d06 	br	1ebb0 <alt_tse_mac_group_init+0xec>
                    return ALTERA_TSE_SYSTEM_DEF_ERROR;
                }
                
                /* MAC type detection */
                if(pmac_info->psys_info->tse_en_maclite) {
                    if(pmac_info->psys_info->tse_maclite_gige) {
   1eb7c:	18c00283 	ldbu	r3,10(r3)
   1eb80:	18001c26 	beq	r3,zero,1ebf4 <alt_tse_mac_group_init+0x130>
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_1000;
   1eb84:	15400005 	stb	r21,0(r2)
	                    tse_dprintf(6, "INFO    : MAC Device               = tse_mac_device[%d]\n", i + j);
	                }
                }
                
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
   1eb88:	84000044 	addi	r16,r16,1
   1eb8c:	8421883a 	add	r16,r16,r16
                pmac_group->channel = 1;
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
   1eb90:	b8c00003 	ldbu	r3,0(r23)
	                    tse_dprintf(6, "INFO    : MAC Device               = tse_mac_device[%d]\n", i + j);
	                }
                }
                
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
   1eb94:	8421883a 	add	r16,r16,r16
   1eb98:	bc09883a 	add	r4,r23,r16
   1eb9c:	20800015 	stw	r2,0(r4)
                pmac_group->channel = 1;
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
   1eba0:	e021883a 	mov	r16,fp
   1eba4:	18803fcc 	andi	r2,r3,255
   1eba8:	e7000044 	addi	fp,fp,1
   1ebac:	8080130e 	bge	r16,r2,1ebfc <alt_tse_mac_group_init+0x138>
                /* Allocate memory for the structure */
                pmac_info = (alt_tse_mac_info *) malloc(sizeof(alt_tse_mac_info));
   1ebb0:	01000404 	movi	r4,16
   1ebb4:	00231640 	call	23164 <malloc>
                
                pmac_info->pmac_group = pmac_group;
                
                pmac_info->pphy_info = 0;
                
                pmac_info->psys_info = &tse_mac_device[i + j];
   1ebb8:	8c0b883a 	add	r5,r17,r16
   1ebbc:	28c01224 	muli	r3,r5,72
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
                /* Allocate memory for the structure */
                pmac_info = (alt_tse_mac_info *) malloc(sizeof(alt_tse_mac_info));
                if(!pmac_info) {
   1ebc0:	10003726 	beq	r2,zero,1eca0 <alt_tse_mac_group_init+0x1dc>
                
                pmac_info->pmac_group = pmac_group;
                
                pmac_info->pphy_info = 0;
                
                pmac_info->psys_info = &tse_mac_device[i + j];
   1ebc4:	90c7883a 	add	r3,r18,r3
                
                /* check to make sure the alt_tse_system_info defined correctly or has been defined */
                if((pmac_info->psys_info->tse_sgdma_tx == 0) || (pmac_info->psys_info->tse_sgdma_rx == 0)){                	
   1ebc8:	19000517 	ldw	r4,20(r3)
                if(!pmac_info) {
                    tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]->pmac_info[%d]\n", mac_group_count, j);
                    return ALTERA_TSE_MALLOC_FAILED;
                }
                
                pmac_info->pmac_group = pmac_group;
   1ebcc:	15c00315 	stw	r23,12(r2)
                
                pmac_info->pphy_info = 0;
   1ebd0:	10000115 	stw	zero,4(r2)
                
                pmac_info->psys_info = &tse_mac_device[i + j];
   1ebd4:	10c00215 	stw	r3,8(r2)
                
                /* check to make sure the alt_tse_system_info defined correctly or has been defined */
                if((pmac_info->psys_info->tse_sgdma_tx == 0) || (pmac_info->psys_info->tse_sgdma_rx == 0)){                	
   1ebd8:	20001f26 	beq	r4,zero,1ec58 <alt_tse_mac_group_init+0x194>
   1ebdc:	19000617 	ldw	r4,24(r3)
   1ebe0:	20001d26 	beq	r4,zero,1ec58 <alt_tse_mac_group_init+0x194>
                    tse_dprintf(2, "ERROR   : tse_mac_device[%d] does not defined correctly!\n", i + j);
                    return ALTERA_TSE_SYSTEM_DEF_ERROR;
                }
                
                /* MAC type detection */
                if(pmac_info->psys_info->tse_en_maclite) {
   1ebe4:	19000243 	ldbu	r4,9(r3)
   1ebe8:	203fe41e 	bne	r4,zero,1eb7c <alt_tse_mac_group_init+0xb8>
                    else {
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_10_100;
                    }
                }
                else {
                    pmac_info->mac_type = ALTERA_TSE_FULL_MAC;                    
   1ebec:	10000005 	stb	zero,0(r2)
   1ebf0:	003fe506 	br	1eb88 <alt_tse_mac_group_init+0xc4>
                if(pmac_info->psys_info->tse_en_maclite) {
                    if(pmac_info->psys_info->tse_maclite_gige) {
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_1000;
                    }
                    else {
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_10_100;
   1ebf4:	15000005 	stb	r20,0(r2)
   1ebf8:	003fe306 	br	1eb88 <alt_tse_mac_group_init+0xc4>
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
            }
            
            /* store the pointer in global variable */
            pmac_groups[mac_group_count] = pmac_group;
   1ebfc:	d0a8df03 	ldbu	r2,-23684(gp)
   1ec00:	d1201d03 	ldbu	r4,-32652(gp)
            
            mac_group_count++;

            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
   1ec04:	9cffffc4 	addi	r19,r19,-1
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
            }
            
            /* store the pointer in global variable */
            pmac_groups[mac_group_count] = pmac_group;
   1ec08:	11403fcc 	andi	r5,r2,255
   1ec0c:	294b883a 	add	r5,r5,r5
   1ec10:	294b883a 	add	r5,r5,r5
   1ec14:	b14b883a 	add	r5,r22,r5
            
            mac_group_count++;
   1ec18:	10800044 	addi	r2,r2,1
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
            }
            
            /* store the pointer in global variable */
            pmac_groups[mac_group_count] = pmac_group;
   1ec1c:	2dc00015 	stw	r23,0(r5)
            
            mac_group_count++;
   1ec20:	d0a8df05 	stb	r2,-23684(gp)

            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
   1ec24:	98e7883a 	add	r19,r19,r3

    /* reset number of MAC group */
    mac_group_count = 0;
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
   1ec28:	9cc00044 	addi	r19,r19,1
   1ec2c:	9c403fcc 	andi	r17,r19,255
   1ec30:	8c40201c 	xori	r17,r17,128
   1ec34:	8c7fe004 	addi	r17,r17,-128
   1ec38:	893fb716 	blt	r17,r4,1eb18 <alt_tse_mac_group_init+0x54>
            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
                        
        }
    }
    return SUCCESS;
   1ec3c:	0005883a 	mov	r2,zero
   1ec40:	00000906 	br	1ec68 <alt_tse_mac_group_init+0x1a4>
                pmac_group->channel = psys->tse_num_of_channel;
                tse_dprintf(6, "INFO    : Multi Channel            = Yes\n");
                tse_dprintf(6, "INFO    : Number of channel        = %d\n", pmac_group->channel);
            	tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
            }
            else if(psys->tse_mdio_shared) {
   1ec44:	80800343 	ldbu	r2,13(r16)
   1ec48:	10001326 	beq	r2,zero,1ec98 <alt_tse_mac_group_init+0x1d4>
                pmac_group->channel = psys->tse_number_of_mac_mdio_shared;
   1ec4c:	80c00383 	ldbu	r3,14(r16)
   1ec50:	b8c00005 	stb	r3,0(r23)
   1ec54:	003fc306 	br	1eb64 <alt_tse_mac_group_init+0xa0>
                
                pmac_info->psys_info = &tse_mac_device[i + j];
                
                /* check to make sure the alt_tse_system_info defined correctly or has been defined */
                if((pmac_info->psys_info->tse_sgdma_tx == 0) || (pmac_info->psys_info->tse_sgdma_rx == 0)){                	
                    tse_dprintf(2, "ERROR   : tse_mac_device[%d] does not defined correctly!\n", i + j);
   1ec58:	010000b4 	movhi	r4,2
   1ec5c:	2119ec04 	addi	r4,r4,26544
   1ec60:	00104380 	call	10438 <printf>
                    return ALTERA_TSE_SYSTEM_DEF_ERROR;
   1ec64:	00bfffc4 	movi	r2,-1
            i += (pmac_group->channel - 1);
                        
        }
    }
    return SUCCESS;
}
   1ec68:	dfc00917 	ldw	ra,36(sp)
   1ec6c:	df000817 	ldw	fp,32(sp)
   1ec70:	ddc00717 	ldw	r23,28(sp)
   1ec74:	dd800617 	ldw	r22,24(sp)
   1ec78:	dd400517 	ldw	r21,20(sp)
   1ec7c:	dd000417 	ldw	r20,16(sp)
   1ec80:	dcc00317 	ldw	r19,12(sp)
   1ec84:	dc800217 	ldw	r18,8(sp)
   1ec88:	dc400117 	ldw	r17,4(sp)
   1ec8c:	dc000017 	ldw	r16,0(sp)
   1ec90:	dec00a04 	addi	sp,sp,40
   1ec94:	f800283a 	ret
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
                tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
                tse_dprintf(6, "INFO    : Number of MAC Share MDIO = %d\n", pmac_group->channel);
            }
            else {
                pmac_group->channel = 1;
   1ec98:	bd000005 	stb	r20,0(r23)
   1ec9c:	003fb306 	br	1eb6c <alt_tse_mac_group_init+0xa8>
            
            for(j = 0; j < pmac_group->channel; j++) {
                /* Allocate memory for the structure */
                pmac_info = (alt_tse_mac_info *) malloc(sizeof(alt_tse_mac_info));
                if(!pmac_info) {
                    tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]->pmac_info[%d]\n", mac_group_count, j);
   1eca0:	d168df03 	ldbu	r5,-23684(gp)
   1eca4:	010000b4 	movhi	r4,2
   1eca8:	2119da04 	addi	r4,r4,26472
   1ecac:	800d883a 	mov	r6,r16
   1ecb0:	00104380 	call	10438 <printf>
                    return ALTERA_TSE_MALLOC_FAILED;
   1ecb4:	00bfffc4 	movi	r2,-1
   1ecb8:	003feb06 	br	1ec68 <alt_tse_mac_group_init+0x1a4>
            tse_dprintf(5, "INFO    : TSE MAC %d found at address 0x%08x\n", mac_group_count, (int) psys->tse_mac_base);
            
            /* Allocate memory for the structure */
            pmac_group = (alt_tse_mac_group *) malloc(sizeof(alt_tse_mac_group));
            if(!pmac_group) {
                tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]\n", mac_group_count);
   1ecbc:	d168df03 	ldbu	r5,-23684(gp)
   1ecc0:	010000b4 	movhi	r4,2
   1ecc4:	2119cc04 	addi	r4,r4,26416
   1ecc8:	00104380 	call	10438 <printf>
                return ALTERA_TSE_MALLOC_FAILED;
   1eccc:	00bfffc4 	movi	r2,-1
   1ecd0:	003fe506 	br	1ec68 <alt_tse_mac_group_init+0x1a4>

0001ecd4 <alt_tse_mac_associate_phy>:
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   1ecd4:	d1e8df03 	ldbu	r7,-23684(gp)
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @param pphy        Pointer to the TSE PHY info structure which hold information of PHY
 * @return            return TSE_PHY_MAP_ERROR if mapping error
 *                    return TSE_PHY_MAP_SUCCESS otherwise
 */
alt_32 alt_tse_mac_associate_phy(alt_tse_mac_group *pmac_group, alt_tse_phy_info *pphy) {
   1ecd8:	deffff04 	addi	sp,sp,-4
   1ecdc:	dfc00015 	stw	ra,0(sp)
   1ece0:	281d883a 	mov	r14,r5
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   1ece4:	38000c26 	beq	r7,zero,1ed18 <alt_tse_mac_associate_phy+0x44>
        if(pmac_group == pmac_groups[i]) {
   1ece8:	00c001f4 	movhi	r3,7
   1ecec:	18d49d04 	addi	r3,r3,21108
   1ecf0:	18800017 	ldw	r2,0(r3)
   1ecf4:	20808f26 	beq	r4,r2,1ef34 <alt_tse_mac_associate_phy+0x260>
   1ecf8:	18c00104 	addi	r3,r3,4
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   1ecfc:	0005883a 	mov	r2,zero
   1ed00:	00000206 	br	1ed0c <alt_tse_mac_associate_phy+0x38>
        if(pmac_group == pmac_groups[i]) {
   1ed04:	19bfff17 	ldw	r6,-4(r3)
   1ed08:	21806e26 	beq	r4,r6,1eec4 <alt_tse_mac_associate_phy+0x1f0>
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   1ed0c:	10800044 	addi	r2,r2,1
   1ed10:	18c00104 	addi	r3,r3,4
   1ed14:	11fffb16 	blt	r2,r7,1ed04 <alt_tse_mac_associate_phy+0x30>
   1ed18:	017fffc4 	movi	r5,-1
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    alt_8 sys_info_index = 0;
    
    is_mapped = 0;
    
    for(i = 0; i < pmac_group->channel; i++) {
   1ed1c:	23000003 	ldbu	r12,0(r4)
   1ed20:	60006c26 	beq	r12,zero,1eed4 <alt_tse_mac_associate_phy+0x200>
        pmac_info = pmac_group->pmac_info[i];
   1ed24:	22c00117 	ldw	r11,4(r4)
        psys = pmac_info->psys_info;
       
        /* map according to the PHY address in alt_tse_system_info.h */
        if(psys->tse_phy_mdio_address == pphy->mdio_address) {
   1ed28:	73400003 	ldbu	r13,0(r14)
    
    is_mapped = 0;
    
    for(i = 0; i < pmac_group->channel; i++) {
        pmac_info = pmac_group->pmac_info[i];
        psys = pmac_info->psys_info;
   1ed2c:	5a400217 	ldw	r9,8(r11)
       
        /* map according to the PHY address in alt_tse_system_info.h */
        if(psys->tse_phy_mdio_address == pphy->mdio_address) {
   1ed30:	48801017 	ldw	r2,64(r9)
   1ed34:	13404026 	beq	r2,r13,1ee38 <alt_tse_mac_associate_phy+0x164>
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @param pphy        Pointer to the TSE PHY info structure which hold information of PHY
 * @return            return TSE_PHY_MAP_ERROR if mapping error
 *                    return TSE_PHY_MAP_SUCCESS otherwise
 */
alt_32 alt_tse_mac_associate_phy(alt_tse_mac_group *pmac_group, alt_tse_phy_info *pphy) {
   1ed38:	21000204 	addi	r4,r4,8
   1ed3c:	200d883a 	mov	r6,r4
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    alt_8 sys_info_index = 0;
    
    is_mapped = 0;
    
    for(i = 0; i < pmac_group->channel; i++) {
   1ed40:	0007883a 	mov	r3,zero
   1ed44:	00000506 	br	1ed5c <alt_tse_mac_associate_phy+0x88>
        pmac_info = pmac_group->pmac_info[i];
   1ed48:	32000017 	ldw	r8,0(r6)
   1ed4c:	31800104 	addi	r6,r6,4
        psys = pmac_info->psys_info;
   1ed50:	42800217 	ldw	r10,8(r8)
       
        /* map according to the PHY address in alt_tse_system_info.h */
        if(psys->tse_phy_mdio_address == pphy->mdio_address) {
   1ed54:	51c01017 	ldw	r7,64(r10)
   1ed58:	3b403926 	beq	r7,r13,1ee40 <alt_tse_mac_associate_phy+0x16c>
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    alt_8 sys_info_index = 0;
    
    is_mapped = 0;
    
    for(i = 0; i < pmac_group->channel; i++) {
   1ed5c:	18c00044 	addi	r3,r3,1
   1ed60:	1b3ff916 	blt	r3,r12,1ed48 <alt_tse_mac_associate_phy+0x74>
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @param pphy        Pointer to the TSE PHY info structure which hold information of PHY
 * @return            return TSE_PHY_MAP_ERROR if mapping error
 *                    return TSE_PHY_MAP_SUCCESS otherwise
 */
alt_32 alt_tse_mac_associate_phy(alt_tse_mac_group *pmac_group, alt_tse_phy_info *pphy) {
   1ed64:	63000044 	addi	r12,r12,1
   1ed68:	00c00044 	movi	r3,1
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
            	continue;
            }
            
            if(psys->tse_phy_mdio_address == TSE_PHY_AUTO_ADDRESS) {
   1ed6c:	01bfffc4 	movi	r6,-1
        for(i = 0; i < pmac_group->channel; i++) {
            pmac_info = pmac_group->pmac_info[i];
            psys = pmac_info->psys_info;
            
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
   1ed70:	49c00517 	ldw	r7,20(r9)
   1ed74:	18c00044 	addi	r3,r3,1
   1ed78:	38000426 	beq	r7,zero,1ed8c <alt_tse_mac_associate_phy+0xb8>
   1ed7c:	49c00617 	ldw	r7,24(r9)
   1ed80:	38000226 	beq	r7,zero,1ed8c <alt_tse_mac_associate_phy+0xb8>
            	continue;
            }
            
            if(psys->tse_phy_mdio_address == TSE_PHY_AUTO_ADDRESS) {
   1ed84:	49c01017 	ldw	r7,64(r9)
   1ed88:	39800526 	beq	r7,r6,1eda0 <alt_tse_mac_associate_phy+0xcc>
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
        for(i = 0; i < pmac_group->channel; i++) {
   1ed8c:	1b005126 	beq	r3,r12,1eed4 <alt_tse_mac_associate_phy+0x200>
   1ed90:	22c00017 	ldw	r11,0(r4)
   1ed94:	21000104 	addi	r4,r4,4
   1ed98:	5a400217 	ldw	r9,8(r11)
   1ed9c:	003ff406 	br	1ed70 <alt_tse_mac_associate_phy+0x9c>
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1eda0:	58800317 	ldw	r2,12(r11)
   1eda4:	11000003 	ldbu	r4,0(r2)
   1eda8:	20000b26 	beq	r4,zero,1edd8 <alt_tse_mac_associate_phy+0x104>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   1edac:	10c00117 	ldw	r3,4(r2)
   1edb0:	1ac06426 	beq	r3,r11,1ef44 <alt_tse_mac_associate_phy+0x270>
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @param pphy        Pointer to the TSE PHY info structure which hold information of PHY
 * @return            return TSE_PHY_MAP_ERROR if mapping error
 *                    return TSE_PHY_MAP_SUCCESS otherwise
 */
alt_32 alt_tse_mac_associate_phy(alt_tse_mac_group *pmac_group, alt_tse_phy_info *pphy) {
   1edb4:	10800204 	addi	r2,r2,8
   1edb8:	000d883a 	mov	r6,zero
   1edbc:	00000206 	br	1edc8 <alt_tse_mac_associate_phy+0xf4>
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   1edc0:	10ffff17 	ldw	r3,-4(r2)
   1edc4:	1ac05326 	beq	r3,r11,1ef14 <alt_tse_mac_associate_phy+0x240>
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1edc8:	31800044 	addi	r6,r6,1
   1edcc:	10800104 	addi	r2,r2,4
   1edd0:	313ffb16 	blt	r6,r4,1edc0 <alt_tse_mac_associate_phy+0xec>
   1edd4:	01bfffc4 	movi	r6,-1
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
   1edd8:	d1201d03 	ldbu	r4,-32652(gp)
   1eddc:	20000a26 	beq	r4,zero,1ee08 <alt_tse_mac_associate_phy+0x134>
        if(psys_info == &tse_mac_device[i]) {
   1ede0:	008000b4 	movhi	r2,2
   1ede4:	109d9604 	addi	r2,r2,30296
   1ede8:	000f883a 	mov	r7,zero
   1edec:	4880031e 	bne	r9,r2,1edfc <alt_tse_mac_associate_phy+0x128>
   1edf0:	00000606 	br	1ee0c <alt_tse_mac_associate_phy+0x138>
   1edf4:	10c7883a 	add	r3,r2,r3
   1edf8:	48c04a26 	beq	r9,r3,1ef24 <alt_tse_mac_associate_phy+0x250>
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
   1edfc:	39c00044 	addi	r7,r7,1
        if(psys_info == &tse_mac_device[i]) {
   1ee00:	38c01224 	muli	r3,r7,72
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
   1ee04:	393ffb16 	blt	r7,r4,1edf4 <alt_tse_mac_associate_phy+0x120>
   1ee08:	01ffffc4 	movi	r7,-1
            
            if(psys->tse_phy_mdio_address == TSE_PHY_AUTO_ADDRESS) {
                mac_info_index = alt_tse_get_mac_info_index(pmac_info);
                sys_info_index = alt_tse_get_system_index(psys);
                
                pmac_info->pphy_info = pphy;
   1ee0c:	5b800115 	stw	r14,4(r11)
                pphy->pmac_info = pmac_info;
                psys->tse_phy_mdio_address = pphy->mdio_address;
   1ee10:	70800003 	ldbu	r2,0(r14)
            if(psys->tse_phy_mdio_address == TSE_PHY_AUTO_ADDRESS) {
                mac_info_index = alt_tse_get_mac_info_index(pmac_info);
                sys_info_index = alt_tse_get_system_index(psys);
                
                pmac_info->pphy_info = pphy;
                pphy->pmac_info = pmac_info;
   1ee14:	72c00615 	stw	r11,24(r14)
                psys->tse_phy_mdio_address = pphy->mdio_address;
                tse_dprintf(5, "INFO    : PHY[%d.%d] - Automatically mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
   1ee18:	010000b4 	movhi	r4,2
   1ee1c:	211a0b04 	addi	r4,r4,26668
                mac_info_index = alt_tse_get_mac_info_index(pmac_info);
                sys_info_index = alt_tse_get_system_index(psys);
                
                pmac_info->pphy_info = pphy;
                pphy->pmac_info = pmac_info;
                psys->tse_phy_mdio_address = pphy->mdio_address;
   1ee20:	48801015 	stw	r2,64(r9)
                tse_dprintf(5, "INFO    : PHY[%d.%d] - Automatically mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
   1ee24:	00104380 	call	10438 <printf>
 *                    return TSE_PHY_MAP_SUCCESS otherwise
 */
alt_32 alt_tse_mac_associate_phy(alt_tse_mac_group *pmac_group, alt_tse_phy_info *pphy) {
    
	alt_32 i;
	alt_32 return_value = TSE_PHY_MAP_SUCCESS;
   1ee28:	0005883a 	mov	r2,zero
        tse_dprintf(2, "WARNING : PHY[%d.X] - Mapping of PHY to MAC failed! Make sure the PHY address is defined correctly in tse_mac_device[] structure, and number of PHYs connected is equivalent to number of channel\n", mac_group_index);
        return_value = TSE_PHY_MAP_ERROR;
    }
    
    return return_value;
}
   1ee2c:	dfc00017 	ldw	ra,0(sp)
   1ee30:	dec00104 	addi	sp,sp,4
   1ee34:	f800283a 	ret
    for(i = 0; i < pmac_group->channel; i++) {
        pmac_info = pmac_group->pmac_info[i];
        psys = pmac_info->psys_info;
       
        /* map according to the PHY address in alt_tse_system_info.h */
        if(psys->tse_phy_mdio_address == pphy->mdio_address) {
   1ee38:	4815883a 	mov	r10,r9
   1ee3c:	5811883a 	mov	r8,r11
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1ee40:	40c00317 	ldw	r3,12(r8)
   1ee44:	18800003 	ldbu	r2,0(r3)
   1ee48:	10000a26 	beq	r2,zero,1ee74 <alt_tse_mac_associate_phy+0x1a0>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   1ee4c:	19000117 	ldw	r4,4(r3)
   1ee50:	41003a26 	beq	r8,r4,1ef3c <alt_tse_mac_associate_phy+0x268>
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @param pphy        Pointer to the TSE PHY info structure which hold information of PHY
 * @return            return TSE_PHY_MAP_ERROR if mapping error
 *                    return TSE_PHY_MAP_SUCCESS otherwise
 */
alt_32 alt_tse_mac_associate_phy(alt_tse_mac_group *pmac_group, alt_tse_phy_info *pphy) {
   1ee54:	18c00204 	addi	r3,r3,8
   1ee58:	000d883a 	mov	r6,zero
   1ee5c:	00000206 	br	1ee68 <alt_tse_mac_associate_phy+0x194>
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   1ee60:	193fff17 	ldw	r4,-4(r3)
   1ee64:	41002326 	beq	r8,r4,1eef4 <alt_tse_mac_associate_phy+0x220>
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1ee68:	31800044 	addi	r6,r6,1
   1ee6c:	18c00104 	addi	r3,r3,4
   1ee70:	30bffb16 	blt	r6,r2,1ee60 <alt_tse_mac_associate_phy+0x18c>
   1ee74:	01bfffc4 	movi	r6,-1
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
   1ee78:	d1201d03 	ldbu	r4,-32652(gp)
   1ee7c:	20000a26 	beq	r4,zero,1eea8 <alt_tse_mac_associate_phy+0x1d4>
        if(psys_info == &tse_mac_device[i]) {
   1ee80:	008000b4 	movhi	r2,2
   1ee84:	109d9604 	addi	r2,r2,30296
   1ee88:	000f883a 	mov	r7,zero
   1ee8c:	5080031e 	bne	r10,r2,1ee9c <alt_tse_mac_associate_phy+0x1c8>
   1ee90:	00000606 	br	1eeac <alt_tse_mac_associate_phy+0x1d8>
   1ee94:	10c7883a 	add	r3,r2,r3
   1ee98:	50c01a26 	beq	r10,r3,1ef04 <alt_tse_mac_associate_phy+0x230>
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
   1ee9c:	39c00044 	addi	r7,r7,1
        if(psys_info == &tse_mac_device[i]) {
   1eea0:	38c01224 	muli	r3,r7,72
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
   1eea4:	393ffb16 	blt	r7,r4,1ee94 <alt_tse_mac_associate_phy+0x1c0>
   1eea8:	01ffffc4 	movi	r7,-1
        /* map according to the PHY address in alt_tse_system_info.h */
        if(psys->tse_phy_mdio_address == pphy->mdio_address) {
        	mac_info_index = alt_tse_get_mac_info_index(pmac_info);
	        sys_info_index = alt_tse_get_system_index(psys);
	        
            pmac_info->pphy_info = pphy;
   1eeac:	43800115 	stw	r14,4(r8)
            pphy->pmac_info = pmac_info;
   1eeb0:	72000615 	stw	r8,24(r14)
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Explicitly mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
   1eeb4:	010000b4 	movhi	r4,2
   1eeb8:	2119fb04 	addi	r4,r4,26604
   1eebc:	00104380 	call	10438 <printf>
   1eec0:	003fd906 	br	1ee28 <alt_tse_mac_associate_phy+0x154>
   1eec4:	11403fcc 	andi	r5,r2,255
   1eec8:	2940201c 	xori	r5,r5,128
   1eecc:	297fe004 	addi	r5,r5,-128
   1eed0:	003f9206 	br	1ed1c <alt_tse_mac_associate_phy+0x48>
        }
    }
    
    /* Still cannot find any matched MAC-PHY */
    if(is_mapped == 0) {
    	pphy->pmac_info = 0;
   1eed4:	70000615 	stw	zero,24(r14)
        tse_dprintf(2, "WARNING : PHY[%d.X] - Mapping of PHY to MAC failed! Make sure the PHY address is defined correctly in tse_mac_device[] structure, and number of PHYs connected is equivalent to number of channel\n", mac_group_index);
   1eed8:	010000b4 	movhi	r4,2
   1eedc:	211a1c04 	addi	r4,r4,26736
   1eee0:	00104380 	call	10438 <printf>
        return_value = TSE_PHY_MAP_ERROR;
   1eee4:	00bfffc4 	movi	r2,-1
    }
    
    return return_value;
}
   1eee8:	dfc00017 	ldw	ra,0(sp)
   1eeec:	dec00104 	addi	sp,sp,4
   1eef0:	f800283a 	ret
   1eef4:	31803fcc 	andi	r6,r6,255
   1eef8:	3180201c 	xori	r6,r6,128
   1eefc:	31bfe004 	addi	r6,r6,-128
   1ef00:	003fdd06 	br	1ee78 <alt_tse_mac_associate_phy+0x1a4>
   1ef04:	39c03fcc 	andi	r7,r7,255
   1ef08:	39c0201c 	xori	r7,r7,128
   1ef0c:	39ffe004 	addi	r7,r7,-128
   1ef10:	003fe606 	br	1eeac <alt_tse_mac_associate_phy+0x1d8>
   1ef14:	31803fcc 	andi	r6,r6,255
   1ef18:	3180201c 	xori	r6,r6,128
   1ef1c:	31bfe004 	addi	r6,r6,-128
   1ef20:	003fad06 	br	1edd8 <alt_tse_mac_associate_phy+0x104>
   1ef24:	39c03fcc 	andi	r7,r7,255
   1ef28:	39c0201c 	xori	r7,r7,128
   1ef2c:	39ffe004 	addi	r7,r7,-128
   1ef30:	003fb606 	br	1ee0c <alt_tse_mac_associate_phy+0x138>
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
        if(pmac_group == pmac_groups[i]) {
   1ef34:	000b883a 	mov	r5,zero
   1ef38:	003f7806 	br	1ed1c <alt_tse_mac_associate_phy+0x48>
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   1ef3c:	000d883a 	mov	r6,zero
   1ef40:	003fcd06 	br	1ee78 <alt_tse_mac_associate_phy+0x1a4>
   1ef44:	000d883a 	mov	r6,zero
   1ef48:	003fa306 	br	1edd8 <alt_tse_mac_associate_phy+0x104>

0001ef4c <alt_tse_phy_cfg_pcs>:
 */
alt_32 alt_tse_phy_cfg_pcs(alt_tse_mac_info *pmac_info) {
    
    alt_tse_system_info *psys = pmac_info->psys_info;
    np_tse_mac *pmac = (np_tse_mac *) psys->tse_mac_base;
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   1ef4c:	21c00317 	ldw	r7,12(r4)
/* @Function Description: Configure operating mode of Altera PCS if available
 * @API Type:           Internal
 * @param pmac_info     pointer to MAC info variable
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_cfg_pcs(alt_tse_mac_info *pmac_info) {
   1ef50:	defffa04 	addi	sp,sp,-24
   1ef54:	dc400115 	stw	r17,4(sp)
   1ef58:	dc000015 	stw	r16,0(sp)
   1ef5c:	dfc00515 	stw	ra,20(sp)
   1ef60:	dd000415 	stw	r20,16(sp)
   1ef64:	dcc00315 	stw	r19,12(sp)
   1ef68:	dc800215 	stw	r18,8(sp)
    
    alt_tse_system_info *psys = pmac_info->psys_info;
   1ef6c:	24000217 	ldw	r16,8(r4)
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1ef70:	39400003 	ldbu	r5,0(r7)
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_cfg_pcs(alt_tse_mac_info *pmac_info) {
    
    alt_tse_system_info *psys = pmac_info->psys_info;
    np_tse_mac *pmac = (np_tse_mac *) psys->tse_mac_base;
   1ef74:	84400017 	ldw	r17,0(r16)
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1ef78:	28000a26 	beq	r5,zero,1efa4 <alt_tse_phy_cfg_pcs+0x58>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   1ef7c:	38800117 	ldw	r2,4(r7)
   1ef80:	20804326 	beq	r4,r2,1f090 <alt_tse_phy_cfg_pcs+0x144>
/* @Function Description: Configure operating mode of Altera PCS if available
 * @API Type:           Internal
 * @param pmac_info     pointer to MAC info variable
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_cfg_pcs(alt_tse_mac_info *pmac_info) {
   1ef84:	38800204 	addi	r2,r7,8
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1ef88:	000d883a 	mov	r6,zero
   1ef8c:	00000206 	br	1ef98 <alt_tse_phy_cfg_pcs+0x4c>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   1ef90:	10ffff17 	ldw	r3,-4(r2)
   1ef94:	20c00426 	beq	r4,r3,1efa8 <alt_tse_phy_cfg_pcs+0x5c>
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1ef98:	31800044 	addi	r6,r6,1
   1ef9c:	10800104 	addi	r2,r2,4
   1efa0:	317ffb16 	blt	r6,r5,1ef90 <alt_tse_phy_cfg_pcs+0x44>
   1efa4:	01bfffc4 	movi	r6,-1
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   1efa8:	d128df03 	ldbu	r4,-23684(gp)
   1efac:	20000c26 	beq	r4,zero,1efe0 <alt_tse_phy_cfg_pcs+0x94>
        if(pmac_group == pmac_groups[i]) {
   1efb0:	008001f4 	movhi	r2,7
   1efb4:	10949d04 	addi	r2,r2,21108
   1efb8:	10c00017 	ldw	r3,0(r2)
   1efbc:	38c03626 	beq	r7,r3,1f098 <alt_tse_phy_cfg_pcs+0x14c>
   1efc0:	10800104 	addi	r2,r2,4
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   1efc4:	000b883a 	mov	r5,zero
   1efc8:	00000206 	br	1efd4 <alt_tse_phy_cfg_pcs+0x88>
        if(pmac_group == pmac_groups[i]) {
   1efcc:	10ffff17 	ldw	r3,-4(r2)
   1efd0:	38c00426 	beq	r7,r3,1efe4 <alt_tse_phy_cfg_pcs+0x98>
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   1efd4:	29400044 	addi	r5,r5,1
   1efd8:	10800104 	addi	r2,r2,4
   1efdc:	293ffb16 	blt	r5,r4,1efcc <alt_tse_phy_cfg_pcs+0x80>
   1efe0:	017fffc4 	movi	r5,-1
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);

    if(psys->tse_pcs_ena) {
   1efe4:	808003c3 	ldbu	r2,15(r16)
   1efe8:	1000091e 	bne	r2,zero,1f010 <alt_tse_phy_cfg_pcs+0xc4>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data & ~0x03);
        }
    }
    
    return SUCCESS;
}
   1efec:	0005883a 	mov	r2,zero
   1eff0:	dfc00517 	ldw	ra,20(sp)
   1eff4:	dd000417 	ldw	r20,16(sp)
   1eff8:	dcc00317 	ldw	r19,12(sp)
   1effc:	dc800217 	ldw	r18,8(sp)
   1f000:	dc400117 	ldw	r17,4(sp)
   1f004:	dc000017 	ldw	r16,0(sp)
   1f008:	dec00604 	addi	sp,sp,24
   1f00c:	f800283a 	ret
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);

    if(psys->tse_pcs_ena) {
        tse_dprintf(5, "INFO    : PCS[%d.%d] - Configuring PCS operating mode\n", mac_group_index, mac_info_index);
   1f010:	2cc03fcc 	andi	r19,r5,255
   1f014:	34803fcc 	andi	r18,r6,255
   1f018:	9cc0201c 	xori	r19,r19,128
   1f01c:	9480201c 	xori	r18,r18,128
   1f020:	9cffe004 	addi	r19,r19,-128
   1f024:	94bfe004 	addi	r18,r18,-128
   1f028:	010000b4 	movhi	r4,2
   1f02c:	211a4d04 	addi	r4,r4,26932
   1f030:	980b883a 	mov	r5,r19
   1f034:	900d883a 	mov	r6,r18
   1f038:	00104380 	call	10438 <printf>
        
        alt_32 data = IORD(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE); 
   1f03c:	8c409404 	addi	r17,r17,592
   1f040:	8d000037 	ldwio	r20,0(r17)
        
        if(psys->tse_pcs_sgmii) {
   1f044:	80800403 	ldbu	r2,16(r16)
   1f048:	1000091e 	bne	r2,zero,1f070 <alt_tse_phy_cfg_pcs+0x124>
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode enabled\n", mac_group_index, mac_info_index);
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data | 0x03);
            }
        else {
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode disabled\n", mac_group_index, mac_info_index);
   1f04c:	010000b4 	movhi	r4,2
   1f050:	211a6704 	addi	r4,r4,27036
   1f054:	980b883a 	mov	r5,r19
   1f058:	900d883a 	mov	r6,r18
   1f05c:	00104380 	call	10438 <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data & ~0x03);
   1f060:	00bfff04 	movi	r2,-4
   1f064:	a0a8703a 	and	r20,r20,r2
   1f068:	8d000035 	stwio	r20,0(r17)
   1f06c:	003fdf06 	br	1efec <alt_tse_phy_cfg_pcs+0xa0>
        tse_dprintf(5, "INFO    : PCS[%d.%d] - Configuring PCS operating mode\n", mac_group_index, mac_info_index);
        
        alt_32 data = IORD(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE); 
        
        if(psys->tse_pcs_sgmii) {
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode enabled\n", mac_group_index, mac_info_index);
   1f070:	010000b4 	movhi	r4,2
   1f074:	211a5b04 	addi	r4,r4,26988
   1f078:	980b883a 	mov	r5,r19
   1f07c:	900d883a 	mov	r6,r18
   1f080:	00104380 	call	10438 <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data | 0x03);
   1f084:	a50000d4 	ori	r20,r20,3
   1f088:	8d000035 	stwio	r20,0(r17)
   1f08c:	003fd706 	br	1efec <alt_tse_phy_cfg_pcs+0xa0>
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   1f090:	000d883a 	mov	r6,zero
   1f094:	003fc406 	br	1efa8 <alt_tse_phy_cfg_pcs+0x5c>
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
        if(pmac_group == pmac_groups[i]) {
   1f098:	000b883a 	mov	r5,zero
   1f09c:	003fd106 	br	1efe4 <alt_tse_phy_cfg_pcs+0x98>

0001f0a0 <alt_tse_phy_restart_an>:
 *                              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_restart_an(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
   1f0a0:	22000617 	ldw	r8,24(r4)
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *                              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_restart_an(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
   1f0a4:	defff804 	addi	sp,sp,-32
   1f0a8:	dc400215 	stw	r17,8(sp)
   1f0ac:	2023883a 	mov	r17,r4
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   1f0b0:	41000317 	ldw	r4,12(r8)
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *                              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_restart_an(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
   1f0b4:	dc800315 	stw	r18,12(sp)
   1f0b8:	dfc00715 	stw	ra,28(sp)
   1f0bc:	dd400615 	stw	r21,24(sp)
   1f0c0:	dd000515 	stw	r20,20(sp)
   1f0c4:	dcc00415 	stw	r19,16(sp)
   1f0c8:	dc000115 	stw	r16,4(sp)
   1f0cc:	2825883a 	mov	r18,r5
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1f0d0:	21400003 	ldbu	r5,0(r4)
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   1f0d4:	22400117 	ldw	r9,4(r4)
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1f0d8:	28000926 	beq	r5,zero,1f100 <alt_tse_phy_restart_an+0x60>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   1f0dc:	42406f26 	beq	r8,r9,1f29c <alt_tse_phy_restart_an+0x1fc>
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *                              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_restart_an(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
   1f0e0:	20800204 	addi	r2,r4,8
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1f0e4:	000d883a 	mov	r6,zero
   1f0e8:	00000206 	br	1f0f4 <alt_tse_phy_restart_an+0x54>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   1f0ec:	10ffff17 	ldw	r3,-4(r2)
   1f0f0:	40c05426 	beq	r8,r3,1f244 <alt_tse_phy_restart_an+0x1a4>
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1f0f4:	31800044 	addi	r6,r6,1
   1f0f8:	10800104 	addi	r2,r2,4
   1f0fc:	317ffb16 	blt	r6,r5,1f0ec <alt_tse_phy_restart_an+0x4c>
   1f100:	04ffffc4 	movi	r19,-1
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   1f104:	d168df03 	ldbu	r5,-23684(gp)
   1f108:	28000c26 	beq	r5,zero,1f13c <alt_tse_phy_restart_an+0x9c>
        if(pmac_group == pmac_groups[i]) {
   1f10c:	00c001f4 	movhi	r3,7
   1f110:	18d49d04 	addi	r3,r3,21108
   1f114:	18800017 	ldw	r2,0(r3)
   1f118:	20806226 	beq	r4,r2,1f2a4 <alt_tse_phy_restart_an+0x204>
   1f11c:	18c00104 	addi	r3,r3,4
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   1f120:	0005883a 	mov	r2,zero
   1f124:	00000206 	br	1f130 <alt_tse_phy_restart_an+0x90>
        if(pmac_group == pmac_groups[i]) {
   1f128:	19ffff17 	ldw	r7,-4(r3)
   1f12c:	21c04926 	beq	r4,r7,1f254 <alt_tse_phy_restart_an+0x1b4>
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   1f130:	10800044 	addi	r2,r2,1
   1f134:	18c00104 	addi	r3,r3,4
   1f138:	117ffb16 	blt	r2,r5,1f128 <alt_tse_phy_restart_an+0x88>
   1f13c:	053fffc4 	movi	r20,-1
 * @API Type:    Internal
 * @param pmac   Pointer to the alt_tse_phy_info structure
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_rd_mdio_addr(alt_tse_phy_info *pphy) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f140:	48800217 	ldw	r2,8(r9)
    return IORD(&pmac_group_base->MDIO_ADDR1, 0);
   1f144:	10800017 	ldw	r2,0(r2)
   1f148:	15401037 	ldwio	r21,64(r2)
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f14c:	40800317 	ldw	r2,12(r8)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
   1f150:	88c00003 	ldbu	r3,0(r17)
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f154:	10800117 	ldw	r2,4(r2)
   1f158:	10800217 	ldw	r2,8(r2)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
   1f15c:	10800017 	ldw	r2,0(r2)
   1f160:	10c01035 	stwio	r3,64(r2)
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
    
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
   1f164:	04000044 	movi	r16,1
   1f168:	8809883a 	mov	r4,r17
   1f16c:	800b883a 	mov	r5,r16
   1f170:	018000c4 	movi	r6,3
   1f174:	800f883a 	mov	r7,r16
   1f178:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
   1f17c:	10004b26 	beq	r2,zero,1f2ac <alt_tse_phy_restart_an+0x20c>
		
		return TSE_PHY_AN_NOT_CAPABLE;
    }
    
    /* enable Auto-Negotiation */    
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_AN_ENA, 1, 1);
   1f180:	800f883a 	mov	r7,r16
   1f184:	8809883a 	mov	r4,r17
   1f188:	000b883a 	mov	r5,zero
   1f18c:	01800304 	movi	r6,12
   1f190:	dc000015 	stw	r16,0(sp)
   1f194:	001e7a40 	call	1e7a4 <alt_tse_phy_wr_mdio_reg>
    
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
   1f198:	800f883a 	mov	r7,r16
   1f19c:	8809883a 	mov	r4,r17
   1f1a0:	000b883a 	mov	r5,zero
   1f1a4:	01800244 	movi	r6,9
   1f1a8:	dc000015 	stw	r16,0(sp)
   1f1ac:	001e7a40 	call	1e7a4 <alt_tse_phy_wr_mdio_reg>
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
   1f1b0:	010000b4 	movhi	r4,2
   1f1b4:	211a8304 	addi	r4,r4,27148
   1f1b8:	a00b883a 	mov	r5,r20
   1f1bc:	980d883a 	mov	r6,r19
   1f1c0:	00104380 	call	10438 <printf>
    
    alt_32 timeout = 0;
   1f1c4:	0021883a 	mov	r16,zero
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
   1f1c8:	01400044 	movi	r5,1
   1f1cc:	8809883a 	mov	r4,r17
   1f1d0:	01800144 	movi	r6,5
   1f1d4:	280f883a 	mov	r7,r5
        if(timeout++ > timeout_threshold) {
   1f1d8:	8161883a 	add	r16,r16,r5
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
    
    alt_32 timeout = 0;
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
   1f1dc:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
        if(timeout++ > timeout_threshold) {
   1f1e0:	80ffffc4 	addi	r3,r16,-1
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
    
    alt_32 timeout = 0;
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
   1f1e4:	10001f1e 	bne	r2,zero,1f264 <alt_tse_phy_restart_an+0x1c4>
        if(timeout++ > timeout_threshold) {
   1f1e8:	90fff72e 	bgeu	r18,r3,1f1c8 <alt_tse_phy_restart_an+0x128>
           tse_dprintf(4, "WARNING : PHY[%d.%d] - Auto-Negotiation FAILED\n", mac_group_index, mac_info_index);
   1f1ec:	010000b4 	movhi	r4,2
   1f1f0:	211a9504 	addi	r4,r4,27220
   1f1f4:	a00b883a 	mov	r5,r20
   1f1f8:	980d883a 	mov	r6,r19
   1f1fc:	00104380 	call	10438 <printf>
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f200:	88800617 	ldw	r2,24(r17)
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
        if(timeout++ > timeout_threshold) {
           tse_dprintf(4, "WARNING : PHY[%d.%d] - Auto-Negotiation FAILED\n", mac_group_index, mac_info_index);
		   
		   /* Restore previous MDIO address */
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   1f204:	ad403fcc 	andi	r21,r21,255
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f208:	10800317 	ldw	r2,12(r2)
   1f20c:	10800117 	ldw	r2,4(r2)
   1f210:	10800217 	ldw	r2,8(r2)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
   1f214:	10800017 	ldw	r2,0(r2)
   1f218:	15401035 	stwio	r21,64(r2)
           tse_dprintf(4, "WARNING : PHY[%d.%d] - Auto-Negotiation FAILED\n", mac_group_index, mac_info_index);
		   
		   /* Restore previous MDIO address */
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
           
		   return TSE_PHY_AN_NOT_COMPLETE;
   1f21c:	00bfffc4 	movi	r2,-1
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
    
    return TSE_PHY_AN_COMPLETE;
}
   1f220:	dfc00717 	ldw	ra,28(sp)
   1f224:	dd400617 	ldw	r21,24(sp)
   1f228:	dd000517 	ldw	r20,20(sp)
   1f22c:	dcc00417 	ldw	r19,16(sp)
   1f230:	dc800317 	ldw	r18,12(sp)
   1f234:	dc400217 	ldw	r17,8(sp)
   1f238:	dc000117 	ldw	r16,4(sp)
   1f23c:	dec00804 	addi	sp,sp,32
   1f240:	f800283a 	ret
   1f244:	34c03fcc 	andi	r19,r6,255
   1f248:	9cc0201c 	xori	r19,r19,128
   1f24c:	9cffe004 	addi	r19,r19,-128
   1f250:	003fac06 	br	1f104 <alt_tse_phy_restart_an+0x64>
   1f254:	15003fcc 	andi	r20,r2,255
   1f258:	a500201c 	xori	r20,r20,128
   1f25c:	a53fe004 	addi	r20,r20,-128
   1f260:	003fb706 	br	1f140 <alt_tse_phy_restart_an+0xa0>
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
           
		   return TSE_PHY_AN_NOT_COMPLETE;
        }
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Auto-Negotiation PASSED\n", mac_group_index, mac_info_index);
   1f264:	010000b4 	movhi	r4,2
   1f268:	211aa104 	addi	r4,r4,27268
   1f26c:	a00b883a 	mov	r5,r20
   1f270:	980d883a 	mov	r6,r19
   1f274:	00104380 	call	10438 <printf>
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f278:	88800617 	ldw	r2,24(r17)
        }
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Auto-Negotiation PASSED\n", mac_group_index, mac_info_index);
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   1f27c:	ad403fcc 	andi	r21,r21,255
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f280:	10800317 	ldw	r2,12(r2)
   1f284:	10800117 	ldw	r2,4(r2)
   1f288:	10800217 	ldw	r2,8(r2)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
   1f28c:	10800017 	ldw	r2,0(r2)
   1f290:	15401035 	stwio	r21,64(r2)
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Auto-Negotiation PASSED\n", mac_group_index, mac_info_index);
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
    
    return TSE_PHY_AN_COMPLETE;
   1f294:	0005883a 	mov	r2,zero
   1f298:	003fe106 	br	1f220 <alt_tse_phy_restart_an+0x180>
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   1f29c:	0027883a 	mov	r19,zero
   1f2a0:	003f9806 	br	1f104 <alt_tse_phy_restart_an+0x64>
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
        if(pmac_group == pmac_groups[i]) {
   1f2a4:	0029883a 	mov	r20,zero
   1f2a8:	003fa506 	br	1f140 <alt_tse_phy_restart_an+0xa0>
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
    
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
   1f2ac:	010000b4 	movhi	r4,2
   1f2b0:	211a7304 	addi	r4,r4,27084
   1f2b4:	a00b883a 	mov	r5,r20
   1f2b8:	980d883a 	mov	r6,r19
   1f2bc:	00104380 	call	10438 <printf>
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f2c0:	88800617 	ldw	r2,24(r17)
    
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
        
		/* Restore previous MDIO address */
		alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   1f2c4:	ad403fcc 	andi	r21,r21,255
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f2c8:	10800317 	ldw	r2,12(r2)
   1f2cc:	10800117 	ldw	r2,4(r2)
   1f2d0:	10800217 	ldw	r2,8(r2)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
   1f2d4:	10800017 	ldw	r2,0(r2)
   1f2d8:	15401035 	stwio	r21,64(r2)
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
        
		/* Restore previous MDIO address */
		alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
		
		return TSE_PHY_AN_NOT_CAPABLE;
   1f2dc:	00bfff84 	movi	r2,-2
   1f2e0:	003fcf06 	br	1f220 <alt_tse_phy_restart_an+0x180>

0001f2e4 <alt_tse_phy_check_link>:
 * @param pphy                  Pointer to the alt_tse_phy_info structure
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 */
alt_32 alt_tse_phy_check_link(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
   1f2e4:	defffa04 	addi	sp,sp,-24
   1f2e8:	dc000015 	stw	r16,0(sp)
   1f2ec:	2021883a 	mov	r16,r4

    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
   1f2f0:	21000617 	ldw	r4,24(r4)
 * @param pphy                  Pointer to the alt_tse_phy_info structure
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 */
alt_32 alt_tse_phy_check_link(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
   1f2f4:	dc400115 	stw	r17,4(sp)
   1f2f8:	dfc00515 	stw	ra,20(sp)

    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   1f2fc:	22000317 	ldw	r8,12(r4)
 * @param pphy                  Pointer to the alt_tse_phy_info structure
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 */
alt_32 alt_tse_phy_check_link(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
   1f300:	dd000415 	stw	r20,16(sp)
   1f304:	dcc00315 	stw	r19,12(sp)
   1f308:	dc800215 	stw	r18,8(sp)
   1f30c:	2823883a 	mov	r17,r5
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1f310:	41400003 	ldbu	r5,0(r8)
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   1f314:	42400117 	ldw	r9,4(r8)
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1f318:	28000926 	beq	r5,zero,1f340 <alt_tse_phy_check_link+0x5c>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   1f31c:	22406a26 	beq	r4,r9,1f4c8 <alt_tse_phy_check_link+0x1e4>
 * @param pphy                  Pointer to the alt_tse_phy_info structure
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 */
alt_32 alt_tse_phy_check_link(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
   1f320:	40800204 	addi	r2,r8,8
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1f324:	000d883a 	mov	r6,zero
   1f328:	00000206 	br	1f334 <alt_tse_phy_check_link+0x50>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   1f32c:	10ffff17 	ldw	r3,-4(r2)
   1f330:	20c05f26 	beq	r4,r3,1f4b0 <alt_tse_phy_check_link+0x1cc>
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1f334:	31800044 	addi	r6,r6,1
   1f338:	10800104 	addi	r2,r2,4
   1f33c:	317ffb16 	blt	r6,r5,1f32c <alt_tse_phy_check_link+0x48>
   1f340:	04bfffc4 	movi	r18,-1
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   1f344:	d168df03 	ldbu	r5,-23684(gp)
   1f348:	28000c26 	beq	r5,zero,1f37c <alt_tse_phy_check_link+0x98>
        if(pmac_group == pmac_groups[i]) {
   1f34c:	00c001f4 	movhi	r3,7
   1f350:	18d49d04 	addi	r3,r3,21108
   1f354:	18800017 	ldw	r2,0(r3)
   1f358:	40805926 	beq	r8,r2,1f4c0 <alt_tse_phy_check_link+0x1dc>
   1f35c:	18c00104 	addi	r3,r3,4
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   1f360:	0005883a 	mov	r2,zero
   1f364:	00000206 	br	1f370 <alt_tse_phy_check_link+0x8c>
        if(pmac_group == pmac_groups[i]) {
   1f368:	19ffff17 	ldw	r7,-4(r3)
   1f36c:	41c04c26 	beq	r8,r7,1f4a0 <alt_tse_phy_check_link+0x1bc>
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   1f370:	10800044 	addi	r2,r2,1
   1f374:	18c00104 	addi	r3,r3,4
   1f378:	117ffb16 	blt	r2,r5,1f368 <alt_tse_phy_check_link+0x84>
   1f37c:	04ffffc4 	movi	r19,-1
 * @API Type:    Internal
 * @param pmac   Pointer to the alt_tse_phy_info structure
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_rd_mdio_addr(alt_tse_phy_info *pphy) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f380:	48800217 	ldw	r2,8(r9)
    return IORD(&pmac_group_base->MDIO_ADDR1, 0);
   1f384:	10800017 	ldw	r2,0(r2)
   1f388:	15001037 	ldwio	r20,64(r2)
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f38c:	20800317 	ldw	r2,12(r4)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
   1f390:	80c00003 	ldbu	r3,0(r16)
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f394:	10800117 	ldw	r2,4(r2)
   1f398:	10800217 	ldw	r2,8(r2)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
   1f39c:	10800017 	ldw	r2,0(r2)
   1f3a0:	10c01035 	stwio	r3,64(r2)
    /* Issue a PHY reset here and wait for the link
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
   1f3a4:	980b883a 	mov	r5,r19
   1f3a8:	900d883a 	mov	r6,r18
   1f3ac:	010000b4 	movhi	r4,2
   1f3b0:	211aad04 	addi	r4,r4,27316
   1f3b4:	00104380 	call	10438 <printf>
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
   1f3b8:	8009883a 	mov	r4,r16
   1f3bc:	000b883a 	mov	r5,zero
   1f3c0:	01800384 	movi	r6,14
   1f3c4:	01c00044 	movi	r7,1
   1f3c8:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
   1f3cc:	10001b1e 	bne	r2,zero,1f43c <alt_tse_phy_check_link+0x158>
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
   1f3d0:	01400044 	movi	r5,1
   1f3d4:	8009883a 	mov	r4,r16
   1f3d8:	01800144 	movi	r6,5
   1f3dc:	280f883a 	mov	r7,r5
   1f3e0:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
   1f3e4:	10001526 	beq	r2,zero,1f43c <alt_tse_phy_check_link+0x158>
			alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
	
            return TSE_PHY_AN_NOT_COMPLETE;
        }            
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Link established\n", mac_group_index, mac_info_index);
   1f3e8:	010000b4 	movhi	r4,2
   1f3ec:	211ad904 	addi	r4,r4,27492
   1f3f0:	980b883a 	mov	r5,r19
   1f3f4:	900d883a 	mov	r6,r18
   1f3f8:	00104380 	call	10438 <printf>
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f3fc:	80800617 	ldw	r2,24(r16)
        }            
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Link established\n", mac_group_index, mac_info_index);
            
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   1f400:	a5003fcc 	andi	r20,r20,255
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f404:	10800317 	ldw	r2,12(r2)
   1f408:	10800117 	ldw	r2,4(r2)
   1f40c:	10800217 	ldw	r2,8(r2)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
   1f410:	10800017 	ldw	r2,0(r2)
   1f414:	15001035 	stwio	r20,64(r2)
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Link established\n", mac_group_index, mac_info_index);
            
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
    
    return TSE_PHY_AN_COMPLETE; 
   1f418:	0005883a 	mov	r2,zero
}
   1f41c:	dfc00517 	ldw	ra,20(sp)
   1f420:	dd000417 	ldw	r20,16(sp)
   1f424:	dcc00317 	ldw	r19,12(sp)
   1f428:	dc800217 	ldw	r18,8(sp)
   1f42c:	dc400117 	ldw	r17,4(sp)
   1f430:	dc000017 	ldw	r16,0(sp)
   1f434:	dec00604 	addi	sp,sp,24
   1f438:	f800283a 	ret
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
        
        tse_dprintf(5, "INFO    : PHY[%d.%d] - Link not yet established, restart auto-negotiation...\n", mac_group_index, mac_info_index);
   1f43c:	900d883a 	mov	r6,r18
   1f440:	010000b4 	movhi	r4,2
   1f444:	211ab804 	addi	r4,r4,27360
   1f448:	980b883a 	mov	r5,r19
   1f44c:	00104380 	call	10438 <printf>
        /* restart Auto-Negotiation */
        /* if Auto-Negotiation still cannot complete, then go to next PHY */
        if(alt_tse_phy_restart_an(pphy, timeout_threshold) == TSE_PHY_AN_NOT_COMPLETE) {
   1f450:	880b883a 	mov	r5,r17
   1f454:	8009883a 	mov	r4,r16
   1f458:	001f0a00 	call	1f0a0 <alt_tse_phy_restart_an>
   1f45c:	1023883a 	mov	r17,r2
   1f460:	00bfffc4 	movi	r2,-1
   1f464:	88bfe01e 	bne	r17,r2,1f3e8 <alt_tse_phy_check_link+0x104>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - Link could not established\n", mac_group_index, mac_info_index);
   1f468:	010000b4 	movhi	r4,2
   1f46c:	211acc04 	addi	r4,r4,27440
   1f470:	980b883a 	mov	r5,r19
   1f474:	900d883a 	mov	r6,r18
   1f478:	00104380 	call	10438 <printf>
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f47c:	80800617 	ldw	r2,24(r16)
        /* if Auto-Negotiation still cannot complete, then go to next PHY */
        if(alt_tse_phy_restart_an(pphy, timeout_threshold) == TSE_PHY_AN_NOT_COMPLETE) {
            tse_dprintf(3, "WARNING : PHY[%d.%d] - Link could not established\n", mac_group_index, mac_info_index);
			
			/* Restore previous MDIO address */
			alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   1f480:	a5003fcc 	andi	r20,r20,255
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f484:	10800317 	ldw	r2,12(r2)
   1f488:	10800117 	ldw	r2,4(r2)
   1f48c:	10800217 	ldw	r2,8(r2)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
   1f490:	10800017 	ldw	r2,0(r2)
   1f494:	15001035 	stwio	r20,64(r2)
            tse_dprintf(3, "WARNING : PHY[%d.%d] - Link could not established\n", mac_group_index, mac_info_index);
			
			/* Restore previous MDIO address */
			alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
	
            return TSE_PHY_AN_NOT_COMPLETE;
   1f498:	8805883a 	mov	r2,r17
   1f49c:	003fdf06 	br	1f41c <alt_tse_phy_check_link+0x138>
   1f4a0:	14c03fcc 	andi	r19,r2,255
   1f4a4:	9cc0201c 	xori	r19,r19,128
   1f4a8:	9cffe004 	addi	r19,r19,-128
   1f4ac:	003fb406 	br	1f380 <alt_tse_phy_check_link+0x9c>
   1f4b0:	34803fcc 	andi	r18,r6,255
   1f4b4:	9480201c 	xori	r18,r18,128
   1f4b8:	94bfe004 	addi	r18,r18,-128
   1f4bc:	003fa106 	br	1f344 <alt_tse_phy_check_link+0x60>
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
        if(pmac_group == pmac_groups[i]) {
   1f4c0:	0027883a 	mov	r19,zero
   1f4c4:	003fae06 	br	1f380 <alt_tse_phy_check_link+0x9c>
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   1f4c8:	0025883a 	mov	r18,zero
   1f4cc:	003f9d06 	br	1f344 <alt_tse_phy_check_link+0x60>

0001f4d0 <alt_tse_phy_get_cap>:
 */
alt_32 alt_tse_phy_get_cap(alt_tse_phy_info *pphy) {
	alt_32 return_value = TSE_PHY_AN_COMPLETE;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
   1f4d0:	21c00617 	ldw	r7,24(r4)
 * @param pmac  Pointer to the alt_tse_phy_info structure
 * @return      return TSE_PHY_AN_COMPLETE if success
 *              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_get_cap(alt_tse_phy_info *pphy) {
   1f4d4:	defffb04 	addi	sp,sp,-20
   1f4d8:	dc000015 	stw	r16,0(sp)
	alt_32 return_value = TSE_PHY_AN_COMPLETE;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   1f4dc:	39400317 	ldw	r5,12(r7)
 * @param pmac  Pointer to the alt_tse_phy_info structure
 * @return      return TSE_PHY_AN_COMPLETE if success
 *              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_get_cap(alt_tse_phy_info *pphy) {
   1f4e0:	dfc00415 	stw	ra,16(sp)
   1f4e4:	dcc00315 	stw	r19,12(sp)
   1f4e8:	dc800215 	stw	r18,8(sp)
   1f4ec:	dc400115 	stw	r17,4(sp)
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1f4f0:	29800003 	ldbu	r6,0(r5)
 * @param pmac  Pointer to the alt_tse_phy_info structure
 * @return      return TSE_PHY_AN_COMPLETE if success
 *              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_get_cap(alt_tse_phy_info *pphy) {
   1f4f4:	2021883a 	mov	r16,r4
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   1f4f8:	2a400117 	ldw	r9,4(r5)
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1f4fc:	30000926 	beq	r6,zero,1f524 <alt_tse_phy_get_cap+0x54>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   1f500:	3a40b326 	beq	r7,r9,1f7d0 <alt_tse_phy_get_cap+0x300>
 * @param pmac  Pointer to the alt_tse_phy_info structure
 * @return      return TSE_PHY_AN_COMPLETE if success
 *              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_get_cap(alt_tse_phy_info *pphy) {
   1f504:	28c00204 	addi	r3,r5,8
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1f508:	0005883a 	mov	r2,zero
   1f50c:	00000206 	br	1f518 <alt_tse_phy_get_cap+0x48>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   1f510:	193fff17 	ldw	r4,-4(r3)
   1f514:	3900a826 	beq	r7,r4,1f7b8 <alt_tse_phy_get_cap+0x2e8>
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1f518:	10800044 	addi	r2,r2,1
   1f51c:	18c00104 	addi	r3,r3,4
   1f520:	11bffb16 	blt	r2,r6,1f510 <alt_tse_phy_get_cap+0x40>
   1f524:	047fffc4 	movi	r17,-1
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   1f528:	d228df03 	ldbu	r8,-23684(gp)
   1f52c:	40000c26 	beq	r8,zero,1f560 <alt_tse_phy_get_cap+0x90>
        if(pmac_group == pmac_groups[i]) {
   1f530:	00c001f4 	movhi	r3,7
   1f534:	18d49d04 	addi	r3,r3,21108
   1f538:	18800017 	ldw	r2,0(r3)
   1f53c:	2880a226 	beq	r5,r2,1f7c8 <alt_tse_phy_get_cap+0x2f8>
   1f540:	18c00104 	addi	r3,r3,4
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   1f544:	0005883a 	mov	r2,zero
   1f548:	00000206 	br	1f554 <alt_tse_phy_get_cap+0x84>
        if(pmac_group == pmac_groups[i]) {
   1f54c:	193fff17 	ldw	r4,-4(r3)
   1f550:	29009b26 	beq	r5,r4,1f7c0 <alt_tse_phy_get_cap+0x2f0>
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   1f554:	10800044 	addi	r2,r2,1
   1f558:	18c00104 	addi	r3,r3,4
   1f55c:	123ffb16 	blt	r2,r8,1f54c <alt_tse_phy_get_cap+0x7c>
   1f560:	04ffffc4 	movi	r19,-1
 * @API Type:    Internal
 * @param pmac   Pointer to the alt_tse_phy_info structure
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_rd_mdio_addr(alt_tse_phy_info *pphy) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f564:	48800217 	ldw	r2,8(r9)
    return IORD(&pmac_group_base->MDIO_ADDR1, 0);
   1f568:	10800017 	ldw	r2,0(r2)
   1f56c:	14801037 	ldwio	r18,64(r2)
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f570:	38800317 	ldw	r2,12(r7)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
   1f574:	81000003 	ldbu	r4,0(r16)
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f578:	10800117 	ldw	r2,4(r2)
   1f57c:	10c00217 	ldw	r3,8(r2)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
   1f580:	18c00017 	ldw	r3,0(r3)
   1f584:	19001035 	stwio	r4,64(r3)
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
            
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
   1f588:	01400044 	movi	r5,1
   1f58c:	8009883a 	mov	r4,r16
   1f590:	018000c4 	movi	r6,3
   1f594:	280f883a 	mov	r7,r5
   1f598:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
   1f59c:	10008e26 	beq	r2,zero,1f7d8 <alt_tse_phy_get_cap+0x308>
        
        return TSE_PHY_AN_NOT_CAPABLE;
    }
    
    /* check whether link has been established */
    alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
   1f5a0:	8009883a 	mov	r4,r16
   1f5a4:	01400134 	movhi	r5,4
   1f5a8:	29742404 	addi	r5,r5,-12144
   1f5ac:	001f0a00 	call	1f0a0 <alt_tse_phy_restart_an>
    
    if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0) {
   1f5b0:	01400044 	movi	r5,1
   1f5b4:	8009883a 	mov	r4,r16
   1f5b8:	280f883a 	mov	r7,r5
   1f5bc:	01800144 	movi	r6,5
   1f5c0:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
        return_value = TSE_PHY_AN_NOT_COMPLETE;
    }
    
    /* get PHY capabilities */
    pphy->link_capability.cap_1000_base_x_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_FULL, 1);
   1f5c4:	014003c4 	movi	r5,15
   1f5c8:	8009883a 	mov	r4,r16
   1f5cc:	280d883a 	mov	r6,r5
   1f5d0:	01c00044 	movi	r7,1
 * @return      return TSE_PHY_AN_COMPLETE if success
 *              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_get_cap(alt_tse_phy_info *pphy) {
	alt_32 return_value = TSE_PHY_AN_COMPLETE;
   1f5d4:	1023003a 	cmpeq	r17,r2,zero
    if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0) {
        return_value = TSE_PHY_AN_NOT_COMPLETE;
    }
    
    /* get PHY capabilities */
    pphy->link_capability.cap_1000_base_x_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_FULL, 1);
   1f5d8:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
    pphy->link_capability.cap_1000_base_x_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_HALF, 1);
   1f5dc:	8009883a 	mov	r4,r16
    if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0) {
        return_value = TSE_PHY_AN_NOT_COMPLETE;
    }
    
    /* get PHY capabilities */
    pphy->link_capability.cap_1000_base_x_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_FULL, 1);
   1f5e0:	80800045 	stb	r2,1(r16)
    pphy->link_capability.cap_1000_base_x_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_HALF, 1);
   1f5e4:	014003c4 	movi	r5,15
   1f5e8:	01800384 	movi	r6,14
   1f5ec:	01c00044 	movi	r7,1
   1f5f0:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
    pphy->link_capability.cap_1000_base_t_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1);
   1f5f4:	8009883a 	mov	r4,r16
        return_value = TSE_PHY_AN_NOT_COMPLETE;
    }
    
    /* get PHY capabilities */
    pphy->link_capability.cap_1000_base_x_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_FULL, 1);
    pphy->link_capability.cap_1000_base_x_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_HALF, 1);
   1f5f8:	80800085 	stb	r2,2(r16)
    pphy->link_capability.cap_1000_base_t_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1);
   1f5fc:	014003c4 	movi	r5,15
   1f600:	01800344 	movi	r6,13
   1f604:	01c00044 	movi	r7,1
   1f608:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
    pphy->link_capability.cap_1000_base_t_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
   1f60c:	8009883a 	mov	r4,r16
    }
    
    /* get PHY capabilities */
    pphy->link_capability.cap_1000_base_x_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_FULL, 1);
    pphy->link_capability.cap_1000_base_x_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_HALF, 1);
    pphy->link_capability.cap_1000_base_t_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1);
   1f610:	808000c5 	stb	r2,3(r16)
    pphy->link_capability.cap_1000_base_t_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
   1f614:	014003c4 	movi	r5,15
   1f618:	01800304 	movi	r6,12
   1f61c:	01c00044 	movi	r7,1
   1f620:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
    
    pphy->link_capability.cap_100_base_t4      = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
   1f624:	01400044 	movi	r5,1
   1f628:	8009883a 	mov	r4,r16
   1f62c:	280f883a 	mov	r7,r5
    
    /* get PHY capabilities */
    pphy->link_capability.cap_1000_base_x_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_FULL, 1);
    pphy->link_capability.cap_1000_base_x_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_HALF, 1);
    pphy->link_capability.cap_1000_base_t_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1);
    pphy->link_capability.cap_1000_base_t_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
   1f630:	80800105 	stb	r2,4(r16)
    
    pphy->link_capability.cap_100_base_t4      = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
   1f634:	018003c4 	movi	r6,15
   1f638:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
    pphy->link_capability.cap_100_base_x_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
   1f63c:	01400044 	movi	r5,1
   1f640:	8009883a 	mov	r4,r16
   1f644:	280f883a 	mov	r7,r5
    pphy->link_capability.cap_1000_base_x_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_FULL, 1);
    pphy->link_capability.cap_1000_base_x_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_HALF, 1);
    pphy->link_capability.cap_1000_base_t_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1);
    pphy->link_capability.cap_1000_base_t_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
    
    pphy->link_capability.cap_100_base_t4      = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
   1f648:	80800145 	stb	r2,5(r16)
    pphy->link_capability.cap_100_base_x_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
   1f64c:	01800384 	movi	r6,14
   1f650:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
    pphy->link_capability.cap_100_base_x_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
   1f654:	01400044 	movi	r5,1
   1f658:	8009883a 	mov	r4,r16
   1f65c:	280f883a 	mov	r7,r5
    pphy->link_capability.cap_1000_base_x_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_HALF, 1);
    pphy->link_capability.cap_1000_base_t_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1);
    pphy->link_capability.cap_1000_base_t_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
    
    pphy->link_capability.cap_100_base_t4      = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
    pphy->link_capability.cap_100_base_x_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
   1f660:	80800185 	stb	r2,6(r16)
    pphy->link_capability.cap_100_base_x_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
   1f664:	01800344 	movi	r6,13
   1f668:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
    pphy->link_capability.cap_100_base_t2_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_FULL, 1);
   1f66c:	01400044 	movi	r5,1
   1f670:	8009883a 	mov	r4,r16
   1f674:	280f883a 	mov	r7,r5
    pphy->link_capability.cap_1000_base_t_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1);
    pphy->link_capability.cap_1000_base_t_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
    
    pphy->link_capability.cap_100_base_t4      = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
    pphy->link_capability.cap_100_base_x_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
    pphy->link_capability.cap_100_base_x_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
   1f678:	808001c5 	stb	r2,7(r16)
    pphy->link_capability.cap_100_base_t2_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_FULL, 1);
   1f67c:	01800284 	movi	r6,10
   1f680:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
    pphy->link_capability.cap_100_base_t2_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_HALF, 1);
   1f684:	01400044 	movi	r5,1
   1f688:	8009883a 	mov	r4,r16
   1f68c:	280f883a 	mov	r7,r5
    pphy->link_capability.cap_1000_base_t_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
    
    pphy->link_capability.cap_100_base_t4      = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
    pphy->link_capability.cap_100_base_x_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
    pphy->link_capability.cap_100_base_x_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
    pphy->link_capability.cap_100_base_t2_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_FULL, 1);
   1f690:	80800205 	stb	r2,8(r16)
    pphy->link_capability.cap_100_base_t2_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_HALF, 1);
   1f694:	01800244 	movi	r6,9
   1f698:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
    pphy->link_capability.cap_10_base_t_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
   1f69c:	01400044 	movi	r5,1
   1f6a0:	8009883a 	mov	r4,r16
   1f6a4:	280f883a 	mov	r7,r5
    
    pphy->link_capability.cap_100_base_t4      = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
    pphy->link_capability.cap_100_base_x_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
    pphy->link_capability.cap_100_base_x_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
    pphy->link_capability.cap_100_base_t2_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_FULL, 1);
    pphy->link_capability.cap_100_base_t2_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_HALF, 1);
   1f6a8:	80800245 	stb	r2,9(r16)
    pphy->link_capability.cap_10_base_t_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
   1f6ac:	01800304 	movi	r6,12
   1f6b0:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
    pphy->link_capability.cap_10_base_t_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
   1f6b4:	01400044 	movi	r5,1
   1f6b8:	8009883a 	mov	r4,r16
   1f6bc:	280f883a 	mov	r7,r5
    pphy->link_capability.cap_100_base_t4      = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
    pphy->link_capability.cap_100_base_x_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
    pphy->link_capability.cap_100_base_x_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
    pphy->link_capability.cap_100_base_t2_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_FULL, 1);
    pphy->link_capability.cap_100_base_t2_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_HALF, 1);
    pphy->link_capability.cap_10_base_t_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
   1f6c0:	80800285 	stb	r2,10(r16)
    pphy->link_capability.cap_10_base_t_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
   1f6c4:	018002c4 	movi	r6,11
   1f6c8:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
    
    /* get link partner capability */
    pphy->link_capability.lp_1000_base_t_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_FULL_ADV, 1);
   1f6cc:	8009883a 	mov	r4,r16
    pphy->link_capability.cap_100_base_x_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
    pphy->link_capability.cap_100_base_x_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
    pphy->link_capability.cap_100_base_t2_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_FULL, 1);
    pphy->link_capability.cap_100_base_t2_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_HALF, 1);
    pphy->link_capability.cap_10_base_t_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
    pphy->link_capability.cap_10_base_t_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
   1f6d0:	808002c5 	stb	r2,11(r16)
    
    /* get link partner capability */
    pphy->link_capability.lp_1000_base_t_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_FULL_ADV, 1);
   1f6d4:	01400284 	movi	r5,10
   1f6d8:	018002c4 	movi	r6,11
   1f6dc:	01c00044 	movi	r7,1
   1f6e0:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
    pphy->link_capability.lp_1000_base_t_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_HALF_ADV, 1);
   1f6e4:	01400284 	movi	r5,10
   1f6e8:	8009883a 	mov	r4,r16
   1f6ec:	280d883a 	mov	r6,r5
    pphy->link_capability.cap_100_base_t2_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_HALF, 1);
    pphy->link_capability.cap_10_base_t_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
    pphy->link_capability.cap_10_base_t_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
    
    /* get link partner capability */
    pphy->link_capability.lp_1000_base_t_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_FULL_ADV, 1);
   1f6f0:	80800305 	stb	r2,12(r16)
    pphy->link_capability.lp_1000_base_t_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_HALF_ADV, 1);
   1f6f4:	01c00044 	movi	r7,1
   1f6f8:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
    
    pphy->link_capability.lp_100_base_t4       = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1);
   1f6fc:	8009883a 	mov	r4,r16
    pphy->link_capability.cap_10_base_t_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
    pphy->link_capability.cap_10_base_t_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
    
    /* get link partner capability */
    pphy->link_capability.lp_1000_base_t_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_FULL_ADV, 1);
    pphy->link_capability.lp_1000_base_t_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_HALF_ADV, 1);
   1f700:	80800345 	stb	r2,13(r16)
    
    pphy->link_capability.lp_100_base_t4       = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1);
   1f704:	01400144 	movi	r5,5
   1f708:	01800244 	movi	r6,9
   1f70c:	01c00044 	movi	r7,1
   1f710:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
    pphy->link_capability.lp_100_base_tx_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1);
   1f714:	8009883a 	mov	r4,r16
    
    /* get link partner capability */
    pphy->link_capability.lp_1000_base_t_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_FULL_ADV, 1);
    pphy->link_capability.lp_1000_base_t_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_HALF_ADV, 1);
    
    pphy->link_capability.lp_100_base_t4       = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1);
   1f718:	80800385 	stb	r2,14(r16)
    pphy->link_capability.lp_100_base_tx_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1);
   1f71c:	01400144 	movi	r5,5
   1f720:	01800204 	movi	r6,8
   1f724:	01c00044 	movi	r7,1
   1f728:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
    pphy->link_capability.lp_100_base_tx_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1);
   1f72c:	8009883a 	mov	r4,r16
    /* get link partner capability */
    pphy->link_capability.lp_1000_base_t_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_FULL_ADV, 1);
    pphy->link_capability.lp_1000_base_t_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_HALF_ADV, 1);
    
    pphy->link_capability.lp_100_base_t4       = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1);
    pphy->link_capability.lp_100_base_tx_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1);
   1f730:	808003c5 	stb	r2,15(r16)
    pphy->link_capability.lp_100_base_tx_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1);
   1f734:	01400144 	movi	r5,5
   1f738:	018001c4 	movi	r6,7
   1f73c:	01c00044 	movi	r7,1
   1f740:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
    pphy->link_capability.lp_10_base_tx_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1);
   1f744:	8009883a 	mov	r4,r16
    pphy->link_capability.lp_1000_base_t_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_FULL_ADV, 1);
    pphy->link_capability.lp_1000_base_t_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_HALF_ADV, 1);
    
    pphy->link_capability.lp_100_base_t4       = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1);
    pphy->link_capability.lp_100_base_tx_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1);
    pphy->link_capability.lp_100_base_tx_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1);
   1f748:	80800405 	stb	r2,16(r16)
    pphy->link_capability.lp_10_base_tx_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1);
   1f74c:	01400144 	movi	r5,5
   1f750:	01800184 	movi	r6,6
   1f754:	01c00044 	movi	r7,1
   1f758:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
    pphy->link_capability.lp_10_base_tx_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1);
   1f75c:	01400144 	movi	r5,5
    pphy->link_capability.lp_1000_base_t_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_HALF_ADV, 1);
    
    pphy->link_capability.lp_100_base_t4       = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1);
    pphy->link_capability.lp_100_base_tx_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1);
    pphy->link_capability.lp_100_base_tx_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1);
    pphy->link_capability.lp_10_base_tx_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1);
   1f760:	80800445 	stb	r2,17(r16)
    pphy->link_capability.lp_10_base_tx_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1);
   1f764:	8009883a 	mov	r4,r16
   1f768:	280d883a 	mov	r6,r5
   1f76c:	01c00044 	movi	r7,1
   1f770:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f774:	80c00617 	ldw	r3,24(r16)
    
    pphy->link_capability.lp_100_base_t4       = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1);
    pphy->link_capability.lp_100_base_tx_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1);
    pphy->link_capability.lp_100_base_tx_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1);
    pphy->link_capability.lp_10_base_tx_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1);
    pphy->link_capability.lp_10_base_tx_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1);
   1f778:	80800485 	stb	r2,18(r16)
 * @return      return TSE_PHY_AN_COMPLETE if success
 *              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_get_cap(alt_tse_phy_info *pphy) {
	alt_32 return_value = TSE_PHY_AN_COMPLETE;
   1f77c:	0463c83a 	sub	r17,zero,r17
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f780:	18800317 	ldw	r2,12(r3)
    tse_dprintf(6, "INFO    : 10 Base-TX Full Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_full);
    tse_dprintf(6, "INFO    : 10 Base-TX Half Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_half);
    tse_dprintf(6, "\n");
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   1f784:	94803fcc 	andi	r18,r18,255
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f788:	10800117 	ldw	r2,4(r2)
   1f78c:	10800217 	ldw	r2,8(r2)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
   1f790:	10800017 	ldw	r2,0(r2)
   1f794:	14801035 	stwio	r18,64(r2)
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
    
    return return_value;
    
}
   1f798:	8805883a 	mov	r2,r17
   1f79c:	dfc00417 	ldw	ra,16(sp)
   1f7a0:	dcc00317 	ldw	r19,12(sp)
   1f7a4:	dc800217 	ldw	r18,8(sp)
   1f7a8:	dc400117 	ldw	r17,4(sp)
   1f7ac:	dc000017 	ldw	r16,0(sp)
   1f7b0:	dec00504 	addi	sp,sp,20
   1f7b4:	f800283a 	ret
   1f7b8:	1023883a 	mov	r17,r2
   1f7bc:	003f5a06 	br	1f528 <alt_tse_phy_get_cap+0x58>
   1f7c0:	1027883a 	mov	r19,r2
   1f7c4:	003f6706 	br	1f564 <alt_tse_phy_get_cap+0x94>
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
        if(pmac_group == pmac_groups[i]) {
   1f7c8:	0027883a 	mov	r19,zero
   1f7cc:	003f6506 	br	1f564 <alt_tse_phy_get_cap+0x94>
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   1f7d0:	0023883a 	mov	r17,zero
   1f7d4:	003f5406 	br	1f528 <alt_tse_phy_get_cap+0x58>
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
            
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
   1f7d8:	99403fcc 	andi	r5,r19,255
   1f7dc:	89803fcc 	andi	r6,r17,255
   1f7e0:	2940201c 	xori	r5,r5,128
   1f7e4:	3180201c 	xori	r6,r6,128
   1f7e8:	010000b4 	movhi	r4,2
   1f7ec:	211a7304 	addi	r4,r4,27084
   1f7f0:	297fe004 	addi	r5,r5,-128
   1f7f4:	31bfe004 	addi	r6,r6,-128
   1f7f8:	00104380 	call	10438 <printf>
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f7fc:	80800617 	ldw	r2,24(r16)
            
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
        
        /* Restore previous MDIO address */
        alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   1f800:	94803fcc 	andi	r18,r18,255
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f804:	10800317 	ldw	r2,12(r2)
   1f808:	10800117 	ldw	r2,4(r2)
   1f80c:	10800217 	ldw	r2,8(r2)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
   1f810:	10800017 	ldw	r2,0(r2)
   1f814:	14801035 	stwio	r18,64(r2)
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
        
        /* Restore previous MDIO address */
        alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
        
        return TSE_PHY_AN_NOT_CAPABLE;
   1f818:	047fff84 	movi	r17,-2
   1f81c:	003fde06 	br	1f798 <alt_tse_phy_get_cap+0x2c8>

0001f820 <alt_tse_phy_set_adv_1000>:
 */
alt_32 alt_tse_phy_set_adv_1000(alt_tse_phy_info *pphy, alt_u8 enable) {
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
   1f820:	21c00617 	ldw	r7,24(r4)
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_1000(alt_tse_phy_info *pphy, alt_u8 enable) {
   1f824:	defffc04 	addi	sp,sp,-16
   1f828:	dc000115 	stw	r16,4(sp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   1f82c:	38c00317 	ldw	r3,12(r7)
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_1000(alt_tse_phy_info *pphy, alt_u8 enable) {
   1f830:	dfc00315 	stw	ra,12(sp)
   1f834:	dc400215 	stw	r17,8(sp)
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1f838:	1a000003 	ldbu	r8,0(r3)
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_1000(alt_tse_phy_info *pphy, alt_u8 enable) {
   1f83c:	2021883a 	mov	r16,r4
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   1f840:	19000117 	ldw	r4,4(r3)
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1f844:	40000926 	beq	r8,zero,1f86c <alt_tse_phy_set_adv_1000+0x4c>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   1f848:	39000826 	beq	r7,r4,1f86c <alt_tse_phy_set_adv_1000+0x4c>
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_1000(alt_tse_phy_info *pphy, alt_u8 enable) {
   1f84c:	18c00204 	addi	r3,r3,8
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1f850:	0005883a 	mov	r2,zero
   1f854:	00000206 	br	1f860 <alt_tse_phy_set_adv_1000+0x40>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   1f858:	19bfff17 	ldw	r6,-4(r3)
   1f85c:	39800326 	beq	r7,r6,1f86c <alt_tse_phy_set_adv_1000+0x4c>
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1f860:	10800044 	addi	r2,r2,1
   1f864:	18c00104 	addi	r3,r3,4
   1f868:	123ffb16 	blt	r2,r8,1f858 <alt_tse_phy_set_adv_1000+0x38>
 * @API Type:    Internal
 * @param pmac   Pointer to the alt_tse_phy_info structure
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_rd_mdio_addr(alt_tse_phy_info *pphy) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f86c:	20800217 	ldw	r2,8(r4)
    return IORD(&pmac_group_base->MDIO_ADDR1, 0);
   1f870:	10800017 	ldw	r2,0(r2)
   1f874:	14401037 	ldwio	r17,64(r2)
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f878:	38800317 	ldw	r2,12(r7)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
   1f87c:	80c00003 	ldbu	r3,0(r16)
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f880:	10800117 	ldw	r2,4(r2)
   1f884:	10800217 	ldw	r2,8(r2)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
   1f888:	10800017 	ldw	r2,0(r2)
   1f88c:	10c01035 	stwio	r3,64(r2)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
   1f890:	29403fcc 	andi	r5,r5,255
   1f894:	2800191e 	bne	r5,zero,1f8fc <alt_tse_phy_set_adv_1000+0xdc>
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, cap);
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, 0);
   1f898:	01400244 	movi	r5,9
   1f89c:	280d883a 	mov	r6,r5
   1f8a0:	8009883a 	mov	r4,r16
   1f8a4:	01c00044 	movi	r7,1
   1f8a8:	d8000015 	stw	zero,0(sp)
   1f8ac:	001e7a40 	call	1e7a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, 0);
   1f8b0:	8009883a 	mov	r4,r16
   1f8b4:	d8000015 	stw	zero,0(sp)
   1f8b8:	01400244 	movi	r5,9
   1f8bc:	01800204 	movi	r6,8
   1f8c0:	01c00044 	movi	r7,1
   1f8c4:	001e7a40 	call	1e7a4 <alt_tse_phy_wr_mdio_reg>
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f8c8:	80800617 	ldw	r2,24(r16)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, 0);
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement 1000 Base-T half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);    
   1f8cc:	8c403fcc 	andi	r17,r17,255
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f8d0:	10800317 	ldw	r2,12(r2)
   1f8d4:	10800117 	ldw	r2,4(r2)
   1f8d8:	10800217 	ldw	r2,8(r2)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
   1f8dc:	10800017 	ldw	r2,0(r2)
   1f8e0:	14401035 	stwio	r17,64(r2)
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);    

    return SUCCESS;
}
   1f8e4:	0005883a 	mov	r2,zero
   1f8e8:	dfc00317 	ldw	ra,12(sp)
   1f8ec:	dc400217 	ldw	r17,8(sp)
   1f8f0:	dc000117 	ldw	r16,4(sp)
   1f8f4:	dec00404 	addi	sp,sp,16
   1f8f8:	f800283a 	ret
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1); 
   1f8fc:	8009883a 	mov	r4,r16
   1f900:	014003c4 	movi	r5,15
   1f904:	01800344 	movi	r6,13
   1f908:	01c00044 	movi	r7,1
   1f90c:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, cap);
   1f910:	01400244 	movi	r5,9
	if(reg_status & 0x4) {
		link_status |= 0x1;
	}
	
	return link_status;
}
   1f914:	10803fcc 	andi	r2,r2,255
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1); 
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, cap);
   1f918:	280d883a 	mov	r6,r5
   1f91c:	8009883a 	mov	r4,r16
   1f920:	d8800015 	stw	r2,0(sp)
   1f924:	01c00044 	movi	r7,1
   1f928:	001e7a40 	call	1e7a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
   1f92c:	8009883a 	mov	r4,r16
   1f930:	014003c4 	movi	r5,15
   1f934:	01800304 	movi	r6,12
   1f938:	01c00044 	movi	r7,1
   1f93c:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
	if(reg_status & 0x4) {
		link_status |= 0x1;
	}
	
	return link_status;
}
   1f940:	10803fcc 	andi	r2,r2,255
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, cap);
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, cap);
   1f944:	d8800015 	stw	r2,0(sp)
   1f948:	8009883a 	mov	r4,r16
   1f94c:	01400244 	movi	r5,9
   1f950:	01800204 	movi	r6,8
   1f954:	01c00044 	movi	r7,1
   1f958:	001e7a40 	call	1e7a4 <alt_tse_phy_wr_mdio_reg>
   1f95c:	003fda06 	br	1f8c8 <alt_tse_phy_set_adv_1000+0xa8>

0001f960 <alt_tse_phy_set_adv_100>:
 */
alt_32 alt_tse_phy_set_adv_100(alt_tse_phy_info *pphy, alt_u8 enable) {
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
   1f960:	21c00617 	ldw	r7,24(r4)
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_100(alt_tse_phy_info *pphy, alt_u8 enable) {
   1f964:	defffc04 	addi	sp,sp,-16
   1f968:	dc000115 	stw	r16,4(sp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   1f96c:	38c00317 	ldw	r3,12(r7)
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_100(alt_tse_phy_info *pphy, alt_u8 enable) {
   1f970:	dfc00315 	stw	ra,12(sp)
   1f974:	dc400215 	stw	r17,8(sp)
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1f978:	1a000003 	ldbu	r8,0(r3)
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_100(alt_tse_phy_info *pphy, alt_u8 enable) {
   1f97c:	2021883a 	mov	r16,r4
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   1f980:	19000117 	ldw	r4,4(r3)
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1f984:	40000926 	beq	r8,zero,1f9ac <alt_tse_phy_set_adv_100+0x4c>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   1f988:	39000826 	beq	r7,r4,1f9ac <alt_tse_phy_set_adv_100+0x4c>
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_100(alt_tse_phy_info *pphy, alt_u8 enable) {
   1f98c:	18c00204 	addi	r3,r3,8
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1f990:	0005883a 	mov	r2,zero
   1f994:	00000206 	br	1f9a0 <alt_tse_phy_set_adv_100+0x40>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   1f998:	19bfff17 	ldw	r6,-4(r3)
   1f99c:	39800326 	beq	r7,r6,1f9ac <alt_tse_phy_set_adv_100+0x4c>
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1f9a0:	10800044 	addi	r2,r2,1
   1f9a4:	18c00104 	addi	r3,r3,4
   1f9a8:	123ffb16 	blt	r2,r8,1f998 <alt_tse_phy_set_adv_100+0x38>
 * @API Type:    Internal
 * @param pmac   Pointer to the alt_tse_phy_info structure
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_rd_mdio_addr(alt_tse_phy_info *pphy) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f9ac:	20800217 	ldw	r2,8(r4)
    return IORD(&pmac_group_base->MDIO_ADDR1, 0);
   1f9b0:	10800017 	ldw	r2,0(r2)
   1f9b4:	14401037 	ldwio	r17,64(r2)
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f9b8:	38800317 	ldw	r2,12(r7)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
   1f9bc:	80c00003 	ldbu	r3,0(r16)
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1f9c0:	10800117 	ldw	r2,4(r2)
   1f9c4:	10800217 	ldw	r2,8(r2)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
   1f9c8:	10800017 	ldw	r2,0(r2)
   1f9cc:	10c01035 	stwio	r3,64(r2)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
   1f9d0:	29403fcc 	andi	r5,r5,255
   1f9d4:	28001f1e 	bne	r5,zero,1fa54 <alt_tse_phy_set_adv_100+0xf4>
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, cap);
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, 0);
   1f9d8:	8009883a 	mov	r4,r16
   1f9dc:	01400104 	movi	r5,4
   1f9e0:	01800244 	movi	r6,9
   1f9e4:	01c00044 	movi	r7,1
   1f9e8:	d8000015 	stw	zero,0(sp)
   1f9ec:	001e7a40 	call	1e7a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, 0);
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, 0);
   1f9f0:	8009883a 	mov	r4,r16
   1f9f4:	01400104 	movi	r5,4
   1f9f8:	01800204 	movi	r6,8
   1f9fc:	01c00044 	movi	r7,1
   1fa00:	d8000015 	stw	zero,0(sp)
   1fa04:	001e7a40 	call	1e7a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, 0);
   1fa08:	8009883a 	mov	r4,r16
   1fa0c:	d8000015 	stw	zero,0(sp)
   1fa10:	01400104 	movi	r5,4
   1fa14:	018001c4 	movi	r6,7
   1fa18:	01c00044 	movi	r7,1
   1fa1c:	001e7a40 	call	1e7a4 <alt_tse_phy_wr_mdio_reg>
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1fa20:	80800617 	ldw	r2,24(r16)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, 0);
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);  
   1fa24:	8c403fcc 	andi	r17,r17,255
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1fa28:	10800317 	ldw	r2,12(r2)
   1fa2c:	10800117 	ldw	r2,4(r2)
   1fa30:	10800217 	ldw	r2,8(r2)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
   1fa34:	10800017 	ldw	r2,0(r2)
   1fa38:	14401035 	stwio	r17,64(r2)
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);  
    
    return SUCCESS;
}
   1fa3c:	0005883a 	mov	r2,zero
   1fa40:	dfc00317 	ldw	ra,12(sp)
   1fa44:	dc400217 	ldw	r17,8(sp)
   1fa48:	dc000117 	ldw	r16,4(sp)
   1fa4c:	dec00404 	addi	sp,sp,16
   1fa50:	f800283a 	ret
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
   1fa54:	01400044 	movi	r5,1
   1fa58:	8009883a 	mov	r4,r16
   1fa5c:	280f883a 	mov	r7,r5
   1fa60:	018003c4 	movi	r6,15
   1fa64:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
	if(reg_status & 0x4) {
		link_status |= 0x1;
	}
	
	return link_status;
}
   1fa68:	10803fcc 	andi	r2,r2,255
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, cap);
   1fa6c:	8009883a 	mov	r4,r16
   1fa70:	d8800015 	stw	r2,0(sp)
   1fa74:	01400104 	movi	r5,4
   1fa78:	01800244 	movi	r6,9
   1fa7c:	01c00044 	movi	r7,1
   1fa80:	001e7a40 	call	1e7a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, cap);
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
   1fa84:	01400044 	movi	r5,1
   1fa88:	8009883a 	mov	r4,r16
   1fa8c:	280f883a 	mov	r7,r5
   1fa90:	01800384 	movi	r6,14
   1fa94:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
	if(reg_status & 0x4) {
		link_status |= 0x1;
	}
	
	return link_status;
}
   1fa98:	10803fcc 	andi	r2,r2,255
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, cap);
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, cap);
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, cap);
   1fa9c:	8009883a 	mov	r4,r16
   1faa0:	d8800015 	stw	r2,0(sp)
   1faa4:	01400104 	movi	r5,4
   1faa8:	01800204 	movi	r6,8
   1faac:	01c00044 	movi	r7,1
   1fab0:	001e7a40 	call	1e7a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
   1fab4:	01400044 	movi	r5,1
   1fab8:	8009883a 	mov	r4,r16
   1fabc:	280f883a 	mov	r7,r5
   1fac0:	01800344 	movi	r6,13
   1fac4:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
	if(reg_status & 0x4) {
		link_status |= 0x1;
	}
	
	return link_status;
}
   1fac8:	10803fcc 	andi	r2,r2,255
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, cap);
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, cap);
   1facc:	d8800015 	stw	r2,0(sp)
   1fad0:	8009883a 	mov	r4,r16
   1fad4:	01400104 	movi	r5,4
   1fad8:	018001c4 	movi	r6,7
   1fadc:	01c00044 	movi	r7,1
   1fae0:	001e7a40 	call	1e7a4 <alt_tse_phy_wr_mdio_reg>
   1fae4:	003fce06 	br	1fa20 <alt_tse_phy_set_adv_100+0xc0>

0001fae8 <alt_tse_phy_set_adv_10>:
 */
alt_32 alt_tse_phy_set_adv_10(alt_tse_phy_info *pphy, alt_u8 enable) {
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
   1fae8:	21c00617 	ldw	r7,24(r4)
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_10(alt_tse_phy_info *pphy, alt_u8 enable) {
   1faec:	defffc04 	addi	sp,sp,-16
   1faf0:	dc000115 	stw	r16,4(sp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   1faf4:	38c00317 	ldw	r3,12(r7)
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_10(alt_tse_phy_info *pphy, alt_u8 enable) {
   1faf8:	dfc00315 	stw	ra,12(sp)
   1fafc:	dc400215 	stw	r17,8(sp)
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1fb00:	1a000003 	ldbu	r8,0(r3)
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_10(alt_tse_phy_info *pphy, alt_u8 enable) {
   1fb04:	2021883a 	mov	r16,r4
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   1fb08:	19000117 	ldw	r4,4(r3)
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1fb0c:	40000926 	beq	r8,zero,1fb34 <alt_tse_phy_set_adv_10+0x4c>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   1fb10:	39000826 	beq	r7,r4,1fb34 <alt_tse_phy_set_adv_10+0x4c>
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_10(alt_tse_phy_info *pphy, alt_u8 enable) {
   1fb14:	18c00204 	addi	r3,r3,8
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1fb18:	0005883a 	mov	r2,zero
   1fb1c:	00000206 	br	1fb28 <alt_tse_phy_set_adv_10+0x40>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   1fb20:	19bfff17 	ldw	r6,-4(r3)
   1fb24:	39800326 	beq	r7,r6,1fb34 <alt_tse_phy_set_adv_10+0x4c>
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   1fb28:	10800044 	addi	r2,r2,1
   1fb2c:	18c00104 	addi	r3,r3,4
   1fb30:	123ffb16 	blt	r2,r8,1fb20 <alt_tse_phy_set_adv_10+0x38>
 * @API Type:    Internal
 * @param pmac   Pointer to the alt_tse_phy_info structure
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_rd_mdio_addr(alt_tse_phy_info *pphy) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1fb34:	20800217 	ldw	r2,8(r4)
    return IORD(&pmac_group_base->MDIO_ADDR1, 0);
   1fb38:	10800017 	ldw	r2,0(r2)
   1fb3c:	14401037 	ldwio	r17,64(r2)
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1fb40:	38800317 	ldw	r2,12(r7)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
   1fb44:	80c00003 	ldbu	r3,0(r16)
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1fb48:	10800117 	ldw	r2,4(r2)
   1fb4c:	10800217 	ldw	r2,8(r2)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
   1fb50:	10800017 	ldw	r2,0(r2)
   1fb54:	10c01035 	stwio	r3,64(r2)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
   1fb58:	29403fcc 	andi	r5,r5,255
   1fb5c:	2800191e 	bne	r5,zero,1fbc4 <alt_tse_phy_set_adv_10+0xdc>
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, cap);
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, 0);
   1fb60:	8009883a 	mov	r4,r16
   1fb64:	01400104 	movi	r5,4
   1fb68:	01800184 	movi	r6,6
   1fb6c:	01c00044 	movi	r7,1
   1fb70:	d8000015 	stw	zero,0(sp)
   1fb74:	001e7a40 	call	1e7a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
    
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, 0);
   1fb78:	8009883a 	mov	r4,r16
   1fb7c:	d8000015 	stw	zero,0(sp)
   1fb80:	01400104 	movi	r5,4
   1fb84:	01800144 	movi	r6,5
   1fb88:	01c00044 	movi	r7,1
   1fb8c:	001e7a40 	call	1e7a4 <alt_tse_phy_wr_mdio_reg>
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1fb90:	80800617 	ldw	r2,24(r16)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, 0);
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   1fb94:	8c403fcc 	andi	r17,r17,255
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1fb98:	10800317 	ldw	r2,12(r2)
   1fb9c:	10800117 	ldw	r2,4(r2)
   1fba0:	10800217 	ldw	r2,8(r2)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
   1fba4:	10800017 	ldw	r2,0(r2)
   1fba8:	14401035 	stwio	r17,64(r2)
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
    
    return SUCCESS;
}
   1fbac:	0005883a 	mov	r2,zero
   1fbb0:	dfc00317 	ldw	ra,12(sp)
   1fbb4:	dc400217 	ldw	r17,8(sp)
   1fbb8:	dc000117 	ldw	r16,4(sp)
   1fbbc:	dec00404 	addi	sp,sp,16
   1fbc0:	f800283a 	ret
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
   1fbc4:	01400044 	movi	r5,1
   1fbc8:	8009883a 	mov	r4,r16
   1fbcc:	280f883a 	mov	r7,r5
   1fbd0:	01800304 	movi	r6,12
   1fbd4:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
	if(reg_status & 0x4) {
		link_status |= 0x1;
	}
	
	return link_status;
}
   1fbd8:	10803fcc 	andi	r2,r2,255
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, cap);
   1fbdc:	8009883a 	mov	r4,r16
   1fbe0:	d8800015 	stw	r2,0(sp)
   1fbe4:	01400104 	movi	r5,4
   1fbe8:	01800184 	movi	r6,6
   1fbec:	01c00044 	movi	r7,1
   1fbf0:	001e7a40 	call	1e7a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
    
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
   1fbf4:	01400044 	movi	r5,1
   1fbf8:	8009883a 	mov	r4,r16
   1fbfc:	280f883a 	mov	r7,r5
   1fc00:	018002c4 	movi	r6,11
   1fc04:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
	if(reg_status & 0x4) {
		link_status |= 0x1;
	}
	
	return link_status;
}
   1fc08:	10803fcc 	andi	r2,r2,255
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, cap);
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
    
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, cap);
   1fc0c:	d8800015 	stw	r2,0(sp)
   1fc10:	8009883a 	mov	r4,r16
   1fc14:	01400104 	movi	r5,4
   1fc18:	01800144 	movi	r6,5
   1fc1c:	01c00044 	movi	r7,1
   1fc20:	001e7a40 	call	1e7a4 <alt_tse_phy_wr_mdio_reg>
   1fc24:	003fda06 	br	1fb90 <alt_tse_phy_set_adv_10+0xa8>

0001fc28 <alt_tse_mac_get_phy>:
    
    alt_tse_phy_info *pphy = 0;
    alt_tse_mac_info *pmac_info = 0;
    alt_tse_system_info *psys = 0;
    
    np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1fc28:	20800117 	ldw	r2,4(r4)
/* @Function Description: Store information of all the PHYs connected to MAC to phy_list
 * @API Type:         Internal
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @return            Number of PHY not in profile, return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 */
alt_32 alt_tse_mac_get_phy(alt_tse_mac_group *pmac_group) {
   1fc2c:	deffee04 	addi	sp,sp,-72
   1fc30:	dc400915 	stw	r17,36(sp)
    
    alt_tse_phy_info *pphy = 0;
    alt_tse_mac_info *pmac_info = 0;
    alt_tse_system_info *psys = 0;
    
    np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1fc34:	10800217 	ldw	r2,8(r2)
/* @Function Description: Store information of all the PHYs connected to MAC to phy_list
 * @API Type:         Internal
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @return            Number of PHY not in profile, return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 */
alt_32 alt_tse_mac_get_phy(alt_tse_mac_group *pmac_group) {
   1fc38:	dc000815 	stw	r16,32(sp)
   1fc3c:	2021883a 	mov	r16,r4
    
    alt_tse_phy_info *pphy = 0;
    alt_tse_mac_info *pmac_info = 0;
    alt_tse_system_info *psys = 0;
    
    np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1fc40:	10800017 	ldw	r2,0(r2)
/* @Function Description: Store information of all the PHYs connected to MAC to phy_list
 * @API Type:         Internal
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @return            Number of PHY not in profile, return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 */
alt_32 alt_tse_mac_get_phy(alt_tse_mac_group *pmac_group) {
   1fc44:	dfc01115 	stw	ra,68(sp)
   1fc48:	df001015 	stw	fp,64(sp)
    alt_tse_system_info *psys = 0;
    
    np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
            
    /* Record previous MDIO address, to be restored at the end of function */
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
   1fc4c:	14401004 	addi	r17,r2,64
/* @Function Description: Store information of all the PHYs connected to MAC to phy_list
 * @API Type:         Internal
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @return            Number of PHY not in profile, return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 */
alt_32 alt_tse_mac_get_phy(alt_tse_mac_group *pmac_group) {
   1fc50:	ddc00f15 	stw	r23,60(sp)
   1fc54:	dd800e15 	stw	r22,56(sp)
   1fc58:	dd400d15 	stw	r21,52(sp)
   1fc5c:	dd000c15 	stw	r20,48(sp)
   1fc60:	dcc00b15 	stw	r19,44(sp)
   1fc64:	dc800a15 	stw	r18,40(sp)
    
    alt_tse_phy_info *pphy = 0;
    alt_tse_mac_info *pmac_info = 0;
    alt_tse_system_info *psys = 0;
    
    np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   1fc68:	d8800315 	stw	r2,12(sp)
            
    /* Record previous MDIO address, to be restored at the end of function */
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
   1fc6c:	88c00037 	ldwio	r3,0(r17)
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   1fc70:	d168df03 	ldbu	r5,-23684(gp)
    alt_tse_system_info *psys = 0;
    
    np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
            
    /* Record previous MDIO address, to be restored at the end of function */
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
   1fc74:	d8c00615 	stw	r3,24(sp)
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   1fc78:	28000c26 	beq	r5,zero,1fcac <alt_tse_mac_get_phy+0x84>
        if(pmac_group == pmac_groups[i]) {
   1fc7c:	00c001f4 	movhi	r3,7
   1fc80:	18d49d04 	addi	r3,r3,21108
   1fc84:	18800017 	ldw	r2,0(r3)
   1fc88:	20809c26 	beq	r4,r2,1fefc <alt_tse_mac_get_phy+0x2d4>
   1fc8c:	18c00104 	addi	r3,r3,4
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   1fc90:	0005883a 	mov	r2,zero
   1fc94:	00000206 	br	1fca0 <alt_tse_mac_get_phy+0x78>
        if(pmac_group == pmac_groups[i]) {
   1fc98:	193fff17 	ldw	r4,-4(r3)
   1fc9c:	81008626 	beq	r16,r4,1feb8 <alt_tse_mac_get_phy+0x290>
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   1fca0:	10800044 	addi	r2,r2,1
   1fca4:	18c00104 	addi	r3,r3,4
   1fca8:	117ffb16 	blt	r2,r5,1fc98 <alt_tse_mac_get_phy+0x70>
   1fcac:	00ffffc4 	movi	r3,-1
   1fcb0:	d8c00505 	stb	r3,20(sp)
   1fcb4:	d8c00317 	ldw	r3,12(sp)
   1fcb8:	0039883a 	mov	fp,zero
    alt_32 i;

    alt_u8 is_phy_in_profile;
    alt_32 return_value = 0;
    
    alt_8 phy_info_count = 0;
   1fcbc:	0025883a 	mov	r18,zero
   1fcc0:	1d00a204 	addi	r20,r3,648
   1fcc4:	1cc0a304 	addi	r19,r3,652
                }
            }
            /* PHY not found in PHY profile */
            if(is_phy_in_profile == 0) {
                pphy->pphy_profile = 0;
                tse_dprintf(3, "WARNING : Unknown PHY found at PHY address 0x%02x of MAC Group[%d]\n", phyadd, mac_group_index);
   1fcc8:	d8c00507 	ldb	r3,20(sp)
    alt_u8 revision_number;

    alt_32 i;

    alt_u8 is_phy_in_profile;
    alt_32 return_value = 0;
   1fccc:	d8000115 	stw	zero,4(sp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x00; phyadd < 0x20; phyadd++)
   1fcd0:	05400804 	movi	r21,32
                }
            }
            /* PHY not found in PHY profile */
            if(is_phy_in_profile == 0) {
                pphy->pphy_profile = 0;
                tse_dprintf(3, "WARNING : Unknown PHY found at PHY address 0x%02x of MAC Group[%d]\n", phyadd, mac_group_index);
   1fcd4:	d8c00215 	stw	r3,8(sp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x00; phyadd < 0x20; phyadd++)
    {        
        IOWR(&pmac_group_base->MDIO_ADDR1, 0, phyadd);
   1fcd8:	8f000035 	stwio	fp,0(r17)
        phyid = IORD(&pmac_group_base->mdio1.PHY_ID1,0);     // read PHY ID
   1fcdc:	a1400037 	ldwio	r5,0(r20)
        phyid2 = IORD(&pmac_group_base->mdio1.PHY_ID2,0);     // read PHY ID
   1fce0:	9d800037 	ldwio	r22,0(r19)
        
        /* PHY found */
        if (phyid != phyid2)
   1fce4:	2d802a26 	beq	r5,r22,1fd90 <alt_tse_mac_get_phy+0x168>
        {
            pphy = (alt_tse_phy_info *) malloc(sizeof(alt_tse_phy_info));
   1fce8:	01000704 	movi	r4,28
   1fcec:	d9400715 	stw	r5,28(sp)
   1fcf0:	00231640 	call	23164 <malloc>
   1fcf4:	102f883a 	mov	r23,r2
            if(!pphy) {
   1fcf8:	d9400717 	ldw	r5,28(sp)
   1fcfc:	10007026 	beq	r2,zero,1fec0 <alt_tse_mac_get_phy+0x298>
            
            /* store PHY address */
            pphy->mdio_address = phyadd;

            /* get oui, model number, and revision number from PHYID and PHYID2 */
            oui = (phyid << 6) | ((phyid2 >> 10) & 0x3f);
   1fd00:	b017d2ba 	srai	r11,r22,10
   1fd04:	280a91ba 	slli	r5,r5,6
            model_number = (phyid2 >> 4) & 0x3f;
   1fd08:	b007d13a 	srai	r3,r22,4
            revision_number = phyid2 & 0x0f;
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
            for(i = 0; i < phy_profile_count; i++) {
   1fd0c:	d2a8df43 	ldbu	r10,-23683(gp)
            
            /* store PHY address */
            pphy->mdio_address = phyadd;

            /* get oui, model number, and revision number from PHYID and PHYID2 */
            oui = (phyid << 6) | ((phyid2 >> 10) & 0x3f);
   1fd10:	5ac00fcc 	andi	r11,r11,63
                tse_dprintf(1, "ERROR   : Unable to allocate memory for phy_info[%d.%d]\n", mac_group_index, phy_info_count);
                return ALTERA_TSE_MALLOC_FAILED;
            }
            
            /* store PHY address */
            pphy->mdio_address = phyadd;
   1fd14:	17000005 	stb	fp,0(r2)

            /* get oui, model number, and revision number from PHYID and PHYID2 */
            oui = (phyid << 6) | ((phyid2 >> 10) & 0x3f);
   1fd18:	5956b03a 	or	r11,r11,r5
            model_number = (phyid2 >> 4) & 0x3f;
   1fd1c:	18800fcc 	andi	r2,r3,63
            revision_number = phyid2 & 0x0f;
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
            for(i = 0; i < phy_profile_count; i++) {
   1fd20:	50000a26 	beq	r10,zero,1fd4c <alt_tse_mac_get_phy+0x124>
   1fd24:	00c001f4 	movhi	r3,7
   1fd28:	18d4a504 	addi	r3,r3,21140
   1fd2c:	000f883a 	mov	r7,zero
                
                /* if PHY match with PHY in profile */
                if((pphy_profiles[i]->oui == oui) && (pphy_profiles[i]->model_number == model_number))
   1fd30:	10803fcc 	andi	r2,r2,255
   1fd34:	1a000017 	ldw	r8,0(r3)
            model_number = (phyid2 >> 4) & 0x3f;
            revision_number = phyid2 & 0x0f;
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
            for(i = 0; i < phy_profile_count; i++) {
   1fd38:	39c00044 	addi	r7,r7,1
   1fd3c:	18c00104 	addi	r3,r3,4
                
                /* if PHY match with PHY in profile */
                if((pphy_profiles[i]->oui == oui) && (pphy_profiles[i]->model_number == model_number))
   1fd40:	42401417 	ldw	r9,80(r8)
   1fd44:	4ac02d26 	beq	r9,r11,1fdfc <alt_tse_mac_get_phy+0x1d4>
            model_number = (phyid2 >> 4) & 0x3f;
            revision_number = phyid2 & 0x0f;
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
            for(i = 0; i < phy_profile_count; i++) {
   1fd48:	3abffa16 	blt	r7,r10,1fd34 <alt_tse_mac_get_phy+0x10c>
                }
            }
            /* PHY not found in PHY profile */
            if(is_phy_in_profile == 0) {
                pphy->pphy_profile = 0;
                tse_dprintf(3, "WARNING : Unknown PHY found at PHY address 0x%02x of MAC Group[%d]\n", phyadd, mac_group_index);
   1fd4c:	d9800217 	ldw	r6,8(sp)
   1fd50:	e00b883a 	mov	r5,fp
   1fd54:	010000b4 	movhi	r4,2
   1fd58:	211b2e04 	addi	r4,r4,27832
                    break;
                }
            }
            /* PHY not found in PHY profile */
            if(is_phy_in_profile == 0) {
                pphy->pphy_profile = 0;
   1fd5c:	b8000515 	stw	zero,20(r23)
                tse_dprintf(3, "WARNING : Unknown PHY found at PHY address 0x%02x of MAC Group[%d]\n", phyadd, mac_group_index);
   1fd60:	00104380 	call	10438 <printf>
                tse_dprintf(3, "WARNING : Please add PHY information to PHY profile\n");
   1fd64:	010000b4 	movhi	r4,2
   1fd68:	211b3f04 	addi	r4,r4,27900
   1fd6c:	00106a40 	call	106a4 <puts>
                return_value++;
   1fd70:	d8800117 	ldw	r2,4(sp)
            tse_dprintf(6, "INFO    : PHY OUI             =  0x%06x\n", (int) oui);
            tse_dprintf(6, "INFO    : PHY Model Number    =  0x%02x\n", model_number);
            tse_dprintf(6, "INFO    : PHY Revision Number =  0x%01x\n", revision_number);
            
            /* map the detected PHY to connected MAC */
            if(alt_tse_mac_associate_phy(pmac_group, pphy) == TSE_PHY_MAP_SUCCESS) {
   1fd74:	8009883a 	mov	r4,r16
   1fd78:	b80b883a 	mov	r5,r23
            /* PHY not found in PHY profile */
            if(is_phy_in_profile == 0) {
                pphy->pphy_profile = 0;
                tse_dprintf(3, "WARNING : Unknown PHY found at PHY address 0x%02x of MAC Group[%d]\n", phyadd, mac_group_index);
                tse_dprintf(3, "WARNING : Please add PHY information to PHY profile\n");
                return_value++;
   1fd7c:	10800044 	addi	r2,r2,1
   1fd80:	d8800115 	stw	r2,4(sp)
            tse_dprintf(6, "INFO    : PHY OUI             =  0x%06x\n", (int) oui);
            tse_dprintf(6, "INFO    : PHY Model Number    =  0x%02x\n", model_number);
            tse_dprintf(6, "INFO    : PHY Revision Number =  0x%01x\n", revision_number);
            
            /* map the detected PHY to connected MAC */
            if(alt_tse_mac_associate_phy(pmac_group, pphy) == TSE_PHY_MAP_SUCCESS) {
   1fd84:	001ecd40 	call	1ecd4 <alt_tse_mac_associate_phy>
   1fd88:	10002926 	beq	r2,zero,1fe30 <alt_tse_mac_get_phy+0x208>
            	}
            }
            
            tse_dprintf(6, "\n");
	            
            phy_info_count++;
   1fd8c:	94800044 	addi	r18,r18,1
   1fd90:	e7000044 	addi	fp,fp,1
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x00; phyadd < 0x20; phyadd++)
   1fd94:	e57fd01e 	bne	fp,r21,1fcd8 <alt_tse_mac_get_phy+0xb0>
            phy_info_count++;
        }
    }
    
    /* check to verify the number of connected PHY match the number of channel */
    if(pmac_group->channel != phy_info_count) {
   1fd98:	91803fcc 	andi	r6,r18,255
   1fd9c:	81c00003 	ldbu	r7,0(r16)
   1fda0:	3180201c 	xori	r6,r6,128
   1fda4:	31bfe004 	addi	r6,r6,-128
   1fda8:	39800526 	beq	r7,r6,1fdc0 <alt_tse_mac_get_phy+0x198>
        if(phy_info_count == 0) {
   1fdac:	30004e1e 	bne	r6,zero,1fee8 <alt_tse_mac_get_phy+0x2c0>
            tse_dprintf(2, "ERROR   : MAC Group[%d] - No PHY connected!\n", mac_group_index);
   1fdb0:	d9400507 	ldb	r5,20(sp)
   1fdb4:	010000b4 	movhi	r4,2
   1fdb8:	211b0304 	addi	r4,r4,27660
   1fdbc:	00104380 	call	10438 <printf>
            tse_dprintf(3, "WARNING : MAC Group[%d] - Number of PHY connected is not equal to the number of channel, Number of PHY : %d, Channel : %d\n", mac_group_index, phy_info_count, pmac_group->channel);
        }
    }
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
   1fdc0:	d8c00617 	ldw	r3,24(sp)
   1fdc4:	88c00035 	stwio	r3,0(r17)
    
    return return_value;
}
   1fdc8:	d8800117 	ldw	r2,4(sp)
   1fdcc:	dfc01117 	ldw	ra,68(sp)
   1fdd0:	df001017 	ldw	fp,64(sp)
   1fdd4:	ddc00f17 	ldw	r23,60(sp)
   1fdd8:	dd800e17 	ldw	r22,56(sp)
   1fddc:	dd400d17 	ldw	r21,52(sp)
   1fde0:	dd000c17 	ldw	r20,48(sp)
   1fde4:	dcc00b17 	ldw	r19,44(sp)
   1fde8:	dc800a17 	ldw	r18,40(sp)
   1fdec:	dc400917 	ldw	r17,36(sp)
   1fdf0:	dc000817 	ldw	r16,32(sp)
   1fdf4:	dec01204 	addi	sp,sp,72
   1fdf8:	f800283a 	ret
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
            for(i = 0; i < phy_profile_count; i++) {
                
                /* if PHY match with PHY in profile */
                if((pphy_profiles[i]->oui == oui) && (pphy_profiles[i]->model_number == model_number))
   1fdfc:	41801503 	ldbu	r6,84(r8)
   1fe00:	30bfd11e 	bne	r6,r2,1fd48 <alt_tse_mac_get_phy+0x120>
                {
                    pphy->pphy_profile = pphy_profiles[i];
                    
                    /* PHY found, add it to phy_list */
                    tse_dprintf(5, "INFO    : PHY %s found at PHY address 0x%02x of MAC Group[%d]\n", pphy_profiles[i]->name, phyadd, mac_group_index);
   1fe04:	d9c00217 	ldw	r7,8(sp)
   1fe08:	010000b4 	movhi	r4,2
   1fe0c:	211af304 	addi	r4,r4,27596
   1fe10:	400b883a 	mov	r5,r8
   1fe14:	e00d883a 	mov	r6,fp
            for(i = 0; i < phy_profile_count; i++) {
                
                /* if PHY match with PHY in profile */
                if((pphy_profiles[i]->oui == oui) && (pphy_profiles[i]->model_number == model_number))
                {
                    pphy->pphy_profile = pphy_profiles[i];
   1fe18:	ba000515 	stw	r8,20(r23)
                    
                    /* PHY found, add it to phy_list */
                    tse_dprintf(5, "INFO    : PHY %s found at PHY address 0x%02x of MAC Group[%d]\n", pphy_profiles[i]->name, phyadd, mac_group_index);
   1fe1c:	00104380 	call	10438 <printf>
            tse_dprintf(6, "INFO    : PHY OUI             =  0x%06x\n", (int) oui);
            tse_dprintf(6, "INFO    : PHY Model Number    =  0x%02x\n", model_number);
            tse_dprintf(6, "INFO    : PHY Revision Number =  0x%01x\n", revision_number);
            
            /* map the detected PHY to connected MAC */
            if(alt_tse_mac_associate_phy(pmac_group, pphy) == TSE_PHY_MAP_SUCCESS) {
   1fe20:	8009883a 	mov	r4,r16
   1fe24:	b80b883a 	mov	r5,r23
   1fe28:	001ecd40 	call	1ecd4 <alt_tse_mac_associate_phy>
   1fe2c:	103fd71e 	bne	r2,zero,1fd8c <alt_tse_mac_get_phy+0x164>
            	
            	pmac_info = pphy->pmac_info;
            	psys = pmac_info->psys_info;
   1fe30:	b8800617 	ldw	r2,24(r23)
            	
            	/* Disable PHY loopback to allow Auto-Negotiation completed */
    	        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
   1fe34:	01800384 	movi	r6,14
   1fe38:	01c00044 	movi	r7,1
            
            /* map the detected PHY to connected MAC */
            if(alt_tse_mac_associate_phy(pmac_group, pphy) == TSE_PHY_MAP_SUCCESS) {
            	
            	pmac_info = pphy->pmac_info;
            	psys = pmac_info->psys_info;
   1fe3c:	10800217 	ldw	r2,8(r2)
            	
            	/* Disable PHY loopback to allow Auto-Negotiation completed */
    	        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
   1fe40:	000b883a 	mov	r5,zero
   1fe44:	b809883a 	mov	r4,r23
   1fe48:	d8000015 	stw	zero,0(sp)
            
            /* map the detected PHY to connected MAC */
            if(alt_tse_mac_associate_phy(pmac_group, pphy) == TSE_PHY_MAP_SUCCESS) {
            	
            	pmac_info = pphy->pmac_info;
            	psys = pmac_info->psys_info;
   1fe4c:	d8800415 	stw	r2,16(sp)
            	
            	/* Disable PHY loopback to allow Auto-Negotiation completed */
    	        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
   1fe50:	001e7a40 	call	1e7a4 <alt_tse_phy_wr_mdio_reg>
				
				/* Reset auto-negotiation advertisement */
				alt_tse_phy_set_adv_1000(pphy, 1);
   1fe54:	b809883a 	mov	r4,r23
   1fe58:	01400044 	movi	r5,1
   1fe5c:	001f8200 	call	1f820 <alt_tse_phy_set_adv_1000>
				alt_tse_phy_set_adv_100(pphy, 1);
   1fe60:	b809883a 	mov	r4,r23
   1fe64:	01400044 	movi	r5,1
   1fe68:	001f9600 	call	1f960 <alt_tse_phy_set_adv_100>
				alt_tse_phy_set_adv_10(pphy, 1);
   1fe6c:	b809883a 	mov	r4,r23
   1fe70:	01400044 	movi	r5,1
   1fe74:	001fae80 	call	1fae8 <alt_tse_phy_set_adv_10>
            	            	
	            /* check link connection for this PHY */
	            alt_tse_phy_restart_an(pphy, ALTERA_CHECKLINK_TIMEOUT_THRESHOLD);
   1fe78:	b809883a 	mov	r4,r23
   1fe7c:	014003f4 	movhi	r5,15
   1fe80:	29509004 	addi	r5,r5,16960
   1fe84:	001f0a00 	call	1f0a0 <alt_tse_phy_restart_an>
	            
	            /* Perform additional setting if there is any */
	            /* Profile specific */
	            if(pphy->pphy_profile) {
   1fe88:	b8800517 	ldw	r2,20(r23)
   1fe8c:	10000426 	beq	r2,zero,1fea0 <alt_tse_mac_get_phy+0x278>
		            if(pphy->pphy_profile->phy_cfg) {
   1fe90:	10801717 	ldw	r2,92(r2)
   1fe94:	10000226 	beq	r2,zero,1fea0 <alt_tse_mac_get_phy+0x278>
		                tse_dprintf(6, "INFO    : Applying additional PHY configuration of %s\n", pphy->pphy_profile->name);
		                pphy->pphy_profile->phy_cfg(pmac_group_base);
   1fe98:	d9000317 	ldw	r4,12(sp)
   1fe9c:	103ee83a 	callr	r2
		            }
	            }
	            
	            /* Initialize PHY, call user's function pointer in alt_tse_system_info structure */
	            /* Individual PHY specific */
            	if(psys->tse_phy_cfg) {
   1fea0:	d8c00417 	ldw	r3,16(sp)
   1fea4:	18801117 	ldw	r2,68(r3)
   1fea8:	103fb826 	beq	r2,zero,1fd8c <alt_tse_mac_get_phy+0x164>
            		tse_dprintf(6, "INFO    : Applying additional user PHY configuration\n");
            		psys->tse_phy_cfg(pmac_group_base);
   1feac:	d9000317 	ldw	r4,12(sp)
   1feb0:	103ee83a 	callr	r2
   1feb4:	003fb506 	br	1fd8c <alt_tse_mac_get_phy+0x164>
   1feb8:	d8800505 	stb	r2,20(sp)
   1febc:	003f7d06 	br	1fcb4 <alt_tse_mac_get_phy+0x8c>
        /* PHY found */
        if (phyid != phyid2)
        {
            pphy = (alt_tse_phy_info *) malloc(sizeof(alt_tse_phy_info));
            if(!pphy) {
                tse_dprintf(1, "ERROR   : Unable to allocate memory for phy_info[%d.%d]\n", mac_group_index, phy_info_count);
   1fec0:	d9400507 	ldb	r5,20(sp)
   1fec4:	91803fcc 	andi	r6,r18,255
   1fec8:	3180201c 	xori	r6,r6,128
   1fecc:	010000b4 	movhi	r4,2
   1fed0:	211ae404 	addi	r4,r4,27536
   1fed4:	31bfe004 	addi	r6,r6,-128
   1fed8:	00104380 	call	10438 <printf>
                return ALTERA_TSE_MALLOC_FAILED;
   1fedc:	00bfffc4 	movi	r2,-1
   1fee0:	d8800115 	stw	r2,4(sp)
   1fee4:	003fb806 	br	1fdc8 <alt_tse_mac_get_phy+0x1a0>
    if(pmac_group->channel != phy_info_count) {
        if(phy_info_count == 0) {
            tse_dprintf(2, "ERROR   : MAC Group[%d] - No PHY connected!\n", mac_group_index);
        }
        else {
            tse_dprintf(3, "WARNING : MAC Group[%d] - Number of PHY connected is not equal to the number of channel, Number of PHY : %d, Channel : %d\n", mac_group_index, phy_info_count, pmac_group->channel);
   1fee8:	d9400507 	ldb	r5,20(sp)
   1feec:	010000b4 	movhi	r4,2
   1fef0:	211b0f04 	addi	r4,r4,27708
   1fef4:	00104380 	call	10438 <printf>
   1fef8:	003fb106 	br	1fdc0 <alt_tse_mac_get_phy+0x198>
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
        if(pmac_group == pmac_groups[i]) {
   1fefc:	d8000505 	stb	zero,20(sp)
   1ff00:	003f6c06 	br	1fcb4 <alt_tse_mac_get_phy+0x8c>

0001ff04 <alt_tse_phy_init>:
/* @Function Description: Detect and initialize all the PHYs connected
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      SUCCESS
 */
alt_32 alt_tse_phy_init() {
   1ff04:	defffb04 	addi	sp,sp,-20
   1ff08:	dfc00415 	stw	ra,16(sp)
   1ff0c:	dcc00315 	stw	r19,12(sp)
   1ff10:	dc800215 	stw	r18,8(sp)
   1ff14:	dc400115 	stw	r17,4(sp)
   1ff18:	dc000015 	stw	r16,0(sp)
    
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    /* add supported PHYs */
    alt_tse_phy_add_profile_default();
   1ff1c:	001e8a00 	call	1e8a0 <alt_tse_phy_add_profile_default>
    
    /* display PHY in profile */
    alt_tse_phy_print_profile();
    
    alt_tse_mac_group_init();
   1ff20:	001eac40 	call	1eac4 <alt_tse_mac_group_init>
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
   1ff24:	d0a8df03 	ldbu	r2,-23684(gp)
   1ff28:	10002226 	beq	r2,zero,1ffb4 <alt_tse_phy_init+0xb0>
   1ff2c:	04800044 	movi	r18,1
   1ff30:	000b883a 	mov	r5,zero
   1ff34:	000d883a 	mov	r6,zero
   1ff38:	04c001f4 	movhi	r19,7
   1ff3c:	9cd49d04 	addi	r19,r19,21108
        pmac_group = pmac_groups[i];
   1ff40:	2945883a 	add	r2,r5,r5
   1ff44:	1085883a 	add	r2,r2,r2
   1ff48:	9885883a 	add	r2,r19,r2
   1ff4c:	14400017 	ldw	r17,0(r2)
        
        if(pmac_group->pmac_info[0]->psys_info->tse_use_mdio) {
   1ff50:	88800117 	ldw	r2,4(r17)
   1ff54:	10800217 	ldw	r2,8(r2)
   1ff58:	10800203 	ldbu	r2,8(r2)
   1ff5c:	10001d26 	beq	r2,zero,1ffd4 <alt_tse_phy_init+0xd0>
            
        	/* get connected PHYs */
            alt_tse_mac_get_phy(pmac_group);
   1ff60:	8809883a 	mov	r4,r17
   1ff64:	001fc280 	call	1fc28 <alt_tse_mac_get_phy>
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
   1ff68:	88800003 	ldbu	r2,0(r17)
   1ff6c:	10002126 	beq	r2,zero,1fff4 <alt_tse_phy_init+0xf0>
   1ff70:	04000044 	movi	r16,1
   1ff74:	0005883a 	mov	r2,zero
            pmac_info = pmac_group->pmac_info[j];
   1ff78:	10800044 	addi	r2,r2,1
   1ff7c:	1085883a 	add	r2,r2,r2
   1ff80:	1085883a 	add	r2,r2,r2
   1ff84:	8885883a 	add	r2,r17,r2
            
            alt_tse_phy_cfg_pcs(pmac_info);
   1ff88:	11000017 	ldw	r4,0(r2)
   1ff8c:	001ef4c0 	call	1ef4c <alt_tse_phy_cfg_pcs>
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
   1ff90:	88c00003 	ldbu	r3,0(r17)
   1ff94:	8005883a 	mov	r2,r16
   1ff98:	800d883a 	mov	r6,r16
   1ff9c:	84000044 	addi	r16,r16,1
   1ffa0:	10fff516 	blt	r2,r3,1ff78 <alt_tse_phy_init+0x74>
    
    alt_tse_mac_group_init();
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
   1ffa4:	d0a8df03 	ldbu	r2,-23684(gp)
   1ffa8:	900b883a 	mov	r5,r18
   1ffac:	94800044 	addi	r18,r18,1
   1ffb0:	28bfe316 	blt	r5,r2,1ff40 <alt_tse_phy_init+0x3c>
            alt_tse_phy_cfg_pcs(pmac_info);
        }
    }
                
    return SUCCESS;
}
   1ffb4:	0005883a 	mov	r2,zero
   1ffb8:	dfc00417 	ldw	ra,16(sp)
   1ffbc:	dcc00317 	ldw	r19,12(sp)
   1ffc0:	dc800217 	ldw	r18,8(sp)
   1ffc4:	dc400117 	ldw	r17,4(sp)
   1ffc8:	dc000017 	ldw	r16,0(sp)
   1ffcc:	dec00504 	addi	sp,sp,20
   1ffd0:	f800283a 	ret
            
        	/* get connected PHYs */
            alt_tse_mac_get_phy(pmac_group);
        }
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
   1ffd4:	31803fcc 	andi	r6,r6,255
   1ffd8:	3180201c 	xori	r6,r6,128
   1ffdc:	010000b4 	movhi	r4,2
   1ffe0:	211b4c04 	addi	r4,r4,27952
   1ffe4:	31bfe004 	addi	r6,r6,-128
   1ffe8:	00104380 	call	10438 <printf>
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
   1ffec:	88800003 	ldbu	r2,0(r17)
   1fff0:	103fdf1e 	bne	r2,zero,1ff70 <alt_tse_phy_init+0x6c>
    
    alt_tse_mac_group_init();
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
   1fff4:	d0a8df03 	ldbu	r2,-23684(gp)
   1fff8:	900b883a 	mov	r5,r18
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
   1fffc:	000d883a 	mov	r6,zero
   20000:	94800044 	addi	r18,r18,1
    
    alt_tse_mac_group_init();
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
   20004:	28bfce16 	blt	r5,r2,1ff40 <alt_tse_phy_init+0x3c>
   20008:	003fea06 	br	1ffb4 <alt_tse_phy_init+0xb0>

0002000c <getPHYSpeed>:
    alt_8 mac_info_index = 0;
    alt_8 mac_group_index = 0;
    
    /* initialized PHYs only once */
    static alt_u8 is_init = 0;
    if(is_init == 0) {
   2000c:	d0a8dfc3 	ldbu	r2,-23681(gp)
  	(((speed == TSE_PHY_SPEED_1000) ? 1 : 0) << 1) |   \
	(((speed == TSE_PHY_SPEED_100) ? 1 : 0) << 2) |     \
	(((speed == TSE_PHY_SPEED_10) ? 1 : 0) << 3) |      \
	((speed == TSE_PHY_SPEED_INVALID) ? ALT_TSE_E_INVALID_SPEED : 0))
  
alt_32 getPHYSpeed(np_tse_mac *pmac) {
   20010:	defff804 	addi	sp,sp,-32
   20014:	dc400215 	stw	r17,8(sp)
   20018:	dfc00715 	stw	ra,28(sp)
   2001c:	dd400615 	stw	r21,24(sp)
   20020:	dd000515 	stw	r20,20(sp)
   20024:	dcc00415 	stw	r19,16(sp)
   20028:	dc800315 	stw	r18,12(sp)
   2002c:	dc000115 	stw	r16,4(sp)
   20030:	2023883a 	mov	r17,r4
    alt_8 mac_info_index = 0;
    alt_8 mac_group_index = 0;
    
    /* initialized PHYs only once */
    static alt_u8 is_init = 0;
    if(is_init == 0) {
   20034:	10008926 	beq	r2,zero,2025c <getPHYSpeed+0x250>
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
   20038:	d2a8df03 	ldbu	r10,-23684(gp)
   2003c:	50001826 	beq	r10,zero,200a0 <getPHYSpeed+0x94>
   20040:	02c001f4 	movhi	r11,7
   20044:	5ad49d04 	addi	r11,r11,21108
   20048:	5809883a 	mov	r4,r11
   2004c:	0011883a 	mov	r8,zero
        pmac_group = pmac_groups[i];
   20050:	20c00017 	ldw	r3,0(r4)
        for(j = 0; j < pmac_group->channel; j++) {
   20054:	19800003 	ldbu	r6,0(r3)
   20058:	30000e26 	beq	r6,zero,20094 <getPHYSpeed+0x88>
            pmac_info = pmac_group->pmac_info[j];
   2005c:	19c00117 	ldw	r7,4(r3)
            if(((np_tse_mac *) pmac_info->psys_info->tse_mac_base) == pmac) {
   20060:	3c000217 	ldw	r16,8(r7)
   20064:	80800017 	ldw	r2,0(r16)
   20068:	88801a26 	beq	r17,r2,200d4 <getPHYSpeed+0xc8>
  	(((speed == TSE_PHY_SPEED_1000) ? 1 : 0) << 1) |   \
	(((speed == TSE_PHY_SPEED_100) ? 1 : 0) << 2) |     \
	(((speed == TSE_PHY_SPEED_10) ? 1 : 0) << 3) |      \
	((speed == TSE_PHY_SPEED_INVALID) ? ALT_TSE_E_INVALID_SPEED : 0))
  
alt_32 getPHYSpeed(np_tse_mac *pmac) {
   2006c:	18c00204 	addi	r3,r3,8
   20070:	0005883a 	mov	r2,zero
   20074:	00000506 	br	2008c <getPHYSpeed+0x80>
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
        pmac_group = pmac_groups[i];
        for(j = 0; j < pmac_group->channel; j++) {
            pmac_info = pmac_group->pmac_info[j];
   20078:	19c00017 	ldw	r7,0(r3)
   2007c:	18c00104 	addi	r3,r3,4
            if(((np_tse_mac *) pmac_info->psys_info->tse_mac_base) == pmac) {
   20080:	3c000217 	ldw	r16,8(r7)
   20084:	81400017 	ldw	r5,0(r16)
   20088:	89401226 	beq	r17,r5,200d4 <getPHYSpeed+0xc8>
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
        pmac_group = pmac_groups[i];
        for(j = 0; j < pmac_group->channel; j++) {
   2008c:	10800044 	addi	r2,r2,1
   20090:	11bff916 	blt	r2,r6,20078 <getPHYSpeed+0x6c>
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
   20094:	42000044 	addi	r8,r8,1
   20098:	21000104 	addi	r4,r4,4
   2009c:	42bfec16 	blt	r8,r10,20050 <getPHYSpeed+0x44>
    
    if(pmac_info == 0) {
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PMAC_FOUND;
        tse_dprintf(2, "ERROR   : [getPHYSpeed] pmac not found from list of pmac_info[]! Speed = %s Mbps, Duplex = %s\n", speed == TSE_PHY_SPEED_1000 ? "1000" :
   200a0:	010000b4 	movhi	r4,2
   200a4:	211bf304 	addi	r4,r4,28620
   200a8:	014000b4 	movhi	r5,2
   200ac:	295b6204 	addi	r5,r5,28040
   200b0:	018000b4 	movhi	r6,2
   200b4:	319b6804 	addi	r6,r6,28064
   200b8:	00104380 	call	10438 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        tse_dprintf(2, "ERROR   : [getPHYSpeed] Please define tse_mac_device[] correctly\n");
   200bc:	010000b4 	movhi	r4,2
   200c0:	211c0b04 	addi	r4,r4,28716
   200c4:	00106a40 	call	106a4 <puts>
        return result;
   200c8:	04002034 	movhi	r16,128
   200cc:	84000144 	addi	r16,r16,5
   200d0:	00007406 	br	202a4 <getPHYSpeed+0x298>
    }
    
    pphy = pmac_info->pphy_info;
    pmac_group = pmac_info->pmac_group;
   200d4:	3a400317 	ldw	r9,12(r7)
                                                                                 duplex == 1 ? "Full" : "Half");
        tse_dprintf(2, "ERROR   : [getPHYSpeed] Please define tse_mac_device[] correctly\n");
        return result;
    }
    
    pphy = pmac_info->pphy_info;
   200d8:	3cc00117 	ldw	r19,4(r7)
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   200dc:	49800003 	ldbu	r6,0(r9)
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   200e0:	49000117 	ldw	r4,4(r9)
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   200e4:	30000926 	beq	r6,zero,2010c <getPHYSpeed+0x100>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   200e8:	3900fb26 	beq	r7,r4,204d8 <getPHYSpeed+0x4cc>
  	(((speed == TSE_PHY_SPEED_1000) ? 1 : 0) << 1) |   \
	(((speed == TSE_PHY_SPEED_100) ? 1 : 0) << 2) |     \
	(((speed == TSE_PHY_SPEED_10) ? 1 : 0) << 3) |      \
	((speed == TSE_PHY_SPEED_INVALID) ? ALT_TSE_E_INVALID_SPEED : 0))
  
alt_32 getPHYSpeed(np_tse_mac *pmac) {
   200ec:	48c00204 	addi	r3,r9,8
   200f0:	0005883a 	mov	r2,zero
   200f4:	00000206 	br	20100 <getPHYSpeed+0xf4>
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   200f8:	197fff17 	ldw	r5,-4(r3)
   200fc:	39405526 	beq	r7,r5,20254 <getPHYSpeed+0x248>
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   20100:	10800044 	addi	r2,r2,1
   20104:	18c00104 	addi	r3,r3,4
   20108:	11bffb16 	blt	r2,r6,200f8 <getPHYSpeed+0xec>
   2010c:	04bfffc4 	movi	r18,-1
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
        if(pmac_group == pmac_groups[i]) {
   20110:	58800017 	ldw	r2,0(r11)
   20114:	4880f226 	beq	r9,r2,204e0 <getPHYSpeed+0x4d4>
   20118:	00c001f4 	movhi	r3,7
   2011c:	18d49e04 	addi	r3,r3,21112
   20120:	000b883a 	mov	r5,zero
   20124:	00000206 	br	20130 <getPHYSpeed+0x124>
   20128:	1a3fff17 	ldw	r8,-4(r3)
   2012c:	4a002c26 	beq	r9,r8,201e0 <getPHYSpeed+0x1d4>
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   20130:	29400044 	addi	r5,r5,1
   20134:	18c00104 	addi	r3,r3,4
   20138:	2abffb16 	blt	r5,r10,20128 <getPHYSpeed+0x11c>
   2013c:	053fffc4 	movi	r20,-1
    
    mac_info_index = alt_tse_get_mac_info_index(pmac_info);
    mac_group_index = alt_tse_get_mac_group_index(pmac_group);
         
    /* MDIO is not used */
    if (pmac_group->pmac_info[0]->psys_info->tse_use_mdio == 0)
   20140:	20800217 	ldw	r2,8(r4)
   20144:	10c00203 	ldbu	r3,8(r2)
   20148:	18002b26 	beq	r3,zero,201f8 <getPHYSpeed+0x1ec>

    /* Not running simulation */
    #ifndef ALT_SIM_OPTIMIZE
	
		/* These variables declaration are here to avoid "warning: unused variable" message when compile for simulation */
		np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   2014c:	14000017 	ldw	r16,0(r2)
    
        /* if no PHY connected to the MAC */
        if(pphy == 0) {
   20150:	9800b026 	beq	r19,zero,20414 <getPHYSpeed+0x408>
                                                                                 duplex == 1 ? "Full" : "Half");
            return result;
        }

		/* Small MAC */
		if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
   20154:	38800003 	ldbu	r2,0(r7)
   20158:	00c00044 	movi	r3,1
   2015c:	10c0bc26 	beq	r2,r3,20450 <getPHYSpeed+0x444>
			alt_tse_phy_set_adv_1000(pphy, 0);
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
		}
		else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
   20160:	00c00084 	movi	r3,2
   20164:	10c0c226 	beq	r2,r3,20470 <getPHYSpeed+0x464>
			alt_tse_phy_set_adv_10(pphy, 0);
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
		}
		
		/* check link connection for this PHY */
		if(alt_tse_phy_check_link(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD) == TSE_PHY_AN_NOT_COMPLETE) {
   20168:	9809883a 	mov	r4,r19
   2016c:	01400134 	movhi	r5,4
   20170:	29742404 	addi	r5,r5,-12144
   20174:	001f2e40 	call	1f2e4 <alt_tse_phy_check_link>
   20178:	00ffffc4 	movi	r3,-1
   2017c:	10c03b26 	beq	r2,r3,2026c <getPHYSpeed+0x260>
																			 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
																			 duplex == 1 ? "Full" : "Half");
			return result;
		}

        IOWR(&pmac_group_base->MDIO_ADDR1, 0, pphy->mdio_address);
   20180:	98800003 	ldbu	r2,0(r19)
   20184:	80801035 	stwio	r2,64(r16)
        /* To enable PHY loopback */
        #if ENABLE_PHY_LOOPBACK
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Putting PHY in loopback\n", mac_group_index, mac_info_index);
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 1);   // enable PHY loopback
		#else
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
   20188:	04400044 	movi	r17,1
   2018c:	d8000015 	stw	zero,0(sp)
   20190:	9809883a 	mov	r4,r19
   20194:	000b883a 	mov	r5,zero
   20198:	01800384 	movi	r6,14
   2019c:	880f883a 	mov	r7,r17
   201a0:	001e7a40 	call	1e7a4 <alt_tse_phy_wr_mdio_reg>
        #endif
       
        /* if PHY not found in profile */
        if(pphy->pphy_profile == 0) {
   201a4:	98800517 	ldw	r2,20(r19)
   201a8:	1000cf26 	beq	r2,zero,204e8 <getPHYSpeed+0x4dc>
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY_PROFILE;
        }
        // retrieve duplex information from PHY
		else
		{
			if(pphy->pphy_profile->link_status_read)
   201ac:	10c01817 	ldw	r3,96(r2)
   201b0:	18004626 	beq	r3,zero,202cc <getPHYSpeed+0x2c0>
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
   201b4:	8009883a 	mov	r4,r16
   201b8:	183ee83a 	callr	r3
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
   201bc:	10c0008c 	andi	r3,r2,2
        // retrieve duplex information from PHY
		else
		{
			if(pphy->pphy_profile->link_status_read)
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
   201c0:	1021883a 	mov	r16,r2
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
   201c4:	18005d1e 	bne	r3,zero,2033c <getPHYSpeed+0x330>
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
   201c8:	10c0010c 	andi	r3,r2,4
		else
		{
			if(pphy->pphy_profile->link_status_read)
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
   201cc:	1800b31e 	bne	r3,zero,2049c <getPHYSpeed+0x490>
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
   201d0:	10c0020c 	andi	r3,r2,8
		else
		{
			if(pphy->pphy_profile->link_status_read)
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
   201d4:	1800b326 	beq	r3,zero,204a4 <getPHYSpeed+0x498>
   201d8:	002b883a 	mov	r21,zero
   201dc:	00005806 	br	20340 <getPHYSpeed+0x334>
    
    mac_info_index = alt_tse_get_mac_info_index(pmac_info);
    mac_group_index = alt_tse_get_mac_group_index(pmac_group);
         
    /* MDIO is not used */
    if (pmac_group->pmac_info[0]->psys_info->tse_use_mdio == 0)
   201e0:	20800217 	ldw	r2,8(r4)
   201e4:	2d003fcc 	andi	r20,r5,255
   201e8:	a500201c 	xori	r20,r20,128
   201ec:	10c00203 	ldbu	r3,8(r2)
   201f0:	a53fe004 	addi	r20,r20,-128
   201f4:	183fd51e 	bne	r3,zero,2014c <getPHYSpeed+0x140>
    {
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_MDIO;
        usleep(ALTERA_NOMDIO_TIMEOUT_THRESHOLD);
   201f8:	010003f4 	movhi	r4,15
   201fc:	21109004 	addi	r4,r4,16960
   20200:	00194f00 	call	194f0 <usleep>
        if(psys->tse_phy_cfg) {
   20204:	80801117 	ldw	r2,68(r16)
   20208:	1000a826 	beq	r2,zero,204ac <getPHYSpeed+0x4a0>
        	tse_dprintf(4, "WARNING : PHY[%d.%d] - MDIO not enabled! Running user configuration...\n", mac_group_index, mac_info_index);
   2020c:	91803fcc 	andi	r6,r18,255
   20210:	3180201c 	xori	r6,r6,128
   20214:	010000b4 	movhi	r4,2
   20218:	211b6c04 	addi	r4,r4,28080
   2021c:	a00b883a 	mov	r5,r20
   20220:	31bfe004 	addi	r6,r6,-128
   20224:	00104380 	call	10438 <printf>
        	result = psys->tse_phy_cfg(pmac);
   20228:	80801117 	ldw	r2,68(r16)
   2022c:	8809883a 	mov	r4,r17
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");

    return result;
}
   20230:	dfc00717 	ldw	ra,28(sp)
   20234:	dd400617 	ldw	r21,24(sp)
   20238:	dd000517 	ldw	r20,20(sp)
   2023c:	dcc00417 	ldw	r19,16(sp)
   20240:	dc800317 	ldw	r18,12(sp)
   20244:	dc400217 	ldw	r17,8(sp)
   20248:	dc000117 	ldw	r16,4(sp)
   2024c:	dec00804 	addi	sp,sp,32
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_MDIO;
        usleep(ALTERA_NOMDIO_TIMEOUT_THRESHOLD);
        if(psys->tse_phy_cfg) {
        	tse_dprintf(4, "WARNING : PHY[%d.%d] - MDIO not enabled! Running user configuration...\n", mac_group_index, mac_info_index);
        	result = psys->tse_phy_cfg(pmac);
   20250:	1000683a 	jmp	r2
   20254:	1025883a 	mov	r18,r2
   20258:	003fad06 	br	20110 <getPHYSpeed+0x104>
    alt_8 mac_group_index = 0;
    
    /* initialized PHYs only once */
    static alt_u8 is_init = 0;
    if(is_init == 0) {
        alt_tse_phy_init();
   2025c:	001ff040 	call	1ff04 <alt_tse_phy_init>
        is_init = 1;
   20260:	00800044 	movi	r2,1
   20264:	d0a8dfc5 	stb	r2,-23681(gp)
   20268:	003f7306 	br	20038 <getPHYSpeed+0x2c>
		/* check link connection for this PHY */
		if(alt_tse_phy_check_link(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD) == TSE_PHY_AN_NOT_COMPLETE) {
			speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
			duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_AN_NOT_COMPLETE;
			tse_dprintf(3, "WARNING : PHY[%d.%d] - Auto-Negotiation not completed! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
   2026c:	91803fcc 	andi	r6,r18,255
   20270:	008000b4 	movhi	r2,2
   20274:	109b6804 	addi	r2,r2,28064
   20278:	3180201c 	xori	r6,r6,128
   2027c:	d8800015 	stw	r2,0(sp)
   20280:	010000b4 	movhi	r4,2
   20284:	211ba104 	addi	r4,r4,28292
   20288:	a00b883a 	mov	r5,r20
   2028c:	31bfe004 	addi	r6,r6,-128
   20290:	01c000b4 	movhi	r7,2
   20294:	39db6204 	addi	r7,r7,28040
   20298:	00104380 	call	10438 <printf>
																			 speed == TSE_PHY_SPEED_100 ? "100" :
																			 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
																			 duplex == 1 ? "Full" : "Half");
			return result;
   2029c:	04000234 	movhi	r16,8
   202a0:	84000144 	addi	r16,r16,5
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");

    return result;
}
   202a4:	8005883a 	mov	r2,r16
   202a8:	dfc00717 	ldw	ra,28(sp)
   202ac:	dd400617 	ldw	r21,24(sp)
   202b0:	dd000517 	ldw	r20,20(sp)
   202b4:	dcc00417 	ldw	r19,16(sp)
   202b8:	dc800317 	ldw	r18,12(sp)
   202bc:	dc400217 	ldw	r17,8(sp)
   202c0:	dc000117 	ldw	r16,4(sp)
   202c4:	dec00804 	addi	sp,sp,32
   202c8:	f800283a 	ret
				if(result & ALT_TSE_E_INVALID_SPEED)
				{
					tse_dprintf(3, "WARNING : PHY[%d.%d] - Invalid speed read from PHY\n", mac_group_index, mac_info_index);
				}
			}
			else if(pphy->pphy_profile->status_reg_location == 0)
   202cc:	11401583 	ldbu	r5,86(r2)
   202d0:	28003b26 	beq	r5,zero,203c0 <getPHYSpeed+0x3b4>
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_PROFILE_INCORRECT_DEFINED;
	        }
	        else
	        {
	            /* extract connection speed and duplex information */
	        	speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
   202d4:	118015c3 	ldbu	r6,87(r2)
   202d8:	04000084 	movi	r16,2
   202dc:	9809883a 	mov	r4,r19
   202e0:	800f883a 	mov	r7,r16
   202e4:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
   202e8:	102b883a 	mov	r21,r2
	            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
   202ec:	98800517 	ldw	r2,20(r19)
   202f0:	9809883a 	mov	r4,r19
   202f4:	880f883a 	mov	r7,r17
   202f8:	11401583 	ldbu	r5,86(r2)
   202fc:	11801603 	ldbu	r6,88(r2)
   20300:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
				
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
   20304:	a8c03fcc 	andi	r3,r21,255
	        }
	        else
	        {
	            /* extract connection speed and duplex information */
	        	speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
	            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
   20308:	1027883a 	mov	r19,r2
				
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
   2030c:	1080004c 	andi	r2,r2,1
   20310:	1c008326 	beq	r3,r16,20520 <getPHYSpeed+0x514>
   20314:	1c407f26 	beq	r3,r17,20514 <getPHYSpeed+0x508>
   20318:	1021883a 	mov	r16,r2
   2031c:	1800861e 	bne	r3,zero,20538 <getPHYSpeed+0x52c>
   20320:	14000214 	ori	r16,r2,8
   20324:	0005883a 	mov	r2,zero
   20328:	94803fcc 	andi	r18,r18,255
   2032c:	9480201c 	xori	r18,r18,128
   20330:	80a0b03a 	or	r16,r16,r2
   20334:	94bfe004 	addi	r18,r18,-128
   20338:	00000806 	br	2035c <getPHYSpeed+0x350>
		else
		{
			if(pphy->pphy_profile->link_status_read)
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
   2033c:	05400084 	movi	r21,2
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
				duplex = (result & 0x01) ? TSE_PHY_DUPLEX_FULL : TSE_PHY_DUPLEX_HALF;
				
				if(result & ALT_TSE_E_INVALID_SPEED)
				{
					tse_dprintf(3, "WARNING : PHY[%d.%d] - Invalid speed read from PHY\n", mac_group_index, mac_info_index);
   20340:	94803fcc 	andi	r18,r18,255
   20344:	9480201c 	xori	r18,r18,128
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
				duplex = (result & 0x01) ? TSE_PHY_DUPLEX_FULL : TSE_PHY_DUPLEX_HALF;
				
				if(result & ALT_TSE_E_INVALID_SPEED)
   20348:	10c0006c 	andhi	r3,r2,1
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
				duplex = (result & 0x01) ? TSE_PHY_DUPLEX_FULL : TSE_PHY_DUPLEX_HALF;
   2034c:	14c0004c 	andi	r19,r2,1
				
				if(result & ALT_TSE_E_INVALID_SPEED)
				{
					tse_dprintf(3, "WARNING : PHY[%d.%d] - Invalid speed read from PHY\n", mac_group_index, mac_info_index);
   20350:	94bfe004 	addi	r18,r18,-128
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
				duplex = (result & 0x01) ? TSE_PHY_DUPLEX_FULL : TSE_PHY_DUPLEX_HALF;
				
				if(result & ALT_TSE_E_INVALID_SPEED)
   20354:	1800141e 	bne	r3,zero,203a8 <getPHYSpeed+0x39c>
   20358:	a8c03fcc 	andi	r3,r21,255
        /* for simulation purpose, default to gigabit mode */
        speed = 1;
        duplex = 1;
    #endif

    tse_dprintf(5, "INFO    : PHY[%d.%d] - Speed = %s, Duplex = %s\n",  mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
   2035c:	00800084 	movi	r2,2
   20360:	18802626 	beq	r3,r2,203fc <getPHYSpeed+0x3f0>
   20364:	00800044 	movi	r2,1
   20368:	18807026 	beq	r3,r2,2052c <getPHYSpeed+0x520>
   2036c:	1800261e 	bne	r3,zero,20408 <getPHYSpeed+0x3fc>
   20370:	01c000b4 	movhi	r7,2
   20374:	39db6704 	addi	r7,r7,28060
   20378:	9cc03fcc 	andi	r19,r19,255
   2037c:	00800044 	movi	r2,1
   20380:	98801b26 	beq	r19,r2,203f0 <getPHYSpeed+0x3e4>
   20384:	008000b4 	movhi	r2,2
   20388:	109b6a04 	addi	r2,r2,28072
   2038c:	d8800015 	stw	r2,0(sp)
   20390:	010000b4 	movhi	r4,2
   20394:	211be704 	addi	r4,r4,28572
   20398:	a00b883a 	mov	r5,r20
   2039c:	900d883a 	mov	r6,r18
   203a0:	00104380 	call	10438 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");

    return result;
   203a4:	003fbf06 	br	202a4 <getPHYSpeed+0x298>
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
				duplex = (result & 0x01) ? TSE_PHY_DUPLEX_FULL : TSE_PHY_DUPLEX_HALF;
				
				if(result & ALT_TSE_E_INVALID_SPEED)
				{
					tse_dprintf(3, "WARNING : PHY[%d.%d] - Invalid speed read from PHY\n", mac_group_index, mac_info_index);
   203a8:	010000b4 	movhi	r4,2
   203ac:	211bc304 	addi	r4,r4,28428
   203b0:	a00b883a 	mov	r5,r20
   203b4:	900d883a 	mov	r6,r18
   203b8:	00104380 	call	10438 <printf>
   203bc:	003fe606 	br	20358 <getPHYSpeed+0x34c>
				}
			}
			else if(pphy->pphy_profile->status_reg_location == 0)
	        {
	            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY Specific Status register information not provided in profile\n", mac_group_index, mac_info_index);
   203c0:	94803fcc 	andi	r18,r18,255
   203c4:	9480201c 	xori	r18,r18,128
   203c8:	94bfe004 	addi	r18,r18,-128
   203cc:	010000b4 	movhi	r4,2
   203d0:	211bd004 	addi	r4,r4,28480
   203d4:	a00b883a 	mov	r5,r20
   203d8:	900d883a 	mov	r6,r18
   203dc:	00104380 	call	10438 <printf>
	            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
	            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_PROFILE_INCORRECT_DEFINED;
   203e0:	040000b4 	movhi	r16,2
   203e4:	84000144 	addi	r16,r16,5
        /* for simulation purpose, default to gigabit mode */
        speed = 1;
        duplex = 1;
    #endif

    tse_dprintf(5, "INFO    : PHY[%d.%d] - Speed = %s, Duplex = %s\n",  mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
   203e8:	01c000b4 	movhi	r7,2
   203ec:	39db6204 	addi	r7,r7,28040
   203f0:	008000b4 	movhi	r2,2
   203f4:	109b6804 	addi	r2,r2,28064
   203f8:	003fe406 	br	2038c <getPHYSpeed+0x380>
   203fc:	01c000b4 	movhi	r7,2
   20400:	39db6304 	addi	r7,r7,28044
   20404:	003fdc06 	br	20378 <getPHYSpeed+0x36c>
   20408:	01c000b4 	movhi	r7,2
   2040c:	39db6504 	addi	r7,r7,28052
   20410:	003fd906 	br	20378 <getPHYSpeed+0x36c>
        /* if no PHY connected to the MAC */
        if(pphy == 0) {
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
            result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY;
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - No PHY connected! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
   20414:	91803fcc 	andi	r6,r18,255
   20418:	008000b4 	movhi	r2,2
   2041c:	109b6804 	addi	r2,r2,28064
   20420:	3180201c 	xori	r6,r6,128
   20424:	d8800015 	stw	r2,0(sp)
   20428:	010000b4 	movhi	r4,2
   2042c:	211b9004 	addi	r4,r4,28224
   20430:	a00b883a 	mov	r5,r20
   20434:	31bfe004 	addi	r6,r6,-128
   20438:	01c000b4 	movhi	r7,2
   2043c:	39db6204 	addi	r7,r7,28040
   20440:	00104380 	call	10438 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
            return result;
   20444:	04000834 	movhi	r16,32
   20448:	84000144 	addi	r16,r16,5
   2044c:	003f9506 	br	202a4 <getPHYSpeed+0x298>
        }

		/* Small MAC */
		if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
			alt_tse_phy_set_adv_1000(pphy, 0);
   20450:	9809883a 	mov	r4,r19
   20454:	000b883a 	mov	r5,zero
   20458:	001f8200 	call	1f820 <alt_tse_phy_set_adv_1000>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
   2045c:	9809883a 	mov	r4,r19
   20460:	01400134 	movhi	r5,4
   20464:	29742404 	addi	r5,r5,-12144
   20468:	001f0a00 	call	1f0a0 <alt_tse_phy_restart_an>
   2046c:	003f3e06 	br	20168 <getPHYSpeed+0x15c>
		}
		else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
			alt_tse_phy_set_adv_100(pphy, 0);
   20470:	9809883a 	mov	r4,r19
   20474:	000b883a 	mov	r5,zero
   20478:	001f9600 	call	1f960 <alt_tse_phy_set_adv_100>
			alt_tse_phy_set_adv_10(pphy, 0);
   2047c:	9809883a 	mov	r4,r19
   20480:	000b883a 	mov	r5,zero
   20484:	001fae80 	call	1fae8 <alt_tse_phy_set_adv_10>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
   20488:	9809883a 	mov	r4,r19
   2048c:	01400134 	movhi	r5,4
   20490:	29742404 	addi	r5,r5,-12144
   20494:	001f0a00 	call	1f0a0 <alt_tse_phy_restart_an>
   20498:	003f3306 	br	20168 <getPHYSpeed+0x15c>
		else
		{
			if(pphy->pphy_profile->link_status_read)
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
   2049c:	882b883a 	mov	r21,r17
   204a0:	003fa706 	br	20340 <getPHYSpeed+0x334>
   204a4:	054000c4 	movi	r21,3
   204a8:	003fa506 	br	20340 <getPHYSpeed+0x334>
        if(psys->tse_phy_cfg) {
        	tse_dprintf(4, "WARNING : PHY[%d.%d] - MDIO not enabled! Running user configuration...\n", mac_group_index, mac_info_index);
        	result = psys->tse_phy_cfg(pmac);
        }
        else {
        	tse_dprintf(4, "WARNING : MAC Group[%d] - MDIO not enabled! Speed = %s, Duplex = %s\n", mac_group_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
   204ac:	010000b4 	movhi	r4,2
   204b0:	211b7e04 	addi	r4,r4,28152
   204b4:	a00b883a 	mov	r5,r20
   204b8:	018000b4 	movhi	r6,2
   204bc:	319b6204 	addi	r6,r6,28040
   204c0:	01c000b4 	movhi	r7,2
   204c4:	39db6804 	addi	r7,r7,28064
   204c8:	00104380 	call	10438 <printf>
    /* MDIO is not used */
    if (pmac_group->pmac_info[0]->psys_info->tse_use_mdio == 0)
    {
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_MDIO;
   204cc:	04001034 	movhi	r16,64
   204d0:	84000144 	addi	r16,r16,5
   204d4:	003f7306 	br	202a4 <getPHYSpeed+0x298>
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   204d8:	0025883a 	mov	r18,zero
   204dc:	003f0c06 	br	20110 <getPHYSpeed+0x104>
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
        if(pmac_group == pmac_groups[i]) {
   204e0:	0029883a 	mov	r20,zero
   204e4:	003f1606 	br	20140 <getPHYSpeed+0x134>
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
        #endif
       
        /* if PHY not found in profile */
        if(pphy->pphy_profile == 0) {
            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not found in PHY profile\n", mac_group_index, mac_info_index);
   204e8:	94803fcc 	andi	r18,r18,255
   204ec:	9480201c 	xori	r18,r18,128
   204f0:	94bfe004 	addi	r18,r18,-128
   204f4:	010000b4 	movhi	r4,2
   204f8:	211bb504 	addi	r4,r4,28372
   204fc:	a00b883a 	mov	r5,r20
   20500:	900d883a 	mov	r6,r18
   20504:	00104380 	call	10438 <printf>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY_PROFILE;
   20508:	04000134 	movhi	r16,4
   2050c:	84000144 	addi	r16,r16,5
   20510:	003fb506 	br	203e8 <getPHYSpeed+0x3dc>
	        {
	            /* extract connection speed and duplex information */
	        	speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
	            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
				
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
   20514:	14000114 	ori	r16,r2,4
   20518:	0005883a 	mov	r2,zero
   2051c:	003f8206 	br	20328 <getPHYSpeed+0x31c>
   20520:	14000094 	ori	r16,r2,2
   20524:	0005883a 	mov	r2,zero
   20528:	003f7f06 	br	20328 <getPHYSpeed+0x31c>
        /* for simulation purpose, default to gigabit mode */
        speed = 1;
        duplex = 1;
    #endif

    tse_dprintf(5, "INFO    : PHY[%d.%d] - Speed = %s, Duplex = %s\n",  mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
   2052c:	01c000b4 	movhi	r7,2
   20530:	39db6204 	addi	r7,r7,28040
   20534:	003f9006 	br	20378 <getPHYSpeed+0x36c>
	        {
	            /* extract connection speed and duplex information */
	        	speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
	            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
				
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
   20538:	188000e0 	cmpeqi	r2,r3,3
   2053c:	1004943a 	slli	r2,r2,16
   20540:	003f7906 	br	20328 <getPHYSpeed+0x31c>

00020544 <alt_tse_phy_get_common_speed>:
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   20544:	d1a8df03 	ldbu	r6,-23684(gp)
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Internal
 * @param pmac_group    Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_phy_get_common_speed(alt_tse_mac_group *pmac_group) {
   20548:	defff504 	addi	sp,sp,-44
   2054c:	ddc00815 	stw	r23,32(sp)
   20550:	dfc00a15 	stw	ra,40(sp)
   20554:	df000915 	stw	fp,36(sp)
   20558:	dd800715 	stw	r22,28(sp)
   2055c:	dd400615 	stw	r21,24(sp)
   20560:	dd000515 	stw	r20,20(sp)
   20564:	dcc00415 	stw	r19,16(sp)
   20568:	dc800315 	stw	r18,12(sp)
   2056c:	dc400215 	stw	r17,8(sp)
   20570:	dc000115 	stw	r16,4(sp)
   20574:	202f883a 	mov	r23,r4
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   20578:	3000a826 	beq	r6,zero,2081c <alt_tse_phy_get_common_speed+0x2d8>
        if(pmac_group == pmac_groups[i]) {
   2057c:	008001f4 	movhi	r2,7
   20580:	10949d04 	addi	r2,r2,21108
   20584:	11000017 	ldw	r4,0(r2)
   20588:	b900a726 	beq	r23,r4,20828 <alt_tse_phy_get_common_speed+0x2e4>
   2058c:	10800104 	addi	r2,r2,4
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   20590:	000b883a 	mov	r5,zero
   20594:	00000206 	br	205a0 <alt_tse_phy_get_common_speed+0x5c>
        if(pmac_group == pmac_groups[i]) {
   20598:	113fff17 	ldw	r4,-4(r2)
   2059c:	b9008c26 	beq	r23,r4,207d0 <alt_tse_phy_get_common_speed+0x28c>
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   205a0:	29400044 	addi	r5,r5,1
   205a4:	10800104 	addi	r2,r2,4
   205a8:	29bffb16 	blt	r5,r6,20598 <alt_tse_phy_get_common_speed+0x54>
   205ac:	00bfffc4 	movi	r2,-1
   205b0:	d8800015 	stw	r2,0(sp)
    alt_tse_phy_info *pphy = 0;
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
   205b4:	b8800003 	ldbu	r2,0(r23)
   205b8:	10008b26 	beq	r2,zero,207e8 <alt_tse_phy_get_common_speed+0x2a4>
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Internal
 * @param pmac_group    Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_phy_get_common_speed(alt_tse_mac_group *pmac_group) {
   205bc:	bf000104 	addi	fp,r23,4
   205c0:	e025883a 	mov	r18,fp
    alt_tse_phy_info *pphy = 0;
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
   205c4:	0023883a 	mov	r17,zero
        pmac_info = pmac_group->pmac_info[i];
        pphy = pmac_info->pphy_info;
   205c8:	91000017 	ldw	r4,0(r18)
        
        /* run only if PHY connected */
        if(pphy) {
            alt_tse_phy_set_adv_1000(pphy, 1);
   205cc:	01400044 	movi	r5,1
    alt_tse_phy_info *pphy = 0;
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
   205d0:	8963883a 	add	r17,r17,r5
        pmac_info = pmac_group->pmac_info[i];
        pphy = pmac_info->pphy_info;
   205d4:	24000117 	ldw	r16,4(r4)
   205d8:	94800104 	addi	r18,r18,4
        
        /* run only if PHY connected */
        if(pphy) {
            alt_tse_phy_set_adv_1000(pphy, 1);
   205dc:	8009883a 	mov	r4,r16
    for(i = 0; i < pmac_group->channel; i++) {
        pmac_info = pmac_group->pmac_info[i];
        pphy = pmac_info->pphy_info;
        
        /* run only if PHY connected */
        if(pphy) {
   205e0:	80000826 	beq	r16,zero,20604 <alt_tse_phy_get_common_speed+0xc0>
            alt_tse_phy_set_adv_1000(pphy, 1);
   205e4:	001f8200 	call	1f820 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
   205e8:	8009883a 	mov	r4,r16
   205ec:	01400044 	movi	r5,1
   205f0:	001f9600 	call	1f960 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
   205f4:	8009883a 	mov	r4,r16
   205f8:	01400044 	movi	r5,1
   205fc:	001fae80 	call	1fae8 <alt_tse_phy_set_adv_10>
   20600:	b8800003 	ldbu	r2,0(r23)
    alt_tse_phy_info *pphy = 0;
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
   20604:	88bff016 	blt	r17,r2,205c8 <alt_tse_phy_get_common_speed+0x84>
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
   20608:	0080770e 	bge	zero,r2,207e8 <alt_tse_phy_get_common_speed+0x2a4>
   2060c:	04400044 	movi	r17,1
   20610:	8829883a 	mov	r20,r17
   20614:	8827883a 	mov	r19,r17
   20618:	8825883a 	mov	r18,r17
   2061c:	002d883a 	mov	r22,zero
   20620:	00000406 	br	20634 <alt_tse_phy_get_common_speed+0xf0>
   20624:	b8800003 	ldbu	r2,0(r23)
   20628:	b5800044 	addi	r22,r22,1
   2062c:	e7000104 	addi	fp,fp,4
   20630:	b080280e 	bge	r22,r2,206d4 <alt_tse_phy_get_common_speed+0x190>

        pmac_info = pmac_group->pmac_info[i];
   20634:	e5400017 	ldw	r21,0(fp)
        pphy = pmac_info->pphy_info;
   20638:	ac000117 	ldw	r16,4(r21)
            continue;
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
   2063c:	8009883a 	mov	r4,r16

        pmac_info = pmac_group->pmac_info[i];
        pphy = pmac_info->pphy_info;
        
        /* if no PHY connected */
        if(!pphy) {
   20640:	803ff926 	beq	r16,zero,20628 <alt_tse_phy_get_common_speed+0xe4>
            continue;
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
   20644:	001f4d00 	call	1f4d0 <alt_tse_phy_get_cap>
   20648:	103ff61e 	bne	r2,zero,20624 <alt_tse_phy_get_common_speed+0xe0>
        }
        
        none_an_complete = 0;
        
        /* Small MAC */
        if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
   2064c:	a8800003 	ldbu	r2,0(r21)
   20650:	00c00044 	movi	r3,1
   20654:	10c03a26 	beq	r2,r3,20740 <alt_tse_phy_get_common_speed+0x1fc>
            common_1000 = 0;
        }
        else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
   20658:	00c00084 	movi	r3,2
   2065c:	10c04e26 	beq	r2,r3,20798 <alt_tse_phy_get_common_speed+0x254>
   20660:	83400183 	ldbu	r13,6(r16)
   20664:	83c003c3 	ldbu	r15,15(r16)
   20668:	838001c3 	ldbu	r14,7(r16)
   2066c:	82000403 	ldbu	r8,16(r16)
   20670:	83000143 	ldbu	r12,5(r16)
   20674:	81000383 	ldbu	r4,14(r16)
   20678:	81c00283 	ldbu	r7,10(r16)
   2067c:	82c00443 	ldbu	r11,17(r16)
   20680:	828002c3 	ldbu	r10,11(r16)
   20684:	80800483 	ldbu	r2,18(r16)
   20688:	824000c3 	ldbu	r9,3(r16)
   2068c:	81800303 	ldbu	r6,12(r16)
   20690:	7b5a703a 	and	r13,r15,r13
   20694:	4390703a 	and	r8,r8,r14
   20698:	4350b03a 	or	r8,r8,r13
   2069c:	2308703a 	and	r4,r4,r12
   206a0:	59ce703a 	and	r7,r11,r7
   206a4:	1284703a 	and	r2,r2,r10
   206a8:	498c703a 	and	r6,r9,r6
   206ac:	4108b03a 	or	r4,r8,r4
   206b0:	11c4b03a 	or	r2,r2,r7
   206b4:	34a4703a 	and	r18,r6,r18
   206b8:	24e6703a 	and	r19,r4,r19
   206bc:	1528703a 	and	r20,r2,r20
   206c0:	b8800003 	ldbu	r2,0(r23)
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
   206c4:	b5800044 	addi	r22,r22,1
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
            continue;
        }
        
        none_an_complete = 0;
   206c8:	0023883a 	mov	r17,zero
   206cc:	e7000104 	addi	fp,fp,4
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
   206d0:	b0bfd816 	blt	r22,r2,20634 <alt_tse_phy_get_common_speed+0xf0>
                        (pphy->link_capability.cap_10_base_t_half & pphy->link_capability.lp_10_base_tx_half));

    }
    
    /* get common speed based on capabilities */
    if(none_an_complete == 1) {
   206d4:	8c403fcc 	andi	r17,r17,255
   206d8:	04000044 	movi	r16,1
   206dc:	8c004226 	beq	r17,r16,207e8 <alt_tse_phy_get_common_speed+0x2a4>
        common_speed = TSE_PHY_SPEED_NO_COMMON;
        tse_dprintf(2, "ERROR   : MAC Group[%d] - None of the PHYs Auto-Negotiation completed!\n", mac_group_index);
    }
    else if(common_1000) {
   206e0:	94803fcc 	andi	r18,r18,255
   206e4:	9000331e 	bne	r18,zero,207b4 <alt_tse_phy_get_common_speed+0x270>
        common_speed = TSE_PHY_SPEED_1000;
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 1000);
    }
    else if(common_100) {
   206e8:	9cc03fcc 	andi	r19,r19,255
   206ec:	9800441e 	bne	r19,zero,20800 <alt_tse_phy_get_common_speed+0x2bc>
        common_speed = TSE_PHY_SPEED_100;
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 100);
    }
    else if(common_10) {
   206f0:	a5003fcc 	andi	r20,r20,255
   206f4:	a0004e26 	beq	r20,zero,20830 <alt_tse_phy_get_common_speed+0x2ec>
        common_speed = TSE_PHY_SPEED_10;
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 10);
   206f8:	d9400017 	ldw	r5,0(sp)
   206fc:	010000b4 	movhi	r4,2
   20700:	211c2e04 	addi	r4,r4,28856
   20704:	01800284 	movi	r6,10
   20708:	00104380 	call	10438 <printf>
    else if(common_100) {
        common_speed = TSE_PHY_SPEED_100;
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 100);
    }
    else if(common_10) {
        common_speed = TSE_PHY_SPEED_10;
   2070c:	0005883a 	mov	r2,zero
    else {
        common_speed = TSE_PHY_SPEED_NO_COMMON;
        tse_dprintf(2, "ERROR   : MAC Group[%d] - No common speed at all!\n", mac_group_index);    }

    return common_speed;
}
   20710:	dfc00a17 	ldw	ra,40(sp)
   20714:	df000917 	ldw	fp,36(sp)
   20718:	ddc00817 	ldw	r23,32(sp)
   2071c:	dd800717 	ldw	r22,28(sp)
   20720:	dd400617 	ldw	r21,24(sp)
   20724:	dd000517 	ldw	r20,20(sp)
   20728:	dcc00417 	ldw	r19,16(sp)
   2072c:	dc800317 	ldw	r18,12(sp)
   20730:	dc400217 	ldw	r17,8(sp)
   20734:	dc000117 	ldw	r16,4(sp)
   20738:	dec00b04 	addi	sp,sp,44
   2073c:	f800283a 	ret
   20740:	82c00183 	ldbu	r11,6(r16)
   20744:	834003c3 	ldbu	r13,15(r16)
   20748:	830001c3 	ldbu	r12,7(r16)
   2074c:	81c00403 	ldbu	r7,16(r16)
   20750:	82800143 	ldbu	r10,5(r16)
   20754:	81000383 	ldbu	r4,14(r16)
   20758:	81800283 	ldbu	r6,10(r16)
   2075c:	82400443 	ldbu	r9,17(r16)
   20760:	820002c3 	ldbu	r8,11(r16)
   20764:	80800483 	ldbu	r2,18(r16)
   20768:	6ad6703a 	and	r11,r13,r11
   2076c:	3b0e703a 	and	r7,r7,r12
   20770:	3aceb03a 	or	r7,r7,r11
   20774:	2288703a 	and	r4,r4,r10
   20778:	498c703a 	and	r6,r9,r6
   2077c:	1204703a 	and	r2,r2,r8
   20780:	3908b03a 	or	r4,r7,r4
   20784:	1184b03a 	or	r2,r2,r6
   20788:	24e6703a 	and	r19,r4,r19
   2078c:	1528703a 	and	r20,r2,r20
        }
        
        none_an_complete = 0;
        
        /* Small MAC */
        if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
   20790:	0025883a 	mov	r18,zero
   20794:	003fca06 	br	206c0 <alt_tse_phy_get_common_speed+0x17c>
   20798:	808000c3 	ldbu	r2,3(r16)
   2079c:	81000303 	ldbu	r4,12(r16)
            common_1000 = 0;
        }
        else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
   207a0:	0029883a 	mov	r20,zero
   207a4:	0027883a 	mov	r19,zero
   207a8:	2084703a 	and	r2,r4,r2
   207ac:	14a4703a 	and	r18,r2,r18
   207b0:	003fc306 	br	206c0 <alt_tse_phy_get_common_speed+0x17c>
        common_speed = TSE_PHY_SPEED_NO_COMMON;
        tse_dprintf(2, "ERROR   : MAC Group[%d] - None of the PHYs Auto-Negotiation completed!\n", mac_group_index);
    }
    else if(common_1000) {
        common_speed = TSE_PHY_SPEED_1000;
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 1000);
   207b4:	d9400017 	ldw	r5,0(sp)
   207b8:	010000b4 	movhi	r4,2
   207bc:	211c2e04 	addi	r4,r4,28856
   207c0:	0180fa04 	movi	r6,1000
   207c4:	00104380 	call	10438 <printf>
    if(none_an_complete == 1) {
        common_speed = TSE_PHY_SPEED_NO_COMMON;
        tse_dprintf(2, "ERROR   : MAC Group[%d] - None of the PHYs Auto-Negotiation completed!\n", mac_group_index);
    }
    else if(common_1000) {
        common_speed = TSE_PHY_SPEED_1000;
   207c8:	00800084 	movi	r2,2
   207cc:	003fd006 	br	20710 <alt_tse_phy_get_common_speed+0x1cc>
   207d0:	29403fcc 	andi	r5,r5,255
   207d4:	2940201c 	xori	r5,r5,128
    alt_tse_phy_info *pphy = 0;
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
   207d8:	b8800003 	ldbu	r2,0(r23)
   207dc:	297fe004 	addi	r5,r5,-128
   207e0:	d9400015 	stw	r5,0(sp)
   207e4:	103f751e 	bne	r2,zero,205bc <alt_tse_phy_get_common_speed+0x78>
    }
    
    /* get common speed based on capabilities */
    if(none_an_complete == 1) {
        common_speed = TSE_PHY_SPEED_NO_COMMON;
        tse_dprintf(2, "ERROR   : MAC Group[%d] - None of the PHYs Auto-Negotiation completed!\n", mac_group_index);
   207e8:	d9400017 	ldw	r5,0(sp)
   207ec:	010000b4 	movhi	r4,2
   207f0:	211c1c04 	addi	r4,r4,28784
   207f4:	00104380 	call	10438 <printf>

    }
    
    /* get common speed based on capabilities */
    if(none_an_complete == 1) {
        common_speed = TSE_PHY_SPEED_NO_COMMON;
   207f8:	00bfffc4 	movi	r2,-1
   207fc:	003fc406 	br	20710 <alt_tse_phy_get_common_speed+0x1cc>
        common_speed = TSE_PHY_SPEED_1000;
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 1000);
    }
    else if(common_100) {
        common_speed = TSE_PHY_SPEED_100;
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 100);
   20800:	d9400017 	ldw	r5,0(sp)
   20804:	010000b4 	movhi	r4,2
   20808:	211c2e04 	addi	r4,r4,28856
   2080c:	01801904 	movi	r6,100
   20810:	00104380 	call	10438 <printf>
    else if(common_1000) {
        common_speed = TSE_PHY_SPEED_1000;
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 1000);
    }
    else if(common_100) {
        common_speed = TSE_PHY_SPEED_100;
   20814:	8005883a 	mov	r2,r16
   20818:	003fbd06 	br	20710 <alt_tse_phy_get_common_speed+0x1cc>
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   2081c:	00ffffc4 	movi	r3,-1
   20820:	d8c00015 	stw	r3,0(sp)
   20824:	003f6306 	br	205b4 <alt_tse_phy_get_common_speed+0x70>
        if(pmac_group == pmac_groups[i]) {
   20828:	d8000015 	stw	zero,0(sp)
   2082c:	003f6106 	br	205b4 <alt_tse_phy_get_common_speed+0x70>
        common_speed = TSE_PHY_SPEED_10;
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 10);
    }
    else {
        common_speed = TSE_PHY_SPEED_NO_COMMON;
        tse_dprintf(2, "ERROR   : MAC Group[%d] - No common speed at all!\n", mac_group_index);    }
   20830:	d9400017 	ldw	r5,0(sp)
   20834:	010000b4 	movhi	r4,2
   20838:	211c3b04 	addi	r4,r4,28908
   2083c:	00104380 	call	10438 <printf>
    else if(common_10) {
        common_speed = TSE_PHY_SPEED_10;
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 10);
    }
    else {
        common_speed = TSE_PHY_SPEED_NO_COMMON;
   20840:	00bfffc4 	movi	r2,-1
   20844:	003fb206 	br	20710 <alt_tse_phy_get_common_speed+0x1cc>

00020848 <alt_tse_mac_get_common_speed>:
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
   20848:	d2a8df03 	ldbu	r10,-23684(gp)
   2084c:	50001726 	beq	r10,zero,208ac <alt_tse_mac_get_common_speed+0x64>
   20850:	020001f4 	movhi	r8,7
   20854:	42149d04 	addi	r8,r8,21108
   20858:	0013883a 	mov	r9,zero
        pmac_group = pmac_groups[i];
   2085c:	40c00017 	ldw	r3,0(r8)
        for(j = 0; j < pmac_group->channel; j++) {
   20860:	19c00003 	ldbu	r7,0(r3)
   20864:	38000e26 	beq	r7,zero,208a0 <alt_tse_mac_get_common_speed+0x58>
            pmac_info = pmac_group->pmac_info[j];
   20868:	19400117 	ldw	r5,4(r3)
            if(((np_tse_mac *) pmac_info->psys_info->tse_mac_base) == pmac) {
   2086c:	28800217 	ldw	r2,8(r5)
   20870:	10800017 	ldw	r2,0(r2)
   20874:	20800e26 	beq	r4,r2,208b0 <alt_tse_mac_get_common_speed+0x68>
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Public
 * @param pmac          Pointer to the TSE MAC Control Interface Base address
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_mac_get_common_speed(np_tse_mac *pmac) {
   20878:	18c00204 	addi	r3,r3,8
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
        pmac_group = pmac_groups[i];
        for(j = 0; j < pmac_group->channel; j++) {
   2087c:	0005883a 	mov	r2,zero
   20880:	00000506 	br	20898 <alt_tse_mac_get_common_speed+0x50>
            pmac_info = pmac_group->pmac_info[j];
   20884:	19400017 	ldw	r5,0(r3)
   20888:	18c00104 	addi	r3,r3,4
            if(((np_tse_mac *) pmac_info->psys_info->tse_mac_base) == pmac) {
   2088c:	29800217 	ldw	r6,8(r5)
   20890:	31800017 	ldw	r6,0(r6)
   20894:	21800626 	beq	r4,r6,208b0 <alt_tse_mac_get_common_speed+0x68>
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
        pmac_group = pmac_groups[i];
        for(j = 0; j < pmac_group->channel; j++) {
   20898:	10800044 	addi	r2,r2,1
   2089c:	11fff916 	blt	r2,r7,20884 <alt_tse_mac_get_common_speed+0x3c>
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
   208a0:	4a400044 	addi	r9,r9,1
   208a4:	42000104 	addi	r8,r8,4
   208a8:	4abfec16 	blt	r9,r10,2085c <alt_tse_mac_get_common_speed+0x14>
                return pmac_info;
            }
        }        
    }
    
    return 0;
   208ac:	000b883a 	mov	r5,zero
 * @param pmac          Pointer to the TSE MAC Control Interface Base address
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_mac_get_common_speed(np_tse_mac *pmac) {
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
    return alt_tse_phy_get_common_speed(pmac_group);
   208b0:	29000317 	ldw	r4,12(r5)
   208b4:	00205441 	jmpi	20544 <alt_tse_phy_get_common_speed>

000208b8 <alt_tse_phy_set_common_speed>:
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   208b8:	d1a8df03 	ldbu	r6,-23684(gp)
 * @API Type:               Internal
 * @param pmac_group        Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 *        common_speed      common speed supported by all PHYs
 * @return      common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_phy_set_common_speed(alt_tse_mac_group *pmac_group, alt_32 common_speed) {
   208bc:	defff004 	addi	sp,sp,-64
   208c0:	dcc00915 	stw	r19,36(sp)
   208c4:	dc800815 	stw	r18,32(sp)
   208c8:	dfc00f15 	stw	ra,60(sp)
   208cc:	df000e15 	stw	fp,56(sp)
   208d0:	ddc00d15 	stw	r23,52(sp)
   208d4:	dd800c15 	stw	r22,48(sp)
   208d8:	dd400b15 	stw	r21,44(sp)
   208dc:	dd000a15 	stw	r20,40(sp)
   208e0:	dc400715 	stw	r17,28(sp)
   208e4:	dc000615 	stw	r16,24(sp)
   208e8:	2025883a 	mov	r18,r4
   208ec:	2827883a 	mov	r19,r5
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   208f0:	30011726 	beq	r6,zero,20d50 <alt_tse_phy_set_common_speed+0x498>
        if(pmac_group == pmac_groups[i]) {
   208f4:	008001f4 	movhi	r2,7
   208f8:	10949d04 	addi	r2,r2,21108
   208fc:	10c00017 	ldw	r3,0(r2)
   20900:	20c11626 	beq	r4,r3,20d5c <alt_tse_phy_set_common_speed+0x4a4>
   20904:	10800104 	addi	r2,r2,4
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   20908:	002f883a 	mov	r23,zero
   2090c:	00000206 	br	20918 <alt_tse_phy_set_common_speed+0x60>
        if(pmac_group == pmac_groups[i]) {
   20910:	10ffff17 	ldw	r3,-4(r2)
   20914:	90c0e726 	beq	r18,r3,20cb4 <alt_tse_phy_set_common_speed+0x3fc>
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   20918:	bdc00044 	addi	r23,r23,1
   2091c:	10800104 	addi	r2,r2,4
   20920:	b9bffb16 	blt	r23,r6,20910 <alt_tse_phy_set_common_speed+0x58>
   20924:	00bfffc4 	movi	r2,-1
   20928:	d8800115 	stw	r2,4(sp)
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
         
    /* Record previous MDIO address, to be restored at the end of function */
    np_tse_mac *pmac_group_base = (np_tse_mac *)pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   2092c:	90800117 	ldw	r2,4(r18)
   20930:	10800217 	ldw	r2,8(r2)
   20934:	10800017 	ldw	r2,0(r2)
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
   20938:	10c01004 	addi	r3,r2,64
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
         
    /* Record previous MDIO address, to be restored at the end of function */
    np_tse_mac *pmac_group_base = (np_tse_mac *)pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   2093c:	d8800315 	stw	r2,12(sp)
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
   20940:	d8c00215 	stw	r3,8(sp)
   20944:	18c00037 	ldwio	r3,0(r3)
    
    if((common_speed < TSE_PHY_SPEED_10) || (common_speed > TSE_PHY_SPEED_1000)) {
   20948:	00800084 	movi	r2,2
    alt_8 mac_info_index = 0;
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
         
    /* Record previous MDIO address, to be restored at the end of function */
    np_tse_mac *pmac_group_base = (np_tse_mac *)pmac_group->pmac_info[0]->psys_info->tse_mac_base;
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
   2094c:	d8c00515 	stw	r3,20(sp)
    
    if((common_speed < TSE_PHY_SPEED_10) || (common_speed > TSE_PHY_SPEED_1000)) {
   20950:	14c10436 	bltu	r2,r19,20d64 <alt_tse_phy_set_common_speed+0x4ac>
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
        return TSE_PHY_SPEED_NO_COMMON;
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
   20954:	91800003 	ldbu	r6,0(r18)
   20958:	30005126 	beq	r6,zero,20aa0 <alt_tse_phy_set_common_speed+0x1e8>
        /* if PHY is not Auto-Negotiation capable */
        if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
            
            /* if PHY supports 1000 Mbps, write msb of speed */
            if(gb_capable) {
                alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_MSB, 1, common_speed >> 1);
   2095c:	9807d07a 	srai	r3,r19,1
 * @API Type:               Internal
 * @param pmac_group        Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 *        common_speed      common speed supported by all PHYs
 * @return      common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_phy_set_common_speed(alt_tse_mac_group *pmac_group, alt_32 common_speed) {
   20960:	94000104 	addi	r16,r18,4
   20964:	0023883a 	mov	r17,zero
        /* if PHY is not Auto-Negotiation capable */
        if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
            
            /* if PHY supports 1000 Mbps, write msb of speed */
            if(gb_capable) {
                alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_MSB, 1, common_speed >> 1);
   20968:	d8c00415 	stw	r3,16(sp)
			IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
            return TSE_PHY_SPEED_NO_COMMON;
        }
        
        /* if PHY is not Auto-Negotiation capable */
        if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
   2096c:	05400044 	movi	r21,1
        return TSE_PHY_SPEED_NO_COMMON;
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
        pmac_info = pmac_group->pmac_info[i];
   20970:	81400017 	ldw	r5,0(r16)
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   20974:	28800317 	ldw	r2,12(r5)
   20978:	11000003 	ldbu	r4,0(r2)
   2097c:	20000a26 	beq	r4,zero,209a8 <alt_tse_phy_set_common_speed+0xf0>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   20980:	10c00117 	ldw	r3,4(r2)
   20984:	28c0c926 	beq	r5,r3,20cac <alt_tse_phy_set_common_speed+0x3f4>
 * @API Type:               Internal
 * @param pmac_group        Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 *        common_speed      common speed supported by all PHYs
 * @return      common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_phy_set_common_speed(alt_tse_mac_group *pmac_group, alt_32 common_speed) {
   20988:	10800204 	addi	r2,r2,8
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   2098c:	0029883a 	mov	r20,zero
   20990:	00000206 	br	2099c <alt_tse_phy_set_common_speed+0xe4>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   20994:	10ffff17 	ldw	r3,-4(r2)
   20998:	28c00426 	beq	r5,r3,209ac <alt_tse_phy_set_common_speed+0xf4>
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   2099c:	a5000044 	addi	r20,r20,1
   209a0:	10800104 	addi	r2,r2,4
   209a4:	a13ffb16 	blt	r20,r4,20994 <alt_tse_phy_set_common_speed+0xdc>
   209a8:	053fffc4 	movi	r20,-1
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
        pmac_info = pmac_group->pmac_info[i];
        mac_info_index = alt_tse_get_mac_info_index(pmac_info);

        pphy = pmac_info->pphy_info;
   209ac:	2dc00117 	ldw	r23,4(r5)
        
        /* if no PHY connected */
        if(!pphy) {
   209b0:	b8003826 	beq	r23,zero,20a94 <alt_tse_phy_set_common_speed+0x1dc>
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   209b4:	b8800617 	ldw	r2,24(r23)
        /* if no PHY connected */
        if(!pphy) {
            continue;
        }
        
        psys = pmac_info->psys_info; 
   209b8:	2d800217 	ldw	r22,8(r5)
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
   209bc:	b9000003 	ldbu	r4,0(r23)
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   209c0:	10800317 	ldw	r2,12(r2)
   209c4:	10800117 	ldw	r2,4(r2)
   209c8:	10800217 	ldw	r2,8(r2)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
   209cc:	10800017 	ldw	r2,0(r2)
   209d0:	11001035 	stwio	r4,64(r2)
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
   209d4:	b88000c3 	ldbu	r2,3(r23)
   209d8:	1000511e 	bne	r2,zero,20b20 <alt_tse_phy_set_common_speed+0x268>
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
   209dc:	b8800103 	ldbu	r2,4(r23)
   209e0:	10004f1e 	bne	r2,zero,20b20 <alt_tse_phy_set_common_speed+0x268>
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
   209e4:	b8800017 	ldw	r2,0(r23)
   209e8:	00c04034 	movhi	r3,256
   209ec:	18ffc004 	addi	r3,r3,-256
   209f0:	10c4703a 	and	r2,r2,r3
   209f4:	10004a1e 	bne	r2,zero,20b20 <alt_tse_phy_set_common_speed+0x268>
        
        /* if PHY does not supports 1000 Mbps, and common speed is 1000 Mbps */
        if((!gb_capable) && (common_speed == TSE_PHY_SPEED_1000)) {
   209f8:	00800084 	movi	r2,2
   209fc:	9880b226 	beq	r19,r2,20cc8 <alt_tse_phy_set_common_speed+0x410>
			IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
            return TSE_PHY_SPEED_NO_COMMON;
        }
        
        /* if PHY is not Auto-Negotiation capable */
        if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
   20a00:	01400044 	movi	r5,1
   20a04:	b809883a 	mov	r4,r23
   20a08:	018000c4 	movi	r6,3
   20a0c:	280f883a 	mov	r7,r5
   20a10:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
   20a14:	10004f26 	beq	r2,zero,20b54 <alt_tse_phy_set_common_speed+0x29c>
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
   20a18:	0039883a 	mov	fp,zero
        if(common_speed == TSE_PHY_SPEED_1000) {
            alt_tse_phy_set_adv_1000(pphy, 1);
            alt_tse_phy_set_adv_100(pphy, 1);
            alt_tse_phy_set_adv_10(pphy, 1);
        }
        else if(common_speed == TSE_PHY_SPEED_100) {
   20a1c:	9d405c26 	beq	r19,r21,20b90 <alt_tse_phy_set_common_speed+0x2d8>
            alt_tse_phy_set_adv_1000(pphy, 0);
            alt_tse_phy_set_adv_100(pphy, 1);
            alt_tse_phy_set_adv_10(pphy, 1);
        }    
        else if(common_speed == TSE_PHY_SPEED_10) {
            alt_tse_phy_set_adv_1000(pphy, 0);
   20a20:	000b883a 	mov	r5,zero
   20a24:	b809883a 	mov	r4,r23
   20a28:	001f8200 	call	1f820 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
   20a2c:	b809883a 	mov	r4,r23
   20a30:	000b883a 	mov	r5,zero
   20a34:	001f9600 	call	1f960 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
   20a38:	b809883a 	mov	r4,r23
   20a3c:	01400044 	movi	r5,1
   20a40:	001fae80 	call	1fae8 <alt_tse_phy_set_adv_10>
            alt_tse_phy_set_adv_100(pphy, 0);
            alt_tse_phy_set_adv_10(pphy, 0);
        }
        
        /* if PHY Auto-Negotiation is completed */
        if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 1) {
   20a44:	01400044 	movi	r5,1
   20a48:	b809883a 	mov	r4,r23
   20a4c:	01800144 	movi	r6,5
   20a50:	280f883a 	mov	r7,r5
   20a54:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
   20a58:	15405c26 	beq	r2,r21,20bcc <alt_tse_phy_set_common_speed+0x314>
            
            /* Set MAC duplex register */
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
   20a5c:	b809883a 	mov	r4,r23
   20a60:	01400044 	movi	r5,1
   20a64:	000d883a 	mov	r6,zero
   20a68:	01c00404 	movi	r7,16
   20a6c:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
   20a70:	d9400117 	ldw	r5,4(sp)
   20a74:	a1803fcc 	andi	r6,r20,255
   20a78:	3180201c 	xori	r6,r6,128
   20a7c:	31bfe004 	addi	r6,r6,-128
   20a80:	010000b4 	movhi	r4,2
   20a84:	211c7304 	addi	r4,r4,29132
   20a88:	100f883a 	mov	r7,r2
   20a8c:	00104380 	call	10438 <printf>
   20a90:	91800003 	ldbu	r6,0(r18)
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
        return TSE_PHY_SPEED_NO_COMMON;
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
   20a94:	8c400044 	addi	r17,r17,1
   20a98:	84000104 	addi	r16,r16,4
   20a9c:	89bfb416 	blt	r17,r6,20970 <alt_tse_phy_set_common_speed+0xb8>
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
    }
    tse_dprintf(5, "INFO    : MAC Group[%d] - All PHYs set to common speed : %d Mbps\n", mac_group_index, (common_speed == TSE_PHY_SPEED_1000) ? 1000 : ((common_speed == TSE_PHY_SPEED_100) ? 100 : 10));
   20aa0:	00800084 	movi	r2,2
   20aa4:	98809426 	beq	r19,r2,20cf8 <alt_tse_phy_set_common_speed+0x440>
   20aa8:	00800044 	movi	r2,1
   20aac:	010000b4 	movhi	r4,2
   20ab0:	211c7f04 	addi	r4,r4,29180
   20ab4:	d9400117 	ldw	r5,4(sp)
   20ab8:	98809c26 	beq	r19,r2,20d2c <alt_tse_phy_set_common_speed+0x474>
   20abc:	01800284 	movi	r6,10
   20ac0:	00104380 	call	10438 <printf>
 */
alt_32 alt_tse_mac_set_speed(np_tse_mac *pmac, alt_u8 speed)
{
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
   20ac4:	d8c00317 	ldw	r3,12(sp)
   20ac8:	18800204 	addi	r2,r3,8
   20acc:	11000037 	ldwio	r4,0(r2)
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
  }
  /* 10 Mbps */
  else if(speed == TSE_PHY_SPEED_10) {
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
   20ad0:	00fffdc4 	movi	r3,-9
   20ad4:	20c6703a 	and	r3,r4,r3
	helpvar |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
   20ad8:	18c08034 	orhi	r3,r3,512
  }  
  else {
    return ENP_PARAM;
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
   20adc:	10c00035 	stwio	r3,0(r2)

    /* Set MAC speed register */
    alt_tse_mac_set_speed(pmac_group_base, common_speed);
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
   20ae0:	d8800517 	ldw	r2,20(sp)
   20ae4:	d8c00217 	ldw	r3,8(sp)
   20ae8:	18800035 	stwio	r2,0(r3)
        
    return common_speed;
}
   20aec:	9805883a 	mov	r2,r19
   20af0:	dfc00f17 	ldw	ra,60(sp)
   20af4:	df000e17 	ldw	fp,56(sp)
   20af8:	ddc00d17 	ldw	r23,52(sp)
   20afc:	dd800c17 	ldw	r22,48(sp)
   20b00:	dd400b17 	ldw	r21,44(sp)
   20b04:	dd000a17 	ldw	r20,40(sp)
   20b08:	dcc00917 	ldw	r19,36(sp)
   20b0c:	dc800817 	ldw	r18,32(sp)
   20b10:	dc400717 	ldw	r17,28(sp)
   20b14:	dc000617 	ldw	r16,24(sp)
   20b18:	dec01004 	addi	sp,sp,64
   20b1c:	f800283a 	ret
			IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
            return TSE_PHY_SPEED_NO_COMMON;
        }
        
        /* if PHY is not Auto-Negotiation capable */
        if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
   20b20:	01400044 	movi	r5,1
   20b24:	b809883a 	mov	r4,r23
   20b28:	018000c4 	movi	r6,3
   20b2c:	280f883a 	mov	r7,r5
   20b30:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
   20b34:	1000121e 	bne	r2,zero,20b80 <alt_tse_phy_set_common_speed+0x2c8>
            
            /* if PHY supports 1000 Mbps, write msb of speed */
            if(gb_capable) {
                alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_MSB, 1, common_speed >> 1);
   20b38:	d8c00417 	ldw	r3,16(sp)
   20b3c:	b809883a 	mov	r4,r23
   20b40:	000b883a 	mov	r5,zero
   20b44:	d8c00015 	stw	r3,0(sp)
   20b48:	01800184 	movi	r6,6
   20b4c:	01c00044 	movi	r7,1
   20b50:	001e7a40 	call	1e7a4 <alt_tse_phy_wr_mdio_reg>
            }
            /* write lsb of speed */
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_LSB, 1, common_speed);
   20b54:	01800344 	movi	r6,13
   20b58:	dcc00015 	stw	r19,0(sp)
   20b5c:	b809883a 	mov	r4,r23
   20b60:	000b883a 	mov	r5,zero
   20b64:	01c00044 	movi	r7,1
   20b68:	001e7a40 	call	1e7a4 <alt_tse_phy_wr_mdio_reg>
   20b6c:	91800003 	ldbu	r6,0(r18)
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
        return TSE_PHY_SPEED_NO_COMMON;
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
   20b70:	8c400044 	addi	r17,r17,1
   20b74:	84000104 	addi	r16,r16,4
   20b78:	89bf7d16 	blt	r17,r6,20970 <alt_tse_phy_set_common_speed+0xb8>
   20b7c:	003fc806 	br	20aa0 <alt_tse_phy_set_common_speed+0x1e8>
            /* continue to next PHY */
            continue;
        }
        
        /* set Auto-Negotiation advertisement based on common speed */
        if(common_speed == TSE_PHY_SPEED_1000) {
   20b80:	00800084 	movi	r2,2
   20b84:	98803926 	beq	r19,r2,20c6c <alt_tse_phy_set_common_speed+0x3b4>
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
   20b88:	07000044 	movi	fp,1
        if(common_speed == TSE_PHY_SPEED_1000) {
            alt_tse_phy_set_adv_1000(pphy, 1);
            alt_tse_phy_set_adv_100(pphy, 1);
            alt_tse_phy_set_adv_10(pphy, 1);
        }
        else if(common_speed == TSE_PHY_SPEED_100) {
   20b8c:	9d7fa41e 	bne	r19,r21,20a20 <alt_tse_phy_set_common_speed+0x168>
            alt_tse_phy_set_adv_1000(pphy, 0);
   20b90:	b809883a 	mov	r4,r23
   20b94:	000b883a 	mov	r5,zero
   20b98:	001f8200 	call	1f820 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
   20b9c:	b809883a 	mov	r4,r23
   20ba0:	980b883a 	mov	r5,r19
   20ba4:	001f9600 	call	1f960 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
   20ba8:	b809883a 	mov	r4,r23
   20bac:	980b883a 	mov	r5,r19
   20bb0:	001fae80 	call	1fae8 <alt_tse_phy_set_adv_10>
            alt_tse_phy_set_adv_100(pphy, 0);
            alt_tse_phy_set_adv_10(pphy, 0);
        }
        
        /* if PHY Auto-Negotiation is completed */
        if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 1) {
   20bb4:	01400044 	movi	r5,1
   20bb8:	b809883a 	mov	r4,r23
   20bbc:	01800144 	movi	r6,5
   20bc0:	280f883a 	mov	r7,r5
   20bc4:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
   20bc8:	157fa41e 	bne	r2,r21,20a5c <alt_tse_phy_set_common_speed+0x1a4>
            
            /* read both msb and lsb of speed bits if PHY support 1000 Mbps */
            if(gb_capable) {
   20bcc:	e7003fcc 	andi	fp,fp,255
   20bd0:	e0001f26 	beq	fp,zero,20c50 <alt_tse_phy_set_common_speed+0x398>
        
                /* get speed information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
   20bd4:	b8800517 	ldw	r2,20(r23)
   20bd8:	b809883a 	mov	r4,r23
   20bdc:	01c00084 	movi	r7,2
   20be0:	11401583 	ldbu	r5,86(r2)
   20be4:	118015c3 	ldbu	r6,87(r2)
   20be8:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
                /* get speed and link information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 1);
            }
            
            /* if current speed != common speed, then restart Auto-Negotiation */
            if(speed != common_speed) {
   20bec:	10803fcc 	andi	r2,r2,255
   20bf0:	14c00426 	beq	r2,r19,20c04 <alt_tse_phy_set_common_speed+0x34c>
                alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
   20bf4:	b809883a 	mov	r4,r23
   20bf8:	01400134 	movhi	r5,4
   20bfc:	29742404 	addi	r5,r5,-12144
   20c00:	001f0a00 	call	1f0a0 <alt_tse_phy_restart_an>
            }
            
            /* get speed information after Auto-Negotiation */
            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
   20c04:	b8800517 	ldw	r2,20(r23)
   20c08:	b809883a 	mov	r4,r23
   20c0c:	01c00044 	movi	r7,1
   20c10:	11401583 	ldbu	r5,86(r2)
   20c14:	11801603 	ldbu	r6,88(r2)
   20c18:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
 */
alt_32 alt_tse_mac_set_duplex(np_tse_mac *pmac, alt_u8 duplex)
{
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
   20c1c:	b1000017 	ldw	r4,0(r22)
   20c20:	21000204 	addi	r4,r4,8
   20c24:	21400037 	ldwio	r5,0(r4)
  
  /* Half Duplex */
  if(duplex == TSE_PHY_DUPLEX_HALF) {
   20c28:	10803fcc 	andi	r2,r2,255
   20c2c:	1000031e 	bne	r2,zero,20c3c <alt_tse_phy_set_common_speed+0x384>
    helpvar |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
   20c30:	29410014 	ori	r5,r5,1024
  }
  else {
    return ENP_PARAM;
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
   20c34:	21400035 	stwio	r5,0(r4)
   20c38:	003f8806 	br	20a5c <alt_tse_phy_set_common_speed+0x1a4>
  /* Half Duplex */
  if(duplex == TSE_PHY_DUPLEX_HALF) {
    helpvar |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
  } 
  /* Full Duplex */
  else if(duplex == TSE_PHY_DUPLEX_FULL) {
   20c3c:	157f871e 	bne	r2,r21,20a5c <alt_tse_phy_set_common_speed+0x1a4>
    helpvar &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
   20c40:	00beffc4 	movi	r2,-1025
   20c44:	288a703a 	and	r5,r5,r2
  }
  else {
    return ENP_PARAM;
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
   20c48:	21400035 	stwio	r5,0(r4)
   20c4c:	003f8306 	br	20a5c <alt_tse_phy_set_common_speed+0x1a4>
            }
            
            /* read lsb of speed only if PHY support only 10/100 Mbps */
            else {
                /* get speed and link information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 1);
   20c50:	b8800517 	ldw	r2,20(r23)
   20c54:	b809883a 	mov	r4,r23
   20c58:	a80f883a 	mov	r7,r21
   20c5c:	11401583 	ldbu	r5,86(r2)
   20c60:	118015c3 	ldbu	r6,87(r2)
   20c64:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
   20c68:	003fe006 	br	20bec <alt_tse_phy_set_common_speed+0x334>
            continue;
        }
        
        /* set Auto-Negotiation advertisement based on common speed */
        if(common_speed == TSE_PHY_SPEED_1000) {
            alt_tse_phy_set_adv_1000(pphy, 1);
   20c6c:	01400044 	movi	r5,1
   20c70:	b809883a 	mov	r4,r23
   20c74:	001f8200 	call	1f820 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
   20c78:	b809883a 	mov	r4,r23
   20c7c:	01400044 	movi	r5,1
   20c80:	001f9600 	call	1f960 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
   20c84:	b809883a 	mov	r4,r23
   20c88:	01400044 	movi	r5,1
   20c8c:	001fae80 	call	1fae8 <alt_tse_phy_set_adv_10>
            alt_tse_phy_set_adv_100(pphy, 0);
            alt_tse_phy_set_adv_10(pphy, 0);
        }
        
        /* if PHY Auto-Negotiation is completed */
        if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 1) {
   20c90:	01400044 	movi	r5,1
   20c94:	b809883a 	mov	r4,r23
   20c98:	01800144 	movi	r6,5
   20c9c:	280f883a 	mov	r7,r5
   20ca0:	001e8340 	call	1e834 <alt_tse_phy_rd_mdio_reg>
   20ca4:	157f6d1e 	bne	r2,r21,20a5c <alt_tse_phy_set_common_speed+0x1a4>
   20ca8:	003fca06 	br	20bd4 <alt_tse_phy_set_common_speed+0x31c>
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   20cac:	0029883a 	mov	r20,zero
   20cb0:	003f3e06 	br	209ac <alt_tse_phy_set_common_speed+0xf4>
   20cb4:	bdc03fcc 	andi	r23,r23,255
   20cb8:	bdc0201c 	xori	r23,r23,128
   20cbc:	bdffe004 	addi	r23,r23,-128
   20cc0:	ddc00115 	stw	r23,4(sp)
   20cc4:	003f1906 	br	2092c <alt_tse_phy_set_common_speed+0x74>
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
        
        /* if PHY does not supports 1000 Mbps, and common speed is 1000 Mbps */
        if((!gb_capable) && (common_speed == TSE_PHY_SPEED_1000)) {
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - PHY does not support 1000 Mbps, please specify valid common speed\n", mac_group_index, mac_info_index);
   20cc8:	a1803fcc 	andi	r6,r20,255
   20ccc:	d9400117 	ldw	r5,4(sp)
   20cd0:	3180201c 	xori	r6,r6,128
   20cd4:	010000b4 	movhi	r4,2
   20cd8:	211c5c04 	addi	r4,r4,29040
   20cdc:	31bfe004 	addi	r6,r6,-128
   20ce0:	00104380 	call	10438 <printf>
			/* Restore previous MDIO address */
			IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
   20ce4:	d8800517 	ldw	r2,20(sp)
   20ce8:	d8c00217 	ldw	r3,8(sp)
   20cec:	18800035 	stwio	r2,0(r3)
            return TSE_PHY_SPEED_NO_COMMON;
   20cf0:	04ffffc4 	movi	r19,-1
   20cf4:	003f7d06 	br	20aec <alt_tse_phy_set_common_speed+0x234>
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
    }
    tse_dprintf(5, "INFO    : MAC Group[%d] - All PHYs set to common speed : %d Mbps\n", mac_group_index, (common_speed == TSE_PHY_SPEED_1000) ? 1000 : ((common_speed == TSE_PHY_SPEED_100) ? 100 : 10));
   20cf8:	d9400117 	ldw	r5,4(sp)
   20cfc:	010000b4 	movhi	r4,2
   20d00:	211c7f04 	addi	r4,r4,29180
   20d04:	0180fa04 	movi	r6,1000
   20d08:	00104380 	call	10438 <printf>
 */
alt_32 alt_tse_mac_set_speed(np_tse_mac *pmac, alt_u8 speed)
{
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
   20d0c:	d8c00317 	ldw	r3,12(sp)
   20d10:	18800204 	addi	r2,r3,8
   20d14:	11000037 	ldwio	r4,0(r2)
  
  /* 1000 Mbps */
  if(speed == TSE_PHY_SPEED_1000) {
    helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
   20d18:	00ff8034 	movhi	r3,65024
   20d1c:	18ffffc4 	addi	r3,r3,-1
   20d20:	20c6703a 	and	r3,r4,r3
   20d24:	18c00214 	ori	r3,r3,8
   20d28:	003f6c06 	br	20adc <alt_tse_phy_set_common_speed+0x224>
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
    }
    tse_dprintf(5, "INFO    : MAC Group[%d] - All PHYs set to common speed : %d Mbps\n", mac_group_index, (common_speed == TSE_PHY_SPEED_1000) ? 1000 : ((common_speed == TSE_PHY_SPEED_100) ? 100 : 10));
   20d2c:	01801904 	movi	r6,100
   20d30:	00104380 	call	10438 <printf>
 */
alt_32 alt_tse_mac_set_speed(np_tse_mac *pmac, alt_u8 speed)
{
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
   20d34:	d8c00317 	ldw	r3,12(sp)
   20d38:	18800204 	addi	r2,r3,8
   20d3c:	11000037 	ldwio	r4,0(r2)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
  }
  /* 100 Mbps */
  else if(speed == TSE_PHY_SPEED_100) {
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
   20d40:	00ff8034 	movhi	r3,65024
   20d44:	18fffdc4 	addi	r3,r3,-9
   20d48:	20c6703a 	and	r3,r4,r3
   20d4c:	003f6306 	br	20adc <alt_tse_phy_set_common_speed+0x224>
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   20d50:	00ffffc4 	movi	r3,-1
   20d54:	d8c00115 	stw	r3,4(sp)
   20d58:	003ef406 	br	2092c <alt_tse_phy_set_common_speed+0x74>
        if(pmac_group == pmac_groups[i]) {
   20d5c:	d8000115 	stw	zero,4(sp)
   20d60:	003ef206 	br	2092c <alt_tse_phy_set_common_speed+0x74>
    /* Record previous MDIO address, to be restored at the end of function */
    np_tse_mac *pmac_group_base = (np_tse_mac *)pmac_group->pmac_info[0]->psys_info->tse_mac_base;
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
    
    if((common_speed < TSE_PHY_SPEED_10) || (common_speed > TSE_PHY_SPEED_1000)) {
        tse_dprintf(2, "ERROR   : MAC Group[%d] - Invalid common speed specified! common speed = %d\n", mac_group_index, (int)common_speed);
   20d64:	010000b4 	movhi	r4,2
   20d68:	211c4804 	addi	r4,r4,28960
   20d6c:	d9400117 	ldw	r5,4(sp)
   20d70:	980d883a 	mov	r6,r19
   20d74:	003fda06 	br	20ce0 <alt_tse_phy_set_common_speed+0x428>

00020d78 <alt_tse_mac_set_common_speed>:
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
   20d78:	d2e8df03 	ldbu	r11,-23684(gp)
   20d7c:	58001726 	beq	r11,zero,20ddc <alt_tse_mac_set_common_speed+0x64>
   20d80:	024001f4 	movhi	r9,7
   20d84:	4a549d04 	addi	r9,r9,21108
   20d88:	0015883a 	mov	r10,zero
        pmac_group = pmac_groups[i];
   20d8c:	48c00017 	ldw	r3,0(r9)
        for(j = 0; j < pmac_group->channel; j++) {
   20d90:	1a000003 	ldbu	r8,0(r3)
   20d94:	40000e26 	beq	r8,zero,20dd0 <alt_tse_mac_set_common_speed+0x58>
            pmac_info = pmac_group->pmac_info[j];
   20d98:	19800117 	ldw	r6,4(r3)
            if(((np_tse_mac *) pmac_info->psys_info->tse_mac_base) == pmac) {
   20d9c:	30800217 	ldw	r2,8(r6)
   20da0:	10800017 	ldw	r2,0(r2)
   20da4:	20800e26 	beq	r4,r2,20de0 <alt_tse_mac_set_common_speed+0x68>
 * @API Type:               Public
 * @param pmac              Pointer to the TSE MAC Control Interface Base address
 *        common_speed      common speed supported by all PHYs
 * @return                  common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_mac_set_common_speed(np_tse_mac *pmac, alt_32 common_speed) {
   20da8:	18c00204 	addi	r3,r3,8
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
        pmac_group = pmac_groups[i];
        for(j = 0; j < pmac_group->channel; j++) {
   20dac:	0005883a 	mov	r2,zero
   20db0:	00000506 	br	20dc8 <alt_tse_mac_set_common_speed+0x50>
            pmac_info = pmac_group->pmac_info[j];
   20db4:	19800017 	ldw	r6,0(r3)
   20db8:	18c00104 	addi	r3,r3,4
            if(((np_tse_mac *) pmac_info->psys_info->tse_mac_base) == pmac) {
   20dbc:	31c00217 	ldw	r7,8(r6)
   20dc0:	39c00017 	ldw	r7,0(r7)
   20dc4:	21c00626 	beq	r4,r7,20de0 <alt_tse_mac_set_common_speed+0x68>
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
        pmac_group = pmac_groups[i];
        for(j = 0; j < pmac_group->channel; j++) {
   20dc8:	10800044 	addi	r2,r2,1
   20dcc:	123ff916 	blt	r2,r8,20db4 <alt_tse_mac_set_common_speed+0x3c>
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
   20dd0:	52800044 	addi	r10,r10,1
   20dd4:	4a400104 	addi	r9,r9,4
   20dd8:	52ffec16 	blt	r10,r11,20d8c <alt_tse_mac_set_common_speed+0x14>
                return pmac_info;
            }
        }        
    }
    
    return 0;
   20ddc:	000d883a 	mov	r6,zero
 *        common_speed      common speed supported by all PHYs
 * @return                  common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_mac_set_common_speed(np_tse_mac *pmac, alt_32 common_speed) {
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
    return alt_tse_phy_set_common_speed(pmac_group, common_speed);
   20de0:	31000317 	ldw	r4,12(r6)
   20de4:	00208b81 	jmpi	208b8 <alt_tse_phy_set_common_speed>

00020de8 <marvell_cfg_gmii>:

/* @Function Description: Change operating mode of Marvell PHY to GMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_gmii(np_tse_mac *pmac) {
   20de8:	defffc04 	addi	sp,sp,-16
   20dec:	dc400115 	stw	r17,4(sp)
   20df0:	dc000015 	stw	r16,0(sp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
   20df4:	2440bb04 	addi	r17,r4,748

/* @Function Description: Change operating mode of Marvell PHY to GMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_gmii(np_tse_mac *pmac) {
   20df8:	2021883a 	mov	r16,r4
   20dfc:	dfc00315 	stw	ra,12(sp)
   20e00:	dc800215 	stw	r18,8(sp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
   20e04:	8c800037 	ldwio	r18,0(r17)
    dat &= 0xfff0;

    tse_dprintf(5, "MARVELL : Mode changed to GMII to copper mode\n");
   20e08:	010000b4 	movhi	r4,2
   20e0c:	211c9004 	addi	r4,r4,29248
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_gmii(np_tse_mac *pmac) {
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
    dat &= 0xfff0;
   20e10:	94bffc0c 	andi	r18,r18,65520

    tse_dprintf(5, "MARVELL : Mode changed to GMII to copper mode\n");
   20e14:	00106a40 	call	106a4 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xf);
   20e18:	948003d4 	ori	r18,r18,15
   20e1c:	8c800035 	stwio	r18,0(r17)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
   20e20:	010000b4 	movhi	r4,2
   20e24:	211c9c04 	addi	r4,r4,29296
   20e28:	00106a40 	call	106a4 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
   20e2c:	8080b404 	addi	r2,r16,720
   20e30:	10c00037 	ldwio	r3,0(r2)
    dat &= ~0x82;
   20e34:	18ffdf4c 	andi	r3,r3,65405
    IOWR(&pmac->mdio1.reg14, 0, dat);
   20e38:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
   20e3c:	010000b4 	movhi	r4,2
   20e40:	2118cc04 	addi	r4,r4,25392
   20e44:	00106a40 	call	106a4 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
   20e48:	8400a004 	addi	r16,r16,640
   20e4c:	80800037 	ldwio	r2,0(r16)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
   20e50:	10bfffcc 	andi	r2,r2,65535
   20e54:	10a00014 	ori	r2,r2,32768
   20e58:	80800035 	stwio	r2,0(r16)
    
    return 1;
}
   20e5c:	00800044 	movi	r2,1
   20e60:	dfc00317 	ldw	ra,12(sp)
   20e64:	dc800217 	ldw	r18,8(sp)
   20e68:	dc400117 	ldw	r17,4(sp)
   20e6c:	dc000017 	ldw	r16,0(sp)
   20e70:	dec00404 	addi	sp,sp,16
   20e74:	f800283a 	ret

00020e78 <marvell_cfg_sgmii>:

/* @Function Description: Change operating mode of Marvell PHY to SGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_sgmii(np_tse_mac *pmac) {
   20e78:	defffc04 	addi	sp,sp,-16
   20e7c:	dc400115 	stw	r17,4(sp)
   20e80:	dc000015 	stw	r16,0(sp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
   20e84:	2440bb04 	addi	r17,r4,748

/* @Function Description: Change operating mode of Marvell PHY to SGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_sgmii(np_tse_mac *pmac) {
   20e88:	2021883a 	mov	r16,r4
   20e8c:	dfc00315 	stw	ra,12(sp)
   20e90:	dc800215 	stw	r18,8(sp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
   20e94:	8c800037 	ldwio	r18,0(r17)
    dat &= 0xfff0;

    tse_dprintf(5, "MARVELL : Mode changed to SGMII without clock with SGMII Auto-Neg to copper mode\n");
   20e98:	010000b4 	movhi	r4,2
   20e9c:	211ca604 	addi	r4,r4,29336
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_sgmii(np_tse_mac *pmac) {
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
    dat &= 0xfff0;
   20ea0:	94bffc0c 	andi	r18,r18,65520

    tse_dprintf(5, "MARVELL : Mode changed to SGMII without clock with SGMII Auto-Neg to copper mode\n");
   20ea4:	00106a40 	call	106a4 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0x4);
   20ea8:	94800114 	ori	r18,r18,4
   20eac:	8c800035 	stwio	r18,0(r17)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
   20eb0:	010000b4 	movhi	r4,2
   20eb4:	211c9c04 	addi	r4,r4,29296
   20eb8:	00106a40 	call	106a4 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
   20ebc:	8080b404 	addi	r2,r16,720
   20ec0:	10c00037 	ldwio	r3,0(r2)
    dat &= ~0x82;
   20ec4:	18ffdf4c 	andi	r3,r3,65405
    IOWR(&pmac->mdio1.reg14, 0, dat);
   20ec8:	10c00035 	stwio	r3,0(r2)

    tse_dprintf(5, "MARVELL : PHY reset\n");
   20ecc:	010000b4 	movhi	r4,2
   20ed0:	2118cc04 	addi	r4,r4,25392
   20ed4:	00106a40 	call	106a4 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
   20ed8:	8400a004 	addi	r16,r16,640
   20edc:	80800037 	ldwio	r2,0(r16)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
   20ee0:	10bfffcc 	andi	r2,r2,65535
   20ee4:	10a00014 	ori	r2,r2,32768
   20ee8:	80800035 	stwio	r2,0(r16)
    
    return 1;
}
   20eec:	00800044 	movi	r2,1
   20ef0:	dfc00317 	ldw	ra,12(sp)
   20ef4:	dc800217 	ldw	r18,8(sp)
   20ef8:	dc400117 	ldw	r17,4(sp)
   20efc:	dc000017 	ldw	r16,0(sp)
   20f00:	dec00404 	addi	sp,sp,16
   20f04:	f800283a 	ret

00020f08 <marvell_cfg_rgmii>:

/* @Function Description: Change operating mode of Marvell PHY to RGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_rgmii(np_tse_mac *pmac) {
   20f08:	defffc04 	addi	sp,sp,-16
   20f0c:	dc400115 	stw	r17,4(sp)
   20f10:	dc000015 	stw	r16,0(sp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
   20f14:	2440bb04 	addi	r17,r4,748

/* @Function Description: Change operating mode of Marvell PHY to RGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_rgmii(np_tse_mac *pmac) {
   20f18:	2021883a 	mov	r16,r4
   20f1c:	dfc00315 	stw	ra,12(sp)
   20f20:	dc800215 	stw	r18,8(sp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
   20f24:	8c800037 	ldwio	r18,0(r17)
    dat &= 0xfff0;
    
    tse_dprintf(5, "MARVELL : Mode changed to RGMII/Modified MII to Copper mode\n");
   20f28:	010000b4 	movhi	r4,2
   20f2c:	211cbb04 	addi	r4,r4,29420
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_rgmii(np_tse_mac *pmac) {
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
    dat &= 0xfff0;
   20f30:	94bffc0c 	andi	r18,r18,65520
    
    tse_dprintf(5, "MARVELL : Mode changed to RGMII/Modified MII to Copper mode\n");
   20f34:	00106a40 	call	106a4 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xb);
   20f38:	948002d4 	ori	r18,r18,11
   20f3c:	8c800035 	stwio	r18,0(r17)
    
    tse_dprintf(5, "MARVELL : Enable RGMII Timing Control\n");
   20f40:	010000b4 	movhi	r4,2
   20f44:	211cca04 	addi	r4,r4,29480
   20f48:	00106a40 	call	106a4 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0);
   20f4c:	8080b404 	addi	r2,r16,720
   20f50:	10c00037 	ldwio	r3,0(r2)
    dat &= ~0x82;
   20f54:	18ffdf4c 	andi	r3,r3,65405
    dat |= 0x82;
   20f58:	18c02094 	ori	r3,r3,130
    IOWR(&pmac->mdio1.reg14, 0, dat);    
   20f5c:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
   20f60:	010000b4 	movhi	r4,2
   20f64:	2118cc04 	addi	r4,r4,25392
   20f68:	00106a40 	call	106a4 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
   20f6c:	8400a004 	addi	r16,r16,640
   20f70:	80800037 	ldwio	r2,0(r16)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
   20f74:	10bfffcc 	andi	r2,r2,65535
   20f78:	10a00014 	ori	r2,r2,32768
   20f7c:	80800035 	stwio	r2,0(r16)
    
    return 1;
    
}
   20f80:	00800044 	movi	r2,1
   20f84:	dfc00317 	ldw	ra,12(sp)
   20f88:	dc800217 	ldw	r18,8(sp)
   20f8c:	dc400117 	ldw	r17,4(sp)
   20f90:	dc000017 	ldw	r16,0(sp)
   20f94:	dec00404 	addi	sp,sp,16
   20f98:	f800283a 	ret

00020f9c <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
   20f9c:	defffa04 	addi	sp,sp,-24
   20fa0:	dfc00515 	stw	ra,20(sp)
   20fa4:	df000415 	stw	fp,16(sp)
   20fa8:	df000404 	addi	fp,sp,16
   20fac:	e13ffd15 	stw	r4,-12(fp)
   20fb0:	e17ffe15 	stw	r5,-8(fp)
   20fb4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
   20fb8:	e0bffd17 	ldw	r2,-12(fp)
   20fbc:	10800017 	ldw	r2,0(r2)
   20fc0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
   20fc4:	e0bffc17 	ldw	r2,-16(fp)
   20fc8:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
   20fcc:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 

    return altera_avalon_uart_read(&dev->state, buffer, space,
   20fd0:	10800217 	ldw	r2,8(r2)
   20fd4:	1809883a 	mov	r4,r3
   20fd8:	e17ffe17 	ldw	r5,-8(fp)
   20fdc:	e1bfff17 	ldw	r6,-4(fp)
   20fe0:	100f883a 	mov	r7,r2
   20fe4:	00214a40 	call	214a4 <altera_avalon_uart_read>
      fd->fd_flags);
}
   20fe8:	e037883a 	mov	sp,fp
   20fec:	dfc00117 	ldw	ra,4(sp)
   20ff0:	df000017 	ldw	fp,0(sp)
   20ff4:	dec00204 	addi	sp,sp,8
   20ff8:	f800283a 	ret

00020ffc <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
   20ffc:	defffa04 	addi	sp,sp,-24
   21000:	dfc00515 	stw	ra,20(sp)
   21004:	df000415 	stw	fp,16(sp)
   21008:	df000404 	addi	fp,sp,16
   2100c:	e13ffd15 	stw	r4,-12(fp)
   21010:	e17ffe15 	stw	r5,-8(fp)
   21014:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
   21018:	e0bffd17 	ldw	r2,-12(fp)
   2101c:	10800017 	ldw	r2,0(r2)
   21020:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
   21024:	e0bffc17 	ldw	r2,-16(fp)
   21028:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
   2102c:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 

    return altera_avalon_uart_write(&dev->state, buffer, space,
   21030:	10800217 	ldw	r2,8(r2)
   21034:	1809883a 	mov	r4,r3
   21038:	e17ffe17 	ldw	r5,-8(fp)
   2103c:	e1bfff17 	ldw	r6,-4(fp)
   21040:	100f883a 	mov	r7,r2
   21044:	00217500 	call	21750 <altera_avalon_uart_write>
      fd->fd_flags);
}
   21048:	e037883a 	mov	sp,fp
   2104c:	dfc00117 	ldw	ra,4(sp)
   21050:	df000017 	ldw	fp,0(sp)
   21054:	dec00204 	addi	sp,sp,8
   21058:	f800283a 	ret

0002105c <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
   2105c:	defffc04 	addi	sp,sp,-16
   21060:	dfc00315 	stw	ra,12(sp)
   21064:	df000215 	stw	fp,8(sp)
   21068:	df000204 	addi	fp,sp,8
   2106c:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
   21070:	e0bfff17 	ldw	r2,-4(fp)
   21074:	10800017 	ldw	r2,0(r2)
   21078:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
   2107c:	e0bffe17 	ldw	r2,-8(fp)
   21080:	10c00a04 	addi	r3,r2,40
   21084:	e0bfff17 	ldw	r2,-4(fp)
   21088:	10800217 	ldw	r2,8(r2)
   2108c:	1809883a 	mov	r4,r3
   21090:	100b883a 	mov	r5,r2
   21094:	00214000 	call	21400 <altera_avalon_uart_close>
}
   21098:	e037883a 	mov	sp,fp
   2109c:	dfc00117 	ldw	ra,4(sp)
   210a0:	df000017 	ldw	fp,0(sp)
   210a4:	dec00204 	addi	sp,sp,8
   210a8:	f800283a 	ret

000210ac <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
   210ac:	defff804 	addi	sp,sp,-32
   210b0:	dfc00715 	stw	ra,28(sp)
   210b4:	df000615 	stw	fp,24(sp)
   210b8:	df000604 	addi	fp,sp,24
   210bc:	e13ffd15 	stw	r4,-12(fp)
   210c0:	e17ffe15 	stw	r5,-8(fp)
   210c4:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
   210c8:	e0bffd17 	ldw	r2,-12(fp)
   210cc:	10800017 	ldw	r2,0(r2)
   210d0:	e0bffb15 	stw	r2,-20(fp)
 * HAL.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_no_error (void)
{
  return 0;
   210d4:	0005883a 	mov	r2,zero
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
   210d8:	1000041e 	bne	r2,zero,210ec <altera_avalon_uart_init+0x40>
   210dc:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
   210e0:	1000021e 	bne	r2,zero,210ec <altera_avalon_uart_init+0x40>
   210e4:	0005883a 	mov	r2,zero
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
   210e8:	10000226 	beq	r2,zero,210f4 <altera_avalon_uart_init+0x48>
   210ec:	00800044 	movi	r2,1
   210f0:	00000106 	br	210f8 <altera_avalon_uart_init+0x4c>
   210f4:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
   210f8:	e0bffc15 	stw	r2,-16(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
   210fc:	e0bffc17 	ldw	r2,-16(fp)
   21100:	10000f1e 	bne	r2,zero,21140 <altera_avalon_uart_init+0x94>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
   21104:	e0bffd17 	ldw	r2,-12(fp)
   21108:	00c32004 	movi	r3,3200
   2110c:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
   21110:	e0bffb17 	ldw	r2,-20(fp)
   21114:	10800304 	addi	r2,r2,12
   21118:	e0fffd17 	ldw	r3,-12(fp)
   2111c:	18c00117 	ldw	r3,4(r3)
   21120:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
   21124:	d8000015 	stw	zero,0(sp)
   21128:	e13ffe17 	ldw	r4,-8(fp)
   2112c:	e17fff17 	ldw	r5,-4(fp)
   21130:	018000b4 	movhi	r6,2
   21134:	31845504 	addi	r6,r6,4436
   21138:	e1fffd17 	ldw	r7,-12(fp)
   2113c:	0021ca40 	call	21ca4 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
   21140:	e037883a 	mov	sp,fp
   21144:	dfc00117 	ldw	ra,4(sp)
   21148:	df000017 	ldw	fp,0(sp)
   2114c:	dec00204 	addi	sp,sp,8
   21150:	f800283a 	ret

00021154 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
   21154:	defffa04 	addi	sp,sp,-24
   21158:	dfc00515 	stw	ra,20(sp)
   2115c:	df000415 	stw	fp,16(sp)
   21160:	df000404 	addi	fp,sp,16
   21164:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
   21168:	e0bfff17 	ldw	r2,-4(fp)
   2116c:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
   21170:	e0bffc17 	ldw	r2,-16(fp)
   21174:	10800017 	ldw	r2,0(r2)
   21178:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
   2117c:	e0bffd17 	ldw	r2,-12(fp)
   21180:	10800204 	addi	r2,r2,8
   21184:	10800037 	ldwio	r2,0(r2)
   21188:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
   2118c:	e0bffd17 	ldw	r2,-12(fp)
   21190:	10800204 	addi	r2,r2,8
   21194:	0007883a 	mov	r3,zero
   21198:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
   2119c:	e0bffd17 	ldw	r2,-12(fp)
   211a0:	10800204 	addi	r2,r2,8
   211a4:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
   211a8:	e0bffe17 	ldw	r2,-8(fp)
   211ac:	1080200c 	andi	r2,r2,128
   211b0:	10000326 	beq	r2,zero,211c0 <altera_avalon_uart_irq+0x6c>
  {
    altera_avalon_uart_rxirq(sp, status);
   211b4:	e13ffc17 	ldw	r4,-16(fp)
   211b8:	e17ffe17 	ldw	r5,-8(fp)
   211bc:	00211ec0 	call	211ec <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
   211c0:	e0bffe17 	ldw	r2,-8(fp)
   211c4:	1081100c 	andi	r2,r2,1088
   211c8:	10000326 	beq	r2,zero,211d8 <altera_avalon_uart_irq+0x84>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
   211cc:	e13ffc17 	ldw	r4,-16(fp)
   211d0:	e17ffe17 	ldw	r5,-8(fp)
   211d4:	00212c40 	call	212c4 <altera_avalon_uart_txirq>
  }
  

}
   211d8:	e037883a 	mov	sp,fp
   211dc:	dfc00117 	ldw	ra,4(sp)
   211e0:	df000017 	ldw	fp,0(sp)
   211e4:	dec00204 	addi	sp,sp,8
   211e8:	f800283a 	ret

000211ec <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
   211ec:	defffc04 	addi	sp,sp,-16
   211f0:	df000315 	stw	fp,12(sp)
   211f4:	df000304 	addi	fp,sp,12
   211f8:	e13ffe15 	stw	r4,-8(fp)
   211fc:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
   21200:	e0bfff17 	ldw	r2,-4(fp)
   21204:	108000cc 	andi	r2,r2,3
   21208:	1000291e 	bne	r2,zero,212b0 <altera_avalon_uart_rxirq+0xc4>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
   2120c:	e0bffe17 	ldw	r2,-8(fp)
   21210:	10800317 	ldw	r2,12(r2)
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
   21214:	e0bffe17 	ldw	r2,-8(fp)
   21218:	10800317 	ldw	r2,12(r2)
   2121c:	10800044 	addi	r2,r2,1
   21220:	10800fcc 	andi	r2,r2,63
   21224:	e0bffd15 	stw	r2,-12(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
   21228:	e0bffe17 	ldw	r2,-8(fp)
   2122c:	10800317 	ldw	r2,12(r2)
   21230:	e0fffe17 	ldw	r3,-8(fp)
   21234:	18c00017 	ldw	r3,0(r3)
   21238:	18c00037 	ldwio	r3,0(r3)
   2123c:	e13ffe17 	ldw	r4,-8(fp)
   21240:	2085883a 	add	r2,r4,r2
   21244:	10800704 	addi	r2,r2,28
   21248:	10c00005 	stb	r3,0(r2)

  sp->rx_end = next;
   2124c:	e0bffe17 	ldw	r2,-8(fp)
   21250:	e0fffd17 	ldw	r3,-12(fp)
   21254:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
   21258:	e0bffe17 	ldw	r2,-8(fp)
   2125c:	10800317 	ldw	r2,12(r2)
   21260:	10800044 	addi	r2,r2,1
   21264:	10800fcc 	andi	r2,r2,63
   21268:	e0bffd15 	stw	r2,-12(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
   2126c:	e0bffe17 	ldw	r2,-8(fp)
   21270:	10c00217 	ldw	r3,8(r2)
   21274:	e0bffd17 	ldw	r2,-12(fp)
   21278:	18800e1e 	bne	r3,r2,212b4 <altera_avalon_uart_rxirq+0xc8>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
   2127c:	e0bffe17 	ldw	r2,-8(fp)
   21280:	10c00117 	ldw	r3,4(r2)
   21284:	00bfdfc4 	movi	r2,-129
   21288:	1886703a 	and	r3,r3,r2
   2128c:	e0bffe17 	ldw	r2,-8(fp)
   21290:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
   21294:	e0bffe17 	ldw	r2,-8(fp)
   21298:	10800017 	ldw	r2,0(r2)
   2129c:	10800304 	addi	r2,r2,12
   212a0:	e0fffe17 	ldw	r3,-8(fp)
   212a4:	18c00117 	ldw	r3,4(r3)
   212a8:	10c00035 	stwio	r3,0(r2)
   212ac:	00000106 	br	212b4 <altera_avalon_uart_rxirq+0xc8>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
   212b0:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
   212b4:	e037883a 	mov	sp,fp
   212b8:	df000017 	ldw	fp,0(sp)
   212bc:	dec00104 	addi	sp,sp,4
   212c0:	f800283a 	ret

000212c4 <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
   212c4:	defffd04 	addi	sp,sp,-12
   212c8:	df000215 	stw	fp,8(sp)
   212cc:	df000204 	addi	fp,sp,8
   212d0:	e13ffe15 	stw	r4,-8(fp)
   212d4:	e17fff15 	stw	r5,-4(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
   212d8:	e0bffe17 	ldw	r2,-8(fp)
   212dc:	10c00417 	ldw	r3,16(r2)
   212e0:	e0bffe17 	ldw	r2,-8(fp)
   212e4:	10800517 	ldw	r2,20(r2)
   212e8:	18803026 	beq	r3,r2,213ac <altera_avalon_uart_txirq+0xe8>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
   212ec:	e0bffe17 	ldw	r2,-8(fp)
   212f0:	10800617 	ldw	r2,24(r2)
   212f4:	1080008c 	andi	r2,r2,2
   212f8:	10000326 	beq	r2,zero,21308 <altera_avalon_uart_txirq+0x44>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
   212fc:	e0bfff17 	ldw	r2,-4(fp)
   21300:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
   21304:	10001b26 	beq	r2,zero,21374 <altera_avalon_uart_txirq+0xb0>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
   21308:	e0bffe17 	ldw	r2,-8(fp)
   2130c:	10800417 	ldw	r2,16(r2)
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
   21310:	e0bffe17 	ldw	r2,-8(fp)
   21314:	10800017 	ldw	r2,0(r2)
   21318:	10800104 	addi	r2,r2,4
   2131c:	e0fffe17 	ldw	r3,-8(fp)
   21320:	18c00417 	ldw	r3,16(r3)
   21324:	e13ffe17 	ldw	r4,-8(fp)
   21328:	20c7883a 	add	r3,r4,r3
   2132c:	18c01704 	addi	r3,r3,92
   21330:	18c00003 	ldbu	r3,0(r3)
   21334:	18c03fcc 	andi	r3,r3,255
   21338:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
   2133c:	e0bffe17 	ldw	r2,-8(fp)
   21340:	10800417 	ldw	r2,16(r2)
   21344:	10800044 	addi	r2,r2,1
   21348:	e0fffe17 	ldw	r3,-8(fp)
   2134c:	18800415 	stw	r2,16(r3)
   21350:	10c00fcc 	andi	r3,r2,63
   21354:	e0bffe17 	ldw	r2,-8(fp)
   21358:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
   2135c:	e0bffe17 	ldw	r2,-8(fp)
   21360:	10800117 	ldw	r2,4(r2)
   21364:	10c01014 	ori	r3,r2,64
   21368:	e0bffe17 	ldw	r2,-8(fp)
   2136c:	10c00115 	stw	r3,4(r2)
   21370:	00000e06 	br	213ac <altera_avalon_uart_txirq+0xe8>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
   21374:	e0bffe17 	ldw	r2,-8(fp)
   21378:	10800017 	ldw	r2,0(r2)
   2137c:	10800204 	addi	r2,r2,8
   21380:	10800037 	ldwio	r2,0(r2)
   21384:	e0bfff15 	stw	r2,-4(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
   21388:	e0bfff17 	ldw	r2,-4(fp)
   2138c:	1082000c 	andi	r2,r2,2048
   21390:	1000061e 	bne	r2,zero,213ac <altera_avalon_uart_txirq+0xe8>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
   21394:	e0bffe17 	ldw	r2,-8(fp)
   21398:	10c00117 	ldw	r3,4(r2)
   2139c:	00bfefc4 	movi	r2,-65
   213a0:	1886703a 	and	r3,r3,r2
   213a4:	e0bffe17 	ldw	r2,-8(fp)
   213a8:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
   213ac:	e0bffe17 	ldw	r2,-8(fp)
   213b0:	10c00417 	ldw	r3,16(r2)
   213b4:	e0bffe17 	ldw	r2,-8(fp)
   213b8:	10800517 	ldw	r2,20(r2)
   213bc:	1880061e 	bne	r3,r2,213d8 <altera_avalon_uart_txirq+0x114>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
   213c0:	e0bffe17 	ldw	r2,-8(fp)
   213c4:	10c00117 	ldw	r3,4(r2)
   213c8:	00beefc4 	movi	r2,-1089
   213cc:	1886703a 	and	r3,r3,r2
   213d0:	e0bffe17 	ldw	r2,-8(fp)
   213d4:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
   213d8:	e0bffe17 	ldw	r2,-8(fp)
   213dc:	10800017 	ldw	r2,0(r2)
   213e0:	10800304 	addi	r2,r2,12
   213e4:	e0fffe17 	ldw	r3,-8(fp)
   213e8:	18c00117 	ldw	r3,4(r3)
   213ec:	10c00035 	stwio	r3,0(r2)
}
   213f0:	e037883a 	mov	sp,fp
   213f4:	df000017 	ldw	fp,0(sp)
   213f8:	dec00104 	addi	sp,sp,4
   213fc:	f800283a 	ret

00021400 <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
   21400:	defffd04 	addi	sp,sp,-12
   21404:	df000215 	stw	fp,8(sp)
   21408:	df000204 	addi	fp,sp,8
   2140c:	e13ffe15 	stw	r4,-8(fp)
   21410:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
   21414:	00000506 	br	2142c <altera_avalon_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
   21418:	e0bfff17 	ldw	r2,-4(fp)
   2141c:	1090000c 	andi	r2,r2,16384
   21420:	10000226 	beq	r2,zero,2142c <altera_avalon_uart_close+0x2c>
      return -EWOULDBLOCK; 
   21424:	00bffd44 	movi	r2,-11
   21428:	00000606 	br	21444 <altera_avalon_uart_close+0x44>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
   2142c:	e0bffe17 	ldw	r2,-8(fp)
   21430:	10c00417 	ldw	r3,16(r2)
   21434:	e0bffe17 	ldw	r2,-8(fp)
   21438:	10800517 	ldw	r2,20(r2)
   2143c:	18bff61e 	bne	r3,r2,21418 <altera_avalon_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
   21440:	0005883a 	mov	r2,zero
}
   21444:	e037883a 	mov	sp,fp
   21448:	df000017 	ldw	fp,0(sp)
   2144c:	dec00104 	addi	sp,sp,4
   21450:	f800283a 	ret

00021454 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   21454:	defffe04 	addi	sp,sp,-8
   21458:	dfc00115 	stw	ra,4(sp)
   2145c:	df000015 	stw	fp,0(sp)
   21460:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   21464:	008000f4 	movhi	r2,3
   21468:	10a61304 	addi	r2,r2,-26548
   2146c:	10800017 	ldw	r2,0(r2)
   21470:	10000526 	beq	r2,zero,21488 <alt_get_errno+0x34>
   21474:	008000f4 	movhi	r2,3
   21478:	10a61304 	addi	r2,r2,-26548
   2147c:	10800017 	ldw	r2,0(r2)
   21480:	103ee83a 	callr	r2
   21484:	00000206 	br	21490 <alt_get_errno+0x3c>
   21488:	008000f4 	movhi	r2,3
   2148c:	10aed404 	addi	r2,r2,-17584
}
   21490:	e037883a 	mov	sp,fp
   21494:	dfc00117 	ldw	ra,4(sp)
   21498:	df000017 	ldw	fp,0(sp)
   2149c:	dec00204 	addi	sp,sp,8
   214a0:	f800283a 	ret

000214a4 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
   214a4:	deffef04 	addi	sp,sp,-68
   214a8:	dfc01015 	stw	ra,64(sp)
   214ac:	df000f15 	stw	fp,60(sp)
   214b0:	df000f04 	addi	fp,sp,60
   214b4:	e13ffc15 	stw	r4,-16(fp)
   214b8:	e17ffd15 	stw	r5,-12(fp)
   214bc:	e1bffe15 	stw	r6,-8(fp)
   214c0:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u32         next;
  alt_u8          read_would_block = 0;
   214c4:	e03ff105 	stb	zero,-60(fp)
  int             count = 0;
   214c8:	e03ff215 	stw	zero,-56(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
   214cc:	e0bfff17 	ldw	r2,-4(fp)
   214d0:	1090000c 	andi	r2,r2,16384
   214d4:	1005003a 	cmpeq	r2,r2,zero
   214d8:	10803fcc 	andi	r2,r2,255
   214dc:	e0bff315 	stw	r2,-52(fp)
  /*
   * Calculate which slot in the circular buffer is the next one to read
   * data from.
   */

  next = (sp->rx_start + 1) & ALT_AVALON_UART_BUF_MSK;
   214e0:	e0bffc17 	ldw	r2,-16(fp)
   214e4:	10800217 	ldw	r2,8(r2)
   214e8:	10800044 	addi	r2,r2,1
   214ec:	10800fcc 	andi	r2,r2,63
   214f0:	e0bff415 	stw	r2,-48(fp)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
   214f4:	00001906 	br	2155c <altera_avalon_uart_read+0xb8>
    {
      count++;
   214f8:	e0bff217 	ldw	r2,-56(fp)
   214fc:	10800044 	addi	r2,r2,1
   21500:	e0bff215 	stw	r2,-56(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
   21504:	e0bffc17 	ldw	r2,-16(fp)
   21508:	10800217 	ldw	r2,8(r2)
   2150c:	e0fffc17 	ldw	r3,-16(fp)
   21510:	1885883a 	add	r2,r3,r2
   21514:	10800704 	addi	r2,r2,28
   21518:	10800003 	ldbu	r2,0(r2)
   2151c:	1007883a 	mov	r3,r2
   21520:	e0bffd17 	ldw	r2,-12(fp)
   21524:	10c00005 	stb	r3,0(r2)
   21528:	e0bffd17 	ldw	r2,-12(fp)
   2152c:	10800044 	addi	r2,r2,1
   21530:	e0bffd15 	stw	r2,-12(fp)
      
      sp->rx_start = (++sp->rx_start) & ALT_AVALON_UART_BUF_MSK;
   21534:	e0bffc17 	ldw	r2,-16(fp)
   21538:	10800217 	ldw	r2,8(r2)
   2153c:	10c00044 	addi	r3,r2,1
   21540:	e0bffc17 	ldw	r2,-16(fp)
   21544:	10c00215 	stw	r3,8(r2)
   21548:	e0bffc17 	ldw	r2,-16(fp)
   2154c:	10800217 	ldw	r2,8(r2)
   21550:	10c00fcc 	andi	r3,r2,63
   21554:	e0bffc17 	ldw	r2,-16(fp)
   21558:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
   2155c:	e0fff217 	ldw	r3,-56(fp)
   21560:	e0bffe17 	ldw	r2,-8(fp)
   21564:	1880050e 	bge	r3,r2,2157c <altera_avalon_uart_read+0xd8>
   21568:	e0bffc17 	ldw	r2,-16(fp)
   2156c:	10c00217 	ldw	r3,8(r2)
   21570:	e0bffc17 	ldw	r2,-16(fp)
   21574:	10800317 	ldw	r2,12(r2)
   21578:	18bfdf1e 	bne	r3,r2,214f8 <altera_avalon_uart_read+0x54>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
   2157c:	e0bff217 	ldw	r2,-56(fp)
   21580:	10002f1e 	bne	r2,zero,21640 <altera_avalon_uart_read+0x19c>
   21584:	e0bffc17 	ldw	r2,-16(fp)
   21588:	10c00217 	ldw	r3,8(r2)
   2158c:	e0bffc17 	ldw	r2,-16(fp)
   21590:	10800317 	ldw	r2,12(r2)
   21594:	18802a1e 	bne	r3,r2,21640 <altera_avalon_uart_read+0x19c>
    {
      if (!block)
   21598:	e0bff317 	ldw	r2,-52(fp)
   2159c:	1000061e 	bne	r2,zero,215b8 <altera_avalon_uart_read+0x114>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
   215a0:	00214540 	call	21454 <alt_get_errno>
   215a4:	00c002c4 	movi	r3,11
   215a8:	10c00015 	stw	r3,0(r2)
        read_would_block = 1;
   215ac:	00800044 	movi	r2,1
   215b0:	e0bff105 	stb	r2,-60(fp)
        break;
   215b4:	00002606 	br	21650 <altera_avalon_uart_read+0x1ac>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   215b8:	0005303a 	rdctl	r2,status
   215bc:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   215c0:	e0fff617 	ldw	r3,-40(fp)
   215c4:	00bfff84 	movi	r2,-2
   215c8:	1884703a 	and	r2,r3,r2
   215cc:	1001703a 	wrctl	status,r2
  
  return context;
   215d0:	e0bff617 	ldw	r2,-40(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
   215d4:	e0bff515 	stw	r2,-44(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
   215d8:	e0bffc17 	ldw	r2,-16(fp)
   215dc:	10800117 	ldw	r2,4(r2)
   215e0:	10c02014 	ori	r3,r2,128
   215e4:	e0bffc17 	ldw	r2,-16(fp)
   215e8:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
   215ec:	e0bffc17 	ldw	r2,-16(fp)
   215f0:	10800017 	ldw	r2,0(r2)
   215f4:	10800304 	addi	r2,r2,12
   215f8:	e0fffc17 	ldw	r3,-16(fp)
   215fc:	18c00117 	ldw	r3,4(r3)
   21600:	10c00035 	stwio	r3,0(r2)
   21604:	e0bff517 	ldw	r2,-44(fp)
   21608:	e0bff715 	stw	r2,-36(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   2160c:	0005303a 	rdctl	r2,status
   21610:	e0bff815 	stw	r2,-32(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   21614:	e0fff817 	ldw	r3,-32(fp)
   21618:	00bfff84 	movi	r2,-2
   2161c:	1884703a 	and	r2,r3,r2
   21620:	e0bff815 	stw	r2,-32(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   21624:	e0bff717 	ldw	r2,-36(fp)
   21628:	1080004c 	andi	r2,r2,1
   2162c:	e0fff817 	ldw	r3,-32(fp)
   21630:	1884b03a 	or	r2,r3,r2
   21634:	e0bff815 	stw	r2,-32(fp)
  
  NIOS2_WRITE_STATUS (status);
   21638:	e0bff817 	ldw	r2,-32(fp)
   2163c:	1001703a 	wrctl	status,r2
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
   21640:	e0bff217 	ldw	r2,-56(fp)
   21644:	1000021e 	bne	r2,zero,21650 <altera_avalon_uart_read+0x1ac>
   21648:	e0bffe17 	ldw	r2,-8(fp)
   2164c:	103fc31e 	bne	r2,zero,2155c <altera_avalon_uart_read+0xb8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   21650:	0005303a 	rdctl	r2,status
   21654:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   21658:	e0fff917 	ldw	r3,-28(fp)
   2165c:	00bfff84 	movi	r2,-2
   21660:	1884703a 	and	r2,r3,r2
   21664:	1001703a 	wrctl	status,r2
  
  return context;
   21668:	e0bff917 	ldw	r2,-28(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
   2166c:	e0bff515 	stw	r2,-44(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
   21670:	e0bffc17 	ldw	r2,-16(fp)
   21674:	10800117 	ldw	r2,4(r2)
   21678:	10c02014 	ori	r3,r2,128
   2167c:	e0bffc17 	ldw	r2,-16(fp)
   21680:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
   21684:	e0bffc17 	ldw	r2,-16(fp)
   21688:	10800017 	ldw	r2,0(r2)
   2168c:	10800304 	addi	r2,r2,12
   21690:	e0fffc17 	ldw	r3,-16(fp)
   21694:	18c00117 	ldw	r3,4(r3)
   21698:	10c00035 	stwio	r3,0(r2)
   2169c:	e0bff517 	ldw	r2,-44(fp)
   216a0:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   216a4:	0005303a 	rdctl	r2,status
   216a8:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   216ac:	e0fffb17 	ldw	r3,-20(fp)
   216b0:	00bfff84 	movi	r2,-2
   216b4:	1884703a 	and	r2,r3,r2
   216b8:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   216bc:	e0bffa17 	ldw	r2,-24(fp)
   216c0:	1080004c 	andi	r2,r2,1
   216c4:	e0fffb17 	ldw	r3,-20(fp)
   216c8:	1884b03a 	or	r2,r3,r2
   216cc:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
   216d0:	e0bffb17 	ldw	r2,-20(fp)
   216d4:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
   216d8:	e0bff103 	ldbu	r2,-60(fp)
   216dc:	10000226 	beq	r2,zero,216e8 <altera_avalon_uart_read+0x244>
    return -EWOULDBLOCK;
   216e0:	00bffd44 	movi	r2,-11
   216e4:	00000106 	br	216ec <altera_avalon_uart_read+0x248>
  }
  else {
    return count;
   216e8:	e0bff217 	ldw	r2,-56(fp)
  }
}
   216ec:	e037883a 	mov	sp,fp
   216f0:	dfc00117 	ldw	ra,4(sp)
   216f4:	df000017 	ldw	fp,0(sp)
   216f8:	dec00204 	addi	sp,sp,8
   216fc:	f800283a 	ret

00021700 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   21700:	defffe04 	addi	sp,sp,-8
   21704:	dfc00115 	stw	ra,4(sp)
   21708:	df000015 	stw	fp,0(sp)
   2170c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   21710:	008000f4 	movhi	r2,3
   21714:	10a61304 	addi	r2,r2,-26548
   21718:	10800017 	ldw	r2,0(r2)
   2171c:	10000526 	beq	r2,zero,21734 <alt_get_errno+0x34>
   21720:	008000f4 	movhi	r2,3
   21724:	10a61304 	addi	r2,r2,-26548
   21728:	10800017 	ldw	r2,0(r2)
   2172c:	103ee83a 	callr	r2
   21730:	00000206 	br	2173c <alt_get_errno+0x3c>
   21734:	008000f4 	movhi	r2,3
   21738:	10aed404 	addi	r2,r2,-17584
}
   2173c:	e037883a 	mov	sp,fp
   21740:	dfc00117 	ldw	ra,4(sp)
   21744:	df000017 	ldw	fp,0(sp)
   21748:	dec00204 	addi	sp,sp,8
   2174c:	f800283a 	ret

00021750 <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
   21750:	defff004 	addi	sp,sp,-64
   21754:	dfc00f15 	stw	ra,60(sp)
   21758:	df000e15 	stw	fp,56(sp)
   2175c:	df000e04 	addi	fp,sp,56
   21760:	e13ffc15 	stw	r4,-16(fp)
   21764:	e17ffd15 	stw	r5,-12(fp)
   21768:	e1bffe15 	stw	r6,-8(fp)
   2176c:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
   21770:	e0bffe17 	ldw	r2,-8(fp)
   21774:	e0bff215 	stw	r2,-56(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
   21778:	e0bfff17 	ldw	r2,-4(fp)
   2177c:	1090000c 	andi	r2,r2,16384
   21780:	e0bff315 	stw	r2,-52(fp)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
   21784:	00004606 	br	218a0 <altera_avalon_uart_write+0x150>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
   21788:	e0bffc17 	ldw	r2,-16(fp)
   2178c:	10800517 	ldw	r2,20(r2)
   21790:	10800044 	addi	r2,r2,1
   21794:	10800fcc 	andi	r2,r2,63
   21798:	e0bff415 	stw	r2,-48(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
   2179c:	e0bffc17 	ldw	r2,-16(fp)
   217a0:	10c00417 	ldw	r3,16(r2)
   217a4:	e0bff417 	ldw	r2,-48(fp)
   217a8:	18802c1e 	bne	r3,r2,2185c <altera_avalon_uart_write+0x10c>
    {
      if (no_block)
   217ac:	e0bff317 	ldw	r2,-52(fp)
   217b0:	10000426 	beq	r2,zero,217c4 <altera_avalon_uart_write+0x74>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
   217b4:	00217000 	call	21700 <alt_get_errno>
   217b8:	00c002c4 	movi	r3,11
   217bc:	10c00015 	stw	r3,0(r2)
        break;
   217c0:	00003906 	br	218a8 <altera_avalon_uart_write+0x158>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   217c4:	0005303a 	rdctl	r2,status
   217c8:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   217cc:	e0fff617 	ldw	r3,-40(fp)
   217d0:	00bfff84 	movi	r2,-2
   217d4:	1884703a 	and	r2,r3,r2
   217d8:	1001703a 	wrctl	status,r2
  
  return context;
   217dc:	e0bff617 	ldw	r2,-40(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
   217e0:	e0bff515 	stw	r2,-44(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
   217e4:	e0bffc17 	ldw	r2,-16(fp)
   217e8:	10800117 	ldw	r2,4(r2)
   217ec:	10c11014 	ori	r3,r2,1088
   217f0:	e0bffc17 	ldw	r2,-16(fp)
   217f4:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
   217f8:	e0bffc17 	ldw	r2,-16(fp)
   217fc:	10800017 	ldw	r2,0(r2)
   21800:	10800304 	addi	r2,r2,12
   21804:	e0fffc17 	ldw	r3,-16(fp)
   21808:	18c00117 	ldw	r3,4(r3)
   2180c:	10c00035 	stwio	r3,0(r2)
   21810:	e0bff517 	ldw	r2,-44(fp)
   21814:	e0bff715 	stw	r2,-36(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   21818:	0005303a 	rdctl	r2,status
   2181c:	e0bff815 	stw	r2,-32(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   21820:	e0fff817 	ldw	r3,-32(fp)
   21824:	00bfff84 	movi	r2,-2
   21828:	1884703a 	and	r2,r3,r2
   2182c:	e0bff815 	stw	r2,-32(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   21830:	e0bff717 	ldw	r2,-36(fp)
   21834:	1080004c 	andi	r2,r2,1
   21838:	e0fff817 	ldw	r3,-32(fp)
   2183c:	1884b03a 	or	r2,r3,r2
   21840:	e0bff815 	stw	r2,-32(fp)
  
  NIOS2_WRITE_STATUS (status);
   21844:	e0bff817 	ldw	r2,-32(fp)
   21848:	1001703a 	wrctl	status,r2
          ALT_FLAG_PEND (sp->events, 
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
   2184c:	e0bffc17 	ldw	r2,-16(fp)
   21850:	10c00417 	ldw	r3,16(r2)
   21854:	e0bff417 	ldw	r2,-48(fp)
   21858:	18bffc26 	beq	r3,r2,2184c <altera_avalon_uart_write+0xfc>
      }
    }

    count--;
   2185c:	e0bff217 	ldw	r2,-56(fp)
   21860:	10bfffc4 	addi	r2,r2,-1
   21864:	e0bff215 	stw	r2,-56(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
   21868:	e0bffc17 	ldw	r2,-16(fp)
   2186c:	10800517 	ldw	r2,20(r2)
   21870:	e0fffd17 	ldw	r3,-12(fp)
   21874:	18c00003 	ldbu	r3,0(r3)
   21878:	e13ffc17 	ldw	r4,-16(fp)
   2187c:	2085883a 	add	r2,r4,r2
   21880:	10801704 	addi	r2,r2,92
   21884:	10c00005 	stb	r3,0(r2)
   21888:	e0bffd17 	ldw	r2,-12(fp)
   2188c:	10800044 	addi	r2,r2,1
   21890:	e0bffd15 	stw	r2,-12(fp)
    sp->tx_end = next;
   21894:	e0bffc17 	ldw	r2,-16(fp)
   21898:	e0fff417 	ldw	r3,-48(fp)
   2189c:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
   218a0:	e0bff217 	ldw	r2,-56(fp)
   218a4:	103fb81e 	bne	r2,zero,21788 <altera_avalon_uart_write+0x38>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   218a8:	0005303a 	rdctl	r2,status
   218ac:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   218b0:	e0fff917 	ldw	r3,-28(fp)
   218b4:	00bfff84 	movi	r2,-2
   218b8:	1884703a 	and	r2,r3,r2
   218bc:	1001703a 	wrctl	status,r2
  
  return context;
   218c0:	e0bff917 	ldw	r2,-28(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
   218c4:	e0bff515 	stw	r2,-44(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
   218c8:	e0bffc17 	ldw	r2,-16(fp)
   218cc:	10800117 	ldw	r2,4(r2)
   218d0:	10c11014 	ori	r3,r2,1088
   218d4:	e0bffc17 	ldw	r2,-16(fp)
   218d8:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
   218dc:	e0bffc17 	ldw	r2,-16(fp)
   218e0:	10800017 	ldw	r2,0(r2)
   218e4:	10800304 	addi	r2,r2,12
   218e8:	e0fffc17 	ldw	r3,-16(fp)
   218ec:	18c00117 	ldw	r3,4(r3)
   218f0:	10c00035 	stwio	r3,0(r2)
   218f4:	e0bff517 	ldw	r2,-44(fp)
   218f8:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   218fc:	0005303a 	rdctl	r2,status
   21900:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   21904:	e0fffb17 	ldw	r3,-20(fp)
   21908:	00bfff84 	movi	r2,-2
   2190c:	1884703a 	and	r2,r3,r2
   21910:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   21914:	e0bffa17 	ldw	r2,-24(fp)
   21918:	1080004c 	andi	r2,r2,1
   2191c:	e0fffb17 	ldw	r3,-20(fp)
   21920:	1884b03a 	or	r2,r3,r2
   21924:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
   21928:	e0bffb17 	ldw	r2,-20(fp)
   2192c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
   21930:	e0fffe17 	ldw	r3,-8(fp)
   21934:	e0bff217 	ldw	r2,-56(fp)
   21938:	1885c83a 	sub	r2,r3,r2
}
   2193c:	e037883a 	mov	sp,fp
   21940:	dfc00117 	ldw	ra,4(sp)
   21944:	df000017 	ldw	fp,0(sp)
   21948:	dec00204 	addi	sp,sp,8
   2194c:	f800283a 	ret

00021950 <VIC_0_VECTOR_TABLE>:

    .section .text, "xa"
    .align 2
    .globl VIC_0_VECTOR_TABLE
VIC_0_VECTOR_TABLE:
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   21950:	0030e03a 	nextpc	et
   21954:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   21960:	0030e03a 	nextpc	et
   21964:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   21970:	0030e03a 	nextpc	et
   21974:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   21980:	0030e03a 	nextpc	et
   21984:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   21990:	0030e03a 	nextpc	et
   21994:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   219a0:	0030e03a 	nextpc	et
   219a4:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   219b0:	0030e03a 	nextpc	et
   219b4:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   219c0:	0030e03a 	nextpc	et
   219c4:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   219d0:	0030e03a 	nextpc	et
   219d4:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   219e0:	0030e03a 	nextpc	et
   219e4:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   219f0:	0030e03a 	nextpc	et
   219f4:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   21a00:	0030e03a 	nextpc	et
   21a04:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   21a10:	0030e03a 	nextpc	et
   21a14:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   21a20:	0030e03a 	nextpc	et
   21a24:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   21a30:	0030e03a 	nextpc	et
   21a34:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   21a40:	0030e03a 	nextpc	et
   21a44:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   21a50:	0030e03a 	nextpc	et
   21a54:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   21a60:	0030e03a 	nextpc	et
   21a64:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   21a70:	0030e03a 	nextpc	et
   21a74:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   21a80:	0030e03a 	nextpc	et
   21a84:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   21a90:	0030e03a 	nextpc	et
   21a94:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   21aa0:	0030e03a 	nextpc	et
   21aa4:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   21ab0:	0030e03a 	nextpc	et
   21ab4:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   21ac0:	0030e03a 	nextpc	et
   21ac4:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   21ad0:	0030e03a 	nextpc	et
   21ad4:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   21ae0:	0030e03a 	nextpc	et
   21ae4:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   21af0:	0030e03a 	nextpc	et
   21af4:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   21b00:	0030e03a 	nextpc	et
   21b04:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   21b10:	0030e03a 	nextpc	et
   21b14:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   21b20:	0030e03a 	nextpc	et
   21b24:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   21b30:	0030e03a 	nextpc	et
   21b34:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   21b40:	0030e03a 	nextpc	et
   21b44:	0021b501 	jmpi	21b50 <alt_shadow_non_preemptive_interrupt>
	...

00021b50 <alt_shadow_non_preemptive_interrupt>:
    .section ALTERA_VIC_DRIVER_LINKER_SECTION
    .set nobreak
    .globl alt_shadow_non_preemptive_interrupt
alt_shadow_non_preemptive_interrupt:

    ldw r16, 4(et)               /* load ISR pointer */
   21b50:	c4000117 	ldw	r16,4(et)

     /*
      * Get SP from previous register set.
      */

    rdprs sp, sp, 0
   21b54:	dec00038 	rdprs	sp,sp,0
  /*
   * Notify the operating system that we are at interrupt level.
   */
    ALT_OS_INT_ENTER_ASM

    ldw r4, 8(et)               /* load isr_context */
   21b58:	c1000217 	ldw	r4,8(et)
    callr r16                   /* call ISR */
   21b5c:	803ee83a 	callr	r16
    /*
     * Notify the operating system that interrupt processing is complete.
     */
    ALT_OS_INT_EXIT_ASM

    addi ea, ea, -4             /* instruction that caused exception */
   21b60:	ef7fff04 	addi	ea,ea,-4
    eret
   21b64:	ef80083a 	eret

00021b68 <alt_vic_irq_init>:
  * @API Type:              Internal
  * @param pdev             pointer of type alt_vic_dev, main Device Structure.
  * @return                 None
  */
void alt_vic_irq_init (alt_vic_dev* pdev)
{
   21b68:	defffd04 	addi	sp,sp,-12
   21b6c:	df000215 	stw	fp,8(sp)
   21b70:	df000204 	addi	fp,sp,8
   21b74:	e13fff15 	stw	r4,-4(fp)
    alt_u32 i;
    static const int VEC_SIZE_ARRAY[]={4, 8, 16, 32, 64, 128, 256, 512};

    /* Stores the VIC instance to list */
    alt_vic_dev_list[pdev->intr_controller_id] = pdev;
   21b78:	e0bfff17 	ldw	r2,-4(fp)
   21b7c:	10800117 	ldw	r2,4(r2)
   21b80:	1085883a 	add	r2,r2,r2
   21b84:	1087883a 	add	r3,r2,r2
   21b88:	d0a8e004 	addi	r2,gp,-23680
   21b8c:	1885883a 	add	r2,r3,r2
   21b90:	e0ffff17 	ldw	r3,-4(fp)
   21b94:	10c00015 	stw	r3,0(r2)

    /* Disables all interrupts */
    IOWR_ALTERA_VIC_INT_ENABLE_CLR(pdev->base, 0xFFFFFFFF);
   21b98:	e0bfff17 	ldw	r2,-4(fp)
   21b9c:	10800017 	ldw	r2,0(r2)
   21ba0:	10802204 	addi	r2,r2,136
   21ba4:	00ffffc4 	movi	r3,-1
   21ba8:	10c00035 	stwio	r3,0(r2)

    /* Initialize INT_CONFIG for all interrupts in this VIC */
    for(i = 0; i < pdev->num_of_intr_ports; i++)
   21bac:	e03ffe15 	stw	zero,-8(fp)
   21bb0:	00001106 	br	21bf8 <alt_vic_irq_init+0x90>
    {
        IOWR_ALTERA_VIC_INT_CONFIG(pdev->base, i, pdev->int_config[i]);
   21bb4:	e0bfff17 	ldw	r2,-4(fp)
   21bb8:	10c00017 	ldw	r3,0(r2)
   21bbc:	e0bffe17 	ldw	r2,-8(fp)
   21bc0:	1085883a 	add	r2,r2,r2
   21bc4:	1085883a 	add	r2,r2,r2
   21bc8:	1887883a 	add	r3,r3,r2
   21bcc:	e13fff17 	ldw	r4,-4(fp)
   21bd0:	e0bffe17 	ldw	r2,-8(fp)
   21bd4:	108001c4 	addi	r2,r2,7
   21bd8:	1085883a 	add	r2,r2,r2
   21bdc:	1085883a 	add	r2,r2,r2
   21be0:	2085883a 	add	r2,r4,r2
   21be4:	10800017 	ldw	r2,0(r2)
   21be8:	18800035 	stwio	r2,0(r3)

    /* Disables all interrupts */
    IOWR_ALTERA_VIC_INT_ENABLE_CLR(pdev->base, 0xFFFFFFFF);

    /* Initialize INT_CONFIG for all interrupts in this VIC */
    for(i = 0; i < pdev->num_of_intr_ports; i++)
   21bec:	e0bffe17 	ldw	r2,-8(fp)
   21bf0:	10800044 	addi	r2,r2,1
   21bf4:	e0bffe15 	stw	r2,-8(fp)
   21bf8:	e0bfff17 	ldw	r2,-4(fp)
   21bfc:	10800217 	ldw	r2,8(r2)
   21c00:	e0fffe17 	ldw	r3,-8(fp)
   21c04:	18bfeb36 	bltu	r3,r2,21bb4 <alt_vic_irq_init+0x4c>
    {
        IOWR_ALTERA_VIC_INT_CONFIG(pdev->base, i, pdev->int_config[i]);
    }

    /* Set vector size and disable/enable daisy-chained input */
    for(i = 0; i < sizeof(VEC_SIZE_ARRAY)/sizeof(VEC_SIZE_ARRAY[0]); i++)
   21c08:	e03ffe15 	stw	zero,-8(fp)
   21c0c:	00001806 	br	21c70 <alt_vic_irq_init+0x108>
    {
        if(VEC_SIZE_ARRAY[i] == pdev->vec_size)
   21c10:	00c000b4 	movhi	r3,2
   21c14:	18dced04 	addi	r3,r3,29620
   21c18:	e0bffe17 	ldw	r2,-8(fp)
   21c1c:	1085883a 	add	r2,r2,r2
   21c20:	1085883a 	add	r2,r2,r2
   21c24:	1885883a 	add	r2,r3,r2
   21c28:	10800017 	ldw	r2,0(r2)
   21c2c:	1007883a 	mov	r3,r2
   21c30:	e0bfff17 	ldw	r2,-4(fp)
   21c34:	10800517 	ldw	r2,20(r2)
   21c38:	18800a1e 	bne	r3,r2,21c64 <alt_vic_irq_init+0xfc>
        {
            IOWR_ALTERA_VIC_CONFIG(pdev->base,
   21c3c:	e0bfff17 	ldw	r2,-4(fp)
   21c40:	10800017 	ldw	r2,0(r2)
   21c44:	10802804 	addi	r2,r2,160
   21c48:	e0ffff17 	ldw	r3,-4(fp)
   21c4c:	18c00417 	ldw	r3,16(r3)
   21c50:	180890fa 	slli	r4,r3,3
   21c54:	e0fffe17 	ldw	r3,-8(fp)
   21c58:	20c6b03a 	or	r3,r4,r3
   21c5c:	10c00035 	stwio	r3,0(r2)
                (i | (pdev->daisy_chain_present << ALTERA_VIC_CONFIG_DC_OFST)));
            break;
   21c60:	00000606 	br	21c7c <alt_vic_irq_init+0x114>
    {
        IOWR_ALTERA_VIC_INT_CONFIG(pdev->base, i, pdev->int_config[i]);
    }

    /* Set vector size and disable/enable daisy-chained input */
    for(i = 0; i < sizeof(VEC_SIZE_ARRAY)/sizeof(VEC_SIZE_ARRAY[0]); i++)
   21c64:	e0bffe17 	ldw	r2,-8(fp)
   21c68:	10800044 	addi	r2,r2,1
   21c6c:	e0bffe15 	stw	r2,-8(fp)
   21c70:	e0bffe17 	ldw	r2,-8(fp)
   21c74:	10800230 	cmpltui	r2,r2,8
   21c78:	103fe51e 	bne	r2,zero,21c10 <alt_vic_irq_init+0xa8>
            break;
        }
    }

    /* Set vector table base address */
    IOWR_ALTERA_VIC_VEC_TBL_BASE(pdev->base,((alt_u32)pdev->vec_addr));
   21c7c:	e0bfff17 	ldw	r2,-4(fp)
   21c80:	10800017 	ldw	r2,0(r2)
   21c84:	10802a04 	addi	r2,r2,168
   21c88:	e0ffff17 	ldw	r3,-4(fp)
   21c8c:	18c00617 	ldw	r3,24(r3)
   21c90:	10c00035 	stwio	r3,0(r2)
}
   21c94:	e037883a 	mov	sp,fp
   21c98:	df000017 	ldw	fp,0(sp)
   21c9c:	dec00104 	addi	sp,sp,4
   21ca0:	f800283a 	ret

00021ca4 <alt_ic_isr_register>:
int alt_ic_isr_register(alt_u32 ic_id,
                        alt_u32 irq,
                        alt_isr_func isr,
                        void *isr_context,
                        void* flags)
{
   21ca4:	defff504 	addi	sp,sp,-44
   21ca8:	df000a15 	stw	fp,40(sp)
   21cac:	df000a04 	addi	fp,sp,40
   21cb0:	e13ffc15 	stw	r4,-16(fp)
   21cb4:	e17ffd15 	stw	r5,-12(fp)
   21cb8:	e1bffe15 	stw	r6,-8(fp)
   21cbc:	e1ffff15 	stw	r7,-4(fp)
    alt_vic_dev *pdev;
    alt_u32 *offset;
    alt_irq_context status;

    if(ic_id >= ALT_NUM_EXTERNAL_INTERRUPT_CONTROLLERS)
   21cc0:	e0bffc17 	ldw	r2,-16(fp)
   21cc4:	10000226 	beq	r2,zero,21cd0 <alt_ic_isr_register+0x2c>
        return -1;
   21cc8:	00bfffc4 	movi	r2,-1
   21ccc:	00004706 	br	21dec <alt_ic_isr_register+0x148>

    /* Get VIC handle */
    pdev = alt_vic_dev_list[ic_id];
   21cd0:	00c000f4 	movhi	r3,3
   21cd4:	18eedd04 	addi	r3,r3,-17548
   21cd8:	e0bffc17 	ldw	r2,-16(fp)
   21cdc:	1085883a 	add	r2,r2,r2
   21ce0:	1085883a 	add	r2,r2,r2
   21ce4:	1885883a 	add	r2,r3,r2
   21ce8:	10800017 	ldw	r2,0(r2)
   21cec:	e0bff615 	stw	r2,-40(fp)

    if(irq < pdev->num_of_intr_ports)
   21cf0:	e0bff617 	ldw	r2,-40(fp)
   21cf4:	10800217 	ldw	r2,8(r2)
   21cf8:	e0fffd17 	ldw	r3,-12(fp)
   21cfc:	18803a2e 	bgeu	r3,r2,21de8 <alt_ic_isr_register+0x144>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   21d00:	0005303a 	rdctl	r2,status
   21d04:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   21d08:	e0fff917 	ldw	r3,-28(fp)
   21d0c:	00bfff84 	movi	r2,-2
   21d10:	1884703a 	and	r2,r3,r2
   21d14:	1001703a 	wrctl	status,r2
  
  return context;
   21d18:	e0bff917 	ldw	r2,-28(fp)
    {
        /* Disable all interrupts */
        status = alt_irq_disable_all ();
   21d1c:	e0bff715 	stw	r2,-36(fp)

        /* Get table offset */
        offset = pdev->vec_addr + (irq * pdev->vec_size);
   21d20:	e0bff617 	ldw	r2,-40(fp)
   21d24:	10c00617 	ldw	r3,24(r2)
   21d28:	e0bff617 	ldw	r2,-40(fp)
   21d2c:	11000517 	ldw	r4,20(r2)
   21d30:	e0bffd17 	ldw	r2,-12(fp)
   21d34:	2085383a 	mul	r2,r4,r2
   21d38:	1885883a 	add	r2,r3,r2
   21d3c:	e0bff815 	stw	r2,-32(fp)

        /* Write ISR and ISR context to vector table */
        ALT_VECTOR_TABLE_WRITE(offset+2, isr);
   21d40:	e0bff817 	ldw	r2,-32(fp)
   21d44:	10800204 	addi	r2,r2,8
   21d48:	e0fffe17 	ldw	r3,-8(fp)
   21d4c:	10c00015 	stw	r3,0(r2)
        ALT_VECTOR_TABLE_WRITE(offset+3, isr_context);
   21d50:	e0bff817 	ldw	r2,-32(fp)
   21d54:	10800304 	addi	r2,r2,12
   21d58:	e0ffff17 	ldw	r3,-4(fp)
   21d5c:	10c00015 	stw	r3,0(r2)

        if(isr)
   21d60:	e0bffe17 	ldw	r2,-8(fp)
   21d64:	10000826 	beq	r2,zero,21d88 <alt_ic_isr_register+0xe4>
        {
            /* Enable this IRQ on the VIC */
            IOWR_ALTERA_VIC_INT_ENABLE_SET(pdev->base, 1 << irq);
   21d68:	e0bff617 	ldw	r2,-40(fp)
   21d6c:	10800017 	ldw	r2,0(r2)
   21d70:	10802104 	addi	r2,r2,132
   21d74:	e0fffd17 	ldw	r3,-12(fp)
   21d78:	01000044 	movi	r4,1
   21d7c:	20c6983a 	sll	r3,r4,r3
   21d80:	10c00035 	stwio	r3,0(r2)
   21d84:	00000706 	br	21da4 <alt_ic_isr_register+0x100>
        }
        else
        {
            /* Disable this IRQ on the VIC */
            IOWR_ALTERA_VIC_INT_ENABLE_CLR(pdev->base, 1 << irq);
   21d88:	e0bff617 	ldw	r2,-40(fp)
   21d8c:	10800017 	ldw	r2,0(r2)
   21d90:	10802204 	addi	r2,r2,136
   21d94:	e0fffd17 	ldw	r3,-12(fp)
   21d98:	01000044 	movi	r4,1
   21d9c:	20c6983a 	sll	r3,r4,r3
   21da0:	10c00035 	stwio	r3,0(r2)
   21da4:	e0bff717 	ldw	r2,-36(fp)
   21da8:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   21dac:	0005303a 	rdctl	r2,status
   21db0:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   21db4:	e0fffb17 	ldw	r3,-20(fp)
   21db8:	00bfff84 	movi	r2,-2
   21dbc:	1884703a 	and	r2,r3,r2
   21dc0:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   21dc4:	e0bffa17 	ldw	r2,-24(fp)
   21dc8:	1080004c 	andi	r2,r2,1
   21dcc:	e0fffb17 	ldw	r3,-20(fp)
   21dd0:	1884b03a 	or	r2,r3,r2
   21dd4:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
   21dd8:	e0bffb17 	ldw	r2,-20(fp)
   21ddc:	1001703a 	wrctl	status,r2
        }

        /* Re-enable all interrupts */
        alt_irq_enable_all(status);

        return 0;
   21de0:	0005883a 	mov	r2,zero
   21de4:	00000106 	br	21dec <alt_ic_isr_register+0x148>
    }

    return -1;
   21de8:	00bfffc4 	movi	r2,-1
}
   21dec:	e037883a 	mov	sp,fp
   21df0:	df000017 	ldw	fp,0(sp)
   21df4:	dec00104 	addi	sp,sp,4
   21df8:	f800283a 	ret

00021dfc <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
   21dfc:	defffb04 	addi	sp,sp,-20
   21e00:	df000415 	stw	fp,16(sp)
   21e04:	df000404 	addi	fp,sp,16
   21e08:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
   21e0c:	008000c4 	movi	r2,3
   21e10:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
   21e14:	e0fffd17 	ldw	r3,-12(fp)
   21e18:	008003f4 	movhi	r2,15
   21e1c:	10909004 	addi	r2,r2,16960
   21e20:	1885383a 	mul	r2,r3,r2
   21e24:	00c17db4 	movhi	r3,1526
   21e28:	18f84004 	addi	r3,r3,-7936
   21e2c:	1885203a 	divu	r2,r3,r2
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
   21e30:	00e00034 	movhi	r3,32768
   21e34:	18ffffc4 	addi	r3,r3,-1
   21e38:	1885203a 	divu	r2,r3,r2
   21e3c:	e0ffff17 	ldw	r3,-4(fp)
   21e40:	1885203a 	divu	r2,r3,r2
   21e44:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
   21e48:	e0bffe17 	ldw	r2,-8(fp)
   21e4c:	10002526 	beq	r2,zero,21ee4 <alt_busy_sleep+0xe8>
  {
    for(i=0;i<big_loops;i++)
   21e50:	e03ffc15 	stw	zero,-16(fp)
   21e54:	00001406 	br	21ea8 <alt_busy_sleep+0xac>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
   21e58:	00a00034 	movhi	r2,32768
   21e5c:	10bfffc4 	addi	r2,r2,-1
   21e60:	10bfffc4 	addi	r2,r2,-1
   21e64:	103ffe1e 	bne	r2,zero,21e60 <alt_busy_sleep+0x64>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
   21e68:	e0fffd17 	ldw	r3,-12(fp)
   21e6c:	008003f4 	movhi	r2,15
   21e70:	10909004 	addi	r2,r2,16960
   21e74:	1885383a 	mul	r2,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
   21e78:	00c17db4 	movhi	r3,1526
   21e7c:	18f84004 	addi	r3,r3,-7936
   21e80:	1885203a 	divu	r2,r3,r2
   21e84:	00e00034 	movhi	r3,32768
   21e88:	18ffffc4 	addi	r3,r3,-1
   21e8c:	1885203a 	divu	r2,r3,r2
   21e90:	e0ffff17 	ldw	r3,-4(fp)
   21e94:	1885c83a 	sub	r2,r3,r2
   21e98:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
   21e9c:	e0bffc17 	ldw	r2,-16(fp)
   21ea0:	10800044 	addi	r2,r2,1
   21ea4:	e0bffc15 	stw	r2,-16(fp)
   21ea8:	e0fffc17 	ldw	r3,-16(fp)
   21eac:	e0bffe17 	ldw	r2,-8(fp)
   21eb0:	18bfe916 	blt	r3,r2,21e58 <alt_busy_sleep+0x5c>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
   21eb4:	e0fffd17 	ldw	r3,-12(fp)
   21eb8:	008003f4 	movhi	r2,15
   21ebc:	10909004 	addi	r2,r2,16960
   21ec0:	1885383a 	mul	r2,r3,r2
   21ec4:	00c17db4 	movhi	r3,1526
   21ec8:	18f84004 	addi	r3,r3,-7936
   21ecc:	1887203a 	divu	r3,r3,r2
   21ed0:	e0bfff17 	ldw	r2,-4(fp)
   21ed4:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
   21ed8:	10bfffc4 	addi	r2,r2,-1
   21edc:	103ffe1e 	bne	r2,zero,21ed8 <alt_busy_sleep+0xdc>
   21ee0:	00000b06 	br	21f10 <alt_busy_sleep+0x114>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
   21ee4:	e0fffd17 	ldw	r3,-12(fp)
   21ee8:	008003f4 	movhi	r2,15
   21eec:	10909004 	addi	r2,r2,16960
   21ef0:	1885383a 	mul	r2,r3,r2
   21ef4:	00c17db4 	movhi	r3,1526
   21ef8:	18f84004 	addi	r3,r3,-7936
   21efc:	1887203a 	divu	r3,r3,r2
   21f00:	e0bfff17 	ldw	r2,-4(fp)
   21f04:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
   21f08:	10bfffc4 	addi	r2,r2,-1
   21f0c:	00bffe16 	blt	zero,r2,21f08 <alt_busy_sleep+0x10c>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
   21f10:	0005883a 	mov	r2,zero
}
   21f14:	e037883a 	mov	sp,fp
   21f18:	df000017 	ldw	fp,0(sp)
   21f1c:	dec00104 	addi	sp,sp,4
   21f20:	f800283a 	ret

00021f24 <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
   21f24:	defffd04 	addi	sp,sp,-12
   21f28:	df000215 	stw	fp,8(sp)
   21f2c:	df000204 	addi	fp,sp,8
   21f30:	e13ffe15 	stw	r4,-8(fp)
   21f34:	e17fff15 	stw	r5,-4(fp)
  {
    ALT_FLUSH_DATA(i);
  }

#endif /* NIOS2_DCACHE_SIZE > 0 */
}
   21f38:	e037883a 	mov	sp,fp
   21f3c:	df000017 	ldw	fp,0(sp)
   21f40:	dec00104 	addi	sp,sp,4
   21f44:	f800283a 	ret

00021f48 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
   21f48:	deffff04 	addi	sp,sp,-4
   21f4c:	df000015 	stw	fp,0(sp)
   21f50:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
   21f54:	e037883a 	mov	sp,fp
   21f58:	df000017 	ldw	fp,0(sp)
   21f5c:	dec00104 	addi	sp,sp,4
   21f60:	f800283a 	ret

00021f64 <alt_get_errno>:
   21f64:	defffe04 	addi	sp,sp,-8
   21f68:	dfc00115 	stw	ra,4(sp)
   21f6c:	df000015 	stw	fp,0(sp)
   21f70:	d839883a 	mov	fp,sp
   21f74:	008000f4 	movhi	r2,3
   21f78:	10a61304 	addi	r2,r2,-26548
   21f7c:	10800017 	ldw	r2,0(r2)
   21f80:	10000526 	beq	r2,zero,21f98 <alt_get_errno+0x34>
   21f84:	008000f4 	movhi	r2,3
   21f88:	10a61304 	addi	r2,r2,-26548
   21f8c:	10800017 	ldw	r2,0(r2)
   21f90:	103ee83a 	callr	r2
   21f94:	00000206 	br	21fa0 <alt_get_errno+0x3c>
   21f98:	008000f4 	movhi	r2,3
   21f9c:	10aed404 	addi	r2,r2,-17584
   21fa0:	e037883a 	mov	sp,fp
   21fa4:	dfc00117 	ldw	ra,4(sp)
   21fa8:	df000017 	ldw	fp,0(sp)
   21fac:	dec00204 	addi	sp,sp,8
   21fb0:	f800283a 	ret

00021fb4 <alt_dev_llist_insert>:
   21fb4:	defffa04 	addi	sp,sp,-24
   21fb8:	dfc00515 	stw	ra,20(sp)
   21fbc:	df000415 	stw	fp,16(sp)
   21fc0:	df000404 	addi	fp,sp,16
   21fc4:	e13ffe15 	stw	r4,-8(fp)
   21fc8:	e17fff15 	stw	r5,-4(fp)
   21fcc:	e0bffe17 	ldw	r2,-8(fp)
   21fd0:	10000326 	beq	r2,zero,21fe0 <alt_dev_llist_insert+0x2c>
   21fd4:	e0bffe17 	ldw	r2,-8(fp)
   21fd8:	10800217 	ldw	r2,8(r2)
   21fdc:	1000051e 	bne	r2,zero,21ff4 <alt_dev_llist_insert+0x40>
   21fe0:	0021f640 	call	21f64 <alt_get_errno>
   21fe4:	00c00584 	movi	r3,22
   21fe8:	10c00015 	stw	r3,0(r2)
   21fec:	00bffa84 	movi	r2,-22
   21ff0:	00001306 	br	22040 <alt_dev_llist_insert+0x8c>
   21ff4:	e0bffe17 	ldw	r2,-8(fp)
   21ff8:	e0ffff17 	ldw	r3,-4(fp)
   21ffc:	e0fffc15 	stw	r3,-16(fp)
   22000:	e0bffd15 	stw	r2,-12(fp)
   22004:	e0bffd17 	ldw	r2,-12(fp)
   22008:	e0fffc17 	ldw	r3,-16(fp)
   2200c:	10c00115 	stw	r3,4(r2)
   22010:	e0bffc17 	ldw	r2,-16(fp)
   22014:	10c00017 	ldw	r3,0(r2)
   22018:	e0bffd17 	ldw	r2,-12(fp)
   2201c:	10c00015 	stw	r3,0(r2)
   22020:	e0bffc17 	ldw	r2,-16(fp)
   22024:	10800017 	ldw	r2,0(r2)
   22028:	e0fffd17 	ldw	r3,-12(fp)
   2202c:	10c00115 	stw	r3,4(r2)
   22030:	e0bffc17 	ldw	r2,-16(fp)
   22034:	e0fffd17 	ldw	r3,-12(fp)
   22038:	10c00015 	stw	r3,0(r2)
   2203c:	0005883a 	mov	r2,zero
   22040:	e037883a 	mov	sp,fp
   22044:	dfc00117 	ldw	ra,4(sp)
   22048:	df000017 	ldw	fp,0(sp)
   2204c:	dec00204 	addi	sp,sp,8
   22050:	f800283a 	ret

00022054 <_do_ctors>:
   22054:	defffd04 	addi	sp,sp,-12
   22058:	dfc00215 	stw	ra,8(sp)
   2205c:	df000115 	stw	fp,4(sp)
   22060:	df000104 	addi	fp,sp,4
   22064:	008000b4 	movhi	r2,2
   22068:	108d4a04 	addi	r2,r2,13608
   2206c:	e0bfff15 	stw	r2,-4(fp)
   22070:	00000606 	br	2208c <_do_ctors+0x38>
   22074:	e0bfff17 	ldw	r2,-4(fp)
   22078:	10800017 	ldw	r2,0(r2)
   2207c:	103ee83a 	callr	r2
   22080:	e0bfff17 	ldw	r2,-4(fp)
   22084:	10bfff04 	addi	r2,r2,-4
   22088:	e0bfff15 	stw	r2,-4(fp)
   2208c:	e0ffff17 	ldw	r3,-4(fp)
   22090:	008000b4 	movhi	r2,2
   22094:	108d4b04 	addi	r2,r2,13612
   22098:	18bff62e 	bgeu	r3,r2,22074 <_do_ctors+0x20>
   2209c:	e037883a 	mov	sp,fp
   220a0:	dfc00117 	ldw	ra,4(sp)
   220a4:	df000017 	ldw	fp,0(sp)
   220a8:	dec00204 	addi	sp,sp,8
   220ac:	f800283a 	ret

000220b0 <_do_dtors>:
   220b0:	defffd04 	addi	sp,sp,-12
   220b4:	dfc00215 	stw	ra,8(sp)
   220b8:	df000115 	stw	fp,4(sp)
   220bc:	df000104 	addi	fp,sp,4
   220c0:	008000b4 	movhi	r2,2
   220c4:	108d4a04 	addi	r2,r2,13608
   220c8:	e0bfff15 	stw	r2,-4(fp)
   220cc:	00000606 	br	220e8 <_do_dtors+0x38>
   220d0:	e0bfff17 	ldw	r2,-4(fp)
   220d4:	10800017 	ldw	r2,0(r2)
   220d8:	103ee83a 	callr	r2
   220dc:	e0bfff17 	ldw	r2,-4(fp)
   220e0:	10bfff04 	addi	r2,r2,-4
   220e4:	e0bfff15 	stw	r2,-4(fp)
   220e8:	e0ffff17 	ldw	r3,-4(fp)
   220ec:	008000b4 	movhi	r2,2
   220f0:	108d4b04 	addi	r2,r2,13612
   220f4:	18bff62e 	bgeu	r3,r2,220d0 <_do_dtors+0x20>
   220f8:	e037883a 	mov	sp,fp
   220fc:	dfc00117 	ldw	ra,4(sp)
   22100:	df000017 	ldw	fp,0(sp)
   22104:	dec00204 	addi	sp,sp,8
   22108:	f800283a 	ret

0002210c <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
   2210c:	defffa04 	addi	sp,sp,-24
   22110:	dfc00515 	stw	ra,20(sp)
   22114:	df000415 	stw	fp,16(sp)
   22118:	df000404 	addi	fp,sp,16
   2211c:	e13ffe15 	stw	r4,-8(fp)
   22120:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
   22124:	e0bfff17 	ldw	r2,-4(fp)
   22128:	10800017 	ldw	r2,0(r2)
   2212c:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
   22130:	e13ffe17 	ldw	r4,-8(fp)
   22134:	001075c0 	call	1075c <strlen>
   22138:	10800044 	addi	r2,r2,1
   2213c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   22140:	00000d06 	br	22178 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
   22144:	e0bffc17 	ldw	r2,-16(fp)
   22148:	10c00217 	ldw	r3,8(r2)
   2214c:	e0bffd17 	ldw	r2,-12(fp)
   22150:	1809883a 	mov	r4,r3
   22154:	e17ffe17 	ldw	r5,-8(fp)
   22158:	100d883a 	mov	r6,r2
   2215c:	00101bc0 	call	101bc <memcmp>
   22160:	1000021e 	bne	r2,zero,2216c <alt_find_dev+0x60>
    {
      /* match found */

      return next;
   22164:	e0bffc17 	ldw	r2,-16(fp)
   22168:	00000706 	br	22188 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
   2216c:	e0bffc17 	ldw	r2,-16(fp)
   22170:	10800017 	ldw	r2,0(r2)
   22174:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   22178:	e0fffc17 	ldw	r3,-16(fp)
   2217c:	e0bfff17 	ldw	r2,-4(fp)
   22180:	18bff01e 	bne	r3,r2,22144 <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
   22184:	0005883a 	mov	r2,zero
}
   22188:	e037883a 	mov	sp,fp
   2218c:	dfc00117 	ldw	ra,4(sp)
   22190:	df000017 	ldw	fp,0(sp)
   22194:	dec00204 	addi	sp,sp,8
   22198:	f800283a 	ret

0002219c <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
   2219c:	defffc04 	addi	sp,sp,-16
   221a0:	dfc00315 	stw	ra,12(sp)
   221a4:	df000215 	stw	fp,8(sp)
   221a8:	df000204 	addi	fp,sp,8
   221ac:	e13fff15 	stw	r4,-4(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
   221b0:	e13fff17 	ldw	r4,-4(fp)
   221b4:	d1601e04 	addi	r5,gp,-32648
   221b8:	002210c0 	call	2210c <alt_find_dev>
   221bc:	e0bffe15 	stw	r2,-8(fp)

  if ((dev) && dev->open)
   221c0:	e0bffe17 	ldw	r2,-8(fp)
   221c4:	10000926 	beq	r2,zero,221ec <alt_flash_open_dev+0x50>
   221c8:	e0bffe17 	ldw	r2,-8(fp)
   221cc:	10800317 	ldw	r2,12(r2)
   221d0:	10000626 	beq	r2,zero,221ec <alt_flash_open_dev+0x50>
  {
    return dev->open(dev, name);
   221d4:	e0bffe17 	ldw	r2,-8(fp)
   221d8:	10800317 	ldw	r2,12(r2)
   221dc:	e13ffe17 	ldw	r4,-8(fp)
   221e0:	e17fff17 	ldw	r5,-4(fp)
   221e4:	103ee83a 	callr	r2
   221e8:	00000106 	br	221f0 <alt_flash_open_dev+0x54>
  }

  return dev;
   221ec:	e0bffe17 	ldw	r2,-8(fp)
}
   221f0:	e037883a 	mov	sp,fp
   221f4:	dfc00117 	ldw	ra,4(sp)
   221f8:	df000017 	ldw	fp,0(sp)
   221fc:	dec00204 	addi	sp,sp,8
   22200:	f800283a 	ret

00022204 <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
   22204:	defffd04 	addi	sp,sp,-12
   22208:	dfc00215 	stw	ra,8(sp)
   2220c:	df000115 	stw	fp,4(sp)
   22210:	df000104 	addi	fp,sp,4
   22214:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
   22218:	e0bfff17 	ldw	r2,-4(fp)
   2221c:	10000726 	beq	r2,zero,2223c <alt_flash_close_dev+0x38>
   22220:	e0bfff17 	ldw	r2,-4(fp)
   22224:	10800417 	ldw	r2,16(r2)
   22228:	10000426 	beq	r2,zero,2223c <alt_flash_close_dev+0x38>
  {
    fd->close(fd);
   2222c:	e0bfff17 	ldw	r2,-4(fp)
   22230:	10800417 	ldw	r2,16(r2)
   22234:	e13fff17 	ldw	r4,-4(fp)
   22238:	103ee83a 	callr	r2
  }
  return;
   2223c:	0001883a 	nop
}
   22240:	e037883a 	mov	sp,fp
   22244:	dfc00117 	ldw	ra,4(sp)
   22248:	df000017 	ldw	fp,0(sp)
   2224c:	dec00204 	addi	sp,sp,8
   22250:	f800283a 	ret

00022254 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
   22254:	defffe04 	addi	sp,sp,-8
   22258:	dfc00115 	stw	ra,4(sp)
   2225c:	df000015 	stw	fp,0(sp)
   22260:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
   22264:	0009883a 	mov	r4,zero
   22268:	01440004 	movi	r5,4096
   2226c:	002308c0 	call	2308c <alt_icache_flush>
#endif
}
   22270:	e037883a 	mov	sp,fp
   22274:	dfc00117 	ldw	ra,4(sp)
   22278:	df000017 	ldw	fp,0(sp)
   2227c:	dec00204 	addi	sp,sp,8
   22280:	f800283a 	ret

00022284 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
   22284:	defff904 	addi	sp,sp,-28
   22288:	dfc00615 	stw	ra,24(sp)
   2228c:	df000515 	stw	fp,20(sp)
   22290:	df000504 	addi	fp,sp,20
   22294:	e13ffc15 	stw	r4,-16(fp)
   22298:	e17ffd15 	stw	r5,-12(fp)
   2229c:	e1bffe15 	stw	r6,-8(fp)
   222a0:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
   222a4:	e13ffd17 	ldw	r4,-12(fp)
   222a8:	e17ffe17 	ldw	r5,-8(fp)
   222ac:	e1bfff17 	ldw	r6,-4(fp)
   222b0:	00224d80 	call	224d8 <open>
   222b4:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
   222b8:	e0bffb17 	ldw	r2,-20(fp)
   222bc:	10001c16 	blt	r2,zero,22330 <alt_open_fd+0xac>
  {
    fd->dev      = alt_fd_list[old].dev;
   222c0:	00c000f4 	movhi	r3,3
   222c4:	18e03504 	addi	r3,r3,-32556
   222c8:	e0bffb17 	ldw	r2,-20(fp)
   222cc:	10800324 	muli	r2,r2,12
   222d0:	1885883a 	add	r2,r3,r2
   222d4:	10c00017 	ldw	r3,0(r2)
   222d8:	e0bffc17 	ldw	r2,-16(fp)
   222dc:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
   222e0:	00c000f4 	movhi	r3,3
   222e4:	18e03504 	addi	r3,r3,-32556
   222e8:	e0bffb17 	ldw	r2,-20(fp)
   222ec:	10800324 	muli	r2,r2,12
   222f0:	1885883a 	add	r2,r3,r2
   222f4:	10800104 	addi	r2,r2,4
   222f8:	10c00017 	ldw	r3,0(r2)
   222fc:	e0bffc17 	ldw	r2,-16(fp)
   22300:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
   22304:	00c000f4 	movhi	r3,3
   22308:	18e03504 	addi	r3,r3,-32556
   2230c:	e0bffb17 	ldw	r2,-20(fp)
   22310:	10800324 	muli	r2,r2,12
   22314:	1885883a 	add	r2,r3,r2
   22318:	10800204 	addi	r2,r2,8
   2231c:	10c00017 	ldw	r3,0(r2)
   22320:	e0bffc17 	ldw	r2,-16(fp)
   22324:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
   22328:	e13ffb17 	ldw	r4,-20(fp)
   2232c:	00191280 	call	19128 <alt_release_fd>
  }
} 
   22330:	e037883a 	mov	sp,fp
   22334:	dfc00117 	ldw	ra,4(sp)
   22338:	df000017 	ldw	fp,0(sp)
   2233c:	dec00204 	addi	sp,sp,8
   22340:	f800283a 	ret

00022344 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
   22344:	defffb04 	addi	sp,sp,-20
   22348:	dfc00415 	stw	ra,16(sp)
   2234c:	df000315 	stw	fp,12(sp)
   22350:	df000304 	addi	fp,sp,12
   22354:	e13ffd15 	stw	r4,-12(fp)
   22358:	e17ffe15 	stw	r5,-8(fp)
   2235c:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
   22360:	010000f4 	movhi	r4,3
   22364:	21203804 	addi	r4,r4,-32544
   22368:	e17ffd17 	ldw	r5,-12(fp)
   2236c:	01800044 	movi	r6,1
   22370:	01c07fc4 	movi	r7,511
   22374:	00222840 	call	22284 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
   22378:	010000f4 	movhi	r4,3
   2237c:	21203504 	addi	r4,r4,-32556
   22380:	e17ffe17 	ldw	r5,-8(fp)
   22384:	000d883a 	mov	r6,zero
   22388:	01c07fc4 	movi	r7,511
   2238c:	00222840 	call	22284 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
   22390:	010000f4 	movhi	r4,3
   22394:	21203b04 	addi	r4,r4,-32532
   22398:	e17fff17 	ldw	r5,-4(fp)
   2239c:	01800044 	movi	r6,1
   223a0:	01c07fc4 	movi	r7,511
   223a4:	00222840 	call	22284 <alt_open_fd>
}  
   223a8:	e037883a 	mov	sp,fp
   223ac:	dfc00117 	ldw	ra,4(sp)
   223b0:	df000017 	ldw	fp,0(sp)
   223b4:	dec00204 	addi	sp,sp,8
   223b8:	f800283a 	ret

000223bc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   223bc:	defffe04 	addi	sp,sp,-8
   223c0:	dfc00115 	stw	ra,4(sp)
   223c4:	df000015 	stw	fp,0(sp)
   223c8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   223cc:	008000f4 	movhi	r2,3
   223d0:	10a61304 	addi	r2,r2,-26548
   223d4:	10800017 	ldw	r2,0(r2)
   223d8:	10000526 	beq	r2,zero,223f0 <alt_get_errno+0x34>
   223dc:	008000f4 	movhi	r2,3
   223e0:	10a61304 	addi	r2,r2,-26548
   223e4:	10800017 	ldw	r2,0(r2)
   223e8:	103ee83a 	callr	r2
   223ec:	00000206 	br	223f8 <alt_get_errno+0x3c>
   223f0:	008000f4 	movhi	r2,3
   223f4:	10aed404 	addi	r2,r2,-17584
}
   223f8:	e037883a 	mov	sp,fp
   223fc:	dfc00117 	ldw	ra,4(sp)
   22400:	df000017 	ldw	fp,0(sp)
   22404:	dec00204 	addi	sp,sp,8
   22408:	f800283a 	ret

0002240c <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
   2240c:	defffd04 	addi	sp,sp,-12
   22410:	df000215 	stw	fp,8(sp)
   22414:	df000204 	addi	fp,sp,8
   22418:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
   2241c:	e0bfff17 	ldw	r2,-4(fp)
   22420:	10800217 	ldw	r2,8(r2)
   22424:	10d00034 	orhi	r3,r2,16384
   22428:	e0bfff17 	ldw	r2,-4(fp)
   2242c:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
   22430:	e03ffe15 	stw	zero,-8(fp)
   22434:	00001d06 	br	224ac <alt_file_locked+0xa0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
   22438:	00c000f4 	movhi	r3,3
   2243c:	18e03504 	addi	r3,r3,-32556
   22440:	e0bffe17 	ldw	r2,-8(fp)
   22444:	10800324 	muli	r2,r2,12
   22448:	1885883a 	add	r2,r3,r2
   2244c:	10c00017 	ldw	r3,0(r2)
   22450:	e0bfff17 	ldw	r2,-4(fp)
   22454:	10800017 	ldw	r2,0(r2)
   22458:	1880111e 	bne	r3,r2,224a0 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
   2245c:	00c000f4 	movhi	r3,3
   22460:	18e03504 	addi	r3,r3,-32556
   22464:	e0bffe17 	ldw	r2,-8(fp)
   22468:	10800324 	muli	r2,r2,12
   2246c:	1885883a 	add	r2,r3,r2
   22470:	10800204 	addi	r2,r2,8
   22474:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
   22478:	1000090e 	bge	r2,zero,224a0 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
   2247c:	e0bffe17 	ldw	r2,-8(fp)
   22480:	10c00324 	muli	r3,r2,12
   22484:	008000f4 	movhi	r2,3
   22488:	10a03504 	addi	r2,r2,-32556
   2248c:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
   22490:	e0bfff17 	ldw	r2,-4(fp)
   22494:	18800226 	beq	r3,r2,224a0 <alt_file_locked+0x94>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
   22498:	00bffcc4 	movi	r2,-13
   2249c:	00000a06 	br	224c8 <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
   224a0:	e0bffe17 	ldw	r2,-8(fp)
   224a4:	10800044 	addi	r2,r2,1
   224a8:	e0bffe15 	stw	r2,-8(fp)
   224ac:	008000f4 	movhi	r2,3
   224b0:	10a61204 	addi	r2,r2,-26552
   224b4:	10800017 	ldw	r2,0(r2)
   224b8:	1007883a 	mov	r3,r2
   224bc:	e0bffe17 	ldw	r2,-8(fp)
   224c0:	18bfdd2e 	bgeu	r3,r2,22438 <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
   224c4:	0005883a 	mov	r2,zero
}
   224c8:	e037883a 	mov	sp,fp
   224cc:	df000017 	ldw	fp,0(sp)
   224d0:	dec00104 	addi	sp,sp,4
   224d4:	f800283a 	ret

000224d8 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
   224d8:	defff604 	addi	sp,sp,-40
   224dc:	dfc00915 	stw	ra,36(sp)
   224e0:	df000815 	stw	fp,32(sp)
   224e4:	df000804 	addi	fp,sp,32
   224e8:	e13ffd15 	stw	r4,-12(fp)
   224ec:	e17ffe15 	stw	r5,-8(fp)
   224f0:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
   224f4:	00bfffc4 	movi	r2,-1
   224f8:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
   224fc:	00bffb44 	movi	r2,-19
   22500:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
   22504:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
   22508:	e13ffd17 	ldw	r4,-12(fp)
   2250c:	014000f4 	movhi	r5,3
   22510:	29661004 	addi	r5,r5,-26560
   22514:	002210c0 	call	2210c <alt_find_dev>
   22518:	e0bff815 	stw	r2,-32(fp)
   2251c:	e0bff817 	ldw	r2,-32(fp)
   22520:	1000051e 	bne	r2,zero,22538 <open+0x60>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
   22524:	e13ffd17 	ldw	r4,-12(fp)
   22528:	0022ec40 	call	22ec4 <alt_find_file>
   2252c:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
   22530:	00800044 	movi	r2,1
   22534:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
   22538:	e0bff817 	ldw	r2,-32(fp)
   2253c:	10002926 	beq	r2,zero,225e4 <open+0x10c>
  {
    if ((index = alt_get_fd (dev)) < 0)
   22540:	e13ff817 	ldw	r4,-32(fp)
   22544:	0022fd80 	call	22fd8 <alt_get_fd>
   22548:	e0bff915 	stw	r2,-28(fp)
   2254c:	e0bff917 	ldw	r2,-28(fp)
   22550:	1000030e 	bge	r2,zero,22560 <open+0x88>
    {
      status = index;
   22554:	e0bff917 	ldw	r2,-28(fp)
   22558:	e0bffa15 	stw	r2,-24(fp)
   2255c:	00002306 	br	225ec <open+0x114>
    }
    else
    {
      fd = &alt_fd_list[index];
   22560:	e0bff917 	ldw	r2,-28(fp)
   22564:	10c00324 	muli	r3,r2,12
   22568:	008000f4 	movhi	r2,3
   2256c:	10a03504 	addi	r2,r2,-32556
   22570:	1885883a 	add	r2,r3,r2
   22574:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
   22578:	e0fffe17 	ldw	r3,-8(fp)
   2257c:	00900034 	movhi	r2,16384
   22580:	10bfffc4 	addi	r2,r2,-1
   22584:	1886703a 	and	r3,r3,r2
   22588:	e0bffc17 	ldw	r2,-16(fp)
   2258c:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
   22590:	e0bffb17 	ldw	r2,-20(fp)
   22594:	1000051e 	bne	r2,zero,225ac <open+0xd4>
   22598:	e13ffc17 	ldw	r4,-16(fp)
   2259c:	002240c0 	call	2240c <alt_file_locked>
   225a0:	e0bffa15 	stw	r2,-24(fp)
   225a4:	e0bffa17 	ldw	r2,-24(fp)
   225a8:	10001016 	blt	r2,zero,225ec <open+0x114>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
   225ac:	e0bff817 	ldw	r2,-32(fp)
   225b0:	10800317 	ldw	r2,12(r2)
   225b4:	10000826 	beq	r2,zero,225d8 <open+0x100>
   225b8:	e0bff817 	ldw	r2,-32(fp)
   225bc:	10800317 	ldw	r2,12(r2)
   225c0:	e13ffc17 	ldw	r4,-16(fp)
   225c4:	e17ffd17 	ldw	r5,-12(fp)
   225c8:	e1bffe17 	ldw	r6,-8(fp)
   225cc:	e1ffff17 	ldw	r7,-4(fp)
   225d0:	103ee83a 	callr	r2
   225d4:	00000106 	br	225dc <open+0x104>
   225d8:	0005883a 	mov	r2,zero
   225dc:	e0bffa15 	stw	r2,-24(fp)
   225e0:	00000206 	br	225ec <open+0x114>
      }
    }
  }
  else
  {
    status = -ENODEV;
   225e4:	00bffb44 	movi	r2,-19
   225e8:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
   225ec:	e0bffa17 	ldw	r2,-24(fp)
   225f0:	1000080e 	bge	r2,zero,22614 <open+0x13c>
  {
    alt_release_fd (index);  
   225f4:	e13ff917 	ldw	r4,-28(fp)
   225f8:	00191280 	call	19128 <alt_release_fd>
    ALT_ERRNO = -status;
   225fc:	00223bc0 	call	223bc <alt_get_errno>
   22600:	e0fffa17 	ldw	r3,-24(fp)
   22604:	00c7c83a 	sub	r3,zero,r3
   22608:	10c00015 	stw	r3,0(r2)
    return -1;
   2260c:	00bfffc4 	movi	r2,-1
   22610:	00000106 	br	22618 <open+0x140>
  }
  
  /* return the reference upon success */

  return index;
   22614:	e0bff917 	ldw	r2,-28(fp)
}
   22618:	e037883a 	mov	sp,fp
   2261c:	dfc00117 	ldw	ra,4(sp)
   22620:	df000017 	ldw	fp,0(sp)
   22624:	dec00204 	addi	sp,sp,8
   22628:	f800283a 	ret

0002262c <alt_program_amd>:
   2262c:	defff704 	addi	sp,sp,-36
   22630:	dfc00815 	stw	ra,32(sp)
   22634:	df000715 	stw	fp,28(sp)
   22638:	df000704 	addi	fp,sp,28
   2263c:	e13ffc15 	stw	r4,-16(fp)
   22640:	e17ffd15 	stw	r5,-12(fp)
   22644:	e1bffe15 	stw	r6,-8(fp)
   22648:	e1ffff15 	stw	r7,-4(fp)
   2264c:	e03ffa15 	stw	zero,-24(fp)
   22650:	e0bffc17 	ldw	r2,-16(fp)
   22654:	e0bffb15 	stw	r2,-20(fp)
   22658:	008000b4 	movhi	r2,2
   2265c:	108a7004 	addi	r2,r2,10688
   22660:	d8800015 	stw	r2,0(sp)
   22664:	e13ffb17 	ldw	r4,-20(fp)
   22668:	e17ffe17 	ldw	r5,-8(fp)
   2266c:	e1bfff17 	ldw	r6,-4(fp)
   22670:	e1c00217 	ldw	r7,8(fp)
   22674:	0019dc80 	call	19dc8 <alt_flash_program_block>
   22678:	e0bffa15 	stw	r2,-24(fp)
   2267c:	e0bffa17 	ldw	r2,-24(fp)
   22680:	e037883a 	mov	sp,fp
   22684:	dfc00117 	ldw	ra,4(sp)
   22688:	df000017 	ldw	fp,0(sp)
   2268c:	dec00204 	addi	sp,sp,8
   22690:	f800283a 	ret

00022694 <alt_erase_block_amd>:
   22694:	defff804 	addi	sp,sp,-32
   22698:	dfc00715 	stw	ra,28(sp)
   2269c:	df000615 	stw	fp,24(sp)
   226a0:	df000604 	addi	fp,sp,24
   226a4:	e13ffe15 	stw	r4,-8(fp)
   226a8:	e17fff15 	stw	r5,-4(fp)
   226ac:	e03ffa15 	stw	zero,-24(fp)
   226b0:	e0bffe17 	ldw	r2,-8(fp)
   226b4:	e0bffc15 	stw	r2,-16(fp)
   226b8:	e0bffc17 	ldw	r2,-16(fp)
   226bc:	10c03317 	ldw	r3,204(r2)
   226c0:	e0bffc17 	ldw	r2,-16(fp)
   226c4:	10800a17 	ldw	r2,40(r2)
   226c8:	1009883a 	mov	r4,r2
   226cc:	01415544 	movi	r5,1365
   226d0:	01802a84 	movi	r6,170
   226d4:	183ee83a 	callr	r3
   226d8:	e0bffc17 	ldw	r2,-16(fp)
   226dc:	10c03317 	ldw	r3,204(r2)
   226e0:	e0bffc17 	ldw	r2,-16(fp)
   226e4:	10800a17 	ldw	r2,40(r2)
   226e8:	1009883a 	mov	r4,r2
   226ec:	0140aa84 	movi	r5,682
   226f0:	01801544 	movi	r6,85
   226f4:	183ee83a 	callr	r3
   226f8:	e0bffc17 	ldw	r2,-16(fp)
   226fc:	10c03317 	ldw	r3,204(r2)
   22700:	e0bffc17 	ldw	r2,-16(fp)
   22704:	10800a17 	ldw	r2,40(r2)
   22708:	1009883a 	mov	r4,r2
   2270c:	01415544 	movi	r5,1365
   22710:	01802004 	movi	r6,128
   22714:	183ee83a 	callr	r3
   22718:	e0bffc17 	ldw	r2,-16(fp)
   2271c:	10c03317 	ldw	r3,204(r2)
   22720:	e0bffc17 	ldw	r2,-16(fp)
   22724:	10800a17 	ldw	r2,40(r2)
   22728:	1009883a 	mov	r4,r2
   2272c:	01415544 	movi	r5,1365
   22730:	01802a84 	movi	r6,170
   22734:	183ee83a 	callr	r3
   22738:	e0bffc17 	ldw	r2,-16(fp)
   2273c:	10c03317 	ldw	r3,204(r2)
   22740:	e0bffc17 	ldw	r2,-16(fp)
   22744:	10800a17 	ldw	r2,40(r2)
   22748:	1009883a 	mov	r4,r2
   2274c:	0140aa84 	movi	r5,682
   22750:	01801544 	movi	r6,85
   22754:	183ee83a 	callr	r3
   22758:	e0bffc17 	ldw	r2,-16(fp)
   2275c:	10c03517 	ldw	r3,212(r2)
   22760:	e0bffc17 	ldw	r2,-16(fp)
   22764:	11000a17 	ldw	r4,40(r2)
   22768:	e0bfff17 	ldw	r2,-4(fp)
   2276c:	2085883a 	add	r2,r4,r2
   22770:	1009883a 	mov	r4,r2
   22774:	01400c04 	movi	r5,48
   22778:	183ee83a 	callr	r3
   2277c:	0109c404 	movi	r4,10000
   22780:	00194f00 	call	194f0 <usleep>
   22784:	00800c84 	movi	r2,50
   22788:	e0bffb15 	stw	r2,-20(fp)
   2278c:	e0bffc17 	ldw	r2,-16(fp)
   22790:	10c00a17 	ldw	r3,40(r2)
   22794:	e0bfff17 	ldw	r2,-4(fp)
   22798:	1885883a 	add	r2,r3,r2
   2279c:	10800023 	ldbuio	r2,0(r2)
   227a0:	10803fcc 	andi	r2,r2,255
   227a4:	e0bffd05 	stb	r2,-12(fp)
   227a8:	0100fa04 	movi	r4,1000
   227ac:	00194f00 	call	194f0 <usleep>
   227b0:	e0bffb17 	ldw	r2,-20(fp)
   227b4:	10bfffc4 	addi	r2,r2,-1
   227b8:	e0bffb15 	stw	r2,-20(fp)
   227bc:	e0bffd03 	ldbu	r2,-12(fp)
   227c0:	10803fcc 	andi	r2,r2,255
   227c4:	1080020c 	andi	r2,r2,8
   227c8:	1000021e 	bne	r2,zero,227d4 <alt_erase_block_amd+0x140>
   227cc:	e0bffb17 	ldw	r2,-20(fp)
   227d0:	00bfee16 	blt	zero,r2,2278c <alt_erase_block_amd+0xf8>
   227d4:	e0bffc17 	ldw	r2,-16(fp)
   227d8:	10803117 	ldw	r2,196(r2)
   227dc:	e0bffb15 	stw	r2,-20(fp)
   227e0:	00001506 	br	22838 <alt_erase_block_amd+0x1a4>
   227e4:	e0bffc17 	ldw	r2,-16(fp)
   227e8:	10c00a17 	ldw	r3,40(r2)
   227ec:	e0bfff17 	ldw	r2,-4(fp)
   227f0:	1885883a 	add	r2,r3,r2
   227f4:	10800023 	ldbuio	r2,0(r2)
   227f8:	10803fcc 	andi	r2,r2,255
   227fc:	e0bffd05 	stb	r2,-12(fp)
   22800:	e0bffd03 	ldbu	r2,-12(fp)
   22804:	10803fcc 	andi	r2,r2,255
   22808:	1080201c 	xori	r2,r2,128
   2280c:	10bfe004 	addi	r2,r2,-128
   22810:	10000b16 	blt	r2,zero,22840 <alt_erase_block_amd+0x1ac>
   22814:	e0bffd03 	ldbu	r2,-12(fp)
   22818:	10803fcc 	andi	r2,r2,255
   2281c:	1080080c 	andi	r2,r2,32
   22820:	1000071e 	bne	r2,zero,22840 <alt_erase_block_amd+0x1ac>
   22824:	0100fa04 	movi	r4,1000
   22828:	00194f00 	call	194f0 <usleep>
   2282c:	e0bffb17 	ldw	r2,-20(fp)
   22830:	10bf0604 	addi	r2,r2,-1000
   22834:	e0bffb15 	stw	r2,-20(fp)
   22838:	e0bffb17 	ldw	r2,-20(fp)
   2283c:	00bfe916 	blt	zero,r2,227e4 <alt_erase_block_amd+0x150>
   22840:	e0bffb17 	ldw	r2,-20(fp)
   22844:	00800316 	blt	zero,r2,22854 <alt_erase_block_amd+0x1c0>
   22848:	00bfe304 	movi	r2,-116
   2284c:	e0bffa15 	stw	r2,-24(fp)
   22850:	00000e06 	br	2288c <alt_erase_block_amd+0x1f8>
   22854:	e0bffc17 	ldw	r2,-16(fp)
   22858:	10c00a17 	ldw	r3,40(r2)
   2285c:	e0bfff17 	ldw	r2,-4(fp)
   22860:	1885883a 	add	r2,r3,r2
   22864:	10800023 	ldbuio	r2,0(r2)
   22868:	10803fcc 	andi	r2,r2,255
   2286c:	e0bffd05 	stb	r2,-12(fp)
   22870:	e0bffd03 	ldbu	r2,-12(fp)
   22874:	10803fcc 	andi	r2,r2,255
   22878:	1080201c 	xori	r2,r2,128
   2287c:	10bfe004 	addi	r2,r2,-128
   22880:	10000216 	blt	r2,zero,2288c <alt_erase_block_amd+0x1f8>
   22884:	00bffec4 	movi	r2,-5
   22888:	e0bffa15 	stw	r2,-24(fp)
   2288c:	e0bffa17 	ldw	r2,-24(fp)
   22890:	e037883a 	mov	sp,fp
   22894:	dfc00117 	ldw	ra,4(sp)
   22898:	df000017 	ldw	fp,0(sp)
   2289c:	dec00204 	addi	sp,sp,8
   228a0:	f800283a 	ret

000228a4 <alt_wait_for_command_to_complete_amd>:
   228a4:	defff804 	addi	sp,sp,-32
   228a8:	dfc00715 	stw	ra,28(sp)
   228ac:	df000615 	stw	fp,24(sp)
   228b0:	df000604 	addi	fp,sp,24
   228b4:	e13ffd15 	stw	r4,-12(fp)
   228b8:	e17ffe15 	stw	r5,-8(fp)
   228bc:	3005883a 	mov	r2,r6
   228c0:	e0bfff05 	stb	r2,-4(fp)
   228c4:	e0bffd17 	ldw	r2,-12(fp)
   228c8:	10803017 	ldw	r2,192(r2)
   228cc:	10801924 	muli	r2,r2,100
   228d0:	e0bffa15 	stw	r2,-24(fp)
   228d4:	e03ffb15 	stw	zero,-20(fp)
   228d8:	e0bffd17 	ldw	r2,-12(fp)
   228dc:	10c00a17 	ldw	r3,40(r2)
   228e0:	e0bffe17 	ldw	r2,-8(fp)
   228e4:	1885883a 	add	r2,r3,r2
   228e8:	10800023 	ldbuio	r2,0(r2)
   228ec:	10803fcc 	andi	r2,r2,255
   228f0:	e0bffc05 	stb	r2,-16(fp)
   228f4:	00001606 	br	22950 <alt_wait_for_command_to_complete_amd+0xac>
   228f8:	e0bffc03 	ldbu	r2,-16(fp)
   228fc:	10c03fcc 	andi	r3,r2,255
   22900:	e0bfff03 	ldbu	r2,-4(fp)
   22904:	1884f03a 	xor	r2,r3,r2
   22908:	1080200c 	andi	r2,r2,128
   2290c:	10001226 	beq	r2,zero,22958 <alt_wait_for_command_to_complete_amd+0xb4>
   22910:	e0bffc03 	ldbu	r2,-16(fp)
   22914:	10803fcc 	andi	r2,r2,255
   22918:	1080080c 	andi	r2,r2,32
   2291c:	10000e1e 	bne	r2,zero,22958 <alt_wait_for_command_to_complete_amd+0xb4>
   22920:	01000044 	movi	r4,1
   22924:	00194f00 	call	194f0 <usleep>
   22928:	e0bffa17 	ldw	r2,-24(fp)
   2292c:	10bfffc4 	addi	r2,r2,-1
   22930:	e0bffa15 	stw	r2,-24(fp)
   22934:	e0bffd17 	ldw	r2,-12(fp)
   22938:	10c00a17 	ldw	r3,40(r2)
   2293c:	e0bffe17 	ldw	r2,-8(fp)
   22940:	1885883a 	add	r2,r3,r2
   22944:	10800023 	ldbuio	r2,0(r2)
   22948:	10803fcc 	andi	r2,r2,255
   2294c:	e0bffc05 	stb	r2,-16(fp)
   22950:	e0bffa17 	ldw	r2,-24(fp)
   22954:	00bfe816 	blt	zero,r2,228f8 <alt_wait_for_command_to_complete_amd+0x54>
   22958:	e0bffa17 	ldw	r2,-24(fp)
   2295c:	1000031e 	bne	r2,zero,2296c <alt_wait_for_command_to_complete_amd+0xc8>
   22960:	00bfe304 	movi	r2,-116
   22964:	e0bffb15 	stw	r2,-20(fp)
   22968:	00000f06 	br	229a8 <alt_wait_for_command_to_complete_amd+0x104>
   2296c:	e0bffd17 	ldw	r2,-12(fp)
   22970:	10c00a17 	ldw	r3,40(r2)
   22974:	e0bffe17 	ldw	r2,-8(fp)
   22978:	1885883a 	add	r2,r3,r2
   2297c:	10800023 	ldbuio	r2,0(r2)
   22980:	10803fcc 	andi	r2,r2,255
   22984:	e0bffc05 	stb	r2,-16(fp)
   22988:	e0bffc03 	ldbu	r2,-16(fp)
   2298c:	10c03fcc 	andi	r3,r2,255
   22990:	e0bfff03 	ldbu	r2,-4(fp)
   22994:	1884f03a 	xor	r2,r3,r2
   22998:	1080200c 	andi	r2,r2,128
   2299c:	10000226 	beq	r2,zero,229a8 <alt_wait_for_command_to_complete_amd+0x104>
   229a0:	00bffec4 	movi	r2,-5
   229a4:	e0bffb15 	stw	r2,-20(fp)
   229a8:	e0bffb17 	ldw	r2,-20(fp)
   229ac:	e037883a 	mov	sp,fp
   229b0:	dfc00117 	ldw	ra,4(sp)
   229b4:	df000017 	ldw	fp,0(sp)
   229b8:	dec00204 	addi	sp,sp,8
   229bc:	f800283a 	ret

000229c0 <alt_write_word_amd>:
   229c0:	defff904 	addi	sp,sp,-28
   229c4:	dfc00615 	stw	ra,24(sp)
   229c8:	df000515 	stw	fp,20(sp)
   229cc:	df000504 	addi	fp,sp,20
   229d0:	e13ffd15 	stw	r4,-12(fp)
   229d4:	e17ffe15 	stw	r5,-8(fp)
   229d8:	e1bfff15 	stw	r6,-4(fp)
   229dc:	e03ffb15 	stw	zero,-20(fp)
   229e0:	e0bffd17 	ldw	r2,-12(fp)
   229e4:	10c03317 	ldw	r3,204(r2)
   229e8:	e0bffd17 	ldw	r2,-12(fp)
   229ec:	10800a17 	ldw	r2,40(r2)
   229f0:	1009883a 	mov	r4,r2
   229f4:	01415544 	movi	r5,1365
   229f8:	01802a84 	movi	r6,170
   229fc:	183ee83a 	callr	r3
   22a00:	e0bffd17 	ldw	r2,-12(fp)
   22a04:	10c03317 	ldw	r3,204(r2)
   22a08:	e0bffd17 	ldw	r2,-12(fp)
   22a0c:	10800a17 	ldw	r2,40(r2)
   22a10:	1009883a 	mov	r4,r2
   22a14:	0140aa84 	movi	r5,682
   22a18:	01801544 	movi	r6,85
   22a1c:	183ee83a 	callr	r3
   22a20:	e0bffd17 	ldw	r2,-12(fp)
   22a24:	10c03317 	ldw	r3,204(r2)
   22a28:	e0bffd17 	ldw	r2,-12(fp)
   22a2c:	10800a17 	ldw	r2,40(r2)
   22a30:	1009883a 	mov	r4,r2
   22a34:	01415544 	movi	r5,1365
   22a38:	01802804 	movi	r6,160
   22a3c:	183ee83a 	callr	r3
   22a40:	e0bfff17 	ldw	r2,-4(fp)
   22a44:	10800003 	ldbu	r2,0(r2)
   22a48:	e0bffc05 	stb	r2,-16(fp)
   22a4c:	e13ffd17 	ldw	r4,-12(fp)
   22a50:	e17ffe17 	ldw	r5,-8(fp)
   22a54:	e1bfff17 	ldw	r6,-4(fp)
   22a58:	0019c700 	call	19c70 <alt_write_value_to_flash>
   22a5c:	e0bffc03 	ldbu	r2,-16(fp)
   22a60:	e13ffd17 	ldw	r4,-12(fp)
   22a64:	e17ffe17 	ldw	r5,-8(fp)
   22a68:	100d883a 	mov	r6,r2
   22a6c:	00228a40 	call	228a4 <alt_wait_for_command_to_complete_amd>
   22a70:	e0bffb15 	stw	r2,-20(fp)
   22a74:	e0bffb17 	ldw	r2,-20(fp)
   22a78:	e037883a 	mov	sp,fp
   22a7c:	dfc00117 	ldw	ra,4(sp)
   22a80:	df000017 	ldw	fp,0(sp)
   22a84:	dec00204 	addi	sp,sp,8
   22a88:	f800283a 	ret

00022a8c <alt_program_intel>:
   22a8c:	defff704 	addi	sp,sp,-36
   22a90:	dfc00815 	stw	ra,32(sp)
   22a94:	df000715 	stw	fp,28(sp)
   22a98:	df000704 	addi	fp,sp,28
   22a9c:	e13ffc15 	stw	r4,-16(fp)
   22aa0:	e17ffd15 	stw	r5,-12(fp)
   22aa4:	e1bffe15 	stw	r6,-8(fp)
   22aa8:	e1ffff15 	stw	r7,-4(fp)
   22aac:	e03ffa15 	stw	zero,-24(fp)
   22ab0:	e0bffc17 	ldw	r2,-16(fp)
   22ab4:	e0bffb15 	stw	r2,-20(fp)
   22ab8:	e13ffb17 	ldw	r4,-20(fp)
   22abc:	e17ffd17 	ldw	r5,-12(fp)
   22ac0:	0022c740 	call	22c74 <alt_unlock_block_intel>
   22ac4:	e0bffa15 	stw	r2,-24(fp)
   22ac8:	e0bffa17 	ldw	r2,-24(fp)
   22acc:	1000091e 	bne	r2,zero,22af4 <alt_program_intel+0x68>
   22ad0:	008000b4 	movhi	r2,2
   22ad4:	108b7c04 	addi	r2,r2,11760
   22ad8:	d8800015 	stw	r2,0(sp)
   22adc:	e13ffb17 	ldw	r4,-20(fp)
   22ae0:	e17ffe17 	ldw	r5,-8(fp)
   22ae4:	e1bfff17 	ldw	r6,-4(fp)
   22ae8:	e1c00217 	ldw	r7,8(fp)
   22aec:	0019dc80 	call	19dc8 <alt_flash_program_block>
   22af0:	e0bffa15 	stw	r2,-24(fp)
   22af4:	e0bffa17 	ldw	r2,-24(fp)
   22af8:	e037883a 	mov	sp,fp
   22afc:	dfc00117 	ldw	ra,4(sp)
   22b00:	df000017 	ldw	fp,0(sp)
   22b04:	dec00204 	addi	sp,sp,8
   22b08:	f800283a 	ret

00022b0c <alt_erase_block_intel>:
   22b0c:	defff804 	addi	sp,sp,-32
   22b10:	dfc00715 	stw	ra,28(sp)
   22b14:	df000615 	stw	fp,24(sp)
   22b18:	df000604 	addi	fp,sp,24
   22b1c:	e13ffe15 	stw	r4,-8(fp)
   22b20:	e17fff15 	stw	r5,-4(fp)
   22b24:	e03ffa15 	stw	zero,-24(fp)
   22b28:	e0bffe17 	ldw	r2,-8(fp)
   22b2c:	e0bffc15 	stw	r2,-16(fp)
   22b30:	e0bffc17 	ldw	r2,-16(fp)
   22b34:	10803117 	ldw	r2,196(r2)
   22b38:	e0bffb15 	stw	r2,-20(fp)
   22b3c:	e13ffc17 	ldw	r4,-16(fp)
   22b40:	e17fff17 	ldw	r5,-4(fp)
   22b44:	0022c740 	call	22c74 <alt_unlock_block_intel>
   22b48:	e0bffa15 	stw	r2,-24(fp)
   22b4c:	e0bffa17 	ldw	r2,-24(fp)
   22b50:	1000421e 	bne	r2,zero,22c5c <alt_erase_block_intel+0x150>
   22b54:	e0bffc17 	ldw	r2,-16(fp)
   22b58:	10c03517 	ldw	r3,212(r2)
   22b5c:	e0bffc17 	ldw	r2,-16(fp)
   22b60:	11000a17 	ldw	r4,40(r2)
   22b64:	e0bfff17 	ldw	r2,-4(fp)
   22b68:	2085883a 	add	r2,r4,r2
   22b6c:	1009883a 	mov	r4,r2
   22b70:	01400804 	movi	r5,32
   22b74:	183ee83a 	callr	r3
   22b78:	e0bffc17 	ldw	r2,-16(fp)
   22b7c:	10c03517 	ldw	r3,212(r2)
   22b80:	e0bffc17 	ldw	r2,-16(fp)
   22b84:	11000a17 	ldw	r4,40(r2)
   22b88:	e0bfff17 	ldw	r2,-4(fp)
   22b8c:	2085883a 	add	r2,r4,r2
   22b90:	1009883a 	mov	r4,r2
   22b94:	01403404 	movi	r5,208
   22b98:	183ee83a 	callr	r3
   22b9c:	e0bffc17 	ldw	r2,-16(fp)
   22ba0:	10c00a17 	ldw	r3,40(r2)
   22ba4:	e0bfff17 	ldw	r2,-4(fp)
   22ba8:	1885883a 	add	r2,r3,r2
   22bac:	10800023 	ldbuio	r2,0(r2)
   22bb0:	10803fcc 	andi	r2,r2,255
   22bb4:	e0bffd05 	stb	r2,-12(fp)
   22bb8:	e0bffd03 	ldbu	r2,-12(fp)
   22bbc:	10803fcc 	andi	r2,r2,255
   22bc0:	1080201c 	xori	r2,r2,128
   22bc4:	10bfe004 	addi	r2,r2,-128
   22bc8:	10000816 	blt	r2,zero,22bec <alt_erase_block_intel+0xe0>
   22bcc:	0100fa04 	movi	r4,1000
   22bd0:	00194f00 	call	194f0 <usleep>
   22bd4:	e0bffb17 	ldw	r2,-20(fp)
   22bd8:	10bf0604 	addi	r2,r2,-1000
   22bdc:	e0bffb15 	stw	r2,-20(fp)
   22be0:	e0bffb17 	ldw	r2,-20(fp)
   22be4:	00bfed16 	blt	zero,r2,22b9c <alt_erase_block_intel+0x90>
   22be8:	00000106 	br	22bf0 <alt_erase_block_intel+0xe4>
   22bec:	0001883a 	nop
   22bf0:	e0bffb17 	ldw	r2,-20(fp)
   22bf4:	00800316 	blt	zero,r2,22c04 <alt_erase_block_intel+0xf8>
   22bf8:	00bfe304 	movi	r2,-116
   22bfc:	e0bffa15 	stw	r2,-24(fp)
   22c00:	00000d06 	br	22c38 <alt_erase_block_intel+0x12c>
   22c04:	e0bffd03 	ldbu	r2,-12(fp)
   22c08:	10803fcc 	andi	r2,r2,255
   22c0c:	10801fcc 	andi	r2,r2,127
   22c10:	10000926 	beq	r2,zero,22c38 <alt_erase_block_intel+0x12c>
   22c14:	00bffec4 	movi	r2,-5
   22c18:	e0bffa15 	stw	r2,-24(fp)
   22c1c:	e0bffc17 	ldw	r2,-16(fp)
   22c20:	10c00a17 	ldw	r3,40(r2)
   22c24:	e0bfff17 	ldw	r2,-4(fp)
   22c28:	1885883a 	add	r2,r3,r2
   22c2c:	10800023 	ldbuio	r2,0(r2)
   22c30:	10803fcc 	andi	r2,r2,255
   22c34:	e0bffd05 	stb	r2,-12(fp)
   22c38:	e0bffc17 	ldw	r2,-16(fp)
   22c3c:	10c03517 	ldw	r3,212(r2)
   22c40:	e0bffc17 	ldw	r2,-16(fp)
   22c44:	11000a17 	ldw	r4,40(r2)
   22c48:	e0bfff17 	ldw	r2,-4(fp)
   22c4c:	2085883a 	add	r2,r4,r2
   22c50:	1009883a 	mov	r4,r2
   22c54:	01403fc4 	movi	r5,255
   22c58:	183ee83a 	callr	r3
   22c5c:	e0bffa17 	ldw	r2,-24(fp)
   22c60:	e037883a 	mov	sp,fp
   22c64:	dfc00117 	ldw	ra,4(sp)
   22c68:	df000017 	ldw	fp,0(sp)
   22c6c:	dec00204 	addi	sp,sp,8
   22c70:	f800283a 	ret

00022c74 <alt_unlock_block_intel>:
   22c74:	defff904 	addi	sp,sp,-28
   22c78:	dfc00615 	stw	ra,24(sp)
   22c7c:	df000515 	stw	fp,20(sp)
   22c80:	df000504 	addi	fp,sp,20
   22c84:	e13ffe15 	stw	r4,-8(fp)
   22c88:	e17fff15 	stw	r5,-4(fp)
   22c8c:	e03ffb15 	stw	zero,-20(fp)
   22c90:	e0bffe17 	ldw	r2,-8(fp)
   22c94:	10803017 	ldw	r2,192(r2)
   22c98:	10801924 	muli	r2,r2,100
   22c9c:	e0bffc15 	stw	r2,-16(fp)
   22ca0:	e0bffe17 	ldw	r2,-8(fp)
   22ca4:	10c03517 	ldw	r3,212(r2)
   22ca8:	e0bffe17 	ldw	r2,-8(fp)
   22cac:	11000a17 	ldw	r4,40(r2)
   22cb0:	e0bfff17 	ldw	r2,-4(fp)
   22cb4:	2085883a 	add	r2,r4,r2
   22cb8:	1009883a 	mov	r4,r2
   22cbc:	01402404 	movi	r5,144
   22cc0:	183ee83a 	callr	r3
   22cc4:	e0bffe17 	ldw	r2,-8(fp)
   22cc8:	10c00a17 	ldw	r3,40(r2)
   22ccc:	e0bfff17 	ldw	r2,-4(fp)
   22cd0:	10800104 	addi	r2,r2,4
   22cd4:	1885883a 	add	r2,r3,r2
   22cd8:	10800023 	ldbuio	r2,0(r2)
   22cdc:	10803fcc 	andi	r2,r2,255
   22ce0:	e0bffd05 	stb	r2,-12(fp)
   22ce4:	e0bffd03 	ldbu	r2,-12(fp)
   22ce8:	1080004c 	andi	r2,r2,1
   22cec:	10003126 	beq	r2,zero,22db4 <alt_unlock_block_intel+0x140>
   22cf0:	e0bffe17 	ldw	r2,-8(fp)
   22cf4:	10c03517 	ldw	r3,212(r2)
   22cf8:	e0bffe17 	ldw	r2,-8(fp)
   22cfc:	11000a17 	ldw	r4,40(r2)
   22d00:	e0bfff17 	ldw	r2,-4(fp)
   22d04:	2085883a 	add	r2,r4,r2
   22d08:	1009883a 	mov	r4,r2
   22d0c:	01401804 	movi	r5,96
   22d10:	183ee83a 	callr	r3
   22d14:	e0bffe17 	ldw	r2,-8(fp)
   22d18:	10c03517 	ldw	r3,212(r2)
   22d1c:	e0bffe17 	ldw	r2,-8(fp)
   22d20:	11000a17 	ldw	r4,40(r2)
   22d24:	e0bfff17 	ldw	r2,-4(fp)
   22d28:	2085883a 	add	r2,r4,r2
   22d2c:	1009883a 	mov	r4,r2
   22d30:	01403404 	movi	r5,208
   22d34:	183ee83a 	callr	r3
   22d38:	e0bffe17 	ldw	r2,-8(fp)
   22d3c:	10c00a17 	ldw	r3,40(r2)
   22d40:	e0bfff17 	ldw	r2,-4(fp)
   22d44:	1885883a 	add	r2,r3,r2
   22d48:	10800023 	ldbuio	r2,0(r2)
   22d4c:	10803fcc 	andi	r2,r2,255
   22d50:	e0bffd45 	stb	r2,-11(fp)
   22d54:	e0bffd43 	ldbu	r2,-11(fp)
   22d58:	10803fcc 	andi	r2,r2,255
   22d5c:	1080201c 	xori	r2,r2,128
   22d60:	10bfe004 	addi	r2,r2,-128
   22d64:	10000816 	blt	r2,zero,22d88 <alt_unlock_block_intel+0x114>
   22d68:	e0bffc17 	ldw	r2,-16(fp)
   22d6c:	10bfffc4 	addi	r2,r2,-1
   22d70:	e0bffc15 	stw	r2,-16(fp)
   22d74:	01000044 	movi	r4,1
   22d78:	00194f00 	call	194f0 <usleep>
   22d7c:	e0bffc17 	ldw	r2,-16(fp)
   22d80:	00bfed16 	blt	zero,r2,22d38 <alt_unlock_block_intel+0xc4>
   22d84:	00000106 	br	22d8c <alt_unlock_block_intel+0x118>
   22d88:	0001883a 	nop
   22d8c:	e0bffc17 	ldw	r2,-16(fp)
   22d90:	1000031e 	bne	r2,zero,22da0 <alt_unlock_block_intel+0x12c>
   22d94:	00bfe304 	movi	r2,-116
   22d98:	e0bffb15 	stw	r2,-20(fp)
   22d9c:	00000506 	br	22db4 <alt_unlock_block_intel+0x140>
   22da0:	e0bffd43 	ldbu	r2,-11(fp)
   22da4:	10801fcc 	andi	r2,r2,127
   22da8:	10000226 	beq	r2,zero,22db4 <alt_unlock_block_intel+0x140>
   22dac:	00bffec4 	movi	r2,-5
   22db0:	e0bffb15 	stw	r2,-20(fp)
   22db4:	e0bffe17 	ldw	r2,-8(fp)
   22db8:	10c03517 	ldw	r3,212(r2)
   22dbc:	e0bffe17 	ldw	r2,-8(fp)
   22dc0:	11000a17 	ldw	r4,40(r2)
   22dc4:	e0bfff17 	ldw	r2,-4(fp)
   22dc8:	2085883a 	add	r2,r4,r2
   22dcc:	1009883a 	mov	r4,r2
   22dd0:	01403fc4 	movi	r5,255
   22dd4:	183ee83a 	callr	r3
   22dd8:	e0bffb17 	ldw	r2,-20(fp)
   22ddc:	e037883a 	mov	sp,fp
   22de0:	dfc00117 	ldw	ra,4(sp)
   22de4:	df000017 	ldw	fp,0(sp)
   22de8:	dec00204 	addi	sp,sp,8
   22dec:	f800283a 	ret

00022df0 <alt_write_word_intel>:
   22df0:	defff904 	addi	sp,sp,-28
   22df4:	dfc00615 	stw	ra,24(sp)
   22df8:	df000515 	stw	fp,20(sp)
   22dfc:	df000504 	addi	fp,sp,20
   22e00:	e13ffd15 	stw	r4,-12(fp)
   22e04:	e17ffe15 	stw	r5,-8(fp)
   22e08:	e1bfff15 	stw	r6,-4(fp)
   22e0c:	e03ffb15 	stw	zero,-20(fp)
   22e10:	e0bffd17 	ldw	r2,-12(fp)
   22e14:	10c03517 	ldw	r3,212(r2)
   22e18:	e0bffd17 	ldw	r2,-12(fp)
   22e1c:	11000a17 	ldw	r4,40(r2)
   22e20:	e0bffe17 	ldw	r2,-8(fp)
   22e24:	2085883a 	add	r2,r4,r2
   22e28:	1009883a 	mov	r4,r2
   22e2c:	01401004 	movi	r5,64
   22e30:	183ee83a 	callr	r3
   22e34:	e13ffd17 	ldw	r4,-12(fp)
   22e38:	e17ffe17 	ldw	r5,-8(fp)
   22e3c:	e1bfff17 	ldw	r6,-4(fp)
   22e40:	0019c700 	call	19c70 <alt_write_value_to_flash>
   22e44:	e0bffd17 	ldw	r2,-12(fp)
   22e48:	10c00a17 	ldw	r3,40(r2)
   22e4c:	e0bffe17 	ldw	r2,-8(fp)
   22e50:	1885883a 	add	r2,r3,r2
   22e54:	10800023 	ldbuio	r2,0(r2)
   22e58:	10803fcc 	andi	r2,r2,255
   22e5c:	e0bffc05 	stb	r2,-16(fp)
   22e60:	e0bffc03 	ldbu	r2,-16(fp)
   22e64:	10803fcc 	andi	r2,r2,255
   22e68:	1080201c 	xori	r2,r2,128
   22e6c:	10bfe004 	addi	r2,r2,-128
   22e70:	103ff40e 	bge	r2,zero,22e44 <alt_write_word_intel+0x54>
   22e74:	e0bffc03 	ldbu	r2,-16(fp)
   22e78:	10801fcc 	andi	r2,r2,127
   22e7c:	10000226 	beq	r2,zero,22e88 <alt_write_word_intel+0x98>
   22e80:	00bffec4 	movi	r2,-5
   22e84:	e0bffb15 	stw	r2,-20(fp)
   22e88:	e0bffd17 	ldw	r2,-12(fp)
   22e8c:	10c03517 	ldw	r3,212(r2)
   22e90:	e0bffd17 	ldw	r2,-12(fp)
   22e94:	11000a17 	ldw	r4,40(r2)
   22e98:	e0bffe17 	ldw	r2,-8(fp)
   22e9c:	2085883a 	add	r2,r4,r2
   22ea0:	1009883a 	mov	r4,r2
   22ea4:	01403fc4 	movi	r5,255
   22ea8:	183ee83a 	callr	r3
   22eac:	e0bffb17 	ldw	r2,-20(fp)
   22eb0:	e037883a 	mov	sp,fp
   22eb4:	dfc00117 	ldw	ra,4(sp)
   22eb8:	df000017 	ldw	fp,0(sp)
   22ebc:	dec00204 	addi	sp,sp,8
   22ec0:	f800283a 	ret

00022ec4 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
   22ec4:	defffb04 	addi	sp,sp,-20
   22ec8:	dfc00415 	stw	ra,16(sp)
   22ecc:	df000315 	stw	fp,12(sp)
   22ed0:	df000304 	addi	fp,sp,12
   22ed4:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
   22ed8:	008000f4 	movhi	r2,3
   22edc:	10a60e04 	addi	r2,r2,-26568
   22ee0:	10800017 	ldw	r2,0(r2)
   22ee4:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
   22ee8:	00003106 	br	22fb0 <alt_find_file+0xec>
  {
    len = strlen(next->name);
   22eec:	e0bffd17 	ldw	r2,-12(fp)
   22ef0:	10800217 	ldw	r2,8(r2)
   22ef4:	1009883a 	mov	r4,r2
   22ef8:	001075c0 	call	1075c <strlen>
   22efc:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
   22f00:	e0bffd17 	ldw	r2,-12(fp)
   22f04:	10c00217 	ldw	r3,8(r2)
   22f08:	e0bffe17 	ldw	r2,-8(fp)
   22f0c:	10bfffc4 	addi	r2,r2,-1
   22f10:	1885883a 	add	r2,r3,r2
   22f14:	10800003 	ldbu	r2,0(r2)
   22f18:	10803fcc 	andi	r2,r2,255
   22f1c:	1080201c 	xori	r2,r2,128
   22f20:	10bfe004 	addi	r2,r2,-128
   22f24:	10800bd8 	cmpnei	r2,r2,47
   22f28:	1000031e 	bne	r2,zero,22f38 <alt_find_file+0x74>
    {
      len -= 1;
   22f2c:	e0bffe17 	ldw	r2,-8(fp)
   22f30:	10bfffc4 	addi	r2,r2,-1
   22f34:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
   22f38:	e0bffe17 	ldw	r2,-8(fp)
   22f3c:	e0ffff17 	ldw	r3,-4(fp)
   22f40:	1885883a 	add	r2,r3,r2
   22f44:	10800003 	ldbu	r2,0(r2)
   22f48:	10803fcc 	andi	r2,r2,255
   22f4c:	1080201c 	xori	r2,r2,128
   22f50:	10bfe004 	addi	r2,r2,-128
   22f54:	10800be0 	cmpeqi	r2,r2,47
   22f58:	1000081e 	bne	r2,zero,22f7c <alt_find_file+0xb8>
   22f5c:	e0bffe17 	ldw	r2,-8(fp)
   22f60:	e0ffff17 	ldw	r3,-4(fp)
   22f64:	1885883a 	add	r2,r3,r2
   22f68:	10800003 	ldbu	r2,0(r2)
   22f6c:	10803fcc 	andi	r2,r2,255
   22f70:	1080201c 	xori	r2,r2,128
   22f74:	10bfe004 	addi	r2,r2,-128
   22f78:	10000a1e 	bne	r2,zero,22fa4 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
   22f7c:	e0bffd17 	ldw	r2,-12(fp)
   22f80:	10c00217 	ldw	r3,8(r2)
   22f84:	e0bffe17 	ldw	r2,-8(fp)
   22f88:	1809883a 	mov	r4,r3
   22f8c:	e17fff17 	ldw	r5,-4(fp)
   22f90:	100d883a 	mov	r6,r2
   22f94:	00101bc0 	call	101bc <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
   22f98:	1000021e 	bne	r2,zero,22fa4 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
   22f9c:	e0bffd17 	ldw	r2,-12(fp)
   22fa0:	00000806 	br	22fc4 <alt_find_file+0x100>
    }
    next = (alt_dev*) next->llist.next;
   22fa4:	e0bffd17 	ldw	r2,-12(fp)
   22fa8:	10800017 	ldw	r2,0(r2)
   22fac:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
   22fb0:	e0fffd17 	ldw	r3,-12(fp)
   22fb4:	008000f4 	movhi	r2,3
   22fb8:	10a60e04 	addi	r2,r2,-26568
   22fbc:	18bfcb1e 	bne	r3,r2,22eec <alt_find_file+0x28>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
   22fc0:	0005883a 	mov	r2,zero
}
   22fc4:	e037883a 	mov	sp,fp
   22fc8:	dfc00117 	ldw	ra,4(sp)
   22fcc:	df000017 	ldw	fp,0(sp)
   22fd0:	dec00204 	addi	sp,sp,8
   22fd4:	f800283a 	ret

00022fd8 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
   22fd8:	defffc04 	addi	sp,sp,-16
   22fdc:	df000315 	stw	fp,12(sp)
   22fe0:	df000304 	addi	fp,sp,12
   22fe4:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
   22fe8:	00bffa04 	movi	r2,-24
   22fec:	e0bffe15 	stw	r2,-8(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
   22ff0:	e03ffd15 	stw	zero,-12(fp)
   22ff4:	00001d06 	br	2306c <alt_get_fd+0x94>
  {
    if (!alt_fd_list[i].dev)
   22ff8:	00c000f4 	movhi	r3,3
   22ffc:	18e03504 	addi	r3,r3,-32556
   23000:	e0bffd17 	ldw	r2,-12(fp)
   23004:	10800324 	muli	r2,r2,12
   23008:	1885883a 	add	r2,r3,r2
   2300c:	10800017 	ldw	r2,0(r2)
   23010:	1000131e 	bne	r2,zero,23060 <alt_get_fd+0x88>
    {
      alt_fd_list[i].dev = dev;
   23014:	00c000f4 	movhi	r3,3
   23018:	18e03504 	addi	r3,r3,-32556
   2301c:	e0bffd17 	ldw	r2,-12(fp)
   23020:	10800324 	muli	r2,r2,12
   23024:	1885883a 	add	r2,r3,r2
   23028:	e0ffff17 	ldw	r3,-4(fp)
   2302c:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
   23030:	008000f4 	movhi	r2,3
   23034:	10a61204 	addi	r2,r2,-26552
   23038:	10c00017 	ldw	r3,0(r2)
   2303c:	e0bffd17 	ldw	r2,-12(fp)
   23040:	1880040e 	bge	r3,r2,23054 <alt_get_fd+0x7c>
      {
        alt_max_fd = i;
   23044:	008000f4 	movhi	r2,3
   23048:	10a61204 	addi	r2,r2,-26552
   2304c:	e0fffd17 	ldw	r3,-12(fp)
   23050:	10c00015 	stw	r3,0(r2)
      }
      rc = i;
   23054:	e0bffd17 	ldw	r2,-12(fp)
   23058:	e0bffe15 	stw	r2,-8(fp)
      goto alt_get_fd_exit;
   2305c:	00000606 	br	23078 <alt_get_fd+0xa0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
   23060:	e0bffd17 	ldw	r2,-12(fp)
   23064:	10800044 	addi	r2,r2,1
   23068:	e0bffd15 	stw	r2,-12(fp)
   2306c:	e0bffd17 	ldw	r2,-12(fp)
   23070:	10800810 	cmplti	r2,r2,32
   23074:	103fe01e 	bne	r2,zero,22ff8 <alt_get_fd+0x20>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
   23078:	e0bffe17 	ldw	r2,-8(fp)
}
   2307c:	e037883a 	mov	sp,fp
   23080:	df000017 	ldw	fp,0(sp)
   23084:	dec00104 	addi	sp,sp,4
   23088:	f800283a 	ret

0002308c <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
   2308c:	defffb04 	addi	sp,sp,-20
   23090:	df000415 	stw	fp,16(sp)
   23094:	df000404 	addi	fp,sp,16
   23098:	e13ffe15 	stw	r4,-8(fp)
   2309c:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
   230a0:	e0bfff17 	ldw	r2,-4(fp)
   230a4:	10840070 	cmpltui	r2,r2,4097
   230a8:	1000021e 	bne	r2,zero,230b4 <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
   230ac:	00840004 	movi	r2,4096
   230b0:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
   230b4:	e0fffe17 	ldw	r3,-8(fp)
   230b8:	e0bfff17 	ldw	r2,-4(fp)
   230bc:	1885883a 	add	r2,r3,r2
   230c0:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
   230c4:	e0bffe17 	ldw	r2,-8(fp)
   230c8:	e0bffc15 	stw	r2,-16(fp)
   230cc:	00000506 	br	230e4 <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
   230d0:	e0bffc17 	ldw	r2,-16(fp)
   230d4:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
   230d8:	e0bffc17 	ldw	r2,-16(fp)
   230dc:	10800804 	addi	r2,r2,32
   230e0:	e0bffc15 	stw	r2,-16(fp)
   230e4:	e0fffc17 	ldw	r3,-16(fp)
   230e8:	e0bffd17 	ldw	r2,-12(fp)
   230ec:	18bff836 	bltu	r3,r2,230d0 <alt_icache_flush+0x44>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
   230f0:	e0bffe17 	ldw	r2,-8(fp)
   230f4:	108007cc 	andi	r2,r2,31
   230f8:	10000226 	beq	r2,zero,23104 <alt_icache_flush+0x78>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
   230fc:	e0bffc17 	ldw	r2,-16(fp)
   23100:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
   23104:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
   23108:	e037883a 	mov	sp,fp
   2310c:	df000017 	ldw	fp,0(sp)
   23110:	dec00104 	addi	sp,sp,4
   23114:	f800283a 	ret

00023118 <atexit>:
   23118:	200b883a 	mov	r5,r4
   2311c:	000d883a 	mov	r6,zero
   23120:	0009883a 	mov	r4,zero
   23124:	000f883a 	mov	r7,zero
   23128:	00232201 	jmpi	23220 <__register_exitproc>

0002312c <exit>:
   2312c:	defffe04 	addi	sp,sp,-8
   23130:	000b883a 	mov	r5,zero
   23134:	dc000015 	stw	r16,0(sp)
   23138:	dfc00115 	stw	ra,4(sp)
   2313c:	2021883a 	mov	r16,r4
   23140:	00233500 	call	23350 <__call_exitprocs>
   23144:	008000f4 	movhi	r2,3
   23148:	10a60904 	addi	r2,r2,-26588
   2314c:	11000017 	ldw	r4,0(r2)
   23150:	20800f17 	ldw	r2,60(r4)
   23154:	10000126 	beq	r2,zero,2315c <exit+0x30>
   23158:	103ee83a 	callr	r2
   2315c:	8009883a 	mov	r4,r16
   23160:	00234f00 	call	234f0 <_exit>

00023164 <malloc>:
   23164:	008000f4 	movhi	r2,3
   23168:	10a60a04 	addi	r2,r2,-26584
   2316c:	200b883a 	mov	r5,r4
   23170:	11000017 	ldw	r4,0(r2)
   23174:	00153e81 	jmpi	153e8 <_malloc_r>

00023178 <free>:
   23178:	008000f4 	movhi	r2,3
   2317c:	10a60a04 	addi	r2,r2,-26584
   23180:	200b883a 	mov	r5,r4
   23184:	11000017 	ldw	r4,0(r2)
   23188:	00148501 	jmpi	14850 <_free_r>

0002318c <strcpy>:
   2318c:	2906b03a 	or	r3,r5,r4
   23190:	18c000cc 	andi	r3,r3,3
   23194:	2005883a 	mov	r2,r4
   23198:	18001a1e 	bne	r3,zero,23204 <strcpy+0x78>
   2319c:	29800017 	ldw	r6,0(r5)
   231a0:	02bfbff4 	movhi	r10,65279
   231a4:	52bfbfc4 	addi	r10,r10,-257
   231a8:	02602074 	movhi	r9,32897
   231ac:	4a602004 	addi	r9,r9,-32640
   231b0:	0188303a 	nor	r4,zero,r6
   231b4:	3287883a 	add	r3,r6,r10
   231b8:	20c6703a 	and	r3,r4,r3
   231bc:	1a46703a 	and	r3,r3,r9
   231c0:	1800101e 	bne	r3,zero,23204 <strcpy+0x78>
   231c4:	1007883a 	mov	r3,r2
   231c8:	19800015 	stw	r6,0(r3)
   231cc:	29400104 	addi	r5,r5,4
   231d0:	29800017 	ldw	r6,0(r5)
   231d4:	18c00104 	addi	r3,r3,4
   231d8:	0190303a 	nor	r8,zero,r6
   231dc:	328f883a 	add	r7,r6,r10
   231e0:	41ce703a 	and	r7,r8,r7
   231e4:	3a4e703a 	and	r7,r7,r9
   231e8:	383ff726 	beq	r7,zero,231c8 <strcpy+0x3c>
   231ec:	29800007 	ldb	r6,0(r5)
   231f0:	18c00044 	addi	r3,r3,1
   231f4:	29400044 	addi	r5,r5,1
   231f8:	19bfffc5 	stb	r6,-1(r3)
   231fc:	3000021e 	bne	r6,zero,23208 <strcpy+0x7c>
   23200:	f800283a 	ret
   23204:	1007883a 	mov	r3,r2
   23208:	29800007 	ldb	r6,0(r5)
   2320c:	18c00044 	addi	r3,r3,1
   23210:	29400044 	addi	r5,r5,1
   23214:	19bfffc5 	stb	r6,-1(r3)
   23218:	303ffb1e 	bne	r6,zero,23208 <strcpy+0x7c>
   2321c:	f800283a 	ret

00023220 <__register_exitproc>:
   23220:	defffa04 	addi	sp,sp,-24
   23224:	008000f4 	movhi	r2,3
   23228:	10a60904 	addi	r2,r2,-26588
   2322c:	dc000315 	stw	r16,12(sp)
   23230:	14000017 	ldw	r16,0(r2)
   23234:	dc400415 	stw	r17,16(sp)
   23238:	dfc00515 	stw	ra,20(sp)
   2323c:	80805217 	ldw	r2,328(r16)
   23240:	2023883a 	mov	r17,r4
   23244:	10003e26 	beq	r2,zero,23340 <__register_exitproc+0x120>
   23248:	10c00117 	ldw	r3,4(r2)
   2324c:	020007c4 	movi	r8,31
   23250:	40c0180e 	bge	r8,r3,232b4 <__register_exitproc+0x94>
   23254:	008000b4 	movhi	r2,2
   23258:	108c5904 	addi	r2,r2,12644
   2325c:	1000061e 	bne	r2,zero,23278 <__register_exitproc+0x58>
   23260:	00bfffc4 	movi	r2,-1
   23264:	dfc00517 	ldw	ra,20(sp)
   23268:	dc400417 	ldw	r17,16(sp)
   2326c:	dc000317 	ldw	r16,12(sp)
   23270:	dec00604 	addi	sp,sp,24
   23274:	f800283a 	ret
   23278:	01006404 	movi	r4,400
   2327c:	d9400015 	stw	r5,0(sp)
   23280:	d9800115 	stw	r6,4(sp)
   23284:	d9c00215 	stw	r7,8(sp)
   23288:	00231640 	call	23164 <malloc>
   2328c:	d9400017 	ldw	r5,0(sp)
   23290:	d9800117 	ldw	r6,4(sp)
   23294:	d9c00217 	ldw	r7,8(sp)
   23298:	103ff126 	beq	r2,zero,23260 <__register_exitproc+0x40>
   2329c:	80c05217 	ldw	r3,328(r16)
   232a0:	10000115 	stw	zero,4(r2)
   232a4:	10c00015 	stw	r3,0(r2)
   232a8:	80805215 	stw	r2,328(r16)
   232ac:	10006215 	stw	zero,392(r2)
   232b0:	10006315 	stw	zero,396(r2)
   232b4:	10c00117 	ldw	r3,4(r2)
   232b8:	88000d1e 	bne	r17,zero,232f0 <__register_exitproc+0xd0>
   232bc:	19000084 	addi	r4,r3,2
   232c0:	2109883a 	add	r4,r4,r4
   232c4:	18c00044 	addi	r3,r3,1
   232c8:	2109883a 	add	r4,r4,r4
   232cc:	1109883a 	add	r4,r2,r4
   232d0:	10c00115 	stw	r3,4(r2)
   232d4:	0005883a 	mov	r2,zero
   232d8:	21400015 	stw	r5,0(r4)
   232dc:	dfc00517 	ldw	ra,20(sp)
   232e0:	dc400417 	ldw	r17,16(sp)
   232e4:	dc000317 	ldw	r16,12(sp)
   232e8:	dec00604 	addi	sp,sp,24
   232ec:	f800283a 	ret
   232f0:	02400044 	movi	r9,1
   232f4:	12806217 	ldw	r10,392(r2)
   232f8:	48d2983a 	sll	r9,r9,r3
   232fc:	19000804 	addi	r4,r3,32
   23300:	18d1883a 	add	r8,r3,r3
   23304:	2109883a 	add	r4,r4,r4
   23308:	4211883a 	add	r8,r8,r8
   2330c:	2109883a 	add	r4,r4,r4
   23310:	1109883a 	add	r4,r2,r4
   23314:	1211883a 	add	r8,r2,r8
   23318:	5254b03a 	or	r10,r10,r9
   2331c:	21c02215 	stw	r7,136(r4)
   23320:	41802215 	stw	r6,136(r8)
   23324:	12806215 	stw	r10,392(r2)
   23328:	01000084 	movi	r4,2
   2332c:	893fe31e 	bne	r17,r4,232bc <__register_exitproc+0x9c>
   23330:	11006317 	ldw	r4,396(r2)
   23334:	2252b03a 	or	r9,r4,r9
   23338:	12406315 	stw	r9,396(r2)
   2333c:	003fdf06 	br	232bc <__register_exitproc+0x9c>
   23340:	008001f4 	movhi	r2,7
   23344:	1094ad04 	addi	r2,r2,21172
   23348:	80805215 	stw	r2,328(r16)
   2334c:	003fbe06 	br	23248 <__register_exitproc+0x28>

00023350 <__call_exitprocs>:
   23350:	008000f4 	movhi	r2,3
   23354:	10a60904 	addi	r2,r2,-26588
   23358:	10800017 	ldw	r2,0(r2)
   2335c:	defff304 	addi	sp,sp,-52
   23360:	df000b15 	stw	fp,44(sp)
   23364:	d8800015 	stw	r2,0(sp)
   23368:	10805204 	addi	r2,r2,328
   2336c:	dd400815 	stw	r21,32(sp)
   23370:	dfc00c15 	stw	ra,48(sp)
   23374:	ddc00a15 	stw	r23,40(sp)
   23378:	dd800915 	stw	r22,36(sp)
   2337c:	dd000715 	stw	r20,28(sp)
   23380:	dcc00615 	stw	r19,24(sp)
   23384:	dc800515 	stw	r18,20(sp)
   23388:	dc400415 	stw	r17,16(sp)
   2338c:	dc000315 	stw	r16,12(sp)
   23390:	d9000115 	stw	r4,4(sp)
   23394:	2839883a 	mov	fp,r5
   23398:	d8800215 	stw	r2,8(sp)
   2339c:	057fffc4 	movi	r21,-1
   233a0:	d8800017 	ldw	r2,0(sp)
   233a4:	ddc00217 	ldw	r23,8(sp)
   233a8:	14805217 	ldw	r18,328(r2)
   233ac:	90001726 	beq	r18,zero,2340c <__call_exitprocs+0xbc>
   233b0:	94400117 	ldw	r17,4(r18)
   233b4:	8c3fffc4 	addi	r16,r17,-1
   233b8:	80001116 	blt	r16,zero,23400 <__call_exitprocs+0xb0>
   233bc:	8c400044 	addi	r17,r17,1
   233c0:	8427883a 	add	r19,r16,r16
   233c4:	8c63883a 	add	r17,r17,r17
   233c8:	95802204 	addi	r22,r18,136
   233cc:	9ce7883a 	add	r19,r19,r19
   233d0:	8c63883a 	add	r17,r17,r17
   233d4:	b4e7883a 	add	r19,r22,r19
   233d8:	9463883a 	add	r17,r18,r17
   233dc:	e0001726 	beq	fp,zero,2343c <__call_exitprocs+0xec>
   233e0:	8c87c83a 	sub	r3,r17,r18
   233e4:	b0c7883a 	add	r3,r22,r3
   233e8:	18c01e17 	ldw	r3,120(r3)
   233ec:	1f001326 	beq	r3,fp,2343c <__call_exitprocs+0xec>
   233f0:	843fffc4 	addi	r16,r16,-1
   233f4:	9cffff04 	addi	r19,r19,-4
   233f8:	8c7fff04 	addi	r17,r17,-4
   233fc:	857ff71e 	bne	r16,r21,233dc <__call_exitprocs+0x8c>
   23400:	008000b4 	movhi	r2,2
   23404:	108c5e04 	addi	r2,r2,12664
   23408:	10002a1e 	bne	r2,zero,234b4 <__call_exitprocs+0x164>
   2340c:	dfc00c17 	ldw	ra,48(sp)
   23410:	df000b17 	ldw	fp,44(sp)
   23414:	ddc00a17 	ldw	r23,40(sp)
   23418:	dd800917 	ldw	r22,36(sp)
   2341c:	dd400817 	ldw	r21,32(sp)
   23420:	dd000717 	ldw	r20,28(sp)
   23424:	dcc00617 	ldw	r19,24(sp)
   23428:	dc800517 	ldw	r18,20(sp)
   2342c:	dc400417 	ldw	r17,16(sp)
   23430:	dc000317 	ldw	r16,12(sp)
   23434:	dec00d04 	addi	sp,sp,52
   23438:	f800283a 	ret
   2343c:	91000117 	ldw	r4,4(r18)
   23440:	88c00017 	ldw	r3,0(r17)
   23444:	213fffc4 	addi	r4,r4,-1
   23448:	24001526 	beq	r4,r16,234a0 <__call_exitprocs+0x150>
   2344c:	88000015 	stw	zero,0(r17)
   23450:	183fe726 	beq	r3,zero,233f0 <__call_exitprocs+0xa0>
   23454:	00800044 	movi	r2,1
   23458:	1408983a 	sll	r4,r2,r16
   2345c:	91406217 	ldw	r5,392(r18)
   23460:	95000117 	ldw	r20,4(r18)
   23464:	214a703a 	and	r5,r4,r5
   23468:	28000b26 	beq	r5,zero,23498 <__call_exitprocs+0x148>
   2346c:	91406317 	ldw	r5,396(r18)
   23470:	2148703a 	and	r4,r4,r5
   23474:	20000c1e 	bne	r4,zero,234a8 <__call_exitprocs+0x158>
   23478:	99400017 	ldw	r5,0(r19)
   2347c:	d9000117 	ldw	r4,4(sp)
   23480:	183ee83a 	callr	r3
   23484:	90c00117 	ldw	r3,4(r18)
   23488:	1d3fc51e 	bne	r3,r20,233a0 <__call_exitprocs+0x50>
   2348c:	b8c00017 	ldw	r3,0(r23)
   23490:	1cbfd726 	beq	r3,r18,233f0 <__call_exitprocs+0xa0>
   23494:	003fc206 	br	233a0 <__call_exitprocs+0x50>
   23498:	183ee83a 	callr	r3
   2349c:	003ff906 	br	23484 <__call_exitprocs+0x134>
   234a0:	94000115 	stw	r16,4(r18)
   234a4:	003fea06 	br	23450 <__call_exitprocs+0x100>
   234a8:	99000017 	ldw	r4,0(r19)
   234ac:	183ee83a 	callr	r3
   234b0:	003ff406 	br	23484 <__call_exitprocs+0x134>
   234b4:	90c00117 	ldw	r3,4(r18)
   234b8:	1800071e 	bne	r3,zero,234d8 <__call_exitprocs+0x188>
   234bc:	90c00017 	ldw	r3,0(r18)
   234c0:	18000926 	beq	r3,zero,234e8 <__call_exitprocs+0x198>
   234c4:	9009883a 	mov	r4,r18
   234c8:	b8c00015 	stw	r3,0(r23)
   234cc:	00231780 	call	23178 <free>
   234d0:	bc800017 	ldw	r18,0(r23)
   234d4:	003fb506 	br	233ac <__call_exitprocs+0x5c>
   234d8:	90c00017 	ldw	r3,0(r18)
   234dc:	902f883a 	mov	r23,r18
   234e0:	1825883a 	mov	r18,r3
   234e4:	003fb106 	br	233ac <__call_exitprocs+0x5c>
   234e8:	0007883a 	mov	r3,zero
   234ec:	003ffb06 	br	234dc <__call_exitprocs+0x18c>

000234f0 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
   234f0:	defffc04 	addi	sp,sp,-16
   234f4:	df000315 	stw	fp,12(sp)
   234f8:	df000304 	addi	fp,sp,12
   234fc:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
   23500:	0001883a 	nop
   23504:	e0bfff17 	ldw	r2,-4(fp)
   23508:	e0bffd15 	stw	r2,-12(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  int r2 = exit_code;
   2350c:	e0bffd17 	ldw	r2,-12(fp)
   23510:	e0bffe15 	stw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "D02"(r2), "D03"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
   23514:	e0bffe17 	ldw	r2,-8(fp)
   23518:	10000226 	beq	r2,zero,23524 <_exit+0x34>
    ALT_SIM_FAIL();
   2351c:	002af070 	cmpltui	zero,zero,43969
   23520:	00000106 	br	23528 <_exit+0x38>
  } else {
    ALT_SIM_PASS();
   23524:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
   23528:	003fff06 	br	23528 <_exit+0x38>
