
FreeLwIP.elf:     file format elf32-littlenios2
FreeLwIP.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00000224

Program Header:
    LOAD off    0x00001020 vaddr 0x00000020 paddr 0x00000020 align 2**12
         filesz 0x00043510 memsz 0x00043510 flags r-x
    LOAD off    0x00044530 vaddr 0x00043530 paddr 0x0004577c align 2**12
         filesz 0x0000224c memsz 0x0000224c flags rw-
    LOAD off    0x000469c8 vaddr 0x000479c8 paddr 0x000479c8 align 2**12
         filesz 0x00000000 memsz 0x00023c34 flags rw-
    LOAD off    0x00047000 vaddr 0x05000000 paddr 0x05000000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  05000000  05000000  00047000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000204  00000020  00000020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0003f58c  00000224  00000224  00001224  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00003d80  0003f7b0  0003f7b0  000407b0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       0000224c  00043530  0004577c  00044530  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00023c34  000479c8  000479c8  000469c8  2**2
                  ALLOC, SMALL_DATA
  6 .comment      00000023  00000000  00000000  00047020  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 00001818  00000000  00000000  00047048  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   0005195d  00000000  00000000  00048860  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 000109fb  00000000  00000000  0009a1bd  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00017839  00000000  00000000  000aabb8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00006700  00000000  00000000  000c23f4  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    0000ba5d  00000000  00000000  000c8af4  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00018bcf  00000000  00000000  000d4551  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_alt_sim_info 00000050  00000000  00000000  000ed120  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00000b18  00000000  00000000  000ed170  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .thread_model 00000008  00000000  00000000  000f8af9  2**0
                  CONTENTS, READONLY
 17 .cpu          00000003  00000000  00000000  000f8b01  2**0
                  CONTENTS, READONLY
 18 .qsys         00000001  00000000  00000000  000f8b04  2**0
                  CONTENTS, READONLY
 19 .simulation_enabled 00000001  00000000  00000000  000f8b05  2**0
                  CONTENTS, READONLY
 20 .sysid_hash   00000004  00000000  00000000  000f8b06  2**0
                  CONTENTS, READONLY
 21 .sysid_base   00000004  00000000  00000000  000f8b0a  2**0
                  CONTENTS, READONLY
 22 .sysid_time   00000004  00000000  00000000  000f8b0e  2**0
                  CONTENTS, READONLY
 23 .stderr_dev   00000009  00000000  00000000  000f8b12  2**0
                  CONTENTS, READONLY
 24 .stdin_dev    00000009  00000000  00000000  000f8b1b  2**0
                  CONTENTS, READONLY
 25 .stdout_dev   00000009  00000000  00000000  000f8b24  2**0
                  CONTENTS, READONLY
 26 .sopc_system_name 0000000c  00000000  00000000  000f8b2d  2**0
                  CONTENTS, READONLY
 27 .quartus_project_dir 0000002e  00000000  00000000  000f8b39  2**0
                  CONTENTS, READONLY
 28 .jdi          00005066  00000000  00000000  000f8b67  2**0
                  CONTENTS, READONLY
 29 .sopcinfo     001a200d  00000000  00000000  000fdbcd  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
05000000 l    d  .entry	00000000 .entry
00000020 l    d  .exceptions	00000000 .exceptions
00000224 l    d  .text	00000000 .text
0003f7b0 l    d  .rodata	00000000 .rodata
00043530 l    d  .rwdata	00000000 .rwdata
000479c8 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../FreeLwIP_bsp//obj/HAL/src/crt0.o
0000029c l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 port_asm.o
00000020 l       .exceptions	00000000 save_context
000000a8 l       .exceptions	00000000 save_sp_to_pxCurrentTCB
000000c0 l       .exceptions	00000000 hw_irq_test
00000178 l       .exceptions	00000000 soft_exceptions
000000d4 l       .exceptions	00000000 hw_irq_handler
000000d8 l       .exceptions	00000000 alt_irq_handler
000000f0 l       .exceptions	00000000 restore_context
00000198 l       .exceptions	00000000 call_scheduler
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 BasicWEB.c
0000031c l     F .text	000001e4 prvweb_ParseHTMLRequest
000479c8 l     O .bss	00000004 ulPageHits.3844
00000000 l    df *ABS*	00000000 BlockQ.c
000479cc l     O .bss	00000006 sBlockingConsumerCount
000479d2 l     O .bss	00000006 sBlockingProducerCount
0000083c l     F .text	000000a8 vBlockingQueueConsumer
000007b4 l     F .text	00000088 vBlockingQueueProducer
000479d8 l     O .bss	00000006 sLastBlockingConsumerCount.2291
000479de l     O .bss	00000006 sLastBlockingProducerCount.2292
00000000 l    df *ABS*	00000000 GenQTest.c
000479e4 l     O .bss	00000004 xErrorDetected
000479e8 l     O .bss	00000004 ulLoopCounter
000479ec l     O .bss	00000004 ulLoopCounter2
000479f0 l     O .bss	00000004 ulGuardedVariable
000479f4 l     O .bss	00000004 xHighPriorityMutexTask
000479f8 l     O .bss	00000004 xMediumPriorityMutexTask
00000b18 l     F .text	00000464 prvSendFrontAndBackTest
00000f7c l     F .text	00000128 prvLowPriorityMutexTask
000010a4 l     F .text	0000002c prvMediumPriorityMutexTask
000010d0 l     F .text	00000078 prvHighPriorityMutexTask
000479fc l     O .bss	00000004 ulLastLoopCounter.2305
00047a00 l     O .bss	00000004 ulLastLoopCounter2.2306
00000000 l    df *ABS*	00000000 PollQ.c
00047a04 l     O .bss	00000004 xPollingConsumerCount
00047a08 l     O .bss	00000004 xPollingProducerCount
00047a0c l     O .bss	00000004 xPolledQueue.2258
000012f8 l     F .text	000000c8 vPolledQueueConsumer
00001244 l     F .text	000000b4 vPolledQueueProducer
00000000 l    df *ABS*	00000000 QPeek.c
00047a10 l     O .bss	00000004 xErrorDetected
00047a14 l     O .bss	00000004 ulLoopCounter
000017c0 l     F .text	0000016c prvLowPriorityPeekTask
00001734 l     F .text	0000008c prvMediumPriorityPeekTask
0000166c l     F .text	000000c8 prvHighPriorityPeekTask
00001508 l     F .text	00000164 prvHighestPriorityPeekTask
00047a18 l     O .bss	00000004 ulLastLoopCounter.2294
00000000 l    df *ABS*	00000000 blocktim.c
00047a28 l     O .bss	00000004 xTestQueue
00047a2c l     O .bss	00000004 xSecondary
00047a30 l     O .bss	00000004 xPrimaryCycles
00047a34 l     O .bss	00000004 xSecondaryCycles
00047a38 l     O .bss	00000004 xErrorOccurred
00047a3c l     O .bss	00000004 xRunIndicator
00001a0c l     F .text	0000041c vPrimaryBlockTimeTestTask
00001e28 l     F .text	00000128 vSecondaryBlockTimeTestTask
00047a40 l     O .bss	00000004 xLastPrimaryCycleCount.1959
00047a44 l     O .bss	00000004 xLastSecondaryCycleCount.1960
00000000 l    df *ABS*	00000000 countsem.c
00047a48 l     O .bss	00000004 xErrorDetected
00047c38 l     O .bss	00000018 xParameters
00002258 l     F .text	000000b0 prvCountingSemaphoreTask
000020c0 l     F .text	000000cc prvDecrementSemaphoreCount
0000218c l     F .text	000000cc prvIncrementSemaphoreCount
00047a4c l     O .bss	00000004 uxLastCount0.1940
00047a50 l     O .bss	00000004 uxLastCount1.1941
00000000 l    df *ABS*	00000000 death.c
00047a54 l     O .bss	00000002 usCreationCount
00047a58 l     O .bss	00000004 uxTasksRunningAtStart
000456f0 l     O .rwdata	00000004 uxMaxNumberOfExtraTasksRunning
000024b0 l     F .text	000000b0 vCreateTasks
00002424 l     F .text	0000008c vSuicidalTask
000456f4 l     O .rwdata	00000002 usLastCreationCount.2200
00047a5c l     O .bss	00000004 uxTasksRunningNow.2202
00000000 l    df *ABS*	00000000 dynamic.c
00047a64 l     O .bss	00000004 xContinousIncrementHandle
00047a68 l     O .bss	00000004 xLimitedIncrementHandle
00047a6c l     O .bss	00000004 ulCounter
00047a70 l     O .bss	00000002 usCheckVariable
00047a74 l     O .bss	00000004 xSuspendedQueueSendError
00047a78 l     O .bss	00000004 xSuspendedQueueReceiveError
00002764 l     F .text	00000060 vContinuousIncrementTask
00002708 l     F .text	0000005c vLimitedIncrementTask
000027c4 l     F .text	000000ec vCounterControlTask
000028b0 l     F .text	0000005c vQueueSendWhenSuspendedTask
0000290c l     F .text	00000078 vQueueReceiveWhenSuspendedTask
00047a88 l     O .bss	00000004 ulValueToSend.2294
00047a80 l     O .bss	00000004 ulReceivedValue.2300
00047a84 l     O .bss	00000004 ulExpectedValue.2299
00047a7c l     O .bss	00000002 usLastTaskCheck.2308
00000000 l    df *ABS*	00000000 echo_server.c
00000000 l    df *ABS*	00000000 ethernet.c
00002bc0 l     F .text	00000040 StatusCallback
00002c00 l     F .text	00000020 LinkCallback
00002c68 l     F .text	000001d4 WaitOnPHY
00000000 l    df *ABS*	00000000 integer.c
00047a90 l     O .bss	00000004 xTaskCheck
000031f0 l     F .text	000000a8 vCompeteingIntMathTask
00000000 l    df *ABS*	00000000 main.c
000034b8 l     F .text	00000240 prvCheckTask
000036f8 l     F .text	00000174 prvFirstRegTestTask
0000386c l     F .text	00000170 prvSecondRegTestTask
00003780 l       .text	00000000 RegTest1
00003854 l       .text	00000000 RegTest1Error
000038f4 l       .text	00000000 RegTest2
000039c4 l       .text	00000000 RegTest2Error
00000000 l    df *ABS*	00000000 recmutex.c
00047a9c l     O .bss	00000004 xMutex
00047aa0 l     O .bss	00000004 xErrorOccurred
00047aa4 l     O .bss	00000004 xControllingIsSuspended
00047aa8 l     O .bss	00000004 xBlockingIsSuspended
00047aac l     O .bss	00000004 uxControllingCycles
00047ab0 l     O .bss	00000004 uxBlockingCycles
00047ab4 l     O .bss	00000004 uxPollingCycles
00047ab8 l     O .bss	00000004 xControllingTaskHandle
00047abc l     O .bss	00000004 xBlockingTaskHandle
00003aa8 l     F .text	000000fc prvRecursiveMutexControllingTask
00003ba4 l     F .text	000000a8 prvRecursiveMutexBlockingTask
00003c4c l     F .text	000000bc prvRecursiveMutexPollingTask
00047ac0 l     O .bss	00000004 uxLastControllingCycles.1939
00047ac4 l     O .bss	00000004 uxLastBlockingCycles.1940
00047ac8 l     O .bss	00000004 uxLastPollingCycles.1941
00000000 l    df *ABS*	00000000 semtest.c
00047acc l     O .bss	00000008 sCheckVariables
00047ad4 l     O .bss	00000002 sNextCheckVariable
00003fa0 l     F .text	00000198 prvSemaphoreTest
00047ad6 l     O .bss	00000008 sLastCheckVariables.2281
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 perror.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 strcat.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 strerror.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 u_strerr.c
00000000 l    df *ABS*	00000000 vfprintf.c
00004f2c l     F .text	00000034 __sprint_r
000406e2 l     O .rodata	00000010 blanks.3515
000406f2 l     O .rodata	00000010 zeroes.3516
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 dtoa.c
00006ef0 l     F .text	00000208 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
0000892c l     F .text	00000008 __fp_lock
00008934 l     F .text	00000008 __fp_unlock
00000000 l    df *ABS*	00000000 fputc.c
00000000 l    df *ABS*	00000000 fputs.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 impure.c
00043530 l     O .rwdata	00000400 impure_data
00000000 l    df *ABS*	00000000 locale.c
00040728 l     O .rodata	00000030 lconv
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
00040870 l     O .rodata	0000000c p05.2435
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 s_isinfd.c
00000000 l    df *ABS*	00000000 s_isnand.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fp-bit.c
0000ced8 l     F .text	00000354 _fpadd_parts
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
0000dc18 l     F .text	00000074 udivmodsi4
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 heap_3.c
00000000 l    df *ABS*	00000000 queue.c
0000f038 l     F .text	00000158 prvCopyDataToQueue
0000f3d8 l     F .text	00000060 prvIsQueueFull
0000f228 l     F .text	00000120 prvUnlockQueue
0000f190 l     F .text	00000098 prvCopyDataFromQueue
0000f348 l     F .text	00000058 prvIsQueueEmpty
00000000 l    df *ABS*	00000000 tasks.c
00047c78 l     O .bss	00000064 pxReadyTasksLists
00047cdc l     O .bss	00000014 xDelayedTaskList1
00047cf0 l     O .bss	00000014 xDelayedTaskList2
00047b10 l     O .bss	00000004 pxDelayedTaskList
00047b14 l     O .bss	00000004 pxOverflowDelayedTaskList
00047d04 l     O .bss	00000014 xPendingReadyList
00047d18 l     O .bss	00000014 xTasksWaitingTermination
00047b18 l     O .bss	00000004 uxTasksDeleted
00047d2c l     O .bss	00000014 xSuspendedTaskList
00047b1c l     O .bss	00000004 uxCurrentNumberOfTasks
00047b20 l     O .bss	00000004 xTickCount
00047b24 l     O .bss	00000004 uxTopUsedPriority
00047b28 l     O .bss	00000004 uxTopReadyPriority
00047b2c l     O .bss	00000004 xSchedulerRunning
00047b30 l     O .bss	00000004 uxSchedulerSuspended
00047b34 l     O .bss	00000004 uxMissedTicks
00047b38 l     O .bss	00000004 xMissedYield
00047b3c l     O .bss	00000004 xNumOfOverflows
00047b40 l     O .bss	00000004 uxTaskNumber
0004570c l     O .rwdata	00000004 xNextTaskUnblockTime
00010b84 l     F .text	000000b4 prvAllocateTCBAndStack
000108bc l     F .text	000000dc prvInitialiseTCBVariables
00010998 l     F .text	000000b4 prvInitialiseTaskLists
00010afc l     F .text	00000088 prvAddCurrentTaskToDelayedList
000108a0 l     F .text	0000001c prvIdleTask
00010c38 l     F .text	00000154 prvListTaskWithinSingleList
000409ba l     O .rodata	00000014 ucExpectedStackBytes.3200
00010a4c l     F .text	000000b0 prvCheckTasksWaitingTermination
00010e54 l     F .text	00000040 prvDeleteTCB
00010d8c l     F .text	00000068 usTaskCheckFreeStackSpace
00047d40 l     O .bss	00000046 pcStatusString.3280
00000000 l    df *ABS*	00000000 timers.c
00047d88 l     O .bss	00000014 xActiveTimerList1
00047d9c l     O .bss	00000014 xActiveTimerList2
00047b44 l     O .bss	00000004 pxCurrentTimerList
00047b48 l     O .bss	00000004 pxOverflowTimerList
00047b4c l     O .bss	00000004 xTimerQueue
0001192c l     F .text	00000088 prvCheckForValidListAndQueue
0001140c l     F .text	0000003c prvTimerTask
00011358 l     F .text	000000b4 prvProcessExpiredTimer
000115bc l     F .text	000000dc prvInsertTimerInActiveList
000114f0 l     F .text	00000060 prvGetNextExpireTime
00011448 l     F .text	000000a8 prvProcessTimerOrBlockTask
00011698 l     F .text	00000184 prvProcessReceivedCommands
00011550 l     F .text	0000006c prvSampleTimeNow
00047b50 l     O .bss	00000004 xLastTime.2004
0001181c l     F .text	00000110 prvSwitchTimerLists
00000000 l    df *ABS*	00000000 alt_dev.c
00011a44 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_fstat.c
00011b28 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_io_redirect.c
00011c24 l     F .text	000000c0 alt_open_fd
00000000 l    df *ABS*	00000000 alt_isatty.c
00011d5c l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_load.c
00011e4c l     F .text	0000006c alt_load_section
00000000 l    df *ABS*	00000000 alt_lseek.c
00011f38 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_open.c
00012058 l     F .text	00000050 alt_get_errno
000120a8 l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
00045724 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 api_lib.c
00012cb8 l     F .text	0000028c netconn_recv_data
000134c8 l     F .text	000000cc netconn_close_shutdown
00000000 l    df *ABS*	00000000 api_msg.c
00013634 l     F .text	00000178 recv_raw
000137ac l     F .text	0000012c recv_udp
000138d8 l     F .text	00000140 recv_tcp
00013a18 l     F .text	000000fc poll_tcp
0001537c l     F .text	00000308 do_writemore
00014498 l     F .text	00000288 do_close_internal
00013b14 l     F .text	000000fc sent_tcp
00013c10 l     F .text	000001b0 err_tcp
00013dc0 l     F .text	00000084 setup_tcp
00013e44 l     F .text	00000168 accept_function
00013fac l     F .text	000001a0 pcb_new
00014320 l     F .text	00000178 netconn_drain
00014a54 l     F .text	00000154 do_connected
00000000 l    df *ABS*	00000000 netbuf.c
00000000 l    df *ABS*	00000000 sockets.c
00047db0 l     O .bss	000003f0 sockets
00047b58 l     O .bss	00000004 select_cb_list
00047b5c l     O .bss	00000004 select_cb_ctr
00040dd0 l     O .rodata	00000040 err_to_errno_table
00016094 l     F .text	00000078 get_socket
0001610c l     F .text	00000080 tryget_socket
0001618c l     F .text	000001a0 alloc_socket
0001632c l     F .text	00000094 free_socket
00017db4 l     F .text	000003b0 event_callback
00017554 l     F .text	0000038c lwip_selscan
000182d0 l     F .text	0000010c lwip_getaddrname
00018724 l     F .text	000003fc lwip_getsockopt_internal
00018db0 l     F .text	0000033c lwip_setsockopt_internal
00000000 l    df *ABS*	00000000 tcpip.c
00047b60 l     O .bss	00000004 tcpip_init_done
00047b64 l     O .bss	00000004 tcpip_init_done_arg
00047b68 l     O .bss	00000004 mbox
000192dc l     F .text	000001c0 tcpip_thread
0001990c l     F .text	00000038 pbuf_free_int
00000000 l    df *ABS*	00000000 alt_lwip_close.c
00000000 l    df *ABS*	00000000 alt_lwip_read.c
00000000 l    df *ABS*	00000000 alt_lwip_write.c
00000000 l    df *ABS*	00000000 lwip_main.c
00047b6c l     O .bss	00000004 status_callback
00047b70 l     O .bss	00000004 link_callback
00019c74 l     F .text	00000250 lwip_handle_interfaces
0001a254 l     F .text	0000003c lwip_status_callback
0001a0c8 l     F .text	000000d4 lwip_handle_ethernet_input
0001a018 l     F .text	000000b0 lwip_check_link_status
00000000 l    df *ABS*	00000000 lwip_tse_mac.c
00000000 l    df *ABS*	00000000 sys_arch.c
00000000 l    df *ABS*	00000000 dhcp.c
0001b9a4 l     F .text	00000060 dhcp_clear_assignment
0001ba04 l     F .text	00000050 dhcp_handle_nak
0001d5ec l     F .text	00000058 dhcp_set_state
0001cb14 l     F .text	000001a0 dhcp_discover
0001ba54 l     F .text	00000098 dhcp_check
0001baec l     F .text	000000e8 dhcp_handle_offer
0001bbd4 l     F .text	00000260 dhcp_select
0001e5b4 l     F .text	00000540 dhcp_create_msg
0001d644 l     F .text	00000098 dhcp_option
0001d738 l     F .text	00000094 dhcp_option_short
0001d7cc l     F .text	00000108 dhcp_option_long
0001d6dc l     F .text	0000005c dhcp_option_byte
0001d8d4 l     F .text	000000e4 dhcp_option_hostname
0001eb74 l     F .text	000000f8 dhcp_option_trailer
0001eaf4 l     F .text	00000080 dhcp_delete_msg
0001c1b0 l     F .text	00000078 dhcp_t2_timeout
0001c138 l     F .text	00000078 dhcp_t1_timeout
0001bfa4 l     F .text	00000194 dhcp_timeout
0001ccb4 l     F .text	00000280 dhcp_bind
0001d090 l     F .text	0000015c dhcp_rebind
0001d1ec l     F .text	000001a4 dhcp_reboot
0001c228 l     F .text	00000214 dhcp_handle_ack
0001e260 l     F .text	00000354 dhcp_recv
0001c9b0 l     F .text	00000164 dhcp_decline
0001d9b8 l     F .text	000008a8 dhcp_parse_reply
00045728 l     O .rwdata	00000004 xid.3666
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 ip.c
00047b84 l     O .bss	00000002 ip_id
00000000 l    df *ABS*	00000000 ip_addr.c
000481a0 l     O .bss	00000010 str.3082
00000000 l    df *ABS*	00000000 ip_frag.c
00047b98 l     O .bss	00000004 reassdatagrams
00047b9c l     O .bss	00000002 ip_reass_pbufcount
0002029c l     F .text	00000190 ip_reass_free_complete_datagram
00020694 l     F .text	00000064 ip_reass_dequeue_datagram
0002042c l     F .text	00000190 ip_reass_remove_oldest_datagram
000205bc l     F .text	000000d8 ip_reass_enqueue_new_datagram
000206f8 l     F .text	00000684 ip_reass_chain_frag_into_datagram_and_validate
0002136c l     F .text	0000002c ip_frag_alloc_pbuf_custom_ref
00021398 l     F .text	00000034 ip_frag_free_pbuf_custom_ref
000213cc l     F .text	00000054 ipfrag_free_pbuf_custom
00000000 l    df *ABS*	00000000 mem.c
00047ba0 l     O .bss	00000004 ram
00047ba4 l     O .bss	00000004 ram_end
00047ba8 l     O .bss	00000004 lfree
00047bac l     O .bss	00000004 mem_mutex
0002187c l     F .text	00000124 plug_holes
00000000 l    df *ABS*	00000000 memp.c
000481b0 l     O .bss	0000003c memp_tab
00041190 l     O .rodata	0000001e memp_sizes
000411ae l     O .rodata	0000001e memp_num
000481ec l     O .bss	0001a16f memp_memory
00000000 l    df *ABS*	00000000 netif.c
00047bb0 l     O .bss	00000001 netif_num
00000000 l    df *ABS*	00000000 pbuf.c
00022e50 l     F .text	00000090 pbuf_free_ooseq
00022ee0 l     F .text	0000002c pbuf_free_ooseq_callback
00022f0c l     F .text	00000094 pbuf_pool_is_empty
00000000 l    df *ABS*	00000000 raw.c
00047bc0 l     O .bss	00000004 raw_pcbs
00000000 l    df *ABS*	00000000 stats.c
00000000 l    df *ABS*	00000000 tcp.c
00045734 l     O .rwdata	00000002 tcp_port
00047bc4 l     O .bss	00000001 tcp_timer
00047bc5 l     O .bss	00000001 tcp_timer_ctr
00024a8c l     F .text	00000358 tcp_close_shutdown
000256bc l     F .text	000000e8 tcp_new_port
00025290 l     F .text	00000030 tcp_accept_null
00026668 l     F .text	000000d4 tcp_kill_prio
0002673c l     F .text	00000090 tcp_kill_timewait
00045740 l     O .rwdata	00000004 iss.3777
00000000 l    df *ABS*	00000000 tcp_in.c
0006235c l     O .bss	00000014 inseg
00047be0 l     O .bss	00000004 tcphdr
00047be4 l     O .bss	00000004 iphdr
00047be8 l     O .bss	00000004 seqno
00047bec l     O .bss	00000004 ackno
00047bf0 l     O .bss	00000001 flags
00047bf2 l     O .bss	00000002 tcplen
00047bf4 l     O .bss	00000001 recv_flags
00047bf8 l     O .bss	00000004 recv_data
00028034 l     F .text	0000014c tcp_timewait_input
00027d24 l     F .text	00000310 tcp_listen_input
00028180 l     F .text	00000c00 tcp_process
0002af90 l     F .text	00000228 tcp_parseopt
00029008 l     F .text	00001f88 tcp_receive
00028d80 l     F .text	00000288 tcp_oos_insert_segment
00000000 l    df *ABS*	00000000 tcp_out.c
0002b1b8 l     F .text	00000368 tcp_output_alloc_header
0002b654 l     F .text	00000344 tcp_create_segment
0002b998 l     F .text	00000124 tcp_pbuf_prealloc
0002babc l     F .text	000000b4 tcp_seg_add_chksum
0002bb70 l     F .text	00000124 tcp_write_checks
0002d46c l     F .text	000005c4 tcp_output_segment
00000000 l    df *ABS*	00000000 timers.c
00047c00 l     O .bss	00000004 next_timeout
00047c04 l     O .bss	00000004 tcpip_tcp_timer_active
0002e654 l     F .text	00000068 tcpip_tcp_timer
0002e724 l     F .text	00000040 ip_reass_timer
0002e764 l     F .text	00000040 arp_timer
0002e7a4 l     F .text	00000040 dhcp_timer_coarse
0002e7e4 l     F .text	00000040 dhcp_timer_fine
00000000 l    df *ABS*	00000000 udp.c
00045744 l     O .rwdata	00000002 udp_port
0002ec38 l     F .text	000000ac udp_new_port
00000000 l    df *ABS*	00000000 etharp.c
00062370 l     O .bss	000001f4 arp_table
0002fcd0 l     F .text	00000064 free_etharp_q
0002fd34 l     F .text	00000098 etharp_free_entry
0002ff40 l     F .text	00000318 etharp_find_entry
00030258 l     F .text	000000a4 etharp_send_ip
000302fc l     F .text	000001ec etharp_update_arp_entry
00030648 l     F .text	000000e0 etharp_ip_input
00030728 l     F .text	0000038c etharp_arp_input
00030ab4 l     F .text	0000010c etharp_output_to_arp_index
00031260 l     F .text	0000023c etharp_raw
00000000 l    df *ABS*	00000000 alt_sys_init.c
00031758 l     F .text	00000038 alt_dev_reg
00043eec l     O .rwdata	0000009c vic_0
00043f88 l     O .rwdata	000000d8 cfi_flash
00044060 l     O .rwdata	00001068 jtag_uart
000450c8 l     O .rwdata	00000124 lcd
000451ec l     O .rwdata	00000030 sgdma_rx
0004521c l     O .rwdata	00000030 sgdma_tx
0004524c l     O .rwdata	000000cc rs232
00045318 l     O .rwdata	000000cc uart_0
000453e4 l     O .rwdata	000000cc uart_1
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash.c
000318e0 l     F .text	00000038 alt_flash_device_register
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_table.c
00032718 l     F .text	00000080 alt_read_16bit_query_entry
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
00033848 l     F .text	00000204 altera_avalon_jtag_uart_irq
00033a4c l     F .text	000000a4 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207.c
00045752 l     O .rwdata	00000004 colstart
00034170 l     F .text	000000b4 lcd_write_command
00034224 l     F .text	000000d0 lcd_write_data
000342f4 l     F .text	000000cc lcd_clear_screen
000343c0 l     F .text	000001ec lcd_repaint_screen
000345ac l     F .text	000000cc lcd_scroll_up
00034678 l     F .text	000002bc lcd_handle_escape
00034e60 l     F .text	000000ac alt_lcd_16207_timeout
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_sgdma.c
000350e4 l     F .text	00000050 alt_get_errno
00035c88 l     F .text	000000e4 alt_avalon_sgdma_irq
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
00035e10 l     F .text	000000a0 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_tse.c
00047c0f l     O .bss	00000001 tse_system_count.3776
00047c0e l     O .bss	00000001 is_init.3858
00000000 l    df *ABS*	00000000 altera_avalon_tse_system_info.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
0003b128 l     F .text	00000098 altera_avalon_uart_irq
0003b1c0 l     F .text	000000d8 altera_avalon_uart_rxirq
0003b298 l     F .text	0000013c altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
0003b428 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
0003b71c l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 altera_vic_irq_init.c
00043284 l     O .rodata	00000020 VEC_SIZE_ARRAY.1688
00000000 l    df *ABS*	00000000 altera_vic_isr_register.c
00000000 l    df *ABS*	00000000 alt_env_lock.c
00000000 l    df *ABS*	00000000 list.c
00000000 l    df *ABS*	00000000 port.c
0003c18c l     F .text	00000028 prvReadGp
00047c18 l     O .bss	00000004 lastContext
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_close.c
0003c664 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0003c7bc l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_gettod.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_read.c
0003cee0 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_remap_uncached.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_uncached_malloc.c
00000000 l    df *ABS*	00000000 alt_write.c
0003d280 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 altera_tse_ethernetif.c
0003d3bc l     F .text	00000070 low_level_init
0003d42c l     F .text	00000170 low_level_input
00000000 l    df *ABS*	00000000 icmp.c
0003de9c l     F .text	000001c8 icmp_send_response
00000000 l    df *ABS*	00000000 inet_chksum.c
0003e064 l     F .text	00000248 lwip_standard_chksum
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_amd.c
0003ec10 l     F .text	000000cc alt_write_word_amd
0003eaf4 l     F .text	0000011c alt_wait_for_command_to_complete_amd
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_intel.c
0003eec4 l     F .text	0000017c alt_unlock_block_intel
0003f040 l     F .text	000000d4 alt_write_word_intel
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 ctype_.c
000433ad l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 errno.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 snprintf.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
00000000 l    df *ABS*	00000000 
00047c2c g     O .bss	00000004 alt_instruction_exception_handler
00016078 g     F .text	0000001c lwip_socket_init
000148f8 g     F .text	0000015c do_bind
00047b88 g     O .bss	00000004 current_iphdr_src
0003e6d4 g     F .text	00000044 inet_chksum
00024654 g     F .text	00000048 raw_bind
0000b1e4 g     F .text	00000074 _mprec_log10
00020d7c g     F .text	000005f0 ip_reass
000371a0 g     F .text	000000d8 alt_tse_get_mac_info
00023450 g     F .text	00000160 pbuf_realloc
00000500 g     F .text	000002b4 vStartBlockingQueueTasks
0000b2d4 g     F .text	00000084 __any_on
0000c248 g     F .text	00000064 _isatty_r
00040758 g     O .rodata	00000028 __mprec_tinytens
0000e30c g     F .text	000000e8 alt_main
000046a4 g     F .text	00000094 strcpy
00026da0 g     F .text	00000030 tcp_next_iss
0000e290 g     F .text	00000044 __ashldi3
000044b0 g     F .text	00000084 _puts_r
000321f0 g     F .text	00000040 alt_read_query_entry_32bit
00025528 g     F .text	000000f0 tcp_update_rcv_ann_wnd
0000c2ac g     F .text	0000006c _lseek_r
000000d8 g       .exceptions	00000000 restore_sp_from_pxCurrentTCB
00047bb4 g     O .bss	00000004 netif_list
000319a8 g     F .text	000002ac alt_flash_cfi_write
0001c484 g     F .text	0000004c dhcp_cleanup
0003ad60 g     F .text	000000f0 marvell_cfg_rgmii
0004577c g       *ABS*	00000000 __flash_rwdata_start
0003c200 g     F .text	00000064 enh_alt_irq_enable_all
0001a19c g     F .text	000000b8 print_ipad
0000d778 g     F .text	0000005c __eqdf2
0002da30 g     F .text	0000035c tcp_rst
000243b0 g     F .text	000000c8 pbuf_memfind
0003837c g     F .text	00000210 alt_tse_phy_print_profile
00047a94 g     O .bss	00000004 ulRegTest1Counter
0006b5fc g       *ABS*	00000000 __alt_heap_start
0003ab00 g     F .text	00000098 marvell_phy_cfg
0000f934 g     F .text	00000068 uxTaskPriorityGet
000111d4 g     F .text	000000ac xTimerCreate
0000192c g     F .text	00000044 xAreQueuePeekTasksStillRunning
0003149c g     F .text	00000074 etharp_request
0002f2f4 g     F .text	00000074 udp_send_chksum
000142d4 g     F .text	0000004c netconn_free
00004474 g     F .text	0000003c printf
0001c4d0 g     F .text	000001f0 dhcp_start
00035258 g     F .text	00000110 alt_avalon_sgdma_do_sync_transfer
00026a88 g     F .text	00000030 tcp_err
0004572c g     O .rwdata	00000004 ip_addr_any
0003e2ac g     F .text	000001f8 inet_chksum_pseudo
0001c86c g     F .text	000000a8 dhcp_network_changed
05000000 g       *ABS*	00000000 __alt_mem_sram
0000bca4 g     F .text	0000005c __sseek
0002fbdc g     F .text	0000009c udp_remove
000089bc g     F .text	0000010c __sinit
0000bdac g     F .text	0000013c __swbuf_r
0000f478 g     F .text	0000009c vQueueWaitForMessageRestricted
00062564 g     O .bss	00000c00 cDynamicPage
0001f308 g     F .text	000005b4 ip_output_if
00009788 g     F .text	0000009c _setlocale_r
00008948 g     F .text	00000064 __sfmoreglue
00022590 g     F .text	000000e0 memp_free
0000e454 g     F .text	00000044 __malloc_unlock
00019f70 g     F .text	00000034 lwip_set_status_callback
00023760 g     F .text	00000144 pbuf_free
00026a28 g     F .text	00000030 tcp_recv
00004738 g     F .text	00000664 strerror
00014720 g     F .text	000001d8 do_delconn
000373e4 g     F .text	00000a68 getPHYSpeed
00023950 g     F .text	000000d0 pbuf_cat
00003008 g     F .text	000000bc get_ip_addr
00001148 g     F .text	00000060 xAreGenericQueueTasksStillRunning
00035944 g     F .text	00000344 alt_avalon_sgdma_construct_descriptor_burst
00016b24 g     F .text	000004d4 lwip_recvfrom
0000a288 g     F .text	00000128 memmove
0001f8bc g     F .text	000000b4 ip_output
000304e8 g     F .text	000000a0 etharp_cleanup_netif
00001f50 g     F .text	00000068 xAreBlockTimeTestTasksStillRunning
0002f368 g     F .text	00000058 udp_sendto
000110d0 g     F .text	00000040 vTaskEnterCritical
00019be4 g     F .text	00000090 lwip_wait_for_an
000089ac g     F .text	00000010 _cleanup
0003f344 g     F .text	000000ac snprintf
0000eb0c g     F .text	000000cc xQueueGenericSendFromISR
0000a3b0 g     F .text	000000a8 _Balloc
0001fbd0 g     F .text	00000044 ipaddr_addr
0002e20c g     F .text	00000180 tcp_keepalive
0002fdcc g     F .text	00000174 etharp_tmr
00039d78 g     F .text	000001bc alt_tse_phy_set_adv_1000
00015b18 g     F .text	00000070 netbuf_delete
00045760 g     O .rwdata	00000001 max_mac_system
000267cc g     F .text	00000200 tcp_alloc
00036458 g     F .text	000009fc alt_tse_system_add_sys
0000d830 g     F .text	00000064 __gtdf2
0003f1b4 g     F .text	00000010 __errno
000197b4 g     F .text	00000070 tcpip_callbackmsg_new
00015b88 g     F .text	000000c4 netbuf_alloc
0002f478 g     F .text	00000060 udp_sendto_if
0003237c g     F .text	0000004c alt_write_flash_command_32bit_device_16bit_mode
05000000 g     F .entry	0000001c __reset
0000e7dc g     F .text	00000088 xQueueGiveMutexRecursive
000135c8 g     F .text	0000006c netconn_shutdown
000039dc g     F .text	000000cc vStartRecursiveMutexTasks
000269f8 g     F .text	00000030 tcp_arg
00047b0c g     O .bss	00000004 pxCurrentTCB
0002e824 g     F .text	00000074 sys_timeouts_init
00047bc6 g     O .bss	00000001 tcp_active_pcbs_changed
00019fd8  w    F .text	00000040 lwip_is_interface_up
0001b570 g     F .text	00000054 sys_mutex_free
00047bc8 g     O .bss	00000004 tcp_active_pcbs
000354b4 g     F .text	00000074 alt_avalon_sgdma_construct_stream_to_mem_desc_burst
00022e18 g     F .text	00000038 netif_set_link_callback
00000020 g       *ABS*	00000000 __flash_exceptions_start
00047c08 g     O .bss	00000004 udp_pcbs
0000c1e0 g     F .text	00000068 _fstat_r
000454b0 g     O .rwdata	00000240 tse_mac_device
00031e9c g     F .text	000002d8 alt_flash_program_block
00047af8 g     O .bss	00000004 errno
00031510 g     F .text	00000248 ethernet_input
00024e40 g     F .text	000000f0 tcp_shutdown
00013160 g     F .text	0000007c netconn_recved
0003a64c g     F .text	000004b4 alt_tse_phy_set_common_speed
000238f0 g     F .text	00000060 pbuf_ref
0000e2d4  w    F .text	0000001c pre_constructors
0006b42c g     O .bss	00000020 pmac_groups
00022b04 g     F .text	00000044 netif_set_netmask
0001b748 g     F .text	00000060 sys_mbox_trypost
00047b00 g     O .bss	00000004 alt_argv
0004d6f0 g       *ABS*	00000000 _gp
000265ec g     F .text	0000007c tcp_recv_null
00012430 g     F .text	00000108 usleep
00047b8c g     O .bss	00000004 current_netif
00013594 g     F .text	00000034 netconn_close
0002c55c g     F .text	000002ec tcp_enqueue_flags
00015aa4 g     F .text	00000074 netbuf_new
0000f99c g     F .text	00000194 vTaskPrioritySet
00047b08 g     O .bss	00000004 alt_heapsem
00024de4 g     F .text	0000005c tcp_close
00025618 g     F .text	000000a4 tcp_recved
0003d228 g     F .text	00000058 alt_uncached_malloc
00026b2c g     F .text	0000016c tcp_pcb_purge
00035f64 g     F .text	00000060 tse_mac_initTransInfo2
00019ad4 g     F .text	00000110 lwip_initialize
00043d6c g     O .rwdata	00000180 alt_fd_list
00012940 g     F .text	000000bc netconn_disconnect
00020014 g     F .text	0000003c ipaddr_ntoa
000030fc g     F .text	00000048 get_iface_name
00045736 g     O .rwdata	00000007 tcp_persist_backoff
0003c354 g     F .text	0000002c xPortStartScheduler
0003b9b4 g       .text	00000000 VIC_0_VECTOR_TABLE
0000fec8 g     F .text	00000030 vTaskEndScheduler
0003c8ac g     F .text	00000090 alt_find_dev
000041f0 g     F .text	000000f8 memcpy
00021a54 g     F .text	0000010c mem_free
000361d0 g     F .text	00000054 tse_mac_setMIImode
000104f4 g     F .text	00000090 vTaskPlaceOnEventList
000240d4 g     F .text	0000010c pbuf_fill_chksum
00003d08 g     F .text	0000009c xAreRecursiveMutexTasksStillRunning
00047bcc g     O .bss	00000004 tcp_ticks
00047bd0 g     O .bss	00000004 tcp_listen_pcbs
0000f514 g     F .text	000001f0 xTaskGenericCreate
00037e4c g     F .text	00000048 alt_tse_phy_rd_mdio_addr
0000fc14 g     F .text	0000006c xTaskIsTaskSuspended
0002f4d8 g     F .text	00000414 udp_sendto_if_chksum
0002dd8c g     F .text	000000b4 tcp_rexmit_rto
0000893c g     F .text	0000000c _cleanup_r
0000d954 g     F .text	000000d4 __floatsidf
00047a1c g     O .bss	00000004 xHighPriorityTask
00035fc4 g     F .text	000000e0 tse_mac_sTxWrite
00004434 g     F .text	00000014 perror
00011ce4 g     F .text	00000078 alt_io_redirect
000269cc g     F .text	0000002c tcp_new
0000d8f8 g     F .text	0000005c __ltdf2
00023d58 g     F .text	0000019c pbuf_copy_partial
0002fb50 g     F .text	0000004c udp_disconnect
0001b154 g     F .text	00000020 sys_init
0001b2f0 g     F .text	00000044 sys_sem_signal
0003f7b0 g       *ABS*	00000000 __DTOR_END__
0000e2f0  w    F .text	0000001c post_constructors
0003c6b4 g     F .text	000000c8 alt_close
0002e898 g     F .text	0000017c sys_timeout
00004534 g     F .text	00000014 puts
0003ce40 g     F .text	000000a0 alt_exception_cause_generated_bad_addr
0000e4d8 g     F .text	00000040 vPortFree
0001d390 g     F .text	000001a8 dhcp_release
00041430 g     O .rodata	0000002c tcp_state_str
0000b140 g     F .text	000000a4 __ratio
000248ac g     F .text	00000044 raw_send
0003e718 g     F .text	0000010c inet_chksum_pbuf
00023ef4 g     F .text	00000154 pbuf_take
000355a4 g     F .text	00000088 alt_avalon_sgdma_construct_mem_to_stream_desc_burst
00033c4c g     F .text	0000028c altera_avalon_jtag_uart_read
0003f1fc g     F .text	00000014 malloc
00004448 g     F .text	0000002c _printf_r
00047b90 g     O .bss	00000004 current_iphdr_dest
0000dd38 g     F .text	00000008 __udivsi3
00047b84 g     O .bss	00000000 tse
00011dac g     F .text	000000a0 isatty
00036e54 g     F .text	00000164 alt_tse_sys_enable_mdio_sharing
0003d864 g     F .text	000005b0 icmp_input
000407a8 g     O .rodata	000000c8 __mprec_tens
00037120 g     F .text	00000080 alt_tse_get_mac_info_index
00047a20 g     O .bss	00000004 xMediumPriorityTask
00010df4 g     F .text	00000060 uxTaskGetStackHighWaterMark
0002268c g     F .text	000000f0 netif_add
00009824 g     F .text	0000000c __locale_charset
00019858 g     F .text	00000044 tcpip_trycallback
00047c1c g     O .bss	00000008 alt_timezone
0001b420 g     F .text	000000bc sys_mutex_new
000264a8 g     F .text	00000050 tcp_segs_free
0003bf90 g     F .text	00000098 vListInsertEnd
0003f114 g     F .text	0000008c alt_icache_flush
00017094 g     F .text	00000140 lwip_send
00047af4 g     O .bss	00000004 __malloc_top_pad
0003c0fc g     F .text	00000090 vListRemove
00047b54 g     O .bss	00000004 alt_fd_list_lock
00045700 g     O .rwdata	00000004 __mb_cur_max
000025e8 g     F .text	00000120 vStartDynamicPriorityTasks
00009830 g     F .text	0000000c _localeconv_r
00019824 g     F .text	00000034 tcpip_callbackmsg_delete
0001f970 g     F .text	000000d0 ip_output_hinted
0002298c g     F .text	00000134 netif_set_ipaddr
0000a7b0 g     F .text	0000003c __i2b
00009144 g     F .text	000004e4 __sfvwrite_r
000356d0 g     F .text	00000058 alt_avalon_sgdma_stop
00037eec g     F .text	0000012c alt_tse_phy_wr_mdio_reg
0000bb64 g     F .text	00000064 _sbrk_r
0003ecdc g     F .text	00000080 alt_program_intel
0003858c g     F .text	0000069c alt_tse_mac_group_init
0002bc94 g     F .text	000008c8 tcp_write
0001a484 g     F .text	00000850 tse_mac_init
0000fd5c g     F .text	000000e4 xTaskResumeFromISR
00030588 g     F .text	000000c0 etharp_find_addr
0001b7a8 g     F .text	00000108 sys_arch_mbox_fetch
00018164 g     F .text	0000016c lwip_shutdown
00019f2c g     F .text	00000044 get_netif
0000c318 g     F .text	0000006c _read_r
0003bf68 g     F .text	00000028 vListInitialiseItem
0003c77c g     F .text	00000024 alt_dcache_flush
00043930 g     O .rwdata	0000000c __lc_ctype
00045720 g     O .rwdata	00000004 alt_max_fd
00032174 g     F .text	0000003c alt_read_query_entry_8bit
0003c39c g     F .text	00000034 vPortSysTickHandler
0000e078 g     F .text	00000104 __unpack_d
0000c090 g     F .text	0000013c _fclose_r
0003ed5c g     F .text	00000168 alt_erase_block_intel
000250c0 g     F .text	000001d0 tcp_bind
000088fc g     F .text	00000030 fflush
00047af0 g     O .bss	00000004 __malloc_max_sbrked_mem
0003de58 g     F .text	00000044 icmp_time_exceeded
0002508c g     F .text	00000034 tcp_abort
00012ac8 g     F .text	000001f0 netconn_accept
00021420 g     F .text	0000045c ip_frag
0000d22c g     F .text	00000054 __adddf3
00016a14 g     F .text	00000110 lwip_listen
0000aeb4 g     F .text	00000148 __b2d
0000c94c g     F .text	0000058c __umoddi3
00011f88 g     F .text	000000d0 lseek
00024724 g     F .text	00000188 raw_sendto
000380e4 g     F .text	00000298 alt_tse_phy_add_profile_default
000397e4 g     F .text	00000594 alt_tse_phy_get_cap
000456f8 g     O .rwdata	00000004 _global_impure_ptr
00015974 g     F .text	00000130 do_close
0003cf30 g     F .text	000000f0 alt_read
0000b504 g     F .text	000005fc _realloc_r
0006b5fc g       *ABS*	00000000 __bss_end
00035134 g     F .text	00000124 alt_avalon_sgdma_do_async_transfer
000008e4 g     F .text	00000128 xAreBlockingQueuesStillRunning
0003d124 g     F .text	00000104 alt_tick
000166c0 g     F .text	00000150 lwip_bind
0000c384 g     F .text	000005c8 __udivdi3
0001d538 g     F .text	000000b4 dhcp_stop
00039684 g     F .text	00000160 alt_tse_phy_check_link
00040780 g     O .rodata	00000028 __mprec_bigtens
0000a594 g     F .text	00000104 __s2b
000183dc g     F .text	00000044 lwip_getpeername
0000dafc g     F .text	0000011c __floatunsidf
0003ac7c g     F .text	000000e4 marvell_cfg_sgmii
00023afc g     F .text	0000025c pbuf_copy
000394c0 g     F .text	000001c4 alt_tse_phy_restart_an
0002de40 g     F .text	000002a8 tcp_rexmit
0000ac54 g     F .text	00000058 __mcmp
0000e498 g     F .text	00000040 pvPortMalloc
0003afd8 g     F .text	00000150 altera_avalon_uart_init
000013c0 g     F .text	00000048 xArePollingQueuesStillRunning
00015e84 g     F .text	000000f4 netbuf_data
00045778 g     O .rwdata	00000004 __ctype_ptr
00008bd4 g     F .text	00000018 __fp_lock_all
00012654 g     F .text	0000013c netconn_getaddr
0006b44c g     O .bss	00000020 pphy_profiles
0000ef74 g     F .text	00000040 vQueueDelete
0003c380 g     F .text	0000001c vPortEndScheduler
00022b70 g     F .text	000000ac netif_set_up
0003bf04 g     F .text	00000064 vListInitialise
0003d060 g     F .text	000000c4 alt_alarm_stop
00019fa4 g     F .text	00000034 lwip_set_link_callback
02001000 g       *ABS*	00000000 __alt_mem_descriptor_memory
000173c8 g     F .text	00000148 lwip_socket
0004146c g     O .rodata	00000010 tcp_pcb_lists
0001989c g     F .text	00000070 tcpip_init
00043d44 g     O .rwdata	00000028 alt_dev_null
0001006c g     F .text	00000048 xTaskGetTickCount
0000e95c g     F .text	000001b0 xQueueGenericSend
00003144 g     F .text	00000024 is_interface_active
0001fb0c g     F .text	000000c4 ip4_addr_netmask_valid
00047bd4 g     O .bss	00000004 tcp_tmp_pcb
00012868 g     F .text	000000d8 netconn_connect
000393a8 g     F .text	00000118 alt_tse_phy_init
0003267c g     F .text	0000009c alt_set_flash_algorithm_func
00035728 g     F .text	00000064 alt_avalon_sgdma_check_descriptor_status
000131dc g     F .text	00000080 netconn_sendto
0003c7a0 g     F .text	0000001c alt_dcache_flush_all
0000a698 g     F .text	00000068 __hi0bits
00000a0c g     F .text	0000010c vStartGenericQueueTasks
0001ae10 g     F .text	0000016c tse_mac_raw_send
0000da28 g     F .text	000000d4 __fixdfsi
0001ad7c g     F .text	00000094 tse_sgdma_rx_isr
00002308 g     F .text	0000008c xAreCountingSemaphoreTasksStillRunning
000219a0 g     F .text	000000b4 mem_init
0003d2d0 g     F .text	000000ec alt_write
0003bbb4 g       .text	00000000 alt_shadow_non_preemptive_interrupt
00032230 g     F .text	00000044 alt_write_flash_command_8bit_device_8bit_mode
0001689c g     F .text	00000178 lwip_connect
0002b520 g     F .text	00000134 tcp_send_fin
0004577c g       *ABS*	00000000 __ram_rwdata_end
0002c9d0 g     F .text	00000a9c tcp_output
00047b74 g     O .bss	00000004 tx_counter
00045718 g     O .rwdata	00000008 alt_dev_list
00008c04 g     F .text	00000044 _fputc_r
00021b60 g     F .text	00000308 mem_trim
00019a70 g     F .text	00000064 write
00035864 g     F .text	00000080 alt_avalon_sgdma_enable_desc_poll
0000b358 g     F .text	000000bc _putc_r
000105ec g     F .text	000000ec xTaskRemoveFromEventList
0000346c g     F .text	00000030 vApplicationMallocFailedHook
00043530 g       *ABS*	00000000 __ram_rodata_end
00015c4c g     F .text	00000088 netbuf_free
00011b78 g     F .text	000000ac fstat
0000e24c g     F .text	00000044 __lshrdi3
000129fc g     F .text	000000cc netconn_listen_with_backlog
00047bfc g     O .bss	00000004 tcp_input_pcb
0002451c g     F .text	00000138 raw_input
0003ae50 g     F .text	00000078 DP83848C_link_status_read
0002c848 g     F .text	00000188 tcp_send_empty_ack
0000460c g     F .text	00000098 strcat
000334d0 g     F .text	000000d4 alt_check_primary_table
0002e0e8 g     F .text	00000124 tcp_rexmit_fast
0001b1bc g     F .text	000000e0 sys_sem_new
0000a9cc g     F .text	0000012c __pow5mult
00047ae8 g     O .bss	00000004 __nlocale_changed
000196b8 g     F .text	0000008c tcpip_untimeout
0000dd40 g     F .text	00000008 __umodsi3
00031ce0 g     F .text	00000064 alt_flash_cfi_read
00032414 g     F .text	00000038 alt_write_native_8bit
00047a98 g     O .bss	00000004 ulRegTest2Counter
0001fc14 g     F .text	00000400 ipaddr_aton
0001fa40 g     F .text	000000cc ip4_addr_isbroadcast
00022b48 g     F .text	00000028 netif_set_default
00035528 g     F .text	0000007c alt_avalon_sgdma_construct_mem_to_stream_desc
0002fb9c g     F .text	00000040 udp_recv
0003562c g     F .text	00000050 alt_avalon_sgdma_register_callback
0006b5fc g       *ABS*	00000000 end
00032274 g     F .text	00000074 alt_write_flash_command_16bit_device_8bit_mode
00034934 g     F .text	0000052c altera_avalon_lcd_16207_write
0000f704 g     F .text	000000d8 vTaskDelete
0002eb04 g     F .text	00000118 sys_timeouts_mbox_fetch
00022c1c g     F .text	00000090 netif_set_down
00002560 g     F .text	00000088 xIsCreateTaskStillRunning
00047b78 g     O .bss	00000004 rx_counter
00022fa0 g     F .text	00000370 pbuf_alloc
00022ce4 g     F .text	000000c0 netif_set_link_up
0001b690 g     F .text	0000006c sys_mbox_free
0003b76c g     F .text	00000248 altera_avalon_uart_write
00036274 g     F .text	000001e4 alt_tse_phy_add_profile
00032798 g     F .text	000005c8 alt_read_cfi_table
00033708 g     F .text	00000140 altera_avalon_jtag_uart_init
000001b0 g     F .exceptions	00000074 alt_instruction_exception_entry
0003f7b0 g       *ABS*	00000000 __CTOR_LIST__
02000000 g       *ABS*	00000000 __alt_stack_pointer
000358e4 g     F .text	00000060 alt_avalon_sgdma_disable_desc_poll
000125f4 g     F .text	00000060 netconn_delete
00035eb0 g     F .text	00000088 alt_avalon_timer_sc_init
0003af28 g     F .text	00000060 altera_avalon_uart_write_fd
0000dda8 g     F .text	000000ac __clzsi2
0003f2a0 g     F .text	000000a4 _snprintf_r
0003af88 g     F .text	00000050 altera_avalon_uart_close_fd
00015f78 g     F .text	0000009c netbuf_next
000029ec g     F .text	000001d4 prvMySocketTest
00033ed8 g     F .text	00000298 altera_avalon_jtag_uart_write
00035368 g     F .text	00000070 alt_avalon_sgdma_construct_mem_to_mem_desc
00016014 g     F .text	00000064 netbuf_first
00031918 g     F .text	00000090 alt_flash_cfi_init
00008bc4 g     F .text	00000004 __sfp_lock_acquire
0000a190 g     F .text	000000f8 memchr
00045730 g     O .rwdata	00000004 ip_addr_broadcast
00004f60 g     F .text	00001df8 ___vfprintf_internal_r
000171d4 g     F .text	000001f4 lwip_sendto
00020200 g     F .text	0000009c ip_reass_tmr
00004548 g     F .text	00000058 _sprintf_r
00010710 g     F .text	000000e4 xTaskCheckForTimeOut
00035458 g     F .text	0000005c alt_avalon_sgdma_construct_stream_to_mem_desc
00008e74 g     F .text	000002d0 _free_r
0002fa48 g     F .text	00000108 udp_connect
0003f5d8 g     F .text	000001a0 __call_exitprocs
000141a8 g     F .text	0000012c netconn_alloc
00047b94 g     O .bss	00000004 current_header
000178e0 g     F .text	000004d4 lwip_select
00016ff8 g     F .text	0000004c lwip_read
00047b80 g     O .bss	00000004 rx_faulty_packets
00047ae4 g     O .bss	00000004 __mlocale_changed
0001af7c g     F .text	000001d8 tse_mac_rcv
0002277c g     F .text	00000058 netif_set_addr
0001c914 g     F .text	0000009c dhcp_arp_reply
00045704 g     O .rwdata	00000004 __malloc_sbrk_base
00000224 g     F .text	0000007c _start
00047c30 g     O .bss	00000004 _alt_tick_rate
0000fef8 g     F .text	00000028 vTaskSuspendAll
00024478 g     F .text	000000a4 pbuf_strstr
0003578c g     F .text	00000050 alt_avalon_sgdma_open
000100b4 g     F .text	0000002c xTaskGetTickCountFromISR
00004f24 g     F .text	00000008 _user_strerror
00002eec g     F .text	0000011c get_mac_addr
000223cc g     F .text	000001c4 memp_malloc
0000aaf8 g     F .text	0000015c __lshift
0002e38c g     F .text	000002c8 tcp_zero_window_probe
00047c34 g     O .bss	00000004 _alt_nticks
00038018 g     F .text	000000cc alt_tse_phy_rd_mdio_reg
00019a04 g     F .text	0000006c read
00015684 g     F .text	00000114 do_write
000317d0 g     F .text	00000110 alt_sys_init
0001bee8 g     F .text	000000bc dhcp_fine_tmr
00063170 g     O .bss	0000000a dhcp_rx_options_given
0003f4a8 g     F .text	00000130 __register_exitproc
000002a0 g     F .text	0000007c vBasicWEBServer
00011004 g     F .text	000000cc vTaskPriorityDisinherit
00047c0c g     O .bss	00000001 phy_profile_count
00004e28 g     F .text	000000fc strncmp
000370ac g     F .text	00000074 alt_tse_get_mac_group_index
000321b0 g     F .text	00000040 alt_read_query_entry_16bit
0003d020 g     F .text	00000040 alt_remap_uncached
00020050 g     F .text	000001b0 ipaddr_ntoa_r
0000a7ec g     F .text	000001e0 __multiply
00033af0 g     F .text	00000068 altera_avalon_jtag_uart_close
00010f08 g     F .text	000000fc vTaskPriorityInherit
00043530 g       *ABS*	00000000 __ram_rwdata_start
0003f7b0 g       *ABS*	00000000 __ram_rodata_start
0003f3f0 g     F .text	000000b8 strncpy
00047c50 g     O .bss	00000028 __malloc_current_mallinfo
00047bd8 g     O .bss	00000004 tcp_bound_pcbs
0000fc80 g     F .text	000000dc vTaskResume
000324b8 g     F .text	000001c4 alt_set_flash_width_func
0000affc g     F .text	00000144 __d2b
0001b29c g     F .text	00000054 sys_sem_free
000264f8 g     F .text	00000058 tcp_seg_free
000103c0 g     F .text	00000134 vTaskSwitchContext
00024290 g     F .text	00000120 pbuf_memcmp
00019980 g     F .text	0000003c mem_free_callback
00037e94 g     F .text	00000058 alt_tse_phy_wr_mdio_addr
000335a4 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
0003cb08 g     F .text	0000010c alt_get_fd
00010584 g     F .text	00000068 vTaskPlaceOnEventListRestricted
00015798 g     F .text	000001dc do_getaddr
0003c53c g     F .text	00000128 alt_busy_sleep
00015dc8 g     F .text	000000bc netbuf_chain
0000e17c g     F .text	000000d0 __fpcmp_parts_d
00024a28 g     F .text	0000001c tcp_init
000257a4 g     F .text	00000390 tcp_connect
0003e4a4 g     F .text	00000230 inet_chksum_pseudo_partial
0000c02c g     F .text	00000064 _close_r
00021e68 g     F .text	00000330 mem_malloc
0003a324 g     F .text	00000328 alt_tse_phy_get_common_speed
0003e8e4 g     F .text	00000210 alt_erase_block_amd
0003f224 g     F .text	0000007c memcmp
00033664 g     F .text	00000050 altera_avalon_jtag_uart_close_fd
0006b5fc g       *ABS*	00000000 __alt_stack_base
000336b4 g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
00047c0d g     O .bss	00000001 mac_group_count
00022da4 g     F .text	00000074 netif_set_link_down
0001cf34 g     F .text	0000015c dhcp_renew
00011280 g     F .text	000000d8 xTimerGenericCommand
00010860 g     F .text	00000040 vTaskSetTaskNumber
00014de0 g     F .text	00000080 do_disconnect
00006d7c g     F .text	00000174 __swsetup_r
00032d60 g     F .text	00000770 alt_read_cfi_width
00003430 g     F .text	0000003c vApplicationStackOverflowHook
0001acd4 g     F .text	000000a8 tse_sgdma_read_init
0000fb30 g     F .text	000000e4 vTaskSuspend
0000d5c4 g     F .text	000001b4 __divdf3
00008ac8 g     F .text	000000fc __sfp
0000b258 g     F .text	0000007c __copybits
000100e0 g     F .text	00000020 uxTaskGetNumberOfTasks
00000000         *UND*	00000000 save_context
00026dd0 g     F .text	0000008c tcp_eff_send_mss
0004393c g     O .rwdata	00000408 __malloc_av_
00008bd0 g     F .text	00000004 __sinit_lock_release
0001024c g     F .text	00000174 vTaskIncrementTick
00047b84 g     O .bss	00000000 eth_tse
0000d2e0 g     F .text	000002e4 __muldf3
0000bbc8 g     F .text	00000054 __sread
00038c28 g     F .text	00000418 alt_tse_mac_get_phy
0003c93c g     F .text	00000114 alt_find_file
00018b20 g     F .text	00000290 lwip_setsockopt
0003c80c g     F .text	000000a0 alt_dev_llist_insert
0000e3f4 g     F .text	00000060 __malloc_lock
00012328 g     F .text	00000108 sbrk
0000e864 g     F .text	000000a0 xQueueTakeMutexRecursive
0003567c g     F .text	00000054 alt_avalon_sgdma_start
0001c6c0 g     F .text	000001ac dhcp_inform
0000efb4 g     F .text	00000028 ucQueueGetQueueNumber
0001961c g     F .text	0000009c tcpip_timeout
00008714 g     F .text	000001e8 _fflush_r
00047a24 g     O .bss	00000004 xHighestPriorityTask
00037358 g     F .text	0000008c alt_tse_mac_set_duplex
0000bf70 g     F .text	000000bc _calloc_r
0002469c g     F .text	00000048 raw_connect
00012f44 g     F .text	00000074 netconn_recv_tcp_pbuf
00045768 g     O .rwdata	00000008 alt_flash_dev_list
00032334 g     F .text	00000048 alt_write_flash_command_16bit_device_16bit_mode
0003cc14 g     F .text	000001fc gettimeofday
0001b5c4 g     F .text	000000cc sys_mbox_new
0001a290 g     F .text	000001f4 lwip_initialize_phys
000479c8 g       *ABS*	00000000 __bss_start
00010100 g     F .text	0000014c vTaskList
00010818 g     F .text	00000048 uxTaskGetTaskNumber
000042e8 g     F .text	000000dc memset
00003314 g     F .text	0000011c main
00047b04 g     O .bss	00000004 alt_envp
00001970 g     F .text	0000009c vCreateBlockTimeTasks
00047aec g     O .bss	00000004 __malloc_max_total_mem
00033604 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
0000bee8 g     F .text	0000001c __swbuf
0003c028 g     F .text	000000d4 vListInsert
0003de14 g     F .text	00000044 icmp_dest_unreach
00034f0c g     F .text	00000178 altera_avalon_lcd_16207_init
00045758 g     O .rwdata	00000008 alt_sgdma_list
00026a58 g     F .text	00000030 tcp_sent
0000bd00 g     F .text	00000008 __sclose
000241e0 g     F .text	000000b0 pbuf_get_at
02000000 g       *ABS*	00000000 __alt_heap_limit
0000c1cc g     F .text	00000014 fclose
00011168 g     F .text	0000006c xTimerCreateTimerTask
0006b46c g     O .bss	00000190 _atexit0
000070f8 g     F .text	0000161c _dtoa_r
0002498c g     F .text	00000080 raw_new
00009a0c g     F .text	00000784 _malloc_r
00036148 g     F .text	00000088 tse_mac_SwReset
00018420 g     F .text	00000044 lwip_getsockname
0000f010 g     F .text	00000028 ucQueueGetQueueType
0003d59c g     F .text	000000fc ethernetif_input
00045764 g     O .rwdata	00000004 alt_errno
0000f7dc g     F .text	000000e4 vTaskDelayUntil
000323c8 g     F .text	0000004c alt_write_flash_command_32bit_device_32bit_mode
00019944 g     F .text	0000003c pbuf_free_callback
00004138 g     F .text	000000b8 xAreSemaphoreTasksStillRunning
0003bec0 g     F .text	00000044 __env_unlock
00022cac g     F .text	00000038 netif_set_status_callback
00009628 g     F .text	000000a8 _fwalk
0001325c g     F .text	000000c8 netconn_send
0000ee24 g     F .text	000000d0 xQueueReceiveFromISR
00031d44 g     F .text	00000158 alt_write_value_to_flash
00012538 g     F .text	000000bc netconn_new_with_proto_and_callback
00010e94 g     F .text	00000028 xTaskGetCurrentTaskHandle
00013324 g     F .text	000001a4 netconn_write_partly
0003244c g     F .text	00000038 alt_write_native_16bit
0000b414 g     F .text	000000f0 putc
0000dc8c g     F .text	00000050 __divsi3
00036ff8 g     F .text	00000048 alt_tse_mac_set_common_speed
000248f0 g     F .text	0000009c raw_remove
04000000 g       *ABS*	00000000 __alt_mem_cfi_flash
0004087c g     O .rodata	00000014 __thenan_df
0000e638 g     F .text	000000cc xQueueGenericCreate
00008d38 g     F .text	0000013c _malloc_trim_r
0003f7b0 g       *ABS*	00000000 __CTOR_END__
00019ee4 g     F .text	00000048 get_mac_base
00047bbc g     O .bss	00000001 pbuf_free_ooseq_pending
0002f8ec g     F .text	0000015c udp_bind
00047c10 g     O .bss	00000004 alt_vic_dev_list
00024a44 g     F .text	00000048 tcp_tmr
00030eac g     F .text	000003b4 etharp_query
0000bd08 g     F .text	000000a4 strcmp
0001ec6c g     F .text	00000048 lwip_init
0000e904 g     F .text	00000058 xQueueCreateCountingSemaphore
0003f7b0 g       *ABS*	00000000 __flash_rodata_start
0001b91c g     F .text	00000088 sys_thread_new
0003f7b0 g       *ABS*	00000000 __DTOR_LIST__
00030bc0 g     F .text	000002ec etharp_output
00047a60 g     O .bss	00000004 xCreatedTask
0002f3c0 g     F .text	000000b8 udp_sendto_chksum
0000d7d4 g     F .text	0000005c __nedf2
0000efdc g     F .text	00000034 vQueueSetQueueNumber
00031790 g     F .text	00000040 alt_irq_init
00003168 g     F .text	00000088 vStartIntegerMathTasks
00036fb8 g     F .text	00000040 alt_tse_mac_get_common_speed
000122c8 g     F .text	00000060 alt_release_fd
00063164 g     O .bss	0000000b cPageHits
0000ff20 g     F .text	0000014c xTaskResumeAll
00019744 g     F .text	00000070 tcpip_apimsg
00023310 g     F .text	00000140 pbuf_alloced_custom
000045a0 g     F .text	0000006c sprintf
00022ac0 g     F .text	00000044 netif_set_gw
00040890 g     O .rodata	00000100 __clz_tab
0000fe40 g     F .text	00000088 vTaskStartScheduler
000238a4 g     F .text	0000004c pbuf_clen
00047ae0 g     O .bss	00000004 _PathLocale
0003f1a0 g     F .text	00000014 atexit
00019ec4 g     F .text	00000020 get_mac_count
0000bf04 g     F .text	0000006c _write_r
00026550 g     F .text	00000034 tcp_setprio
0002f2a0 g     F .text	00000054 udp_send
00018464 g     F .text	000002c0 lwip_getsockopt
0000983c g     F .text	0000001c setlocale
0000f438 g     F .text	00000040 xQueueIsQueueFullFromISR
00024048 g     F .text	0000008c pbuf_coalesce
00001408 g     F .text	00000100 vStartQueuePeekTasks
000246e4 g     F .text	00000040 raw_recv
00011a14 g     F .text	00000030 pvTimerGetTimerID
0001b52c g     F .text	00000044 sys_mutex_unlock
000227d4 g     F .text	000000d8 netif_remove
0001b4dc g     F .text	00000050 sys_mutex_lock
0001b334 g     F .text	000000ec sys_arch_sem_wait
000456fc g     O .rwdata	00000004 _impure_ptr
00047afc g     O .bss	00000004 alt_argc
00025b34 g     F .text	0000072c tcp_slowtmr
00011acc g     F .text	0000005c _do_dtors
00003298 g     F .text	0000007c xAreIntegerMathsTaskStillRunning
000011a8 g     F .text	0000009c vStartPolledQueueTasks
00001fb8 g     F .text	00000108 vStartCountingSemaphoreTasks
0003bbcc g     F .text	0000013c alt_vic_irq_init
0000ae54 g     F .text	00000060 __ulp
0000bb00 g     F .text	00000038 __isinfd
00026ab8 g     F .text	00000030 tcp_accept
00008bec g     F .text	00000018 __fp_unlock_all
00014e60 g     F .text	000001f8 do_listen
000107f4 g     F .text	00000024 vTaskMissedYield
00035084 g     F .text	00000060 altera_avalon_lcd_16207_write_fd
00008c48 g     F .text	00000060 fputc
0003d698 g     F .text	000001cc ethernetif_init
00045710 g     O .rwdata	00000008 alt_fs_list
000322e8 g     F .text	0000004c alt_write_flash_command_32bit_device_8bit_mode
0000eef4 g     F .text	00000050 uxQueueMessagesWaiting
0000ebd8 g     F .text	0000024c xQueueGenericReceive
00047c24 g     O .bss	00000008 alt_resettime
00000020 g       *ABS*	00000000 __ram_exceptions_start
00009858 g     F .text	0000000c localeconv
0001949c g     F .text	000000b0 tcpip_input
0a000000 g       *ABS*	00000000 __alt_mem_onchip_memory2
00047bdc g     O .bss	00000004 tcp_tw_pcbs
0003a17c g     F .text	000001a8 alt_tse_phy_set_adv_10
00002c20 g     F .text	00000048 InitNetwork
0003bd08 g     F .text	00000158 alt_ic_isr_register
0001b174 g     F .text	00000048 sys_now
0002ece4 g     F .text	000005bc udp_input
0000e518 g     F .text	00000120 xQueueGenericReset
0000349c g     F .text	0000001c _general_exception_handler
0004577c g       *ABS*	00000000 _edata
00002394 g     F .text	00000090 vCreateSuicidalTasks
0003aec8 g     F .text	00000060 altera_avalon_uart_read_fd
0006b5fc g       *ABS*	00000000 _end
0003ca50 g     F .text	00000068 alt_flash_open_dev
00039040 g     F .text	00000240 alt_tse_mac_associate_phy
00022670 g     F .text	0000001c netif_init
00000224 g       *ABS*	00000000 __ram_exceptions_end
00033b58 g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
00008ca8 g     F .text	00000074 _fputs_r
0001ecb4 g     F .text	00000110 ip_route
000252c0 g     F .text	00000268 tcp_listen_with_backlog
0006b1b8 g     O .bss	00000274 lwip_stats
00015284 g     F .text	000000f8 do_recv
000235b0 g     F .text	000001b0 pbuf_header
000119b4 g     F .text	00000060 xTimerIsTimerActive
00047bb8 g     O .bss	00000004 netif_default
00026c98 g     F .text	00000108 tcp_pcb_remove
00047b7c g     O .bss	00000004 rx_missed_packets
000357dc g     F .text	00000088 alt_avalon_sgdma_construct_descriptor
0000bc1c g     F .text	00000088 __swrite
0003e824 g     F .text	00000058 lwip_chksum_copy
00045708 g     O .rwdata	00000004 __malloc_trim_threshold
00023a20 g     F .text	00000040 pbuf_chain
000043c4 g     F .text	00000070 _perror_r
00024f30 g     F .text	0000015c tcp_abandon
0003f1c4 g     F .text	00000038 exit
00026e5c g     F .text	0000003c tcp_debug_state_str
0002e6bc g     F .text	00000068 tcp_timer_needed
000096d0 g     F .text	000000b8 _fwalk_reent
00022210 g     F .text	000001bc memp_init
0001c43c g     F .text	00000048 dhcp_set_struct
00022198 g     F .text	00000078 mem_calloc
0000acac g     F .text	000001a8 __mdiff
00026260 g     F .text	000000f8 tcp_fasttmr
0003cab8 g     F .text	00000050 alt_flash_close_dev
0000dcdc g     F .text	0000005c __modsi3
00026358 g     F .text	00000150 tcp_process_refused_data
00036224 g     F .text	00000050 tse_mac_setGMIImode
0000f8c0 g     F .text	00000074 vTaskDelay
0003ab98 g     F .text	000000e4 marvell_cfg_gmii
02000000 g       *ABS*	00000000 __alt_data_end
00008bc8 g     F .text	00000004 __sfp_lock_release
00012790 g     F .text	000000d8 netconn_bind
00017510 g     F .text	00000044 lwip_write
00000000 g       *ABS*	00000000 __alt_mem_sdram
00039280 g     F .text	00000128 alt_tse_phy_cfg_pcs
0006317c g     O .bss	00000028 dhcp_rx_options_val
00010ebc g     F .text	0000004c xTaskGetSchedulerState
000432ac g     O .rodata	00000101 _ctype_
00017044 g     F .text	00000050 lwip_recv
00047a8c g     O .bss	00000004 xSuspendedTestQueue
0003b3d4 g     F .text	00000054 altera_avalon_uart_close
000190ec g     F .text	000000e4 lwip_ioctl
0003f778 g     F .text	00000038 _exit
0000bb38 g     F .text	0000002c __isnand
0001be34 g     F .text	000000b4 dhcp_coarse_tmr
0003c3d0 g     F .text	0000016c alt_alarm_start
00026584 g     F .text	00000068 tcp_seg_copy
0000dd48 g     F .text	00000060 __muldi3
00009864 g     F .text	000001a8 __smakebuf_r
00032484 g     F .text	00000034 alt_write_native_32bit
00011110 g     F .text	00000058 vTaskExitCritical
00026ae8 g     F .text	00000044 tcp_poll
00002984 g     F .text	00000068 xAreDynamicPriorityTasksStillRunning
00004d9c g     F .text	0000008c strlen
0003c264 g     F .text	000000f0 pxPortInitialiseStack
000191d0 g     F .text	0000010c lwip_fcntl
00012174 g     F .text	00000154 open
0002ec1c g     F .text	0000001c udp_init
000631a4 g     O .bss	00008014 ram_heap
0000d894 g     F .text	00000064 __gedf2
0002fc78 g     F .text	00000058 udp_new
00031c54 g     F .text	0000008c alt_flash_cfi_get_info
00016810 g     F .text	0000008c lwip_close
0003c1b4 g     F .text	0000004c enh_alt_irq_disable_all
000360a4 g     F .text	000000a4 tse_mac_aRxRead
0003ce10 g     F .text	00000030 alt_icache_flush_all
00015cd4 g     F .text	000000f4 netbuf_ref
00045746 g     O .rwdata	00000006 ethbroadcast
000106d8 g     F .text	00000038 vTaskSetTimeOutState
0004145c g     O .rodata	0000000d tcp_backoff
00008d1c g     F .text	0000001c fputs
0001b8b0 g     F .text	0000006c sys_arch_mbox_tryfetch
00006d58 g     F .text	00000024 __vfprintf_internal
0003b478 g     F .text	000002a4 altera_avalon_uart_read
0000ef44 g     F .text	00000030 uxQueueMessagesWaitingFromISR
000163c0 g     F .text	00000300 lwip_accept
0003be60 g     F .text	00000060 __env_lock
00012fb8 g     F .text	000001a8 netconn_recv
0000f3a0 g     F .text	00000038 xQueueIsQueueEmptyFromISR
0001414c g     F .text	0000005c do_newconn
00037278 g     F .text	000000e0 alt_tse_mac_set_speed
0001b6fc g     F .text	0000004c sys_mbox_post
000353d8 g     F .text	00000080 alt_avalon_sgdma_construct_mem_to_mem_desc_burst
0000d280 g     F .text	00000060 __subdf3
00003da4 g     F .text	000001fc vStartSemaphoreTasks
0000a700 g     F .text	000000b0 __lo0bits
00014ba8 g     F .text	00000238 do_connect
00045770 g     O .rwdata	00000008 alt_alarm_list
00011a70 g     F .text	0000005c _do_ctors
00039f34 g     F .text	00000248 alt_tse_phy_set_adv_100
0002ea14 g     F .text	000000f0 sys_untimeout
00026e98 g     F .text	00000e8c tcp_input
0000e704 g     F .text	000000d8 xQueueCreateMutex
000199bc g     F .text	00000048 close
0003e87c g     F .text	00000068 alt_program_amd
00047c14 g     O .bss	00000004 alt_envsem
0001edc4 g     F .text	00000544 ip_input
000030c4 g     F .text	00000038 get_hostname
00015058 g     F .text	0000022c do_send
00011eb8 g     F .text	00000080 alt_load
0004574c g     O .rwdata	00000006 ethzero
0000de54 g     F .text	00000224 __pack_d
00024a0c g     F .text	0000001c stats_init
00037040 g     F .text	0000006c alt_tse_get_system_index
00035d6c g     F .text	000000a4 alt_avalon_sgdma_init
000228ac g     F .text	000000e0 netif_find
0003f210 g     F .text	00000014 free
00008bcc g     F .text	00000004 __sinit_lock_acquire
00002e3c g     F .text	000000b0 xEthernetRun
0000a480 g     F .text	00000114 __multadd
0001954c g     F .text	000000d0 tcpip_callback_with_block
0000a458 g     F .text	00000028 _Bfree
00035f38 g     F .text	0000002c no_printf
00023a60 g     F .text	0000009c pbuf_dechain



Disassembly of section .entry:

05000000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && !defined(ALT_SIM_OPTIMIZE)
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
 5000000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
 5000004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
 5000008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
 500000c:	00bffd16 	blt	zero,r2,5000004 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 5000010:	00400034 	movhi	at,0
    ori r1, r1, %lo(_start)
 5000014:	08408914 	ori	at,at,548
    jmp r1
 5000018:	0800683a 	jmp	at
 500001c:	00000000 	call	0 <__alt_mem_sdram>

Disassembly of section .exceptions:

00000020 <save_context>:
# Entry point for exceptions.
.section .exceptions.entry, "xa"

# Save the entire context of a task.
save_context:
	addi	ea, ea, -4			# Point to the next instruction.
  20:	ef7fff04 	addi	ea,ea,-4
	addi	sp,	sp, -120		# Create space on the stack.
  24:	deffe204 	addi	sp,sp,-120
	stw		ra, 0(sp)
  28:	dfc00015 	stw	ra,0(sp)
								# Leave a gap for muldiv 0
	stw		at, 8(sp)		 
  2c:	d8400215 	stw	at,8(sp)
	stw		r2, 12(sp)
  30:	d8800315 	stw	r2,12(sp)
	stw		r3, 16(sp)
  34:	d8c00415 	stw	r3,16(sp)
	stw		r4, 20(sp)
  38:	d9000515 	stw	r4,20(sp)
	stw		r5, 24(sp) 
  3c:	d9400615 	stw	r5,24(sp)
	stw		r6, 28(sp) 
  40:	d9800715 	stw	r6,28(sp)
	stw		r7, 32(sp) 
  44:	d9c00815 	stw	r7,32(sp)
	stw		r8, 36(sp) 
  48:	da000915 	stw	r8,36(sp)
	stw		r9, 40(sp) 
  4c:	da400a15 	stw	r9,40(sp)
	stw		r10, 44(sp)
  50:	da800b15 	stw	r10,44(sp)
	stw		r11, 48(sp)
  54:	dac00c15 	stw	r11,48(sp)
	stw		r12, 52(sp)
  58:	db000d15 	stw	r12,52(sp)
	stw		r13, 56(sp)
  5c:	db400e15 	stw	r13,56(sp)
	stw		r14, 60(sp)
  60:	db800f15 	stw	r14,60(sp)
	stw		r15, 64(sp)
  64:	dbc01015 	stw	r15,64(sp)
	rdctl	r5, estatus 		# Save the eStatus
  68:	000b307a 	rdctl	r5,estatus
	stw		r5, 68(sp)
  6c:	d9401115 	stw	r5,68(sp)
	stw		ea, 72(sp)			# Save the PC
  70:	df401215 	stw	ea,72(sp)
	stw		r16, 76(sp)			# Save the remaining registers
  74:	dc001315 	stw	r16,76(sp)
	stw		r17, 80(sp)
  78:	dc401415 	stw	r17,80(sp)
	stw		r18, 84(sp)
  7c:	dc801515 	stw	r18,84(sp)
	stw		r19, 88(sp)
  80:	dcc01615 	stw	r19,88(sp)
	stw		r20, 92(sp)
  84:	dd001715 	stw	r20,92(sp)
	stw		r21, 96(sp)
  88:	dd401815 	stw	r21,96(sp)
	stw		r22, 100(sp)
  8c:	dd801915 	stw	r22,100(sp)
	stw		r23, 104(sp)
  90:	ddc01a15 	stw	r23,104(sp)
	stw		gp, 108(sp)
  94:	de801b15 	stw	gp,108(sp)
	stw		fp, 112(sp)
  98:	df001c15 	stw	fp,112(sp)

	# preserve the errno
	call	__errno				# get the errno pointer
  9c:	003f1b40 	call	3f1b4 <__errno>
	ldw		r3, 0(r2)			# load the errno in r3
  a0:	10c00017 	ldw	r3,0(r2)
	stw		r3, 116(sp)			# store the errno on the stack
  a4:	d8c01d15 	stw	r3,116(sp)

000000a8 <save_sp_to_pxCurrentTCB>:

save_sp_to_pxCurrentTCB:
	call	xTaskGetSchedulerState			# Only save the stack if scheduler has been started
  a8:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    beq		r2,	zero,	hw_irq_test			# If xTaskGetSchedulerState returns 0 it has not been started yet
  ac:	10000426 	beq	r2,zero,c0 <hw_irq_test>
  b0:	06000134 	movhi	et,4

	movia	et, pxCurrentTCB				# Load the address of the pxCurrentTCB pointer
  b4:	c61ec304 	addi	et,et,31500
	ldw		et, (et)						# Load the value of the pxCurrentTCB pointer
  b8:	c6000017 	ldw	et,0(et)
	stw		sp, (et)						# Store the stack pointer into the top of the TCB
  bc:	c6c00015 	stw	sp,0(et)

000000c0 <hw_irq_test>:
hw_irq_test:
	/*
     * Test to see if the exception was a software exception or caused 
     * by an external interrupt, and vector accordingly.
     */
    rdctl	r4, ipending					# Load the Pending Interrupts indication
  c0:	0009313a 	rdctl	r4,ipending
	rdctl	r5, estatus 					# Load the eStatus (enabled interrupts).
  c4:	000b307a 	rdctl	r5,estatus
    andi	r2, r5, 1						# Are interrupts enabled globally.
  c8:	2880004c 	andi	r2,r5,1
    beq		r2, zero, soft_exceptions		# Interrupts are not enabled.
  cc:	10002a26 	beq	r2,zero,178 <soft_exceptions>
    beq		r4, zero, soft_exceptions		# There are no interrupts triggered.
  d0:	20002926 	beq	r4,zero,178 <soft_exceptions>

000000d4 <hw_irq_handler>:

	.section .exceptions.irqhandler, "xa"
hw_irq_handler:
	call	alt_irq_handler					# Call the alt_irq_handler to deliver to the registered interrupt handler.
  d4:	00000d80 	call	d8 <restore_sp_from_pxCurrentTCB>

000000d8 <restore_sp_from_pxCurrentTCB>:
alt_irq_handler:
    .section .exceptions.irqreturn, "xa"
restore_sp_from_pxCurrentTCB:

	call	xTaskGetSchedulerState			# Only restore stack if scheduler has been started
  d8:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    beq		r2,	zero,	restore_context		# If xTaskGetSchedulerState returns 0 it has not been started yet
  dc:	10000426 	beq	r2,zero,f0 <restore_context>
  e0:	06000134 	movhi	et,4

	movia	et, pxCurrentTCB				# Load the address of the pxCurrentTCB pointer
  e4:	c61ec304 	addi	et,et,31500
	ldw		et, (et)						# Load the value of the pxCurrentTCB pointer
  e8:	c6000017 	ldw	et,0(et)
	ldw		sp, (et)						# Load the stack pointer with the top value of the TCB
  ec:	c6c00017 	ldw	sp,0(et)

000000f0 <restore_context>:

restore_context:
	# preserve the errno
	call	__errno			# get the errno pointer
  f0:	003f1b40 	call	3f1b4 <__errno>
	ldw		r3, 116(sp)		# get errno from the stack
  f4:	d8c01d17 	ldw	r3,116(sp)
	stw		r3, 0(r2)		# restore the global errno for this task
  f8:	10c00015 	stw	r3,0(r2)

	ldw		ra, 0(sp)		# Restore the registers.
  fc:	dfc00017 	ldw	ra,0(sp)
							# Leave a gap for muldiv 0.
	ldw		at, 8(sp)
 100:	d8400217 	ldw	at,8(sp)

	ldw		r2, 12(sp)		# now restore r2 from the stack
 104:	d8800317 	ldw	r2,12(sp)
	ldw		r3, 16(sp)
 108:	d8c00417 	ldw	r3,16(sp)
	ldw		r4, 20(sp)
 10c:	d9000517 	ldw	r4,20(sp)
	ldw		r5, 24(sp) 
 110:	d9400617 	ldw	r5,24(sp)
	ldw		r6, 28(sp) 
 114:	d9800717 	ldw	r6,28(sp)
	ldw		r7, 32(sp) 
 118:	d9c00817 	ldw	r7,32(sp)
	ldw		r8, 36(sp) 
 11c:	da000917 	ldw	r8,36(sp)
	ldw		r9, 40(sp) 
 120:	da400a17 	ldw	r9,40(sp)
	ldw		r10, 44(sp)
 124:	da800b17 	ldw	r10,44(sp)
	ldw		r11, 48(sp)
 128:	dac00c17 	ldw	r11,48(sp)
	ldw		r12, 52(sp)
 12c:	db000d17 	ldw	r12,52(sp)
	ldw		r13, 56(sp)
 130:	db400e17 	ldw	r13,56(sp)
	ldw		r14, 60(sp)
 134:	db800f17 	ldw	r14,60(sp)
	ldw		r15, 64(sp)
 138:	dbc01017 	ldw	r15,64(sp)
	ldw		et, 68(sp)		# Load the eStatus
 13c:	de001117 	ldw	et,68(sp)
	wrctl	estatus, et 	# Write the eStatus
 140:	c001707a 	wrctl	estatus,et
	ldw		ea, 72(sp)		# Load the Program Counter
 144:	df401217 	ldw	ea,72(sp)
	ldw		r16, 76(sp)
 148:	dc001317 	ldw	r16,76(sp)
	ldw		r17, 80(sp)
 14c:	dc401417 	ldw	r17,80(sp)
	ldw		r18, 84(sp)
 150:	dc801517 	ldw	r18,84(sp)
	ldw		r19, 88(sp)
 154:	dcc01617 	ldw	r19,88(sp)
	ldw		r20, 92(sp)
 158:	dd001717 	ldw	r20,92(sp)
	ldw		r21, 96(sp)
 15c:	dd401817 	ldw	r21,96(sp)
	ldw		r22, 100(sp)
 160:	dd801917 	ldw	r22,100(sp)
	ldw		r23, 104(sp)
 164:	ddc01a17 	ldw	r23,104(sp)
	ldw		gp, 108(sp)
 168:	de801b17 	ldw	gp,108(sp)
	ldw		fp, 112(sp)
 16c:	df001c17 	ldw	fp,112(sp)
	addi	sp,	sp, 120		# Release stack space
 170:	dec01e04 	addi	sp,sp,120

    eret					# Return to address ea, loading eStatus into Status.
 174:	ef80083a 	eret

00000178 <soft_exceptions>:
   
	.section .exceptions.soft, "xa"
soft_exceptions:
	ldw		et, 0(ea)				# Load the instruction where the interrupt occured.
 178:	ee000017 	ldw	et,0(ea)
	movhi	at, %hi(0x003B683A)		# Load the registers with the trap instruction code
 17c:	00400ef4 	movhi	at,59
	ori		at, at, %lo(0x003B683A)
 180:	085a0e94 	ori	at,at,26682
   	cmpne	et, et, at				# Compare the trap instruction code to the last excuted instruction
 184:	c070c03a 	cmpne	et,et,at
  	beq		et, r0, call_scheduler	# its a trap so switchcontext
 188:	c0000326 	beq	et,zero,198 <call_scheduler>
#ifdef ALT_INCLUDE_INSTRUCTION_RELATED_EXCEPTION_API
  	mov		r4, ea									# load the PC of the exception into r4
 18c:	e809883a 	mov	r4,ea
  	call	alt_instruction_exception_entry			# call the invalid instruction parser and bring up the instruction in the callback
 190:	00001b00 	call	1b0 <alt_instruction_exception_entry>
#else
  	break							# This is an un-implemented instruction or muldiv problem.
#endif
  	br		restore_context			# its something else
 194:	003fd606 	br	f0 <restore_context>

00000198 <call_scheduler>:

call_scheduler:

	call	xTaskGetSchedulerState			# Only restore stack if scheduler has been started
 198:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    beq		r2,	zero,	restore_context		# If xTaskGetSchedulerState returns 0 it has not been started yet
 19c:	103fd426 	beq	r2,zero,f0 <restore_context>

	addi	ea, ea, 4						# A trap was called, increment the program counter so it is not called again.
 1a0:	ef400104 	addi	ea,ea,4
	stw		ea, 72(sp)						# Save the new program counter to the context.
 1a4:	df401215 	stw	ea,72(sp)
	call	vTaskSwitchContext				# Pick the next context.
 1a8:	00103c00 	call	103c0 <vTaskSwitchContext>
	br		restore_sp_from_pxCurrentTCB	# Switch in the task context and restore.
 1ac:	003fca06 	br	d8 <restore_sp_from_pxCurrentTCB>

000001b0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
 1b0:	defffb04 	addi	sp,sp,-20
 1b4:	dfc00415 	stw	ra,16(sp)
 1b8:	df000315 	stw	fp,12(sp)
 1bc:	df000304 	addi	fp,sp,12
 1c0:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
 1c4:	000531fa 	rdctl	r2,exception
 1c8:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
 1cc:	e0bffd17 	ldw	r2,-12(fp)
 1d0:	10801f0c 	andi	r2,r2,124
 1d4:	1004d0ba 	srli	r2,r2,2
 1d8:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
 1dc:	0005333a 	rdctl	r2,badaddr
 1e0:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
 1e4:	d0a94f17 	ldw	r2,-23236(gp)
 1e8:	10000726 	beq	r2,zero,208 <alt_instruction_exception_entry+0x58>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
 1ec:	d0e94f17 	ldw	r3,-23236(gp)
 1f0:	e0bffd17 	ldw	r2,-12(fp)
 1f4:	1009883a 	mov	r4,r2
 1f8:	e17fff17 	ldw	r5,-4(fp)
 1fc:	e1bffe17 	ldw	r6,-8(fp)
 200:	183ee83a 	callr	r3
 204:	00000206 	br	210 <alt_instruction_exception_entry+0x60>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
 208:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
 20c:	0005883a 	mov	r2,zero
}
 210:	e037883a 	mov	sp,fp
 214:	dfc00117 	ldw	ra,4(sp)
 218:	df000017 	ldw	fp,0(sp)
 21c:	dec00204 	addi	sp,sp,8
 220:	f800283a 	ret

Disassembly of section .text:

00000224 <_start>:
     * writing zero to SSTATUS register and executing an ERET instruction
     * to set STATUS.CRS to 0.
     */
    
    /* Get the current register set number (STATUS.CRS). */
    rdctl r2, status
     224:	0005303a 	rdctl	r2,status
    andi r2, r2, NIOS2_STATUS_CRS_MSK
     228:	10bf000c 	andi	r2,r2,64512
    
    /* Skip switching register set if STATUS.CRS is 0.  */
    beq r2, zero, 0f
     22c:	10000426 	beq	r2,zero,240 <_start+0x1c>

    /* Set SSTATUS to 0 to get to set SSTATUS.PRS to 0. */
    .set nobreak
    movui sstatus, 0
     230:	07800014 	movui	ba,0
    .set break

    /* Switch to register set 0 and jump to label. */
    movhi ea, %hi(0f)
     234:	07400034 	movhi	ea,0
    ori ea, ea, %lo(0f)
     238:	ef409014 	ori	ea,ea,576
    eret
     23c:	ef80083a 	eret

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
     240:	06c08034 	movhi	sp,512
    ori sp, sp, %lo(__alt_stack_pointer)
     244:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
     248:	06800134 	movhi	gp,4
    ori gp, gp, %lo(_gp)
     24c:	d6b5bc14 	ori	gp,gp,55024
    /* 
     * Setup registers in shadow register sets
     * from 1 to NIOS2_NUM_OF_SHADOW_REG_SETS.
     */

    movui r2, 0     /* Contains value written into STATUS */
     250:	00800014 	movui	r2,0
    movui r3, NIOS2_NUM_OF_SHADOW_REG_SETS  /* counter */
     254:	00c00054 	movui	r3,1
    movhi r4, 1     /* Constant to increment STATUS.PRS */
     258:	01000074 	movhi	r4,1
    
.Linitialize_shadow_registers:
    /* Increment STATUS.PRS */
    add r2, r2, r4
     25c:	1105883a 	add	r2,r2,r4
    wrctl status, r2
     260:	1001703a 	wrctl	status,r2

    /* Clear r0 in the shadow register set (not done by hardware) */
    wrprs r0, r0
     264:	0000a03a 	wrprs	zero,zero

    /* Write the GP in previous register set */
    wrprs gp, gp
     268:	d034a03a 	wrprs	gp,gp
    wrprs r30, r0    /* ba */
    wrprs r31, r0    /* ra */
#endif /* NIOS2_ECC_PRESENT */

    /* Decrement shadow register set counter */
    addi r3, r3, -1
     26c:	18ffffc4 	addi	r3,r3,-1

    /* Done if index is 0. */
    bne r3, zero, .Linitialize_shadow_registers
     270:	183ffa1e 	bne	r3,zero,25c <_start+0x38>
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
     274:	00800134 	movhi	r2,4
    ori r2, r2, %lo(__bss_start)
     278:	109e7214 	ori	r2,r2,31176

    movhi r3, %hi(__bss_end)
     27c:	00c001b4 	movhi	r3,6
    ori r3, r3, %lo(__bss_end)
     280:	18ed7f14 	ori	r3,r3,46588

    beq r2, r3, 1f
     284:	10c00326 	beq	r2,r3,294 <_start+0x70>

0:
    stw zero, (r2)
     288:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
     28c:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
     290:	10fffd36 	bltu	r2,r3,288 <_start+0x64>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
     294:	0011eb80 	call	11eb8 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
     298:	000e30c0 	call	e30c <alt_main>

0000029c <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
     29c:	003fff06 	br	29c <alt_after_alt_main>

000002a0 <vBasicWEBServer>:
 *
 *  \param pvParameters   Input. Not Used.
 *
 */
portTASK_FUNCTION( vBasicWEBServer, pvParameters )
{
     2a0:	defffb04 	addi	sp,sp,-20
     2a4:	dfc00415 	stw	ra,16(sp)
     2a8:	df000315 	stw	fp,12(sp)
     2ac:	df000304 	addi	fp,sp,12
     2b0:	e13fff15 	stw	r4,-4(fp)
struct netconn *pxHTTPListener, *pxNewConnection;

	/* Create a new tcp connection handle */
	pxHTTPListener = netconn_new( NETCONN_TCP );
     2b4:	01000404 	movi	r4,16
     2b8:	000b883a 	mov	r5,zero
     2bc:	000d883a 	mov	r6,zero
     2c0:	00125380 	call	12538 <netconn_new_with_proto_and_callback>
     2c4:	e0bffd15 	stw	r2,-12(fp)
	netconn_bind(pxHTTPListener, NULL, webHTTP_PORT );
     2c8:	e13ffd17 	ldw	r4,-12(fp)
     2cc:	000b883a 	mov	r5,zero
     2d0:	01801404 	movi	r6,80
     2d4:	00127900 	call	12790 <netconn_bind>
	netconn_listen( pxHTTPListener );
     2d8:	e13ffd17 	ldw	r4,-12(fp)
     2dc:	01403fc4 	movi	r5,255
     2e0:	00129fc0 	call	129fc <netconn_listen_with_backlog>
     2e4:	00000106 	br	2ec <vBasicWEBServer+0x4c>
	for( ;; ) {
		/* Wait for a first connection. */
		if(netconn_accept(pxHTTPListener, &pxNewConnection) == ERR_OK) {
			prvweb_ParseHTMLRequest(pxNewConnection);
		}/* end if new connection */
	} /* end infinite loop */
     2e8:	0001883a 	nop
	netconn_listen( pxHTTPListener );

	/* Loop forever */
	for( ;; ) {
		/* Wait for a first connection. */
		if(netconn_accept(pxHTTPListener, &pxNewConnection) == ERR_OK) {
     2ec:	e0bffe04 	addi	r2,fp,-8
     2f0:	e13ffd17 	ldw	r4,-12(fp)
     2f4:	100b883a 	mov	r5,r2
     2f8:	0012ac80 	call	12ac8 <netconn_accept>
     2fc:	10803fcc 	andi	r2,r2,255
     300:	1080201c 	xori	r2,r2,128
     304:	10bfe004 	addi	r2,r2,-128
     308:	103ff71e 	bne	r2,zero,2e8 <vBasicWEBServer+0x48>
			prvweb_ParseHTMLRequest(pxNewConnection);
     30c:	e0bffe17 	ldw	r2,-8(fp)
     310:	1009883a 	mov	r4,r2
     314:	000031c0 	call	31c <prvweb_ParseHTMLRequest>
		}/* end if new connection */
	} /* end infinite loop */
     318:	003ff306 	br	2e8 <vBasicWEBServer+0x48>

0000031c <prvweb_ParseHTMLRequest>:
 *
 *  \param pxNetCon   Input. The netconn to use to send and receive data.
 *
 */
static void prvweb_ParseHTMLRequest( struct netconn *pxNetCon )
{
     31c:	defff904 	addi	sp,sp,-28
     320:	dfc00615 	stw	ra,24(sp)
     324:	df000515 	stw	fp,20(sp)
     328:	df000504 	addi	fp,sp,20
     32c:	e13fff15 	stw	r4,-4(fp)
portCHAR *pcRxString;
unsigned portSHORT usLength;
static unsigned portLONG ulPageHits = 0;

	/* We expect to immediately get data. */
	if(netconn_recv(pxNetCon, &pxRxBuffer) == ERR_OK)
     330:	e13fff17 	ldw	r4,-4(fp)
     334:	e17ffc04 	addi	r5,fp,-16
     338:	0012fb80 	call	12fb8 <netconn_recv>
     33c:	10803fcc 	andi	r2,r2,255
     340:	1080201c 	xori	r2,r2,128
     344:	10bfe004 	addi	r2,r2,-128
     348:	1000641e 	bne	r2,zero,4dc <prvweb_ParseHTMLRequest+0x1c0>
	{
		/* Where is the data? */
		netbuf_data( pxRxBuffer, ( void * ) &pcRxString, &usLength );
     34c:	e13ffc17 	ldw	r4,-16(fp)
     350:	e0fffd04 	addi	r3,fp,-12
     354:	e0bffe04 	addi	r2,fp,-8
     358:	180b883a 	mov	r5,r3
     35c:	100d883a 	mov	r6,r2
     360:	0015e840 	call	15e84 <netbuf_data>

		/* Is this a GET?  We don't handle anything else. */
		if( !strncmp( pcRxString, "GET", 3 ) )
     364:	e0bffd17 	ldw	r2,-12(fp)
     368:	1009883a 	mov	r4,r2
     36c:	01400134 	movhi	r5,4
     370:	297dec04 	addi	r5,r5,-2128
     374:	018000c4 	movi	r6,3
     378:	0004e280 	call	4e28 <strncmp>
     37c:	1000541e 	bne	r2,zero,4d0 <prvweb_ParseHTMLRequest+0x1b4>
		{
			pcRxString = cDynamicPage;
     380:	008001b4 	movhi	r2,6
     384:	10895904 	addi	r2,r2,9572
     388:	e0bffd15 	stw	r2,-12(fp)

			/* Update the hit count. */
			ulPageHits++;
     38c:	d0a8b617 	ldw	r2,-23848(gp)
     390:	10800044 	addi	r2,r2,1
     394:	d0a8b615 	stw	r2,-23848(gp)
			sprintf( cPageHits, "%d", (int)ulPageHits );
     398:	d0a8b617 	ldw	r2,-23848(gp)
     39c:	010001b4 	movhi	r4,6
     3a0:	210c5904 	addi	r4,r4,12644
     3a4:	01400134 	movhi	r5,4
     3a8:	297ded04 	addi	r5,r5,-2124
     3ac:	100d883a 	mov	r6,r2
     3b0:	00045a00 	call	45a0 <sprintf>

			/* Write out the HTTP OK header. */
			netconn_write( pxNetCon, webHTTP_OK, (u16_t) strlen( webHTTP_OK ), NETCONN_COPY );
     3b4:	d8000015 	stw	zero,0(sp)
     3b8:	e13fff17 	ldw	r4,-4(fp)
     3bc:	01400134 	movhi	r5,4
     3c0:	297dee04 	addi	r5,r5,-2120
     3c4:	01800b04 	movi	r6,44
     3c8:	01c00044 	movi	r7,1
     3cc:	00133240 	call	13324 <netconn_write_partly>

			/* Generate the dynamic page... First the page header. */
			strcpy( cDynamicPage, webHTML_START );
     3d0:	00c001b4 	movhi	r3,6
     3d4:	18c95904 	addi	r3,r3,9572
     3d8:	00800134 	movhi	r2,4
     3dc:	10bdfa04 	addi	r2,r2,-2072
     3e0:	1809883a 	mov	r4,r3
     3e4:	1007883a 	mov	r3,r2
     3e8:	00802444 	movi	r2,145
     3ec:	180b883a 	mov	r5,r3
     3f0:	100d883a 	mov	r6,r2
     3f4:	00041f00 	call	41f0 <memcpy>

			/* ... Then the hit count... */
			strcat( cDynamicPage, cPageHits );
     3f8:	010001b4 	movhi	r4,6
     3fc:	21095904 	addi	r4,r4,9572
     400:	014001b4 	movhi	r5,6
     404:	294c5904 	addi	r5,r5,12644
     408:	000460c0 	call	460c <strcat>
			strcat( cDynamicPage, "<p><pre>Task          State  Priority  Stack	#<br>************************************************<br>" );
     40c:	010001b4 	movhi	r4,6
     410:	21095904 	addi	r4,r4,9572
     414:	0004d9c0 	call	4d9c <strlen>
     418:	1007883a 	mov	r3,r2
     41c:	008001b4 	movhi	r2,6
     420:	10895904 	addi	r2,r2,9572
     424:	1887883a 	add	r3,r3,r2
     428:	00800134 	movhi	r2,4
     42c:	10be1f04 	addi	r2,r2,-1924
     430:	1809883a 	mov	r4,r3
     434:	1007883a 	mov	r3,r2
     438:	008019c4 	movi	r2,103
     43c:	180b883a 	mov	r5,r3
     440:	100d883a 	mov	r6,r2
     444:	00041f00 	call	41f0 <memcpy>

			/* ... Then the list of tasks and their status... */
			vTaskList( ( signed portCHAR * ) cDynamicPage + strlen( cDynamicPage ) );
     448:	010001b4 	movhi	r4,6
     44c:	21095904 	addi	r4,r4,9572
     450:	0004d9c0 	call	4d9c <strlen>
     454:	00c001b4 	movhi	r3,6
     458:	18c95904 	addi	r3,r3,9572
     45c:	10c5883a 	add	r2,r2,r3
     460:	1009883a 	mov	r4,r2
     464:	00101000 	call	10100 <vTaskList>

			/* ... Finally the page footer. */
			strcat( cDynamicPage, webHTML_END );
     468:	010001b4 	movhi	r4,6
     46c:	21095904 	addi	r4,r4,9572
     470:	0004d9c0 	call	4d9c <strlen>
     474:	1007883a 	mov	r3,r2
     478:	008001b4 	movhi	r2,6
     47c:	10895904 	addi	r2,r2,9572
     480:	1887883a 	add	r3,r3,r2
     484:	00800134 	movhi	r2,4
     488:	10be3904 	addi	r2,r2,-1820
     48c:	1809883a 	mov	r4,r3
     490:	1007883a 	mov	r3,r2
     494:	00800804 	movi	r2,32
     498:	180b883a 	mov	r5,r3
     49c:	100d883a 	mov	r6,r2
     4a0:	00041f00 	call	41f0 <memcpy>

			/* Write out the dynamically generated page. */
			netconn_write( pxNetCon, cDynamicPage, (u16_t) strlen( cDynamicPage ), NETCONN_COPY );
     4a4:	010001b4 	movhi	r4,6
     4a8:	21095904 	addi	r4,r4,9572
     4ac:	0004d9c0 	call	4d9c <strlen>
     4b0:	10bfffcc 	andi	r2,r2,65535
     4b4:	d8000015 	stw	zero,0(sp)
     4b8:	e13fff17 	ldw	r4,-4(fp)
     4bc:	014001b4 	movhi	r5,6
     4c0:	29495904 	addi	r5,r5,9572
     4c4:	100d883a 	mov	r6,r2
     4c8:	01c00044 	movi	r7,1
     4cc:	00133240 	call	13324 <netconn_write_partly>
		}
		netbuf_delete( pxRxBuffer );
     4d0:	e0bffc17 	ldw	r2,-16(fp)
     4d4:	1009883a 	mov	r4,r2
     4d8:	0015b180 	call	15b18 <netbuf_delete>
	}

	netconn_close( pxNetCon );
     4dc:	e13fff17 	ldw	r4,-4(fp)
     4e0:	00135940 	call	13594 <netconn_close>
	netconn_delete( pxNetCon );
     4e4:	e13fff17 	ldw	r4,-4(fp)
     4e8:	00125f40 	call	125f4 <netconn_delete>
}
     4ec:	e037883a 	mov	sp,fp
     4f0:	dfc00117 	ldw	ra,4(sp)
     4f4:	df000017 	ldw	fp,0(sp)
     4f8:	dec00204 	addi	sp,sp,8
     4fc:	f800283a 	ret

00000500 <vStartBlockingQueueTasks>:
static volatile short sBlockingProducerCount[ blckqNUM_TASK_SETS ] = { ( unsigned short ) 0, ( unsigned short ) 0, ( unsigned short ) 0 };

/*-----------------------------------------------------------*/

void vStartBlockingQueueTasks( unsigned portBASE_TYPE uxPriority )
{
     500:	deffef04 	addi	sp,sp,-68
     504:	dfc01015 	stw	ra,64(sp)
     508:	df000f15 	stw	fp,60(sp)
     50c:	df000f04 	addi	fp,sp,60
     510:	e13fff15 	stw	r4,-4(fp)
xBlockingQueueParameters *pxQueueParameters1, *pxQueueParameters2;
xBlockingQueueParameters *pxQueueParameters3, *pxQueueParameters4;
xBlockingQueueParameters *pxQueueParameters5, *pxQueueParameters6;
const unsigned portBASE_TYPE uxQueueSize1 = 1, uxQueueSize5 = 5;
     514:	00800044 	movi	r2,1
     518:	e0bff515 	stw	r2,-44(fp)
     51c:	00800144 	movi	r2,5
     520:	e0bff615 	stw	r2,-40(fp)
const portTickType xBlockTime = ( portTickType ) 1000 / portTICK_RATE_MS;
     524:	0080fa04 	movi	r2,1000
     528:	e0bff715 	stw	r2,-36(fp)
const portTickType xDontBlock = ( portTickType ) 0;
     52c:	e03ff815 	stw	zero,-32(fp)

	/* Create the first two tasks as described at the top of the file. */
	
	/* First create the structure used to pass parameters to the consumer tasks. */
	pxQueueParameters1 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
     530:	01000304 	movi	r4,12
     534:	000e4980 	call	e498 <pvPortMalloc>
     538:	e0bff915 	stw	r2,-28(fp)

	/* Create the queue used by the first two tasks to pass the incrementing number.
	Pass a pointer to the queue in the parameter structure. */
	pxQueueParameters1->xQueue = xQueueCreate( uxQueueSize1, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );
     53c:	e13ff517 	ldw	r4,-44(fp)
     540:	01400084 	movi	r5,2
     544:	000d883a 	mov	r6,zero
     548:	000e6380 	call	e638 <xQueueGenericCreate>
     54c:	e0fff917 	ldw	r3,-28(fp)
     550:	18800015 	stw	r2,0(r3)

	/* The consumer is created first so gets a block time as described above. */
	pxQueueParameters1->xBlockTime = xBlockTime;
     554:	e0bff917 	ldw	r2,-28(fp)
     558:	e0fff717 	ldw	r3,-36(fp)
     55c:	10c00115 	stw	r3,4(r2)

	/* Pass in the variable that this task is going to increment so we can check it
	is still running. */
	pxQueueParameters1->psCheckVariable = &( sBlockingConsumerCount[ 0 ] );
     560:	e0bff917 	ldw	r2,-28(fp)
     564:	d0e8b704 	addi	r3,gp,-23844
     568:	10c00215 	stw	r3,8(r2)
		
	/* Create the structure used to pass parameters to the producer task. */
	pxQueueParameters2 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
     56c:	01000304 	movi	r4,12
     570:	000e4980 	call	e498 <pvPortMalloc>
     574:	e0bffa15 	stw	r2,-24(fp)

	/* Pass the queue to this task also, using the parameter structure. */
	pxQueueParameters2->xQueue = pxQueueParameters1->xQueue;
     578:	e0bff917 	ldw	r2,-28(fp)
     57c:	10c00017 	ldw	r3,0(r2)
     580:	e0bffa17 	ldw	r2,-24(fp)
     584:	10c00015 	stw	r3,0(r2)

	/* The producer is not going to block - as soon as it posts the consumer will
	wake and remove the item so the producer should always have room to post. */
	pxQueueParameters2->xBlockTime = xDontBlock;
     588:	e0bffa17 	ldw	r2,-24(fp)
     58c:	e0fff817 	ldw	r3,-32(fp)
     590:	10c00115 	stw	r3,4(r2)

	/* Pass in the variable that this task is going to increment so we can check
	it is still running. */
	pxQueueParameters2->psCheckVariable = &( sBlockingProducerCount[ 0 ] );
     594:	e0bffa17 	ldw	r2,-24(fp)
     598:	d0e8b884 	addi	r3,gp,-23838
     59c:	10c00215 	stw	r3,8(r2)


	/* Note the producer has a lower priority than the consumer when the tasks are
	spawned. */
	xTaskCreate( vBlockingQueueConsumer, ( signed char * ) "QConsB1", blckqSTACK_SIZE, ( void * ) pxQueueParameters1, uxPriority, NULL );
     5a0:	e0bfff17 	ldw	r2,-4(fp)
     5a4:	d8800015 	stw	r2,0(sp)
     5a8:	d8000115 	stw	zero,4(sp)
     5ac:	d8000215 	stw	zero,8(sp)
     5b0:	d8000315 	stw	zero,12(sp)
     5b4:	01000034 	movhi	r4,0
     5b8:	21020f04 	addi	r4,r4,2108
     5bc:	01400134 	movhi	r5,4
     5c0:	297e4104 	addi	r5,r5,-1788
     5c4:	018c9604 	movi	r6,12888
     5c8:	e1fff917 	ldw	r7,-28(fp)
     5cc:	000f5140 	call	f514 <xTaskGenericCreate>
	xTaskCreate( vBlockingQueueProducer, ( signed char * ) "QProdB2", blckqSTACK_SIZE, ( void * ) pxQueueParameters2, tskIDLE_PRIORITY, NULL );
     5d0:	d8000015 	stw	zero,0(sp)
     5d4:	d8000115 	stw	zero,4(sp)
     5d8:	d8000215 	stw	zero,8(sp)
     5dc:	d8000315 	stw	zero,12(sp)
     5e0:	01000034 	movhi	r4,0
     5e4:	2101ed04 	addi	r4,r4,1972
     5e8:	01400134 	movhi	r5,4
     5ec:	297e4304 	addi	r5,r5,-1780
     5f0:	018c9604 	movi	r6,12888
     5f4:	e1fffa17 	ldw	r7,-24(fp)
     5f8:	000f5140 	call	f514 <xTaskGenericCreate>
	

	/* Create the second two tasks as described at the top of the file.   This uses
	the same mechanism but reverses the task priorities. */

	pxQueueParameters3 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
     5fc:	01000304 	movi	r4,12
     600:	000e4980 	call	e498 <pvPortMalloc>
     604:	e0bffb15 	stw	r2,-20(fp)
	pxQueueParameters3->xQueue = xQueueCreate( uxQueueSize1, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );
     608:	e13ff517 	ldw	r4,-44(fp)
     60c:	01400084 	movi	r5,2
     610:	000d883a 	mov	r6,zero
     614:	000e6380 	call	e638 <xQueueGenericCreate>
     618:	e0fffb17 	ldw	r3,-20(fp)
     61c:	18800015 	stw	r2,0(r3)
	pxQueueParameters3->xBlockTime = xDontBlock;
     620:	e0bffb17 	ldw	r2,-20(fp)
     624:	e0fff817 	ldw	r3,-32(fp)
     628:	10c00115 	stw	r3,4(r2)
	pxQueueParameters3->psCheckVariable = &( sBlockingProducerCount[ 1 ] );
     62c:	e0bffb17 	ldw	r2,-20(fp)
     630:	00c00134 	movhi	r3,4
     634:	18de7504 	addi	r3,r3,31188
     638:	10c00215 	stw	r3,8(r2)

	pxQueueParameters4 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
     63c:	01000304 	movi	r4,12
     640:	000e4980 	call	e498 <pvPortMalloc>
     644:	e0bffc15 	stw	r2,-16(fp)
	pxQueueParameters4->xQueue = pxQueueParameters3->xQueue;
     648:	e0bffb17 	ldw	r2,-20(fp)
     64c:	10c00017 	ldw	r3,0(r2)
     650:	e0bffc17 	ldw	r2,-16(fp)
     654:	10c00015 	stw	r3,0(r2)
	pxQueueParameters4->xBlockTime = xBlockTime;
     658:	e0bffc17 	ldw	r2,-16(fp)
     65c:	e0fff717 	ldw	r3,-36(fp)
     660:	10c00115 	stw	r3,4(r2)
	pxQueueParameters4->psCheckVariable = &( sBlockingConsumerCount[ 1 ] );
     664:	e0bffc17 	ldw	r2,-16(fp)
     668:	00c00134 	movhi	r3,4
     66c:	18de7384 	addi	r3,r3,31182
     670:	10c00215 	stw	r3,8(r2)

	xTaskCreate( vBlockingQueueConsumer, ( signed char * ) "QConsB3", blckqSTACK_SIZE, ( void * ) pxQueueParameters3, tskIDLE_PRIORITY, NULL );
     674:	d8000015 	stw	zero,0(sp)
     678:	d8000115 	stw	zero,4(sp)
     67c:	d8000215 	stw	zero,8(sp)
     680:	d8000315 	stw	zero,12(sp)
     684:	01000034 	movhi	r4,0
     688:	21020f04 	addi	r4,r4,2108
     68c:	01400134 	movhi	r5,4
     690:	297e4504 	addi	r5,r5,-1772
     694:	018c9604 	movi	r6,12888
     698:	e1fffb17 	ldw	r7,-20(fp)
     69c:	000f5140 	call	f514 <xTaskGenericCreate>
	xTaskCreate( vBlockingQueueProducer, ( signed char * ) "QProdB4", blckqSTACK_SIZE, ( void * ) pxQueueParameters4, uxPriority, NULL );
     6a0:	e0bfff17 	ldw	r2,-4(fp)
     6a4:	d8800015 	stw	r2,0(sp)
     6a8:	d8000115 	stw	zero,4(sp)
     6ac:	d8000215 	stw	zero,8(sp)
     6b0:	d8000315 	stw	zero,12(sp)
     6b4:	01000034 	movhi	r4,0
     6b8:	2101ed04 	addi	r4,r4,1972
     6bc:	01400134 	movhi	r5,4
     6c0:	297e4704 	addi	r5,r5,-1764
     6c4:	018c9604 	movi	r6,12888
     6c8:	e1fffc17 	ldw	r7,-16(fp)
     6cc:	000f5140 	call	f514 <xTaskGenericCreate>



	/* Create the last two tasks as described above.  The mechanism is again just
	the same.  This time both parameter structures are given a block time. */
	pxQueueParameters5 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
     6d0:	01000304 	movi	r4,12
     6d4:	000e4980 	call	e498 <pvPortMalloc>
     6d8:	e0bffd15 	stw	r2,-12(fp)
	pxQueueParameters5->xQueue = xQueueCreate( uxQueueSize5, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );
     6dc:	e13ff617 	ldw	r4,-40(fp)
     6e0:	01400084 	movi	r5,2
     6e4:	000d883a 	mov	r6,zero
     6e8:	000e6380 	call	e638 <xQueueGenericCreate>
     6ec:	e0fffd17 	ldw	r3,-12(fp)
     6f0:	18800015 	stw	r2,0(r3)
	pxQueueParameters5->xBlockTime = xBlockTime;
     6f4:	e0bffd17 	ldw	r2,-12(fp)
     6f8:	e0fff717 	ldw	r3,-36(fp)
     6fc:	10c00115 	stw	r3,4(r2)
	pxQueueParameters5->psCheckVariable = &( sBlockingProducerCount[ 2 ] );
     700:	e0bffd17 	ldw	r2,-12(fp)
     704:	00c00134 	movhi	r3,4
     708:	18de7584 	addi	r3,r3,31190
     70c:	10c00215 	stw	r3,8(r2)

	pxQueueParameters6 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
     710:	01000304 	movi	r4,12
     714:	000e4980 	call	e498 <pvPortMalloc>
     718:	e0bffe15 	stw	r2,-8(fp)
	pxQueueParameters6->xQueue = pxQueueParameters5->xQueue;
     71c:	e0bffd17 	ldw	r2,-12(fp)
     720:	10c00017 	ldw	r3,0(r2)
     724:	e0bffe17 	ldw	r2,-8(fp)
     728:	10c00015 	stw	r3,0(r2)
	pxQueueParameters6->xBlockTime = xBlockTime;
     72c:	e0bffe17 	ldw	r2,-8(fp)
     730:	e0fff717 	ldw	r3,-36(fp)
     734:	10c00115 	stw	r3,4(r2)
	pxQueueParameters6->psCheckVariable = &( sBlockingConsumerCount[ 2 ] );	
     738:	e0bffe17 	ldw	r2,-8(fp)
     73c:	00c00134 	movhi	r3,4
     740:	18de7404 	addi	r3,r3,31184
     744:	10c00215 	stw	r3,8(r2)

	xTaskCreate( vBlockingQueueProducer, ( signed char * ) "QProdB5", blckqSTACK_SIZE, ( void * ) pxQueueParameters5, tskIDLE_PRIORITY, NULL );
     748:	d8000015 	stw	zero,0(sp)
     74c:	d8000115 	stw	zero,4(sp)
     750:	d8000215 	stw	zero,8(sp)
     754:	d8000315 	stw	zero,12(sp)
     758:	01000034 	movhi	r4,0
     75c:	2101ed04 	addi	r4,r4,1972
     760:	01400134 	movhi	r5,4
     764:	297e4904 	addi	r5,r5,-1756
     768:	018c9604 	movi	r6,12888
     76c:	e1fffd17 	ldw	r7,-12(fp)
     770:	000f5140 	call	f514 <xTaskGenericCreate>
	xTaskCreate( vBlockingQueueConsumer, ( signed char * ) "QConsB6", blckqSTACK_SIZE, ( void * ) pxQueueParameters6, tskIDLE_PRIORITY, NULL );
     774:	d8000015 	stw	zero,0(sp)
     778:	d8000115 	stw	zero,4(sp)
     77c:	d8000215 	stw	zero,8(sp)
     780:	d8000315 	stw	zero,12(sp)
     784:	01000034 	movhi	r4,0
     788:	21020f04 	addi	r4,r4,2108
     78c:	01400134 	movhi	r5,4
     790:	297e4b04 	addi	r5,r5,-1748
     794:	018c9604 	movi	r6,12888
     798:	e1fffe17 	ldw	r7,-8(fp)
     79c:	000f5140 	call	f514 <xTaskGenericCreate>
}
     7a0:	e037883a 	mov	sp,fp
     7a4:	dfc00117 	ldw	ra,4(sp)
     7a8:	df000017 	ldw	fp,0(sp)
     7ac:	dec00204 	addi	sp,sp,8
     7b0:	f800283a 	ret

000007b4 <vBlockingQueueProducer>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vBlockingQueueProducer, pvParameters )
{
     7b4:	defffa04 	addi	sp,sp,-24
     7b8:	dfc00515 	stw	ra,20(sp)
     7bc:	df000415 	stw	fp,16(sp)
     7c0:	df000404 	addi	fp,sp,16
     7c4:	e13fff15 	stw	r4,-4(fp)
unsigned short usValue = 0;
     7c8:	e03ffe0d 	sth	zero,-8(fp)
xBlockingQueueParameters *pxQueueParameters;
short sErrorEverOccurred = pdFALSE;
     7cc:	e03ffc0d 	sth	zero,-16(fp)

	pxQueueParameters = ( xBlockingQueueParameters * ) pvParameters;
     7d0:	e0bfff17 	ldw	r2,-4(fp)
     7d4:	e0bffd15 	stw	r2,-12(fp)

	for( ;; )
	{		
		if( xQueueSend( pxQueueParameters->xQueue, ( void * ) &usValue, pxQueueParameters->xBlockTime ) != pdPASS )
     7d8:	e0bffd17 	ldw	r2,-12(fp)
     7dc:	11000017 	ldw	r4,0(r2)
     7e0:	e0bffd17 	ldw	r2,-12(fp)
     7e4:	10800117 	ldw	r2,4(r2)
     7e8:	e0fffe04 	addi	r3,fp,-8
     7ec:	180b883a 	mov	r5,r3
     7f0:	100d883a 	mov	r6,r2
     7f4:	000f883a 	mov	r7,zero
     7f8:	000e95c0 	call	e95c <xQueueGenericSend>
     7fc:	10800060 	cmpeqi	r2,r2,1
     800:	1000031e 	bne	r2,zero,810 <vBlockingQueueProducer+0x5c>
		{
			sErrorEverOccurred = pdTRUE;
     804:	00800044 	movi	r2,1
     808:	e0bffc0d 	sth	r2,-16(fp)

			/* Increment the variable we are going to post next time round.  The
			consumer will expect the numbers to	follow in numerical order. */
			++usValue;
		}
	}
     80c:	003ff206 	br	7d8 <vBlockingQueueProducer+0x24>
		}
		else
		{
			/* We have successfully posted a message, so increment the variable
			used to check we are still running. */
			if( sErrorEverOccurred == pdFALSE )
     810:	e0bffc0f 	ldh	r2,-16(fp)
     814:	1000051e 	bne	r2,zero,82c <vBlockingQueueProducer+0x78>
			{
				( *pxQueueParameters->psCheckVariable )++;
     818:	e0bffd17 	ldw	r2,-12(fp)
     81c:	10800217 	ldw	r2,8(r2)
     820:	10c0000b 	ldhu	r3,0(r2)
     824:	18c00044 	addi	r3,r3,1
     828:	10c0000d 	sth	r3,0(r2)
			}

			/* Increment the variable we are going to post next time round.  The
			consumer will expect the numbers to	follow in numerical order. */
			++usValue;
     82c:	e0bffe0b 	ldhu	r2,-8(fp)
     830:	10800044 	addi	r2,r2,1
     834:	e0bffe0d 	sth	r2,-8(fp)
		}
	}
     838:	003fe706 	br	7d8 <vBlockingQueueProducer+0x24>

0000083c <vBlockingQueueConsumer>:
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vBlockingQueueConsumer, pvParameters )
{
     83c:	defffa04 	addi	sp,sp,-24
     840:	dfc00515 	stw	ra,20(sp)
     844:	df000415 	stw	fp,16(sp)
     848:	df000404 	addi	fp,sp,16
     84c:	e13fff15 	stw	r4,-4(fp)
unsigned short usData, usExpectedValue = 0;
     850:	e03ffc0d 	sth	zero,-16(fp)
xBlockingQueueParameters *pxQueueParameters;
short sErrorEverOccurred = pdFALSE;
     854:	e03ffc8d 	sth	zero,-14(fp)

	pxQueueParameters = ( xBlockingQueueParameters * ) pvParameters;
     858:	e0bfff17 	ldw	r2,-4(fp)
     85c:	e0bffd15 	stw	r2,-12(fp)
     860:	00000106 	br	868 <vBlockingQueueConsumer+0x2c>
				/* Increment the value we expect to remove from the queue next time
				round. */
				++usExpectedValue;
			}			
		}		
	}
     864:	0001883a 	nop

	pxQueueParameters = ( xBlockingQueueParameters * ) pvParameters;

	for( ;; )
	{	
		if( xQueueReceive( pxQueueParameters->xQueue, &usData, pxQueueParameters->xBlockTime ) == pdPASS )
     868:	e0bffd17 	ldw	r2,-12(fp)
     86c:	11000017 	ldw	r4,0(r2)
     870:	e0bffd17 	ldw	r2,-12(fp)
     874:	10800117 	ldw	r2,4(r2)
     878:	e0fffe04 	addi	r3,fp,-8
     87c:	180b883a 	mov	r5,r3
     880:	100d883a 	mov	r6,r2
     884:	000f883a 	mov	r7,zero
     888:	000ebd80 	call	ebd8 <xQueueGenericReceive>
     88c:	10800058 	cmpnei	r2,r2,1
     890:	103ff41e 	bne	r2,zero,864 <vBlockingQueueConsumer+0x28>
		{
			if( usData != usExpectedValue )
     894:	e0bffe0b 	ldhu	r2,-8(fp)
     898:	10ffffcc 	andi	r3,r2,65535
     89c:	e0bffc0b 	ldhu	r2,-16(fp)
     8a0:	18800526 	beq	r3,r2,8b8 <vBlockingQueueConsumer+0x7c>
			{
				/* Catch-up. */
				usExpectedValue = usData;
     8a4:	e0bffe0b 	ldhu	r2,-8(fp)
     8a8:	e0bffc0d 	sth	r2,-16(fp)

				sErrorEverOccurred = pdTRUE;
     8ac:	00800044 	movi	r2,1
     8b0:	e0bffc8d 	sth	r2,-14(fp)
				/* Increment the value we expect to remove from the queue next time
				round. */
				++usExpectedValue;
			}			
		}		
	}
     8b4:	003feb06 	br	864 <vBlockingQueueConsumer+0x28>
			}
			else
			{
				/* We have successfully received a message, so increment the
				variable used to check we are still running. */	
				if( sErrorEverOccurred == pdFALSE )
     8b8:	e0bffc8f 	ldh	r2,-14(fp)
     8bc:	1000051e 	bne	r2,zero,8d4 <vBlockingQueueConsumer+0x98>
				{
					( *pxQueueParameters->psCheckVariable )++;
     8c0:	e0bffd17 	ldw	r2,-12(fp)
     8c4:	10800217 	ldw	r2,8(r2)
     8c8:	10c0000b 	ldhu	r3,0(r2)
     8cc:	18c00044 	addi	r3,r3,1
     8d0:	10c0000d 	sth	r3,0(r2)
				}
							
				/* Increment the value we expect to remove from the queue next time
				round. */
				++usExpectedValue;
     8d4:	e0bffc0b 	ldhu	r2,-16(fp)
     8d8:	10800044 	addi	r2,r2,1
     8dc:	e0bffc0d 	sth	r2,-16(fp)
			}			
		}		
	}
     8e0:	003fe006 	br	864 <vBlockingQueueConsumer+0x28>

000008e4 <xAreBlockingQueuesStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
portBASE_TYPE xAreBlockingQueuesStillRunning( void )
{
     8e4:	defffd04 	addi	sp,sp,-12
     8e8:	df000215 	stw	fp,8(sp)
     8ec:	df000204 	addi	fp,sp,8
static short sLastBlockingConsumerCount[ blckqNUM_TASK_SETS ] = { ( unsigned short ) 0, ( unsigned short ) 0, ( unsigned short ) 0 };
static short sLastBlockingProducerCount[ blckqNUM_TASK_SETS ] = { ( unsigned short ) 0, ( unsigned short ) 0, ( unsigned short ) 0 };
portBASE_TYPE xReturn = pdPASS, xTasks;
     8f0:	00800044 	movi	r2,1
     8f4:	e0bffe15 	stw	r2,-8(fp)
	changed or not.
	
	Loop through each check variable to and return pdFALSE if any are found not
	to have changed since the last call. */

	for( xTasks = 0; xTasks < blckqNUM_TASK_SETS; xTasks++ )
     8f8:	e03fff15 	stw	zero,-4(fp)
     8fc:	00003b06 	br	9ec <xAreBlockingQueuesStillRunning+0x108>
	{
		if( sBlockingConsumerCount[ xTasks ] == sLastBlockingConsumerCount[ xTasks ]  )
     900:	e0bfff17 	ldw	r2,-4(fp)
     904:	1087883a 	add	r3,r2,r2
     908:	d0a8b704 	addi	r2,gp,-23844
     90c:	1885883a 	add	r2,r3,r2
     910:	10c0000b 	ldhu	r3,0(r2)
     914:	e0bfff17 	ldw	r2,-4(fp)
     918:	1089883a 	add	r4,r2,r2
     91c:	d0a8ba04 	addi	r2,gp,-23832
     920:	2085883a 	add	r2,r4,r2
     924:	1080000b 	ldhu	r2,0(r2)
     928:	18ffffcc 	andi	r3,r3,65535
     92c:	18e0001c 	xori	r3,r3,32768
     930:	18e00004 	addi	r3,r3,-32768
     934:	10bfffcc 	andi	r2,r2,65535
     938:	10a0001c 	xori	r2,r2,32768
     93c:	10a00004 	addi	r2,r2,-32768
     940:	1880011e 	bne	r3,r2,948 <xAreBlockingQueuesStillRunning+0x64>
		{
			xReturn = pdFALSE;
     944:	e03ffe15 	stw	zero,-8(fp)
		}
		sLastBlockingConsumerCount[ xTasks ] = sBlockingConsumerCount[ xTasks ];
     948:	e0bfff17 	ldw	r2,-4(fp)
     94c:	1087883a 	add	r3,r2,r2
     950:	d0a8b704 	addi	r2,gp,-23844
     954:	1885883a 	add	r2,r3,r2
     958:	10c0000b 	ldhu	r3,0(r2)
     95c:	e0bfff17 	ldw	r2,-4(fp)
     960:	1089883a 	add	r4,r2,r2
     964:	d0a8ba04 	addi	r2,gp,-23832
     968:	2085883a 	add	r2,r4,r2
     96c:	10c0000d 	sth	r3,0(r2)


		if( sBlockingProducerCount[ xTasks ] == sLastBlockingProducerCount[ xTasks ]  )
     970:	e0bfff17 	ldw	r2,-4(fp)
     974:	1087883a 	add	r3,r2,r2
     978:	d0a8b884 	addi	r2,gp,-23838
     97c:	1885883a 	add	r2,r3,r2
     980:	10c0000b 	ldhu	r3,0(r2)
     984:	e0bfff17 	ldw	r2,-4(fp)
     988:	1089883a 	add	r4,r2,r2
     98c:	d0a8bb84 	addi	r2,gp,-23826
     990:	2085883a 	add	r2,r4,r2
     994:	1080000b 	ldhu	r2,0(r2)
     998:	18ffffcc 	andi	r3,r3,65535
     99c:	18e0001c 	xori	r3,r3,32768
     9a0:	18e00004 	addi	r3,r3,-32768
     9a4:	10bfffcc 	andi	r2,r2,65535
     9a8:	10a0001c 	xori	r2,r2,32768
     9ac:	10a00004 	addi	r2,r2,-32768
     9b0:	1880011e 	bne	r3,r2,9b8 <xAreBlockingQueuesStillRunning+0xd4>
		{
			xReturn = pdFALSE;
     9b4:	e03ffe15 	stw	zero,-8(fp)
		}
		sLastBlockingProducerCount[ xTasks ] = sBlockingProducerCount[ xTasks ];
     9b8:	e0bfff17 	ldw	r2,-4(fp)
     9bc:	1087883a 	add	r3,r2,r2
     9c0:	d0a8b884 	addi	r2,gp,-23838
     9c4:	1885883a 	add	r2,r3,r2
     9c8:	10c0000b 	ldhu	r3,0(r2)
     9cc:	e0bfff17 	ldw	r2,-4(fp)
     9d0:	1089883a 	add	r4,r2,r2
     9d4:	d0a8bb84 	addi	r2,gp,-23826
     9d8:	2085883a 	add	r2,r4,r2
     9dc:	10c0000d 	sth	r3,0(r2)
	changed or not.
	
	Loop through each check variable to and return pdFALSE if any are found not
	to have changed since the last call. */

	for( xTasks = 0; xTasks < blckqNUM_TASK_SETS; xTasks++ )
     9e0:	e0bfff17 	ldw	r2,-4(fp)
     9e4:	10800044 	addi	r2,r2,1
     9e8:	e0bfff15 	stw	r2,-4(fp)
     9ec:	e0bfff17 	ldw	r2,-4(fp)
     9f0:	108000d0 	cmplti	r2,r2,3
     9f4:	103fc21e 	bne	r2,zero,900 <xAreBlockingQueuesStillRunning+0x1c>
			xReturn = pdFALSE;
		}
		sLastBlockingProducerCount[ xTasks ] = sBlockingProducerCount[ xTasks ];
	}

	return xReturn;
     9f8:	e0bffe17 	ldw	r2,-8(fp)
}
     9fc:	e037883a 	mov	sp,fp
     a00:	df000017 	ldw	fp,0(sp)
     a04:	dec00104 	addi	sp,sp,4
     a08:	f800283a 	ret

00000a0c <vStartGenericQueueTasks>:
static xTaskHandle xHighPriorityMutexTask, xMediumPriorityMutexTask;

/*-----------------------------------------------------------*/

void vStartGenericQueueTasks( unsigned portBASE_TYPE uxPriority )
{
     a0c:	defff704 	addi	sp,sp,-36
     a10:	dfc00815 	stw	ra,32(sp)
     a14:	df000715 	stw	fp,28(sp)
     a18:	df000704 	addi	fp,sp,28
     a1c:	e13fff15 	stw	r4,-4(fp)
xQueueHandle xQueue;
xSemaphoreHandle xMutex;

	/* Create the queue that we are going to use for the
	prvSendFrontAndBackTest demo. */
	xQueue = xQueueCreate( genqQUEUE_LENGTH, sizeof( unsigned portLONG ) );
     a20:	01000144 	movi	r4,5
     a24:	01400104 	movi	r5,4
     a28:	000d883a 	mov	r6,zero
     a2c:	000e6380 	call	e638 <xQueueGenericCreate>
     a30:	e0bffd15 	stw	r2,-12(fp)
	vQueueAddToRegistry( xQueue, ( signed portCHAR * ) "Gen_Queue_Test" );

	/* Create the demo task and pass it the queue just created.  We are
	passing the queue handle by value so it does not matter that it is
	declared on the stack here. */
	xTaskCreate( prvSendFrontAndBackTest, ( signed portCHAR * )"GenQ", configMINIMAL_STACK_SIZE, ( void * ) xQueue, uxPriority, NULL );
     a34:	e0bfff17 	ldw	r2,-4(fp)
     a38:	d8800015 	stw	r2,0(sp)
     a3c:	d8000115 	stw	zero,4(sp)
     a40:	d8000215 	stw	zero,8(sp)
     a44:	d8000315 	stw	zero,12(sp)
     a48:	01000034 	movhi	r4,0
     a4c:	2102c604 	addi	r4,r4,2840
     a50:	01400134 	movhi	r5,4
     a54:	297e4d04 	addi	r5,r5,-1740
     a58:	018c9604 	movi	r6,12888
     a5c:	e1fffd17 	ldw	r7,-12(fp)
     a60:	000f5140 	call	f514 <xTaskGenericCreate>

	/* Create the mutex used by the prvMutexTest task. */
	xMutex = xSemaphoreCreateMutex();
     a64:	01000044 	movi	r4,1
     a68:	000e7040 	call	e704 <xQueueCreateMutex>
     a6c:	e0bffe15 	stw	r2,-8(fp)
	vQueueAddToRegistry( ( xQueueHandle ) xMutex, ( signed portCHAR * ) "Gen_Queue_Mutex" );

	/* Create the mutex demo tasks and pass it the mutex just created.  We are
	passing the mutex handle by value so it does not matter that it is declared
	on the stack here. */
	xTaskCreate( prvLowPriorityMutexTask, ( signed portCHAR * )"MuLow", configMINIMAL_STACK_SIZE, ( void * ) xMutex, genqMUTEX_LOW_PRIORITY, NULL );
     a70:	d8000015 	stw	zero,0(sp)
     a74:	d8000115 	stw	zero,4(sp)
     a78:	d8000215 	stw	zero,8(sp)
     a7c:	d8000315 	stw	zero,12(sp)
     a80:	01000034 	movhi	r4,0
     a84:	2103df04 	addi	r4,r4,3964
     a88:	01400134 	movhi	r5,4
     a8c:	297e4f04 	addi	r5,r5,-1732
     a90:	018c9604 	movi	r6,12888
     a94:	e1fffe17 	ldw	r7,-8(fp)
     a98:	000f5140 	call	f514 <xTaskGenericCreate>
	xTaskCreate( prvMediumPriorityMutexTask, ( signed portCHAR * )"MuMed", configMINIMAL_STACK_SIZE, NULL, genqMUTEX_MEDIUM_PRIORITY, &xMediumPriorityMutexTask );
     a9c:	00800084 	movi	r2,2
     aa0:	d8800015 	stw	r2,0(sp)
     aa4:	d0a8c204 	addi	r2,gp,-23800
     aa8:	d8800115 	stw	r2,4(sp)
     aac:	d8000215 	stw	zero,8(sp)
     ab0:	d8000315 	stw	zero,12(sp)
     ab4:	01000034 	movhi	r4,0
     ab8:	21042904 	addi	r4,r4,4260
     abc:	01400134 	movhi	r5,4
     ac0:	297e5104 	addi	r5,r5,-1724
     ac4:	018c9604 	movi	r6,12888
     ac8:	000f883a 	mov	r7,zero
     acc:	000f5140 	call	f514 <xTaskGenericCreate>
	xTaskCreate( prvHighPriorityMutexTask, ( signed portCHAR * )"MuHigh", configMINIMAL_STACK_SIZE, ( void * ) xMutex, genqMUTEX_HIGH_PRIORITY, &xHighPriorityMutexTask );
     ad0:	008000c4 	movi	r2,3
     ad4:	d8800015 	stw	r2,0(sp)
     ad8:	d0a8c104 	addi	r2,gp,-23804
     adc:	d8800115 	stw	r2,4(sp)
     ae0:	d8000215 	stw	zero,8(sp)
     ae4:	d8000315 	stw	zero,12(sp)
     ae8:	01000034 	movhi	r4,0
     aec:	21043404 	addi	r4,r4,4304
     af0:	01400134 	movhi	r5,4
     af4:	297e5304 	addi	r5,r5,-1716
     af8:	018c9604 	movi	r6,12888
     afc:	e1fffe17 	ldw	r7,-8(fp)
     b00:	000f5140 	call	f514 <xTaskGenericCreate>
}
     b04:	e037883a 	mov	sp,fp
     b08:	dfc00117 	ldw	ra,4(sp)
     b0c:	df000017 	ldw	fp,0(sp)
     b10:	dec00204 	addi	sp,sp,8
     b14:	f800283a 	ret

00000b18 <prvSendFrontAndBackTest>:
/*-----------------------------------------------------------*/

static void prvSendFrontAndBackTest( void *pvParameters )
{
     b18:	defffa04 	addi	sp,sp,-24
     b1c:	dfc00515 	stw	ra,20(sp)
     b20:	df000415 	stw	fp,16(sp)
     b24:	df000404 	addi	fp,sp,16
     b28:	e13fff15 	stw	r4,-4(fp)

		/* Queue a message for printing to say the task has started. */
		vPrintDisplayMessage( &pcTaskStartMsg );
	#endif

	xQueue = ( xQueueHandle ) pvParameters;
     b2c:	e0bfff17 	ldw	r2,-4(fp)
     b30:	e0bffc15 	stw	r2,-16(fp)
	{
		/* The queue is empty, so sending an item to the back of the queue
		should have the same efect as sending it to the front of the queue.

		First send to the front and check everything is as expected. */
		xQueueSendToFront( xQueue, ( void * ) &ulLoopCounter, genqNO_BLOCK );
     b34:	e13ffc17 	ldw	r4,-16(fp)
     b38:	d168be04 	addi	r5,gp,-23816
     b3c:	000d883a 	mov	r6,zero
     b40:	01c00044 	movi	r7,1
     b44:	000e95c0 	call	e95c <xQueueGenericSend>

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
     b48:	e13ffc17 	ldw	r4,-16(fp)
     b4c:	000eef40 	call	eef4 <uxQueueMessagesWaiting>
     b50:	10800060 	cmpeqi	r2,r2,1
     b54:	1000021e 	bne	r2,zero,b60 <prvSendFrontAndBackTest+0x48>
		{
			xErrorDetected = pdTRUE;
     b58:	00800044 	movi	r2,1
     b5c:	d0a8bd15 	stw	r2,-23820(gp)
		}

		if( xQueueReceive( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != pdPASS )
     b60:	e0bffd04 	addi	r2,fp,-12
     b64:	e13ffc17 	ldw	r4,-16(fp)
     b68:	100b883a 	mov	r5,r2
     b6c:	000d883a 	mov	r6,zero
     b70:	000f883a 	mov	r7,zero
     b74:	000ebd80 	call	ebd8 <xQueueGenericReceive>
     b78:	10800060 	cmpeqi	r2,r2,1
     b7c:	1000021e 	bne	r2,zero,b88 <prvSendFrontAndBackTest+0x70>
		{
			xErrorDetected = pdTRUE;
     b80:	00800044 	movi	r2,1
     b84:	d0a8bd15 	stw	r2,-23820(gp)
		}

		/* The data we sent to the queue should equal the data we just received
		from the queue. */
		if( ulLoopCounter != ulData )
     b88:	d0e8be17 	ldw	r3,-23816(gp)
     b8c:	e0bffd17 	ldw	r2,-12(fp)
     b90:	18800226 	beq	r3,r2,b9c <prvSendFrontAndBackTest+0x84>
		{
			xErrorDetected = pdTRUE;
     b94:	00800044 	movi	r2,1
     b98:	d0a8bd15 	stw	r2,-23820(gp)
		}

		/* Then do the same, sending the data to the back, checking everything
		is as expected. */
		if( uxQueueMessagesWaiting( xQueue ) != 0 )
     b9c:	e13ffc17 	ldw	r4,-16(fp)
     ba0:	000eef40 	call	eef4 <uxQueueMessagesWaiting>
     ba4:	10000226 	beq	r2,zero,bb0 <prvSendFrontAndBackTest+0x98>
		{
			xErrorDetected = pdTRUE;
     ba8:	00800044 	movi	r2,1
     bac:	d0a8bd15 	stw	r2,-23820(gp)
		}

		xQueueSendToBack( xQueue, ( void * ) &ulLoopCounter, genqNO_BLOCK );
     bb0:	e13ffc17 	ldw	r4,-16(fp)
     bb4:	d168be04 	addi	r5,gp,-23816
     bb8:	000d883a 	mov	r6,zero
     bbc:	000f883a 	mov	r7,zero
     bc0:	000e95c0 	call	e95c <xQueueGenericSend>

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
     bc4:	e13ffc17 	ldw	r4,-16(fp)
     bc8:	000eef40 	call	eef4 <uxQueueMessagesWaiting>
     bcc:	10800060 	cmpeqi	r2,r2,1
     bd0:	1000021e 	bne	r2,zero,bdc <prvSendFrontAndBackTest+0xc4>
		{
			xErrorDetected = pdTRUE;
     bd4:	00800044 	movi	r2,1
     bd8:	d0a8bd15 	stw	r2,-23820(gp)
		}

		if( xQueueReceive( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != pdPASS )
     bdc:	e0bffd04 	addi	r2,fp,-12
     be0:	e13ffc17 	ldw	r4,-16(fp)
     be4:	100b883a 	mov	r5,r2
     be8:	000d883a 	mov	r6,zero
     bec:	000f883a 	mov	r7,zero
     bf0:	000ebd80 	call	ebd8 <xQueueGenericReceive>
     bf4:	10800060 	cmpeqi	r2,r2,1
     bf8:	1000021e 	bne	r2,zero,c04 <prvSendFrontAndBackTest+0xec>
		{
			xErrorDetected = pdTRUE;
     bfc:	00800044 	movi	r2,1
     c00:	d0a8bd15 	stw	r2,-23820(gp)
		}

		if( uxQueueMessagesWaiting( xQueue ) != 0 )
     c04:	e13ffc17 	ldw	r4,-16(fp)
     c08:	000eef40 	call	eef4 <uxQueueMessagesWaiting>
     c0c:	10000226 	beq	r2,zero,c18 <prvSendFrontAndBackTest+0x100>
		{
			xErrorDetected = pdTRUE;
     c10:	00800044 	movi	r2,1
     c14:	d0a8bd15 	stw	r2,-23820(gp)
		}

		/* The data we sent to the queue should equal the data we just received
		from the queue. */
		if( ulLoopCounter != ulData )
     c18:	d0e8be17 	ldw	r3,-23816(gp)
     c1c:	e0bffd17 	ldw	r2,-12(fp)
     c20:	18800226 	beq	r3,r2,c2c <prvSendFrontAndBackTest+0x114>
		{
			xErrorDetected = pdTRUE;
     c24:	00800044 	movi	r2,1
     c28:	d0a8bd15 	stw	r2,-23820(gp)
		#endif



		/* Place 2, 3, 4 into the queue, adding items to the back of the queue. */
		for( ulData = 2; ulData < 5; ulData++ )
     c2c:	00800084 	movi	r2,2
     c30:	e0bffd15 	stw	r2,-12(fp)
     c34:	00000906 	br	c5c <prvSendFrontAndBackTest+0x144>
		{
			xQueueSendToBack( xQueue, ( void * ) &ulData, genqNO_BLOCK );
     c38:	e0bffd04 	addi	r2,fp,-12
     c3c:	e13ffc17 	ldw	r4,-16(fp)
     c40:	100b883a 	mov	r5,r2
     c44:	000d883a 	mov	r6,zero
     c48:	000f883a 	mov	r7,zero
     c4c:	000e95c0 	call	e95c <xQueueGenericSend>
		#endif



		/* Place 2, 3, 4 into the queue, adding items to the back of the queue. */
		for( ulData = 2; ulData < 5; ulData++ )
     c50:	e0bffd17 	ldw	r2,-12(fp)
     c54:	10800044 	addi	r2,r2,1
     c58:	e0bffd15 	stw	r2,-12(fp)
     c5c:	e0bffd17 	ldw	r2,-12(fp)
     c60:	10800170 	cmpltui	r2,r2,5
     c64:	103ff41e 	bne	r2,zero,c38 <prvSendFrontAndBackTest+0x120>
			xQueueSendToBack( xQueue, ( void * ) &ulData, genqNO_BLOCK );
		}

		/* Now the order in the queue should be 2, 3, 4, with 2 being the first
		thing to be read out.  Now add 1 then 0 to the front of the queue. */
		if( uxQueueMessagesWaiting( xQueue ) != 3 )
     c68:	e13ffc17 	ldw	r4,-16(fp)
     c6c:	000eef40 	call	eef4 <uxQueueMessagesWaiting>
     c70:	108000e0 	cmpeqi	r2,r2,3
     c74:	1000021e 	bne	r2,zero,c80 <prvSendFrontAndBackTest+0x168>
		{
			xErrorDetected = pdTRUE;
     c78:	00800044 	movi	r2,1
     c7c:	d0a8bd15 	stw	r2,-23820(gp)
		}
		ulData = 1;
     c80:	00800044 	movi	r2,1
     c84:	e0bffd15 	stw	r2,-12(fp)
		xQueueSendToFront( xQueue, ( void * ) &ulData, genqNO_BLOCK );
     c88:	e0bffd04 	addi	r2,fp,-12
     c8c:	e13ffc17 	ldw	r4,-16(fp)
     c90:	100b883a 	mov	r5,r2
     c94:	000d883a 	mov	r6,zero
     c98:	01c00044 	movi	r7,1
     c9c:	000e95c0 	call	e95c <xQueueGenericSend>
		ulData = 0;
     ca0:	e03ffd15 	stw	zero,-12(fp)
		xQueueSendToFront( xQueue, ( void * ) &ulData, genqNO_BLOCK );
     ca4:	e0bffd04 	addi	r2,fp,-12
     ca8:	e13ffc17 	ldw	r4,-16(fp)
     cac:	100b883a 	mov	r5,r2
     cb0:	000d883a 	mov	r6,zero
     cb4:	01c00044 	movi	r7,1
     cb8:	000e95c0 	call	e95c <xQueueGenericSend>

		/* Now the queue should be full, and when we read the data out we
		should receive 0, 1, 2, 3, 4. */
		if( uxQueueMessagesWaiting( xQueue ) != 5 )
     cbc:	e13ffc17 	ldw	r4,-16(fp)
     cc0:	000eef40 	call	eef4 <uxQueueMessagesWaiting>
     cc4:	10800160 	cmpeqi	r2,r2,5
     cc8:	1000021e 	bne	r2,zero,cd4 <prvSendFrontAndBackTest+0x1bc>
		{
			xErrorDetected = pdTRUE;
     ccc:	00800044 	movi	r2,1
     cd0:	d0a8bd15 	stw	r2,-23820(gp)
		}

		if( xQueueSendToFront( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != errQUEUE_FULL )
     cd4:	e0bffd04 	addi	r2,fp,-12
     cd8:	e13ffc17 	ldw	r4,-16(fp)
     cdc:	100b883a 	mov	r5,r2
     ce0:	000d883a 	mov	r6,zero
     ce4:	01c00044 	movi	r7,1
     ce8:	000e95c0 	call	e95c <xQueueGenericSend>
     cec:	10000226 	beq	r2,zero,cf8 <prvSendFrontAndBackTest+0x1e0>
		{
			xErrorDetected = pdTRUE;
     cf0:	00800044 	movi	r2,1
     cf4:	d0a8bd15 	stw	r2,-23820(gp)
		}

		if( xQueueSendToBack( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != errQUEUE_FULL )
     cf8:	e0bffd04 	addi	r2,fp,-12
     cfc:	e13ffc17 	ldw	r4,-16(fp)
     d00:	100b883a 	mov	r5,r2
     d04:	000d883a 	mov	r6,zero
     d08:	000f883a 	mov	r7,zero
     d0c:	000e95c0 	call	e95c <xQueueGenericSend>
     d10:	10000226 	beq	r2,zero,d1c <prvSendFrontAndBackTest+0x204>
		{
			xErrorDetected = pdTRUE;
     d14:	00800044 	movi	r2,1
     d18:	d0a8bd15 	stw	r2,-23820(gp)
		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif

		/* Check the data we read out is in the expected order. */
		for( ulData = 0; ulData < genqQUEUE_LENGTH; ulData++ )
     d1c:	e03ffd15 	stw	zero,-12(fp)
     d20:	00002406 	br	db4 <prvSendFrontAndBackTest+0x29c>
		{
			/* Try peeking the data first. */
			if( xQueuePeek( xQueue, &ulData2, genqNO_BLOCK ) != pdPASS )
     d24:	e0bffe04 	addi	r2,fp,-8
     d28:	e13ffc17 	ldw	r4,-16(fp)
     d2c:	100b883a 	mov	r5,r2
     d30:	000d883a 	mov	r6,zero
     d34:	01c00044 	movi	r7,1
     d38:	000ebd80 	call	ebd8 <xQueueGenericReceive>
     d3c:	10800060 	cmpeqi	r2,r2,1
     d40:	1000021e 	bne	r2,zero,d4c <prvSendFrontAndBackTest+0x234>
			{
				xErrorDetected = pdTRUE;
     d44:	00800044 	movi	r2,1
     d48:	d0a8bd15 	stw	r2,-23820(gp)
			}

			if( ulData != ulData2 )
     d4c:	e0fffd17 	ldw	r3,-12(fp)
     d50:	e0bffe17 	ldw	r2,-8(fp)
     d54:	18800226 	beq	r3,r2,d60 <prvSendFrontAndBackTest+0x248>
			{
				xErrorDetected = pdTRUE;
     d58:	00800044 	movi	r2,1
     d5c:	d0a8bd15 	stw	r2,-23820(gp)
			}
			

			/* Now try receiving the data for real.  The value should be the
			same.  Clobber the value first so we know we really received it. */
			ulData2 = ~ulData2;
     d60:	e0bffe17 	ldw	r2,-8(fp)
     d64:	0084303a 	nor	r2,zero,r2
     d68:	e0bffe15 	stw	r2,-8(fp)
			if( xQueueReceive( xQueue, &ulData2, genqNO_BLOCK ) != pdPASS )
     d6c:	e0bffe04 	addi	r2,fp,-8
     d70:	e13ffc17 	ldw	r4,-16(fp)
     d74:	100b883a 	mov	r5,r2
     d78:	000d883a 	mov	r6,zero
     d7c:	000f883a 	mov	r7,zero
     d80:	000ebd80 	call	ebd8 <xQueueGenericReceive>
     d84:	10800060 	cmpeqi	r2,r2,1
     d88:	1000021e 	bne	r2,zero,d94 <prvSendFrontAndBackTest+0x27c>
			{
				xErrorDetected = pdTRUE;
     d8c:	00800044 	movi	r2,1
     d90:	d0a8bd15 	stw	r2,-23820(gp)
			}

			if( ulData != ulData2 )
     d94:	e0fffd17 	ldw	r3,-12(fp)
     d98:	e0bffe17 	ldw	r2,-8(fp)
     d9c:	18800226 	beq	r3,r2,da8 <prvSendFrontAndBackTest+0x290>
			{
				xErrorDetected = pdTRUE;
     da0:	00800044 	movi	r2,1
     da4:	d0a8bd15 	stw	r2,-23820(gp)
		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif

		/* Check the data we read out is in the expected order. */
		for( ulData = 0; ulData < genqQUEUE_LENGTH; ulData++ )
     da8:	e0bffd17 	ldw	r2,-12(fp)
     dac:	10800044 	addi	r2,r2,1
     db0:	e0bffd15 	stw	r2,-12(fp)
     db4:	e0bffd17 	ldw	r2,-12(fp)
     db8:	10800170 	cmpltui	r2,r2,5
     dbc:	103fd91e 	bne	r2,zero,d24 <prvSendFrontAndBackTest+0x20c>
				xErrorDetected = pdTRUE;
			}
		}

		/* The queue should now be empty again. */
		if( uxQueueMessagesWaiting( xQueue ) != 0 )
     dc0:	e13ffc17 	ldw	r4,-16(fp)
     dc4:	000eef40 	call	eef4 <uxQueueMessagesWaiting>
     dc8:	10000226 	beq	r2,zero,dd4 <prvSendFrontAndBackTest+0x2bc>
		{
			xErrorDetected = pdTRUE;
     dcc:	00800044 	movi	r2,1
     dd0:	d0a8bd15 	stw	r2,-23820(gp)
			taskYIELD();
		#endif


		/* Our queue is empty once more, add 10, 11 to the back. */
		ulData = 10;
     dd4:	00800284 	movi	r2,10
     dd8:	e0bffd15 	stw	r2,-12(fp)
		if( xQueueSend( xQueue, &ulData, genqNO_BLOCK ) != pdPASS )
     ddc:	e0bffd04 	addi	r2,fp,-12
     de0:	e13ffc17 	ldw	r4,-16(fp)
     de4:	100b883a 	mov	r5,r2
     de8:	000d883a 	mov	r6,zero
     dec:	000f883a 	mov	r7,zero
     df0:	000e95c0 	call	e95c <xQueueGenericSend>
     df4:	10800060 	cmpeqi	r2,r2,1
     df8:	1000021e 	bne	r2,zero,e04 <prvSendFrontAndBackTest+0x2ec>
		{
			xErrorDetected = pdTRUE;
     dfc:	00800044 	movi	r2,1
     e00:	d0a8bd15 	stw	r2,-23820(gp)
		}
		ulData = 11;
     e04:	008002c4 	movi	r2,11
     e08:	e0bffd15 	stw	r2,-12(fp)
		if( xQueueSend( xQueue, &ulData, genqNO_BLOCK ) != pdPASS )
     e0c:	e0bffd04 	addi	r2,fp,-12
     e10:	e13ffc17 	ldw	r4,-16(fp)
     e14:	100b883a 	mov	r5,r2
     e18:	000d883a 	mov	r6,zero
     e1c:	000f883a 	mov	r7,zero
     e20:	000e95c0 	call	e95c <xQueueGenericSend>
     e24:	10800060 	cmpeqi	r2,r2,1
     e28:	1000021e 	bne	r2,zero,e34 <prvSendFrontAndBackTest+0x31c>
		{
			xErrorDetected = pdTRUE;
     e2c:	00800044 	movi	r2,1
     e30:	d0a8bd15 	stw	r2,-23820(gp)
		}

		if( uxQueueMessagesWaiting( xQueue ) != 2 )
     e34:	e13ffc17 	ldw	r4,-16(fp)
     e38:	000eef40 	call	eef4 <uxQueueMessagesWaiting>
     e3c:	108000a0 	cmpeqi	r2,r2,2
     e40:	1000021e 	bne	r2,zero,e4c <prvSendFrontAndBackTest+0x334>
		{
			xErrorDetected = pdTRUE;
     e44:	00800044 	movi	r2,1
     e48:	d0a8bd15 	stw	r2,-23820(gp)
		}

		/* Now we should have 10, 11 in the queue.  Add 7, 8, 9 to the
		front. */
		for( ulData = 9; ulData >= 7; ulData-- )
     e4c:	00800244 	movi	r2,9
     e50:	e0bffd15 	stw	r2,-12(fp)
     e54:	00000d06 	br	e8c <prvSendFrontAndBackTest+0x374>
		{
			if( xQueueSendToFront( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != pdPASS )
     e58:	e0bffd04 	addi	r2,fp,-12
     e5c:	e13ffc17 	ldw	r4,-16(fp)
     e60:	100b883a 	mov	r5,r2
     e64:	000d883a 	mov	r6,zero
     e68:	01c00044 	movi	r7,1
     e6c:	000e95c0 	call	e95c <xQueueGenericSend>
     e70:	10800060 	cmpeqi	r2,r2,1
     e74:	1000021e 	bne	r2,zero,e80 <prvSendFrontAndBackTest+0x368>
			{
				xErrorDetected = pdTRUE;
     e78:	00800044 	movi	r2,1
     e7c:	d0a8bd15 	stw	r2,-23820(gp)
			xErrorDetected = pdTRUE;
		}

		/* Now we should have 10, 11 in the queue.  Add 7, 8, 9 to the
		front. */
		for( ulData = 9; ulData >= 7; ulData-- )
     e80:	e0bffd17 	ldw	r2,-12(fp)
     e84:	10bfffc4 	addi	r2,r2,-1
     e88:	e0bffd15 	stw	r2,-12(fp)
     e8c:	e0bffd17 	ldw	r2,-12(fp)
     e90:	108001e8 	cmpgeui	r2,r2,7
     e94:	103ff01e 	bne	r2,zero,e58 <prvSendFrontAndBackTest+0x340>
			}
		}

		/* Now check that the queue is full, and that receiving data provides
		the expected sequence of 7, 8, 9, 10, 11. */
		if( uxQueueMessagesWaiting( xQueue ) != 5 )
     e98:	e13ffc17 	ldw	r4,-16(fp)
     e9c:	000eef40 	call	eef4 <uxQueueMessagesWaiting>
     ea0:	10800160 	cmpeqi	r2,r2,5
     ea4:	1000021e 	bne	r2,zero,eb0 <prvSendFrontAndBackTest+0x398>
		{
			xErrorDetected = pdTRUE;
     ea8:	00800044 	movi	r2,1
     eac:	d0a8bd15 	stw	r2,-23820(gp)
		}

		if( xQueueSendToFront( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != errQUEUE_FULL )
     eb0:	e0bffd04 	addi	r2,fp,-12
     eb4:	e13ffc17 	ldw	r4,-16(fp)
     eb8:	100b883a 	mov	r5,r2
     ebc:	000d883a 	mov	r6,zero
     ec0:	01c00044 	movi	r7,1
     ec4:	000e95c0 	call	e95c <xQueueGenericSend>
     ec8:	10000226 	beq	r2,zero,ed4 <prvSendFrontAndBackTest+0x3bc>
		{
			xErrorDetected = pdTRUE;
     ecc:	00800044 	movi	r2,1
     ed0:	d0a8bd15 	stw	r2,-23820(gp)
		}

		if( xQueueSendToBack( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != errQUEUE_FULL )
     ed4:	e0bffd04 	addi	r2,fp,-12
     ed8:	e13ffc17 	ldw	r4,-16(fp)
     edc:	100b883a 	mov	r5,r2
     ee0:	000d883a 	mov	r6,zero
     ee4:	000f883a 	mov	r7,zero
     ee8:	000e95c0 	call	e95c <xQueueGenericSend>
     eec:	10000226 	beq	r2,zero,ef8 <prvSendFrontAndBackTest+0x3e0>
		{
			xErrorDetected = pdTRUE;
     ef0:	00800044 	movi	r2,1
     ef4:	d0a8bd15 	stw	r2,-23820(gp)
		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif

		/* Check the data we read out is in the expected order. */
		for( ulData = 7; ulData < ( 7 + genqQUEUE_LENGTH ); ulData++ )
     ef8:	008001c4 	movi	r2,7
     efc:	e0bffd15 	stw	r2,-12(fp)
     f00:	00001206 	br	f4c <prvSendFrontAndBackTest+0x434>
		{
			if( xQueueReceive( xQueue, &ulData2, genqNO_BLOCK ) != pdPASS )
     f04:	e0bffe04 	addi	r2,fp,-8
     f08:	e13ffc17 	ldw	r4,-16(fp)
     f0c:	100b883a 	mov	r5,r2
     f10:	000d883a 	mov	r6,zero
     f14:	000f883a 	mov	r7,zero
     f18:	000ebd80 	call	ebd8 <xQueueGenericReceive>
     f1c:	10800060 	cmpeqi	r2,r2,1
     f20:	1000021e 	bne	r2,zero,f2c <prvSendFrontAndBackTest+0x414>
			{
				xErrorDetected = pdTRUE;
     f24:	00800044 	movi	r2,1
     f28:	d0a8bd15 	stw	r2,-23820(gp)
			}

			if( ulData != ulData2 )
     f2c:	e0fffd17 	ldw	r3,-12(fp)
     f30:	e0bffe17 	ldw	r2,-8(fp)
     f34:	18800226 	beq	r3,r2,f40 <prvSendFrontAndBackTest+0x428>
			{
				xErrorDetected = pdTRUE;
     f38:	00800044 	movi	r2,1
     f3c:	d0a8bd15 	stw	r2,-23820(gp)
		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif

		/* Check the data we read out is in the expected order. */
		for( ulData = 7; ulData < ( 7 + genqQUEUE_LENGTH ); ulData++ )
     f40:	e0bffd17 	ldw	r2,-12(fp)
     f44:	10800044 	addi	r2,r2,1
     f48:	e0bffd15 	stw	r2,-12(fp)
     f4c:	e0bffd17 	ldw	r2,-12(fp)
     f50:	10800330 	cmpltui	r2,r2,12
     f54:	103feb1e 	bne	r2,zero,f04 <prvSendFrontAndBackTest+0x3ec>
			{
				xErrorDetected = pdTRUE;
			}
		}

		if( uxQueueMessagesWaiting( xQueue ) != 0 )
     f58:	e13ffc17 	ldw	r4,-16(fp)
     f5c:	000eef40 	call	eef4 <uxQueueMessagesWaiting>
     f60:	10000226 	beq	r2,zero,f6c <prvSendFrontAndBackTest+0x454>
		{
			xErrorDetected = pdTRUE;
     f64:	00800044 	movi	r2,1
     f68:	d0a8bd15 	stw	r2,-23820(gp)
		}

		ulLoopCounter++;
     f6c:	d0a8be17 	ldw	r2,-23816(gp)
     f70:	10800044 	addi	r2,r2,1
     f74:	d0a8be15 	stw	r2,-23816(gp)
	}
     f78:	003eee06 	br	b34 <prvSendFrontAndBackTest+0x1c>

00000f7c <prvLowPriorityMutexTask>:
}
/*-----------------------------------------------------------*/

static void prvLowPriorityMutexTask( void *pvParameters )
{
     f7c:	defffc04 	addi	sp,sp,-16
     f80:	dfc00315 	stw	ra,12(sp)
     f84:	df000215 	stw	fp,8(sp)
     f88:	df000204 	addi	fp,sp,8
     f8c:	e13fff15 	stw	r4,-4(fp)
xSemaphoreHandle xMutex = ( xSemaphoreHandle ) pvParameters;
     f90:	e0bfff17 	ldw	r2,-4(fp)
     f94:	e0bffe15 	stw	r2,-8(fp)
	#endif

	for( ;; )
	{
		/* Take the mutex.  It should be available now. */
		if( xSemaphoreTake( xMutex, genqNO_BLOCK ) != pdPASS )
     f98:	e13ffe17 	ldw	r4,-8(fp)
     f9c:	000b883a 	mov	r5,zero
     fa0:	000d883a 	mov	r6,zero
     fa4:	000f883a 	mov	r7,zero
     fa8:	000ebd80 	call	ebd8 <xQueueGenericReceive>
     fac:	10800060 	cmpeqi	r2,r2,1
     fb0:	1000021e 	bne	r2,zero,fbc <prvLowPriorityMutexTask+0x40>
		{
			xErrorDetected = pdTRUE;
     fb4:	00800044 	movi	r2,1
     fb8:	d0a8bd15 	stw	r2,-23820(gp)
		}

		/* Set our guarded variable to a known start value. */
		ulGuardedVariable = 0;
     fbc:	d028c015 	stw	zero,-23808(gp)

		/* Our priority should be as per that assigned when the task was
		created. */
		if( uxTaskPriorityGet( NULL ) != genqMUTEX_LOW_PRIORITY )
     fc0:	0009883a 	mov	r4,zero
     fc4:	000f9340 	call	f934 <uxTaskPriorityGet>
     fc8:	10000226 	beq	r2,zero,fd4 <prvLowPriorityMutexTask+0x58>
		{
			xErrorDetected = pdTRUE;
     fcc:	00800044 	movi	r2,1
     fd0:	d0a8bd15 	stw	r2,-23820(gp)
		}

		/* Now unsuspend the high priority task.  This will attempt to take the
		mutex, and block when it finds it cannot obtain it. */
		vTaskResume( xHighPriorityMutexTask );
     fd4:	d0a8c117 	ldw	r2,-23804(gp)
     fd8:	1009883a 	mov	r4,r2
     fdc:	000fc800 	call	fc80 <vTaskResume>

		/* We should now have inherited the prioritoy of the high priority task,
		as by now it will have attempted to get the mutex. */
		if( uxTaskPriorityGet( NULL ) != genqMUTEX_HIGH_PRIORITY )
     fe0:	0009883a 	mov	r4,zero
     fe4:	000f9340 	call	f934 <uxTaskPriorityGet>
     fe8:	108000e0 	cmpeqi	r2,r2,3
     fec:	1000021e 	bne	r2,zero,ff8 <prvLowPriorityMutexTask+0x7c>
		{
			xErrorDetected = pdTRUE;
     ff0:	00800044 	movi	r2,1
     ff4:	d0a8bd15 	stw	r2,-23820(gp)
		}

		/* We can attempt to set our priority to the test priority - between the
		idle priority and the medium/high test priorities, but our actual
		prioroity should remain at the high priority. */
		vTaskPrioritySet( NULL, genqMUTEX_TEST_PRIORITY );
     ff8:	0009883a 	mov	r4,zero
     ffc:	01400044 	movi	r5,1
    1000:	000f99c0 	call	f99c <vTaskPrioritySet>
		if( uxTaskPriorityGet( NULL ) != genqMUTEX_HIGH_PRIORITY )
    1004:	0009883a 	mov	r4,zero
    1008:	000f9340 	call	f934 <uxTaskPriorityGet>
    100c:	108000e0 	cmpeqi	r2,r2,3
    1010:	1000021e 	bne	r2,zero,101c <prvLowPriorityMutexTask+0xa0>
		{
			xErrorDetected = pdTRUE;
    1014:	00800044 	movi	r2,1
    1018:	d0a8bd15 	stw	r2,-23820(gp)
		}

		/* Now unsuspend the medium priority task.  This should not run as our
		inherited priority is above that of the medium priority task. */
		vTaskResume( xMediumPriorityMutexTask );
    101c:	d0a8c217 	ldw	r2,-23800(gp)
    1020:	1009883a 	mov	r4,r2
    1024:	000fc800 	call	fc80 <vTaskResume>

		/* If the did run then it will have incremented our guarded variable. */
		if( ulGuardedVariable != 0 )
    1028:	d0a8c017 	ldw	r2,-23808(gp)
    102c:	10000226 	beq	r2,zero,1038 <prvLowPriorityMutexTask+0xbc>
		{
			xErrorDetected = pdTRUE;
    1030:	00800044 	movi	r2,1
    1034:	d0a8bd15 	stw	r2,-23820(gp)
		/* When we give back the semaphore our priority should be disinherited
		back to the priority to which we attempted to set ourselves.  This means
		that when the high priority task next blocks, the medium priority task
		should execute and increment the guarded variable.   When we next run
		both the high and medium priority tasks will have been suspended again. */
		if( xSemaphoreGive( xMutex ) != pdPASS )
    1038:	e13ffe17 	ldw	r4,-8(fp)
    103c:	000b883a 	mov	r5,zero
    1040:	000d883a 	mov	r6,zero
    1044:	000f883a 	mov	r7,zero
    1048:	000e95c0 	call	e95c <xQueueGenericSend>
    104c:	10800060 	cmpeqi	r2,r2,1
    1050:	1000021e 	bne	r2,zero,105c <prvLowPriorityMutexTask+0xe0>
		{
			xErrorDetected = pdTRUE;
    1054:	00800044 	movi	r2,1
    1058:	d0a8bd15 	stw	r2,-23820(gp)
		}

		/* Check that the guarded variable did indeed increment... */
		if( ulGuardedVariable != 1 )
    105c:	d0a8c017 	ldw	r2,-23808(gp)
    1060:	10800060 	cmpeqi	r2,r2,1
    1064:	1000021e 	bne	r2,zero,1070 <prvLowPriorityMutexTask+0xf4>
		{
			xErrorDetected = pdTRUE;
    1068:	00800044 	movi	r2,1
    106c:	d0a8bd15 	stw	r2,-23820(gp)
		}

		/* ... and that our priority has been disinherited to
		genqMUTEX_TEST_PRIORITY. */
		if( uxTaskPriorityGet( NULL ) != genqMUTEX_TEST_PRIORITY )
    1070:	0009883a 	mov	r4,zero
    1074:	000f9340 	call	f934 <uxTaskPriorityGet>
    1078:	10800060 	cmpeqi	r2,r2,1
    107c:	1000021e 	bne	r2,zero,1088 <prvLowPriorityMutexTask+0x10c>
		{
			xErrorDetected = pdTRUE;
    1080:	00800044 	movi	r2,1
    1084:	d0a8bd15 	stw	r2,-23820(gp)
		}

		/* Set our priority back to our original priority ready for the next
		loop around this test. */
		vTaskPrioritySet( NULL, genqMUTEX_LOW_PRIORITY );
    1088:	0009883a 	mov	r4,zero
    108c:	000b883a 	mov	r5,zero
    1090:	000f99c0 	call	f99c <vTaskPrioritySet>

		/* Just to show we are still running. */
		ulLoopCounter2++;
    1094:	d0a8bf17 	ldw	r2,-23812(gp)
    1098:	10800044 	addi	r2,r2,1
    109c:	d0a8bf15 	stw	r2,-23812(gp)

		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif		
	}
    10a0:	003fbd06 	br	f98 <prvLowPriorityMutexTask+0x1c>

000010a4 <prvMediumPriorityMutexTask>:
}
/*-----------------------------------------------------------*/

static void prvMediumPriorityMutexTask( void *pvParameters )
{
    10a4:	defffd04 	addi	sp,sp,-12
    10a8:	dfc00215 	stw	ra,8(sp)
    10ac:	df000115 	stw	fp,4(sp)
    10b0:	df000104 	addi	fp,sp,4
    10b4:	e13fff15 	stw	r4,-4(fp)

	for( ;; )
	{
		/* The medium priority task starts by suspending itself.  The low
		priority task will unsuspend this task when required. */
		vTaskSuspend( NULL );
    10b8:	0009883a 	mov	r4,zero
    10bc:	000fb300 	call	fb30 <vTaskSuspend>

		/* When this task unsuspends all it does is increment the guarded
		variable, this is so the low priority task knows that it has
		executed. */
		ulGuardedVariable++;
    10c0:	d0a8c017 	ldw	r2,-23808(gp)
    10c4:	10800044 	addi	r2,r2,1
    10c8:	d0a8c015 	stw	r2,-23808(gp)
	}
    10cc:	003ffa06 	br	10b8 <prvMediumPriorityMutexTask+0x14>

000010d0 <prvHighPriorityMutexTask>:
}
/*-----------------------------------------------------------*/

static void prvHighPriorityMutexTask( void *pvParameters )
{
    10d0:	defffc04 	addi	sp,sp,-16
    10d4:	dfc00315 	stw	ra,12(sp)
    10d8:	df000215 	stw	fp,8(sp)
    10dc:	df000204 	addi	fp,sp,8
    10e0:	e13fff15 	stw	r4,-4(fp)
xSemaphoreHandle xMutex = ( xSemaphoreHandle ) pvParameters;
    10e4:	e0bfff17 	ldw	r2,-4(fp)
    10e8:	e0bffe15 	stw	r2,-8(fp)
    10ec:	00000106 	br	10f4 <prvHighPriorityMutexTask+0x24>
		return to suspend ready for the next test. */
		if( xSemaphoreGive( xMutex ) != pdPASS )
		{
			xErrorDetected = pdTRUE;
		}		
	}
    10f0:	0001883a 	nop

	for( ;; )
	{
		/* The high priority task starts by suspending itself.  The low
		priority task will unsuspend this task when required. */
		vTaskSuspend( NULL );
    10f4:	0009883a 	mov	r4,zero
    10f8:	000fb300 	call	fb30 <vTaskSuspend>

		/* When this task unsuspends all it does is attempt to obtain
		the mutex.  It should find the mutex is not available so a
		block time is specified. */
		if( xSemaphoreTake( xMutex, portMAX_DELAY ) != pdPASS )
    10fc:	e13ffe17 	ldw	r4,-8(fp)
    1100:	000b883a 	mov	r5,zero
    1104:	01bfffc4 	movi	r6,-1
    1108:	000f883a 	mov	r7,zero
    110c:	000ebd80 	call	ebd8 <xQueueGenericReceive>
    1110:	10800060 	cmpeqi	r2,r2,1
    1114:	1000021e 	bne	r2,zero,1120 <prvHighPriorityMutexTask+0x50>
		{
			xErrorDetected = pdTRUE;
    1118:	00800044 	movi	r2,1
    111c:	d0a8bd15 	stw	r2,-23820(gp)
		}

		/* When we eventually obtain the mutex we just give it back then
		return to suspend ready for the next test. */
		if( xSemaphoreGive( xMutex ) != pdPASS )
    1120:	e13ffe17 	ldw	r4,-8(fp)
    1124:	000b883a 	mov	r5,zero
    1128:	000d883a 	mov	r6,zero
    112c:	000f883a 	mov	r7,zero
    1130:	000e95c0 	call	e95c <xQueueGenericSend>
    1134:	10800060 	cmpeqi	r2,r2,1
    1138:	103fed1e 	bne	r2,zero,10f0 <prvHighPriorityMutexTask+0x20>
		{
			xErrorDetected = pdTRUE;
    113c:	00800044 	movi	r2,1
    1140:	d0a8bd15 	stw	r2,-23820(gp)
		}		
	}
    1144:	003fea06 	br	10f0 <prvHighPriorityMutexTask+0x20>

00001148 <xAreGenericQueueTasksStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
portBASE_TYPE xAreGenericQueueTasksStillRunning( void )
{
    1148:	deffff04 	addi	sp,sp,-4
    114c:	df000015 	stw	fp,0(sp)
    1150:	d839883a 	mov	fp,sp
static unsigned portLONG ulLastLoopCounter = 0, ulLastLoopCounter2 = 0;

	/* If the demo task is still running then we expect the loopcounters to
	have incremented since this function was last called. */
	if( ulLastLoopCounter == ulLoopCounter )
    1154:	d0e8c317 	ldw	r3,-23796(gp)
    1158:	d0a8be17 	ldw	r2,-23816(gp)
    115c:	1880021e 	bne	r3,r2,1168 <xAreGenericQueueTasksStillRunning+0x20>
	{
		xErrorDetected = pdTRUE;
    1160:	00800044 	movi	r2,1
    1164:	d0a8bd15 	stw	r2,-23820(gp)
	}

	if( ulLastLoopCounter2 == ulLoopCounter2 )
    1168:	d0e8c417 	ldw	r3,-23792(gp)
    116c:	d0a8bf17 	ldw	r2,-23812(gp)
    1170:	1880021e 	bne	r3,r2,117c <xAreGenericQueueTasksStillRunning+0x34>
	{
		xErrorDetected = pdTRUE;
    1174:	00800044 	movi	r2,1
    1178:	d0a8bd15 	stw	r2,-23820(gp)
	}

	ulLastLoopCounter = ulLoopCounter;
    117c:	d0a8be17 	ldw	r2,-23816(gp)
    1180:	d0a8c315 	stw	r2,-23796(gp)
	ulLastLoopCounter2 = ulLoopCounter2;	
    1184:	d0a8bf17 	ldw	r2,-23812(gp)
    1188:	d0a8c415 	stw	r2,-23792(gp)

	/* Errors detected in the task itself will have latched xErrorDetected
	to true. */

	return !xErrorDetected;
    118c:	d0a8bd17 	ldw	r2,-23820(gp)
    1190:	1005003a 	cmpeq	r2,r2,zero
    1194:	10803fcc 	andi	r2,r2,255
}
    1198:	e037883a 	mov	sp,fp
    119c:	df000017 	ldw	fp,0(sp)
    11a0:	dec00104 	addi	sp,sp,4
    11a4:	f800283a 	ret

000011a8 <vStartPolledQueueTasks>:
static volatile signed portBASE_TYPE xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( unsigned portBASE_TYPE uxPriority )
{
    11a8:	defff904 	addi	sp,sp,-28
    11ac:	dfc00615 	stw	ra,24(sp)
    11b0:	df000515 	stw	fp,20(sp)
    11b4:	df000504 	addi	fp,sp,20
    11b8:	e13fff15 	stw	r4,-4(fp)
static xQueueHandle xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );
    11bc:	01000284 	movi	r4,10
    11c0:	01400084 	movi	r5,2
    11c4:	000d883a 	mov	r6,zero
    11c8:	000e6380 	call	e638 <xQueueGenericCreate>
    11cc:	d0a8c715 	stw	r2,-23780(gp)
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( xPolledQueue, ( signed char * ) "Poll_Test_Queue" );

	/* Spawn the producer and consumer. */
	xTaskCreate( vPolledQueueConsumer, ( signed char * ) "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( xTaskHandle * ) NULL );
    11d0:	e0bfff17 	ldw	r2,-4(fp)
    11d4:	d8800015 	stw	r2,0(sp)
    11d8:	d8000115 	stw	zero,4(sp)
    11dc:	d8000215 	stw	zero,8(sp)
    11e0:	d8000315 	stw	zero,12(sp)
    11e4:	01000034 	movhi	r4,0
    11e8:	2104be04 	addi	r4,r4,4856
    11ec:	01400134 	movhi	r5,4
    11f0:	297e5504 	addi	r5,r5,-1708
    11f4:	018c9604 	movi	r6,12888
    11f8:	d1e8c704 	addi	r7,gp,-23780
    11fc:	000f5140 	call	f514 <xTaskGenericCreate>
	xTaskCreate( vPolledQueueProducer, ( signed char * ) "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( xTaskHandle * ) NULL );
    1200:	e0bfff17 	ldw	r2,-4(fp)
    1204:	d8800015 	stw	r2,0(sp)
    1208:	d8000115 	stw	zero,4(sp)
    120c:	d8000215 	stw	zero,8(sp)
    1210:	d8000315 	stw	zero,12(sp)
    1214:	01000034 	movhi	r4,0
    1218:	21049104 	addi	r4,r4,4676
    121c:	01400134 	movhi	r5,4
    1220:	297e5704 	addi	r5,r5,-1700
    1224:	018c9604 	movi	r6,12888
    1228:	d1e8c704 	addi	r7,gp,-23780
    122c:	000f5140 	call	f514 <xTaskGenericCreate>
}
    1230:	e037883a 	mov	sp,fp
    1234:	dfc00117 	ldw	ra,4(sp)
    1238:	df000017 	ldw	fp,0(sp)
    123c:	dec00204 	addi	sp,sp,8
    1240:	f800283a 	ret

00001244 <vPolledQueueProducer>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
    1244:	defffa04 	addi	sp,sp,-24
    1248:	dfc00515 	stw	ra,20(sp)
    124c:	df000415 	stw	fp,16(sp)
    1250:	df000404 	addi	fp,sp,16
    1254:	e13fff15 	stw	r4,-4(fp)
unsigned short usValue = ( unsigned short ) 0;
    1258:	e03ffe0d 	sth	zero,-8(fp)
signed portBASE_TYPE xError = pdFALSE, xLoop;
    125c:	e03ffc15 	stw	zero,-16(fp)

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
    1260:	e03ffd15 	stw	zero,-12(fp)
    1264:	00001e06 	br	12e0 <vPolledQueueProducer+0x9c>
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( xQueueHandle * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
    1268:	e0bfff17 	ldw	r2,-4(fp)
    126c:	10c00017 	ldw	r3,0(r2)
    1270:	e0bffe04 	addi	r2,fp,-8
    1274:	1809883a 	mov	r4,r3
    1278:	100b883a 	mov	r5,r2
    127c:	000d883a 	mov	r6,zero
    1280:	000f883a 	mov	r7,zero
    1284:	000e95c0 	call	e95c <xQueueGenericSend>
    1288:	10800060 	cmpeqi	r2,r2,1
    128c:	1000031e 	bne	r2,zero,129c <vPolledQueueProducer+0x58>
			{
				/* We should never find the queue full so if we get here there
				has been an error. */
				xError = pdTRUE;
    1290:	00800044 	movi	r2,1
    1294:	e0bffc15 	stw	r2,-16(fp)
    1298:	00000e06 	br	12d4 <vPolledQueueProducer+0x90>
			}
			else
			{
				if( xError == pdFALSE )
    129c:	e0bffc17 	ldw	r2,-16(fp)
    12a0:	1000091e 	bne	r2,zero,12c8 <vPolledQueueProducer+0x84>
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
    12a4:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    12a8:	10000126 	beq	r2,zero,12b0 <vPolledQueueProducer+0x6c>
    12ac:	00110d00 	call	110d0 <vTaskEnterCritical>
						xPollingProducerCount++;
    12b0:	d0a8c617 	ldw	r2,-23784(gp)
    12b4:	10800044 	addi	r2,r2,1
    12b8:	d0a8c615 	stw	r2,-23784(gp)
					portEXIT_CRITICAL();
    12bc:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    12c0:	10000126 	beq	r2,zero,12c8 <vPolledQueueProducer+0x84>
    12c4:	00111100 	call	11110 <vTaskExitCritical>
				}

				/* Update the value we are going to post next time around. */
				usValue++;
    12c8:	e0bffe0b 	ldhu	r2,-8(fp)
    12cc:	10800044 	addi	r2,r2,1
    12d0:	e0bffe0d 	sth	r2,-8(fp)
unsigned short usValue = ( unsigned short ) 0;
signed portBASE_TYPE xError = pdFALSE, xLoop;

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
    12d4:	e0bffd17 	ldw	r2,-12(fp)
    12d8:	10800044 	addi	r2,r2,1
    12dc:	e0bffd15 	stw	r2,-12(fp)
    12e0:	e0bffd17 	ldw	r2,-12(fp)
    12e4:	108000d0 	cmplti	r2,r2,3
    12e8:	103fdf1e 	bne	r2,zero,1268 <vPolledQueueProducer+0x24>
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
    12ec:	01003204 	movi	r4,200
    12f0:	000f8c00 	call	f8c0 <vTaskDelay>
	}
    12f4:	003fda06 	br	1260 <vPolledQueueProducer+0x1c>

000012f8 <vPolledQueueConsumer>:
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
    12f8:	defffa04 	addi	sp,sp,-24
    12fc:	dfc00515 	stw	ra,20(sp)
    1300:	df000415 	stw	fp,16(sp)
    1304:	df000404 	addi	fp,sp,16
    1308:	e13fff15 	stw	r4,-4(fp)
unsigned short usData, usExpectedValue = ( unsigned short ) 0;
    130c:	e03ffc0d 	sth	zero,-16(fp)
signed portBASE_TYPE xError = pdFALSE;
    1310:	e03ffd15 	stw	zero,-12(fp)

	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( xQueueHandle * ) pvParameters ) ) )
    1314:	00002106 	br	139c <vPolledQueueConsumer+0xa4>
		{
			if( xQueueReceive( *( ( xQueueHandle * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
    1318:	e0bfff17 	ldw	r2,-4(fp)
    131c:	10c00017 	ldw	r3,0(r2)
    1320:	e0bffe04 	addi	r2,fp,-8
    1324:	1809883a 	mov	r4,r3
    1328:	100b883a 	mov	r5,r2
    132c:	000d883a 	mov	r6,zero
    1330:	000f883a 	mov	r7,zero
    1334:	000ebd80 	call	ebd8 <xQueueGenericReceive>
    1338:	10800058 	cmpnei	r2,r2,1
    133c:	1000171e 	bne	r2,zero,139c <vPolledQueueConsumer+0xa4>
			{
				if( usData != usExpectedValue )
    1340:	e0bffe0b 	ldhu	r2,-8(fp)
    1344:	10ffffcc 	andi	r3,r2,65535
    1348:	e0bffc0b 	ldhu	r2,-16(fp)
    134c:	18800526 	beq	r3,r2,1364 <vPolledQueueConsumer+0x6c>
				{
					/* This is not what we expected to receive so an error has
					occurred. */
					xError = pdTRUE;
    1350:	00800044 	movi	r2,1
    1354:	e0bffd15 	stw	r2,-12(fp)

					/* Catch-up to the value we received so our next expected
					value should again be correct. */
					usExpectedValue = usData;
    1358:	e0bffe0b 	ldhu	r2,-8(fp)
    135c:	e0bffc0d 	sth	r2,-16(fp)
    1360:	00000b06 	br	1390 <vPolledQueueConsumer+0x98>
				}
				else
				{
					if( xError == pdFALSE )
    1364:	e0bffd17 	ldw	r2,-12(fp)
    1368:	1000091e 	bne	r2,zero,1390 <vPolledQueueConsumer+0x98>
					{
						/* Only increment the check variable if no errors have
						occurred. */
						portENTER_CRITICAL();
    136c:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    1370:	10000126 	beq	r2,zero,1378 <vPolledQueueConsumer+0x80>
    1374:	00110d00 	call	110d0 <vTaskEnterCritical>
							xPollingConsumerCount++;
    1378:	d0a8c517 	ldw	r2,-23788(gp)
    137c:	10800044 	addi	r2,r2,1
    1380:	d0a8c515 	stw	r2,-23788(gp)
						portEXIT_CRITICAL();
    1384:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    1388:	10000126 	beq	r2,zero,1390 <vPolledQueueConsumer+0x98>
    138c:	00111100 	call	11110 <vTaskExitCritical>
					}
				}

				/* Next time round we would expect the number to be one higher. */
				usExpectedValue++;
    1390:	e0bffc0b 	ldhu	r2,-16(fp)
    1394:	10800044 	addi	r2,r2,1
    1398:	e0bffc0d 	sth	r2,-16(fp)
signed portBASE_TYPE xError = pdFALSE;

	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( xQueueHandle * ) pvParameters ) ) )
    139c:	e0bfff17 	ldw	r2,-4(fp)
    13a0:	10800017 	ldw	r2,0(r2)
    13a4:	1009883a 	mov	r4,r2
    13a8:	000eef40 	call	eef4 <uxQueueMessagesWaiting>
    13ac:	103fda1e 	bne	r2,zero,1318 <vPolledQueueConsumer+0x20>
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
    13b0:	01002d04 	movi	r4,180
    13b4:	000f8c00 	call	f8c0 <vTaskDelay>
	}
    13b8:	0001883a 	nop
signed portBASE_TYPE xError = pdFALSE;

	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( xQueueHandle * ) pvParameters ) ) )
    13bc:	003ff706 	br	139c <vPolledQueueConsumer+0xa4>

000013c0 <xArePollingQueuesStillRunning>:
} /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running with no errors. */
portBASE_TYPE xArePollingQueuesStillRunning( void )
{
    13c0:	defffe04 	addi	sp,sp,-8
    13c4:	df000115 	stw	fp,4(sp)
    13c8:	df000104 	addi	fp,sp,4

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
    13cc:	d0a8c517 	ldw	r2,-23788(gp)
    13d0:	10000226 	beq	r2,zero,13dc <xArePollingQueuesStillRunning+0x1c>
		( xPollingProducerCount == pollqINITIAL_VALUE )
    13d4:	d0a8c617 	ldw	r2,-23784(gp)

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
    13d8:	1000021e 	bne	r2,zero,13e4 <xArePollingQueuesStillRunning+0x24>
		( xPollingProducerCount == pollqINITIAL_VALUE )
	  )
	{
		xReturn = pdFALSE;
    13dc:	e03fff15 	stw	zero,-4(fp)
    13e0:	00000206 	br	13ec <xArePollingQueuesStillRunning+0x2c>
	}
	else
	{
		xReturn = pdTRUE;
    13e4:	00800044 	movi	r2,1
    13e8:	e0bfff15 	stw	r2,-4(fp)
	}

	/* Set the check variables back down so we know if they have been
	incremented the next time around. */
	xPollingConsumerCount = pollqINITIAL_VALUE;
    13ec:	d028c515 	stw	zero,-23788(gp)
	xPollingProducerCount = pollqINITIAL_VALUE;
    13f0:	d028c615 	stw	zero,-23784(gp)

	return xReturn;
    13f4:	e0bfff17 	ldw	r2,-4(fp)
}
    13f8:	e037883a 	mov	sp,fp
    13fc:	df000017 	ldw	fp,0(sp)
    1400:	dec00104 	addi	sp,sp,4
    1404:	f800283a 	ret

00001408 <vStartQueuePeekTasks>:
/* Handles to the test tasks. */
xTaskHandle xMediumPriorityTask, xHighPriorityTask, xHighestPriorityTask;
/*-----------------------------------------------------------*/

void vStartQueuePeekTasks( void )
{
    1408:	defff904 	addi	sp,sp,-28
    140c:	dfc00615 	stw	ra,24(sp)
    1410:	df000515 	stw	fp,20(sp)
    1414:	df000504 	addi	fp,sp,20
xQueueHandle xQueue;

	/* Create the queue that we are going to use for the test/demo. */
	xQueue = xQueueCreate( qpeekQUEUE_LENGTH, sizeof( unsigned portLONG ) );
    1418:	01000144 	movi	r4,5
    141c:	01400104 	movi	r5,4
    1420:	000d883a 	mov	r6,zero
    1424:	000e6380 	call	e638 <xQueueGenericCreate>
    1428:	e0bfff15 	stw	r2,-4(fp)
	vQueueAddToRegistry( xQueue, ( signed portCHAR * ) "QPeek_Test_Queue" );

	/* Create the demo tasks and pass it the queue just created.  We are
	passing the queue handle by value so it does not matter that it is declared
	on the stack here. */
	xTaskCreate( prvLowPriorityPeekTask, ( signed portCHAR * )"PeekL", configMINIMAL_STACK_SIZE, ( void * ) xQueue, qpeekLOW_PRIORITY, NULL );
    142c:	d8000015 	stw	zero,0(sp)
    1430:	d8000115 	stw	zero,4(sp)
    1434:	d8000215 	stw	zero,8(sp)
    1438:	d8000315 	stw	zero,12(sp)
    143c:	01000034 	movhi	r4,0
    1440:	2105f004 	addi	r4,r4,6080
    1444:	01400134 	movhi	r5,4
    1448:	297e5904 	addi	r5,r5,-1692
    144c:	018c9604 	movi	r6,12888
    1450:	e1ffff17 	ldw	r7,-4(fp)
    1454:	000f5140 	call	f514 <xTaskGenericCreate>
	xTaskCreate( prvMediumPriorityPeekTask, ( signed portCHAR * )"PeekM", configMINIMAL_STACK_SIZE, ( void * ) xQueue, qpeekMEDIUM_PRIORITY, &xMediumPriorityTask );
    1458:	00800044 	movi	r2,1
    145c:	d8800015 	stw	r2,0(sp)
    1460:	d0a8cc04 	addi	r2,gp,-23760
    1464:	d8800115 	stw	r2,4(sp)
    1468:	d8000215 	stw	zero,8(sp)
    146c:	d8000315 	stw	zero,12(sp)
    1470:	01000034 	movhi	r4,0
    1474:	2105cd04 	addi	r4,r4,5940
    1478:	01400134 	movhi	r5,4
    147c:	297e5b04 	addi	r5,r5,-1684
    1480:	018c9604 	movi	r6,12888
    1484:	e1ffff17 	ldw	r7,-4(fp)
    1488:	000f5140 	call	f514 <xTaskGenericCreate>
	xTaskCreate( prvHighPriorityPeekTask, ( signed portCHAR * )"PeekH1", configMINIMAL_STACK_SIZE, ( void * ) xQueue, qpeekHIGH_PRIORITY, &xHighPriorityTask );
    148c:	00800084 	movi	r2,2
    1490:	d8800015 	stw	r2,0(sp)
    1494:	d0a8cb04 	addi	r2,gp,-23764
    1498:	d8800115 	stw	r2,4(sp)
    149c:	d8000215 	stw	zero,8(sp)
    14a0:	d8000315 	stw	zero,12(sp)
    14a4:	01000034 	movhi	r4,0
    14a8:	21059b04 	addi	r4,r4,5740
    14ac:	01400134 	movhi	r5,4
    14b0:	297e5d04 	addi	r5,r5,-1676
    14b4:	018c9604 	movi	r6,12888
    14b8:	e1ffff17 	ldw	r7,-4(fp)
    14bc:	000f5140 	call	f514 <xTaskGenericCreate>
	xTaskCreate( prvHighestPriorityPeekTask, ( signed portCHAR * )"PeekH2", configMINIMAL_STACK_SIZE, ( void * ) xQueue, qpeekHIGHEST_PRIORITY, &xHighestPriorityTask );
    14c0:	008000c4 	movi	r2,3
    14c4:	d8800015 	stw	r2,0(sp)
    14c8:	d0a8cd04 	addi	r2,gp,-23756
    14cc:	d8800115 	stw	r2,4(sp)
    14d0:	d8000215 	stw	zero,8(sp)
    14d4:	d8000315 	stw	zero,12(sp)
    14d8:	01000034 	movhi	r4,0
    14dc:	21054204 	addi	r4,r4,5384
    14e0:	01400134 	movhi	r5,4
    14e4:	297e5f04 	addi	r5,r5,-1668
    14e8:	018c9604 	movi	r6,12888
    14ec:	e1ffff17 	ldw	r7,-4(fp)
    14f0:	000f5140 	call	f514 <xTaskGenericCreate>
}
    14f4:	e037883a 	mov	sp,fp
    14f8:	dfc00117 	ldw	ra,4(sp)
    14fc:	df000017 	ldw	fp,0(sp)
    1500:	dec00204 	addi	sp,sp,8
    1504:	f800283a 	ret

00001508 <prvHighestPriorityPeekTask>:
/*-----------------------------------------------------------*/

static void prvHighestPriorityPeekTask( void *pvParameters )
{
    1508:	defffb04 	addi	sp,sp,-20
    150c:	dfc00415 	stw	ra,16(sp)
    1510:	df000315 	stw	fp,12(sp)
    1514:	df000304 	addi	fp,sp,12
    1518:	e13fff15 	stw	r4,-4(fp)
xQueueHandle xQueue = ( xQueueHandle ) pvParameters;
    151c:	e0bfff17 	ldw	r2,-4(fp)
    1520:	e0bffd15 	stw	r2,-12(fp)

	for( ;; )
	{
		/* Try peeking from the queue.  The queue should be empty so we will
		block, allowing the high priority task to execute. */
		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
    1524:	e0bffe04 	addi	r2,fp,-8
    1528:	e13ffd17 	ldw	r4,-12(fp)
    152c:	100b883a 	mov	r5,r2
    1530:	01bfffc4 	movi	r6,-1
    1534:	01c00044 	movi	r7,1
    1538:	000ebd80 	call	ebd8 <xQueueGenericReceive>
    153c:	10800060 	cmpeqi	r2,r2,1
    1540:	1000021e 	bne	r2,zero,154c <prvHighestPriorityPeekTask+0x44>
		{
			/* We expected to have received something by the time we unblock. */
			xErrorDetected = pdTRUE;
    1544:	00800044 	movi	r2,1
    1548:	d0a8c815 	stw	r2,-23776(gp)
		be blocked on the queue.  We unblocked because the low priority task
		wrote a value to the queue, which we should have peeked.  Peeking the
		data (rather than receiving it) will leave the data on the queue, so
		the high priority task should then have also been unblocked, but not
		yet executed. */
		if( ulValue != 0x11223344 )
    154c:	e0fffe17 	ldw	r3,-8(fp)
    1550:	008448b4 	movhi	r2,4386
    1554:	108cd104 	addi	r2,r2,13124
    1558:	18800226 	beq	r3,r2,1564 <prvHighestPriorityPeekTask+0x5c>
		{
			/* We did not receive the expected value. */
			xErrorDetected = pdTRUE;
    155c:	00800044 	movi	r2,1
    1560:	d0a8c815 	stw	r2,-23776(gp)
		}

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
    1564:	e13ffd17 	ldw	r4,-12(fp)
    1568:	000eef40 	call	eef4 <uxQueueMessagesWaiting>
    156c:	10800060 	cmpeqi	r2,r2,1
    1570:	1000021e 	bne	r2,zero,157c <prvHighestPriorityPeekTask+0x74>
		{
			/* The message should have been left on the queue. */
			xErrorDetected = pdTRUE;
    1574:	00800044 	movi	r2,1
    1578:	d0a8c815 	stw	r2,-23776(gp)
		}

		/* Now we are going to actually receive the data, so when the high
		priority task runs it will find the queue empty and return to the
		blocked state. */
		ulValue = 0;
    157c:	e03ffe15 	stw	zero,-8(fp)
		if( xQueueReceive( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
    1580:	e0bffe04 	addi	r2,fp,-8
    1584:	e13ffd17 	ldw	r4,-12(fp)
    1588:	100b883a 	mov	r5,r2
    158c:	000d883a 	mov	r6,zero
    1590:	000f883a 	mov	r7,zero
    1594:	000ebd80 	call	ebd8 <xQueueGenericReceive>
    1598:	10800060 	cmpeqi	r2,r2,1
    159c:	1000021e 	bne	r2,zero,15a8 <prvHighestPriorityPeekTask+0xa0>
		{
			/* We expected to receive the value. */
			xErrorDetected = pdTRUE;
    15a0:	00800044 	movi	r2,1
    15a4:	d0a8c815 	stw	r2,-23776(gp)
		}

		if( ulValue != 0x11223344 )
    15a8:	e0fffe17 	ldw	r3,-8(fp)
    15ac:	008448b4 	movhi	r2,4386
    15b0:	108cd104 	addi	r2,r2,13124
    15b4:	18800226 	beq	r3,r2,15c0 <prvHighestPriorityPeekTask+0xb8>
		{
			/* We did not receive the expected value - which should have been
			the same value as was peeked. */
			xErrorDetected = pdTRUE;
    15b8:	00800044 	movi	r2,1
    15bc:	d0a8c815 	stw	r2,-23776(gp)
		}

		/* Now we will block again as the queue is once more empty.  The low 
		priority task can then execute again. */
		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
    15c0:	e0bffe04 	addi	r2,fp,-8
    15c4:	e13ffd17 	ldw	r4,-12(fp)
    15c8:	100b883a 	mov	r5,r2
    15cc:	01bfffc4 	movi	r6,-1
    15d0:	01c00044 	movi	r7,1
    15d4:	000ebd80 	call	ebd8 <xQueueGenericReceive>
    15d8:	10800060 	cmpeqi	r2,r2,1
    15dc:	1000021e 	bne	r2,zero,15e8 <prvHighestPriorityPeekTask+0xe0>
		{
			/* We expected to have received something by the time we unblock. */
			xErrorDetected = pdTRUE;
    15e0:	00800044 	movi	r2,1
    15e4:	d0a8c815 	stw	r2,-23776(gp)
		}

		/* When we get here the low priority task should have again written to the
		queue. */
		if( ulValue != 0x01234567 )
    15e8:	e0fffe17 	ldw	r3,-8(fp)
    15ec:	008048f4 	movhi	r2,291
    15f0:	109159c4 	addi	r2,r2,17767
    15f4:	18800226 	beq	r3,r2,1600 <prvHighestPriorityPeekTask+0xf8>
		{
			/* We did not receive the expected value. */
			xErrorDetected = pdTRUE;
    15f8:	00800044 	movi	r2,1
    15fc:	d0a8c815 	stw	r2,-23776(gp)
		}

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
    1600:	e13ffd17 	ldw	r4,-12(fp)
    1604:	000eef40 	call	eef4 <uxQueueMessagesWaiting>
    1608:	10800060 	cmpeqi	r2,r2,1
    160c:	1000021e 	bne	r2,zero,1618 <prvHighestPriorityPeekTask+0x110>
		{
			/* The message should have been left on the queue. */
			xErrorDetected = pdTRUE;
    1610:	00800044 	movi	r2,1
    1614:	d0a8c815 	stw	r2,-23776(gp)

		/* We only peeked the data, so suspending ourselves now should enable
		the high priority task to also peek the data.  The high priority task
		will have been unblocked when we peeked the data as we left the data
		in the queue. */
		vTaskSuspend( NULL );
    1618:	0009883a 	mov	r4,zero
    161c:	000fb300 	call	fb30 <vTaskSuspend>


		/* This time we are going to do the same as the above test, but the
		high priority task is going to receive the data, rather than peek it.
		This means that the medium priority task should never peek the value. */
		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
    1620:	e0bffe04 	addi	r2,fp,-8
    1624:	e13ffd17 	ldw	r4,-12(fp)
    1628:	100b883a 	mov	r5,r2
    162c:	01bfffc4 	movi	r6,-1
    1630:	01c00044 	movi	r7,1
    1634:	000ebd80 	call	ebd8 <xQueueGenericReceive>
    1638:	10800060 	cmpeqi	r2,r2,1
    163c:	1000021e 	bne	r2,zero,1648 <prvHighestPriorityPeekTask+0x140>
		{
			xErrorDetected = pdTRUE;
    1640:	00800044 	movi	r2,1
    1644:	d0a8c815 	stw	r2,-23776(gp)
		}

		if( ulValue != 0xaabbaabb )
    1648:	e0fffe17 	ldw	r3,-8(fp)
    164c:	00aaaf34 	movhi	r2,43708
    1650:	10aaaec4 	addi	r2,r2,-21829
    1654:	18800226 	beq	r3,r2,1660 <prvHighestPriorityPeekTask+0x158>
		{
			xErrorDetected = pdTRUE;
    1658:	00800044 	movi	r2,1
    165c:	d0a8c815 	stw	r2,-23776(gp)
		}

		vTaskSuspend( NULL );		
    1660:	0009883a 	mov	r4,zero
    1664:	000fb300 	call	fb30 <vTaskSuspend>
	}
    1668:	003fae06 	br	1524 <prvHighestPriorityPeekTask+0x1c>

0000166c <prvHighPriorityPeekTask>:
}
/*-----------------------------------------------------------*/

static void prvHighPriorityPeekTask( void *pvParameters )
{
    166c:	defffb04 	addi	sp,sp,-20
    1670:	dfc00415 	stw	ra,16(sp)
    1674:	df000315 	stw	fp,12(sp)
    1678:	df000304 	addi	fp,sp,12
    167c:	e13fff15 	stw	r4,-4(fp)
xQueueHandle xQueue = ( xQueueHandle ) pvParameters;
    1680:	e0bfff17 	ldw	r2,-4(fp)
    1684:	e0bffd15 	stw	r2,-12(fp)
	for( ;; )
	{
		/* Try peeking from the queue.  The queue should be empty so we will
		block, allowing the medium priority task to execute.  Both the high
		and highest priority tasks will then be blocked on the queue. */
		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
    1688:	e0bffe04 	addi	r2,fp,-8
    168c:	e13ffd17 	ldw	r4,-12(fp)
    1690:	100b883a 	mov	r5,r2
    1694:	01bfffc4 	movi	r6,-1
    1698:	01c00044 	movi	r7,1
    169c:	000ebd80 	call	ebd8 <xQueueGenericReceive>
    16a0:	10800060 	cmpeqi	r2,r2,1
    16a4:	1000021e 	bne	r2,zero,16b0 <prvHighPriorityPeekTask+0x44>
		{
			/* We expected to have received something by the time we unblock. */
			xErrorDetected = pdTRUE;
    16a8:	00800044 	movi	r2,1
    16ac:	d0a8c815 	stw	r2,-23776(gp)
		}

		/* When we get here the highest priority task should have peeked the data
		(unblocking this task) then suspended (allowing this task to also peek
		the data). */
		if( ulValue != 0x01234567 )
    16b0:	e0fffe17 	ldw	r3,-8(fp)
    16b4:	008048f4 	movhi	r2,291
    16b8:	109159c4 	addi	r2,r2,17767
    16bc:	18800226 	beq	r3,r2,16c8 <prvHighPriorityPeekTask+0x5c>
		{
			/* We did not receive the expected value. */
			xErrorDetected = pdTRUE;
    16c0:	00800044 	movi	r2,1
    16c4:	d0a8c815 	stw	r2,-23776(gp)
		}

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
    16c8:	e13ffd17 	ldw	r4,-12(fp)
    16cc:	000eef40 	call	eef4 <uxQueueMessagesWaiting>
    16d0:	10800060 	cmpeqi	r2,r2,1
    16d4:	1000021e 	bne	r2,zero,16e0 <prvHighPriorityPeekTask+0x74>
		{
			/* The message should have been left on the queue. */
			xErrorDetected = pdTRUE;
    16d8:	00800044 	movi	r2,1
    16dc:	d0a8c815 	stw	r2,-23776(gp)

		/* We only peeked the data, so suspending ourselves now should enable
		the medium priority task to also peek the data.  The medium priority task
		will have been unblocked when we peeked the data as we left the data
		in the queue. */
		vTaskSuspend( NULL );
    16e0:	0009883a 	mov	r4,zero
    16e4:	000fb300 	call	fb30 <vTaskSuspend>


		/* This time we are going actually receive the value, so the medium
		priority task will never peek the data - we removed it from the queue. */
		if( xQueueReceive( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
    16e8:	e0bffe04 	addi	r2,fp,-8
    16ec:	e13ffd17 	ldw	r4,-12(fp)
    16f0:	100b883a 	mov	r5,r2
    16f4:	01bfffc4 	movi	r6,-1
    16f8:	000f883a 	mov	r7,zero
    16fc:	000ebd80 	call	ebd8 <xQueueGenericReceive>
    1700:	10800060 	cmpeqi	r2,r2,1
    1704:	1000021e 	bne	r2,zero,1710 <prvHighPriorityPeekTask+0xa4>
		{
			xErrorDetected = pdTRUE;
    1708:	00800044 	movi	r2,1
    170c:	d0a8c815 	stw	r2,-23776(gp)
		}

		if( ulValue != 0xaabbaabb )
    1710:	e0fffe17 	ldw	r3,-8(fp)
    1714:	00aaaf34 	movhi	r2,43708
    1718:	10aaaec4 	addi	r2,r2,-21829
    171c:	18800226 	beq	r3,r2,1728 <prvHighPriorityPeekTask+0xbc>
		{
			xErrorDetected = pdTRUE;
    1720:	00800044 	movi	r2,1
    1724:	d0a8c815 	stw	r2,-23776(gp)
		}

		vTaskSuspend( NULL );				
    1728:	0009883a 	mov	r4,zero
    172c:	000fb300 	call	fb30 <vTaskSuspend>
	}
    1730:	003fd506 	br	1688 <prvHighPriorityPeekTask+0x1c>

00001734 <prvMediumPriorityPeekTask>:
}
/*-----------------------------------------------------------*/

static void prvMediumPriorityPeekTask( void *pvParameters )
{
    1734:	defffb04 	addi	sp,sp,-20
    1738:	dfc00415 	stw	ra,16(sp)
    173c:	df000315 	stw	fp,12(sp)
    1740:	df000304 	addi	fp,sp,12
    1744:	e13fff15 	stw	r4,-4(fp)
xQueueHandle xQueue = ( xQueueHandle ) pvParameters;
    1748:	e0bfff17 	ldw	r2,-4(fp)
    174c:	e0bffd15 	stw	r2,-12(fp)
	for( ;; )
	{
		/* Try peeking from the queue.  The queue should be empty so we will
		block, allowing the low priority task to execute.  The highest, high
		and medium priority tasks will then all be blocked on the queue. */
		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
    1750:	e0bffe04 	addi	r2,fp,-8
    1754:	e13ffd17 	ldw	r4,-12(fp)
    1758:	100b883a 	mov	r5,r2
    175c:	01bfffc4 	movi	r6,-1
    1760:	01c00044 	movi	r7,1
    1764:	000ebd80 	call	ebd8 <xQueueGenericReceive>
    1768:	10800060 	cmpeqi	r2,r2,1
    176c:	1000021e 	bne	r2,zero,1778 <prvMediumPriorityPeekTask+0x44>
		{
			/* We expected to have received something by the time we unblock. */
			xErrorDetected = pdTRUE;
    1770:	00800044 	movi	r2,1
    1774:	d0a8c815 	stw	r2,-23776(gp)
		}

		/* When we get here the high priority task should have peeked the data
		(unblocking this task) then suspended (allowing this task to also peek
		the data). */
		if( ulValue != 0x01234567 )
    1778:	e0fffe17 	ldw	r3,-8(fp)
    177c:	008048f4 	movhi	r2,291
    1780:	109159c4 	addi	r2,r2,17767
    1784:	18800226 	beq	r3,r2,1790 <prvMediumPriorityPeekTask+0x5c>
		{
			/* We did not receive the expected value. */
			xErrorDetected = pdTRUE;
    1788:	00800044 	movi	r2,1
    178c:	d0a8c815 	stw	r2,-23776(gp)
		}

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
    1790:	e13ffd17 	ldw	r4,-12(fp)
    1794:	000eef40 	call	eef4 <uxQueueMessagesWaiting>
    1798:	10800060 	cmpeqi	r2,r2,1
    179c:	1000021e 	bne	r2,zero,17a8 <prvMediumPriorityPeekTask+0x74>
		{
			/* The message should have been left on the queue. */
			xErrorDetected = pdTRUE;
    17a0:	00800044 	movi	r2,1
    17a4:	d0a8c815 	stw	r2,-23776(gp)
		}

		/* Just so we know the test is still running. */
		ulLoopCounter++;
    17a8:	d0a8c917 	ldw	r2,-23772(gp)
    17ac:	10800044 	addi	r2,r2,1
    17b0:	d0a8c915 	stw	r2,-23772(gp)

		/* Now we can suspend ourselves so the low priority task can execute
		again. */
		vTaskSuspend( NULL );
    17b4:	0009883a 	mov	r4,zero
    17b8:	000fb300 	call	fb30 <vTaskSuspend>
	}
    17bc:	003fe406 	br	1750 <prvMediumPriorityPeekTask+0x1c>

000017c0 <prvLowPriorityPeekTask>:
}
/*-----------------------------------------------------------*/

static void prvLowPriorityPeekTask( void *pvParameters )
{
    17c0:	defffb04 	addi	sp,sp,-20
    17c4:	dfc00415 	stw	ra,16(sp)
    17c8:	df000315 	stw	fp,12(sp)
    17cc:	df000304 	addi	fp,sp,12
    17d0:	e13fff15 	stw	r4,-4(fp)
xQueueHandle xQueue = ( xQueueHandle ) pvParameters;
    17d4:	e0bfff17 	ldw	r2,-4(fp)
    17d8:	e0bffd15 	stw	r2,-12(fp)

	for( ;; )
	{
		/* Write some data to the queue.  This should unblock the highest 
		priority task that is waiting to peek data from the queue. */
		ulValue = 0x11223344;
    17dc:	008448b4 	movhi	r2,4386
    17e0:	108cd104 	addi	r2,r2,13124
    17e4:	e0bffe15 	stw	r2,-8(fp)
		if( xQueueSendToBack( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
    17e8:	e0bffe04 	addi	r2,fp,-8
    17ec:	e13ffd17 	ldw	r4,-12(fp)
    17f0:	100b883a 	mov	r5,r2
    17f4:	000d883a 	mov	r6,zero
    17f8:	000f883a 	mov	r7,zero
    17fc:	000e95c0 	call	e95c <xQueueGenericSend>
    1800:	10800060 	cmpeqi	r2,r2,1
    1804:	1000021e 	bne	r2,zero,1810 <prvLowPriorityPeekTask+0x50>
		{
			/* We were expecting the queue to be empty so we should not of
			had a problem writing to the queue. */
			xErrorDetected = pdTRUE;
    1808:	00800044 	movi	r2,1
    180c:	d0a8c815 	stw	r2,-23776(gp)
		}

		/* By the time we get here the data should have been removed from
		the queue. */
		if( uxQueueMessagesWaiting( xQueue ) != 0 )
    1810:	e13ffd17 	ldw	r4,-12(fp)
    1814:	000eef40 	call	eef4 <uxQueueMessagesWaiting>
    1818:	10000226 	beq	r2,zero,1824 <prvLowPriorityPeekTask+0x64>
		{
			xErrorDetected = pdTRUE;
    181c:	00800044 	movi	r2,1
    1820:	d0a8c815 	stw	r2,-23776(gp)
		}

		/* Write another value to the queue, again waking the highest priority
		task that is blocked on the queue. */
		ulValue = 0x01234567;
    1824:	008048f4 	movhi	r2,291
    1828:	109159c4 	addi	r2,r2,17767
    182c:	e0bffe15 	stw	r2,-8(fp)
		if( xQueueSendToBack( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
    1830:	e0bffe04 	addi	r2,fp,-8
    1834:	e13ffd17 	ldw	r4,-12(fp)
    1838:	100b883a 	mov	r5,r2
    183c:	000d883a 	mov	r6,zero
    1840:	000f883a 	mov	r7,zero
    1844:	000e95c0 	call	e95c <xQueueGenericSend>
    1848:	10800060 	cmpeqi	r2,r2,1
    184c:	1000021e 	bne	r2,zero,1858 <prvLowPriorityPeekTask+0x98>
		{
			/* We were expecting the queue to be empty so we should not of
			had a problem writing to the queue. */
			xErrorDetected = pdTRUE;
    1850:	00800044 	movi	r2,1
    1854:	d0a8c815 	stw	r2,-23776(gp)
		}

		/* All the other tasks should now have successfully peeked the data.
		The data is still in the queue so we should be able to receive it. */
		ulValue = 0;
    1858:	e03ffe15 	stw	zero,-8(fp)
		if( xQueueReceive( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
    185c:	e0bffe04 	addi	r2,fp,-8
    1860:	e13ffd17 	ldw	r4,-12(fp)
    1864:	100b883a 	mov	r5,r2
    1868:	000d883a 	mov	r6,zero
    186c:	000f883a 	mov	r7,zero
    1870:	000ebd80 	call	ebd8 <xQueueGenericReceive>
    1874:	10800060 	cmpeqi	r2,r2,1
    1878:	1000021e 	bne	r2,zero,1884 <prvLowPriorityPeekTask+0xc4>
		{
			/* We expected to receive the data. */
			xErrorDetected = pdTRUE;
    187c:	00800044 	movi	r2,1
    1880:	d0a8c815 	stw	r2,-23776(gp)
			/* We did not receive the expected value. */
		}
		
		/* Lets just delay a while as this is an intensive test as we don't
		want to starve other tests of processing time. */
		vTaskDelay( qpeekSHORT_DELAY );
    1884:	01000284 	movi	r4,10
    1888:	000f8c00 	call	f8c0 <vTaskDelay>
		/* Unsuspend the other tasks so we can repeat the test - this time
		however not all the other tasks will peek the data as the high
		priority task is actually going to remove it from the queue.  Send
		to front is used just to be different.  As the queue is empty it
		makes no difference to the result. */
		vTaskResume( xMediumPriorityTask );
    188c:	d0a8cc17 	ldw	r2,-23760(gp)
    1890:	1009883a 	mov	r4,r2
    1894:	000fc800 	call	fc80 <vTaskResume>
		vTaskResume( xHighPriorityTask );
    1898:	d0a8cb17 	ldw	r2,-23764(gp)
    189c:	1009883a 	mov	r4,r2
    18a0:	000fc800 	call	fc80 <vTaskResume>
		vTaskResume( xHighestPriorityTask );
    18a4:	d0a8cd17 	ldw	r2,-23756(gp)
    18a8:	1009883a 	mov	r4,r2
    18ac:	000fc800 	call	fc80 <vTaskResume>

		ulValue = 0xaabbaabb;
    18b0:	00aaaf34 	movhi	r2,43708
    18b4:	10aaaec4 	addi	r2,r2,-21829
    18b8:	e0bffe15 	stw	r2,-8(fp)
		if( xQueueSendToFront( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
    18bc:	e0bffe04 	addi	r2,fp,-8
    18c0:	e13ffd17 	ldw	r4,-12(fp)
    18c4:	100b883a 	mov	r5,r2
    18c8:	000d883a 	mov	r6,zero
    18cc:	01c00044 	movi	r7,1
    18d0:	000e95c0 	call	e95c <xQueueGenericSend>
    18d4:	10800060 	cmpeqi	r2,r2,1
    18d8:	1000021e 	bne	r2,zero,18e4 <prvLowPriorityPeekTask+0x124>
		{
			/* We were expecting the queue to be empty so we should not of
			had a problem writing to the queue. */
			xErrorDetected = pdTRUE;
    18dc:	00800044 	movi	r2,1
    18e0:	d0a8c815 	stw	r2,-23776(gp)
		}

		/* This time we should find that the queue is empty.  The high priority
		task actually removed the data rather than just peeking it. */
		if( xQueuePeek( xQueue, &ulValue, qpeekNO_BLOCK ) != errQUEUE_EMPTY )
    18e4:	e0bffe04 	addi	r2,fp,-8
    18e8:	e13ffd17 	ldw	r4,-12(fp)
    18ec:	100b883a 	mov	r5,r2
    18f0:	000d883a 	mov	r6,zero
    18f4:	01c00044 	movi	r7,1
    18f8:	000ebd80 	call	ebd8 <xQueueGenericReceive>
    18fc:	10000226 	beq	r2,zero,1908 <prvLowPriorityPeekTask+0x148>
		{
			/* We expected to receive the data. */
			xErrorDetected = pdTRUE;
    1900:	00800044 	movi	r2,1
    1904:	d0a8c815 	stw	r2,-23776(gp)
		}

		/* Unsuspend the highest and high priority tasks so we can go back
		and repeat the whole thing.  The medium priority task should not be
		suspended as it was not able to peek the data in this last case. */
		vTaskResume( xHighPriorityTask );
    1908:	d0a8cb17 	ldw	r2,-23764(gp)
    190c:	1009883a 	mov	r4,r2
    1910:	000fc800 	call	fc80 <vTaskResume>
		vTaskResume( xHighestPriorityTask );		
    1914:	d0a8cd17 	ldw	r2,-23756(gp)
    1918:	1009883a 	mov	r4,r2
    191c:	000fc800 	call	fc80 <vTaskResume>

		/* Lets just delay a while as this is an intensive test as we don't
		want to starve other tests of processing time. */
		vTaskDelay( qpeekSHORT_DELAY );
    1920:	01000284 	movi	r4,10
    1924:	000f8c00 	call	f8c0 <vTaskDelay>
	}
    1928:	003fac06 	br	17dc <prvLowPriorityPeekTask+0x1c>

0000192c <xAreQueuePeekTasksStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
portBASE_TYPE xAreQueuePeekTasksStillRunning( void )
{
    192c:	deffff04 	addi	sp,sp,-4
    1930:	df000015 	stw	fp,0(sp)
    1934:	d839883a 	mov	fp,sp
static unsigned portLONG ulLastLoopCounter = 0;

	/* If the demo task is still running then we expect the loopcounter to
	have incremented since this function was last called. */
	if( ulLastLoopCounter == ulLoopCounter )
    1938:	d0e8ca17 	ldw	r3,-23768(gp)
    193c:	d0a8c917 	ldw	r2,-23772(gp)
    1940:	1880021e 	bne	r3,r2,194c <xAreQueuePeekTasksStillRunning+0x20>
	{
		xErrorDetected = pdTRUE;
    1944:	00800044 	movi	r2,1
    1948:	d0a8c815 	stw	r2,-23776(gp)
	}

	ulLastLoopCounter = ulLoopCounter;
    194c:	d0a8c917 	ldw	r2,-23772(gp)
    1950:	d0a8ca15 	stw	r2,-23768(gp)

	/* Errors detected in the task itself will have latched xErrorDetected
	to true. */

	return !xErrorDetected;
    1954:	d0a8c817 	ldw	r2,-23776(gp)
    1958:	1005003a 	cmpeq	r2,r2,zero
    195c:	10803fcc 	andi	r2,r2,255
}
    1960:	e037883a 	mov	sp,fp
    1964:	df000017 	ldw	fp,0(sp)
    1968:	dec00104 	addi	sp,sp,4
    196c:	f800283a 	ret

00001970 <vCreateBlockTimeTasks>:
static void vSecondaryBlockTimeTestTask( void *pvParameters );

/*-----------------------------------------------------------*/

void vCreateBlockTimeTasks( void )
{
    1970:	defffa04 	addi	sp,sp,-24
    1974:	dfc00515 	stw	ra,20(sp)
    1978:	df000415 	stw	fp,16(sp)
    197c:	df000404 	addi	fp,sp,16
	/* Create the queue on which the two tasks block. */
    xTestQueue = xQueueCreate( bktQUEUE_LENGTH, sizeof( portBASE_TYPE ) );
    1980:	01000144 	movi	r4,5
    1984:	01400104 	movi	r5,4
    1988:	000d883a 	mov	r6,zero
    198c:	000e6380 	call	e638 <xQueueGenericCreate>
    1990:	d0a8ce15 	stw	r2,-23752(gp)
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is
	defined to be less than 1. */
	vQueueAddToRegistry( xTestQueue, ( signed char * ) "Block_Time_Queue" );

	/* Create the two test tasks. */
	xTaskCreate( vPrimaryBlockTimeTestTask, ( signed char * )"BTest1", configMINIMAL_STACK_SIZE, NULL, bktPRIMARY_PRIORITY, NULL );
    1994:	00800084 	movi	r2,2
    1998:	d8800015 	stw	r2,0(sp)
    199c:	d8000115 	stw	zero,4(sp)
    19a0:	d8000215 	stw	zero,8(sp)
    19a4:	d8000315 	stw	zero,12(sp)
    19a8:	01000034 	movhi	r4,0
    19ac:	21068304 	addi	r4,r4,6668
    19b0:	01400134 	movhi	r5,4
    19b4:	297e6104 	addi	r5,r5,-1660
    19b8:	018c9604 	movi	r6,12888
    19bc:	000f883a 	mov	r7,zero
    19c0:	000f5140 	call	f514 <xTaskGenericCreate>
	xTaskCreate( vSecondaryBlockTimeTestTask, ( signed char * )"BTest2", configMINIMAL_STACK_SIZE, NULL, bktSECONDARY_PRIORITY, &xSecondary );
    19c4:	00800044 	movi	r2,1
    19c8:	d8800015 	stw	r2,0(sp)
    19cc:	d0a8cf04 	addi	r2,gp,-23748
    19d0:	d8800115 	stw	r2,4(sp)
    19d4:	d8000215 	stw	zero,8(sp)
    19d8:	d8000315 	stw	zero,12(sp)
    19dc:	01000034 	movhi	r4,0
    19e0:	21078a04 	addi	r4,r4,7720
    19e4:	01400134 	movhi	r5,4
    19e8:	297e6304 	addi	r5,r5,-1652
    19ec:	018c9604 	movi	r6,12888
    19f0:	000f883a 	mov	r7,zero
    19f4:	000f5140 	call	f514 <xTaskGenericCreate>
}
    19f8:	e037883a 	mov	sp,fp
    19fc:	dfc00117 	ldw	ra,4(sp)
    1a00:	df000017 	ldw	fp,0(sp)
    1a04:	dec00204 	addi	sp,sp,8
    1a08:	f800283a 	ret

00001a0c <vPrimaryBlockTimeTestTask>:
/*-----------------------------------------------------------*/

static void vPrimaryBlockTimeTestTask( void *pvParameters )
{
    1a0c:	defff804 	addi	sp,sp,-32
    1a10:	dfc00715 	stw	ra,28(sp)
    1a14:	df000615 	stw	fp,24(sp)
    1a18:	df000604 	addi	fp,sp,24
    1a1c:	e13fff15 	stw	r4,-4(fp)
	{
		/*********************************************************************
        Test 1

        Simple block time wakeup test on queue receives. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
    1a20:	e03ffd15 	stw	zero,-12(fp)
    1a24:	00002206 	br	1ab0 <vPrimaryBlockTimeTestTask+0xa4>
		{
			/* The queue is empty. Attempt to read from the queue using a block
			time.  When we wake, ensure the delta in time is as expected. */
			xTimeToBlock = bktPRIMARY_BLOCK_TIME << xItem;
    1a28:	e0bffd17 	ldw	r2,-12(fp)
    1a2c:	00c00284 	movi	r3,10
    1a30:	1884983a 	sll	r2,r3,r2
    1a34:	e0bffa15 	stw	r2,-24(fp)

			xTimeWhenBlocking = xTaskGetTickCount();
    1a38:	001006c0 	call	1006c <xTaskGetTickCount>
    1a3c:	e0bffb15 	stw	r2,-20(fp)

			/* We should unblock after xTimeToBlock having not received
			anything on the queue. */
			if( xQueueReceive( xTestQueue, &xData, xTimeToBlock ) != errQUEUE_EMPTY )
    1a40:	d0e8ce17 	ldw	r3,-23752(gp)
    1a44:	e0bffe04 	addi	r2,fp,-8
    1a48:	1809883a 	mov	r4,r3
    1a4c:	100b883a 	mov	r5,r2
    1a50:	e1bffa17 	ldw	r6,-24(fp)
    1a54:	000f883a 	mov	r7,zero
    1a58:	000ebd80 	call	ebd8 <xQueueGenericReceive>
    1a5c:	10000226 	beq	r2,zero,1a68 <vPrimaryBlockTimeTestTask+0x5c>
			{
				xErrorOccurred = pdTRUE;
    1a60:	00800044 	movi	r2,1
    1a64:	d0a8d215 	stw	r2,-23736(gp)
			}

			/* How long were we blocked for? */
			xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
    1a68:	001006c0 	call	1006c <xTaskGetTickCount>
    1a6c:	e0fffb17 	ldw	r3,-20(fp)
    1a70:	10c5c83a 	sub	r2,r2,r3
    1a74:	e0bffc15 	stw	r2,-16(fp)

			if( xBlockedTime < xTimeToBlock )
    1a78:	e0fffc17 	ldw	r3,-16(fp)
    1a7c:	e0bffa17 	ldw	r2,-24(fp)
    1a80:	1880022e 	bgeu	r3,r2,1a8c <vPrimaryBlockTimeTestTask+0x80>
			{
				/* Should not have blocked for less than we requested. */
				xErrorOccurred = pdTRUE;
    1a84:	00800044 	movi	r2,1
    1a88:	d0a8d215 	stw	r2,-23736(gp)
			}

			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
    1a8c:	e0bffa17 	ldw	r2,-24(fp)
    1a90:	10c003c4 	addi	r3,r2,15
    1a94:	e0bffc17 	ldw	r2,-16(fp)
    1a98:	1880022e 	bgeu	r3,r2,1aa4 <vPrimaryBlockTimeTestTask+0x98>
			{
				/* Should not have blocked for longer than we requested,
				although we would not necessarily run as soon as we were
				unblocked so a margin is allowed. */
				xErrorOccurred = pdTRUE;
    1a9c:	00800044 	movi	r2,1
    1aa0:	d0a8d215 	stw	r2,-23736(gp)
	{
		/*********************************************************************
        Test 1

        Simple block time wakeup test on queue receives. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
    1aa4:	e0bffd17 	ldw	r2,-12(fp)
    1aa8:	10800044 	addi	r2,r2,1
    1aac:	e0bffd15 	stw	r2,-12(fp)
    1ab0:	e0bffd17 	ldw	r2,-12(fp)
    1ab4:	10800150 	cmplti	r2,r2,5
    1ab8:	103fdb1e 	bne	r2,zero,1a28 <vPrimaryBlockTimeTestTask+0x1c>
        Test 2

        Simple block time wakeup test on queue sends.

		First fill the queue.  It should be empty so all sends should pass. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
    1abc:	e03ffd15 	stw	zero,-12(fp)
    1ac0:	00000e06 	br	1afc <vPrimaryBlockTimeTestTask+0xf0>
		{
			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
    1ac4:	d0e8ce17 	ldw	r3,-23752(gp)
    1ac8:	e0bffd04 	addi	r2,fp,-12
    1acc:	1809883a 	mov	r4,r3
    1ad0:	100b883a 	mov	r5,r2
    1ad4:	000d883a 	mov	r6,zero
    1ad8:	000f883a 	mov	r7,zero
    1adc:	000e95c0 	call	e95c <xQueueGenericSend>
    1ae0:	10800060 	cmpeqi	r2,r2,1
    1ae4:	1000021e 	bne	r2,zero,1af0 <vPrimaryBlockTimeTestTask+0xe4>
			{
				xErrorOccurred = pdTRUE;
    1ae8:	00800044 	movi	r2,1
    1aec:	d0a8d215 	stw	r2,-23736(gp)
        Test 2

        Simple block time wakeup test on queue sends.

		First fill the queue.  It should be empty so all sends should pass. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
    1af0:	e0bffd17 	ldw	r2,-12(fp)
    1af4:	10800044 	addi	r2,r2,1
    1af8:	e0bffd15 	stw	r2,-12(fp)
    1afc:	e0bffd17 	ldw	r2,-12(fp)
    1b00:	10800150 	cmplti	r2,r2,5
    1b04:	103fef1e 	bne	r2,zero,1ac4 <vPrimaryBlockTimeTestTask+0xb8>
			#if configUSE_PREEMPTION == 0
				taskYIELD();
			#endif
		}

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
    1b08:	e03ffd15 	stw	zero,-12(fp)
    1b0c:	00002206 	br	1b98 <vPrimaryBlockTimeTestTask+0x18c>
		{
			/* The queue is full. Attempt to write to the queue using a block
			time.  When we wake, ensure the delta in time is as expected. */
			xTimeToBlock = bktPRIMARY_BLOCK_TIME << xItem;
    1b10:	e0bffd17 	ldw	r2,-12(fp)
    1b14:	00c00284 	movi	r3,10
    1b18:	1884983a 	sll	r2,r3,r2
    1b1c:	e0bffa15 	stw	r2,-24(fp)

			xTimeWhenBlocking = xTaskGetTickCount();
    1b20:	001006c0 	call	1006c <xTaskGetTickCount>
    1b24:	e0bffb15 	stw	r2,-20(fp)

			/* We should unblock after xTimeToBlock having not received
			anything on the queue. */
			if( xQueueSend( xTestQueue, &xItem, xTimeToBlock ) != errQUEUE_FULL )
    1b28:	d0e8ce17 	ldw	r3,-23752(gp)
    1b2c:	e0bffd04 	addi	r2,fp,-12
    1b30:	1809883a 	mov	r4,r3
    1b34:	100b883a 	mov	r5,r2
    1b38:	e1bffa17 	ldw	r6,-24(fp)
    1b3c:	000f883a 	mov	r7,zero
    1b40:	000e95c0 	call	e95c <xQueueGenericSend>
    1b44:	10000226 	beq	r2,zero,1b50 <vPrimaryBlockTimeTestTask+0x144>
			{
				xErrorOccurred = pdTRUE;
    1b48:	00800044 	movi	r2,1
    1b4c:	d0a8d215 	stw	r2,-23736(gp)
			}

			/* How long were we blocked for? */
			xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
    1b50:	001006c0 	call	1006c <xTaskGetTickCount>
    1b54:	e0fffb17 	ldw	r3,-20(fp)
    1b58:	10c5c83a 	sub	r2,r2,r3
    1b5c:	e0bffc15 	stw	r2,-16(fp)

			if( xBlockedTime < xTimeToBlock )
    1b60:	e0fffc17 	ldw	r3,-16(fp)
    1b64:	e0bffa17 	ldw	r2,-24(fp)
    1b68:	1880022e 	bgeu	r3,r2,1b74 <vPrimaryBlockTimeTestTask+0x168>
			{
				/* Should not have blocked for less than we requested. */
				xErrorOccurred = pdTRUE;
    1b6c:	00800044 	movi	r2,1
    1b70:	d0a8d215 	stw	r2,-23736(gp)
			}

			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
    1b74:	e0bffa17 	ldw	r2,-24(fp)
    1b78:	10c003c4 	addi	r3,r2,15
    1b7c:	e0bffc17 	ldw	r2,-16(fp)
    1b80:	1880022e 	bgeu	r3,r2,1b8c <vPrimaryBlockTimeTestTask+0x180>
			{
				/* Should not have blocked for longer than we requested,
				although we would not necessarily run as soon as we were
				unblocked so a margin is allowed. */
				xErrorOccurred = pdTRUE;
    1b84:	00800044 	movi	r2,1
    1b88:	d0a8d215 	stw	r2,-23736(gp)
			#if configUSE_PREEMPTION == 0
				taskYIELD();
			#endif
		}

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
    1b8c:	e0bffd17 	ldw	r2,-12(fp)
    1b90:	10800044 	addi	r2,r2,1
    1b94:	e0bffd15 	stw	r2,-12(fp)
    1b98:	e0bffd17 	ldw	r2,-12(fp)
    1b9c:	10800150 	cmplti	r2,r2,5
    1ba0:	103fdb1e 	bne	r2,zero,1b10 <vPrimaryBlockTimeTestTask+0x104>
		recognise that its block time has not expired and return to block for
		the remains of its block time.

		Wake the other task so it blocks attempting to post to the already
		full queue. */
		xRunIndicator = 0;
    1ba4:	d028d315 	stw	zero,-23732(gp)
		vTaskResume( xSecondary );
    1ba8:	d0a8cf17 	ldw	r2,-23748(gp)
    1bac:	1009883a 	mov	r4,r2
    1bb0:	000fc800 	call	fc80 <vTaskResume>

		/* We need to wait a little to ensure the other task executes. */
		while( xRunIndicator != bktRUN_INDICATOR )
    1bb4:	00000206 	br	1bc0 <vPrimaryBlockTimeTestTask+0x1b4>
		{
			/* The other task has not yet executed. */
			vTaskDelay( bktSHORT_WAIT );
    1bb8:	01000504 	movi	r4,20
    1bbc:	000f8c00 	call	f8c0 <vTaskDelay>
		full queue. */
		xRunIndicator = 0;
		vTaskResume( xSecondary );

		/* We need to wait a little to ensure the other task executes. */
		while( xRunIndicator != bktRUN_INDICATOR )
    1bc0:	d0a8d317 	ldw	r2,-23732(gp)
    1bc4:	10801558 	cmpnei	r2,r2,85
    1bc8:	103ffb1e 	bne	r2,zero,1bb8 <vPrimaryBlockTimeTestTask+0x1ac>
		{
			/* The other task has not yet executed. */
			vTaskDelay( bktSHORT_WAIT );
		}
		/* Make sure the other task is blocked on the queue. */
		vTaskDelay( bktSHORT_WAIT );
    1bcc:	01000504 	movi	r4,20
    1bd0:	000f8c00 	call	f8c0 <vTaskDelay>
		xRunIndicator = 0;
    1bd4:	d028d315 	stw	zero,-23732(gp)

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
    1bd8:	e03ffd15 	stw	zero,-12(fp)
    1bdc:	00002b06 	br	1c8c <vPrimaryBlockTimeTestTask+0x280>
		{
			/* Now when we make space on the queue the other task should wake
			but not execute as this task has higher priority. */
			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
    1be0:	d0e8ce17 	ldw	r3,-23752(gp)
    1be4:	e0bffe04 	addi	r2,fp,-8
    1be8:	1809883a 	mov	r4,r3
    1bec:	100b883a 	mov	r5,r2
    1bf0:	000d883a 	mov	r6,zero
    1bf4:	000f883a 	mov	r7,zero
    1bf8:	000ebd80 	call	ebd8 <xQueueGenericReceive>
    1bfc:	10800060 	cmpeqi	r2,r2,1
    1c00:	1000021e 	bne	r2,zero,1c0c <vPrimaryBlockTimeTestTask+0x200>
			{
				xErrorOccurred = pdTRUE;
    1c04:	00800044 	movi	r2,1
    1c08:	d0a8d215 	stw	r2,-23736(gp)
			}

			/* Now fill the queue again before the other task gets a chance to
			execute.  If the other task had executed we would find the queue
			full ourselves, and the other task have set xRunIndicator. */
			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
    1c0c:	d0e8ce17 	ldw	r3,-23752(gp)
    1c10:	e0bffd04 	addi	r2,fp,-12
    1c14:	1809883a 	mov	r4,r3
    1c18:	100b883a 	mov	r5,r2
    1c1c:	000d883a 	mov	r6,zero
    1c20:	000f883a 	mov	r7,zero
    1c24:	000e95c0 	call	e95c <xQueueGenericSend>
    1c28:	10800060 	cmpeqi	r2,r2,1
    1c2c:	1000021e 	bne	r2,zero,1c38 <vPrimaryBlockTimeTestTask+0x22c>
			{
				xErrorOccurred = pdTRUE;
    1c30:	00800044 	movi	r2,1
    1c34:	d0a8d215 	stw	r2,-23736(gp)
			}

			if( xRunIndicator == bktRUN_INDICATOR )
    1c38:	d0a8d317 	ldw	r2,-23732(gp)
    1c3c:	10801558 	cmpnei	r2,r2,85
    1c40:	1000021e 	bne	r2,zero,1c4c <vPrimaryBlockTimeTestTask+0x240>
			{
				/* The other task should not have executed. */
				xErrorOccurred = pdTRUE;
    1c44:	00800044 	movi	r2,1
    1c48:	d0a8d215 	stw	r2,-23736(gp)
			}

			/* Raise the priority of the other task so it executes and blocks
			on the queue again. */
			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
    1c4c:	d0a8cf17 	ldw	r2,-23748(gp)
    1c50:	1009883a 	mov	r4,r2
    1c54:	01400104 	movi	r5,4
    1c58:	000f99c0 	call	f99c <vTaskPrioritySet>

			/* The other task should now have re-blocked without exiting the
			queue function. */
			if( xRunIndicator == bktRUN_INDICATOR )
    1c5c:	d0a8d317 	ldw	r2,-23732(gp)
    1c60:	10801558 	cmpnei	r2,r2,85
    1c64:	1000021e 	bne	r2,zero,1c70 <vPrimaryBlockTimeTestTask+0x264>
			{
				/* The other task should not have executed outside of the
				queue function. */
				xErrorOccurred = pdTRUE;
    1c68:	00800044 	movi	r2,1
    1c6c:	d0a8d215 	stw	r2,-23736(gp)
			}

			/* Set the priority back down. */
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
    1c70:	d0a8cf17 	ldw	r2,-23748(gp)
    1c74:	1009883a 	mov	r4,r2
    1c78:	01400044 	movi	r5,1
    1c7c:	000f99c0 	call	f99c <vTaskPrioritySet>
		}
		/* Make sure the other task is blocked on the queue. */
		vTaskDelay( bktSHORT_WAIT );
		xRunIndicator = 0;

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
    1c80:	e0bffd17 	ldw	r2,-12(fp)
    1c84:	10800044 	addi	r2,r2,1
    1c88:	e0bffd15 	stw	r2,-12(fp)
    1c8c:	e0bffd17 	ldw	r2,-12(fp)
    1c90:	10800150 	cmplti	r2,r2,5
    1c94:	103fd21e 	bne	r2,zero,1be0 <vPrimaryBlockTimeTestTask+0x1d4>
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
		}

		/* Let the other task timeout.  When it unblockes it will check that it
		unblocked at the correct time, then suspend itself. */
		while( xRunIndicator != bktRUN_INDICATOR )
    1c98:	00000206 	br	1ca4 <vPrimaryBlockTimeTestTask+0x298>
		{
			vTaskDelay( bktSHORT_WAIT );
    1c9c:	01000504 	movi	r4,20
    1ca0:	000f8c00 	call	f8c0 <vTaskDelay>
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
		}

		/* Let the other task timeout.  When it unblockes it will check that it
		unblocked at the correct time, then suspend itself. */
		while( xRunIndicator != bktRUN_INDICATOR )
    1ca4:	d0a8d317 	ldw	r2,-23732(gp)
    1ca8:	10801558 	cmpnei	r2,r2,85
    1cac:	103ffb1e 	bne	r2,zero,1c9c <vPrimaryBlockTimeTestTask+0x290>
		{
			vTaskDelay( bktSHORT_WAIT );
		}
		vTaskDelay( bktSHORT_WAIT );
    1cb0:	01000504 	movi	r4,20
    1cb4:	000f8c00 	call	f8c0 <vTaskDelay>
		xRunIndicator = 0;
    1cb8:	d028d315 	stw	zero,-23732(gp)

		As per test 3 - but with the send and receive the other way around.
		The other task blocks attempting to read from the queue.

		Empty the queue.  We should find that it is full. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
    1cbc:	e03ffd15 	stw	zero,-12(fp)
    1cc0:	00000e06 	br	1cfc <vPrimaryBlockTimeTestTask+0x2f0>
		{
			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
    1cc4:	d0e8ce17 	ldw	r3,-23752(gp)
    1cc8:	e0bffe04 	addi	r2,fp,-8
    1ccc:	1809883a 	mov	r4,r3
    1cd0:	100b883a 	mov	r5,r2
    1cd4:	000d883a 	mov	r6,zero
    1cd8:	000f883a 	mov	r7,zero
    1cdc:	000ebd80 	call	ebd8 <xQueueGenericReceive>
    1ce0:	10800060 	cmpeqi	r2,r2,1
    1ce4:	1000021e 	bne	r2,zero,1cf0 <vPrimaryBlockTimeTestTask+0x2e4>
			{
				xErrorOccurred = pdTRUE;
    1ce8:	00800044 	movi	r2,1
    1cec:	d0a8d215 	stw	r2,-23736(gp)

		As per test 3 - but with the send and receive the other way around.
		The other task blocks attempting to read from the queue.

		Empty the queue.  We should find that it is full. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
    1cf0:	e0bffd17 	ldw	r2,-12(fp)
    1cf4:	10800044 	addi	r2,r2,1
    1cf8:	e0bffd15 	stw	r2,-12(fp)
    1cfc:	e0bffd17 	ldw	r2,-12(fp)
    1d00:	10800150 	cmplti	r2,r2,5
    1d04:	103fef1e 	bne	r2,zero,1cc4 <vPrimaryBlockTimeTestTask+0x2b8>
			}
		}

		/* Wake the other task so it blocks attempting to read from  the
		already	empty queue. */
		vTaskResume( xSecondary );
    1d08:	d0a8cf17 	ldw	r2,-23748(gp)
    1d0c:	1009883a 	mov	r4,r2
    1d10:	000fc800 	call	fc80 <vTaskResume>

		/* We need to wait a little to ensure the other task executes. */
		while( xRunIndicator != bktRUN_INDICATOR )
    1d14:	00000206 	br	1d20 <vPrimaryBlockTimeTestTask+0x314>
		{
			vTaskDelay( bktSHORT_WAIT );
    1d18:	01000504 	movi	r4,20
    1d1c:	000f8c00 	call	f8c0 <vTaskDelay>
		/* Wake the other task so it blocks attempting to read from  the
		already	empty queue. */
		vTaskResume( xSecondary );

		/* We need to wait a little to ensure the other task executes. */
		while( xRunIndicator != bktRUN_INDICATOR )
    1d20:	d0a8d317 	ldw	r2,-23732(gp)
    1d24:	10801558 	cmpnei	r2,r2,85
    1d28:	103ffb1e 	bne	r2,zero,1d18 <vPrimaryBlockTimeTestTask+0x30c>
		{
			vTaskDelay( bktSHORT_WAIT );
		}
		vTaskDelay( bktSHORT_WAIT );
    1d2c:	01000504 	movi	r4,20
    1d30:	000f8c00 	call	f8c0 <vTaskDelay>
		xRunIndicator = 0;
    1d34:	d028d315 	stw	zero,-23732(gp)

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
    1d38:	e03ffd15 	stw	zero,-12(fp)
    1d3c:	00002b06 	br	1dec <vPrimaryBlockTimeTestTask+0x3e0>
		{
			/* Now when we place an item on the queue the other task should
			wake but not execute as this task has higher priority. */
			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
    1d40:	d0e8ce17 	ldw	r3,-23752(gp)
    1d44:	e0bffd04 	addi	r2,fp,-12
    1d48:	1809883a 	mov	r4,r3
    1d4c:	100b883a 	mov	r5,r2
    1d50:	000d883a 	mov	r6,zero
    1d54:	000f883a 	mov	r7,zero
    1d58:	000e95c0 	call	e95c <xQueueGenericSend>
    1d5c:	10800060 	cmpeqi	r2,r2,1
    1d60:	1000021e 	bne	r2,zero,1d6c <vPrimaryBlockTimeTestTask+0x360>
			{
				xErrorOccurred = pdTRUE;
    1d64:	00800044 	movi	r2,1
    1d68:	d0a8d215 	stw	r2,-23736(gp)
			}

			/* Now empty the queue again before the other task gets a chance to
			execute.  If the other task had executed we would find the queue
			empty ourselves, and the other task would be suspended. */
			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
    1d6c:	d0e8ce17 	ldw	r3,-23752(gp)
    1d70:	e0bffe04 	addi	r2,fp,-8
    1d74:	1809883a 	mov	r4,r3
    1d78:	100b883a 	mov	r5,r2
    1d7c:	000d883a 	mov	r6,zero
    1d80:	000f883a 	mov	r7,zero
    1d84:	000ebd80 	call	ebd8 <xQueueGenericReceive>
    1d88:	10800060 	cmpeqi	r2,r2,1
    1d8c:	1000021e 	bne	r2,zero,1d98 <vPrimaryBlockTimeTestTask+0x38c>
			{
				xErrorOccurred = pdTRUE;
    1d90:	00800044 	movi	r2,1
    1d94:	d0a8d215 	stw	r2,-23736(gp)
			}

			if( xRunIndicator == bktRUN_INDICATOR )
    1d98:	d0a8d317 	ldw	r2,-23732(gp)
    1d9c:	10801558 	cmpnei	r2,r2,85
    1da0:	1000021e 	bne	r2,zero,1dac <vPrimaryBlockTimeTestTask+0x3a0>
			{
				/* The other task should not have executed. */
				xErrorOccurred = pdTRUE;
    1da4:	00800044 	movi	r2,1
    1da8:	d0a8d215 	stw	r2,-23736(gp)
			}

			/* Raise the priority of the other task so it executes and blocks
			on the queue again. */
			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
    1dac:	d0a8cf17 	ldw	r2,-23748(gp)
    1db0:	1009883a 	mov	r4,r2
    1db4:	01400104 	movi	r5,4
    1db8:	000f99c0 	call	f99c <vTaskPrioritySet>

			/* The other task should now have re-blocked without exiting the
			queue function. */
			if( xRunIndicator == bktRUN_INDICATOR )
    1dbc:	d0a8d317 	ldw	r2,-23732(gp)
    1dc0:	10801558 	cmpnei	r2,r2,85
    1dc4:	1000021e 	bne	r2,zero,1dd0 <vPrimaryBlockTimeTestTask+0x3c4>
			{
				/* The other task should not have executed outside of the
				queue function. */
				xErrorOccurred = pdTRUE;
    1dc8:	00800044 	movi	r2,1
    1dcc:	d0a8d215 	stw	r2,-23736(gp)
			}
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
    1dd0:	d0a8cf17 	ldw	r2,-23748(gp)
    1dd4:	1009883a 	mov	r4,r2
    1dd8:	01400044 	movi	r5,1
    1ddc:	000f99c0 	call	f99c <vTaskPrioritySet>
			vTaskDelay( bktSHORT_WAIT );
		}
		vTaskDelay( bktSHORT_WAIT );
		xRunIndicator = 0;

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
    1de0:	e0bffd17 	ldw	r2,-12(fp)
    1de4:	10800044 	addi	r2,r2,1
    1de8:	e0bffd15 	stw	r2,-12(fp)
    1dec:	e0bffd17 	ldw	r2,-12(fp)
    1df0:	10800150 	cmplti	r2,r2,5
    1df4:	103fd21e 	bne	r2,zero,1d40 <vPrimaryBlockTimeTestTask+0x334>
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
		}

		/* Let the other task timeout.  When it unblockes it will check that it
		unblocked at the correct time, then suspend itself. */
		while( xRunIndicator != bktRUN_INDICATOR )
    1df8:	00000206 	br	1e04 <vPrimaryBlockTimeTestTask+0x3f8>
		{
			vTaskDelay( bktSHORT_WAIT );
    1dfc:	01000504 	movi	r4,20
    1e00:	000f8c00 	call	f8c0 <vTaskDelay>
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
		}

		/* Let the other task timeout.  When it unblockes it will check that it
		unblocked at the correct time, then suspend itself. */
		while( xRunIndicator != bktRUN_INDICATOR )
    1e04:	d0a8d317 	ldw	r2,-23732(gp)
    1e08:	10801558 	cmpnei	r2,r2,85
    1e0c:	103ffb1e 	bne	r2,zero,1dfc <vPrimaryBlockTimeTestTask+0x3f0>
		{
			vTaskDelay( bktSHORT_WAIT );
		}
		vTaskDelay( bktSHORT_WAIT );
    1e10:	01000504 	movi	r4,20
    1e14:	000f8c00 	call	f8c0 <vTaskDelay>

		xPrimaryCycles++;
    1e18:	d0a8d017 	ldw	r2,-23744(gp)
    1e1c:	10800044 	addi	r2,r2,1
    1e20:	d0a8d015 	stw	r2,-23744(gp)
	}
    1e24:	003efe06 	br	1a20 <vPrimaryBlockTimeTestTask+0x14>

00001e28 <vSecondaryBlockTimeTestTask>:
}
/*-----------------------------------------------------------*/

static void vSecondaryBlockTimeTestTask( void *pvParameters )
{
    1e28:	defffa04 	addi	sp,sp,-24
    1e2c:	dfc00515 	stw	ra,20(sp)
    1e30:	df000415 	stw	fp,16(sp)
    1e34:	df000404 	addi	fp,sp,16
    1e38:	e13fff15 	stw	r4,-4(fp)
	{
		/*********************************************************************
        Test 1 and 2

		This task does does not participate in these tests. */
		vTaskSuspend( NULL );
    1e3c:	0009883a 	mov	r4,zero
    1e40:	000fb300 	call	fb30 <vTaskSuspend>
        Test 3

		The first thing we do is attempt to read from the queue.  It should be
		full so we block.  Note the time before we block so we can check the
		wake time is as per that expected. */
		xTimeWhenBlocking = xTaskGetTickCount();
    1e44:	001006c0 	call	1006c <xTaskGetTickCount>
    1e48:	e0bffc15 	stw	r2,-16(fp)

		/* We should unblock after bktTIME_TO_BLOCK having not sent
		anything to the queue. */
		xData = 0;
    1e4c:	e03ffe15 	stw	zero,-8(fp)
		xRunIndicator = bktRUN_INDICATOR;
    1e50:	00801544 	movi	r2,85
    1e54:	d0a8d315 	stw	r2,-23732(gp)
		if( xQueueSend( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_FULL )
    1e58:	d0e8ce17 	ldw	r3,-23752(gp)
    1e5c:	e0bffe04 	addi	r2,fp,-8
    1e60:	1809883a 	mov	r4,r3
    1e64:	100b883a 	mov	r5,r2
    1e68:	01802bc4 	movi	r6,175
    1e6c:	000f883a 	mov	r7,zero
    1e70:	000e95c0 	call	e95c <xQueueGenericSend>
    1e74:	10000226 	beq	r2,zero,1e80 <vSecondaryBlockTimeTestTask+0x58>
		{
			xErrorOccurred = pdTRUE;
    1e78:	00800044 	movi	r2,1
    1e7c:	d0a8d215 	stw	r2,-23736(gp)
		}

		/* How long were we inside the send function? */
		xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
    1e80:	001006c0 	call	1006c <xTaskGetTickCount>
    1e84:	e0fffc17 	ldw	r3,-16(fp)
    1e88:	10c5c83a 	sub	r2,r2,r3
    1e8c:	e0bffd15 	stw	r2,-12(fp)

		/* We should not have blocked for less time than bktTIME_TO_BLOCK. */
		if( xBlockedTime < bktTIME_TO_BLOCK )
    1e90:	e0bffd17 	ldw	r2,-12(fp)
    1e94:	10802be8 	cmpgeui	r2,r2,175
    1e98:	1000021e 	bne	r2,zero,1ea4 <vSecondaryBlockTimeTestTask+0x7c>
		{
			xErrorOccurred = pdTRUE;
    1e9c:	00800044 	movi	r2,1
    1ea0:	d0a8d215 	stw	r2,-23736(gp)
		}

		/* We should of not blocked for much longer than bktALLOWABLE_MARGIN
		either.  A margin is permitted as we would not necessarily run as
		soon as we unblocked. */
		if( xBlockedTime > ( bktTIME_TO_BLOCK + bktALLOWABLE_MARGIN ) )
    1ea4:	e0bffd17 	ldw	r2,-12(fp)
    1ea8:	10802ff0 	cmpltui	r2,r2,191
    1eac:	1000021e 	bne	r2,zero,1eb8 <vSecondaryBlockTimeTestTask+0x90>
		{
			xErrorOccurred = pdTRUE;
    1eb0:	00800044 	movi	r2,1
    1eb4:	d0a8d215 	stw	r2,-23736(gp)
		}

		/* Suspend ready for test 3. */
		xRunIndicator = bktRUN_INDICATOR;
    1eb8:	00801544 	movi	r2,85
    1ebc:	d0a8d315 	stw	r2,-23732(gp)
		vTaskSuspend( NULL );
    1ec0:	0009883a 	mov	r4,zero
    1ec4:	000fb300 	call	fb30 <vTaskSuspend>

		/*********************************************************************
        Test 4

		As per test three, but with the send and receive reversed. */
		xTimeWhenBlocking = xTaskGetTickCount();
    1ec8:	001006c0 	call	1006c <xTaskGetTickCount>
    1ecc:	e0bffc15 	stw	r2,-16(fp)

		/* We should unblock after bktTIME_TO_BLOCK having not received
		anything on the queue. */
		xRunIndicator = bktRUN_INDICATOR;
    1ed0:	00801544 	movi	r2,85
    1ed4:	d0a8d315 	stw	r2,-23732(gp)
		if( xQueueReceive( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_EMPTY )
    1ed8:	d0e8ce17 	ldw	r3,-23752(gp)
    1edc:	e0bffe04 	addi	r2,fp,-8
    1ee0:	1809883a 	mov	r4,r3
    1ee4:	100b883a 	mov	r5,r2
    1ee8:	01802bc4 	movi	r6,175
    1eec:	000f883a 	mov	r7,zero
    1ef0:	000ebd80 	call	ebd8 <xQueueGenericReceive>
    1ef4:	10000226 	beq	r2,zero,1f00 <vSecondaryBlockTimeTestTask+0xd8>
		{
			xErrorOccurred = pdTRUE;
    1ef8:	00800044 	movi	r2,1
    1efc:	d0a8d215 	stw	r2,-23736(gp)
		}

		xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
    1f00:	001006c0 	call	1006c <xTaskGetTickCount>
    1f04:	e0fffc17 	ldw	r3,-16(fp)
    1f08:	10c5c83a 	sub	r2,r2,r3
    1f0c:	e0bffd15 	stw	r2,-12(fp)

		/* We should not have blocked for less time than bktTIME_TO_BLOCK. */
		if( xBlockedTime < bktTIME_TO_BLOCK )
    1f10:	e0bffd17 	ldw	r2,-12(fp)
    1f14:	10802be8 	cmpgeui	r2,r2,175
    1f18:	1000021e 	bne	r2,zero,1f24 <vSecondaryBlockTimeTestTask+0xfc>
		{
			xErrorOccurred = pdTRUE;
    1f1c:	00800044 	movi	r2,1
    1f20:	d0a8d215 	stw	r2,-23736(gp)
		}

		/* We should of not blocked for much longer than bktALLOWABLE_MARGIN
		either.  A margin is permitted as we would not necessarily run as soon
		as we unblocked. */
		if( xBlockedTime > ( bktTIME_TO_BLOCK + bktALLOWABLE_MARGIN ) )
    1f24:	e0bffd17 	ldw	r2,-12(fp)
    1f28:	10802ff0 	cmpltui	r2,r2,191
    1f2c:	1000021e 	bne	r2,zero,1f38 <vSecondaryBlockTimeTestTask+0x110>
		{
			xErrorOccurred = pdTRUE;
    1f30:	00800044 	movi	r2,1
    1f34:	d0a8d215 	stw	r2,-23736(gp)
		}

		xRunIndicator = bktRUN_INDICATOR;
    1f38:	00801544 	movi	r2,85
    1f3c:	d0a8d315 	stw	r2,-23732(gp)

		xSecondaryCycles++;
    1f40:	d0a8d117 	ldw	r2,-23740(gp)
    1f44:	10800044 	addi	r2,r2,1
    1f48:	d0a8d115 	stw	r2,-23740(gp)
	}
    1f4c:	003fbb06 	br	1e3c <vSecondaryBlockTimeTestTask+0x14>

00001f50 <xAreBlockTimeTestTasksStillRunning>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xAreBlockTimeTestTasksStillRunning( void )
{
    1f50:	defffe04 	addi	sp,sp,-8
    1f54:	df000115 	stw	fp,4(sp)
    1f58:	df000104 	addi	fp,sp,4
static portBASE_TYPE xLastPrimaryCycleCount = 0, xLastSecondaryCycleCount = 0;
portBASE_TYPE xReturn = pdPASS;
    1f5c:	00800044 	movi	r2,1
    1f60:	e0bfff15 	stw	r2,-4(fp)

	/* Have both tasks performed at least one cycle since this function was
	last called? */
	if( xPrimaryCycles == xLastPrimaryCycleCount )
    1f64:	d0e8d017 	ldw	r3,-23744(gp)
    1f68:	d0a8d417 	ldw	r2,-23728(gp)
    1f6c:	1880011e 	bne	r3,r2,1f74 <xAreBlockTimeTestTasksStillRunning+0x24>
	{
		xReturn = pdFAIL;
    1f70:	e03fff15 	stw	zero,-4(fp)
	}

	if( xSecondaryCycles == xLastSecondaryCycleCount )
    1f74:	d0e8d117 	ldw	r3,-23740(gp)
    1f78:	d0a8d517 	ldw	r2,-23724(gp)
    1f7c:	1880011e 	bne	r3,r2,1f84 <xAreBlockTimeTestTasksStillRunning+0x34>
	{
		xReturn = pdFAIL;
    1f80:	e03fff15 	stw	zero,-4(fp)
	}

	if( xErrorOccurred == pdTRUE )
    1f84:	d0a8d217 	ldw	r2,-23736(gp)
    1f88:	10800058 	cmpnei	r2,r2,1
    1f8c:	1000011e 	bne	r2,zero,1f94 <xAreBlockTimeTestTasksStillRunning+0x44>
	{
		xReturn = pdFAIL;
    1f90:	e03fff15 	stw	zero,-4(fp)
	}

	xLastSecondaryCycleCount = xSecondaryCycles;
    1f94:	d0a8d117 	ldw	r2,-23740(gp)
    1f98:	d0a8d515 	stw	r2,-23724(gp)
	xLastPrimaryCycleCount = xPrimaryCycles;
    1f9c:	d0a8d017 	ldw	r2,-23744(gp)
    1fa0:	d0a8d415 	stw	r2,-23728(gp)

	return xReturn;
    1fa4:	e0bfff17 	ldw	r2,-4(fp)
}
    1fa8:	e037883a 	mov	sp,fp
    1fac:	df000017 	ldw	fp,0(sp)
    1fb0:	dec00104 	addi	sp,sp,4
    1fb4:	f800283a 	ret

00001fb8 <vStartCountingSemaphoreTasks>:
static volatile xCountSemStruct xParameters[ countNUM_TEST_TASKS ];

/*-----------------------------------------------------------*/

void vStartCountingSemaphoreTasks( void )
{
    1fb8:	defffa04 	addi	sp,sp,-24
    1fbc:	dfc00515 	stw	ra,20(sp)
    1fc0:	df000415 	stw	fp,16(sp)
    1fc4:	df000404 	addi	fp,sp,16
	/* Create the semaphores that we are going to use for the test/demo.  The
	first should be created such that it starts at its maximum count value,
	the second should be created such that it starts with a count value of zero. */
	xParameters[ 0 ].xSemaphore = xSemaphoreCreateCounting( countMAX_COUNT_VALUE, countMAX_COUNT_VALUE );
    1fc8:	01003204 	movi	r4,200
    1fcc:	01403204 	movi	r5,200
    1fd0:	000e9040 	call	e904 <xQueueCreateCountingSemaphore>
    1fd4:	00c00134 	movhi	r3,4
    1fd8:	18df0e04 	addi	r3,r3,31800
    1fdc:	18800015 	stw	r2,0(r3)
	xParameters[ 0 ].uxExpectedStartCount = countSTART_AT_MAX_COUNT;
    1fe0:	00800134 	movhi	r2,4
    1fe4:	109f0e04 	addi	r2,r2,31800
    1fe8:	00c02a84 	movi	r3,170
    1fec:	10c00115 	stw	r3,4(r2)
	xParameters[ 0 ].uxLoopCounter = 0;
    1ff0:	00800134 	movhi	r2,4
    1ff4:	109f0e04 	addi	r2,r2,31800
    1ff8:	10000215 	stw	zero,8(r2)

	xParameters[ 1 ].xSemaphore = xSemaphoreCreateCounting( countMAX_COUNT_VALUE, 0 );
    1ffc:	01003204 	movi	r4,200
    2000:	000b883a 	mov	r5,zero
    2004:	000e9040 	call	e904 <xQueueCreateCountingSemaphore>
    2008:	00c00134 	movhi	r3,4
    200c:	18df0e04 	addi	r3,r3,31800
    2010:	18800315 	stw	r2,12(r3)
	xParameters[ 1 ].uxExpectedStartCount = 0;
    2014:	00800134 	movhi	r2,4
    2018:	109f0e04 	addi	r2,r2,31800
    201c:	10000415 	stw	zero,16(r2)
	xParameters[ 1 ].uxLoopCounter = 0;
    2020:	00800134 	movhi	r2,4
    2024:	109f0e04 	addi	r2,r2,31800
    2028:	10000515 	stw	zero,20(r2)
	vQueueAddToRegistry( ( xQueueHandle ) xParameters[ 0 ].xSemaphore, ( signed portCHAR * ) "Counting_Sem_1" );
	vQueueAddToRegistry( ( xQueueHandle ) xParameters[ 1 ].xSemaphore, ( signed portCHAR * ) "Counting_Sem_2" );


	/* Were the semaphores created? */
	if( ( xParameters[ 0 ].xSemaphore != NULL ) || ( xParameters[ 1 ].xSemaphore != NULL ) )
    202c:	00800134 	movhi	r2,4
    2030:	109f0e04 	addi	r2,r2,31800
    2034:	10800017 	ldw	r2,0(r2)
    2038:	1000041e 	bne	r2,zero,204c <vStartCountingSemaphoreTasks+0x94>
    203c:	00800134 	movhi	r2,4
    2040:	109f0e04 	addi	r2,r2,31800
    2044:	10800317 	ldw	r2,12(r2)
    2048:	10001826 	beq	r2,zero,20ac <vStartCountingSemaphoreTasks+0xf4>
	{
		/* Create the demo tasks, passing in the semaphore to use as the parameter. */
		xTaskCreate( prvCountingSemaphoreTask, ( signed portCHAR * ) "CNT1", configMINIMAL_STACK_SIZE, ( void * ) &( xParameters[ 0 ] ), tskIDLE_PRIORITY, NULL );
    204c:	d8000015 	stw	zero,0(sp)
    2050:	d8000115 	stw	zero,4(sp)
    2054:	d8000215 	stw	zero,8(sp)
    2058:	d8000315 	stw	zero,12(sp)
    205c:	01000034 	movhi	r4,0
    2060:	21089604 	addi	r4,r4,8792
    2064:	01400134 	movhi	r5,4
    2068:	297e6504 	addi	r5,r5,-1644
    206c:	018c9604 	movi	r6,12888
    2070:	01c00134 	movhi	r7,4
    2074:	39df0e04 	addi	r7,r7,31800
    2078:	000f5140 	call	f514 <xTaskGenericCreate>
		xTaskCreate( prvCountingSemaphoreTask, ( signed portCHAR * ) "CNT2", configMINIMAL_STACK_SIZE, ( void * ) &( xParameters[ 1 ] ), tskIDLE_PRIORITY, NULL );		
    207c:	d8000015 	stw	zero,0(sp)
    2080:	d8000115 	stw	zero,4(sp)
    2084:	d8000215 	stw	zero,8(sp)
    2088:	d8000315 	stw	zero,12(sp)
    208c:	01000034 	movhi	r4,0
    2090:	21089604 	addi	r4,r4,8792
    2094:	01400134 	movhi	r5,4
    2098:	297e6704 	addi	r5,r5,-1636
    209c:	018c9604 	movi	r6,12888
    20a0:	01c00134 	movhi	r7,4
    20a4:	39df1104 	addi	r7,r7,31812
    20a8:	000f5140 	call	f514 <xTaskGenericCreate>
	}
}
    20ac:	e037883a 	mov	sp,fp
    20b0:	dfc00117 	ldw	ra,4(sp)
    20b4:	df000017 	ldw	fp,0(sp)
    20b8:	dec00204 	addi	sp,sp,8
    20bc:	f800283a 	ret

000020c0 <prvDecrementSemaphoreCount>:
/*-----------------------------------------------------------*/

static void prvDecrementSemaphoreCount( xSemaphoreHandle xSemaphore, unsigned portBASE_TYPE *puxLoopCounter )
{
    20c0:	defffb04 	addi	sp,sp,-20
    20c4:	dfc00415 	stw	ra,16(sp)
    20c8:	df000315 	stw	fp,12(sp)
    20cc:	df000304 	addi	fp,sp,12
    20d0:	e13ffe15 	stw	r4,-8(fp)
    20d4:	e17fff15 	stw	r5,-4(fp)
unsigned portBASE_TYPE ux;

	/* If the semaphore count is at its maximum then we should not be able to
	'give' the semaphore. */
	if( xSemaphoreGive( xSemaphore ) == pdPASS )
    20d8:	e13ffe17 	ldw	r4,-8(fp)
    20dc:	000b883a 	mov	r5,zero
    20e0:	000d883a 	mov	r6,zero
    20e4:	000f883a 	mov	r7,zero
    20e8:	000e95c0 	call	e95c <xQueueGenericSend>
    20ec:	10800058 	cmpnei	r2,r2,1
    20f0:	1000021e 	bne	r2,zero,20fc <prvDecrementSemaphoreCount+0x3c>
	{
		xErrorDetected = pdTRUE;
    20f4:	00800044 	movi	r2,1
    20f8:	d0a8d615 	stw	r2,-23720(gp)
	}

	/* We should be able to 'take' the semaphore countMAX_COUNT_VALUE times. */
	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
    20fc:	e03ffd15 	stw	zero,-12(fp)
    2100:	00001106 	br	2148 <prvDecrementSemaphoreCount+0x88>
	{
		if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) != pdPASS )
    2104:	e13ffe17 	ldw	r4,-8(fp)
    2108:	000b883a 	mov	r5,zero
    210c:	000d883a 	mov	r6,zero
    2110:	000f883a 	mov	r7,zero
    2114:	000ebd80 	call	ebd8 <xQueueGenericReceive>
    2118:	10800060 	cmpeqi	r2,r2,1
    211c:	1000021e 	bne	r2,zero,2128 <prvDecrementSemaphoreCount+0x68>
		{
			/* We expected to be able to take the semaphore. */
			xErrorDetected = pdTRUE;
    2120:	00800044 	movi	r2,1
    2124:	d0a8d615 	stw	r2,-23720(gp)
		}

		( *puxLoopCounter )++;
    2128:	e0bfff17 	ldw	r2,-4(fp)
    212c:	10800017 	ldw	r2,0(r2)
    2130:	10c00044 	addi	r3,r2,1
    2134:	e0bfff17 	ldw	r2,-4(fp)
    2138:	10c00015 	stw	r3,0(r2)
	{
		xErrorDetected = pdTRUE;
	}

	/* We should be able to 'take' the semaphore countMAX_COUNT_VALUE times. */
	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
    213c:	e0bffd17 	ldw	r2,-12(fp)
    2140:	10800044 	addi	r2,r2,1
    2144:	e0bffd15 	stw	r2,-12(fp)
    2148:	e0bffd17 	ldw	r2,-12(fp)
    214c:	10803230 	cmpltui	r2,r2,200
    2150:	103fec1e 	bne	r2,zero,2104 <prvDecrementSemaphoreCount+0x44>
		taskYIELD();
	#endif

	/* If the semaphore count is zero then we should not be able to	'take' 
	the semaphore. */
	if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) == pdPASS )
    2154:	e13ffe17 	ldw	r4,-8(fp)
    2158:	000b883a 	mov	r5,zero
    215c:	000d883a 	mov	r6,zero
    2160:	000f883a 	mov	r7,zero
    2164:	000ebd80 	call	ebd8 <xQueueGenericReceive>
    2168:	10800058 	cmpnei	r2,r2,1
    216c:	1000021e 	bne	r2,zero,2178 <prvDecrementSemaphoreCount+0xb8>
	{
		xErrorDetected = pdTRUE;
    2170:	00800044 	movi	r2,1
    2174:	d0a8d615 	stw	r2,-23720(gp)
	}
}
    2178:	e037883a 	mov	sp,fp
    217c:	dfc00117 	ldw	ra,4(sp)
    2180:	df000017 	ldw	fp,0(sp)
    2184:	dec00204 	addi	sp,sp,8
    2188:	f800283a 	ret

0000218c <prvIncrementSemaphoreCount>:
/*-----------------------------------------------------------*/

static void prvIncrementSemaphoreCount( xSemaphoreHandle xSemaphore, unsigned portBASE_TYPE *puxLoopCounter )
{
    218c:	defffb04 	addi	sp,sp,-20
    2190:	dfc00415 	stw	ra,16(sp)
    2194:	df000315 	stw	fp,12(sp)
    2198:	df000304 	addi	fp,sp,12
    219c:	e13ffe15 	stw	r4,-8(fp)
    21a0:	e17fff15 	stw	r5,-4(fp)
unsigned portBASE_TYPE ux;

	/* If the semaphore count is zero then we should not be able to	'take' 
	the semaphore. */
	if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) == pdPASS )
    21a4:	e13ffe17 	ldw	r4,-8(fp)
    21a8:	000b883a 	mov	r5,zero
    21ac:	000d883a 	mov	r6,zero
    21b0:	000f883a 	mov	r7,zero
    21b4:	000ebd80 	call	ebd8 <xQueueGenericReceive>
    21b8:	10800058 	cmpnei	r2,r2,1
    21bc:	1000021e 	bne	r2,zero,21c8 <prvIncrementSemaphoreCount+0x3c>
	{
		xErrorDetected = pdTRUE;
    21c0:	00800044 	movi	r2,1
    21c4:	d0a8d615 	stw	r2,-23720(gp)
	}

	/* We should be able to 'give' the semaphore countMAX_COUNT_VALUE times. */
	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
    21c8:	e03ffd15 	stw	zero,-12(fp)
    21cc:	00001106 	br	2214 <prvIncrementSemaphoreCount+0x88>
	{
		if( xSemaphoreGive( xSemaphore ) != pdPASS )
    21d0:	e13ffe17 	ldw	r4,-8(fp)
    21d4:	000b883a 	mov	r5,zero
    21d8:	000d883a 	mov	r6,zero
    21dc:	000f883a 	mov	r7,zero
    21e0:	000e95c0 	call	e95c <xQueueGenericSend>
    21e4:	10800060 	cmpeqi	r2,r2,1
    21e8:	1000021e 	bne	r2,zero,21f4 <prvIncrementSemaphoreCount+0x68>
		{
			/* We expected to be able to take the semaphore. */
			xErrorDetected = pdTRUE;
    21ec:	00800044 	movi	r2,1
    21f0:	d0a8d615 	stw	r2,-23720(gp)
		}

		( *puxLoopCounter )++;
    21f4:	e0bfff17 	ldw	r2,-4(fp)
    21f8:	10800017 	ldw	r2,0(r2)
    21fc:	10c00044 	addi	r3,r2,1
    2200:	e0bfff17 	ldw	r2,-4(fp)
    2204:	10c00015 	stw	r3,0(r2)
	{
		xErrorDetected = pdTRUE;
	}

	/* We should be able to 'give' the semaphore countMAX_COUNT_VALUE times. */
	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
    2208:	e0bffd17 	ldw	r2,-12(fp)
    220c:	10800044 	addi	r2,r2,1
    2210:	e0bffd15 	stw	r2,-12(fp)
    2214:	e0bffd17 	ldw	r2,-12(fp)
    2218:	10803230 	cmpltui	r2,r2,200
    221c:	103fec1e 	bne	r2,zero,21d0 <prvIncrementSemaphoreCount+0x44>
		taskYIELD();
	#endif

	/* If the semaphore count is at its maximum then we should not be able to
	'give' the semaphore. */
	if( xSemaphoreGive( xSemaphore ) == pdPASS )
    2220:	e13ffe17 	ldw	r4,-8(fp)
    2224:	000b883a 	mov	r5,zero
    2228:	000d883a 	mov	r6,zero
    222c:	000f883a 	mov	r7,zero
    2230:	000e95c0 	call	e95c <xQueueGenericSend>
    2234:	10800058 	cmpnei	r2,r2,1
    2238:	1000021e 	bne	r2,zero,2244 <prvIncrementSemaphoreCount+0xb8>
	{
		xErrorDetected = pdTRUE;
    223c:	00800044 	movi	r2,1
    2240:	d0a8d615 	stw	r2,-23720(gp)
	}
}
    2244:	e037883a 	mov	sp,fp
    2248:	dfc00117 	ldw	ra,4(sp)
    224c:	df000017 	ldw	fp,0(sp)
    2250:	dec00204 	addi	sp,sp,8
    2254:	f800283a 	ret

00002258 <prvCountingSemaphoreTask>:
/*-----------------------------------------------------------*/

static void prvCountingSemaphoreTask( void *pvParameters )
{
    2258:	defffc04 	addi	sp,sp,-16
    225c:	dfc00315 	stw	ra,12(sp)
    2260:	df000215 	stw	fp,8(sp)
    2264:	df000204 	addi	fp,sp,8
    2268:	e13fff15 	stw	r4,-4(fp)
		/* Queue a message for printing to say the task has started. */
		vPrintDisplayMessage( &pcTaskStartMsg );
	#endif

	/* The semaphore to be used was passed as the parameter. */
	pxParameter = ( xCountSemStruct * ) pvParameters;
    226c:	e0bfff17 	ldw	r2,-4(fp)
    2270:	e0bffe15 	stw	r2,-8(fp)

	/* Did we expect to find the semaphore already at its max count value, or
	at zero? */
	if( pxParameter->uxExpectedStartCount == countSTART_AT_MAX_COUNT )
    2274:	e0bffe17 	ldw	r2,-8(fp)
    2278:	10800117 	ldw	r2,4(r2)
    227c:	10802a98 	cmpnei	r2,r2,170
    2280:	1000071e 	bne	r2,zero,22a0 <prvCountingSemaphoreTask+0x48>
	{
		prvDecrementSemaphoreCount( pxParameter->xSemaphore, &( pxParameter->uxLoopCounter ) );
    2284:	e0bffe17 	ldw	r2,-8(fp)
    2288:	10c00017 	ldw	r3,0(r2)
    228c:	e0bffe17 	ldw	r2,-8(fp)
    2290:	10800204 	addi	r2,r2,8
    2294:	1809883a 	mov	r4,r3
    2298:	100b883a 	mov	r5,r2
    229c:	00020c00 	call	20c0 <prvDecrementSemaphoreCount>
	}

	/* Now we expect the semaphore count to be 0, so this time there is an
	error if we can take the semaphore. */
	if( xSemaphoreTake( pxParameter->xSemaphore, 0 ) == pdPASS )
    22a0:	e0bffe17 	ldw	r2,-8(fp)
    22a4:	10800017 	ldw	r2,0(r2)
    22a8:	1009883a 	mov	r4,r2
    22ac:	000b883a 	mov	r5,zero
    22b0:	000d883a 	mov	r6,zero
    22b4:	000f883a 	mov	r7,zero
    22b8:	000ebd80 	call	ebd8 <xQueueGenericReceive>
    22bc:	10800058 	cmpnei	r2,r2,1
    22c0:	1000021e 	bne	r2,zero,22cc <prvCountingSemaphoreTask+0x74>
	{
		xErrorDetected = pdTRUE;
    22c4:	00800044 	movi	r2,1
    22c8:	d0a8d615 	stw	r2,-23720(gp)
	}

	for( ;; )
	{
		prvIncrementSemaphoreCount( pxParameter->xSemaphore, &( pxParameter->uxLoopCounter ) );
    22cc:	e0bffe17 	ldw	r2,-8(fp)
    22d0:	10c00017 	ldw	r3,0(r2)
    22d4:	e0bffe17 	ldw	r2,-8(fp)
    22d8:	10800204 	addi	r2,r2,8
    22dc:	1809883a 	mov	r4,r3
    22e0:	100b883a 	mov	r5,r2
    22e4:	000218c0 	call	218c <prvIncrementSemaphoreCount>
		prvDecrementSemaphoreCount( pxParameter->xSemaphore, &( pxParameter->uxLoopCounter ) );
    22e8:	e0bffe17 	ldw	r2,-8(fp)
    22ec:	10c00017 	ldw	r3,0(r2)
    22f0:	e0bffe17 	ldw	r2,-8(fp)
    22f4:	10800204 	addi	r2,r2,8
    22f8:	1809883a 	mov	r4,r3
    22fc:	100b883a 	mov	r5,r2
    2300:	00020c00 	call	20c0 <prvDecrementSemaphoreCount>
	}
    2304:	003ff106 	br	22cc <prvCountingSemaphoreTask+0x74>

00002308 <xAreCountingSemaphoreTasksStillRunning>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xAreCountingSemaphoreTasksStillRunning( void )
{
    2308:	defffe04 	addi	sp,sp,-8
    230c:	df000115 	stw	fp,4(sp)
    2310:	df000104 	addi	fp,sp,4
static unsigned portBASE_TYPE uxLastCount0 = 0, uxLastCount1 = 0;
portBASE_TYPE xReturn = pdPASS;
    2314:	00800044 	movi	r2,1
    2318:	e0bfff15 	stw	r2,-4(fp)

	/* Return fail if any 'give' or 'take' did not result in the expected
	behaviour. */
	if( xErrorDetected != pdFALSE )
    231c:	d0a8d617 	ldw	r2,-23720(gp)
    2320:	10000126 	beq	r2,zero,2328 <xAreCountingSemaphoreTasksStillRunning+0x20>
	{
		xReturn = pdFAIL;
    2324:	e03fff15 	stw	zero,-4(fp)
	}

	/* Return fail if either task is not still incrementing its loop counter. */
	if( uxLastCount0 == xParameters[ 0 ].uxLoopCounter )
    2328:	00800134 	movhi	r2,4
    232c:	109f0e04 	addi	r2,r2,31800
    2330:	10c00217 	ldw	r3,8(r2)
    2334:	d0a8d717 	ldw	r2,-23716(gp)
    2338:	1880021e 	bne	r3,r2,2344 <xAreCountingSemaphoreTasksStillRunning+0x3c>
	{
		xReturn = pdFAIL;
    233c:	e03fff15 	stw	zero,-4(fp)
    2340:	00000406 	br	2354 <xAreCountingSemaphoreTasksStillRunning+0x4c>
	}
	else
	{
		uxLastCount0 = xParameters[ 0 ].uxLoopCounter;
    2344:	00800134 	movhi	r2,4
    2348:	109f0e04 	addi	r2,r2,31800
    234c:	10800217 	ldw	r2,8(r2)
    2350:	d0a8d715 	stw	r2,-23716(gp)
	}

	if( uxLastCount1 == xParameters[ 1 ].uxLoopCounter )
    2354:	00800134 	movhi	r2,4
    2358:	109f0e04 	addi	r2,r2,31800
    235c:	10c00517 	ldw	r3,20(r2)
    2360:	d0a8d817 	ldw	r2,-23712(gp)
    2364:	1880021e 	bne	r3,r2,2370 <xAreCountingSemaphoreTasksStillRunning+0x68>
	{
		xReturn = pdFAIL;
    2368:	e03fff15 	stw	zero,-4(fp)
    236c:	00000406 	br	2380 <xAreCountingSemaphoreTasksStillRunning+0x78>
	}
	else
	{
		uxLastCount1 = xParameters[ 1 ].uxLoopCounter;
    2370:	00800134 	movhi	r2,4
    2374:	109f0e04 	addi	r2,r2,31800
    2378:	10800517 	ldw	r2,20(r2)
    237c:	d0a8d815 	stw	r2,-23712(gp)
	}

	return xReturn;
    2380:	e0bfff17 	ldw	r2,-4(fp)
}
    2384:	e037883a 	mov	sp,fp
    2388:	df000017 	ldw	fp,0(sp)
    238c:	dec00104 	addi	sp,sp,4
    2390:	f800283a 	ret

00002394 <vCreateSuicidalTasks>:
xTaskHandle xCreatedTask;

/*-----------------------------------------------------------*/

void vCreateSuicidalTasks( unsigned portBASE_TYPE uxPriority )
{
    2394:	defff804 	addi	sp,sp,-32
    2398:	dfc00715 	stw	ra,28(sp)
    239c:	df000615 	stw	fp,24(sp)
    23a0:	df000604 	addi	fp,sp,24
    23a4:	e13fff15 	stw	r4,-4(fp)
unsigned portBASE_TYPE *puxPriority;

	/* Create the Creator tasks - passing in as a parameter the priority at which
	the suicidal tasks should be created. */
	puxPriority = ( unsigned portBASE_TYPE * ) pvPortMalloc( sizeof( unsigned portBASE_TYPE ) );
    23a8:	01000104 	movi	r4,4
    23ac:	000e4980 	call	e498 <pvPortMalloc>
    23b0:	e0bffe15 	stw	r2,-8(fp)
	*puxPriority = uxPriority;
    23b4:	e0bffe17 	ldw	r2,-8(fp)
    23b8:	e0ffff17 	ldw	r3,-4(fp)
    23bc:	10c00015 	stw	r3,0(r2)

	xTaskCreate( vCreateTasks, ( signed char * ) "CREATOR", deathSTACK_SIZE, ( void * ) puxPriority, uxPriority, NULL );
    23c0:	e0bfff17 	ldw	r2,-4(fp)
    23c4:	d8800015 	stw	r2,0(sp)
    23c8:	d8000115 	stw	zero,4(sp)
    23cc:	d8000215 	stw	zero,8(sp)
    23d0:	d8000315 	stw	zero,12(sp)
    23d4:	01000034 	movhi	r4,0
    23d8:	21092c04 	addi	r4,r4,9392
    23dc:	01400134 	movhi	r5,4
    23e0:	297e6904 	addi	r5,r5,-1628
    23e4:	018ca504 	movi	r6,12948
    23e8:	e1fffe17 	ldw	r7,-8(fp)
    23ec:	000f5140 	call	f514 <xTaskGenericCreate>

	/* Record the number of tasks that are running now so we know if any of the
	suicidal tasks have failed to be killed. */
	uxTasksRunningAtStart = ( unsigned portBASE_TYPE ) uxTaskGetNumberOfTasks();
    23f0:	00100e00 	call	100e0 <uxTaskGetNumberOfTasks>
    23f4:	d0a8da15 	stw	r2,-23704(gp)
	/* FreeRTOS.org versions before V3.0 started the idle-task as the very
	first task. The idle task was then already included in uxTasksRunningAtStart.
	From FreeRTOS V3.0 on, the idle task is started when the scheduler is
	started. Therefore the idle task is not yet accounted for. We correct
	this by increasing uxTasksRunningAtStart by 1. */
	uxTasksRunningAtStart++;
    23f8:	d0a8da17 	ldw	r2,-23704(gp)
    23fc:	10800044 	addi	r2,r2,1
    2400:	d0a8da15 	stw	r2,-23704(gp)
	
	/* From FreeRTOS version 7.0.0 can optionally create a timer service task.  
	If this is done, then uxTasksRunningAtStart needs incrementing again as that
	too is created when the scheduler is started. */
	#if configUSE_TIMERS == 1
		uxTasksRunningAtStart++;
    2404:	d0a8da17 	ldw	r2,-23704(gp)
    2408:	10800044 	addi	r2,r2,1
    240c:	d0a8da15 	stw	r2,-23704(gp)
	#endif
}
    2410:	e037883a 	mov	sp,fp
    2414:	dfc00117 	ldw	ra,4(sp)
    2418:	df000017 	ldw	fp,0(sp)
    241c:	dec00204 	addi	sp,sp,8
    2420:	f800283a 	ret

00002424 <vSuicidalTask>:
/*-----------------------------------------------------------*/
					
static portTASK_FUNCTION( vSuicidalTask, pvParameters )
{
    2424:	defff904 	addi	sp,sp,-28
    2428:	dfc00615 	stw	ra,24(sp)
    242c:	df000515 	stw	fp,20(sp)
    2430:	df000504 	addi	fp,sp,20
    2434:	e13fff15 	stw	r4,-4(fp)
volatile long l1, l2;
xTaskHandle xTaskToKill;
const portTickType xDelay = ( portTickType ) 200 / portTICK_RATE_MS;
    2438:	00803204 	movi	r2,200
    243c:	e0bffc15 	stw	r2,-16(fp)

	if( pvParameters != NULL )
    2440:	e0bfff17 	ldw	r2,-4(fp)
    2444:	10000426 	beq	r2,zero,2458 <vSuicidalTask+0x34>
	{
		/* This task is periodically created four times.  Two created tasks are
		passed a handle to the other task so it can kill it before killing itself.
		The other task is passed in null. */
		xTaskToKill = *( xTaskHandle* )pvParameters;
    2448:	e0bfff17 	ldw	r2,-4(fp)
    244c:	10800017 	ldw	r2,0(r2)
    2450:	e0bffb15 	stw	r2,-20(fp)
    2454:	00000306 	br	2464 <vSuicidalTask+0x40>
	}
	else
	{
		xTaskToKill = NULL;
    2458:	e03ffb15 	stw	zero,-20(fp)
    245c:	00000106 	br	2464 <vSuicidalTask+0x40>
			vTaskDelete( xTaskToKill );

			/* Kill ourselves. */
			vTaskDelete( NULL );
		}
	}
    2460:	0001883a 	nop
	}

	for( ;; )
	{
		/* Do something random just to use some stack and registers. */
		l1 = 2;
    2464:	00800084 	movi	r2,2
    2468:	e0bffd15 	stw	r2,-12(fp)
		l2 = 89;
    246c:	00801644 	movi	r2,89
    2470:	e0bffe15 	stw	r2,-8(fp)
		l2 *= l1;
    2474:	e0fffe17 	ldw	r3,-8(fp)
    2478:	e0bffd17 	ldw	r2,-12(fp)
    247c:	1885383a 	mul	r2,r3,r2
    2480:	e0bffe15 	stw	r2,-8(fp)
		vTaskDelay( xDelay );
    2484:	e13ffc17 	ldw	r4,-16(fp)
    2488:	000f8c00 	call	f8c0 <vTaskDelay>

		if( xTaskToKill != NULL )
    248c:	e0bffb17 	ldw	r2,-20(fp)
    2490:	103ff326 	beq	r2,zero,2460 <vSuicidalTask+0x3c>
		{
			/* Make sure the other task has a go before we delete it. */
			vTaskDelay( ( portTickType ) 0 );
    2494:	0009883a 	mov	r4,zero
    2498:	000f8c00 	call	f8c0 <vTaskDelay>

			/* Kill the other task that was created by vCreateTasks(). */
			vTaskDelete( xTaskToKill );
    249c:	e13ffb17 	ldw	r4,-20(fp)
    24a0:	000f7040 	call	f704 <vTaskDelete>

			/* Kill ourselves. */
			vTaskDelete( NULL );
    24a4:	0009883a 	mov	r4,zero
    24a8:	000f7040 	call	f704 <vTaskDelete>
		}
	}
    24ac:	003fec06 	br	2460 <vSuicidalTask+0x3c>

000024b0 <vCreateTasks>:
}/*lint !e818 !e550 Function prototype must be as per standard for task functions. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCreateTasks, pvParameters )
{
    24b0:	defff704 	addi	sp,sp,-36
    24b4:	dfc00815 	stw	ra,32(sp)
    24b8:	df000715 	stw	fp,28(sp)
    24bc:	df000704 	addi	fp,sp,28
    24c0:	e13fff15 	stw	r4,-4(fp)
const portTickType xDelay = ( portTickType ) 1000 / portTICK_RATE_MS;
    24c4:	0080fa04 	movi	r2,1000
    24c8:	e0bffd15 	stw	r2,-12(fp)
unsigned portBASE_TYPE uxPriority;

	uxPriority = *( unsigned portBASE_TYPE * ) pvParameters;
    24cc:	e0bfff17 	ldw	r2,-4(fp)
    24d0:	10800017 	ldw	r2,0(r2)
    24d4:	e0bffe15 	stw	r2,-8(fp)
	vPortFree( pvParameters );
    24d8:	e13fff17 	ldw	r4,-4(fp)
    24dc:	000e4d80 	call	e4d8 <vPortFree>

	for( ;; )
	{
		/* Just loop round, delaying then creating the four suicidal tasks. */
		vTaskDelay( xDelay );
    24e0:	e13ffd17 	ldw	r4,-12(fp)
    24e4:	000f8c00 	call	f8c0 <vTaskDelay>

		xCreatedTask = NULL;
    24e8:	d028dc15 	stw	zero,-23696(gp)

		xTaskCreate( vSuicidalTask, ( signed char * ) "SUICID1", configMINIMAL_STACK_SIZE, NULL, uxPriority, &xCreatedTask );
    24ec:	e0bffe17 	ldw	r2,-8(fp)
    24f0:	d8800015 	stw	r2,0(sp)
    24f4:	d0a8dc04 	addi	r2,gp,-23696
    24f8:	d8800115 	stw	r2,4(sp)
    24fc:	d8000215 	stw	zero,8(sp)
    2500:	d8000315 	stw	zero,12(sp)
    2504:	01000034 	movhi	r4,0
    2508:	21090904 	addi	r4,r4,9252
    250c:	01400134 	movhi	r5,4
    2510:	297e6b04 	addi	r5,r5,-1620
    2514:	018c9604 	movi	r6,12888
    2518:	000f883a 	mov	r7,zero
    251c:	000f5140 	call	f514 <xTaskGenericCreate>
		xTaskCreate( vSuicidalTask, ( signed char * ) "SUICID2", configMINIMAL_STACK_SIZE, &xCreatedTask, uxPriority, NULL );
    2520:	e0bffe17 	ldw	r2,-8(fp)
    2524:	d8800015 	stw	r2,0(sp)
    2528:	d8000115 	stw	zero,4(sp)
    252c:	d8000215 	stw	zero,8(sp)
    2530:	d8000315 	stw	zero,12(sp)
    2534:	01000034 	movhi	r4,0
    2538:	21090904 	addi	r4,r4,9252
    253c:	01400134 	movhi	r5,4
    2540:	297e6d04 	addi	r5,r5,-1612
    2544:	018c9604 	movi	r6,12888
    2548:	d1e8dc04 	addi	r7,gp,-23696
    254c:	000f5140 	call	f514 <xTaskGenericCreate>

		++usCreationCount;
    2550:	d0a8d90b 	ldhu	r2,-23708(gp)
    2554:	10800044 	addi	r2,r2,1
    2558:	d0a8d90d 	sth	r2,-23708(gp)
	}
    255c:	003fe006 	br	24e0 <vCreateTasks+0x30>

00002560 <xIsCreateTaskStillRunning>:
/*-----------------------------------------------------------*/

/* This is called to check that the creator task is still running and that there
are not any more than four extra tasks. */
portBASE_TYPE xIsCreateTaskStillRunning( void )
{
    2560:	defffd04 	addi	sp,sp,-12
    2564:	dfc00215 	stw	ra,8(sp)
    2568:	df000115 	stw	fp,4(sp)
    256c:	df000104 	addi	fp,sp,4
static unsigned short usLastCreationCount = 0xfff;
portBASE_TYPE xReturn = pdTRUE;
    2570:	00800044 	movi	r2,1
    2574:	e0bfff15 	stw	r2,-4(fp)
static unsigned portBASE_TYPE uxTasksRunningNow;

	if( usLastCreationCount == usCreationCount )
    2578:	d0e0010b 	ldhu	r3,-32764(gp)
    257c:	d0a8d90b 	ldhu	r2,-23708(gp)
    2580:	18ffffcc 	andi	r3,r3,65535
    2584:	10bfffcc 	andi	r2,r2,65535
    2588:	1880021e 	bne	r3,r2,2594 <xIsCreateTaskStillRunning+0x34>
	{
		xReturn = pdFALSE;
    258c:	e03fff15 	stw	zero,-4(fp)
    2590:	00000206 	br	259c <xIsCreateTaskStillRunning+0x3c>
	}
	else
	{
		usLastCreationCount = usCreationCount;
    2594:	d0a8d90b 	ldhu	r2,-23708(gp)
    2598:	d0a0010d 	sth	r2,-32764(gp)
	}
	
	uxTasksRunningNow = ( unsigned portBASE_TYPE ) uxTaskGetNumberOfTasks();
    259c:	00100e00 	call	100e0 <uxTaskGetNumberOfTasks>
    25a0:	d0a8db15 	stw	r2,-23700(gp)

	if( uxTasksRunningNow < uxTasksRunningAtStart )
    25a4:	d0e8db17 	ldw	r3,-23700(gp)
    25a8:	d0a8da17 	ldw	r2,-23704(gp)
    25ac:	1880022e 	bgeu	r3,r2,25b8 <xIsCreateTaskStillRunning+0x58>
	{
		xReturn = pdFALSE;
    25b0:	e03fff15 	stw	zero,-4(fp)
    25b4:	00000606 	br	25d0 <xIsCreateTaskStillRunning+0x70>
	}
	else if( ( uxTasksRunningNow - uxTasksRunningAtStart ) > uxMaxNumberOfExtraTasksRunning )
    25b8:	d0e8db17 	ldw	r3,-23700(gp)
    25bc:	d0a8da17 	ldw	r2,-23704(gp)
    25c0:	1885c83a 	sub	r2,r3,r2
    25c4:	d0e00017 	ldw	r3,-32768(gp)
    25c8:	1880012e 	bgeu	r3,r2,25d0 <xIsCreateTaskStillRunning+0x70>
	{
		xReturn = pdFALSE;
    25cc:	e03fff15 	stw	zero,-4(fp)
	else
	{
		/* Everything is okay. */
	}

	return xReturn;
    25d0:	e0bfff17 	ldw	r2,-4(fp)
}
    25d4:	e037883a 	mov	sp,fp
    25d8:	dfc00117 	ldw	ra,4(sp)
    25dc:	df000017 	ldw	fp,0(sp)
    25e0:	dec00204 	addi	sp,sp,8
    25e4:	f800283a 	ret

000025e8 <vStartDynamicPriorityTasks>:
/*
 * Start the three tasks as described at the top of the file.
 * Note that the limited count task is given a higher priority.
 */
void vStartDynamicPriorityTasks( void )
{
    25e8:	defffa04 	addi	sp,sp,-24
    25ec:	dfc00515 	stw	ra,20(sp)
    25f0:	df000415 	stw	fp,16(sp)
    25f4:	df000404 	addi	fp,sp,16
	xSuspendedTestQueue = xQueueCreate( priSUSPENDED_QUEUE_LENGTH, sizeof( unsigned long ) );
    25f8:	01000044 	movi	r4,1
    25fc:	01400104 	movi	r5,4
    2600:	000d883a 	mov	r6,zero
    2604:	000e6380 	call	e638 <xQueueGenericCreate>
    2608:	d0a8e715 	stw	r2,-23652(gp)
	is not being used.  The call to vQueueAddToRegistry() will be removed
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( xSuspendedTestQueue, ( signed char * ) "Suspended_Test_Queue" );

	xTaskCreate( vContinuousIncrementTask, ( signed char * ) "CNT_INC", priSTACK_SIZE, ( void * ) &ulCounter, tskIDLE_PRIORITY, &xContinousIncrementHandle );
    260c:	d8000015 	stw	zero,0(sp)
    2610:	d0a8dd04 	addi	r2,gp,-23692
    2614:	d8800115 	stw	r2,4(sp)
    2618:	d8000215 	stw	zero,8(sp)
    261c:	d8000315 	stw	zero,12(sp)
    2620:	01000034 	movhi	r4,0
    2624:	2109d904 	addi	r4,r4,10084
    2628:	01400134 	movhi	r5,4
    262c:	297e6f04 	addi	r5,r5,-1604
    2630:	018c9604 	movi	r6,12888
    2634:	d1e8df04 	addi	r7,gp,-23684
    2638:	000f5140 	call	f514 <xTaskGenericCreate>
	xTaskCreate( vLimitedIncrementTask, ( signed char * ) "LIM_INC", priSTACK_SIZE, ( void * ) &ulCounter, tskIDLE_PRIORITY + 1, &xLimitedIncrementHandle );
    263c:	00800044 	movi	r2,1
    2640:	d8800015 	stw	r2,0(sp)
    2644:	d0a8de04 	addi	r2,gp,-23688
    2648:	d8800115 	stw	r2,4(sp)
    264c:	d8000215 	stw	zero,8(sp)
    2650:	d8000315 	stw	zero,12(sp)
    2654:	01000034 	movhi	r4,0
    2658:	2109c204 	addi	r4,r4,9992
    265c:	01400134 	movhi	r5,4
    2660:	297e7104 	addi	r5,r5,-1596
    2664:	018c9604 	movi	r6,12888
    2668:	d1e8df04 	addi	r7,gp,-23684
    266c:	000f5140 	call	f514 <xTaskGenericCreate>
	xTaskCreate( vCounterControlTask, ( signed char * ) "C_CTRL", priSTACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
    2670:	d8000015 	stw	zero,0(sp)
    2674:	d8000115 	stw	zero,4(sp)
    2678:	d8000215 	stw	zero,8(sp)
    267c:	d8000315 	stw	zero,12(sp)
    2680:	01000034 	movhi	r4,0
    2684:	2109f104 	addi	r4,r4,10180
    2688:	01400134 	movhi	r5,4
    268c:	297e7304 	addi	r5,r5,-1588
    2690:	018c9604 	movi	r6,12888
    2694:	000f883a 	mov	r7,zero
    2698:	000f5140 	call	f514 <xTaskGenericCreate>
	xTaskCreate( vQueueSendWhenSuspendedTask, ( signed char * ) "SUSP_TX", priSTACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
    269c:	d8000015 	stw	zero,0(sp)
    26a0:	d8000115 	stw	zero,4(sp)
    26a4:	d8000215 	stw	zero,8(sp)
    26a8:	d8000315 	stw	zero,12(sp)
    26ac:	01000034 	movhi	r4,0
    26b0:	210a2c04 	addi	r4,r4,10416
    26b4:	01400134 	movhi	r5,4
    26b8:	297e7504 	addi	r5,r5,-1580
    26bc:	018c9604 	movi	r6,12888
    26c0:	000f883a 	mov	r7,zero
    26c4:	000f5140 	call	f514 <xTaskGenericCreate>
	xTaskCreate( vQueueReceiveWhenSuspendedTask, ( signed char * ) "SUSP_RX", priSTACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
    26c8:	d8000015 	stw	zero,0(sp)
    26cc:	d8000115 	stw	zero,4(sp)
    26d0:	d8000215 	stw	zero,8(sp)
    26d4:	d8000315 	stw	zero,12(sp)
    26d8:	01000034 	movhi	r4,0
    26dc:	210a4304 	addi	r4,r4,10508
    26e0:	01400134 	movhi	r5,4
    26e4:	297e7704 	addi	r5,r5,-1572
    26e8:	018c9604 	movi	r6,12888
    26ec:	000f883a 	mov	r7,zero
    26f0:	000f5140 	call	f514 <xTaskGenericCreate>
}
    26f4:	e037883a 	mov	sp,fp
    26f8:	dfc00117 	ldw	ra,4(sp)
    26fc:	df000017 	ldw	fp,0(sp)
    2700:	dec00204 	addi	sp,sp,8
    2704:	f800283a 	ret

00002708 <vLimitedIncrementTask>:
/*
 * Just loops around incrementing the shared variable until the limit has been
 * reached.  Once the limit has been reached it suspends itself. 
 */
static portTASK_FUNCTION( vLimitedIncrementTask, pvParameters )
{
    2708:	defffc04 	addi	sp,sp,-16
    270c:	dfc00315 	stw	ra,12(sp)
    2710:	df000215 	stw	fp,8(sp)
    2714:	df000204 	addi	fp,sp,8
    2718:	e13fff15 	stw	r4,-4(fp)
unsigned long *pulCounter;

	/* Take a pointer to the shared variable from the parameters passed into
	the task. */
	pulCounter = ( unsigned long * ) pvParameters;
    271c:	e0bfff17 	ldw	r2,-4(fp)
    2720:	e0bffe15 	stw	r2,-8(fp)

	/* This will run before the control task, so the first thing it does is
	suspend - the control task will resume it when ready. */
	vTaskSuspend( NULL );
    2724:	0009883a 	mov	r4,zero
    2728:	000fb300 	call	fb30 <vTaskSuspend>
    272c:	00000106 	br	2734 <vLimitedIncrementTask+0x2c>
		
		if( *pulCounter >= priMAX_COUNT )
		{
			vTaskSuspend( NULL );
		} 	
	}
    2730:	0001883a 	nop
	vTaskSuspend( NULL );

	for( ;; )
	{
		/* Just count up to a value then suspend. */
		( *pulCounter )++;	
    2734:	e0bffe17 	ldw	r2,-8(fp)
    2738:	10800017 	ldw	r2,0(r2)
    273c:	10c00044 	addi	r3,r2,1
    2740:	e0bffe17 	ldw	r2,-8(fp)
    2744:	10c00015 	stw	r3,0(r2)
		
		if( *pulCounter >= priMAX_COUNT )
    2748:	e0bffe17 	ldw	r2,-8(fp)
    274c:	10800017 	ldw	r2,0(r2)
    2750:	10803ff0 	cmpltui	r2,r2,255
    2754:	103ff61e 	bne	r2,zero,2730 <vLimitedIncrementTask+0x28>
		{
			vTaskSuspend( NULL );
    2758:	0009883a 	mov	r4,zero
    275c:	000fb300 	call	fb30 <vTaskSuspend>
		} 	
	}
    2760:	003ff306 	br	2730 <vLimitedIncrementTask+0x28>

00002764 <vContinuousIncrementTask>:
/*
 * Just keep counting the shared variable up.  The control task will suspend
 * this task when it wants.
 */
static portTASK_FUNCTION( vContinuousIncrementTask, pvParameters )
{
    2764:	defffb04 	addi	sp,sp,-20
    2768:	dfc00415 	stw	ra,16(sp)
    276c:	df000315 	stw	fp,12(sp)
    2770:	df000304 	addi	fp,sp,12
    2774:	e13fff15 	stw	r4,-4(fp)
unsigned long *pulCounter;
unsigned portBASE_TYPE uxOurPriority;

	/* Take a pointer to the shared variable from the parameters passed into
	the task. */
	pulCounter = ( unsigned long * ) pvParameters;
    2778:	e0bfff17 	ldw	r2,-4(fp)
    277c:	e0bffd15 	stw	r2,-12(fp)

	/* Query our priority so we can raise it when exclusive access to the 
	shared variable is required. */
	uxOurPriority = uxTaskPriorityGet( NULL );
    2780:	0009883a 	mov	r4,zero
    2784:	000f9340 	call	f934 <uxTaskPriorityGet>
    2788:	e0bffe15 	stw	r2,-8(fp)

	for( ;; )
	{
		/* Raise our priority above the controller task to ensure a context
		switch does not occur while we are accessing this variable. */
		vTaskPrioritySet( NULL, uxOurPriority + 1 );
    278c:	e0bffe17 	ldw	r2,-8(fp)
    2790:	10800044 	addi	r2,r2,1
    2794:	0009883a 	mov	r4,zero
    2798:	100b883a 	mov	r5,r2
    279c:	000f99c0 	call	f99c <vTaskPrioritySet>
			( *pulCounter )++;		
    27a0:	e0bffd17 	ldw	r2,-12(fp)
    27a4:	10800017 	ldw	r2,0(r2)
    27a8:	10c00044 	addi	r3,r2,1
    27ac:	e0bffd17 	ldw	r2,-12(fp)
    27b0:	10c00015 	stw	r3,0(r2)
		vTaskPrioritySet( NULL, uxOurPriority );
    27b4:	0009883a 	mov	r4,zero
    27b8:	e17ffe17 	ldw	r5,-8(fp)
    27bc:	000f99c0 	call	f99c <vTaskPrioritySet>
	}
    27c0:	003ff206 	br	278c <vContinuousIncrementTask+0x28>

000027c4 <vCounterControlTask>:

/*
 * Controller task as described above.
 */
static portTASK_FUNCTION( vCounterControlTask, pvParameters )
{
    27c4:	defffb04 	addi	sp,sp,-20
    27c8:	dfc00415 	stw	ra,16(sp)
    27cc:	df000315 	stw	fp,12(sp)
    27d0:	df000304 	addi	fp,sp,12
    27d4:	e13fff15 	stw	r4,-4(fp)
unsigned long ulLastCounter;
short sLoops;
short sError = pdFALSE;
    27d8:	e03ffd8d 	sth	zero,-10(fp)
	( void ) pvParameters;

	for( ;; )
	{
		/* Start with the counter at zero. */
		ulCounter = ( unsigned long ) 0;
    27dc:	d028df15 	stw	zero,-23684(gp)

		/* First section : */

		/* Check the continuous count task is running. */
		for( sLoops = 0; sLoops < priLOOPS; sLoops++ )
    27e0:	e03ffd0d 	sth	zero,-12(fp)
    27e4:	00001406 	br	2838 <vCounterControlTask+0x74>
		{
			/* Suspend the continuous count task so we can take a mirror of the
			shared variable without risk of corruption. */
			vTaskSuspend( xContinousIncrementHandle );
    27e8:	d0a8dd17 	ldw	r2,-23692(gp)
    27ec:	1009883a 	mov	r4,r2
    27f0:	000fb300 	call	fb30 <vTaskSuspend>
				ulLastCounter = ulCounter;
    27f4:	d0a8df17 	ldw	r2,-23684(gp)
    27f8:	e0bffe15 	stw	r2,-8(fp)
			vTaskResume( xContinousIncrementHandle );
    27fc:	d0a8dd17 	ldw	r2,-23692(gp)
    2800:	1009883a 	mov	r4,r2
    2804:	000fc800 	call	fc80 <vTaskResume>
			
			/* Now delay to ensure the other task has processor time. */
			vTaskDelay( priSLEEP_TIME );
    2808:	01002004 	movi	r4,128
    280c:	000f8c00 	call	f8c0 <vTaskDelay>

			/* Check the shared variable again.  This time to ensure mutual 
			exclusion the whole scheduler will be locked.  This is just for
			demo purposes! */
			vTaskSuspendAll();
    2810:	000fef80 	call	fef8 <vTaskSuspendAll>
			{
				if( ulLastCounter == ulCounter )
    2814:	d0a8df17 	ldw	r2,-23684(gp)
    2818:	e0fffe17 	ldw	r3,-8(fp)
    281c:	1880021e 	bne	r3,r2,2828 <vCounterControlTask+0x64>
				{
					/* The shared variable has not changed.  There is a problem
					with the continuous count task so flag an error. */
					sError = pdTRUE;
    2820:	00800044 	movi	r2,1
    2824:	e0bffd8d 	sth	r2,-10(fp)
				}
			}
			xTaskResumeAll();
    2828:	000ff200 	call	ff20 <xTaskResumeAll>
		ulCounter = ( unsigned long ) 0;

		/* First section : */

		/* Check the continuous count task is running. */
		for( sLoops = 0; sLoops < priLOOPS; sLoops++ )
    282c:	e0bffd0b 	ldhu	r2,-12(fp)
    2830:	10800044 	addi	r2,r2,1
    2834:	e0bffd0d 	sth	r2,-12(fp)
    2838:	e0bffd0f 	ldh	r2,-12(fp)
    283c:	10800150 	cmplti	r2,r2,5
    2840:	103fe91e 	bne	r2,zero,27e8 <vCounterControlTask+0x24>


		/* Second section: */

		/* Suspend the continuous counter task so it stops accessing the shared variable. */
		vTaskSuspend( xContinousIncrementHandle );
    2844:	d0a8dd17 	ldw	r2,-23692(gp)
    2848:	1009883a 	mov	r4,r2
    284c:	000fb300 	call	fb30 <vTaskSuspend>

		/* Reset the variable. */
		ulCounter = ( unsigned long ) 0;
    2850:	d028df15 	stw	zero,-23684(gp)

		/* Resume the limited count task which has a higher priority than us.
		We should therefore not return from this call until the limited count
		task has suspended itself with a known value in the counter variable. */
		vTaskResume( xLimitedIncrementHandle );
    2854:	d0a8de17 	ldw	r2,-23688(gp)
    2858:	1009883a 	mov	r4,r2
    285c:	000fc800 	call	fc80 <vTaskResume>

		/* Does the counter variable have the expected value? */
		if( ulCounter != priMAX_COUNT )
    2860:	d0a8df17 	ldw	r2,-23684(gp)
    2864:	10803fe0 	cmpeqi	r2,r2,255
    2868:	1000021e 	bne	r2,zero,2874 <vCounterControlTask+0xb0>
		{
			sError = pdTRUE;
    286c:	00800044 	movi	r2,1
    2870:	e0bffd8d 	sth	r2,-10(fp)
		}

		if( sError == pdFALSE )
    2874:	e0bffd8f 	ldh	r2,-10(fp)
    2878:	1000091e 	bne	r2,zero,28a0 <vCounterControlTask+0xdc>
		{
			/* If no errors have occurred then increment the check variable. */
			portENTER_CRITICAL();
    287c:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    2880:	10000126 	beq	r2,zero,2888 <vCounterControlTask+0xc4>
    2884:	00110d00 	call	110d0 <vTaskEnterCritical>
				usCheckVariable++;
    2888:	d0a8e00b 	ldhu	r2,-23680(gp)
    288c:	10800044 	addi	r2,r2,1
    2890:	d0a8e00d 	sth	r2,-23680(gp)
			portEXIT_CRITICAL();
    2894:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    2898:	10000126 	beq	r2,zero,28a0 <vCounterControlTask+0xdc>
    289c:	00111100 	call	11110 <vTaskExitCritical>
		}

		/* Resume the continuous count task and do it all again. */
		vTaskResume( xContinousIncrementHandle );
    28a0:	d0a8dd17 	ldw	r2,-23692(gp)
    28a4:	1009883a 	mov	r4,r2
    28a8:	000fc800 	call	fc80 <vTaskResume>
	}
    28ac:	003fcb06 	br	27dc <vCounterControlTask+0x18>

000028b0 <vQueueSendWhenSuspendedTask>:
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vQueueSendWhenSuspendedTask, pvParameters )
{
    28b0:	defffd04 	addi	sp,sp,-12
    28b4:	dfc00215 	stw	ra,8(sp)
    28b8:	df000115 	stw	fp,4(sp)
    28bc:	df000104 	addi	fp,sp,4
    28c0:	e13fff15 	stw	r4,-4(fp)
	/* Just to stop warning messages. */
	( void ) pvParameters;

	for( ;; )
	{
		vTaskSuspendAll();
    28c4:	000fef80 	call	fef8 <vTaskSuspendAll>
		{
			/* We must not block while the scheduler is suspended! */
			if( xQueueSend( xSuspendedTestQueue, ( void * ) &ulValueToSend, priNO_BLOCK ) != pdTRUE )
    28c8:	d0a8e717 	ldw	r2,-23652(gp)
    28cc:	1009883a 	mov	r4,r2
    28d0:	d168e604 	addi	r5,gp,-23656
    28d4:	000d883a 	mov	r6,zero
    28d8:	000f883a 	mov	r7,zero
    28dc:	000e95c0 	call	e95c <xQueueGenericSend>
    28e0:	10800060 	cmpeqi	r2,r2,1
    28e4:	1000021e 	bne	r2,zero,28f0 <vQueueSendWhenSuspendedTask+0x40>
			{
				xSuspendedQueueSendError = pdTRUE;
    28e8:	00800044 	movi	r2,1
    28ec:	d0a8e115 	stw	r2,-23676(gp)
			}
		}
		xTaskResumeAll();
    28f0:	000ff200 	call	ff20 <xTaskResumeAll>

		vTaskDelay( priSLEEP_TIME );
    28f4:	01002004 	movi	r4,128
    28f8:	000f8c00 	call	f8c0 <vTaskDelay>

		++ulValueToSend;
    28fc:	d0a8e617 	ldw	r2,-23656(gp)
    2900:	10800044 	addi	r2,r2,1
    2904:	d0a8e615 	stw	r2,-23656(gp)
	}
    2908:	003fee06 	br	28c4 <vQueueSendWhenSuspendedTask+0x14>

0000290c <vQueueReceiveWhenSuspendedTask>:
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vQueueReceiveWhenSuspendedTask, pvParameters )
{
    290c:	defffc04 	addi	sp,sp,-16
    2910:	dfc00315 	stw	ra,12(sp)
    2914:	df000215 	stw	fp,8(sp)
    2918:	df000204 	addi	fp,sp,8
    291c:	e13fff15 	stw	r4,-4(fp)
			/* Suspending the scheduler here is fairly pointless and 
			undesirable for a normal application.  It is done here purely
			to test the scheduler.  The inner xTaskResumeAll() should
			never return pdTRUE as the scheduler is still locked by the
			outer call. */
			vTaskSuspendAll();
    2920:	000fef80 	call	fef8 <vTaskSuspendAll>
			{
				vTaskSuspendAll();
    2924:	000fef80 	call	fef8 <vTaskSuspendAll>
				{
					xGotValue = xQueueReceive( xSuspendedTestQueue, ( void * ) &ulReceivedValue, priNO_BLOCK );
    2928:	d0a8e717 	ldw	r2,-23652(gp)
    292c:	1009883a 	mov	r4,r2
    2930:	d168e404 	addi	r5,gp,-23664
    2934:	000d883a 	mov	r6,zero
    2938:	000f883a 	mov	r7,zero
    293c:	000ebd80 	call	ebd8 <xQueueGenericReceive>
    2940:	e0bffe15 	stw	r2,-8(fp)
				}
				if( xTaskResumeAll() )
    2944:	000ff200 	call	ff20 <xTaskResumeAll>
    2948:	10000226 	beq	r2,zero,2954 <vQueueReceiveWhenSuspendedTask+0x48>
				{
					xSuspendedQueueReceiveError = pdTRUE;
    294c:	00800044 	movi	r2,1
    2950:	d0a8e215 	stw	r2,-23672(gp)
				}
			}
			xTaskResumeAll();
    2954:	000ff200 	call	ff20 <xTaskResumeAll>
			{
				taskYIELD();
			}
			#endif

		} while( xGotValue == pdFALSE );
    2958:	e0bffe17 	ldw	r2,-8(fp)
    295c:	103ff026 	beq	r2,zero,2920 <vQueueReceiveWhenSuspendedTask+0x14>

		if( ulReceivedValue != ulExpectedValue )
    2960:	d0e8e417 	ldw	r3,-23664(gp)
    2964:	d0a8e517 	ldw	r2,-23660(gp)
    2968:	18800226 	beq	r3,r2,2974 <vQueueReceiveWhenSuspendedTask+0x68>
		{
			xSuspendedQueueReceiveError = pdTRUE;
    296c:	00800044 	movi	r2,1
    2970:	d0a8e215 	stw	r2,-23672(gp)
		}

		++ulExpectedValue;
    2974:	d0a8e517 	ldw	r2,-23660(gp)
    2978:	10800044 	addi	r2,r2,1
    297c:	d0a8e515 	stw	r2,-23660(gp)
	}
    2980:	003fe706 	br	2920 <vQueueReceiveWhenSuspendedTask+0x14>

00002984 <xAreDynamicPriorityTasksStillRunning>:
}
/*-----------------------------------------------------------*/

/* Called to check that all the created tasks are still running without error. */
portBASE_TYPE xAreDynamicPriorityTasksStillRunning( void )
{
    2984:	defffe04 	addi	sp,sp,-8
    2988:	df000115 	stw	fp,4(sp)
    298c:	df000104 	addi	fp,sp,4
/* Keep a history of the check variables so we know if it has been incremented 
since the last call. */
static unsigned short usLastTaskCheck = ( unsigned short ) 0;
portBASE_TYPE xReturn = pdTRUE;
    2990:	00800044 	movi	r2,1
    2994:	e0bfff15 	stw	r2,-4(fp)

	/* Check the tasks are still running by ensuring the check variable
	is still incrementing. */

	if( usCheckVariable == usLastTaskCheck )
    2998:	d0e8e00b 	ldhu	r3,-23680(gp)
    299c:	d0a8e30b 	ldhu	r2,-23668(gp)
    29a0:	18ffffcc 	andi	r3,r3,65535
    29a4:	10bfffcc 	andi	r2,r2,65535
    29a8:	1880011e 	bne	r3,r2,29b0 <xAreDynamicPriorityTasksStillRunning+0x2c>
	{
		/* The check has not incremented so an error exists. */
		xReturn = pdFALSE;
    29ac:	e03fff15 	stw	zero,-4(fp)
	}

	if( xSuspendedQueueSendError == pdTRUE )
    29b0:	d0a8e117 	ldw	r2,-23676(gp)
    29b4:	10800058 	cmpnei	r2,r2,1
    29b8:	1000011e 	bne	r2,zero,29c0 <xAreDynamicPriorityTasksStillRunning+0x3c>
	{
		xReturn = pdFALSE;
    29bc:	e03fff15 	stw	zero,-4(fp)
	}

	if( xSuspendedQueueReceiveError == pdTRUE )
    29c0:	d0a8e217 	ldw	r2,-23672(gp)
    29c4:	10800058 	cmpnei	r2,r2,1
    29c8:	1000011e 	bne	r2,zero,29d0 <xAreDynamicPriorityTasksStillRunning+0x4c>
	{
		xReturn = pdFALSE;
    29cc:	e03fff15 	stw	zero,-4(fp)
	}

	usLastTaskCheck = usCheckVariable;
    29d0:	d0a8e00b 	ldhu	r2,-23680(gp)
    29d4:	d0a8e30d 	sth	r2,-23668(gp)
	return xReturn;
    29d8:	e0bfff17 	ldw	r2,-4(fp)
}
    29dc:	e037883a 	mov	sp,fp
    29e0:	df000017 	ldw	fp,0(sp)
    29e4:	dec00104 	addi	sp,sp,4
    29e8:	f800283a 	ret

000029ec <prvMySocketTest>:
#include <task.h>
#include <semphr.h>

#if LWIP_SOCKET == 1
void prvMySocketTest(__unused void *params)
{
    29ec:	defef104 	addi	sp,sp,-1084
    29f0:	dfc10e15 	stw	ra,1080(sp)
    29f4:	df010d15 	stw	fp,1076(sp)
    29f8:	df010d04 	addi	fp,sp,1076
    29fc:	e13fff15 	stw	r4,-4(fp)
	// create server socket stuff
	int lSocket;
	struct sockaddr_in sLocalAddr;

	printf("Starting socket test interface.\n");
    2a00:	01000134 	movhi	r4,4
    2a04:	213e7904 	addi	r4,r4,-1564
    2a08:	00045340 	call	4534 <puts>

	lSocket = socket(AF_INET, SOCK_STREAM, 0);
    2a0c:	01000084 	movi	r4,2
    2a10:	01400044 	movi	r5,1
    2a14:	000d883a 	mov	r6,zero
    2a18:	00173c80 	call	173c8 <lwip_socket>
    2a1c:	e0bef315 	stw	r2,-1076(fp)
	printf("socket returns %d\n", lSocket);
    2a20:	01000134 	movhi	r4,4
    2a24:	213e8104 	addi	r4,r4,-1532
    2a28:	e17ef317 	ldw	r5,-1076(fp)
    2a2c:	00044740 	call	4474 <printf>
	if (lSocket < 0) {
    2a30:	e0bef317 	ldw	r2,-1076(fp)
    2a34:	1000040e 	bge	r2,zero,2a48 <prvMySocketTest+0x5c>
		perror("socket");
    2a38:	01000134 	movhi	r4,4
    2a3c:	213e8604 	addi	r4,r4,-1512
    2a40:	00044340 	call	4434 <perror>
    2a44:	00005906 	br	2bac <prvMySocketTest+0x1c0>
		return;
	}

	memset((char *)&sLocalAddr, 0, sizeof(sLocalAddr));
    2a48:	e0bef604 	addi	r2,fp,-1064
    2a4c:	1009883a 	mov	r4,r2
    2a50:	000b883a 	mov	r5,zero
    2a54:	01800404 	movi	r6,16
    2a58:	00042e80 	call	42e8 <memset>
	sLocalAddr.sin_family = AF_INET;
    2a5c:	00800084 	movi	r2,2
    2a60:	e0bef645 	stb	r2,-1063(fp)
	sLocalAddr.sin_len = sizeof(sLocalAddr);
    2a64:	00800404 	movi	r2,16
    2a68:	e0bef605 	stb	r2,-1064(fp)
	sLocalAddr.sin_addr.s_addr = 0;
    2a6c:	e03ef715 	stw	zero,-1060(fp)
	sLocalAddr.sin_port = htons(23);
    2a70:	0085c004 	movi	r2,5888
    2a74:	e0bef68d 	sth	r2,-1062(fp)

	printf("Binding socket\n");
    2a78:	01000134 	movhi	r4,4
    2a7c:	213e8804 	addi	r4,r4,-1504
    2a80:	00045340 	call	4534 <puts>
	if (bind(lSocket, (struct sockaddr *)&sLocalAddr, sizeof(sLocalAddr)) < 0) {
    2a84:	e0bef604 	addi	r2,fp,-1064
    2a88:	e13ef317 	ldw	r4,-1076(fp)
    2a8c:	100b883a 	mov	r5,r2
    2a90:	01800404 	movi	r6,16
    2a94:	00166c00 	call	166c0 <lwip_bind>
    2a98:	1000060e 	bge	r2,zero,2ab4 <prvMySocketTest+0xc8>
		perror("bind");
    2a9c:	01000134 	movhi	r4,4
    2aa0:	213e8c04 	addi	r4,r4,-1488
    2aa4:	00044340 	call	4434 <perror>
		close(lSocket);
    2aa8:	e13ef317 	ldw	r4,-1076(fp)
    2aac:	00199bc0 	call	199bc <close>
    2ab0:	00003e06 	br	2bac <prvMySocketTest+0x1c0>
		return;
	}

	printf("Listening for socket\n");
    2ab4:	01000134 	movhi	r4,4
    2ab8:	213e8e04 	addi	r4,r4,-1480
    2abc:	00045340 	call	4534 <puts>
	if (listen(lSocket, 20) != 0) {
    2ac0:	e13ef317 	ldw	r4,-1076(fp)
    2ac4:	01400504 	movi	r5,20
    2ac8:	0016a140 	call	16a14 <lwip_listen>
    2acc:	10000726 	beq	r2,zero,2aec <prvMySocketTest+0x100>
		perror("listen");
    2ad0:	01000134 	movhi	r4,4
    2ad4:	213e9404 	addi	r4,r4,-1456
    2ad8:	00044340 	call	4434 <perror>
		close(lSocket);
    2adc:	e13ef317 	ldw	r4,-1076(fp)
    2ae0:	00199bc0 	call	199bc <close>
    2ae4:	00003106 	br	2bac <prvMySocketTest+0x1c0>
			if (!close(clientfd))
				perror("close client");
		}
		else
			perror("accept");
	}
    2ae8:	0001883a 	nop
	}

	while (1) {
		int clientfd;
		struct sockaddr_in client_addr;
		int addrlen = sizeof(client_addr);
    2aec:	00800404 	movi	r2,16
    2af0:	e0befe15 	stw	r2,-1032(fp)
		char buffer[1024];
		int nbytes;

		printf("Waiting for new client\n");
    2af4:	01000134 	movhi	r4,4
    2af8:	213e9604 	addi	r4,r4,-1448
    2afc:	00045340 	call	4534 <puts>

		clientfd = accept(lSocket, (struct sockaddr*)&client_addr, (socklen_t*)&addrlen);
    2b00:	e0fefa04 	addi	r3,fp,-1048
    2b04:	e0befe04 	addi	r2,fp,-1032
    2b08:	e13ef317 	ldw	r4,-1076(fp)
    2b0c:	180b883a 	mov	r5,r3
    2b10:	100d883a 	mov	r6,r2
    2b14:	00163c00 	call	163c0 <lwip_accept>
    2b18:	e0bef415 	stw	r2,-1072(fp)
		printf("client socket %d connected from %s\n", clientfd, print_ipad(client_addr.sin_addr.s_addr));
    2b1c:	e0befb17 	ldw	r2,-1044(fp)
    2b20:	1009883a 	mov	r4,r2
    2b24:	001a19c0 	call	1a19c <print_ipad>
    2b28:	01000134 	movhi	r4,4
    2b2c:	213e9c04 	addi	r4,r4,-1424
    2b30:	e17ef417 	ldw	r5,-1072(fp)
    2b34:	100d883a 	mov	r6,r2
    2b38:	00044740 	call	4474 <printf>
		if (clientfd > 0) {
    2b3c:	e0bef417 	ldw	r2,-1072(fp)
    2b40:	0080160e 	bge	zero,r2,2b9c <prvMySocketTest+0x1b0>
			do {
				nbytes = read(clientfd, buffer, sizeof(buffer));
    2b44:	e0beff04 	addi	r2,fp,-1028
    2b48:	e13ef417 	ldw	r4,-1072(fp)
    2b4c:	100b883a 	mov	r5,r2
    2b50:	01810004 	movi	r6,1024
    2b54:	0019a040 	call	19a04 <read>
    2b58:	e0bef515 	stw	r2,-1068(fp)
				if (nbytes > 0)
    2b5c:	e0bef517 	ldw	r2,-1068(fp)
    2b60:	0080050e 	bge	zero,r2,2b78 <prvMySocketTest+0x18c>
					write(clientfd, buffer, nbytes);
    2b64:	e0beff04 	addi	r2,fp,-1028
    2b68:	e13ef417 	ldw	r4,-1072(fp)
    2b6c:	100b883a 	mov	r5,r2
    2b70:	e1bef517 	ldw	r6,-1068(fp)
    2b74:	0019a700 	call	19a70 <write>

			}  while (nbytes>0);
    2b78:	e0bef517 	ldw	r2,-1068(fp)
    2b7c:	00bff116 	blt	zero,r2,2b44 <prvMySocketTest+0x158>

			if (!close(clientfd))
    2b80:	e13ef417 	ldw	r4,-1072(fp)
    2b84:	00199bc0 	call	199bc <close>
    2b88:	103fd71e 	bne	r2,zero,2ae8 <prvMySocketTest+0xfc>
				perror("close client");
    2b8c:	01000134 	movhi	r4,4
    2b90:	213ea504 	addi	r4,r4,-1388
    2b94:	00044340 	call	4434 <perror>
		}
		else
			perror("accept");
	}
    2b98:	003fd306 	br	2ae8 <prvMySocketTest+0xfc>

			if (!close(clientfd))
				perror("close client");
		}
		else
			perror("accept");
    2b9c:	01000134 	movhi	r4,4
    2ba0:	213ea904 	addi	r4,r4,-1372
    2ba4:	00044340 	call	4434 <perror>
	}
    2ba8:	003fcf06 	br	2ae8 <prvMySocketTest+0xfc>

	if (!close(lSocket))
		perror("close server");
}
    2bac:	e037883a 	mov	sp,fp
    2bb0:	dfc00117 	ldw	ra,4(sp)
    2bb4:	df000017 	ldw	fp,0(sp)
    2bb8:	dec00204 	addi	sp,sp,8
    2bbc:	f800283a 	ret

00002bc0 <StatusCallback>:

#define ETH_STATUS_DISCONNECTED			0x20

// callback function for when the DHCP subsystem acquires an IP address.
static void StatusCallback(struct netif* netif)
{
    2bc0:	defffd04 	addi	sp,sp,-12
    2bc4:	dfc00215 	stw	ra,8(sp)
    2bc8:	df000115 	stw	fp,4(sp)
    2bcc:	df000104 	addi	fp,sp,4
    2bd0:	e13fff15 	stw	r4,-4(fp)
	// get IP and stuff
	printf("[ethernet] Acquired IP address via DHCP client for interface: %s\n", netif->name);
    2bd4:	e0bfff17 	ldw	r2,-4(fp)
    2bd8:	10800e84 	addi	r2,r2,58
    2bdc:	01000134 	movhi	r4,4
    2be0:	213eab04 	addi	r4,r4,-1364
    2be4:	100b883a 	mov	r5,r2
    2be8:	00044740 	call	4474 <printf>

	//printf("[ethernet] IP address : %s\n", print_ipad(netif->ip_addr.addr));
	//printf("[ethernet] Subnet     : %s\n", print_ipad(netif->netmask.addr));
	//printf("[ethernet] Gateway    : %s\n", print_ipad(netif->gw.addr));
}
    2bec:	e037883a 	mov	sp,fp
    2bf0:	dfc00117 	ldw	ra,4(sp)
    2bf4:	df000017 	ldw	fp,0(sp)
    2bf8:	dec00204 	addi	sp,sp,8
    2bfc:	f800283a 	ret

00002c00 <LinkCallback>:

static void LinkCallback(__unused struct netif* netif)
{
    2c00:	defffe04 	addi	sp,sp,-8
    2c04:	df000115 	stw	fp,4(sp)
    2c08:	df000104 	addi	fp,sp,4
    2c0c:	e13fff15 	stw	r4,-4(fp)
	// link change callback
	// TODO release semaphore
	// TODO switch context
}
    2c10:	e037883a 	mov	sp,fp
    2c14:	df000017 	ldw	fp,0(sp)
    2c18:	dec00104 	addi	sp,sp,4
    2c1c:	f800283a 	ret

00002c20 <InitNetwork>:

int InitNetwork(void)
{
    2c20:	defffe04 	addi	sp,sp,-8
    2c24:	dfc00115 	stw	ra,4(sp)
    2c28:	df000015 	stw	fp,0(sp)
    2c2c:	d839883a 	mov	fp,sp
	// register new DHCP "IP attained" callback function.
	// if DHCP is acquired, ws_ipset will be called instead of dhc_main_ipset().
	lwip_set_status_callback(StatusCallback);
    2c30:	01000034 	movhi	r4,0
    2c34:	210af004 	addi	r4,r4,11200
    2c38:	0019f700 	call	19f70 <lwip_set_status_callback>
	lwip_set_link_callback(LinkCallback);
    2c3c:	01000034 	movhi	r4,0
    2c40:	210b0004 	addi	r4,r4,11264
    2c44:	0019fa40 	call	19fa4 <lwip_set_link_callback>

	// Initialize LwIP TCP/IP stack.
	// This function is blocking till the the interface is up.
	lwip_initialize(1);
    2c48:	01000044 	movi	r4,1
    2c4c:	0019ad40 	call	19ad4 <lwip_initialize>

	return EXIT_SUCCESS;
    2c50:	0005883a 	mov	r2,zero
}
    2c54:	e037883a 	mov	sp,fp
    2c58:	dfc00117 	ldw	ra,4(sp)
    2c5c:	df000017 	ldw	fp,0(sp)
    2c60:	dec00204 	addi	sp,sp,8
    2c64:	f800283a 	ret

00002c68 <WaitOnPHY>:

static int WaitOnPHY(void)
{
    2c68:	defff904 	addi	sp,sp,-28
    2c6c:	dfc00615 	stw	ra,24(sp)
    2c70:	df000515 	stw	fp,20(sp)
    2c74:	df000504 	addi	fp,sp,20
	int phyadd;
	int phyid;
	int phyid2 = 0;
    2c78:	e03ffd15 	stw	zero,-12(fp)

	np_tse_mac* pmac;
	bool bInitialized = false;
    2c7c:	e03fff05 	stb	zero,-4(fp)

	while (!bInitialized) {
    2c80:	00003706 	br	2d60 <WaitOnPHY+0xf8>
		printf("[ethernet] PHY INFO: Interface: %d Waiting for PHY\n", 0);
    2c84:	01000134 	movhi	r4,4
    2c88:	213ebc04 	addi	r4,r4,-1296
    2c8c:	000b883a 	mov	r5,zero
    2c90:	00044740 	call	4474 <printf>

		// initialize the structure necessary for "pmac" to function.
		pmac = (np_tse_mac*) TSE_MAC_BASE;
    2c94:	00808034 	movhi	r2,512
    2c98:	10820004 	addi	r2,r2,2048
    2c9c:	e0bffe15 	stw	r2,-8(fp)

		// we are using a Lantiq PHY
		for (phyadd = 0x00; phyadd < 0xff; phyadd++) {
    2ca0:	e03ffb15 	stw	zero,-20(fp)
    2ca4:	00001a06 	br	2d10 <WaitOnPHY+0xa8>
			IOWR(&pmac->MDIO_ADDR0, 0, phyadd);
    2ca8:	e0bffe17 	ldw	r2,-8(fp)
    2cac:	10800f04 	addi	r2,r2,60
    2cb0:	e0fffb17 	ldw	r3,-20(fp)
    2cb4:	10c00035 	stwio	r3,0(r2)

			phyid = IORD(&pmac->MDIO_IFACE.PHY_ID1, 0);
    2cb8:	e0bffe17 	ldw	r2,-8(fp)
    2cbc:	1080a204 	addi	r2,r2,648
    2cc0:	10800037 	ldwio	r2,0(r2)
    2cc4:	e0bffc15 	stw	r2,-16(fp)
			phyid2 = IORD(&pmac->MDIO_IFACE.PHY_ID2, 0);
    2cc8:	e0bffe17 	ldw	r2,-8(fp)
    2ccc:	1080a304 	addi	r2,r2,652
    2cd0:	10800037 	ldwio	r2,0(r2)
    2cd4:	e0bffd15 	stw	r2,-12(fp)

			if (phyid != phyid2) {
    2cd8:	e0fffc17 	ldw	r3,-16(fp)
    2cdc:	e0bffd17 	ldw	r2,-12(fp)
    2ce0:	18800826 	beq	r3,r2,2d04 <WaitOnPHY+0x9c>
				printf("[ethernet] PHY INFO: [PHY ID] 0x%x %x %x\n", phyadd, phyid, phyid2);
    2ce4:	01000134 	movhi	r4,4
    2ce8:	213ec904 	addi	r4,r4,-1244
    2cec:	e17ffb17 	ldw	r5,-20(fp)
    2cf0:	e1bffc17 	ldw	r6,-16(fp)
    2cf4:	e1fffd17 	ldw	r7,-12(fp)
    2cf8:	00044740 	call	4474 <printf>
				phyadd = 0xff;
    2cfc:	00803fc4 	movi	r2,255
    2d00:	e0bffb15 	stw	r2,-20(fp)

		// initialize the structure necessary for "pmac" to function.
		pmac = (np_tse_mac*) TSE_MAC_BASE;

		// we are using a Lantiq PHY
		for (phyadd = 0x00; phyadd < 0xff; phyadd++) {
    2d04:	e0bffb17 	ldw	r2,-20(fp)
    2d08:	10800044 	addi	r2,r2,1
    2d0c:	e0bffb15 	stw	r2,-20(fp)
    2d10:	e0bffb17 	ldw	r2,-20(fp)
    2d14:	10803fd0 	cmplti	r2,r2,255
    2d18:	103fe31e 	bne	r2,zero,2ca8 <WaitOnPHY+0x40>
				printf("[ethernet] PHY INFO: [PHY ID] 0x%x %x %x\n", phyadd, phyid, phyid2);
				phyadd = 0xff;
			}
		}

		if ((phyadd == 0xff) && (phyid == phyid2)) {
    2d1c:	e0bffb17 	ldw	r2,-20(fp)
    2d20:	10803fd8 	cmpnei	r2,r2,255
    2d24:	10000c1e 	bne	r2,zero,2d58 <WaitOnPHY+0xf0>
    2d28:	e0fffc17 	ldw	r3,-16(fp)
    2d2c:	e0bffd17 	ldw	r2,-12(fp)
    2d30:	1880091e 	bne	r3,r2,2d58 <WaitOnPHY+0xf0>
			printf("[ethernet] PHY INFO: No PHY found... restart detect\n");
    2d34:	01000134 	movhi	r4,4
    2d38:	213ed404 	addi	r4,r4,-1200
    2d3c:	00045340 	call	4534 <puts>
			bInitialized = true;
    2d40:	00800044 	movi	r2,1
    2d44:	e0bfff05 	stb	r2,-4(fp)
			mssleep(1000);
    2d48:	010003f4 	movhi	r4,15
    2d4c:	21109004 	addi	r4,r4,16960
    2d50:	00124300 	call	12430 <usleep>
				printf("[ethernet] PHY INFO: [PHY ID] 0x%x %x %x\n", phyadd, phyid, phyid2);
				phyadd = 0xff;
			}
		}

		if ((phyadd == 0xff) && (phyid == phyid2)) {
    2d54:	00000206 	br	2d60 <WaitOnPHY+0xf8>
			printf("[ethernet] PHY INFO: No PHY found... restart detect\n");
			bInitialized = true;
			mssleep(1000);
		}
		else
			bInitialized = true;
    2d58:	00800044 	movi	r2,1
    2d5c:	e0bfff05 	stb	r2,-4(fp)
	int phyid2 = 0;

	np_tse_mac* pmac;
	bool bInitialized = false;

	while (!bInitialized) {
    2d60:	e0bfff03 	ldbu	r2,-4(fp)
    2d64:	1080005c 	xori	r2,r2,1
    2d68:	10803fcc 	andi	r2,r2,255
    2d6c:	103fc51e 	bne	r2,zero,2c84 <WaitOnPHY+0x1c>
		else
			bInitialized = true;
	}

	// issue a PHY reset.
	IOWR(&pmac->MDIO_IFACE.CONTROL, 0, PCS_CTL_an_enable | PCS_CTL_sw_reset);
    2d70:	e0bffe17 	ldw	r2,-8(fp)
    2d74:	1080a004 	addi	r2,r2,640
    2d78:	00e40014 	movui	r3,36864
    2d7c:	10c00035 	stwio	r3,0(r2)
	if (((IORD(&pmac->MDIO_IFACE.CONTROL, 0) & PCS_CTL_rx_slpbk) != 0) || ((IORD(&pmac->MDIO_IFACE.STATUS, 0) & PCS_ST_an_done) == 0)) {
    2d80:	e0bffe17 	ldw	r2,-8(fp)
    2d84:	1080a004 	addi	r2,r2,640
    2d88:	10800037 	ldwio	r2,0(r2)
    2d8c:	1090000c 	andi	r2,r2,16384
    2d90:	1000051e 	bne	r2,zero,2da8 <WaitOnPHY+0x140>
    2d94:	e0bffe17 	ldw	r2,-8(fp)
    2d98:	1080a104 	addi	r2,r2,644
    2d9c:	10800037 	ldwio	r2,0(r2)
    2da0:	1080080c 	andi	r2,r2,32
    2da4:	1000071e 	bne	r2,zero,2dc4 <WaitOnPHY+0x15c>
		IOWR(&pmac->MDIO_IFACE.CONTROL, 0, PCS_CTL_an_enable | PCS_CTL_sw_reset);
    2da8:	e0bffe17 	ldw	r2,-8(fp)
    2dac:	1080a004 	addi	r2,r2,640
    2db0:	00e40014 	movui	r3,36864
    2db4:	10c00035 	stwio	r3,0(r2)
		printf("[ethernet] PHY INFO: Issuing PHY Reset\n");
    2db8:	01000134 	movhi	r4,4
    2dbc:	213ee104 	addi	r4,r4,-1148
    2dc0:	00045340 	call	4534 <puts>
	}

	// holding pattern until autonegotiation completes.
	if ((IORD(&pmac->MDIO_IFACE.STATUS, 0) & PCS_ST_an_done) == 0) {
    2dc4:	e0bffe17 	ldw	r2,-8(fp)
    2dc8:	1080a104 	addi	r2,r2,644
    2dcc:	10800037 	ldwio	r2,0(r2)
    2dd0:	1080080c 	andi	r2,r2,32
    2dd4:	1000111e 	bne	r2,zero,2e1c <WaitOnPHY+0x1b4>
		printf("[ethernet] PHY INFO: Waiting on PHY link...\n");
    2dd8:	01000134 	movhi	r4,4
    2ddc:	213eeb04 	addi	r4,r4,-1108
    2de0:	00045340 	call	4534 <puts>

		while ((IORD(&pmac->MDIO_IFACE.STATUS, 0) & PCS_ST_an_done) == 0)
    2de4:	00000206 	br	2df0 <WaitOnPHY+0x188>
			mssleep(10);
    2de8:	0109c404 	movi	r4,10000
    2dec:	00124300 	call	12430 <usleep>

	// holding pattern until autonegotiation completes.
	if ((IORD(&pmac->MDIO_IFACE.STATUS, 0) & PCS_ST_an_done) == 0) {
		printf("[ethernet] PHY INFO: Waiting on PHY link...\n");

		while ((IORD(&pmac->MDIO_IFACE.STATUS, 0) & PCS_ST_an_done) == 0)
    2df0:	e0bffe17 	ldw	r2,-8(fp)
    2df4:	1080a104 	addi	r2,r2,644
    2df8:	10800037 	ldwio	r2,0(r2)
    2dfc:	1080080c 	andi	r2,r2,32
    2e00:	103ff926 	beq	r2,zero,2de8 <WaitOnPHY+0x180>
			mssleep(10);

		printf("[ethernet] PHY INFO: PHY link detected, allowing network to start.\n");
    2e04:	01000134 	movhi	r4,4
    2e08:	213ef604 	addi	r4,r4,-1064
    2e0c:	00045340 	call	4534 <puts>
		
		mssleep(1000);
    2e10:	010003f4 	movhi	r4,15
    2e14:	21109004 	addi	r4,r4,16960
    2e18:	00124300 	call	12430 <usleep>
	}

	mssleep(10);
    2e1c:	0109c404 	movi	r4,10000
    2e20:	00124300 	call	12430 <usleep>

	return 0;
    2e24:	0005883a 	mov	r2,zero
}
    2e28:	e037883a 	mov	sp,fp
    2e2c:	dfc00117 	ldw	ra,4(sp)
    2e30:	df000017 	ldw	fp,0(sp)
    2e34:	dec00204 	addi	sp,sp,8
    2e38:	f800283a 	ret

00002e3c <xEthernetRun>:

void xEthernetRun(__unused void* param)
{
    2e3c:	defffa04 	addi	sp,sp,-24
    2e40:	dfc00515 	stw	ra,20(sp)
    2e44:	df000415 	stw	fp,16(sp)
    2e48:	df000404 	addi	fp,sp,16
    2e4c:	e13fff15 	stw	r4,-4(fp)
	// initialize PHY
	WaitOnPHY();
    2e50:	0002c680 	call	2c68 <WaitOnPHY>

	if (InitNetwork() != EXIT_SUCCESS) {
    2e54:	0002c200 	call	2c20 <InitNetwork>
    2e58:	10000526 	beq	r2,zero,2e70 <xEthernetRun+0x34>
		// the network initialization has failed.
		printf("[ethernet] Network initialize failed!\n");
    2e5c:	01000134 	movhi	r4,4
    2e60:	213f0704 	addi	r4,r4,-996
    2e64:	00045340 	call	4534 <puts>
		return;
    2e68:	0001883a 	nop
    2e6c:	00001a06 	br	2ed8 <xEthernetRun+0x9c>
	}

	// populate the local pmac structure upon successful network initialization.
	np_tse_mac* pmac = (np_tse_mac*)TSE_MAC_BASE;
    2e70:	00808034 	movhi	r2,512
    2e74:	10820004 	addi	r2,r2,2048
    2e78:	e0bffd15 	stw	r2,-12(fp)

	// set a counter to allow for a brief network disconnect.
	int nDisconnectCnt = 0;
    2e7c:	e03ffe15 	stw	zero,-8(fp)

	// start the demo network tasks
	sys_thread_new("TCP Echo Server", prvMySocketTest, NULL, KB(4), 3);
    2e80:	008000c4 	movi	r2,3
    2e84:	d8800015 	stw	r2,0(sp)
    2e88:	01000134 	movhi	r4,4
    2e8c:	213f1104 	addi	r4,r4,-956
    2e90:	01400034 	movhi	r5,0
    2e94:	294a7b04 	addi	r5,r5,10732
    2e98:	000d883a 	mov	r6,zero
    2e9c:	01c40004 	movi	r7,4096
    2ea0:	001b91c0 	call	1b91c <sys_thread_new>
	sys_thread_new("HTTP Server", vBasicWEBServer, NULL, KB(8), 3);
    2ea4:	008000c4 	movi	r2,3
    2ea8:	d8800015 	stw	r2,0(sp)
    2eac:	01000134 	movhi	r4,4
    2eb0:	213f1504 	addi	r4,r4,-940
    2eb4:	01400034 	movhi	r5,0
    2eb8:	2940a804 	addi	r5,r5,672
    2ebc:	000d883a 	mov	r6,zero
    2ec0:	01c80004 	movi	r7,8192
    2ec4:	001b91c0 	call	1b91c <sys_thread_new>
	// keep checking our network status, are we connected or disconnected?
	while (1) {
		// TODO wait for semaphore is network status changes

		// sleep for 1 second
		mssleep(1000);
    2ec8:	010003f4 	movhi	r4,15
    2ecc:	21109004 	addi	r4,r4,16960
    2ed0:	00124300 	call	12430 <usleep>
			// reset the disconnect counter.
			nDisconnectCnt = 0;
		}

#endif
	}
    2ed4:	003ffc06 	br	2ec8 <xEthernetRun+0x8c>

	return 0;
}
    2ed8:	e037883a 	mov	sp,fp
    2edc:	dfc00117 	ldw	ra,4(sp)
    2ee0:	df000017 	ldw	fp,0(sp)
    2ee4:	dec00204 	addi	sp,sp,8
    2ee8:	f800283a 	ret

00002eec <get_mac_addr>:

// callback wrapper for lwip to get the interface configurations
int get_mac_addr(int iface, struct netif* ethif, unsigned char mac_addr[6])
{	
    2eec:	defff704 	addi	sp,sp,-36
    2ef0:	dfc00815 	stw	ra,32(sp)
    2ef4:	df000715 	stw	fp,28(sp)
    2ef8:	df000704 	addi	fp,sp,28
    2efc:	e13ffd15 	stw	r4,-12(fp)
    2f00:	e17ffe15 	stw	r5,-8(fp)
    2f04:	e1bfff15 	stw	r6,-4(fp)
	mac_addr[0] = 0x00;
    2f08:	e0bfff17 	ldw	r2,-4(fp)
    2f0c:	10000005 	stb	zero,0(r2)
	mac_addr[1] = 0x07;
    2f10:	e0bfff17 	ldw	r2,-4(fp)
    2f14:	10800044 	addi	r2,r2,1
    2f18:	00c001c4 	movi	r3,7
    2f1c:	10c00005 	stb	r3,0(r2)
	mac_addr[2] = 0xED;
    2f20:	e0bfff17 	ldw	r2,-4(fp)
    2f24:	10800084 	addi	r2,r2,2
    2f28:	00fffb44 	movi	r3,-19
    2f2c:	10c00005 	stb	r3,0(r2)
	mac_addr[3] = 0xFF;
    2f30:	e0bfff17 	ldw	r2,-4(fp)
    2f34:	108000c4 	addi	r2,r2,3
    2f38:	00ffffc4 	movi	r3,-1
    2f3c:	10c00005 	stb	r3,0(r2)
	mac_addr[4] = 0x68;
    2f40:	e0bfff17 	ldw	r2,-4(fp)
    2f44:	10800104 	addi	r2,r2,4
    2f48:	00c01a04 	movi	r3,104
    2f4c:	10c00005 	stb	r3,0(r2)
	mac_addr[5] = 0xB0 + iface;
    2f50:	e0bfff17 	ldw	r2,-4(fp)
    2f54:	10800144 	addi	r2,r2,5
    2f58:	e0fffd17 	ldw	r3,-12(fp)
    2f5c:	18ffec04 	addi	r3,r3,-80
    2f60:	10c00005 	stb	r3,0(r2)
	
	// only show info if net is not NULL
	if (ethif)
    2f64:	e0bffe17 	ldw	r2,-8(fp)
    2f68:	10002126 	beq	r2,zero,2ff0 <get_mac_addr+0x104>
		printf("[ethernet] Using Ethernet MAC address %02x:%02x:%02x:%02x:%02x:%02x for interface: %d\n",
				mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5], iface);
    2f6c:	e0bfff17 	ldw	r2,-4(fp)
    2f70:	10800003 	ldbu	r2,0(r2)
	mac_addr[4] = 0x68;
	mac_addr[5] = 0xB0 + iface;
	
	// only show info if net is not NULL
	if (ethif)
		printf("[ethernet] Using Ethernet MAC address %02x:%02x:%02x:%02x:%02x:%02x for interface: %d\n",
    2f74:	11403fcc 	andi	r5,r2,255
				mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5], iface);
    2f78:	e0bfff17 	ldw	r2,-4(fp)
    2f7c:	10800044 	addi	r2,r2,1
    2f80:	10800003 	ldbu	r2,0(r2)
	mac_addr[4] = 0x68;
	mac_addr[5] = 0xB0 + iface;
	
	// only show info if net is not NULL
	if (ethif)
		printf("[ethernet] Using Ethernet MAC address %02x:%02x:%02x:%02x:%02x:%02x for interface: %d\n",
    2f84:	10c03fcc 	andi	r3,r2,255
				mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5], iface);
    2f88:	e0bfff17 	ldw	r2,-4(fp)
    2f8c:	10800084 	addi	r2,r2,2
    2f90:	10800003 	ldbu	r2,0(r2)
	mac_addr[4] = 0x68;
	mac_addr[5] = 0xB0 + iface;
	
	// only show info if net is not NULL
	if (ethif)
		printf("[ethernet] Using Ethernet MAC address %02x:%02x:%02x:%02x:%02x:%02x for interface: %d\n",
    2f94:	10803fcc 	andi	r2,r2,255
				mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5], iface);
    2f98:	e13fff17 	ldw	r4,-4(fp)
    2f9c:	210000c4 	addi	r4,r4,3
    2fa0:	21000003 	ldbu	r4,0(r4)
	mac_addr[4] = 0x68;
	mac_addr[5] = 0xB0 + iface;
	
	// only show info if net is not NULL
	if (ethif)
		printf("[ethernet] Using Ethernet MAC address %02x:%02x:%02x:%02x:%02x:%02x for interface: %d\n",
    2fa4:	21c03fcc 	andi	r7,r4,255
				mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5], iface);
    2fa8:	e13fff17 	ldw	r4,-4(fp)
    2fac:	21000104 	addi	r4,r4,4
    2fb0:	21000003 	ldbu	r4,0(r4)
	mac_addr[4] = 0x68;
	mac_addr[5] = 0xB0 + iface;
	
	// only show info if net is not NULL
	if (ethif)
		printf("[ethernet] Using Ethernet MAC address %02x:%02x:%02x:%02x:%02x:%02x for interface: %d\n",
    2fb4:	21803fcc 	andi	r6,r4,255
				mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5], iface);
    2fb8:	e13fff17 	ldw	r4,-4(fp)
    2fbc:	21000144 	addi	r4,r4,5
    2fc0:	21000003 	ldbu	r4,0(r4)
	mac_addr[4] = 0x68;
	mac_addr[5] = 0xB0 + iface;
	
	// only show info if net is not NULL
	if (ethif)
		printf("[ethernet] Using Ethernet MAC address %02x:%02x:%02x:%02x:%02x:%02x for interface: %d\n",
    2fc4:	21003fcc 	andi	r4,r4,255
    2fc8:	d9c00015 	stw	r7,0(sp)
    2fcc:	d9800115 	stw	r6,4(sp)
    2fd0:	d9000215 	stw	r4,8(sp)
    2fd4:	e13ffd17 	ldw	r4,-12(fp)
    2fd8:	d9000315 	stw	r4,12(sp)
    2fdc:	01000134 	movhi	r4,4
    2fe0:	213f1804 	addi	r4,r4,-928
    2fe4:	180d883a 	mov	r6,r3
    2fe8:	100f883a 	mov	r7,r2
    2fec:	00044740 	call	4474 <printf>
				mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5], iface);

	return EXIT_SUCCESS;
    2ff0:	0005883a 	mov	r2,zero
}
    2ff4:	e037883a 	mov	sp,fp
    2ff8:	dfc00117 	ldw	ra,4(sp)
    2ffc:	df000017 	ldw	fp,0(sp)
    3000:	dec00204 	addi	sp,sp,8
    3004:	f800283a 	ret

00003008 <get_ip_addr>:

// callback wrapper for lwip to get the IP configurations
int get_ip_addr(int iface, ip_addr_t* ipaddr, ip_addr_t* netmask, ip_addr_t* gw, int* use_dhcp)
{
    3008:	defff904 	addi	sp,sp,-28
    300c:	dfc00615 	stw	ra,24(sp)
    3010:	df000515 	stw	fp,20(sp)
    3014:	df000504 	addi	fp,sp,20
    3018:	e13ffc15 	stw	r4,-16(fp)
    301c:	e17ffd15 	stw	r5,-12(fp)
    3020:	e1bffe15 	stw	r6,-8(fp)
    3024:	e1ffff15 	stw	r7,-4(fp)
	// set configuration
	IP4_ADDR(ipaddr, 192, 168, 0, 218);
    3028:	e0bffd17 	ldw	r2,-12(fp)
    302c:	00f68074 	movhi	r3,55809
    3030:	18ea3004 	addi	r3,r3,-22336
    3034:	10c00015 	stw	r3,0(r2)
	IP4_ADDR(netmask, 255, 255, 255, 0);
    3038:	e0bffe17 	ldw	r2,-8(fp)
    303c:	00c04034 	movhi	r3,256
    3040:	18ffffc4 	addi	r3,r3,-1
    3044:	10c00015 	stw	r3,0(r2)
	IP4_ADDR(gw, 192, 168, 0, 1);
    3048:	e0bfff17 	ldw	r2,-4(fp)
    304c:	00c04074 	movhi	r3,257
    3050:	18ea3004 	addi	r3,r3,-22336
    3054:	10c00015 	stw	r3,0(r2)
	*use_dhcp = 1;
    3058:	e0800217 	ldw	r2,8(fp)
    305c:	00c00044 	movi	r3,1
    3060:	10c00015 	stw	r3,0(r2)

	char *buf;

	if (*use_dhcp == 0)
    3064:	e0800217 	ldw	r2,8(fp)
    3068:	10800017 	ldw	r2,0(r2)
    306c:	10000b1e 	bne	r2,zero,309c <get_ip_addr+0x94>
		printf("[ethernet] Static IP Address for interface %d %s\n", iface, print_ipad(ipaddr->addr, buf));
    3070:	e0bffd17 	ldw	r2,-12(fp)
    3074:	10800017 	ldw	r2,0(r2)
    3078:	1009883a 	mov	r4,r2
    307c:	e17ffb17 	ldw	r5,-20(fp)
    3080:	001a19c0 	call	1a19c <print_ipad>
    3084:	01000134 	movhi	r4,4
    3088:	213f2e04 	addi	r4,r4,-840
    308c:	e17ffc17 	ldw	r5,-16(fp)
    3090:	100d883a 	mov	r6,r2
    3094:	00044740 	call	4474 <printf>
    3098:	00000406 	br	30ac <get_ip_addr+0xa4>
	else
		printf("[ethernet] Starting get IP via DHCP for interface %d\n", iface);
    309c:	01000134 	movhi	r4,4
    30a0:	213f3b04 	addi	r4,r4,-788
    30a4:	e17ffc17 	ldw	r5,-16(fp)
    30a8:	00044740 	call	4474 <printf>

	return EXIT_SUCCESS;
    30ac:	0005883a 	mov	r2,zero
}
    30b0:	e037883a 	mov	sp,fp
    30b4:	dfc00117 	ldw	ra,4(sp)
    30b8:	df000017 	ldw	fp,0(sp)
    30bc:	dec00204 	addi	sp,sp,8
    30c0:	f800283a 	ret

000030c4 <get_hostname>:

int get_hostname(int iface, const char **hostname)
{
    30c4:	defffd04 	addi	sp,sp,-12
    30c8:	df000215 	stw	fp,8(sp)
    30cc:	df000204 	addi	fp,sp,8
    30d0:	e13ffe15 	stw	r4,-8(fp)
    30d4:	e17fff15 	stw	r5,-4(fp)
	*hostname = "LwIP";
    30d8:	e0bfff17 	ldw	r2,-4(fp)
    30dc:	00c00134 	movhi	r3,4
    30e0:	18ff4904 	addi	r3,r3,-732
    30e4:	10c00015 	stw	r3,0(r2)

	return ERR_OK;
    30e8:	0005883a 	mov	r2,zero
}
    30ec:	e037883a 	mov	sp,fp
    30f0:	df000017 	ldw	fp,0(sp)
    30f4:	dec00104 	addi	sp,sp,4
    30f8:	f800283a 	ret

000030fc <get_iface_name>:

int get_iface_name(int iface, char name[ETH_IFACE_NAME_LENGTH])
{
    30fc:	defffd04 	addi	sp,sp,-12
    3100:	df000215 	stw	fp,8(sp)
    3104:	df000204 	addi	fp,sp,8
    3108:	e13ffe15 	stw	r4,-8(fp)
    310c:	e17fff15 	stw	r5,-4(fp)
	name[0] = 'e';
    3110:	e0bfff17 	ldw	r2,-4(fp)
    3114:	00c01944 	movi	r3,101
    3118:	10c00005 	stb	r3,0(r2)
	name[1] = (iface + 0x30);
    311c:	e0bfff17 	ldw	r2,-4(fp)
    3120:	10800044 	addi	r2,r2,1
    3124:	e0fffe17 	ldw	r3,-8(fp)
    3128:	18c00c04 	addi	r3,r3,48
    312c:	10c00005 	stb	r3,0(r2)

	return ERR_OK;
    3130:	0005883a 	mov	r2,zero
}
    3134:	e037883a 	mov	sp,fp
    3138:	df000017 	ldw	fp,0(sp)
    313c:	dec00104 	addi	sp,sp,4
    3140:	f800283a 	ret

00003144 <is_interface_active>:

int is_interface_active(int iface)
{
    3144:	defffe04 	addi	sp,sp,-8
    3148:	df000115 	stw	fp,4(sp)
    314c:	df000104 	addi	fp,sp,4
    3150:	e13fff15 	stw	r4,-4(fp)
	return 1;
    3154:	00800044 	movi	r2,1
}
    3158:	e037883a 	mov	sp,fp
    315c:	df000017 	ldw	fp,0(sp)
    3160:	dec00104 	addi	sp,sp,4
    3164:	f800283a 	ret

00003168 <vStartIntegerMathTasks>:
static volatile signed portBASE_TYPE xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( signed portBASE_TYPE ) pdFALSE };

/*-----------------------------------------------------------*/

void vStartIntegerMathTasks( unsigned portBASE_TYPE uxPriority )
{
    3168:	defff804 	addi	sp,sp,-32
    316c:	dfc00715 	stw	ra,28(sp)
    3170:	df000615 	stw	fp,24(sp)
    3174:	df000604 	addi	fp,sp,24
    3178:	e13fff15 	stw	r4,-4(fp)
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    317c:	e03ffe0d 	sth	zero,-8(fp)
    3180:	00001406 	br	31d4 <vStartIntegerMathTasks+0x6c>
	{
		xTaskCreate( vCompeteingIntMathTask, ( signed char * ) "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( xTaskHandle * ) NULL );
    3184:	e0bffe0f 	ldh	r2,-8(fp)
    3188:	1085883a 	add	r2,r2,r2
    318c:	1087883a 	add	r3,r2,r2
    3190:	d0a8e804 	addi	r2,gp,-23648
    3194:	1885883a 	add	r2,r3,r2
    3198:	e0ffff17 	ldw	r3,-4(fp)
    319c:	d8c00015 	stw	r3,0(sp)
    31a0:	d8000115 	stw	zero,4(sp)
    31a4:	d8000215 	stw	zero,8(sp)
    31a8:	d8000315 	stw	zero,12(sp)
    31ac:	01000034 	movhi	r4,0
    31b0:	210c7c04 	addi	r4,r4,12784
    31b4:	01400134 	movhi	r5,4
    31b8:	297f4b04 	addi	r5,r5,-724
    31bc:	018c9604 	movi	r6,12888
    31c0:	100f883a 	mov	r7,r2
    31c4:	000f5140 	call	f514 <xTaskGenericCreate>

void vStartIntegerMathTasks( unsigned portBASE_TYPE uxPriority )
{
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    31c8:	e0bffe0b 	ldhu	r2,-8(fp)
    31cc:	10800044 	addi	r2,r2,1
    31d0:	e0bffe0d 	sth	r2,-8(fp)
    31d4:	e0bffe0f 	ldh	r2,-8(fp)
    31d8:	00bfea0e 	bge	zero,r2,3184 <vStartIntegerMathTasks+0x1c>
	{
		xTaskCreate( vCompeteingIntMathTask, ( signed char * ) "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( xTaskHandle * ) NULL );
	}
}
    31dc:	e037883a 	mov	sp,fp
    31e0:	dfc00117 	ldw	ra,4(sp)
    31e4:	df000017 	ldw	fp,0(sp)
    31e8:	dec00204 	addi	sp,sp,8
    31ec:	f800283a 	ret

000031f0 <vCompeteingIntMathTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
    31f0:	defffa04 	addi	sp,sp,-24
    31f4:	dfc00515 	stw	ra,20(sp)
    31f8:	df000415 	stw	fp,16(sp)
    31fc:	df000404 	addi	fp,sp,16
    3200:	e13fff15 	stw	r4,-4(fp)
/* These variables are all effectively set to constants so they are volatile to
ensure the compiler does not just get rid of them. */
volatile long lValue;
short sError = pdFALSE;
    3204:	e03ffc0d 	sth	zero,-16(fp)
volatile signed portBASE_TYPE *pxTaskHasExecuted;

	/* Set a pointer to the variable we are going to set to true each
	iteration.  This is also a good test of the parameter passing mechanism
	within each port. */
	pxTaskHasExecuted = ( volatile signed portBASE_TYPE * ) pvParameters;
    3208:	e0bfff17 	ldw	r2,-4(fp)
    320c:	e0bffd15 	stw	r2,-12(fp)
    3210:	00000106 	br	3218 <vCompeteingIntMathTask+0x28>
		#if configUSE_PREEMPTION == 0
		{
			taskYIELD();
		}
		#endif
	}
    3214:	0001883a 	nop
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    3218:	00801ec4 	movi	r2,123
    321c:	e0bffe15 	stw	r2,-8(fp)
		lValue += intgCONST2;
    3220:	e0fffe17 	ldw	r3,-8(fp)
    3224:	00800134 	movhi	r2,4
    3228:	10a511c4 	addi	r2,r2,-27577
    322c:	1885883a 	add	r2,r3,r2
    3230:	e0bffe15 	stw	r2,-8(fp)
			taskYIELD();
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
    3234:	e0bffe17 	ldw	r2,-8(fp)
    3238:	10bfff64 	muli	r2,r2,-3
    323c:	e0bffe15 	stw	r2,-8(fp)
		lValue /= intgCONST4;
    3240:	e0fffe17 	ldw	r3,-8(fp)
    3244:	008001c4 	movi	r2,7
    3248:	1885283a 	div	r2,r3,r2
    324c:	e0bffe15 	stw	r2,-8(fp)

		/* If the calculation is found to be incorrect we stop setting the 
		TaskHasExecuted variable so the check task can see an error has 
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
    3250:	e0fffe17 	ldw	r3,-8(fp)
    3254:	00bfffb4 	movhi	r2,65534
    3258:	109dc6c4 	addi	r2,r2,30491
    325c:	18800226 	beq	r3,r2,3268 <vCompeteingIntMathTask+0x78>
		{
			sError = pdTRUE;
    3260:	00800044 	movi	r2,1
    3264:	e0bffc0d 	sth	r2,-16(fp)
		}

		if( sError == pdFALSE )
    3268:	e0bffc0f 	ldh	r2,-16(fp)
    326c:	103fe91e 	bne	r2,zero,3214 <vCompeteingIntMathTask+0x24>
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
    3270:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    3274:	10000126 	beq	r2,zero,327c <vCompeteingIntMathTask+0x8c>
    3278:	00110d00 	call	110d0 <vTaskEnterCritical>
				*pxTaskHasExecuted = pdTRUE;
    327c:	e0bffd17 	ldw	r2,-12(fp)
    3280:	00c00044 	movi	r3,1
    3284:	10c00015 	stw	r3,0(r2)
			portEXIT_CRITICAL();
    3288:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    328c:	103fe126 	beq	r2,zero,3214 <vCompeteingIntMathTask+0x24>
    3290:	00111100 	call	11110 <vTaskExitCritical>
		#if configUSE_PREEMPTION == 0
		{
			taskYIELD();
		}
		#endif
	}
    3294:	003fdf06 	br	3214 <vCompeteingIntMathTask+0x24>

00003298 <xAreIntegerMathsTaskStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
portBASE_TYPE xAreIntegerMathsTaskStillRunning( void )
{
    3298:	defffd04 	addi	sp,sp,-12
    329c:	df000215 	stw	fp,8(sp)
    32a0:	df000204 	addi	fp,sp,8
portBASE_TYPE xReturn = pdTRUE;
    32a4:	00800044 	movi	r2,1
    32a8:	e0bffe15 	stw	r2,-8(fp)
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    32ac:	e03fff0d 	sth	zero,-4(fp)
    32b0:	00001106 	br	32f8 <xAreIntegerMathsTaskStillRunning+0x60>
	{
		if( xTaskCheck[ sTask ] == pdFALSE )
    32b4:	e0bfff0f 	ldh	r2,-4(fp)
    32b8:	1085883a 	add	r2,r2,r2
    32bc:	1087883a 	add	r3,r2,r2
    32c0:	d0a8e804 	addi	r2,gp,-23648
    32c4:	1885883a 	add	r2,r3,r2
    32c8:	10800017 	ldw	r2,0(r2)
    32cc:	1000011e 	bne	r2,zero,32d4 <xAreIntegerMathsTaskStillRunning+0x3c>
		{
			/* The check has not incremented so an error exists. */
			xReturn = pdFALSE;
    32d0:	e03ffe15 	stw	zero,-8(fp)
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
    32d4:	e0bfff0f 	ldh	r2,-4(fp)
    32d8:	1085883a 	add	r2,r2,r2
    32dc:	1087883a 	add	r3,r2,r2
    32e0:	d0a8e804 	addi	r2,gp,-23648
    32e4:	1885883a 	add	r2,r3,r2
    32e8:	10000015 	stw	zero,0(r2)
portBASE_TYPE xReturn = pdTRUE;
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    32ec:	e0bfff0b 	ldhu	r2,-4(fp)
    32f0:	10800044 	addi	r2,r2,1
    32f4:	e0bfff0d 	sth	r2,-4(fp)
    32f8:	e0bfff0f 	ldh	r2,-4(fp)
    32fc:	00bfed0e 	bge	zero,r2,32b4 <xAreIntegerMathsTaskStillRunning+0x1c>
		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
	}

	return xReturn;
    3300:	e0bffe17 	ldw	r2,-8(fp)
}
    3304:	e037883a 	mov	sp,fp
    3308:	df000017 	ldw	fp,0(sp)
    330c:	dec00104 	addi	sp,sp,4
    3310:	f800283a 	ret

00003314 <main>:

/*
 * Create the demo tasks then start the scheduler.
 */
int main( void )
{
    3314:	defffa04 	addi	sp,sp,-24
    3318:	dfc00515 	stw	ra,20(sp)
    331c:	df000415 	stw	fp,16(sp)
    3320:	df000404 	addi	fp,sp,16
	/* Create all the other standard demo tasks.  These serve no purpose other
    than to test the port and demonstrate the use of the FreeRTOS API. */
	vStartIntegerMathTasks( mainGENERIC_QUEUE_PRIORITY );
    3324:	0009883a 	mov	r4,zero
    3328:	00031680 	call	3168 <vStartIntegerMathTasks>
	vStartPolledQueueTasks( mainQUEUE_POLL_PRIORITY );
    332c:	01000084 	movi	r4,2
    3330:	00011a80 	call	11a8 <vStartPolledQueueTasks>
	vStartBlockingQueueTasks( mainQUEUE_BLOCK_PRIORITY );
    3334:	010000c4 	movi	r4,3
    3338:	00005000 	call	500 <vStartBlockingQueueTasks>
	vCreateBlockTimeTasks();
    333c:	00019700 	call	1970 <vCreateBlockTimeTasks>
	vStartSemaphoreTasks( mainSEMAPHORE_TASK_PRIORITY );
    3340:	01000044 	movi	r4,1
    3344:	0003da40 	call	3da4 <vStartSemaphoreTasks>
	vStartDynamicPriorityTasks();
    3348:	00025e80 	call	25e8 <vStartDynamicPriorityTasks>
	vStartQueuePeekTasks();
    334c:	00014080 	call	1408 <vStartQueuePeekTasks>
	vStartGenericQueueTasks( mainGENERIC_QUEUE_PRIORITY );
    3350:	0009883a 	mov	r4,zero
    3354:	0000a0c0 	call	a0c <vStartGenericQueueTasks>
	vStartCountingSemaphoreTasks();
    3358:	0001fb80 	call	1fb8 <vStartCountingSemaphoreTasks>
	vStartRecursiveMutexTasks();
    335c:	00039dc0 	call	39dc <vStartRecursiveMutexTasks>
    
	/* prvCheckTask uses sprintf so requires more stack. */
	xTaskCreate( prvCheckTask, "Check", configMINIMAL_STACK_SIZE, NULL, mainCHECK_TASK_PRIORITY, NULL );
    3360:	00800104 	movi	r2,4
    3364:	d8800015 	stw	r2,0(sp)
    3368:	d8000115 	stw	zero,4(sp)
    336c:	d8000215 	stw	zero,8(sp)
    3370:	d8000315 	stw	zero,12(sp)
    3374:	01000034 	movhi	r4,0
    3378:	210d2e04 	addi	r4,r4,13496
    337c:	01400134 	movhi	r5,4
    3380:	297f4d04 	addi	r5,r5,-716
    3384:	018c9604 	movi	r6,12888
    3388:	000f883a 	mov	r7,zero
    338c:	000f5140 	call	f514 <xTaskGenericCreate>
    
    /* The RegTest tasks as described at the top of this file. */
    xTaskCreate( prvFirstRegTestTask, "Rreg1", configMINIMAL_STACK_SIZE, mainREG_TEST_1_PARAMETER, mainREG_TEST_PRIORITY, NULL );
    3390:	d8000015 	stw	zero,0(sp)
    3394:	d8000115 	stw	zero,4(sp)
    3398:	d8000215 	stw	zero,8(sp)
    339c:	d8000315 	stw	zero,12(sp)
    33a0:	01000034 	movhi	r4,0
    33a4:	210dbe04 	addi	r4,r4,14072
    33a8:	01400134 	movhi	r5,4
    33ac:	297f4f04 	addi	r5,r5,-708
    33b0:	018c9604 	movi	r6,12888
    33b4:	01c48d34 	movhi	r7,4660
    33b8:	39d59e04 	addi	r7,r7,22136
    33bc:	000f5140 	call	f514 <xTaskGenericCreate>
    xTaskCreate( prvSecondRegTestTask, "Rreg2", configMINIMAL_STACK_SIZE, mainREG_TEST_2_PARAMETER, mainREG_TEST_PRIORITY, NULL );
    33c0:	d8000015 	stw	zero,0(sp)
    33c4:	d8000115 	stw	zero,4(sp)
    33c8:	d8000215 	stw	zero,8(sp)
    33cc:	d8000315 	stw	zero,12(sp)
    33d0:	01000034 	movhi	r4,0
    33d4:	210e1b04 	addi	r4,r4,14444
    33d8:	01400134 	movhi	r5,4
    33dc:	297f5104 	addi	r5,r5,-700
    33e0:	018c9604 	movi	r6,12888
    33e4:	01e1d974 	movhi	r7,34661
    33e8:	39d0c844 	addi	r7,r7,17185
    33ec:	000f5140 	call	f514 <xTaskGenericCreate>
	
	/* start the network task to start the network */
	xTaskCreate(xEthernetRun, "eth0", KB(4), NULL, mainQUEUE_POLL_PRIORITY, NULL);
    33f0:	00800084 	movi	r2,2
    33f4:	d8800015 	stw	r2,0(sp)
    33f8:	d8000115 	stw	zero,4(sp)
    33fc:	d8000215 	stw	zero,8(sp)
    3400:	d8000315 	stw	zero,12(sp)
    3404:	01000034 	movhi	r4,0
    3408:	210b8f04 	addi	r4,r4,11836
    340c:	01400134 	movhi	r5,4
    3410:	297f5304 	addi	r5,r5,-692
    3414:	01840004 	movi	r6,4096
    3418:	000f883a 	mov	r7,zero
    341c:	000f5140 	call	f514 <xTaskGenericCreate>

	/* This task has to be created last as it keeps account of the number of tasks
	it expects to see running. */
	vCreateSuicidalTasks( mainCREATOR_TASK_PRIORITY );
    3420:	010000c4 	movi	r4,3
    3424:	00023940 	call	2394 <vCreateSuicidalTasks>

    /* Finally start the scheduler. */
	vTaskStartScheduler();
    3428:	000fe400 	call	fe40 <vTaskStartScheduler>
    
	/* Will only reach here if there is insufficient heap available to start
	the scheduler. */
	for( ;; );
    342c:	003fff06 	br	342c <main+0x118>

00003430 <vApplicationStackOverflowHook>:
}
/*-----------------------------------------------------------*/
void vApplicationStackOverflowHook(__unused xTaskHandle *pxTask, signed char *pcTaskName )
{
    3430:	defffc04 	addi	sp,sp,-16
    3434:	dfc00315 	stw	ra,12(sp)
    3438:	df000215 	stw	fp,8(sp)
    343c:	df000204 	addi	fp,sp,8
    3440:	e13ffe15 	stw	r4,-8(fp)
    3444:	e17fff15 	stw	r5,-4(fp)
	printf("[free_rtos] Application stack overflow at task: %s\n", pcTaskName);
    3448:	01000134 	movhi	r4,4
    344c:	213f5504 	addi	r4,r4,-684
    3450:	e17fff17 	ldw	r5,-4(fp)
    3454:	00044740 	call	4474 <printf>
}
    3458:	e037883a 	mov	sp,fp
    345c:	dfc00117 	ldw	ra,4(sp)
    3460:	df000017 	ldw	fp,0(sp)
    3464:	dec00204 	addi	sp,sp,8
    3468:	f800283a 	ret

0000346c <vApplicationMallocFailedHook>:

void vApplicationMallocFailedHook(void)
{
    346c:	defffe04 	addi	sp,sp,-8
    3470:	dfc00115 	stw	ra,4(sp)
    3474:	df000015 	stw	fp,0(sp)
    3478:	d839883a 	mov	fp,sp
	printf("[free_rtos] Malloc Failed\n");
    347c:	01000134 	movhi	r4,4
    3480:	213f6204 	addi	r4,r4,-632
    3484:	00045340 	call	4534 <puts>
}
    3488:	e037883a 	mov	sp,fp
    348c:	dfc00117 	ldw	ra,4(sp)
    3490:	df000017 	ldw	fp,0(sp)
    3494:	dec00204 	addi	sp,sp,8
    3498:	f800283a 	ret

0000349c <_general_exception_handler>:

void _general_exception_handler( unsigned long ulCause, unsigned long ulStatus )
{
    349c:	defffd04 	addi	sp,sp,-12
    34a0:	df000215 	stw	fp,8(sp)
    34a4:	df000204 	addi	fp,sp,8
    34a8:	e13ffe15 	stw	r4,-8(fp)
    34ac:	e17fff15 	stw	r5,-4(fp)
	/* This overrides the definition provided by the kernel.  Other exceptions 
	should be handled here. */
	for( ;; )
    {
		asm( "break" );
    34b0:	003da03a 	break	0
    }
    34b4:	003ffe06 	br	34b0 <_general_exception_handler+0x14>

000034b8 <prvCheckTask>:
}
/*-----------------------------------------------------------*/

static void prvCheckTask( void *pvParameters )
{
    34b8:	defff804 	addi	sp,sp,-32
    34bc:	dfc00715 	stw	ra,28(sp)
    34c0:	df000615 	stw	fp,24(sp)
    34c4:	df000604 	addi	fp,sp,24
    34c8:	e13fff15 	stw	r4,-4(fp)
portTickType xLastExecutionTime, ulTicksToWait = mainNO_ERROR_PERIOD;
    34cc:	0084e204 	movi	r2,5000
    34d0:	e0bffa15 	stw	r2,-24(fp)
unsigned long ulLastRegTest1 = 0UL, ulLastRegTest2 = 0UL;
    34d4:	e03ffb15 	stw	zero,-20(fp)
    34d8:	e03ffc15 	stw	zero,-16(fp)
const char * pcMessage;

	/* Initialise the variable used to control our iteration rate prior to
	its first use. */
	xLastExecutionTime = xTaskGetTickCount();
    34dc:	001006c0 	call	1006c <xTaskGetTickCount>
    34e0:	e0bffe15 	stw	r2,-8(fp)
    34e4:	00000106 	br	34ec <prvCheckTask+0x34>
        not used as this is the only task accessing stdout. */
        if( pcMessage != NULL )
        {
            printf( pcMessage );
        }
	}
    34e8:	0001883a 	nop
	xLastExecutionTime = xTaskGetTickCount();

	for( ;; )
	{
		/* Wait until it is time to run the tests again. */
		vTaskDelayUntil( &xLastExecutionTime, ulTicksToWait );
    34ec:	e0bffe04 	addi	r2,fp,-8
    34f0:	1009883a 	mov	r4,r2
    34f4:	e17ffa17 	ldw	r5,-24(fp)
    34f8:	000f7dc0 	call	f7dc <vTaskDelayUntil>
		
		/* Have any of the standard demo tasks detected an error in their 
		operation? */
		if( xAreIntegerMathsTaskStillRunning() != pdTRUE )
    34fc:	00032980 	call	3298 <xAreIntegerMathsTaskStillRunning>
    3500:	10800060 	cmpeqi	r2,r2,1
    3504:	1000061e 	bne	r2,zero,3520 <prvCheckTask+0x68>
		{
			ulTicksToWait = mainERROR_PERIOD;
    3508:	00807d04 	movi	r2,500
    350c:	e0bffa15 	stw	r2,-24(fp)
			pcMessage = "Error: Integer Maths.\n";
    3510:	00800134 	movhi	r2,4
    3514:	10bf6904 	addi	r2,r2,-604
    3518:	e0bffd15 	stw	r2,-12(fp)
    351c:	00006d06 	br	36d4 <prvCheckTask+0x21c>
		}
		else if( xAreGenericQueueTasksStillRunning() != pdTRUE )
    3520:	00011480 	call	1148 <xAreGenericQueueTasksStillRunning>
    3524:	10800060 	cmpeqi	r2,r2,1
    3528:	1000061e 	bne	r2,zero,3544 <prvCheckTask+0x8c>
		{
			ulTicksToWait = mainERROR_PERIOD;
    352c:	00807d04 	movi	r2,500
    3530:	e0bffa15 	stw	r2,-24(fp)
			pcMessage = "Error: GenQ.\n";
    3534:	00800134 	movhi	r2,4
    3538:	10bf6f04 	addi	r2,r2,-580
    353c:	e0bffd15 	stw	r2,-12(fp)
    3540:	00006406 	br	36d4 <prvCheckTask+0x21c>
		}
		else if( xAreBlockingQueuesStillRunning() != pdTRUE )
    3544:	00008e40 	call	8e4 <xAreBlockingQueuesStillRunning>
    3548:	10800060 	cmpeqi	r2,r2,1
    354c:	1000061e 	bne	r2,zero,3568 <prvCheckTask+0xb0>
		{
			ulTicksToWait = mainERROR_PERIOD;
    3550:	00807d04 	movi	r2,500
    3554:	e0bffa15 	stw	r2,-24(fp)
			pcMessage = "Error: BlockQ.\n";
    3558:	00800134 	movhi	r2,4
    355c:	10bf7304 	addi	r2,r2,-564
    3560:	e0bffd15 	stw	r2,-12(fp)
    3564:	00005b06 	br	36d4 <prvCheckTask+0x21c>
		}
		else if( xArePollingQueuesStillRunning() != pdTRUE )
    3568:	00013c00 	call	13c0 <xArePollingQueuesStillRunning>
    356c:	10800060 	cmpeqi	r2,r2,1
    3570:	1000061e 	bne	r2,zero,358c <prvCheckTask+0xd4>
		{
			ulTicksToWait = mainERROR_PERIOD;
    3574:	00807d04 	movi	r2,500
    3578:	e0bffa15 	stw	r2,-24(fp)
			pcMessage = "Error: PollQ.\n";
    357c:	00800134 	movhi	r2,4
    3580:	10bf7704 	addi	r2,r2,-548
    3584:	e0bffd15 	stw	r2,-12(fp)
    3588:	00005206 	br	36d4 <prvCheckTask+0x21c>
		}
		else if( xAreQueuePeekTasksStillRunning() != pdTRUE )
    358c:	000192c0 	call	192c <xAreQueuePeekTasksStillRunning>
    3590:	10800060 	cmpeqi	r2,r2,1
    3594:	1000061e 	bne	r2,zero,35b0 <prvCheckTask+0xf8>
		{
			ulTicksToWait = mainERROR_PERIOD;
    3598:	00807d04 	movi	r2,500
    359c:	e0bffa15 	stw	r2,-24(fp)
			pcMessage = "Error: PeekQ.\n";
    35a0:	00800134 	movhi	r2,4
    35a4:	10bf7b04 	addi	r2,r2,-532
    35a8:	e0bffd15 	stw	r2,-12(fp)
    35ac:	00004906 	br	36d4 <prvCheckTask+0x21c>
		}
		else if( xAreBlockTimeTestTasksStillRunning() != pdTRUE )
    35b0:	0001f500 	call	1f50 <xAreBlockTimeTestTasksStillRunning>
    35b4:	10800060 	cmpeqi	r2,r2,1
    35b8:	1000061e 	bne	r2,zero,35d4 <prvCheckTask+0x11c>
		{
			ulTicksToWait = mainERROR_PERIOD;
    35bc:	00807d04 	movi	r2,500
    35c0:	e0bffa15 	stw	r2,-24(fp)
			pcMessage = "Error: Block Time.\n";
    35c4:	00800134 	movhi	r2,4
    35c8:	10bf7f04 	addi	r2,r2,-516
    35cc:	e0bffd15 	stw	r2,-12(fp)
    35d0:	00004006 	br	36d4 <prvCheckTask+0x21c>
		}
		else if( xAreSemaphoreTasksStillRunning() != pdTRUE )
    35d4:	00041380 	call	4138 <xAreSemaphoreTasksStillRunning>
    35d8:	10800060 	cmpeqi	r2,r2,1
    35dc:	1000061e 	bne	r2,zero,35f8 <prvCheckTask+0x140>
	    {
	        ulTicksToWait = mainERROR_PERIOD;
    35e0:	00807d04 	movi	r2,500
    35e4:	e0bffa15 	stw	r2,-24(fp)
			pcMessage = "Error: Semaphore Test.\n";
    35e8:	00800134 	movhi	r2,4
    35ec:	10bf8404 	addi	r2,r2,-496
    35f0:	e0bffd15 	stw	r2,-12(fp)
    35f4:	00003706 	br	36d4 <prvCheckTask+0x21c>
	    }
		else if( xIsCreateTaskStillRunning() != pdTRUE )
    35f8:	00025600 	call	2560 <xIsCreateTaskStillRunning>
    35fc:	10800060 	cmpeqi	r2,r2,1
    3600:	1000061e 	bne	r2,zero,361c <prvCheckTask+0x164>
		{
			ulTicksToWait = mainERROR_PERIOD;
    3604:	00807d04 	movi	r2,500
    3608:	e0bffa15 	stw	r2,-24(fp)
			pcMessage = "Error: Suicidal Tasks.\n";
    360c:	00800134 	movhi	r2,4
    3610:	10bf8a04 	addi	r2,r2,-472
    3614:	e0bffd15 	stw	r2,-12(fp)
    3618:	00002e06 	br	36d4 <prvCheckTask+0x21c>
		}
		else if( xAreDynamicPriorityTasksStillRunning() != pdTRUE )
    361c:	00029840 	call	2984 <xAreDynamicPriorityTasksStillRunning>
    3620:	10800060 	cmpeqi	r2,r2,1
    3624:	1000061e 	bne	r2,zero,3640 <prvCheckTask+0x188>
		{
			ulTicksToWait = mainERROR_PERIOD;
    3628:	00807d04 	movi	r2,500
    362c:	e0bffa15 	stw	r2,-24(fp)
			pcMessage = "Error: Dynamic Priority.\n";
    3630:	00800134 	movhi	r2,4
    3634:	10bf9004 	addi	r2,r2,-448
    3638:	e0bffd15 	stw	r2,-12(fp)
    363c:	00002506 	br	36d4 <prvCheckTask+0x21c>
		}
		else if( xAreCountingSemaphoreTasksStillRunning() != pdTRUE )
    3640:	00023080 	call	2308 <xAreCountingSemaphoreTasksStillRunning>
    3644:	10800060 	cmpeqi	r2,r2,1
    3648:	1000061e 	bne	r2,zero,3664 <prvCheckTask+0x1ac>
		{
			ulTicksToWait = mainERROR_PERIOD;
    364c:	00807d04 	movi	r2,500
    3650:	e0bffa15 	stw	r2,-24(fp)
			pcMessage = "Error: Count Semaphore.\n";
    3654:	00800134 	movhi	r2,4
    3658:	10bf9704 	addi	r2,r2,-420
    365c:	e0bffd15 	stw	r2,-12(fp)
    3660:	00001c06 	br	36d4 <prvCheckTask+0x21c>
		}
		else if( xAreRecursiveMutexTasksStillRunning() != pdTRUE )
    3664:	0003d080 	call	3d08 <xAreRecursiveMutexTasksStillRunning>
    3668:	10800060 	cmpeqi	r2,r2,1
    366c:	1000061e 	bne	r2,zero,3688 <prvCheckTask+0x1d0>
		{
			ulTicksToWait = mainERROR_PERIOD;
    3670:	00807d04 	movi	r2,500
    3674:	e0bffa15 	stw	r2,-24(fp)
			pcMessage = "Error: Recursive Mutex.\n";
    3678:	00800134 	movhi	r2,4
    367c:	10bf9e04 	addi	r2,r2,-392
    3680:	e0bffd15 	stw	r2,-12(fp)
    3684:	00001306 	br	36d4 <prvCheckTask+0x21c>
		}
        else if( ulLastRegTest1 == ulRegTest1Counter )
    3688:	d0a8e917 	ldw	r2,-23644(gp)
    368c:	e0fffb17 	ldw	r3,-20(fp)
    3690:	1880061e 	bne	r3,r2,36ac <prvCheckTask+0x1f4>
        {
            /* ulRegTest1Counter is no longer being incremented, indicating
            that an error has been discovered in prvFirstRegTestTask(). */
            ulTicksToWait = mainERROR_PERIOD;
    3694:	00807d04 	movi	r2,500
    3698:	e0bffa15 	stw	r2,-24(fp)
            pcMessage = "Error: Reg Test1.\n";
    369c:	00800134 	movhi	r2,4
    36a0:	10bfa504 	addi	r2,r2,-364
    36a4:	e0bffd15 	stw	r2,-12(fp)
    36a8:	00000a06 	br	36d4 <prvCheckTask+0x21c>
        }
        else if( ulLastRegTest2 == ulRegTest2Counter )
    36ac:	d0a8ea17 	ldw	r2,-23640(gp)
    36b0:	e0fffc17 	ldw	r3,-16(fp)
    36b4:	1880061e 	bne	r3,r2,36d0 <prvCheckTask+0x218>
        {
            /* ulRegTest2Counter is no longer being incremented, indicating
            that an error has been discovered in prvSecondRegTestTask(). */            
            ulTicksToWait = mainERROR_PERIOD;
    36b8:	00807d04 	movi	r2,500
    36bc:	e0bffa15 	stw	r2,-24(fp)
            pcMessage = "Error: Reg Test2.\n";
    36c0:	00800134 	movhi	r2,4
    36c4:	10bfaa04 	addi	r2,r2,-344
    36c8:	e0bffd15 	stw	r2,-12(fp)
    36cc:	00000106 	br	36d4 <prvCheckTask+0x21c>
        }
		else
		{
			pcMessage = NULL;
    36d0:	e03ffd15 	stw	zero,-12(fp)
		}
        
        /* Remember the counter values this time around so a counter failing
        to be incremented correctly can be spotted. */
        ulLastRegTest1 = ulRegTest1Counter;
    36d4:	d0a8e917 	ldw	r2,-23644(gp)
    36d8:	e0bffb15 	stw	r2,-20(fp)
        ulLastRegTest2 = ulRegTest2Counter;
    36dc:	d0a8ea17 	ldw	r2,-23640(gp)
    36e0:	e0bffc15 	stw	r2,-16(fp)
        
        /* Print out an error message if there is one.  Mutual exclusion is 
        not used as this is the only task accessing stdout. */
        if( pcMessage != NULL )
    36e4:	e0bffd17 	ldw	r2,-12(fp)
    36e8:	103f7f26 	beq	r2,zero,34e8 <prvCheckTask+0x30>
        {
            printf( pcMessage );
    36ec:	e13ffd17 	ldw	r4,-12(fp)
    36f0:	00044740 	call	4474 <printf>
        }
	}
    36f4:	003f7c06 	br	34e8 <prvCheckTask+0x30>

000036f8 <prvFirstRegTestTask>:
}
/*-----------------------------------------------------------*/

static void prvFirstRegTestTask( void *pvParameters )
{
    36f8:	defffd04 	addi	sp,sp,-12
    36fc:	dfc00215 	stw	ra,8(sp)
    3700:	df000115 	stw	fp,4(sp)
    3704:	df000104 	addi	fp,sp,4
    3708:	e13fff15 	stw	r4,-4(fp)
    /* Check the parameters are passed in as expected. */
    if( pvParameters != mainREG_TEST_1_PARAMETER )
    370c:	e0ffff17 	ldw	r3,-4(fp)
    3710:	00848d34 	movhi	r2,4660
    3714:	10959e04 	addi	r2,r2,22136
    3718:	18800226 	beq	r3,r2,3724 <prvFirstRegTestTask+0x2c>
    {
        /* Don't execute any further so an error is recognised by the check 
        task. */
        vTaskDelete( NULL );
    371c:	0009883a 	mov	r4,zero
    3720:	000f7040 	call	f704 <vTaskDelete>
    
    If no errors are found ulRegTest1Counter is incremented.  The check task
    will recognise an error if ulRegTest1Counter stops being incremented. 
    This task also performs a manual yield in the middle of its execution, just
    to increase the test coverage. */
    asm volatile (
    3724:	00c000c4 	movi	r3,3
    3728:	01000104 	movi	r4,4
    372c:	01400144 	movi	r5,5
    3730:	01800184 	movi	r6,6
    3734:	01c001c4 	movi	r7,7
    3738:	02000204 	movi	r8,8
    373c:	02400244 	movi	r9,9
    3740:	02800284 	movi	r10,10
    3744:	02c002c4 	movi	r11,11
    3748:	03000304 	movi	r12,12
    374c:	03400344 	movi	r13,13
    3750:	03800384 	movi	r14,14
    3754:	03c003c4 	movi	r15,15
    3758:	04000404 	movi	r16,16
    375c:	04400444 	movi	r17,17
    3760:	04800484 	movi	r18,18
    3764:	04c004c4 	movi	r19,19
    3768:	05000504 	movi	r20,20
    376c:	05400544 	movi	r21,21
    3770:	05800584 	movi	r22,22
    3774:	05c005c4 	movi	r23,23
    3778:	07000704 	movi	fp,28
    377c:	07c007c4 	movi	ra,31

00003780 <RegTest1>:
    3780:	00800004 	movi	r2,0
    3784:	003b683a 	trap	0
    3788:	1000321e 	bne	r2,zero,3854 <RegTest1Error>
    378c:	008000c4 	movi	r2,3
    3790:	10c0301e 	bne	r2,r3,3854 <RegTest1Error>
    3794:	00800104 	movi	r2,4
    3798:	11002e1e 	bne	r2,r4,3854 <RegTest1Error>
    379c:	00800144 	movi	r2,5
    37a0:	11402c1e 	bne	r2,r5,3854 <RegTest1Error>
    37a4:	00800184 	movi	r2,6
    37a8:	11802a1e 	bne	r2,r6,3854 <RegTest1Error>
    37ac:	008001c4 	movi	r2,7
    37b0:	11c0281e 	bne	r2,r7,3854 <RegTest1Error>
    37b4:	00800204 	movi	r2,8
    37b8:	1200261e 	bne	r2,r8,3854 <RegTest1Error>
    37bc:	00800244 	movi	r2,9
    37c0:	1240241e 	bne	r2,r9,3854 <RegTest1Error>
    37c4:	00800284 	movi	r2,10
    37c8:	1280221e 	bne	r2,r10,3854 <RegTest1Error>
    37cc:	008002c4 	movi	r2,11
    37d0:	12c0201e 	bne	r2,r11,3854 <RegTest1Error>
    37d4:	00800304 	movi	r2,12
    37d8:	13001e1e 	bne	r2,r12,3854 <RegTest1Error>
    37dc:	00800344 	movi	r2,13
    37e0:	13401c1e 	bne	r2,r13,3854 <RegTest1Error>
    37e4:	00800384 	movi	r2,14
    37e8:	13801a1e 	bne	r2,r14,3854 <RegTest1Error>
    37ec:	008003c4 	movi	r2,15
    37f0:	13c0181e 	bne	r2,r15,3854 <RegTest1Error>
    37f4:	00800404 	movi	r2,16
    37f8:	1400161e 	bne	r2,r16,3854 <RegTest1Error>
    37fc:	00800444 	movi	r2,17
    3800:	1440141e 	bne	r2,r17,3854 <RegTest1Error>
    3804:	00800484 	movi	r2,18
    3808:	1480121e 	bne	r2,r18,3854 <RegTest1Error>
    380c:	008004c4 	movi	r2,19
    3810:	14c0101e 	bne	r2,r19,3854 <RegTest1Error>
    3814:	00800504 	movi	r2,20
    3818:	15000e1e 	bne	r2,r20,3854 <RegTest1Error>
    381c:	00800544 	movi	r2,21
    3820:	15400c1e 	bne	r2,r21,3854 <RegTest1Error>
    3824:	00800584 	movi	r2,22
    3828:	15800a1e 	bne	r2,r22,3854 <RegTest1Error>
    382c:	008005c4 	movi	r2,23
    3830:	15c0081e 	bne	r2,r23,3854 <RegTest1Error>
    3834:	00800704 	movi	r2,28
    3838:	1700061e 	bne	r2,fp,3854 <RegTest1Error>
    383c:	008007c4 	movi	r2,31
    3840:	17c0041e 	bne	r2,ra,3854 <RegTest1Error>
    3844:	d0a8e917 	ldw	r2,-23644(gp)
    3848:	10800044 	addi	r2,r2,1
    384c:	d0a8e915 	stw	r2,-23644(gp)
    3850:	003fcb06 	br	3780 <RegTest1>

00003854 <RegTest1Error>:
    3854:	003fff06 	br	3854 <RegTest1Error>
        "   stw     r2, %gprel(ulRegTest1Counter)(gp)       \n" \
        "   br      RegTest1                    \n" \
        "RegTest1Error:                         \n" \
        "   br      RegTest1Error               \n"
    );
}
    3858:	e037883a 	mov	sp,fp
    385c:	dfc00117 	ldw	ra,4(sp)
    3860:	df000017 	ldw	fp,0(sp)
    3864:	dec00204 	addi	sp,sp,8
    3868:	f800283a 	ret

0000386c <prvSecondRegTestTask>:
/*-----------------------------------------------------------*/

static void prvSecondRegTestTask( void *pvParameters )
{
    386c:	defffd04 	addi	sp,sp,-12
    3870:	dfc00215 	stw	ra,8(sp)
    3874:	df000115 	stw	fp,4(sp)
    3878:	df000104 	addi	fp,sp,4
    387c:	e13fff15 	stw	r4,-4(fp)
    /* Check the parameters are passed in as expected. */
    if( pvParameters != mainREG_TEST_2_PARAMETER )
    3880:	e0ffff17 	ldw	r3,-4(fp)
    3884:	00a1d974 	movhi	r2,34661
    3888:	1090c844 	addi	r2,r2,17185
    388c:	18800226 	beq	r3,r2,3898 <prvSecondRegTestTask+0x2c>
    {
        /* Don't execute any further so an error is recognised by the check 
        task. */
        vTaskDelete( NULL );
    3890:	0009883a 	mov	r4,zero
    3894:	000f7040 	call	f704 <vTaskDelete>
    contains its expected value.  An incorrect value is indicative of an error
    in the context switching process. 
    
    If no errors are found ulRegTest2Counter is incremented.  The check task
    will recognise an error if ulRegTest2Counter stops being incremented. */
    asm volatile (
    3898:	00c000c4 	movi	r3,3
    389c:	01000104 	movi	r4,4
    38a0:	01400144 	movi	r5,5
    38a4:	01800184 	movi	r6,6
    38a8:	01c001c4 	movi	r7,7
    38ac:	02000204 	movi	r8,8
    38b0:	02400244 	movi	r9,9
    38b4:	02800284 	movi	r10,10
    38b8:	02c002c4 	movi	r11,11
    38bc:	03000304 	movi	r12,12
    38c0:	03400344 	movi	r13,13
    38c4:	03800384 	movi	r14,14
    38c8:	03c003c4 	movi	r15,15
    38cc:	04000404 	movi	r16,16
    38d0:	04400444 	movi	r17,17
    38d4:	04800484 	movi	r18,18
    38d8:	04c004c4 	movi	r19,19
    38dc:	05000504 	movi	r20,20
    38e0:	05400544 	movi	r21,21
    38e4:	05800584 	movi	r22,22
    38e8:	05c005c4 	movi	r23,23
    38ec:	07000704 	movi	fp,28
    38f0:	07c007c4 	movi	ra,31

000038f4 <RegTest2>:
    38f4:	00800004 	movi	r2,0
    38f8:	1000321e 	bne	r2,zero,39c4 <RegTest2Error>
    38fc:	008000c4 	movi	r2,3
    3900:	10c0301e 	bne	r2,r3,39c4 <RegTest2Error>
    3904:	00800104 	movi	r2,4
    3908:	11002e1e 	bne	r2,r4,39c4 <RegTest2Error>
    390c:	00800144 	movi	r2,5
    3910:	11402c1e 	bne	r2,r5,39c4 <RegTest2Error>
    3914:	00800184 	movi	r2,6
    3918:	11802a1e 	bne	r2,r6,39c4 <RegTest2Error>
    391c:	008001c4 	movi	r2,7
    3920:	11c0281e 	bne	r2,r7,39c4 <RegTest2Error>
    3924:	00800204 	movi	r2,8
    3928:	1200261e 	bne	r2,r8,39c4 <RegTest2Error>
    392c:	00800244 	movi	r2,9
    3930:	1240241e 	bne	r2,r9,39c4 <RegTest2Error>
    3934:	00800284 	movi	r2,10
    3938:	1280221e 	bne	r2,r10,39c4 <RegTest2Error>
    393c:	008002c4 	movi	r2,11
    3940:	12c0201e 	bne	r2,r11,39c4 <RegTest2Error>
    3944:	00800304 	movi	r2,12
    3948:	13001e1e 	bne	r2,r12,39c4 <RegTest2Error>
    394c:	00800344 	movi	r2,13
    3950:	13401c1e 	bne	r2,r13,39c4 <RegTest2Error>
    3954:	00800384 	movi	r2,14
    3958:	13801a1e 	bne	r2,r14,39c4 <RegTest2Error>
    395c:	008003c4 	movi	r2,15
    3960:	13c0181e 	bne	r2,r15,39c4 <RegTest2Error>
    3964:	00800404 	movi	r2,16
    3968:	1400161e 	bne	r2,r16,39c4 <RegTest2Error>
    396c:	00800444 	movi	r2,17
    3970:	1440141e 	bne	r2,r17,39c4 <RegTest2Error>
    3974:	00800484 	movi	r2,18
    3978:	1480121e 	bne	r2,r18,39c4 <RegTest2Error>
    397c:	008004c4 	movi	r2,19
    3980:	14c0101e 	bne	r2,r19,39c4 <RegTest2Error>
    3984:	00800504 	movi	r2,20
    3988:	15000e1e 	bne	r2,r20,39c4 <RegTest2Error>
    398c:	00800544 	movi	r2,21
    3990:	15400c1e 	bne	r2,r21,39c4 <RegTest2Error>
    3994:	00800584 	movi	r2,22
    3998:	15800a1e 	bne	r2,r22,39c4 <RegTest2Error>
    399c:	008005c4 	movi	r2,23
    39a0:	15c0081e 	bne	r2,r23,39c4 <RegTest2Error>
    39a4:	00800704 	movi	r2,28
    39a8:	1700061e 	bne	r2,fp,39c4 <RegTest2Error>
    39ac:	008007c4 	movi	r2,31
    39b0:	17c0041e 	bne	r2,ra,39c4 <RegTest2Error>
    39b4:	d0a8ea17 	ldw	r2,-23640(gp)
    39b8:	10800044 	addi	r2,r2,1
    39bc:	d0a8ea15 	stw	r2,-23640(gp)
    39c0:	003fcc06 	br	38f4 <RegTest2>

000039c4 <RegTest2Error>:
    39c4:	003fff06 	br	39c4 <RegTest2Error>
        "   stw     r2, %gprel(ulRegTest2Counter)(gp)       \n" \
        "   br      RegTest2                    \n" \
        "RegTest2Error:                         \n" \
        "   br      RegTest2Error               \n"
    );
}
    39c8:	e037883a 	mov	sp,fp
    39cc:	dfc00117 	ldw	ra,4(sp)
    39d0:	df000017 	ldw	fp,0(sp)
    39d4:	dec00204 	addi	sp,sp,8
    39d8:	f800283a 	ret

000039dc <vStartRecursiveMutexTasks>:
static xTaskHandle xControllingTaskHandle, xBlockingTaskHandle;

/*-----------------------------------------------------------*/

void vStartRecursiveMutexTasks( void )
{
    39dc:	defffa04 	addi	sp,sp,-24
    39e0:	dfc00515 	stw	ra,20(sp)
    39e4:	df000415 	stw	fp,16(sp)
    39e8:	df000404 	addi	fp,sp,16
	/* Just creates the mutex and the three tasks. */

	xMutex = xSemaphoreCreateRecursiveMutex();
    39ec:	01000104 	movi	r4,4
    39f0:	000e7040 	call	e704 <xQueueCreateMutex>
    39f4:	d0a8eb15 	stw	r2,-23636(gp)
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( ( xQueueHandle ) xMutex, ( signed portCHAR * ) "Recursive_Mutex" );


	if( xMutex != NULL )
    39f8:	d0a8eb17 	ldw	r2,-23636(gp)
    39fc:	10002526 	beq	r2,zero,3a94 <vStartRecursiveMutexTasks+0xb8>
	{
		xTaskCreate( prvRecursiveMutexControllingTask, ( signed portCHAR * ) "Rec1", configMINIMAL_STACK_SIZE, NULL, recmuCONTROLLING_TASK_PRIORITY, &xControllingTaskHandle );
    3a00:	00800084 	movi	r2,2
    3a04:	d8800015 	stw	r2,0(sp)
    3a08:	d0a8f204 	addi	r2,gp,-23608
    3a0c:	d8800115 	stw	r2,4(sp)
    3a10:	d8000215 	stw	zero,8(sp)
    3a14:	d8000315 	stw	zero,12(sp)
    3a18:	01000034 	movhi	r4,0
    3a1c:	210eaa04 	addi	r4,r4,15016
    3a20:	01400134 	movhi	r5,4
    3a24:	297faf04 	addi	r5,r5,-324
    3a28:	018c9604 	movi	r6,12888
    3a2c:	000f883a 	mov	r7,zero
    3a30:	000f5140 	call	f514 <xTaskGenericCreate>
        xTaskCreate( prvRecursiveMutexBlockingTask, ( signed portCHAR * ) "Rec2", configMINIMAL_STACK_SIZE, NULL, recmuBLOCKING_TASK_PRIORITY, &xBlockingTaskHandle );
    3a34:	00800044 	movi	r2,1
    3a38:	d8800015 	stw	r2,0(sp)
    3a3c:	d0a8f304 	addi	r2,gp,-23604
    3a40:	d8800115 	stw	r2,4(sp)
    3a44:	d8000215 	stw	zero,8(sp)
    3a48:	d8000315 	stw	zero,12(sp)
    3a4c:	01000034 	movhi	r4,0
    3a50:	210ee904 	addi	r4,r4,15268
    3a54:	01400134 	movhi	r5,4
    3a58:	297fb104 	addi	r5,r5,-316
    3a5c:	018c9604 	movi	r6,12888
    3a60:	000f883a 	mov	r7,zero
    3a64:	000f5140 	call	f514 <xTaskGenericCreate>
        xTaskCreate( prvRecursiveMutexPollingTask, ( signed portCHAR * ) "Rec3", configMINIMAL_STACK_SIZE, NULL, recmuPOLLING_TASK_PRIORITY, NULL );
    3a68:	d8000015 	stw	zero,0(sp)
    3a6c:	d8000115 	stw	zero,4(sp)
    3a70:	d8000215 	stw	zero,8(sp)
    3a74:	d8000315 	stw	zero,12(sp)
    3a78:	01000034 	movhi	r4,0
    3a7c:	210f1304 	addi	r4,r4,15436
    3a80:	01400134 	movhi	r5,4
    3a84:	297fb304 	addi	r5,r5,-308
    3a88:	018c9604 	movi	r6,12888
    3a8c:	000f883a 	mov	r7,zero
    3a90:	000f5140 	call	f514 <xTaskGenericCreate>
	}
}
    3a94:	e037883a 	mov	sp,fp
    3a98:	dfc00117 	ldw	ra,4(sp)
    3a9c:	df000017 	ldw	fp,0(sp)
    3aa0:	dec00204 	addi	sp,sp,8
    3aa4:	f800283a 	ret

00003aa8 <prvRecursiveMutexControllingTask>:
/*-----------------------------------------------------------*/

static void prvRecursiveMutexControllingTask( void *pvParameters )
{
    3aa8:	defffc04 	addi	sp,sp,-16
    3aac:	dfc00315 	stw	ra,12(sp)
    3ab0:	df000215 	stw	fp,8(sp)
    3ab4:	df000204 	addi	fp,sp,8
    3ab8:	e13fff15 	stw	r4,-4(fp)
	{
		/* Should not be able to 'give' the mutex, as we have not yet 'taken'
		it.   The first time through, the mutex will not have been used yet,
		subsequent times through, at this point the mutex will be held by the
		polling task. */
		if( xSemaphoreGiveRecursive( xMutex ) == pdPASS )
    3abc:	d0a8eb17 	ldw	r2,-23636(gp)
    3ac0:	1009883a 	mov	r4,r2
    3ac4:	000e7dc0 	call	e7dc <xQueueGiveMutexRecursive>
    3ac8:	10800058 	cmpnei	r2,r2,1
    3acc:	1000021e 	bne	r2,zero,3ad8 <prvRecursiveMutexControllingTask+0x30>
		{
			xErrorOccurred = pdTRUE;
    3ad0:	00800044 	movi	r2,1
    3ad4:	d0a8ec15 	stw	r2,-23632(gp)
		}

		for( ux = 0; ux < recmuMAX_COUNT; ux++ )
    3ad8:	e03ffe15 	stw	zero,-8(fp)
    3adc:	00000d06 	br	3b14 <prvRecursiveMutexControllingTask+0x6c>
			at this point and this Take will cause the polling task to inherit
			the priority of this task.  In this case the block time must be
			long enough to ensure the polling task will execute again before the
			block time expires.  If the block time does expire then the error
			flag will be set here. */
			if( xSemaphoreTakeRecursive( xMutex, recmuTWO_TICK_DELAY ) != pdPASS )
    3ae0:	d0a8eb17 	ldw	r2,-23636(gp)
    3ae4:	1009883a 	mov	r4,r2
    3ae8:	01400084 	movi	r5,2
    3aec:	000e8640 	call	e864 <xQueueTakeMutexRecursive>
    3af0:	10800060 	cmpeqi	r2,r2,1
    3af4:	1000021e 	bne	r2,zero,3b00 <prvRecursiveMutexControllingTask+0x58>
			{
				xErrorOccurred = pdTRUE;
    3af8:	00800044 	movi	r2,1
    3afc:	d0a8ec15 	stw	r2,-23632(gp)

			/* Ensure the other task attempting to access the mutex (and the
			other demo tasks) are able to execute to ensure they either block
			(where a block time is specified) or return an error (where no 
			block time is specified) as the mutex is held by this task. */
			vTaskDelay( recmuSHORT_DELAY );
    3b00:	01000504 	movi	r4,20
    3b04:	000f8c00 	call	f8c0 <vTaskDelay>
		if( xSemaphoreGiveRecursive( xMutex ) == pdPASS )
		{
			xErrorOccurred = pdTRUE;
		}

		for( ux = 0; ux < recmuMAX_COUNT; ux++ )
    3b08:	e0bffe17 	ldw	r2,-8(fp)
    3b0c:	10800044 	addi	r2,r2,1
    3b10:	e0bffe15 	stw	r2,-8(fp)
    3b14:	e0bffe17 	ldw	r2,-8(fp)
    3b18:	108002b0 	cmpltui	r2,r2,10
    3b1c:	103ff01e 	bne	r2,zero,3ae0 <prvRecursiveMutexControllingTask+0x38>
			block time is specified) as the mutex is held by this task. */
			vTaskDelay( recmuSHORT_DELAY );
		}

		/* For each time we took the mutex, give it back. */
		for( ux = 0; ux < recmuMAX_COUNT; ux++ )
    3b20:	e03ffe15 	stw	zero,-8(fp)
    3b24:	00000c06 	br	3b58 <prvRecursiveMutexControllingTask+0xb0>
		{
			/* Ensure the other task attempting to access the mutex (and the
			other demo tasks) are able to execute. */
			vTaskDelay( recmuSHORT_DELAY );
    3b28:	01000504 	movi	r4,20
    3b2c:	000f8c00 	call	f8c0 <vTaskDelay>
			/* We should now be able to give the mutex as many times as we
			took it.  When the mutex is available again the Blocking task
			should be unblocked but not run because it has a lower priority
			than this task.  The polling task should also not run at this point
			as it too has a lower priority than this task. */
			if( xSemaphoreGiveRecursive( xMutex ) != pdPASS )
    3b30:	d0a8eb17 	ldw	r2,-23636(gp)
    3b34:	1009883a 	mov	r4,r2
    3b38:	000e7dc0 	call	e7dc <xQueueGiveMutexRecursive>
    3b3c:	10800060 	cmpeqi	r2,r2,1
    3b40:	1000021e 	bne	r2,zero,3b4c <prvRecursiveMutexControllingTask+0xa4>
			{
				xErrorOccurred = pdTRUE;
    3b44:	00800044 	movi	r2,1
    3b48:	d0a8ec15 	stw	r2,-23632(gp)
			block time is specified) as the mutex is held by this task. */
			vTaskDelay( recmuSHORT_DELAY );
		}

		/* For each time we took the mutex, give it back. */
		for( ux = 0; ux < recmuMAX_COUNT; ux++ )
    3b4c:	e0bffe17 	ldw	r2,-8(fp)
    3b50:	10800044 	addi	r2,r2,1
    3b54:	e0bffe15 	stw	r2,-8(fp)
    3b58:	e0bffe17 	ldw	r2,-8(fp)
    3b5c:	108002b0 	cmpltui	r2,r2,10
    3b60:	103ff11e 	bne	r2,zero,3b28 <prvRecursiveMutexControllingTask+0x80>
			}
		}

		/* Having given it back the same number of times as it was taken, we
		should no longer be the mutex owner, so the next give sh ould fail. */
		if( xSemaphoreGiveRecursive( xMutex ) == pdPASS )
    3b64:	d0a8eb17 	ldw	r2,-23636(gp)
    3b68:	1009883a 	mov	r4,r2
    3b6c:	000e7dc0 	call	e7dc <xQueueGiveMutexRecursive>
    3b70:	10800058 	cmpnei	r2,r2,1
    3b74:	1000021e 	bne	r2,zero,3b80 <prvRecursiveMutexControllingTask+0xd8>
		{
			xErrorOccurred = pdTRUE;
    3b78:	00800044 	movi	r2,1
    3b7c:	d0a8ec15 	stw	r2,-23632(gp)
		}

		/* Keep count of the number of cycles this task has performed so a 
		stall can be detected. */
		uxControllingCycles++;
    3b80:	d0a8ef17 	ldw	r2,-23620(gp)
    3b84:	10800044 	addi	r2,r2,1
    3b88:	d0a8ef15 	stw	r2,-23620(gp)

		/* Suspend ourselves to the blocking task can execute. */
		xControllingIsSuspended = pdTRUE;
    3b8c:	00800044 	movi	r2,1
    3b90:	d0a8ed15 	stw	r2,-23628(gp)
		vTaskSuspend( NULL );
    3b94:	0009883a 	mov	r4,zero
    3b98:	000fb300 	call	fb30 <vTaskSuspend>
		xControllingIsSuspended = pdFALSE;
    3b9c:	d028ed15 	stw	zero,-23628(gp)
	}
    3ba0:	003fc606 	br	3abc <prvRecursiveMutexControllingTask+0x14>

00003ba4 <prvRecursiveMutexBlockingTask>:
}
/*-----------------------------------------------------------*/

static void prvRecursiveMutexBlockingTask( void *pvParameters )
{
    3ba4:	defffd04 	addi	sp,sp,-12
    3ba8:	dfc00215 	stw	ra,8(sp)
    3bac:	df000115 	stw	fp,4(sp)
    3bb0:	df000104 	addi	fp,sp,4
    3bb4:	e13fff15 	stw	r4,-4(fp)
		/* This task will run while the controlling task is blocked, and the
		controlling task will block only once it has the mutex - therefore
		this call should block until the controlling task has given up the 
		mutex, and not actually execute	past this call until the controlling 
		task is suspended. */
		if( xSemaphoreTakeRecursive( xMutex, portMAX_DELAY ) == pdPASS )
    3bb8:	d0a8eb17 	ldw	r2,-23636(gp)
    3bbc:	1009883a 	mov	r4,r2
    3bc0:	017fffc4 	movi	r5,-1
    3bc4:	000e8640 	call	e864 <xQueueTakeMutexRecursive>
    3bc8:	10800058 	cmpnei	r2,r2,1
    3bcc:	1000131e 	bne	r2,zero,3c1c <prvRecursiveMutexBlockingTask+0x78>
		{
			if( xControllingIsSuspended != pdTRUE )
    3bd0:	d0a8ed17 	ldw	r2,-23628(gp)
    3bd4:	10800060 	cmpeqi	r2,r2,1
    3bd8:	1000031e 	bne	r2,zero,3be8 <prvRecursiveMutexBlockingTask+0x44>
			{
				/* Did not expect to execute until the controlling task was
				suspended. */
				xErrorOccurred = pdTRUE;
    3bdc:	00800044 	movi	r2,1
    3be0:	d0a8ec15 	stw	r2,-23632(gp)
    3be4:	00000f06 	br	3c24 <prvRecursiveMutexBlockingTask+0x80>
			}
			else
			{
				/* Give the mutex back before suspending ourselves to allow
				the polling task to obtain the mutex. */
				if( xSemaphoreGiveRecursive( xMutex ) != pdPASS )
    3be8:	d0a8eb17 	ldw	r2,-23636(gp)
    3bec:	1009883a 	mov	r4,r2
    3bf0:	000e7dc0 	call	e7dc <xQueueGiveMutexRecursive>
    3bf4:	10800060 	cmpeqi	r2,r2,1
    3bf8:	1000021e 	bne	r2,zero,3c04 <prvRecursiveMutexBlockingTask+0x60>
				{
					xErrorOccurred = pdTRUE;
    3bfc:	00800044 	movi	r2,1
    3c00:	d0a8ec15 	stw	r2,-23632(gp)
				}

				xBlockingIsSuspended = pdTRUE;
    3c04:	00800044 	movi	r2,1
    3c08:	d0a8ee15 	stw	r2,-23624(gp)
				vTaskSuspend( NULL );
    3c0c:	0009883a 	mov	r4,zero
    3c10:	000fb300 	call	fb30 <vTaskSuspend>
				xBlockingIsSuspended = pdFALSE;
    3c14:	d028ee15 	stw	zero,-23624(gp)
    3c18:	00000206 	br	3c24 <prvRecursiveMutexBlockingTask+0x80>
		}
		else
		{
			/* We should not leave the xSemaphoreTakeRecursive() function
			until the mutex was obtained. */
			xErrorOccurred = pdTRUE;
    3c1c:	00800044 	movi	r2,1
    3c20:	d0a8ec15 	stw	r2,-23632(gp)
		}

		/* The controlling and blocking tasks should be in lock step. */
		if( uxControllingCycles != ( uxBlockingCycles + 1 ) )
    3c24:	d0a8f017 	ldw	r2,-23616(gp)
    3c28:	10c00044 	addi	r3,r2,1
    3c2c:	d0a8ef17 	ldw	r2,-23620(gp)
    3c30:	18800226 	beq	r3,r2,3c3c <prvRecursiveMutexBlockingTask+0x98>
		{
			xErrorOccurred = pdTRUE;
    3c34:	00800044 	movi	r2,1
    3c38:	d0a8ec15 	stw	r2,-23632(gp)
		}

		/* Keep count of the number of cycles this task has performed so a 
		stall can be detected. */
		uxBlockingCycles++;
    3c3c:	d0a8f017 	ldw	r2,-23616(gp)
    3c40:	10800044 	addi	r2,r2,1
    3c44:	d0a8f015 	stw	r2,-23616(gp)
	}
    3c48:	003fdb06 	br	3bb8 <prvRecursiveMutexBlockingTask+0x14>

00003c4c <prvRecursiveMutexPollingTask>:
}
/*-----------------------------------------------------------*/

static void prvRecursiveMutexPollingTask( void *pvParameters )
{
    3c4c:	defffd04 	addi	sp,sp,-12
    3c50:	dfc00215 	stw	ra,8(sp)
    3c54:	df000115 	stw	fp,4(sp)
    3c58:	df000104 	addi	fp,sp,4
    3c5c:	e13fff15 	stw	r4,-4(fp)
    3c60:	00000106 	br	3c68 <prvRecursiveMutexPollingTask+0x1c>
		#if configUSE_PREEMPTION == 0
		{
			taskYIELD();
		}
		#endif
	}
    3c64:	0001883a 	nop
	for( ;; )
	{
		/* Keep attempting to obtain the mutex.  We should only obtain it when
		the blocking task has suspended itself, which in turn should only
		happen when the controlling task is also suspended. */
		if( xSemaphoreTakeRecursive( xMutex, recmuNO_DELAY ) == pdPASS )
    3c68:	d0a8eb17 	ldw	r2,-23636(gp)
    3c6c:	1009883a 	mov	r4,r2
    3c70:	000b883a 	mov	r5,zero
    3c74:	000e8640 	call	e864 <xQueueTakeMutexRecursive>
    3c78:	10800058 	cmpnei	r2,r2,1
    3c7c:	103ff91e 	bne	r2,zero,3c64 <prvRecursiveMutexPollingTask+0x18>
		{
			/* Is the blocking task suspended? */
			if( ( xBlockingIsSuspended != pdTRUE ) || ( xControllingIsSuspended != pdTRUE ) )
    3c80:	d0a8ee17 	ldw	r2,-23624(gp)
    3c84:	10800058 	cmpnei	r2,r2,1
    3c88:	1000031e 	bne	r2,zero,3c98 <prvRecursiveMutexPollingTask+0x4c>
    3c8c:	d0a8ed17 	ldw	r2,-23628(gp)
    3c90:	10800060 	cmpeqi	r2,r2,1
    3c94:	1000031e 	bne	r2,zero,3ca4 <prvRecursiveMutexPollingTask+0x58>
			{
				xErrorOccurred = pdTRUE;
    3c98:	00800044 	movi	r2,1
    3c9c:	d0a8ec15 	stw	r2,-23632(gp)
		#if configUSE_PREEMPTION == 0
		{
			taskYIELD();
		}
		#endif
	}
    3ca0:	003ff006 	br	3c64 <prvRecursiveMutexPollingTask+0x18>
			}
			else
			{
				/* Keep count of the number of cycles this task has performed 
				so a stall can be detected. */
				uxPollingCycles++;
    3ca4:	d0a8f117 	ldw	r2,-23612(gp)
    3ca8:	10800044 	addi	r2,r2,1
    3cac:	d0a8f115 	stw	r2,-23612(gp)
				will then inherit the higher priority.  The Blocking task will
				block indefinitely when it attempts to obtain the mutex, the
				Controlling task will only block for a fixed period and an
				error will be latched if the polling task has not returned the
				mutex by the time this fixed period has expired. */
				vTaskResume( xBlockingTaskHandle );
    3cb0:	d0a8f317 	ldw	r2,-23604(gp)
    3cb4:	1009883a 	mov	r4,r2
    3cb8:	000fc800 	call	fc80 <vTaskResume>
                vTaskResume( xControllingTaskHandle );
    3cbc:	d0a8f217 	ldw	r2,-23608(gp)
    3cc0:	1009883a 	mov	r4,r2
    3cc4:	000fc800 	call	fc80 <vTaskResume>
			
				/* The other two tasks should now have executed and no longer
				be suspended. */
				if( ( xBlockingIsSuspended == pdTRUE ) || ( xControllingIsSuspended == pdTRUE ) )
    3cc8:	d0a8ee17 	ldw	r2,-23624(gp)
    3ccc:	10800060 	cmpeqi	r2,r2,1
    3cd0:	1000031e 	bne	r2,zero,3ce0 <prvRecursiveMutexPollingTask+0x94>
    3cd4:	d0a8ed17 	ldw	r2,-23628(gp)
    3cd8:	10800058 	cmpnei	r2,r2,1
    3cdc:	1000021e 	bne	r2,zero,3ce8 <prvRecursiveMutexPollingTask+0x9c>
				{
					xErrorOccurred = pdTRUE;
    3ce0:	00800044 	movi	r2,1
    3ce4:	d0a8ec15 	stw	r2,-23632(gp)
				}				
			
				/* Release the mutex, disinheriting the higher priority again. */
				if( xSemaphoreGiveRecursive( xMutex ) != pdPASS )
    3ce8:	d0a8eb17 	ldw	r2,-23636(gp)
    3cec:	1009883a 	mov	r4,r2
    3cf0:	000e7dc0 	call	e7dc <xQueueGiveMutexRecursive>
    3cf4:	10800060 	cmpeqi	r2,r2,1
    3cf8:	103fda1e 	bne	r2,zero,3c64 <prvRecursiveMutexPollingTask+0x18>
				{
					xErrorOccurred = pdTRUE;
    3cfc:	00800044 	movi	r2,1
    3d00:	d0a8ec15 	stw	r2,-23632(gp)
		#if configUSE_PREEMPTION == 0
		{
			taskYIELD();
		}
		#endif
	}
    3d04:	003fd706 	br	3c64 <prvRecursiveMutexPollingTask+0x18>

00003d08 <xAreRecursiveMutexTasksStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
portBASE_TYPE xAreRecursiveMutexTasksStillRunning( void )
{
    3d08:	defffe04 	addi	sp,sp,-8
    3d0c:	df000115 	stw	fp,4(sp)
    3d10:	df000104 	addi	fp,sp,4
portBASE_TYPE xReturn;
static unsigned portBASE_TYPE uxLastControllingCycles = 0, uxLastBlockingCycles = 0, uxLastPollingCycles = 0;

	/* Is the controlling task still cycling? */
	if( uxLastControllingCycles == uxControllingCycles )
    3d14:	d0e8f417 	ldw	r3,-23600(gp)
    3d18:	d0a8ef17 	ldw	r2,-23620(gp)
    3d1c:	1880031e 	bne	r3,r2,3d2c <xAreRecursiveMutexTasksStillRunning+0x24>
	{
		xErrorOccurred = pdTRUE;
    3d20:	00800044 	movi	r2,1
    3d24:	d0a8ec15 	stw	r2,-23632(gp)
    3d28:	00000206 	br	3d34 <xAreRecursiveMutexTasksStillRunning+0x2c>
	}
	else
	{
		uxLastControllingCycles = uxControllingCycles;
    3d2c:	d0a8ef17 	ldw	r2,-23620(gp)
    3d30:	d0a8f415 	stw	r2,-23600(gp)
	}

	/* Is the blocking task still cycling? */
	if( uxLastBlockingCycles == uxBlockingCycles )
    3d34:	d0e8f517 	ldw	r3,-23596(gp)
    3d38:	d0a8f017 	ldw	r2,-23616(gp)
    3d3c:	1880031e 	bne	r3,r2,3d4c <xAreRecursiveMutexTasksStillRunning+0x44>
	{
		xErrorOccurred = pdTRUE;
    3d40:	00800044 	movi	r2,1
    3d44:	d0a8ec15 	stw	r2,-23632(gp)
    3d48:	00000206 	br	3d54 <xAreRecursiveMutexTasksStillRunning+0x4c>
	}
	else
	{
		uxLastBlockingCycles = uxBlockingCycles;
    3d4c:	d0a8f017 	ldw	r2,-23616(gp)
    3d50:	d0a8f515 	stw	r2,-23596(gp)
	}

	/* Is the polling task still cycling? */
	if( uxLastPollingCycles == uxPollingCycles )
    3d54:	d0e8f617 	ldw	r3,-23592(gp)
    3d58:	d0a8f117 	ldw	r2,-23612(gp)
    3d5c:	1880031e 	bne	r3,r2,3d6c <xAreRecursiveMutexTasksStillRunning+0x64>
	{
		xErrorOccurred = pdTRUE;
    3d60:	00800044 	movi	r2,1
    3d64:	d0a8ec15 	stw	r2,-23632(gp)
    3d68:	00000206 	br	3d74 <xAreRecursiveMutexTasksStillRunning+0x6c>
	}
	else
	{
		uxLastPollingCycles = uxPollingCycles;
    3d6c:	d0a8f117 	ldw	r2,-23612(gp)
    3d70:	d0a8f615 	stw	r2,-23592(gp)
	}

	if( xErrorOccurred == pdTRUE )
    3d74:	d0a8ec17 	ldw	r2,-23632(gp)
    3d78:	10800058 	cmpnei	r2,r2,1
    3d7c:	1000021e 	bne	r2,zero,3d88 <xAreRecursiveMutexTasksStillRunning+0x80>
	{
		xReturn = pdFAIL;
    3d80:	e03fff15 	stw	zero,-4(fp)
    3d84:	00000206 	br	3d90 <xAreRecursiveMutexTasksStillRunning+0x88>
	}
	else
	{
		xReturn = pdTRUE;
    3d88:	00800044 	movi	r2,1
    3d8c:	e0bfff15 	stw	r2,-4(fp)
	}

	return xReturn;
    3d90:	e0bfff17 	ldw	r2,-4(fp)
}
    3d94:	e037883a 	mov	sp,fp
    3d98:	df000017 	ldw	fp,0(sp)
    3d9c:	dec00104 	addi	sp,sp,4
    3da0:	f800283a 	ret

00003da4 <vStartSemaphoreTasks>:
static volatile short sNextCheckVariable = 0;

/*-----------------------------------------------------------*/

void vStartSemaphoreTasks( unsigned portBASE_TYPE uxPriority )
{
    3da4:	defff604 	addi	sp,sp,-40
    3da8:	dfc00915 	stw	ra,36(sp)
    3dac:	df000815 	stw	fp,32(sp)
    3db0:	df000804 	addi	fp,sp,32
    3db4:	e13fff15 	stw	r4,-4(fp)
xSemaphoreParameters *pxFirstSemaphoreParameters, *pxSecondSemaphoreParameters;
const portTickType xBlockTime = ( portTickType ) 100;
    3db8:	00801904 	movi	r2,100
    3dbc:	e0bffc15 	stw	r2,-16(fp)

	/* Create the structure used to pass parameters to the first two tasks. */
	pxFirstSemaphoreParameters = ( xSemaphoreParameters * ) pvPortMalloc( sizeof( xSemaphoreParameters ) );
    3dc0:	01000304 	movi	r4,12
    3dc4:	000e4980 	call	e498 <pvPortMalloc>
    3dc8:	e0bffd15 	stw	r2,-12(fp)

	if( pxFirstSemaphoreParameters != NULL )
    3dcc:	e0bffd17 	ldw	r2,-12(fp)
    3dd0:	10003326 	beq	r2,zero,3ea0 <vStartSemaphoreTasks+0xfc>
	{
		/* Create the semaphore used by the first two tasks. */
		vSemaphoreCreateBinary( pxFirstSemaphoreParameters->xSemaphore );
    3dd4:	01000044 	movi	r4,1
    3dd8:	000b883a 	mov	r5,zero
    3ddc:	018000c4 	movi	r6,3
    3de0:	000e6380 	call	e638 <xQueueGenericCreate>
    3de4:	e0fffd17 	ldw	r3,-12(fp)
    3de8:	18800015 	stw	r2,0(r3)
    3dec:	e0bffd17 	ldw	r2,-12(fp)
    3df0:	10800017 	ldw	r2,0(r2)
    3df4:	10000726 	beq	r2,zero,3e14 <vStartSemaphoreTasks+0x70>
    3df8:	e0bffd17 	ldw	r2,-12(fp)
    3dfc:	10800017 	ldw	r2,0(r2)
    3e00:	1009883a 	mov	r4,r2
    3e04:	000b883a 	mov	r5,zero
    3e08:	000d883a 	mov	r6,zero
    3e0c:	000f883a 	mov	r7,zero
    3e10:	000e95c0 	call	e95c <xQueueGenericSend>

		if( pxFirstSemaphoreParameters->xSemaphore != NULL )
    3e14:	e0bffd17 	ldw	r2,-12(fp)
    3e18:	10800017 	ldw	r2,0(r2)
    3e1c:	10002026 	beq	r2,zero,3ea0 <vStartSemaphoreTasks+0xfc>
		{
			/* Create the variable which is to be shared by the first two tasks. */
			pxFirstSemaphoreParameters->pulSharedVariable = ( unsigned long * ) pvPortMalloc( sizeof( unsigned long ) );
    3e20:	01000104 	movi	r4,4
    3e24:	000e4980 	call	e498 <pvPortMalloc>
    3e28:	e0fffd17 	ldw	r3,-12(fp)
    3e2c:	18800115 	stw	r2,4(r3)

			/* Initialise the share variable to the value the tasks expect. */
			*( pxFirstSemaphoreParameters->pulSharedVariable ) = semtstNON_BLOCKING_EXPECTED_VALUE;
    3e30:	e0bffd17 	ldw	r2,-12(fp)
    3e34:	10800117 	ldw	r2,4(r2)
    3e38:	00c03fc4 	movi	r3,255
    3e3c:	10c00015 	stw	r3,0(r2)

			/* The first two tasks do not block on semaphore calls. */
			pxFirstSemaphoreParameters->xBlockTime = ( portTickType ) 0;
    3e40:	e0bffd17 	ldw	r2,-12(fp)
    3e44:	10000215 	stw	zero,8(r2)

			/* Spawn the first two tasks.  As they poll they operate at the idle priority. */
			xTaskCreate( prvSemaphoreTest, ( signed char * ) "PolSEM1", semtstSTACK_SIZE, ( void * ) pxFirstSemaphoreParameters, tskIDLE_PRIORITY, ( xTaskHandle * ) NULL );
    3e48:	d8000015 	stw	zero,0(sp)
    3e4c:	d8000115 	stw	zero,4(sp)
    3e50:	d8000215 	stw	zero,8(sp)
    3e54:	d8000315 	stw	zero,12(sp)
    3e58:	01000034 	movhi	r4,0
    3e5c:	210fe804 	addi	r4,r4,16288
    3e60:	01400134 	movhi	r5,4
    3e64:	297fb504 	addi	r5,r5,-300
    3e68:	018c9604 	movi	r6,12888
    3e6c:	e1fffd17 	ldw	r7,-12(fp)
    3e70:	000f5140 	call	f514 <xTaskGenericCreate>
			xTaskCreate( prvSemaphoreTest, ( signed char * ) "PolSEM2", semtstSTACK_SIZE, ( void * ) pxFirstSemaphoreParameters, tskIDLE_PRIORITY, ( xTaskHandle * ) NULL );
    3e74:	d8000015 	stw	zero,0(sp)
    3e78:	d8000115 	stw	zero,4(sp)
    3e7c:	d8000215 	stw	zero,8(sp)
    3e80:	d8000315 	stw	zero,12(sp)
    3e84:	01000034 	movhi	r4,0
    3e88:	210fe804 	addi	r4,r4,16288
    3e8c:	01400134 	movhi	r5,4
    3e90:	297fb704 	addi	r5,r5,-292
    3e94:	018c9604 	movi	r6,12888
    3e98:	e1fffd17 	ldw	r7,-12(fp)
    3e9c:	000f5140 	call	f514 <xTaskGenericCreate>
		}
	}

	/* Do exactly the same to create the second set of tasks, only this time 
	provide a block time for the semaphore calls. */
	pxSecondSemaphoreParameters = ( xSemaphoreParameters * ) pvPortMalloc( sizeof( xSemaphoreParameters ) );
    3ea0:	01000304 	movi	r4,12
    3ea4:	000e4980 	call	e498 <pvPortMalloc>
    3ea8:	e0bffe15 	stw	r2,-8(fp)
	if( pxSecondSemaphoreParameters != NULL )
    3eac:	e0bffe17 	ldw	r2,-8(fp)
    3eb0:	10003626 	beq	r2,zero,3f8c <vStartSemaphoreTasks+0x1e8>
	{
		vSemaphoreCreateBinary( pxSecondSemaphoreParameters->xSemaphore );
    3eb4:	01000044 	movi	r4,1
    3eb8:	000b883a 	mov	r5,zero
    3ebc:	018000c4 	movi	r6,3
    3ec0:	000e6380 	call	e638 <xQueueGenericCreate>
    3ec4:	e0fffe17 	ldw	r3,-8(fp)
    3ec8:	18800015 	stw	r2,0(r3)
    3ecc:	e0bffe17 	ldw	r2,-8(fp)
    3ed0:	10800017 	ldw	r2,0(r2)
    3ed4:	10000726 	beq	r2,zero,3ef4 <vStartSemaphoreTasks+0x150>
    3ed8:	e0bffe17 	ldw	r2,-8(fp)
    3edc:	10800017 	ldw	r2,0(r2)
    3ee0:	1009883a 	mov	r4,r2
    3ee4:	000b883a 	mov	r5,zero
    3ee8:	000d883a 	mov	r6,zero
    3eec:	000f883a 	mov	r7,zero
    3ef0:	000e95c0 	call	e95c <xQueueGenericSend>

		if( pxSecondSemaphoreParameters->xSemaphore != NULL )
    3ef4:	e0bffe17 	ldw	r2,-8(fp)
    3ef8:	10800017 	ldw	r2,0(r2)
    3efc:	10002326 	beq	r2,zero,3f8c <vStartSemaphoreTasks+0x1e8>
		{
			pxSecondSemaphoreParameters->pulSharedVariable = ( unsigned long * ) pvPortMalloc( sizeof( unsigned long ) );
    3f00:	01000104 	movi	r4,4
    3f04:	000e4980 	call	e498 <pvPortMalloc>
    3f08:	e0fffe17 	ldw	r3,-8(fp)
    3f0c:	18800115 	stw	r2,4(r3)
			*( pxSecondSemaphoreParameters->pulSharedVariable ) = semtstBLOCKING_EXPECTED_VALUE;
    3f10:	e0bffe17 	ldw	r2,-8(fp)
    3f14:	10800117 	ldw	r2,4(r2)
    3f18:	00c3ffc4 	movi	r3,4095
    3f1c:	10c00015 	stw	r3,0(r2)
			pxSecondSemaphoreParameters->xBlockTime = xBlockTime / portTICK_RATE_MS;
    3f20:	e0bffe17 	ldw	r2,-8(fp)
    3f24:	e0fffc17 	ldw	r3,-16(fp)
    3f28:	10c00215 	stw	r3,8(r2)

			xTaskCreate( prvSemaphoreTest, ( signed char * ) "BlkSEM1", semtstSTACK_SIZE, ( void * ) pxSecondSemaphoreParameters, uxPriority, ( xTaskHandle * ) NULL );
    3f2c:	e0bfff17 	ldw	r2,-4(fp)
    3f30:	d8800015 	stw	r2,0(sp)
    3f34:	d8000115 	stw	zero,4(sp)
    3f38:	d8000215 	stw	zero,8(sp)
    3f3c:	d8000315 	stw	zero,12(sp)
    3f40:	01000034 	movhi	r4,0
    3f44:	210fe804 	addi	r4,r4,16288
    3f48:	01400134 	movhi	r5,4
    3f4c:	297fb904 	addi	r5,r5,-284
    3f50:	018c9604 	movi	r6,12888
    3f54:	e1fffe17 	ldw	r7,-8(fp)
    3f58:	000f5140 	call	f514 <xTaskGenericCreate>
			xTaskCreate( prvSemaphoreTest, ( signed char * ) "BlkSEM2", semtstSTACK_SIZE, ( void * ) pxSecondSemaphoreParameters, uxPriority, ( xTaskHandle * ) NULL );
    3f5c:	e0bfff17 	ldw	r2,-4(fp)
    3f60:	d8800015 	stw	r2,0(sp)
    3f64:	d8000115 	stw	zero,4(sp)
    3f68:	d8000215 	stw	zero,8(sp)
    3f6c:	d8000315 	stw	zero,12(sp)
    3f70:	01000034 	movhi	r4,0
    3f74:	210fe804 	addi	r4,r4,16288
    3f78:	01400134 	movhi	r5,4
    3f7c:	297fbb04 	addi	r5,r5,-276
    3f80:	018c9604 	movi	r6,12888
    3f84:	e1fffe17 	ldw	r7,-8(fp)
    3f88:	000f5140 	call	f514 <xTaskGenericCreate>
	is not being used.  The call to vQueueAddToRegistry() will be removed
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( ( xQueueHandle ) pxFirstSemaphoreParameters->xSemaphore, ( signed char * ) "Counting_Sem_1" );
	vQueueAddToRegistry( ( xQueueHandle ) pxSecondSemaphoreParameters->xSemaphore, ( signed char * ) "Counting_Sem_2" );
}
    3f8c:	e037883a 	mov	sp,fp
    3f90:	dfc00117 	ldw	ra,4(sp)
    3f94:	df000017 	ldw	fp,0(sp)
    3f98:	dec00204 	addi	sp,sp,8
    3f9c:	f800283a 	ret

00003fa0 <prvSemaphoreTest>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvSemaphoreTest, pvParameters )
{
    3fa0:	defff804 	addi	sp,sp,-32
    3fa4:	dfc00715 	stw	ra,28(sp)
    3fa8:	df000615 	stw	fp,24(sp)
    3fac:	df000604 	addi	fp,sp,24
    3fb0:	e13fff15 	stw	r4,-4(fp)
xSemaphoreParameters *pxParameters;
volatile unsigned long *pulSharedVariable, ulExpectedValue;
unsigned long ulCounter;
short sError = pdFALSE, sCheckVariableToUse;
    3fb4:	e03ffb0d 	sth	zero,-20(fp)

	/* See which check variable to use.  sNextCheckVariable is not semaphore 
	protected! */
	portENTER_CRITICAL();
    3fb8:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    3fbc:	10000126 	beq	r2,zero,3fc4 <prvSemaphoreTest+0x24>
    3fc0:	00110d00 	call	110d0 <vTaskEnterCritical>
		sCheckVariableToUse = sNextCheckVariable;
    3fc4:	d0a8f90b 	ldhu	r2,-23580(gp)
    3fc8:	e0bffb8d 	sth	r2,-18(fp)
		sNextCheckVariable++;
    3fcc:	d0a8f90b 	ldhu	r2,-23580(gp)
    3fd0:	10800044 	addi	r2,r2,1
    3fd4:	d0a8f90d 	sth	r2,-23580(gp)
	portEXIT_CRITICAL();
    3fd8:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    3fdc:	10000126 	beq	r2,zero,3fe4 <prvSemaphoreTest+0x44>
    3fe0:	00111100 	call	11110 <vTaskExitCritical>

	/* A structure is passed in as the parameter.  This contains the shared 
	variable being guarded. */
	pxParameters = ( xSemaphoreParameters * ) pvParameters;
    3fe4:	e0bfff17 	ldw	r2,-4(fp)
    3fe8:	e0bffc15 	stw	r2,-16(fp)
	pulSharedVariable = pxParameters->pulSharedVariable;
    3fec:	e0bffc17 	ldw	r2,-16(fp)
    3ff0:	10800117 	ldw	r2,4(r2)
    3ff4:	e0bffd15 	stw	r2,-12(fp)

	/* If we are blocking we use a much higher count to ensure loads of context
	switches occur during the count. */
	if( pxParameters->xBlockTime > ( portTickType ) 0 )
    3ff8:	e0bffc17 	ldw	r2,-16(fp)
    3ffc:	10800217 	ldw	r2,8(r2)
    4000:	10000326 	beq	r2,zero,4010 <prvSemaphoreTest+0x70>
	{
		ulExpectedValue = semtstBLOCKING_EXPECTED_VALUE;
    4004:	0083ffc4 	movi	r2,4095
    4008:	e0bffe15 	stw	r2,-8(fp)
    400c:	00000406 	br	4020 <prvSemaphoreTest+0x80>
	}
	else
	{
		ulExpectedValue = semtstNON_BLOCKING_EXPECTED_VALUE;
    4010:	00803fc4 	movi	r2,255
    4014:	e0bffe15 	stw	r2,-8(fp)
    4018:	00000106 	br	4020 <prvSemaphoreTest+0x80>
				processor.  We are not blocking when attempting to obtain the
				semaphore. */
				taskYIELD();
			}
		}
	}
    401c:	0001883a 	nop
	}

	for( ;; )
	{
		/* Try to obtain the semaphore. */
		if( xSemaphoreTake( pxParameters->xSemaphore, pxParameters->xBlockTime ) == pdPASS )
    4020:	e0bffc17 	ldw	r2,-16(fp)
    4024:	10c00017 	ldw	r3,0(r2)
    4028:	e0bffc17 	ldw	r2,-16(fp)
    402c:	10800217 	ldw	r2,8(r2)
    4030:	1809883a 	mov	r4,r3
    4034:	000b883a 	mov	r5,zero
    4038:	100d883a 	mov	r6,r2
    403c:	000f883a 	mov	r7,zero
    4040:	000ebd80 	call	ebd8 <xQueueGenericReceive>
    4044:	10800058 	cmpnei	r2,r2,1
    4048:	1000361e 	bne	r2,zero,4124 <prvSemaphoreTest+0x184>
		{
			/* We have the semaphore and so expect any other tasks using the
			shared variable to have left it in the state we expect to find
			it. */
			if( *pulSharedVariable != ulExpectedValue )
    404c:	e0bffd17 	ldw	r2,-12(fp)
    4050:	10c00017 	ldw	r3,0(r2)
    4054:	e0bffe17 	ldw	r2,-8(fp)
    4058:	18800226 	beq	r3,r2,4064 <prvSemaphoreTest+0xc4>
			{
				sError = pdTRUE;
    405c:	00800044 	movi	r2,1
    4060:	e0bffb0d 	sth	r2,-20(fp)
			}
			
			/* Clear the variable, then count it back up to the expected value
			before releasing the semaphore.  Would expect a context switch or
			two during this time. */
			for( ulCounter = ( unsigned long ) 0; ulCounter <= ulExpectedValue; ulCounter++ )
    4064:	e03ffa15 	stw	zero,-24(fp)
    4068:	00000c06 	br	409c <prvSemaphoreTest+0xfc>
			{
				*pulSharedVariable = ulCounter;
    406c:	e0bffd17 	ldw	r2,-12(fp)
    4070:	e0fffa17 	ldw	r3,-24(fp)
    4074:	10c00015 	stw	r3,0(r2)
				if( *pulSharedVariable != ulCounter )
    4078:	e0bffd17 	ldw	r2,-12(fp)
    407c:	10c00017 	ldw	r3,0(r2)
    4080:	e0bffa17 	ldw	r2,-24(fp)
    4084:	18800226 	beq	r3,r2,4090 <prvSemaphoreTest+0xf0>
				{
					sError = pdTRUE;
    4088:	00800044 	movi	r2,1
    408c:	e0bffb0d 	sth	r2,-20(fp)
			}
			
			/* Clear the variable, then count it back up to the expected value
			before releasing the semaphore.  Would expect a context switch or
			two during this time. */
			for( ulCounter = ( unsigned long ) 0; ulCounter <= ulExpectedValue; ulCounter++ )
    4090:	e0bffa17 	ldw	r2,-24(fp)
    4094:	10800044 	addi	r2,r2,1
    4098:	e0bffa15 	stw	r2,-24(fp)
    409c:	e0fffe17 	ldw	r3,-8(fp)
    40a0:	e0bffa17 	ldw	r2,-24(fp)
    40a4:	18bff12e 	bgeu	r3,r2,406c <prvSemaphoreTest+0xcc>
				}
			}

			/* Release the semaphore, and if no errors have occurred increment the check
			variable. */
			if(	xSemaphoreGive( pxParameters->xSemaphore ) == pdFALSE )
    40a8:	e0bffc17 	ldw	r2,-16(fp)
    40ac:	10800017 	ldw	r2,0(r2)
    40b0:	1009883a 	mov	r4,r2
    40b4:	000b883a 	mov	r5,zero
    40b8:	000d883a 	mov	r6,zero
    40bc:	000f883a 	mov	r7,zero
    40c0:	000e95c0 	call	e95c <xQueueGenericSend>
    40c4:	1000021e 	bne	r2,zero,40d0 <prvSemaphoreTest+0x130>
			{
				sError = pdTRUE;
    40c8:	00800044 	movi	r2,1
    40cc:	e0bffb0d 	sth	r2,-20(fp)
			}

			if( sError == pdFALSE )
    40d0:	e0bffb0f 	ldh	r2,-20(fp)
    40d4:	10000d1e 	bne	r2,zero,410c <prvSemaphoreTest+0x16c>
			{
				if( sCheckVariableToUse < semtstNUM_TASKS )
    40d8:	e0bffb8f 	ldh	r2,-18(fp)
    40dc:	10800108 	cmpgei	r2,r2,4
    40e0:	10000a1e 	bne	r2,zero,410c <prvSemaphoreTest+0x16c>
				{
					( sCheckVariables[ sCheckVariableToUse ] )++;
    40e4:	e0bffb8f 	ldh	r2,-18(fp)
    40e8:	1089883a 	add	r4,r2,r2
    40ec:	d0e8f704 	addi	r3,gp,-23588
    40f0:	20c7883a 	add	r3,r4,r3
    40f4:	18c0000b 	ldhu	r3,0(r3)
    40f8:	18c00044 	addi	r3,r3,1
    40fc:	1089883a 	add	r4,r2,r2
    4100:	d0a8f704 	addi	r2,gp,-23588
    4104:	2085883a 	add	r2,r4,r2
    4108:	10c0000d 	sth	r3,0(r2)
			/* If we have a block time then we are running at a priority higher
			than the idle priority.  This task takes a long time to complete
			a cycle	(deliberately so to test the guarding) so will be starving
			out lower priority tasks.  Block for some time to allow give lower
			priority tasks some processor time. */
			vTaskDelay( pxParameters->xBlockTime * semtstDELAY_FACTOR );
    410c:	e0bffc17 	ldw	r2,-16(fp)
    4110:	10800217 	ldw	r2,8(r2)
    4114:	108002a4 	muli	r2,r2,10
    4118:	1009883a 	mov	r4,r2
    411c:	000f8c00 	call	f8c0 <vTaskDelay>
				processor.  We are not blocking when attempting to obtain the
				semaphore. */
				taskYIELD();
			}
		}
	}
    4120:	003fbe06 	br	401c <prvSemaphoreTest+0x7c>
			priority tasks some processor time. */
			vTaskDelay( pxParameters->xBlockTime * semtstDELAY_FACTOR );
		}
		else
		{
			if( pxParameters->xBlockTime == ( portTickType ) 0 )
    4124:	e0bffc17 	ldw	r2,-16(fp)
    4128:	10800217 	ldw	r2,8(r2)
    412c:	103fbb1e 	bne	r2,zero,401c <prvSemaphoreTest+0x7c>
			{
				/* We have not got the semaphore yet, so no point using the
				processor.  We are not blocking when attempting to obtain the
				semaphore. */
				taskYIELD();
    4130:	003b683a 	trap	0
			}
		}
	}
    4134:	003fb906 	br	401c <prvSemaphoreTest+0x7c>

00004138 <xAreSemaphoreTasksStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
portBASE_TYPE xAreSemaphoreTasksStillRunning( void )
{
    4138:	defffd04 	addi	sp,sp,-12
    413c:	df000215 	stw	fp,8(sp)
    4140:	df000204 	addi	fp,sp,8
static short sLastCheckVariables[ semtstNUM_TASKS ] = { 0 };
portBASE_TYPE xTask, xReturn = pdTRUE;
    4144:	00800044 	movi	r2,1
    4148:	e0bfff15 	stw	r2,-4(fp)

	for( xTask = 0; xTask < semtstNUM_TASKS; xTask++ )
    414c:	e03ffe15 	stw	zero,-8(fp)
    4150:	00001f06 	br	41d0 <xAreSemaphoreTasksStillRunning+0x98>
	{
		if( sLastCheckVariables[ xTask ] == sCheckVariables[ xTask ] )
    4154:	e0bffe17 	ldw	r2,-8(fp)
    4158:	1087883a 	add	r3,r2,r2
    415c:	d0a8f984 	addi	r2,gp,-23578
    4160:	1885883a 	add	r2,r3,r2
    4164:	10c0000b 	ldhu	r3,0(r2)
    4168:	e0bffe17 	ldw	r2,-8(fp)
    416c:	1089883a 	add	r4,r2,r2
    4170:	d0a8f704 	addi	r2,gp,-23588
    4174:	2085883a 	add	r2,r4,r2
    4178:	1080000b 	ldhu	r2,0(r2)
    417c:	18ffffcc 	andi	r3,r3,65535
    4180:	18e0001c 	xori	r3,r3,32768
    4184:	18e00004 	addi	r3,r3,-32768
    4188:	10bfffcc 	andi	r2,r2,65535
    418c:	10a0001c 	xori	r2,r2,32768
    4190:	10a00004 	addi	r2,r2,-32768
    4194:	1880011e 	bne	r3,r2,419c <xAreSemaphoreTasksStillRunning+0x64>
		{
			xReturn = pdFALSE;
    4198:	e03fff15 	stw	zero,-4(fp)
		}

		sLastCheckVariables[ xTask ] = sCheckVariables[ xTask ];
    419c:	e0bffe17 	ldw	r2,-8(fp)
    41a0:	1087883a 	add	r3,r2,r2
    41a4:	d0a8f704 	addi	r2,gp,-23588
    41a8:	1885883a 	add	r2,r3,r2
    41ac:	10c0000b 	ldhu	r3,0(r2)
    41b0:	e0bffe17 	ldw	r2,-8(fp)
    41b4:	1089883a 	add	r4,r2,r2
    41b8:	d0a8f984 	addi	r2,gp,-23578
    41bc:	2085883a 	add	r2,r4,r2
    41c0:	10c0000d 	sth	r3,0(r2)
portBASE_TYPE xAreSemaphoreTasksStillRunning( void )
{
static short sLastCheckVariables[ semtstNUM_TASKS ] = { 0 };
portBASE_TYPE xTask, xReturn = pdTRUE;

	for( xTask = 0; xTask < semtstNUM_TASKS; xTask++ )
    41c4:	e0bffe17 	ldw	r2,-8(fp)
    41c8:	10800044 	addi	r2,r2,1
    41cc:	e0bffe15 	stw	r2,-8(fp)
    41d0:	e0bffe17 	ldw	r2,-8(fp)
    41d4:	10800110 	cmplti	r2,r2,4
    41d8:	103fde1e 	bne	r2,zero,4154 <xAreSemaphoreTasksStillRunning+0x1c>
		}

		sLastCheckVariables[ xTask ] = sCheckVariables[ xTask ];
	}

	return xReturn;
    41dc:	e0bfff17 	ldw	r2,-4(fp)
}
    41e0:	e037883a 	mov	sp,fp
    41e4:	df000017 	ldw	fp,0(sp)
    41e8:	dec00104 	addi	sp,sp,4
    41ec:	f800283a 	ret

000041f0 <memcpy>:
    41f0:	00c003c4 	movi	r3,15
    41f4:	2005883a 	mov	r2,r4
    41f8:	3009883a 	mov	r4,r6
    41fc:	1980032e 	bgeu	r3,r6,420c <memcpy+0x1c>
    4200:	2886b03a 	or	r3,r5,r2
    4204:	18c000cc 	andi	r3,r3,3
    4208:	18000926 	beq	r3,zero,4230 <memcpy+0x40>
    420c:	1007883a 	mov	r3,r2
    4210:	290f883a 	add	r7,r5,r4
    4214:	20000526 	beq	r4,zero,422c <memcpy+0x3c>
    4218:	29800003 	ldbu	r6,0(r5)
    421c:	18c00044 	addi	r3,r3,1
    4220:	29400044 	addi	r5,r5,1
    4224:	19bfffc5 	stb	r6,-1(r3)
    4228:	29fffb1e 	bne	r5,r7,4218 <memcpy+0x28>
    422c:	f800283a 	ret
    4230:	327ffc04 	addi	r9,r6,-16
    4234:	4812d13a 	srli	r9,r9,4
    4238:	11000404 	addi	r4,r2,16
    423c:	1007883a 	mov	r3,r2
    4240:	4810913a 	slli	r8,r9,4
    4244:	280f883a 	mov	r7,r5
    4248:	2209883a 	add	r4,r4,r8
    424c:	3a000017 	ldw	r8,0(r7)
    4250:	18c00404 	addi	r3,r3,16
    4254:	39c00404 	addi	r7,r7,16
    4258:	1a3ffc15 	stw	r8,-16(r3)
    425c:	3a3ffd17 	ldw	r8,-12(r7)
    4260:	1a3ffd15 	stw	r8,-12(r3)
    4264:	3a3ffe17 	ldw	r8,-8(r7)
    4268:	1a3ffe15 	stw	r8,-8(r3)
    426c:	3a3fff17 	ldw	r8,-4(r7)
    4270:	1a3fff15 	stw	r8,-4(r3)
    4274:	193ff51e 	bne	r3,r4,424c <memcpy+0x5c>
    4278:	49c00044 	addi	r7,r9,1
    427c:	380e913a 	slli	r7,r7,4
    4280:	310003cc 	andi	r4,r6,15
    4284:	018000c4 	movi	r6,3
    4288:	11c7883a 	add	r3,r2,r7
    428c:	29cb883a 	add	r5,r5,r7
    4290:	313fdf2e 	bgeu	r6,r4,4210 <memcpy+0x20>
    4294:	213fff04 	addi	r4,r4,-4
    4298:	2014d0ba 	srli	r10,r4,2
    429c:	1a400104 	addi	r9,r3,4
    42a0:	180d883a 	mov	r6,r3
    42a4:	528f883a 	add	r7,r10,r10
    42a8:	39cf883a 	add	r7,r7,r7
    42ac:	49d3883a 	add	r9,r9,r7
    42b0:	280f883a 	mov	r7,r5
    42b4:	3a000017 	ldw	r8,0(r7)
    42b8:	31800104 	addi	r6,r6,4
    42bc:	39c00104 	addi	r7,r7,4
    42c0:	323fff15 	stw	r8,-4(r6)
    42c4:	327ffb1e 	bne	r6,r9,42b4 <memcpy+0xc4>
    42c8:	51800044 	addi	r6,r10,1
    42cc:	52bfff24 	muli	r10,r10,-4
    42d0:	318d883a 	add	r6,r6,r6
    42d4:	318d883a 	add	r6,r6,r6
    42d8:	5109883a 	add	r4,r10,r4
    42dc:	298b883a 	add	r5,r5,r6
    42e0:	1987883a 	add	r3,r3,r6
    42e4:	003fca06 	br	4210 <memcpy+0x20>

000042e8 <memset>:
    42e8:	00c000c4 	movi	r3,3
    42ec:	2005883a 	mov	r2,r4
    42f0:	29403fcc 	andi	r5,r5,255
    42f4:	19802d2e 	bgeu	r3,r6,43ac <memset+0xc4>
    42f8:	20c6703a 	and	r3,r4,r3
    42fc:	18002e1e 	bne	r3,zero,43b8 <memset+0xd0>
    4300:	2806923a 	slli	r3,r5,8
    4304:	010003c4 	movi	r4,15
    4308:	3011883a 	mov	r8,r6
    430c:	1946b03a 	or	r3,r3,r5
    4310:	180e943a 	slli	r7,r3,16
    4314:	38ceb03a 	or	r7,r7,r3
    4318:	1007883a 	mov	r3,r2
    431c:	21800f2e 	bgeu	r4,r6,435c <memset+0x74>
    4320:	19c00015 	stw	r7,0(r3)
    4324:	19c00115 	stw	r7,4(r3)
    4328:	19c00215 	stw	r7,8(r3)
    432c:	19c00315 	stw	r7,12(r3)
    4330:	423ffc04 	addi	r8,r8,-16
    4334:	18c00404 	addi	r3,r3,16
    4338:	223ff936 	bltu	r4,r8,4320 <memset+0x38>
    433c:	30fffc04 	addi	r3,r6,-16
    4340:	1806d13a 	srli	r3,r3,4
    4344:	318003cc 	andi	r6,r6,15
    4348:	010000c4 	movi	r4,3
    434c:	18c00044 	addi	r3,r3,1
    4350:	1806913a 	slli	r3,r3,4
    4354:	10c7883a 	add	r3,r2,r3
    4358:	21800e2e 	bgeu	r4,r6,4394 <memset+0xac>
    435c:	1813883a 	mov	r9,r3
    4360:	3011883a 	mov	r8,r6
    4364:	010000c4 	movi	r4,3
    4368:	49c00015 	stw	r7,0(r9)
    436c:	423fff04 	addi	r8,r8,-4
    4370:	4a400104 	addi	r9,r9,4
    4374:	223ffc36 	bltu	r4,r8,4368 <memset+0x80>
    4378:	313fff04 	addi	r4,r6,-4
    437c:	2008d0ba 	srli	r4,r4,2
    4380:	318000cc 	andi	r6,r6,3
    4384:	21000044 	addi	r4,r4,1
    4388:	2109883a 	add	r4,r4,r4
    438c:	2109883a 	add	r4,r4,r4
    4390:	1907883a 	add	r3,r3,r4
    4394:	30000a26 	beq	r6,zero,43c0 <memset+0xd8>
    4398:	198d883a 	add	r6,r3,r6
    439c:	19400005 	stb	r5,0(r3)
    43a0:	18c00044 	addi	r3,r3,1
    43a4:	19bffd1e 	bne	r3,r6,439c <memset+0xb4>
    43a8:	f800283a 	ret
    43ac:	2007883a 	mov	r3,r4
    43b0:	303ff91e 	bne	r6,zero,4398 <memset+0xb0>
    43b4:	00000206 	br	43c0 <memset+0xd8>
    43b8:	2007883a 	mov	r3,r4
    43bc:	003ff606 	br	4398 <memset+0xb0>
    43c0:	f800283a 	ret

000043c4 <_perror_r>:
    43c4:	defffe04 	addi	sp,sp,-8
    43c8:	dc000015 	stw	r16,0(sp)
    43cc:	dfc00115 	stw	ra,4(sp)
    43d0:	2805883a 	mov	r2,r5
    43d4:	2021883a 	mov	r16,r4
    43d8:	28000226 	beq	r5,zero,43e4 <_perror_r+0x20>
    43dc:	28c00007 	ldb	r3,0(r5)
    43e0:	18000c1e 	bne	r3,zero,4414 <_perror_r+0x50>
    43e4:	81000017 	ldw	r4,0(r16)
    43e8:	00047380 	call	4738 <strerror>
    43ec:	10000326 	beq	r2,zero,43fc <_perror_r+0x38>
    43f0:	81400317 	ldw	r5,12(r16)
    43f4:	1009883a 	mov	r4,r2
    43f8:	0008d1c0 	call	8d1c <fputs>
    43fc:	81400317 	ldw	r5,12(r16)
    4400:	01000284 	movi	r4,10
    4404:	dfc00117 	ldw	ra,4(sp)
    4408:	dc000017 	ldw	r16,0(sp)
    440c:	dec00204 	addi	sp,sp,8
    4410:	0008c481 	jmpi	8c48 <fputc>
    4414:	21400317 	ldw	r5,12(r4)
    4418:	1009883a 	mov	r4,r2
    441c:	0008d1c0 	call	8d1c <fputs>
    4420:	81400317 	ldw	r5,12(r16)
    4424:	01000134 	movhi	r4,4
    4428:	213fbd04 	addi	r4,r4,-268
    442c:	0008d1c0 	call	8d1c <fputs>
    4430:	003fec06 	br	43e4 <_perror_r+0x20>

00004434 <perror>:
    4434:	00800134 	movhi	r2,4
    4438:	1095bf04 	addi	r2,r2,22268
    443c:	200b883a 	mov	r5,r4
    4440:	11000017 	ldw	r4,0(r2)
    4444:	00043c41 	jmpi	43c4 <_perror_r>

00004448 <_printf_r>:
    4448:	defffd04 	addi	sp,sp,-12
    444c:	dfc00015 	stw	ra,0(sp)
    4450:	d9800115 	stw	r6,4(sp)
    4454:	d9c00215 	stw	r7,8(sp)
    4458:	280d883a 	mov	r6,r5
    445c:	21400217 	ldw	r5,8(r4)
    4460:	d9c00104 	addi	r7,sp,4
    4464:	0004f600 	call	4f60 <___vfprintf_internal_r>
    4468:	dfc00017 	ldw	ra,0(sp)
    446c:	dec00304 	addi	sp,sp,12
    4470:	f800283a 	ret

00004474 <printf>:
    4474:	defffc04 	addi	sp,sp,-16
    4478:	dfc00015 	stw	ra,0(sp)
    447c:	d9400115 	stw	r5,4(sp)
    4480:	d9800215 	stw	r6,8(sp)
    4484:	d9c00315 	stw	r7,12(sp)
    4488:	00800134 	movhi	r2,4
    448c:	1095bf04 	addi	r2,r2,22268
    4490:	10800017 	ldw	r2,0(r2)
    4494:	200b883a 	mov	r5,r4
    4498:	d9800104 	addi	r6,sp,4
    449c:	11000217 	ldw	r4,8(r2)
    44a0:	0006d580 	call	6d58 <__vfprintf_internal>
    44a4:	dfc00017 	ldw	ra,0(sp)
    44a8:	dec00404 	addi	sp,sp,16
    44ac:	f800283a 	ret

000044b0 <_puts_r>:
    44b0:	defff604 	addi	sp,sp,-40
    44b4:	dc400815 	stw	r17,32(sp)
    44b8:	2023883a 	mov	r17,r4
    44bc:	2809883a 	mov	r4,r5
    44c0:	dc000715 	stw	r16,28(sp)
    44c4:	dfc00915 	stw	ra,36(sp)
    44c8:	2821883a 	mov	r16,r5
    44cc:	0004d9c0 	call	4d9c <strlen>
    44d0:	10c00044 	addi	r3,r2,1
    44d4:	d8800115 	stw	r2,4(sp)
    44d8:	89400217 	ldw	r5,8(r17)
    44dc:	00800134 	movhi	r2,4
    44e0:	10bfbe04 	addi	r2,r2,-264
    44e4:	d8800215 	stw	r2,8(sp)
    44e8:	00800044 	movi	r2,1
    44ec:	d8800315 	stw	r2,12(sp)
    44f0:	8809883a 	mov	r4,r17
    44f4:	00800084 	movi	r2,2
    44f8:	d9800404 	addi	r6,sp,16
    44fc:	dc000015 	stw	r16,0(sp)
    4500:	d8c00615 	stw	r3,24(sp)
    4504:	dec00415 	stw	sp,16(sp)
    4508:	d8800515 	stw	r2,20(sp)
    450c:	00091440 	call	9144 <__sfvwrite_r>
    4510:	1000061e 	bne	r2,zero,452c <_puts_r+0x7c>
    4514:	00800284 	movi	r2,10
    4518:	dfc00917 	ldw	ra,36(sp)
    451c:	dc400817 	ldw	r17,32(sp)
    4520:	dc000717 	ldw	r16,28(sp)
    4524:	dec00a04 	addi	sp,sp,40
    4528:	f800283a 	ret
    452c:	00bfffc4 	movi	r2,-1
    4530:	003ff906 	br	4518 <_puts_r+0x68>

00004534 <puts>:
    4534:	00800134 	movhi	r2,4
    4538:	1095bf04 	addi	r2,r2,22268
    453c:	200b883a 	mov	r5,r4
    4540:	11000017 	ldw	r4,0(r2)
    4544:	00044b01 	jmpi	44b0 <_puts_r>

00004548 <_sprintf_r>:
    4548:	deffe704 	addi	sp,sp,-100
    454c:	2807883a 	mov	r3,r5
    4550:	dfc01715 	stw	ra,92(sp)
    4554:	d9c01815 	stw	r7,96(sp)
    4558:	00a00034 	movhi	r2,32768
    455c:	10bfffc4 	addi	r2,r2,-1
    4560:	02008204 	movi	r8,520
    4564:	d8800215 	stw	r2,8(sp)
    4568:	d8800515 	stw	r2,20(sp)
    456c:	d80b883a 	mov	r5,sp
    4570:	d9c01804 	addi	r7,sp,96
    4574:	00bfffc4 	movi	r2,-1
    4578:	d8c00015 	stw	r3,0(sp)
    457c:	d8c00415 	stw	r3,16(sp)
    4580:	da00030d 	sth	r8,12(sp)
    4584:	d880038d 	sth	r2,14(sp)
    4588:	0004f600 	call	4f60 <___vfprintf_internal_r>
    458c:	d8c00017 	ldw	r3,0(sp)
    4590:	18000005 	stb	zero,0(r3)
    4594:	dfc01717 	ldw	ra,92(sp)
    4598:	dec01904 	addi	sp,sp,100
    459c:	f800283a 	ret

000045a0 <sprintf>:
    45a0:	deffe604 	addi	sp,sp,-104
    45a4:	2007883a 	mov	r3,r4
    45a8:	dfc01715 	stw	ra,92(sp)
    45ac:	d9801815 	stw	r6,96(sp)
    45b0:	d9c01915 	stw	r7,100(sp)
    45b4:	00800134 	movhi	r2,4
    45b8:	1095bf04 	addi	r2,r2,22268
    45bc:	11000017 	ldw	r4,0(r2)
    45c0:	00a00034 	movhi	r2,32768
    45c4:	10bfffc4 	addi	r2,r2,-1
    45c8:	280d883a 	mov	r6,r5
    45cc:	02008204 	movi	r8,520
    45d0:	d8800215 	stw	r2,8(sp)
    45d4:	d8800515 	stw	r2,20(sp)
    45d8:	d80b883a 	mov	r5,sp
    45dc:	d9c01804 	addi	r7,sp,96
    45e0:	00bfffc4 	movi	r2,-1
    45e4:	d8c00015 	stw	r3,0(sp)
    45e8:	d8c00415 	stw	r3,16(sp)
    45ec:	da00030d 	sth	r8,12(sp)
    45f0:	d880038d 	sth	r2,14(sp)
    45f4:	0004f600 	call	4f60 <___vfprintf_internal_r>
    45f8:	d8c00017 	ldw	r3,0(sp)
    45fc:	18000005 	stb	zero,0(r3)
    4600:	dfc01717 	ldw	ra,92(sp)
    4604:	dec01a04 	addi	sp,sp,104
    4608:	f800283a 	ret

0000460c <strcat>:
    460c:	defffe04 	addi	sp,sp,-8
    4610:	dc000015 	stw	r16,0(sp)
    4614:	dfc00115 	stw	ra,4(sp)
    4618:	208000cc 	andi	r2,r4,3
    461c:	2021883a 	mov	r16,r4
    4620:	1000141e 	bne	r2,zero,4674 <strcat+0x68>
    4624:	20800017 	ldw	r2,0(r4)
    4628:	027fbff4 	movhi	r9,65279
    462c:	4a7fbfc4 	addi	r9,r9,-257
    4630:	02202074 	movhi	r8,32897
    4634:	42202004 	addi	r8,r8,-32640
    4638:	1247883a 	add	r3,r2,r9
    463c:	0084303a 	nor	r2,zero,r2
    4640:	1884703a 	and	r2,r3,r2
    4644:	1204703a 	and	r2,r2,r8
    4648:	2007883a 	mov	r3,r4
    464c:	1000091e 	bne	r2,zero,4674 <strcat+0x68>
    4650:	18c00104 	addi	r3,r3,4
    4654:	19800017 	ldw	r6,0(r3)
    4658:	324f883a 	add	r7,r6,r9
    465c:	018c303a 	nor	r6,zero,r6
    4660:	398c703a 	and	r6,r7,r6
    4664:	320c703a 	and	r6,r6,r8
    4668:	303ff926 	beq	r6,zero,4650 <strcat+0x44>
    466c:	1809883a 	mov	r4,r3
    4670:	00000106 	br	4678 <strcat+0x6c>
    4674:	8009883a 	mov	r4,r16
    4678:	20800007 	ldb	r2,0(r4)
    467c:	10000326 	beq	r2,zero,468c <strcat+0x80>
    4680:	21000044 	addi	r4,r4,1
    4684:	20c00007 	ldb	r3,0(r4)
    4688:	183ffd1e 	bne	r3,zero,4680 <strcat+0x74>
    468c:	00046a40 	call	46a4 <strcpy>
    4690:	8005883a 	mov	r2,r16
    4694:	dfc00117 	ldw	ra,4(sp)
    4698:	dc000017 	ldw	r16,0(sp)
    469c:	dec00204 	addi	sp,sp,8
    46a0:	f800283a 	ret

000046a4 <strcpy>:
    46a4:	2906b03a 	or	r3,r5,r4
    46a8:	18c000cc 	andi	r3,r3,3
    46ac:	2005883a 	mov	r2,r4
    46b0:	18001a1e 	bne	r3,zero,471c <strcpy+0x78>
    46b4:	29800017 	ldw	r6,0(r5)
    46b8:	02bfbff4 	movhi	r10,65279
    46bc:	52bfbfc4 	addi	r10,r10,-257
    46c0:	02602074 	movhi	r9,32897
    46c4:	4a602004 	addi	r9,r9,-32640
    46c8:	0188303a 	nor	r4,zero,r6
    46cc:	3287883a 	add	r3,r6,r10
    46d0:	20c6703a 	and	r3,r4,r3
    46d4:	1a46703a 	and	r3,r3,r9
    46d8:	1800101e 	bne	r3,zero,471c <strcpy+0x78>
    46dc:	1007883a 	mov	r3,r2
    46e0:	19800015 	stw	r6,0(r3)
    46e4:	29400104 	addi	r5,r5,4
    46e8:	29800017 	ldw	r6,0(r5)
    46ec:	18c00104 	addi	r3,r3,4
    46f0:	0190303a 	nor	r8,zero,r6
    46f4:	328f883a 	add	r7,r6,r10
    46f8:	41ce703a 	and	r7,r8,r7
    46fc:	3a4e703a 	and	r7,r7,r9
    4700:	383ff726 	beq	r7,zero,46e0 <strcpy+0x3c>
    4704:	29800007 	ldb	r6,0(r5)
    4708:	18c00044 	addi	r3,r3,1
    470c:	29400044 	addi	r5,r5,1
    4710:	19bfffc5 	stb	r6,-1(r3)
    4714:	3000021e 	bne	r6,zero,4720 <strcpy+0x7c>
    4718:	f800283a 	ret
    471c:	1007883a 	mov	r3,r2
    4720:	29800007 	ldb	r6,0(r5)
    4724:	18c00044 	addi	r3,r3,1
    4728:	29400044 	addi	r5,r5,1
    472c:	19bfffc5 	stb	r6,-1(r3)
    4730:	303ffb1e 	bne	r6,zero,4720 <strcpy+0x7c>
    4734:	f800283a 	ret

00004738 <strerror>:
    4738:	deffff04 	addi	sp,sp,-4
    473c:	dfc00015 	stw	ra,0(sp)
    4740:	00802184 	movi	r2,134
    4744:	1100052e 	bgeu	r2,r4,475c <strerror+0x24>
    4748:	0004f240 	call	4f24 <_user_strerror>
    474c:	10019026 	beq	r2,zero,4d90 <strerror+0x658>
    4750:	dfc00017 	ldw	ra,0(sp)
    4754:	dec00104 	addi	sp,sp,4
    4758:	f800283a 	ret
    475c:	2105883a 	add	r2,r4,r4
    4760:	1085883a 	add	r2,r2,r2
    4764:	00c00034 	movhi	r3,0
    4768:	18d1de04 	addi	r3,r3,18296
    476c:	10c5883a 	add	r2,r2,r3
    4770:	10800017 	ldw	r2,0(r2)
    4774:	1000683a 	jmp	r2
    4778:	00004748 	cmpgei	zero,zero,285
    477c:	00004d84 	movi	zero,310
    4780:	00004d78 	rdprs	zero,zero,309
    4784:	00004d6c 	andhi	zero,zero,309
    4788:	00004d60 	cmpeqi	zero,zero,309
    478c:	00004d54 	movui	zero,309
    4790:	00004d48 	cmpgei	zero,zero,309
    4794:	00004d3c 	xorhi	zero,zero,308
    4798:	00004d30 	cmpltui	zero,zero,308
    479c:	00004d24 	muli	zero,zero,308
    47a0:	00004d18 	cmpnei	zero,zero,308
    47a4:	00004d0c 	andi	zero,zero,308
    47a8:	00004d00 	call	4d0 <prvweb_ParseHTMLRequest+0x1b4>
    47ac:	00004cf4 	movhi	zero,307
    47b0:	00004ce8 	cmpgeui	zero,zero,307
    47b4:	00004cdc 	xori	zero,zero,307
    47b8:	00004cd0 	cmplti	zero,zero,307
    47bc:	00004cc4 	movi	zero,307
    47c0:	00004cb8 	rdprs	zero,zero,306
    47c4:	00004cac 	andhi	zero,zero,306
    47c8:	00004ca0 	cmpeqi	zero,zero,306
    47cc:	00004c94 	movui	zero,306
    47d0:	00004c88 	cmpgei	zero,zero,306
    47d4:	00004c7c 	xorhi	zero,zero,305
    47d8:	00004c70 	cmpltui	zero,zero,305
    47dc:	00004c64 	muli	zero,zero,305
    47e0:	00004c58 	cmpnei	zero,zero,305
    47e4:	00004c4c 	andi	zero,zero,305
    47e8:	00004c40 	call	4c4 <prvweb_ParseHTMLRequest+0x1a8>
    47ec:	00004c34 	movhi	zero,304
    47f0:	00004c28 	cmpgeui	zero,zero,304
    47f4:	00004c1c 	xori	zero,zero,304
    47f8:	00004c10 	cmplti	zero,zero,304
    47fc:	00004c04 	movi	zero,304
    4800:	00004bf8 	rdprs	zero,zero,303
    4804:	00004bec 	andhi	zero,zero,303
    4808:	00004be0 	cmpeqi	zero,zero,303
    480c:	00004748 	cmpgei	zero,zero,285
    4810:	00004748 	cmpgei	zero,zero,285
    4814:	00004748 	cmpgei	zero,zero,285
    4818:	00004748 	cmpgei	zero,zero,285
    481c:	00004748 	cmpgei	zero,zero,285
    4820:	00004748 	cmpgei	zero,zero,285
    4824:	00004748 	cmpgei	zero,zero,285
    4828:	00004748 	cmpgei	zero,zero,285
    482c:	00004bd4 	movui	zero,303
    4830:	00004bc8 	cmpgei	zero,zero,303
    4834:	00004748 	cmpgei	zero,zero,285
    4838:	00004748 	cmpgei	zero,zero,285
    483c:	00004748 	cmpgei	zero,zero,285
    4840:	00004748 	cmpgei	zero,zero,285
    4844:	00004748 	cmpgei	zero,zero,285
    4848:	00004748 	cmpgei	zero,zero,285
    484c:	00004748 	cmpgei	zero,zero,285
    4850:	00004748 	cmpgei	zero,zero,285
    4854:	00004748 	cmpgei	zero,zero,285
    4858:	00004748 	cmpgei	zero,zero,285
    485c:	00004748 	cmpgei	zero,zero,285
    4860:	00004748 	cmpgei	zero,zero,285
    4864:	00004748 	cmpgei	zero,zero,285
    4868:	00004bbc 	xorhi	zero,zero,302
    486c:	00004748 	cmpgei	zero,zero,285
    4870:	00004bb0 	cmpltui	zero,zero,302
    4874:	00004ba4 	muli	zero,zero,302
    4878:	00004b98 	cmpnei	zero,zero,302
    487c:	00004b8c 	andi	zero,zero,302
    4880:	00004b80 	call	4b8 <prvweb_ParseHTMLRequest+0x19c>
    4884:	00004b74 	movhi	zero,301
    4888:	00004b68 	cmpgeui	zero,zero,301
    488c:	00004b5c 	xori	zero,zero,301
    4890:	00004b50 	cmplti	zero,zero,301
    4894:	00004b44 	movi	zero,301
    4898:	00004748 	cmpgei	zero,zero,285
    489c:	00004748 	cmpgei	zero,zero,285
    48a0:	00004b38 	rdprs	zero,zero,300
    48a4:	00004748 	cmpgei	zero,zero,285
    48a8:	00004748 	cmpgei	zero,zero,285
    48ac:	00004b2c 	andhi	zero,zero,300
    48b0:	00004748 	cmpgei	zero,zero,285
    48b4:	00004748 	cmpgei	zero,zero,285
    48b8:	00004748 	cmpgei	zero,zero,285
    48bc:	00004748 	cmpgei	zero,zero,285
    48c0:	00004748 	cmpgei	zero,zero,285
    48c4:	00004b20 	cmpeqi	zero,zero,300
    48c8:	00004b14 	movui	zero,300
    48cc:	00004b08 	cmpgei	zero,zero,300
    48d0:	00004afc 	xorhi	zero,zero,299
    48d4:	00004af0 	cmpltui	zero,zero,299
    48d8:	00004ae4 	muli	zero,zero,299
    48dc:	00004ad8 	cmpnei	zero,zero,299
    48e0:	00004acc 	andi	zero,zero,299
    48e4:	00004ac0 	call	4ac <prvweb_ParseHTMLRequest+0x190>
    48e8:	00004ab4 	movhi	zero,298
    48ec:	00004748 	cmpgei	zero,zero,285
    48f0:	00004748 	cmpgei	zero,zero,285
    48f4:	00004aa8 	cmpgeui	zero,zero,298
    48f8:	00004748 	cmpgei	zero,zero,285
    48fc:	00004748 	cmpgei	zero,zero,285
    4900:	00004748 	cmpgei	zero,zero,285
    4904:	00004748 	cmpgei	zero,zero,285
    4908:	00004748 	cmpgei	zero,zero,285
    490c:	00004748 	cmpgei	zero,zero,285
    4910:	00004748 	cmpgei	zero,zero,285
    4914:	00004748 	cmpgei	zero,zero,285
    4918:	00004748 	cmpgei	zero,zero,285
    491c:	00004a9c 	xori	zero,zero,298
    4920:	00004a90 	cmplti	zero,zero,298
    4924:	00004a84 	movi	zero,298
    4928:	00004a78 	rdprs	zero,zero,297
    492c:	00004a6c 	andhi	zero,zero,297
    4930:	00004a60 	cmpeqi	zero,zero,297
    4934:	00004a54 	movui	zero,297
    4938:	00004a48 	cmpgei	zero,zero,297
    493c:	00004a3c 	xorhi	zero,zero,296
    4940:	00004a30 	cmpltui	zero,zero,296
    4944:	00004a24 	muli	zero,zero,296
    4948:	00004a18 	cmpnei	zero,zero,296
    494c:	00004a0c 	andi	zero,zero,296
    4950:	00004a00 	call	4a0 <prvweb_ParseHTMLRequest+0x184>
    4954:	000049f4 	movhi	zero,295
    4958:	000049e8 	cmpgeui	zero,zero,295
    495c:	000049dc 	xori	zero,zero,295
    4960:	000049d0 	cmplti	zero,zero,295
    4964:	000049c4 	movi	zero,295
    4968:	000049b8 	rdprs	zero,zero,294
    496c:	00004748 	cmpgei	zero,zero,285
    4970:	00004748 	cmpgei	zero,zero,285
    4974:	000049ac 	andhi	zero,zero,294
    4978:	000049a0 	cmpeqi	zero,zero,294
    497c:	00004748 	cmpgei	zero,zero,285
    4980:	00004748 	cmpgei	zero,zero,285
    4984:	00004748 	cmpgei	zero,zero,285
    4988:	00004748 	cmpgei	zero,zero,285
    498c:	00004748 	cmpgei	zero,zero,285
    4990:	00004994 	movui	zero,294
    4994:	00800134 	movhi	r2,4
    4998:	10806f04 	addi	r2,r2,444
    499c:	003f6c06 	br	4750 <strerror+0x18>
    49a0:	00800134 	movhi	r2,4
    49a4:	10818004 	addi	r2,r2,1536
    49a8:	003f6906 	br	4750 <strerror+0x18>
    49ac:	00800134 	movhi	r2,4
    49b0:	10818d04 	addi	r2,r2,1588
    49b4:	003f6606 	br	4750 <strerror+0x18>
    49b8:	00800134 	movhi	r2,4
    49bc:	10818604 	addi	r2,r2,1560
    49c0:	003f6306 	br	4750 <strerror+0x18>
    49c4:	00800134 	movhi	r2,4
    49c8:	1080da04 	addi	r2,r2,872
    49cc:	003f6006 	br	4750 <strerror+0x18>
    49d0:	00800134 	movhi	r2,4
    49d4:	10819d04 	addi	r2,r2,1652
    49d8:	003f5d06 	br	4750 <strerror+0x18>
    49dc:	00800134 	movhi	r2,4
    49e0:	10bff504 	addi	r2,r2,-44
    49e4:	003f5a06 	br	4750 <strerror+0x18>
    49e8:	00800134 	movhi	r2,4
    49ec:	10bfe704 	addi	r2,r2,-100
    49f0:	003f5706 	br	4750 <strerror+0x18>
    49f4:	00800134 	movhi	r2,4
    49f8:	10802f04 	addi	r2,r2,188
    49fc:	003f5406 	br	4750 <strerror+0x18>
    4a00:	00800134 	movhi	r2,4
    4a04:	10806404 	addi	r2,r2,400
    4a08:	003f5106 	br	4750 <strerror+0x18>
    4a0c:	00800134 	movhi	r2,4
    4a10:	10802b04 	addi	r2,r2,172
    4a14:	003f4e06 	br	4750 <strerror+0x18>
    4a18:	00800134 	movhi	r2,4
    4a1c:	1081a204 	addi	r2,r2,1672
    4a20:	003f4b06 	br	4750 <strerror+0x18>
    4a24:	00800134 	movhi	r2,4
    4a28:	10804004 	addi	r2,r2,256
    4a2c:	003f4806 	br	4750 <strerror+0x18>
    4a30:	00800134 	movhi	r2,4
    4a34:	10809c04 	addi	r2,r2,624
    4a38:	003f4506 	br	4750 <strerror+0x18>
    4a3c:	00800134 	movhi	r2,4
    4a40:	10817704 	addi	r2,r2,1500
    4a44:	003f4206 	br	4750 <strerror+0x18>
    4a48:	00800134 	movhi	r2,4
    4a4c:	10817104 	addi	r2,r2,1476
    4a50:	003f3f06 	br	4750 <strerror+0x18>
    4a54:	00800134 	movhi	r2,4
    4a58:	10816c04 	addi	r2,r2,1456
    4a5c:	003f3c06 	br	4750 <strerror+0x18>
    4a60:	00800134 	movhi	r2,4
    4a64:	10816304 	addi	r2,r2,1420
    4a68:	003f3906 	br	4750 <strerror+0x18>
    4a6c:	00800134 	movhi	r2,4
    4a70:	10815d04 	addi	r2,r2,1396
    4a74:	003f3606 	br	4750 <strerror+0x18>
    4a78:	00800134 	movhi	r2,4
    4a7c:	10815504 	addi	r2,r2,1364
    4a80:	003f3306 	br	4750 <strerror+0x18>
    4a84:	00800134 	movhi	r2,4
    4a88:	10814d04 	addi	r2,r2,1332
    4a8c:	003f3006 	br	4750 <strerror+0x18>
    4a90:	00800134 	movhi	r2,4
    4a94:	10814104 	addi	r2,r2,1284
    4a98:	003f2d06 	br	4750 <strerror+0x18>
    4a9c:	00800134 	movhi	r2,4
    4aa0:	10813a04 	addi	r2,r2,1256
    4aa4:	003f2a06 	br	4750 <strerror+0x18>
    4aa8:	00800134 	movhi	r2,4
    4aac:	10819404 	addi	r2,r2,1616
    4ab0:	003f2706 	br	4750 <strerror+0x18>
    4ab4:	00800134 	movhi	r2,4
    4ab8:	10813404 	addi	r2,r2,1232
    4abc:	003f2406 	br	4750 <strerror+0x18>
    4ac0:	00800134 	movhi	r2,4
    4ac4:	10812d04 	addi	r2,r2,1204
    4ac8:	003f2106 	br	4750 <strerror+0x18>
    4acc:	00800134 	movhi	r2,4
    4ad0:	10812804 	addi	r2,r2,1184
    4ad4:	003f1e06 	br	4750 <strerror+0x18>
    4ad8:	00800134 	movhi	r2,4
    4adc:	10812404 	addi	r2,r2,1168
    4ae0:	003f1b06 	br	4750 <strerror+0x18>
    4ae4:	00800134 	movhi	r2,4
    4ae8:	10811d04 	addi	r2,r2,1140
    4aec:	003f1806 	br	4750 <strerror+0x18>
    4af0:	00800134 	movhi	r2,4
    4af4:	10811304 	addi	r2,r2,1100
    4af8:	003f1506 	br	4750 <strerror+0x18>
    4afc:	00800134 	movhi	r2,4
    4b00:	10810304 	addi	r2,r2,1036
    4b04:	003f1206 	br	4750 <strerror+0x18>
    4b08:	00800134 	movhi	r2,4
    4b0c:	1080fb04 	addi	r2,r2,1004
    4b10:	003f0f06 	br	4750 <strerror+0x18>
    4b14:	00800134 	movhi	r2,4
    4b18:	1080f104 	addi	r2,r2,964
    4b1c:	003f0c06 	br	4750 <strerror+0x18>
    4b20:	00800134 	movhi	r2,4
    4b24:	1080e704 	addi	r2,r2,924
    4b28:	003f0906 	br	4750 <strerror+0x18>
    4b2c:	00800134 	movhi	r2,4
    4b30:	1080e404 	addi	r2,r2,912
    4b34:	003f0606 	br	4750 <strerror+0x18>
    4b38:	00800134 	movhi	r2,4
    4b3c:	1080df04 	addi	r2,r2,892
    4b40:	003f0306 	br	4750 <strerror+0x18>
    4b44:	00800134 	movhi	r2,4
    4b48:	1080d604 	addi	r2,r2,856
    4b4c:	003f0006 	br	4750 <strerror+0x18>
    4b50:	00800134 	movhi	r2,4
    4b54:	1080d104 	addi	r2,r2,836
    4b58:	003efd06 	br	4750 <strerror+0x18>
    4b5c:	00800134 	movhi	r2,4
    4b60:	1080cd04 	addi	r2,r2,820
    4b64:	003efa06 	br	4750 <strerror+0x18>
    4b68:	00800134 	movhi	r2,4
    4b6c:	1080c904 	addi	r2,r2,804
    4b70:	003ef706 	br	4750 <strerror+0x18>
    4b74:	00800134 	movhi	r2,4
    4b78:	1080c304 	addi	r2,r2,780
    4b7c:	003ef406 	br	4750 <strerror+0x18>
    4b80:	00800134 	movhi	r2,4
    4b84:	1080be04 	addi	r2,r2,760
    4b88:	003ef106 	br	4750 <strerror+0x18>
    4b8c:	00800134 	movhi	r2,4
    4b90:	1080bb04 	addi	r2,r2,748
    4b94:	003eee06 	br	4750 <strerror+0x18>
    4b98:	00800134 	movhi	r2,4
    4b9c:	1080b304 	addi	r2,r2,716
    4ba0:	003eeb06 	br	4750 <strerror+0x18>
    4ba4:	00800134 	movhi	r2,4
    4ba8:	1080ae04 	addi	r2,r2,696
    4bac:	003ee806 	br	4750 <strerror+0x18>
    4bb0:	00800134 	movhi	r2,4
    4bb4:	1080a804 	addi	r2,r2,672
    4bb8:	003ee506 	br	4750 <strerror+0x18>
    4bbc:	00800134 	movhi	r2,4
    4bc0:	1080a404 	addi	r2,r2,656
    4bc4:	003ee206 	br	4750 <strerror+0x18>
    4bc8:	00800134 	movhi	r2,4
    4bcc:	1080a204 	addi	r2,r2,648
    4bd0:	003edf06 	br	4750 <strerror+0x18>
    4bd4:	00800134 	movhi	r2,4
    4bd8:	10809904 	addi	r2,r2,612
    4bdc:	003edc06 	br	4750 <strerror+0x18>
    4be0:	00800134 	movhi	r2,4
    4be4:	10809404 	addi	r2,r2,592
    4be8:	003ed906 	br	4750 <strerror+0x18>
    4bec:	00800134 	movhi	r2,4
    4bf0:	10808d04 	addi	r2,r2,564
    4bf4:	003ed606 	br	4750 <strerror+0x18>
    4bf8:	00800134 	movhi	r2,4
    4bfc:	10808804 	addi	r2,r2,544
    4c00:	003ed306 	br	4750 <strerror+0x18>
    4c04:	00800134 	movhi	r2,4
    4c08:	10808404 	addi	r2,r2,528
    4c0c:	003ed006 	br	4750 <strerror+0x18>
    4c10:	00800134 	movhi	r2,4
    4c14:	10808104 	addi	r2,r2,516
    4c18:	003ecd06 	br	4750 <strerror+0x18>
    4c1c:	00800134 	movhi	r2,4
    4c20:	10807d04 	addi	r2,r2,500
    4c24:	003eca06 	br	4750 <strerror+0x18>
    4c28:	00800134 	movhi	r2,4
    4c2c:	10807704 	addi	r2,r2,476
    4c30:	003ec706 	br	4750 <strerror+0x18>
    4c34:	00800134 	movhi	r2,4
    4c38:	10807304 	addi	r2,r2,460
    4c3c:	003ec406 	br	4750 <strerror+0x18>
    4c40:	00800134 	movhi	r2,4
    4c44:	10806904 	addi	r2,r2,420
    4c48:	003ec106 	br	4750 <strerror+0x18>
    4c4c:	00800134 	movhi	r2,4
    4c50:	10806004 	addi	r2,r2,384
    4c54:	003ebe06 	br	4750 <strerror+0x18>
    4c58:	00800134 	movhi	r2,4
    4c5c:	10805c04 	addi	r2,r2,368
    4c60:	003ebb06 	br	4750 <strerror+0x18>
    4c64:	00800134 	movhi	r2,4
    4c68:	10805604 	addi	r2,r2,344
    4c6c:	003eb806 	br	4750 <strerror+0x18>
    4c70:	00800134 	movhi	r2,4
    4c74:	10805104 	addi	r2,r2,324
    4c78:	003eb506 	br	4750 <strerror+0x18>
    4c7c:	00800134 	movhi	r2,4
    4c80:	10804904 	addi	r2,r2,292
    4c84:	003eb206 	br	4750 <strerror+0x18>
    4c88:	00800134 	movhi	r2,4
    4c8c:	10803b04 	addi	r2,r2,236
    4c90:	003eaf06 	br	4750 <strerror+0x18>
    4c94:	00800134 	movhi	r2,4
    4c98:	10803704 	addi	r2,r2,220
    4c9c:	003eac06 	br	4750 <strerror+0x18>
    4ca0:	00800134 	movhi	r2,4
    4ca4:	10802704 	addi	r2,r2,156
    4ca8:	003ea906 	br	4750 <strerror+0x18>
    4cac:	00800134 	movhi	r2,4
    4cb0:	10802304 	addi	r2,r2,140
    4cb4:	003ea606 	br	4750 <strerror+0x18>
    4cb8:	00800134 	movhi	r2,4
    4cbc:	10801e04 	addi	r2,r2,120
    4cc0:	003ea306 	br	4750 <strerror+0x18>
    4cc4:	00800134 	movhi	r2,4
    4cc8:	10801b04 	addi	r2,r2,108
    4ccc:	003ea006 	br	4750 <strerror+0x18>
    4cd0:	00800134 	movhi	r2,4
    4cd4:	10801504 	addi	r2,r2,84
    4cd8:	003e9d06 	br	4750 <strerror+0x18>
    4cdc:	00800134 	movhi	r2,4
    4ce0:	10800f04 	addi	r2,r2,60
    4ce4:	003e9a06 	br	4750 <strerror+0x18>
    4ce8:	00800134 	movhi	r2,4
    4cec:	10800c04 	addi	r2,r2,48
    4cf0:	003e9706 	br	4750 <strerror+0x18>
    4cf4:	00800134 	movhi	r2,4
    4cf8:	10800704 	addi	r2,r2,28
    4cfc:	003e9406 	br	4750 <strerror+0x18>
    4d00:	00800134 	movhi	r2,4
    4d04:	10800204 	addi	r2,r2,8
    4d08:	003e9106 	br	4750 <strerror+0x18>
    4d0c:	00800134 	movhi	r2,4
    4d10:	10bffd04 	addi	r2,r2,-12
    4d14:	003e8e06 	br	4750 <strerror+0x18>
    4d18:	00800134 	movhi	r2,4
    4d1c:	10bff204 	addi	r2,r2,-56
    4d20:	003e8b06 	br	4750 <strerror+0x18>
    4d24:	00800134 	movhi	r2,4
    4d28:	10bfee04 	addi	r2,r2,-72
    4d2c:	003e8806 	br	4750 <strerror+0x18>
    4d30:	00800134 	movhi	r2,4
    4d34:	10bfe204 	addi	r2,r2,-120
    4d38:	003e8506 	br	4750 <strerror+0x18>
    4d3c:	00800134 	movhi	r2,4
    4d40:	10bfdd04 	addi	r2,r2,-140
    4d44:	003e8206 	br	4750 <strerror+0x18>
    4d48:	00800134 	movhi	r2,4
    4d4c:	10bfd604 	addi	r2,r2,-168
    4d50:	003e7f06 	br	4750 <strerror+0x18>
    4d54:	00800134 	movhi	r2,4
    4d58:	10bfd304 	addi	r2,r2,-180
    4d5c:	003e7c06 	br	4750 <strerror+0x18>
    4d60:	00800134 	movhi	r2,4
    4d64:	10bfcd04 	addi	r2,r2,-204
    4d68:	003e7906 	br	4750 <strerror+0x18>
    4d6c:	00800134 	movhi	r2,4
    4d70:	10bfc904 	addi	r2,r2,-220
    4d74:	003e7606 	br	4750 <strerror+0x18>
    4d78:	00800134 	movhi	r2,4
    4d7c:	10bfc204 	addi	r2,r2,-248
    4d80:	003e7306 	br	4750 <strerror+0x18>
    4d84:	00800134 	movhi	r2,4
    4d88:	10bfbf04 	addi	r2,r2,-260
    4d8c:	003e7006 	br	4750 <strerror+0x18>
    4d90:	00800134 	movhi	r2,4
    4d94:	1081b004 	addi	r2,r2,1728
    4d98:	003e6d06 	br	4750 <strerror+0x18>

00004d9c <strlen>:
    4d9c:	208000cc 	andi	r2,r4,3
    4da0:	10001f1e 	bne	r2,zero,4e20 <strlen+0x84>
    4da4:	20800017 	ldw	r2,0(r4)
    4da8:	01ffbff4 	movhi	r7,65279
    4dac:	39ffbfc4 	addi	r7,r7,-257
    4db0:	01a02074 	movhi	r6,32897
    4db4:	31a02004 	addi	r6,r6,-32640
    4db8:	11c7883a 	add	r3,r2,r7
    4dbc:	0084303a 	nor	r2,zero,r2
    4dc0:	1886703a 	and	r3,r3,r2
    4dc4:	1986703a 	and	r3,r3,r6
    4dc8:	2005883a 	mov	r2,r4
    4dcc:	1800101e 	bne	r3,zero,4e10 <strlen+0x74>
    4dd0:	10800104 	addi	r2,r2,4
    4dd4:	10c00017 	ldw	r3,0(r2)
    4dd8:	19cb883a 	add	r5,r3,r7
    4ddc:	00c6303a 	nor	r3,zero,r3
    4de0:	28c6703a 	and	r3,r5,r3
    4de4:	1986703a 	and	r3,r3,r6
    4de8:	1800091e 	bne	r3,zero,4e10 <strlen+0x74>
    4dec:	10800104 	addi	r2,r2,4
    4df0:	10c00017 	ldw	r3,0(r2)
    4df4:	19cb883a 	add	r5,r3,r7
    4df8:	00c6303a 	nor	r3,zero,r3
    4dfc:	28c6703a 	and	r3,r5,r3
    4e00:	1986703a 	and	r3,r3,r6
    4e04:	183ff226 	beq	r3,zero,4dd0 <strlen+0x34>
    4e08:	00000106 	br	4e10 <strlen+0x74>
    4e0c:	10800044 	addi	r2,r2,1
    4e10:	10c00007 	ldb	r3,0(r2)
    4e14:	183ffd1e 	bne	r3,zero,4e0c <strlen+0x70>
    4e18:	1105c83a 	sub	r2,r2,r4
    4e1c:	f800283a 	ret
    4e20:	2005883a 	mov	r2,r4
    4e24:	003ffa06 	br	4e10 <strlen+0x74>

00004e28 <strncmp>:
    4e28:	30001826 	beq	r6,zero,4e8c <strncmp+0x64>
    4e2c:	2904b03a 	or	r2,r5,r4
    4e30:	108000cc 	andi	r2,r2,3
    4e34:	10001726 	beq	r2,zero,4e94 <strncmp+0x6c>
    4e38:	31bfffc4 	addi	r6,r6,-1
    4e3c:	20800007 	ldb	r2,0(r4)
    4e40:	28c00007 	ldb	r3,0(r5)
    4e44:	10c0331e 	bne	r2,r3,4f14 <strncmp+0xec>
    4e48:	30001026 	beq	r6,zero,4e8c <strncmp+0x64>
    4e4c:	10000f26 	beq	r2,zero,4e8c <strncmp+0x64>
    4e50:	20800044 	addi	r2,r4,1
    4e54:	29400044 	addi	r5,r5,1
    4e58:	2189883a 	add	r4,r4,r6
    4e5c:	00000406 	br	4e70 <strncmp+0x48>
    4e60:	11000a26 	beq	r2,r4,4e8c <strncmp+0x64>
    4e64:	18000926 	beq	r3,zero,4e8c <strncmp+0x64>
    4e68:	10800044 	addi	r2,r2,1
    4e6c:	29400044 	addi	r5,r5,1
    4e70:	10c00007 	ldb	r3,0(r2)
    4e74:	29800007 	ldb	r6,0(r5)
    4e78:	19bff926 	beq	r3,r6,4e60 <strncmp+0x38>
    4e7c:	10c00003 	ldbu	r3,0(r2)
    4e80:	28800003 	ldbu	r2,0(r5)
    4e84:	1885c83a 	sub	r2,r3,r2
    4e88:	f800283a 	ret
    4e8c:	0005883a 	mov	r2,zero
    4e90:	f800283a 	ret
    4e94:	024000c4 	movi	r9,3
    4e98:	49bfe72e 	bgeu	r9,r6,4e38 <strncmp+0x10>
    4e9c:	20800017 	ldw	r2,0(r4)
    4ea0:	28c00017 	ldw	r3,0(r5)
    4ea4:	10ffe41e 	bne	r2,r3,4e38 <strncmp+0x10>
    4ea8:	30ffff04 	addi	r3,r6,-4
    4eac:	183ff726 	beq	r3,zero,4e8c <strncmp+0x64>
    4eb0:	02ffbff4 	movhi	r11,65279
    4eb4:	5affbfc4 	addi	r11,r11,-257
    4eb8:	12cd883a 	add	r6,r2,r11
    4ebc:	0084303a 	nor	r2,zero,r2
    4ec0:	3084703a 	and	r2,r6,r2
    4ec4:	02a02074 	movhi	r10,32897
    4ec8:	52a02004 	addi	r10,r10,-32640
    4ecc:	1284703a 	and	r2,r2,r10
    4ed0:	10000b26 	beq	r2,zero,4f00 <strncmp+0xd8>
    4ed4:	003fed06 	br	4e8c <strncmp+0x64>
    4ed8:	21800017 	ldw	r6,0(r4)
    4edc:	28800017 	ldw	r2,0(r5)
    4ee0:	32d1883a 	add	r8,r6,r11
    4ee4:	018e303a 	nor	r7,zero,r6
    4ee8:	41ce703a 	and	r7,r8,r7
    4eec:	3a8e703a 	and	r7,r7,r10
    4ef0:	30800a1e 	bne	r6,r2,4f1c <strncmp+0xf4>
    4ef4:	18ffff04 	addi	r3,r3,-4
    4ef8:	183fe426 	beq	r3,zero,4e8c <strncmp+0x64>
    4efc:	383fe31e 	bne	r7,zero,4e8c <strncmp+0x64>
    4f00:	21000104 	addi	r4,r4,4
    4f04:	29400104 	addi	r5,r5,4
    4f08:	48fff336 	bltu	r9,r3,4ed8 <strncmp+0xb0>
    4f0c:	19bfffc4 	addi	r6,r3,-1
    4f10:	183fca1e 	bne	r3,zero,4e3c <strncmp+0x14>
    4f14:	2005883a 	mov	r2,r4
    4f18:	003fd806 	br	4e7c <strncmp+0x54>
    4f1c:	19bfffc4 	addi	r6,r3,-1
    4f20:	003fc606 	br	4e3c <strncmp+0x14>

00004f24 <_user_strerror>:
    4f24:	0005883a 	mov	r2,zero
    4f28:	f800283a 	ret

00004f2c <__sprint_r>:
    4f2c:	30800217 	ldw	r2,8(r6)
    4f30:	defffe04 	addi	sp,sp,-8
    4f34:	dc000015 	stw	r16,0(sp)
    4f38:	dfc00115 	stw	ra,4(sp)
    4f3c:	3021883a 	mov	r16,r6
    4f40:	10000226 	beq	r2,zero,4f4c <__sprint_r+0x20>
    4f44:	00091440 	call	9144 <__sfvwrite_r>
    4f48:	80000215 	stw	zero,8(r16)
    4f4c:	80000115 	stw	zero,4(r16)
    4f50:	dfc00117 	ldw	ra,4(sp)
    4f54:	dc000017 	ldw	r16,0(sp)
    4f58:	dec00204 	addi	sp,sp,8
    4f5c:	f800283a 	ret

00004f60 <___vfprintf_internal_r>:
    4f60:	defeb904 	addi	sp,sp,-1308
    4f64:	dc013d15 	stw	r16,1268(sp)
    4f68:	d9013015 	stw	r4,1216(sp)
    4f6c:	dfc14615 	stw	ra,1304(sp)
    4f70:	df014515 	stw	fp,1300(sp)
    4f74:	ddc14415 	stw	r23,1296(sp)
    4f78:	dd814315 	stw	r22,1292(sp)
    4f7c:	dd414215 	stw	r21,1288(sp)
    4f80:	dd014115 	stw	r20,1284(sp)
    4f84:	dcc14015 	stw	r19,1280(sp)
    4f88:	dc813f15 	stw	r18,1276(sp)
    4f8c:	dc413e15 	stw	r17,1272(sp)
    4f90:	d9412915 	stw	r5,1188(sp)
    4f94:	3021883a 	mov	r16,r6
    4f98:	d9c12d15 	stw	r7,1204(sp)
    4f9c:	00098300 	call	9830 <_localeconv_r>
    4fa0:	10800017 	ldw	r2,0(r2)
    4fa4:	d9013017 	ldw	r4,1216(sp)
    4fa8:	d8013315 	stw	zero,1228(sp)
    4fac:	d8813715 	stw	r2,1244(sp)
    4fb0:	d8013415 	stw	zero,1232(sp)
    4fb4:	20000226 	beq	r4,zero,4fc0 <___vfprintf_internal_r+0x60>
    4fb8:	20800e17 	ldw	r2,56(r4)
    4fbc:	10019826 	beq	r2,zero,5620 <___vfprintf_internal_r+0x6c0>
    4fc0:	da012917 	ldw	r8,1188(sp)
    4fc4:	4080030b 	ldhu	r2,12(r8)
    4fc8:	10c0020c 	andi	r3,r2,8
    4fcc:	18ffffcc 	andi	r3,r3,65535
    4fd0:	18e0001c 	xori	r3,r3,32768
    4fd4:	18e00004 	addi	r3,r3,-32768
    4fd8:	18013a26 	beq	r3,zero,54c4 <___vfprintf_internal_r+0x564>
    4fdc:	40c00417 	ldw	r3,16(r8)
    4fe0:	18013826 	beq	r3,zero,54c4 <___vfprintf_internal_r+0x564>
    4fe4:	1100068c 	andi	r4,r2,26
    4fe8:	00c00284 	movi	r3,10
    4fec:	20c13e26 	beq	r4,r3,54e8 <___vfprintf_internal_r+0x588>
    4ff0:	da010dc4 	addi	r8,sp,1079
    4ff4:	d8800404 	addi	r2,sp,16
    4ff8:	da012615 	stw	r8,1176(sp)
    4ffc:	d8811b15 	stw	r2,1132(sp)
    5000:	1013883a 	mov	r9,r2
    5004:	d8812617 	ldw	r2,1176(sp)
    5008:	da010e04 	addi	r8,sp,1080
    500c:	dc413017 	ldw	r17,1216(sp)
    5010:	da012715 	stw	r8,1180(sp)
    5014:	4091c83a 	sub	r8,r8,r2
    5018:	d8011d15 	stw	zero,1140(sp)
    501c:	d8011c15 	stw	zero,1136(sp)
    5020:	802b883a 	mov	r21,r16
    5024:	d8013215 	stw	zero,1224(sp)
    5028:	d8013615 	stw	zero,1240(sp)
    502c:	d8013515 	stw	zero,1236(sp)
    5030:	d8012c15 	stw	zero,1200(sp)
    5034:	da013915 	stw	r8,1252(sp)
    5038:	a8800007 	ldb	r2,0(r21)
    503c:	1002ec26 	beq	r2,zero,5bf0 <___vfprintf_internal_r+0xc90>
    5040:	00c00944 	movi	r3,37
    5044:	a825883a 	mov	r18,r21
    5048:	10c0021e 	bne	r2,r3,5054 <___vfprintf_internal_r+0xf4>
    504c:	00001406 	br	50a0 <___vfprintf_internal_r+0x140>
    5050:	10c00326 	beq	r2,r3,5060 <___vfprintf_internal_r+0x100>
    5054:	94800044 	addi	r18,r18,1
    5058:	90800007 	ldb	r2,0(r18)
    505c:	103ffc1e 	bne	r2,zero,5050 <___vfprintf_internal_r+0xf0>
    5060:	9561c83a 	sub	r16,r18,r21
    5064:	80000e26 	beq	r16,zero,50a0 <___vfprintf_internal_r+0x140>
    5068:	da011d17 	ldw	r8,1140(sp)
    506c:	d8c11c17 	ldw	r3,1136(sp)
    5070:	4d400015 	stw	r21,0(r9)
    5074:	4c000115 	stw	r16,4(r9)
    5078:	4411883a 	add	r8,r8,r16
    507c:	18c00044 	addi	r3,r3,1
    5080:	da011d15 	stw	r8,1140(sp)
    5084:	d8c11c15 	stw	r3,1136(sp)
    5088:	008001c4 	movi	r2,7
    508c:	10c15d16 	blt	r2,r3,5604 <___vfprintf_internal_r+0x6a4>
    5090:	4a400204 	addi	r9,r9,8
    5094:	d8812c17 	ldw	r2,1200(sp)
    5098:	1405883a 	add	r2,r2,r16
    509c:	d8812c15 	stw	r2,1200(sp)
    50a0:	90800007 	ldb	r2,0(r18)
    50a4:	10013b26 	beq	r2,zero,5594 <___vfprintf_internal_r+0x634>
    50a8:	95400044 	addi	r21,r18,1
    50ac:	94800047 	ldb	r18,1(r18)
    50b0:	d8012585 	stb	zero,1174(sp)
    50b4:	073fffc4 	movi	fp,-1
    50b8:	d8012e15 	stw	zero,1208(sp)
    50bc:	0021883a 	mov	r16,zero
    50c0:	00c01604 	movi	r3,88
    50c4:	01400244 	movi	r5,9
    50c8:	02800a84 	movi	r10,42
    50cc:	01c01b04 	movi	r7,108
    50d0:	01800ac4 	movi	r6,43
    50d4:	02c00804 	movi	r11,32
    50d8:	ad400044 	addi	r21,r21,1
    50dc:	90bff804 	addi	r2,r18,-32
    50e0:	1880092e 	bgeu	r3,r2,5108 <___vfprintf_internal_r+0x1a8>
    50e4:	90012b26 	beq	r18,zero,5594 <___vfprintf_internal_r+0x634>
    50e8:	00c00044 	movi	r3,1
    50ec:	d8c12815 	stw	r3,1184(sp)
    50f0:	dc810405 	stb	r18,1040(sp)
    50f4:	d8012585 	stb	zero,1174(sp)
    50f8:	d8c12b15 	stw	r3,1196(sp)
    50fc:	dcc10404 	addi	r19,sp,1040
    5100:	d8013115 	stw	zero,1220(sp)
    5104:	00008806 	br	5328 <___vfprintf_internal_r+0x3c8>
    5108:	1085883a 	add	r2,r2,r2
    510c:	1085883a 	add	r2,r2,r2
    5110:	01000034 	movhi	r4,0
    5114:	21144904 	addi	r4,r4,20772
    5118:	1105883a 	add	r2,r2,r4
    511c:	10800017 	ldw	r2,0(r2)
    5120:	1000683a 	jmp	r2
    5124:	000056d8 	cmpnei	zero,zero,347
    5128:	000050e4 	muli	zero,zero,323
    512c:	000050e4 	muli	zero,zero,323
    5130:	000056ec 	andhi	zero,zero,347
    5134:	000050e4 	muli	zero,zero,323
    5138:	000050e4 	muli	zero,zero,323
    513c:	000050e4 	muli	zero,zero,323
    5140:	000050e4 	muli	zero,zero,323
    5144:	000050e4 	muli	zero,zero,323
    5148:	000050e4 	muli	zero,zero,323
    514c:	000057d4 	movui	zero,351
    5150:	00005690 	cmplti	zero,zero,346
    5154:	000050e4 	muli	zero,zero,323
    5158:	000054b8 	rdprs	zero,zero,338
    515c:	0000569c 	xori	zero,zero,346
    5160:	000050e4 	muli	zero,zero,323
    5164:	000056f8 	rdprs	zero,zero,347
    5168:	000057f8 	rdprs	zero,zero,351
    516c:	000057f8 	rdprs	zero,zero,351
    5170:	000057f8 	rdprs	zero,zero,351
    5174:	000057f8 	rdprs	zero,zero,351
    5178:	000057f8 	rdprs	zero,zero,351
    517c:	000057f8 	rdprs	zero,zero,351
    5180:	000057f8 	rdprs	zero,zero,351
    5184:	000057f8 	rdprs	zero,zero,351
    5188:	000057f8 	rdprs	zero,zero,351
    518c:	000050e4 	muli	zero,zero,323
    5190:	000050e4 	muli	zero,zero,323
    5194:	000050e4 	muli	zero,zero,323
    5198:	000050e4 	muli	zero,zero,323
    519c:	000050e4 	muli	zero,zero,323
    51a0:	000050e4 	muli	zero,zero,323
    51a4:	000050e4 	muli	zero,zero,323
    51a8:	000050e4 	muli	zero,zero,323
    51ac:	000050e4 	muli	zero,zero,323
    51b0:	000050e4 	muli	zero,zero,323
    51b4:	00005454 	movui	zero,337
    51b8:	00005820 	cmpeqi	zero,zero,352
    51bc:	000050e4 	muli	zero,zero,323
    51c0:	00005820 	cmpeqi	zero,zero,352
    51c4:	000050e4 	muli	zero,zero,323
    51c8:	000050e4 	muli	zero,zero,323
    51cc:	000050e4 	muli	zero,zero,323
    51d0:	000050e4 	muli	zero,zero,323
    51d4:	00005990 	cmplti	zero,zero,358
    51d8:	000050e4 	muli	zero,zero,323
    51dc:	000050e4 	muli	zero,zero,323
    51e0:	0000541c 	xori	zero,zero,336
    51e4:	000050e4 	muli	zero,zero,323
    51e8:	000050e4 	muli	zero,zero,323
    51ec:	000050e4 	muli	zero,zero,323
    51f0:	000050e4 	muli	zero,zero,323
    51f4:	000050e4 	muli	zero,zero,323
    51f8:	00005288 	cmpgei	zero,zero,330
    51fc:	000050e4 	muli	zero,zero,323
    5200:	000050e4 	muli	zero,zero,323
    5204:	00005704 	movi	zero,348
    5208:	000050e4 	muli	zero,zero,323
    520c:	000050e4 	muli	zero,zero,323
    5210:	000050e4 	muli	zero,zero,323
    5214:	000050e4 	muli	zero,zero,323
    5218:	000050e4 	muli	zero,zero,323
    521c:	000050e4 	muli	zero,zero,323
    5220:	000050e4 	muli	zero,zero,323
    5224:	000050e4 	muli	zero,zero,323
    5228:	000050e4 	muli	zero,zero,323
    522c:	000050e4 	muli	zero,zero,323
    5230:	00005778 	rdprs	zero,zero,349
    5234:	00005458 	cmpnei	zero,zero,337
    5238:	00005820 	cmpeqi	zero,zero,352
    523c:	00005820 	cmpeqi	zero,zero,352
    5240:	00005820 	cmpeqi	zero,zero,352
    5244:	00005758 	cmpnei	zero,zero,349
    5248:	00005458 	cmpnei	zero,zero,337
    524c:	000050e4 	muli	zero,zero,323
    5250:	000050e4 	muli	zero,zero,323
    5254:	00005764 	muli	zero,zero,349
    5258:	000050e4 	muli	zero,zero,323
    525c:	000057a8 	cmpgeui	zero,zero,350
    5260:	00005420 	cmpeqi	zero,zero,336
    5264:	000058a8 	cmpgeui	zero,zero,354
    5268:	000058f4 	movhi	zero,355
    526c:	000050e4 	muli	zero,zero,323
    5270:	00005900 	call	590 <vStartBlockingQueueTasks+0x90>
    5274:	000050e4 	muli	zero,zero,323
    5278:	0000528c 	andi	zero,zero,330
    527c:	000050e4 	muli	zero,zero,323
    5280:	000050e4 	muli	zero,zero,323
    5284:	0000595c 	xori	zero,zero,357
    5288:	84000414 	ori	r16,r16,16
    528c:	8080080c 	andi	r2,r16,32
    5290:	1000f51e 	bne	r2,zero,5668 <___vfprintf_internal_r+0x708>
    5294:	8080040c 	andi	r2,r16,16
    5298:	10042c26 	beq	r2,zero,634c <___vfprintf_internal_r+0x13ec>
    529c:	da012d17 	ldw	r8,1204(sp)
    52a0:	002d883a 	mov	r22,zero
    52a4:	00c00044 	movi	r3,1
    52a8:	45c00017 	ldw	r23,0(r8)
    52ac:	42000104 	addi	r8,r8,4
    52b0:	da012d15 	stw	r8,1204(sp)
    52b4:	b805883a 	mov	r2,r23
    52b8:	d8012585 	stb	zero,1174(sp)
    52bc:	e0000216 	blt	fp,zero,52c8 <___vfprintf_internal_r+0x368>
    52c0:	013fdfc4 	movi	r4,-129
    52c4:	8120703a 	and	r16,r16,r4
    52c8:	1002671e 	bne	r2,zero,5c68 <___vfprintf_internal_r+0xd08>
    52cc:	e002661e 	bne	fp,zero,5c68 <___vfprintf_internal_r+0xd08>
    52d0:	18c03fcc 	andi	r3,r3,255
    52d4:	1803561e 	bne	r3,zero,6030 <___vfprintf_internal_r+0x10d0>
    52d8:	8080004c 	andi	r2,r16,1
    52dc:	10035426 	beq	r2,zero,6030 <___vfprintf_internal_r+0x10d0>
    52e0:	da013917 	ldw	r8,1252(sp)
    52e4:	00800c04 	movi	r2,48
    52e8:	d8810dc5 	stb	r2,1079(sp)
    52ec:	da012b15 	stw	r8,1196(sp)
    52f0:	dcc10dc4 	addi	r19,sp,1079
    52f4:	d8812b17 	ldw	r2,1196(sp)
    52f8:	d8812815 	stw	r2,1184(sp)
    52fc:	1700010e 	bge	r2,fp,5304 <___vfprintf_internal_r+0x3a4>
    5300:	df012815 	stw	fp,1184(sp)
    5304:	d8812583 	ldbu	r2,1174(sp)
    5308:	df013115 	stw	fp,1220(sp)
    530c:	10803fcc 	andi	r2,r2,255
    5310:	1080201c 	xori	r2,r2,128
    5314:	10bfe004 	addi	r2,r2,-128
    5318:	10000326 	beq	r2,zero,5328 <___vfprintf_internal_r+0x3c8>
    531c:	da012817 	ldw	r8,1184(sp)
    5320:	42000044 	addi	r8,r8,1
    5324:	da012815 	stw	r8,1184(sp)
    5328:	80c0008c 	andi	r3,r16,2
    532c:	d8c12a15 	stw	r3,1192(sp)
    5330:	18000326 	beq	r3,zero,5340 <___vfprintf_internal_r+0x3e0>
    5334:	da012817 	ldw	r8,1184(sp)
    5338:	42000084 	addi	r8,r8,2
    533c:	da012815 	stw	r8,1184(sp)
    5340:	80c0210c 	andi	r3,r16,132
    5344:	d8c12f15 	stw	r3,1212(sp)
    5348:	1801941e 	bne	r3,zero,599c <___vfprintf_internal_r+0xa3c>
    534c:	da012e17 	ldw	r8,1208(sp)
    5350:	d8c12817 	ldw	r3,1184(sp)
    5354:	40edc83a 	sub	r22,r8,r3
    5358:	0581900e 	bge	zero,r22,599c <___vfprintf_internal_r+0xa3c>
    535c:	02800404 	movi	r10,16
    5360:	da011d17 	ldw	r8,1140(sp)
    5364:	d8c11c17 	ldw	r3,1136(sp)
    5368:	05c00134 	movhi	r23,4
    536c:	bdc1b884 	addi	r23,r23,1762
    5370:	5580200e 	bge	r10,r22,53f4 <___vfprintf_internal_r+0x494>
    5374:	dc813815 	stw	r18,1248(sp)
    5378:	5039883a 	mov	fp,r10
    537c:	b825883a 	mov	r18,r23
    5380:	050001c4 	movi	r20,7
    5384:	b02f883a 	mov	r23,r22
    5388:	802d883a 	mov	r22,r16
    538c:	dc012917 	ldw	r16,1188(sp)
    5390:	00000306 	br	53a0 <___vfprintf_internal_r+0x440>
    5394:	bdfffc04 	addi	r23,r23,-16
    5398:	4a400204 	addi	r9,r9,8
    539c:	e5c0110e 	bge	fp,r23,53e4 <___vfprintf_internal_r+0x484>
    53a0:	4c800015 	stw	r18,0(r9)
    53a4:	4f000115 	stw	fp,4(r9)
    53a8:	42000404 	addi	r8,r8,16
    53ac:	18c00044 	addi	r3,r3,1
    53b0:	da011d15 	stw	r8,1140(sp)
    53b4:	d8c11c15 	stw	r3,1136(sp)
    53b8:	a0fff60e 	bge	r20,r3,5394 <___vfprintf_internal_r+0x434>
    53bc:	8809883a 	mov	r4,r17
    53c0:	800b883a 	mov	r5,r16
    53c4:	d9811b04 	addi	r6,sp,1132
    53c8:	0004f2c0 	call	4f2c <__sprint_r>
    53cc:	1000771e 	bne	r2,zero,55ac <___vfprintf_internal_r+0x64c>
    53d0:	bdfffc04 	addi	r23,r23,-16
    53d4:	da011d17 	ldw	r8,1140(sp)
    53d8:	d8c11c17 	ldw	r3,1136(sp)
    53dc:	da400404 	addi	r9,sp,16
    53e0:	e5ffef16 	blt	fp,r23,53a0 <___vfprintf_internal_r+0x440>
    53e4:	b021883a 	mov	r16,r22
    53e8:	b82d883a 	mov	r22,r23
    53ec:	902f883a 	mov	r23,r18
    53f0:	dc813817 	ldw	r18,1248(sp)
    53f4:	4dc00015 	stw	r23,0(r9)
    53f8:	4d800115 	stw	r22,4(r9)
    53fc:	4591883a 	add	r8,r8,r22
    5400:	18c00044 	addi	r3,r3,1
    5404:	da011d15 	stw	r8,1140(sp)
    5408:	d8c11c15 	stw	r3,1136(sp)
    540c:	008001c4 	movi	r2,7
    5410:	10c36d16 	blt	r2,r3,61c8 <___vfprintf_internal_r+0x1268>
    5414:	4a400204 	addi	r9,r9,8
    5418:	00016206 	br	59a4 <___vfprintf_internal_r+0xa44>
    541c:	84000414 	ori	r16,r16,16
    5420:	8080080c 	andi	r2,r16,32
    5424:	1000801e 	bne	r2,zero,5628 <___vfprintf_internal_r+0x6c8>
    5428:	8080040c 	andi	r2,r16,16
    542c:	1003da26 	beq	r2,zero,6398 <___vfprintf_internal_r+0x1438>
    5430:	d8c12d17 	ldw	r3,1204(sp)
    5434:	002d883a 	mov	r22,zero
    5438:	1dc00017 	ldw	r23,0(r3)
    543c:	18c00104 	addi	r3,r3,4
    5440:	d8c12d15 	stw	r3,1204(sp)
    5444:	b805883a 	mov	r2,r23
    5448:	0007883a 	mov	r3,zero
    544c:	d8012585 	stb	zero,1174(sp)
    5450:	003f9a06 	br	52bc <___vfprintf_internal_r+0x35c>
    5454:	84000414 	ori	r16,r16,16
    5458:	8080080c 	andi	r2,r16,32
    545c:	10007b1e 	bne	r2,zero,564c <___vfprintf_internal_r+0x6ec>
    5460:	8080040c 	andi	r2,r16,16
    5464:	1003ed26 	beq	r2,zero,641c <___vfprintf_internal_r+0x14bc>
    5468:	d9012d17 	ldw	r4,1204(sp)
    546c:	25c00017 	ldw	r23,0(r4)
    5470:	21000104 	addi	r4,r4,4
    5474:	d9012d15 	stw	r4,1204(sp)
    5478:	b82dd7fa 	srai	r22,r23,31
    547c:	b005883a 	mov	r2,r22
    5480:	1003230e 	bge	r2,zero,6110 <___vfprintf_internal_r+0x11b0>
    5484:	05efc83a 	sub	r23,zero,r23
    5488:	b804c03a 	cmpne	r2,r23,zero
    548c:	05adc83a 	sub	r22,zero,r22
    5490:	b0adc83a 	sub	r22,r22,r2
    5494:	00800b44 	movi	r2,45
    5498:	d8812585 	stb	r2,1174(sp)
    549c:	00c00044 	movi	r3,1
    54a0:	bd84b03a 	or	r2,r23,r22
    54a4:	003f8506 	br	52bc <___vfprintf_internal_r+0x35c>
    54a8:	da012e17 	ldw	r8,1208(sp)
    54ac:	d8812d15 	stw	r2,1204(sp)
    54b0:	0211c83a 	sub	r8,zero,r8
    54b4:	da012e15 	stw	r8,1208(sp)
    54b8:	84000114 	ori	r16,r16,4
    54bc:	ac800007 	ldb	r18,0(r21)
    54c0:	003f0506 	br	50d8 <___vfprintf_internal_r+0x178>
    54c4:	d9013017 	ldw	r4,1216(sp)
    54c8:	d9412917 	ldw	r5,1188(sp)
    54cc:	0006d7c0 	call	6d7c <__swsetup_r>
    54d0:	10003d1e 	bne	r2,zero,55c8 <___vfprintf_internal_r+0x668>
    54d4:	d8c12917 	ldw	r3,1188(sp)
    54d8:	1880030b 	ldhu	r2,12(r3)
    54dc:	00c00284 	movi	r3,10
    54e0:	1100068c 	andi	r4,r2,26
    54e4:	20fec21e 	bne	r4,r3,4ff0 <___vfprintf_internal_r+0x90>
    54e8:	d9012917 	ldw	r4,1188(sp)
    54ec:	20c0038b 	ldhu	r3,14(r4)
    54f0:	193fffcc 	andi	r4,r3,65535
    54f4:	2120001c 	xori	r4,r4,32768
    54f8:	21200004 	addi	r4,r4,-32768
    54fc:	203ebc16 	blt	r4,zero,4ff0 <___vfprintf_internal_r+0x90>
    5500:	da012917 	ldw	r8,1188(sp)
    5504:	d9013017 	ldw	r4,1216(sp)
    5508:	d9c12d17 	ldw	r7,1204(sp)
    550c:	42800717 	ldw	r10,28(r8)
    5510:	42400917 	ldw	r9,36(r8)
    5514:	10bfff4c 	andi	r2,r2,65533
    5518:	02010004 	movi	r8,1024
    551c:	d881070d 	sth	r2,1052(sp)
    5520:	d9410404 	addi	r5,sp,1040
    5524:	d8800404 	addi	r2,sp,16
    5528:	800d883a 	mov	r6,r16
    552c:	d8c1078d 	sth	r3,1054(sp)
    5530:	da810b15 	stw	r10,1068(sp)
    5534:	da410d15 	stw	r9,1076(sp)
    5538:	d8810415 	stw	r2,1040(sp)
    553c:	d8810815 	stw	r2,1056(sp)
    5540:	da010615 	stw	r8,1048(sp)
    5544:	da010915 	stw	r8,1060(sp)
    5548:	d8010a15 	stw	zero,1064(sp)
    554c:	0004f600 	call	4f60 <___vfprintf_internal_r>
    5550:	d8812c15 	stw	r2,1200(sp)
    5554:	10000416 	blt	r2,zero,5568 <___vfprintf_internal_r+0x608>
    5558:	d9013017 	ldw	r4,1216(sp)
    555c:	d9410404 	addi	r5,sp,1040
    5560:	00087140 	call	8714 <_fflush_r>
    5564:	1005d81e 	bne	r2,zero,6cc8 <___vfprintf_internal_r+0x1d68>
    5568:	d881070b 	ldhu	r2,1052(sp)
    556c:	1080100c 	andi	r2,r2,64
    5570:	10bfffcc 	andi	r2,r2,65535
    5574:	10a0001c 	xori	r2,r2,32768
    5578:	10a00004 	addi	r2,r2,-32768
    557c:	10001426 	beq	r2,zero,55d0 <___vfprintf_internal_r+0x670>
    5580:	d8c12917 	ldw	r3,1188(sp)
    5584:	1880030b 	ldhu	r2,12(r3)
    5588:	10801014 	ori	r2,r2,64
    558c:	1880030d 	sth	r2,12(r3)
    5590:	00000f06 	br	55d0 <___vfprintf_internal_r+0x670>
    5594:	d8811d17 	ldw	r2,1140(sp)
    5598:	10000426 	beq	r2,zero,55ac <___vfprintf_internal_r+0x64c>
    559c:	d9013017 	ldw	r4,1216(sp)
    55a0:	d9412917 	ldw	r5,1188(sp)
    55a4:	d9811b04 	addi	r6,sp,1132
    55a8:	0004f2c0 	call	4f2c <__sprint_r>
    55ac:	d8c12917 	ldw	r3,1188(sp)
    55b0:	1880030b 	ldhu	r2,12(r3)
    55b4:	1080100c 	andi	r2,r2,64
    55b8:	10bfffcc 	andi	r2,r2,65535
    55bc:	10a0001c 	xori	r2,r2,32768
    55c0:	10a00004 	addi	r2,r2,-32768
    55c4:	10000226 	beq	r2,zero,55d0 <___vfprintf_internal_r+0x670>
    55c8:	00bfffc4 	movi	r2,-1
    55cc:	d8812c15 	stw	r2,1200(sp)
    55d0:	d8812c17 	ldw	r2,1200(sp)
    55d4:	dfc14617 	ldw	ra,1304(sp)
    55d8:	df014517 	ldw	fp,1300(sp)
    55dc:	ddc14417 	ldw	r23,1296(sp)
    55e0:	dd814317 	ldw	r22,1292(sp)
    55e4:	dd414217 	ldw	r21,1288(sp)
    55e8:	dd014117 	ldw	r20,1284(sp)
    55ec:	dcc14017 	ldw	r19,1280(sp)
    55f0:	dc813f17 	ldw	r18,1276(sp)
    55f4:	dc413e17 	ldw	r17,1272(sp)
    55f8:	dc013d17 	ldw	r16,1268(sp)
    55fc:	dec14704 	addi	sp,sp,1308
    5600:	f800283a 	ret
    5604:	d9412917 	ldw	r5,1188(sp)
    5608:	8809883a 	mov	r4,r17
    560c:	d9811b04 	addi	r6,sp,1132
    5610:	0004f2c0 	call	4f2c <__sprint_r>
    5614:	103fe51e 	bne	r2,zero,55ac <___vfprintf_internal_r+0x64c>
    5618:	da400404 	addi	r9,sp,16
    561c:	003e9d06 	br	5094 <___vfprintf_internal_r+0x134>
    5620:	00089bc0 	call	89bc <__sinit>
    5624:	003e6606 	br	4fc0 <___vfprintf_internal_r+0x60>
    5628:	d8812d17 	ldw	r2,1204(sp)
    562c:	0007883a 	mov	r3,zero
    5630:	15c00017 	ldw	r23,0(r2)
    5634:	15800117 	ldw	r22,4(r2)
    5638:	10800204 	addi	r2,r2,8
    563c:	d8812d15 	stw	r2,1204(sp)
    5640:	d8012585 	stb	zero,1174(sp)
    5644:	bd84b03a 	or	r2,r23,r22
    5648:	003f1c06 	br	52bc <___vfprintf_internal_r+0x35c>
    564c:	d8c12d17 	ldw	r3,1204(sp)
    5650:	18800117 	ldw	r2,4(r3)
    5654:	1dc00017 	ldw	r23,0(r3)
    5658:	18c00204 	addi	r3,r3,8
    565c:	d8c12d15 	stw	r3,1204(sp)
    5660:	102d883a 	mov	r22,r2
    5664:	003f8606 	br	5480 <___vfprintf_internal_r+0x520>
    5668:	d8c12d17 	ldw	r3,1204(sp)
    566c:	d9012d17 	ldw	r4,1204(sp)
    5670:	1dc00017 	ldw	r23,0(r3)
    5674:	1d800117 	ldw	r22,4(r3)
    5678:	21000204 	addi	r4,r4,8
    567c:	00c00044 	movi	r3,1
    5680:	d9012d15 	stw	r4,1204(sp)
    5684:	bd84b03a 	or	r2,r23,r22
    5688:	d8012585 	stb	zero,1174(sp)
    568c:	003f0b06 	br	52bc <___vfprintf_internal_r+0x35c>
    5690:	d9812585 	stb	r6,1174(sp)
    5694:	ac800007 	ldb	r18,0(r21)
    5698:	003e8f06 	br	50d8 <___vfprintf_internal_r+0x178>
    569c:	ac800007 	ldb	r18,0(r21)
    56a0:	a9000044 	addi	r4,r21,1
    56a4:	92857d26 	beq	r18,r10,6c9c <___vfprintf_internal_r+0x1d3c>
    56a8:	90bff404 	addi	r2,r18,-48
    56ac:	0039883a 	mov	fp,zero
    56b0:	28800736 	bltu	r5,r2,56d0 <___vfprintf_internal_r+0x770>
    56b4:	24800007 	ldb	r18,0(r4)
    56b8:	e70002a4 	muli	fp,fp,10
    56bc:	21000044 	addi	r4,r4,1
    56c0:	1739883a 	add	fp,r2,fp
    56c4:	90bff404 	addi	r2,r18,-48
    56c8:	28bffa2e 	bgeu	r5,r2,56b4 <___vfprintf_internal_r+0x754>
    56cc:	e0044216 	blt	fp,zero,67d8 <___vfprintf_internal_r+0x1878>
    56d0:	202b883a 	mov	r21,r4
    56d4:	003e8106 	br	50dc <___vfprintf_internal_r+0x17c>
    56d8:	d8812587 	ldb	r2,1174(sp)
    56dc:	1003581e 	bne	r2,zero,6440 <___vfprintf_internal_r+0x14e0>
    56e0:	dac12585 	stb	r11,1174(sp)
    56e4:	ac800007 	ldb	r18,0(r21)
    56e8:	003e7b06 	br	50d8 <___vfprintf_internal_r+0x178>
    56ec:	84000054 	ori	r16,r16,1
    56f0:	ac800007 	ldb	r18,0(r21)
    56f4:	003e7806 	br	50d8 <___vfprintf_internal_r+0x178>
    56f8:	84002014 	ori	r16,r16,128
    56fc:	ac800007 	ldb	r18,0(r21)
    5700:	003e7506 	br	50d8 <___vfprintf_internal_r+0x178>
    5704:	02000134 	movhi	r8,4
    5708:	4201ac04 	addi	r8,r8,1712
    570c:	da013615 	stw	r8,1240(sp)
    5710:	8080080c 	andi	r2,r16,32
    5714:	10009626 	beq	r2,zero,5970 <___vfprintf_internal_r+0xa10>
    5718:	d8812d17 	ldw	r2,1204(sp)
    571c:	15c00017 	ldw	r23,0(r2)
    5720:	15800117 	ldw	r22,4(r2)
    5724:	10800204 	addi	r2,r2,8
    5728:	d8812d15 	stw	r2,1204(sp)
    572c:	8080004c 	andi	r2,r16,1
    5730:	1002ae26 	beq	r2,zero,61ec <___vfprintf_internal_r+0x128c>
    5734:	bd84b03a 	or	r2,r23,r22
    5738:	10032a26 	beq	r2,zero,63e4 <___vfprintf_internal_r+0x1484>
    573c:	00c00c04 	movi	r3,48
    5740:	d8c12505 	stb	r3,1172(sp)
    5744:	dc812545 	stb	r18,1173(sp)
    5748:	84000094 	ori	r16,r16,2
    574c:	00c00084 	movi	r3,2
    5750:	d8012585 	stb	zero,1174(sp)
    5754:	003ed906 	br	52bc <___vfprintf_internal_r+0x35c>
    5758:	84001014 	ori	r16,r16,64
    575c:	ac800007 	ldb	r18,0(r21)
    5760:	003e5d06 	br	50d8 <___vfprintf_internal_r+0x178>
    5764:	ac800007 	ldb	r18,0(r21)
    5768:	a805883a 	mov	r2,r21
    576c:	91c43226 	beq	r18,r7,6838 <___vfprintf_internal_r+0x18d8>
    5770:	84000414 	ori	r16,r16,16
    5774:	003e5806 	br	50d8 <___vfprintf_internal_r+0x178>
    5778:	d8c12d17 	ldw	r3,1204(sp)
    577c:	02000044 	movi	r8,1
    5780:	da012815 	stw	r8,1184(sp)
    5784:	18800017 	ldw	r2,0(r3)
    5788:	18c00104 	addi	r3,r3,4
    578c:	d8012585 	stb	zero,1174(sp)
    5790:	d8810405 	stb	r2,1040(sp)
    5794:	d8c12d15 	stw	r3,1204(sp)
    5798:	da012b15 	stw	r8,1196(sp)
    579c:	dcc10404 	addi	r19,sp,1040
    57a0:	d8013115 	stw	zero,1220(sp)
    57a4:	003ee006 	br	5328 <___vfprintf_internal_r+0x3c8>
    57a8:	8080080c 	andi	r2,r16,32
    57ac:	10031026 	beq	r2,zero,63f0 <___vfprintf_internal_r+0x1490>
    57b0:	d9012d17 	ldw	r4,1204(sp)
    57b4:	da012c17 	ldw	r8,1200(sp)
    57b8:	20800017 	ldw	r2,0(r4)
    57bc:	4007d7fa 	srai	r3,r8,31
    57c0:	21000104 	addi	r4,r4,4
    57c4:	d9012d15 	stw	r4,1204(sp)
    57c8:	12000015 	stw	r8,0(r2)
    57cc:	10c00115 	stw	r3,4(r2)
    57d0:	003e1906 	br	5038 <___vfprintf_internal_r+0xd8>
    57d4:	da012d17 	ldw	r8,1204(sp)
    57d8:	d9012d17 	ldw	r4,1204(sp)
    57dc:	42000017 	ldw	r8,0(r8)
    57e0:	20800104 	addi	r2,r4,4
    57e4:	da012e15 	stw	r8,1208(sp)
    57e8:	403f2f16 	blt	r8,zero,54a8 <___vfprintf_internal_r+0x548>
    57ec:	d8812d15 	stw	r2,1204(sp)
    57f0:	ac800007 	ldb	r18,0(r21)
    57f4:	003e3806 	br	50d8 <___vfprintf_internal_r+0x178>
    57f8:	0009883a 	mov	r4,zero
    57fc:	90bff404 	addi	r2,r18,-48
    5800:	ac800007 	ldb	r18,0(r21)
    5804:	210002a4 	muli	r4,r4,10
    5808:	ad400044 	addi	r21,r21,1
    580c:	2089883a 	add	r4,r4,r2
    5810:	90bff404 	addi	r2,r18,-48
    5814:	28bffa2e 	bgeu	r5,r2,5800 <___vfprintf_internal_r+0x8a0>
    5818:	d9012e15 	stw	r4,1208(sp)
    581c:	003e2f06 	br	50dc <___vfprintf_internal_r+0x17c>
    5820:	8080020c 	andi	r2,r16,8
    5824:	1002d426 	beq	r2,zero,6378 <___vfprintf_internal_r+0x1418>
    5828:	d8c12d17 	ldw	r3,1204(sp)
    582c:	1d800017 	ldw	r22,0(r3)
    5830:	1d000117 	ldw	r20,4(r3)
    5834:	18c00204 	addi	r3,r3,8
    5838:	d8c12d15 	stw	r3,1204(sp)
    583c:	dd813315 	stw	r22,1228(sp)
    5840:	dd013415 	stw	r20,1232(sp)
    5844:	b009883a 	mov	r4,r22
    5848:	a00b883a 	mov	r5,r20
    584c:	da413c15 	stw	r9,1264(sp)
    5850:	000bb000 	call	bb00 <__isinfd>
    5854:	da413c17 	ldw	r9,1264(sp)
    5858:	b009883a 	mov	r4,r22
    585c:	a00b883a 	mov	r5,r20
    5860:	10035726 	beq	r2,zero,65c0 <___vfprintf_internal_r+0x1660>
    5864:	000d883a 	mov	r6,zero
    5868:	000f883a 	mov	r7,zero
    586c:	000d8f80 	call	d8f8 <__ltdf2>
    5870:	da413c17 	ldw	r9,1264(sp)
    5874:	10041b16 	blt	r2,zero,68e4 <___vfprintf_internal_r+0x1984>
    5878:	d8812583 	ldbu	r2,1174(sp)
    587c:	00c011c4 	movi	r3,71
    5880:	1c830b16 	blt	r3,r18,64b0 <___vfprintf_internal_r+0x1550>
    5884:	04c00134 	movhi	r19,4
    5888:	9cc1a804 	addi	r19,r19,1696
    588c:	020000c4 	movi	r8,3
    5890:	00ffdfc4 	movi	r3,-129
    5894:	da012815 	stw	r8,1184(sp)
    5898:	80e0703a 	and	r16,r16,r3
    589c:	da012b15 	stw	r8,1196(sp)
    58a0:	d8013115 	stw	zero,1220(sp)
    58a4:	003e9906 	br	530c <___vfprintf_internal_r+0x3ac>
    58a8:	d8812d17 	ldw	r2,1204(sp)
    58ac:	d8c12d17 	ldw	r3,1204(sp)
    58b0:	02000134 	movhi	r8,4
    58b4:	4201b104 	addi	r8,r8,1732
    58b8:	15c00017 	ldw	r23,0(r2)
    58bc:	00800c04 	movi	r2,48
    58c0:	18c00104 	addi	r3,r3,4
    58c4:	d8812505 	stb	r2,1172(sp)
    58c8:	00801e04 	movi	r2,120
    58cc:	d8812545 	stb	r2,1173(sp)
    58d0:	d8c12d15 	stw	r3,1204(sp)
    58d4:	002d883a 	mov	r22,zero
    58d8:	84000094 	ori	r16,r16,2
    58dc:	da013615 	stw	r8,1240(sp)
    58e0:	00c00084 	movi	r3,2
    58e4:	04801e04 	movi	r18,120
    58e8:	b805883a 	mov	r2,r23
    58ec:	d8012585 	stb	zero,1174(sp)
    58f0:	003e7206 	br	52bc <___vfprintf_internal_r+0x35c>
    58f4:	84000814 	ori	r16,r16,32
    58f8:	ac800007 	ldb	r18,0(r21)
    58fc:	003df606 	br	50d8 <___vfprintf_internal_r+0x178>
    5900:	d8812d17 	ldw	r2,1204(sp)
    5904:	d8012585 	stb	zero,1174(sp)
    5908:	14c00017 	ldw	r19,0(r2)
    590c:	15c00104 	addi	r23,r2,4
    5910:	98040126 	beq	r19,zero,6918 <___vfprintf_internal_r+0x19b8>
    5914:	9809883a 	mov	r4,r19
    5918:	e003dd16 	blt	fp,zero,6890 <___vfprintf_internal_r+0x1930>
    591c:	000b883a 	mov	r5,zero
    5920:	e00d883a 	mov	r6,fp
    5924:	da413c15 	stw	r9,1264(sp)
    5928:	000a1900 	call	a190 <memchr>
    592c:	da413c17 	ldw	r9,1264(sp)
    5930:	10042e26 	beq	r2,zero,69ec <___vfprintf_internal_r+0x1a8c>
    5934:	14c5c83a 	sub	r2,r2,r19
    5938:	d8812b15 	stw	r2,1196(sp)
    593c:	e083790e 	bge	fp,r2,6724 <___vfprintf_internal_r+0x17c4>
    5940:	df012815 	stw	fp,1184(sp)
    5944:	e0049516 	blt	fp,zero,6b9c <___vfprintf_internal_r+0x1c3c>
    5948:	d8812583 	ldbu	r2,1174(sp)
    594c:	df012b15 	stw	fp,1196(sp)
    5950:	ddc12d15 	stw	r23,1204(sp)
    5954:	d8013115 	stw	zero,1220(sp)
    5958:	003e6c06 	br	530c <___vfprintf_internal_r+0x3ac>
    595c:	02000134 	movhi	r8,4
    5960:	4201b104 	addi	r8,r8,1732
    5964:	da013615 	stw	r8,1240(sp)
    5968:	8080080c 	andi	r2,r16,32
    596c:	103f6a1e 	bne	r2,zero,5718 <___vfprintf_internal_r+0x7b8>
    5970:	8080040c 	andi	r2,r16,16
    5974:	10029326 	beq	r2,zero,63c4 <___vfprintf_internal_r+0x1464>
    5978:	d8c12d17 	ldw	r3,1204(sp)
    597c:	002d883a 	mov	r22,zero
    5980:	1dc00017 	ldw	r23,0(r3)
    5984:	18c00104 	addi	r3,r3,4
    5988:	d8c12d15 	stw	r3,1204(sp)
    598c:	003f6706 	br	572c <___vfprintf_internal_r+0x7cc>
    5990:	84000214 	ori	r16,r16,8
    5994:	ac800007 	ldb	r18,0(r21)
    5998:	003dcf06 	br	50d8 <___vfprintf_internal_r+0x178>
    599c:	da011d17 	ldw	r8,1140(sp)
    59a0:	d8c11c17 	ldw	r3,1136(sp)
    59a4:	d8812587 	ldb	r2,1174(sp)
    59a8:	10000b26 	beq	r2,zero,59d8 <___vfprintf_internal_r+0xa78>
    59ac:	d8812584 	addi	r2,sp,1174
    59b0:	48800015 	stw	r2,0(r9)
    59b4:	00800044 	movi	r2,1
    59b8:	48800115 	stw	r2,4(r9)
    59bc:	4091883a 	add	r8,r8,r2
    59c0:	1887883a 	add	r3,r3,r2
    59c4:	da011d15 	stw	r8,1140(sp)
    59c8:	d8c11c15 	stw	r3,1136(sp)
    59cc:	008001c4 	movi	r2,7
    59d0:	10c18516 	blt	r2,r3,5fe8 <___vfprintf_internal_r+0x1088>
    59d4:	4a400204 	addi	r9,r9,8
    59d8:	d9012a17 	ldw	r4,1192(sp)
    59dc:	20000b26 	beq	r4,zero,5a0c <___vfprintf_internal_r+0xaac>
    59e0:	d8812504 	addi	r2,sp,1172
    59e4:	48800015 	stw	r2,0(r9)
    59e8:	00800084 	movi	r2,2
    59ec:	48800115 	stw	r2,4(r9)
    59f0:	4091883a 	add	r8,r8,r2
    59f4:	18c00044 	addi	r3,r3,1
    59f8:	da011d15 	stw	r8,1140(sp)
    59fc:	d8c11c15 	stw	r3,1136(sp)
    5a00:	008001c4 	movi	r2,7
    5a04:	10c18116 	blt	r2,r3,600c <___vfprintf_internal_r+0x10ac>
    5a08:	4a400204 	addi	r9,r9,8
    5a0c:	d9012f17 	ldw	r4,1212(sp)
    5a10:	00802004 	movi	r2,128
    5a14:	2080fc26 	beq	r4,r2,5e08 <___vfprintf_internal_r+0xea8>
    5a18:	d8813117 	ldw	r2,1220(sp)
    5a1c:	d9012b17 	ldw	r4,1196(sp)
    5a20:	112fc83a 	sub	r23,r2,r4
    5a24:	05c02a0e 	bge	zero,r23,5ad0 <___vfprintf_internal_r+0xb70>
    5a28:	07000404 	movi	fp,16
    5a2c:	05000134 	movhi	r20,4
    5a30:	a501bc84 	addi	r20,r20,1778
    5a34:	e5c01d0e 	bge	fp,r23,5aac <___vfprintf_internal_r+0xb4c>
    5a38:	dc812a15 	stw	r18,1192(sp)
    5a3c:	058001c4 	movi	r22,7
    5a40:	a025883a 	mov	r18,r20
    5a44:	8029883a 	mov	r20,r16
    5a48:	dc012917 	ldw	r16,1188(sp)
    5a4c:	00000306 	br	5a5c <___vfprintf_internal_r+0xafc>
    5a50:	bdfffc04 	addi	r23,r23,-16
    5a54:	4a400204 	addi	r9,r9,8
    5a58:	e5c0110e 	bge	fp,r23,5aa0 <___vfprintf_internal_r+0xb40>
    5a5c:	4c800015 	stw	r18,0(r9)
    5a60:	4f000115 	stw	fp,4(r9)
    5a64:	42000404 	addi	r8,r8,16
    5a68:	18c00044 	addi	r3,r3,1
    5a6c:	da011d15 	stw	r8,1140(sp)
    5a70:	d8c11c15 	stw	r3,1136(sp)
    5a74:	b0fff60e 	bge	r22,r3,5a50 <___vfprintf_internal_r+0xaf0>
    5a78:	8809883a 	mov	r4,r17
    5a7c:	800b883a 	mov	r5,r16
    5a80:	d9811b04 	addi	r6,sp,1132
    5a84:	0004f2c0 	call	4f2c <__sprint_r>
    5a88:	103ec81e 	bne	r2,zero,55ac <___vfprintf_internal_r+0x64c>
    5a8c:	bdfffc04 	addi	r23,r23,-16
    5a90:	da011d17 	ldw	r8,1140(sp)
    5a94:	d8c11c17 	ldw	r3,1136(sp)
    5a98:	da400404 	addi	r9,sp,16
    5a9c:	e5ffef16 	blt	fp,r23,5a5c <___vfprintf_internal_r+0xafc>
    5aa0:	a021883a 	mov	r16,r20
    5aa4:	9029883a 	mov	r20,r18
    5aa8:	dc812a17 	ldw	r18,1192(sp)
    5aac:	4d000015 	stw	r20,0(r9)
    5ab0:	4dc00115 	stw	r23,4(r9)
    5ab4:	45d1883a 	add	r8,r8,r23
    5ab8:	18c00044 	addi	r3,r3,1
    5abc:	da011d15 	stw	r8,1140(sp)
    5ac0:	d8c11c15 	stw	r3,1136(sp)
    5ac4:	008001c4 	movi	r2,7
    5ac8:	10c13e16 	blt	r2,r3,5fc4 <___vfprintf_internal_r+0x1064>
    5acc:	4a400204 	addi	r9,r9,8
    5ad0:	8080400c 	andi	r2,r16,256
    5ad4:	1000831e 	bne	r2,zero,5ce4 <___vfprintf_internal_r+0xd84>
    5ad8:	d8812b17 	ldw	r2,1196(sp)
    5adc:	4cc00015 	stw	r19,0(r9)
    5ae0:	48800115 	stw	r2,4(r9)
    5ae4:	4091883a 	add	r8,r8,r2
    5ae8:	18c00044 	addi	r3,r3,1
    5aec:	da011d15 	stw	r8,1140(sp)
    5af0:	d8c11c15 	stw	r3,1136(sp)
    5af4:	008001c4 	movi	r2,7
    5af8:	10c05316 	blt	r2,r3,5c48 <___vfprintf_internal_r+0xce8>
    5afc:	4a400204 	addi	r9,r9,8
    5b00:	8400010c 	andi	r16,r16,4
    5b04:	80002e26 	beq	r16,zero,5bc0 <___vfprintf_internal_r+0xc60>
    5b08:	d8812e17 	ldw	r2,1208(sp)
    5b0c:	d8c12817 	ldw	r3,1184(sp)
    5b10:	10e1c83a 	sub	r16,r2,r3
    5b14:	04002a0e 	bge	zero,r16,5bc0 <___vfprintf_internal_r+0xc60>
    5b18:	04800404 	movi	r18,16
    5b1c:	d8c11c17 	ldw	r3,1136(sp)
    5b20:	05c00134 	movhi	r23,4
    5b24:	bdc1b884 	addi	r23,r23,1762
    5b28:	9400170e 	bge	r18,r16,5b88 <___vfprintf_internal_r+0xc28>
    5b2c:	04c001c4 	movi	r19,7
    5b30:	dd012917 	ldw	r20,1188(sp)
    5b34:	00000306 	br	5b44 <___vfprintf_internal_r+0xbe4>
    5b38:	843ffc04 	addi	r16,r16,-16
    5b3c:	4a400204 	addi	r9,r9,8
    5b40:	9400110e 	bge	r18,r16,5b88 <___vfprintf_internal_r+0xc28>
    5b44:	4dc00015 	stw	r23,0(r9)
    5b48:	4c800115 	stw	r18,4(r9)
    5b4c:	42000404 	addi	r8,r8,16
    5b50:	18c00044 	addi	r3,r3,1
    5b54:	da011d15 	stw	r8,1140(sp)
    5b58:	d8c11c15 	stw	r3,1136(sp)
    5b5c:	98fff60e 	bge	r19,r3,5b38 <___vfprintf_internal_r+0xbd8>
    5b60:	8809883a 	mov	r4,r17
    5b64:	a00b883a 	mov	r5,r20
    5b68:	d9811b04 	addi	r6,sp,1132
    5b6c:	0004f2c0 	call	4f2c <__sprint_r>
    5b70:	103e8e1e 	bne	r2,zero,55ac <___vfprintf_internal_r+0x64c>
    5b74:	843ffc04 	addi	r16,r16,-16
    5b78:	da011d17 	ldw	r8,1140(sp)
    5b7c:	d8c11c17 	ldw	r3,1136(sp)
    5b80:	da400404 	addi	r9,sp,16
    5b84:	943fef16 	blt	r18,r16,5b44 <___vfprintf_internal_r+0xbe4>
    5b88:	4dc00015 	stw	r23,0(r9)
    5b8c:	4c000115 	stw	r16,4(r9)
    5b90:	8211883a 	add	r8,r16,r8
    5b94:	18c00044 	addi	r3,r3,1
    5b98:	da011d15 	stw	r8,1140(sp)
    5b9c:	d8c11c15 	stw	r3,1136(sp)
    5ba0:	008001c4 	movi	r2,7
    5ba4:	10c0060e 	bge	r2,r3,5bc0 <___vfprintf_internal_r+0xc60>
    5ba8:	d9412917 	ldw	r5,1188(sp)
    5bac:	8809883a 	mov	r4,r17
    5bb0:	d9811b04 	addi	r6,sp,1132
    5bb4:	0004f2c0 	call	4f2c <__sprint_r>
    5bb8:	103e7c1e 	bne	r2,zero,55ac <___vfprintf_internal_r+0x64c>
    5bbc:	da011d17 	ldw	r8,1140(sp)
    5bc0:	dd012817 	ldw	r20,1184(sp)
    5bc4:	d9012e17 	ldw	r4,1208(sp)
    5bc8:	a100010e 	bge	r20,r4,5bd0 <___vfprintf_internal_r+0xc70>
    5bcc:	2029883a 	mov	r20,r4
    5bd0:	d8812c17 	ldw	r2,1200(sp)
    5bd4:	1505883a 	add	r2,r2,r20
    5bd8:	d8812c15 	stw	r2,1200(sp)
    5bdc:	4000b91e 	bne	r8,zero,5ec4 <___vfprintf_internal_r+0xf64>
    5be0:	d8011c15 	stw	zero,1136(sp)
    5be4:	a8800007 	ldb	r2,0(r21)
    5be8:	da400404 	addi	r9,sp,16
    5bec:	103d141e 	bne	r2,zero,5040 <___vfprintf_internal_r+0xe0>
    5bf0:	a825883a 	mov	r18,r21
    5bf4:	003d2a06 	br	50a0 <___vfprintf_internal_r+0x140>
    5bf8:	d9412917 	ldw	r5,1188(sp)
    5bfc:	8809883a 	mov	r4,r17
    5c00:	d9811b04 	addi	r6,sp,1132
    5c04:	0004f2c0 	call	4f2c <__sprint_r>
    5c08:	103e681e 	bne	r2,zero,55ac <___vfprintf_internal_r+0x64c>
    5c0c:	da011d17 	ldw	r8,1140(sp)
    5c10:	da400404 	addi	r9,sp,16
    5c14:	8080004c 	andi	r2,r16,1
    5c18:	103fb926 	beq	r2,zero,5b00 <___vfprintf_internal_r+0xba0>
    5c1c:	d8c11c17 	ldw	r3,1136(sp)
    5c20:	d9013717 	ldw	r4,1244(sp)
    5c24:	00800044 	movi	r2,1
    5c28:	48800115 	stw	r2,4(r9)
    5c2c:	49000015 	stw	r4,0(r9)
    5c30:	4091883a 	add	r8,r8,r2
    5c34:	1887883a 	add	r3,r3,r2
    5c38:	da011d15 	stw	r8,1140(sp)
    5c3c:	d8c11c15 	stw	r3,1136(sp)
    5c40:	008001c4 	movi	r2,7
    5c44:	10ffad0e 	bge	r2,r3,5afc <___vfprintf_internal_r+0xb9c>
    5c48:	d9412917 	ldw	r5,1188(sp)
    5c4c:	8809883a 	mov	r4,r17
    5c50:	d9811b04 	addi	r6,sp,1132
    5c54:	0004f2c0 	call	4f2c <__sprint_r>
    5c58:	103e541e 	bne	r2,zero,55ac <___vfprintf_internal_r+0x64c>
    5c5c:	da400404 	addi	r9,sp,16
    5c60:	da011d17 	ldw	r8,1140(sp)
    5c64:	003fa606 	br	5b00 <___vfprintf_internal_r+0xba0>
    5c68:	18803fcc 	andi	r2,r3,255
    5c6c:	00c00044 	movi	r3,1
    5c70:	10c10126 	beq	r2,r3,6078 <___vfprintf_internal_r+0x1118>
    5c74:	00c00084 	movi	r3,2
    5c78:	10c0f026 	beq	r2,r3,603c <___vfprintf_internal_r+0x10dc>
    5c7c:	d8c10dc4 	addi	r3,sp,1079
    5c80:	b808d0fa 	srli	r4,r23,3
    5c84:	b00a977a 	slli	r5,r22,29
    5c88:	b02cd0fa 	srli	r22,r22,3
    5c8c:	bdc001cc 	andi	r23,r23,7
    5c90:	b8800c04 	addi	r2,r23,48
    5c94:	292eb03a 	or	r23,r5,r4
    5c98:	18800005 	stb	r2,0(r3)
    5c9c:	bd88b03a 	or	r4,r23,r22
    5ca0:	1827883a 	mov	r19,r3
    5ca4:	18ffffc4 	addi	r3,r3,-1
    5ca8:	203ff51e 	bne	r4,zero,5c80 <___vfprintf_internal_r+0xd20>
    5cac:	8100004c 	andi	r4,r16,1
    5cb0:	980b883a 	mov	r5,r19
    5cb4:	20000726 	beq	r4,zero,5cd4 <___vfprintf_internal_r+0xd74>
    5cb8:	10803fcc 	andi	r2,r2,255
    5cbc:	1080201c 	xori	r2,r2,128
    5cc0:	10bfe004 	addi	r2,r2,-128
    5cc4:	01000c04 	movi	r4,48
    5cc8:	11000226 	beq	r2,r4,5cd4 <___vfprintf_internal_r+0xd74>
    5ccc:	1827883a 	mov	r19,r3
    5cd0:	293fffc5 	stb	r4,-1(r5)
    5cd4:	d8812717 	ldw	r2,1180(sp)
    5cd8:	14c5c83a 	sub	r2,r2,r19
    5cdc:	d8812b15 	stw	r2,1196(sp)
    5ce0:	003d8406 	br	52f4 <___vfprintf_internal_r+0x394>
    5ce4:	00801944 	movi	r2,101
    5ce8:	14807c0e 	bge	r2,r18,5edc <___vfprintf_internal_r+0xf7c>
    5cec:	d9013317 	ldw	r4,1228(sp)
    5cf0:	d9413417 	ldw	r5,1232(sp)
    5cf4:	000d883a 	mov	r6,zero
    5cf8:	000f883a 	mov	r7,zero
    5cfc:	d8c13b15 	stw	r3,1260(sp)
    5d00:	da013a15 	stw	r8,1256(sp)
    5d04:	da413c15 	stw	r9,1264(sp)
    5d08:	000d7780 	call	d778 <__eqdf2>
    5d0c:	d8c13b17 	ldw	r3,1260(sp)
    5d10:	da013a17 	ldw	r8,1256(sp)
    5d14:	da413c17 	ldw	r9,1264(sp)
    5d18:	1001001e 	bne	r2,zero,611c <___vfprintf_internal_r+0x11bc>
    5d1c:	00800134 	movhi	r2,4
    5d20:	1081b804 	addi	r2,r2,1760
    5d24:	48800015 	stw	r2,0(r9)
    5d28:	00800044 	movi	r2,1
    5d2c:	48800115 	stw	r2,4(r9)
    5d30:	4091883a 	add	r8,r8,r2
    5d34:	1887883a 	add	r3,r3,r2
    5d38:	da011d15 	stw	r8,1140(sp)
    5d3c:	d8c11c15 	stw	r3,1136(sp)
    5d40:	008001c4 	movi	r2,7
    5d44:	10c1dd16 	blt	r2,r3,64bc <___vfprintf_internal_r+0x155c>
    5d48:	4a400204 	addi	r9,r9,8
    5d4c:	d8812417 	ldw	r2,1168(sp)
    5d50:	d8c13217 	ldw	r3,1224(sp)
    5d54:	10c00216 	blt	r2,r3,5d60 <___vfprintf_internal_r+0xe00>
    5d58:	8080004c 	andi	r2,r16,1
    5d5c:	103f6826 	beq	r2,zero,5b00 <___vfprintf_internal_r+0xba0>
    5d60:	d8c11c17 	ldw	r3,1136(sp)
    5d64:	d9013717 	ldw	r4,1244(sp)
    5d68:	00800044 	movi	r2,1
    5d6c:	48800115 	stw	r2,4(r9)
    5d70:	49000015 	stw	r4,0(r9)
    5d74:	4091883a 	add	r8,r8,r2
    5d78:	1887883a 	add	r3,r3,r2
    5d7c:	da011d15 	stw	r8,1140(sp)
    5d80:	d8c11c15 	stw	r3,1136(sp)
    5d84:	008001c4 	movi	r2,7
    5d88:	10c2af16 	blt	r2,r3,6848 <___vfprintf_internal_r+0x18e8>
    5d8c:	4a400204 	addi	r9,r9,8
    5d90:	d8813217 	ldw	r2,1224(sp)
    5d94:	14bfffc4 	addi	r18,r2,-1
    5d98:	04bf590e 	bge	zero,r18,5b00 <___vfprintf_internal_r+0xba0>
    5d9c:	04c00404 	movi	r19,16
    5da0:	d8c11c17 	ldw	r3,1136(sp)
    5da4:	05000134 	movhi	r20,4
    5da8:	a501bc84 	addi	r20,r20,1778
    5dac:	9c81630e 	bge	r19,r18,633c <___vfprintf_internal_r+0x13dc>
    5db0:	058001c4 	movi	r22,7
    5db4:	ddc12917 	ldw	r23,1188(sp)
    5db8:	00000306 	br	5dc8 <___vfprintf_internal_r+0xe68>
    5dbc:	4a400204 	addi	r9,r9,8
    5dc0:	94bffc04 	addi	r18,r18,-16
    5dc4:	9c815d0e 	bge	r19,r18,633c <___vfprintf_internal_r+0x13dc>
    5dc8:	4d000015 	stw	r20,0(r9)
    5dcc:	4cc00115 	stw	r19,4(r9)
    5dd0:	42000404 	addi	r8,r8,16
    5dd4:	18c00044 	addi	r3,r3,1
    5dd8:	da011d15 	stw	r8,1140(sp)
    5ddc:	d8c11c15 	stw	r3,1136(sp)
    5de0:	b0fff60e 	bge	r22,r3,5dbc <___vfprintf_internal_r+0xe5c>
    5de4:	8809883a 	mov	r4,r17
    5de8:	b80b883a 	mov	r5,r23
    5dec:	d9811b04 	addi	r6,sp,1132
    5df0:	0004f2c0 	call	4f2c <__sprint_r>
    5df4:	103ded1e 	bne	r2,zero,55ac <___vfprintf_internal_r+0x64c>
    5df8:	da011d17 	ldw	r8,1140(sp)
    5dfc:	d8c11c17 	ldw	r3,1136(sp)
    5e00:	da400404 	addi	r9,sp,16
    5e04:	003fee06 	br	5dc0 <___vfprintf_internal_r+0xe60>
    5e08:	d8812e17 	ldw	r2,1208(sp)
    5e0c:	d9012817 	ldw	r4,1184(sp)
    5e10:	112fc83a 	sub	r23,r2,r4
    5e14:	05ff000e 	bge	zero,r23,5a18 <___vfprintf_internal_r+0xab8>
    5e18:	07000404 	movi	fp,16
    5e1c:	05000134 	movhi	r20,4
    5e20:	a501bc84 	addi	r20,r20,1778
    5e24:	e5c01d0e 	bge	fp,r23,5e9c <___vfprintf_internal_r+0xf3c>
    5e28:	dc812a15 	stw	r18,1192(sp)
    5e2c:	058001c4 	movi	r22,7
    5e30:	a025883a 	mov	r18,r20
    5e34:	8029883a 	mov	r20,r16
    5e38:	dc012917 	ldw	r16,1188(sp)
    5e3c:	00000306 	br	5e4c <___vfprintf_internal_r+0xeec>
    5e40:	bdfffc04 	addi	r23,r23,-16
    5e44:	4a400204 	addi	r9,r9,8
    5e48:	e5c0110e 	bge	fp,r23,5e90 <___vfprintf_internal_r+0xf30>
    5e4c:	4c800015 	stw	r18,0(r9)
    5e50:	4f000115 	stw	fp,4(r9)
    5e54:	42000404 	addi	r8,r8,16
    5e58:	18c00044 	addi	r3,r3,1
    5e5c:	da011d15 	stw	r8,1140(sp)
    5e60:	d8c11c15 	stw	r3,1136(sp)
    5e64:	b0fff60e 	bge	r22,r3,5e40 <___vfprintf_internal_r+0xee0>
    5e68:	8809883a 	mov	r4,r17
    5e6c:	800b883a 	mov	r5,r16
    5e70:	d9811b04 	addi	r6,sp,1132
    5e74:	0004f2c0 	call	4f2c <__sprint_r>
    5e78:	103dcc1e 	bne	r2,zero,55ac <___vfprintf_internal_r+0x64c>
    5e7c:	bdfffc04 	addi	r23,r23,-16
    5e80:	da011d17 	ldw	r8,1140(sp)
    5e84:	d8c11c17 	ldw	r3,1136(sp)
    5e88:	da400404 	addi	r9,sp,16
    5e8c:	e5ffef16 	blt	fp,r23,5e4c <___vfprintf_internal_r+0xeec>
    5e90:	a021883a 	mov	r16,r20
    5e94:	9029883a 	mov	r20,r18
    5e98:	dc812a17 	ldw	r18,1192(sp)
    5e9c:	4d000015 	stw	r20,0(r9)
    5ea0:	4dc00115 	stw	r23,4(r9)
    5ea4:	45d1883a 	add	r8,r8,r23
    5ea8:	18c00044 	addi	r3,r3,1
    5eac:	da011d15 	stw	r8,1140(sp)
    5eb0:	d8c11c15 	stw	r3,1136(sp)
    5eb4:	008001c4 	movi	r2,7
    5eb8:	10c11716 	blt	r2,r3,6318 <___vfprintf_internal_r+0x13b8>
    5ebc:	4a400204 	addi	r9,r9,8
    5ec0:	003ed506 	br	5a18 <___vfprintf_internal_r+0xab8>
    5ec4:	d9412917 	ldw	r5,1188(sp)
    5ec8:	8809883a 	mov	r4,r17
    5ecc:	d9811b04 	addi	r6,sp,1132
    5ed0:	0004f2c0 	call	4f2c <__sprint_r>
    5ed4:	103f4226 	beq	r2,zero,5be0 <___vfprintf_internal_r+0xc80>
    5ed8:	003db406 	br	55ac <___vfprintf_internal_r+0x64c>
    5edc:	d9013217 	ldw	r4,1224(sp)
    5ee0:	00800044 	movi	r2,1
    5ee4:	4cc00015 	stw	r19,0(r9)
    5ee8:	1100e10e 	bge	r2,r4,6270 <___vfprintf_internal_r+0x1310>
    5eec:	00800044 	movi	r2,1
    5ef0:	48800115 	stw	r2,4(r9)
    5ef4:	4091883a 	add	r8,r8,r2
    5ef8:	1887883a 	add	r3,r3,r2
    5efc:	da011d15 	stw	r8,1140(sp)
    5f00:	d8c11c15 	stw	r3,1136(sp)
    5f04:	008001c4 	movi	r2,7
    5f08:	10c0ed16 	blt	r2,r3,62c0 <___vfprintf_internal_r+0x1360>
    5f0c:	4a400204 	addi	r9,r9,8
    5f10:	d8813717 	ldw	r2,1244(sp)
    5f14:	48800015 	stw	r2,0(r9)
    5f18:	00800044 	movi	r2,1
    5f1c:	48800115 	stw	r2,4(r9)
    5f20:	4091883a 	add	r8,r8,r2
    5f24:	1887883a 	add	r3,r3,r2
    5f28:	da011d15 	stw	r8,1140(sp)
    5f2c:	d8c11c15 	stw	r3,1136(sp)
    5f30:	008001c4 	movi	r2,7
    5f34:	10c0eb16 	blt	r2,r3,62e4 <___vfprintf_internal_r+0x1384>
    5f38:	4c800204 	addi	r18,r9,8
    5f3c:	d9013317 	ldw	r4,1228(sp)
    5f40:	d9413417 	ldw	r5,1232(sp)
    5f44:	000d883a 	mov	r6,zero
    5f48:	000f883a 	mov	r7,zero
    5f4c:	d8c13b15 	stw	r3,1260(sp)
    5f50:	da013a15 	stw	r8,1256(sp)
    5f54:	000d7d40 	call	d7d4 <__nedf2>
    5f58:	d8c13b17 	ldw	r3,1260(sp)
    5f5c:	da013a17 	ldw	r8,1256(sp)
    5f60:	1000a626 	beq	r2,zero,61fc <___vfprintf_internal_r+0x129c>
    5f64:	d9013217 	ldw	r4,1224(sp)
    5f68:	9cc00044 	addi	r19,r19,1
    5f6c:	94c00015 	stw	r19,0(r18)
    5f70:	20bfffc4 	addi	r2,r4,-1
    5f74:	90800115 	stw	r2,4(r18)
    5f78:	4091883a 	add	r8,r8,r2
    5f7c:	18c00044 	addi	r3,r3,1
    5f80:	da011d15 	stw	r8,1140(sp)
    5f84:	d8c11c15 	stw	r3,1136(sp)
    5f88:	008001c4 	movi	r2,7
    5f8c:	10c0c316 	blt	r2,r3,629c <___vfprintf_internal_r+0x133c>
    5f90:	94800204 	addi	r18,r18,8
    5f94:	d9013517 	ldw	r4,1236(sp)
    5f98:	d8811fc4 	addi	r2,sp,1151
    5f9c:	90800015 	stw	r2,0(r18)
    5fa0:	91000115 	stw	r4,4(r18)
    5fa4:	4111883a 	add	r8,r8,r4
    5fa8:	18c00044 	addi	r3,r3,1
    5fac:	da011d15 	stw	r8,1140(sp)
    5fb0:	d8c11c15 	stw	r3,1136(sp)
    5fb4:	008001c4 	movi	r2,7
    5fb8:	10ff2316 	blt	r2,r3,5c48 <___vfprintf_internal_r+0xce8>
    5fbc:	92400204 	addi	r9,r18,8
    5fc0:	003ecf06 	br	5b00 <___vfprintf_internal_r+0xba0>
    5fc4:	d9412917 	ldw	r5,1188(sp)
    5fc8:	8809883a 	mov	r4,r17
    5fcc:	d9811b04 	addi	r6,sp,1132
    5fd0:	0004f2c0 	call	4f2c <__sprint_r>
    5fd4:	103d751e 	bne	r2,zero,55ac <___vfprintf_internal_r+0x64c>
    5fd8:	da011d17 	ldw	r8,1140(sp)
    5fdc:	d8c11c17 	ldw	r3,1136(sp)
    5fe0:	da400404 	addi	r9,sp,16
    5fe4:	003eba06 	br	5ad0 <___vfprintf_internal_r+0xb70>
    5fe8:	d9412917 	ldw	r5,1188(sp)
    5fec:	8809883a 	mov	r4,r17
    5ff0:	d9811b04 	addi	r6,sp,1132
    5ff4:	0004f2c0 	call	4f2c <__sprint_r>
    5ff8:	103d6c1e 	bne	r2,zero,55ac <___vfprintf_internal_r+0x64c>
    5ffc:	da011d17 	ldw	r8,1140(sp)
    6000:	d8c11c17 	ldw	r3,1136(sp)
    6004:	da400404 	addi	r9,sp,16
    6008:	003e7306 	br	59d8 <___vfprintf_internal_r+0xa78>
    600c:	d9412917 	ldw	r5,1188(sp)
    6010:	8809883a 	mov	r4,r17
    6014:	d9811b04 	addi	r6,sp,1132
    6018:	0004f2c0 	call	4f2c <__sprint_r>
    601c:	103d631e 	bne	r2,zero,55ac <___vfprintf_internal_r+0x64c>
    6020:	da011d17 	ldw	r8,1140(sp)
    6024:	d8c11c17 	ldw	r3,1136(sp)
    6028:	da400404 	addi	r9,sp,16
    602c:	003e7706 	br	5a0c <___vfprintf_internal_r+0xaac>
    6030:	d8012b15 	stw	zero,1196(sp)
    6034:	dcc10e04 	addi	r19,sp,1080
    6038:	003cae06 	br	52f4 <___vfprintf_internal_r+0x394>
    603c:	d9413617 	ldw	r5,1240(sp)
    6040:	d8810dc4 	addi	r2,sp,1079
    6044:	b8c003cc 	andi	r3,r23,15
    6048:	b008973a 	slli	r4,r22,28
    604c:	28c7883a 	add	r3,r5,r3
    6050:	b82ed13a 	srli	r23,r23,4
    6054:	18c00003 	ldbu	r3,0(r3)
    6058:	b02cd13a 	srli	r22,r22,4
    605c:	25eeb03a 	or	r23,r4,r23
    6060:	10c00005 	stb	r3,0(r2)
    6064:	bd86b03a 	or	r3,r23,r22
    6068:	1027883a 	mov	r19,r2
    606c:	10bfffc4 	addi	r2,r2,-1
    6070:	183ff41e 	bne	r3,zero,6044 <___vfprintf_internal_r+0x10e4>
    6074:	003f1706 	br	5cd4 <___vfprintf_internal_r+0xd74>
    6078:	b0025826 	beq	r22,zero,69dc <___vfprintf_internal_r+0x1a7c>
    607c:	b807883a 	mov	r3,r23
    6080:	d8810dc4 	addi	r2,sp,1079
    6084:	882f883a 	mov	r23,r17
    6088:	04c00244 	movi	r19,9
    608c:	8023883a 	mov	r17,r16
    6090:	da412815 	stw	r9,1184(sp)
    6094:	1821883a 	mov	r16,r3
    6098:	8009883a 	mov	r4,r16
    609c:	b00b883a 	mov	r5,r22
    60a0:	01800284 	movi	r6,10
    60a4:	000f883a 	mov	r7,zero
    60a8:	1029883a 	mov	r20,r2
    60ac:	000c94c0 	call	c94c <__umoddi3>
    60b0:	10800c04 	addi	r2,r2,48
    60b4:	8009883a 	mov	r4,r16
    60b8:	b00b883a 	mov	r5,r22
    60bc:	a0800005 	stb	r2,0(r20)
    60c0:	01800284 	movi	r6,10
    60c4:	000f883a 	mov	r7,zero
    60c8:	000c3840 	call	c384 <__udivdi3>
    60cc:	1021883a 	mov	r16,r2
    60d0:	182d883a 	mov	r22,r3
    60d4:	a0bfffc4 	addi	r2,r20,-1
    60d8:	183fef1e 	bne	r3,zero,6098 <___vfprintf_internal_r+0x1138>
    60dc:	9c3fee36 	bltu	r19,r16,6098 <___vfprintf_internal_r+0x1138>
    60e0:	da412817 	ldw	r9,1184(sp)
    60e4:	8005883a 	mov	r2,r16
    60e8:	8821883a 	mov	r16,r17
    60ec:	b823883a 	mov	r17,r23
    60f0:	102f883a 	mov	r23,r2
    60f4:	d8812717 	ldw	r2,1180(sp)
    60f8:	a4ffffc4 	addi	r19,r20,-1
    60fc:	bdc00c04 	addi	r23,r23,48
    6100:	14c5c83a 	sub	r2,r2,r19
    6104:	a5ffffc5 	stb	r23,-1(r20)
    6108:	d8812b15 	stw	r2,1196(sp)
    610c:	003c7906 	br	52f4 <___vfprintf_internal_r+0x394>
    6110:	00c00044 	movi	r3,1
    6114:	bd84b03a 	or	r2,r23,r22
    6118:	003c6806 	br	52bc <___vfprintf_internal_r+0x35c>
    611c:	dc812417 	ldw	r18,1168(sp)
    6120:	0480ee0e 	bge	zero,r18,64dc <___vfprintf_internal_r+0x157c>
    6124:	d9013217 	ldw	r4,1224(sp)
    6128:	4cc00015 	stw	r19,0(r9)
    612c:	9100c616 	blt	r18,r4,6448 <___vfprintf_internal_r+0x14e8>
    6130:	49000115 	stw	r4,4(r9)
    6134:	4111883a 	add	r8,r8,r4
    6138:	18c00044 	addi	r3,r3,1
    613c:	da011d15 	stw	r8,1140(sp)
    6140:	d8c11c15 	stw	r3,1136(sp)
    6144:	008001c4 	movi	r2,7
    6148:	10c20916 	blt	r2,r3,6970 <___vfprintf_internal_r+0x1a10>
    614c:	4a400204 	addi	r9,r9,8
    6150:	d8813217 	ldw	r2,1224(sp)
    6154:	90a5c83a 	sub	r18,r18,r2
    6158:	04beae0e 	bge	zero,r18,5c14 <___vfprintf_internal_r+0xcb4>
    615c:	04c00404 	movi	r19,16
    6160:	d8c11c17 	ldw	r3,1136(sp)
    6164:	05000134 	movhi	r20,4
    6168:	a501bc84 	addi	r20,r20,1778
    616c:	9c81be0e 	bge	r19,r18,6868 <___vfprintf_internal_r+0x1908>
    6170:	058001c4 	movi	r22,7
    6174:	ddc12917 	ldw	r23,1188(sp)
    6178:	00000306 	br	6188 <___vfprintf_internal_r+0x1228>
    617c:	4a400204 	addi	r9,r9,8
    6180:	94bffc04 	addi	r18,r18,-16
    6184:	9c81b80e 	bge	r19,r18,6868 <___vfprintf_internal_r+0x1908>
    6188:	4d000015 	stw	r20,0(r9)
    618c:	4cc00115 	stw	r19,4(r9)
    6190:	42000404 	addi	r8,r8,16
    6194:	18c00044 	addi	r3,r3,1
    6198:	da011d15 	stw	r8,1140(sp)
    619c:	d8c11c15 	stw	r3,1136(sp)
    61a0:	b0fff60e 	bge	r22,r3,617c <___vfprintf_internal_r+0x121c>
    61a4:	8809883a 	mov	r4,r17
    61a8:	b80b883a 	mov	r5,r23
    61ac:	d9811b04 	addi	r6,sp,1132
    61b0:	0004f2c0 	call	4f2c <__sprint_r>
    61b4:	103cfd1e 	bne	r2,zero,55ac <___vfprintf_internal_r+0x64c>
    61b8:	da011d17 	ldw	r8,1140(sp)
    61bc:	d8c11c17 	ldw	r3,1136(sp)
    61c0:	da400404 	addi	r9,sp,16
    61c4:	003fee06 	br	6180 <___vfprintf_internal_r+0x1220>
    61c8:	d9412917 	ldw	r5,1188(sp)
    61cc:	8809883a 	mov	r4,r17
    61d0:	d9811b04 	addi	r6,sp,1132
    61d4:	0004f2c0 	call	4f2c <__sprint_r>
    61d8:	103cf41e 	bne	r2,zero,55ac <___vfprintf_internal_r+0x64c>
    61dc:	da011d17 	ldw	r8,1140(sp)
    61e0:	d8c11c17 	ldw	r3,1136(sp)
    61e4:	da400404 	addi	r9,sp,16
    61e8:	003dee06 	br	59a4 <___vfprintf_internal_r+0xa44>
    61ec:	00c00084 	movi	r3,2
    61f0:	bd84b03a 	or	r2,r23,r22
    61f4:	d8012585 	stb	zero,1174(sp)
    61f8:	003c3006 	br	52bc <___vfprintf_internal_r+0x35c>
    61fc:	d8813217 	ldw	r2,1224(sp)
    6200:	14ffffc4 	addi	r19,r2,-1
    6204:	04ff630e 	bge	zero,r19,5f94 <___vfprintf_internal_r+0x1034>
    6208:	05800404 	movi	r22,16
    620c:	05000134 	movhi	r20,4
    6210:	a501bc84 	addi	r20,r20,1778
    6214:	b4c03c0e 	bge	r22,r19,6308 <___vfprintf_internal_r+0x13a8>
    6218:	05c001c4 	movi	r23,7
    621c:	df012917 	ldw	fp,1188(sp)
    6220:	00000306 	br	6230 <___vfprintf_internal_r+0x12d0>
    6224:	94800204 	addi	r18,r18,8
    6228:	9cfffc04 	addi	r19,r19,-16
    622c:	b4c0360e 	bge	r22,r19,6308 <___vfprintf_internal_r+0x13a8>
    6230:	95000015 	stw	r20,0(r18)
    6234:	95800115 	stw	r22,4(r18)
    6238:	42000404 	addi	r8,r8,16
    623c:	18c00044 	addi	r3,r3,1
    6240:	da011d15 	stw	r8,1140(sp)
    6244:	d8c11c15 	stw	r3,1136(sp)
    6248:	b8fff60e 	bge	r23,r3,6224 <___vfprintf_internal_r+0x12c4>
    624c:	8809883a 	mov	r4,r17
    6250:	e00b883a 	mov	r5,fp
    6254:	d9811b04 	addi	r6,sp,1132
    6258:	0004f2c0 	call	4f2c <__sprint_r>
    625c:	103cd31e 	bne	r2,zero,55ac <___vfprintf_internal_r+0x64c>
    6260:	da011d17 	ldw	r8,1140(sp)
    6264:	d8c11c17 	ldw	r3,1136(sp)
    6268:	dc800404 	addi	r18,sp,16
    626c:	003fee06 	br	6228 <___vfprintf_internal_r+0x12c8>
    6270:	8088703a 	and	r4,r16,r2
    6274:	203f1d1e 	bne	r4,zero,5eec <___vfprintf_internal_r+0xf8c>
    6278:	48800115 	stw	r2,4(r9)
    627c:	42000044 	addi	r8,r8,1
    6280:	18c00044 	addi	r3,r3,1
    6284:	da011d15 	stw	r8,1140(sp)
    6288:	d8c11c15 	stw	r3,1136(sp)
    628c:	008001c4 	movi	r2,7
    6290:	10c00216 	blt	r2,r3,629c <___vfprintf_internal_r+0x133c>
    6294:	4c800204 	addi	r18,r9,8
    6298:	003f3e06 	br	5f94 <___vfprintf_internal_r+0x1034>
    629c:	d9412917 	ldw	r5,1188(sp)
    62a0:	8809883a 	mov	r4,r17
    62a4:	d9811b04 	addi	r6,sp,1132
    62a8:	0004f2c0 	call	4f2c <__sprint_r>
    62ac:	103cbf1e 	bne	r2,zero,55ac <___vfprintf_internal_r+0x64c>
    62b0:	dc800404 	addi	r18,sp,16
    62b4:	da011d17 	ldw	r8,1140(sp)
    62b8:	d8c11c17 	ldw	r3,1136(sp)
    62bc:	003f3506 	br	5f94 <___vfprintf_internal_r+0x1034>
    62c0:	d9412917 	ldw	r5,1188(sp)
    62c4:	8809883a 	mov	r4,r17
    62c8:	d9811b04 	addi	r6,sp,1132
    62cc:	0004f2c0 	call	4f2c <__sprint_r>
    62d0:	103cb61e 	bne	r2,zero,55ac <___vfprintf_internal_r+0x64c>
    62d4:	da011d17 	ldw	r8,1140(sp)
    62d8:	d8c11c17 	ldw	r3,1136(sp)
    62dc:	da400404 	addi	r9,sp,16
    62e0:	003f0b06 	br	5f10 <___vfprintf_internal_r+0xfb0>
    62e4:	d9412917 	ldw	r5,1188(sp)
    62e8:	8809883a 	mov	r4,r17
    62ec:	d9811b04 	addi	r6,sp,1132
    62f0:	0004f2c0 	call	4f2c <__sprint_r>
    62f4:	103cad1e 	bne	r2,zero,55ac <___vfprintf_internal_r+0x64c>
    62f8:	da011d17 	ldw	r8,1140(sp)
    62fc:	d8c11c17 	ldw	r3,1136(sp)
    6300:	dc800404 	addi	r18,sp,16
    6304:	003f0d06 	br	5f3c <___vfprintf_internal_r+0xfdc>
    6308:	95000015 	stw	r20,0(r18)
    630c:	94c00115 	stw	r19,4(r18)
    6310:	44d1883a 	add	r8,r8,r19
    6314:	003f1906 	br	5f7c <___vfprintf_internal_r+0x101c>
    6318:	d9412917 	ldw	r5,1188(sp)
    631c:	8809883a 	mov	r4,r17
    6320:	d9811b04 	addi	r6,sp,1132
    6324:	0004f2c0 	call	4f2c <__sprint_r>
    6328:	103ca01e 	bne	r2,zero,55ac <___vfprintf_internal_r+0x64c>
    632c:	da011d17 	ldw	r8,1140(sp)
    6330:	d8c11c17 	ldw	r3,1136(sp)
    6334:	da400404 	addi	r9,sp,16
    6338:	003db706 	br	5a18 <___vfprintf_internal_r+0xab8>
    633c:	4d000015 	stw	r20,0(r9)
    6340:	4c800115 	stw	r18,4(r9)
    6344:	4491883a 	add	r8,r8,r18
    6348:	003de706 	br	5ae8 <___vfprintf_internal_r+0xb88>
    634c:	8080100c 	andi	r2,r16,64
    6350:	10010226 	beq	r2,zero,675c <___vfprintf_internal_r+0x17fc>
    6354:	d8812d17 	ldw	r2,1204(sp)
    6358:	002d883a 	mov	r22,zero
    635c:	00c00044 	movi	r3,1
    6360:	15c0000b 	ldhu	r23,0(r2)
    6364:	10800104 	addi	r2,r2,4
    6368:	d8812d15 	stw	r2,1204(sp)
    636c:	d8012585 	stb	zero,1174(sp)
    6370:	b805883a 	mov	r2,r23
    6374:	003bd106 	br	52bc <___vfprintf_internal_r+0x35c>
    6378:	d9012d17 	ldw	r4,1204(sp)
    637c:	25800017 	ldw	r22,0(r4)
    6380:	25000117 	ldw	r20,4(r4)
    6384:	21000204 	addi	r4,r4,8
    6388:	d9012d15 	stw	r4,1204(sp)
    638c:	dd813315 	stw	r22,1228(sp)
    6390:	dd013415 	stw	r20,1232(sp)
    6394:	003d2b06 	br	5844 <___vfprintf_internal_r+0x8e4>
    6398:	8080100c 	andi	r2,r16,64
    639c:	1000fe26 	beq	r2,zero,6798 <___vfprintf_internal_r+0x1838>
    63a0:	d9012d17 	ldw	r4,1204(sp)
    63a4:	002d883a 	mov	r22,zero
    63a8:	0007883a 	mov	r3,zero
    63ac:	25c0000b 	ldhu	r23,0(r4)
    63b0:	21000104 	addi	r4,r4,4
    63b4:	d9012d15 	stw	r4,1204(sp)
    63b8:	b805883a 	mov	r2,r23
    63bc:	d8012585 	stb	zero,1174(sp)
    63c0:	003bbe06 	br	52bc <___vfprintf_internal_r+0x35c>
    63c4:	8080100c 	andi	r2,r16,64
    63c8:	1000ed26 	beq	r2,zero,6780 <___vfprintf_internal_r+0x1820>
    63cc:	d9012d17 	ldw	r4,1204(sp)
    63d0:	002d883a 	mov	r22,zero
    63d4:	25c0000b 	ldhu	r23,0(r4)
    63d8:	21000104 	addi	r4,r4,4
    63dc:	d9012d15 	stw	r4,1204(sp)
    63e0:	003cd206 	br	572c <___vfprintf_internal_r+0x7cc>
    63e4:	00c00084 	movi	r3,2
    63e8:	d8012585 	stb	zero,1174(sp)
    63ec:	003bb306 	br	52bc <___vfprintf_internal_r+0x35c>
    63f0:	8080040c 	andi	r2,r16,16
    63f4:	1000f11e 	bne	r2,zero,67bc <___vfprintf_internal_r+0x185c>
    63f8:	8400100c 	andi	r16,r16,64
    63fc:	80015526 	beq	r16,zero,6954 <___vfprintf_internal_r+0x19f4>
    6400:	da012d17 	ldw	r8,1204(sp)
    6404:	d8c12c17 	ldw	r3,1200(sp)
    6408:	40800017 	ldw	r2,0(r8)
    640c:	42000104 	addi	r8,r8,4
    6410:	da012d15 	stw	r8,1204(sp)
    6414:	10c0000d 	sth	r3,0(r2)
    6418:	003b0706 	br	5038 <___vfprintf_internal_r+0xd8>
    641c:	8080100c 	andi	r2,r16,64
    6420:	1000c726 	beq	r2,zero,6740 <___vfprintf_internal_r+0x17e0>
    6424:	da012d17 	ldw	r8,1204(sp)
    6428:	45c0000f 	ldh	r23,0(r8)
    642c:	42000104 	addi	r8,r8,4
    6430:	da012d15 	stw	r8,1204(sp)
    6434:	b82dd7fa 	srai	r22,r23,31
    6438:	b005883a 	mov	r2,r22
    643c:	003c1006 	br	5480 <___vfprintf_internal_r+0x520>
    6440:	ac800007 	ldb	r18,0(r21)
    6444:	003b2406 	br	50d8 <___vfprintf_internal_r+0x178>
    6448:	4c800115 	stw	r18,4(r9)
    644c:	9211883a 	add	r8,r18,r8
    6450:	18c00044 	addi	r3,r3,1
    6454:	da011d15 	stw	r8,1140(sp)
    6458:	d8c11c15 	stw	r3,1136(sp)
    645c:	008001c4 	movi	r2,7
    6460:	10c15416 	blt	r2,r3,69b4 <___vfprintf_internal_r+0x1a54>
    6464:	4a400204 	addi	r9,r9,8
    6468:	d8813717 	ldw	r2,1244(sp)
    646c:	9ca7883a 	add	r19,r19,r18
    6470:	48800015 	stw	r2,0(r9)
    6474:	00800044 	movi	r2,1
    6478:	48800115 	stw	r2,4(r9)
    647c:	4091883a 	add	r8,r8,r2
    6480:	1887883a 	add	r3,r3,r2
    6484:	da011d15 	stw	r8,1140(sp)
    6488:	d8c11c15 	stw	r3,1136(sp)
    648c:	008001c4 	movi	r2,7
    6490:	10c14016 	blt	r2,r3,6994 <___vfprintf_internal_r+0x1a34>
    6494:	4a400204 	addi	r9,r9,8
    6498:	d9013217 	ldw	r4,1224(sp)
    649c:	da011d17 	ldw	r8,1140(sp)
    64a0:	d8c11c17 	ldw	r3,1136(sp)
    64a4:	24a5c83a 	sub	r18,r4,r18
    64a8:	4cc00015 	stw	r19,0(r9)
    64ac:	003fa406 	br	6340 <___vfprintf_internal_r+0x13e0>
    64b0:	04c00134 	movhi	r19,4
    64b4:	9cc1a904 	addi	r19,r19,1700
    64b8:	003cf406 	br	588c <___vfprintf_internal_r+0x92c>
    64bc:	d9412917 	ldw	r5,1188(sp)
    64c0:	8809883a 	mov	r4,r17
    64c4:	d9811b04 	addi	r6,sp,1132
    64c8:	0004f2c0 	call	4f2c <__sprint_r>
    64cc:	103c371e 	bne	r2,zero,55ac <___vfprintf_internal_r+0x64c>
    64d0:	da011d17 	ldw	r8,1140(sp)
    64d4:	da400404 	addi	r9,sp,16
    64d8:	003e1c06 	br	5d4c <___vfprintf_internal_r+0xdec>
    64dc:	00800134 	movhi	r2,4
    64e0:	1081b804 	addi	r2,r2,1760
    64e4:	48800015 	stw	r2,0(r9)
    64e8:	00800044 	movi	r2,1
    64ec:	48800115 	stw	r2,4(r9)
    64f0:	4091883a 	add	r8,r8,r2
    64f4:	1887883a 	add	r3,r3,r2
    64f8:	da011d15 	stw	r8,1140(sp)
    64fc:	d8c11c15 	stw	r3,1136(sp)
    6500:	008001c4 	movi	r2,7
    6504:	10c0c316 	blt	r2,r3,6814 <___vfprintf_internal_r+0x18b4>
    6508:	4a400204 	addi	r9,r9,8
    650c:	9000041e 	bne	r18,zero,6520 <___vfprintf_internal_r+0x15c0>
    6510:	d8c13217 	ldw	r3,1224(sp)
    6514:	1800021e 	bne	r3,zero,6520 <___vfprintf_internal_r+0x15c0>
    6518:	8080004c 	andi	r2,r16,1
    651c:	103d7826 	beq	r2,zero,5b00 <___vfprintf_internal_r+0xba0>
    6520:	d8c11c17 	ldw	r3,1136(sp)
    6524:	d9013717 	ldw	r4,1244(sp)
    6528:	00800044 	movi	r2,1
    652c:	48800115 	stw	r2,4(r9)
    6530:	49000015 	stw	r4,0(r9)
    6534:	4091883a 	add	r8,r8,r2
    6538:	1887883a 	add	r3,r3,r2
    653c:	da011d15 	stw	r8,1140(sp)
    6540:	d8c11c15 	stw	r3,1136(sp)
    6544:	008001c4 	movi	r2,7
    6548:	10c12e16 	blt	r2,r3,6a04 <___vfprintf_internal_r+0x1aa4>
    654c:	4a400204 	addi	r9,r9,8
    6550:	04a5c83a 	sub	r18,zero,r18
    6554:	0480de0e 	bge	zero,r18,68d0 <___vfprintf_internal_r+0x1970>
    6558:	05800404 	movi	r22,16
    655c:	05000134 	movhi	r20,4
    6560:	a501bc84 	addi	r20,r20,1778
    6564:	b480e20e 	bge	r22,r18,68f0 <___vfprintf_internal_r+0x1990>
    6568:	05c001c4 	movi	r23,7
    656c:	df012917 	ldw	fp,1188(sp)
    6570:	00000306 	br	6580 <___vfprintf_internal_r+0x1620>
    6574:	4a400204 	addi	r9,r9,8
    6578:	94bffc04 	addi	r18,r18,-16
    657c:	b480dc0e 	bge	r22,r18,68f0 <___vfprintf_internal_r+0x1990>
    6580:	4d000015 	stw	r20,0(r9)
    6584:	4d800115 	stw	r22,4(r9)
    6588:	42000404 	addi	r8,r8,16
    658c:	18c00044 	addi	r3,r3,1
    6590:	da011d15 	stw	r8,1140(sp)
    6594:	d8c11c15 	stw	r3,1136(sp)
    6598:	b8fff60e 	bge	r23,r3,6574 <___vfprintf_internal_r+0x1614>
    659c:	8809883a 	mov	r4,r17
    65a0:	e00b883a 	mov	r5,fp
    65a4:	d9811b04 	addi	r6,sp,1132
    65a8:	0004f2c0 	call	4f2c <__sprint_r>
    65ac:	103bff1e 	bne	r2,zero,55ac <___vfprintf_internal_r+0x64c>
    65b0:	da011d17 	ldw	r8,1140(sp)
    65b4:	d8c11c17 	ldw	r3,1136(sp)
    65b8:	da400404 	addi	r9,sp,16
    65bc:	003fee06 	br	6578 <___vfprintf_internal_r+0x1618>
    65c0:	da413c15 	stw	r9,1264(sp)
    65c4:	000bb380 	call	bb38 <__isnand>
    65c8:	da413c17 	ldw	r9,1264(sp)
    65cc:	1000851e 	bne	r2,zero,67e4 <___vfprintf_internal_r+0x1884>
    65d0:	00bfffc4 	movi	r2,-1
    65d4:	e0817626 	beq	fp,r2,6bb0 <___vfprintf_internal_r+0x1c50>
    65d8:	008019c4 	movi	r2,103
    65dc:	90817126 	beq	r18,r2,6ba4 <___vfprintf_internal_r+0x1c44>
    65e0:	008011c4 	movi	r2,71
    65e4:	90816f26 	beq	r18,r2,6ba4 <___vfprintf_internal_r+0x1c44>
    65e8:	82004014 	ori	r8,r16,256
    65ec:	da012a15 	stw	r8,1192(sp)
    65f0:	a0017116 	blt	r20,zero,6bb8 <___vfprintf_internal_r+0x1c58>
    65f4:	d8012f05 	stb	zero,1212(sp)
    65f8:	00801984 	movi	r2,102
    65fc:	90811226 	beq	r18,r2,6a48 <___vfprintf_internal_r+0x1ae8>
    6600:	00801184 	movi	r2,70
    6604:	90811026 	beq	r18,r2,6a48 <___vfprintf_internal_r+0x1ae8>
    6608:	00801944 	movi	r2,101
    660c:	90819b26 	beq	r18,r2,6c7c <___vfprintf_internal_r+0x1d1c>
    6610:	00801144 	movi	r2,69
    6614:	90819926 	beq	r18,r2,6c7c <___vfprintf_internal_r+0x1d1c>
    6618:	e02f883a 	mov	r23,fp
    661c:	d8812404 	addi	r2,sp,1168
    6620:	d8800115 	stw	r2,4(sp)
    6624:	d8812304 	addi	r2,sp,1164
    6628:	d8800215 	stw	r2,8(sp)
    662c:	d8812204 	addi	r2,sp,1160
    6630:	ddc00015 	stw	r23,0(sp)
    6634:	d8800315 	stw	r2,12(sp)
    6638:	8809883a 	mov	r4,r17
    663c:	b00b883a 	mov	r5,r22
    6640:	a00d883a 	mov	r6,r20
    6644:	01c00084 	movi	r7,2
    6648:	da413c15 	stw	r9,1264(sp)
    664c:	00070f80 	call	70f8 <_dtoa_r>
    6650:	1027883a 	mov	r19,r2
    6654:	008019c4 	movi	r2,103
    6658:	da413c17 	ldw	r9,1264(sp)
    665c:	90818c1e 	bne	r18,r2,6c90 <___vfprintf_internal_r+0x1d30>
    6660:	8080004c 	andi	r2,r16,1
    6664:	10017926 	beq	r2,zero,6c4c <___vfprintf_internal_r+0x1cec>
    6668:	00801184 	movi	r2,70
    666c:	9dc7883a 	add	r3,r19,r23
    6670:	90810626 	beq	r18,r2,6a8c <___vfprintf_internal_r+0x1b2c>
    6674:	b009883a 	mov	r4,r22
    6678:	a00b883a 	mov	r5,r20
    667c:	000d883a 	mov	r6,zero
    6680:	000f883a 	mov	r7,zero
    6684:	d8c13b15 	stw	r3,1260(sp)
    6688:	da413c15 	stw	r9,1264(sp)
    668c:	000d7780 	call	d778 <__eqdf2>
    6690:	d8c13b17 	ldw	r3,1260(sp)
    6694:	da413c17 	ldw	r9,1264(sp)
    6698:	10000726 	beq	r2,zero,66b8 <___vfprintf_internal_r+0x1758>
    669c:	d8812217 	ldw	r2,1160(sp)
    66a0:	10c1962e 	bgeu	r2,r3,6cfc <___vfprintf_internal_r+0x1d9c>
    66a4:	01000c04 	movi	r4,48
    66a8:	11000005 	stb	r4,0(r2)
    66ac:	10800044 	addi	r2,r2,1
    66b0:	d8812215 	stw	r2,1160(sp)
    66b4:	10fffc1e 	bne	r2,r3,66a8 <___vfprintf_internal_r+0x1748>
    66b8:	1cc7c83a 	sub	r3,r3,r19
    66bc:	d8c13215 	stw	r3,1224(sp)
    66c0:	008019c4 	movi	r2,103
    66c4:	90810626 	beq	r18,r2,6ae0 <___vfprintf_internal_r+0x1b80>
    66c8:	008011c4 	movi	r2,71
    66cc:	90810426 	beq	r18,r2,6ae0 <___vfprintf_internal_r+0x1b80>
    66d0:	00801984 	movi	r2,102
    66d4:	90819a1e 	bne	r18,r2,6d40 <___vfprintf_internal_r+0x1de0>
    66d8:	d8812417 	ldw	r2,1168(sp)
    66dc:	d8812b15 	stw	r2,1196(sp)
    66e0:	0081880e 	bge	zero,r2,6d04 <___vfprintf_internal_r+0x1da4>
    66e4:	e000021e 	bne	fp,zero,66f0 <___vfprintf_internal_r+0x1790>
    66e8:	8400004c 	andi	r16,r16,1
    66ec:	80000426 	beq	r16,zero,6700 <___vfprintf_internal_r+0x17a0>
    66f0:	d8812b17 	ldw	r2,1196(sp)
    66f4:	e2000044 	addi	r8,fp,1
    66f8:	1205883a 	add	r2,r2,r8
    66fc:	d8812b15 	stw	r2,1196(sp)
    6700:	d8812815 	stw	r2,1184(sp)
    6704:	10011716 	blt	r2,zero,6b64 <___vfprintf_internal_r+0x1c04>
    6708:	ddc12f07 	ldb	r23,1212(sp)
    670c:	b800ca26 	beq	r23,zero,6a38 <___vfprintf_internal_r+0x1ad8>
    6710:	00800b44 	movi	r2,45
    6714:	d8812585 	stb	r2,1174(sp)
    6718:	dc012a17 	ldw	r16,1192(sp)
    671c:	d8013115 	stw	zero,1220(sp)
    6720:	003afe06 	br	531c <___vfprintf_internal_r+0x3bc>
    6724:	d8812b17 	ldw	r2,1196(sp)
    6728:	d8812815 	stw	r2,1184(sp)
    672c:	10005e16 	blt	r2,zero,68a8 <___vfprintf_internal_r+0x1948>
    6730:	d8812583 	ldbu	r2,1174(sp)
    6734:	ddc12d15 	stw	r23,1204(sp)
    6738:	d8013115 	stw	zero,1220(sp)
    673c:	003af306 	br	530c <___vfprintf_internal_r+0x3ac>
    6740:	d8812d17 	ldw	r2,1204(sp)
    6744:	15c00017 	ldw	r23,0(r2)
    6748:	10800104 	addi	r2,r2,4
    674c:	d8812d15 	stw	r2,1204(sp)
    6750:	b82dd7fa 	srai	r22,r23,31
    6754:	b005883a 	mov	r2,r22
    6758:	003b4906 	br	5480 <___vfprintf_internal_r+0x520>
    675c:	d8c12d17 	ldw	r3,1204(sp)
    6760:	002d883a 	mov	r22,zero
    6764:	1dc00017 	ldw	r23,0(r3)
    6768:	18c00104 	addi	r3,r3,4
    676c:	d8c12d15 	stw	r3,1204(sp)
    6770:	b805883a 	mov	r2,r23
    6774:	00c00044 	movi	r3,1
    6778:	d8012585 	stb	zero,1174(sp)
    677c:	003acf06 	br	52bc <___vfprintf_internal_r+0x35c>
    6780:	da012d17 	ldw	r8,1204(sp)
    6784:	002d883a 	mov	r22,zero
    6788:	45c00017 	ldw	r23,0(r8)
    678c:	42000104 	addi	r8,r8,4
    6790:	da012d15 	stw	r8,1204(sp)
    6794:	003be506 	br	572c <___vfprintf_internal_r+0x7cc>
    6798:	da012d17 	ldw	r8,1204(sp)
    679c:	002d883a 	mov	r22,zero
    67a0:	0007883a 	mov	r3,zero
    67a4:	45c00017 	ldw	r23,0(r8)
    67a8:	42000104 	addi	r8,r8,4
    67ac:	da012d15 	stw	r8,1204(sp)
    67b0:	b805883a 	mov	r2,r23
    67b4:	d8012585 	stb	zero,1174(sp)
    67b8:	003ac006 	br	52bc <___vfprintf_internal_r+0x35c>
    67bc:	d8c12d17 	ldw	r3,1204(sp)
    67c0:	d9012c17 	ldw	r4,1200(sp)
    67c4:	18800017 	ldw	r2,0(r3)
    67c8:	18c00104 	addi	r3,r3,4
    67cc:	d8c12d15 	stw	r3,1204(sp)
    67d0:	11000015 	stw	r4,0(r2)
    67d4:	003a1806 	br	5038 <___vfprintf_internal_r+0xd8>
    67d8:	073fffc4 	movi	fp,-1
    67dc:	202b883a 	mov	r21,r4
    67e0:	003a3e06 	br	50dc <___vfprintf_internal_r+0x17c>
    67e4:	008011c4 	movi	r2,71
    67e8:	14809016 	blt	r2,r18,6a2c <___vfprintf_internal_r+0x1acc>
    67ec:	04c00134 	movhi	r19,4
    67f0:	9cc1aa04 	addi	r19,r19,1704
    67f4:	00c000c4 	movi	r3,3
    67f8:	00bfdfc4 	movi	r2,-129
    67fc:	80a0703a 	and	r16,r16,r2
    6800:	d8c12815 	stw	r3,1184(sp)
    6804:	d8812583 	ldbu	r2,1174(sp)
    6808:	d8c12b15 	stw	r3,1196(sp)
    680c:	d8013115 	stw	zero,1220(sp)
    6810:	003abe06 	br	530c <___vfprintf_internal_r+0x3ac>
    6814:	d9412917 	ldw	r5,1188(sp)
    6818:	8809883a 	mov	r4,r17
    681c:	d9811b04 	addi	r6,sp,1132
    6820:	0004f2c0 	call	4f2c <__sprint_r>
    6824:	103b611e 	bne	r2,zero,55ac <___vfprintf_internal_r+0x64c>
    6828:	dc812417 	ldw	r18,1168(sp)
    682c:	da011d17 	ldw	r8,1140(sp)
    6830:	da400404 	addi	r9,sp,16
    6834:	003f3506 	br	650c <___vfprintf_internal_r+0x15ac>
    6838:	ad400044 	addi	r21,r21,1
    683c:	84000814 	ori	r16,r16,32
    6840:	14800047 	ldb	r18,1(r2)
    6844:	003a2406 	br	50d8 <___vfprintf_internal_r+0x178>
    6848:	d9412917 	ldw	r5,1188(sp)
    684c:	8809883a 	mov	r4,r17
    6850:	d9811b04 	addi	r6,sp,1132
    6854:	0004f2c0 	call	4f2c <__sprint_r>
    6858:	103b541e 	bne	r2,zero,55ac <___vfprintf_internal_r+0x64c>
    685c:	da011d17 	ldw	r8,1140(sp)
    6860:	da400404 	addi	r9,sp,16
    6864:	003d4a06 	br	5d90 <___vfprintf_internal_r+0xe30>
    6868:	4d000015 	stw	r20,0(r9)
    686c:	4c800115 	stw	r18,4(r9)
    6870:	4491883a 	add	r8,r8,r18
    6874:	18c00044 	addi	r3,r3,1
    6878:	da011d15 	stw	r8,1140(sp)
    687c:	d8c11c15 	stw	r3,1136(sp)
    6880:	008001c4 	movi	r2,7
    6884:	10fcdc16 	blt	r2,r3,5bf8 <___vfprintf_internal_r+0xc98>
    6888:	4a400204 	addi	r9,r9,8
    688c:	003ce106 	br	5c14 <___vfprintf_internal_r+0xcb4>
    6890:	da413c15 	stw	r9,1264(sp)
    6894:	0004d9c0 	call	4d9c <strlen>
    6898:	d8812b15 	stw	r2,1196(sp)
    689c:	d8812815 	stw	r2,1184(sp)
    68a0:	da413c17 	ldw	r9,1264(sp)
    68a4:	103fa20e 	bge	r2,zero,6730 <___vfprintf_internal_r+0x17d0>
    68a8:	d8012815 	stw	zero,1184(sp)
    68ac:	003fa006 	br	6730 <___vfprintf_internal_r+0x17d0>
    68b0:	d9412917 	ldw	r5,1188(sp)
    68b4:	8809883a 	mov	r4,r17
    68b8:	d9811b04 	addi	r6,sp,1132
    68bc:	0004f2c0 	call	4f2c <__sprint_r>
    68c0:	103b3a1e 	bne	r2,zero,55ac <___vfprintf_internal_r+0x64c>
    68c4:	da011d17 	ldw	r8,1140(sp)
    68c8:	d8c11c17 	ldw	r3,1136(sp)
    68cc:	da400404 	addi	r9,sp,16
    68d0:	d8813217 	ldw	r2,1224(sp)
    68d4:	4cc00015 	stw	r19,0(r9)
    68d8:	48800115 	stw	r2,4(r9)
    68dc:	4091883a 	add	r8,r8,r2
    68e0:	003c8106 	br	5ae8 <___vfprintf_internal_r+0xb88>
    68e4:	00800b44 	movi	r2,45
    68e8:	d8812585 	stb	r2,1174(sp)
    68ec:	003be306 	br	587c <___vfprintf_internal_r+0x91c>
    68f0:	4d000015 	stw	r20,0(r9)
    68f4:	4c800115 	stw	r18,4(r9)
    68f8:	4491883a 	add	r8,r8,r18
    68fc:	18c00044 	addi	r3,r3,1
    6900:	da011d15 	stw	r8,1140(sp)
    6904:	d8c11c15 	stw	r3,1136(sp)
    6908:	008001c4 	movi	r2,7
    690c:	10ffe816 	blt	r2,r3,68b0 <___vfprintf_internal_r+0x1950>
    6910:	4a400204 	addi	r9,r9,8
    6914:	003fee06 	br	68d0 <___vfprintf_internal_r+0x1970>
    6918:	df012b15 	stw	fp,1196(sp)
    691c:	00800184 	movi	r2,6
    6920:	1700072e 	bgeu	r2,fp,6940 <___vfprintf_internal_r+0x19e0>
    6924:	d8812b15 	stw	r2,1196(sp)
    6928:	d8812815 	stw	r2,1184(sp)
    692c:	ddc12d15 	stw	r23,1204(sp)
    6930:	04c00134 	movhi	r19,4
    6934:	9cc1b604 	addi	r19,r19,1752
    6938:	d8013115 	stw	zero,1220(sp)
    693c:	003a7a06 	br	5328 <___vfprintf_internal_r+0x3c8>
    6940:	d8812b17 	ldw	r2,1196(sp)
    6944:	d8812815 	stw	r2,1184(sp)
    6948:	103ff80e 	bge	r2,zero,692c <___vfprintf_internal_r+0x19cc>
    694c:	d8012815 	stw	zero,1184(sp)
    6950:	003ff606 	br	692c <___vfprintf_internal_r+0x19cc>
    6954:	d9012d17 	ldw	r4,1204(sp)
    6958:	da012c17 	ldw	r8,1200(sp)
    695c:	20800017 	ldw	r2,0(r4)
    6960:	21000104 	addi	r4,r4,4
    6964:	d9012d15 	stw	r4,1204(sp)
    6968:	12000015 	stw	r8,0(r2)
    696c:	0039b206 	br	5038 <___vfprintf_internal_r+0xd8>
    6970:	d9412917 	ldw	r5,1188(sp)
    6974:	8809883a 	mov	r4,r17
    6978:	d9811b04 	addi	r6,sp,1132
    697c:	0004f2c0 	call	4f2c <__sprint_r>
    6980:	103b0a1e 	bne	r2,zero,55ac <___vfprintf_internal_r+0x64c>
    6984:	dc812417 	ldw	r18,1168(sp)
    6988:	da011d17 	ldw	r8,1140(sp)
    698c:	da400404 	addi	r9,sp,16
    6990:	003def06 	br	6150 <___vfprintf_internal_r+0x11f0>
    6994:	d9412917 	ldw	r5,1188(sp)
    6998:	8809883a 	mov	r4,r17
    699c:	d9811b04 	addi	r6,sp,1132
    69a0:	0004f2c0 	call	4f2c <__sprint_r>
    69a4:	103b011e 	bne	r2,zero,55ac <___vfprintf_internal_r+0x64c>
    69a8:	dc812417 	ldw	r18,1168(sp)
    69ac:	da400404 	addi	r9,sp,16
    69b0:	003eb906 	br	6498 <___vfprintf_internal_r+0x1538>
    69b4:	d9412917 	ldw	r5,1188(sp)
    69b8:	8809883a 	mov	r4,r17
    69bc:	d9811b04 	addi	r6,sp,1132
    69c0:	0004f2c0 	call	4f2c <__sprint_r>
    69c4:	103af91e 	bne	r2,zero,55ac <___vfprintf_internal_r+0x64c>
    69c8:	dc812417 	ldw	r18,1168(sp)
    69cc:	da011d17 	ldw	r8,1140(sp)
    69d0:	d8c11c17 	ldw	r3,1136(sp)
    69d4:	da400404 	addi	r9,sp,16
    69d8:	003ea306 	br	6468 <___vfprintf_internal_r+0x1508>
    69dc:	00800244 	movi	r2,9
    69e0:	15fda636 	bltu	r2,r23,607c <___vfprintf_internal_r+0x111c>
    69e4:	dd010e04 	addi	r20,sp,1080
    69e8:	003dc206 	br	60f4 <___vfprintf_internal_r+0x1194>
    69ec:	df012815 	stw	fp,1184(sp)
    69f0:	d8812583 	ldbu	r2,1174(sp)
    69f4:	df012b15 	stw	fp,1196(sp)
    69f8:	ddc12d15 	stw	r23,1204(sp)
    69fc:	d8013115 	stw	zero,1220(sp)
    6a00:	003a4206 	br	530c <___vfprintf_internal_r+0x3ac>
    6a04:	d9412917 	ldw	r5,1188(sp)
    6a08:	8809883a 	mov	r4,r17
    6a0c:	d9811b04 	addi	r6,sp,1132
    6a10:	0004f2c0 	call	4f2c <__sprint_r>
    6a14:	103ae51e 	bne	r2,zero,55ac <___vfprintf_internal_r+0x64c>
    6a18:	dc812417 	ldw	r18,1168(sp)
    6a1c:	da011d17 	ldw	r8,1140(sp)
    6a20:	d8c11c17 	ldw	r3,1136(sp)
    6a24:	da400404 	addi	r9,sp,16
    6a28:	003ec906 	br	6550 <___vfprintf_internal_r+0x15f0>
    6a2c:	04c00134 	movhi	r19,4
    6a30:	9cc1ab04 	addi	r19,r19,1708
    6a34:	003f6f06 	br	67f4 <___vfprintf_internal_r+0x1894>
    6a38:	d8812583 	ldbu	r2,1174(sp)
    6a3c:	dc012a17 	ldw	r16,1192(sp)
    6a40:	d8013115 	stw	zero,1220(sp)
    6a44:	003a3106 	br	530c <___vfprintf_internal_r+0x3ac>
    6a48:	d8812404 	addi	r2,sp,1168
    6a4c:	d8800115 	stw	r2,4(sp)
    6a50:	d8812304 	addi	r2,sp,1164
    6a54:	d8800215 	stw	r2,8(sp)
    6a58:	d8812204 	addi	r2,sp,1160
    6a5c:	df000015 	stw	fp,0(sp)
    6a60:	d8800315 	stw	r2,12(sp)
    6a64:	8809883a 	mov	r4,r17
    6a68:	b00b883a 	mov	r5,r22
    6a6c:	a00d883a 	mov	r6,r20
    6a70:	01c000c4 	movi	r7,3
    6a74:	da413c15 	stw	r9,1264(sp)
    6a78:	00070f80 	call	70f8 <_dtoa_r>
    6a7c:	da413c17 	ldw	r9,1264(sp)
    6a80:	1027883a 	mov	r19,r2
    6a84:	1707883a 	add	r3,r2,fp
    6a88:	e02f883a 	mov	r23,fp
    6a8c:	99000007 	ldb	r4,0(r19)
    6a90:	00800c04 	movi	r2,48
    6a94:	20800326 	beq	r4,r2,6aa4 <___vfprintf_internal_r+0x1b44>
    6a98:	da812417 	ldw	r10,1168(sp)
    6a9c:	1a87883a 	add	r3,r3,r10
    6aa0:	003ef406 	br	6674 <___vfprintf_internal_r+0x1714>
    6aa4:	b009883a 	mov	r4,r22
    6aa8:	a00b883a 	mov	r5,r20
    6aac:	000d883a 	mov	r6,zero
    6ab0:	000f883a 	mov	r7,zero
    6ab4:	d8c13b15 	stw	r3,1260(sp)
    6ab8:	da413c15 	stw	r9,1264(sp)
    6abc:	000d7d40 	call	d7d4 <__nedf2>
    6ac0:	d8c13b17 	ldw	r3,1260(sp)
    6ac4:	da413c17 	ldw	r9,1264(sp)
    6ac8:	103ff326 	beq	r2,zero,6a98 <___vfprintf_internal_r+0x1b38>
    6acc:	00800044 	movi	r2,1
    6ad0:	15d5c83a 	sub	r10,r2,r23
    6ad4:	da812415 	stw	r10,1168(sp)
    6ad8:	1a87883a 	add	r3,r3,r10
    6adc:	003ee506 	br	6674 <___vfprintf_internal_r+0x1714>
    6ae0:	d8812417 	ldw	r2,1168(sp)
    6ae4:	d8812b15 	stw	r2,1196(sp)
    6ae8:	1029883a 	mov	r20,r2
    6aec:	00bfff44 	movi	r2,-3
    6af0:	a0800116 	blt	r20,r2,6af8 <___vfprintf_internal_r+0x1b98>
    6af4:	e5001d0e 	bge	fp,r20,6b6c <___vfprintf_internal_r+0x1c0c>
    6af8:	94bfff84 	addi	r18,r18,-2
    6afc:	a53fffc4 	addi	r20,r20,-1
    6b00:	dd012415 	stw	r20,1168(sp)
    6b04:	dc811fc5 	stb	r18,1151(sp)
    6b08:	a0007816 	blt	r20,zero,6cec <___vfprintf_internal_r+0x1d8c>
    6b0c:	00800ac4 	movi	r2,43
    6b10:	d8812005 	stb	r2,1152(sp)
    6b14:	00800244 	movi	r2,9
    6b18:	15002b16 	blt	r2,r20,6bc8 <___vfprintf_internal_r+0x1c68>
    6b1c:	00800c04 	movi	r2,48
    6b20:	a5000c04 	addi	r20,r20,48
    6b24:	d8812045 	stb	r2,1153(sp)
    6b28:	dd012085 	stb	r20,1154(sp)
    6b2c:	d8c120c4 	addi	r3,sp,1155
    6b30:	d8811fc4 	addi	r2,sp,1151
    6b34:	da013217 	ldw	r8,1224(sp)
    6b38:	1885c83a 	sub	r2,r3,r2
    6b3c:	d8813515 	stw	r2,1236(sp)
    6b40:	4085883a 	add	r2,r8,r2
    6b44:	d8812b15 	stw	r2,1196(sp)
    6b48:	00800044 	movi	r2,1
    6b4c:	1200610e 	bge	r2,r8,6cd4 <___vfprintf_internal_r+0x1d74>
    6b50:	d8812b17 	ldw	r2,1196(sp)
    6b54:	10800044 	addi	r2,r2,1
    6b58:	d8812b15 	stw	r2,1196(sp)
    6b5c:	d8812815 	stw	r2,1184(sp)
    6b60:	103ee90e 	bge	r2,zero,6708 <___vfprintf_internal_r+0x17a8>
    6b64:	d8012815 	stw	zero,1184(sp)
    6b68:	003ee706 	br	6708 <___vfprintf_internal_r+0x17a8>
    6b6c:	d8812b17 	ldw	r2,1196(sp)
    6b70:	da013217 	ldw	r8,1224(sp)
    6b74:	12003716 	blt	r2,r8,6c54 <___vfprintf_internal_r+0x1cf4>
    6b78:	8400004c 	andi	r16,r16,1
    6b7c:	80000326 	beq	r16,zero,6b8c <___vfprintf_internal_r+0x1c2c>
    6b80:	d8812b17 	ldw	r2,1196(sp)
    6b84:	10800044 	addi	r2,r2,1
    6b88:	d8812b15 	stw	r2,1196(sp)
    6b8c:	d8812815 	stw	r2,1184(sp)
    6b90:	10003716 	blt	r2,zero,6c70 <___vfprintf_internal_r+0x1d10>
    6b94:	048019c4 	movi	r18,103
    6b98:	003edb06 	br	6708 <___vfprintf_internal_r+0x17a8>
    6b9c:	d8012815 	stw	zero,1184(sp)
    6ba0:	003b6906 	br	5948 <___vfprintf_internal_r+0x9e8>
    6ba4:	e03e901e 	bne	fp,zero,65e8 <___vfprintf_internal_r+0x1688>
    6ba8:	07000044 	movi	fp,1
    6bac:	003e8e06 	br	65e8 <___vfprintf_internal_r+0x1688>
    6bb0:	07000184 	movi	fp,6
    6bb4:	003e8c06 	br	65e8 <___vfprintf_internal_r+0x1688>
    6bb8:	00c00b44 	movi	r3,45
    6bbc:	a520003c 	xorhi	r20,r20,32768
    6bc0:	d8c12f05 	stb	r3,1212(sp)
    6bc4:	003e8c06 	br	65f8 <___vfprintf_internal_r+0x1698>
    6bc8:	d8c11f84 	addi	r3,sp,1150
    6bcc:	102f883a 	mov	r23,r2
    6bd0:	4839883a 	mov	fp,r9
    6bd4:	a009883a 	mov	r4,r20
    6bd8:	01400284 	movi	r5,10
    6bdc:	182d883a 	mov	r22,r3
    6be0:	000dcdc0 	call	dcdc <__modsi3>
    6be4:	10800c04 	addi	r2,r2,48
    6be8:	a009883a 	mov	r4,r20
    6bec:	b0800005 	stb	r2,0(r22)
    6bf0:	01400284 	movi	r5,10
    6bf4:	000dc8c0 	call	dc8c <__divsi3>
    6bf8:	1029883a 	mov	r20,r2
    6bfc:	b0ffffc4 	addi	r3,r22,-1
    6c00:	b8bff416 	blt	r23,r2,6bd4 <___vfprintf_internal_r+0x1c74>
    6c04:	11400c04 	addi	r5,r2,48
    6c08:	b17fffc5 	stb	r5,-1(r22)
    6c0c:	d8811fc4 	addi	r2,sp,1151
    6c10:	e013883a 	mov	r9,fp
    6c14:	1880482e 	bgeu	r3,r2,6d38 <___vfprintf_internal_r+0x1dd8>
    6c18:	b007883a 	mov	r3,r22
    6c1c:	d9012044 	addi	r4,sp,1153
    6c20:	00000206 	br	6c2c <___vfprintf_internal_r+0x1ccc>
    6c24:	19400003 	ldbu	r5,0(r3)
    6c28:	18c00044 	addi	r3,r3,1
    6c2c:	21400005 	stb	r5,0(r4)
    6c30:	21000044 	addi	r4,r4,1
    6c34:	10fffb1e 	bne	r2,r3,6c24 <___vfprintf_internal_r+0x1cc4>
    6c38:	d8c12004 	addi	r3,sp,1152
    6c3c:	1d87c83a 	sub	r3,r3,r22
    6c40:	d9012044 	addi	r4,sp,1153
    6c44:	20c7883a 	add	r3,r4,r3
    6c48:	003fba06 	br	6b34 <___vfprintf_internal_r+0x1bd4>
    6c4c:	d8c12217 	ldw	r3,1160(sp)
    6c50:	003e9906 	br	66b8 <___vfprintf_internal_r+0x1758>
    6c54:	05000b0e 	bge	zero,r20,6c84 <___vfprintf_internal_r+0x1d24>
    6c58:	05000044 	movi	r20,1
    6c5c:	da013217 	ldw	r8,1224(sp)
    6c60:	a229883a 	add	r20,r20,r8
    6c64:	dd012b15 	stw	r20,1196(sp)
    6c68:	dd012815 	stw	r20,1184(sp)
    6c6c:	a03fc90e 	bge	r20,zero,6b94 <___vfprintf_internal_r+0x1c34>
    6c70:	d8012815 	stw	zero,1184(sp)
    6c74:	048019c4 	movi	r18,103
    6c78:	003ea306 	br	6708 <___vfprintf_internal_r+0x17a8>
    6c7c:	e5c00044 	addi	r23,fp,1
    6c80:	003e6606 	br	661c <___vfprintf_internal_r+0x16bc>
    6c84:	00800084 	movi	r2,2
    6c88:	1529c83a 	sub	r20,r2,r20
    6c8c:	003ff306 	br	6c5c <___vfprintf_internal_r+0x1cfc>
    6c90:	008011c4 	movi	r2,71
    6c94:	90be7226 	beq	r18,r2,6660 <___vfprintf_internal_r+0x1700>
    6c98:	003e7306 	br	6668 <___vfprintf_internal_r+0x1708>
    6c9c:	d8812d17 	ldw	r2,1204(sp)
    6ca0:	ac800043 	ldbu	r18,1(r21)
    6ca4:	202b883a 	mov	r21,r4
    6ca8:	17000017 	ldw	fp,0(r2)
    6cac:	10800104 	addi	r2,r2,4
    6cb0:	d8812d15 	stw	r2,1204(sp)
    6cb4:	e0001b16 	blt	fp,zero,6d24 <___vfprintf_internal_r+0x1dc4>
    6cb8:	94803fcc 	andi	r18,r18,255
    6cbc:	9480201c 	xori	r18,r18,128
    6cc0:	94bfe004 	addi	r18,r18,-128
    6cc4:	00390406 	br	50d8 <___vfprintf_internal_r+0x178>
    6cc8:	00bfffc4 	movi	r2,-1
    6ccc:	d8812c15 	stw	r2,1200(sp)
    6cd0:	003a2506 	br	5568 <___vfprintf_internal_r+0x608>
    6cd4:	80a0703a 	and	r16,r16,r2
    6cd8:	803f9d1e 	bne	r16,zero,6b50 <___vfprintf_internal_r+0x1bf0>
    6cdc:	d8812b17 	ldw	r2,1196(sp)
    6ce0:	d8812815 	stw	r2,1184(sp)
    6ce4:	103e880e 	bge	r2,zero,6708 <___vfprintf_internal_r+0x17a8>
    6ce8:	003f9e06 	br	6b64 <___vfprintf_internal_r+0x1c04>
    6cec:	00800b44 	movi	r2,45
    6cf0:	0529c83a 	sub	r20,zero,r20
    6cf4:	d8812005 	stb	r2,1152(sp)
    6cf8:	003f8606 	br	6b14 <___vfprintf_internal_r+0x1bb4>
    6cfc:	1007883a 	mov	r3,r2
    6d00:	003e6d06 	br	66b8 <___vfprintf_internal_r+0x1758>
    6d04:	e000021e 	bne	fp,zero,6d10 <___vfprintf_internal_r+0x1db0>
    6d08:	8400004c 	andi	r16,r16,1
    6d0c:	80000e26 	beq	r16,zero,6d48 <___vfprintf_internal_r+0x1de8>
    6d10:	e7000084 	addi	fp,fp,2
    6d14:	df012b15 	stw	fp,1196(sp)
    6d18:	df012815 	stw	fp,1184(sp)
    6d1c:	e03e7a0e 	bge	fp,zero,6708 <___vfprintf_internal_r+0x17a8>
    6d20:	003f9006 	br	6b64 <___vfprintf_internal_r+0x1c04>
    6d24:	94803fcc 	andi	r18,r18,255
    6d28:	9480201c 	xori	r18,r18,128
    6d2c:	073fffc4 	movi	fp,-1
    6d30:	94bfe004 	addi	r18,r18,-128
    6d34:	0038e806 	br	50d8 <___vfprintf_internal_r+0x178>
    6d38:	d8c12044 	addi	r3,sp,1153
    6d3c:	003f7d06 	br	6b34 <___vfprintf_internal_r+0x1bd4>
    6d40:	dd012417 	ldw	r20,1168(sp)
    6d44:	003f6d06 	br	6afc <___vfprintf_internal_r+0x1b9c>
    6d48:	00c00044 	movi	r3,1
    6d4c:	d8c12815 	stw	r3,1184(sp)
    6d50:	d8c12b15 	stw	r3,1196(sp)
    6d54:	003e6c06 	br	6708 <___vfprintf_internal_r+0x17a8>

00006d58 <__vfprintf_internal>:
    6d58:	00800134 	movhi	r2,4
    6d5c:	1095bf04 	addi	r2,r2,22268
    6d60:	2007883a 	mov	r3,r4
    6d64:	11000017 	ldw	r4,0(r2)
    6d68:	2805883a 	mov	r2,r5
    6d6c:	300f883a 	mov	r7,r6
    6d70:	180b883a 	mov	r5,r3
    6d74:	100d883a 	mov	r6,r2
    6d78:	0004f601 	jmpi	4f60 <___vfprintf_internal_r>

00006d7c <__swsetup_r>:
    6d7c:	00800134 	movhi	r2,4
    6d80:	1095bf04 	addi	r2,r2,22268
    6d84:	10800017 	ldw	r2,0(r2)
    6d88:	defffd04 	addi	sp,sp,-12
    6d8c:	dc400115 	stw	r17,4(sp)
    6d90:	dc000015 	stw	r16,0(sp)
    6d94:	dfc00215 	stw	ra,8(sp)
    6d98:	2023883a 	mov	r17,r4
    6d9c:	2821883a 	mov	r16,r5
    6da0:	10000226 	beq	r2,zero,6dac <__swsetup_r+0x30>
    6da4:	10c00e17 	ldw	r3,56(r2)
    6da8:	18003d26 	beq	r3,zero,6ea0 <__swsetup_r+0x124>
    6dac:	8080030b 	ldhu	r2,12(r16)
    6db0:	10c0020c 	andi	r3,r2,8
    6db4:	18ffffcc 	andi	r3,r3,65535
    6db8:	18e0001c 	xori	r3,r3,32768
    6dbc:	18e00004 	addi	r3,r3,-32768
    6dc0:	18001226 	beq	r3,zero,6e0c <__swsetup_r+0x90>
    6dc4:	80c00417 	ldw	r3,16(r16)
    6dc8:	18001f26 	beq	r3,zero,6e48 <__swsetup_r+0xcc>
    6dcc:	1100004c 	andi	r4,r2,1
    6dd0:	2000261e 	bne	r4,zero,6e6c <__swsetup_r+0xf0>
    6dd4:	1080008c 	andi	r2,r2,2
    6dd8:	10bfffcc 	andi	r2,r2,65535
    6ddc:	10a0001c 	xori	r2,r2,32768
    6de0:	10a00004 	addi	r2,r2,-32768
    6de4:	1000311e 	bne	r2,zero,6eac <__swsetup_r+0x130>
    6de8:	80800517 	ldw	r2,20(r16)
    6dec:	80800215 	stw	r2,8(r16)
    6df0:	18002326 	beq	r3,zero,6e80 <__swsetup_r+0x104>
    6df4:	0005883a 	mov	r2,zero
    6df8:	dfc00217 	ldw	ra,8(sp)
    6dfc:	dc400117 	ldw	r17,4(sp)
    6e00:	dc000017 	ldw	r16,0(sp)
    6e04:	dec00304 	addi	sp,sp,12
    6e08:	f800283a 	ret
    6e0c:	10c0040c 	andi	r3,r2,16
    6e10:	18ffffcc 	andi	r3,r3,65535
    6e14:	18e0001c 	xori	r3,r3,32768
    6e18:	18e00004 	addi	r3,r3,-32768
    6e1c:	18001e26 	beq	r3,zero,6e98 <__swsetup_r+0x11c>
    6e20:	10c0010c 	andi	r3,r2,4
    6e24:	18ffffcc 	andi	r3,r3,65535
    6e28:	18e0001c 	xori	r3,r3,32768
    6e2c:	18e00004 	addi	r3,r3,-32768
    6e30:	1800211e 	bne	r3,zero,6eb8 <__swsetup_r+0x13c>
    6e34:	80c00417 	ldw	r3,16(r16)
    6e38:	11400214 	ori	r5,r2,8
    6e3c:	8140030d 	sth	r5,12(r16)
    6e40:	2805883a 	mov	r2,r5
    6e44:	183fe11e 	bne	r3,zero,6dcc <__swsetup_r+0x50>
    6e48:	1140a00c 	andi	r5,r2,640
    6e4c:	01008004 	movi	r4,512
    6e50:	293fde26 	beq	r5,r4,6dcc <__swsetup_r+0x50>
    6e54:	8809883a 	mov	r4,r17
    6e58:	800b883a 	mov	r5,r16
    6e5c:	00098640 	call	9864 <__smakebuf_r>
    6e60:	8080030b 	ldhu	r2,12(r16)
    6e64:	80c00417 	ldw	r3,16(r16)
    6e68:	003fd806 	br	6dcc <__swsetup_r+0x50>
    6e6c:	80800517 	ldw	r2,20(r16)
    6e70:	80000215 	stw	zero,8(r16)
    6e74:	0085c83a 	sub	r2,zero,r2
    6e78:	80800615 	stw	r2,24(r16)
    6e7c:	183fdd1e 	bne	r3,zero,6df4 <__swsetup_r+0x78>
    6e80:	8080030b 	ldhu	r2,12(r16)
    6e84:	1080200c 	andi	r2,r2,128
    6e88:	10bfffcc 	andi	r2,r2,65535
    6e8c:	10a0001c 	xori	r2,r2,32768
    6e90:	10a00004 	addi	r2,r2,-32768
    6e94:	103fd826 	beq	r2,zero,6df8 <__swsetup_r+0x7c>
    6e98:	00bfffc4 	movi	r2,-1
    6e9c:	003fd606 	br	6df8 <__swsetup_r+0x7c>
    6ea0:	1009883a 	mov	r4,r2
    6ea4:	00089bc0 	call	89bc <__sinit>
    6ea8:	003fc006 	br	6dac <__swsetup_r+0x30>
    6eac:	0005883a 	mov	r2,zero
    6eb0:	80800215 	stw	r2,8(r16)
    6eb4:	003fce06 	br	6df0 <__swsetup_r+0x74>
    6eb8:	81400c17 	ldw	r5,48(r16)
    6ebc:	28000626 	beq	r5,zero,6ed8 <__swsetup_r+0x15c>
    6ec0:	80c01004 	addi	r3,r16,64
    6ec4:	28c00326 	beq	r5,r3,6ed4 <__swsetup_r+0x158>
    6ec8:	8809883a 	mov	r4,r17
    6ecc:	0008e740 	call	8e74 <_free_r>
    6ed0:	8080030b 	ldhu	r2,12(r16)
    6ed4:	80000c15 	stw	zero,48(r16)
    6ed8:	80c00417 	ldw	r3,16(r16)
    6edc:	013ff6c4 	movi	r4,-37
    6ee0:	2084703a 	and	r2,r4,r2
    6ee4:	80000115 	stw	zero,4(r16)
    6ee8:	80c00015 	stw	r3,0(r16)
    6eec:	003fd206 	br	6e38 <__swsetup_r+0xbc>

00006ef0 <quorem>:
    6ef0:	defff704 	addi	sp,sp,-36
    6ef4:	dc400115 	stw	r17,4(sp)
    6ef8:	20800417 	ldw	r2,16(r4)
    6efc:	2c400417 	ldw	r17,16(r5)
    6f00:	dd800615 	stw	r22,24(sp)
    6f04:	dd400515 	stw	r21,20(sp)
    6f08:	dfc00815 	stw	ra,32(sp)
    6f0c:	ddc00715 	stw	r23,28(sp)
    6f10:	dd000415 	stw	r20,16(sp)
    6f14:	dcc00315 	stw	r19,12(sp)
    6f18:	dc800215 	stw	r18,8(sp)
    6f1c:	dc000015 	stw	r16,0(sp)
    6f20:	202b883a 	mov	r21,r4
    6f24:	282d883a 	mov	r22,r5
    6f28:	14407116 	blt	r2,r17,70f0 <quorem+0x200>
    6f2c:	88800104 	addi	r2,r17,4
    6f30:	1085883a 	add	r2,r2,r2
    6f34:	1085883a 	add	r2,r2,r2
    6f38:	28a7883a 	add	r19,r5,r2
    6f3c:	2085883a 	add	r2,r4,r2
    6f40:	15c00017 	ldw	r23,0(r2)
    6f44:	99400017 	ldw	r5,0(r19)
    6f48:	8c7fffc4 	addi	r17,r17,-1
    6f4c:	b809883a 	mov	r4,r23
    6f50:	29400044 	addi	r5,r5,1
    6f54:	000dd380 	call	dd38 <__udivsi3>
    6f58:	1025883a 	mov	r18,r2
    6f5c:	b4000504 	addi	r16,r22,20
    6f60:	ad000504 	addi	r20,r21,20
    6f64:	10002d26 	beq	r2,zero,701c <quorem+0x12c>
    6f68:	800d883a 	mov	r6,r16
    6f6c:	a007883a 	mov	r3,r20
    6f70:	000f883a 	mov	r7,zero
    6f74:	0005883a 	mov	r2,zero
    6f78:	32c00017 	ldw	r11,0(r6)
    6f7c:	1a400017 	ldw	r9,0(r3)
    6f80:	31800104 	addi	r6,r6,4
    6f84:	5abfffcc 	andi	r10,r11,65535
    6f88:	5495383a 	mul	r10,r10,r18
    6f8c:	5816d43a 	srli	r11,r11,16
    6f90:	4a3fffcc 	andi	r8,r9,65535
    6f94:	3a95883a 	add	r10,r7,r10
    6f98:	500ed43a 	srli	r7,r10,16
    6f9c:	5c97383a 	mul	r11,r11,r18
    6fa0:	4085883a 	add	r2,r8,r2
    6fa4:	52bfffcc 	andi	r10,r10,65535
    6fa8:	1291c83a 	sub	r8,r2,r10
    6fac:	4804d43a 	srli	r2,r9,16
    6fb0:	3acf883a 	add	r7,r7,r11
    6fb4:	4015d43a 	srai	r10,r8,16
    6fb8:	393fffcc 	andi	r4,r7,65535
    6fbc:	1105c83a 	sub	r2,r2,r4
    6fc0:	1285883a 	add	r2,r2,r10
    6fc4:	1880008d 	sth	r2,2(r3)
    6fc8:	1a00000d 	sth	r8,0(r3)
    6fcc:	380ed43a 	srli	r7,r7,16
    6fd0:	1005d43a 	srai	r2,r2,16
    6fd4:	18c00104 	addi	r3,r3,4
    6fd8:	99bfe72e 	bgeu	r19,r6,6f78 <quorem+0x88>
    6fdc:	b8000f1e 	bne	r23,zero,701c <quorem+0x12c>
    6fe0:	88800144 	addi	r2,r17,5
    6fe4:	1085883a 	add	r2,r2,r2
    6fe8:	1085883a 	add	r2,r2,r2
    6fec:	a887883a 	add	r3,r21,r2
    6ff0:	18bfff04 	addi	r2,r3,-4
    6ff4:	a080082e 	bgeu	r20,r2,7018 <quorem+0x128>
    6ff8:	18ffff17 	ldw	r3,-4(r3)
    6ffc:	18000326 	beq	r3,zero,700c <quorem+0x11c>
    7000:	00000506 	br	7018 <quorem+0x128>
    7004:	10c00017 	ldw	r3,0(r2)
    7008:	1800031e 	bne	r3,zero,7018 <quorem+0x128>
    700c:	10bfff04 	addi	r2,r2,-4
    7010:	8c7fffc4 	addi	r17,r17,-1
    7014:	a0bffb36 	bltu	r20,r2,7004 <quorem+0x114>
    7018:	ac400415 	stw	r17,16(r21)
    701c:	a809883a 	mov	r4,r21
    7020:	b00b883a 	mov	r5,r22
    7024:	000ac540 	call	ac54 <__mcmp>
    7028:	10002516 	blt	r2,zero,70c0 <quorem+0x1d0>
    702c:	94800044 	addi	r18,r18,1
    7030:	a007883a 	mov	r3,r20
    7034:	000b883a 	mov	r5,zero
    7038:	1a000017 	ldw	r8,0(r3)
    703c:	81c00017 	ldw	r7,0(r16)
    7040:	84000104 	addi	r16,r16,4
    7044:	41bfffcc 	andi	r6,r8,65535
    7048:	38bfffcc 	andi	r2,r7,65535
    704c:	314b883a 	add	r5,r6,r5
    7050:	288dc83a 	sub	r6,r5,r2
    7054:	380ed43a 	srli	r7,r7,16
    7058:	400ad43a 	srli	r5,r8,16
    705c:	3005d43a 	srai	r2,r6,16
    7060:	1980000d 	sth	r6,0(r3)
    7064:	29cbc83a 	sub	r5,r5,r7
    7068:	288b883a 	add	r5,r5,r2
    706c:	1940008d 	sth	r5,2(r3)
    7070:	280bd43a 	srai	r5,r5,16
    7074:	18c00104 	addi	r3,r3,4
    7078:	9c3fef2e 	bgeu	r19,r16,7038 <quorem+0x148>
    707c:	88800144 	addi	r2,r17,5
    7080:	1085883a 	add	r2,r2,r2
    7084:	1085883a 	add	r2,r2,r2
    7088:	a885883a 	add	r2,r21,r2
    708c:	10c00017 	ldw	r3,0(r2)
    7090:	18000b1e 	bne	r3,zero,70c0 <quorem+0x1d0>
    7094:	10ffff04 	addi	r3,r2,-4
    7098:	a0c0082e 	bgeu	r20,r3,70bc <quorem+0x1cc>
    709c:	10bfff17 	ldw	r2,-4(r2)
    70a0:	10000326 	beq	r2,zero,70b0 <quorem+0x1c0>
    70a4:	00000506 	br	70bc <quorem+0x1cc>
    70a8:	18800017 	ldw	r2,0(r3)
    70ac:	1000031e 	bne	r2,zero,70bc <quorem+0x1cc>
    70b0:	18ffff04 	addi	r3,r3,-4
    70b4:	8c7fffc4 	addi	r17,r17,-1
    70b8:	a0fffb36 	bltu	r20,r3,70a8 <quorem+0x1b8>
    70bc:	ac400415 	stw	r17,16(r21)
    70c0:	9005883a 	mov	r2,r18
    70c4:	dfc00817 	ldw	ra,32(sp)
    70c8:	ddc00717 	ldw	r23,28(sp)
    70cc:	dd800617 	ldw	r22,24(sp)
    70d0:	dd400517 	ldw	r21,20(sp)
    70d4:	dd000417 	ldw	r20,16(sp)
    70d8:	dcc00317 	ldw	r19,12(sp)
    70dc:	dc800217 	ldw	r18,8(sp)
    70e0:	dc400117 	ldw	r17,4(sp)
    70e4:	dc000017 	ldw	r16,0(sp)
    70e8:	dec00904 	addi	sp,sp,36
    70ec:	f800283a 	ret
    70f0:	0005883a 	mov	r2,zero
    70f4:	003ff306 	br	70c4 <quorem+0x1d4>

000070f8 <_dtoa_r>:
    70f8:	20801017 	ldw	r2,64(r4)
    70fc:	deffdf04 	addi	sp,sp,-132
    7100:	dcc01a15 	stw	r19,104(sp)
    7104:	dc801915 	stw	r18,100(sp)
    7108:	dc401815 	stw	r17,96(sp)
    710c:	dc001715 	stw	r16,92(sp)
    7110:	dfc02015 	stw	ra,128(sp)
    7114:	df001f15 	stw	fp,124(sp)
    7118:	ddc01e15 	stw	r23,120(sp)
    711c:	dd801d15 	stw	r22,116(sp)
    7120:	dd401c15 	stw	r21,112(sp)
    7124:	dd001b15 	stw	r20,108(sp)
    7128:	d9400315 	stw	r5,12(sp)
    712c:	d9c00415 	stw	r7,16(sp)
    7130:	2021883a 	mov	r16,r4
    7134:	3025883a 	mov	r18,r6
    7138:	dcc02317 	ldw	r19,140(sp)
    713c:	3023883a 	mov	r17,r6
    7140:	10000826 	beq	r2,zero,7164 <_dtoa_r+0x6c>
    7144:	20c01117 	ldw	r3,68(r4)
    7148:	01800044 	movi	r6,1
    714c:	100b883a 	mov	r5,r2
    7150:	30cc983a 	sll	r6,r6,r3
    7154:	10c00115 	stw	r3,4(r2)
    7158:	11800215 	stw	r6,8(r2)
    715c:	000a4580 	call	a458 <_Bfree>
    7160:	80001015 	stw	zero,64(r16)
    7164:	90002f16 	blt	r18,zero,7224 <_dtoa_r+0x12c>
    7168:	98000015 	stw	zero,0(r19)
    716c:	90dffc2c 	andhi	r3,r18,32752
    7170:	009ffc34 	movhi	r2,32752
    7174:	18801c26 	beq	r3,r2,71e8 <_dtoa_r+0xf0>
    7178:	d9000317 	ldw	r4,12(sp)
    717c:	880b883a 	mov	r5,r17
    7180:	000d883a 	mov	r6,zero
    7184:	000f883a 	mov	r7,zero
    7188:	000d7780 	call	d778 <__eqdf2>
    718c:	10002c1e 	bne	r2,zero,7240 <_dtoa_r+0x148>
    7190:	d9002217 	ldw	r4,136(sp)
    7194:	d9c02417 	ldw	r7,144(sp)
    7198:	00800044 	movi	r2,1
    719c:	20800015 	stw	r2,0(r4)
    71a0:	38019426 	beq	r7,zero,77f4 <_dtoa_r+0x6fc>
    71a4:	00800134 	movhi	r2,4
    71a8:	1081b844 	addi	r2,r2,1761
    71ac:	38800015 	stw	r2,0(r7)
    71b0:	15ffffc4 	addi	r23,r2,-1
    71b4:	b805883a 	mov	r2,r23
    71b8:	dfc02017 	ldw	ra,128(sp)
    71bc:	df001f17 	ldw	fp,124(sp)
    71c0:	ddc01e17 	ldw	r23,120(sp)
    71c4:	dd801d17 	ldw	r22,116(sp)
    71c8:	dd401c17 	ldw	r21,112(sp)
    71cc:	dd001b17 	ldw	r20,108(sp)
    71d0:	dcc01a17 	ldw	r19,104(sp)
    71d4:	dc801917 	ldw	r18,100(sp)
    71d8:	dc401817 	ldw	r17,96(sp)
    71dc:	dc001717 	ldw	r16,92(sp)
    71e0:	dec02104 	addi	sp,sp,132
    71e4:	f800283a 	ret
    71e8:	d8c02217 	ldw	r3,136(sp)
    71ec:	d9000317 	ldw	r4,12(sp)
    71f0:	0089c3c4 	movi	r2,9999
    71f4:	18800015 	stw	r2,0(r3)
    71f8:	20016c26 	beq	r4,zero,77ac <_dtoa_r+0x6b4>
    71fc:	05c00134 	movhi	r23,4
    7200:	bdc1c404 	addi	r23,r23,1808
    7204:	d9c02417 	ldw	r7,144(sp)
    7208:	383fea26 	beq	r7,zero,71b4 <_dtoa_r+0xbc>
    720c:	b88000c7 	ldb	r2,3(r23)
    7210:	10016d1e 	bne	r2,zero,77c8 <_dtoa_r+0x6d0>
    7214:	b88000c4 	addi	r2,r23,3
    7218:	d8c02417 	ldw	r3,144(sp)
    721c:	18800015 	stw	r2,0(r3)
    7220:	003fe406 	br	71b4 <_dtoa_r+0xbc>
    7224:	04600034 	movhi	r17,32768
    7228:	8c7fffc4 	addi	r17,r17,-1
    722c:	9462703a 	and	r17,r18,r17
    7230:	00800044 	movi	r2,1
    7234:	98800015 	stw	r2,0(r19)
    7238:	8825883a 	mov	r18,r17
    723c:	003fcb06 	br	716c <_dtoa_r+0x74>
    7240:	d9400317 	ldw	r5,12(sp)
    7244:	9028d53a 	srli	r20,r18,20
    7248:	d8800204 	addi	r2,sp,8
    724c:	d8800015 	stw	r2,0(sp)
    7250:	8009883a 	mov	r4,r16
    7254:	880d883a 	mov	r6,r17
    7258:	d9c00104 	addi	r7,sp,4
    725c:	000affc0 	call	affc <__d2b>
    7260:	a501ffcc 	andi	r20,r20,2047
    7264:	1039883a 	mov	fp,r2
    7268:	a001591e 	bne	r20,zero,77d0 <_dtoa_r+0x6d8>
    726c:	dd400217 	ldw	r21,8(sp)
    7270:	dd000117 	ldw	r20,4(sp)
    7274:	00befbc4 	movi	r2,-1041
    7278:	ad29883a 	add	r20,r21,r20
    727c:	a082d216 	blt	r20,r2,7dc8 <_dtoa_r+0xcd0>
    7280:	d8c00317 	ldw	r3,12(sp)
    7284:	013f0384 	movi	r4,-1010
    7288:	2509c83a 	sub	r4,r4,r20
    728c:	a0810484 	addi	r2,r20,1042
    7290:	9124983a 	sll	r18,r18,r4
    7294:	1884d83a 	srl	r2,r3,r2
    7298:	9088b03a 	or	r4,r18,r2
    729c:	000dafc0 	call	dafc <__floatunsidf>
    72a0:	1009883a 	mov	r4,r2
    72a4:	017f8434 	movhi	r5,65040
    72a8:	00800044 	movi	r2,1
    72ac:	194b883a 	add	r5,r3,r5
    72b0:	a53fffc4 	addi	r20,r20,-1
    72b4:	d8800f15 	stw	r2,60(sp)
    72b8:	000d883a 	mov	r6,zero
    72bc:	01cffe34 	movhi	r7,16376
    72c0:	000d2800 	call	d280 <__subdf3>
    72c4:	1009883a 	mov	r4,r2
    72c8:	180b883a 	mov	r5,r3
    72cc:	0198dbf4 	movhi	r6,25455
    72d0:	3190d844 	addi	r6,r6,17249
    72d4:	01cff4f4 	movhi	r7,16339
    72d8:	39e1e9c4 	addi	r7,r7,-30809
    72dc:	000d2e00 	call	d2e0 <__muldf3>
    72e0:	180b883a 	mov	r5,r3
    72e4:	01a2d874 	movhi	r6,35681
    72e8:	31b22cc4 	addi	r6,r6,-14157
    72ec:	01cff1f4 	movhi	r7,16327
    72f0:	39e28a04 	addi	r7,r7,-30168
    72f4:	1009883a 	mov	r4,r2
    72f8:	000d22c0 	call	d22c <__adddf3>
    72fc:	a009883a 	mov	r4,r20
    7300:	1027883a 	mov	r19,r2
    7304:	1825883a 	mov	r18,r3
    7308:	000d9540 	call	d954 <__floatsidf>
    730c:	1009883a 	mov	r4,r2
    7310:	180b883a 	mov	r5,r3
    7314:	019427f4 	movhi	r6,20639
    7318:	319e7ec4 	addi	r6,r6,31227
    731c:	01cff4f4 	movhi	r7,16339
    7320:	39d104c4 	addi	r7,r7,17427
    7324:	000d2e00 	call	d2e0 <__muldf3>
    7328:	9809883a 	mov	r4,r19
    732c:	900b883a 	mov	r5,r18
    7330:	100d883a 	mov	r6,r2
    7334:	180f883a 	mov	r7,r3
    7338:	000d22c0 	call	d22c <__adddf3>
    733c:	1009883a 	mov	r4,r2
    7340:	180b883a 	mov	r5,r3
    7344:	1027883a 	mov	r19,r2
    7348:	1825883a 	mov	r18,r3
    734c:	000da280 	call	da28 <__fixdfsi>
    7350:	9809883a 	mov	r4,r19
    7354:	900b883a 	mov	r5,r18
    7358:	000d883a 	mov	r6,zero
    735c:	000f883a 	mov	r7,zero
    7360:	d8800615 	stw	r2,24(sp)
    7364:	000d8f80 	call	d8f8 <__ltdf2>
    7368:	10027e16 	blt	r2,zero,7d64 <_dtoa_r+0xc6c>
    736c:	d8c00617 	ldw	r3,24(sp)
    7370:	00800584 	movi	r2,22
    7374:	10c26c36 	bltu	r2,r3,7d28 <_dtoa_r+0xc30>
    7378:	180490fa 	slli	r2,r3,3
    737c:	00c00134 	movhi	r3,4
    7380:	18c1ea04 	addi	r3,r3,1960
    7384:	d9800317 	ldw	r6,12(sp)
    7388:	1885883a 	add	r2,r3,r2
    738c:	11000017 	ldw	r4,0(r2)
    7390:	11400117 	ldw	r5,4(r2)
    7394:	880f883a 	mov	r7,r17
    7398:	000d8300 	call	d830 <__gtdf2>
    739c:	00828f0e 	bge	zero,r2,7ddc <_dtoa_r+0xce4>
    73a0:	d8800617 	ldw	r2,24(sp)
    73a4:	d8000d15 	stw	zero,52(sp)
    73a8:	10bfffc4 	addi	r2,r2,-1
    73ac:	d8800615 	stw	r2,24(sp)
    73b0:	ad29c83a 	sub	r20,r21,r20
    73b4:	a53fffc4 	addi	r20,r20,-1
    73b8:	a0026616 	blt	r20,zero,7d54 <_dtoa_r+0xc5c>
    73bc:	dd000715 	stw	r20,28(sp)
    73c0:	d8000815 	stw	zero,32(sp)
    73c4:	d8800617 	ldw	r2,24(sp)
    73c8:	10025a16 	blt	r2,zero,7d34 <_dtoa_r+0xc3c>
    73cc:	d8c00717 	ldw	r3,28(sp)
    73d0:	d8800b15 	stw	r2,44(sp)
    73d4:	d8000a15 	stw	zero,40(sp)
    73d8:	1887883a 	add	r3,r3,r2
    73dc:	d8c00715 	stw	r3,28(sp)
    73e0:	d9c00417 	ldw	r7,16(sp)
    73e4:	00800244 	movi	r2,9
    73e8:	11c10536 	bltu	r2,r7,7800 <_dtoa_r+0x708>
    73ec:	00800144 	movi	r2,5
    73f0:	11c4c60e 	bge	r2,r7,870c <_dtoa_r+0x1614>
    73f4:	39ffff04 	addi	r7,r7,-4
    73f8:	d9c00415 	stw	r7,16(sp)
    73fc:	0027883a 	mov	r19,zero
    7400:	d9c00417 	ldw	r7,16(sp)
    7404:	008000c4 	movi	r2,3
    7408:	3883a226 	beq	r7,r2,8294 <_dtoa_r+0x119c>
    740c:	11c2bc16 	blt	r2,r7,7f00 <_dtoa_r+0xe08>
    7410:	00800084 	movi	r2,2
    7414:	3880fb1e 	bne	r7,r2,7804 <_dtoa_r+0x70c>
    7418:	d8000c15 	stw	zero,48(sp)
    741c:	d9002117 	ldw	r4,132(sp)
    7420:	0103ae0e 	bge	zero,r4,82dc <_dtoa_r+0x11e4>
    7424:	2025883a 	mov	r18,r4
    7428:	d9000e15 	stw	r4,56(sp)
    742c:	d9000915 	stw	r4,36(sp)
    7430:	80001115 	stw	zero,68(r16)
    7434:	008005c4 	movi	r2,23
    7438:	1484b22e 	bgeu	r2,r18,8704 <_dtoa_r+0x160c>
    743c:	00c00044 	movi	r3,1
    7440:	00800104 	movi	r2,4
    7444:	1085883a 	add	r2,r2,r2
    7448:	11000504 	addi	r4,r2,20
    744c:	180b883a 	mov	r5,r3
    7450:	18c00044 	addi	r3,r3,1
    7454:	913ffb2e 	bgeu	r18,r4,7444 <_dtoa_r+0x34c>
    7458:	81401115 	stw	r5,68(r16)
    745c:	8009883a 	mov	r4,r16
    7460:	000a3b00 	call	a3b0 <_Balloc>
    7464:	102f883a 	mov	r23,r2
    7468:	80801015 	stw	r2,64(r16)
    746c:	00800384 	movi	r2,14
    7470:	1480f036 	bltu	r2,r18,7834 <_dtoa_r+0x73c>
    7474:	9800ef26 	beq	r19,zero,7834 <_dtoa_r+0x73c>
    7478:	d8800617 	ldw	r2,24(sp)
    747c:	00839c0e 	bge	zero,r2,82f0 <_dtoa_r+0x11f8>
    7480:	d8c00617 	ldw	r3,24(sp)
    7484:	108003cc 	andi	r2,r2,15
    7488:	100490fa 	slli	r2,r2,3
    748c:	182bd13a 	srai	r21,r3,4
    7490:	00c00134 	movhi	r3,4
    7494:	18c1ea04 	addi	r3,r3,1960
    7498:	1885883a 	add	r2,r3,r2
    749c:	a8c0040c 	andi	r3,r21,16
    74a0:	12800017 	ldw	r10,0(r2)
    74a4:	15800117 	ldw	r22,4(r2)
    74a8:	18038726 	beq	r3,zero,82c8 <_dtoa_r+0x11d0>
    74ac:	00800134 	movhi	r2,4
    74b0:	1081e004 	addi	r2,r2,1920
    74b4:	11800817 	ldw	r6,32(r2)
    74b8:	11c00917 	ldw	r7,36(r2)
    74bc:	d9000317 	ldw	r4,12(sp)
    74c0:	880b883a 	mov	r5,r17
    74c4:	da801515 	stw	r10,84(sp)
    74c8:	000d5c40 	call	d5c4 <__divdf3>
    74cc:	da801517 	ldw	r10,84(sp)
    74d0:	d8801015 	stw	r2,64(sp)
    74d4:	1829883a 	mov	r20,r3
    74d8:	ad4003cc 	andi	r21,r21,15
    74dc:	048000c4 	movi	r18,3
    74e0:	a8001126 	beq	r21,zero,7528 <_dtoa_r+0x430>
    74e4:	04c00134 	movhi	r19,4
    74e8:	9cc1e004 	addi	r19,r19,1920
    74ec:	5005883a 	mov	r2,r10
    74f0:	b007883a 	mov	r3,r22
    74f4:	a980004c 	andi	r6,r21,1
    74f8:	1009883a 	mov	r4,r2
    74fc:	a82bd07a 	srai	r21,r21,1
    7500:	180b883a 	mov	r5,r3
    7504:	30000426 	beq	r6,zero,7518 <_dtoa_r+0x420>
    7508:	99800017 	ldw	r6,0(r19)
    750c:	99c00117 	ldw	r7,4(r19)
    7510:	94800044 	addi	r18,r18,1
    7514:	000d2e00 	call	d2e0 <__muldf3>
    7518:	9cc00204 	addi	r19,r19,8
    751c:	a83ff51e 	bne	r21,zero,74f4 <_dtoa_r+0x3fc>
    7520:	1015883a 	mov	r10,r2
    7524:	182d883a 	mov	r22,r3
    7528:	d9001017 	ldw	r4,64(sp)
    752c:	a00b883a 	mov	r5,r20
    7530:	500d883a 	mov	r6,r10
    7534:	b00f883a 	mov	r7,r22
    7538:	000d5c40 	call	d5c4 <__divdf3>
    753c:	1027883a 	mov	r19,r2
    7540:	1829883a 	mov	r20,r3
    7544:	d8c00d17 	ldw	r3,52(sp)
    7548:	18000626 	beq	r3,zero,7564 <_dtoa_r+0x46c>
    754c:	9809883a 	mov	r4,r19
    7550:	a00b883a 	mov	r5,r20
    7554:	000d883a 	mov	r6,zero
    7558:	01cffc34 	movhi	r7,16368
    755c:	000d8f80 	call	d8f8 <__ltdf2>
    7560:	10040e16 	blt	r2,zero,859c <_dtoa_r+0x14a4>
    7564:	9009883a 	mov	r4,r18
    7568:	000d9540 	call	d954 <__floatsidf>
    756c:	1009883a 	mov	r4,r2
    7570:	180b883a 	mov	r5,r3
    7574:	980d883a 	mov	r6,r19
    7578:	a00f883a 	mov	r7,r20
    757c:	000d2e00 	call	d2e0 <__muldf3>
    7580:	1009883a 	mov	r4,r2
    7584:	180b883a 	mov	r5,r3
    7588:	000d883a 	mov	r6,zero
    758c:	01d00734 	movhi	r7,16412
    7590:	000d22c0 	call	d22c <__adddf3>
    7594:	057f3034 	movhi	r21,64704
    7598:	1d6b883a 	add	r21,r3,r21
    759c:	d8c00917 	ldw	r3,36(sp)
    75a0:	1025883a 	mov	r18,r2
    75a4:	18031f26 	beq	r3,zero,8224 <_dtoa_r+0x112c>
    75a8:	d8800617 	ldw	r2,24(sp)
    75ac:	dac00917 	ldw	r11,36(sp)
    75b0:	d8801315 	stw	r2,76(sp)
    75b4:	d8c00c17 	ldw	r3,48(sp)
    75b8:	18039026 	beq	r3,zero,83fc <_dtoa_r+0x1304>
    75bc:	58bfffc4 	addi	r2,r11,-1
    75c0:	100490fa 	slli	r2,r2,3
    75c4:	00c00134 	movhi	r3,4
    75c8:	18c1ea04 	addi	r3,r3,1960
    75cc:	0009883a 	mov	r4,zero
    75d0:	1885883a 	add	r2,r3,r2
    75d4:	11800017 	ldw	r6,0(r2)
    75d8:	11c00117 	ldw	r7,4(r2)
    75dc:	014ff834 	movhi	r5,16352
    75e0:	dac01615 	stw	r11,88(sp)
    75e4:	000d5c40 	call	d5c4 <__divdf3>
    75e8:	900d883a 	mov	r6,r18
    75ec:	a80f883a 	mov	r7,r21
    75f0:	1009883a 	mov	r4,r2
    75f4:	180b883a 	mov	r5,r3
    75f8:	000d2800 	call	d280 <__subdf3>
    75fc:	a00b883a 	mov	r5,r20
    7600:	9809883a 	mov	r4,r19
    7604:	182b883a 	mov	r21,r3
    7608:	d8801015 	stw	r2,64(sp)
    760c:	000da280 	call	da28 <__fixdfsi>
    7610:	1009883a 	mov	r4,r2
    7614:	d8801515 	stw	r2,84(sp)
    7618:	000d9540 	call	d954 <__floatsidf>
    761c:	9809883a 	mov	r4,r19
    7620:	a00b883a 	mov	r5,r20
    7624:	100d883a 	mov	r6,r2
    7628:	180f883a 	mov	r7,r3
    762c:	000d2800 	call	d280 <__subdf3>
    7630:	da401517 	ldw	r9,84(sp)
    7634:	d9001017 	ldw	r4,64(sp)
    7638:	a80b883a 	mov	r5,r21
    763c:	4d000c04 	addi	r20,r9,48
    7640:	bd000005 	stb	r20,0(r23)
    7644:	100d883a 	mov	r6,r2
    7648:	180f883a 	mov	r7,r3
    764c:	bd800044 	addi	r22,r23,1
    7650:	1025883a 	mov	r18,r2
    7654:	1827883a 	mov	r19,r3
    7658:	000d8300 	call	d830 <__gtdf2>
    765c:	00842216 	blt	zero,r2,86e8 <_dtoa_r+0x15f0>
    7660:	0009883a 	mov	r4,zero
    7664:	014ffc34 	movhi	r5,16368
    7668:	900d883a 	mov	r6,r18
    766c:	980f883a 	mov	r7,r19
    7670:	000d2800 	call	d280 <__subdf3>
    7674:	d9001017 	ldw	r4,64(sp)
    7678:	a80b883a 	mov	r5,r21
    767c:	100d883a 	mov	r6,r2
    7680:	180f883a 	mov	r7,r3
    7684:	000d8300 	call	d830 <__gtdf2>
    7688:	dac01617 	ldw	r11,88(sp)
    768c:	00841316 	blt	zero,r2,86dc <_dtoa_r+0x15e4>
    7690:	00800044 	movi	r2,1
    7694:	12c0670e 	bge	r2,r11,7834 <_dtoa_r+0x73c>
    7698:	bad7883a 	add	r11,r23,r11
    769c:	df001115 	stw	fp,68(sp)
    76a0:	dc401215 	stw	r17,72(sp)
    76a4:	5839883a 	mov	fp,r11
    76a8:	dc401017 	ldw	r17,64(sp)
    76ac:	00000806 	br	76d0 <_dtoa_r+0x5d8>
    76b0:	000d2800 	call	d280 <__subdf3>
    76b4:	1009883a 	mov	r4,r2
    76b8:	180b883a 	mov	r5,r3
    76bc:	880d883a 	mov	r6,r17
    76c0:	a80f883a 	mov	r7,r21
    76c4:	000d8f80 	call	d8f8 <__ltdf2>
    76c8:	1003ee16 	blt	r2,zero,8684 <_dtoa_r+0x158c>
    76cc:	b703f126 	beq	r22,fp,8694 <_dtoa_r+0x159c>
    76d0:	8809883a 	mov	r4,r17
    76d4:	a80b883a 	mov	r5,r21
    76d8:	000d883a 	mov	r6,zero
    76dc:	01d00934 	movhi	r7,16420
    76e0:	000d2e00 	call	d2e0 <__muldf3>
    76e4:	000d883a 	mov	r6,zero
    76e8:	01d00934 	movhi	r7,16420
    76ec:	9009883a 	mov	r4,r18
    76f0:	980b883a 	mov	r5,r19
    76f4:	1023883a 	mov	r17,r2
    76f8:	182b883a 	mov	r21,r3
    76fc:	000d2e00 	call	d2e0 <__muldf3>
    7700:	180b883a 	mov	r5,r3
    7704:	1009883a 	mov	r4,r2
    7708:	1825883a 	mov	r18,r3
    770c:	1027883a 	mov	r19,r2
    7710:	000da280 	call	da28 <__fixdfsi>
    7714:	1009883a 	mov	r4,r2
    7718:	1029883a 	mov	r20,r2
    771c:	000d9540 	call	d954 <__floatsidf>
    7720:	9809883a 	mov	r4,r19
    7724:	900b883a 	mov	r5,r18
    7728:	100d883a 	mov	r6,r2
    772c:	180f883a 	mov	r7,r3
    7730:	000d2800 	call	d280 <__subdf3>
    7734:	a5000c04 	addi	r20,r20,48
    7738:	b5000005 	stb	r20,0(r22)
    773c:	1009883a 	mov	r4,r2
    7740:	180b883a 	mov	r5,r3
    7744:	880d883a 	mov	r6,r17
    7748:	a80f883a 	mov	r7,r21
    774c:	1025883a 	mov	r18,r2
    7750:	1827883a 	mov	r19,r3
    7754:	000d8f80 	call	d8f8 <__ltdf2>
    7758:	b5800044 	addi	r22,r22,1
    775c:	0009883a 	mov	r4,zero
    7760:	014ffc34 	movhi	r5,16368
    7764:	900d883a 	mov	r6,r18
    7768:	980f883a 	mov	r7,r19
    776c:	103fd00e 	bge	r2,zero,76b0 <_dtoa_r+0x5b8>
    7770:	d9001317 	ldw	r4,76(sp)
    7774:	df001117 	ldw	fp,68(sp)
    7778:	d9000615 	stw	r4,24(sp)
    777c:	8009883a 	mov	r4,r16
    7780:	e00b883a 	mov	r5,fp
    7784:	000a4580 	call	a458 <_Bfree>
    7788:	d9c00617 	ldw	r7,24(sp)
    778c:	d8c02217 	ldw	r3,136(sp)
    7790:	d9002417 	ldw	r4,144(sp)
    7794:	b0000005 	stb	zero,0(r22)
    7798:	38800044 	addi	r2,r7,1
    779c:	18800015 	stw	r2,0(r3)
    77a0:	203e8426 	beq	r4,zero,71b4 <_dtoa_r+0xbc>
    77a4:	25800015 	stw	r22,0(r4)
    77a8:	003e8206 	br	71b4 <_dtoa_r+0xbc>
    77ac:	00800434 	movhi	r2,16
    77b0:	10bfffc4 	addi	r2,r2,-1
    77b4:	90a4703a 	and	r18,r18,r2
    77b8:	903e901e 	bne	r18,zero,71fc <_dtoa_r+0x104>
    77bc:	05c00134 	movhi	r23,4
    77c0:	bdc1c104 	addi	r23,r23,1796
    77c4:	003e8f06 	br	7204 <_dtoa_r+0x10c>
    77c8:	b8800204 	addi	r2,r23,8
    77cc:	003e9206 	br	7218 <_dtoa_r+0x120>
    77d0:	01400434 	movhi	r5,16
    77d4:	297fffc4 	addi	r5,r5,-1
    77d8:	894a703a 	and	r5,r17,r5
    77dc:	d9000317 	ldw	r4,12(sp)
    77e0:	294ffc34 	orhi	r5,r5,16368
    77e4:	a53f0044 	addi	r20,r20,-1023
    77e8:	dd400217 	ldw	r21,8(sp)
    77ec:	d8000f15 	stw	zero,60(sp)
    77f0:	003eb106 	br	72b8 <_dtoa_r+0x1c0>
    77f4:	05c00134 	movhi	r23,4
    77f8:	bdc1b804 	addi	r23,r23,1760
    77fc:	003e6d06 	br	71b4 <_dtoa_r+0xbc>
    7800:	d8000415 	stw	zero,16(sp)
    7804:	80001115 	stw	zero,68(r16)
    7808:	8009883a 	mov	r4,r16
    780c:	000b883a 	mov	r5,zero
    7810:	000a3b00 	call	a3b0 <_Balloc>
    7814:	01ffffc4 	movi	r7,-1
    7818:	102f883a 	mov	r23,r2
    781c:	80801015 	stw	r2,64(r16)
    7820:	00800044 	movi	r2,1
    7824:	d9c00915 	stw	r7,36(sp)
    7828:	d8002115 	stw	zero,132(sp)
    782c:	d9c00e15 	stw	r7,56(sp)
    7830:	d8800c15 	stw	r2,48(sp)
    7834:	d8800117 	ldw	r2,4(sp)
    7838:	10008b16 	blt	r2,zero,7a68 <_dtoa_r+0x970>
    783c:	d9000617 	ldw	r4,24(sp)
    7840:	00c00384 	movi	r3,14
    7844:	19008816 	blt	r3,r4,7a68 <_dtoa_r+0x970>
    7848:	200490fa 	slli	r2,r4,3
    784c:	d9c02117 	ldw	r7,132(sp)
    7850:	00c00134 	movhi	r3,4
    7854:	18c1ea04 	addi	r3,r3,1960
    7858:	1885883a 	add	r2,r3,r2
    785c:	14800017 	ldw	r18,0(r2)
    7860:	14c00117 	ldw	r19,4(r2)
    7864:	3801c916 	blt	r7,zero,7f8c <_dtoa_r+0xe94>
    7868:	d9000317 	ldw	r4,12(sp)
    786c:	900d883a 	mov	r6,r18
    7870:	980f883a 	mov	r7,r19
    7874:	880b883a 	mov	r5,r17
    7878:	000d5c40 	call	d5c4 <__divdf3>
    787c:	180b883a 	mov	r5,r3
    7880:	1009883a 	mov	r4,r2
    7884:	000da280 	call	da28 <__fixdfsi>
    7888:	1009883a 	mov	r4,r2
    788c:	102b883a 	mov	r21,r2
    7890:	000d9540 	call	d954 <__floatsidf>
    7894:	1009883a 	mov	r4,r2
    7898:	180b883a 	mov	r5,r3
    789c:	900d883a 	mov	r6,r18
    78a0:	980f883a 	mov	r7,r19
    78a4:	000d2e00 	call	d2e0 <__muldf3>
    78a8:	d9000317 	ldw	r4,12(sp)
    78ac:	880b883a 	mov	r5,r17
    78b0:	100d883a 	mov	r6,r2
    78b4:	180f883a 	mov	r7,r3
    78b8:	000d2800 	call	d280 <__subdf3>
    78bc:	d9c00917 	ldw	r7,36(sp)
    78c0:	1009883a 	mov	r4,r2
    78c4:	a8800c04 	addi	r2,r21,48
    78c8:	b8800005 	stb	r2,0(r23)
    78cc:	01800044 	movi	r6,1
    78d0:	180b883a 	mov	r5,r3
    78d4:	2005883a 	mov	r2,r4
    78d8:	bd800044 	addi	r22,r23,1
    78dc:	39803726 	beq	r7,r6,79bc <_dtoa_r+0x8c4>
    78e0:	000d883a 	mov	r6,zero
    78e4:	01d00934 	movhi	r7,16420
    78e8:	000d2e00 	call	d2e0 <__muldf3>
    78ec:	1009883a 	mov	r4,r2
    78f0:	180b883a 	mov	r5,r3
    78f4:	000d883a 	mov	r6,zero
    78f8:	000f883a 	mov	r7,zero
    78fc:	1029883a 	mov	r20,r2
    7900:	1823883a 	mov	r17,r3
    7904:	000d7780 	call	d778 <__eqdf2>
    7908:	103f9c26 	beq	r2,zero,777c <_dtoa_r+0x684>
    790c:	dd400917 	ldw	r21,36(sp)
    7910:	dc000415 	stw	r16,16(sp)
    7914:	00000906 	br	793c <_dtoa_r+0x844>
    7918:	000d2e00 	call	d2e0 <__muldf3>
    791c:	1009883a 	mov	r4,r2
    7920:	180b883a 	mov	r5,r3
    7924:	000d883a 	mov	r6,zero
    7928:	000f883a 	mov	r7,zero
    792c:	1029883a 	mov	r20,r2
    7930:	1823883a 	mov	r17,r3
    7934:	000d7780 	call	d778 <__eqdf2>
    7938:	10022926 	beq	r2,zero,81e0 <_dtoa_r+0x10e8>
    793c:	900d883a 	mov	r6,r18
    7940:	980f883a 	mov	r7,r19
    7944:	a009883a 	mov	r4,r20
    7948:	880b883a 	mov	r5,r17
    794c:	000d5c40 	call	d5c4 <__divdf3>
    7950:	180b883a 	mov	r5,r3
    7954:	1009883a 	mov	r4,r2
    7958:	000da280 	call	da28 <__fixdfsi>
    795c:	1009883a 	mov	r4,r2
    7960:	1021883a 	mov	r16,r2
    7964:	000d9540 	call	d954 <__floatsidf>
    7968:	1009883a 	mov	r4,r2
    796c:	180b883a 	mov	r5,r3
    7970:	900d883a 	mov	r6,r18
    7974:	980f883a 	mov	r7,r19
    7978:	000d2e00 	call	d2e0 <__muldf3>
    797c:	a009883a 	mov	r4,r20
    7980:	880b883a 	mov	r5,r17
    7984:	100d883a 	mov	r6,r2
    7988:	180f883a 	mov	r7,r3
    798c:	000d2800 	call	d280 <__subdf3>
    7990:	82400c04 	addi	r9,r16,48
    7994:	b2400005 	stb	r9,0(r22)
    7998:	b5800044 	addi	r22,r22,1
    799c:	b5d3c83a 	sub	r9,r22,r23
    79a0:	000d883a 	mov	r6,zero
    79a4:	01d00934 	movhi	r7,16420
    79a8:	1009883a 	mov	r4,r2
    79ac:	180b883a 	mov	r5,r3
    79b0:	aa7fd91e 	bne	r21,r9,7918 <_dtoa_r+0x820>
    79b4:	802b883a 	mov	r21,r16
    79b8:	dc000417 	ldw	r16,16(sp)
    79bc:	1009883a 	mov	r4,r2
    79c0:	180b883a 	mov	r5,r3
    79c4:	100d883a 	mov	r6,r2
    79c8:	180f883a 	mov	r7,r3
    79cc:	000d22c0 	call	d22c <__adddf3>
    79d0:	9009883a 	mov	r4,r18
    79d4:	980b883a 	mov	r5,r19
    79d8:	100d883a 	mov	r6,r2
    79dc:	180f883a 	mov	r7,r3
    79e0:	1023883a 	mov	r17,r2
    79e4:	1829883a 	mov	r20,r3
    79e8:	000d8f80 	call	d8f8 <__ltdf2>
    79ec:	10000816 	blt	r2,zero,7a10 <_dtoa_r+0x918>
    79f0:	9009883a 	mov	r4,r18
    79f4:	980b883a 	mov	r5,r19
    79f8:	880d883a 	mov	r6,r17
    79fc:	a00f883a 	mov	r7,r20
    7a00:	000d7780 	call	d778 <__eqdf2>
    7a04:	103f5d1e 	bne	r2,zero,777c <_dtoa_r+0x684>
    7a08:	ad40004c 	andi	r21,r21,1
    7a0c:	a83f5b26 	beq	r21,zero,777c <_dtoa_r+0x684>
    7a10:	b53fffc3 	ldbu	r20,-1(r22)
    7a14:	b0ffff84 	addi	r3,r22,-2
    7a18:	01400e44 	movi	r5,57
    7a1c:	00000306 	br	7a2c <_dtoa_r+0x934>
    7a20:	1d000003 	ldbu	r20,0(r3)
    7a24:	102d883a 	mov	r22,r2
    7a28:	18ffffc4 	addi	r3,r3,-1
    7a2c:	a1003fcc 	andi	r4,r20,255
    7a30:	2100201c 	xori	r4,r4,128
    7a34:	213fe004 	addi	r4,r4,-128
    7a38:	b0bfffc4 	addi	r2,r22,-1
    7a3c:	2142ca1e 	bne	r4,r5,8568 <_dtoa_r+0x1470>
    7a40:	b8bff71e 	bne	r23,r2,7a20 <_dtoa_r+0x928>
    7a44:	d8800617 	ldw	r2,24(sp)
    7a48:	05000c44 	movi	r20,49
    7a4c:	10800044 	addi	r2,r2,1
    7a50:	d8800615 	stw	r2,24(sp)
    7a54:	00800c04 	movi	r2,48
    7a58:	b8800005 	stb	r2,0(r23)
    7a5c:	b805883a 	mov	r2,r23
    7a60:	15000005 	stb	r20,0(r2)
    7a64:	003f4506 	br	777c <_dtoa_r+0x684>
    7a68:	d9c00c17 	ldw	r7,48(sp)
    7a6c:	3800c926 	beq	r7,zero,7d94 <_dtoa_r+0xc9c>
    7a70:	d9c00417 	ldw	r7,16(sp)
    7a74:	00c00044 	movi	r3,1
    7a78:	19c16c0e 	bge	r3,r7,802c <_dtoa_r+0xf34>
    7a7c:	d9000917 	ldw	r4,36(sp)
    7a80:	d9c00a17 	ldw	r7,40(sp)
    7a84:	24ffffc4 	addi	r19,r4,-1
    7a88:	3cc20716 	blt	r7,r19,82a8 <_dtoa_r+0x11b0>
    7a8c:	3ce7c83a 	sub	r19,r7,r19
    7a90:	d9c00917 	ldw	r7,36(sp)
    7a94:	3802ae16 	blt	r7,zero,8550 <_dtoa_r+0x1458>
    7a98:	dc800817 	ldw	r18,32(sp)
    7a9c:	d8800917 	ldw	r2,36(sp)
    7aa0:	d8c00817 	ldw	r3,32(sp)
    7aa4:	d9c00717 	ldw	r7,28(sp)
    7aa8:	8009883a 	mov	r4,r16
    7aac:	1887883a 	add	r3,r3,r2
    7ab0:	388f883a 	add	r7,r7,r2
    7ab4:	01400044 	movi	r5,1
    7ab8:	d8c00815 	stw	r3,32(sp)
    7abc:	d9c00715 	stw	r7,28(sp)
    7ac0:	000a7b00 	call	a7b0 <__i2b>
    7ac4:	102b883a 	mov	r21,r2
    7ac8:	90000a26 	beq	r18,zero,7af4 <_dtoa_r+0x9fc>
    7acc:	d8800717 	ldw	r2,28(sp)
    7ad0:	0080080e 	bge	zero,r2,7af4 <_dtoa_r+0x9fc>
    7ad4:	90812b16 	blt	r18,r2,7f84 <_dtoa_r+0xe8c>
    7ad8:	d8c00817 	ldw	r3,32(sp)
    7adc:	d9000717 	ldw	r4,28(sp)
    7ae0:	90a5c83a 	sub	r18,r18,r2
    7ae4:	1887c83a 	sub	r3,r3,r2
    7ae8:	2089c83a 	sub	r4,r4,r2
    7aec:	d8c00815 	stw	r3,32(sp)
    7af0:	d9000715 	stw	r4,28(sp)
    7af4:	d9c00a17 	ldw	r7,40(sp)
    7af8:	01c0140e 	bge	zero,r7,7b4c <_dtoa_r+0xa54>
    7afc:	d8800c17 	ldw	r2,48(sp)
    7b00:	1001de26 	beq	r2,zero,827c <_dtoa_r+0x1184>
    7b04:	04c00e0e 	bge	zero,r19,7b40 <_dtoa_r+0xa48>
    7b08:	a80b883a 	mov	r5,r21
    7b0c:	8009883a 	mov	r4,r16
    7b10:	980d883a 	mov	r6,r19
    7b14:	000a9cc0 	call	a9cc <__pow5mult>
    7b18:	e00d883a 	mov	r6,fp
    7b1c:	8009883a 	mov	r4,r16
    7b20:	100b883a 	mov	r5,r2
    7b24:	102b883a 	mov	r21,r2
    7b28:	000a7ec0 	call	a7ec <__multiply>
    7b2c:	1029883a 	mov	r20,r2
    7b30:	e00b883a 	mov	r5,fp
    7b34:	8009883a 	mov	r4,r16
    7b38:	000a4580 	call	a458 <_Bfree>
    7b3c:	a039883a 	mov	fp,r20
    7b40:	d8c00a17 	ldw	r3,40(sp)
    7b44:	1ccdc83a 	sub	r6,r3,r19
    7b48:	3001291e 	bne	r6,zero,7ff0 <_dtoa_r+0xef8>
    7b4c:	8009883a 	mov	r4,r16
    7b50:	01400044 	movi	r5,1
    7b54:	000a7b00 	call	a7b0 <__i2b>
    7b58:	d9000b17 	ldw	r4,44(sp)
    7b5c:	1029883a 	mov	r20,r2
    7b60:	0100050e 	bge	zero,r4,7b78 <_dtoa_r+0xa80>
    7b64:	d9800b17 	ldw	r6,44(sp)
    7b68:	8009883a 	mov	r4,r16
    7b6c:	100b883a 	mov	r5,r2
    7b70:	000a9cc0 	call	a9cc <__pow5mult>
    7b74:	1029883a 	mov	r20,r2
    7b78:	d9c00417 	ldw	r7,16(sp)
    7b7c:	00800044 	movi	r2,1
    7b80:	11c0f00e 	bge	r2,r7,7f44 <_dtoa_r+0xe4c>
    7b84:	0023883a 	mov	r17,zero
    7b88:	d8800b17 	ldw	r2,44(sp)
    7b8c:	1001741e 	bne	r2,zero,8160 <_dtoa_r+0x1068>
    7b90:	00800044 	movi	r2,1
    7b94:	d8c00717 	ldw	r3,28(sp)
    7b98:	10c5883a 	add	r2,r2,r3
    7b9c:	108007cc 	andi	r2,r2,31
    7ba0:	10008026 	beq	r2,zero,7da4 <_dtoa_r+0xcac>
    7ba4:	01000804 	movi	r4,32
    7ba8:	2089c83a 	sub	r4,r4,r2
    7bac:	00c00104 	movi	r3,4
    7bb0:	1902d00e 	bge	r3,r4,86f4 <_dtoa_r+0x15fc>
    7bb4:	d9000817 	ldw	r4,32(sp)
    7bb8:	d9c00717 	ldw	r7,28(sp)
    7bbc:	00c00704 	movi	r3,28
    7bc0:	1885c83a 	sub	r2,r3,r2
    7bc4:	2089883a 	add	r4,r4,r2
    7bc8:	388f883a 	add	r7,r7,r2
    7bcc:	d9000815 	stw	r4,32(sp)
    7bd0:	90a5883a 	add	r18,r18,r2
    7bd4:	d9c00715 	stw	r7,28(sp)
    7bd8:	d9c00817 	ldw	r7,32(sp)
    7bdc:	01c0050e 	bge	zero,r7,7bf4 <_dtoa_r+0xafc>
    7be0:	e00b883a 	mov	r5,fp
    7be4:	8009883a 	mov	r4,r16
    7be8:	380d883a 	mov	r6,r7
    7bec:	000aaf80 	call	aaf8 <__lshift>
    7bf0:	1039883a 	mov	fp,r2
    7bf4:	d8800717 	ldw	r2,28(sp)
    7bf8:	0080050e 	bge	zero,r2,7c10 <_dtoa_r+0xb18>
    7bfc:	a00b883a 	mov	r5,r20
    7c00:	8009883a 	mov	r4,r16
    7c04:	100d883a 	mov	r6,r2
    7c08:	000aaf80 	call	aaf8 <__lshift>
    7c0c:	1029883a 	mov	r20,r2
    7c10:	d8c00d17 	ldw	r3,52(sp)
    7c14:	1801401e 	bne	r3,zero,8118 <_dtoa_r+0x1020>
    7c18:	d8800917 	ldw	r2,36(sp)
    7c1c:	00815a0e 	bge	zero,r2,8188 <_dtoa_r+0x1090>
    7c20:	d8c00c17 	ldw	r3,48(sp)
    7c24:	18006f1e 	bne	r3,zero,7de4 <_dtoa_r+0xcec>
    7c28:	b823883a 	mov	r17,r23
    7c2c:	dc800917 	ldw	r18,36(sp)
    7c30:	00000206 	br	7c3c <_dtoa_r+0xb44>
    7c34:	000a4800 	call	a480 <__multadd>
    7c38:	1039883a 	mov	fp,r2
    7c3c:	e009883a 	mov	r4,fp
    7c40:	a00b883a 	mov	r5,r20
    7c44:	0006ef00 	call	6ef0 <quorem>
    7c48:	10800c04 	addi	r2,r2,48
    7c4c:	88800005 	stb	r2,0(r17)
    7c50:	8c400044 	addi	r17,r17,1
    7c54:	8dc7c83a 	sub	r3,r17,r23
    7c58:	8009883a 	mov	r4,r16
    7c5c:	e00b883a 	mov	r5,fp
    7c60:	01800284 	movi	r6,10
    7c64:	000f883a 	mov	r7,zero
    7c68:	1cbff216 	blt	r3,r18,7c34 <_dtoa_r+0xb3c>
    7c6c:	dd800917 	ldw	r22,36(sp)
    7c70:	1007883a 	mov	r3,r2
    7c74:	05823a0e 	bge	zero,r22,8560 <_dtoa_r+0x1468>
    7c78:	bdad883a 	add	r22,r23,r22
    7c7c:	0023883a 	mov	r17,zero
    7c80:	e00b883a 	mov	r5,fp
    7c84:	01800044 	movi	r6,1
    7c88:	8009883a 	mov	r4,r16
    7c8c:	d8c01515 	stw	r3,84(sp)
    7c90:	000aaf80 	call	aaf8 <__lshift>
    7c94:	1009883a 	mov	r4,r2
    7c98:	a00b883a 	mov	r5,r20
    7c9c:	1039883a 	mov	fp,r2
    7ca0:	000ac540 	call	ac54 <__mcmp>
    7ca4:	d8c01517 	ldw	r3,84(sp)
    7ca8:	0080d60e 	bge	zero,r2,8004 <_dtoa_r+0xf0c>
    7cac:	b13fffc3 	ldbu	r4,-1(r22)
    7cb0:	b0ffff84 	addi	r3,r22,-2
    7cb4:	01800e44 	movi	r6,57
    7cb8:	00000306 	br	7cc8 <_dtoa_r+0xbd0>
    7cbc:	19000003 	ldbu	r4,0(r3)
    7cc0:	102d883a 	mov	r22,r2
    7cc4:	18ffffc4 	addi	r3,r3,-1
    7cc8:	21403fcc 	andi	r5,r4,255
    7ccc:	2940201c 	xori	r5,r5,128
    7cd0:	297fe004 	addi	r5,r5,-128
    7cd4:	b0bfffc4 	addi	r2,r22,-1
    7cd8:	2981a71e 	bne	r5,r6,8378 <_dtoa_r+0x1280>
    7cdc:	b8bff71e 	bne	r23,r2,7cbc <_dtoa_r+0xbc4>
    7ce0:	d8800617 	ldw	r2,24(sp)
    7ce4:	10800044 	addi	r2,r2,1
    7ce8:	d8800615 	stw	r2,24(sp)
    7cec:	00800c44 	movi	r2,49
    7cf0:	b8800005 	stb	r2,0(r23)
    7cf4:	8009883a 	mov	r4,r16
    7cf8:	a00b883a 	mov	r5,r20
    7cfc:	000a4580 	call	a458 <_Bfree>
    7d00:	a83e9e26 	beq	r21,zero,777c <_dtoa_r+0x684>
    7d04:	88000426 	beq	r17,zero,7d18 <_dtoa_r+0xc20>
    7d08:	8d400326 	beq	r17,r21,7d18 <_dtoa_r+0xc20>
    7d0c:	8009883a 	mov	r4,r16
    7d10:	880b883a 	mov	r5,r17
    7d14:	000a4580 	call	a458 <_Bfree>
    7d18:	8009883a 	mov	r4,r16
    7d1c:	a80b883a 	mov	r5,r21
    7d20:	000a4580 	call	a458 <_Bfree>
    7d24:	003e9506 	br	777c <_dtoa_r+0x684>
    7d28:	00c00044 	movi	r3,1
    7d2c:	d8c00d15 	stw	r3,52(sp)
    7d30:	003d9f06 	br	73b0 <_dtoa_r+0x2b8>
    7d34:	d9000817 	ldw	r4,32(sp)
    7d38:	d8800617 	ldw	r2,24(sp)
    7d3c:	d8000b15 	stw	zero,44(sp)
    7d40:	2089c83a 	sub	r4,r4,r2
    7d44:	0087c83a 	sub	r3,zero,r2
    7d48:	d9000815 	stw	r4,32(sp)
    7d4c:	d8c00a15 	stw	r3,40(sp)
    7d50:	003da306 	br	73e0 <_dtoa_r+0x2e8>
    7d54:	0529c83a 	sub	r20,zero,r20
    7d58:	dd000815 	stw	r20,32(sp)
    7d5c:	d8000715 	stw	zero,28(sp)
    7d60:	003d9806 	br	73c4 <_dtoa_r+0x2cc>
    7d64:	d9000617 	ldw	r4,24(sp)
    7d68:	000d9540 	call	d954 <__floatsidf>
    7d6c:	1009883a 	mov	r4,r2
    7d70:	180b883a 	mov	r5,r3
    7d74:	980d883a 	mov	r6,r19
    7d78:	900f883a 	mov	r7,r18
    7d7c:	000d7d40 	call	d7d4 <__nedf2>
    7d80:	103d7a26 	beq	r2,zero,736c <_dtoa_r+0x274>
    7d84:	d8800617 	ldw	r2,24(sp)
    7d88:	10bfffc4 	addi	r2,r2,-1
    7d8c:	d8800615 	stw	r2,24(sp)
    7d90:	003d7606 	br	736c <_dtoa_r+0x274>
    7d94:	dcc00a17 	ldw	r19,40(sp)
    7d98:	dc800817 	ldw	r18,32(sp)
    7d9c:	002b883a 	mov	r21,zero
    7da0:	003f4906 	br	7ac8 <_dtoa_r+0x9d0>
    7da4:	00800704 	movi	r2,28
    7da8:	d8c00817 	ldw	r3,32(sp)
    7dac:	d9000717 	ldw	r4,28(sp)
    7db0:	90a5883a 	add	r18,r18,r2
    7db4:	1887883a 	add	r3,r3,r2
    7db8:	2089883a 	add	r4,r4,r2
    7dbc:	d8c00815 	stw	r3,32(sp)
    7dc0:	d9000715 	stw	r4,28(sp)
    7dc4:	003f8406 	br	7bd8 <_dtoa_r+0xae0>
    7dc8:	d9c00317 	ldw	r7,12(sp)
    7dcc:	013efb84 	movi	r4,-1042
    7dd0:	2509c83a 	sub	r4,r4,r20
    7dd4:	3908983a 	sll	r4,r7,r4
    7dd8:	003d3006 	br	729c <_dtoa_r+0x1a4>
    7ddc:	d8000d15 	stw	zero,52(sp)
    7de0:	003d7306 	br	73b0 <_dtoa_r+0x2b8>
    7de4:	0480050e 	bge	zero,r18,7dfc <_dtoa_r+0xd04>
    7de8:	a80b883a 	mov	r5,r21
    7dec:	8009883a 	mov	r4,r16
    7df0:	900d883a 	mov	r6,r18
    7df4:	000aaf80 	call	aaf8 <__lshift>
    7df8:	102b883a 	mov	r21,r2
    7dfc:	8801611e 	bne	r17,zero,8384 <_dtoa_r+0x128c>
    7e00:	a827883a 	mov	r19,r21
    7e04:	d8c00317 	ldw	r3,12(sp)
    7e08:	d9000917 	ldw	r4,36(sp)
    7e0c:	b8bfffc4 	addi	r2,r23,-1
    7e10:	18c0004c 	andi	r3,r3,1
    7e14:	1105883a 	add	r2,r2,r4
    7e18:	b825883a 	mov	r18,r23
    7e1c:	d8800515 	stw	r2,20(sp)
    7e20:	a823883a 	mov	r17,r21
    7e24:	d8c00315 	stw	r3,12(sp)
    7e28:	ddc00715 	stw	r23,28(sp)
    7e2c:	e009883a 	mov	r4,fp
    7e30:	a00b883a 	mov	r5,r20
    7e34:	0006ef00 	call	6ef0 <quorem>
    7e38:	e009883a 	mov	r4,fp
    7e3c:	880b883a 	mov	r5,r17
    7e40:	102d883a 	mov	r22,r2
    7e44:	000ac540 	call	ac54 <__mcmp>
    7e48:	980d883a 	mov	r6,r19
    7e4c:	8009883a 	mov	r4,r16
    7e50:	a00b883a 	mov	r5,r20
    7e54:	102b883a 	mov	r21,r2
    7e58:	000acac0 	call	acac <__mdiff>
    7e5c:	100d883a 	mov	r6,r2
    7e60:	10800317 	ldw	r2,12(r2)
    7e64:	b5c00c04 	addi	r23,r22,48
    7e68:	10008c26 	beq	r2,zero,809c <_dtoa_r+0xfa4>
    7e6c:	8009883a 	mov	r4,r16
    7e70:	300b883a 	mov	r5,r6
    7e74:	000a4580 	call	a458 <_Bfree>
    7e78:	00800044 	movi	r2,1
    7e7c:	a8007116 	blt	r21,zero,8044 <_dtoa_r+0xf4c>
    7e80:	a800041e 	bne	r21,zero,7e94 <_dtoa_r+0xd9c>
    7e84:	d9c00417 	ldw	r7,16(sp)
    7e88:	3800021e 	bne	r7,zero,7e94 <_dtoa_r+0xd9c>
    7e8c:	d8c00317 	ldw	r3,12(sp)
    7e90:	18006c26 	beq	r3,zero,8044 <_dtoa_r+0xf4c>
    7e94:	00814c16 	blt	zero,r2,83c8 <_dtoa_r+0x12d0>
    7e98:	d8c00517 	ldw	r3,20(sp)
    7e9c:	95400044 	addi	r21,r18,1
    7ea0:	95c00005 	stb	r23,0(r18)
    7ea4:	a82d883a 	mov	r22,r21
    7ea8:	90c14d26 	beq	r18,r3,83e0 <_dtoa_r+0x12e8>
    7eac:	e00b883a 	mov	r5,fp
    7eb0:	8009883a 	mov	r4,r16
    7eb4:	01800284 	movi	r6,10
    7eb8:	000f883a 	mov	r7,zero
    7ebc:	000a4800 	call	a480 <__multadd>
    7ec0:	1039883a 	mov	fp,r2
    7ec4:	8cc08b26 	beq	r17,r19,80f4 <_dtoa_r+0xffc>
    7ec8:	880b883a 	mov	r5,r17
    7ecc:	01800284 	movi	r6,10
    7ed0:	000f883a 	mov	r7,zero
    7ed4:	8009883a 	mov	r4,r16
    7ed8:	000a4800 	call	a480 <__multadd>
    7edc:	980b883a 	mov	r5,r19
    7ee0:	8009883a 	mov	r4,r16
    7ee4:	01800284 	movi	r6,10
    7ee8:	000f883a 	mov	r7,zero
    7eec:	1023883a 	mov	r17,r2
    7ef0:	000a4800 	call	a480 <__multadd>
    7ef4:	1027883a 	mov	r19,r2
    7ef8:	a825883a 	mov	r18,r21
    7efc:	003fcb06 	br	7e2c <_dtoa_r+0xd34>
    7f00:	d9c00417 	ldw	r7,16(sp)
    7f04:	00800104 	movi	r2,4
    7f08:	3880e426 	beq	r7,r2,829c <_dtoa_r+0x11a4>
    7f0c:	00800144 	movi	r2,5
    7f10:	38be3c1e 	bne	r7,r2,7804 <_dtoa_r+0x70c>
    7f14:	00c00044 	movi	r3,1
    7f18:	d8c00c15 	stw	r3,48(sp)
    7f1c:	d9c02117 	ldw	r7,132(sp)
    7f20:	d8800617 	ldw	r2,24(sp)
    7f24:	388f883a 	add	r7,r7,r2
    7f28:	3c800044 	addi	r18,r7,1
    7f2c:	d9c00e15 	stw	r7,56(sp)
    7f30:	dc800915 	stw	r18,36(sp)
    7f34:	04bd3e16 	blt	zero,r18,7430 <_dtoa_r+0x338>
    7f38:	80001115 	stw	zero,68(r16)
    7f3c:	000b883a 	mov	r5,zero
    7f40:	003d4606 	br	745c <_dtoa_r+0x364>
    7f44:	d8c00317 	ldw	r3,12(sp)
    7f48:	183f0e1e 	bne	r3,zero,7b84 <_dtoa_r+0xa8c>
    7f4c:	00c00434 	movhi	r3,16
    7f50:	18ffffc4 	addi	r3,r3,-1
    7f54:	88c6703a 	and	r3,r17,r3
    7f58:	183f0a1e 	bne	r3,zero,7b84 <_dtoa_r+0xa8c>
    7f5c:	8c5ffc2c 	andhi	r17,r17,32752
    7f60:	883f0826 	beq	r17,zero,7b84 <_dtoa_r+0xa8c>
    7f64:	d9000817 	ldw	r4,32(sp)
    7f68:	d9c00717 	ldw	r7,28(sp)
    7f6c:	1023883a 	mov	r17,r2
    7f70:	2089883a 	add	r4,r4,r2
    7f74:	388f883a 	add	r7,r7,r2
    7f78:	d9000815 	stw	r4,32(sp)
    7f7c:	d9c00715 	stw	r7,28(sp)
    7f80:	003f0106 	br	7b88 <_dtoa_r+0xa90>
    7f84:	9005883a 	mov	r2,r18
    7f88:	003ed306 	br	7ad8 <_dtoa_r+0x9e0>
    7f8c:	d8800917 	ldw	r2,36(sp)
    7f90:	00be3516 	blt	zero,r2,7868 <_dtoa_r+0x770>
    7f94:	1000b61e 	bne	r2,zero,8270 <_dtoa_r+0x1178>
    7f98:	9009883a 	mov	r4,r18
    7f9c:	980b883a 	mov	r5,r19
    7fa0:	000d883a 	mov	r6,zero
    7fa4:	01d00534 	movhi	r7,16404
    7fa8:	000d2e00 	call	d2e0 <__muldf3>
    7fac:	d9800317 	ldw	r6,12(sp)
    7fb0:	1009883a 	mov	r4,r2
    7fb4:	180b883a 	mov	r5,r3
    7fb8:	880f883a 	mov	r7,r17
    7fbc:	000d8940 	call	d894 <__gedf2>
    7fc0:	0029883a 	mov	r20,zero
    7fc4:	002b883a 	mov	r21,zero
    7fc8:	10007e16 	blt	r2,zero,81c4 <_dtoa_r+0x10cc>
    7fcc:	d8802117 	ldw	r2,132(sp)
    7fd0:	b82d883a 	mov	r22,r23
    7fd4:	0084303a 	nor	r2,zero,r2
    7fd8:	d8800615 	stw	r2,24(sp)
    7fdc:	8009883a 	mov	r4,r16
    7fe0:	a00b883a 	mov	r5,r20
    7fe4:	000a4580 	call	a458 <_Bfree>
    7fe8:	a83f4b1e 	bne	r21,zero,7d18 <_dtoa_r+0xc20>
    7fec:	003de306 	br	777c <_dtoa_r+0x684>
    7ff0:	e00b883a 	mov	r5,fp
    7ff4:	8009883a 	mov	r4,r16
    7ff8:	000a9cc0 	call	a9cc <__pow5mult>
    7ffc:	1039883a 	mov	fp,r2
    8000:	003ed206 	br	7b4c <_dtoa_r+0xa54>
    8004:	1000021e 	bne	r2,zero,8010 <_dtoa_r+0xf18>
    8008:	18c0004c 	andi	r3,r3,1
    800c:	183f271e 	bne	r3,zero,7cac <_dtoa_r+0xbb4>
    8010:	01000c04 	movi	r4,48
    8014:	00000106 	br	801c <_dtoa_r+0xf24>
    8018:	102d883a 	mov	r22,r2
    801c:	b0bfffc4 	addi	r2,r22,-1
    8020:	10c00007 	ldb	r3,0(r2)
    8024:	193ffc26 	beq	r3,r4,8018 <_dtoa_r+0xf20>
    8028:	003f3206 	br	7cf4 <_dtoa_r+0xbfc>
    802c:	d8c00f17 	ldw	r3,60(sp)
    8030:	18015026 	beq	r3,zero,8574 <_dtoa_r+0x147c>
    8034:	10810cc4 	addi	r2,r2,1075
    8038:	dcc00a17 	ldw	r19,40(sp)
    803c:	dc800817 	ldw	r18,32(sp)
    8040:	003e9706 	br	7aa0 <_dtoa_r+0x9a8>
    8044:	b807883a 	mov	r3,r23
    8048:	182b883a 	mov	r21,r3
    804c:	ddc00717 	ldw	r23,28(sp)
    8050:	00800e0e 	bge	zero,r2,808c <_dtoa_r+0xf94>
    8054:	e00b883a 	mov	r5,fp
    8058:	01800044 	movi	r6,1
    805c:	8009883a 	mov	r4,r16
    8060:	d8c01515 	stw	r3,84(sp)
    8064:	000aaf80 	call	aaf8 <__lshift>
    8068:	1009883a 	mov	r4,r2
    806c:	a00b883a 	mov	r5,r20
    8070:	1039883a 	mov	fp,r2
    8074:	000ac540 	call	ac54 <__mcmp>
    8078:	d8c01517 	ldw	r3,84(sp)
    807c:	0081880e 	bge	zero,r2,86a0 <_dtoa_r+0x15a8>
    8080:	00800e44 	movi	r2,57
    8084:	b0c00c44 	addi	r3,r22,49
    8088:	a8816326 	beq	r21,r2,8618 <_dtoa_r+0x1520>
    808c:	90c00005 	stb	r3,0(r18)
    8090:	95800044 	addi	r22,r18,1
    8094:	982b883a 	mov	r21,r19
    8098:	003f1606 	br	7cf4 <_dtoa_r+0xbfc>
    809c:	300b883a 	mov	r5,r6
    80a0:	e009883a 	mov	r4,fp
    80a4:	d9801515 	stw	r6,84(sp)
    80a8:	000ac540 	call	ac54 <__mcmp>
    80ac:	d9801517 	ldw	r6,84(sp)
    80b0:	8009883a 	mov	r4,r16
    80b4:	d8801515 	stw	r2,84(sp)
    80b8:	300b883a 	mov	r5,r6
    80bc:	000a4580 	call	a458 <_Bfree>
    80c0:	d8801517 	ldw	r2,84(sp)
    80c4:	103f6d1e 	bne	r2,zero,7e7c <_dtoa_r+0xd84>
    80c8:	d9c00417 	ldw	r7,16(sp)
    80cc:	383f6b1e 	bne	r7,zero,7e7c <_dtoa_r+0xd84>
    80d0:	d8c00317 	ldw	r3,12(sp)
    80d4:	183f691e 	bne	r3,zero,7e7c <_dtoa_r+0xd84>
    80d8:	b807883a 	mov	r3,r23
    80dc:	00800e44 	movi	r2,57
    80e0:	ddc00717 	ldw	r23,28(sp)
    80e4:	18814c26 	beq	r3,r2,8618 <_dtoa_r+0x1520>
    80e8:	057fe80e 	bge	zero,r21,808c <_dtoa_r+0xf94>
    80ec:	b0c00c44 	addi	r3,r22,49
    80f0:	003fe606 	br	808c <_dtoa_r+0xf94>
    80f4:	880b883a 	mov	r5,r17
    80f8:	8009883a 	mov	r4,r16
    80fc:	01800284 	movi	r6,10
    8100:	000f883a 	mov	r7,zero
    8104:	000a4800 	call	a480 <__multadd>
    8108:	1023883a 	mov	r17,r2
    810c:	1027883a 	mov	r19,r2
    8110:	a825883a 	mov	r18,r21
    8114:	003f4506 	br	7e2c <_dtoa_r+0xd34>
    8118:	e009883a 	mov	r4,fp
    811c:	a00b883a 	mov	r5,r20
    8120:	000ac540 	call	ac54 <__mcmp>
    8124:	103ebc0e 	bge	r2,zero,7c18 <_dtoa_r+0xb20>
    8128:	e00b883a 	mov	r5,fp
    812c:	8009883a 	mov	r4,r16
    8130:	01800284 	movi	r6,10
    8134:	000f883a 	mov	r7,zero
    8138:	000a4800 	call	a480 <__multadd>
    813c:	1039883a 	mov	fp,r2
    8140:	d8800617 	ldw	r2,24(sp)
    8144:	d8c00c17 	ldw	r3,48(sp)
    8148:	10bfffc4 	addi	r2,r2,-1
    814c:	d8800615 	stw	r2,24(sp)
    8150:	1801571e 	bne	r3,zero,86b0 <_dtoa_r+0x15b8>
    8154:	d9c00e17 	ldw	r7,56(sp)
    8158:	d9c00915 	stw	r7,36(sp)
    815c:	003eae06 	br	7c18 <_dtoa_r+0xb20>
    8160:	a0800417 	ldw	r2,16(r20)
    8164:	10800104 	addi	r2,r2,4
    8168:	1085883a 	add	r2,r2,r2
    816c:	1085883a 	add	r2,r2,r2
    8170:	a085883a 	add	r2,r20,r2
    8174:	11000017 	ldw	r4,0(r2)
    8178:	000a6980 	call	a698 <__hi0bits>
    817c:	00c00804 	movi	r3,32
    8180:	1885c83a 	sub	r2,r3,r2
    8184:	003e8306 	br	7b94 <_dtoa_r+0xa9c>
    8188:	d9c00417 	ldw	r7,16(sp)
    818c:	00800084 	movi	r2,2
    8190:	11fea30e 	bge	r2,r7,7c20 <_dtoa_r+0xb28>
    8194:	d8800917 	ldw	r2,36(sp)
    8198:	103f8c1e 	bne	r2,zero,7fcc <_dtoa_r+0xed4>
    819c:	a00b883a 	mov	r5,r20
    81a0:	8009883a 	mov	r4,r16
    81a4:	01800144 	movi	r6,5
    81a8:	000f883a 	mov	r7,zero
    81ac:	000a4800 	call	a480 <__multadd>
    81b0:	e009883a 	mov	r4,fp
    81b4:	100b883a 	mov	r5,r2
    81b8:	1029883a 	mov	r20,r2
    81bc:	000ac540 	call	ac54 <__mcmp>
    81c0:	00bf820e 	bge	zero,r2,7fcc <_dtoa_r+0xed4>
    81c4:	00800c44 	movi	r2,49
    81c8:	b8800005 	stb	r2,0(r23)
    81cc:	d8800617 	ldw	r2,24(sp)
    81d0:	bd800044 	addi	r22,r23,1
    81d4:	10800044 	addi	r2,r2,1
    81d8:	d8800615 	stw	r2,24(sp)
    81dc:	003f7f06 	br	7fdc <_dtoa_r+0xee4>
    81e0:	dc000417 	ldw	r16,16(sp)
    81e4:	003d6506 	br	777c <_dtoa_r+0x684>
    81e8:	9009883a 	mov	r4,r18
    81ec:	000d9540 	call	d954 <__floatsidf>
    81f0:	1009883a 	mov	r4,r2
    81f4:	180b883a 	mov	r5,r3
    81f8:	980d883a 	mov	r6,r19
    81fc:	a00f883a 	mov	r7,r20
    8200:	000d2e00 	call	d2e0 <__muldf3>
    8204:	1009883a 	mov	r4,r2
    8208:	180b883a 	mov	r5,r3
    820c:	000d883a 	mov	r6,zero
    8210:	01d00734 	movhi	r7,16412
    8214:	000d22c0 	call	d22c <__adddf3>
    8218:	057f3034 	movhi	r21,64704
    821c:	1025883a 	mov	r18,r2
    8220:	1d6b883a 	add	r21,r3,r21
    8224:	9809883a 	mov	r4,r19
    8228:	a00b883a 	mov	r5,r20
    822c:	000d883a 	mov	r6,zero
    8230:	01d00534 	movhi	r7,16404
    8234:	000d2800 	call	d280 <__subdf3>
    8238:	1009883a 	mov	r4,r2
    823c:	180b883a 	mov	r5,r3
    8240:	900d883a 	mov	r6,r18
    8244:	a80f883a 	mov	r7,r21
    8248:	1027883a 	mov	r19,r2
    824c:	1829883a 	mov	r20,r3
    8250:	000d8300 	call	d830 <__gtdf2>
    8254:	00806616 	blt	zero,r2,83f0 <_dtoa_r+0x12f8>
    8258:	a9e0003c 	xorhi	r7,r21,32768
    825c:	9809883a 	mov	r4,r19
    8260:	a00b883a 	mov	r5,r20
    8264:	900d883a 	mov	r6,r18
    8268:	000d8f80 	call	d8f8 <__ltdf2>
    826c:	103d710e 	bge	r2,zero,7834 <_dtoa_r+0x73c>
    8270:	0029883a 	mov	r20,zero
    8274:	002b883a 	mov	r21,zero
    8278:	003f5406 	br	7fcc <_dtoa_r+0xed4>
    827c:	d9800a17 	ldw	r6,40(sp)
    8280:	e00b883a 	mov	r5,fp
    8284:	8009883a 	mov	r4,r16
    8288:	000a9cc0 	call	a9cc <__pow5mult>
    828c:	1039883a 	mov	fp,r2
    8290:	003e2e06 	br	7b4c <_dtoa_r+0xa54>
    8294:	d8000c15 	stw	zero,48(sp)
    8298:	003f2006 	br	7f1c <_dtoa_r+0xe24>
    829c:	00800044 	movi	r2,1
    82a0:	d8800c15 	stw	r2,48(sp)
    82a4:	003c5d06 	br	741c <_dtoa_r+0x324>
    82a8:	d8c00a17 	ldw	r3,40(sp)
    82ac:	d9000b17 	ldw	r4,44(sp)
    82b0:	dcc00a15 	stw	r19,40(sp)
    82b4:	98c5c83a 	sub	r2,r19,r3
    82b8:	2089883a 	add	r4,r4,r2
    82bc:	d9000b15 	stw	r4,44(sp)
    82c0:	0027883a 	mov	r19,zero
    82c4:	003df206 	br	7a90 <_dtoa_r+0x998>
    82c8:	d9000317 	ldw	r4,12(sp)
    82cc:	8829883a 	mov	r20,r17
    82d0:	04800084 	movi	r18,2
    82d4:	d9001015 	stw	r4,64(sp)
    82d8:	003c8106 	br	74e0 <_dtoa_r+0x3e8>
    82dc:	04800044 	movi	r18,1
    82e0:	dc800e15 	stw	r18,56(sp)
    82e4:	dc800915 	stw	r18,36(sp)
    82e8:	dc802115 	stw	r18,132(sp)
    82ec:	003f1206 	br	7f38 <_dtoa_r+0xe40>
    82f0:	d8800617 	ldw	r2,24(sp)
    82f4:	00abc83a 	sub	r21,zero,r2
    82f8:	a800a426 	beq	r21,zero,858c <_dtoa_r+0x1494>
    82fc:	a88003cc 	andi	r2,r21,15
    8300:	100490fa 	slli	r2,r2,3
    8304:	00c00134 	movhi	r3,4
    8308:	18c1ea04 	addi	r3,r3,1960
    830c:	d9000317 	ldw	r4,12(sp)
    8310:	1885883a 	add	r2,r3,r2
    8314:	11800017 	ldw	r6,0(r2)
    8318:	11c00117 	ldw	r7,4(r2)
    831c:	a82bd13a 	srai	r21,r21,4
    8320:	880b883a 	mov	r5,r17
    8324:	000d2e00 	call	d2e0 <__muldf3>
    8328:	1027883a 	mov	r19,r2
    832c:	1829883a 	mov	r20,r3
    8330:	a800e826 	beq	r21,zero,86d4 <_dtoa_r+0x15dc>
    8334:	05800134 	movhi	r22,4
    8338:	b581e004 	addi	r22,r22,1920
    833c:	04800084 	movi	r18,2
    8340:	a980004c 	andi	r6,r21,1
    8344:	1009883a 	mov	r4,r2
    8348:	a82bd07a 	srai	r21,r21,1
    834c:	180b883a 	mov	r5,r3
    8350:	30000426 	beq	r6,zero,8364 <_dtoa_r+0x126c>
    8354:	b1800017 	ldw	r6,0(r22)
    8358:	b1c00117 	ldw	r7,4(r22)
    835c:	94800044 	addi	r18,r18,1
    8360:	000d2e00 	call	d2e0 <__muldf3>
    8364:	b5800204 	addi	r22,r22,8
    8368:	a83ff51e 	bne	r21,zero,8340 <_dtoa_r+0x1248>
    836c:	1027883a 	mov	r19,r2
    8370:	1829883a 	mov	r20,r3
    8374:	003c7306 	br	7544 <_dtoa_r+0x44c>
    8378:	21000044 	addi	r4,r4,1
    837c:	11000005 	stb	r4,0(r2)
    8380:	003e5c06 	br	7cf4 <_dtoa_r+0xbfc>
    8384:	a9400117 	ldw	r5,4(r21)
    8388:	8009883a 	mov	r4,r16
    838c:	000a3b00 	call	a3b0 <_Balloc>
    8390:	a9800417 	ldw	r6,16(r21)
    8394:	11000304 	addi	r4,r2,12
    8398:	a9400304 	addi	r5,r21,12
    839c:	31800084 	addi	r6,r6,2
    83a0:	318d883a 	add	r6,r6,r6
    83a4:	318d883a 	add	r6,r6,r6
    83a8:	1023883a 	mov	r17,r2
    83ac:	00041f00 	call	41f0 <memcpy>
    83b0:	8009883a 	mov	r4,r16
    83b4:	880b883a 	mov	r5,r17
    83b8:	01800044 	movi	r6,1
    83bc:	000aaf80 	call	aaf8 <__lshift>
    83c0:	1027883a 	mov	r19,r2
    83c4:	003e8f06 	br	7e04 <_dtoa_r+0xd0c>
    83c8:	b807883a 	mov	r3,r23
    83cc:	00800e44 	movi	r2,57
    83d0:	ddc00717 	ldw	r23,28(sp)
    83d4:	18809026 	beq	r3,r2,8618 <_dtoa_r+0x1520>
    83d8:	18c00044 	addi	r3,r3,1
    83dc:	003f2b06 	br	808c <_dtoa_r+0xf94>
    83e0:	b807883a 	mov	r3,r23
    83e4:	982b883a 	mov	r21,r19
    83e8:	ddc00717 	ldw	r23,28(sp)
    83ec:	003e2406 	br	7c80 <_dtoa_r+0xb88>
    83f0:	0029883a 	mov	r20,zero
    83f4:	002b883a 	mov	r21,zero
    83f8:	003f7206 	br	81c4 <_dtoa_r+0x10cc>
    83fc:	593fffc4 	addi	r4,r11,-1
    8400:	200490fa 	slli	r2,r4,3
    8404:	00c00134 	movhi	r3,4
    8408:	18c1ea04 	addi	r3,r3,1960
    840c:	d9001015 	stw	r4,64(sp)
    8410:	1885883a 	add	r2,r3,r2
    8414:	11000017 	ldw	r4,0(r2)
    8418:	11400117 	ldw	r5,4(r2)
    841c:	900d883a 	mov	r6,r18
    8420:	a80f883a 	mov	r7,r21
    8424:	dac01615 	stw	r11,88(sp)
    8428:	000d2e00 	call	d2e0 <__muldf3>
    842c:	a00b883a 	mov	r5,r20
    8430:	9809883a 	mov	r4,r19
    8434:	d8c01215 	stw	r3,72(sp)
    8438:	d8801115 	stw	r2,68(sp)
    843c:	000da280 	call	da28 <__fixdfsi>
    8440:	1009883a 	mov	r4,r2
    8444:	1025883a 	mov	r18,r2
    8448:	000d9540 	call	d954 <__floatsidf>
    844c:	9809883a 	mov	r4,r19
    8450:	a00b883a 	mov	r5,r20
    8454:	100d883a 	mov	r6,r2
    8458:	180f883a 	mov	r7,r3
    845c:	94800c04 	addi	r18,r18,48
    8460:	000d2800 	call	d280 <__subdf3>
    8464:	bc800005 	stb	r18,0(r23)
    8468:	dac01617 	ldw	r11,88(sp)
    846c:	102b883a 	mov	r21,r2
    8470:	00800044 	movi	r2,1
    8474:	bd800044 	addi	r22,r23,1
    8478:	1815883a 	mov	r10,r3
    847c:	58802226 	beq	r11,r2,8508 <_dtoa_r+0x1410>
    8480:	bad7883a 	add	r11,r23,r11
    8484:	dc001415 	stw	r16,80(sp)
    8488:	a805883a 	mov	r2,r21
    848c:	b027883a 	mov	r19,r22
    8490:	5821883a 	mov	r16,r11
    8494:	882b883a 	mov	r21,r17
    8498:	000d883a 	mov	r6,zero
    849c:	01d00934 	movhi	r7,16420
    84a0:	1009883a 	mov	r4,r2
    84a4:	180b883a 	mov	r5,r3
    84a8:	000d2e00 	call	d2e0 <__muldf3>
    84ac:	180b883a 	mov	r5,r3
    84b0:	1009883a 	mov	r4,r2
    84b4:	1829883a 	mov	r20,r3
    84b8:	1023883a 	mov	r17,r2
    84bc:	000da280 	call	da28 <__fixdfsi>
    84c0:	1009883a 	mov	r4,r2
    84c4:	1025883a 	mov	r18,r2
    84c8:	000d9540 	call	d954 <__floatsidf>
    84cc:	8809883a 	mov	r4,r17
    84d0:	a00b883a 	mov	r5,r20
    84d4:	100d883a 	mov	r6,r2
    84d8:	180f883a 	mov	r7,r3
    84dc:	94800c04 	addi	r18,r18,48
    84e0:	000d2800 	call	d280 <__subdf3>
    84e4:	9cc00044 	addi	r19,r19,1
    84e8:	9cbfffc5 	stb	r18,-1(r19)
    84ec:	9c3fea1e 	bne	r19,r16,8498 <_dtoa_r+0x13a0>
    84f0:	1815883a 	mov	r10,r3
    84f4:	d8c01017 	ldw	r3,64(sp)
    84f8:	dc001417 	ldw	r16,80(sp)
    84fc:	a823883a 	mov	r17,r21
    8500:	b0ed883a 	add	r22,r22,r3
    8504:	102b883a 	mov	r21,r2
    8508:	d9001117 	ldw	r4,68(sp)
    850c:	d9401217 	ldw	r5,72(sp)
    8510:	000d883a 	mov	r6,zero
    8514:	01cff834 	movhi	r7,16352
    8518:	da801515 	stw	r10,84(sp)
    851c:	000d22c0 	call	d22c <__adddf3>
    8520:	da801517 	ldw	r10,84(sp)
    8524:	1009883a 	mov	r4,r2
    8528:	180b883a 	mov	r5,r3
    852c:	500f883a 	mov	r7,r10
    8530:	a80d883a 	mov	r6,r21
    8534:	000d8f80 	call	d8f8 <__ltdf2>
    8538:	da801517 	ldw	r10,84(sp)
    853c:	10003b0e 	bge	r2,zero,862c <_dtoa_r+0x1534>
    8540:	d9c01317 	ldw	r7,76(sp)
    8544:	b53fffc3 	ldbu	r20,-1(r22)
    8548:	d9c00615 	stw	r7,24(sp)
    854c:	003d3106 	br	7a14 <_dtoa_r+0x91c>
    8550:	d8800817 	ldw	r2,32(sp)
    8554:	11e5c83a 	sub	r18,r2,r7
    8558:	0005883a 	mov	r2,zero
    855c:	003d5006 	br	7aa0 <_dtoa_r+0x9a8>
    8560:	05800044 	movi	r22,1
    8564:	003dc406 	br	7c78 <_dtoa_r+0xb80>
    8568:	a5000044 	addi	r20,r20,1
    856c:	15000005 	stb	r20,0(r2)
    8570:	003c8206 	br	777c <_dtoa_r+0x684>
    8574:	d8800217 	ldw	r2,8(sp)
    8578:	00c00d84 	movi	r3,54
    857c:	dcc00a17 	ldw	r19,40(sp)
    8580:	1885c83a 	sub	r2,r3,r2
    8584:	dc800817 	ldw	r18,32(sp)
    8588:	003d4506 	br	7aa0 <_dtoa_r+0x9a8>
    858c:	dcc00317 	ldw	r19,12(sp)
    8590:	8829883a 	mov	r20,r17
    8594:	04800084 	movi	r18,2
    8598:	003bea06 	br	7544 <_dtoa_r+0x44c>
    859c:	d9000917 	ldw	r4,36(sp)
    85a0:	203f1126 	beq	r4,zero,81e8 <_dtoa_r+0x10f0>
    85a4:	d9c00e17 	ldw	r7,56(sp)
    85a8:	01fca20e 	bge	zero,r7,7834 <_dtoa_r+0x73c>
    85ac:	a00b883a 	mov	r5,r20
    85b0:	9809883a 	mov	r4,r19
    85b4:	000d883a 	mov	r6,zero
    85b8:	01d00934 	movhi	r7,16420
    85bc:	000d2e00 	call	d2e0 <__muldf3>
    85c0:	91000044 	addi	r4,r18,1
    85c4:	1027883a 	mov	r19,r2
    85c8:	1829883a 	mov	r20,r3
    85cc:	000d9540 	call	d954 <__floatsidf>
    85d0:	9809883a 	mov	r4,r19
    85d4:	a00b883a 	mov	r5,r20
    85d8:	100d883a 	mov	r6,r2
    85dc:	180f883a 	mov	r7,r3
    85e0:	000d2e00 	call	d2e0 <__muldf3>
    85e4:	1009883a 	mov	r4,r2
    85e8:	180b883a 	mov	r5,r3
    85ec:	000d883a 	mov	r6,zero
    85f0:	01d00734 	movhi	r7,16412
    85f4:	000d22c0 	call	d22c <__adddf3>
    85f8:	1025883a 	mov	r18,r2
    85fc:	d8800617 	ldw	r2,24(sp)
    8600:	057f3034 	movhi	r21,64704
    8604:	1d6b883a 	add	r21,r3,r21
    8608:	10bfffc4 	addi	r2,r2,-1
    860c:	d8801315 	stw	r2,76(sp)
    8610:	dac00e17 	ldw	r11,56(sp)
    8614:	003be706 	br	75b4 <_dtoa_r+0x4bc>
    8618:	01000e44 	movi	r4,57
    861c:	91000005 	stb	r4,0(r18)
    8620:	95800044 	addi	r22,r18,1
    8624:	982b883a 	mov	r21,r19
    8628:	003da106 	br	7cb0 <_dtoa_r+0xbb8>
    862c:	d9801117 	ldw	r6,68(sp)
    8630:	d9c01217 	ldw	r7,72(sp)
    8634:	0009883a 	mov	r4,zero
    8638:	014ff834 	movhi	r5,16352
    863c:	da801515 	stw	r10,84(sp)
    8640:	000d2800 	call	d280 <__subdf3>
    8644:	da801517 	ldw	r10,84(sp)
    8648:	1009883a 	mov	r4,r2
    864c:	180b883a 	mov	r5,r3
    8650:	a80d883a 	mov	r6,r21
    8654:	500f883a 	mov	r7,r10
    8658:	000d8300 	call	d830 <__gtdf2>
    865c:	00bc750e 	bge	zero,r2,7834 <_dtoa_r+0x73c>
    8660:	01000c04 	movi	r4,48
    8664:	00000106 	br	866c <_dtoa_r+0x1574>
    8668:	102d883a 	mov	r22,r2
    866c:	b0bfffc4 	addi	r2,r22,-1
    8670:	10c00007 	ldb	r3,0(r2)
    8674:	193ffc26 	beq	r3,r4,8668 <_dtoa_r+0x1570>
    8678:	d8801317 	ldw	r2,76(sp)
    867c:	d8800615 	stw	r2,24(sp)
    8680:	003c3e06 	br	777c <_dtoa_r+0x684>
    8684:	d9001317 	ldw	r4,76(sp)
    8688:	df001117 	ldw	fp,68(sp)
    868c:	d9000615 	stw	r4,24(sp)
    8690:	003ce006 	br	7a14 <_dtoa_r+0x91c>
    8694:	df001117 	ldw	fp,68(sp)
    8698:	dc401217 	ldw	r17,72(sp)
    869c:	003c6506 	br	7834 <_dtoa_r+0x73c>
    86a0:	103e7a1e 	bne	r2,zero,808c <_dtoa_r+0xf94>
    86a4:	1880004c 	andi	r2,r3,1
    86a8:	103e7826 	beq	r2,zero,808c <_dtoa_r+0xf94>
    86ac:	003e7406 	br	8080 <_dtoa_r+0xf88>
    86b0:	8009883a 	mov	r4,r16
    86b4:	a80b883a 	mov	r5,r21
    86b8:	01800284 	movi	r6,10
    86bc:	000f883a 	mov	r7,zero
    86c0:	000a4800 	call	a480 <__multadd>
    86c4:	d9000e17 	ldw	r4,56(sp)
    86c8:	102b883a 	mov	r21,r2
    86cc:	d9000915 	stw	r4,36(sp)
    86d0:	003d5106 	br	7c18 <_dtoa_r+0xb20>
    86d4:	04800084 	movi	r18,2
    86d8:	003b9a06 	br	7544 <_dtoa_r+0x44c>
    86dc:	d8c01317 	ldw	r3,76(sp)
    86e0:	d8c00615 	stw	r3,24(sp)
    86e4:	003ccb06 	br	7a14 <_dtoa_r+0x91c>
    86e8:	d8c01317 	ldw	r3,76(sp)
    86ec:	d8c00615 	stw	r3,24(sp)
    86f0:	003c2206 	br	777c <_dtoa_r+0x684>
    86f4:	20fd3826 	beq	r4,r3,7bd8 <_dtoa_r+0xae0>
    86f8:	00c00f04 	movi	r3,60
    86fc:	1885c83a 	sub	r2,r3,r2
    8700:	003da906 	br	7da8 <_dtoa_r+0xcb0>
    8704:	000b883a 	mov	r5,zero
    8708:	003b5406 	br	745c <_dtoa_r+0x364>
    870c:	04c00044 	movi	r19,1
    8710:	003b3b06 	br	7400 <_dtoa_r+0x308>

00008714 <_fflush_r>:
    8714:	defffb04 	addi	sp,sp,-20
    8718:	dcc00315 	stw	r19,12(sp)
    871c:	dc400115 	stw	r17,4(sp)
    8720:	dfc00415 	stw	ra,16(sp)
    8724:	dc800215 	stw	r18,8(sp)
    8728:	dc000015 	stw	r16,0(sp)
    872c:	2027883a 	mov	r19,r4
    8730:	2823883a 	mov	r17,r5
    8734:	20000226 	beq	r4,zero,8740 <_fflush_r+0x2c>
    8738:	20800e17 	ldw	r2,56(r4)
    873c:	10005726 	beq	r2,zero,889c <_fflush_r+0x188>
    8740:	8880030b 	ldhu	r2,12(r17)
    8744:	10c0020c 	andi	r3,r2,8
    8748:	18ffffcc 	andi	r3,r3,65535
    874c:	18e0001c 	xori	r3,r3,32768
    8750:	18e00004 	addi	r3,r3,-32768
    8754:	1800311e 	bne	r3,zero,881c <_fflush_r+0x108>
    8758:	89000117 	ldw	r4,4(r17)
    875c:	10c20014 	ori	r3,r2,2048
    8760:	88c0030d 	sth	r3,12(r17)
    8764:	180b883a 	mov	r5,r3
    8768:	0100520e 	bge	zero,r4,88b4 <_fflush_r+0x1a0>
    876c:	88c00a17 	ldw	r3,40(r17)
    8770:	18002226 	beq	r3,zero,87fc <_fflush_r+0xe8>
    8774:	1084000c 	andi	r2,r2,4096
    8778:	10bfffcc 	andi	r2,r2,65535
    877c:	10a0001c 	xori	r2,r2,32768
    8780:	10a00004 	addi	r2,r2,-32768
    8784:	10004e26 	beq	r2,zero,88c0 <_fflush_r+0x1ac>
    8788:	8c001417 	ldw	r16,80(r17)
    878c:	2940010c 	andi	r5,r5,4
    8790:	297fffcc 	andi	r5,r5,65535
    8794:	2960001c 	xori	r5,r5,32768
    8798:	29600004 	addi	r5,r5,-32768
    879c:	28000626 	beq	r5,zero,87b8 <_fflush_r+0xa4>
    87a0:	89000117 	ldw	r4,4(r17)
    87a4:	88800c17 	ldw	r2,48(r17)
    87a8:	8121c83a 	sub	r16,r16,r4
    87ac:	10000226 	beq	r2,zero,87b8 <_fflush_r+0xa4>
    87b0:	88800f17 	ldw	r2,60(r17)
    87b4:	80a1c83a 	sub	r16,r16,r2
    87b8:	89400717 	ldw	r5,28(r17)
    87bc:	9809883a 	mov	r4,r19
    87c0:	800d883a 	mov	r6,r16
    87c4:	000f883a 	mov	r7,zero
    87c8:	183ee83a 	callr	r3
    87cc:	8080281e 	bne	r16,r2,8870 <_fflush_r+0x15c>
    87d0:	8880030b 	ldhu	r2,12(r17)
    87d4:	88c00417 	ldw	r3,16(r17)
    87d8:	88000115 	stw	zero,4(r17)
    87dc:	113dffcc 	andi	r4,r2,63487
    87e0:	1084000c 	andi	r2,r2,4096
    87e4:	10bfffcc 	andi	r2,r2,65535
    87e8:	10a0001c 	xori	r2,r2,32768
    87ec:	8900030d 	sth	r4,12(r17)
    87f0:	88c00015 	stw	r3,0(r17)
    87f4:	10a00004 	addi	r2,r2,-32768
    87f8:	10002c1e 	bne	r2,zero,88ac <_fflush_r+0x198>
    87fc:	0005883a 	mov	r2,zero
    8800:	dfc00417 	ldw	ra,16(sp)
    8804:	dcc00317 	ldw	r19,12(sp)
    8808:	dc800217 	ldw	r18,8(sp)
    880c:	dc400117 	ldw	r17,4(sp)
    8810:	dc000017 	ldw	r16,0(sp)
    8814:	dec00504 	addi	sp,sp,20
    8818:	f800283a 	ret
    881c:	8c800417 	ldw	r18,16(r17)
    8820:	903ff626 	beq	r18,zero,87fc <_fflush_r+0xe8>
    8824:	8c000017 	ldw	r16,0(r17)
    8828:	108000cc 	andi	r2,r2,3
    882c:	8c800015 	stw	r18,0(r17)
    8830:	84a1c83a 	sub	r16,r16,r18
    8834:	10001b1e 	bne	r2,zero,88a4 <_fflush_r+0x190>
    8838:	88800517 	ldw	r2,20(r17)
    883c:	88800215 	stw	r2,8(r17)
    8840:	04000316 	blt	zero,r16,8850 <_fflush_r+0x13c>
    8844:	003fed06 	br	87fc <_fflush_r+0xe8>
    8848:	90a5883a 	add	r18,r18,r2
    884c:	043feb0e 	bge	zero,r16,87fc <_fflush_r+0xe8>
    8850:	88800917 	ldw	r2,36(r17)
    8854:	89400717 	ldw	r5,28(r17)
    8858:	800f883a 	mov	r7,r16
    885c:	900d883a 	mov	r6,r18
    8860:	9809883a 	mov	r4,r19
    8864:	103ee83a 	callr	r2
    8868:	80a1c83a 	sub	r16,r16,r2
    886c:	00bff616 	blt	zero,r2,8848 <_fflush_r+0x134>
    8870:	88c0030b 	ldhu	r3,12(r17)
    8874:	00bfffc4 	movi	r2,-1
    8878:	18c01014 	ori	r3,r3,64
    887c:	88c0030d 	sth	r3,12(r17)
    8880:	dfc00417 	ldw	ra,16(sp)
    8884:	dcc00317 	ldw	r19,12(sp)
    8888:	dc800217 	ldw	r18,8(sp)
    888c:	dc400117 	ldw	r17,4(sp)
    8890:	dc000017 	ldw	r16,0(sp)
    8894:	dec00504 	addi	sp,sp,20
    8898:	f800283a 	ret
    889c:	00089bc0 	call	89bc <__sinit>
    88a0:	003fa706 	br	8740 <_fflush_r+0x2c>
    88a4:	0005883a 	mov	r2,zero
    88a8:	003fe406 	br	883c <_fflush_r+0x128>
    88ac:	8c001415 	stw	r16,80(r17)
    88b0:	003fd206 	br	87fc <_fflush_r+0xe8>
    88b4:	88c00f17 	ldw	r3,60(r17)
    88b8:	00ffac16 	blt	zero,r3,876c <_fflush_r+0x58>
    88bc:	003fcf06 	br	87fc <_fflush_r+0xe8>
    88c0:	89400717 	ldw	r5,28(r17)
    88c4:	9809883a 	mov	r4,r19
    88c8:	000d883a 	mov	r6,zero
    88cc:	01c00044 	movi	r7,1
    88d0:	183ee83a 	callr	r3
    88d4:	1021883a 	mov	r16,r2
    88d8:	00bfffc4 	movi	r2,-1
    88dc:	80800326 	beq	r16,r2,88ec <_fflush_r+0x1d8>
    88e0:	8940030b 	ldhu	r5,12(r17)
    88e4:	88c00a17 	ldw	r3,40(r17)
    88e8:	003fa806 	br	878c <_fflush_r+0x78>
    88ec:	98c00017 	ldw	r3,0(r19)
    88f0:	00800744 	movi	r2,29
    88f4:	18bfde1e 	bne	r3,r2,8870 <_fflush_r+0x15c>
    88f8:	003fc006 	br	87fc <_fflush_r+0xe8>

000088fc <fflush>:
    88fc:	200b883a 	mov	r5,r4
    8900:	20000426 	beq	r4,zero,8914 <fflush+0x18>
    8904:	00800134 	movhi	r2,4
    8908:	1095bf04 	addi	r2,r2,22268
    890c:	11000017 	ldw	r4,0(r2)
    8910:	00087141 	jmpi	8714 <_fflush_r>
    8914:	00800134 	movhi	r2,4
    8918:	1095be04 	addi	r2,r2,22264
    891c:	11000017 	ldw	r4,0(r2)
    8920:	01400074 	movhi	r5,1
    8924:	2961c504 	addi	r5,r5,-30956
    8928:	00096d01 	jmpi	96d0 <_fwalk_reent>

0000892c <__fp_lock>:
    892c:	0005883a 	mov	r2,zero
    8930:	f800283a 	ret

00008934 <__fp_unlock>:
    8934:	0005883a 	mov	r2,zero
    8938:	f800283a 	ret

0000893c <_cleanup_r>:
    893c:	01400074 	movhi	r5,1
    8940:	29707304 	addi	r5,r5,-15924
    8944:	00096281 	jmpi	9628 <_fwalk>

00008948 <__sfmoreglue>:
    8948:	defffc04 	addi	sp,sp,-16
    894c:	dc400115 	stw	r17,4(sp)
    8950:	2c401724 	muli	r17,r5,92
    8954:	dc800215 	stw	r18,8(sp)
    8958:	2825883a 	mov	r18,r5
    895c:	89400304 	addi	r5,r17,12
    8960:	dc000015 	stw	r16,0(sp)
    8964:	dfc00315 	stw	ra,12(sp)
    8968:	0009a0c0 	call	9a0c <_malloc_r>
    896c:	1021883a 	mov	r16,r2
    8970:	10000726 	beq	r2,zero,8990 <__sfmoreglue+0x48>
    8974:	11000304 	addi	r4,r2,12
    8978:	10000015 	stw	zero,0(r2)
    897c:	14800115 	stw	r18,4(r2)
    8980:	11000215 	stw	r4,8(r2)
    8984:	000b883a 	mov	r5,zero
    8988:	880d883a 	mov	r6,r17
    898c:	00042e80 	call	42e8 <memset>
    8990:	8005883a 	mov	r2,r16
    8994:	dfc00317 	ldw	ra,12(sp)
    8998:	dc800217 	ldw	r18,8(sp)
    899c:	dc400117 	ldw	r17,4(sp)
    89a0:	dc000017 	ldw	r16,0(sp)
    89a4:	dec00404 	addi	sp,sp,16
    89a8:	f800283a 	ret

000089ac <_cleanup>:
    89ac:	00800134 	movhi	r2,4
    89b0:	1095be04 	addi	r2,r2,22264
    89b4:	11000017 	ldw	r4,0(r2)
    89b8:	000893c1 	jmpi	893c <_cleanup_r>

000089bc <__sinit>:
    89bc:	20800e17 	ldw	r2,56(r4)
    89c0:	1000401e 	bne	r2,zero,8ac4 <__sinit+0x108>
    89c4:	21400117 	ldw	r5,4(r4)
    89c8:	01800074 	movhi	r6,1
    89cc:	31a24f04 	addi	r6,r6,-30404
    89d0:	20c00217 	ldw	r3,8(r4)
    89d4:	21800f15 	stw	r6,60(r4)
    89d8:	2080bb04 	addi	r2,r4,748
    89dc:	02400044 	movi	r9,1
    89e0:	018000c4 	movi	r6,3
    89e4:	2180b915 	stw	r6,740(r4)
    89e8:	2080ba15 	stw	r2,744(r4)
    89ec:	22400e15 	stw	r9,56(r4)
    89f0:	20800317 	ldw	r2,12(r4)
    89f4:	2000b815 	stw	zero,736(r4)
    89f8:	02000074 	movhi	r8,1
    89fc:	422ef204 	addi	r8,r8,-17464
    8a00:	01c00074 	movhi	r7,1
    8a04:	39ef0704 	addi	r7,r7,-17380
    8a08:	01800074 	movhi	r6,1
    8a0c:	31af2904 	addi	r6,r6,-17244
    8a10:	01000074 	movhi	r4,1
    8a14:	212f4004 	addi	r4,r4,-17152
    8a18:	02800104 	movi	r10,4
    8a1c:	28000015 	stw	zero,0(r5)
    8a20:	28000115 	stw	zero,4(r5)
    8a24:	28000215 	stw	zero,8(r5)
    8a28:	2a80030d 	sth	r10,12(r5)
    8a2c:	2800038d 	sth	zero,14(r5)
    8a30:	28000415 	stw	zero,16(r5)
    8a34:	28000515 	stw	zero,20(r5)
    8a38:	28000615 	stw	zero,24(r5)
    8a3c:	29400715 	stw	r5,28(r5)
    8a40:	2a000815 	stw	r8,32(r5)
    8a44:	29c00915 	stw	r7,36(r5)
    8a48:	29800a15 	stw	r6,40(r5)
    8a4c:	29000b15 	stw	r4,44(r5)
    8a50:	01400284 	movi	r5,10
    8a54:	18000015 	stw	zero,0(r3)
    8a58:	18000115 	stw	zero,4(r3)
    8a5c:	18000215 	stw	zero,8(r3)
    8a60:	1940030d 	sth	r5,12(r3)
    8a64:	1a40038d 	sth	r9,14(r3)
    8a68:	18000415 	stw	zero,16(r3)
    8a6c:	18000515 	stw	zero,20(r3)
    8a70:	18000615 	stw	zero,24(r3)
    8a74:	18c00715 	stw	r3,28(r3)
    8a78:	1a000815 	stw	r8,32(r3)
    8a7c:	19c00915 	stw	r7,36(r3)
    8a80:	19800a15 	stw	r6,40(r3)
    8a84:	19000b15 	stw	r4,44(r3)
    8a88:	00c00484 	movi	r3,18
    8a8c:	10c0030d 	sth	r3,12(r2)
    8a90:	00c00084 	movi	r3,2
    8a94:	10000015 	stw	zero,0(r2)
    8a98:	10000115 	stw	zero,4(r2)
    8a9c:	10000215 	stw	zero,8(r2)
    8aa0:	10c0038d 	sth	r3,14(r2)
    8aa4:	10000415 	stw	zero,16(r2)
    8aa8:	10000515 	stw	zero,20(r2)
    8aac:	10000615 	stw	zero,24(r2)
    8ab0:	10800715 	stw	r2,28(r2)
    8ab4:	12000815 	stw	r8,32(r2)
    8ab8:	11c00915 	stw	r7,36(r2)
    8abc:	11800a15 	stw	r6,40(r2)
    8ac0:	11000b15 	stw	r4,44(r2)
    8ac4:	f800283a 	ret

00008ac8 <__sfp>:
    8ac8:	defffc04 	addi	sp,sp,-16
    8acc:	00800134 	movhi	r2,4
    8ad0:	1095be04 	addi	r2,r2,22264
    8ad4:	dc400115 	stw	r17,4(sp)
    8ad8:	14400017 	ldw	r17,0(r2)
    8adc:	dc800215 	stw	r18,8(sp)
    8ae0:	dfc00315 	stw	ra,12(sp)
    8ae4:	88800e17 	ldw	r2,56(r17)
    8ae8:	dc000015 	stw	r16,0(sp)
    8aec:	2025883a 	mov	r18,r4
    8af0:	10002826 	beq	r2,zero,8b94 <__sfp+0xcc>
    8af4:	8c40b804 	addi	r17,r17,736
    8af8:	043fffc4 	movi	r16,-1
    8afc:	89400117 	ldw	r5,4(r17)
    8b00:	88800217 	ldw	r2,8(r17)
    8b04:	297fffc4 	addi	r5,r5,-1
    8b08:	28000a16 	blt	r5,zero,8b34 <__sfp+0x6c>
    8b0c:	10c0030f 	ldh	r3,12(r2)
    8b10:	18000c26 	beq	r3,zero,8b44 <__sfp+0x7c>
    8b14:	10c01a04 	addi	r3,r2,104
    8b18:	00000206 	br	8b24 <__sfp+0x5c>
    8b1c:	19bfe90f 	ldh	r6,-92(r3)
    8b20:	30000826 	beq	r6,zero,8b44 <__sfp+0x7c>
    8b24:	297fffc4 	addi	r5,r5,-1
    8b28:	18bffd04 	addi	r2,r3,-12
    8b2c:	18c01704 	addi	r3,r3,92
    8b30:	2c3ffa1e 	bne	r5,r16,8b1c <__sfp+0x54>
    8b34:	88800017 	ldw	r2,0(r17)
    8b38:	10001926 	beq	r2,zero,8ba0 <__sfp+0xd8>
    8b3c:	1023883a 	mov	r17,r2
    8b40:	003fee06 	br	8afc <__sfp+0x34>
    8b44:	00ffffc4 	movi	r3,-1
    8b48:	10c0038d 	sth	r3,14(r2)
    8b4c:	00c00044 	movi	r3,1
    8b50:	10c0030d 	sth	r3,12(r2)
    8b54:	10000015 	stw	zero,0(r2)
    8b58:	10000215 	stw	zero,8(r2)
    8b5c:	10000115 	stw	zero,4(r2)
    8b60:	10000415 	stw	zero,16(r2)
    8b64:	10000515 	stw	zero,20(r2)
    8b68:	10000615 	stw	zero,24(r2)
    8b6c:	10000c15 	stw	zero,48(r2)
    8b70:	10000d15 	stw	zero,52(r2)
    8b74:	10001115 	stw	zero,68(r2)
    8b78:	10001215 	stw	zero,72(r2)
    8b7c:	dfc00317 	ldw	ra,12(sp)
    8b80:	dc800217 	ldw	r18,8(sp)
    8b84:	dc400117 	ldw	r17,4(sp)
    8b88:	dc000017 	ldw	r16,0(sp)
    8b8c:	dec00404 	addi	sp,sp,16
    8b90:	f800283a 	ret
    8b94:	8809883a 	mov	r4,r17
    8b98:	00089bc0 	call	89bc <__sinit>
    8b9c:	003fd506 	br	8af4 <__sfp+0x2c>
    8ba0:	9009883a 	mov	r4,r18
    8ba4:	01400104 	movi	r5,4
    8ba8:	00089480 	call	8948 <__sfmoreglue>
    8bac:	88800015 	stw	r2,0(r17)
    8bb0:	103fe21e 	bne	r2,zero,8b3c <__sfp+0x74>
    8bb4:	00800304 	movi	r2,12
    8bb8:	90800015 	stw	r2,0(r18)
    8bbc:	0005883a 	mov	r2,zero
    8bc0:	003fee06 	br	8b7c <__sfp+0xb4>

00008bc4 <__sfp_lock_acquire>:
    8bc4:	f800283a 	ret

00008bc8 <__sfp_lock_release>:
    8bc8:	f800283a 	ret

00008bcc <__sinit_lock_acquire>:
    8bcc:	f800283a 	ret

00008bd0 <__sinit_lock_release>:
    8bd0:	f800283a 	ret

00008bd4 <__fp_lock_all>:
    8bd4:	00800134 	movhi	r2,4
    8bd8:	1095bf04 	addi	r2,r2,22268
    8bdc:	11000017 	ldw	r4,0(r2)
    8be0:	01400074 	movhi	r5,1
    8be4:	29624b04 	addi	r5,r5,-30420
    8be8:	00096281 	jmpi	9628 <_fwalk>

00008bec <__fp_unlock_all>:
    8bec:	00800134 	movhi	r2,4
    8bf0:	1095bf04 	addi	r2,r2,22268
    8bf4:	11000017 	ldw	r4,0(r2)
    8bf8:	01400074 	movhi	r5,1
    8bfc:	29624d04 	addi	r5,r5,-30412
    8c00:	00096281 	jmpi	9628 <_fwalk>

00008c04 <_fputc_r>:
    8c04:	defffc04 	addi	sp,sp,-16
    8c08:	dc000215 	stw	r16,8(sp)
    8c0c:	dfc00315 	stw	ra,12(sp)
    8c10:	2021883a 	mov	r16,r4
    8c14:	20000726 	beq	r4,zero,8c34 <_fputc_r+0x30>
    8c18:	20800e17 	ldw	r2,56(r4)
    8c1c:	1000051e 	bne	r2,zero,8c34 <_fputc_r+0x30>
    8c20:	d9400015 	stw	r5,0(sp)
    8c24:	d9800115 	stw	r6,4(sp)
    8c28:	00089bc0 	call	89bc <__sinit>
    8c2c:	d9800117 	ldw	r6,4(sp)
    8c30:	d9400017 	ldw	r5,0(sp)
    8c34:	8009883a 	mov	r4,r16
    8c38:	dfc00317 	ldw	ra,12(sp)
    8c3c:	dc000217 	ldw	r16,8(sp)
    8c40:	dec00404 	addi	sp,sp,16
    8c44:	000b3581 	jmpi	b358 <_putc_r>

00008c48 <fputc>:
    8c48:	defffc04 	addi	sp,sp,-16
    8c4c:	dc000115 	stw	r16,4(sp)
    8c50:	04000134 	movhi	r16,4
    8c54:	8415bf04 	addi	r16,r16,22268
    8c58:	80800017 	ldw	r2,0(r16)
    8c5c:	dc400215 	stw	r17,8(sp)
    8c60:	dfc00315 	stw	ra,12(sp)
    8c64:	2023883a 	mov	r17,r4
    8c68:	280d883a 	mov	r6,r5
    8c6c:	10000726 	beq	r2,zero,8c8c <fputc+0x44>
    8c70:	10c00e17 	ldw	r3,56(r2)
    8c74:	1800051e 	bne	r3,zero,8c8c <fputc+0x44>
    8c78:	1009883a 	mov	r4,r2
    8c7c:	d9400015 	stw	r5,0(sp)
    8c80:	00089bc0 	call	89bc <__sinit>
    8c84:	80800017 	ldw	r2,0(r16)
    8c88:	d9800017 	ldw	r6,0(sp)
    8c8c:	1009883a 	mov	r4,r2
    8c90:	880b883a 	mov	r5,r17
    8c94:	dfc00317 	ldw	ra,12(sp)
    8c98:	dc400217 	ldw	r17,8(sp)
    8c9c:	dc000117 	ldw	r16,4(sp)
    8ca0:	dec00404 	addi	sp,sp,16
    8ca4:	000b3581 	jmpi	b358 <_putc_r>

00008ca8 <_fputs_r>:
    8ca8:	defff804 	addi	sp,sp,-32
    8cac:	dc000515 	stw	r16,20(sp)
    8cb0:	2021883a 	mov	r16,r4
    8cb4:	2809883a 	mov	r4,r5
    8cb8:	dc400615 	stw	r17,24(sp)
    8cbc:	dfc00715 	stw	ra,28(sp)
    8cc0:	3023883a 	mov	r17,r6
    8cc4:	d9400315 	stw	r5,12(sp)
    8cc8:	0004d9c0 	call	4d9c <strlen>
    8ccc:	d8800215 	stw	r2,8(sp)
    8cd0:	d8800415 	stw	r2,16(sp)
    8cd4:	d8800304 	addi	r2,sp,12
    8cd8:	d8800015 	stw	r2,0(sp)
    8cdc:	00800044 	movi	r2,1
    8ce0:	d8800115 	stw	r2,4(sp)
    8ce4:	80000426 	beq	r16,zero,8cf8 <_fputs_r+0x50>
    8ce8:	80800e17 	ldw	r2,56(r16)
    8cec:	1000021e 	bne	r2,zero,8cf8 <_fputs_r+0x50>
    8cf0:	8009883a 	mov	r4,r16
    8cf4:	00089bc0 	call	89bc <__sinit>
    8cf8:	8009883a 	mov	r4,r16
    8cfc:	880b883a 	mov	r5,r17
    8d00:	d80d883a 	mov	r6,sp
    8d04:	00091440 	call	9144 <__sfvwrite_r>
    8d08:	dfc00717 	ldw	ra,28(sp)
    8d0c:	dc400617 	ldw	r17,24(sp)
    8d10:	dc000517 	ldw	r16,20(sp)
    8d14:	dec00804 	addi	sp,sp,32
    8d18:	f800283a 	ret

00008d1c <fputs>:
    8d1c:	00c00134 	movhi	r3,4
    8d20:	18d5bf04 	addi	r3,r3,22268
    8d24:	2005883a 	mov	r2,r4
    8d28:	19000017 	ldw	r4,0(r3)
    8d2c:	280d883a 	mov	r6,r5
    8d30:	100b883a 	mov	r5,r2
    8d34:	0008ca81 	jmpi	8ca8 <_fputs_r>

00008d38 <_malloc_trim_r>:
    8d38:	defffb04 	addi	sp,sp,-20
    8d3c:	dcc00315 	stw	r19,12(sp)
    8d40:	dc800215 	stw	r18,8(sp)
    8d44:	dc400115 	stw	r17,4(sp)
    8d48:	dc000015 	stw	r16,0(sp)
    8d4c:	2827883a 	mov	r19,r5
    8d50:	dfc00415 	stw	ra,16(sp)
    8d54:	04400134 	movhi	r17,4
    8d58:	8c4e4f04 	addi	r17,r17,14652
    8d5c:	2021883a 	mov	r16,r4
    8d60:	000e3f40 	call	e3f4 <__malloc_lock>
    8d64:	88800217 	ldw	r2,8(r17)
    8d68:	14800117 	ldw	r18,4(r2)
    8d6c:	00bfff04 	movi	r2,-4
    8d70:	90a4703a 	and	r18,r18,r2
    8d74:	9083fbc4 	addi	r2,r18,4079
    8d78:	14e7c83a 	sub	r19,r2,r19
    8d7c:	9826d33a 	srli	r19,r19,12
    8d80:	0083ffc4 	movi	r2,4095
    8d84:	9cffffc4 	addi	r19,r19,-1
    8d88:	9826933a 	slli	r19,r19,12
    8d8c:	14c0060e 	bge	r2,r19,8da8 <_malloc_trim_r+0x70>
    8d90:	8009883a 	mov	r4,r16
    8d94:	000b883a 	mov	r5,zero
    8d98:	000bb640 	call	bb64 <_sbrk_r>
    8d9c:	88c00217 	ldw	r3,8(r17)
    8da0:	1c87883a 	add	r3,r3,r18
    8da4:	10c00a26 	beq	r2,r3,8dd0 <_malloc_trim_r+0x98>
    8da8:	8009883a 	mov	r4,r16
    8dac:	000e4540 	call	e454 <__malloc_unlock>
    8db0:	0005883a 	mov	r2,zero
    8db4:	dfc00417 	ldw	ra,16(sp)
    8db8:	dcc00317 	ldw	r19,12(sp)
    8dbc:	dc800217 	ldw	r18,8(sp)
    8dc0:	dc400117 	ldw	r17,4(sp)
    8dc4:	dc000017 	ldw	r16,0(sp)
    8dc8:	dec00504 	addi	sp,sp,20
    8dcc:	f800283a 	ret
    8dd0:	8009883a 	mov	r4,r16
    8dd4:	04cbc83a 	sub	r5,zero,r19
    8dd8:	000bb640 	call	bb64 <_sbrk_r>
    8ddc:	00ffffc4 	movi	r3,-1
    8de0:	10c01326 	beq	r2,r3,8e30 <_malloc_trim_r+0xf8>
    8de4:	00800134 	movhi	r2,4
    8de8:	109f1404 	addi	r2,r2,31824
    8dec:	11000017 	ldw	r4,0(r2)
    8df0:	88c00217 	ldw	r3,8(r17)
    8df4:	94e5c83a 	sub	r18,r18,r19
    8df8:	94800054 	ori	r18,r18,1
    8dfc:	24e7c83a 	sub	r19,r4,r19
    8e00:	1c800115 	stw	r18,4(r3)
    8e04:	8009883a 	mov	r4,r16
    8e08:	14c00015 	stw	r19,0(r2)
    8e0c:	000e4540 	call	e454 <__malloc_unlock>
    8e10:	00800044 	movi	r2,1
    8e14:	dfc00417 	ldw	ra,16(sp)
    8e18:	dcc00317 	ldw	r19,12(sp)
    8e1c:	dc800217 	ldw	r18,8(sp)
    8e20:	dc400117 	ldw	r17,4(sp)
    8e24:	dc000017 	ldw	r16,0(sp)
    8e28:	dec00504 	addi	sp,sp,20
    8e2c:	f800283a 	ret
    8e30:	8009883a 	mov	r4,r16
    8e34:	000b883a 	mov	r5,zero
    8e38:	000bb640 	call	bb64 <_sbrk_r>
    8e3c:	88c00217 	ldw	r3,8(r17)
    8e40:	014003c4 	movi	r5,15
    8e44:	10c9c83a 	sub	r4,r2,r3
    8e48:	293fd70e 	bge	r5,r4,8da8 <_malloc_trim_r+0x70>
    8e4c:	01400134 	movhi	r5,4
    8e50:	2955c104 	addi	r5,r5,22276
    8e54:	29400017 	ldw	r5,0(r5)
    8e58:	21000054 	ori	r4,r4,1
    8e5c:	19000115 	stw	r4,4(r3)
    8e60:	1145c83a 	sub	r2,r2,r5
    8e64:	01400134 	movhi	r5,4
    8e68:	295f1404 	addi	r5,r5,31824
    8e6c:	28800015 	stw	r2,0(r5)
    8e70:	003fcd06 	br	8da8 <_malloc_trim_r+0x70>

00008e74 <_free_r>:
    8e74:	defffd04 	addi	sp,sp,-12
    8e78:	dc400115 	stw	r17,4(sp)
    8e7c:	dc000015 	stw	r16,0(sp)
    8e80:	dfc00215 	stw	ra,8(sp)
    8e84:	2821883a 	mov	r16,r5
    8e88:	2023883a 	mov	r17,r4
    8e8c:	28004b26 	beq	r5,zero,8fbc <_free_r+0x148>
    8e90:	000e3f40 	call	e3f4 <__malloc_lock>
    8e94:	823fff17 	ldw	r8,-4(r16)
    8e98:	00bfff84 	movi	r2,-2
    8e9c:	81bffe04 	addi	r6,r16,-8
    8ea0:	4084703a 	and	r2,r8,r2
    8ea4:	3087883a 	add	r3,r6,r2
    8ea8:	01400134 	movhi	r5,4
    8eac:	294e4f04 	addi	r5,r5,14652
    8eb0:	1a400117 	ldw	r9,4(r3)
    8eb4:	29000217 	ldw	r4,8(r5)
    8eb8:	01ffff04 	movi	r7,-4
    8ebc:	49ce703a 	and	r7,r9,r7
    8ec0:	20c06526 	beq	r4,r3,9058 <_free_r+0x1e4>
    8ec4:	19c00115 	stw	r7,4(r3)
    8ec8:	4200004c 	andi	r8,r8,1
    8ecc:	40003026 	beq	r8,zero,8f90 <_free_r+0x11c>
    8ed0:	0009883a 	mov	r4,zero
    8ed4:	19d1883a 	add	r8,r3,r7
    8ed8:	42000117 	ldw	r8,4(r8)
    8edc:	4200004c 	andi	r8,r8,1
    8ee0:	4000061e 	bne	r8,zero,8efc <_free_r+0x88>
    8ee4:	11c5883a 	add	r2,r2,r7
    8ee8:	19c00217 	ldw	r7,8(r3)
    8eec:	20004e26 	beq	r4,zero,9028 <_free_r+0x1b4>
    8ef0:	18c00317 	ldw	r3,12(r3)
    8ef4:	38c00315 	stw	r3,12(r7)
    8ef8:	19c00215 	stw	r7,8(r3)
    8efc:	11c00054 	ori	r7,r2,1
    8f00:	3087883a 	add	r3,r6,r2
    8f04:	31c00115 	stw	r7,4(r6)
    8f08:	18800015 	stw	r2,0(r3)
    8f0c:	20001a1e 	bne	r4,zero,8f78 <_free_r+0x104>
    8f10:	00c07fc4 	movi	r3,511
    8f14:	18802e2e 	bgeu	r3,r2,8fd0 <_free_r+0x15c>
    8f18:	1006d27a 	srli	r3,r2,9
    8f1c:	01000104 	movi	r4,4
    8f20:	20c06636 	bltu	r4,r3,90bc <_free_r+0x248>
    8f24:	1008d1ba 	srli	r4,r2,6
    8f28:	21000e04 	addi	r4,r4,56
    8f2c:	210f883a 	add	r7,r4,r4
    8f30:	39cf883a 	add	r7,r7,r7
    8f34:	39cf883a 	add	r7,r7,r7
    8f38:	29cf883a 	add	r7,r5,r7
    8f3c:	38c00217 	ldw	r3,8(r7)
    8f40:	01400134 	movhi	r5,4
    8f44:	294e4f04 	addi	r5,r5,14652
    8f48:	19c06126 	beq	r3,r7,90d0 <_free_r+0x25c>
    8f4c:	013fff04 	movi	r4,-4
    8f50:	19400117 	ldw	r5,4(r3)
    8f54:	290a703a 	and	r5,r5,r4
    8f58:	1140022e 	bgeu	r2,r5,8f64 <_free_r+0xf0>
    8f5c:	18c00217 	ldw	r3,8(r3)
    8f60:	38fffb1e 	bne	r7,r3,8f50 <_free_r+0xdc>
    8f64:	18800317 	ldw	r2,12(r3)
    8f68:	30800315 	stw	r2,12(r6)
    8f6c:	30c00215 	stw	r3,8(r6)
    8f70:	11800215 	stw	r6,8(r2)
    8f74:	19800315 	stw	r6,12(r3)
    8f78:	8809883a 	mov	r4,r17
    8f7c:	dfc00217 	ldw	ra,8(sp)
    8f80:	dc400117 	ldw	r17,4(sp)
    8f84:	dc000017 	ldw	r16,0(sp)
    8f88:	dec00304 	addi	sp,sp,12
    8f8c:	000e4541 	jmpi	e454 <__malloc_unlock>
    8f90:	813ffe17 	ldw	r4,-8(r16)
    8f94:	2a400204 	addi	r9,r5,8
    8f98:	310dc83a 	sub	r6,r6,r4
    8f9c:	32000217 	ldw	r8,8(r6)
    8fa0:	1105883a 	add	r2,r2,r4
    8fa4:	42404326 	beq	r8,r9,90b4 <_free_r+0x240>
    8fa8:	32400317 	ldw	r9,12(r6)
    8fac:	0009883a 	mov	r4,zero
    8fb0:	42400315 	stw	r9,12(r8)
    8fb4:	4a000215 	stw	r8,8(r9)
    8fb8:	003fc606 	br	8ed4 <_free_r+0x60>
    8fbc:	dfc00217 	ldw	ra,8(sp)
    8fc0:	dc400117 	ldw	r17,4(sp)
    8fc4:	dc000017 	ldw	r16,0(sp)
    8fc8:	dec00304 	addi	sp,sp,12
    8fcc:	f800283a 	ret
    8fd0:	1004d0fa 	srli	r2,r2,3
    8fd4:	02000044 	movi	r8,1
    8fd8:	29c00117 	ldw	r7,4(r5)
    8fdc:	1087883a 	add	r3,r2,r2
    8fe0:	18c7883a 	add	r3,r3,r3
    8fe4:	1005d0ba 	srai	r2,r2,2
    8fe8:	18c7883a 	add	r3,r3,r3
    8fec:	28c7883a 	add	r3,r5,r3
    8ff0:	19000217 	ldw	r4,8(r3)
    8ff4:	4084983a 	sll	r2,r8,r2
    8ff8:	30c00315 	stw	r3,12(r6)
    8ffc:	31000215 	stw	r4,8(r6)
    9000:	11c4b03a 	or	r2,r2,r7
    9004:	21800315 	stw	r6,12(r4)
    9008:	8809883a 	mov	r4,r17
    900c:	28800115 	stw	r2,4(r5)
    9010:	19800215 	stw	r6,8(r3)
    9014:	dfc00217 	ldw	ra,8(sp)
    9018:	dc400117 	ldw	r17,4(sp)
    901c:	dc000017 	ldw	r16,0(sp)
    9020:	dec00304 	addi	sp,sp,12
    9024:	000e4541 	jmpi	e454 <__malloc_unlock>
    9028:	02000134 	movhi	r8,4
    902c:	420e5104 	addi	r8,r8,14660
    9030:	3a3faf1e 	bne	r7,r8,8ef0 <_free_r+0x7c>
    9034:	29800515 	stw	r6,20(r5)
    9038:	29800415 	stw	r6,16(r5)
    903c:	11000054 	ori	r4,r2,1
    9040:	3087883a 	add	r3,r6,r2
    9044:	31c00315 	stw	r7,12(r6)
    9048:	31c00215 	stw	r7,8(r6)
    904c:	31000115 	stw	r4,4(r6)
    9050:	18800015 	stw	r2,0(r3)
    9054:	003fc806 	br	8f78 <_free_r+0x104>
    9058:	4200004c 	andi	r8,r8,1
    905c:	3885883a 	add	r2,r7,r2
    9060:	4000071e 	bne	r8,zero,9080 <_free_r+0x20c>
    9064:	81fffe17 	ldw	r7,-8(r16)
    9068:	31cdc83a 	sub	r6,r6,r7
    906c:	30c00317 	ldw	r3,12(r6)
    9070:	31000217 	ldw	r4,8(r6)
    9074:	11c5883a 	add	r2,r2,r7
    9078:	20c00315 	stw	r3,12(r4)
    907c:	19000215 	stw	r4,8(r3)
    9080:	00c00134 	movhi	r3,4
    9084:	18d5c204 	addi	r3,r3,22280
    9088:	18c00017 	ldw	r3,0(r3)
    908c:	11000054 	ori	r4,r2,1
    9090:	31000115 	stw	r4,4(r6)
    9094:	29800215 	stw	r6,8(r5)
    9098:	10ffb736 	bltu	r2,r3,8f78 <_free_r+0x104>
    909c:	00800134 	movhi	r2,4
    90a0:	109ebd04 	addi	r2,r2,31476
    90a4:	11400017 	ldw	r5,0(r2)
    90a8:	8809883a 	mov	r4,r17
    90ac:	0008d380 	call	8d38 <_malloc_trim_r>
    90b0:	003fb106 	br	8f78 <_free_r+0x104>
    90b4:	01000044 	movi	r4,1
    90b8:	003f8606 	br	8ed4 <_free_r+0x60>
    90bc:	01000504 	movi	r4,20
    90c0:	20c00b36 	bltu	r4,r3,90f0 <_free_r+0x27c>
    90c4:	190016c4 	addi	r4,r3,91
    90c8:	210f883a 	add	r7,r4,r4
    90cc:	003f9806 	br	8f30 <_free_r+0xbc>
    90d0:	2009d0ba 	srai	r4,r4,2
    90d4:	00800044 	movi	r2,1
    90d8:	29c00117 	ldw	r7,4(r5)
    90dc:	1108983a 	sll	r4,r2,r4
    90e0:	1805883a 	mov	r2,r3
    90e4:	21c8b03a 	or	r4,r4,r7
    90e8:	29000115 	stw	r4,4(r5)
    90ec:	003f9e06 	br	8f68 <_free_r+0xf4>
    90f0:	01001504 	movi	r4,84
    90f4:	20c00436 	bltu	r4,r3,9108 <_free_r+0x294>
    90f8:	1008d33a 	srli	r4,r2,12
    90fc:	21001b84 	addi	r4,r4,110
    9100:	210f883a 	add	r7,r4,r4
    9104:	003f8a06 	br	8f30 <_free_r+0xbc>
    9108:	01005504 	movi	r4,340
    910c:	20c00436 	bltu	r4,r3,9120 <_free_r+0x2ac>
    9110:	1008d3fa 	srli	r4,r2,15
    9114:	21001dc4 	addi	r4,r4,119
    9118:	210f883a 	add	r7,r4,r4
    911c:	003f8406 	br	8f30 <_free_r+0xbc>
    9120:	01015504 	movi	r4,1364
    9124:	20c00436 	bltu	r4,r3,9138 <_free_r+0x2c4>
    9128:	1008d4ba 	srli	r4,r2,18
    912c:	21001f04 	addi	r4,r4,124
    9130:	210f883a 	add	r7,r4,r4
    9134:	003f7e06 	br	8f30 <_free_r+0xbc>
    9138:	01c03f04 	movi	r7,252
    913c:	01001f84 	movi	r4,126
    9140:	003f7b06 	br	8f30 <_free_r+0xbc>

00009144 <__sfvwrite_r>:
    9144:	30800217 	ldw	r2,8(r6)
    9148:	defff504 	addi	sp,sp,-44
    914c:	dd400615 	stw	r21,24(sp)
    9150:	dd000515 	stw	r20,20(sp)
    9154:	dc000115 	stw	r16,4(sp)
    9158:	dfc00a15 	stw	ra,40(sp)
    915c:	df000915 	stw	fp,36(sp)
    9160:	ddc00815 	stw	r23,32(sp)
    9164:	dd800715 	stw	r22,28(sp)
    9168:	dcc00415 	stw	r19,16(sp)
    916c:	dc800315 	stw	r18,12(sp)
    9170:	dc400215 	stw	r17,8(sp)
    9174:	3029883a 	mov	r20,r6
    9178:	202b883a 	mov	r21,r4
    917c:	2821883a 	mov	r16,r5
    9180:	10002126 	beq	r2,zero,9208 <__sfvwrite_r+0xc4>
    9184:	2880030b 	ldhu	r2,12(r5)
    9188:	10c0020c 	andi	r3,r2,8
    918c:	18ffffcc 	andi	r3,r3,65535
    9190:	18e0001c 	xori	r3,r3,32768
    9194:	18e00004 	addi	r3,r3,-32768
    9198:	18002826 	beq	r3,zero,923c <__sfvwrite_r+0xf8>
    919c:	28c00417 	ldw	r3,16(r5)
    91a0:	18002626 	beq	r3,zero,923c <__sfvwrite_r+0xf8>
    91a4:	10c0008c 	andi	r3,r2,2
    91a8:	18ffffcc 	andi	r3,r3,65535
    91ac:	18e0001c 	xori	r3,r3,32768
    91b0:	18e00004 	addi	r3,r3,-32768
    91b4:	a4400017 	ldw	r17,0(r20)
    91b8:	18002b26 	beq	r3,zero,9268 <__sfvwrite_r+0x124>
    91bc:	0027883a 	mov	r19,zero
    91c0:	0025883a 	mov	r18,zero
    91c4:	05810004 	movi	r22,1024
    91c8:	980d883a 	mov	r6,r19
    91cc:	a809883a 	mov	r4,r21
    91d0:	90004f26 	beq	r18,zero,9310 <__sfvwrite_r+0x1cc>
    91d4:	900f883a 	mov	r7,r18
    91d8:	81400717 	ldw	r5,28(r16)
    91dc:	b480012e 	bgeu	r22,r18,91e4 <__sfvwrite_r+0xa0>
    91e0:	01c10004 	movi	r7,1024
    91e4:	80800917 	ldw	r2,36(r16)
    91e8:	103ee83a 	callr	r2
    91ec:	0080540e 	bge	zero,r2,9340 <__sfvwrite_r+0x1fc>
    91f0:	a0c00217 	ldw	r3,8(r20)
    91f4:	98a7883a 	add	r19,r19,r2
    91f8:	90a5c83a 	sub	r18,r18,r2
    91fc:	1885c83a 	sub	r2,r3,r2
    9200:	a0800215 	stw	r2,8(r20)
    9204:	103ff01e 	bne	r2,zero,91c8 <__sfvwrite_r+0x84>
    9208:	0005883a 	mov	r2,zero
    920c:	dfc00a17 	ldw	ra,40(sp)
    9210:	df000917 	ldw	fp,36(sp)
    9214:	ddc00817 	ldw	r23,32(sp)
    9218:	dd800717 	ldw	r22,28(sp)
    921c:	dd400617 	ldw	r21,24(sp)
    9220:	dd000517 	ldw	r20,20(sp)
    9224:	dcc00417 	ldw	r19,16(sp)
    9228:	dc800317 	ldw	r18,12(sp)
    922c:	dc400217 	ldw	r17,8(sp)
    9230:	dc000117 	ldw	r16,4(sp)
    9234:	dec00b04 	addi	sp,sp,44
    9238:	f800283a 	ret
    923c:	a809883a 	mov	r4,r21
    9240:	800b883a 	mov	r5,r16
    9244:	0006d7c0 	call	6d7c <__swsetup_r>
    9248:	1000f01e 	bne	r2,zero,960c <__sfvwrite_r+0x4c8>
    924c:	8080030b 	ldhu	r2,12(r16)
    9250:	a4400017 	ldw	r17,0(r20)
    9254:	10c0008c 	andi	r3,r2,2
    9258:	18ffffcc 	andi	r3,r3,65535
    925c:	18e0001c 	xori	r3,r3,32768
    9260:	18e00004 	addi	r3,r3,-32768
    9264:	183fd51e 	bne	r3,zero,91bc <__sfvwrite_r+0x78>
    9268:	10c0004c 	andi	r3,r2,1
    926c:	002d883a 	mov	r22,zero
    9270:	1800381e 	bne	r3,zero,9354 <__sfvwrite_r+0x210>
    9274:	0025883a 	mov	r18,zero
    9278:	90002126 	beq	r18,zero,9300 <__sfvwrite_r+0x1bc>
    927c:	10c0800c 	andi	r3,r2,512
    9280:	18ffffcc 	andi	r3,r3,65535
    9284:	18e0001c 	xori	r3,r3,32768
    9288:	18e00004 	addi	r3,r3,-32768
    928c:	84c00217 	ldw	r19,8(r16)
    9290:	18006b26 	beq	r3,zero,9440 <__sfvwrite_r+0x2fc>
    9294:	980f883a 	mov	r7,r19
    9298:	94c08636 	bltu	r18,r19,94b4 <__sfvwrite_r+0x370>
    929c:	10c1200c 	andi	r3,r2,1152
    92a0:	18009f1e 	bne	r3,zero,9520 <__sfvwrite_r+0x3dc>
    92a4:	81000017 	ldw	r4,0(r16)
    92a8:	982f883a 	mov	r23,r19
    92ac:	9039883a 	mov	fp,r18
    92b0:	9027883a 	mov	r19,r18
    92b4:	380d883a 	mov	r6,r7
    92b8:	b00b883a 	mov	r5,r22
    92bc:	d9c00015 	stw	r7,0(sp)
    92c0:	000a2880 	call	a288 <memmove>
    92c4:	d9c00017 	ldw	r7,0(sp)
    92c8:	81000217 	ldw	r4,8(r16)
    92cc:	80800017 	ldw	r2,0(r16)
    92d0:	25efc83a 	sub	r23,r4,r23
    92d4:	11cf883a 	add	r7,r2,r7
    92d8:	85c00215 	stw	r23,8(r16)
    92dc:	81c00015 	stw	r7,0(r16)
    92e0:	a0800217 	ldw	r2,8(r20)
    92e4:	b72d883a 	add	r22,r22,fp
    92e8:	9725c83a 	sub	r18,r18,fp
    92ec:	14e7c83a 	sub	r19,r2,r19
    92f0:	a4c00215 	stw	r19,8(r20)
    92f4:	983fc426 	beq	r19,zero,9208 <__sfvwrite_r+0xc4>
    92f8:	8080030b 	ldhu	r2,12(r16)
    92fc:	903fdf1e 	bne	r18,zero,927c <__sfvwrite_r+0x138>
    9300:	8d800017 	ldw	r22,0(r17)
    9304:	8c800117 	ldw	r18,4(r17)
    9308:	8c400204 	addi	r17,r17,8
    930c:	003fda06 	br	9278 <__sfvwrite_r+0x134>
    9310:	8cc00017 	ldw	r19,0(r17)
    9314:	8c800117 	ldw	r18,4(r17)
    9318:	8c400204 	addi	r17,r17,8
    931c:	003faa06 	br	91c8 <__sfvwrite_r+0x84>
    9320:	000b5040 	call	b504 <_realloc_r>
    9324:	102f883a 	mov	r23,r2
    9328:	10009f1e 	bne	r2,zero,95a8 <__sfvwrite_r+0x464>
    932c:	81400417 	ldw	r5,16(r16)
    9330:	a809883a 	mov	r4,r21
    9334:	0008e740 	call	8e74 <_free_r>
    9338:	00800304 	movi	r2,12
    933c:	a8800015 	stw	r2,0(r21)
    9340:	80c0030b 	ldhu	r3,12(r16)
    9344:	00bfffc4 	movi	r2,-1
    9348:	18c01014 	ori	r3,r3,64
    934c:	80c0030d 	sth	r3,12(r16)
    9350:	003fae06 	br	920c <__sfvwrite_r+0xc8>
    9354:	0007883a 	mov	r3,zero
    9358:	0039883a 	mov	fp,zero
    935c:	0025883a 	mov	r18,zero
    9360:	90001e26 	beq	r18,zero,93dc <__sfvwrite_r+0x298>
    9364:	18006526 	beq	r3,zero,94fc <__sfvwrite_r+0x3b8>
    9368:	b02f883a 	mov	r23,r22
    936c:	9580012e 	bgeu	r18,r22,9374 <__sfvwrite_r+0x230>
    9370:	902f883a 	mov	r23,r18
    9374:	81000017 	ldw	r4,0(r16)
    9378:	80800417 	ldw	r2,16(r16)
    937c:	84c00217 	ldw	r19,8(r16)
    9380:	81c00517 	ldw	r7,20(r16)
    9384:	1100022e 	bgeu	r2,r4,9390 <__sfvwrite_r+0x24c>
    9388:	99e7883a 	add	r19,r19,r7
    938c:	9dc01816 	blt	r19,r23,93f0 <__sfvwrite_r+0x2ac>
    9390:	b9c03b16 	blt	r23,r7,9480 <__sfvwrite_r+0x33c>
    9394:	80800917 	ldw	r2,36(r16)
    9398:	81400717 	ldw	r5,28(r16)
    939c:	a809883a 	mov	r4,r21
    93a0:	d8c00015 	stw	r3,0(sp)
    93a4:	e00d883a 	mov	r6,fp
    93a8:	103ee83a 	callr	r2
    93ac:	1027883a 	mov	r19,r2
    93b0:	d8c00017 	ldw	r3,0(sp)
    93b4:	00bfe20e 	bge	zero,r2,9340 <__sfvwrite_r+0x1fc>
    93b8:	b4edc83a 	sub	r22,r22,r19
    93bc:	b0001a26 	beq	r22,zero,9428 <__sfvwrite_r+0x2e4>
    93c0:	a0800217 	ldw	r2,8(r20)
    93c4:	e4f9883a 	add	fp,fp,r19
    93c8:	94e5c83a 	sub	r18,r18,r19
    93cc:	14e7c83a 	sub	r19,r2,r19
    93d0:	a4c00215 	stw	r19,8(r20)
    93d4:	983f8c26 	beq	r19,zero,9208 <__sfvwrite_r+0xc4>
    93d8:	903fe21e 	bne	r18,zero,9364 <__sfvwrite_r+0x220>
    93dc:	8f000017 	ldw	fp,0(r17)
    93e0:	8c800117 	ldw	r18,4(r17)
    93e4:	0007883a 	mov	r3,zero
    93e8:	8c400204 	addi	r17,r17,8
    93ec:	003fdc06 	br	9360 <__sfvwrite_r+0x21c>
    93f0:	e00b883a 	mov	r5,fp
    93f4:	980d883a 	mov	r6,r19
    93f8:	d8c00015 	stw	r3,0(sp)
    93fc:	000a2880 	call	a288 <memmove>
    9400:	80800017 	ldw	r2,0(r16)
    9404:	a809883a 	mov	r4,r21
    9408:	800b883a 	mov	r5,r16
    940c:	14c5883a 	add	r2,r2,r19
    9410:	80800015 	stw	r2,0(r16)
    9414:	00087140 	call	8714 <_fflush_r>
    9418:	d8c00017 	ldw	r3,0(sp)
    941c:	103fc81e 	bne	r2,zero,9340 <__sfvwrite_r+0x1fc>
    9420:	b4edc83a 	sub	r22,r22,r19
    9424:	b03fe61e 	bne	r22,zero,93c0 <__sfvwrite_r+0x27c>
    9428:	a809883a 	mov	r4,r21
    942c:	800b883a 	mov	r5,r16
    9430:	00087140 	call	8714 <_fflush_r>
    9434:	103fc21e 	bne	r2,zero,9340 <__sfvwrite_r+0x1fc>
    9438:	0007883a 	mov	r3,zero
    943c:	003fe006 	br	93c0 <__sfvwrite_r+0x27c>
    9440:	81000017 	ldw	r4,0(r16)
    9444:	80800417 	ldw	r2,16(r16)
    9448:	1100022e 	bgeu	r2,r4,9454 <__sfvwrite_r+0x310>
    944c:	9839883a 	mov	fp,r19
    9450:	9c806036 	bltu	r19,r18,95d4 <__sfvwrite_r+0x490>
    9454:	81c00517 	ldw	r7,20(r16)
    9458:	91c01c36 	bltu	r18,r7,94cc <__sfvwrite_r+0x388>
    945c:	80800917 	ldw	r2,36(r16)
    9460:	81400717 	ldw	r5,28(r16)
    9464:	a809883a 	mov	r4,r21
    9468:	b00d883a 	mov	r6,r22
    946c:	103ee83a 	callr	r2
    9470:	1027883a 	mov	r19,r2
    9474:	00bfb20e 	bge	zero,r2,9340 <__sfvwrite_r+0x1fc>
    9478:	1039883a 	mov	fp,r2
    947c:	003f9806 	br	92e0 <__sfvwrite_r+0x19c>
    9480:	b80d883a 	mov	r6,r23
    9484:	e00b883a 	mov	r5,fp
    9488:	d8c00015 	stw	r3,0(sp)
    948c:	000a2880 	call	a288 <memmove>
    9490:	80800217 	ldw	r2,8(r16)
    9494:	81000017 	ldw	r4,0(r16)
    9498:	b827883a 	mov	r19,r23
    949c:	15c5c83a 	sub	r2,r2,r23
    94a0:	25ef883a 	add	r23,r4,r23
    94a4:	80800215 	stw	r2,8(r16)
    94a8:	85c00015 	stw	r23,0(r16)
    94ac:	d8c00017 	ldw	r3,0(sp)
    94b0:	003fc106 	br	93b8 <__sfvwrite_r+0x274>
    94b4:	81000017 	ldw	r4,0(r16)
    94b8:	902f883a 	mov	r23,r18
    94bc:	9039883a 	mov	fp,r18
    94c0:	9027883a 	mov	r19,r18
    94c4:	900f883a 	mov	r7,r18
    94c8:	003f7a06 	br	92b4 <__sfvwrite_r+0x170>
    94cc:	b00b883a 	mov	r5,r22
    94d0:	900d883a 	mov	r6,r18
    94d4:	000a2880 	call	a288 <memmove>
    94d8:	80c00217 	ldw	r3,8(r16)
    94dc:	80800017 	ldw	r2,0(r16)
    94e0:	9027883a 	mov	r19,r18
    94e4:	1c87c83a 	sub	r3,r3,r18
    94e8:	1485883a 	add	r2,r2,r18
    94ec:	80c00215 	stw	r3,8(r16)
    94f0:	80800015 	stw	r2,0(r16)
    94f4:	9039883a 	mov	fp,r18
    94f8:	003f7906 	br	92e0 <__sfvwrite_r+0x19c>
    94fc:	e009883a 	mov	r4,fp
    9500:	01400284 	movi	r5,10
    9504:	900d883a 	mov	r6,r18
    9508:	000a1900 	call	a190 <memchr>
    950c:	10003c26 	beq	r2,zero,9600 <__sfvwrite_r+0x4bc>
    9510:	15800044 	addi	r22,r2,1
    9514:	b72dc83a 	sub	r22,r22,fp
    9518:	00c00044 	movi	r3,1
    951c:	003f9206 	br	9368 <__sfvwrite_r+0x224>
    9520:	81000517 	ldw	r4,20(r16)
    9524:	81400417 	ldw	r5,16(r16)
    9528:	80c00017 	ldw	r3,0(r16)
    952c:	210d883a 	add	r6,r4,r4
    9530:	3109883a 	add	r4,r6,r4
    9534:	2026d7fa 	srli	r19,r4,31
    9538:	1979c83a 	sub	fp,r3,r5
    953c:	e1800044 	addi	r6,fp,1
    9540:	9909883a 	add	r4,r19,r4
    9544:	2027d07a 	srai	r19,r4,1
    9548:	3489883a 	add	r4,r6,r18
    954c:	980d883a 	mov	r6,r19
    9550:	9900022e 	bgeu	r19,r4,955c <__sfvwrite_r+0x418>
    9554:	2027883a 	mov	r19,r4
    9558:	200d883a 	mov	r6,r4
    955c:	1081000c 	andi	r2,r2,1024
    9560:	10bfffcc 	andi	r2,r2,65535
    9564:	10a0001c 	xori	r2,r2,32768
    9568:	10a00004 	addi	r2,r2,-32768
    956c:	a809883a 	mov	r4,r21
    9570:	103f6b26 	beq	r2,zero,9320 <__sfvwrite_r+0x1dc>
    9574:	300b883a 	mov	r5,r6
    9578:	0009a0c0 	call	9a0c <_malloc_r>
    957c:	102f883a 	mov	r23,r2
    9580:	103f6d26 	beq	r2,zero,9338 <__sfvwrite_r+0x1f4>
    9584:	81400417 	ldw	r5,16(r16)
    9588:	1009883a 	mov	r4,r2
    958c:	e00d883a 	mov	r6,fp
    9590:	00041f00 	call	41f0 <memcpy>
    9594:	8080030b 	ldhu	r2,12(r16)
    9598:	00fedfc4 	movi	r3,-1153
    959c:	10c4703a 	and	r2,r2,r3
    95a0:	10802014 	ori	r2,r2,128
    95a4:	8080030d 	sth	r2,12(r16)
    95a8:	bf09883a 	add	r4,r23,fp
    95ac:	9f07c83a 	sub	r3,r19,fp
    95b0:	85c00415 	stw	r23,16(r16)
    95b4:	84c00515 	stw	r19,20(r16)
    95b8:	81000015 	stw	r4,0(r16)
    95bc:	902f883a 	mov	r23,r18
    95c0:	80c00215 	stw	r3,8(r16)
    95c4:	9039883a 	mov	fp,r18
    95c8:	9027883a 	mov	r19,r18
    95cc:	900f883a 	mov	r7,r18
    95d0:	003f3806 	br	92b4 <__sfvwrite_r+0x170>
    95d4:	b00b883a 	mov	r5,r22
    95d8:	980d883a 	mov	r6,r19
    95dc:	000a2880 	call	a288 <memmove>
    95e0:	80800017 	ldw	r2,0(r16)
    95e4:	a809883a 	mov	r4,r21
    95e8:	800b883a 	mov	r5,r16
    95ec:	14c5883a 	add	r2,r2,r19
    95f0:	80800015 	stw	r2,0(r16)
    95f4:	00087140 	call	8714 <_fflush_r>
    95f8:	103f3926 	beq	r2,zero,92e0 <__sfvwrite_r+0x19c>
    95fc:	003f5006 	br	9340 <__sfvwrite_r+0x1fc>
    9600:	95800044 	addi	r22,r18,1
    9604:	00c00044 	movi	r3,1
    9608:	003f5706 	br	9368 <__sfvwrite_r+0x224>
    960c:	80c0030b 	ldhu	r3,12(r16)
    9610:	00bfffc4 	movi	r2,-1
    9614:	18c01014 	ori	r3,r3,64
    9618:	80c0030d 	sth	r3,12(r16)
    961c:	00c00244 	movi	r3,9
    9620:	a8c00015 	stw	r3,0(r21)
    9624:	003ef906 	br	920c <__sfvwrite_r+0xc8>

00009628 <_fwalk>:
    9628:	defff904 	addi	sp,sp,-28
    962c:	dcc00315 	stw	r19,12(sp)
    9630:	24c0b804 	addi	r19,r4,736
    9634:	dd400515 	stw	r21,20(sp)
    9638:	dd000415 	stw	r20,16(sp)
    963c:	dfc00615 	stw	ra,24(sp)
    9640:	dc800215 	stw	r18,8(sp)
    9644:	dc400115 	stw	r17,4(sp)
    9648:	dc000015 	stw	r16,0(sp)
    964c:	282b883a 	mov	r21,r5
    9650:	0029883a 	mov	r20,zero
    9654:	0008bc40 	call	8bc4 <__sfp_lock_acquire>
    9658:	98001226 	beq	r19,zero,96a4 <_fwalk+0x7c>
    965c:	04bfffc4 	movi	r18,-1
    9660:	9c400117 	ldw	r17,4(r19)
    9664:	9c000217 	ldw	r16,8(r19)
    9668:	8c7fffc4 	addi	r17,r17,-1
    966c:	88000b16 	blt	r17,zero,969c <_fwalk+0x74>
    9670:	84000304 	addi	r16,r16,12
    9674:	80c0000f 	ldh	r3,0(r16)
    9678:	8c7fffc4 	addi	r17,r17,-1
    967c:	813ffd04 	addi	r4,r16,-12
    9680:	18000426 	beq	r3,zero,9694 <_fwalk+0x6c>
    9684:	80c0008f 	ldh	r3,2(r16)
    9688:	1c800226 	beq	r3,r18,9694 <_fwalk+0x6c>
    968c:	a83ee83a 	callr	r21
    9690:	a0a8b03a 	or	r20,r20,r2
    9694:	84001704 	addi	r16,r16,92
    9698:	8cbff61e 	bne	r17,r18,9674 <_fwalk+0x4c>
    969c:	9cc00017 	ldw	r19,0(r19)
    96a0:	983fef1e 	bne	r19,zero,9660 <_fwalk+0x38>
    96a4:	0008bc80 	call	8bc8 <__sfp_lock_release>
    96a8:	a005883a 	mov	r2,r20
    96ac:	dfc00617 	ldw	ra,24(sp)
    96b0:	dd400517 	ldw	r21,20(sp)
    96b4:	dd000417 	ldw	r20,16(sp)
    96b8:	dcc00317 	ldw	r19,12(sp)
    96bc:	dc800217 	ldw	r18,8(sp)
    96c0:	dc400117 	ldw	r17,4(sp)
    96c4:	dc000017 	ldw	r16,0(sp)
    96c8:	dec00704 	addi	sp,sp,28
    96cc:	f800283a 	ret

000096d0 <_fwalk_reent>:
    96d0:	defff804 	addi	sp,sp,-32
    96d4:	dcc00315 	stw	r19,12(sp)
    96d8:	24c0b804 	addi	r19,r4,736
    96dc:	dd800615 	stw	r22,24(sp)
    96e0:	dd400515 	stw	r21,20(sp)
    96e4:	dd000415 	stw	r20,16(sp)
    96e8:	dfc00715 	stw	ra,28(sp)
    96ec:	dc800215 	stw	r18,8(sp)
    96f0:	dc400115 	stw	r17,4(sp)
    96f4:	dc000015 	stw	r16,0(sp)
    96f8:	2029883a 	mov	r20,r4
    96fc:	282b883a 	mov	r21,r5
    9700:	002d883a 	mov	r22,zero
    9704:	0008bc40 	call	8bc4 <__sfp_lock_acquire>
    9708:	98001326 	beq	r19,zero,9758 <_fwalk_reent+0x88>
    970c:	04bfffc4 	movi	r18,-1
    9710:	9c400117 	ldw	r17,4(r19)
    9714:	9c000217 	ldw	r16,8(r19)
    9718:	8c7fffc4 	addi	r17,r17,-1
    971c:	88000c16 	blt	r17,zero,9750 <_fwalk_reent+0x80>
    9720:	84000304 	addi	r16,r16,12
    9724:	80c0000f 	ldh	r3,0(r16)
    9728:	8c7fffc4 	addi	r17,r17,-1
    972c:	817ffd04 	addi	r5,r16,-12
    9730:	18000526 	beq	r3,zero,9748 <_fwalk_reent+0x78>
    9734:	80c0008f 	ldh	r3,2(r16)
    9738:	a009883a 	mov	r4,r20
    973c:	1c800226 	beq	r3,r18,9748 <_fwalk_reent+0x78>
    9740:	a83ee83a 	callr	r21
    9744:	b0acb03a 	or	r22,r22,r2
    9748:	84001704 	addi	r16,r16,92
    974c:	8cbff51e 	bne	r17,r18,9724 <_fwalk_reent+0x54>
    9750:	9cc00017 	ldw	r19,0(r19)
    9754:	983fee1e 	bne	r19,zero,9710 <_fwalk_reent+0x40>
    9758:	0008bc80 	call	8bc8 <__sfp_lock_release>
    975c:	b005883a 	mov	r2,r22
    9760:	dfc00717 	ldw	ra,28(sp)
    9764:	dd800617 	ldw	r22,24(sp)
    9768:	dd400517 	ldw	r21,20(sp)
    976c:	dd000417 	ldw	r20,16(sp)
    9770:	dcc00317 	ldw	r19,12(sp)
    9774:	dc800217 	ldw	r18,8(sp)
    9778:	dc400117 	ldw	r17,4(sp)
    977c:	dc000017 	ldw	r16,0(sp)
    9780:	dec00804 	addi	sp,sp,32
    9784:	f800283a 	ret

00009788 <_setlocale_r>:
    9788:	defffc04 	addi	sp,sp,-16
    978c:	dc800215 	stw	r18,8(sp)
    9790:	dc400115 	stw	r17,4(sp)
    9794:	dc000015 	stw	r16,0(sp)
    9798:	dfc00315 	stw	ra,12(sp)
    979c:	3021883a 	mov	r16,r6
    97a0:	2023883a 	mov	r17,r4
    97a4:	2825883a 	mov	r18,r5
    97a8:	30001626 	beq	r6,zero,9804 <_setlocale_r+0x7c>
    97ac:	3009883a 	mov	r4,r6
    97b0:	01400134 	movhi	r5,4
    97b4:	2941c504 	addi	r5,r5,1812
    97b8:	000bd080 	call	bd08 <strcmp>
    97bc:	10000a1e 	bne	r2,zero,97e8 <_setlocale_r+0x60>
    97c0:	8c800c15 	stw	r18,48(r17)
    97c4:	8c000d15 	stw	r16,52(r17)
    97c8:	00800134 	movhi	r2,4
    97cc:	1081c504 	addi	r2,r2,1812
    97d0:	dfc00317 	ldw	ra,12(sp)
    97d4:	dc800217 	ldw	r18,8(sp)
    97d8:	dc400117 	ldw	r17,4(sp)
    97dc:	dc000017 	ldw	r16,0(sp)
    97e0:	dec00404 	addi	sp,sp,16
    97e4:	f800283a 	ret
    97e8:	8009883a 	mov	r4,r16
    97ec:	01400134 	movhi	r5,4
    97f0:	2941b004 	addi	r5,r5,1728
    97f4:	000bd080 	call	bd08 <strcmp>
    97f8:	103ff126 	beq	r2,zero,97c0 <_setlocale_r+0x38>
    97fc:	0005883a 	mov	r2,zero
    9800:	003ff306 	br	97d0 <_setlocale_r+0x48>
    9804:	00800134 	movhi	r2,4
    9808:	1081c504 	addi	r2,r2,1812
    980c:	dfc00317 	ldw	ra,12(sp)
    9810:	dc800217 	ldw	r18,8(sp)
    9814:	dc400117 	ldw	r17,4(sp)
    9818:	dc000017 	ldw	r16,0(sp)
    981c:	dec00404 	addi	sp,sp,16
    9820:	f800283a 	ret

00009824 <__locale_charset>:
    9824:	00800134 	movhi	r2,4
    9828:	1081c604 	addi	r2,r2,1816
    982c:	f800283a 	ret

00009830 <_localeconv_r>:
    9830:	00800134 	movhi	r2,4
    9834:	1081ca04 	addi	r2,r2,1832
    9838:	f800283a 	ret

0000983c <setlocale>:
    983c:	00c00134 	movhi	r3,4
    9840:	18d5bf04 	addi	r3,r3,22268
    9844:	2005883a 	mov	r2,r4
    9848:	19000017 	ldw	r4,0(r3)
    984c:	280d883a 	mov	r6,r5
    9850:	100b883a 	mov	r5,r2
    9854:	00097881 	jmpi	9788 <_setlocale_r>

00009858 <localeconv>:
    9858:	00800134 	movhi	r2,4
    985c:	1081ca04 	addi	r2,r2,1832
    9860:	f800283a 	ret

00009864 <__smakebuf_r>:
    9864:	2880030b 	ldhu	r2,12(r5)
    9868:	deffed04 	addi	sp,sp,-76
    986c:	dc401015 	stw	r17,64(sp)
    9870:	10c0008c 	andi	r3,r2,2
    9874:	18ffffcc 	andi	r3,r3,65535
    9878:	18e0001c 	xori	r3,r3,32768
    987c:	dc000f15 	stw	r16,60(sp)
    9880:	dfc01215 	stw	ra,72(sp)
    9884:	dc801115 	stw	r18,68(sp)
    9888:	18e00004 	addi	r3,r3,-32768
    988c:	2821883a 	mov	r16,r5
    9890:	2023883a 	mov	r17,r4
    9894:	1800381e 	bne	r3,zero,9978 <__smakebuf_r+0x114>
    9898:	2940038f 	ldh	r5,14(r5)
    989c:	28002d16 	blt	r5,zero,9954 <__smakebuf_r+0xf0>
    98a0:	d80d883a 	mov	r6,sp
    98a4:	000c1e00 	call	c1e0 <_fstat_r>
    98a8:	10002916 	blt	r2,zero,9950 <__smakebuf_r+0xec>
    98ac:	d8800117 	ldw	r2,4(sp)
    98b0:	00e00014 	movui	r3,32768
    98b4:	10bc000c 	andi	r2,r2,61440
    98b8:	10c03c26 	beq	r2,r3,99ac <__smakebuf_r+0x148>
    98bc:	80c0030b 	ldhu	r3,12(r16)
    98c0:	18c20014 	ori	r3,r3,2048
    98c4:	80c0030d 	sth	r3,12(r16)
    98c8:	00c80004 	movi	r3,8192
    98cc:	10c00c1e 	bne	r2,r3,9900 <__smakebuf_r+0x9c>
    98d0:	8140038f 	ldh	r5,14(r16)
    98d4:	8809883a 	mov	r4,r17
    98d8:	000c2480 	call	c248 <_isatty_r>
    98dc:	10000826 	beq	r2,zero,9900 <__smakebuf_r+0x9c>
    98e0:	80c0030b 	ldhu	r3,12(r16)
    98e4:	808010c4 	addi	r2,r16,67
    98e8:	80800015 	stw	r2,0(r16)
    98ec:	18c00054 	ori	r3,r3,1
    98f0:	80800415 	stw	r2,16(r16)
    98f4:	00800044 	movi	r2,1
    98f8:	80c0030d 	sth	r3,12(r16)
    98fc:	80800515 	stw	r2,20(r16)
    9900:	04810004 	movi	r18,1024
    9904:	8809883a 	mov	r4,r17
    9908:	900b883a 	mov	r5,r18
    990c:	0009a0c0 	call	9a0c <_malloc_r>
    9910:	10003026 	beq	r2,zero,99d4 <__smakebuf_r+0x170>
    9914:	80c0030b 	ldhu	r3,12(r16)
    9918:	01000074 	movhi	r4,1
    991c:	21224f04 	addi	r4,r4,-30404
    9920:	89000f15 	stw	r4,60(r17)
    9924:	18c02014 	ori	r3,r3,128
    9928:	80c0030d 	sth	r3,12(r16)
    992c:	80800015 	stw	r2,0(r16)
    9930:	80800415 	stw	r2,16(r16)
    9934:	84800515 	stw	r18,20(r16)
    9938:	dfc01217 	ldw	ra,72(sp)
    993c:	dc801117 	ldw	r18,68(sp)
    9940:	dc401017 	ldw	r17,64(sp)
    9944:	dc000f17 	ldw	r16,60(sp)
    9948:	dec01304 	addi	sp,sp,76
    994c:	f800283a 	ret
    9950:	8080030b 	ldhu	r2,12(r16)
    9954:	10c0200c 	andi	r3,r2,128
    9958:	18ffffcc 	andi	r3,r3,65535
    995c:	18e0001c 	xori	r3,r3,32768
    9960:	18e00004 	addi	r3,r3,-32768
    9964:	18000f1e 	bne	r3,zero,99a4 <__smakebuf_r+0x140>
    9968:	04810004 	movi	r18,1024
    996c:	10820014 	ori	r2,r2,2048
    9970:	8080030d 	sth	r2,12(r16)
    9974:	003fe306 	br	9904 <__smakebuf_r+0xa0>
    9978:	288010c4 	addi	r2,r5,67
    997c:	28800015 	stw	r2,0(r5)
    9980:	28800415 	stw	r2,16(r5)
    9984:	00800044 	movi	r2,1
    9988:	28800515 	stw	r2,20(r5)
    998c:	dfc01217 	ldw	ra,72(sp)
    9990:	dc801117 	ldw	r18,68(sp)
    9994:	dc401017 	ldw	r17,64(sp)
    9998:	dc000f17 	ldw	r16,60(sp)
    999c:	dec01304 	addi	sp,sp,76
    99a0:	f800283a 	ret
    99a4:	04801004 	movi	r18,64
    99a8:	003ff006 	br	996c <__smakebuf_r+0x108>
    99ac:	81000a17 	ldw	r4,40(r16)
    99b0:	00c00074 	movhi	r3,1
    99b4:	18ef2904 	addi	r3,r3,-17244
    99b8:	20ffc01e 	bne	r4,r3,98bc <__smakebuf_r+0x58>
    99bc:	8080030b 	ldhu	r2,12(r16)
    99c0:	00c10004 	movi	r3,1024
    99c4:	80c01315 	stw	r3,76(r16)
    99c8:	10c4b03a 	or	r2,r2,r3
    99cc:	8080030d 	sth	r2,12(r16)
    99d0:	003fcb06 	br	9900 <__smakebuf_r+0x9c>
    99d4:	8080030b 	ldhu	r2,12(r16)
    99d8:	10c0800c 	andi	r3,r2,512
    99dc:	18ffffcc 	andi	r3,r3,65535
    99e0:	18e0001c 	xori	r3,r3,32768
    99e4:	18e00004 	addi	r3,r3,-32768
    99e8:	183fd31e 	bne	r3,zero,9938 <__smakebuf_r+0xd4>
    99ec:	10800094 	ori	r2,r2,2
    99f0:	80c010c4 	addi	r3,r16,67
    99f4:	8080030d 	sth	r2,12(r16)
    99f8:	00800044 	movi	r2,1
    99fc:	80c00015 	stw	r3,0(r16)
    9a00:	80c00415 	stw	r3,16(r16)
    9a04:	80800515 	stw	r2,20(r16)
    9a08:	003fcb06 	br	9938 <__smakebuf_r+0xd4>

00009a0c <_malloc_r>:
    9a0c:	defff604 	addi	sp,sp,-40
    9a10:	dc800215 	stw	r18,8(sp)
    9a14:	dfc00915 	stw	ra,36(sp)
    9a18:	df000815 	stw	fp,32(sp)
    9a1c:	ddc00715 	stw	r23,28(sp)
    9a20:	dd800615 	stw	r22,24(sp)
    9a24:	dd400515 	stw	r21,20(sp)
    9a28:	dd000415 	stw	r20,16(sp)
    9a2c:	dcc00315 	stw	r19,12(sp)
    9a30:	dc400115 	stw	r17,4(sp)
    9a34:	dc000015 	stw	r16,0(sp)
    9a38:	288002c4 	addi	r2,r5,11
    9a3c:	00c00584 	movi	r3,22
    9a40:	2025883a 	mov	r18,r4
    9a44:	18802b2e 	bgeu	r3,r2,9af4 <_malloc_r+0xe8>
    9a48:	047ffe04 	movi	r17,-8
    9a4c:	1462703a 	and	r17,r2,r17
    9a50:	88002a16 	blt	r17,zero,9afc <_malloc_r+0xf0>
    9a54:	89402936 	bltu	r17,r5,9afc <_malloc_r+0xf0>
    9a58:	9009883a 	mov	r4,r18
    9a5c:	000e3f40 	call	e3f4 <__malloc_lock>
    9a60:	00807dc4 	movi	r2,503
    9a64:	14402936 	bltu	r2,r17,9b0c <_malloc_r+0x100>
    9a68:	8808d0fa 	srli	r4,r17,3
    9a6c:	04c00134 	movhi	r19,4
    9a70:	9cce4f04 	addi	r19,r19,14652
    9a74:	2105883a 	add	r2,r4,r4
    9a78:	1085883a 	add	r2,r2,r2
    9a7c:	1085883a 	add	r2,r2,r2
    9a80:	9885883a 	add	r2,r19,r2
    9a84:	14000317 	ldw	r16,12(r2)
    9a88:	80815526 	beq	r16,r2,9fe0 <_malloc_r+0x5d4>
    9a8c:	81000117 	ldw	r4,4(r16)
    9a90:	00bfff04 	movi	r2,-4
    9a94:	80c00317 	ldw	r3,12(r16)
    9a98:	2084703a 	and	r2,r4,r2
    9a9c:	8085883a 	add	r2,r16,r2
    9aa0:	11800117 	ldw	r6,4(r2)
    9aa4:	81400217 	ldw	r5,8(r16)
    9aa8:	9009883a 	mov	r4,r18
    9aac:	31800054 	ori	r6,r6,1
    9ab0:	11800115 	stw	r6,4(r2)
    9ab4:	28c00315 	stw	r3,12(r5)
    9ab8:	19400215 	stw	r5,8(r3)
    9abc:	000e4540 	call	e454 <__malloc_unlock>
    9ac0:	80800204 	addi	r2,r16,8
    9ac4:	dfc00917 	ldw	ra,36(sp)
    9ac8:	df000817 	ldw	fp,32(sp)
    9acc:	ddc00717 	ldw	r23,28(sp)
    9ad0:	dd800617 	ldw	r22,24(sp)
    9ad4:	dd400517 	ldw	r21,20(sp)
    9ad8:	dd000417 	ldw	r20,16(sp)
    9adc:	dcc00317 	ldw	r19,12(sp)
    9ae0:	dc800217 	ldw	r18,8(sp)
    9ae4:	dc400117 	ldw	r17,4(sp)
    9ae8:	dc000017 	ldw	r16,0(sp)
    9aec:	dec00a04 	addi	sp,sp,40
    9af0:	f800283a 	ret
    9af4:	04400404 	movi	r17,16
    9af8:	897fd72e 	bgeu	r17,r5,9a58 <_malloc_r+0x4c>
    9afc:	00800304 	movi	r2,12
    9b00:	90800015 	stw	r2,0(r18)
    9b04:	0005883a 	mov	r2,zero
    9b08:	003fee06 	br	9ac4 <_malloc_r+0xb8>
    9b0c:	8808d27a 	srli	r4,r17,9
    9b10:	20007126 	beq	r4,zero,9cd8 <_malloc_r+0x2cc>
    9b14:	00800104 	movi	r2,4
    9b18:	1100eb36 	bltu	r2,r4,9ec8 <_malloc_r+0x4bc>
    9b1c:	8808d1ba 	srli	r4,r17,6
    9b20:	21000e04 	addi	r4,r4,56
    9b24:	210b883a 	add	r5,r4,r4
    9b28:	294b883a 	add	r5,r5,r5
    9b2c:	294b883a 	add	r5,r5,r5
    9b30:	04c00134 	movhi	r19,4
    9b34:	9cce4f04 	addi	r19,r19,14652
    9b38:	994b883a 	add	r5,r19,r5
    9b3c:	2c000317 	ldw	r16,12(r5)
    9b40:	2c000e26 	beq	r5,r16,9b7c <_malloc_r+0x170>
    9b44:	80c00117 	ldw	r3,4(r16)
    9b48:	01ffff04 	movi	r7,-4
    9b4c:	018003c4 	movi	r6,15
    9b50:	19c6703a 	and	r3,r3,r7
    9b54:	1c45c83a 	sub	r2,r3,r17
    9b58:	30800716 	blt	r6,r2,9b78 <_malloc_r+0x16c>
    9b5c:	1000610e 	bge	r2,zero,9ce4 <_malloc_r+0x2d8>
    9b60:	84000317 	ldw	r16,12(r16)
    9b64:	2c000526 	beq	r5,r16,9b7c <_malloc_r+0x170>
    9b68:	80c00117 	ldw	r3,4(r16)
    9b6c:	19c6703a 	and	r3,r3,r7
    9b70:	1c45c83a 	sub	r2,r3,r17
    9b74:	30bff90e 	bge	r6,r2,9b5c <_malloc_r+0x150>
    9b78:	213fffc4 	addi	r4,r4,-1
    9b7c:	21000044 	addi	r4,r4,1
    9b80:	9c000417 	ldw	r16,16(r19)
    9b84:	00c00134 	movhi	r3,4
    9b88:	18ce4f04 	addi	r3,r3,14652
    9b8c:	1a400204 	addi	r9,r3,8
    9b90:	8240ff26 	beq	r16,r9,9f90 <_malloc_r+0x584>
    9b94:	81400117 	ldw	r5,4(r16)
    9b98:	00bfff04 	movi	r2,-4
    9b9c:	018003c4 	movi	r6,15
    9ba0:	2884703a 	and	r2,r5,r2
    9ba4:	144bc83a 	sub	r5,r2,r17
    9ba8:	3140ea16 	blt	r6,r5,9f54 <_malloc_r+0x548>
    9bac:	1a400515 	stw	r9,20(r3)
    9bb0:	1a400415 	stw	r9,16(r3)
    9bb4:	2800570e 	bge	r5,zero,9d14 <_malloc_r+0x308>
    9bb8:	01407fc4 	movi	r5,511
    9bbc:	2880ca36 	bltu	r5,r2,9ee8 <_malloc_r+0x4dc>
    9bc0:	1004d0fa 	srli	r2,r2,3
    9bc4:	02000044 	movi	r8,1
    9bc8:	19c00117 	ldw	r7,4(r3)
    9bcc:	108b883a 	add	r5,r2,r2
    9bd0:	294b883a 	add	r5,r5,r5
    9bd4:	1005d0ba 	srai	r2,r2,2
    9bd8:	294b883a 	add	r5,r5,r5
    9bdc:	28cb883a 	add	r5,r5,r3
    9be0:	29800217 	ldw	r6,8(r5)
    9be4:	4084983a 	sll	r2,r8,r2
    9be8:	81400315 	stw	r5,12(r16)
    9bec:	81800215 	stw	r6,8(r16)
    9bf0:	11c4b03a 	or	r2,r2,r7
    9bf4:	18800115 	stw	r2,4(r3)
    9bf8:	2c000215 	stw	r16,8(r5)
    9bfc:	34000315 	stw	r16,12(r6)
    9c00:	200bd0ba 	srai	r5,r4,2
    9c04:	00c00044 	movi	r3,1
    9c08:	194a983a 	sll	r5,r3,r5
    9c0c:	11404936 	bltu	r2,r5,9d34 <_malloc_r+0x328>
    9c10:	1146703a 	and	r3,r2,r5
    9c14:	18000a1e 	bne	r3,zero,9c40 <_malloc_r+0x234>
    9c18:	00ffff04 	movi	r3,-4
    9c1c:	294b883a 	add	r5,r5,r5
    9c20:	20c8703a 	and	r4,r4,r3
    9c24:	1146703a 	and	r3,r2,r5
    9c28:	21000104 	addi	r4,r4,4
    9c2c:	1800041e 	bne	r3,zero,9c40 <_malloc_r+0x234>
    9c30:	294b883a 	add	r5,r5,r5
    9c34:	1146703a 	and	r3,r2,r5
    9c38:	21000104 	addi	r4,r4,4
    9c3c:	183ffc26 	beq	r3,zero,9c30 <_malloc_r+0x224>
    9c40:	023fff04 	movi	r8,-4
    9c44:	01c003c4 	movi	r7,15
    9c48:	2105883a 	add	r2,r4,r4
    9c4c:	1085883a 	add	r2,r2,r2
    9c50:	1085883a 	add	r2,r2,r2
    9c54:	9899883a 	add	r12,r19,r2
    9c58:	62800304 	addi	r10,r12,12
    9c5c:	2017883a 	mov	r11,r4
    9c60:	54000017 	ldw	r16,0(r10)
    9c64:	51bffd04 	addi	r6,r10,-12
    9c68:	8180041e 	bne	r16,r6,9c7c <_malloc_r+0x270>
    9c6c:	0000ca06 	br	9f98 <_malloc_r+0x58c>
    9c70:	10001c0e 	bge	r2,zero,9ce4 <_malloc_r+0x2d8>
    9c74:	84000317 	ldw	r16,12(r16)
    9c78:	8180c726 	beq	r16,r6,9f98 <_malloc_r+0x58c>
    9c7c:	80c00117 	ldw	r3,4(r16)
    9c80:	1a06703a 	and	r3,r3,r8
    9c84:	1c45c83a 	sub	r2,r3,r17
    9c88:	38bff90e 	bge	r7,r2,9c70 <_malloc_r+0x264>
    9c8c:	81000317 	ldw	r4,12(r16)
    9c90:	81400217 	ldw	r5,8(r16)
    9c94:	8447883a 	add	r3,r16,r17
    9c98:	8c400054 	ori	r17,r17,1
    9c9c:	29000315 	stw	r4,12(r5)
    9ca0:	21400215 	stw	r5,8(r4)
    9ca4:	84400115 	stw	r17,4(r16)
    9ca8:	1889883a 	add	r4,r3,r2
    9cac:	11400054 	ori	r5,r2,1
    9cb0:	98c00515 	stw	r3,20(r19)
    9cb4:	98c00415 	stw	r3,16(r19)
    9cb8:	20800015 	stw	r2,0(r4)
    9cbc:	1a400315 	stw	r9,12(r3)
    9cc0:	1a400215 	stw	r9,8(r3)
    9cc4:	19400115 	stw	r5,4(r3)
    9cc8:	9009883a 	mov	r4,r18
    9ccc:	000e4540 	call	e454 <__malloc_unlock>
    9cd0:	80800204 	addi	r2,r16,8
    9cd4:	003f7b06 	br	9ac4 <_malloc_r+0xb8>
    9cd8:	8808d0fa 	srli	r4,r17,3
    9cdc:	210b883a 	add	r5,r4,r4
    9ce0:	003f9106 	br	9b28 <_malloc_r+0x11c>
    9ce4:	80c7883a 	add	r3,r16,r3
    9ce8:	19400117 	ldw	r5,4(r3)
    9cec:	80800317 	ldw	r2,12(r16)
    9cf0:	81000217 	ldw	r4,8(r16)
    9cf4:	29400054 	ori	r5,r5,1
    9cf8:	19400115 	stw	r5,4(r3)
    9cfc:	20800315 	stw	r2,12(r4)
    9d00:	11000215 	stw	r4,8(r2)
    9d04:	9009883a 	mov	r4,r18
    9d08:	000e4540 	call	e454 <__malloc_unlock>
    9d0c:	80800204 	addi	r2,r16,8
    9d10:	003f6c06 	br	9ac4 <_malloc_r+0xb8>
    9d14:	8085883a 	add	r2,r16,r2
    9d18:	10c00117 	ldw	r3,4(r2)
    9d1c:	9009883a 	mov	r4,r18
    9d20:	18c00054 	ori	r3,r3,1
    9d24:	10c00115 	stw	r3,4(r2)
    9d28:	000e4540 	call	e454 <__malloc_unlock>
    9d2c:	80800204 	addi	r2,r16,8
    9d30:	003f6406 	br	9ac4 <_malloc_r+0xb8>
    9d34:	9c000217 	ldw	r16,8(r19)
    9d38:	00bfff04 	movi	r2,-4
    9d3c:	85400117 	ldw	r21,4(r16)
    9d40:	a8aa703a 	and	r21,r21,r2
    9d44:	ac400336 	bltu	r21,r17,9d54 <_malloc_r+0x348>
    9d48:	ac45c83a 	sub	r2,r21,r17
    9d4c:	00c003c4 	movi	r3,15
    9d50:	18805316 	blt	r3,r2,9ea0 <_malloc_r+0x494>
    9d54:	d5e90117 	ldw	r23,-23548(gp)
    9d58:	d0e00517 	ldw	r3,-32748(gp)
    9d5c:	00bfffc4 	movi	r2,-1
    9d60:	8579883a 	add	fp,r16,r21
    9d64:	8def883a 	add	r23,r17,r23
    9d68:	1880d226 	beq	r3,r2,a0b4 <_malloc_r+0x6a8>
    9d6c:	bdc403c4 	addi	r23,r23,4111
    9d70:	00bc0004 	movi	r2,-4096
    9d74:	b8ae703a 	and	r23,r23,r2
    9d78:	9009883a 	mov	r4,r18
    9d7c:	b80b883a 	mov	r5,r23
    9d80:	000bb640 	call	bb64 <_sbrk_r>
    9d84:	1029883a 	mov	r20,r2
    9d88:	00bfffc4 	movi	r2,-1
    9d8c:	a080d126 	beq	r20,r2,a0d4 <_malloc_r+0x6c8>
    9d90:	a7009f36 	bltu	r20,fp,a010 <_malloc_r+0x604>
    9d94:	05800134 	movhi	r22,4
    9d98:	b59f1404 	addi	r22,r22,31824
    9d9c:	b0800017 	ldw	r2,0(r22)
    9da0:	b885883a 	add	r2,r23,r2
    9da4:	b0800015 	stw	r2,0(r22)
    9da8:	e500cf26 	beq	fp,r20,a0e8 <_malloc_r+0x6dc>
    9dac:	d1200517 	ldw	r4,-32748(gp)
    9db0:	00ffffc4 	movi	r3,-1
    9db4:	20c0e026 	beq	r4,r3,a138 <_malloc_r+0x72c>
    9db8:	a739c83a 	sub	fp,r20,fp
    9dbc:	1705883a 	add	r2,r2,fp
    9dc0:	b0800015 	stw	r2,0(r22)
    9dc4:	a08001cc 	andi	r2,r20,7
    9dc8:	1000a526 	beq	r2,zero,a060 <_malloc_r+0x654>
    9dcc:	a0a9c83a 	sub	r20,r20,r2
    9dd0:	00c40204 	movi	r3,4104
    9dd4:	a5000204 	addi	r20,r20,8
    9dd8:	1885c83a 	sub	r2,r3,r2
    9ddc:	a5c7883a 	add	r3,r20,r23
    9de0:	18c3ffcc 	andi	r3,r3,4095
    9de4:	10efc83a 	sub	r23,r2,r3
    9de8:	9009883a 	mov	r4,r18
    9dec:	b80b883a 	mov	r5,r23
    9df0:	000bb640 	call	bb64 <_sbrk_r>
    9df4:	00ffffc4 	movi	r3,-1
    9df8:	10c0cc26 	beq	r2,r3,a12c <_malloc_r+0x720>
    9dfc:	1505c83a 	sub	r2,r2,r20
    9e00:	b887883a 	add	r3,r23,r2
    9e04:	18c00054 	ori	r3,r3,1
    9e08:	b0800017 	ldw	r2,0(r22)
    9e0c:	9d000215 	stw	r20,8(r19)
    9e10:	a0c00115 	stw	r3,4(r20)
    9e14:	b885883a 	add	r2,r23,r2
    9e18:	b0800015 	stw	r2,0(r22)
    9e1c:	84c00e26 	beq	r16,r19,9e58 <_malloc_r+0x44c>
    9e20:	00c003c4 	movi	r3,15
    9e24:	1d40902e 	bgeu	r3,r21,a068 <_malloc_r+0x65c>
    9e28:	ad7ffd04 	addi	r21,r21,-12
    9e2c:	013ffe04 	movi	r4,-8
    9e30:	a908703a 	and	r4,r21,r4
    9e34:	810b883a 	add	r5,r16,r4
    9e38:	01800144 	movi	r6,5
    9e3c:	29800115 	stw	r6,4(r5)
    9e40:	29800215 	stw	r6,8(r5)
    9e44:	81400117 	ldw	r5,4(r16)
    9e48:	2940004c 	andi	r5,r5,1
    9e4c:	214ab03a 	or	r5,r4,r5
    9e50:	81400115 	stw	r5,4(r16)
    9e54:	1900ae36 	bltu	r3,r4,a110 <_malloc_r+0x704>
    9e58:	d0e90017 	ldw	r3,-23552(gp)
    9e5c:	1880012e 	bgeu	r3,r2,9e64 <_malloc_r+0x458>
    9e60:	d0a90015 	stw	r2,-23552(gp)
    9e64:	d0e8ff17 	ldw	r3,-23556(gp)
    9e68:	9c000217 	ldw	r16,8(r19)
    9e6c:	1880012e 	bgeu	r3,r2,9e74 <_malloc_r+0x468>
    9e70:	d0a8ff15 	stw	r2,-23556(gp)
    9e74:	80c00117 	ldw	r3,4(r16)
    9e78:	00bfff04 	movi	r2,-4
    9e7c:	1886703a 	and	r3,r3,r2
    9e80:	1c45c83a 	sub	r2,r3,r17
    9e84:	1c400236 	bltu	r3,r17,9e90 <_malloc_r+0x484>
    9e88:	00c003c4 	movi	r3,15
    9e8c:	18800416 	blt	r3,r2,9ea0 <_malloc_r+0x494>
    9e90:	9009883a 	mov	r4,r18
    9e94:	000e4540 	call	e454 <__malloc_unlock>
    9e98:	0005883a 	mov	r2,zero
    9e9c:	003f0906 	br	9ac4 <_malloc_r+0xb8>
    9ea0:	88c00054 	ori	r3,r17,1
    9ea4:	10800054 	ori	r2,r2,1
    9ea8:	80c00115 	stw	r3,4(r16)
    9eac:	8463883a 	add	r17,r16,r17
    9eb0:	88800115 	stw	r2,4(r17)
    9eb4:	9009883a 	mov	r4,r18
    9eb8:	9c400215 	stw	r17,8(r19)
    9ebc:	000e4540 	call	e454 <__malloc_unlock>
    9ec0:	80800204 	addi	r2,r16,8
    9ec4:	003eff06 	br	9ac4 <_malloc_r+0xb8>
    9ec8:	00800504 	movi	r2,20
    9ecc:	1100492e 	bgeu	r2,r4,9ff4 <_malloc_r+0x5e8>
    9ed0:	00801504 	movi	r2,84
    9ed4:	11005c36 	bltu	r2,r4,a048 <_malloc_r+0x63c>
    9ed8:	8808d33a 	srli	r4,r17,12
    9edc:	21001b84 	addi	r4,r4,110
    9ee0:	210b883a 	add	r5,r4,r4
    9ee4:	003f1006 	br	9b28 <_malloc_r+0x11c>
    9ee8:	1006d27a 	srli	r3,r2,9
    9eec:	01400104 	movi	r5,4
    9ef0:	28c0432e 	bgeu	r5,r3,a000 <_malloc_r+0x5f4>
    9ef4:	01400504 	movi	r5,20
    9ef8:	28c07036 	bltu	r5,r3,a0bc <_malloc_r+0x6b0>
    9efc:	194016c4 	addi	r5,r3,91
    9f00:	294d883a 	add	r6,r5,r5
    9f04:	318d883a 	add	r6,r6,r6
    9f08:	318d883a 	add	r6,r6,r6
    9f0c:	998d883a 	add	r6,r19,r6
    9f10:	30c00217 	ldw	r3,8(r6)
    9f14:	01c00134 	movhi	r7,4
    9f18:	39ce4f04 	addi	r7,r7,14652
    9f1c:	19805726 	beq	r3,r6,a07c <_malloc_r+0x670>
    9f20:	01ffff04 	movi	r7,-4
    9f24:	19400117 	ldw	r5,4(r3)
    9f28:	29ca703a 	and	r5,r5,r7
    9f2c:	1140022e 	bgeu	r2,r5,9f38 <_malloc_r+0x52c>
    9f30:	18c00217 	ldw	r3,8(r3)
    9f34:	30fffb1e 	bne	r6,r3,9f24 <_malloc_r+0x518>
    9f38:	19400317 	ldw	r5,12(r3)
    9f3c:	98800117 	ldw	r2,4(r19)
    9f40:	81400315 	stw	r5,12(r16)
    9f44:	80c00215 	stw	r3,8(r16)
    9f48:	2c000215 	stw	r16,8(r5)
    9f4c:	1c000315 	stw	r16,12(r3)
    9f50:	003f2b06 	br	9c00 <_malloc_r+0x1f4>
    9f54:	8445883a 	add	r2,r16,r17
    9f58:	8c400054 	ori	r17,r17,1
    9f5c:	18800515 	stw	r2,20(r3)
    9f60:	18800415 	stw	r2,16(r3)
    9f64:	29000054 	ori	r4,r5,1
    9f68:	1147883a 	add	r3,r2,r5
    9f6c:	84400115 	stw	r17,4(r16)
    9f70:	11000115 	stw	r4,4(r2)
    9f74:	12400315 	stw	r9,12(r2)
    9f78:	12400215 	stw	r9,8(r2)
    9f7c:	19400015 	stw	r5,0(r3)
    9f80:	9009883a 	mov	r4,r18
    9f84:	000e4540 	call	e454 <__malloc_unlock>
    9f88:	80800204 	addi	r2,r16,8
    9f8c:	003ecd06 	br	9ac4 <_malloc_r+0xb8>
    9f90:	18800117 	ldw	r2,4(r3)
    9f94:	003f1a06 	br	9c00 <_malloc_r+0x1f4>
    9f98:	5ac00044 	addi	r11,r11,1
    9f9c:	588000cc 	andi	r2,r11,3
    9fa0:	52800204 	addi	r10,r10,8
    9fa4:	103f2e1e 	bne	r2,zero,9c60 <_malloc_r+0x254>
    9fa8:	20c000cc 	andi	r3,r4,3
    9fac:	60bffe04 	addi	r2,r12,-8
    9fb0:	18006f26 	beq	r3,zero,a170 <_malloc_r+0x764>
    9fb4:	63000017 	ldw	r12,0(r12)
    9fb8:	213fffc4 	addi	r4,r4,-1
    9fbc:	60bffa26 	beq	r12,r2,9fa8 <_malloc_r+0x59c>
    9fc0:	98800117 	ldw	r2,4(r19)
    9fc4:	294b883a 	add	r5,r5,r5
    9fc8:	117f5a36 	bltu	r2,r5,9d34 <_malloc_r+0x328>
    9fcc:	283f5926 	beq	r5,zero,9d34 <_malloc_r+0x328>
    9fd0:	1146703a 	and	r3,r2,r5
    9fd4:	18001626 	beq	r3,zero,a030 <_malloc_r+0x624>
    9fd8:	5809883a 	mov	r4,r11
    9fdc:	003f1a06 	br	9c48 <_malloc_r+0x23c>
    9fe0:	80800204 	addi	r2,r16,8
    9fe4:	84000517 	ldw	r16,20(r16)
    9fe8:	143ea81e 	bne	r2,r16,9a8c <_malloc_r+0x80>
    9fec:	21000084 	addi	r4,r4,2
    9ff0:	003ee306 	br	9b80 <_malloc_r+0x174>
    9ff4:	210016c4 	addi	r4,r4,91
    9ff8:	210b883a 	add	r5,r4,r4
    9ffc:	003eca06 	br	9b28 <_malloc_r+0x11c>
    a000:	100ad1ba 	srli	r5,r2,6
    a004:	29400e04 	addi	r5,r5,56
    a008:	294d883a 	add	r6,r5,r5
    a00c:	003fbd06 	br	9f04 <_malloc_r+0x4f8>
    a010:	84ff6026 	beq	r16,r19,9d94 <_malloc_r+0x388>
    a014:	00800134 	movhi	r2,4
    a018:	108e4f04 	addi	r2,r2,14652
    a01c:	14000217 	ldw	r16,8(r2)
    a020:	00bfff04 	movi	r2,-4
    a024:	80c00117 	ldw	r3,4(r16)
    a028:	1886703a 	and	r3,r3,r2
    a02c:	003f9406 	br	9e80 <_malloc_r+0x474>
    a030:	294b883a 	add	r5,r5,r5
    a034:	1146703a 	and	r3,r2,r5
    a038:	5ac00104 	addi	r11,r11,4
    a03c:	183ffc26 	beq	r3,zero,a030 <_malloc_r+0x624>
    a040:	5809883a 	mov	r4,r11
    a044:	003f0006 	br	9c48 <_malloc_r+0x23c>
    a048:	00805504 	movi	r2,340
    a04c:	11001336 	bltu	r2,r4,a09c <_malloc_r+0x690>
    a050:	8808d3fa 	srli	r4,r17,15
    a054:	21001dc4 	addi	r4,r4,119
    a058:	210b883a 	add	r5,r4,r4
    a05c:	003eb206 	br	9b28 <_malloc_r+0x11c>
    a060:	00840004 	movi	r2,4096
    a064:	003f5d06 	br	9ddc <_malloc_r+0x3d0>
    a068:	00800044 	movi	r2,1
    a06c:	a0800115 	stw	r2,4(r20)
    a070:	a021883a 	mov	r16,r20
    a074:	0007883a 	mov	r3,zero
    a078:	003f8106 	br	9e80 <_malloc_r+0x474>
    a07c:	280bd0ba 	srai	r5,r5,2
    a080:	01800044 	movi	r6,1
    a084:	38800117 	ldw	r2,4(r7)
    a088:	314c983a 	sll	r6,r6,r5
    a08c:	180b883a 	mov	r5,r3
    a090:	3084b03a 	or	r2,r6,r2
    a094:	38800115 	stw	r2,4(r7)
    a098:	003fa906 	br	9f40 <_malloc_r+0x534>
    a09c:	00815504 	movi	r2,1364
    a0a0:	11001836 	bltu	r2,r4,a104 <_malloc_r+0x6f8>
    a0a4:	8808d4ba 	srli	r4,r17,18
    a0a8:	21001f04 	addi	r4,r4,124
    a0ac:	210b883a 	add	r5,r4,r4
    a0b0:	003e9d06 	br	9b28 <_malloc_r+0x11c>
    a0b4:	bdc00404 	addi	r23,r23,16
    a0b8:	003f2f06 	br	9d78 <_malloc_r+0x36c>
    a0bc:	01401504 	movi	r5,84
    a0c0:	28c01f36 	bltu	r5,r3,a140 <_malloc_r+0x734>
    a0c4:	100ad33a 	srli	r5,r2,12
    a0c8:	29401b84 	addi	r5,r5,110
    a0cc:	294d883a 	add	r6,r5,r5
    a0d0:	003f8c06 	br	9f04 <_malloc_r+0x4f8>
    a0d4:	9c000217 	ldw	r16,8(r19)
    a0d8:	00bfff04 	movi	r2,-4
    a0dc:	80c00117 	ldw	r3,4(r16)
    a0e0:	1886703a 	and	r3,r3,r2
    a0e4:	003f6606 	br	9e80 <_malloc_r+0x474>
    a0e8:	e0c3ffcc 	andi	r3,fp,4095
    a0ec:	183f2f1e 	bne	r3,zero,9dac <_malloc_r+0x3a0>
    a0f0:	98c00217 	ldw	r3,8(r19)
    a0f4:	bd49883a 	add	r4,r23,r21
    a0f8:	21000054 	ori	r4,r4,1
    a0fc:	19000115 	stw	r4,4(r3)
    a100:	003f5506 	br	9e58 <_malloc_r+0x44c>
    a104:	01403f04 	movi	r5,252
    a108:	01001f84 	movi	r4,126
    a10c:	003e8606 	br	9b28 <_malloc_r+0x11c>
    a110:	9009883a 	mov	r4,r18
    a114:	81400204 	addi	r5,r16,8
    a118:	0008e740 	call	8e74 <_free_r>
    a11c:	00800134 	movhi	r2,4
    a120:	109f1404 	addi	r2,r2,31824
    a124:	10800017 	ldw	r2,0(r2)
    a128:	003f4b06 	br	9e58 <_malloc_r+0x44c>
    a12c:	00c00044 	movi	r3,1
    a130:	002f883a 	mov	r23,zero
    a134:	003f3406 	br	9e08 <_malloc_r+0x3fc>
    a138:	d5200515 	stw	r20,-32748(gp)
    a13c:	003f2106 	br	9dc4 <_malloc_r+0x3b8>
    a140:	01405504 	movi	r5,340
    a144:	28c00436 	bltu	r5,r3,a158 <_malloc_r+0x74c>
    a148:	100ad3fa 	srli	r5,r2,15
    a14c:	29401dc4 	addi	r5,r5,119
    a150:	294d883a 	add	r6,r5,r5
    a154:	003f6b06 	br	9f04 <_malloc_r+0x4f8>
    a158:	01415504 	movi	r5,1364
    a15c:	28c00936 	bltu	r5,r3,a184 <_malloc_r+0x778>
    a160:	100ad4ba 	srli	r5,r2,18
    a164:	29401f04 	addi	r5,r5,124
    a168:	294d883a 	add	r6,r5,r5
    a16c:	003f6506 	br	9f04 <_malloc_r+0x4f8>
    a170:	98800117 	ldw	r2,4(r19)
    a174:	0146303a 	nor	r3,zero,r5
    a178:	1884703a 	and	r2,r3,r2
    a17c:	98800115 	stw	r2,4(r19)
    a180:	003f9006 	br	9fc4 <_malloc_r+0x5b8>
    a184:	01803f04 	movi	r6,252
    a188:	01401f84 	movi	r5,126
    a18c:	003f5d06 	br	9f04 <_malloc_r+0x4f8>

0000a190 <memchr>:
    a190:	008000c4 	movi	r2,3
    a194:	29403fcc 	andi	r5,r5,255
    a198:	1180282e 	bgeu	r2,r6,a23c <memchr+0xac>
    a19c:	2086703a 	and	r3,r4,r2
    a1a0:	1800351e 	bne	r3,zero,a278 <memchr+0xe8>
    a1a4:	2816923a 	slli	r11,r5,8
    a1a8:	2093883a 	add	r9,r4,r2
    a1ac:	22000084 	addi	r8,r4,2
    a1b0:	5957883a 	add	r11,r11,r5
    a1b4:	5816923a 	slli	r11,r11,8
    a1b8:	20c00044 	addi	r3,r4,1
    a1bc:	037fbff4 	movhi	r13,65279
    a1c0:	6b7fbfc4 	addi	r13,r13,-257
    a1c4:	5957883a 	add	r11,r11,r5
    a1c8:	5816923a 	slli	r11,r11,8
    a1cc:	03202074 	movhi	r12,32897
    a1d0:	63202004 	addi	r12,r12,-32640
    a1d4:	101d883a 	mov	r14,r2
    a1d8:	5957883a 	add	r11,r11,r5
    a1dc:	21c00017 	ldw	r7,0(r4)
    a1e0:	31bfff04 	addi	r6,r6,-4
    a1e4:	1805883a 	mov	r2,r3
    a1e8:	3acef03a 	xor	r7,r7,r11
    a1ec:	3b55883a 	add	r10,r7,r13
    a1f0:	01ce303a 	nor	r7,zero,r7
    a1f4:	51ce703a 	and	r7,r10,r7
    a1f8:	3b0e703a 	and	r7,r7,r12
    a1fc:	38000a26 	beq	r7,zero,a228 <memchr+0x98>
    a200:	21c00003 	ldbu	r7,0(r4)
    a204:	39401e26 	beq	r7,r5,a280 <memchr+0xf0>
    a208:	19c00003 	ldbu	r7,0(r3)
    a20c:	39401926 	beq	r7,r5,a274 <memchr+0xe4>
    a210:	41c00003 	ldbu	r7,0(r8)
    a214:	4005883a 	mov	r2,r8
    a218:	39401626 	beq	r7,r5,a274 <memchr+0xe4>
    a21c:	49c00003 	ldbu	r7,0(r9)
    a220:	4805883a 	mov	r2,r9
    a224:	39401326 	beq	r7,r5,a274 <memchr+0xe4>
    a228:	21000104 	addi	r4,r4,4
    a22c:	4a400104 	addi	r9,r9,4
    a230:	42000104 	addi	r8,r8,4
    a234:	18c00104 	addi	r3,r3,4
    a238:	71bfe836 	bltu	r14,r6,a1dc <memchr+0x4c>
    a23c:	2005883a 	mov	r2,r4
    a240:	30000a26 	beq	r6,zero,a26c <memchr+0xdc>
    a244:	10c00003 	ldbu	r3,0(r2)
    a248:	19400a26 	beq	r3,r5,a274 <memchr+0xe4>
    a24c:	10c00044 	addi	r3,r2,1
    a250:	118d883a 	add	r6,r2,r6
    a254:	00000306 	br	a264 <memchr+0xd4>
    a258:	11000003 	ldbu	r4,0(r2)
    a25c:	18c00044 	addi	r3,r3,1
    a260:	21400426 	beq	r4,r5,a274 <memchr+0xe4>
    a264:	1805883a 	mov	r2,r3
    a268:	19bffb1e 	bne	r3,r6,a258 <memchr+0xc8>
    a26c:	0005883a 	mov	r2,zero
    a270:	f800283a 	ret
    a274:	f800283a 	ret
    a278:	2005883a 	mov	r2,r4
    a27c:	003ff106 	br	a244 <memchr+0xb4>
    a280:	2005883a 	mov	r2,r4
    a284:	f800283a 	ret

0000a288 <memmove>:
    a288:	2005883a 	mov	r2,r4
    a28c:	300f883a 	mov	r7,r6
    a290:	29000b2e 	bgeu	r5,r4,a2c0 <memmove+0x38>
    a294:	2987883a 	add	r3,r5,r6
    a298:	20c0092e 	bgeu	r4,r3,a2c0 <memmove+0x38>
    a29c:	218b883a 	add	r5,r4,r6
    a2a0:	198fc83a 	sub	r7,r3,r6
    a2a4:	30003f26 	beq	r6,zero,a3a4 <memmove+0x11c>
    a2a8:	18ffffc4 	addi	r3,r3,-1
    a2ac:	19000003 	ldbu	r4,0(r3)
    a2b0:	297fffc4 	addi	r5,r5,-1
    a2b4:	29000005 	stb	r4,0(r5)
    a2b8:	19fffb1e 	bne	r3,r7,a2a8 <memmove+0x20>
    a2bc:	f800283a 	ret
    a2c0:	00c003c4 	movi	r3,15
    a2c4:	1980382e 	bgeu	r3,r6,a3a8 <memmove+0x120>
    a2c8:	2886b03a 	or	r3,r5,r2
    a2cc:	18c000cc 	andi	r3,r3,3
    a2d0:	1800351e 	bne	r3,zero,a3a8 <memmove+0x120>
    a2d4:	327ffc04 	addi	r9,r6,-16
    a2d8:	4812d13a 	srli	r9,r9,4
    a2dc:	12000404 	addi	r8,r2,16
    a2e0:	1007883a 	mov	r3,r2
    a2e4:	4808913a 	slli	r4,r9,4
    a2e8:	280f883a 	mov	r7,r5
    a2ec:	4111883a 	add	r8,r8,r4
    a2f0:	39000017 	ldw	r4,0(r7)
    a2f4:	18c00404 	addi	r3,r3,16
    a2f8:	39c00404 	addi	r7,r7,16
    a2fc:	193ffc15 	stw	r4,-16(r3)
    a300:	393ffd17 	ldw	r4,-12(r7)
    a304:	193ffd15 	stw	r4,-12(r3)
    a308:	393ffe17 	ldw	r4,-8(r7)
    a30c:	193ffe15 	stw	r4,-8(r3)
    a310:	393fff17 	ldw	r4,-4(r7)
    a314:	193fff15 	stw	r4,-4(r3)
    a318:	1a3ff51e 	bne	r3,r8,a2f0 <memmove+0x68>
    a31c:	49000044 	addi	r4,r9,1
    a320:	2008913a 	slli	r4,r4,4
    a324:	31c003cc 	andi	r7,r6,15
    a328:	1107883a 	add	r3,r2,r4
    a32c:	290b883a 	add	r5,r5,r4
    a330:	010000c4 	movi	r4,3
    a334:	21c0142e 	bgeu	r4,r7,a388 <memmove+0x100>
    a338:	39ffff04 	addi	r7,r7,-4
    a33c:	3814d0ba 	srli	r10,r7,2
    a340:	1a400104 	addi	r9,r3,4
    a344:	180d883a 	mov	r6,r3
    a348:	5289883a 	add	r4,r10,r10
    a34c:	2109883a 	add	r4,r4,r4
    a350:	4913883a 	add	r9,r9,r4
    a354:	2809883a 	mov	r4,r5
    a358:	22000017 	ldw	r8,0(r4)
    a35c:	31800104 	addi	r6,r6,4
    a360:	21000104 	addi	r4,r4,4
    a364:	323fff15 	stw	r8,-4(r6)
    a368:	327ffb1e 	bne	r6,r9,a358 <memmove+0xd0>
    a36c:	51000044 	addi	r4,r10,1
    a370:	52bfff24 	muli	r10,r10,-4
    a374:	2109883a 	add	r4,r4,r4
    a378:	2109883a 	add	r4,r4,r4
    a37c:	51cf883a 	add	r7,r10,r7
    a380:	290b883a 	add	r5,r5,r4
    a384:	1907883a 	add	r3,r3,r4
    a388:	38000626 	beq	r7,zero,a3a4 <memmove+0x11c>
    a38c:	19cf883a 	add	r7,r3,r7
    a390:	29800003 	ldbu	r6,0(r5)
    a394:	18c00044 	addi	r3,r3,1
    a398:	29400044 	addi	r5,r5,1
    a39c:	19bfffc5 	stb	r6,-1(r3)
    a3a0:	19fffb1e 	bne	r3,r7,a390 <memmove+0x108>
    a3a4:	f800283a 	ret
    a3a8:	1007883a 	mov	r3,r2
    a3ac:	003ff606 	br	a388 <memmove+0x100>

0000a3b0 <_Balloc>:
    a3b0:	20801317 	ldw	r2,76(r4)
    a3b4:	defffc04 	addi	sp,sp,-16
    a3b8:	dc400115 	stw	r17,4(sp)
    a3bc:	dc000015 	stw	r16,0(sp)
    a3c0:	dfc00315 	stw	ra,12(sp)
    a3c4:	dc800215 	stw	r18,8(sp)
    a3c8:	2023883a 	mov	r17,r4
    a3cc:	2821883a 	mov	r16,r5
    a3d0:	10000f26 	beq	r2,zero,a410 <_Balloc+0x60>
    a3d4:	8407883a 	add	r3,r16,r16
    a3d8:	18c7883a 	add	r3,r3,r3
    a3dc:	10c7883a 	add	r3,r2,r3
    a3e0:	18800017 	ldw	r2,0(r3)
    a3e4:	10001126 	beq	r2,zero,a42c <_Balloc+0x7c>
    a3e8:	11000017 	ldw	r4,0(r2)
    a3ec:	19000015 	stw	r4,0(r3)
    a3f0:	10000415 	stw	zero,16(r2)
    a3f4:	10000315 	stw	zero,12(r2)
    a3f8:	dfc00317 	ldw	ra,12(sp)
    a3fc:	dc800217 	ldw	r18,8(sp)
    a400:	dc400117 	ldw	r17,4(sp)
    a404:	dc000017 	ldw	r16,0(sp)
    a408:	dec00404 	addi	sp,sp,16
    a40c:	f800283a 	ret
    a410:	01400104 	movi	r5,4
    a414:	01800404 	movi	r6,16
    a418:	000bf700 	call	bf70 <_calloc_r>
    a41c:	88801315 	stw	r2,76(r17)
    a420:	103fec1e 	bne	r2,zero,a3d4 <_Balloc+0x24>
    a424:	0005883a 	mov	r2,zero
    a428:	003ff306 	br	a3f8 <_Balloc+0x48>
    a42c:	01400044 	movi	r5,1
    a430:	2c24983a 	sll	r18,r5,r16
    a434:	8809883a 	mov	r4,r17
    a438:	91800144 	addi	r6,r18,5
    a43c:	318d883a 	add	r6,r6,r6
    a440:	318d883a 	add	r6,r6,r6
    a444:	000bf700 	call	bf70 <_calloc_r>
    a448:	103ff626 	beq	r2,zero,a424 <_Balloc+0x74>
    a44c:	14000115 	stw	r16,4(r2)
    a450:	14800215 	stw	r18,8(r2)
    a454:	003fe606 	br	a3f0 <_Balloc+0x40>

0000a458 <_Bfree>:
    a458:	28000826 	beq	r5,zero,a47c <_Bfree+0x24>
    a45c:	28c00117 	ldw	r3,4(r5)
    a460:	20801317 	ldw	r2,76(r4)
    a464:	18c7883a 	add	r3,r3,r3
    a468:	18c7883a 	add	r3,r3,r3
    a46c:	10c5883a 	add	r2,r2,r3
    a470:	10c00017 	ldw	r3,0(r2)
    a474:	28c00015 	stw	r3,0(r5)
    a478:	11400015 	stw	r5,0(r2)
    a47c:	f800283a 	ret

0000a480 <__multadd>:
    a480:	defffa04 	addi	sp,sp,-24
    a484:	dc000115 	stw	r16,4(sp)
    a488:	2c000417 	ldw	r16,16(r5)
    a48c:	dc800315 	stw	r18,12(sp)
    a490:	dc400215 	stw	r17,8(sp)
    a494:	dfc00515 	stw	ra,20(sp)
    a498:	dcc00415 	stw	r19,16(sp)
    a49c:	2823883a 	mov	r17,r5
    a4a0:	2025883a 	mov	r18,r4
    a4a4:	28c00504 	addi	r3,r5,20
    a4a8:	0011883a 	mov	r8,zero
    a4ac:	1a800017 	ldw	r10,0(r3)
    a4b0:	18c00104 	addi	r3,r3,4
    a4b4:	42000044 	addi	r8,r8,1
    a4b8:	527fffcc 	andi	r9,r10,65535
    a4bc:	4993383a 	mul	r9,r9,r6
    a4c0:	5014d43a 	srli	r10,r10,16
    a4c4:	49d3883a 	add	r9,r9,r7
    a4c8:	480ed43a 	srli	r7,r9,16
    a4cc:	5195383a 	mul	r10,r10,r6
    a4d0:	4a7fffcc 	andi	r9,r9,65535
    a4d4:	3a8f883a 	add	r7,r7,r10
    a4d8:	3814943a 	slli	r10,r7,16
    a4dc:	380ed43a 	srli	r7,r7,16
    a4e0:	5253883a 	add	r9,r10,r9
    a4e4:	1a7fff15 	stw	r9,-4(r3)
    a4e8:	443ff016 	blt	r8,r16,a4ac <__multadd+0x2c>
    a4ec:	38000926 	beq	r7,zero,a514 <__multadd+0x94>
    a4f0:	88800217 	ldw	r2,8(r17)
    a4f4:	80800f0e 	bge	r16,r2,a534 <__multadd+0xb4>
    a4f8:	80800144 	addi	r2,r16,5
    a4fc:	1085883a 	add	r2,r2,r2
    a500:	1085883a 	add	r2,r2,r2
    a504:	8885883a 	add	r2,r17,r2
    a508:	84000044 	addi	r16,r16,1
    a50c:	11c00015 	stw	r7,0(r2)
    a510:	8c000415 	stw	r16,16(r17)
    a514:	8805883a 	mov	r2,r17
    a518:	dfc00517 	ldw	ra,20(sp)
    a51c:	dcc00417 	ldw	r19,16(sp)
    a520:	dc800317 	ldw	r18,12(sp)
    a524:	dc400217 	ldw	r17,8(sp)
    a528:	dc000117 	ldw	r16,4(sp)
    a52c:	dec00604 	addi	sp,sp,24
    a530:	f800283a 	ret
    a534:	89400117 	ldw	r5,4(r17)
    a538:	9009883a 	mov	r4,r18
    a53c:	d9c00015 	stw	r7,0(sp)
    a540:	29400044 	addi	r5,r5,1
    a544:	000a3b00 	call	a3b0 <_Balloc>
    a548:	89800417 	ldw	r6,16(r17)
    a54c:	89400304 	addi	r5,r17,12
    a550:	11000304 	addi	r4,r2,12
    a554:	31800084 	addi	r6,r6,2
    a558:	318d883a 	add	r6,r6,r6
    a55c:	318d883a 	add	r6,r6,r6
    a560:	1027883a 	mov	r19,r2
    a564:	00041f00 	call	41f0 <memcpy>
    a568:	88c00117 	ldw	r3,4(r17)
    a56c:	90801317 	ldw	r2,76(r18)
    a570:	d9c00017 	ldw	r7,0(sp)
    a574:	18c7883a 	add	r3,r3,r3
    a578:	18c7883a 	add	r3,r3,r3
    a57c:	10c5883a 	add	r2,r2,r3
    a580:	10c00017 	ldw	r3,0(r2)
    a584:	88c00015 	stw	r3,0(r17)
    a588:	14400015 	stw	r17,0(r2)
    a58c:	9823883a 	mov	r17,r19
    a590:	003fd906 	br	a4f8 <__multadd+0x78>

0000a594 <__s2b>:
    a594:	defff904 	addi	sp,sp,-28
    a598:	dd000415 	stw	r20,16(sp)
    a59c:	dc400115 	stw	r17,4(sp)
    a5a0:	2829883a 	mov	r20,r5
    a5a4:	2023883a 	mov	r17,r4
    a5a8:	01400244 	movi	r5,9
    a5ac:	39000204 	addi	r4,r7,8
    a5b0:	dcc00315 	stw	r19,12(sp)
    a5b4:	dc800215 	stw	r18,8(sp)
    a5b8:	dfc00615 	stw	ra,24(sp)
    a5bc:	dd400515 	stw	r21,20(sp)
    a5c0:	dc000015 	stw	r16,0(sp)
    a5c4:	3825883a 	mov	r18,r7
    a5c8:	3027883a 	mov	r19,r6
    a5cc:	000dc8c0 	call	dc8c <__divsi3>
    a5d0:	00c00044 	movi	r3,1
    a5d4:	000b883a 	mov	r5,zero
    a5d8:	1880030e 	bge	r3,r2,a5e8 <__s2b+0x54>
    a5dc:	18c7883a 	add	r3,r3,r3
    a5e0:	29400044 	addi	r5,r5,1
    a5e4:	18bffd16 	blt	r3,r2,a5dc <__s2b+0x48>
    a5e8:	8809883a 	mov	r4,r17
    a5ec:	000a3b00 	call	a3b0 <_Balloc>
    a5f0:	d8c00717 	ldw	r3,28(sp)
    a5f4:	10c00515 	stw	r3,20(r2)
    a5f8:	00c00044 	movi	r3,1
    a5fc:	10c00415 	stw	r3,16(r2)
    a600:	00c00244 	movi	r3,9
    a604:	1cc0210e 	bge	r3,r19,a68c <__s2b+0xf8>
    a608:	a0eb883a 	add	r21,r20,r3
    a60c:	a821883a 	mov	r16,r21
    a610:	a4e9883a 	add	r20,r20,r19
    a614:	81c00007 	ldb	r7,0(r16)
    a618:	8809883a 	mov	r4,r17
    a61c:	84000044 	addi	r16,r16,1
    a620:	100b883a 	mov	r5,r2
    a624:	01800284 	movi	r6,10
    a628:	39fff404 	addi	r7,r7,-48
    a62c:	000a4800 	call	a480 <__multadd>
    a630:	853ff81e 	bne	r16,r20,a614 <__s2b+0x80>
    a634:	ace1883a 	add	r16,r21,r19
    a638:	843ffe04 	addi	r16,r16,-8
    a63c:	9c800a0e 	bge	r19,r18,a668 <__s2b+0xd4>
    a640:	94e5c83a 	sub	r18,r18,r19
    a644:	84a5883a 	add	r18,r16,r18
    a648:	81c00007 	ldb	r7,0(r16)
    a64c:	8809883a 	mov	r4,r17
    a650:	84000044 	addi	r16,r16,1
    a654:	100b883a 	mov	r5,r2
    a658:	01800284 	movi	r6,10
    a65c:	39fff404 	addi	r7,r7,-48
    a660:	000a4800 	call	a480 <__multadd>
    a664:	84bff81e 	bne	r16,r18,a648 <__s2b+0xb4>
    a668:	dfc00617 	ldw	ra,24(sp)
    a66c:	dd400517 	ldw	r21,20(sp)
    a670:	dd000417 	ldw	r20,16(sp)
    a674:	dcc00317 	ldw	r19,12(sp)
    a678:	dc800217 	ldw	r18,8(sp)
    a67c:	dc400117 	ldw	r17,4(sp)
    a680:	dc000017 	ldw	r16,0(sp)
    a684:	dec00704 	addi	sp,sp,28
    a688:	f800283a 	ret
    a68c:	a4000284 	addi	r16,r20,10
    a690:	1827883a 	mov	r19,r3
    a694:	003fe906 	br	a63c <__s2b+0xa8>

0000a698 <__hi0bits>:
    a698:	20bfffec 	andhi	r2,r4,65535
    a69c:	1000141e 	bne	r2,zero,a6f0 <__hi0bits+0x58>
    a6a0:	2008943a 	slli	r4,r4,16
    a6a4:	00800404 	movi	r2,16
    a6a8:	20ffc02c 	andhi	r3,r4,65280
    a6ac:	1800021e 	bne	r3,zero,a6b8 <__hi0bits+0x20>
    a6b0:	2008923a 	slli	r4,r4,8
    a6b4:	10800204 	addi	r2,r2,8
    a6b8:	20fc002c 	andhi	r3,r4,61440
    a6bc:	1800021e 	bne	r3,zero,a6c8 <__hi0bits+0x30>
    a6c0:	2008913a 	slli	r4,r4,4
    a6c4:	10800104 	addi	r2,r2,4
    a6c8:	20f0002c 	andhi	r3,r4,49152
    a6cc:	1800031e 	bne	r3,zero,a6dc <__hi0bits+0x44>
    a6d0:	2109883a 	add	r4,r4,r4
    a6d4:	10800084 	addi	r2,r2,2
    a6d8:	2109883a 	add	r4,r4,r4
    a6dc:	20000316 	blt	r4,zero,a6ec <__hi0bits+0x54>
    a6e0:	2110002c 	andhi	r4,r4,16384
    a6e4:	2000041e 	bne	r4,zero,a6f8 <__hi0bits+0x60>
    a6e8:	00800804 	movi	r2,32
    a6ec:	f800283a 	ret
    a6f0:	0005883a 	mov	r2,zero
    a6f4:	003fec06 	br	a6a8 <__hi0bits+0x10>
    a6f8:	10800044 	addi	r2,r2,1
    a6fc:	f800283a 	ret

0000a700 <__lo0bits>:
    a700:	20c00017 	ldw	r3,0(r4)
    a704:	188001cc 	andi	r2,r3,7
    a708:	10000826 	beq	r2,zero,a72c <__lo0bits+0x2c>
    a70c:	1880004c 	andi	r2,r3,1
    a710:	1000211e 	bne	r2,zero,a798 <__lo0bits+0x98>
    a714:	1880008c 	andi	r2,r3,2
    a718:	1000211e 	bne	r2,zero,a7a0 <__lo0bits+0xa0>
    a71c:	1806d0ba 	srli	r3,r3,2
    a720:	00800084 	movi	r2,2
    a724:	20c00015 	stw	r3,0(r4)
    a728:	f800283a 	ret
    a72c:	18bfffcc 	andi	r2,r3,65535
    a730:	10001326 	beq	r2,zero,a780 <__lo0bits+0x80>
    a734:	0005883a 	mov	r2,zero
    a738:	19403fcc 	andi	r5,r3,255
    a73c:	2800021e 	bne	r5,zero,a748 <__lo0bits+0x48>
    a740:	1806d23a 	srli	r3,r3,8
    a744:	10800204 	addi	r2,r2,8
    a748:	194003cc 	andi	r5,r3,15
    a74c:	2800021e 	bne	r5,zero,a758 <__lo0bits+0x58>
    a750:	1806d13a 	srli	r3,r3,4
    a754:	10800104 	addi	r2,r2,4
    a758:	194000cc 	andi	r5,r3,3
    a75c:	2800021e 	bne	r5,zero,a768 <__lo0bits+0x68>
    a760:	1806d0ba 	srli	r3,r3,2
    a764:	10800084 	addi	r2,r2,2
    a768:	1940004c 	andi	r5,r3,1
    a76c:	2800081e 	bne	r5,zero,a790 <__lo0bits+0x90>
    a770:	1806d07a 	srli	r3,r3,1
    a774:	1800051e 	bne	r3,zero,a78c <__lo0bits+0x8c>
    a778:	00800804 	movi	r2,32
    a77c:	f800283a 	ret
    a780:	1806d43a 	srli	r3,r3,16
    a784:	00800404 	movi	r2,16
    a788:	003feb06 	br	a738 <__lo0bits+0x38>
    a78c:	10800044 	addi	r2,r2,1
    a790:	20c00015 	stw	r3,0(r4)
    a794:	f800283a 	ret
    a798:	0005883a 	mov	r2,zero
    a79c:	f800283a 	ret
    a7a0:	1806d07a 	srli	r3,r3,1
    a7a4:	00800044 	movi	r2,1
    a7a8:	20c00015 	stw	r3,0(r4)
    a7ac:	f800283a 	ret

0000a7b0 <__i2b>:
    a7b0:	defffd04 	addi	sp,sp,-12
    a7b4:	dc000015 	stw	r16,0(sp)
    a7b8:	04000044 	movi	r16,1
    a7bc:	dc400115 	stw	r17,4(sp)
    a7c0:	2823883a 	mov	r17,r5
    a7c4:	800b883a 	mov	r5,r16
    a7c8:	dfc00215 	stw	ra,8(sp)
    a7cc:	000a3b00 	call	a3b0 <_Balloc>
    a7d0:	14400515 	stw	r17,20(r2)
    a7d4:	14000415 	stw	r16,16(r2)
    a7d8:	dfc00217 	ldw	ra,8(sp)
    a7dc:	dc400117 	ldw	r17,4(sp)
    a7e0:	dc000017 	ldw	r16,0(sp)
    a7e4:	dec00304 	addi	sp,sp,12
    a7e8:	f800283a 	ret

0000a7ec <__multiply>:
    a7ec:	defffa04 	addi	sp,sp,-24
    a7f0:	dcc00315 	stw	r19,12(sp)
    a7f4:	dc400115 	stw	r17,4(sp)
    a7f8:	34c00417 	ldw	r19,16(r6)
    a7fc:	2c400417 	ldw	r17,16(r5)
    a800:	dd000415 	stw	r20,16(sp)
    a804:	dc800215 	stw	r18,8(sp)
    a808:	dfc00515 	stw	ra,20(sp)
    a80c:	dc000015 	stw	r16,0(sp)
    a810:	2825883a 	mov	r18,r5
    a814:	3029883a 	mov	r20,r6
    a818:	8cc0050e 	bge	r17,r19,a830 <__multiply+0x44>
    a81c:	8807883a 	mov	r3,r17
    a820:	3025883a 	mov	r18,r6
    a824:	9823883a 	mov	r17,r19
    a828:	2829883a 	mov	r20,r5
    a82c:	1827883a 	mov	r19,r3
    a830:	90800217 	ldw	r2,8(r18)
    a834:	8ce1883a 	add	r16,r17,r19
    a838:	91400117 	ldw	r5,4(r18)
    a83c:	1400010e 	bge	r2,r16,a844 <__multiply+0x58>
    a840:	29400044 	addi	r5,r5,1
    a844:	000a3b00 	call	a3b0 <_Balloc>
    a848:	83c00144 	addi	r15,r16,5
    a84c:	7bdf883a 	add	r15,r15,r15
    a850:	7bdf883a 	add	r15,r15,r15
    a854:	13800504 	addi	r14,r2,20
    a858:	13df883a 	add	r15,r2,r15
    a85c:	7007883a 	mov	r3,r14
    a860:	73c0032e 	bgeu	r14,r15,a870 <__multiply+0x84>
    a864:	18000015 	stw	zero,0(r3)
    a868:	18c00104 	addi	r3,r3,4
    a86c:	1bfffd36 	bltu	r3,r15,a864 <__multiply+0x78>
    a870:	99800144 	addi	r6,r19,5
    a874:	8b000144 	addi	r12,r17,5
    a878:	318d883a 	add	r6,r6,r6
    a87c:	6319883a 	add	r12,r12,r12
    a880:	318d883a 	add	r6,r6,r6
    a884:	6319883a 	add	r12,r12,r12
    a888:	a3400504 	addi	r13,r20,20
    a88c:	a18d883a 	add	r6,r20,r6
    a890:	94400504 	addi	r17,r18,20
    a894:	9319883a 	add	r12,r18,r12
    a898:	6980392e 	bgeu	r13,r6,a980 <__multiply+0x194>
    a89c:	6a800017 	ldw	r10,0(r13)
    a8a0:	52ffffcc 	andi	r11,r10,65535
    a8a4:	58001826 	beq	r11,zero,a908 <__multiply+0x11c>
    a8a8:	7007883a 	mov	r3,r14
    a8ac:	8809883a 	mov	r4,r17
    a8b0:	000b883a 	mov	r5,zero
    a8b4:	22400017 	ldw	r9,0(r4)
    a8b8:	1a000017 	ldw	r8,0(r3)
    a8bc:	21000104 	addi	r4,r4,4
    a8c0:	49ffffcc 	andi	r7,r9,65535
    a8c4:	3acf383a 	mul	r7,r7,r11
    a8c8:	4812d43a 	srli	r9,r9,16
    a8cc:	42bfffcc 	andi	r10,r8,65535
    a8d0:	3a8f883a 	add	r7,r7,r10
    a8d4:	394f883a 	add	r7,r7,r5
    a8d8:	4010d43a 	srli	r8,r8,16
    a8dc:	4acb383a 	mul	r5,r9,r11
    a8e0:	3814d43a 	srli	r10,r7,16
    a8e4:	19c0000d 	sth	r7,0(r3)
    a8e8:	2a0b883a 	add	r5,r5,r8
    a8ec:	2a8b883a 	add	r5,r5,r10
    a8f0:	1940008d 	sth	r5,2(r3)
    a8f4:	280ad43a 	srli	r5,r5,16
    a8f8:	18c00104 	addi	r3,r3,4
    a8fc:	233fed36 	bltu	r4,r12,a8b4 <__multiply+0xc8>
    a900:	19400015 	stw	r5,0(r3)
    a904:	6a800017 	ldw	r10,0(r13)
    a908:	5014d43a 	srli	r10,r10,16
    a90c:	50001926 	beq	r10,zero,a974 <__multiply+0x188>
    a910:	71400017 	ldw	r5,0(r14)
    a914:	7007883a 	mov	r3,r14
    a918:	8809883a 	mov	r4,r17
    a91c:	280f883a 	mov	r7,r5
    a920:	0017883a 	mov	r11,zero
    a924:	22400017 	ldw	r9,0(r4)
    a928:	380ed43a 	srli	r7,r7,16
    a92c:	1940000d 	sth	r5,0(r3)
    a930:	4a3fffcc 	andi	r8,r9,65535
    a934:	4291383a 	mul	r8,r8,r10
    a938:	4812d43a 	srli	r9,r9,16
    a93c:	18c00104 	addi	r3,r3,4
    a940:	41d1883a 	add	r8,r8,r7
    a944:	19c00017 	ldw	r7,0(r3)
    a948:	42d1883a 	add	r8,r8,r11
    a94c:	4a93383a 	mul	r9,r9,r10
    a950:	1a3fff8d 	sth	r8,-2(r3)
    a954:	4010d43a 	srli	r8,r8,16
    a958:	397fffcc 	andi	r5,r7,65535
    a95c:	2a4b883a 	add	r5,r5,r9
    a960:	2a0b883a 	add	r5,r5,r8
    a964:	21000104 	addi	r4,r4,4
    a968:	2816d43a 	srli	r11,r5,16
    a96c:	233fed36 	bltu	r4,r12,a924 <__multiply+0x138>
    a970:	19400015 	stw	r5,0(r3)
    a974:	6b400104 	addi	r13,r13,4
    a978:	73800104 	addi	r14,r14,4
    a97c:	69bfc736 	bltu	r13,r6,a89c <__multiply+0xb0>
    a980:	0400090e 	bge	zero,r16,a9a8 <__multiply+0x1bc>
    a984:	78ffff17 	ldw	r3,-4(r15)
    a988:	7bffff04 	addi	r15,r15,-4
    a98c:	18000326 	beq	r3,zero,a99c <__multiply+0x1b0>
    a990:	00000506 	br	a9a8 <__multiply+0x1bc>
    a994:	78c00017 	ldw	r3,0(r15)
    a998:	1800031e 	bne	r3,zero,a9a8 <__multiply+0x1bc>
    a99c:	843fffc4 	addi	r16,r16,-1
    a9a0:	7bffff04 	addi	r15,r15,-4
    a9a4:	803ffb1e 	bne	r16,zero,a994 <__multiply+0x1a8>
    a9a8:	14000415 	stw	r16,16(r2)
    a9ac:	dfc00517 	ldw	ra,20(sp)
    a9b0:	dd000417 	ldw	r20,16(sp)
    a9b4:	dcc00317 	ldw	r19,12(sp)
    a9b8:	dc800217 	ldw	r18,8(sp)
    a9bc:	dc400117 	ldw	r17,4(sp)
    a9c0:	dc000017 	ldw	r16,0(sp)
    a9c4:	dec00604 	addi	sp,sp,24
    a9c8:	f800283a 	ret

0000a9cc <__pow5mult>:
    a9cc:	defffb04 	addi	sp,sp,-20
    a9d0:	dcc00315 	stw	r19,12(sp)
    a9d4:	dc800215 	stw	r18,8(sp)
    a9d8:	dc000015 	stw	r16,0(sp)
    a9dc:	dfc00415 	stw	ra,16(sp)
    a9e0:	dc400115 	stw	r17,4(sp)
    a9e4:	308000cc 	andi	r2,r6,3
    a9e8:	3021883a 	mov	r16,r6
    a9ec:	2027883a 	mov	r19,r4
    a9f0:	2825883a 	mov	r18,r5
    a9f4:	10002e1e 	bne	r2,zero,aab0 <__pow5mult+0xe4>
    a9f8:	8021d0ba 	srai	r16,r16,2
    a9fc:	80001a26 	beq	r16,zero,aa68 <__pow5mult+0x9c>
    aa00:	9c401217 	ldw	r17,72(r19)
    aa04:	8800061e 	bne	r17,zero,aa20 <__pow5mult+0x54>
    aa08:	00003406 	br	aadc <__pow5mult+0x110>
    aa0c:	8021d07a 	srai	r16,r16,1
    aa10:	80001526 	beq	r16,zero,aa68 <__pow5mult+0x9c>
    aa14:	88c00017 	ldw	r3,0(r17)
    aa18:	18001b26 	beq	r3,zero,aa88 <__pow5mult+0xbc>
    aa1c:	1823883a 	mov	r17,r3
    aa20:	80c0004c 	andi	r3,r16,1
    aa24:	183ff926 	beq	r3,zero,aa0c <__pow5mult+0x40>
    aa28:	900b883a 	mov	r5,r18
    aa2c:	880d883a 	mov	r6,r17
    aa30:	9809883a 	mov	r4,r19
    aa34:	000a7ec0 	call	a7ec <__multiply>
    aa38:	90001b26 	beq	r18,zero,aaa8 <__pow5mult+0xdc>
    aa3c:	91000117 	ldw	r4,4(r18)
    aa40:	98c01317 	ldw	r3,76(r19)
    aa44:	8021d07a 	srai	r16,r16,1
    aa48:	2109883a 	add	r4,r4,r4
    aa4c:	2109883a 	add	r4,r4,r4
    aa50:	1907883a 	add	r3,r3,r4
    aa54:	19000017 	ldw	r4,0(r3)
    aa58:	91000015 	stw	r4,0(r18)
    aa5c:	1c800015 	stw	r18,0(r3)
    aa60:	1025883a 	mov	r18,r2
    aa64:	803feb1e 	bne	r16,zero,aa14 <__pow5mult+0x48>
    aa68:	9005883a 	mov	r2,r18
    aa6c:	dfc00417 	ldw	ra,16(sp)
    aa70:	dcc00317 	ldw	r19,12(sp)
    aa74:	dc800217 	ldw	r18,8(sp)
    aa78:	dc400117 	ldw	r17,4(sp)
    aa7c:	dc000017 	ldw	r16,0(sp)
    aa80:	dec00504 	addi	sp,sp,20
    aa84:	f800283a 	ret
    aa88:	880b883a 	mov	r5,r17
    aa8c:	880d883a 	mov	r6,r17
    aa90:	9809883a 	mov	r4,r19
    aa94:	000a7ec0 	call	a7ec <__multiply>
    aa98:	88800015 	stw	r2,0(r17)
    aa9c:	10000015 	stw	zero,0(r2)
    aaa0:	1023883a 	mov	r17,r2
    aaa4:	003fde06 	br	aa20 <__pow5mult+0x54>
    aaa8:	1025883a 	mov	r18,r2
    aaac:	003fd706 	br	aa0c <__pow5mult+0x40>
    aab0:	10bfffc4 	addi	r2,r2,-1
    aab4:	1085883a 	add	r2,r2,r2
    aab8:	00c00134 	movhi	r3,4
    aabc:	18c21c04 	addi	r3,r3,2160
    aac0:	1085883a 	add	r2,r2,r2
    aac4:	1885883a 	add	r2,r3,r2
    aac8:	11800017 	ldw	r6,0(r2)
    aacc:	000f883a 	mov	r7,zero
    aad0:	000a4800 	call	a480 <__multadd>
    aad4:	1025883a 	mov	r18,r2
    aad8:	003fc706 	br	a9f8 <__pow5mult+0x2c>
    aadc:	9809883a 	mov	r4,r19
    aae0:	01409c44 	movi	r5,625
    aae4:	000a7b00 	call	a7b0 <__i2b>
    aae8:	98801215 	stw	r2,72(r19)
    aaec:	1023883a 	mov	r17,r2
    aaf0:	10000015 	stw	zero,0(r2)
    aaf4:	003fca06 	br	aa20 <__pow5mult+0x54>

0000aaf8 <__lshift>:
    aaf8:	defff904 	addi	sp,sp,-28
    aafc:	dd400515 	stw	r21,20(sp)
    ab00:	dc400115 	stw	r17,4(sp)
    ab04:	2d400417 	ldw	r21,16(r5)
    ab08:	3023d17a 	srai	r17,r6,5
    ab0c:	28800217 	ldw	r2,8(r5)
    ab10:	dd000415 	stw	r20,16(sp)
    ab14:	8d6b883a 	add	r21,r17,r21
    ab18:	dcc00315 	stw	r19,12(sp)
    ab1c:	dc800215 	stw	r18,8(sp)
    ab20:	dc000015 	stw	r16,0(sp)
    ab24:	dfc00615 	stw	ra,24(sp)
    ab28:	ac000044 	addi	r16,r21,1
    ab2c:	2825883a 	mov	r18,r5
    ab30:	3029883a 	mov	r20,r6
    ab34:	2027883a 	mov	r19,r4
    ab38:	29400117 	ldw	r5,4(r5)
    ab3c:	1400030e 	bge	r2,r16,ab4c <__lshift+0x54>
    ab40:	1085883a 	add	r2,r2,r2
    ab44:	29400044 	addi	r5,r5,1
    ab48:	143ffd16 	blt	r2,r16,ab40 <__lshift+0x48>
    ab4c:	9809883a 	mov	r4,r19
    ab50:	000a3b00 	call	a3b0 <_Balloc>
    ab54:	10c00504 	addi	r3,r2,20
    ab58:	0440090e 	bge	zero,r17,ab80 <__lshift+0x88>
    ab5c:	000f883a 	mov	r7,zero
    ab60:	18000015 	stw	zero,0(r3)
    ab64:	39c00044 	addi	r7,r7,1
    ab68:	18c00104 	addi	r3,r3,4
    ab6c:	3c7ffc1e 	bne	r7,r17,ab60 <__lshift+0x68>
    ab70:	38c00144 	addi	r3,r7,5
    ab74:	18c7883a 	add	r3,r3,r3
    ab78:	18c7883a 	add	r3,r3,r3
    ab7c:	10c7883a 	add	r3,r2,r3
    ab80:	92000417 	ldw	r8,16(r18)
    ab84:	a18007cc 	andi	r6,r20,31
    ab88:	91c00504 	addi	r7,r18,20
    ab8c:	42000144 	addi	r8,r8,5
    ab90:	4211883a 	add	r8,r8,r8
    ab94:	4211883a 	add	r8,r8,r8
    ab98:	9211883a 	add	r8,r18,r8
    ab9c:	30002226 	beq	r6,zero,ac28 <__lshift+0x130>
    aba0:	02800804 	movi	r10,32
    aba4:	5195c83a 	sub	r10,r10,r6
    aba8:	000b883a 	mov	r5,zero
    abac:	3a400017 	ldw	r9,0(r7)
    abb0:	18c00104 	addi	r3,r3,4
    abb4:	39c00104 	addi	r7,r7,4
    abb8:	4992983a 	sll	r9,r9,r6
    abbc:	2a4ab03a 	or	r5,r5,r9
    abc0:	197fff15 	stw	r5,-4(r3)
    abc4:	397fff17 	ldw	r5,-4(r7)
    abc8:	2a8ad83a 	srl	r5,r5,r10
    abcc:	3a3ff736 	bltu	r7,r8,abac <__lshift+0xb4>
    abd0:	19400015 	stw	r5,0(r3)
    abd4:	28000126 	beq	r5,zero,abdc <__lshift+0xe4>
    abd8:	ac000084 	addi	r16,r21,2
    abdc:	91000117 	ldw	r4,4(r18)
    abe0:	98c01317 	ldw	r3,76(r19)
    abe4:	843fffc4 	addi	r16,r16,-1
    abe8:	2109883a 	add	r4,r4,r4
    abec:	2109883a 	add	r4,r4,r4
    abf0:	1907883a 	add	r3,r3,r4
    abf4:	19000017 	ldw	r4,0(r3)
    abf8:	14000415 	stw	r16,16(r2)
    abfc:	91000015 	stw	r4,0(r18)
    ac00:	1c800015 	stw	r18,0(r3)
    ac04:	dfc00617 	ldw	ra,24(sp)
    ac08:	dd400517 	ldw	r21,20(sp)
    ac0c:	dd000417 	ldw	r20,16(sp)
    ac10:	dcc00317 	ldw	r19,12(sp)
    ac14:	dc800217 	ldw	r18,8(sp)
    ac18:	dc400117 	ldw	r17,4(sp)
    ac1c:	dc000017 	ldw	r16,0(sp)
    ac20:	dec00704 	addi	sp,sp,28
    ac24:	f800283a 	ret
    ac28:	39400017 	ldw	r5,0(r7)
    ac2c:	18c00104 	addi	r3,r3,4
    ac30:	39c00104 	addi	r7,r7,4
    ac34:	197fff15 	stw	r5,-4(r3)
    ac38:	3a3fe82e 	bgeu	r7,r8,abdc <__lshift+0xe4>
    ac3c:	39400017 	ldw	r5,0(r7)
    ac40:	18c00104 	addi	r3,r3,4
    ac44:	39c00104 	addi	r7,r7,4
    ac48:	197fff15 	stw	r5,-4(r3)
    ac4c:	3a3ff636 	bltu	r7,r8,ac28 <__lshift+0x130>
    ac50:	003fe206 	br	abdc <__lshift+0xe4>

0000ac54 <__mcmp>:
    ac54:	20800417 	ldw	r2,16(r4)
    ac58:	28c00417 	ldw	r3,16(r5)
    ac5c:	10c5c83a 	sub	r2,r2,r3
    ac60:	10000f1e 	bne	r2,zero,aca0 <__mcmp+0x4c>
    ac64:	18c00144 	addi	r3,r3,5
    ac68:	18c7883a 	add	r3,r3,r3
    ac6c:	18c7883a 	add	r3,r3,r3
    ac70:	21c00504 	addi	r7,r4,20
    ac74:	28cb883a 	add	r5,r5,r3
    ac78:	20c9883a 	add	r4,r4,r3
    ac7c:	213fff04 	addi	r4,r4,-4
    ac80:	297fff04 	addi	r5,r5,-4
    ac84:	21800017 	ldw	r6,0(r4)
    ac88:	28c00017 	ldw	r3,0(r5)
    ac8c:	30c0021e 	bne	r6,r3,ac98 <__mcmp+0x44>
    ac90:	393ffa36 	bltu	r7,r4,ac7c <__mcmp+0x28>
    ac94:	f800283a 	ret
    ac98:	30c00236 	bltu	r6,r3,aca4 <__mcmp+0x50>
    ac9c:	00800044 	movi	r2,1
    aca0:	f800283a 	ret
    aca4:	00bfffc4 	movi	r2,-1
    aca8:	f800283a 	ret

0000acac <__mdiff>:
    acac:	defffb04 	addi	sp,sp,-20
    acb0:	dc000015 	stw	r16,0(sp)
    acb4:	2821883a 	mov	r16,r5
    acb8:	dc800215 	stw	r18,8(sp)
    acbc:	300b883a 	mov	r5,r6
    acc0:	2025883a 	mov	r18,r4
    acc4:	8009883a 	mov	r4,r16
    acc8:	dc400115 	stw	r17,4(sp)
    accc:	dfc00415 	stw	ra,16(sp)
    acd0:	dcc00315 	stw	r19,12(sp)
    acd4:	3023883a 	mov	r17,r6
    acd8:	000ac540 	call	ac54 <__mcmp>
    acdc:	10005026 	beq	r2,zero,ae20 <__mdiff+0x174>
    ace0:	10004a16 	blt	r2,zero,ae0c <__mdiff+0x160>
    ace4:	0027883a 	mov	r19,zero
    ace8:	81400117 	ldw	r5,4(r16)
    acec:	9009883a 	mov	r4,r18
    acf0:	000a3b00 	call	a3b0 <_Balloc>
    acf4:	82400417 	ldw	r9,16(r16)
    acf8:	89800417 	ldw	r6,16(r17)
    acfc:	14c00315 	stw	r19,12(r2)
    ad00:	4b800144 	addi	r14,r9,5
    ad04:	31800144 	addi	r6,r6,5
    ad08:	739d883a 	add	r14,r14,r14
    ad0c:	318d883a 	add	r6,r6,r6
    ad10:	739d883a 	add	r14,r14,r14
    ad14:	318d883a 	add	r6,r6,r6
    ad18:	81c00504 	addi	r7,r16,20
    ad1c:	839d883a 	add	r14,r16,r14
    ad20:	8a000504 	addi	r8,r17,20
    ad24:	898d883a 	add	r6,r17,r6
    ad28:	10c00504 	addi	r3,r2,20
    ad2c:	0009883a 	mov	r4,zero
    ad30:	3b000017 	ldw	r12,0(r7)
    ad34:	42c00017 	ldw	r11,0(r8)
    ad38:	42000104 	addi	r8,r8,4
    ad3c:	62bfffcc 	andi	r10,r12,65535
    ad40:	5b7fffcc 	andi	r13,r11,65535
    ad44:	5109883a 	add	r4,r10,r4
    ad48:	2355c83a 	sub	r10,r4,r13
    ad4c:	5816d43a 	srli	r11,r11,16
    ad50:	6008d43a 	srli	r4,r12,16
    ad54:	501bd43a 	srai	r13,r10,16
    ad58:	1a80000d 	sth	r10,0(r3)
    ad5c:	22c9c83a 	sub	r4,r4,r11
    ad60:	2349883a 	add	r4,r4,r13
    ad64:	1900008d 	sth	r4,2(r3)
    ad68:	39c00104 	addi	r7,r7,4
    ad6c:	2009d43a 	srai	r4,r4,16
    ad70:	18c00104 	addi	r3,r3,4
    ad74:	41bfee36 	bltu	r8,r6,ad30 <__mdiff+0x84>
    ad78:	180b883a 	mov	r5,r3
    ad7c:	3815883a 	mov	r10,r7
    ad80:	3b80132e 	bgeu	r7,r14,add0 <__mdiff+0x124>
    ad84:	3a000017 	ldw	r8,0(r7)
    ad88:	18c00104 	addi	r3,r3,4
    ad8c:	39c00104 	addi	r7,r7,4
    ad90:	41bfffcc 	andi	r6,r8,65535
    ad94:	310d883a 	add	r6,r6,r4
    ad98:	3009d43a 	srai	r4,r6,16
    ad9c:	4010d43a 	srli	r8,r8,16
    ada0:	19bfff0d 	sth	r6,-4(r3)
    ada4:	2209883a 	add	r4,r4,r8
    ada8:	193fff8d 	sth	r4,-2(r3)
    adac:	2009d43a 	srai	r4,r4,16
    adb0:	3bbff436 	bltu	r7,r14,ad84 <__mdiff+0xd8>
    adb4:	0286303a 	nor	r3,zero,r10
    adb8:	1b87883a 	add	r3,r3,r14
    adbc:	1806d0ba 	srli	r3,r3,2
    adc0:	18c00044 	addi	r3,r3,1
    adc4:	18c7883a 	add	r3,r3,r3
    adc8:	18c7883a 	add	r3,r3,r3
    adcc:	28c7883a 	add	r3,r5,r3
    add0:	193fff17 	ldw	r4,-4(r3)
    add4:	18ffff04 	addi	r3,r3,-4
    add8:	2000041e 	bne	r4,zero,adec <__mdiff+0x140>
    addc:	18ffff04 	addi	r3,r3,-4
    ade0:	19000017 	ldw	r4,0(r3)
    ade4:	4a7fffc4 	addi	r9,r9,-1
    ade8:	203ffc26 	beq	r4,zero,addc <__mdiff+0x130>
    adec:	12400415 	stw	r9,16(r2)
    adf0:	dfc00417 	ldw	ra,16(sp)
    adf4:	dcc00317 	ldw	r19,12(sp)
    adf8:	dc800217 	ldw	r18,8(sp)
    adfc:	dc400117 	ldw	r17,4(sp)
    ae00:	dc000017 	ldw	r16,0(sp)
    ae04:	dec00504 	addi	sp,sp,20
    ae08:	f800283a 	ret
    ae0c:	8005883a 	mov	r2,r16
    ae10:	04c00044 	movi	r19,1
    ae14:	8821883a 	mov	r16,r17
    ae18:	1023883a 	mov	r17,r2
    ae1c:	003fb206 	br	ace8 <__mdiff+0x3c>
    ae20:	9009883a 	mov	r4,r18
    ae24:	000b883a 	mov	r5,zero
    ae28:	000a3b00 	call	a3b0 <_Balloc>
    ae2c:	00c00044 	movi	r3,1
    ae30:	10c00415 	stw	r3,16(r2)
    ae34:	10000515 	stw	zero,20(r2)
    ae38:	dfc00417 	ldw	ra,16(sp)
    ae3c:	dcc00317 	ldw	r19,12(sp)
    ae40:	dc800217 	ldw	r18,8(sp)
    ae44:	dc400117 	ldw	r17,4(sp)
    ae48:	dc000017 	ldw	r16,0(sp)
    ae4c:	dec00504 	addi	sp,sp,20
    ae50:	f800283a 	ret

0000ae54 <__ulp>:
    ae54:	295ffc2c 	andhi	r5,r5,32752
    ae58:	00bf3034 	movhi	r2,64704
    ae5c:	2887883a 	add	r3,r5,r2
    ae60:	00c0020e 	bge	zero,r3,ae6c <__ulp+0x18>
    ae64:	0005883a 	mov	r2,zero
    ae68:	f800283a 	ret
    ae6c:	00c7c83a 	sub	r3,zero,r3
    ae70:	1805d53a 	srai	r2,r3,20
    ae74:	00c004c4 	movi	r3,19
    ae78:	18800a0e 	bge	r3,r2,aea4 <__ulp+0x50>
    ae7c:	01000c84 	movi	r4,50
    ae80:	0007883a 	mov	r3,zero
    ae84:	20800516 	blt	r4,r2,ae9c <__ulp+0x48>
    ae88:	01000cc4 	movi	r4,51
    ae8c:	2085c83a 	sub	r2,r4,r2
    ae90:	01000044 	movi	r4,1
    ae94:	2084983a 	sll	r2,r4,r2
    ae98:	f800283a 	ret
    ae9c:	00800044 	movi	r2,1
    aea0:	f800283a 	ret
    aea4:	00c00234 	movhi	r3,8
    aea8:	1887d83a 	sra	r3,r3,r2
    aeac:	0005883a 	mov	r2,zero
    aeb0:	f800283a 	ret

0000aeb4 <__b2d>:
    aeb4:	defffa04 	addi	sp,sp,-24
    aeb8:	dc000015 	stw	r16,0(sp)
    aebc:	24000417 	ldw	r16,16(r4)
    aec0:	dc400115 	stw	r17,4(sp)
    aec4:	dcc00315 	stw	r19,12(sp)
    aec8:	84000144 	addi	r16,r16,5
    aecc:	8421883a 	add	r16,r16,r16
    aed0:	8421883a 	add	r16,r16,r16
    aed4:	2421883a 	add	r16,r4,r16
    aed8:	847fff17 	ldw	r17,-4(r16)
    aedc:	24c00504 	addi	r19,r4,20
    aee0:	dd000415 	stw	r20,16(sp)
    aee4:	8809883a 	mov	r4,r17
    aee8:	dc800215 	stw	r18,8(sp)
    aeec:	2829883a 	mov	r20,r5
    aef0:	dfc00515 	stw	ra,20(sp)
    aef4:	000a6980 	call	a698 <__hi0bits>
    aef8:	00c00804 	movi	r3,32
    aefc:	1887c83a 	sub	r3,r3,r2
    af00:	a0c00015 	stw	r3,0(r20)
    af04:	00c00284 	movi	r3,10
    af08:	84bfff04 	addi	r18,r16,-4
    af0c:	18801216 	blt	r3,r2,af58 <__b2d+0xa4>
    af10:	010002c4 	movi	r4,11
    af14:	2089c83a 	sub	r4,r4,r2
    af18:	8906d83a 	srl	r3,r17,r4
    af1c:	18cffc34 	orhi	r3,r3,16368
    af20:	9c80322e 	bgeu	r19,r18,afec <__b2d+0x138>
    af24:	817ffe17 	ldw	r5,-8(r16)
    af28:	2908d83a 	srl	r4,r5,r4
    af2c:	10800544 	addi	r2,r2,21
    af30:	88a2983a 	sll	r17,r17,r2
    af34:	2444b03a 	or	r2,r4,r17
    af38:	dfc00517 	ldw	ra,20(sp)
    af3c:	dd000417 	ldw	r20,16(sp)
    af40:	dcc00317 	ldw	r19,12(sp)
    af44:	dc800217 	ldw	r18,8(sp)
    af48:	dc400117 	ldw	r17,4(sp)
    af4c:	dc000017 	ldw	r16,0(sp)
    af50:	dec00604 	addi	sp,sp,24
    af54:	f800283a 	ret
    af58:	9c801636 	bltu	r19,r18,afb4 <__b2d+0x100>
    af5c:	113ffd44 	addi	r4,r2,-11
    af60:	000b883a 	mov	r5,zero
    af64:	20001726 	beq	r4,zero,afc4 <__b2d+0x110>
    af68:	00c00ac4 	movi	r3,43
    af6c:	1885c83a 	sub	r2,r3,r2
    af70:	8906983a 	sll	r3,r17,r4
    af74:	288cd83a 	srl	r6,r5,r2
    af78:	18cffc34 	orhi	r3,r3,16368
    af7c:	1986b03a 	or	r3,r3,r6
    af80:	9c801c2e 	bgeu	r19,r18,aff4 <__b2d+0x140>
    af84:	91bfff17 	ldw	r6,-4(r18)
    af88:	3084d83a 	srl	r2,r6,r2
    af8c:	2908983a 	sll	r4,r5,r4
    af90:	1104b03a 	or	r2,r2,r4
    af94:	dfc00517 	ldw	ra,20(sp)
    af98:	dd000417 	ldw	r20,16(sp)
    af9c:	dcc00317 	ldw	r19,12(sp)
    afa0:	dc800217 	ldw	r18,8(sp)
    afa4:	dc400117 	ldw	r17,4(sp)
    afa8:	dc000017 	ldw	r16,0(sp)
    afac:	dec00604 	addi	sp,sp,24
    afb0:	f800283a 	ret
    afb4:	113ffd44 	addi	r4,r2,-11
    afb8:	84bffe04 	addi	r18,r16,-8
    afbc:	817ffe17 	ldw	r5,-8(r16)
    afc0:	203fe91e 	bne	r4,zero,af68 <__b2d+0xb4>
    afc4:	88cffc34 	orhi	r3,r17,16368
    afc8:	2805883a 	mov	r2,r5
    afcc:	dfc00517 	ldw	ra,20(sp)
    afd0:	dd000417 	ldw	r20,16(sp)
    afd4:	dcc00317 	ldw	r19,12(sp)
    afd8:	dc800217 	ldw	r18,8(sp)
    afdc:	dc400117 	ldw	r17,4(sp)
    afe0:	dc000017 	ldw	r16,0(sp)
    afe4:	dec00604 	addi	sp,sp,24
    afe8:	f800283a 	ret
    afec:	0009883a 	mov	r4,zero
    aff0:	003fce06 	br	af2c <__b2d+0x78>
    aff4:	0005883a 	mov	r2,zero
    aff8:	003fe406 	br	af8c <__b2d+0xd8>

0000affc <__d2b>:
    affc:	defff804 	addi	sp,sp,-32
    b000:	dc400315 	stw	r17,12(sp)
    b004:	3023883a 	mov	r17,r6
    b008:	dc800415 	stw	r18,16(sp)
    b00c:	8824907a 	slli	r18,r17,1
    b010:	dcc00515 	stw	r19,20(sp)
    b014:	2827883a 	mov	r19,r5
    b018:	9024d57a 	srli	r18,r18,21
    b01c:	01400044 	movi	r5,1
    b020:	dd000615 	stw	r20,24(sp)
    b024:	dc000215 	stw	r16,8(sp)
    b028:	dfc00715 	stw	ra,28(sp)
    b02c:	3829883a 	mov	r20,r7
    b030:	000a3b00 	call	a3b0 <_Balloc>
    b034:	1021883a 	mov	r16,r2
    b038:	00800434 	movhi	r2,16
    b03c:	10bfffc4 	addi	r2,r2,-1
    b040:	88a2703a 	and	r17,r17,r2
    b044:	90000126 	beq	r18,zero,b04c <__d2b+0x50>
    b048:	8c400434 	orhi	r17,r17,16
    b04c:	dc400015 	stw	r17,0(sp)
    b050:	98002226 	beq	r19,zero,b0dc <__d2b+0xe0>
    b054:	d9000104 	addi	r4,sp,4
    b058:	dcc00115 	stw	r19,4(sp)
    b05c:	000a7000 	call	a700 <__lo0bits>
    b060:	d8c00017 	ldw	r3,0(sp)
    b064:	10002d1e 	bne	r2,zero,b11c <__d2b+0x120>
    b068:	d9000117 	ldw	r4,4(sp)
    b06c:	81000515 	stw	r4,20(r16)
    b070:	1823003a 	cmpeq	r17,r3,zero
    b074:	01000084 	movi	r4,2
    b078:	2463c83a 	sub	r17,r4,r17
    b07c:	80c00615 	stw	r3,24(r16)
    b080:	84400415 	stw	r17,16(r16)
    b084:	90001d1e 	bne	r18,zero,b0fc <__d2b+0x100>
    b088:	88c00104 	addi	r3,r17,4
    b08c:	18c7883a 	add	r3,r3,r3
    b090:	18c7883a 	add	r3,r3,r3
    b094:	80c7883a 	add	r3,r16,r3
    b098:	19000017 	ldw	r4,0(r3)
    b09c:	10bef384 	addi	r2,r2,-1074
    b0a0:	a0800015 	stw	r2,0(r20)
    b0a4:	000a6980 	call	a698 <__hi0bits>
    b0a8:	8822917a 	slli	r17,r17,5
    b0ac:	d8c00817 	ldw	r3,32(sp)
    b0b0:	8885c83a 	sub	r2,r17,r2
    b0b4:	18800015 	stw	r2,0(r3)
    b0b8:	8005883a 	mov	r2,r16
    b0bc:	dfc00717 	ldw	ra,28(sp)
    b0c0:	dd000617 	ldw	r20,24(sp)
    b0c4:	dcc00517 	ldw	r19,20(sp)
    b0c8:	dc800417 	ldw	r18,16(sp)
    b0cc:	dc400317 	ldw	r17,12(sp)
    b0d0:	dc000217 	ldw	r16,8(sp)
    b0d4:	dec00804 	addi	sp,sp,32
    b0d8:	f800283a 	ret
    b0dc:	d809883a 	mov	r4,sp
    b0e0:	000a7000 	call	a700 <__lo0bits>
    b0e4:	d8c00017 	ldw	r3,0(sp)
    b0e8:	04400044 	movi	r17,1
    b0ec:	84400415 	stw	r17,16(r16)
    b0f0:	80c00515 	stw	r3,20(r16)
    b0f4:	10800804 	addi	r2,r2,32
    b0f8:	903fe326 	beq	r18,zero,b088 <__d2b+0x8c>
    b0fc:	00c00d44 	movi	r3,53
    b100:	94bef344 	addi	r18,r18,-1075
    b104:	90a5883a 	add	r18,r18,r2
    b108:	1885c83a 	sub	r2,r3,r2
    b10c:	d8c00817 	ldw	r3,32(sp)
    b110:	a4800015 	stw	r18,0(r20)
    b114:	18800015 	stw	r2,0(r3)
    b118:	003fe706 	br	b0b8 <__d2b+0xbc>
    b11c:	01000804 	movi	r4,32
    b120:	2089c83a 	sub	r4,r4,r2
    b124:	1908983a 	sll	r4,r3,r4
    b128:	d9400117 	ldw	r5,4(sp)
    b12c:	1886d83a 	srl	r3,r3,r2
    b130:	2148b03a 	or	r4,r4,r5
    b134:	81000515 	stw	r4,20(r16)
    b138:	d8c00015 	stw	r3,0(sp)
    b13c:	003fcc06 	br	b070 <__d2b+0x74>

0000b140 <__ratio>:
    b140:	defff904 	addi	sp,sp,-28
    b144:	dc400315 	stw	r17,12(sp)
    b148:	2823883a 	mov	r17,r5
    b14c:	d9400104 	addi	r5,sp,4
    b150:	dfc00615 	stw	ra,24(sp)
    b154:	dcc00515 	stw	r19,20(sp)
    b158:	dc800415 	stw	r18,16(sp)
    b15c:	2027883a 	mov	r19,r4
    b160:	dc000215 	stw	r16,8(sp)
    b164:	000aeb40 	call	aeb4 <__b2d>
    b168:	8809883a 	mov	r4,r17
    b16c:	d80b883a 	mov	r5,sp
    b170:	1025883a 	mov	r18,r2
    b174:	1821883a 	mov	r16,r3
    b178:	000aeb40 	call	aeb4 <__b2d>
    b17c:	99400417 	ldw	r5,16(r19)
    b180:	89000417 	ldw	r4,16(r17)
    b184:	d9800117 	ldw	r6,4(sp)
    b188:	2909c83a 	sub	r4,r5,r4
    b18c:	d9400017 	ldw	r5,0(sp)
    b190:	2008917a 	slli	r4,r4,5
    b194:	314bc83a 	sub	r5,r6,r5
    b198:	290b883a 	add	r5,r5,r4
    b19c:	01400e0e 	bge	zero,r5,b1d8 <__ratio+0x98>
    b1a0:	280a953a 	slli	r5,r5,20
    b1a4:	2c21883a 	add	r16,r5,r16
    b1a8:	9009883a 	mov	r4,r18
    b1ac:	800b883a 	mov	r5,r16
    b1b0:	100d883a 	mov	r6,r2
    b1b4:	180f883a 	mov	r7,r3
    b1b8:	000d5c40 	call	d5c4 <__divdf3>
    b1bc:	dfc00617 	ldw	ra,24(sp)
    b1c0:	dcc00517 	ldw	r19,20(sp)
    b1c4:	dc800417 	ldw	r18,16(sp)
    b1c8:	dc400317 	ldw	r17,12(sp)
    b1cc:	dc000217 	ldw	r16,8(sp)
    b1d0:	dec00704 	addi	sp,sp,28
    b1d4:	f800283a 	ret
    b1d8:	280a953a 	slli	r5,r5,20
    b1dc:	1947c83a 	sub	r3,r3,r5
    b1e0:	003ff106 	br	b1a8 <__ratio+0x68>

0000b1e4 <_mprec_log10>:
    b1e4:	defffe04 	addi	sp,sp,-8
    b1e8:	dc000015 	stw	r16,0(sp)
    b1ec:	dfc00115 	stw	ra,4(sp)
    b1f0:	008005c4 	movi	r2,23
    b1f4:	2021883a 	mov	r16,r4
    b1f8:	11000d0e 	bge	r2,r4,b230 <_mprec_log10+0x4c>
    b1fc:	0005883a 	mov	r2,zero
    b200:	00cffc34 	movhi	r3,16368
    b204:	843fffc4 	addi	r16,r16,-1
    b208:	1009883a 	mov	r4,r2
    b20c:	180b883a 	mov	r5,r3
    b210:	000d883a 	mov	r6,zero
    b214:	01d00934 	movhi	r7,16420
    b218:	000d2e00 	call	d2e0 <__muldf3>
    b21c:	803ff91e 	bne	r16,zero,b204 <_mprec_log10+0x20>
    b220:	dfc00117 	ldw	ra,4(sp)
    b224:	dc000017 	ldw	r16,0(sp)
    b228:	dec00204 	addi	sp,sp,8
    b22c:	f800283a 	ret
    b230:	202090fa 	slli	r16,r4,3
    b234:	00800134 	movhi	r2,4
    b238:	1081ea04 	addi	r2,r2,1960
    b23c:	1421883a 	add	r16,r2,r16
    b240:	80800017 	ldw	r2,0(r16)
    b244:	80c00117 	ldw	r3,4(r16)
    b248:	dfc00117 	ldw	ra,4(sp)
    b24c:	dc000017 	ldw	r16,0(sp)
    b250:	dec00204 	addi	sp,sp,8
    b254:	f800283a 	ret

0000b258 <__copybits>:
    b258:	297fffc4 	addi	r5,r5,-1
    b25c:	31c00417 	ldw	r7,16(r6)
    b260:	2811d17a 	srai	r8,r5,5
    b264:	30800504 	addi	r2,r6,20
    b268:	39c00144 	addi	r7,r7,5
    b26c:	42000044 	addi	r8,r8,1
    b270:	39cf883a 	add	r7,r7,r7
    b274:	4211883a 	add	r8,r8,r8
    b278:	39cf883a 	add	r7,r7,r7
    b27c:	4211883a 	add	r8,r8,r8
    b280:	31cf883a 	add	r7,r6,r7
    b284:	2211883a 	add	r8,r4,r8
    b288:	11c00d2e 	bgeu	r2,r7,b2c0 <__copybits+0x68>
    b28c:	2007883a 	mov	r3,r4
    b290:	11400017 	ldw	r5,0(r2)
    b294:	18c00104 	addi	r3,r3,4
    b298:	10800104 	addi	r2,r2,4
    b29c:	197fff15 	stw	r5,-4(r3)
    b2a0:	11fffb36 	bltu	r2,r7,b290 <__copybits+0x38>
    b2a4:	3985c83a 	sub	r2,r7,r6
    b2a8:	10bffac4 	addi	r2,r2,-21
    b2ac:	1004d0ba 	srli	r2,r2,2
    b2b0:	10800044 	addi	r2,r2,1
    b2b4:	1085883a 	add	r2,r2,r2
    b2b8:	1085883a 	add	r2,r2,r2
    b2bc:	2089883a 	add	r4,r4,r2
    b2c0:	2200032e 	bgeu	r4,r8,b2d0 <__copybits+0x78>
    b2c4:	20000015 	stw	zero,0(r4)
    b2c8:	21000104 	addi	r4,r4,4
    b2cc:	223ffd36 	bltu	r4,r8,b2c4 <__copybits+0x6c>
    b2d0:	f800283a 	ret

0000b2d4 <__any_on>:
    b2d4:	21800417 	ldw	r6,16(r4)
    b2d8:	2805d17a 	srai	r2,r5,5
    b2dc:	20c00504 	addi	r3,r4,20
    b2e0:	30800f0e 	bge	r6,r2,b320 <__any_on+0x4c>
    b2e4:	3005883a 	mov	r2,r6
    b2e8:	10800144 	addi	r2,r2,5
    b2ec:	1085883a 	add	r2,r2,r2
    b2f0:	1085883a 	add	r2,r2,r2
    b2f4:	2089883a 	add	r4,r4,r2
    b2f8:	1900152e 	bgeu	r3,r4,b350 <__any_on+0x7c>
    b2fc:	20bfff17 	ldw	r2,-4(r4)
    b300:	213fff04 	addi	r4,r4,-4
    b304:	1000041e 	bne	r2,zero,b318 <__any_on+0x44>
    b308:	1900112e 	bgeu	r3,r4,b350 <__any_on+0x7c>
    b30c:	213fff04 	addi	r4,r4,-4
    b310:	20800017 	ldw	r2,0(r4)
    b314:	103ffc26 	beq	r2,zero,b308 <__any_on+0x34>
    b318:	00800044 	movi	r2,1
    b31c:	f800283a 	ret
    b320:	11bff10e 	bge	r2,r6,b2e8 <__any_on+0x14>
    b324:	294007cc 	andi	r5,r5,31
    b328:	283fef26 	beq	r5,zero,b2e8 <__any_on+0x14>
    b32c:	11800144 	addi	r6,r2,5
    b330:	318d883a 	add	r6,r6,r6
    b334:	318d883a 	add	r6,r6,r6
    b338:	218d883a 	add	r6,r4,r6
    b33c:	31800017 	ldw	r6,0(r6)
    b340:	314ed83a 	srl	r7,r6,r5
    b344:	394a983a 	sll	r5,r7,r5
    b348:	29bff31e 	bne	r5,r6,b318 <__any_on+0x44>
    b34c:	003fe606 	br	b2e8 <__any_on+0x14>
    b350:	0005883a 	mov	r2,zero
    b354:	f800283a 	ret

0000b358 <_putc_r>:
    b358:	defffc04 	addi	sp,sp,-16
    b35c:	dc000215 	stw	r16,8(sp)
    b360:	dfc00315 	stw	ra,12(sp)
    b364:	2021883a 	mov	r16,r4
    b368:	20000226 	beq	r4,zero,b374 <_putc_r+0x1c>
    b36c:	20800e17 	ldw	r2,56(r4)
    b370:	10001d26 	beq	r2,zero,b3e8 <_putc_r+0x90>
    b374:	30800217 	ldw	r2,8(r6)
    b378:	10bfffc4 	addi	r2,r2,-1
    b37c:	30800215 	stw	r2,8(r6)
    b380:	10000a16 	blt	r2,zero,b3ac <_putc_r+0x54>
    b384:	30800017 	ldw	r2,0(r6)
    b388:	11400005 	stb	r5,0(r2)
    b38c:	30800017 	ldw	r2,0(r6)
    b390:	10c00044 	addi	r3,r2,1
    b394:	10800003 	ldbu	r2,0(r2)
    b398:	30c00015 	stw	r3,0(r6)
    b39c:	dfc00317 	ldw	ra,12(sp)
    b3a0:	dc000217 	ldw	r16,8(sp)
    b3a4:	dec00404 	addi	sp,sp,16
    b3a8:	f800283a 	ret
    b3ac:	30c00617 	ldw	r3,24(r6)
    b3b0:	10c01316 	blt	r2,r3,b400 <_putc_r+0xa8>
    b3b4:	30800017 	ldw	r2,0(r6)
    b3b8:	01000284 	movi	r4,10
    b3bc:	11400005 	stb	r5,0(r2)
    b3c0:	30c00017 	ldw	r3,0(r6)
    b3c4:	19400003 	ldbu	r5,0(r3)
    b3c8:	29000d26 	beq	r5,r4,b400 <_putc_r+0xa8>
    b3cc:	18c00044 	addi	r3,r3,1
    b3d0:	2805883a 	mov	r2,r5
    b3d4:	30c00015 	stw	r3,0(r6)
    b3d8:	dfc00317 	ldw	ra,12(sp)
    b3dc:	dc000217 	ldw	r16,8(sp)
    b3e0:	dec00404 	addi	sp,sp,16
    b3e4:	f800283a 	ret
    b3e8:	d9400015 	stw	r5,0(sp)
    b3ec:	d9800115 	stw	r6,4(sp)
    b3f0:	00089bc0 	call	89bc <__sinit>
    b3f4:	d9800117 	ldw	r6,4(sp)
    b3f8:	d9400017 	ldw	r5,0(sp)
    b3fc:	003fdd06 	br	b374 <_putc_r+0x1c>
    b400:	8009883a 	mov	r4,r16
    b404:	dfc00317 	ldw	ra,12(sp)
    b408:	dc000217 	ldw	r16,8(sp)
    b40c:	dec00404 	addi	sp,sp,16
    b410:	000bdac1 	jmpi	bdac <__swbuf_r>

0000b414 <putc>:
    b414:	defffc04 	addi	sp,sp,-16
    b418:	dc400115 	stw	r17,4(sp)
    b41c:	04400134 	movhi	r17,4
    b420:	8c55bf04 	addi	r17,r17,22268
    b424:	88800017 	ldw	r2,0(r17)
    b428:	dc800215 	stw	r18,8(sp)
    b42c:	dc000015 	stw	r16,0(sp)
    b430:	dfc00315 	stw	ra,12(sp)
    b434:	2025883a 	mov	r18,r4
    b438:	2821883a 	mov	r16,r5
    b43c:	10000226 	beq	r2,zero,b448 <putc+0x34>
    b440:	10c00e17 	ldw	r3,56(r2)
    b444:	18002126 	beq	r3,zero,b4cc <putc+0xb8>
    b448:	80800217 	ldw	r2,8(r16)
    b44c:	10bfffc4 	addi	r2,r2,-1
    b450:	80800215 	stw	r2,8(r16)
    b454:	10000c16 	blt	r2,zero,b488 <putc+0x74>
    b458:	80800017 	ldw	r2,0(r16)
    b45c:	14800005 	stb	r18,0(r2)
    b460:	80800017 	ldw	r2,0(r16)
    b464:	10c00044 	addi	r3,r2,1
    b468:	10800003 	ldbu	r2,0(r2)
    b46c:	80c00015 	stw	r3,0(r16)
    b470:	dfc00317 	ldw	ra,12(sp)
    b474:	dc800217 	ldw	r18,8(sp)
    b478:	dc400117 	ldw	r17,4(sp)
    b47c:	dc000017 	ldw	r16,0(sp)
    b480:	dec00404 	addi	sp,sp,16
    b484:	f800283a 	ret
    b488:	80c00617 	ldw	r3,24(r16)
    b48c:	10c01216 	blt	r2,r3,b4d8 <putc+0xc4>
    b490:	80800017 	ldw	r2,0(r16)
    b494:	01000284 	movi	r4,10
    b498:	14800005 	stb	r18,0(r2)
    b49c:	80c00017 	ldw	r3,0(r16)
    b4a0:	19400003 	ldbu	r5,0(r3)
    b4a4:	29001526 	beq	r5,r4,b4fc <putc+0xe8>
    b4a8:	18c00044 	addi	r3,r3,1
    b4ac:	2805883a 	mov	r2,r5
    b4b0:	80c00015 	stw	r3,0(r16)
    b4b4:	dfc00317 	ldw	ra,12(sp)
    b4b8:	dc800217 	ldw	r18,8(sp)
    b4bc:	dc400117 	ldw	r17,4(sp)
    b4c0:	dc000017 	ldw	r16,0(sp)
    b4c4:	dec00404 	addi	sp,sp,16
    b4c8:	f800283a 	ret
    b4cc:	1009883a 	mov	r4,r2
    b4d0:	00089bc0 	call	89bc <__sinit>
    b4d4:	003fdc06 	br	b448 <putc+0x34>
    b4d8:	89000017 	ldw	r4,0(r17)
    b4dc:	900b883a 	mov	r5,r18
    b4e0:	800d883a 	mov	r6,r16
    b4e4:	dfc00317 	ldw	ra,12(sp)
    b4e8:	dc800217 	ldw	r18,8(sp)
    b4ec:	dc400117 	ldw	r17,4(sp)
    b4f0:	dc000017 	ldw	r16,0(sp)
    b4f4:	dec00404 	addi	sp,sp,16
    b4f8:	000bdac1 	jmpi	bdac <__swbuf_r>
    b4fc:	89000017 	ldw	r4,0(r17)
    b500:	003ff706 	br	b4e0 <putc+0xcc>

0000b504 <_realloc_r>:
    b504:	defff504 	addi	sp,sp,-44
    b508:	dd400615 	stw	r21,24(sp)
    b50c:	dc800315 	stw	r18,12(sp)
    b510:	dc000115 	stw	r16,4(sp)
    b514:	dfc00a15 	stw	ra,40(sp)
    b518:	df000915 	stw	fp,36(sp)
    b51c:	ddc00815 	stw	r23,32(sp)
    b520:	dd800715 	stw	r22,28(sp)
    b524:	dd000515 	stw	r20,20(sp)
    b528:	dcc00415 	stw	r19,16(sp)
    b52c:	dc400215 	stw	r17,8(sp)
    b530:	2821883a 	mov	r16,r5
    b534:	202b883a 	mov	r21,r4
    b538:	3025883a 	mov	r18,r6
    b53c:	28009626 	beq	r5,zero,b798 <_realloc_r+0x294>
    b540:	000e3f40 	call	e3f4 <__malloc_lock>
    b544:	80bfff17 	ldw	r2,-4(r16)
    b548:	04ffff04 	movi	r19,-4
    b54c:	90c002c4 	addi	r3,r18,11
    b550:	01000584 	movi	r4,22
    b554:	85bffe04 	addi	r22,r16,-8
    b558:	14e6703a 	and	r19,r2,r19
    b55c:	20c0372e 	bgeu	r4,r3,b63c <_realloc_r+0x138>
    b560:	047ffe04 	movi	r17,-8
    b564:	1c62703a 	and	r17,r3,r17
    b568:	8807883a 	mov	r3,r17
    b56c:	88005a16 	blt	r17,zero,b6d8 <_realloc_r+0x1d4>
    b570:	8c805936 	bltu	r17,r18,b6d8 <_realloc_r+0x1d4>
    b574:	98c0340e 	bge	r19,r3,b648 <_realloc_r+0x144>
    b578:	07000134 	movhi	fp,4
    b57c:	e70e4f04 	addi	fp,fp,14652
    b580:	e1400217 	ldw	r5,8(fp)
    b584:	b4c9883a 	add	r4,r22,r19
    b588:	29009026 	beq	r5,r4,b7cc <_realloc_r+0x2c8>
    b58c:	21800117 	ldw	r6,4(r4)
    b590:	01ffff84 	movi	r7,-2
    b594:	31ce703a 	and	r7,r6,r7
    b598:	21cf883a 	add	r7,r4,r7
    b59c:	39c00117 	ldw	r7,4(r7)
    b5a0:	39c0004c 	andi	r7,r7,1
    b5a4:	38004326 	beq	r7,zero,b6b4 <_realloc_r+0x1b0>
    b5a8:	000d883a 	mov	r6,zero
    b5ac:	0009883a 	mov	r4,zero
    b5b0:	1080004c 	andi	r2,r2,1
    b5b4:	10005a1e 	bne	r2,zero,b720 <_realloc_r+0x21c>
    b5b8:	85fffe17 	ldw	r23,-8(r16)
    b5bc:	00bfff04 	movi	r2,-4
    b5c0:	b5efc83a 	sub	r23,r22,r23
    b5c4:	b9c00117 	ldw	r7,4(r23)
    b5c8:	388e703a 	and	r7,r7,r2
    b5cc:	3ccf883a 	add	r7,r7,r19
    b5d0:	20005226 	beq	r4,zero,b71c <_realloc_r+0x218>
    b5d4:	31e9883a 	add	r20,r6,r7
    b5d8:	2140c726 	beq	r4,r5,b8f8 <_realloc_r+0x3f4>
    b5dc:	a0c04f16 	blt	r20,r3,b71c <_realloc_r+0x218>
    b5e0:	20800317 	ldw	r2,12(r4)
    b5e4:	20c00217 	ldw	r3,8(r4)
    b5e8:	99bfff04 	addi	r6,r19,-4
    b5ec:	01000904 	movi	r4,36
    b5f0:	18800315 	stw	r2,12(r3)
    b5f4:	10c00215 	stw	r3,8(r2)
    b5f8:	b8c00217 	ldw	r3,8(r23)
    b5fc:	b8800317 	ldw	r2,12(r23)
    b600:	bc800204 	addi	r18,r23,8
    b604:	18800315 	stw	r2,12(r3)
    b608:	10c00215 	stw	r3,8(r2)
    b60c:	2180ed36 	bltu	r4,r6,b9c4 <_realloc_r+0x4c0>
    b610:	008004c4 	movi	r2,19
    b614:	11809b2e 	bgeu	r2,r6,b884 <_realloc_r+0x380>
    b618:	80800017 	ldw	r2,0(r16)
    b61c:	b8800215 	stw	r2,8(r23)
    b620:	80800117 	ldw	r2,4(r16)
    b624:	b8800315 	stw	r2,12(r23)
    b628:	008006c4 	movi	r2,27
    b62c:	1180f936 	bltu	r2,r6,ba14 <_realloc_r+0x510>
    b630:	b8800404 	addi	r2,r23,16
    b634:	80c00204 	addi	r3,r16,8
    b638:	00009406 	br	b88c <_realloc_r+0x388>
    b63c:	00c00404 	movi	r3,16
    b640:	1823883a 	mov	r17,r3
    b644:	003fca06 	br	b570 <_realloc_r+0x6c>
    b648:	9829883a 	mov	r20,r19
    b64c:	a447c83a 	sub	r3,r20,r17
    b650:	010003c4 	movi	r4,15
    b654:	1080004c 	andi	r2,r2,1
    b658:	20c02336 	bltu	r4,r3,b6e8 <_realloc_r+0x1e4>
    b65c:	1504b03a 	or	r2,r2,r20
    b660:	b0800115 	stw	r2,4(r22)
    b664:	b52d883a 	add	r22,r22,r20
    b668:	b0800117 	ldw	r2,4(r22)
    b66c:	10800054 	ori	r2,r2,1
    b670:	b0800115 	stw	r2,4(r22)
    b674:	a809883a 	mov	r4,r21
    b678:	000e4540 	call	e454 <__malloc_unlock>
    b67c:	8025883a 	mov	r18,r16
    b680:	9005883a 	mov	r2,r18
    b684:	dfc00a17 	ldw	ra,40(sp)
    b688:	df000917 	ldw	fp,36(sp)
    b68c:	ddc00817 	ldw	r23,32(sp)
    b690:	dd800717 	ldw	r22,28(sp)
    b694:	dd400617 	ldw	r21,24(sp)
    b698:	dd000517 	ldw	r20,20(sp)
    b69c:	dcc00417 	ldw	r19,16(sp)
    b6a0:	dc800317 	ldw	r18,12(sp)
    b6a4:	dc400217 	ldw	r17,8(sp)
    b6a8:	dc000117 	ldw	r16,4(sp)
    b6ac:	dec00b04 	addi	sp,sp,44
    b6b0:	f800283a 	ret
    b6b4:	01ffff04 	movi	r7,-4
    b6b8:	31cc703a 	and	r6,r6,r7
    b6bc:	34e9883a 	add	r20,r6,r19
    b6c0:	a0ffbb16 	blt	r20,r3,b5b0 <_realloc_r+0xac>
    b6c4:	20c00317 	ldw	r3,12(r4)
    b6c8:	21000217 	ldw	r4,8(r4)
    b6cc:	20c00315 	stw	r3,12(r4)
    b6d0:	19000215 	stw	r4,8(r3)
    b6d4:	003fdd06 	br	b64c <_realloc_r+0x148>
    b6d8:	00800304 	movi	r2,12
    b6dc:	a8800015 	stw	r2,0(r21)
    b6e0:	0025883a 	mov	r18,zero
    b6e4:	003fe606 	br	b680 <_realloc_r+0x17c>
    b6e8:	1444b03a 	or	r2,r2,r17
    b6ec:	b0800115 	stw	r2,4(r22)
    b6f0:	b44b883a 	add	r5,r22,r17
    b6f4:	18800054 	ori	r2,r3,1
    b6f8:	28800115 	stw	r2,4(r5)
    b6fc:	28c7883a 	add	r3,r5,r3
    b700:	18800117 	ldw	r2,4(r3)
    b704:	a809883a 	mov	r4,r21
    b708:	29400204 	addi	r5,r5,8
    b70c:	10800054 	ori	r2,r2,1
    b710:	18800115 	stw	r2,4(r3)
    b714:	0008e740 	call	8e74 <_free_r>
    b718:	003fd606 	br	b674 <_realloc_r+0x170>
    b71c:	38c0330e 	bge	r7,r3,b7ec <_realloc_r+0x2e8>
    b720:	900b883a 	mov	r5,r18
    b724:	a809883a 	mov	r4,r21
    b728:	0009a0c0 	call	9a0c <_malloc_r>
    b72c:	1025883a 	mov	r18,r2
    b730:	10001626 	beq	r2,zero,b78c <_realloc_r+0x288>
    b734:	80bfff17 	ldw	r2,-4(r16)
    b738:	00ffff84 	movi	r3,-2
    b73c:	913ffe04 	addi	r4,r18,-8
    b740:	10c6703a 	and	r3,r2,r3
    b744:	b0c7883a 	add	r3,r22,r3
    b748:	20c09926 	beq	r4,r3,b9b0 <_realloc_r+0x4ac>
    b74c:	99bfff04 	addi	r6,r19,-4
    b750:	00800904 	movi	r2,36
    b754:	11806436 	bltu	r2,r6,b8e8 <_realloc_r+0x3e4>
    b758:	00c004c4 	movi	r3,19
    b75c:	19804036 	bltu	r3,r6,b860 <_realloc_r+0x35c>
    b760:	9005883a 	mov	r2,r18
    b764:	8007883a 	mov	r3,r16
    b768:	19000017 	ldw	r4,0(r3)
    b76c:	11000015 	stw	r4,0(r2)
    b770:	19000117 	ldw	r4,4(r3)
    b774:	11000115 	stw	r4,4(r2)
    b778:	18c00217 	ldw	r3,8(r3)
    b77c:	10c00215 	stw	r3,8(r2)
    b780:	a809883a 	mov	r4,r21
    b784:	800b883a 	mov	r5,r16
    b788:	0008e740 	call	8e74 <_free_r>
    b78c:	a809883a 	mov	r4,r21
    b790:	000e4540 	call	e454 <__malloc_unlock>
    b794:	003fba06 	br	b680 <_realloc_r+0x17c>
    b798:	300b883a 	mov	r5,r6
    b79c:	dfc00a17 	ldw	ra,40(sp)
    b7a0:	df000917 	ldw	fp,36(sp)
    b7a4:	ddc00817 	ldw	r23,32(sp)
    b7a8:	dd800717 	ldw	r22,28(sp)
    b7ac:	dd400617 	ldw	r21,24(sp)
    b7b0:	dd000517 	ldw	r20,20(sp)
    b7b4:	dcc00417 	ldw	r19,16(sp)
    b7b8:	dc800317 	ldw	r18,12(sp)
    b7bc:	dc400217 	ldw	r17,8(sp)
    b7c0:	dc000117 	ldw	r16,4(sp)
    b7c4:	dec00b04 	addi	sp,sp,44
    b7c8:	0009a0c1 	jmpi	9a0c <_malloc_r>
    b7cc:	29800117 	ldw	r6,4(r5)
    b7d0:	013fff04 	movi	r4,-4
    b7d4:	89c00404 	addi	r7,r17,16
    b7d8:	310c703a 	and	r6,r6,r4
    b7dc:	34c9883a 	add	r4,r6,r19
    b7e0:	21c0340e 	bge	r4,r7,b8b4 <_realloc_r+0x3b0>
    b7e4:	2809883a 	mov	r4,r5
    b7e8:	003f7106 	br	b5b0 <_realloc_r+0xac>
    b7ec:	b8800317 	ldw	r2,12(r23)
    b7f0:	b8c00217 	ldw	r3,8(r23)
    b7f4:	99bfff04 	addi	r6,r19,-4
    b7f8:	01000904 	movi	r4,36
    b7fc:	18800315 	stw	r2,12(r3)
    b800:	10c00215 	stw	r3,8(r2)
    b804:	bc800204 	addi	r18,r23,8
    b808:	21807836 	bltu	r4,r6,b9ec <_realloc_r+0x4e8>
    b80c:	008004c4 	movi	r2,19
    b810:	1180732e 	bgeu	r2,r6,b9e0 <_realloc_r+0x4dc>
    b814:	80800017 	ldw	r2,0(r16)
    b818:	b8800215 	stw	r2,8(r23)
    b81c:	80800117 	ldw	r2,4(r16)
    b820:	b8800315 	stw	r2,12(r23)
    b824:	008006c4 	movi	r2,27
    b828:	11808936 	bltu	r2,r6,ba50 <_realloc_r+0x54c>
    b82c:	b8800404 	addi	r2,r23,16
    b830:	80c00204 	addi	r3,r16,8
    b834:	19000017 	ldw	r4,0(r3)
    b838:	9021883a 	mov	r16,r18
    b83c:	3829883a 	mov	r20,r7
    b840:	11000015 	stw	r4,0(r2)
    b844:	19000117 	ldw	r4,4(r3)
    b848:	b82d883a 	mov	r22,r23
    b84c:	11000115 	stw	r4,4(r2)
    b850:	18c00217 	ldw	r3,8(r3)
    b854:	10c00215 	stw	r3,8(r2)
    b858:	b8800117 	ldw	r2,4(r23)
    b85c:	003f7b06 	br	b64c <_realloc_r+0x148>
    b860:	80c00017 	ldw	r3,0(r16)
    b864:	90c00015 	stw	r3,0(r18)
    b868:	80c00117 	ldw	r3,4(r16)
    b86c:	90c00115 	stw	r3,4(r18)
    b870:	00c006c4 	movi	r3,27
    b874:	19804636 	bltu	r3,r6,b990 <_realloc_r+0x48c>
    b878:	90800204 	addi	r2,r18,8
    b87c:	80c00204 	addi	r3,r16,8
    b880:	003fb906 	br	b768 <_realloc_r+0x264>
    b884:	9005883a 	mov	r2,r18
    b888:	8007883a 	mov	r3,r16
    b88c:	19000017 	ldw	r4,0(r3)
    b890:	9021883a 	mov	r16,r18
    b894:	b82d883a 	mov	r22,r23
    b898:	11000015 	stw	r4,0(r2)
    b89c:	19000117 	ldw	r4,4(r3)
    b8a0:	11000115 	stw	r4,4(r2)
    b8a4:	18c00217 	ldw	r3,8(r3)
    b8a8:	10c00215 	stw	r3,8(r2)
    b8ac:	b8800117 	ldw	r2,4(r23)
    b8b0:	003f6606 	br	b64c <_realloc_r+0x148>
    b8b4:	2445c83a 	sub	r2,r4,r17
    b8b8:	b46d883a 	add	r22,r22,r17
    b8bc:	10800054 	ori	r2,r2,1
    b8c0:	b0800115 	stw	r2,4(r22)
    b8c4:	80bfff17 	ldw	r2,-4(r16)
    b8c8:	a809883a 	mov	r4,r21
    b8cc:	e5800215 	stw	r22,8(fp)
    b8d0:	1080004c 	andi	r2,r2,1
    b8d4:	88a2b03a 	or	r17,r17,r2
    b8d8:	847fff15 	stw	r17,-4(r16)
    b8dc:	000e4540 	call	e454 <__malloc_unlock>
    b8e0:	8025883a 	mov	r18,r16
    b8e4:	003f6606 	br	b680 <_realloc_r+0x17c>
    b8e8:	9009883a 	mov	r4,r18
    b8ec:	800b883a 	mov	r5,r16
    b8f0:	000a2880 	call	a288 <memmove>
    b8f4:	003fa206 	br	b780 <_realloc_r+0x27c>
    b8f8:	88800404 	addi	r2,r17,16
    b8fc:	a0bf8716 	blt	r20,r2,b71c <_realloc_r+0x218>
    b900:	b8800317 	ldw	r2,12(r23)
    b904:	b8c00217 	ldw	r3,8(r23)
    b908:	99bfff04 	addi	r6,r19,-4
    b90c:	01000904 	movi	r4,36
    b910:	18800315 	stw	r2,12(r3)
    b914:	10c00215 	stw	r3,8(r2)
    b918:	bc800204 	addi	r18,r23,8
    b91c:	21806536 	bltu	r4,r6,bab4 <_realloc_r+0x5b0>
    b920:	008004c4 	movi	r2,19
    b924:	1180592e 	bgeu	r2,r6,ba8c <_realloc_r+0x588>
    b928:	80800017 	ldw	r2,0(r16)
    b92c:	b8800215 	stw	r2,8(r23)
    b930:	80800117 	ldw	r2,4(r16)
    b934:	b8800315 	stw	r2,12(r23)
    b938:	008006c4 	movi	r2,27
    b93c:	11806136 	bltu	r2,r6,bac4 <_realloc_r+0x5c0>
    b940:	b8800404 	addi	r2,r23,16
    b944:	80c00204 	addi	r3,r16,8
    b948:	19000017 	ldw	r4,0(r3)
    b94c:	11000015 	stw	r4,0(r2)
    b950:	19000117 	ldw	r4,4(r3)
    b954:	11000115 	stw	r4,4(r2)
    b958:	18c00217 	ldw	r3,8(r3)
    b95c:	10c00215 	stw	r3,8(r2)
    b960:	a447c83a 	sub	r3,r20,r17
    b964:	bc45883a 	add	r2,r23,r17
    b968:	18c00054 	ori	r3,r3,1
    b96c:	10c00115 	stw	r3,4(r2)
    b970:	b8c00117 	ldw	r3,4(r23)
    b974:	e0800215 	stw	r2,8(fp)
    b978:	a809883a 	mov	r4,r21
    b97c:	1880004c 	andi	r2,r3,1
    b980:	88a2b03a 	or	r17,r17,r2
    b984:	bc400115 	stw	r17,4(r23)
    b988:	000e4540 	call	e454 <__malloc_unlock>
    b98c:	003f3c06 	br	b680 <_realloc_r+0x17c>
    b990:	80c00217 	ldw	r3,8(r16)
    b994:	90c00215 	stw	r3,8(r18)
    b998:	80c00317 	ldw	r3,12(r16)
    b99c:	90c00315 	stw	r3,12(r18)
    b9a0:	30802426 	beq	r6,r2,ba34 <_realloc_r+0x530>
    b9a4:	90800404 	addi	r2,r18,16
    b9a8:	80c00404 	addi	r3,r16,16
    b9ac:	003f6e06 	br	b768 <_realloc_r+0x264>
    b9b0:	953fff17 	ldw	r20,-4(r18)
    b9b4:	00ffff04 	movi	r3,-4
    b9b8:	a0e8703a 	and	r20,r20,r3
    b9bc:	a4e9883a 	add	r20,r20,r19
    b9c0:	003f2206 	br	b64c <_realloc_r+0x148>
    b9c4:	800b883a 	mov	r5,r16
    b9c8:	9009883a 	mov	r4,r18
    b9cc:	000a2880 	call	a288 <memmove>
    b9d0:	9021883a 	mov	r16,r18
    b9d4:	b8800117 	ldw	r2,4(r23)
    b9d8:	b82d883a 	mov	r22,r23
    b9dc:	003f1b06 	br	b64c <_realloc_r+0x148>
    b9e0:	9005883a 	mov	r2,r18
    b9e4:	8007883a 	mov	r3,r16
    b9e8:	003f9206 	br	b834 <_realloc_r+0x330>
    b9ec:	800b883a 	mov	r5,r16
    b9f0:	9009883a 	mov	r4,r18
    b9f4:	d9c00015 	stw	r7,0(sp)
    b9f8:	000a2880 	call	a288 <memmove>
    b9fc:	d9c00017 	ldw	r7,0(sp)
    ba00:	9021883a 	mov	r16,r18
    ba04:	b8800117 	ldw	r2,4(r23)
    ba08:	3829883a 	mov	r20,r7
    ba0c:	b82d883a 	mov	r22,r23
    ba10:	003f0e06 	br	b64c <_realloc_r+0x148>
    ba14:	80800217 	ldw	r2,8(r16)
    ba18:	b8800415 	stw	r2,16(r23)
    ba1c:	80800317 	ldw	r2,12(r16)
    ba20:	b8800515 	stw	r2,20(r23)
    ba24:	31001226 	beq	r6,r4,ba70 <_realloc_r+0x56c>
    ba28:	b8800604 	addi	r2,r23,24
    ba2c:	80c00404 	addi	r3,r16,16
    ba30:	003f9606 	br	b88c <_realloc_r+0x388>
    ba34:	81000417 	ldw	r4,16(r16)
    ba38:	90800604 	addi	r2,r18,24
    ba3c:	80c00604 	addi	r3,r16,24
    ba40:	91000415 	stw	r4,16(r18)
    ba44:	81000517 	ldw	r4,20(r16)
    ba48:	91000515 	stw	r4,20(r18)
    ba4c:	003f4606 	br	b768 <_realloc_r+0x264>
    ba50:	80800217 	ldw	r2,8(r16)
    ba54:	b8800415 	stw	r2,16(r23)
    ba58:	80800317 	ldw	r2,12(r16)
    ba5c:	b8800515 	stw	r2,20(r23)
    ba60:	31000d26 	beq	r6,r4,ba98 <_realloc_r+0x594>
    ba64:	b8800604 	addi	r2,r23,24
    ba68:	80c00404 	addi	r3,r16,16
    ba6c:	003f7106 	br	b834 <_realloc_r+0x330>
    ba70:	81000417 	ldw	r4,16(r16)
    ba74:	b8800804 	addi	r2,r23,32
    ba78:	80c00604 	addi	r3,r16,24
    ba7c:	b9000615 	stw	r4,24(r23)
    ba80:	81000517 	ldw	r4,20(r16)
    ba84:	b9000715 	stw	r4,28(r23)
    ba88:	003f8006 	br	b88c <_realloc_r+0x388>
    ba8c:	9005883a 	mov	r2,r18
    ba90:	8007883a 	mov	r3,r16
    ba94:	003fac06 	br	b948 <_realloc_r+0x444>
    ba98:	81000417 	ldw	r4,16(r16)
    ba9c:	b8800804 	addi	r2,r23,32
    baa0:	80c00604 	addi	r3,r16,24
    baa4:	b9000615 	stw	r4,24(r23)
    baa8:	81000517 	ldw	r4,20(r16)
    baac:	b9000715 	stw	r4,28(r23)
    bab0:	003f6006 	br	b834 <_realloc_r+0x330>
    bab4:	9009883a 	mov	r4,r18
    bab8:	800b883a 	mov	r5,r16
    babc:	000a2880 	call	a288 <memmove>
    bac0:	003fa706 	br	b960 <_realloc_r+0x45c>
    bac4:	80800217 	ldw	r2,8(r16)
    bac8:	b8800415 	stw	r2,16(r23)
    bacc:	80800317 	ldw	r2,12(r16)
    bad0:	b8800515 	stw	r2,20(r23)
    bad4:	31000326 	beq	r6,r4,bae4 <_realloc_r+0x5e0>
    bad8:	b8800604 	addi	r2,r23,24
    badc:	80c00404 	addi	r3,r16,16
    bae0:	003f9906 	br	b948 <_realloc_r+0x444>
    bae4:	81000417 	ldw	r4,16(r16)
    bae8:	b8800804 	addi	r2,r23,32
    baec:	80c00604 	addi	r3,r16,24
    baf0:	b9000615 	stw	r4,24(r23)
    baf4:	81000517 	ldw	r4,20(r16)
    baf8:	b9000715 	stw	r4,28(r23)
    bafc:	003f9206 	br	b948 <_realloc_r+0x444>

0000bb00 <__isinfd>:
    bb00:	0105c83a 	sub	r2,zero,r4
    bb04:	1108b03a 	or	r4,r2,r4
    bb08:	2004d7fa 	srli	r2,r4,31
    bb0c:	00e00034 	movhi	r3,32768
    bb10:	18ffffc4 	addi	r3,r3,-1
    bb14:	28ca703a 	and	r5,r5,r3
    bb18:	1144b03a 	or	r2,r2,r5
    bb1c:	00dffc34 	movhi	r3,32752
    bb20:	1885c83a 	sub	r2,r3,r2
    bb24:	0087c83a 	sub	r3,zero,r2
    bb28:	1884b03a 	or	r2,r3,r2
    bb2c:	1005d7fa 	srai	r2,r2,31
    bb30:	10800044 	addi	r2,r2,1
    bb34:	f800283a 	ret

0000bb38 <__isnand>:
    bb38:	0105c83a 	sub	r2,zero,r4
    bb3c:	1108b03a 	or	r4,r2,r4
    bb40:	2004d7fa 	srli	r2,r4,31
    bb44:	00e00034 	movhi	r3,32768
    bb48:	18ffffc4 	addi	r3,r3,-1
    bb4c:	28ca703a 	and	r5,r5,r3
    bb50:	1144b03a 	or	r2,r2,r5
    bb54:	00dffc34 	movhi	r3,32752
    bb58:	1885c83a 	sub	r2,r3,r2
    bb5c:	1004d7fa 	srli	r2,r2,31
    bb60:	f800283a 	ret

0000bb64 <_sbrk_r>:
    bb64:	defffd04 	addi	sp,sp,-12
    bb68:	dc400115 	stw	r17,4(sp)
    bb6c:	dc000015 	stw	r16,0(sp)
    bb70:	2023883a 	mov	r17,r4
    bb74:	04000134 	movhi	r16,4
    bb78:	841ebe04 	addi	r16,r16,31480
    bb7c:	2809883a 	mov	r4,r5
    bb80:	dfc00215 	stw	ra,8(sp)
    bb84:	80000015 	stw	zero,0(r16)
    bb88:	00123280 	call	12328 <sbrk>
    bb8c:	00ffffc4 	movi	r3,-1
    bb90:	10c00526 	beq	r2,r3,bba8 <_sbrk_r+0x44>
    bb94:	dfc00217 	ldw	ra,8(sp)
    bb98:	dc400117 	ldw	r17,4(sp)
    bb9c:	dc000017 	ldw	r16,0(sp)
    bba0:	dec00304 	addi	sp,sp,12
    bba4:	f800283a 	ret
    bba8:	80c00017 	ldw	r3,0(r16)
    bbac:	183ff926 	beq	r3,zero,bb94 <_sbrk_r+0x30>
    bbb0:	88c00015 	stw	r3,0(r17)
    bbb4:	dfc00217 	ldw	ra,8(sp)
    bbb8:	dc400117 	ldw	r17,4(sp)
    bbbc:	dc000017 	ldw	r16,0(sp)
    bbc0:	dec00304 	addi	sp,sp,12
    bbc4:	f800283a 	ret

0000bbc8 <__sread>:
    bbc8:	defffe04 	addi	sp,sp,-8
    bbcc:	dc000015 	stw	r16,0(sp)
    bbd0:	2821883a 	mov	r16,r5
    bbd4:	2940038f 	ldh	r5,14(r5)
    bbd8:	dfc00115 	stw	ra,4(sp)
    bbdc:	000c3180 	call	c318 <_read_r>
    bbe0:	10000716 	blt	r2,zero,bc00 <__sread+0x38>
    bbe4:	80c01417 	ldw	r3,80(r16)
    bbe8:	1887883a 	add	r3,r3,r2
    bbec:	80c01415 	stw	r3,80(r16)
    bbf0:	dfc00117 	ldw	ra,4(sp)
    bbf4:	dc000017 	ldw	r16,0(sp)
    bbf8:	dec00204 	addi	sp,sp,8
    bbfc:	f800283a 	ret
    bc00:	80c0030b 	ldhu	r3,12(r16)
    bc04:	18fbffcc 	andi	r3,r3,61439
    bc08:	80c0030d 	sth	r3,12(r16)
    bc0c:	dfc00117 	ldw	ra,4(sp)
    bc10:	dc000017 	ldw	r16,0(sp)
    bc14:	dec00204 	addi	sp,sp,8
    bc18:	f800283a 	ret

0000bc1c <__swrite>:
    bc1c:	2880030b 	ldhu	r2,12(r5)
    bc20:	defffb04 	addi	sp,sp,-20
    bc24:	dcc00315 	stw	r19,12(sp)
    bc28:	10c0400c 	andi	r3,r2,256
    bc2c:	18ffffcc 	andi	r3,r3,65535
    bc30:	18e0001c 	xori	r3,r3,32768
    bc34:	dc800215 	stw	r18,8(sp)
    bc38:	dc400115 	stw	r17,4(sp)
    bc3c:	dc000015 	stw	r16,0(sp)
    bc40:	dfc00415 	stw	ra,16(sp)
    bc44:	18e00004 	addi	r3,r3,-32768
    bc48:	2821883a 	mov	r16,r5
    bc4c:	2027883a 	mov	r19,r4
    bc50:	3025883a 	mov	r18,r6
    bc54:	3823883a 	mov	r17,r7
    bc58:	18000526 	beq	r3,zero,bc70 <__swrite+0x54>
    bc5c:	2940038f 	ldh	r5,14(r5)
    bc60:	000d883a 	mov	r6,zero
    bc64:	01c00084 	movi	r7,2
    bc68:	000c2ac0 	call	c2ac <_lseek_r>
    bc6c:	8080030b 	ldhu	r2,12(r16)
    bc70:	8140038f 	ldh	r5,14(r16)
    bc74:	10bbffcc 	andi	r2,r2,61439
    bc78:	9809883a 	mov	r4,r19
    bc7c:	900d883a 	mov	r6,r18
    bc80:	880f883a 	mov	r7,r17
    bc84:	8080030d 	sth	r2,12(r16)
    bc88:	dfc00417 	ldw	ra,16(sp)
    bc8c:	dcc00317 	ldw	r19,12(sp)
    bc90:	dc800217 	ldw	r18,8(sp)
    bc94:	dc400117 	ldw	r17,4(sp)
    bc98:	dc000017 	ldw	r16,0(sp)
    bc9c:	dec00504 	addi	sp,sp,20
    bca0:	000bf041 	jmpi	bf04 <_write_r>

0000bca4 <__sseek>:
    bca4:	defffe04 	addi	sp,sp,-8
    bca8:	dc000015 	stw	r16,0(sp)
    bcac:	2821883a 	mov	r16,r5
    bcb0:	2940038f 	ldh	r5,14(r5)
    bcb4:	dfc00115 	stw	ra,4(sp)
    bcb8:	000c2ac0 	call	c2ac <_lseek_r>
    bcbc:	00ffffc4 	movi	r3,-1
    bcc0:	10c00826 	beq	r2,r3,bce4 <__sseek+0x40>
    bcc4:	80c0030b 	ldhu	r3,12(r16)
    bcc8:	80801415 	stw	r2,80(r16)
    bccc:	18c40014 	ori	r3,r3,4096
    bcd0:	80c0030d 	sth	r3,12(r16)
    bcd4:	dfc00117 	ldw	ra,4(sp)
    bcd8:	dc000017 	ldw	r16,0(sp)
    bcdc:	dec00204 	addi	sp,sp,8
    bce0:	f800283a 	ret
    bce4:	80c0030b 	ldhu	r3,12(r16)
    bce8:	18fbffcc 	andi	r3,r3,61439
    bcec:	80c0030d 	sth	r3,12(r16)
    bcf0:	dfc00117 	ldw	ra,4(sp)
    bcf4:	dc000017 	ldw	r16,0(sp)
    bcf8:	dec00204 	addi	sp,sp,8
    bcfc:	f800283a 	ret

0000bd00 <__sclose>:
    bd00:	2940038f 	ldh	r5,14(r5)
    bd04:	000c02c1 	jmpi	c02c <_close_r>

0000bd08 <strcmp>:
    bd08:	2904b03a 	or	r2,r5,r4
    bd0c:	108000cc 	andi	r2,r2,3
    bd10:	1000171e 	bne	r2,zero,bd70 <strcmp+0x68>
    bd14:	20800017 	ldw	r2,0(r4)
    bd18:	28c00017 	ldw	r3,0(r5)
    bd1c:	10c0141e 	bne	r2,r3,bd70 <strcmp+0x68>
    bd20:	027fbff4 	movhi	r9,65279
    bd24:	4a7fbfc4 	addi	r9,r9,-257
    bd28:	1247883a 	add	r3,r2,r9
    bd2c:	0084303a 	nor	r2,zero,r2
    bd30:	1884703a 	and	r2,r3,r2
    bd34:	02202074 	movhi	r8,32897
    bd38:	42202004 	addi	r8,r8,-32640
    bd3c:	1204703a 	and	r2,r2,r8
    bd40:	10000226 	beq	r2,zero,bd4c <strcmp+0x44>
    bd44:	00001706 	br	bda4 <strcmp+0x9c>
    bd48:	3000161e 	bne	r6,zero,bda4 <strcmp+0x9c>
    bd4c:	21000104 	addi	r4,r4,4
    bd50:	20800017 	ldw	r2,0(r4)
    bd54:	29400104 	addi	r5,r5,4
    bd58:	28c00017 	ldw	r3,0(r5)
    bd5c:	124f883a 	add	r7,r2,r9
    bd60:	008c303a 	nor	r6,zero,r2
    bd64:	398c703a 	and	r6,r7,r6
    bd68:	320c703a 	and	r6,r6,r8
    bd6c:	10fff626 	beq	r2,r3,bd48 <strcmp+0x40>
    bd70:	20800007 	ldb	r2,0(r4)
    bd74:	1000051e 	bne	r2,zero,bd8c <strcmp+0x84>
    bd78:	00000606 	br	bd94 <strcmp+0x8c>
    bd7c:	21000044 	addi	r4,r4,1
    bd80:	20800007 	ldb	r2,0(r4)
    bd84:	29400044 	addi	r5,r5,1
    bd88:	10000226 	beq	r2,zero,bd94 <strcmp+0x8c>
    bd8c:	28c00007 	ldb	r3,0(r5)
    bd90:	10fffa26 	beq	r2,r3,bd7c <strcmp+0x74>
    bd94:	20c00003 	ldbu	r3,0(r4)
    bd98:	28800003 	ldbu	r2,0(r5)
    bd9c:	1885c83a 	sub	r2,r3,r2
    bda0:	f800283a 	ret
    bda4:	0005883a 	mov	r2,zero
    bda8:	f800283a 	ret

0000bdac <__swbuf_r>:
    bdac:	defffc04 	addi	sp,sp,-16
    bdb0:	dc800215 	stw	r18,8(sp)
    bdb4:	dc400115 	stw	r17,4(sp)
    bdb8:	dc000015 	stw	r16,0(sp)
    bdbc:	dfc00315 	stw	ra,12(sp)
    bdc0:	2023883a 	mov	r17,r4
    bdc4:	2825883a 	mov	r18,r5
    bdc8:	3021883a 	mov	r16,r6
    bdcc:	20000226 	beq	r4,zero,bdd8 <__swbuf_r+0x2c>
    bdd0:	20800e17 	ldw	r2,56(r4)
    bdd4:	10003b26 	beq	r2,zero,bec4 <__swbuf_r+0x118>
    bdd8:	8080030b 	ldhu	r2,12(r16)
    bddc:	80c00617 	ldw	r3,24(r16)
    bde0:	1080020c 	andi	r2,r2,8
    bde4:	10bfffcc 	andi	r2,r2,65535
    bde8:	10a0001c 	xori	r2,r2,32768
    bdec:	80c00215 	stw	r3,8(r16)
    bdf0:	10a00004 	addi	r2,r2,-32768
    bdf4:	10002226 	beq	r2,zero,be80 <__swbuf_r+0xd4>
    bdf8:	80800417 	ldw	r2,16(r16)
    bdfc:	10002026 	beq	r2,zero,be80 <__swbuf_r+0xd4>
    be00:	80c00017 	ldw	r3,0(r16)
    be04:	81000517 	ldw	r4,20(r16)
    be08:	94803fcc 	andi	r18,r18,255
    be0c:	1885c83a 	sub	r2,r3,r2
    be10:	1100250e 	bge	r2,r4,bea8 <__swbuf_r+0xfc>
    be14:	10800044 	addi	r2,r2,1
    be18:	81400217 	ldw	r5,8(r16)
    be1c:	19000044 	addi	r4,r3,1
    be20:	297fffc4 	addi	r5,r5,-1
    be24:	81400215 	stw	r5,8(r16)
    be28:	1c800005 	stb	r18,0(r3)
    be2c:	80c00517 	ldw	r3,20(r16)
    be30:	81000015 	stw	r4,0(r16)
    be34:	18800c26 	beq	r3,r2,be68 <__swbuf_r+0xbc>
    be38:	8080030b 	ldhu	r2,12(r16)
    be3c:	1080004c 	andi	r2,r2,1
    be40:	10000226 	beq	r2,zero,be4c <__swbuf_r+0xa0>
    be44:	00800284 	movi	r2,10
    be48:	90800726 	beq	r18,r2,be68 <__swbuf_r+0xbc>
    be4c:	9005883a 	mov	r2,r18
    be50:	dfc00317 	ldw	ra,12(sp)
    be54:	dc800217 	ldw	r18,8(sp)
    be58:	dc400117 	ldw	r17,4(sp)
    be5c:	dc000017 	ldw	r16,0(sp)
    be60:	dec00404 	addi	sp,sp,16
    be64:	f800283a 	ret
    be68:	8809883a 	mov	r4,r17
    be6c:	800b883a 	mov	r5,r16
    be70:	00087140 	call	8714 <_fflush_r>
    be74:	103ff526 	beq	r2,zero,be4c <__swbuf_r+0xa0>
    be78:	04bfffc4 	movi	r18,-1
    be7c:	003ff306 	br	be4c <__swbuf_r+0xa0>
    be80:	8809883a 	mov	r4,r17
    be84:	800b883a 	mov	r5,r16
    be88:	0006d7c0 	call	6d7c <__swsetup_r>
    be8c:	10000f1e 	bne	r2,zero,becc <__swbuf_r+0x120>
    be90:	80800417 	ldw	r2,16(r16)
    be94:	80c00017 	ldw	r3,0(r16)
    be98:	81000517 	ldw	r4,20(r16)
    be9c:	94803fcc 	andi	r18,r18,255
    bea0:	1885c83a 	sub	r2,r3,r2
    bea4:	113fdb16 	blt	r2,r4,be14 <__swbuf_r+0x68>
    bea8:	8809883a 	mov	r4,r17
    beac:	800b883a 	mov	r5,r16
    beb0:	00087140 	call	8714 <_fflush_r>
    beb4:	103ff01e 	bne	r2,zero,be78 <__swbuf_r+0xcc>
    beb8:	80c00017 	ldw	r3,0(r16)
    bebc:	00800044 	movi	r2,1
    bec0:	003fd506 	br	be18 <__swbuf_r+0x6c>
    bec4:	00089bc0 	call	89bc <__sinit>
    bec8:	003fc306 	br	bdd8 <__swbuf_r+0x2c>
    becc:	8080030b 	ldhu	r2,12(r16)
    bed0:	04bfffc4 	movi	r18,-1
    bed4:	10801014 	ori	r2,r2,64
    bed8:	8080030d 	sth	r2,12(r16)
    bedc:	00800244 	movi	r2,9
    bee0:	88800015 	stw	r2,0(r17)
    bee4:	003fd906 	br	be4c <__swbuf_r+0xa0>

0000bee8 <__swbuf>:
    bee8:	00c00134 	movhi	r3,4
    beec:	18d5bf04 	addi	r3,r3,22268
    bef0:	2005883a 	mov	r2,r4
    bef4:	19000017 	ldw	r4,0(r3)
    bef8:	280d883a 	mov	r6,r5
    befc:	100b883a 	mov	r5,r2
    bf00:	000bdac1 	jmpi	bdac <__swbuf_r>

0000bf04 <_write_r>:
    bf04:	defffd04 	addi	sp,sp,-12
    bf08:	dc400115 	stw	r17,4(sp)
    bf0c:	dc000015 	stw	r16,0(sp)
    bf10:	2023883a 	mov	r17,r4
    bf14:	04000134 	movhi	r16,4
    bf18:	841ebe04 	addi	r16,r16,31480
    bf1c:	2809883a 	mov	r4,r5
    bf20:	300b883a 	mov	r5,r6
    bf24:	380d883a 	mov	r6,r7
    bf28:	dfc00215 	stw	ra,8(sp)
    bf2c:	80000015 	stw	zero,0(r16)
    bf30:	0019a700 	call	19a70 <write>
    bf34:	00ffffc4 	movi	r3,-1
    bf38:	10c00526 	beq	r2,r3,bf50 <_write_r+0x4c>
    bf3c:	dfc00217 	ldw	ra,8(sp)
    bf40:	dc400117 	ldw	r17,4(sp)
    bf44:	dc000017 	ldw	r16,0(sp)
    bf48:	dec00304 	addi	sp,sp,12
    bf4c:	f800283a 	ret
    bf50:	80c00017 	ldw	r3,0(r16)
    bf54:	183ff926 	beq	r3,zero,bf3c <_write_r+0x38>
    bf58:	88c00015 	stw	r3,0(r17)
    bf5c:	dfc00217 	ldw	ra,8(sp)
    bf60:	dc400117 	ldw	r17,4(sp)
    bf64:	dc000017 	ldw	r16,0(sp)
    bf68:	dec00304 	addi	sp,sp,12
    bf6c:	f800283a 	ret

0000bf70 <_calloc_r>:
    bf70:	314b383a 	mul	r5,r6,r5
    bf74:	defffe04 	addi	sp,sp,-8
    bf78:	dc000015 	stw	r16,0(sp)
    bf7c:	dfc00115 	stw	ra,4(sp)
    bf80:	0009a0c0 	call	9a0c <_malloc_r>
    bf84:	1021883a 	mov	r16,r2
    bf88:	10000c26 	beq	r2,zero,bfbc <_calloc_r+0x4c>
    bf8c:	11bfff17 	ldw	r6,-4(r2)
    bf90:	00ffff04 	movi	r3,-4
    bf94:	00800904 	movi	r2,36
    bf98:	30cc703a 	and	r6,r6,r3
    bf9c:	30cd883a 	add	r6,r6,r3
    bfa0:	11801436 	bltu	r2,r6,bff4 <_calloc_r+0x84>
    bfa4:	00c004c4 	movi	r3,19
    bfa8:	19800936 	bltu	r3,r6,bfd0 <_calloc_r+0x60>
    bfac:	8005883a 	mov	r2,r16
    bfb0:	10000015 	stw	zero,0(r2)
    bfb4:	10000115 	stw	zero,4(r2)
    bfb8:	10000215 	stw	zero,8(r2)
    bfbc:	8005883a 	mov	r2,r16
    bfc0:	dfc00117 	ldw	ra,4(sp)
    bfc4:	dc000017 	ldw	r16,0(sp)
    bfc8:	dec00204 	addi	sp,sp,8
    bfcc:	f800283a 	ret
    bfd0:	80000015 	stw	zero,0(r16)
    bfd4:	80000115 	stw	zero,4(r16)
    bfd8:	00c006c4 	movi	r3,27
    bfdc:	19800d2e 	bgeu	r3,r6,c014 <_calloc_r+0xa4>
    bfe0:	80000215 	stw	zero,8(r16)
    bfe4:	80000315 	stw	zero,12(r16)
    bfe8:	30800c26 	beq	r6,r2,c01c <_calloc_r+0xac>
    bfec:	80800404 	addi	r2,r16,16
    bff0:	003fef06 	br	bfb0 <_calloc_r+0x40>
    bff4:	8009883a 	mov	r4,r16
    bff8:	000b883a 	mov	r5,zero
    bffc:	00042e80 	call	42e8 <memset>
    c000:	8005883a 	mov	r2,r16
    c004:	dfc00117 	ldw	ra,4(sp)
    c008:	dc000017 	ldw	r16,0(sp)
    c00c:	dec00204 	addi	sp,sp,8
    c010:	f800283a 	ret
    c014:	80800204 	addi	r2,r16,8
    c018:	003fe506 	br	bfb0 <_calloc_r+0x40>
    c01c:	80000415 	stw	zero,16(r16)
    c020:	80000515 	stw	zero,20(r16)
    c024:	80800604 	addi	r2,r16,24
    c028:	003fe106 	br	bfb0 <_calloc_r+0x40>

0000c02c <_close_r>:
    c02c:	defffd04 	addi	sp,sp,-12
    c030:	dc400115 	stw	r17,4(sp)
    c034:	dc000015 	stw	r16,0(sp)
    c038:	2023883a 	mov	r17,r4
    c03c:	04000134 	movhi	r16,4
    c040:	841ebe04 	addi	r16,r16,31480
    c044:	2809883a 	mov	r4,r5
    c048:	dfc00215 	stw	ra,8(sp)
    c04c:	80000015 	stw	zero,0(r16)
    c050:	00199bc0 	call	199bc <close>
    c054:	00ffffc4 	movi	r3,-1
    c058:	10c00526 	beq	r2,r3,c070 <_close_r+0x44>
    c05c:	dfc00217 	ldw	ra,8(sp)
    c060:	dc400117 	ldw	r17,4(sp)
    c064:	dc000017 	ldw	r16,0(sp)
    c068:	dec00304 	addi	sp,sp,12
    c06c:	f800283a 	ret
    c070:	80c00017 	ldw	r3,0(r16)
    c074:	183ff926 	beq	r3,zero,c05c <_close_r+0x30>
    c078:	88c00015 	stw	r3,0(r17)
    c07c:	dfc00217 	ldw	ra,8(sp)
    c080:	dc400117 	ldw	r17,4(sp)
    c084:	dc000017 	ldw	r16,0(sp)
    c088:	dec00304 	addi	sp,sp,12
    c08c:	f800283a 	ret

0000c090 <_fclose_r>:
    c090:	defffc04 	addi	sp,sp,-16
    c094:	dc400115 	stw	r17,4(sp)
    c098:	dc000015 	stw	r16,0(sp)
    c09c:	dfc00315 	stw	ra,12(sp)
    c0a0:	dc800215 	stw	r18,8(sp)
    c0a4:	2821883a 	mov	r16,r5
    c0a8:	2023883a 	mov	r17,r4
    c0ac:	28003426 	beq	r5,zero,c180 <_fclose_r+0xf0>
    c0b0:	0008bc40 	call	8bc4 <__sfp_lock_acquire>
    c0b4:	88000226 	beq	r17,zero,c0c0 <_fclose_r+0x30>
    c0b8:	88800e17 	ldw	r2,56(r17)
    c0bc:	10003826 	beq	r2,zero,c1a0 <_fclose_r+0x110>
    c0c0:	8080030f 	ldh	r2,12(r16)
    c0c4:	10002526 	beq	r2,zero,c15c <_fclose_r+0xcc>
    c0c8:	8809883a 	mov	r4,r17
    c0cc:	800b883a 	mov	r5,r16
    c0d0:	00087140 	call	8714 <_fflush_r>
    c0d4:	1025883a 	mov	r18,r2
    c0d8:	80800b17 	ldw	r2,44(r16)
    c0dc:	10000426 	beq	r2,zero,c0f0 <_fclose_r+0x60>
    c0e0:	81400717 	ldw	r5,28(r16)
    c0e4:	8809883a 	mov	r4,r17
    c0e8:	103ee83a 	callr	r2
    c0ec:	10003516 	blt	r2,zero,c1c4 <_fclose_r+0x134>
    c0f0:	8080030b 	ldhu	r2,12(r16)
    c0f4:	1080200c 	andi	r2,r2,128
    c0f8:	10bfffcc 	andi	r2,r2,65535
    c0fc:	10a0001c 	xori	r2,r2,32768
    c100:	10a00004 	addi	r2,r2,-32768
    c104:	10002b1e 	bne	r2,zero,c1b4 <_fclose_r+0x124>
    c108:	81400c17 	ldw	r5,48(r16)
    c10c:	28000526 	beq	r5,zero,c124 <_fclose_r+0x94>
    c110:	80801004 	addi	r2,r16,64
    c114:	28800226 	beq	r5,r2,c120 <_fclose_r+0x90>
    c118:	8809883a 	mov	r4,r17
    c11c:	0008e740 	call	8e74 <_free_r>
    c120:	80000c15 	stw	zero,48(r16)
    c124:	81401117 	ldw	r5,68(r16)
    c128:	28000326 	beq	r5,zero,c138 <_fclose_r+0xa8>
    c12c:	8809883a 	mov	r4,r17
    c130:	0008e740 	call	8e74 <_free_r>
    c134:	80001115 	stw	zero,68(r16)
    c138:	8000030d 	sth	zero,12(r16)
    c13c:	0008bc80 	call	8bc8 <__sfp_lock_release>
    c140:	9005883a 	mov	r2,r18
    c144:	dfc00317 	ldw	ra,12(sp)
    c148:	dc800217 	ldw	r18,8(sp)
    c14c:	dc400117 	ldw	r17,4(sp)
    c150:	dc000017 	ldw	r16,0(sp)
    c154:	dec00404 	addi	sp,sp,16
    c158:	f800283a 	ret
    c15c:	0008bc80 	call	8bc8 <__sfp_lock_release>
    c160:	0025883a 	mov	r18,zero
    c164:	9005883a 	mov	r2,r18
    c168:	dfc00317 	ldw	ra,12(sp)
    c16c:	dc800217 	ldw	r18,8(sp)
    c170:	dc400117 	ldw	r17,4(sp)
    c174:	dc000017 	ldw	r16,0(sp)
    c178:	dec00404 	addi	sp,sp,16
    c17c:	f800283a 	ret
    c180:	0025883a 	mov	r18,zero
    c184:	9005883a 	mov	r2,r18
    c188:	dfc00317 	ldw	ra,12(sp)
    c18c:	dc800217 	ldw	r18,8(sp)
    c190:	dc400117 	ldw	r17,4(sp)
    c194:	dc000017 	ldw	r16,0(sp)
    c198:	dec00404 	addi	sp,sp,16
    c19c:	f800283a 	ret
    c1a0:	8809883a 	mov	r4,r17
    c1a4:	00089bc0 	call	89bc <__sinit>
    c1a8:	8080030f 	ldh	r2,12(r16)
    c1ac:	103fc61e 	bne	r2,zero,c0c8 <_fclose_r+0x38>
    c1b0:	003fea06 	br	c15c <_fclose_r+0xcc>
    c1b4:	81400417 	ldw	r5,16(r16)
    c1b8:	8809883a 	mov	r4,r17
    c1bc:	0008e740 	call	8e74 <_free_r>
    c1c0:	003fd106 	br	c108 <_fclose_r+0x78>
    c1c4:	04bfffc4 	movi	r18,-1
    c1c8:	003fc906 	br	c0f0 <_fclose_r+0x60>

0000c1cc <fclose>:
    c1cc:	00800134 	movhi	r2,4
    c1d0:	1095bf04 	addi	r2,r2,22268
    c1d4:	200b883a 	mov	r5,r4
    c1d8:	11000017 	ldw	r4,0(r2)
    c1dc:	000c0901 	jmpi	c090 <_fclose_r>

0000c1e0 <_fstat_r>:
    c1e0:	defffd04 	addi	sp,sp,-12
    c1e4:	dc400115 	stw	r17,4(sp)
    c1e8:	dc000015 	stw	r16,0(sp)
    c1ec:	2023883a 	mov	r17,r4
    c1f0:	04000134 	movhi	r16,4
    c1f4:	841ebe04 	addi	r16,r16,31480
    c1f8:	2809883a 	mov	r4,r5
    c1fc:	300b883a 	mov	r5,r6
    c200:	dfc00215 	stw	ra,8(sp)
    c204:	80000015 	stw	zero,0(r16)
    c208:	0011b780 	call	11b78 <fstat>
    c20c:	00ffffc4 	movi	r3,-1
    c210:	10c00526 	beq	r2,r3,c228 <_fstat_r+0x48>
    c214:	dfc00217 	ldw	ra,8(sp)
    c218:	dc400117 	ldw	r17,4(sp)
    c21c:	dc000017 	ldw	r16,0(sp)
    c220:	dec00304 	addi	sp,sp,12
    c224:	f800283a 	ret
    c228:	80c00017 	ldw	r3,0(r16)
    c22c:	183ff926 	beq	r3,zero,c214 <_fstat_r+0x34>
    c230:	88c00015 	stw	r3,0(r17)
    c234:	dfc00217 	ldw	ra,8(sp)
    c238:	dc400117 	ldw	r17,4(sp)
    c23c:	dc000017 	ldw	r16,0(sp)
    c240:	dec00304 	addi	sp,sp,12
    c244:	f800283a 	ret

0000c248 <_isatty_r>:
    c248:	defffd04 	addi	sp,sp,-12
    c24c:	dc400115 	stw	r17,4(sp)
    c250:	dc000015 	stw	r16,0(sp)
    c254:	2023883a 	mov	r17,r4
    c258:	04000134 	movhi	r16,4
    c25c:	841ebe04 	addi	r16,r16,31480
    c260:	2809883a 	mov	r4,r5
    c264:	dfc00215 	stw	ra,8(sp)
    c268:	80000015 	stw	zero,0(r16)
    c26c:	0011dac0 	call	11dac <isatty>
    c270:	00ffffc4 	movi	r3,-1
    c274:	10c00526 	beq	r2,r3,c28c <_isatty_r+0x44>
    c278:	dfc00217 	ldw	ra,8(sp)
    c27c:	dc400117 	ldw	r17,4(sp)
    c280:	dc000017 	ldw	r16,0(sp)
    c284:	dec00304 	addi	sp,sp,12
    c288:	f800283a 	ret
    c28c:	80c00017 	ldw	r3,0(r16)
    c290:	183ff926 	beq	r3,zero,c278 <_isatty_r+0x30>
    c294:	88c00015 	stw	r3,0(r17)
    c298:	dfc00217 	ldw	ra,8(sp)
    c29c:	dc400117 	ldw	r17,4(sp)
    c2a0:	dc000017 	ldw	r16,0(sp)
    c2a4:	dec00304 	addi	sp,sp,12
    c2a8:	f800283a 	ret

0000c2ac <_lseek_r>:
    c2ac:	defffd04 	addi	sp,sp,-12
    c2b0:	dc400115 	stw	r17,4(sp)
    c2b4:	dc000015 	stw	r16,0(sp)
    c2b8:	2023883a 	mov	r17,r4
    c2bc:	04000134 	movhi	r16,4
    c2c0:	841ebe04 	addi	r16,r16,31480
    c2c4:	2809883a 	mov	r4,r5
    c2c8:	300b883a 	mov	r5,r6
    c2cc:	380d883a 	mov	r6,r7
    c2d0:	dfc00215 	stw	ra,8(sp)
    c2d4:	80000015 	stw	zero,0(r16)
    c2d8:	0011f880 	call	11f88 <lseek>
    c2dc:	00ffffc4 	movi	r3,-1
    c2e0:	10c00526 	beq	r2,r3,c2f8 <_lseek_r+0x4c>
    c2e4:	dfc00217 	ldw	ra,8(sp)
    c2e8:	dc400117 	ldw	r17,4(sp)
    c2ec:	dc000017 	ldw	r16,0(sp)
    c2f0:	dec00304 	addi	sp,sp,12
    c2f4:	f800283a 	ret
    c2f8:	80c00017 	ldw	r3,0(r16)
    c2fc:	183ff926 	beq	r3,zero,c2e4 <_lseek_r+0x38>
    c300:	88c00015 	stw	r3,0(r17)
    c304:	dfc00217 	ldw	ra,8(sp)
    c308:	dc400117 	ldw	r17,4(sp)
    c30c:	dc000017 	ldw	r16,0(sp)
    c310:	dec00304 	addi	sp,sp,12
    c314:	f800283a 	ret

0000c318 <_read_r>:
    c318:	defffd04 	addi	sp,sp,-12
    c31c:	dc400115 	stw	r17,4(sp)
    c320:	dc000015 	stw	r16,0(sp)
    c324:	2023883a 	mov	r17,r4
    c328:	04000134 	movhi	r16,4
    c32c:	841ebe04 	addi	r16,r16,31480
    c330:	2809883a 	mov	r4,r5
    c334:	300b883a 	mov	r5,r6
    c338:	380d883a 	mov	r6,r7
    c33c:	dfc00215 	stw	ra,8(sp)
    c340:	80000015 	stw	zero,0(r16)
    c344:	0019a040 	call	19a04 <read>
    c348:	00ffffc4 	movi	r3,-1
    c34c:	10c00526 	beq	r2,r3,c364 <_read_r+0x4c>
    c350:	dfc00217 	ldw	ra,8(sp)
    c354:	dc400117 	ldw	r17,4(sp)
    c358:	dc000017 	ldw	r16,0(sp)
    c35c:	dec00304 	addi	sp,sp,12
    c360:	f800283a 	ret
    c364:	80c00017 	ldw	r3,0(r16)
    c368:	183ff926 	beq	r3,zero,c350 <_read_r+0x38>
    c36c:	88c00015 	stw	r3,0(r17)
    c370:	dfc00217 	ldw	ra,8(sp)
    c374:	dc400117 	ldw	r17,4(sp)
    c378:	dc000017 	ldw	r16,0(sp)
    c37c:	dec00304 	addi	sp,sp,12
    c380:	f800283a 	ret

0000c384 <__udivdi3>:
    c384:	defff504 	addi	sp,sp,-44
    c388:	dd000515 	stw	r20,20(sp)
    c38c:	dcc00415 	stw	r19,16(sp)
    c390:	dc800315 	stw	r18,12(sp)
    c394:	dc400215 	stw	r17,8(sp)
    c398:	dc000115 	stw	r16,4(sp)
    c39c:	dfc00a15 	stw	ra,40(sp)
    c3a0:	df000915 	stw	fp,36(sp)
    c3a4:	ddc00815 	stw	r23,32(sp)
    c3a8:	dd800715 	stw	r22,28(sp)
    c3ac:	dd400615 	stw	r21,24(sp)
    c3b0:	2025883a 	mov	r18,r4
    c3b4:	2823883a 	mov	r17,r5
    c3b8:	3021883a 	mov	r16,r6
    c3bc:	2027883a 	mov	r19,r4
    c3c0:	2829883a 	mov	r20,r5
    c3c4:	3800401e 	bne	r7,zero,c4c8 <__udivdi3+0x144>
    c3c8:	2980602e 	bgeu	r5,r6,c54c <__udivdi3+0x1c8>
    c3cc:	00bfffd4 	movui	r2,65535
    c3d0:	1180aa36 	bltu	r2,r6,c67c <__udivdi3+0x2f8>
    c3d4:	00803fc4 	movi	r2,255
    c3d8:	11814436 	bltu	r2,r6,c8ec <__udivdi3+0x568>
    c3dc:	0005883a 	mov	r2,zero
    c3e0:	0007883a 	mov	r3,zero
    c3e4:	3084d83a 	srl	r2,r6,r2
    c3e8:	01000134 	movhi	r4,4
    c3ec:	21022404 	addi	r4,r4,2192
    c3f0:	2085883a 	add	r2,r4,r2
    c3f4:	10800003 	ldbu	r2,0(r2)
    c3f8:	10c7883a 	add	r3,r2,r3
    c3fc:	00800804 	movi	r2,32
    c400:	10c5c83a 	sub	r2,r2,r3
    c404:	10000526 	beq	r2,zero,c41c <__udivdi3+0x98>
    c408:	88a2983a 	sll	r17,r17,r2
    c40c:	90c6d83a 	srl	r3,r18,r3
    c410:	30a0983a 	sll	r16,r6,r2
    c414:	90a6983a 	sll	r19,r18,r2
    c418:	88e8b03a 	or	r20,r17,r3
    c41c:	8022d43a 	srli	r17,r16,16
    c420:	a009883a 	mov	r4,r20
    c424:	857fffcc 	andi	r21,r16,65535
    c428:	880b883a 	mov	r5,r17
    c42c:	000dd400 	call	dd40 <__umodsi3>
    c430:	a009883a 	mov	r4,r20
    c434:	880b883a 	mov	r5,r17
    c438:	102d883a 	mov	r22,r2
    c43c:	000dd380 	call	dd38 <__udivsi3>
    c440:	b02c943a 	slli	r22,r22,16
    c444:	9806d43a 	srli	r3,r19,16
    c448:	1549383a 	mul	r4,r2,r21
    c44c:	1025883a 	mov	r18,r2
    c450:	b0c6b03a 	or	r3,r22,r3
    c454:	1900052e 	bgeu	r3,r4,c46c <__udivdi3+0xe8>
    c458:	1c07883a 	add	r3,r3,r16
    c45c:	10bfffc4 	addi	r2,r2,-1
    c460:	1c000136 	bltu	r3,r16,c468 <__udivdi3+0xe4>
    c464:	19013636 	bltu	r3,r4,c940 <__udivdi3+0x5bc>
    c468:	1025883a 	mov	r18,r2
    c46c:	1929c83a 	sub	r20,r3,r4
    c470:	a009883a 	mov	r4,r20
    c474:	880b883a 	mov	r5,r17
    c478:	000dd400 	call	dd40 <__umodsi3>
    c47c:	102d883a 	mov	r22,r2
    c480:	a009883a 	mov	r4,r20
    c484:	880b883a 	mov	r5,r17
    c488:	000dd380 	call	dd38 <__udivsi3>
    c48c:	b02c943a 	slli	r22,r22,16
    c490:	156b383a 	mul	r21,r2,r21
    c494:	9cffffcc 	andi	r19,r19,65535
    c498:	b4e6b03a 	or	r19,r22,r19
    c49c:	1009883a 	mov	r4,r2
    c4a0:	9d40052e 	bgeu	r19,r21,c4b8 <__udivdi3+0x134>
    c4a4:	9c27883a 	add	r19,r19,r16
    c4a8:	10bfffc4 	addi	r2,r2,-1
    c4ac:	9c00f736 	bltu	r19,r16,c88c <__udivdi3+0x508>
    c4b0:	9d40f62e 	bgeu	r19,r21,c88c <__udivdi3+0x508>
    c4b4:	213fff84 	addi	r4,r4,-2
    c4b8:	9004943a 	slli	r2,r18,16
    c4bc:	0007883a 	mov	r3,zero
    c4c0:	2084b03a 	or	r2,r4,r2
    c4c4:	00001506 	br	c51c <__udivdi3+0x198>
    c4c8:	29c06536 	bltu	r5,r7,c660 <__udivdi3+0x2dc>
    c4cc:	00bfffd4 	movui	r2,65535
    c4d0:	11c0652e 	bgeu	r2,r7,c668 <__udivdi3+0x2e4>
    c4d4:	00804034 	movhi	r2,256
    c4d8:	10bfffc4 	addi	r2,r2,-1
    c4dc:	11c0f736 	bltu	r2,r7,c8bc <__udivdi3+0x538>
    c4e0:	00c00404 	movi	r3,16
    c4e4:	180b883a 	mov	r5,r3
    c4e8:	38c6d83a 	srl	r3,r7,r3
    c4ec:	01000134 	movhi	r4,4
    c4f0:	21022404 	addi	r4,r4,2192
    c4f4:	04000804 	movi	r16,32
    c4f8:	20c7883a 	add	r3,r4,r3
    c4fc:	18800003 	ldbu	r2,0(r3)
    c500:	1145883a 	add	r2,r2,r5
    c504:	80a1c83a 	sub	r16,r16,r2
    c508:	8000691e 	bne	r16,zero,c6b0 <__udivdi3+0x32c>
    c50c:	0007883a 	mov	r3,zero
    c510:	3c406536 	bltu	r7,r17,c6a8 <__udivdi3+0x324>
    c514:	9180642e 	bgeu	r18,r6,c6a8 <__udivdi3+0x324>
    c518:	0005883a 	mov	r2,zero
    c51c:	dfc00a17 	ldw	ra,40(sp)
    c520:	df000917 	ldw	fp,36(sp)
    c524:	ddc00817 	ldw	r23,32(sp)
    c528:	dd800717 	ldw	r22,28(sp)
    c52c:	dd400617 	ldw	r21,24(sp)
    c530:	dd000517 	ldw	r20,20(sp)
    c534:	dcc00417 	ldw	r19,16(sp)
    c538:	dc800317 	ldw	r18,12(sp)
    c53c:	dc400217 	ldw	r17,8(sp)
    c540:	dc000117 	ldw	r16,4(sp)
    c544:	dec00b04 	addi	sp,sp,44
    c548:	f800283a 	ret
    c54c:	3000041e 	bne	r6,zero,c560 <__udivdi3+0x1dc>
    c550:	01000044 	movi	r4,1
    c554:	000b883a 	mov	r5,zero
    c558:	000dd380 	call	dd38 <__udivsi3>
    c55c:	1021883a 	mov	r16,r2
    c560:	00bfffd4 	movui	r2,65535
    c564:	14004b2e 	bgeu	r2,r16,c694 <__udivdi3+0x310>
    c568:	00804034 	movhi	r2,256
    c56c:	10bfffc4 	addi	r2,r2,-1
    c570:	1400d836 	bltu	r2,r16,c8d4 <__udivdi3+0x550>
    c574:	00800404 	movi	r2,16
    c578:	1007883a 	mov	r3,r2
    c57c:	8084d83a 	srl	r2,r16,r2
    c580:	01000134 	movhi	r4,4
    c584:	21022404 	addi	r4,r4,2192
    c588:	2085883a 	add	r2,r4,r2
    c58c:	10800003 	ldbu	r2,0(r2)
    c590:	10c7883a 	add	r3,r2,r3
    c594:	00800804 	movi	r2,32
    c598:	10c5c83a 	sub	r2,r2,r3
    c59c:	1000891e 	bne	r2,zero,c7c4 <__udivdi3+0x440>
    c5a0:	8028d43a 	srli	r20,r16,16
    c5a4:	8c23c83a 	sub	r17,r17,r16
    c5a8:	84bfffcc 	andi	r18,r16,65535
    c5ac:	00c00044 	movi	r3,1
    c5b0:	8809883a 	mov	r4,r17
    c5b4:	a00b883a 	mov	r5,r20
    c5b8:	d8c00015 	stw	r3,0(sp)
    c5bc:	000dd400 	call	dd40 <__umodsi3>
    c5c0:	8809883a 	mov	r4,r17
    c5c4:	a00b883a 	mov	r5,r20
    c5c8:	102b883a 	mov	r21,r2
    c5cc:	000dd380 	call	dd38 <__udivsi3>
    c5d0:	a82a943a 	slli	r21,r21,16
    c5d4:	9808d43a 	srli	r4,r19,16
    c5d8:	148b383a 	mul	r5,r2,r18
    c5dc:	1023883a 	mov	r17,r2
    c5e0:	a908b03a 	or	r4,r21,r4
    c5e4:	d8c00017 	ldw	r3,0(sp)
    c5e8:	2140052e 	bgeu	r4,r5,c600 <__udivdi3+0x27c>
    c5ec:	2409883a 	add	r4,r4,r16
    c5f0:	10bfffc4 	addi	r2,r2,-1
    c5f4:	24000136 	bltu	r4,r16,c5fc <__udivdi3+0x278>
    c5f8:	2140ce36 	bltu	r4,r5,c934 <__udivdi3+0x5b0>
    c5fc:	1023883a 	mov	r17,r2
    c600:	216bc83a 	sub	r21,r4,r5
    c604:	a809883a 	mov	r4,r21
    c608:	a00b883a 	mov	r5,r20
    c60c:	d8c00015 	stw	r3,0(sp)
    c610:	000dd400 	call	dd40 <__umodsi3>
    c614:	102d883a 	mov	r22,r2
    c618:	a809883a 	mov	r4,r21
    c61c:	a00b883a 	mov	r5,r20
    c620:	000dd380 	call	dd38 <__udivsi3>
    c624:	b02c943a 	slli	r22,r22,16
    c628:	14a5383a 	mul	r18,r2,r18
    c62c:	9cffffcc 	andi	r19,r19,65535
    c630:	b4e6b03a 	or	r19,r22,r19
    c634:	1009883a 	mov	r4,r2
    c638:	d8c00017 	ldw	r3,0(sp)
    c63c:	9c80052e 	bgeu	r19,r18,c654 <__udivdi3+0x2d0>
    c640:	9c27883a 	add	r19,r19,r16
    c644:	10bfffc4 	addi	r2,r2,-1
    c648:	9c009236 	bltu	r19,r16,c894 <__udivdi3+0x510>
    c64c:	9c80912e 	bgeu	r19,r18,c894 <__udivdi3+0x510>
    c650:	213fff84 	addi	r4,r4,-2
    c654:	8804943a 	slli	r2,r17,16
    c658:	2084b03a 	or	r2,r4,r2
    c65c:	003faf06 	br	c51c <__udivdi3+0x198>
    c660:	0007883a 	mov	r3,zero
    c664:	003fac06 	br	c518 <__udivdi3+0x194>
    c668:	00803fc4 	movi	r2,255
    c66c:	11c09636 	bltu	r2,r7,c8c8 <__udivdi3+0x544>
    c670:	0007883a 	mov	r3,zero
    c674:	000b883a 	mov	r5,zero
    c678:	003f9b06 	br	c4e8 <__udivdi3+0x164>
    c67c:	00804034 	movhi	r2,256
    c680:	10bfffc4 	addi	r2,r2,-1
    c684:	11809636 	bltu	r2,r6,c8e0 <__udivdi3+0x55c>
    c688:	00800404 	movi	r2,16
    c68c:	1007883a 	mov	r3,r2
    c690:	003f5406 	br	c3e4 <__udivdi3+0x60>
    c694:	00803fc4 	movi	r2,255
    c698:	14009736 	bltu	r2,r16,c8f8 <__udivdi3+0x574>
    c69c:	0005883a 	mov	r2,zero
    c6a0:	0007883a 	mov	r3,zero
    c6a4:	003fb506 	br	c57c <__udivdi3+0x1f8>
    c6a8:	00800044 	movi	r2,1
    c6ac:	003f9b06 	br	c51c <__udivdi3+0x198>
    c6b0:	3086d83a 	srl	r3,r6,r2
    c6b4:	3c0e983a 	sll	r7,r7,r16
    c6b8:	88aad83a 	srl	r21,r17,r2
    c6bc:	9084d83a 	srl	r2,r18,r2
    c6c0:	38e6b03a 	or	r19,r7,r3
    c6c4:	9828d43a 	srli	r20,r19,16
    c6c8:	8c22983a 	sll	r17,r17,r16
    c6cc:	a809883a 	mov	r4,r21
    c6d0:	a00b883a 	mov	r5,r20
    c6d4:	342c983a 	sll	r22,r6,r16
    c6d8:	88a2b03a 	or	r17,r17,r2
    c6dc:	000dd400 	call	dd40 <__umodsi3>
    c6e0:	a809883a 	mov	r4,r21
    c6e4:	a00b883a 	mov	r5,r20
    c6e8:	1039883a 	mov	fp,r2
    c6ec:	000dd380 	call	dd38 <__udivsi3>
    c6f0:	102b883a 	mov	r21,r2
    c6f4:	9dffffcc 	andi	r23,r19,65535
    c6f8:	e008943a 	slli	r4,fp,16
    c6fc:	8804d43a 	srli	r2,r17,16
    c700:	adcd383a 	mul	r6,r21,r23
    c704:	2088b03a 	or	r4,r4,r2
    c708:	2180042e 	bgeu	r4,r6,c71c <__udivdi3+0x398>
    c70c:	24c9883a 	add	r4,r4,r19
    c710:	a8bfffc4 	addi	r2,r21,-1
    c714:	24c07f2e 	bgeu	r4,r19,c914 <__udivdi3+0x590>
    c718:	102b883a 	mov	r21,r2
    c71c:	21b9c83a 	sub	fp,r4,r6
    c720:	e009883a 	mov	r4,fp
    c724:	a00b883a 	mov	r5,r20
    c728:	000dd400 	call	dd40 <__umodsi3>
    c72c:	e009883a 	mov	r4,fp
    c730:	a00b883a 	mov	r5,r20
    c734:	d8800015 	stw	r2,0(sp)
    c738:	000dd380 	call	dd38 <__udivsi3>
    c73c:	d8c00017 	ldw	r3,0(sp)
    c740:	15cb383a 	mul	r5,r2,r23
    c744:	8c7fffcc 	andi	r17,r17,65535
    c748:	1806943a 	slli	r3,r3,16
    c74c:	1009883a 	mov	r4,r2
    c750:	1c46b03a 	or	r3,r3,r17
    c754:	1940042e 	bgeu	r3,r5,c768 <__udivdi3+0x3e4>
    c758:	1cc7883a 	add	r3,r3,r19
    c75c:	10bfffc4 	addi	r2,r2,-1
    c760:	1cc0682e 	bgeu	r3,r19,c904 <__udivdi3+0x580>
    c764:	1009883a 	mov	r4,r2
    c768:	a804943a 	slli	r2,r21,16
    c76c:	b1ffffcc 	andi	r7,r22,65535
    c770:	b02cd43a 	srli	r22,r22,16
    c774:	2084b03a 	or	r2,r4,r2
    c778:	113fffcc 	andi	r4,r2,65535
    c77c:	100cd43a 	srli	r6,r2,16
    c780:	21d1383a 	mul	r8,r4,r7
    c784:	2589383a 	mul	r4,r4,r22
    c788:	31cf383a 	mul	r7,r6,r7
    c78c:	4012d43a 	srli	r9,r8,16
    c790:	1947c83a 	sub	r3,r3,r5
    c794:	3909883a 	add	r4,r7,r4
    c798:	2249883a 	add	r4,r4,r9
    c79c:	35ad383a 	mul	r22,r6,r22
    c7a0:	21c0022e 	bgeu	r4,r7,c7ac <__udivdi3+0x428>
    c7a4:	01400074 	movhi	r5,1
    c7a8:	b16d883a 	add	r22,r22,r5
    c7ac:	200ad43a 	srli	r5,r4,16
    c7b0:	b16d883a 	add	r22,r22,r5
    c7b4:	1d803e36 	bltu	r3,r22,c8b0 <__udivdi3+0x52c>
    c7b8:	1d803826 	beq	r3,r22,c89c <__udivdi3+0x518>
    c7bc:	0007883a 	mov	r3,zero
    c7c0:	003f5606 	br	c51c <__udivdi3+0x198>
    c7c4:	80a0983a 	sll	r16,r16,r2
    c7c8:	88ead83a 	srl	r21,r17,r3
    c7cc:	90c6d83a 	srl	r3,r18,r3
    c7d0:	8028d43a 	srli	r20,r16,16
    c7d4:	88a2983a 	sll	r17,r17,r2
    c7d8:	a809883a 	mov	r4,r21
    c7dc:	a00b883a 	mov	r5,r20
    c7e0:	88ecb03a 	or	r22,r17,r3
    c7e4:	90a6983a 	sll	r19,r18,r2
    c7e8:	000dd400 	call	dd40 <__umodsi3>
    c7ec:	a809883a 	mov	r4,r21
    c7f0:	a00b883a 	mov	r5,r20
    c7f4:	1023883a 	mov	r17,r2
    c7f8:	000dd380 	call	dd38 <__udivsi3>
    c7fc:	102b883a 	mov	r21,r2
    c800:	84bfffcc 	andi	r18,r16,65535
    c804:	8808943a 	slli	r4,r17,16
    c808:	b004d43a 	srli	r2,r22,16
    c80c:	ac87383a 	mul	r3,r21,r18
    c810:	2088b03a 	or	r4,r4,r2
    c814:	20c0062e 	bgeu	r4,r3,c830 <__udivdi3+0x4ac>
    c818:	2409883a 	add	r4,r4,r16
    c81c:	a8bfffc4 	addi	r2,r21,-1
    c820:	24004236 	bltu	r4,r16,c92c <__udivdi3+0x5a8>
    c824:	20c0412e 	bgeu	r4,r3,c92c <__udivdi3+0x5a8>
    c828:	ad7fff84 	addi	r21,r21,-2
    c82c:	2409883a 	add	r4,r4,r16
    c830:	20efc83a 	sub	r23,r4,r3
    c834:	b809883a 	mov	r4,r23
    c838:	a00b883a 	mov	r5,r20
    c83c:	000dd400 	call	dd40 <__umodsi3>
    c840:	1023883a 	mov	r17,r2
    c844:	a00b883a 	mov	r5,r20
    c848:	b809883a 	mov	r4,r23
    c84c:	000dd380 	call	dd38 <__udivsi3>
    c850:	8822943a 	slli	r17,r17,16
    c854:	148b383a 	mul	r5,r2,r18
    c858:	b5bfffcc 	andi	r22,r22,65535
    c85c:	8da2b03a 	or	r17,r17,r22
    c860:	8940062e 	bgeu	r17,r5,c87c <__udivdi3+0x4f8>
    c864:	8c23883a 	add	r17,r17,r16
    c868:	10ffffc4 	addi	r3,r2,-1
    c86c:	8c002d36 	bltu	r17,r16,c924 <__udivdi3+0x5a0>
    c870:	89402c2e 	bgeu	r17,r5,c924 <__udivdi3+0x5a0>
    c874:	10bfff84 	addi	r2,r2,-2
    c878:	8c23883a 	add	r17,r17,r16
    c87c:	a806943a 	slli	r3,r21,16
    c880:	8963c83a 	sub	r17,r17,r5
    c884:	10c6b03a 	or	r3,r2,r3
    c888:	003f4906 	br	c5b0 <__udivdi3+0x22c>
    c88c:	1009883a 	mov	r4,r2
    c890:	003f0906 	br	c4b8 <__udivdi3+0x134>
    c894:	1009883a 	mov	r4,r2
    c898:	003f6e06 	br	c654 <__udivdi3+0x2d0>
    c89c:	2008943a 	slli	r4,r4,16
    c8a0:	9420983a 	sll	r16,r18,r16
    c8a4:	423fffcc 	andi	r8,r8,65535
    c8a8:	2209883a 	add	r4,r4,r8
    c8ac:	813fc32e 	bgeu	r16,r4,c7bc <__udivdi3+0x438>
    c8b0:	10bfffc4 	addi	r2,r2,-1
    c8b4:	0007883a 	mov	r3,zero
    c8b8:	003f1806 	br	c51c <__udivdi3+0x198>
    c8bc:	00c00604 	movi	r3,24
    c8c0:	180b883a 	mov	r5,r3
    c8c4:	003f0806 	br	c4e8 <__udivdi3+0x164>
    c8c8:	00c00204 	movi	r3,8
    c8cc:	180b883a 	mov	r5,r3
    c8d0:	003f0506 	br	c4e8 <__udivdi3+0x164>
    c8d4:	00800604 	movi	r2,24
    c8d8:	1007883a 	mov	r3,r2
    c8dc:	003f2706 	br	c57c <__udivdi3+0x1f8>
    c8e0:	00800604 	movi	r2,24
    c8e4:	1007883a 	mov	r3,r2
    c8e8:	003ebe06 	br	c3e4 <__udivdi3+0x60>
    c8ec:	00800204 	movi	r2,8
    c8f0:	1007883a 	mov	r3,r2
    c8f4:	003ebb06 	br	c3e4 <__udivdi3+0x60>
    c8f8:	00800204 	movi	r2,8
    c8fc:	1007883a 	mov	r3,r2
    c900:	003f1e06 	br	c57c <__udivdi3+0x1f8>
    c904:	197f972e 	bgeu	r3,r5,c764 <__udivdi3+0x3e0>
    c908:	213fff84 	addi	r4,r4,-2
    c90c:	1cc7883a 	add	r3,r3,r19
    c910:	003f9506 	br	c768 <__udivdi3+0x3e4>
    c914:	21bf802e 	bgeu	r4,r6,c718 <__udivdi3+0x394>
    c918:	ad7fff84 	addi	r21,r21,-2
    c91c:	24c9883a 	add	r4,r4,r19
    c920:	003f7e06 	br	c71c <__udivdi3+0x398>
    c924:	1805883a 	mov	r2,r3
    c928:	003fd406 	br	c87c <__udivdi3+0x4f8>
    c92c:	102b883a 	mov	r21,r2
    c930:	003fbf06 	br	c830 <__udivdi3+0x4ac>
    c934:	8c7fff84 	addi	r17,r17,-2
    c938:	2409883a 	add	r4,r4,r16
    c93c:	003f3006 	br	c600 <__udivdi3+0x27c>
    c940:	94bfff84 	addi	r18,r18,-2
    c944:	1c07883a 	add	r3,r3,r16
    c948:	003ec806 	br	c46c <__udivdi3+0xe8>

0000c94c <__umoddi3>:
    c94c:	defff504 	addi	sp,sp,-44
    c950:	dd000515 	stw	r20,20(sp)
    c954:	dcc00415 	stw	r19,16(sp)
    c958:	dc800315 	stw	r18,12(sp)
    c95c:	dc400215 	stw	r17,8(sp)
    c960:	dc000115 	stw	r16,4(sp)
    c964:	dfc00a15 	stw	ra,40(sp)
    c968:	df000915 	stw	fp,36(sp)
    c96c:	ddc00815 	stw	r23,32(sp)
    c970:	dd800715 	stw	r22,28(sp)
    c974:	dd400615 	stw	r21,24(sp)
    c978:	2025883a 	mov	r18,r4
    c97c:	2823883a 	mov	r17,r5
    c980:	3021883a 	mov	r16,r6
    c984:	2027883a 	mov	r19,r4
    c988:	2829883a 	mov	r20,r5
    c98c:	3800351e 	bne	r7,zero,ca64 <__umoddi3+0x118>
    c990:	29804d2e 	bgeu	r5,r6,cac8 <__umoddi3+0x17c>
    c994:	00bfffd4 	movui	r2,65535
    c998:	11809a36 	bltu	r2,r6,cc04 <__umoddi3+0x2b8>
    c99c:	00803fc4 	movi	r2,255
    c9a0:	11813936 	bltu	r2,r6,ce88 <__umoddi3+0x53c>
    c9a4:	0005883a 	mov	r2,zero
    c9a8:	0009883a 	mov	r4,zero
    c9ac:	3084d83a 	srl	r2,r6,r2
    c9b0:	00c00134 	movhi	r3,4
    c9b4:	18c22404 	addi	r3,r3,2192
    c9b8:	05400804 	movi	r21,32
    c9bc:	1885883a 	add	r2,r3,r2
    c9c0:	10800003 	ldbu	r2,0(r2)
    c9c4:	1109883a 	add	r4,r2,r4
    c9c8:	a92bc83a 	sub	r21,r21,r4
    c9cc:	a800ec26 	beq	r21,zero,cd80 <__umoddi3+0x434>
    c9d0:	8d62983a 	sll	r17,r17,r21
    c9d4:	9108d83a 	srl	r4,r18,r4
    c9d8:	3560983a 	sll	r16,r6,r21
    c9dc:	9566983a 	sll	r19,r18,r21
    c9e0:	8928b03a 	or	r20,r17,r4
    c9e4:	8022d43a 	srli	r17,r16,16
    c9e8:	a009883a 	mov	r4,r20
    c9ec:	84bfffcc 	andi	r18,r16,65535
    c9f0:	880b883a 	mov	r5,r17
    c9f4:	000dd400 	call	dd40 <__umodsi3>
    c9f8:	a009883a 	mov	r4,r20
    c9fc:	880b883a 	mov	r5,r17
    ca00:	102d883a 	mov	r22,r2
    ca04:	000dd380 	call	dd38 <__udivsi3>
    ca08:	b02c943a 	slli	r22,r22,16
    ca0c:	9806d43a 	srli	r3,r19,16
    ca10:	1485383a 	mul	r2,r2,r18
    ca14:	b0c6b03a 	or	r3,r22,r3
    ca18:	1880042e 	bgeu	r3,r2,ca2c <__umoddi3+0xe0>
    ca1c:	1c07883a 	add	r3,r3,r16
    ca20:	1c000236 	bltu	r3,r16,ca2c <__umoddi3+0xe0>
    ca24:	1880012e 	bgeu	r3,r2,ca2c <__umoddi3+0xe0>
    ca28:	1c07883a 	add	r3,r3,r16
    ca2c:	18a9c83a 	sub	r20,r3,r2
    ca30:	a009883a 	mov	r4,r20
    ca34:	880b883a 	mov	r5,r17
    ca38:	000dd400 	call	dd40 <__umodsi3>
    ca3c:	102d883a 	mov	r22,r2
    ca40:	a009883a 	mov	r4,r20
    ca44:	880b883a 	mov	r5,r17
    ca48:	000dd380 	call	dd38 <__udivsi3>
    ca4c:	b02c943a 	slli	r22,r22,16
    ca50:	1485383a 	mul	r2,r2,r18
    ca54:	9cffffcc 	andi	r19,r19,65535
    ca58:	b4e6b03a 	or	r19,r22,r19
    ca5c:	9880522e 	bgeu	r19,r2,cba8 <__umoddi3+0x25c>
    ca60:	00004d06 	br	cb98 <__umoddi3+0x24c>
    ca64:	29c05436 	bltu	r5,r7,cbb8 <__umoddi3+0x26c>
    ca68:	00bfffd4 	movui	r2,65535
    ca6c:	11c0602e 	bgeu	r2,r7,cbf0 <__umoddi3+0x2a4>
    ca70:	00804034 	movhi	r2,256
    ca74:	10bfffc4 	addi	r2,r2,-1
    ca78:	11c0f736 	bltu	r2,r7,ce58 <__umoddi3+0x50c>
    ca7c:	00c00404 	movi	r3,16
    ca80:	1827883a 	mov	r19,r3
    ca84:	38c6d83a 	srl	r3,r7,r3
    ca88:	01000134 	movhi	r4,4
    ca8c:	21022404 	addi	r4,r4,2192
    ca90:	04000804 	movi	r16,32
    ca94:	20c7883a 	add	r3,r4,r3
    ca98:	18800003 	ldbu	r2,0(r3)
    ca9c:	14e7883a 	add	r19,r2,r19
    caa0:	84e1c83a 	sub	r16,r16,r19
    caa4:	8000621e 	bne	r16,zero,cc30 <__umoddi3+0x2e4>
    caa8:	3c400136 	bltu	r7,r17,cab0 <__umoddi3+0x164>
    caac:	91810336 	bltu	r18,r6,cebc <__umoddi3+0x570>
    cab0:	9185c83a 	sub	r2,r18,r6
    cab4:	89e3c83a 	sub	r17,r17,r7
    cab8:	90a5803a 	cmpltu	r18,r18,r2
    cabc:	8ca9c83a 	sub	r20,r17,r18
    cac0:	a007883a 	mov	r3,r20
    cac4:	00003e06 	br	cbc0 <__umoddi3+0x274>
    cac8:	3000041e 	bne	r6,zero,cadc <__umoddi3+0x190>
    cacc:	01000044 	movi	r4,1
    cad0:	000b883a 	mov	r5,zero
    cad4:	000dd380 	call	dd38 <__udivsi3>
    cad8:	1021883a 	mov	r16,r2
    cadc:	00bfffd4 	movui	r2,65535
    cae0:	14004e2e 	bgeu	r2,r16,cc1c <__umoddi3+0x2d0>
    cae4:	00804034 	movhi	r2,256
    cae8:	10bfffc4 	addi	r2,r2,-1
    caec:	1400e336 	bltu	r2,r16,ce7c <__umoddi3+0x530>
    caf0:	00800404 	movi	r2,16
    caf4:	1007883a 	mov	r3,r2
    caf8:	8084d83a 	srl	r2,r16,r2
    cafc:	01000134 	movhi	r4,4
    cb00:	21022404 	addi	r4,r4,2192
    cb04:	05400804 	movi	r21,32
    cb08:	2085883a 	add	r2,r4,r2
    cb0c:	10800003 	ldbu	r2,0(r2)
    cb10:	10c7883a 	add	r3,r2,r3
    cb14:	a8ebc83a 	sub	r21,r21,r3
    cb18:	a8009b1e 	bne	r21,zero,cd88 <__umoddi3+0x43c>
    cb1c:	8028d43a 	srli	r20,r16,16
    cb20:	8c23c83a 	sub	r17,r17,r16
    cb24:	85bfffcc 	andi	r22,r16,65535
    cb28:	8809883a 	mov	r4,r17
    cb2c:	a00b883a 	mov	r5,r20
    cb30:	000dd400 	call	dd40 <__umodsi3>
    cb34:	8809883a 	mov	r4,r17
    cb38:	a00b883a 	mov	r5,r20
    cb3c:	1025883a 	mov	r18,r2
    cb40:	000dd380 	call	dd38 <__udivsi3>
    cb44:	9024943a 	slli	r18,r18,16
    cb48:	9806d43a 	srli	r3,r19,16
    cb4c:	1585383a 	mul	r2,r2,r22
    cb50:	90c6b03a 	or	r3,r18,r3
    cb54:	1880032e 	bgeu	r3,r2,cb64 <__umoddi3+0x218>
    cb58:	1c07883a 	add	r3,r3,r16
    cb5c:	1c000136 	bltu	r3,r16,cb64 <__umoddi3+0x218>
    cb60:	1880d436 	bltu	r3,r2,ceb4 <__umoddi3+0x568>
    cb64:	18a3c83a 	sub	r17,r3,r2
    cb68:	8809883a 	mov	r4,r17
    cb6c:	a00b883a 	mov	r5,r20
    cb70:	000dd400 	call	dd40 <__umodsi3>
    cb74:	1025883a 	mov	r18,r2
    cb78:	8809883a 	mov	r4,r17
    cb7c:	a00b883a 	mov	r5,r20
    cb80:	000dd380 	call	dd38 <__udivsi3>
    cb84:	9024943a 	slli	r18,r18,16
    cb88:	1585383a 	mul	r2,r2,r22
    cb8c:	9cffffcc 	andi	r19,r19,65535
    cb90:	94e6b03a 	or	r19,r18,r19
    cb94:	9880042e 	bgeu	r19,r2,cba8 <__umoddi3+0x25c>
    cb98:	9c27883a 	add	r19,r19,r16
    cb9c:	9c000236 	bltu	r19,r16,cba8 <__umoddi3+0x25c>
    cba0:	9880012e 	bgeu	r19,r2,cba8 <__umoddi3+0x25c>
    cba4:	9c27883a 	add	r19,r19,r16
    cba8:	98a7c83a 	sub	r19,r19,r2
    cbac:	9d44d83a 	srl	r2,r19,r21
    cbb0:	0007883a 	mov	r3,zero
    cbb4:	00000206 	br	cbc0 <__umoddi3+0x274>
    cbb8:	2005883a 	mov	r2,r4
    cbbc:	2807883a 	mov	r3,r5
    cbc0:	dfc00a17 	ldw	ra,40(sp)
    cbc4:	df000917 	ldw	fp,36(sp)
    cbc8:	ddc00817 	ldw	r23,32(sp)
    cbcc:	dd800717 	ldw	r22,28(sp)
    cbd0:	dd400617 	ldw	r21,24(sp)
    cbd4:	dd000517 	ldw	r20,20(sp)
    cbd8:	dcc00417 	ldw	r19,16(sp)
    cbdc:	dc800317 	ldw	r18,12(sp)
    cbe0:	dc400217 	ldw	r17,8(sp)
    cbe4:	dc000117 	ldw	r16,4(sp)
    cbe8:	dec00b04 	addi	sp,sp,44
    cbec:	f800283a 	ret
    cbf0:	00803fc4 	movi	r2,255
    cbf4:	11c09536 	bltu	r2,r7,ce4c <__umoddi3+0x500>
    cbf8:	0007883a 	mov	r3,zero
    cbfc:	0027883a 	mov	r19,zero
    cc00:	003fa006 	br	ca84 <__umoddi3+0x138>
    cc04:	00804034 	movhi	r2,256
    cc08:	10bfffc4 	addi	r2,r2,-1
    cc0c:	11809536 	bltu	r2,r6,ce64 <__umoddi3+0x518>
    cc10:	00800404 	movi	r2,16
    cc14:	1009883a 	mov	r4,r2
    cc18:	003f6406 	br	c9ac <__umoddi3+0x60>
    cc1c:	00803fc4 	movi	r2,255
    cc20:	14009336 	bltu	r2,r16,ce70 <__umoddi3+0x524>
    cc24:	0005883a 	mov	r2,zero
    cc28:	0007883a 	mov	r3,zero
    cc2c:	003fb206 	br	caf8 <__umoddi3+0x1ac>
    cc30:	34c4d83a 	srl	r2,r6,r19
    cc34:	3c0e983a 	sll	r7,r7,r16
    cc38:	8ceed83a 	srl	r23,r17,r19
    cc3c:	8c22983a 	sll	r17,r17,r16
    cc40:	38a8b03a 	or	r20,r7,r2
    cc44:	a02ad43a 	srli	r21,r20,16
    cc48:	94c4d83a 	srl	r2,r18,r19
    cc4c:	b809883a 	mov	r4,r23
    cc50:	a80b883a 	mov	r5,r21
    cc54:	88a2b03a 	or	r17,r17,r2
    cc58:	342c983a 	sll	r22,r6,r16
    cc5c:	000dd400 	call	dd40 <__umodsi3>
    cc60:	b809883a 	mov	r4,r23
    cc64:	a80b883a 	mov	r5,r21
    cc68:	d8800015 	stw	r2,0(sp)
    cc6c:	000dd380 	call	dd38 <__udivsi3>
    cc70:	d8c00017 	ldw	r3,0(sp)
    cc74:	102f883a 	mov	r23,r2
    cc78:	a73fffcc 	andi	fp,r20,65535
    cc7c:	180a943a 	slli	r5,r3,16
    cc80:	8804d43a 	srli	r2,r17,16
    cc84:	bf09383a 	mul	r4,r23,fp
    cc88:	9424983a 	sll	r18,r18,r16
    cc8c:	288ab03a 	or	r5,r5,r2
    cc90:	2900042e 	bgeu	r5,r4,cca4 <__umoddi3+0x358>
    cc94:	2d0b883a 	add	r5,r5,r20
    cc98:	b8bfffc4 	addi	r2,r23,-1
    cc9c:	2d00812e 	bgeu	r5,r20,cea4 <__umoddi3+0x558>
    cca0:	102f883a 	mov	r23,r2
    cca4:	2907c83a 	sub	r3,r5,r4
    cca8:	1809883a 	mov	r4,r3
    ccac:	a80b883a 	mov	r5,r21
    ccb0:	d8c00015 	stw	r3,0(sp)
    ccb4:	000dd400 	call	dd40 <__umodsi3>
    ccb8:	d8c00017 	ldw	r3,0(sp)
    ccbc:	a80b883a 	mov	r5,r21
    ccc0:	d8800015 	stw	r2,0(sp)
    ccc4:	1809883a 	mov	r4,r3
    ccc8:	000dd380 	call	dd38 <__udivsi3>
    cccc:	d9800017 	ldw	r6,0(sp)
    ccd0:	8c7fffcc 	andi	r17,r17,65535
    ccd4:	3008943a 	slli	r4,r6,16
    ccd8:	170d383a 	mul	r6,r2,fp
    ccdc:	2448b03a 	or	r4,r4,r17
    cce0:	2180042e 	bgeu	r4,r6,ccf4 <__umoddi3+0x3a8>
    cce4:	2509883a 	add	r4,r4,r20
    cce8:	10ffffc4 	addi	r3,r2,-1
    ccec:	2500692e 	bgeu	r4,r20,ce94 <__umoddi3+0x548>
    ccf0:	1805883a 	mov	r2,r3
    ccf4:	b82e943a 	slli	r23,r23,16
    ccf8:	b010d43a 	srli	r8,r22,16
    ccfc:	b1ffffcc 	andi	r7,r22,65535
    cd00:	15eeb03a 	or	r23,r2,r23
    cd04:	b8bfffcc 	andi	r2,r23,65535
    cd08:	b82ed43a 	srli	r23,r23,16
    cd0c:	11c7383a 	mul	r3,r2,r7
    cd10:	1205383a 	mul	r2,r2,r8
    cd14:	b9cf383a 	mul	r7,r23,r7
    cd18:	400b883a 	mov	r5,r8
    cd1c:	1810d43a 	srli	r8,r3,16
    cd20:	3885883a 	add	r2,r7,r2
    cd24:	2189c83a 	sub	r4,r4,r6
    cd28:	1205883a 	add	r2,r2,r8
    cd2c:	b94b383a 	mul	r5,r23,r5
    cd30:	11c0022e 	bgeu	r2,r7,cd3c <__umoddi3+0x3f0>
    cd34:	01800074 	movhi	r6,1
    cd38:	298b883a 	add	r5,r5,r6
    cd3c:	100cd43a 	srli	r6,r2,16
    cd40:	1004943a 	slli	r2,r2,16
    cd44:	18ffffcc 	andi	r3,r3,65535
    cd48:	298b883a 	add	r5,r5,r6
    cd4c:	10c5883a 	add	r2,r2,r3
    cd50:	21403836 	bltu	r4,r5,ce34 <__umoddi3+0x4e8>
    cd54:	21405c26 	beq	r4,r5,cec8 <__umoddi3+0x57c>
    cd58:	2147c83a 	sub	r3,r4,r5
    cd5c:	102d883a 	mov	r22,r2
    cd60:	95adc83a 	sub	r22,r18,r22
    cd64:	95a5803a 	cmpltu	r18,r18,r22
    cd68:	1c87c83a 	sub	r3,r3,r18
    cd6c:	1cc4983a 	sll	r2,r3,r19
    cd70:	b42cd83a 	srl	r22,r22,r16
    cd74:	1c06d83a 	srl	r3,r3,r16
    cd78:	1584b03a 	or	r2,r2,r22
    cd7c:	003f9006 	br	cbc0 <__umoddi3+0x274>
    cd80:	002b883a 	mov	r21,zero
    cd84:	003f1706 	br	c9e4 <__umoddi3+0x98>
    cd88:	8560983a 	sll	r16,r16,r21
    cd8c:	88e6d83a 	srl	r19,r17,r3
    cd90:	90c6d83a 	srl	r3,r18,r3
    cd94:	8028d43a 	srli	r20,r16,16
    cd98:	8d62983a 	sll	r17,r17,r21
    cd9c:	9809883a 	mov	r4,r19
    cda0:	a00b883a 	mov	r5,r20
    cda4:	88eeb03a 	or	r23,r17,r3
    cda8:	000dd400 	call	dd40 <__umodsi3>
    cdac:	9809883a 	mov	r4,r19
    cdb0:	a00b883a 	mov	r5,r20
    cdb4:	1023883a 	mov	r17,r2
    cdb8:	000dd380 	call	dd38 <__udivsi3>
    cdbc:	85bfffcc 	andi	r22,r16,65535
    cdc0:	880a943a 	slli	r5,r17,16
    cdc4:	b806d43a 	srli	r3,r23,16
    cdc8:	1585383a 	mul	r2,r2,r22
    cdcc:	9566983a 	sll	r19,r18,r21
    cdd0:	28cab03a 	or	r5,r5,r3
    cdd4:	2880042e 	bgeu	r5,r2,cde8 <__umoddi3+0x49c>
    cdd8:	2c0b883a 	add	r5,r5,r16
    cddc:	2c000236 	bltu	r5,r16,cde8 <__umoddi3+0x49c>
    cde0:	2880012e 	bgeu	r5,r2,cde8 <__umoddi3+0x49c>
    cde4:	2c0b883a 	add	r5,r5,r16
    cde8:	28a5c83a 	sub	r18,r5,r2
    cdec:	9009883a 	mov	r4,r18
    cdf0:	a00b883a 	mov	r5,r20
    cdf4:	000dd400 	call	dd40 <__umodsi3>
    cdf8:	1023883a 	mov	r17,r2
    cdfc:	9009883a 	mov	r4,r18
    ce00:	a00b883a 	mov	r5,r20
    ce04:	000dd380 	call	dd38 <__udivsi3>
    ce08:	8822943a 	slli	r17,r17,16
    ce0c:	1585383a 	mul	r2,r2,r22
    ce10:	bdffffcc 	andi	r23,r23,65535
    ce14:	8de2b03a 	or	r17,r17,r23
    ce18:	8880042e 	bgeu	r17,r2,ce2c <__umoddi3+0x4e0>
    ce1c:	8c23883a 	add	r17,r17,r16
    ce20:	8c000236 	bltu	r17,r16,ce2c <__umoddi3+0x4e0>
    ce24:	8880012e 	bgeu	r17,r2,ce2c <__umoddi3+0x4e0>
    ce28:	8c23883a 	add	r17,r17,r16
    ce2c:	88a3c83a 	sub	r17,r17,r2
    ce30:	003f3d06 	br	cb28 <__umoddi3+0x1dc>
    ce34:	15adc83a 	sub	r22,r2,r22
    ce38:	2d07c83a 	sub	r3,r5,r20
    ce3c:	1585803a 	cmpltu	r2,r2,r22
    ce40:	1887c83a 	sub	r3,r3,r2
    ce44:	20c7c83a 	sub	r3,r4,r3
    ce48:	003fc506 	br	cd60 <__umoddi3+0x414>
    ce4c:	00c00204 	movi	r3,8
    ce50:	1827883a 	mov	r19,r3
    ce54:	003f0b06 	br	ca84 <__umoddi3+0x138>
    ce58:	00c00604 	movi	r3,24
    ce5c:	1827883a 	mov	r19,r3
    ce60:	003f0806 	br	ca84 <__umoddi3+0x138>
    ce64:	00800604 	movi	r2,24
    ce68:	1009883a 	mov	r4,r2
    ce6c:	003ecf06 	br	c9ac <__umoddi3+0x60>
    ce70:	00800204 	movi	r2,8
    ce74:	1007883a 	mov	r3,r2
    ce78:	003f1f06 	br	caf8 <__umoddi3+0x1ac>
    ce7c:	00800604 	movi	r2,24
    ce80:	1007883a 	mov	r3,r2
    ce84:	003f1c06 	br	caf8 <__umoddi3+0x1ac>
    ce88:	00800204 	movi	r2,8
    ce8c:	1009883a 	mov	r4,r2
    ce90:	003ec606 	br	c9ac <__umoddi3+0x60>
    ce94:	21bf962e 	bgeu	r4,r6,ccf0 <__umoddi3+0x3a4>
    ce98:	10bfff84 	addi	r2,r2,-2
    ce9c:	2509883a 	add	r4,r4,r20
    cea0:	003f9406 	br	ccf4 <__umoddi3+0x3a8>
    cea4:	293f7e2e 	bgeu	r5,r4,cca0 <__umoddi3+0x354>
    cea8:	bdffff84 	addi	r23,r23,-2
    ceac:	2d0b883a 	add	r5,r5,r20
    ceb0:	003f7c06 	br	cca4 <__umoddi3+0x358>
    ceb4:	1c07883a 	add	r3,r3,r16
    ceb8:	003f2a06 	br	cb64 <__umoddi3+0x218>
    cebc:	9005883a 	mov	r2,r18
    cec0:	a007883a 	mov	r3,r20
    cec4:	003f3e06 	br	cbc0 <__umoddi3+0x274>
    cec8:	90bfda36 	bltu	r18,r2,ce34 <__umoddi3+0x4e8>
    cecc:	102d883a 	mov	r22,r2
    ced0:	0007883a 	mov	r3,zero
    ced4:	003fa206 	br	cd60 <__umoddi3+0x414>

0000ced8 <_fpadd_parts>:
    ced8:	2005883a 	mov	r2,r4
    cedc:	21000017 	ldw	r4,0(r4)
    cee0:	01c00044 	movi	r7,1
    cee4:	3900622e 	bgeu	r7,r4,d070 <_fpadd_parts+0x198>
    cee8:	28c00017 	ldw	r3,0(r5)
    ceec:	38c05f2e 	bgeu	r7,r3,d06c <_fpadd_parts+0x194>
    cef0:	01c00104 	movi	r7,4
    cef4:	21c0c626 	beq	r4,r7,d210 <_fpadd_parts+0x338>
    cef8:	19c05c26 	beq	r3,r7,d06c <_fpadd_parts+0x194>
    cefc:	01c00084 	movi	r7,2
    cf00:	19c06b26 	beq	r3,r7,d0b0 <_fpadd_parts+0x1d8>
    cf04:	21c05926 	beq	r4,r7,d06c <_fpadd_parts+0x194>
    cf08:	11c00217 	ldw	r7,8(r2)
    cf0c:	2ac00217 	ldw	r11,8(r5)
    cf10:	13000317 	ldw	r12,12(r2)
    cf14:	13400417 	ldw	r13,16(r2)
    cf18:	3ac9c83a 	sub	r4,r7,r11
    cf1c:	2a000317 	ldw	r8,12(r5)
    cf20:	2a400417 	ldw	r9,16(r5)
    cf24:	2015883a 	mov	r10,r4
    cf28:	20007516 	blt	r4,zero,d100 <_fpadd_parts+0x228>
    cf2c:	00c00fc4 	movi	r3,63
    cf30:	1a805016 	blt	r3,r10,d074 <_fpadd_parts+0x19c>
    cf34:	0100870e 	bge	zero,r4,d154 <_fpadd_parts+0x27c>
    cf38:	50fff804 	addi	r3,r10,-32
    cf3c:	18009916 	blt	r3,zero,d1a4 <_fpadd_parts+0x2cc>
    cf40:	48d6d83a 	srl	r11,r9,r3
    cf44:	001d883a 	mov	r14,zero
    cf48:	18009e16 	blt	r3,zero,d1c4 <_fpadd_parts+0x2ec>
    cf4c:	01000044 	movi	r4,1
    cf50:	20c6983a 	sll	r3,r4,r3
    cf54:	0015883a 	mov	r10,zero
    cf58:	513fffc4 	addi	r4,r10,-1
    cf5c:	2295403a 	cmpgeu	r10,r4,r10
    cf60:	1a87c83a 	sub	r3,r3,r10
    cf64:	1a52703a 	and	r9,r3,r9
    cf68:	2210703a 	and	r8,r4,r8
    cf6c:	4250b03a 	or	r8,r8,r9
    cf70:	4010c03a 	cmpne	r8,r8,zero
    cf74:	42d0b03a 	or	r8,r8,r11
    cf78:	7013883a 	mov	r9,r14
    cf7c:	11000117 	ldw	r4,4(r2)
    cf80:	28800117 	ldw	r2,4(r5)
    cf84:	20804126 	beq	r4,r2,d08c <_fpadd_parts+0x1b4>
    cf88:	20006326 	beq	r4,zero,d118 <_fpadd_parts+0x240>
    cf8c:	4305c83a 	sub	r2,r8,r12
    cf90:	4091803a 	cmpltu	r8,r8,r2
    cf94:	4b47c83a 	sub	r3,r9,r13
    cf98:	1a07c83a 	sub	r3,r3,r8
    cf9c:	18006316 	blt	r3,zero,d12c <_fpadd_parts+0x254>
    cfa0:	30000115 	stw	zero,4(r6)
    cfa4:	31c00215 	stw	r7,8(r6)
    cfa8:	30800315 	stw	r2,12(r6)
    cfac:	30c00415 	stw	r3,16(r6)
    cfb0:	11ffffc4 	addi	r7,r2,-1
    cfb4:	388b403a 	cmpgeu	r5,r7,r2
    cfb8:	194bc83a 	sub	r5,r3,r5
    cfbc:	01040034 	movhi	r4,4096
    cfc0:	213fffc4 	addi	r4,r4,-1
    cfc4:	21401736 	bltu	r4,r5,d024 <_fpadd_parts+0x14c>
    cfc8:	29008226 	beq	r5,r4,d1d4 <_fpadd_parts+0x2fc>
    cfcc:	31400217 	ldw	r5,8(r6)
    cfd0:	02840034 	movhi	r10,4096
    cfd4:	52bfffc4 	addi	r10,r10,-1
    cfd8:	033fff84 	movi	r12,-2
    cfdc:	297fffc4 	addi	r5,r5,-1
    cfe0:	00000106 	br	cfe8 <_fpadd_parts+0x110>
    cfe4:	3a804a26 	beq	r7,r10,d110 <_fpadd_parts+0x238>
    cfe8:	1089883a 	add	r4,r2,r2
    cfec:	2091803a 	cmpltu	r8,r4,r2
    cff0:	18c7883a 	add	r3,r3,r3
    cff4:	227fffc4 	addi	r9,r4,-1
    cff8:	40d1883a 	add	r8,r8,r3
    cffc:	490f403a 	cmpgeu	r7,r9,r4
    d000:	41cfc83a 	sub	r7,r8,r7
    d004:	2817883a 	mov	r11,r5
    d008:	2005883a 	mov	r2,r4
    d00c:	4007883a 	mov	r3,r8
    d010:	297fffc4 	addi	r5,r5,-1
    d014:	51fff32e 	bgeu	r10,r7,cfe4 <_fpadd_parts+0x10c>
    d018:	31000315 	stw	r4,12(r6)
    d01c:	32000415 	stw	r8,16(r6)
    d020:	32c00215 	stw	r11,8(r6)
    d024:	010000c4 	movi	r4,3
    d028:	31000015 	stw	r4,0(r6)
    d02c:	01080034 	movhi	r4,8192
    d030:	213fffc4 	addi	r4,r4,-1
    d034:	20c00b2e 	bgeu	r4,r3,d064 <_fpadd_parts+0x18c>
    d038:	180e97fa 	slli	r7,r3,31
    d03c:	1008d07a 	srli	r4,r2,1
    d040:	31400217 	ldw	r5,8(r6)
    d044:	1806d07a 	srli	r3,r3,1
    d048:	1080004c 	andi	r2,r2,1
    d04c:	3908b03a 	or	r4,r7,r4
    d050:	1108b03a 	or	r4,r2,r4
    d054:	29400044 	addi	r5,r5,1
    d058:	31000315 	stw	r4,12(r6)
    d05c:	30c00415 	stw	r3,16(r6)
    d060:	31400215 	stw	r5,8(r6)
    d064:	3005883a 	mov	r2,r6
    d068:	f800283a 	ret
    d06c:	2805883a 	mov	r2,r5
    d070:	f800283a 	ret
    d074:	59c01e0e 	bge	r11,r7,d0f0 <_fpadd_parts+0x218>
    d078:	11000117 	ldw	r4,4(r2)
    d07c:	28800117 	ldw	r2,4(r5)
    d080:	0011883a 	mov	r8,zero
    d084:	0013883a 	mov	r9,zero
    d088:	20bfbf1e 	bne	r4,r2,cf88 <_fpadd_parts+0xb0>
    d08c:	4305883a 	add	r2,r8,r12
    d090:	1207803a 	cmpltu	r3,r2,r8
    d094:	4b53883a 	add	r9,r9,r13
    d098:	1a47883a 	add	r3,r3,r9
    d09c:	31000115 	stw	r4,4(r6)
    d0a0:	31c00215 	stw	r7,8(r6)
    d0a4:	30800315 	stw	r2,12(r6)
    d0a8:	30c00415 	stw	r3,16(r6)
    d0ac:	003fdd06 	br	d024 <_fpadd_parts+0x14c>
    d0b0:	20ffef1e 	bne	r4,r3,d070 <_fpadd_parts+0x198>
    d0b4:	31000015 	stw	r4,0(r6)
    d0b8:	10c00117 	ldw	r3,4(r2)
    d0bc:	30c00115 	stw	r3,4(r6)
    d0c0:	10c00217 	ldw	r3,8(r2)
    d0c4:	11000117 	ldw	r4,4(r2)
    d0c8:	29400117 	ldw	r5,4(r5)
    d0cc:	30c00215 	stw	r3,8(r6)
    d0d0:	10c00317 	ldw	r3,12(r2)
    d0d4:	2908703a 	and	r4,r5,r4
    d0d8:	30c00315 	stw	r3,12(r6)
    d0dc:	10c00417 	ldw	r3,16(r2)
    d0e0:	31000115 	stw	r4,4(r6)
    d0e4:	3005883a 	mov	r2,r6
    d0e8:	30c00415 	stw	r3,16(r6)
    d0ec:	f800283a 	ret
    d0f0:	580f883a 	mov	r7,r11
    d0f4:	0019883a 	mov	r12,zero
    d0f8:	001b883a 	mov	r13,zero
    d0fc:	003f9f06 	br	cf7c <_fpadd_parts+0xa4>
    d100:	0115c83a 	sub	r10,zero,r4
    d104:	00c00fc4 	movi	r3,63
    d108:	1abfda16 	blt	r3,r10,d074 <_fpadd_parts+0x19c>
    d10c:	003f8906 	br	cf34 <_fpadd_parts+0x5c>
    d110:	627fb52e 	bgeu	r12,r9,cfe8 <_fpadd_parts+0x110>
    d114:	003fc006 	br	d018 <_fpadd_parts+0x140>
    d118:	6205c83a 	sub	r2,r12,r8
    d11c:	6099803a 	cmpltu	r12,r12,r2
    d120:	6a47c83a 	sub	r3,r13,r9
    d124:	1b07c83a 	sub	r3,r3,r12
    d128:	183f9d0e 	bge	r3,zero,cfa0 <_fpadd_parts+0xc8>
    d12c:	0085c83a 	sub	r2,zero,r2
    d130:	1008c03a 	cmpne	r4,r2,zero
    d134:	00c7c83a 	sub	r3,zero,r3
    d138:	1907c83a 	sub	r3,r3,r4
    d13c:	01000044 	movi	r4,1
    d140:	31000115 	stw	r4,4(r6)
    d144:	31c00215 	stw	r7,8(r6)
    d148:	30800315 	stw	r2,12(r6)
    d14c:	30c00415 	stw	r3,16(r6)
    d150:	003f9706 	br	cfb0 <_fpadd_parts+0xd8>
    d154:	203f8926 	beq	r4,zero,cf7c <_fpadd_parts+0xa4>
    d158:	50fff804 	addi	r3,r10,-32
    d15c:	3a8f883a 	add	r7,r7,r10
    d160:	18002316 	blt	r3,zero,d1f0 <_fpadd_parts+0x318>
    d164:	68d6d83a 	srl	r11,r13,r3
    d168:	001d883a 	mov	r14,zero
    d16c:	18001c16 	blt	r3,zero,d1e0 <_fpadd_parts+0x308>
    d170:	01000044 	movi	r4,1
    d174:	20c6983a 	sll	r3,r4,r3
    d178:	0015883a 	mov	r10,zero
    d17c:	513fffc4 	addi	r4,r10,-1
    d180:	2295403a 	cmpgeu	r10,r4,r10
    d184:	1a87c83a 	sub	r3,r3,r10
    d188:	1b5a703a 	and	r13,r3,r13
    d18c:	2318703a 	and	r12,r4,r12
    d190:	6358b03a 	or	r12,r12,r13
    d194:	6018c03a 	cmpne	r12,r12,zero
    d198:	62d8b03a 	or	r12,r12,r11
    d19c:	701b883a 	mov	r13,r14
    d1a0:	003f7606 	br	cf7c <_fpadd_parts+0xa4>
    d1a4:	4808907a 	slli	r4,r9,1
    d1a8:	02c007c4 	movi	r11,31
    d1ac:	5a97c83a 	sub	r11,r11,r10
    d1b0:	22c8983a 	sll	r4,r4,r11
    d1b4:	4296d83a 	srl	r11,r8,r10
    d1b8:	4a9cd83a 	srl	r14,r9,r10
    d1bc:	22d6b03a 	or	r11,r4,r11
    d1c0:	003f6106 	br	cf48 <_fpadd_parts+0x70>
    d1c4:	00c00044 	movi	r3,1
    d1c8:	1a94983a 	sll	r10,r3,r10
    d1cc:	0007883a 	mov	r3,zero
    d1d0:	003f6106 	br	cf58 <_fpadd_parts+0x80>
    d1d4:	013fff84 	movi	r4,-2
    d1d8:	21ff7c2e 	bgeu	r4,r7,cfcc <_fpadd_parts+0xf4>
    d1dc:	003f9106 	br	d024 <_fpadd_parts+0x14c>
    d1e0:	00c00044 	movi	r3,1
    d1e4:	1a94983a 	sll	r10,r3,r10
    d1e8:	0007883a 	mov	r3,zero
    d1ec:	003fe306 	br	d17c <_fpadd_parts+0x2a4>
    d1f0:	6816907a 	slli	r11,r13,1
    d1f4:	010007c4 	movi	r4,31
    d1f8:	2289c83a 	sub	r4,r4,r10
    d1fc:	5908983a 	sll	r4,r11,r4
    d200:	6296d83a 	srl	r11,r12,r10
    d204:	6a9cd83a 	srl	r14,r13,r10
    d208:	22d6b03a 	or	r11,r4,r11
    d20c:	003fd706 	br	d16c <_fpadd_parts+0x294>
    d210:	193f971e 	bne	r3,r4,d070 <_fpadd_parts+0x198>
    d214:	11000117 	ldw	r4,4(r2)
    d218:	28c00117 	ldw	r3,4(r5)
    d21c:	20ff9426 	beq	r4,r3,d070 <_fpadd_parts+0x198>
    d220:	00800134 	movhi	r2,4
    d224:	10821f04 	addi	r2,r2,2172
    d228:	f800283a 	ret

0000d22c <__adddf3>:
    d22c:	deffec04 	addi	sp,sp,-80
    d230:	d9001115 	stw	r4,68(sp)
    d234:	d9401215 	stw	r5,72(sp)
    d238:	d9001104 	addi	r4,sp,68
    d23c:	d9400a04 	addi	r5,sp,40
    d240:	dfc01315 	stw	ra,76(sp)
    d244:	d9c01015 	stw	r7,64(sp)
    d248:	d9800f15 	stw	r6,60(sp)
    d24c:	000e0780 	call	e078 <__unpack_d>
    d250:	d9000f04 	addi	r4,sp,60
    d254:	d9400504 	addi	r5,sp,20
    d258:	000e0780 	call	e078 <__unpack_d>
    d25c:	d9000a04 	addi	r4,sp,40
    d260:	d9400504 	addi	r5,sp,20
    d264:	d80d883a 	mov	r6,sp
    d268:	000ced80 	call	ced8 <_fpadd_parts>
    d26c:	1009883a 	mov	r4,r2
    d270:	000de540 	call	de54 <__pack_d>
    d274:	dfc01317 	ldw	ra,76(sp)
    d278:	dec01404 	addi	sp,sp,80
    d27c:	f800283a 	ret

0000d280 <__subdf3>:
    d280:	deffec04 	addi	sp,sp,-80
    d284:	d9001115 	stw	r4,68(sp)
    d288:	d9401215 	stw	r5,72(sp)
    d28c:	d9001104 	addi	r4,sp,68
    d290:	d9400a04 	addi	r5,sp,40
    d294:	dfc01315 	stw	ra,76(sp)
    d298:	d9c01015 	stw	r7,64(sp)
    d29c:	d9800f15 	stw	r6,60(sp)
    d2a0:	000e0780 	call	e078 <__unpack_d>
    d2a4:	d9000f04 	addi	r4,sp,60
    d2a8:	d9400504 	addi	r5,sp,20
    d2ac:	000e0780 	call	e078 <__unpack_d>
    d2b0:	d8800617 	ldw	r2,24(sp)
    d2b4:	d9000a04 	addi	r4,sp,40
    d2b8:	d9400504 	addi	r5,sp,20
    d2bc:	d80d883a 	mov	r6,sp
    d2c0:	1080005c 	xori	r2,r2,1
    d2c4:	d8800615 	stw	r2,24(sp)
    d2c8:	000ced80 	call	ced8 <_fpadd_parts>
    d2cc:	1009883a 	mov	r4,r2
    d2d0:	000de540 	call	de54 <__pack_d>
    d2d4:	dfc01317 	ldw	ra,76(sp)
    d2d8:	dec01404 	addi	sp,sp,80
    d2dc:	f800283a 	ret

0000d2e0 <__muldf3>:
    d2e0:	deffe404 	addi	sp,sp,-112
    d2e4:	d9001115 	stw	r4,68(sp)
    d2e8:	d9401215 	stw	r5,72(sp)
    d2ec:	d9001104 	addi	r4,sp,68
    d2f0:	d9400a04 	addi	r5,sp,40
    d2f4:	dfc01b15 	stw	ra,108(sp)
    d2f8:	d9800f15 	stw	r6,60(sp)
    d2fc:	d9c01015 	stw	r7,64(sp)
    d300:	ddc01a15 	stw	r23,104(sp)
    d304:	dd801915 	stw	r22,100(sp)
    d308:	dd401815 	stw	r21,96(sp)
    d30c:	dd001715 	stw	r20,92(sp)
    d310:	dcc01615 	stw	r19,88(sp)
    d314:	dc801515 	stw	r18,84(sp)
    d318:	dc401415 	stw	r17,80(sp)
    d31c:	dc001315 	stw	r16,76(sp)
    d320:	000e0780 	call	e078 <__unpack_d>
    d324:	d9000f04 	addi	r4,sp,60
    d328:	d9400504 	addi	r5,sp,20
    d32c:	000e0780 	call	e078 <__unpack_d>
    d330:	d8c00a17 	ldw	r3,40(sp)
    d334:	00800044 	movi	r2,1
    d338:	10c01136 	bltu	r2,r3,d380 <__muldf3+0xa0>
    d33c:	d8c00b17 	ldw	r3,44(sp)
    d340:	d8800617 	ldw	r2,24(sp)
    d344:	d9000a04 	addi	r4,sp,40
    d348:	1884c03a 	cmpne	r2,r3,r2
    d34c:	d8800b15 	stw	r2,44(sp)
    d350:	000de540 	call	de54 <__pack_d>
    d354:	dfc01b17 	ldw	ra,108(sp)
    d358:	ddc01a17 	ldw	r23,104(sp)
    d35c:	dd801917 	ldw	r22,100(sp)
    d360:	dd401817 	ldw	r21,96(sp)
    d364:	dd001717 	ldw	r20,92(sp)
    d368:	dcc01617 	ldw	r19,88(sp)
    d36c:	dc801517 	ldw	r18,84(sp)
    d370:	dc401417 	ldw	r17,80(sp)
    d374:	dc001317 	ldw	r16,76(sp)
    d378:	dec01c04 	addi	sp,sp,112
    d37c:	f800283a 	ret
    d380:	d9000517 	ldw	r4,20(sp)
    d384:	11000636 	bltu	r2,r4,d3a0 <__muldf3+0xc0>
    d388:	d8800617 	ldw	r2,24(sp)
    d38c:	d8c00b17 	ldw	r3,44(sp)
    d390:	d9000504 	addi	r4,sp,20
    d394:	1884c03a 	cmpne	r2,r3,r2
    d398:	d8800615 	stw	r2,24(sp)
    d39c:	003fec06 	br	d350 <__muldf3+0x70>
    d3a0:	00800104 	movi	r2,4
    d3a4:	1880051e 	bne	r3,r2,d3bc <__muldf3+0xdc>
    d3a8:	00800084 	movi	r2,2
    d3ac:	20bfe31e 	bne	r4,r2,d33c <__muldf3+0x5c>
    d3b0:	01000134 	movhi	r4,4
    d3b4:	21021f04 	addi	r4,r4,2172
    d3b8:	003fe506 	br	d350 <__muldf3+0x70>
    d3bc:	2080031e 	bne	r4,r2,d3cc <__muldf3+0xec>
    d3c0:	00800084 	movi	r2,2
    d3c4:	18bffa26 	beq	r3,r2,d3b0 <__muldf3+0xd0>
    d3c8:	003fef06 	br	d388 <__muldf3+0xa8>
    d3cc:	00800084 	movi	r2,2
    d3d0:	18bfda26 	beq	r3,r2,d33c <__muldf3+0x5c>
    d3d4:	20bfec26 	beq	r4,r2,d388 <__muldf3+0xa8>
    d3d8:	dc000d17 	ldw	r16,52(sp)
    d3dc:	dd000817 	ldw	r20,32(sp)
    d3e0:	dc800917 	ldw	r18,36(sp)
    d3e4:	8009883a 	mov	r4,r16
    d3e8:	000b883a 	mov	r5,zero
    d3ec:	a00d883a 	mov	r6,r20
    d3f0:	000f883a 	mov	r7,zero
    d3f4:	000dd480 	call	dd48 <__muldi3>
    d3f8:	dc400e17 	ldw	r17,56(sp)
    d3fc:	9009883a 	mov	r4,r18
    d400:	800d883a 	mov	r6,r16
    d404:	000b883a 	mov	r5,zero
    d408:	000f883a 	mov	r7,zero
    d40c:	102f883a 	mov	r23,r2
    d410:	1827883a 	mov	r19,r3
    d414:	000dd480 	call	dd48 <__muldi3>
    d418:	900d883a 	mov	r6,r18
    d41c:	8809883a 	mov	r4,r17
    d420:	000b883a 	mov	r5,zero
    d424:	000f883a 	mov	r7,zero
    d428:	102b883a 	mov	r21,r2
    d42c:	1821883a 	mov	r16,r3
    d430:	000dd480 	call	dd48 <__muldi3>
    d434:	8809883a 	mov	r4,r17
    d438:	000b883a 	mov	r5,zero
    d43c:	a00d883a 	mov	r6,r20
    d440:	000f883a 	mov	r7,zero
    d444:	102d883a 	mov	r22,r2
    d448:	1825883a 	mov	r18,r3
    d44c:	000dd480 	call	dd48 <__muldi3>
    d450:	154b883a 	add	r5,r2,r21
    d454:	2889803a 	cmpltu	r4,r5,r2
    d458:	1c07883a 	add	r3,r3,r16
    d45c:	20c9883a 	add	r4,r4,r3
    d460:	24004b36 	bltu	r4,r16,d590 <__muldf3+0x2b0>
    d464:	8100011e 	bne	r16,r4,d46c <__muldf3+0x18c>
    d468:	2d404936 	bltu	r5,r21,d590 <__muldf3+0x2b0>
    d46c:	0011883a 	mov	r8,zero
    d470:	0007883a 	mov	r3,zero
    d474:	2ccb883a 	add	r5,r5,r19
    d478:	b80d883a 	mov	r6,r23
    d47c:	2cc0012e 	bgeu	r5,r19,d484 <__muldf3+0x1a4>
    d480:	02000044 	movi	r8,1
    d484:	258f883a 	add	r7,r4,r22
    d488:	3909803a 	cmpltu	r4,r7,r4
    d48c:	da400c17 	ldw	r9,48(sp)
    d490:	2489883a 	add	r4,r4,r18
    d494:	d8800717 	ldw	r2,28(sp)
    d498:	20c9883a 	add	r4,r4,r3
    d49c:	da800b17 	ldw	r10,44(sp)
    d4a0:	d8c00617 	ldw	r3,24(sp)
    d4a4:	3a11883a 	add	r8,r7,r8
    d4a8:	4885883a 	add	r2,r9,r2
    d4ac:	50c6c03a 	cmpne	r3,r10,r3
    d4b0:	41cf803a 	cmpltu	r7,r8,r7
    d4b4:	12400104 	addi	r9,r2,4
    d4b8:	d8c00115 	stw	r3,4(sp)
    d4bc:	3909883a 	add	r4,r7,r4
    d4c0:	da400215 	stw	r9,8(sp)
    d4c4:	03480034 	movhi	r13,8192
    d4c8:	6b7fffc4 	addi	r13,r13,-1
    d4cc:	4007883a 	mov	r3,r8
    d4d0:	6900102e 	bgeu	r13,r4,d514 <__muldf3+0x234>
    d4d4:	10800144 	addi	r2,r2,5
    d4d8:	180ed07a 	srli	r7,r3,1
    d4dc:	18c0004c 	andi	r3,r3,1
    d4e0:	201097fa 	slli	r8,r4,31
    d4e4:	281697fa 	slli	r11,r5,31
    d4e8:	2008d07a 	srli	r4,r4,1
    d4ec:	3014d07a 	srli	r10,r6,1
    d4f0:	2812d07a 	srli	r9,r5,1
    d4f4:	1019883a 	mov	r12,r2
    d4f8:	18000226 	beq	r3,zero,d504 <__muldf3+0x224>
    d4fc:	5a8cb03a 	or	r6,r11,r10
    d500:	49600034 	orhi	r5,r9,32768
    d504:	41c6b03a 	or	r3,r8,r7
    d508:	10800044 	addi	r2,r2,1
    d50c:	693ff236 	bltu	r13,r4,d4d8 <__muldf3+0x1f8>
    d510:	db000215 	stw	r12,8(sp)
    d514:	03440034 	movhi	r13,4096
    d518:	6b7fffc4 	addi	r13,r13,-1
    d51c:	69001336 	bltu	r13,r4,d56c <__muldf3+0x28c>
    d520:	d8800217 	ldw	r2,8(sp)
    d524:	10bfffc4 	addi	r2,r2,-1
    d528:	18d3883a 	add	r9,r3,r3
    d52c:	48c7803a 	cmpltu	r3,r9,r3
    d530:	2109883a 	add	r4,r4,r4
    d534:	190f883a 	add	r7,r3,r4
    d538:	3191883a 	add	r8,r6,r6
    d53c:	4197803a 	cmpltu	r11,r8,r6
    d540:	2955883a 	add	r10,r5,r5
    d544:	1019883a 	mov	r12,r2
    d548:	4807883a 	mov	r3,r9
    d54c:	3809883a 	mov	r4,r7
    d550:	2800010e 	bge	r5,zero,d558 <__muldf3+0x278>
    d554:	48c00054 	ori	r3,r9,1
    d558:	400d883a 	mov	r6,r8
    d55c:	5a8b883a 	add	r5,r11,r10
    d560:	10bfffc4 	addi	r2,r2,-1
    d564:	69fff02e 	bgeu	r13,r7,d528 <__muldf3+0x248>
    d568:	db000215 	stw	r12,8(sp)
    d56c:	18803fcc 	andi	r2,r3,255
    d570:	01c02004 	movi	r7,128
    d574:	11c00926 	beq	r2,r7,d59c <__muldf3+0x2bc>
    d578:	008000c4 	movi	r2,3
    d57c:	d9000415 	stw	r4,16(sp)
    d580:	d8c00315 	stw	r3,12(sp)
    d584:	d8800015 	stw	r2,0(sp)
    d588:	d809883a 	mov	r4,sp
    d58c:	003f7006 	br	d350 <__muldf3+0x70>
    d590:	0011883a 	mov	r8,zero
    d594:	00c00044 	movi	r3,1
    d598:	003fb606 	br	d474 <__muldf3+0x194>
    d59c:	19c0400c 	andi	r7,r3,256
    d5a0:	383ff51e 	bne	r7,zero,d578 <__muldf3+0x298>
    d5a4:	314ab03a 	or	r5,r6,r5
    d5a8:	283ff326 	beq	r5,zero,d578 <__muldf3+0x298>
    d5ac:	1885883a 	add	r2,r3,r2
    d5b0:	10cb803a 	cmpltu	r5,r2,r3
    d5b4:	00ffc004 	movi	r3,-256
    d5b8:	10c6703a 	and	r3,r2,r3
    d5bc:	2909883a 	add	r4,r5,r4
    d5c0:	003fed06 	br	d578 <__muldf3+0x298>

0000d5c4 <__divdf3>:
    d5c4:	defff104 	addi	sp,sp,-60
    d5c8:	d9000c15 	stw	r4,48(sp)
    d5cc:	d9400d15 	stw	r5,52(sp)
    d5d0:	d9000c04 	addi	r4,sp,48
    d5d4:	d9400504 	addi	r5,sp,20
    d5d8:	dfc00e15 	stw	ra,56(sp)
    d5dc:	d9800a15 	stw	r6,40(sp)
    d5e0:	d9c00b15 	stw	r7,44(sp)
    d5e4:	000e0780 	call	e078 <__unpack_d>
    d5e8:	d9000a04 	addi	r4,sp,40
    d5ec:	d80b883a 	mov	r5,sp
    d5f0:	000e0780 	call	e078 <__unpack_d>
    d5f4:	d8c00517 	ldw	r3,20(sp)
    d5f8:	00800044 	movi	r2,1
    d5fc:	10c00536 	bltu	r2,r3,d614 <__divdf3+0x50>
    d600:	d9000504 	addi	r4,sp,20
    d604:	000de540 	call	de54 <__pack_d>
    d608:	dfc00e17 	ldw	ra,56(sp)
    d60c:	dec00f04 	addi	sp,sp,60
    d610:	f800283a 	ret
    d614:	d9000017 	ldw	r4,0(sp)
    d618:	11000536 	bltu	r2,r4,d630 <__divdf3+0x6c>
    d61c:	d809883a 	mov	r4,sp
    d620:	000de540 	call	de54 <__pack_d>
    d624:	dfc00e17 	ldw	ra,56(sp)
    d628:	dec00f04 	addi	sp,sp,60
    d62c:	f800283a 	ret
    d630:	d9800617 	ldw	r6,24(sp)
    d634:	d9400117 	ldw	r5,4(sp)
    d638:	00800104 	movi	r2,4
    d63c:	314af03a 	xor	r5,r6,r5
    d640:	d9400615 	stw	r5,24(sp)
    d644:	18800226 	beq	r3,r2,d650 <__divdf3+0x8c>
    d648:	01400084 	movi	r5,2
    d64c:	1940041e 	bne	r3,r5,d660 <__divdf3+0x9c>
    d650:	193feb1e 	bne	r3,r4,d600 <__divdf3+0x3c>
    d654:	01000134 	movhi	r4,4
    d658:	21021f04 	addi	r4,r4,2172
    d65c:	003fe906 	br	d604 <__divdf3+0x40>
    d660:	20803326 	beq	r4,r2,d730 <__divdf3+0x16c>
    d664:	21403726 	beq	r4,r5,d744 <__divdf3+0x180>
    d668:	d8800217 	ldw	r2,8(sp)
    d66c:	d9000717 	ldw	r4,28(sp)
    d670:	d8c00917 	ldw	r3,36(sp)
    d674:	da000417 	ldw	r8,16(sp)
    d678:	2089c83a 	sub	r4,r4,r2
    d67c:	d9000715 	stw	r4,28(sp)
    d680:	d8800817 	ldw	r2,32(sp)
    d684:	dbc00317 	ldw	r15,12(sp)
    d688:	1a000236 	bltu	r3,r8,d694 <__divdf3+0xd0>
    d68c:	40c0081e 	bne	r8,r3,d6b0 <__divdf3+0xec>
    d690:	13c0072e 	bgeu	r2,r15,d6b0 <__divdf3+0xec>
    d694:	108b883a 	add	r5,r2,r2
    d698:	288d803a 	cmpltu	r6,r5,r2
    d69c:	18c7883a 	add	r3,r3,r3
    d6a0:	213fffc4 	addi	r4,r4,-1
    d6a4:	2805883a 	mov	r2,r5
    d6a8:	30c7883a 	add	r3,r6,r3
    d6ac:	d9000715 	stw	r4,28(sp)
    d6b0:	01400f44 	movi	r5,61
    d6b4:	000f883a 	mov	r7,zero
    d6b8:	01040034 	movhi	r4,4096
    d6bc:	0019883a 	mov	r12,zero
    d6c0:	001b883a 	mov	r13,zero
    d6c4:	201697fa 	slli	r11,r4,31
    d6c8:	3814d07a 	srli	r10,r7,1
    d6cc:	297fffc4 	addi	r5,r5,-1
    d6d0:	1a000936 	bltu	r3,r8,d6f8 <__divdf3+0x134>
    d6d4:	13cdc83a 	sub	r6,r2,r15
    d6d8:	1193803a 	cmpltu	r9,r2,r6
    d6dc:	1a1dc83a 	sub	r14,r3,r8
    d6e0:	40c0011e 	bne	r8,r3,d6e8 <__divdf3+0x124>
    d6e4:	13c00436 	bltu	r2,r15,d6f8 <__divdf3+0x134>
    d6e8:	3005883a 	mov	r2,r6
    d6ec:	7247c83a 	sub	r3,r14,r9
    d6f0:	61d8b03a 	or	r12,r12,r7
    d6f4:	691ab03a 	or	r13,r13,r4
    d6f8:	108d883a 	add	r6,r2,r2
    d6fc:	3093803a 	cmpltu	r9,r6,r2
    d700:	18c7883a 	add	r3,r3,r3
    d704:	5a8eb03a 	or	r7,r11,r10
    d708:	2008d07a 	srli	r4,r4,1
    d70c:	3005883a 	mov	r2,r6
    d710:	48c7883a 	add	r3,r9,r3
    d714:	283feb1e 	bne	r5,zero,d6c4 <__divdf3+0x100>
    d718:	61003fcc 	andi	r4,r12,255
    d71c:	01402004 	movi	r5,128
    d720:	21400b26 	beq	r4,r5,d750 <__divdf3+0x18c>
    d724:	db000815 	stw	r12,32(sp)
    d728:	db400915 	stw	r13,36(sp)
    d72c:	003fb406 	br	d600 <__divdf3+0x3c>
    d730:	d8000815 	stw	zero,32(sp)
    d734:	d8000915 	stw	zero,36(sp)
    d738:	d8000715 	stw	zero,28(sp)
    d73c:	d9000504 	addi	r4,sp,20
    d740:	003fb006 	br	d604 <__divdf3+0x40>
    d744:	d8800515 	stw	r2,20(sp)
    d748:	d9000504 	addi	r4,sp,20
    d74c:	003fad06 	br	d604 <__divdf3+0x40>
    d750:	6140400c 	andi	r5,r12,256
    d754:	283ff31e 	bne	r5,zero,d724 <__divdf3+0x160>
    d758:	30c4b03a 	or	r2,r6,r3
    d75c:	103ff126 	beq	r2,zero,d724 <__divdf3+0x160>
    d760:	6109883a 	add	r4,r12,r4
    d764:	2305803a 	cmpltu	r2,r4,r12
    d768:	033fc004 	movi	r12,-256
    d76c:	2318703a 	and	r12,r4,r12
    d770:	135b883a 	add	r13,r2,r13
    d774:	003feb06 	br	d724 <__divdf3+0x160>

0000d778 <__eqdf2>:
    d778:	defff104 	addi	sp,sp,-60
    d77c:	d9000c15 	stw	r4,48(sp)
    d780:	d9400d15 	stw	r5,52(sp)
    d784:	d9000c04 	addi	r4,sp,48
    d788:	d9400504 	addi	r5,sp,20
    d78c:	dfc00e15 	stw	ra,56(sp)
    d790:	d9800a15 	stw	r6,40(sp)
    d794:	d9c00b15 	stw	r7,44(sp)
    d798:	000e0780 	call	e078 <__unpack_d>
    d79c:	d9000a04 	addi	r4,sp,40
    d7a0:	d80b883a 	mov	r5,sp
    d7a4:	000e0780 	call	e078 <__unpack_d>
    d7a8:	d8c00517 	ldw	r3,20(sp)
    d7ac:	00800044 	movi	r2,1
    d7b0:	10c0052e 	bgeu	r2,r3,d7c8 <__eqdf2+0x50>
    d7b4:	d8c00017 	ldw	r3,0(sp)
    d7b8:	10c0032e 	bgeu	r2,r3,d7c8 <__eqdf2+0x50>
    d7bc:	d9000504 	addi	r4,sp,20
    d7c0:	d80b883a 	mov	r5,sp
    d7c4:	000e17c0 	call	e17c <__fpcmp_parts_d>
    d7c8:	dfc00e17 	ldw	ra,56(sp)
    d7cc:	dec00f04 	addi	sp,sp,60
    d7d0:	f800283a 	ret

0000d7d4 <__nedf2>:
    d7d4:	defff104 	addi	sp,sp,-60
    d7d8:	d9000c15 	stw	r4,48(sp)
    d7dc:	d9400d15 	stw	r5,52(sp)
    d7e0:	d9000c04 	addi	r4,sp,48
    d7e4:	d9400504 	addi	r5,sp,20
    d7e8:	dfc00e15 	stw	ra,56(sp)
    d7ec:	d9800a15 	stw	r6,40(sp)
    d7f0:	d9c00b15 	stw	r7,44(sp)
    d7f4:	000e0780 	call	e078 <__unpack_d>
    d7f8:	d9000a04 	addi	r4,sp,40
    d7fc:	d80b883a 	mov	r5,sp
    d800:	000e0780 	call	e078 <__unpack_d>
    d804:	d8c00517 	ldw	r3,20(sp)
    d808:	00800044 	movi	r2,1
    d80c:	10c0052e 	bgeu	r2,r3,d824 <__nedf2+0x50>
    d810:	d8c00017 	ldw	r3,0(sp)
    d814:	10c0032e 	bgeu	r2,r3,d824 <__nedf2+0x50>
    d818:	d9000504 	addi	r4,sp,20
    d81c:	d80b883a 	mov	r5,sp
    d820:	000e17c0 	call	e17c <__fpcmp_parts_d>
    d824:	dfc00e17 	ldw	ra,56(sp)
    d828:	dec00f04 	addi	sp,sp,60
    d82c:	f800283a 	ret

0000d830 <__gtdf2>:
    d830:	defff104 	addi	sp,sp,-60
    d834:	d9000c15 	stw	r4,48(sp)
    d838:	d9400d15 	stw	r5,52(sp)
    d83c:	d9000c04 	addi	r4,sp,48
    d840:	d9400504 	addi	r5,sp,20
    d844:	dfc00e15 	stw	ra,56(sp)
    d848:	d9800a15 	stw	r6,40(sp)
    d84c:	d9c00b15 	stw	r7,44(sp)
    d850:	000e0780 	call	e078 <__unpack_d>
    d854:	d9000a04 	addi	r4,sp,40
    d858:	d80b883a 	mov	r5,sp
    d85c:	000e0780 	call	e078 <__unpack_d>
    d860:	d8c00517 	ldw	r3,20(sp)
    d864:	00800044 	movi	r2,1
    d868:	10c0082e 	bgeu	r2,r3,d88c <__gtdf2+0x5c>
    d86c:	d8c00017 	ldw	r3,0(sp)
    d870:	10c0062e 	bgeu	r2,r3,d88c <__gtdf2+0x5c>
    d874:	d9000504 	addi	r4,sp,20
    d878:	d80b883a 	mov	r5,sp
    d87c:	000e17c0 	call	e17c <__fpcmp_parts_d>
    d880:	dfc00e17 	ldw	ra,56(sp)
    d884:	dec00f04 	addi	sp,sp,60
    d888:	f800283a 	ret
    d88c:	00bfffc4 	movi	r2,-1
    d890:	003ffb06 	br	d880 <__gtdf2+0x50>

0000d894 <__gedf2>:
    d894:	defff104 	addi	sp,sp,-60
    d898:	d9000c15 	stw	r4,48(sp)
    d89c:	d9400d15 	stw	r5,52(sp)
    d8a0:	d9000c04 	addi	r4,sp,48
    d8a4:	d9400504 	addi	r5,sp,20
    d8a8:	dfc00e15 	stw	ra,56(sp)
    d8ac:	d9800a15 	stw	r6,40(sp)
    d8b0:	d9c00b15 	stw	r7,44(sp)
    d8b4:	000e0780 	call	e078 <__unpack_d>
    d8b8:	d9000a04 	addi	r4,sp,40
    d8bc:	d80b883a 	mov	r5,sp
    d8c0:	000e0780 	call	e078 <__unpack_d>
    d8c4:	d8c00517 	ldw	r3,20(sp)
    d8c8:	00800044 	movi	r2,1
    d8cc:	10c0082e 	bgeu	r2,r3,d8f0 <__gedf2+0x5c>
    d8d0:	d8c00017 	ldw	r3,0(sp)
    d8d4:	10c0062e 	bgeu	r2,r3,d8f0 <__gedf2+0x5c>
    d8d8:	d9000504 	addi	r4,sp,20
    d8dc:	d80b883a 	mov	r5,sp
    d8e0:	000e17c0 	call	e17c <__fpcmp_parts_d>
    d8e4:	dfc00e17 	ldw	ra,56(sp)
    d8e8:	dec00f04 	addi	sp,sp,60
    d8ec:	f800283a 	ret
    d8f0:	00bfffc4 	movi	r2,-1
    d8f4:	003ffb06 	br	d8e4 <__gedf2+0x50>

0000d8f8 <__ltdf2>:
    d8f8:	defff104 	addi	sp,sp,-60
    d8fc:	d9000c15 	stw	r4,48(sp)
    d900:	d9400d15 	stw	r5,52(sp)
    d904:	d9000c04 	addi	r4,sp,48
    d908:	d9400504 	addi	r5,sp,20
    d90c:	dfc00e15 	stw	ra,56(sp)
    d910:	d9800a15 	stw	r6,40(sp)
    d914:	d9c00b15 	stw	r7,44(sp)
    d918:	000e0780 	call	e078 <__unpack_d>
    d91c:	d9000a04 	addi	r4,sp,40
    d920:	d80b883a 	mov	r5,sp
    d924:	000e0780 	call	e078 <__unpack_d>
    d928:	d8c00517 	ldw	r3,20(sp)
    d92c:	00800044 	movi	r2,1
    d930:	10c0052e 	bgeu	r2,r3,d948 <__ltdf2+0x50>
    d934:	d8c00017 	ldw	r3,0(sp)
    d938:	10c0032e 	bgeu	r2,r3,d948 <__ltdf2+0x50>
    d93c:	d9000504 	addi	r4,sp,20
    d940:	d80b883a 	mov	r5,sp
    d944:	000e17c0 	call	e17c <__fpcmp_parts_d>
    d948:	dfc00e17 	ldw	ra,56(sp)
    d94c:	dec00f04 	addi	sp,sp,60
    d950:	f800283a 	ret

0000d954 <__floatsidf>:
    d954:	2004d7fa 	srli	r2,r4,31
    d958:	defff904 	addi	sp,sp,-28
    d95c:	00c000c4 	movi	r3,3
    d960:	dfc00615 	stw	ra,24(sp)
    d964:	dc000515 	stw	r16,20(sp)
    d968:	d8c00015 	stw	r3,0(sp)
    d96c:	d8800115 	stw	r2,4(sp)
    d970:	2000081e 	bne	r4,zero,d994 <__floatsidf+0x40>
    d974:	00800084 	movi	r2,2
    d978:	d8800015 	stw	r2,0(sp)
    d97c:	d809883a 	mov	r4,sp
    d980:	000de540 	call	de54 <__pack_d>
    d984:	dfc00617 	ldw	ra,24(sp)
    d988:	dc000517 	ldw	r16,20(sp)
    d98c:	dec00704 	addi	sp,sp,28
    d990:	f800283a 	ret
    d994:	00c00f04 	movi	r3,60
    d998:	d8c00215 	stw	r3,8(sp)
    d99c:	10000f1e 	bne	r2,zero,d9dc <__floatsidf+0x88>
    d9a0:	2021883a 	mov	r16,r4
    d9a4:	8009883a 	mov	r4,r16
    d9a8:	000dda80 	call	dda8 <__clzsi2>
    d9ac:	11000744 	addi	r4,r2,29
    d9b0:	0100110e 	bge	zero,r4,d9f8 <__floatsidf+0xa4>
    d9b4:	10ffff44 	addi	r3,r2,-3
    d9b8:	18001216 	blt	r3,zero,da04 <__floatsidf+0xb0>
    d9bc:	80c6983a 	sll	r3,r16,r3
    d9c0:	0009883a 	mov	r4,zero
    d9c4:	014007c4 	movi	r5,31
    d9c8:	2885c83a 	sub	r2,r5,r2
    d9cc:	d9000315 	stw	r4,12(sp)
    d9d0:	d8c00415 	stw	r3,16(sp)
    d9d4:	d8800215 	stw	r2,8(sp)
    d9d8:	003fe806 	br	d97c <__floatsidf+0x28>
    d9dc:	00a00034 	movhi	r2,32768
    d9e0:	20800e26 	beq	r4,r2,da1c <__floatsidf+0xc8>
    d9e4:	0121c83a 	sub	r16,zero,r4
    d9e8:	8009883a 	mov	r4,r16
    d9ec:	000dda80 	call	dda8 <__clzsi2>
    d9f0:	11000744 	addi	r4,r2,29
    d9f4:	013fef16 	blt	zero,r4,d9b4 <__floatsidf+0x60>
    d9f8:	dc000315 	stw	r16,12(sp)
    d9fc:	d8000415 	stw	zero,16(sp)
    da00:	003fde06 	br	d97c <__floatsidf+0x28>
    da04:	800ad07a 	srli	r5,r16,1
    da08:	00c007c4 	movi	r3,31
    da0c:	1907c83a 	sub	r3,r3,r4
    da10:	28c6d83a 	srl	r3,r5,r3
    da14:	8108983a 	sll	r4,r16,r4
    da18:	003fea06 	br	d9c4 <__floatsidf+0x70>
    da1c:	0005883a 	mov	r2,zero
    da20:	00f07834 	movhi	r3,49632
    da24:	003fd706 	br	d984 <__floatsidf+0x30>

0000da28 <__fixdfsi>:
    da28:	defff804 	addi	sp,sp,-32
    da2c:	d9000515 	stw	r4,20(sp)
    da30:	d9400615 	stw	r5,24(sp)
    da34:	d9000504 	addi	r4,sp,20
    da38:	d80b883a 	mov	r5,sp
    da3c:	dfc00715 	stw	ra,28(sp)
    da40:	000e0780 	call	e078 <__unpack_d>
    da44:	d8800017 	ldw	r2,0(sp)
    da48:	00c00084 	movi	r3,2
    da4c:	10c01c26 	beq	r2,r3,dac0 <__fixdfsi+0x98>
    da50:	00c00044 	movi	r3,1
    da54:	18801a2e 	bgeu	r3,r2,dac0 <__fixdfsi+0x98>
    da58:	00c00104 	movi	r3,4
    da5c:	10c01126 	beq	r2,r3,daa4 <__fixdfsi+0x7c>
    da60:	d8800217 	ldw	r2,8(sp)
    da64:	10001616 	blt	r2,zero,dac0 <__fixdfsi+0x98>
    da68:	00c00784 	movi	r3,30
    da6c:	18800d16 	blt	r3,r2,daa4 <__fixdfsi+0x7c>
    da70:	00c00f04 	movi	r3,60
    da74:	1885c83a 	sub	r2,r3,r2
    da78:	10fff804 	addi	r3,r2,-32
    da7c:	d9400317 	ldw	r5,12(sp)
    da80:	d9000417 	ldw	r4,16(sp)
    da84:	18001616 	blt	r3,zero,dae0 <__fixdfsi+0xb8>
    da88:	20c4d83a 	srl	r2,r4,r3
    da8c:	d8c00117 	ldw	r3,4(sp)
    da90:	18000126 	beq	r3,zero,da98 <__fixdfsi+0x70>
    da94:	0085c83a 	sub	r2,zero,r2
    da98:	dfc00717 	ldw	ra,28(sp)
    da9c:	dec00804 	addi	sp,sp,32
    daa0:	f800283a 	ret
    daa4:	d8800117 	ldw	r2,4(sp)
    daa8:	1000091e 	bne	r2,zero,dad0 <__fixdfsi+0xa8>
    daac:	00a00034 	movhi	r2,32768
    dab0:	10bfffc4 	addi	r2,r2,-1
    dab4:	dfc00717 	ldw	ra,28(sp)
    dab8:	dec00804 	addi	sp,sp,32
    dabc:	f800283a 	ret
    dac0:	0005883a 	mov	r2,zero
    dac4:	dfc00717 	ldw	ra,28(sp)
    dac8:	dec00804 	addi	sp,sp,32
    dacc:	f800283a 	ret
    dad0:	00a00034 	movhi	r2,32768
    dad4:	dfc00717 	ldw	ra,28(sp)
    dad8:	dec00804 	addi	sp,sp,32
    dadc:	f800283a 	ret
    dae0:	2008907a 	slli	r4,r4,1
    dae4:	018007c4 	movi	r6,31
    dae8:	308dc83a 	sub	r6,r6,r2
    daec:	2188983a 	sll	r4,r4,r6
    daf0:	2884d83a 	srl	r2,r5,r2
    daf4:	2084b03a 	or	r2,r4,r2
    daf8:	003fe406 	br	da8c <__fixdfsi+0x64>

0000dafc <__floatunsidf>:
    dafc:	defff904 	addi	sp,sp,-28
    db00:	dc000515 	stw	r16,20(sp)
    db04:	dfc00615 	stw	ra,24(sp)
    db08:	d8000115 	stw	zero,4(sp)
    db0c:	2021883a 	mov	r16,r4
    db10:	20001726 	beq	r4,zero,db70 <__floatunsidf+0x74>
    db14:	008000c4 	movi	r2,3
    db18:	d8800015 	stw	r2,0(sp)
    db1c:	00800f04 	movi	r2,60
    db20:	d8800215 	stw	r2,8(sp)
    db24:	000dda80 	call	dda8 <__clzsi2>
    db28:	10c00744 	addi	r3,r2,29
    db2c:	18001816 	blt	r3,zero,db90 <__floatunsidf+0x94>
    db30:	18002d26 	beq	r3,zero,dbe8 <__floatunsidf+0xec>
    db34:	113fff44 	addi	r4,r2,-3
    db38:	20002e16 	blt	r4,zero,dbf4 <__floatunsidf+0xf8>
    db3c:	8108983a 	sll	r4,r16,r4
    db40:	0021883a 	mov	r16,zero
    db44:	014007c4 	movi	r5,31
    db48:	2885c83a 	sub	r2,r5,r2
    db4c:	dc000315 	stw	r16,12(sp)
    db50:	d9000415 	stw	r4,16(sp)
    db54:	d8800215 	stw	r2,8(sp)
    db58:	d809883a 	mov	r4,sp
    db5c:	000de540 	call	de54 <__pack_d>
    db60:	dfc00617 	ldw	ra,24(sp)
    db64:	dc000517 	ldw	r16,20(sp)
    db68:	dec00704 	addi	sp,sp,28
    db6c:	f800283a 	ret
    db70:	00800084 	movi	r2,2
    db74:	d809883a 	mov	r4,sp
    db78:	d8800015 	stw	r2,0(sp)
    db7c:	000de540 	call	de54 <__pack_d>
    db80:	dfc00617 	ldw	ra,24(sp)
    db84:	dc000517 	ldw	r16,20(sp)
    db88:	dec00704 	addi	sp,sp,28
    db8c:	f800283a 	ret
    db90:	00c7c83a 	sub	r3,zero,r3
    db94:	193ff804 	addi	r4,r3,-32
    db98:	20001c16 	blt	r4,zero,dc0c <__floatunsidf+0x110>
    db9c:	000b883a 	mov	r5,zero
    dba0:	2009d7fa 	srai	r4,r4,31
    dba4:	80c6d83a 	srl	r3,r16,r3
    dba8:	297fffc4 	addi	r5,r5,-1
    dbac:	2c20703a 	and	r16,r5,r16
    dbb0:	8020c03a 	cmpne	r16,r16,zero
    dbb4:	1906703a 	and	r3,r3,r4
    dbb8:	010007c4 	movi	r4,31
    dbbc:	80c6b03a 	or	r3,r16,r3
    dbc0:	2085c83a 	sub	r2,r4,r2
    dbc4:	d809883a 	mov	r4,sp
    dbc8:	d8c00315 	stw	r3,12(sp)
    dbcc:	d8000415 	stw	zero,16(sp)
    dbd0:	d8800215 	stw	r2,8(sp)
    dbd4:	000de540 	call	de54 <__pack_d>
    dbd8:	dfc00617 	ldw	ra,24(sp)
    dbdc:	dc000517 	ldw	r16,20(sp)
    dbe0:	dec00704 	addi	sp,sp,28
    dbe4:	f800283a 	ret
    dbe8:	dc000315 	stw	r16,12(sp)
    dbec:	d8000415 	stw	zero,16(sp)
    dbf0:	003fd906 	br	db58 <__floatunsidf+0x5c>
    dbf4:	800ad07a 	srli	r5,r16,1
    dbf8:	010007c4 	movi	r4,31
    dbfc:	20c9c83a 	sub	r4,r4,r3
    dc00:	2908d83a 	srl	r4,r5,r4
    dc04:	80e0983a 	sll	r16,r16,r3
    dc08:	003fce06 	br	db44 <__floatunsidf+0x48>
    dc0c:	01400044 	movi	r5,1
    dc10:	28ca983a 	sll	r5,r5,r3
    dc14:	003fe206 	br	dba0 <__floatunsidf+0xa4>

0000dc18 <udivmodsi4>:
    dc18:	2005883a 	mov	r2,r4
    dc1c:	2900182e 	bgeu	r5,r4,dc80 <udivmodsi4+0x68>
    dc20:	28001716 	blt	r5,zero,dc80 <udivmodsi4+0x68>
    dc24:	01000804 	movi	r4,32
    dc28:	00c00044 	movi	r3,1
    dc2c:	00000206 	br	dc38 <udivmodsi4+0x20>
    dc30:	20001126 	beq	r4,zero,dc78 <udivmodsi4+0x60>
    dc34:	28000516 	blt	r5,zero,dc4c <udivmodsi4+0x34>
    dc38:	294b883a 	add	r5,r5,r5
    dc3c:	213fffc4 	addi	r4,r4,-1
    dc40:	18c7883a 	add	r3,r3,r3
    dc44:	28bffa36 	bltu	r5,r2,dc30 <udivmodsi4+0x18>
    dc48:	18000b26 	beq	r3,zero,dc78 <udivmodsi4+0x60>
    dc4c:	0009883a 	mov	r4,zero
    dc50:	11400236 	bltu	r2,r5,dc5c <udivmodsi4+0x44>
    dc54:	1145c83a 	sub	r2,r2,r5
    dc58:	20c8b03a 	or	r4,r4,r3
    dc5c:	1806d07a 	srli	r3,r3,1
    dc60:	280ad07a 	srli	r5,r5,1
    dc64:	183ffa1e 	bne	r3,zero,dc50 <udivmodsi4+0x38>
    dc68:	3000021e 	bne	r6,zero,dc74 <udivmodsi4+0x5c>
    dc6c:	2005883a 	mov	r2,r4
    dc70:	f800283a 	ret
    dc74:	f800283a 	ret
    dc78:	0009883a 	mov	r4,zero
    dc7c:	003ffa06 	br	dc68 <udivmodsi4+0x50>
    dc80:	00c00044 	movi	r3,1
    dc84:	0009883a 	mov	r4,zero
    dc88:	003ff106 	br	dc50 <udivmodsi4+0x38>

0000dc8c <__divsi3>:
    dc8c:	defffe04 	addi	sp,sp,-8
    dc90:	dfc00115 	stw	ra,4(sp)
    dc94:	dc000015 	stw	r16,0(sp)
    dc98:	20000a16 	blt	r4,zero,dcc4 <__divsi3+0x38>
    dc9c:	0021883a 	mov	r16,zero
    dca0:	28000b16 	blt	r5,zero,dcd0 <__divsi3+0x44>
    dca4:	000d883a 	mov	r6,zero
    dca8:	000dc180 	call	dc18 <udivmodsi4>
    dcac:	80000126 	beq	r16,zero,dcb4 <__divsi3+0x28>
    dcb0:	0085c83a 	sub	r2,zero,r2
    dcb4:	dfc00117 	ldw	ra,4(sp)
    dcb8:	dc000017 	ldw	r16,0(sp)
    dcbc:	dec00204 	addi	sp,sp,8
    dcc0:	f800283a 	ret
    dcc4:	0109c83a 	sub	r4,zero,r4
    dcc8:	04000044 	movi	r16,1
    dccc:	283ff50e 	bge	r5,zero,dca4 <__divsi3+0x18>
    dcd0:	014bc83a 	sub	r5,zero,r5
    dcd4:	8400005c 	xori	r16,r16,1
    dcd8:	003ff206 	br	dca4 <__divsi3+0x18>

0000dcdc <__modsi3>:
    dcdc:	deffff04 	addi	sp,sp,-4
    dce0:	dfc00015 	stw	ra,0(sp)
    dce4:	20000516 	blt	r4,zero,dcfc <__modsi3+0x20>
    dce8:	28000c16 	blt	r5,zero,dd1c <__modsi3+0x40>
    dcec:	01800044 	movi	r6,1
    dcf0:	dfc00017 	ldw	ra,0(sp)
    dcf4:	dec00104 	addi	sp,sp,4
    dcf8:	000dc181 	jmpi	dc18 <udivmodsi4>
    dcfc:	0109c83a 	sub	r4,zero,r4
    dd00:	28000b16 	blt	r5,zero,dd30 <__modsi3+0x54>
    dd04:	01800044 	movi	r6,1
    dd08:	000dc180 	call	dc18 <udivmodsi4>
    dd0c:	0085c83a 	sub	r2,zero,r2
    dd10:	dfc00017 	ldw	ra,0(sp)
    dd14:	dec00104 	addi	sp,sp,4
    dd18:	f800283a 	ret
    dd1c:	014bc83a 	sub	r5,zero,r5
    dd20:	01800044 	movi	r6,1
    dd24:	dfc00017 	ldw	ra,0(sp)
    dd28:	dec00104 	addi	sp,sp,4
    dd2c:	000dc181 	jmpi	dc18 <udivmodsi4>
    dd30:	014bc83a 	sub	r5,zero,r5
    dd34:	003ff306 	br	dd04 <__modsi3+0x28>

0000dd38 <__udivsi3>:
    dd38:	000d883a 	mov	r6,zero
    dd3c:	000dc181 	jmpi	dc18 <udivmodsi4>

0000dd40 <__umodsi3>:
    dd40:	01800044 	movi	r6,1
    dd44:	000dc181 	jmpi	dc18 <udivmodsi4>

0000dd48 <__muldi3>:
    dd48:	20bfffcc 	andi	r2,r4,65535
    dd4c:	2010d43a 	srli	r8,r4,16
    dd50:	30ffffcc 	andi	r3,r6,65535
    dd54:	3014d43a 	srli	r10,r6,16
    dd58:	1893383a 	mul	r9,r3,r2
    dd5c:	1a07383a 	mul	r3,r3,r8
    dd60:	5085383a 	mul	r2,r10,r2
    dd64:	4816d43a 	srli	r11,r9,16
    dd68:	5211383a 	mul	r8,r10,r8
    dd6c:	1885883a 	add	r2,r3,r2
    dd70:	12c5883a 	add	r2,r2,r11
    dd74:	10c0022e 	bgeu	r2,r3,dd80 <__muldi3+0x38>
    dd78:	00c00074 	movhi	r3,1
    dd7c:	40d1883a 	add	r8,r8,r3
    dd80:	1014d43a 	srli	r10,r2,16
    dd84:	21c9383a 	mul	r4,r4,r7
    dd88:	314d383a 	mul	r6,r6,r5
    dd8c:	1004943a 	slli	r2,r2,16
    dd90:	4291883a 	add	r8,r8,r10
    dd94:	4a7fffcc 	andi	r9,r9,65535
    dd98:	2187883a 	add	r3,r4,r6
    dd9c:	1245883a 	add	r2,r2,r9
    dda0:	1a07883a 	add	r3,r3,r8
    dda4:	f800283a 	ret

0000dda8 <__clzsi2>:
    dda8:	00bfffd4 	movui	r2,65535
    ddac:	11000b36 	bltu	r2,r4,dddc <__clzsi2+0x34>
    ddb0:	00803fc4 	movi	r2,255
    ddb4:	11001e2e 	bgeu	r2,r4,de30 <__clzsi2+0x88>
    ddb8:	00c00204 	movi	r3,8
    ddbc:	20c8d83a 	srl	r4,r4,r3
    ddc0:	00c00134 	movhi	r3,4
    ddc4:	18c22404 	addi	r3,r3,2192
    ddc8:	00800604 	movi	r2,24
    ddcc:	1909883a 	add	r4,r3,r4
    ddd0:	20c00003 	ldbu	r3,0(r4)
    ddd4:	10c5c83a 	sub	r2,r2,r3
    ddd8:	f800283a 	ret
    dddc:	00804034 	movhi	r2,256
    dde0:	10bfffc4 	addi	r2,r2,-1
    dde4:	11000936 	bltu	r2,r4,de0c <__clzsi2+0x64>
    dde8:	00800404 	movi	r2,16
    ddec:	1007883a 	mov	r3,r2
    ddf0:	20c8d83a 	srl	r4,r4,r3
    ddf4:	00c00134 	movhi	r3,4
    ddf8:	18c22404 	addi	r3,r3,2192
    ddfc:	1909883a 	add	r4,r3,r4
    de00:	20c00003 	ldbu	r3,0(r4)
    de04:	10c5c83a 	sub	r2,r2,r3
    de08:	f800283a 	ret
    de0c:	00c00604 	movi	r3,24
    de10:	20c8d83a 	srl	r4,r4,r3
    de14:	00c00134 	movhi	r3,4
    de18:	18c22404 	addi	r3,r3,2192
    de1c:	00800204 	movi	r2,8
    de20:	1909883a 	add	r4,r3,r4
    de24:	20c00003 	ldbu	r3,0(r4)
    de28:	10c5c83a 	sub	r2,r2,r3
    de2c:	f800283a 	ret
    de30:	0007883a 	mov	r3,zero
    de34:	20c8d83a 	srl	r4,r4,r3
    de38:	00c00134 	movhi	r3,4
    de3c:	18c22404 	addi	r3,r3,2192
    de40:	00800804 	movi	r2,32
    de44:	1909883a 	add	r4,r3,r4
    de48:	20c00003 	ldbu	r3,0(r4)
    de4c:	10c5c83a 	sub	r2,r2,r3
    de50:	f800283a 	ret

0000de54 <__pack_d>:
    de54:	20800017 	ldw	r2,0(r4)
    de58:	defff804 	addi	sp,sp,-32
    de5c:	dcc00315 	stw	r19,12(sp)
    de60:	dc800215 	stw	r18,8(sp)
    de64:	dfc00715 	stw	ra,28(sp)
    de68:	dd800615 	stw	r22,24(sp)
    de6c:	dd400515 	stw	r21,20(sp)
    de70:	dd000415 	stw	r20,16(sp)
    de74:	dc400115 	stw	r17,4(sp)
    de78:	dc000015 	stw	r16,0(sp)
    de7c:	04800044 	movi	r18,1
    de80:	24400317 	ldw	r17,12(r4)
    de84:	24000417 	ldw	r16,16(r4)
    de88:	24c00117 	ldw	r19,4(r4)
    de8c:	9080422e 	bgeu	r18,r2,df98 <__pack_d+0x144>
    de90:	00c00104 	movi	r3,4
    de94:	10c03c26 	beq	r2,r3,df88 <__pack_d+0x134>
    de98:	00c00084 	movi	r3,2
    de9c:	10c01926 	beq	r2,r3,df04 <__pack_d+0xb0>
    dea0:	8c04b03a 	or	r2,r17,r16
    dea4:	10001726 	beq	r2,zero,df04 <__pack_d+0xb0>
    dea8:	21000217 	ldw	r4,8(r4)
    deac:	00bf0084 	movi	r2,-1022
    deb0:	20804016 	blt	r4,r2,dfb4 <__pack_d+0x160>
    deb4:	0080ffc4 	movi	r2,1023
    deb8:	11003316 	blt	r2,r4,df88 <__pack_d+0x134>
    debc:	88803fcc 	andi	r2,r17,255
    dec0:	00c02004 	movi	r3,128
    dec4:	10c02926 	beq	r2,r3,df6c <__pack_d+0x118>
    dec8:	88801fc4 	addi	r2,r17,127
    decc:	1463803a 	cmpltu	r17,r2,r17
    ded0:	8c21883a 	add	r16,r17,r16
    ded4:	1023883a 	mov	r17,r2
    ded8:	00880034 	movhi	r2,8192
    dedc:	10bfffc4 	addi	r2,r2,-1
    dee0:	14001c36 	bltu	r2,r16,df54 <__pack_d+0x100>
    dee4:	2100ffc4 	addi	r4,r4,1023
    dee8:	8006963a 	slli	r3,r16,24
    deec:	8804d23a 	srli	r2,r17,8
    def0:	8020913a 	slli	r16,r16,4
    def4:	2101ffcc 	andi	r4,r4,2047
    def8:	1884b03a 	or	r2,r3,r2
    defc:	8020d33a 	srli	r16,r16,12
    df00:	00000306 	br	df10 <__pack_d+0xbc>
    df04:	0009883a 	mov	r4,zero
    df08:	0005883a 	mov	r2,zero
    df0c:	0021883a 	mov	r16,zero
    df10:	2008953a 	slli	r4,r4,20
    df14:	982697fa 	slli	r19,r19,31
    df18:	00c00434 	movhi	r3,16
    df1c:	18ffffc4 	addi	r3,r3,-1
    df20:	80e0703a 	and	r16,r16,r3
    df24:	8106b03a 	or	r3,r16,r4
    df28:	1cc6b03a 	or	r3,r3,r19
    df2c:	dfc00717 	ldw	ra,28(sp)
    df30:	dd800617 	ldw	r22,24(sp)
    df34:	dd400517 	ldw	r21,20(sp)
    df38:	dd000417 	ldw	r20,16(sp)
    df3c:	dcc00317 	ldw	r19,12(sp)
    df40:	dc800217 	ldw	r18,8(sp)
    df44:	dc400117 	ldw	r17,4(sp)
    df48:	dc000017 	ldw	r16,0(sp)
    df4c:	dec00804 	addi	sp,sp,32
    df50:	f800283a 	ret
    df54:	800697fa 	slli	r3,r16,31
    df58:	8804d07a 	srli	r2,r17,1
    df5c:	21010004 	addi	r4,r4,1024
    df60:	8020d07a 	srli	r16,r16,1
    df64:	18a2b03a 	or	r17,r3,r2
    df68:	003fdf06 	br	dee8 <__pack_d+0x94>
    df6c:	88c0400c 	andi	r3,r17,256
    df70:	183fd926 	beq	r3,zero,ded8 <__pack_d+0x84>
    df74:	8885883a 	add	r2,r17,r2
    df78:	1463803a 	cmpltu	r17,r2,r17
    df7c:	8c21883a 	add	r16,r17,r16
    df80:	1023883a 	mov	r17,r2
    df84:	003fd406 	br	ded8 <__pack_d+0x84>
    df88:	0101ffc4 	movi	r4,2047
    df8c:	0005883a 	mov	r2,zero
    df90:	0021883a 	mov	r16,zero
    df94:	003fde06 	br	df10 <__pack_d+0xbc>
    df98:	84000234 	orhi	r16,r16,8
    df9c:	00c00434 	movhi	r3,16
    dfa0:	18ffffc4 	addi	r3,r3,-1
    dfa4:	8805883a 	mov	r2,r17
    dfa8:	80e0703a 	and	r16,r16,r3
    dfac:	0101ffc4 	movi	r4,2047
    dfb0:	003fd706 	br	df10 <__pack_d+0xbc>
    dfb4:	1129c83a 	sub	r20,r2,r4
    dfb8:	00800e04 	movi	r2,56
    dfbc:	15002716 	blt	r2,r20,e05c <__pack_d+0x208>
    dfc0:	800b883a 	mov	r5,r16
    dfc4:	a00d883a 	mov	r6,r20
    dfc8:	8809883a 	mov	r4,r17
    dfcc:	000e24c0 	call	e24c <__lshrdi3>
    dfd0:	9009883a 	mov	r4,r18
    dfd4:	000b883a 	mov	r5,zero
    dfd8:	a00d883a 	mov	r6,r20
    dfdc:	102d883a 	mov	r22,r2
    dfe0:	182b883a 	mov	r21,r3
    dfe4:	000e2900 	call	e290 <__ashldi3>
    dfe8:	1009003a 	cmpeq	r4,r2,zero
    dfec:	1907c83a 	sub	r3,r3,r4
    dff0:	10bfffc4 	addi	r2,r2,-1
    dff4:	1c20703a 	and	r16,r3,r16
    dff8:	1444703a 	and	r2,r2,r17
    dffc:	1404b03a 	or	r2,r2,r16
    e000:	1004c03a 	cmpne	r2,r2,zero
    e004:	1584b03a 	or	r2,r2,r22
    e008:	11003fcc 	andi	r4,r2,255
    e00c:	01402004 	movi	r5,128
    e010:	a807883a 	mov	r3,r21
    e014:	2140131e 	bne	r4,r5,e064 <__pack_d+0x210>
    e018:	1140400c 	andi	r5,r2,256
    e01c:	28000426 	beq	r5,zero,e030 <__pack_d+0x1dc>
    e020:	1109883a 	add	r4,r2,r4
    e024:	2085803a 	cmpltu	r2,r4,r2
    e028:	1547883a 	add	r3,r2,r21
    e02c:	2005883a 	mov	r2,r4
    e030:	1808963a 	slli	r4,r3,24
    e034:	1004d23a 	srli	r2,r2,8
    e038:	1820913a 	slli	r16,r3,4
    e03c:	01440034 	movhi	r5,4096
    e040:	297fffc4 	addi	r5,r5,-1
    e044:	2084b03a 	or	r2,r4,r2
    e048:	8020d33a 	srli	r16,r16,12
    e04c:	01000044 	movi	r4,1
    e050:	28ffaf36 	bltu	r5,r3,df10 <__pack_d+0xbc>
    e054:	0009883a 	mov	r4,zero
    e058:	003fad06 	br	df10 <__pack_d+0xbc>
    e05c:	0005883a 	mov	r2,zero
    e060:	0007883a 	mov	r3,zero
    e064:	11001fc4 	addi	r4,r2,127
    e068:	2085803a 	cmpltu	r2,r4,r2
    e06c:	10c7883a 	add	r3,r2,r3
    e070:	2005883a 	mov	r2,r4
    e074:	003fee06 	br	e030 <__pack_d+0x1dc>

0000e078 <__unpack_d>:
    e078:	21800117 	ldw	r6,4(r4)
    e07c:	20c00017 	ldw	r3,0(r4)
    e080:	3004d7fa 	srli	r2,r6,31
    e084:	3008d53a 	srli	r4,r6,20
    e088:	28800115 	stw	r2,4(r5)
    e08c:	2101ffcc 	andi	r4,r4,2047
    e090:	00800434 	movhi	r2,16
    e094:	10bfffc4 	addi	r2,r2,-1
    e098:	3084703a 	and	r2,r6,r2
    e09c:	20001a1e 	bne	r4,zero,e108 <__unpack_d+0x90>
    e0a0:	1888b03a 	or	r4,r3,r2
    e0a4:	20002626 	beq	r4,zero,e140 <__unpack_d+0xc8>
    e0a8:	1808d63a 	srli	r4,r3,24
    e0ac:	1004923a 	slli	r2,r2,8
    e0b0:	01bf0084 	movi	r6,-1022
    e0b4:	29800215 	stw	r6,8(r5)
    e0b8:	2084b03a 	or	r2,r4,r2
    e0bc:	010000c4 	movi	r4,3
    e0c0:	29000015 	stw	r4,0(r5)
    e0c4:	02040034 	movhi	r8,4096
    e0c8:	423fffc4 	addi	r8,r8,-1
    e0cc:	1806923a 	slli	r3,r3,8
    e0d0:	40801836 	bltu	r8,r2,e134 <__unpack_d+0xbc>
    e0d4:	013f0044 	movi	r4,-1023
    e0d8:	18cd883a 	add	r6,r3,r3
    e0dc:	30c7803a 	cmpltu	r3,r6,r3
    e0e0:	1085883a 	add	r2,r2,r2
    e0e4:	1885883a 	add	r2,r3,r2
    e0e8:	200f883a 	mov	r7,r4
    e0ec:	3007883a 	mov	r3,r6
    e0f0:	213fffc4 	addi	r4,r4,-1
    e0f4:	40bff82e 	bgeu	r8,r2,e0d8 <__unpack_d+0x60>
    e0f8:	29c00215 	stw	r7,8(r5)
    e0fc:	28c00315 	stw	r3,12(r5)
    e100:	28800415 	stw	r2,16(r5)
    e104:	f800283a 	ret
    e108:	01c1ffc4 	movi	r7,2047
    e10c:	21c00f26 	beq	r4,r7,e14c <__unpack_d+0xd4>
    e110:	180cd63a 	srli	r6,r3,24
    e114:	1004923a 	slli	r2,r2,8
    e118:	213f0044 	addi	r4,r4,-1023
    e11c:	1806923a 	slli	r3,r3,8
    e120:	3084b03a 	or	r2,r6,r2
    e124:	29000215 	stw	r4,8(r5)
    e128:	010000c4 	movi	r4,3
    e12c:	10840034 	orhi	r2,r2,4096
    e130:	29000015 	stw	r4,0(r5)
    e134:	28c00315 	stw	r3,12(r5)
    e138:	28800415 	stw	r2,16(r5)
    e13c:	f800283a 	ret
    e140:	00800084 	movi	r2,2
    e144:	28800015 	stw	r2,0(r5)
    e148:	f800283a 	ret
    e14c:	1888b03a 	or	r4,r3,r2
    e150:	20000526 	beq	r4,zero,e168 <__unpack_d+0xf0>
    e154:	3180022c 	andhi	r6,r6,8
    e158:	30000626 	beq	r6,zero,e174 <__unpack_d+0xfc>
    e15c:	01000044 	movi	r4,1
    e160:	29000015 	stw	r4,0(r5)
    e164:	003ff306 	br	e134 <__unpack_d+0xbc>
    e168:	00800104 	movi	r2,4
    e16c:	28800015 	stw	r2,0(r5)
    e170:	f800283a 	ret
    e174:	28000015 	stw	zero,0(r5)
    e178:	003fee06 	br	e134 <__unpack_d+0xbc>

0000e17c <__fpcmp_parts_d>:
    e17c:	20c00017 	ldw	r3,0(r4)
    e180:	00800044 	movi	r2,1
    e184:	10c0142e 	bgeu	r2,r3,e1d8 <__fpcmp_parts_d+0x5c>
    e188:	29800017 	ldw	r6,0(r5)
    e18c:	1180122e 	bgeu	r2,r6,e1d8 <__fpcmp_parts_d+0x5c>
    e190:	01c00104 	movi	r7,4
    e194:	19c02826 	beq	r3,r7,e238 <__fpcmp_parts_d+0xbc>
    e198:	31c00926 	beq	r6,r7,e1c0 <__fpcmp_parts_d+0x44>
    e19c:	01c00084 	movi	r7,2
    e1a0:	19c00626 	beq	r3,r7,e1bc <__fpcmp_parts_d+0x40>
    e1a4:	31c00a26 	beq	r6,r7,e1d0 <__fpcmp_parts_d+0x54>
    e1a8:	20c00117 	ldw	r3,4(r4)
    e1ac:	29800117 	ldw	r6,4(r5)
    e1b0:	19800b26 	beq	r3,r6,e1e0 <__fpcmp_parts_d+0x64>
    e1b4:	1800041e 	bne	r3,zero,e1c8 <__fpcmp_parts_d+0x4c>
    e1b8:	f800283a 	ret
    e1bc:	30c01a26 	beq	r6,r3,e228 <__fpcmp_parts_d+0xac>
    e1c0:	28800117 	ldw	r2,4(r5)
    e1c4:	1000041e 	bne	r2,zero,e1d8 <__fpcmp_parts_d+0x5c>
    e1c8:	00bfffc4 	movi	r2,-1
    e1cc:	f800283a 	ret
    e1d0:	20800117 	ldw	r2,4(r4)
    e1d4:	103ffc1e 	bne	r2,zero,e1c8 <__fpcmp_parts_d+0x4c>
    e1d8:	00800044 	movi	r2,1
    e1dc:	f800283a 	ret
    e1e0:	21c00217 	ldw	r7,8(r4)
    e1e4:	29800217 	ldw	r6,8(r5)
    e1e8:	31c0020e 	bge	r6,r7,e1f4 <__fpcmp_parts_d+0x78>
    e1ec:	183ff61e 	bne	r3,zero,e1c8 <__fpcmp_parts_d+0x4c>
    e1f0:	f800283a 	ret
    e1f4:	39800a16 	blt	r7,r6,e220 <__fpcmp_parts_d+0xa4>
    e1f8:	20800417 	ldw	r2,16(r4)
    e1fc:	29800417 	ldw	r6,16(r5)
    e200:	21c00317 	ldw	r7,12(r4)
    e204:	29000317 	ldw	r4,12(r5)
    e208:	30800936 	bltu	r6,r2,e230 <__fpcmp_parts_d+0xb4>
    e20c:	1180011e 	bne	r2,r6,e214 <__fpcmp_parts_d+0x98>
    e210:	21c00736 	bltu	r4,r7,e230 <__fpcmp_parts_d+0xb4>
    e214:	11800236 	bltu	r2,r6,e220 <__fpcmp_parts_d+0xa4>
    e218:	3080031e 	bne	r6,r2,e228 <__fpcmp_parts_d+0xac>
    e21c:	3900022e 	bgeu	r7,r4,e228 <__fpcmp_parts_d+0xac>
    e220:	183fe926 	beq	r3,zero,e1c8 <__fpcmp_parts_d+0x4c>
    e224:	003fec06 	br	e1d8 <__fpcmp_parts_d+0x5c>
    e228:	0005883a 	mov	r2,zero
    e22c:	f800283a 	ret
    e230:	183fe926 	beq	r3,zero,e1d8 <__fpcmp_parts_d+0x5c>
    e234:	003fe406 	br	e1c8 <__fpcmp_parts_d+0x4c>
    e238:	30ffe51e 	bne	r6,r3,e1d0 <__fpcmp_parts_d+0x54>
    e23c:	28c00117 	ldw	r3,4(r5)
    e240:	20800117 	ldw	r2,4(r4)
    e244:	1885c83a 	sub	r2,r3,r2
    e248:	f800283a 	ret

0000e24c <__lshrdi3>:
    e24c:	2005883a 	mov	r2,r4
    e250:	2807883a 	mov	r3,r5
    e254:	30000826 	beq	r6,zero,e278 <__lshrdi3+0x2c>
    e258:	01000804 	movi	r4,32
    e25c:	2189c83a 	sub	r4,r4,r6
    e260:	0100060e 	bge	zero,r4,e27c <__lshrdi3+0x30>
    e264:	1184d83a 	srl	r2,r2,r6
    e268:	2908983a 	sll	r4,r5,r4
    e26c:	298cd83a 	srl	r6,r5,r6
    e270:	2084b03a 	or	r2,r4,r2
    e274:	3007883a 	mov	r3,r6
    e278:	f800283a 	ret
    e27c:	0105c83a 	sub	r2,zero,r4
    e280:	000d883a 	mov	r6,zero
    e284:	2884d83a 	srl	r2,r5,r2
    e288:	3007883a 	mov	r3,r6
    e28c:	003ffa06 	br	e278 <__lshrdi3+0x2c>

0000e290 <__ashldi3>:
    e290:	2005883a 	mov	r2,r4
    e294:	2807883a 	mov	r3,r5
    e298:	30000826 	beq	r6,zero,e2bc <__ashldi3+0x2c>
    e29c:	01000804 	movi	r4,32
    e2a0:	2189c83a 	sub	r4,r4,r6
    e2a4:	0100060e 	bge	zero,r4,e2c0 <__ashldi3+0x30>
    e2a8:	1108d83a 	srl	r4,r2,r4
    e2ac:	2986983a 	sll	r3,r5,r6
    e2b0:	118c983a 	sll	r6,r2,r6
    e2b4:	20c6b03a 	or	r3,r4,r3
    e2b8:	3005883a 	mov	r2,r6
    e2bc:	f800283a 	ret
    e2c0:	0107c83a 	sub	r3,zero,r4
    e2c4:	000d883a 	mov	r6,zero
    e2c8:	10c6983a 	sll	r3,r2,r3
    e2cc:	3005883a 	mov	r2,r6
    e2d0:	003ffa06 	br	e2bc <__ashldi3+0x2c>

0000e2d4 <pre_constructors>:
/*
 * We want this pre_constructors and post_constructors functions to be called when it is defined by the user, if the user didn't define it
 * we don't want a link error, just call this empty function
 */
void __attribute__((weak)) pre_constructors()
{
    e2d4:	deffff04 	addi	sp,sp,-4
    e2d8:	df000015 	stw	fp,0(sp)
    e2dc:	d839883a 	mov	fp,sp
	// nothing to do here... may be overloaded by the application
}
    e2e0:	e037883a 	mov	sp,fp
    e2e4:	df000017 	ldw	fp,0(sp)
    e2e8:	dec00104 	addi	sp,sp,4
    e2ec:	f800283a 	ret

0000e2f0 <post_constructors>:

void __attribute__((weak)) post_constructors()
{
    e2f0:	deffff04 	addi	sp,sp,-4
    e2f4:	df000015 	stw	fp,0(sp)
    e2f8:	d839883a 	mov	fp,sp
	// nothing to do here... may be overloaded by the application
}
    e2fc:	e037883a 	mov	sp,fp
    e300:	df000017 	ldw	fp,0(sp)
    e304:	dec00104 	addi	sp,sp,4
    e308:	f800283a 	ret

0000e30c <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
    e30c:	defffb04 	addi	sp,sp,-20
    e310:	dfc00415 	stw	ra,16(sp)
    e314:	df000315 	stw	fp,12(sp)
    e318:	df000304 	addi	fp,sp,12
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
    e31c:	0009883a 	mov	r4,zero
    e320:	00317900 	call	31790 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
    e324:	01000104 	movi	r4,4
    e328:	000e7040 	call	e704 <xQueueCreateMutex>
    e32c:	00c00134 	movhi	r3,4
    e330:	18dec204 	addi	r3,r3,31496
    e334:	18800015 	stw	r2,0(r3)
    e338:	01000104 	movi	r4,4
    e33c:	000e7040 	call	e704 <xQueueCreateMutex>
    e340:	00c00134 	movhi	r3,4
    e344:	18df0504 	addi	r3,r3,31764
    e348:	18800015 	stw	r2,0(r3)
    e34c:	00800134 	movhi	r2,4
    e350:	109ed504 	addi	r2,r2,31572
    e354:	e0bffe15 	stw	r2,-8(fp)
    e358:	00800044 	movi	r2,1
    e35c:	e0bfff0d 	sth	r2,-4(fp)
 * alt_sem_create() is a wrapper for xSemaphoreCreateCounting(). The return value is 0 if 
 * the semaphore has been successfully created, or non-zero otherwise.
 */
static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (xSemaphoreHandle* sem, alt_u16 value)
{
	*sem = xSemaphoreCreateCounting(value ? value : 1, value);
    e360:	e0bfff0b 	ldhu	r2,-4(fp)
    e364:	10000226 	beq	r2,zero,e370 <alt_main+0x64>
    e368:	e0bfff0b 	ldhu	r2,-4(fp)
    e36c:	00000106 	br	e374 <alt_main+0x68>
    e370:	00800044 	movi	r2,1
    e374:	e0ffff0b 	ldhu	r3,-4(fp)
    e378:	1009883a 	mov	r4,r2
    e37c:	180b883a 	mov	r5,r3
    e380:	000e9040 	call	e904 <xQueueCreateCountingSemaphore>
    e384:	e0fffe17 	ldw	r3,-8(fp)
    e388:	18800015 	stw	r2,0(r3)
	return *sem ? 0 : -1;
    e38c:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
    e390:	00317d00 	call	317d0 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
    e394:	01000134 	movhi	r4,4
    e398:	21026404 	addi	r4,r4,2448
    e39c:	01400134 	movhi	r5,4
    e3a0:	29426404 	addi	r5,r5,2448
    e3a4:	01800134 	movhi	r6,4
    e3a8:	31826404 	addi	r6,r6,2448
    e3ac:	0011ce40 	call	11ce4 <alt_io_redirect>
#endif

  /*
   * Call the pre_constructors function
   */
  pre_constructors();
    e3b0:	000e2d40 	call	e2d4 <pre_constructors>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
    e3b4:	0011a700 	call	11a70 <_do_ctors>
#endif /* ALT_NO_C_PLUS_PLUS */

  /*
   * Call the post_constructors function
   */
  post_constructors();
    e3b8:	000e2f00 	call	e2f0 <post_constructors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
    e3bc:	01000074 	movhi	r4,1
    e3c0:	2106b304 	addi	r4,r4,6860
    e3c4:	003f1a00 	call	3f1a0 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
    e3c8:	d1290317 	ldw	r4,-23540(gp)
    e3cc:	d0e90417 	ldw	r3,-23536(gp)
    e3d0:	d0a90517 	ldw	r2,-23532(gp)
    e3d4:	180b883a 	mov	r5,r3
    e3d8:	100d883a 	mov	r6,r2
    e3dc:	00033140 	call	3314 <main>
    e3e0:	e0bffd15 	stw	r2,-12(fp)
  close(STDOUT_FILENO);
    e3e4:	01000044 	movi	r4,1
    e3e8:	00199bc0 	call	199bc <close>
  exit (result);
    e3ec:	e13ffd17 	ldw	r4,-12(fp)
    e3f0:	003f1c40 	call	3f1c4 <exit>

0000e3f4 <__malloc_lock>:
xSemaphoreHandle alt_heapsem;

/* __malloc_lock needs to provide recursive mutex locking */

void __malloc_lock ( struct _reent *_r )
{
    e3f4:	defffd04 	addi	sp,sp,-12
    e3f8:	dfc00215 	stw	ra,8(sp)
    e3fc:	df000115 	stw	fp,4(sp)
    e400:	df000104 	addi	fp,sp,4
    e404:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
    e408:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    e40c:	1000041e 	bne	r2,zero,e420 <__malloc_lock+0x2c>
		return;
    e410:	00000b06 	br	e440 <__malloc_lock+0x4c>

	// wait for the mutex to be released
	while (xSemaphoreTakeRecursive(alt_heapsem, 10) != pdTRUE)
		vTaskDelay(1);
    e414:	01000044 	movi	r4,1
    e418:	000f8c00 	call	f8c0 <vTaskDelay>
    e41c:	00000106 	br	e424 <__malloc_lock+0x30>
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
		return;

	// wait for the mutex to be released
	while (xSemaphoreTakeRecursive(alt_heapsem, 10) != pdTRUE)
    e420:	0001883a 	nop
    e424:	d0a90617 	ldw	r2,-23528(gp)
    e428:	1009883a 	mov	r4,r2
    e42c:	01400284 	movi	r5,10
    e430:	000e8640 	call	e864 <xQueueTakeMutexRecursive>
    e434:	10800058 	cmpnei	r2,r2,1
    e438:	103ff61e 	bne	r2,zero,e414 <__malloc_lock+0x20>
		vTaskDelay(1);

#endif /* OS_THREAD_SAFE_NEWLIB */
	return;
    e43c:	0001883a 	nop
}
    e440:	e037883a 	mov	sp,fp
    e444:	dfc00117 	ldw	ra,4(sp)
    e448:	df000017 	ldw	fp,0(sp)
    e44c:	dec00204 	addi	sp,sp,8
    e450:	f800283a 	ret

0000e454 <__malloc_unlock>:

/* __malloc_unlock needs to provide recursive mutex unlocking */

void __malloc_unlock ( struct _reent *_r )
{
    e454:	defffd04 	addi	sp,sp,-12
    e458:	dfc00215 	stw	ra,8(sp)
    e45c:	df000115 	stw	fp,4(sp)
    e460:	df000104 	addi	fp,sp,4
    e464:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
    e468:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    e46c:	10000426 	beq	r2,zero,e480 <__malloc_unlock+0x2c>
		return;
	  
	xSemaphoreGiveRecursive(alt_heapsem);
    e470:	d0a90617 	ldw	r2,-23528(gp)
    e474:	1009883a 	mov	r4,r2
    e478:	000e7dc0 	call	e7dc <xQueueGiveMutexRecursive>
    e47c:	00000106 	br	e484 <__malloc_unlock+0x30>

void __malloc_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
		return;
    e480:	0001883a 	nop
	  
	xSemaphoreGiveRecursive(alt_heapsem);
#endif /* OS_THREAD_SAFE_NEWLIB */
}
    e484:	e037883a 	mov	sp,fp
    e488:	dfc00117 	ldw	ra,4(sp)
    e48c:	df000017 	ldw	fp,0(sp)
    e490:	dec00204 	addi	sp,sp,8
    e494:	f800283a 	ret

0000e498 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    e498:	defffc04 	addi	sp,sp,-16
    e49c:	dfc00315 	stw	ra,12(sp)
    e4a0:	df000215 	stw	fp,8(sp)
    e4a4:	df000204 	addi	fp,sp,8
    e4a8:	e13fff15 	stw	r4,-4(fp)
void *pvReturn;

	vTaskSuspendAll();
    e4ac:	000fef80 	call	fef8 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
    e4b0:	e13fff17 	ldw	r4,-4(fp)
    e4b4:	003f1fc0 	call	3f1fc <malloc>
    e4b8:	e0bffe15 	stw	r2,-8(fp)
	}
	xTaskResumeAll();
    e4bc:	000ff200 	call	ff20 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif
	
	return pvReturn;
    e4c0:	e0bffe17 	ldw	r2,-8(fp)
}
    e4c4:	e037883a 	mov	sp,fp
    e4c8:	dfc00117 	ldw	ra,4(sp)
    e4cc:	df000017 	ldw	fp,0(sp)
    e4d0:	dec00204 	addi	sp,sp,8
    e4d4:	f800283a 	ret

0000e4d8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    e4d8:	defffd04 	addi	sp,sp,-12
    e4dc:	dfc00215 	stw	ra,8(sp)
    e4e0:	df000115 	stw	fp,4(sp)
    e4e4:	df000104 	addi	fp,sp,4
    e4e8:	e13fff15 	stw	r4,-4(fp)
	if( pv )
    e4ec:	e0bfff17 	ldw	r2,-4(fp)
    e4f0:	10000426 	beq	r2,zero,e504 <vPortFree+0x2c>
	{
		vTaskSuspendAll();
    e4f4:	000fef80 	call	fef8 <vTaskSuspendAll>
		{
			free( pv );
    e4f8:	e13fff17 	ldw	r4,-4(fp)
    e4fc:	003f2100 	call	3f210 <free>
		}
		xTaskResumeAll();
    e500:	000ff200 	call	ff20 <xTaskResumeAll>
	}
}
    e504:	e037883a 	mov	sp,fp
    e508:	dfc00117 	ldw	ra,4(sp)
    e50c:	df000017 	ldw	fp,0(sp)
    e510:	dec00204 	addi	sp,sp,8
    e514:	f800283a 	ret

0000e518 <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
    e518:	defffc04 	addi	sp,sp,-16
    e51c:	dfc00315 	stw	ra,12(sp)
    e520:	df000215 	stw	fp,8(sp)
    e524:	df000204 	addi	fp,sp,8
    e528:	e13ffe15 	stw	r4,-8(fp)
    e52c:	e17fff15 	stw	r5,-4(fp)
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    e530:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    e534:	10000126 	beq	r2,zero,e53c <xQueueGenericReset+0x24>
    e538:	00110d00 	call	110d0 <vTaskEnterCritical>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    e53c:	e0bffe17 	ldw	r2,-8(fp)
    e540:	10c00017 	ldw	r3,0(r2)
    e544:	e0bffe17 	ldw	r2,-8(fp)
    e548:	11000f17 	ldw	r4,60(r2)
    e54c:	e0bffe17 	ldw	r2,-8(fp)
    e550:	10801017 	ldw	r2,64(r2)
    e554:	2085383a 	mul	r2,r4,r2
    e558:	1887883a 	add	r3,r3,r2
    e55c:	e0bffe17 	ldw	r2,-8(fp)
    e560:	10c00115 	stw	r3,4(r2)
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    e564:	e0bffe17 	ldw	r2,-8(fp)
    e568:	10000e15 	stw	zero,56(r2)
		pxQueue->pcWriteTo = pxQueue->pcHead;
    e56c:	e0bffe17 	ldw	r2,-8(fp)
    e570:	10c00017 	ldw	r3,0(r2)
    e574:	e0bffe17 	ldw	r2,-8(fp)
    e578:	10c00215 	stw	r3,8(r2)
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
    e57c:	e0bffe17 	ldw	r2,-8(fp)
    e580:	10c00017 	ldw	r3,0(r2)
    e584:	e0bffe17 	ldw	r2,-8(fp)
    e588:	10800f17 	ldw	r2,60(r2)
    e58c:	113fffc4 	addi	r4,r2,-1
    e590:	e0bffe17 	ldw	r2,-8(fp)
    e594:	10801017 	ldw	r2,64(r2)
    e598:	2085383a 	mul	r2,r4,r2
    e59c:	1887883a 	add	r3,r3,r2
    e5a0:	e0bffe17 	ldw	r2,-8(fp)
    e5a4:	10c00315 	stw	r3,12(r2)
		pxQueue->xRxLock = queueUNLOCKED;
    e5a8:	e0bffe17 	ldw	r2,-8(fp)
    e5ac:	00ffffc4 	movi	r3,-1
    e5b0:	10c01115 	stw	r3,68(r2)
		pxQueue->xTxLock = queueUNLOCKED;
    e5b4:	e0bffe17 	ldw	r2,-8(fp)
    e5b8:	00ffffc4 	movi	r3,-1
    e5bc:	10c01215 	stw	r3,72(r2)

		if( xNewQueue == pdFALSE )
    e5c0:	e0bfff17 	ldw	r2,-4(fp)
    e5c4:	10000b1e 	bne	r2,zero,e5f4 <xQueueGenericReset+0xdc>
			/* If there are tasks blocked waiting to read from the queue, then 
			the tasks will remain blocked as after this function exits the queue 
			will still be empty.  If there are tasks blocked waiting to	write to 
			the queue, then one should be unblocked as after this function exits 
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    e5c8:	e0bffe17 	ldw	r2,-8(fp)
    e5cc:	10800417 	ldw	r2,16(r2)
    e5d0:	10001026 	beq	r2,zero,e614 <xQueueGenericReset+0xfc>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    e5d4:	e0bffe17 	ldw	r2,-8(fp)
    e5d8:	10800404 	addi	r2,r2,16
    e5dc:	1009883a 	mov	r4,r2
    e5e0:	00105ec0 	call	105ec <xTaskRemoveFromEventList>
    e5e4:	10800058 	cmpnei	r2,r2,1
    e5e8:	10000a1e 	bne	r2,zero,e614 <xQueueGenericReset+0xfc>
				{
					portYIELD_WITHIN_API();
    e5ec:	003b683a 	trap	0
    e5f0:	00000806 	br	e614 <xQueueGenericReset+0xfc>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    e5f4:	e0bffe17 	ldw	r2,-8(fp)
    e5f8:	10800404 	addi	r2,r2,16
    e5fc:	1009883a 	mov	r4,r2
    e600:	003bf040 	call	3bf04 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );		
    e604:	e0bffe17 	ldw	r2,-8(fp)
    e608:	10800904 	addi	r2,r2,36
    e60c:	1009883a 	mov	r4,r2
    e610:	003bf040 	call	3bf04 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    e614:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    e618:	10000126 	beq	r2,zero,e620 <xQueueGenericReset+0x108>
    e61c:	00111100 	call	11110 <vTaskExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    e620:	00800044 	movi	r2,1
}
    e624:	e037883a 	mov	sp,fp
    e628:	dfc00117 	ldw	ra,4(sp)
    e62c:	df000017 	ldw	fp,0(sp)
    e630:	dec00204 	addi	sp,sp,8
    e634:	f800283a 	ret

0000e638 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
    e638:	defff804 	addi	sp,sp,-32
    e63c:	dfc00715 	stw	ra,28(sp)
    e640:	df000615 	stw	fp,24(sp)
    e644:	df000604 	addi	fp,sp,24
    e648:	e13ffd15 	stw	r4,-12(fp)
    e64c:	e17ffe15 	stw	r5,-8(fp)
    e650:	3005883a 	mov	r2,r6
    e654:	e0bfff05 	stb	r2,-4(fp)
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    e658:	e03ffa15 	stw	zero,-24(fp)
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    e65c:	e0bffd17 	ldw	r2,-12(fp)
    e660:	10002226 	beq	r2,zero,e6ec <xQueueGenericCreate+0xb4>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    e664:	01001404 	movi	r4,80
    e668:	000e4980 	call	e498 <pvPortMalloc>
    e66c:	e0bffb15 	stw	r2,-20(fp)
		if( pxNewQueue != NULL )
    e670:	e0bffb17 	ldw	r2,-20(fp)
    e674:	10001d26 	beq	r2,zero,e6ec <xQueueGenericCreate+0xb4>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    e678:	e0fffd17 	ldw	r3,-12(fp)
    e67c:	e0bffe17 	ldw	r2,-8(fp)
    e680:	1885383a 	mul	r2,r3,r2
    e684:	10800044 	addi	r2,r2,1
    e688:	e0bffc15 	stw	r2,-16(fp)

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    e68c:	e13ffc17 	ldw	r4,-16(fp)
    e690:	000e4980 	call	e498 <pvPortMalloc>
    e694:	e0fffb17 	ldw	r3,-20(fp)
    e698:	18800015 	stw	r2,0(r3)
			if( pxNewQueue->pcHead != NULL )
    e69c:	e0bffb17 	ldw	r2,-20(fp)
    e6a0:	10800017 	ldw	r2,0(r2)
    e6a4:	10000f26 	beq	r2,zero,e6e4 <xQueueGenericCreate+0xac>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    e6a8:	e0bffb17 	ldw	r2,-20(fp)
    e6ac:	e0fffd17 	ldw	r3,-12(fp)
    e6b0:	10c00f15 	stw	r3,60(r2)
				pxNewQueue->uxItemSize = uxItemSize;
    e6b4:	e0bffb17 	ldw	r2,-20(fp)
    e6b8:	e0fffe17 	ldw	r3,-8(fp)
    e6bc:	10c01015 	stw	r3,64(r2)
				xQueueGenericReset( pxNewQueue, pdTRUE );
    e6c0:	e13ffb17 	ldw	r4,-20(fp)
    e6c4:	01400044 	movi	r5,1
    e6c8:	000e5180 	call	e518 <xQueueGenericReset>
				#if ( configUSE_TRACE_FACILITY == 1 )
				{
					pxNewQueue->ucQueueType = ucQueueType;
    e6cc:	e0bffb17 	ldw	r2,-20(fp)
    e6d0:	e0ffff03 	ldbu	r3,-4(fp)
    e6d4:	10c01345 	stb	r3,77(r2)
				}
				#endif /* configUSE_TRACE_FACILITY */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    e6d8:	e0bffb17 	ldw	r2,-20(fp)
    e6dc:	e0bffa15 	stw	r2,-24(fp)
    e6e0:	00000206 	br	e6ec <xQueueGenericCreate+0xb4>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    e6e4:	e13ffb17 	ldw	r4,-20(fp)
    e6e8:	000e4d80 	call	e4d8 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    e6ec:	e0bffa17 	ldw	r2,-24(fp)
}
    e6f0:	e037883a 	mov	sp,fp
    e6f4:	dfc00117 	ldw	ra,4(sp)
    e6f8:	df000017 	ldw	fp,0(sp)
    e6fc:	dec00204 	addi	sp,sp,8
    e700:	f800283a 	ret

0000e704 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
    e704:	defffc04 	addi	sp,sp,-16
    e708:	dfc00315 	stw	ra,12(sp)
    e70c:	df000215 	stw	fp,8(sp)
    e710:	df000204 	addi	fp,sp,8
    e714:	2005883a 	mov	r2,r4
    e718:	e0bfff05 	stb	r2,-4(fp)
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    e71c:	01001404 	movi	r4,80
    e720:	000e4980 	call	e498 <pvPortMalloc>
    e724:	e0bffe15 	stw	r2,-8(fp)
		if( pxNewQueue != NULL )
    e728:	e0bffe17 	ldw	r2,-8(fp)
    e72c:	10002526 	beq	r2,zero,e7c4 <xQueueCreateMutex+0xc0>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    e730:	e0bffe17 	ldw	r2,-8(fp)
    e734:	10000115 	stw	zero,4(r2)
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    e738:	e0bffe17 	ldw	r2,-8(fp)
    e73c:	10000015 	stw	zero,0(r2)

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    e740:	e0bffe17 	ldw	r2,-8(fp)
    e744:	10000215 	stw	zero,8(r2)
			pxNewQueue->pcReadFrom = NULL;
    e748:	e0bffe17 	ldw	r2,-8(fp)
    e74c:	10000315 	stw	zero,12(r2)

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    e750:	e0bffe17 	ldw	r2,-8(fp)
    e754:	10000e15 	stw	zero,56(r2)
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
    e758:	e0bffe17 	ldw	r2,-8(fp)
    e75c:	00c00044 	movi	r3,1
    e760:	10c00f15 	stw	r3,60(r2)
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
    e764:	e0bffe17 	ldw	r2,-8(fp)
    e768:	10001015 	stw	zero,64(r2)
			pxNewQueue->xRxLock = queueUNLOCKED;
    e76c:	e0bffe17 	ldw	r2,-8(fp)
    e770:	00ffffc4 	movi	r3,-1
    e774:	10c01115 	stw	r3,68(r2)
			pxNewQueue->xTxLock = queueUNLOCKED;
    e778:	e0bffe17 	ldw	r2,-8(fp)
    e77c:	00ffffc4 	movi	r3,-1
    e780:	10c01215 	stw	r3,72(r2)

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				pxNewQueue->ucQueueType = ucQueueType;
    e784:	e0bffe17 	ldw	r2,-8(fp)
    e788:	e0ffff03 	ldbu	r3,-4(fp)
    e78c:	10c01345 	stb	r3,77(r2)
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    e790:	e0bffe17 	ldw	r2,-8(fp)
    e794:	10800404 	addi	r2,r2,16
    e798:	1009883a 	mov	r4,r2
    e79c:	003bf040 	call	3bf04 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    e7a0:	e0bffe17 	ldw	r2,-8(fp)
    e7a4:	10800904 	addi	r2,r2,36
    e7a8:	1009883a 	mov	r4,r2
    e7ac:	003bf040 	call	3bf04 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
    e7b0:	e13ffe17 	ldw	r4,-8(fp)
    e7b4:	000b883a 	mov	r5,zero
    e7b8:	000d883a 	mov	r6,zero
    e7bc:	000f883a 	mov	r7,zero
    e7c0:	000e95c0 	call	e95c <xQueueGenericSend>
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
    e7c4:	e0bffe17 	ldw	r2,-8(fp)
	}
    e7c8:	e037883a 	mov	sp,fp
    e7cc:	dfc00117 	ldw	ra,4(sp)
    e7d0:	df000017 	ldw	fp,0(sp)
    e7d4:	dec00204 	addi	sp,sp,8
    e7d8:	f800283a 	ret

0000e7dc <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle pxMutex )
	{
    e7dc:	defffb04 	addi	sp,sp,-20
    e7e0:	dfc00415 	stw	ra,16(sp)
    e7e4:	df000315 	stw	fp,12(sp)
    e7e8:	dc000215 	stw	r16,8(sp)
    e7ec:	df000204 	addi	fp,sp,8
    e7f0:	e13fff15 	stw	r4,-4(fp)
		change outside of this task.  If this task does not hold the mutex then
		pxMutexHolder can never coincidentally equal the tasks handle, and as
		this is the only condition we are interested in it does not matter if
		pxMutexHolder is accessed simultaneously by another task.  Therefore no
		mutual exclusion is required to test the pxMutexHolder variable. */
		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
    e7f4:	e0bfff17 	ldw	r2,-4(fp)
    e7f8:	14000117 	ldw	r16,4(r2)
    e7fc:	0010e940 	call	10e94 <xTaskGetCurrentTaskHandle>
    e800:	8080101e 	bne	r16,r2,e844 <xQueueGiveMutexRecursive+0x68>
			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
			the task handle, therefore no underflow check is required.  Also,
			uxRecursiveCallCount is only modified by the mutex holder, and as
			there can only be one, no mutual exclusion is required to modify the
			uxRecursiveCallCount member. */
			( pxMutex->uxRecursiveCallCount )--;
    e804:	e0bfff17 	ldw	r2,-4(fp)
    e808:	10800317 	ldw	r2,12(r2)
    e80c:	10ffffc4 	addi	r3,r2,-1
    e810:	e0bfff17 	ldw	r2,-4(fp)
    e814:	10c00315 	stw	r3,12(r2)

			/* Have we unwound the call count? */
			if( pxMutex->uxRecursiveCallCount == 0 )
    e818:	e0bfff17 	ldw	r2,-4(fp)
    e81c:	10800317 	ldw	r2,12(r2)
    e820:	1000051e 	bne	r2,zero,e838 <xQueueGiveMutexRecursive+0x5c>
			{
				/* Return the mutex.  This will automatically unblock any other
				task that might be waiting to access the mutex. */
				xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
    e824:	e13fff17 	ldw	r4,-4(fp)
    e828:	000b883a 	mov	r5,zero
    e82c:	000d883a 	mov	r6,zero
    e830:	000f883a 	mov	r7,zero
    e834:	000e95c0 	call	e95c <xQueueGenericSend>
			}

			xReturn = pdPASS;
    e838:	00800044 	movi	r2,1
    e83c:	e0bffe15 	stw	r2,-8(fp)
    e840:	00000106 	br	e848 <xQueueGiveMutexRecursive+0x6c>
		}
		else
		{
			/* We cannot give the mutex because we are not the holder. */
			xReturn = pdFAIL;
    e844:	e03ffe15 	stw	zero,-8(fp)

			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
		}

		return xReturn;
    e848:	e0bffe17 	ldw	r2,-8(fp)
	}
    e84c:	e037883a 	mov	sp,fp
    e850:	dfc00217 	ldw	ra,8(sp)
    e854:	df000117 	ldw	fp,4(sp)
    e858:	dc000017 	ldw	r16,0(sp)
    e85c:	dec00304 	addi	sp,sp,12
    e860:	f800283a 	ret

0000e864 <xQueueTakeMutexRecursive>:
/*-----------------------------------------------------------*/

#if configUSE_RECURSIVE_MUTEXES == 1

	portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle pxMutex, portTickType xBlockTime )
	{
    e864:	defffa04 	addi	sp,sp,-24
    e868:	dfc00515 	stw	ra,20(sp)
    e86c:	df000415 	stw	fp,16(sp)
    e870:	dc000315 	stw	r16,12(sp)
    e874:	df000304 	addi	fp,sp,12
    e878:	e13ffe15 	stw	r4,-8(fp)
    e87c:	e17fff15 	stw	r5,-4(fp)
		/* Comments regarding mutual exclusion as per those within
		xQueueGiveMutexRecursive(). */

		traceTAKE_MUTEX_RECURSIVE( pxMutex );

		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
    e880:	e0bffe17 	ldw	r2,-8(fp)
    e884:	14000117 	ldw	r16,4(r2)
    e888:	0010e940 	call	10e94 <xTaskGetCurrentTaskHandle>
    e88c:	8080081e 	bne	r16,r2,e8b0 <xQueueTakeMutexRecursive+0x4c>
		{
			( pxMutex->uxRecursiveCallCount )++;
    e890:	e0bffe17 	ldw	r2,-8(fp)
    e894:	10800317 	ldw	r2,12(r2)
    e898:	10c00044 	addi	r3,r2,1
    e89c:	e0bffe17 	ldw	r2,-8(fp)
    e8a0:	10c00315 	stw	r3,12(r2)
			xReturn = pdPASS;
    e8a4:	00800044 	movi	r2,1
    e8a8:	e0bffd15 	stw	r2,-12(fp)
    e8ac:	00000e06 	br	e8e8 <xQueueTakeMutexRecursive+0x84>
		}
		else
		{
			xReturn = xQueueGenericReceive( pxMutex, NULL, xBlockTime, pdFALSE );
    e8b0:	e13ffe17 	ldw	r4,-8(fp)
    e8b4:	000b883a 	mov	r5,zero
    e8b8:	e1bfff17 	ldw	r6,-4(fp)
    e8bc:	000f883a 	mov	r7,zero
    e8c0:	000ebd80 	call	ebd8 <xQueueGenericReceive>
    e8c4:	e0bffd15 	stw	r2,-12(fp)

			/* pdPASS will only be returned if we successfully obtained the mutex,
			we may have blocked to reach here. */
			if( xReturn == pdPASS )
    e8c8:	e0bffd17 	ldw	r2,-12(fp)
    e8cc:	10800058 	cmpnei	r2,r2,1
    e8d0:	1000051e 	bne	r2,zero,e8e8 <xQueueTakeMutexRecursive+0x84>
			{
				( pxMutex->uxRecursiveCallCount )++;
    e8d4:	e0bffe17 	ldw	r2,-8(fp)
    e8d8:	10800317 	ldw	r2,12(r2)
    e8dc:	10c00044 	addi	r3,r2,1
    e8e0:	e0bffe17 	ldw	r2,-8(fp)
    e8e4:	10c00315 	stw	r3,12(r2)
			{
				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
			}
		}

		return xReturn;
    e8e8:	e0bffd17 	ldw	r2,-12(fp)
	}
    e8ec:	e037883a 	mov	sp,fp
    e8f0:	dfc00217 	ldw	ra,8(sp)
    e8f4:	df000117 	ldw	fp,4(sp)
    e8f8:	dc000017 	ldw	r16,0(sp)
    e8fc:	dec00304 	addi	sp,sp,12
    e900:	f800283a 	ret

0000e904 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
	{
    e904:	defffb04 	addi	sp,sp,-20
    e908:	dfc00415 	stw	ra,16(sp)
    e90c:	df000315 	stw	fp,12(sp)
    e910:	df000304 	addi	fp,sp,12
    e914:	e13ffe15 	stw	r4,-8(fp)
    e918:	e17fff15 	stw	r5,-4(fp)
	xQueueHandle pxHandle;

		pxHandle = xQueueGenericCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    e91c:	e13ffe17 	ldw	r4,-8(fp)
    e920:	000b883a 	mov	r5,zero
    e924:	01800084 	movi	r6,2
    e928:	000e6380 	call	e638 <xQueueGenericCreate>
    e92c:	e0bffd15 	stw	r2,-12(fp)

		if( pxHandle != NULL )
    e930:	e0bffd17 	ldw	r2,-12(fp)
    e934:	10000326 	beq	r2,zero,e944 <xQueueCreateCountingSemaphore+0x40>
		{
			pxHandle->uxMessagesWaiting = uxInitialCount;
    e938:	e0bffd17 	ldw	r2,-12(fp)
    e93c:	e0ffff17 	ldw	r3,-4(fp)
    e940:	10c00e15 	stw	r3,56(r2)
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( pxHandle );
		return pxHandle;
    e944:	e0bffd17 	ldw	r2,-12(fp)
	}
    e948:	e037883a 	mov	sp,fp
    e94c:	dfc00117 	ldw	ra,4(sp)
    e950:	df000017 	ldw	fp,0(sp)
    e954:	dec00204 	addi	sp,sp,8
    e958:	f800283a 	ret

0000e95c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    e95c:	defff704 	addi	sp,sp,-36
    e960:	dfc00815 	stw	ra,32(sp)
    e964:	df000715 	stw	fp,28(sp)
    e968:	df000704 	addi	fp,sp,28
    e96c:	e13ffc15 	stw	r4,-16(fp)
    e970:	e17ffd15 	stw	r5,-12(fp)
    e974:	e1bffe15 	stw	r6,-8(fp)
    e978:	e1ffff15 	stw	r7,-4(fp)
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    e97c:	e03ff915 	stw	zero,-28(fp)
    e980:	00000106 	br	e988 <xQueueGenericSend+0x2c>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
    e984:	0001883a 	nop
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    e988:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    e98c:	10000126 	beq	r2,zero,e994 <xQueueGenericSend+0x38>
    e990:	00110d00 	call	110d0 <vTaskEnterCritical>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    e994:	e0bffc17 	ldw	r2,-16(fp)
    e998:	10c00e17 	ldw	r3,56(r2)
    e99c:	e0bffc17 	ldw	r2,-16(fp)
    e9a0:	10800f17 	ldw	r2,60(r2)
    e9a4:	1880132e 	bgeu	r3,r2,e9f4 <xQueueGenericSend+0x98>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    e9a8:	e13ffc17 	ldw	r4,-16(fp)
    e9ac:	e17ffd17 	ldw	r5,-12(fp)
    e9b0:	e1bfff17 	ldw	r6,-4(fp)
    e9b4:	000f0380 	call	f038 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    e9b8:	e0bffc17 	ldw	r2,-16(fp)
    e9bc:	10800917 	ldw	r2,36(r2)
    e9c0:	10000726 	beq	r2,zero,e9e0 <xQueueGenericSend+0x84>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    e9c4:	e0bffc17 	ldw	r2,-16(fp)
    e9c8:	10800904 	addi	r2,r2,36
    e9cc:	1009883a 	mov	r4,r2
    e9d0:	00105ec0 	call	105ec <xTaskRemoveFromEventList>
    e9d4:	10800058 	cmpnei	r2,r2,1
    e9d8:	1000011e 	bne	r2,zero,e9e0 <xQueueGenericSend+0x84>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    e9dc:	003b683a 	trap	0
					}
				}

				taskEXIT_CRITICAL();
    e9e0:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    e9e4:	10000126 	beq	r2,zero,e9ec <xQueueGenericSend+0x90>
    e9e8:	00111100 	call	11110 <vTaskExitCritical>

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    e9ec:	00800044 	movi	r2,1
    e9f0:	00004106 	br	eaf8 <xQueueGenericSend+0x19c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    e9f4:	e0bffe17 	ldw	r2,-8(fp)
    e9f8:	1000051e 	bne	r2,zero,ea10 <xQueueGenericSend+0xb4>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    e9fc:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    ea00:	10000126 	beq	r2,zero,ea08 <xQueueGenericSend+0xac>
    ea04:	00111100 	call	11110 <vTaskExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    ea08:	0005883a 	mov	r2,zero
    ea0c:	00003a06 	br	eaf8 <xQueueGenericSend+0x19c>
				}
				else if( xEntryTimeSet == pdFALSE )
    ea10:	e0bff917 	ldw	r2,-28(fp)
    ea14:	1000051e 	bne	r2,zero,ea2c <xQueueGenericSend+0xd0>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    ea18:	e0bffa04 	addi	r2,fp,-24
    ea1c:	1009883a 	mov	r4,r2
    ea20:	00106d80 	call	106d8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    ea24:	00800044 	movi	r2,1
    ea28:	e0bff915 	stw	r2,-28(fp)
				}
			}
		}
		taskEXIT_CRITICAL();
    ea2c:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    ea30:	10000126 	beq	r2,zero,ea38 <xQueueGenericSend+0xdc>
    ea34:	00111100 	call	11110 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    ea38:	000fef80 	call	fef8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    ea3c:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    ea40:	10000126 	beq	r2,zero,ea48 <xQueueGenericSend+0xec>
    ea44:	00110d00 	call	110d0 <vTaskEnterCritical>
    ea48:	e0bffc17 	ldw	r2,-16(fp)
    ea4c:	10801117 	ldw	r2,68(r2)
    ea50:	10bfffd8 	cmpnei	r2,r2,-1
    ea54:	1000021e 	bne	r2,zero,ea60 <xQueueGenericSend+0x104>
    ea58:	e0bffc17 	ldw	r2,-16(fp)
    ea5c:	10001115 	stw	zero,68(r2)
    ea60:	e0bffc17 	ldw	r2,-16(fp)
    ea64:	10801217 	ldw	r2,72(r2)
    ea68:	10bfffd8 	cmpnei	r2,r2,-1
    ea6c:	1000021e 	bne	r2,zero,ea78 <xQueueGenericSend+0x11c>
    ea70:	e0bffc17 	ldw	r2,-16(fp)
    ea74:	10001215 	stw	zero,72(r2)
    ea78:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    ea7c:	10000126 	beq	r2,zero,ea84 <xQueueGenericSend+0x128>
    ea80:	00111100 	call	11110 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    ea84:	e0fffa04 	addi	r3,fp,-24
    ea88:	e0bffe04 	addi	r2,fp,-8
    ea8c:	1809883a 	mov	r4,r3
    ea90:	100b883a 	mov	r5,r2
    ea94:	00107100 	call	10710 <xTaskCheckForTimeOut>
    ea98:	1000131e 	bne	r2,zero,eae8 <xQueueGenericSend+0x18c>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    ea9c:	e13ffc17 	ldw	r4,-16(fp)
    eaa0:	000f3d80 	call	f3d8 <prvIsQueueFull>
    eaa4:	10000c26 	beq	r2,zero,ead8 <xQueueGenericSend+0x17c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    eaa8:	e0bffc17 	ldw	r2,-16(fp)
    eaac:	10c00404 	addi	r3,r2,16
    eab0:	e0bffe17 	ldw	r2,-8(fp)
    eab4:	1809883a 	mov	r4,r3
    eab8:	100b883a 	mov	r5,r2
    eabc:	00104f40 	call	104f4 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    eac0:	e13ffc17 	ldw	r4,-16(fp)
    eac4:	000f2280 	call	f228 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    eac8:	000ff200 	call	ff20 <xTaskResumeAll>
    eacc:	103fad1e 	bne	r2,zero,e984 <xQueueGenericSend+0x28>
				{
					portYIELD_WITHIN_API();
    ead0:	003b683a 	trap	0
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
    ead4:	003fab06 	br	e984 <xQueueGenericSend+0x28>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    ead8:	e13ffc17 	ldw	r4,-16(fp)
    eadc:	000f2280 	call	f228 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    eae0:	000ff200 	call	ff20 <xTaskResumeAll>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
    eae4:	003fa706 	br	e984 <xQueueGenericSend+0x28>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    eae8:	e13ffc17 	ldw	r4,-16(fp)
    eaec:	000f2280 	call	f228 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    eaf0:	000ff200 	call	ff20 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    eaf4:	0005883a 	mov	r2,zero
		}
	}
}
    eaf8:	e037883a 	mov	sp,fp
    eafc:	dfc00117 	ldw	ra,4(sp)
    eb00:	df000017 	ldw	fp,0(sp)
    eb04:	dec00204 	addi	sp,sp,8
    eb08:	f800283a 	ret

0000eb0c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    eb0c:	defff804 	addi	sp,sp,-32
    eb10:	dfc00715 	stw	ra,28(sp)
    eb14:	df000615 	stw	fp,24(sp)
    eb18:	df000604 	addi	fp,sp,24
    eb1c:	e13ffc15 	stw	r4,-16(fp)
    eb20:	e17ffd15 	stw	r5,-12(fp)
    eb24:	e1bffe15 	stw	r6,-8(fp)
    eb28:	e1ffff15 	stw	r7,-4(fp)
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    eb2c:	e03ffb15 	stw	zero,-20(fp)
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    eb30:	e0bffc17 	ldw	r2,-16(fp)
    eb34:	10c00e17 	ldw	r3,56(r2)
    eb38:	e0bffc17 	ldw	r2,-16(fp)
    eb3c:	10800f17 	ldw	r2,60(r2)
    eb40:	18801e2e 	bgeu	r3,r2,ebbc <xQueueGenericSendFromISR+0xb0>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    eb44:	e13ffc17 	ldw	r4,-16(fp)
    eb48:	e17ffd17 	ldw	r5,-12(fp)
    eb4c:	e1bfff17 	ldw	r6,-4(fp)
    eb50:	000f0380 	call	f038 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    eb54:	e0bffc17 	ldw	r2,-16(fp)
    eb58:	10801217 	ldw	r2,72(r2)
    eb5c:	10bfffd8 	cmpnei	r2,r2,-1
    eb60:	10000e1e 	bne	r2,zero,eb9c <xQueueGenericSendFromISR+0x90>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    eb64:	e0bffc17 	ldw	r2,-16(fp)
    eb68:	10800917 	ldw	r2,36(r2)
    eb6c:	10001026 	beq	r2,zero,ebb0 <xQueueGenericSendFromISR+0xa4>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    eb70:	e0bffc17 	ldw	r2,-16(fp)
    eb74:	10800904 	addi	r2,r2,36
    eb78:	1009883a 	mov	r4,r2
    eb7c:	00105ec0 	call	105ec <xTaskRemoveFromEventList>
    eb80:	10000b26 	beq	r2,zero,ebb0 <xQueueGenericSendFromISR+0xa4>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						if( pxHigherPriorityTaskWoken != NULL )
    eb84:	e0bffe17 	ldw	r2,-8(fp)
    eb88:	10000926 	beq	r2,zero,ebb0 <xQueueGenericSendFromISR+0xa4>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    eb8c:	e0bffe17 	ldw	r2,-8(fp)
    eb90:	00c00044 	movi	r3,1
    eb94:	10c00015 	stw	r3,0(r2)
    eb98:	00000506 	br	ebb0 <xQueueGenericSendFromISR+0xa4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    eb9c:	e0bffc17 	ldw	r2,-16(fp)
    eba0:	10801217 	ldw	r2,72(r2)
    eba4:	10c00044 	addi	r3,r2,1
    eba8:	e0bffc17 	ldw	r2,-16(fp)
    ebac:	10c01215 	stw	r3,72(r2)
			}

			xReturn = pdPASS;
    ebb0:	00800044 	movi	r2,1
    ebb4:	e0bffa15 	stw	r2,-24(fp)
    ebb8:	00000106 	br	ebc0 <xQueueGenericSendFromISR+0xb4>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    ebbc:	e03ffa15 	stw	zero,-24(fp)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    ebc0:	e0bffa17 	ldw	r2,-24(fp)
}
    ebc4:	e037883a 	mov	sp,fp
    ebc8:	dfc00117 	ldw	ra,4(sp)
    ebcc:	df000017 	ldw	fp,0(sp)
    ebd0:	dec00204 	addi	sp,sp,8
    ebd4:	f800283a 	ret

0000ebd8 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    ebd8:	defff604 	addi	sp,sp,-40
    ebdc:	dfc00915 	stw	ra,36(sp)
    ebe0:	df000815 	stw	fp,32(sp)
    ebe4:	df000804 	addi	fp,sp,32
    ebe8:	e13ffc15 	stw	r4,-16(fp)
    ebec:	e17ffd15 	stw	r5,-12(fp)
    ebf0:	e1bffe15 	stw	r6,-8(fp)
    ebf4:	e1ffff15 	stw	r7,-4(fp)
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    ebf8:	e03ff815 	stw	zero,-32(fp)
    ebfc:	00000106 	br	ec04 <xQueueGenericReceive+0x2c>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
    ec00:	0001883a 	nop
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    ec04:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    ec08:	10000126 	beq	r2,zero,ec10 <xQueueGenericReceive+0x38>
    ec0c:	00110d00 	call	110d0 <vTaskEnterCritical>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    ec10:	e0bffc17 	ldw	r2,-16(fp)
    ec14:	10800e17 	ldw	r2,56(r2)
    ec18:	10002f26 	beq	r2,zero,ecd8 <xQueueGenericReceive+0x100>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    ec1c:	e0bffc17 	ldw	r2,-16(fp)
    ec20:	10800317 	ldw	r2,12(r2)
    ec24:	e0bff915 	stw	r2,-28(fp)

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    ec28:	e13ffc17 	ldw	r4,-16(fp)
    ec2c:	e17ffd17 	ldw	r5,-12(fp)
    ec30:	000f1900 	call	f190 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    ec34:	e0bfff17 	ldw	r2,-4(fp)
    ec38:	1000161e 	bne	r2,zero,ec94 <xQueueGenericReceive+0xbc>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    ec3c:	e0bffc17 	ldw	r2,-16(fp)
    ec40:	10800e17 	ldw	r2,56(r2)
    ec44:	10ffffc4 	addi	r3,r2,-1
    ec48:	e0bffc17 	ldw	r2,-16(fp)
    ec4c:	10c00e15 	stw	r3,56(r2)

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    ec50:	e0bffc17 	ldw	r2,-16(fp)
    ec54:	10800017 	ldw	r2,0(r2)
    ec58:	1000031e 	bne	r2,zero,ec68 <xQueueGenericReceive+0x90>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    ec5c:	0010e940 	call	10e94 <xTaskGetCurrentTaskHandle>
    ec60:	e0fffc17 	ldw	r3,-16(fp)
    ec64:	18800115 	stw	r2,4(r3)
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    ec68:	e0bffc17 	ldw	r2,-16(fp)
    ec6c:	10800417 	ldw	r2,16(r2)
    ec70:	10001426 	beq	r2,zero,ecc4 <xQueueGenericReceive+0xec>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    ec74:	e0bffc17 	ldw	r2,-16(fp)
    ec78:	10800404 	addi	r2,r2,16
    ec7c:	1009883a 	mov	r4,r2
    ec80:	00105ec0 	call	105ec <xTaskRemoveFromEventList>
    ec84:	10800058 	cmpnei	r2,r2,1
    ec88:	10000e1e 	bne	r2,zero,ecc4 <xQueueGenericReceive+0xec>
						{
							portYIELD_WITHIN_API();
    ec8c:	003b683a 	trap	0
    ec90:	00000c06 	br	ecc4 <xQueueGenericReceive+0xec>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    ec94:	e0bffc17 	ldw	r2,-16(fp)
    ec98:	e0fff917 	ldw	r3,-28(fp)
    ec9c:	10c00315 	stw	r3,12(r2)

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    eca0:	e0bffc17 	ldw	r2,-16(fp)
    eca4:	10800917 	ldw	r2,36(r2)
    eca8:	10000626 	beq	r2,zero,ecc4 <xQueueGenericReceive+0xec>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    ecac:	e0bffc17 	ldw	r2,-16(fp)
    ecb0:	10800904 	addi	r2,r2,36
    ecb4:	1009883a 	mov	r4,r2
    ecb8:	00105ec0 	call	105ec <xTaskRemoveFromEventList>
    ecbc:	10000126 	beq	r2,zero,ecc4 <xQueueGenericReceive+0xec>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    ecc0:	003b683a 	trap	0
						}
					}
				}

				taskEXIT_CRITICAL();
    ecc4:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    ecc8:	10000126 	beq	r2,zero,ecd0 <xQueueGenericReceive+0xf8>
    eccc:	00111100 	call	11110 <vTaskExitCritical>
				return pdPASS;
    ecd0:	00800044 	movi	r2,1
    ecd4:	00004e06 	br	ee10 <xQueueGenericReceive+0x238>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    ecd8:	e0bffe17 	ldw	r2,-8(fp)
    ecdc:	1000051e 	bne	r2,zero,ecf4 <xQueueGenericReceive+0x11c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    ece0:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    ece4:	10000126 	beq	r2,zero,ecec <xQueueGenericReceive+0x114>
    ece8:	00111100 	call	11110 <vTaskExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    ecec:	0005883a 	mov	r2,zero
    ecf0:	00004706 	br	ee10 <xQueueGenericReceive+0x238>
				}
				else if( xEntryTimeSet == pdFALSE )
    ecf4:	e0bff817 	ldw	r2,-32(fp)
    ecf8:	1000051e 	bne	r2,zero,ed10 <xQueueGenericReceive+0x138>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    ecfc:	e0bffa04 	addi	r2,fp,-24
    ed00:	1009883a 	mov	r4,r2
    ed04:	00106d80 	call	106d8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    ed08:	00800044 	movi	r2,1
    ed0c:	e0bff815 	stw	r2,-32(fp)
				}
			}
		}
		taskEXIT_CRITICAL();
    ed10:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    ed14:	10000126 	beq	r2,zero,ed1c <xQueueGenericReceive+0x144>
    ed18:	00111100 	call	11110 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    ed1c:	000fef80 	call	fef8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    ed20:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    ed24:	10000126 	beq	r2,zero,ed2c <xQueueGenericReceive+0x154>
    ed28:	00110d00 	call	110d0 <vTaskEnterCritical>
    ed2c:	e0bffc17 	ldw	r2,-16(fp)
    ed30:	10801117 	ldw	r2,68(r2)
    ed34:	10bfffd8 	cmpnei	r2,r2,-1
    ed38:	1000021e 	bne	r2,zero,ed44 <xQueueGenericReceive+0x16c>
    ed3c:	e0bffc17 	ldw	r2,-16(fp)
    ed40:	10001115 	stw	zero,68(r2)
    ed44:	e0bffc17 	ldw	r2,-16(fp)
    ed48:	10801217 	ldw	r2,72(r2)
    ed4c:	10bfffd8 	cmpnei	r2,r2,-1
    ed50:	1000021e 	bne	r2,zero,ed5c <xQueueGenericReceive+0x184>
    ed54:	e0bffc17 	ldw	r2,-16(fp)
    ed58:	10001215 	stw	zero,72(r2)
    ed5c:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    ed60:	10000126 	beq	r2,zero,ed68 <xQueueGenericReceive+0x190>
    ed64:	00111100 	call	11110 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    ed68:	e0fffa04 	addi	r3,fp,-24
    ed6c:	e0bffe04 	addi	r2,fp,-8
    ed70:	1809883a 	mov	r4,r3
    ed74:	100b883a 	mov	r5,r2
    ed78:	00107100 	call	10710 <xTaskCheckForTimeOut>
    ed7c:	1000201e 	bne	r2,zero,ee00 <xQueueGenericReceive+0x228>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    ed80:	e13ffc17 	ldw	r4,-16(fp)
    ed84:	000f3480 	call	f348 <prvIsQueueEmpty>
    ed88:	10001926 	beq	r2,zero,edf0 <xQueueGenericReceive+0x218>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    ed8c:	e0bffc17 	ldw	r2,-16(fp)
    ed90:	10800017 	ldw	r2,0(r2)
    ed94:	10000a1e 	bne	r2,zero,edc0 <xQueueGenericReceive+0x1e8>
					{
						portENTER_CRITICAL();
    ed98:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    ed9c:	10000126 	beq	r2,zero,eda4 <xQueueGenericReceive+0x1cc>
    eda0:	00110d00 	call	110d0 <vTaskEnterCritical>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    eda4:	e0bffc17 	ldw	r2,-16(fp)
    eda8:	10800117 	ldw	r2,4(r2)
    edac:	1009883a 	mov	r4,r2
    edb0:	0010f080 	call	10f08 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    edb4:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    edb8:	10000126 	beq	r2,zero,edc0 <xQueueGenericReceive+0x1e8>
    edbc:	00111100 	call	11110 <vTaskExitCritical>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    edc0:	e0bffc17 	ldw	r2,-16(fp)
    edc4:	10c00904 	addi	r3,r2,36
    edc8:	e0bffe17 	ldw	r2,-8(fp)
    edcc:	1809883a 	mov	r4,r3
    edd0:	100b883a 	mov	r5,r2
    edd4:	00104f40 	call	104f4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    edd8:	e13ffc17 	ldw	r4,-16(fp)
    eddc:	000f2280 	call	f228 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    ede0:	000ff200 	call	ff20 <xTaskResumeAll>
    ede4:	103f861e 	bne	r2,zero,ec00 <xQueueGenericReceive+0x28>
				{
					portYIELD_WITHIN_API();
    ede8:	003b683a 	trap	0
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
    edec:	003f8406 	br	ec00 <xQueueGenericReceive+0x28>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    edf0:	e13ffc17 	ldw	r4,-16(fp)
    edf4:	000f2280 	call	f228 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    edf8:	000ff200 	call	ff20 <xTaskResumeAll>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
    edfc:	003f8006 	br	ec00 <xQueueGenericReceive+0x28>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    ee00:	e13ffc17 	ldw	r4,-16(fp)
    ee04:	000f2280 	call	f228 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    ee08:	000ff200 	call	ff20 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    ee0c:	0005883a 	mov	r2,zero
		}
	}
}
    ee10:	e037883a 	mov	sp,fp
    ee14:	dfc00117 	ldw	ra,4(sp)
    ee18:	df000017 	ldw	fp,0(sp)
    ee1c:	dec00204 	addi	sp,sp,8
    ee20:	f800283a 	ret

0000ee24 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
    ee24:	defff904 	addi	sp,sp,-28
    ee28:	dfc00615 	stw	ra,24(sp)
    ee2c:	df000515 	stw	fp,20(sp)
    ee30:	df000504 	addi	fp,sp,20
    ee34:	e13ffd15 	stw	r4,-12(fp)
    ee38:	e17ffe15 	stw	r5,-8(fp)
    ee3c:	e1bfff15 	stw	r6,-4(fp)
unsigned portBASE_TYPE uxSavedInterruptStatus;

	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    ee40:	e03ffc15 	stw	zero,-16(fp)
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    ee44:	e0bffd17 	ldw	r2,-12(fp)
    ee48:	10800e17 	ldw	r2,56(r2)
    ee4c:	10002226 	beq	r2,zero,eed8 <xQueueReceiveFromISR+0xb4>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    ee50:	e13ffd17 	ldw	r4,-12(fp)
    ee54:	e17ffe17 	ldw	r5,-8(fp)
    ee58:	000f1900 	call	f190 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    ee5c:	e0bffd17 	ldw	r2,-12(fp)
    ee60:	10800e17 	ldw	r2,56(r2)
    ee64:	10ffffc4 	addi	r3,r2,-1
    ee68:	e0bffd17 	ldw	r2,-12(fp)
    ee6c:	10c00e15 	stw	r3,56(r2)

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    ee70:	e0bffd17 	ldw	r2,-12(fp)
    ee74:	10801117 	ldw	r2,68(r2)
    ee78:	10bfffd8 	cmpnei	r2,r2,-1
    ee7c:	10000e1e 	bne	r2,zero,eeb8 <xQueueReceiveFromISR+0x94>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    ee80:	e0bffd17 	ldw	r2,-12(fp)
    ee84:	10800417 	ldw	r2,16(r2)
    ee88:	10001026 	beq	r2,zero,eecc <xQueueReceiveFromISR+0xa8>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    ee8c:	e0bffd17 	ldw	r2,-12(fp)
    ee90:	10800404 	addi	r2,r2,16
    ee94:	1009883a 	mov	r4,r2
    ee98:	00105ec0 	call	105ec <xTaskRemoveFromEventList>
    ee9c:	10000b26 	beq	r2,zero,eecc <xQueueReceiveFromISR+0xa8>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    eea0:	e0bfff17 	ldw	r2,-4(fp)
    eea4:	10000926 	beq	r2,zero,eecc <xQueueReceiveFromISR+0xa8>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    eea8:	e0bfff17 	ldw	r2,-4(fp)
    eeac:	00c00044 	movi	r3,1
    eeb0:	10c00015 	stw	r3,0(r2)
    eeb4:	00000506 	br	eecc <xQueueReceiveFromISR+0xa8>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    eeb8:	e0bffd17 	ldw	r2,-12(fp)
    eebc:	10801117 	ldw	r2,68(r2)
    eec0:	10c00044 	addi	r3,r2,1
    eec4:	e0bffd17 	ldw	r2,-12(fp)
    eec8:	10c01115 	stw	r3,68(r2)
			}

			xReturn = pdPASS;
    eecc:	00800044 	movi	r2,1
    eed0:	e0bffb15 	stw	r2,-20(fp)
    eed4:	00000106 	br	eedc <xQueueReceiveFromISR+0xb8>
		}
		else
		{
			xReturn = pdFAIL;
    eed8:	e03ffb15 	stw	zero,-20(fp)
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    eedc:	e0bffb17 	ldw	r2,-20(fp)
}
    eee0:	e037883a 	mov	sp,fp
    eee4:	dfc00117 	ldw	ra,4(sp)
    eee8:	df000017 	ldw	fp,0(sp)
    eeec:	dec00204 	addi	sp,sp,8
    eef0:	f800283a 	ret

0000eef4 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    eef4:	defffc04 	addi	sp,sp,-16
    eef8:	dfc00315 	stw	ra,12(sp)
    eefc:	df000215 	stw	fp,8(sp)
    ef00:	df000204 	addi	fp,sp,8
    ef04:	e13fff15 	stw	r4,-4(fp)
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    ef08:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    ef0c:	10000126 	beq	r2,zero,ef14 <uxQueueMessagesWaiting+0x20>
    ef10:	00110d00 	call	110d0 <vTaskEnterCritical>
		uxReturn = pxQueue->uxMessagesWaiting;
    ef14:	e0bfff17 	ldw	r2,-4(fp)
    ef18:	10800e17 	ldw	r2,56(r2)
    ef1c:	e0bffe15 	stw	r2,-8(fp)
	taskEXIT_CRITICAL();
    ef20:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    ef24:	10000126 	beq	r2,zero,ef2c <uxQueueMessagesWaiting+0x38>
    ef28:	00111100 	call	11110 <vTaskExitCritical>

	return uxReturn;
    ef2c:	e0bffe17 	ldw	r2,-8(fp)
}
    ef30:	e037883a 	mov	sp,fp
    ef34:	dfc00117 	ldw	ra,4(sp)
    ef38:	df000017 	ldw	fp,0(sp)
    ef3c:	dec00204 	addi	sp,sp,8
    ef40:	f800283a 	ret

0000ef44 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    ef44:	defffd04 	addi	sp,sp,-12
    ef48:	df000215 	stw	fp,8(sp)
    ef4c:	df000204 	addi	fp,sp,8
    ef50:	e13fff15 	stw	r4,-4(fp)
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    ef54:	e0bfff17 	ldw	r2,-4(fp)
    ef58:	10800e17 	ldw	r2,56(r2)
    ef5c:	e0bffe15 	stw	r2,-8(fp)

	return uxReturn;
    ef60:	e0bffe17 	ldw	r2,-8(fp)
}
    ef64:	e037883a 	mov	sp,fp
    ef68:	df000017 	ldw	fp,0(sp)
    ef6c:	dec00104 	addi	sp,sp,4
    ef70:	f800283a 	ret

0000ef74 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    ef74:	defffd04 	addi	sp,sp,-12
    ef78:	dfc00215 	stw	ra,8(sp)
    ef7c:	df000115 	stw	fp,4(sp)
    ef80:	df000104 	addi	fp,sp,4
    ef84:	e13fff15 	stw	r4,-4(fp)
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    ef88:	e0bfff17 	ldw	r2,-4(fp)
    ef8c:	10800017 	ldw	r2,0(r2)
    ef90:	1009883a 	mov	r4,r2
    ef94:	000e4d80 	call	e4d8 <vPortFree>
	vPortFree( pxQueue );
    ef98:	e13fff17 	ldw	r4,-4(fp)
    ef9c:	000e4d80 	call	e4d8 <vPortFree>
}
    efa0:	e037883a 	mov	sp,fp
    efa4:	dfc00117 	ldw	ra,4(sp)
    efa8:	df000017 	ldw	fp,0(sp)
    efac:	dec00204 	addi	sp,sp,8
    efb0:	f800283a 	ret

0000efb4 <ucQueueGetQueueNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	unsigned char ucQueueGetQueueNumber( xQueueHandle pxQueue )
	{
    efb4:	defffe04 	addi	sp,sp,-8
    efb8:	df000115 	stw	fp,4(sp)
    efbc:	df000104 	addi	fp,sp,4
    efc0:	e13fff15 	stw	r4,-4(fp)
		return pxQueue->ucQueueNumber;
    efc4:	e0bfff17 	ldw	r2,-4(fp)
    efc8:	10801303 	ldbu	r2,76(r2)
	}
    efcc:	e037883a 	mov	sp,fp
    efd0:	df000017 	ldw	fp,0(sp)
    efd4:	dec00104 	addi	sp,sp,4
    efd8:	f800283a 	ret

0000efdc <vQueueSetQueueNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vQueueSetQueueNumber( xQueueHandle pxQueue, unsigned char ucQueueNumber )
	{
    efdc:	defffd04 	addi	sp,sp,-12
    efe0:	df000215 	stw	fp,8(sp)
    efe4:	df000204 	addi	fp,sp,8
    efe8:	e13ffe15 	stw	r4,-8(fp)
    efec:	2805883a 	mov	r2,r5
    eff0:	e0bfff05 	stb	r2,-4(fp)
		pxQueue->ucQueueNumber = ucQueueNumber;
    eff4:	e0bffe17 	ldw	r2,-8(fp)
    eff8:	e0ffff03 	ldbu	r3,-4(fp)
    effc:	10c01305 	stb	r3,76(r2)
	}
    f000:	e037883a 	mov	sp,fp
    f004:	df000017 	ldw	fp,0(sp)
    f008:	dec00104 	addi	sp,sp,4
    f00c:	f800283a 	ret

0000f010 <ucQueueGetQueueType>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	unsigned char ucQueueGetQueueType( xQueueHandle pxQueue )
	{
    f010:	defffe04 	addi	sp,sp,-8
    f014:	df000115 	stw	fp,4(sp)
    f018:	df000104 	addi	fp,sp,4
    f01c:	e13fff15 	stw	r4,-4(fp)
		return pxQueue->ucQueueType;
    f020:	e0bfff17 	ldw	r2,-4(fp)
    f024:	10801343 	ldbu	r2,77(r2)
	}
    f028:	e037883a 	mov	sp,fp
    f02c:	df000017 	ldw	fp,0(sp)
    f030:	dec00104 	addi	sp,sp,4
    f034:	f800283a 	ret

0000f038 <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    f038:	defffb04 	addi	sp,sp,-20
    f03c:	dfc00415 	stw	ra,16(sp)
    f040:	df000315 	stw	fp,12(sp)
    f044:	df000304 	addi	fp,sp,12
    f048:	e13ffd15 	stw	r4,-12(fp)
    f04c:	e17ffe15 	stw	r5,-8(fp)
    f050:	e1bfff15 	stw	r6,-4(fp)
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    f054:	e0bffd17 	ldw	r2,-12(fp)
    f058:	10801017 	ldw	r2,64(r2)
    f05c:	10000a1e 	bne	r2,zero,f088 <prvCopyDataToQueue+0x50>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    f060:	e0bffd17 	ldw	r2,-12(fp)
    f064:	10800017 	ldw	r2,0(r2)
    f068:	10003f1e 	bne	r2,zero,f168 <prvCopyDataToQueue+0x130>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    f06c:	e0bffd17 	ldw	r2,-12(fp)
    f070:	10800117 	ldw	r2,4(r2)
    f074:	1009883a 	mov	r4,r2
    f078:	00110040 	call	11004 <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    f07c:	e0bffd17 	ldw	r2,-12(fp)
    f080:	10000115 	stw	zero,4(r2)
    f084:	00003806 	br	f168 <prvCopyDataToQueue+0x130>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    f088:	e0bfff17 	ldw	r2,-4(fp)
    f08c:	1000191e 	bne	r2,zero,f0f4 <prvCopyDataToQueue+0xbc>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    f090:	e0bffd17 	ldw	r2,-12(fp)
    f094:	10c00217 	ldw	r3,8(r2)
    f098:	e0bffd17 	ldw	r2,-12(fp)
    f09c:	10801017 	ldw	r2,64(r2)
    f0a0:	1809883a 	mov	r4,r3
    f0a4:	e17ffe17 	ldw	r5,-8(fp)
    f0a8:	100d883a 	mov	r6,r2
    f0ac:	00041f00 	call	41f0 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    f0b0:	e0bffd17 	ldw	r2,-12(fp)
    f0b4:	10c00217 	ldw	r3,8(r2)
    f0b8:	e0bffd17 	ldw	r2,-12(fp)
    f0bc:	10801017 	ldw	r2,64(r2)
    f0c0:	1887883a 	add	r3,r3,r2
    f0c4:	e0bffd17 	ldw	r2,-12(fp)
    f0c8:	10c00215 	stw	r3,8(r2)
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    f0cc:	e0bffd17 	ldw	r2,-12(fp)
    f0d0:	10c00217 	ldw	r3,8(r2)
    f0d4:	e0bffd17 	ldw	r2,-12(fp)
    f0d8:	10800117 	ldw	r2,4(r2)
    f0dc:	18802236 	bltu	r3,r2,f168 <prvCopyDataToQueue+0x130>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    f0e0:	e0bffd17 	ldw	r2,-12(fp)
    f0e4:	10c00017 	ldw	r3,0(r2)
    f0e8:	e0bffd17 	ldw	r2,-12(fp)
    f0ec:	10c00215 	stw	r3,8(r2)
    f0f0:	00001d06 	br	f168 <prvCopyDataToQueue+0x130>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    f0f4:	e0bffd17 	ldw	r2,-12(fp)
    f0f8:	10c00317 	ldw	r3,12(r2)
    f0fc:	e0bffd17 	ldw	r2,-12(fp)
    f100:	10801017 	ldw	r2,64(r2)
    f104:	1809883a 	mov	r4,r3
    f108:	e17ffe17 	ldw	r5,-8(fp)
    f10c:	100d883a 	mov	r6,r2
    f110:	00041f00 	call	41f0 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    f114:	e0bffd17 	ldw	r2,-12(fp)
    f118:	10c00317 	ldw	r3,12(r2)
    f11c:	e0bffd17 	ldw	r2,-12(fp)
    f120:	10801017 	ldw	r2,64(r2)
    f124:	0085c83a 	sub	r2,zero,r2
    f128:	1887883a 	add	r3,r3,r2
    f12c:	e0bffd17 	ldw	r2,-12(fp)
    f130:	10c00315 	stw	r3,12(r2)
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    f134:	e0bffd17 	ldw	r2,-12(fp)
    f138:	10c00317 	ldw	r3,12(r2)
    f13c:	e0bffd17 	ldw	r2,-12(fp)
    f140:	10800017 	ldw	r2,0(r2)
    f144:	1880082e 	bgeu	r3,r2,f168 <prvCopyDataToQueue+0x130>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    f148:	e0bffd17 	ldw	r2,-12(fp)
    f14c:	10c00117 	ldw	r3,4(r2)
    f150:	e0bffd17 	ldw	r2,-12(fp)
    f154:	10801017 	ldw	r2,64(r2)
    f158:	0085c83a 	sub	r2,zero,r2
    f15c:	1887883a 	add	r3,r3,r2
    f160:	e0bffd17 	ldw	r2,-12(fp)
    f164:	10c00315 	stw	r3,12(r2)
		}
	}

	++( pxQueue->uxMessagesWaiting );
    f168:	e0bffd17 	ldw	r2,-12(fp)
    f16c:	10800e17 	ldw	r2,56(r2)
    f170:	10c00044 	addi	r3,r2,1
    f174:	e0bffd17 	ldw	r2,-12(fp)
    f178:	10c00e15 	stw	r3,56(r2)
}
    f17c:	e037883a 	mov	sp,fp
    f180:	dfc00117 	ldw	ra,4(sp)
    f184:	df000017 	ldw	fp,0(sp)
    f188:	dec00204 	addi	sp,sp,8
    f18c:	f800283a 	ret

0000f190 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    f190:	defffc04 	addi	sp,sp,-16
    f194:	dfc00315 	stw	ra,12(sp)
    f198:	df000215 	stw	fp,8(sp)
    f19c:	df000204 	addi	fp,sp,8
    f1a0:	e13ffe15 	stw	r4,-8(fp)
    f1a4:	e17fff15 	stw	r5,-4(fp)
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    f1a8:	e0bffe17 	ldw	r2,-8(fp)
    f1ac:	10800017 	ldw	r2,0(r2)
    f1b0:	10001826 	beq	r2,zero,f214 <prvCopyDataFromQueue+0x84>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    f1b4:	e0bffe17 	ldw	r2,-8(fp)
    f1b8:	10c00317 	ldw	r3,12(r2)
    f1bc:	e0bffe17 	ldw	r2,-8(fp)
    f1c0:	10801017 	ldw	r2,64(r2)
    f1c4:	1887883a 	add	r3,r3,r2
    f1c8:	e0bffe17 	ldw	r2,-8(fp)
    f1cc:	10c00315 	stw	r3,12(r2)
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    f1d0:	e0bffe17 	ldw	r2,-8(fp)
    f1d4:	10c00317 	ldw	r3,12(r2)
    f1d8:	e0bffe17 	ldw	r2,-8(fp)
    f1dc:	10800117 	ldw	r2,4(r2)
    f1e0:	18800436 	bltu	r3,r2,f1f4 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    f1e4:	e0bffe17 	ldw	r2,-8(fp)
    f1e8:	10c00017 	ldw	r3,0(r2)
    f1ec:	e0bffe17 	ldw	r2,-8(fp)
    f1f0:	10c00315 	stw	r3,12(r2)
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    f1f4:	e0bffe17 	ldw	r2,-8(fp)
    f1f8:	10c00317 	ldw	r3,12(r2)
    f1fc:	e0bffe17 	ldw	r2,-8(fp)
    f200:	10801017 	ldw	r2,64(r2)
    f204:	e13fff17 	ldw	r4,-4(fp)
    f208:	180b883a 	mov	r5,r3
    f20c:	100d883a 	mov	r6,r2
    f210:	00041f00 	call	41f0 <memcpy>
	}
}
    f214:	e037883a 	mov	sp,fp
    f218:	dfc00117 	ldw	ra,4(sp)
    f21c:	df000017 	ldw	fp,0(sp)
    f220:	dec00204 	addi	sp,sp,8
    f224:	f800283a 	ret

0000f228 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    f228:	defffd04 	addi	sp,sp,-12
    f22c:	dfc00215 	stw	ra,8(sp)
    f230:	df000115 	stw	fp,4(sp)
    f234:	df000104 	addi	fp,sp,4
    f238:	e13fff15 	stw	r4,-4(fp)

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    f23c:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    f240:	10001126 	beq	r2,zero,f288 <prvUnlockQueue+0x60>
    f244:	00110d00 	call	110d0 <vTaskEnterCritical>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    f248:	00000f06 	br	f288 <prvUnlockQueue+0x60>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    f24c:	e0bfff17 	ldw	r2,-4(fp)
    f250:	10800917 	ldw	r2,36(r2)
    f254:	10001126 	beq	r2,zero,f29c <prvUnlockQueue+0x74>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    f258:	e0bfff17 	ldw	r2,-4(fp)
    f25c:	10800904 	addi	r2,r2,36
    f260:	1009883a 	mov	r4,r2
    f264:	00105ec0 	call	105ec <xTaskRemoveFromEventList>
    f268:	10000126 	beq	r2,zero,f270 <prvUnlockQueue+0x48>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    f26c:	00107f40 	call	107f4 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    f270:	e0bfff17 	ldw	r2,-4(fp)
    f274:	10801217 	ldw	r2,72(r2)
    f278:	10ffffc4 	addi	r3,r2,-1
    f27c:	e0bfff17 	ldw	r2,-4(fp)
    f280:	10c01215 	stw	r3,72(r2)
    f284:	00000106 	br	f28c <prvUnlockQueue+0x64>
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    f288:	0001883a 	nop
    f28c:	e0bfff17 	ldw	r2,-4(fp)
    f290:	10801217 	ldw	r2,72(r2)
    f294:	00bfed16 	blt	zero,r2,f24c <prvUnlockQueue+0x24>
    f298:	00000106 	br	f2a0 <prvUnlockQueue+0x78>

				--( pxQueue->xTxLock );
			}
			else
			{
				break;
    f29c:	0001883a 	nop
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    f2a0:	e0bfff17 	ldw	r2,-4(fp)
    f2a4:	00ffffc4 	movi	r3,-1
    f2a8:	10c01215 	stw	r3,72(r2)
	}
	taskEXIT_CRITICAL();
    f2ac:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    f2b0:	10000126 	beq	r2,zero,f2b8 <prvUnlockQueue+0x90>
    f2b4:	00111100 	call	11110 <vTaskExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    f2b8:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    f2bc:	10001126 	beq	r2,zero,f304 <prvUnlockQueue+0xdc>
    f2c0:	00110d00 	call	110d0 <vTaskEnterCritical>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    f2c4:	00000f06 	br	f304 <prvUnlockQueue+0xdc>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    f2c8:	e0bfff17 	ldw	r2,-4(fp)
    f2cc:	10800417 	ldw	r2,16(r2)
    f2d0:	10001126 	beq	r2,zero,f318 <prvUnlockQueue+0xf0>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    f2d4:	e0bfff17 	ldw	r2,-4(fp)
    f2d8:	10800404 	addi	r2,r2,16
    f2dc:	1009883a 	mov	r4,r2
    f2e0:	00105ec0 	call	105ec <xTaskRemoveFromEventList>
    f2e4:	10000126 	beq	r2,zero,f2ec <prvUnlockQueue+0xc4>
				{
					vTaskMissedYield();
    f2e8:	00107f40 	call	107f4 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    f2ec:	e0bfff17 	ldw	r2,-4(fp)
    f2f0:	10801117 	ldw	r2,68(r2)
    f2f4:	10ffffc4 	addi	r3,r2,-1
    f2f8:	e0bfff17 	ldw	r2,-4(fp)
    f2fc:	10c01115 	stw	r3,68(r2)
    f300:	00000106 	br	f308 <prvUnlockQueue+0xe0>
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    f304:	0001883a 	nop
    f308:	e0bfff17 	ldw	r2,-4(fp)
    f30c:	10801117 	ldw	r2,68(r2)
    f310:	00bfed16 	blt	zero,r2,f2c8 <prvUnlockQueue+0xa0>
    f314:	00000106 	br	f31c <prvUnlockQueue+0xf4>

				--( pxQueue->xRxLock );
			}
			else
			{
				break;
    f318:	0001883a 	nop
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    f31c:	e0bfff17 	ldw	r2,-4(fp)
    f320:	00ffffc4 	movi	r3,-1
    f324:	10c01115 	stw	r3,68(r2)
	}
	taskEXIT_CRITICAL();
    f328:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    f32c:	10000126 	beq	r2,zero,f334 <prvUnlockQueue+0x10c>
    f330:	00111100 	call	11110 <vTaskExitCritical>
}
    f334:	e037883a 	mov	sp,fp
    f338:	dfc00117 	ldw	ra,4(sp)
    f33c:	df000017 	ldw	fp,0(sp)
    f340:	dec00204 	addi	sp,sp,8
    f344:	f800283a 	ret

0000f348 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    f348:	defffc04 	addi	sp,sp,-16
    f34c:	dfc00315 	stw	ra,12(sp)
    f350:	df000215 	stw	fp,8(sp)
    f354:	df000204 	addi	fp,sp,8
    f358:	e13fff15 	stw	r4,-4(fp)
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    f35c:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    f360:	10000126 	beq	r2,zero,f368 <prvIsQueueEmpty+0x20>
    f364:	00110d00 	call	110d0 <vTaskEnterCritical>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    f368:	e0bfff17 	ldw	r2,-4(fp)
    f36c:	10800e17 	ldw	r2,56(r2)
    f370:	1005003a 	cmpeq	r2,r2,zero
    f374:	10803fcc 	andi	r2,r2,255
    f378:	e0bffe15 	stw	r2,-8(fp)
	taskEXIT_CRITICAL();
    f37c:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    f380:	10000126 	beq	r2,zero,f388 <prvIsQueueEmpty+0x40>
    f384:	00111100 	call	11110 <vTaskExitCritical>

	return xReturn;
    f388:	e0bffe17 	ldw	r2,-8(fp)
}
    f38c:	e037883a 	mov	sp,fp
    f390:	dfc00117 	ldw	ra,4(sp)
    f394:	df000017 	ldw	fp,0(sp)
    f398:	dec00204 	addi	sp,sp,8
    f39c:	f800283a 	ret

0000f3a0 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    f3a0:	defffd04 	addi	sp,sp,-12
    f3a4:	df000215 	stw	fp,8(sp)
    f3a8:	df000204 	addi	fp,sp,8
    f3ac:	e13fff15 	stw	r4,-4(fp)
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    f3b0:	e0bfff17 	ldw	r2,-4(fp)
    f3b4:	10800e17 	ldw	r2,56(r2)
    f3b8:	1005003a 	cmpeq	r2,r2,zero
    f3bc:	10803fcc 	andi	r2,r2,255
    f3c0:	e0bffe15 	stw	r2,-8(fp)

	return xReturn;
    f3c4:	e0bffe17 	ldw	r2,-8(fp)
}
    f3c8:	e037883a 	mov	sp,fp
    f3cc:	df000017 	ldw	fp,0(sp)
    f3d0:	dec00104 	addi	sp,sp,4
    f3d4:	f800283a 	ret

0000f3d8 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    f3d8:	defffc04 	addi	sp,sp,-16
    f3dc:	dfc00315 	stw	ra,12(sp)
    f3e0:	df000215 	stw	fp,8(sp)
    f3e4:	df000204 	addi	fp,sp,8
    f3e8:	e13fff15 	stw	r4,-4(fp)
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    f3ec:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    f3f0:	10000126 	beq	r2,zero,f3f8 <prvIsQueueFull+0x20>
    f3f4:	00110d00 	call	110d0 <vTaskEnterCritical>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    f3f8:	e0bfff17 	ldw	r2,-4(fp)
    f3fc:	10c00e17 	ldw	r3,56(r2)
    f400:	e0bfff17 	ldw	r2,-4(fp)
    f404:	10800f17 	ldw	r2,60(r2)
    f408:	1885003a 	cmpeq	r2,r3,r2
    f40c:	10803fcc 	andi	r2,r2,255
    f410:	e0bffe15 	stw	r2,-8(fp)
	taskEXIT_CRITICAL();
    f414:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    f418:	10000126 	beq	r2,zero,f420 <prvIsQueueFull+0x48>
    f41c:	00111100 	call	11110 <vTaskExitCritical>

	return xReturn;
    f420:	e0bffe17 	ldw	r2,-8(fp)
}
    f424:	e037883a 	mov	sp,fp
    f428:	dfc00117 	ldw	ra,4(sp)
    f42c:	df000017 	ldw	fp,0(sp)
    f430:	dec00204 	addi	sp,sp,8
    f434:	f800283a 	ret

0000f438 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    f438:	defffd04 	addi	sp,sp,-12
    f43c:	df000215 	stw	fp,8(sp)
    f440:	df000204 	addi	fp,sp,8
    f444:	e13fff15 	stw	r4,-4(fp)
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    f448:	e0bfff17 	ldw	r2,-4(fp)
    f44c:	10c00e17 	ldw	r3,56(r2)
    f450:	e0bfff17 	ldw	r2,-4(fp)
    f454:	10800f17 	ldw	r2,60(r2)
    f458:	1885003a 	cmpeq	r2,r3,r2
    f45c:	10803fcc 	andi	r2,r2,255
    f460:	e0bffe15 	stw	r2,-8(fp)

	return xReturn;
    f464:	e0bffe17 	ldw	r2,-8(fp)
}
    f468:	e037883a 	mov	sp,fp
    f46c:	df000017 	ldw	fp,0(sp)
    f470:	dec00104 	addi	sp,sp,4
    f474:	f800283a 	ret

0000f478 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vQueueWaitForMessageRestricted( xQueueHandle pxQueue, portTickType xTicksToWait )
	{
    f478:	defffc04 	addi	sp,sp,-16
    f47c:	dfc00315 	stw	ra,12(sp)
    f480:	df000215 	stw	fp,8(sp)
    f484:	df000204 	addi	fp,sp,8
    f488:	e13ffe15 	stw	r4,-8(fp)
    f48c:	e17fff15 	stw	r5,-4(fp)
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    f490:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    f494:	10000126 	beq	r2,zero,f49c <vQueueWaitForMessageRestricted+0x24>
    f498:	00110d00 	call	110d0 <vTaskEnterCritical>
    f49c:	e0bffe17 	ldw	r2,-8(fp)
    f4a0:	10801117 	ldw	r2,68(r2)
    f4a4:	10bfffd8 	cmpnei	r2,r2,-1
    f4a8:	1000021e 	bne	r2,zero,f4b4 <vQueueWaitForMessageRestricted+0x3c>
    f4ac:	e0bffe17 	ldw	r2,-8(fp)
    f4b0:	10001115 	stw	zero,68(r2)
    f4b4:	e0bffe17 	ldw	r2,-8(fp)
    f4b8:	10801217 	ldw	r2,72(r2)
    f4bc:	10bfffd8 	cmpnei	r2,r2,-1
    f4c0:	1000021e 	bne	r2,zero,f4cc <vQueueWaitForMessageRestricted+0x54>
    f4c4:	e0bffe17 	ldw	r2,-8(fp)
    f4c8:	10001215 	stw	zero,72(r2)
    f4cc:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    f4d0:	10000126 	beq	r2,zero,f4d8 <vQueueWaitForMessageRestricted+0x60>
    f4d4:	00111100 	call	11110 <vTaskExitCritical>
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
    f4d8:	e0bffe17 	ldw	r2,-8(fp)
    f4dc:	10800e17 	ldw	r2,56(r2)
    f4e0:	1000051e 	bne	r2,zero,f4f8 <vQueueWaitForMessageRestricted+0x80>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    f4e4:	e0bffe17 	ldw	r2,-8(fp)
    f4e8:	10800904 	addi	r2,r2,36
    f4ec:	1009883a 	mov	r4,r2
    f4f0:	e17fff17 	ldw	r5,-4(fp)
    f4f4:	00105840 	call	10584 <vTaskPlaceOnEventListRestricted>
		}
		prvUnlockQueue( pxQueue );
    f4f8:	e13ffe17 	ldw	r4,-8(fp)
    f4fc:	000f2280 	call	f228 <prvUnlockQueue>
	}
    f500:	e037883a 	mov	sp,fp
    f504:	dfc00117 	ldw	ra,4(sp)
    f508:	df000017 	ldw	fp,0(sp)
    f50c:	dec00204 	addi	sp,sp,8
    f510:	f800283a 	ret

0000f514 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    f514:	defff604 	addi	sp,sp,-40
    f518:	dfc00915 	stw	ra,36(sp)
    f51c:	df000815 	stw	fp,32(sp)
    f520:	df000804 	addi	fp,sp,32
    f524:	e13ffc15 	stw	r4,-16(fp)
    f528:	e17ffd15 	stw	r5,-12(fp)
    f52c:	3005883a 	mov	r2,r6
    f530:	e1ffff15 	stw	r7,-4(fp)
    f534:	e0bffe0d 	sth	r2,-8(fp)
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    f538:	e0bffe0b 	ldhu	r2,-8(fp)
    f53c:	1009883a 	mov	r4,r2
    f540:	e1400417 	ldw	r5,16(fp)
    f544:	0010b840 	call	10b84 <prvAllocateTCBAndStack>
    f548:	e0bffa15 	stw	r2,-24(fp)

	if( pxNewTCB != NULL )
    f54c:	e0bffa17 	ldw	r2,-24(fp)
    f550:	10005a26 	beq	r2,zero,f6bc <xTaskGenericCreate+0x1a8>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    f554:	e0bffa17 	ldw	r2,-24(fp)
    f558:	10c00c17 	ldw	r3,48(r2)
    f55c:	e0bffe0b 	ldhu	r2,-8(fp)
    f560:	10bfffc4 	addi	r2,r2,-1
    f564:	1085883a 	add	r2,r2,r2
    f568:	1085883a 	add	r2,r2,r2
    f56c:	1885883a 	add	r2,r3,r2
    f570:	e0bffb15 	stw	r2,-20(fp)
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) );
    f574:	e0fffb17 	ldw	r3,-20(fp)
    f578:	00bfff04 	movi	r2,-4
    f57c:	1884703a 	and	r2,r3,r2
    f580:	e0bffb15 	stw	r2,-20(fp)
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    f584:	e0bffe0b 	ldhu	r2,-8(fp)
    f588:	d8800015 	stw	r2,0(sp)
    f58c:	e13ffa17 	ldw	r4,-24(fp)
    f590:	e17ffd17 	ldw	r5,-12(fp)
    f594:	e1800217 	ldw	r6,8(fp)
    f598:	e1c00517 	ldw	r7,20(fp)
    f59c:	00108bc0 	call	108bc <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    f5a0:	e13ffb17 	ldw	r4,-20(fp)
    f5a4:	e17ffc17 	ldw	r5,-16(fp)
    f5a8:	e1bfff17 	ldw	r6,-4(fp)
    f5ac:	003c2640 	call	3c264 <pxPortInitialiseStack>
    f5b0:	e0fffa17 	ldw	r3,-24(fp)
    f5b4:	18800015 	stw	r2,0(r3)
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    f5b8:	e0800317 	ldw	r2,12(fp)
    f5bc:	10000326 	beq	r2,zero,f5cc <xTaskGenericCreate+0xb8>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    f5c0:	e0800317 	ldw	r2,12(fp)
    f5c4:	e0fffa17 	ldw	r3,-24(fp)
    f5c8:	10c00015 	stw	r3,0(r2)
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    f5cc:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    f5d0:	10000126 	beq	r2,zero,f5d8 <xTaskGenericCreate+0xc4>
    f5d4:	00110d00 	call	110d0 <vTaskEnterCritical>
		{
			uxCurrentNumberOfTasks++;
    f5d8:	d0a90b17 	ldw	r2,-23508(gp)
    f5dc:	10800044 	addi	r2,r2,1
    f5e0:	d0a90b15 	stw	r2,-23508(gp)
			if( pxCurrentTCB == NULL )
    f5e4:	d0a90717 	ldw	r2,-23524(gp)
    f5e8:	1000071e 	bne	r2,zero,f608 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    f5ec:	e0bffa17 	ldw	r2,-24(fp)
    f5f0:	d0a90715 	stw	r2,-23524(gp)

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    f5f4:	d0a90b17 	ldw	r2,-23508(gp)
    f5f8:	10800058 	cmpnei	r2,r2,1
    f5fc:	10000a1e 	bne	r2,zero,f628 <xTaskGenericCreate+0x114>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    f600:	00109980 	call	10998 <prvInitialiseTaskLists>
    f604:	00000806 	br	f628 <xTaskGenericCreate+0x114>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    f608:	d0a90f17 	ldw	r2,-23492(gp)
    f60c:	1000061e 	bne	r2,zero,f628 <xTaskGenericCreate+0x114>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    f610:	d0a90717 	ldw	r2,-23524(gp)
    f614:	10800b17 	ldw	r2,44(r2)
    f618:	e0c00217 	ldw	r3,8(fp)
    f61c:	18800236 	bltu	r3,r2,f628 <xTaskGenericCreate+0x114>
					{
						pxCurrentTCB = pxNewTCB;
    f620:	e0bffa17 	ldw	r2,-24(fp)
    f624:	d0a90715 	stw	r2,-23524(gp)
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    f628:	e0bffa17 	ldw	r2,-24(fp)
    f62c:	10800b17 	ldw	r2,44(r2)
    f630:	d0e90d17 	ldw	r3,-23500(gp)
    f634:	1880032e 	bgeu	r3,r2,f644 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    f638:	e0bffa17 	ldw	r2,-24(fp)
    f63c:	10800b17 	ldw	r2,44(r2)
    f640:	d0a90d15 	stw	r2,-23500(gp)
			}

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
    f644:	d0e91417 	ldw	r3,-23472(gp)
    f648:	e0bffa17 	ldw	r2,-24(fp)
    f64c:	10c01815 	stw	r3,96(r2)
			}
			#endif
			uxTaskNumber++;
    f650:	d0a91417 	ldw	r2,-23472(gp)
    f654:	10800044 	addi	r2,r2,1
    f658:	d0a91415 	stw	r2,-23472(gp)

			prvAddTaskToReadyQueue( pxNewTCB );
    f65c:	e0bffa17 	ldw	r2,-24(fp)
    f660:	10800b17 	ldw	r2,44(r2)
    f664:	d0e90e17 	ldw	r3,-23496(gp)
    f668:	1880032e 	bgeu	r3,r2,f678 <xTaskGenericCreate+0x164>
    f66c:	e0bffa17 	ldw	r2,-24(fp)
    f670:	10800b17 	ldw	r2,44(r2)
    f674:	d0a90e15 	stw	r2,-23496(gp)
    f678:	e0bffa17 	ldw	r2,-24(fp)
    f67c:	10800b17 	ldw	r2,44(r2)
    f680:	10c00524 	muli	r3,r2,20
    f684:	00800134 	movhi	r2,4
    f688:	109f1e04 	addi	r2,r2,31864
    f68c:	1887883a 	add	r3,r3,r2
    f690:	e0bffa17 	ldw	r2,-24(fp)
    f694:	10800104 	addi	r2,r2,4
    f698:	1809883a 	mov	r4,r3
    f69c:	100b883a 	mov	r5,r2
    f6a0:	003bf900 	call	3bf90 <vListInsertEnd>

			xReturn = pdPASS;
    f6a4:	00800044 	movi	r2,1
    f6a8:	e0bff915 	stw	r2,-28(fp)
			portSETUP_TCB( pxNewTCB );
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    f6ac:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    f6b0:	10000426 	beq	r2,zero,f6c4 <xTaskGenericCreate+0x1b0>
    f6b4:	00111100 	call	11110 <vTaskExitCritical>
    f6b8:	00000206 	br	f6c4 <xTaskGenericCreate+0x1b0>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    f6bc:	00bfffc4 	movi	r2,-1
    f6c0:	e0bff915 	stw	r2,-28(fp)
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    f6c4:	e0bff917 	ldw	r2,-28(fp)
    f6c8:	10800058 	cmpnei	r2,r2,1
    f6cc:	1000071e 	bne	r2,zero,f6ec <xTaskGenericCreate+0x1d8>
	{
		if( xSchedulerRunning != pdFALSE )
    f6d0:	d0a90f17 	ldw	r2,-23492(gp)
    f6d4:	10000526 	beq	r2,zero,f6ec <xTaskGenericCreate+0x1d8>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    f6d8:	d0a90717 	ldw	r2,-23524(gp)
    f6dc:	10c00b17 	ldw	r3,44(r2)
    f6e0:	e0800217 	ldw	r2,8(fp)
    f6e4:	1880012e 	bgeu	r3,r2,f6ec <xTaskGenericCreate+0x1d8>
			{
				portYIELD_WITHIN_API();
    f6e8:	003b683a 	trap	0
			}
		}
	}

	return xReturn;
    f6ec:	e0bff917 	ldw	r2,-28(fp)
}
    f6f0:	e037883a 	mov	sp,fp
    f6f4:	dfc00117 	ldw	ra,4(sp)
    f6f8:	df000017 	ldw	fp,0(sp)
    f6fc:	dec00204 	addi	sp,sp,8
    f700:	f800283a 	ret

0000f704 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    f704:	defffc04 	addi	sp,sp,-16
    f708:	dfc00315 	stw	ra,12(sp)
    f70c:	df000215 	stw	fp,8(sp)
    f710:	df000204 	addi	fp,sp,8
    f714:	e13fff15 	stw	r4,-4(fp)
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    f718:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    f71c:	10000126 	beq	r2,zero,f724 <vTaskDelete+0x20>
    f720:	00110d00 	call	110d0 <vTaskEnterCritical>
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    f724:	d0a90717 	ldw	r2,-23524(gp)
    f728:	e0ffff17 	ldw	r3,-4(fp)
    f72c:	1880011e 	bne	r3,r2,f734 <vTaskDelete+0x30>
			{
				pxTaskToDelete = NULL;
    f730:	e03fff15 	stw	zero,-4(fp)
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    f734:	e0bfff17 	ldw	r2,-4(fp)
    f738:	1000021e 	bne	r2,zero,f744 <vTaskDelete+0x40>
    f73c:	d0a90717 	ldw	r2,-23524(gp)
    f740:	00000106 	br	f748 <vTaskDelete+0x44>
    f744:	e0bfff17 	ldw	r2,-4(fp)
    f748:	e0bffe15 	stw	r2,-8(fp)

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    f74c:	e0bffe17 	ldw	r2,-8(fp)
    f750:	10800104 	addi	r2,r2,4
    f754:	1009883a 	mov	r4,r2
    f758:	003c0fc0 	call	3c0fc <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    f75c:	e0bffe17 	ldw	r2,-8(fp)
    f760:	10800a17 	ldw	r2,40(r2)
    f764:	10000426 	beq	r2,zero,f778 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    f768:	e0bffe17 	ldw	r2,-8(fp)
    f76c:	10800604 	addi	r2,r2,24
    f770:	1009883a 	mov	r4,r2
    f774:	003c0fc0 	call	3c0fc <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    f778:	e0bffe17 	ldw	r2,-8(fp)
    f77c:	10800104 	addi	r2,r2,4
    f780:	01000134 	movhi	r4,4
    f784:	211f4604 	addi	r4,r4,32024
    f788:	100b883a 	mov	r5,r2
    f78c:	003bf900 	call	3bf90 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    f790:	d0a90a17 	ldw	r2,-23512(gp)
    f794:	10800044 	addi	r2,r2,1
    f798:	d0a90a15 	stw	r2,-23512(gp)

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    f79c:	d0a91417 	ldw	r2,-23472(gp)
    f7a0:	10800044 	addi	r2,r2,1
    f7a4:	d0a91415 	stw	r2,-23472(gp)

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    f7a8:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    f7ac:	10000126 	beq	r2,zero,f7b4 <vTaskDelete+0xb0>
    f7b0:	00111100 	call	11110 <vTaskExitCritical>

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    f7b4:	d0a90f17 	ldw	r2,-23492(gp)
    f7b8:	10000326 	beq	r2,zero,f7c8 <vTaskDelete+0xc4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    f7bc:	e0bfff17 	ldw	r2,-4(fp)
    f7c0:	1000011e 	bne	r2,zero,f7c8 <vTaskDelete+0xc4>
			{
				portYIELD_WITHIN_API();
    f7c4:	003b683a 	trap	0
			}
		}
	}
    f7c8:	e037883a 	mov	sp,fp
    f7cc:	dfc00117 	ldw	ra,4(sp)
    f7d0:	df000017 	ldw	fp,0(sp)
    f7d4:	dec00204 	addi	sp,sp,8
    f7d8:	f800283a 	ret

0000f7dc <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    f7dc:	defff904 	addi	sp,sp,-28
    f7e0:	dfc00615 	stw	ra,24(sp)
    f7e4:	df000515 	stw	fp,20(sp)
    f7e8:	df000504 	addi	fp,sp,20
    f7ec:	e13ffe15 	stw	r4,-8(fp)
    f7f0:	e17fff15 	stw	r5,-4(fp)
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    f7f4:	e03ffb15 	stw	zero,-20(fp)

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    f7f8:	000fef80 	call	fef8 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    f7fc:	e0bffe17 	ldw	r2,-8(fp)
    f800:	10c00017 	ldw	r3,0(r2)
    f804:	e0bfff17 	ldw	r2,-4(fp)
    f808:	1885883a 	add	r2,r3,r2
    f80c:	e0bffc15 	stw	r2,-16(fp)

			if( xTickCount < *pxPreviousWakeTime )
    f810:	e0bffe17 	ldw	r2,-8(fp)
    f814:	10800017 	ldw	r2,0(r2)
    f818:	d0e90c17 	ldw	r3,-23504(gp)
    f81c:	18800a2e 	bgeu	r3,r2,f848 <vTaskDelayUntil+0x6c>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    f820:	e0bffe17 	ldw	r2,-8(fp)
    f824:	10800017 	ldw	r2,0(r2)
    f828:	e0fffc17 	ldw	r3,-16(fp)
    f82c:	18800f2e 	bgeu	r3,r2,f86c <vTaskDelayUntil+0x90>
    f830:	d0e90c17 	ldw	r3,-23504(gp)
    f834:	e0bffc17 	ldw	r2,-16(fp)
    f838:	18800c2e 	bgeu	r3,r2,f86c <vTaskDelayUntil+0x90>
				{
					xShouldDelay = pdTRUE;
    f83c:	00800044 	movi	r2,1
    f840:	e0bffb15 	stw	r2,-20(fp)
    f844:	00000906 	br	f86c <vTaskDelayUntil+0x90>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    f848:	e0bffe17 	ldw	r2,-8(fp)
    f84c:	10800017 	ldw	r2,0(r2)
    f850:	e0fffc17 	ldw	r3,-16(fp)
    f854:	18800336 	bltu	r3,r2,f864 <vTaskDelayUntil+0x88>
    f858:	d0e90c17 	ldw	r3,-23504(gp)
    f85c:	e0bffc17 	ldw	r2,-16(fp)
    f860:	1880022e 	bgeu	r3,r2,f86c <vTaskDelayUntil+0x90>
				{
					xShouldDelay = pdTRUE;
    f864:	00800044 	movi	r2,1
    f868:	e0bffb15 	stw	r2,-20(fp)
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    f86c:	e0bffe17 	ldw	r2,-8(fp)
    f870:	e0fffc17 	ldw	r3,-16(fp)
    f874:	10c00015 	stw	r3,0(r2)

			if( xShouldDelay != pdFALSE )
    f878:	e0bffb17 	ldw	r2,-20(fp)
    f87c:	10000626 	beq	r2,zero,f898 <vTaskDelayUntil+0xbc>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    f880:	d0a90717 	ldw	r2,-23524(gp)
    f884:	10800104 	addi	r2,r2,4
    f888:	1009883a 	mov	r4,r2
    f88c:	003c0fc0 	call	3c0fc <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    f890:	e13ffc17 	ldw	r4,-16(fp)
    f894:	0010afc0 	call	10afc <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    f898:	000ff200 	call	ff20 <xTaskResumeAll>
    f89c:	e0bffd15 	stw	r2,-12(fp)

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    f8a0:	e0bffd17 	ldw	r2,-12(fp)
    f8a4:	1000011e 	bne	r2,zero,f8ac <vTaskDelayUntil+0xd0>
		{
			portYIELD_WITHIN_API();
    f8a8:	003b683a 	trap	0
		}
	}
    f8ac:	e037883a 	mov	sp,fp
    f8b0:	dfc00117 	ldw	ra,4(sp)
    f8b4:	df000017 	ldw	fp,0(sp)
    f8b8:	dec00204 	addi	sp,sp,8
    f8bc:	f800283a 	ret

0000f8c0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    f8c0:	defffb04 	addi	sp,sp,-20
    f8c4:	dfc00415 	stw	ra,16(sp)
    f8c8:	df000315 	stw	fp,12(sp)
    f8cc:	df000304 	addi	fp,sp,12
    f8d0:	e13fff15 	stw	r4,-4(fp)
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    f8d4:	e03ffd15 	stw	zero,-12(fp)

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    f8d8:	e0bfff17 	ldw	r2,-4(fp)
    f8dc:	10000d26 	beq	r2,zero,f914 <vTaskDelay+0x54>
		{
			vTaskSuspendAll();
    f8e0:	000fef80 	call	fef8 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    f8e4:	d0e90c17 	ldw	r3,-23504(gp)
    f8e8:	e0bfff17 	ldw	r2,-4(fp)
    f8ec:	1885883a 	add	r2,r3,r2
    f8f0:	e0bffe15 	stw	r2,-8(fp)

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    f8f4:	d0a90717 	ldw	r2,-23524(gp)
    f8f8:	10800104 	addi	r2,r2,4
    f8fc:	1009883a 	mov	r4,r2
    f900:	003c0fc0 	call	3c0fc <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    f904:	e13ffe17 	ldw	r4,-8(fp)
    f908:	0010afc0 	call	10afc <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    f90c:	000ff200 	call	ff20 <xTaskResumeAll>
    f910:	e0bffd15 	stw	r2,-12(fp)
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    f914:	e0bffd17 	ldw	r2,-12(fp)
    f918:	1000011e 	bne	r2,zero,f920 <vTaskDelay+0x60>
		{
			portYIELD_WITHIN_API();
    f91c:	003b683a 	trap	0
		}
	}
    f920:	e037883a 	mov	sp,fp
    f924:	dfc00117 	ldw	ra,4(sp)
    f928:	df000017 	ldw	fp,0(sp)
    f92c:	dec00204 	addi	sp,sp,8
    f930:	f800283a 	ret

0000f934 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
	{
    f934:	defffb04 	addi	sp,sp,-20
    f938:	dfc00415 	stw	ra,16(sp)
    f93c:	df000315 	stw	fp,12(sp)
    f940:	df000304 	addi	fp,sp,12
    f944:	e13fff15 	stw	r4,-4(fp)
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxReturn;

		taskENTER_CRITICAL();
    f948:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    f94c:	10000126 	beq	r2,zero,f954 <uxTaskPriorityGet+0x20>
    f950:	00110d00 	call	110d0 <vTaskEnterCritical>
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    f954:	e0bfff17 	ldw	r2,-4(fp)
    f958:	1000021e 	bne	r2,zero,f964 <uxTaskPriorityGet+0x30>
    f95c:	d0a90717 	ldw	r2,-23524(gp)
    f960:	00000106 	br	f968 <uxTaskPriorityGet+0x34>
    f964:	e0bfff17 	ldw	r2,-4(fp)
    f968:	e0bffd15 	stw	r2,-12(fp)
			uxReturn = pxTCB->uxPriority;
    f96c:	e0bffd17 	ldw	r2,-12(fp)
    f970:	10800b17 	ldw	r2,44(r2)
    f974:	e0bffe15 	stw	r2,-8(fp)
		}
		taskEXIT_CRITICAL();
    f978:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    f97c:	10000126 	beq	r2,zero,f984 <uxTaskPriorityGet+0x50>
    f980:	00111100 	call	11110 <vTaskExitCritical>

		return uxReturn;
    f984:	e0bffe17 	ldw	r2,-8(fp)
	}
    f988:	e037883a 	mov	sp,fp
    f98c:	dfc00117 	ldw	ra,4(sp)
    f990:	df000017 	ldw	fp,0(sp)
    f994:	dec00204 	addi	sp,sp,8
    f998:	f800283a 	ret

0000f99c <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
	{
    f99c:	defff904 	addi	sp,sp,-28
    f9a0:	dfc00615 	stw	ra,24(sp)
    f9a4:	df000515 	stw	fp,20(sp)
    f9a8:	df000504 	addi	fp,sp,20
    f9ac:	e13ffe15 	stw	r4,-8(fp)
    f9b0:	e17fff15 	stw	r5,-4(fp)
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxCurrentPriority;
	portBASE_TYPE xYieldRequired = pdFALSE;
    f9b4:	e03ffb15 	stw	zero,-20(fp)

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= configMAX_PRIORITIES )
    f9b8:	e0bfff17 	ldw	r2,-4(fp)
    f9bc:	10800170 	cmpltui	r2,r2,5
    f9c0:	1000021e 	bne	r2,zero,f9cc <vTaskPrioritySet+0x30>
		{
			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    f9c4:	00800104 	movi	r2,4
    f9c8:	e0bfff15 	stw	r2,-4(fp)
		}

		taskENTER_CRITICAL();
    f9cc:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    f9d0:	10000126 	beq	r2,zero,f9d8 <vTaskPrioritySet+0x3c>
    f9d4:	00110d00 	call	110d0 <vTaskEnterCritical>
		{
			if( pxTask == pxCurrentTCB )
    f9d8:	d0a90717 	ldw	r2,-23524(gp)
    f9dc:	e0fffe17 	ldw	r3,-8(fp)
    f9e0:	1880011e 	bne	r3,r2,f9e8 <vTaskPrioritySet+0x4c>
			{
				pxTask = NULL;
    f9e4:	e03ffe15 	stw	zero,-8(fp)
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    f9e8:	e0bffe17 	ldw	r2,-8(fp)
    f9ec:	1000021e 	bne	r2,zero,f9f8 <vTaskPrioritySet+0x5c>
    f9f0:	d0a90717 	ldw	r2,-23524(gp)
    f9f4:	00000106 	br	f9fc <vTaskPrioritySet+0x60>
    f9f8:	e0bffe17 	ldw	r2,-8(fp)
    f9fc:	e0bffc15 	stw	r2,-16(fp)

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentPriority = pxTCB->uxBasePriority;
    fa00:	e0bffc17 	ldw	r2,-16(fp)
    fa04:	10801a17 	ldw	r2,104(r2)
    fa08:	e0bffd15 	stw	r2,-12(fp)
			{
				uxCurrentPriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentPriority != uxNewPriority )
    fa0c:	e0fffd17 	ldw	r3,-12(fp)
    fa10:	e0bfff17 	ldw	r2,-4(fp)
    fa14:	18803e26 	beq	r3,r2,fb10 <vTaskPrioritySet+0x174>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
    fa18:	e0bfff17 	ldw	r2,-4(fp)
    fa1c:	e0fffd17 	ldw	r3,-12(fp)
    fa20:	1880052e 	bgeu	r3,r2,fa38 <vTaskPrioritySet+0x9c>
				{
					if( pxTask != NULL )
    fa24:	e0bffe17 	ldw	r2,-8(fp)
    fa28:	10000726 	beq	r2,zero,fa48 <vTaskPrioritySet+0xac>
					{
						/* The priority of another task is being raised.  If we
						were raising the priority of the currently running task
						there would be no need to switch as it must have already
						been the highest priority task. */
						xYieldRequired = pdTRUE;
    fa2c:	00800044 	movi	r2,1
    fa30:	e0bffb15 	stw	r2,-20(fp)
    fa34:	00000406 	br	fa48 <vTaskPrioritySet+0xac>
					}
				}
				else if( pxTask == NULL )
    fa38:	e0bffe17 	ldw	r2,-8(fp)
    fa3c:	1000021e 	bne	r2,zero,fa48 <vTaskPrioritySet+0xac>
				{
					/* Setting our own priority down means there may now be another
					task of higher priority that is ready to execute. */
					xYieldRequired = pdTRUE;
    fa40:	00800044 	movi	r2,1
    fa44:	e0bffb15 	stw	r2,-20(fp)

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    fa48:	e0bffc17 	ldw	r2,-16(fp)
    fa4c:	10c01a17 	ldw	r3,104(r2)
    fa50:	e0bffc17 	ldw	r2,-16(fp)
    fa54:	10800b17 	ldw	r2,44(r2)
    fa58:	1880031e 	bne	r3,r2,fa68 <vTaskPrioritySet+0xcc>
					{
						pxTCB->uxPriority = uxNewPriority;
    fa5c:	e0bffc17 	ldw	r2,-16(fp)
    fa60:	e0ffff17 	ldw	r3,-4(fp)
    fa64:	10c00b15 	stw	r3,44(r2)
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
    fa68:	e0bffc17 	ldw	r2,-16(fp)
    fa6c:	e0ffff17 	ldw	r3,-4(fp)
    fa70:	10c01a15 	stw	r3,104(r2)
				{
					pxTCB->uxPriority = uxNewPriority;
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
    fa74:	00c00144 	movi	r3,5
    fa78:	e0bfff17 	ldw	r2,-4(fp)
    fa7c:	1887c83a 	sub	r3,r3,r2
    fa80:	e0bffc17 	ldw	r2,-16(fp)
    fa84:	10c00615 	stw	r3,24(r2)

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
    fa88:	e0bffc17 	ldw	r2,-16(fp)
    fa8c:	10c00517 	ldw	r3,20(r2)
    fa90:	e0bffd17 	ldw	r2,-12(fp)
    fa94:	11000524 	muli	r4,r2,20
    fa98:	00800134 	movhi	r2,4
    fa9c:	109f1e04 	addi	r2,r2,31864
    faa0:	2085883a 	add	r2,r4,r2
    faa4:	1880161e 	bne	r3,r2,fb00 <vTaskPrioritySet+0x164>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					vListRemove( &( pxTCB->xGenericListItem ) );
    faa8:	e0bffc17 	ldw	r2,-16(fp)
    faac:	10800104 	addi	r2,r2,4
    fab0:	1009883a 	mov	r4,r2
    fab4:	003c0fc0 	call	3c0fc <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    fab8:	e0bffc17 	ldw	r2,-16(fp)
    fabc:	10800b17 	ldw	r2,44(r2)
    fac0:	d0e90e17 	ldw	r3,-23496(gp)
    fac4:	1880032e 	bgeu	r3,r2,fad4 <vTaskPrioritySet+0x138>
    fac8:	e0bffc17 	ldw	r2,-16(fp)
    facc:	10800b17 	ldw	r2,44(r2)
    fad0:	d0a90e15 	stw	r2,-23496(gp)
    fad4:	e0bffc17 	ldw	r2,-16(fp)
    fad8:	10800b17 	ldw	r2,44(r2)
    fadc:	10c00524 	muli	r3,r2,20
    fae0:	00800134 	movhi	r2,4
    fae4:	109f1e04 	addi	r2,r2,31864
    fae8:	1887883a 	add	r3,r3,r2
    faec:	e0bffc17 	ldw	r2,-16(fp)
    faf0:	10800104 	addi	r2,r2,4
    faf4:	1809883a 	mov	r4,r3
    faf8:	100b883a 	mov	r5,r2
    fafc:	003bf900 	call	3bf90 <vListInsertEnd>
				}

				if( xYieldRequired == pdTRUE )
    fb00:	e0bffb17 	ldw	r2,-20(fp)
    fb04:	10800058 	cmpnei	r2,r2,1
    fb08:	1000011e 	bne	r2,zero,fb10 <vTaskPrioritySet+0x174>
				{
					portYIELD_WITHIN_API();
    fb0c:	003b683a 	trap	0
				}
			}
		}
		taskEXIT_CRITICAL();
    fb10:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    fb14:	10000126 	beq	r2,zero,fb1c <vTaskPrioritySet+0x180>
    fb18:	00111100 	call	11110 <vTaskExitCritical>
	}
    fb1c:	e037883a 	mov	sp,fp
    fb20:	dfc00117 	ldw	ra,4(sp)
    fb24:	df000017 	ldw	fp,0(sp)
    fb28:	dec00204 	addi	sp,sp,8
    fb2c:	f800283a 	ret

0000fb30 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
    fb30:	defffc04 	addi	sp,sp,-16
    fb34:	dfc00315 	stw	ra,12(sp)
    fb38:	df000215 	stw	fp,8(sp)
    fb3c:	df000204 	addi	fp,sp,8
    fb40:	e13fff15 	stw	r4,-4(fp)
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    fb44:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    fb48:	10000126 	beq	r2,zero,fb50 <vTaskSuspend+0x20>
    fb4c:	00110d00 	call	110d0 <vTaskEnterCritical>
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
    fb50:	d0a90717 	ldw	r2,-23524(gp)
    fb54:	e0ffff17 	ldw	r3,-4(fp)
    fb58:	1880011e 	bne	r3,r2,fb60 <vTaskSuspend+0x30>
			{
				pxTaskToSuspend = NULL;
    fb5c:	e03fff15 	stw	zero,-4(fp)
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    fb60:	e0bfff17 	ldw	r2,-4(fp)
    fb64:	1000021e 	bne	r2,zero,fb70 <vTaskSuspend+0x40>
    fb68:	d0a90717 	ldw	r2,-23524(gp)
    fb6c:	00000106 	br	fb74 <vTaskSuspend+0x44>
    fb70:	e0bfff17 	ldw	r2,-4(fp)
    fb74:	e0bffe15 	stw	r2,-8(fp)

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    fb78:	e0bffe17 	ldw	r2,-8(fp)
    fb7c:	10800104 	addi	r2,r2,4
    fb80:	1009883a 	mov	r4,r2
    fb84:	003c0fc0 	call	3c0fc <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    fb88:	e0bffe17 	ldw	r2,-8(fp)
    fb8c:	10800a17 	ldw	r2,40(r2)
    fb90:	10000426 	beq	r2,zero,fba4 <vTaskSuspend+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    fb94:	e0bffe17 	ldw	r2,-8(fp)
    fb98:	10800604 	addi	r2,r2,24
    fb9c:	1009883a 	mov	r4,r2
    fba0:	003c0fc0 	call	3c0fc <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    fba4:	e0bffe17 	ldw	r2,-8(fp)
    fba8:	10800104 	addi	r2,r2,4
    fbac:	01000134 	movhi	r4,4
    fbb0:	211f4b04 	addi	r4,r4,32044
    fbb4:	100b883a 	mov	r5,r2
    fbb8:	003bf900 	call	3bf90 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    fbbc:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    fbc0:	10000126 	beq	r2,zero,fbc8 <vTaskSuspend+0x98>
    fbc4:	00111100 	call	11110 <vTaskExitCritical>

		if( ( void * ) pxTaskToSuspend == NULL )
    fbc8:	e0bfff17 	ldw	r2,-4(fp)
    fbcc:	10000c1e 	bne	r2,zero,fc00 <vTaskSuspend+0xd0>
		{
			if( xSchedulerRunning != pdFALSE )
    fbd0:	d0a90f17 	ldw	r2,-23492(gp)
    fbd4:	10000226 	beq	r2,zero,fbe0 <vTaskSuspend+0xb0>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
    fbd8:	003b683a 	trap	0
    fbdc:	00000806 	br	fc00 <vTaskSuspend+0xd0>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    fbe0:	00800134 	movhi	r2,4
    fbe4:	109f4b04 	addi	r2,r2,32044
    fbe8:	10c00017 	ldw	r3,0(r2)
    fbec:	d0a90b17 	ldw	r2,-23508(gp)
    fbf0:	1880021e 	bne	r3,r2,fbfc <vTaskSuspend+0xcc>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    fbf4:	d0290715 	stw	zero,-23524(gp)
    fbf8:	00000106 	br	fc00 <vTaskSuspend+0xd0>
				}
				else
				{
					vTaskSwitchContext();
    fbfc:	00103c00 	call	103c0 <vTaskSwitchContext>
				}
			}
		}
	}
    fc00:	e037883a 	mov	sp,fp
    fc04:	dfc00117 	ldw	ra,4(sp)
    fc08:	df000017 	ldw	fp,0(sp)
    fc0c:	dec00204 	addi	sp,sp,8
    fc10:	f800283a 	ret

0000fc14 <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
    fc14:	defffc04 	addi	sp,sp,-16
    fc18:	df000315 	stw	fp,12(sp)
    fc1c:	df000304 	addi	fp,sp,12
    fc20:	e13fff15 	stw	r4,-4(fp)
	portBASE_TYPE xReturn = pdFALSE;
    fc24:	e03ffd15 	stw	zero,-12(fp)
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
    fc28:	e0bfff17 	ldw	r2,-4(fp)
    fc2c:	e0bffe15 	stw	r2,-8(fp)
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    fc30:	e0bffe17 	ldw	r2,-8(fp)
    fc34:	10c00517 	ldw	r3,20(r2)
    fc38:	00800134 	movhi	r2,4
    fc3c:	109f4b04 	addi	r2,r2,32044
    fc40:	18800a1e 	bne	r3,r2,fc6c <xTaskIsTaskSuspended+0x58>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    fc44:	e0bffe17 	ldw	r2,-8(fp)
    fc48:	10c00a17 	ldw	r3,40(r2)
    fc4c:	00800134 	movhi	r2,4
    fc50:	109f4104 	addi	r2,r2,32004
    fc54:	18800526 	beq	r3,r2,fc6c <xTaskIsTaskSuspended+0x58>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
    fc58:	e0bffe17 	ldw	r2,-8(fp)
    fc5c:	10800a17 	ldw	r2,40(r2)
    fc60:	1000021e 	bne	r2,zero,fc6c <xTaskIsTaskSuspended+0x58>
				{
					xReturn = pdTRUE;
    fc64:	00800044 	movi	r2,1
    fc68:	e0bffd15 	stw	r2,-12(fp)
				}
			}
		}

		return xReturn;
    fc6c:	e0bffd17 	ldw	r2,-12(fp)
	}
    fc70:	e037883a 	mov	sp,fp
    fc74:	df000017 	ldw	fp,0(sp)
    fc78:	dec00104 	addi	sp,sp,4
    fc7c:	f800283a 	ret

0000fc80 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
    fc80:	defffc04 	addi	sp,sp,-16
    fc84:	dfc00315 	stw	ra,12(sp)
    fc88:	df000215 	stw	fp,8(sp)
    fc8c:	df000204 	addi	fp,sp,8
    fc90:	e13fff15 	stw	r4,-4(fp)
		/* It does not make sense to resume the calling task. */
		configASSERT( pxTaskToResume );

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
    fc94:	e0bfff17 	ldw	r2,-4(fp)
    fc98:	e0bffe15 	stw	r2,-8(fp)

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    fc9c:	e0bffe17 	ldw	r2,-8(fp)
    fca0:	10002926 	beq	r2,zero,fd48 <vTaskResume+0xc8>
    fca4:	d0a90717 	ldw	r2,-23524(gp)
    fca8:	e0fffe17 	ldw	r3,-8(fp)
    fcac:	18802626 	beq	r3,r2,fd48 <vTaskResume+0xc8>
		{
			taskENTER_CRITICAL();
    fcb0:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    fcb4:	10000126 	beq	r2,zero,fcbc <vTaskResume+0x3c>
    fcb8:	00110d00 	call	110d0 <vTaskEnterCritical>
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    fcbc:	e13ffe17 	ldw	r4,-8(fp)
    fcc0:	000fc140 	call	fc14 <xTaskIsTaskSuspended>
    fcc4:	10800058 	cmpnei	r2,r2,1
    fcc8:	10001c1e 	bne	r2,zero,fd3c <vTaskResume+0xbc>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
    fccc:	e0bffe17 	ldw	r2,-8(fp)
    fcd0:	10800104 	addi	r2,r2,4
    fcd4:	1009883a 	mov	r4,r2
    fcd8:	003c0fc0 	call	3c0fc <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    fcdc:	e0bffe17 	ldw	r2,-8(fp)
    fce0:	10800b17 	ldw	r2,44(r2)
    fce4:	d0e90e17 	ldw	r3,-23496(gp)
    fce8:	1880032e 	bgeu	r3,r2,fcf8 <vTaskResume+0x78>
    fcec:	e0bffe17 	ldw	r2,-8(fp)
    fcf0:	10800b17 	ldw	r2,44(r2)
    fcf4:	d0a90e15 	stw	r2,-23496(gp)
    fcf8:	e0bffe17 	ldw	r2,-8(fp)
    fcfc:	10800b17 	ldw	r2,44(r2)
    fd00:	10c00524 	muli	r3,r2,20
    fd04:	00800134 	movhi	r2,4
    fd08:	109f1e04 	addi	r2,r2,31864
    fd0c:	1887883a 	add	r3,r3,r2
    fd10:	e0bffe17 	ldw	r2,-8(fp)
    fd14:	10800104 	addi	r2,r2,4
    fd18:	1809883a 	mov	r4,r3
    fd1c:	100b883a 	mov	r5,r2
    fd20:	003bf900 	call	3bf90 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    fd24:	e0bffe17 	ldw	r2,-8(fp)
    fd28:	10c00b17 	ldw	r3,44(r2)
    fd2c:	d0a90717 	ldw	r2,-23524(gp)
    fd30:	10800b17 	ldw	r2,44(r2)
    fd34:	18800136 	bltu	r3,r2,fd3c <vTaskResume+0xbc>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
    fd38:	003b683a 	trap	0
					}
				}
			}
			taskEXIT_CRITICAL();
    fd3c:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    fd40:	10000126 	beq	r2,zero,fd48 <vTaskResume+0xc8>
    fd44:	00111100 	call	11110 <vTaskExitCritical>
		}
	}
    fd48:	e037883a 	mov	sp,fp
    fd4c:	dfc00117 	ldw	ra,4(sp)
    fd50:	df000017 	ldw	fp,0(sp)
    fd54:	dec00204 	addi	sp,sp,8
    fd58:	f800283a 	ret

0000fd5c <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
    fd5c:	defffa04 	addi	sp,sp,-24
    fd60:	dfc00515 	stw	ra,20(sp)
    fd64:	df000415 	stw	fp,16(sp)
    fd68:	df000404 	addi	fp,sp,16
    fd6c:	e13fff15 	stw	r4,-4(fp)
	portBASE_TYPE xYieldRequired = pdFALSE;
    fd70:	e03ffc15 	stw	zero,-16(fp)
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxSavedInterruptStatus;

		configASSERT( pxTaskToResume );

		pxTCB = ( tskTCB * ) pxTaskToResume;
    fd74:	e0bfff17 	ldw	r2,-4(fp)
    fd78:	e0bffd15 	stw	r2,-12(fp)

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    fd7c:	e03ffe15 	stw	zero,-8(fp)
		{
			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    fd80:	e13ffd17 	ldw	r4,-12(fp)
    fd84:	000fc140 	call	fc14 <xTaskIsTaskSuspended>
    fd88:	10800058 	cmpnei	r2,r2,1
    fd8c:	1000261e 	bne	r2,zero,fe28 <xTaskResumeFromISR+0xcc>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    fd90:	d0a91017 	ldw	r2,-23488(gp)
    fd94:	10001e1e 	bne	r2,zero,fe10 <xTaskResumeFromISR+0xb4>
				{
					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    fd98:	e0bffd17 	ldw	r2,-12(fp)
    fd9c:	10c00b17 	ldw	r3,44(r2)
    fda0:	d0a90717 	ldw	r2,-23524(gp)
    fda4:	10800b17 	ldw	r2,44(r2)
    fda8:	1885403a 	cmpgeu	r2,r3,r2
    fdac:	10803fcc 	andi	r2,r2,255
    fdb0:	e0bffc15 	stw	r2,-16(fp)
					vListRemove(  &( pxTCB->xGenericListItem ) );
    fdb4:	e0bffd17 	ldw	r2,-12(fp)
    fdb8:	10800104 	addi	r2,r2,4
    fdbc:	1009883a 	mov	r4,r2
    fdc0:	003c0fc0 	call	3c0fc <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    fdc4:	e0bffd17 	ldw	r2,-12(fp)
    fdc8:	10800b17 	ldw	r2,44(r2)
    fdcc:	d0e90e17 	ldw	r3,-23496(gp)
    fdd0:	1880032e 	bgeu	r3,r2,fde0 <xTaskResumeFromISR+0x84>
    fdd4:	e0bffd17 	ldw	r2,-12(fp)
    fdd8:	10800b17 	ldw	r2,44(r2)
    fddc:	d0a90e15 	stw	r2,-23496(gp)
    fde0:	e0bffd17 	ldw	r2,-12(fp)
    fde4:	10800b17 	ldw	r2,44(r2)
    fde8:	10c00524 	muli	r3,r2,20
    fdec:	00800134 	movhi	r2,4
    fdf0:	109f1e04 	addi	r2,r2,31864
    fdf4:	1887883a 	add	r3,r3,r2
    fdf8:	e0bffd17 	ldw	r2,-12(fp)
    fdfc:	10800104 	addi	r2,r2,4
    fe00:	1809883a 	mov	r4,r3
    fe04:	100b883a 	mov	r5,r2
    fe08:	003bf900 	call	3bf90 <vListInsertEnd>
    fe0c:	00000606 	br	fe28 <xTaskResumeFromISR+0xcc>
				else
				{
					/* We cannot access the delayed or ready lists, so will hold this
					task pending until the scheduler is resumed, at which point a
					yield will be performed if necessary. */
					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    fe10:	e0bffd17 	ldw	r2,-12(fp)
    fe14:	10800604 	addi	r2,r2,24
    fe18:	01000134 	movhi	r4,4
    fe1c:	211f4104 	addi	r4,r4,32004
    fe20:	100b883a 	mov	r5,r2
    fe24:	003bf900 	call	3bf90 <vListInsertEnd>
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    fe28:	e0bffc17 	ldw	r2,-16(fp)
	}
    fe2c:	e037883a 	mov	sp,fp
    fe30:	dfc00117 	ldw	ra,4(sp)
    fe34:	df000017 	ldw	fp,0(sp)
    fe38:	dec00204 	addi	sp,sp,8
    fe3c:	f800283a 	ret

0000fe40 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    fe40:	defff904 	addi	sp,sp,-28
    fe44:	dfc00615 	stw	ra,24(sp)
    fe48:	df000515 	stw	fp,20(sp)
    fe4c:	df000504 	addi	fp,sp,20
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    fe50:	d8000015 	stw	zero,0(sp)
    fe54:	d8000115 	stw	zero,4(sp)
    fe58:	d8000215 	stw	zero,8(sp)
    fe5c:	d8000315 	stw	zero,12(sp)
    fe60:	01000074 	movhi	r4,1
    fe64:	21022804 	addi	r4,r4,2208
    fe68:	01400134 	movhi	r5,4
    fe6c:	29426804 	addi	r5,r5,2464
    fe70:	018c9604 	movi	r6,12888
    fe74:	000f883a 	mov	r7,zero
    fe78:	000f5140 	call	f514 <xTaskGenericCreate>
    fe7c:	e0bfff15 	stw	r2,-4(fp)
	}
	#endif

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
    fe80:	e0bfff17 	ldw	r2,-4(fp)
    fe84:	10800058 	cmpnei	r2,r2,1
    fe88:	1000021e 	bne	r2,zero,fe94 <vTaskStartScheduler+0x54>
		{
			xReturn = xTimerCreateTimerTask();
    fe8c:	00111680 	call	11168 <xTimerCreateTimerTask>
    fe90:	e0bfff15 	stw	r2,-4(fp)
		}
	}
	#endif

	if( xReturn == pdPASS )
    fe94:	e0bfff17 	ldw	r2,-4(fp)
    fe98:	10800058 	cmpnei	r2,r2,1
    fe9c:	1000051e 	bne	r2,zero,feb4 <vTaskStartScheduler+0x74>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    fea0:	003c1b40 	call	3c1b4 <enh_alt_irq_disable_all>

		xSchedulerRunning = pdTRUE;
    fea4:	00800044 	movi	r2,1
    fea8:	d0a90f15 	stw	r2,-23492(gp)
		xTickCount = ( portTickType ) 0U;
    feac:	d0290c15 	stw	zero,-23504(gp)
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    feb0:	003c3540 	call	3c354 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    feb4:	e037883a 	mov	sp,fp
    feb8:	dfc00117 	ldw	ra,4(sp)
    febc:	df000017 	ldw	fp,0(sp)
    fec0:	dec00204 	addi	sp,sp,8
    fec4:	f800283a 	ret

0000fec8 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    fec8:	defffe04 	addi	sp,sp,-8
    fecc:	dfc00115 	stw	ra,4(sp)
    fed0:	df000015 	stw	fp,0(sp)
    fed4:	d839883a 	mov	fp,sp
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    fed8:	003c1b40 	call	3c1b4 <enh_alt_irq_disable_all>
	xSchedulerRunning = pdFALSE;
    fedc:	d0290f15 	stw	zero,-23492(gp)
	vPortEndScheduler();
    fee0:	003c3800 	call	3c380 <vPortEndScheduler>
}
    fee4:	e037883a 	mov	sp,fp
    fee8:	dfc00117 	ldw	ra,4(sp)
    feec:	df000017 	ldw	fp,0(sp)
    fef0:	dec00204 	addi	sp,sp,8
    fef4:	f800283a 	ret

0000fef8 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    fef8:	deffff04 	addi	sp,sp,-4
    fefc:	df000015 	stw	fp,0(sp)
    ff00:	d839883a 	mov	fp,sp
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    ff04:	d0a91017 	ldw	r2,-23488(gp)
    ff08:	10800044 	addi	r2,r2,1
    ff0c:	d0a91015 	stw	r2,-23488(gp)
}
    ff10:	e037883a 	mov	sp,fp
    ff14:	df000017 	ldw	fp,0(sp)
    ff18:	dec00104 	addi	sp,sp,4
    ff1c:	f800283a 	ret

0000ff20 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    ff20:	defffb04 	addi	sp,sp,-20
    ff24:	dfc00415 	stw	ra,16(sp)
    ff28:	df000315 	stw	fp,12(sp)
    ff2c:	dc000215 	stw	r16,8(sp)
    ff30:	df000204 	addi	fp,sp,8
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    ff34:	e03ffe15 	stw	zero,-8(fp)
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    ff38:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
    ff3c:	10000126 	beq	r2,zero,ff44 <xTaskResumeAll+0x24>
    ff40:	00110d00 	call	110d0 <vTaskEnterCritical>
	{
		--uxSchedulerSuspended;
    ff44:	d0a91017 	ldw	r2,-23488(gp)
    ff48:	10bfffc4 	addi	r2,r2,-1
    ff4c:	d0a91015 	stw	r2,-23488(gp)

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    ff50:	d0a91017 	ldw	r2,-23488(gp)
    ff54:	10003b1e 	bne	r2,zero,10044 <xTaskResumeAll+0x124>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    ff58:	d0a90b17 	ldw	r2,-23508(gp)
    ff5c:	10003926 	beq	r2,zero,10044 <xTaskResumeAll+0x124>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    ff60:	e03fff15 	stw	zero,-4(fp)

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    ff64:	00001e06 	br	ffe0 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    ff68:	00800134 	movhi	r2,4
    ff6c:	109f4104 	addi	r2,r2,32004
    ff70:	10800317 	ldw	r2,12(r2)
    ff74:	14000317 	ldw	r16,12(r2)
					vListRemove( &( pxTCB->xEventListItem ) );
    ff78:	80800604 	addi	r2,r16,24
    ff7c:	1009883a 	mov	r4,r2
    ff80:	003c0fc0 	call	3c0fc <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    ff84:	80800104 	addi	r2,r16,4
    ff88:	1009883a 	mov	r4,r2
    ff8c:	003c0fc0 	call	3c0fc <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    ff90:	80800b17 	ldw	r2,44(r16)
    ff94:	d0e90e17 	ldw	r3,-23496(gp)
    ff98:	1880022e 	bgeu	r3,r2,ffa4 <xTaskResumeAll+0x84>
    ff9c:	80800b17 	ldw	r2,44(r16)
    ffa0:	d0a90e15 	stw	r2,-23496(gp)
    ffa4:	80800b17 	ldw	r2,44(r16)
    ffa8:	10c00524 	muli	r3,r2,20
    ffac:	00800134 	movhi	r2,4
    ffb0:	109f1e04 	addi	r2,r2,31864
    ffb4:	1887883a 	add	r3,r3,r2
    ffb8:	80800104 	addi	r2,r16,4
    ffbc:	1809883a 	mov	r4,r3
    ffc0:	100b883a 	mov	r5,r2
    ffc4:	003bf900 	call	3bf90 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    ffc8:	80c00b17 	ldw	r3,44(r16)
    ffcc:	d0a90717 	ldw	r2,-23524(gp)
    ffd0:	10800b17 	ldw	r2,44(r2)
    ffd4:	18800236 	bltu	r3,r2,ffe0 <xTaskResumeAll+0xc0>
					{
						xYieldRequired = pdTRUE;
    ffd8:	00800044 	movi	r2,1
    ffdc:	e0bfff15 	stw	r2,-4(fp)
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    ffe0:	00800134 	movhi	r2,4
    ffe4:	109f4104 	addi	r2,r2,32004
    ffe8:	10800017 	ldw	r2,0(r2)
    ffec:	103fde1e 	bne	r2,zero,ff68 <xTaskResumeAll+0x48>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    fff0:	d0a91117 	ldw	r2,-23484(gp)
    fff4:	10000926 	beq	r2,zero,1001c <xTaskResumeAll+0xfc>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    fff8:	00000406 	br	1000c <xTaskResumeAll+0xec>
					{
						vTaskIncrementTick();
    fffc:	001024c0 	call	1024c <vTaskIncrementTick>
						--uxMissedTicks;
   10000:	d0a91117 	ldw	r2,-23484(gp)
   10004:	10bfffc4 	addi	r2,r2,-1
   10008:	d0a91115 	stw	r2,-23484(gp)
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
   1000c:	d0a91117 	ldw	r2,-23484(gp)
   10010:	103ffa1e 	bne	r2,zero,fffc <xTaskResumeAll+0xdc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
   10014:	00800044 	movi	r2,1
   10018:	e0bfff15 	stw	r2,-4(fp)
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
   1001c:	e0bfff17 	ldw	r2,-4(fp)
   10020:	10800060 	cmpeqi	r2,r2,1
   10024:	1000031e 	bne	r2,zero,10034 <xTaskResumeAll+0x114>
   10028:	d0a91217 	ldw	r2,-23480(gp)
   1002c:	10800058 	cmpnei	r2,r2,1
   10030:	1000041e 	bne	r2,zero,10044 <xTaskResumeAll+0x124>
				{
					xAlreadyYielded = pdTRUE;
   10034:	00800044 	movi	r2,1
   10038:	e0bffe15 	stw	r2,-8(fp)
					xMissedYield = pdFALSE;
   1003c:	d0291215 	stw	zero,-23480(gp)
					portYIELD_WITHIN_API();
   10040:	003b683a 	trap	0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
   10044:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   10048:	10000126 	beq	r2,zero,10050 <xTaskResumeAll+0x130>
   1004c:	00111100 	call	11110 <vTaskExitCritical>

	return xAlreadyYielded;
   10050:	e0bffe17 	ldw	r2,-8(fp)
}
   10054:	e037883a 	mov	sp,fp
   10058:	dfc00217 	ldw	ra,8(sp)
   1005c:	df000117 	ldw	fp,4(sp)
   10060:	dc000017 	ldw	r16,0(sp)
   10064:	dec00304 	addi	sp,sp,12
   10068:	f800283a 	ret

0001006c <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
   1006c:	defffd04 	addi	sp,sp,-12
   10070:	dfc00215 	stw	ra,8(sp)
   10074:	df000115 	stw	fp,4(sp)
   10078:	df000104 	addi	fp,sp,4
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
   1007c:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   10080:	10000126 	beq	r2,zero,10088 <xTaskGetTickCount+0x1c>
   10084:	00110d00 	call	110d0 <vTaskEnterCritical>
	{
		xTicks = xTickCount;
   10088:	d0a90c17 	ldw	r2,-23504(gp)
   1008c:	e0bfff15 	stw	r2,-4(fp)
	}
	taskEXIT_CRITICAL();
   10090:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   10094:	10000126 	beq	r2,zero,1009c <xTaskGetTickCount+0x30>
   10098:	00111100 	call	11110 <vTaskExitCritical>

	return xTicks;
   1009c:	e0bfff17 	ldw	r2,-4(fp)
}
   100a0:	e037883a 	mov	sp,fp
   100a4:	dfc00117 	ldw	ra,4(sp)
   100a8:	df000017 	ldw	fp,0(sp)
   100ac:	dec00204 	addi	sp,sp,8
   100b0:	f800283a 	ret

000100b4 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
   100b4:	defffd04 	addi	sp,sp,-12
   100b8:	df000215 	stw	fp,8(sp)
   100bc:	df000204 	addi	fp,sp,8
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   100c0:	e03ffe15 	stw	zero,-8(fp)
	xReturn = xTickCount;
   100c4:	d0a90c17 	ldw	r2,-23504(gp)
   100c8:	e0bfff15 	stw	r2,-4(fp)
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
   100cc:	e0bfff17 	ldw	r2,-4(fp)
}
   100d0:	e037883a 	mov	sp,fp
   100d4:	df000017 	ldw	fp,0(sp)
   100d8:	dec00104 	addi	sp,sp,4
   100dc:	f800283a 	ret

000100e0 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
   100e0:	deffff04 	addi	sp,sp,-4
   100e4:	df000015 	stw	fp,0(sp)
   100e8:	d839883a 	mov	fp,sp
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
   100ec:	d0a90b17 	ldw	r2,-23508(gp)
}
   100f0:	e037883a 	mov	sp,fp
   100f4:	df000017 	ldw	fp,0(sp)
   100f8:	dec00104 	addi	sp,sp,4
   100fc:	f800283a 	ret

00010100 <vTaskList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTaskList( signed char *pcWriteBuffer )
	{
   10100:	defffb04 	addi	sp,sp,-20
   10104:	dfc00415 	stw	ra,16(sp)
   10108:	df000315 	stw	fp,12(sp)
   1010c:	dc000215 	stw	r16,8(sp)
   10110:	df000204 	addi	fp,sp,8
   10114:	e13fff15 	stw	r4,-4(fp)
	unsigned portBASE_TYPE uxQueue;

		/* This is a VERY costly function that should be used for debug only.
		It leaves interrupts disabled for a LONG time. */

		vTaskSuspendAll();
   10118:	000fef80 	call	fef8 <vTaskSuspendAll>
		{
			/* Run through all the lists that could potentially contain a TCB and
			report the task name, state and stack high water mark. */

			*pcWriteBuffer = ( signed char ) 0x00;
   1011c:	e0bfff17 	ldw	r2,-4(fp)
   10120:	10000005 	stb	zero,0(r2)
			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
   10124:	e43fff17 	ldw	r16,-4(fp)
   10128:	8009883a 	mov	r4,r16
   1012c:	0004d9c0 	call	4d9c <strlen>
   10130:	8085883a 	add	r2,r16,r2
   10134:	00c00344 	movi	r3,13
   10138:	10c00005 	stb	r3,0(r2)
   1013c:	00c00284 	movi	r3,10
   10140:	10c00045 	stb	r3,1(r2)
   10144:	10000085 	stb	zero,2(r2)

			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
   10148:	d0a90d17 	ldw	r2,-23500(gp)
   1014c:	10800044 	addi	r2,r2,1
   10150:	e0bffe15 	stw	r2,-8(fp)

			do
			{
				uxQueue--;
   10154:	e0bffe17 	ldw	r2,-8(fp)
   10158:	10bfffc4 	addi	r2,r2,-1
   1015c:	e0bffe15 	stw	r2,-8(fp)

				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
   10160:	00c00134 	movhi	r3,4
   10164:	18df1e04 	addi	r3,r3,31864
   10168:	e0bffe17 	ldw	r2,-8(fp)
   1016c:	10800524 	muli	r2,r2,20
   10170:	1885883a 	add	r2,r3,r2
   10174:	10800017 	ldw	r2,0(r2)
   10178:	10000926 	beq	r2,zero,101a0 <vTaskList+0xa0>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tskREADY_CHAR );
   1017c:	e0bffe17 	ldw	r2,-8(fp)
   10180:	10c00524 	muli	r3,r2,20
   10184:	00800134 	movhi	r2,4
   10188:	109f1e04 	addi	r2,r2,31864
   1018c:	1885883a 	add	r2,r3,r2
   10190:	e13fff17 	ldw	r4,-4(fp)
   10194:	100b883a 	mov	r5,r2
   10198:	01801484 	movi	r6,82
   1019c:	0010c380 	call	10c38 <prvListTaskWithinSingleList>
				}
			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
   101a0:	e0bffe17 	ldw	r2,-8(fp)
   101a4:	103feb1e 	bne	r2,zero,10154 <vTaskList+0x54>

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
   101a8:	d0a90817 	ldw	r2,-23520(gp)
   101ac:	10800017 	ldw	r2,0(r2)
   101b0:	10000526 	beq	r2,zero,101c8 <vTaskList+0xc8>
			{
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
   101b4:	d0a90817 	ldw	r2,-23520(gp)
   101b8:	e13fff17 	ldw	r4,-4(fp)
   101bc:	100b883a 	mov	r5,r2
   101c0:	01801084 	movi	r6,66
   101c4:	0010c380 	call	10c38 <prvListTaskWithinSingleList>
			}

			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
   101c8:	d0a90917 	ldw	r2,-23516(gp)
   101cc:	10800017 	ldw	r2,0(r2)
   101d0:	10000526 	beq	r2,zero,101e8 <vTaskList+0xe8>
			{
				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_CHAR );
   101d4:	d0a90917 	ldw	r2,-23516(gp)
   101d8:	e13fff17 	ldw	r4,-4(fp)
   101dc:	100b883a 	mov	r5,r2
   101e0:	01801084 	movi	r6,66
   101e4:	0010c380 	call	10c38 <prvListTaskWithinSingleList>
			}

			#if( INCLUDE_vTaskDelete == 1 )
			{
				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
   101e8:	00800134 	movhi	r2,4
   101ec:	109f4604 	addi	r2,r2,32024
   101f0:	10800017 	ldw	r2,0(r2)
   101f4:	10000526 	beq	r2,zero,1020c <vTaskList+0x10c>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, &xTasksWaitingTermination, tskDELETED_CHAR );
   101f8:	e13fff17 	ldw	r4,-4(fp)
   101fc:	01400134 	movhi	r5,4
   10200:	295f4604 	addi	r5,r5,32024
   10204:	01801104 	movi	r6,68
   10208:	0010c380 	call	10c38 <prvListTaskWithinSingleList>
			}
			#endif

			#if ( INCLUDE_vTaskSuspend == 1 )
			{
				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
   1020c:	00800134 	movhi	r2,4
   10210:	109f4b04 	addi	r2,r2,32044
   10214:	10800017 	ldw	r2,0(r2)
   10218:	10000526 	beq	r2,zero,10230 <vTaskList+0x130>
				{
					prvListTaskWithinSingleList( pcWriteBuffer, &xSuspendedTaskList, tskSUSPENDED_CHAR );
   1021c:	e13fff17 	ldw	r4,-4(fp)
   10220:	01400134 	movhi	r5,4
   10224:	295f4b04 	addi	r5,r5,32044
   10228:	018014c4 	movi	r6,83
   1022c:	0010c380 	call	10c38 <prvListTaskWithinSingleList>
				}
			}
			#endif
		}
		xTaskResumeAll();
   10230:	000ff200 	call	ff20 <xTaskResumeAll>
	}
   10234:	e037883a 	mov	sp,fp
   10238:	dfc00217 	ldw	ra,8(sp)
   1023c:	df000117 	ldw	fp,4(sp)
   10240:	dc000017 	ldw	r16,0(sp)
   10244:	dec00304 	addi	sp,sp,12
   10248:	f800283a 	ret

0001024c <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
   1024c:	defffb04 	addi	sp,sp,-20
   10250:	dfc00415 	stw	ra,16(sp)
   10254:	df000315 	stw	fp,12(sp)
   10258:	df000304 	addi	fp,sp,12
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   1025c:	d0a91017 	ldw	r2,-23488(gp)
   10260:	10004f1e 	bne	r2,zero,103a0 <vTaskIncrementTick+0x154>
	{
		++xTickCount;
   10264:	d0a90c17 	ldw	r2,-23504(gp)
   10268:	10800044 	addi	r2,r2,1
   1026c:	d0a90c15 	stw	r2,-23504(gp)
		if( xTickCount == ( portTickType ) 0U )
   10270:	d0a90c17 	ldw	r2,-23504(gp)
   10274:	1000161e 	bne	r2,zero,102d0 <vTaskIncrementTick+0x84>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
   10278:	d0a90817 	ldw	r2,-23520(gp)
   1027c:	e0bffd15 	stw	r2,-12(fp)
			pxDelayedTaskList = pxOverflowDelayedTaskList;
   10280:	d0a90917 	ldw	r2,-23516(gp)
   10284:	d0a90815 	stw	r2,-23520(gp)
			pxOverflowDelayedTaskList = pxTemp;
   10288:	e0bffd17 	ldw	r2,-12(fp)
   1028c:	d0a90915 	stw	r2,-23516(gp)
			xNumOfOverflows++;
   10290:	d0a91317 	ldw	r2,-23476(gp)
   10294:	10800044 	addi	r2,r2,1
   10298:	d0a91315 	stw	r2,-23476(gp)
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   1029c:	d0a90817 	ldw	r2,-23520(gp)
   102a0:	10800017 	ldw	r2,0(r2)
   102a4:	1000031e 	bne	r2,zero,102b4 <vTaskIncrementTick+0x68>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
   102a8:	00bfffc4 	movi	r2,-1
   102ac:	d0a00715 	stw	r2,-32740(gp)
   102b0:	00000706 	br	102d0 <vTaskIncrementTick+0x84>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   102b4:	d0a90817 	ldw	r2,-23520(gp)
   102b8:	10800317 	ldw	r2,12(r2)
   102bc:	10800317 	ldw	r2,12(r2)
   102c0:	e0bffe15 	stw	r2,-8(fp)
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
   102c4:	e0bffe17 	ldw	r2,-8(fp)
   102c8:	10800117 	ldw	r2,4(r2)
   102cc:	d0a00715 	stw	r2,-32740(gp)
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
   102d0:	d0e90c17 	ldw	r3,-23504(gp)
   102d4:	d0a00717 	ldw	r2,-32740(gp)
   102d8:	18803436 	bltu	r3,r2,103ac <vTaskIncrementTick+0x160>
   102dc:	d0a90817 	ldw	r2,-23520(gp)
   102e0:	10800017 	ldw	r2,0(r2)
   102e4:	1000031e 	bne	r2,zero,102f4 <vTaskIncrementTick+0xa8>
   102e8:	00bfffc4 	movi	r2,-1
   102ec:	d0a00715 	stw	r2,-32740(gp)
   102f0:	00002e06 	br	103ac <vTaskIncrementTick+0x160>
   102f4:	d0a90817 	ldw	r2,-23520(gp)
   102f8:	10800317 	ldw	r2,12(r2)
   102fc:	10800317 	ldw	r2,12(r2)
   10300:	e0bffe15 	stw	r2,-8(fp)
   10304:	e0bffe17 	ldw	r2,-8(fp)
   10308:	10800117 	ldw	r2,4(r2)
   1030c:	e0bfff15 	stw	r2,-4(fp)
   10310:	d0e90c17 	ldw	r3,-23504(gp)
   10314:	e0bfff17 	ldw	r2,-4(fp)
   10318:	1880032e 	bgeu	r3,r2,10328 <vTaskIncrementTick+0xdc>
   1031c:	e0bfff17 	ldw	r2,-4(fp)
   10320:	d0a00715 	stw	r2,-32740(gp)
   10324:	00002106 	br	103ac <vTaskIncrementTick+0x160>
   10328:	e0bffe17 	ldw	r2,-8(fp)
   1032c:	10800104 	addi	r2,r2,4
   10330:	1009883a 	mov	r4,r2
   10334:	003c0fc0 	call	3c0fc <vListRemove>
   10338:	e0bffe17 	ldw	r2,-8(fp)
   1033c:	10800a17 	ldw	r2,40(r2)
   10340:	10000426 	beq	r2,zero,10354 <vTaskIncrementTick+0x108>
   10344:	e0bffe17 	ldw	r2,-8(fp)
   10348:	10800604 	addi	r2,r2,24
   1034c:	1009883a 	mov	r4,r2
   10350:	003c0fc0 	call	3c0fc <vListRemove>
   10354:	e0bffe17 	ldw	r2,-8(fp)
   10358:	10800b17 	ldw	r2,44(r2)
   1035c:	d0e90e17 	ldw	r3,-23496(gp)
   10360:	1880032e 	bgeu	r3,r2,10370 <vTaskIncrementTick+0x124>
   10364:	e0bffe17 	ldw	r2,-8(fp)
   10368:	10800b17 	ldw	r2,44(r2)
   1036c:	d0a90e15 	stw	r2,-23496(gp)
   10370:	e0bffe17 	ldw	r2,-8(fp)
   10374:	10800b17 	ldw	r2,44(r2)
   10378:	10c00524 	muli	r3,r2,20
   1037c:	00800134 	movhi	r2,4
   10380:	109f1e04 	addi	r2,r2,31864
   10384:	1887883a 	add	r3,r3,r2
   10388:	e0bffe17 	ldw	r2,-8(fp)
   1038c:	10800104 	addi	r2,r2,4
   10390:	1809883a 	mov	r4,r3
   10394:	100b883a 	mov	r5,r2
   10398:	003bf900 	call	3bf90 <vListInsertEnd>
   1039c:	003fcf06 	br	102dc <vTaskIncrementTick+0x90>
	}
	else
	{
		++uxMissedTicks;
   103a0:	d0a91117 	ldw	r2,-23484(gp)
   103a4:	10800044 	addi	r2,r2,1
   103a8:	d0a91115 	stw	r2,-23484(gp)
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
   103ac:	e037883a 	mov	sp,fp
   103b0:	dfc00117 	ldw	ra,4(sp)
   103b4:	df000017 	ldw	fp,0(sp)
   103b8:	dec00204 	addi	sp,sp,8
   103bc:	f800283a 	ret

000103c0 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
   103c0:	defffd04 	addi	sp,sp,-12
   103c4:	dfc00215 	stw	ra,8(sp)
   103c8:	df000115 	stw	fp,4(sp)
   103cc:	df000104 	addi	fp,sp,4
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
   103d0:	d0a91017 	ldw	r2,-23488(gp)
   103d4:	10000326 	beq	r2,zero,103e4 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
   103d8:	00800044 	movi	r2,1
   103dc:	d0a91215 	stw	r2,-23480(gp)
   103e0:	00003f06 	br	104e0 <vTaskSwitchContext+0x120>
				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
				ulTaskSwitchedInTime = ulTempCounter;
		}
		#endif
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
   103e4:	d0a90717 	ldw	r2,-23524(gp)
   103e8:	10800017 	ldw	r2,0(r2)
   103ec:	d0e90717 	ldw	r3,-23524(gp)
   103f0:	18c00c17 	ldw	r3,48(r3)
   103f4:	18800636 	bltu	r3,r2,10410 <vTaskSwitchContext+0x50>
   103f8:	d0e90717 	ldw	r3,-23524(gp)
   103fc:	d0a90717 	ldw	r2,-23524(gp)
   10400:	10800d04 	addi	r2,r2,52
   10404:	1809883a 	mov	r4,r3
   10408:	100b883a 	mov	r5,r2
   1040c:	00034300 	call	3430 <vApplicationStackOverflowHook>
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
   10410:	d0a90717 	ldw	r2,-23524(gp)
   10414:	10800c17 	ldw	r2,48(r2)
   10418:	1009883a 	mov	r4,r2
   1041c:	01400134 	movhi	r5,4
   10420:	29426e84 	addi	r5,r5,2490
   10424:	01800504 	movi	r6,20
   10428:	003f2240 	call	3f224 <memcmp>
   1042c:	10000b26 	beq	r2,zero,1045c <vTaskSwitchContext+0x9c>
   10430:	d0e90717 	ldw	r3,-23524(gp)
   10434:	d0a90717 	ldw	r2,-23524(gp)
   10438:	10800d04 	addi	r2,r2,52
   1043c:	1809883a 	mov	r4,r3
   10440:	100b883a 	mov	r5,r2
   10444:	00034300 	call	3430 <vApplicationStackOverflowHook>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
   10448:	00000406 	br	1045c <vTaskSwitchContext+0x9c>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
   1044c:	d0a90e17 	ldw	r2,-23496(gp)
   10450:	10bfffc4 	addi	r2,r2,-1
   10454:	d0a90e15 	stw	r2,-23496(gp)
   10458:	00000106 	br	10460 <vTaskSwitchContext+0xa0>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
   1045c:	0001883a 	nop
   10460:	d0a90e17 	ldw	r2,-23496(gp)
   10464:	00c00134 	movhi	r3,4
   10468:	18df1e04 	addi	r3,r3,31864
   1046c:	10800524 	muli	r2,r2,20
   10470:	1885883a 	add	r2,r3,r2
   10474:	10800017 	ldw	r2,0(r2)
   10478:	103ff426 	beq	r2,zero,1044c <vTaskSwitchContext+0x8c>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
   1047c:	d0a90e17 	ldw	r2,-23496(gp)
   10480:	10c00524 	muli	r3,r2,20
   10484:	00800134 	movhi	r2,4
   10488:	109f1e04 	addi	r2,r2,31864
   1048c:	1885883a 	add	r2,r3,r2
   10490:	e0bfff15 	stw	r2,-4(fp)
   10494:	e0bfff17 	ldw	r2,-4(fp)
   10498:	10800117 	ldw	r2,4(r2)
   1049c:	10c00117 	ldw	r3,4(r2)
   104a0:	e0bfff17 	ldw	r2,-4(fp)
   104a4:	10c00115 	stw	r3,4(r2)
   104a8:	e0bfff17 	ldw	r2,-4(fp)
   104ac:	10c00117 	ldw	r3,4(r2)
   104b0:	e0bfff17 	ldw	r2,-4(fp)
   104b4:	10800204 	addi	r2,r2,8
   104b8:	1880051e 	bne	r3,r2,104d0 <vTaskSwitchContext+0x110>
   104bc:	e0bfff17 	ldw	r2,-4(fp)
   104c0:	10800117 	ldw	r2,4(r2)
   104c4:	10c00117 	ldw	r3,4(r2)
   104c8:	e0bfff17 	ldw	r2,-4(fp)
   104cc:	10c00115 	stw	r3,4(r2)
   104d0:	e0bfff17 	ldw	r2,-4(fp)
   104d4:	10800117 	ldw	r2,4(r2)
   104d8:	10800317 	ldw	r2,12(r2)
   104dc:	d0a90715 	stw	r2,-23524(gp)
	
		traceTASK_SWITCHED_IN();
	}
}
   104e0:	e037883a 	mov	sp,fp
   104e4:	dfc00117 	ldw	ra,4(sp)
   104e8:	df000017 	ldw	fp,0(sp)
   104ec:	dec00204 	addi	sp,sp,8
   104f0:	f800283a 	ret

000104f4 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
   104f4:	defffb04 	addi	sp,sp,-20
   104f8:	dfc00415 	stw	ra,16(sp)
   104fc:	df000315 	stw	fp,12(sp)
   10500:	df000304 	addi	fp,sp,12
   10504:	e13ffe15 	stw	r4,-8(fp)
   10508:	e17fff15 	stw	r5,-4(fp)
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
   1050c:	d0a90717 	ldw	r2,-23524(gp)
   10510:	10800604 	addi	r2,r2,24
   10514:	e13ffe17 	ldw	r4,-8(fp)
   10518:	100b883a 	mov	r5,r2
   1051c:	003c0280 	call	3c028 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   10520:	d0a90717 	ldw	r2,-23524(gp)
   10524:	10800104 	addi	r2,r2,4
   10528:	1009883a 	mov	r4,r2
   1052c:	003c0fc0 	call	3c0fc <vListRemove>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
   10530:	e0bfff17 	ldw	r2,-4(fp)
   10534:	10bfffd8 	cmpnei	r2,r2,-1
   10538:	1000071e 	bne	r2,zero,10558 <vTaskPlaceOnEventList+0x64>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   1053c:	d0a90717 	ldw	r2,-23524(gp)
   10540:	10800104 	addi	r2,r2,4
   10544:	01000134 	movhi	r4,4
   10548:	211f4b04 	addi	r4,r4,32044
   1054c:	100b883a 	mov	r5,r2
   10550:	003bf900 	call	3bf90 <vListInsertEnd>
   10554:	00000606 	br	10570 <vTaskPlaceOnEventList+0x7c>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
   10558:	d0e90c17 	ldw	r3,-23504(gp)
   1055c:	e0bfff17 	ldw	r2,-4(fp)
   10560:	1885883a 	add	r2,r3,r2
   10564:	e0bffd15 	stw	r2,-12(fp)
			prvAddCurrentTaskToDelayedList( xTimeToWake );
   10568:	e13ffd17 	ldw	r4,-12(fp)
   1056c:	0010afc0 	call	10afc <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
   10570:	e037883a 	mov	sp,fp
   10574:	dfc00117 	ldw	ra,4(sp)
   10578:	df000017 	ldw	fp,0(sp)
   1057c:	dec00204 	addi	sp,sp,8
   10580:	f800283a 	ret

00010584 <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
	{
   10584:	defffb04 	addi	sp,sp,-20
   10588:	dfc00415 	stw	ra,16(sp)
   1058c:	df000315 	stw	fp,12(sp)
   10590:	df000304 	addi	fp,sp,12
   10594:	e13ffe15 	stw	r4,-8(fp)
   10598:	e17fff15 	stw	r5,-4(fp)
	
		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
   1059c:	d0a90717 	ldw	r2,-23524(gp)
   105a0:	10800604 	addi	r2,r2,24
   105a4:	e13ffe17 	ldw	r4,-8(fp)
   105a8:	100b883a 	mov	r5,r2
   105ac:	003bf900 	call	3bf90 <vListInsertEnd>

		/* We must remove this task from the ready list before adding it to the
		blocked list as the same list item is used for both lists.  This
		function is called form a critical section. */
		vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   105b0:	d0a90717 	ldw	r2,-23524(gp)
   105b4:	10800104 	addi	r2,r2,4
   105b8:	1009883a 	mov	r4,r2
   105bc:	003c0fc0 	call	3c0fc <vListRemove>

		/* Calculate the time at which the task should be woken if the event does
		not occur.  This may overflow but this doesn't matter. */
		xTimeToWake = xTickCount + xTicksToWait;
   105c0:	d0e90c17 	ldw	r3,-23504(gp)
   105c4:	e0bfff17 	ldw	r2,-4(fp)
   105c8:	1885883a 	add	r2,r3,r2
   105cc:	e0bffd15 	stw	r2,-12(fp)
		prvAddCurrentTaskToDelayedList( xTimeToWake );
   105d0:	e13ffd17 	ldw	r4,-12(fp)
   105d4:	0010afc0 	call	10afc <prvAddCurrentTaskToDelayedList>
	}
   105d8:	e037883a 	mov	sp,fp
   105dc:	dfc00117 	ldw	ra,4(sp)
   105e0:	df000017 	ldw	fp,0(sp)
   105e4:	dec00204 	addi	sp,sp,8
   105e8:	f800283a 	ret

000105ec <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
   105ec:	defffb04 	addi	sp,sp,-20
   105f0:	dfc00415 	stw	ra,16(sp)
   105f4:	df000315 	stw	fp,12(sp)
   105f8:	df000304 	addi	fp,sp,12
   105fc:	e13fff15 	stw	r4,-4(fp)
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
   10600:	e0bfff17 	ldw	r2,-4(fp)
   10604:	10800317 	ldw	r2,12(r2)
   10608:	10800317 	ldw	r2,12(r2)
   1060c:	e0bffe15 	stw	r2,-8(fp)
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
   10610:	e0bffe17 	ldw	r2,-8(fp)
   10614:	10800604 	addi	r2,r2,24
   10618:	1009883a 	mov	r4,r2
   1061c:	003c0fc0 	call	3c0fc <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   10620:	d0a91017 	ldw	r2,-23488(gp)
   10624:	1000171e 	bne	r2,zero,10684 <xTaskRemoveFromEventList+0x98>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
   10628:	e0bffe17 	ldw	r2,-8(fp)
   1062c:	10800104 	addi	r2,r2,4
   10630:	1009883a 	mov	r4,r2
   10634:	003c0fc0 	call	3c0fc <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
   10638:	e0bffe17 	ldw	r2,-8(fp)
   1063c:	10800b17 	ldw	r2,44(r2)
   10640:	d0e90e17 	ldw	r3,-23496(gp)
   10644:	1880032e 	bgeu	r3,r2,10654 <xTaskRemoveFromEventList+0x68>
   10648:	e0bffe17 	ldw	r2,-8(fp)
   1064c:	10800b17 	ldw	r2,44(r2)
   10650:	d0a90e15 	stw	r2,-23496(gp)
   10654:	e0bffe17 	ldw	r2,-8(fp)
   10658:	10800b17 	ldw	r2,44(r2)
   1065c:	10c00524 	muli	r3,r2,20
   10660:	00800134 	movhi	r2,4
   10664:	109f1e04 	addi	r2,r2,31864
   10668:	1887883a 	add	r3,r3,r2
   1066c:	e0bffe17 	ldw	r2,-8(fp)
   10670:	10800104 	addi	r2,r2,4
   10674:	1809883a 	mov	r4,r3
   10678:	100b883a 	mov	r5,r2
   1067c:	003bf900 	call	3bf90 <vListInsertEnd>
   10680:	00000606 	br	1069c <xTaskRemoveFromEventList+0xb0>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   10684:	e0bffe17 	ldw	r2,-8(fp)
   10688:	10800604 	addi	r2,r2,24
   1068c:	01000134 	movhi	r4,4
   10690:	211f4104 	addi	r4,r4,32004
   10694:	100b883a 	mov	r5,r2
   10698:	003bf900 	call	3bf90 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
   1069c:	e0bffe17 	ldw	r2,-8(fp)
   106a0:	10c00b17 	ldw	r3,44(r2)
   106a4:	d0a90717 	ldw	r2,-23524(gp)
   106a8:	10800b17 	ldw	r2,44(r2)
   106ac:	18800336 	bltu	r3,r2,106bc <xTaskRemoveFromEventList+0xd0>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
   106b0:	00800044 	movi	r2,1
   106b4:	e0bffd15 	stw	r2,-12(fp)
   106b8:	00000106 	br	106c0 <xTaskRemoveFromEventList+0xd4>
	}
	else
	{
		xReturn = pdFALSE;
   106bc:	e03ffd15 	stw	zero,-12(fp)
	}

	return xReturn;
   106c0:	e0bffd17 	ldw	r2,-12(fp)
}
   106c4:	e037883a 	mov	sp,fp
   106c8:	dfc00117 	ldw	ra,4(sp)
   106cc:	df000017 	ldw	fp,0(sp)
   106d0:	dec00204 	addi	sp,sp,8
   106d4:	f800283a 	ret

000106d8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
   106d8:	defffe04 	addi	sp,sp,-8
   106dc:	df000115 	stw	fp,4(sp)
   106e0:	df000104 	addi	fp,sp,4
   106e4:	e13fff15 	stw	r4,-4(fp)
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
   106e8:	d0e91317 	ldw	r3,-23476(gp)
   106ec:	e0bfff17 	ldw	r2,-4(fp)
   106f0:	10c00015 	stw	r3,0(r2)
	pxTimeOut->xTimeOnEntering = xTickCount;
   106f4:	d0e90c17 	ldw	r3,-23504(gp)
   106f8:	e0bfff17 	ldw	r2,-4(fp)
   106fc:	10c00115 	stw	r3,4(r2)
}
   10700:	e037883a 	mov	sp,fp
   10704:	df000017 	ldw	fp,0(sp)
   10708:	dec00104 	addi	sp,sp,4
   1070c:	f800283a 	ret

00010710 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
   10710:	defffb04 	addi	sp,sp,-20
   10714:	dfc00415 	stw	ra,16(sp)
   10718:	df000315 	stw	fp,12(sp)
   1071c:	df000304 	addi	fp,sp,12
   10720:	e13ffe15 	stw	r4,-8(fp)
   10724:	e17fff15 	stw	r5,-4(fp)
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
   10728:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   1072c:	10000126 	beq	r2,zero,10734 <xTaskCheckForTimeOut+0x24>
   10730:	00110d00 	call	110d0 <vTaskEnterCritical>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
   10734:	e0bfff17 	ldw	r2,-4(fp)
   10738:	10800017 	ldw	r2,0(r2)
   1073c:	10bfffd8 	cmpnei	r2,r2,-1
   10740:	1000021e 	bne	r2,zero,1074c <xTaskCheckForTimeOut+0x3c>
			{
				xReturn = pdFALSE;
   10744:	e03ffd15 	stw	zero,-12(fp)
   10748:	00002106 	br	107d0 <xTaskCheckForTimeOut+0xc0>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
   1074c:	e0bffe17 	ldw	r2,-8(fp)
   10750:	10c00017 	ldw	r3,0(r2)
   10754:	d0a91317 	ldw	r2,-23476(gp)
   10758:	18800726 	beq	r3,r2,10778 <xTaskCheckForTimeOut+0x68>
   1075c:	e0bffe17 	ldw	r2,-8(fp)
   10760:	10800117 	ldw	r2,4(r2)
   10764:	d0e90c17 	ldw	r3,-23504(gp)
   10768:	18800336 	bltu	r3,r2,10778 <xTaskCheckForTimeOut+0x68>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
   1076c:	00800044 	movi	r2,1
   10770:	e0bffd15 	stw	r2,-12(fp)
   10774:	00001606 	br	107d0 <xTaskCheckForTimeOut+0xc0>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
   10778:	d0e90c17 	ldw	r3,-23504(gp)
   1077c:	e0bffe17 	ldw	r2,-8(fp)
   10780:	10800117 	ldw	r2,4(r2)
   10784:	1887c83a 	sub	r3,r3,r2
   10788:	e0bfff17 	ldw	r2,-4(fp)
   1078c:	10800017 	ldw	r2,0(r2)
   10790:	18800d2e 	bgeu	r3,r2,107c8 <xTaskCheckForTimeOut+0xb8>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
   10794:	e0bfff17 	ldw	r2,-4(fp)
   10798:	10c00017 	ldw	r3,0(r2)
   1079c:	e0bffe17 	ldw	r2,-8(fp)
   107a0:	11000117 	ldw	r4,4(r2)
   107a4:	d0a90c17 	ldw	r2,-23504(gp)
   107a8:	2085c83a 	sub	r2,r4,r2
   107ac:	1887883a 	add	r3,r3,r2
   107b0:	e0bfff17 	ldw	r2,-4(fp)
   107b4:	10c00015 	stw	r3,0(r2)
			vTaskSetTimeOutState( pxTimeOut );
   107b8:	e13ffe17 	ldw	r4,-8(fp)
   107bc:	00106d80 	call	106d8 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
   107c0:	e03ffd15 	stw	zero,-12(fp)
   107c4:	00000206 	br	107d0 <xTaskCheckForTimeOut+0xc0>
		}
		else
		{
			xReturn = pdTRUE;
   107c8:	00800044 	movi	r2,1
   107cc:	e0bffd15 	stw	r2,-12(fp)
		}
	}
	taskEXIT_CRITICAL();
   107d0:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   107d4:	10000126 	beq	r2,zero,107dc <xTaskCheckForTimeOut+0xcc>
   107d8:	00111100 	call	11110 <vTaskExitCritical>

	return xReturn;
   107dc:	e0bffd17 	ldw	r2,-12(fp)
}
   107e0:	e037883a 	mov	sp,fp
   107e4:	dfc00117 	ldw	ra,4(sp)
   107e8:	df000017 	ldw	fp,0(sp)
   107ec:	dec00204 	addi	sp,sp,8
   107f0:	f800283a 	ret

000107f4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
   107f4:	deffff04 	addi	sp,sp,-4
   107f8:	df000015 	stw	fp,0(sp)
   107fc:	d839883a 	mov	fp,sp
	xMissedYield = pdTRUE;
   10800:	00800044 	movi	r2,1
   10804:	d0a91215 	stw	r2,-23480(gp)
}
   10808:	e037883a 	mov	sp,fp
   1080c:	df000017 	ldw	fp,0(sp)
   10810:	dec00104 	addi	sp,sp,4
   10814:	f800283a 	ret

00010818 <uxTaskGetTaskNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )
	unsigned portBASE_TYPE uxTaskGetTaskNumber( xTaskHandle xTask )
	{
   10818:	defffc04 	addi	sp,sp,-16
   1081c:	df000315 	stw	fp,12(sp)
   10820:	df000304 	addi	fp,sp,12
   10824:	e13fff15 	stw	r4,-4(fp)
	unsigned portBASE_TYPE uxReturn;
	tskTCB *pxTCB;
	
		if( xTask != NULL )
   10828:	e0bfff17 	ldw	r2,-4(fp)
   1082c:	10000626 	beq	r2,zero,10848 <uxTaskGetTaskNumber+0x30>
		{
			pxTCB = ( tskTCB * ) xTask;
   10830:	e0bfff17 	ldw	r2,-4(fp)
   10834:	e0bffe15 	stw	r2,-8(fp)
			uxReturn = pxTCB->uxTaskNumber;
   10838:	e0bffe17 	ldw	r2,-8(fp)
   1083c:	10801917 	ldw	r2,100(r2)
   10840:	e0bffd15 	stw	r2,-12(fp)
   10844:	00000106 	br	1084c <uxTaskGetTaskNumber+0x34>
		}
		else
		{
			uxReturn = 0U;
   10848:	e03ffd15 	stw	zero,-12(fp)
		}
		
		return uxReturn;
   1084c:	e0bffd17 	ldw	r2,-12(fp)
	}
   10850:	e037883a 	mov	sp,fp
   10854:	df000017 	ldw	fp,0(sp)
   10858:	dec00104 	addi	sp,sp,4
   1085c:	f800283a 	ret

00010860 <vTaskSetTaskNumber>:
#endif
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )
	void vTaskSetTaskNumber( xTaskHandle xTask, unsigned portBASE_TYPE uxHandle )
	{
   10860:	defffc04 	addi	sp,sp,-16
   10864:	df000315 	stw	fp,12(sp)
   10868:	df000304 	addi	fp,sp,12
   1086c:	e13ffe15 	stw	r4,-8(fp)
   10870:	e17fff15 	stw	r5,-4(fp)
	tskTCB *pxTCB;
	
		if( xTask != NULL )
   10874:	e0bffe17 	ldw	r2,-8(fp)
   10878:	10000526 	beq	r2,zero,10890 <vTaskSetTaskNumber+0x30>
		{
			pxTCB = ( tskTCB * ) xTask;
   1087c:	e0bffe17 	ldw	r2,-8(fp)
   10880:	e0bffd15 	stw	r2,-12(fp)
			pxTCB->uxTaskNumber = uxHandle;
   10884:	e0bffd17 	ldw	r2,-12(fp)
   10888:	e0ffff17 	ldw	r3,-4(fp)
   1088c:	10c01915 	stw	r3,100(r2)
		}
	}
   10890:	e037883a 	mov	sp,fp
   10894:	df000017 	ldw	fp,0(sp)
   10898:	dec00104 	addi	sp,sp,4
   1089c:	f800283a 	ret

000108a0 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
   108a0:	defffd04 	addi	sp,sp,-12
   108a4:	dfc00215 	stw	ra,8(sp)
   108a8:	df000115 	stw	fp,4(sp)
   108ac:	df000104 	addi	fp,sp,4
   108b0:	e13fff15 	stw	r4,-4(fp)
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
   108b4:	0010a4c0 	call	10a4c <prvCheckTasksWaitingTermination>
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
   108b8:	003ffe06 	br	108b4 <prvIdleTask+0x14>

000108bc <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
   108bc:	defff904 	addi	sp,sp,-28
   108c0:	dfc00615 	stw	ra,24(sp)
   108c4:	df000515 	stw	fp,20(sp)
   108c8:	df000504 	addi	fp,sp,20
   108cc:	e13ffb15 	stw	r4,-20(fp)
   108d0:	e17ffc15 	stw	r5,-16(fp)
   108d4:	e1bffd15 	stw	r6,-12(fp)
   108d8:	e1fffe15 	stw	r7,-8(fp)
   108dc:	e0800217 	ldw	r2,8(fp)
   108e0:	e0bfff0d 	sth	r2,-4(fp)
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
   108e4:	e0bffb17 	ldw	r2,-20(fp)
   108e8:	10800d04 	addi	r2,r2,52
   108ec:	1009883a 	mov	r4,r2
   108f0:	e17ffc17 	ldw	r5,-16(fp)
   108f4:	01800a04 	movi	r6,40
   108f8:	003f3f00 	call	3f3f0 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
   108fc:	e0bffb17 	ldw	r2,-20(fp)
   10900:	100016c5 	stb	zero,91(r2)

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
   10904:	e0bffd17 	ldw	r2,-12(fp)
   10908:	10800170 	cmpltui	r2,r2,5
   1090c:	1000021e 	bne	r2,zero,10918 <prvInitialiseTCBVariables+0x5c>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
   10910:	00800104 	movi	r2,4
   10914:	e0bffd15 	stw	r2,-12(fp)
	}

	pxTCB->uxPriority = uxPriority;
   10918:	e0bffb17 	ldw	r2,-20(fp)
   1091c:	e0fffd17 	ldw	r3,-12(fp)
   10920:	10c00b15 	stw	r3,44(r2)
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
   10924:	e0bffb17 	ldw	r2,-20(fp)
   10928:	e0fffd17 	ldw	r3,-12(fp)
   1092c:	10c01a15 	stw	r3,104(r2)
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
   10930:	e0bffb17 	ldw	r2,-20(fp)
   10934:	10800104 	addi	r2,r2,4
   10938:	1009883a 	mov	r4,r2
   1093c:	003bf680 	call	3bf68 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
   10940:	e0bffb17 	ldw	r2,-20(fp)
   10944:	10800604 	addi	r2,r2,24
   10948:	1009883a 	mov	r4,r2
   1094c:	003bf680 	call	3bf68 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
   10950:	e0bffb17 	ldw	r2,-20(fp)
   10954:	e0fffb17 	ldw	r3,-20(fp)
   10958:	10c00415 	stw	r3,16(r2)

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
   1095c:	00c00144 	movi	r3,5
   10960:	e0bffd17 	ldw	r2,-12(fp)
   10964:	1887c83a 	sub	r3,r3,r2
   10968:	e0bffb17 	ldw	r2,-20(fp)
   1096c:	10c00615 	stw	r3,24(r2)
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
   10970:	e0bffb17 	ldw	r2,-20(fp)
   10974:	e0fffb17 	ldw	r3,-20(fp)
   10978:	10c00915 	stw	r3,36(r2)

	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
	{
		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;
   1097c:	e0bffb17 	ldw	r2,-20(fp)
   10980:	10001715 	stw	zero,92(r2)
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
   10984:	e037883a 	mov	sp,fp
   10988:	dfc00117 	ldw	ra,4(sp)
   1098c:	df000017 	ldw	fp,0(sp)
   10990:	dec00204 	addi	sp,sp,8
   10994:	f800283a 	ret

00010998 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
   10998:	defffd04 	addi	sp,sp,-12
   1099c:	dfc00215 	stw	ra,8(sp)
   109a0:	df000115 	stw	fp,4(sp)
   109a4:	df000104 	addi	fp,sp,4
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
   109a8:	e03fff15 	stw	zero,-4(fp)
   109ac:	00000a06 	br	109d8 <prvInitialiseTaskLists+0x40>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
   109b0:	e0bfff17 	ldw	r2,-4(fp)
   109b4:	10c00524 	muli	r3,r2,20
   109b8:	00800134 	movhi	r2,4
   109bc:	109f1e04 	addi	r2,r2,31864
   109c0:	1885883a 	add	r2,r3,r2
   109c4:	1009883a 	mov	r4,r2
   109c8:	003bf040 	call	3bf04 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
   109cc:	e0bfff17 	ldw	r2,-4(fp)
   109d0:	10800044 	addi	r2,r2,1
   109d4:	e0bfff15 	stw	r2,-4(fp)
   109d8:	e0bfff17 	ldw	r2,-4(fp)
   109dc:	10800170 	cmpltui	r2,r2,5
   109e0:	103ff31e 	bne	r2,zero,109b0 <prvInitialiseTaskLists+0x18>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
   109e4:	01000134 	movhi	r4,4
   109e8:	211f3704 	addi	r4,r4,31964
   109ec:	003bf040 	call	3bf04 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
   109f0:	01000134 	movhi	r4,4
   109f4:	211f3c04 	addi	r4,r4,31984
   109f8:	003bf040 	call	3bf04 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
   109fc:	01000134 	movhi	r4,4
   10a00:	211f4104 	addi	r4,r4,32004
   10a04:	003bf040 	call	3bf04 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
   10a08:	01000134 	movhi	r4,4
   10a0c:	211f4604 	addi	r4,r4,32024
   10a10:	003bf040 	call	3bf04 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
   10a14:	01000134 	movhi	r4,4
   10a18:	211f4b04 	addi	r4,r4,32044
   10a1c:	003bf040 	call	3bf04 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
   10a20:	00800134 	movhi	r2,4
   10a24:	109f3704 	addi	r2,r2,31964
   10a28:	d0a90815 	stw	r2,-23520(gp)
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   10a2c:	00800134 	movhi	r2,4
   10a30:	109f3c04 	addi	r2,r2,31984
   10a34:	d0a90915 	stw	r2,-23516(gp)
}
   10a38:	e037883a 	mov	sp,fp
   10a3c:	dfc00117 	ldw	ra,4(sp)
   10a40:	df000017 	ldw	fp,0(sp)
   10a44:	dec00204 	addi	sp,sp,8
   10a48:	f800283a 	ret

00010a4c <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
   10a4c:	defffc04 	addi	sp,sp,-16
   10a50:	dfc00315 	stw	ra,12(sp)
   10a54:	df000215 	stw	fp,8(sp)
   10a58:	df000204 	addi	fp,sp,8
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
   10a5c:	d0a90a17 	ldw	r2,-23512(gp)
   10a60:	10002126 	beq	r2,zero,10ae8 <prvCheckTasksWaitingTermination+0x9c>
		{
			vTaskSuspendAll();
   10a64:	000fef80 	call	fef8 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
   10a68:	00800134 	movhi	r2,4
   10a6c:	109f4604 	addi	r2,r2,32024
   10a70:	10800017 	ldw	r2,0(r2)
   10a74:	1005003a 	cmpeq	r2,r2,zero
   10a78:	10803fcc 	andi	r2,r2,255
   10a7c:	e0bffe15 	stw	r2,-8(fp)
			xTaskResumeAll();
   10a80:	000ff200 	call	ff20 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
   10a84:	e0bffe17 	ldw	r2,-8(fp)
   10a88:	1000171e 	bne	r2,zero,10ae8 <prvCheckTasksWaitingTermination+0x9c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
   10a8c:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   10a90:	10000126 	beq	r2,zero,10a98 <prvCheckTasksWaitingTermination+0x4c>
   10a94:	00110d00 	call	110d0 <vTaskEnterCritical>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
   10a98:	00800134 	movhi	r2,4
   10a9c:	109f4604 	addi	r2,r2,32024
   10aa0:	10800317 	ldw	r2,12(r2)
   10aa4:	10800317 	ldw	r2,12(r2)
   10aa8:	e0bfff15 	stw	r2,-4(fp)
					vListRemove( &( pxTCB->xGenericListItem ) );
   10aac:	e0bfff17 	ldw	r2,-4(fp)
   10ab0:	10800104 	addi	r2,r2,4
   10ab4:	1009883a 	mov	r4,r2
   10ab8:	003c0fc0 	call	3c0fc <vListRemove>
					--uxCurrentNumberOfTasks;
   10abc:	d0a90b17 	ldw	r2,-23508(gp)
   10ac0:	10bfffc4 	addi	r2,r2,-1
   10ac4:	d0a90b15 	stw	r2,-23508(gp)
					--uxTasksDeleted;
   10ac8:	d0a90a17 	ldw	r2,-23512(gp)
   10acc:	10bfffc4 	addi	r2,r2,-1
   10ad0:	d0a90a15 	stw	r2,-23512(gp)
				}
				taskEXIT_CRITICAL();
   10ad4:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   10ad8:	10000126 	beq	r2,zero,10ae0 <prvCheckTasksWaitingTermination+0x94>
   10adc:	00111100 	call	11110 <vTaskExitCritical>

				prvDeleteTCB( pxTCB );
   10ae0:	e13fff17 	ldw	r4,-4(fp)
   10ae4:	0010e540 	call	10e54 <prvDeleteTCB>
			}
		}
	}
	#endif
}
   10ae8:	e037883a 	mov	sp,fp
   10aec:	dfc00117 	ldw	ra,4(sp)
   10af0:	df000017 	ldw	fp,0(sp)
   10af4:	dec00204 	addi	sp,sp,8
   10af8:	f800283a 	ret

00010afc <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
   10afc:	defffd04 	addi	sp,sp,-12
   10b00:	dfc00215 	stw	ra,8(sp)
   10b04:	df000115 	stw	fp,4(sp)
   10b08:	df000104 	addi	fp,sp,4
   10b0c:	e13fff15 	stw	r4,-4(fp)
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
   10b10:	d0a90717 	ldw	r2,-23524(gp)
   10b14:	e0ffff17 	ldw	r3,-4(fp)
   10b18:	10c00115 	stw	r3,4(r2)

	if( xTimeToWake < xTickCount )
   10b1c:	d0a90c17 	ldw	r2,-23504(gp)
   10b20:	e0ffff17 	ldw	r3,-4(fp)
   10b24:	1880072e 	bgeu	r3,r2,10b44 <prvAddCurrentTaskToDelayedList+0x48>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   10b28:	d0e90917 	ldw	r3,-23516(gp)
   10b2c:	d0a90717 	ldw	r2,-23524(gp)
   10b30:	10800104 	addi	r2,r2,4
   10b34:	1809883a 	mov	r4,r3
   10b38:	100b883a 	mov	r5,r2
   10b3c:	003c0280 	call	3c028 <vListInsert>
   10b40:	00000b06 	br	10b70 <prvAddCurrentTaskToDelayedList+0x74>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   10b44:	d0e90817 	ldw	r3,-23520(gp)
   10b48:	d0a90717 	ldw	r2,-23524(gp)
   10b4c:	10800104 	addi	r2,r2,4
   10b50:	1809883a 	mov	r4,r3
   10b54:	100b883a 	mov	r5,r2
   10b58:	003c0280 	call	3c028 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
   10b5c:	d0a00717 	ldw	r2,-32740(gp)
   10b60:	e0ffff17 	ldw	r3,-4(fp)
   10b64:	1880022e 	bgeu	r3,r2,10b70 <prvAddCurrentTaskToDelayedList+0x74>
		{
			xNextTaskUnblockTime = xTimeToWake;
   10b68:	e0bfff17 	ldw	r2,-4(fp)
   10b6c:	d0a00715 	stw	r2,-32740(gp)
		}
	}
}
   10b70:	e037883a 	mov	sp,fp
   10b74:	dfc00117 	ldw	ra,4(sp)
   10b78:	df000017 	ldw	fp,0(sp)
   10b7c:	dec00204 	addi	sp,sp,8
   10b80:	f800283a 	ret

00010b84 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
   10b84:	defffb04 	addi	sp,sp,-20
   10b88:	dfc00415 	stw	ra,16(sp)
   10b8c:	df000315 	stw	fp,12(sp)
   10b90:	df000304 	addi	fp,sp,12
   10b94:	2005883a 	mov	r2,r4
   10b98:	e17fff15 	stw	r5,-4(fp)
   10b9c:	e0bffe0d 	sth	r2,-8(fp)
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
   10ba0:	01001b04 	movi	r4,108
   10ba4:	000e4980 	call	e498 <pvPortMalloc>
   10ba8:	e0bffd15 	stw	r2,-12(fp)

	if( pxNewTCB != NULL )
   10bac:	e0bffd17 	ldw	r2,-12(fp)
   10bb0:	10001b26 	beq	r2,zero,10c20 <prvAllocateTCBAndStack+0x9c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
   10bb4:	e0bfff17 	ldw	r2,-4(fp)
   10bb8:	1000061e 	bne	r2,zero,10bd4 <prvAllocateTCBAndStack+0x50>
   10bbc:	e0bffe0b 	ldhu	r2,-8(fp)
   10bc0:	1085883a 	add	r2,r2,r2
   10bc4:	1085883a 	add	r2,r2,r2
   10bc8:	1009883a 	mov	r4,r2
   10bcc:	000e4980 	call	e498 <pvPortMalloc>
   10bd0:	00000106 	br	10bd8 <prvAllocateTCBAndStack+0x54>
   10bd4:	e0bfff17 	ldw	r2,-4(fp)
   10bd8:	e0fffd17 	ldw	r3,-12(fp)
   10bdc:	18800c15 	stw	r2,48(r3)

		if( pxNewTCB->pxStack == NULL )
   10be0:	e0bffd17 	ldw	r2,-12(fp)
   10be4:	10800c17 	ldw	r2,48(r2)
   10be8:	1000041e 	bne	r2,zero,10bfc <prvAllocateTCBAndStack+0x78>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
   10bec:	e13ffd17 	ldw	r4,-12(fp)
   10bf0:	000e4d80 	call	e4d8 <vPortFree>
			pxNewTCB = NULL;
   10bf4:	e03ffd15 	stw	zero,-12(fp)
   10bf8:	00000906 	br	10c20 <prvAllocateTCBAndStack+0x9c>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
   10bfc:	e0bffd17 	ldw	r2,-12(fp)
   10c00:	10c00c17 	ldw	r3,48(r2)
   10c04:	e0bffe0b 	ldhu	r2,-8(fp)
   10c08:	1085883a 	add	r2,r2,r2
   10c0c:	1085883a 	add	r2,r2,r2
   10c10:	1809883a 	mov	r4,r3
   10c14:	01402944 	movi	r5,165
   10c18:	100d883a 	mov	r6,r2
   10c1c:	00042e80 	call	42e8 <memset>
		}
	}

	return pxNewTCB;
   10c20:	e0bffd17 	ldw	r2,-12(fp)
}
   10c24:	e037883a 	mov	sp,fp
   10c28:	dfc00117 	ldw	ra,4(sp)
   10c2c:	df000017 	ldw	fp,0(sp)
   10c30:	dec00204 	addi	sp,sp,8
   10c34:	f800283a 	ret

00010c38 <prvListTaskWithinSingleList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed char cStatus )
	{
   10c38:	defff304 	addi	sp,sp,-52
   10c3c:	dfc00c15 	stw	ra,48(sp)
   10c40:	df000b15 	stw	fp,44(sp)
   10c44:	df000b04 	addi	fp,sp,44
   10c48:	e13ffd15 	stw	r4,-12(fp)
   10c4c:	e17ffe15 	stw	r5,-8(fp)
   10c50:	3005883a 	mov	r2,r6
   10c54:	e0bfff05 	stb	r2,-4(fp)
	volatile tskTCB *pxNextTCB, *pxFirstTCB;
	unsigned short usStackRemaining;
	PRIVILEGED_DATA static char pcStatusString[ configMAX_TASK_NAME_LEN + 30 ];

		/* Write the details of all the TCB's in pxList into the buffer. */
		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
   10c58:	e0bffe17 	ldw	r2,-8(fp)
   10c5c:	e0bff815 	stw	r2,-32(fp)
   10c60:	e0bff817 	ldw	r2,-32(fp)
   10c64:	10800117 	ldw	r2,4(r2)
   10c68:	10c00117 	ldw	r3,4(r2)
   10c6c:	e0bff817 	ldw	r2,-32(fp)
   10c70:	10c00115 	stw	r3,4(r2)
   10c74:	e0bff817 	ldw	r2,-32(fp)
   10c78:	10c00117 	ldw	r3,4(r2)
   10c7c:	e0bff817 	ldw	r2,-32(fp)
   10c80:	10800204 	addi	r2,r2,8
   10c84:	1880051e 	bne	r3,r2,10c9c <prvListTaskWithinSingleList+0x64>
   10c88:	e0bff817 	ldw	r2,-32(fp)
   10c8c:	10800117 	ldw	r2,4(r2)
   10c90:	10c00117 	ldw	r3,4(r2)
   10c94:	e0bff817 	ldw	r2,-32(fp)
   10c98:	10c00115 	stw	r3,4(r2)
   10c9c:	e0bff817 	ldw	r2,-32(fp)
   10ca0:	10800117 	ldw	r2,4(r2)
   10ca4:	10800317 	ldw	r2,12(r2)
   10ca8:	e0bff915 	stw	r2,-28(fp)
		do
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
   10cac:	e0bffe17 	ldw	r2,-8(fp)
   10cb0:	e0bffa15 	stw	r2,-24(fp)
   10cb4:	e0bffa17 	ldw	r2,-24(fp)
   10cb8:	10800117 	ldw	r2,4(r2)
   10cbc:	10c00117 	ldw	r3,4(r2)
   10cc0:	e0bffa17 	ldw	r2,-24(fp)
   10cc4:	10c00115 	stw	r3,4(r2)
   10cc8:	e0bffa17 	ldw	r2,-24(fp)
   10ccc:	10c00117 	ldw	r3,4(r2)
   10cd0:	e0bffa17 	ldw	r2,-24(fp)
   10cd4:	10800204 	addi	r2,r2,8
   10cd8:	1880051e 	bne	r3,r2,10cf0 <prvListTaskWithinSingleList+0xb8>
   10cdc:	e0bffa17 	ldw	r2,-24(fp)
   10ce0:	10800117 	ldw	r2,4(r2)
   10ce4:	10c00117 	ldw	r3,4(r2)
   10ce8:	e0bffa17 	ldw	r2,-24(fp)
   10cec:	10c00115 	stw	r3,4(r2)
   10cf0:	e0bffa17 	ldw	r2,-24(fp)
   10cf4:	10800117 	ldw	r2,4(r2)
   10cf8:	10800317 	ldw	r2,12(r2)
   10cfc:	e0bffb15 	stw	r2,-20(fp)
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
			}
			#else
			{
				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
   10d00:	e0bffb17 	ldw	r2,-20(fp)
   10d04:	10800c17 	ldw	r2,48(r2)
   10d08:	1009883a 	mov	r4,r2
   10d0c:	0010d8c0 	call	10d8c <usTaskCheckFreeStackSpace>
   10d10:	e0bffc0d 	sth	r2,-16(fp)
			}
			#endif			
			
			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, ( unsigned int ) pxNextTCB->uxPriority, usStackRemaining, ( unsigned int ) pxNextTCB->uxTCBNumber );
   10d14:	e0bffb17 	ldw	r2,-20(fp)
   10d18:	10c00d04 	addi	r3,r2,52
   10d1c:	e0bfff07 	ldb	r2,-4(fp)
   10d20:	e13ffb17 	ldw	r4,-20(fp)
   10d24:	21800b17 	ldw	r6,44(r4)
   10d28:	e17ffc0b 	ldhu	r5,-16(fp)
   10d2c:	e13ffb17 	ldw	r4,-20(fp)
   10d30:	21001817 	ldw	r4,96(r4)
   10d34:	d9800015 	stw	r6,0(sp)
   10d38:	d9400115 	stw	r5,4(sp)
   10d3c:	d9000215 	stw	r4,8(sp)
   10d40:	01000134 	movhi	r4,4
   10d44:	211f5004 	addi	r4,r4,32064
   10d48:	01400134 	movhi	r5,4
   10d4c:	29426a04 	addi	r5,r5,2472
   10d50:	180d883a 	mov	r6,r3
   10d54:	100f883a 	mov	r7,r2
   10d58:	00045a00 	call	45a0 <sprintf>
			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
   10d5c:	e13ffd17 	ldw	r4,-12(fp)
   10d60:	01400134 	movhi	r5,4
   10d64:	295f5004 	addi	r5,r5,32064
   10d68:	000460c0 	call	460c <strcat>

		} while( pxNextTCB != pxFirstTCB );
   10d6c:	e0fffb17 	ldw	r3,-20(fp)
   10d70:	e0bff917 	ldw	r2,-28(fp)
   10d74:	18bfcd1e 	bne	r3,r2,10cac <prvListTaskWithinSingleList+0x74>
	}
   10d78:	e037883a 	mov	sp,fp
   10d7c:	dfc00117 	ldw	ra,4(sp)
   10d80:	df000017 	ldw	fp,0(sp)
   10d84:	dec00204 	addi	sp,sp,8
   10d88:	f800283a 	ret

00010d8c <usTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
   10d8c:	defffd04 	addi	sp,sp,-12
   10d90:	df000215 	stw	fp,8(sp)
   10d94:	dc000115 	stw	r16,4(sp)
   10d98:	df000104 	addi	fp,sp,4
   10d9c:	e13fff15 	stw	r4,-4(fp)
	register unsigned short usCount = 0U;
   10da0:	0021883a 	mov	r16,zero

		while( *pucStackByte == tskSTACK_FILL_BYTE )
   10da4:	00000506 	br	10dbc <usTaskCheckFreeStackSpace+0x30>
		{
			pucStackByte -= portSTACK_GROWTH;
   10da8:	e0bfff17 	ldw	r2,-4(fp)
   10dac:	10800044 	addi	r2,r2,1
   10db0:	e0bfff15 	stw	r2,-4(fp)
			usCount++;
   10db4:	80800044 	addi	r2,r16,1
   10db8:	1021883a 	mov	r16,r2

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
   10dbc:	e0bfff17 	ldw	r2,-4(fp)
   10dc0:	10800003 	ldbu	r2,0(r2)
   10dc4:	10803fcc 	andi	r2,r2,255
   10dc8:	10802960 	cmpeqi	r2,r2,165
   10dcc:	103ff61e 	bne	r2,zero,10da8 <usTaskCheckFreeStackSpace+0x1c>
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
		}

		usCount /= sizeof( portSTACK_TYPE );
   10dd0:	80bfffcc 	andi	r2,r16,65535
   10dd4:	1004d0ba 	srli	r2,r2,2
   10dd8:	1021883a 	mov	r16,r2

		return usCount;
   10ddc:	8005883a 	mov	r2,r16
	}
   10de0:	e037883a 	mov	sp,fp
   10de4:	df000117 	ldw	fp,4(sp)
   10de8:	dc000017 	ldw	r16,0(sp)
   10dec:	dec00204 	addi	sp,sp,8
   10df0:	f800283a 	ret

00010df4 <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
	{
   10df4:	defffa04 	addi	sp,sp,-24
   10df8:	dfc00515 	stw	ra,20(sp)
   10dfc:	df000415 	stw	fp,16(sp)
   10e00:	df000404 	addi	fp,sp,16
   10e04:	e13fff15 	stw	r4,-4(fp)
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
   10e08:	e0bfff17 	ldw	r2,-4(fp)
   10e0c:	1000021e 	bne	r2,zero,10e18 <uxTaskGetStackHighWaterMark+0x24>
   10e10:	d0a90717 	ldw	r2,-23524(gp)
   10e14:	00000106 	br	10e1c <uxTaskGetStackHighWaterMark+0x28>
   10e18:	e0bfff17 	ldw	r2,-4(fp)
   10e1c:	e0bffc15 	stw	r2,-16(fp)

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
   10e20:	e0bffc17 	ldw	r2,-16(fp)
   10e24:	10800c17 	ldw	r2,48(r2)
   10e28:	e0bffd15 	stw	r2,-12(fp)
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
		}
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
   10e2c:	e13ffd17 	ldw	r4,-12(fp)
   10e30:	0010d8c0 	call	10d8c <usTaskCheckFreeStackSpace>
   10e34:	10bfffcc 	andi	r2,r2,65535
   10e38:	e0bffe15 	stw	r2,-8(fp)

		return uxReturn;
   10e3c:	e0bffe17 	ldw	r2,-8(fp)
	}
   10e40:	e037883a 	mov	sp,fp
   10e44:	dfc00117 	ldw	ra,4(sp)
   10e48:	df000017 	ldw	fp,0(sp)
   10e4c:	dec00204 	addi	sp,sp,8
   10e50:	f800283a 	ret

00010e54 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
   10e54:	defffd04 	addi	sp,sp,-12
   10e58:	dfc00215 	stw	ra,8(sp)
   10e5c:	df000115 	stw	fp,4(sp)
   10e60:	df000104 	addi	fp,sp,4
   10e64:	e13fff15 	stw	r4,-4(fp)
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
   10e68:	e0bfff17 	ldw	r2,-4(fp)
   10e6c:	10800c17 	ldw	r2,48(r2)
   10e70:	1009883a 	mov	r4,r2
   10e74:	000e4d80 	call	e4d8 <vPortFree>
		vPortFree( pxTCB );
   10e78:	e13fff17 	ldw	r4,-4(fp)
   10e7c:	000e4d80 	call	e4d8 <vPortFree>
	}
   10e80:	e037883a 	mov	sp,fp
   10e84:	dfc00117 	ldw	ra,4(sp)
   10e88:	df000017 	ldw	fp,0(sp)
   10e8c:	dec00204 	addi	sp,sp,8
   10e90:	f800283a 	ret

00010e94 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
   10e94:	defffe04 	addi	sp,sp,-8
   10e98:	df000115 	stw	fp,4(sp)
   10e9c:	df000104 	addi	fp,sp,4
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
   10ea0:	d0a90717 	ldw	r2,-23524(gp)
   10ea4:	e0bfff15 	stw	r2,-4(fp)

		return xReturn;
   10ea8:	e0bfff17 	ldw	r2,-4(fp)
	}
   10eac:	e037883a 	mov	sp,fp
   10eb0:	df000017 	ldw	fp,0(sp)
   10eb4:	dec00104 	addi	sp,sp,4
   10eb8:	f800283a 	ret

00010ebc <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	portBASE_TYPE xTaskGetSchedulerState( void )
	{
   10ebc:	defffe04 	addi	sp,sp,-8
   10ec0:	df000115 	stw	fp,4(sp)
   10ec4:	df000104 	addi	fp,sp,4
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
   10ec8:	d0a90f17 	ldw	r2,-23492(gp)
   10ecc:	1000021e 	bne	r2,zero,10ed8 <xTaskGetSchedulerState+0x1c>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
   10ed0:	e03fff15 	stw	zero,-4(fp)
   10ed4:	00000706 	br	10ef4 <xTaskGetSchedulerState+0x38>
		}
		else
		{
			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   10ed8:	d0a91017 	ldw	r2,-23488(gp)
   10edc:	1000031e 	bne	r2,zero,10eec <xTaskGetSchedulerState+0x30>
			{
				xReturn = taskSCHEDULER_RUNNING;
   10ee0:	00800044 	movi	r2,1
   10ee4:	e0bfff15 	stw	r2,-4(fp)
   10ee8:	00000206 	br	10ef4 <xTaskGetSchedulerState+0x38>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
   10eec:	00800084 	movi	r2,2
   10ef0:	e0bfff15 	stw	r2,-4(fp)
			}
		}

		return xReturn;
   10ef4:	e0bfff17 	ldw	r2,-4(fp)
	}
   10ef8:	e037883a 	mov	sp,fp
   10efc:	df000017 	ldw	fp,0(sp)
   10f00:	dec00104 	addi	sp,sp,4
   10f04:	f800283a 	ret

00010f08 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
   10f08:	defffc04 	addi	sp,sp,-16
   10f0c:	dfc00315 	stw	ra,12(sp)
   10f10:	df000215 	stw	fp,8(sp)
   10f14:	df000204 	addi	fp,sp,8
   10f18:	e13fff15 	stw	r4,-4(fp)
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
   10f1c:	e0bfff17 	ldw	r2,-4(fp)
   10f20:	e0bffe15 	stw	r2,-8(fp)

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
   10f24:	e0bffe17 	ldw	r2,-8(fp)
   10f28:	10c00b17 	ldw	r3,44(r2)
   10f2c:	d0a90717 	ldw	r2,-23524(gp)
   10f30:	10800b17 	ldw	r2,44(r2)
   10f34:	18802e2e 	bgeu	r3,r2,10ff0 <vTaskPriorityInherit+0xe8>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
   10f38:	d0a90717 	ldw	r2,-23524(gp)
   10f3c:	10800b17 	ldw	r2,44(r2)
   10f40:	00c00144 	movi	r3,5
   10f44:	1887c83a 	sub	r3,r3,r2
   10f48:	e0bffe17 	ldw	r2,-8(fp)
   10f4c:	10c00615 	stw	r3,24(r2)

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
   10f50:	e0bffe17 	ldw	r2,-8(fp)
   10f54:	10c00517 	ldw	r3,20(r2)
   10f58:	e0bffe17 	ldw	r2,-8(fp)
   10f5c:	10800b17 	ldw	r2,44(r2)
   10f60:	11000524 	muli	r4,r2,20
   10f64:	00800134 	movhi	r2,4
   10f68:	109f1e04 	addi	r2,r2,31864
   10f6c:	2085883a 	add	r2,r4,r2
   10f70:	18801b1e 	bne	r3,r2,10fe0 <vTaskPriorityInherit+0xd8>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
   10f74:	e0bffe17 	ldw	r2,-8(fp)
   10f78:	10800104 	addi	r2,r2,4
   10f7c:	1009883a 	mov	r4,r2
   10f80:	003c0fc0 	call	3c0fc <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   10f84:	d0a90717 	ldw	r2,-23524(gp)
   10f88:	10c00b17 	ldw	r3,44(r2)
   10f8c:	e0bffe17 	ldw	r2,-8(fp)
   10f90:	10c00b15 	stw	r3,44(r2)
				prvAddTaskToReadyQueue( pxTCB );
   10f94:	e0bffe17 	ldw	r2,-8(fp)
   10f98:	10800b17 	ldw	r2,44(r2)
   10f9c:	d0e90e17 	ldw	r3,-23496(gp)
   10fa0:	1880032e 	bgeu	r3,r2,10fb0 <vTaskPriorityInherit+0xa8>
   10fa4:	e0bffe17 	ldw	r2,-8(fp)
   10fa8:	10800b17 	ldw	r2,44(r2)
   10fac:	d0a90e15 	stw	r2,-23496(gp)
   10fb0:	e0bffe17 	ldw	r2,-8(fp)
   10fb4:	10800b17 	ldw	r2,44(r2)
   10fb8:	10c00524 	muli	r3,r2,20
   10fbc:	00800134 	movhi	r2,4
   10fc0:	109f1e04 	addi	r2,r2,31864
   10fc4:	1887883a 	add	r3,r3,r2
   10fc8:	e0bffe17 	ldw	r2,-8(fp)
   10fcc:	10800104 	addi	r2,r2,4
   10fd0:	1809883a 	mov	r4,r3
   10fd4:	100b883a 	mov	r5,r2
   10fd8:	003bf900 	call	3bf90 <vListInsertEnd>
   10fdc:	00000406 	br	10ff0 <vTaskPriorityInherit+0xe8>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   10fe0:	d0a90717 	ldw	r2,-23524(gp)
   10fe4:	10c00b17 	ldw	r3,44(r2)
   10fe8:	e0bffe17 	ldw	r2,-8(fp)
   10fec:	10c00b15 	stw	r3,44(r2)
			}

			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
		}
	}
   10ff0:	e037883a 	mov	sp,fp
   10ff4:	dfc00117 	ldw	ra,4(sp)
   10ff8:	df000017 	ldw	fp,0(sp)
   10ffc:	dec00204 	addi	sp,sp,8
   11000:	f800283a 	ret

00011004 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
   11004:	defffc04 	addi	sp,sp,-16
   11008:	dfc00315 	stw	ra,12(sp)
   1100c:	df000215 	stw	fp,8(sp)
   11010:	df000204 	addi	fp,sp,8
   11014:	e13fff15 	stw	r4,-4(fp)
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
   11018:	e0bfff17 	ldw	r2,-4(fp)
   1101c:	e0bffe15 	stw	r2,-8(fp)

		if( pxMutexHolder != NULL )
   11020:	e0bfff17 	ldw	r2,-4(fp)
   11024:	10002526 	beq	r2,zero,110bc <vTaskPriorityDisinherit+0xb8>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   11028:	e0bffe17 	ldw	r2,-8(fp)
   1102c:	10c00b17 	ldw	r3,44(r2)
   11030:	e0bffe17 	ldw	r2,-8(fp)
   11034:	10801a17 	ldw	r2,104(r2)
   11038:	18802026 	beq	r3,r2,110bc <vTaskPriorityDisinherit+0xb8>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
   1103c:	e0bffe17 	ldw	r2,-8(fp)
   11040:	10800104 	addi	r2,r2,4
   11044:	1009883a 	mov	r4,r2
   11048:	003c0fc0 	call	3c0fc <vListRemove>

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
   1104c:	e0bffe17 	ldw	r2,-8(fp)
   11050:	10c01a17 	ldw	r3,104(r2)
   11054:	e0bffe17 	ldw	r2,-8(fp)
   11058:	10c00b15 	stw	r3,44(r2)
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
   1105c:	e0bffe17 	ldw	r2,-8(fp)
   11060:	10800b17 	ldw	r2,44(r2)
   11064:	00c00144 	movi	r3,5
   11068:	1887c83a 	sub	r3,r3,r2
   1106c:	e0bffe17 	ldw	r2,-8(fp)
   11070:	10c00615 	stw	r3,24(r2)
				prvAddTaskToReadyQueue( pxTCB );
   11074:	e0bffe17 	ldw	r2,-8(fp)
   11078:	10800b17 	ldw	r2,44(r2)
   1107c:	d0e90e17 	ldw	r3,-23496(gp)
   11080:	1880032e 	bgeu	r3,r2,11090 <vTaskPriorityDisinherit+0x8c>
   11084:	e0bffe17 	ldw	r2,-8(fp)
   11088:	10800b17 	ldw	r2,44(r2)
   1108c:	d0a90e15 	stw	r2,-23496(gp)
   11090:	e0bffe17 	ldw	r2,-8(fp)
   11094:	10800b17 	ldw	r2,44(r2)
   11098:	10c00524 	muli	r3,r2,20
   1109c:	00800134 	movhi	r2,4
   110a0:	109f1e04 	addi	r2,r2,31864
   110a4:	1887883a 	add	r3,r3,r2
   110a8:	e0bffe17 	ldw	r2,-8(fp)
   110ac:	10800104 	addi	r2,r2,4
   110b0:	1809883a 	mov	r4,r3
   110b4:	100b883a 	mov	r5,r2
   110b8:	003bf900 	call	3bf90 <vListInsertEnd>
			}
		}
	}
   110bc:	e037883a 	mov	sp,fp
   110c0:	dfc00117 	ldw	ra,4(sp)
   110c4:	df000017 	ldw	fp,0(sp)
   110c8:	dec00204 	addi	sp,sp,8
   110cc:	f800283a 	ret

000110d0 <vTaskEnterCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
   110d0:	defffe04 	addi	sp,sp,-8
   110d4:	dfc00115 	stw	ra,4(sp)
   110d8:	df000015 	stw	fp,0(sp)
   110dc:	d839883a 	mov	fp,sp
		portDISABLE_INTERRUPTS();
   110e0:	003c1b40 	call	3c1b4 <enh_alt_irq_disable_all>

		if( xSchedulerRunning != pdFALSE )
   110e4:	d0a90f17 	ldw	r2,-23492(gp)
   110e8:	10000426 	beq	r2,zero,110fc <vTaskEnterCritical+0x2c>
		{
			( pxCurrentTCB->uxCriticalNesting )++;
   110ec:	d0a90717 	ldw	r2,-23524(gp)
   110f0:	10c01717 	ldw	r3,92(r2)
   110f4:	18c00044 	addi	r3,r3,1
   110f8:	10c01715 	stw	r3,92(r2)
		}
	}
   110fc:	e037883a 	mov	sp,fp
   11100:	dfc00117 	ldw	ra,4(sp)
   11104:	df000017 	ldw	fp,0(sp)
   11108:	dec00204 	addi	sp,sp,8
   1110c:	f800283a 	ret

00011110 <vTaskExitCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

void vTaskExitCritical( void )
{
   11110:	defffe04 	addi	sp,sp,-8
   11114:	dfc00115 	stw	ra,4(sp)
   11118:	df000015 	stw	fp,0(sp)
   1111c:	d839883a 	mov	fp,sp
	if( xSchedulerRunning != pdFALSE )
   11120:	d0a90f17 	ldw	r2,-23492(gp)
   11124:	10000b26 	beq	r2,zero,11154 <vTaskExitCritical+0x44>
	{
		if( pxCurrentTCB->uxCriticalNesting > 0U )
   11128:	d0a90717 	ldw	r2,-23524(gp)
   1112c:	10801717 	ldw	r2,92(r2)
   11130:	10000826 	beq	r2,zero,11154 <vTaskExitCritical+0x44>
		{
			( pxCurrentTCB->uxCriticalNesting )--;
   11134:	d0a90717 	ldw	r2,-23524(gp)
   11138:	10c01717 	ldw	r3,92(r2)
   1113c:	18ffffc4 	addi	r3,r3,-1
   11140:	10c01715 	stw	r3,92(r2)

			if( pxCurrentTCB->uxCriticalNesting == 0U )
   11144:	d0a90717 	ldw	r2,-23524(gp)
   11148:	10801717 	ldw	r2,92(r2)
   1114c:	1000011e 	bne	r2,zero,11154 <vTaskExitCritical+0x44>
			{
				portENABLE_INTERRUPTS();
   11150:	003c2000 	call	3c200 <enh_alt_irq_enable_all>
			}
		}
	}
}
   11154:	e037883a 	mov	sp,fp
   11158:	dfc00117 	ldw	ra,4(sp)
   1115c:	df000017 	ldw	fp,0(sp)
   11160:	dec00204 	addi	sp,sp,8
   11164:	f800283a 	ret

00011168 <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

portBASE_TYPE xTimerCreateTimerTask( void )
{
   11168:	defff904 	addi	sp,sp,-28
   1116c:	dfc00615 	stw	ra,24(sp)
   11170:	df000515 	stw	fp,20(sp)
   11174:	df000504 	addi	fp,sp,20
portBASE_TYPE xReturn = pdFAIL;
   11178:	e03fff15 	stw	zero,-4(fp)

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
   1117c:	001192c0 	call	1192c <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
   11180:	d0a91717 	ldw	r2,-23460(gp)
   11184:	10000d26 	beq	r2,zero,111bc <xTimerCreateTimerTask+0x54>
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );	
		}
		#else
		{
			/* Create the timer task without storing its handle. */
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
   11188:	00800144 	movi	r2,5
   1118c:	d8800015 	stw	r2,0(sp)
   11190:	d8000115 	stw	zero,4(sp)
   11194:	d8000215 	stw	zero,8(sp)
   11198:	d8000315 	stw	zero,12(sp)
   1119c:	01000074 	movhi	r4,1
   111a0:	21050304 	addi	r4,r4,5132
   111a4:	01400134 	movhi	r5,4
   111a8:	29427404 	addi	r5,r5,2512
   111ac:	018c9604 	movi	r6,12888
   111b0:	000f883a 	mov	r7,zero
   111b4:	000f5140 	call	f514 <xTaskGenericCreate>
   111b8:	e0bfff15 	stw	r2,-4(fp)
		}
		#endif
	}

	configASSERT( xReturn );
	return xReturn;
   111bc:	e0bfff17 	ldw	r2,-4(fp)
}
   111c0:	e037883a 	mov	sp,fp
   111c4:	dfc00117 	ldw	ra,4(sp)
   111c8:	df000017 	ldw	fp,0(sp)
   111cc:	dec00204 	addi	sp,sp,8
   111d0:	f800283a 	ret

000111d4 <xTimerCreate>:
/*-----------------------------------------------------------*/

xTimerHandle xTimerCreate( const signed char *pcTimerName, portTickType xTimerPeriodInTicks, unsigned portBASE_TYPE uxAutoReload, void *pvTimerID, tmrTIMER_CALLBACK pxCallbackFunction )
{
   111d4:	defff904 	addi	sp,sp,-28
   111d8:	dfc00615 	stw	ra,24(sp)
   111dc:	df000515 	stw	fp,20(sp)
   111e0:	df000504 	addi	fp,sp,20
   111e4:	e13ffc15 	stw	r4,-16(fp)
   111e8:	e17ffd15 	stw	r5,-12(fp)
   111ec:	e1bffe15 	stw	r6,-8(fp)
   111f0:	e1ffff15 	stw	r7,-4(fp)
xTIMER *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( portTickType ) 0U )
   111f4:	e0bffd17 	ldw	r2,-12(fp)
   111f8:	1000021e 	bne	r2,zero,11204 <xTimerCreate+0x30>
	{
		pxNewTimer = NULL;
   111fc:	e03ffb15 	stw	zero,-20(fp)
   11200:	00001906 	br	11268 <xTimerCreate+0x94>
		configASSERT( ( xTimerPeriodInTicks > 0 ) );
	}
	else
	{
		pxNewTimer = ( xTIMER * ) pvPortMalloc( sizeof( xTIMER ) );
   11204:	01000a04 	movi	r4,40
   11208:	000e4980 	call	e498 <pvPortMalloc>
   1120c:	e0bffb15 	stw	r2,-20(fp)
		if( pxNewTimer != NULL )
   11210:	e0bffb17 	ldw	r2,-20(fp)
   11214:	10001426 	beq	r2,zero,11268 <xTimerCreate+0x94>
		{
			/* Ensure the infrastructure used by the timer service task has been
			created/initialised. */
			prvCheckForValidListAndQueue();
   11218:	001192c0 	call	1192c <prvCheckForValidListAndQueue>
	
			/* Initialise the timer structure members using the function parameters. */
			pxNewTimer->pcTimerName = pcTimerName;
   1121c:	e0bffb17 	ldw	r2,-20(fp)
   11220:	e0fffc17 	ldw	r3,-16(fp)
   11224:	10c00015 	stw	r3,0(r2)
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
   11228:	e0bffb17 	ldw	r2,-20(fp)
   1122c:	e0fffd17 	ldw	r3,-12(fp)
   11230:	10c00615 	stw	r3,24(r2)
			pxNewTimer->uxAutoReload = uxAutoReload;
   11234:	e0bffb17 	ldw	r2,-20(fp)
   11238:	e0fffe17 	ldw	r3,-8(fp)
   1123c:	10c00715 	stw	r3,28(r2)
			pxNewTimer->pvTimerID = pvTimerID;
   11240:	e0bffb17 	ldw	r2,-20(fp)
   11244:	e0ffff17 	ldw	r3,-4(fp)
   11248:	10c00815 	stw	r3,32(r2)
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
   1124c:	e0bffb17 	ldw	r2,-20(fp)
   11250:	e0c00217 	ldw	r3,8(fp)
   11254:	10c00915 	stw	r3,36(r2)
			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
   11258:	e0bffb17 	ldw	r2,-20(fp)
   1125c:	10800104 	addi	r2,r2,4
   11260:	1009883a 	mov	r4,r2
   11264:	003bf680 	call	3bf68 <vListInitialiseItem>
		{
			traceTIMER_CREATE_FAILED();
		}
	}
	
	return ( xTimerHandle ) pxNewTimer;
   11268:	e0bffb17 	ldw	r2,-20(fp)
}
   1126c:	e037883a 	mov	sp,fp
   11270:	dfc00117 	ldw	ra,4(sp)
   11274:	df000017 	ldw	fp,0(sp)
   11278:	dec00204 	addi	sp,sp,8
   1127c:	f800283a 	ret

00011280 <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
   11280:	defff604 	addi	sp,sp,-40
   11284:	dfc00915 	stw	ra,36(sp)
   11288:	df000815 	stw	fp,32(sp)
   1128c:	df000804 	addi	fp,sp,32
   11290:	e13ffc15 	stw	r4,-16(fp)
   11294:	e17ffd15 	stw	r5,-12(fp)
   11298:	e1bffe15 	stw	r6,-8(fp)
   1129c:	e1ffff15 	stw	r7,-4(fp)
portBASE_TYPE xReturn = pdFAIL;
   112a0:	e03ff815 	stw	zero,-32(fp)
xTIMER_MESSAGE xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
   112a4:	d0a91717 	ldw	r2,-23460(gp)
   112a8:	10002526 	beq	r2,zero,11340 <xTimerGenericCommand+0xc0>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
   112ac:	e0bffd17 	ldw	r2,-12(fp)
   112b0:	e0bff915 	stw	r2,-28(fp)
		xMessage.xMessageValue = xOptionalValue;
   112b4:	e0bffe17 	ldw	r2,-8(fp)
   112b8:	e0bffa15 	stw	r2,-24(fp)
		xMessage.pxTimer = ( xTIMER * ) xTimer;
   112bc:	e0bffc17 	ldw	r2,-16(fp)
   112c0:	e0bffb15 	stw	r2,-20(fp)

		if( pxHigherPriorityTaskWoken == NULL )
   112c4:	e0bfff17 	ldw	r2,-4(fp)
   112c8:	1000151e 	bne	r2,zero,11320 <xTimerGenericCommand+0xa0>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
   112cc:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   112d0:	10800058 	cmpnei	r2,r2,1
   112d4:	1000091e 	bne	r2,zero,112fc <xTimerGenericCommand+0x7c>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
   112d8:	d0e91717 	ldw	r3,-23460(gp)
   112dc:	e0bff904 	addi	r2,fp,-28
   112e0:	1809883a 	mov	r4,r3
   112e4:	100b883a 	mov	r5,r2
   112e8:	e1800217 	ldw	r6,8(fp)
   112ec:	000f883a 	mov	r7,zero
   112f0:	000e95c0 	call	e95c <xQueueGenericSend>
   112f4:	e0bff815 	stw	r2,-32(fp)
   112f8:	00001106 	br	11340 <xTimerGenericCommand+0xc0>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
   112fc:	d0e91717 	ldw	r3,-23460(gp)
   11300:	e0bff904 	addi	r2,fp,-28
   11304:	1809883a 	mov	r4,r3
   11308:	100b883a 	mov	r5,r2
   1130c:	000d883a 	mov	r6,zero
   11310:	000f883a 	mov	r7,zero
   11314:	000e95c0 	call	e95c <xQueueGenericSend>
   11318:	e0bff815 	stw	r2,-32(fp)
   1131c:	00000806 	br	11340 <xTimerGenericCommand+0xc0>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
   11320:	d0e91717 	ldw	r3,-23460(gp)
   11324:	e0bff904 	addi	r2,fp,-28
   11328:	1809883a 	mov	r4,r3
   1132c:	100b883a 	mov	r5,r2
   11330:	e1bfff17 	ldw	r6,-4(fp)
   11334:	000f883a 	mov	r7,zero
   11338:	000eb0c0 	call	eb0c <xQueueGenericSendFromISR>
   1133c:	e0bff815 	stw	r2,-32(fp)
		}
		
		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
	}
	
	return xReturn;
   11340:	e0bff817 	ldw	r2,-32(fp)
}
   11344:	e037883a 	mov	sp,fp
   11348:	dfc00117 	ldw	ra,4(sp)
   1134c:	df000017 	ldw	fp,0(sp)
   11350:	dec00204 	addi	sp,sp,8
   11354:	f800283a 	ret

00011358 <prvProcessExpiredTimer>:
	
#endif
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( portTickType xNextExpireTime, portTickType xTimeNow )
{
   11358:	defff904 	addi	sp,sp,-28
   1135c:	dfc00615 	stw	ra,24(sp)
   11360:	df000515 	stw	fp,20(sp)
   11364:	df000504 	addi	fp,sp,20
   11368:	e13ffe15 	stw	r4,-8(fp)
   1136c:	e17fff15 	stw	r5,-4(fp)
xTIMER *pxTimer;
portBASE_TYPE xResult;

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
   11370:	d0a91517 	ldw	r2,-23468(gp)
   11374:	10800317 	ldw	r2,12(r2)
   11378:	10800317 	ldw	r2,12(r2)
   1137c:	e0bffc15 	stw	r2,-16(fp)
	vListRemove( &( pxTimer->xTimerListItem ) );
   11380:	e0bffc17 	ldw	r2,-16(fp)
   11384:	10800104 	addi	r2,r2,4
   11388:	1009883a 	mov	r4,r2
   1138c:	003c0fc0 	call	3c0fc <vListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
   11390:	e0bffc17 	ldw	r2,-16(fp)
   11394:	10800717 	ldw	r2,28(r2)
   11398:	10800058 	cmpnei	r2,r2,1
   1139c:	1000121e 	bne	r2,zero,113e8 <prvProcessExpiredTimer+0x90>
		a time relative to anything other than the current time.  It
		will therefore be inserted into the correct list relative to
		the time this task thinks it is now, even if a command to
		switch lists due to a tick count overflow is already waiting in
		the timer queue. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
   113a0:	e0bffc17 	ldw	r2,-16(fp)
   113a4:	10c00617 	ldw	r3,24(r2)
   113a8:	e0bffe17 	ldw	r2,-8(fp)
   113ac:	1885883a 	add	r2,r3,r2
   113b0:	e13ffc17 	ldw	r4,-16(fp)
   113b4:	100b883a 	mov	r5,r2
   113b8:	e1bfff17 	ldw	r6,-4(fp)
   113bc:	e1fffe17 	ldw	r7,-8(fp)
   113c0:	00115bc0 	call	115bc <prvInsertTimerInActiveList>
   113c4:	10800058 	cmpnei	r2,r2,1
   113c8:	1000071e 	bne	r2,zero,113e8 <prvProcessExpiredTimer+0x90>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
   113cc:	d8000015 	stw	zero,0(sp)
   113d0:	e13ffc17 	ldw	r4,-16(fp)
   113d4:	000b883a 	mov	r5,zero
   113d8:	e1bffe17 	ldw	r6,-8(fp)
   113dc:	000f883a 	mov	r7,zero
   113e0:	00112800 	call	11280 <xTimerGenericCommand>
   113e4:	e0bffd15 	stw	r2,-12(fp)
			( void ) xResult;
		}
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
   113e8:	e0bffc17 	ldw	r2,-16(fp)
   113ec:	10800917 	ldw	r2,36(r2)
   113f0:	e13ffc17 	ldw	r4,-16(fp)
   113f4:	103ee83a 	callr	r2
}
   113f8:	e037883a 	mov	sp,fp
   113fc:	dfc00117 	ldw	ra,4(sp)
   11400:	df000017 	ldw	fp,0(sp)
   11404:	dec00204 	addi	sp,sp,8
   11408:	f800283a 	ret

0001140c <prvTimerTask>:
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
   1140c:	defffb04 	addi	sp,sp,-20
   11410:	dfc00415 	stw	ra,16(sp)
   11414:	df000315 	stw	fp,12(sp)
   11418:	df000304 	addi	fp,sp,12
   1141c:	e13fff15 	stw	r4,-4(fp)

	for( ;; )
	{
		/* Query the timers list to see if it contains any timers, and if so,
		obtain the time at which the next timer will expire. */
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
   11420:	e0bffe04 	addi	r2,fp,-8
   11424:	1009883a 	mov	r4,r2
   11428:	00114f00 	call	114f0 <prvGetNextExpireTime>
   1142c:	e0bffd15 	stw	r2,-12(fp)

		/* If a timer has expired, process it.  Otherwise, block this task
		until either a timer does expire, or a command is received. */
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
   11430:	e0bffe17 	ldw	r2,-8(fp)
   11434:	e13ffd17 	ldw	r4,-12(fp)
   11438:	100b883a 	mov	r5,r2
   1143c:	00114480 	call	11448 <prvProcessTimerOrBlockTask>
		
		/* Empty the command queue. */
		prvProcessReceivedCommands();		
   11440:	00116980 	call	11698 <prvProcessReceivedCommands>
	}
   11444:	003ff606 	br	11420 <prvTimerTask+0x14>

00011448 <prvProcessTimerOrBlockTask>:
}
/*-----------------------------------------------------------*/

static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
   11448:	defffa04 	addi	sp,sp,-24
   1144c:	dfc00515 	stw	ra,20(sp)
   11450:	df000415 	stw	fp,16(sp)
   11454:	df000404 	addi	fp,sp,16
   11458:	e13ffe15 	stw	r4,-8(fp)
   1145c:	e17fff15 	stw	r5,-4(fp)
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
   11460:	000fef80 	call	fef8 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
   11464:	e0bffd04 	addi	r2,fp,-12
   11468:	1009883a 	mov	r4,r2
   1146c:	00115500 	call	11550 <prvSampleTimeNow>
   11470:	e0bffc15 	stw	r2,-16(fp)
		if( xTimerListsWereSwitched == pdFALSE )
   11474:	e0bffd17 	ldw	r2,-12(fp)
   11478:	1000151e 	bne	r2,zero,114d0 <prvProcessTimerOrBlockTask+0x88>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
   1147c:	e0bfff17 	ldw	r2,-4(fp)
   11480:	1000081e 	bne	r2,zero,114a4 <prvProcessTimerOrBlockTask+0x5c>
   11484:	e0bffe17 	ldw	r2,-8(fp)
   11488:	e0fffc17 	ldw	r3,-16(fp)
   1148c:	18800536 	bltu	r3,r2,114a4 <prvProcessTimerOrBlockTask+0x5c>
			{
				xTaskResumeAll();
   11490:	000ff200 	call	ff20 <xTaskResumeAll>
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
   11494:	e13ffe17 	ldw	r4,-8(fp)
   11498:	e17ffc17 	ldw	r5,-16(fp)
   1149c:	00113580 	call	11358 <prvProcessExpiredTimer>
   114a0:	00000e06 	br	114dc <prvProcessTimerOrBlockTask+0x94>
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
   114a4:	d0e91717 	ldw	r3,-23460(gp)
   114a8:	e13ffe17 	ldw	r4,-8(fp)
   114ac:	e0bffc17 	ldw	r2,-16(fp)
   114b0:	2085c83a 	sub	r2,r4,r2
   114b4:	1809883a 	mov	r4,r3
   114b8:	100b883a 	mov	r5,r2
   114bc:	000f4780 	call	f478 <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
   114c0:	000ff200 	call	ff20 <xTaskResumeAll>
   114c4:	1000041e 	bne	r2,zero,114d8 <prvProcessTimerOrBlockTask+0x90>
				{
					/* Yield to wait for either a command to arrive, or the block time
					to expire.  If a command arrived between the critical section being
					exited and this yield then the yield will not cause the task
					to block. */
					portYIELD_WITHIN_API();
   114c8:	003b683a 	trap	0
   114cc:	00000206 	br	114d8 <prvProcessTimerOrBlockTask+0x90>
				}
			}
		}
		else
		{
			xTaskResumeAll();
   114d0:	000ff200 	call	ff20 <xTaskResumeAll>
   114d4:	00000106 	br	114dc <prvProcessTimerOrBlockTask+0x94>
				{
					/* Yield to wait for either a command to arrive, or the block time
					to expire.  If a command arrived between the critical section being
					exited and this yield then the yield will not cause the task
					to block. */
					portYIELD_WITHIN_API();
   114d8:	0001883a 	nop
		else
		{
			xTaskResumeAll();
		}
	}
}
   114dc:	e037883a 	mov	sp,fp
   114e0:	dfc00117 	ldw	ra,4(sp)
   114e4:	df000017 	ldw	fp,0(sp)
   114e8:	dec00204 	addi	sp,sp,8
   114ec:	f800283a 	ret

000114f0 <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

static portTickType prvGetNextExpireTime( portBASE_TYPE *pxListWasEmpty )
{
   114f0:	defffd04 	addi	sp,sp,-12
   114f4:	df000215 	stw	fp,8(sp)
   114f8:	df000204 	addi	fp,sp,8
   114fc:	e13fff15 	stw	r4,-4(fp)
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
   11500:	d0a91517 	ldw	r2,-23468(gp)
   11504:	10800017 	ldw	r2,0(r2)
   11508:	1005003a 	cmpeq	r2,r2,zero
   1150c:	10c03fcc 	andi	r3,r2,255
   11510:	e0bfff17 	ldw	r2,-4(fp)
   11514:	10c00015 	stw	r3,0(r2)
	if( *pxListWasEmpty == pdFALSE )
   11518:	e0bfff17 	ldw	r2,-4(fp)
   1151c:	10800017 	ldw	r2,0(r2)
   11520:	1000051e 	bne	r2,zero,11538 <prvGetNextExpireTime+0x48>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
   11524:	d0a91517 	ldw	r2,-23468(gp)
   11528:	10800317 	ldw	r2,12(r2)
   1152c:	10800017 	ldw	r2,0(r2)
   11530:	e0bffe15 	stw	r2,-8(fp)
   11534:	00000106 	br	1153c <prvGetNextExpireTime+0x4c>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( portTickType ) 0U;
   11538:	e03ffe15 	stw	zero,-8(fp)
	}

	return xNextExpireTime;
   1153c:	e0bffe17 	ldw	r2,-8(fp)
}
   11540:	e037883a 	mov	sp,fp
   11544:	df000017 	ldw	fp,0(sp)
   11548:	dec00104 	addi	sp,sp,4
   1154c:	f800283a 	ret

00011550 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
   11550:	defffc04 	addi	sp,sp,-16
   11554:	dfc00315 	stw	ra,12(sp)
   11558:	df000215 	stw	fp,8(sp)
   1155c:	df000204 	addi	fp,sp,8
   11560:	e13fff15 	stw	r4,-4(fp)
portTickType xTimeNow;
PRIVILEGED_DATA static portTickType xLastTime = ( portTickType ) 0U;

	xTimeNow = xTaskGetTickCount();
   11564:	001006c0 	call	1006c <xTaskGetTickCount>
   11568:	e0bffe15 	stw	r2,-8(fp)
	
	if( xTimeNow < xLastTime )
   1156c:	d0a91817 	ldw	r2,-23456(gp)
   11570:	e0fffe17 	ldw	r3,-8(fp)
   11574:	1880072e 	bgeu	r3,r2,11594 <prvSampleTimeNow+0x44>
	{
		prvSwitchTimerLists( xLastTime );
   11578:	d0a91817 	ldw	r2,-23456(gp)
   1157c:	1009883a 	mov	r4,r2
   11580:	001181c0 	call	1181c <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
   11584:	e0bfff17 	ldw	r2,-4(fp)
   11588:	00c00044 	movi	r3,1
   1158c:	10c00015 	stw	r3,0(r2)
   11590:	00000206 	br	1159c <prvSampleTimeNow+0x4c>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
   11594:	e0bfff17 	ldw	r2,-4(fp)
   11598:	10000015 	stw	zero,0(r2)
	}
	
	xLastTime = xTimeNow;
   1159c:	e0bffe17 	ldw	r2,-8(fp)
   115a0:	d0a91815 	stw	r2,-23456(gp)
	
	return xTimeNow;
   115a4:	e0bffe17 	ldw	r2,-8(fp)
}
   115a8:	e037883a 	mov	sp,fp
   115ac:	dfc00117 	ldw	ra,4(sp)
   115b0:	df000017 	ldw	fp,0(sp)
   115b4:	dec00204 	addi	sp,sp,8
   115b8:	f800283a 	ret

000115bc <prvInsertTimerInActiveList>:
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
   115bc:	defff904 	addi	sp,sp,-28
   115c0:	dfc00615 	stw	ra,24(sp)
   115c4:	df000515 	stw	fp,20(sp)
   115c8:	df000504 	addi	fp,sp,20
   115cc:	e13ffc15 	stw	r4,-16(fp)
   115d0:	e17ffd15 	stw	r5,-12(fp)
   115d4:	e1bffe15 	stw	r6,-8(fp)
   115d8:	e1ffff15 	stw	r7,-4(fp)
portBASE_TYPE xProcessTimerNow = pdFALSE;
   115dc:	e03ffb15 	stw	zero,-20(fp)

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
   115e0:	e0bffc17 	ldw	r2,-16(fp)
   115e4:	e0fffd17 	ldw	r3,-12(fp)
   115e8:	10c00115 	stw	r3,4(r2)
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
   115ec:	e0bffc17 	ldw	r2,-16(fp)
   115f0:	e0fffc17 	ldw	r3,-16(fp)
   115f4:	10c00415 	stw	r3,16(r2)
	
	if( xNextExpiryTime <= xTimeNow )
   115f8:	e0bffd17 	ldw	r2,-12(fp)
   115fc:	e0fffe17 	ldw	r3,-8(fp)
   11600:	18801036 	bltu	r3,r2,11644 <prvInsertTimerInActiveList+0x88>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( portTickType ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks )
   11604:	e0fffe17 	ldw	r3,-8(fp)
   11608:	e0bfff17 	ldw	r2,-4(fp)
   1160c:	1887c83a 	sub	r3,r3,r2
   11610:	e0bffc17 	ldw	r2,-16(fp)
   11614:	10800617 	ldw	r2,24(r2)
   11618:	18800336 	bltu	r3,r2,11628 <prvInsertTimerInActiveList+0x6c>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
   1161c:	00800044 	movi	r2,1
   11620:	e0bffb15 	stw	r2,-20(fp)
   11624:	00001606 	br	11680 <prvInsertTimerInActiveList+0xc4>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
   11628:	d0e91617 	ldw	r3,-23464(gp)
   1162c:	e0bffc17 	ldw	r2,-16(fp)
   11630:	10800104 	addi	r2,r2,4
   11634:	1809883a 	mov	r4,r3
   11638:	100b883a 	mov	r5,r2
   1163c:	003c0280 	call	3c028 <vListInsert>
   11640:	00000f06 	br	11680 <prvInsertTimerInActiveList+0xc4>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
   11644:	e0fffe17 	ldw	r3,-8(fp)
   11648:	e0bfff17 	ldw	r2,-4(fp)
   1164c:	1880062e 	bgeu	r3,r2,11668 <prvInsertTimerInActiveList+0xac>
   11650:	e0fffd17 	ldw	r3,-12(fp)
   11654:	e0bfff17 	ldw	r2,-4(fp)
   11658:	18800336 	bltu	r3,r2,11668 <prvInsertTimerInActiveList+0xac>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
   1165c:	00800044 	movi	r2,1
   11660:	e0bffb15 	stw	r2,-20(fp)
   11664:	00000606 	br	11680 <prvInsertTimerInActiveList+0xc4>
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
   11668:	d0e91517 	ldw	r3,-23468(gp)
   1166c:	e0bffc17 	ldw	r2,-16(fp)
   11670:	10800104 	addi	r2,r2,4
   11674:	1809883a 	mov	r4,r3
   11678:	100b883a 	mov	r5,r2
   1167c:	003c0280 	call	3c028 <vListInsert>
		}
	}

	return xProcessTimerNow;
   11680:	e0bffb17 	ldw	r2,-20(fp)
}
   11684:	e037883a 	mov	sp,fp
   11688:	dfc00117 	ldw	ra,4(sp)
   1168c:	df000017 	ldw	fp,0(sp)
   11690:	dec00204 	addi	sp,sp,8
   11694:	f800283a 	ret

00011698 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

static void	prvProcessReceivedCommands( void )
{
   11698:	defff604 	addi	sp,sp,-40
   1169c:	dfc00915 	stw	ra,36(sp)
   116a0:	df000815 	stw	fp,32(sp)
   116a4:	df000804 	addi	fp,sp,32
portBASE_TYPE xTimerListsWereSwitched, xResult;
portTickType xTimeNow;

	/* In this case the xTimerListsWereSwitched parameter is not used, but it
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
   116a8:	e0bfff04 	addi	r2,fp,-4
   116ac:	1009883a 	mov	r4,r2
   116b0:	00115500 	call	11550 <prvSampleTimeNow>
   116b4:	e0bff915 	stw	r2,-28(fp)

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
   116b8:	00004b06 	br	117e8 <prvProcessReceivedCommands+0x150>
	{
		pxTimer = xMessage.pxTimer;
   116bc:	e0bffe17 	ldw	r2,-8(fp)
   116c0:	e0bffa15 	stw	r2,-24(fp)

		/* Is the timer already in a list of active timers?  When the command
		is trmCOMMAND_PROCESS_TIMER_OVERFLOW, the timer will be NULL as the
		command is to the task rather than to an individual timer. */
		if( pxTimer != NULL )
   116c4:	e0bffa17 	ldw	r2,-24(fp)
   116c8:	10000726 	beq	r2,zero,116e8 <prvProcessReceivedCommands+0x50>
		{
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
   116cc:	e0bffa17 	ldw	r2,-24(fp)
   116d0:	10800517 	ldw	r2,20(r2)
   116d4:	10000426 	beq	r2,zero,116e8 <prvProcessReceivedCommands+0x50>
			{
				/* The timer is in a list, remove it. */
				vListRemove( &( pxTimer->xTimerListItem ) );
   116d8:	e0bffa17 	ldw	r2,-24(fp)
   116dc:	10800104 	addi	r2,r2,4
   116e0:	1009883a 	mov	r4,r2
   116e4:	003c0fc0 	call	3c0fc <vListRemove>
			}
		}

		traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.xMessageValue );
		
		switch( xMessage.xMessageID )
   116e8:	e0bffc17 	ldw	r2,-16(fp)
   116ec:	10c00060 	cmpeqi	r3,r2,1
   116f0:	18003a1e 	bne	r3,zero,117dc <prvProcessReceivedCommands+0x144>
   116f4:	10c00088 	cmpgei	r3,r2,2
   116f8:	1800021e 	bne	r3,zero,11704 <prvProcessReceivedCommands+0x6c>
   116fc:	10000626 	beq	r2,zero,11718 <prvProcessReceivedCommands+0x80>
   11700:	00003506 	br	117d8 <prvProcessReceivedCommands+0x140>
   11704:	10c000a0 	cmpeqi	r3,r2,2
   11708:	1800231e 	bne	r3,zero,11798 <prvProcessReceivedCommands+0x100>
   1170c:	108000e0 	cmpeqi	r2,r2,3
   11710:	10002e1e 	bne	r2,zero,117cc <prvProcessReceivedCommands+0x134>
   11714:	00003006 	br	117d8 <prvProcessReceivedCommands+0x140>
		{
			case tmrCOMMAND_START :	
				/* Start or restart a timer. */
				if( prvInsertTimerInActiveList( pxTimer,  xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.xMessageValue ) == pdTRUE )
   11718:	e0fffd17 	ldw	r3,-12(fp)
   1171c:	e0bffa17 	ldw	r2,-24(fp)
   11720:	10800617 	ldw	r2,24(r2)
   11724:	1887883a 	add	r3,r3,r2
   11728:	e0bffd17 	ldw	r2,-12(fp)
   1172c:	e13ffa17 	ldw	r4,-24(fp)
   11730:	180b883a 	mov	r5,r3
   11734:	e1bff917 	ldw	r6,-28(fp)
   11738:	100f883a 	mov	r7,r2
   1173c:	00115bc0 	call	115bc <prvInsertTimerInActiveList>
   11740:	10800058 	cmpnei	r2,r2,1
   11744:	1000271e 	bne	r2,zero,117e4 <prvProcessReceivedCommands+0x14c>
				{
					/* The timer expired before it was added to the active timer
					list.  Process it now. */
					pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
   11748:	e0bffa17 	ldw	r2,-24(fp)
   1174c:	10800917 	ldw	r2,36(r2)
   11750:	e13ffa17 	ldw	r4,-24(fp)
   11754:	103ee83a 	callr	r2

					if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
   11758:	e0bffa17 	ldw	r2,-24(fp)
   1175c:	10800717 	ldw	r2,28(r2)
   11760:	10800058 	cmpnei	r2,r2,1
   11764:	10001f1e 	bne	r2,zero,117e4 <prvProcessReceivedCommands+0x14c>
					{
						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
   11768:	e0fffd17 	ldw	r3,-12(fp)
   1176c:	e0bffa17 	ldw	r2,-24(fp)
   11770:	10800617 	ldw	r2,24(r2)
   11774:	1885883a 	add	r2,r3,r2
   11778:	d8000015 	stw	zero,0(sp)
   1177c:	e13ffa17 	ldw	r4,-24(fp)
   11780:	000b883a 	mov	r5,zero
   11784:	100d883a 	mov	r6,r2
   11788:	000f883a 	mov	r7,zero
   1178c:	00112800 	call	11280 <xTimerGenericCommand>
   11790:	e0bffb15 	stw	r2,-20(fp)
						configASSERT( xResult );
						( void ) xResult;
					}
				}
				break;
   11794:	00001306 	br	117e4 <prvProcessReceivedCommands+0x14c>
				/* The timer has already been removed from the active list.
				There is nothing to do here. */
				break;

			case tmrCOMMAND_CHANGE_PERIOD :
				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
   11798:	e0fffd17 	ldw	r3,-12(fp)
   1179c:	e0bffa17 	ldw	r2,-24(fp)
   117a0:	10c00615 	stw	r3,24(r2)
				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
				prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
   117a4:	e0bffa17 	ldw	r2,-24(fp)
   117a8:	10c00617 	ldw	r3,24(r2)
   117ac:	e0bff917 	ldw	r2,-28(fp)
   117b0:	1885883a 	add	r2,r3,r2
   117b4:	e13ffa17 	ldw	r4,-24(fp)
   117b8:	100b883a 	mov	r5,r2
   117bc:	e1bff917 	ldw	r6,-28(fp)
   117c0:	e1fff917 	ldw	r7,-28(fp)
   117c4:	00115bc0 	call	115bc <prvInsertTimerInActiveList>
				break;
   117c8:	00000706 	br	117e8 <prvProcessReceivedCommands+0x150>

			case tmrCOMMAND_DELETE :
				/* The timer has already been removed from the active list,
				just free up the memory. */
				vPortFree( pxTimer );
   117cc:	e13ffa17 	ldw	r4,-24(fp)
   117d0:	000e4d80 	call	e4d8 <vPortFree>
				break;
   117d4:	00000406 	br	117e8 <prvProcessReceivedCommands+0x150>

			default	:			
				/* Don't expect to get here. */
				break;
   117d8:	00000306 	br	117e8 <prvProcessReceivedCommands+0x150>
				break;

			case tmrCOMMAND_STOP :	
				/* The timer has already been removed from the active list.
				There is nothing to do here. */
				break;
   117dc:	0001883a 	nop
   117e0:	00000106 	br	117e8 <prvProcessReceivedCommands+0x150>
						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
						configASSERT( xResult );
						( void ) xResult;
					}
				}
				break;
   117e4:	0001883a 	nop

	/* In this case the xTimerListsWereSwitched parameter is not used, but it
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
   117e8:	d0e91717 	ldw	r3,-23460(gp)
   117ec:	e0bffc04 	addi	r2,fp,-16
   117f0:	1809883a 	mov	r4,r3
   117f4:	100b883a 	mov	r5,r2
   117f8:	000d883a 	mov	r6,zero
   117fc:	000f883a 	mov	r7,zero
   11800:	000ebd80 	call	ebd8 <xQueueGenericReceive>
   11804:	103fad1e 	bne	r2,zero,116bc <prvProcessReceivedCommands+0x24>
			default	:			
				/* Don't expect to get here. */
				break;
		}
	}
}
   11808:	e037883a 	mov	sp,fp
   1180c:	dfc00117 	ldw	ra,4(sp)
   11810:	df000017 	ldw	fp,0(sp)
   11814:	dec00204 	addi	sp,sp,8
   11818:	f800283a 	ret

0001181c <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( portTickType xLastTime )
{
   1181c:	defff704 	addi	sp,sp,-36
   11820:	dfc00815 	stw	ra,32(sp)
   11824:	df000715 	stw	fp,28(sp)
   11828:	df000704 	addi	fp,sp,28
   1182c:	e13fff15 	stw	r4,-4(fp)
	
	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
   11830:	00003006 	br	118f4 <prvSwitchTimerLists+0xd8>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
   11834:	d0a91517 	ldw	r2,-23468(gp)
   11838:	10800317 	ldw	r2,12(r2)
   1183c:	10800017 	ldw	r2,0(r2)
   11840:	e0bffa15 	stw	r2,-24(fp)

		/* Remove the timer from the list. */
		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
   11844:	d0a91517 	ldw	r2,-23468(gp)
   11848:	10800317 	ldw	r2,12(r2)
   1184c:	10800317 	ldw	r2,12(r2)
   11850:	e0bffb15 	stw	r2,-20(fp)
		vListRemove( &( pxTimer->xTimerListItem ) );
   11854:	e0bffb17 	ldw	r2,-20(fp)
   11858:	10800104 	addi	r2,r2,4
   1185c:	1009883a 	mov	r4,r2
   11860:	003c0fc0 	call	3c0fc <vListRemove>

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
   11864:	e0bffb17 	ldw	r2,-20(fp)
   11868:	10800917 	ldw	r2,36(r2)
   1186c:	e13ffb17 	ldw	r4,-20(fp)
   11870:	103ee83a 	callr	r2

		if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
   11874:	e0bffb17 	ldw	r2,-20(fp)
   11878:	10800717 	ldw	r2,28(r2)
   1187c:	10800058 	cmpnei	r2,r2,1
   11880:	10001c1e 	bne	r2,zero,118f4 <prvSwitchTimerLists+0xd8>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
   11884:	e0bffb17 	ldw	r2,-20(fp)
   11888:	10c00617 	ldw	r3,24(r2)
   1188c:	e0bffa17 	ldw	r2,-24(fp)
   11890:	1885883a 	add	r2,r3,r2
   11894:	e0bffc15 	stw	r2,-16(fp)
			if( xReloadTime > xNextExpireTime )
   11898:	e0bffc17 	ldw	r2,-16(fp)
   1189c:	e0fffa17 	ldw	r3,-24(fp)
   118a0:	18800d2e 	bgeu	r3,r2,118d8 <prvSwitchTimerLists+0xbc>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
   118a4:	e0bffb17 	ldw	r2,-20(fp)
   118a8:	e0fffc17 	ldw	r3,-16(fp)
   118ac:	10c00115 	stw	r3,4(r2)
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
   118b0:	e0bffb17 	ldw	r2,-20(fp)
   118b4:	e0fffb17 	ldw	r3,-20(fp)
   118b8:	10c00415 	stw	r3,16(r2)
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
   118bc:	d0e91517 	ldw	r3,-23468(gp)
   118c0:	e0bffb17 	ldw	r2,-20(fp)
   118c4:	10800104 	addi	r2,r2,4
   118c8:	1809883a 	mov	r4,r3
   118cc:	100b883a 	mov	r5,r2
   118d0:	003c0280 	call	3c028 <vListInsert>
   118d4:	00000706 	br	118f4 <prvSwitchTimerLists+0xd8>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
   118d8:	d8000015 	stw	zero,0(sp)
   118dc:	e13ffb17 	ldw	r4,-20(fp)
   118e0:	000b883a 	mov	r5,zero
   118e4:	e1bffa17 	ldw	r6,-24(fp)
   118e8:	000f883a 	mov	r7,zero
   118ec:	00112800 	call	11280 <xTimerGenericCommand>
   118f0:	e0bffd15 	stw	r2,-12(fp)
	
	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
   118f4:	d0a91517 	ldw	r2,-23468(gp)
   118f8:	10800017 	ldw	r2,0(r2)
   118fc:	103fcd1e 	bne	r2,zero,11834 <prvSwitchTimerLists+0x18>
				( void ) xResult;
			}
		}
	}

	pxTemp = pxCurrentTimerList;
   11900:	d0a91517 	ldw	r2,-23468(gp)
   11904:	e0bffe15 	stw	r2,-8(fp)
	pxCurrentTimerList = pxOverflowTimerList;
   11908:	d0a91617 	ldw	r2,-23464(gp)
   1190c:	d0a91515 	stw	r2,-23468(gp)
	pxOverflowTimerList = pxTemp;
   11910:	e0bffe17 	ldw	r2,-8(fp)
   11914:	d0a91615 	stw	r2,-23464(gp)
}
   11918:	e037883a 	mov	sp,fp
   1191c:	dfc00117 	ldw	ra,4(sp)
   11920:	df000017 	ldw	fp,0(sp)
   11924:	dec00204 	addi	sp,sp,8
   11928:	f800283a 	ret

0001192c <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
   1192c:	defffe04 	addi	sp,sp,-8
   11930:	dfc00115 	stw	ra,4(sp)
   11934:	df000015 	stw	fp,0(sp)
   11938:	d839883a 	mov	fp,sp
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
   1193c:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   11940:	10000126 	beq	r2,zero,11948 <prvCheckForValidListAndQueue+0x1c>
   11944:	00110d00 	call	110d0 <vTaskEnterCritical>
	{
		if( xTimerQueue == NULL )
   11948:	d0a91717 	ldw	r2,-23460(gp)
   1194c:	1000111e 	bne	r2,zero,11994 <prvCheckForValidListAndQueue+0x68>
		{
			vListInitialise( &xActiveTimerList1 );
   11950:	01000134 	movhi	r4,4
   11954:	211f6204 	addi	r4,r4,32136
   11958:	003bf040 	call	3bf04 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
   1195c:	01000134 	movhi	r4,4
   11960:	211f6704 	addi	r4,r4,32156
   11964:	003bf040 	call	3bf04 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
   11968:	00800134 	movhi	r2,4
   1196c:	109f6204 	addi	r2,r2,32136
   11970:	d0a91515 	stw	r2,-23468(gp)
			pxOverflowTimerList = &xActiveTimerList2;
   11974:	00800134 	movhi	r2,4
   11978:	109f6704 	addi	r2,r2,32156
   1197c:	d0a91615 	stw	r2,-23464(gp)
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
   11980:	01000284 	movi	r4,10
   11984:	01400304 	movi	r5,12
   11988:	000d883a 	mov	r6,zero
   1198c:	000e6380 	call	e638 <xQueueGenericCreate>
   11990:	d0a91715 	stw	r2,-23460(gp)
		}
	}
	taskEXIT_CRITICAL();
   11994:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   11998:	10000126 	beq	r2,zero,119a0 <prvCheckForValidListAndQueue+0x74>
   1199c:	00111100 	call	11110 <vTaskExitCritical>
}
   119a0:	e037883a 	mov	sp,fp
   119a4:	dfc00117 	ldw	ra,4(sp)
   119a8:	df000017 	ldw	fp,0(sp)
   119ac:	dec00204 	addi	sp,sp,8
   119b0:	f800283a 	ret

000119b4 <xTimerIsTimerActive>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerIsTimerActive( xTimerHandle xTimer )
{
   119b4:	defffb04 	addi	sp,sp,-20
   119b8:	dfc00415 	stw	ra,16(sp)
   119bc:	df000315 	stw	fp,12(sp)
   119c0:	df000304 	addi	fp,sp,12
   119c4:	e13fff15 	stw	r4,-4(fp)
portBASE_TYPE xTimerIsInActiveList;
xTIMER *pxTimer = ( xTIMER * ) xTimer;
   119c8:	e0bfff17 	ldw	r2,-4(fp)
   119cc:	e0bffd15 	stw	r2,-12(fp)

	/* Is the timer in the list of active timers? */
	taskENTER_CRITICAL();
   119d0:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   119d4:	10000126 	beq	r2,zero,119dc <xTimerIsTimerActive+0x28>
   119d8:	00110d00 	call	110d0 <vTaskEnterCritical>
	{
		/* Checking to see if it is in the NULL list in effect checks to see if
		it is referenced from either the current or the overflow timer lists in
		one go, but the logic has to be reversed, hence the '!'. */
		xTimerIsInActiveList = !( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) );
   119dc:	e0bffd17 	ldw	r2,-12(fp)
   119e0:	10800517 	ldw	r2,20(r2)
   119e4:	1004c03a 	cmpne	r2,r2,zero
   119e8:	10803fcc 	andi	r2,r2,255
   119ec:	e0bffe15 	stw	r2,-8(fp)
	}
	taskEXIT_CRITICAL();
   119f0:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   119f4:	10000126 	beq	r2,zero,119fc <xTimerIsTimerActive+0x48>
   119f8:	00111100 	call	11110 <vTaskExitCritical>

	return xTimerIsInActiveList;
   119fc:	e0bffe17 	ldw	r2,-8(fp)
}
   11a00:	e037883a 	mov	sp,fp
   11a04:	dfc00117 	ldw	ra,4(sp)
   11a08:	df000017 	ldw	fp,0(sp)
   11a0c:	dec00204 	addi	sp,sp,8
   11a10:	f800283a 	ret

00011a14 <pvTimerGetTimerID>:
/*-----------------------------------------------------------*/

void *pvTimerGetTimerID( xTimerHandle xTimer )
{
   11a14:	defffd04 	addi	sp,sp,-12
   11a18:	df000215 	stw	fp,8(sp)
   11a1c:	df000204 	addi	fp,sp,8
   11a20:	e13fff15 	stw	r4,-4(fp)
xTIMER *pxTimer = ( xTIMER * ) xTimer;
   11a24:	e0bfff17 	ldw	r2,-4(fp)
   11a28:	e0bffe15 	stw	r2,-8(fp)

	return pxTimer->pvTimerID;
   11a2c:	e0bffe17 	ldw	r2,-8(fp)
   11a30:	10800817 	ldw	r2,32(r2)
}
   11a34:	e037883a 	mov	sp,fp
   11a38:	df000017 	ldw	fp,0(sp)
   11a3c:	dec00104 	addi	sp,sp,4
   11a40:	f800283a 	ret

00011a44 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
   11a44:	defffc04 	addi	sp,sp,-16
   11a48:	df000315 	stw	fp,12(sp)
   11a4c:	df000304 	addi	fp,sp,12
   11a50:	e13ffd15 	stw	r4,-12(fp)
   11a54:	e17ffe15 	stw	r5,-8(fp)
   11a58:	e1bfff15 	stw	r6,-4(fp)
  return len;
   11a5c:	e0bfff17 	ldw	r2,-4(fp)
}
   11a60:	e037883a 	mov	sp,fp
   11a64:	df000017 	ldw	fp,0(sp)
   11a68:	dec00104 	addi	sp,sp,4
   11a6c:	f800283a 	ret

00011a70 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
   11a70:	defffd04 	addi	sp,sp,-12
   11a74:	dfc00215 	stw	ra,8(sp)
   11a78:	df000115 	stw	fp,4(sp)
   11a7c:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
   11a80:	00800134 	movhi	r2,4
   11a84:	10bdeb04 	addi	r2,r2,-2132
   11a88:	e0bfff15 	stw	r2,-4(fp)
   11a8c:	00000606 	br	11aa8 <_do_ctors+0x38>
        (*ctor) (); 
   11a90:	e0bfff17 	ldw	r2,-4(fp)
   11a94:	10800017 	ldw	r2,0(r2)
   11a98:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
   11a9c:	e0bfff17 	ldw	r2,-4(fp)
   11aa0:	10bfff04 	addi	r2,r2,-4
   11aa4:	e0bfff15 	stw	r2,-4(fp)
   11aa8:	e0ffff17 	ldw	r3,-4(fp)
   11aac:	00800134 	movhi	r2,4
   11ab0:	10bdec04 	addi	r2,r2,-2128
   11ab4:	18bff62e 	bgeu	r3,r2,11a90 <_do_ctors+0x20>
        (*ctor) (); 
}
   11ab8:	e037883a 	mov	sp,fp
   11abc:	dfc00117 	ldw	ra,4(sp)
   11ac0:	df000017 	ldw	fp,0(sp)
   11ac4:	dec00204 	addi	sp,sp,8
   11ac8:	f800283a 	ret

00011acc <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
   11acc:	defffd04 	addi	sp,sp,-12
   11ad0:	dfc00215 	stw	ra,8(sp)
   11ad4:	df000115 	stw	fp,4(sp)
   11ad8:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
   11adc:	00800134 	movhi	r2,4
   11ae0:	10bdeb04 	addi	r2,r2,-2132
   11ae4:	e0bfff15 	stw	r2,-4(fp)
   11ae8:	00000606 	br	11b04 <_do_dtors+0x38>
        (*dtor) (); 
   11aec:	e0bfff17 	ldw	r2,-4(fp)
   11af0:	10800017 	ldw	r2,0(r2)
   11af4:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
   11af8:	e0bfff17 	ldw	r2,-4(fp)
   11afc:	10bfff04 	addi	r2,r2,-4
   11b00:	e0bfff15 	stw	r2,-4(fp)
   11b04:	e0ffff17 	ldw	r3,-4(fp)
   11b08:	00800134 	movhi	r2,4
   11b0c:	10bdec04 	addi	r2,r2,-2128
   11b10:	18bff62e 	bgeu	r3,r2,11aec <_do_dtors+0x20>
        (*dtor) (); 
}
   11b14:	e037883a 	mov	sp,fp
   11b18:	dfc00117 	ldw	ra,4(sp)
   11b1c:	df000017 	ldw	fp,0(sp)
   11b20:	dec00204 	addi	sp,sp,8
   11b24:	f800283a 	ret

00011b28 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   11b28:	defffe04 	addi	sp,sp,-8
   11b2c:	dfc00115 	stw	ra,4(sp)
   11b30:	df000015 	stw	fp,0(sp)
   11b34:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   11b38:	00800134 	movhi	r2,4
   11b3c:	1095d904 	addi	r2,r2,22372
   11b40:	10800017 	ldw	r2,0(r2)
   11b44:	10000526 	beq	r2,zero,11b5c <alt_get_errno+0x34>
   11b48:	00800134 	movhi	r2,4
   11b4c:	1095d904 	addi	r2,r2,22372
   11b50:	10800017 	ldw	r2,0(r2)
   11b54:	103ee83a 	callr	r2
   11b58:	00000206 	br	11b64 <alt_get_errno+0x3c>
   11b5c:	00800134 	movhi	r2,4
   11b60:	109ebe04 	addi	r2,r2,31480
}
   11b64:	e037883a 	mov	sp,fp
   11b68:	dfc00117 	ldw	ra,4(sp)
   11b6c:	df000017 	ldw	fp,0(sp)
   11b70:	dec00204 	addi	sp,sp,8
   11b74:	f800283a 	ret

00011b78 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
   11b78:	defffb04 	addi	sp,sp,-20
   11b7c:	dfc00415 	stw	ra,16(sp)
   11b80:	df000315 	stw	fp,12(sp)
   11b84:	df000304 	addi	fp,sp,12
   11b88:	e13ffe15 	stw	r4,-8(fp)
   11b8c:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   11b90:	e0bffe17 	ldw	r2,-8(fp)
   11b94:	10000616 	blt	r2,zero,11bb0 <fstat+0x38>
   11b98:	e0bffe17 	ldw	r2,-8(fp)
   11b9c:	10c00324 	muli	r3,r2,12
   11ba0:	00800134 	movhi	r2,4
   11ba4:	108f5b04 	addi	r2,r2,15724
   11ba8:	1885883a 	add	r2,r3,r2
   11bac:	00000106 	br	11bb4 <fstat+0x3c>
   11bb0:	0005883a 	mov	r2,zero
   11bb4:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
   11bb8:	e0bffd17 	ldw	r2,-12(fp)
   11bbc:	10001026 	beq	r2,zero,11c00 <fstat+0x88>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
   11bc0:	e0bffd17 	ldw	r2,-12(fp)
   11bc4:	10800017 	ldw	r2,0(r2)
   11bc8:	10800817 	ldw	r2,32(r2)
   11bcc:	10000726 	beq	r2,zero,11bec <fstat+0x74>
    {
      return fd->dev->fstat(fd, st);
   11bd0:	e0bffd17 	ldw	r2,-12(fp)
   11bd4:	10800017 	ldw	r2,0(r2)
   11bd8:	10800817 	ldw	r2,32(r2)
   11bdc:	e13ffd17 	ldw	r4,-12(fp)
   11be0:	e17fff17 	ldw	r5,-4(fp)
   11be4:	103ee83a 	callr	r2
   11be8:	00000906 	br	11c10 <fstat+0x98>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
   11bec:	e0bfff17 	ldw	r2,-4(fp)
   11bf0:	00c80004 	movi	r3,8192
   11bf4:	10c00115 	stw	r3,4(r2)
      return 0;
   11bf8:	0005883a 	mov	r2,zero
   11bfc:	00000406 	br	11c10 <fstat+0x98>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
   11c00:	0011b280 	call	11b28 <alt_get_errno>
   11c04:	00c01444 	movi	r3,81
   11c08:	10c00015 	stw	r3,0(r2)
    return -1;
   11c0c:	00bfffc4 	movi	r2,-1
  }
}
   11c10:	e037883a 	mov	sp,fp
   11c14:	dfc00117 	ldw	ra,4(sp)
   11c18:	df000017 	ldw	fp,0(sp)
   11c1c:	dec00204 	addi	sp,sp,8
   11c20:	f800283a 	ret

00011c24 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
   11c24:	defff904 	addi	sp,sp,-28
   11c28:	dfc00615 	stw	ra,24(sp)
   11c2c:	df000515 	stw	fp,20(sp)
   11c30:	df000504 	addi	fp,sp,20
   11c34:	e13ffc15 	stw	r4,-16(fp)
   11c38:	e17ffd15 	stw	r5,-12(fp)
   11c3c:	e1bffe15 	stw	r6,-8(fp)
   11c40:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
   11c44:	e13ffd17 	ldw	r4,-12(fp)
   11c48:	e17ffe17 	ldw	r5,-8(fp)
   11c4c:	e1bfff17 	ldw	r6,-4(fp)
   11c50:	00121740 	call	12174 <open>
   11c54:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
   11c58:	e0bffb17 	ldw	r2,-20(fp)
   11c5c:	10001c16 	blt	r2,zero,11cd0 <alt_open_fd+0xac>
  {
    fd->dev      = alt_fd_list[old].dev;
   11c60:	00c00134 	movhi	r3,4
   11c64:	18cf5b04 	addi	r3,r3,15724
   11c68:	e0bffb17 	ldw	r2,-20(fp)
   11c6c:	10800324 	muli	r2,r2,12
   11c70:	1885883a 	add	r2,r3,r2
   11c74:	10c00017 	ldw	r3,0(r2)
   11c78:	e0bffc17 	ldw	r2,-16(fp)
   11c7c:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
   11c80:	00c00134 	movhi	r3,4
   11c84:	18cf5b04 	addi	r3,r3,15724
   11c88:	e0bffb17 	ldw	r2,-20(fp)
   11c8c:	10800324 	muli	r2,r2,12
   11c90:	1885883a 	add	r2,r3,r2
   11c94:	10800104 	addi	r2,r2,4
   11c98:	10c00017 	ldw	r3,0(r2)
   11c9c:	e0bffc17 	ldw	r2,-16(fp)
   11ca0:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
   11ca4:	00c00134 	movhi	r3,4
   11ca8:	18cf5b04 	addi	r3,r3,15724
   11cac:	e0bffb17 	ldw	r2,-20(fp)
   11cb0:	10800324 	muli	r2,r2,12
   11cb4:	1885883a 	add	r2,r3,r2
   11cb8:	10800204 	addi	r2,r2,8
   11cbc:	10c00017 	ldw	r3,0(r2)
   11cc0:	e0bffc17 	ldw	r2,-16(fp)
   11cc4:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
   11cc8:	e13ffb17 	ldw	r4,-20(fp)
   11ccc:	00122c80 	call	122c8 <alt_release_fd>
  }
} 
   11cd0:	e037883a 	mov	sp,fp
   11cd4:	dfc00117 	ldw	ra,4(sp)
   11cd8:	df000017 	ldw	fp,0(sp)
   11cdc:	dec00204 	addi	sp,sp,8
   11ce0:	f800283a 	ret

00011ce4 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
   11ce4:	defffb04 	addi	sp,sp,-20
   11ce8:	dfc00415 	stw	ra,16(sp)
   11cec:	df000315 	stw	fp,12(sp)
   11cf0:	df000304 	addi	fp,sp,12
   11cf4:	e13ffd15 	stw	r4,-12(fp)
   11cf8:	e17ffe15 	stw	r5,-8(fp)
   11cfc:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
   11d00:	01000134 	movhi	r4,4
   11d04:	210f5e04 	addi	r4,r4,15736
   11d08:	e17ffd17 	ldw	r5,-12(fp)
   11d0c:	01800044 	movi	r6,1
   11d10:	01c07fc4 	movi	r7,511
   11d14:	0011c240 	call	11c24 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
   11d18:	01000134 	movhi	r4,4
   11d1c:	210f5b04 	addi	r4,r4,15724
   11d20:	e17ffe17 	ldw	r5,-8(fp)
   11d24:	000d883a 	mov	r6,zero
   11d28:	01c07fc4 	movi	r7,511
   11d2c:	0011c240 	call	11c24 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
   11d30:	01000134 	movhi	r4,4
   11d34:	210f6104 	addi	r4,r4,15748
   11d38:	e17fff17 	ldw	r5,-4(fp)
   11d3c:	01800044 	movi	r6,1
   11d40:	01c07fc4 	movi	r7,511
   11d44:	0011c240 	call	11c24 <alt_open_fd>
}  
   11d48:	e037883a 	mov	sp,fp
   11d4c:	dfc00117 	ldw	ra,4(sp)
   11d50:	df000017 	ldw	fp,0(sp)
   11d54:	dec00204 	addi	sp,sp,8
   11d58:	f800283a 	ret

00011d5c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   11d5c:	defffe04 	addi	sp,sp,-8
   11d60:	dfc00115 	stw	ra,4(sp)
   11d64:	df000015 	stw	fp,0(sp)
   11d68:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   11d6c:	00800134 	movhi	r2,4
   11d70:	1095d904 	addi	r2,r2,22372
   11d74:	10800017 	ldw	r2,0(r2)
   11d78:	10000526 	beq	r2,zero,11d90 <alt_get_errno+0x34>
   11d7c:	00800134 	movhi	r2,4
   11d80:	1095d904 	addi	r2,r2,22372
   11d84:	10800017 	ldw	r2,0(r2)
   11d88:	103ee83a 	callr	r2
   11d8c:	00000206 	br	11d98 <alt_get_errno+0x3c>
   11d90:	00800134 	movhi	r2,4
   11d94:	109ebe04 	addi	r2,r2,31480
}
   11d98:	e037883a 	mov	sp,fp
   11d9c:	dfc00117 	ldw	ra,4(sp)
   11da0:	df000017 	ldw	fp,0(sp)
   11da4:	dec00204 	addi	sp,sp,8
   11da8:	f800283a 	ret

00011dac <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
   11dac:	deffed04 	addi	sp,sp,-76
   11db0:	dfc01215 	stw	ra,72(sp)
   11db4:	df001115 	stw	fp,68(sp)
   11db8:	df001104 	addi	fp,sp,68
   11dbc:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   11dc0:	e0bfff17 	ldw	r2,-4(fp)
   11dc4:	10000616 	blt	r2,zero,11de0 <isatty+0x34>
   11dc8:	e0bfff17 	ldw	r2,-4(fp)
   11dcc:	10c00324 	muli	r3,r2,12
   11dd0:	00800134 	movhi	r2,4
   11dd4:	108f5b04 	addi	r2,r2,15724
   11dd8:	1885883a 	add	r2,r3,r2
   11ddc:	00000106 	br	11de4 <isatty+0x38>
   11de0:	0005883a 	mov	r2,zero
   11de4:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
   11de8:	e0bfef17 	ldw	r2,-68(fp)
   11dec:	10000e26 	beq	r2,zero,11e28 <isatty+0x7c>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
   11df0:	e0bfef17 	ldw	r2,-68(fp)
   11df4:	10800017 	ldw	r2,0(r2)
   11df8:	10800817 	ldw	r2,32(r2)
   11dfc:	1000021e 	bne	r2,zero,11e08 <isatty+0x5c>
    {
      return 1;
   11e00:	00800044 	movi	r2,1
   11e04:	00000c06 	br	11e38 <isatty+0x8c>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
   11e08:	e0bff004 	addi	r2,fp,-64
   11e0c:	e13fff17 	ldw	r4,-4(fp)
   11e10:	100b883a 	mov	r5,r2
   11e14:	0011b780 	call	11b78 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
   11e18:	e0bff117 	ldw	r2,-60(fp)
   11e1c:	10880020 	cmpeqi	r2,r2,8192
   11e20:	10803fcc 	andi	r2,r2,255
   11e24:	00000406 	br	11e38 <isatty+0x8c>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
   11e28:	0011d5c0 	call	11d5c <alt_get_errno>
   11e2c:	00c01444 	movi	r3,81
   11e30:	10c00015 	stw	r3,0(r2)
    return 0;
   11e34:	0005883a 	mov	r2,zero
  }
}
   11e38:	e037883a 	mov	sp,fp
   11e3c:	dfc00117 	ldw	ra,4(sp)
   11e40:	df000017 	ldw	fp,0(sp)
   11e44:	dec00204 	addi	sp,sp,8
   11e48:	f800283a 	ret

00011e4c <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
   11e4c:	defffc04 	addi	sp,sp,-16
   11e50:	df000315 	stw	fp,12(sp)
   11e54:	df000304 	addi	fp,sp,12
   11e58:	e13ffd15 	stw	r4,-12(fp)
   11e5c:	e17ffe15 	stw	r5,-8(fp)
   11e60:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
   11e64:	e0fffe17 	ldw	r3,-8(fp)
   11e68:	e0bffd17 	ldw	r2,-12(fp)
   11e6c:	18800e26 	beq	r3,r2,11ea8 <alt_load_section+0x5c>
  {
    while( to != end )
   11e70:	00000a06 	br	11e9c <alt_load_section+0x50>
    {
      *to++ = *from++;
   11e74:	e0bffd17 	ldw	r2,-12(fp)
   11e78:	10c00017 	ldw	r3,0(r2)
   11e7c:	e0bffe17 	ldw	r2,-8(fp)
   11e80:	10c00015 	stw	r3,0(r2)
   11e84:	e0bffe17 	ldw	r2,-8(fp)
   11e88:	10800104 	addi	r2,r2,4
   11e8c:	e0bffe15 	stw	r2,-8(fp)
   11e90:	e0bffd17 	ldw	r2,-12(fp)
   11e94:	10800104 	addi	r2,r2,4
   11e98:	e0bffd15 	stw	r2,-12(fp)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
   11e9c:	e0fffe17 	ldw	r3,-8(fp)
   11ea0:	e0bfff17 	ldw	r2,-4(fp)
   11ea4:	18bff31e 	bne	r3,r2,11e74 <alt_load_section+0x28>
    {
      *to++ = *from++;
    }
  }
}
   11ea8:	e037883a 	mov	sp,fp
   11eac:	df000017 	ldw	fp,0(sp)
   11eb0:	dec00104 	addi	sp,sp,4
   11eb4:	f800283a 	ret

00011eb8 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
   11eb8:	defffe04 	addi	sp,sp,-8
   11ebc:	dfc00115 	stw	ra,4(sp)
   11ec0:	df000015 	stw	fp,0(sp)
   11ec4:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
   11ec8:	01000134 	movhi	r4,4
   11ecc:	2115df04 	addi	r4,r4,22396
   11ed0:	01400134 	movhi	r5,4
   11ed4:	294d4c04 	addi	r5,r5,13616
   11ed8:	01800134 	movhi	r6,4
   11edc:	3195df04 	addi	r6,r6,22396
   11ee0:	0011e4c0 	call	11e4c <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
   11ee4:	01000034 	movhi	r4,0
   11ee8:	21000804 	addi	r4,r4,32
   11eec:	01400034 	movhi	r5,0
   11ef0:	29400804 	addi	r5,r5,32
   11ef4:	01800034 	movhi	r6,0
   11ef8:	31808904 	addi	r6,r6,548
   11efc:	0011e4c0 	call	11e4c <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
   11f00:	01000134 	movhi	r4,4
   11f04:	213dec04 	addi	r4,r4,-2128
   11f08:	01400134 	movhi	r5,4
   11f0c:	297dec04 	addi	r5,r5,-2128
   11f10:	01800134 	movhi	r6,4
   11f14:	318d4c04 	addi	r6,r6,13616
   11f18:	0011e4c0 	call	11e4c <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
   11f1c:	003c7a00 	call	3c7a0 <alt_dcache_flush_all>
  alt_icache_flush_all();
   11f20:	003ce100 	call	3ce10 <alt_icache_flush_all>
}
   11f24:	e037883a 	mov	sp,fp
   11f28:	dfc00117 	ldw	ra,4(sp)
   11f2c:	df000017 	ldw	fp,0(sp)
   11f30:	dec00204 	addi	sp,sp,8
   11f34:	f800283a 	ret

00011f38 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   11f38:	defffe04 	addi	sp,sp,-8
   11f3c:	dfc00115 	stw	ra,4(sp)
   11f40:	df000015 	stw	fp,0(sp)
   11f44:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   11f48:	00800134 	movhi	r2,4
   11f4c:	1095d904 	addi	r2,r2,22372
   11f50:	10800017 	ldw	r2,0(r2)
   11f54:	10000526 	beq	r2,zero,11f6c <alt_get_errno+0x34>
   11f58:	00800134 	movhi	r2,4
   11f5c:	1095d904 	addi	r2,r2,22372
   11f60:	10800017 	ldw	r2,0(r2)
   11f64:	103ee83a 	callr	r2
   11f68:	00000206 	br	11f74 <alt_get_errno+0x3c>
   11f6c:	00800134 	movhi	r2,4
   11f70:	109ebe04 	addi	r2,r2,31480
}
   11f74:	e037883a 	mov	sp,fp
   11f78:	dfc00117 	ldw	ra,4(sp)
   11f7c:	df000017 	ldw	fp,0(sp)
   11f80:	dec00204 	addi	sp,sp,8
   11f84:	f800283a 	ret

00011f88 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
   11f88:	defff904 	addi	sp,sp,-28
   11f8c:	dfc00615 	stw	ra,24(sp)
   11f90:	df000515 	stw	fp,20(sp)
   11f94:	df000504 	addi	fp,sp,20
   11f98:	e13ffd15 	stw	r4,-12(fp)
   11f9c:	e17ffe15 	stw	r5,-8(fp)
   11fa0:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
   11fa4:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   11fa8:	e0bffd17 	ldw	r2,-12(fp)
   11fac:	10000616 	blt	r2,zero,11fc8 <lseek+0x40>
   11fb0:	e0bffd17 	ldw	r2,-12(fp)
   11fb4:	10c00324 	muli	r3,r2,12
   11fb8:	00800134 	movhi	r2,4
   11fbc:	108f5b04 	addi	r2,r2,15724
   11fc0:	1885883a 	add	r2,r3,r2
   11fc4:	00000106 	br	11fcc <lseek+0x44>
   11fc8:	0005883a 	mov	r2,zero
   11fcc:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
   11fd0:	e0bffc17 	ldw	r2,-16(fp)
   11fd4:	10001026 	beq	r2,zero,12018 <lseek+0x90>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
   11fd8:	e0bffc17 	ldw	r2,-16(fp)
   11fdc:	10800017 	ldw	r2,0(r2)
   11fe0:	10800717 	ldw	r2,28(r2)
   11fe4:	10000926 	beq	r2,zero,1200c <lseek+0x84>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
   11fe8:	e0bffc17 	ldw	r2,-16(fp)
   11fec:	10800017 	ldw	r2,0(r2)
   11ff0:	10800717 	ldw	r2,28(r2)
   11ff4:	e13ffc17 	ldw	r4,-16(fp)
   11ff8:	e17ffe17 	ldw	r5,-8(fp)
   11ffc:	e1bfff17 	ldw	r6,-4(fp)
   12000:	103ee83a 	callr	r2
   12004:	e0bffb15 	stw	r2,-20(fp)
   12008:	00000506 	br	12020 <lseek+0x98>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
   1200c:	00bfde84 	movi	r2,-134
   12010:	e0bffb15 	stw	r2,-20(fp)
   12014:	00000206 	br	12020 <lseek+0x98>
    }
  }
  else  
  {
    rc = -EBADFD;
   12018:	00bfebc4 	movi	r2,-81
   1201c:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
   12020:	e0bffb17 	ldw	r2,-20(fp)
   12024:	1000060e 	bge	r2,zero,12040 <lseek+0xb8>
  {
    ALT_ERRNO = -rc;
   12028:	0011f380 	call	11f38 <alt_get_errno>
   1202c:	e0fffb17 	ldw	r3,-20(fp)
   12030:	00c7c83a 	sub	r3,zero,r3
   12034:	10c00015 	stw	r3,0(r2)
    rc = -1;
   12038:	00bfffc4 	movi	r2,-1
   1203c:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
   12040:	e0bffb17 	ldw	r2,-20(fp)
}
   12044:	e037883a 	mov	sp,fp
   12048:	dfc00117 	ldw	ra,4(sp)
   1204c:	df000017 	ldw	fp,0(sp)
   12050:	dec00204 	addi	sp,sp,8
   12054:	f800283a 	ret

00012058 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   12058:	defffe04 	addi	sp,sp,-8
   1205c:	dfc00115 	stw	ra,4(sp)
   12060:	df000015 	stw	fp,0(sp)
   12064:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   12068:	00800134 	movhi	r2,4
   1206c:	1095d904 	addi	r2,r2,22372
   12070:	10800017 	ldw	r2,0(r2)
   12074:	10000526 	beq	r2,zero,1208c <alt_get_errno+0x34>
   12078:	00800134 	movhi	r2,4
   1207c:	1095d904 	addi	r2,r2,22372
   12080:	10800017 	ldw	r2,0(r2)
   12084:	103ee83a 	callr	r2
   12088:	00000206 	br	12094 <alt_get_errno+0x3c>
   1208c:	00800134 	movhi	r2,4
   12090:	109ebe04 	addi	r2,r2,31480
}
   12094:	e037883a 	mov	sp,fp
   12098:	dfc00117 	ldw	ra,4(sp)
   1209c:	df000017 	ldw	fp,0(sp)
   120a0:	dec00204 	addi	sp,sp,8
   120a4:	f800283a 	ret

000120a8 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
   120a8:	defffd04 	addi	sp,sp,-12
   120ac:	df000215 	stw	fp,8(sp)
   120b0:	df000204 	addi	fp,sp,8
   120b4:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
   120b8:	e0bfff17 	ldw	r2,-4(fp)
   120bc:	10800217 	ldw	r2,8(r2)
   120c0:	10d00034 	orhi	r3,r2,16384
   120c4:	e0bfff17 	ldw	r2,-4(fp)
   120c8:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
   120cc:	e03ffe15 	stw	zero,-8(fp)
   120d0:	00001d06 	br	12148 <alt_file_locked+0xa0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
   120d4:	00c00134 	movhi	r3,4
   120d8:	18cf5b04 	addi	r3,r3,15724
   120dc:	e0bffe17 	ldw	r2,-8(fp)
   120e0:	10800324 	muli	r2,r2,12
   120e4:	1885883a 	add	r2,r3,r2
   120e8:	10c00017 	ldw	r3,0(r2)
   120ec:	e0bfff17 	ldw	r2,-4(fp)
   120f0:	10800017 	ldw	r2,0(r2)
   120f4:	1880111e 	bne	r3,r2,1213c <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
   120f8:	00c00134 	movhi	r3,4
   120fc:	18cf5b04 	addi	r3,r3,15724
   12100:	e0bffe17 	ldw	r2,-8(fp)
   12104:	10800324 	muli	r2,r2,12
   12108:	1885883a 	add	r2,r3,r2
   1210c:	10800204 	addi	r2,r2,8
   12110:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
   12114:	1000090e 	bge	r2,zero,1213c <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
   12118:	e0bffe17 	ldw	r2,-8(fp)
   1211c:	10c00324 	muli	r3,r2,12
   12120:	00800134 	movhi	r2,4
   12124:	108f5b04 	addi	r2,r2,15724
   12128:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
   1212c:	e0bfff17 	ldw	r2,-4(fp)
   12130:	18800226 	beq	r3,r2,1213c <alt_file_locked+0x94>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
   12134:	00bffcc4 	movi	r2,-13
   12138:	00000a06 	br	12164 <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
   1213c:	e0bffe17 	ldw	r2,-8(fp)
   12140:	10800044 	addi	r2,r2,1
   12144:	e0bffe15 	stw	r2,-8(fp)
   12148:	00800134 	movhi	r2,4
   1214c:	1095c804 	addi	r2,r2,22304
   12150:	10800017 	ldw	r2,0(r2)
   12154:	1007883a 	mov	r3,r2
   12158:	e0bffe17 	ldw	r2,-8(fp)
   1215c:	18bfdd2e 	bgeu	r3,r2,120d4 <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
   12160:	0005883a 	mov	r2,zero
}
   12164:	e037883a 	mov	sp,fp
   12168:	df000017 	ldw	fp,0(sp)
   1216c:	dec00104 	addi	sp,sp,4
   12170:	f800283a 	ret

00012174 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
   12174:	defff604 	addi	sp,sp,-40
   12178:	dfc00915 	stw	ra,36(sp)
   1217c:	df000815 	stw	fp,32(sp)
   12180:	df000804 	addi	fp,sp,32
   12184:	e13ffd15 	stw	r4,-12(fp)
   12188:	e17ffe15 	stw	r5,-8(fp)
   1218c:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
   12190:	00bfffc4 	movi	r2,-1
   12194:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
   12198:	00bffb44 	movi	r2,-19
   1219c:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
   121a0:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
   121a4:	e13ffd17 	ldw	r4,-12(fp)
   121a8:	01400134 	movhi	r5,4
   121ac:	2955c604 	addi	r5,r5,22296
   121b0:	003c8ac0 	call	3c8ac <alt_find_dev>
   121b4:	e0bff815 	stw	r2,-32(fp)
   121b8:	e0bff817 	ldw	r2,-32(fp)
   121bc:	1000051e 	bne	r2,zero,121d4 <open+0x60>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
   121c0:	e13ffd17 	ldw	r4,-12(fp)
   121c4:	003c93c0 	call	3c93c <alt_find_file>
   121c8:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
   121cc:	00800044 	movi	r2,1
   121d0:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
   121d4:	e0bff817 	ldw	r2,-32(fp)
   121d8:	10002926 	beq	r2,zero,12280 <open+0x10c>
  {
    if ((index = alt_get_fd (dev)) < 0)
   121dc:	e13ff817 	ldw	r4,-32(fp)
   121e0:	003cb080 	call	3cb08 <alt_get_fd>
   121e4:	e0bff915 	stw	r2,-28(fp)
   121e8:	e0bff917 	ldw	r2,-28(fp)
   121ec:	1000030e 	bge	r2,zero,121fc <open+0x88>
    {
      status = index;
   121f0:	e0bff917 	ldw	r2,-28(fp)
   121f4:	e0bffa15 	stw	r2,-24(fp)
   121f8:	00002306 	br	12288 <open+0x114>
    }
    else
    {
      fd = &alt_fd_list[index];
   121fc:	e0bff917 	ldw	r2,-28(fp)
   12200:	10c00324 	muli	r3,r2,12
   12204:	00800134 	movhi	r2,4
   12208:	108f5b04 	addi	r2,r2,15724
   1220c:	1885883a 	add	r2,r3,r2
   12210:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
   12214:	e0fffe17 	ldw	r3,-8(fp)
   12218:	00900034 	movhi	r2,16384
   1221c:	10bfffc4 	addi	r2,r2,-1
   12220:	1886703a 	and	r3,r3,r2
   12224:	e0bffc17 	ldw	r2,-16(fp)
   12228:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
   1222c:	e0bffb17 	ldw	r2,-20(fp)
   12230:	1000051e 	bne	r2,zero,12248 <open+0xd4>
   12234:	e13ffc17 	ldw	r4,-16(fp)
   12238:	00120a80 	call	120a8 <alt_file_locked>
   1223c:	e0bffa15 	stw	r2,-24(fp)
   12240:	e0bffa17 	ldw	r2,-24(fp)
   12244:	10001016 	blt	r2,zero,12288 <open+0x114>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
   12248:	e0bff817 	ldw	r2,-32(fp)
   1224c:	10800317 	ldw	r2,12(r2)
   12250:	10000826 	beq	r2,zero,12274 <open+0x100>
   12254:	e0bff817 	ldw	r2,-32(fp)
   12258:	10800317 	ldw	r2,12(r2)
   1225c:	e13ffc17 	ldw	r4,-16(fp)
   12260:	e17ffd17 	ldw	r5,-12(fp)
   12264:	e1bffe17 	ldw	r6,-8(fp)
   12268:	e1ffff17 	ldw	r7,-4(fp)
   1226c:	103ee83a 	callr	r2
   12270:	00000106 	br	12278 <open+0x104>
   12274:	0005883a 	mov	r2,zero
   12278:	e0bffa15 	stw	r2,-24(fp)
   1227c:	00000206 	br	12288 <open+0x114>
      }
    }
  }
  else
  {
    status = -ENODEV;
   12280:	00bffb44 	movi	r2,-19
   12284:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
   12288:	e0bffa17 	ldw	r2,-24(fp)
   1228c:	1000080e 	bge	r2,zero,122b0 <open+0x13c>
  {
    alt_release_fd (index);  
   12290:	e13ff917 	ldw	r4,-28(fp)
   12294:	00122c80 	call	122c8 <alt_release_fd>
    ALT_ERRNO = -status;
   12298:	00120580 	call	12058 <alt_get_errno>
   1229c:	e0fffa17 	ldw	r3,-24(fp)
   122a0:	00c7c83a 	sub	r3,zero,r3
   122a4:	10c00015 	stw	r3,0(r2)
    return -1;
   122a8:	00bfffc4 	movi	r2,-1
   122ac:	00000106 	br	122b4 <open+0x140>
  }
  
  /* return the reference upon success */

  return index;
   122b0:	e0bff917 	ldw	r2,-28(fp)
}
   122b4:	e037883a 	mov	sp,fp
   122b8:	dfc00117 	ldw	ra,4(sp)
   122bc:	df000017 	ldw	fp,0(sp)
   122c0:	dec00204 	addi	sp,sp,8
   122c4:	f800283a 	ret

000122c8 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
   122c8:	defffe04 	addi	sp,sp,-8
   122cc:	df000115 	stw	fp,4(sp)
   122d0:	df000104 	addi	fp,sp,4
   122d4:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
   122d8:	e0bfff17 	ldw	r2,-4(fp)
   122dc:	108000d0 	cmplti	r2,r2,3
   122e0:	10000d1e 	bne	r2,zero,12318 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
   122e4:	00c00134 	movhi	r3,4
   122e8:	18cf5b04 	addi	r3,r3,15724
   122ec:	e0bfff17 	ldw	r2,-4(fp)
   122f0:	10800324 	muli	r2,r2,12
   122f4:	1885883a 	add	r2,r3,r2
   122f8:	10800204 	addi	r2,r2,8
   122fc:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
   12300:	00c00134 	movhi	r3,4
   12304:	18cf5b04 	addi	r3,r3,15724
   12308:	e0bfff17 	ldw	r2,-4(fp)
   1230c:	10800324 	muli	r2,r2,12
   12310:	1885883a 	add	r2,r3,r2
   12314:	10000015 	stw	zero,0(r2)
  }
}
   12318:	e037883a 	mov	sp,fp
   1231c:	df000017 	ldw	fp,0(sp)
   12320:	dec00104 	addi	sp,sp,4
   12324:	f800283a 	ret

00012328 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
   12328:	defff704 	addi	sp,sp,-36
   1232c:	df000815 	stw	fp,32(sp)
   12330:	df000804 	addi	fp,sp,32
   12334:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   12338:	0005303a 	rdctl	r2,status
   1233c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   12340:	e0fffa17 	ldw	r3,-24(fp)
   12344:	00bfff84 	movi	r2,-2
   12348:	1884703a 	and	r2,r3,r2
   1234c:	1001703a 	wrctl	status,r2
  
  return context;
   12350:	e0bffa17 	ldw	r2,-24(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
   12354:	e0bff815 	stw	r2,-32(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
   12358:	d0a00d17 	ldw	r2,-32716(gp)
   1235c:	10c000c4 	addi	r3,r2,3
   12360:	00bfff04 	movi	r2,-4
   12364:	1884703a 	and	r2,r3,r2
   12368:	d0a00d15 	stw	r2,-32716(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
   1236c:	d0e00d17 	ldw	r3,-32716(gp)
   12370:	e0bfff17 	ldw	r2,-4(fp)
   12374:	1885883a 	add	r2,r3,r2
   12378:	00c08034 	movhi	r3,512
   1237c:	18c00004 	addi	r3,r3,0
   12380:	1880112e 	bgeu	r3,r2,123c8 <sbrk+0xa0>
   12384:	e0bff817 	ldw	r2,-32(fp)
   12388:	e0bffb15 	stw	r2,-20(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   1238c:	0005303a 	rdctl	r2,status
   12390:	e0bffc15 	stw	r2,-16(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   12394:	e0fffc17 	ldw	r3,-16(fp)
   12398:	00bfff84 	movi	r2,-2
   1239c:	1884703a 	and	r2,r3,r2
   123a0:	e0bffc15 	stw	r2,-16(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   123a4:	e0bffb17 	ldw	r2,-20(fp)
   123a8:	1080004c 	andi	r2,r2,1
   123ac:	e0fffc17 	ldw	r3,-16(fp)
   123b0:	1884b03a 	or	r2,r3,r2
   123b4:	e0bffc15 	stw	r2,-16(fp)
  
  NIOS2_WRITE_STATUS (status);
   123b8:	e0bffc17 	ldw	r2,-16(fp)
   123bc:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
   123c0:	00bfffc4 	movi	r2,-1
   123c4:	00001606 	br	12420 <sbrk+0xf8>
  }
#endif

  prev_heap_end = heap_end; 
   123c8:	d0a00d17 	ldw	r2,-32716(gp)
   123cc:	e0bff915 	stw	r2,-28(fp)
  heap_end += incr; 
   123d0:	d0e00d17 	ldw	r3,-32716(gp)
   123d4:	e0bfff17 	ldw	r2,-4(fp)
   123d8:	1885883a 	add	r2,r3,r2
   123dc:	d0a00d15 	stw	r2,-32716(gp)
   123e0:	e0bff817 	ldw	r2,-32(fp)
   123e4:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   123e8:	0005303a 	rdctl	r2,status
   123ec:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   123f0:	e0fffe17 	ldw	r3,-8(fp)
   123f4:	00bfff84 	movi	r2,-2
   123f8:	1884703a 	and	r2,r3,r2
   123fc:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   12400:	e0bffd17 	ldw	r2,-12(fp)
   12404:	1080004c 	andi	r2,r2,1
   12408:	e0fffe17 	ldw	r3,-8(fp)
   1240c:	1884b03a 	or	r2,r3,r2
   12410:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
   12414:	e0bffe17 	ldw	r2,-8(fp)
   12418:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
   1241c:	e0bff917 	ldw	r2,-28(fp)
} 
   12420:	e037883a 	mov	sp,fp
   12424:	df000017 	ldw	fp,0(sp)
   12428:	dec00104 	addi	sp,sp,4
   1242c:	f800283a 	ret

00012430 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
   12430:	defffb04 	addi	sp,sp,-20
   12434:	dfc00415 	stw	ra,16(sp)
   12438:	df000315 	stw	fp,12(sp)
   1243c:	df000304 	addi	fp,sp,12
   12440:	e13fff15 	stw	r4,-4(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * vTaskDelay (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (!xTaskGetSchedulerState())
   12444:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   12448:	1000031e 	bne	r2,zero,12458 <usleep+0x28>
  {
    return alt_busy_sleep (us);
   1244c:	e13fff17 	ldw	r4,-4(fp)
   12450:	003c53c0 	call	3c53c <alt_busy_sleep>
   12454:	00003306 	br	12524 <usleep+0xf4>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
   12458:	00800134 	movhi	r2,4
   1245c:	109f0c04 	addi	r2,r2,31792
   12460:	10800017 	ldw	r2,0(r2)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
   12464:	e0bffe15 	stw	r2,-8(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
   12468:	e0ffff17 	ldw	r3,-4(fp)
   1246c:	008003f4 	movhi	r2,15
   12470:	10909004 	addi	r2,r2,16960
   12474:	1887203a 	divu	r3,r3,r2
   12478:	e0bffe17 	ldw	r2,-8(fp)
   1247c:	1887383a 	mul	r3,r3,r2
   12480:	e0bfff17 	ldw	r2,-4(fp)
   12484:	010003f4 	movhi	r4,15
   12488:	21109004 	addi	r4,r4,16960
   1248c:	110b203a 	divu	r5,r2,r4
   12490:	010003f4 	movhi	r4,15
   12494:	21109004 	addi	r4,r4,16960
   12498:	2909383a 	mul	r4,r5,r4
   1249c:	1109c83a 	sub	r4,r2,r4
   124a0:	e0bffe17 	ldw	r2,-8(fp)
   124a4:	2089383a 	mul	r4,r4,r2
   124a8:	008003f4 	movhi	r2,15
   124ac:	10909004 	addi	r2,r2,16960
   124b0:	2085203a 	divu	r2,r4,r2
   124b4:	1885883a 	add	r2,r3,r2
   124b8:	e0bffd15 	stw	r2,-12(fp)
   * vTaskDelay can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
   124bc:	00000706 	br	124dc <usleep+0xac>
  {
    vTaskDelay(0xffff);
   124c0:	013fffd4 	movui	r4,65535
   124c4:	000f8c00 	call	f8c0 <vTaskDelay>
    ticks -= 0xffff;
   124c8:	e0fffd17 	ldw	r3,-12(fp)
   124cc:	00bffff4 	movhi	r2,65535
   124d0:	10800044 	addi	r2,r2,1
   124d4:	1885883a 	add	r2,r3,r2
   124d8:	e0bffd15 	stw	r2,-12(fp)
   * vTaskDelay can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
   124dc:	e0bffd17 	ldw	r2,-12(fp)
   124e0:	00ffffd4 	movui	r3,65535
   124e4:	18bff636 	bltu	r3,r2,124c0 <usleep+0x90>
  {
    vTaskDelay(0xffff);
    ticks -= 0xffff;
  }

  vTaskDelay ((alt_u16) (ticks));
   124e8:	e0bffd17 	ldw	r2,-12(fp)
   124ec:	10bfffcc 	andi	r2,r2,65535
   124f0:	1009883a 	mov	r4,r2
   124f4:	000f8c00 	call	f8c0 <vTaskDelay>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
   124f8:	00c003f4 	movhi	r3,15
   124fc:	18d09004 	addi	r3,r3,16960
   12500:	e0bffe17 	ldw	r2,-8(fp)
   12504:	1887203a 	divu	r3,r3,r2
   12508:	e0bfff17 	ldw	r2,-4(fp)
   1250c:	10c9203a 	divu	r4,r2,r3
   12510:	20c7383a 	mul	r3,r4,r3
   12514:	10c5c83a 	sub	r2,r2,r3
   12518:	1009883a 	mov	r4,r2
   1251c:	003c53c0 	call	3c53c <alt_busy_sleep>

  return 0;  
   12520:	0005883a 	mov	r2,zero
}
   12524:	e037883a 	mov	sp,fp
   12528:	dfc00117 	ldw	ra,4(sp)
   1252c:	df000017 	ldw	fp,0(sp)
   12530:	dec00204 	addi	sp,sp,8
   12534:	f800283a 	ret

00012538 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
   12538:	defff404 	addi	sp,sp,-48
   1253c:	dfc00b15 	stw	ra,44(sp)
   12540:	df000a15 	stw	fp,40(sp)
   12544:	df000a04 	addi	fp,sp,40
   12548:	e13ffd15 	stw	r4,-12(fp)
   1254c:	2805883a 	mov	r2,r5
   12550:	e1bfff15 	stw	r6,-4(fp)
   12554:	e0bffe05 	stb	r2,-8(fp)
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
   12558:	e13ffd17 	ldw	r4,-12(fp)
   1255c:	e17fff17 	ldw	r5,-4(fp)
   12560:	00141a80 	call	141a8 <netconn_alloc>
   12564:	e0bff615 	stw	r2,-40(fp)
  if (conn != NULL) {
   12568:	e0bff617 	ldw	r2,-40(fp)
   1256c:	10001b26 	beq	r2,zero,125dc <netconn_new_with_proto_and_callback+0xa4>
    msg.function = do_newconn;
   12570:	00800074 	movhi	r2,1
   12574:	10905304 	addi	r2,r2,16716
   12578:	e0bff715 	stw	r2,-36(fp)
    msg.msg.msg.n.proto = proto;
   1257c:	e0bffe03 	ldbu	r2,-8(fp)
   12580:	e0bffa05 	stb	r2,-24(fp)
    msg.msg.conn = conn;
   12584:	e0bff617 	ldw	r2,-40(fp)
   12588:	e0bff815 	stw	r2,-32(fp)
    if (TCPIP_APIMSG(&msg) != ERR_OK) {
   1258c:	e0bff704 	addi	r2,fp,-36
   12590:	1009883a 	mov	r4,r2
   12594:	00197440 	call	19744 <tcpip_apimsg>
   12598:	10803fcc 	andi	r2,r2,255
   1259c:	1080201c 	xori	r2,r2,128
   125a0:	10bfe004 	addi	r2,r2,-128
   125a4:	10000d26 	beq	r2,zero,125dc <netconn_new_with_proto_and_callback+0xa4>
      LWIP_ASSERT("conn has no op_completed", sys_sem_valid(&conn->op_completed));
      LWIP_ASSERT("conn has no recvmbox", sys_mbox_valid(&conn->recvmbox));
#if LWIP_TCP
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", !sys_mbox_valid(&conn->acceptmbox));
#endif /* LWIP_TCP */
      sys_sem_free(&conn->op_completed);
   125a8:	e0bff617 	ldw	r2,-40(fp)
   125ac:	10800404 	addi	r2,r2,16
   125b0:	1009883a 	mov	r4,r2
   125b4:	001b29c0 	call	1b29c <sys_sem_free>
      sys_mbox_free(&conn->recvmbox);
   125b8:	e0bff617 	ldw	r2,-40(fp)
   125bc:	10800504 	addi	r2,r2,20
   125c0:	1009883a 	mov	r4,r2
   125c4:	001b6900 	call	1b690 <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
   125c8:	01000204 	movi	r4,8
   125cc:	e17ff617 	ldw	r5,-40(fp)
   125d0:	00225900 	call	22590 <memp_free>
      return NULL;
   125d4:	0005883a 	mov	r2,zero
   125d8:	00000106 	br	125e0 <netconn_new_with_proto_and_callback+0xa8>
    }
  }
  return conn;
   125dc:	e0bff617 	ldw	r2,-40(fp)
}
   125e0:	e037883a 	mov	sp,fp
   125e4:	dfc00117 	ldw	ra,4(sp)
   125e8:	df000017 	ldw	fp,0(sp)
   125ec:	dec00204 	addi	sp,sp,8
   125f0:	f800283a 	ret

000125f4 <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
   125f4:	defff704 	addi	sp,sp,-36
   125f8:	dfc00815 	stw	ra,32(sp)
   125fc:	df000715 	stw	fp,28(sp)
   12600:	df000704 	addi	fp,sp,28
   12604:	e13fff15 	stw	r4,-4(fp)
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
   12608:	e0bfff17 	ldw	r2,-4(fp)
   1260c:	1000021e 	bne	r2,zero,12618 <netconn_delete+0x24>
    return ERR_OK;
   12610:	0005883a 	mov	r2,zero
   12614:	00000a06 	br	12640 <netconn_delete+0x4c>
  }

  msg.function = do_delconn;
   12618:	00800074 	movhi	r2,1
   1261c:	1091c804 	addi	r2,r2,18208
   12620:	e0bff915 	stw	r2,-28(fp)
  msg.msg.conn = conn;
   12624:	e0bfff17 	ldw	r2,-4(fp)
   12628:	e0bffa15 	stw	r2,-24(fp)
  tcpip_apimsg(&msg);
   1262c:	e13ff904 	addi	r4,fp,-28
   12630:	00197440 	call	19744 <tcpip_apimsg>

  netconn_free(conn);
   12634:	e13fff17 	ldw	r4,-4(fp)
   12638:	00142d40 	call	142d4 <netconn_free>

  /* don't care for return value of do_delconn since it only calls void functions */

  return ERR_OK;
   1263c:	0005883a 	mov	r2,zero
}
   12640:	e037883a 	mov	sp,fp
   12644:	dfc00117 	ldw	ra,4(sp)
   12648:	df000017 	ldw	fp,0(sp)
   1264c:	dec00204 	addi	sp,sp,8
   12650:	f800283a 	ret

00012654 <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, ip_addr_t *addr, u16_t *port, u8_t local)
{
   12654:	defff304 	addi	sp,sp,-52
   12658:	dfc00c15 	stw	ra,48(sp)
   1265c:	df000b15 	stw	fp,44(sp)
   12660:	df000b04 	addi	fp,sp,44
   12664:	e13ffc15 	stw	r4,-16(fp)
   12668:	e17ffd15 	stw	r5,-12(fp)
   1266c:	e1bffe15 	stw	r6,-8(fp)
   12670:	3805883a 	mov	r2,r7
   12674:	e0bfff05 	stb	r2,-4(fp)
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
   12678:	e0bffc17 	ldw	r2,-16(fp)
   1267c:	1000091e 	bne	r2,zero,126a4 <netconn_getaddr+0x50>
   12680:	01000134 	movhi	r4,4
   12684:	21027904 	addi	r4,r4,2532
   12688:	01400134 	movhi	r5,4
   1268c:	29428504 	addi	r5,r5,2580
   12690:	01802304 	movi	r6,140
   12694:	01c00134 	movhi	r7,4
   12698:	39c28d04 	addi	r7,r7,2612
   1269c:	00044740 	call	4474 <printf>
   126a0:	003fff06 	br	126a0 <netconn_getaddr+0x4c>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
   126a4:	e0bffd17 	ldw	r2,-12(fp)
   126a8:	1000091e 	bne	r2,zero,126d0 <netconn_getaddr+0x7c>
   126ac:	01000134 	movhi	r4,4
   126b0:	21027904 	addi	r4,r4,2532
   126b4:	01400134 	movhi	r5,4
   126b8:	29429304 	addi	r5,r5,2636
   126bc:	01802344 	movi	r6,141
   126c0:	01c00134 	movhi	r7,4
   126c4:	39c28d04 	addi	r7,r7,2612
   126c8:	00044740 	call	4474 <printf>
   126cc:	003fff06 	br	126cc <netconn_getaddr+0x78>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
   126d0:	e0bffe17 	ldw	r2,-8(fp)
   126d4:	1000091e 	bne	r2,zero,126fc <netconn_getaddr+0xa8>
   126d8:	01000134 	movhi	r4,4
   126dc:	21027904 	addi	r4,r4,2532
   126e0:	01400134 	movhi	r5,4
   126e4:	29429b04 	addi	r5,r5,2668
   126e8:	01802384 	movi	r6,142
   126ec:	01c00134 	movhi	r7,4
   126f0:	39c28d04 	addi	r7,r7,2612
   126f4:	00044740 	call	4474 <printf>
   126f8:	003fff06 	br	126f8 <netconn_getaddr+0xa4>

  msg.function = do_getaddr;
   126fc:	00800074 	movhi	r2,1
   12700:	1095e604 	addi	r2,r2,22424
   12704:	e0bff615 	stw	r2,-40(fp)
  msg.msg.conn = conn;
   12708:	e0bffc17 	ldw	r2,-16(fp)
   1270c:	e0bff715 	stw	r2,-36(fp)
  msg.msg.msg.ad.ipaddr = addr;
   12710:	e0bffd17 	ldw	r2,-12(fp)
   12714:	e0bff915 	stw	r2,-28(fp)
  msg.msg.msg.ad.port = port;
   12718:	e0bffe17 	ldw	r2,-8(fp)
   1271c:	e0bffa15 	stw	r2,-24(fp)
  msg.msg.msg.ad.local = local;
   12720:	e0bfff03 	ldbu	r2,-4(fp)
   12724:	e0bffb05 	stb	r2,-20(fp)
  err = TCPIP_APIMSG(&msg);
   12728:	e0bff604 	addi	r2,fp,-40
   1272c:	1009883a 	mov	r4,r2
   12730:	00197440 	call	19744 <tcpip_apimsg>
   12734:	e0bff505 	stb	r2,-44(fp)

  NETCONN_SET_SAFE_ERR(conn, err);
   12738:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   1273c:	10000126 	beq	r2,zero,12744 <netconn_getaddr+0xf0>
   12740:	00110d00 	call	110d0 <vTaskEnterCritical>
   12744:	e0bffc17 	ldw	r2,-16(fp)
   12748:	10800303 	ldbu	r2,12(r2)
   1274c:	10803fcc 	andi	r2,r2,255
   12750:	1080201c 	xori	r2,r2,128
   12754:	10bfe004 	addi	r2,r2,-128
   12758:	10bffdd0 	cmplti	r2,r2,-9
   1275c:	1000031e 	bne	r2,zero,1276c <netconn_getaddr+0x118>
   12760:	e0bffc17 	ldw	r2,-16(fp)
   12764:	e0fff503 	ldbu	r3,-44(fp)
   12768:	10c00305 	stb	r3,12(r2)
   1276c:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   12770:	10000126 	beq	r2,zero,12778 <netconn_getaddr+0x124>
   12774:	00111100 	call	11110 <vTaskExitCritical>
  return err;
   12778:	e0bff503 	ldbu	r2,-44(fp)
}
   1277c:	e037883a 	mov	sp,fp
   12780:	dfc00117 	ldw	ra,4(sp)
   12784:	df000017 	ldw	fp,0(sp)
   12788:	dec00204 	addi	sp,sp,8
   1278c:	f800283a 	ret

00012790 <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, ip_addr_t *addr, u16_t port)
{
   12790:	defff404 	addi	sp,sp,-48
   12794:	dfc00b15 	stw	ra,44(sp)
   12798:	df000a15 	stw	fp,40(sp)
   1279c:	df000a04 	addi	fp,sp,40
   127a0:	e13ffd15 	stw	r4,-12(fp)
   127a4:	e17ffe15 	stw	r5,-8(fp)
   127a8:	3005883a 	mov	r2,r6
   127ac:	e0bfff0d 	sth	r2,-4(fp)
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
   127b0:	e0bffd17 	ldw	r2,-12(fp)
   127b4:	1000091e 	bne	r2,zero,127dc <netconn_bind+0x4c>
   127b8:	01000134 	movhi	r4,4
   127bc:	21027904 	addi	r4,r4,2532
   127c0:	01400134 	movhi	r5,4
   127c4:	2942a304 	addi	r5,r5,2700
   127c8:	01802ac4 	movi	r6,171
   127cc:	01c00134 	movhi	r7,4
   127d0:	39c28d04 	addi	r7,r7,2612
   127d4:	00044740 	call	4474 <printf>
   127d8:	003fff06 	br	127d8 <netconn_bind+0x48>

  msg.function = do_bind;
   127dc:	00800074 	movhi	r2,1
   127e0:	10923e04 	addi	r2,r2,18680
   127e4:	e0bff715 	stw	r2,-36(fp)
  msg.msg.conn = conn;
   127e8:	e0bffd17 	ldw	r2,-12(fp)
   127ec:	e0bff815 	stw	r2,-32(fp)
  msg.msg.msg.bc.ipaddr = addr;
   127f0:	e0bffe17 	ldw	r2,-8(fp)
   127f4:	e0bffa15 	stw	r2,-24(fp)
  msg.msg.msg.bc.port = port;
   127f8:	e0bfff0b 	ldhu	r2,-4(fp)
   127fc:	e0bffb0d 	sth	r2,-20(fp)
  err = TCPIP_APIMSG(&msg);
   12800:	e0bff704 	addi	r2,fp,-36
   12804:	1009883a 	mov	r4,r2
   12808:	00197440 	call	19744 <tcpip_apimsg>
   1280c:	e0bff605 	stb	r2,-40(fp)

  NETCONN_SET_SAFE_ERR(conn, err);
   12810:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   12814:	10000126 	beq	r2,zero,1281c <netconn_bind+0x8c>
   12818:	00110d00 	call	110d0 <vTaskEnterCritical>
   1281c:	e0bffd17 	ldw	r2,-12(fp)
   12820:	10800303 	ldbu	r2,12(r2)
   12824:	10803fcc 	andi	r2,r2,255
   12828:	1080201c 	xori	r2,r2,128
   1282c:	10bfe004 	addi	r2,r2,-128
   12830:	10bffdd0 	cmplti	r2,r2,-9
   12834:	1000031e 	bne	r2,zero,12844 <netconn_bind+0xb4>
   12838:	e0bffd17 	ldw	r2,-12(fp)
   1283c:	e0fff603 	ldbu	r3,-40(fp)
   12840:	10c00305 	stb	r3,12(r2)
   12844:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   12848:	10000126 	beq	r2,zero,12850 <netconn_bind+0xc0>
   1284c:	00111100 	call	11110 <vTaskExitCritical>
  return err;
   12850:	e0bff603 	ldbu	r2,-40(fp)
}
   12854:	e037883a 	mov	sp,fp
   12858:	dfc00117 	ldw	ra,4(sp)
   1285c:	df000017 	ldw	fp,0(sp)
   12860:	dec00204 	addi	sp,sp,8
   12864:	f800283a 	ret

00012868 <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, ip_addr_t *addr, u16_t port)
{
   12868:	defff404 	addi	sp,sp,-48
   1286c:	dfc00b15 	stw	ra,44(sp)
   12870:	df000a15 	stw	fp,40(sp)
   12874:	df000a04 	addi	fp,sp,40
   12878:	e13ffd15 	stw	r4,-12(fp)
   1287c:	e17ffe15 	stw	r5,-8(fp)
   12880:	3005883a 	mov	r2,r6
   12884:	e0bfff0d 	sth	r2,-4(fp)
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
   12888:	e0bffd17 	ldw	r2,-12(fp)
   1288c:	1000091e 	bne	r2,zero,128b4 <netconn_connect+0x4c>
   12890:	01000134 	movhi	r4,4
   12894:	21027904 	addi	r4,r4,2532
   12898:	01400134 	movhi	r5,4
   1289c:	2942aa04 	addi	r5,r5,2728
   128a0:	01803144 	movi	r6,197
   128a4:	01c00134 	movhi	r7,4
   128a8:	39c28d04 	addi	r7,r7,2612
   128ac:	00044740 	call	4474 <printf>
   128b0:	003fff06 	br	128b0 <netconn_connect+0x48>

  msg.function = do_connect;
   128b4:	00800074 	movhi	r2,1
   128b8:	1092ea04 	addi	r2,r2,19368
   128bc:	e0bff715 	stw	r2,-36(fp)
  msg.msg.conn = conn;
   128c0:	e0bffd17 	ldw	r2,-12(fp)
   128c4:	e0bff815 	stw	r2,-32(fp)
  msg.msg.msg.bc.ipaddr = addr;
   128c8:	e0bffe17 	ldw	r2,-8(fp)
   128cc:	e0bffa15 	stw	r2,-24(fp)
  msg.msg.msg.bc.port = port;
   128d0:	e0bfff0b 	ldhu	r2,-4(fp)
   128d4:	e0bffb0d 	sth	r2,-20(fp)
  /* This is the only function which need to not block tcpip_thread */
  err = tcpip_apimsg(&msg);
   128d8:	e0bff704 	addi	r2,fp,-36
   128dc:	1009883a 	mov	r4,r2
   128e0:	00197440 	call	19744 <tcpip_apimsg>
   128e4:	e0bff605 	stb	r2,-40(fp)

  NETCONN_SET_SAFE_ERR(conn, err);
   128e8:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   128ec:	10000126 	beq	r2,zero,128f4 <netconn_connect+0x8c>
   128f0:	00110d00 	call	110d0 <vTaskEnterCritical>
   128f4:	e0bffd17 	ldw	r2,-12(fp)
   128f8:	10800303 	ldbu	r2,12(r2)
   128fc:	10803fcc 	andi	r2,r2,255
   12900:	1080201c 	xori	r2,r2,128
   12904:	10bfe004 	addi	r2,r2,-128
   12908:	10bffdd0 	cmplti	r2,r2,-9
   1290c:	1000031e 	bne	r2,zero,1291c <netconn_connect+0xb4>
   12910:	e0bffd17 	ldw	r2,-12(fp)
   12914:	e0fff603 	ldbu	r3,-40(fp)
   12918:	10c00305 	stb	r3,12(r2)
   1291c:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   12920:	10000126 	beq	r2,zero,12928 <netconn_connect+0xc0>
   12924:	00111100 	call	11110 <vTaskExitCritical>
  return err;
   12928:	e0bff603 	ldbu	r2,-40(fp)
}
   1292c:	e037883a 	mov	sp,fp
   12930:	dfc00117 	ldw	ra,4(sp)
   12934:	df000017 	ldw	fp,0(sp)
   12938:	dec00204 	addi	sp,sp,8
   1293c:	f800283a 	ret

00012940 <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
   12940:	defff604 	addi	sp,sp,-40
   12944:	dfc00915 	stw	ra,36(sp)
   12948:	df000815 	stw	fp,32(sp)
   1294c:	df000804 	addi	fp,sp,32
   12950:	e13fff15 	stw	r4,-4(fp)
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
   12954:	e0bfff17 	ldw	r2,-4(fp)
   12958:	1000091e 	bne	r2,zero,12980 <netconn_disconnect+0x40>
   1295c:	01000134 	movhi	r4,4
   12960:	21027904 	addi	r4,r4,2532
   12964:	01400134 	movhi	r5,4
   12968:	2942b204 	addi	r5,r5,2760
   1296c:	01803784 	movi	r6,222
   12970:	01c00134 	movhi	r7,4
   12974:	39c28d04 	addi	r7,r7,2612
   12978:	00044740 	call	4474 <printf>
   1297c:	003fff06 	br	1297c <netconn_disconnect+0x3c>

  msg.function = do_disconnect;
   12980:	00800074 	movhi	r2,1
   12984:	10937804 	addi	r2,r2,19936
   12988:	e0bff915 	stw	r2,-28(fp)
  msg.msg.conn = conn;
   1298c:	e0bfff17 	ldw	r2,-4(fp)
   12990:	e0bffa15 	stw	r2,-24(fp)
  err = TCPIP_APIMSG(&msg);
   12994:	e0bff904 	addi	r2,fp,-28
   12998:	1009883a 	mov	r4,r2
   1299c:	00197440 	call	19744 <tcpip_apimsg>
   129a0:	e0bff805 	stb	r2,-32(fp)

  NETCONN_SET_SAFE_ERR(conn, err);
   129a4:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   129a8:	10000126 	beq	r2,zero,129b0 <netconn_disconnect+0x70>
   129ac:	00110d00 	call	110d0 <vTaskEnterCritical>
   129b0:	e0bfff17 	ldw	r2,-4(fp)
   129b4:	10800303 	ldbu	r2,12(r2)
   129b8:	10803fcc 	andi	r2,r2,255
   129bc:	1080201c 	xori	r2,r2,128
   129c0:	10bfe004 	addi	r2,r2,-128
   129c4:	10bffdd0 	cmplti	r2,r2,-9
   129c8:	1000031e 	bne	r2,zero,129d8 <netconn_disconnect+0x98>
   129cc:	e0bfff17 	ldw	r2,-4(fp)
   129d0:	e0fff803 	ldbu	r3,-32(fp)
   129d4:	10c00305 	stb	r3,12(r2)
   129d8:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   129dc:	10000126 	beq	r2,zero,129e4 <netconn_disconnect+0xa4>
   129e0:	00111100 	call	11110 <vTaskExitCritical>
  return err;
   129e4:	e0bff803 	ldbu	r2,-32(fp)
}
   129e8:	e037883a 	mov	sp,fp
   129ec:	dfc00117 	ldw	ra,4(sp)
   129f0:	df000017 	ldw	fp,0(sp)
   129f4:	dec00204 	addi	sp,sp,8
   129f8:	f800283a 	ret

000129fc <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
   129fc:	defff504 	addi	sp,sp,-44
   12a00:	dfc00a15 	stw	ra,40(sp)
   12a04:	df000915 	stw	fp,36(sp)
   12a08:	df000904 	addi	fp,sp,36
   12a0c:	e13ffe15 	stw	r4,-8(fp)
   12a10:	2805883a 	mov	r2,r5
   12a14:	e0bfff05 	stb	r2,-4(fp)
  err_t err;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
   12a18:	e0bffe17 	ldw	r2,-8(fp)
   12a1c:	1000091e 	bne	r2,zero,12a44 <netconn_listen_with_backlog+0x48>
   12a20:	01000134 	movhi	r4,4
   12a24:	21027904 	addi	r4,r4,2532
   12a28:	01400134 	movhi	r5,4
   12a2c:	2942bb04 	addi	r5,r5,2796
   12a30:	01803e84 	movi	r6,250
   12a34:	01c00134 	movhi	r7,4
   12a38:	39c28d04 	addi	r7,r7,2612
   12a3c:	00044740 	call	4474 <printf>
   12a40:	003fff06 	br	12a40 <netconn_listen_with_backlog+0x44>

  msg.function = do_listen;
   12a44:	00800074 	movhi	r2,1
   12a48:	10939804 	addi	r2,r2,20064
   12a4c:	e0bff815 	stw	r2,-32(fp)
  msg.msg.conn = conn;
   12a50:	e0bffe17 	ldw	r2,-8(fp)
   12a54:	e0bff915 	stw	r2,-28(fp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
   12a58:	e0bfff03 	ldbu	r2,-4(fp)
   12a5c:	e0bffb05 	stb	r2,-20(fp)
#endif /* TCP_LISTEN_BACKLOG */
  err = TCPIP_APIMSG(&msg);
   12a60:	e0bff804 	addi	r2,fp,-32
   12a64:	1009883a 	mov	r4,r2
   12a68:	00197440 	call	19744 <tcpip_apimsg>
   12a6c:	e0bff705 	stb	r2,-36(fp)

  NETCONN_SET_SAFE_ERR(conn, err);
   12a70:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   12a74:	10000126 	beq	r2,zero,12a7c <netconn_listen_with_backlog+0x80>
   12a78:	00110d00 	call	110d0 <vTaskEnterCritical>
   12a7c:	e0bffe17 	ldw	r2,-8(fp)
   12a80:	10800303 	ldbu	r2,12(r2)
   12a84:	10803fcc 	andi	r2,r2,255
   12a88:	1080201c 	xori	r2,r2,128
   12a8c:	10bfe004 	addi	r2,r2,-128
   12a90:	10bffdd0 	cmplti	r2,r2,-9
   12a94:	1000031e 	bne	r2,zero,12aa4 <netconn_listen_with_backlog+0xa8>
   12a98:	e0bffe17 	ldw	r2,-8(fp)
   12a9c:	e0fff703 	ldbu	r3,-36(fp)
   12aa0:	10c00305 	stb	r3,12(r2)
   12aa4:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   12aa8:	10000126 	beq	r2,zero,12ab0 <netconn_listen_with_backlog+0xb4>
   12aac:	00111100 	call	11110 <vTaskExitCritical>
  return err;
   12ab0:	e0bff703 	ldbu	r2,-36(fp)
#else /* LWIP_TCP */
  LWIP_UNUSED_ARG(conn);
  LWIP_UNUSED_ARG(backlog);
  return ERR_ARG;
#endif /* LWIP_TCP */
}
   12ab4:	e037883a 	mov	sp,fp
   12ab8:	dfc00117 	ldw	ra,4(sp)
   12abc:	df000017 	ldw	fp,0(sp)
   12ac0:	dec00204 	addi	sp,sp,8
   12ac4:	f800283a 	ret

00012ac8 <netconn_accept>:
 * @return ERR_OK if a new connection has been received or an error
 *                code otherwise
 */
err_t
netconn_accept(struct netconn *conn, struct netconn **new_conn)
{
   12ac8:	defff404 	addi	sp,sp,-48
   12acc:	dfc00b15 	stw	ra,44(sp)
   12ad0:	df000a15 	stw	fp,40(sp)
   12ad4:	df000a04 	addi	fp,sp,40
   12ad8:	e13ffe15 	stw	r4,-8(fp)
   12adc:	e17fff15 	stw	r5,-4(fp)
  err_t err;
#if TCP_LISTEN_BACKLOG
  struct api_msg msg;
#endif /* TCP_LISTEN_BACKLOG */

  LWIP_ERROR("netconn_accept: invalid pointer",    (new_conn != NULL),                  return ERR_ARG;);
   12ae0:	e0bfff17 	ldw	r2,-4(fp)
   12ae4:	1000091e 	bne	r2,zero,12b0c <netconn_accept+0x44>
   12ae8:	01000134 	movhi	r4,4
   12aec:	21027904 	addi	r4,r4,2532
   12af0:	01400134 	movhi	r5,4
   12af4:	2942c304 	addi	r5,r5,2828
   12af8:	01804784 	movi	r6,286
   12afc:	01c00134 	movhi	r7,4
   12b00:	39c28d04 	addi	r7,r7,2612
   12b04:	00044740 	call	4474 <printf>
   12b08:	003fff06 	br	12b08 <netconn_accept+0x40>
  *new_conn = NULL;
   12b0c:	e0bfff17 	ldw	r2,-4(fp)
   12b10:	10000015 	stw	zero,0(r2)
  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return ERR_ARG;);
   12b14:	e0bffe17 	ldw	r2,-8(fp)
   12b18:	1000091e 	bne	r2,zero,12b40 <netconn_accept+0x78>
   12b1c:	01000134 	movhi	r4,4
   12b20:	21027904 	addi	r4,r4,2532
   12b24:	01400134 	movhi	r5,4
   12b28:	2942cb04 	addi	r5,r5,2860
   12b2c:	01804804 	movi	r6,288
   12b30:	01c00134 	movhi	r7,4
   12b34:	39c28d04 	addi	r7,r7,2612
   12b38:	00044740 	call	4474 <printf>
   12b3c:	003fff06 	br	12b3c <netconn_accept+0x74>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", sys_mbox_valid(&conn->acceptmbox),   return ERR_ARG;);
   12b40:	e0bffe17 	ldw	r2,-8(fp)
   12b44:	10800617 	ldw	r2,24(r2)
   12b48:	1000091e 	bne	r2,zero,12b70 <netconn_accept+0xa8>
   12b4c:	01000134 	movhi	r4,4
   12b50:	21027904 	addi	r4,r4,2532
   12b54:	01400134 	movhi	r5,4
   12b58:	2942d304 	addi	r5,r5,2892
   12b5c:	01804844 	movi	r6,289
   12b60:	01c00134 	movhi	r7,4
   12b64:	39c28d04 	addi	r7,r7,2612
   12b68:	00044740 	call	4474 <printf>
   12b6c:	003fff06 	br	12b6c <netconn_accept+0xa4>

  err = conn->last_err;
   12b70:	e0bffe17 	ldw	r2,-8(fp)
   12b74:	10800303 	ldbu	r2,12(r2)
   12b78:	e0bff605 	stb	r2,-40(fp)
  if (ERR_IS_FATAL(err)) {
   12b7c:	e0bff607 	ldb	r2,-40(fp)
   12b80:	10bffdc8 	cmpgei	r2,r2,-9
   12b84:	1000021e 	bne	r2,zero,12b90 <netconn_accept+0xc8>
    /* don't recv on fatal errors: this might block the application task
       waiting on acceptmbox forever! */
    return err;
   12b88:	e0bff603 	ldbu	r2,-40(fp)
   12b8c:	00004506 	br	12ca4 <netconn_accept+0x1dc>
  }

#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(&conn->acceptmbox, (void **)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
   12b90:	e0bffe17 	ldw	r2,-8(fp)
   12b94:	11000604 	addi	r4,r2,24
   12b98:	e0bffe17 	ldw	r2,-8(fp)
   12b9c:	10800817 	ldw	r2,32(r2)
   12ba0:	e0fff704 	addi	r3,fp,-36
   12ba4:	180b883a 	mov	r5,r3
   12ba8:	100d883a 	mov	r6,r2
   12bac:	001b7a80 	call	1b7a8 <sys_arch_mbox_fetch>
   12bb0:	10bfffd8 	cmpnei	r2,r2,-1
   12bb4:	1000121e 	bne	r2,zero,12c00 <netconn_accept+0x138>
    NETCONN_SET_SAFE_ERR(conn, ERR_TIMEOUT);
   12bb8:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   12bbc:	10000126 	beq	r2,zero,12bc4 <netconn_accept+0xfc>
   12bc0:	00110d00 	call	110d0 <vTaskEnterCritical>
   12bc4:	e0bffe17 	ldw	r2,-8(fp)
   12bc8:	10800303 	ldbu	r2,12(r2)
   12bcc:	10803fcc 	andi	r2,r2,255
   12bd0:	1080201c 	xori	r2,r2,128
   12bd4:	10bfe004 	addi	r2,r2,-128
   12bd8:	10bffdd0 	cmplti	r2,r2,-9
   12bdc:	1000031e 	bne	r2,zero,12bec <netconn_accept+0x124>
   12be0:	e0bffe17 	ldw	r2,-8(fp)
   12be4:	00ffff44 	movi	r3,-3
   12be8:	10c00305 	stb	r3,12(r2)
   12bec:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   12bf0:	10000126 	beq	r2,zero,12bf8 <netconn_accept+0x130>
   12bf4:	00111100 	call	11110 <vTaskExitCritical>
    return ERR_TIMEOUT;
   12bf8:	00bfff44 	movi	r2,-3
   12bfc:	00002906 	br	12ca4 <netconn_accept+0x1dc>
  }
#else
  sys_arch_mbox_fetch(&conn->acceptmbox, (void **)&newconn, 0);
#endif /* LWIP_SO_RCVTIMEO*/
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
   12c00:	e0bffe17 	ldw	r2,-8(fp)
   12c04:	10800c17 	ldw	r2,48(r2)
   12c08:	10000626 	beq	r2,zero,12c24 <netconn_accept+0x15c>
   12c0c:	e0bffe17 	ldw	r2,-8(fp)
   12c10:	10800c17 	ldw	r2,48(r2)
   12c14:	e13ffe17 	ldw	r4,-8(fp)
   12c18:	01400044 	movi	r5,1
   12c1c:	000d883a 	mov	r6,zero
   12c20:	103ee83a 	callr	r2

  if (newconn == NULL) {
   12c24:	e0bff717 	ldw	r2,-36(fp)
   12c28:	1000121e 	bne	r2,zero,12c74 <netconn_accept+0x1ac>
    /* connection has been aborted */
    NETCONN_SET_SAFE_ERR(conn, ERR_ABRT);
   12c2c:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   12c30:	10000126 	beq	r2,zero,12c38 <netconn_accept+0x170>
   12c34:	00110d00 	call	110d0 <vTaskEnterCritical>
   12c38:	e0bffe17 	ldw	r2,-8(fp)
   12c3c:	10800303 	ldbu	r2,12(r2)
   12c40:	10803fcc 	andi	r2,r2,255
   12c44:	1080201c 	xori	r2,r2,128
   12c48:	10bfe004 	addi	r2,r2,-128
   12c4c:	10bffdd0 	cmplti	r2,r2,-9
   12c50:	1000031e 	bne	r2,zero,12c60 <netconn_accept+0x198>
   12c54:	e0bffe17 	ldw	r2,-8(fp)
   12c58:	00fffd84 	movi	r3,-10
   12c5c:	10c00305 	stb	r3,12(r2)
   12c60:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   12c64:	10000126 	beq	r2,zero,12c6c <netconn_accept+0x1a4>
   12c68:	00111100 	call	11110 <vTaskExitCritical>
    return ERR_ABRT;
   12c6c:	00bffd84 	movi	r2,-10
   12c70:	00000c06 	br	12ca4 <netconn_accept+0x1dc>
  }
#if TCP_LISTEN_BACKLOG
  /* Let the stack know that we have accepted the connection. */
  msg.function = do_recv;
   12c74:	00800074 	movhi	r2,1
   12c78:	1094a104 	addi	r2,r2,21124
   12c7c:	e0bff815 	stw	r2,-32(fp)
  msg.msg.conn = conn;
   12c80:	e0bffe17 	ldw	r2,-8(fp)
   12c84:	e0bff915 	stw	r2,-28(fp)
  /* don't care for the return value of do_recv */
  TCPIP_APIMSG(&msg);
   12c88:	e0bff804 	addi	r2,fp,-32
   12c8c:	1009883a 	mov	r4,r2
   12c90:	00197440 	call	19744 <tcpip_apimsg>
#endif /* TCP_LISTEN_BACKLOG */

  *new_conn = newconn;
   12c94:	e0fff717 	ldw	r3,-36(fp)
   12c98:	e0bfff17 	ldw	r2,-4(fp)
   12c9c:	10c00015 	stw	r3,0(r2)
  /* don't set conn->last_err: it's only ERR_OK, anyway */
  return ERR_OK;
   12ca0:	0005883a 	mov	r2,zero
#else /* LWIP_TCP */
  LWIP_UNUSED_ARG(conn);
  LWIP_UNUSED_ARG(new_conn);
  return ERR_ARG;
#endif /* LWIP_TCP */
}
   12ca4:	e037883a 	mov	sp,fp
   12ca8:	dfc00117 	ldw	ra,4(sp)
   12cac:	df000017 	ldw	fp,0(sp)
   12cb0:	dec00204 	addi	sp,sp,8
   12cb4:	f800283a 	ret

00012cb8 <netconn_recv_data>:
 * @return ERR_OK if data has been received, an error code otherwise (timeout,
 *                memory error or another error)
 */
static err_t
netconn_recv_data(struct netconn *conn, void **new_buf)
{
   12cb8:	defff404 	addi	sp,sp,-48
   12cbc:	dfc00b15 	stw	ra,44(sp)
   12cc0:	df000a15 	stw	fp,40(sp)
   12cc4:	df000a04 	addi	fp,sp,40
   12cc8:	e13ffe15 	stw	r4,-8(fp)
   12ccc:	e17fff15 	stw	r5,-4(fp)
  void *buf = NULL;
   12cd0:	e03ff715 	stw	zero,-36(fp)
  err_t err;
#if LWIP_TCP
  struct api_msg msg;
#endif /* LWIP_TCP */

  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
   12cd4:	e0bfff17 	ldw	r2,-4(fp)
   12cd8:	1000091e 	bne	r2,zero,12d00 <netconn_recv_data+0x48>
   12cdc:	01000134 	movhi	r4,4
   12ce0:	21027904 	addi	r4,r4,2532
   12ce4:	01400134 	movhi	r5,4
   12ce8:	2942dc04 	addi	r5,r5,2928
   12cec:	018057c4 	movi	r6,351
   12cf0:	01c00134 	movhi	r7,4
   12cf4:	39c28d04 	addi	r7,r7,2612
   12cf8:	00044740 	call	4474 <printf>
   12cfc:	003fff06 	br	12cfc <netconn_recv_data+0x44>
  *new_buf = NULL;
   12d00:	e0bfff17 	ldw	r2,-4(fp)
   12d04:	10000015 	stw	zero,0(r2)
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
   12d08:	e0bffe17 	ldw	r2,-8(fp)
   12d0c:	1000091e 	bne	r2,zero,12d34 <netconn_recv_data+0x7c>
   12d10:	01000134 	movhi	r4,4
   12d14:	21027904 	addi	r4,r4,2532
   12d18:	01400134 	movhi	r5,4
   12d1c:	2942e404 	addi	r5,r5,2960
   12d20:	01805844 	movi	r6,353
   12d24:	01c00134 	movhi	r7,4
   12d28:	39c28d04 	addi	r7,r7,2612
   12d2c:	00044740 	call	4474 <printf>
   12d30:	003fff06 	br	12d30 <netconn_recv_data+0x78>
  LWIP_ERROR("netconn_accept: invalid recvmbox", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);
   12d34:	e0bffe17 	ldw	r2,-8(fp)
   12d38:	10800517 	ldw	r2,20(r2)
   12d3c:	1000091e 	bne	r2,zero,12d64 <netconn_recv_data+0xac>
   12d40:	01000134 	movhi	r4,4
   12d44:	21027904 	addi	r4,r4,2532
   12d48:	01400134 	movhi	r5,4
   12d4c:	2942eb04 	addi	r5,r5,2988
   12d50:	01805884 	movi	r6,354
   12d54:	01c00134 	movhi	r7,4
   12d58:	39c28d04 	addi	r7,r7,2612
   12d5c:	00044740 	call	4474 <printf>
   12d60:	003fff06 	br	12d60 <netconn_recv_data+0xa8>

  err = conn->last_err;
   12d64:	e0bffe17 	ldw	r2,-8(fp)
   12d68:	10800303 	ldbu	r2,12(r2)
   12d6c:	e0bff685 	stb	r2,-38(fp)
  if (ERR_IS_FATAL(err)) {
   12d70:	e0bff687 	ldb	r2,-38(fp)
   12d74:	10bffdc8 	cmpgei	r2,r2,-9
   12d78:	1000021e 	bne	r2,zero,12d84 <netconn_recv_data+0xcc>
    /* don't recv on fatal errors: this might block the application task
       waiting on recvmbox forever! */
    /* @todo: this does not allow us to fetch data that has been put into recvmbox
       before the fatal error occurred - is that a problem? */
    return err;
   12d7c:	e0bff683 	ldbu	r2,-38(fp)
   12d80:	00006b06 	br	12f30 <netconn_recv_data+0x278>
  }

#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(&conn->recvmbox, &buf, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
   12d84:	e0bffe17 	ldw	r2,-8(fp)
   12d88:	11000504 	addi	r4,r2,20
   12d8c:	e0bffe17 	ldw	r2,-8(fp)
   12d90:	10800817 	ldw	r2,32(r2)
   12d94:	e0fff704 	addi	r3,fp,-36
   12d98:	180b883a 	mov	r5,r3
   12d9c:	100d883a 	mov	r6,r2
   12da0:	001b7a80 	call	1b7a8 <sys_arch_mbox_fetch>
   12da4:	10bfffd8 	cmpnei	r2,r2,-1
   12da8:	1000121e 	bne	r2,zero,12df4 <netconn_recv_data+0x13c>
    NETCONN_SET_SAFE_ERR(conn, ERR_TIMEOUT);
   12dac:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   12db0:	10000126 	beq	r2,zero,12db8 <netconn_recv_data+0x100>
   12db4:	00110d00 	call	110d0 <vTaskEnterCritical>
   12db8:	e0bffe17 	ldw	r2,-8(fp)
   12dbc:	10800303 	ldbu	r2,12(r2)
   12dc0:	10803fcc 	andi	r2,r2,255
   12dc4:	1080201c 	xori	r2,r2,128
   12dc8:	10bfe004 	addi	r2,r2,-128
   12dcc:	10bffdd0 	cmplti	r2,r2,-9
   12dd0:	1000031e 	bne	r2,zero,12de0 <netconn_recv_data+0x128>
   12dd4:	e0bffe17 	ldw	r2,-8(fp)
   12dd8:	00ffff44 	movi	r3,-3
   12ddc:	10c00305 	stb	r3,12(r2)
   12de0:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   12de4:	10000126 	beq	r2,zero,12dec <netconn_recv_data+0x134>
   12de8:	00111100 	call	11110 <vTaskExitCritical>
    return ERR_TIMEOUT;
   12dec:	00bfff44 	movi	r2,-3
   12df0:	00004f06 	br	12f30 <netconn_recv_data+0x278>
  sys_arch_mbox_fetch(&conn->recvmbox, &buf, 0);
#endif /* LWIP_SO_RCVTIMEO*/

#if LWIP_TCP
#if (LWIP_UDP || LWIP_RAW)
  if (conn->type == NETCONN_TCP)
   12df4:	e0bffe17 	ldw	r2,-8(fp)
   12df8:	10800017 	ldw	r2,0(r2)
   12dfc:	10800418 	cmpnei	r2,r2,16
   12e00:	1000391e 	bne	r2,zero,12ee8 <netconn_recv_data+0x230>
#endif /* (LWIP_UDP || LWIP_RAW) */
  {
    if (!netconn_get_noautorecved(conn) || (buf == NULL)) {
   12e04:	e0bffe17 	ldw	r2,-8(fp)
   12e08:	10800903 	ldbu	r2,36(r2)
   12e0c:	10803fcc 	andi	r2,r2,255
   12e10:	1080020c 	andi	r2,r2,8
   12e14:	10000226 	beq	r2,zero,12e20 <netconn_recv_data+0x168>
   12e18:	e0bff717 	ldw	r2,-36(fp)
   12e1c:	1000111e 	bne	r2,zero,12e64 <netconn_recv_data+0x1ac>
      /* Let the stack know that we have taken the data. */
      /* TODO: Speedup: Don't block and wait for the answer here
         (to prevent multiple thread-switches). */
      msg.function = do_recv;
   12e20:	00800074 	movhi	r2,1
   12e24:	1094a104 	addi	r2,r2,21124
   12e28:	e0bff815 	stw	r2,-32(fp)
      msg.msg.conn = conn;
   12e2c:	e0bffe17 	ldw	r2,-8(fp)
   12e30:	e0bff915 	stw	r2,-28(fp)
      if (buf != NULL) {
   12e34:	e0bff717 	ldw	r2,-36(fp)
   12e38:	10000526 	beq	r2,zero,12e50 <netconn_recv_data+0x198>
        msg.msg.msg.r.len = ((struct pbuf *)buf)->tot_len;
   12e3c:	e0bff717 	ldw	r2,-36(fp)
   12e40:	1080020b 	ldhu	r2,8(r2)
   12e44:	10bfffcc 	andi	r2,r2,65535
   12e48:	e0bffb15 	stw	r2,-20(fp)
   12e4c:	00000206 	br	12e58 <netconn_recv_data+0x1a0>
      } else {
        msg.msg.msg.r.len = 1;
   12e50:	00800044 	movi	r2,1
   12e54:	e0bffb15 	stw	r2,-20(fp)
      }
      /* don't care for the return value of do_recv */
      TCPIP_APIMSG(&msg);
   12e58:	e0bff804 	addi	r2,fp,-32
   12e5c:	1009883a 	mov	r4,r2
   12e60:	00197440 	call	19744 <tcpip_apimsg>
    }

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (buf == NULL) {
   12e64:	e0bff717 	ldw	r2,-36(fp)
   12e68:	10001b1e 	bne	r2,zero,12ed8 <netconn_recv_data+0x220>
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
   12e6c:	e0bffe17 	ldw	r2,-8(fp)
   12e70:	10800c17 	ldw	r2,48(r2)
   12e74:	10000626 	beq	r2,zero,12e90 <netconn_recv_data+0x1d8>
   12e78:	e0bffe17 	ldw	r2,-8(fp)
   12e7c:	10800c17 	ldw	r2,48(r2)
   12e80:	e13ffe17 	ldw	r4,-8(fp)
   12e84:	01400044 	movi	r5,1
   12e88:	000d883a 	mov	r6,zero
   12e8c:	103ee83a 	callr	r2
      /* Avoid to lose any previous error code */
      NETCONN_SET_SAFE_ERR(conn, ERR_CLSD);
   12e90:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   12e94:	10000126 	beq	r2,zero,12e9c <netconn_recv_data+0x1e4>
   12e98:	00110d00 	call	110d0 <vTaskEnterCritical>
   12e9c:	e0bffe17 	ldw	r2,-8(fp)
   12ea0:	10800303 	ldbu	r2,12(r2)
   12ea4:	10803fcc 	andi	r2,r2,255
   12ea8:	1080201c 	xori	r2,r2,128
   12eac:	10bfe004 	addi	r2,r2,-128
   12eb0:	10bffdd0 	cmplti	r2,r2,-9
   12eb4:	1000031e 	bne	r2,zero,12ec4 <netconn_recv_data+0x20c>
   12eb8:	e0bffe17 	ldw	r2,-8(fp)
   12ebc:	00fffd04 	movi	r3,-12
   12ec0:	10c00305 	stb	r3,12(r2)
   12ec4:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   12ec8:	10000126 	beq	r2,zero,12ed0 <netconn_recv_data+0x218>
   12ecc:	00111100 	call	11110 <vTaskExitCritical>
      return ERR_CLSD;
   12ed0:	00bffd04 	movi	r2,-12
   12ed4:	00001606 	br	12f30 <netconn_recv_data+0x278>
    }
    len = ((struct pbuf *)buf)->tot_len;
   12ed8:	e0bff717 	ldw	r2,-36(fp)
   12edc:	1080020b 	ldhu	r2,8(r2)
   12ee0:	e0bff60d 	sth	r2,-40(fp)
   12ee4:	00000406 	br	12ef8 <netconn_recv_data+0x240>
  else
#endif /* LWIP_TCP && (LWIP_UDP || LWIP_RAW) */
#if (LWIP_UDP || LWIP_RAW)
  {
    LWIP_ASSERT("buf != NULL", buf != NULL);
    len = netbuf_len((struct netbuf *)buf);
   12ee8:	e0bff717 	ldw	r2,-36(fp)
   12eec:	10800017 	ldw	r2,0(r2)
   12ef0:	1080020b 	ldhu	r2,8(r2)
   12ef4:	e0bff60d 	sth	r2,-40(fp)

#if LWIP_SO_RCVBUF
  SYS_ARCH_DEC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
   12ef8:	e0bffe17 	ldw	r2,-8(fp)
   12efc:	10800c17 	ldw	r2,48(r2)
   12f00:	10000726 	beq	r2,zero,12f20 <netconn_recv_data+0x268>
   12f04:	e0bffe17 	ldw	r2,-8(fp)
   12f08:	10c00c17 	ldw	r3,48(r2)
   12f0c:	e0bff60b 	ldhu	r2,-40(fp)
   12f10:	e13ffe17 	ldw	r4,-8(fp)
   12f14:	01400044 	movi	r5,1
   12f18:	100d883a 	mov	r6,r2
   12f1c:	183ee83a 	callr	r3

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv_data: received %p, len=%"U16_F"\n", buf, len));

  *new_buf = buf;
   12f20:	e0fff717 	ldw	r3,-36(fp)
   12f24:	e0bfff17 	ldw	r2,-4(fp)
   12f28:	10c00015 	stw	r3,0(r2)
  /* don't set conn->last_err: it's only ERR_OK, anyway */
  return ERR_OK;
   12f2c:	0005883a 	mov	r2,zero
}
   12f30:	e037883a 	mov	sp,fp
   12f34:	dfc00117 	ldw	ra,4(sp)
   12f38:	df000017 	ldw	fp,0(sp)
   12f3c:	dec00204 	addi	sp,sp,8
   12f40:	f800283a 	ret

00012f44 <netconn_recv_tcp_pbuf>:
 *                memory error or another error)
 *         ERR_ARG if conn is not a TCP netconn
 */
err_t
netconn_recv_tcp_pbuf(struct netconn *conn, struct pbuf **new_buf)
{
   12f44:	defffc04 	addi	sp,sp,-16
   12f48:	dfc00315 	stw	ra,12(sp)
   12f4c:	df000215 	stw	fp,8(sp)
   12f50:	df000204 	addi	fp,sp,8
   12f54:	e13ffe15 	stw	r4,-8(fp)
   12f58:	e17fff15 	stw	r5,-4(fp)
  LWIP_ERROR("netconn_recv: invalid conn", (conn != NULL) &&
   12f5c:	e0bffe17 	ldw	r2,-8(fp)
   12f60:	10000426 	beq	r2,zero,12f74 <netconn_recv_tcp_pbuf+0x30>
   12f64:	e0bffe17 	ldw	r2,-8(fp)
   12f68:	10800017 	ldw	r2,0(r2)
   12f6c:	10800420 	cmpeqi	r2,r2,16
   12f70:	1000091e 	bne	r2,zero,12f98 <netconn_recv_tcp_pbuf+0x54>
   12f74:	01000134 	movhi	r4,4
   12f78:	21027904 	addi	r4,r4,2532
   12f7c:	01400134 	movhi	r5,4
   12f80:	2942e404 	addi	r5,r5,2960
   12f84:	01806e04 	movi	r6,440
   12f88:	01c00134 	movhi	r7,4
   12f8c:	39c28d04 	addi	r7,r7,2612
   12f90:	00044740 	call	4474 <printf>
   12f94:	003fff06 	br	12f94 <netconn_recv_tcp_pbuf+0x50>
             netconn_type(conn) == NETCONN_TCP, return ERR_ARG;);

  return netconn_recv_data(conn, (void **)new_buf);
   12f98:	e13ffe17 	ldw	r4,-8(fp)
   12f9c:	e17fff17 	ldw	r5,-4(fp)
   12fa0:	0012cb80 	call	12cb8 <netconn_recv_data>
}
   12fa4:	e037883a 	mov	sp,fp
   12fa8:	dfc00117 	ldw	ra,4(sp)
   12fac:	df000017 	ldw	fp,0(sp)
   12fb0:	dec00204 	addi	sp,sp,8
   12fb4:	f800283a 	ret

00012fb8 <netconn_recv>:
 * @return ERR_OK if data has been received, an error code otherwise (timeout,
 *                memory error or another error)
 */
err_t
netconn_recv(struct netconn *conn, struct netbuf **new_buf)
{
   12fb8:	defff904 	addi	sp,sp,-28
   12fbc:	dfc00615 	stw	ra,24(sp)
   12fc0:	df000515 	stw	fp,20(sp)
   12fc4:	df000504 	addi	fp,sp,20
   12fc8:	e13ffe15 	stw	r4,-8(fp)
   12fcc:	e17fff15 	stw	r5,-4(fp)
#if LWIP_TCP
  struct netbuf *buf = NULL;
   12fd0:	e03ffb15 	stw	zero,-20(fp)
  err_t err;
#endif /* LWIP_TCP */

  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
   12fd4:	e0bfff17 	ldw	r2,-4(fp)
   12fd8:	1000091e 	bne	r2,zero,13000 <netconn_recv+0x48>
   12fdc:	01000134 	movhi	r4,4
   12fe0:	21027904 	addi	r4,r4,2532
   12fe4:	01400134 	movhi	r5,4
   12fe8:	2942dc04 	addi	r5,r5,2928
   12fec:	01807344 	movi	r6,461
   12ff0:	01c00134 	movhi	r7,4
   12ff4:	39c28d04 	addi	r7,r7,2612
   12ff8:	00044740 	call	4474 <printf>
   12ffc:	003fff06 	br	12ffc <netconn_recv+0x44>
  *new_buf = NULL;
   13000:	e0bfff17 	ldw	r2,-4(fp)
   13004:	10000015 	stw	zero,0(r2)
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
   13008:	e0bffe17 	ldw	r2,-8(fp)
   1300c:	1000091e 	bne	r2,zero,13034 <netconn_recv+0x7c>
   13010:	01000134 	movhi	r4,4
   13014:	21027904 	addi	r4,r4,2532
   13018:	01400134 	movhi	r5,4
   1301c:	2942e404 	addi	r5,r5,2960
   13020:	018073c4 	movi	r6,463
   13024:	01c00134 	movhi	r7,4
   13028:	39c28d04 	addi	r7,r7,2612
   1302c:	00044740 	call	4474 <printf>
   13030:	003fff06 	br	13030 <netconn_recv+0x78>
  LWIP_ERROR("netconn_accept: invalid recvmbox", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);
   13034:	e0bffe17 	ldw	r2,-8(fp)
   13038:	10800517 	ldw	r2,20(r2)
   1303c:	1000091e 	bne	r2,zero,13064 <netconn_recv+0xac>
   13040:	01000134 	movhi	r4,4
   13044:	21027904 	addi	r4,r4,2532
   13048:	01400134 	movhi	r5,4
   1304c:	2942eb04 	addi	r5,r5,2988
   13050:	01807404 	movi	r6,464
   13054:	01c00134 	movhi	r7,4
   13058:	39c28d04 	addi	r7,r7,2612
   1305c:	00044740 	call	4474 <printf>
   13060:	003fff06 	br	13060 <netconn_recv+0xa8>

#if LWIP_TCP
#if (LWIP_UDP || LWIP_RAW)
  if (conn->type == NETCONN_TCP)
   13064:	e0bffe17 	ldw	r2,-8(fp)
   13068:	10800017 	ldw	r2,0(r2)
   1306c:	10800418 	cmpnei	r2,r2,16
   13070:	1000331e 	bne	r2,zero,13140 <netconn_recv+0x188>
#endif /* (LWIP_UDP || LWIP_RAW) */
  {
    struct pbuf *p = NULL;
   13074:	e03ffd15 	stw	zero,-12(fp)
    /* This is not a listening netconn, since recvmbox is set */

    buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
   13078:	010001c4 	movi	r4,7
   1307c:	00223cc0 	call	223cc <memp_malloc>
   13080:	e0bffb15 	stw	r2,-20(fp)
    if (buf == NULL) {
   13084:	e0bffb17 	ldw	r2,-20(fp)
   13088:	1000121e 	bne	r2,zero,130d4 <netconn_recv+0x11c>
      NETCONN_SET_SAFE_ERR(conn, ERR_MEM);
   1308c:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   13090:	10000126 	beq	r2,zero,13098 <netconn_recv+0xe0>
   13094:	00110d00 	call	110d0 <vTaskEnterCritical>
   13098:	e0bffe17 	ldw	r2,-8(fp)
   1309c:	10800303 	ldbu	r2,12(r2)
   130a0:	10803fcc 	andi	r2,r2,255
   130a4:	1080201c 	xori	r2,r2,128
   130a8:	10bfe004 	addi	r2,r2,-128
   130ac:	10bffdd0 	cmplti	r2,r2,-9
   130b0:	1000031e 	bne	r2,zero,130c0 <netconn_recv+0x108>
   130b4:	e0bffe17 	ldw	r2,-8(fp)
   130b8:	00ffffc4 	movi	r3,-1
   130bc:	10c00305 	stb	r3,12(r2)
   130c0:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   130c4:	10000126 	beq	r2,zero,130cc <netconn_recv+0x114>
   130c8:	00111100 	call	11110 <vTaskExitCritical>
      return ERR_MEM;
   130cc:	00bfffc4 	movi	r2,-1
   130d0:	00001e06 	br	1314c <netconn_recv+0x194>
    }

    err = netconn_recv_data(conn, (void **)&p);
   130d4:	e0bffd04 	addi	r2,fp,-12
   130d8:	e13ffe17 	ldw	r4,-8(fp)
   130dc:	100b883a 	mov	r5,r2
   130e0:	0012cb80 	call	12cb8 <netconn_recv_data>
   130e4:	e0bffc05 	stb	r2,-16(fp)
    if (err != ERR_OK) {
   130e8:	e0bffc07 	ldb	r2,-16(fp)
   130ec:	10000526 	beq	r2,zero,13104 <netconn_recv+0x14c>
      memp_free(MEMP_NETBUF, buf);
   130f0:	010001c4 	movi	r4,7
   130f4:	e17ffb17 	ldw	r5,-20(fp)
   130f8:	00225900 	call	22590 <memp_free>
      return err;
   130fc:	e0bffc03 	ldbu	r2,-16(fp)
   13100:	00001206 	br	1314c <netconn_recv+0x194>
    }
    LWIP_ASSERT("p != NULL", p != NULL);

    buf->p = p;
   13104:	e0fffd17 	ldw	r3,-12(fp)
   13108:	e0bffb17 	ldw	r2,-20(fp)
   1310c:	10c00015 	stw	r3,0(r2)
    buf->ptr = p;
   13110:	e0fffd17 	ldw	r3,-12(fp)
   13114:	e0bffb17 	ldw	r2,-20(fp)
   13118:	10c00115 	stw	r3,4(r2)
    buf->port = 0;
   1311c:	e0bffb17 	ldw	r2,-20(fp)
   13120:	1000030d 	sth	zero,12(r2)
    ip_addr_set_any(&buf->addr);
   13124:	e0bffb17 	ldw	r2,-20(fp)
   13128:	10000215 	stw	zero,8(r2)
    *new_buf = buf;
   1312c:	e0bfff17 	ldw	r2,-4(fp)
   13130:	e0fffb17 	ldw	r3,-20(fp)
   13134:	10c00015 	stw	r3,0(r2)
    /* don't set conn->last_err: it's only ERR_OK, anyway */
    return ERR_OK;
   13138:	0005883a 	mov	r2,zero
   1313c:	00000306 	br	1314c <netconn_recv+0x194>
#if LWIP_TCP && (LWIP_UDP || LWIP_RAW)
  else
#endif /* LWIP_TCP && (LWIP_UDP || LWIP_RAW) */
  {
#if (LWIP_UDP || LWIP_RAW)
    return netconn_recv_data(conn, (void **)new_buf);
   13140:	e13ffe17 	ldw	r4,-8(fp)
   13144:	e17fff17 	ldw	r5,-4(fp)
   13148:	0012cb80 	call	12cb8 <netconn_recv_data>
#endif /* (LWIP_UDP || LWIP_RAW) */
  }
}
   1314c:	e037883a 	mov	sp,fp
   13150:	dfc00117 	ldw	ra,4(sp)
   13154:	df000017 	ldw	fp,0(sp)
   13158:	dec00204 	addi	sp,sp,8
   1315c:	f800283a 	ret

00013160 <netconn_recved>:
 * @param conn the netconn for which to update the receive window
 * @param length amount of data processed (ATTENTION: this must be accurate!)
 */
void
netconn_recved(struct netconn *conn, u32_t length)
{
   13160:	defff604 	addi	sp,sp,-40
   13164:	dfc00915 	stw	ra,36(sp)
   13168:	df000815 	stw	fp,32(sp)
   1316c:	df000804 	addi	fp,sp,32
   13170:	e13ffe15 	stw	r4,-8(fp)
   13174:	e17fff15 	stw	r5,-4(fp)
#if LWIP_TCP
  if ((conn != NULL) && (conn->type == NETCONN_TCP) &&
   13178:	e0bffe17 	ldw	r2,-8(fp)
   1317c:	10001226 	beq	r2,zero,131c8 <netconn_recved+0x68>
   13180:	e0bffe17 	ldw	r2,-8(fp)
   13184:	10800017 	ldw	r2,0(r2)
   13188:	10800418 	cmpnei	r2,r2,16
   1318c:	10000e1e 	bne	r2,zero,131c8 <netconn_recved+0x68>
      (netconn_get_noautorecved(conn))) {
   13190:	e0bffe17 	ldw	r2,-8(fp)
   13194:	10800903 	ldbu	r2,36(r2)
   13198:	10803fcc 	andi	r2,r2,255
   1319c:	1080020c 	andi	r2,r2,8
 */
void
netconn_recved(struct netconn *conn, u32_t length)
{
#if LWIP_TCP
  if ((conn != NULL) && (conn->type == NETCONN_TCP) &&
   131a0:	10000926 	beq	r2,zero,131c8 <netconn_recved+0x68>
      (netconn_get_noautorecved(conn))) {
    struct api_msg msg;
    /* Let the stack know that we have taken the data. */
    /* TODO: Speedup: Don't block and wait for the answer here
       (to prevent multiple thread-switches). */
    msg.function = do_recv;
   131a4:	00800074 	movhi	r2,1
   131a8:	1094a104 	addi	r2,r2,21124
   131ac:	e0bff815 	stw	r2,-32(fp)
    msg.msg.conn = conn;
   131b0:	e0bffe17 	ldw	r2,-8(fp)
   131b4:	e0bff915 	stw	r2,-28(fp)
    msg.msg.msg.r.len = length;
   131b8:	e0bfff17 	ldw	r2,-4(fp)
   131bc:	e0bffb15 	stw	r2,-20(fp)
    /* don't care for the return value of do_recv */
    TCPIP_APIMSG(&msg);
   131c0:	e13ff804 	addi	r4,fp,-32
   131c4:	00197440 	call	19744 <tcpip_apimsg>
  }
#else /* LWIP_TCP */
  LWIP_UNUSED_ARG(conn);
  LWIP_UNUSED_ARG(length);
#endif /* LWIP_TCP */
}
   131c8:	e037883a 	mov	sp,fp
   131cc:	dfc00117 	ldw	ra,4(sp)
   131d0:	df000017 	ldw	fp,0(sp)
   131d4:	dec00204 	addi	sp,sp,8
   131d8:	f800283a 	ret

000131dc <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, ip_addr_t *addr, u16_t port)
{
   131dc:	defffa04 	addi	sp,sp,-24
   131e0:	dfc00515 	stw	ra,20(sp)
   131e4:	df000415 	stw	fp,16(sp)
   131e8:	df000404 	addi	fp,sp,16
   131ec:	e13ffc15 	stw	r4,-16(fp)
   131f0:	e17ffd15 	stw	r5,-12(fp)
   131f4:	e1bffe15 	stw	r6,-8(fp)
   131f8:	3805883a 	mov	r2,r7
   131fc:	e0bfff0d 	sth	r2,-4(fp)
  if (buf != NULL) {
   13200:	e0bffd17 	ldw	r2,-12(fp)
   13204:	10000f26 	beq	r2,zero,13244 <netconn_sendto+0x68>
    ip_addr_set(&buf->addr, addr);
   13208:	e0bffe17 	ldw	r2,-8(fp)
   1320c:	10000326 	beq	r2,zero,1321c <netconn_sendto+0x40>
   13210:	e0bffe17 	ldw	r2,-8(fp)
   13214:	10800017 	ldw	r2,0(r2)
   13218:	00000106 	br	13220 <netconn_sendto+0x44>
   1321c:	0005883a 	mov	r2,zero
   13220:	e0fffd17 	ldw	r3,-12(fp)
   13224:	18800215 	stw	r2,8(r3)
    buf->port = port;
   13228:	e0bffd17 	ldw	r2,-12(fp)
   1322c:	e0ffff0b 	ldhu	r3,-4(fp)
   13230:	10c0030d 	sth	r3,12(r2)
    return netconn_send(conn, buf);
   13234:	e13ffc17 	ldw	r4,-16(fp)
   13238:	e17ffd17 	ldw	r5,-12(fp)
   1323c:	001325c0 	call	1325c <netconn_send>
   13240:	00000106 	br	13248 <netconn_sendto+0x6c>
  }
  return ERR_VAL;
   13244:	00bffe84 	movi	r2,-6
}
   13248:	e037883a 	mov	sp,fp
   1324c:	dfc00117 	ldw	ra,4(sp)
   13250:	df000017 	ldw	fp,0(sp)
   13254:	dec00204 	addi	sp,sp,8
   13258:	f800283a 	ret

0001325c <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
   1325c:	defff504 	addi	sp,sp,-44
   13260:	dfc00a15 	stw	ra,40(sp)
   13264:	df000915 	stw	fp,36(sp)
   13268:	df000904 	addi	fp,sp,36
   1326c:	e13ffe15 	stw	r4,-8(fp)
   13270:	e17fff15 	stw	r5,-4(fp)
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
   13274:	e0bffe17 	ldw	r2,-8(fp)
   13278:	1000091e 	bne	r2,zero,132a0 <netconn_send+0x44>
   1327c:	01000134 	movhi	r4,4
   13280:	21027904 	addi	r4,r4,2532
   13284:	01400134 	movhi	r5,4
   13288:	2942f404 	addi	r5,r5,3024
   1328c:	01808f04 	movi	r6,572
   13290:	01c00134 	movhi	r7,4
   13294:	39c28d04 	addi	r7,r7,2612
   13298:	00044740 	call	4474 <printf>
   1329c:	003fff06 	br	1329c <netconn_send+0x40>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %"U16_F" bytes\n", buf->p->tot_len));
  msg.function = do_send;
   132a0:	00800074 	movhi	r2,1
   132a4:	10941604 	addi	r2,r2,20568
   132a8:	e0bff815 	stw	r2,-32(fp)
  msg.msg.conn = conn;
   132ac:	e0bffe17 	ldw	r2,-8(fp)
   132b0:	e0bff915 	stw	r2,-28(fp)
  msg.msg.msg.b = buf;
   132b4:	e0bfff17 	ldw	r2,-4(fp)
   132b8:	e0bffb15 	stw	r2,-20(fp)
  err = TCPIP_APIMSG(&msg);
   132bc:	e0bff804 	addi	r2,fp,-32
   132c0:	1009883a 	mov	r4,r2
   132c4:	00197440 	call	19744 <tcpip_apimsg>
   132c8:	e0bff705 	stb	r2,-36(fp)

  NETCONN_SET_SAFE_ERR(conn, err);
   132cc:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   132d0:	10000126 	beq	r2,zero,132d8 <netconn_send+0x7c>
   132d4:	00110d00 	call	110d0 <vTaskEnterCritical>
   132d8:	e0bffe17 	ldw	r2,-8(fp)
   132dc:	10800303 	ldbu	r2,12(r2)
   132e0:	10803fcc 	andi	r2,r2,255
   132e4:	1080201c 	xori	r2,r2,128
   132e8:	10bfe004 	addi	r2,r2,-128
   132ec:	10bffdd0 	cmplti	r2,r2,-9
   132f0:	1000031e 	bne	r2,zero,13300 <netconn_send+0xa4>
   132f4:	e0bffe17 	ldw	r2,-8(fp)
   132f8:	e0fff703 	ldbu	r3,-36(fp)
   132fc:	10c00305 	stb	r3,12(r2)
   13300:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   13304:	10000126 	beq	r2,zero,1330c <netconn_send+0xb0>
   13308:	00111100 	call	11110 <vTaskExitCritical>
  return err;
   1330c:	e0bff703 	ldbu	r2,-36(fp)
}
   13310:	e037883a 	mov	sp,fp
   13314:	dfc00117 	ldw	ra,4(sp)
   13318:	df000017 	ldw	fp,0(sp)
   1331c:	dec00204 	addi	sp,sp,8
   13320:	f800283a 	ret

00013324 <netconn_write_partly>:
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write_partly(struct netconn *conn, const void *dataptr, size_t size,
                     u8_t apiflags, size_t *bytes_written)
{
   13324:	defff304 	addi	sp,sp,-52
   13328:	dfc00c15 	stw	ra,48(sp)
   1332c:	df000b15 	stw	fp,44(sp)
   13330:	df000b04 	addi	fp,sp,44
   13334:	e13ffc15 	stw	r4,-16(fp)
   13338:	e17ffd15 	stw	r5,-12(fp)
   1333c:	e1bffe15 	stw	r6,-8(fp)
   13340:	3805883a 	mov	r2,r7
   13344:	e0bfff05 	stb	r2,-4(fp)
  struct api_msg msg;
  err_t err;
  u8_t dontblock;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
   13348:	e0bffc17 	ldw	r2,-16(fp)
   1334c:	1000091e 	bne	r2,zero,13374 <netconn_write_partly+0x50>
   13350:	01000134 	movhi	r4,4
   13354:	21027904 	addi	r4,r4,2532
   13358:	01400134 	movhi	r5,4
   1335c:	2942fb04 	addi	r5,r5,3052
   13360:	01809744 	movi	r6,605
   13364:	01c00134 	movhi	r7,4
   13368:	39c28d04 	addi	r7,r7,2612
   1336c:	00044740 	call	4474 <printf>
   13370:	003fff06 	br	13370 <netconn_write_partly+0x4c>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
   13374:	e0bffc17 	ldw	r2,-16(fp)
   13378:	10800017 	ldw	r2,0(r2)
   1337c:	10800420 	cmpeqi	r2,r2,16
   13380:	1000091e 	bne	r2,zero,133a8 <netconn_write_partly+0x84>
   13384:	01000134 	movhi	r4,4
   13388:	21027904 	addi	r4,r4,2532
   1338c:	01400134 	movhi	r5,4
   13390:	29430204 	addi	r5,r5,3080
   13394:	01809784 	movi	r6,606
   13398:	01c00134 	movhi	r7,4
   1339c:	39c28d04 	addi	r7,r7,2612
   133a0:	00044740 	call	4474 <printf>
   133a4:	003fff06 	br	133a4 <netconn_write_partly+0x80>
  if (size == 0) {
   133a8:	e0bffe17 	ldw	r2,-8(fp)
   133ac:	1000021e 	bne	r2,zero,133b8 <netconn_write_partly+0x94>
    return ERR_OK;
   133b0:	0005883a 	mov	r2,zero
   133b4:	00003f06 	br	134b4 <netconn_write_partly+0x190>
  }
  dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
   133b8:	e0bffc17 	ldw	r2,-16(fp)
   133bc:	10800903 	ldbu	r2,36(r2)
   133c0:	10803fcc 	andi	r2,r2,255
   133c4:	1080008c 	andi	r2,r2,2
   133c8:	1000031e 	bne	r2,zero,133d8 <netconn_write_partly+0xb4>
   133cc:	e0bfff03 	ldbu	r2,-4(fp)
   133d0:	1080010c 	andi	r2,r2,4
   133d4:	10000226 	beq	r2,zero,133e0 <netconn_write_partly+0xbc>
   133d8:	00800044 	movi	r2,1
   133dc:	00000106 	br	133e4 <netconn_write_partly+0xc0>
   133e0:	0005883a 	mov	r2,zero
   133e4:	e0bff505 	stb	r2,-44(fp)
  if (dontblock && !bytes_written) {
   133e8:	e0bff503 	ldbu	r2,-44(fp)
   133ec:	10000426 	beq	r2,zero,13400 <netconn_write_partly+0xdc>
   133f0:	e0800217 	ldw	r2,8(fp)
   133f4:	1000021e 	bne	r2,zero,13400 <netconn_write_partly+0xdc>
    /* This implies netconn_write() cannot be used for non-blocking send, since
       it has no way to return the number of bytes written. */
    return ERR_VAL;
   133f8:	00bffe84 	movi	r2,-6
   133fc:	00002d06 	br	134b4 <netconn_write_partly+0x190>
  }

  /* non-blocking write sends as much  */
  msg.function = do_write;
   13400:	00800074 	movhi	r2,1
   13404:	1095a104 	addi	r2,r2,22148
   13408:	e0bff615 	stw	r2,-40(fp)
  msg.msg.conn = conn;
   1340c:	e0bffc17 	ldw	r2,-16(fp)
   13410:	e0bff715 	stw	r2,-36(fp)
  msg.msg.msg.w.dataptr = dataptr;
   13414:	e0bffd17 	ldw	r2,-12(fp)
   13418:	e0bff915 	stw	r2,-28(fp)
  msg.msg.msg.w.apiflags = apiflags;
   1341c:	e0bfff03 	ldbu	r2,-4(fp)
   13420:	e0bffb05 	stb	r2,-20(fp)
  msg.msg.msg.w.len = size;
   13424:	e0bffe17 	ldw	r2,-8(fp)
   13428:	e0bffa15 	stw	r2,-24(fp)
#endif /* LWIP_SO_SNDTIMEO */

  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  err = TCPIP_APIMSG(&msg);
   1342c:	e0bff604 	addi	r2,fp,-40
   13430:	1009883a 	mov	r4,r2
   13434:	00197440 	call	19744 <tcpip_apimsg>
   13438:	e0bff545 	stb	r2,-43(fp)
  if ((err == ERR_OK) && (bytes_written != NULL)) {
   1343c:	e0bff547 	ldb	r2,-43(fp)
   13440:	10000b1e 	bne	r2,zero,13470 <netconn_write_partly+0x14c>
   13444:	e0800217 	ldw	r2,8(fp)
   13448:	10000926 	beq	r2,zero,13470 <netconn_write_partly+0x14c>
    if (dontblock
   1344c:	e0bff503 	ldbu	r2,-44(fp)
   13450:	10000426 	beq	r2,zero,13464 <netconn_write_partly+0x140>
#if LWIP_SO_SNDTIMEO
        || (conn->send_timeout != 0)
#endif /* LWIP_SO_SNDTIMEO */
       ) {
      /* nonblocking write: maybe the data has been sent partly */
      *bytes_written = msg.msg.msg.w.len;
   13454:	e0fffa17 	ldw	r3,-24(fp)
   13458:	e0800217 	ldw	r2,8(fp)
   1345c:	10c00015 	stw	r3,0(r2)
   13460:	00000306 	br	13470 <netconn_write_partly+0x14c>
    } else {
      /* blocking call succeeded: all data has been sent if it */
      *bytes_written = size;
   13464:	e0800217 	ldw	r2,8(fp)
   13468:	e0fffe17 	ldw	r3,-8(fp)
   1346c:	10c00015 	stw	r3,0(r2)
    }
  }

  NETCONN_SET_SAFE_ERR(conn, err);
   13470:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   13474:	10000126 	beq	r2,zero,1347c <netconn_write_partly+0x158>
   13478:	00110d00 	call	110d0 <vTaskEnterCritical>
   1347c:	e0bffc17 	ldw	r2,-16(fp)
   13480:	10800303 	ldbu	r2,12(r2)
   13484:	10803fcc 	andi	r2,r2,255
   13488:	1080201c 	xori	r2,r2,128
   1348c:	10bfe004 	addi	r2,r2,-128
   13490:	10bffdd0 	cmplti	r2,r2,-9
   13494:	1000031e 	bne	r2,zero,134a4 <netconn_write_partly+0x180>
   13498:	e0bffc17 	ldw	r2,-16(fp)
   1349c:	e0fff543 	ldbu	r3,-43(fp)
   134a0:	10c00305 	stb	r3,12(r2)
   134a4:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   134a8:	10000126 	beq	r2,zero,134b0 <netconn_write_partly+0x18c>
   134ac:	00111100 	call	11110 <vTaskExitCritical>
  return err;
   134b0:	e0bff543 	ldbu	r2,-43(fp)
}
   134b4:	e037883a 	mov	sp,fp
   134b8:	dfc00117 	ldw	ra,4(sp)
   134bc:	df000017 	ldw	fp,0(sp)
   134c0:	dec00204 	addi	sp,sp,8
   134c4:	f800283a 	ret

000134c8 <netconn_close_shutdown>:
 * @param how fully close or only shutdown one side?
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
static err_t
netconn_close_shutdown(struct netconn *conn, u8_t how)
{
   134c8:	defff504 	addi	sp,sp,-44
   134cc:	dfc00a15 	stw	ra,40(sp)
   134d0:	df000915 	stw	fp,36(sp)
   134d4:	df000904 	addi	fp,sp,36
   134d8:	e13ffe15 	stw	r4,-8(fp)
   134dc:	2805883a 	mov	r2,r5
   134e0:	e0bfff05 	stb	r2,-4(fp)
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
   134e4:	e0bffe17 	ldw	r2,-8(fp)
   134e8:	1000091e 	bne	r2,zero,13510 <netconn_close_shutdown+0x48>
   134ec:	01000134 	movhi	r4,4
   134f0:	21027904 	addi	r4,r4,2532
   134f4:	01400134 	movhi	r5,4
   134f8:	29430b04 	addi	r5,r5,3116
   134fc:	0180a704 	movi	r6,668
   13500:	01c00134 	movhi	r7,4
   13504:	39c28d04 	addi	r7,r7,2612
   13508:	00044740 	call	4474 <printf>
   1350c:	003fff06 	br	1350c <netconn_close_shutdown+0x44>

  msg.function = do_close;
   13510:	00800074 	movhi	r2,1
   13514:	10965d04 	addi	r2,r2,22900
   13518:	e0bff815 	stw	r2,-32(fp)
  msg.msg.conn = conn;
   1351c:	e0bffe17 	ldw	r2,-8(fp)
   13520:	e0bff915 	stw	r2,-28(fp)
  /* shutting down both ends is the same as closing */
  msg.msg.msg.sd.shut = how;
   13524:	e0bfff03 	ldbu	r2,-4(fp)
   13528:	e0bffb05 	stb	r2,-20(fp)
  /* because of the LWIP_TCPIP_CORE_LOCKING implementation of do_close,
     don't use TCPIP_APIMSG here */
  err = tcpip_apimsg(&msg);
   1352c:	e0bff804 	addi	r2,fp,-32
   13530:	1009883a 	mov	r4,r2
   13534:	00197440 	call	19744 <tcpip_apimsg>
   13538:	e0bff705 	stb	r2,-36(fp)

  NETCONN_SET_SAFE_ERR(conn, err);
   1353c:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   13540:	10000126 	beq	r2,zero,13548 <netconn_close_shutdown+0x80>
   13544:	00110d00 	call	110d0 <vTaskEnterCritical>
   13548:	e0bffe17 	ldw	r2,-8(fp)
   1354c:	10800303 	ldbu	r2,12(r2)
   13550:	10803fcc 	andi	r2,r2,255
   13554:	1080201c 	xori	r2,r2,128
   13558:	10bfe004 	addi	r2,r2,-128
   1355c:	10bffdd0 	cmplti	r2,r2,-9
   13560:	1000031e 	bne	r2,zero,13570 <netconn_close_shutdown+0xa8>
   13564:	e0bffe17 	ldw	r2,-8(fp)
   13568:	e0fff703 	ldbu	r3,-36(fp)
   1356c:	10c00305 	stb	r3,12(r2)
   13570:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   13574:	10000126 	beq	r2,zero,1357c <netconn_close_shutdown+0xb4>
   13578:	00111100 	call	11110 <vTaskExitCritical>
  return err;
   1357c:	e0bff703 	ldbu	r2,-36(fp)
}
   13580:	e037883a 	mov	sp,fp
   13584:	dfc00117 	ldw	ra,4(sp)
   13588:	df000017 	ldw	fp,0(sp)
   1358c:	dec00204 	addi	sp,sp,8
   13590:	f800283a 	ret

00013594 <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
   13594:	defffd04 	addi	sp,sp,-12
   13598:	dfc00215 	stw	ra,8(sp)
   1359c:	df000115 	stw	fp,4(sp)
   135a0:	df000104 	addi	fp,sp,4
   135a4:	e13fff15 	stw	r4,-4(fp)
  /* shutting down both ends is the same as closing */
  return netconn_close_shutdown(conn, NETCONN_SHUT_RDWR);
   135a8:	e13fff17 	ldw	r4,-4(fp)
   135ac:	014000c4 	movi	r5,3
   135b0:	00134c80 	call	134c8 <netconn_close_shutdown>
}
   135b4:	e037883a 	mov	sp,fp
   135b8:	dfc00117 	ldw	ra,4(sp)
   135bc:	df000017 	ldw	fp,0(sp)
   135c0:	dec00204 	addi	sp,sp,8
   135c4:	f800283a 	ret

000135c8 <netconn_shutdown>:
 * @param conn the TCP netconn to shut down
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_shutdown(struct netconn *conn, u8_t shut_rx, u8_t shut_tx)
{
   135c8:	defffb04 	addi	sp,sp,-20
   135cc:	dfc00415 	stw	ra,16(sp)
   135d0:	df000315 	stw	fp,12(sp)
   135d4:	df000304 	addi	fp,sp,12
   135d8:	e13ffd15 	stw	r4,-12(fp)
   135dc:	2807883a 	mov	r3,r5
   135e0:	3005883a 	mov	r2,r6
   135e4:	e0fffe05 	stb	r3,-8(fp)
   135e8:	e0bfff05 	stb	r2,-4(fp)
  return netconn_close_shutdown(conn, (shut_rx ? NETCONN_SHUT_RD : 0) | (shut_tx ? NETCONN_SHUT_WR : 0));
   135ec:	e0bffe03 	ldbu	r2,-8(fp)
   135f0:	1004c03a 	cmpne	r2,r2,zero
   135f4:	1007883a 	mov	r3,r2
   135f8:	e0bfff03 	ldbu	r2,-4(fp)
   135fc:	10000226 	beq	r2,zero,13608 <netconn_shutdown+0x40>
   13600:	00800084 	movi	r2,2
   13604:	00000106 	br	1360c <netconn_shutdown+0x44>
   13608:	0005883a 	mov	r2,zero
   1360c:	1884b03a 	or	r2,r3,r2
   13610:	10803fcc 	andi	r2,r2,255
   13614:	e13ffd17 	ldw	r4,-12(fp)
   13618:	100b883a 	mov	r5,r2
   1361c:	00134c80 	call	134c8 <netconn_close_shutdown>
}
   13620:	e037883a 	mov	sp,fp
   13624:	dfc00117 	ldw	ra,4(sp)
   13628:	df000017 	ldw	fp,0(sp)
   1362c:	dec00204 	addi	sp,sp,8
   13630:	f800283a 	ret

00013634 <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    ip_addr_t *addr)
{
   13634:	defff604 	addi	sp,sp,-40
   13638:	dfc00915 	stw	ra,36(sp)
   1363c:	df000815 	stw	fp,32(sp)
   13640:	df000804 	addi	fp,sp,32
   13644:	e13ffc15 	stw	r4,-16(fp)
   13648:	e17ffd15 	stw	r5,-12(fp)
   1364c:	e1bffe15 	stw	r6,-8(fp)
   13650:	e1ffff15 	stw	r7,-4(fp)
  struct pbuf *q;
  struct netbuf *buf;
  struct netconn *conn;

  LWIP_UNUSED_ARG(addr);
  conn = (struct netconn *)arg;
   13654:	e0bffc17 	ldw	r2,-16(fp)
   13658:	e0bff915 	stw	r2,-28(fp)

  if ((conn != NULL) && sys_mbox_valid(&conn->recvmbox)) {
   1365c:	e0bff917 	ldw	r2,-28(fp)
   13660:	10004c26 	beq	r2,zero,13794 <recv_raw+0x160>
   13664:	e0bff917 	ldw	r2,-28(fp)
   13668:	10800517 	ldw	r2,20(r2)
   1366c:	10004926 	beq	r2,zero,13794 <recv_raw+0x160>
    if ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize) {
      return 0;
    }
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
   13670:	e0bffe17 	ldw	r2,-8(fp)
   13674:	1080020b 	ldhu	r2,8(r2)
   13678:	10bfffcc 	andi	r2,r2,65535
   1367c:	010000c4 	movi	r4,3
   13680:	100b883a 	mov	r5,r2
   13684:	000d883a 	mov	r6,zero
   13688:	0022fa00 	call	22fa0 <pbuf_alloc>
   1368c:	e0bff815 	stw	r2,-32(fp)
    if(q != NULL) {
   13690:	e0bff817 	ldw	r2,-32(fp)
   13694:	10000a26 	beq	r2,zero,136c0 <recv_raw+0x8c>
      if (pbuf_copy(q, p) != ERR_OK) {
   13698:	e13ff817 	ldw	r4,-32(fp)
   1369c:	e17ffe17 	ldw	r5,-8(fp)
   136a0:	0023afc0 	call	23afc <pbuf_copy>
   136a4:	10803fcc 	andi	r2,r2,255
   136a8:	1080201c 	xori	r2,r2,128
   136ac:	10bfe004 	addi	r2,r2,-128
   136b0:	10000326 	beq	r2,zero,136c0 <recv_raw+0x8c>
        pbuf_free(q);
   136b4:	e13ff817 	ldw	r4,-32(fp)
   136b8:	00237600 	call	23760 <pbuf_free>
        q = NULL;
   136bc:	e03ff815 	stw	zero,-32(fp)
      }
    }

    if (q != NULL) {
   136c0:	e0bff817 	ldw	r2,-32(fp)
   136c4:	10003326 	beq	r2,zero,13794 <recv_raw+0x160>
      u16_t len;
      buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
   136c8:	010001c4 	movi	r4,7
   136cc:	00223cc0 	call	223cc <memp_malloc>
   136d0:	e0bffa15 	stw	r2,-24(fp)
      if (buf == NULL) {
   136d4:	e0bffa17 	ldw	r2,-24(fp)
   136d8:	1000041e 	bne	r2,zero,136ec <recv_raw+0xb8>
        pbuf_free(q);
   136dc:	e13ff817 	ldw	r4,-32(fp)
   136e0:	00237600 	call	23760 <pbuf_free>
        return 0;
   136e4:	0005883a 	mov	r2,zero
   136e8:	00002b06 	br	13798 <recv_raw+0x164>
      }

      buf->p = q;
   136ec:	e0bffa17 	ldw	r2,-24(fp)
   136f0:	e0fff817 	ldw	r3,-32(fp)
   136f4:	10c00015 	stw	r3,0(r2)
      buf->ptr = q;
   136f8:	e0bffa17 	ldw	r2,-24(fp)
   136fc:	e0fff817 	ldw	r3,-32(fp)
   13700:	10c00115 	stw	r3,4(r2)
      ip_addr_copy(buf->addr, *ip_current_src_addr());
   13704:	00800134 	movhi	r2,4
   13708:	109ee204 	addi	r2,r2,31624
   1370c:	10c00017 	ldw	r3,0(r2)
   13710:	e0bffa17 	ldw	r2,-24(fp)
   13714:	10c00215 	stw	r3,8(r2)
      buf->port = pcb->protocol;
   13718:	e0bffd17 	ldw	r2,-12(fp)
   1371c:	10800403 	ldbu	r2,16(r2)
   13720:	10c03fcc 	andi	r3,r2,255
   13724:	e0bffa17 	ldw	r2,-24(fp)
   13728:	10c0030d 	sth	r3,12(r2)

      len = q->tot_len;
   1372c:	e0bff817 	ldw	r2,-32(fp)
   13730:	1080020b 	ldhu	r2,8(r2)
   13734:	e0bffb0d 	sth	r2,-20(fp)
      if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
   13738:	e0bff917 	ldw	r2,-28(fp)
   1373c:	10800504 	addi	r2,r2,20
   13740:	1009883a 	mov	r4,r2
   13744:	e17ffa17 	ldw	r5,-24(fp)
   13748:	001b7480 	call	1b748 <sys_mbox_trypost>
   1374c:	10803fcc 	andi	r2,r2,255
   13750:	1080201c 	xori	r2,r2,128
   13754:	10bfe004 	addi	r2,r2,-128
   13758:	10000426 	beq	r2,zero,1376c <recv_raw+0x138>
        netbuf_delete(buf);
   1375c:	e13ffa17 	ldw	r4,-24(fp)
   13760:	0015b180 	call	15b18 <netbuf_delete>
        return 0;
   13764:	0005883a 	mov	r2,zero
   13768:	00000b06 	br	13798 <recv_raw+0x164>
      } else {
#if LWIP_SO_RCVBUF
        SYS_ARCH_INC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
        /* Register event with callback */
        API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
   1376c:	e0bff917 	ldw	r2,-28(fp)
   13770:	10800c17 	ldw	r2,48(r2)
   13774:	10000726 	beq	r2,zero,13794 <recv_raw+0x160>
   13778:	e0bff917 	ldw	r2,-28(fp)
   1377c:	10c00c17 	ldw	r3,48(r2)
   13780:	e0bffb0b 	ldhu	r2,-20(fp)
   13784:	e13ff917 	ldw	r4,-28(fp)
   13788:	000b883a 	mov	r5,zero
   1378c:	100d883a 	mov	r6,r2
   13790:	183ee83a 	callr	r3
      }
    }
  }

  return 0; /* do not eat the packet */
   13794:	0005883a 	mov	r2,zero
}
   13798:	e037883a 	mov	sp,fp
   1379c:	dfc00117 	ldw	ra,4(sp)
   137a0:	df000017 	ldw	fp,0(sp)
   137a4:	dec00204 	addi	sp,sp,8
   137a8:	f800283a 	ret

000137ac <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   ip_addr_t *addr, u16_t port)
{
   137ac:	defff604 	addi	sp,sp,-40
   137b0:	dfc00915 	stw	ra,36(sp)
   137b4:	df000815 	stw	fp,32(sp)
   137b8:	df000804 	addi	fp,sp,32
   137bc:	e13ffb15 	stw	r4,-20(fp)
   137c0:	e17ffc15 	stw	r5,-16(fp)
   137c4:	e1bffd15 	stw	r6,-12(fp)
   137c8:	e1fffe15 	stw	r7,-8(fp)
   137cc:	e0800217 	ldw	r2,8(fp)
   137d0:	e0bfff0d 	sth	r2,-4(fp)
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  conn = (struct netconn *)arg;
   137d4:	e0bffb17 	ldw	r2,-20(fp)
   137d8:	e0bff815 	stw	r2,-32(fp)
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox)) {
   137dc:	e0bff817 	ldw	r2,-32(fp)
   137e0:	10000326 	beq	r2,zero,137f0 <recv_udp+0x44>
   137e4:	e0bff817 	ldw	r2,-32(fp)
   137e8:	10800517 	ldw	r2,20(r2)
   137ec:	1000031e 	bne	r2,zero,137fc <recv_udp+0x50>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
   137f0:	e13ffd17 	ldw	r4,-12(fp)
   137f4:	00237600 	call	23760 <pbuf_free>
    return;
   137f8:	00003206 	br	138c4 <recv_udp+0x118>
  }

  buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
   137fc:	010001c4 	movi	r4,7
   13800:	00223cc0 	call	223cc <memp_malloc>
   13804:	e0bff915 	stw	r2,-28(fp)
  if (buf == NULL) {
   13808:	e0bff917 	ldw	r2,-28(fp)
   1380c:	1000031e 	bne	r2,zero,1381c <recv_udp+0x70>
    pbuf_free(p);
   13810:	e13ffd17 	ldw	r4,-12(fp)
   13814:	00237600 	call	23760 <pbuf_free>
    return;
   13818:	00002a06 	br	138c4 <recv_udp+0x118>
  } else {
    buf->p = p;
   1381c:	e0bff917 	ldw	r2,-28(fp)
   13820:	e0fffd17 	ldw	r3,-12(fp)
   13824:	10c00015 	stw	r3,0(r2)
    buf->ptr = p;
   13828:	e0bff917 	ldw	r2,-28(fp)
   1382c:	e0fffd17 	ldw	r3,-12(fp)
   13830:	10c00115 	stw	r3,4(r2)
    ip_addr_set(&buf->addr, addr);
   13834:	e0bffe17 	ldw	r2,-8(fp)
   13838:	10000326 	beq	r2,zero,13848 <recv_udp+0x9c>
   1383c:	e0bffe17 	ldw	r2,-8(fp)
   13840:	10800017 	ldw	r2,0(r2)
   13844:	00000106 	br	1384c <recv_udp+0xa0>
   13848:	0005883a 	mov	r2,zero
   1384c:	e0fff917 	ldw	r3,-28(fp)
   13850:	18800215 	stw	r2,8(r3)
    buf->port = port;
   13854:	e0bff917 	ldw	r2,-28(fp)
   13858:	e0ffff0b 	ldhu	r3,-4(fp)
   1385c:	10c0030d 	sth	r3,12(r2)
      buf->toport_chksum = udphdr->dest;
    }
#endif /* LWIP_NETBUF_RECVINFO */
  }

  len = p->tot_len;
   13860:	e0bffd17 	ldw	r2,-12(fp)
   13864:	1080020b 	ldhu	r2,8(r2)
   13868:	e0bffa0d 	sth	r2,-24(fp)
  if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
   1386c:	e0bff817 	ldw	r2,-32(fp)
   13870:	10800504 	addi	r2,r2,20
   13874:	1009883a 	mov	r4,r2
   13878:	e17ff917 	ldw	r5,-28(fp)
   1387c:	001b7480 	call	1b748 <sys_mbox_trypost>
   13880:	10803fcc 	andi	r2,r2,255
   13884:	1080201c 	xori	r2,r2,128
   13888:	10bfe004 	addi	r2,r2,-128
   1388c:	10000326 	beq	r2,zero,1389c <recv_udp+0xf0>
    netbuf_delete(buf);
   13890:	e13ff917 	ldw	r4,-28(fp)
   13894:	0015b180 	call	15b18 <netbuf_delete>
    return;
   13898:	00000a06 	br	138c4 <recv_udp+0x118>
  } else {
#if LWIP_SO_RCVBUF
    SYS_ARCH_INC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
   1389c:	e0bff817 	ldw	r2,-32(fp)
   138a0:	10800c17 	ldw	r2,48(r2)
   138a4:	10000726 	beq	r2,zero,138c4 <recv_udp+0x118>
   138a8:	e0bff817 	ldw	r2,-32(fp)
   138ac:	10c00c17 	ldw	r3,48(r2)
   138b0:	e0bffa0b 	ldhu	r2,-24(fp)
   138b4:	e13ff817 	ldw	r4,-32(fp)
   138b8:	000b883a 	mov	r5,zero
   138bc:	100d883a 	mov	r6,r2
   138c0:	183ee83a 	callr	r3
  }
}
   138c4:	e037883a 	mov	sp,fp
   138c8:	dfc00117 	ldw	ra,4(sp)
   138cc:	df000017 	ldw	fp,0(sp)
   138d0:	dec00204 	addi	sp,sp,8
   138d4:	f800283a 	ret

000138d8 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
   138d8:	defff804 	addi	sp,sp,-32
   138dc:	dfc00715 	stw	ra,28(sp)
   138e0:	df000615 	stw	fp,24(sp)
   138e4:	df000604 	addi	fp,sp,24
   138e8:	e13ffc15 	stw	r4,-16(fp)
   138ec:	e17ffd15 	stw	r5,-12(fp)
   138f0:	e1bffe15 	stw	r6,-8(fp)
   138f4:	3805883a 	mov	r2,r7
   138f8:	e0bfff05 	stb	r2,-4(fp)
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  conn = (struct netconn *)arg;
   138fc:	e0bffc17 	ldw	r2,-16(fp)
   13900:	e0bffb15 	stw	r2,-20(fp)

  if (conn == NULL) {
   13904:	e0bffb17 	ldw	r2,-20(fp)
   13908:	1000021e 	bne	r2,zero,13914 <recv_tcp+0x3c>
    return ERR_VAL;
   1390c:	00bffe84 	movi	r2,-6
   13910:	00003c06 	br	13a04 <recv_tcp+0x12c>
  }

  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);

  if (!sys_mbox_valid(&conn->recvmbox)) {
   13914:	e0bffb17 	ldw	r2,-20(fp)
   13918:	10800517 	ldw	r2,20(r2)
   1391c:	10000c1e 	bne	r2,zero,13950 <recv_tcp+0x78>
    /* recvmbox already deleted */
    if (p != NULL) {
   13920:	e0bffe17 	ldw	r2,-8(fp)
   13924:	10000826 	beq	r2,zero,13948 <recv_tcp+0x70>
      tcp_recved(pcb, p->tot_len);
   13928:	e0bffe17 	ldw	r2,-8(fp)
   1392c:	1080020b 	ldhu	r2,8(r2)
   13930:	10bfffcc 	andi	r2,r2,65535
   13934:	e13ffd17 	ldw	r4,-12(fp)
   13938:	100b883a 	mov	r5,r2
   1393c:	00256180 	call	25618 <tcp_recved>
      pbuf_free(p);
   13940:	e13ffe17 	ldw	r4,-8(fp)
   13944:	00237600 	call	23760 <pbuf_free>
    }
    return ERR_OK;
   13948:	0005883a 	mov	r2,zero
   1394c:	00002d06 	br	13a04 <recv_tcp+0x12c>
  /* Unlike for UDP or RAW pcbs, don't check for available space
     using recv_avail since that could break the connection
     (data is already ACKed) */

  /* don't overwrite fatal errors! */
  NETCONN_SET_SAFE_ERR(conn, err);
   13950:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   13954:	10000126 	beq	r2,zero,1395c <recv_tcp+0x84>
   13958:	00110d00 	call	110d0 <vTaskEnterCritical>
   1395c:	e0bffb17 	ldw	r2,-20(fp)
   13960:	10800303 	ldbu	r2,12(r2)
   13964:	10803fcc 	andi	r2,r2,255
   13968:	1080201c 	xori	r2,r2,128
   1396c:	10bfe004 	addi	r2,r2,-128
   13970:	10bffdd0 	cmplti	r2,r2,-9
   13974:	1000031e 	bne	r2,zero,13984 <recv_tcp+0xac>
   13978:	e0bffb17 	ldw	r2,-20(fp)
   1397c:	e0ffff03 	ldbu	r3,-4(fp)
   13980:	10c00305 	stb	r3,12(r2)
   13984:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   13988:	10000126 	beq	r2,zero,13990 <recv_tcp+0xb8>
   1398c:	00111100 	call	11110 <vTaskExitCritical>

  if (p != NULL) {
   13990:	e0bffe17 	ldw	r2,-8(fp)
   13994:	10000426 	beq	r2,zero,139a8 <recv_tcp+0xd0>
    len = p->tot_len;
   13998:	e0bffe17 	ldw	r2,-8(fp)
   1399c:	1080020b 	ldhu	r2,8(r2)
   139a0:	e0bffa0d 	sth	r2,-24(fp)
   139a4:	00000106 	br	139ac <recv_tcp+0xd4>
  } else {
    len = 0;
   139a8:	e03ffa0d 	sth	zero,-24(fp)
  }

  if (sys_mbox_trypost(&conn->recvmbox, p) != ERR_OK) {
   139ac:	e0bffb17 	ldw	r2,-20(fp)
   139b0:	10800504 	addi	r2,r2,20
   139b4:	1009883a 	mov	r4,r2
   139b8:	e17ffe17 	ldw	r5,-8(fp)
   139bc:	001b7480 	call	1b748 <sys_mbox_trypost>
   139c0:	10803fcc 	andi	r2,r2,255
   139c4:	1080201c 	xori	r2,r2,128
   139c8:	10bfe004 	addi	r2,r2,-128
   139cc:	10000226 	beq	r2,zero,139d8 <recv_tcp+0x100>
    /* don't deallocate p: it is presented to us later again from tcp_fasttmr! */
    return ERR_MEM;
   139d0:	00bfffc4 	movi	r2,-1
   139d4:	00000b06 	br	13a04 <recv_tcp+0x12c>
  } else {
#if LWIP_SO_RCVBUF
    SYS_ARCH_INC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
   139d8:	e0bffb17 	ldw	r2,-20(fp)
   139dc:	10800c17 	ldw	r2,48(r2)
   139e0:	10000726 	beq	r2,zero,13a00 <recv_tcp+0x128>
   139e4:	e0bffb17 	ldw	r2,-20(fp)
   139e8:	10c00c17 	ldw	r3,48(r2)
   139ec:	e0bffa0b 	ldhu	r2,-24(fp)
   139f0:	e13ffb17 	ldw	r4,-20(fp)
   139f4:	000b883a 	mov	r5,zero
   139f8:	100d883a 	mov	r6,r2
   139fc:	183ee83a 	callr	r3
  }

  return ERR_OK;
   13a00:	0005883a 	mov	r2,zero
}
   13a04:	e037883a 	mov	sp,fp
   13a08:	dfc00117 	ldw	ra,4(sp)
   13a0c:	df000017 	ldw	fp,0(sp)
   13a10:	dec00204 	addi	sp,sp,8
   13a14:	f800283a 	ret

00013a18 <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
   13a18:	defffb04 	addi	sp,sp,-20
   13a1c:	dfc00415 	stw	ra,16(sp)
   13a20:	df000315 	stw	fp,12(sp)
   13a24:	df000304 	addi	fp,sp,12
   13a28:	e13ffe15 	stw	r4,-8(fp)
   13a2c:	e17fff15 	stw	r5,-4(fp)
  struct netconn *conn = (struct netconn *)arg;
   13a30:	e0bffe17 	ldw	r2,-8(fp)
   13a34:	e0bffd15 	stw	r2,-12(fp)

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));

  if (conn->state == NETCONN_WRITE) {
   13a38:	e0bffd17 	ldw	r2,-12(fp)
   13a3c:	10800117 	ldw	r2,4(r2)
   13a40:	10800058 	cmpnei	r2,r2,1
   13a44:	1000031e 	bne	r2,zero,13a54 <poll_tcp+0x3c>
    do_writemore(conn);
   13a48:	e13ffd17 	ldw	r4,-12(fp)
   13a4c:	001537c0 	call	1537c <do_writemore>
   13a50:	00000606 	br	13a6c <poll_tcp+0x54>
  } else if (conn->state == NETCONN_CLOSE) {
   13a54:	e0bffd17 	ldw	r2,-12(fp)
   13a58:	10800117 	ldw	r2,4(r2)
   13a5c:	10800118 	cmpnei	r2,r2,4
   13a60:	1000021e 	bne	r2,zero,13a6c <poll_tcp+0x54>
    do_close_internal(conn);
   13a64:	e13ffd17 	ldw	r4,-12(fp)
   13a68:	00144980 	call	14498 <do_close_internal>
  }
  /* @todo: implement connect timeout here? */

  /* Did a nonblocking write fail before? Then check available write-space. */
  if (conn->flags & NETCONN_FLAG_CHECK_WRITESPACE) {
   13a6c:	e0bffd17 	ldw	r2,-12(fp)
   13a70:	10800903 	ldbu	r2,36(r2)
   13a74:	10803fcc 	andi	r2,r2,255
   13a78:	1080040c 	andi	r2,r2,16
   13a7c:	10001f26 	beq	r2,zero,13afc <poll_tcp+0xe4>
    /* If the queued byte- or pbuf-count drops below the configured low-water limit,
       let select mark this pcb as writable again. */
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
   13a80:	e0bffd17 	ldw	r2,-12(fp)
   13a84:	10800217 	ldw	r2,8(r2)
   13a88:	10001c26 	beq	r2,zero,13afc <poll_tcp+0xe4>
   13a8c:	e0bffd17 	ldw	r2,-12(fp)
   13a90:	10800217 	ldw	r2,8(r2)
   13a94:	10801a8b 	ldhu	r2,106(r2)
   13a98:	10bfffcc 	andi	r2,r2,65535
   13a9c:	10816d70 	cmpltui	r2,r2,1461
   13aa0:	1000161e 	bne	r2,zero,13afc <poll_tcp+0xe4>
      (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
   13aa4:	e0bffd17 	ldw	r2,-12(fp)
   13aa8:	10800217 	ldw	r2,8(r2)
   13aac:	10801b0b 	ldhu	r2,108(r2)

  /* Did a nonblocking write fail before? Then check available write-space. */
  if (conn->flags & NETCONN_FLAG_CHECK_WRITESPACE) {
    /* If the queued byte- or pbuf-count drops below the configured low-water limit,
       let select mark this pcb as writable again. */
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
   13ab0:	10bfffcc 	andi	r2,r2,65535
   13ab4:	10800128 	cmpgeui	r2,r2,4
   13ab8:	1000101e 	bne	r2,zero,13afc <poll_tcp+0xe4>
      (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
      conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
   13abc:	e0bffd17 	ldw	r2,-12(fp)
   13ac0:	10c00903 	ldbu	r3,36(r2)
   13ac4:	00bffbc4 	movi	r2,-17
   13ac8:	1884703a 	and	r2,r3,r2
   13acc:	1007883a 	mov	r3,r2
   13ad0:	e0bffd17 	ldw	r2,-12(fp)
   13ad4:	10c00905 	stb	r3,36(r2)
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
   13ad8:	e0bffd17 	ldw	r2,-12(fp)
   13adc:	10800c17 	ldw	r2,48(r2)
   13ae0:	10000626 	beq	r2,zero,13afc <poll_tcp+0xe4>
   13ae4:	e0bffd17 	ldw	r2,-12(fp)
   13ae8:	10800c17 	ldw	r2,48(r2)
   13aec:	e13ffd17 	ldw	r4,-12(fp)
   13af0:	01400084 	movi	r5,2
   13af4:	000d883a 	mov	r6,zero
   13af8:	103ee83a 	callr	r2
    }
  }

  return ERR_OK;
   13afc:	0005883a 	mov	r2,zero
}
   13b00:	e037883a 	mov	sp,fp
   13b04:	dfc00117 	ldw	ra,4(sp)
   13b08:	df000017 	ldw	fp,0(sp)
   13b0c:	dec00204 	addi	sp,sp,8
   13b10:	f800283a 	ret

00013b14 <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
   13b14:	defffa04 	addi	sp,sp,-24
   13b18:	dfc00515 	stw	ra,20(sp)
   13b1c:	df000415 	stw	fp,16(sp)
   13b20:	df000404 	addi	fp,sp,16
   13b24:	e13ffd15 	stw	r4,-12(fp)
   13b28:	e17ffe15 	stw	r5,-8(fp)
   13b2c:	3005883a 	mov	r2,r6
   13b30:	e0bfff0d 	sth	r2,-4(fp)
  struct netconn *conn = (struct netconn *)arg;
   13b34:	e0bffd17 	ldw	r2,-12(fp)
   13b38:	e0bffc15 	stw	r2,-16(fp)

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));

  if (conn) {
   13b3c:	e0bffc17 	ldw	r2,-16(fp)
   13b40:	10002d26 	beq	r2,zero,13bf8 <sent_tcp+0xe4>
  if (conn->state == NETCONN_WRITE) {
   13b44:	e0bffc17 	ldw	r2,-16(fp)
   13b48:	10800117 	ldw	r2,4(r2)
   13b4c:	10800058 	cmpnei	r2,r2,1
   13b50:	1000031e 	bne	r2,zero,13b60 <sent_tcp+0x4c>
    do_writemore(conn);
   13b54:	e13ffc17 	ldw	r4,-16(fp)
   13b58:	001537c0 	call	1537c <do_writemore>
   13b5c:	00000606 	br	13b78 <sent_tcp+0x64>
  } else if (conn->state == NETCONN_CLOSE) {
   13b60:	e0bffc17 	ldw	r2,-16(fp)
   13b64:	10800117 	ldw	r2,4(r2)
   13b68:	10800118 	cmpnei	r2,r2,4
   13b6c:	1000021e 	bne	r2,zero,13b78 <sent_tcp+0x64>
    do_close_internal(conn);
   13b70:	e13ffc17 	ldw	r4,-16(fp)
   13b74:	00144980 	call	14498 <do_close_internal>
  }

    /* If the queued byte- or pbuf-count drops below the configured low-water limit,
       let select mark this pcb as writable again. */
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
   13b78:	e0bffc17 	ldw	r2,-16(fp)
   13b7c:	10800217 	ldw	r2,8(r2)
   13b80:	10001d26 	beq	r2,zero,13bf8 <sent_tcp+0xe4>
   13b84:	e0bffc17 	ldw	r2,-16(fp)
   13b88:	10800217 	ldw	r2,8(r2)
   13b8c:	10801a8b 	ldhu	r2,106(r2)
   13b90:	10bfffcc 	andi	r2,r2,65535
   13b94:	10816d70 	cmpltui	r2,r2,1461
   13b98:	1000171e 	bne	r2,zero,13bf8 <sent_tcp+0xe4>
      (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
   13b9c:	e0bffc17 	ldw	r2,-16(fp)
   13ba0:	10800217 	ldw	r2,8(r2)
   13ba4:	10801b0b 	ldhu	r2,108(r2)
    do_close_internal(conn);
  }

    /* If the queued byte- or pbuf-count drops below the configured low-water limit,
       let select mark this pcb as writable again. */
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
   13ba8:	10bfffcc 	andi	r2,r2,65535
   13bac:	10800128 	cmpgeui	r2,r2,4
   13bb0:	1000111e 	bne	r2,zero,13bf8 <sent_tcp+0xe4>
      (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
      conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
   13bb4:	e0bffc17 	ldw	r2,-16(fp)
   13bb8:	10c00903 	ldbu	r3,36(r2)
   13bbc:	00bffbc4 	movi	r2,-17
   13bc0:	1884703a 	and	r2,r3,r2
   13bc4:	1007883a 	mov	r3,r2
   13bc8:	e0bffc17 	ldw	r2,-16(fp)
   13bcc:	10c00905 	stb	r3,36(r2)
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
   13bd0:	e0bffc17 	ldw	r2,-16(fp)
   13bd4:	10800c17 	ldw	r2,48(r2)
   13bd8:	10000726 	beq	r2,zero,13bf8 <sent_tcp+0xe4>
   13bdc:	e0bffc17 	ldw	r2,-16(fp)
   13be0:	10c00c17 	ldw	r3,48(r2)
   13be4:	e0bfff0b 	ldhu	r2,-4(fp)
   13be8:	e13ffc17 	ldw	r4,-16(fp)
   13bec:	01400084 	movi	r5,2
   13bf0:	100d883a 	mov	r6,r2
   13bf4:	183ee83a 	callr	r3
    }
  }
  
  return ERR_OK;
   13bf8:	0005883a 	mov	r2,zero
}
   13bfc:	e037883a 	mov	sp,fp
   13c00:	dfc00117 	ldw	ra,4(sp)
   13c04:	df000017 	ldw	fp,0(sp)
   13c08:	dec00204 	addi	sp,sp,8
   13c0c:	f800283a 	ret

00013c10 <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
   13c10:	defff904 	addi	sp,sp,-28
   13c14:	dfc00615 	stw	ra,24(sp)
   13c18:	df000515 	stw	fp,20(sp)
   13c1c:	df000504 	addi	fp,sp,20
   13c20:	e13ffe15 	stw	r4,-8(fp)
   13c24:	2805883a 	mov	r2,r5
   13c28:	e0bfff05 	stb	r2,-4(fp)
  struct netconn *conn;
  enum netconn_state old_state;
  SYS_ARCH_DECL_PROTECT(lev);

  conn = (struct netconn *)arg;
   13c2c:	e0bffe17 	ldw	r2,-8(fp)
   13c30:	e0bffb15 	stw	r2,-20(fp)
  LWIP_ASSERT("conn != NULL", (conn != NULL));

  conn->pcb.tcp = NULL;
   13c34:	e0bffb17 	ldw	r2,-20(fp)
   13c38:	10000215 	stw	zero,8(r2)

  /* no check since this is always fatal! */
  SYS_ARCH_PROTECT(lev);
   13c3c:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   13c40:	10000126 	beq	r2,zero,13c48 <err_tcp+0x38>
   13c44:	00110d00 	call	110d0 <vTaskEnterCritical>
  conn->last_err = err;
   13c48:	e0bffb17 	ldw	r2,-20(fp)
   13c4c:	e0ffff03 	ldbu	r3,-4(fp)
   13c50:	10c00305 	stb	r3,12(r2)
  SYS_ARCH_UNPROTECT(lev);
   13c54:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   13c58:	10000126 	beq	r2,zero,13c60 <err_tcp+0x50>
   13c5c:	00111100 	call	11110 <vTaskExitCritical>

  /* reset conn->state now before waking up other threads */
  old_state = conn->state;
   13c60:	e0bffb17 	ldw	r2,-20(fp)
   13c64:	10800117 	ldw	r2,4(r2)
   13c68:	e0bffc15 	stw	r2,-16(fp)
  conn->state = NETCONN_NONE;
   13c6c:	e0bffb17 	ldw	r2,-20(fp)
   13c70:	10000115 	stw	zero,4(r2)

  /* Notify the user layer about a connection error. Used to signal
     select. */
  API_EVENT(conn, NETCONN_EVT_ERROR, 0);
   13c74:	e0bffb17 	ldw	r2,-20(fp)
   13c78:	10800c17 	ldw	r2,48(r2)
   13c7c:	10000626 	beq	r2,zero,13c98 <err_tcp+0x88>
   13c80:	e0bffb17 	ldw	r2,-20(fp)
   13c84:	10800c17 	ldw	r2,48(r2)
   13c88:	e13ffb17 	ldw	r4,-20(fp)
   13c8c:	01400104 	movi	r5,4
   13c90:	000d883a 	mov	r6,zero
   13c94:	103ee83a 	callr	r2
  /* Try to release selects pending on 'read' or 'write', too.
     They will get an error if they actually try to read or write. */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
   13c98:	e0bffb17 	ldw	r2,-20(fp)
   13c9c:	10800c17 	ldw	r2,48(r2)
   13ca0:	10000626 	beq	r2,zero,13cbc <err_tcp+0xac>
   13ca4:	e0bffb17 	ldw	r2,-20(fp)
   13ca8:	10800c17 	ldw	r2,48(r2)
   13cac:	e13ffb17 	ldw	r4,-20(fp)
   13cb0:	000b883a 	mov	r5,zero
   13cb4:	000d883a 	mov	r6,zero
   13cb8:	103ee83a 	callr	r2
  API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
   13cbc:	e0bffb17 	ldw	r2,-20(fp)
   13cc0:	10800c17 	ldw	r2,48(r2)
   13cc4:	10000626 	beq	r2,zero,13ce0 <err_tcp+0xd0>
   13cc8:	e0bffb17 	ldw	r2,-20(fp)
   13ccc:	10800c17 	ldw	r2,48(r2)
   13cd0:	e13ffb17 	ldw	r4,-20(fp)
   13cd4:	01400084 	movi	r5,2
   13cd8:	000d883a 	mov	r6,zero
   13cdc:	103ee83a 	callr	r2

  /* pass NULL-message to recvmbox to wake up pending recv */
  if (sys_mbox_valid(&conn->recvmbox)) {
   13ce0:	e0bffb17 	ldw	r2,-20(fp)
   13ce4:	10800517 	ldw	r2,20(r2)
   13ce8:	10000526 	beq	r2,zero,13d00 <err_tcp+0xf0>
    /* use trypost to prevent deadlock */
    sys_mbox_trypost(&conn->recvmbox, NULL);
   13cec:	e0bffb17 	ldw	r2,-20(fp)
   13cf0:	10800504 	addi	r2,r2,20
   13cf4:	1009883a 	mov	r4,r2
   13cf8:	000b883a 	mov	r5,zero
   13cfc:	001b7480 	call	1b748 <sys_mbox_trypost>
  }
  /* pass NULL-message to acceptmbox to wake up pending accept */
  if (sys_mbox_valid(&conn->acceptmbox)) {
   13d00:	e0bffb17 	ldw	r2,-20(fp)
   13d04:	10800617 	ldw	r2,24(r2)
   13d08:	10000526 	beq	r2,zero,13d20 <err_tcp+0x110>
    /* use trypost to preven deadlock */
    sys_mbox_trypost(&conn->acceptmbox, NULL);
   13d0c:	e0bffb17 	ldw	r2,-20(fp)
   13d10:	10800604 	addi	r2,r2,24
   13d14:	1009883a 	mov	r4,r2
   13d18:	000b883a 	mov	r5,zero
   13d1c:	001b7480 	call	1b748 <sys_mbox_trypost>
  }

  if ((old_state == NETCONN_WRITE) || (old_state == NETCONN_CLOSE) ||
   13d20:	e0bffc17 	ldw	r2,-16(fp)
   13d24:	10800060 	cmpeqi	r2,r2,1
   13d28:	1000061e 	bne	r2,zero,13d44 <err_tcp+0x134>
   13d2c:	e0bffc17 	ldw	r2,-16(fp)
   13d30:	10800120 	cmpeqi	r2,r2,4
   13d34:	1000031e 	bne	r2,zero,13d44 <err_tcp+0x134>
   13d38:	e0bffc17 	ldw	r2,-16(fp)
   13d3c:	108000d8 	cmpnei	r2,r2,3
   13d40:	10001a1e 	bne	r2,zero,13dac <err_tcp+0x19c>
      (old_state == NETCONN_CONNECT)) {
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    int was_nonblocking_connect = IN_NONBLOCKING_CONNECT(conn);
   13d44:	e0bffb17 	ldw	r2,-20(fp)
   13d48:	10800903 	ldbu	r2,36(r2)
   13d4c:	10803fcc 	andi	r2,r2,255
   13d50:	1080010c 	andi	r2,r2,4
   13d54:	1004c03a 	cmpne	r2,r2,zero
   13d58:	10803fcc 	andi	r2,r2,255
   13d5c:	e0bffd15 	stw	r2,-12(fp)
    SET_NONBLOCKING_CONNECT(conn, 0);
   13d60:	e0bffb17 	ldw	r2,-20(fp)
   13d64:	10c00903 	ldbu	r3,36(r2)
   13d68:	00bffec4 	movi	r2,-5
   13d6c:	1884703a 	and	r2,r3,r2
   13d70:	1007883a 	mov	r3,r2
   13d74:	e0bffb17 	ldw	r2,-20(fp)
   13d78:	10c00905 	stb	r3,36(r2)

    if (!was_nonblocking_connect) {
   13d7c:	e0bffd17 	ldw	r2,-12(fp)
   13d80:	10000a1e 	bne	r2,zero,13dac <err_tcp+0x19c>
      /* set error return code */
      LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
      conn->current_msg->err = err;
   13d84:	e0bffb17 	ldw	r2,-20(fp)
   13d88:	10800b17 	ldw	r2,44(r2)
   13d8c:	e0ffff03 	ldbu	r3,-4(fp)
   13d90:	10c00105 	stb	r3,4(r2)
      conn->current_msg = NULL;
   13d94:	e0bffb17 	ldw	r2,-20(fp)
   13d98:	10000b15 	stw	zero,44(r2)
      /* wake up the waiting task */
      sys_sem_signal(&conn->op_completed);
   13d9c:	e0bffb17 	ldw	r2,-20(fp)
   13da0:	10800404 	addi	r2,r2,16
   13da4:	1009883a 	mov	r4,r2
   13da8:	001b2f00 	call	1b2f0 <sys_sem_signal>
    }
  } else {
    LWIP_ASSERT("conn->current_msg == NULL", conn->current_msg == NULL);
  }
}
   13dac:	e037883a 	mov	sp,fp
   13db0:	dfc00117 	ldw	ra,4(sp)
   13db4:	df000017 	ldw	fp,0(sp)
   13db8:	dec00204 	addi	sp,sp,8
   13dbc:	f800283a 	ret

00013dc0 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
   13dc0:	defffc04 	addi	sp,sp,-16
   13dc4:	dfc00315 	stw	ra,12(sp)
   13dc8:	df000215 	stw	fp,8(sp)
   13dcc:	df000204 	addi	fp,sp,8
   13dd0:	e13fff15 	stw	r4,-4(fp)
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
   13dd4:	e0bfff17 	ldw	r2,-4(fp)
   13dd8:	10800217 	ldw	r2,8(r2)
   13ddc:	e0bffe15 	stw	r2,-8(fp)
  tcp_arg(pcb, conn);
   13de0:	e13ffe17 	ldw	r4,-8(fp)
   13de4:	e17fff17 	ldw	r5,-4(fp)
   13de8:	00269f80 	call	269f8 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
   13dec:	e13ffe17 	ldw	r4,-8(fp)
   13df0:	01400074 	movhi	r5,1
   13df4:	294e3604 	addi	r5,r5,14552
   13df8:	0026a280 	call	26a28 <tcp_recv>
  tcp_sent(pcb, sent_tcp);
   13dfc:	e13ffe17 	ldw	r4,-8(fp)
   13e00:	01400074 	movhi	r5,1
   13e04:	294ec504 	addi	r5,r5,15124
   13e08:	0026a580 	call	26a58 <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
   13e0c:	e13ffe17 	ldw	r4,-8(fp)
   13e10:	01400074 	movhi	r5,1
   13e14:	294e8604 	addi	r5,r5,14872
   13e18:	01800104 	movi	r6,4
   13e1c:	0026ae80 	call	26ae8 <tcp_poll>
  tcp_err(pcb, err_tcp);
   13e20:	e13ffe17 	ldw	r4,-8(fp)
   13e24:	01400074 	movhi	r5,1
   13e28:	294f0404 	addi	r5,r5,15376
   13e2c:	0026a880 	call	26a88 <tcp_err>
}
   13e30:	e037883a 	mov	sp,fp
   13e34:	dfc00117 	ldw	ra,4(sp)
   13e38:	df000017 	ldw	fp,0(sp)
   13e3c:	dec00204 	addi	sp,sp,8
   13e40:	f800283a 	ret

00013e44 <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
   13e44:	defff804 	addi	sp,sp,-32
   13e48:	dfc00715 	stw	ra,28(sp)
   13e4c:	df000615 	stw	fp,24(sp)
   13e50:	df000604 	addi	fp,sp,24
   13e54:	e13ffd15 	stw	r4,-12(fp)
   13e58:	e17ffe15 	stw	r5,-8(fp)
   13e5c:	3005883a 	mov	r2,r6
   13e60:	e0bfff05 	stb	r2,-4(fp)
  struct netconn *newconn;
  struct netconn *conn = (struct netconn *)arg;
   13e64:	e0bffd17 	ldw	r2,-12(fp)
   13e68:	e0bffa15 	stw	r2,-24(fp)

  LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: newpcb->tate: %s\n", tcp_debug_state_str(newpcb->state)));

  if (!sys_mbox_valid(&conn->acceptmbox)) {
   13e6c:	e0bffa17 	ldw	r2,-24(fp)
   13e70:	10800617 	ldw	r2,24(r2)
   13e74:	1000021e 	bne	r2,zero,13e80 <accept_function+0x3c>
    LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: acceptmbox already deleted\n"));
    return ERR_VAL;
   13e78:	00bffe84 	movi	r2,-6
   13e7c:	00004606 	br	13f98 <accept_function+0x154>
  }

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
   13e80:	e0bffa17 	ldw	r2,-24(fp)
   13e84:	10c00017 	ldw	r3,0(r2)
   13e88:	e0bffa17 	ldw	r2,-24(fp)
   13e8c:	10800c17 	ldw	r2,48(r2)
   13e90:	1809883a 	mov	r4,r3
   13e94:	100b883a 	mov	r5,r2
   13e98:	00141a80 	call	141a8 <netconn_alloc>
   13e9c:	e0bffb15 	stw	r2,-20(fp)
  if (newconn == NULL) {
   13ea0:	e0bffb17 	ldw	r2,-20(fp)
   13ea4:	1000021e 	bne	r2,zero,13eb0 <accept_function+0x6c>
    return ERR_MEM;
   13ea8:	00bfffc4 	movi	r2,-1
   13eac:	00003a06 	br	13f98 <accept_function+0x154>
  }
  newconn->pcb.tcp = newpcb;
   13eb0:	e0bffb17 	ldw	r2,-20(fp)
   13eb4:	e0fffe17 	ldw	r3,-8(fp)
   13eb8:	10c00215 	stw	r3,8(r2)
  setup_tcp(newconn);
   13ebc:	e13ffb17 	ldw	r4,-20(fp)
   13ec0:	0013dc00 	call	13dc0 <setup_tcp>
  /* no protection: when creating the pcb, the netconn is not yet known
     to the application thread */
  newconn->last_err = err;
   13ec4:	e0bffb17 	ldw	r2,-20(fp)
   13ec8:	e0ffff03 	ldbu	r3,-4(fp)
   13ecc:	10c00305 	stb	r3,12(r2)

  if (sys_mbox_trypost(&conn->acceptmbox, newconn) != ERR_OK) {
   13ed0:	e0bffa17 	ldw	r2,-24(fp)
   13ed4:	10800604 	addi	r2,r2,24
   13ed8:	1009883a 	mov	r4,r2
   13edc:	e17ffb17 	ldw	r5,-20(fp)
   13ee0:	001b7480 	call	1b748 <sys_mbox_trypost>
   13ee4:	10803fcc 	andi	r2,r2,255
   13ee8:	1080201c 	xori	r2,r2,128
   13eec:	10bfe004 	addi	r2,r2,-128
   13ef0:	10001f26 	beq	r2,zero,13f70 <accept_function+0x12c>
    /* When returning != ERR_OK, the pcb is aborted in tcp_process(),
       so do nothing here! */
    /* remove all references to this netconn from the pcb */
    struct tcp_pcb* pcb = newconn->pcb.tcp;
   13ef4:	e0bffb17 	ldw	r2,-20(fp)
   13ef8:	10800217 	ldw	r2,8(r2)
   13efc:	e0bffc15 	stw	r2,-16(fp)
    tcp_arg(pcb, NULL);
   13f00:	e13ffc17 	ldw	r4,-16(fp)
   13f04:	000b883a 	mov	r5,zero
   13f08:	00269f80 	call	269f8 <tcp_arg>
    tcp_recv(pcb, NULL);
   13f0c:	e13ffc17 	ldw	r4,-16(fp)
   13f10:	000b883a 	mov	r5,zero
   13f14:	0026a280 	call	26a28 <tcp_recv>
    tcp_sent(pcb, NULL);
   13f18:	e13ffc17 	ldw	r4,-16(fp)
   13f1c:	000b883a 	mov	r5,zero
   13f20:	0026a580 	call	26a58 <tcp_sent>
    tcp_poll(pcb, NULL, 4);
   13f24:	e13ffc17 	ldw	r4,-16(fp)
   13f28:	000b883a 	mov	r5,zero
   13f2c:	01800104 	movi	r6,4
   13f30:	0026ae80 	call	26ae8 <tcp_poll>
    tcp_err(pcb, NULL);
   13f34:	e13ffc17 	ldw	r4,-16(fp)
   13f38:	000b883a 	mov	r5,zero
   13f3c:	0026a880 	call	26a88 <tcp_err>
    /* remove reference from to the pcb from this netconn */
    newconn->pcb.tcp = NULL;
   13f40:	e0bffb17 	ldw	r2,-20(fp)
   13f44:	10000215 	stw	zero,8(r2)
    /* no need to drain since we know the recvmbox is empty. */
    sys_mbox_free(&newconn->recvmbox);
   13f48:	e0bffb17 	ldw	r2,-20(fp)
   13f4c:	10800504 	addi	r2,r2,20
   13f50:	1009883a 	mov	r4,r2
   13f54:	001b6900 	call	1b690 <sys_mbox_free>
    sys_mbox_set_invalid(&newconn->recvmbox);
   13f58:	e0bffb17 	ldw	r2,-20(fp)
   13f5c:	10000515 	stw	zero,20(r2)
    netconn_free(newconn);
   13f60:	e13ffb17 	ldw	r4,-20(fp)
   13f64:	00142d40 	call	142d4 <netconn_free>
    return ERR_MEM;
   13f68:	00bfffc4 	movi	r2,-1
   13f6c:	00000a06 	br	13f98 <accept_function+0x154>
  } else {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
   13f70:	e0bffa17 	ldw	r2,-24(fp)
   13f74:	10800c17 	ldw	r2,48(r2)
   13f78:	10000626 	beq	r2,zero,13f94 <accept_function+0x150>
   13f7c:	e0bffa17 	ldw	r2,-24(fp)
   13f80:	10800c17 	ldw	r2,48(r2)
   13f84:	e13ffa17 	ldw	r4,-24(fp)
   13f88:	000b883a 	mov	r5,zero
   13f8c:	000d883a 	mov	r6,zero
   13f90:	103ee83a 	callr	r2
  }

  return ERR_OK;
   13f94:	0005883a 	mov	r2,zero
}
   13f98:	e037883a 	mov	sp,fp
   13f9c:	dfc00117 	ldw	ra,4(sp)
   13fa0:	df000017 	ldw	fp,0(sp)
   13fa4:	dec00204 	addi	sp,sp,8
   13fa8:	f800283a 	ret

00013fac <pcb_new>:
 * @param msg the api_msg_msg describing the connection type
 * @return msg->conn->err, but the return value is currently ignored
 */
static void
pcb_new(struct api_msg_msg *msg)
{
   13fac:	defffc04 	addi	sp,sp,-16
   13fb0:	dfc00315 	stw	ra,12(sp)
   13fb4:	df000215 	stw	fp,8(sp)
   13fb8:	dc000115 	stw	r16,4(sp)
   13fbc:	df000104 	addi	fp,sp,4
   13fc0:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);

  /* Allocate a PCB for this connection */
  switch(NETCONNTYPE_GROUP(msg->conn->type)) {
   13fc4:	e0bfff17 	ldw	r2,-4(fp)
   13fc8:	10800017 	ldw	r2,0(r2)
   13fcc:	10800017 	ldw	r2,0(r2)
   13fd0:	10803c0c 	andi	r2,r2,240
   13fd4:	10c00820 	cmpeqi	r3,r2,32
   13fd8:	1800201e 	bne	r3,zero,1405c <pcb_new+0xb0>
   13fdc:	10c01020 	cmpeqi	r3,r2,64
   13fe0:	1800031e 	bne	r3,zero,13ff0 <pcb_new+0x44>
   13fe4:	10800420 	cmpeqi	r2,r2,16
   13fe8:	10003d1e 	bne	r2,zero,140e0 <pcb_new+0x134>
   13fec:	00004d06 	br	14124 <pcb_new+0x178>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
   13ff0:	e0bfff17 	ldw	r2,-4(fp)
   13ff4:	14000017 	ldw	r16,0(r2)
   13ff8:	e0bfff17 	ldw	r2,-4(fp)
   13ffc:	10800203 	ldbu	r2,8(r2)
   14000:	10803fcc 	andi	r2,r2,255
   14004:	1009883a 	mov	r4,r2
   14008:	002498c0 	call	2498c <raw_new>
   1400c:	80800215 	stw	r2,8(r16)
    if(msg->conn->pcb.raw == NULL) {
   14010:	e0bfff17 	ldw	r2,-4(fp)
   14014:	10800017 	ldw	r2,0(r2)
   14018:	10800217 	ldw	r2,8(r2)
   1401c:	1000041e 	bne	r2,zero,14030 <pcb_new+0x84>
      msg->err = ERR_MEM;
   14020:	e0bfff17 	ldw	r2,-4(fp)
   14024:	00ffffc4 	movi	r3,-1
   14028:	10c00105 	stb	r3,4(r2)
      break;
   1402c:	00004106 	br	14134 <pcb_new+0x188>
    }
    raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
   14030:	e0bfff17 	ldw	r2,-4(fp)
   14034:	10800017 	ldw	r2,0(r2)
   14038:	10c00217 	ldw	r3,8(r2)
   1403c:	e0bfff17 	ldw	r2,-4(fp)
   14040:	10800017 	ldw	r2,0(r2)
   14044:	1809883a 	mov	r4,r3
   14048:	01400074 	movhi	r5,1
   1404c:	294d8d04 	addi	r5,r5,13876
   14050:	100d883a 	mov	r6,r2
   14054:	00246e40 	call	246e4 <raw_recv>
    break;
   14058:	00003606 	br	14134 <pcb_new+0x188>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->pcb.udp = udp_new();
   1405c:	e0bfff17 	ldw	r2,-4(fp)
   14060:	14000017 	ldw	r16,0(r2)
   14064:	002fc780 	call	2fc78 <udp_new>
   14068:	80800215 	stw	r2,8(r16)
    if(msg->conn->pcb.udp == NULL) {
   1406c:	e0bfff17 	ldw	r2,-4(fp)
   14070:	10800017 	ldw	r2,0(r2)
   14074:	10800217 	ldw	r2,8(r2)
   14078:	1000041e 	bne	r2,zero,1408c <pcb_new+0xe0>
      msg->err = ERR_MEM;
   1407c:	e0bfff17 	ldw	r2,-4(fp)
   14080:	00ffffc4 	movi	r3,-1
   14084:	10c00105 	stb	r3,4(r2)
      break;
   14088:	00002a06 	br	14134 <pcb_new+0x188>
#if LWIP_UDPLITE
    if (msg->conn->type==NETCONN_UDPLITE) {
      udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
    }
#endif /* LWIP_UDPLITE */
    if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
   1408c:	e0bfff17 	ldw	r2,-4(fp)
   14090:	10800017 	ldw	r2,0(r2)
   14094:	10800017 	ldw	r2,0(r2)
   14098:	10800898 	cmpnei	r2,r2,34
   1409c:	1000051e 	bne	r2,zero,140b4 <pcb_new+0x108>
      udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
   140a0:	e0bfff17 	ldw	r2,-4(fp)
   140a4:	10800017 	ldw	r2,0(r2)
   140a8:	10800217 	ldw	r2,8(r2)
   140ac:	00c00044 	movi	r3,1
   140b0:	10c00405 	stb	r3,16(r2)
    }
    udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
   140b4:	e0bfff17 	ldw	r2,-4(fp)
   140b8:	10800017 	ldw	r2,0(r2)
   140bc:	10c00217 	ldw	r3,8(r2)
   140c0:	e0bfff17 	ldw	r2,-4(fp)
   140c4:	10800017 	ldw	r2,0(r2)
   140c8:	1809883a 	mov	r4,r3
   140cc:	01400074 	movhi	r5,1
   140d0:	294deb04 	addi	r5,r5,14252
   140d4:	100d883a 	mov	r6,r2
   140d8:	002fb9c0 	call	2fb9c <udp_recv>
    break;
   140dc:	00001506 	br	14134 <pcb_new+0x188>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->pcb.tcp = tcp_new();
   140e0:	e0bfff17 	ldw	r2,-4(fp)
   140e4:	14000017 	ldw	r16,0(r2)
   140e8:	00269cc0 	call	269cc <tcp_new>
   140ec:	80800215 	stw	r2,8(r16)
    if(msg->conn->pcb.tcp == NULL) {
   140f0:	e0bfff17 	ldw	r2,-4(fp)
   140f4:	10800017 	ldw	r2,0(r2)
   140f8:	10800217 	ldw	r2,8(r2)
   140fc:	1000041e 	bne	r2,zero,14110 <pcb_new+0x164>
      msg->err = ERR_MEM;
   14100:	e0bfff17 	ldw	r2,-4(fp)
   14104:	00ffffc4 	movi	r3,-1
   14108:	10c00105 	stb	r3,4(r2)
      break;
   1410c:	00000906 	br	14134 <pcb_new+0x188>
    }
    setup_tcp(msg->conn);
   14110:	e0bfff17 	ldw	r2,-4(fp)
   14114:	10800017 	ldw	r2,0(r2)
   14118:	1009883a 	mov	r4,r2
   1411c:	0013dc00 	call	13dc0 <setup_tcp>
    break;
   14120:	00000406 	br	14134 <pcb_new+0x188>
#endif /* LWIP_TCP */
  default:
    /* Unsupported netconn type, e.g. protocol disabled */
    msg->err = ERR_VAL;
   14124:	e0bfff17 	ldw	r2,-4(fp)
   14128:	00fffe84 	movi	r3,-6
   1412c:	10c00105 	stb	r3,4(r2)
    break;
   14130:	0001883a 	nop
  }
}
   14134:	e037883a 	mov	sp,fp
   14138:	dfc00217 	ldw	ra,8(sp)
   1413c:	df000117 	ldw	fp,4(sp)
   14140:	dc000017 	ldw	r16,0(sp)
   14144:	dec00304 	addi	sp,sp,12
   14148:	f800283a 	ret

0001414c <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
   1414c:	defffd04 	addi	sp,sp,-12
   14150:	dfc00215 	stw	ra,8(sp)
   14154:	df000115 	stw	fp,4(sp)
   14158:	df000104 	addi	fp,sp,4
   1415c:	e13fff15 	stw	r4,-4(fp)
  msg->err = ERR_OK;
   14160:	e0bfff17 	ldw	r2,-4(fp)
   14164:	10000105 	stb	zero,4(r2)
  if(msg->conn->pcb.tcp == NULL) {
   14168:	e0bfff17 	ldw	r2,-4(fp)
   1416c:	10800017 	ldw	r2,0(r2)
   14170:	10800217 	ldw	r2,8(r2)
   14174:	1000021e 	bne	r2,zero,14180 <do_newconn+0x34>
    pcb_new(msg);
   14178:	e13fff17 	ldw	r4,-4(fp)
   1417c:	0013fac0 	call	13fac <pcb_new>
  }
  /* Else? This "new" connection already has a PCB allocated. */
  /* Is this an error condition? Should it be deleted? */
  /* We currently just are happy and return. */

  TCPIP_APIMSG_ACK(msg);
   14180:	e0bfff17 	ldw	r2,-4(fp)
   14184:	10800017 	ldw	r2,0(r2)
   14188:	10800404 	addi	r2,r2,16
   1418c:	1009883a 	mov	r4,r2
   14190:	001b2f00 	call	1b2f0 <sys_sem_signal>
}
   14194:	e037883a 	mov	sp,fp
   14198:	dfc00117 	ldw	ra,4(sp)
   1419c:	df000017 	ldw	fp,0(sp)
   141a0:	dec00204 	addi	sp,sp,8
   141a4:	f800283a 	ret

000141a8 <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
   141a8:	defffa04 	addi	sp,sp,-24
   141ac:	dfc00515 	stw	ra,20(sp)
   141b0:	df000415 	stw	fp,16(sp)
   141b4:	df000404 	addi	fp,sp,16
   141b8:	e13ffe15 	stw	r4,-8(fp)
   141bc:	e17fff15 	stw	r5,-4(fp)
  struct netconn *conn;
  int size;

  conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
   141c0:	01000204 	movi	r4,8
   141c4:	00223cc0 	call	223cc <memp_malloc>
   141c8:	e0bffc15 	stw	r2,-16(fp)
  if (conn == NULL) {
   141cc:	e0bffc17 	ldw	r2,-16(fp)
   141d0:	1000021e 	bne	r2,zero,141dc <netconn_alloc+0x34>
    return NULL;
   141d4:	0005883a 	mov	r2,zero
   141d8:	00003906 	br	142c0 <netconn_alloc+0x118>
  }

  conn->last_err = ERR_OK;
   141dc:	e0bffc17 	ldw	r2,-16(fp)
   141e0:	10000305 	stb	zero,12(r2)
  conn->type = t;
   141e4:	e0bffc17 	ldw	r2,-16(fp)
   141e8:	e0fffe17 	ldw	r3,-8(fp)
   141ec:	10c00015 	stw	r3,0(r2)
  conn->pcb.tcp = NULL;
   141f0:	e0bffc17 	ldw	r2,-16(fp)
   141f4:	10000215 	stw	zero,8(r2)

#if (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_UDP_RECVMBOX_SIZE) && \
    (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_TCP_RECVMBOX_SIZE)
  size = DEFAULT_RAW_RECVMBOX_SIZE;
   141f8:	00840004 	movi	r2,4096
   141fc:	e0bffd15 	stw	r2,-12(fp)
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    goto free_and_return;
  }
#endif

  if (sys_sem_new(&conn->op_completed, 0) != ERR_OK) {
   14200:	e0bffc17 	ldw	r2,-16(fp)
   14204:	10800404 	addi	r2,r2,16
   14208:	1009883a 	mov	r4,r2
   1420c:	000b883a 	mov	r5,zero
   14210:	001b1bc0 	call	1b1bc <sys_sem_new>
   14214:	10803fcc 	andi	r2,r2,255
   14218:	1080201c 	xori	r2,r2,128
   1421c:	10bfe004 	addi	r2,r2,-128
   14220:	1000221e 	bne	r2,zero,142ac <netconn_alloc+0x104>
    goto free_and_return;
  }
  if (sys_mbox_new(&conn->recvmbox, size) != ERR_OK) {
   14224:	e0bffc17 	ldw	r2,-16(fp)
   14228:	10800504 	addi	r2,r2,20
   1422c:	1009883a 	mov	r4,r2
   14230:	e17ffd17 	ldw	r5,-12(fp)
   14234:	001b5c40 	call	1b5c4 <sys_mbox_new>
   14238:	10803fcc 	andi	r2,r2,255
   1423c:	1080201c 	xori	r2,r2,128
   14240:	10bfe004 	addi	r2,r2,-128
   14244:	10000526 	beq	r2,zero,1425c <netconn_alloc+0xb4>
    sys_sem_free(&conn->op_completed);
   14248:	e0bffc17 	ldw	r2,-16(fp)
   1424c:	10800404 	addi	r2,r2,16
   14250:	1009883a 	mov	r4,r2
   14254:	001b29c0 	call	1b29c <sys_sem_free>
    goto free_and_return;
   14258:	00001506 	br	142b0 <netconn_alloc+0x108>
  }

#if LWIP_TCP
  sys_mbox_set_invalid(&conn->acceptmbox);
   1425c:	e0bffc17 	ldw	r2,-16(fp)
   14260:	10000615 	stw	zero,24(r2)
#endif
  conn->state        = NETCONN_NONE;
   14264:	e0bffc17 	ldw	r2,-16(fp)
   14268:	10000115 	stw	zero,4(r2)
#if LWIP_SOCKET
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
   1426c:	e0bffc17 	ldw	r2,-16(fp)
   14270:	00ffffc4 	movi	r3,-1
   14274:	10c00715 	stw	r3,28(r2)
#endif /* LWIP_SOCKET */
  conn->callback     = callback;
   14278:	e0bffc17 	ldw	r2,-16(fp)
   1427c:	e0ffff17 	ldw	r3,-4(fp)
   14280:	10c00c15 	stw	r3,48(r2)
#if LWIP_TCP
  conn->current_msg  = NULL;
   14284:	e0bffc17 	ldw	r2,-16(fp)
   14288:	10000b15 	stw	zero,44(r2)
  conn->write_offset = 0;
   1428c:	e0bffc17 	ldw	r2,-16(fp)
   14290:	10000a15 	stw	zero,40(r2)
#endif /* LWIP_TCP */
#if LWIP_SO_SNDTIMEO
  conn->send_timeout = 0;
#endif /* LWIP_SO_SNDTIMEO */
#if LWIP_SO_RCVTIMEO
  conn->recv_timeout = 0;
   14294:	e0bffc17 	ldw	r2,-16(fp)
   14298:	10000815 	stw	zero,32(r2)
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = RECV_BUFSIZE_DEFAULT;
  conn->recv_avail   = 0;
#endif /* LWIP_SO_RCVBUF */
  conn->flags = 0;
   1429c:	e0bffc17 	ldw	r2,-16(fp)
   142a0:	10000905 	stb	zero,36(r2)
  return conn;
   142a4:	e0bffc17 	ldw	r2,-16(fp)
   142a8:	00000506 	br	142c0 <netconn_alloc+0x118>
    goto free_and_return;
  }
#endif

  if (sys_sem_new(&conn->op_completed, 0) != ERR_OK) {
    goto free_and_return;
   142ac:	0001883a 	nop
  conn->recv_avail   = 0;
#endif /* LWIP_SO_RCVBUF */
  conn->flags = 0;
  return conn;
free_and_return:
  memp_free(MEMP_NETCONN, conn);
   142b0:	01000204 	movi	r4,8
   142b4:	e17ffc17 	ldw	r5,-16(fp)
   142b8:	00225900 	call	22590 <memp_free>
  return NULL;
   142bc:	0005883a 	mov	r2,zero
}
   142c0:	e037883a 	mov	sp,fp
   142c4:	dfc00117 	ldw	ra,4(sp)
   142c8:	df000017 	ldw	fp,0(sp)
   142cc:	dec00204 	addi	sp,sp,8
   142d0:	f800283a 	ret

000142d4 <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
   142d4:	defffd04 	addi	sp,sp,-12
   142d8:	dfc00215 	stw	ra,8(sp)
   142dc:	df000115 	stw	fp,4(sp)
   142e0:	df000104 	addi	fp,sp,4
   142e4:	e13fff15 	stw	r4,-4(fp)
#if LWIP_TCP
  LWIP_ASSERT("acceptmbox must be deallocated before calling this function",
    !sys_mbox_valid(&conn->acceptmbox));
#endif /* LWIP_TCP */

  sys_sem_free(&conn->op_completed);
   142e8:	e0bfff17 	ldw	r2,-4(fp)
   142ec:	10800404 	addi	r2,r2,16
   142f0:	1009883a 	mov	r4,r2
   142f4:	001b29c0 	call	1b29c <sys_sem_free>
  sys_sem_set_invalid(&conn->op_completed);
   142f8:	e0bfff17 	ldw	r2,-4(fp)
   142fc:	10000415 	stw	zero,16(r2)

  memp_free(MEMP_NETCONN, conn);
   14300:	01000204 	movi	r4,8
   14304:	e17fff17 	ldw	r5,-4(fp)
   14308:	00225900 	call	22590 <memp_free>
}
   1430c:	e037883a 	mov	sp,fp
   14310:	dfc00117 	ldw	ra,4(sp)
   14314:	df000017 	ldw	fp,0(sp)
   14318:	dec00204 	addi	sp,sp,8
   1431c:	f800283a 	ret

00014320 <netconn_drain>:
 * @bytes_drained bytes drained from recvmbox
 * @accepts_drained pending connections drained from acceptmbox
 */
static void
netconn_drain(struct netconn *conn)
{
   14320:	defffa04 	addi	sp,sp,-24
   14324:	dfc00515 	stw	ra,20(sp)
   14328:	df000415 	stw	fp,16(sp)
   1432c:	df000404 	addi	fp,sp,16
   14330:	e13fff15 	stw	r4,-4(fp)
#endif /* LWIP_TCP */

  /* This runs in tcpip_thread, so we don't need to lock against rx packets */

  /* Delete and drain the recvmbox. */
  if (sys_mbox_valid(&conn->recvmbox)) {
   14334:	e0bfff17 	ldw	r2,-4(fp)
   14338:	10800517 	ldw	r2,20(r2)
   1433c:	10002826 	beq	r2,zero,143e0 <netconn_drain+0xc0>
    while (sys_mbox_tryfetch(&conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
   14340:	00001906 	br	143a8 <netconn_drain+0x88>
#if LWIP_TCP
      if (conn->type == NETCONN_TCP) {
   14344:	e0bfff17 	ldw	r2,-4(fp)
   14348:	10800017 	ldw	r2,0(r2)
   1434c:	10800418 	cmpnei	r2,r2,16
   14350:	1000121e 	bne	r2,zero,1439c <netconn_drain+0x7c>
        if(mem != NULL) {
   14354:	e0bffe17 	ldw	r2,-8(fp)
   14358:	10001326 	beq	r2,zero,143a8 <netconn_drain+0x88>
          p = (struct pbuf*)mem;
   1435c:	e0bffe17 	ldw	r2,-8(fp)
   14360:	e0bffc15 	stw	r2,-16(fp)
          /* pcb might be set to NULL already by err_tcp() */
          if (conn->pcb.tcp != NULL) {
   14364:	e0bfff17 	ldw	r2,-4(fp)
   14368:	10800217 	ldw	r2,8(r2)
   1436c:	10000826 	beq	r2,zero,14390 <netconn_drain+0x70>
            tcp_recved(conn->pcb.tcp, p->tot_len);
   14370:	e0bfff17 	ldw	r2,-4(fp)
   14374:	10c00217 	ldw	r3,8(r2)
   14378:	e0bffc17 	ldw	r2,-16(fp)
   1437c:	1080020b 	ldhu	r2,8(r2)
   14380:	10bfffcc 	andi	r2,r2,65535
   14384:	1809883a 	mov	r4,r3
   14388:	100b883a 	mov	r5,r2
   1438c:	00256180 	call	25618 <tcp_recved>
          }
          pbuf_free(p);
   14390:	e13ffc17 	ldw	r4,-16(fp)
   14394:	00237600 	call	23760 <pbuf_free>
   14398:	00000306 	br	143a8 <netconn_drain+0x88>
        }
      } else
#endif /* LWIP_TCP */
      {
        netbuf_delete((struct netbuf *)mem);
   1439c:	e0bffe17 	ldw	r2,-8(fp)
   143a0:	1009883a 	mov	r4,r2
   143a4:	0015b180 	call	15b18 <netbuf_delete>

  /* This runs in tcpip_thread, so we don't need to lock against rx packets */

  /* Delete and drain the recvmbox. */
  if (sys_mbox_valid(&conn->recvmbox)) {
    while (sys_mbox_tryfetch(&conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
   143a8:	e0bfff17 	ldw	r2,-4(fp)
   143ac:	10c00504 	addi	r3,r2,20
   143b0:	e0bffe04 	addi	r2,fp,-8
   143b4:	1809883a 	mov	r4,r3
   143b8:	100b883a 	mov	r5,r2
   143bc:	001b8b00 	call	1b8b0 <sys_arch_mbox_tryfetch>
   143c0:	10bfffd8 	cmpnei	r2,r2,-1
   143c4:	103fdf1e 	bne	r2,zero,14344 <netconn_drain+0x24>
#endif /* LWIP_TCP */
      {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(&conn->recvmbox);
   143c8:	e0bfff17 	ldw	r2,-4(fp)
   143cc:	10800504 	addi	r2,r2,20
   143d0:	1009883a 	mov	r4,r2
   143d4:	001b6900 	call	1b690 <sys_mbox_free>
    sys_mbox_set_invalid(&conn->recvmbox);
   143d8:	e0bfff17 	ldw	r2,-4(fp)
   143dc:	10000515 	stw	zero,20(r2)
  }

  /* Delete and drain the acceptmbox. */
#if LWIP_TCP
  if (sys_mbox_valid(&conn->acceptmbox)) {
   143e0:	e0bfff17 	ldw	r2,-4(fp)
   143e4:	10800617 	ldw	r2,24(r2)
   143e8:	10002626 	beq	r2,zero,14484 <netconn_drain+0x164>
    while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
   143ec:	00001706 	br	1444c <netconn_drain+0x12c>
      struct netconn *newconn = (struct netconn *)mem;
   143f0:	e0bffe17 	ldw	r2,-8(fp)
   143f4:	e0bffd15 	stw	r2,-12(fp)
      /* Only tcp pcbs have an acceptmbox, so no need to check conn->type */
      /* pcb might be set to NULL already by err_tcp() */
      if (conn->pcb.tcp != NULL) {
   143f8:	e0bfff17 	ldw	r2,-4(fp)
   143fc:	10800217 	ldw	r2,8(r2)
   14400:	10000526 	beq	r2,zero,14418 <netconn_drain+0xf8>
        tcp_accepted(conn->pcb.tcp);
   14404:	e0bfff17 	ldw	r2,-4(fp)
   14408:	10800217 	ldw	r2,8(r2)
   1440c:	10c00843 	ldbu	r3,33(r2)
   14410:	18ffffc4 	addi	r3,r3,-1
   14414:	10c00845 	stb	r3,33(r2)
      }
      /* drain recvmbox */
      netconn_drain(newconn);
   14418:	e13ffd17 	ldw	r4,-12(fp)
   1441c:	00143200 	call	14320 <netconn_drain>
      if (newconn->pcb.tcp != NULL) {
   14420:	e0bffd17 	ldw	r2,-12(fp)
   14424:	10800217 	ldw	r2,8(r2)
   14428:	10000626 	beq	r2,zero,14444 <netconn_drain+0x124>
        tcp_abort(newconn->pcb.tcp);
   1442c:	e0bffd17 	ldw	r2,-12(fp)
   14430:	10800217 	ldw	r2,8(r2)
   14434:	1009883a 	mov	r4,r2
   14438:	002508c0 	call	2508c <tcp_abort>
        newconn->pcb.tcp = NULL;
   1443c:	e0bffd17 	ldw	r2,-12(fp)
   14440:	10000215 	stw	zero,8(r2)
      }
      netconn_free(newconn);
   14444:	e13ffd17 	ldw	r4,-12(fp)
   14448:	00142d40 	call	142d4 <netconn_free>
  }

  /* Delete and drain the acceptmbox. */
#if LWIP_TCP
  if (sys_mbox_valid(&conn->acceptmbox)) {
    while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
   1444c:	e0bfff17 	ldw	r2,-4(fp)
   14450:	10c00604 	addi	r3,r2,24
   14454:	e0bffe04 	addi	r2,fp,-8
   14458:	1809883a 	mov	r4,r3
   1445c:	100b883a 	mov	r5,r2
   14460:	001b8b00 	call	1b8b0 <sys_arch_mbox_tryfetch>
   14464:	10bfffd8 	cmpnei	r2,r2,-1
   14468:	103fe11e 	bne	r2,zero,143f0 <netconn_drain+0xd0>
        tcp_abort(newconn->pcb.tcp);
        newconn->pcb.tcp = NULL;
      }
      netconn_free(newconn);
    }
    sys_mbox_free(&conn->acceptmbox);
   1446c:	e0bfff17 	ldw	r2,-4(fp)
   14470:	10800604 	addi	r2,r2,24
   14474:	1009883a 	mov	r4,r2
   14478:	001b6900 	call	1b690 <sys_mbox_free>
    sys_mbox_set_invalid(&conn->acceptmbox);
   1447c:	e0bfff17 	ldw	r2,-4(fp)
   14480:	10000615 	stw	zero,24(r2)
  }
#endif /* LWIP_TCP */
}
   14484:	e037883a 	mov	sp,fp
   14488:	dfc00117 	ldw	ra,4(sp)
   1448c:	df000017 	ldw	fp,0(sp)
   14490:	dec00204 	addi	sp,sp,8
   14494:	f800283a 	ret

00014498 <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
   14498:	defffb04 	addi	sp,sp,-20
   1449c:	dfc00415 	stw	ra,16(sp)
   144a0:	df000315 	stw	fp,12(sp)
   144a4:	df000304 	addi	fp,sp,12
   144a8:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);

  shut = conn->current_msg->msg.sd.shut;
   144ac:	e0bfff17 	ldw	r2,-4(fp)
   144b0:	10800b17 	ldw	r2,44(r2)
   144b4:	10800203 	ldbu	r2,8(r2)
   144b8:	e0bffd45 	stb	r2,-11(fp)
  shut_rx = shut & NETCONN_SHUT_RD;
   144bc:	e0bffd43 	ldbu	r2,-11(fp)
   144c0:	1080004c 	andi	r2,r2,1
   144c4:	e0bffd85 	stb	r2,-10(fp)
  shut_tx = shut & NETCONN_SHUT_WR;
   144c8:	e0bffd43 	ldbu	r2,-11(fp)
   144cc:	1080008c 	andi	r2,r2,2
   144d0:	e0bffdc5 	stb	r2,-9(fp)
  /* shutting down both ends is the same as closing */
  close = shut == NETCONN_SHUT_RDWR;
   144d4:	e0bffd43 	ldbu	r2,-11(fp)
   144d8:	108000e0 	cmpeqi	r2,r2,3
   144dc:	e0bffe05 	stb	r2,-8(fp)

  /* Set back some callback pointers */
  if (close) {
   144e0:	e0bffe03 	ldbu	r2,-8(fp)
   144e4:	10000526 	beq	r2,zero,144fc <do_close_internal+0x64>
    tcp_arg(conn->pcb.tcp, NULL);
   144e8:	e0bfff17 	ldw	r2,-4(fp)
   144ec:	10800217 	ldw	r2,8(r2)
   144f0:	1009883a 	mov	r4,r2
   144f4:	000b883a 	mov	r5,zero
   144f8:	00269f80 	call	269f8 <tcp_arg>
  }
  if (conn->pcb.tcp->state == LISTEN) {
   144fc:	e0bfff17 	ldw	r2,-4(fp)
   14500:	10800217 	ldw	r2,8(r2)
   14504:	10800617 	ldw	r2,24(r2)
   14508:	10800058 	cmpnei	r2,r2,1
   1450c:	1000061e 	bne	r2,zero,14528 <do_close_internal+0x90>
    tcp_accept(conn->pcb.tcp, NULL);
   14510:	e0bfff17 	ldw	r2,-4(fp)
   14514:	10800217 	ldw	r2,8(r2)
   14518:	1009883a 	mov	r4,r2
   1451c:	000b883a 	mov	r5,zero
   14520:	0026ab80 	call	26ab8 <tcp_accept>
   14524:	00002006 	br	145a8 <do_close_internal+0x110>
  } else {
    /* some callbacks have to be reset if tcp_close is not successful */
    if (shut_rx) {
   14528:	e0bffd83 	ldbu	r2,-10(fp)
   1452c:	10000a26 	beq	r2,zero,14558 <do_close_internal+0xc0>
      tcp_recv(conn->pcb.tcp, NULL);
   14530:	e0bfff17 	ldw	r2,-4(fp)
   14534:	10800217 	ldw	r2,8(r2)
   14538:	1009883a 	mov	r4,r2
   1453c:	000b883a 	mov	r5,zero
   14540:	0026a280 	call	26a28 <tcp_recv>
      tcp_accept(conn->pcb.tcp, NULL);
   14544:	e0bfff17 	ldw	r2,-4(fp)
   14548:	10800217 	ldw	r2,8(r2)
   1454c:	1009883a 	mov	r4,r2
   14550:	000b883a 	mov	r5,zero
   14554:	0026ab80 	call	26ab8 <tcp_accept>
    }
    if (shut_tx) {
   14558:	e0bffdc3 	ldbu	r2,-9(fp)
   1455c:	10000526 	beq	r2,zero,14574 <do_close_internal+0xdc>
      tcp_sent(conn->pcb.tcp, NULL);
   14560:	e0bfff17 	ldw	r2,-4(fp)
   14564:	10800217 	ldw	r2,8(r2)
   14568:	1009883a 	mov	r4,r2
   1456c:	000b883a 	mov	r5,zero
   14570:	0026a580 	call	26a58 <tcp_sent>
    }
    if (close) {
   14574:	e0bffe03 	ldbu	r2,-8(fp)
   14578:	10000b26 	beq	r2,zero,145a8 <do_close_internal+0x110>
      tcp_poll(conn->pcb.tcp, NULL, 4);
   1457c:	e0bfff17 	ldw	r2,-4(fp)
   14580:	10800217 	ldw	r2,8(r2)
   14584:	1009883a 	mov	r4,r2
   14588:	000b883a 	mov	r5,zero
   1458c:	01800104 	movi	r6,4
   14590:	0026ae80 	call	26ae8 <tcp_poll>
      tcp_err(conn->pcb.tcp, NULL);
   14594:	e0bfff17 	ldw	r2,-4(fp)
   14598:	10800217 	ldw	r2,8(r2)
   1459c:	1009883a 	mov	r4,r2
   145a0:	000b883a 	mov	r5,zero
   145a4:	0026a880 	call	26a88 <tcp_err>
    }
  }
  /* Try to close the connection */
  if (close) {
   145a8:	e0bffe03 	ldbu	r2,-8(fp)
   145ac:	10000626 	beq	r2,zero,145c8 <do_close_internal+0x130>
    err = tcp_close(conn->pcb.tcp);
   145b0:	e0bfff17 	ldw	r2,-4(fp)
   145b4:	10800217 	ldw	r2,8(r2)
   145b8:	1009883a 	mov	r4,r2
   145bc:	0024de40 	call	24de4 <tcp_close>
   145c0:	e0bffd05 	stb	r2,-12(fp)
   145c4:	00000806 	br	145e8 <do_close_internal+0x150>
  } else {
    err = tcp_shutdown(conn->pcb.tcp, shut_rx, shut_tx);
   145c8:	e0bfff17 	ldw	r2,-4(fp)
   145cc:	11000217 	ldw	r4,8(r2)
   145d0:	e0fffd83 	ldbu	r3,-10(fp)
   145d4:	e0bffdc3 	ldbu	r2,-9(fp)
   145d8:	180b883a 	mov	r5,r3
   145dc:	100d883a 	mov	r6,r2
   145e0:	0024e400 	call	24e40 <tcp_shutdown>
   145e4:	e0bffd05 	stb	r2,-12(fp)
  }
  if (err == ERR_OK) {
   145e8:	e0bffd07 	ldb	r2,-12(fp)
   145ec:	10002f1e 	bne	r2,zero,146ac <do_close_internal+0x214>
    /* Closing succeeded */
    conn->current_msg->err = ERR_OK;
   145f0:	e0bfff17 	ldw	r2,-4(fp)
   145f4:	10800b17 	ldw	r2,44(r2)
   145f8:	10000105 	stb	zero,4(r2)
    conn->current_msg = NULL;
   145fc:	e0bfff17 	ldw	r2,-4(fp)
   14600:	10000b15 	stw	zero,44(r2)
    conn->state = NETCONN_NONE;
   14604:	e0bfff17 	ldw	r2,-4(fp)
   14608:	10000115 	stw	zero,4(r2)
    if (close) {
   1460c:	e0bffe03 	ldbu	r2,-8(fp)
   14610:	10000b26 	beq	r2,zero,14640 <do_close_internal+0x1a8>
      /* Set back some callback pointers as conn is going away */
      conn->pcb.tcp = NULL;
   14614:	e0bfff17 	ldw	r2,-4(fp)
   14618:	10000215 	stw	zero,8(r2)
      /* Trigger select() in socket layer. Make sure everybody notices activity
       on the connection, error first! */
      API_EVENT(conn, NETCONN_EVT_ERROR, 0);
   1461c:	e0bfff17 	ldw	r2,-4(fp)
   14620:	10800c17 	ldw	r2,48(r2)
   14624:	10000626 	beq	r2,zero,14640 <do_close_internal+0x1a8>
   14628:	e0bfff17 	ldw	r2,-4(fp)
   1462c:	10800c17 	ldw	r2,48(r2)
   14630:	e13fff17 	ldw	r4,-4(fp)
   14634:	01400104 	movi	r5,4
   14638:	000d883a 	mov	r6,zero
   1463c:	103ee83a 	callr	r2
    }
    if (shut_rx) {
   14640:	e0bffd83 	ldbu	r2,-10(fp)
   14644:	10000926 	beq	r2,zero,1466c <do_close_internal+0x1d4>
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
   14648:	e0bfff17 	ldw	r2,-4(fp)
   1464c:	10800c17 	ldw	r2,48(r2)
   14650:	10000626 	beq	r2,zero,1466c <do_close_internal+0x1d4>
   14654:	e0bfff17 	ldw	r2,-4(fp)
   14658:	10800c17 	ldw	r2,48(r2)
   1465c:	e13fff17 	ldw	r4,-4(fp)
   14660:	000b883a 	mov	r5,zero
   14664:	000d883a 	mov	r6,zero
   14668:	103ee83a 	callr	r2
    }
    if (shut_tx) {
   1466c:	e0bffdc3 	ldbu	r2,-9(fp)
   14670:	10000926 	beq	r2,zero,14698 <do_close_internal+0x200>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
   14674:	e0bfff17 	ldw	r2,-4(fp)
   14678:	10800c17 	ldw	r2,48(r2)
   1467c:	10000626 	beq	r2,zero,14698 <do_close_internal+0x200>
   14680:	e0bfff17 	ldw	r2,-4(fp)
   14684:	10800c17 	ldw	r2,48(r2)
   14688:	e13fff17 	ldw	r4,-4(fp)
   1468c:	01400084 	movi	r5,2
   14690:	000d883a 	mov	r6,zero
   14694:	103ee83a 	callr	r2
    }
    /* wake up the application task */
    sys_sem_signal(&conn->op_completed);
   14698:	e0bfff17 	ldw	r2,-4(fp)
   1469c:	10800404 	addi	r2,r2,16
   146a0:	1009883a 	mov	r4,r2
   146a4:	001b2f00 	call	1b2f0 <sys_sem_signal>
   146a8:	00001806 	br	1470c <do_close_internal+0x274>
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
    tcp_sent(conn->pcb.tcp, sent_tcp);
   146ac:	e0bfff17 	ldw	r2,-4(fp)
   146b0:	10800217 	ldw	r2,8(r2)
   146b4:	1009883a 	mov	r4,r2
   146b8:	01400074 	movhi	r5,1
   146bc:	294ec504 	addi	r5,r5,15124
   146c0:	0026a580 	call	26a58 <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
   146c4:	e0bfff17 	ldw	r2,-4(fp)
   146c8:	10800217 	ldw	r2,8(r2)
   146cc:	1009883a 	mov	r4,r2
   146d0:	01400074 	movhi	r5,1
   146d4:	294e8604 	addi	r5,r5,14872
   146d8:	01800104 	movi	r6,4
   146dc:	0026ae80 	call	26ae8 <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
   146e0:	e0bfff17 	ldw	r2,-4(fp)
   146e4:	10800217 	ldw	r2,8(r2)
   146e8:	1009883a 	mov	r4,r2
   146ec:	01400074 	movhi	r5,1
   146f0:	294f0404 	addi	r5,r5,15376
   146f4:	0026a880 	call	26a88 <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
   146f8:	e0bfff17 	ldw	r2,-4(fp)
   146fc:	10800217 	ldw	r2,8(r2)
   14700:	1009883a 	mov	r4,r2
   14704:	e17fff17 	ldw	r5,-4(fp)
   14708:	00269f80 	call	269f8 <tcp_arg>
    /* don't restore recv callback: we don't want to receive any more data */
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
   1470c:	e037883a 	mov	sp,fp
   14710:	dfc00117 	ldw	ra,4(sp)
   14714:	df000017 	ldw	fp,0(sp)
   14718:	dec00204 	addi	sp,sp,8
   1471c:	f800283a 	ret

00014720 <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
   14720:	defffd04 	addi	sp,sp,-12
   14724:	dfc00215 	stw	ra,8(sp)
   14728:	df000115 	stw	fp,4(sp)
   1472c:	df000104 	addi	fp,sp,4
   14730:	e13fff15 	stw	r4,-4(fp)
  /* @todo TCP: abort running write/connect? */
 if ((msg->conn->state != NETCONN_NONE) &&
   14734:	e0bfff17 	ldw	r2,-4(fp)
   14738:	10800017 	ldw	r2,0(r2)
   1473c:	10800117 	ldw	r2,4(r2)
   14740:	10000e26 	beq	r2,zero,1477c <do_delconn+0x5c>
     (msg->conn->state != NETCONN_LISTEN) &&
   14744:	e0bfff17 	ldw	r2,-4(fp)
   14748:	10800017 	ldw	r2,0(r2)
   1474c:	10800117 	ldw	r2,4(r2)
 */
void
do_delconn(struct api_msg_msg *msg)
{
  /* @todo TCP: abort running write/connect? */
 if ((msg->conn->state != NETCONN_NONE) &&
   14750:	108000a0 	cmpeqi	r2,r2,2
   14754:	1000091e 	bne	r2,zero,1477c <do_delconn+0x5c>
     (msg->conn->state != NETCONN_LISTEN) &&
     (msg->conn->state != NETCONN_CONNECT)) {
   14758:	e0bfff17 	ldw	r2,-4(fp)
   1475c:	10800017 	ldw	r2,0(r2)
   14760:	10800117 	ldw	r2,4(r2)
void
do_delconn(struct api_msg_msg *msg)
{
  /* @todo TCP: abort running write/connect? */
 if ((msg->conn->state != NETCONN_NONE) &&
     (msg->conn->state != NETCONN_LISTEN) &&
   14764:	108000e0 	cmpeqi	r2,r2,3
   14768:	1000041e 	bne	r2,zero,1477c <do_delconn+0x5c>
     (msg->conn->state != NETCONN_CONNECT)) {
    /* this only happens for TCP netconns */
    LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
    msg->err = ERR_INPROGRESS;
   1476c:	e0bfff17 	ldw	r2,-4(fp)
   14770:	00fffec4 	movi	r3,-5
   14774:	10c00105 	stb	r3,4(r2)
   14778:	00005106 	br	148c0 <do_delconn+0x1a0>
  } else {
    LWIP_ASSERT("blocking connect in progress",
      (msg->conn->state != NETCONN_CONNECT) || IN_NONBLOCKING_CONNECT(msg->conn));
    /* Drain and delete mboxes */
    netconn_drain(msg->conn);
   1477c:	e0bfff17 	ldw	r2,-4(fp)
   14780:	10800017 	ldw	r2,0(r2)
   14784:	1009883a 	mov	r4,r2
   14788:	00143200 	call	14320 <netconn_drain>

    if (msg->conn->pcb.tcp != NULL) {
   1478c:	e0bfff17 	ldw	r2,-4(fp)
   14790:	10800017 	ldw	r2,0(r2)
   14794:	10800217 	ldw	r2,8(r2)
   14798:	10002f26 	beq	r2,zero,14858 <do_delconn+0x138>

      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
   1479c:	e0bfff17 	ldw	r2,-4(fp)
   147a0:	10800017 	ldw	r2,0(r2)
   147a4:	10800017 	ldw	r2,0(r2)
   147a8:	10803c0c 	andi	r2,r2,240
   147ac:	10c00820 	cmpeqi	r3,r2,32
   147b0:	18000b1e 	bne	r3,zero,147e0 <do_delconn+0xc0>
   147b4:	10c01020 	cmpeqi	r3,r2,64
   147b8:	1800031e 	bne	r3,zero,147c8 <do_delconn+0xa8>
   147bc:	10800420 	cmpeqi	r2,r2,16
   147c0:	1000111e 	bne	r2,zero,14808 <do_delconn+0xe8>
   147c4:	00002006 	br	14848 <do_delconn+0x128>
#if LWIP_RAW
      case NETCONN_RAW:
        raw_remove(msg->conn->pcb.raw);
   147c8:	e0bfff17 	ldw	r2,-4(fp)
   147cc:	10800017 	ldw	r2,0(r2)
   147d0:	10800217 	ldw	r2,8(r2)
   147d4:	1009883a 	mov	r4,r2
   147d8:	00248f00 	call	248f0 <raw_remove>
        break;
   147dc:	00001b06 	br	1484c <do_delconn+0x12c>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->pcb.udp->recv_arg = NULL;
   147e0:	e0bfff17 	ldw	r2,-4(fp)
   147e4:	10800017 	ldw	r2,0(r2)
   147e8:	10800217 	ldw	r2,8(r2)
   147ec:	10000715 	stw	zero,28(r2)
        udp_remove(msg->conn->pcb.udp);
   147f0:	e0bfff17 	ldw	r2,-4(fp)
   147f4:	10800017 	ldw	r2,0(r2)
   147f8:	10800217 	ldw	r2,8(r2)
   147fc:	1009883a 	mov	r4,r2
   14800:	002fbdc0 	call	2fbdc <udp_remove>
        break;
   14804:	00001106 	br	1484c <do_delconn+0x12c>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
          msg->conn->write_offset == 0);
        msg->conn->state = NETCONN_CLOSE;
   14808:	e0bfff17 	ldw	r2,-4(fp)
   1480c:	10800017 	ldw	r2,0(r2)
   14810:	00c00104 	movi	r3,4
   14814:	10c00115 	stw	r3,4(r2)
        msg->msg.sd.shut = NETCONN_SHUT_RDWR;
   14818:	e0bfff17 	ldw	r2,-4(fp)
   1481c:	00c000c4 	movi	r3,3
   14820:	10c00205 	stb	r3,8(r2)
        msg->conn->current_msg = msg;
   14824:	e0bfff17 	ldw	r2,-4(fp)
   14828:	10800017 	ldw	r2,0(r2)
   1482c:	e0ffff17 	ldw	r3,-4(fp)
   14830:	10c00b15 	stw	r3,44(r2)
        do_close_internal(msg->conn);
   14834:	e0bfff17 	ldw	r2,-4(fp)
   14838:	10800017 	ldw	r2,0(r2)
   1483c:	1009883a 	mov	r4,r2
   14840:	00144980 	call	14498 <do_close_internal>
        /* API_EVENT is called inside do_close_internal, before releasing
           the application thread, so we can return at this point! */
        return;
   14844:	00002706 	br	148e4 <do_delconn+0x1c4>
#endif /* LWIP_TCP */
      default:
        break;
   14848:	0001883a 	nop
      }
      msg->conn->pcb.tcp = NULL;
   1484c:	e0bfff17 	ldw	r2,-4(fp)
   14850:	10800017 	ldw	r2,0(r2)
   14854:	10000215 	stw	zero,8(r2)
    }
    /* tcp netconns don't come here! */

    /* @todo: this lets select make the socket readable and writable,
       which is wrong! errfd instead? */
    API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
   14858:	e0bfff17 	ldw	r2,-4(fp)
   1485c:	10800017 	ldw	r2,0(r2)
   14860:	10800c17 	ldw	r2,48(r2)
   14864:	10000926 	beq	r2,zero,1488c <do_delconn+0x16c>
   14868:	e0bfff17 	ldw	r2,-4(fp)
   1486c:	10800017 	ldw	r2,0(r2)
   14870:	10c00c17 	ldw	r3,48(r2)
   14874:	e0bfff17 	ldw	r2,-4(fp)
   14878:	10800017 	ldw	r2,0(r2)
   1487c:	1009883a 	mov	r4,r2
   14880:	000b883a 	mov	r5,zero
   14884:	000d883a 	mov	r6,zero
   14888:	183ee83a 	callr	r3
    API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
   1488c:	e0bfff17 	ldw	r2,-4(fp)
   14890:	10800017 	ldw	r2,0(r2)
   14894:	10800c17 	ldw	r2,48(r2)
   14898:	10000926 	beq	r2,zero,148c0 <do_delconn+0x1a0>
   1489c:	e0bfff17 	ldw	r2,-4(fp)
   148a0:	10800017 	ldw	r2,0(r2)
   148a4:	10c00c17 	ldw	r3,48(r2)
   148a8:	e0bfff17 	ldw	r2,-4(fp)
   148ac:	10800017 	ldw	r2,0(r2)
   148b0:	1009883a 	mov	r4,r2
   148b4:	01400084 	movi	r5,2
   148b8:	000d883a 	mov	r6,zero
   148bc:	183ee83a 	callr	r3
  }
  if (sys_sem_valid(&msg->conn->op_completed)) {
   148c0:	e0bfff17 	ldw	r2,-4(fp)
   148c4:	10800017 	ldw	r2,0(r2)
   148c8:	10800417 	ldw	r2,16(r2)
   148cc:	10000526 	beq	r2,zero,148e4 <do_delconn+0x1c4>
    sys_sem_signal(&msg->conn->op_completed);
   148d0:	e0bfff17 	ldw	r2,-4(fp)
   148d4:	10800017 	ldw	r2,0(r2)
   148d8:	10800404 	addi	r2,r2,16
   148dc:	1009883a 	mov	r4,r2
   148e0:	001b2f00 	call	1b2f0 <sys_sem_signal>
  }
}
   148e4:	e037883a 	mov	sp,fp
   148e8:	dfc00117 	ldw	ra,4(sp)
   148ec:	df000017 	ldw	fp,0(sp)
   148f0:	dec00204 	addi	sp,sp,8
   148f4:	f800283a 	ret

000148f8 <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
   148f8:	defffd04 	addi	sp,sp,-12
   148fc:	dfc00215 	stw	ra,8(sp)
   14900:	df000115 	stw	fp,4(sp)
   14904:	df000104 	addi	fp,sp,4
   14908:	e13fff15 	stw	r4,-4(fp)
  if (ERR_IS_FATAL(msg->conn->last_err)) {
   1490c:	e0bfff17 	ldw	r2,-4(fp)
   14910:	10800017 	ldw	r2,0(r2)
   14914:	10800303 	ldbu	r2,12(r2)
   14918:	10803fcc 	andi	r2,r2,255
   1491c:	1080201c 	xori	r2,r2,128
   14920:	10bfe004 	addi	r2,r2,-128
   14924:	10bffdc8 	cmpgei	r2,r2,-9
   14928:	1000061e 	bne	r2,zero,14944 <do_bind+0x4c>
    msg->err = msg->conn->last_err;
   1492c:	e0bfff17 	ldw	r2,-4(fp)
   14930:	10800017 	ldw	r2,0(r2)
   14934:	10c00303 	ldbu	r3,12(r2)
   14938:	e0bfff17 	ldw	r2,-4(fp)
   1493c:	10c00105 	stb	r3,4(r2)
   14940:	00003a06 	br	14a2c <do_bind+0x134>
  } else {
    msg->err = ERR_VAL;
   14944:	e0bfff17 	ldw	r2,-4(fp)
   14948:	00fffe84 	movi	r3,-6
   1494c:	10c00105 	stb	r3,4(r2)
    if (msg->conn->pcb.tcp != NULL) {
   14950:	e0bfff17 	ldw	r2,-4(fp)
   14954:	10800017 	ldw	r2,0(r2)
   14958:	10800217 	ldw	r2,8(r2)
   1495c:	10003326 	beq	r2,zero,14a2c <do_bind+0x134>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
   14960:	e0bfff17 	ldw	r2,-4(fp)
   14964:	10800017 	ldw	r2,0(r2)
   14968:	10800017 	ldw	r2,0(r2)
   1496c:	10803c0c 	andi	r2,r2,240
   14970:	10c00820 	cmpeqi	r3,r2,32
   14974:	1800101e 	bne	r3,zero,149b8 <do_bind+0xc0>
   14978:	10c01020 	cmpeqi	r3,r2,64
   1497c:	1800031e 	bne	r3,zero,1498c <do_bind+0x94>
   14980:	10800420 	cmpeqi	r2,r2,16
   14984:	10001a1e 	bne	r2,zero,149f0 <do_bind+0xf8>
   14988:	00002706 	br	14a28 <do_bind+0x130>
#if LWIP_RAW
      case NETCONN_RAW:
        msg->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
   1498c:	e0bfff17 	ldw	r2,-4(fp)
   14990:	10800017 	ldw	r2,0(r2)
   14994:	10c00217 	ldw	r3,8(r2)
   14998:	e0bfff17 	ldw	r2,-4(fp)
   1499c:	10800217 	ldw	r2,8(r2)
   149a0:	1809883a 	mov	r4,r3
   149a4:	100b883a 	mov	r5,r2
   149a8:	00246540 	call	24654 <raw_bind>
   149ac:	e0ffff17 	ldw	r3,-4(fp)
   149b0:	18800105 	stb	r2,4(r3)
        break;
   149b4:	00001d06 	br	14a2c <do_bind+0x134>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
   149b8:	e0bfff17 	ldw	r2,-4(fp)
   149bc:	10800017 	ldw	r2,0(r2)
   149c0:	11000217 	ldw	r4,8(r2)
   149c4:	e0bfff17 	ldw	r2,-4(fp)
   149c8:	10c00217 	ldw	r3,8(r2)
   149cc:	e0bfff17 	ldw	r2,-4(fp)
   149d0:	1080030b 	ldhu	r2,12(r2)
   149d4:	10bfffcc 	andi	r2,r2,65535
   149d8:	180b883a 	mov	r5,r3
   149dc:	100d883a 	mov	r6,r2
   149e0:	002f8ec0 	call	2f8ec <udp_bind>
   149e4:	e0ffff17 	ldw	r3,-4(fp)
   149e8:	18800105 	stb	r2,4(r3)
        break;
   149ec:	00000f06 	br	14a2c <do_bind+0x134>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
   149f0:	e0bfff17 	ldw	r2,-4(fp)
   149f4:	10800017 	ldw	r2,0(r2)
   149f8:	11000217 	ldw	r4,8(r2)
   149fc:	e0bfff17 	ldw	r2,-4(fp)
   14a00:	10c00217 	ldw	r3,8(r2)
   14a04:	e0bfff17 	ldw	r2,-4(fp)
   14a08:	1080030b 	ldhu	r2,12(r2)
   14a0c:	10bfffcc 	andi	r2,r2,65535
   14a10:	180b883a 	mov	r5,r3
   14a14:	100d883a 	mov	r6,r2
   14a18:	00250c00 	call	250c0 <tcp_bind>
   14a1c:	e0ffff17 	ldw	r3,-4(fp)
   14a20:	18800105 	stb	r2,4(r3)
        break;
   14a24:	00000106 	br	14a2c <do_bind+0x134>
#endif /* LWIP_TCP */
      default:
        break;
   14a28:	0001883a 	nop
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
   14a2c:	e0bfff17 	ldw	r2,-4(fp)
   14a30:	10800017 	ldw	r2,0(r2)
   14a34:	10800404 	addi	r2,r2,16
   14a38:	1009883a 	mov	r4,r2
   14a3c:	001b2f00 	call	1b2f0 <sys_sem_signal>
}
   14a40:	e037883a 	mov	sp,fp
   14a44:	dfc00117 	ldw	ra,4(sp)
   14a48:	df000017 	ldw	fp,0(sp)
   14a4c:	dec00204 	addi	sp,sp,8
   14a50:	f800283a 	ret

00014a54 <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
   14a54:	defff904 	addi	sp,sp,-28
   14a58:	dfc00615 	stw	ra,24(sp)
   14a5c:	df000515 	stw	fp,20(sp)
   14a60:	df000504 	addi	fp,sp,20
   14a64:	e13ffd15 	stw	r4,-12(fp)
   14a68:	e17ffe15 	stw	r5,-8(fp)
   14a6c:	3005883a 	mov	r2,r6
   14a70:	e0bfff05 	stb	r2,-4(fp)
  struct netconn *conn;
  int was_blocking;

  LWIP_UNUSED_ARG(pcb);

  conn = (struct netconn *)arg;
   14a74:	e0bffd17 	ldw	r2,-12(fp)
   14a78:	e0bffb15 	stw	r2,-20(fp)

  if (conn == NULL) {
   14a7c:	e0bffb17 	ldw	r2,-20(fp)
   14a80:	1000021e 	bne	r2,zero,14a8c <do_connected+0x38>
    return ERR_VAL;
   14a84:	00bffe84 	movi	r2,-6
   14a88:	00004206 	br	14b94 <do_connected+0x140>

  LWIP_ASSERT("conn->state == NETCONN_CONNECT", conn->state == NETCONN_CONNECT);
  LWIP_ASSERT("(conn->current_msg != NULL) || conn->in_non_blocking_connect",
    (conn->current_msg != NULL) || IN_NONBLOCKING_CONNECT(conn));

  if (conn->current_msg != NULL) {
   14a8c:	e0bffb17 	ldw	r2,-20(fp)
   14a90:	10800b17 	ldw	r2,44(r2)
   14a94:	10000426 	beq	r2,zero,14aa8 <do_connected+0x54>
    conn->current_msg->err = err;
   14a98:	e0bffb17 	ldw	r2,-20(fp)
   14a9c:	10800b17 	ldw	r2,44(r2)
   14aa0:	e0ffff03 	ldbu	r3,-4(fp)
   14aa4:	10c00105 	stb	r3,4(r2)
  }
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
   14aa8:	e0bffb17 	ldw	r2,-20(fp)
   14aac:	10800017 	ldw	r2,0(r2)
   14ab0:	10800418 	cmpnei	r2,r2,16
   14ab4:	1000041e 	bne	r2,zero,14ac8 <do_connected+0x74>
   14ab8:	e0bfff07 	ldb	r2,-4(fp)
   14abc:	1000021e 	bne	r2,zero,14ac8 <do_connected+0x74>
    setup_tcp(conn);
   14ac0:	e13ffb17 	ldw	r4,-20(fp)
   14ac4:	0013dc00 	call	13dc0 <setup_tcp>
  }
  was_blocking = !IN_NONBLOCKING_CONNECT(conn);
   14ac8:	e0bffb17 	ldw	r2,-20(fp)
   14acc:	10800903 	ldbu	r2,36(r2)
   14ad0:	10803fcc 	andi	r2,r2,255
   14ad4:	1080010c 	andi	r2,r2,4
   14ad8:	1005003a 	cmpeq	r2,r2,zero
   14adc:	10803fcc 	andi	r2,r2,255
   14ae0:	e0bffc15 	stw	r2,-16(fp)
  SET_NONBLOCKING_CONNECT(conn, 0);
   14ae4:	e0bffb17 	ldw	r2,-20(fp)
   14ae8:	10c00903 	ldbu	r3,36(r2)
   14aec:	00bffec4 	movi	r2,-5
   14af0:	1884703a 	and	r2,r3,r2
   14af4:	1007883a 	mov	r3,r2
   14af8:	e0bffb17 	ldw	r2,-20(fp)
   14afc:	10c00905 	stb	r3,36(r2)
  conn->current_msg = NULL;
   14b00:	e0bffb17 	ldw	r2,-20(fp)
   14b04:	10000b15 	stw	zero,44(r2)
  conn->state = NETCONN_NONE;
   14b08:	e0bffb17 	ldw	r2,-20(fp)
   14b0c:	10000115 	stw	zero,4(r2)
  if (!was_blocking) {
   14b10:	e0bffc17 	ldw	r2,-16(fp)
   14b14:	10000f1e 	bne	r2,zero,14b54 <do_connected+0x100>
    NETCONN_SET_SAFE_ERR(conn, ERR_OK);
   14b18:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   14b1c:	10000126 	beq	r2,zero,14b24 <do_connected+0xd0>
   14b20:	00110d00 	call	110d0 <vTaskEnterCritical>
   14b24:	e0bffb17 	ldw	r2,-20(fp)
   14b28:	10800303 	ldbu	r2,12(r2)
   14b2c:	10803fcc 	andi	r2,r2,255
   14b30:	1080201c 	xori	r2,r2,128
   14b34:	10bfe004 	addi	r2,r2,-128
   14b38:	10bffdd0 	cmplti	r2,r2,-9
   14b3c:	1000021e 	bne	r2,zero,14b48 <do_connected+0xf4>
   14b40:	e0bffb17 	ldw	r2,-20(fp)
   14b44:	10000305 	stb	zero,12(r2)
   14b48:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   14b4c:	10000126 	beq	r2,zero,14b54 <do_connected+0x100>
   14b50:	00111100 	call	11110 <vTaskExitCritical>
  }
  API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
   14b54:	e0bffb17 	ldw	r2,-20(fp)
   14b58:	10800c17 	ldw	r2,48(r2)
   14b5c:	10000626 	beq	r2,zero,14b78 <do_connected+0x124>
   14b60:	e0bffb17 	ldw	r2,-20(fp)
   14b64:	10800c17 	ldw	r2,48(r2)
   14b68:	e13ffb17 	ldw	r4,-20(fp)
   14b6c:	01400084 	movi	r5,2
   14b70:	000d883a 	mov	r6,zero
   14b74:	103ee83a 	callr	r2

  if (was_blocking) {
   14b78:	e0bffc17 	ldw	r2,-16(fp)
   14b7c:	10000426 	beq	r2,zero,14b90 <do_connected+0x13c>
    sys_sem_signal(&conn->op_completed);
   14b80:	e0bffb17 	ldw	r2,-20(fp)
   14b84:	10800404 	addi	r2,r2,16
   14b88:	1009883a 	mov	r4,r2
   14b8c:	001b2f00 	call	1b2f0 <sys_sem_signal>
  }
  return ERR_OK;
   14b90:	0005883a 	mov	r2,zero
}
   14b94:	e037883a 	mov	sp,fp
   14b98:	dfc00117 	ldw	ra,4(sp)
   14b9c:	df000017 	ldw	fp,0(sp)
   14ba0:	dec00204 	addi	sp,sp,8
   14ba4:	f800283a 	ret

00014ba8 <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
   14ba8:	defffc04 	addi	sp,sp,-16
   14bac:	dfc00315 	stw	ra,12(sp)
   14bb0:	df000215 	stw	fp,8(sp)
   14bb4:	df000204 	addi	fp,sp,8
   14bb8:	e13fff15 	stw	r4,-4(fp)
  if (msg->conn->pcb.tcp == NULL) {
   14bbc:	e0bfff17 	ldw	r2,-4(fp)
   14bc0:	10800017 	ldw	r2,0(r2)
   14bc4:	10800217 	ldw	r2,8(r2)
   14bc8:	1000041e 	bne	r2,zero,14bdc <do_connect+0x34>
    /* This may happen when calling netconn_connect() a second time */
    msg->err = ERR_CLSD;
   14bcc:	e0bfff17 	ldw	r2,-4(fp)
   14bd0:	00fffd04 	movi	r3,-12
   14bd4:	10c00105 	stb	r3,4(r2)
   14bd8:	00007706 	br	14db8 <do_connect+0x210>
  } else {
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
   14bdc:	e0bfff17 	ldw	r2,-4(fp)
   14be0:	10800017 	ldw	r2,0(r2)
   14be4:	10800017 	ldw	r2,0(r2)
   14be8:	10803c0c 	andi	r2,r2,240
   14bec:	10c00820 	cmpeqi	r3,r2,32
   14bf0:	1800101e 	bne	r3,zero,14c34 <do_connect+0x8c>
   14bf4:	10c01020 	cmpeqi	r3,r2,64
   14bf8:	1800031e 	bne	r3,zero,14c08 <do_connect+0x60>
   14bfc:	10800420 	cmpeqi	r2,r2,16
   14c00:	10001a1e 	bne	r2,zero,14c6c <do_connect+0xc4>
   14c04:	00006206 	br	14d90 <do_connect+0x1e8>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
   14c08:	e0bfff17 	ldw	r2,-4(fp)
   14c0c:	10800017 	ldw	r2,0(r2)
   14c10:	10c00217 	ldw	r3,8(r2)
   14c14:	e0bfff17 	ldw	r2,-4(fp)
   14c18:	10800217 	ldw	r2,8(r2)
   14c1c:	1809883a 	mov	r4,r3
   14c20:	100b883a 	mov	r5,r2
   14c24:	002469c0 	call	2469c <raw_connect>
   14c28:	e0ffff17 	ldw	r3,-4(fp)
   14c2c:	18800105 	stb	r2,4(r3)
    break;
   14c30:	00006106 	br	14db8 <do_connect+0x210>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
   14c34:	e0bfff17 	ldw	r2,-4(fp)
   14c38:	10800017 	ldw	r2,0(r2)
   14c3c:	11000217 	ldw	r4,8(r2)
   14c40:	e0bfff17 	ldw	r2,-4(fp)
   14c44:	10c00217 	ldw	r3,8(r2)
   14c48:	e0bfff17 	ldw	r2,-4(fp)
   14c4c:	1080030b 	ldhu	r2,12(r2)
   14c50:	10bfffcc 	andi	r2,r2,65535
   14c54:	180b883a 	mov	r5,r3
   14c58:	100d883a 	mov	r6,r2
   14c5c:	002fa480 	call	2fa48 <udp_connect>
   14c60:	e0ffff17 	ldw	r3,-4(fp)
   14c64:	18800105 	stb	r2,4(r3)
    break;
   14c68:	00005306 	br	14db8 <do_connect+0x210>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    /* Prevent connect while doing any other action. */
    if (msg->conn->state != NETCONN_NONE) {
   14c6c:	e0bfff17 	ldw	r2,-4(fp)
   14c70:	10800017 	ldw	r2,0(r2)
   14c74:	10800117 	ldw	r2,4(r2)
   14c78:	10000426 	beq	r2,zero,14c8c <do_connect+0xe4>
      msg->err = ERR_ISCONN;
   14c7c:	e0bfff17 	ldw	r2,-4(fp)
   14c80:	00fffdc4 	movi	r3,-9
   14c84:	10c00105 	stb	r3,4(r2)
          * when the connection is established! */
          return;
        }
      }
    }
    break;
   14c88:	00004a06 	br	14db4 <do_connect+0x20c>
  case NETCONN_TCP:
    /* Prevent connect while doing any other action. */
    if (msg->conn->state != NETCONN_NONE) {
      msg->err = ERR_ISCONN;
    } else {
      setup_tcp(msg->conn);
   14c8c:	e0bfff17 	ldw	r2,-4(fp)
   14c90:	10800017 	ldw	r2,0(r2)
   14c94:	1009883a 	mov	r4,r2
   14c98:	0013dc00 	call	13dc0 <setup_tcp>
      msg->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr,
   14c9c:	e0bfff17 	ldw	r2,-4(fp)
   14ca0:	10800017 	ldw	r2,0(r2)
   14ca4:	11000217 	ldw	r4,8(r2)
   14ca8:	e0bfff17 	ldw	r2,-4(fp)
   14cac:	10c00217 	ldw	r3,8(r2)
        msg->msg.bc.port, do_connected);
   14cb0:	e0bfff17 	ldw	r2,-4(fp)
   14cb4:	1080030b 	ldhu	r2,12(r2)
    /* Prevent connect while doing any other action. */
    if (msg->conn->state != NETCONN_NONE) {
      msg->err = ERR_ISCONN;
    } else {
      setup_tcp(msg->conn);
      msg->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr,
   14cb8:	10bfffcc 	andi	r2,r2,65535
   14cbc:	180b883a 	mov	r5,r3
   14cc0:	100d883a 	mov	r6,r2
   14cc4:	01c00074 	movhi	r7,1
   14cc8:	39d29504 	addi	r7,r7,19028
   14ccc:	00257a40 	call	257a4 <tcp_connect>
   14cd0:	e0ffff17 	ldw	r3,-4(fp)
   14cd4:	18800105 	stb	r2,4(r3)
        msg->msg.bc.port, do_connected);
      if (msg->err == ERR_OK) {
   14cd8:	e0bfff17 	ldw	r2,-4(fp)
   14cdc:	10800103 	ldbu	r2,4(r2)
   14ce0:	10803fcc 	andi	r2,r2,255
   14ce4:	1080201c 	xori	r2,r2,128
   14ce8:	10bfe004 	addi	r2,r2,-128
   14cec:	1000311e 	bne	r2,zero,14db4 <do_connect+0x20c>
        u8_t non_blocking = netconn_is_nonblocking(msg->conn);
   14cf0:	e0bfff17 	ldw	r2,-4(fp)
   14cf4:	10800017 	ldw	r2,0(r2)
   14cf8:	10800903 	ldbu	r2,36(r2)
   14cfc:	10803fcc 	andi	r2,r2,255
   14d00:	1080008c 	andi	r2,r2,2
   14d04:	1004c03a 	cmpne	r2,r2,zero
   14d08:	e0bffe05 	stb	r2,-8(fp)
        msg->conn->state = NETCONN_CONNECT;
   14d0c:	e0bfff17 	ldw	r2,-4(fp)
   14d10:	10800017 	ldw	r2,0(r2)
   14d14:	00c000c4 	movi	r3,3
   14d18:	10c00115 	stw	r3,4(r2)
        SET_NONBLOCKING_CONNECT(msg->conn, non_blocking);
   14d1c:	e0bffe03 	ldbu	r2,-8(fp)
   14d20:	10000826 	beq	r2,zero,14d44 <do_connect+0x19c>
   14d24:	e0bfff17 	ldw	r2,-4(fp)
   14d28:	10800017 	ldw	r2,0(r2)
   14d2c:	e0ffff17 	ldw	r3,-4(fp)
   14d30:	18c00017 	ldw	r3,0(r3)
   14d34:	18c00903 	ldbu	r3,36(r3)
   14d38:	18c00114 	ori	r3,r3,4
   14d3c:	10c00905 	stb	r3,36(r2)
   14d40:	00000806 	br	14d64 <do_connect+0x1bc>
   14d44:	e0bfff17 	ldw	r2,-4(fp)
   14d48:	10800017 	ldw	r2,0(r2)
   14d4c:	e0ffff17 	ldw	r3,-4(fp)
   14d50:	18c00017 	ldw	r3,0(r3)
   14d54:	19000903 	ldbu	r4,36(r3)
   14d58:	00fffec4 	movi	r3,-5
   14d5c:	20c6703a 	and	r3,r4,r3
   14d60:	10c00905 	stb	r3,36(r2)
        if (non_blocking) {
   14d64:	e0bffe03 	ldbu	r2,-8(fp)
   14d68:	10000426 	beq	r2,zero,14d7c <do_connect+0x1d4>
          msg->err = ERR_INPROGRESS;
   14d6c:	e0bfff17 	ldw	r2,-4(fp)
   14d70:	00fffec4 	movi	r3,-5
   14d74:	10c00105 	stb	r3,4(r2)
          * when the connection is established! */
          return;
        }
      }
    }
    break;
   14d78:	00000e06 	br	14db4 <do_connect+0x20c>
        msg->conn->state = NETCONN_CONNECT;
        SET_NONBLOCKING_CONNECT(msg->conn, non_blocking);
        if (non_blocking) {
          msg->err = ERR_INPROGRESS;
        } else {
          msg->conn->current_msg = msg;
   14d7c:	e0bfff17 	ldw	r2,-4(fp)
   14d80:	10800017 	ldw	r2,0(r2)
   14d84:	e0ffff17 	ldw	r3,-4(fp)
   14d88:	10c00b15 	stw	r3,44(r2)
          /* sys_sem_signal() is called from do_connected (or err_tcp()),
          * when the connection is established! */
          return;
   14d8c:	00000f06 	br	14dcc <do_connect+0x224>
      }
    }
    break;
#endif /* LWIP_TCP */
  default:
    LWIP_ERROR("Invalid netconn type", 0, do{ msg->err = ERR_VAL; }while(0));
   14d90:	01000134 	movhi	r4,4
   14d94:	21031204 	addi	r4,r4,3144
   14d98:	01400134 	movhi	r5,4
   14d9c:	29431e04 	addi	r5,r5,3192
   14da0:	01810144 	movi	r6,1029
   14da4:	01c00134 	movhi	r7,4
   14da8:	39c32404 	addi	r7,r7,3216
   14dac:	00044740 	call	4474 <printf>
   14db0:	003fff06 	br	14db0 <do_connect+0x208>
          * when the connection is established! */
          return;
        }
      }
    }
    break;
   14db4:	0001883a 	nop
  default:
    LWIP_ERROR("Invalid netconn type", 0, do{ msg->err = ERR_VAL; }while(0));
    break;
    }
  }
  sys_sem_signal(&msg->conn->op_completed);
   14db8:	e0bfff17 	ldw	r2,-4(fp)
   14dbc:	10800017 	ldw	r2,0(r2)
   14dc0:	10800404 	addi	r2,r2,16
   14dc4:	1009883a 	mov	r4,r2
   14dc8:	001b2f00 	call	1b2f0 <sys_sem_signal>
}
   14dcc:	e037883a 	mov	sp,fp
   14dd0:	dfc00117 	ldw	ra,4(sp)
   14dd4:	df000017 	ldw	fp,0(sp)
   14dd8:	dec00204 	addi	sp,sp,8
   14ddc:	f800283a 	ret

00014de0 <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
   14de0:	defffd04 	addi	sp,sp,-12
   14de4:	dfc00215 	stw	ra,8(sp)
   14de8:	df000115 	stw	fp,4(sp)
   14dec:	df000104 	addi	fp,sp,4
   14df0:	e13fff15 	stw	r4,-4(fp)
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
   14df4:	e0bfff17 	ldw	r2,-4(fp)
   14df8:	10800017 	ldw	r2,0(r2)
   14dfc:	10800017 	ldw	r2,0(r2)
   14e00:	10803c0c 	andi	r2,r2,240
   14e04:	10800818 	cmpnei	r2,r2,32
   14e08:	1000081e 	bne	r2,zero,14e2c <do_disconnect+0x4c>
    udp_disconnect(msg->conn->pcb.udp);
   14e0c:	e0bfff17 	ldw	r2,-4(fp)
   14e10:	10800017 	ldw	r2,0(r2)
   14e14:	10800217 	ldw	r2,8(r2)
   14e18:	1009883a 	mov	r4,r2
   14e1c:	002fb500 	call	2fb50 <udp_disconnect>
    msg->err = ERR_OK;
   14e20:	e0bfff17 	ldw	r2,-4(fp)
   14e24:	10000105 	stb	zero,4(r2)
   14e28:	00000306 	br	14e38 <do_disconnect+0x58>
  } else
#endif /* LWIP_UDP */
  {
    msg->err = ERR_VAL;
   14e2c:	e0bfff17 	ldw	r2,-4(fp)
   14e30:	00fffe84 	movi	r3,-6
   14e34:	10c00105 	stb	r3,4(r2)
  }
  TCPIP_APIMSG_ACK(msg);
   14e38:	e0bfff17 	ldw	r2,-4(fp)
   14e3c:	10800017 	ldw	r2,0(r2)
   14e40:	10800404 	addi	r2,r2,16
   14e44:	1009883a 	mov	r4,r2
   14e48:	001b2f00 	call	1b2f0 <sys_sem_signal>
}
   14e4c:	e037883a 	mov	sp,fp
   14e50:	dfc00117 	ldw	ra,4(sp)
   14e54:	df000017 	ldw	fp,0(sp)
   14e58:	dec00204 	addi	sp,sp,8
   14e5c:	f800283a 	ret

00014e60 <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
   14e60:	defffc04 	addi	sp,sp,-16
   14e64:	dfc00315 	stw	ra,12(sp)
   14e68:	df000215 	stw	fp,8(sp)
   14e6c:	df000204 	addi	fp,sp,8
   14e70:	e13fff15 	stw	r4,-4(fp)
  if (ERR_IS_FATAL(msg->conn->last_err)) {
   14e74:	e0bfff17 	ldw	r2,-4(fp)
   14e78:	10800017 	ldw	r2,0(r2)
   14e7c:	10800303 	ldbu	r2,12(r2)
   14e80:	10803fcc 	andi	r2,r2,255
   14e84:	1080201c 	xori	r2,r2,128
   14e88:	10bfe004 	addi	r2,r2,-128
   14e8c:	10bffdc8 	cmpgei	r2,r2,-9
   14e90:	1000061e 	bne	r2,zero,14eac <do_listen+0x4c>
    msg->err = msg->conn->last_err;
   14e94:	e0bfff17 	ldw	r2,-4(fp)
   14e98:	10800017 	ldw	r2,0(r2)
   14e9c:	10c00303 	ldbu	r3,12(r2)
   14ea0:	e0bfff17 	ldw	r2,-4(fp)
   14ea4:	10c00105 	stb	r3,4(r2)
   14ea8:	00006106 	br	15030 <do_listen+0x1d0>
  } else {
    msg->err = ERR_CONN;
   14eac:	e0bfff17 	ldw	r2,-4(fp)
   14eb0:	00fffcc4 	movi	r3,-13
   14eb4:	10c00105 	stb	r3,4(r2)
    if (msg->conn->pcb.tcp != NULL) {
   14eb8:	e0bfff17 	ldw	r2,-4(fp)
   14ebc:	10800017 	ldw	r2,0(r2)
   14ec0:	10800217 	ldw	r2,8(r2)
   14ec4:	10005a26 	beq	r2,zero,15030 <do_listen+0x1d0>
      if (msg->conn->type == NETCONN_TCP) {
   14ec8:	e0bfff17 	ldw	r2,-4(fp)
   14ecc:	10800017 	ldw	r2,0(r2)
   14ed0:	10800017 	ldw	r2,0(r2)
   14ed4:	10800418 	cmpnei	r2,r2,16
   14ed8:	1000521e 	bne	r2,zero,15024 <do_listen+0x1c4>
        if (msg->conn->state == NETCONN_NONE) {
   14edc:	e0bfff17 	ldw	r2,-4(fp)
   14ee0:	10800017 	ldw	r2,0(r2)
   14ee4:	10800117 	ldw	r2,4(r2)
   14ee8:	1000511e 	bne	r2,zero,15030 <do_listen+0x1d0>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
   14eec:	e0bfff17 	ldw	r2,-4(fp)
   14ef0:	10800017 	ldw	r2,0(r2)
   14ef4:	10c00217 	ldw	r3,8(r2)
   14ef8:	e0bfff17 	ldw	r2,-4(fp)
   14efc:	10800203 	ldbu	r2,8(r2)
   14f00:	10803fcc 	andi	r2,r2,255
   14f04:	1809883a 	mov	r4,r3
   14f08:	100b883a 	mov	r5,r2
   14f0c:	00252c00 	call	252c0 <tcp_listen_with_backlog>
   14f10:	e0bffe15 	stw	r2,-8(fp)
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
   14f14:	e0bffe17 	ldw	r2,-8(fp)
   14f18:	1000041e 	bne	r2,zero,14f2c <do_listen+0xcc>
            /* in this case, the old pcb is still allocated */
            msg->err = ERR_MEM;
   14f1c:	e0bfff17 	ldw	r2,-4(fp)
   14f20:	00ffffc4 	movi	r3,-1
   14f24:	10c00105 	stb	r3,4(r2)
   14f28:	00004106 	br	15030 <do_listen+0x1d0>
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (sys_mbox_valid(&msg->conn->recvmbox)) {
   14f2c:	e0bfff17 	ldw	r2,-4(fp)
   14f30:	10800017 	ldw	r2,0(r2)
   14f34:	10800517 	ldw	r2,20(r2)
   14f38:	10000826 	beq	r2,zero,14f5c <do_listen+0xfc>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(&msg->conn->recvmbox);
   14f3c:	e0bfff17 	ldw	r2,-4(fp)
   14f40:	10800017 	ldw	r2,0(r2)
   14f44:	10800504 	addi	r2,r2,20
   14f48:	1009883a 	mov	r4,r2
   14f4c:	001b6900 	call	1b690 <sys_mbox_free>
              sys_mbox_set_invalid(&msg->conn->recvmbox);
   14f50:	e0bfff17 	ldw	r2,-4(fp)
   14f54:	10800017 	ldw	r2,0(r2)
   14f58:	10000515 	stw	zero,20(r2)
            }
            msg->err = ERR_OK;
   14f5c:	e0bfff17 	ldw	r2,-4(fp)
   14f60:	10000105 	stb	zero,4(r2)
            if (!sys_mbox_valid(&msg->conn->acceptmbox)) {
   14f64:	e0bfff17 	ldw	r2,-4(fp)
   14f68:	10800017 	ldw	r2,0(r2)
   14f6c:	10800617 	ldw	r2,24(r2)
   14f70:	1000081e 	bne	r2,zero,14f94 <do_listen+0x134>
              msg->err = sys_mbox_new(&msg->conn->acceptmbox, DEFAULT_ACCEPTMBOX_SIZE);
   14f74:	e0bfff17 	ldw	r2,-4(fp)
   14f78:	10800017 	ldw	r2,0(r2)
   14f7c:	10800604 	addi	r2,r2,24
   14f80:	1009883a 	mov	r4,r2
   14f84:	01420004 	movi	r5,2048
   14f88:	001b5c40 	call	1b5c4 <sys_mbox_new>
   14f8c:	e0ffff17 	ldw	r3,-4(fp)
   14f90:	18800105 	stb	r2,4(r3)
            }
            if (msg->err == ERR_OK) {
   14f94:	e0bfff17 	ldw	r2,-4(fp)
   14f98:	10800103 	ldbu	r2,4(r2)
   14f9c:	10803fcc 	andi	r2,r2,255
   14fa0:	1080201c 	xori	r2,r2,128
   14fa4:	10bfe004 	addi	r2,r2,-128
   14fa8:	1000181e 	bne	r2,zero,1500c <do_listen+0x1ac>
              msg->conn->state = NETCONN_LISTEN;
   14fac:	e0bfff17 	ldw	r2,-4(fp)
   14fb0:	10800017 	ldw	r2,0(r2)
   14fb4:	00c00084 	movi	r3,2
   14fb8:	10c00115 	stw	r3,4(r2)
              msg->conn->pcb.tcp = lpcb;
   14fbc:	e0bfff17 	ldw	r2,-4(fp)
   14fc0:	10800017 	ldw	r2,0(r2)
   14fc4:	e0fffe17 	ldw	r3,-8(fp)
   14fc8:	10c00215 	stw	r3,8(r2)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
   14fcc:	e0bfff17 	ldw	r2,-4(fp)
   14fd0:	10800017 	ldw	r2,0(r2)
   14fd4:	10c00217 	ldw	r3,8(r2)
   14fd8:	e0bfff17 	ldw	r2,-4(fp)
   14fdc:	10800017 	ldw	r2,0(r2)
   14fe0:	1809883a 	mov	r4,r3
   14fe4:	100b883a 	mov	r5,r2
   14fe8:	00269f80 	call	269f8 <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
   14fec:	e0bfff17 	ldw	r2,-4(fp)
   14ff0:	10800017 	ldw	r2,0(r2)
   14ff4:	10800217 	ldw	r2,8(r2)
   14ff8:	1009883a 	mov	r4,r2
   14ffc:	01400074 	movhi	r5,1
   15000:	294f9104 	addi	r5,r5,15940
   15004:	0026ab80 	call	26ab8 <tcp_accept>
   15008:	00000906 	br	15030 <do_listen+0x1d0>
            } else {
              /* since the old pcb is already deallocated, free lpcb now */
              tcp_close(lpcb);
   1500c:	e13ffe17 	ldw	r4,-8(fp)
   15010:	0024de40 	call	24de4 <tcp_close>
              msg->conn->pcb.tcp = NULL;
   15014:	e0bfff17 	ldw	r2,-4(fp)
   15018:	10800017 	ldw	r2,0(r2)
   1501c:	10000215 	stw	zero,8(r2)
   15020:	00000306 	br	15030 <do_listen+0x1d0>
            }
          }
        }
      } else {
        msg->err = ERR_ARG;
   15024:	e0bfff17 	ldw	r2,-4(fp)
   15028:	00fffc84 	movi	r3,-14
   1502c:	10c00105 	stb	r3,4(r2)
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
   15030:	e0bfff17 	ldw	r2,-4(fp)
   15034:	10800017 	ldw	r2,0(r2)
   15038:	10800404 	addi	r2,r2,16
   1503c:	1009883a 	mov	r4,r2
   15040:	001b2f00 	call	1b2f0 <sys_sem_signal>
}
   15044:	e037883a 	mov	sp,fp
   15048:	dfc00117 	ldw	ra,4(sp)
   1504c:	df000017 	ldw	fp,0(sp)
   15050:	dec00204 	addi	sp,sp,8
   15054:	f800283a 	ret

00015058 <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
   15058:	defffb04 	addi	sp,sp,-20
   1505c:	dfc00415 	stw	ra,16(sp)
   15060:	df000315 	stw	fp,12(sp)
   15064:	df000304 	addi	fp,sp,12
   15068:	e13fff15 	stw	r4,-4(fp)
  if (ERR_IS_FATAL(msg->conn->last_err)) {
   1506c:	e0bfff17 	ldw	r2,-4(fp)
   15070:	10800017 	ldw	r2,0(r2)
   15074:	10800303 	ldbu	r2,12(r2)
   15078:	10803fcc 	andi	r2,r2,255
   1507c:	1080201c 	xori	r2,r2,128
   15080:	10bfe004 	addi	r2,r2,-128
   15084:	10bffdc8 	cmpgei	r2,r2,-9
   15088:	1000061e 	bne	r2,zero,150a4 <do_send+0x4c>
    msg->err = msg->conn->last_err;
   1508c:	e0bfff17 	ldw	r2,-4(fp)
   15090:	10800017 	ldw	r2,0(r2)
   15094:	10c00303 	ldbu	r3,12(r2)
   15098:	e0bfff17 	ldw	r2,-4(fp)
   1509c:	10c00105 	stb	r3,4(r2)
   150a0:	00006e06 	br	1525c <do_send+0x204>
  } else {
    msg->err = ERR_CONN;
   150a4:	e0bfff17 	ldw	r2,-4(fp)
   150a8:	00fffcc4 	movi	r3,-13
   150ac:	10c00105 	stb	r3,4(r2)
    if (msg->conn->pcb.tcp != NULL) {
   150b0:	e0bfff17 	ldw	r2,-4(fp)
   150b4:	10800017 	ldw	r2,0(r2)
   150b8:	10800217 	ldw	r2,8(r2)
   150bc:	10006726 	beq	r2,zero,1525c <do_send+0x204>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
   150c0:	e0bfff17 	ldw	r2,-4(fp)
   150c4:	10800017 	ldw	r2,0(r2)
   150c8:	10800017 	ldw	r2,0(r2)
   150cc:	10803c0c 	andi	r2,r2,240
   150d0:	10c00820 	cmpeqi	r3,r2,32
   150d4:	1800251e 	bne	r3,zero,1516c <do_send+0x114>
   150d8:	10801020 	cmpeqi	r2,r2,64
   150dc:	10005e26 	beq	r2,zero,15258 <do_send+0x200>
#if LWIP_RAW
      case NETCONN_RAW:
        if (ip_addr_isany(&msg->msg.b->addr)) {
   150e0:	e0bfff17 	ldw	r2,-4(fp)
   150e4:	10800217 	ldw	r2,8(r2)
   150e8:	10800204 	addi	r2,r2,8
   150ec:	10000426 	beq	r2,zero,15100 <do_send+0xa8>
   150f0:	e0bfff17 	ldw	r2,-4(fp)
   150f4:	10800217 	ldw	r2,8(r2)
   150f8:	10800217 	ldw	r2,8(r2)
   150fc:	10000c1e 	bne	r2,zero,15130 <do_send+0xd8>
          msg->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
   15100:	e0bfff17 	ldw	r2,-4(fp)
   15104:	10800017 	ldw	r2,0(r2)
   15108:	10c00217 	ldw	r3,8(r2)
   1510c:	e0bfff17 	ldw	r2,-4(fp)
   15110:	10800217 	ldw	r2,8(r2)
   15114:	10800017 	ldw	r2,0(r2)
   15118:	1809883a 	mov	r4,r3
   1511c:	100b883a 	mov	r5,r2
   15120:	00248ac0 	call	248ac <raw_send>
   15124:	e0ffff17 	ldw	r3,-4(fp)
   15128:	18800105 	stb	r2,4(r3)
        } else {
          msg->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, &msg->msg.b->addr);
        }
        break;
   1512c:	00004b06 	br	1525c <do_send+0x204>
#if LWIP_RAW
      case NETCONN_RAW:
        if (ip_addr_isany(&msg->msg.b->addr)) {
          msg->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
        } else {
          msg->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, &msg->msg.b->addr);
   15130:	e0bfff17 	ldw	r2,-4(fp)
   15134:	10800017 	ldw	r2,0(r2)
   15138:	11000217 	ldw	r4,8(r2)
   1513c:	e0bfff17 	ldw	r2,-4(fp)
   15140:	10800217 	ldw	r2,8(r2)
   15144:	10c00017 	ldw	r3,0(r2)
   15148:	e0bfff17 	ldw	r2,-4(fp)
   1514c:	10800217 	ldw	r2,8(r2)
   15150:	10800204 	addi	r2,r2,8
   15154:	180b883a 	mov	r5,r3
   15158:	100d883a 	mov	r6,r2
   1515c:	00247240 	call	24724 <raw_sendto>
   15160:	e0ffff17 	ldw	r3,-4(fp)
   15164:	18800105 	stb	r2,4(r3)
        }
        break;
   15168:	00003c06 	br	1525c <do_send+0x204>
#endif
#if LWIP_UDP
      case NETCONN_UDP:
#if LWIP_CHECKSUM_ON_COPY
        if (ip_addr_isany(&msg->msg.b->addr)) {
   1516c:	e0bfff17 	ldw	r2,-4(fp)
   15170:	10800217 	ldw	r2,8(r2)
   15174:	10800204 	addi	r2,r2,8
   15178:	10000426 	beq	r2,zero,1518c <do_send+0x134>
   1517c:	e0bfff17 	ldw	r2,-4(fp)
   15180:	10800217 	ldw	r2,8(r2)
   15184:	10800217 	ldw	r2,8(r2)
   15188:	1000151e 	bne	r2,zero,151e0 <do_send+0x188>
          msg->err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
   1518c:	e0bfff17 	ldw	r2,-4(fp)
   15190:	10800017 	ldw	r2,0(r2)
   15194:	11000217 	ldw	r4,8(r2)
   15198:	e0bfff17 	ldw	r2,-4(fp)
   1519c:	10800217 	ldw	r2,8(r2)
   151a0:	11400017 	ldw	r5,0(r2)
            msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
   151a4:	e0bfff17 	ldw	r2,-4(fp)
   151a8:	10800217 	ldw	r2,8(r2)
   151ac:	10800383 	ldbu	r2,14(r2)
#endif
#if LWIP_UDP
      case NETCONN_UDP:
#if LWIP_CHECKSUM_ON_COPY
        if (ip_addr_isany(&msg->msg.b->addr)) {
          msg->err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
   151b0:	10803fcc 	andi	r2,r2,255
   151b4:	10c0008c 	andi	r3,r2,2
            msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
   151b8:	e0bfff17 	ldw	r2,-4(fp)
   151bc:	10800217 	ldw	r2,8(r2)
   151c0:	1080040b 	ldhu	r2,16(r2)
#endif
#if LWIP_UDP
      case NETCONN_UDP:
#if LWIP_CHECKSUM_ON_COPY
        if (ip_addr_isany(&msg->msg.b->addr)) {
          msg->err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
   151c4:	10bfffcc 	andi	r2,r2,65535
   151c8:	180d883a 	mov	r6,r3
   151cc:	100f883a 	mov	r7,r2
   151d0:	002f2f40 	call	2f2f4 <udp_send_chksum>
   151d4:	e0ffff17 	ldw	r3,-4(fp)
   151d8:	18800105 	stb	r2,4(r3)
          msg->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
        } else {
          msg->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, &msg->msg.b->addr, msg->msg.b->port);
        }
#endif /* LWIP_CHECKSUM_ON_COPY */
        break;
   151dc:	00001f06 	br	1525c <do_send+0x204>
#if LWIP_CHECKSUM_ON_COPY
        if (ip_addr_isany(&msg->msg.b->addr)) {
          msg->err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
            msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
        } else {
          msg->err = udp_sendto_chksum(msg->conn->pcb.udp, msg->msg.b->p,
   151e0:	e0bfff17 	ldw	r2,-4(fp)
   151e4:	10800017 	ldw	r2,0(r2)
   151e8:	11000217 	ldw	r4,8(r2)
   151ec:	e0bfff17 	ldw	r2,-4(fp)
   151f0:	10800217 	ldw	r2,8(r2)
   151f4:	11400017 	ldw	r5,0(r2)
            &msg->msg.b->addr, msg->msg.b->port,
   151f8:	e0bfff17 	ldw	r2,-4(fp)
   151fc:	10800217 	ldw	r2,8(r2)
#if LWIP_CHECKSUM_ON_COPY
        if (ip_addr_isany(&msg->msg.b->addr)) {
          msg->err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
            msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
        } else {
          msg->err = udp_sendto_chksum(msg->conn->pcb.udp, msg->msg.b->p,
   15200:	10c00204 	addi	r3,r2,8
            &msg->msg.b->addr, msg->msg.b->port,
   15204:	e0bfff17 	ldw	r2,-4(fp)
   15208:	10800217 	ldw	r2,8(r2)
   1520c:	1080030b 	ldhu	r2,12(r2)
#if LWIP_CHECKSUM_ON_COPY
        if (ip_addr_isany(&msg->msg.b->addr)) {
          msg->err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
            msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
        } else {
          msg->err = udp_sendto_chksum(msg->conn->pcb.udp, msg->msg.b->p,
   15210:	10bfffcc 	andi	r2,r2,65535
            &msg->msg.b->addr, msg->msg.b->port,
            msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
   15214:	e1bfff17 	ldw	r6,-4(fp)
   15218:	31800217 	ldw	r6,8(r6)
   1521c:	31800383 	ldbu	r6,14(r6)
#if LWIP_CHECKSUM_ON_COPY
        if (ip_addr_isany(&msg->msg.b->addr)) {
          msg->err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
            msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
        } else {
          msg->err = udp_sendto_chksum(msg->conn->pcb.udp, msg->msg.b->p,
   15220:	31803fcc 	andi	r6,r6,255
   15224:	31c0008c 	andi	r7,r6,2
            &msg->msg.b->addr, msg->msg.b->port,
            msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
   15228:	e1bfff17 	ldw	r6,-4(fp)
   1522c:	31800217 	ldw	r6,8(r6)
   15230:	3180040b 	ldhu	r6,16(r6)
#if LWIP_CHECKSUM_ON_COPY
        if (ip_addr_isany(&msg->msg.b->addr)) {
          msg->err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
            msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
        } else {
          msg->err = udp_sendto_chksum(msg->conn->pcb.udp, msg->msg.b->p,
   15234:	31bfffcc 	andi	r6,r6,65535
   15238:	d9c00015 	stw	r7,0(sp)
   1523c:	d9800115 	stw	r6,4(sp)
   15240:	180d883a 	mov	r6,r3
   15244:	100f883a 	mov	r7,r2
   15248:	002f3c00 	call	2f3c0 <udp_sendto_chksum>
   1524c:	e0ffff17 	ldw	r3,-4(fp)
   15250:	18800105 	stb	r2,4(r3)
          msg->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
        } else {
          msg->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, &msg->msg.b->addr, msg->msg.b->port);
        }
#endif /* LWIP_CHECKSUM_ON_COPY */
        break;
   15254:	00000106 	br	1525c <do_send+0x204>
#endif /* LWIP_UDP */
      default:
        break;
   15258:	0001883a 	nop
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
   1525c:	e0bfff17 	ldw	r2,-4(fp)
   15260:	10800017 	ldw	r2,0(r2)
   15264:	10800404 	addi	r2,r2,16
   15268:	1009883a 	mov	r4,r2
   1526c:	001b2f00 	call	1b2f0 <sys_sem_signal>
}
   15270:	e037883a 	mov	sp,fp
   15274:	dfc00117 	ldw	ra,4(sp)
   15278:	df000017 	ldw	fp,0(sp)
   1527c:	dec00204 	addi	sp,sp,8
   15280:	f800283a 	ret

00015284 <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
   15284:	defffb04 	addi	sp,sp,-20
   15288:	dfc00415 	stw	ra,16(sp)
   1528c:	df000315 	stw	fp,12(sp)
   15290:	df000304 	addi	fp,sp,12
   15294:	e13fff15 	stw	r4,-4(fp)
  msg->err = ERR_OK;
   15298:	e0bfff17 	ldw	r2,-4(fp)
   1529c:	10000105 	stb	zero,4(r2)
  if (msg->conn->pcb.tcp != NULL) {
   152a0:	e0bfff17 	ldw	r2,-4(fp)
   152a4:	10800017 	ldw	r2,0(r2)
   152a8:	10800217 	ldw	r2,8(r2)
   152ac:	10002926 	beq	r2,zero,15354 <do_recv+0xd0>
    if (msg->conn->type == NETCONN_TCP) {
   152b0:	e0bfff17 	ldw	r2,-4(fp)
   152b4:	10800017 	ldw	r2,0(r2)
   152b8:	10800017 	ldw	r2,0(r2)
   152bc:	10800418 	cmpnei	r2,r2,16
   152c0:	1000241e 	bne	r2,zero,15354 <do_recv+0xd0>
#if TCP_LISTEN_BACKLOG
      if (msg->conn->pcb.tcp->state == LISTEN) {
   152c4:	e0bfff17 	ldw	r2,-4(fp)
   152c8:	10800017 	ldw	r2,0(r2)
   152cc:	10800217 	ldw	r2,8(r2)
   152d0:	10800617 	ldw	r2,24(r2)
   152d4:	10800058 	cmpnei	r2,r2,1
   152d8:	1000071e 	bne	r2,zero,152f8 <do_recv+0x74>
        tcp_accepted(msg->conn->pcb.tcp);
   152dc:	e0bfff17 	ldw	r2,-4(fp)
   152e0:	10800017 	ldw	r2,0(r2)
   152e4:	10800217 	ldw	r2,8(r2)
   152e8:	10c00843 	ldbu	r3,33(r2)
   152ec:	18ffffc4 	addi	r3,r3,-1
   152f0:	10c00845 	stb	r3,33(r2)
   152f4:	00001706 	br	15354 <do_recv+0xd0>
      } else
#endif /* TCP_LISTEN_BACKLOG */
      {
        u32_t remaining = msg->msg.r.len;
   152f8:	e0bfff17 	ldw	r2,-4(fp)
   152fc:	10800217 	ldw	r2,8(r2)
   15300:	e0bffd15 	stw	r2,-12(fp)
        do {
          u16_t recved = (remaining > 0xffff) ? 0xffff : (u16_t)remaining;
   15304:	e0bffd17 	ldw	r2,-12(fp)
   15308:	00ffffd4 	movui	r3,65535
   1530c:	18800236 	bltu	r3,r2,15318 <do_recv+0x94>
   15310:	e0bffd17 	ldw	r2,-12(fp)
   15314:	00000106 	br	1531c <do_recv+0x98>
   15318:	00bfffc4 	movi	r2,-1
   1531c:	e0bffe0d 	sth	r2,-8(fp)
          tcp_recved(msg->conn->pcb.tcp, recved);
   15320:	e0bfff17 	ldw	r2,-4(fp)
   15324:	10800017 	ldw	r2,0(r2)
   15328:	10c00217 	ldw	r3,8(r2)
   1532c:	e0bffe0b 	ldhu	r2,-8(fp)
   15330:	1809883a 	mov	r4,r3
   15334:	100b883a 	mov	r5,r2
   15338:	00256180 	call	25618 <tcp_recved>
          remaining -= recved;
   1533c:	e0bffe0b 	ldhu	r2,-8(fp)
   15340:	e0fffd17 	ldw	r3,-12(fp)
   15344:	1885c83a 	sub	r2,r3,r2
   15348:	e0bffd15 	stw	r2,-12(fp)
        }while(remaining != 0);
   1534c:	e0bffd17 	ldw	r2,-12(fp)
   15350:	103fec1e 	bne	r2,zero,15304 <do_recv+0x80>
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
   15354:	e0bfff17 	ldw	r2,-4(fp)
   15358:	10800017 	ldw	r2,0(r2)
   1535c:	10800404 	addi	r2,r2,16
   15360:	1009883a 	mov	r4,r2
   15364:	001b2f00 	call	1b2f0 <sys_sem_signal>
}
   15368:	e037883a 	mov	sp,fp
   1536c:	dfc00117 	ldw	ra,4(sp)
   15370:	df000017 	ldw	fp,0(sp)
   15374:	dec00204 	addi	sp,sp,8
   15378:	f800283a 	ret

0001537c <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
   1537c:	defff804 	addi	sp,sp,-32
   15380:	dfc00715 	stw	ra,28(sp)
   15384:	df000615 	stw	fp,24(sp)
   15388:	df000604 	addi	fp,sp,24
   1538c:	e13fff15 	stw	r4,-4(fp)
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
   15390:	e03ffb05 	stb	zero,-20(fp)
  size_t diff;
  u8_t dontblock = netconn_is_nonblocking(conn) ||
   15394:	e0bfff17 	ldw	r2,-4(fp)
   15398:	10800903 	ldbu	r2,36(r2)
   1539c:	10803fcc 	andi	r2,r2,255
   153a0:	1080008c 	andi	r2,r2,2
   153a4:	1000061e 	bne	r2,zero,153c0 <do_writemore+0x44>
       (conn->current_msg->msg.w.apiflags & NETCONN_DONTBLOCK);
   153a8:	e0bfff17 	ldw	r2,-4(fp)
   153ac:	10800b17 	ldw	r2,44(r2)
   153b0:	10800403 	ldbu	r2,16(r2)
   153b4:	10803fcc 	andi	r2,r2,255
   153b8:	1080010c 	andi	r2,r2,4
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
  size_t diff;
  u8_t dontblock = netconn_is_nonblocking(conn) ||
   153bc:	10000226 	beq	r2,zero,153c8 <do_writemore+0x4c>
   153c0:	00800044 	movi	r2,1
   153c4:	00000106 	br	153cc <do_writemore+0x50>
   153c8:	0005883a 	mov	r2,zero
   153cc:	e0bffb85 	stb	r2,-18(fp)
       (conn->current_msg->msg.w.apiflags & NETCONN_DONTBLOCK);
  u8_t apiflags = conn->current_msg->msg.w.apiflags;
   153d0:	e0bfff17 	ldw	r2,-4(fp)
   153d4:	10800b17 	ldw	r2,44(r2)
   153d8:	10800403 	ldbu	r2,16(r2)
   153dc:	e0bffb45 	stb	r2,-19(fp)
      conn->current_msg->msg.w.len = conn->write_offset;
    }
  } else
#endif /* LWIP_SO_SNDTIMEO */
  {
    dataptr = (u8_t*)conn->current_msg->msg.w.dataptr + conn->write_offset;
   153e0:	e0bfff17 	ldw	r2,-4(fp)
   153e4:	10800b17 	ldw	r2,44(r2)
   153e8:	10c00217 	ldw	r3,8(r2)
   153ec:	e0bfff17 	ldw	r2,-4(fp)
   153f0:	10800a17 	ldw	r2,40(r2)
   153f4:	1885883a 	add	r2,r3,r2
   153f8:	e0bffc15 	stw	r2,-16(fp)
    diff = conn->current_msg->msg.w.len - conn->write_offset;
   153fc:	e0bfff17 	ldw	r2,-4(fp)
   15400:	10800b17 	ldw	r2,44(r2)
   15404:	10c00317 	ldw	r3,12(r2)
   15408:	e0bfff17 	ldw	r2,-4(fp)
   1540c:	10800a17 	ldw	r2,40(r2)
   15410:	1885c83a 	sub	r2,r3,r2
   15414:	e0bffd15 	stw	r2,-12(fp)
    if (diff > 0xffffUL) { /* max_u16_t */
   15418:	e0bffd17 	ldw	r2,-12(fp)
   1541c:	00ffffd4 	movui	r3,65535
   15420:	1880062e 	bgeu	r3,r2,1543c <do_writemore+0xc0>
      len = 0xffff;
   15424:	00bfffc4 	movi	r2,-1
   15428:	e0bffa8d 	sth	r2,-22(fp)
#if LWIP_TCPIP_CORE_LOCKING
      conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
#endif
      apiflags |= TCP_WRITE_FLAG_MORE;
   1542c:	e0bffb43 	ldbu	r2,-19(fp)
   15430:	10800094 	ori	r2,r2,2
   15434:	e0bffb45 	stb	r2,-19(fp)
   15438:	00000206 	br	15444 <do_writemore+0xc8>
    } else {
      len = (u16_t)diff;
   1543c:	e0bffd17 	ldw	r2,-12(fp)
   15440:	e0bffa8d 	sth	r2,-22(fp)
    }
    available = tcp_sndbuf(conn->pcb.tcp);
   15444:	e0bfff17 	ldw	r2,-4(fp)
   15448:	10800217 	ldw	r2,8(r2)
   1544c:	10801a8b 	ldhu	r2,106(r2)
   15450:	e0bffe0d 	sth	r2,-8(fp)
    if (available < len) {
   15454:	e0fffe0b 	ldhu	r3,-8(fp)
   15458:	e0bffa8b 	ldhu	r2,-22(fp)
   1545c:	18800c2e 	bgeu	r3,r2,15490 <do_writemore+0x114>
      /* don't try to write more than sendbuf */
      len = available;
   15460:	e0bffe0b 	ldhu	r2,-8(fp)
   15464:	e0bffa8d 	sth	r2,-22(fp)
      if (dontblock){ 
   15468:	e0bffb83 	ldbu	r2,-18(fp)
   1546c:	10000526 	beq	r2,zero,15484 <do_writemore+0x108>
        if (!len) {
   15470:	e0bffa8b 	ldhu	r2,-22(fp)
   15474:	1000061e 	bne	r2,zero,15490 <do_writemore+0x114>
          err = ERR_WOULDBLOCK;
   15478:	00bffe44 	movi	r2,-7
   1547c:	e0bffa05 	stb	r2,-24(fp)
          goto err_mem;
   15480:	00001106 	br	154c8 <do_writemore+0x14c>
        }
      } else {
#if LWIP_TCPIP_CORE_LOCKING
        conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
#endif
        apiflags |= TCP_WRITE_FLAG_MORE;
   15484:	e0bffb43 	ldbu	r2,-19(fp)
   15488:	10800094 	ori	r2,r2,2
   1548c:	e0bffb45 	stb	r2,-19(fp)
      }
    }
    LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->current_msg->msg.w.len));
    err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
   15490:	e0bfff17 	ldw	r2,-4(fp)
   15494:	11000217 	ldw	r4,8(r2)
   15498:	e0fffa8b 	ldhu	r3,-22(fp)
   1549c:	e0bffb43 	ldbu	r2,-19(fp)
   154a0:	e17ffc17 	ldw	r5,-16(fp)
   154a4:	180d883a 	mov	r6,r3
   154a8:	100f883a 	mov	r7,r2
   154ac:	002bc940 	call	2bc94 <tcp_write>
   154b0:	e0bffa05 	stb	r2,-24(fp)
    /* if OK or memory error, check available space */
    if ((err == ERR_OK) || (err == ERR_MEM)) {
   154b4:	e0bffa07 	ldb	r2,-24(fp)
   154b8:	10000326 	beq	r2,zero,154c8 <do_writemore+0x14c>
   154bc:	e0bffa07 	ldb	r2,-24(fp)
   154c0:	10bfffd8 	cmpnei	r2,r2,-1
   154c4:	10002e1e 	bne	r2,zero,15580 <do_writemore+0x204>
err_mem:
      if (dontblock && (len < conn->current_msg->msg.w.len)) {
   154c8:	e0bffb83 	ldbu	r2,-18(fp)
   154cc:	10001626 	beq	r2,zero,15528 <do_writemore+0x1ac>
   154d0:	e0fffa8b 	ldhu	r3,-22(fp)
   154d4:	e0bfff17 	ldw	r2,-4(fp)
   154d8:	10800b17 	ldw	r2,44(r2)
   154dc:	10800317 	ldw	r2,12(r2)
   154e0:	1880112e 	bgeu	r3,r2,15528 <do_writemore+0x1ac>
        /* non-blocking write did not write everything: mark the pcb non-writable
           and let poll_tcp check writable space to mark the pcb writable again */
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
   154e4:	e0bfff17 	ldw	r2,-4(fp)
   154e8:	10800c17 	ldw	r2,48(r2)
   154ec:	10000726 	beq	r2,zero,1550c <do_writemore+0x190>
   154f0:	e0bfff17 	ldw	r2,-4(fp)
   154f4:	10c00c17 	ldw	r3,48(r2)
   154f8:	e0bffa8b 	ldhu	r2,-22(fp)
   154fc:	e13fff17 	ldw	r4,-4(fp)
   15500:	014000c4 	movi	r5,3
   15504:	100d883a 	mov	r6,r2
   15508:	183ee83a 	callr	r3
        conn->flags |= NETCONN_FLAG_CHECK_WRITESPACE;
   1550c:	e0bfff17 	ldw	r2,-4(fp)
   15510:	10800903 	ldbu	r2,36(r2)
   15514:	10800414 	ori	r2,r2,16
   15518:	1007883a 	mov	r3,r2
   1551c:	e0bfff17 	ldw	r2,-4(fp)
   15520:	10c00905 	stb	r3,36(r2)
   15524:	00001606 	br	15580 <do_writemore+0x204>
      } else if ((tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT) ||
   15528:	e0bfff17 	ldw	r2,-4(fp)
   1552c:	10800217 	ldw	r2,8(r2)
   15530:	10801a8b 	ldhu	r2,106(r2)
   15534:	10bfffcc 	andi	r2,r2,65535
   15538:	10816d70 	cmpltui	r2,r2,1461
   1553c:	1000061e 	bne	r2,zero,15558 <do_writemore+0x1dc>
                 (tcp_sndqueuelen(conn->pcb.tcp) >= TCP_SNDQUEUELOWAT)) {
   15540:	e0bfff17 	ldw	r2,-4(fp)
   15544:	10800217 	ldw	r2,8(r2)
   15548:	10801b0b 	ldhu	r2,108(r2)
      if (dontblock && (len < conn->current_msg->msg.w.len)) {
        /* non-blocking write did not write everything: mark the pcb non-writable
           and let poll_tcp check writable space to mark the pcb writable again */
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
        conn->flags |= NETCONN_FLAG_CHECK_WRITESPACE;
      } else if ((tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT) ||
   1554c:	10bfffcc 	andi	r2,r2,65535
   15550:	10800130 	cmpltui	r2,r2,4
   15554:	10000a1e 	bne	r2,zero,15580 <do_writemore+0x204>
                 (tcp_sndqueuelen(conn->pcb.tcp) >= TCP_SNDQUEUELOWAT)) {
        /* The queued byte- or pbuf-count exceeds the configured low-water limit,
           let select mark this pcb as non-writable. */
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
   15558:	e0bfff17 	ldw	r2,-4(fp)
   1555c:	10800c17 	ldw	r2,48(r2)
   15560:	10000726 	beq	r2,zero,15580 <do_writemore+0x204>
   15564:	e0bfff17 	ldw	r2,-4(fp)
   15568:	10c00c17 	ldw	r3,48(r2)
   1556c:	e0bffa8b 	ldhu	r2,-22(fp)
   15570:	e13fff17 	ldw	r4,-4(fp)
   15574:	014000c4 	movi	r5,3
   15578:	100d883a 	mov	r6,r2
   1557c:	183ee83a 	callr	r3
      }
    }

    if (err == ERR_OK) {
   15580:	e0bffa07 	ldb	r2,-24(fp)
   15584:	10001c1e 	bne	r2,zero,155f8 <do_writemore+0x27c>
      conn->write_offset += len;
   15588:	e0bfff17 	ldw	r2,-4(fp)
   1558c:	10c00a17 	ldw	r3,40(r2)
   15590:	e0bffa8b 	ldhu	r2,-22(fp)
   15594:	1887883a 	add	r3,r3,r2
   15598:	e0bfff17 	ldw	r2,-4(fp)
   1559c:	10c00a15 	stw	r3,40(r2)
      if ((conn->write_offset == conn->current_msg->msg.w.len) || dontblock) {
   155a0:	e0bfff17 	ldw	r2,-4(fp)
   155a4:	10c00a17 	ldw	r3,40(r2)
   155a8:	e0bfff17 	ldw	r2,-4(fp)
   155ac:	10800b17 	ldw	r2,44(r2)
   155b0:	10800317 	ldw	r2,12(r2)
   155b4:	18800226 	beq	r3,r2,155c0 <do_writemore+0x244>
   155b8:	e0bffb83 	ldbu	r2,-18(fp)
   155bc:	10000926 	beq	r2,zero,155e4 <do_writemore+0x268>
        /* return sent length */
        conn->current_msg->msg.w.len = conn->write_offset;
   155c0:	e0bfff17 	ldw	r2,-4(fp)
   155c4:	10800b17 	ldw	r2,44(r2)
   155c8:	e0ffff17 	ldw	r3,-4(fp)
   155cc:	18c00a17 	ldw	r3,40(r3)
   155d0:	10c00315 	stw	r3,12(r2)
        /* everything was written */
        write_finished = 1;
   155d4:	00800044 	movi	r2,1
   155d8:	e0bffb05 	stb	r2,-20(fp)
        conn->write_offset = 0;
   155dc:	e0bfff17 	ldw	r2,-4(fp)
   155e0:	10000a15 	stw	zero,40(r2)
      }
      tcp_output(conn->pcb.tcp);
   155e4:	e0bfff17 	ldw	r2,-4(fp)
   155e8:	10800217 	ldw	r2,8(r2)
   155ec:	1009883a 	mov	r4,r2
   155f0:	002c9d00 	call	2c9d0 <tcp_output>
   155f4:	00000f06 	br	15634 <do_writemore+0x2b8>
    } else if ((err == ERR_MEM) && !dontblock) {
   155f8:	e0bffa07 	ldb	r2,-24(fp)
   155fc:	10bfffd8 	cmpnei	r2,r2,-1
   15600:	1000071e 	bne	r2,zero,15620 <do_writemore+0x2a4>
   15604:	e0bffb83 	ldbu	r2,-18(fp)
   15608:	1000051e 	bne	r2,zero,15620 <do_writemore+0x2a4>
      /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
         we do NOT return to the application thread, since ERR_MEM is
         only a temporary error! */

      /* tcp_write returned ERR_MEM, try tcp_output anyway */
      tcp_output(conn->pcb.tcp);
   1560c:	e0bfff17 	ldw	r2,-4(fp)
   15610:	10800217 	ldw	r2,8(r2)
   15614:	1009883a 	mov	r4,r2
   15618:	002c9d00 	call	2c9d0 <tcp_output>
   1561c:	00000506 	br	15634 <do_writemore+0x2b8>
      conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
#endif
    } else {
      /* On errors != ERR_MEM, we don't try writing any more but return
         the error to the application thread. */
      write_finished = 1;
   15620:	00800044 	movi	r2,1
   15624:	e0bffb05 	stb	r2,-20(fp)
      conn->current_msg->msg.w.len = 0;
   15628:	e0bfff17 	ldw	r2,-4(fp)
   1562c:	10800b17 	ldw	r2,44(r2)
   15630:	10000315 	stw	zero,12(r2)
    }
  }
  if (write_finished) {
   15634:	e0bffb03 	ldbu	r2,-20(fp)
   15638:	10000c26 	beq	r2,zero,1566c <do_writemore+0x2f0>
    /* everything was written: set back connection state
       and back to application task */
    conn->current_msg->err = err;
   1563c:	e0bfff17 	ldw	r2,-4(fp)
   15640:	10800b17 	ldw	r2,44(r2)
   15644:	e0fffa03 	ldbu	r3,-24(fp)
   15648:	10c00105 	stb	r3,4(r2)
    conn->current_msg = NULL;
   1564c:	e0bfff17 	ldw	r2,-4(fp)
   15650:	10000b15 	stw	zero,44(r2)
    conn->state = NETCONN_NONE;
   15654:	e0bfff17 	ldw	r2,-4(fp)
   15658:	10000115 	stw	zero,4(r2)
#if LWIP_TCPIP_CORE_LOCKING
    if ((conn->flags & NETCONN_FLAG_WRITE_DELAYED) != 0)
#endif
    {
      sys_sem_signal(&conn->op_completed);
   1565c:	e0bfff17 	ldw	r2,-4(fp)
   15660:	10800404 	addi	r2,r2,16
   15664:	1009883a 	mov	r4,r2
   15668:	001b2f00 	call	1b2f0 <sys_sem_signal>
  }
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
   1566c:	0005883a 	mov	r2,zero
}
   15670:	e037883a 	mov	sp,fp
   15674:	dfc00117 	ldw	ra,4(sp)
   15678:	df000017 	ldw	fp,0(sp)
   1567c:	dec00204 	addi	sp,sp,8
   15680:	f800283a 	ret

00015684 <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
   15684:	defffd04 	addi	sp,sp,-12
   15688:	dfc00215 	stw	ra,8(sp)
   1568c:	df000115 	stw	fp,4(sp)
   15690:	df000104 	addi	fp,sp,4
   15694:	e13fff15 	stw	r4,-4(fp)
  if (ERR_IS_FATAL(msg->conn->last_err)) {
   15698:	e0bfff17 	ldw	r2,-4(fp)
   1569c:	10800017 	ldw	r2,0(r2)
   156a0:	10800303 	ldbu	r2,12(r2)
   156a4:	10803fcc 	andi	r2,r2,255
   156a8:	1080201c 	xori	r2,r2,128
   156ac:	10bfe004 	addi	r2,r2,-128
   156b0:	10bffdc8 	cmpgei	r2,r2,-9
   156b4:	1000061e 	bne	r2,zero,156d0 <do_write+0x4c>
    msg->err = msg->conn->last_err;
   156b8:	e0bfff17 	ldw	r2,-4(fp)
   156bc:	10800017 	ldw	r2,0(r2)
   156c0:	10c00303 	ldbu	r3,12(r2)
   156c4:	e0bfff17 	ldw	r2,-4(fp)
   156c8:	10c00105 	stb	r3,4(r2)
   156cc:	00002806 	br	15770 <do_write+0xec>
  } else {
    if (msg->conn->type == NETCONN_TCP) {
   156d0:	e0bfff17 	ldw	r2,-4(fp)
   156d4:	10800017 	ldw	r2,0(r2)
   156d8:	10800017 	ldw	r2,0(r2)
   156dc:	10800418 	cmpnei	r2,r2,16
   156e0:	1000201e 	bne	r2,zero,15764 <do_write+0xe0>
#if LWIP_TCP
      if (msg->conn->state != NETCONN_NONE) {
   156e4:	e0bfff17 	ldw	r2,-4(fp)
   156e8:	10800017 	ldw	r2,0(r2)
   156ec:	10800117 	ldw	r2,4(r2)
   156f0:	10000426 	beq	r2,zero,15704 <do_write+0x80>
        /* netconn is connecting, closing or in blocking write */
        msg->err = ERR_INPROGRESS;
   156f4:	e0bfff17 	ldw	r2,-4(fp)
   156f8:	00fffec4 	movi	r3,-5
   156fc:	10c00105 	stb	r3,4(r2)
   15700:	00001b06 	br	15770 <do_write+0xec>
      } else if (msg->conn->pcb.tcp != NULL) {
   15704:	e0bfff17 	ldw	r2,-4(fp)
   15708:	10800017 	ldw	r2,0(r2)
   1570c:	10800217 	ldw	r2,8(r2)
   15710:	10001026 	beq	r2,zero,15754 <do_write+0xd0>
        msg->conn->state = NETCONN_WRITE;
   15714:	e0bfff17 	ldw	r2,-4(fp)
   15718:	10800017 	ldw	r2,0(r2)
   1571c:	00c00044 	movi	r3,1
   15720:	10c00115 	stw	r3,4(r2)
        /* set all the variables used by do_writemore */
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
          msg->conn->write_offset == 0);
        LWIP_ASSERT("msg->msg.w.len != 0", msg->msg.w.len != 0);
        msg->conn->current_msg = msg;
   15724:	e0bfff17 	ldw	r2,-4(fp)
   15728:	10800017 	ldw	r2,0(r2)
   1572c:	e0ffff17 	ldw	r3,-4(fp)
   15730:	10c00b15 	stw	r3,44(r2)
        msg->conn->write_offset = 0;
   15734:	e0bfff17 	ldw	r2,-4(fp)
   15738:	10800017 	ldw	r2,0(r2)
   1573c:	10000a15 	stw	zero,40(r2)
          sys_arch_sem_wait(&msg->conn->op_completed, 0);
          LOCK_TCPIP_CORE();
          LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
        }
#else /* LWIP_TCPIP_CORE_LOCKING */
        do_writemore(msg->conn);
   15740:	e0bfff17 	ldw	r2,-4(fp)
   15744:	10800017 	ldw	r2,0(r2)
   15748:	1009883a 	mov	r4,r2
   1574c:	001537c0 	call	1537c <do_writemore>
#endif /* LWIP_TCPIP_CORE_LOCKING */
        /* for both cases: if do_writemore was called, don't ACK the APIMSG
           since do_writemore ACKs it! */
        return;
   15750:	00000c06 	br	15784 <do_write+0x100>
      } else {
        msg->err = ERR_CONN;
   15754:	e0bfff17 	ldw	r2,-4(fp)
   15758:	00fffcc4 	movi	r3,-13
   1575c:	10c00105 	stb	r3,4(r2)
   15760:	00000306 	br	15770 <do_write+0xec>
#else /* LWIP_TCP */
      msg->err = ERR_VAL;
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->err = ERR_VAL;
   15764:	e0bfff17 	ldw	r2,-4(fp)
   15768:	00fffe84 	movi	r3,-6
   1576c:	10c00105 	stb	r3,4(r2)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
   15770:	e0bfff17 	ldw	r2,-4(fp)
   15774:	10800017 	ldw	r2,0(r2)
   15778:	10800404 	addi	r2,r2,16
   1577c:	1009883a 	mov	r4,r2
   15780:	001b2f00 	call	1b2f0 <sys_sem_signal>
}
   15784:	e037883a 	mov	sp,fp
   15788:	dfc00117 	ldw	ra,4(sp)
   1578c:	df000017 	ldw	fp,0(sp)
   15790:	dec00204 	addi	sp,sp,8
   15794:	f800283a 	ret

00015798 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
   15798:	defffd04 	addi	sp,sp,-12
   1579c:	dfc00215 	stw	ra,8(sp)
   157a0:	df000115 	stw	fp,4(sp)
   157a4:	df000104 	addi	fp,sp,4
   157a8:	e13fff15 	stw	r4,-4(fp)
  if (msg->conn->pcb.ip != NULL) {
   157ac:	e0bfff17 	ldw	r2,-4(fp)
   157b0:	10800017 	ldw	r2,0(r2)
   157b4:	10800217 	ldw	r2,8(r2)
   157b8:	10006126 	beq	r2,zero,15940 <do_getaddr+0x1a8>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local ? msg->conn->pcb.ip->local_ip :
   157bc:	e0bfff17 	ldw	r2,-4(fp)
   157c0:	10800217 	ldw	r2,8(r2)
   157c4:	e0ffff17 	ldw	r3,-4(fp)
   157c8:	18c00403 	ldbu	r3,16(r3)
   157cc:	18c03fcc 	andi	r3,r3,255
   157d0:	18000626 	beq	r3,zero,157ec <do_getaddr+0x54>
   157d4:	e0ffff17 	ldw	r3,-4(fp)
   157d8:	18c00017 	ldw	r3,0(r3)
   157dc:	18c00217 	ldw	r3,8(r3)
   157e0:	18c00017 	ldw	r3,0(r3)
   157e4:	10c00015 	stw	r3,0(r2)
   157e8:	00000506 	br	15800 <do_getaddr+0x68>
                             msg->conn->pcb.ip->remote_ip);
   157ec:	e0ffff17 	ldw	r3,-4(fp)
   157f0:	18c00017 	ldw	r3,0(r3)
   157f4:	18c00217 	ldw	r3,8(r3)
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  if (msg->conn->pcb.ip != NULL) {
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local ? msg->conn->pcb.ip->local_ip :
   157f8:	18c00117 	ldw	r3,4(r3)
   157fc:	10c00015 	stw	r3,0(r2)
                             msg->conn->pcb.ip->remote_ip);

    msg->err = ERR_OK;
   15800:	e0bfff17 	ldw	r2,-4(fp)
   15804:	10000105 	stb	zero,4(r2)
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
   15808:	e0bfff17 	ldw	r2,-4(fp)
   1580c:	10800017 	ldw	r2,0(r2)
   15810:	10800017 	ldw	r2,0(r2)
   15814:	10803c0c 	andi	r2,r2,240
   15818:	10c00820 	cmpeqi	r3,r2,32
   1581c:	1800161e 	bne	r3,zero,15878 <do_getaddr+0xe0>
   15820:	10c01020 	cmpeqi	r3,r2,64
   15824:	1800031e 	bne	r3,zero,15834 <do_getaddr+0x9c>
   15828:	10800420 	cmpeqi	r2,r2,16
   1582c:	1000311e 	bne	r2,zero,158f4 <do_getaddr+0x15c>
   15830:	00004206 	br	1593c <do_getaddr+0x1a4>
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
   15834:	e0bfff17 	ldw	r2,-4(fp)
   15838:	10800403 	ldbu	r2,16(r2)
   1583c:	10803fcc 	andi	r2,r2,255
   15840:	10000926 	beq	r2,zero,15868 <do_getaddr+0xd0>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
   15844:	e0bfff17 	ldw	r2,-4(fp)
   15848:	10800317 	ldw	r2,12(r2)
   1584c:	e0ffff17 	ldw	r3,-4(fp)
   15850:	18c00017 	ldw	r3,0(r3)
   15854:	18c00217 	ldw	r3,8(r3)
   15858:	18c00403 	ldbu	r3,16(r3)
   1585c:	18c03fcc 	andi	r3,r3,255
   15860:	10c0000d 	sth	r3,0(r2)
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->err = ERR_CONN;
      }
      break;
   15864:	00003906 	br	1594c <do_getaddr+0x1b4>
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->err = ERR_CONN;
   15868:	e0bfff17 	ldw	r2,-4(fp)
   1586c:	00fffcc4 	movi	r3,-13
   15870:	10c00105 	stb	r3,4(r2)
      }
      break;
   15874:	00003506 	br	1594c <do_getaddr+0x1b4>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
   15878:	e0bfff17 	ldw	r2,-4(fp)
   1587c:	10800403 	ldbu	r2,16(r2)
   15880:	10803fcc 	andi	r2,r2,255
   15884:	10000826 	beq	r2,zero,158a8 <do_getaddr+0x110>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
   15888:	e0bfff17 	ldw	r2,-4(fp)
   1588c:	10800317 	ldw	r2,12(r2)
   15890:	e0ffff17 	ldw	r3,-4(fp)
   15894:	18c00017 	ldw	r3,0(r3)
   15898:	18c00217 	ldw	r3,8(r3)
   1589c:	18c0048b 	ldhu	r3,18(r3)
   158a0:	10c0000d 	sth	r3,0(r2)
          msg->err = ERR_CONN;
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
        }
      }
      break;
   158a4:	00002906 	br	1594c <do_getaddr+0x1b4>
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
   158a8:	e0bfff17 	ldw	r2,-4(fp)
   158ac:	10800017 	ldw	r2,0(r2)
   158b0:	10800217 	ldw	r2,8(r2)
   158b4:	10800403 	ldbu	r2,16(r2)
   158b8:	10803fcc 	andi	r2,r2,255
   158bc:	1080010c 	andi	r2,r2,4
   158c0:	1000041e 	bne	r2,zero,158d4 <do_getaddr+0x13c>
          msg->err = ERR_CONN;
   158c4:	e0bfff17 	ldw	r2,-4(fp)
   158c8:	00fffcc4 	movi	r3,-13
   158cc:	10c00105 	stb	r3,4(r2)
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
        }
      }
      break;
   158d0:	00001e06 	br	1594c <do_getaddr+0x1b4>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
          msg->err = ERR_CONN;
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
   158d4:	e0bfff17 	ldw	r2,-4(fp)
   158d8:	10800317 	ldw	r2,12(r2)
   158dc:	e0ffff17 	ldw	r3,-4(fp)
   158e0:	18c00017 	ldw	r3,0(r3)
   158e4:	18c00217 	ldw	r3,8(r3)
   158e8:	18c0050b 	ldhu	r3,20(r3)
   158ec:	10c0000d 	sth	r3,0(r2)
        }
      }
      break;
   158f0:	00001606 	br	1594c <do_getaddr+0x1b4>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
   158f4:	e0bfff17 	ldw	r2,-4(fp)
   158f8:	10c00317 	ldw	r3,12(r2)
   158fc:	e0bfff17 	ldw	r2,-4(fp)
   15900:	10800403 	ldbu	r2,16(r2)
   15904:	10803fcc 	andi	r2,r2,255
   15908:	10000526 	beq	r2,zero,15920 <do_getaddr+0x188>
   1590c:	e0bfff17 	ldw	r2,-4(fp)
   15910:	10800017 	ldw	r2,0(r2)
   15914:	10800217 	ldw	r2,8(r2)
   15918:	1080078b 	ldhu	r2,30(r2)
   1591c:	00000406 	br	15930 <do_getaddr+0x198>
   15920:	e0bfff17 	ldw	r2,-4(fp)
   15924:	10800017 	ldw	r2,0(r2)
   15928:	10800217 	ldw	r2,8(r2)
   1592c:	1080080b 	ldhu	r2,32(r2)
   15930:	1880000d 	sth	r2,0(r3)
      break;
   15934:	0001883a 	nop
   15938:	00000406 	br	1594c <do_getaddr+0x1b4>
#endif /* LWIP_TCP */
    default:
      LWIP_ASSERT("invalid netconn_type", 0);
      break;
   1593c:	00000306 	br	1594c <do_getaddr+0x1b4>
    }
  } else {
    msg->err = ERR_CONN;
   15940:	e0bfff17 	ldw	r2,-4(fp)
   15944:	00fffcc4 	movi	r3,-13
   15948:	10c00105 	stb	r3,4(r2)
  }
  TCPIP_APIMSG_ACK(msg);
   1594c:	e0bfff17 	ldw	r2,-4(fp)
   15950:	10800017 	ldw	r2,0(r2)
   15954:	10800404 	addi	r2,r2,16
   15958:	1009883a 	mov	r4,r2
   1595c:	001b2f00 	call	1b2f0 <sys_sem_signal>
}
   15960:	e037883a 	mov	sp,fp
   15964:	dfc00117 	ldw	ra,4(sp)
   15968:	df000017 	ldw	fp,0(sp)
   1596c:	dec00204 	addi	sp,sp,8
   15970:	f800283a 	ret

00015974 <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
   15974:	defffd04 	addi	sp,sp,-12
   15978:	dfc00215 	stw	ra,8(sp)
   1597c:	df000115 	stw	fp,4(sp)
   15980:	df000104 	addi	fp,sp,4
   15984:	e13fff15 	stw	r4,-4(fp)
#if LWIP_TCP
  /* @todo: abort running write/connect? */
  if ((msg->conn->state != NETCONN_NONE) && (msg->conn->state != NETCONN_LISTEN)) {
   15988:	e0bfff17 	ldw	r2,-4(fp)
   1598c:	10800017 	ldw	r2,0(r2)
   15990:	10800117 	ldw	r2,4(r2)
   15994:	10000926 	beq	r2,zero,159bc <do_close+0x48>
   15998:	e0bfff17 	ldw	r2,-4(fp)
   1599c:	10800017 	ldw	r2,0(r2)
   159a0:	10800117 	ldw	r2,4(r2)
   159a4:	108000a0 	cmpeqi	r2,r2,2
   159a8:	1000041e 	bne	r2,zero,159bc <do_close+0x48>
    /* this only happens for TCP netconns */
    LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
    msg->err = ERR_INPROGRESS;
   159ac:	e0bfff17 	ldw	r2,-4(fp)
   159b0:	00fffec4 	movi	r3,-5
   159b4:	10c00105 	stb	r3,4(r2)
   159b8:	00003006 	br	15a7c <do_close+0x108>
  } else if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
   159bc:	e0bfff17 	ldw	r2,-4(fp)
   159c0:	10800017 	ldw	r2,0(r2)
   159c4:	10800217 	ldw	r2,8(r2)
   159c8:	10002926 	beq	r2,zero,15a70 <do_close+0xfc>
   159cc:	e0bfff17 	ldw	r2,-4(fp)
   159d0:	10800017 	ldw	r2,0(r2)
   159d4:	10800017 	ldw	r2,0(r2)
   159d8:	10800418 	cmpnei	r2,r2,16
   159dc:	1000241e 	bne	r2,zero,15a70 <do_close+0xfc>
    if ((msg->msg.sd.shut != NETCONN_SHUT_RDWR) && (msg->conn->state == NETCONN_LISTEN)) {
   159e0:	e0bfff17 	ldw	r2,-4(fp)
   159e4:	10800203 	ldbu	r2,8(r2)
   159e8:	10803fcc 	andi	r2,r2,255
   159ec:	108000e0 	cmpeqi	r2,r2,3
   159f0:	1000091e 	bne	r2,zero,15a18 <do_close+0xa4>
   159f4:	e0bfff17 	ldw	r2,-4(fp)
   159f8:	10800017 	ldw	r2,0(r2)
   159fc:	10800117 	ldw	r2,4(r2)
   15a00:	10800098 	cmpnei	r2,r2,2
   15a04:	1000041e 	bne	r2,zero,15a18 <do_close+0xa4>
      /* LISTEN doesn't support half shutdown */
      msg->err = ERR_CONN;
   15a08:	e0bfff17 	ldw	r2,-4(fp)
   15a0c:	00fffcc4 	movi	r3,-13
   15a10:	10c00105 	stb	r3,4(r2)
  if ((msg->conn->state != NETCONN_NONE) && (msg->conn->state != NETCONN_LISTEN)) {
    /* this only happens for TCP netconns */
    LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
    msg->err = ERR_INPROGRESS;
  } else if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
    if ((msg->msg.sd.shut != NETCONN_SHUT_RDWR) && (msg->conn->state == NETCONN_LISTEN)) {
   15a14:	00001906 	br	15a7c <do_close+0x108>
      /* LISTEN doesn't support half shutdown */
      msg->err = ERR_CONN;
    } else {
      if (msg->msg.sd.shut & NETCONN_SHUT_RD) {
   15a18:	e0bfff17 	ldw	r2,-4(fp)
   15a1c:	10800203 	ldbu	r2,8(r2)
   15a20:	10803fcc 	andi	r2,r2,255
   15a24:	1080004c 	andi	r2,r2,1
   15a28:	10000426 	beq	r2,zero,15a3c <do_close+0xc8>
        /* Drain and delete mboxes */
        netconn_drain(msg->conn);
   15a2c:	e0bfff17 	ldw	r2,-4(fp)
   15a30:	10800017 	ldw	r2,0(r2)
   15a34:	1009883a 	mov	r4,r2
   15a38:	00143200 	call	14320 <netconn_drain>
      }
      LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
        msg->conn->write_offset == 0);
      msg->conn->state = NETCONN_CLOSE;
   15a3c:	e0bfff17 	ldw	r2,-4(fp)
   15a40:	10800017 	ldw	r2,0(r2)
   15a44:	00c00104 	movi	r3,4
   15a48:	10c00115 	stw	r3,4(r2)
      msg->conn->current_msg = msg;
   15a4c:	e0bfff17 	ldw	r2,-4(fp)
   15a50:	10800017 	ldw	r2,0(r2)
   15a54:	e0ffff17 	ldw	r3,-4(fp)
   15a58:	10c00b15 	stw	r3,44(r2)
      do_close_internal(msg->conn);
   15a5c:	e0bfff17 	ldw	r2,-4(fp)
   15a60:	10800017 	ldw	r2,0(r2)
   15a64:	1009883a 	mov	r4,r2
   15a68:	00144980 	call	14498 <do_close_internal>
      /* for tcp netconns, do_close_internal ACKs the message */
      return;
   15a6c:	00000806 	br	15a90 <do_close+0x11c>
    }
  } else
#endif /* LWIP_TCP */
  {
    msg->err = ERR_VAL;
   15a70:	e0bfff17 	ldw	r2,-4(fp)
   15a74:	00fffe84 	movi	r3,-6
   15a78:	10c00105 	stb	r3,4(r2)
  }
  sys_sem_signal(&msg->conn->op_completed);
   15a7c:	e0bfff17 	ldw	r2,-4(fp)
   15a80:	10800017 	ldw	r2,0(r2)
   15a84:	10800404 	addi	r2,r2,16
   15a88:	1009883a 	mov	r4,r2
   15a8c:	001b2f00 	call	1b2f0 <sys_sem_signal>
}
   15a90:	e037883a 	mov	sp,fp
   15a94:	dfc00117 	ldw	ra,4(sp)
   15a98:	df000017 	ldw	fp,0(sp)
   15a9c:	dec00204 	addi	sp,sp,8
   15aa0:	f800283a 	ret

00015aa4 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
   15aa4:	defffd04 	addi	sp,sp,-12
   15aa8:	dfc00215 	stw	ra,8(sp)
   15aac:	df000115 	stw	fp,4(sp)
   15ab0:	df000104 	addi	fp,sp,4
  struct netbuf *buf;

  buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
   15ab4:	010001c4 	movi	r4,7
   15ab8:	00223cc0 	call	223cc <memp_malloc>
   15abc:	e0bfff15 	stw	r2,-4(fp)
  if (buf != NULL) {
   15ac0:	e0bfff17 	ldw	r2,-4(fp)
   15ac4:	10000e26 	beq	r2,zero,15b00 <netbuf_new+0x5c>
    buf->p = NULL;
   15ac8:	e0bfff17 	ldw	r2,-4(fp)
   15acc:	10000015 	stw	zero,0(r2)
    buf->ptr = NULL;
   15ad0:	e0bfff17 	ldw	r2,-4(fp)
   15ad4:	10000115 	stw	zero,4(r2)
    ip_addr_set_any(&buf->addr);
   15ad8:	e0bfff17 	ldw	r2,-4(fp)
   15adc:	10000215 	stw	zero,8(r2)
    buf->port = 0;
   15ae0:	e0bfff17 	ldw	r2,-4(fp)
   15ae4:	1000030d 	sth	zero,12(r2)
#if LWIP_NETBUF_RECVINFO || LWIP_CHECKSUM_ON_COPY
#if LWIP_CHECKSUM_ON_COPY
    buf->flags = 0;
   15ae8:	e0bfff17 	ldw	r2,-4(fp)
   15aec:	10000385 	stb	zero,14(r2)
#endif /* LWIP_CHECKSUM_ON_COPY */
    buf->toport_chksum = 0;
   15af0:	e0bfff17 	ldw	r2,-4(fp)
   15af4:	1000040d 	sth	zero,16(r2)
#if LWIP_NETBUF_RECVINFO
    ip_addr_set_any(&buf->toaddr);
#endif /* LWIP_NETBUF_RECVINFO */
#endif /* LWIP_NETBUF_RECVINFO || LWIP_CHECKSUM_ON_COPY */
    return buf;
   15af8:	e0bfff17 	ldw	r2,-4(fp)
   15afc:	00000106 	br	15b04 <netbuf_new+0x60>
  } else {
    return NULL;
   15b00:	0005883a 	mov	r2,zero
  }
}
   15b04:	e037883a 	mov	sp,fp
   15b08:	dfc00117 	ldw	ra,4(sp)
   15b0c:	df000017 	ldw	fp,0(sp)
   15b10:	dec00204 	addi	sp,sp,8
   15b14:	f800283a 	ret

00015b18 <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
   15b18:	defffd04 	addi	sp,sp,-12
   15b1c:	dfc00215 	stw	ra,8(sp)
   15b20:	df000115 	stw	fp,4(sp)
   15b24:	df000104 	addi	fp,sp,4
   15b28:	e13fff15 	stw	r4,-4(fp)
  if (buf != NULL) {
   15b2c:	e0bfff17 	ldw	r2,-4(fp)
   15b30:	10001026 	beq	r2,zero,15b74 <netbuf_delete+0x5c>
    if (buf->p != NULL) {
   15b34:	e0bfff17 	ldw	r2,-4(fp)
   15b38:	10800017 	ldw	r2,0(r2)
   15b3c:	10000a26 	beq	r2,zero,15b68 <netbuf_delete+0x50>
      pbuf_free(buf->p);
   15b40:	e0bfff17 	ldw	r2,-4(fp)
   15b44:	10800017 	ldw	r2,0(r2)
   15b48:	1009883a 	mov	r4,r2
   15b4c:	00237600 	call	23760 <pbuf_free>
      buf->p = buf->ptr = NULL;
   15b50:	e0bfff17 	ldw	r2,-4(fp)
   15b54:	10000115 	stw	zero,4(r2)
   15b58:	e0bfff17 	ldw	r2,-4(fp)
   15b5c:	10c00117 	ldw	r3,4(r2)
   15b60:	e0bfff17 	ldw	r2,-4(fp)
   15b64:	10c00015 	stw	r3,0(r2)
    }
    memp_free(MEMP_NETBUF, buf);
   15b68:	010001c4 	movi	r4,7
   15b6c:	e17fff17 	ldw	r5,-4(fp)
   15b70:	00225900 	call	22590 <memp_free>
  }
}
   15b74:	e037883a 	mov	sp,fp
   15b78:	dfc00117 	ldw	ra,4(sp)
   15b7c:	df000017 	ldw	fp,0(sp)
   15b80:	dec00204 	addi	sp,sp,8
   15b84:	f800283a 	ret

00015b88 <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
   15b88:	defffc04 	addi	sp,sp,-16
   15b8c:	dfc00315 	stw	ra,12(sp)
   15b90:	df000215 	stw	fp,8(sp)
   15b94:	df000204 	addi	fp,sp,8
   15b98:	e13ffe15 	stw	r4,-8(fp)
   15b9c:	2805883a 	mov	r2,r5
   15ba0:	e0bfff0d 	sth	r2,-4(fp)
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
   15ba4:	e0bffe17 	ldw	r2,-8(fp)
   15ba8:	1000091e 	bne	r2,zero,15bd0 <netbuf_alloc+0x48>
   15bac:	01000134 	movhi	r4,4
   15bb0:	21032a04 	addi	r4,r4,3240
   15bb4:	01400134 	movhi	r5,4
   15bb8:	29433604 	addi	r5,r5,3288
   15bbc:	01801b44 	movi	r6,109
   15bc0:	01c00134 	movhi	r7,4
   15bc4:	39c33d04 	addi	r7,r7,3316
   15bc8:	00044740 	call	4474 <printf>
   15bcc:	003fff06 	br	15bcc <netbuf_alloc+0x44>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
   15bd0:	e0bffe17 	ldw	r2,-8(fp)
   15bd4:	10800017 	ldw	r2,0(r2)
   15bd8:	10000426 	beq	r2,zero,15bec <netbuf_alloc+0x64>
    pbuf_free(buf->p);
   15bdc:	e0bffe17 	ldw	r2,-8(fp)
   15be0:	10800017 	ldw	r2,0(r2)
   15be4:	1009883a 	mov	r4,r2
   15be8:	00237600 	call	23760 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
   15bec:	e0bfff0b 	ldhu	r2,-4(fp)
   15bf0:	0009883a 	mov	r4,zero
   15bf4:	100b883a 	mov	r5,r2
   15bf8:	000d883a 	mov	r6,zero
   15bfc:	0022fa00 	call	22fa0 <pbuf_alloc>
   15c00:	e0fffe17 	ldw	r3,-8(fp)
   15c04:	18800015 	stw	r2,0(r3)
  if (buf->p == NULL) {
   15c08:	e0bffe17 	ldw	r2,-8(fp)
   15c0c:	10800017 	ldw	r2,0(r2)
   15c10:	1000021e 	bne	r2,zero,15c1c <netbuf_alloc+0x94>
     return NULL;
   15c14:	0005883a 	mov	r2,zero
   15c18:	00000706 	br	15c38 <netbuf_alloc+0xb0>
  }
  LWIP_ASSERT("check that first pbuf can hold size",
             (buf->p->len >= size));
  buf->ptr = buf->p;
   15c1c:	e0bffe17 	ldw	r2,-8(fp)
   15c20:	10c00017 	ldw	r3,0(r2)
   15c24:	e0bffe17 	ldw	r2,-8(fp)
   15c28:	10c00115 	stw	r3,4(r2)
  return buf->p->payload;
   15c2c:	e0bffe17 	ldw	r2,-8(fp)
   15c30:	10800017 	ldw	r2,0(r2)
   15c34:	10800117 	ldw	r2,4(r2)
}
   15c38:	e037883a 	mov	sp,fp
   15c3c:	dfc00117 	ldw	ra,4(sp)
   15c40:	df000017 	ldw	fp,0(sp)
   15c44:	dec00204 	addi	sp,sp,8
   15c48:	f800283a 	ret

00015c4c <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
   15c4c:	defffd04 	addi	sp,sp,-12
   15c50:	dfc00215 	stw	ra,8(sp)
   15c54:	df000115 	stw	fp,4(sp)
   15c58:	df000104 	addi	fp,sp,4
   15c5c:	e13fff15 	stw	r4,-4(fp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
   15c60:	e0bfff17 	ldw	r2,-4(fp)
   15c64:	1000091e 	bne	r2,zero,15c8c <netbuf_free+0x40>
   15c68:	01000134 	movhi	r4,4
   15c6c:	21032a04 	addi	r4,r4,3240
   15c70:	01400134 	movhi	r5,4
   15c74:	29434304 	addi	r5,r5,3340
   15c78:	01802144 	movi	r6,133
   15c7c:	01c00134 	movhi	r7,4
   15c80:	39c33d04 	addi	r7,r7,3316
   15c84:	00044740 	call	4474 <printf>
   15c88:	003fff06 	br	15c88 <netbuf_free+0x3c>
  if (buf->p != NULL) {
   15c8c:	e0bfff17 	ldw	r2,-4(fp)
   15c90:	10800017 	ldw	r2,0(r2)
   15c94:	10000426 	beq	r2,zero,15ca8 <netbuf_free+0x5c>
    pbuf_free(buf->p);
   15c98:	e0bfff17 	ldw	r2,-4(fp)
   15c9c:	10800017 	ldw	r2,0(r2)
   15ca0:	1009883a 	mov	r4,r2
   15ca4:	00237600 	call	23760 <pbuf_free>
  }
  buf->p = buf->ptr = NULL;
   15ca8:	e0bfff17 	ldw	r2,-4(fp)
   15cac:	10000115 	stw	zero,4(r2)
   15cb0:	e0bfff17 	ldw	r2,-4(fp)
   15cb4:	10c00117 	ldw	r3,4(r2)
   15cb8:	e0bfff17 	ldw	r2,-4(fp)
   15cbc:	10c00015 	stw	r3,0(r2)
}
   15cc0:	e037883a 	mov	sp,fp
   15cc4:	dfc00117 	ldw	ra,4(sp)
   15cc8:	df000017 	ldw	fp,0(sp)
   15ccc:	dec00204 	addi	sp,sp,8
   15cd0:	f800283a 	ret

00015cd4 <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
   15cd4:	defffb04 	addi	sp,sp,-20
   15cd8:	dfc00415 	stw	ra,16(sp)
   15cdc:	df000315 	stw	fp,12(sp)
   15ce0:	df000304 	addi	fp,sp,12
   15ce4:	e13ffd15 	stw	r4,-12(fp)
   15ce8:	e17ffe15 	stw	r5,-8(fp)
   15cec:	3005883a 	mov	r2,r6
   15cf0:	e0bfff0d 	sth	r2,-4(fp)
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
   15cf4:	e0bffd17 	ldw	r2,-12(fp)
   15cf8:	1000091e 	bne	r2,zero,15d20 <netbuf_ref+0x4c>
   15cfc:	01000134 	movhi	r4,4
   15d00:	21032a04 	addi	r4,r4,3240
   15d04:	01400134 	movhi	r5,4
   15d08:	29434a04 	addi	r5,r5,3368
   15d0c:	01802604 	movi	r6,152
   15d10:	01c00134 	movhi	r7,4
   15d14:	39c33d04 	addi	r7,r7,3316
   15d18:	00044740 	call	4474 <printf>
   15d1c:	003fff06 	br	15d1c <netbuf_ref+0x48>
  if (buf->p != NULL) {
   15d20:	e0bffd17 	ldw	r2,-12(fp)
   15d24:	10800017 	ldw	r2,0(r2)
   15d28:	10000426 	beq	r2,zero,15d3c <netbuf_ref+0x68>
    pbuf_free(buf->p);
   15d2c:	e0bffd17 	ldw	r2,-12(fp)
   15d30:	10800017 	ldw	r2,0(r2)
   15d34:	1009883a 	mov	r4,r2
   15d38:	00237600 	call	23760 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
   15d3c:	0009883a 	mov	r4,zero
   15d40:	000b883a 	mov	r5,zero
   15d44:	01800084 	movi	r6,2
   15d48:	0022fa00 	call	22fa0 <pbuf_alloc>
   15d4c:	e0fffd17 	ldw	r3,-12(fp)
   15d50:	18800015 	stw	r2,0(r3)
  if (buf->p == NULL) {
   15d54:	e0bffd17 	ldw	r2,-12(fp)
   15d58:	10800017 	ldw	r2,0(r2)
   15d5c:	1000041e 	bne	r2,zero,15d70 <netbuf_ref+0x9c>
    buf->ptr = NULL;
   15d60:	e0bffd17 	ldw	r2,-12(fp)
   15d64:	10000115 	stw	zero,4(r2)
    return ERR_MEM;
   15d68:	00bfffc4 	movi	r2,-1
   15d6c:	00001106 	br	15db4 <netbuf_ref+0xe0>
  }
  buf->p->payload = (void*)dataptr;
   15d70:	e0bffd17 	ldw	r2,-12(fp)
   15d74:	10800017 	ldw	r2,0(r2)
   15d78:	e0fffe17 	ldw	r3,-8(fp)
   15d7c:	10c00115 	stw	r3,4(r2)
  buf->p->len = buf->p->tot_len = size;
   15d80:	e0bffd17 	ldw	r2,-12(fp)
   15d84:	10c00017 	ldw	r3,0(r2)
   15d88:	e0bffd17 	ldw	r2,-12(fp)
   15d8c:	10800017 	ldw	r2,0(r2)
   15d90:	e13fff0b 	ldhu	r4,-4(fp)
   15d94:	1100020d 	sth	r4,8(r2)
   15d98:	1080020b 	ldhu	r2,8(r2)
   15d9c:	1880028d 	sth	r2,10(r3)
  buf->ptr = buf->p;
   15da0:	e0bffd17 	ldw	r2,-12(fp)
   15da4:	10c00017 	ldw	r3,0(r2)
   15da8:	e0bffd17 	ldw	r2,-12(fp)
   15dac:	10c00115 	stw	r3,4(r2)
  return ERR_OK;
   15db0:	0005883a 	mov	r2,zero
}
   15db4:	e037883a 	mov	sp,fp
   15db8:	dfc00117 	ldw	ra,4(sp)
   15dbc:	df000017 	ldw	fp,0(sp)
   15dc0:	dec00204 	addi	sp,sp,8
   15dc4:	f800283a 	ret

00015dc8 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head, freed by this function, may not be reference after returning
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
   15dc8:	defffc04 	addi	sp,sp,-16
   15dcc:	dfc00315 	stw	ra,12(sp)
   15dd0:	df000215 	stw	fp,8(sp)
   15dd4:	df000204 	addi	fp,sp,8
   15dd8:	e13ffe15 	stw	r4,-8(fp)
   15ddc:	e17fff15 	stw	r5,-4(fp)
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
   15de0:	e0bffe17 	ldw	r2,-8(fp)
   15de4:	1000091e 	bne	r2,zero,15e0c <netbuf_chain+0x44>
   15de8:	01000134 	movhi	r4,4
   15dec:	21032a04 	addi	r4,r4,3240
   15df0:	01400134 	movhi	r5,4
   15df4:	29435004 	addi	r5,r5,3392
   15df8:	01802c04 	movi	r6,176
   15dfc:	01c00134 	movhi	r7,4
   15e00:	39c33d04 	addi	r7,r7,3316
   15e04:	00044740 	call	4474 <printf>
   15e08:	003fff06 	br	15e08 <netbuf_chain+0x40>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
   15e0c:	e0bfff17 	ldw	r2,-4(fp)
   15e10:	1000091e 	bne	r2,zero,15e38 <netbuf_chain+0x70>
   15e14:	01000134 	movhi	r4,4
   15e18:	21032a04 	addi	r4,r4,3240
   15e1c:	01400134 	movhi	r5,4
   15e20:	29435704 	addi	r5,r5,3420
   15e24:	01802c44 	movi	r6,177
   15e28:	01c00134 	movhi	r7,4
   15e2c:	39c33d04 	addi	r7,r7,3316
   15e30:	00044740 	call	4474 <printf>
   15e34:	003fff06 	br	15e34 <netbuf_chain+0x6c>
  pbuf_cat(head->p, tail->p);
   15e38:	e0bffe17 	ldw	r2,-8(fp)
   15e3c:	10c00017 	ldw	r3,0(r2)
   15e40:	e0bfff17 	ldw	r2,-4(fp)
   15e44:	10800017 	ldw	r2,0(r2)
   15e48:	1809883a 	mov	r4,r3
   15e4c:	100b883a 	mov	r5,r2
   15e50:	00239500 	call	23950 <pbuf_cat>
  head->ptr = head->p;
   15e54:	e0bffe17 	ldw	r2,-8(fp)
   15e58:	10c00017 	ldw	r3,0(r2)
   15e5c:	e0bffe17 	ldw	r2,-8(fp)
   15e60:	10c00115 	stw	r3,4(r2)
  memp_free(MEMP_NETBUF, tail);
   15e64:	010001c4 	movi	r4,7
   15e68:	e17fff17 	ldw	r5,-4(fp)
   15e6c:	00225900 	call	22590 <memp_free>
}
   15e70:	e037883a 	mov	sp,fp
   15e74:	dfc00117 	ldw	ra,4(sp)
   15e78:	df000017 	ldw	fp,0(sp)
   15e7c:	dec00204 	addi	sp,sp,8
   15e80:	f800283a 	ret

00015e84 <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
   15e84:	defffb04 	addi	sp,sp,-20
   15e88:	dfc00415 	stw	ra,16(sp)
   15e8c:	df000315 	stw	fp,12(sp)
   15e90:	df000304 	addi	fp,sp,12
   15e94:	e13ffd15 	stw	r4,-12(fp)
   15e98:	e17ffe15 	stw	r5,-8(fp)
   15e9c:	e1bfff15 	stw	r6,-4(fp)
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
   15ea0:	e0bffd17 	ldw	r2,-12(fp)
   15ea4:	1000091e 	bne	r2,zero,15ecc <netbuf_data+0x48>
   15ea8:	01000134 	movhi	r4,4
   15eac:	21032a04 	addi	r4,r4,3240
   15eb0:	01400134 	movhi	r5,4
   15eb4:	29435e04 	addi	r5,r5,3448
   15eb8:	018030c4 	movi	r6,195
   15ebc:	01c00134 	movhi	r7,4
   15ec0:	39c33d04 	addi	r7,r7,3316
   15ec4:	00044740 	call	4474 <printf>
   15ec8:	003fff06 	br	15ec8 <netbuf_data+0x44>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
   15ecc:	e0bffe17 	ldw	r2,-8(fp)
   15ed0:	1000091e 	bne	r2,zero,15ef8 <netbuf_data+0x74>
   15ed4:	01000134 	movhi	r4,4
   15ed8:	21032a04 	addi	r4,r4,3240
   15edc:	01400134 	movhi	r5,4
   15ee0:	29436504 	addi	r5,r5,3476
   15ee4:	01803104 	movi	r6,196
   15ee8:	01c00134 	movhi	r7,4
   15eec:	39c33d04 	addi	r7,r7,3316
   15ef0:	00044740 	call	4474 <printf>
   15ef4:	003fff06 	br	15ef4 <netbuf_data+0x70>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
   15ef8:	e0bfff17 	ldw	r2,-4(fp)
   15efc:	1000091e 	bne	r2,zero,15f24 <netbuf_data+0xa0>
   15f00:	01000134 	movhi	r4,4
   15f04:	21032a04 	addi	r4,r4,3240
   15f08:	01400134 	movhi	r5,4
   15f0c:	29436d04 	addi	r5,r5,3508
   15f10:	01803144 	movi	r6,197
   15f14:	01c00134 	movhi	r7,4
   15f18:	39c33d04 	addi	r7,r7,3316
   15f1c:	00044740 	call	4474 <printf>
   15f20:	003fff06 	br	15f20 <netbuf_data+0x9c>

  if (buf->ptr == NULL) {
   15f24:	e0bffd17 	ldw	r2,-12(fp)
   15f28:	10800117 	ldw	r2,4(r2)
   15f2c:	1000021e 	bne	r2,zero,15f38 <netbuf_data+0xb4>
    return ERR_BUF;
   15f30:	00bfff84 	movi	r2,-2
   15f34:	00000b06 	br	15f64 <netbuf_data+0xe0>
  }
  *dataptr = buf->ptr->payload;
   15f38:	e0bffd17 	ldw	r2,-12(fp)
   15f3c:	10800117 	ldw	r2,4(r2)
   15f40:	10c00117 	ldw	r3,4(r2)
   15f44:	e0bffe17 	ldw	r2,-8(fp)
   15f48:	10c00015 	stw	r3,0(r2)
  *len = buf->ptr->len;
   15f4c:	e0bffd17 	ldw	r2,-12(fp)
   15f50:	10800117 	ldw	r2,4(r2)
   15f54:	10c0028b 	ldhu	r3,10(r2)
   15f58:	e0bfff17 	ldw	r2,-4(fp)
   15f5c:	10c0000d 	sth	r3,0(r2)
  return ERR_OK;
   15f60:	0005883a 	mov	r2,zero
}
   15f64:	e037883a 	mov	sp,fp
   15f68:	dfc00117 	ldw	ra,4(sp)
   15f6c:	df000017 	ldw	fp,0(sp)
   15f70:	dec00204 	addi	sp,sp,8
   15f74:	f800283a 	ret

00015f78 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
   15f78:	defffd04 	addi	sp,sp,-12
   15f7c:	dfc00215 	stw	ra,8(sp)
   15f80:	df000115 	stw	fp,4(sp)
   15f84:	df000104 	addi	fp,sp,4
   15f88:	e13fff15 	stw	r4,-4(fp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
   15f8c:	e0bfff17 	ldw	r2,-4(fp)
   15f90:	1000091e 	bne	r2,zero,15fb8 <netbuf_next+0x40>
   15f94:	01000134 	movhi	r4,4
   15f98:	21032a04 	addi	r4,r4,3240
   15f9c:	01400134 	movhi	r5,4
   15fa0:	29434304 	addi	r5,r5,3340
   15fa4:	01803704 	movi	r6,220
   15fa8:	01c00134 	movhi	r7,4
   15fac:	39c33d04 	addi	r7,r7,3316
   15fb0:	00044740 	call	4474 <printf>
   15fb4:	003fff06 	br	15fb4 <netbuf_next+0x3c>
  if (buf->ptr->next == NULL) {
   15fb8:	e0bfff17 	ldw	r2,-4(fp)
   15fbc:	10800117 	ldw	r2,4(r2)
   15fc0:	10800017 	ldw	r2,0(r2)
   15fc4:	1000021e 	bne	r2,zero,15fd0 <netbuf_next+0x58>
    return -1;
   15fc8:	00bfffc4 	movi	r2,-1
   15fcc:	00000c06 	br	16000 <netbuf_next+0x88>
  }
  buf->ptr = buf->ptr->next;
   15fd0:	e0bfff17 	ldw	r2,-4(fp)
   15fd4:	10800117 	ldw	r2,4(r2)
   15fd8:	10c00017 	ldw	r3,0(r2)
   15fdc:	e0bfff17 	ldw	r2,-4(fp)
   15fe0:	10c00115 	stw	r3,4(r2)
  if (buf->ptr->next == NULL) {
   15fe4:	e0bfff17 	ldw	r2,-4(fp)
   15fe8:	10800117 	ldw	r2,4(r2)
   15fec:	10800017 	ldw	r2,0(r2)
   15ff0:	1000021e 	bne	r2,zero,15ffc <netbuf_next+0x84>
    return 1;
   15ff4:	00800044 	movi	r2,1
   15ff8:	00000106 	br	16000 <netbuf_next+0x88>
  }
  return 0;
   15ffc:	0005883a 	mov	r2,zero
}
   16000:	e037883a 	mov	sp,fp
   16004:	dfc00117 	ldw	ra,4(sp)
   16008:	df000017 	ldw	fp,0(sp)
   1600c:	dec00204 	addi	sp,sp,8
   16010:	f800283a 	ret

00016014 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
   16014:	defffd04 	addi	sp,sp,-12
   16018:	dfc00215 	stw	ra,8(sp)
   1601c:	df000115 	stw	fp,4(sp)
   16020:	df000104 	addi	fp,sp,4
   16024:	e13fff15 	stw	r4,-4(fp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
   16028:	e0bfff17 	ldw	r2,-4(fp)
   1602c:	1000091e 	bne	r2,zero,16054 <netbuf_first+0x40>
   16030:	01000134 	movhi	r4,4
   16034:	21032a04 	addi	r4,r4,3240
   16038:	01400134 	movhi	r5,4
   1603c:	29434304 	addi	r5,r5,3340
   16040:	01803c44 	movi	r6,241
   16044:	01c00134 	movhi	r7,4
   16048:	39c33d04 	addi	r7,r7,3316
   1604c:	00044740 	call	4474 <printf>
   16050:	003fff06 	br	16050 <netbuf_first+0x3c>
  buf->ptr = buf->p;
   16054:	e0bfff17 	ldw	r2,-4(fp)
   16058:	10c00017 	ldw	r3,0(r2)
   1605c:	e0bfff17 	ldw	r2,-4(fp)
   16060:	10c00115 	stw	r3,4(r2)
}
   16064:	e037883a 	mov	sp,fp
   16068:	dfc00117 	ldw	ra,4(sp)
   1606c:	df000017 	ldw	fp,0(sp)
   16070:	dec00204 	addi	sp,sp,8
   16074:	f800283a 	ret

00016078 <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
   16078:	deffff04 	addi	sp,sp,-4
   1607c:	df000015 	stw	fp,0(sp)
   16080:	d839883a 	mov	fp,sp
}
   16084:	e037883a 	mov	sp,fp
   16088:	df000017 	ldw	fp,0(sp)
   1608c:	dec00104 	addi	sp,sp,4
   16090:	f800283a 	ret

00016094 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_sock for the socket or NULL if not found
 */
static struct lwip_sock *
get_socket(int s)
{
   16094:	defffd04 	addi	sp,sp,-12
   16098:	df000215 	stw	fp,8(sp)
   1609c:	df000204 	addi	fp,sp,8
   160a0:	e13fff15 	stw	r4,-4(fp)
  struct lwip_sock *sock;

  s -= LWIP_SOCKET_OFFSET;
   160a4:	e0bfff17 	ldw	r2,-4(fp)
   160a8:	10bff804 	addi	r2,r2,-32
   160ac:	e0bfff15 	stw	r2,-4(fp)

  if ((s < 0) || (s >= NUM_SOCKETS)) {
   160b0:	e0bfff17 	ldw	r2,-4(fp)
   160b4:	10000316 	blt	r2,zero,160c4 <get_socket+0x30>
   160b8:	e0bfff17 	ldw	r2,-4(fp)
   160bc:	10800a90 	cmplti	r2,r2,42
   160c0:	1000021e 	bne	r2,zero,160cc <get_socket+0x38>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
    return NULL;
   160c4:	0005883a 	mov	r2,zero
   160c8:	00000c06 	br	160fc <get_socket+0x68>
  }

  sock = &sockets[s];
   160cc:	e0bfff17 	ldw	r2,-4(fp)
   160d0:	10c00624 	muli	r3,r2,24
   160d4:	00800134 	movhi	r2,4
   160d8:	109f6c04 	addi	r2,r2,32176
   160dc:	1885883a 	add	r2,r3,r2
   160e0:	e0bffe15 	stw	r2,-8(fp)

  if (!sock->conn) {
   160e4:	e0bffe17 	ldw	r2,-8(fp)
   160e8:	10800017 	ldw	r2,0(r2)
   160ec:	1000021e 	bne	r2,zero,160f8 <get_socket+0x64>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
    return NULL;
   160f0:	0005883a 	mov	r2,zero
   160f4:	00000106 	br	160fc <get_socket+0x68>
  }

  return sock;
   160f8:	e0bffe17 	ldw	r2,-8(fp)
}
   160fc:	e037883a 	mov	sp,fp
   16100:	df000017 	ldw	fp,0(sp)
   16104:	dec00104 	addi	sp,sp,4
   16108:	f800283a 	ret

0001610c <tryget_socket>:
 * @param s externally used socket index
 * @return struct lwip_sock for the socket or NULL if not found
 */
static struct lwip_sock *
tryget_socket(int s)
{
   1610c:	defffe04 	addi	sp,sp,-8
   16110:	df000115 	stw	fp,4(sp)
   16114:	df000104 	addi	fp,sp,4
   16118:	e13fff15 	stw	r4,-4(fp)
	s -= LWIP_SOCKET_OFFSET;
   1611c:	e0bfff17 	ldw	r2,-4(fp)
   16120:	10bff804 	addi	r2,r2,-32
   16124:	e0bfff15 	stw	r2,-4(fp)

  if ((s < 0) || (s >= NUM_SOCKETS)) {
   16128:	e0bfff17 	ldw	r2,-4(fp)
   1612c:	10000316 	blt	r2,zero,1613c <tryget_socket+0x30>
   16130:	e0bfff17 	ldw	r2,-4(fp)
   16134:	10800a90 	cmplti	r2,r2,42
   16138:	1000021e 	bne	r2,zero,16144 <tryget_socket+0x38>
    return NULL;
   1613c:	0005883a 	mov	r2,zero
   16140:	00000e06 	br	1617c <tryget_socket+0x70>
  }
  if (!sockets[s].conn) {
   16144:	00c00134 	movhi	r3,4
   16148:	18df6c04 	addi	r3,r3,32176
   1614c:	e0bfff17 	ldw	r2,-4(fp)
   16150:	10800624 	muli	r2,r2,24
   16154:	1885883a 	add	r2,r3,r2
   16158:	10800017 	ldw	r2,0(r2)
   1615c:	1000021e 	bne	r2,zero,16168 <tryget_socket+0x5c>
    return NULL;
   16160:	0005883a 	mov	r2,zero
   16164:	00000506 	br	1617c <tryget_socket+0x70>
  }
  return &sockets[s];
   16168:	e0bfff17 	ldw	r2,-4(fp)
   1616c:	10c00624 	muli	r3,r2,24
   16170:	00800134 	movhi	r2,4
   16174:	109f6c04 	addi	r2,r2,32176
   16178:	1885883a 	add	r2,r3,r2
}
   1617c:	e037883a 	mov	sp,fp
   16180:	df000017 	ldw	fp,0(sp)
   16184:	dec00104 	addi	sp,sp,4
   16188:	f800283a 	ret

0001618c <alloc_socket>:
 *                 0 if socket has been created by socket()
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn, int accepted)
{
   1618c:	defffb04 	addi	sp,sp,-20
   16190:	dfc00415 	stw	ra,16(sp)
   16194:	df000315 	stw	fp,12(sp)
   16198:	df000304 	addi	fp,sp,12
   1619c:	e13ffe15 	stw	r4,-8(fp)
   161a0:	e17fff15 	stw	r5,-4(fp)
  int i;
  SYS_ARCH_DECL_PROTECT(lev);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
   161a4:	e03ffd15 	stw	zero,-12(fp)
   161a8:	00005706 	br	16308 <alloc_socket+0x17c>
    /* Protect socket array */
    SYS_ARCH_PROTECT(lev);
   161ac:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   161b0:	10000126 	beq	r2,zero,161b8 <alloc_socket+0x2c>
   161b4:	00110d00 	call	110d0 <vTaskEnterCritical>
    if (!sockets[i].conn) {
   161b8:	00c00134 	movhi	r3,4
   161bc:	18df6c04 	addi	r3,r3,32176
   161c0:	e0bffd17 	ldw	r2,-12(fp)
   161c4:	10800624 	muli	r2,r2,24
   161c8:	1885883a 	add	r2,r3,r2
   161cc:	10800017 	ldw	r2,0(r2)
   161d0:	1000471e 	bne	r2,zero,162f0 <alloc_socket+0x164>
      sockets[i].conn       = newconn;
   161d4:	00c00134 	movhi	r3,4
   161d8:	18df6c04 	addi	r3,r3,32176
   161dc:	e0bffd17 	ldw	r2,-12(fp)
   161e0:	10800624 	muli	r2,r2,24
   161e4:	1885883a 	add	r2,r3,r2
   161e8:	e0fffe17 	ldw	r3,-8(fp)
   161ec:	10c00015 	stw	r3,0(r2)
      /* The socket is not yet known to anyone, so no need to protect
         after having marked it as used. */
      SYS_ARCH_UNPROTECT(lev);
   161f0:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   161f4:	10000126 	beq	r2,zero,161fc <alloc_socket+0x70>
   161f8:	00111100 	call	11110 <vTaskExitCritical>
      sockets[i].lastdata   = NULL;
   161fc:	00c00134 	movhi	r3,4
   16200:	18df6c04 	addi	r3,r3,32176
   16204:	e0bffd17 	ldw	r2,-12(fp)
   16208:	10800624 	muli	r2,r2,24
   1620c:	1885883a 	add	r2,r3,r2
   16210:	10800104 	addi	r2,r2,4
   16214:	10000015 	stw	zero,0(r2)
      sockets[i].lastoffset = 0;
   16218:	00c00134 	movhi	r3,4
   1621c:	18df6c04 	addi	r3,r3,32176
   16220:	e0bffd17 	ldw	r2,-12(fp)
   16224:	10800624 	muli	r2,r2,24
   16228:	1885883a 	add	r2,r3,r2
   1622c:	10800204 	addi	r2,r2,8
   16230:	1000000d 	sth	zero,0(r2)
      sockets[i].rcvevent   = 0;
   16234:	00c00134 	movhi	r3,4
   16238:	18df6c04 	addi	r3,r3,32176
   1623c:	e0bffd17 	ldw	r2,-12(fp)
   16240:	10800624 	muli	r2,r2,24
   16244:	1885883a 	add	r2,r3,r2
   16248:	10800204 	addi	r2,r2,8
   1624c:	1000008d 	sth	zero,2(r2)
      /* TCP sendbuf is empty, but the socket is not yet writable until connected
       * (unless it has been created by accept()). */
      sockets[i].sendevent  = (newconn->type == NETCONN_TCP ? (accepted != 0) : 1);
   16250:	e0bffe17 	ldw	r2,-8(fp)
   16254:	10800017 	ldw	r2,0(r2)
   16258:	10800418 	cmpnei	r2,r2,16
   1625c:	1000021e 	bne	r2,zero,16268 <alloc_socket+0xdc>
   16260:	e0bfff17 	ldw	r2,-4(fp)
   16264:	10000226 	beq	r2,zero,16270 <alloc_socket+0xe4>
   16268:	00800044 	movi	r2,1
   1626c:	00000106 	br	16274 <alloc_socket+0xe8>
   16270:	0005883a 	mov	r2,zero
   16274:	1007883a 	mov	r3,r2
   16278:	01000134 	movhi	r4,4
   1627c:	211f6c04 	addi	r4,r4,32176
   16280:	e0bffd17 	ldw	r2,-12(fp)
   16284:	10800624 	muli	r2,r2,24
   16288:	2085883a 	add	r2,r4,r2
   1628c:	10800304 	addi	r2,r2,12
   16290:	10c0000d 	sth	r3,0(r2)
      sockets[i].errevent   = 0;
   16294:	00c00134 	movhi	r3,4
   16298:	18df6c04 	addi	r3,r3,32176
   1629c:	e0bffd17 	ldw	r2,-12(fp)
   162a0:	10800624 	muli	r2,r2,24
   162a4:	1885883a 	add	r2,r3,r2
   162a8:	10800304 	addi	r2,r2,12
   162ac:	1000008d 	sth	zero,2(r2)
      sockets[i].err        = 0;
   162b0:	00c00134 	movhi	r3,4
   162b4:	18df6c04 	addi	r3,r3,32176
   162b8:	e0bffd17 	ldw	r2,-12(fp)
   162bc:	10800624 	muli	r2,r2,24
   162c0:	1885883a 	add	r2,r3,r2
   162c4:	10800404 	addi	r2,r2,16
   162c8:	10000015 	stw	zero,0(r2)
      sockets[i].select_waiting = 0;
   162cc:	00c00134 	movhi	r3,4
   162d0:	18df6c04 	addi	r3,r3,32176
   162d4:	e0bffd17 	ldw	r2,-12(fp)
   162d8:	10800624 	muli	r2,r2,24
   162dc:	1885883a 	add	r2,r3,r2
   162e0:	10800504 	addi	r2,r2,20
   162e4:	10000015 	stw	zero,0(r2)
      return i;
   162e8:	e0bffd17 	ldw	r2,-12(fp)
   162ec:	00000a06 	br	16318 <alloc_socket+0x18c>
    }
    SYS_ARCH_UNPROTECT(lev);
   162f0:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   162f4:	10000126 	beq	r2,zero,162fc <alloc_socket+0x170>
   162f8:	00111100 	call	11110 <vTaskExitCritical>
{
  int i;
  SYS_ARCH_DECL_PROTECT(lev);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
   162fc:	e0bffd17 	ldw	r2,-12(fp)
   16300:	10800044 	addi	r2,r2,1
   16304:	e0bffd15 	stw	r2,-12(fp)
   16308:	e0bffd17 	ldw	r2,-12(fp)
   1630c:	10800a90 	cmplti	r2,r2,42
   16310:	103fa61e 	bne	r2,zero,161ac <alloc_socket+0x20>
      sockets[i].select_waiting = 0;
      return i;
    }
    SYS_ARCH_UNPROTECT(lev);
  }
  return -1;
   16314:	00bfffc4 	movi	r2,-1
}
   16318:	e037883a 	mov	sp,fp
   1631c:	dfc00117 	ldw	ra,4(sp)
   16320:	df000017 	ldw	fp,0(sp)
   16324:	dec00204 	addi	sp,sp,8
   16328:	f800283a 	ret

0001632c <free_socket>:
 * @param sock the socket to free
 * @param is_tcp != 0 for TCP sockets, used to free lastdata
 */
static void
free_socket(struct lwip_sock *sock, int is_tcp)
{
   1632c:	defffb04 	addi	sp,sp,-20
   16330:	dfc00415 	stw	ra,16(sp)
   16334:	df000315 	stw	fp,12(sp)
   16338:	df000304 	addi	fp,sp,12
   1633c:	e13ffe15 	stw	r4,-8(fp)
   16340:	e17fff15 	stw	r5,-4(fp)
  void *lastdata;
  SYS_ARCH_DECL_PROTECT(lev);

  lastdata         = sock->lastdata;
   16344:	e0bffe17 	ldw	r2,-8(fp)
   16348:	10800117 	ldw	r2,4(r2)
   1634c:	e0bffd15 	stw	r2,-12(fp)
  sock->lastdata   = NULL;
   16350:	e0bffe17 	ldw	r2,-8(fp)
   16354:	10000115 	stw	zero,4(r2)
  sock->lastoffset = 0;
   16358:	e0bffe17 	ldw	r2,-8(fp)
   1635c:	1000020d 	sth	zero,8(r2)
  sock->err        = 0;
   16360:	e0bffe17 	ldw	r2,-8(fp)
   16364:	10000415 	stw	zero,16(r2)

  /* Protect socket array */
  SYS_ARCH_PROTECT(lev);
   16368:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   1636c:	10000126 	beq	r2,zero,16374 <free_socket+0x48>
   16370:	00110d00 	call	110d0 <vTaskEnterCritical>
  sock->conn       = NULL;
   16374:	e0bffe17 	ldw	r2,-8(fp)
   16378:	10000015 	stw	zero,0(r2)
  SYS_ARCH_UNPROTECT(lev);
   1637c:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   16380:	10000126 	beq	r2,zero,16388 <free_socket+0x5c>
   16384:	00111100 	call	11110 <vTaskExitCritical>
  /* don't use 'sock' after this line, as another task might have allocated it */

  if (lastdata != NULL) {
   16388:	e0bffd17 	ldw	r2,-12(fp)
   1638c:	10000726 	beq	r2,zero,163ac <free_socket+0x80>
    if (is_tcp) {
   16390:	e0bfff17 	ldw	r2,-4(fp)
   16394:	10000326 	beq	r2,zero,163a4 <free_socket+0x78>
      pbuf_free((struct pbuf *)lastdata);
   16398:	e13ffd17 	ldw	r4,-12(fp)
   1639c:	00237600 	call	23760 <pbuf_free>
   163a0:	00000206 	br	163ac <free_socket+0x80>
    } else {
      netbuf_delete((struct netbuf *)lastdata);
   163a4:	e13ffd17 	ldw	r4,-12(fp)
   163a8:	0015b180 	call	15b18 <netbuf_delete>
    }
  }
}
   163ac:	e037883a 	mov	sp,fp
   163b0:	dfc00117 	ldw	ra,4(sp)
   163b4:	df000017 	ldw	fp,0(sp)
   163b8:	dec00204 	addi	sp,sp,8
   163bc:	f800283a 	ret

000163c0 <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
   163c0:	defff004 	addi	sp,sp,-64
   163c4:	dfc00f15 	stw	ra,60(sp)
   163c8:	df000e15 	stw	fp,56(sp)
   163cc:	df000e04 	addi	fp,sp,56
   163d0:	e13ffd15 	stw	r4,-12(fp)
   163d4:	e17ffe15 	stw	r5,-8(fp)
   163d8:	e1bfff15 	stw	r6,-4(fp)
  struct sockaddr_in sin;
  err_t err;
  SYS_ARCH_DECL_PROTECT(lev);

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
   163dc:	e13ffd17 	ldw	r4,-12(fp)
   163e0:	00160940 	call	16094 <get_socket>
   163e4:	e0bff215 	stw	r2,-56(fp)
  if (!sock) {
   163e8:	e0bff217 	ldw	r2,-56(fp)
   163ec:	1000021e 	bne	r2,zero,163f8 <lwip_accept+0x38>
    return -1;
   163f0:	00bfffc4 	movi	r2,-1
   163f4:	0000ad06 	br	166ac <lwip_accept+0x2ec>
  }

  if (netconn_is_nonblocking(sock->conn) && (sock->rcvevent <= 0)) {
   163f8:	e0bff217 	ldw	r2,-56(fp)
   163fc:	10800017 	ldw	r2,0(r2)
   16400:	10800903 	ldbu	r2,36(r2)
   16404:	10803fcc 	andi	r2,r2,255
   16408:	1080008c 	andi	r2,r2,2
   1640c:	10000b26 	beq	r2,zero,1643c <lwip_accept+0x7c>
   16410:	e0bff217 	ldw	r2,-56(fp)
   16414:	1080028b 	ldhu	r2,10(r2)
   16418:	10bfffcc 	andi	r2,r2,65535
   1641c:	10a0001c 	xori	r2,r2,32768
   16420:	10a00004 	addi	r2,r2,-32768
   16424:	00800516 	blt	zero,r2,1643c <lwip_accept+0x7c>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): returning EWOULDBLOCK\n", s));
    sock_set_errno(sock, EWOULDBLOCK);
   16428:	e0bff217 	ldw	r2,-56(fp)
   1642c:	00c002c4 	movi	r3,11
   16430:	10c00415 	stw	r3,16(r2)
    return -1;
   16434:	00bfffc4 	movi	r2,-1
   16438:	00009c06 	br	166ac <lwip_accept+0x2ec>
  }

  /* wait for a new connection */
  err = netconn_accept(sock->conn, &newconn);
   1643c:	e0bff217 	ldw	r2,-56(fp)
   16440:	10c00017 	ldw	r3,0(r2)
   16444:	e0bff604 	addi	r2,fp,-40
   16448:	1809883a 	mov	r4,r3
   1644c:	100b883a 	mov	r5,r2
   16450:	0012ac80 	call	12ac8 <netconn_accept>
   16454:	e0bff305 	stb	r2,-52(fp)
  if (err != ERR_OK) {
   16458:	e0bff307 	ldb	r2,-52(fp)
   1645c:	10001c26 	beq	r2,zero,164d0 <lwip_accept+0x110>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): netconn_acept failed, err=%d\n", s, err));
    if (netconn_type(sock->conn) != NETCONN_TCP) {
   16460:	e0bff217 	ldw	r2,-56(fp)
   16464:	10800017 	ldw	r2,0(r2)
   16468:	10800017 	ldw	r2,0(r2)
   1646c:	10800420 	cmpeqi	r2,r2,16
   16470:	1000051e 	bne	r2,zero,16488 <lwip_accept+0xc8>
      sock_set_errno(sock, EOPNOTSUPP);
   16474:	e0bff217 	ldw	r2,-56(fp)
   16478:	00c017c4 	movi	r3,95
   1647c:	10c00415 	stw	r3,16(r2)
      return EOPNOTSUPP;
   16480:	008017c4 	movi	r2,95
   16484:	00008906 	br	166ac <lwip_accept+0x2ec>
    }
    sock_set_errno(sock, err_to_errno(err));
   16488:	e0bff307 	ldb	r2,-52(fp)
   1648c:	0085c83a 	sub	r2,zero,r2
   16490:	10800428 	cmpgeui	r2,r2,16
   16494:	1000091e 	bne	r2,zero,164bc <lwip_accept+0xfc>
   16498:	e0bff307 	ldb	r2,-52(fp)
   1649c:	0085c83a 	sub	r2,zero,r2
   164a0:	00c00134 	movhi	r3,4
   164a4:	18c37404 	addi	r3,r3,3536
   164a8:	1085883a 	add	r2,r2,r2
   164ac:	1085883a 	add	r2,r2,r2
   164b0:	1885883a 	add	r2,r3,r2
   164b4:	10800017 	ldw	r2,0(r2)
   164b8:	00000106 	br	164c0 <lwip_accept+0x100>
   164bc:	00800144 	movi	r2,5
   164c0:	e0fff217 	ldw	r3,-56(fp)
   164c4:	18800415 	stw	r2,16(r3)
    return -1;
   164c8:	00bfffc4 	movi	r2,-1
   164cc:	00007706 	br	166ac <lwip_accept+0x2ec>
  }
  LWIP_ASSERT("newconn != NULL", newconn != NULL);
  /* Prevent automatic window updates, we do this on our own! */
  netconn_set_noautorecved(newconn, 1);
   164d0:	e0bff617 	ldw	r2,-40(fp)
   164d4:	e0fff617 	ldw	r3,-40(fp)
   164d8:	18c00903 	ldbu	r3,36(r3)
   164dc:	18c00214 	ori	r3,r3,8
   164e0:	10c00905 	stb	r3,36(r2)

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
   164e4:	e13ff617 	ldw	r4,-40(fp)
   164e8:	e0fff704 	addi	r3,fp,-36
   164ec:	e0bff804 	addi	r2,fp,-32
   164f0:	180b883a 	mov	r5,r3
   164f4:	100d883a 	mov	r6,r2
   164f8:	000f883a 	mov	r7,zero
   164fc:	00126540 	call	12654 <netconn_getaddr>
   16500:	e0bff305 	stb	r2,-52(fp)
  if (err != ERR_OK) {
   16504:	e0bff307 	ldb	r2,-52(fp)
   16508:	10001526 	beq	r2,zero,16560 <lwip_accept+0x1a0>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): netconn_peer failed, err=%d\n", s, err));
    netconn_delete(newconn);
   1650c:	e0bff617 	ldw	r2,-40(fp)
   16510:	1009883a 	mov	r4,r2
   16514:	00125f40 	call	125f4 <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
   16518:	e0bff307 	ldb	r2,-52(fp)
   1651c:	0085c83a 	sub	r2,zero,r2
   16520:	10800428 	cmpgeui	r2,r2,16
   16524:	1000091e 	bne	r2,zero,1654c <lwip_accept+0x18c>
   16528:	e0bff307 	ldb	r2,-52(fp)
   1652c:	0085c83a 	sub	r2,zero,r2
   16530:	00c00134 	movhi	r3,4
   16534:	18c37404 	addi	r3,r3,3536
   16538:	1085883a 	add	r2,r2,r2
   1653c:	1085883a 	add	r2,r2,r2
   16540:	1885883a 	add	r2,r3,r2
   16544:	10800017 	ldw	r2,0(r2)
   16548:	00000106 	br	16550 <lwip_accept+0x190>
   1654c:	00800144 	movi	r2,5
   16550:	e0fff217 	ldw	r3,-56(fp)
   16554:	18800415 	stw	r2,16(r3)
    return -1;
   16558:	00bfffc4 	movi	r2,-1
   1655c:	00005306 	br	166ac <lwip_accept+0x2ec>
  }

  /* Note that POSIX only requires us to check addr is non-NULL. addrlen must
   * not be NULL if addr is valid.
   */
  if (NULL != addr) {
   16560:	e0bffe17 	ldw	r2,-8(fp)
   16564:	10002226 	beq	r2,zero,165f0 <lwip_accept+0x230>
    LWIP_ASSERT("addr valid but addrlen NULL", addrlen != NULL);
    memset(&sin, 0, sizeof(sin));
   16568:	e0bff904 	addi	r2,fp,-28
   1656c:	1009883a 	mov	r4,r2
   16570:	000b883a 	mov	r5,zero
   16574:	01800404 	movi	r6,16
   16578:	00042e80 	call	42e8 <memset>
    sin.sin_len = sizeof(sin);
   1657c:	00800404 	movi	r2,16
   16580:	e0bff905 	stb	r2,-28(fp)
    sin.sin_family = AF_INET;
   16584:	00800084 	movi	r2,2
   16588:	e0bff945 	stb	r2,-27(fp)
    sin.sin_port = htons(port);
   1658c:	e0bff80b 	ldhu	r2,-32(fp)
   16590:	10bfffcc 	andi	r2,r2,65535
   16594:	1004d23a 	srli	r2,r2,8
   16598:	1007883a 	mov	r3,r2
   1659c:	e0bff80b 	ldhu	r2,-32(fp)
   165a0:	10bfffcc 	andi	r2,r2,65535
   165a4:	1004923a 	slli	r2,r2,8
   165a8:	1884b03a 	or	r2,r3,r2
   165ac:	e0bff98d 	sth	r2,-26(fp)
    inet_addr_from_ipaddr(&sin.sin_addr, &naddr);
   165b0:	e0bff717 	ldw	r2,-36(fp)
   165b4:	e0bffa15 	stw	r2,-24(fp)

    if (*addrlen > sizeof(sin))
   165b8:	e0bfff17 	ldw	r2,-4(fp)
   165bc:	10800017 	ldw	r2,0(r2)
   165c0:	10800470 	cmpltui	r2,r2,17
   165c4:	1000031e 	bne	r2,zero,165d4 <lwip_accept+0x214>
      *addrlen = sizeof(sin);
   165c8:	e0bfff17 	ldw	r2,-4(fp)
   165cc:	00c00404 	movi	r3,16
   165d0:	10c00015 	stw	r3,0(r2)

    MEMCPY(addr, &sin, *addrlen);
   165d4:	e0bfff17 	ldw	r2,-4(fp)
   165d8:	10800017 	ldw	r2,0(r2)
   165dc:	e0fff904 	addi	r3,fp,-28
   165e0:	e13ffe17 	ldw	r4,-8(fp)
   165e4:	180b883a 	mov	r5,r3
   165e8:	100d883a 	mov	r6,r2
   165ec:	00041f00 	call	41f0 <memcpy>
  }

  newsock = alloc_socket(newconn, 1);
   165f0:	e0bff617 	ldw	r2,-40(fp)
   165f4:	1009883a 	mov	r4,r2
   165f8:	01400044 	movi	r5,1
   165fc:	001618c0 	call	1618c <alloc_socket>
   16600:	e0bff415 	stw	r2,-48(fp)
  if (newsock == -1) {
   16604:	e0bff417 	ldw	r2,-48(fp)
   16608:	10bfffd8 	cmpnei	r2,r2,-1
   1660c:	1000081e 	bne	r2,zero,16630 <lwip_accept+0x270>
    netconn_delete(newconn);
   16610:	e0bff617 	ldw	r2,-40(fp)
   16614:	1009883a 	mov	r4,r2
   16618:	00125f40 	call	125f4 <netconn_delete>
    sock_set_errno(sock, ENFILE);
   1661c:	e0bff217 	ldw	r2,-56(fp)
   16620:	00c005c4 	movi	r3,23
   16624:	10c00415 	stw	r3,16(r2)
    return -1;
   16628:	00bfffc4 	movi	r2,-1
   1662c:	00001f06 	br	166ac <lwip_accept+0x2ec>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  LWIP_ASSERT("newconn->callback == event_callback", newconn->callback == event_callback);
  nsock = &sockets[newsock];
   16630:	e0bff417 	ldw	r2,-48(fp)
   16634:	10c00624 	muli	r3,r2,24
   16638:	00800134 	movhi	r2,4
   1663c:	109f6c04 	addi	r2,r2,32176
   16640:	1885883a 	add	r2,r3,r2
   16644:	e0bff515 	stw	r2,-44(fp)

  newsock += LWIP_SOCKET_OFFSET;
   16648:	e0bff417 	ldw	r2,-48(fp)
   1664c:	10800804 	addi	r2,r2,32
   16650:	e0bff415 	stw	r2,-48(fp)
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  SYS_ARCH_PROTECT(lev);
   16654:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   16658:	10000126 	beq	r2,zero,16660 <lwip_accept+0x2a0>
   1665c:	00110d00 	call	110d0 <vTaskEnterCritical>
  nsock->rcvevent += (s16_t)(-1 - newconn->socket);
   16660:	e0bff517 	ldw	r2,-44(fp)
   16664:	1080028b 	ldhu	r2,10(r2)
   16668:	1007883a 	mov	r3,r2
   1666c:	e0bff617 	ldw	r2,-40(fp)
   16670:	10800717 	ldw	r2,28(r2)
   16674:	0084303a 	nor	r2,zero,r2
   16678:	1885883a 	add	r2,r3,r2
   1667c:	1007883a 	mov	r3,r2
   16680:	e0bff517 	ldw	r2,-44(fp)
   16684:	10c0028d 	sth	r3,10(r2)
  newconn->socket = newsock;
   16688:	e0bff617 	ldw	r2,-40(fp)
   1668c:	e0fff417 	ldw	r3,-48(fp)
   16690:	10c00715 	stw	r3,28(r2)
  SYS_ARCH_UNPROTECT(lev);
   16694:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   16698:	10000126 	beq	r2,zero,166a0 <lwip_accept+0x2e0>
   1669c:	00111100 	call	11110 <vTaskExitCritical>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F"\n", port));

  sock_set_errno(sock, 0);
   166a0:	e0bff217 	ldw	r2,-56(fp)
   166a4:	10000415 	stw	zero,16(r2)
  return newsock;
   166a8:	e0bff417 	ldw	r2,-48(fp)
}
   166ac:	e037883a 	mov	sp,fp
   166b0:	dfc00117 	ldw	ra,4(sp)
   166b4:	df000017 	ldw	fp,0(sp)
   166b8:	dec00204 	addi	sp,sp,8
   166bc:	f800283a 	ret

000166c0 <lwip_bind>:

int
lwip_bind(int s, const struct sockaddr *name, socklen_t namelen)
{
   166c0:	defff704 	addi	sp,sp,-36
   166c4:	dfc00815 	stw	ra,32(sp)
   166c8:	df000715 	stw	fp,28(sp)
   166cc:	df000704 	addi	fp,sp,28
   166d0:	e13ffd15 	stw	r4,-12(fp)
   166d4:	e17ffe15 	stw	r5,-8(fp)
   166d8:	e1bfff15 	stw	r6,-4(fp)
  ip_addr_t local_addr;
  u16_t local_port;
  err_t err;
  const struct sockaddr_in *name_in;

  sock = get_socket(s);
   166dc:	e13ffd17 	ldw	r4,-12(fp)
   166e0:	00160940 	call	16094 <get_socket>
   166e4:	e0bff915 	stw	r2,-28(fp)
  if (!sock) {
   166e8:	e0bff917 	ldw	r2,-28(fp)
   166ec:	1000021e 	bne	r2,zero,166f8 <lwip_bind+0x38>
    return -1;
   166f0:	00bfffc4 	movi	r2,-1
   166f4:	00004106 	br	167fc <lwip_bind+0x13c>
  }

  /* check size, familiy and alignment of 'name' */
  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
   166f8:	e0bfff17 	ldw	r2,-4(fp)
   166fc:	10800418 	cmpnei	r2,r2,16
   16700:	1000081e 	bne	r2,zero,16724 <lwip_bind+0x64>
   16704:	e0bffe17 	ldw	r2,-8(fp)
   16708:	10800043 	ldbu	r2,1(r2)
   1670c:	10803fcc 	andi	r2,r2,255
   16710:	10800098 	cmpnei	r2,r2,2
   16714:	1000031e 	bne	r2,zero,16724 <lwip_bind+0x64>
   16718:	e0bffe17 	ldw	r2,-8(fp)
   1671c:	108000cc 	andi	r2,r2,3
   16720:	10000926 	beq	r2,zero,16748 <lwip_bind+0x88>
   16724:	01000134 	movhi	r4,4
   16728:	21038404 	addi	r4,r4,3600
   1672c:	01400134 	movhi	r5,4
   16730:	29439004 	addi	r5,r5,3648
   16734:	01806ac4 	movi	r6,427
   16738:	01c00134 	movhi	r7,4
   1673c:	39c39704 	addi	r7,r7,3676
   16740:	00044740 	call	4474 <printf>
   16744:	003fff06 	br	16744 <lwip_bind+0x84>
             ((name->sa_family) == AF_INET) && ((((mem_ptr_t)name) % 4) == 0)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);
  name_in = (const struct sockaddr_in *)(void*)name;
   16748:	e0bffe17 	ldw	r2,-8(fp)
   1674c:	e0bffa15 	stw	r2,-24(fp)

  inet_addr_to_ipaddr(&local_addr, &name_in->sin_addr);
   16750:	e0bffa17 	ldw	r2,-24(fp)
   16754:	10800117 	ldw	r2,4(r2)
   16758:	e0bffc15 	stw	r2,-16(fp)
  local_port = name_in->sin_port;
   1675c:	e0bffa17 	ldw	r2,-24(fp)
   16760:	1080008b 	ldhu	r2,2(r2)
   16764:	e0bffb0d 	sth	r2,-20(fp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
   16768:	e0bff917 	ldw	r2,-28(fp)
   1676c:	11000017 	ldw	r4,0(r2)
   16770:	e0bffb0b 	ldhu	r2,-20(fp)
   16774:	1004d23a 	srli	r2,r2,8
   16778:	1007883a 	mov	r3,r2
   1677c:	e0bffb0b 	ldhu	r2,-20(fp)
   16780:	1004923a 	slli	r2,r2,8
   16784:	1884b03a 	or	r2,r3,r2
   16788:	10bfffcc 	andi	r2,r2,65535
   1678c:	e0fffc04 	addi	r3,fp,-16
   16790:	180b883a 	mov	r5,r3
   16794:	100d883a 	mov	r6,r2
   16798:	00127900 	call	12790 <netconn_bind>
   1679c:	e0bffb85 	stb	r2,-18(fp)

  if (err != ERR_OK) {
   167a0:	e0bffb87 	ldb	r2,-18(fp)
   167a4:	10001226 	beq	r2,zero,167f0 <lwip_bind+0x130>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
   167a8:	e0bffb87 	ldb	r2,-18(fp)
   167ac:	0085c83a 	sub	r2,zero,r2
   167b0:	10800428 	cmpgeui	r2,r2,16
   167b4:	1000091e 	bne	r2,zero,167dc <lwip_bind+0x11c>
   167b8:	e0bffb87 	ldb	r2,-18(fp)
   167bc:	0085c83a 	sub	r2,zero,r2
   167c0:	00c00134 	movhi	r3,4
   167c4:	18c37404 	addi	r3,r3,3536
   167c8:	1085883a 	add	r2,r2,r2
   167cc:	1085883a 	add	r2,r2,r2
   167d0:	1885883a 	add	r2,r3,r2
   167d4:	10800017 	ldw	r2,0(r2)
   167d8:	00000106 	br	167e0 <lwip_bind+0x120>
   167dc:	00800144 	movi	r2,5
   167e0:	e0fff917 	ldw	r3,-28(fp)
   167e4:	18800415 	stw	r2,16(r3)
    return -1;
   167e8:	00bfffc4 	movi	r2,-1
   167ec:	00000306 	br	167fc <lwip_bind+0x13c>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
   167f0:	e0bff917 	ldw	r2,-28(fp)
   167f4:	10000415 	stw	zero,16(r2)
  return 0;
   167f8:	0005883a 	mov	r2,zero
}
   167fc:	e037883a 	mov	sp,fp
   16800:	dfc00117 	ldw	ra,4(sp)
   16804:	df000017 	ldw	fp,0(sp)
   16808:	dec00204 	addi	sp,sp,8
   1680c:	f800283a 	ret

00016810 <lwip_close>:

int
lwip_close(int s)
{
   16810:	defffb04 	addi	sp,sp,-20
   16814:	dfc00415 	stw	ra,16(sp)
   16818:	df000315 	stw	fp,12(sp)
   1681c:	df000304 	addi	fp,sp,12
   16820:	e13fff15 	stw	r4,-4(fp)
  struct lwip_sock *sock;
  int is_tcp = 0;
   16824:	e03ffd15 	stw	zero,-12(fp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
   16828:	e13fff17 	ldw	r4,-4(fp)
   1682c:	00160940 	call	16094 <get_socket>
   16830:	e0bffe15 	stw	r2,-8(fp)
  if (!sock) {
   16834:	e0bffe17 	ldw	r2,-8(fp)
   16838:	1000021e 	bne	r2,zero,16844 <lwip_close+0x34>
    return -1;
   1683c:	00bfffc4 	movi	r2,-1
   16840:	00001106 	br	16888 <lwip_close+0x78>
  }

  if(sock->conn != NULL) {
   16844:	e0bffe17 	ldw	r2,-8(fp)
   16848:	10800017 	ldw	r2,0(r2)
   1684c:	10000626 	beq	r2,zero,16868 <lwip_close+0x58>
    is_tcp = netconn_type(sock->conn) == NETCONN_TCP;
   16850:	e0bffe17 	ldw	r2,-8(fp)
   16854:	10800017 	ldw	r2,0(r2)
   16858:	10800017 	ldw	r2,0(r2)
   1685c:	10800420 	cmpeqi	r2,r2,16
   16860:	10803fcc 	andi	r2,r2,255
   16864:	e0bffd15 	stw	r2,-12(fp)
  } else {
    LWIP_ASSERT("sock->lastdata == NULL", sock->lastdata == NULL);
  }

  netconn_delete(sock->conn);
   16868:	e0bffe17 	ldw	r2,-8(fp)
   1686c:	10800017 	ldw	r2,0(r2)
   16870:	1009883a 	mov	r4,r2
   16874:	00125f40 	call	125f4 <netconn_delete>

  free_socket(sock, is_tcp);
   16878:	e13ffe17 	ldw	r4,-8(fp)
   1687c:	e17ffd17 	ldw	r5,-12(fp)
   16880:	001632c0 	call	1632c <free_socket>
  set_errno(0);
  return 0;
   16884:	0005883a 	mov	r2,zero
}
   16888:	e037883a 	mov	sp,fp
   1688c:	dfc00117 	ldw	ra,4(sp)
   16890:	df000017 	ldw	fp,0(sp)
   16894:	dec00204 	addi	sp,sp,8
   16898:	f800283a 	ret

0001689c <lwip_connect>:

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
   1689c:	defff604 	addi	sp,sp,-40
   168a0:	dfc00915 	stw	ra,36(sp)
   168a4:	df000815 	stw	fp,32(sp)
   168a8:	df000804 	addi	fp,sp,32
   168ac:	e13ffd15 	stw	r4,-12(fp)
   168b0:	e17ffe15 	stw	r5,-8(fp)
   168b4:	e1bfff15 	stw	r6,-4(fp)
  struct lwip_sock *sock;
  err_t err;
  const struct sockaddr_in *name_in;

  sock = get_socket(s);
   168b8:	e13ffd17 	ldw	r4,-12(fp)
   168bc:	00160940 	call	16094 <get_socket>
   168c0:	e0bff915 	stw	r2,-28(fp)
  if (!sock) {
   168c4:	e0bff917 	ldw	r2,-28(fp)
   168c8:	1000021e 	bne	r2,zero,168d4 <lwip_connect+0x38>
    return -1;
   168cc:	00bfffc4 	movi	r2,-1
   168d0:	00004b06 	br	16a00 <lwip_connect+0x164>
  }

  /* check size, familiy and alignment of 'name' */
  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
   168d4:	e0bfff17 	ldw	r2,-4(fp)
   168d8:	10800418 	cmpnei	r2,r2,16
   168dc:	1000081e 	bne	r2,zero,16900 <lwip_connect+0x64>
   168e0:	e0bffe17 	ldw	r2,-8(fp)
   168e4:	10800043 	ldbu	r2,1(r2)
   168e8:	10803fcc 	andi	r2,r2,255
   168ec:	10800098 	cmpnei	r2,r2,2
   168f0:	1000031e 	bne	r2,zero,16900 <lwip_connect+0x64>
   168f4:	e0bffe17 	ldw	r2,-8(fp)
   168f8:	108000cc 	andi	r2,r2,3
   168fc:	10000926 	beq	r2,zero,16924 <lwip_connect+0x88>
   16900:	01000134 	movhi	r4,4
   16904:	21038404 	addi	r4,r4,3600
   16908:	01400134 	movhi	r5,4
   1690c:	29439d04 	addi	r5,r5,3700
   16910:	01807ac4 	movi	r6,491
   16914:	01c00134 	movhi	r7,4
   16918:	39c39704 	addi	r7,r7,3676
   1691c:	00044740 	call	4474 <printf>
   16920:	003fff06 	br	16920 <lwip_connect+0x84>
             ((name->sa_family) == AF_INET) && ((((mem_ptr_t)name) % 4) == 0)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);
  name_in = (const struct sockaddr_in *)(void*)name;
   16924:	e0bffe17 	ldw	r2,-8(fp)
   16928:	e0bffa15 	stw	r2,-24(fp)

  if (name_in->sin_family == AF_UNSPEC) {
   1692c:	e0bffa17 	ldw	r2,-24(fp)
   16930:	10800043 	ldbu	r2,1(r2)
   16934:	10803fcc 	andi	r2,r2,255
   16938:	1000061e 	bne	r2,zero,16954 <lwip_connect+0xb8>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, AF_UNSPEC)\n", s));
    err = netconn_disconnect(sock->conn);
   1693c:	e0bff917 	ldw	r2,-28(fp)
   16940:	10800017 	ldw	r2,0(r2)
   16944:	1009883a 	mov	r4,r2
   16948:	00129400 	call	12940 <netconn_disconnect>
   1694c:	e0bff805 	stb	r2,-32(fp)
   16950:	00001406 	br	169a4 <lwip_connect+0x108>
  } else {
    ip_addr_t remote_addr;
    u16_t remote_port;

    inet_addr_to_ipaddr(&remote_addr, &name_in->sin_addr);
   16954:	e0bffa17 	ldw	r2,-24(fp)
   16958:	10800117 	ldw	r2,4(r2)
   1695c:	e0bffc15 	stw	r2,-16(fp)
    remote_port = name_in->sin_port;
   16960:	e0bffa17 	ldw	r2,-24(fp)
   16964:	1080008b 	ldhu	r2,2(r2)
   16968:	e0bffb0d 	sth	r2,-20(fp)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
   1696c:	e0bff917 	ldw	r2,-28(fp)
   16970:	11000017 	ldw	r4,0(r2)
   16974:	e0bffb0b 	ldhu	r2,-20(fp)
   16978:	1004d23a 	srli	r2,r2,8
   1697c:	1007883a 	mov	r3,r2
   16980:	e0bffb0b 	ldhu	r2,-20(fp)
   16984:	1004923a 	slli	r2,r2,8
   16988:	1884b03a 	or	r2,r3,r2
   1698c:	10bfffcc 	andi	r2,r2,65535
   16990:	e0fffc04 	addi	r3,fp,-16
   16994:	180b883a 	mov	r5,r3
   16998:	100d883a 	mov	r6,r2
   1699c:	00128680 	call	12868 <netconn_connect>
   169a0:	e0bff805 	stb	r2,-32(fp)
  }

  if (err != ERR_OK) {
   169a4:	e0bff807 	ldb	r2,-32(fp)
   169a8:	10001226 	beq	r2,zero,169f4 <lwip_connect+0x158>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
   169ac:	e0bff807 	ldb	r2,-32(fp)
   169b0:	0085c83a 	sub	r2,zero,r2
   169b4:	10800428 	cmpgeui	r2,r2,16
   169b8:	1000091e 	bne	r2,zero,169e0 <lwip_connect+0x144>
   169bc:	e0bff807 	ldb	r2,-32(fp)
   169c0:	0085c83a 	sub	r2,zero,r2
   169c4:	00c00134 	movhi	r3,4
   169c8:	18c37404 	addi	r3,r3,3536
   169cc:	1085883a 	add	r2,r2,r2
   169d0:	1085883a 	add	r2,r2,r2
   169d4:	1885883a 	add	r2,r3,r2
   169d8:	10800017 	ldw	r2,0(r2)
   169dc:	00000106 	br	169e4 <lwip_connect+0x148>
   169e0:	00800144 	movi	r2,5
   169e4:	e0fff917 	ldw	r3,-28(fp)
   169e8:	18800415 	stw	r2,16(r3)
    return -1;
   169ec:	00bfffc4 	movi	r2,-1
   169f0:	00000306 	br	16a00 <lwip_connect+0x164>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
   169f4:	e0bff917 	ldw	r2,-28(fp)
   169f8:	10000415 	stw	zero,16(r2)
  return 0;
   169fc:	0005883a 	mov	r2,zero
}
   16a00:	e037883a 	mov	sp,fp
   16a04:	dfc00117 	ldw	ra,4(sp)
   16a08:	df000017 	ldw	fp,0(sp)
   16a0c:	dec00204 	addi	sp,sp,8
   16a10:	f800283a 	ret

00016a14 <lwip_listen>:
 * @param backlog (ATTENTION: needs TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
   16a14:	defffa04 	addi	sp,sp,-24
   16a18:	dfc00515 	stw	ra,20(sp)
   16a1c:	df000415 	stw	fp,16(sp)
   16a20:	df000404 	addi	fp,sp,16
   16a24:	e13ffe15 	stw	r4,-8(fp)
   16a28:	e17fff15 	stw	r5,-4(fp)
  struct lwip_sock *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
   16a2c:	e13ffe17 	ldw	r4,-8(fp)
   16a30:	00160940 	call	16094 <get_socket>
   16a34:	e0bffc15 	stw	r2,-16(fp)
  if (!sock) {
   16a38:	e0bffc17 	ldw	r2,-16(fp)
   16a3c:	1000021e 	bne	r2,zero,16a48 <lwip_listen+0x34>
    return -1;
   16a40:	00bfffc4 	movi	r2,-1
   16a44:	00003206 	br	16b10 <lwip_listen+0xfc>
  }

  /* limit the "backlog" parameter to fit in an u8_t */
  backlog = LWIP_MIN(LWIP_MAX(backlog, 0), 0xff);
   16a48:	e0bfff17 	ldw	r2,-4(fp)
   16a4c:	10803fc8 	cmpgei	r2,r2,255
   16a50:	1000041e 	bne	r2,zero,16a64 <lwip_listen+0x50>
   16a54:	e0bfff17 	ldw	r2,-4(fp)
   16a58:	1000030e 	bge	r2,zero,16a68 <lwip_listen+0x54>
   16a5c:	0005883a 	mov	r2,zero
   16a60:	00000106 	br	16a68 <lwip_listen+0x54>
   16a64:	00803fc4 	movi	r2,255
   16a68:	e0bfff15 	stw	r2,-4(fp)

  err = netconn_listen_with_backlog(sock->conn, (u8_t)backlog);
   16a6c:	e0bffc17 	ldw	r2,-16(fp)
   16a70:	10c00017 	ldw	r3,0(r2)
   16a74:	e0bfff17 	ldw	r2,-4(fp)
   16a78:	10803fcc 	andi	r2,r2,255
   16a7c:	1809883a 	mov	r4,r3
   16a80:	100b883a 	mov	r5,r2
   16a84:	00129fc0 	call	129fc <netconn_listen_with_backlog>
   16a88:	e0bffd05 	stb	r2,-12(fp)

  if (err != ERR_OK) {
   16a8c:	e0bffd07 	ldb	r2,-12(fp)
   16a90:	10001c26 	beq	r2,zero,16b04 <lwip_listen+0xf0>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    if (netconn_type(sock->conn) != NETCONN_TCP) {
   16a94:	e0bffc17 	ldw	r2,-16(fp)
   16a98:	10800017 	ldw	r2,0(r2)
   16a9c:	10800017 	ldw	r2,0(r2)
   16aa0:	10800420 	cmpeqi	r2,r2,16
   16aa4:	1000051e 	bne	r2,zero,16abc <lwip_listen+0xa8>
      sock_set_errno(sock, EOPNOTSUPP);
   16aa8:	e0bffc17 	ldw	r2,-16(fp)
   16aac:	00c017c4 	movi	r3,95
   16ab0:	10c00415 	stw	r3,16(r2)
      return EOPNOTSUPP;
   16ab4:	008017c4 	movi	r2,95
   16ab8:	00001506 	br	16b10 <lwip_listen+0xfc>
    }
    sock_set_errno(sock, err_to_errno(err));
   16abc:	e0bffd07 	ldb	r2,-12(fp)
   16ac0:	0085c83a 	sub	r2,zero,r2
   16ac4:	10800428 	cmpgeui	r2,r2,16
   16ac8:	1000091e 	bne	r2,zero,16af0 <lwip_listen+0xdc>
   16acc:	e0bffd07 	ldb	r2,-12(fp)
   16ad0:	0085c83a 	sub	r2,zero,r2
   16ad4:	00c00134 	movhi	r3,4
   16ad8:	18c37404 	addi	r3,r3,3536
   16adc:	1085883a 	add	r2,r2,r2
   16ae0:	1085883a 	add	r2,r2,r2
   16ae4:	1885883a 	add	r2,r3,r2
   16ae8:	10800017 	ldw	r2,0(r2)
   16aec:	00000106 	br	16af4 <lwip_listen+0xe0>
   16af0:	00800144 	movi	r2,5
   16af4:	e0fffc17 	ldw	r3,-16(fp)
   16af8:	18800415 	stw	r2,16(r3)
    return -1;
   16afc:	00bfffc4 	movi	r2,-1
   16b00:	00000306 	br	16b10 <lwip_listen+0xfc>
  }

  sock_set_errno(sock, 0);
   16b04:	e0bffc17 	ldw	r2,-16(fp)
   16b08:	10000415 	stw	zero,16(r2)
  return 0;
   16b0c:	0005883a 	mov	r2,zero
}
   16b10:	e037883a 	mov	sp,fp
   16b14:	dfc00117 	ldw	ra,4(sp)
   16b18:	df000017 	ldw	fp,0(sp)
   16b1c:	dec00204 	addi	sp,sp,8
   16b20:	f800283a 	ret

00016b24 <lwip_recvfrom>:

int
lwip_recvfrom(int s, void *mem, size_t len, int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
   16b24:	deffec04 	addi	sp,sp,-80
   16b28:	dfc01315 	stw	ra,76(sp)
   16b2c:	df001215 	stw	fp,72(sp)
   16b30:	df001204 	addi	fp,sp,72
   16b34:	e13ffc15 	stw	r4,-16(fp)
   16b38:	e17ffd15 	stw	r5,-12(fp)
   16b3c:	e1bffe15 	stw	r6,-8(fp)
   16b40:	e1ffff15 	stw	r7,-4(fp)
  struct lwip_sock *sock;
  void             *buf = NULL;
   16b44:	e03ff515 	stw	zero,-44(fp)
  struct pbuf      *p;
  u16_t            buflen, copylen;
  int              off = 0;
   16b48:	e03ff015 	stw	zero,-64(fp)
  ip_addr_t        *addr;
  u16_t            port;
  u8_t             done = 0;
   16b4c:	e03ff205 	stb	zero,-56(fp)
  err_t            err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %"SZT_F", 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
   16b50:	e13ffc17 	ldw	r4,-16(fp)
   16b54:	00160940 	call	16094 <get_socket>
   16b58:	e0bff315 	stw	r2,-52(fp)
  if (!sock) {
   16b5c:	e0bff317 	ldw	r2,-52(fp)
   16b60:	1000021e 	bne	r2,zero,16b6c <lwip_recvfrom+0x48>
    return -1;
   16b64:	00bfffc4 	movi	r2,-1
   16b68:	00011e06 	br	16fe4 <lwip_recvfrom+0x4c0>
  }

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
   16b6c:	e0bff317 	ldw	r2,-52(fp)
   16b70:	10800117 	ldw	r2,4(r2)
   16b74:	10000426 	beq	r2,zero,16b88 <lwip_recvfrom+0x64>
      buf = sock->lastdata;
   16b78:	e0bff317 	ldw	r2,-52(fp)
   16b7c:	10800117 	ldw	r2,4(r2)
   16b80:	e0bff515 	stw	r2,-44(fp)
   16b84:	00005c06 	br	16cf8 <lwip_recvfrom+0x1d4>
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || netconn_is_nonblocking(sock->conn)) && 
   16b88:	e0bfff17 	ldw	r2,-4(fp)
   16b8c:	1080020c 	andi	r2,r2,8
   16b90:	1000061e 	bne	r2,zero,16bac <lwip_recvfrom+0x88>
   16b94:	e0bff317 	ldw	r2,-52(fp)
   16b98:	10800017 	ldw	r2,0(r2)
   16b9c:	10800903 	ldbu	r2,36(r2)
   16ba0:	10803fcc 	andi	r2,r2,255
   16ba4:	1080008c 	andi	r2,r2,2
   16ba8:	10001726 	beq	r2,zero,16c08 <lwip_recvfrom+0xe4>
          (sock->rcvevent <= 0)) {
   16bac:	e0bff317 	ldw	r2,-52(fp)
   16bb0:	1080028b 	ldhu	r2,10(r2)
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || netconn_is_nonblocking(sock->conn)) && 
   16bb4:	10bfffcc 	andi	r2,r2,65535
   16bb8:	10a0001c 	xori	r2,r2,32768
   16bbc:	10a00004 	addi	r2,r2,-32768
   16bc0:	00801116 	blt	zero,r2,16c08 <lwip_recvfrom+0xe4>
          (sock->rcvevent <= 0)) {
        if (off > 0) {
   16bc4:	e0bff017 	ldw	r2,-64(fp)
   16bc8:	00800a0e 	bge	zero,r2,16bf4 <lwip_recvfrom+0xd0>
          /* update receive window */
          netconn_recved(sock->conn, (u32_t)off);
   16bcc:	e0bff317 	ldw	r2,-52(fp)
   16bd0:	10c00017 	ldw	r3,0(r2)
   16bd4:	e0bff017 	ldw	r2,-64(fp)
   16bd8:	1809883a 	mov	r4,r3
   16bdc:	100b883a 	mov	r5,r2
   16be0:	00131600 	call	13160 <netconn_recved>
          /* already received data, return that */
          sock_set_errno(sock, 0);
   16be4:	e0bff317 	ldw	r2,-52(fp)
   16be8:	10000415 	stw	zero,16(r2)
          return off;
   16bec:	e0bff017 	ldw	r2,-64(fp)
   16bf0:	0000fc06 	br	16fe4 <lwip_recvfrom+0x4c0>
        }
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
   16bf4:	e0bff317 	ldw	r2,-52(fp)
   16bf8:	00c002c4 	movi	r3,11
   16bfc:	10c00415 	stw	r3,16(r2)
        return -1;
   16c00:	00bfffc4 	movi	r2,-1
   16c04:	0000f706 	br	16fe4 <lwip_recvfrom+0x4c0>
      }

      /* No data was left from the previous operation, so we try to get
         some from the network. */
      if (netconn_type(sock->conn) == NETCONN_TCP) {
   16c08:	e0bff317 	ldw	r2,-52(fp)
   16c0c:	10800017 	ldw	r2,0(r2)
   16c10:	10800017 	ldw	r2,0(r2)
   16c14:	10800418 	cmpnei	r2,r2,16
   16c18:	1000081e 	bne	r2,zero,16c3c <lwip_recvfrom+0x118>
        err = netconn_recv_tcp_pbuf(sock->conn, (struct pbuf **)&buf);
   16c1c:	e0bff317 	ldw	r2,-52(fp)
   16c20:	10c00017 	ldw	r3,0(r2)
   16c24:	e0bff504 	addi	r2,fp,-44
   16c28:	1809883a 	mov	r4,r3
   16c2c:	100b883a 	mov	r5,r2
   16c30:	0012f440 	call	12f44 <netconn_recv_tcp_pbuf>
   16c34:	e0bff245 	stb	r2,-55(fp)
   16c38:	00000706 	br	16c58 <lwip_recvfrom+0x134>
      } else {
        err = netconn_recv(sock->conn, (struct netbuf **)&buf);
   16c3c:	e0bff317 	ldw	r2,-52(fp)
   16c40:	10c00017 	ldw	r3,0(r2)
   16c44:	e0bff504 	addi	r2,fp,-44
   16c48:	1809883a 	mov	r4,r3
   16c4c:	100b883a 	mov	r5,r2
   16c50:	0012fb80 	call	12fb8 <netconn_recv>
   16c54:	e0bff245 	stb	r2,-55(fp)
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv err=%d, netbuf=%p\n",
        err, buf));

      if (err != ERR_OK) {
   16c58:	e0bff247 	ldb	r2,-55(fp)
   16c5c:	10002326 	beq	r2,zero,16cec <lwip_recvfrom+0x1c8>
        if (off > 0) {
   16c60:	e0bff017 	ldw	r2,-64(fp)
   16c64:	00800a0e 	bge	zero,r2,16c90 <lwip_recvfrom+0x16c>
          /* update receive window */
          netconn_recved(sock->conn, (u32_t)off);
   16c68:	e0bff317 	ldw	r2,-52(fp)
   16c6c:	10c00017 	ldw	r3,0(r2)
   16c70:	e0bff017 	ldw	r2,-64(fp)
   16c74:	1809883a 	mov	r4,r3
   16c78:	100b883a 	mov	r5,r2
   16c7c:	00131600 	call	13160 <netconn_recved>
          /* already received data, return that */
          sock_set_errno(sock, 0);
   16c80:	e0bff317 	ldw	r2,-52(fp)
   16c84:	10000415 	stw	zero,16(r2)
          return off;
   16c88:	e0bff017 	ldw	r2,-64(fp)
   16c8c:	0000d506 	br	16fe4 <lwip_recvfrom+0x4c0>
        }
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL, error is \"%s\"!\n",
          s, lwip_strerr(err)));
        sock_set_errno(sock, err_to_errno(err));
   16c90:	e0bff247 	ldb	r2,-55(fp)
   16c94:	0085c83a 	sub	r2,zero,r2
   16c98:	10800428 	cmpgeui	r2,r2,16
   16c9c:	1000091e 	bne	r2,zero,16cc4 <lwip_recvfrom+0x1a0>
   16ca0:	e0bff247 	ldb	r2,-55(fp)
   16ca4:	0085c83a 	sub	r2,zero,r2
   16ca8:	00c00134 	movhi	r3,4
   16cac:	18c37404 	addi	r3,r3,3536
   16cb0:	1085883a 	add	r2,r2,r2
   16cb4:	1085883a 	add	r2,r2,r2
   16cb8:	1885883a 	add	r2,r3,r2
   16cbc:	10800017 	ldw	r2,0(r2)
   16cc0:	00000106 	br	16cc8 <lwip_recvfrom+0x1a4>
   16cc4:	00800144 	movi	r2,5
   16cc8:	e0fff317 	ldw	r3,-52(fp)
   16ccc:	18800415 	stw	r2,16(r3)
        if (err == ERR_CLSD) {
   16cd0:	e0bff247 	ldb	r2,-55(fp)
   16cd4:	10bffd18 	cmpnei	r2,r2,-12
   16cd8:	1000021e 	bne	r2,zero,16ce4 <lwip_recvfrom+0x1c0>
          return 0;
   16cdc:	0005883a 	mov	r2,zero
   16ce0:	0000c006 	br	16fe4 <lwip_recvfrom+0x4c0>
        } else {
          return -1;
   16ce4:	00bfffc4 	movi	r2,-1
   16ce8:	0000be06 	br	16fe4 <lwip_recvfrom+0x4c0>
        }
      }
      LWIP_ASSERT("buf != NULL", buf != NULL);
      sock->lastdata = buf;
   16cec:	e0fff517 	ldw	r3,-44(fp)
   16cf0:	e0bff317 	ldw	r2,-52(fp)
   16cf4:	10c00115 	stw	r3,4(r2)
    }

    if (netconn_type(sock->conn) == NETCONN_TCP) {
   16cf8:	e0bff317 	ldw	r2,-52(fp)
   16cfc:	10800017 	ldw	r2,0(r2)
   16d00:	10800017 	ldw	r2,0(r2)
   16d04:	10800418 	cmpnei	r2,r2,16
   16d08:	1000031e 	bne	r2,zero,16d18 <lwip_recvfrom+0x1f4>
      p = (struct pbuf *)buf;
   16d0c:	e0bff517 	ldw	r2,-44(fp)
   16d10:	e0bfee15 	stw	r2,-72(fp)
   16d14:	00000306 	br	16d24 <lwip_recvfrom+0x200>
    } else {
      p = ((struct netbuf *)buf)->p;
   16d18:	e0bff517 	ldw	r2,-44(fp)
   16d1c:	10800017 	ldw	r2,0(r2)
   16d20:	e0bfee15 	stw	r2,-72(fp)
    }
    buflen = p->tot_len;
   16d24:	e0bfee17 	ldw	r2,-72(fp)
   16d28:	1080020b 	ldhu	r2,8(r2)
   16d2c:	e0bff40d 	sth	r2,-48(fp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%"U16_F" len=%"SZT_F" off=%d sock->lastoffset=%"U16_F"\n",
      buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
   16d30:	e0bff317 	ldw	r2,-52(fp)
   16d34:	1080020b 	ldhu	r2,8(r2)
   16d38:	e0fff40b 	ldhu	r3,-48(fp)
   16d3c:	1885c83a 	sub	r2,r3,r2
   16d40:	e0bff40d 	sth	r2,-48(fp)

    if (len > buflen) {
   16d44:	e0fff40b 	ldhu	r3,-48(fp)
   16d48:	e0bffe17 	ldw	r2,-8(fp)
   16d4c:	1880032e 	bgeu	r3,r2,16d5c <lwip_recvfrom+0x238>
      copylen = buflen;
   16d50:	e0bff40b 	ldhu	r2,-48(fp)
   16d54:	e0bfef0d 	sth	r2,-68(fp)
   16d58:	00000206 	br	16d64 <lwip_recvfrom+0x240>
    } else {
      copylen = (u16_t)len;
   16d5c:	e0bffe17 	ldw	r2,-8(fp)
   16d60:	e0bfef0d 	sth	r2,-68(fp)
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    pbuf_copy_partial(p, (u8_t*)mem + off, copylen, sock->lastoffset);
   16d64:	e0bff017 	ldw	r2,-64(fp)
   16d68:	e0fffd17 	ldw	r3,-12(fp)
   16d6c:	188b883a 	add	r5,r3,r2
   16d70:	e0ffef0b 	ldhu	r3,-68(fp)
   16d74:	e0bff317 	ldw	r2,-52(fp)
   16d78:	1080020b 	ldhu	r2,8(r2)
   16d7c:	10bfffcc 	andi	r2,r2,65535
   16d80:	e13fee17 	ldw	r4,-72(fp)
   16d84:	180d883a 	mov	r6,r3
   16d88:	100f883a 	mov	r7,r2
   16d8c:	0023d580 	call	23d58 <pbuf_copy_partial>

    off += copylen;
   16d90:	e0bfef0b 	ldhu	r2,-68(fp)
   16d94:	e0fff017 	ldw	r3,-64(fp)
   16d98:	1885883a 	add	r2,r3,r2
   16d9c:	e0bff015 	stw	r2,-64(fp)

    if (netconn_type(sock->conn) == NETCONN_TCP) {
   16da0:	e0bff317 	ldw	r2,-52(fp)
   16da4:	10800017 	ldw	r2,0(r2)
   16da8:	10800017 	ldw	r2,0(r2)
   16dac:	10800418 	cmpnei	r2,r2,16
   16db0:	1000171e 	bne	r2,zero,16e10 <lwip_recvfrom+0x2ec>
      LWIP_ASSERT("invalid copylen, len would underflow", len >= copylen);
      len -= copylen;
   16db4:	e0bfef0b 	ldhu	r2,-68(fp)
   16db8:	e0fffe17 	ldw	r3,-8(fp)
   16dbc:	1885c83a 	sub	r2,r3,r2
   16dc0:	e0bffe15 	stw	r2,-8(fp)
      if ( (len <= 0) || 
   16dc4:	e0bffe17 	ldw	r2,-8(fp)
   16dc8:	10000e26 	beq	r2,zero,16e04 <lwip_recvfrom+0x2e0>
           (p->flags & PBUF_FLAG_PUSH) || 
   16dcc:	e0bfee17 	ldw	r2,-72(fp)
   16dd0:	10800343 	ldbu	r2,13(r2)
   16dd4:	10803fcc 	andi	r2,r2,255
   16dd8:	1080004c 	andi	r2,r2,1
    off += copylen;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
      LWIP_ASSERT("invalid copylen, len would underflow", len >= copylen);
      len -= copylen;
      if ( (len <= 0) || 
   16ddc:	1000091e 	bne	r2,zero,16e04 <lwip_recvfrom+0x2e0>
           (p->flags & PBUF_FLAG_PUSH) || 
           (sock->rcvevent <= 0) || 
   16de0:	e0bff317 	ldw	r2,-52(fp)
   16de4:	1080028b 	ldhu	r2,10(r2)

    if (netconn_type(sock->conn) == NETCONN_TCP) {
      LWIP_ASSERT("invalid copylen, len would underflow", len >= copylen);
      len -= copylen;
      if ( (len <= 0) || 
           (p->flags & PBUF_FLAG_PUSH) || 
   16de8:	10bfffcc 	andi	r2,r2,65535
   16dec:	10a0001c 	xori	r2,r2,32768
   16df0:	10a00004 	addi	r2,r2,-32768
   16df4:	0080030e 	bge	zero,r2,16e04 <lwip_recvfrom+0x2e0>
           (sock->rcvevent <= 0) || 
           ((flags & MSG_PEEK)!=0)) {
   16df8:	e0bfff17 	ldw	r2,-4(fp)
   16dfc:	1080004c 	andi	r2,r2,1
    if (netconn_type(sock->conn) == NETCONN_TCP) {
      LWIP_ASSERT("invalid copylen, len would underflow", len >= copylen);
      len -= copylen;
      if ( (len <= 0) || 
           (p->flags & PBUF_FLAG_PUSH) || 
           (sock->rcvevent <= 0) || 
   16e00:	10000526 	beq	r2,zero,16e18 <lwip_recvfrom+0x2f4>
           ((flags & MSG_PEEK)!=0)) {
        done = 1;
   16e04:	00800044 	movi	r2,1
   16e08:	e0bff205 	stb	r2,-56(fp)
   16e0c:	00000206 	br	16e18 <lwip_recvfrom+0x2f4>
      }
    } else {
      done = 1;
   16e10:	00800044 	movi	r2,1
   16e14:	e0bff205 	stb	r2,-56(fp)
    }

    /* Check to see from where the data was.*/
    if (done) {
   16e18:	e0bff203 	ldbu	r2,-56(fp)
   16e1c:	10003d26 	beq	r2,zero,16f14 <lwip_recvfrom+0x3f0>
      ip_addr_t fromaddr;
      if (from && fromlen) {
   16e20:	e0800217 	ldw	r2,8(fp)
   16e24:	10003b26 	beq	r2,zero,16f14 <lwip_recvfrom+0x3f0>
   16e28:	e0800317 	ldw	r2,12(fp)
   16e2c:	10003926 	beq	r2,zero,16f14 <lwip_recvfrom+0x3f0>
        struct sockaddr_in sin;

        if (netconn_type(sock->conn) == NETCONN_TCP) {
   16e30:	e0bff317 	ldw	r2,-52(fp)
   16e34:	10800017 	ldw	r2,0(r2)
   16e38:	10800017 	ldw	r2,0(r2)
   16e3c:	10800418 	cmpnei	r2,r2,16
   16e40:	10000b1e 	bne	r2,zero,16e70 <lwip_recvfrom+0x34c>
          addr = &fromaddr;
   16e44:	e0bff704 	addi	r2,fp,-36
   16e48:	e0bff115 	stw	r2,-60(fp)
          netconn_getaddr(sock->conn, addr, &port, 0);
   16e4c:	e0bff317 	ldw	r2,-52(fp)
   16e50:	10c00017 	ldw	r3,0(r2)
   16e54:	e0bff604 	addi	r2,fp,-40
   16e58:	1809883a 	mov	r4,r3
   16e5c:	e17ff117 	ldw	r5,-60(fp)
   16e60:	100d883a 	mov	r6,r2
   16e64:	000f883a 	mov	r7,zero
   16e68:	00126540 	call	12654 <netconn_getaddr>
   16e6c:	00000606 	br	16e88 <lwip_recvfrom+0x364>
        } else {
          addr = netbuf_fromaddr((struct netbuf *)buf);
   16e70:	e0bff517 	ldw	r2,-44(fp)
   16e74:	10800204 	addi	r2,r2,8
   16e78:	e0bff115 	stw	r2,-60(fp)
          port = netbuf_fromport((struct netbuf *)buf);
   16e7c:	e0bff517 	ldw	r2,-44(fp)
   16e80:	1080030b 	ldhu	r2,12(r2)
   16e84:	e0bff60d 	sth	r2,-40(fp)
        }

        memset(&sin, 0, sizeof(sin));
   16e88:	e0bff804 	addi	r2,fp,-32
   16e8c:	1009883a 	mov	r4,r2
   16e90:	000b883a 	mov	r5,zero
   16e94:	01800404 	movi	r6,16
   16e98:	00042e80 	call	42e8 <memset>
        sin.sin_len = sizeof(sin);
   16e9c:	00800404 	movi	r2,16
   16ea0:	e0bff805 	stb	r2,-32(fp)
        sin.sin_family = AF_INET;
   16ea4:	00800084 	movi	r2,2
   16ea8:	e0bff845 	stb	r2,-31(fp)
        sin.sin_port = htons(port);
   16eac:	e0bff60b 	ldhu	r2,-40(fp)
   16eb0:	10bfffcc 	andi	r2,r2,65535
   16eb4:	1004d23a 	srli	r2,r2,8
   16eb8:	1007883a 	mov	r3,r2
   16ebc:	e0bff60b 	ldhu	r2,-40(fp)
   16ec0:	10bfffcc 	andi	r2,r2,65535
   16ec4:	1004923a 	slli	r2,r2,8
   16ec8:	1884b03a 	or	r2,r3,r2
   16ecc:	e0bff88d 	sth	r2,-30(fp)
        inet_addr_from_ipaddr(&sin.sin_addr, addr);
   16ed0:	e0bff117 	ldw	r2,-60(fp)
   16ed4:	10800017 	ldw	r2,0(r2)
   16ed8:	e0bff915 	stw	r2,-28(fp)

        if (*fromlen > sizeof(sin)) {
   16edc:	e0800317 	ldw	r2,12(fp)
   16ee0:	10800017 	ldw	r2,0(r2)
   16ee4:	10800470 	cmpltui	r2,r2,17
   16ee8:	1000031e 	bne	r2,zero,16ef8 <lwip_recvfrom+0x3d4>
          *fromlen = sizeof(sin);
   16eec:	e0800317 	ldw	r2,12(fp)
   16ef0:	00c00404 	movi	r3,16
   16ef4:	10c00015 	stw	r3,0(r2)
        }

        MEMCPY(from, &sin, *fromlen);
   16ef8:	e0800317 	ldw	r2,12(fp)
   16efc:	10800017 	ldw	r2,0(r2)
   16f00:	e0fff804 	addi	r3,fp,-32
   16f04:	e1000217 	ldw	r4,8(fp)
   16f08:	180b883a 	mov	r5,r3
   16f0c:	100d883a 	mov	r6,r2
   16f10:	00041f00 	call	41f0 <memcpy>
#endif /*  SOCKETS_DEBUG */
      }
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK) == 0) {
   16f14:	e0bfff17 	ldw	r2,-4(fp)
   16f18:	1080004c 	andi	r2,r2,1
   16f1c:	1000241e 	bne	r2,zero,16fb0 <lwip_recvfrom+0x48c>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((netconn_type(sock->conn) == NETCONN_TCP) && (buflen - copylen > 0)) {
   16f20:	e0bff317 	ldw	r2,-52(fp)
   16f24:	10800017 	ldw	r2,0(r2)
   16f28:	10800017 	ldw	r2,0(r2)
   16f2c:	10800418 	cmpnei	r2,r2,16
   16f30:	10000f1e 	bne	r2,zero,16f70 <lwip_recvfrom+0x44c>
   16f34:	e0fff40b 	ldhu	r3,-48(fp)
   16f38:	e0bfef0b 	ldhu	r2,-68(fp)
   16f3c:	1885c83a 	sub	r2,r3,r2
   16f40:	00800b0e 	bge	zero,r2,16f70 <lwip_recvfrom+0x44c>
        sock->lastdata = buf;
   16f44:	e0fff517 	ldw	r3,-44(fp)
   16f48:	e0bff317 	ldw	r2,-52(fp)
   16f4c:	10c00115 	stw	r3,4(r2)
        sock->lastoffset += copylen;
   16f50:	e0bff317 	ldw	r2,-52(fp)
   16f54:	10c0020b 	ldhu	r3,8(r2)
   16f58:	e0bfef0b 	ldhu	r2,-68(fp)
   16f5c:	1885883a 	add	r2,r3,r2
   16f60:	1007883a 	mov	r3,r2
   16f64:	e0bff317 	ldw	r2,-52(fp)
   16f68:	10c0020d 	sth	r3,8(r2)
   16f6c:	00001006 	br	16fb0 <lwip_recvfrom+0x48c>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", buf));
      } else {
        sock->lastdata = NULL;
   16f70:	e0bff317 	ldw	r2,-52(fp)
   16f74:	10000115 	stw	zero,4(r2)
        sock->lastoffset = 0;
   16f78:	e0bff317 	ldw	r2,-52(fp)
   16f7c:	1000020d 	sth	zero,8(r2)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", buf));
        if (netconn_type(sock->conn) == NETCONN_TCP) {
   16f80:	e0bff317 	ldw	r2,-52(fp)
   16f84:	10800017 	ldw	r2,0(r2)
   16f88:	10800017 	ldw	r2,0(r2)
   16f8c:	10800418 	cmpnei	r2,r2,16
   16f90:	1000041e 	bne	r2,zero,16fa4 <lwip_recvfrom+0x480>
          pbuf_free((struct pbuf *)buf);
   16f94:	e0bff517 	ldw	r2,-44(fp)
   16f98:	1009883a 	mov	r4,r2
   16f9c:	00237600 	call	23760 <pbuf_free>
   16fa0:	00000306 	br	16fb0 <lwip_recvfrom+0x48c>
        } else {
          netbuf_delete((struct netbuf *)buf);
   16fa4:	e0bff517 	ldw	r2,-44(fp)
   16fa8:	1009883a 	mov	r4,r2
   16fac:	0015b180 	call	15b18 <netbuf_delete>
        }
      }
    }
  } while (!done);
   16fb0:	e0bff203 	ldbu	r2,-56(fp)
   16fb4:	103eed26 	beq	r2,zero,16b6c <lwip_recvfrom+0x48>

  if (off > 0) {
   16fb8:	e0bff017 	ldw	r2,-64(fp)
   16fbc:	0080060e 	bge	zero,r2,16fd8 <lwip_recvfrom+0x4b4>
    /* update receive window */
    netconn_recved(sock->conn, (u32_t)off);
   16fc0:	e0bff317 	ldw	r2,-52(fp)
   16fc4:	10c00017 	ldw	r3,0(r2)
   16fc8:	e0bff017 	ldw	r2,-64(fp)
   16fcc:	1809883a 	mov	r4,r3
   16fd0:	100b883a 	mov	r5,r2
   16fd4:	00131600 	call	13160 <netconn_recved>
  }
  sock_set_errno(sock, 0);
   16fd8:	e0bff317 	ldw	r2,-52(fp)
   16fdc:	10000415 	stw	zero,16(r2)
  return off;
   16fe0:	e0bff017 	ldw	r2,-64(fp)
}
   16fe4:	e037883a 	mov	sp,fp
   16fe8:	dfc00117 	ldw	ra,4(sp)
   16fec:	df000017 	ldw	fp,0(sp)
   16ff0:	dec00204 	addi	sp,sp,8
   16ff4:	f800283a 	ret

00016ff8 <lwip_read>:

int
lwip_read(int s, void *mem, size_t len)
{
   16ff8:	defff904 	addi	sp,sp,-28
   16ffc:	dfc00615 	stw	ra,24(sp)
   17000:	df000515 	stw	fp,20(sp)
   17004:	df000504 	addi	fp,sp,20
   17008:	e13ffd15 	stw	r4,-12(fp)
   1700c:	e17ffe15 	stw	r5,-8(fp)
   17010:	e1bfff15 	stw	r6,-4(fp)
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
   17014:	d8000015 	stw	zero,0(sp)
   17018:	d8000115 	stw	zero,4(sp)
   1701c:	e13ffd17 	ldw	r4,-12(fp)
   17020:	e17ffe17 	ldw	r5,-8(fp)
   17024:	e1bfff17 	ldw	r6,-4(fp)
   17028:	000f883a 	mov	r7,zero
   1702c:	0016b240 	call	16b24 <lwip_recvfrom>
}
   17030:	e037883a 	mov	sp,fp
   17034:	dfc00117 	ldw	ra,4(sp)
   17038:	df000017 	ldw	fp,0(sp)
   1703c:	dec00204 	addi	sp,sp,8
   17040:	f800283a 	ret

00017044 <lwip_recv>:

int
lwip_recv(int s, void *mem, size_t len, int flags)
{
   17044:	defff804 	addi	sp,sp,-32
   17048:	dfc00715 	stw	ra,28(sp)
   1704c:	df000615 	stw	fp,24(sp)
   17050:	df000604 	addi	fp,sp,24
   17054:	e13ffc15 	stw	r4,-16(fp)
   17058:	e17ffd15 	stw	r5,-12(fp)
   1705c:	e1bffe15 	stw	r6,-8(fp)
   17060:	e1ffff15 	stw	r7,-4(fp)
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
   17064:	d8000015 	stw	zero,0(sp)
   17068:	d8000115 	stw	zero,4(sp)
   1706c:	e13ffc17 	ldw	r4,-16(fp)
   17070:	e17ffd17 	ldw	r5,-12(fp)
   17074:	e1bffe17 	ldw	r6,-8(fp)
   17078:	e1ffff17 	ldw	r7,-4(fp)
   1707c:	0016b240 	call	16b24 <lwip_recvfrom>
}
   17080:	e037883a 	mov	sp,fp
   17084:	dfc00117 	ldw	ra,4(sp)
   17088:	df000017 	ldw	fp,0(sp)
   1708c:	dec00204 	addi	sp,sp,8
   17090:	f800283a 	ret

00017094 <lwip_send>:

int
lwip_send(int s, const void *data, size_t size, int flags)
{
   17094:	defff504 	addi	sp,sp,-44
   17098:	dfc00a15 	stw	ra,40(sp)
   1709c:	df000915 	stw	fp,36(sp)
   170a0:	df000904 	addi	fp,sp,36
   170a4:	e13ffc15 	stw	r4,-16(fp)
   170a8:	e17ffd15 	stw	r5,-12(fp)
   170ac:	e1bffe15 	stw	r6,-8(fp)
   170b0:	e1ffff15 	stw	r7,-4(fp)
  size_t written;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%"SZT_F", flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
   170b4:	e13ffc17 	ldw	r4,-16(fp)
   170b8:	00160940 	call	16094 <get_socket>
   170bc:	e0bff915 	stw	r2,-28(fp)
  if (!sock) {
   170c0:	e0bff917 	ldw	r2,-28(fp)
   170c4:	1000021e 	bne	r2,zero,170d0 <lwip_send+0x3c>
    return -1;
   170c8:	00bfffc4 	movi	r2,-1
   170cc:	00003c06 	br	171c0 <lwip_send+0x12c>
  }

  if (sock->conn->type != NETCONN_TCP) {
   170d0:	e0bff917 	ldw	r2,-28(fp)
   170d4:	10800017 	ldw	r2,0(r2)
   170d8:	10800017 	ldw	r2,0(r2)
   170dc:	10800420 	cmpeqi	r2,r2,16
   170e0:	1000081e 	bne	r2,zero,17104 <lwip_send+0x70>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
   170e4:	d8000015 	stw	zero,0(sp)
   170e8:	d8000115 	stw	zero,4(sp)
   170ec:	e13ffc17 	ldw	r4,-16(fp)
   170f0:	e17ffd17 	ldw	r5,-12(fp)
   170f4:	e1bffe17 	ldw	r6,-8(fp)
   170f8:	e1ffff17 	ldw	r7,-4(fp)
   170fc:	00171d40 	call	171d4 <lwip_sendto>
   17100:	00002f06 	br	171c0 <lwip_send+0x12c>
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  write_flags = NETCONN_COPY |
    ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
   17104:	e0bfff17 	ldw	r2,-4(fp)
   17108:	1080040c 	andi	r2,r2,16
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  write_flags = NETCONN_COPY |
   1710c:	10000226 	beq	r2,zero,17118 <lwip_send+0x84>
   17110:	00c000c4 	movi	r3,3
   17114:	00000106 	br	1711c <lwip_send+0x88>
   17118:	00c00044 	movi	r3,1
    ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
    ((flags & MSG_DONTWAIT) ? NETCONN_DONTBLOCK : 0);
   1711c:	e0bfff17 	ldw	r2,-4(fp)
   17120:	1080020c 	andi	r2,r2,8
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  write_flags = NETCONN_COPY |
   17124:	10000226 	beq	r2,zero,17130 <lwip_send+0x9c>
   17128:	00800104 	movi	r2,4
   1712c:	00000106 	br	17134 <lwip_send+0xa0>
   17130:	0005883a 	mov	r2,zero
   17134:	1884b03a 	or	r2,r3,r2
   17138:	e0bffa05 	stb	r2,-24(fp)
    ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
    ((flags & MSG_DONTWAIT) ? NETCONN_DONTBLOCK : 0);
  written = 0;
   1713c:	e03ffb15 	stw	zero,-20(fp)
  err = netconn_write_partly(sock->conn, data, size, write_flags, &written);
   17140:	e0bff917 	ldw	r2,-28(fp)
   17144:	10c00017 	ldw	r3,0(r2)
   17148:	e0bffa03 	ldbu	r2,-24(fp)
   1714c:	e13ffb04 	addi	r4,fp,-20
   17150:	d9000015 	stw	r4,0(sp)
   17154:	1809883a 	mov	r4,r3
   17158:	e17ffd17 	ldw	r5,-12(fp)
   1715c:	e1bffe17 	ldw	r6,-8(fp)
   17160:	100f883a 	mov	r7,r2
   17164:	00133240 	call	13324 <netconn_write_partly>
   17168:	e0bffa45 	stb	r2,-23(fp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d written=%"SZT_F"\n", s, err, written));
  sock_set_errno(sock, err_to_errno(err));
   1716c:	e0bffa47 	ldb	r2,-23(fp)
   17170:	0085c83a 	sub	r2,zero,r2
   17174:	10800428 	cmpgeui	r2,r2,16
   17178:	1000091e 	bne	r2,zero,171a0 <lwip_send+0x10c>
   1717c:	e0bffa47 	ldb	r2,-23(fp)
   17180:	0085c83a 	sub	r2,zero,r2
   17184:	00c00134 	movhi	r3,4
   17188:	18c37404 	addi	r3,r3,3536
   1718c:	1085883a 	add	r2,r2,r2
   17190:	1085883a 	add	r2,r2,r2
   17194:	1885883a 	add	r2,r3,r2
   17198:	10800017 	ldw	r2,0(r2)
   1719c:	00000106 	br	171a4 <lwip_send+0x110>
   171a0:	00800144 	movi	r2,5
   171a4:	e0fff917 	ldw	r3,-28(fp)
   171a8:	18800415 	stw	r2,16(r3)
  return (err == ERR_OK ? (int)written : -1);
   171ac:	e0bffa47 	ldb	r2,-23(fp)
   171b0:	1000021e 	bne	r2,zero,171bc <lwip_send+0x128>
   171b4:	e0bffb17 	ldw	r2,-20(fp)
   171b8:	00000106 	br	171c0 <lwip_send+0x12c>
   171bc:	00bfffc4 	movi	r2,-1
}
   171c0:	e037883a 	mov	sp,fp
   171c4:	dfc00117 	ldw	ra,4(sp)
   171c8:	df000017 	ldw	fp,0(sp)
   171cc:	dec00204 	addi	sp,sp,8
   171d0:	f800283a 	ret

000171d4 <lwip_sendto>:

int
lwip_sendto(int s, const void *data, size_t size, int flags,
       const struct sockaddr *to, socklen_t tolen)
{
   171d4:	defff004 	addi	sp,sp,-64
   171d8:	dfc00f15 	stw	ra,60(sp)
   171dc:	df000e15 	stw	fp,56(sp)
   171e0:	df000e04 	addi	fp,sp,56
   171e4:	e13ffc15 	stw	r4,-16(fp)
   171e8:	e17ffd15 	stw	r5,-12(fp)
   171ec:	e1bffe15 	stw	r6,-8(fp)
   171f0:	e1ffff15 	stw	r7,-4(fp)
  u16_t remote_port;
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
#endif

  sock = get_socket(s);
   171f4:	e13ffc17 	ldw	r4,-16(fp)
   171f8:	00160940 	call	16094 <get_socket>
   171fc:	e0bff315 	stw	r2,-52(fp)
  if (!sock) {
   17200:	e0bff317 	ldw	r2,-52(fp)
   17204:	1000021e 	bne	r2,zero,17210 <lwip_sendto+0x3c>
    return -1;
   17208:	00bfffc4 	movi	r2,-1
   1720c:	00006906 	br	173b4 <lwip_sendto+0x1e0>
  }

  if (sock->conn->type == NETCONN_TCP) {
   17210:	e0bff317 	ldw	r2,-52(fp)
   17214:	10800017 	ldw	r2,0(r2)
   17218:	10800017 	ldw	r2,0(r2)
   1721c:	10800418 	cmpnei	r2,r2,16
   17220:	1000061e 	bne	r2,zero,1723c <lwip_sendto+0x68>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
   17224:	e13ffc17 	ldw	r4,-16(fp)
   17228:	e17ffd17 	ldw	r5,-12(fp)
   1722c:	e1bffe17 	ldw	r6,-8(fp)
   17230:	e1ffff17 	ldw	r7,-4(fp)
   17234:	00170940 	call	17094 <lwip_send>
   17238:	00005e06 	br	173b4 <lwip_sendto+0x1e0>
#endif /* LWIP_TCP */
  }

  /* @todo: split into multiple sendto's? */
  LWIP_ASSERT("lwip_sendto: size must fit in u16_t", size <= 0xffff);
  short_size = (u16_t)size;
   1723c:	e0bffe17 	ldw	r2,-8(fp)
   17240:	e0bff40d 	sth	r2,-48(fp)
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
   17244:	e0800217 	ldw	r2,8(fp)
   17248:	1000021e 	bne	r2,zero,17254 <lwip_sendto+0x80>
   1724c:	e0800317 	ldw	r2,12(fp)
   17250:	10001426 	beq	r2,zero,172a4 <lwip_sendto+0xd0>
   17254:	e0800317 	ldw	r2,12(fp)
   17258:	10800418 	cmpnei	r2,r2,16
   1725c:	1000081e 	bne	r2,zero,17280 <lwip_sendto+0xac>
   17260:	e0800217 	ldw	r2,8(fp)
   17264:	10800043 	ldbu	r2,1(r2)
   17268:	10803fcc 	andi	r2,r2,255
   1726c:	10800098 	cmpnei	r2,r2,2
   17270:	1000031e 	bne	r2,zero,17280 <lwip_sendto+0xac>
   17274:	e0800217 	ldw	r2,8(fp)
   17278:	108000cc 	andi	r2,r2,3
   1727c:	10000926 	beq	r2,zero,172a4 <lwip_sendto+0xd0>
   17280:	01000134 	movhi	r4,4
   17284:	21038404 	addi	r4,r4,3600
   17288:	01400134 	movhi	r5,4
   1728c:	2943a504 	addi	r5,r5,3732
   17290:	0180cf44 	movi	r6,829
   17294:	01c00134 	movhi	r7,4
   17298:	39c39704 	addi	r7,r7,3676
   1729c:	00044740 	call	4474 <printf>
   172a0:	003fff06 	br	172a0 <lwip_sendto+0xcc>
             ((tolen == sizeof(struct sockaddr_in)) &&
             ((to->sa_family) == AF_INET) && ((((mem_ptr_t)to) % 4) == 0))),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);
  to_in = (const struct sockaddr_in *)(void*)to;
   172a4:	e0800217 	ldw	r2,8(fp)
   172a8:	e0bff515 	stw	r2,-44(fp)
      err = ERR_MEM;
    }
  }
#else /* LWIP_TCPIP_CORE_LOCKING */
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
   172ac:	e03ff815 	stw	zero,-32(fp)
   172b0:	e0bff817 	ldw	r2,-32(fp)
   172b4:	e0bff715 	stw	r2,-36(fp)
#if LWIP_CHECKSUM_ON_COPY
  buf.flags = 0;
   172b8:	e03ffa85 	stb	zero,-22(fp)
#endif /* LWIP_CHECKSUM_ON_COPY */
  if (to) {
   172bc:	e0800217 	ldw	r2,8(fp)
   172c0:	10001126 	beq	r2,zero,17308 <lwip_sendto+0x134>
    inet_addr_to_ipaddr(&buf.addr, &to_in->sin_addr);
   172c4:	e0bff517 	ldw	r2,-44(fp)
   172c8:	10800117 	ldw	r2,4(r2)
   172cc:	e0bff915 	stw	r2,-28(fp)
    remote_port           = ntohs(to_in->sin_port);
   172d0:	e0bff517 	ldw	r2,-44(fp)
   172d4:	1080008b 	ldhu	r2,2(r2)
   172d8:	10bfffcc 	andi	r2,r2,65535
   172dc:	1004d23a 	srli	r2,r2,8
   172e0:	1007883a 	mov	r3,r2
   172e4:	e0bff517 	ldw	r2,-44(fp)
   172e8:	1080008b 	ldhu	r2,2(r2)
   172ec:	10bfffcc 	andi	r2,r2,65535
   172f0:	1004923a 	slli	r2,r2,8
   172f4:	1884b03a 	or	r2,r3,r2
   172f8:	e0bff60d 	sth	r2,-40(fp)
    netbuf_fromport(&buf) = remote_port;
   172fc:	e0bff60b 	ldhu	r2,-40(fp)
   17300:	e0bffa0d 	sth	r2,-24(fp)
   17304:	00000306 	br	17314 <lwip_sendto+0x140>
  } else {
    remote_port           = 0;
   17308:	e03ff60d 	sth	zero,-40(fp)
    ip_addr_set_any(&buf.addr);
   1730c:	e03ff915 	stw	zero,-28(fp)
    netbuf_fromport(&buf) = 0;
   17310:	e03ffa0d 	sth	zero,-24(fp)
    {
      err = netbuf_take(&buf, data, short_size);
    }
  }
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  err = netbuf_ref(&buf, data, short_size);
   17314:	e0bff40b 	ldhu	r2,-48(fp)
   17318:	e0fff704 	addi	r3,fp,-36
   1731c:	1809883a 	mov	r4,r3
   17320:	e17ffd17 	ldw	r5,-12(fp)
   17324:	100d883a 	mov	r6,r2
   17328:	0015cd40 	call	15cd4 <netbuf_ref>
   1732c:	e0bff205 	stb	r2,-56(fp)
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (err == ERR_OK) {
   17330:	e0bff207 	ldb	r2,-56(fp)
   17334:	1000071e 	bne	r2,zero,17354 <lwip_sendto+0x180>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
   17338:	e0bff317 	ldw	r2,-52(fp)
   1733c:	10c00017 	ldw	r3,0(r2)
   17340:	e0bff704 	addi	r2,fp,-36
   17344:	1809883a 	mov	r4,r3
   17348:	100b883a 	mov	r5,r2
   1734c:	001325c0 	call	1325c <netconn_send>
   17350:	e0bff205 	stb	r2,-56(fp)
  }

  /* deallocated the buffer */
  netbuf_free(&buf);
   17354:	e0bff704 	addi	r2,fp,-36
   17358:	1009883a 	mov	r4,r2
   1735c:	0015c4c0 	call	15c4c <netbuf_free>
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
   17360:	e0bff207 	ldb	r2,-56(fp)
   17364:	0085c83a 	sub	r2,zero,r2
   17368:	10800428 	cmpgeui	r2,r2,16
   1736c:	1000091e 	bne	r2,zero,17394 <lwip_sendto+0x1c0>
   17370:	e0bff207 	ldb	r2,-56(fp)
   17374:	0085c83a 	sub	r2,zero,r2
   17378:	00c00134 	movhi	r3,4
   1737c:	18c37404 	addi	r3,r3,3536
   17380:	1085883a 	add	r2,r2,r2
   17384:	1085883a 	add	r2,r2,r2
   17388:	1885883a 	add	r2,r3,r2
   1738c:	10800017 	ldw	r2,0(r2)
   17390:	00000106 	br	17398 <lwip_sendto+0x1c4>
   17394:	00800144 	movi	r2,5
   17398:	e0fff317 	ldw	r3,-52(fp)
   1739c:	18800415 	stw	r2,16(r3)
  return (err == ERR_OK ? short_size : -1);
   173a0:	e0bff207 	ldb	r2,-56(fp)
   173a4:	1000021e 	bne	r2,zero,173b0 <lwip_sendto+0x1dc>
   173a8:	e0bff40b 	ldhu	r2,-48(fp)
   173ac:	00000106 	br	173b4 <lwip_sendto+0x1e0>
   173b0:	00bfffc4 	movi	r2,-1
}
   173b4:	e037883a 	mov	sp,fp
   173b8:	dfc00117 	ldw	ra,4(sp)
   173bc:	df000017 	ldw	fp,0(sp)
   173c0:	dec00204 	addi	sp,sp,8
   173c4:	f800283a 	ret

000173c8 <lwip_socket>:

int
lwip_socket(int domain, int type, int protocol)
{
   173c8:	defff904 	addi	sp,sp,-28
   173cc:	dfc00615 	stw	ra,24(sp)
   173d0:	df000515 	stw	fp,20(sp)
   173d4:	df000504 	addi	fp,sp,20
   173d8:	e13ffd15 	stw	r4,-12(fp)
   173dc:	e17ffe15 	stw	r5,-8(fp)
   173e0:	e1bfff15 	stw	r6,-4(fp)
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
   173e4:	e0bffe17 	ldw	r2,-8(fp)
   173e8:	10c000a0 	cmpeqi	r3,r2,2
   173ec:	18000e1e 	bne	r3,zero,17428 <lwip_socket+0x60>
   173f0:	10c000e0 	cmpeqi	r3,r2,3
   173f4:	1800031e 	bne	r3,zero,17404 <lwip_socket+0x3c>
   173f8:	10800060 	cmpeqi	r2,r2,1
   173fc:	1000171e 	bne	r2,zero,1745c <lwip_socket+0x94>
   17400:	00002506 	br	17498 <lwip_socket+0xd0>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
   17404:	e0bfff17 	ldw	r2,-4(fp)
   17408:	10803fcc 	andi	r2,r2,255
   1740c:	01001004 	movi	r4,64
   17410:	100b883a 	mov	r5,r2
   17414:	01800074 	movhi	r6,1
   17418:	319f6d04 	addi	r6,r6,32180
   1741c:	00125380 	call	12538 <netconn_new_with_proto_and_callback>
   17420:	e0bffb15 	stw	r2,-20(fp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
   17424:	00001f06 	br	174a4 <lwip_socket+0xdc>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
   17428:	e0bfff17 	ldw	r2,-4(fp)
   1742c:	10802218 	cmpnei	r2,r2,136
   17430:	1000021e 	bne	r2,zero,1743c <lwip_socket+0x74>
   17434:	00800844 	movi	r2,33
   17438:	00000106 	br	17440 <lwip_socket+0x78>
   1743c:	00800804 	movi	r2,32
   17440:	1009883a 	mov	r4,r2
   17444:	000b883a 	mov	r5,zero
   17448:	01800074 	movhi	r6,1
   1744c:	319f6d04 	addi	r6,r6,32180
   17450:	00125380 	call	12538 <netconn_new_with_proto_and_callback>
   17454:	e0bffb15 	stw	r2,-20(fp)
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
   17458:	00001206 	br	174a4 <lwip_socket+0xdc>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
   1745c:	01000404 	movi	r4,16
   17460:	000b883a 	mov	r5,zero
   17464:	01800074 	movhi	r6,1
   17468:	319f6d04 	addi	r6,r6,32180
   1746c:	00125380 	call	12538 <netconn_new_with_proto_and_callback>
   17470:	e0bffb15 	stw	r2,-20(fp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    if (conn != NULL) {
   17474:	e0bffb17 	ldw	r2,-20(fp)
   17478:	10000926 	beq	r2,zero,174a0 <lwip_socket+0xd8>
      /* Prevent automatic window updates, we do this on our own! */
      netconn_set_noautorecved(conn, 1);
   1747c:	e0bffb17 	ldw	r2,-20(fp)
   17480:	10800903 	ldbu	r2,36(r2)
   17484:	10800214 	ori	r2,r2,8
   17488:	1007883a 	mov	r3,r2
   1748c:	e0bffb17 	ldw	r2,-20(fp)
   17490:	10c00905 	stb	r3,36(r2)
    }
    break;
   17494:	00000206 	br	174a0 <lwip_socket+0xd8>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
    return -1;
   17498:	00bfffc4 	movi	r2,-1
   1749c:	00001706 	br	174fc <lwip_socket+0x134>
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    if (conn != NULL) {
      /* Prevent automatic window updates, we do this on our own! */
      netconn_set_noautorecved(conn, 1);
    }
    break;
   174a0:	0001883a 	nop
                                 domain, type, protocol));
    set_errno(EINVAL);
    return -1;
  }

  if (!conn) {
   174a4:	e0bffb17 	ldw	r2,-20(fp)
   174a8:	1000021e 	bne	r2,zero,174b4 <lwip_socket+0xec>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
    return -1;
   174ac:	00bfffc4 	movi	r2,-1
   174b0:	00001206 	br	174fc <lwip_socket+0x134>
  }

  i = alloc_socket(conn, 0);
   174b4:	e13ffb17 	ldw	r4,-20(fp)
   174b8:	000b883a 	mov	r5,zero
   174bc:	001618c0 	call	1618c <alloc_socket>
   174c0:	e0bffc15 	stw	r2,-16(fp)

  if (i == -1) {
   174c4:	e0bffc17 	ldw	r2,-16(fp)
   174c8:	10bfffd8 	cmpnei	r2,r2,-1
   174cc:	1000041e 	bne	r2,zero,174e0 <lwip_socket+0x118>
    netconn_delete(conn);
   174d0:	e13ffb17 	ldw	r4,-20(fp)
   174d4:	00125f40 	call	125f4 <netconn_delete>
    set_errno(ENFILE);
    return -1;
   174d8:	00bfffc4 	movi	r2,-1
   174dc:	00000706 	br	174fc <lwip_socket+0x134>
  }

  i += LWIP_SOCKET_OFFSET;
   174e0:	e0bffc17 	ldw	r2,-16(fp)
   174e4:	10800804 	addi	r2,r2,32
   174e8:	e0bffc15 	stw	r2,-16(fp)

  conn->socket = i;
   174ec:	e0bffb17 	ldw	r2,-20(fp)
   174f0:	e0fffc17 	ldw	r3,-16(fp)
   174f4:	10c00715 	stw	r3,28(r2)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  return i;
   174f8:	e0bffc17 	ldw	r2,-16(fp)
}
   174fc:	e037883a 	mov	sp,fp
   17500:	dfc00117 	ldw	ra,4(sp)
   17504:	df000017 	ldw	fp,0(sp)
   17508:	dec00204 	addi	sp,sp,8
   1750c:	f800283a 	ret

00017510 <lwip_write>:

int
lwip_write(int s, const void *data, size_t size)
{
   17510:	defffb04 	addi	sp,sp,-20
   17514:	dfc00415 	stw	ra,16(sp)
   17518:	df000315 	stw	fp,12(sp)
   1751c:	df000304 	addi	fp,sp,12
   17520:	e13ffd15 	stw	r4,-12(fp)
   17524:	e17ffe15 	stw	r5,-8(fp)
   17528:	e1bfff15 	stw	r6,-4(fp)
  return lwip_send(s, data, size, 0);
   1752c:	e13ffd17 	ldw	r4,-12(fp)
   17530:	e17ffe17 	ldw	r5,-8(fp)
   17534:	e1bfff17 	ldw	r6,-4(fp)
   17538:	000f883a 	mov	r7,zero
   1753c:	00170940 	call	17094 <lwip_send>
}
   17540:	e037883a 	mov	sp,fp
   17544:	dfc00117 	ldw	ra,4(sp)
   17548:	df000017 	ldw	fp,0(sp)
   1754c:	dec00204 	addi	sp,sp,8
   17550:	f800283a 	ret

00017554 <lwip_selscan>:
 * @return number of sockets that had events (read/write/exception) (>= 0)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset_in, fd_set *writeset_in, fd_set *exceptset_in,
             fd_set *readset_out, fd_set *writeset_out, fd_set *exceptset_out)
{
   17554:	deffe804 	addi	sp,sp,-96
   17558:	dfc01715 	stw	ra,92(sp)
   1755c:	df001615 	stw	fp,88(sp)
   17560:	df001604 	addi	fp,sp,88
   17564:	e13ffc15 	stw	r4,-16(fp)
   17568:	e17ffd15 	stw	r5,-12(fp)
   1756c:	e1bffe15 	stw	r6,-8(fp)
   17570:	e1ffff15 	stw	r7,-4(fp)
  int i, nready = 0;
   17574:	e03feb15 	stw	zero,-84(fp)
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_sock *sock;
  SYS_ARCH_DECL_PROTECT(lev);

  FD_ZERO(&lreadset);
   17578:	e0bff604 	addi	r2,fp,-40
   1757c:	e0bfed15 	stw	r2,-76(fp)
   17580:	e03fec15 	stw	zero,-80(fp)
   17584:	00000806 	br	175a8 <lwip_selscan+0x54>
   17588:	e0bfed17 	ldw	r2,-76(fp)
   1758c:	10000005 	stb	zero,0(r2)
   17590:	e0bfed17 	ldw	r2,-76(fp)
   17594:	10800044 	addi	r2,r2,1
   17598:	e0bfed15 	stw	r2,-76(fp)
   1759c:	e0bfec17 	ldw	r2,-80(fp)
   175a0:	10800044 	addi	r2,r2,1
   175a4:	e0bfec15 	stw	r2,-80(fp)
   175a8:	e0bfec17 	ldw	r2,-80(fp)
   175ac:	10800230 	cmpltui	r2,r2,8
   175b0:	103ff51e 	bne	r2,zero,17588 <lwip_selscan+0x34>
  FD_ZERO(&lwriteset);
   175b4:	e0bff804 	addi	r2,fp,-32
   175b8:	e0bfef15 	stw	r2,-68(fp)
   175bc:	e03fee15 	stw	zero,-72(fp)
   175c0:	00000806 	br	175e4 <lwip_selscan+0x90>
   175c4:	e0bfef17 	ldw	r2,-68(fp)
   175c8:	10000005 	stb	zero,0(r2)
   175cc:	e0bfef17 	ldw	r2,-68(fp)
   175d0:	10800044 	addi	r2,r2,1
   175d4:	e0bfef15 	stw	r2,-68(fp)
   175d8:	e0bfee17 	ldw	r2,-72(fp)
   175dc:	10800044 	addi	r2,r2,1
   175e0:	e0bfee15 	stw	r2,-72(fp)
   175e4:	e0bfee17 	ldw	r2,-72(fp)
   175e8:	10800230 	cmpltui	r2,r2,8
   175ec:	103ff51e 	bne	r2,zero,175c4 <lwip_selscan+0x70>
  FD_ZERO(&lexceptset);
   175f0:	e0bffa04 	addi	r2,fp,-24
   175f4:	e0bff115 	stw	r2,-60(fp)
   175f8:	e03ff015 	stw	zero,-64(fp)
   175fc:	00000806 	br	17620 <lwip_selscan+0xcc>
   17600:	e0bff117 	ldw	r2,-60(fp)
   17604:	10000005 	stb	zero,0(r2)
   17608:	e0bff117 	ldw	r2,-60(fp)
   1760c:	10800044 	addi	r2,r2,1
   17610:	e0bff115 	stw	r2,-60(fp)
   17614:	e0bff017 	ldw	r2,-64(fp)
   17618:	10800044 	addi	r2,r2,1
   1761c:	e0bff015 	stw	r2,-64(fp)
   17620:	e0bff017 	ldw	r2,-64(fp)
   17624:	10800230 	cmpltui	r2,r2,8
   17628:	103ff51e 	bne	r2,zero,17600 <lwip_selscan+0xac>

  /* Go through each socket in each list to count number of sockets which
     currently match */
  for(i = LWIP_SOCKET_OFFSET; i < maxfdp1; i++) {
   1762c:	00800804 	movi	r2,32
   17630:	e0bfea15 	stw	r2,-88(fp)
   17634:	00009206 	br	17880 <lwip_selscan+0x32c>
    void* lastdata = NULL;
   17638:	e03ff215 	stw	zero,-56(fp)
    s16_t rcvevent = 0;
   1763c:	e03ff30d 	sth	zero,-52(fp)
    u16_t sendevent = 0;
   17640:	e03ff38d 	sth	zero,-50(fp)
    u16_t errevent = 0;
   17644:	e03ff40d 	sth	zero,-48(fp)
    /* First get the socket's status (protected)... */
    SYS_ARCH_PROTECT(lev);
   17648:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   1764c:	10000126 	beq	r2,zero,17654 <lwip_selscan+0x100>
   17650:	00110d00 	call	110d0 <vTaskEnterCritical>
    sock = tryget_socket(i);
   17654:	e13fea17 	ldw	r4,-88(fp)
   17658:	001610c0 	call	1610c <tryget_socket>
   1765c:	e0bff515 	stw	r2,-44(fp)
    if (sock != NULL) {
   17660:	e0bff517 	ldw	r2,-44(fp)
   17664:	10000c26 	beq	r2,zero,17698 <lwip_selscan+0x144>
      lastdata = sock->lastdata;
   17668:	e0bff517 	ldw	r2,-44(fp)
   1766c:	10800117 	ldw	r2,4(r2)
   17670:	e0bff215 	stw	r2,-56(fp)
      rcvevent = sock->rcvevent;
   17674:	e0bff517 	ldw	r2,-44(fp)
   17678:	1080028b 	ldhu	r2,10(r2)
   1767c:	e0bff30d 	sth	r2,-52(fp)
      sendevent = sock->sendevent;
   17680:	e0bff517 	ldw	r2,-44(fp)
   17684:	1080030b 	ldhu	r2,12(r2)
   17688:	e0bff38d 	sth	r2,-50(fp)
      errevent = sock->errevent;
   1768c:	e0bff517 	ldw	r2,-44(fp)
   17690:	1080038b 	ldhu	r2,14(r2)
   17694:	e0bff40d 	sth	r2,-48(fp)
    }
    SYS_ARCH_UNPROTECT(lev);
   17698:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   1769c:	10000126 	beq	r2,zero,176a4 <lwip_selscan+0x150>
   176a0:	00111100 	call	11110 <vTaskExitCritical>
    /* ... then examine it: */
    /* See if netconn of this socket is ready for read */
    if (readset_in && FD_ISSET(i, readset_in) && ((lastdata != NULL) || (rcvevent > 0))) {
   176a4:	e0bffd17 	ldw	r2,-12(fp)
   176a8:	10002626 	beq	r2,zero,17744 <lwip_selscan+0x1f0>
   176ac:	e0bfea17 	ldw	r2,-88(fp)
   176b0:	1004d17a 	srli	r2,r2,5
   176b4:	e0fffd17 	ldw	r3,-12(fp)
   176b8:	1085883a 	add	r2,r2,r2
   176bc:	1085883a 	add	r2,r2,r2
   176c0:	1885883a 	add	r2,r3,r2
   176c4:	10c00017 	ldw	r3,0(r2)
   176c8:	e0bfea17 	ldw	r2,-88(fp)
   176cc:	108007cc 	andi	r2,r2,31
   176d0:	1885d83a 	sra	r2,r3,r2
   176d4:	1080004c 	andi	r2,r2,1
   176d8:	10001a26 	beq	r2,zero,17744 <lwip_selscan+0x1f0>
   176dc:	e0bff217 	ldw	r2,-56(fp)
   176e0:	1000021e 	bne	r2,zero,176ec <lwip_selscan+0x198>
   176e4:	e0bff30f 	ldh	r2,-52(fp)
   176e8:	0080160e 	bge	zero,r2,17744 <lwip_selscan+0x1f0>
      FD_SET(i, &lreadset);
   176ec:	e0bfea17 	ldw	r2,-88(fp)
   176f0:	1004d17a 	srli	r2,r2,5
   176f4:	1087883a 	add	r3,r2,r2
   176f8:	18c7883a 	add	r3,r3,r3
   176fc:	e13fea04 	addi	r4,fp,-88
   17700:	20c7883a 	add	r3,r4,r3
   17704:	18c00c04 	addi	r3,r3,48
   17708:	19000017 	ldw	r4,0(r3)
   1770c:	e0ffea17 	ldw	r3,-88(fp)
   17710:	18c007cc 	andi	r3,r3,31
   17714:	01400044 	movi	r5,1
   17718:	28c6983a 	sll	r3,r5,r3
   1771c:	20c6b03a 	or	r3,r4,r3
   17720:	1085883a 	add	r2,r2,r2
   17724:	1085883a 	add	r2,r2,r2
   17728:	e13fea04 	addi	r4,fp,-88
   1772c:	2085883a 	add	r2,r4,r2
   17730:	10800c04 	addi	r2,r2,48
   17734:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
      nready++;
   17738:	e0bfeb17 	ldw	r2,-84(fp)
   1773c:	10800044 	addi	r2,r2,1
   17740:	e0bfeb15 	stw	r2,-84(fp)
    }
    /* See if netconn of this socket is ready for write */
    if (writeset_in && FD_ISSET(i, writeset_in) && (sendevent != 0)) {
   17744:	e0bffe17 	ldw	r2,-8(fp)
   17748:	10002426 	beq	r2,zero,177dc <lwip_selscan+0x288>
   1774c:	e0bfea17 	ldw	r2,-88(fp)
   17750:	1004d17a 	srli	r2,r2,5
   17754:	e0fffe17 	ldw	r3,-8(fp)
   17758:	1085883a 	add	r2,r2,r2
   1775c:	1085883a 	add	r2,r2,r2
   17760:	1885883a 	add	r2,r3,r2
   17764:	10c00017 	ldw	r3,0(r2)
   17768:	e0bfea17 	ldw	r2,-88(fp)
   1776c:	108007cc 	andi	r2,r2,31
   17770:	1885d83a 	sra	r2,r3,r2
   17774:	1080004c 	andi	r2,r2,1
   17778:	10001826 	beq	r2,zero,177dc <lwip_selscan+0x288>
   1777c:	e0bff38b 	ldhu	r2,-50(fp)
   17780:	10001626 	beq	r2,zero,177dc <lwip_selscan+0x288>
      FD_SET(i, &lwriteset);
   17784:	e0bfea17 	ldw	r2,-88(fp)
   17788:	1004d17a 	srli	r2,r2,5
   1778c:	1087883a 	add	r3,r2,r2
   17790:	18c7883a 	add	r3,r3,r3
   17794:	e13fea04 	addi	r4,fp,-88
   17798:	20c7883a 	add	r3,r4,r3
   1779c:	18c00e04 	addi	r3,r3,56
   177a0:	19000017 	ldw	r4,0(r3)
   177a4:	e0ffea17 	ldw	r3,-88(fp)
   177a8:	18c007cc 	andi	r3,r3,31
   177ac:	01400044 	movi	r5,1
   177b0:	28c6983a 	sll	r3,r5,r3
   177b4:	20c6b03a 	or	r3,r4,r3
   177b8:	1085883a 	add	r2,r2,r2
   177bc:	1085883a 	add	r2,r2,r2
   177c0:	e13fea04 	addi	r4,fp,-88
   177c4:	2085883a 	add	r2,r4,r2
   177c8:	10800e04 	addi	r2,r2,56
   177cc:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
      nready++;
   177d0:	e0bfeb17 	ldw	r2,-84(fp)
   177d4:	10800044 	addi	r2,r2,1
   177d8:	e0bfeb15 	stw	r2,-84(fp)
    }
    /* See if netconn of this socket had an error */
    if (exceptset_in && FD_ISSET(i, exceptset_in) && (errevent != 0)) {
   177dc:	e0bfff17 	ldw	r2,-4(fp)
   177e0:	10002426 	beq	r2,zero,17874 <lwip_selscan+0x320>
   177e4:	e0bfea17 	ldw	r2,-88(fp)
   177e8:	1004d17a 	srli	r2,r2,5
   177ec:	e0ffff17 	ldw	r3,-4(fp)
   177f0:	1085883a 	add	r2,r2,r2
   177f4:	1085883a 	add	r2,r2,r2
   177f8:	1885883a 	add	r2,r3,r2
   177fc:	10c00017 	ldw	r3,0(r2)
   17800:	e0bfea17 	ldw	r2,-88(fp)
   17804:	108007cc 	andi	r2,r2,31
   17808:	1885d83a 	sra	r2,r3,r2
   1780c:	1080004c 	andi	r2,r2,1
   17810:	10001826 	beq	r2,zero,17874 <lwip_selscan+0x320>
   17814:	e0bff40b 	ldhu	r2,-48(fp)
   17818:	10001626 	beq	r2,zero,17874 <lwip_selscan+0x320>
      FD_SET(i, &lexceptset);
   1781c:	e0bfea17 	ldw	r2,-88(fp)
   17820:	1004d17a 	srli	r2,r2,5
   17824:	1087883a 	add	r3,r2,r2
   17828:	18c7883a 	add	r3,r3,r3
   1782c:	e13fea04 	addi	r4,fp,-88
   17830:	20c7883a 	add	r3,r4,r3
   17834:	18c01004 	addi	r3,r3,64
   17838:	19000017 	ldw	r4,0(r3)
   1783c:	e0ffea17 	ldw	r3,-88(fp)
   17840:	18c007cc 	andi	r3,r3,31
   17844:	01400044 	movi	r5,1
   17848:	28c6983a 	sll	r3,r5,r3
   1784c:	20c6b03a 	or	r3,r4,r3
   17850:	1085883a 	add	r2,r2,r2
   17854:	1085883a 	add	r2,r2,r2
   17858:	e13fea04 	addi	r4,fp,-88
   1785c:	2085883a 	add	r2,r4,r2
   17860:	10801004 	addi	r2,r2,64
   17864:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for exception\n", i));
      nready++;
   17868:	e0bfeb17 	ldw	r2,-84(fp)
   1786c:	10800044 	addi	r2,r2,1
   17870:	e0bfeb15 	stw	r2,-84(fp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);

  /* Go through each socket in each list to count number of sockets which
     currently match */
  for(i = LWIP_SOCKET_OFFSET; i < maxfdp1; i++) {
   17874:	e0bfea17 	ldw	r2,-88(fp)
   17878:	10800044 	addi	r2,r2,1
   1787c:	e0bfea15 	stw	r2,-88(fp)
   17880:	e0ffea17 	ldw	r3,-88(fp)
   17884:	e0bffc17 	ldw	r2,-16(fp)
   17888:	18bf6b16 	blt	r3,r2,17638 <lwip_selscan+0xe4>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for exception\n", i));
      nready++;
    }
  }
  /* copy local sets to the ones provided as arguments */
  *readset_out = lreadset;
   1788c:	e0800217 	ldw	r2,8(fp)
   17890:	e0fff617 	ldw	r3,-40(fp)
   17894:	10c00015 	stw	r3,0(r2)
   17898:	e0fff717 	ldw	r3,-36(fp)
   1789c:	10c00115 	stw	r3,4(r2)
  *writeset_out = lwriteset;
   178a0:	e0800317 	ldw	r2,12(fp)
   178a4:	e0fff817 	ldw	r3,-32(fp)
   178a8:	10c00015 	stw	r3,0(r2)
   178ac:	e0fff917 	ldw	r3,-28(fp)
   178b0:	10c00115 	stw	r3,4(r2)
  *exceptset_out = lexceptset;
   178b4:	e0800417 	ldw	r2,16(fp)
   178b8:	e0fffa17 	ldw	r3,-24(fp)
   178bc:	10c00015 	stw	r3,0(r2)
   178c0:	e0fffb17 	ldw	r3,-20(fp)
   178c4:	10c00115 	stw	r3,4(r2)

  LWIP_ASSERT("nready >= 0", nready >= 0);
  return nready;
   178c8:	e0bfeb17 	ldw	r2,-84(fp)
}
   178cc:	e037883a 	mov	sp,fp
   178d0:	dfc00117 	ldw	ra,4(sp)
   178d4:	df000017 	ldw	fp,0(sp)
   178d8:	dec00204 	addi	sp,sp,8
   178dc:	f800283a 	ret

000178e0 <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
            struct timeval *timeout)
{
   178e0:	deffe304 	addi	sp,sp,-116
   178e4:	dfc01c15 	stw	ra,112(sp)
   178e8:	df001b15 	stw	fp,108(sp)
   178ec:	df001b04 	addi	fp,sp,108
   178f0:	e13ffc15 	stw	r4,-16(fp)
   178f4:	e17ffd15 	stw	r5,-12(fp)
   178f8:	e1bffe15 	stw	r6,-8(fp)
   178fc:	e1ffff15 	stw	r7,-4(fp)
  u32_t waitres = 0;
   17900:	e03fe815 	stw	zero,-96(fp)
                  timeout ? (s32_t)timeout->tv_sec : (s32_t)-1,
                  timeout ? (s32_t)timeout->tv_usec : (s32_t)-1));

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
   17904:	e0bfef04 	addi	r2,fp,-68
   17908:	d8800015 	stw	r2,0(sp)
   1790c:	e0bff104 	addi	r2,fp,-60
   17910:	d8800115 	stw	r2,4(sp)
   17914:	e0bff304 	addi	r2,fp,-52
   17918:	d8800215 	stw	r2,8(sp)
   1791c:	e13ffc17 	ldw	r4,-16(fp)
   17920:	e17ffd17 	ldw	r5,-12(fp)
   17924:	e1bffe17 	ldw	r6,-8(fp)
   17928:	e1ffff17 	ldw	r7,-4(fp)
   1792c:	00175540 	call	17554 <lwip_selscan>
   17930:	e0bfe915 	stw	r2,-92(fp)

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
   17934:	e0bfe917 	ldw	r2,-92(fp)
   17938:	1001031e 	bne	r2,zero,17d48 <lwip_select+0x468>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
   1793c:	e0800217 	ldw	r2,8(fp)
   17940:	10000626 	beq	r2,zero,1795c <lwip_select+0x7c>
   17944:	e0800217 	ldw	r2,8(fp)
   17948:	10800017 	ldw	r2,0(r2)
   1794c:	1000031e 	bne	r2,zero,1795c <lwip_select+0x7c>
   17950:	e0800217 	ldw	r2,8(fp)
   17954:	10800117 	ldw	r2,4(r2)
   17958:	1000f826 	beq	r2,zero,17d3c <lwip_select+0x45c>
    /* None ready: add our semaphore to list:
       We don't actually need any dynamic memory. Our entry on the
       list is only valid while we are in this function, so it's ok
       to use local variables. */

    select_cb.next = NULL;
   1795c:	e03ff515 	stw	zero,-44(fp)
    select_cb.prev = NULL;
   17960:	e03ff615 	stw	zero,-40(fp)
    select_cb.readset = readset;
   17964:	e0bffd17 	ldw	r2,-12(fp)
   17968:	e0bff715 	stw	r2,-36(fp)
    select_cb.writeset = writeset;
   1796c:	e0bffe17 	ldw	r2,-8(fp)
   17970:	e0bff815 	stw	r2,-32(fp)
    select_cb.exceptset = exceptset;
   17974:	e0bfff17 	ldw	r2,-4(fp)
   17978:	e0bff915 	stw	r2,-28(fp)
    select_cb.sem_signalled = 0;
   1797c:	e03ffa15 	stw	zero,-24(fp)
    err = sys_sem_new(&select_cb.sem, 0);
   17980:	e0bff504 	addi	r2,fp,-44
   17984:	10800604 	addi	r2,r2,24
   17988:	1009883a 	mov	r4,r2
   1798c:	000b883a 	mov	r5,zero
   17990:	001b1bc0 	call	1b1bc <sys_sem_new>
   17994:	e0bfec05 	stb	r2,-80(fp)
    if (err != ERR_OK) {
   17998:	e0bfec07 	ldb	r2,-80(fp)
   1799c:	10000226 	beq	r2,zero,179a8 <lwip_select+0xc8>
      /* failed to create semaphore */
      set_errno(ENOMEM);
      return -1;
   179a0:	00bfffc4 	movi	r2,-1
   179a4:	0000fe06 	br	17da0 <lwip_select+0x4c0>
    }

    /* Protect the select_cb_list */
    SYS_ARCH_PROTECT(lev);
   179a8:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   179ac:	10000126 	beq	r2,zero,179b4 <lwip_select+0xd4>
   179b0:	00110d00 	call	110d0 <vTaskEnterCritical>

    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
   179b4:	d0a91a17 	ldw	r2,-23448(gp)
   179b8:	e0bff515 	stw	r2,-44(fp)
    if (select_cb_list != NULL) {
   179bc:	d0a91a17 	ldw	r2,-23448(gp)
   179c0:	10000326 	beq	r2,zero,179d0 <lwip_select+0xf0>
      select_cb_list->prev = &select_cb;
   179c4:	d0a91a17 	ldw	r2,-23448(gp)
   179c8:	e0fff504 	addi	r3,fp,-44
   179cc:	10c00115 	stw	r3,4(r2)
    }
    select_cb_list = &select_cb;
   179d0:	e0bff504 	addi	r2,fp,-44
   179d4:	d0a91a15 	stw	r2,-23448(gp)
    /* Increasing this counter tells even_callback that the list has changed. */
    select_cb_ctr++;
   179d8:	d0a91b17 	ldw	r2,-23444(gp)
   179dc:	10800044 	addi	r2,r2,1
   179e0:	d0a91b15 	stw	r2,-23444(gp)

    /* Now we can safely unprotect */
    SYS_ARCH_UNPROTECT(lev);
   179e4:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   179e8:	10000126 	beq	r2,zero,179f0 <lwip_select+0x110>
   179ec:	00111100 	call	11110 <vTaskExitCritical>

    /* Increase select_waiting for each socket we are interested in */
    for(i = LWIP_SOCKET_OFFSET; i < maxfdp1; i++) {
   179f0:	00800804 	movi	r2,32
   179f4:	e0bfeb15 	stw	r2,-84(fp)
   179f8:	00003b06 	br	17ae8 <lwip_select+0x208>
      if ((readset && FD_ISSET(i, readset)) ||
   179fc:	e0bffd17 	ldw	r2,-12(fp)
   17a00:	10000c26 	beq	r2,zero,17a34 <lwip_select+0x154>
   17a04:	e0bfeb17 	ldw	r2,-84(fp)
   17a08:	1004d17a 	srli	r2,r2,5
   17a0c:	e0fffd17 	ldw	r3,-12(fp)
   17a10:	1085883a 	add	r2,r2,r2
   17a14:	1085883a 	add	r2,r2,r2
   17a18:	1885883a 	add	r2,r3,r2
   17a1c:	10c00017 	ldw	r3,0(r2)
   17a20:	e0bfeb17 	ldw	r2,-84(fp)
   17a24:	108007cc 	andi	r2,r2,31
   17a28:	1885d83a 	sra	r2,r3,r2
   17a2c:	1080004c 	andi	r2,r2,1
   17a30:	10001c1e 	bne	r2,zero,17aa4 <lwip_select+0x1c4>
   17a34:	e0bffe17 	ldw	r2,-8(fp)
   17a38:	10000c26 	beq	r2,zero,17a6c <lwip_select+0x18c>
          (writeset && FD_ISSET(i, writeset)) ||
   17a3c:	e0bfeb17 	ldw	r2,-84(fp)
   17a40:	1004d17a 	srli	r2,r2,5
   17a44:	e0fffe17 	ldw	r3,-8(fp)
   17a48:	1085883a 	add	r2,r2,r2
   17a4c:	1085883a 	add	r2,r2,r2
   17a50:	1885883a 	add	r2,r3,r2
   17a54:	10c00017 	ldw	r3,0(r2)
   17a58:	e0bfeb17 	ldw	r2,-84(fp)
   17a5c:	108007cc 	andi	r2,r2,31
   17a60:	1885d83a 	sra	r2,r3,r2
   17a64:	1080004c 	andi	r2,r2,1
   17a68:	10000e1e 	bne	r2,zero,17aa4 <lwip_select+0x1c4>
   17a6c:	e0bfff17 	ldw	r2,-4(fp)
   17a70:	10001a26 	beq	r2,zero,17adc <lwip_select+0x1fc>
          (exceptset && FD_ISSET(i, exceptset))) {
   17a74:	e0bfeb17 	ldw	r2,-84(fp)
   17a78:	1004d17a 	srli	r2,r2,5
   17a7c:	e0ffff17 	ldw	r3,-4(fp)
   17a80:	1085883a 	add	r2,r2,r2
   17a84:	1085883a 	add	r2,r2,r2
   17a88:	1885883a 	add	r2,r3,r2
   17a8c:	10c00017 	ldw	r3,0(r2)
   17a90:	e0bfeb17 	ldw	r2,-84(fp)
   17a94:	108007cc 	andi	r2,r2,31
   17a98:	1885d83a 	sra	r2,r3,r2
   17a9c:	1080004c 	andi	r2,r2,1
   17aa0:	10000e26 	beq	r2,zero,17adc <lwip_select+0x1fc>
        struct lwip_sock *sock = tryget_socket(i);
   17aa4:	e13feb17 	ldw	r4,-84(fp)
   17aa8:	001610c0 	call	1610c <tryget_socket>
   17aac:	e0bfed15 	stw	r2,-76(fp)
        LWIP_ASSERT("sock != NULL", sock != NULL);
        SYS_ARCH_PROTECT(lev);
   17ab0:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   17ab4:	10000126 	beq	r2,zero,17abc <lwip_select+0x1dc>
   17ab8:	00110d00 	call	110d0 <vTaskEnterCritical>
        sock->select_waiting++;
   17abc:	e0bfed17 	ldw	r2,-76(fp)
   17ac0:	10800517 	ldw	r2,20(r2)
   17ac4:	10c00044 	addi	r3,r2,1
   17ac8:	e0bfed17 	ldw	r2,-76(fp)
   17acc:	10c00515 	stw	r3,20(r2)
        LWIP_ASSERT("sock->select_waiting > 0", sock->select_waiting > 0);
        SYS_ARCH_UNPROTECT(lev);
   17ad0:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   17ad4:	10000126 	beq	r2,zero,17adc <lwip_select+0x1fc>
   17ad8:	00111100 	call	11110 <vTaskExitCritical>

    /* Now we can safely unprotect */
    SYS_ARCH_UNPROTECT(lev);

    /* Increase select_waiting for each socket we are interested in */
    for(i = LWIP_SOCKET_OFFSET; i < maxfdp1; i++) {
   17adc:	e0bfeb17 	ldw	r2,-84(fp)
   17ae0:	10800044 	addi	r2,r2,1
   17ae4:	e0bfeb15 	stw	r2,-84(fp)
   17ae8:	e0ffeb17 	ldw	r3,-84(fp)
   17aec:	e0bffc17 	ldw	r2,-16(fp)
   17af0:	18bfc216 	blt	r3,r2,179fc <lwip_select+0x11c>
      }
    }

    /* Call lwip_selscan again: there could have been events between
       the last scan (whithout us on the list) and putting us on the list! */
    nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
   17af4:	e0bfef04 	addi	r2,fp,-68
   17af8:	d8800015 	stw	r2,0(sp)
   17afc:	e0bff104 	addi	r2,fp,-60
   17b00:	d8800115 	stw	r2,4(sp)
   17b04:	e0bff304 	addi	r2,fp,-52
   17b08:	d8800215 	stw	r2,8(sp)
   17b0c:	e13ffc17 	ldw	r4,-16(fp)
   17b10:	e17ffd17 	ldw	r5,-12(fp)
   17b14:	e1bffe17 	ldw	r6,-8(fp)
   17b18:	e1ffff17 	ldw	r7,-4(fp)
   17b1c:	00175540 	call	17554 <lwip_selscan>
   17b20:	e0bfe915 	stw	r2,-92(fp)
    if (!nready) {
   17b24:	e0bfe917 	ldw	r2,-92(fp)
   17b28:	1000181e 	bne	r2,zero,17b8c <lwip_select+0x2ac>
      /* Still none ready, just wait to be woken */
      if (timeout == 0) {
   17b2c:	e0800217 	ldw	r2,8(fp)
   17b30:	1000021e 	bne	r2,zero,17b3c <lwip_select+0x25c>
        /* Wait forever */
        msectimeout = 0;
   17b34:	e03fea15 	stw	zero,-88(fp)
   17b38:	00000e06 	br	17b74 <lwip_select+0x294>
      } else {
        msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
   17b3c:	e0800217 	ldw	r2,8(fp)
   17b40:	10800017 	ldw	r2,0(r2)
   17b44:	10c0fa24 	muli	r3,r2,1000
   17b48:	e0800217 	ldw	r2,8(fp)
   17b4c:	10800117 	ldw	r2,4(r2)
   17b50:	11007d04 	addi	r4,r2,500
   17b54:	0080fa04 	movi	r2,1000
   17b58:	2085283a 	div	r2,r4,r2
   17b5c:	1885883a 	add	r2,r3,r2
   17b60:	e0bfea15 	stw	r2,-88(fp)
        if (msectimeout == 0) {
   17b64:	e0bfea17 	ldw	r2,-88(fp)
   17b68:	1000021e 	bne	r2,zero,17b74 <lwip_select+0x294>
          /* Wait 1ms at least (0 means wait forever) */
          msectimeout = 1;
   17b6c:	00800044 	movi	r2,1
   17b70:	e0bfea15 	stw	r2,-88(fp)
        }
      }

      waitres = sys_arch_sem_wait(&select_cb.sem, msectimeout);
   17b74:	e0bff504 	addi	r2,fp,-44
   17b78:	10800604 	addi	r2,r2,24
   17b7c:	1009883a 	mov	r4,r2
   17b80:	e17fea17 	ldw	r5,-88(fp)
   17b84:	001b3340 	call	1b334 <sys_arch_sem_wait>
   17b88:	e0bfe815 	stw	r2,-96(fp)
    }
    /* Increase select_waiting for each socket we are interested in */
    for(i = LWIP_SOCKET_OFFSET; i < maxfdp1; i++) {
   17b8c:	00800804 	movi	r2,32
   17b90:	e0bfeb15 	stw	r2,-84(fp)
   17b94:	00003b06 	br	17c84 <lwip_select+0x3a4>
      if ((readset && FD_ISSET(i, readset)) ||
   17b98:	e0bffd17 	ldw	r2,-12(fp)
   17b9c:	10000c26 	beq	r2,zero,17bd0 <lwip_select+0x2f0>
   17ba0:	e0bfeb17 	ldw	r2,-84(fp)
   17ba4:	1004d17a 	srli	r2,r2,5
   17ba8:	e0fffd17 	ldw	r3,-12(fp)
   17bac:	1085883a 	add	r2,r2,r2
   17bb0:	1085883a 	add	r2,r2,r2
   17bb4:	1885883a 	add	r2,r3,r2
   17bb8:	10c00017 	ldw	r3,0(r2)
   17bbc:	e0bfeb17 	ldw	r2,-84(fp)
   17bc0:	108007cc 	andi	r2,r2,31
   17bc4:	1885d83a 	sra	r2,r3,r2
   17bc8:	1080004c 	andi	r2,r2,1
   17bcc:	10001c1e 	bne	r2,zero,17c40 <lwip_select+0x360>
   17bd0:	e0bffe17 	ldw	r2,-8(fp)
   17bd4:	10000c26 	beq	r2,zero,17c08 <lwip_select+0x328>
          (writeset && FD_ISSET(i, writeset)) ||
   17bd8:	e0bfeb17 	ldw	r2,-84(fp)
   17bdc:	1004d17a 	srli	r2,r2,5
   17be0:	e0fffe17 	ldw	r3,-8(fp)
   17be4:	1085883a 	add	r2,r2,r2
   17be8:	1085883a 	add	r2,r2,r2
   17bec:	1885883a 	add	r2,r3,r2
   17bf0:	10c00017 	ldw	r3,0(r2)
   17bf4:	e0bfeb17 	ldw	r2,-84(fp)
   17bf8:	108007cc 	andi	r2,r2,31
   17bfc:	1885d83a 	sra	r2,r3,r2
   17c00:	1080004c 	andi	r2,r2,1
   17c04:	10000e1e 	bne	r2,zero,17c40 <lwip_select+0x360>
   17c08:	e0bfff17 	ldw	r2,-4(fp)
   17c0c:	10001a26 	beq	r2,zero,17c78 <lwip_select+0x398>
          (exceptset && FD_ISSET(i, exceptset))) {
   17c10:	e0bfeb17 	ldw	r2,-84(fp)
   17c14:	1004d17a 	srli	r2,r2,5
   17c18:	e0ffff17 	ldw	r3,-4(fp)
   17c1c:	1085883a 	add	r2,r2,r2
   17c20:	1085883a 	add	r2,r2,r2
   17c24:	1885883a 	add	r2,r3,r2
   17c28:	10c00017 	ldw	r3,0(r2)
   17c2c:	e0bfeb17 	ldw	r2,-84(fp)
   17c30:	108007cc 	andi	r2,r2,31
   17c34:	1885d83a 	sra	r2,r3,r2
   17c38:	1080004c 	andi	r2,r2,1
   17c3c:	10000e26 	beq	r2,zero,17c78 <lwip_select+0x398>
        struct lwip_sock *sock = tryget_socket(i);
   17c40:	e13feb17 	ldw	r4,-84(fp)
   17c44:	001610c0 	call	1610c <tryget_socket>
   17c48:	e0bfee15 	stw	r2,-72(fp)
        LWIP_ASSERT("sock != NULL", sock != NULL);
        SYS_ARCH_PROTECT(lev);
   17c4c:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   17c50:	10000126 	beq	r2,zero,17c58 <lwip_select+0x378>
   17c54:	00110d00 	call	110d0 <vTaskEnterCritical>
        sock->select_waiting--;
   17c58:	e0bfee17 	ldw	r2,-72(fp)
   17c5c:	10800517 	ldw	r2,20(r2)
   17c60:	10ffffc4 	addi	r3,r2,-1
   17c64:	e0bfee17 	ldw	r2,-72(fp)
   17c68:	10c00515 	stw	r3,20(r2)
        LWIP_ASSERT("sock->select_waiting >= 0", sock->select_waiting >= 0);
        SYS_ARCH_UNPROTECT(lev);
   17c6c:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   17c70:	10000126 	beq	r2,zero,17c78 <lwip_select+0x398>
   17c74:	00111100 	call	11110 <vTaskExitCritical>
      }

      waitres = sys_arch_sem_wait(&select_cb.sem, msectimeout);
    }
    /* Increase select_waiting for each socket we are interested in */
    for(i = LWIP_SOCKET_OFFSET; i < maxfdp1; i++) {
   17c78:	e0bfeb17 	ldw	r2,-84(fp)
   17c7c:	10800044 	addi	r2,r2,1
   17c80:	e0bfeb15 	stw	r2,-84(fp)
   17c84:	e0ffeb17 	ldw	r3,-84(fp)
   17c88:	e0bffc17 	ldw	r2,-16(fp)
   17c8c:	18bfc216 	blt	r3,r2,17b98 <lwip_select+0x2b8>
        LWIP_ASSERT("sock->select_waiting >= 0", sock->select_waiting >= 0);
        SYS_ARCH_UNPROTECT(lev);
      }
    }
    /* Take us off the list */
    SYS_ARCH_PROTECT(lev);
   17c90:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   17c94:	10000126 	beq	r2,zero,17c9c <lwip_select+0x3bc>
   17c98:	00110d00 	call	110d0 <vTaskEnterCritical>
    if (select_cb.next != NULL) {
   17c9c:	e0bff517 	ldw	r2,-44(fp)
   17ca0:	10000326 	beq	r2,zero,17cb0 <lwip_select+0x3d0>
      select_cb.next->prev = select_cb.prev;
   17ca4:	e0bff517 	ldw	r2,-44(fp)
   17ca8:	e0fff617 	ldw	r3,-40(fp)
   17cac:	10c00115 	stw	r3,4(r2)
    }
    if (select_cb_list == &select_cb) {
   17cb0:	d0e91a17 	ldw	r3,-23448(gp)
   17cb4:	e0bff504 	addi	r2,fp,-44
   17cb8:	1880031e 	bne	r3,r2,17cc8 <lwip_select+0x3e8>
      LWIP_ASSERT("select_cb.prev == NULL", select_cb.prev == NULL);
      select_cb_list = select_cb.next;
   17cbc:	e0bff517 	ldw	r2,-44(fp)
   17cc0:	d0a91a15 	stw	r2,-23448(gp)
   17cc4:	00000306 	br	17cd4 <lwip_select+0x3f4>
    } else {
      LWIP_ASSERT("select_cb.prev != NULL", select_cb.prev != NULL);
      select_cb.prev->next = select_cb.next;
   17cc8:	e0bff617 	ldw	r2,-40(fp)
   17ccc:	e0fff517 	ldw	r3,-44(fp)
   17cd0:	10c00015 	stw	r3,0(r2)
    }
    /* Increasing this counter tells even_callback that the list has changed. */
    select_cb_ctr++;
   17cd4:	d0a91b17 	ldw	r2,-23444(gp)
   17cd8:	10800044 	addi	r2,r2,1
   17cdc:	d0a91b15 	stw	r2,-23444(gp)
    SYS_ARCH_UNPROTECT(lev);
   17ce0:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   17ce4:	10000126 	beq	r2,zero,17cec <lwip_select+0x40c>
   17ce8:	00111100 	call	11110 <vTaskExitCritical>

    sys_sem_free(&select_cb.sem);
   17cec:	e0bff504 	addi	r2,fp,-44
   17cf0:	10800604 	addi	r2,r2,24
   17cf4:	1009883a 	mov	r4,r2
   17cf8:	001b29c0 	call	1b29c <sys_sem_free>
    if (waitres == SYS_ARCH_TIMEOUT)  {
   17cfc:	e0bfe817 	ldw	r2,-96(fp)
   17d00:	10bfffd8 	cmpnei	r2,r2,-1
   17d04:	10000f26 	beq	r2,zero,17d44 <lwip_select+0x464>
         or we would have returned earlier. */
      goto return_copy_fdsets;
    }

    /* See what's set */
    nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
   17d08:	e0bfef04 	addi	r2,fp,-68
   17d0c:	d8800015 	stw	r2,0(sp)
   17d10:	e0bff104 	addi	r2,fp,-60
   17d14:	d8800115 	stw	r2,4(sp)
   17d18:	e0bff304 	addi	r2,fp,-52
   17d1c:	d8800215 	stw	r2,8(sp)
   17d20:	e13ffc17 	ldw	r4,-16(fp)
   17d24:	e17ffd17 	ldw	r5,-12(fp)
   17d28:	e1bffe17 	ldw	r6,-8(fp)
   17d2c:	e1ffff17 	ldw	r7,-4(fp)
   17d30:	00175540 	call	17554 <lwip_selscan>
   17d34:	e0bfe915 	stw	r2,-92(fp)
   17d38:	00000306 	br	17d48 <lwip_select+0x468>
  if (!nready) {
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      /* This is OK as the local fdsets are empty and nready is zero,
         or we would have returned earlier. */
      goto return_copy_fdsets;
   17d3c:	0001883a 	nop
   17d40:	00000106 	br	17d48 <lwip_select+0x468>
    if (waitres == SYS_ARCH_TIMEOUT)  {
      /* Timeout */
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      /* This is OK as the local fdsets are empty and nready is zero,
         or we would have returned earlier. */
      goto return_copy_fdsets;
   17d44:	0001883a 	nop
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
return_copy_fdsets:
  set_errno(0);
  if (readset) {
   17d48:	e0bffd17 	ldw	r2,-12(fp)
   17d4c:	10000526 	beq	r2,zero,17d64 <lwip_select+0x484>
    *readset = lreadset;
   17d50:	e0bffd17 	ldw	r2,-12(fp)
   17d54:	e0ffef17 	ldw	r3,-68(fp)
   17d58:	10c00015 	stw	r3,0(r2)
   17d5c:	e0fff017 	ldw	r3,-64(fp)
   17d60:	10c00115 	stw	r3,4(r2)
  }
  if (writeset) {
   17d64:	e0bffe17 	ldw	r2,-8(fp)
   17d68:	10000526 	beq	r2,zero,17d80 <lwip_select+0x4a0>
    *writeset = lwriteset;
   17d6c:	e0bffe17 	ldw	r2,-8(fp)
   17d70:	e0fff117 	ldw	r3,-60(fp)
   17d74:	10c00015 	stw	r3,0(r2)
   17d78:	e0fff217 	ldw	r3,-56(fp)
   17d7c:	10c00115 	stw	r3,4(r2)
  }
  if (exceptset) {
   17d80:	e0bfff17 	ldw	r2,-4(fp)
   17d84:	10000526 	beq	r2,zero,17d9c <lwip_select+0x4bc>
    *exceptset = lexceptset;
   17d88:	e0bfff17 	ldw	r2,-4(fp)
   17d8c:	e0fff317 	ldw	r3,-52(fp)
   17d90:	10c00015 	stw	r3,0(r2)
   17d94:	e0fff417 	ldw	r3,-48(fp)
   17d98:	10c00115 	stw	r3,4(r2)
  }


  return nready;
   17d9c:	e0bfe917 	ldw	r2,-92(fp)
}
   17da0:	e037883a 	mov	sp,fp
   17da4:	dfc00117 	ldw	ra,4(sp)
   17da8:	df000017 	ldw	fp,0(sp)
   17dac:	dec00204 	addi	sp,sp,8
   17db0:	f800283a 	ret

00017db4 <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
   17db4:	defff604 	addi	sp,sp,-40
   17db8:	dfc00915 	stw	ra,36(sp)
   17dbc:	df000815 	stw	fp,32(sp)
   17dc0:	df000804 	addi	fp,sp,32
   17dc4:	e13ffd15 	stw	r4,-12(fp)
   17dc8:	e17ffe15 	stw	r5,-8(fp)
   17dcc:	3005883a 	mov	r2,r6
   17dd0:	e0bfff0d 	sth	r2,-4(fp)
  SYS_ARCH_DECL_PROTECT(lev);

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
   17dd4:	e0bffd17 	ldw	r2,-12(fp)
   17dd8:	1000d626 	beq	r2,zero,18134 <event_callback+0x380>
    s = conn->socket;
   17ddc:	e0bffd17 	ldw	r2,-12(fp)
   17de0:	10800717 	ldw	r2,28(r2)
   17de4:	e0bff815 	stw	r2,-32(fp)
    if (s < 0) {
   17de8:	e0bff817 	ldw	r2,-32(fp)
   17dec:	1000170e 	bge	r2,zero,17e4c <event_callback+0x98>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      SYS_ARCH_PROTECT(lev);
   17df0:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   17df4:	10000126 	beq	r2,zero,17dfc <event_callback+0x48>
   17df8:	00110d00 	call	110d0 <vTaskEnterCritical>
      if (conn->socket < 0) {
   17dfc:	e0bffd17 	ldw	r2,-12(fp)
   17e00:	10800717 	ldw	r2,28(r2)
   17e04:	10000b0e 	bge	r2,zero,17e34 <event_callback+0x80>
        if (evt == NETCONN_EVT_RCVPLUS) {
   17e08:	e0bffe17 	ldw	r2,-8(fp)
   17e0c:	1000051e 	bne	r2,zero,17e24 <event_callback+0x70>
          conn->socket--;
   17e10:	e0bffd17 	ldw	r2,-12(fp)
   17e14:	10800717 	ldw	r2,28(r2)
   17e18:	10ffffc4 	addi	r3,r2,-1
   17e1c:	e0bffd17 	ldw	r2,-12(fp)
   17e20:	10c00715 	stw	r3,28(r2)
        }
        SYS_ARCH_UNPROTECT(lev);
   17e24:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   17e28:	1000c426 	beq	r2,zero,1813c <event_callback+0x388>
   17e2c:	00111100 	call	11110 <vTaskExitCritical>
        return;
   17e30:	0000c206 	br	1813c <event_callback+0x388>
      }
      s = conn->socket;
   17e34:	e0bffd17 	ldw	r2,-12(fp)
   17e38:	10800717 	ldw	r2,28(r2)
   17e3c:	e0bff815 	stw	r2,-32(fp)
      SYS_ARCH_UNPROTECT(lev);
   17e40:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   17e44:	10000126 	beq	r2,zero,17e4c <event_callback+0x98>
   17e48:	00111100 	call	11110 <vTaskExitCritical>
    }

    sock = get_socket(s);
   17e4c:	e13ff817 	ldw	r4,-32(fp)
   17e50:	00160940 	call	16094 <get_socket>
   17e54:	e0bffb15 	stw	r2,-20(fp)
    if (!sock) {
   17e58:	e0bffb17 	ldw	r2,-20(fp)
   17e5c:	1000b926 	beq	r2,zero,18144 <event_callback+0x390>
    }
  } else {
    return;
  }

  SYS_ARCH_PROTECT(lev);
   17e60:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   17e64:	10000126 	beq	r2,zero,17e6c <event_callback+0xb8>
   17e68:	00110d00 	call	110d0 <vTaskEnterCritical>
  /* Set event as required */
  switch (evt) {
   17e6c:	e0bffe17 	ldw	r2,-8(fp)
   17e70:	10800168 	cmpgeui	r2,r2,5
   17e74:	1000261e 	bne	r2,zero,17f10 <event_callback+0x15c>
   17e78:	e0bffe17 	ldw	r2,-8(fp)
   17e7c:	1085883a 	add	r2,r2,r2
   17e80:	1087883a 	add	r3,r2,r2
   17e84:	00800074 	movhi	r2,1
   17e88:	109fa604 	addi	r2,r2,32408
   17e8c:	1885883a 	add	r2,r3,r2
   17e90:	10800017 	ldw	r2,0(r2)
   17e94:	1000683a 	jmp	r2
   17e98:	00017eac 	andhi	zero,zero,1530
   17e9c:	00017ec8 	cmpgei	zero,zero,1531
   17ea0:	00017ee4 	muli	zero,zero,1531
   17ea4:	00017ef4 	movhi	zero,1531
   17ea8:	00017f00 	call	17f0 <prvLowPriorityPeekTask+0x30>
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
   17eac:	e0bffb17 	ldw	r2,-20(fp)
   17eb0:	1080028b 	ldhu	r2,10(r2)
   17eb4:	10800044 	addi	r2,r2,1
   17eb8:	1007883a 	mov	r3,r2
   17ebc:	e0bffb17 	ldw	r2,-20(fp)
   17ec0:	10c0028d 	sth	r3,10(r2)
      break;
   17ec4:	00001306 	br	17f14 <event_callback+0x160>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
   17ec8:	e0bffb17 	ldw	r2,-20(fp)
   17ecc:	1080028b 	ldhu	r2,10(r2)
   17ed0:	10bfffc4 	addi	r2,r2,-1
   17ed4:	1007883a 	mov	r3,r2
   17ed8:	e0bffb17 	ldw	r2,-20(fp)
   17edc:	10c0028d 	sth	r3,10(r2)
      break;
   17ee0:	00000c06 	br	17f14 <event_callback+0x160>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
   17ee4:	e0bffb17 	ldw	r2,-20(fp)
   17ee8:	00c00044 	movi	r3,1
   17eec:	10c0030d 	sth	r3,12(r2)
      break;
   17ef0:	00000806 	br	17f14 <event_callback+0x160>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
   17ef4:	e0bffb17 	ldw	r2,-20(fp)
   17ef8:	1000030d 	sth	zero,12(r2)
      break;
   17efc:	00000506 	br	17f14 <event_callback+0x160>
    case NETCONN_EVT_ERROR:
      sock->errevent = 1;
   17f00:	e0bffb17 	ldw	r2,-20(fp)
   17f04:	00c00044 	movi	r3,1
   17f08:	10c0038d 	sth	r3,14(r2)
      break;
   17f0c:	00000106 	br	17f14 <event_callback+0x160>
    default:
      LWIP_ASSERT("unknown event", 0);
      break;
   17f10:	0001883a 	nop
  }

  if (sock->select_waiting == 0) {
   17f14:	e0bffb17 	ldw	r2,-20(fp)
   17f18:	10800517 	ldw	r2,20(r2)
   17f1c:	1000051e 	bne	r2,zero,17f34 <event_callback+0x180>
    /* noone is waiting for this socket, no need to check select_cb_list */
    SYS_ARCH_UNPROTECT(lev);
   17f20:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   17f24:	10008926 	beq	r2,zero,1814c <event_callback+0x398>
   17f28:	00111100 	call	11110 <vTaskExitCritical>
    return;
   17f2c:	00008706 	br	1814c <event_callback+0x398>
    SYS_ARCH_UNPROTECT(lev);
    /* this makes sure interrupt protection time is short */
    SYS_ARCH_PROTECT(lev);
    if (last_select_cb_ctr != select_cb_ctr) {
      /* someone has changed select_cb_list, restart at the beginning */
      goto again;
   17f30:	0001883a 	nop
     ONLY IF a select was actually waiting. We go through the list the number
     of waiting select calls + 1. This list is expected to be small. */

  /* At this point, SYS_ARCH is still protected! */
again:
  for (scb = select_cb_list; scb != NULL; scb = scb->next) {
   17f34:	d0a91a17 	ldw	r2,-23448(gp)
   17f38:	e0bff915 	stw	r2,-28(fp)
   17f3c:	00007706 	br	1811c <event_callback+0x368>
    if (scb->sem_signalled == 0) {
   17f40:	e0bff917 	ldw	r2,-28(fp)
   17f44:	10800517 	ldw	r2,20(r2)
   17f48:	1000521e 	bne	r2,zero,18094 <event_callback+0x2e0>
      /* semaphore not signalled yet */
      int do_signal = 0;
   17f4c:	e03ffa15 	stw	zero,-24(fp)
      /* Test this select call for our socket */
      if (sock->rcvevent > 0) {
   17f50:	e0bffb17 	ldw	r2,-20(fp)
   17f54:	1080028b 	ldhu	r2,10(r2)
   17f58:	10bfffcc 	andi	r2,r2,65535
   17f5c:	10a0001c 	xori	r2,r2,32768
   17f60:	10a00004 	addi	r2,r2,-32768
   17f64:	0080120e 	bge	zero,r2,17fb0 <event_callback+0x1fc>
        if (scb->readset && FD_ISSET(s, scb->readset)) {
   17f68:	e0bff917 	ldw	r2,-28(fp)
   17f6c:	10800217 	ldw	r2,8(r2)
   17f70:	10000f26 	beq	r2,zero,17fb0 <event_callback+0x1fc>
   17f74:	e0bff917 	ldw	r2,-28(fp)
   17f78:	10c00217 	ldw	r3,8(r2)
   17f7c:	e0bff817 	ldw	r2,-32(fp)
   17f80:	1004d17a 	srli	r2,r2,5
   17f84:	1085883a 	add	r2,r2,r2
   17f88:	1085883a 	add	r2,r2,r2
   17f8c:	1885883a 	add	r2,r3,r2
   17f90:	10c00017 	ldw	r3,0(r2)
   17f94:	e0bff817 	ldw	r2,-32(fp)
   17f98:	108007cc 	andi	r2,r2,31
   17f9c:	1885d83a 	sra	r2,r3,r2
   17fa0:	1080004c 	andi	r2,r2,1
   17fa4:	10000226 	beq	r2,zero,17fb0 <event_callback+0x1fc>
          do_signal = 1;
   17fa8:	00800044 	movi	r2,1
   17fac:	e0bffa15 	stw	r2,-24(fp)
        }
      }
      if (sock->sendevent != 0) {
   17fb0:	e0bffb17 	ldw	r2,-20(fp)
   17fb4:	1080030b 	ldhu	r2,12(r2)
   17fb8:	10bfffcc 	andi	r2,r2,65535
   17fbc:	10001426 	beq	r2,zero,18010 <event_callback+0x25c>
        if (!do_signal && scb->writeset && FD_ISSET(s, scb->writeset)) {
   17fc0:	e0bffa17 	ldw	r2,-24(fp)
   17fc4:	1000121e 	bne	r2,zero,18010 <event_callback+0x25c>
   17fc8:	e0bff917 	ldw	r2,-28(fp)
   17fcc:	10800317 	ldw	r2,12(r2)
   17fd0:	10000f26 	beq	r2,zero,18010 <event_callback+0x25c>
   17fd4:	e0bff917 	ldw	r2,-28(fp)
   17fd8:	10c00317 	ldw	r3,12(r2)
   17fdc:	e0bff817 	ldw	r2,-32(fp)
   17fe0:	1004d17a 	srli	r2,r2,5
   17fe4:	1085883a 	add	r2,r2,r2
   17fe8:	1085883a 	add	r2,r2,r2
   17fec:	1885883a 	add	r2,r3,r2
   17ff0:	10c00017 	ldw	r3,0(r2)
   17ff4:	e0bff817 	ldw	r2,-32(fp)
   17ff8:	108007cc 	andi	r2,r2,31
   17ffc:	1885d83a 	sra	r2,r3,r2
   18000:	1080004c 	andi	r2,r2,1
   18004:	10000226 	beq	r2,zero,18010 <event_callback+0x25c>
          do_signal = 1;
   18008:	00800044 	movi	r2,1
   1800c:	e0bffa15 	stw	r2,-24(fp)
        }
      }
      if (sock->errevent != 0) {
   18010:	e0bffb17 	ldw	r2,-20(fp)
   18014:	1080038b 	ldhu	r2,14(r2)
   18018:	10bfffcc 	andi	r2,r2,65535
   1801c:	10001426 	beq	r2,zero,18070 <event_callback+0x2bc>
        if (!do_signal && scb->exceptset && FD_ISSET(s, scb->exceptset)) {
   18020:	e0bffa17 	ldw	r2,-24(fp)
   18024:	1000121e 	bne	r2,zero,18070 <event_callback+0x2bc>
   18028:	e0bff917 	ldw	r2,-28(fp)
   1802c:	10800417 	ldw	r2,16(r2)
   18030:	10000f26 	beq	r2,zero,18070 <event_callback+0x2bc>
   18034:	e0bff917 	ldw	r2,-28(fp)
   18038:	10c00417 	ldw	r3,16(r2)
   1803c:	e0bff817 	ldw	r2,-32(fp)
   18040:	1004d17a 	srli	r2,r2,5
   18044:	1085883a 	add	r2,r2,r2
   18048:	1085883a 	add	r2,r2,r2
   1804c:	1885883a 	add	r2,r3,r2
   18050:	10c00017 	ldw	r3,0(r2)
   18054:	e0bff817 	ldw	r2,-32(fp)
   18058:	108007cc 	andi	r2,r2,31
   1805c:	1885d83a 	sra	r2,r3,r2
   18060:	1080004c 	andi	r2,r2,1
   18064:	10000226 	beq	r2,zero,18070 <event_callback+0x2bc>
          do_signal = 1;
   18068:	00800044 	movi	r2,1
   1806c:	e0bffa15 	stw	r2,-24(fp)
        }
      }
      if (do_signal) {
   18070:	e0bffa17 	ldw	r2,-24(fp)
   18074:	10000726 	beq	r2,zero,18094 <event_callback+0x2e0>
        scb->sem_signalled = 1;
   18078:	e0bff917 	ldw	r2,-28(fp)
   1807c:	00c00044 	movi	r3,1
   18080:	10c00515 	stw	r3,20(r2)
        /* Don't call SYS_ARCH_UNPROTECT() before signaling the semaphore, as this might
           lead to the select thread taking itself off the list, invalidagin the semaphore. */
        sys_sem_signal(&scb->sem);
   18084:	e0bff917 	ldw	r2,-28(fp)
   18088:	10800604 	addi	r2,r2,24
   1808c:	1009883a 	mov	r4,r2
   18090:	001b2f00 	call	1b2f0 <sys_sem_signal>
      }
    }

    if ((scb->next) && (scb->next < 0x00800000 || scb->next > 0x00ffffff))
   18094:	e0bff917 	ldw	r2,-28(fp)
   18098:	10800017 	ldw	r2,0(r2)
   1809c:	10000a26 	beq	r2,zero,180c8 <event_callback+0x314>
   180a0:	e0bff917 	ldw	r2,-28(fp)
   180a4:	10c00017 	ldw	r3,0(r2)
   180a8:	00802034 	movhi	r2,128
   180ac:	18800436 	bltu	r3,r2,180c0 <event_callback+0x30c>
   180b0:	e0bff917 	ldw	r2,-28(fp)
   180b4:	10c00017 	ldw	r3,0(r2)
   180b8:	00804034 	movhi	r2,256
   180bc:	18800236 	bltu	r3,r2,180c8 <event_callback+0x314>
    {
    	NIOS2_BREAK();
   180c0:	003da03a 	break	0
   180c4:	00000706 	br	180e4 <event_callback+0x330>
    }
    else if (scb < 0x00800000 || scb > 0x00ffffff)
   180c8:	e0fff917 	ldw	r3,-28(fp)
   180cc:	00802034 	movhi	r2,128
   180d0:	18800336 	bltu	r3,r2,180e0 <event_callback+0x32c>
   180d4:	e0fff917 	ldw	r3,-28(fp)
   180d8:	00804034 	movhi	r2,256
   180dc:	18800136 	bltu	r3,r2,180e4 <event_callback+0x330>
    {
    	NIOS2_BREAK();
   180e0:	003da03a 	break	0
    }

    /* unlock interrupts with each step */
    last_select_cb_ctr = select_cb_ctr;
   180e4:	d0a91b17 	ldw	r2,-23444(gp)
   180e8:	e0bffc15 	stw	r2,-16(fp)
    SYS_ARCH_UNPROTECT(lev);
   180ec:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   180f0:	10000126 	beq	r2,zero,180f8 <event_callback+0x344>
   180f4:	00111100 	call	11110 <vTaskExitCritical>
    /* this makes sure interrupt protection time is short */
    SYS_ARCH_PROTECT(lev);
   180f8:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   180fc:	10000126 	beq	r2,zero,18104 <event_callback+0x350>
   18100:	00110d00 	call	110d0 <vTaskEnterCritical>
    if (last_select_cb_ctr != select_cb_ctr) {
   18104:	d0a91b17 	ldw	r2,-23444(gp)
   18108:	e0fffc17 	ldw	r3,-16(fp)
   1810c:	18bf881e 	bne	r3,r2,17f30 <event_callback+0x17c>
     ONLY IF a select was actually waiting. We go through the list the number
     of waiting select calls + 1. This list is expected to be small. */

  /* At this point, SYS_ARCH is still protected! */
again:
  for (scb = select_cb_list; scb != NULL; scb = scb->next) {
   18110:	e0bff917 	ldw	r2,-28(fp)
   18114:	10800017 	ldw	r2,0(r2)
   18118:	e0bff915 	stw	r2,-28(fp)
   1811c:	e0bff917 	ldw	r2,-28(fp)
   18120:	103f871e 	bne	r2,zero,17f40 <event_callback+0x18c>
    if (last_select_cb_ctr != select_cb_ctr) {
      /* someone has changed select_cb_list, restart at the beginning */
      goto again;
    }
  }
  SYS_ARCH_UNPROTECT(lev);
   18124:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   18128:	10000926 	beq	r2,zero,18150 <event_callback+0x39c>
   1812c:	00111100 	call	11110 <vTaskExitCritical>
   18130:	00000706 	br	18150 <event_callback+0x39c>
    sock = get_socket(s);
    if (!sock) {
      return;
    }
  } else {
    return;
   18134:	0001883a 	nop
   18138:	00000506 	br	18150 <event_callback+0x39c>
      if (conn->socket < 0) {
        if (evt == NETCONN_EVT_RCVPLUS) {
          conn->socket--;
        }
        SYS_ARCH_UNPROTECT(lev);
        return;
   1813c:	0001883a 	nop
   18140:	00000306 	br	18150 <event_callback+0x39c>
      SYS_ARCH_UNPROTECT(lev);
    }

    sock = get_socket(s);
    if (!sock) {
      return;
   18144:	0001883a 	nop
   18148:	00000106 	br	18150 <event_callback+0x39c>
  }

  if (sock->select_waiting == 0) {
    /* noone is waiting for this socket, no need to check select_cb_list */
    SYS_ARCH_UNPROTECT(lev);
    return;
   1814c:	0001883a 	nop
      /* someone has changed select_cb_list, restart at the beginning */
      goto again;
    }
  }
  SYS_ARCH_UNPROTECT(lev);
}
   18150:	e037883a 	mov	sp,fp
   18154:	dfc00117 	ldw	ra,4(sp)
   18158:	df000017 	ldw	fp,0(sp)
   1815c:	dec00204 	addi	sp,sp,8
   18160:	f800283a 	ret

00018164 <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
   18164:	defff904 	addi	sp,sp,-28
   18168:	dfc00615 	stw	ra,24(sp)
   1816c:	df000515 	stw	fp,20(sp)
   18170:	df000504 	addi	fp,sp,20
   18174:	e13ffe15 	stw	r4,-8(fp)
   18178:	e17fff15 	stw	r5,-4(fp)
  struct lwip_sock *sock;
  err_t err;
  u8_t shut_rx = 0, shut_tx = 0;
   1817c:	e03ffb05 	stb	zero,-20(fp)
   18180:	e03ffb45 	stb	zero,-19(fp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));

  sock = get_socket(s);
   18184:	e13ffe17 	ldw	r4,-8(fp)
   18188:	00160940 	call	16094 <get_socket>
   1818c:	e0bffc15 	stw	r2,-16(fp)
  if (!sock) {
   18190:	e0bffc17 	ldw	r2,-16(fp)
   18194:	1000021e 	bne	r2,zero,181a0 <lwip_shutdown+0x3c>
    return -1;
   18198:	00bfffc4 	movi	r2,-1
   1819c:	00004706 	br	182bc <lwip_shutdown+0x158>
  }

  if (sock->conn != NULL) {
   181a0:	e0bffc17 	ldw	r2,-16(fp)
   181a4:	10800017 	ldw	r2,0(r2)
   181a8:	10000a26 	beq	r2,zero,181d4 <lwip_shutdown+0x70>
    if (netconn_type(sock->conn) != NETCONN_TCP) {
   181ac:	e0bffc17 	ldw	r2,-16(fp)
   181b0:	10800017 	ldw	r2,0(r2)
   181b4:	10800017 	ldw	r2,0(r2)
   181b8:	10800420 	cmpeqi	r2,r2,16
   181bc:	10000a1e 	bne	r2,zero,181e8 <lwip_shutdown+0x84>
      sock_set_errno(sock, EOPNOTSUPP);
   181c0:	e0bffc17 	ldw	r2,-16(fp)
   181c4:	00c017c4 	movi	r3,95
   181c8:	10c00415 	stw	r3,16(r2)
      return EOPNOTSUPP;
   181cc:	008017c4 	movi	r2,95
   181d0:	00003a06 	br	182bc <lwip_shutdown+0x158>
    }
  } else {
    sock_set_errno(sock, ENOTCONN);
   181d4:	e0bffc17 	ldw	r2,-16(fp)
   181d8:	00c02004 	movi	r3,128
   181dc:	10c00415 	stw	r3,16(r2)
    return ENOTCONN;
   181e0:	00802004 	movi	r2,128
   181e4:	00003506 	br	182bc <lwip_shutdown+0x158>
  }

  if (how == SHUT_RD) {
   181e8:	e0bfff17 	ldw	r2,-4(fp)
   181ec:	1000031e 	bne	r2,zero,181fc <lwip_shutdown+0x98>
    shut_rx = 1;
   181f0:	00800044 	movi	r2,1
   181f4:	e0bffb05 	stb	r2,-20(fp)
   181f8:	00001306 	br	18248 <lwip_shutdown+0xe4>
  } else if (how == SHUT_WR) {
   181fc:	e0bfff17 	ldw	r2,-4(fp)
   18200:	10800058 	cmpnei	r2,r2,1
   18204:	1000031e 	bne	r2,zero,18214 <lwip_shutdown+0xb0>
    shut_tx = 1;
   18208:	00800044 	movi	r2,1
   1820c:	e0bffb45 	stb	r2,-19(fp)
   18210:	00000d06 	br	18248 <lwip_shutdown+0xe4>
  } else if(how == SHUT_RDWR) {
   18214:	e0bfff17 	ldw	r2,-4(fp)
   18218:	10800098 	cmpnei	r2,r2,2
   1821c:	1000051e 	bne	r2,zero,18234 <lwip_shutdown+0xd0>
    shut_rx = 1;
   18220:	00800044 	movi	r2,1
   18224:	e0bffb05 	stb	r2,-20(fp)
    shut_tx = 1;
   18228:	00800044 	movi	r2,1
   1822c:	e0bffb45 	stb	r2,-19(fp)
   18230:	00000506 	br	18248 <lwip_shutdown+0xe4>
  } else {
    sock_set_errno(sock, EINVAL);
   18234:	e0bffc17 	ldw	r2,-16(fp)
   18238:	00c00584 	movi	r3,22
   1823c:	10c00415 	stw	r3,16(r2)
    return EINVAL;
   18240:	00800584 	movi	r2,22
   18244:	00001d06 	br	182bc <lwip_shutdown+0x158>
  }
  err = netconn_shutdown(sock->conn, shut_rx, shut_tx);
   18248:	e0bffc17 	ldw	r2,-16(fp)
   1824c:	11000017 	ldw	r4,0(r2)
   18250:	e0fffb03 	ldbu	r3,-20(fp)
   18254:	e0bffb43 	ldbu	r2,-19(fp)
   18258:	180b883a 	mov	r5,r3
   1825c:	100d883a 	mov	r6,r2
   18260:	00135c80 	call	135c8 <netconn_shutdown>
   18264:	e0bffd05 	stb	r2,-12(fp)

  sock_set_errno(sock, err_to_errno(err));
   18268:	e0bffd07 	ldb	r2,-12(fp)
   1826c:	0085c83a 	sub	r2,zero,r2
   18270:	10800428 	cmpgeui	r2,r2,16
   18274:	1000091e 	bne	r2,zero,1829c <lwip_shutdown+0x138>
   18278:	e0bffd07 	ldb	r2,-12(fp)
   1827c:	0085c83a 	sub	r2,zero,r2
   18280:	00c00134 	movhi	r3,4
   18284:	18c37404 	addi	r3,r3,3536
   18288:	1085883a 	add	r2,r2,r2
   1828c:	1085883a 	add	r2,r2,r2
   18290:	1885883a 	add	r2,r3,r2
   18294:	10800017 	ldw	r2,0(r2)
   18298:	00000106 	br	182a0 <lwip_shutdown+0x13c>
   1829c:	00800144 	movi	r2,5
   182a0:	e0fffc17 	ldw	r3,-16(fp)
   182a4:	18800415 	stw	r2,16(r3)
  return (err == ERR_OK ? 0 : -1);
   182a8:	e0bffd07 	ldb	r2,-12(fp)
   182ac:	1000021e 	bne	r2,zero,182b8 <lwip_shutdown+0x154>
   182b0:	0005883a 	mov	r2,zero
   182b4:	00000106 	br	182bc <lwip_shutdown+0x158>
   182b8:	00bfffc4 	movi	r2,-1
}
   182bc:	e037883a 	mov	sp,fp
   182c0:	dfc00117 	ldw	ra,4(sp)
   182c4:	df000017 	ldw	fp,0(sp)
   182c8:	dec00204 	addi	sp,sp,8
   182cc:	f800283a 	ret

000182d0 <lwip_getaddrname>:

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
   182d0:	defff404 	addi	sp,sp,-48
   182d4:	dfc00b15 	stw	ra,44(sp)
   182d8:	df000a15 	stw	fp,40(sp)
   182dc:	df000a04 	addi	fp,sp,40
   182e0:	e13ffc15 	stw	r4,-16(fp)
   182e4:	e17ffd15 	stw	r5,-12(fp)
   182e8:	e1bffe15 	stw	r6,-8(fp)
   182ec:	3805883a 	mov	r2,r7
   182f0:	e0bfff05 	stb	r2,-4(fp)
  struct lwip_sock *sock;
  struct sockaddr_in sin;
  ip_addr_t naddr;

  sock = get_socket(s);
   182f4:	e13ffc17 	ldw	r4,-16(fp)
   182f8:	00160940 	call	16094 <get_socket>
   182fc:	e0bff615 	stw	r2,-40(fp)
  if (!sock) {
   18300:	e0bff617 	ldw	r2,-40(fp)
   18304:	1000021e 	bne	r2,zero,18310 <lwip_getaddrname+0x40>
    return -1;
   18308:	00bfffc4 	movi	r2,-1
   1830c:	00002e06 	br	183c8 <lwip_getaddrname+0xf8>
  }

  memset(&sin, 0, sizeof(sin));
   18310:	e0bff704 	addi	r2,fp,-36
   18314:	1009883a 	mov	r4,r2
   18318:	000b883a 	mov	r5,zero
   1831c:	01800404 	movi	r6,16
   18320:	00042e80 	call	42e8 <memset>
  sin.sin_len = sizeof(sin);
   18324:	00800404 	movi	r2,16
   18328:	e0bff705 	stb	r2,-36(fp)
  sin.sin_family = AF_INET;
   1832c:	00800084 	movi	r2,2
   18330:	e0bff745 	stb	r2,-35(fp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
   18334:	e0bff617 	ldw	r2,-40(fp)
   18338:	11000017 	ldw	r4,0(r2)
   1833c:	e0bfff03 	ldbu	r2,-4(fp)
   18340:	e17ffb04 	addi	r5,fp,-20
   18344:	e0fff704 	addi	r3,fp,-36
   18348:	18c00084 	addi	r3,r3,2
   1834c:	180d883a 	mov	r6,r3
   18350:	100f883a 	mov	r7,r2
   18354:	00126540 	call	12654 <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
   18358:	e0bff78b 	ldhu	r2,-34(fp)
   1835c:	10bfffcc 	andi	r2,r2,65535
   18360:	1004d23a 	srli	r2,r2,8
   18364:	1007883a 	mov	r3,r2
   18368:	e0bff78b 	ldhu	r2,-34(fp)
   1836c:	10bfffcc 	andi	r2,r2,65535
   18370:	1004923a 	slli	r2,r2,8
   18374:	1884b03a 	or	r2,r3,r2
   18378:	e0bff78d 	sth	r2,-34(fp)
  inet_addr_from_ipaddr(&sin.sin_addr, &naddr);
   1837c:	e0bffb17 	ldw	r2,-20(fp)
   18380:	e0bff815 	stw	r2,-32(fp)

  if (*namelen > sizeof(sin)) {
   18384:	e0bffe17 	ldw	r2,-8(fp)
   18388:	10800017 	ldw	r2,0(r2)
   1838c:	10800470 	cmpltui	r2,r2,17
   18390:	1000031e 	bne	r2,zero,183a0 <lwip_getaddrname+0xd0>
    *namelen = sizeof(sin);
   18394:	e0bffe17 	ldw	r2,-8(fp)
   18398:	00c00404 	movi	r3,16
   1839c:	10c00015 	stw	r3,0(r2)
  }

  MEMCPY(name, &sin, *namelen);
   183a0:	e0bffe17 	ldw	r2,-8(fp)
   183a4:	10800017 	ldw	r2,0(r2)
   183a8:	e0fff704 	addi	r3,fp,-36
   183ac:	e13ffd17 	ldw	r4,-12(fp)
   183b0:	180b883a 	mov	r5,r3
   183b4:	100d883a 	mov	r6,r2
   183b8:	00041f00 	call	41f0 <memcpy>
  sock_set_errno(sock, 0);
   183bc:	e0bff617 	ldw	r2,-40(fp)
   183c0:	10000415 	stw	zero,16(r2)
  return 0;
   183c4:	0005883a 	mov	r2,zero
}
   183c8:	e037883a 	mov	sp,fp
   183cc:	dfc00117 	ldw	ra,4(sp)
   183d0:	df000017 	ldw	fp,0(sp)
   183d4:	dec00204 	addi	sp,sp,8
   183d8:	f800283a 	ret

000183dc <lwip_getpeername>:

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
   183dc:	defffb04 	addi	sp,sp,-20
   183e0:	dfc00415 	stw	ra,16(sp)
   183e4:	df000315 	stw	fp,12(sp)
   183e8:	df000304 	addi	fp,sp,12
   183ec:	e13ffd15 	stw	r4,-12(fp)
   183f0:	e17ffe15 	stw	r5,-8(fp)
   183f4:	e1bfff15 	stw	r6,-4(fp)
  return lwip_getaddrname(s, name, namelen, 0);
   183f8:	e13ffd17 	ldw	r4,-12(fp)
   183fc:	e17ffe17 	ldw	r5,-8(fp)
   18400:	e1bfff17 	ldw	r6,-4(fp)
   18404:	000f883a 	mov	r7,zero
   18408:	00182d00 	call	182d0 <lwip_getaddrname>
}
   1840c:	e037883a 	mov	sp,fp
   18410:	dfc00117 	ldw	ra,4(sp)
   18414:	df000017 	ldw	fp,0(sp)
   18418:	dec00204 	addi	sp,sp,8
   1841c:	f800283a 	ret

00018420 <lwip_getsockname>:

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
   18420:	defffb04 	addi	sp,sp,-20
   18424:	dfc00415 	stw	ra,16(sp)
   18428:	df000315 	stw	fp,12(sp)
   1842c:	df000304 	addi	fp,sp,12
   18430:	e13ffd15 	stw	r4,-12(fp)
   18434:	e17ffe15 	stw	r5,-8(fp)
   18438:	e1bfff15 	stw	r6,-4(fp)
  return lwip_getaddrname(s, name, namelen, 1);
   1843c:	e13ffd17 	ldw	r4,-12(fp)
   18440:	e17ffe17 	ldw	r5,-8(fp)
   18444:	e1bfff17 	ldw	r6,-4(fp)
   18448:	01c00044 	movi	r7,1
   1844c:	00182d00 	call	182d0 <lwip_getaddrname>
}
   18450:	e037883a 	mov	sp,fp
   18454:	dfc00117 	ldw	ra,4(sp)
   18458:	df000017 	ldw	fp,0(sp)
   1845c:	dec00204 	addi	sp,sp,8
   18460:	f800283a 	ret

00018464 <lwip_getsockopt>:

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
   18464:	defff204 	addi	sp,sp,-56
   18468:	dfc00d15 	stw	ra,52(sp)
   1846c:	df000c15 	stw	fp,48(sp)
   18470:	df000c04 	addi	fp,sp,48
   18474:	e13ffc15 	stw	r4,-16(fp)
   18478:	e17ffd15 	stw	r5,-12(fp)
   1847c:	e1bffe15 	stw	r6,-8(fp)
   18480:	e1ffff15 	stw	r7,-4(fp)
  err_t err = ERR_OK;
   18484:	e03ff405 	stb	zero,-48(fp)
  struct lwip_sock *sock = get_socket(s);
   18488:	e13ffc17 	ldw	r4,-16(fp)
   1848c:	00160940 	call	16094 <get_socket>
   18490:	e0bff515 	stw	r2,-44(fp)
  struct lwip_setgetsockopt_data data;

  if (!sock) {
   18494:	e0bff517 	ldw	r2,-44(fp)
   18498:	1000021e 	bne	r2,zero,184a4 <lwip_getsockopt+0x40>
    return -1;
   1849c:	00bfffc4 	movi	r2,-1
   184a0:	00009b06 	br	18710 <lwip_getsockopt+0x2ac>
  }

  if ((NULL == optval) || (NULL == optlen)) {
   184a4:	e0bfff17 	ldw	r2,-4(fp)
   184a8:	10000226 	beq	r2,zero,184b4 <lwip_getsockopt+0x50>
   184ac:	e0800217 	ldw	r2,8(fp)
   184b0:	1000051e 	bne	r2,zero,184c8 <lwip_getsockopt+0x64>
    sock_set_errno(sock, EFAULT);
   184b4:	e0bff517 	ldw	r2,-44(fp)
   184b8:	00c00384 	movi	r3,14
   184bc:	10c00415 	stw	r3,16(r2)
    return -1;
   184c0:	00bfffc4 	movi	r2,-1
   184c4:	00009206 	br	18710 <lwip_getsockopt+0x2ac>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
   184c8:	e0bffd17 	ldw	r2,-12(fp)
   184cc:	10c001a0 	cmpeqi	r3,r2,6
   184d0:	18004d1e 	bne	r3,zero,18608 <lwip_getsockopt+0x1a4>
   184d4:	10c3ffe0 	cmpeqi	r3,r2,4095
   184d8:	1800021e 	bne	r3,zero,184e4 <lwip_getsockopt+0x80>
   184dc:	10003a26 	beq	r2,zero,185c8 <lwip_getsockopt+0x164>
   184e0:	00006006 	br	18664 <lwip_getsockopt+0x200>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
   184e4:	e0bffe17 	ldw	r2,-8(fp)
   184e8:	10c00820 	cmpeqi	r3,r2,32
   184ec:	1800131e 	bne	r3,zero,1853c <lwip_getsockopt+0xd8>
   184f0:	10c00848 	cmpgei	r3,r2,33
   184f4:	1800071e 	bne	r3,zero,18514 <lwip_getsockopt+0xb0>
   184f8:	10c00120 	cmpeqi	r3,r2,4
   184fc:	18000f1e 	bne	r3,zero,1853c <lwip_getsockopt+0xd8>
   18500:	10c00220 	cmpeqi	r3,r2,8
   18504:	18000d1e 	bne	r3,zero,1853c <lwip_getsockopt+0xd8>
   18508:	108000a0 	cmpeqi	r2,r2,2
   1850c:	10000b1e 	bne	r2,zero,1853c <lwip_getsockopt+0xd8>
   18510:	00002606 	br	185ac <lwip_getsockopt+0x148>
   18514:	10c40248 	cmpgei	r3,r2,4105
   18518:	1800051e 	bne	r3,zero,18530 <lwip_getsockopt+0xcc>
   1851c:	10c40188 	cmpgei	r3,r2,4102
   18520:	1800061e 	bne	r3,zero,1853c <lwip_getsockopt+0xd8>
   18524:	10808020 	cmpeqi	r2,r2,512
   18528:	1000041e 	bne	r2,zero,1853c <lwip_getsockopt+0xd8>
   1852c:	00001f06 	br	185ac <lwip_getsockopt+0x148>
   18530:	108402a0 	cmpeqi	r2,r2,4106
   18534:	1000081e 	bne	r2,zero,18558 <lwip_getsockopt+0xf4>
   18538:	00001c06 	br	185ac <lwip_getsockopt+0x148>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
   1853c:	e0800217 	ldw	r2,8(fp)
   18540:	10800017 	ldw	r2,0(r2)
   18544:	10800128 	cmpgeui	r2,r2,4
   18548:	10001b1e 	bne	r2,zero,185b8 <lwip_getsockopt+0x154>
        err = EINVAL;
   1854c:	00800584 	movi	r2,22
   18550:	e0bff405 	stb	r2,-48(fp)
      }
      break;
   18554:	00001806 	br	185b8 <lwip_getsockopt+0x154>

    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
   18558:	e0800217 	ldw	r2,8(fp)
   1855c:	10800017 	ldw	r2,0(r2)
   18560:	10800128 	cmpgeui	r2,r2,4
   18564:	1000021e 	bne	r2,zero,18570 <lwip_getsockopt+0x10c>
        err = EINVAL;
   18568:	00800584 	movi	r2,22
   1856c:	e0bff405 	stb	r2,-48(fp)
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
   18570:	e0bff517 	ldw	r2,-44(fp)
   18574:	10800017 	ldw	r2,0(r2)
   18578:	10800017 	ldw	r2,0(r2)
   1857c:	10800818 	cmpnei	r2,r2,32
   18580:	1000071e 	bne	r2,zero,185a0 <lwip_getsockopt+0x13c>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
   18584:	e0bff517 	ldw	r2,-44(fp)
   18588:	10800017 	ldw	r2,0(r2)
   1858c:	10800217 	ldw	r2,8(r2)
   18590:	10800403 	ldbu	r2,16(r2)
   18594:	10803fcc 	andi	r2,r2,255
   18598:	1080008c 	andi	r2,r2,2
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
   1859c:	10000826 	beq	r2,zero,185c0 <lwip_getsockopt+0x15c>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
   185a0:	00801a84 	movi	r2,106
   185a4:	e0bff405 	stb	r2,-48(fp)
      }
#endif /* LWIP_UDP */
      break;
   185a8:	00000506 	br	185c0 <lwip_getsockopt+0x15c>

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
   185ac:	00801b44 	movi	r2,109
   185b0:	e0bff405 	stb	r2,-48(fp)
    }  /* switch (optname) */
    break;
   185b4:	00002d06 	br	1866c <lwip_getsockopt+0x208>
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
      break;
   185b8:	0001883a 	nop
   185bc:	00000106 	br	185c4 <lwip_getsockopt+0x160>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
      }
#endif /* LWIP_UDP */
      break;
   185c0:	0001883a 	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
   185c4:	00002906 	br	1866c <lwip_getsockopt+0x208>
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
   185c8:	e0bffe17 	ldw	r2,-8(fp)
   185cc:	10bfffc4 	addi	r2,r2,-1
   185d0:	108000a8 	cmpgeui	r2,r2,2
   185d4:	1000071e 	bne	r2,zero,185f4 <lwip_getsockopt+0x190>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
   185d8:	e0800217 	ldw	r2,8(fp)
   185dc:	10800017 	ldw	r2,0(r2)
   185e0:	10800128 	cmpgeui	r2,r2,4
   185e4:	1000061e 	bne	r2,zero,18600 <lwip_getsockopt+0x19c>
        err = EINVAL;
   185e8:	00800584 	movi	r2,22
   185ec:	e0bff405 	stb	r2,-48(fp)
      }
      break;
   185f0:	00000306 	br	18600 <lwip_getsockopt+0x19c>
#endif /* LWIP_IGMP */

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
   185f4:	00801b44 	movi	r2,109
   185f8:	e0bff405 	stb	r2,-48(fp)
    }  /* switch (optname) */
    break;
   185fc:	00001b06 	br	1866c <lwip_getsockopt+0x208>
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
      break;
   18600:	0001883a 	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
   18604:	00001906 	br	1866c <lwip_getsockopt+0x208>
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
   18608:	e0800217 	ldw	r2,8(fp)
   1860c:	10800017 	ldw	r2,0(r2)
   18610:	10800128 	cmpgeui	r2,r2,4
   18614:	1000031e 	bne	r2,zero,18624 <lwip_getsockopt+0x1c0>
      err = EINVAL;
   18618:	00800584 	movi	r2,22
   1861c:	e0bff405 	stb	r2,-48(fp)
      break;
   18620:	00001206 	br	1866c <lwip_getsockopt+0x208>
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
   18624:	e0bff517 	ldw	r2,-44(fp)
   18628:	10800017 	ldw	r2,0(r2)
   1862c:	10800017 	ldw	r2,0(r2)
   18630:	10800420 	cmpeqi	r2,r2,16
   18634:	1000021e 	bne	r2,zero,18640 <lwip_getsockopt+0x1dc>
      return 0;
   18638:	0005883a 	mov	r2,zero
   1863c:	00003406 	br	18710 <lwip_getsockopt+0x2ac>

    switch (optname) {
   18640:	e0bffe17 	ldw	r2,-8(fp)
   18644:	10bfffc4 	addi	r2,r2,-1
   18648:	10800168 	cmpgeui	r2,r2,5
   1864c:	1000021e 	bne	r2,zero,18658 <lwip_getsockopt+0x1f4>
#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
    case TCP_KEEPINTVL:
    case TCP_KEEPCNT:
#endif /* LWIP_TCP_KEEPALIVE */
      break;
   18650:	0001883a 	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
   18654:	00000506 	br	1866c <lwip_getsockopt+0x208>
      break;
       
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
   18658:	00801b44 	movi	r2,109
   1865c:	e0bff405 	stb	r2,-48(fp)
    }  /* switch (optname) */
    break;
   18660:	00000206 	br	1866c <lwip_getsockopt+0x208>
#endif /* LWIP_UDP && LWIP_UDPLITE*/
/* UNDEFINED LEVEL */
  default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                                  s, level, optname));
      err = ENOPROTOOPT;
   18664:	00801b44 	movi	r2,109
   18668:	e0bff405 	stb	r2,-48(fp)
  }  /* switch */

   
  if (err != ERR_OK) {
   1866c:	e0bff407 	ldb	r2,-48(fp)
   18670:	10000526 	beq	r2,zero,18688 <lwip_getsockopt+0x224>
    sock_set_errno(sock, err);
   18674:	e0fff407 	ldb	r3,-48(fp)
   18678:	e0bff517 	ldw	r2,-44(fp)
   1867c:	10c00415 	stw	r3,16(r2)
    return -1;
   18680:	00bfffc4 	movi	r2,-1
   18684:	00002206 	br	18710 <lwip_getsockopt+0x2ac>
  }

  /* Now do the actual option processing */
  data.sock = sock;
   18688:	e0bff517 	ldw	r2,-44(fp)
   1868c:	e0bff615 	stw	r2,-40(fp)
#ifdef LWIP_DEBUG
  data.s = s;
#endif /* LWIP_DEBUG */
  data.level = level;
   18690:	e0bffd17 	ldw	r2,-12(fp)
   18694:	e0bff715 	stw	r2,-36(fp)
  data.optname = optname;
   18698:	e0bffe17 	ldw	r2,-8(fp)
   1869c:	e0bff815 	stw	r2,-32(fp)
  data.optval = optval;
   186a0:	e0bfff17 	ldw	r2,-4(fp)
   186a4:	e0bff915 	stw	r2,-28(fp)
  data.optlen = optlen;
   186a8:	e0800217 	ldw	r2,8(fp)
   186ac:	e0bffa15 	stw	r2,-24(fp)
  data.err = err;
   186b0:	e0bff403 	ldbu	r2,-48(fp)
   186b4:	e0bffb05 	stb	r2,-20(fp)
  tcpip_callback(lwip_getsockopt_internal, &data);
   186b8:	e0bff604 	addi	r2,fp,-40
   186bc:	010000b4 	movhi	r4,2
   186c0:	2121c904 	addi	r4,r4,-30940
   186c4:	100b883a 	mov	r5,r2
   186c8:	01800044 	movi	r6,1
   186cc:	001954c0 	call	1954c <tcpip_callback_with_block>
  sys_arch_sem_wait(&sock->conn->op_completed, 0);
   186d0:	e0bff517 	ldw	r2,-44(fp)
   186d4:	10800017 	ldw	r2,0(r2)
   186d8:	10800404 	addi	r2,r2,16
   186dc:	1009883a 	mov	r4,r2
   186e0:	000b883a 	mov	r5,zero
   186e4:	001b3340 	call	1b334 <sys_arch_sem_wait>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
   186e8:	e0bffb03 	ldbu	r2,-20(fp)
   186ec:	e0bff405 	stb	r2,-48(fp)

  sock_set_errno(sock, err);
   186f0:	e0fff407 	ldb	r3,-48(fp)
   186f4:	e0bff517 	ldw	r2,-44(fp)
   186f8:	10c00415 	stw	r3,16(r2)
  return err ? -1 : 0;
   186fc:	e0bff407 	ldb	r2,-48(fp)
   18700:	10000226 	beq	r2,zero,1870c <lwip_getsockopt+0x2a8>
   18704:	00bfffc4 	movi	r2,-1
   18708:	00000106 	br	18710 <lwip_getsockopt+0x2ac>
   1870c:	0005883a 	mov	r2,zero
}
   18710:	e037883a 	mov	sp,fp
   18714:	dfc00117 	ldw	ra,4(sp)
   18718:	df000017 	ldw	fp,0(sp)
   1871c:	dec00204 	addi	sp,sp,8
   18720:	f800283a 	ret

00018724 <lwip_getsockopt_internal>:

static void
lwip_getsockopt_internal(void *arg)
{
   18724:	defff804 	addi	sp,sp,-32
   18728:	dfc00715 	stw	ra,28(sp)
   1872c:	df000615 	stw	fp,24(sp)
   18730:	df000604 	addi	fp,sp,24
   18734:	e13fff15 	stw	r4,-4(fp)
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);

  data = (struct lwip_setgetsockopt_data*)arg;
   18738:	e0bfff17 	ldw	r2,-4(fp)
   1873c:	e0bffa15 	stw	r2,-24(fp)
  sock = data->sock;
   18740:	e0bffa17 	ldw	r2,-24(fp)
   18744:	10800017 	ldw	r2,0(r2)
   18748:	e0bffb15 	stw	r2,-20(fp)
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
   1874c:	e0bffa17 	ldw	r2,-24(fp)
   18750:	10800117 	ldw	r2,4(r2)
   18754:	e0bffc15 	stw	r2,-16(fp)
  optname = data->optname;
   18758:	e0bffa17 	ldw	r2,-24(fp)
   1875c:	10800217 	ldw	r2,8(r2)
   18760:	e0bffd15 	stw	r2,-12(fp)
  optval = data->optval;
   18764:	e0bffa17 	ldw	r2,-24(fp)
   18768:	10800317 	ldw	r2,12(r2)
   1876c:	e0bffe15 	stw	r2,-8(fp)

  switch (level) {
   18770:	e0bffc17 	ldw	r2,-16(fp)
   18774:	10c001a0 	cmpeqi	r3,r2,6
   18778:	18009c1e 	bne	r3,zero,189ec <lwip_getsockopt_internal+0x2c8>
   1877c:	10c3ffe0 	cmpeqi	r3,r2,4095
   18780:	1800021e 	bne	r3,zero,1878c <lwip_getsockopt_internal+0x68>
   18784:	10008226 	beq	r2,zero,18990 <lwip_getsockopt_internal+0x26c>
   18788:	0000da06 	br	18af4 <lwip_getsockopt_internal+0x3d0>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
   1878c:	e0bffd17 	ldw	r2,-12(fp)
   18790:	10c08020 	cmpeqi	r3,r2,512
   18794:	18001a1e 	bne	r3,zero,18800 <lwip_getsockopt_internal+0xdc>
   18798:	10c08048 	cmpgei	r3,r2,513
   1879c:	18000c1e 	bne	r3,zero,187d0 <lwip_getsockopt_internal+0xac>
   187a0:	10c00120 	cmpeqi	r3,r2,4
   187a4:	1800161e 	bne	r3,zero,18800 <lwip_getsockopt_internal+0xdc>
   187a8:	10c00148 	cmpgei	r3,r2,5
   187ac:	1800031e 	bne	r3,zero,187bc <lwip_getsockopt_internal+0x98>
   187b0:	108000a0 	cmpeqi	r2,r2,2
   187b4:	1000121e 	bne	r2,zero,18800 <lwip_getsockopt_internal+0xdc>
   187b8:	00007306 	br	18988 <lwip_getsockopt_internal+0x264>
   187bc:	10c00220 	cmpeqi	r3,r2,8
   187c0:	18000f1e 	bne	r3,zero,18800 <lwip_getsockopt_internal+0xdc>
   187c4:	10800820 	cmpeqi	r2,r2,32
   187c8:	10000d1e 	bne	r2,zero,18800 <lwip_getsockopt_internal+0xdc>
   187cc:	00006e06 	br	18988 <lwip_getsockopt_internal+0x264>
   187d0:	10c401e0 	cmpeqi	r3,r2,4103
   187d4:	1800331e 	bne	r3,zero,188a4 <lwip_getsockopt_internal+0x180>
   187d8:	10c40208 	cmpgei	r3,r2,4104
   187dc:	1800031e 	bne	r3,zero,187ec <lwip_getsockopt_internal+0xc8>
   187e0:	108401a0 	cmpeqi	r2,r2,4102
   187e4:	1000571e 	bne	r2,zero,18944 <lwip_getsockopt_internal+0x220>
   187e8:	00006706 	br	18988 <lwip_getsockopt_internal+0x264>
   187ec:	10c40220 	cmpeqi	r3,r2,4104
   187f0:	18000d1e 	bne	r3,zero,18828 <lwip_getsockopt_internal+0x104>
   187f4:	108402a0 	cmpeqi	r2,r2,4106
   187f8:	1000581e 	bne	r2,zero,1895c <lwip_getsockopt_internal+0x238>
   187fc:	00006206 	br	18988 <lwip_getsockopt_internal+0x264>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = ip_get_option(sock->conn->pcb.ip, optname);
   18800:	e0bffb17 	ldw	r2,-20(fp)
   18804:	10800017 	ldw	r2,0(r2)
   18808:	10800217 	ldw	r2,8(r2)
   1880c:	10800203 	ldbu	r2,8(r2)
   18810:	10c03fcc 	andi	r3,r2,255
   18814:	e0bffd17 	ldw	r2,-12(fp)
   18818:	1886703a 	and	r3,r3,r2
   1881c:	e0bffe17 	ldw	r2,-8(fp)
   18820:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
   18824:	00005906 	br	1898c <lwip_getsockopt_internal+0x268>

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
   18828:	e0bffb17 	ldw	r2,-20(fp)
   1882c:	10800017 	ldw	r2,0(r2)
   18830:	10800017 	ldw	r2,0(r2)
   18834:	10803c0c 	andi	r2,r2,240
   18838:	10c00820 	cmpeqi	r3,r2,32
   1883c:	18000d1e 	bne	r3,zero,18874 <lwip_getsockopt_internal+0x150>
   18840:	10c01020 	cmpeqi	r3,r2,64
   18844:	1800031e 	bne	r3,zero,18854 <lwip_getsockopt_internal+0x130>
   18848:	10800420 	cmpeqi	r2,r2,16
   1884c:	1000051e 	bne	r2,zero,18864 <lwip_getsockopt_internal+0x140>
   18850:	00000c06 	br	18884 <lwip_getsockopt_internal+0x160>
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
   18854:	e0bffe17 	ldw	r2,-8(fp)
   18858:	00c000c4 	movi	r3,3
   1885c:	10c00015 	stw	r3,0(r2)
        break;
   18860:	00000f06 	br	188a0 <lwip_getsockopt_internal+0x17c>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
   18864:	e0bffe17 	ldw	r2,-8(fp)
   18868:	00c00044 	movi	r3,1
   1886c:	10c00015 	stw	r3,0(r2)
        break;
   18870:	00000b06 	br	188a0 <lwip_getsockopt_internal+0x17c>
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
   18874:	e0bffe17 	ldw	r2,-8(fp)
   18878:	00c00084 	movi	r3,2
   1887c:	10c00015 	stw	r3,0(r2)
        break;
   18880:	00000706 	br	188a0 <lwip_getsockopt_internal+0x17c>
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
   18884:	e0bffb17 	ldw	r2,-20(fp)
   18888:	10800017 	ldw	r2,0(r2)
   1888c:	10800017 	ldw	r2,0(r2)
   18890:	1007883a 	mov	r3,r2
   18894:	e0bffe17 	ldw	r2,-8(fp)
   18898:	10c00015 	stw	r3,0(r2)
                    ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE): unrecognized socket type %d\n",
                    s, *(int *)optval));
      }  /* switch (sock->conn->type) */
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;
   1889c:	00003b06 	br	1898c <lwip_getsockopt_internal+0x268>
   188a0:	00003a06 	br	1898c <lwip_getsockopt_internal+0x268>

    case SO_ERROR:
      /* only overwrite ERR_OK or tempoary errors */
      if ((sock->err == 0) || (sock->err == EINPROGRESS)) {
   188a4:	e0bffb17 	ldw	r2,-20(fp)
   188a8:	10800417 	ldw	r2,16(r2)
   188ac:	10000426 	beq	r2,zero,188c0 <lwip_getsockopt_internal+0x19c>
   188b0:	e0bffb17 	ldw	r2,-20(fp)
   188b4:	10800417 	ldw	r2,16(r2)
   188b8:	10801dd8 	cmpnei	r2,r2,119
   188bc:	10001a1e 	bne	r2,zero,18928 <lwip_getsockopt_internal+0x204>
        sock_set_errno(sock, err_to_errno(sock->conn->last_err));
   188c0:	e0bffb17 	ldw	r2,-20(fp)
   188c4:	10800017 	ldw	r2,0(r2)
   188c8:	10800303 	ldbu	r2,12(r2)
   188cc:	10803fcc 	andi	r2,r2,255
   188d0:	1080201c 	xori	r2,r2,128
   188d4:	10bfe004 	addi	r2,r2,-128
   188d8:	0085c83a 	sub	r2,zero,r2
   188dc:	10800428 	cmpgeui	r2,r2,16
   188e0:	10000e1e 	bne	r2,zero,1891c <lwip_getsockopt_internal+0x1f8>
   188e4:	e0bffb17 	ldw	r2,-20(fp)
   188e8:	10800017 	ldw	r2,0(r2)
   188ec:	10800303 	ldbu	r2,12(r2)
   188f0:	10803fcc 	andi	r2,r2,255
   188f4:	1080201c 	xori	r2,r2,128
   188f8:	10bfe004 	addi	r2,r2,-128
   188fc:	0085c83a 	sub	r2,zero,r2
   18900:	00c00134 	movhi	r3,4
   18904:	18c37404 	addi	r3,r3,3536
   18908:	1085883a 	add	r2,r2,r2
   1890c:	1085883a 	add	r2,r2,r2
   18910:	1885883a 	add	r2,r3,r2
   18914:	10800017 	ldw	r2,0(r2)
   18918:	00000106 	br	18920 <lwip_getsockopt_internal+0x1fc>
   1891c:	00800144 	movi	r2,5
   18920:	e0fffb17 	ldw	r3,-20(fp)
   18924:	18800415 	stw	r2,16(r3)
      } 
      *(int *)optval = sock->err;
   18928:	e0bffb17 	ldw	r2,-20(fp)
   1892c:	10c00417 	ldw	r3,16(r2)
   18930:	e0bffe17 	ldw	r2,-8(fp)
   18934:	10c00015 	stw	r3,0(r2)
      sock->err = 0;
   18938:	e0bffb17 	ldw	r2,-20(fp)
   1893c:	10000415 	stw	zero,16(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
   18940:	00001206 	br	1898c <lwip_getsockopt_internal+0x268>
      *(int *)optval = netconn_get_sendtimeout(sock->conn);
      break;
#endif /* LWIP_SO_SNDTIMEO */
#if LWIP_SO_RCVTIMEO
    case SO_RCVTIMEO:
      *(int *)optval = netconn_get_recvtimeout(sock->conn);
   18944:	e0bffb17 	ldw	r2,-20(fp)
   18948:	10800017 	ldw	r2,0(r2)
   1894c:	10c00817 	ldw	r3,32(r2)
   18950:	e0bffe17 	ldw	r2,-8(fp)
   18954:	10c00015 	stw	r3,0(r2)
      break;
   18958:	00000c06 	br	1898c <lwip_getsockopt_internal+0x268>
      *(int *)optval = netconn_get_recvbufsize(sock->conn);
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
   1895c:	e0bffb17 	ldw	r2,-20(fp)
   18960:	10800017 	ldw	r2,0(r2)
   18964:	10800217 	ldw	r2,8(r2)
   18968:	10800403 	ldbu	r2,16(r2)
   1896c:	10803fcc 	andi	r2,r2,255
   18970:	1080004c 	andi	r2,r2,1
   18974:	1004c03a 	cmpne	r2,r2,zero
   18978:	10c03fcc 	andi	r3,r2,255
   1897c:	e0bffe17 	ldw	r2,-8(fp)
   18980:	10c00015 	stw	r3,0(r2)
      break;
   18984:	00000106 	br	1898c <lwip_getsockopt_internal+0x268>
#endif /* LWIP_UDP*/
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
   18988:	0001883a 	nop
    }  /* switch (optname) */
    break;
   1898c:	00005a06 	br	18af8 <lwip_getsockopt_internal+0x3d4>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
   18990:	e0bffd17 	ldw	r2,-12(fp)
   18994:	10c00060 	cmpeqi	r3,r2,1
   18998:	18000a1e 	bne	r3,zero,189c4 <lwip_getsockopt_internal+0x2a0>
   1899c:	108000a0 	cmpeqi	r2,r2,2
   189a0:	10001026 	beq	r2,zero,189e4 <lwip_getsockopt_internal+0x2c0>
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
   189a4:	e0bffb17 	ldw	r2,-20(fp)
   189a8:	10800017 	ldw	r2,0(r2)
   189ac:	10800217 	ldw	r2,8(r2)
   189b0:	10800283 	ldbu	r2,10(r2)
   189b4:	10c03fcc 	andi	r3,r2,255
   189b8:	e0bffe17 	ldw	r2,-8(fp)
   189bc:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
   189c0:	00000906 	br	189e8 <lwip_getsockopt_internal+0x2c4>
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
   189c4:	e0bffb17 	ldw	r2,-20(fp)
   189c8:	10800017 	ldw	r2,0(r2)
   189cc:	10800217 	ldw	r2,8(r2)
   189d0:	10800243 	ldbu	r2,9(r2)
   189d4:	10c03fcc 	andi	r3,r2,255
   189d8:	e0bffe17 	ldw	r2,-8(fp)
   189dc:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
                  s, *(int *)optval));
      break;
   189e0:	00000106 	br	189e8 <lwip_getsockopt_internal+0x2c4>
                  s, *(int *)optval));
      break;
#endif /* LWIP_IGMP */
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
   189e4:	0001883a 	nop
    }  /* switch (optname) */
    break;
   189e8:	00004306 	br	18af8 <lwip_getsockopt_internal+0x3d4>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
   189ec:	e0bffd17 	ldw	r2,-12(fp)
   189f0:	108001a8 	cmpgeui	r2,r2,6
   189f4:	10003d1e 	bne	r2,zero,18aec <lwip_getsockopt_internal+0x3c8>
   189f8:	e0bffd17 	ldw	r2,-12(fp)
   189fc:	1085883a 	add	r2,r2,r2
   18a00:	1087883a 	add	r3,r2,r2
   18a04:	008000b4 	movhi	r2,2
   18a08:	10a28604 	addi	r2,r2,-30184
   18a0c:	1885883a 	add	r2,r3,r2
   18a10:	10800017 	ldw	r2,0(r2)
   18a14:	1000683a 	jmp	r2
   18a18:	00018aec 	andhi	zero,zero,1579
   18a1c:	00018a30 	cmpltui	zero,zero,1576
   18a20:	00018a5c 	xori	zero,zero,1577
   18a24:	00018a7c 	xorhi	zero,zero,1577
   18a28:	00018aa4 	muli	zero,zero,1578
   18a2c:	00018acc 	andi	zero,zero,1579
    case TCP_NODELAY:
      *(int*)optval = tcp_nagle_disabled(sock->conn->pcb.tcp);
   18a30:	e0bffb17 	ldw	r2,-20(fp)
   18a34:	10800017 	ldw	r2,0(r2)
   18a38:	10800217 	ldw	r2,8(r2)
   18a3c:	10800883 	ldbu	r2,34(r2)
   18a40:	10803fcc 	andi	r2,r2,255
   18a44:	1080100c 	andi	r2,r2,64
   18a48:	1004c03a 	cmpne	r2,r2,zero
   18a4c:	10c03fcc 	andi	r3,r2,255
   18a50:	e0bffe17 	ldw	r2,-8(fp)
   18a54:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
   18a58:	00002506 	br	18af0 <lwip_getsockopt_internal+0x3cc>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
   18a5c:	e0bffb17 	ldw	r2,-20(fp)
   18a60:	10800017 	ldw	r2,0(r2)
   18a64:	10800217 	ldw	r2,8(r2)
   18a68:	10802517 	ldw	r2,148(r2)
   18a6c:	1007883a 	mov	r3,r2
   18a70:	e0bffe17 	ldw	r2,-8(fp)
   18a74:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPALIVE) = %d\n",
                  s, *(int *)optval));
      break;
   18a78:	00001d06 	br	18af0 <lwip_getsockopt_internal+0x3cc>

#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
      *(int*)optval = (int)(sock->conn->pcb.tcp->keep_idle/1000);
   18a7c:	e0bffb17 	ldw	r2,-20(fp)
   18a80:	10800017 	ldw	r2,0(r2)
   18a84:	10800217 	ldw	r2,8(r2)
   18a88:	10c02517 	ldw	r3,148(r2)
   18a8c:	0080fa04 	movi	r2,1000
   18a90:	1885203a 	divu	r2,r3,r2
   18a94:	1007883a 	mov	r3,r2
   18a98:	e0bffe17 	ldw	r2,-8(fp)
   18a9c:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPIDLE) = %d\n",
                  s, *(int *)optval));
      break;
   18aa0:	00001306 	br	18af0 <lwip_getsockopt_internal+0x3cc>
    case TCP_KEEPINTVL:
      *(int*)optval = (int)(sock->conn->pcb.tcp->keep_intvl/1000);
   18aa4:	e0bffb17 	ldw	r2,-20(fp)
   18aa8:	10800017 	ldw	r2,0(r2)
   18aac:	10800217 	ldw	r2,8(r2)
   18ab0:	10c02617 	ldw	r3,152(r2)
   18ab4:	0080fa04 	movi	r2,1000
   18ab8:	1885203a 	divu	r2,r3,r2
   18abc:	1007883a 	mov	r3,r2
   18ac0:	e0bffe17 	ldw	r2,-8(fp)
   18ac4:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPINTVL) = %d\n",
                  s, *(int *)optval));
      break;
   18ac8:	00000906 	br	18af0 <lwip_getsockopt_internal+0x3cc>
    case TCP_KEEPCNT:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_cnt;
   18acc:	e0bffb17 	ldw	r2,-20(fp)
   18ad0:	10800017 	ldw	r2,0(r2)
   18ad4:	10800217 	ldw	r2,8(r2)
   18ad8:	10802717 	ldw	r2,156(r2)
   18adc:	1007883a 	mov	r3,r2
   18ae0:	e0bffe17 	ldw	r2,-8(fp)
   18ae4:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPCNT) = %d\n",
                  s, *(int *)optval));
      break;
   18ae8:	00000106 	br	18af0 <lwip_getsockopt_internal+0x3cc>
#endif /* LWIP_TCP_KEEPALIVE */
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
   18aec:	0001883a 	nop
    }  /* switch (optname) */
    break;
   18af0:	00000106 	br	18af8 <lwip_getsockopt_internal+0x3d4>
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  default:
    LWIP_ASSERT("unhandled level", 0);
    break;
   18af4:	0001883a 	nop
  } /* switch (level) */
  sys_sem_signal(&sock->conn->op_completed);
   18af8:	e0bffb17 	ldw	r2,-20(fp)
   18afc:	10800017 	ldw	r2,0(r2)
   18b00:	10800404 	addi	r2,r2,16
   18b04:	1009883a 	mov	r4,r2
   18b08:	001b2f00 	call	1b2f0 <sys_sem_signal>
}
   18b0c:	e037883a 	mov	sp,fp
   18b10:	dfc00117 	ldw	ra,4(sp)
   18b14:	df000017 	ldw	fp,0(sp)
   18b18:	dec00204 	addi	sp,sp,8
   18b1c:	f800283a 	ret

00018b20 <lwip_setsockopt>:

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
   18b20:	defff204 	addi	sp,sp,-56
   18b24:	dfc00d15 	stw	ra,52(sp)
   18b28:	df000c15 	stw	fp,48(sp)
   18b2c:	df000c04 	addi	fp,sp,48
   18b30:	e13ffc15 	stw	r4,-16(fp)
   18b34:	e17ffd15 	stw	r5,-12(fp)
   18b38:	e1bffe15 	stw	r6,-8(fp)
   18b3c:	e1ffff15 	stw	r7,-4(fp)
  struct lwip_sock *sock = get_socket(s);
   18b40:	e13ffc17 	ldw	r4,-16(fp)
   18b44:	00160940 	call	16094 <get_socket>
   18b48:	e0bff515 	stw	r2,-44(fp)
  err_t err = ERR_OK;
   18b4c:	e03ff405 	stb	zero,-48(fp)
  struct lwip_setgetsockopt_data data;

  if (!sock) {
   18b50:	e0bff517 	ldw	r2,-44(fp)
   18b54:	1000021e 	bne	r2,zero,18b60 <lwip_setsockopt+0x40>
    return -1;
   18b58:	00bfffc4 	movi	r2,-1
   18b5c:	00008f06 	br	18d9c <lwip_setsockopt+0x27c>
  }

  if (NULL == optval) {
   18b60:	e0bfff17 	ldw	r2,-4(fp)
   18b64:	1000051e 	bne	r2,zero,18b7c <lwip_setsockopt+0x5c>
    sock_set_errno(sock, EFAULT);
   18b68:	e0bff517 	ldw	r2,-44(fp)
   18b6c:	00c00384 	movi	r3,14
   18b70:	10c00415 	stw	r3,16(r2)
    return -1;
   18b74:	00bfffc4 	movi	r2,-1
   18b78:	00008806 	br	18d9c <lwip_setsockopt+0x27c>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
   18b7c:	e0bffd17 	ldw	r2,-12(fp)
   18b80:	10c001a0 	cmpeqi	r3,r2,6
   18b84:	1800441e 	bne	r3,zero,18c98 <lwip_setsockopt+0x178>
   18b88:	10c3ffe0 	cmpeqi	r3,r2,4095
   18b8c:	1800021e 	bne	r3,zero,18b98 <lwip_setsockopt+0x78>
   18b90:	10003226 	beq	r2,zero,18c5c <lwip_setsockopt+0x13c>
   18b94:	00005606 	br	18cf0 <lwip_setsockopt+0x1d0>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
   18b98:	e0bffe17 	ldw	r2,-8(fp)
   18b9c:	10c00820 	cmpeqi	r3,r2,32
   18ba0:	18000d1e 	bne	r3,zero,18bd8 <lwip_setsockopt+0xb8>
   18ba4:	10c00848 	cmpgei	r3,r2,33
   18ba8:	1800051e 	bne	r3,zero,18bc0 <lwip_setsockopt+0xa0>
   18bac:	10c00120 	cmpeqi	r3,r2,4
   18bb0:	1800091e 	bne	r3,zero,18bd8 <lwip_setsockopt+0xb8>
   18bb4:	10800220 	cmpeqi	r2,r2,8
   18bb8:	1000071e 	bne	r2,zero,18bd8 <lwip_setsockopt+0xb8>
   18bbc:	00002006 	br	18c40 <lwip_setsockopt+0x120>
   18bc0:	10c401a0 	cmpeqi	r3,r2,4102
   18bc4:	1800041e 	bne	r3,zero,18bd8 <lwip_setsockopt+0xb8>
   18bc8:	10c402a0 	cmpeqi	r3,r2,4106
   18bcc:	1800081e 	bne	r3,zero,18bf0 <lwip_setsockopt+0xd0>
   18bd0:	10808020 	cmpeqi	r2,r2,512
   18bd4:	10001a26 	beq	r2,zero,18c40 <lwip_setsockopt+0x120>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
   18bd8:	e0800217 	ldw	r2,8(fp)
   18bdc:	10800128 	cmpgeui	r2,r2,4
   18be0:	10001a1e 	bne	r2,zero,18c4c <lwip_setsockopt+0x12c>
        err = EINVAL;
   18be4:	00800584 	movi	r2,22
   18be8:	e0bff405 	stb	r2,-48(fp)
      }
      break;
   18bec:	00001706 	br	18c4c <lwip_setsockopt+0x12c>
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
   18bf0:	e0800217 	ldw	r2,8(fp)
   18bf4:	10800128 	cmpgeui	r2,r2,4
   18bf8:	1000021e 	bne	r2,zero,18c04 <lwip_setsockopt+0xe4>
        err = EINVAL;
   18bfc:	00800584 	movi	r2,22
   18c00:	e0bff405 	stb	r2,-48(fp)
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
   18c04:	e0bff517 	ldw	r2,-44(fp)
   18c08:	10800017 	ldw	r2,0(r2)
   18c0c:	10800017 	ldw	r2,0(r2)
   18c10:	10800818 	cmpnei	r2,r2,32
   18c14:	1000071e 	bne	r2,zero,18c34 <lwip_setsockopt+0x114>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
   18c18:	e0bff517 	ldw	r2,-44(fp)
   18c1c:	10800017 	ldw	r2,0(r2)
   18c20:	10800217 	ldw	r2,8(r2)
   18c24:	10800403 	ldbu	r2,16(r2)
   18c28:	10803fcc 	andi	r2,r2,255
   18c2c:	1080008c 	andi	r2,r2,2
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
   18c30:	10000826 	beq	r2,zero,18c54 <lwip_setsockopt+0x134>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
   18c34:	00801a84 	movi	r2,106
   18c38:	e0bff405 	stb	r2,-48(fp)
      }
#endif /* LWIP_UDP */
      break;
   18c3c:	00000506 	br	18c54 <lwip_setsockopt+0x134>
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
   18c40:	00801b44 	movi	r2,109
   18c44:	e0bff405 	stb	r2,-48(fp)
    }  /* switch (optname) */
    break;
   18c48:	00002b06 	br	18cf8 <lwip_setsockopt+0x1d8>
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
      break;
   18c4c:	0001883a 	nop
   18c50:	00000106 	br	18c58 <lwip_setsockopt+0x138>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
      }
#endif /* LWIP_UDP */
      break;
   18c54:	0001883a 	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
   18c58:	00002706 	br	18cf8 <lwip_setsockopt+0x1d8>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
   18c5c:	e0bffe17 	ldw	r2,-8(fp)
   18c60:	10bfffc4 	addi	r2,r2,-1
   18c64:	108000a8 	cmpgeui	r2,r2,2
   18c68:	1000061e 	bne	r2,zero,18c84 <lwip_setsockopt+0x164>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
   18c6c:	e0800217 	ldw	r2,8(fp)
   18c70:	10800128 	cmpgeui	r2,r2,4
   18c74:	1000061e 	bne	r2,zero,18c90 <lwip_setsockopt+0x170>
        err = EINVAL;
   18c78:	00800584 	movi	r2,22
   18c7c:	e0bff405 	stb	r2,-48(fp)
      }
      break;
   18c80:	00000306 	br	18c90 <lwip_setsockopt+0x170>
      break;
#endif /* LWIP_IGMP */
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
   18c84:	00801b44 	movi	r2,109
   18c88:	e0bff405 	stb	r2,-48(fp)
    }  /* switch (optname) */
    break;
   18c8c:	00001a06 	br	18cf8 <lwip_setsockopt+0x1d8>
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
      break;
   18c90:	0001883a 	nop
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
   18c94:	00001806 	br	18cf8 <lwip_setsockopt+0x1d8>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
   18c98:	e0800217 	ldw	r2,8(fp)
   18c9c:	10800128 	cmpgeui	r2,r2,4
   18ca0:	1000031e 	bne	r2,zero,18cb0 <lwip_setsockopt+0x190>
      err = EINVAL;
   18ca4:	00800584 	movi	r2,22
   18ca8:	e0bff405 	stb	r2,-48(fp)
      break;
   18cac:	00001206 	br	18cf8 <lwip_setsockopt+0x1d8>
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
   18cb0:	e0bff517 	ldw	r2,-44(fp)
   18cb4:	10800017 	ldw	r2,0(r2)
   18cb8:	10800017 	ldw	r2,0(r2)
   18cbc:	10800420 	cmpeqi	r2,r2,16
   18cc0:	1000021e 	bne	r2,zero,18ccc <lwip_setsockopt+0x1ac>
      return 0;
   18cc4:	0005883a 	mov	r2,zero
   18cc8:	00003406 	br	18d9c <lwip_setsockopt+0x27c>

    switch (optname) {
   18ccc:	e0bffe17 	ldw	r2,-8(fp)
   18cd0:	10bfffc4 	addi	r2,r2,-1
   18cd4:	10800168 	cmpgeui	r2,r2,5
   18cd8:	1000021e 	bne	r2,zero,18ce4 <lwip_setsockopt+0x1c4>
#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
    case TCP_KEEPINTVL:
    case TCP_KEEPCNT:
#endif /* LWIP_TCP_KEEPALIVE */
      break;
   18cdc:	0001883a 	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
   18ce0:	00000506 	br	18cf8 <lwip_setsockopt+0x1d8>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
   18ce4:	00801b44 	movi	r2,109
   18ce8:	e0bff405 	stb	r2,-48(fp)
    }  /* switch (optname) */
    break;
   18cec:	00000206 	br	18cf8 <lwip_setsockopt+0x1d8>
#endif /* LWIP_UDP && LWIP_UDPLITE */
/* UNDEFINED LEVEL */
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                s, level, optname));
    err = ENOPROTOOPT;
   18cf0:	00801b44 	movi	r2,109
   18cf4:	e0bff405 	stb	r2,-48(fp)
  }  /* switch (level) */


  if (err != ERR_OK) {
   18cf8:	e0bff407 	ldb	r2,-48(fp)
   18cfc:	10000526 	beq	r2,zero,18d14 <lwip_setsockopt+0x1f4>
    sock_set_errno(sock, err);
   18d00:	e0fff407 	ldb	r3,-48(fp)
   18d04:	e0bff517 	ldw	r2,-44(fp)
   18d08:	10c00415 	stw	r3,16(r2)
    return -1;
   18d0c:	00bfffc4 	movi	r2,-1
   18d10:	00002206 	br	18d9c <lwip_setsockopt+0x27c>
  }


  /* Now do the actual option processing */
  data.sock = sock;
   18d14:	e0bff517 	ldw	r2,-44(fp)
   18d18:	e0bff615 	stw	r2,-40(fp)
#ifdef LWIP_DEBUG
  data.s = s;
#endif /* LWIP_DEBUG */
  data.level = level;
   18d1c:	e0bffd17 	ldw	r2,-12(fp)
   18d20:	e0bff715 	stw	r2,-36(fp)
  data.optname = optname;
   18d24:	e0bffe17 	ldw	r2,-8(fp)
   18d28:	e0bff815 	stw	r2,-32(fp)
  data.optval = (void*)optval;
   18d2c:	e0bfff17 	ldw	r2,-4(fp)
   18d30:	e0bff915 	stw	r2,-28(fp)
  data.optlen = &optlen;
   18d34:	e0800204 	addi	r2,fp,8
   18d38:	e0bffa15 	stw	r2,-24(fp)
  data.err = err;
   18d3c:	e0bff403 	ldbu	r2,-48(fp)
   18d40:	e0bffb05 	stb	r2,-20(fp)
  tcpip_callback(lwip_setsockopt_internal, &data);
   18d44:	e0bff604 	addi	r2,fp,-40
   18d48:	010000b4 	movhi	r4,2
   18d4c:	21236c04 	addi	r4,r4,-29264
   18d50:	100b883a 	mov	r5,r2
   18d54:	01800044 	movi	r6,1
   18d58:	001954c0 	call	1954c <tcpip_callback_with_block>
  sys_arch_sem_wait(&sock->conn->op_completed, 0);
   18d5c:	e0bff517 	ldw	r2,-44(fp)
   18d60:	10800017 	ldw	r2,0(r2)
   18d64:	10800404 	addi	r2,r2,16
   18d68:	1009883a 	mov	r4,r2
   18d6c:	000b883a 	mov	r5,zero
   18d70:	001b3340 	call	1b334 <sys_arch_sem_wait>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
   18d74:	e0bffb03 	ldbu	r2,-20(fp)
   18d78:	e0bff405 	stb	r2,-48(fp)

  sock_set_errno(sock, err);
   18d7c:	e0fff407 	ldb	r3,-48(fp)
   18d80:	e0bff517 	ldw	r2,-44(fp)
   18d84:	10c00415 	stw	r3,16(r2)
  return err ? -1 : 0;
   18d88:	e0bff407 	ldb	r2,-48(fp)
   18d8c:	10000226 	beq	r2,zero,18d98 <lwip_setsockopt+0x278>
   18d90:	00bfffc4 	movi	r2,-1
   18d94:	00000106 	br	18d9c <lwip_setsockopt+0x27c>
   18d98:	0005883a 	mov	r2,zero
}
   18d9c:	e037883a 	mov	sp,fp
   18da0:	dfc00117 	ldw	ra,4(sp)
   18da4:	df000017 	ldw	fp,0(sp)
   18da8:	dec00204 	addi	sp,sp,8
   18dac:	f800283a 	ret

00018db0 <lwip_setsockopt_internal>:

static void
lwip_setsockopt_internal(void *arg)
{
   18db0:	defff804 	addi	sp,sp,-32
   18db4:	dfc00715 	stw	ra,28(sp)
   18db8:	df000615 	stw	fp,24(sp)
   18dbc:	df000604 	addi	fp,sp,24
   18dc0:	e13fff15 	stw	r4,-4(fp)
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);

  data = (struct lwip_setgetsockopt_data*)arg;
   18dc4:	e0bfff17 	ldw	r2,-4(fp)
   18dc8:	e0bffa15 	stw	r2,-24(fp)
  sock = data->sock;
   18dcc:	e0bffa17 	ldw	r2,-24(fp)
   18dd0:	10800017 	ldw	r2,0(r2)
   18dd4:	e0bffb15 	stw	r2,-20(fp)
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
   18dd8:	e0bffa17 	ldw	r2,-24(fp)
   18ddc:	10800117 	ldw	r2,4(r2)
   18de0:	e0bffc15 	stw	r2,-16(fp)
  optname = data->optname;
   18de4:	e0bffa17 	ldw	r2,-24(fp)
   18de8:	10800217 	ldw	r2,8(r2)
   18dec:	e0bffd15 	stw	r2,-12(fp)
  optval = data->optval;
   18df0:	e0bffa17 	ldw	r2,-24(fp)
   18df4:	10800317 	ldw	r2,12(r2)
   18df8:	e0bffe15 	stw	r2,-8(fp)

  switch (level) {
   18dfc:	e0bffc17 	ldw	r2,-16(fp)
   18e00:	10c001a0 	cmpeqi	r3,r2,6
   18e04:	1800651e 	bne	r3,zero,18f9c <lwip_setsockopt_internal+0x1ec>
   18e08:	10c3ffe0 	cmpeqi	r3,r2,4095
   18e0c:	1800021e 	bne	r3,zero,18e18 <lwip_setsockopt_internal+0x68>
   18e10:	10004d26 	beq	r2,zero,18f48 <lwip_setsockopt_internal+0x198>
   18e14:	0000aa06 	br	190c0 <lwip_setsockopt_internal+0x310>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
   18e18:	e0bffd17 	ldw	r2,-12(fp)
   18e1c:	10c00820 	cmpeqi	r3,r2,32
   18e20:	18000d1e 	bne	r3,zero,18e58 <lwip_setsockopt_internal+0xa8>
   18e24:	10c00848 	cmpgei	r3,r2,33
   18e28:	1800051e 	bne	r3,zero,18e40 <lwip_setsockopt_internal+0x90>
   18e2c:	10c00120 	cmpeqi	r3,r2,4
   18e30:	1800091e 	bne	r3,zero,18e58 <lwip_setsockopt_internal+0xa8>
   18e34:	10800220 	cmpeqi	r2,r2,8
   18e38:	1000071e 	bne	r2,zero,18e58 <lwip_setsockopt_internal+0xa8>
   18e3c:	00004006 	br	18f40 <lwip_setsockopt_internal+0x190>
   18e40:	10c401a0 	cmpeqi	r3,r2,4102
   18e44:	1800201e 	bne	r3,zero,18ec8 <lwip_setsockopt_internal+0x118>
   18e48:	10c402a0 	cmpeqi	r3,r2,4106
   18e4c:	1800241e 	bne	r3,zero,18ee0 <lwip_setsockopt_internal+0x130>
   18e50:	10808020 	cmpeqi	r2,r2,512
   18e54:	10003a26 	beq	r2,zero,18f40 <lwip_setsockopt_internal+0x190>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
   18e58:	e0bffe17 	ldw	r2,-8(fp)
   18e5c:	10800017 	ldw	r2,0(r2)
   18e60:	10000c26 	beq	r2,zero,18e94 <lwip_setsockopt_internal+0xe4>
        ip_set_option(sock->conn->pcb.ip, optname);
   18e64:	e0bffb17 	ldw	r2,-20(fp)
   18e68:	10800017 	ldw	r2,0(r2)
   18e6c:	10800217 	ldw	r2,8(r2)
   18e70:	e0fffb17 	ldw	r3,-20(fp)
   18e74:	18c00017 	ldw	r3,0(r3)
   18e78:	18c00217 	ldw	r3,8(r3)
   18e7c:	18c00203 	ldbu	r3,8(r3)
   18e80:	1809883a 	mov	r4,r3
   18e84:	e0fffd17 	ldw	r3,-12(fp)
   18e88:	20c6b03a 	or	r3,r4,r3
   18e8c:	10c00205 	stb	r3,8(r2)
      } else {
        ip_reset_option(sock->conn->pcb.ip, optname);
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
                  s, optname, (*(int*)optval?"on":"off")));
      break;
   18e90:	00002c06 	br	18f44 <lwip_setsockopt_internal+0x194>
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
        ip_set_option(sock->conn->pcb.ip, optname);
      } else {
        ip_reset_option(sock->conn->pcb.ip, optname);
   18e94:	e0bffb17 	ldw	r2,-20(fp)
   18e98:	10800017 	ldw	r2,0(r2)
   18e9c:	10800217 	ldw	r2,8(r2)
   18ea0:	e0fffb17 	ldw	r3,-20(fp)
   18ea4:	18c00017 	ldw	r3,0(r3)
   18ea8:	18c00217 	ldw	r3,8(r3)
   18eac:	18c00203 	ldbu	r3,8(r3)
   18eb0:	1809883a 	mov	r4,r3
   18eb4:	e0fffd17 	ldw	r3,-12(fp)
   18eb8:	00c6303a 	nor	r3,zero,r3
   18ebc:	20c6703a 	and	r3,r4,r3
   18ec0:	10c00205 	stb	r3,8(r2)
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
                  s, optname, (*(int*)optval?"on":"off")));
      break;
   18ec4:	00001f06 	br	18f44 <lwip_setsockopt_internal+0x194>
      netconn_set_sendtimeout(sock->conn, (s32_t)*(int*)optval);
      break;
#endif /* LWIP_SO_SNDTIMEO */
#if LWIP_SO_RCVTIMEO
    case SO_RCVTIMEO:
      netconn_set_recvtimeout(sock->conn, *(int*)optval);
   18ec8:	e0bffb17 	ldw	r2,-20(fp)
   18ecc:	10800017 	ldw	r2,0(r2)
   18ed0:	e0fffe17 	ldw	r3,-8(fp)
   18ed4:	18c00017 	ldw	r3,0(r3)
   18ed8:	10c00815 	stw	r3,32(r2)
      break;
   18edc:	00001906 	br	18f44 <lwip_setsockopt_internal+0x194>
      netconn_set_recvbufsize(sock->conn, *(int*)optval);
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
   18ee0:	e0bffe17 	ldw	r2,-8(fp)
   18ee4:	10800017 	ldw	r2,0(r2)
   18ee8:	10000a26 	beq	r2,zero,18f14 <lwip_setsockopt_internal+0x164>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
   18eec:	e0bffb17 	ldw	r2,-20(fp)
   18ef0:	10800017 	ldw	r2,0(r2)
   18ef4:	10800217 	ldw	r2,8(r2)
   18ef8:	e0fffb17 	ldw	r3,-20(fp)
   18efc:	18c00017 	ldw	r3,0(r3)
   18f00:	18c00217 	ldw	r3,8(r3)
   18f04:	18c00403 	ldbu	r3,16(r3)
   18f08:	18c00054 	ori	r3,r3,1
   18f0c:	10c00405 	stb	r3,16(r2)
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
      }
      break;
   18f10:	00000c06 	br	18f44 <lwip_setsockopt_internal+0x194>
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
   18f14:	e0bffb17 	ldw	r2,-20(fp)
   18f18:	10800017 	ldw	r2,0(r2)
   18f1c:	10800217 	ldw	r2,8(r2)
   18f20:	e0fffb17 	ldw	r3,-20(fp)
   18f24:	18c00017 	ldw	r3,0(r3)
   18f28:	18c00217 	ldw	r3,8(r3)
   18f2c:	19000403 	ldbu	r4,16(r3)
   18f30:	00ffff84 	movi	r3,-2
   18f34:	20c6703a 	and	r3,r4,r3
   18f38:	10c00405 	stb	r3,16(r2)
      }
      break;
   18f3c:	00000106 	br	18f44 <lwip_setsockopt_internal+0x194>
#endif /* LWIP_UDP */
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
   18f40:	0001883a 	nop
    }  /* switch (optname) */
    break;
   18f44:	00005f06 	br	190c4 <lwip_setsockopt_internal+0x314>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
   18f48:	e0bffd17 	ldw	r2,-12(fp)
   18f4c:	10c00060 	cmpeqi	r3,r2,1
   18f50:	1800091e 	bne	r3,zero,18f78 <lwip_setsockopt_internal+0x1c8>
   18f54:	108000a0 	cmpeqi	r2,r2,2
   18f58:	10000e26 	beq	r2,zero,18f94 <lwip_setsockopt_internal+0x1e4>
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
   18f5c:	e0bffb17 	ldw	r2,-20(fp)
   18f60:	10800017 	ldw	r2,0(r2)
   18f64:	10800217 	ldw	r2,8(r2)
   18f68:	e0fffe17 	ldw	r3,-8(fp)
   18f6c:	18c00017 	ldw	r3,0(r3)
   18f70:	10c00285 	stb	r3,10(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %d\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
   18f74:	00000806 	br	18f98 <lwip_setsockopt_internal+0x1e8>
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
   18f78:	e0bffb17 	ldw	r2,-20(fp)
   18f7c:	10800017 	ldw	r2,0(r2)
   18f80:	10800217 	ldw	r2,8(r2)
   18f84:	e0fffe17 	ldw	r3,-8(fp)
   18f88:	18c00017 	ldw	r3,0(r3)
   18f8c:	10c00245 	stb	r3,9(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %d\n",
                  s, sock->conn->pcb.ip->tos));
      break;
   18f90:	00000106 	br	18f98 <lwip_setsockopt_internal+0x1e8>
      }
      break;
#endif /* LWIP_IGMP */
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
   18f94:	0001883a 	nop
    }  /* switch (optname) */
    break;
   18f98:	00004a06 	br	190c4 <lwip_setsockopt_internal+0x314>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
   18f9c:	e0bffd17 	ldw	r2,-12(fp)
   18fa0:	108001a8 	cmpgeui	r2,r2,6
   18fa4:	1000441e 	bne	r2,zero,190b8 <lwip_setsockopt_internal+0x308>
   18fa8:	e0bffd17 	ldw	r2,-12(fp)
   18fac:	1085883a 	add	r2,r2,r2
   18fb0:	1087883a 	add	r3,r2,r2
   18fb4:	008000b4 	movhi	r2,2
   18fb8:	10a3f204 	addi	r2,r2,-28728
   18fbc:	1885883a 	add	r2,r3,r2
   18fc0:	10800017 	ldw	r2,0(r2)
   18fc4:	1000683a 	jmp	r2
   18fc8:	000190b8 	rdprs	zero,zero,1602
   18fcc:	00018fe0 	cmpeqi	zero,zero,1599
   18fd0:	00019040 	call	1904 <prvLowPriorityPeekTask+0x144>
   18fd4:	0001905c 	xori	zero,zero,1601
   18fd8:	0001907c 	xorhi	zero,zero,1601
   18fdc:	0001909c 	xori	zero,zero,1602
    case TCP_NODELAY:
      if (*(int*)optval) {
   18fe0:	e0bffe17 	ldw	r2,-8(fp)
   18fe4:	10800017 	ldw	r2,0(r2)
   18fe8:	10000a26 	beq	r2,zero,19014 <lwip_setsockopt_internal+0x264>
        tcp_nagle_disable(sock->conn->pcb.tcp);
   18fec:	e0bffb17 	ldw	r2,-20(fp)
   18ff0:	10800017 	ldw	r2,0(r2)
   18ff4:	10800217 	ldw	r2,8(r2)
   18ff8:	e0fffb17 	ldw	r3,-20(fp)
   18ffc:	18c00017 	ldw	r3,0(r3)
   19000:	18c00217 	ldw	r3,8(r3)
   19004:	18c00883 	ldbu	r3,34(r3)
   19008:	18c01014 	ori	r3,r3,64
   1900c:	10c00885 	stb	r3,34(r2)
      } else {
        tcp_nagle_enable(sock->conn->pcb.tcp);
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
   19010:	00002a06 	br	190bc <lwip_setsockopt_internal+0x30c>
    switch (optname) {
    case TCP_NODELAY:
      if (*(int*)optval) {
        tcp_nagle_disable(sock->conn->pcb.tcp);
      } else {
        tcp_nagle_enable(sock->conn->pcb.tcp);
   19014:	e0bffb17 	ldw	r2,-20(fp)
   19018:	10800017 	ldw	r2,0(r2)
   1901c:	10800217 	ldw	r2,8(r2)
   19020:	e0fffb17 	ldw	r3,-20(fp)
   19024:	18c00017 	ldw	r3,0(r3)
   19028:	18c00217 	ldw	r3,8(r3)
   1902c:	19000883 	ldbu	r4,34(r3)
   19030:	00ffefc4 	movi	r3,-65
   19034:	20c6703a 	and	r3,r4,r3
   19038:	10c00885 	stb	r3,34(r2)
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
   1903c:	00001f06 	br	190bc <lwip_setsockopt_internal+0x30c>
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
   19040:	e0bffb17 	ldw	r2,-20(fp)
   19044:	10800017 	ldw	r2,0(r2)
   19048:	10800217 	ldw	r2,8(r2)
   1904c:	e0fffe17 	ldw	r3,-8(fp)
   19050:	18c00017 	ldw	r3,0(r3)
   19054:	10c02515 	stw	r3,148(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPALIVE) -> %"U32_F"\n",
                  s, sock->conn->pcb.tcp->keep_idle));
      break;
   19058:	00001806 	br	190bc <lwip_setsockopt_internal+0x30c>

#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
      sock->conn->pcb.tcp->keep_idle = 1000*(u32_t)(*(int*)optval);
   1905c:	e0bffb17 	ldw	r2,-20(fp)
   19060:	10800017 	ldw	r2,0(r2)
   19064:	10800217 	ldw	r2,8(r2)
   19068:	e0fffe17 	ldw	r3,-8(fp)
   1906c:	18c00017 	ldw	r3,0(r3)
   19070:	18c0fa24 	muli	r3,r3,1000
   19074:	10c02515 	stw	r3,148(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPIDLE) -> %"U32_F"\n",
                  s, sock->conn->pcb.tcp->keep_idle));
      break;
   19078:	00001006 	br	190bc <lwip_setsockopt_internal+0x30c>
    case TCP_KEEPINTVL:
      sock->conn->pcb.tcp->keep_intvl = 1000*(u32_t)(*(int*)optval);
   1907c:	e0bffb17 	ldw	r2,-20(fp)
   19080:	10800017 	ldw	r2,0(r2)
   19084:	10800217 	ldw	r2,8(r2)
   19088:	e0fffe17 	ldw	r3,-8(fp)
   1908c:	18c00017 	ldw	r3,0(r3)
   19090:	18c0fa24 	muli	r3,r3,1000
   19094:	10c02615 	stw	r3,152(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPINTVL) -> %"U32_F"\n",
                  s, sock->conn->pcb.tcp->keep_intvl));
      break;
   19098:	00000806 	br	190bc <lwip_setsockopt_internal+0x30c>
    case TCP_KEEPCNT:
      sock->conn->pcb.tcp->keep_cnt = (u32_t)(*(int*)optval);
   1909c:	e0bffb17 	ldw	r2,-20(fp)
   190a0:	10800017 	ldw	r2,0(r2)
   190a4:	10800217 	ldw	r2,8(r2)
   190a8:	e0fffe17 	ldw	r3,-8(fp)
   190ac:	18c00017 	ldw	r3,0(r3)
   190b0:	10c02715 	stw	r3,156(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPCNT) -> %"U32_F"\n",
                  s, sock->conn->pcb.tcp->keep_cnt));
      break;
   190b4:	00000106 	br	190bc <lwip_setsockopt_internal+0x30c>
#endif /* LWIP_TCP_KEEPALIVE */
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
   190b8:	0001883a 	nop
    }  /* switch (optname) */
    break;
   190bc:	00000106 	br	190c4 <lwip_setsockopt_internal+0x314>
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  default:
    LWIP_ASSERT("unhandled level", 0);
    break;
   190c0:	0001883a 	nop
  }  /* switch (level) */
  sys_sem_signal(&sock->conn->op_completed);
   190c4:	e0bffb17 	ldw	r2,-20(fp)
   190c8:	10800017 	ldw	r2,0(r2)
   190cc:	10800404 	addi	r2,r2,16
   190d0:	1009883a 	mov	r4,r2
   190d4:	001b2f00 	call	1b2f0 <sys_sem_signal>
}
   190d8:	e037883a 	mov	sp,fp
   190dc:	dfc00117 	ldw	ra,4(sp)
   190e0:	df000017 	ldw	fp,0(sp)
   190e4:	dec00204 	addi	sp,sp,8
   190e8:	f800283a 	ret

000190ec <lwip_ioctl>:

int
lwip_ioctl(int s, long cmd, void *argp)
{
   190ec:	defff904 	addi	sp,sp,-28
   190f0:	dfc00615 	stw	ra,24(sp)
   190f4:	df000515 	stw	fp,20(sp)
   190f8:	df000504 	addi	fp,sp,20
   190fc:	e13ffd15 	stw	r4,-12(fp)
   19100:	e17ffe15 	stw	r5,-8(fp)
   19104:	e1bfff15 	stw	r6,-4(fp)
  struct lwip_sock *sock = get_socket(s);
   19108:	e13ffd17 	ldw	r4,-12(fp)
   1910c:	00160940 	call	16094 <get_socket>
   19110:	e0bffc15 	stw	r2,-16(fp)
#if LWIP_SO_RCVBUF
  u16_t buflen = 0;
  s16_t recv_avail;
#endif /* LWIP_SO_RCVBUF */

  if (!sock) {
   19114:	e0bffc17 	ldw	r2,-16(fp)
   19118:	1000021e 	bne	r2,zero,19124 <lwip_ioctl+0x38>
    return -1;
   1911c:	00bfffc4 	movi	r2,-1
   19120:	00002606 	br	191bc <lwip_ioctl+0xd0>
  }

  switch (cmd) {
   19124:	e0fffe17 	ldw	r3,-8(fp)
   19128:	00a00134 	movhi	r2,32772
   1912c:	10999f84 	addi	r2,r2,26238
   19130:	18801e1e 	bne	r3,r2,191ac <lwip_ioctl+0xc0>
    sock_set_errno(sock, 0);
    return 0;
#endif /* LWIP_SO_RCVBUF */

  case FIONBIO:
    val = 0;
   19134:	e03ffb05 	stb	zero,-20(fp)
    if (argp && *(u32_t*)argp) {
   19138:	e0bfff17 	ldw	r2,-4(fp)
   1913c:	10000526 	beq	r2,zero,19154 <lwip_ioctl+0x68>
   19140:	e0bfff17 	ldw	r2,-4(fp)
   19144:	10800017 	ldw	r2,0(r2)
   19148:	10000226 	beq	r2,zero,19154 <lwip_ioctl+0x68>
      val = 1;
   1914c:	00800044 	movi	r2,1
   19150:	e0bffb05 	stb	r2,-20(fp)
    }
    netconn_set_nonblocking(sock->conn, val);
   19154:	e0bffb03 	ldbu	r2,-20(fp)
   19158:	10000826 	beq	r2,zero,1917c <lwip_ioctl+0x90>
   1915c:	e0bffc17 	ldw	r2,-16(fp)
   19160:	10800017 	ldw	r2,0(r2)
   19164:	e0fffc17 	ldw	r3,-16(fp)
   19168:	18c00017 	ldw	r3,0(r3)
   1916c:	18c00903 	ldbu	r3,36(r3)
   19170:	18c00094 	ori	r3,r3,2
   19174:	10c00905 	stb	r3,36(r2)
   19178:	00000806 	br	1919c <lwip_ioctl+0xb0>
   1917c:	e0bffc17 	ldw	r2,-16(fp)
   19180:	10800017 	ldw	r2,0(r2)
   19184:	e0fffc17 	ldw	r3,-16(fp)
   19188:	18c00017 	ldw	r3,0(r3)
   1918c:	19000903 	ldbu	r4,36(r3)
   19190:	00ffff44 	movi	r3,-3
   19194:	20c6703a 	and	r3,r4,r3
   19198:	10c00905 	stb	r3,36(r2)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, val));
    sock_set_errno(sock, 0);
   1919c:	e0bffc17 	ldw	r2,-16(fp)
   191a0:	10000415 	stw	zero,16(r2)
    return 0;
   191a4:	0005883a 	mov	r2,zero
   191a8:	00000406 	br	191bc <lwip_ioctl+0xd0>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
   191ac:	e0bffc17 	ldw	r2,-16(fp)
   191b0:	00c01604 	movi	r3,88
   191b4:	10c00415 	stw	r3,16(r2)
    return -1;
   191b8:	00bfffc4 	movi	r2,-1
  } /* switch (cmd) */
}
   191bc:	e037883a 	mov	sp,fp
   191c0:	dfc00117 	ldw	ra,4(sp)
   191c4:	df000017 	ldw	fp,0(sp)
   191c8:	dec00204 	addi	sp,sp,8
   191cc:	f800283a 	ret

000191d0 <lwip_fcntl>:
 * Currently only the commands F_GETFL and F_SETFL are implemented.
 * Only the flag O_NONBLOCK is implemented.
 */
int
lwip_fcntl(int s, int cmd, int val)
{
   191d0:	defff904 	addi	sp,sp,-28
   191d4:	dfc00615 	stw	ra,24(sp)
   191d8:	df000515 	stw	fp,20(sp)
   191dc:	df000504 	addi	fp,sp,20
   191e0:	e13ffd15 	stw	r4,-12(fp)
   191e4:	e17ffe15 	stw	r5,-8(fp)
   191e8:	e1bfff15 	stw	r6,-4(fp)
  struct lwip_sock *sock = get_socket(s);
   191ec:	e13ffd17 	ldw	r4,-12(fp)
   191f0:	00160940 	call	16094 <get_socket>
   191f4:	e0bffc15 	stw	r2,-16(fp)
  int ret = -1;
   191f8:	00bfffc4 	movi	r2,-1
   191fc:	e0bffb15 	stw	r2,-20(fp)

  if (!sock || !sock->conn) {
   19200:	e0bffc17 	ldw	r2,-16(fp)
   19204:	10000326 	beq	r2,zero,19214 <lwip_fcntl+0x44>
   19208:	e0bffc17 	ldw	r2,-16(fp)
   1920c:	10800017 	ldw	r2,0(r2)
   19210:	1000021e 	bne	r2,zero,1921c <lwip_fcntl+0x4c>
    return -1;
   19214:	00bfffc4 	movi	r2,-1
   19218:	00002b06 	br	192c8 <lwip_fcntl+0xf8>
  }

  switch (cmd) {
   1921c:	e0bffe17 	ldw	r2,-8(fp)
   19220:	10c000e0 	cmpeqi	r3,r2,3
   19224:	1800031e 	bne	r3,zero,19234 <lwip_fcntl+0x64>
   19228:	10800120 	cmpeqi	r2,r2,4
   1922c:	10000a1e 	bne	r2,zero,19258 <lwip_fcntl+0x88>
   19230:	00002206 	br	192bc <lwip_fcntl+0xec>
  case F_GETFL:
    ret = netconn_is_nonblocking(sock->conn) ? O_NONBLOCK : 0;
   19234:	e0bffc17 	ldw	r2,-16(fp)
   19238:	10800017 	ldw	r2,0(r2)
   1923c:	10800903 	ldbu	r2,36(r2)
   19240:	10803fcc 	andi	r2,r2,255
   19244:	1080008c 	andi	r2,r2,2
   19248:	1004c03a 	cmpne	r2,r2,zero
   1924c:	10803fcc 	andi	r2,r2,255
   19250:	e0bffb15 	stw	r2,-20(fp)
    break;
   19254:	00001b06 	br	192c4 <lwip_fcntl+0xf4>
  case F_SETFL:
    if ((val & ~O_NONBLOCK) == 0) {
   19258:	e0ffff17 	ldw	r3,-4(fp)
   1925c:	00bfff84 	movi	r2,-2
   19260:	1884703a 	and	r2,r3,r2
   19264:	1000161e 	bne	r2,zero,192c0 <lwip_fcntl+0xf0>
      /* only O_NONBLOCK, all other bits are zero */
      netconn_set_nonblocking(sock->conn, val & O_NONBLOCK);
   19268:	e0bfff17 	ldw	r2,-4(fp)
   1926c:	1080004c 	andi	r2,r2,1
   19270:	10000826 	beq	r2,zero,19294 <lwip_fcntl+0xc4>
   19274:	e0bffc17 	ldw	r2,-16(fp)
   19278:	10800017 	ldw	r2,0(r2)
   1927c:	e0fffc17 	ldw	r3,-16(fp)
   19280:	18c00017 	ldw	r3,0(r3)
   19284:	18c00903 	ldbu	r3,36(r3)
   19288:	18c00094 	ori	r3,r3,2
   1928c:	10c00905 	stb	r3,36(r2)
   19290:	00000806 	br	192b4 <lwip_fcntl+0xe4>
   19294:	e0bffc17 	ldw	r2,-16(fp)
   19298:	10800017 	ldw	r2,0(r2)
   1929c:	e0fffc17 	ldw	r3,-16(fp)
   192a0:	18c00017 	ldw	r3,0(r3)
   192a4:	19000903 	ldbu	r4,36(r3)
   192a8:	00ffff44 	movi	r3,-3
   192ac:	20c6703a 	and	r3,r4,r3
   192b0:	10c00905 	stb	r3,36(r2)
      ret = 0;
   192b4:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
   192b8:	00000106 	br	192c0 <lwip_fcntl+0xf0>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_fcntl(%d, UNIMPL: %d, %d)\n", s, cmd, val));
    break;
   192bc:	00000106 	br	192c4 <lwip_fcntl+0xf4>
    if ((val & ~O_NONBLOCK) == 0) {
      /* only O_NONBLOCK, all other bits are zero */
      netconn_set_nonblocking(sock->conn, val & O_NONBLOCK);
      ret = 0;
    }
    break;
   192c0:	0001883a 	nop
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_fcntl(%d, UNIMPL: %d, %d)\n", s, cmd, val));
    break;
  }
  return ret;
   192c4:	e0bffb17 	ldw	r2,-20(fp)
}
   192c8:	e037883a 	mov	sp,fp
   192cc:	dfc00117 	ldw	ra,4(sp)
   192d0:	df000017 	ldw	fp,0(sp)
   192d4:	dec00204 	addi	sp,sp,8
   192d8:	f800283a 	ret

000192dc <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
   192dc:	defffc04 	addi	sp,sp,-16
   192e0:	dfc00315 	stw	ra,12(sp)
   192e4:	df000215 	stw	fp,8(sp)
   192e8:	df000204 	addi	fp,sp,8
   192ec:	e13fff15 	stw	r4,-4(fp)
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

  if (tcpip_init_done != NULL) {
   192f0:	d0a91c17 	ldw	r2,-23440(gp)
   192f4:	10000426 	beq	r2,zero,19308 <tcpip_thread+0x2c>
    tcpip_init_done(tcpip_init_done_arg);
   192f8:	d0e91c17 	ldw	r3,-23440(gp)
   192fc:	d0a91d17 	ldw	r2,-23436(gp)
   19300:	1009883a 	mov	r4,r2
   19304:	183ee83a 	callr	r3
  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    UNLOCK_TCPIP_CORE();
    LWIP_TCPIP_THREAD_ALIVE();
    /* wait for a message, timeouts are processed while waiting */
    sys_timeouts_mbox_fetch(&mbox, (void **)&msg);
   19308:	d1291e04 	addi	r4,gp,-23432
   1930c:	e17ffe04 	addi	r5,fp,-8
   19310:	002eb040 	call	2eb04 <sys_timeouts_mbox_fetch>
    LOCK_TCPIP_CORE();
    switch (msg->type) {
   19314:	e0bffe17 	ldw	r2,-8(fp)
   19318:	10800017 	ldw	r2,0(r2)
   1931c:	10c001a8 	cmpgeui	r3,r2,6
   19320:	18005c1e 	bne	r3,zero,19494 <tcpip_thread+0x1b8>
   19324:	1085883a 	add	r2,r2,r2
   19328:	1087883a 	add	r3,r2,r2
   1932c:	008000b4 	movhi	r2,2
   19330:	10a4d004 	addi	r2,r2,-27840
   19334:	1885883a 	add	r2,r3,r2
   19338:	10800017 	ldw	r2,0(r2)
   1933c:	1000683a 	jmp	r2
   19340:	00019358 	cmpnei	zero,zero,1613
   19344:	0001937c 	xorhi	zero,zero,1613
   19348:	000193e4 	muli	zero,zero,1615
   1934c:	0001941c 	xori	zero,zero,1616
   19350:	0001944c 	andi	zero,zero,1617
   19354:	00019478 	rdprs	zero,zero,1617
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
   19358:	e0bffe17 	ldw	r2,-8(fp)
   1935c:	10800217 	ldw	r2,8(r2)
   19360:	10c00017 	ldw	r3,0(r2)
   19364:	e0bffe17 	ldw	r2,-8(fp)
   19368:	10800217 	ldw	r2,8(r2)
   1936c:	10800104 	addi	r2,r2,4
   19370:	1009883a 	mov	r4,r2
   19374:	183ee83a 	callr	r3
      break;
   19378:	00004706 	br	19498 <tcpip_thread+0x1bc>

#if !LWIP_TCPIP_CORE_LOCKING_INPUT
    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ETHERNET
      if (msg->msg.inp.netif->flags & (NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET)) {
   1937c:	e0bffe17 	ldw	r2,-8(fp)
   19380:	10800317 	ldw	r2,12(r2)
   19384:	10800e43 	ldbu	r2,57(r2)
   19388:	10803fcc 	andi	r2,r2,255
   1938c:	1080180c 	andi	r2,r2,96
   19390:	10000826 	beq	r2,zero,193b4 <tcpip_thread+0xd8>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
   19394:	e0bffe17 	ldw	r2,-8(fp)
   19398:	10c00217 	ldw	r3,8(r2)
   1939c:	e0bffe17 	ldw	r2,-8(fp)
   193a0:	10800317 	ldw	r2,12(r2)
   193a4:	1809883a 	mov	r4,r3
   193a8:	100b883a 	mov	r5,r2
   193ac:	00315100 	call	31510 <ethernet_input>
   193b0:	00000706 	br	193d0 <tcpip_thread+0xf4>
      } else
#endif /* LWIP_ETHERNET */
      {
        ip_input(msg->msg.inp.p, msg->msg.inp.netif);
   193b4:	e0bffe17 	ldw	r2,-8(fp)
   193b8:	10c00217 	ldw	r3,8(r2)
   193bc:	e0bffe17 	ldw	r2,-8(fp)
   193c0:	10800317 	ldw	r2,12(r2)
   193c4:	1809883a 	mov	r4,r3
   193c8:	100b883a 	mov	r5,r2
   193cc:	001edc40 	call	1edc4 <ip_input>
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
   193d0:	e0bffe17 	ldw	r2,-8(fp)
   193d4:	01000284 	movi	r4,10
   193d8:	100b883a 	mov	r5,r2
   193dc:	00225900 	call	22590 <memp_free>
      break;
   193e0:	00002d06 	br	19498 <tcpip_thread+0x1bc>
#endif /* LWIP_NETIF_API */

#if LWIP_TCPIP_TIMEOUT
    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));
      sys_timeout(msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
   193e4:	e0bffe17 	ldw	r2,-8(fp)
   193e8:	11000217 	ldw	r4,8(r2)
   193ec:	e0bffe17 	ldw	r2,-8(fp)
   193f0:	10c00317 	ldw	r3,12(r2)
   193f4:	e0bffe17 	ldw	r2,-8(fp)
   193f8:	10800417 	ldw	r2,16(r2)
   193fc:	180b883a 	mov	r5,r3
   19400:	100d883a 	mov	r6,r2
   19404:	002e8980 	call	2e898 <sys_timeout>
      memp_free(MEMP_TCPIP_MSG_API, msg);
   19408:	e0bffe17 	ldw	r2,-8(fp)
   1940c:	01000244 	movi	r4,9
   19410:	100b883a 	mov	r5,r2
   19414:	00225900 	call	22590 <memp_free>
      break;
   19418:	00001f06 	br	19498 <tcpip_thread+0x1bc>
    case TCPIP_MSG_UNTIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: UNTIMEOUT %p\n", (void *)msg));
      sys_untimeout(msg->msg.tmo.h, msg->msg.tmo.arg);
   1941c:	e0bffe17 	ldw	r2,-8(fp)
   19420:	10c00317 	ldw	r3,12(r2)
   19424:	e0bffe17 	ldw	r2,-8(fp)
   19428:	10800417 	ldw	r2,16(r2)
   1942c:	1809883a 	mov	r4,r3
   19430:	100b883a 	mov	r5,r2
   19434:	002ea140 	call	2ea14 <sys_untimeout>
      memp_free(MEMP_TCPIP_MSG_API, msg);
   19438:	e0bffe17 	ldw	r2,-8(fp)
   1943c:	01000244 	movi	r4,9
   19440:	100b883a 	mov	r5,r2
   19444:	00225900 	call	22590 <memp_free>
      break;
   19448:	00001306 	br	19498 <tcpip_thread+0x1bc>
#endif /* LWIP_TCPIP_TIMEOUT */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.function(msg->msg.cb.ctx);
   1944c:	e0bffe17 	ldw	r2,-8(fp)
   19450:	10c00217 	ldw	r3,8(r2)
   19454:	e0bffe17 	ldw	r2,-8(fp)
   19458:	10800317 	ldw	r2,12(r2)
   1945c:	1009883a 	mov	r4,r2
   19460:	183ee83a 	callr	r3
      memp_free(MEMP_TCPIP_MSG_API, msg);
   19464:	e0bffe17 	ldw	r2,-8(fp)
   19468:	01000244 	movi	r4,9
   1946c:	100b883a 	mov	r5,r2
   19470:	00225900 	call	22590 <memp_free>
      break;
   19474:	00000806 	br	19498 <tcpip_thread+0x1bc>

    case TCPIP_MSG_CALLBACK_STATIC:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK_STATIC %p\n", (void *)msg));
      msg->msg.cb.function(msg->msg.cb.ctx);
   19478:	e0bffe17 	ldw	r2,-8(fp)
   1947c:	10c00217 	ldw	r3,8(r2)
   19480:	e0bffe17 	ldw	r2,-8(fp)
   19484:	10800317 	ldw	r2,12(r2)
   19488:	1009883a 	mov	r4,r2
   1948c:	183ee83a 	callr	r3
      break;
   19490:	00000106 	br	19498 <tcpip_thread+0x1bc>

    default:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: invalid message: %d\n", msg->type));
      LWIP_ASSERT("tcpip_thread: invalid message", 0);
      break;
   19494:	0001883a 	nop
    }
  }
   19498:	003f9b06 	br	19308 <tcpip_thread+0x2c>

0001949c <tcpip_input>:
 *          NETIF_FLAG_ETHERNET flags)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
   1949c:	defffb04 	addi	sp,sp,-20
   194a0:	dfc00415 	stw	ra,16(sp)
   194a4:	df000315 	stw	fp,12(sp)
   194a8:	df000304 	addi	fp,sp,12
   194ac:	e13ffe15 	stw	r4,-8(fp)
   194b0:	e17fff15 	stw	r5,-4(fp)
  UNLOCK_TCPIP_CORE();
  return ret;
#else /* LWIP_TCPIP_CORE_LOCKING_INPUT */
  struct tcpip_msg *msg;

  if (!sys_mbox_valid(&mbox)) {
   194b4:	d0a91e17 	ldw	r2,-23432(gp)
   194b8:	1000021e 	bne	r2,zero,194c4 <tcpip_input+0x28>
    return ERR_VAL;
   194bc:	00bffe84 	movi	r2,-6
   194c0:	00001d06 	br	19538 <tcpip_input+0x9c>
  }
  msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_INPKT);
   194c4:	01000284 	movi	r4,10
   194c8:	00223cc0 	call	223cc <memp_malloc>
   194cc:	e0bffd15 	stw	r2,-12(fp)
  if (msg == NULL) {
   194d0:	e0bffd17 	ldw	r2,-12(fp)
   194d4:	1000021e 	bne	r2,zero,194e0 <tcpip_input+0x44>
    return ERR_MEM;
   194d8:	00bfffc4 	movi	r2,-1
   194dc:	00001606 	br	19538 <tcpip_input+0x9c>
  }

  msg->type = TCPIP_MSG_INPKT;
   194e0:	e0bffd17 	ldw	r2,-12(fp)
   194e4:	00c00044 	movi	r3,1
   194e8:	10c00015 	stw	r3,0(r2)
  msg->msg.inp.p = p;
   194ec:	e0bffd17 	ldw	r2,-12(fp)
   194f0:	e0fffe17 	ldw	r3,-8(fp)
   194f4:	10c00215 	stw	r3,8(r2)
  msg->msg.inp.netif = inp;
   194f8:	e0bffd17 	ldw	r2,-12(fp)
   194fc:	e0ffff17 	ldw	r3,-4(fp)
   19500:	10c00315 	stw	r3,12(r2)
  if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
   19504:	d1291e04 	addi	r4,gp,-23432
   19508:	e17ffd17 	ldw	r5,-12(fp)
   1950c:	001b7480 	call	1b748 <sys_mbox_trypost>
   19510:	10803fcc 	andi	r2,r2,255
   19514:	1080201c 	xori	r2,r2,128
   19518:	10bfe004 	addi	r2,r2,-128
   1951c:	10000526 	beq	r2,zero,19534 <tcpip_input+0x98>
    memp_free(MEMP_TCPIP_MSG_INPKT, msg);
   19520:	01000284 	movi	r4,10
   19524:	e17ffd17 	ldw	r5,-12(fp)
   19528:	00225900 	call	22590 <memp_free>
    return ERR_MEM;
   1952c:	00bfffc4 	movi	r2,-1
   19530:	00000106 	br	19538 <tcpip_input+0x9c>
  }
  return ERR_OK;
   19534:	0005883a 	mov	r2,zero
#endif /* LWIP_TCPIP_CORE_LOCKING_INPUT */
}
   19538:	e037883a 	mov	sp,fp
   1953c:	dfc00117 	ldw	ra,4(sp)
   19540:	df000017 	ldw	fp,0(sp)
   19544:	dec00204 	addi	sp,sp,8
   19548:	f800283a 	ret

0001954c <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(tcpip_callback_fn function, void *ctx, u8_t block)
{
   1954c:	defffa04 	addi	sp,sp,-24
   19550:	dfc00515 	stw	ra,20(sp)
   19554:	df000415 	stw	fp,16(sp)
   19558:	df000404 	addi	fp,sp,16
   1955c:	e13ffd15 	stw	r4,-12(fp)
   19560:	e17ffe15 	stw	r5,-8(fp)
   19564:	3005883a 	mov	r2,r6
   19568:	e0bfff05 	stb	r2,-4(fp)
  struct tcpip_msg *msg;

  if (sys_mbox_valid(&mbox)) {
   1956c:	d0a91e17 	ldw	r2,-23432(gp)
   19570:	10002426 	beq	r2,zero,19604 <tcpip_callback_with_block+0xb8>
    msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
   19574:	01000244 	movi	r4,9
   19578:	00223cc0 	call	223cc <memp_malloc>
   1957c:	e0bffc15 	stw	r2,-16(fp)
    if (msg == NULL) {
   19580:	e0bffc17 	ldw	r2,-16(fp)
   19584:	1000021e 	bne	r2,zero,19590 <tcpip_callback_with_block+0x44>
      return ERR_MEM;
   19588:	00bfffc4 	movi	r2,-1
   1958c:	00001e06 	br	19608 <tcpip_callback_with_block+0xbc>
    }

    msg->type = TCPIP_MSG_CALLBACK;
   19590:	e0bffc17 	ldw	r2,-16(fp)
   19594:	00c00104 	movi	r3,4
   19598:	10c00015 	stw	r3,0(r2)
    msg->msg.cb.function = function;
   1959c:	e0bffc17 	ldw	r2,-16(fp)
   195a0:	e0fffd17 	ldw	r3,-12(fp)
   195a4:	10c00215 	stw	r3,8(r2)
    msg->msg.cb.ctx = ctx;
   195a8:	e0bffc17 	ldw	r2,-16(fp)
   195ac:	e0fffe17 	ldw	r3,-8(fp)
   195b0:	10c00315 	stw	r3,12(r2)
    if (block) {
   195b4:	e0bfff03 	ldbu	r2,-4(fp)
   195b8:	10000426 	beq	r2,zero,195cc <tcpip_callback_with_block+0x80>
      sys_mbox_post(&mbox, msg);
   195bc:	d1291e04 	addi	r4,gp,-23432
   195c0:	e17ffc17 	ldw	r5,-16(fp)
   195c4:	001b6fc0 	call	1b6fc <sys_mbox_post>
   195c8:	00000c06 	br	195fc <tcpip_callback_with_block+0xb0>
    } else {
      if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
   195cc:	d1291e04 	addi	r4,gp,-23432
   195d0:	e17ffc17 	ldw	r5,-16(fp)
   195d4:	001b7480 	call	1b748 <sys_mbox_trypost>
   195d8:	10803fcc 	andi	r2,r2,255
   195dc:	1080201c 	xori	r2,r2,128
   195e0:	10bfe004 	addi	r2,r2,-128
   195e4:	10000526 	beq	r2,zero,195fc <tcpip_callback_with_block+0xb0>
        memp_free(MEMP_TCPIP_MSG_API, msg);
   195e8:	01000244 	movi	r4,9
   195ec:	e17ffc17 	ldw	r5,-16(fp)
   195f0:	00225900 	call	22590 <memp_free>
        return ERR_MEM;
   195f4:	00bfffc4 	movi	r2,-1
   195f8:	00000306 	br	19608 <tcpip_callback_with_block+0xbc>
      }
    }
    return ERR_OK;
   195fc:	0005883a 	mov	r2,zero
   19600:	00000106 	br	19608 <tcpip_callback_with_block+0xbc>
  }
  return ERR_VAL;
   19604:	00bffe84 	movi	r2,-6
}
   19608:	e037883a 	mov	sp,fp
   1960c:	dfc00117 	ldw	ra,4(sp)
   19610:	df000017 	ldw	fp,0(sp)
   19614:	dec00204 	addi	sp,sp,8
   19618:	f800283a 	ret

0001961c <tcpip_timeout>:
 * @param arg argument to pass to timeout function h
 * @return ERR_MEM on memory error, ERR_OK otherwise
 */
err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
   1961c:	defffa04 	addi	sp,sp,-24
   19620:	dfc00515 	stw	ra,20(sp)
   19624:	df000415 	stw	fp,16(sp)
   19628:	df000404 	addi	fp,sp,16
   1962c:	e13ffd15 	stw	r4,-12(fp)
   19630:	e17ffe15 	stw	r5,-8(fp)
   19634:	e1bfff15 	stw	r6,-4(fp)
  struct tcpip_msg *msg;

  if (sys_mbox_valid(&mbox)) {
   19638:	d0a91e17 	ldw	r2,-23432(gp)
   1963c:	10001826 	beq	r2,zero,196a0 <tcpip_timeout+0x84>
    msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
   19640:	01000244 	movi	r4,9
   19644:	00223cc0 	call	223cc <memp_malloc>
   19648:	e0bffc15 	stw	r2,-16(fp)
    if (msg == NULL) {
   1964c:	e0bffc17 	ldw	r2,-16(fp)
   19650:	1000021e 	bne	r2,zero,1965c <tcpip_timeout+0x40>
      return ERR_MEM;
   19654:	00bfffc4 	movi	r2,-1
   19658:	00001206 	br	196a4 <tcpip_timeout+0x88>
    }

    msg->type = TCPIP_MSG_TIMEOUT;
   1965c:	e0bffc17 	ldw	r2,-16(fp)
   19660:	00c00084 	movi	r3,2
   19664:	10c00015 	stw	r3,0(r2)
    msg->msg.tmo.msecs = msecs;
   19668:	e0bffc17 	ldw	r2,-16(fp)
   1966c:	e0fffd17 	ldw	r3,-12(fp)
   19670:	10c00215 	stw	r3,8(r2)
    msg->msg.tmo.h = h;
   19674:	e0bffc17 	ldw	r2,-16(fp)
   19678:	e0fffe17 	ldw	r3,-8(fp)
   1967c:	10c00315 	stw	r3,12(r2)
    msg->msg.tmo.arg = arg;
   19680:	e0bffc17 	ldw	r2,-16(fp)
   19684:	e0ffff17 	ldw	r3,-4(fp)
   19688:	10c00415 	stw	r3,16(r2)
    sys_mbox_post(&mbox, msg);
   1968c:	d1291e04 	addi	r4,gp,-23432
   19690:	e17ffc17 	ldw	r5,-16(fp)
   19694:	001b6fc0 	call	1b6fc <sys_mbox_post>
    return ERR_OK;
   19698:	0005883a 	mov	r2,zero
   1969c:	00000106 	br	196a4 <tcpip_timeout+0x88>
  }
  return ERR_VAL;
   196a0:	00bffe84 	movi	r2,-6
}
   196a4:	e037883a 	mov	sp,fp
   196a8:	dfc00117 	ldw	ra,4(sp)
   196ac:	df000017 	ldw	fp,0(sp)
   196b0:	dec00204 	addi	sp,sp,8
   196b4:	f800283a 	ret

000196b8 <tcpip_untimeout>:
 * @param arg argument to pass to timeout function h
 * @return ERR_MEM on memory error, ERR_OK otherwise
 */
err_t
tcpip_untimeout(sys_timeout_handler h, void *arg)
{
   196b8:	defffb04 	addi	sp,sp,-20
   196bc:	dfc00415 	stw	ra,16(sp)
   196c0:	df000315 	stw	fp,12(sp)
   196c4:	df000304 	addi	fp,sp,12
   196c8:	e13ffe15 	stw	r4,-8(fp)
   196cc:	e17fff15 	stw	r5,-4(fp)
  struct tcpip_msg *msg;

  if (sys_mbox_valid(&mbox)) {
   196d0:	d0a91e17 	ldw	r2,-23432(gp)
   196d4:	10001526 	beq	r2,zero,1972c <tcpip_untimeout+0x74>
    msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
   196d8:	01000244 	movi	r4,9
   196dc:	00223cc0 	call	223cc <memp_malloc>
   196e0:	e0bffd15 	stw	r2,-12(fp)
    if (msg == NULL) {
   196e4:	e0bffd17 	ldw	r2,-12(fp)
   196e8:	1000021e 	bne	r2,zero,196f4 <tcpip_untimeout+0x3c>
      return ERR_MEM;
   196ec:	00bfffc4 	movi	r2,-1
   196f0:	00000f06 	br	19730 <tcpip_untimeout+0x78>
    }

    msg->type = TCPIP_MSG_UNTIMEOUT;
   196f4:	e0bffd17 	ldw	r2,-12(fp)
   196f8:	00c000c4 	movi	r3,3
   196fc:	10c00015 	stw	r3,0(r2)
    msg->msg.tmo.h = h;
   19700:	e0bffd17 	ldw	r2,-12(fp)
   19704:	e0fffe17 	ldw	r3,-8(fp)
   19708:	10c00315 	stw	r3,12(r2)
    msg->msg.tmo.arg = arg;
   1970c:	e0bffd17 	ldw	r2,-12(fp)
   19710:	e0ffff17 	ldw	r3,-4(fp)
   19714:	10c00415 	stw	r3,16(r2)
    sys_mbox_post(&mbox, msg);
   19718:	d1291e04 	addi	r4,gp,-23432
   1971c:	e17ffd17 	ldw	r5,-12(fp)
   19720:	001b6fc0 	call	1b6fc <sys_mbox_post>
    return ERR_OK;
   19724:	0005883a 	mov	r2,zero
   19728:	00000106 	br	19730 <tcpip_untimeout+0x78>
  }
  return ERR_VAL;
   1972c:	00bffe84 	movi	r2,-6
}
   19730:	e037883a 	mov	sp,fp
   19734:	dfc00117 	ldw	ra,4(sp)
   19738:	df000017 	ldw	fp,0(sp)
   1973c:	dec00204 	addi	sp,sp,8
   19740:	f800283a 	ret

00019744 <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
   19744:	defff804 	addi	sp,sp,-32
   19748:	dfc00715 	stw	ra,28(sp)
   1974c:	df000615 	stw	fp,24(sp)
   19750:	df000604 	addi	fp,sp,24
   19754:	e13fff15 	stw	r4,-4(fp)
#ifdef LWIP_DEBUG
  /* catch functions that don't set err */
  apimsg->msg.err = ERR_VAL;
#endif
  
  if (sys_mbox_valid(&mbox)) {
   19758:	d0a91e17 	ldw	r2,-23432(gp)
   1975c:	10000f26 	beq	r2,zero,1979c <tcpip_apimsg+0x58>
    msg.type = TCPIP_MSG_API;
   19760:	e03ffa15 	stw	zero,-24(fp)
    msg.msg.apimsg = apimsg;
   19764:	e0bfff17 	ldw	r2,-4(fp)
   19768:	e0bffc15 	stw	r2,-16(fp)
    sys_mbox_post(&mbox, &msg);
   1976c:	d1291e04 	addi	r4,gp,-23432
   19770:	e17ffa04 	addi	r5,fp,-24
   19774:	001b6fc0 	call	1b6fc <sys_mbox_post>
    sys_arch_sem_wait(&apimsg->msg.conn->op_completed, 0);
   19778:	e0bfff17 	ldw	r2,-4(fp)
   1977c:	10800117 	ldw	r2,4(r2)
   19780:	10800404 	addi	r2,r2,16
   19784:	1009883a 	mov	r4,r2
   19788:	000b883a 	mov	r5,zero
   1978c:	001b3340 	call	1b334 <sys_arch_sem_wait>
    return apimsg->msg.err;
   19790:	e0bfff17 	ldw	r2,-4(fp)
   19794:	10800203 	ldbu	r2,8(r2)
   19798:	00000106 	br	197a0 <tcpip_apimsg+0x5c>
  }
  return ERR_VAL;
   1979c:	00bffe84 	movi	r2,-6
}
   197a0:	e037883a 	mov	sp,fp
   197a4:	dfc00117 	ldw	ra,4(sp)
   197a8:	df000017 	ldw	fp,0(sp)
   197ac:	dec00204 	addi	sp,sp,8
   197b0:	f800283a 	ret

000197b4 <tcpip_callbackmsg_new>:
 * @param function the function to call
 * @param ctx parameter passed to function
 * @return a struct pointer to pass to tcpip_trycallback().
 */
struct tcpip_callback_msg* tcpip_callbackmsg_new(tcpip_callback_fn function, void *ctx)
{
   197b4:	defffb04 	addi	sp,sp,-20
   197b8:	dfc00415 	stw	ra,16(sp)
   197bc:	df000315 	stw	fp,12(sp)
   197c0:	df000304 	addi	fp,sp,12
   197c4:	e13ffe15 	stw	r4,-8(fp)
   197c8:	e17fff15 	stw	r5,-4(fp)
  struct tcpip_msg *msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
   197cc:	01000244 	movi	r4,9
   197d0:	00223cc0 	call	223cc <memp_malloc>
   197d4:	e0bffd15 	stw	r2,-12(fp)
  if (msg == NULL) {
   197d8:	e0bffd17 	ldw	r2,-12(fp)
   197dc:	1000021e 	bne	r2,zero,197e8 <tcpip_callbackmsg_new+0x34>
    return NULL;
   197e0:	0005883a 	mov	r2,zero
   197e4:	00000a06 	br	19810 <tcpip_callbackmsg_new+0x5c>
  }
  msg->type = TCPIP_MSG_CALLBACK_STATIC;
   197e8:	e0bffd17 	ldw	r2,-12(fp)
   197ec:	00c00144 	movi	r3,5
   197f0:	10c00015 	stw	r3,0(r2)
  msg->msg.cb.function = function;
   197f4:	e0bffd17 	ldw	r2,-12(fp)
   197f8:	e0fffe17 	ldw	r3,-8(fp)
   197fc:	10c00215 	stw	r3,8(r2)
  msg->msg.cb.ctx = ctx;
   19800:	e0bffd17 	ldw	r2,-12(fp)
   19804:	e0ffff17 	ldw	r3,-4(fp)
   19808:	10c00315 	stw	r3,12(r2)
  return (struct tcpip_callback_msg*)msg;
   1980c:	e0bffd17 	ldw	r2,-12(fp)
}
   19810:	e037883a 	mov	sp,fp
   19814:	dfc00117 	ldw	ra,4(sp)
   19818:	df000017 	ldw	fp,0(sp)
   1981c:	dec00204 	addi	sp,sp,8
   19820:	f800283a 	ret

00019824 <tcpip_callbackmsg_delete>:
 * Free a callback message allocated by tcpip_callbackmsg_new().
 *
 * @param msg the message to free
 */
void tcpip_callbackmsg_delete(struct tcpip_callback_msg* msg)
{
   19824:	defffd04 	addi	sp,sp,-12
   19828:	dfc00215 	stw	ra,8(sp)
   1982c:	df000115 	stw	fp,4(sp)
   19830:	df000104 	addi	fp,sp,4
   19834:	e13fff15 	stw	r4,-4(fp)
  memp_free(MEMP_TCPIP_MSG_API, msg);
   19838:	01000244 	movi	r4,9
   1983c:	e17fff17 	ldw	r5,-4(fp)
   19840:	00225900 	call	22590 <memp_free>
}
   19844:	e037883a 	mov	sp,fp
   19848:	dfc00117 	ldw	ra,4(sp)
   1984c:	df000017 	ldw	fp,0(sp)
   19850:	dec00204 	addi	sp,sp,8
   19854:	f800283a 	ret

00019858 <tcpip_trycallback>:
 * @param msg pointer to the message to post
 * @return sys_mbox_trypost() return code
 */
err_t
tcpip_trycallback(struct tcpip_callback_msg* msg)
{
   19858:	defffd04 	addi	sp,sp,-12
   1985c:	dfc00215 	stw	ra,8(sp)
   19860:	df000115 	stw	fp,4(sp)
   19864:	df000104 	addi	fp,sp,4
   19868:	e13fff15 	stw	r4,-4(fp)
  if (!sys_mbox_valid(&mbox)) {
   1986c:	d0a91e17 	ldw	r2,-23432(gp)
   19870:	1000021e 	bne	r2,zero,1987c <tcpip_trycallback+0x24>
    return ERR_VAL;
   19874:	00bffe84 	movi	r2,-6
   19878:	00000306 	br	19888 <tcpip_trycallback+0x30>
  }
  return sys_mbox_trypost(&mbox, msg);
   1987c:	d1291e04 	addi	r4,gp,-23432
   19880:	e17fff17 	ldw	r5,-4(fp)
   19884:	001b7480 	call	1b748 <sys_mbox_trypost>
}
   19888:	e037883a 	mov	sp,fp
   1988c:	dfc00117 	ldw	ra,4(sp)
   19890:	df000017 	ldw	fp,0(sp)
   19894:	dec00204 	addi	sp,sp,8
   19898:	f800283a 	ret

0001989c <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(tcpip_init_done_fn initfunc, void *arg)
{
   1989c:	defffb04 	addi	sp,sp,-20
   198a0:	dfc00415 	stw	ra,16(sp)
   198a4:	df000315 	stw	fp,12(sp)
   198a8:	df000304 	addi	fp,sp,12
   198ac:	e13ffe15 	stw	r4,-8(fp)
   198b0:	e17fff15 	stw	r5,-4(fp)
  lwip_init();
   198b4:	001ec6c0 	call	1ec6c <lwip_init>

  tcpip_init_done = initfunc;
   198b8:	e0bffe17 	ldw	r2,-8(fp)
   198bc:	d0a91c15 	stw	r2,-23440(gp)
  tcpip_init_done_arg = arg;
   198c0:	e0bfff17 	ldw	r2,-4(fp)
   198c4:	d0a91d15 	stw	r2,-23436(gp)
  if(sys_mbox_new(&mbox, TCPIP_MBOX_SIZE) != ERR_OK) {
   198c8:	d1291e04 	addi	r4,gp,-23432
   198cc:	01440004 	movi	r5,4096
   198d0:	001b5c40 	call	1b5c4 <sys_mbox_new>
  if(sys_mutex_new(&lock_tcpip_core) != ERR_OK) {
    LWIP_ASSERT("failed to create lock_tcpip_core", 0);
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
   198d4:	008000c4 	movi	r2,3
   198d8:	d8800015 	stw	r2,0(sp)
   198dc:	01000134 	movhi	r4,4
   198e0:	2103ad04 	addi	r4,r4,3764
   198e4:	014000b4 	movhi	r5,2
   198e8:	2964b704 	addi	r5,r5,-27940
   198ec:	000d883a 	mov	r6,zero
   198f0:	01c80004 	movi	r7,8192
   198f4:	001b91c0 	call	1b91c <sys_thread_new>
}
   198f8:	e037883a 	mov	sp,fp
   198fc:	dfc00117 	ldw	ra,4(sp)
   19900:	df000017 	ldw	fp,0(sp)
   19904:	dec00204 	addi	sp,sp,8
   19908:	f800283a 	ret

0001990c <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
   1990c:	defffc04 	addi	sp,sp,-16
   19910:	dfc00315 	stw	ra,12(sp)
   19914:	df000215 	stw	fp,8(sp)
   19918:	df000204 	addi	fp,sp,8
   1991c:	e13fff15 	stw	r4,-4(fp)
  struct pbuf *q = (struct pbuf *)p;
   19920:	e0bfff17 	ldw	r2,-4(fp)
   19924:	e0bffe15 	stw	r2,-8(fp)
  pbuf_free(q);
   19928:	e13ffe17 	ldw	r4,-8(fp)
   1992c:	00237600 	call	23760 <pbuf_free>
}
   19930:	e037883a 	mov	sp,fp
   19934:	dfc00117 	ldw	ra,4(sp)
   19938:	df000017 	ldw	fp,0(sp)
   1993c:	dec00204 	addi	sp,sp,8
   19940:	f800283a 	ret

00019944 <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
   19944:	defffd04 	addi	sp,sp,-12
   19948:	dfc00215 	stw	ra,8(sp)
   1994c:	df000115 	stw	fp,4(sp)
   19950:	df000104 	addi	fp,sp,4
   19954:	e13fff15 	stw	r4,-4(fp)
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
   19958:	010000b4 	movhi	r4,2
   1995c:	21264304 	addi	r4,r4,-26356
   19960:	e17fff17 	ldw	r5,-4(fp)
   19964:	000d883a 	mov	r6,zero
   19968:	001954c0 	call	1954c <tcpip_callback_with_block>
}
   1996c:	e037883a 	mov	sp,fp
   19970:	dfc00117 	ldw	ra,4(sp)
   19974:	df000017 	ldw	fp,0(sp)
   19978:	dec00204 	addi	sp,sp,8
   1997c:	f800283a 	ret

00019980 <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
   19980:	defffd04 	addi	sp,sp,-12
   19984:	dfc00215 	stw	ra,8(sp)
   19988:	df000115 	stw	fp,4(sp)
   1998c:	df000104 	addi	fp,sp,4
   19990:	e13fff15 	stw	r4,-4(fp)
  return tcpip_callback_with_block(mem_free, m, 0);
   19994:	010000b4 	movhi	r4,2
   19998:	21069504 	addi	r4,r4,6740
   1999c:	e17fff17 	ldw	r5,-4(fp)
   199a0:	000d883a 	mov	r6,zero
   199a4:	001954c0 	call	1954c <tcpip_callback_with_block>
}
   199a8:	e037883a 	mov	sp,fp
   199ac:	dfc00117 	ldw	ra,4(sp)
   199b0:	df000017 	ldw	fp,0(sp)
   199b4:	dec00204 	addi	sp,sp,8
   199b8:	f800283a 	ret

000199bc <close>:
 * (for files and device drivers) or the InterNiche soclose() function for
 * sockets.
 */
 
int close (int fd)
{
   199bc:	defffd04 	addi	sp,sp,-12
   199c0:	dfc00215 	stw	ra,8(sp)
   199c4:	df000115 	stw	fp,4(sp)
   199c8:	df000104 	addi	fp,sp,4
   199cc:	e13fff15 	stw	r4,-4(fp)
	if (fd < ALT_MAX_FD)
   199d0:	e0bfff17 	ldw	r2,-4(fp)
   199d4:	10800808 	cmpgei	r2,r2,32
   199d8:	1000031e 	bne	r2,zero,199e8 <close+0x2c>
		return ALT_CLOSE (fd);
   199dc:	e13fff17 	ldw	r4,-4(fp)
   199e0:	003c6b40 	call	3c6b4 <alt_close>
   199e4:	00000206 	br	199f0 <close+0x34>
#if LWIP_SOCKET
	else
		return lwip_close((long) fd);
   199e8:	e13fff17 	ldw	r4,-4(fp)
   199ec:	00168100 	call	16810 <lwip_close>
#else
	else
		return -1;
#endif
}
   199f0:	e037883a 	mov	sp,fp
   199f4:	dfc00117 	ldw	ra,4(sp)
   199f8:	df000017 	ldw	fp,0(sp)
   199fc:	dec00204 	addi	sp,sp,8
   19a00:	f800283a 	ret

00019a04 <read>:
 * (for files and device drivers) or the InterNiche recvfrom() function for
 * sockets.
 */

int read (int fd, void *ptr, size_t len)
{
   19a04:	defff904 	addi	sp,sp,-28
   19a08:	dfc00615 	stw	ra,24(sp)
   19a0c:	df000515 	stw	fp,20(sp)
   19a10:	df000504 	addi	fp,sp,20
   19a14:	e13ffd15 	stw	r4,-12(fp)
   19a18:	e17ffe15 	stw	r5,-8(fp)
   19a1c:	e1bfff15 	stw	r6,-4(fp)
	if (fd < ALT_MAX_FD)
   19a20:	e0bffd17 	ldw	r2,-12(fp)
   19a24:	10800808 	cmpgei	r2,r2,32
   19a28:	1000051e 	bne	r2,zero,19a40 <read+0x3c>
		return ALT_READ (fd, ptr, len);
   19a2c:	e13ffd17 	ldw	r4,-12(fp)
   19a30:	e17ffe17 	ldw	r5,-8(fp)
   19a34:	e1bfff17 	ldw	r6,-4(fp)
   19a38:	003cf300 	call	3cf30 <alt_read>
   19a3c:	00000706 	br	19a5c <read+0x58>
#if LWIP_SOCKET
	else
		return recvfrom(fd, ptr, len, 0, NULL, NULL);
   19a40:	d8000015 	stw	zero,0(sp)
   19a44:	d8000115 	stw	zero,4(sp)
   19a48:	e13ffd17 	ldw	r4,-12(fp)
   19a4c:	e17ffe17 	ldw	r5,-8(fp)
   19a50:	e1bfff17 	ldw	r6,-4(fp)
   19a54:	000f883a 	mov	r7,zero
   19a58:	0016b240 	call	16b24 <lwip_recvfrom>
#else
	else
		return -1;
#endif
}
   19a5c:	e037883a 	mov	sp,fp
   19a60:	dfc00117 	ldw	ra,4(sp)
   19a64:	df000017 	ldw	fp,0(sp)
   19a68:	dec00204 	addi	sp,sp,8
   19a6c:	f800283a 	ret

00019a70 <write>:
 * This implementation vectors requests to either the HAL alt_write() function 
 * (for files and device drivers) or the InterNiche send() function for sockets.
 */

int write (int fd, const void *ptr, size_t len)
{
   19a70:	defffb04 	addi	sp,sp,-20
   19a74:	dfc00415 	stw	ra,16(sp)
   19a78:	df000315 	stw	fp,12(sp)
   19a7c:	df000304 	addi	fp,sp,12
   19a80:	e13ffd15 	stw	r4,-12(fp)
   19a84:	e17ffe15 	stw	r5,-8(fp)
   19a88:	e1bfff15 	stw	r6,-4(fp)
  if (fd < ALT_MAX_FD)
   19a8c:	e0bffd17 	ldw	r2,-12(fp)
   19a90:	10800808 	cmpgei	r2,r2,32
   19a94:	1000051e 	bne	r2,zero,19aac <write+0x3c>
    return ALT_WRITE(fd, ptr, len);
   19a98:	e13ffd17 	ldw	r4,-12(fp)
   19a9c:	e17ffe17 	ldw	r5,-8(fp)
   19aa0:	e1bfff17 	ldw	r6,-4(fp)
   19aa4:	003d2d00 	call	3d2d0 <alt_write>
   19aa8:	00000506 	br	19ac0 <write+0x50>
#if LWIP_SOCKET
  else
    return send (fd, (void*) ptr, len, 0);
   19aac:	e13ffd17 	ldw	r4,-12(fp)
   19ab0:	e17ffe17 	ldw	r5,-8(fp)
   19ab4:	e1bfff17 	ldw	r6,-4(fp)
   19ab8:	000f883a 	mov	r7,zero
   19abc:	00170940 	call	17094 <lwip_send>
#else
	else
		return -1;
#endif
}
   19ac0:	e037883a 	mov	sp,fp
   19ac4:	dfc00117 	ldw	ra,4(sp)
   19ac8:	df000017 	ldw	fp,0(sp)
   19acc:	dec00204 	addi	sp,sp,8
   19ad0:	f800283a 	ret

00019ad4 <lwip_initialize>:
}
#endif

// Function which initializes the LwIP TCP/IP stack
void lwip_initialize(int waitForAll)
{
   19ad4:	defffa04 	addi	sp,sp,-24
   19ad8:	dfc00515 	stw	ra,20(sp)
   19adc:	df000415 	stw	fp,16(sp)
   19ae0:	df000404 	addi	fp,sp,16
   19ae4:	e13fff15 	stw	r4,-4(fp)
	int idx;
	int upCount = 0;
   19ae8:	e03ffd15 	stw	zero,-12(fp)
	int activeCount = 0;
   19aec:	e03ffe15 	stw	zero,-8(fp)
		return;
	}
#endif

	// Initialize the TCP/IP stack and give our configuration function as callback
	tcpip_init(lwip_handle_interfaces, NULL);
   19af0:	010000b4 	movhi	r4,2
   19af4:	21271d04 	addi	r4,r4,-25484
   19af8:	000b883a 	mov	r5,zero
   19afc:	001989c0 	call	1989c <tcpip_init>

	for (idx = 0; idx < PHY_COUNT; ++idx)
   19b00:	e03ffc15 	stw	zero,-16(fp)
   19b04:	00000906 	br	19b2c <lwip_initialize+0x58>
		if (is_interface_active(idx))
   19b08:	e13ffc17 	ldw	r4,-16(fp)
   19b0c:	00031440 	call	3144 <is_interface_active>
   19b10:	10000326 	beq	r2,zero,19b20 <lwip_initialize+0x4c>
			++activeCount;
   19b14:	e0bffe17 	ldw	r2,-8(fp)
   19b18:	10800044 	addi	r2,r2,1
   19b1c:	e0bffe15 	stw	r2,-8(fp)
#endif

	// Initialize the TCP/IP stack and give our configuration function as callback
	tcpip_init(lwip_handle_interfaces, NULL);

	for (idx = 0; idx < PHY_COUNT; ++idx)
   19b20:	e0bffc17 	ldw	r2,-16(fp)
   19b24:	10800044 	addi	r2,r2,1
   19b28:	e0bffc15 	stw	r2,-16(fp)
   19b2c:	e0bffc17 	ldw	r2,-16(fp)
   19b30:	103ff516 	blt	r2,zero,19b08 <lwip_initialize+0x34>
		if (is_interface_active(idx))
			++activeCount;

	// Wait for the network to get up
	while ((waitForAll && activeCount != upCount) || (!waitForAll && !upCount))
   19b34:	00001d06 	br	19bac <lwip_initialize+0xd8>
	{
		for (idx = 0; idx < PHY_COUNT; ++idx)
   19b38:	e03ffc15 	stw	zero,-16(fp)
   19b3c:	00001706 	br	19b9c <lwip_initialize+0xc8>
		{
			if (is_interface_active(idx) && netif_is_up(&eth_tse[idx]))
   19b40:	e13ffc17 	ldw	r4,-16(fp)
   19b44:	00031440 	call	3144 <is_interface_active>
   19b48:	10001126 	beq	r2,zero,19b90 <lwip_initialize+0xbc>
   19b4c:	00c00134 	movhi	r3,4
   19b50:	18dee104 	addi	r3,r3,31620
   19b54:	e0bffc17 	ldw	r2,-16(fp)
   19b58:	10801124 	muli	r2,r2,68
   19b5c:	1885883a 	add	r2,r3,r2
   19b60:	10800e04 	addi	r2,r2,56
   19b64:	10800043 	ldbu	r2,1(r2)
   19b68:	10803fcc 	andi	r2,r2,255
   19b6c:	1080004c 	andi	r2,r2,1
   19b70:	10000726 	beq	r2,zero,19b90 <lwip_initialize+0xbc>
			{
				printf("[lwip_eth%d] up\r\n", idx);
   19b74:	01000134 	movhi	r4,4
   19b78:	2103b104 	addi	r4,r4,3780
   19b7c:	e17ffc17 	ldw	r5,-16(fp)
   19b80:	00044740 	call	4474 <printf>
				++upCount;
   19b84:	e0bffd17 	ldw	r2,-12(fp)
   19b88:	10800044 	addi	r2,r2,1
   19b8c:	e0bffd15 	stw	r2,-12(fp)
			++activeCount;

	// Wait for the network to get up
	while ((waitForAll && activeCount != upCount) || (!waitForAll && !upCount))
	{
		for (idx = 0; idx < PHY_COUNT; ++idx)
   19b90:	e0bffc17 	ldw	r2,-16(fp)
   19b94:	10800044 	addi	r2,r2,1
   19b98:	e0bffc15 	stw	r2,-16(fp)
   19b9c:	e0bffc17 	ldw	r2,-16(fp)
   19ba0:	103fe716 	blt	r2,zero,19b40 <lwip_initialize+0x6c>
				printf("[lwip_eth%d] up\r\n", idx);
				++upCount;
			}
		}

		mssleep(10);
   19ba4:	0109c404 	movi	r4,10000
   19ba8:	00124300 	call	12430 <usleep>
	for (idx = 0; idx < PHY_COUNT; ++idx)
		if (is_interface_active(idx))
			++activeCount;

	// Wait for the network to get up
	while ((waitForAll && activeCount != upCount) || (!waitForAll && !upCount))
   19bac:	e0bfff17 	ldw	r2,-4(fp)
   19bb0:	10000326 	beq	r2,zero,19bc0 <lwip_initialize+0xec>
   19bb4:	e0fffe17 	ldw	r3,-8(fp)
   19bb8:	e0bffd17 	ldw	r2,-12(fp)
   19bbc:	18bfde1e 	bne	r3,r2,19b38 <lwip_initialize+0x64>
   19bc0:	e0bfff17 	ldw	r2,-4(fp)
   19bc4:	1000021e 	bne	r2,zero,19bd0 <lwip_initialize+0xfc>
   19bc8:	e0bffd17 	ldw	r2,-12(fp)
   19bcc:	103fda26 	beq	r2,zero,19b38 <lwip_initialize+0x64>
			}
		}

		mssleep(10);
	}
}
   19bd0:	e037883a 	mov	sp,fp
   19bd4:	dfc00117 	ldw	ra,4(sp)
   19bd8:	df000017 	ldw	fp,0(sp)
   19bdc:	dec00204 	addi	sp,sp,8
   19be0:	f800283a 	ret

00019be4 <lwip_wait_for_an>:
#endif

#define MAX_RETRY_COUNT			3

int lwip_wait_for_an(int idx, struct ethernetif *ethernetif)
{
   19be4:	defffb04 	addi	sp,sp,-20
   19be8:	dfc00415 	stw	ra,16(sp)
   19bec:	df000315 	stw	fp,12(sp)
   19bf0:	df000304 	addi	fp,sp,12
   19bf4:	e13ffe15 	stw	r4,-8(fp)
   19bf8:	e17fff15 	stw	r5,-4(fp)
	int retryCount = MAX_RETRY_COUNT;
   19bfc:	008000c4 	movi	r2,3
   19c00:	e0bffd15 	stw	r2,-12(fp)

	while (ethernetif->link_alive != 1 && --retryCount) {
   19c04:	00000c06 	br	19c38 <lwip_wait_for_an+0x54>
		mssleep(100 * (MAX_RETRY_COUNT - retryCount));
   19c08:	e0fffd17 	ldw	r3,-12(fp)
   19c0c:	00bfffb4 	movhi	r2,65534
   19c10:	109e5804 	addi	r2,r2,31072
   19c14:	1887383a 	mul	r3,r3,r2
   19c18:	00800174 	movhi	r2,5
   19c1c:	10a4f804 	addi	r2,r2,-27680
   19c20:	1885883a 	add	r2,r3,r2
   19c24:	1009883a 	mov	r4,r2
   19c28:	00124300 	call	12430 <usleep>
		tse_mac_init(idx, ethernetif);
   19c2c:	e13ffe17 	ldw	r4,-8(fp)
   19c30:	e17fff17 	ldw	r5,-4(fp)
   19c34:	001a4840 	call	1a484 <tse_mac_init>

int lwip_wait_for_an(int idx, struct ethernetif *ethernetif)
{
	int retryCount = MAX_RETRY_COUNT;

	while (ethernetif->link_alive != 1 && --retryCount) {
   19c38:	e0bfff17 	ldw	r2,-4(fp)
   19c3c:	10800217 	ldw	r2,8(r2)
   19c40:	10800060 	cmpeqi	r2,r2,1
   19c44:	1000051e 	bne	r2,zero,19c5c <lwip_wait_for_an+0x78>
   19c48:	e0bffd17 	ldw	r2,-12(fp)
   19c4c:	10bfffc4 	addi	r2,r2,-1
   19c50:	e0bffd15 	stw	r2,-12(fp)
   19c54:	e0bffd17 	ldw	r2,-12(fp)
   19c58:	103feb1e 	bne	r2,zero,19c08 <lwip_wait_for_an+0x24>
		mssleep(100 * (MAX_RETRY_COUNT - retryCount));
		tse_mac_init(idx, ethernetif);
	}

	return retryCount;
   19c5c:	e0bffd17 	ldw	r2,-12(fp)
}
   19c60:	e037883a 	mov	sp,fp
   19c64:	dfc00117 	ldw	ra,4(sp)
   19c68:	df000017 	ldw	fp,0(sp)
   19c6c:	dec00204 	addi	sp,sp,8
   19c70:	f800283a 	ret

00019c74 <lwip_handle_interfaces>:

void lwip_handle_interfaces(__unused void *params)
{
   19c74:	deffe904 	addi	sp,sp,-92
   19c78:	dfc01615 	stw	ra,88(sp)
   19c7c:	df001515 	stw	fp,84(sp)
   19c80:	df001504 	addi	fp,sp,84
   19c84:	e13fff15 	stw	r4,-4(fp)
	int idx;
	int active_macs = 0;
   19c88:	e03fef15 	stw	zero,-68(fp)
	char tmpbuf[OS_MAX_TASK_NAME_LEN];

	ip_addr_t ip = {0}, subnet = {0}, gateway = {0};
   19c8c:	e03ffb15 	stw	zero,-20(fp)
   19c90:	e03ffc15 	stw	zero,-16(fp)
   19c94:	e03ffd15 	stw	zero,-12(fp)
	int dhcp;

	for (idx = 0; idx < PHY_COUNT; ++idx)
   19c98:	e03fee15 	stw	zero,-72(fp)
   19c9c:	00008206 	br	19ea8 <lwip_handle_interfaces+0x234>
	{
		struct netif *eth = &eth_tse[idx];
   19ca0:	e0bfee17 	ldw	r2,-72(fp)
   19ca4:	10c01124 	muli	r3,r2,68
   19ca8:	00800134 	movhi	r2,4
   19cac:	109ee104 	addi	r2,r2,31620
   19cb0:	1885883a 	add	r2,r3,r2
   19cb4:	e0bff015 	stw	r2,-64(fp)

		// Load platform specific MAC address into netif
		if (get_mac_addr(idx, eth, eth->hwaddr) != EXIT_SUCCESS)
   19cb8:	e0bff017 	ldw	r2,-64(fp)
   19cbc:	10800cc4 	addi	r2,r2,51
   19cc0:	e13fee17 	ldw	r4,-72(fp)
   19cc4:	e17ff017 	ldw	r5,-64(fp)
   19cc8:	100d883a 	mov	r6,r2
   19ccc:	0002eec0 	call	2eec <get_mac_addr>
   19cd0:	10000326 	beq	r2,zero,19ce0 <lwip_handle_interfaces+0x6c>
			printf("[LwIP] Failed to get MAC address\n");
   19cd4:	01000134 	movhi	r4,4
   19cd8:	2103b604 	addi	r4,r4,3800
   19cdc:	00045340 	call	4534 <puts>

		// Get the requested IP configuration for the given interface
		if (get_ip_addr(idx, &ip, &subnet, &gateway, &dhcp) != EXIT_SUCCESS)
   19ce0:	e17ffb04 	addi	r5,fp,-20
   19ce4:	e0fffc04 	addi	r3,fp,-16
   19ce8:	e0bffd04 	addi	r2,fp,-12
   19cec:	e13ffe04 	addi	r4,fp,-8
   19cf0:	d9000015 	stw	r4,0(sp)
   19cf4:	e13fee17 	ldw	r4,-72(fp)
   19cf8:	180d883a 	mov	r6,r3
   19cfc:	100f883a 	mov	r7,r2
   19d00:	00030080 	call	3008 <get_ip_addr>
   19d04:	10000326 	beq	r2,zero,19d14 <lwip_handle_interfaces+0xa0>
			printf("[LwIP] Failed to get IP config\n");
   19d08:	01000134 	movhi	r4,4
   19d0c:	2103bf04 	addi	r4,r4,3836
   19d10:	00045340 	call	4534 <puts>

		//  Initialize lwIP, Altera TSE and the ethernetif
#if NO_SYS
		if (netif_add(eth, &ip, &subnet, &gateway, eth->state, ethernetif_init, ethernet_input) == NULL)
#else
			if (netif_add(eth, &ip, &subnet, &gateway, eth->state, ethernetif_init, tcpip_input) == NULL)
   19d14:	e0bff017 	ldw	r2,-64(fp)
   19d18:	11000917 	ldw	r4,36(r2)
   19d1c:	e17ffb04 	addi	r5,fp,-20
   19d20:	e0fffc04 	addi	r3,fp,-16
   19d24:	e0bffd04 	addi	r2,fp,-12
   19d28:	d9000015 	stw	r4,0(sp)
   19d2c:	01000134 	movhi	r4,4
   19d30:	2135a604 	addi	r4,r4,-10600
   19d34:	d9000115 	stw	r4,4(sp)
   19d38:	010000b4 	movhi	r4,2
   19d3c:	21252704 	addi	r4,r4,-27492
   19d40:	d9000215 	stw	r4,8(sp)
   19d44:	e13ff017 	ldw	r4,-64(fp)
   19d48:	180d883a 	mov	r6,r3
   19d4c:	100f883a 	mov	r7,r2
   19d50:	002268c0 	call	2268c <netif_add>
   19d54:	1000051e 	bne	r2,zero,19d6c <lwip_handle_interfaces+0xf8>
#endif
			{
				printf("[eth%d] Fatal error initializing...\n", idx);
   19d58:	01000134 	movhi	r4,4
   19d5c:	2103c704 	addi	r4,r4,3868
   19d60:	e17fee17 	ldw	r5,-72(fp)
   19d64:	00044740 	call	4474 <printf>
				for(;;) ;
   19d68:	003fff06 	br	19d68 <lwip_handle_interfaces+0xf4>
			}

		// check whether this interface should be used
		if (!is_interface_active(idx))
   19d6c:	e13fee17 	ldw	r4,-72(fp)
   19d70:	00031440 	call	3144 <is_interface_active>
   19d74:	10004826 	beq	r2,zero,19e98 <lwip_handle_interfaces+0x224>
			continue;

		// update the active phy count
		++active_macs;
   19d78:	e0bfef17 	ldw	r2,-68(fp)
   19d7c:	10800044 	addi	r2,r2,1
   19d80:	e0bfef15 	stw	r2,-68(fp)

		if (active_macs == 1)
   19d84:	e0bfef17 	ldw	r2,-68(fp)
   19d88:	10800058 	cmpnei	r2,r2,1
   19d8c:	1000021e 	bne	r2,zero,19d98 <lwip_handle_interfaces+0x124>
			netif_set_default(eth);
   19d90:	e13ff017 	ldw	r4,-64(fp)
   19d94:	0022b480 	call	22b48 <netif_set_default>

		// Set status and link callback (link is not working?)
		netif_set_status_callback(eth, lwip_status_callback);
   19d98:	e13ff017 	ldw	r4,-64(fp)
   19d9c:	014000b4 	movhi	r5,2
   19da0:	29689504 	addi	r5,r5,-23980
   19da4:	0022cac0 	call	22cac <netif_set_status_callback>

		if (link_callback)
   19da8:	d0a92017 	ldw	r2,-23424(gp)
   19dac:	10000426 	beq	r2,zero,19dc0 <lwip_handle_interfaces+0x14c>
			netif_set_link_callback(eth, link_callback);
   19db0:	d0a92017 	ldw	r2,-23424(gp)
   19db4:	e13ff017 	ldw	r4,-64(fp)
   19db8:	100b883a 	mov	r5,r2
   19dbc:	0022e180 	call	22e18 <netif_set_link_callback>

		// Initialize Altera TSE in a loop if waiting for a link
		printf("Waiting for link... ");
   19dc0:	01000134 	movhi	r4,4
   19dc4:	2103d104 	addi	r4,r4,3908
   19dc8:	00044740 	call	4474 <printf>
		if (lwip_wait_for_an(idx, eth->state) < 0) {
   19dcc:	e0bff017 	ldw	r2,-64(fp)
   19dd0:	10800917 	ldw	r2,36(r2)
   19dd4:	e13fee17 	ldw	r4,-72(fp)
   19dd8:	100b883a 	mov	r5,r2
   19ddc:	0019be40 	call	19be4 <lwip_wait_for_an>
   19de0:	1000040e 	bge	r2,zero,19df4 <lwip_handle_interfaces+0x180>
			printf("FAILED\n");
   19de4:	01000134 	movhi	r4,4
   19de8:	2103d704 	addi	r4,r4,3932
   19dec:	00045340 	call	4534 <puts>
			continue;
   19df0:	00002a06 	br	19e9c <lwip_handle_interfaces+0x228>
		}

		printf("OK\n");
   19df4:	01000134 	movhi	r4,4
   19df8:	2103d904 	addi	r4,r4,3940
   19dfc:	00045340 	call	4534 <puts>

		// create input output task and start DHCP or static w/e
		snprintf(tmpbuf, OS_MAX_TASK_NAME_LEN, "LwIP %*sih", 2, eth->name);
   19e00:	e0bff017 	ldw	r2,-64(fp)
   19e04:	10c00e84 	addi	r3,r2,58
   19e08:	e0bff104 	addi	r2,fp,-60
   19e0c:	d8c00015 	stw	r3,0(sp)
   19e10:	1009883a 	mov	r4,r2
   19e14:	01400a04 	movi	r5,40
   19e18:	01800134 	movhi	r6,4
   19e1c:	3183da04 	addi	r6,r6,3944
   19e20:	01c00084 	movi	r7,2
   19e24:	003f3440 	call	3f344 <snprintf>
		tmpbuf[(OS_MAX_TASK_NAME_LEN - 1)] = 0;
   19e28:	e03ffac5 	stb	zero,-21(fp)

		// create input task, this must be started before we can do any DHCP request
		if (sys_thread_new(tmpbuf, lwip_handle_ethernet_input, eth, KB(32), TCPIP_THREAD_PRIO) == NULL)
   19e2c:	e0bff104 	addi	r2,fp,-60
   19e30:	00c000c4 	movi	r3,3
   19e34:	d8c00015 	stw	r3,0(sp)
   19e38:	1009883a 	mov	r4,r2
   19e3c:	014000b4 	movhi	r5,2
   19e40:	29683204 	addi	r5,r5,-24376
   19e44:	e1bff017 	ldw	r6,-64(fp)
   19e48:	01e00014 	movui	r7,32768
   19e4c:	001b91c0 	call	1b91c <sys_thread_new>
   19e50:	1000031e 	bne	r2,zero,19e60 <lwip_handle_interfaces+0x1ec>
			printf("LwIP Couldn't create input / output task for ethernet\n");
   19e54:	01000134 	movhi	r4,4
   19e58:	2103dd04 	addi	r4,r4,3956
   19e5c:	00045340 	call	4534 <puts>

		// wait previous DHCP to finish
		if (dhcp) {
   19e60:	e0bffe17 	ldw	r2,-8(fp)
   19e64:	10000926 	beq	r2,zero,19e8c <lwip_handle_interfaces+0x218>
			printf("[LwIP] Start DHCP request...\n");
   19e68:	01000134 	movhi	r4,4
   19e6c:	2103eb04 	addi	r4,r4,4012
   19e70:	00045340 	call	4534 <puts>

			dhcp_start(eth);
   19e74:	e13ff017 	ldw	r4,-64(fp)
   19e78:	001c4d00 	call	1c4d0 <dhcp_start>

			// wait till we got our address
			printf("[LwIP] Waiting for DHCP IP address...\n");
   19e7c:	01000134 	movhi	r4,4
   19e80:	2103f304 	addi	r4,r4,4044
   19e84:	00045340 	call	4534 <puts>
   19e88:	00000406 	br	19e9c <lwip_handle_interfaces+0x228>
		} else {
			// the static IP has already been set, just bring up the interface
			netif_set_up(eth);
   19e8c:	e13ff017 	ldw	r4,-64(fp)
   19e90:	0022b700 	call	22b70 <netif_set_up>
   19e94:	00000106 	br	19e9c <lwip_handle_interfaces+0x228>
				for(;;) ;
			}

		// check whether this interface should be used
		if (!is_interface_active(idx))
			continue;
   19e98:	0001883a 	nop
	char tmpbuf[OS_MAX_TASK_NAME_LEN];

	ip_addr_t ip = {0}, subnet = {0}, gateway = {0};
	int dhcp;

	for (idx = 0; idx < PHY_COUNT; ++idx)
   19e9c:	e0bfee17 	ldw	r2,-72(fp)
   19ea0:	10800044 	addi	r2,r2,1
   19ea4:	e0bfee15 	stw	r2,-72(fp)
   19ea8:	e0bfee17 	ldw	r2,-72(fp)
   19eac:	103f7c16 	blt	r2,zero,19ca0 <lwip_handle_interfaces+0x2c>
		} else {
			// the static IP has already been set, just bring up the interface
			netif_set_up(eth);
		}
	}
}
   19eb0:	e037883a 	mov	sp,fp
   19eb4:	dfc00117 	ldw	ra,4(sp)
   19eb8:	df000017 	ldw	fp,0(sp)
   19ebc:	dec00204 	addi	sp,sp,8
   19ec0:	f800283a 	ret

00019ec4 <get_mac_count>:
 * \brief Get the number of MAC's available in the NIOS build
 *
 * \returns the number of MAC's in the NIOS build
 */
int get_mac_count(void)
{
   19ec4:	deffff04 	addi	sp,sp,-4
   19ec8:	df000015 	stw	fp,0(sp)
   19ecc:	d839883a 	mov	fp,sp
	return PHY_COUNT;
   19ed0:	0005883a 	mov	r2,zero
}
   19ed4:	e037883a 	mov	sp,fp
   19ed8:	df000017 	ldw	fp,0(sp)
   19edc:	dec00104 	addi	sp,sp,4
   19ee0:	f800283a 	ret

00019ee4 <get_mac_base>:
 * \param [in] idx the index of the MAC
 *
 * \returns the base address of the MAC
 */
volatile np_tse_mac* get_mac_base(int idx)
{
   19ee4:	defffe04 	addi	sp,sp,-8
   19ee8:	df000115 	stw	fp,4(sp)
   19eec:	df000104 	addi	fp,sp,4
   19ef0:	e13fff15 	stw	r4,-4(fp)
	if (idx > PHY_COUNT)
   19ef4:	e0bfff17 	ldw	r2,-4(fp)
   19ef8:	0080020e 	bge	zero,r2,19f04 <get_mac_base+0x20>
		return NULL;
   19efc:	0005883a 	mov	r2,zero
   19f00:	00000606 	br	19f1c <get_mac_base+0x38>

	return (volatile np_tse_mac*)tse_mac_device[idx].tse_mac_base;
   19f04:	00c00134 	movhi	r3,4
   19f08:	18d52c04 	addi	r3,r3,21680
   19f0c:	e0bfff17 	ldw	r2,-4(fp)
   19f10:	10801224 	muli	r2,r2,72
   19f14:	1885883a 	add	r2,r3,r2
   19f18:	10800017 	ldw	r2,0(r2)
}
   19f1c:	e037883a 	mov	sp,fp
   19f20:	df000017 	ldw	fp,0(sp)
   19f24:	dec00104 	addi	sp,sp,4
   19f28:	f800283a 	ret

00019f2c <get_netif>:
 * \brief Get the netif struct used by LwIP
 *
 * \return the reference to the netif used by LwIP
 */
struct netif* get_netif(int idx)
{
   19f2c:	defffe04 	addi	sp,sp,-8
   19f30:	df000115 	stw	fp,4(sp)
   19f34:	df000104 	addi	fp,sp,4
   19f38:	e13fff15 	stw	r4,-4(fp)
	if (idx > PHY_COUNT)
   19f3c:	e0bfff17 	ldw	r2,-4(fp)
   19f40:	0080020e 	bge	zero,r2,19f4c <get_netif+0x20>
		return NULL;
   19f44:	0005883a 	mov	r2,zero
   19f48:	00000506 	br	19f60 <get_netif+0x34>

	return eth_tse + idx;
   19f4c:	e0bfff17 	ldw	r2,-4(fp)
   19f50:	10c01124 	muli	r3,r2,68
   19f54:	00800134 	movhi	r2,4
   19f58:	109ee104 	addi	r2,r2,31620
   19f5c:	1885883a 	add	r2,r3,r2
}
   19f60:	e037883a 	mov	sp,fp
   19f64:	df000017 	ldw	fp,0(sp)
   19f68:	dec00104 	addi	sp,sp,4
   19f6c:	f800283a 	ret

00019f70 <lwip_set_status_callback>:

netif_status_callback_fn lwip_set_status_callback(netif_status_callback_fn callback)
{
   19f70:	defffd04 	addi	sp,sp,-12
   19f74:	df000215 	stw	fp,8(sp)
   19f78:	df000204 	addi	fp,sp,8
   19f7c:	e13fff15 	stw	r4,-4(fp)
	netif_status_callback_fn old = status_callback;
   19f80:	d0a91f17 	ldw	r2,-23428(gp)
   19f84:	e0bffe15 	stw	r2,-8(fp)

	status_callback = callback;
   19f88:	e0bfff17 	ldw	r2,-4(fp)
   19f8c:	d0a91f15 	stw	r2,-23428(gp)

	return old;
   19f90:	e0bffe17 	ldw	r2,-8(fp)
}
   19f94:	e037883a 	mov	sp,fp
   19f98:	df000017 	ldw	fp,0(sp)
   19f9c:	dec00104 	addi	sp,sp,4
   19fa0:	f800283a 	ret

00019fa4 <lwip_set_link_callback>:

netif_status_callback_fn lwip_set_link_callback(netif_status_callback_fn callback)
{
   19fa4:	defffd04 	addi	sp,sp,-12
   19fa8:	df000215 	stw	fp,8(sp)
   19fac:	df000204 	addi	fp,sp,8
   19fb0:	e13fff15 	stw	r4,-4(fp)
	netif_status_callback_fn old = link_callback;
   19fb4:	d0a92017 	ldw	r2,-23424(gp)
   19fb8:	e0bffe15 	stw	r2,-8(fp)

	link_callback = callback;
   19fbc:	e0bfff17 	ldw	r2,-4(fp)
   19fc0:	d0a92015 	stw	r2,-23424(gp)

	return old;
   19fc4:	e0bffe17 	ldw	r2,-8(fp)
}
   19fc8:	e037883a 	mov	sp,fp
   19fcc:	df000017 	ldw	fp,0(sp)
   19fd0:	dec00104 	addi	sp,sp,4
   19fd4:	f800283a 	ret

00019fd8 <lwip_is_interface_up>:

#define REG_STATS_LS					(1 << 2)	// Link Status

int __attribute__((weak)) lwip_is_interface_up(__unused np_tse_mac* pmac)
{
   19fd8:	defffd04 	addi	sp,sp,-12
   19fdc:	df000215 	stw	fp,8(sp)
   19fe0:	df000204 	addi	fp,sp,8
   19fe4:	e13fff15 	stw	r4,-4(fp)
	alt_u16 reg = IORD(&pmac->mdio1.STATUS, 0);
   19fe8:	e0bfff17 	ldw	r2,-4(fp)
   19fec:	1080a104 	addi	r2,r2,644
   19ff0:	10800037 	ldwio	r2,0(r2)
   19ff4:	e0bffe0d 	sth	r2,-8(fp)

	return ((reg & (REG_STATS_LS)) == REG_STATS_LS) ? ETH_INTERFACE_UP : ETH_INTERFACE_DOWN;
   19ff8:	e0bffe0b 	ldhu	r2,-8(fp)
   19ffc:	1080010c 	andi	r2,r2,4
   1a000:	1004c03a 	cmpne	r2,r2,zero
   1a004:	10803fcc 	andi	r2,r2,255
}
   1a008:	e037883a 	mov	sp,fp
   1a00c:	df000017 	ldw	fp,0(sp)
   1a010:	dec00104 	addi	sp,sp,4
   1a014:	f800283a 	ret

0001a018 <lwip_check_link_status>:

static void lwip_check_link_status(struct netif *netif, np_tse_mac* base)
{
   1a018:	defffa04 	addi	sp,sp,-24
   1a01c:	dfc00515 	stw	ra,20(sp)
   1a020:	df000415 	stw	fp,16(sp)
   1a024:	df000404 	addi	fp,sp,16
   1a028:	e13ffe15 	stw	r4,-8(fp)
   1a02c:	e17fff15 	stw	r5,-4(fp)
	struct ethernetif *ethif = (struct ethernetif*)netif->state;
   1a030:	e0bffe17 	ldw	r2,-8(fp)
   1a034:	10800917 	ldw	r2,36(r2)
   1a038:	e0bffc15 	stw	r2,-16(fp)

	// check if the interface is up
	int cur_status = lwip_is_interface_up(base);
   1a03c:	e13fff17 	ldw	r4,-4(fp)
   1a040:	0019fd80 	call	19fd8 <lwip_is_interface_up>
   1a044:	e0bffd15 	stw	r2,-12(fp)

	// is there a state change in the ethernet connectivity
	if (cur_status != ethif->current_state)
   1a048:	e0bffc17 	ldw	r2,-16(fp)
   1a04c:	10c01617 	ldw	r3,88(r2)
   1a050:	e0bffd17 	ldw	r2,-12(fp)
   1a054:	18801726 	beq	r3,r2,1a0b4 <lwip_check_link_status+0x9c>
	{
		// check if the Auto-Negotiate is successful
		if (cur_status == ETH_INTERFACE_UP)
   1a058:	e0bffd17 	ldw	r2,-12(fp)
   1a05c:	10800058 	cmpnei	r2,r2,1
   1a060:	10000d1e 	bne	r2,zero,1a098 <lwip_check_link_status+0x80>
		{
			// wait for auto-negotiate...
			if (lwip_wait_for_an(netif->num, ethif) > 0)
   1a064:	e0bffe17 	ldw	r2,-8(fp)
   1a068:	10800f03 	ldbu	r2,60(r2)
   1a06c:	10803fcc 	andi	r2,r2,255
   1a070:	1009883a 	mov	r4,r2
   1a074:	e17ffc17 	ldw	r5,-16(fp)
   1a078:	0019be40 	call	19be4 <lwip_wait_for_an>
   1a07c:	00800d0e 	bge	zero,r2,1a0b4 <lwip_check_link_status+0x9c>
			{
				netif_set_link_up(netif);
   1a080:	e13ffe17 	ldw	r4,-8(fp)
   1a084:	0022ce40 	call	22ce4 <netif_set_link_up>
				ethif->current_state = cur_status;
   1a088:	e0bffc17 	ldw	r2,-16(fp)
   1a08c:	e0fffd17 	ldw	r3,-12(fp)
   1a090:	10c01615 	stw	r3,88(r2)
   1a094:	00000706 	br	1a0b4 <lwip_check_link_status+0x9c>
			}
		}
		else
		{
			// bring down the link
			ethif->link_alive = 0;
   1a098:	e0bffc17 	ldw	r2,-16(fp)
   1a09c:	10000215 	stw	zero,8(r2)

			netif_set_link_down(netif);
   1a0a0:	e13ffe17 	ldw	r4,-8(fp)
   1a0a4:	0022da40 	call	22da4 <netif_set_link_down>
			ethif->current_state = cur_status;
   1a0a8:	e0bffc17 	ldw	r2,-16(fp)
   1a0ac:	e0fffd17 	ldw	r3,-12(fp)
   1a0b0:	10c01615 	stw	r3,88(r2)
		}
	}
}
   1a0b4:	e037883a 	mov	sp,fp
   1a0b8:	dfc00117 	ldw	ra,4(sp)
   1a0bc:	df000017 	ldw	fp,0(sp)
   1a0c0:	dec00204 	addi	sp,sp,8
   1a0c4:	f800283a 	ret

0001a0c8 <lwip_handle_ethernet_input>:

#define NR_TEST_PACKETS						50000

// Input / monitor task per ethernet device
static void lwip_handle_ethernet_input(void *pvParameters)
{
   1a0c8:	defe7104 	addi	sp,sp,-1596
   1a0cc:	dfc18e15 	stw	ra,1592(sp)
   1a0d0:	df018d15 	stw	fp,1588(sp)
   1a0d4:	df018d04 	addi	fp,sp,1588
   1a0d8:	e13fff15 	stw	r4,-4(fp)
	sys_sem_t rcvsem = NULL;
   1a0dc:	e03e7815 	stw	zero,-1568(fp)
	np_tse_mac* base = NULL;
   1a0e0:	e03e7415 	stw	zero,-1584(fp)
	struct netif *cur_netif = (struct netif*)pvParameters;
   1a0e4:	e0bfff17 	ldw	r2,-4(fp)
   1a0e8:	e0be7515 	stw	r2,-1580(fp)
	struct ethernetif *cur_ethif = (struct ethernetif*)cur_netif->state;
   1a0ec:	e0be7517 	ldw	r2,-1580(fp)
   1a0f0:	10800917 	ldw	r2,36(r2)
   1a0f4:	e0be7615 	stw	r2,-1576(fp)
	int packets_waiting = 0;
   1a0f8:	e03e7315 	stw	zero,-1588(fp)

	/* Intermediate buffers used for temporary copy of frames that cannot be directrly DMA'ed*/
	char buf2[1560]; // TODO remove
	int replug_state = 0; // TODO remove
   1a0fc:	e03e7715 	stw	zero,-1572(fp)

#if LWIP_RECEIVE_SEMAPHORE
	rcvsem = cur_ethif->tse_info->rx_semaphore;
   1a100:	e0be7617 	ldw	r2,-1576(fp)
   1a104:	10801717 	ldw	r2,92(r2)
   1a108:	10800817 	ldw	r2,32(r2)
   1a10c:	e0be7815 	stw	r2,-1568(fp)
#endif

	// get the actual MAC peripheral
	base = get_mac_base(cur_netif->num);
   1a110:	e0be7517 	ldw	r2,-1580(fp)
   1a114:	10800f03 	ldbu	r2,60(r2)
   1a118:	10803fcc 	andi	r2,r2,255
   1a11c:	1009883a 	mov	r4,r2
   1a120:	0019ee40 	call	19ee4 <get_mac_base>
   1a124:	e0be7415 	stw	r2,-1584(fp)
	if (!base)
   1a128:	e0be7417 	ldw	r2,-1584(fp)
   1a12c:	10001626 	beq	r2,zero,1a188 <lwip_handle_ethernet_input+0xc0>
   1a130:	00000106 	br	1a138 <lwip_handle_ethernet_input+0x70>
		packets_waiting = ethernetif_input(cur_netif);

		// check the link status if there are no packets waiting
		if (packets_waiting <= 0)
			lwip_check_link_status(cur_netif, base);
	}
   1a134:	0001883a 	nop
	// else we'll poll the function once every 100ms
		while (1) {
		// if we have a semaphore wait for it to be released by the SGDMA IRQ, or sleep for 1 ms
			// if we timeout also call ethernetif_input although most likely it would be useless
			// it is use full however to check the link status
		if (rcvsem)
   1a138:	e0be7817 	ldw	r2,-1568(fp)
   1a13c:	10000526 	beq	r2,zero,1a154 <lwip_handle_ethernet_input+0x8c>
			sys_arch_sem_wait(&rcvsem, 100);
   1a140:	e0be7804 	addi	r2,fp,-1568
   1a144:	1009883a 	mov	r4,r2
   1a148:	01401904 	movi	r5,100
   1a14c:	001b3340 	call	1b334 <sys_arch_sem_wait>
   1a150:	00000406 	br	1a164 <lwip_handle_ethernet_input+0x9c>
		else if (packets_waiting <= 0)	// only sleep if there are no packets waiting
   1a154:	e0be7317 	ldw	r2,-1588(fp)
   1a158:	00800216 	blt	zero,r2,1a164 <lwip_handle_ethernet_input+0x9c>
			mssleep(1);					// sleep a bit to be nice to the CPU
   1a15c:	0100fa04 	movi	r4,1000
   1a160:	00124300 	call	12430 <usleep>

			// Use semaphore or the timeout to call ethernet_input
			// this to avoid unnecessary load and faster responses ;)
		packets_waiting = ethernetif_input(cur_netif);
   1a164:	e13e7517 	ldw	r4,-1580(fp)
   1a168:	003d59c0 	call	3d59c <ethernetif_input>
   1a16c:	e0be7315 	stw	r2,-1588(fp)

		// check the link status if there are no packets waiting
		if (packets_waiting <= 0)
   1a170:	e0be7317 	ldw	r2,-1588(fp)
   1a174:	00bfef16 	blt	zero,r2,1a134 <lwip_handle_ethernet_input+0x6c>
			lwip_check_link_status(cur_netif, base);
   1a178:	e13e7517 	ldw	r4,-1580(fp)
   1a17c:	e17e7417 	ldw	r5,-1584(fp)
   1a180:	001a0180 	call	1a018 <lwip_check_link_status>
	}
   1a184:	003feb06 	br	1a134 <lwip_handle_ethernet_input+0x6c>
}
   1a188:	e037883a 	mov	sp,fp
   1a18c:	dfc00117 	ldw	ra,4(sp)
   1a190:	df000017 	ldw	fp,0(sp)
   1a194:	dec00204 	addi	sp,sp,8
   1a198:	f800283a 	ret

0001a19c <print_ipad>:

const char* print_ipad(alt_u32 ip, char* buf)
{
   1a19c:	defff704 	addi	sp,sp,-36
   1a1a0:	dfc00815 	stw	ra,32(sp)
   1a1a4:	df000715 	stw	fp,28(sp)
   1a1a8:	df000704 	addi	fp,sp,28
   1a1ac:	e13ffe15 	stw	r4,-8(fp)
   1a1b0:	e17fff15 	stw	r5,-4(fp)
	alt_u8 bip[4];
	alt_u32 idx = 0;
   1a1b4:	e03ffc15 	stw	zero,-16(fp)

	for (; idx < sizeof(bip); idx++) {
   1a1b8:	00000c06 	br	1a1ec <print_ipad+0x50>
		bip[idx] = ip & 0xFF;
   1a1bc:	e0bffe17 	ldw	r2,-8(fp)
   1a1c0:	1007883a 	mov	r3,r2
   1a1c4:	e13ffd04 	addi	r4,fp,-12
   1a1c8:	e0bffc17 	ldw	r2,-16(fp)
   1a1cc:	2085883a 	add	r2,r4,r2
   1a1d0:	10c00005 	stb	r3,0(r2)
		ip >>= 8;
   1a1d4:	e0bffe17 	ldw	r2,-8(fp)
   1a1d8:	1004d23a 	srli	r2,r2,8
   1a1dc:	e0bffe15 	stw	r2,-8(fp)
const char* print_ipad(alt_u32 ip, char* buf)
{
	alt_u8 bip[4];
	alt_u32 idx = 0;

	for (; idx < sizeof(bip); idx++) {
   1a1e0:	e0bffc17 	ldw	r2,-16(fp)
   1a1e4:	10800044 	addi	r2,r2,1
   1a1e8:	e0bffc15 	stw	r2,-16(fp)
   1a1ec:	e0bffc17 	ldw	r2,-16(fp)
   1a1f0:	10800130 	cmpltui	r2,r2,4
   1a1f4:	103ff11e 	bne	r2,zero,1a1bc <print_ipad+0x20>
		bip[idx] = ip & 0xFF;
		ip >>= 8;
	}

	snprintf(buf, 17, "%d.%d.%d.%d", bip[0], bip[1], bip[2], bip[3]);
   1a1f8:	e0bffd03 	ldbu	r2,-12(fp)
   1a1fc:	10803fcc 	andi	r2,r2,255
   1a200:	e0fffd43 	ldbu	r3,-11(fp)
   1a204:	19403fcc 	andi	r5,r3,255
   1a208:	e0fffd83 	ldbu	r3,-10(fp)
   1a20c:	19003fcc 	andi	r4,r3,255
   1a210:	e0fffdc3 	ldbu	r3,-9(fp)
   1a214:	18c03fcc 	andi	r3,r3,255
   1a218:	d9400015 	stw	r5,0(sp)
   1a21c:	d9000115 	stw	r4,4(sp)
   1a220:	d8c00215 	stw	r3,8(sp)
   1a224:	e13fff17 	ldw	r4,-4(fp)
   1a228:	01400444 	movi	r5,17
   1a22c:	01800134 	movhi	r6,4
   1a230:	3183fd04 	addi	r6,r6,4084
   1a234:	100f883a 	mov	r7,r2
   1a238:	003f3440 	call	3f344 <snprintf>

	return buf;
   1a23c:	e0bfff17 	ldw	r2,-4(fp)
}
   1a240:	e037883a 	mov	sp,fp
   1a244:	dfc00117 	ldw	ra,4(sp)
   1a248:	df000017 	ldw	fp,0(sp)
   1a24c:	dec00204 	addi	sp,sp,8
   1a250:	f800283a 	ret

0001a254 <lwip_status_callback>:

static void lwip_status_callback(struct netif *netif)
{
   1a254:	defffd04 	addi	sp,sp,-12
   1a258:	dfc00215 	stw	ra,8(sp)
   1a25c:	df000115 	stw	fp,4(sp)
   1a260:	df000104 	addi	fp,sp,4
   1a264:	e13fff15 	stw	r4,-4(fp)
	if (status_callback)
   1a268:	d0a91f17 	ldw	r2,-23428(gp)
   1a26c:	10000326 	beq	r2,zero,1a27c <lwip_status_callback+0x28>
		status_callback(netif);
   1a270:	d0a91f17 	ldw	r2,-23428(gp)
   1a274:	e13fff17 	ldw	r4,-4(fp)
   1a278:	103ee83a 	callr	r2
}
   1a27c:	e037883a 	mov	sp,fp
   1a280:	dfc00117 	ldw	ra,4(sp)
   1a284:	df000017 	ldw	fp,0(sp)
   1a288:	dec00204 	addi	sp,sp,8
   1a28c:	f800283a 	ret

0001a290 <lwip_initialize_phys>:

void lwip_initialize_phys(void)
{
   1a290:	defff604 	addi	sp,sp,-40
   1a294:	dfc00915 	stw	ra,36(sp)
   1a298:	df000815 	stw	fp,32(sp)
   1a29c:	df000804 	addi	fp,sp,32
	int idx, phyadd, phyid, phyid2;
	np_tse_mac *pmac;

	for (idx = 0; idx < PHY_COUNT; ++idx)
   1a2a0:	e03ff815 	stw	zero,-32(fp)
   1a2a4:	00007006 	br	1a468 <lwip_initialize_phys+0x1d8>
	{
		// check whether this interface should be used
		if (!is_interface_active(idx))
   1a2a8:	e13ff817 	ldw	r4,-32(fp)
   1a2ac:	00031440 	call	3144 <is_interface_active>
   1a2b0:	10006526 	beq	r2,zero,1a448 <lwip_initialize_phys+0x1b8>
			continue;

		// the PHY is active... let's get the mac base
		pmac = get_mac_base(idx);
   1a2b4:	e13ff817 	ldw	r4,-32(fp)
   1a2b8:	0019ee40 	call	19ee4 <get_mac_base>
   1a2bc:	e0bffd15 	stw	r2,-12(fp)
		if (!pmac)
   1a2c0:	e0bffd17 	ldw	r2,-12(fp)
   1a2c4:	10006226 	beq	r2,zero,1a450 <lwip_initialize_phys+0x1c0>
			continue;

		// search the PHY and it's ID
		for (phyadd = 0x00; phyadd < 0x20; ++phyadd)
   1a2c8:	e03ff915 	stw	zero,-28(fp)
   1a2cc:	00001206 	br	1a318 <lwip_initialize_phys+0x88>
		{
			IOWR(&pmac->MDIO_ADDR1, 0, phyadd);
   1a2d0:	e0bffd17 	ldw	r2,-12(fp)
   1a2d4:	10801004 	addi	r2,r2,64
   1a2d8:	e0fff917 	ldw	r3,-28(fp)
   1a2dc:	10c00035 	stwio	r3,0(r2)

			phyid = IORD(&pmac->mdio1.PHY_ID1, 0);
   1a2e0:	e0bffd17 	ldw	r2,-12(fp)
   1a2e4:	1080a204 	addi	r2,r2,648
   1a2e8:	10800037 	ldwio	r2,0(r2)
   1a2ec:	e0bffa15 	stw	r2,-24(fp)
			phyid2 = IORD(&pmac->mdio1.PHY_ID2, 0);
   1a2f0:	e0bffd17 	ldw	r2,-12(fp)
   1a2f4:	1080a304 	addi	r2,r2,652
   1a2f8:	10800037 	ldwio	r2,0(r2)
   1a2fc:	e0bffb15 	stw	r2,-20(fp)

			if (phyid != phyid2)
   1a300:	e0fffa17 	ldw	r3,-24(fp)
   1a304:	e0bffb17 	ldw	r2,-20(fp)
   1a308:	1880071e 	bne	r3,r2,1a328 <lwip_initialize_phys+0x98>
		pmac = get_mac_base(idx);
		if (!pmac)
			continue;

		// search the PHY and it's ID
		for (phyadd = 0x00; phyadd < 0x20; ++phyadd)
   1a30c:	e0bff917 	ldw	r2,-28(fp)
   1a310:	10800044 	addi	r2,r2,1
   1a314:	e0bff915 	stw	r2,-28(fp)
   1a318:	e0bff917 	ldw	r2,-28(fp)
   1a31c:	10800810 	cmplti	r2,r2,32
   1a320:	103feb1e 	bne	r2,zero,1a2d0 <lwip_initialize_phys+0x40>
   1a324:	00000106 	br	1a32c <lwip_initialize_phys+0x9c>

			phyid = IORD(&pmac->mdio1.PHY_ID1, 0);
			phyid2 = IORD(&pmac->mdio1.PHY_ID2, 0);

			if (phyid != phyid2)
				break;
   1a328:	0001883a 	nop
		}

		// if we have the PHY we can initialize it if we can find the driver in the pphy_profiles array
		if (phyid != phyid2)
   1a32c:	e0fffa17 	ldw	r3,-24(fp)
   1a330:	e0bffb17 	ldw	r2,-20(fp)
   1a334:	18804926 	beq	r3,r2,1a45c <lwip_initialize_phys+0x1cc>
            extern alt_tse_phy_profile *pphy_profiles[];
            extern alt_u8 phy_profile_count;

            int i;

            for(i = 0; i < phy_profile_count; i++) {
   1a338:	e03ffc15 	stw	zero,-16(fp)
   1a33c:	00003b06 	br	1a42c <lwip_initialize_phys+0x19c>
                alt_u32 oui = (phyid << 6) | ((phyid2 >> 10) & 0x3f);
   1a340:	e0bffa17 	ldw	r2,-24(fp)
   1a344:	100691ba 	slli	r3,r2,6
   1a348:	e0bffb17 	ldw	r2,-20(fp)
   1a34c:	1005d2ba 	srai	r2,r2,10
   1a350:	10800fcc 	andi	r2,r2,63
   1a354:	1884b03a 	or	r2,r3,r2
   1a358:	e0bffe15 	stw	r2,-8(fp)
                alt_u8 model_number = (phyid2 >> 4) & 0x3f;
   1a35c:	e0bffb17 	ldw	r2,-20(fp)
   1a360:	1005d13a 	srai	r2,r2,4
   1a364:	10800fcc 	andi	r2,r2,63
   1a368:	e0bfff05 	stb	r2,-4(fp)
                // unused so far... alt_u8 revision_number = phyid2 & 0x0f;

                // if PHY match with PHY in profile we can call the initialize function
                if((pphy_profiles[i]->oui == oui) && (pphy_profiles[i]->model_number == model_number))
   1a36c:	00c001f4 	movhi	r3,7
   1a370:	18ed1304 	addi	r3,r3,-19380
   1a374:	e0bffc17 	ldw	r2,-16(fp)
   1a378:	1085883a 	add	r2,r2,r2
   1a37c:	1085883a 	add	r2,r2,r2
   1a380:	1885883a 	add	r2,r3,r2
   1a384:	10800017 	ldw	r2,0(r2)
   1a388:	10c01417 	ldw	r3,80(r2)
   1a38c:	e0bffe17 	ldw	r2,-8(fp)
   1a390:	1880231e 	bne	r3,r2,1a420 <lwip_initialize_phys+0x190>
   1a394:	00c001f4 	movhi	r3,7
   1a398:	18ed1304 	addi	r3,r3,-19380
   1a39c:	e0bffc17 	ldw	r2,-16(fp)
   1a3a0:	1085883a 	add	r2,r2,r2
   1a3a4:	1085883a 	add	r2,r2,r2
   1a3a8:	1885883a 	add	r2,r3,r2
   1a3ac:	10800017 	ldw	r2,0(r2)
   1a3b0:	10801503 	ldbu	r2,84(r2)
   1a3b4:	10c03fcc 	andi	r3,r2,255
   1a3b8:	e0bfff03 	ldbu	r2,-4(fp)
   1a3bc:	1880181e 	bne	r3,r2,1a420 <lwip_initialize_phys+0x190>
                {
                    if (pphy_profiles[i]->phy_cfg)
   1a3c0:	00c001f4 	movhi	r3,7
   1a3c4:	18ed1304 	addi	r3,r3,-19380
   1a3c8:	e0bffc17 	ldw	r2,-16(fp)
   1a3cc:	1085883a 	add	r2,r2,r2
   1a3d0:	1085883a 	add	r2,r2,r2
   1a3d4:	1885883a 	add	r2,r3,r2
   1a3d8:	10800017 	ldw	r2,0(r2)
   1a3dc:	10801717 	ldw	r2,92(r2)
   1a3e0:	10001d26 	beq	r2,zero,1a458 <lwip_initialize_phys+0x1c8>
                    {
                    	// initialize the PHY
                    	pphy_profiles[i]->phy_cfg(pmac);
   1a3e4:	00c001f4 	movhi	r3,7
   1a3e8:	18ed1304 	addi	r3,r3,-19380
   1a3ec:	e0bffc17 	ldw	r2,-16(fp)
   1a3f0:	1085883a 	add	r2,r2,r2
   1a3f4:	1085883a 	add	r2,r2,r2
   1a3f8:	1885883a 	add	r2,r3,r2
   1a3fc:	10800017 	ldw	r2,0(r2)
   1a400:	10801717 	ldw	r2,92(r2)
   1a404:	e13ffd17 	ldw	r4,-12(fp)
   1a408:	103ee83a 	callr	r2

                    	// and restart the Auto-Negotiation
                    	IOWR(&pmac->mdio1.CONTROL, 0, (PCS_CTL_an_enable | PCS_CTL_an_restart));
   1a40c:	e0bffd17 	ldw	r2,-12(fp)
   1a410:	1080a004 	addi	r2,r2,640
   1a414:	00c48004 	movi	r3,4608
   1a418:	10c00035 	stwio	r3,0(r2)
                    }

                    // and done for this PHY
                    break;
   1a41c:	00000e06 	br	1a458 <lwip_initialize_phys+0x1c8>
            extern alt_tse_phy_profile *pphy_profiles[];
            extern alt_u8 phy_profile_count;

            int i;

            for(i = 0; i < phy_profile_count; i++) {
   1a420:	e0bffc17 	ldw	r2,-16(fp)
   1a424:	10800044 	addi	r2,r2,1
   1a428:	e0bffc15 	stw	r2,-16(fp)
   1a42c:	00800134 	movhi	r2,4
   1a430:	109f0304 	addi	r2,r2,31756
   1a434:	10800003 	ldbu	r2,0(r2)
   1a438:	10803fcc 	andi	r2,r2,255
   1a43c:	e0fffc17 	ldw	r3,-16(fp)
   1a440:	18bfbf16 	blt	r3,r2,1a340 <lwip_initialize_phys+0xb0>
   1a444:	00000506 	br	1a45c <lwip_initialize_phys+0x1cc>

	for (idx = 0; idx < PHY_COUNT; ++idx)
	{
		// check whether this interface should be used
		if (!is_interface_active(idx))
			continue;
   1a448:	0001883a 	nop
   1a44c:	00000306 	br	1a45c <lwip_initialize_phys+0x1cc>

		// the PHY is active... let's get the mac base
		pmac = get_mac_base(idx);
		if (!pmac)
			continue;
   1a450:	0001883a 	nop
   1a454:	00000106 	br	1a45c <lwip_initialize_phys+0x1cc>
                    	// and restart the Auto-Negotiation
                    	IOWR(&pmac->mdio1.CONTROL, 0, (PCS_CTL_an_enable | PCS_CTL_an_restart));
                    }

                    // and done for this PHY
                    break;
   1a458:	0001883a 	nop
void lwip_initialize_phys(void)
{
	int idx, phyadd, phyid, phyid2;
	np_tse_mac *pmac;

	for (idx = 0; idx < PHY_COUNT; ++idx)
   1a45c:	e0bff817 	ldw	r2,-32(fp)
   1a460:	10800044 	addi	r2,r2,1
   1a464:	e0bff815 	stw	r2,-32(fp)
   1a468:	e0bff817 	ldw	r2,-32(fp)
   1a46c:	103f8e16 	blt	r2,zero,1a2a8 <lwip_initialize_phys+0x18>
                    break;
                }
            }
		}
	}
}
   1a470:	e037883a 	mov	sp,fp
   1a474:	dfc00117 	ldw	ra,4(sp)
   1a478:	df000017 	ldw	fp,0(sp)
   1a47c:	dec00204 	addi	sp,sp,8
   1a480:	f800283a 	ret

0001a484 <tse_mac_init>:
 * @API TYPE: Internal
 * @Param iface index of the NET structure associated with TSE instance
 * @Return 0 if ok, else -1 if error
 */
int tse_mac_init(int iface, struct ethernetif *ethernetif)
{
   1a484:	defff004 	addi	sp,sp,-64
   1a488:	dfc00f15 	stw	ra,60(sp)
   1a48c:	df000e15 	stw	fp,56(sp)
   1a490:	df000e04 	addi	fp,sp,56
   1a494:	e13ffe15 	stw	r4,-8(fp)
   1a498:	e17fff15 	stw	r5,-4(fp)
	int speed, duplex, result;
	int x;

	alt_sgdma_dev *sgdma_tx_dev;
	alt_sgdma_dev *sgdma_rx_dev;
	alt_tse_system_info* tse_hw = (alt_tse_system_info *) tse[iface].tse;
   1a49c:	00c00134 	movhi	r3,4
   1a4a0:	18dee104 	addi	r3,r3,31620
   1a4a4:	e0bffe17 	ldw	r2,-8(fp)
   1a4a8:	10800924 	muli	r2,r2,36
   1a4ac:	1885883a 	add	r2,r3,r2
   1a4b0:	10800704 	addi	r2,r2,28
   1a4b4:	10800017 	ldw	r2,0(r2)
   1a4b8:	e0bff715 	stw	r2,-36(fp)
	np_tse_mac *mi_base;
	alt_tse_mac_info *pmac_info;

#if LWIP_RECEIVE_SEMAPHORE
	if (!tse[iface].rx_semaphore) {
   1a4bc:	00c00134 	movhi	r3,4
   1a4c0:	18dee104 	addi	r3,r3,31620
   1a4c4:	e0bffe17 	ldw	r2,-8(fp)
   1a4c8:	10800924 	muli	r2,r2,36
   1a4cc:	1885883a 	add	r2,r3,r2
   1a4d0:	10800804 	addi	r2,r2,32
   1a4d4:	10800017 	ldw	r2,0(r2)
   1a4d8:	10001e1e 	bne	r2,zero,1a554 <tse_mac_init+0xd0>
		dprintf(("creating RX SGDMA semaphore\n"));
		// create a counting semaphore so we can 'release' the semaphore for each rx input buffer filled
		if (sys_sem_new(&tse[iface].rx_semaphore, LWIP_RX_ETH_BUFFER) != ERR_OK) {
   1a4dc:	e0bffe17 	ldw	r2,-8(fp)
   1a4e0:	10800924 	muli	r2,r2,36
   1a4e4:	10c00804 	addi	r3,r2,32
   1a4e8:	00800134 	movhi	r2,4
   1a4ec:	109ee104 	addi	r2,r2,31620
   1a4f0:	1885883a 	add	r2,r3,r2
   1a4f4:	1009883a 	mov	r4,r2
   1a4f8:	01400304 	movi	r5,12
   1a4fc:	001b1bc0 	call	1b1bc <sys_sem_new>
   1a500:	10803fcc 	andi	r2,r2,255
   1a504:	1080201c 	xori	r2,r2,128
   1a508:	10bfe004 	addi	r2,r2,-128
   1a50c:	1000111e 	bne	r2,zero,1a554 <tse_mac_init+0xd0>
			dprintf(("[LwIP] Couldn't create the rx_semephore\n"));
		} else {
			// we got a semaphore, completely lock it
			for (x = 0; x < LWIP_RX_ETH_BUFFER; x++)
   1a510:	e03ff515 	stw	zero,-44(fp)
   1a514:	00000c06 	br	1a548 <tse_mac_init+0xc4>
				sys_arch_sem_wait(&tse[iface].rx_semaphore, 1);
   1a518:	e0bffe17 	ldw	r2,-8(fp)
   1a51c:	10800924 	muli	r2,r2,36
   1a520:	10c00804 	addi	r3,r2,32
   1a524:	00800134 	movhi	r2,4
   1a528:	109ee104 	addi	r2,r2,31620
   1a52c:	1885883a 	add	r2,r3,r2
   1a530:	1009883a 	mov	r4,r2
   1a534:	01400044 	movi	r5,1
   1a538:	001b3340 	call	1b334 <sys_arch_sem_wait>
		// create a counting semaphore so we can 'release' the semaphore for each rx input buffer filled
		if (sys_sem_new(&tse[iface].rx_semaphore, LWIP_RX_ETH_BUFFER) != ERR_OK) {
			dprintf(("[LwIP] Couldn't create the rx_semephore\n"));
		} else {
			// we got a semaphore, completely lock it
			for (x = 0; x < LWIP_RX_ETH_BUFFER; x++)
   1a53c:	e0bff517 	ldw	r2,-44(fp)
   1a540:	10800044 	addi	r2,r2,1
   1a544:	e0bff515 	stw	r2,-44(fp)
   1a548:	e0bff517 	ldw	r2,-44(fp)
   1a54c:	10800310 	cmplti	r2,r2,12
   1a550:	103ff11e 	bne	r2,zero,1a518 <tse_mac_init+0x94>
	dprintf(("[tse_mac_init]\n"));
#ifdef PRINTIF
	dprintf(("tse_mac_init %d\n", iface));
#endif    
	// These lines were done in prep_tse_mac
	tse_hw = &tse_mac_device[iface];
   1a554:	e0bffe17 	ldw	r2,-8(fp)
   1a558:	10c01224 	muli	r3,r2,72
   1a55c:	00800134 	movhi	r2,4
   1a560:	10952c04 	addi	r2,r2,21680
   1a564:	1885883a 	add	r2,r3,r2
   1a568:	e0bff715 	stw	r2,-36(fp)
	tse[iface].tse = tse_hw;
   1a56c:	00c00134 	movhi	r3,4
   1a570:	18dee104 	addi	r3,r3,31620
   1a574:	e0bffe17 	ldw	r2,-8(fp)
   1a578:	10800924 	muli	r2,r2,36
   1a57c:	1885883a 	add	r2,r3,r2
   1a580:	10800704 	addi	r2,r2,28
   1a584:	e0fff717 	ldw	r3,-36(fp)
   1a588:	10c00015 	stw	r3,0(r2)

	// Store ethernetif for access, and the tse in ethernetif for access in tse_mac_raw_send/tse_mac_rcv
	tse[iface].ethernetif = ethernetif;
   1a58c:	00c00134 	movhi	r3,4
   1a590:	18dee104 	addi	r3,r3,31620
   1a594:	e0bffe17 	ldw	r2,-8(fp)
   1a598:	10800924 	muli	r2,r2,36
   1a59c:	1885883a 	add	r2,r3,r2
   1a5a0:	10800604 	addi	r2,r2,24
   1a5a4:	e0ffff17 	ldw	r3,-4(fp)
   1a5a8:	10c00015 	stw	r3,0(r2)
	ethernetif->iface = iface;
   1a5ac:	e0bfff17 	ldw	r2,-4(fp)
   1a5b0:	e0fffe17 	ldw	r3,-8(fp)
   1a5b4:	10c00115 	stw	r3,4(r2)
	ethernetif->tse_info = &tse[iface];
   1a5b8:	e0bffe17 	ldw	r2,-8(fp)
   1a5bc:	10c00924 	muli	r3,r2,36
   1a5c0:	00800134 	movhi	r2,4
   1a5c4:	109ee104 	addi	r2,r2,31620
   1a5c8:	1887883a 	add	r3,r3,r2
   1a5cc:	e0bfff17 	ldw	r2,-4(fp)
   1a5d0:	10c01715 	stw	r3,92(r2)

	if (tse_hw->ext_desc_mem == 1)
   1a5d4:	e0bff717 	ldw	r2,-36(fp)
   1a5d8:	10800783 	ldbu	r2,30(r2)
   1a5dc:	10803fcc 	andi	r2,r2,255
   1a5e0:	10800058 	cmpnei	r2,r2,1
   1a5e4:	10000b1e 	bne	r2,zero,1a614 <tse_mac_init+0x190>
	{
		tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
   1a5e8:	e0bff717 	ldw	r2,-36(fp)
   1a5ec:	10800817 	ldw	r2,32(r2)
   1a5f0:	1007883a 	mov	r3,r2
   1a5f4:	01000134 	movhi	r4,4
   1a5f8:	211ee104 	addi	r4,r4,31620
   1a5fc:	e0bffe17 	ldw	r2,-8(fp)
   1a600:	10800924 	muli	r2,r2,36
   1a604:	2085883a 	add	r2,r4,r2
   1a608:	10800504 	addi	r2,r2,20
   1a60c:	10c00015 	stw	r3,0(r2)
   1a610:	00001206 	br	1a65c <tse_mac_init+0x1d8>
	}
	else
	{
		unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
   1a614:	01002804 	movi	r4,160
   1a618:	003d2280 	call	3d228 <alt_uncached_malloc>
   1a61c:	e0bff615 	stw	r2,-40(fp)

		while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
   1a620:	00000306 	br	1a630 <tse_mac_init+0x1ac>
			temp_desc++;
   1a624:	e0bff617 	ldw	r2,-40(fp)
   1a628:	10800044 	addi	r2,r2,1
   1a62c:	e0bff615 	stw	r2,-40(fp)
	}
	else
	{
		unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));

		while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
   1a630:	e0bff617 	ldw	r2,-40(fp)
   1a634:	108007cc 	andi	r2,r2,31
   1a638:	103ffa1e 	bne	r2,zero,1a624 <tse_mac_init+0x1a0>
			temp_desc++;
		tse[iface].desc = (alt_sgdma_descriptor *) temp_desc;
   1a63c:	00c00134 	movhi	r3,4
   1a640:	18dee104 	addi	r3,r3,31620
   1a644:	e0bffe17 	ldw	r2,-8(fp)
   1a648:	10800924 	muli	r2,r2,36
   1a64c:	1885883a 	add	r2,r3,r2
   1a650:	10800504 	addi	r2,r2,20
   1a654:	e0fff617 	ldw	r3,-40(fp)
   1a658:	10c00015 	stw	r3,0(r2)
	}

	/* Get the Rx and Tx SGDMA addresses */
	sgdma_tx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_tx);
   1a65c:	e0bff717 	ldw	r2,-36(fp)
   1a660:	10800517 	ldw	r2,20(r2)
   1a664:	1009883a 	mov	r4,r2
   1a668:	003578c0 	call	3578c <alt_avalon_sgdma_open>
   1a66c:	e0bff815 	stw	r2,-32(fp)

	if (!sgdma_tx_dev)
   1a670:	e0bff817 	ldw	r2,-32(fp)
   1a674:	1000021e 	bne	r2,zero,1a680 <tse_mac_init+0x1fc>
	{
		dprintf(("[triple_speed_ethernet_init] Error opening TX SGDMA\n"));
		return ENP_RESOURCE;
   1a678:	00bffa84 	movi	r2,-22
   1a67c:	00019006 	br	1acc0 <tse_mac_init+0x83c>
	}

	sgdma_rx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_rx);
   1a680:	e0bff717 	ldw	r2,-36(fp)
   1a684:	10800617 	ldw	r2,24(r2)
   1a688:	1009883a 	mov	r4,r2
   1a68c:	003578c0 	call	3578c <alt_avalon_sgdma_open>
   1a690:	e0bff915 	stw	r2,-28(fp)
	if (!sgdma_rx_dev)
   1a694:	e0bff917 	ldw	r2,-28(fp)
   1a698:	1000021e 	bne	r2,zero,1a6a4 <tse_mac_init+0x220>
	{
		dprintf(("[triple_speed_ethernet_init] Error opening RX SGDMA\n"));
		return ENP_RESOURCE;
   1a69c:	00bffa84 	movi	r2,-22
   1a6a0:	00018706 	br	1acc0 <tse_mac_init+0x83c>
	}

	/* Initialize mtip_mac_trans_info structure with values from <system.h>*/

	tse_mac_initTransInfo2(&tse[iface].mi, (int)tse_hw->tse_mac_base,
   1a6a4:	e0bffe17 	ldw	r2,-8(fp)
   1a6a8:	10c00924 	muli	r3,r2,36
   1a6ac:	00800134 	movhi	r2,4
   1a6b0:	109ee104 	addi	r2,r2,31620
   1a6b4:	1889883a 	add	r4,r3,r2
   1a6b8:	e0bff717 	ldw	r2,-36(fp)
   1a6bc:	11400017 	ldw	r5,0(r2)
   1a6c0:	e0fff817 	ldw	r3,-32(fp)
   1a6c4:	e0bff917 	ldw	r2,-28(fp)
   1a6c8:	d8000015 	stw	zero,0(sp)
   1a6cc:	180d883a 	mov	r6,r3
   1a6d0:	100f883a 	mov	r7,r2
   1a6d4:	0035f640 	call	35f64 <tse_mac_initTransInfo2>
			(unsigned int)sgdma_tx_dev,
			(unsigned int)sgdma_rx_dev,
			0);
	mi_base = tse[iface].mi.base;
   1a6d8:	00c00134 	movhi	r3,4
   1a6dc:	18dee104 	addi	r3,r3,31620
   1a6e0:	e0bffe17 	ldw	r2,-8(fp)
   1a6e4:	10800924 	muli	r2,r2,36
   1a6e8:	1885883a 	add	r2,r3,r2
   1a6ec:	10800017 	ldw	r2,0(r2)
   1a6f0:	e0bffa15 	stw	r2,-24(fp)

	IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base, ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
   1a6f4:	00c00134 	movhi	r3,4
   1a6f8:	18dee104 	addi	r3,r3,31620
   1a6fc:	e0bffe17 	ldw	r2,-8(fp)
   1a700:	10800924 	muli	r2,r2,36
   1a704:	1885883a 	add	r2,r3,r2
   1a708:	10800204 	addi	r2,r2,8
   1a70c:	10800017 	ldw	r2,0(r2)
   1a710:	10800317 	ldw	r2,12(r2)
   1a714:	10800404 	addi	r2,r2,16
   1a718:	00c00074 	movhi	r3,1
   1a71c:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base, 0x0);
   1a720:	00c00134 	movhi	r3,4
   1a724:	18dee104 	addi	r3,r3,31620
   1a728:	e0bffe17 	ldw	r2,-8(fp)
   1a72c:	10800924 	muli	r2,r2,36
   1a730:	1885883a 	add	r2,r3,r2
   1a734:	10800204 	addi	r2,r2,8
   1a738:	10800017 	ldw	r2,0(r2)
   1a73c:	10800317 	ldw	r2,12(r2)
   1a740:	10800404 	addi	r2,r2,16
   1a744:	0007883a 	mov	r3,zero
   1a748:	10c00035 	stwio	r3,0(r2)

	/* reset the PHY if necessary */
	result = getPHYSpeed(tse[iface].mi.base);
   1a74c:	00c00134 	movhi	r3,4
   1a750:	18dee104 	addi	r3,r3,31620
   1a754:	e0bffe17 	ldw	r2,-8(fp)
   1a758:	10800924 	muli	r2,r2,36
   1a75c:	1885883a 	add	r2,r3,r2
   1a760:	10800017 	ldw	r2,0(r2)
   1a764:	1009883a 	mov	r4,r2
   1a768:	00373e40 	call	373e4 <getPHYSpeed>
   1a76c:	e0bffb15 	stw	r2,-20(fp)
	speed = (result >> 1) & 0x07;
   1a770:	e0bffb17 	ldw	r2,-20(fp)
   1a774:	1005d07a 	srai	r2,r2,1
   1a778:	108001cc 	andi	r2,r2,7
   1a77c:	e0bffc15 	stw	r2,-16(fp)
	duplex = result & 0x01;
   1a780:	e0bffb17 	ldw	r2,-20(fp)
   1a784:	1080004c 	andi	r2,r2,1
   1a788:	e0bff415 	stw	r2,-48(fp)

	/* reset the mac */
	IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base,
   1a78c:	00c00134 	movhi	r3,4
   1a790:	18dee104 	addi	r3,r3,31620
   1a794:	e0bffe17 	ldw	r2,-8(fp)
   1a798:	10800924 	muli	r2,r2,36
   1a79c:	1885883a 	add	r2,r3,r2
   1a7a0:	10800017 	ldw	r2,0(r2)
   1a7a4:	10800204 	addi	r2,r2,8
   1a7a8:	00c800c4 	movi	r3,8195
   1a7ac:	10c00035 	stwio	r3,0(r2)
			mmac_cc_SW_RESET_mask |
			mmac_cc_TX_ENA_mask |
			mmac_cc_RX_ENA_mask);

	x = 0;
   1a7b0:	e03ff515 	stw	zero,-44(fp)
	while (IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) &
   1a7b4:	00000706 	br	1a7d4 <tse_mac_init+0x350>
			ALTERA_TSEMAC_CMD_SW_RESET_MSK)
	{
		if( x++ > 10000 )
   1a7b8:	e0bff517 	ldw	r2,-44(fp)
   1a7bc:	1089c448 	cmpgei	r2,r2,10001
   1a7c0:	e0fff517 	ldw	r3,-44(fp)
   1a7c4:	18c00044 	addi	r3,r3,1
   1a7c8:	e0fff515 	stw	r3,-44(fp)
   1a7cc:	10803fcc 	andi	r2,r2,255
   1a7d0:	10000b1e 	bne	r2,zero,1a800 <tse_mac_init+0x37c>
			mmac_cc_SW_RESET_mask |
			mmac_cc_TX_ENA_mask |
			mmac_cc_RX_ENA_mask);

	x = 0;
	while (IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) &
   1a7d4:	00c00134 	movhi	r3,4
   1a7d8:	18dee104 	addi	r3,r3,31620
   1a7dc:	e0bffe17 	ldw	r2,-8(fp)
   1a7e0:	10800924 	muli	r2,r2,36
   1a7e4:	1885883a 	add	r2,r3,r2
   1a7e8:	10800017 	ldw	r2,0(r2)
   1a7ec:	10800204 	addi	r2,r2,8
   1a7f0:	10800037 	ldwio	r2,0(r2)
   1a7f4:	1088000c 	andi	r2,r2,8192
   1a7f8:	103fef1e 	bne	r2,zero,1a7b8 <tse_mac_init+0x334>
   1a7fc:	00000106 	br	1a804 <tse_mac_init+0x380>
			ALTERA_TSEMAC_CMD_SW_RESET_MSK)
	{
		if( x++ > 10000 )
			break;
   1a800:	0001883a 	nop
	}

	if (x >= 10000)
		dprintf(("TSEMAC SW reset bit never cleared!\n"));

	dat = IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base);
   1a804:	00c00134 	movhi	r3,4
   1a808:	18dee104 	addi	r3,r3,31620
   1a80c:	e0bffe17 	ldw	r2,-8(fp)
   1a810:	10800924 	muli	r2,r2,36
   1a814:	1885883a 	add	r2,r3,r2
   1a818:	10800017 	ldw	r2,0(r2)
   1a81c:	10800204 	addi	r2,r2,8
   1a820:	10800037 	ldwio	r2,0(r2)
   1a824:	e0bff315 	stw	r2,-52(fp)
		dprintf(("WARN: RX/TX not disabled after reset... missing PHY clock? CMD_CONFIG=0x%08x\n", dat));
	else
		dprintf(("OK, x=%d, CMD_CONFIG=0x%08x\n", x, dat));

	/* Initialize MAC registers */
	IOWR_ALTERA_TSEMAC_FRM_LENGTH(mi_base, PBUF_POOL_BUFSIZE+ETH_PAD_SIZE);
   1a828:	e0bffa17 	ldw	r2,-24(fp)
   1a82c:	10800504 	addi	r2,r2,20
   1a830:	00c17b84 	movi	r3,1518
   1a834:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_RX_ALMOST_EMPTY(mi_base, 8);
   1a838:	e0bffa17 	ldw	r2,-24(fp)
   1a83c:	10800b04 	addi	r2,r2,44
   1a840:	00c00204 	movi	r3,8
   1a844:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_RX_ALMOST_FULL(mi_base, 8);
   1a848:	e0bffa17 	ldw	r2,-24(fp)
   1a84c:	10800c04 	addi	r2,r2,48
   1a850:	00c00204 	movi	r3,8
   1a854:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_TX_ALMOST_EMPTY(mi_base, 8);
   1a858:	e0bffa17 	ldw	r2,-24(fp)
   1a85c:	10800d04 	addi	r2,r2,52
   1a860:	00c00204 	movi	r3,8
   1a864:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_TX_ALMOST_FULL(mi_base,  3);
   1a868:	e0bffa17 	ldw	r2,-24(fp)
   1a86c:	10800e04 	addi	r2,r2,56
   1a870:	00c000c4 	movi	r3,3
   1a874:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_TX_SECTION_EMPTY(mi_base, tse_hw->tse_tx_depth - 16);
   1a878:	e0bffa17 	ldw	r2,-24(fp)
   1a87c:	10800904 	addi	r2,r2,36
   1a880:	e0fff717 	ldw	r3,-36(fp)
   1a884:	18c0010b 	ldhu	r3,4(r3)
   1a888:	18ffffcc 	andi	r3,r3,65535
   1a88c:	18fffc04 	addi	r3,r3,-16
   1a890:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_TX_SECTION_FULL(mi_base,  0);
   1a894:	e0bffa17 	ldw	r2,-24(fp)
   1a898:	10800a04 	addi	r2,r2,40
   1a89c:	0007883a 	mov	r3,zero
   1a8a0:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_RX_SECTION_EMPTY(mi_base, tse_hw->tse_rx_depth - 16);
   1a8a4:	e0bffa17 	ldw	r2,-24(fp)
   1a8a8:	10800704 	addi	r2,r2,28
   1a8ac:	e0fff717 	ldw	r3,-36(fp)
   1a8b0:	18c0018b 	ldhu	r3,6(r3)
   1a8b4:	18ffffcc 	andi	r3,r3,65535
   1a8b8:	18fffc04 	addi	r3,r3,-16
   1a8bc:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_RX_SECTION_FULL(mi_base,  0);
   1a8c0:	e0bffa17 	ldw	r2,-24(fp)
   1a8c4:	10800804 	addi	r2,r2,32
   1a8c8:	0007883a 	mov	r3,zero
   1a8cc:	10c00035 	stwio	r3,0(r2)

	/* Enable TX shift 16 for removing two bytes from the start of all transmitted frames */
	IOWR_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK);
   1a8d0:	00c00134 	movhi	r3,4
   1a8d4:	18dee104 	addi	r3,r3,31620
   1a8d8:	e0bffe17 	ldw	r2,-8(fp)
   1a8dc:	10800924 	muli	r2,r2,36
   1a8e0:	1885883a 	add	r2,r3,r2
   1a8e4:	10800017 	ldw	r2,0(r2)
   1a8e8:	10803a04 	addi	r2,r2,232
   1a8ec:	00c00134 	movhi	r3,4
   1a8f0:	10c00035 	stwio	r3,0(r2)

	/*
	 * check if the MAC supports the 16-bit shift option allowing us
	 * to send BIASed frames without copying. Used by the send function later.
	 */
	if ((IORD_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK) == 0)
   1a8f4:	00c00134 	movhi	r3,4
   1a8f8:	18dee104 	addi	r3,r3,31620
   1a8fc:	e0bffe17 	ldw	r2,-8(fp)
   1a900:	10800924 	muli	r2,r2,36
   1a904:	1885883a 	add	r2,r3,r2
   1a908:	10800017 	ldw	r2,0(r2)
   1a90c:	10803a04 	addi	r2,r2,232
   1a910:	10800037 	ldwio	r2,0(r2)
   1a914:	1080012c 	andhi	r2,r2,4
   1a918:	1000021e 	bne	r2,zero,1a924 <tse_mac_init+0x4a0>
	{
		dprintf(("[tse_mac_init] Error: Incompatible %d value with TX_CMD_STAT register return TxShift16 value. \n",ETH_PAD_SIZE));
		return ERR_IF;
   1a91c:	00bffc44 	movi	r2,-15
   1a920:	0000e706 	br	1acc0 <tse_mac_init+0x83c>
	}

	/* Enable RX shift 16 for alignment of all received frames on 16-bit start address */
	IOWR_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK);
   1a924:	00c00134 	movhi	r3,4
   1a928:	18dee104 	addi	r3,r3,31620
   1a92c:	e0bffe17 	ldw	r2,-8(fp)
   1a930:	10800924 	muli	r2,r2,36
   1a934:	1885883a 	add	r2,r3,r2
   1a938:	10800017 	ldw	r2,0(r2)
   1a93c:	10803b04 	addi	r2,r2,236
   1a940:	00c08034 	movhi	r3,512
   1a944:	10c00035 	stwio	r3,0(r2)

	/* check if the MAC supports the 16-bit shift option at the RX CMD STATUS Register  */
	if ((IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK) == 0)
   1a948:	00c00134 	movhi	r3,4
   1a94c:	18dee104 	addi	r3,r3,31620
   1a950:	e0bffe17 	ldw	r2,-8(fp)
   1a954:	10800924 	muli	r2,r2,36
   1a958:	1885883a 	add	r2,r3,r2
   1a95c:	10800017 	ldw	r2,0(r2)
   1a960:	10803b04 	addi	r2,r2,236
   1a964:	10800037 	ldwio	r2,0(r2)
   1a968:	1080802c 	andhi	r2,r2,512
   1a96c:	1000021e 	bne	r2,zero,1a978 <tse_mac_init+0x4f4>
	{
		dprintf(("[tse_mac_init] Error: Incompatible %d value with RX_CMD_STAT register return RxShift16 value. \n",ETH_PAD_SIZE));
		return ERR_IF;
   1a970:	00bffc44 	movi	r2,-15
   1a974:	0000d206 	br	1acc0 <tse_mac_init+0x83c>
	}

	/* Set the MAC address */
	IOWR_ALTERA_TSEMAC_MAC_0(mi_base,
   1a978:	e0bffa17 	ldw	r2,-24(fp)
   1a97c:	10800304 	addi	r2,r2,12
   1a980:	e0ffff17 	ldw	r3,-4(fp)
   1a984:	18c00017 	ldw	r3,0(r3)
   1a988:	18c00003 	ldbu	r3,0(r3)
   1a98c:	19003fcc 	andi	r4,r3,255
   1a990:	e0ffff17 	ldw	r3,-4(fp)
   1a994:	18c00017 	ldw	r3,0(r3)
   1a998:	18c00043 	ldbu	r3,1(r3)
   1a99c:	18c03fcc 	andi	r3,r3,255
   1a9a0:	1806923a 	slli	r3,r3,8
   1a9a4:	20c8b03a 	or	r4,r4,r3
   1a9a8:	e0ffff17 	ldw	r3,-4(fp)
   1a9ac:	18c00017 	ldw	r3,0(r3)
   1a9b0:	18c00083 	ldbu	r3,2(r3)
   1a9b4:	18c03fcc 	andi	r3,r3,255
   1a9b8:	1806943a 	slli	r3,r3,16
   1a9bc:	20c8b03a 	or	r4,r4,r3
   1a9c0:	e0ffff17 	ldw	r3,-4(fp)
   1a9c4:	18c00017 	ldw	r3,0(r3)
   1a9c8:	18c000c3 	ldbu	r3,3(r3)
   1a9cc:	18c03fcc 	andi	r3,r3,255
   1a9d0:	1806963a 	slli	r3,r3,24
   1a9d4:	20c6b03a 	or	r3,r4,r3
   1a9d8:	10c00035 	stwio	r3,0(r2)
			((int)((unsigned char) ethernetif->ethaddr->addr[0]) |
					(int)((unsigned char) ethernetif->ethaddr->addr[1] <<  8) |
					(int)((unsigned char) ethernetif->ethaddr->addr[2] << 16) |
					(int)((unsigned char) ethernetif->ethaddr->addr[3] << 24)));

	IOWR_ALTERA_TSEMAC_MAC_1(mi_base,
   1a9dc:	e0bffa17 	ldw	r2,-24(fp)
   1a9e0:	10800404 	addi	r2,r2,16
   1a9e4:	e0ffff17 	ldw	r3,-4(fp)
   1a9e8:	18c00017 	ldw	r3,0(r3)
   1a9ec:	18c00103 	ldbu	r3,4(r3)
   1a9f0:	19003fcc 	andi	r4,r3,255
   1a9f4:	e0ffff17 	ldw	r3,-4(fp)
   1a9f8:	18c00017 	ldw	r3,0(r3)
   1a9fc:	18c00143 	ldbu	r3,5(r3)
   1aa00:	18c03fcc 	andi	r3,r3,255
   1aa04:	1806923a 	slli	r3,r3,8
   1aa08:	20c6b03a 	or	r3,r4,r3
   1aa0c:	18ffffcc 	andi	r3,r3,65535
   1aa10:	10c00035 	stwio	r3,0(r2)
			(((int)((unsigned char) ethernetif->ethaddr->addr[4]) |
					(int)((unsigned char) ethernetif->ethaddr->addr[5] <<  8)) & 0xFFFF));

	/* enable MAC */
	dat = ALTERA_TSEMAC_CMD_TX_ENA_MSK       |
   1aa14:	00810034 	movhi	r2,1024
   1aa18:	108080c4 	addi	r2,r2,515
   1aa1c:	e0bff315 	stw	r2,-52(fp)
			ALTERA_TSEMAC_CMD_LOOPBACK_MSK     |     // promiscuous mode
#endif
			ALTERA_TSEMAC_CMD_TX_ADDR_INS_MSK  |
			ALTERA_TSEMAC_CMD_RX_ERR_DISC_MSK;  /* automatically discard frames with CRC errors */

	if ((result & ALT_TSE_E_AN_NOT_COMPLETE) == 0)
   1aa20:	e0bffb17 	ldw	r2,-20(fp)
   1aa24:	1080022c 	andhi	r2,r2,8
   1aa28:	1000461e 	bne	r2,zero,1ab44 <tse_mac_init+0x6c0>
	{
		speed = (result >> 1) & 0x07;
   1aa2c:	e0bffb17 	ldw	r2,-20(fp)
   1aa30:	1005d07a 	srai	r2,r2,1
   1aa34:	108001cc 	andi	r2,r2,7
   1aa38:	e0bffc15 	stw	r2,-16(fp)
		duplex = result & 0x01;
   1aa3c:	e0bffb17 	ldw	r2,-20(fp)
   1aa40:	1080004c 	andi	r2,r2,1
   1aa44:	e0bff415 	stw	r2,-48(fp)

		/* 1000 Mbps */
		if(speed == 0x01)
   1aa48:	e0bffc17 	ldw	r2,-16(fp)
   1aa4c:	10800058 	cmpnei	r2,r2,1
   1aa50:	1000121e 	bne	r2,zero,1aa9c <tse_mac_init+0x618>
		{
			dat |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
   1aa54:	e0bff317 	ldw	r2,-52(fp)
   1aa58:	10800214 	ori	r2,r2,8
   1aa5c:	e0bff315 	stw	r2,-52(fp)
			dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
   1aa60:	e0fff317 	ldw	r3,-52(fp)
   1aa64:	00bf8034 	movhi	r2,65024
   1aa68:	10bfffc4 	addi	r2,r2,-1
   1aa6c:	1884703a 	and	r2,r3,r2
   1aa70:	e0bff315 	stw	r2,-52(fp)
			tse[iface].ethernetif->link_speed = 1000;
   1aa74:	00c00134 	movhi	r3,4
   1aa78:	18dee104 	addi	r3,r3,31620
   1aa7c:	e0bffe17 	ldw	r2,-8(fp)
   1aa80:	10800924 	muli	r2,r2,36
   1aa84:	1885883a 	add	r2,r3,r2
   1aa88:	10800604 	addi	r2,r2,24
   1aa8c:	10800017 	ldw	r2,0(r2)
   1aa90:	00c0fa04 	movi	r3,1000
   1aa94:	10c00315 	stw	r3,12(r2)
   1aa98:	00003306 	br	1ab68 <tse_mac_init+0x6e4>
		}
		/* 100 Mbps */
		else if(speed == 0x02)
   1aa9c:	e0bffc17 	ldw	r2,-16(fp)
   1aaa0:	10800098 	cmpnei	r2,r2,2
   1aaa4:	1000131e 	bne	r2,zero,1aaf4 <tse_mac_init+0x670>
		{
			dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
   1aaa8:	e0fff317 	ldw	r3,-52(fp)
   1aaac:	00bffdc4 	movi	r2,-9
   1aab0:	1884703a 	and	r2,r3,r2
   1aab4:	e0bff315 	stw	r2,-52(fp)
			dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
   1aab8:	e0fff317 	ldw	r3,-52(fp)
   1aabc:	00bf8034 	movhi	r2,65024
   1aac0:	10bfffc4 	addi	r2,r2,-1
   1aac4:	1884703a 	and	r2,r3,r2
   1aac8:	e0bff315 	stw	r2,-52(fp)
			tse[iface].ethernetif->link_speed = 100;
   1aacc:	00c00134 	movhi	r3,4
   1aad0:	18dee104 	addi	r3,r3,31620
   1aad4:	e0bffe17 	ldw	r2,-8(fp)
   1aad8:	10800924 	muli	r2,r2,36
   1aadc:	1885883a 	add	r2,r3,r2
   1aae0:	10800604 	addi	r2,r2,24
   1aae4:	10800017 	ldw	r2,0(r2)
   1aae8:	00c01904 	movi	r3,100
   1aaec:	10c00315 	stw	r3,12(r2)
   1aaf0:	00001d06 	br	1ab68 <tse_mac_init+0x6e4>
		}
		/* 10 Mbps */
		else if(speed == 0x04)
   1aaf4:	e0bffc17 	ldw	r2,-16(fp)
   1aaf8:	10800118 	cmpnei	r2,r2,4
   1aafc:	10001a1e 	bne	r2,zero,1ab68 <tse_mac_init+0x6e4>
		{
			dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
   1ab00:	e0fff317 	ldw	r3,-52(fp)
   1ab04:	00bffdc4 	movi	r2,-9
   1ab08:	1884703a 	and	r2,r3,r2
   1ab0c:	e0bff315 	stw	r2,-52(fp)
			dat |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
   1ab10:	e0bff317 	ldw	r2,-52(fp)
   1ab14:	10808034 	orhi	r2,r2,512
   1ab18:	e0bff315 	stw	r2,-52(fp)
			tse[iface].ethernetif->link_speed = 10;
   1ab1c:	00c00134 	movhi	r3,4
   1ab20:	18dee104 	addi	r3,r3,31620
   1ab24:	e0bffe17 	ldw	r2,-8(fp)
   1ab28:	10800924 	muli	r2,r2,36
   1ab2c:	1885883a 	add	r2,r3,r2
   1ab30:	10800604 	addi	r2,r2,24
   1ab34:	10800017 	ldw	r2,0(r2)
   1ab38:	00c00284 	movi	r3,10
   1ab3c:	10c00315 	stw	r3,12(r2)
   1ab40:	00000906 	br	1ab68 <tse_mac_init+0x6e4>
		}
	}
	/* default to 100 Mbps if returned invalid speed */
	else
	{
		dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
   1ab44:	e0fff317 	ldw	r3,-52(fp)
   1ab48:	00bffdc4 	movi	r2,-9
   1ab4c:	1884703a 	and	r2,r3,r2
   1ab50:	e0bff315 	stw	r2,-52(fp)
		dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
   1ab54:	e0fff317 	ldw	r3,-52(fp)
   1ab58:	00bf8034 	movhi	r2,65024
   1ab5c:	10bfffc4 	addi	r2,r2,-1
   1ab60:	1884703a 	and	r2,r3,r2
   1ab64:	e0bff315 	stw	r2,-52(fp)
	}

	/* Half Duplex */
	if(duplex == TSE_PHY_DUPLEX_HALF)
   1ab68:	e0bff417 	ldw	r2,-48(fp)
   1ab6c:	10000c1e 	bne	r2,zero,1aba0 <tse_mac_init+0x71c>
	{
		dat |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
   1ab70:	e0bff317 	ldw	r2,-52(fp)
   1ab74:	10810014 	ori	r2,r2,1024
   1ab78:	e0bff315 	stw	r2,-52(fp)
		tse[iface].ethernetif->full_duplex = 0;
   1ab7c:	00c00134 	movhi	r3,4
   1ab80:	18dee104 	addi	r3,r3,31620
   1ab84:	e0bffe17 	ldw	r2,-8(fp)
   1ab88:	10800924 	muli	r2,r2,36
   1ab8c:	1885883a 	add	r2,r3,r2
   1ab90:	10800604 	addi	r2,r2,24
   1ab94:	10800017 	ldw	r2,0(r2)
   1ab98:	10000415 	stw	zero,16(r2)
   1ab9c:	00000d06 	br	1abd4 <tse_mac_init+0x750>
	}
	/* Full Duplex */
	else
	{
		dat &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
   1aba0:	e0fff317 	ldw	r3,-52(fp)
   1aba4:	00beffc4 	movi	r2,-1025
   1aba8:	1884703a 	and	r2,r3,r2
   1abac:	e0bff315 	stw	r2,-52(fp)
		tse[iface].ethernetif->full_duplex = 1;
   1abb0:	00c00134 	movhi	r3,4
   1abb4:	18dee104 	addi	r3,r3,31620
   1abb8:	e0bffe17 	ldw	r2,-8(fp)
   1abbc:	10800924 	muli	r2,r2,36
   1abc0:	1885883a 	add	r2,r3,r2
   1abc4:	10800604 	addi	r2,r2,24
   1abc8:	10800017 	ldw	r2,0(r2)
   1abcc:	00c00044 	movi	r3,1
   1abd0:	10c00415 	stw	r3,16(r2)
	}

	IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base, dat);
   1abd4:	00c00134 	movhi	r3,4
   1abd8:	18dee104 	addi	r3,r3,31620
   1abdc:	e0bffe17 	ldw	r2,-8(fp)
   1abe0:	10800924 	muli	r2,r2,36
   1abe4:	1885883a 	add	r2,r3,r2
   1abe8:	10800017 	ldw	r2,0(r2)
   1abec:	10800204 	addi	r2,r2,8
   1abf0:	e0fff317 	ldw	r3,-52(fp)
   1abf4:	10c00035 	stwio	r3,0(r2)
	dprintf(("\nMAC post-initialization: CMD_CONFIG=0x%08x\n",
			IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base)));

	alt_avalon_sgdma_register_callback(tse[iface].mi.rx_sgdma,
   1abf8:	00c00134 	movhi	r3,4
   1abfc:	18dee104 	addi	r3,r3,31620
   1ac00:	e0bffe17 	ldw	r2,-8(fp)
   1ac04:	10800924 	muli	r2,r2,36
   1ac08:	1885883a 	add	r2,r3,r2
   1ac0c:	10800204 	addi	r2,r2,8
   1ac10:	10c00017 	ldw	r3,0(r2)
#ifndef ALTERA_TSE_IRQ_R
			(alt_avalon_sgdma_callback)&tse_sgdma_rx_isr,
#else
			(alt_avalon_sgdma_callback)&ALTERA_TSE_IRQ_R,
#endif
			(alt_u16)ALTERA_TSE_SGDMA_INTR_MASK,(void*)(&tse[iface]));
   1ac14:	e0bffe17 	ldw	r2,-8(fp)
   1ac18:	11000924 	muli	r4,r2,36
   1ac1c:	00800134 	movhi	r2,4
   1ac20:	109ee104 	addi	r2,r2,31620
   1ac24:	2085883a 	add	r2,r4,r2

	IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base, dat);
	dprintf(("\nMAC post-initialization: CMD_CONFIG=0x%08x\n",
			IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base)));

	alt_avalon_sgdma_register_callback(tse[iface].mi.rx_sgdma,
   1ac28:	1809883a 	mov	r4,r3
   1ac2c:	014000b4 	movhi	r5,2
   1ac30:	296b5f04 	addi	r5,r5,-21124
   1ac34:	01800604 	movi	r6,24
   1ac38:	100f883a 	mov	r7,r2
   1ac3c:	003562c0 	call	3562c <alt_avalon_sgdma_register_callback>
#else
			(alt_avalon_sgdma_callback)&ALTERA_TSE_IRQ_R,
#endif
			(alt_u16)ALTERA_TSE_SGDMA_INTR_MASK,(void*)(&tse[iface]));

	tse_sgdma_read_init(&tse[iface]);
   1ac40:	e0bffe17 	ldw	r2,-8(fp)
   1ac44:	10c00924 	muli	r3,r2,36
   1ac48:	00800134 	movhi	r2,4
   1ac4c:	109ee104 	addi	r2,r2,31620
   1ac50:	1885883a 	add	r2,r3,r2
   1ac54:	1009883a 	mov	r4,r2
   1ac58:	001acd40 	call	1acd4 <tse_sgdma_read_init>
	pmac_info = alt_tse_get_mac_info(mi_base);
   1ac5c:	e13ffa17 	ldw	r4,-24(fp)
   1ac60:	00371a00 	call	371a0 <alt_tse_get_mac_info>
   1ac64:	e0bffd15 	stw	r2,-12(fp)
	alt_tse_phy_wr_mdio_addr(pmac_info->pphy_info, pmac_info->pphy_info->mdio_address);
   1ac68:	e0bffd17 	ldw	r2,-12(fp)
   1ac6c:	10c00117 	ldw	r3,4(r2)
   1ac70:	e0bffd17 	ldw	r2,-12(fp)
   1ac74:	10800117 	ldw	r2,4(r2)
   1ac78:	10800003 	ldbu	r2,0(r2)
   1ac7c:	10803fcc 	andi	r2,r2,255
   1ac80:	1809883a 	mov	r4,r3
   1ac84:	100b883a 	mov	r5,r2
   1ac88:	0037e940 	call	37e94 <alt_tse_phy_wr_mdio_addr>
	ethernetif->link_alive = alt_tse_phy_rd_mdio_reg(pmac_info->pphy_info, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) != 0;// && (((IORD(&(mi_base->mdio1.reg10), 0) >> 4) & 0xF) <= 3);
   1ac8c:	e0bffd17 	ldw	r2,-12(fp)
   1ac90:	10800117 	ldw	r2,4(r2)
   1ac94:	1009883a 	mov	r4,r2
   1ac98:	01400044 	movi	r5,1
   1ac9c:	01800144 	movi	r6,5
   1aca0:	01c00044 	movi	r7,1
   1aca4:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   1aca8:	1004c03a 	cmpne	r2,r2,zero
   1acac:	10c03fcc 	andi	r3,r2,255
   1acb0:	e0bfff17 	ldw	r2,-4(fp)
   1acb4:	10c00215 	stw	r3,8(r2)
	return ethernetif->link_alive;
   1acb8:	e0bfff17 	ldw	r2,-4(fp)
   1acbc:	10800217 	ldw	r2,8(r2)
}
   1acc0:	e037883a 	mov	sp,fp
   1acc4:	dfc00117 	ldw	ra,4(sp)
   1acc8:	df000017 	ldw	fp,0(sp)
   1accc:	dec00204 	addi	sp,sp,8
   1acd0:	f800283a 	ret

0001acd4 <tse_sgdma_read_init>:
 * 
 * @API TYPE - Internal
 * @return SUCCESS on success 
 */
int tse_sgdma_read_init(lwip_tse_info* tse_ptr)
{     
   1acd4:	defffb04 	addi	sp,sp,-20
   1acd8:	dfc00415 	stw	ra,16(sp)
   1acdc:	df000315 	stw	fp,12(sp)
   1ace0:	df000304 	addi	fp,sp,12
   1ace4:	e13fff15 	stw	r4,-4(fp)
	struct ethernetif *ethernetif;

	ethernetif = tse_ptr->ethernetif;
   1ace8:	e0bfff17 	ldw	r2,-4(fp)
   1acec:	10800617 	ldw	r2,24(r2)
   1acf0:	e0bffe15 	stw	r2,-8(fp)

	alt_avalon_sgdma_construct_stream_to_mem_desc(
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
   1acf4:	e0bfff17 	ldw	r2,-4(fp)
   1acf8:	10800517 	ldw	r2,20(r2)
{     
	struct ethernetif *ethernetif;

	ethernetif = tse_ptr->ethernetif;

	alt_avalon_sgdma_construct_stream_to_mem_desc(
   1acfc:	11001004 	addi	r4,r2,64
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST],  // pointer to "next"
   1ad00:	e0bfff17 	ldw	r2,-4(fp)
   1ad04:	10800517 	ldw	r2,20(r2)
{     
	struct ethernetif *ethernetif;

	ethernetif = tse_ptr->ethernetif;

	alt_avalon_sgdma_construct_stream_to_mem_desc(
   1ad08:	10c01804 	addi	r3,r2,96
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST],  // pointer to "next"
			(alt_u32 *) ethernetif->lwipRxPbuf[tse_ptr->ethernetif->lwipRxIndexIsr]->payload,          // starting write_address
   1ad0c:	e0bfff17 	ldw	r2,-4(fp)
   1ad10:	10800617 	ldw	r2,24(r2)
   1ad14:	10801317 	ldw	r2,76(r2)
   1ad18:	e17ffe17 	ldw	r5,-8(fp)
   1ad1c:	108001c4 	addi	r2,r2,7
   1ad20:	1085883a 	add	r2,r2,r2
   1ad24:	1085883a 	add	r2,r2,r2
   1ad28:	2885883a 	add	r2,r5,r2
   1ad2c:	10800017 	ldw	r2,0(r2)
   1ad30:	10800117 	ldw	r2,4(r2)
{     
	struct ethernetif *ethernetif;

	ethernetif = tse_ptr->ethernetif;

	alt_avalon_sgdma_construct_stream_to_mem_desc(
   1ad34:	d8000015 	stw	zero,0(sp)
   1ad38:	180b883a 	mov	r5,r3
   1ad3c:	100d883a 	mov	r6,r2
   1ad40:	000f883a 	mov	r7,zero
   1ad44:	00354580 	call	35458 <alt_avalon_sgdma_construct_stream_to_mem_desc>
			0,                                  // read until EOP
			0);          // don't write to constant address

	dprintf(("[tse_sgdma_read_init] RX descriptor chain desc (%d depth) created\n",0));

	tse_mac_aRxRead( &tse_ptr->mi, &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
   1ad48:	e0ffff17 	ldw	r3,-4(fp)
   1ad4c:	e0bfff17 	ldw	r2,-4(fp)
   1ad50:	10800517 	ldw	r2,20(r2)
   1ad54:	10801004 	addi	r2,r2,64
   1ad58:	1809883a 	mov	r4,r3
   1ad5c:	100b883a 	mov	r5,r2
   1ad60:	00360a40 	call	360a4 <tse_mac_aRxRead>

	return SUCCESS;
   1ad64:	0005883a 	mov	r2,zero
}
   1ad68:	e037883a 	mov	sp,fp
   1ad6c:	dfc00117 	ldw	ra,4(sp)
   1ad70:	df000017 	ldw	fp,0(sp)
   1ad74:	dec00204 	addi	sp,sp,8
   1ad78:	f800283a 	ret

0001ad7c <tse_sgdma_rx_isr>:
 * @API TYPE - callback
 * @param  context  - context of the TSE MAC instance
 * @param  intnum - temporary storage
 */
int tse_sgdma_rx_isr(void * context, __unused u_long intnum)
{
   1ad7c:	defffb04 	addi	sp,sp,-20
   1ad80:	dfc00415 	stw	ra,16(sp)
   1ad84:	df000315 	stw	fp,12(sp)
   1ad88:	df000304 	addi	fp,sp,12
   1ad8c:	e13ffe15 	stw	r4,-8(fp)
   1ad90:	e17fff15 	stw	r5,-4(fp)
	lwip_tse_info* tse_ptr = (lwip_tse_info *) context;
   1ad94:	e0bffe17 	ldw	r2,-8(fp)
   1ad98:	e0bffd15 	stw	r2,-12(fp)

	IOWR_ALTERA_AVALON_SGDMA_CONTROL(&tse_ptr->mi.rx_sgdma->base,ALTERA_AVALON_SGDMA_CONTROL_CLEAR_INTERRUPT_MSK);
   1ad9c:	e0bffd17 	ldw	r2,-12(fp)
   1ada0:	10800217 	ldw	r2,8(r2)
   1ada4:	10800304 	addi	r2,r2,12
   1ada8:	10800404 	addi	r2,r2,16
   1adac:	00e00034 	movhi	r3,32768
   1adb0:	10c00035 	stwio	r3,0(r2)

	// process the newly received data and cycle to the next free pbuf for receive
	tse_mac_rcv(tse_ptr->ethernetif);
   1adb4:	e0bffd17 	ldw	r2,-12(fp)
   1adb8:	10800617 	ldw	r2,24(r2)
   1adbc:	1009883a 	mov	r4,r2
   1adc0:	001af7c0 	call	1af7c <tse_mac_rcv>

	// start a new async read transaction
	tse_mac_aRxRead( &tse_ptr->mi, &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
   1adc4:	e0fffd17 	ldw	r3,-12(fp)
   1adc8:	e0bffd17 	ldw	r2,-12(fp)
   1adcc:	10800517 	ldw	r2,20(r2)
   1add0:	10801004 	addi	r2,r2,64
   1add4:	1809883a 	mov	r4,r3
   1add8:	100b883a 	mov	r5,r2
   1addc:	00360a40 	call	360a4 <tse_mac_aRxRead>

	IOWR_ALTERA_AVALON_SGDMA_CONTROL(&tse_ptr->mi.rx_sgdma->base, ALTERA_TSE_SGDMA_INTR_MASK);
   1ade0:	e0bffd17 	ldw	r2,-12(fp)
   1ade4:	10800217 	ldw	r2,8(r2)
   1ade8:	10800304 	addi	r2,r2,12
   1adec:	10800404 	addi	r2,r2,16
   1adf0:	00c00604 	movi	r3,24
   1adf4:	10c00035 	stwio	r3,0(r2)

	return SUCCESS;
   1adf8:	0005883a 	mov	r2,zero
}
   1adfc:	e037883a 	mov	sp,fp
   1ae00:	dfc00117 	ldw	ra,4(sp)
   1ae04:	df000017 	ldw	fp,0(sp)
   1ae08:	dec00204 	addi	sp,sp,8
   1ae0c:	f800283a 	ret

0001ae10 <tse_mac_raw_send>:
 * @param  data - pointer to the data payload
 * @param  data_bytes - number of bytes of the data payload to be sent to the MAC
 * @return SUCCESS if success, else a negative value
 */
err_t tse_mac_raw_send(struct netif *netif, struct pbuf *pkt)
{
   1ae10:	defe6a04 	addi	sp,sp,-1624
   1ae14:	dfc19515 	stw	ra,1620(sp)
   1ae18:	df019415 	stw	fp,1616(sp)
   1ae1c:	df019404 	addi	fp,sp,1616
   1ae20:	e13ffe15 	stw	r4,-8(fp)
   1ae24:	e17fff15 	stw	r5,-4(fp)
	alt_u32			   *ActualData;

	/* Intermediate buffers used for temporary copy of frames that cannot be directrly DMA'ed*/
	char buf2[1560];

	ethernetif = netif->state;
   1ae28:	e0bffe17 	ldw	r2,-8(fp)
   1ae2c:	10800917 	ldw	r2,36(r2)
   1ae30:	e0be7215 	stw	r2,-1592(fp)
	tse_ptr = ethernetif->tse_info;
   1ae34:	e0be7217 	ldw	r2,-1592(fp)
   1ae38:	10801717 	ldw	r2,92(r2)
   1ae3c:	e0be7315 	stw	r2,-1588(fp)
	mi = &tse_ptr->mi;
   1ae40:	e0be7317 	ldw	r2,-1588(fp)
   1ae44:	e0be7415 	stw	r2,-1584(fp)

	for(p = pkt; p != NULL; p = p->next)
   1ae48:	e0bfff17 	ldw	r2,-4(fp)
   1ae4c:	e0be7015 	stw	r2,-1600(fp)
   1ae50:	00003b06 	br	1af40 <tse_mac_raw_send+0x130>
	{
		data = p->payload;
   1ae54:	e0be7017 	ldw	r2,-1600(fp)
   1ae58:	10800117 	ldw	r2,4(r2)
   1ae5c:	e0be7115 	stw	r2,-1596(fp)
		len = p->len;
   1ae60:	e0be7017 	ldw	r2,-1600(fp)
   1ae64:	1080028b 	ldhu	r2,10(r2)
   1ae68:	10bfffcc 	andi	r2,r2,65535
   1ae6c:	e0be7515 	stw	r2,-1580(fp)

		// just in case we have an unaligned buffer, this should never occur
		if(((unsigned long)data & 0x03) != 0)
   1ae70:	e0be7117 	ldw	r2,-1596(fp)
   1ae74:	108000cc 	andi	r2,r2,3
   1ae78:	10000726 	beq	r2,zero,1ae98 <tse_mac_raw_send+0x88>
			/*
			 * Copy data to temporary buffer <buf2>. This is done because of alignment
			 * issues. The SGDMA cannot copy the data directly from (data + ETH_PAD_SIZE)
			 * because it needs a 32-bit aligned address space.
			 */
			memcpy(buf2,data,len);
   1ae7c:	e0be7804 	addi	r2,fp,-1568
   1ae80:	1009883a 	mov	r4,r2
   1ae84:	e17e7117 	ldw	r5,-1596(fp)
   1ae88:	e1be7517 	ldw	r6,-1580(fp)
   1ae8c:	00041f00 	call	41f0 <memcpy>
			data = (alt_u32 *)buf2;
   1ae90:	e0be7804 	addi	r2,fp,-1568
   1ae94:	e0be7115 	stw	r2,-1596(fp)
		}

		// uncache the ethernet frame
		ActualData = (void *)alt_remap_uncached (data, len);
   1ae98:	e13e7117 	ldw	r4,-1596(fp)
   1ae9c:	e17e7517 	ldw	r5,-1580(fp)
   1aea0:	003d0200 	call	3d020 <alt_remap_uncached>
   1aea4:	e0be7615 	stw	r2,-1576(fp)

		/* Write data to Tx FIFO using the DMA */
		alt_avalon_sgdma_construct_mem_to_stream_desc(
				(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST], // descriptor I want to work with
   1aea8:	e0be7317 	ldw	r2,-1588(fp)

		// uncache the ethernet frame
		ActualData = (void *)alt_remap_uncached (data, len);

		/* Write data to Tx FIFO using the DMA */
		alt_avalon_sgdma_construct_mem_to_stream_desc(
   1aeac:	11000517 	ldw	r4,20(r2)
				(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST], // descriptor I want to work with
				(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_TX_SGDMA_DESC_OFST],// pointer to "next"
   1aeb0:	e0be7317 	ldw	r2,-1588(fp)
   1aeb4:	10800517 	ldw	r2,20(r2)

		// uncache the ethernet frame
		ActualData = (void *)alt_remap_uncached (data, len);

		/* Write data to Tx FIFO using the DMA */
		alt_avalon_sgdma_construct_mem_to_stream_desc(
   1aeb8:	10c00804 	addi	r3,r2,32
   1aebc:	e0be7517 	ldw	r2,-1580(fp)
   1aec0:	10bfffcc 	andi	r2,r2,65535
   1aec4:	e1be7017 	ldw	r6,-1600(fp)
   1aec8:	e17fff17 	ldw	r5,-4(fp)
   1aecc:	314b003a 	cmpeq	r5,r6,r5
   1aed0:	29803fcc 	andi	r6,r5,255
				(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_TX_SGDMA_DESC_OFST],// pointer to "next"
				(alt_u32*)ActualData,                    // starting read address
				(len),                                   // # bytes
				0,                                       // don't read from constant address
				p == pkt,                                // generate sop
				p->next == NULL,                         // generate endofpacket signal
   1aed4:	e17e7017 	ldw	r5,-1600(fp)
   1aed8:	29400017 	ldw	r5,0(r5)

		// uncache the ethernet frame
		ActualData = (void *)alt_remap_uncached (data, len);

		/* Write data to Tx FIFO using the DMA */
		alt_avalon_sgdma_construct_mem_to_stream_desc(
   1aedc:	280b003a 	cmpeq	r5,r5,zero
   1aee0:	29403fcc 	andi	r5,r5,255
   1aee4:	d8000015 	stw	zero,0(sp)
   1aee8:	d9800115 	stw	r6,4(sp)
   1aeec:	d9400215 	stw	r5,8(sp)
   1aef0:	d8000315 	stw	zero,12(sp)
   1aef4:	180b883a 	mov	r5,r3
   1aef8:	e1be7617 	ldw	r6,-1576(fp)
   1aefc:	100f883a 	mov	r7,r2
   1af00:	00355280 	call	35528 <alt_avalon_sgdma_construct_mem_to_stream_desc>
				0,                                       // don't read from constant address
				p == pkt,                                // generate sop
				p->next == NULL,                         // generate endofpacket signal
				0);                                      // atlantic channel (don't know/don't care: set to 0)

		tx_length = tse_mac_sTxWrite(mi,&tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST]);
   1af04:	e0be7317 	ldw	r2,-1588(fp)
   1af08:	10800517 	ldw	r2,20(r2)
   1af0c:	e13e7417 	ldw	r4,-1584(fp)
   1af10:	100b883a 	mov	r5,r2
   1af14:	0035fc40 	call	35fc4 <tse_mac_sTxWrite>
   1af18:	e0be7715 	stw	r2,-1572(fp)

		if (tx_length != p->len)
			dprintf(("failed to send all bytes, send %d out of %d\r\n", tx_length, p->len));

		ethernetif->bytes_sent += tx_length;
   1af1c:	e0be7217 	ldw	r2,-1592(fp)
   1af20:	10c00517 	ldw	r3,20(r2)
   1af24:	e0be7717 	ldw	r2,-1572(fp)
   1af28:	1887883a 	add	r3,r3,r2
   1af2c:	e0be7217 	ldw	r2,-1592(fp)
   1af30:	10c00515 	stw	r3,20(r2)

	ethernetif = netif->state;
	tse_ptr = ethernetif->tse_info;
	mi = &tse_ptr->mi;

	for(p = pkt; p != NULL; p = p->next)
   1af34:	e0be7017 	ldw	r2,-1600(fp)
   1af38:	10800017 	ldw	r2,0(r2)
   1af3c:	e0be7015 	stw	r2,-1600(fp)
   1af40:	e0be7017 	ldw	r2,-1600(fp)
   1af44:	103fc31e 	bne	r2,zero,1ae54 <tse_mac_raw_send+0x44>
			dprintf(("failed to send all bytes, send %d out of %d\r\n", tx_length, p->len));

		ethernetif->bytes_sent += tx_length;
	}

	LINK_STATS_INC(link.xmit);
   1af48:	008001f4 	movhi	r2,7
   1af4c:	10ac6e04 	addi	r2,r2,-20040
   1af50:	10800017 	ldw	r2,0(r2)
   1af54:	10c00044 	addi	r3,r2,1
   1af58:	008001f4 	movhi	r2,7
   1af5c:	10ac6e04 	addi	r2,r2,-20040
   1af60:	10c00015 	stw	r3,0(r2)

	return ERR_OK;
   1af64:	0005883a 	mov	r2,zero
}
   1af68:	e037883a 	mov	sp,fp
   1af6c:	dfc00117 	ldw	ra,4(sp)
   1af70:	df000017 	ldw	fp,0(sp)
   1af74:	dec00204 	addi	sp,sp,8
   1af78:	f800283a 	ret

0001af7c <tse_mac_rcv>:
 * 
 * @API TYPE        - callback internal function
 * @return SUCCESS on success
 */
int tse_mac_rcv(struct ethernetif *ethernetif)
{
   1af7c:	defff704 	addi	sp,sp,-36
   1af80:	dfc00815 	stw	ra,32(sp)
   1af84:	df000715 	stw	fp,28(sp)
   1af88:	df000704 	addi	fp,sp,28
   1af8c:	e13fff15 	stw	r4,-4(fp)
#if LWIP_RECEIVE_SEMAPHORE
	signed portBASE_TYPE switch_context = 0;
   1af90:	e03ffe15 	stw	zero,-8(fp)
	int pklen;
	lwip_tse_info* tse_ptr;
	alt_u32 *uncached_packet_payload;
	struct pbuf *p;

	tse_ptr = ethernetif->tse_info;
   1af94:	e0bfff17 	ldw	r2,-4(fp)
   1af98:	10801717 	ldw	r2,92(r2)
   1af9c:	e0bffa15 	stw	r2,-24(fp)
	pklen = IORD_16DIRECT(&(tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST].actual_bytes_transferred),0);
   1afa0:	e0bffa17 	ldw	r2,-24(fp)
   1afa4:	10800517 	ldw	r2,20(r2)
   1afa8:	10801004 	addi	r2,r2,64
   1afac:	10800704 	addi	r2,r2,28
   1afb0:	1080002b 	ldhuio	r2,0(r2)
   1afb4:	10bfffcc 	andi	r2,r2,65535
   1afb8:	e0bffb15 	stw	r2,-20(fp)
	p = ethernetif->lwipRxPbuf[ethernetif->lwipRxIndexIsr];
   1afbc:	e0bfff17 	ldw	r2,-4(fp)
   1afc0:	10801317 	ldw	r2,76(r2)
   1afc4:	e0ffff17 	ldw	r3,-4(fp)
   1afc8:	108001c4 	addi	r2,r2,7
   1afcc:	1085883a 	add	r2,r2,r2
   1afd0:	1085883a 	add	r2,r2,r2
   1afd4:	1885883a 	add	r2,r3,r2
   1afd8:	10800017 	ldw	r2,0(r2)
   1afdc:	e0bffc15 	stw	r2,-16(fp)
	p->tot_len = pklen;
   1afe0:	e0bffb17 	ldw	r2,-20(fp)
   1afe4:	1007883a 	mov	r3,r2
   1afe8:	e0bffc17 	ldw	r2,-16(fp)
   1afec:	10c0020d 	sth	r3,8(r2)
	p->len = pklen;
   1aff0:	e0bffb17 	ldw	r2,-20(fp)
   1aff4:	1007883a 	mov	r3,r2
   1aff8:	e0bffc17 	ldw	r2,-16(fp)
   1affc:	10c0028d 	sth	r3,10(r2)
	if ((IORD_ALTERA_TSE_SGDMA_DESC_STATUS(&tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]) & ( ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_CRC_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_PARITY_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK )) == 0)
   1b000:	e0bffa17 	ldw	r2,-24(fp)
   1b004:	10800517 	ldw	r2,20(r2)
   1b008:	10801704 	addi	r2,r2,92
   1b00c:	10800037 	ldwio	r2,0(r2)
   1b010:	1005d43a 	srai	r2,r2,16
   1b014:	10801fcc 	andi	r2,r2,127
   1b018:	10002f1e 	bne	r2,zero,1b0d8 <tse_mac_rcv+0x15c>
	{
		enh_alt_irq_disable_all();
   1b01c:	003c1b40 	call	3c1b4 <enh_alt_irq_disable_all>

		if (++ethernetif->lwipRxCount >= LWIP_RX_ETH_BUFFER)
   1b020:	e0bfff17 	ldw	r2,-4(fp)
   1b024:	10801517 	ldw	r2,84(r2)
   1b028:	10800044 	addi	r2,r2,1
   1b02c:	e0ffff17 	ldw	r3,-4(fp)
   1b030:	18801515 	stw	r2,84(r3)
   1b034:	10800310 	cmplti	r2,r2,12
   1b038:	10000e1e 	bne	r2,zero,1b074 <tse_mac_rcv+0xf8>
		{
			LINK_STATS_INC(link.drop);
   1b03c:	008001f4 	movhi	r2,7
   1b040:	10ac6e04 	addi	r2,r2,-20040
   1b044:	10800317 	ldw	r2,12(r2)
   1b048:	10c00044 	addi	r3,r2,1
   1b04c:	008001f4 	movhi	r2,7
   1b050:	10ac6e04 	addi	r2,r2,-20040
   1b054:	10c00315 	stw	r3,12(r2)
			--ethernetif->lwipRxCount;
   1b058:	e0bfff17 	ldw	r2,-4(fp)
   1b05c:	10801517 	ldw	r2,84(r2)
   1b060:	10ffffc4 	addi	r3,r2,-1
   1b064:	e0bfff17 	ldw	r2,-4(fp)
   1b068:	10c01515 	stw	r3,84(r2)

			enh_alt_irq_enable_all();
   1b06c:	003c2000 	call	3c200 <enh_alt_irq_enable_all>
   1b070:	00001906 	br	1b0d8 <tse_mac_rcv+0x15c>

			dprintf(("No free buffers for RX on iface: %hhd\n", ethernetif->iface));
		}
		else
		{
			ethernetif->bytes_recv += pklen;
   1b074:	e0bfff17 	ldw	r2,-4(fp)
   1b078:	10c00617 	ldw	r3,24(r2)
   1b07c:	e0bffb17 	ldw	r2,-20(fp)
   1b080:	1887883a 	add	r3,r3,r2
   1b084:	e0bfff17 	ldw	r2,-4(fp)
   1b088:	10c00615 	stw	r3,24(r2)

			//  Set up DMA for the next pbuf in the buffer
			if (++ethernetif->lwipRxIndexIsr >= LWIP_RX_ETH_BUFFER)
   1b08c:	e0bfff17 	ldw	r2,-4(fp)
   1b090:	10801317 	ldw	r2,76(r2)
   1b094:	10800044 	addi	r2,r2,1
   1b098:	e0ffff17 	ldw	r3,-4(fp)
   1b09c:	18801315 	stw	r2,76(r3)
   1b0a0:	10800310 	cmplti	r2,r2,12
   1b0a4:	1000021e 	bne	r2,zero,1b0b0 <tse_mac_rcv+0x134>
				ethernetif->lwipRxIndexIsr = 0;
   1b0a8:	e0bfff17 	ldw	r2,-4(fp)
   1b0ac:	10001315 	stw	zero,76(r2)

			enh_alt_irq_enable_all();
   1b0b0:	003c2000 	call	3c200 <enh_alt_irq_enable_all>

#if LWIP_RECEIVE_SEMAPHORE
			// we can't use the LwIP sys_signal_sem since this can't be used in an ISR
			// release the semaphore and check if a task with a higher priority then the current one is waiting for it
			xSemaphoreGiveFromISR(ethernetif->tse_info->rx_semaphore, &switch_context);
   1b0b4:	e0bfff17 	ldw	r2,-4(fp)
   1b0b8:	10801717 	ldw	r2,92(r2)
   1b0bc:	10c00817 	ldw	r3,32(r2)
   1b0c0:	e0bffe04 	addi	r2,fp,-8
   1b0c4:	1809883a 	mov	r4,r3
   1b0c8:	000b883a 	mov	r5,zero
   1b0cc:	100d883a 	mov	r6,r2
   1b0d0:	000f883a 	mov	r7,zero
   1b0d4:	000eb0c0 	call	eb0c <xQueueGenericSendFromISR>
#endif
		}
	}

	uncached_packet_payload = (alt_u32 *) ethernetif->lwipRxPbuf[ethernetif->lwipRxIndexIsr]->payload;
   1b0d8:	e0bfff17 	ldw	r2,-4(fp)
   1b0dc:	10801317 	ldw	r2,76(r2)
   1b0e0:	e0ffff17 	ldw	r3,-4(fp)
   1b0e4:	108001c4 	addi	r2,r2,7
   1b0e8:	1085883a 	add	r2,r2,r2
   1b0ec:	1085883a 	add	r2,r2,r2
   1b0f0:	1885883a 	add	r2,r3,r2
   1b0f4:	10800017 	ldw	r2,0(r2)
   1b0f8:	10800117 	ldw	r2,4(r2)
   1b0fc:	e0bffd15 	stw	r2,-12(fp)
	alt_avalon_sgdma_construct_stream_to_mem_desc(
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],	// descriptor I want to work with
   1b100:	e0bffa17 	ldw	r2,-24(fp)
   1b104:	10800517 	ldw	r2,20(r2)
#endif
		}
	}

	uncached_packet_payload = (alt_u32 *) ethernetif->lwipRxPbuf[ethernetif->lwipRxIndexIsr]->payload;
	alt_avalon_sgdma_construct_stream_to_mem_desc(
   1b108:	10c01004 	addi	r3,r2,64
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],	// descriptor I want to work with
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST],  // pointer to "next"
   1b10c:	e0bffa17 	ldw	r2,-24(fp)
   1b110:	10800517 	ldw	r2,20(r2)
#endif
		}
	}

	uncached_packet_payload = (alt_u32 *) ethernetif->lwipRxPbuf[ethernetif->lwipRxIndexIsr]->payload;
	alt_avalon_sgdma_construct_stream_to_mem_desc(
   1b114:	10801804 	addi	r2,r2,96
   1b118:	d8000015 	stw	zero,0(sp)
   1b11c:	1809883a 	mov	r4,r3
   1b120:	100b883a 	mov	r5,r2
   1b124:	e1bffd17 	ldw	r6,-12(fp)
   1b128:	000f883a 	mov	r7,zero
   1b12c:	00354580 	call	35458 <alt_avalon_sgdma_construct_stream_to_mem_desc>
			0,                                  											// read until EOP
			0);          																	// don't write to constant address

#if LWIP_RECEIVE_SEMAPHORE
	// if it's waiting we will force a context switch so this task will run right away
	portEND_SWITCHING_ISR(switch_context);
   1b130:	e0bffe17 	ldw	r2,-8(fp)
   1b134:	10000126 	beq	r2,zero,1b13c <tse_mac_rcv+0x1c0>
   1b138:	00103c00 	call	103c0 <vTaskSwitchContext>
#endif

	return ERR_OK;
   1b13c:	0005883a 	mov	r2,zero
}
   1b140:	e037883a 	mov	sp,fp
   1b144:	dfc00117 	ldw	ra,4(sp)
   1b148:	df000017 	ldw	fp,0(sp)
   1b14c:	dec00204 	addi	sp,sp,8
   1b150:	f800283a 	ret

0001b154 <sys_init>:
#include <lwip/err.h>
#include <lwip/stats.h>

// LwIP FreeRTOS port
void sys_init(void)
{
   1b154:	deffff04 	addi	sp,sp,-4
   1b158:	df000015 	stw	fp,0(sp)
   1b15c:	d839883a 	mov	fp,sp
	return;
   1b160:	0001883a 	nop
}
   1b164:	e037883a 	mov	sp,fp
   1b168:	df000017 	ldw	fp,0(sp)
   1b16c:	dec00104 	addi	sp,sp,4
   1b170:	f800283a 	ret

0001b174 <sys_now>:

u32_t sys_now(void)
{
   1b174:	defffc04 	addi	sp,sp,-16
   1b178:	dfc00315 	stw	ra,12(sp)
   1b17c:	df000215 	stw	fp,8(sp)
   1b180:	df000204 	addi	fp,sp,8
	struct timeval tv;
	gettimeofday(&tv, NULL);
   1b184:	e13ffe04 	addi	r4,fp,-8
   1b188:	000b883a 	mov	r5,zero
   1b18c:	003cc140 	call	3cc14 <gettimeofday>

	return ((tv.tv_sec * 1000) + (tv.tv_usec / 1000));
   1b190:	e0bffe17 	ldw	r2,-8(fp)
   1b194:	10c0fa24 	muli	r3,r2,1000
   1b198:	e13fff17 	ldw	r4,-4(fp)
   1b19c:	0080fa04 	movi	r2,1000
   1b1a0:	2085283a 	div	r2,r4,r2
   1b1a4:	1885883a 	add	r2,r3,r2
}
   1b1a8:	e037883a 	mov	sp,fp
   1b1ac:	dfc00117 	ldw	ra,4(sp)
   1b1b0:	df000017 	ldw	fp,0(sp)
   1b1b4:	dec00204 	addi	sp,sp,8
   1b1b8:	f800283a 	ret

0001b1bc <sys_sem_new>:
/**
 * Creates and returns a new semaphore. The "count" argument specifies
 * the initial state of the semaphore.
 */
err_t sys_sem_new(sys_sem_t *sem, u8_t count)
{
   1b1bc:	defffc04 	addi	sp,sp,-16
   1b1c0:	dfc00315 	stw	ra,12(sp)
   1b1c4:	df000215 	stw	fp,8(sp)
   1b1c8:	df000204 	addi	fp,sp,8
   1b1cc:	e13ffe15 	stw	r4,-8(fp)
   1b1d0:	2805883a 	mov	r2,r5
   1b1d4:	e0bfff05 	stb	r2,-4(fp)
	// count 0 means a binary semaphore so max value should be 1
	*sem = xSemaphoreCreateCounting((count ? count : 1), count);
   1b1d8:	e0bfff03 	ldbu	r2,-4(fp)
   1b1dc:	10000226 	beq	r2,zero,1b1e8 <sys_sem_new+0x2c>
   1b1e0:	e0bfff03 	ldbu	r2,-4(fp)
   1b1e4:	00000106 	br	1b1ec <sys_sem_new+0x30>
   1b1e8:	00800044 	movi	r2,1
   1b1ec:	e0ffff03 	ldbu	r3,-4(fp)
   1b1f0:	1009883a 	mov	r4,r2
   1b1f4:	180b883a 	mov	r5,r3
   1b1f8:	000e9040 	call	e904 <xQueueCreateCountingSemaphore>
   1b1fc:	e0fffe17 	ldw	r3,-8(fp)
   1b200:	18800015 	stw	r2,0(r3)

	if (*sem == NULL) {
   1b204:	e0bffe17 	ldw	r2,-8(fp)
   1b208:	10800017 	ldw	r2,0(r2)
   1b20c:	1000091e 	bne	r2,zero,1b234 <sys_sem_new+0x78>
		SYS_STATS_INC(sem.err);
   1b210:	008001f4 	movhi	r2,7
   1b214:	10ac6e04 	addi	r2,r2,-20040
   1b218:	10809617 	ldw	r2,600(r2)
   1b21c:	10c00044 	addi	r3,r2,1
   1b220:	008001f4 	movhi	r2,7
   1b224:	10ac6e04 	addi	r2,r2,-20040
   1b228:	10c09615 	stw	r3,600(r2)
		return ERR_MEM;  // TBD need assert
   1b22c:	00bfffc4 	movi	r2,-1
   1b230:	00001506 	br	1b288 <sys_sem_new+0xcc>
	}

	SYS_STATS_INC_USED(sem);
   1b234:	008001f4 	movhi	r2,7
   1b238:	10ac6e04 	addi	r2,r2,-20040
   1b23c:	10809417 	ldw	r2,592(r2)
   1b240:	10c00044 	addi	r3,r2,1
   1b244:	008001f4 	movhi	r2,7
   1b248:	10ac6e04 	addi	r2,r2,-20040
   1b24c:	10c09415 	stw	r3,592(r2)
   1b250:	008001f4 	movhi	r2,7
   1b254:	10ac6e04 	addi	r2,r2,-20040
   1b258:	10c09517 	ldw	r3,596(r2)
   1b25c:	008001f4 	movhi	r2,7
   1b260:	10ac6e04 	addi	r2,r2,-20040
   1b264:	10809417 	ldw	r2,592(r2)
   1b268:	1880062e 	bgeu	r3,r2,1b284 <sys_sem_new+0xc8>
   1b26c:	008001f4 	movhi	r2,7
   1b270:	10ac6e04 	addi	r2,r2,-20040
   1b274:	10c09417 	ldw	r3,592(r2)
   1b278:	008001f4 	movhi	r2,7
   1b27c:	10ac6e04 	addi	r2,r2,-20040
   1b280:	10c09515 	stw	r3,596(r2)

	return ERR_OK;
   1b284:	0005883a 	mov	r2,zero
}
   1b288:	e037883a 	mov	sp,fp
   1b28c:	dfc00117 	ldw	ra,4(sp)
   1b290:	df000017 	ldw	fp,0(sp)
   1b294:	dec00204 	addi	sp,sp,8
   1b298:	f800283a 	ret

0001b29c <sys_sem_free>:

/**
 * Deallocates a semaphore.
 */
void sys_sem_free(sys_sem_t *sem)
{
   1b29c:	defffd04 	addi	sp,sp,-12
   1b2a0:	dfc00215 	stw	ra,8(sp)
   1b2a4:	df000115 	stw	fp,4(sp)
   1b2a8:	df000104 	addi	fp,sp,4
   1b2ac:	e13fff15 	stw	r4,-4(fp)
	vQueueDelete(*sem);
   1b2b0:	e0bfff17 	ldw	r2,-4(fp)
   1b2b4:	10800017 	ldw	r2,0(r2)
   1b2b8:	1009883a 	mov	r4,r2
   1b2bc:	000ef740 	call	ef74 <vQueueDelete>

	SYS_STATS_DEC(sem.used);
   1b2c0:	008001f4 	movhi	r2,7
   1b2c4:	10ac6e04 	addi	r2,r2,-20040
   1b2c8:	10809417 	ldw	r2,592(r2)
   1b2cc:	10ffffc4 	addi	r3,r2,-1
   1b2d0:	008001f4 	movhi	r2,7
   1b2d4:	10ac6e04 	addi	r2,r2,-20040
   1b2d8:	10c09415 	stw	r3,592(r2)
}
   1b2dc:	e037883a 	mov	sp,fp
   1b2e0:	dfc00117 	ldw	ra,4(sp)
   1b2e4:	df000017 	ldw	fp,0(sp)
   1b2e8:	dec00204 	addi	sp,sp,8
   1b2ec:	f800283a 	ret

0001b2f0 <sys_sem_signal>:

/**
 * Signals a semaphore.
 */
void sys_sem_signal(sys_sem_t *sem)
{
   1b2f0:	defffd04 	addi	sp,sp,-12
   1b2f4:	dfc00215 	stw	ra,8(sp)
   1b2f8:	df000115 	stw	fp,4(sp)
   1b2fc:	df000104 	addi	fp,sp,4
   1b300:	e13fff15 	stw	r4,-4(fp)
	xSemaphoreGive(*sem);
   1b304:	e0bfff17 	ldw	r2,-4(fp)
   1b308:	10800017 	ldw	r2,0(r2)
   1b30c:	1009883a 	mov	r4,r2
   1b310:	000b883a 	mov	r5,zero
   1b314:	000d883a 	mov	r6,zero
   1b318:	000f883a 	mov	r7,zero
   1b31c:	000e95c0 	call	e95c <xQueueGenericSend>
}
   1b320:	e037883a 	mov	sp,fp
   1b324:	dfc00117 	ldw	ra,4(sp)
   1b328:	df000017 	ldw	fp,0(sp)
   1b32c:	dec00204 	addi	sp,sp,8
   1b330:	f800283a 	ret

0001b334 <sys_arch_sem_wait>:
 *
 * Notice that lwIP implements a function with a similar name,
 * sys_sem_wait(), that uses the sys_arch_sem_wait() function.
 */
u32_t sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout)
{
   1b334:	defff904 	addi	sp,sp,-28
   1b338:	dfc00615 	stw	ra,24(sp)
   1b33c:	df000515 	stw	fp,20(sp)
   1b340:	df000504 	addi	fp,sp,20
   1b344:	e13ffe15 	stw	r4,-8(fp)
   1b348:	e17fff15 	stw	r5,-4(fp)
	portTickType nStartTime, nEndTime, nElapsed;

	nStartTime = xTaskGetTickCount();
   1b34c:	001006c0 	call	1006c <xTaskGetTickCount>
   1b350:	e0bffc15 	stw	r2,-16(fp)

	if (timeout != 0)
   1b354:	e0bfff17 	ldw	r2,-4(fp)
   1b358:	10001726 	beq	r2,zero,1b3b8 <sys_arch_sem_wait+0x84>
	{
		if (xSemaphoreTake(*sem, timeout) == pdTRUE)
   1b35c:	e0bffe17 	ldw	r2,-8(fp)
   1b360:	10800017 	ldw	r2,0(r2)
   1b364:	1009883a 	mov	r4,r2
   1b368:	000b883a 	mov	r5,zero
   1b36c:	e1bfff17 	ldw	r6,-4(fp)
   1b370:	000f883a 	mov	r7,zero
   1b374:	000ebd80 	call	ebd8 <xQueueGenericReceive>
   1b378:	10800058 	cmpnei	r2,r2,1
   1b37c:	10000c1e 	bne	r2,zero,1b3b0 <sys_arch_sem_wait+0x7c>
		{
			nEndTime = xTaskGetTickCount();
   1b380:	001006c0 	call	1006c <xTaskGetTickCount>
   1b384:	e0bffd15 	stw	r2,-12(fp)
			nElapsed = nEndTime - nStartTime;
   1b388:	e0fffd17 	ldw	r3,-12(fp)
   1b38c:	e0bffc17 	ldw	r2,-16(fp)
   1b390:	1885c83a 	sub	r2,r3,r2
   1b394:	e0bffb15 	stw	r2,-20(fp)

			if (nElapsed == 0)
   1b398:	e0bffb17 	ldw	r2,-20(fp)
   1b39c:	1000021e 	bne	r2,zero,1b3a8 <sys_arch_sem_wait+0x74>
				nElapsed = 1;
   1b3a0:	00800044 	movi	r2,1
   1b3a4:	e0bffb15 	stw	r2,-20(fp)

			return nElapsed; // return time blocked TBD test
   1b3a8:	e0bffb17 	ldw	r2,-20(fp)
   1b3ac:	00001706 	br	1b40c <sys_arch_sem_wait+0xd8>
		}
		else
			return SYS_ARCH_TIMEOUT;
   1b3b0:	00bfffc4 	movi	r2,-1
   1b3b4:	00001506 	br	1b40c <sys_arch_sem_wait+0xd8>
	}
	else // must block without a timeout
	{
		while (xSemaphoreTake(*sem, 10000) != pdTRUE);
   1b3b8:	0001883a 	nop
   1b3bc:	e0bffe17 	ldw	r2,-8(fp)
   1b3c0:	10800017 	ldw	r2,0(r2)
   1b3c4:	1009883a 	mov	r4,r2
   1b3c8:	000b883a 	mov	r5,zero
   1b3cc:	0189c404 	movi	r6,10000
   1b3d0:	000f883a 	mov	r7,zero
   1b3d4:	000ebd80 	call	ebd8 <xQueueGenericReceive>
   1b3d8:	10800058 	cmpnei	r2,r2,1
   1b3dc:	103ff71e 	bne	r2,zero,1b3bc <sys_arch_sem_wait+0x88>

		nEndTime = xTaskGetTickCount();
   1b3e0:	001006c0 	call	1006c <xTaskGetTickCount>
   1b3e4:	e0bffd15 	stw	r2,-12(fp)
		nElapsed = nEndTime - nStartTime;
   1b3e8:	e0fffd17 	ldw	r3,-12(fp)
   1b3ec:	e0bffc17 	ldw	r2,-16(fp)
   1b3f0:	1885c83a 	sub	r2,r3,r2
   1b3f4:	e0bffb15 	stw	r2,-20(fp)
		if( nElapsed == 0 )
   1b3f8:	e0bffb17 	ldw	r2,-20(fp)
   1b3fc:	1000021e 	bne	r2,zero,1b408 <sys_arch_sem_wait+0xd4>
			nElapsed = 1;
   1b400:	00800044 	movi	r2,1
   1b404:	e0bffb15 	stw	r2,-20(fp)

		return nElapsed; // return time blocked
   1b408:	e0bffb17 	ldw	r2,-20(fp)
	}
}
   1b40c:	e037883a 	mov	sp,fp
   1b410:	dfc00117 	ldw	ra,4(sp)
   1b414:	df000017 	ldw	fp,0(sp)
   1b418:	dec00204 	addi	sp,sp,8
   1b41c:	f800283a 	ret

0001b420 <sys_mutex_new>:
#if ! LWIP_COMPAT_MUTEX
/** Create a new mutex
 * @param mutex pointer to the mutex to create
 * @return a new mutex */
err_t sys_mutex_new(sys_mutex_t *mutex)
{
   1b420:	defffd04 	addi	sp,sp,-12
   1b424:	dfc00215 	stw	ra,8(sp)
   1b428:	df000115 	stw	fp,4(sp)
   1b42c:	df000104 	addi	fp,sp,4
   1b430:	e13fff15 	stw	r4,-4(fp)
	*mutex = xSemaphoreCreateMutex();
   1b434:	01000044 	movi	r4,1
   1b438:	000e7040 	call	e704 <xQueueCreateMutex>
   1b43c:	e0ffff17 	ldw	r3,-4(fp)
   1b440:	18800015 	stw	r2,0(r3)

	if (!*mutex) {
   1b444:	e0bfff17 	ldw	r2,-4(fp)
   1b448:	10800017 	ldw	r2,0(r2)
   1b44c:	1000091e 	bne	r2,zero,1b474 <sys_mutex_new+0x54>
		SYS_STATS_INC(mutex.err);
   1b450:	008001f4 	movhi	r2,7
   1b454:	10ac6e04 	addi	r2,r2,-20040
   1b458:	10809917 	ldw	r2,612(r2)
   1b45c:	10c00044 	addi	r3,r2,1
   1b460:	008001f4 	movhi	r2,7
   1b464:	10ac6e04 	addi	r2,r2,-20040
   1b468:	10c09915 	stw	r3,612(r2)
		return ERR_MEM;
   1b46c:	00bfffc4 	movi	r2,-1
   1b470:	00001506 	br	1b4c8 <sys_mutex_new+0xa8>
	}

	SYS_STATS_INC_USED(mutex);
   1b474:	008001f4 	movhi	r2,7
   1b478:	10ac6e04 	addi	r2,r2,-20040
   1b47c:	10809717 	ldw	r2,604(r2)
   1b480:	10c00044 	addi	r3,r2,1
   1b484:	008001f4 	movhi	r2,7
   1b488:	10ac6e04 	addi	r2,r2,-20040
   1b48c:	10c09715 	stw	r3,604(r2)
   1b490:	008001f4 	movhi	r2,7
   1b494:	10ac6e04 	addi	r2,r2,-20040
   1b498:	10c09817 	ldw	r3,608(r2)
   1b49c:	008001f4 	movhi	r2,7
   1b4a0:	10ac6e04 	addi	r2,r2,-20040
   1b4a4:	10809717 	ldw	r2,604(r2)
   1b4a8:	1880062e 	bgeu	r3,r2,1b4c4 <sys_mutex_new+0xa4>
   1b4ac:	008001f4 	movhi	r2,7
   1b4b0:	10ac6e04 	addi	r2,r2,-20040
   1b4b4:	10c09717 	ldw	r3,604(r2)
   1b4b8:	008001f4 	movhi	r2,7
   1b4bc:	10ac6e04 	addi	r2,r2,-20040
   1b4c0:	10c09815 	stw	r3,608(r2)

	return ERR_OK;
   1b4c4:	0005883a 	mov	r2,zero
}
   1b4c8:	e037883a 	mov	sp,fp
   1b4cc:	dfc00117 	ldw	ra,4(sp)
   1b4d0:	df000017 	ldw	fp,0(sp)
   1b4d4:	dec00204 	addi	sp,sp,8
   1b4d8:	f800283a 	ret

0001b4dc <sys_mutex_lock>:

/** Lock a mutex
 * @param mutex the mutex to lock */
void sys_mutex_lock(sys_mutex_t *mutex)
{
   1b4dc:	defffd04 	addi	sp,sp,-12
   1b4e0:	dfc00215 	stw	ra,8(sp)
   1b4e4:	df000115 	stw	fp,4(sp)
   1b4e8:	df000104 	addi	fp,sp,4
   1b4ec:	e13fff15 	stw	r4,-4(fp)
	// wait on mutex forever
	while (xSemaphoreTake(*mutex, 10000) != pdTRUE);
   1b4f0:	0001883a 	nop
   1b4f4:	e0bfff17 	ldw	r2,-4(fp)
   1b4f8:	10800017 	ldw	r2,0(r2)
   1b4fc:	1009883a 	mov	r4,r2
   1b500:	000b883a 	mov	r5,zero
   1b504:	0189c404 	movi	r6,10000
   1b508:	000f883a 	mov	r7,zero
   1b50c:	000ebd80 	call	ebd8 <xQueueGenericReceive>
   1b510:	10800058 	cmpnei	r2,r2,1
   1b514:	103ff71e 	bne	r2,zero,1b4f4 <sys_mutex_lock+0x18>
}
   1b518:	e037883a 	mov	sp,fp
   1b51c:	dfc00117 	ldw	ra,4(sp)
   1b520:	df000017 	ldw	fp,0(sp)
   1b524:	dec00204 	addi	sp,sp,8
   1b528:	f800283a 	ret

0001b52c <sys_mutex_unlock>:

/** Unlock a mutex
 * @param mutex the mutex to unlock */
void sys_mutex_unlock(sys_mutex_t *mutex)
{
   1b52c:	defffd04 	addi	sp,sp,-12
   1b530:	dfc00215 	stw	ra,8(sp)
   1b534:	df000115 	stw	fp,4(sp)
   1b538:	df000104 	addi	fp,sp,4
   1b53c:	e13fff15 	stw	r4,-4(fp)
	xSemaphoreGive(*mutex);
   1b540:	e0bfff17 	ldw	r2,-4(fp)
   1b544:	10800017 	ldw	r2,0(r2)
   1b548:	1009883a 	mov	r4,r2
   1b54c:	000b883a 	mov	r5,zero
   1b550:	000d883a 	mov	r6,zero
   1b554:	000f883a 	mov	r7,zero
   1b558:	000e95c0 	call	e95c <xQueueGenericSend>
}
   1b55c:	e037883a 	mov	sp,fp
   1b560:	dfc00117 	ldw	ra,4(sp)
   1b564:	df000017 	ldw	fp,0(sp)
   1b568:	dec00204 	addi	sp,sp,8
   1b56c:	f800283a 	ret

0001b570 <sys_mutex_free>:

/** Delete a semaphore
 * @param mutex the mutex to delete */
void sys_mutex_free(sys_mutex_t *mutex)
{
   1b570:	defffd04 	addi	sp,sp,-12
   1b574:	dfc00215 	stw	ra,8(sp)
   1b578:	df000115 	stw	fp,4(sp)
   1b57c:	df000104 	addi	fp,sp,4
   1b580:	e13fff15 	stw	r4,-4(fp)
	vQueueDelete(*mutex);
   1b584:	e0bfff17 	ldw	r2,-4(fp)
   1b588:	10800017 	ldw	r2,0(r2)
   1b58c:	1009883a 	mov	r4,r2
   1b590:	000ef740 	call	ef74 <vQueueDelete>
	SYS_STATS_DEC(mutex.used);
   1b594:	008001f4 	movhi	r2,7
   1b598:	10ac6e04 	addi	r2,r2,-20040
   1b59c:	10809717 	ldw	r2,604(r2)
   1b5a0:	10ffffc4 	addi	r3,r2,-1
   1b5a4:	008001f4 	movhi	r2,7
   1b5a8:	10ac6e04 	addi	r2,r2,-20040
   1b5ac:	10c09715 	stw	r3,604(r2)
}
   1b5b0:	e037883a 	mov	sp,fp
   1b5b4:	dfc00117 	ldw	ra,4(sp)
   1b5b8:	df000017 	ldw	fp,0(sp)
   1b5bc:	dec00204 	addi	sp,sp,8
   1b5c0:	f800283a 	ret

0001b5c4 <sys_mbox_new>:
 * in mailboxes are pointers. You have to define macros "_MBOX_SIZE"
 * in your lwipopts.h, or ignore this parameter in your implementation
 * and use a default size.
 */
err_t sys_mbox_new(sys_mbox_t *mbox, int size)
{
   1b5c4:	defffc04 	addi	sp,sp,-16
   1b5c8:	dfc00315 	stw	ra,12(sp)
   1b5cc:	df000215 	stw	fp,8(sp)
   1b5d0:	df000204 	addi	fp,sp,8
   1b5d4:	e13ffe15 	stw	r4,-8(fp)
   1b5d8:	e17fff15 	stw	r5,-4(fp)
	*mbox = xQueueCreate(size, sizeof(void *)); // XXX correct? We are posting pointers so I guess it is...
   1b5dc:	e0bfff17 	ldw	r2,-4(fp)
   1b5e0:	1009883a 	mov	r4,r2
   1b5e4:	01400104 	movi	r5,4
   1b5e8:	000d883a 	mov	r6,zero
   1b5ec:	000e6380 	call	e638 <xQueueGenericCreate>
   1b5f0:	e0fffe17 	ldw	r3,-8(fp)
   1b5f4:	18800015 	stw	r2,0(r3)

	if (!*mbox) {
   1b5f8:	e0bffe17 	ldw	r2,-8(fp)
   1b5fc:	10800017 	ldw	r2,0(r2)
   1b600:	1000091e 	bne	r2,zero,1b628 <sys_mbox_new+0x64>
		SYS_STATS_INC(mbox.err);
   1b604:	008001f4 	movhi	r2,7
   1b608:	10ac6e04 	addi	r2,r2,-20040
   1b60c:	10809c17 	ldw	r2,624(r2)
   1b610:	10c00044 	addi	r3,r2,1
   1b614:	008001f4 	movhi	r2,7
   1b618:	10ac6e04 	addi	r2,r2,-20040
   1b61c:	10c09c15 	stw	r3,624(r2)
		return ERR_MEM;
   1b620:	00bfffc4 	movi	r2,-1
   1b624:	00001506 	br	1b67c <sys_mbox_new+0xb8>
	}

	SYS_STATS_INC_USED(mbox);
   1b628:	008001f4 	movhi	r2,7
   1b62c:	10ac6e04 	addi	r2,r2,-20040
   1b630:	10809a17 	ldw	r2,616(r2)
   1b634:	10c00044 	addi	r3,r2,1
   1b638:	008001f4 	movhi	r2,7
   1b63c:	10ac6e04 	addi	r2,r2,-20040
   1b640:	10c09a15 	stw	r3,616(r2)
   1b644:	008001f4 	movhi	r2,7
   1b648:	10ac6e04 	addi	r2,r2,-20040
   1b64c:	10c09b17 	ldw	r3,620(r2)
   1b650:	008001f4 	movhi	r2,7
   1b654:	10ac6e04 	addi	r2,r2,-20040
   1b658:	10809a17 	ldw	r2,616(r2)
   1b65c:	1880062e 	bgeu	r3,r2,1b678 <sys_mbox_new+0xb4>
   1b660:	008001f4 	movhi	r2,7
   1b664:	10ac6e04 	addi	r2,r2,-20040
   1b668:	10c09a17 	ldw	r3,616(r2)
   1b66c:	008001f4 	movhi	r2,7
   1b670:	10ac6e04 	addi	r2,r2,-20040
   1b674:	10c09b15 	stw	r3,620(r2)

	return ERR_OK;
   1b678:	0005883a 	mov	r2,zero
}
   1b67c:	e037883a 	mov	sp,fp
   1b680:	dfc00117 	ldw	ra,4(sp)
   1b684:	df000017 	ldw	fp,0(sp)
   1b688:	dec00204 	addi	sp,sp,8
   1b68c:	f800283a 	ret

0001b690 <sys_mbox_free>:
 * Deallocates a mailbox. If there are messages still present in the
 * mailbox when the mailbox is deallocated, it is an indication of a
 * programming error in lwIP and the developer should be notified.
 */
void sys_mbox_free(sys_mbox_t *mbox)
{
   1b690:	defffd04 	addi	sp,sp,-12
   1b694:	dfc00215 	stw	ra,8(sp)
   1b698:	df000115 	stw	fp,4(sp)
   1b69c:	df000104 	addi	fp,sp,4
   1b6a0:	e13fff15 	stw	r4,-4(fp)
	if (uxQueueMessagesWaiting(*mbox))
   1b6a4:	e0bfff17 	ldw	r2,-4(fp)
   1b6a8:	10800017 	ldw	r2,0(r2)
   1b6ac:	1009883a 	mov	r4,r2
   1b6b0:	000eef40 	call	eef4 <uxQueueMessagesWaiting>
   1b6b4:	10000126 	beq	r2,zero,1b6bc <sys_mbox_free+0x2c>
	{
		// Line for breakpoint.  Should never break here!
		__asm__ __volatile__ ( "nop" );
   1b6b8:	0001883a 	nop
	}

	vQueueDelete(*mbox);
   1b6bc:	e0bfff17 	ldw	r2,-4(fp)
   1b6c0:	10800017 	ldw	r2,0(r2)
   1b6c4:	1009883a 	mov	r4,r2
   1b6c8:	000ef740 	call	ef74 <vQueueDelete>

	SYS_STATS_DEC(mbox.used);
   1b6cc:	008001f4 	movhi	r2,7
   1b6d0:	10ac6e04 	addi	r2,r2,-20040
   1b6d4:	10809a17 	ldw	r2,616(r2)
   1b6d8:	10ffffc4 	addi	r3,r2,-1
   1b6dc:	008001f4 	movhi	r2,7
   1b6e0:	10ac6e04 	addi	r2,r2,-20040
   1b6e4:	10c09a15 	stw	r3,616(r2)
}
   1b6e8:	e037883a 	mov	sp,fp
   1b6ec:	dfc00117 	ldw	ra,4(sp)
   1b6f0:	df000017 	ldw	fp,0(sp)
   1b6f4:	dec00204 	addi	sp,sp,8
   1b6f8:	f800283a 	ret

0001b6fc <sys_mbox_post>:
/**
 * Posts the "msg" to the mailbox. This function have to block until
 * the "msg" is really posted.
 */
void sys_mbox_post(sys_mbox_t *mbox, void *data)
{
   1b6fc:	defffc04 	addi	sp,sp,-16
   1b700:	dfc00315 	stw	ra,12(sp)
   1b704:	df000215 	stw	fp,8(sp)
   1b708:	df000204 	addi	fp,sp,8
   1b70c:	e13ffe15 	stw	r4,-8(fp)
   1b710:	e17fff15 	stw	r5,-4(fp)
	xQueueSend(*mbox, &data, (portTickType)(archPOST_BLOCK_TIME_MS / portTICK_RATE_MS));
   1b714:	e0bffe17 	ldw	r2,-8(fp)
   1b718:	10c00017 	ldw	r3,0(r2)
   1b71c:	e0bfff04 	addi	r2,fp,-4
   1b720:	1809883a 	mov	r4,r3
   1b724:	100b883a 	mov	r5,r2
   1b728:	0189c404 	movi	r6,10000
   1b72c:	000f883a 	mov	r7,zero
   1b730:	000e95c0 	call	e95c <xQueueGenericSend>
}
   1b734:	e037883a 	mov	sp,fp
   1b738:	dfc00117 	ldw	ra,4(sp)
   1b73c:	df000017 	ldw	fp,0(sp)
   1b740:	dec00204 	addi	sp,sp,8
   1b744:	f800283a 	ret

0001b748 <sys_mbox_trypost>:
/**
 * Try to post the "msg" to the mailbox. Returns ERR_MEM if this one
 * is full, else, ERR_OK if the "msg" is posted.
 */
err_t sys_mbox_trypost(sys_mbox_t *mbox, void *data)
{
   1b748:	defffc04 	addi	sp,sp,-16
   1b74c:	dfc00315 	stw	ra,12(sp)
   1b750:	df000215 	stw	fp,8(sp)
   1b754:	df000204 	addi	fp,sp,8
   1b758:	e13ffe15 	stw	r4,-8(fp)
   1b75c:	e17fff15 	stw	r5,-4(fp)
	return (xQueueSend(*mbox, &data, 0) == pdTRUE) ? ERR_OK : ERR_MEM;
   1b760:	e0bffe17 	ldw	r2,-8(fp)
   1b764:	10c00017 	ldw	r3,0(r2)
   1b768:	e0bfff04 	addi	r2,fp,-4
   1b76c:	1809883a 	mov	r4,r3
   1b770:	100b883a 	mov	r5,r2
   1b774:	000d883a 	mov	r6,zero
   1b778:	000f883a 	mov	r7,zero
   1b77c:	000e95c0 	call	e95c <xQueueGenericSend>
   1b780:	10800058 	cmpnei	r2,r2,1
   1b784:	1000021e 	bne	r2,zero,1b790 <sys_mbox_trypost+0x48>
   1b788:	0005883a 	mov	r2,zero
   1b78c:	00000106 	br	1b794 <sys_mbox_trypost+0x4c>
   1b790:	00bfffc4 	movi	r2,-1
}
   1b794:	e037883a 	mov	sp,fp
   1b798:	dfc00117 	ldw	ra,4(sp)
   1b79c:	df000017 	ldw	fp,0(sp)
   1b7a0:	dec00204 	addi	sp,sp,8
   1b7a4:	f800283a 	ret

0001b7a8 <sys_arch_mbox_fetch>:
 *
 * Note that a function with a similar name, sys_mbox_fetch(), is
 * implemented by lwIP.
 */
u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout)
{
   1b7a8:	defff704 	addi	sp,sp,-36
   1b7ac:	dfc00815 	stw	ra,32(sp)
   1b7b0:	df000715 	stw	fp,28(sp)
   1b7b4:	df000704 	addi	fp,sp,28
   1b7b8:	e13ffd15 	stw	r4,-12(fp)
   1b7bc:	e17ffe15 	stw	r5,-8(fp)
   1b7c0:	e1bfff15 	stw	r6,-4(fp)
	void *dummyptr;
	portTickType nStartTime, nEndTime, nElapsed;

	nStartTime = xTaskGetTickCount();
   1b7c4:	001006c0 	call	1006c <xTaskGetTickCount>
   1b7c8:	e0bffa15 	stw	r2,-24(fp)

	if (msg == NULL)
   1b7cc:	e0bffe17 	ldw	r2,-8(fp)
   1b7d0:	1000021e 	bne	r2,zero,1b7dc <sys_arch_mbox_fetch+0x34>
		msg = &dummyptr;
   1b7d4:	e0bffc04 	addi	r2,fp,-16
   1b7d8:	e0bffe15 	stw	r2,-8(fp)

	if (timeout != 0)
   1b7dc:	e0bfff17 	ldw	r2,-4(fp)
   1b7e0:	10001926 	beq	r2,zero,1b848 <sys_arch_mbox_fetch+0xa0>
	{
		if (pdTRUE == xQueueReceive(*mbox, msg, timeout))
   1b7e4:	e0bffd17 	ldw	r2,-12(fp)
   1b7e8:	10800017 	ldw	r2,0(r2)
   1b7ec:	1009883a 	mov	r4,r2
   1b7f0:	e17ffe17 	ldw	r5,-8(fp)
   1b7f4:	e1bfff17 	ldw	r6,-4(fp)
   1b7f8:	000f883a 	mov	r7,zero
   1b7fc:	000ebd80 	call	ebd8 <xQueueGenericReceive>
   1b800:	10800058 	cmpnei	r2,r2,1
   1b804:	10000c1e 	bne	r2,zero,1b838 <sys_arch_mbox_fetch+0x90>
		{
			nEndTime = xTaskGetTickCount();
   1b808:	001006c0 	call	1006c <xTaskGetTickCount>
   1b80c:	e0bffb15 	stw	r2,-20(fp)
			nElapsed = nEndTime - nStartTime;
   1b810:	e0fffb17 	ldw	r3,-20(fp)
   1b814:	e0bffa17 	ldw	r2,-24(fp)
   1b818:	1885c83a 	sub	r2,r3,r2
   1b81c:	e0bff915 	stw	r2,-28(fp)

			if (nElapsed == 0)
   1b820:	e0bff917 	ldw	r2,-28(fp)
   1b824:	1000021e 	bne	r2,zero,1b830 <sys_arch_mbox_fetch+0x88>
				nElapsed = 1;
   1b828:	00800044 	movi	r2,1
   1b82c:	e0bff915 	stw	r2,-28(fp)

			return nElapsed;
   1b830:	e0bff917 	ldw	r2,-28(fp)
   1b834:	00001906 	br	1b89c <sys_arch_mbox_fetch+0xf4>
		}
		else // timed out blocking for message
		{
			*msg = NULL;
   1b838:	e0bffe17 	ldw	r2,-8(fp)
   1b83c:	10000015 	stw	zero,0(r2)
			return SYS_ARCH_TIMEOUT;
   1b840:	00bfffc4 	movi	r2,-1
   1b844:	00001506 	br	1b89c <sys_arch_mbox_fetch+0xf4>
		}
	}
	else // block forever for a message.
	{
		// wait on message forever
		while (pdTRUE != xQueueReceive(*mbox, msg, 10000));
   1b848:	0001883a 	nop
   1b84c:	e0bffd17 	ldw	r2,-12(fp)
   1b850:	10800017 	ldw	r2,0(r2)
   1b854:	1009883a 	mov	r4,r2
   1b858:	e17ffe17 	ldw	r5,-8(fp)
   1b85c:	0189c404 	movi	r6,10000
   1b860:	000f883a 	mov	r7,zero
   1b864:	000ebd80 	call	ebd8 <xQueueGenericReceive>
   1b868:	10800058 	cmpnei	r2,r2,1
   1b86c:	103ff71e 	bne	r2,zero,1b84c <sys_arch_mbox_fetch+0xa4>

		nEndTime = xTaskGetTickCount();
   1b870:	001006c0 	call	1006c <xTaskGetTickCount>
   1b874:	e0bffb15 	stw	r2,-20(fp)
		nElapsed = nEndTime - nStartTime;
   1b878:	e0fffb17 	ldw	r3,-20(fp)
   1b87c:	e0bffa17 	ldw	r2,-24(fp)
   1b880:	1885c83a 	sub	r2,r3,r2
   1b884:	e0bff915 	stw	r2,-28(fp)

		if (nElapsed == 0)
   1b888:	e0bff917 	ldw	r2,-28(fp)
   1b88c:	1000021e 	bne	r2,zero,1b898 <sys_arch_mbox_fetch+0xf0>
			nElapsed = 1;
   1b890:	00800044 	movi	r2,1
   1b894:	e0bff915 	stw	r2,-28(fp)

		return nElapsed; // return time blocked TBD test
   1b898:	e0bff917 	ldw	r2,-28(fp)
	}
}
   1b89c:	e037883a 	mov	sp,fp
   1b8a0:	dfc00117 	ldw	ra,4(sp)
   1b8a4:	df000017 	ldw	fp,0(sp)
   1b8a8:	dec00204 	addi	sp,sp,8
   1b8ac:	f800283a 	ret

0001b8b0 <sys_arch_mbox_tryfetch>:
 * #define sys_arch_mbox_tryfetch(mbox,msg) \
 * 		sys_arch_mbox_fetch(mbox,msg,1)
 * although this would introduce unnecessary delays.
 */
u32_t sys_arch_mbox_tryfetch(sys_mbox_t *mbox, void **msg)
{
   1b8b0:	defffb04 	addi	sp,sp,-20
   1b8b4:	dfc00415 	stw	ra,16(sp)
   1b8b8:	df000315 	stw	fp,12(sp)
   1b8bc:	df000304 	addi	fp,sp,12
   1b8c0:	e13ffe15 	stw	r4,-8(fp)
   1b8c4:	e17fff15 	stw	r5,-4(fp)
	void *dummyptr;

	if (msg == NULL)
   1b8c8:	e0bfff17 	ldw	r2,-4(fp)
   1b8cc:	1000021e 	bne	r2,zero,1b8d8 <sys_arch_mbox_tryfetch+0x28>
		msg = &dummyptr;
   1b8d0:	e0bffd04 	addi	r2,fp,-12
   1b8d4:	e0bfff15 	stw	r2,-4(fp)

	return (pdTRUE == xQueueReceive(*mbox, msg, 0)) ? 0 : SYS_MBOX_EMPTY;
   1b8d8:	e0bffe17 	ldw	r2,-8(fp)
   1b8dc:	10800017 	ldw	r2,0(r2)
   1b8e0:	1009883a 	mov	r4,r2
   1b8e4:	e17fff17 	ldw	r5,-4(fp)
   1b8e8:	000d883a 	mov	r6,zero
   1b8ec:	000f883a 	mov	r7,zero
   1b8f0:	000ebd80 	call	ebd8 <xQueueGenericReceive>
   1b8f4:	10800058 	cmpnei	r2,r2,1
   1b8f8:	1000021e 	bne	r2,zero,1b904 <sys_arch_mbox_tryfetch+0x54>
   1b8fc:	0005883a 	mov	r2,zero
   1b900:	00000106 	br	1b908 <sys_arch_mbox_tryfetch+0x58>
   1b904:	00bfffc4 	movi	r2,-1
}
   1b908:	e037883a 	mov	sp,fp
   1b90c:	dfc00117 	ldw	ra,4(sp)
   1b910:	df000017 	ldw	fp,0(sp)
   1b914:	dec00204 	addi	sp,sp,8
   1b918:	f800283a 	ret

0001b91c <sys_thread_new>:
 * argument to the thread() function. The stack size to used for this thread is
 * the "stacksize" parameter. The id of the new thread is returned. Both the id
 * and the priority are system dependent.
 */
sys_thread_t sys_thread_new(const char *name, lwip_thread_fn thread, void *arg, int stacksize, int prio)
{
   1b91c:	defff404 	addi	sp,sp,-48
   1b920:	dfc00b15 	stw	ra,44(sp)
   1b924:	df000a15 	stw	fp,40(sp)
   1b928:	df000a04 	addi	fp,sp,40
   1b92c:	e13ffc15 	stw	r4,-16(fp)
   1b930:	e17ffd15 	stw	r5,-12(fp)
   1b934:	e1bffe15 	stw	r6,-8(fp)
   1b938:	e1ffff15 	stw	r7,-4(fp)
	xTaskHandle objTask;
	int result = pdFAIL;
   1b93c:	e03ffa15 	stw	zero,-24(fp)

	result = xTaskCreate(thread, (signed portCHAR*)name, stacksize, arg, prio, &objTask);
   1b940:	e0bfff17 	ldw	r2,-4(fp)
   1b944:	10bfffcc 	andi	r2,r2,65535
   1b948:	e0c00217 	ldw	r3,8(fp)
   1b94c:	d8c00015 	stw	r3,0(sp)
   1b950:	e0fffb04 	addi	r3,fp,-20
   1b954:	d8c00115 	stw	r3,4(sp)
   1b958:	d8000215 	stw	zero,8(sp)
   1b95c:	d8000315 	stw	zero,12(sp)
   1b960:	e13ffd17 	ldw	r4,-12(fp)
   1b964:	e17ffc17 	ldw	r5,-16(fp)
   1b968:	100d883a 	mov	r6,r2
   1b96c:	e1fffe17 	ldw	r7,-8(fp)
   1b970:	000f5140 	call	f514 <xTaskGenericCreate>
   1b974:	e0bffa15 	stw	r2,-24(fp)

	return (result == pdPASS) ? objTask : NULL;
   1b978:	e0bffa17 	ldw	r2,-24(fp)
   1b97c:	10800058 	cmpnei	r2,r2,1
   1b980:	1000021e 	bne	r2,zero,1b98c <sys_thread_new+0x70>
   1b984:	e0bffb17 	ldw	r2,-20(fp)
   1b988:	00000106 	br	1b990 <sys_thread_new+0x74>
   1b98c:	0005883a 	mov	r2,zero
}
   1b990:	e037883a 	mov	sp,fp
   1b994:	dfc00117 	ldw	ra,4(sp)
   1b998:	df000017 	ldw	fp,0(sp)
   1b99c:	dec00204 	addi	sp,sp,8
   1b9a0:	f800283a 	ret

0001b9a4 <dhcp_clear_assignment>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_clear_assignment(struct netif *netif)
{
   1b9a4:	defffd04 	addi	sp,sp,-12
   1b9a8:	dfc00215 	stw	ra,8(sp)
   1b9ac:	df000115 	stw	fp,4(sp)
   1b9b0:	df000104 	addi	fp,sp,4
   1b9b4:	e13fff15 	stw	r4,-4(fp)
  netif_set_down(netif);
   1b9b8:	e13fff17 	ldw	r4,-4(fp)
   1b9bc:	0022c1c0 	call	22c1c <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
   1b9c0:	e13fff17 	ldw	r4,-4(fp)
   1b9c4:	01400134 	movhi	r5,4
   1b9c8:	2955cb04 	addi	r5,r5,22316
   1b9cc:	002298c0 	call	2298c <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
   1b9d0:	e13fff17 	ldw	r4,-4(fp)
   1b9d4:	01400134 	movhi	r5,4
   1b9d8:	2955cb04 	addi	r5,r5,22316
   1b9dc:	0022ac00 	call	22ac0 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
   1b9e0:	e13fff17 	ldw	r4,-4(fp)
   1b9e4:	01400134 	movhi	r5,4
   1b9e8:	2955cb04 	addi	r5,r5,22316
   1b9ec:	0022b040 	call	22b04 <netif_set_netmask>
}
   1b9f0:	e037883a 	mov	sp,fp
   1b9f4:	dfc00117 	ldw	ra,4(sp)
   1b9f8:	df000017 	ldw	fp,0(sp)
   1b9fc:	dec00204 	addi	sp,sp,8
   1ba00:	f800283a 	ret

0001ba04 <dhcp_handle_nak>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
   1ba04:	defffc04 	addi	sp,sp,-16
   1ba08:	dfc00315 	stw	ra,12(sp)
   1ba0c:	df000215 	stw	fp,8(sp)
   1ba10:	df000204 	addi	fp,sp,8
   1ba14:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
   1ba18:	e0bfff17 	ldw	r2,-4(fp)
   1ba1c:	10800a17 	ldw	r2,40(r2)
   1ba20:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  dhcp_clear_assignment(netif);
   1ba24:	e13fff17 	ldw	r4,-4(fp)
   1ba28:	001b9a40 	call	1b9a4 <dhcp_clear_assignment>
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
   1ba2c:	e13ffe17 	ldw	r4,-8(fp)
   1ba30:	01400304 	movi	r5,12
   1ba34:	001d5ec0 	call	1d5ec <dhcp_set_state>
  /* We can immediately restart discovery */
  dhcp_discover(netif);
   1ba38:	e13fff17 	ldw	r4,-4(fp)
   1ba3c:	001cb140 	call	1cb14 <dhcp_discover>
}
   1ba40:	e037883a 	mov	sp,fp
   1ba44:	dfc00117 	ldw	ra,4(sp)
   1ba48:	df000017 	ldw	fp,0(sp)
   1ba4c:	dec00204 	addi	sp,sp,8
   1ba50:	f800283a 	ret

0001ba54 <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
   1ba54:	defffb04 	addi	sp,sp,-20
   1ba58:	dfc00415 	stw	ra,16(sp)
   1ba5c:	df000315 	stw	fp,12(sp)
   1ba60:	df000304 	addi	fp,sp,12
   1ba64:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
   1ba68:	e0bfff17 	ldw	r2,-4(fp)
   1ba6c:	10800a17 	ldw	r2,40(r2)
   1ba70:	e0bffd15 	stw	r2,-12(fp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  dhcp_set_state(dhcp, DHCP_CHECKING);
   1ba74:	e13ffd17 	ldw	r4,-12(fp)
   1ba78:	01400204 	movi	r5,8
   1ba7c:	001d5ec0 	call	1d5ec <dhcp_set_state>
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
   1ba80:	e0bffd17 	ldw	r2,-12(fp)
   1ba84:	10800904 	addi	r2,r2,36
   1ba88:	e13fff17 	ldw	r4,-4(fp)
   1ba8c:	100b883a 	mov	r5,r2
   1ba90:	000d883a 	mov	r6,zero
   1ba94:	0030eac0 	call	30eac <etharp_query>
   1ba98:	e0bffe05 	stb	r2,-8(fp)
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
   1ba9c:	e0bffd17 	ldw	r2,-12(fp)
   1baa0:	10800343 	ldbu	r2,13(r2)
   1baa4:	10800044 	addi	r2,r2,1
   1baa8:	1007883a 	mov	r3,r2
   1baac:	e0bffd17 	ldw	r2,-12(fp)
   1bab0:	10c00345 	stb	r3,13(r2)
  msecs = 500;
   1bab4:	00807d04 	movi	r2,500
   1bab8:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
   1babc:	e0bffe8b 	ldhu	r2,-6(fp)
   1bac0:	10c07cc4 	addi	r3,r2,499
   1bac4:	00807d04 	movi	r2,500
   1bac8:	1885283a 	div	r2,r3,r2
   1bacc:	1007883a 	mov	r3,r2
   1bad0:	e0bffd17 	ldw	r2,-12(fp)
   1bad4:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
}
   1bad8:	e037883a 	mov	sp,fp
   1badc:	dfc00117 	ldw	ra,4(sp)
   1bae0:	df000017 	ldw	fp,0(sp)
   1bae4:	dec00204 	addi	sp,sp,8
   1bae8:	f800283a 	ret

0001baec <dhcp_handle_offer>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
   1baec:	defffc04 	addi	sp,sp,-16
   1baf0:	dfc00315 	stw	ra,12(sp)
   1baf4:	df000215 	stw	fp,8(sp)
   1baf8:	df000204 	addi	fp,sp,8
   1bafc:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
   1bb00:	e0bfff17 	ldw	r2,-4(fp)
   1bb04:	10800a17 	ldw	r2,40(r2)
   1bb08:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* obtain the server address */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SERVER_ID)) {
   1bb0c:	008001b4 	movhi	r2,6
   1bb10:	108c5c04 	addi	r2,r2,12656
   1bb14:	10800083 	ldbu	r2,2(r2)
   1bb18:	10803fcc 	andi	r2,r2,255
   1bb1c:	10002826 	beq	r2,zero,1bbc0 <dhcp_handle_offer+0xd4>
    ip4_addr_set_u32(&dhcp->server_ip_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SERVER_ID)));
   1bb20:	008001b4 	movhi	r2,6
   1bb24:	108c5f04 	addi	r2,r2,12668
   1bb28:	10800217 	ldw	r2,8(r2)
   1bb2c:	1006d63a 	srli	r3,r2,24
   1bb30:	008001b4 	movhi	r2,6
   1bb34:	108c5f04 	addi	r2,r2,12668
   1bb38:	10800217 	ldw	r2,8(r2)
   1bb3c:	1004d23a 	srli	r2,r2,8
   1bb40:	10bfc00c 	andi	r2,r2,65280
   1bb44:	1886b03a 	or	r3,r3,r2
   1bb48:	008001b4 	movhi	r2,6
   1bb4c:	108c5f04 	addi	r2,r2,12668
   1bb50:	10800217 	ldw	r2,8(r2)
   1bb54:	10bfc00c 	andi	r2,r2,65280
   1bb58:	1004923a 	slli	r2,r2,8
   1bb5c:	1886b03a 	or	r3,r3,r2
   1bb60:	008001b4 	movhi	r2,6
   1bb64:	108c5f04 	addi	r2,r2,12668
   1bb68:	10800217 	ldw	r2,8(r2)
   1bb6c:	1004963a 	slli	r2,r2,24
   1bb70:	1886b03a 	or	r3,r3,r2
   1bb74:	e0bffe17 	ldw	r2,-8(fp)
   1bb78:	10c00815 	stw	r3,32(r2)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n",
      ip4_addr_get_u32(&dhcp->server_ip_addr)));
    /* remember offered address */
    ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
   1bb7c:	e0bffe17 	ldw	r2,-8(fp)
   1bb80:	10800217 	ldw	r2,8(r2)
   1bb84:	10c00403 	ldbu	r3,16(r2)
   1bb88:	11000443 	ldbu	r4,17(r2)
   1bb8c:	2008923a 	slli	r4,r4,8
   1bb90:	20c6b03a 	or	r3,r4,r3
   1bb94:	11000483 	ldbu	r4,18(r2)
   1bb98:	2008943a 	slli	r4,r4,16
   1bb9c:	20c6b03a 	or	r3,r4,r3
   1bba0:	108004c3 	ldbu	r2,19(r2)
   1bba4:	1004963a 	slli	r2,r2,24
   1bba8:	10c4b03a 	or	r2,r2,r3
   1bbac:	1007883a 	mov	r3,r2
   1bbb0:	e0bffe17 	ldw	r2,-8(fp)
   1bbb4:	10c00915 	stw	r3,36(r2)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n",
      ip4_addr_get_u32(&dhcp->offered_ip_addr)));

    dhcp_select(netif);
   1bbb8:	e13fff17 	ldw	r4,-4(fp)
   1bbbc:	001bbd40 	call	1bbd4 <dhcp_select>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_handle_offer(netif=%p) did not get server ID!\n", (void*)netif));
  }
}
   1bbc0:	e037883a 	mov	sp,fp
   1bbc4:	dfc00117 	ldw	ra,4(sp)
   1bbc8:	df000017 	ldw	fp,0(sp)
   1bbcc:	dec00204 	addi	sp,sp,8
   1bbd0:	f800283a 	ret

0001bbd4 <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
   1bbd4:	defffa04 	addi	sp,sp,-24
   1bbd8:	dfc00515 	stw	ra,20(sp)
   1bbdc:	df000415 	stw	fp,16(sp)
   1bbe0:	df000404 	addi	fp,sp,16
   1bbe4:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
   1bbe8:	e0bfff17 	ldw	r2,-4(fp)
   1bbec:	10800a17 	ldw	r2,40(r2)
   1bbf0:	e0bffd15 	stw	r2,-12(fp)
  err_t result;
  u16_t msecs;

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  dhcp_set_state(dhcp, DHCP_REQUESTING);
   1bbf4:	e13ffd17 	ldw	r4,-12(fp)
   1bbf8:	01400044 	movi	r5,1
   1bbfc:	001d5ec0 	call	1d5ec <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
   1bc00:	e13fff17 	ldw	r4,-4(fp)
   1bc04:	e17ffd17 	ldw	r5,-12(fp)
   1bc08:	018000c4 	movi	r6,3
   1bc0c:	001e5b40 	call	1e5b4 <dhcp_create_msg>
   1bc10:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
   1bc14:	e0bffe07 	ldb	r2,-8(fp)
   1bc18:	1000661e 	bne	r2,zero,1bdb4 <dhcp_select+0x1e0>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
   1bc1c:	e13ffd17 	ldw	r4,-12(fp)
   1bc20:	01400e44 	movi	r5,57
   1bc24:	01800084 	movi	r6,2
   1bc28:	001d6440 	call	1d644 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
   1bc2c:	e0bfff17 	ldw	r2,-4(fp)
   1bc30:	10800c0b 	ldhu	r2,48(r2)
   1bc34:	10bfffcc 	andi	r2,r2,65535
   1bc38:	e13ffd17 	ldw	r4,-12(fp)
   1bc3c:	100b883a 	mov	r5,r2
   1bc40:	001d7380 	call	1d738 <dhcp_option_short>

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
   1bc44:	e13ffd17 	ldw	r4,-12(fp)
   1bc48:	01400c84 	movi	r5,50
   1bc4c:	01800104 	movi	r6,4
   1bc50:	001d6440 	call	1d644 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
   1bc54:	e0bffd17 	ldw	r2,-12(fp)
   1bc58:	10800917 	ldw	r2,36(r2)
   1bc5c:	1006d63a 	srli	r3,r2,24
   1bc60:	e0bffd17 	ldw	r2,-12(fp)
   1bc64:	10800917 	ldw	r2,36(r2)
   1bc68:	1004d23a 	srli	r2,r2,8
   1bc6c:	10bfc00c 	andi	r2,r2,65280
   1bc70:	1886b03a 	or	r3,r3,r2
   1bc74:	e0bffd17 	ldw	r2,-12(fp)
   1bc78:	10800917 	ldw	r2,36(r2)
   1bc7c:	10bfc00c 	andi	r2,r2,65280
   1bc80:	1004923a 	slli	r2,r2,8
   1bc84:	1886b03a 	or	r3,r3,r2
   1bc88:	e0bffd17 	ldw	r2,-12(fp)
   1bc8c:	10800917 	ldw	r2,36(r2)
   1bc90:	1004963a 	slli	r2,r2,24
   1bc94:	1884b03a 	or	r2,r3,r2
   1bc98:	e13ffd17 	ldw	r4,-12(fp)
   1bc9c:	100b883a 	mov	r5,r2
   1bca0:	001d7cc0 	call	1d7cc <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
   1bca4:	e13ffd17 	ldw	r4,-12(fp)
   1bca8:	01400d84 	movi	r5,54
   1bcac:	01800104 	movi	r6,4
   1bcb0:	001d6440 	call	1d644 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->server_ip_addr)));
   1bcb4:	e0bffd17 	ldw	r2,-12(fp)
   1bcb8:	10800817 	ldw	r2,32(r2)
   1bcbc:	1006d63a 	srli	r3,r2,24
   1bcc0:	e0bffd17 	ldw	r2,-12(fp)
   1bcc4:	10800817 	ldw	r2,32(r2)
   1bcc8:	1004d23a 	srli	r2,r2,8
   1bccc:	10bfc00c 	andi	r2,r2,65280
   1bcd0:	1886b03a 	or	r3,r3,r2
   1bcd4:	e0bffd17 	ldw	r2,-12(fp)
   1bcd8:	10800817 	ldw	r2,32(r2)
   1bcdc:	10bfc00c 	andi	r2,r2,65280
   1bce0:	1004923a 	slli	r2,r2,8
   1bce4:	1886b03a 	or	r3,r3,r2
   1bce8:	e0bffd17 	ldw	r2,-12(fp)
   1bcec:	10800817 	ldw	r2,32(r2)
   1bcf0:	1004963a 	slli	r2,r2,24
   1bcf4:	1884b03a 	or	r2,r3,r2
   1bcf8:	e13ffd17 	ldw	r4,-12(fp)
   1bcfc:	100b883a 	mov	r5,r2
   1bd00:	001d7cc0 	call	1d7cc <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
   1bd04:	e13ffd17 	ldw	r4,-12(fp)
   1bd08:	01400dc4 	movi	r5,55
   1bd0c:	01800104 	movi	r6,4
   1bd10:	001d6440 	call	1d644 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
   1bd14:	e13ffd17 	ldw	r4,-12(fp)
   1bd18:	01400044 	movi	r5,1
   1bd1c:	001d6dc0 	call	1d6dc <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
   1bd20:	e13ffd17 	ldw	r4,-12(fp)
   1bd24:	014000c4 	movi	r5,3
   1bd28:	001d6dc0 	call	1d6dc <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
   1bd2c:	e13ffd17 	ldw	r4,-12(fp)
   1bd30:	01400704 	movi	r5,28
   1bd34:	001d6dc0 	call	1d6dc <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
   1bd38:	e13ffd17 	ldw	r4,-12(fp)
   1bd3c:	01400184 	movi	r5,6
   1bd40:	001d6dc0 	call	1d6dc <dhcp_option_byte>

#if LWIP_NETIF_HOSTNAME
    dhcp_option_hostname(dhcp, netif);
   1bd44:	e13ffd17 	ldw	r4,-12(fp)
   1bd48:	e17fff17 	ldw	r5,-4(fp)
   1bd4c:	001d8d40 	call	1d8d4 <dhcp_option_hostname>
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
   1bd50:	e13ffd17 	ldw	r4,-12(fp)
   1bd54:	001eb740 	call	1eb74 <dhcp_option_trailer>
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
   1bd58:	e0bffd17 	ldw	r2,-12(fp)
   1bd5c:	10c00417 	ldw	r3,16(r2)
   1bd60:	e0bffd17 	ldw	r2,-12(fp)
   1bd64:	1080060b 	ldhu	r2,24(r2)
   1bd68:	10803c04 	addi	r2,r2,240
   1bd6c:	10bfffcc 	andi	r2,r2,65535
   1bd70:	1809883a 	mov	r4,r3
   1bd74:	100b883a 	mov	r5,r2
   1bd78:	00234500 	call	23450 <pbuf_realloc>

    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
   1bd7c:	e0bffd17 	ldw	r2,-12(fp)
   1bd80:	10c00117 	ldw	r3,4(r2)
   1bd84:	e0bffd17 	ldw	r2,-12(fp)
   1bd88:	10800417 	ldw	r2,16(r2)
   1bd8c:	e13fff17 	ldw	r4,-4(fp)
   1bd90:	d9000015 	stw	r4,0(sp)
   1bd94:	1809883a 	mov	r4,r3
   1bd98:	100b883a 	mov	r5,r2
   1bd9c:	01800134 	movhi	r6,4
   1bda0:	3195cc04 	addi	r6,r6,22320
   1bda4:	01c010c4 	movi	r7,67
   1bda8:	002f4780 	call	2f478 <udp_sendto_if>
    dhcp_delete_msg(dhcp);
   1bdac:	e13ffd17 	ldw	r4,-12(fp)
   1bdb0:	001eaf40 	call	1eaf4 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
   1bdb4:	e0bffd17 	ldw	r2,-12(fp)
   1bdb8:	10800343 	ldbu	r2,13(r2)
   1bdbc:	10800044 	addi	r2,r2,1
   1bdc0:	1007883a 	mov	r3,r2
   1bdc4:	e0bffd17 	ldw	r2,-12(fp)
   1bdc8:	10c00345 	stb	r3,13(r2)
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
   1bdcc:	e0bffd17 	ldw	r2,-12(fp)
   1bdd0:	10800343 	ldbu	r2,13(r2)
   1bdd4:	10803fcc 	andi	r2,r2,255
   1bdd8:	108001a8 	cmpgeui	r2,r2,6
   1bddc:	1000061e 	bne	r2,zero,1bdf8 <dhcp_select+0x224>
   1bde0:	e0bffd17 	ldw	r2,-12(fp)
   1bde4:	10800343 	ldbu	r2,13(r2)
   1bde8:	10803fcc 	andi	r2,r2,255
   1bdec:	00c0fa04 	movi	r3,1000
   1bdf0:	1884983a 	sll	r2,r3,r2
   1bdf4:	00000106 	br	1bdfc <dhcp_select+0x228>
   1bdf8:	00ba9804 	movi	r2,-5536
   1bdfc:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
   1be00:	e0bffe8b 	ldhu	r2,-6(fp)
   1be04:	10c07cc4 	addi	r3,r2,499
   1be08:	00807d04 	movi	r2,500
   1be0c:	1885283a 	div	r2,r3,r2
   1be10:	1007883a 	mov	r3,r2
   1be14:	e0bffd17 	ldw	r2,-12(fp)
   1be18:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
   1be1c:	e0bffe03 	ldbu	r2,-8(fp)
}
   1be20:	e037883a 	mov	sp,fp
   1be24:	dfc00117 	ldw	ra,4(sp)
   1be28:	df000017 	ldw	fp,0(sp)
   1be2c:	dec00204 	addi	sp,sp,8
   1be30:	f800283a 	ret

0001be34 <dhcp_coarse_tmr>:
/**
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 */
void
dhcp_coarse_tmr()
{
   1be34:	defffd04 	addi	sp,sp,-12
   1be38:	dfc00215 	stw	ra,8(sp)
   1be3c:	df000115 	stw	fp,4(sp)
   1be40:	df000104 	addi	fp,sp,4
  struct netif *netif = netif_list;
   1be44:	00800134 	movhi	r2,4
   1be48:	109eed04 	addi	r2,r2,31668
   1be4c:	10800017 	ldw	r2,0(r2)
   1be50:	e0bfff15 	stw	r2,-4(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
   1be54:	00001d06 	br	1becc <dhcp_coarse_tmr+0x98>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
   1be58:	e0bfff17 	ldw	r2,-4(fp)
   1be5c:	10800a17 	ldw	r2,40(r2)
   1be60:	10001726 	beq	r2,zero,1bec0 <dhcp_coarse_tmr+0x8c>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
   1be64:	e0bfff17 	ldw	r2,-4(fp)
   1be68:	10800a17 	ldw	r2,40(r2)
   1be6c:	10c0078b 	ldhu	r3,30(r2)
   1be70:	193fffcc 	andi	r4,r3,65535
   1be74:	21000060 	cmpeqi	r4,r4,1
   1be78:	18ffffc4 	addi	r3,r3,-1
   1be7c:	10c0078d 	sth	r3,30(r2)
   1be80:	20803fcc 	andi	r2,r4,255
   1be84:	10000326 	beq	r2,zero,1be94 <dhcp_coarse_tmr+0x60>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
   1be88:	e13fff17 	ldw	r4,-4(fp)
   1be8c:	001c1b00 	call	1c1b0 <dhcp_t2_timeout>
   1be90:	00000b06 	br	1bec0 <dhcp_coarse_tmr+0x8c>
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
   1be94:	e0bfff17 	ldw	r2,-4(fp)
   1be98:	10800a17 	ldw	r2,40(r2)
   1be9c:	10c0070b 	ldhu	r3,28(r2)
   1bea0:	193fffcc 	andi	r4,r3,65535
   1bea4:	21000060 	cmpeqi	r4,r4,1
   1bea8:	18ffffc4 	addi	r3,r3,-1
   1beac:	10c0070d 	sth	r3,28(r2)
   1beb0:	20803fcc 	andi	r2,r4,255
   1beb4:	10000226 	beq	r2,zero,1bec0 <dhcp_coarse_tmr+0x8c>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t1 timeout\n"));
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
   1beb8:	e13fff17 	ldw	r4,-4(fp)
   1bebc:	001c1380 	call	1c138 <dhcp_t1_timeout>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
   1bec0:	e0bfff17 	ldw	r2,-4(fp)
   1bec4:	10800017 	ldw	r2,0(r2)
   1bec8:	e0bfff15 	stw	r2,-4(fp)
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
   1becc:	e0bfff17 	ldw	r2,-4(fp)
   1bed0:	103fe11e 	bne	r2,zero,1be58 <dhcp_coarse_tmr+0x24>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
   1bed4:	e037883a 	mov	sp,fp
   1bed8:	dfc00117 	ldw	ra,4(sp)
   1bedc:	df000017 	ldw	fp,0(sp)
   1bee0:	dec00204 	addi	sp,sp,8
   1bee4:	f800283a 	ret

0001bee8 <dhcp_fine_tmr>:
 * A DHCP server is expected to respond within a short period of time.
 * This timer checks whether an outstanding DHCP request is timed out.
 */
void
dhcp_fine_tmr()
{
   1bee8:	defffd04 	addi	sp,sp,-12
   1beec:	dfc00215 	stw	ra,8(sp)
   1bef0:	df000115 	stw	fp,4(sp)
   1bef4:	df000104 	addi	fp,sp,4
  struct netif *netif = netif_list;
   1bef8:	00800134 	movhi	r2,4
   1befc:	109eed04 	addi	r2,r2,31668
   1bf00:	10800017 	ldw	r2,0(r2)
   1bf04:	e0bfff15 	stw	r2,-4(fp)
  /* loop through netif's */
  while (netif != NULL) {
   1bf08:	00001f06 	br	1bf88 <dhcp_fine_tmr+0xa0>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
   1bf0c:	e0bfff17 	ldw	r2,-4(fp)
   1bf10:	10800a17 	ldw	r2,40(r2)
   1bf14:	10001926 	beq	r2,zero,1bf7c <dhcp_fine_tmr+0x94>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
   1bf18:	e0bfff17 	ldw	r2,-4(fp)
   1bf1c:	10800a17 	ldw	r2,40(r2)
   1bf20:	1080068b 	ldhu	r2,26(r2)
   1bf24:	10bfffcc 	andi	r2,r2,65535
   1bf28:	108000b0 	cmpltui	r2,r2,2
   1bf2c:	1000061e 	bne	r2,zero,1bf48 <dhcp_fine_tmr+0x60>
        netif->dhcp->request_timeout--;
   1bf30:	e0bfff17 	ldw	r2,-4(fp)
   1bf34:	10800a17 	ldw	r2,40(r2)
   1bf38:	10c0068b 	ldhu	r3,26(r2)
   1bf3c:	18ffffc4 	addi	r3,r3,-1
   1bf40:	10c0068d 	sth	r3,26(r2)
   1bf44:	00000d06 	br	1bf7c <dhcp_fine_tmr+0x94>
      }
      else if (netif->dhcp->request_timeout == 1) {
   1bf48:	e0bfff17 	ldw	r2,-4(fp)
   1bf4c:	10800a17 	ldw	r2,40(r2)
   1bf50:	1080068b 	ldhu	r2,26(r2)
   1bf54:	10bfffcc 	andi	r2,r2,65535
   1bf58:	10800058 	cmpnei	r2,r2,1
   1bf5c:	1000071e 	bne	r2,zero,1bf7c <dhcp_fine_tmr+0x94>
        netif->dhcp->request_timeout--;
   1bf60:	e0bfff17 	ldw	r2,-4(fp)
   1bf64:	10800a17 	ldw	r2,40(r2)
   1bf68:	10c0068b 	ldhu	r3,26(r2)
   1bf6c:	18ffffc4 	addi	r3,r3,-1
   1bf70:	10c0068d 	sth	r3,26(r2)
        /* { netif->dhcp->request_timeout == 0 } */
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_fine_tmr(): request timeout\n"));
        /* this client's request timeout triggered */
        dhcp_timeout(netif);
   1bf74:	e13fff17 	ldw	r4,-4(fp)
   1bf78:	001bfa40 	call	1bfa4 <dhcp_timeout>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
   1bf7c:	e0bfff17 	ldw	r2,-4(fp)
   1bf80:	10800017 	ldw	r2,0(r2)
   1bf84:	e0bfff15 	stw	r2,-4(fp)
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
   1bf88:	e0bfff17 	ldw	r2,-4(fp)
   1bf8c:	103fdf1e 	bne	r2,zero,1bf0c <dhcp_fine_tmr+0x24>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
   1bf90:	e037883a 	mov	sp,fp
   1bf94:	dfc00117 	ldw	ra,4(sp)
   1bf98:	df000017 	ldw	fp,0(sp)
   1bf9c:	dec00204 	addi	sp,sp,8
   1bfa0:	f800283a 	ret

0001bfa4 <dhcp_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
   1bfa4:	defffc04 	addi	sp,sp,-16
   1bfa8:	dfc00315 	stw	ra,12(sp)
   1bfac:	df000215 	stw	fp,8(sp)
   1bfb0:	df000204 	addi	fp,sp,8
   1bfb4:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
   1bfb8:	e0bfff17 	ldw	r2,-4(fp)
   1bfbc:	10800a17 	ldw	r2,40(r2)
   1bfc0:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
   1bfc4:	e0bffe17 	ldw	r2,-8(fp)
   1bfc8:	10800303 	ldbu	r2,12(r2)
   1bfcc:	10803fcc 	andi	r2,r2,255
   1bfd0:	10800320 	cmpeqi	r2,r2,12
   1bfd4:	1000051e 	bne	r2,zero,1bfec <dhcp_timeout+0x48>
   1bfd8:	e0bffe17 	ldw	r2,-8(fp)
   1bfdc:	10800303 	ldbu	r2,12(r2)
   1bfe0:	10803fcc 	andi	r2,r2,255
   1bfe4:	10800198 	cmpnei	r2,r2,6
   1bfe8:	1000031e 	bne	r2,zero,1bff8 <dhcp_timeout+0x54>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
   1bfec:	e13fff17 	ldw	r4,-4(fp)
   1bff0:	001cb140 	call	1cb14 <dhcp_discover>
   1bff4:	00004b06 	br	1c124 <dhcp_timeout+0x180>
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
   1bff8:	e0bffe17 	ldw	r2,-8(fp)
   1bffc:	10800303 	ldbu	r2,12(r2)
   1c000:	10803fcc 	andi	r2,r2,255
   1c004:	10800058 	cmpnei	r2,r2,1
   1c008:	10000d1e 	bne	r2,zero,1c040 <dhcp_timeout+0x9c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
   1c00c:	e0bffe17 	ldw	r2,-8(fp)
   1c010:	10800343 	ldbu	r2,13(r2)
   1c014:	10803fcc 	andi	r2,r2,255
   1c018:	108001a8 	cmpgeui	r2,r2,6
   1c01c:	1000031e 	bne	r2,zero,1c02c <dhcp_timeout+0x88>
      dhcp_select(netif);
   1c020:	e13fff17 	ldw	r4,-4(fp)
   1c024:	001bbd40 	call	1bbd4 <dhcp_select>
   1c028:	00003e06 	br	1c124 <dhcp_timeout+0x180>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
   1c02c:	e13fff17 	ldw	r4,-4(fp)
   1c030:	001d3900 	call	1d390 <dhcp_release>
      dhcp_discover(netif);
   1c034:	e13fff17 	ldw	r4,-4(fp)
   1c038:	001cb140 	call	1cb14 <dhcp_discover>
   1c03c:	00003906 	br	1c124 <dhcp_timeout+0x180>
    }
#if DHCP_DOES_ARP_CHECK
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
   1c040:	e0bffe17 	ldw	r2,-8(fp)
   1c044:	10800303 	ldbu	r2,12(r2)
   1c048:	10803fcc 	andi	r2,r2,255
   1c04c:	10800218 	cmpnei	r2,r2,8
   1c050:	10000b1e 	bne	r2,zero,1c080 <dhcp_timeout+0xdc>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
   1c054:	e0bffe17 	ldw	r2,-8(fp)
   1c058:	10800343 	ldbu	r2,13(r2)
   1c05c:	10803fcc 	andi	r2,r2,255
   1c060:	108000a8 	cmpgeui	r2,r2,2
   1c064:	1000031e 	bne	r2,zero,1c074 <dhcp_timeout+0xd0>
      dhcp_check(netif);
   1c068:	e13fff17 	ldw	r4,-4(fp)
   1c06c:	001ba540 	call	1ba54 <dhcp_check>
   1c070:	00002c06 	br	1c124 <dhcp_timeout+0x180>
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
   1c074:	e13fff17 	ldw	r4,-4(fp)
   1c078:	001ccb40 	call	1ccb4 <dhcp_bind>
   1c07c:	00002906 	br	1c124 <dhcp_timeout+0x180>
    }
#endif /* DHCP_DOES_ARP_CHECK */
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
   1c080:	e0bffe17 	ldw	r2,-8(fp)
   1c084:	10800303 	ldbu	r2,12(r2)
   1c088:	10803fcc 	andi	r2,r2,255
   1c08c:	10800158 	cmpnei	r2,r2,5
   1c090:	1000031e 	bne	r2,zero,1c0a0 <dhcp_timeout+0xfc>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
   1c094:	e13fff17 	ldw	r4,-4(fp)
   1c098:	001cf340 	call	1cf34 <dhcp_renew>
   1c09c:	00002106 	br	1c124 <dhcp_timeout+0x180>
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
   1c0a0:	e0bffe17 	ldw	r2,-8(fp)
   1c0a4:	10800303 	ldbu	r2,12(r2)
   1c0a8:	10803fcc 	andi	r2,r2,255
   1c0ac:	10800118 	cmpnei	r2,r2,4
   1c0b0:	10000d1e 	bne	r2,zero,1c0e8 <dhcp_timeout+0x144>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
   1c0b4:	e0bffe17 	ldw	r2,-8(fp)
   1c0b8:	10800343 	ldbu	r2,13(r2)
   1c0bc:	10803fcc 	andi	r2,r2,255
   1c0c0:	10800268 	cmpgeui	r2,r2,9
   1c0c4:	1000031e 	bne	r2,zero,1c0d4 <dhcp_timeout+0x130>
      dhcp_rebind(netif);
   1c0c8:	e13fff17 	ldw	r4,-4(fp)
   1c0cc:	001d0900 	call	1d090 <dhcp_rebind>
   1c0d0:	00001406 	br	1c124 <dhcp_timeout+0x180>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
   1c0d4:	e13fff17 	ldw	r4,-4(fp)
   1c0d8:	001d3900 	call	1d390 <dhcp_release>
      dhcp_discover(netif);
   1c0dc:	e13fff17 	ldw	r4,-4(fp)
   1c0e0:	001cb140 	call	1cb14 <dhcp_discover>
   1c0e4:	00000f06 	br	1c124 <dhcp_timeout+0x180>
    }
  } else if (dhcp->state == DHCP_REBOOTING) {
   1c0e8:	e0bffe17 	ldw	r2,-8(fp)
   1c0ec:	10800303 	ldbu	r2,12(r2)
   1c0f0:	10803fcc 	andi	r2,r2,255
   1c0f4:	108000d8 	cmpnei	r2,r2,3
   1c0f8:	10000a1e 	bne	r2,zero,1c124 <dhcp_timeout+0x180>
    if (dhcp->tries < REBOOT_TRIES) {
   1c0fc:	e0bffe17 	ldw	r2,-8(fp)
   1c100:	10800343 	ldbu	r2,13(r2)
   1c104:	10803fcc 	andi	r2,r2,255
   1c108:	108000a8 	cmpgeui	r2,r2,2
   1c10c:	1000031e 	bne	r2,zero,1c11c <dhcp_timeout+0x178>
      dhcp_reboot(netif);
   1c110:	e13fff17 	ldw	r4,-4(fp)
   1c114:	001d1ec0 	call	1d1ec <dhcp_reboot>
   1c118:	00000206 	br	1c124 <dhcp_timeout+0x180>
    } else {
      dhcp_discover(netif);
   1c11c:	e13fff17 	ldw	r4,-4(fp)
   1c120:	001cb140 	call	1cb14 <dhcp_discover>
    }
  }
}
   1c124:	e037883a 	mov	sp,fp
   1c128:	dfc00117 	ldw	ra,4(sp)
   1c12c:	df000017 	ldw	fp,0(sp)
   1c130:	dec00204 	addi	sp,sp,8
   1c134:	f800283a 	ret

0001c138 <dhcp_t1_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t1_timeout(struct netif *netif)
{
   1c138:	defffc04 	addi	sp,sp,-16
   1c13c:	dfc00315 	stw	ra,12(sp)
   1c140:	df000215 	stw	fp,8(sp)
   1c144:	df000204 	addi	fp,sp,8
   1c148:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
   1c14c:	e0bfff17 	ldw	r2,-4(fp)
   1c150:	10800a17 	ldw	r2,40(r2)
   1c154:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) ||
   1c158:	e0bffe17 	ldw	r2,-8(fp)
   1c15c:	10800303 	ldbu	r2,12(r2)
   1c160:	10803fcc 	andi	r2,r2,255
   1c164:	10800060 	cmpeqi	r2,r2,1
   1c168:	10000a1e 	bne	r2,zero,1c194 <dhcp_t1_timeout+0x5c>
   1c16c:	e0bffe17 	ldw	r2,-8(fp)
   1c170:	10800303 	ldbu	r2,12(r2)
   1c174:	10803fcc 	andi	r2,r2,255
   1c178:	108002a0 	cmpeqi	r2,r2,10
   1c17c:	1000051e 	bne	r2,zero,1c194 <dhcp_t1_timeout+0x5c>
      (dhcp->state == DHCP_RENEWING)) {
   1c180:	e0bffe17 	ldw	r2,-8(fp)
   1c184:	10800303 	ldbu	r2,12(r2)
static void
dhcp_t1_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) ||
   1c188:	10803fcc 	andi	r2,r2,255
   1c18c:	10800158 	cmpnei	r2,r2,5
   1c190:	1000021e 	bne	r2,zero,1c19c <dhcp_t1_timeout+0x64>
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
                ("dhcp_t1_timeout(): must renew\n"));
    /* This slightly different to RFC2131: DHCPREQUEST will be sent from state
       DHCP_RENEWING, not DHCP_BOUND */
    dhcp_renew(netif);
   1c194:	e13fff17 	ldw	r4,-4(fp)
   1c198:	001cf340 	call	1cf34 <dhcp_renew>
  }
}
   1c19c:	e037883a 	mov	sp,fp
   1c1a0:	dfc00117 	ldw	ra,4(sp)
   1c1a4:	df000017 	ldw	fp,0(sp)
   1c1a8:	dec00204 	addi	sp,sp,8
   1c1ac:	f800283a 	ret

0001c1b0 <dhcp_t2_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t2_timeout(struct netif *netif)
{
   1c1b0:	defffc04 	addi	sp,sp,-16
   1c1b4:	dfc00315 	stw	ra,12(sp)
   1c1b8:	df000215 	stw	fp,8(sp)
   1c1bc:	df000204 	addi	fp,sp,8
   1c1c0:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
   1c1c4:	e0bfff17 	ldw	r2,-4(fp)
   1c1c8:	10800a17 	ldw	r2,40(r2)
   1c1cc:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) ||
   1c1d0:	e0bffe17 	ldw	r2,-8(fp)
   1c1d4:	10800303 	ldbu	r2,12(r2)
   1c1d8:	10803fcc 	andi	r2,r2,255
   1c1dc:	10800060 	cmpeqi	r2,r2,1
   1c1e0:	10000a1e 	bne	r2,zero,1c20c <dhcp_t2_timeout+0x5c>
   1c1e4:	e0bffe17 	ldw	r2,-8(fp)
   1c1e8:	10800303 	ldbu	r2,12(r2)
   1c1ec:	10803fcc 	andi	r2,r2,255
   1c1f0:	108002a0 	cmpeqi	r2,r2,10
   1c1f4:	1000051e 	bne	r2,zero,1c20c <dhcp_t2_timeout+0x5c>
      (dhcp->state == DHCP_RENEWING)) {
   1c1f8:	e0bffe17 	ldw	r2,-8(fp)
   1c1fc:	10800303 	ldbu	r2,12(r2)
static void
dhcp_t2_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) ||
   1c200:	10803fcc 	andi	r2,r2,255
   1c204:	10800158 	cmpnei	r2,r2,5
   1c208:	1000021e 	bne	r2,zero,1c214 <dhcp_t2_timeout+0x64>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
                ("dhcp_t2_timeout(): must rebind\n"));
    /* This slightly different to RFC2131: DHCPREQUEST will be sent from state
       DHCP_REBINDING, not DHCP_BOUND */
    dhcp_rebind(netif);
   1c20c:	e13fff17 	ldw	r4,-4(fp)
   1c210:	001d0900 	call	1d090 <dhcp_rebind>
  }
}
   1c214:	e037883a 	mov	sp,fp
   1c218:	dfc00117 	ldw	ra,4(sp)
   1c21c:	df000017 	ldw	fp,0(sp)
   1c220:	dec00204 	addi	sp,sp,8
   1c224:	f800283a 	ret

0001c228 <dhcp_handle_ack>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
   1c228:	defffd04 	addi	sp,sp,-12
   1c22c:	df000215 	stw	fp,8(sp)
   1c230:	df000204 	addi	fp,sp,8
   1c234:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
   1c238:	e0bfff17 	ldw	r2,-4(fp)
   1c23c:	10800a17 	ldw	r2,40(r2)
   1c240:	e0bffe15 	stw	r2,-8(fp)
#if LWIP_DNS
  u8_t n;
#endif /* LWIP_DNS */

  /* clear options we might not get from the ACK */
  ip_addr_set_zero(&dhcp->offered_sn_mask);
   1c244:	e0bffe17 	ldw	r2,-8(fp)
   1c248:	10000a15 	stw	zero,40(r2)
  ip_addr_set_zero(&dhcp->offered_gw_addr);
   1c24c:	e0bffe17 	ldw	r2,-8(fp)
   1c250:	10000b15 	stw	zero,44(r2)
#if LWIP_DHCP_BOOTP_FILE
  ip_addr_set_zero(&dhcp->offered_si_addr);
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* lease time given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_LEASE_TIME)) {
   1c254:	008001b4 	movhi	r2,6
   1c258:	108c5c04 	addi	r2,r2,12656
   1c25c:	108000c3 	ldbu	r2,3(r2)
   1c260:	10803fcc 	andi	r2,r2,255
   1c264:	10000526 	beq	r2,zero,1c27c <dhcp_handle_ack+0x54>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_LEASE_TIME);
   1c268:	008001b4 	movhi	r2,6
   1c26c:	108c5f04 	addi	r2,r2,12668
   1c270:	10c00317 	ldw	r3,12(r2)
   1c274:	e0bffe17 	ldw	r2,-8(fp)
   1c278:	10c00c15 	stw	r3,48(r2)
  }
  /* renewal period given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T1)) {
   1c27c:	008001b4 	movhi	r2,6
   1c280:	108c5c04 	addi	r2,r2,12656
   1c284:	10800103 	ldbu	r2,4(r2)
   1c288:	10803fcc 	andi	r2,r2,255
   1c28c:	10000626 	beq	r2,zero,1c2a8 <dhcp_handle_ack+0x80>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T1);
   1c290:	008001b4 	movhi	r2,6
   1c294:	108c5f04 	addi	r2,r2,12668
   1c298:	10c00417 	ldw	r3,16(r2)
   1c29c:	e0bffe17 	ldw	r2,-8(fp)
   1c2a0:	10c00d15 	stw	r3,52(r2)
   1c2a4:	00000506 	br	1c2bc <dhcp_handle_ack+0x94>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
   1c2a8:	e0bffe17 	ldw	r2,-8(fp)
   1c2ac:	10800c17 	ldw	r2,48(r2)
   1c2b0:	1006d07a 	srli	r3,r2,1
   1c2b4:	e0bffe17 	ldw	r2,-8(fp)
   1c2b8:	10c00d15 	stw	r3,52(r2)
  }

  /* renewal period given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T2)) {
   1c2bc:	008001b4 	movhi	r2,6
   1c2c0:	108c5c04 	addi	r2,r2,12656
   1c2c4:	10800143 	ldbu	r2,5(r2)
   1c2c8:	10803fcc 	andi	r2,r2,255
   1c2cc:	10000626 	beq	r2,zero,1c2e8 <dhcp_handle_ack+0xc0>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T2);
   1c2d0:	008001b4 	movhi	r2,6
   1c2d4:	108c5f04 	addi	r2,r2,12668
   1c2d8:	10c00517 	ldw	r3,20(r2)
   1c2dc:	e0bffe17 	ldw	r2,-8(fp)
   1c2e0:	10c00e15 	stw	r3,56(r2)
   1c2e4:	00000406 	br	1c2f8 <dhcp_handle_ack+0xd0>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
   1c2e8:	e0bffe17 	ldw	r2,-8(fp)
   1c2ec:	10c00c17 	ldw	r3,48(r2)
   1c2f0:	e0bffe17 	ldw	r2,-8(fp)
   1c2f4:	10c00e15 	stw	r3,56(r2)
  }

  /* (y)our internet address */
  ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
   1c2f8:	e0bffe17 	ldw	r2,-8(fp)
   1c2fc:	10800217 	ldw	r2,8(r2)
   1c300:	10c00403 	ldbu	r3,16(r2)
   1c304:	11000443 	ldbu	r4,17(r2)
   1c308:	2008923a 	slli	r4,r4,8
   1c30c:	20c6b03a 	or	r3,r4,r3
   1c310:	11000483 	ldbu	r4,18(r2)
   1c314:	2008943a 	slli	r4,r4,16
   1c318:	20c6b03a 	or	r3,r4,r3
   1c31c:	108004c3 	ldbu	r2,19(r2)
   1c320:	1004963a 	slli	r2,r2,24
   1c324:	10c4b03a 	or	r2,r2,r3
   1c328:	1007883a 	mov	r3,r2
   1c32c:	e0bffe17 	ldw	r2,-8(fp)
   1c330:	10c00915 	stw	r3,36(r2)
     boot file name copied in dhcp_parse_reply if not overloaded */
  ip_addr_copy(dhcp->offered_si_addr, dhcp->msg_in->siaddr);
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* subnet mask given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)) {
   1c334:	008001b4 	movhi	r2,6
   1c338:	108c5c04 	addi	r2,r2,12656
   1c33c:	10800183 	ldbu	r2,6(r2)
   1c340:	10803fcc 	andi	r2,r2,255
   1c344:	10001b26 	beq	r2,zero,1c3b4 <dhcp_handle_ack+0x18c>
    /* remember given subnet mask */
    ip4_addr_set_u32(&dhcp->offered_sn_mask, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)));
   1c348:	008001b4 	movhi	r2,6
   1c34c:	108c5f04 	addi	r2,r2,12668
   1c350:	10800617 	ldw	r2,24(r2)
   1c354:	1006d63a 	srli	r3,r2,24
   1c358:	008001b4 	movhi	r2,6
   1c35c:	108c5f04 	addi	r2,r2,12668
   1c360:	10800617 	ldw	r2,24(r2)
   1c364:	1004d23a 	srli	r2,r2,8
   1c368:	10bfc00c 	andi	r2,r2,65280
   1c36c:	1886b03a 	or	r3,r3,r2
   1c370:	008001b4 	movhi	r2,6
   1c374:	108c5f04 	addi	r2,r2,12668
   1c378:	10800617 	ldw	r2,24(r2)
   1c37c:	10bfc00c 	andi	r2,r2,65280
   1c380:	1004923a 	slli	r2,r2,8
   1c384:	1886b03a 	or	r3,r3,r2
   1c388:	008001b4 	movhi	r2,6
   1c38c:	108c5f04 	addi	r2,r2,12668
   1c390:	10800617 	ldw	r2,24(r2)
   1c394:	1004963a 	slli	r2,r2,24
   1c398:	1886b03a 	or	r3,r3,r2
   1c39c:	e0bffe17 	ldw	r2,-8(fp)
   1c3a0:	10c00a15 	stw	r3,40(r2)
    dhcp->subnet_mask_given = 1;
   1c3a4:	e0bffe17 	ldw	r2,-8(fp)
   1c3a8:	00c00044 	movi	r3,1
   1c3ac:	10c00385 	stb	r3,14(r2)
   1c3b0:	00000206 	br	1c3bc <dhcp_handle_ack+0x194>
  } else {
    dhcp->subnet_mask_given = 0;
   1c3b4:	e0bffe17 	ldw	r2,-8(fp)
   1c3b8:	10000385 	stb	zero,14(r2)
  }

  /* gateway router */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_ROUTER)) {
   1c3bc:	008001b4 	movhi	r2,6
   1c3c0:	108c5c04 	addi	r2,r2,12656
   1c3c4:	108001c3 	ldbu	r2,7(r2)
   1c3c8:	10803fcc 	andi	r2,r2,255
   1c3cc:	10001726 	beq	r2,zero,1c42c <dhcp_handle_ack+0x204>
    ip4_addr_set_u32(&dhcp->offered_gw_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_ROUTER)));
   1c3d0:	008001b4 	movhi	r2,6
   1c3d4:	108c5f04 	addi	r2,r2,12668
   1c3d8:	10800717 	ldw	r2,28(r2)
   1c3dc:	1006d63a 	srli	r3,r2,24
   1c3e0:	008001b4 	movhi	r2,6
   1c3e4:	108c5f04 	addi	r2,r2,12668
   1c3e8:	10800717 	ldw	r2,28(r2)
   1c3ec:	1004d23a 	srli	r2,r2,8
   1c3f0:	10bfc00c 	andi	r2,r2,65280
   1c3f4:	1886b03a 	or	r3,r3,r2
   1c3f8:	008001b4 	movhi	r2,6
   1c3fc:	108c5f04 	addi	r2,r2,12668
   1c400:	10800717 	ldw	r2,28(r2)
   1c404:	10bfc00c 	andi	r2,r2,65280
   1c408:	1004923a 	slli	r2,r2,8
   1c40c:	1886b03a 	or	r3,r3,r2
   1c410:	008001b4 	movhi	r2,6
   1c414:	108c5f04 	addi	r2,r2,12668
   1c418:	10800717 	ldw	r2,28(r2)
   1c41c:	1004963a 	slli	r2,r2,24
   1c420:	1886b03a 	or	r3,r3,r2
   1c424:	e0bffe17 	ldw	r2,-8(fp)
   1c428:	10c00b15 	stw	r3,44(r2)
    ip4_addr_set_u32(&dns_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_DNS_SERVER + n)));
    dns_setserver(n, &dns_addr);
    n++;
  }
#endif /* LWIP_DNS */
}
   1c42c:	e037883a 	mov	sp,fp
   1c430:	df000017 	ldw	fp,0(sp)
   1c434:	dec00104 	addi	sp,sp,4
   1c438:	f800283a 	ret

0001c43c <dhcp_set_struct>:
 * @param netif the netif for which to set the struct dhcp
 * @param dhcp (uninitialised) dhcp struct allocated by the application
 */
void
dhcp_set_struct(struct netif *netif, struct dhcp *dhcp)
{
   1c43c:	defffc04 	addi	sp,sp,-16
   1c440:	dfc00315 	stw	ra,12(sp)
   1c444:	df000215 	stw	fp,8(sp)
   1c448:	df000204 	addi	fp,sp,8
   1c44c:	e13ffe15 	stw	r4,-8(fp)
   1c450:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT("netif != NULL", netif != NULL);
  LWIP_ASSERT("dhcp != NULL", dhcp != NULL);
  LWIP_ASSERT("netif already has a struct dhcp set", netif->dhcp == NULL);

  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
   1c454:	e13fff17 	ldw	r4,-4(fp)
   1c458:	000b883a 	mov	r5,zero
   1c45c:	01800f04 	movi	r6,60
   1c460:	00042e80 	call	42e8 <memset>
  /* dhcp_set_state(&dhcp, DHCP_OFF); */
  netif->dhcp = dhcp;
   1c464:	e0bffe17 	ldw	r2,-8(fp)
   1c468:	e0ffff17 	ldw	r3,-4(fp)
   1c46c:	10c00a15 	stw	r3,40(r2)
}
   1c470:	e037883a 	mov	sp,fp
   1c474:	dfc00117 	ldw	ra,4(sp)
   1c478:	df000017 	ldw	fp,0(sp)
   1c47c:	dec00204 	addi	sp,sp,8
   1c480:	f800283a 	ret

0001c484 <dhcp_cleanup>:
 *            struct dhcp since the memory is passed back to the heap.
 *
 * @param netif the netif from which to remove the struct dhcp
 */
void dhcp_cleanup(struct netif *netif)
{
   1c484:	defffd04 	addi	sp,sp,-12
   1c488:	dfc00215 	stw	ra,8(sp)
   1c48c:	df000115 	stw	fp,4(sp)
   1c490:	df000104 	addi	fp,sp,4
   1c494:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("netif != NULL", netif != NULL);

  if (netif->dhcp != NULL) {
   1c498:	e0bfff17 	ldw	r2,-4(fp)
   1c49c:	10800a17 	ldw	r2,40(r2)
   1c4a0:	10000626 	beq	r2,zero,1c4bc <dhcp_cleanup+0x38>
    mem_free(netif->dhcp);
   1c4a4:	e0bfff17 	ldw	r2,-4(fp)
   1c4a8:	10800a17 	ldw	r2,40(r2)
   1c4ac:	1009883a 	mov	r4,r2
   1c4b0:	0021a540 	call	21a54 <mem_free>
    netif->dhcp = NULL;
   1c4b4:	e0bfff17 	ldw	r2,-4(fp)
   1c4b8:	10000a15 	stw	zero,40(r2)
  }
}
   1c4bc:	e037883a 	mov	sp,fp
   1c4c0:	dfc00117 	ldw	ra,4(sp)
   1c4c4:	df000017 	ldw	fp,0(sp)
   1c4c8:	dec00204 	addi	sp,sp,8
   1c4cc:	f800283a 	ret

0001c4d0 <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
   1c4d0:	defffb04 	addi	sp,sp,-20
   1c4d4:	dfc00415 	stw	ra,16(sp)
   1c4d8:	df000315 	stw	fp,12(sp)
   1c4dc:	df000304 	addi	fp,sp,12
   1c4e0:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp;
  err_t result = ERR_OK;
   1c4e4:	e03ffe05 	stb	zero,-8(fp)

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
   1c4e8:	e0bfff17 	ldw	r2,-4(fp)
   1c4ec:	1000091e 	bne	r2,zero,1c514 <dhcp_start+0x44>
   1c4f0:	01000134 	movhi	r4,4
   1c4f4:	21040004 	addi	r4,r4,4096
   1c4f8:	01400134 	movhi	r5,4
   1c4fc:	29440c04 	addi	r5,r5,4144
   1c500:	0180a144 	movi	r6,645
   1c504:	01c00134 	movhi	r7,4
   1c508:	39c41004 	addi	r7,r7,4160
   1c50c:	00044740 	call	4474 <printf>
   1c510:	003fff06 	br	1c510 <dhcp_start+0x40>
  dhcp = netif->dhcp;
   1c514:	e0bfff17 	ldw	r2,-4(fp)
   1c518:	10800a17 	ldw	r2,40(r2)
   1c51c:	e0bffd15 	stw	r2,-12(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
   1c520:	e0bfff17 	ldw	r2,-4(fp)
   1c524:	10c00e43 	ldbu	r3,57(r2)
   1c528:	00bffdc4 	movi	r2,-9
   1c52c:	1884703a 	and	r2,r3,r2
   1c530:	1007883a 	mov	r3,r2
   1c534:	e0bfff17 	ldw	r2,-4(fp)
   1c538:	10c00e45 	stb	r3,57(r2)

  /* check hwtype of the netif */
  if ((netif->flags & NETIF_FLAG_ETHARP) == 0) {
   1c53c:	e0bfff17 	ldw	r2,-4(fp)
   1c540:	10800e43 	ldbu	r2,57(r2)
   1c544:	10803fcc 	andi	r2,r2,255
   1c548:	1080080c 	andi	r2,r2,32
   1c54c:	1000021e 	bne	r2,zero,1c558 <dhcp_start+0x88>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): No ETHARP netif\n"));
    return ERR_ARG;
   1c550:	00bffc84 	movi	r2,-14
   1c554:	00005506 	br	1c6ac <dhcp_start+0x1dc>
  }

  /* check MTU of the netif */
  if (netif->mtu < DHCP_MAX_MSG_LEN_MIN_REQUIRED) {
   1c558:	e0bfff17 	ldw	r2,-4(fp)
   1c55c:	10800c0b 	ldhu	r2,48(r2)
   1c560:	10bfffcc 	andi	r2,r2,65535
   1c564:	10809028 	cmpgeui	r2,r2,576
   1c568:	1000021e 	bne	r2,zero,1c574 <dhcp_start+0xa4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): Cannot use this netif with DHCP: MTU is too small\n"));
    return ERR_MEM;
   1c56c:	00bfffc4 	movi	r2,-1
   1c570:	00004e06 	br	1c6ac <dhcp_start+0x1dc>
  }

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
   1c574:	e0bffd17 	ldw	r2,-12(fp)
   1c578:	10000b1e 	bne	r2,zero,1c5a8 <dhcp_start+0xd8>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = (struct dhcp *)mem_malloc(sizeof(struct dhcp));
   1c57c:	01000f04 	movi	r4,60
   1c580:	0021e680 	call	21e68 <mem_malloc>
   1c584:	e0bffd15 	stw	r2,-12(fp)
    if (dhcp == NULL) {
   1c588:	e0bffd17 	ldw	r2,-12(fp)
   1c58c:	1000021e 	bne	r2,zero,1c598 <dhcp_start+0xc8>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
   1c590:	00bfffc4 	movi	r2,-1
   1c594:	00004506 	br	1c6ac <dhcp_start+0x1dc>
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
   1c598:	e0bfff17 	ldw	r2,-4(fp)
   1c59c:	e0fffd17 	ldw	r3,-12(fp)
   1c5a0:	10c00a15 	stw	r3,40(r2)
   1c5a4:	00000706 	br	1c5c4 <dhcp_start+0xf4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): allocated dhcp"));
  /* already has DHCP client attached */
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(): restarting DHCP configuration\n"));
    if (dhcp->pcb != NULL) {
   1c5a8:	e0bffd17 	ldw	r2,-12(fp)
   1c5ac:	10800117 	ldw	r2,4(r2)
   1c5b0:	10000426 	beq	r2,zero,1c5c4 <dhcp_start+0xf4>
      udp_remove(dhcp->pcb);
   1c5b4:	e0bffd17 	ldw	r2,-12(fp)
   1c5b8:	10800117 	ldw	r2,4(r2)
   1c5bc:	1009883a 	mov	r4,r2
   1c5c0:	002fbdc0 	call	2fbdc <udp_remove>
    LWIP_ASSERT("pbuf p_out wasn't freed", dhcp->p_out == NULL);
    LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL );
  }
    
  /* clear the previous IP assignment */
  dhcp_clear_assignment(netif);
   1c5c4:	e13fff17 	ldw	r4,-4(fp)
   1c5c8:	001b9a40 	call	1b9a4 <dhcp_clear_assignment>
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
   1c5cc:	e13ffd17 	ldw	r4,-12(fp)
   1c5d0:	000b883a 	mov	r5,zero
   1c5d4:	01800f04 	movi	r6,60
   1c5d8:	00042e80 	call	42e8 <memset>
  /* dhcp_set_state(&dhcp, DHCP_OFF); */
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
   1c5dc:	002fc780 	call	2fc78 <udp_new>
   1c5e0:	e0fffd17 	ldw	r3,-12(fp)
   1c5e4:	18800115 	stw	r2,4(r3)
  if (dhcp->pcb == NULL) {
   1c5e8:	e0bffd17 	ldw	r2,-12(fp)
   1c5ec:	10800117 	ldw	r2,4(r2)
   1c5f0:	1000021e 	bne	r2,zero,1c5fc <dhcp_start+0x12c>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    return ERR_MEM;
   1c5f4:	00bfffc4 	movi	r2,-1
   1c5f8:	00002c06 	br	1c6ac <dhcp_start+0x1dc>
  }
  ip_set_option(dhcp->pcb, SOF_BROADCAST);
   1c5fc:	e0bffd17 	ldw	r2,-12(fp)
   1c600:	10800117 	ldw	r2,4(r2)
   1c604:	e0fffd17 	ldw	r3,-12(fp)
   1c608:	18c00117 	ldw	r3,4(r3)
   1c60c:	18c00203 	ldbu	r3,8(r3)
   1c610:	18c00814 	ori	r3,r3,32
   1c614:	10c00205 	stb	r3,8(r2)
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
   1c618:	e0bffd17 	ldw	r2,-12(fp)
   1c61c:	10800117 	ldw	r2,4(r2)
   1c620:	1009883a 	mov	r4,r2
   1c624:	01400134 	movhi	r5,4
   1c628:	2955cb04 	addi	r5,r5,22316
   1c62c:	01801104 	movi	r6,68
   1c630:	002f8ec0 	call	2f8ec <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
   1c634:	e0bffd17 	ldw	r2,-12(fp)
   1c638:	10800117 	ldw	r2,4(r2)
   1c63c:	1009883a 	mov	r4,r2
   1c640:	01400134 	movhi	r5,4
   1c644:	2955cb04 	addi	r5,r5,22316
   1c648:	018010c4 	movi	r6,67
   1c64c:	002fa480 	call	2fa48 <udp_connect>
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
   1c650:	e0bffd17 	ldw	r2,-12(fp)
   1c654:	10800117 	ldw	r2,4(r2)
   1c658:	1009883a 	mov	r4,r2
   1c65c:	014000b4 	movhi	r5,2
   1c660:	29789804 	addi	r5,r5,-7584
   1c664:	e1bfff17 	ldw	r6,-4(fp)
   1c668:	002fb9c0 	call	2fb9c <udp_recv>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
   1c66c:	e13fff17 	ldw	r4,-4(fp)
   1c670:	001cb140 	call	1cb14 <dhcp_discover>
   1c674:	e0bffe05 	stb	r2,-8(fp)
  if (result != ERR_OK) {
   1c678:	e0bffe07 	ldb	r2,-8(fp)
   1c67c:	10000426 	beq	r2,zero,1c690 <dhcp_start+0x1c0>
    /* free resources allocated above */
    dhcp_stop(netif);
   1c680:	e13fff17 	ldw	r4,-4(fp)
   1c684:	001d5380 	call	1d538 <dhcp_stop>
    return ERR_MEM;
   1c688:	00bfffc4 	movi	r2,-1
   1c68c:	00000706 	br	1c6ac <dhcp_start+0x1dc>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
   1c690:	e0bfff17 	ldw	r2,-4(fp)
   1c694:	10800e43 	ldbu	r2,57(r2)
   1c698:	10800214 	ori	r2,r2,8
   1c69c:	1007883a 	mov	r3,r2
   1c6a0:	e0bfff17 	ldw	r2,-4(fp)
   1c6a4:	10c00e45 	stb	r3,57(r2)
  return result;
   1c6a8:	e0bffe03 	ldbu	r2,-8(fp)
}
   1c6ac:	e037883a 	mov	sp,fp
   1c6b0:	dfc00117 	ldw	ra,4(sp)
   1c6b4:	df000017 	ldw	fp,0(sp)
   1c6b8:	dec00204 	addi	sp,sp,8
   1c6bc:	f800283a 	ret

0001c6c0 <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
   1c6c0:	deffeb04 	addi	sp,sp,-84
   1c6c4:	dfc01415 	stw	ra,80(sp)
   1c6c8:	df001315 	stw	fp,76(sp)
   1c6cc:	df001304 	addi	fp,sp,76
   1c6d0:	e13fff15 	stw	r4,-4(fp)
  struct dhcp dhcp;
  err_t result = ERR_OK;
   1c6d4:	e03fef05 	stb	zero,-68(fp)
  struct udp_pcb *pcb;

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
   1c6d8:	e0bfff17 	ldw	r2,-4(fp)
   1c6dc:	1000091e 	bne	r2,zero,1c704 <dhcp_inform+0x44>
   1c6e0:	01000134 	movhi	r4,4
   1c6e4:	21040004 	addi	r4,r4,4096
   1c6e8:	01400134 	movhi	r5,4
   1c6ec:	29440c04 	addi	r5,r5,4144
   1c6f0:	0180b6c4 	movi	r6,731
   1c6f4:	01c00134 	movhi	r7,4
   1c6f8:	39c41004 	addi	r7,r7,4160
   1c6fc:	00044740 	call	4474 <printf>
   1c700:	003fff06 	br	1c700 <dhcp_inform+0x40>

  memset(&dhcp, 0, sizeof(struct dhcp));
   1c704:	e0bff004 	addi	r2,fp,-64
   1c708:	1009883a 	mov	r4,r2
   1c70c:	000b883a 	mov	r5,zero
   1c710:	01800f04 	movi	r6,60
   1c714:	00042e80 	call	42e8 <memset>
  dhcp_set_state(&dhcp, DHCP_INFORM);
   1c718:	e0bff004 	addi	r2,fp,-64
   1c71c:	1009883a 	mov	r4,r2
   1c720:	01400204 	movi	r5,8
   1c724:	001d5ec0 	call	1d5ec <dhcp_set_state>

  if ((netif->dhcp != NULL) && (netif->dhcp->pcb != NULL)) {
   1c728:	e0bfff17 	ldw	r2,-4(fp)
   1c72c:	10800a17 	ldw	r2,40(r2)
   1c730:	10000926 	beq	r2,zero,1c758 <dhcp_inform+0x98>
   1c734:	e0bfff17 	ldw	r2,-4(fp)
   1c738:	10800a17 	ldw	r2,40(r2)
   1c73c:	10800117 	ldw	r2,4(r2)
   1c740:	10000526 	beq	r2,zero,1c758 <dhcp_inform+0x98>
    /* re-use existing pcb */
    pcb = netif->dhcp->pcb;
   1c744:	e0bfff17 	ldw	r2,-4(fp)
   1c748:	10800a17 	ldw	r2,40(r2)
   1c74c:	10800117 	ldw	r2,4(r2)
   1c750:	e0bfee15 	stw	r2,-72(fp)
   1c754:	00001106 	br	1c79c <dhcp_inform+0xdc>
  } else {
    pcb = udp_new();
   1c758:	002fc780 	call	2fc78 <udp_new>
   1c75c:	e0bfee15 	stw	r2,-72(fp)
    if (pcb == NULL) {
   1c760:	e0bfee17 	ldw	r2,-72(fp)
   1c764:	10003c26 	beq	r2,zero,1c858 <dhcp_inform+0x198>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform(): could not obtain pcb"));
      return;
    }
    dhcp.pcb = pcb;
   1c768:	e0bfee17 	ldw	r2,-72(fp)
   1c76c:	e0bff115 	stw	r2,-60(fp)
    ip_set_option(dhcp.pcb, SOF_BROADCAST);
   1c770:	e0bff117 	ldw	r2,-60(fp)
   1c774:	e0fff117 	ldw	r3,-60(fp)
   1c778:	18c00203 	ldbu	r3,8(r3)
   1c77c:	18c00814 	ori	r3,r3,32
   1c780:	10c00205 	stb	r3,8(r2)
    udp_bind(dhcp.pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
   1c784:	e0bff117 	ldw	r2,-60(fp)
   1c788:	1009883a 	mov	r4,r2
   1c78c:	01400134 	movhi	r5,4
   1c790:	2955cb04 	addi	r5,r5,22316
   1c794:	01801104 	movi	r6,68
   1c798:	002f8ec0 	call	2f8ec <udp_bind>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  }
  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, &dhcp, DHCP_INFORM);
   1c79c:	e0bff004 	addi	r2,fp,-64
   1c7a0:	e13fff17 	ldw	r4,-4(fp)
   1c7a4:	100b883a 	mov	r5,r2
   1c7a8:	01800204 	movi	r6,8
   1c7ac:	001e5b40 	call	1e5b4 <dhcp_create_msg>
   1c7b0:	e0bfef05 	stb	r2,-68(fp)
  if (result == ERR_OK) {
   1c7b4:	e0bfef07 	ldb	r2,-68(fp)
   1c7b8:	1000221e 	bne	r2,zero,1c844 <dhcp_inform+0x184>
    dhcp_option(&dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
   1c7bc:	e0bff004 	addi	r2,fp,-64
   1c7c0:	1009883a 	mov	r4,r2
   1c7c4:	01400e44 	movi	r5,57
   1c7c8:	01800084 	movi	r6,2
   1c7cc:	001d6440 	call	1d644 <dhcp_option>
    dhcp_option_short(&dhcp, DHCP_MAX_MSG_LEN(netif));
   1c7d0:	e0bfff17 	ldw	r2,-4(fp)
   1c7d4:	10800c0b 	ldhu	r2,48(r2)
   1c7d8:	10bfffcc 	andi	r2,r2,65535
   1c7dc:	e0fff004 	addi	r3,fp,-64
   1c7e0:	1809883a 	mov	r4,r3
   1c7e4:	100b883a 	mov	r5,r2
   1c7e8:	001d7380 	call	1d738 <dhcp_option_short>

    dhcp_option_trailer(&dhcp);
   1c7ec:	e0bff004 	addi	r2,fp,-64
   1c7f0:	1009883a 	mov	r4,r2
   1c7f4:	001eb740 	call	1eb74 <dhcp_option_trailer>

    pbuf_realloc(dhcp.p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp.options_out_len);
   1c7f8:	e0fff417 	ldw	r3,-48(fp)
   1c7fc:	e0bff60b 	ldhu	r2,-40(fp)
   1c800:	10803c04 	addi	r2,r2,240
   1c804:	10bfffcc 	andi	r2,r2,65535
   1c808:	1809883a 	mov	r4,r3
   1c80c:	100b883a 	mov	r5,r2
   1c810:	00234500 	call	23450 <pbuf_realloc>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(pcb, dhcp.p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
   1c814:	e0bff417 	ldw	r2,-48(fp)
   1c818:	e0ffff17 	ldw	r3,-4(fp)
   1c81c:	d8c00015 	stw	r3,0(sp)
   1c820:	e13fee17 	ldw	r4,-72(fp)
   1c824:	100b883a 	mov	r5,r2
   1c828:	01800134 	movhi	r6,4
   1c82c:	3195cc04 	addi	r6,r6,22320
   1c830:	01c010c4 	movi	r7,67
   1c834:	002f4780 	call	2f478 <udp_sendto_if>
    dhcp_delete_msg(&dhcp);
   1c838:	e0bff004 	addi	r2,fp,-64
   1c83c:	1009883a 	mov	r4,r2
   1c840:	001eaf40 	call	1eaf4 <dhcp_delete_msg>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp.pcb != NULL) {
   1c844:	e0bff117 	ldw	r2,-60(fp)
   1c848:	10000326 	beq	r2,zero,1c858 <dhcp_inform+0x198>
    /* otherwise, the existing pcb was used */
    udp_remove(dhcp.pcb);
   1c84c:	e0bff117 	ldw	r2,-60(fp)
   1c850:	1009883a 	mov	r4,r2
   1c854:	002fbdc0 	call	2fbdc <udp_remove>
  }
}
   1c858:	e037883a 	mov	sp,fp
   1c85c:	dfc00117 	ldw	ra,4(sp)
   1c860:	df000017 	ldw	fp,0(sp)
   1c864:	dec00204 	addi	sp,sp,8
   1c868:	f800283a 	ret

0001c86c <dhcp_network_changed>:
 * This enters the REBOOTING state to verify that the currently bound
 * address is still valid.
 */
void
dhcp_network_changed(struct netif *netif)
{
   1c86c:	defffc04 	addi	sp,sp,-16
   1c870:	dfc00315 	stw	ra,12(sp)
   1c874:	df000215 	stw	fp,8(sp)
   1c878:	df000204 	addi	fp,sp,8
   1c87c:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
   1c880:	e0bfff17 	ldw	r2,-4(fp)
   1c884:	10800a17 	ldw	r2,40(r2)
   1c888:	e0bffe15 	stw	r2,-8(fp)
  if (!dhcp)
   1c88c:	e0bffe17 	ldw	r2,-8(fp)
   1c890:	10001826 	beq	r2,zero,1c8f4 <dhcp_network_changed+0x88>
    return;
  switch (dhcp->state) {
   1c894:	e0bffe17 	ldw	r2,-8(fp)
   1c898:	10800303 	ldbu	r2,12(r2)
   1c89c:	10803fcc 	andi	r2,r2,255
   1c8a0:	10c00188 	cmpgei	r3,r2,6
   1c8a4:	1800041e 	bne	r3,zero,1c8b8 <dhcp_network_changed+0x4c>
   1c8a8:	10c000c8 	cmpgei	r3,r2,3
   1c8ac:	1800041e 	bne	r3,zero,1c8c0 <dhcp_network_changed+0x54>
   1c8b0:	10001226 	beq	r2,zero,1c8fc <dhcp_network_changed+0x90>
   1c8b4:	00000906 	br	1c8dc <dhcp_network_changed+0x70>
   1c8b8:	108002a0 	cmpeqi	r2,r2,10
   1c8bc:	10000726 	beq	r2,zero,1c8dc <dhcp_network_changed+0x70>
  case DHCP_REBINDING:
  case DHCP_RENEWING:
  case DHCP_BOUND:
  case DHCP_REBOOTING:
    netif_set_down(netif);
   1c8c0:	e13fff17 	ldw	r4,-4(fp)
   1c8c4:	0022c1c0 	call	22c1c <netif_set_down>
    dhcp->tries = 0;
   1c8c8:	e0bffe17 	ldw	r2,-8(fp)
   1c8cc:	10000345 	stb	zero,13(r2)
    dhcp_reboot(netif);
   1c8d0:	e13fff17 	ldw	r4,-4(fp)
   1c8d4:	001d1ec0 	call	1d1ec <dhcp_reboot>
    break;
   1c8d8:	00000906 	br	1c900 <dhcp_network_changed+0x94>
  case DHCP_OFF:
    /* stay off */
    break;
  default:
    dhcp->tries = 0;
   1c8dc:	e0bffe17 	ldw	r2,-8(fp)
   1c8e0:	10000345 	stb	zero,13(r2)
    if(dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_ON) {
      autoip_stop(netif);
      dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
    }
#endif /* LWIP_DHCP_AUTOIP_COOP */
    dhcp_discover(netif);
   1c8e4:	e13fff17 	ldw	r4,-4(fp)
   1c8e8:	001cb140 	call	1cb14 <dhcp_discover>
    break;
   1c8ec:	0001883a 	nop
   1c8f0:	00000306 	br	1c900 <dhcp_network_changed+0x94>
void
dhcp_network_changed(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  if (!dhcp)
    return;
   1c8f4:	0001883a 	nop
   1c8f8:	00000106 	br	1c900 <dhcp_network_changed+0x94>
    dhcp->tries = 0;
    dhcp_reboot(netif);
    break;
  case DHCP_OFF:
    /* stay off */
    break;
   1c8fc:	0001883a 	nop
    }
#endif /* LWIP_DHCP_AUTOIP_COOP */
    dhcp_discover(netif);
    break;
  }
}
   1c900:	e037883a 	mov	sp,fp
   1c904:	dfc00117 	ldw	ra,4(sp)
   1c908:	df000017 	ldw	fp,0(sp)
   1c90c:	dec00204 	addi	sp,sp,8
   1c910:	f800283a 	ret

0001c914 <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, ip_addr_t *addr)
{
   1c914:	defffc04 	addi	sp,sp,-16
   1c918:	dfc00315 	stw	ra,12(sp)
   1c91c:	df000215 	stw	fp,8(sp)
   1c920:	df000204 	addi	fp,sp,8
   1c924:	e13ffe15 	stw	r4,-8(fp)
   1c928:	e17fff15 	stw	r5,-4(fp)
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
   1c92c:	e0bffe17 	ldw	r2,-8(fp)
   1c930:	1000091e 	bne	r2,zero,1c958 <dhcp_arp_reply+0x44>
   1c934:	01000134 	movhi	r4,4
   1c938:	21040004 	addi	r4,r4,4096
   1c93c:	01400134 	movhi	r5,4
   1c940:	29440c04 	addi	r5,r5,4144
   1c944:	0180cc84 	movi	r6,818
   1c948:	01c00134 	movhi	r7,4
   1c94c:	39c41004 	addi	r7,r7,4160
   1c950:	00044740 	call	4474 <printf>
   1c954:	003fff06 	br	1c954 <dhcp_arp_reply+0x40>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
   1c958:	e0bffe17 	ldw	r2,-8(fp)
   1c95c:	10800a17 	ldw	r2,40(r2)
   1c960:	10000e26 	beq	r2,zero,1c99c <dhcp_arp_reply+0x88>
   1c964:	e0bffe17 	ldw	r2,-8(fp)
   1c968:	10800a17 	ldw	r2,40(r2)
   1c96c:	10800303 	ldbu	r2,12(r2)
   1c970:	10803fcc 	andi	r2,r2,255
   1c974:	10800218 	cmpnei	r2,r2,8
   1c978:	1000081e 	bne	r2,zero,1c99c <dhcp_arp_reply+0x88>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n",
      ip4_addr_get_u32(addr)));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
   1c97c:	e0bfff17 	ldw	r2,-4(fp)
   1c980:	10c00017 	ldw	r3,0(r2)
   1c984:	e0bffe17 	ldw	r2,-8(fp)
   1c988:	10800a17 	ldw	r2,40(r2)
   1c98c:	10800917 	ldw	r2,36(r2)
   1c990:	1880021e 	bne	r3,r2,1c99c <dhcp_arp_reply+0x88>
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
        ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
   1c994:	e13ffe17 	ldw	r4,-8(fp)
   1c998:	001c9b00 	call	1c9b0 <dhcp_decline>
    }
  }
}
   1c99c:	e037883a 	mov	sp,fp
   1c9a0:	dfc00117 	ldw	ra,4(sp)
   1c9a4:	df000017 	ldw	fp,0(sp)
   1c9a8:	dec00204 	addi	sp,sp,8
   1c9ac:	f800283a 	ret

0001c9b0 <dhcp_decline>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_decline(struct netif *netif)
{
   1c9b0:	defffa04 	addi	sp,sp,-24
   1c9b4:	dfc00515 	stw	ra,20(sp)
   1c9b8:	df000415 	stw	fp,16(sp)
   1c9bc:	df000404 	addi	fp,sp,16
   1c9c0:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
   1c9c4:	e0bfff17 	ldw	r2,-4(fp)
   1c9c8:	10800a17 	ldw	r2,40(r2)
   1c9cc:	e0bffd15 	stw	r2,-12(fp)
  err_t result = ERR_OK;
   1c9d0:	e03ffe05 	stb	zero,-8(fp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
   1c9d4:	e13ffd17 	ldw	r4,-12(fp)
   1c9d8:	01400304 	movi	r5,12
   1c9dc:	001d5ec0 	call	1d5ec <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_DECLINE);
   1c9e0:	e13fff17 	ldw	r4,-4(fp)
   1c9e4:	e17ffd17 	ldw	r5,-12(fp)
   1c9e8:	01800104 	movi	r6,4
   1c9ec:	001e5b40 	call	1e5b4 <dhcp_create_msg>
   1c9f0:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
   1c9f4:	e0bffe07 	ldb	r2,-8(fp)
   1c9f8:	1000311e 	bne	r2,zero,1cac0 <dhcp_decline+0x110>
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
   1c9fc:	e13ffd17 	ldw	r4,-12(fp)
   1ca00:	01400c84 	movi	r5,50
   1ca04:	01800104 	movi	r6,4
   1ca08:	001d6440 	call	1d644 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
   1ca0c:	e0bffd17 	ldw	r2,-12(fp)
   1ca10:	10800917 	ldw	r2,36(r2)
   1ca14:	1006d63a 	srli	r3,r2,24
   1ca18:	e0bffd17 	ldw	r2,-12(fp)
   1ca1c:	10800917 	ldw	r2,36(r2)
   1ca20:	1004d23a 	srli	r2,r2,8
   1ca24:	10bfc00c 	andi	r2,r2,65280
   1ca28:	1886b03a 	or	r3,r3,r2
   1ca2c:	e0bffd17 	ldw	r2,-12(fp)
   1ca30:	10800917 	ldw	r2,36(r2)
   1ca34:	10bfc00c 	andi	r2,r2,65280
   1ca38:	1004923a 	slli	r2,r2,8
   1ca3c:	1886b03a 	or	r3,r3,r2
   1ca40:	e0bffd17 	ldw	r2,-12(fp)
   1ca44:	10800917 	ldw	r2,36(r2)
   1ca48:	1004963a 	slli	r2,r2,24
   1ca4c:	1884b03a 	or	r2,r3,r2
   1ca50:	e13ffd17 	ldw	r4,-12(fp)
   1ca54:	100b883a 	mov	r5,r2
   1ca58:	001d7cc0 	call	1d7cc <dhcp_option_long>

    dhcp_option_trailer(dhcp);
   1ca5c:	e13ffd17 	ldw	r4,-12(fp)
   1ca60:	001eb740 	call	1eb74 <dhcp_option_trailer>
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
   1ca64:	e0bffd17 	ldw	r2,-12(fp)
   1ca68:	10c00417 	ldw	r3,16(r2)
   1ca6c:	e0bffd17 	ldw	r2,-12(fp)
   1ca70:	1080060b 	ldhu	r2,24(r2)
   1ca74:	10803c04 	addi	r2,r2,240
   1ca78:	10bfffcc 	andi	r2,r2,65535
   1ca7c:	1809883a 	mov	r4,r3
   1ca80:	100b883a 	mov	r5,r2
   1ca84:	00234500 	call	23450 <pbuf_realloc>

    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
   1ca88:	e0bffd17 	ldw	r2,-12(fp)
   1ca8c:	10c00117 	ldw	r3,4(r2)
   1ca90:	e0bffd17 	ldw	r2,-12(fp)
   1ca94:	10800417 	ldw	r2,16(r2)
   1ca98:	e13fff17 	ldw	r4,-4(fp)
   1ca9c:	d9000015 	stw	r4,0(sp)
   1caa0:	1809883a 	mov	r4,r3
   1caa4:	100b883a 	mov	r5,r2
   1caa8:	01800134 	movhi	r6,4
   1caac:	3195cc04 	addi	r6,r6,22320
   1cab0:	01c010c4 	movi	r7,67
   1cab4:	002f4780 	call	2f478 <udp_sendto_if>
    dhcp_delete_msg(dhcp);
   1cab8:	e13ffd17 	ldw	r4,-12(fp)
   1cabc:	001eaf40 	call	1eaf4 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
   1cac0:	e0bffd17 	ldw	r2,-12(fp)
   1cac4:	10800343 	ldbu	r2,13(r2)
   1cac8:	10800044 	addi	r2,r2,1
   1cacc:	1007883a 	mov	r3,r2
   1cad0:	e0bffd17 	ldw	r2,-12(fp)
   1cad4:	10c00345 	stb	r3,13(r2)
  msecs = 10*1000;
   1cad8:	0089c404 	movi	r2,10000
   1cadc:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
   1cae0:	e0bffe8b 	ldhu	r2,-6(fp)
   1cae4:	10c07cc4 	addi	r3,r2,499
   1cae8:	00807d04 	movi	r2,500
   1caec:	1885283a 	div	r2,r3,r2
   1caf0:	1007883a 	mov	r3,r2
   1caf4:	e0bffd17 	ldw	r2,-12(fp)
   1caf8:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
   1cafc:	e0bffe03 	ldbu	r2,-8(fp)
}
   1cb00:	e037883a 	mov	sp,fp
   1cb04:	dfc00117 	ldw	ra,4(sp)
   1cb08:	df000017 	ldw	fp,0(sp)
   1cb0c:	dec00204 	addi	sp,sp,8
   1cb10:	f800283a 	ret

0001cb14 <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
   1cb14:	defffa04 	addi	sp,sp,-24
   1cb18:	dfc00515 	stw	ra,20(sp)
   1cb1c:	df000415 	stw	fp,16(sp)
   1cb20:	df000404 	addi	fp,sp,16
   1cb24:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
   1cb28:	e0bfff17 	ldw	r2,-4(fp)
   1cb2c:	10800a17 	ldw	r2,40(r2)
   1cb30:	e0bffd15 	stw	r2,-12(fp)
  err_t result = ERR_OK;
   1cb34:	e03ffe05 	stb	zero,-8(fp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover()\n"));
  ip_addr_set_any(&dhcp->offered_ip_addr);
   1cb38:	e0bffd17 	ldw	r2,-12(fp)
   1cb3c:	10000915 	stw	zero,36(r2)
  dhcp_set_state(dhcp, DHCP_SELECTING);
   1cb40:	e13ffd17 	ldw	r4,-12(fp)
   1cb44:	01400184 	movi	r5,6
   1cb48:	001d5ec0 	call	1d5ec <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_DISCOVER);
   1cb4c:	e13fff17 	ldw	r4,-4(fp)
   1cb50:	e17ffd17 	ldw	r5,-12(fp)
   1cb54:	01800044 	movi	r6,1
   1cb58:	001e5b40 	call	1e5b4 <dhcp_create_msg>
   1cb5c:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
   1cb60:	e0bffe07 	ldb	r2,-8(fp)
   1cb64:	1000331e 	bne	r2,zero,1cc34 <dhcp_discover+0x120>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
   1cb68:	e13ffd17 	ldw	r4,-12(fp)
   1cb6c:	01400e44 	movi	r5,57
   1cb70:	01800084 	movi	r6,2
   1cb74:	001d6440 	call	1d644 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
   1cb78:	e0bfff17 	ldw	r2,-4(fp)
   1cb7c:	10800c0b 	ldhu	r2,48(r2)
   1cb80:	10bfffcc 	andi	r2,r2,65535
   1cb84:	e13ffd17 	ldw	r4,-12(fp)
   1cb88:	100b883a 	mov	r5,r2
   1cb8c:	001d7380 	call	1d738 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
   1cb90:	e13ffd17 	ldw	r4,-12(fp)
   1cb94:	01400dc4 	movi	r5,55
   1cb98:	01800104 	movi	r6,4
   1cb9c:	001d6440 	call	1d644 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
   1cba0:	e13ffd17 	ldw	r4,-12(fp)
   1cba4:	01400044 	movi	r5,1
   1cba8:	001d6dc0 	call	1d6dc <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
   1cbac:	e13ffd17 	ldw	r4,-12(fp)
   1cbb0:	014000c4 	movi	r5,3
   1cbb4:	001d6dc0 	call	1d6dc <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
   1cbb8:	e13ffd17 	ldw	r4,-12(fp)
   1cbbc:	01400704 	movi	r5,28
   1cbc0:	001d6dc0 	call	1d6dc <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
   1cbc4:	e13ffd17 	ldw	r4,-12(fp)
   1cbc8:	01400184 	movi	r5,6
   1cbcc:	001d6dc0 	call	1d6dc <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
   1cbd0:	e13ffd17 	ldw	r4,-12(fp)
   1cbd4:	001eb740 	call	1eb74 <dhcp_option_trailer>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
   1cbd8:	e0bffd17 	ldw	r2,-12(fp)
   1cbdc:	10c00417 	ldw	r3,16(r2)
   1cbe0:	e0bffd17 	ldw	r2,-12(fp)
   1cbe4:	1080060b 	ldhu	r2,24(r2)
   1cbe8:	10803c04 	addi	r2,r2,240
   1cbec:	10bfffcc 	andi	r2,r2,65535
   1cbf0:	1809883a 	mov	r4,r3
   1cbf4:	100b883a 	mov	r5,r2
   1cbf8:	00234500 	call	23450 <pbuf_realloc>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
   1cbfc:	e0bffd17 	ldw	r2,-12(fp)
   1cc00:	10c00117 	ldw	r3,4(r2)
   1cc04:	e0bffd17 	ldw	r2,-12(fp)
   1cc08:	10800417 	ldw	r2,16(r2)
   1cc0c:	e13fff17 	ldw	r4,-4(fp)
   1cc10:	d9000015 	stw	r4,0(sp)
   1cc14:	1809883a 	mov	r4,r3
   1cc18:	100b883a 	mov	r5,r2
   1cc1c:	01800134 	movhi	r6,4
   1cc20:	3195cc04 	addi	r6,r6,22320
   1cc24:	01c010c4 	movi	r7,67
   1cc28:	002f4780 	call	2f478 <udp_sendto_if>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_msg(dhcp);
   1cc2c:	e13ffd17 	ldw	r4,-12(fp)
   1cc30:	001eaf40 	call	1eaf4 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
   1cc34:	e0bffd17 	ldw	r2,-12(fp)
   1cc38:	10800343 	ldbu	r2,13(r2)
   1cc3c:	10800044 	addi	r2,r2,1
   1cc40:	1007883a 	mov	r3,r2
   1cc44:	e0bffd17 	ldw	r2,-12(fp)
   1cc48:	10c00345 	stb	r3,13(r2)
  if(dhcp->tries >= LWIP_DHCP_AUTOIP_COOP_TRIES && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
   1cc4c:	e0bffd17 	ldw	r2,-12(fp)
   1cc50:	10800343 	ldbu	r2,13(r2)
   1cc54:	10803fcc 	andi	r2,r2,255
   1cc58:	108001a8 	cmpgeui	r2,r2,6
   1cc5c:	1000061e 	bne	r2,zero,1cc78 <dhcp_discover+0x164>
   1cc60:	e0bffd17 	ldw	r2,-12(fp)
   1cc64:	10800343 	ldbu	r2,13(r2)
   1cc68:	10803fcc 	andi	r2,r2,255
   1cc6c:	00c0fa04 	movi	r3,1000
   1cc70:	1884983a 	sll	r2,r3,r2
   1cc74:	00000106 	br	1cc7c <dhcp_discover+0x168>
   1cc78:	00ba9804 	movi	r2,-5536
   1cc7c:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
   1cc80:	e0bffe8b 	ldhu	r2,-6(fp)
   1cc84:	10c07cc4 	addi	r3,r2,499
   1cc88:	00807d04 	movi	r2,500
   1cc8c:	1885283a 	div	r2,r3,r2
   1cc90:	1007883a 	mov	r3,r2
   1cc94:	e0bffd17 	ldw	r2,-12(fp)
   1cc98:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
   1cc9c:	e0bffe03 	ldbu	r2,-8(fp)
}
   1cca0:	e037883a 	mov	sp,fp
   1cca4:	dfc00117 	ldw	ra,4(sp)
   1cca8:	df000017 	ldw	fp,0(sp)
   1ccac:	dec00204 	addi	sp,sp,8
   1ccb0:	f800283a 	ret

0001ccb4 <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
   1ccb4:	defff804 	addi	sp,sp,-32
   1ccb8:	dfc00715 	stw	ra,28(sp)
   1ccbc:	df000615 	stw	fp,24(sp)
   1ccc0:	df000604 	addi	fp,sp,24
   1ccc4:	e13fff15 	stw	r4,-4(fp)
  u32_t timeout;
  struct dhcp *dhcp;
  ip_addr_t sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
   1ccc8:	e0bfff17 	ldw	r2,-4(fp)
   1cccc:	1000091e 	bne	r2,zero,1ccf4 <dhcp_bind+0x40>
   1ccd0:	01000134 	movhi	r4,4
   1ccd4:	21040004 	addi	r4,r4,4096
   1ccd8:	01400134 	movhi	r5,4
   1ccdc:	29441604 	addi	r5,r5,4184
   1cce0:	0180ec44 	movi	r6,945
   1cce4:	01c00134 	movhi	r7,4
   1cce8:	39c41004 	addi	r7,r7,4160
   1ccec:	00044740 	call	4474 <printf>
   1ccf0:	003fff06 	br	1ccf0 <dhcp_bind+0x3c>
  dhcp = netif->dhcp;
   1ccf4:	e0bfff17 	ldw	r2,-4(fp)
   1ccf8:	10800a17 	ldw	r2,40(r2)
   1ccfc:	e0bffb15 	stw	r2,-20(fp)
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
   1cd00:	e0bffb17 	ldw	r2,-20(fp)
   1cd04:	1000091e 	bne	r2,zero,1cd2c <dhcp_bind+0x78>
   1cd08:	01000134 	movhi	r4,4
   1cd0c:	21040004 	addi	r4,r4,4096
   1cd10:	01400134 	movhi	r5,4
   1cd14:	29441d04 	addi	r5,r5,4212
   1cd18:	0180ecc4 	movi	r6,947
   1cd1c:	01c00134 	movhi	r7,4
   1cd20:	39c41004 	addi	r7,r7,4160
   1cd24:	00044740 	call	4474 <printf>
   1cd28:	003fff06 	br	1cd28 <dhcp_bind+0x74>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
   1cd2c:	e0bffb17 	ldw	r2,-20(fp)
   1cd30:	10800d17 	ldw	r2,52(r2)
   1cd34:	10bfffe0 	cmpeqi	r2,r2,-1
   1cd38:	1000161e 	bne	r2,zero,1cd94 <dhcp_bind+0xe0>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
   1cd3c:	e0bffb17 	ldw	r2,-20(fp)
   1cd40:	10800d17 	ldw	r2,52(r2)
   1cd44:	10c00784 	addi	r3,r2,30
   1cd48:	00800f04 	movi	r2,60
   1cd4c:	1885203a 	divu	r2,r3,r2
   1cd50:	e0bffa15 	stw	r2,-24(fp)
    if(timeout > 0xffff) {
   1cd54:	e0bffa17 	ldw	r2,-24(fp)
   1cd58:	00ffffd4 	movui	r3,65535
   1cd5c:	1880022e 	bgeu	r3,r2,1cd68 <dhcp_bind+0xb4>
      timeout = 0xffff;
   1cd60:	00bfffd4 	movui	r2,65535
   1cd64:	e0bffa15 	stw	r2,-24(fp)
    }
    dhcp->t1_timeout = (u16_t)timeout;
   1cd68:	e0bffa17 	ldw	r2,-24(fp)
   1cd6c:	1007883a 	mov	r3,r2
   1cd70:	e0bffb17 	ldw	r2,-20(fp)
   1cd74:	10c0070d 	sth	r3,28(r2)
    if (dhcp->t1_timeout == 0) {
   1cd78:	e0bffb17 	ldw	r2,-20(fp)
   1cd7c:	1080070b 	ldhu	r2,28(r2)
   1cd80:	10bfffcc 	andi	r2,r2,65535
   1cd84:	1000031e 	bne	r2,zero,1cd94 <dhcp_bind+0xe0>
      dhcp->t1_timeout = 1;
   1cd88:	e0bffb17 	ldw	r2,-20(fp)
   1cd8c:	00c00044 	movi	r3,1
   1cd90:	10c0070d 	sth	r3,28(r2)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
   1cd94:	e0bffb17 	ldw	r2,-20(fp)
   1cd98:	10800e17 	ldw	r2,56(r2)
   1cd9c:	10bfffe0 	cmpeqi	r2,r2,-1
   1cda0:	1000161e 	bne	r2,zero,1cdfc <dhcp_bind+0x148>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
   1cda4:	e0bffb17 	ldw	r2,-20(fp)
   1cda8:	10800e17 	ldw	r2,56(r2)
   1cdac:	10c00784 	addi	r3,r2,30
   1cdb0:	00800f04 	movi	r2,60
   1cdb4:	1885203a 	divu	r2,r3,r2
   1cdb8:	e0bffa15 	stw	r2,-24(fp)
    if(timeout > 0xffff) {
   1cdbc:	e0bffa17 	ldw	r2,-24(fp)
   1cdc0:	00ffffd4 	movui	r3,65535
   1cdc4:	1880022e 	bgeu	r3,r2,1cdd0 <dhcp_bind+0x11c>
      timeout = 0xffff;
   1cdc8:	00bfffd4 	movui	r2,65535
   1cdcc:	e0bffa15 	stw	r2,-24(fp)
    }
    dhcp->t2_timeout = (u16_t)timeout;
   1cdd0:	e0bffa17 	ldw	r2,-24(fp)
   1cdd4:	1007883a 	mov	r3,r2
   1cdd8:	e0bffb17 	ldw	r2,-20(fp)
   1cddc:	10c0078d 	sth	r3,30(r2)
    if (dhcp->t2_timeout == 0) {
   1cde0:	e0bffb17 	ldw	r2,-20(fp)
   1cde4:	1080078b 	ldhu	r2,30(r2)
   1cde8:	10bfffcc 	andi	r2,r2,65535
   1cdec:	1000031e 	bne	r2,zero,1cdfc <dhcp_bind+0x148>
      dhcp->t2_timeout = 1;
   1cdf0:	e0bffb17 	ldw	r2,-20(fp)
   1cdf4:	00c00044 	movi	r3,1
   1cdf8:	10c0078d 	sth	r3,30(r2)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }

  /* If we have sub 1 minute lease, t2 and t1 will kick in at the same time. */
  if ((dhcp->t1_timeout >= dhcp->t2_timeout) && (dhcp->t2_timeout > 0)) {
   1cdfc:	e0bffb17 	ldw	r2,-20(fp)
   1ce00:	10c0070b 	ldhu	r3,28(r2)
   1ce04:	e0bffb17 	ldw	r2,-20(fp)
   1ce08:	1080078b 	ldhu	r2,30(r2)
   1ce0c:	18ffffcc 	andi	r3,r3,65535
   1ce10:	10bfffcc 	andi	r2,r2,65535
   1ce14:	18800636 	bltu	r3,r2,1ce30 <dhcp_bind+0x17c>
   1ce18:	e0bffb17 	ldw	r2,-20(fp)
   1ce1c:	1080078b 	ldhu	r2,30(r2)
   1ce20:	10bfffcc 	andi	r2,r2,65535
   1ce24:	10000226 	beq	r2,zero,1ce30 <dhcp_bind+0x17c>
    dhcp->t1_timeout = 0;
   1ce28:	e0bffb17 	ldw	r2,-20(fp)
   1ce2c:	1000070d 	sth	zero,28(r2)
  }

  if (dhcp->subnet_mask_given) {
   1ce30:	e0bffb17 	ldw	r2,-20(fp)
   1ce34:	10800383 	ldbu	r2,14(r2)
   1ce38:	10803fcc 	andi	r2,r2,255
   1ce3c:	10000426 	beq	r2,zero,1ce50 <dhcp_bind+0x19c>
    /* copy offered network mask */
    ip_addr_copy(sn_mask, dhcp->offered_sn_mask);
   1ce40:	e0bffb17 	ldw	r2,-20(fp)
   1ce44:	10800a17 	ldw	r2,40(r2)
   1ce48:	e0bffd15 	stw	r2,-12(fp)
   1ce4c:	00001506 	br	1cea4 <dhcp_bind+0x1f0>
  } else {
    /* subnet mask not given, choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&dhcp->offered_ip_addr);
   1ce50:	e0bffb17 	ldw	r2,-20(fp)
   1ce54:	10800904 	addi	r2,r2,36
   1ce58:	10800003 	ldbu	r2,0(r2)
   1ce5c:	e0bffc05 	stb	r2,-16(fp)
    if (first_octet <= 127) {
   1ce60:	e0bffc03 	ldbu	r2,-16(fp)
   1ce64:	10803fcc 	andi	r2,r2,255
   1ce68:	1080201c 	xori	r2,r2,128
   1ce6c:	10bfe004 	addi	r2,r2,-128
   1ce70:	10000316 	blt	r2,zero,1ce80 <dhcp_bind+0x1cc>
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xff000000UL));
   1ce74:	00803fc4 	movi	r2,255
   1ce78:	e0bffd15 	stw	r2,-12(fp)
   1ce7c:	00000906 	br	1cea4 <dhcp_bind+0x1f0>
    } else if (first_octet >= 192) {
   1ce80:	e0bffc03 	ldbu	r2,-16(fp)
   1ce84:	10803030 	cmpltui	r2,r2,192
   1ce88:	1000041e 	bne	r2,zero,1ce9c <dhcp_bind+0x1e8>
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffffff00UL));
   1ce8c:	00804034 	movhi	r2,256
   1ce90:	10bfffc4 	addi	r2,r2,-1
   1ce94:	e0bffd15 	stw	r2,-12(fp)
   1ce98:	00000206 	br	1cea4 <dhcp_bind+0x1f0>
    } else {
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffff0000UL));
   1ce9c:	00bfffd4 	movui	r2,65535
   1cea0:	e0bffd15 	stw	r2,-12(fp)
    }
  }

  ip_addr_copy(gw_addr, dhcp->offered_gw_addr);
   1cea4:	e0bffb17 	ldw	r2,-20(fp)
   1cea8:	10800b17 	ldw	r2,44(r2)
   1ceac:	e0bffe15 	stw	r2,-8(fp)
  /* gateway address not given? */
  if (ip_addr_isany(&gw_addr)) {
   1ceb0:	e0bffe17 	ldw	r2,-8(fp)
   1ceb4:	1000081e 	bne	r2,zero,1ced8 <dhcp_bind+0x224>
    /* copy network address */
    ip_addr_get_network(&gw_addr, &dhcp->offered_ip_addr, &sn_mask);
   1ceb8:	e0bffb17 	ldw	r2,-20(fp)
   1cebc:	10c00917 	ldw	r3,36(r2)
   1cec0:	e0bffd17 	ldw	r2,-12(fp)
   1cec4:	1884703a 	and	r2,r3,r2
   1cec8:	e0bffe15 	stw	r2,-8(fp)
    /* use first host address on network as gateway */
    ip4_addr_set_u32(&gw_addr, ip4_addr_get_u32(&gw_addr) | PP_HTONL(0x00000001UL));
   1cecc:	e0bffe17 	ldw	r2,-8(fp)
   1ced0:	10804034 	orhi	r2,r2,256
   1ced4:	e0bffe15 	stw	r2,-8(fp)
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n",
    ip4_addr_get_u32(&dhcp->offered_ip_addr)));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
   1ced8:	e0bffb17 	ldw	r2,-20(fp)
   1cedc:	10800904 	addi	r2,r2,36
   1cee0:	e13fff17 	ldw	r4,-4(fp)
   1cee4:	100b883a 	mov	r5,r2
   1cee8:	002298c0 	call	2298c <netif_set_ipaddr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n",
    ip4_addr_get_u32(&sn_mask)));
  netif_set_netmask(netif, &sn_mask);
   1ceec:	e0bffd04 	addi	r2,fp,-12
   1cef0:	e13fff17 	ldw	r4,-4(fp)
   1cef4:	100b883a 	mov	r5,r2
   1cef8:	0022b040 	call	22b04 <netif_set_netmask>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n",
    ip4_addr_get_u32(&gw_addr)));
  netif_set_gw(netif, &gw_addr);
   1cefc:	e0bffe04 	addi	r2,fp,-8
   1cf00:	e13fff17 	ldw	r4,-4(fp)
   1cf04:	100b883a 	mov	r5,r2
   1cf08:	0022ac00 	call	22ac0 <netif_set_gw>
  /* bring the interface up */
  netif_set_up(netif);
   1cf0c:	e13fff17 	ldw	r4,-4(fp)
   1cf10:	0022b700 	call	22b70 <netif_set_up>
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
   1cf14:	e13ffb17 	ldw	r4,-20(fp)
   1cf18:	01400284 	movi	r5,10
   1cf1c:	001d5ec0 	call	1d5ec <dhcp_set_state>
}
   1cf20:	e037883a 	mov	sp,fp
   1cf24:	dfc00117 	ldw	ra,4(sp)
   1cf28:	df000017 	ldw	fp,0(sp)
   1cf2c:	dec00204 	addi	sp,sp,8
   1cf30:	f800283a 	ret

0001cf34 <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
   1cf34:	defffa04 	addi	sp,sp,-24
   1cf38:	dfc00515 	stw	ra,20(sp)
   1cf3c:	df000415 	stw	fp,16(sp)
   1cf40:	df000404 	addi	fp,sp,16
   1cf44:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
   1cf48:	e0bfff17 	ldw	r2,-4(fp)
   1cf4c:	10800a17 	ldw	r2,40(r2)
   1cf50:	e0bffd15 	stw	r2,-12(fp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
   1cf54:	e13ffd17 	ldw	r4,-12(fp)
   1cf58:	01400144 	movi	r5,5
   1cf5c:	001d5ec0 	call	1d5ec <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
   1cf60:	e13fff17 	ldw	r4,-4(fp)
   1cf64:	e17ffd17 	ldw	r5,-12(fp)
   1cf68:	018000c4 	movi	r6,3
   1cf6c:	001e5b40 	call	1e5b4 <dhcp_create_msg>
   1cf70:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
   1cf74:	e0bffe07 	ldb	r2,-8(fp)
   1cf78:	1000261e 	bne	r2,zero,1d014 <dhcp_renew+0xe0>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
   1cf7c:	e13ffd17 	ldw	r4,-12(fp)
   1cf80:	01400e44 	movi	r5,57
   1cf84:	01800084 	movi	r6,2
   1cf88:	001d6440 	call	1d644 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
   1cf8c:	e0bfff17 	ldw	r2,-4(fp)
   1cf90:	10800c0b 	ldhu	r2,48(r2)
   1cf94:	10bfffcc 	andi	r2,r2,65535
   1cf98:	e13ffd17 	ldw	r4,-12(fp)
   1cf9c:	100b883a 	mov	r5,r2
   1cfa0:	001d7380 	call	1d738 <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

#if LWIP_NETIF_HOSTNAME
    dhcp_option_hostname(dhcp, netif);
   1cfa4:	e13ffd17 	ldw	r4,-12(fp)
   1cfa8:	e17fff17 	ldw	r5,-4(fp)
   1cfac:	001d8d40 	call	1d8d4 <dhcp_option_hostname>
#endif /* LWIP_NETIF_HOSTNAME */

    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
   1cfb0:	e13ffd17 	ldw	r4,-12(fp)
   1cfb4:	001eb740 	call	1eb74 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
   1cfb8:	e0bffd17 	ldw	r2,-12(fp)
   1cfbc:	10c00417 	ldw	r3,16(r2)
   1cfc0:	e0bffd17 	ldw	r2,-12(fp)
   1cfc4:	1080060b 	ldhu	r2,24(r2)
   1cfc8:	10803c04 	addi	r2,r2,240
   1cfcc:	10bfffcc 	andi	r2,r2,65535
   1cfd0:	1809883a 	mov	r4,r3
   1cfd4:	100b883a 	mov	r5,r2
   1cfd8:	00234500 	call	23450 <pbuf_realloc>

    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
   1cfdc:	e0bffd17 	ldw	r2,-12(fp)
   1cfe0:	11000117 	ldw	r4,4(r2)
   1cfe4:	e0bffd17 	ldw	r2,-12(fp)
   1cfe8:	10c00417 	ldw	r3,16(r2)
   1cfec:	e0bffd17 	ldw	r2,-12(fp)
   1cff0:	10800804 	addi	r2,r2,32
   1cff4:	e17fff17 	ldw	r5,-4(fp)
   1cff8:	d9400015 	stw	r5,0(sp)
   1cffc:	180b883a 	mov	r5,r3
   1d000:	100d883a 	mov	r6,r2
   1d004:	01c010c4 	movi	r7,67
   1d008:	002f4780 	call	2f478 <udp_sendto_if>
    dhcp_delete_msg(dhcp);
   1d00c:	e13ffd17 	ldw	r4,-12(fp)
   1d010:	001eaf40 	call	1eaf4 <dhcp_delete_msg>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
   1d014:	e0bffd17 	ldw	r2,-12(fp)
   1d018:	10800343 	ldbu	r2,13(r2)
   1d01c:	10800044 	addi	r2,r2,1
   1d020:	1007883a 	mov	r3,r2
   1d024:	e0bffd17 	ldw	r2,-12(fp)
   1d028:	10c00345 	stb	r3,13(r2)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
   1d02c:	e0bffd17 	ldw	r2,-12(fp)
   1d030:	10800343 	ldbu	r2,13(r2)
   1d034:	10803fcc 	andi	r2,r2,255
   1d038:	108002a8 	cmpgeui	r2,r2,10
   1d03c:	1000051e 	bne	r2,zero,1d054 <dhcp_renew+0x120>
   1d040:	e0bffd17 	ldw	r2,-12(fp)
   1d044:	10800343 	ldbu	r2,13(r2)
   1d048:	10803fcc 	andi	r2,r2,255
   1d04c:	1081f424 	muli	r2,r2,2000
   1d050:	00000106 	br	1d058 <dhcp_renew+0x124>
   1d054:	00938804 	movi	r2,20000
   1d058:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
   1d05c:	e0bffe8b 	ldhu	r2,-6(fp)
   1d060:	10c07cc4 	addi	r3,r2,499
   1d064:	00807d04 	movi	r2,500
   1d068:	1885283a 	div	r2,r3,r2
   1d06c:	1007883a 	mov	r3,r2
   1d070:	e0bffd17 	ldw	r2,-12(fp)
   1d074:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
   1d078:	e0bffe03 	ldbu	r2,-8(fp)
}
   1d07c:	e037883a 	mov	sp,fp
   1d080:	dfc00117 	ldw	ra,4(sp)
   1d084:	df000017 	ldw	fp,0(sp)
   1d088:	dec00204 	addi	sp,sp,8
   1d08c:	f800283a 	ret

0001d090 <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
   1d090:	defffa04 	addi	sp,sp,-24
   1d094:	dfc00515 	stw	ra,20(sp)
   1d098:	df000415 	stw	fp,16(sp)
   1d09c:	df000404 	addi	fp,sp,16
   1d0a0:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
   1d0a4:	e0bfff17 	ldw	r2,-4(fp)
   1d0a8:	10800a17 	ldw	r2,40(r2)
   1d0ac:	e0bffd15 	stw	r2,-12(fp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
   1d0b0:	e13ffd17 	ldw	r4,-12(fp)
   1d0b4:	01400104 	movi	r5,4
   1d0b8:	001d5ec0 	call	1d5ec <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
   1d0bc:	e13fff17 	ldw	r4,-4(fp)
   1d0c0:	e17ffd17 	ldw	r5,-12(fp)
   1d0c4:	018000c4 	movi	r6,3
   1d0c8:	001e5b40 	call	1e5b4 <dhcp_create_msg>
   1d0cc:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
   1d0d0:	e0bffe07 	ldb	r2,-8(fp)
   1d0d4:	1000261e 	bne	r2,zero,1d170 <dhcp_rebind+0xe0>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
   1d0d8:	e13ffd17 	ldw	r4,-12(fp)
   1d0dc:	01400e44 	movi	r5,57
   1d0e0:	01800084 	movi	r6,2
   1d0e4:	001d6440 	call	1d644 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
   1d0e8:	e0bfff17 	ldw	r2,-4(fp)
   1d0ec:	10800c0b 	ldhu	r2,48(r2)
   1d0f0:	10bfffcc 	andi	r2,r2,65535
   1d0f4:	e13ffd17 	ldw	r4,-12(fp)
   1d0f8:	100b883a 	mov	r5,r2
   1d0fc:	001d7380 	call	1d738 <dhcp_option_short>

#if LWIP_NETIF_HOSTNAME
    dhcp_option_hostname(dhcp, netif);
   1d100:	e13ffd17 	ldw	r4,-12(fp)
   1d104:	e17fff17 	ldw	r5,-4(fp)
   1d108:	001d8d40 	call	1d8d4 <dhcp_option_hostname>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
   1d10c:	e13ffd17 	ldw	r4,-12(fp)
   1d110:	001eb740 	call	1eb74 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
   1d114:	e0bffd17 	ldw	r2,-12(fp)
   1d118:	10c00417 	ldw	r3,16(r2)
   1d11c:	e0bffd17 	ldw	r2,-12(fp)
   1d120:	1080060b 	ldhu	r2,24(r2)
   1d124:	10803c04 	addi	r2,r2,240
   1d128:	10bfffcc 	andi	r2,r2,65535
   1d12c:	1809883a 	mov	r4,r3
   1d130:	100b883a 	mov	r5,r2
   1d134:	00234500 	call	23450 <pbuf_realloc>

    /* broadcast to server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
   1d138:	e0bffd17 	ldw	r2,-12(fp)
   1d13c:	10c00117 	ldw	r3,4(r2)
   1d140:	e0bffd17 	ldw	r2,-12(fp)
   1d144:	10800417 	ldw	r2,16(r2)
   1d148:	e13fff17 	ldw	r4,-4(fp)
   1d14c:	d9000015 	stw	r4,0(sp)
   1d150:	1809883a 	mov	r4,r3
   1d154:	100b883a 	mov	r5,r2
   1d158:	01800134 	movhi	r6,4
   1d15c:	3195cc04 	addi	r6,r6,22320
   1d160:	01c010c4 	movi	r7,67
   1d164:	002f4780 	call	2f478 <udp_sendto_if>
    dhcp_delete_msg(dhcp);
   1d168:	e13ffd17 	ldw	r4,-12(fp)
   1d16c:	001eaf40 	call	1eaf4 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
   1d170:	e0bffd17 	ldw	r2,-12(fp)
   1d174:	10800343 	ldbu	r2,13(r2)
   1d178:	10800044 	addi	r2,r2,1
   1d17c:	1007883a 	mov	r3,r2
   1d180:	e0bffd17 	ldw	r2,-12(fp)
   1d184:	10c00345 	stb	r3,13(r2)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
   1d188:	e0bffd17 	ldw	r2,-12(fp)
   1d18c:	10800343 	ldbu	r2,13(r2)
   1d190:	10803fcc 	andi	r2,r2,255
   1d194:	108002a8 	cmpgeui	r2,r2,10
   1d198:	1000051e 	bne	r2,zero,1d1b0 <dhcp_rebind+0x120>
   1d19c:	e0bffd17 	ldw	r2,-12(fp)
   1d1a0:	10800343 	ldbu	r2,13(r2)
   1d1a4:	10803fcc 	andi	r2,r2,255
   1d1a8:	1080fa24 	muli	r2,r2,1000
   1d1ac:	00000106 	br	1d1b4 <dhcp_rebind+0x124>
   1d1b0:	0089c404 	movi	r2,10000
   1d1b4:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
   1d1b8:	e0bffe8b 	ldhu	r2,-6(fp)
   1d1bc:	10c07cc4 	addi	r3,r2,499
   1d1c0:	00807d04 	movi	r2,500
   1d1c4:	1885283a 	div	r2,r3,r2
   1d1c8:	1007883a 	mov	r3,r2
   1d1cc:	e0bffd17 	ldw	r2,-12(fp)
   1d1d0:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
   1d1d4:	e0bffe03 	ldbu	r2,-8(fp)
}
   1d1d8:	e037883a 	mov	sp,fp
   1d1dc:	dfc00117 	ldw	ra,4(sp)
   1d1e0:	df000017 	ldw	fp,0(sp)
   1d1e4:	dec00204 	addi	sp,sp,8
   1d1e8:	f800283a 	ret

0001d1ec <dhcp_reboot>:
 *
 * @param netif network interface which must reboot
 */
static err_t
dhcp_reboot(struct netif *netif)
{
   1d1ec:	defffa04 	addi	sp,sp,-24
   1d1f0:	dfc00515 	stw	ra,20(sp)
   1d1f4:	df000415 	stw	fp,16(sp)
   1d1f8:	df000404 	addi	fp,sp,16
   1d1fc:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
   1d200:	e0bfff17 	ldw	r2,-4(fp)
   1d204:	10800a17 	ldw	r2,40(r2)
   1d208:	e0bffd15 	stw	r2,-12(fp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot()\n"));
  dhcp_set_state(dhcp, DHCP_REBOOTING);
   1d20c:	e13ffd17 	ldw	r4,-12(fp)
   1d210:	014000c4 	movi	r5,3
   1d214:	001d5ec0 	call	1d5ec <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
   1d218:	e13fff17 	ldw	r4,-4(fp)
   1d21c:	e17ffd17 	ldw	r5,-12(fp)
   1d220:	018000c4 	movi	r6,3
   1d224:	001e5b40 	call	1e5b4 <dhcp_create_msg>
   1d228:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
   1d22c:	e0bffe07 	ldb	r2,-8(fp)
   1d230:	1000381e 	bne	r2,zero,1d314 <dhcp_reboot+0x128>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
   1d234:	e13ffd17 	ldw	r4,-12(fp)
   1d238:	01400e44 	movi	r5,57
   1d23c:	01800084 	movi	r6,2
   1d240:	001d6440 	call	1d644 <dhcp_option>
    dhcp_option_short(dhcp, 576);
   1d244:	e13ffd17 	ldw	r4,-12(fp)
   1d248:	01409004 	movi	r5,576
   1d24c:	001d7380 	call	1d738 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
   1d250:	e13ffd17 	ldw	r4,-12(fp)
   1d254:	01400c84 	movi	r5,50
   1d258:	01800104 	movi	r6,4
   1d25c:	001d6440 	call	1d644 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
   1d260:	e0bffd17 	ldw	r2,-12(fp)
   1d264:	10800917 	ldw	r2,36(r2)
   1d268:	1006d63a 	srli	r3,r2,24
   1d26c:	e0bffd17 	ldw	r2,-12(fp)
   1d270:	10800917 	ldw	r2,36(r2)
   1d274:	1004d23a 	srli	r2,r2,8
   1d278:	10bfc00c 	andi	r2,r2,65280
   1d27c:	1886b03a 	or	r3,r3,r2
   1d280:	e0bffd17 	ldw	r2,-12(fp)
   1d284:	10800917 	ldw	r2,36(r2)
   1d288:	10bfc00c 	andi	r2,r2,65280
   1d28c:	1004923a 	slli	r2,r2,8
   1d290:	1886b03a 	or	r3,r3,r2
   1d294:	e0bffd17 	ldw	r2,-12(fp)
   1d298:	10800917 	ldw	r2,36(r2)
   1d29c:	1004963a 	slli	r2,r2,24
   1d2a0:	1884b03a 	or	r2,r3,r2
   1d2a4:	e13ffd17 	ldw	r4,-12(fp)
   1d2a8:	100b883a 	mov	r5,r2
   1d2ac:	001d7cc0 	call	1d7cc <dhcp_option_long>

    dhcp_option_trailer(dhcp);
   1d2b0:	e13ffd17 	ldw	r4,-12(fp)
   1d2b4:	001eb740 	call	1eb74 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
   1d2b8:	e0bffd17 	ldw	r2,-12(fp)
   1d2bc:	10c00417 	ldw	r3,16(r2)
   1d2c0:	e0bffd17 	ldw	r2,-12(fp)
   1d2c4:	1080060b 	ldhu	r2,24(r2)
   1d2c8:	10803c04 	addi	r2,r2,240
   1d2cc:	10bfffcc 	andi	r2,r2,65535
   1d2d0:	1809883a 	mov	r4,r3
   1d2d4:	100b883a 	mov	r5,r2
   1d2d8:	00234500 	call	23450 <pbuf_realloc>

    /* broadcast to server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
   1d2dc:	e0bffd17 	ldw	r2,-12(fp)
   1d2e0:	10c00117 	ldw	r3,4(r2)
   1d2e4:	e0bffd17 	ldw	r2,-12(fp)
   1d2e8:	10800417 	ldw	r2,16(r2)
   1d2ec:	e13fff17 	ldw	r4,-4(fp)
   1d2f0:	d9000015 	stw	r4,0(sp)
   1d2f4:	1809883a 	mov	r4,r3
   1d2f8:	100b883a 	mov	r5,r2
   1d2fc:	01800134 	movhi	r6,4
   1d300:	3195cc04 	addi	r6,r6,22320
   1d304:	01c010c4 	movi	r7,67
   1d308:	002f4780 	call	2f478 <udp_sendto_if>
    dhcp_delete_msg(dhcp);
   1d30c:	e13ffd17 	ldw	r4,-12(fp)
   1d310:	001eaf40 	call	1eaf4 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot: REBOOTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_reboot: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
   1d314:	e0bffd17 	ldw	r2,-12(fp)
   1d318:	10800343 	ldbu	r2,13(r2)
   1d31c:	10800044 	addi	r2,r2,1
   1d320:	1007883a 	mov	r3,r2
   1d324:	e0bffd17 	ldw	r2,-12(fp)
   1d328:	10c00345 	stb	r3,13(r2)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
   1d32c:	e0bffd17 	ldw	r2,-12(fp)
   1d330:	10800343 	ldbu	r2,13(r2)
   1d334:	10803fcc 	andi	r2,r2,255
   1d338:	108002a8 	cmpgeui	r2,r2,10
   1d33c:	1000051e 	bne	r2,zero,1d354 <dhcp_reboot+0x168>
   1d340:	e0bffd17 	ldw	r2,-12(fp)
   1d344:	10800343 	ldbu	r2,13(r2)
   1d348:	10803fcc 	andi	r2,r2,255
   1d34c:	1080fa24 	muli	r2,r2,1000
   1d350:	00000106 	br	1d358 <dhcp_reboot+0x16c>
   1d354:	0089c404 	movi	r2,10000
   1d358:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
   1d35c:	e0bffe8b 	ldhu	r2,-6(fp)
   1d360:	10c07cc4 	addi	r3,r2,499
   1d364:	00807d04 	movi	r2,500
   1d368:	1885283a 	div	r2,r3,r2
   1d36c:	1007883a 	mov	r3,r2
   1d370:	e0bffd17 	ldw	r2,-12(fp)
   1d374:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
   1d378:	e0bffe03 	ldbu	r2,-8(fp)
}
   1d37c:	e037883a 	mov	sp,fp
   1d380:	dfc00117 	ldw	ra,4(sp)
   1d384:	df000017 	ldw	fp,0(sp)
   1d388:	dec00204 	addi	sp,sp,8
   1d38c:	f800283a 	ret

0001d390 <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
   1d390:	defffa04 	addi	sp,sp,-24
   1d394:	dfc00515 	stw	ra,20(sp)
   1d398:	df000415 	stw	fp,16(sp)
   1d39c:	df000404 	addi	fp,sp,16
   1d3a0:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
   1d3a4:	e0bfff17 	ldw	r2,-4(fp)
   1d3a8:	10800a17 	ldw	r2,40(r2)
   1d3ac:	e0bffd15 	stw	r2,-12(fp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
   1d3b0:	e13ffd17 	ldw	r4,-12(fp)
   1d3b4:	000b883a 	mov	r5,zero
   1d3b8:	001d5ec0 	call	1d5ec <dhcp_set_state>
  /* clean old DHCP offer */
  ip_addr_set_zero(&dhcp->server_ip_addr);
   1d3bc:	e0bffd17 	ldw	r2,-12(fp)
   1d3c0:	10000815 	stw	zero,32(r2)
  ip_addr_set_zero(&dhcp->offered_ip_addr);
   1d3c4:	e0bffd17 	ldw	r2,-12(fp)
   1d3c8:	10000915 	stw	zero,36(r2)
  ip_addr_set_zero(&dhcp->offered_sn_mask);
   1d3cc:	e0bffd17 	ldw	r2,-12(fp)
   1d3d0:	10000a15 	stw	zero,40(r2)
  ip_addr_set_zero(&dhcp->offered_gw_addr);
   1d3d4:	e0bffd17 	ldw	r2,-12(fp)
   1d3d8:	10000b15 	stw	zero,44(r2)
#if LWIP_DHCP_BOOTP_FILE
  ip_addr_set_zero(&dhcp->offered_si_addr);
#endif /* LWIP_DHCP_BOOTP_FILE */
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
   1d3dc:	e0bffd17 	ldw	r2,-12(fp)
   1d3e0:	10000e15 	stw	zero,56(r2)
   1d3e4:	e0bffd17 	ldw	r2,-12(fp)
   1d3e8:	10c00e17 	ldw	r3,56(r2)
   1d3ec:	e0bffd17 	ldw	r2,-12(fp)
   1d3f0:	10c00d15 	stw	r3,52(r2)
   1d3f4:	e0bffd17 	ldw	r2,-12(fp)
   1d3f8:	10c00d17 	ldw	r3,52(r2)
   1d3fc:	e0bffd17 	ldw	r2,-12(fp)
   1d400:	10c00c15 	stw	r3,48(r2)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_RELEASE);
   1d404:	e13fff17 	ldw	r4,-4(fp)
   1d408:	e17ffd17 	ldw	r5,-12(fp)
   1d40c:	018001c4 	movi	r6,7
   1d410:	001e5b40 	call	1e5b4 <dhcp_create_msg>
   1d414:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
   1d418:	e0bffe07 	ldb	r2,-8(fp)
   1d41c:	1000191e 	bne	r2,zero,1d484 <dhcp_release+0xf4>
    dhcp_option_trailer(dhcp);
   1d420:	e13ffd17 	ldw	r4,-12(fp)
   1d424:	001eb740 	call	1eb74 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
   1d428:	e0bffd17 	ldw	r2,-12(fp)
   1d42c:	10c00417 	ldw	r3,16(r2)
   1d430:	e0bffd17 	ldw	r2,-12(fp)
   1d434:	1080060b 	ldhu	r2,24(r2)
   1d438:	10803c04 	addi	r2,r2,240
   1d43c:	10bfffcc 	andi	r2,r2,65535
   1d440:	1809883a 	mov	r4,r3
   1d444:	100b883a 	mov	r5,r2
   1d448:	00234500 	call	23450 <pbuf_realloc>

    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
   1d44c:	e0bffd17 	ldw	r2,-12(fp)
   1d450:	11000117 	ldw	r4,4(r2)
   1d454:	e0bffd17 	ldw	r2,-12(fp)
   1d458:	10c00417 	ldw	r3,16(r2)
   1d45c:	e0bffd17 	ldw	r2,-12(fp)
   1d460:	10800804 	addi	r2,r2,32
   1d464:	e17fff17 	ldw	r5,-4(fp)
   1d468:	d9400015 	stw	r5,0(sp)
   1d46c:	180b883a 	mov	r5,r3
   1d470:	100d883a 	mov	r6,r2
   1d474:	01c010c4 	movi	r7,67
   1d478:	002f4780 	call	2f478 <udp_sendto_if>
    dhcp_delete_msg(dhcp);
   1d47c:	e13ffd17 	ldw	r4,-12(fp)
   1d480:	001eaf40 	call	1eaf4 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
   1d484:	e0bffd17 	ldw	r2,-12(fp)
   1d488:	10800343 	ldbu	r2,13(r2)
   1d48c:	10800044 	addi	r2,r2,1
   1d490:	1007883a 	mov	r3,r2
   1d494:	e0bffd17 	ldw	r2,-12(fp)
   1d498:	10c00345 	stb	r3,13(r2)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
   1d49c:	e0bffd17 	ldw	r2,-12(fp)
   1d4a0:	10800343 	ldbu	r2,13(r2)
   1d4a4:	10803fcc 	andi	r2,r2,255
   1d4a8:	108002a8 	cmpgeui	r2,r2,10
   1d4ac:	1000051e 	bne	r2,zero,1d4c4 <dhcp_release+0x134>
   1d4b0:	e0bffd17 	ldw	r2,-12(fp)
   1d4b4:	10800343 	ldbu	r2,13(r2)
   1d4b8:	10803fcc 	andi	r2,r2,255
   1d4bc:	1080fa24 	muli	r2,r2,1000
   1d4c0:	00000106 	br	1d4c8 <dhcp_release+0x138>
   1d4c4:	0089c404 	movi	r2,10000
   1d4c8:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
   1d4cc:	e0bffe8b 	ldhu	r2,-6(fp)
   1d4d0:	10c07cc4 	addi	r3,r2,499
   1d4d4:	00807d04 	movi	r2,500
   1d4d8:	1885283a 	div	r2,r3,r2
   1d4dc:	1007883a 	mov	r3,r2
   1d4e0:	e0bffd17 	ldw	r2,-12(fp)
   1d4e4:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
   1d4e8:	e13fff17 	ldw	r4,-4(fp)
   1d4ec:	0022c1c0 	call	22c1c <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
   1d4f0:	e13fff17 	ldw	r4,-4(fp)
   1d4f4:	01400134 	movhi	r5,4
   1d4f8:	2955cb04 	addi	r5,r5,22316
   1d4fc:	002298c0 	call	2298c <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
   1d500:	e13fff17 	ldw	r4,-4(fp)
   1d504:	01400134 	movhi	r5,4
   1d508:	2955cb04 	addi	r5,r5,22316
   1d50c:	0022ac00 	call	22ac0 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
   1d510:	e13fff17 	ldw	r4,-4(fp)
   1d514:	01400134 	movhi	r5,4
   1d518:	2955cb04 	addi	r5,r5,22316
   1d51c:	0022b040 	call	22b04 <netif_set_netmask>
  
  return result;
   1d520:	e0bffe03 	ldbu	r2,-8(fp)
}
   1d524:	e037883a 	mov	sp,fp
   1d528:	dfc00117 	ldw	ra,4(sp)
   1d52c:	df000017 	ldw	fp,0(sp)
   1d530:	dec00204 	addi	sp,sp,8
   1d534:	f800283a 	ret

0001d538 <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
   1d538:	defffc04 	addi	sp,sp,-16
   1d53c:	dfc00315 	stw	ra,12(sp)
   1d540:	df000215 	stw	fp,8(sp)
   1d544:	df000204 	addi	fp,sp,8
   1d548:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
   1d54c:	e0bfff17 	ldw	r2,-4(fp)
   1d550:	1000091e 	bne	r2,zero,1d578 <dhcp_stop+0x40>
   1d554:	01000134 	movhi	r4,4
   1d558:	21040004 	addi	r4,r4,4096
   1d55c:	01400134 	movhi	r5,4
   1d560:	29442304 	addi	r5,r5,4236
   1d564:	01813504 	movi	r6,1236
   1d568:	01c00134 	movhi	r7,4
   1d56c:	39c41004 	addi	r7,r7,4160
   1d570:	00044740 	call	4474 <printf>
   1d574:	003fff06 	br	1d574 <dhcp_stop+0x3c>
  dhcp = netif->dhcp;
   1d578:	e0bfff17 	ldw	r2,-4(fp)
   1d57c:	10800a17 	ldw	r2,40(r2)
   1d580:	e0bffe15 	stw	r2,-8(fp)
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
   1d584:	e0bfff17 	ldw	r2,-4(fp)
   1d588:	10c00e43 	ldbu	r3,57(r2)
   1d58c:	00bffdc4 	movi	r2,-9
   1d590:	1884703a 	and	r2,r3,r2
   1d594:	1007883a 	mov	r3,r2
   1d598:	e0bfff17 	ldw	r2,-4(fp)
   1d59c:	10c00e45 	stb	r3,57(r2)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
   1d5a0:	e0bffe17 	ldw	r2,-8(fp)
   1d5a4:	10000c26 	beq	r2,zero,1d5d8 <dhcp_stop+0xa0>
      autoip_stop(netif);
      dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
    }
#endif /* LWIP_DHCP_AUTOIP_COOP */

    if (dhcp->pcb != NULL) {
   1d5a8:	e0bffe17 	ldw	r2,-8(fp)
   1d5ac:	10800117 	ldw	r2,4(r2)
   1d5b0:	10000626 	beq	r2,zero,1d5cc <dhcp_stop+0x94>
      udp_remove(dhcp->pcb);
   1d5b4:	e0bffe17 	ldw	r2,-8(fp)
   1d5b8:	10800117 	ldw	r2,4(r2)
   1d5bc:	1009883a 	mov	r4,r2
   1d5c0:	002fbdc0 	call	2fbdc <udp_remove>
      dhcp->pcb = NULL;
   1d5c4:	e0bffe17 	ldw	r2,-8(fp)
   1d5c8:	10000115 	stw	zero,4(r2)
    }
    LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL);
    dhcp_set_state(dhcp, DHCP_OFF);
   1d5cc:	e13ffe17 	ldw	r4,-8(fp)
   1d5d0:	000b883a 	mov	r5,zero
   1d5d4:	001d5ec0 	call	1d5ec <dhcp_set_state>
  }
}
   1d5d8:	e037883a 	mov	sp,fp
   1d5dc:	dfc00117 	ldw	ra,4(sp)
   1d5e0:	df000017 	ldw	fp,0(sp)
   1d5e4:	dec00204 	addi	sp,sp,8
   1d5e8:	f800283a 	ret

0001d5ec <dhcp_set_state>:
 *
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
   1d5ec:	defffd04 	addi	sp,sp,-12
   1d5f0:	df000215 	stw	fp,8(sp)
   1d5f4:	df000204 	addi	fp,sp,8
   1d5f8:	e13ffe15 	stw	r4,-8(fp)
   1d5fc:	2805883a 	mov	r2,r5
   1d600:	e0bfff05 	stb	r2,-4(fp)
  if (new_state != dhcp->state) {
   1d604:	e0bffe17 	ldw	r2,-8(fp)
   1d608:	10800303 	ldbu	r2,12(r2)
   1d60c:	10c03fcc 	andi	r3,r2,255
   1d610:	e0bfff03 	ldbu	r2,-4(fp)
   1d614:	18800726 	beq	r3,r2,1d634 <dhcp_set_state+0x48>
    dhcp->state = new_state;
   1d618:	e0bffe17 	ldw	r2,-8(fp)
   1d61c:	e0ffff03 	ldbu	r3,-4(fp)
   1d620:	10c00305 	stb	r3,12(r2)
    dhcp->tries = 0;
   1d624:	e0bffe17 	ldw	r2,-8(fp)
   1d628:	10000345 	stb	zero,13(r2)
    dhcp->request_timeout = 0;
   1d62c:	e0bffe17 	ldw	r2,-8(fp)
   1d630:	1000068d 	sth	zero,26(r2)
  }
}
   1d634:	e037883a 	mov	sp,fp
   1d638:	df000017 	ldw	fp,0(sp)
   1d63c:	dec00104 	addi	sp,sp,4
   1d640:	f800283a 	ret

0001d644 <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
   1d644:	defffc04 	addi	sp,sp,-16
   1d648:	df000315 	stw	fp,12(sp)
   1d64c:	df000304 	addi	fp,sp,12
   1d650:	e13ffd15 	stw	r4,-12(fp)
   1d654:	2807883a 	mov	r3,r5
   1d658:	3005883a 	mov	r2,r6
   1d65c:	e0fffe05 	stb	r3,-8(fp)
   1d660:	e0bfff05 	stb	r2,-4(fp)
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
   1d664:	e0bffd17 	ldw	r2,-12(fp)
   1d668:	11000517 	ldw	r4,20(r2)
   1d66c:	e0bffd17 	ldw	r2,-12(fp)
   1d670:	1080060b 	ldhu	r2,24(r2)
   1d674:	10ffffcc 	andi	r3,r2,65535
   1d678:	20c7883a 	add	r3,r4,r3
   1d67c:	18c03c04 	addi	r3,r3,240
   1d680:	e13ffe03 	ldbu	r4,-8(fp)
   1d684:	19000005 	stb	r4,0(r3)
   1d688:	10800044 	addi	r2,r2,1
   1d68c:	1007883a 	mov	r3,r2
   1d690:	e0bffd17 	ldw	r2,-12(fp)
   1d694:	10c0060d 	sth	r3,24(r2)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
   1d698:	e0bffd17 	ldw	r2,-12(fp)
   1d69c:	11000517 	ldw	r4,20(r2)
   1d6a0:	e0bffd17 	ldw	r2,-12(fp)
   1d6a4:	1080060b 	ldhu	r2,24(r2)
   1d6a8:	10ffffcc 	andi	r3,r2,65535
   1d6ac:	20c7883a 	add	r3,r4,r3
   1d6b0:	18c03c04 	addi	r3,r3,240
   1d6b4:	e13fff03 	ldbu	r4,-4(fp)
   1d6b8:	19000005 	stb	r4,0(r3)
   1d6bc:	10800044 	addi	r2,r2,1
   1d6c0:	1007883a 	mov	r3,r2
   1d6c4:	e0bffd17 	ldw	r2,-12(fp)
   1d6c8:	10c0060d 	sth	r3,24(r2)
}
   1d6cc:	e037883a 	mov	sp,fp
   1d6d0:	df000017 	ldw	fp,0(sp)
   1d6d4:	dec00104 	addi	sp,sp,4
   1d6d8:	f800283a 	ret

0001d6dc <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
   1d6dc:	defffd04 	addi	sp,sp,-12
   1d6e0:	df000215 	stw	fp,8(sp)
   1d6e4:	df000204 	addi	fp,sp,8
   1d6e8:	e13ffe15 	stw	r4,-8(fp)
   1d6ec:	2805883a 	mov	r2,r5
   1d6f0:	e0bfff05 	stb	r2,-4(fp)
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
   1d6f4:	e0bffe17 	ldw	r2,-8(fp)
   1d6f8:	11000517 	ldw	r4,20(r2)
   1d6fc:	e0bffe17 	ldw	r2,-8(fp)
   1d700:	1080060b 	ldhu	r2,24(r2)
   1d704:	10ffffcc 	andi	r3,r2,65535
   1d708:	20c7883a 	add	r3,r4,r3
   1d70c:	18c03c04 	addi	r3,r3,240
   1d710:	e13fff03 	ldbu	r4,-4(fp)
   1d714:	19000005 	stb	r4,0(r3)
   1d718:	10800044 	addi	r2,r2,1
   1d71c:	1007883a 	mov	r3,r2
   1d720:	e0bffe17 	ldw	r2,-8(fp)
   1d724:	10c0060d 	sth	r3,24(r2)
}
   1d728:	e037883a 	mov	sp,fp
   1d72c:	df000017 	ldw	fp,0(sp)
   1d730:	dec00104 	addi	sp,sp,4
   1d734:	f800283a 	ret

0001d738 <dhcp_option_short>:

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
   1d738:	defffd04 	addi	sp,sp,-12
   1d73c:	df000215 	stw	fp,8(sp)
   1d740:	df000204 	addi	fp,sp,8
   1d744:	e13ffe15 	stw	r4,-8(fp)
   1d748:	2805883a 	mov	r2,r5
   1d74c:	e0bfff0d 	sth	r2,-4(fp)
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
   1d750:	e0bffe17 	ldw	r2,-8(fp)
   1d754:	11400517 	ldw	r5,20(r2)
   1d758:	e0bffe17 	ldw	r2,-8(fp)
   1d75c:	1080060b 	ldhu	r2,24(r2)
   1d760:	10ffffcc 	andi	r3,r2,65535
   1d764:	e13fff0b 	ldhu	r4,-4(fp)
   1d768:	2008d23a 	srli	r4,r4,8
   1d76c:	28c7883a 	add	r3,r5,r3
   1d770:	18c03c04 	addi	r3,r3,240
   1d774:	19000005 	stb	r4,0(r3)
   1d778:	10800044 	addi	r2,r2,1
   1d77c:	1007883a 	mov	r3,r2
   1d780:	e0bffe17 	ldw	r2,-8(fp)
   1d784:	10c0060d 	sth	r3,24(r2)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
   1d788:	e0bffe17 	ldw	r2,-8(fp)
   1d78c:	11400517 	ldw	r5,20(r2)
   1d790:	e0bffe17 	ldw	r2,-8(fp)
   1d794:	1080060b 	ldhu	r2,24(r2)
   1d798:	10ffffcc 	andi	r3,r2,65535
   1d79c:	e13fff0b 	ldhu	r4,-4(fp)
   1d7a0:	28c7883a 	add	r3,r5,r3
   1d7a4:	18c03c04 	addi	r3,r3,240
   1d7a8:	19000005 	stb	r4,0(r3)
   1d7ac:	10800044 	addi	r2,r2,1
   1d7b0:	1007883a 	mov	r3,r2
   1d7b4:	e0bffe17 	ldw	r2,-8(fp)
   1d7b8:	10c0060d 	sth	r3,24(r2)
}
   1d7bc:	e037883a 	mov	sp,fp
   1d7c0:	df000017 	ldw	fp,0(sp)
   1d7c4:	dec00104 	addi	sp,sp,4
   1d7c8:	f800283a 	ret

0001d7cc <dhcp_option_long>:

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
   1d7cc:	defffd04 	addi	sp,sp,-12
   1d7d0:	df000215 	stw	fp,8(sp)
   1d7d4:	df000204 	addi	fp,sp,8
   1d7d8:	e13ffe15 	stw	r4,-8(fp)
   1d7dc:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
   1d7e0:	e0bffe17 	ldw	r2,-8(fp)
   1d7e4:	11400517 	ldw	r5,20(r2)
   1d7e8:	e0bffe17 	ldw	r2,-8(fp)
   1d7ec:	1080060b 	ldhu	r2,24(r2)
   1d7f0:	10ffffcc 	andi	r3,r2,65535
   1d7f4:	e13fff17 	ldw	r4,-4(fp)
   1d7f8:	2008d63a 	srli	r4,r4,24
   1d7fc:	28c7883a 	add	r3,r5,r3
   1d800:	18c03c04 	addi	r3,r3,240
   1d804:	19000005 	stb	r4,0(r3)
   1d808:	10800044 	addi	r2,r2,1
   1d80c:	1007883a 	mov	r3,r2
   1d810:	e0bffe17 	ldw	r2,-8(fp)
   1d814:	10c0060d 	sth	r3,24(r2)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
   1d818:	e0bffe17 	ldw	r2,-8(fp)
   1d81c:	11400517 	ldw	r5,20(r2)
   1d820:	e0bffe17 	ldw	r2,-8(fp)
   1d824:	1080060b 	ldhu	r2,24(r2)
   1d828:	10ffffcc 	andi	r3,r2,65535
   1d82c:	e13fff17 	ldw	r4,-4(fp)
   1d830:	21003fec 	andhi	r4,r4,255
   1d834:	2008d43a 	srli	r4,r4,16
   1d838:	28c7883a 	add	r3,r5,r3
   1d83c:	18c03c04 	addi	r3,r3,240
   1d840:	19000005 	stb	r4,0(r3)
   1d844:	10800044 	addi	r2,r2,1
   1d848:	1007883a 	mov	r3,r2
   1d84c:	e0bffe17 	ldw	r2,-8(fp)
   1d850:	10c0060d 	sth	r3,24(r2)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
   1d854:	e0bffe17 	ldw	r2,-8(fp)
   1d858:	11400517 	ldw	r5,20(r2)
   1d85c:	e0bffe17 	ldw	r2,-8(fp)
   1d860:	1080060b 	ldhu	r2,24(r2)
   1d864:	10ffffcc 	andi	r3,r2,65535
   1d868:	e13fff17 	ldw	r4,-4(fp)
   1d86c:	213fc00c 	andi	r4,r4,65280
   1d870:	2008d23a 	srli	r4,r4,8
   1d874:	28c7883a 	add	r3,r5,r3
   1d878:	18c03c04 	addi	r3,r3,240
   1d87c:	19000005 	stb	r4,0(r3)
   1d880:	10800044 	addi	r2,r2,1
   1d884:	1007883a 	mov	r3,r2
   1d888:	e0bffe17 	ldw	r2,-8(fp)
   1d88c:	10c0060d 	sth	r3,24(r2)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
   1d890:	e0bffe17 	ldw	r2,-8(fp)
   1d894:	11400517 	ldw	r5,20(r2)
   1d898:	e0bffe17 	ldw	r2,-8(fp)
   1d89c:	1080060b 	ldhu	r2,24(r2)
   1d8a0:	10ffffcc 	andi	r3,r2,65535
   1d8a4:	e13fff17 	ldw	r4,-4(fp)
   1d8a8:	28c7883a 	add	r3,r5,r3
   1d8ac:	18c03c04 	addi	r3,r3,240
   1d8b0:	19000005 	stb	r4,0(r3)
   1d8b4:	10800044 	addi	r2,r2,1
   1d8b8:	1007883a 	mov	r3,r2
   1d8bc:	e0bffe17 	ldw	r2,-8(fp)
   1d8c0:	10c0060d 	sth	r3,24(r2)
}
   1d8c4:	e037883a 	mov	sp,fp
   1d8c8:	df000017 	ldw	fp,0(sp)
   1d8cc:	dec00104 	addi	sp,sp,4
   1d8d0:	f800283a 	ret

0001d8d4 <dhcp_option_hostname>:

#if LWIP_NETIF_HOSTNAME
static void
dhcp_option_hostname(struct dhcp *dhcp, struct netif *netif)
{
   1d8d4:	defff804 	addi	sp,sp,-32
   1d8d8:	dfc00715 	stw	ra,28(sp)
   1d8dc:	df000615 	stw	fp,24(sp)
   1d8e0:	df000604 	addi	fp,sp,24
   1d8e4:	e13ffe15 	stw	r4,-8(fp)
   1d8e8:	e17fff15 	stw	r5,-4(fp)
  if (netif->hostname != NULL) {
   1d8ec:	e0bfff17 	ldw	r2,-4(fp)
   1d8f0:	10800b17 	ldw	r2,44(r2)
   1d8f4:	10002b26 	beq	r2,zero,1d9a4 <dhcp_option_hostname+0xd0>
    size_t namelen = strlen(netif->hostname);
   1d8f8:	e0bfff17 	ldw	r2,-4(fp)
   1d8fc:	10800b17 	ldw	r2,44(r2)
   1d900:	1009883a 	mov	r4,r2
   1d904:	0004d9c0 	call	4d9c <strlen>
   1d908:	e0bffc15 	stw	r2,-16(fp)
    if (namelen > 0) {
   1d90c:	e0bffc17 	ldw	r2,-16(fp)
   1d910:	10002426 	beq	r2,zero,1d9a4 <dhcp_option_hostname+0xd0>
      u8_t len;
      const char *p = netif->hostname;
   1d914:	e0bfff17 	ldw	r2,-4(fp)
   1d918:	10800b17 	ldw	r2,44(r2)
   1d91c:	e0bffb15 	stw	r2,-20(fp)
      /* Shrink len to available bytes (need 2 bytes for OPTION_HOSTNAME
         and 1 byte for trailer) */
      size_t available = DHCP_OPTIONS_LEN - dhcp->options_out_len - 3;
   1d920:	e0bffe17 	ldw	r2,-8(fp)
   1d924:	1080060b 	ldhu	r2,24(r2)
   1d928:	10bfffcc 	andi	r2,r2,65535
   1d92c:	00c01044 	movi	r3,65
   1d930:	1885c83a 	sub	r2,r3,r2
   1d934:	e0bffd15 	stw	r2,-12(fp)
      LWIP_ASSERT("DHCP: hostname is too long!", namelen <= available);
      len = LWIP_MIN(namelen, available);
   1d938:	e0fffc17 	ldw	r3,-16(fp)
   1d93c:	e0bffd17 	ldw	r2,-12(fp)
   1d940:	1880012e 	bgeu	r3,r2,1d948 <dhcp_option_hostname+0x74>
   1d944:	1805883a 	mov	r2,r3
   1d948:	e0bffa05 	stb	r2,-24(fp)
      dhcp_option(dhcp, DHCP_OPTION_HOSTNAME, len);
   1d94c:	e0bffa03 	ldbu	r2,-24(fp)
   1d950:	e13ffe17 	ldw	r4,-8(fp)
   1d954:	01400304 	movi	r5,12
   1d958:	100d883a 	mov	r6,r2
   1d95c:	001d6440 	call	1d644 <dhcp_option>
      while (len--) {
   1d960:	00000906 	br	1d988 <dhcp_option_hostname+0xb4>
        dhcp_option_byte(dhcp, *p++);
   1d964:	e0bffb17 	ldw	r2,-20(fp)
   1d968:	10800003 	ldbu	r2,0(r2)
   1d96c:	10803fcc 	andi	r2,r2,255
   1d970:	e0fffb17 	ldw	r3,-20(fp)
   1d974:	18c00044 	addi	r3,r3,1
   1d978:	e0fffb15 	stw	r3,-20(fp)
   1d97c:	e13ffe17 	ldw	r4,-8(fp)
   1d980:	100b883a 	mov	r5,r2
   1d984:	001d6dc0 	call	1d6dc <dhcp_option_byte>
         and 1 byte for trailer) */
      size_t available = DHCP_OPTIONS_LEN - dhcp->options_out_len - 3;
      LWIP_ASSERT("DHCP: hostname is too long!", namelen <= available);
      len = LWIP_MIN(namelen, available);
      dhcp_option(dhcp, DHCP_OPTION_HOSTNAME, len);
      while (len--) {
   1d988:	e0bffa03 	ldbu	r2,-24(fp)
   1d98c:	1004c03a 	cmpne	r2,r2,zero
   1d990:	e0fffa03 	ldbu	r3,-24(fp)
   1d994:	18ffffc4 	addi	r3,r3,-1
   1d998:	e0fffa05 	stb	r3,-24(fp)
   1d99c:	10803fcc 	andi	r2,r2,255
   1d9a0:	103ff01e 	bne	r2,zero,1d964 <dhcp_option_hostname+0x90>
        dhcp_option_byte(dhcp, *p++);
      }
    }
  }
}
   1d9a4:	e037883a 	mov	sp,fp
   1d9a8:	dfc00117 	ldw	ra,4(sp)
   1d9ac:	df000017 	ldw	fp,0(sp)
   1d9b0:	dec00204 	addi	sp,sp,8
   1d9b4:	f800283a 	ret

0001d9b8 <dhcp_parse_reply>:
 * use that further on.
 *
 */
static err_t
dhcp_parse_reply(struct dhcp *dhcp, struct pbuf *p)
{
   1d9b8:	defff004 	addi	sp,sp,-64
   1d9bc:	dfc00f15 	stw	ra,60(sp)
   1d9c0:	df000e15 	stw	fp,56(sp)
   1d9c4:	df000e04 	addi	fp,sp,56
   1d9c8:	e13ffe15 	stw	r4,-8(fp)
   1d9cc:	e17fff15 	stw	r5,-4(fp)
  u16_t offset;
  u16_t offset_max;
  u16_t options_idx;
  u16_t options_idx_max;
  struct pbuf *q;
  int parse_file_as_options = 0;
   1d9d0:	e03ff615 	stw	zero,-40(fp)
  int parse_sname_as_options = 0;
   1d9d4:	e03ff715 	stw	zero,-36(fp)

  /* clear received options */
  dhcp_clear_all_options(dhcp);
   1d9d8:	010001b4 	movhi	r4,6
   1d9dc:	210c5c04 	addi	r4,r4,12656
   1d9e0:	000b883a 	mov	r5,zero
   1d9e4:	01800284 	movi	r6,10
   1d9e8:	00042e80 	call	42e8 <memset>
  /* check that beginning of dhcp_msg (up to and including chaddr) is in first pbuf */
  if (p->len < DHCP_SNAME_OFS) {
   1d9ec:	e0bfff17 	ldw	r2,-4(fp)
   1d9f0:	1080028b 	ldhu	r2,10(r2)
   1d9f4:	10bfffcc 	andi	r2,r2,65535
   1d9f8:	10800b28 	cmpgeui	r2,r2,44
   1d9fc:	1000021e 	bne	r2,zero,1da08 <dhcp_parse_reply+0x50>
    return ERR_BUF;
   1da00:	00bfff84 	movi	r2,-2
   1da04:	00021106 	br	1e24c <dhcp_parse_reply+0x894>
  }
  dhcp->msg_in = (struct dhcp_msg *)p->payload;
   1da08:	e0bfff17 	ldw	r2,-4(fp)
   1da0c:	10c00117 	ldw	r3,4(r2)
   1da10:	e0bffe17 	ldw	r2,-8(fp)
   1da14:	10c00215 	stw	r3,8(r2)
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* parse options */

  /* start with options field */
  options_idx = DHCP_OPTIONS_OFS;
   1da18:	00803c04 	movi	r2,240
   1da1c:	e0bff40d 	sth	r2,-48(fp)
  /* parse options to the end of the received packet */
  options_idx_max = p->tot_len;
   1da20:	e0bfff17 	ldw	r2,-4(fp)
   1da24:	1080020b 	ldhu	r2,8(r2)
   1da28:	e0bff48d 	sth	r2,-46(fp)
again:
  q = p;
   1da2c:	e0bfff17 	ldw	r2,-4(fp)
   1da30:	e0bff515 	stw	r2,-44(fp)
  while((q != NULL) && (options_idx >= q->len)) {
   1da34:	00000d06 	br	1da6c <dhcp_parse_reply+0xb4>
    options_idx -= q->len;
   1da38:	e0bff517 	ldw	r2,-44(fp)
   1da3c:	1080028b 	ldhu	r2,10(r2)
   1da40:	e0fff40b 	ldhu	r3,-48(fp)
   1da44:	1885c83a 	sub	r2,r3,r2
   1da48:	e0bff40d 	sth	r2,-48(fp)
    options_idx_max -= q->len;
   1da4c:	e0bff517 	ldw	r2,-44(fp)
   1da50:	1080028b 	ldhu	r2,10(r2)
   1da54:	e0fff48b 	ldhu	r3,-46(fp)
   1da58:	1885c83a 	sub	r2,r3,r2
   1da5c:	e0bff48d 	sth	r2,-46(fp)
    q = q->next;
   1da60:	e0bff517 	ldw	r2,-44(fp)
   1da64:	10800017 	ldw	r2,0(r2)
   1da68:	e0bff515 	stw	r2,-44(fp)
  options_idx = DHCP_OPTIONS_OFS;
  /* parse options to the end of the received packet */
  options_idx_max = p->tot_len;
again:
  q = p;
  while((q != NULL) && (options_idx >= q->len)) {
   1da6c:	e0bff517 	ldw	r2,-44(fp)
   1da70:	10000526 	beq	r2,zero,1da88 <dhcp_parse_reply+0xd0>
   1da74:	e0bff517 	ldw	r2,-44(fp)
   1da78:	1080028b 	ldhu	r2,10(r2)
   1da7c:	10bfffcc 	andi	r2,r2,65535
   1da80:	e0fff40b 	ldhu	r3,-48(fp)
   1da84:	18bfec2e 	bgeu	r3,r2,1da38 <dhcp_parse_reply+0x80>
    options_idx -= q->len;
    options_idx_max -= q->len;
    q = q->next;
  }
  if (q == NULL) {
   1da88:	e0bff517 	ldw	r2,-44(fp)
   1da8c:	1000021e 	bne	r2,zero,1da98 <dhcp_parse_reply+0xe0>
    return ERR_BUF;
   1da90:	00bfff84 	movi	r2,-2
   1da94:	0001ed06 	br	1e24c <dhcp_parse_reply+0x894>
  }
  offset = options_idx;
   1da98:	e0bff40b 	ldhu	r2,-48(fp)
   1da9c:	e0bff30d 	sth	r2,-52(fp)
  offset_max = options_idx_max;
   1daa0:	e0bff48b 	ldhu	r2,-46(fp)
   1daa4:	e0bff38d 	sth	r2,-50(fp)
  options = (u8_t*)q->payload;
   1daa8:	e0bff517 	ldw	r2,-44(fp)
   1daac:	10800117 	ldw	r2,4(r2)
   1dab0:	e0bff215 	stw	r2,-56(fp)
  /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
  while((q != NULL) && (options[offset] != DHCP_OPTION_END) && (offset < offset_max)) {
   1dab4:	0001a906 	br	1e15c <dhcp_parse_reply+0x7a4>
    u8_t op = options[offset];
   1dab8:	e0bff30b 	ldhu	r2,-52(fp)
   1dabc:	e0fff217 	ldw	r3,-56(fp)
   1dac0:	1885883a 	add	r2,r3,r2
   1dac4:	10800003 	ldbu	r2,0(r2)
   1dac8:	e0bffa85 	stb	r2,-22(fp)
    u8_t len;
    u8_t decode_len = 0;
   1dacc:	e03ff845 	stb	zero,-31(fp)
    int decode_idx = -1;
   1dad0:	00bfffc4 	movi	r2,-1
   1dad4:	e0bff915 	stw	r2,-28(fp)
    u16_t val_offset = offset + 2;
   1dad8:	e0bff30b 	ldhu	r2,-52(fp)
   1dadc:	10800084 	addi	r2,r2,2
   1dae0:	e0bffa0d 	sth	r2,-24(fp)
    /* len byte might be in the next pbuf */
    if (offset + 1 < q->len) {
   1dae4:	e0bff30b 	ldhu	r2,-52(fp)
   1dae8:	10c00044 	addi	r3,r2,1
   1daec:	e0bff517 	ldw	r2,-44(fp)
   1daf0:	1080028b 	ldhu	r2,10(r2)
   1daf4:	10bfffcc 	andi	r2,r2,65535
   1daf8:	1880070e 	bge	r3,r2,1db18 <dhcp_parse_reply+0x160>
      len = options[offset + 1];
   1dafc:	e0bff30b 	ldhu	r2,-52(fp)
   1db00:	10800044 	addi	r2,r2,1
   1db04:	e0fff217 	ldw	r3,-56(fp)
   1db08:	1885883a 	add	r2,r3,r2
   1db0c:	10800003 	ldbu	r2,0(r2)
   1db10:	e0bff805 	stb	r2,-32(fp)
   1db14:	00000a06 	br	1db40 <dhcp_parse_reply+0x188>
    } else {
      len = (q->next != NULL ? ((u8_t*)q->next->payload)[0] : 0);
   1db18:	e0bff517 	ldw	r2,-44(fp)
   1db1c:	10800017 	ldw	r2,0(r2)
   1db20:	10000526 	beq	r2,zero,1db38 <dhcp_parse_reply+0x180>
   1db24:	e0bff517 	ldw	r2,-44(fp)
   1db28:	10800017 	ldw	r2,0(r2)
   1db2c:	10800117 	ldw	r2,4(r2)
   1db30:	10800003 	ldbu	r2,0(r2)
   1db34:	00000106 	br	1db3c <dhcp_parse_reply+0x184>
   1db38:	0005883a 	mov	r2,zero
   1db3c:	e0bff805 	stb	r2,-32(fp)
    }
    /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
    decode_len = len;
   1db40:	e0bff803 	ldbu	r2,-32(fp)
   1db44:	e0bff845 	stb	r2,-31(fp)
    switch(op) {
   1db48:	e0bffa83 	ldbu	r2,-22(fp)
   1db4c:	10c00f28 	cmpgeui	r3,r2,60
   1db50:	1800e51e 	bne	r3,zero,1dee8 <dhcp_parse_reply+0x530>
   1db54:	1085883a 	add	r2,r2,r2
   1db58:	1087883a 	add	r3,r2,r2
   1db5c:	008000b4 	movhi	r2,2
   1db60:	10b6dc04 	addi	r2,r2,-9360
   1db64:	1885883a 	add	r2,r3,r2
   1db68:	10800017 	ldw	r2,0(r2)
   1db6c:	1000683a 	jmp	r2
   1db70:	0001dc60 	cmpeqi	zero,zero,1905
   1db74:	0001dc7c 	xorhi	zero,zero,1905
   1db78:	0001dee8 	cmpgeui	zero,zero,1915
   1db7c:	0001dcb8 	rdprs	zero,zero,1906
   1db80:	0001dee8 	cmpgeui	zero,zero,1915
   1db84:	0001dee8 	cmpgeui	zero,zero,1915
   1db88:	0001dcfc 	xorhi	zero,zero,1907
   1db8c:	0001dee8 	cmpgeui	zero,zero,1915
   1db90:	0001dee8 	cmpgeui	zero,zero,1915
   1db94:	0001dee8 	cmpgeui	zero,zero,1915
   1db98:	0001dee8 	cmpgeui	zero,zero,1915
   1db9c:	0001dee8 	cmpgeui	zero,zero,1915
   1dba0:	0001dee8 	cmpgeui	zero,zero,1915
   1dba4:	0001dee8 	cmpgeui	zero,zero,1915
   1dba8:	0001dee8 	cmpgeui	zero,zero,1915
   1dbac:	0001dee8 	cmpgeui	zero,zero,1915
   1dbb0:	0001dee8 	cmpgeui	zero,zero,1915
   1dbb4:	0001dee8 	cmpgeui	zero,zero,1915
   1dbb8:	0001dee8 	cmpgeui	zero,zero,1915
   1dbbc:	0001dee8 	cmpgeui	zero,zero,1915
   1dbc0:	0001dee8 	cmpgeui	zero,zero,1915
   1dbc4:	0001dee8 	cmpgeui	zero,zero,1915
   1dbc8:	0001dee8 	cmpgeui	zero,zero,1915
   1dbcc:	0001dee8 	cmpgeui	zero,zero,1915
   1dbd0:	0001dee8 	cmpgeui	zero,zero,1915
   1dbd4:	0001dee8 	cmpgeui	zero,zero,1915
   1dbd8:	0001dee8 	cmpgeui	zero,zero,1915
   1dbdc:	0001dee8 	cmpgeui	zero,zero,1915
   1dbe0:	0001dee8 	cmpgeui	zero,zero,1915
   1dbe4:	0001dee8 	cmpgeui	zero,zero,1915
   1dbe8:	0001dee8 	cmpgeui	zero,zero,1915
   1dbec:	0001dee8 	cmpgeui	zero,zero,1915
   1dbf0:	0001dee8 	cmpgeui	zero,zero,1915
   1dbf4:	0001dee8 	cmpgeui	zero,zero,1915
   1dbf8:	0001dee8 	cmpgeui	zero,zero,1915
   1dbfc:	0001dee8 	cmpgeui	zero,zero,1915
   1dc00:	0001dee8 	cmpgeui	zero,zero,1915
   1dc04:	0001dee8 	cmpgeui	zero,zero,1915
   1dc08:	0001dee8 	cmpgeui	zero,zero,1915
   1dc0c:	0001dee8 	cmpgeui	zero,zero,1915
   1dc10:	0001dee8 	cmpgeui	zero,zero,1915
   1dc14:	0001dee8 	cmpgeui	zero,zero,1915
   1dc18:	0001dee8 	cmpgeui	zero,zero,1915
   1dc1c:	0001dee8 	cmpgeui	zero,zero,1915
   1dc20:	0001dee8 	cmpgeui	zero,zero,1915
   1dc24:	0001dee8 	cmpgeui	zero,zero,1915
   1dc28:	0001dee8 	cmpgeui	zero,zero,1915
   1dc2c:	0001dee8 	cmpgeui	zero,zero,1915
   1dc30:	0001dee8 	cmpgeui	zero,zero,1915
   1dc34:	0001dee8 	cmpgeui	zero,zero,1915
   1dc38:	0001dee8 	cmpgeui	zero,zero,1915
   1dc3c:	0001dd84 	movi	zero,1910
   1dc40:	0001ddc0 	call	1ddc <vPrimaryBlockTimeTestTask+0x3d0>
   1dc44:	0001ddf8 	rdprs	zero,zero,1911
   1dc48:	0001de34 	movhi	zero,1912
   1dc4c:	0001dee8 	cmpgeui	zero,zero,1915
   1dc50:	0001dee8 	cmpgeui	zero,zero,1915
   1dc54:	0001dee8 	cmpgeui	zero,zero,1915
   1dc58:	0001de70 	cmpltui	zero,zero,1913
   1dc5c:	0001deac 	andhi	zero,zero,1914
      /* case(DHCP_OPTION_END): handled above */
      case(DHCP_OPTION_PAD):
        /* special option: no len encoded */
        decode_len = len = 0;
   1dc60:	e03ff805 	stb	zero,-32(fp)
   1dc64:	e0bff803 	ldbu	r2,-32(fp)
   1dc68:	e0bff845 	stb	r2,-31(fp)
        /* will be increased below */
        offset--;
   1dc6c:	e0bff30b 	ldhu	r2,-52(fp)
   1dc70:	10bfffc4 	addi	r2,r2,-1
   1dc74:	e0bff30d 	sth	r2,-52(fp)
        break;
   1dc78:	00009d06 	br	1def0 <dhcp_parse_reply+0x538>
      case(DHCP_OPTION_SUBNET_MASK):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
   1dc7c:	e0bff803 	ldbu	r2,-32(fp)
   1dc80:	10800120 	cmpeqi	r2,r2,4
   1dc84:	1000091e 	bne	r2,zero,1dcac <dhcp_parse_reply+0x2f4>
   1dc88:	01000134 	movhi	r4,4
   1dc8c:	21040004 	addi	r4,r4,4096
   1dc90:	01400134 	movhi	r5,4
   1dc94:	29442a04 	addi	r5,r5,4264
   1dc98:	01816204 	movi	r6,1416
   1dc9c:	01c00134 	movhi	r7,4
   1dca0:	39c41004 	addi	r7,r7,4160
   1dca4:	00044740 	call	4474 <printf>
   1dca8:	003fff06 	br	1dca8 <dhcp_parse_reply+0x2f0>
        decode_idx = DHCP_OPTION_IDX_SUBNET_MASK;
   1dcac:	00800184 	movi	r2,6
   1dcb0:	e0bff915 	stw	r2,-28(fp)
        break;
   1dcb4:	00008e06 	br	1def0 <dhcp_parse_reply+0x538>
      case(DHCP_OPTION_ROUTER):
        decode_len = 4; /* only copy the first given router */
   1dcb8:	00800104 	movi	r2,4
   1dcbc:	e0bff845 	stb	r2,-31(fp)
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
   1dcc0:	e0fff803 	ldbu	r3,-32(fp)
   1dcc4:	e0bff843 	ldbu	r2,-31(fp)
   1dcc8:	1880092e 	bgeu	r3,r2,1dcf0 <dhcp_parse_reply+0x338>
   1dccc:	01000134 	movhi	r4,4
   1dcd0:	21040004 	addi	r4,r4,4096
   1dcd4:	01400134 	movhi	r5,4
   1dcd8:	29442d04 	addi	r5,r5,4276
   1dcdc:	01816344 	movi	r6,1421
   1dce0:	01c00134 	movhi	r7,4
   1dce4:	39c41004 	addi	r7,r7,4160
   1dce8:	00044740 	call	4474 <printf>
   1dcec:	003fff06 	br	1dcec <dhcp_parse_reply+0x334>
        decode_idx = DHCP_OPTION_IDX_ROUTER;
   1dcf0:	008001c4 	movi	r2,7
   1dcf4:	e0bff915 	stw	r2,-28(fp)
        break;
   1dcf8:	00007d06 	br	1def0 <dhcp_parse_reply+0x538>
      case(DHCP_OPTION_DNS_SERVER):
        /* special case: there might be more than one server */
        LWIP_ERROR("len % 4 == 0", len % 4 == 0, return ERR_VAL;);
   1dcfc:	e0bff803 	ldbu	r2,-32(fp)
   1dd00:	108000cc 	andi	r2,r2,3
   1dd04:	10803fcc 	andi	r2,r2,255
   1dd08:	10000926 	beq	r2,zero,1dd30 <dhcp_parse_reply+0x378>
   1dd0c:	01000134 	movhi	r4,4
   1dd10:	21040004 	addi	r4,r4,4096
   1dd14:	01400134 	movhi	r5,4
   1dd18:	29443204 	addi	r5,r5,4296
   1dd1c:	01816484 	movi	r6,1426
   1dd20:	01c00134 	movhi	r7,4
   1dd24:	39c41004 	addi	r7,r7,4160
   1dd28:	00044740 	call	4474 <printf>
   1dd2c:	003fff06 	br	1dd2c <dhcp_parse_reply+0x374>
        /* limit number of DNS servers */
        decode_len = LWIP_MIN(len, 4 * DNS_MAX_SERVERS);
   1dd30:	e0bff803 	ldbu	r2,-32(fp)
   1dd34:	10c03fcc 	andi	r3,r2,255
   1dd38:	18c00270 	cmpltui	r3,r3,9
   1dd3c:	1800011e 	bne	r3,zero,1dd44 <dhcp_parse_reply+0x38c>
   1dd40:	00800204 	movi	r2,8
   1dd44:	e0bff845 	stb	r2,-31(fp)
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
   1dd48:	e0fff803 	ldbu	r3,-32(fp)
   1dd4c:	e0bff843 	ldbu	r2,-31(fp)
   1dd50:	1880092e 	bgeu	r3,r2,1dd78 <dhcp_parse_reply+0x3c0>
   1dd54:	01000134 	movhi	r4,4
   1dd58:	21040004 	addi	r4,r4,4096
   1dd5c:	01400134 	movhi	r5,4
   1dd60:	29442d04 	addi	r5,r5,4276
   1dd64:	01816544 	movi	r6,1429
   1dd68:	01c00134 	movhi	r7,4
   1dd6c:	39c41004 	addi	r7,r7,4160
   1dd70:	00044740 	call	4474 <printf>
   1dd74:	003fff06 	br	1dd74 <dhcp_parse_reply+0x3bc>
        decode_idx = DHCP_OPTION_IDX_DNS_SERVER;
   1dd78:	00800204 	movi	r2,8
   1dd7c:	e0bff915 	stw	r2,-28(fp)
        break;
   1dd80:	00005b06 	br	1def0 <dhcp_parse_reply+0x538>
      case(DHCP_OPTION_LEASE_TIME):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
   1dd84:	e0bff803 	ldbu	r2,-32(fp)
   1dd88:	10800120 	cmpeqi	r2,r2,4
   1dd8c:	1000091e 	bne	r2,zero,1ddb4 <dhcp_parse_reply+0x3fc>
   1dd90:	01000134 	movhi	r4,4
   1dd94:	21040004 	addi	r4,r4,4096
   1dd98:	01400134 	movhi	r5,4
   1dd9c:	29442a04 	addi	r5,r5,4264
   1dda0:	01816644 	movi	r6,1433
   1dda4:	01c00134 	movhi	r7,4
   1dda8:	39c41004 	addi	r7,r7,4160
   1ddac:	00044740 	call	4474 <printf>
   1ddb0:	003fff06 	br	1ddb0 <dhcp_parse_reply+0x3f8>
        decode_idx = DHCP_OPTION_IDX_LEASE_TIME;
   1ddb4:	008000c4 	movi	r2,3
   1ddb8:	e0bff915 	stw	r2,-28(fp)
        break;
   1ddbc:	00004c06 	br	1def0 <dhcp_parse_reply+0x538>
      case(DHCP_OPTION_OVERLOAD):
        LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
   1ddc0:	e0bff803 	ldbu	r2,-32(fp)
   1ddc4:	10800060 	cmpeqi	r2,r2,1
   1ddc8:	1000091e 	bne	r2,zero,1ddf0 <dhcp_parse_reply+0x438>
   1ddcc:	01000134 	movhi	r4,4
   1ddd0:	21040004 	addi	r4,r4,4096
   1ddd4:	01400134 	movhi	r5,4
   1ddd8:	29443604 	addi	r5,r5,4312
   1dddc:	01816744 	movi	r6,1437
   1dde0:	01c00134 	movhi	r7,4
   1dde4:	39c41004 	addi	r7,r7,4160
   1dde8:	00044740 	call	4474 <printf>
   1ddec:	003fff06 	br	1ddec <dhcp_parse_reply+0x434>
        decode_idx = DHCP_OPTION_IDX_OVERLOAD;
   1ddf0:	e03ff915 	stw	zero,-28(fp)
        break;
   1ddf4:	00003e06 	br	1def0 <dhcp_parse_reply+0x538>
      case(DHCP_OPTION_MESSAGE_TYPE):
        LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
   1ddf8:	e0bff803 	ldbu	r2,-32(fp)
   1ddfc:	10800060 	cmpeqi	r2,r2,1
   1de00:	1000091e 	bne	r2,zero,1de28 <dhcp_parse_reply+0x470>
   1de04:	01000134 	movhi	r4,4
   1de08:	21040004 	addi	r4,r4,4096
   1de0c:	01400134 	movhi	r5,4
   1de10:	29443604 	addi	r5,r5,4312
   1de14:	01816844 	movi	r6,1441
   1de18:	01c00134 	movhi	r7,4
   1de1c:	39c41004 	addi	r7,r7,4160
   1de20:	00044740 	call	4474 <printf>
   1de24:	003fff06 	br	1de24 <dhcp_parse_reply+0x46c>
        decode_idx = DHCP_OPTION_IDX_MSG_TYPE;
   1de28:	00800044 	movi	r2,1
   1de2c:	e0bff915 	stw	r2,-28(fp)
        break;
   1de30:	00002f06 	br	1def0 <dhcp_parse_reply+0x538>
      case(DHCP_OPTION_SERVER_ID):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
   1de34:	e0bff803 	ldbu	r2,-32(fp)
   1de38:	10800120 	cmpeqi	r2,r2,4
   1de3c:	1000091e 	bne	r2,zero,1de64 <dhcp_parse_reply+0x4ac>
   1de40:	01000134 	movhi	r4,4
   1de44:	21040004 	addi	r4,r4,4096
   1de48:	01400134 	movhi	r5,4
   1de4c:	29442a04 	addi	r5,r5,4264
   1de50:	01816944 	movi	r6,1445
   1de54:	01c00134 	movhi	r7,4
   1de58:	39c41004 	addi	r7,r7,4160
   1de5c:	00044740 	call	4474 <printf>
   1de60:	003fff06 	br	1de60 <dhcp_parse_reply+0x4a8>
        decode_idx = DHCP_OPTION_IDX_SERVER_ID;
   1de64:	00800084 	movi	r2,2
   1de68:	e0bff915 	stw	r2,-28(fp)
        break;
   1de6c:	00002006 	br	1def0 <dhcp_parse_reply+0x538>
      case(DHCP_OPTION_T1):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
   1de70:	e0bff803 	ldbu	r2,-32(fp)
   1de74:	10800120 	cmpeqi	r2,r2,4
   1de78:	1000091e 	bne	r2,zero,1dea0 <dhcp_parse_reply+0x4e8>
   1de7c:	01000134 	movhi	r4,4
   1de80:	21040004 	addi	r4,r4,4096
   1de84:	01400134 	movhi	r5,4
   1de88:	29442a04 	addi	r5,r5,4264
   1de8c:	01816a44 	movi	r6,1449
   1de90:	01c00134 	movhi	r7,4
   1de94:	39c41004 	addi	r7,r7,4160
   1de98:	00044740 	call	4474 <printf>
   1de9c:	003fff06 	br	1de9c <dhcp_parse_reply+0x4e4>
        decode_idx = DHCP_OPTION_IDX_T1;
   1dea0:	00800104 	movi	r2,4
   1dea4:	e0bff915 	stw	r2,-28(fp)
        break;
   1dea8:	00001106 	br	1def0 <dhcp_parse_reply+0x538>
      case(DHCP_OPTION_T2):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
   1deac:	e0bff803 	ldbu	r2,-32(fp)
   1deb0:	10800120 	cmpeqi	r2,r2,4
   1deb4:	1000091e 	bne	r2,zero,1dedc <dhcp_parse_reply+0x524>
   1deb8:	01000134 	movhi	r4,4
   1debc:	21040004 	addi	r4,r4,4096
   1dec0:	01400134 	movhi	r5,4
   1dec4:	29442a04 	addi	r5,r5,4264
   1dec8:	01816b44 	movi	r6,1453
   1decc:	01c00134 	movhi	r7,4
   1ded0:	39c41004 	addi	r7,r7,4160
   1ded4:	00044740 	call	4474 <printf>
   1ded8:	003fff06 	br	1ded8 <dhcp_parse_reply+0x520>
        decode_idx = DHCP_OPTION_IDX_T2;
   1dedc:	00800144 	movi	r2,5
   1dee0:	e0bff915 	stw	r2,-28(fp)
        break;
   1dee4:	00000206 	br	1def0 <dhcp_parse_reply+0x538>
      default:
        decode_len = 0;
   1dee8:	e03ff845 	stb	zero,-31(fp)
        LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", op));
        break;
   1deec:	0001883a 	nop
    }
    offset += len + 2;
   1def0:	e0fff803 	ldbu	r3,-32(fp)
   1def4:	e0bff30b 	ldhu	r2,-52(fp)
   1def8:	1885883a 	add	r2,r3,r2
   1defc:	10800084 	addi	r2,r2,2
   1df00:	e0bff30d 	sth	r2,-52(fp)
    if (decode_len > 0) {
   1df04:	e0bff843 	ldbu	r2,-31(fp)
   1df08:	10007a26 	beq	r2,zero,1e0f4 <dhcp_parse_reply+0x73c>
      u32_t value = 0;
   1df0c:	e03ffd15 	stw	zero,-12(fp)
      u16_t copy_len;
decode_next:
      LWIP_ASSERT("check decode_idx", decode_idx >= 0 && decode_idx < DHCP_OPTION_IDX_MAX);
      if (!dhcp_option_given(dhcp, decode_idx)) {
   1df10:	00c001b4 	movhi	r3,6
   1df14:	18cc5c04 	addi	r3,r3,12656
   1df18:	e0bff917 	ldw	r2,-28(fp)
   1df1c:	1885883a 	add	r2,r3,r2
   1df20:	10800003 	ldbu	r2,0(r2)
   1df24:	10803fcc 	andi	r2,r2,255
   1df28:	1000721e 	bne	r2,zero,1e0f4 <dhcp_parse_reply+0x73c>
        copy_len = LWIP_MIN(decode_len, 4);
   1df2c:	e0bff843 	ldbu	r2,-31(fp)
   1df30:	10800128 	cmpgeui	r2,r2,4
   1df34:	1000021e 	bne	r2,zero,1df40 <dhcp_parse_reply+0x588>
   1df38:	e0bff843 	ldbu	r2,-31(fp)
   1df3c:	00000106 	br	1df44 <dhcp_parse_reply+0x58c>
   1df40:	00800104 	movi	r2,4
   1df44:	e0bffb0d 	sth	r2,-20(fp)
        pbuf_copy_partial(q, &value, copy_len, val_offset);
   1df48:	e0fffb0b 	ldhu	r3,-20(fp)
   1df4c:	e0bffa0b 	ldhu	r2,-24(fp)
   1df50:	e17ffd04 	addi	r5,fp,-12
   1df54:	e13ff517 	ldw	r4,-44(fp)
   1df58:	180d883a 	mov	r6,r3
   1df5c:	100f883a 	mov	r7,r2
   1df60:	0023d580 	call	23d58 <pbuf_copy_partial>
        if (decode_len > 4) {
   1df64:	e0bff843 	ldbu	r2,-31(fp)
   1df68:	10800170 	cmpltui	r2,r2,5
   1df6c:	1000311e 	bne	r2,zero,1e034 <dhcp_parse_reply+0x67c>
          /* decode more than one u32_t */
          LWIP_ERROR("decode_len % 4 == 0", decode_len % 4 == 0, return ERR_VAL;);
   1df70:	e0bff843 	ldbu	r2,-31(fp)
   1df74:	108000cc 	andi	r2,r2,3
   1df78:	10803fcc 	andi	r2,r2,255
   1df7c:	10000926 	beq	r2,zero,1dfa4 <dhcp_parse_reply+0x5ec>
   1df80:	01000134 	movhi	r4,4
   1df84:	21040004 	addi	r4,r4,4096
   1df88:	01400134 	movhi	r5,4
   1df8c:	29443904 	addi	r5,r5,4324
   1df90:	01817004 	movi	r6,1472
   1df94:	01c00134 	movhi	r7,4
   1df98:	39c41004 	addi	r7,r7,4160
   1df9c:	00044740 	call	4474 <printf>
   1dfa0:	003fff06 	br	1dfa0 <dhcp_parse_reply+0x5e8>
          dhcp_got_option(dhcp, decode_idx);
   1dfa4:	00c001b4 	movhi	r3,6
   1dfa8:	18cc5c04 	addi	r3,r3,12656
   1dfac:	e0bff917 	ldw	r2,-28(fp)
   1dfb0:	1885883a 	add	r2,r3,r2
   1dfb4:	00c00044 	movi	r3,1
   1dfb8:	10c00005 	stb	r3,0(r2)
          dhcp_set_option_value(dhcp, decode_idx, htonl(value));
   1dfbc:	e0bffd17 	ldw	r2,-12(fp)
   1dfc0:	1006d63a 	srli	r3,r2,24
   1dfc4:	e0bffd17 	ldw	r2,-12(fp)
   1dfc8:	1004d23a 	srli	r2,r2,8
   1dfcc:	10bfc00c 	andi	r2,r2,65280
   1dfd0:	1886b03a 	or	r3,r3,r2
   1dfd4:	e0bffd17 	ldw	r2,-12(fp)
   1dfd8:	10bfc00c 	andi	r2,r2,65280
   1dfdc:	1004923a 	slli	r2,r2,8
   1dfe0:	1886b03a 	or	r3,r3,r2
   1dfe4:	e0bffd17 	ldw	r2,-12(fp)
   1dfe8:	1004963a 	slli	r2,r2,24
   1dfec:	1886b03a 	or	r3,r3,r2
   1dff0:	010001b4 	movhi	r4,6
   1dff4:	210c5f04 	addi	r4,r4,12668
   1dff8:	e0bff917 	ldw	r2,-28(fp)
   1dffc:	1085883a 	add	r2,r2,r2
   1e000:	1085883a 	add	r2,r2,r2
   1e004:	2085883a 	add	r2,r4,r2
   1e008:	10c00015 	stw	r3,0(r2)
          decode_len -= 4;
   1e00c:	e0bff843 	ldbu	r2,-31(fp)
   1e010:	10bfff04 	addi	r2,r2,-4
   1e014:	e0bff845 	stb	r2,-31(fp)
          val_offset += 4;
   1e018:	e0bffa0b 	ldhu	r2,-24(fp)
   1e01c:	10800104 	addi	r2,r2,4
   1e020:	e0bffa0d 	sth	r2,-24(fp)
          decode_idx++;
   1e024:	e0bff917 	ldw	r2,-28(fp)
   1e028:	10800044 	addi	r2,r2,1
   1e02c:	e0bff915 	stw	r2,-28(fp)
          goto decode_next;
   1e030:	003fb706 	br	1df10 <dhcp_parse_reply+0x558>
        } else if (decode_len == 4) {
   1e034:	e0bff843 	ldbu	r2,-31(fp)
   1e038:	10800118 	cmpnei	r2,r2,4
   1e03c:	10000f1e 	bne	r2,zero,1e07c <dhcp_parse_reply+0x6c4>
          value = ntohl(value);
   1e040:	e0bffd17 	ldw	r2,-12(fp)
   1e044:	1006d63a 	srli	r3,r2,24
   1e048:	e0bffd17 	ldw	r2,-12(fp)
   1e04c:	1004d23a 	srli	r2,r2,8
   1e050:	10bfc00c 	andi	r2,r2,65280
   1e054:	1886b03a 	or	r3,r3,r2
   1e058:	e0bffd17 	ldw	r2,-12(fp)
   1e05c:	10bfc00c 	andi	r2,r2,65280
   1e060:	1004923a 	slli	r2,r2,8
   1e064:	1886b03a 	or	r3,r3,r2
   1e068:	e0bffd17 	ldw	r2,-12(fp)
   1e06c:	1004963a 	slli	r2,r2,24
   1e070:	1884b03a 	or	r2,r3,r2
   1e074:	e0bffd15 	stw	r2,-12(fp)
   1e078:	00001006 	br	1e0bc <dhcp_parse_reply+0x704>
        } else {
          LWIP_ERROR("invalid decode_len", decode_len == 1, return ERR_VAL;);
   1e07c:	e0bff843 	ldbu	r2,-31(fp)
   1e080:	10800060 	cmpeqi	r2,r2,1
   1e084:	1000091e 	bne	r2,zero,1e0ac <dhcp_parse_reply+0x6f4>
   1e088:	01000134 	movhi	r4,4
   1e08c:	21040004 	addi	r4,r4,4096
   1e090:	01400134 	movhi	r5,4
   1e094:	29443e04 	addi	r5,r5,4344
   1e098:	01817284 	movi	r6,1482
   1e09c:	01c00134 	movhi	r7,4
   1e0a0:	39c41004 	addi	r7,r7,4160
   1e0a4:	00044740 	call	4474 <printf>
   1e0a8:	003fff06 	br	1e0a8 <dhcp_parse_reply+0x6f0>
          value = ((u8_t*)&value)[0];
   1e0ac:	e0bffd04 	addi	r2,fp,-12
   1e0b0:	10800003 	ldbu	r2,0(r2)
   1e0b4:	10803fcc 	andi	r2,r2,255
   1e0b8:	e0bffd15 	stw	r2,-12(fp)
        }
        dhcp_got_option(dhcp, decode_idx);
   1e0bc:	00c001b4 	movhi	r3,6
   1e0c0:	18cc5c04 	addi	r3,r3,12656
   1e0c4:	e0bff917 	ldw	r2,-28(fp)
   1e0c8:	1885883a 	add	r2,r3,r2
   1e0cc:	00c00044 	movi	r3,1
   1e0d0:	10c00005 	stb	r3,0(r2)
        dhcp_set_option_value(dhcp, decode_idx, value);
   1e0d4:	e0fffd17 	ldw	r3,-12(fp)
   1e0d8:	010001b4 	movhi	r4,6
   1e0dc:	210c5f04 	addi	r4,r4,12668
   1e0e0:	e0bff917 	ldw	r2,-28(fp)
   1e0e4:	1085883a 	add	r2,r2,r2
   1e0e8:	1085883a 	add	r2,r2,r2
   1e0ec:	2085883a 	add	r2,r4,r2
   1e0f0:	10c00015 	stw	r3,0(r2)
      }
    }
    if (offset >= q->len) {
   1e0f4:	e0bff517 	ldw	r2,-44(fp)
   1e0f8:	1080028b 	ldhu	r2,10(r2)
   1e0fc:	10bfffcc 	andi	r2,r2,65535
   1e100:	e0fff30b 	ldhu	r3,-52(fp)
   1e104:	18801536 	bltu	r3,r2,1e15c <dhcp_parse_reply+0x7a4>
      offset -= q->len;
   1e108:	e0bff517 	ldw	r2,-44(fp)
   1e10c:	1080028b 	ldhu	r2,10(r2)
   1e110:	e0fff30b 	ldhu	r3,-52(fp)
   1e114:	1885c83a 	sub	r2,r3,r2
   1e118:	e0bff30d 	sth	r2,-52(fp)
      offset_max -= q->len;
   1e11c:	e0bff517 	ldw	r2,-44(fp)
   1e120:	1080028b 	ldhu	r2,10(r2)
   1e124:	e0fff38b 	ldhu	r3,-50(fp)
   1e128:	1885c83a 	sub	r2,r3,r2
   1e12c:	e0bff38d 	sth	r2,-50(fp)
      if ((offset < offset_max) && offset_max) {
   1e130:	e0fff30b 	ldhu	r3,-52(fp)
   1e134:	e0bff38b 	ldhu	r2,-50(fp)
   1e138:	1880142e 	bgeu	r3,r2,1e18c <dhcp_parse_reply+0x7d4>
   1e13c:	e0bff38b 	ldhu	r2,-50(fp)
   1e140:	10001226 	beq	r2,zero,1e18c <dhcp_parse_reply+0x7d4>
        q = q->next;
   1e144:	e0bff517 	ldw	r2,-44(fp)
   1e148:	10800017 	ldw	r2,0(r2)
   1e14c:	e0bff515 	stw	r2,-44(fp)
        LWIP_ASSERT("next pbuf was null", q);
        options = (u8_t*)q->payload;
   1e150:	e0bff517 	ldw	r2,-44(fp)
   1e154:	10800117 	ldw	r2,4(r2)
   1e158:	e0bff215 	stw	r2,-56(fp)
  }
  offset = options_idx;
  offset_max = options_idx_max;
  options = (u8_t*)q->payload;
  /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
  while((q != NULL) && (options[offset] != DHCP_OPTION_END) && (offset < offset_max)) {
   1e15c:	e0bff517 	ldw	r2,-44(fp)
   1e160:	10000a26 	beq	r2,zero,1e18c <dhcp_parse_reply+0x7d4>
   1e164:	e0bff30b 	ldhu	r2,-52(fp)
   1e168:	e0fff217 	ldw	r3,-56(fp)
   1e16c:	1885883a 	add	r2,r3,r2
   1e170:	10800003 	ldbu	r2,0(r2)
   1e174:	10803fcc 	andi	r2,r2,255
   1e178:	10803fe0 	cmpeqi	r2,r2,255
   1e17c:	1000031e 	bne	r2,zero,1e18c <dhcp_parse_reply+0x7d4>
   1e180:	e0fff30b 	ldhu	r3,-52(fp)
   1e184:	e0bff38b 	ldhu	r2,-50(fp)
   1e188:	18be4b36 	bltu	r3,r2,1dab8 <dhcp_parse_reply+0x100>
        break;
      }
    }
  }
  /* is this an overloaded message? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_OVERLOAD)) {
   1e18c:	008001b4 	movhi	r2,6
   1e190:	108c5c04 	addi	r2,r2,12656
   1e194:	10800003 	ldbu	r2,0(r2)
   1e198:	10803fcc 	andi	r2,r2,255
   1e19c:	10001a26 	beq	r2,zero,1e208 <dhcp_parse_reply+0x850>
    u32_t overload = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_OVERLOAD);
   1e1a0:	008001b4 	movhi	r2,6
   1e1a4:	108c5f04 	addi	r2,r2,12668
   1e1a8:	10800017 	ldw	r2,0(r2)
   1e1ac:	e0bffc15 	stw	r2,-16(fp)
    dhcp_clear_option(dhcp, DHCP_OPTION_IDX_OVERLOAD);
   1e1b0:	008001b4 	movhi	r2,6
   1e1b4:	108c5c04 	addi	r2,r2,12656
   1e1b8:	10000005 	stb	zero,0(r2)
    if (overload == DHCP_OVERLOAD_FILE) {
   1e1bc:	e0bffc17 	ldw	r2,-16(fp)
   1e1c0:	10800058 	cmpnei	r2,r2,1
   1e1c4:	1000031e 	bne	r2,zero,1e1d4 <dhcp_parse_reply+0x81c>
      parse_file_as_options = 1;
   1e1c8:	00800044 	movi	r2,1
   1e1cc:	e0bff615 	stw	r2,-40(fp)
   1e1d0:	00000d06 	br	1e208 <dhcp_parse_reply+0x850>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded file field\n"));
    } else if (overload == DHCP_OVERLOAD_SNAME) {
   1e1d4:	e0bffc17 	ldw	r2,-16(fp)
   1e1d8:	10800098 	cmpnei	r2,r2,2
   1e1dc:	1000031e 	bne	r2,zero,1e1ec <dhcp_parse_reply+0x834>
      parse_sname_as_options = 1;
   1e1e0:	00800044 	movi	r2,1
   1e1e4:	e0bff715 	stw	r2,-36(fp)
   1e1e8:	00000706 	br	1e208 <dhcp_parse_reply+0x850>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded sname field\n"));
    } else if (overload == DHCP_OVERLOAD_SNAME_FILE) {
   1e1ec:	e0bffc17 	ldw	r2,-16(fp)
   1e1f0:	108000d8 	cmpnei	r2,r2,3
   1e1f4:	1000041e 	bne	r2,zero,1e208 <dhcp_parse_reply+0x850>
      parse_sname_as_options = 1;
   1e1f8:	00800044 	movi	r2,1
   1e1fc:	e0bff715 	stw	r2,-36(fp)
      parse_file_as_options = 1;
   1e200:	00800044 	movi	r2,1
   1e204:	e0bff615 	stw	r2,-40(fp)
      /* make sure the string is really NULL-terminated */
      dhcp->boot_file_name[DHCP_FILE_LEN-1] = 0;
    }
#endif /* LWIP_DHCP_BOOTP_FILE */
  }
  if (parse_file_as_options) {
   1e208:	e0bff617 	ldw	r2,-40(fp)
   1e20c:	10000626 	beq	r2,zero,1e228 <dhcp_parse_reply+0x870>
    /* if both are overloaded, parse file first and then sname (RFC 2131 ch. 4.1) */
    parse_file_as_options = 0;
   1e210:	e03ff615 	stw	zero,-40(fp)
    options_idx = DHCP_FILE_OFS;
   1e214:	00801b04 	movi	r2,108
   1e218:	e0bff40d 	sth	r2,-48(fp)
    options_idx_max = DHCP_FILE_OFS + DHCP_FILE_LEN;
   1e21c:	00803b04 	movi	r2,236
   1e220:	e0bff48d 	sth	r2,-46(fp)
    goto again;
   1e224:	003e0106 	br	1da2c <dhcp_parse_reply+0x74>
  } else if (parse_sname_as_options) {
   1e228:	e0bff717 	ldw	r2,-36(fp)
   1e22c:	10000626 	beq	r2,zero,1e248 <dhcp_parse_reply+0x890>
    parse_sname_as_options = 0;
   1e230:	e03ff715 	stw	zero,-36(fp)
    options_idx = DHCP_SNAME_OFS;
   1e234:	00800b04 	movi	r2,44
   1e238:	e0bff40d 	sth	r2,-48(fp)
    options_idx_max = DHCP_SNAME_OFS + DHCP_SNAME_LEN;
   1e23c:	00801b04 	movi	r2,108
   1e240:	e0bff48d 	sth	r2,-46(fp)
    goto again;
   1e244:	003df906 	br	1da2c <dhcp_parse_reply+0x74>
  }
  return ERR_OK;
   1e248:	0005883a 	mov	r2,zero
}
   1e24c:	e037883a 	mov	sp,fp
   1e250:	dfc00117 	ldw	ra,4(sp)
   1e254:	df000017 	ldw	fp,0(sp)
   1e258:	dec00204 	addi	sp,sp,8
   1e25c:	f800283a 	ret

0001e260 <dhcp_recv>:
/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void
dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *addr, u16_t port)
{
   1e260:	defff404 	addi	sp,sp,-48
   1e264:	dfc00b15 	stw	ra,44(sp)
   1e268:	df000a15 	stw	fp,40(sp)
   1e26c:	df000a04 	addi	fp,sp,40
   1e270:	e13ffb15 	stw	r4,-20(fp)
   1e274:	e17ffc15 	stw	r5,-16(fp)
   1e278:	e1bffd15 	stw	r6,-12(fp)
   1e27c:	e1fffe15 	stw	r7,-8(fp)
   1e280:	e0800217 	ldw	r2,8(fp)
   1e284:	e0bfff0d 	sth	r2,-4(fp)
  struct netif *netif = (struct netif *)arg;
   1e288:	e0bffb17 	ldw	r2,-20(fp)
   1e28c:	e0bff715 	stw	r2,-36(fp)
  struct dhcp *dhcp = netif->dhcp;
   1e290:	e0bff717 	ldw	r2,-36(fp)
   1e294:	10800a17 	ldw	r2,40(r2)
   1e298:	e0bff815 	stw	r2,-32(fp)
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
   1e29c:	e0bffd17 	ldw	r2,-12(fp)
   1e2a0:	10800117 	ldw	r2,4(r2)
   1e2a4:	e0bff915 	stw	r2,-28(fp)
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);

  LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL);

  if (p->len < DHCP_MIN_REPLY_LEN) {
   1e2a8:	e0bffd17 	ldw	r2,-12(fp)
   1e2ac:	1080028b 	ldhu	r2,10(r2)
   1e2b0:	10bfffcc 	andi	r2,r2,65535
   1e2b4:	10800b28 	cmpgeui	r2,r2,44
   1e2b8:	1000aa26 	beq	r2,zero,1e564 <dhcp_recv+0x304>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP reply message or pbuf too short\n"));
    goto free_pbuf_and_return;
  }

  if (reply_msg->op != DHCP_BOOTREPLY) {
   1e2bc:	e0bff917 	ldw	r2,-28(fp)
   1e2c0:	10800003 	ldbu	r2,0(r2)
   1e2c4:	10803fcc 	andi	r2,r2,255
   1e2c8:	108000a0 	cmpeqi	r2,r2,2
   1e2cc:	1000a726 	beq	r2,zero,1e56c <dhcp_recv+0x30c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
   1e2d0:	e03ff605 	stb	zero,-40(fp)
   1e2d4:	00001006 	br	1e318 <dhcp_recv+0xb8>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
   1e2d8:	e0bff603 	ldbu	r2,-40(fp)
   1e2dc:	e0fff717 	ldw	r3,-36(fp)
   1e2e0:	1885883a 	add	r2,r3,r2
   1e2e4:	10800c04 	addi	r2,r2,48
   1e2e8:	10c000c3 	ldbu	r3,3(r2)
   1e2ec:	e0bff603 	ldbu	r2,-40(fp)
   1e2f0:	e13ff917 	ldw	r4,-28(fp)
   1e2f4:	2085883a 	add	r2,r4,r2
   1e2f8:	10800704 	addi	r2,r2,28
   1e2fc:	10800003 	ldbu	r2,0(r2)
   1e300:	18c03fcc 	andi	r3,r3,255
   1e304:	10803fcc 	andi	r2,r2,255
   1e308:	18809a1e 	bne	r3,r2,1e574 <dhcp_recv+0x314>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
   1e30c:	e0bff603 	ldbu	r2,-40(fp)
   1e310:	10800044 	addi	r2,r2,1
   1e314:	e0bff605 	stb	r2,-40(fp)
   1e318:	e0bff717 	ldw	r2,-36(fp)
   1e31c:	10800c83 	ldbu	r2,50(r2)
   1e320:	10803fcc 	andi	r2,r2,255
   1e324:	e0fff603 	ldbu	r3,-40(fp)
   1e328:	18bfeb36 	bltu	r3,r2,1e2d8 <dhcp_recv+0x78>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
   1e32c:	e0bff917 	ldw	r2,-28(fp)
   1e330:	10c00103 	ldbu	r3,4(r2)
   1e334:	11000143 	ldbu	r4,5(r2)
   1e338:	2008923a 	slli	r4,r4,8
   1e33c:	20c6b03a 	or	r3,r4,r3
   1e340:	11000183 	ldbu	r4,6(r2)
   1e344:	2008943a 	slli	r4,r4,16
   1e348:	20c6b03a 	or	r3,r4,r3
   1e34c:	108001c3 	ldbu	r2,7(r2)
   1e350:	1004963a 	slli	r2,r2,24
   1e354:	10c4b03a 	or	r2,r2,r3
   1e358:	1006d63a 	srli	r3,r2,24
   1e35c:	e0bff917 	ldw	r2,-28(fp)
   1e360:	11000103 	ldbu	r4,4(r2)
   1e364:	11400143 	ldbu	r5,5(r2)
   1e368:	280a923a 	slli	r5,r5,8
   1e36c:	2908b03a 	or	r4,r5,r4
   1e370:	11400183 	ldbu	r5,6(r2)
   1e374:	280a943a 	slli	r5,r5,16
   1e378:	2908b03a 	or	r4,r5,r4
   1e37c:	108001c3 	ldbu	r2,7(r2)
   1e380:	1004963a 	slli	r2,r2,24
   1e384:	1104b03a 	or	r2,r2,r4
   1e388:	1004d23a 	srli	r2,r2,8
   1e38c:	10bfc00c 	andi	r2,r2,65280
   1e390:	1886b03a 	or	r3,r3,r2
   1e394:	e0bff917 	ldw	r2,-28(fp)
   1e398:	11000103 	ldbu	r4,4(r2)
   1e39c:	11400143 	ldbu	r5,5(r2)
   1e3a0:	280a923a 	slli	r5,r5,8
   1e3a4:	2908b03a 	or	r4,r5,r4
   1e3a8:	11400183 	ldbu	r5,6(r2)
   1e3ac:	280a943a 	slli	r5,r5,16
   1e3b0:	2908b03a 	or	r4,r5,r4
   1e3b4:	108001c3 	ldbu	r2,7(r2)
   1e3b8:	1004963a 	slli	r2,r2,24
   1e3bc:	1104b03a 	or	r2,r2,r4
   1e3c0:	10bfc00c 	andi	r2,r2,65280
   1e3c4:	1004923a 	slli	r2,r2,8
   1e3c8:	1886b03a 	or	r3,r3,r2
   1e3cc:	e0bff917 	ldw	r2,-28(fp)
   1e3d0:	11000103 	ldbu	r4,4(r2)
   1e3d4:	11400143 	ldbu	r5,5(r2)
   1e3d8:	280a923a 	slli	r5,r5,8
   1e3dc:	2908b03a 	or	r4,r5,r4
   1e3e0:	11400183 	ldbu	r5,6(r2)
   1e3e4:	280a943a 	slli	r5,r5,16
   1e3e8:	2908b03a 	or	r4,r5,r4
   1e3ec:	108001c3 	ldbu	r2,7(r2)
   1e3f0:	1004963a 	slli	r2,r2,24
   1e3f4:	1104b03a 	or	r2,r2,r4
   1e3f8:	1004963a 	slli	r2,r2,24
   1e3fc:	1886b03a 	or	r3,r3,r2
   1e400:	e0bff817 	ldw	r2,-32(fp)
   1e404:	10800017 	ldw	r2,0(r2)
   1e408:	18805c1e 	bne	r3,r2,1e57c <dhcp_recv+0x31c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n",ntohl(reply_msg->xid),dhcp->xid));
    goto free_pbuf_and_return;
  }
  /* option fields could be unfold? */
  if (dhcp_parse_reply(dhcp, p) != ERR_OK) {
   1e40c:	e13ff817 	ldw	r4,-32(fp)
   1e410:	e17ffd17 	ldw	r5,-12(fp)
   1e414:	001d9b80 	call	1d9b8 <dhcp_parse_reply>
   1e418:	10803fcc 	andi	r2,r2,255
   1e41c:	1080201c 	xori	r2,r2,128
   1e420:	10bfe004 	addi	r2,r2,-128
   1e424:	1000571e 	bne	r2,zero,1e584 <dhcp_recv+0x324>
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  if (!dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE)) {
   1e428:	008001b4 	movhi	r2,6
   1e42c:	108c5c04 	addi	r2,r2,12656
   1e430:	10800043 	ldbu	r2,1(r2)
   1e434:	10803fcc 	andi	r2,r2,255
   1e438:	10005426 	beq	r2,zero,1e58c <dhcp_recv+0x32c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  }

  /* read DHCP message type */
  msg_type = (u8_t)dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_MSG_TYPE);
   1e43c:	008001b4 	movhi	r2,6
   1e440:	108c5f04 	addi	r2,r2,12668
   1e444:	10800117 	ldw	r2,4(r2)
   1e448:	e0bffa05 	stb	r2,-24(fp)
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
   1e44c:	e0bffa03 	ldbu	r2,-24(fp)
   1e450:	10800158 	cmpnei	r2,r2,5
   1e454:	10001c1e 	bne	r2,zero,1e4c8 <dhcp_recv+0x268>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
   1e458:	e0bff817 	ldw	r2,-32(fp)
   1e45c:	10800303 	ldbu	r2,12(r2)
   1e460:	10803fcc 	andi	r2,r2,255
   1e464:	10800058 	cmpnei	r2,r2,1
   1e468:	1000051e 	bne	r2,zero,1e480 <dhcp_recv+0x220>
      dhcp_handle_ack(netif);
   1e46c:	e13ff717 	ldw	r4,-36(fp)
   1e470:	001c2280 	call	1c228 <dhcp_handle_ack>
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
   1e474:	e13ff717 	ldw	r4,-36(fp)
   1e478:	001ba540 	call	1ba54 <dhcp_check>
   1e47c:	00004406 	br	1e590 <dhcp_recv+0x330>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
   1e480:	e0bff817 	ldw	r2,-32(fp)
   1e484:	10800303 	ldbu	r2,12(r2)
   1e488:	10803fcc 	andi	r2,r2,255
   1e48c:	108000e0 	cmpeqi	r2,r2,3
   1e490:	10000a1e 	bne	r2,zero,1e4bc <dhcp_recv+0x25c>
   1e494:	e0bff817 	ldw	r2,-32(fp)
   1e498:	10800303 	ldbu	r2,12(r2)
   1e49c:	10803fcc 	andi	r2,r2,255
   1e4a0:	10800120 	cmpeqi	r2,r2,4
   1e4a4:	1000051e 	bne	r2,zero,1e4bc <dhcp_recv+0x25c>
   1e4a8:	e0bff817 	ldw	r2,-32(fp)
   1e4ac:	10800303 	ldbu	r2,12(r2)
   1e4b0:	10803fcc 	andi	r2,r2,255
   1e4b4:	10800158 	cmpnei	r2,r2,5
   1e4b8:	1000351e 	bne	r2,zero,1e590 <dhcp_recv+0x330>
      dhcp_bind(netif);
   1e4bc:	e13ff717 	ldw	r4,-36(fp)
   1e4c0:	001ccb40 	call	1ccb4 <dhcp_bind>
   1e4c4:	00003206 	br	1e590 <dhcp_recv+0x330>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
   1e4c8:	e0bffa03 	ldbu	r2,-24(fp)
   1e4cc:	10800198 	cmpnei	r2,r2,6
   1e4d0:	1000171e 	bne	r2,zero,1e530 <dhcp_recv+0x2d0>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
   1e4d4:	e0bff817 	ldw	r2,-32(fp)
   1e4d8:	10800303 	ldbu	r2,12(r2)
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
   1e4dc:	10803fcc 	andi	r2,r2,255
   1e4e0:	108000e0 	cmpeqi	r2,r2,3
   1e4e4:	10000f1e 	bne	r2,zero,1e524 <dhcp_recv+0x2c4>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
   1e4e8:	e0bff817 	ldw	r2,-32(fp)
   1e4ec:	10800303 	ldbu	r2,12(r2)
   1e4f0:	10803fcc 	andi	r2,r2,255
   1e4f4:	10800060 	cmpeqi	r2,r2,1
   1e4f8:	10000a1e 	bne	r2,zero,1e524 <dhcp_recv+0x2c4>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
   1e4fc:	e0bff817 	ldw	r2,-32(fp)
   1e500:	10800303 	ldbu	r2,12(r2)
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
   1e504:	10803fcc 	andi	r2,r2,255
   1e508:	10800120 	cmpeqi	r2,r2,4
   1e50c:	1000051e 	bne	r2,zero,1e524 <dhcp_recv+0x2c4>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
   1e510:	e0bff817 	ldw	r2,-32(fp)
   1e514:	10800303 	ldbu	r2,12(r2)
   1e518:	10803fcc 	andi	r2,r2,255
   1e51c:	10800158 	cmpnei	r2,r2,5
   1e520:	1000031e 	bne	r2,zero,1e530 <dhcp_recv+0x2d0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_NAK received\n"));
    dhcp_handle_nak(netif);
   1e524:	e13ff717 	ldw	r4,-36(fp)
   1e528:	001ba040 	call	1ba04 <dhcp_handle_nak>
   1e52c:	00001806 	br	1e590 <dhcp_recv+0x330>
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
   1e530:	e0bffa03 	ldbu	r2,-24(fp)
   1e534:	10800098 	cmpnei	r2,r2,2
   1e538:	1000151e 	bne	r2,zero,1e590 <dhcp_recv+0x330>
   1e53c:	e0bff817 	ldw	r2,-32(fp)
   1e540:	10800303 	ldbu	r2,12(r2)
   1e544:	10803fcc 	andi	r2,r2,255
   1e548:	10800198 	cmpnei	r2,r2,6
   1e54c:	1000101e 	bne	r2,zero,1e590 <dhcp_recv+0x330>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
   1e550:	e0bff817 	ldw	r2,-32(fp)
   1e554:	1000068d 	sth	zero,26(r2)
    /* remember offered lease */
    dhcp_handle_offer(netif);
   1e558:	e13ff717 	ldw	r4,-36(fp)
   1e55c:	001baec0 	call	1baec <dhcp_handle_offer>
   1e560:	00000b06 	br	1e590 <dhcp_recv+0x330>

  LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL);

  if (p->len < DHCP_MIN_REPLY_LEN) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP reply message or pbuf too short\n"));
    goto free_pbuf_and_return;
   1e564:	0001883a 	nop
   1e568:	00000906 	br	1e590 <dhcp_recv+0x330>
  }

  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
   1e56c:	0001883a 	nop
   1e570:	00000706 	br	1e590 <dhcp_recv+0x330>
  for (i = 0; i < netif->hwaddr_len; i++) {
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
        ("netif->hwaddr[%"U16_F"]==%02"X16_F" != reply_msg->chaddr[%"U16_F"]==%02"X16_F"\n",
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
   1e574:	0001883a 	nop
   1e578:	00000506 	br	1e590 <dhcp_recv+0x330>
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n",ntohl(reply_msg->xid),dhcp->xid));
    goto free_pbuf_and_return;
   1e57c:	0001883a 	nop
   1e580:	00000306 	br	1e590 <dhcp_recv+0x330>
  }
  /* option fields could be unfold? */
  if (dhcp_parse_reply(dhcp, p) != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("problem unfolding DHCP message - too short on memory?\n"));
    goto free_pbuf_and_return;
   1e584:	0001883a 	nop
   1e588:	00000106 	br	1e590 <dhcp_recv+0x330>

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  if (!dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE)) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
   1e58c:	0001883a 	nop
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  dhcp->msg_in = NULL;
   1e590:	e0bff817 	ldw	r2,-32(fp)
   1e594:	10000215 	stw	zero,8(r2)
  pbuf_free(p);
   1e598:	e13ffd17 	ldw	r4,-12(fp)
   1e59c:	00237600 	call	23760 <pbuf_free>
}
   1e5a0:	e037883a 	mov	sp,fp
   1e5a4:	dfc00117 	ldw	ra,4(sp)
   1e5a8:	df000017 	ldw	fp,0(sp)
   1e5ac:	dec00204 	addi	sp,sp,8
   1e5b0:	f800283a 	ret

0001e5b4 <dhcp_create_msg>:
 * @param dhcp dhcp control struct
 * @param message_type message type of the request
 */
static err_t
dhcp_create_msg(struct netif *netif, struct dhcp *dhcp, u8_t message_type)
{
   1e5b4:	defffa04 	addi	sp,sp,-24
   1e5b8:	dfc00515 	stw	ra,20(sp)
   1e5bc:	df000415 	stw	fp,16(sp)
   1e5c0:	df000404 	addi	fp,sp,16
   1e5c4:	e13ffd15 	stw	r4,-12(fp)
   1e5c8:	e17ffe15 	stw	r5,-8(fp)
   1e5cc:	3005883a 	mov	r2,r6
   1e5d0:	e0bfff05 	stb	r2,-4(fp)
  if (!xid_initialised) {
    xid = DHCP_GLOBAL_XID;
    xid_initialised = !xid_initialised;
  }
#endif
  LWIP_ERROR("dhcp_create_msg: netif != NULL", (netif != NULL), return ERR_ARG;);
   1e5d4:	e0bffd17 	ldw	r2,-12(fp)
   1e5d8:	1000091e 	bne	r2,zero,1e600 <dhcp_create_msg+0x4c>
   1e5dc:	01000134 	movhi	r4,4
   1e5e0:	21040004 	addi	r4,r4,4096
   1e5e4:	01400134 	movhi	r5,4
   1e5e8:	29444304 	addi	r5,r5,4364
   1e5ec:	0181a244 	movi	r6,1673
   1e5f0:	01c00134 	movhi	r7,4
   1e5f4:	39c41004 	addi	r7,r7,4160
   1e5f8:	00044740 	call	4474 <printf>
   1e5fc:	003fff06 	br	1e5fc <dhcp_create_msg+0x48>
  LWIP_ERROR("dhcp_create_msg: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
   1e600:	e0bffe17 	ldw	r2,-8(fp)
   1e604:	1000091e 	bne	r2,zero,1e62c <dhcp_create_msg+0x78>
   1e608:	01000134 	movhi	r4,4
   1e60c:	21040004 	addi	r4,r4,4096
   1e610:	01400134 	movhi	r5,4
   1e614:	29444b04 	addi	r5,r5,4396
   1e618:	0181a284 	movi	r6,1674
   1e61c:	01c00134 	movhi	r7,4
   1e620:	39c41004 	addi	r7,r7,4160
   1e624:	00044740 	call	4474 <printf>
   1e628:	003fff06 	br	1e628 <dhcp_create_msg+0x74>
  LWIP_ASSERT("dhcp_create_msg: dhcp->p_out == NULL", dhcp->p_out == NULL);
  LWIP_ASSERT("dhcp_create_msg: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
   1e62c:	0009883a 	mov	r4,zero
   1e630:	01404d04 	movi	r5,308
   1e634:	000d883a 	mov	r6,zero
   1e638:	0022fa00 	call	22fa0 <pbuf_alloc>
   1e63c:	e0fffe17 	ldw	r3,-8(fp)
   1e640:	18800415 	stw	r2,16(r3)
  if (dhcp->p_out == NULL) {
   1e644:	e0bffe17 	ldw	r2,-8(fp)
   1e648:	10800417 	ldw	r2,16(r2)
   1e64c:	1000021e 	bne	r2,zero,1e658 <dhcp_create_msg+0xa4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_create_msg(): could not allocate pbuf\n"));
    return ERR_MEM;
   1e650:	00bfffc4 	movi	r2,-1
   1e654:	00012206 	br	1eae0 <dhcp_create_msg+0x52c>
  }
  LWIP_ASSERT("dhcp_create_msg: check that first pbuf can hold struct dhcp_msg",
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* reuse transaction identifier in retransmissions */
  if (dhcp->tries == 0) {
   1e658:	e0bffe17 	ldw	r2,-8(fp)
   1e65c:	10800343 	ldbu	r2,13(r2)
   1e660:	10803fcc 	andi	r2,r2,255
   1e664:	1000031e 	bne	r2,zero,1e674 <dhcp_create_msg+0xc0>
#if DHCP_CREATE_RAND_XID && defined(LWIP_RAND)
    xid = LWIP_RAND();
#else /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
    xid++;
   1e668:	d0a00e17 	ldw	r2,-32712(gp)
   1e66c:	10800044 	addi	r2,r2,1
   1e670:	d0a00e15 	stw	r2,-32712(gp)
#endif /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
  }
  dhcp->xid = xid;
   1e674:	d0e00e17 	ldw	r3,-32712(gp)
   1e678:	e0bffe17 	ldw	r2,-8(fp)
   1e67c:	10c00015 	stw	r3,0(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
              ("transaction id xid(%"X32_F")\n", xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
   1e680:	e0bffe17 	ldw	r2,-8(fp)
   1e684:	10800417 	ldw	r2,16(r2)
   1e688:	10c00117 	ldw	r3,4(r2)
   1e68c:	e0bffe17 	ldw	r2,-8(fp)
   1e690:	10c00515 	stw	r3,20(r2)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
   1e694:	e0bffe17 	ldw	r2,-8(fp)
   1e698:	10800517 	ldw	r2,20(r2)
   1e69c:	00c00044 	movi	r3,1
   1e6a0:	10c00005 	stb	r3,0(r2)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
   1e6a4:	e0bffe17 	ldw	r2,-8(fp)
   1e6a8:	10800517 	ldw	r2,20(r2)
   1e6ac:	00c00044 	movi	r3,1
   1e6b0:	10c00045 	stb	r3,1(r2)
  dhcp->msg_out->hlen = netif->hwaddr_len;
   1e6b4:	e0bffe17 	ldw	r2,-8(fp)
   1e6b8:	10800517 	ldw	r2,20(r2)
   1e6bc:	e0fffd17 	ldw	r3,-12(fp)
   1e6c0:	18c00c83 	ldbu	r3,50(r3)
   1e6c4:	10c00085 	stb	r3,2(r2)
  dhcp->msg_out->hops = 0;
   1e6c8:	e0bffe17 	ldw	r2,-8(fp)
   1e6cc:	10800517 	ldw	r2,20(r2)
   1e6d0:	100000c5 	stb	zero,3(r2)
  dhcp->msg_out->xid = htonl(dhcp->xid);
   1e6d4:	e0bffe17 	ldw	r2,-8(fp)
   1e6d8:	10800517 	ldw	r2,20(r2)
   1e6dc:	e0fffe17 	ldw	r3,-8(fp)
   1e6e0:	18c00017 	ldw	r3,0(r3)
   1e6e4:	1808d63a 	srli	r4,r3,24
   1e6e8:	e0fffe17 	ldw	r3,-8(fp)
   1e6ec:	18c00017 	ldw	r3,0(r3)
   1e6f0:	1806d23a 	srli	r3,r3,8
   1e6f4:	18ffc00c 	andi	r3,r3,65280
   1e6f8:	20c8b03a 	or	r4,r4,r3
   1e6fc:	e0fffe17 	ldw	r3,-8(fp)
   1e700:	18c00017 	ldw	r3,0(r3)
   1e704:	18ffc00c 	andi	r3,r3,65280
   1e708:	1806923a 	slli	r3,r3,8
   1e70c:	20c8b03a 	or	r4,r4,r3
   1e710:	e0fffe17 	ldw	r3,-8(fp)
   1e714:	18c00017 	ldw	r3,0(r3)
   1e718:	1806963a 	slli	r3,r3,24
   1e71c:	20c6b03a 	or	r3,r4,r3
   1e720:	19003fcc 	andi	r4,r3,255
   1e724:	11400103 	ldbu	r5,4(r2)
   1e728:	280a703a 	and	r5,r5,zero
   1e72c:	2908b03a 	or	r4,r5,r4
   1e730:	11000105 	stb	r4,4(r2)
   1e734:	1808d23a 	srli	r4,r3,8
   1e738:	21003fcc 	andi	r4,r4,255
   1e73c:	11400143 	ldbu	r5,5(r2)
   1e740:	280a703a 	and	r5,r5,zero
   1e744:	2908b03a 	or	r4,r5,r4
   1e748:	11000145 	stb	r4,5(r2)
   1e74c:	1808d43a 	srli	r4,r3,16
   1e750:	21003fcc 	andi	r4,r4,255
   1e754:	11400183 	ldbu	r5,6(r2)
   1e758:	280a703a 	and	r5,r5,zero
   1e75c:	2908b03a 	or	r4,r5,r4
   1e760:	11000185 	stb	r4,6(r2)
   1e764:	1806d63a 	srli	r3,r3,24
   1e768:	110001c3 	ldbu	r4,7(r2)
   1e76c:	2008703a 	and	r4,r4,zero
   1e770:	20c6b03a 	or	r3,r4,r3
   1e774:	10c001c5 	stb	r3,7(r2)
  dhcp->msg_out->secs = 0;
   1e778:	e0bffe17 	ldw	r2,-8(fp)
   1e77c:	10800517 	ldw	r2,20(r2)
   1e780:	10c00203 	ldbu	r3,8(r2)
   1e784:	1806703a 	and	r3,r3,zero
   1e788:	10c00205 	stb	r3,8(r2)
   1e78c:	10c00243 	ldbu	r3,9(r2)
   1e790:	1806703a 	and	r3,r3,zero
   1e794:	10c00245 	stb	r3,9(r2)
  /* we don't need the broadcast flag since we can receive unicast traffic
     before being fully configured! */
  dhcp->msg_out->flags = 0;
   1e798:	e0bffe17 	ldw	r2,-8(fp)
   1e79c:	10800517 	ldw	r2,20(r2)
   1e7a0:	10c00283 	ldbu	r3,10(r2)
   1e7a4:	1806703a 	and	r3,r3,zero
   1e7a8:	10c00285 	stb	r3,10(r2)
   1e7ac:	10c002c3 	ldbu	r3,11(r2)
   1e7b0:	1806703a 	and	r3,r3,zero
   1e7b4:	10c002c5 	stb	r3,11(r2)
  ip_addr_set_zero(&dhcp->msg_out->ciaddr);
   1e7b8:	e0bffe17 	ldw	r2,-8(fp)
   1e7bc:	10800517 	ldw	r2,20(r2)
   1e7c0:	10c00303 	ldbu	r3,12(r2)
   1e7c4:	1806703a 	and	r3,r3,zero
   1e7c8:	10c00305 	stb	r3,12(r2)
   1e7cc:	10c00343 	ldbu	r3,13(r2)
   1e7d0:	1806703a 	and	r3,r3,zero
   1e7d4:	10c00345 	stb	r3,13(r2)
   1e7d8:	10c00383 	ldbu	r3,14(r2)
   1e7dc:	1806703a 	and	r3,r3,zero
   1e7e0:	10c00385 	stb	r3,14(r2)
   1e7e4:	10c003c3 	ldbu	r3,15(r2)
   1e7e8:	1806703a 	and	r3,r3,zero
   1e7ec:	10c003c5 	stb	r3,15(r2)
  /* set ciaddr to netif->ip_addr based on message_type and state */
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) ||
   1e7f0:	e0bfff03 	ldbu	r2,-4(fp)
   1e7f4:	10800220 	cmpeqi	r2,r2,8
   1e7f8:	1000101e 	bne	r2,zero,1e83c <dhcp_create_msg+0x288>
   1e7fc:	e0bfff03 	ldbu	r2,-4(fp)
   1e800:	10800120 	cmpeqi	r2,r2,4
   1e804:	10000d1e 	bne	r2,zero,1e83c <dhcp_create_msg+0x288>
   1e808:	e0bfff03 	ldbu	r2,-4(fp)
   1e80c:	108000d8 	cmpnei	r2,r2,3
   1e810:	1000241e 	bne	r2,zero,1e8a4 <dhcp_create_msg+0x2f0>
      ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
       ((dhcp->state==DHCP_RENEWING) || dhcp->state==DHCP_REBINDING))) {
   1e814:	e0bffe17 	ldw	r2,-8(fp)
   1e818:	10800303 	ldbu	r2,12(r2)
     before being fully configured! */
  dhcp->msg_out->flags = 0;
  ip_addr_set_zero(&dhcp->msg_out->ciaddr);
  /* set ciaddr to netif->ip_addr based on message_type and state */
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) ||
      ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
   1e81c:	10803fcc 	andi	r2,r2,255
   1e820:	10800160 	cmpeqi	r2,r2,5
   1e824:	1000051e 	bne	r2,zero,1e83c <dhcp_create_msg+0x288>
       ((dhcp->state==DHCP_RENEWING) || dhcp->state==DHCP_REBINDING))) {
   1e828:	e0bffe17 	ldw	r2,-8(fp)
   1e82c:	10800303 	ldbu	r2,12(r2)
   1e830:	10803fcc 	andi	r2,r2,255
   1e834:	10800118 	cmpnei	r2,r2,4
   1e838:	10001a1e 	bne	r2,zero,1e8a4 <dhcp_create_msg+0x2f0>
    ip_addr_copy(dhcp->msg_out->ciaddr, netif->ip_addr);
   1e83c:	e0bffe17 	ldw	r2,-8(fp)
   1e840:	10800517 	ldw	r2,20(r2)
   1e844:	e0fffd17 	ldw	r3,-12(fp)
   1e848:	18c00117 	ldw	r3,4(r3)
   1e84c:	19003fcc 	andi	r4,r3,255
   1e850:	11400303 	ldbu	r5,12(r2)
   1e854:	280a703a 	and	r5,r5,zero
   1e858:	2908b03a 	or	r4,r5,r4
   1e85c:	11000305 	stb	r4,12(r2)
   1e860:	1808d23a 	srli	r4,r3,8
   1e864:	21003fcc 	andi	r4,r4,255
   1e868:	11400343 	ldbu	r5,13(r2)
   1e86c:	280a703a 	and	r5,r5,zero
   1e870:	2908b03a 	or	r4,r5,r4
   1e874:	11000345 	stb	r4,13(r2)
   1e878:	1808d43a 	srli	r4,r3,16
   1e87c:	21003fcc 	andi	r4,r4,255
   1e880:	11400383 	ldbu	r5,14(r2)
   1e884:	280a703a 	and	r5,r5,zero
   1e888:	2908b03a 	or	r4,r5,r4
   1e88c:	11000385 	stb	r4,14(r2)
   1e890:	1806d63a 	srli	r3,r3,24
   1e894:	110003c3 	ldbu	r4,15(r2)
   1e898:	2008703a 	and	r4,r4,zero
   1e89c:	20c6b03a 	or	r3,r4,r3
   1e8a0:	10c003c5 	stb	r3,15(r2)
  }
  ip_addr_set_zero(&dhcp->msg_out->yiaddr);
   1e8a4:	e0bffe17 	ldw	r2,-8(fp)
   1e8a8:	10800517 	ldw	r2,20(r2)
   1e8ac:	10c00403 	ldbu	r3,16(r2)
   1e8b0:	1806703a 	and	r3,r3,zero
   1e8b4:	10c00405 	stb	r3,16(r2)
   1e8b8:	10c00443 	ldbu	r3,17(r2)
   1e8bc:	1806703a 	and	r3,r3,zero
   1e8c0:	10c00445 	stb	r3,17(r2)
   1e8c4:	10c00483 	ldbu	r3,18(r2)
   1e8c8:	1806703a 	and	r3,r3,zero
   1e8cc:	10c00485 	stb	r3,18(r2)
   1e8d0:	10c004c3 	ldbu	r3,19(r2)
   1e8d4:	1806703a 	and	r3,r3,zero
   1e8d8:	10c004c5 	stb	r3,19(r2)
  ip_addr_set_zero(&dhcp->msg_out->siaddr);
   1e8dc:	e0bffe17 	ldw	r2,-8(fp)
   1e8e0:	10800517 	ldw	r2,20(r2)
   1e8e4:	10c00503 	ldbu	r3,20(r2)
   1e8e8:	1806703a 	and	r3,r3,zero
   1e8ec:	10c00505 	stb	r3,20(r2)
   1e8f0:	10c00543 	ldbu	r3,21(r2)
   1e8f4:	1806703a 	and	r3,r3,zero
   1e8f8:	10c00545 	stb	r3,21(r2)
   1e8fc:	10c00583 	ldbu	r3,22(r2)
   1e900:	1806703a 	and	r3,r3,zero
   1e904:	10c00585 	stb	r3,22(r2)
   1e908:	10c005c3 	ldbu	r3,23(r2)
   1e90c:	1806703a 	and	r3,r3,zero
   1e910:	10c005c5 	stb	r3,23(r2)
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
   1e914:	e0bffe17 	ldw	r2,-8(fp)
   1e918:	10800517 	ldw	r2,20(r2)
   1e91c:	10c00603 	ldbu	r3,24(r2)
   1e920:	1806703a 	and	r3,r3,zero
   1e924:	10c00605 	stb	r3,24(r2)
   1e928:	10c00643 	ldbu	r3,25(r2)
   1e92c:	1806703a 	and	r3,r3,zero
   1e930:	10c00645 	stb	r3,25(r2)
   1e934:	10c00683 	ldbu	r3,26(r2)
   1e938:	1806703a 	and	r3,r3,zero
   1e93c:	10c00685 	stb	r3,26(r2)
   1e940:	10c006c3 	ldbu	r3,27(r2)
   1e944:	1806703a 	and	r3,r3,zero
   1e948:	10c006c5 	stb	r3,27(r2)
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
   1e94c:	e03ffc0d 	sth	zero,-16(fp)
   1e950:	00001606 	br	1e9ac <dhcp_create_msg+0x3f8>
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
   1e954:	e0bffe17 	ldw	r2,-8(fp)
   1e958:	11000517 	ldw	r4,20(r2)
   1e95c:	e0fffc0b 	ldhu	r3,-16(fp)
   1e960:	e0bffd17 	ldw	r2,-12(fp)
   1e964:	10800c83 	ldbu	r2,50(r2)
   1e968:	10803fcc 	andi	r2,r2,255
   1e96c:	10bfffcc 	andi	r2,r2,65535
   1e970:	e17ffc0b 	ldhu	r5,-16(fp)
   1e974:	2880062e 	bgeu	r5,r2,1e990 <dhcp_create_msg+0x3dc>
   1e978:	e0bffc0b 	ldhu	r2,-16(fp)
   1e97c:	e17ffd17 	ldw	r5,-12(fp)
   1e980:	2885883a 	add	r2,r5,r2
   1e984:	10800c04 	addi	r2,r2,48
   1e988:	108000c3 	ldbu	r2,3(r2)
   1e98c:	00000106 	br	1e994 <dhcp_create_msg+0x3e0>
   1e990:	0005883a 	mov	r2,zero
   1e994:	20c7883a 	add	r3,r4,r3
   1e998:	18c00704 	addi	r3,r3,28
   1e99c:	18800005 	stb	r2,0(r3)
    ip_addr_copy(dhcp->msg_out->ciaddr, netif->ip_addr);
  }
  ip_addr_set_zero(&dhcp->msg_out->yiaddr);
  ip_addr_set_zero(&dhcp->msg_out->siaddr);
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
   1e9a0:	e0bffc0b 	ldhu	r2,-16(fp)
   1e9a4:	10800044 	addi	r2,r2,1
   1e9a8:	e0bffc0d 	sth	r2,-16(fp)
   1e9ac:	e0bffc0b 	ldhu	r2,-16(fp)
   1e9b0:	10800430 	cmpltui	r2,r2,16
   1e9b4:	103fe71e 	bne	r2,zero,1e954 <dhcp_create_msg+0x3a0>
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
   1e9b8:	e03ffc0d 	sth	zero,-16(fp)
   1e9bc:	00000906 	br	1e9e4 <dhcp_create_msg+0x430>
    dhcp->msg_out->sname[i] = 0;
   1e9c0:	e0bffe17 	ldw	r2,-8(fp)
   1e9c4:	10c00517 	ldw	r3,20(r2)
   1e9c8:	e0bffc0b 	ldhu	r2,-16(fp)
   1e9cc:	1885883a 	add	r2,r3,r2
   1e9d0:	10800b04 	addi	r2,r2,44
   1e9d4:	10000005 	stb	zero,0(r2)
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
   1e9d8:	e0bffc0b 	ldhu	r2,-16(fp)
   1e9dc:	10800044 	addi	r2,r2,1
   1e9e0:	e0bffc0d 	sth	r2,-16(fp)
   1e9e4:	e0bffc0b 	ldhu	r2,-16(fp)
   1e9e8:	10801030 	cmpltui	r2,r2,64
   1e9ec:	103ff41e 	bne	r2,zero,1e9c0 <dhcp_create_msg+0x40c>
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
   1e9f0:	e03ffc0d 	sth	zero,-16(fp)
   1e9f4:	00000906 	br	1ea1c <dhcp_create_msg+0x468>
    dhcp->msg_out->file[i] = 0;
   1e9f8:	e0bffe17 	ldw	r2,-8(fp)
   1e9fc:	10c00517 	ldw	r3,20(r2)
   1ea00:	e0bffc0b 	ldhu	r2,-16(fp)
   1ea04:	1885883a 	add	r2,r3,r2
   1ea08:	10801b04 	addi	r2,r2,108
   1ea0c:	10000005 	stb	zero,0(r2)
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
   1ea10:	e0bffc0b 	ldhu	r2,-16(fp)
   1ea14:	10800044 	addi	r2,r2,1
   1ea18:	e0bffc0d 	sth	r2,-16(fp)
   1ea1c:	e0bffc0b 	ldhu	r2,-16(fp)
   1ea20:	10802030 	cmpltui	r2,r2,128
   1ea24:	103ff41e 	bne	r2,zero,1e9f8 <dhcp_create_msg+0x444>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
   1ea28:	e0bffe17 	ldw	r2,-8(fp)
   1ea2c:	10800517 	ldw	r2,20(r2)
   1ea30:	10c03b03 	ldbu	r3,236(r2)
   1ea34:	1806703a 	and	r3,r3,zero
   1ea38:	18c018d4 	ori	r3,r3,99
   1ea3c:	10c03b05 	stb	r3,236(r2)
   1ea40:	10c03b43 	ldbu	r3,237(r2)
   1ea44:	1806703a 	and	r3,r3,zero
   1ea48:	1809883a 	mov	r4,r3
   1ea4c:	00ffe084 	movi	r3,-126
   1ea50:	20c6b03a 	or	r3,r4,r3
   1ea54:	10c03b45 	stb	r3,237(r2)
   1ea58:	10c03b83 	ldbu	r3,238(r2)
   1ea5c:	1806703a 	and	r3,r3,zero
   1ea60:	18c014d4 	ori	r3,r3,83
   1ea64:	10c03b85 	stb	r3,238(r2)
   1ea68:	10c03bc3 	ldbu	r3,239(r2)
   1ea6c:	1806703a 	and	r3,r3,zero
   1ea70:	18c018d4 	ori	r3,r3,99
   1ea74:	10c03bc5 	stb	r3,239(r2)
  dhcp->options_out_len = 0;
   1ea78:	e0bffe17 	ldw	r2,-8(fp)
   1ea7c:	1000060d 	sth	zero,24(r2)
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
   1ea80:	e03ffc0d 	sth	zero,-16(fp)
   1ea84:	00000a06 	br	1eab0 <dhcp_create_msg+0x4fc>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
   1ea88:	e0bffe17 	ldw	r2,-8(fp)
   1ea8c:	11000517 	ldw	r4,20(r2)
   1ea90:	e0bffc0b 	ldhu	r2,-16(fp)
   1ea94:	e0fffc0b 	ldhu	r3,-16(fp)
   1ea98:	2085883a 	add	r2,r4,r2
   1ea9c:	10803c04 	addi	r2,r2,240
   1eaa0:	10c00005 	stb	r3,0(r2)
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
   1eaa4:	e0bffc0b 	ldhu	r2,-16(fp)
   1eaa8:	10800044 	addi	r2,r2,1
   1eaac:	e0bffc0d 	sth	r2,-16(fp)
   1eab0:	e0bffc0b 	ldhu	r2,-16(fp)
   1eab4:	10801130 	cmpltui	r2,r2,68
   1eab8:	103ff31e 	bne	r2,zero,1ea88 <dhcp_create_msg+0x4d4>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  /* Add option MESSAGE_TYPE */
  dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
   1eabc:	e13ffe17 	ldw	r4,-8(fp)
   1eac0:	01400d44 	movi	r5,53
   1eac4:	01800044 	movi	r6,1
   1eac8:	001d6440 	call	1d644 <dhcp_option>
  dhcp_option_byte(dhcp, message_type);
   1eacc:	e0bfff03 	ldbu	r2,-4(fp)
   1ead0:	e13ffe17 	ldw	r4,-8(fp)
   1ead4:	100b883a 	mov	r5,r2
   1ead8:	001d6dc0 	call	1d6dc <dhcp_option_byte>
  return ERR_OK;
   1eadc:	0005883a 	mov	r2,zero
}
   1eae0:	e037883a 	mov	sp,fp
   1eae4:	dfc00117 	ldw	ra,4(sp)
   1eae8:	df000017 	ldw	fp,0(sp)
   1eaec:	dec00204 	addi	sp,sp,8
   1eaf0:	f800283a 	ret

0001eaf4 <dhcp_delete_msg>:
 *
 * @param dhcp the dhcp struct to free the request from
 */
static void
dhcp_delete_msg(struct dhcp *dhcp)
{
   1eaf4:	defffd04 	addi	sp,sp,-12
   1eaf8:	dfc00215 	stw	ra,8(sp)
   1eafc:	df000115 	stw	fp,4(sp)
   1eb00:	df000104 	addi	fp,sp,4
   1eb04:	e13fff15 	stw	r4,-4(fp)
  LWIP_ERROR("dhcp_delete_msg: dhcp != NULL", (dhcp != NULL), return;);
   1eb08:	e0bfff17 	ldw	r2,-4(fp)
   1eb0c:	1000091e 	bne	r2,zero,1eb34 <dhcp_delete_msg+0x40>
   1eb10:	01000134 	movhi	r4,4
   1eb14:	21040004 	addi	r4,r4,4096
   1eb18:	01400134 	movhi	r5,4
   1eb1c:	29445304 	addi	r5,r5,4428
   1eb20:	0181b584 	movi	r6,1750
   1eb24:	01c00134 	movhi	r7,4
   1eb28:	39c41004 	addi	r7,r7,4160
   1eb2c:	00044740 	call	4474 <printf>
   1eb30:	003fff06 	br	1eb30 <dhcp_delete_msg+0x3c>
  LWIP_ASSERT("dhcp_delete_msg: dhcp->p_out != NULL", dhcp->p_out != NULL);
  LWIP_ASSERT("dhcp_delete_msg: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  if (dhcp->p_out != NULL) {
   1eb34:	e0bfff17 	ldw	r2,-4(fp)
   1eb38:	10800417 	ldw	r2,16(r2)
   1eb3c:	10000426 	beq	r2,zero,1eb50 <dhcp_delete_msg+0x5c>
    pbuf_free(dhcp->p_out);
   1eb40:	e0bfff17 	ldw	r2,-4(fp)
   1eb44:	10800417 	ldw	r2,16(r2)
   1eb48:	1009883a 	mov	r4,r2
   1eb4c:	00237600 	call	23760 <pbuf_free>
  }
  dhcp->p_out = NULL;
   1eb50:	e0bfff17 	ldw	r2,-4(fp)
   1eb54:	10000415 	stw	zero,16(r2)
  dhcp->msg_out = NULL;
   1eb58:	e0bfff17 	ldw	r2,-4(fp)
   1eb5c:	10000515 	stw	zero,20(r2)
}
   1eb60:	e037883a 	mov	sp,fp
   1eb64:	dfc00117 	ldw	ra,4(sp)
   1eb68:	df000017 	ldw	fp,0(sp)
   1eb6c:	dec00204 	addi	sp,sp,8
   1eb70:	f800283a 	ret

0001eb74 <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
   1eb74:	defffd04 	addi	sp,sp,-12
   1eb78:	dfc00215 	stw	ra,8(sp)
   1eb7c:	df000115 	stw	fp,4(sp)
   1eb80:	df000104 	addi	fp,sp,4
   1eb84:	e13fff15 	stw	r4,-4(fp)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
   1eb88:	e0bfff17 	ldw	r2,-4(fp)
   1eb8c:	1000091e 	bne	r2,zero,1ebb4 <dhcp_option_trailer+0x40>
   1eb90:	01000134 	movhi	r4,4
   1eb94:	21040004 	addi	r4,r4,4096
   1eb98:	01400134 	movhi	r5,4
   1eb9c:	29445b04 	addi	r5,r5,4460
   1eba0:	0181bac4 	movi	r6,1771
   1eba4:	01c00134 	movhi	r7,4
   1eba8:	39c41004 	addi	r7,r7,4160
   1ebac:	00044740 	call	4474 <printf>
   1ebb0:	003fff06 	br	1ebb0 <dhcp_option_trailer+0x3c>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
   1ebb4:	e0bfff17 	ldw	r2,-4(fp)
   1ebb8:	11000517 	ldw	r4,20(r2)
   1ebbc:	e0bfff17 	ldw	r2,-4(fp)
   1ebc0:	1080060b 	ldhu	r2,24(r2)
   1ebc4:	10ffffcc 	andi	r3,r2,65535
   1ebc8:	20c7883a 	add	r3,r4,r3
   1ebcc:	18c03c04 	addi	r3,r3,240
   1ebd0:	013fffc4 	movi	r4,-1
   1ebd4:	19000005 	stb	r4,0(r3)
   1ebd8:	10800044 	addi	r2,r2,1
   1ebdc:	1007883a 	mov	r3,r2
   1ebe0:	e0bfff17 	ldw	r2,-4(fp)
   1ebe4:	10c0060d 	sth	r3,24(r2)
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
   1ebe8:	00000c06 	br	1ec1c <dhcp_option_trailer+0xa8>
         (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
   1ebec:	e0bfff17 	ldw	r2,-4(fp)
   1ebf0:	11000517 	ldw	r4,20(r2)
   1ebf4:	e0bfff17 	ldw	r2,-4(fp)
   1ebf8:	1080060b 	ldhu	r2,24(r2)
   1ebfc:	10ffffcc 	andi	r3,r2,65535
   1ec00:	20c7883a 	add	r3,r4,r3
   1ec04:	18c03c04 	addi	r3,r3,240
   1ec08:	18000005 	stb	zero,0(r3)
   1ec0c:	10800044 	addi	r2,r2,1
   1ec10:	1007883a 	mov	r3,r2
   1ec14:	e0bfff17 	ldw	r2,-4(fp)
   1ec18:	10c0060d 	sth	r3,24(r2)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
   1ec1c:	e0bfff17 	ldw	r2,-4(fp)
   1ec20:	1080060b 	ldhu	r2,24(r2)
   1ec24:	10bfffcc 	andi	r2,r2,65535
   1ec28:	10801130 	cmpltui	r2,r2,68
   1ec2c:	1000051e 	bne	r2,zero,1ec44 <dhcp_option_trailer+0xd0>
   1ec30:	e0bfff17 	ldw	r2,-4(fp)
   1ec34:	1080060b 	ldhu	r2,24(r2)
   1ec38:	10bfffcc 	andi	r2,r2,65535
   1ec3c:	108000cc 	andi	r2,r2,3
   1ec40:	10000526 	beq	r2,zero,1ec58 <dhcp_option_trailer+0xe4>
         (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
   1ec44:	e0bfff17 	ldw	r2,-4(fp)
   1ec48:	1080060b 	ldhu	r2,24(r2)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
   1ec4c:	10bfffcc 	andi	r2,r2,65535
   1ec50:	10801130 	cmpltui	r2,r2,68
   1ec54:	103fe51e 	bne	r2,zero,1ebec <dhcp_option_trailer+0x78>
         (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
   1ec58:	e037883a 	mov	sp,fp
   1ec5c:	dfc00117 	ldw	ra,4(sp)
   1ec60:	df000017 	ldw	fp,0(sp)
   1ec64:	dec00204 	addi	sp,sp,8
   1ec68:	f800283a 	ret

0001ec6c <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
   1ec6c:	defffe04 	addi	sp,sp,-8
   1ec70:	dfc00115 	stw	ra,4(sp)
   1ec74:	df000015 	stw	fp,0(sp)
   1ec78:	d839883a 	mov	fp,sp
  /* Modules initialization */
  stats_init();
   1ec7c:	0024a0c0 	call	24a0c <stats_init>
#if !NO_SYS
  sys_init();
   1ec80:	001b1540 	call	1b154 <sys_init>
#endif /* !NO_SYS */
  mem_init();
   1ec84:	00219a00 	call	219a0 <mem_init>
  memp_init();
   1ec88:	00222100 	call	22210 <memp_init>
  pbuf_init();
  netif_init();
   1ec8c:	00226700 	call	22670 <netif_init>
#if LWIP_SOCKET
  lwip_socket_init();
   1ec90:	00160780 	call	16078 <lwip_socket_init>
#endif /* LWIP_ARP */
#if LWIP_RAW
  raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
  udp_init();
   1ec94:	002ec1c0 	call	2ec1c <udp_init>
#endif /* LWIP_UDP */
#if LWIP_TCP
  tcp_init();
   1ec98:	0024a280 	call	24a28 <tcp_init>
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */

#if LWIP_TIMERS
  sys_timeouts_init();
   1ec9c:	002e8240 	call	2e824 <sys_timeouts_init>
#endif /* LWIP_TIMERS */
}
   1eca0:	e037883a 	mov	sp,fp
   1eca4:	dfc00117 	ldw	ra,4(sp)
   1eca8:	df000017 	ldw	fp,0(sp)
   1ecac:	dec00204 	addi	sp,sp,8
   1ecb0:	f800283a 	ret

0001ecb4 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(ip_addr_t *src, ip_addr_t *dest)
{
   1ecb4:	defffc04 	addi	sp,sp,-16
   1ecb8:	df000315 	stw	fp,12(sp)
   1ecbc:	df000304 	addi	fp,sp,12
   1ecc0:	e13ffe15 	stw	r4,-8(fp)
   1ecc4:	e17fff15 	stw	r5,-4(fp)
    return netif;
  }
#endif

  /* iterate through netifs */
  for (netif = netif_list; netif != NULL; netif = netif->next) {
   1ecc8:	00800134 	movhi	r2,4
   1eccc:	109eed04 	addi	r2,r2,31668
   1ecd0:	10800017 	ldw	r2,0(r2)
   1ecd4:	e0bffd15 	stw	r2,-12(fp)
   1ecd8:	00001d06 	br	1ed50 <ip_route+0x9c>
    /* network mask matches? */
    if (netif_is_up(netif)) {
   1ecdc:	e0bffd17 	ldw	r2,-12(fp)
   1ece0:	10800e43 	ldbu	r2,57(r2)
   1ece4:	10803fcc 	andi	r2,r2,255
   1ece8:	1080004c 	andi	r2,r2,1
   1ecec:	10001526 	beq	r2,zero,1ed44 <ip_route+0x90>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
   1ecf0:	e0bfff17 	ldw	r2,-4(fp)
   1ecf4:	10c00017 	ldw	r3,0(r2)
   1ecf8:	e0bffd17 	ldw	r2,-12(fp)
   1ecfc:	10800117 	ldw	r2,4(r2)
   1ed00:	1886f03a 	xor	r3,r3,r2
   1ed04:	e0bffd17 	ldw	r2,-12(fp)
   1ed08:	10800217 	ldw	r2,8(r2)
   1ed0c:	1884703a 	and	r2,r3,r2
   1ed10:	10000c1e 	bne	r2,zero,1ed44 <ip_route+0x90>
        if (!src || !src->addr || ip_addr_cmp(src, &(netif->ip_addr))) {
   1ed14:	e0bffe17 	ldw	r2,-8(fp)
   1ed18:	10000826 	beq	r2,zero,1ed3c <ip_route+0x88>
   1ed1c:	e0bffe17 	ldw	r2,-8(fp)
   1ed20:	10800017 	ldw	r2,0(r2)
   1ed24:	10000526 	beq	r2,zero,1ed3c <ip_route+0x88>
   1ed28:	e0bffe17 	ldw	r2,-8(fp)
   1ed2c:	10c00017 	ldw	r3,0(r2)
   1ed30:	e0bffd17 	ldw	r2,-12(fp)
   1ed34:	10800117 	ldw	r2,4(r2)
   1ed38:	1880021e 	bne	r3,r2,1ed44 <ip_route+0x90>
        /* return netif on which to forward IP packet */
        return netif;
   1ed3c:	e0bffd17 	ldw	r2,-12(fp)
   1ed40:	00001c06 	br	1edb4 <ip_route+0x100>
    return netif;
  }
#endif

  /* iterate through netifs */
  for (netif = netif_list; netif != NULL; netif = netif->next) {
   1ed44:	e0bffd17 	ldw	r2,-12(fp)
   1ed48:	10800017 	ldw	r2,0(r2)
   1ed4c:	e0bffd15 	stw	r2,-12(fp)
   1ed50:	e0bffd17 	ldw	r2,-12(fp)
   1ed54:	103fe11e 	bne	r2,zero,1ecdc <ip_route+0x28>
        return netif;
      }
    }
  }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
   1ed58:	00800134 	movhi	r2,4
   1ed5c:	109eee04 	addi	r2,r2,31672
   1ed60:	10800017 	ldw	r2,0(r2)
   1ed64:	10000726 	beq	r2,zero,1ed84 <ip_route+0xd0>
   1ed68:	00800134 	movhi	r2,4
   1ed6c:	109eee04 	addi	r2,r2,31672
   1ed70:	10800017 	ldw	r2,0(r2)
   1ed74:	10800e43 	ldbu	r2,57(r2)
   1ed78:	10803fcc 	andi	r2,r2,255
   1ed7c:	1080004c 	andi	r2,r2,1
   1ed80:	1000091e 	bne	r2,zero,1eda8 <ip_route+0xf4>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_route: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
   1ed84:	008001f4 	movhi	r2,7
   1ed88:	10ac6e04 	addi	r2,r2,-20040
   1ed8c:	10802b17 	ldw	r2,172(r2)
   1ed90:	10c00044 	addi	r3,r2,1
   1ed94:	008001f4 	movhi	r2,7
   1ed98:	10ac6e04 	addi	r2,r2,-20040
   1ed9c:	10c02b15 	stw	r3,172(r2)
    snmp_inc_ipoutnoroutes();
    return NULL;
   1eda0:	0005883a 	mov	r2,zero
   1eda4:	00000306 	br	1edb4 <ip_route+0x100>
  }
  /* no matching netif found, use default netif */
  return netif_default;
   1eda8:	00800134 	movhi	r2,4
   1edac:	109eee04 	addi	r2,r2,31672
   1edb0:	10800017 	ldw	r2,0(r2)
}
   1edb4:	e037883a 	mov	sp,fp
   1edb8:	df000017 	ldw	fp,0(sp)
   1edbc:	dec00104 	addi	sp,sp,4
   1edc0:	f800283a 	ret

0001edc4 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
   1edc4:	defff604 	addi	sp,sp,-40
   1edc8:	dfc00915 	stw	ra,36(sp)
   1edcc:	df000815 	stw	fp,32(sp)
   1edd0:	df000804 	addi	fp,sp,32
   1edd4:	e13ffe15 	stw	r4,-8(fp)
   1edd8:	e17fff15 	stw	r5,-4(fp)
  struct ip_hdr *iphdr;
  struct netif *netif;
  u16_t iphdr_hlen;
  u16_t iphdr_len;
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  int check_ip_src=1;
   1eddc:	00800044 	movi	r2,1
   1ede0:	e0bffa15 	stw	r2,-24(fp)
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */

  IP_STATS_INC(ip.recv);
   1ede4:	008001f4 	movhi	r2,7
   1ede8:	10ac6e04 	addi	r2,r2,-20040
   1edec:	10802517 	ldw	r2,148(r2)
   1edf0:	10c00044 	addi	r3,r2,1
   1edf4:	008001f4 	movhi	r2,7
   1edf8:	10ac6e04 	addi	r2,r2,-20040
   1edfc:	10c02515 	stw	r3,148(r2)
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
   1ee00:	e0bffe17 	ldw	r2,-8(fp)
   1ee04:	10800117 	ldw	r2,4(r2)
   1ee08:	e0bff815 	stw	r2,-32(fp)
  if (IPH_V(iphdr) != 4) {
   1ee0c:	e0bff817 	ldw	r2,-32(fp)
   1ee10:	10800003 	ldbu	r2,0(r2)
   1ee14:	10803fcc 	andi	r2,r2,255
   1ee18:	1004d13a 	srli	r2,r2,4
   1ee1c:	10803fcc 	andi	r2,r2,255
   1ee20:	10800120 	cmpeqi	r2,r2,4
   1ee24:	1000121e 	bne	r2,zero,1ee70 <ip_input+0xac>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
   1ee28:	e13ffe17 	ldw	r4,-8(fp)
   1ee2c:	00237600 	call	23760 <pbuf_free>
    IP_STATS_INC(ip.err);
   1ee30:	008001f4 	movhi	r2,7
   1ee34:	10ac6e04 	addi	r2,r2,-20040
   1ee38:	10802e17 	ldw	r2,184(r2)
   1ee3c:	10c00044 	addi	r3,r2,1
   1ee40:	008001f4 	movhi	r2,7
   1ee44:	10ac6e04 	addi	r2,r2,-20040
   1ee48:	10c02e15 	stw	r3,184(r2)
    IP_STATS_INC(ip.drop);
   1ee4c:	008001f4 	movhi	r2,7
   1ee50:	10ac6e04 	addi	r2,r2,-20040
   1ee54:	10802717 	ldw	r2,156(r2)
   1ee58:	10c00044 	addi	r3,r2,1
   1ee5c:	008001f4 	movhi	r2,7
   1ee60:	10ac6e04 	addi	r2,r2,-20040
   1ee64:	10c02715 	stw	r3,156(r2)
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
   1ee68:	0005883a 	mov	r2,zero
   1ee6c:	00012106 	br	1f2f4 <ip_input+0x530>
    return ERR_OK;
  }
#endif

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
   1ee70:	e0bff817 	ldw	r2,-32(fp)
   1ee74:	10800003 	ldbu	r2,0(r2)
   1ee78:	10803fcc 	andi	r2,r2,255
   1ee7c:	108003cc 	andi	r2,r2,15
   1ee80:	e0bffc0d 	sth	r2,-16(fp)
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
   1ee84:	e0bffc0b 	ldhu	r2,-16(fp)
   1ee88:	1085883a 	add	r2,r2,r2
   1ee8c:	1085883a 	add	r2,r2,r2
   1ee90:	e0bffc0d 	sth	r2,-16(fp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
   1ee94:	e0bff817 	ldw	r2,-32(fp)
   1ee98:	10c00083 	ldbu	r3,2(r2)
   1ee9c:	108000c3 	ldbu	r2,3(r2)
   1eea0:	1004923a 	slli	r2,r2,8
   1eea4:	10c4b03a 	or	r2,r2,r3
   1eea8:	10bfffcc 	andi	r2,r2,65535
   1eeac:	1004d23a 	srli	r2,r2,8
   1eeb0:	1007883a 	mov	r3,r2
   1eeb4:	e0bff817 	ldw	r2,-32(fp)
   1eeb8:	11000083 	ldbu	r4,2(r2)
   1eebc:	108000c3 	ldbu	r2,3(r2)
   1eec0:	1004923a 	slli	r2,r2,8
   1eec4:	1104b03a 	or	r2,r2,r4
   1eec8:	10bfffcc 	andi	r2,r2,65535
   1eecc:	1004923a 	slli	r2,r2,8
   1eed0:	1884b03a 	or	r2,r3,r2
   1eed4:	e0bffc8d 	sth	r2,-14(fp)

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
   1eed8:	e0bffe17 	ldw	r2,-8(fp)
   1eedc:	1080028b 	ldhu	r2,10(r2)
   1eee0:	10ffffcc 	andi	r3,r2,65535
   1eee4:	e0bffc0b 	ldhu	r2,-16(fp)
   1eee8:	18800536 	bltu	r3,r2,1ef00 <ip_input+0x13c>
   1eeec:	e0bffe17 	ldw	r2,-8(fp)
   1eef0:	1080020b 	ldhu	r2,8(r2)
   1eef4:	10ffffcc 	andi	r3,r2,65535
   1eef8:	e0bffc8b 	ldhu	r2,-14(fp)
   1eefc:	1880122e 	bgeu	r3,r2,1ef48 <ip_input+0x184>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
        iphdr_len, p->tot_len));
    }
    /* free (drop) packet pbufs */
    pbuf_free(p);
   1ef00:	e13ffe17 	ldw	r4,-8(fp)
   1ef04:	00237600 	call	23760 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
   1ef08:	008001f4 	movhi	r2,7
   1ef0c:	10ac6e04 	addi	r2,r2,-20040
   1ef10:	10802917 	ldw	r2,164(r2)
   1ef14:	10c00044 	addi	r3,r2,1
   1ef18:	008001f4 	movhi	r2,7
   1ef1c:	10ac6e04 	addi	r2,r2,-20040
   1ef20:	10c02915 	stw	r3,164(r2)
    IP_STATS_INC(ip.drop);
   1ef24:	008001f4 	movhi	r2,7
   1ef28:	10ac6e04 	addi	r2,r2,-20040
   1ef2c:	10802717 	ldw	r2,156(r2)
   1ef30:	10c00044 	addi	r3,r2,1
   1ef34:	008001f4 	movhi	r2,7
   1ef38:	10ac6e04 	addi	r2,r2,-20040
   1ef3c:	10c02715 	stw	r3,156(r2)
    snmp_inc_ipindiscards();
    return ERR_OK;
   1ef40:	0005883a 	mov	r2,zero
   1ef44:	0000eb06 	br	1f2f4 <ip_input+0x530>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
   1ef48:	e0bffc0b 	ldhu	r2,-16(fp)
   1ef4c:	e13ff817 	ldw	r4,-32(fp)
   1ef50:	100b883a 	mov	r5,r2
   1ef54:	003e6d40 	call	3e6d4 <inet_chksum>
   1ef58:	10bfffcc 	andi	r2,r2,65535
   1ef5c:	10001226 	beq	r2,zero,1efa8 <ip_input+0x1e4>

    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
      ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
   1ef60:	e13ffe17 	ldw	r4,-8(fp)
   1ef64:	00237600 	call	23760 <pbuf_free>
    IP_STATS_INC(ip.chkerr);
   1ef68:	008001f4 	movhi	r2,7
   1ef6c:	10ac6e04 	addi	r2,r2,-20040
   1ef70:	10802817 	ldw	r2,160(r2)
   1ef74:	10c00044 	addi	r3,r2,1
   1ef78:	008001f4 	movhi	r2,7
   1ef7c:	10ac6e04 	addi	r2,r2,-20040
   1ef80:	10c02815 	stw	r3,160(r2)
    IP_STATS_INC(ip.drop);
   1ef84:	008001f4 	movhi	r2,7
   1ef88:	10ac6e04 	addi	r2,r2,-20040
   1ef8c:	10802717 	ldw	r2,156(r2)
   1ef90:	10c00044 	addi	r3,r2,1
   1ef94:	008001f4 	movhi	r2,7
   1ef98:	10ac6e04 	addi	r2,r2,-20040
   1ef9c:	10c02715 	stw	r3,156(r2)
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
   1efa0:	0005883a 	mov	r2,zero
   1efa4:	0000d306 	br	1f2f4 <ip_input+0x530>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
   1efa8:	e0bffc8b 	ldhu	r2,-14(fp)
   1efac:	e13ffe17 	ldw	r4,-8(fp)
   1efb0:	100b883a 	mov	r5,r2
   1efb4:	00234500 	call	23450 <pbuf_realloc>

  /* copy IP addresses to aligned ip_addr_t */
  ip_addr_copy(current_iphdr_dest, iphdr->dest);
   1efb8:	e0bff817 	ldw	r2,-32(fp)
   1efbc:	10c00403 	ldbu	r3,16(r2)
   1efc0:	11000443 	ldbu	r4,17(r2)
   1efc4:	2008923a 	slli	r4,r4,8
   1efc8:	20c6b03a 	or	r3,r4,r3
   1efcc:	11000483 	ldbu	r4,18(r2)
   1efd0:	2008943a 	slli	r4,r4,16
   1efd4:	20c6b03a 	or	r3,r4,r3
   1efd8:	108004c3 	ldbu	r2,19(r2)
   1efdc:	1004963a 	slli	r2,r2,24
   1efe0:	10c4b03a 	or	r2,r2,r3
   1efe4:	d0a92815 	stw	r2,-23392(gp)
  ip_addr_copy(current_iphdr_src, iphdr->src);
   1efe8:	e0bff817 	ldw	r2,-32(fp)
   1efec:	10c00303 	ldbu	r3,12(r2)
   1eff0:	11000343 	ldbu	r4,13(r2)
   1eff4:	2008923a 	slli	r4,r4,8
   1eff8:	20c6b03a 	or	r3,r4,r3
   1effc:	11000383 	ldbu	r4,14(r2)
   1f000:	2008943a 	slli	r4,r4,16
   1f004:	20c6b03a 	or	r3,r4,r3
   1f008:	108003c3 	ldbu	r2,15(r2)
   1f00c:	1004963a 	slli	r2,r2,24
   1f010:	10c4b03a 	or	r2,r2,r3
   1f014:	d0a92615 	stw	r2,-23400(gp)
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
   1f018:	00800044 	movi	r2,1
   1f01c:	e0bffb15 	stw	r2,-20(fp)
    netif = inp;
   1f020:	e0bfff17 	ldw	r2,-4(fp)
   1f024:	e0bff915 	stw	r2,-28(fp)
          ip4_addr_get_u32(&iphdr->dest) & ip4_addr_get_u32(&netif->netmask),
          ip4_addr_get_u32(&netif->ip_addr) & ip4_addr_get_u32(&netif->netmask),
          ip4_addr_get_u32(&iphdr->dest) & ~ip4_addr_get_u32(&netif->netmask)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
   1f028:	e0bff917 	ldw	r2,-28(fp)
   1f02c:	10800e43 	ldbu	r2,57(r2)
   1f030:	10803fcc 	andi	r2,r2,255
   1f034:	1080004c 	andi	r2,r2,1
   1f038:	10001026 	beq	r2,zero,1f07c <ip_input+0x2b8>
   1f03c:	e0bff917 	ldw	r2,-28(fp)
   1f040:	10800104 	addi	r2,r2,4
   1f044:	10000d26 	beq	r2,zero,1f07c <ip_input+0x2b8>
   1f048:	e0bff917 	ldw	r2,-28(fp)
   1f04c:	10800117 	ldw	r2,4(r2)
   1f050:	10000a26 	beq	r2,zero,1f07c <ip_input+0x2b8>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
   1f054:	d0e92817 	ldw	r3,-23392(gp)
   1f058:	e0bff917 	ldw	r2,-28(fp)
   1f05c:	10800117 	ldw	r2,4(r2)
   1f060:	18801926 	beq	r3,r2,1f0c8 <ip_input+0x304>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&current_iphdr_dest, netif)) {
   1f064:	d0a92817 	ldw	r2,-23392(gp)
   1f068:	1009883a 	mov	r4,r2
   1f06c:	e17ff917 	ldw	r5,-28(fp)
   1f070:	001fa400 	call	1fa40 <ip4_addr_isbroadcast>
          ip4_addr_get_u32(&iphdr->dest) & ~ip4_addr_get_u32(&netif->netmask)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
   1f074:	10803fcc 	andi	r2,r2,255
   1f078:	1000131e 	bne	r2,zero,1f0c8 <ip_input+0x304>
          /* break out of for loop */
          break;
        }
#endif /* LWIP_AUTOIP */
      }
      if (first) {
   1f07c:	e0bffb17 	ldw	r2,-20(fp)
   1f080:	10000626 	beq	r2,zero,1f09c <ip_input+0x2d8>
        first = 0;
   1f084:	e03ffb15 	stw	zero,-20(fp)
        netif = netif_list;
   1f088:	00800134 	movhi	r2,4
   1f08c:	109eed04 	addi	r2,r2,31668
   1f090:	10800017 	ldw	r2,0(r2)
   1f094:	e0bff915 	stw	r2,-28(fp)
   1f098:	00000306 	br	1f0a8 <ip_input+0x2e4>
      } else {
        netif = netif->next;
   1f09c:	e0bff917 	ldw	r2,-28(fp)
   1f0a0:	10800017 	ldw	r2,0(r2)
   1f0a4:	e0bff915 	stw	r2,-28(fp)
      }
      if (netif == inp) {
   1f0a8:	e0fff917 	ldw	r3,-28(fp)
   1f0ac:	e0bfff17 	ldw	r2,-4(fp)
   1f0b0:	1880031e 	bne	r3,r2,1f0c0 <ip_input+0x2fc>
        netif = netif->next;
   1f0b4:	e0bff917 	ldw	r2,-28(fp)
   1f0b8:	10800017 	ldw	r2,0(r2)
   1f0bc:	e0bff915 	stw	r2,-28(fp)
      }
    } while(netif != NULL);
   1f0c0:	e0bff917 	ldw	r2,-28(fp)
   1f0c4:	103fd81e 	bne	r2,zero,1f028 <ip_input+0x264>
   * If you want to accept private broadcast communication while a netif is down,
   * define LWIP_IP_ACCEPT_UDP_PORT(dst_port), e.g.:
   *
   * #define LWIP_IP_ACCEPT_UDP_PORT(dst_port) ((dst_port) == PP_NTOHS(12345))
   */
  if (netif == NULL) {
   1f0c8:	e0bff917 	ldw	r2,-28(fp)
   1f0cc:	1000141e 	bne	r2,zero,1f120 <ip_input+0x35c>
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
   1f0d0:	e0bff817 	ldw	r2,-32(fp)
   1f0d4:	10800243 	ldbu	r2,9(r2)
   1f0d8:	10803fcc 	andi	r2,r2,255
   1f0dc:	10800458 	cmpnei	r2,r2,17
   1f0e0:	10000f1e 	bne	r2,zero,1f120 <ip_input+0x35c>
      struct udp_hdr *udphdr = (struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen);
   1f0e4:	e0bffc0b 	ldhu	r2,-16(fp)
   1f0e8:	e0fff817 	ldw	r3,-32(fp)
   1f0ec:	1885883a 	add	r2,r3,r2
   1f0f0:	e0bffd15 	stw	r2,-12(fp)
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(udphdr->dest)));
      if (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr->dest)) {
   1f0f4:	e0bffd17 	ldw	r2,-12(fp)
   1f0f8:	10c00083 	ldbu	r3,2(r2)
   1f0fc:	108000c3 	ldbu	r2,3(r2)
   1f100:	1004923a 	slli	r2,r2,8
   1f104:	10c4b03a 	or	r2,r2,r3
   1f108:	10bfffcc 	andi	r2,r2,65535
   1f10c:	10910018 	cmpnei	r2,r2,17408
   1f110:	1000031e 	bne	r2,zero,1f120 <ip_input+0x35c>
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: DHCP packet accepted.\n"));
        netif = inp;
   1f114:	e0bfff17 	ldw	r2,-4(fp)
   1f118:	e0bff915 	stw	r2,-28(fp)
        check_ip_src = 0;
   1f11c:	e03ffa15 	stw	zero,-24(fp)
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
  if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
   1f120:	e0bffa17 	ldw	r2,-24(fp)
   1f124:	10001726 	beq	r2,zero,1f184 <ip_input+0x3c0>
   1f128:	d0a92617 	ldw	r2,-23400(gp)
   1f12c:	10001526 	beq	r2,zero,1f184 <ip_input+0x3c0>
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
  {  if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) ||
   1f130:	d0a92617 	ldw	r2,-23400(gp)
   1f134:	1009883a 	mov	r4,r2
   1f138:	e17fff17 	ldw	r5,-4(fp)
   1f13c:	001fa400 	call	1fa40 <ip4_addr_isbroadcast>
   1f140:	10803fcc 	andi	r2,r2,255
   1f144:	1000041e 	bne	r2,zero,1f158 <ip_input+0x394>
         (ip_addr_ismulticast(&current_iphdr_src))) {
   1f148:	d0a92617 	ldw	r2,-23400(gp)
   1f14c:	10803c0c 	andi	r2,r2,240
  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
  if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
  {  if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) ||
   1f150:	10803818 	cmpnei	r2,r2,224
   1f154:	10000b1e 	bne	r2,zero,1f184 <ip_input+0x3c0>
         (ip_addr_ismulticast(&current_iphdr_src))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
   1f158:	e13ffe17 	ldw	r4,-8(fp)
   1f15c:	00237600 	call	23760 <pbuf_free>
      IP_STATS_INC(ip.drop);
   1f160:	008001f4 	movhi	r2,7
   1f164:	10ac6e04 	addi	r2,r2,-20040
   1f168:	10802717 	ldw	r2,156(r2)
   1f16c:	10c00044 	addi	r3,r2,1
   1f170:	008001f4 	movhi	r2,7
   1f174:	10ac6e04 	addi	r2,r2,-20040
   1f178:	10c02715 	stw	r3,156(r2)
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
   1f17c:	0005883a 	mov	r2,zero
   1f180:	00005c06 	br	1f2f4 <ip_input+0x530>
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
   1f184:	e0bff917 	ldw	r2,-28(fp)
   1f188:	1000041e 	bne	r2,zero,1f19c <ip_input+0x3d8>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
   1f18c:	e13ffe17 	ldw	r4,-8(fp)
   1f190:	00237600 	call	23760 <pbuf_free>
    return ERR_OK;
   1f194:	0005883a 	mov	r2,zero
   1f198:	00005606 	br	1f2f4 <ip_input+0x530>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
   1f19c:	e0bff817 	ldw	r2,-32(fp)
   1f1a0:	10c00183 	ldbu	r3,6(r2)
   1f1a4:	108001c3 	ldbu	r2,7(r2)
   1f1a8:	1004923a 	slli	r2,r2,8
   1f1ac:	10c4b03a 	or	r2,r2,r3
   1f1b0:	10bfffcc 	andi	r2,r2,65535
   1f1b4:	10bfcfcc 	andi	r2,r2,65343
   1f1b8:	10000a26 	beq	r2,zero,1f1e4 <ip_input+0x420>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & PP_HTONS(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
   1f1bc:	e13ffe17 	ldw	r4,-8(fp)
   1f1c0:	0020d7c0 	call	20d7c <ip_reass>
   1f1c4:	e0bffe15 	stw	r2,-8(fp)
    /* packet not fully reassembled yet? */
    if (p == NULL) {
   1f1c8:	e0bffe17 	ldw	r2,-8(fp)
   1f1cc:	1000021e 	bne	r2,zero,1f1d8 <ip_input+0x414>
      return ERR_OK;
   1f1d0:	0005883a 	mov	r2,zero
   1f1d4:	00004706 	br	1f2f4 <ip_input+0x530>
    }
    iphdr = (struct ip_hdr *)p->payload;
   1f1d8:	e0bffe17 	ldw	r2,-8(fp)
   1f1dc:	10800117 	ldw	r2,4(r2)
   1f1e0:	e0bff815 	stw	r2,-32(fp)
  /* send to upper layers */
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: \n"));
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

  current_netif = inp;
   1f1e4:	e0bfff17 	ldw	r2,-4(fp)
   1f1e8:	d0a92715 	stw	r2,-23396(gp)
  current_header = iphdr;
   1f1ec:	e0bff817 	ldw	r2,-32(fp)
   1f1f0:	d0a92915 	stw	r2,-23388(gp)

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
   1f1f4:	e13ffe17 	ldw	r4,-8(fp)
   1f1f8:	e17fff17 	ldw	r5,-4(fp)
   1f1fc:	002451c0 	call	2451c <raw_input>
   1f200:	10803fcc 	andi	r2,r2,255
   1f204:	1000361e 	bne	r2,zero,1f2e0 <ip_input+0x51c>
#endif /* LWIP_RAW */
  {
    switch (IPH_PROTO(iphdr)) {
   1f208:	e0bff817 	ldw	r2,-32(fp)
   1f20c:	10800243 	ldbu	r2,9(r2)
   1f210:	10803fcc 	andi	r2,r2,255
   1f214:	10c001a0 	cmpeqi	r3,r2,6
   1f218:	1800091e 	bne	r3,zero,1f240 <ip_input+0x47c>
   1f21c:	10c00460 	cmpeqi	r3,r2,17
   1f220:	1800031e 	bne	r3,zero,1f230 <ip_input+0x46c>
   1f224:	10800060 	cmpeqi	r2,r2,1
   1f228:	1000091e 	bne	r2,zero,1f250 <ip_input+0x48c>
   1f22c:	00000c06 	br	1f260 <ip_input+0x49c>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
   1f230:	e13ffe17 	ldw	r4,-8(fp)
   1f234:	e17fff17 	ldw	r5,-4(fp)
   1f238:	002ece40 	call	2ece4 <udp_input>
      break;
   1f23c:	00002806 	br	1f2e0 <ip_input+0x51c>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
   1f240:	e13ffe17 	ldw	r4,-8(fp)
   1f244:	e17fff17 	ldw	r5,-4(fp)
   1f248:	0026e980 	call	26e98 <tcp_input>
      break;
   1f24c:	00002406 	br	1f2e0 <ip_input+0x51c>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
   1f250:	e13ffe17 	ldw	r4,-8(fp)
   1f254:	e17fff17 	ldw	r5,-4(fp)
   1f258:	003d8640 	call	3d864 <icmp_input>
      break;
   1f25c:	00002006 	br	1f2e0 <ip_input+0x51c>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) &&
   1f260:	d0a92817 	ldw	r2,-23392(gp)
   1f264:	1009883a 	mov	r4,r2
   1f268:	e17fff17 	ldw	r5,-4(fp)
   1f26c:	001fa400 	call	1fa40 <ip4_addr_isbroadcast>
   1f270:	10803fcc 	andi	r2,r2,255
   1f274:	10000a1e 	bne	r2,zero,1f2a0 <ip_input+0x4dc>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
   1f278:	d0a92817 	ldw	r2,-23392(gp)
   1f27c:	10803c0c 	andi	r2,r2,240
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) &&
   1f280:	10803820 	cmpeqi	r2,r2,224
   1f284:	1000061e 	bne	r2,zero,1f2a0 <ip_input+0x4dc>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
        p->payload = iphdr;
   1f288:	e0bffe17 	ldw	r2,-8(fp)
   1f28c:	e0fff817 	ldw	r3,-32(fp)
   1f290:	10c00115 	stw	r3,4(r2)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
   1f294:	e13ffe17 	ldw	r4,-8(fp)
   1f298:	01400084 	movi	r5,2
   1f29c:	003de140 	call	3de14 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
   1f2a0:	e13ffe17 	ldw	r4,-8(fp)
   1f2a4:	00237600 	call	23760 <pbuf_free>

      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Unsupported transport protocol %"U16_F"\n", IPH_PROTO(iphdr)));

      IP_STATS_INC(ip.proterr);
   1f2a8:	008001f4 	movhi	r2,7
   1f2ac:	10ac6e04 	addi	r2,r2,-20040
   1f2b0:	10802c17 	ldw	r2,176(r2)
   1f2b4:	10c00044 	addi	r3,r2,1
   1f2b8:	008001f4 	movhi	r2,7
   1f2bc:	10ac6e04 	addi	r2,r2,-20040
   1f2c0:	10c02c15 	stw	r3,176(r2)
      IP_STATS_INC(ip.drop);
   1f2c4:	008001f4 	movhi	r2,7
   1f2c8:	10ac6e04 	addi	r2,r2,-20040
   1f2cc:	10802717 	ldw	r2,156(r2)
   1f2d0:	10c00044 	addi	r3,r2,1
   1f2d4:	008001f4 	movhi	r2,7
   1f2d8:	10ac6e04 	addi	r2,r2,-20040
   1f2dc:	10c02715 	stw	r3,156(r2)
      snmp_inc_ipinunknownprotos();
    }
  }

  current_netif = NULL;
   1f2e0:	d0292715 	stw	zero,-23396(gp)
  current_header = NULL;
   1f2e4:	d0292915 	stw	zero,-23388(gp)
  ip_addr_set_any(&current_iphdr_src);
   1f2e8:	d0292615 	stw	zero,-23400(gp)
  ip_addr_set_any(&current_iphdr_dest);
   1f2ec:	d0292815 	stw	zero,-23392(gp)

  return ERR_OK;
   1f2f0:	0005883a 	mov	r2,zero
}
   1f2f4:	e037883a 	mov	sp,fp
   1f2f8:	dfc00117 	ldw	ra,4(sp)
   1f2fc:	df000017 	ldw	fp,0(sp)
   1f300:	dec00204 	addi	sp,sp,8
   1f304:	f800283a 	ret

0001f308 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
   1f308:	defff404 	addi	sp,sp,-48
   1f30c:	dfc00b15 	stw	ra,44(sp)
   1f310:	df000a15 	stw	fp,40(sp)
   1f314:	df000a04 	addi	fp,sp,40
   1f318:	e13ffa15 	stw	r4,-24(fp)
   1f31c:	e17ffb15 	stw	r5,-20(fp)
   1f320:	e1bffc15 	stw	r6,-16(fp)
   1f324:	3805883a 	mov	r2,r7
   1f328:	e1000217 	ldw	r4,8(fp)
   1f32c:	e0c00317 	ldw	r3,12(fp)
   1f330:	e0bffd05 	stb	r2,-12(fp)
   1f334:	e13ffe05 	stb	r4,-8(fp)
   1f338:	e0ffff05 	stb	r3,-4(fp)
{
#endif /* IP_OPTIONS_SEND */
  struct ip_hdr *iphdr;
  ip_addr_t dest_addr;
#if CHECKSUM_GEN_IP_INLINE
  u32_t chk_sum = 0;
   1f33c:	e03ff615 	stw	zero,-40(fp)
  LWIP_ASSERT("p->ref == 1", p->ref == 1);

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
   1f340:	e0bffc17 	ldw	r2,-16(fp)
   1f344:	10012a26 	beq	r2,zero,1f7f0 <ip_output_if+0x4e8>
    u16_t ip_hlen = IP_HLEN;
   1f348:	00800504 	movi	r2,20
   1f34c:	e0bff70d 	sth	r2,-36(fp)
      }
#endif /* CHECKSUM_GEN_IP_INLINE */
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
   1f350:	e13ffa17 	ldw	r4,-24(fp)
   1f354:	01400504 	movi	r5,20
   1f358:	00235b00 	call	235b0 <pbuf_header>
   1f35c:	10803fcc 	andi	r2,r2,255
   1f360:	10000926 	beq	r2,zero,1f388 <ip_output_if+0x80>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
   1f364:	008001f4 	movhi	r2,7
   1f368:	10ac6e04 	addi	r2,r2,-20040
   1f36c:	10802e17 	ldw	r2,184(r2)
   1f370:	10c00044 	addi	r3,r2,1
   1f374:	008001f4 	movhi	r2,7
   1f378:	10ac6e04 	addi	r2,r2,-20040
   1f37c:	10c02e15 	stw	r3,184(r2)
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
   1f380:	00bfff84 	movi	r2,-2
   1f384:	00014806 	br	1f8a8 <ip_output_if+0x5a0>
    }

    iphdr = (struct ip_hdr *)p->payload;
   1f388:	e0bffa17 	ldw	r2,-24(fp)
   1f38c:	10800117 	ldw	r2,4(r2)
   1f390:	e0bff815 	stw	r2,-32(fp)
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
   1f394:	e0bff817 	ldw	r2,-32(fp)
   1f398:	e0fffd03 	ldbu	r3,-12(fp)
   1f39c:	10c00205 	stb	r3,8(r2)
    IPH_PROTO_SET(iphdr, proto);
   1f3a0:	e0bff817 	ldw	r2,-32(fp)
   1f3a4:	e0ffff03 	ldbu	r3,-4(fp)
   1f3a8:	10c00245 	stb	r3,9(r2)
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(proto, ttl);
   1f3ac:	e0bfff03 	ldbu	r2,-4(fp)
   1f3b0:	1006923a 	slli	r3,r2,8
   1f3b4:	e0bffd03 	ldbu	r2,-12(fp)
   1f3b8:	1884b03a 	or	r2,r3,r2
   1f3bc:	e0fff617 	ldw	r3,-40(fp)
   1f3c0:	1885883a 	add	r2,r3,r2
   1f3c4:	e0bff615 	stw	r2,-40(fp)
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip_addr_copy(iphdr->dest, *dest);
   1f3c8:	e0bffc17 	ldw	r2,-16(fp)
   1f3cc:	10c00017 	ldw	r3,0(r2)
   1f3d0:	e0bff817 	ldw	r2,-32(fp)
   1f3d4:	19003fcc 	andi	r4,r3,255
   1f3d8:	11400403 	ldbu	r5,16(r2)
   1f3dc:	280a703a 	and	r5,r5,zero
   1f3e0:	2908b03a 	or	r4,r5,r4
   1f3e4:	11000405 	stb	r4,16(r2)
   1f3e8:	1808d23a 	srli	r4,r3,8
   1f3ec:	21003fcc 	andi	r4,r4,255
   1f3f0:	11400443 	ldbu	r5,17(r2)
   1f3f4:	280a703a 	and	r5,r5,zero
   1f3f8:	2908b03a 	or	r4,r5,r4
   1f3fc:	11000445 	stb	r4,17(r2)
   1f400:	1808d43a 	srli	r4,r3,16
   1f404:	21003fcc 	andi	r4,r4,255
   1f408:	11400483 	ldbu	r5,18(r2)
   1f40c:	280a703a 	and	r5,r5,zero
   1f410:	2908b03a 	or	r4,r5,r4
   1f414:	11000485 	stb	r4,18(r2)
   1f418:	1806d63a 	srli	r3,r3,24
   1f41c:	110004c3 	ldbu	r4,19(r2)
   1f420:	2008703a 	and	r4,r4,zero
   1f424:	20c6b03a 	or	r3,r4,r3
   1f428:	10c004c5 	stb	r3,19(r2)
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
   1f42c:	e0bff817 	ldw	r2,-32(fp)
   1f430:	10c00403 	ldbu	r3,16(r2)
   1f434:	11000443 	ldbu	r4,17(r2)
   1f438:	2008923a 	slli	r4,r4,8
   1f43c:	20c6b03a 	or	r3,r4,r3
   1f440:	11000483 	ldbu	r4,18(r2)
   1f444:	2008943a 	slli	r4,r4,16
   1f448:	20c6b03a 	or	r3,r4,r3
   1f44c:	108004c3 	ldbu	r2,19(r2)
   1f450:	1004963a 	slli	r2,r2,24
   1f454:	10c4b03a 	or	r2,r2,r3
   1f458:	10bfffcc 	andi	r2,r2,65535
   1f45c:	e0fff617 	ldw	r3,-40(fp)
   1f460:	1885883a 	add	r2,r3,r2
   1f464:	e0bff615 	stw	r2,-40(fp)
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
   1f468:	e0bff817 	ldw	r2,-32(fp)
   1f46c:	10c00403 	ldbu	r3,16(r2)
   1f470:	11000443 	ldbu	r4,17(r2)
   1f474:	2008923a 	slli	r4,r4,8
   1f478:	20c6b03a 	or	r3,r4,r3
   1f47c:	11000483 	ldbu	r4,18(r2)
   1f480:	2008943a 	slli	r4,r4,16
   1f484:	20c6b03a 	or	r3,r4,r3
   1f488:	108004c3 	ldbu	r2,19(r2)
   1f48c:	1004963a 	slli	r2,r2,24
   1f490:	10c4b03a 	or	r2,r2,r3
   1f494:	1004d43a 	srli	r2,r2,16
   1f498:	e0fff617 	ldw	r3,-40(fp)
   1f49c:	1885883a 	add	r2,r3,r2
   1f4a0:	e0bff615 	stw	r2,-40(fp)
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
   1f4a4:	e0bff70b 	ldhu	r2,-36(fp)
   1f4a8:	1004d0ba 	srli	r2,r2,2
   1f4ac:	10801014 	ori	r2,r2,64
   1f4b0:	1007883a 	mov	r3,r2
   1f4b4:	e0bff817 	ldw	r2,-32(fp)
   1f4b8:	10c00005 	stb	r3,0(r2)
    IPH_TOS_SET(iphdr, tos);
   1f4bc:	e0bff817 	ldw	r2,-32(fp)
   1f4c0:	e0fffe03 	ldbu	r3,-8(fp)
   1f4c4:	10c00045 	stb	r3,1(r2)
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
   1f4c8:	e0bffe03 	ldbu	r2,-8(fp)
   1f4cc:	1006923a 	slli	r3,r2,8
   1f4d0:	e0bff817 	ldw	r2,-32(fp)
   1f4d4:	10800003 	ldbu	r2,0(r2)
   1f4d8:	10803fcc 	andi	r2,r2,255
   1f4dc:	1884b03a 	or	r2,r3,r2
   1f4e0:	e0fff617 	ldw	r3,-40(fp)
   1f4e4:	1885883a 	add	r2,r3,r2
   1f4e8:	e0bff615 	stw	r2,-40(fp)
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, htons(p->tot_len));
   1f4ec:	e0bffa17 	ldw	r2,-24(fp)
   1f4f0:	1080020b 	ldhu	r2,8(r2)
   1f4f4:	10bfffcc 	andi	r2,r2,65535
   1f4f8:	1004d23a 	srli	r2,r2,8
   1f4fc:	1007883a 	mov	r3,r2
   1f500:	e0bffa17 	ldw	r2,-24(fp)
   1f504:	1080020b 	ldhu	r2,8(r2)
   1f508:	10bfffcc 	andi	r2,r2,65535
   1f50c:	1004923a 	slli	r2,r2,8
   1f510:	1884b03a 	or	r2,r3,r2
   1f514:	1007883a 	mov	r3,r2
   1f518:	e0bff817 	ldw	r2,-32(fp)
   1f51c:	193fffcc 	andi	r4,r3,65535
   1f520:	21003fcc 	andi	r4,r4,255
   1f524:	11400083 	ldbu	r5,2(r2)
   1f528:	280a703a 	and	r5,r5,zero
   1f52c:	2908b03a 	or	r4,r5,r4
   1f530:	11000085 	stb	r4,2(r2)
   1f534:	18ffffcc 	andi	r3,r3,65535
   1f538:	1806d23a 	srli	r3,r3,8
   1f53c:	18ffffcc 	andi	r3,r3,65535
   1f540:	110000c3 	ldbu	r4,3(r2)
   1f544:	2008703a 	and	r4,r4,zero
   1f548:	20c6b03a 	or	r3,r4,r3
   1f54c:	10c000c5 	stb	r3,3(r2)
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
   1f550:	e0bff817 	ldw	r2,-32(fp)
   1f554:	10c00083 	ldbu	r3,2(r2)
   1f558:	108000c3 	ldbu	r2,3(r2)
   1f55c:	1004923a 	slli	r2,r2,8
   1f560:	10c4b03a 	or	r2,r2,r3
   1f564:	10bfffcc 	andi	r2,r2,65535
   1f568:	e0fff617 	ldw	r3,-40(fp)
   1f56c:	1885883a 	add	r2,r3,r2
   1f570:	e0bff615 	stw	r2,-40(fp)
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
   1f574:	e0bff817 	ldw	r2,-32(fp)
   1f578:	10c00183 	ldbu	r3,6(r2)
   1f57c:	1806703a 	and	r3,r3,zero
   1f580:	10c00185 	stb	r3,6(r2)
   1f584:	10c001c3 	ldbu	r3,7(r2)
   1f588:	1806703a 	and	r3,r3,zero
   1f58c:	10c001c5 	stb	r3,7(r2)
    IPH_ID_SET(iphdr, htons(ip_id));
   1f590:	d0a9250b 	ldhu	r2,-23404(gp)
   1f594:	10bfffcc 	andi	r2,r2,65535
   1f598:	1004d23a 	srli	r2,r2,8
   1f59c:	1007883a 	mov	r3,r2
   1f5a0:	d0a9250b 	ldhu	r2,-23404(gp)
   1f5a4:	10bfffcc 	andi	r2,r2,65535
   1f5a8:	1004923a 	slli	r2,r2,8
   1f5ac:	1884b03a 	or	r2,r3,r2
   1f5b0:	1007883a 	mov	r3,r2
   1f5b4:	e0bff817 	ldw	r2,-32(fp)
   1f5b8:	193fffcc 	andi	r4,r3,65535
   1f5bc:	21003fcc 	andi	r4,r4,255
   1f5c0:	11400103 	ldbu	r5,4(r2)
   1f5c4:	280a703a 	and	r5,r5,zero
   1f5c8:	2908b03a 	or	r4,r5,r4
   1f5cc:	11000105 	stb	r4,4(r2)
   1f5d0:	18ffffcc 	andi	r3,r3,65535
   1f5d4:	1806d23a 	srli	r3,r3,8
   1f5d8:	18ffffcc 	andi	r3,r3,65535
   1f5dc:	11000143 	ldbu	r4,5(r2)
   1f5e0:	2008703a 	and	r4,r4,zero
   1f5e4:	20c6b03a 	or	r3,r4,r3
   1f5e8:	10c00145 	stb	r3,5(r2)
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
   1f5ec:	e0bff817 	ldw	r2,-32(fp)
   1f5f0:	10c00103 	ldbu	r3,4(r2)
   1f5f4:	10800143 	ldbu	r2,5(r2)
   1f5f8:	1004923a 	slli	r2,r2,8
   1f5fc:	10c4b03a 	or	r2,r2,r3
   1f600:	10bfffcc 	andi	r2,r2,65535
   1f604:	e0fff617 	ldw	r3,-40(fp)
   1f608:	1885883a 	add	r2,r3,r2
   1f60c:	e0bff615 	stw	r2,-40(fp)
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
   1f610:	d0a9250b 	ldhu	r2,-23404(gp)
   1f614:	10800044 	addi	r2,r2,1
   1f618:	d0a9250d 	sth	r2,-23404(gp)

    if (ip_addr_isany(src)) {
   1f61c:	e0bffb17 	ldw	r2,-20(fp)
   1f620:	10000326 	beq	r2,zero,1f630 <ip_output_if+0x328>
   1f624:	e0bffb17 	ldw	r2,-20(fp)
   1f628:	10800017 	ldw	r2,0(r2)
   1f62c:	10001a1e 	bne	r2,zero,1f698 <ip_output_if+0x390>
      ip_addr_copy(iphdr->src, netif->ip_addr);
   1f630:	e0800417 	ldw	r2,16(fp)
   1f634:	10c00117 	ldw	r3,4(r2)
   1f638:	e0bff817 	ldw	r2,-32(fp)
   1f63c:	19003fcc 	andi	r4,r3,255
   1f640:	11400303 	ldbu	r5,12(r2)
   1f644:	280a703a 	and	r5,r5,zero
   1f648:	2908b03a 	or	r4,r5,r4
   1f64c:	11000305 	stb	r4,12(r2)
   1f650:	1808d23a 	srli	r4,r3,8
   1f654:	21003fcc 	andi	r4,r4,255
   1f658:	11400343 	ldbu	r5,13(r2)
   1f65c:	280a703a 	and	r5,r5,zero
   1f660:	2908b03a 	or	r4,r5,r4
   1f664:	11000345 	stb	r4,13(r2)
   1f668:	1808d43a 	srli	r4,r3,16
   1f66c:	21003fcc 	andi	r4,r4,255
   1f670:	11400383 	ldbu	r5,14(r2)
   1f674:	280a703a 	and	r5,r5,zero
   1f678:	2908b03a 	or	r4,r5,r4
   1f67c:	11000385 	stb	r4,14(r2)
   1f680:	1806d63a 	srli	r3,r3,24
   1f684:	110003c3 	ldbu	r4,15(r2)
   1f688:	2008703a 	and	r4,r4,zero
   1f68c:	20c6b03a 	or	r3,r4,r3
   1f690:	10c003c5 	stb	r3,15(r2)
   1f694:	00001906 	br	1f6fc <ip_output_if+0x3f4>
    } else {
      /* src cannot be NULL here */
      ip_addr_copy(iphdr->src, *src);
   1f698:	e0bffb17 	ldw	r2,-20(fp)
   1f69c:	10c00017 	ldw	r3,0(r2)
   1f6a0:	e0bff817 	ldw	r2,-32(fp)
   1f6a4:	19003fcc 	andi	r4,r3,255
   1f6a8:	11400303 	ldbu	r5,12(r2)
   1f6ac:	280a703a 	and	r5,r5,zero
   1f6b0:	2908b03a 	or	r4,r5,r4
   1f6b4:	11000305 	stb	r4,12(r2)
   1f6b8:	1808d23a 	srli	r4,r3,8
   1f6bc:	21003fcc 	andi	r4,r4,255
   1f6c0:	11400343 	ldbu	r5,13(r2)
   1f6c4:	280a703a 	and	r5,r5,zero
   1f6c8:	2908b03a 	or	r4,r5,r4
   1f6cc:	11000345 	stb	r4,13(r2)
   1f6d0:	1808d43a 	srli	r4,r3,16
   1f6d4:	21003fcc 	andi	r4,r4,255
   1f6d8:	11400383 	ldbu	r5,14(r2)
   1f6dc:	280a703a 	and	r5,r5,zero
   1f6e0:	2908b03a 	or	r4,r5,r4
   1f6e4:	11000385 	stb	r4,14(r2)
   1f6e8:	1806d63a 	srli	r3,r3,24
   1f6ec:	110003c3 	ldbu	r4,15(r2)
   1f6f0:	2008703a 	and	r4,r4,zero
   1f6f4:	20c6b03a 	or	r3,r4,r3
   1f6f8:	10c003c5 	stb	r3,15(r2)
    }

#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
   1f6fc:	e0bff817 	ldw	r2,-32(fp)
   1f700:	10c00303 	ldbu	r3,12(r2)
   1f704:	11000343 	ldbu	r4,13(r2)
   1f708:	2008923a 	slli	r4,r4,8
   1f70c:	20c6b03a 	or	r3,r4,r3
   1f710:	11000383 	ldbu	r4,14(r2)
   1f714:	2008943a 	slli	r4,r4,16
   1f718:	20c6b03a 	or	r3,r4,r3
   1f71c:	108003c3 	ldbu	r2,15(r2)
   1f720:	1004963a 	slli	r2,r2,24
   1f724:	10c4b03a 	or	r2,r2,r3
   1f728:	10bfffcc 	andi	r2,r2,65535
   1f72c:	e0fff617 	ldw	r3,-40(fp)
   1f730:	1885883a 	add	r2,r3,r2
   1f734:	e0bff615 	stw	r2,-40(fp)
    chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
   1f738:	e0bff817 	ldw	r2,-32(fp)
   1f73c:	10c00303 	ldbu	r3,12(r2)
   1f740:	11000343 	ldbu	r4,13(r2)
   1f744:	2008923a 	slli	r4,r4,8
   1f748:	20c6b03a 	or	r3,r4,r3
   1f74c:	11000383 	ldbu	r4,14(r2)
   1f750:	2008943a 	slli	r4,r4,16
   1f754:	20c6b03a 	or	r3,r4,r3
   1f758:	108003c3 	ldbu	r2,15(r2)
   1f75c:	1004963a 	slli	r2,r2,24
   1f760:	10c4b03a 	or	r2,r2,r3
   1f764:	1004d43a 	srli	r2,r2,16
   1f768:	e0fff617 	ldw	r3,-40(fp)
   1f76c:	1885883a 	add	r2,r3,r2
   1f770:	e0bff615 	stw	r2,-40(fp)
    chk_sum = (chk_sum >> 16) + (chk_sum & 0xFFFF);
   1f774:	e0bff617 	ldw	r2,-40(fp)
   1f778:	1006d43a 	srli	r3,r2,16
   1f77c:	e0bff617 	ldw	r2,-40(fp)
   1f780:	10bfffcc 	andi	r2,r2,65535
   1f784:	1885883a 	add	r2,r3,r2
   1f788:	e0bff615 	stw	r2,-40(fp)
    chk_sum = (chk_sum >> 16) + chk_sum;
   1f78c:	e0bff617 	ldw	r2,-40(fp)
   1f790:	1004d43a 	srli	r2,r2,16
   1f794:	e0fff617 	ldw	r3,-40(fp)
   1f798:	1885883a 	add	r2,r3,r2
   1f79c:	e0bff615 	stw	r2,-40(fp)
    chk_sum = ~chk_sum;
   1f7a0:	e0bff617 	ldw	r2,-40(fp)
   1f7a4:	0084303a 	nor	r2,zero,r2
   1f7a8:	e0bff615 	stw	r2,-40(fp)
    iphdr->_chksum = chk_sum; /* network order */
   1f7ac:	e0bff617 	ldw	r2,-40(fp)
   1f7b0:	1007883a 	mov	r3,r2
   1f7b4:	e0bff817 	ldw	r2,-32(fp)
   1f7b8:	193fffcc 	andi	r4,r3,65535
   1f7bc:	21003fcc 	andi	r4,r4,255
   1f7c0:	11400283 	ldbu	r5,10(r2)
   1f7c4:	280a703a 	and	r5,r5,zero
   1f7c8:	2908b03a 	or	r4,r5,r4
   1f7cc:	11000285 	stb	r4,10(r2)
   1f7d0:	18ffffcc 	andi	r3,r3,65535
   1f7d4:	1806d23a 	srli	r3,r3,8
   1f7d8:	18ffffcc 	andi	r3,r3,65535
   1f7dc:	110002c3 	ldbu	r4,11(r2)
   1f7e0:	2008703a 	and	r4,r4,zero
   1f7e4:	20c6b03a 	or	r3,r4,r3
   1f7e8:	10c002c5 	stb	r3,11(r2)
   1f7ec:	00001106 	br	1f834 <ip_output_if+0x52c>
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, ip_hlen));
#endif
#endif /* CHECKSUM_GEN_IP_INLINE */
  } else {
    /* IP header already included in p */
    iphdr = (struct ip_hdr *)p->payload;
   1f7f0:	e0bffa17 	ldw	r2,-24(fp)
   1f7f4:	10800117 	ldw	r2,4(r2)
   1f7f8:	e0bff815 	stw	r2,-32(fp)
    ip_addr_copy(dest_addr, iphdr->dest);
   1f7fc:	e0bff817 	ldw	r2,-32(fp)
   1f800:	10c00403 	ldbu	r3,16(r2)
   1f804:	11000443 	ldbu	r4,17(r2)
   1f808:	2008923a 	slli	r4,r4,8
   1f80c:	20c6b03a 	or	r3,r4,r3
   1f810:	11000483 	ldbu	r4,18(r2)
   1f814:	2008943a 	slli	r4,r4,16
   1f818:	20c6b03a 	or	r3,r4,r3
   1f81c:	108004c3 	ldbu	r2,19(r2)
   1f820:	1004963a 	slli	r2,r2,24
   1f824:	10c4b03a 	or	r2,r2,r3
   1f828:	e0bff915 	stw	r2,-28(fp)
    dest = &dest_addr;
   1f82c:	e0bff904 	addi	r2,fp,-28
   1f830:	e0bffc15 	stw	r2,-16(fp)
  }

  IP_STATS_INC(ip.xmit);
   1f834:	008001f4 	movhi	r2,7
   1f838:	10ac6e04 	addi	r2,r2,-20040
   1f83c:	10802417 	ldw	r2,144(r2)
   1f840:	10c00044 	addi	r3,r2,1
   1f844:	008001f4 	movhi	r2,7
   1f848:	10ac6e04 	addi	r2,r2,-20040
   1f84c:	10c02415 	stw	r3,144(r2)
  }
#endif /* LWIP_IGMP */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
   1f850:	e0800417 	ldw	r2,16(fp)
   1f854:	10800c0b 	ldhu	r2,48(r2)
   1f858:	10bfffcc 	andi	r2,r2,65535
   1f85c:	10000c26 	beq	r2,zero,1f890 <ip_output_if+0x588>
   1f860:	e0bffa17 	ldw	r2,-24(fp)
   1f864:	1080020b 	ldhu	r2,8(r2)
   1f868:	e0c00417 	ldw	r3,16(fp)
   1f86c:	18c00c0b 	ldhu	r3,48(r3)
   1f870:	10bfffcc 	andi	r2,r2,65535
   1f874:	18ffffcc 	andi	r3,r3,65535
   1f878:	1880052e 	bgeu	r3,r2,1f890 <ip_output_if+0x588>
    return ip_frag(p, netif, dest);
   1f87c:	e13ffa17 	ldw	r4,-24(fp)
   1f880:	e1400417 	ldw	r5,16(fp)
   1f884:	e1bffc17 	ldw	r6,-16(fp)
   1f888:	00214200 	call	21420 <ip_frag>
   1f88c:	00000606 	br	1f8a8 <ip_output_if+0x5a0>
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
  return netif->output(netif, p, dest);
   1f890:	e0800417 	ldw	r2,16(fp)
   1f894:	10800517 	ldw	r2,20(r2)
   1f898:	e1000417 	ldw	r4,16(fp)
   1f89c:	e17ffa17 	ldw	r5,-24(fp)
   1f8a0:	e1bffc17 	ldw	r6,-16(fp)
   1f8a4:	103ee83a 	callr	r2
}
   1f8a8:	e037883a 	mov	sp,fp
   1f8ac:	dfc00117 	ldw	ra,4(sp)
   1f8b0:	df000017 	ldw	fp,0(sp)
   1f8b4:	dec00204 	addi	sp,sp,8
   1f8b8:	f800283a 	ret

0001f8bc <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
   1f8bc:	defff404 	addi	sp,sp,-48
   1f8c0:	dfc00b15 	stw	ra,44(sp)
   1f8c4:	df000a15 	stw	fp,40(sp)
   1f8c8:	df000a04 	addi	fp,sp,40
   1f8cc:	e13ffa15 	stw	r4,-24(fp)
   1f8d0:	e17ffb15 	stw	r5,-20(fp)
   1f8d4:	e1bffc15 	stw	r6,-16(fp)
   1f8d8:	3805883a 	mov	r2,r7
   1f8dc:	e1000217 	ldw	r4,8(fp)
   1f8e0:	e0c00317 	ldw	r3,12(fp)
   1f8e4:	e0bffd05 	stb	r2,-12(fp)
   1f8e8:	e13ffe05 	stb	r4,-8(fp)
   1f8ec:	e0ffff05 	stb	r3,-4(fp)

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);

  if ((netif = ip_route(src, dest)) == NULL) {
   1f8f0:	e13ffb17 	ldw	r4,-20(fp)
   1f8f4:	e17ffc17 	ldw	r5,-16(fp)
   1f8f8:	001ecb40 	call	1ecb4 <ip_route>
   1f8fc:	e0bff915 	stw	r2,-28(fp)
   1f900:	e0bff917 	ldw	r2,-28(fp)
   1f904:	1000091e 	bne	r2,zero,1f92c <ip_output+0x70>
    LWIP_DEBUGF(IP_DEBUG, ("ip_output: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
   1f908:	008001f4 	movhi	r2,7
   1f90c:	10ac6e04 	addi	r2,r2,-20040
   1f910:	10802b17 	ldw	r2,172(r2)
   1f914:	10c00044 	addi	r3,r2,1
   1f918:	008001f4 	movhi	r2,7
   1f91c:	10ac6e04 	addi	r2,r2,-20040
   1f920:	10c02b15 	stw	r3,172(r2)
    return ERR_RTE;
   1f924:	00bfff04 	movi	r2,-4
   1f928:	00000c06 	br	1f95c <ip_output+0xa0>
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
   1f92c:	e0bffd03 	ldbu	r2,-12(fp)
   1f930:	e13ffe03 	ldbu	r4,-8(fp)
   1f934:	e0ffff03 	ldbu	r3,-4(fp)
   1f938:	d9000015 	stw	r4,0(sp)
   1f93c:	d8c00115 	stw	r3,4(sp)
   1f940:	e0fff917 	ldw	r3,-28(fp)
   1f944:	d8c00215 	stw	r3,8(sp)
   1f948:	e13ffa17 	ldw	r4,-24(fp)
   1f94c:	e17ffb17 	ldw	r5,-20(fp)
   1f950:	e1bffc17 	ldw	r6,-16(fp)
   1f954:	100f883a 	mov	r7,r2
   1f958:	001f3080 	call	1f308 <ip_output_if>
}
   1f95c:	e037883a 	mov	sp,fp
   1f960:	dfc00117 	ldw	ra,4(sp)
   1f964:	df000017 	ldw	fp,0(sp)
   1f968:	dec00204 	addi	sp,sp,8
   1f96c:	f800283a 	ret

0001f970 <ip_output_hinted>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output_hinted(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
          u8_t ttl, u8_t tos, u8_t proto, u8_t *addr_hint)
{
   1f970:	defff304 	addi	sp,sp,-52
   1f974:	dfc00c15 	stw	ra,48(sp)
   1f978:	df000b15 	stw	fp,44(sp)
   1f97c:	df000b04 	addi	fp,sp,44
   1f980:	e13ffa15 	stw	r4,-24(fp)
   1f984:	e17ffb15 	stw	r5,-20(fp)
   1f988:	e1bffc15 	stw	r6,-16(fp)
   1f98c:	3805883a 	mov	r2,r7
   1f990:	e1000217 	ldw	r4,8(fp)
   1f994:	e0c00317 	ldw	r3,12(fp)
   1f998:	e0bffd05 	stb	r2,-12(fp)
   1f99c:	e13ffe05 	stb	r4,-8(fp)
   1f9a0:	e0ffff05 	stb	r3,-4(fp)

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);

  if ((netif = ip_route(src, dest)) == NULL) {
   1f9a4:	e13ffb17 	ldw	r4,-20(fp)
   1f9a8:	e17ffc17 	ldw	r5,-16(fp)
   1f9ac:	001ecb40 	call	1ecb4 <ip_route>
   1f9b0:	e0bff815 	stw	r2,-32(fp)
   1f9b4:	e0bff817 	ldw	r2,-32(fp)
   1f9b8:	1000091e 	bne	r2,zero,1f9e0 <ip_output_hinted+0x70>
    LWIP_DEBUGF(IP_DEBUG, ("ip_output: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
   1f9bc:	008001f4 	movhi	r2,7
   1f9c0:	10ac6e04 	addi	r2,r2,-20040
   1f9c4:	10802b17 	ldw	r2,172(r2)
   1f9c8:	10c00044 	addi	r3,r2,1
   1f9cc:	008001f4 	movhi	r2,7
   1f9d0:	10ac6e04 	addi	r2,r2,-20040
   1f9d4:	10c02b15 	stw	r3,172(r2)
    return ERR_RTE;
   1f9d8:	00bfff04 	movi	r2,-4
   1f9dc:	00001306 	br	1fa2c <ip_output_hinted+0xbc>
  }


  NETIF_SET_HWADDRHINT(netif, addr_hint);
   1f9e0:	e0bff817 	ldw	r2,-32(fp)
   1f9e4:	e0c00417 	ldw	r3,16(fp)
   1f9e8:	10c01015 	stw	r3,64(r2)
  err = ip_output_if(p, src, dest, ttl, tos, proto, netif);
   1f9ec:	e0bffd03 	ldbu	r2,-12(fp)
   1f9f0:	e13ffe03 	ldbu	r4,-8(fp)
   1f9f4:	e0ffff03 	ldbu	r3,-4(fp)
   1f9f8:	d9000015 	stw	r4,0(sp)
   1f9fc:	d8c00115 	stw	r3,4(sp)
   1fa00:	e0fff817 	ldw	r3,-32(fp)
   1fa04:	d8c00215 	stw	r3,8(sp)
   1fa08:	e13ffa17 	ldw	r4,-24(fp)
   1fa0c:	e17ffb17 	ldw	r5,-20(fp)
   1fa10:	e1bffc17 	ldw	r6,-16(fp)
   1fa14:	100f883a 	mov	r7,r2
   1fa18:	001f3080 	call	1f308 <ip_output_if>
   1fa1c:	e0bff905 	stb	r2,-28(fp)
  NETIF_SET_HWADDRHINT(netif, NULL);
   1fa20:	e0bff817 	ldw	r2,-32(fp)
   1fa24:	10001015 	stw	zero,64(r2)

  return err;
   1fa28:	e0bff903 	ldbu	r2,-28(fp)
}
   1fa2c:	e037883a 	mov	sp,fp
   1fa30:	dfc00117 	ldw	ra,4(sp)
   1fa34:	df000017 	ldw	fp,0(sp)
   1fa38:	dec00204 	addi	sp,sp,8
   1fa3c:	f800283a 	ret

0001fa40 <ip4_addr_isbroadcast>:
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t
ip4_addr_isbroadcast(u32_t addr, const struct netif *netif)
{
   1fa40:	defffc04 	addi	sp,sp,-16
   1fa44:	df000315 	stw	fp,12(sp)
   1fa48:	df000304 	addi	fp,sp,12
   1fa4c:	e13ffe15 	stw	r4,-8(fp)
   1fa50:	e17fff15 	stw	r5,-4(fp)
  ip_addr_t ipaddr;
  ip4_addr_set_u32(&ipaddr, addr);
   1fa54:	e0bffe17 	ldw	r2,-8(fp)
   1fa58:	e0bffd15 	stw	r2,-12(fp)

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
   1fa5c:	e0bffe17 	ldw	r2,-8(fp)
   1fa60:	10bfffe0 	cmpeqi	r2,r2,-1
   1fa64:	1000021e 	bne	r2,zero,1fa70 <ip4_addr_isbroadcast+0x30>
   1fa68:	e0bffe17 	ldw	r2,-8(fp)
   1fa6c:	1000021e 	bne	r2,zero,1fa78 <ip4_addr_isbroadcast+0x38>
      (addr == IPADDR_ANY)) {
    return 1;
   1fa70:	00800044 	movi	r2,1
   1fa74:	00002106 	br	1fafc <ip4_addr_isbroadcast+0xbc>
  /* no broadcast support on this network interface? */
  } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
   1fa78:	e0bfff17 	ldw	r2,-4(fp)
   1fa7c:	10800e43 	ldbu	r2,57(r2)
   1fa80:	10803fcc 	andi	r2,r2,255
   1fa84:	1080008c 	andi	r2,r2,2
   1fa88:	1000021e 	bne	r2,zero,1fa94 <ip4_addr_isbroadcast+0x54>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
   1fa8c:	0005883a 	mov	r2,zero
   1fa90:	00001a06 	br	1fafc <ip4_addr_isbroadcast+0xbc>
  /* address matches network interface address exactly? => no broadcast */
  } else if (addr == ip4_addr_get_u32(&netif->ip_addr)) {
   1fa94:	e0bfff17 	ldw	r2,-4(fp)
   1fa98:	10c00117 	ldw	r3,4(r2)
   1fa9c:	e0bffe17 	ldw	r2,-8(fp)
   1faa0:	1880021e 	bne	r3,r2,1faac <ip4_addr_isbroadcast+0x6c>
    return 0;
   1faa4:	0005883a 	mov	r2,zero
   1faa8:	00001406 	br	1fafc <ip4_addr_isbroadcast+0xbc>
  /*  on the same (sub) network... */
  } else if (ip_addr_netcmp(&ipaddr, &(netif->ip_addr), &(netif->netmask))
   1faac:	e0fffd17 	ldw	r3,-12(fp)
   1fab0:	e0bfff17 	ldw	r2,-4(fp)
   1fab4:	10800117 	ldw	r2,4(r2)
   1fab8:	1886f03a 	xor	r3,r3,r2
   1fabc:	e0bfff17 	ldw	r2,-4(fp)
   1fac0:	10800217 	ldw	r2,8(r2)
   1fac4:	1884703a 	and	r2,r3,r2
   1fac8:	10000b1e 	bne	r2,zero,1faf8 <ip4_addr_isbroadcast+0xb8>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr & ~ip4_addr_get_u32(&netif->netmask)) ==
   1facc:	e0bfff17 	ldw	r2,-4(fp)
   1fad0:	10800217 	ldw	r2,8(r2)
   1fad4:	0086303a 	nor	r3,zero,r2
   1fad8:	e0bffe17 	ldw	r2,-8(fp)
   1fadc:	1886703a 	and	r3,r3,r2
           (IPADDR_BROADCAST & ~ip4_addr_get_u32(&netif->netmask)))) {
   1fae0:	e0bfff17 	ldw	r2,-4(fp)
   1fae4:	10800217 	ldw	r2,8(r2)
   1fae8:	0084303a 	nor	r2,zero,r2
  } else if (addr == ip4_addr_get_u32(&netif->ip_addr)) {
    return 0;
  /*  on the same (sub) network... */
  } else if (ip_addr_netcmp(&ipaddr, &(netif->ip_addr), &(netif->netmask))
         /* ...and host identifier bits are all ones? =>... */
          && ((addr & ~ip4_addr_get_u32(&netif->netmask)) ==
   1faec:	1880021e 	bne	r3,r2,1faf8 <ip4_addr_isbroadcast+0xb8>
           (IPADDR_BROADCAST & ~ip4_addr_get_u32(&netif->netmask)))) {
    /* => network broadcast address */
    return 1;
   1faf0:	00800044 	movi	r2,1
   1faf4:	00000106 	br	1fafc <ip4_addr_isbroadcast+0xbc>
  } else {
    return 0;
   1faf8:	0005883a 	mov	r2,zero
  }
}
   1fafc:	e037883a 	mov	sp,fp
   1fb00:	df000017 	ldw	fp,0(sp)
   1fb04:	dec00104 	addi	sp,sp,4
   1fb08:	f800283a 	ret

0001fb0c <ip4_addr_netmask_valid>:
 * @param netmask the IPv4 netmask to check (in network byte order!)
 * @return 1 if the netmask is valid, 0 if it is not
 */
u8_t
ip4_addr_netmask_valid(u32_t netmask)
{
   1fb0c:	defffc04 	addi	sp,sp,-16
   1fb10:	df000315 	stw	fp,12(sp)
   1fb14:	df000304 	addi	fp,sp,12
   1fb18:	e13fff15 	stw	r4,-4(fp)
  u32_t mask;
  u32_t nm_hostorder = lwip_htonl(netmask);
   1fb1c:	e0bfff17 	ldw	r2,-4(fp)
   1fb20:	1006d63a 	srli	r3,r2,24
   1fb24:	e0bfff17 	ldw	r2,-4(fp)
   1fb28:	1004d23a 	srli	r2,r2,8
   1fb2c:	10bfc00c 	andi	r2,r2,65280
   1fb30:	1886b03a 	or	r3,r3,r2
   1fb34:	e0bfff17 	ldw	r2,-4(fp)
   1fb38:	10bfc00c 	andi	r2,r2,65280
   1fb3c:	1004923a 	slli	r2,r2,8
   1fb40:	1886b03a 	or	r3,r3,r2
   1fb44:	e0bfff17 	ldw	r2,-4(fp)
   1fb48:	1004963a 	slli	r2,r2,24
   1fb4c:	1884b03a 	or	r2,r3,r2
   1fb50:	e0bffe15 	stw	r2,-8(fp)

  /* first, check for the first zero */
  for (mask = 1UL << 31 ; mask != 0; mask >>= 1) {
   1fb54:	00a00034 	movhi	r2,32768
   1fb58:	e0bffd15 	stw	r2,-12(fp)
   1fb5c:	00000706 	br	1fb7c <ip4_addr_netmask_valid+0x70>
    if ((nm_hostorder & mask) == 0) {
   1fb60:	e0fffe17 	ldw	r3,-8(fp)
   1fb64:	e0bffd17 	ldw	r2,-12(fp)
   1fb68:	1884703a 	and	r2,r3,r2
   1fb6c:	10000626 	beq	r2,zero,1fb88 <ip4_addr_netmask_valid+0x7c>
{
  u32_t mask;
  u32_t nm_hostorder = lwip_htonl(netmask);

  /* first, check for the first zero */
  for (mask = 1UL << 31 ; mask != 0; mask >>= 1) {
   1fb70:	e0bffd17 	ldw	r2,-12(fp)
   1fb74:	1004d07a 	srli	r2,r2,1
   1fb78:	e0bffd15 	stw	r2,-12(fp)
   1fb7c:	e0bffd17 	ldw	r2,-12(fp)
   1fb80:	103ff71e 	bne	r2,zero,1fb60 <ip4_addr_netmask_valid+0x54>
    if ((nm_hostorder & mask) == 0) {
      break;
    }
  }
  /* then check that there is no one */
  for (; mask != 0; mask >>= 1) {
   1fb84:	00000b06 	br	1fbb4 <ip4_addr_netmask_valid+0xa8>
  u32_t nm_hostorder = lwip_htonl(netmask);

  /* first, check for the first zero */
  for (mask = 1UL << 31 ; mask != 0; mask >>= 1) {
    if ((nm_hostorder & mask) == 0) {
      break;
   1fb88:	0001883a 	nop
    }
  }
  /* then check that there is no one */
  for (; mask != 0; mask >>= 1) {
   1fb8c:	00000906 	br	1fbb4 <ip4_addr_netmask_valid+0xa8>
    if ((nm_hostorder & mask) != 0) {
   1fb90:	e0fffe17 	ldw	r3,-8(fp)
   1fb94:	e0bffd17 	ldw	r2,-12(fp)
   1fb98:	1884703a 	and	r2,r3,r2
   1fb9c:	10000226 	beq	r2,zero,1fba8 <ip4_addr_netmask_valid+0x9c>
      /* there is a one after the first zero -> invalid */
      return 0;
   1fba0:	0005883a 	mov	r2,zero
   1fba4:	00000606 	br	1fbc0 <ip4_addr_netmask_valid+0xb4>
    if ((nm_hostorder & mask) == 0) {
      break;
    }
  }
  /* then check that there is no one */
  for (; mask != 0; mask >>= 1) {
   1fba8:	e0bffd17 	ldw	r2,-12(fp)
   1fbac:	1004d07a 	srli	r2,r2,1
   1fbb0:	e0bffd15 	stw	r2,-12(fp)
   1fbb4:	e0bffd17 	ldw	r2,-12(fp)
   1fbb8:	103ff51e 	bne	r2,zero,1fb90 <ip4_addr_netmask_valid+0x84>
      /* there is a one after the first zero -> invalid */
      return 0;
    }
  }
  /* no one after the first zero -> valid */
  return 1;
   1fbbc:	00800044 	movi	r2,1
}
   1fbc0:	e037883a 	mov	sp,fp
   1fbc4:	df000017 	ldw	fp,0(sp)
   1fbc8:	dec00104 	addi	sp,sp,4
   1fbcc:	f800283a 	ret

0001fbd0 <ipaddr_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
ipaddr_addr(const char *cp)
{
   1fbd0:	defffc04 	addi	sp,sp,-16
   1fbd4:	dfc00315 	stw	ra,12(sp)
   1fbd8:	df000215 	stw	fp,8(sp)
   1fbdc:	df000204 	addi	fp,sp,8
   1fbe0:	e13fff15 	stw	r4,-4(fp)
  ip_addr_t val;

  if (ipaddr_aton(cp, &val)) {
   1fbe4:	e13fff17 	ldw	r4,-4(fp)
   1fbe8:	e17ffe04 	addi	r5,fp,-8
   1fbec:	001fc140 	call	1fc14 <ipaddr_aton>
   1fbf0:	10000226 	beq	r2,zero,1fbfc <ipaddr_addr+0x2c>
    return ip4_addr_get_u32(&val);
   1fbf4:	e0bffe17 	ldw	r2,-8(fp)
   1fbf8:	00000106 	br	1fc00 <ipaddr_addr+0x30>
  }
  return (IPADDR_NONE);
   1fbfc:	00bfffc4 	movi	r2,-1
}
   1fc00:	e037883a 	mov	sp,fp
   1fc04:	dfc00117 	ldw	ra,4(sp)
   1fc08:	df000017 	ldw	fp,0(sp)
   1fc0c:	dec00204 	addi	sp,sp,8
   1fc10:	f800283a 	ret

0001fc14 <ipaddr_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
ipaddr_aton(const char *cp, ip_addr_t *addr)
{
   1fc14:	defff604 	addi	sp,sp,-40
   1fc18:	df000915 	stw	fp,36(sp)
   1fc1c:	df000904 	addi	fp,sp,36
   1fc20:	e13ffe15 	stw	r4,-8(fp)
   1fc24:	e17fff15 	stw	r5,-4(fp)
  u32_t val;
  u8_t base;
  char c;
  u32_t parts[4];
  u32_t *pp = parts;
   1fc28:	e0bffa04 	addi	r2,fp,-24
   1fc2c:	e0bff915 	stw	r2,-28(fp)

  c = *cp;
   1fc30:	e0bffe17 	ldw	r2,-8(fp)
   1fc34:	10800003 	ldbu	r2,0(r2)
   1fc38:	e0bff845 	stb	r2,-31(fp)
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
   1fc3c:	e0bff843 	ldbu	r2,-31(fp)
   1fc40:	10803fcc 	andi	r2,r2,255
   1fc44:	10800c30 	cmpltui	r2,r2,48
   1fc48:	1000041e 	bne	r2,zero,1fc5c <ipaddr_aton+0x48>
   1fc4c:	e0bff843 	ldbu	r2,-31(fp)
   1fc50:	10803fcc 	andi	r2,r2,255
   1fc54:	10800eb0 	cmpltui	r2,r2,58
   1fc58:	1000021e 	bne	r2,zero,1fc64 <ipaddr_aton+0x50>
      return (0);
   1fc5c:	0005883a 	mov	r2,zero
   1fc60:	0000e806 	br	20004 <ipaddr_aton+0x3f0>
    val = 0;
   1fc64:	e03ff715 	stw	zero,-36(fp)
    base = 10;
   1fc68:	00800284 	movi	r2,10
   1fc6c:	e0bff805 	stb	r2,-32(fp)
    if (c == '0') {
   1fc70:	e0bff847 	ldb	r2,-31(fp)
   1fc74:	10800c18 	cmpnei	r2,r2,48
   1fc78:	1000171e 	bne	r2,zero,1fcd8 <ipaddr_aton+0xc4>
      c = *++cp;
   1fc7c:	e0bffe17 	ldw	r2,-8(fp)
   1fc80:	10800044 	addi	r2,r2,1
   1fc84:	e0bffe15 	stw	r2,-8(fp)
   1fc88:	e0bffe17 	ldw	r2,-8(fp)
   1fc8c:	10800003 	ldbu	r2,0(r2)
   1fc90:	e0bff845 	stb	r2,-31(fp)
      if (c == 'x' || c == 'X') {
   1fc94:	e0bff847 	ldb	r2,-31(fp)
   1fc98:	10801e20 	cmpeqi	r2,r2,120
   1fc9c:	1000031e 	bne	r2,zero,1fcac <ipaddr_aton+0x98>
   1fca0:	e0bff847 	ldb	r2,-31(fp)
   1fca4:	10801618 	cmpnei	r2,r2,88
   1fca8:	1000091e 	bne	r2,zero,1fcd0 <ipaddr_aton+0xbc>
        base = 16;
   1fcac:	00800404 	movi	r2,16
   1fcb0:	e0bff805 	stb	r2,-32(fp)
        c = *++cp;
   1fcb4:	e0bffe17 	ldw	r2,-8(fp)
   1fcb8:	10800044 	addi	r2,r2,1
   1fcbc:	e0bffe15 	stw	r2,-8(fp)
   1fcc0:	e0bffe17 	ldw	r2,-8(fp)
   1fcc4:	10800003 	ldbu	r2,0(r2)
   1fcc8:	e0bff845 	stb	r2,-31(fp)
   1fccc:	00000206 	br	1fcd8 <ipaddr_aton+0xc4>
      } else
        base = 8;
   1fcd0:	00800204 	movi	r2,8
   1fcd4:	e0bff805 	stb	r2,-32(fp)
    }
    for (;;) {
      if (isdigit(c)) {
   1fcd8:	e0bff843 	ldbu	r2,-31(fp)
   1fcdc:	10803fcc 	andi	r2,r2,255
   1fce0:	10800c30 	cmpltui	r2,r2,48
   1fce4:	1000121e 	bne	r2,zero,1fd30 <ipaddr_aton+0x11c>
   1fce8:	e0bff843 	ldbu	r2,-31(fp)
   1fcec:	10803fcc 	andi	r2,r2,255
   1fcf0:	10800ea8 	cmpgeui	r2,r2,58
   1fcf4:	10000e1e 	bne	r2,zero,1fd30 <ipaddr_aton+0x11c>
        val = (val * base) + (int)(c - '0');
   1fcf8:	e0fff803 	ldbu	r3,-32(fp)
   1fcfc:	e0bff717 	ldw	r2,-36(fp)
   1fd00:	1887383a 	mul	r3,r3,r2
   1fd04:	e0bff847 	ldb	r2,-31(fp)
   1fd08:	1885883a 	add	r2,r3,r2
   1fd0c:	10bff404 	addi	r2,r2,-48
   1fd10:	e0bff715 	stw	r2,-36(fp)
        c = *++cp;
   1fd14:	e0bffe17 	ldw	r2,-8(fp)
   1fd18:	10800044 	addi	r2,r2,1
   1fd1c:	e0bffe15 	stw	r2,-8(fp)
   1fd20:	e0bffe17 	ldw	r2,-8(fp)
   1fd24:	10800003 	ldbu	r2,0(r2)
   1fd28:	e0bff845 	stb	r2,-31(fp)
      } else if (base == 16 && isxdigit(c)) {
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
        c = *++cp;
      } else
        break;
    }
   1fd2c:	003fea06 	br	1fcd8 <ipaddr_aton+0xc4>
    }
    for (;;) {
      if (isdigit(c)) {
        val = (val * base) + (int)(c - '0');
        c = *++cp;
      } else if (base == 16 && isxdigit(c)) {
   1fd30:	e0bff803 	ldbu	r2,-32(fp)
   1fd34:	10800418 	cmpnei	r2,r2,16
   1fd38:	1000311e 	bne	r2,zero,1fe00 <ipaddr_aton+0x1ec>
   1fd3c:	e0bff843 	ldbu	r2,-31(fp)
   1fd40:	10803fcc 	andi	r2,r2,255
   1fd44:	10800c30 	cmpltui	r2,r2,48
   1fd48:	1000041e 	bne	r2,zero,1fd5c <ipaddr_aton+0x148>
   1fd4c:	e0bff843 	ldbu	r2,-31(fp)
   1fd50:	10803fcc 	andi	r2,r2,255
   1fd54:	10800eb0 	cmpltui	r2,r2,58
   1fd58:	1000101e 	bne	r2,zero,1fd9c <ipaddr_aton+0x188>
   1fd5c:	e0bff843 	ldbu	r2,-31(fp)
   1fd60:	10803fcc 	andi	r2,r2,255
   1fd64:	10801870 	cmpltui	r2,r2,97
   1fd68:	1000041e 	bne	r2,zero,1fd7c <ipaddr_aton+0x168>
   1fd6c:	e0bff843 	ldbu	r2,-31(fp)
   1fd70:	10803fcc 	andi	r2,r2,255
   1fd74:	108019f0 	cmpltui	r2,r2,103
   1fd78:	1000081e 	bne	r2,zero,1fd9c <ipaddr_aton+0x188>
   1fd7c:	e0bff843 	ldbu	r2,-31(fp)
   1fd80:	10803fcc 	andi	r2,r2,255
   1fd84:	10801070 	cmpltui	r2,r2,65
   1fd88:	10001d1e 	bne	r2,zero,1fe00 <ipaddr_aton+0x1ec>
   1fd8c:	e0bff843 	ldbu	r2,-31(fp)
   1fd90:	10803fcc 	andi	r2,r2,255
   1fd94:	108011e8 	cmpgeui	r2,r2,71
   1fd98:	1000191e 	bne	r2,zero,1fe00 <ipaddr_aton+0x1ec>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
   1fd9c:	e0bff717 	ldw	r2,-36(fp)
   1fda0:	1006913a 	slli	r3,r2,4
   1fda4:	e0bff847 	ldb	r2,-31(fp)
   1fda8:	11000284 	addi	r4,r2,10
   1fdac:	e0bff843 	ldbu	r2,-31(fp)
   1fdb0:	10803fcc 	andi	r2,r2,255
   1fdb4:	10801870 	cmpltui	r2,r2,97
   1fdb8:	1000061e 	bne	r2,zero,1fdd4 <ipaddr_aton+0x1c0>
   1fdbc:	e0bff843 	ldbu	r2,-31(fp)
   1fdc0:	10803fcc 	andi	r2,r2,255
   1fdc4:	10801ee8 	cmpgeui	r2,r2,123
   1fdc8:	1000021e 	bne	r2,zero,1fdd4 <ipaddr_aton+0x1c0>
   1fdcc:	00801844 	movi	r2,97
   1fdd0:	00000106 	br	1fdd8 <ipaddr_aton+0x1c4>
   1fdd4:	00801044 	movi	r2,65
   1fdd8:	2085c83a 	sub	r2,r4,r2
   1fddc:	1884b03a 	or	r2,r3,r2
   1fde0:	e0bff715 	stw	r2,-36(fp)
        c = *++cp;
   1fde4:	e0bffe17 	ldw	r2,-8(fp)
   1fde8:	10800044 	addi	r2,r2,1
   1fdec:	e0bffe15 	stw	r2,-8(fp)
   1fdf0:	e0bffe17 	ldw	r2,-8(fp)
   1fdf4:	10800003 	ldbu	r2,0(r2)
   1fdf8:	e0bff845 	stb	r2,-31(fp)
      } else
        break;
    }
   1fdfc:	003fb606 	br	1fcd8 <ipaddr_aton+0xc4>
    if (c == '.') {
   1fe00:	e0bff847 	ldb	r2,-31(fp)
   1fe04:	10800b98 	cmpnei	r2,r2,46
   1fe08:	1000131e 	bne	r2,zero,1fe58 <ipaddr_aton+0x244>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3) {
   1fe0c:	e0bffa04 	addi	r2,fp,-24
   1fe10:	10800304 	addi	r2,r2,12
   1fe14:	e0fff917 	ldw	r3,-28(fp)
   1fe18:	18800236 	bltu	r3,r2,1fe24 <ipaddr_aton+0x210>
        return (0);
   1fe1c:	0005883a 	mov	r2,zero
   1fe20:	00007806 	br	20004 <ipaddr_aton+0x3f0>
      }
      *pp++ = val;
   1fe24:	e0bff917 	ldw	r2,-28(fp)
   1fe28:	e0fff717 	ldw	r3,-36(fp)
   1fe2c:	10c00015 	stw	r3,0(r2)
   1fe30:	e0bff917 	ldw	r2,-28(fp)
   1fe34:	10800104 	addi	r2,r2,4
   1fe38:	e0bff915 	stw	r2,-28(fp)
      c = *++cp;
   1fe3c:	e0bffe17 	ldw	r2,-8(fp)
   1fe40:	10800044 	addi	r2,r2,1
   1fe44:	e0bffe15 	stw	r2,-8(fp)
   1fe48:	e0bffe17 	ldw	r2,-8(fp)
   1fe4c:	10800003 	ldbu	r2,0(r2)
   1fe50:	e0bff845 	stb	r2,-31(fp)
    } else
      break;
  }
   1fe54:	003f7906 	br	1fc3c <ipaddr_aton+0x28>
        return (0);
      }
      *pp++ = val;
      c = *++cp;
    } else
      break;
   1fe58:	0001883a 	nop
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && !isspace(c)) {
   1fe5c:	e0bff847 	ldb	r2,-31(fp)
   1fe60:	10001426 	beq	r2,zero,1feb4 <ipaddr_aton+0x2a0>
   1fe64:	e0bff847 	ldb	r2,-31(fp)
   1fe68:	10800820 	cmpeqi	r2,r2,32
   1fe6c:	1000111e 	bne	r2,zero,1feb4 <ipaddr_aton+0x2a0>
   1fe70:	e0bff847 	ldb	r2,-31(fp)
   1fe74:	10800320 	cmpeqi	r2,r2,12
   1fe78:	10000e1e 	bne	r2,zero,1feb4 <ipaddr_aton+0x2a0>
   1fe7c:	e0bff847 	ldb	r2,-31(fp)
   1fe80:	108002a0 	cmpeqi	r2,r2,10
   1fe84:	10000b1e 	bne	r2,zero,1feb4 <ipaddr_aton+0x2a0>
   1fe88:	e0bff847 	ldb	r2,-31(fp)
   1fe8c:	10800360 	cmpeqi	r2,r2,13
   1fe90:	1000081e 	bne	r2,zero,1feb4 <ipaddr_aton+0x2a0>
   1fe94:	e0bff847 	ldb	r2,-31(fp)
   1fe98:	10800260 	cmpeqi	r2,r2,9
   1fe9c:	1000051e 	bne	r2,zero,1feb4 <ipaddr_aton+0x2a0>
   1fea0:	e0bff847 	ldb	r2,-31(fp)
   1fea4:	108002e0 	cmpeqi	r2,r2,11
   1fea8:	1000021e 	bne	r2,zero,1feb4 <ipaddr_aton+0x2a0>
    return (0);
   1feac:	0005883a 	mov	r2,zero
   1feb0:	00005406 	br	20004 <ipaddr_aton+0x3f0>
  }
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  switch (pp - parts + 1) {
   1feb4:	e0fff917 	ldw	r3,-28(fp)
   1feb8:	e0bffa04 	addi	r2,fp,-24
   1febc:	1885c83a 	sub	r2,r3,r2
   1fec0:	1005d0ba 	srai	r2,r2,2
   1fec4:	10800044 	addi	r2,r2,1
   1fec8:	10c00168 	cmpgeui	r3,r2,5
   1fecc:	1800381e 	bne	r3,zero,1ffb0 <ipaddr_aton+0x39c>
   1fed0:	1085883a 	add	r2,r2,r2
   1fed4:	1087883a 	add	r3,r2,r2
   1fed8:	008000b4 	movhi	r2,2
   1fedc:	10bfbb04 	addi	r2,r2,-276
   1fee0:	1885883a 	add	r2,r3,r2
   1fee4:	10800017 	ldw	r2,0(r2)
   1fee8:	1000683a 	jmp	r2
   1feec:	0001ff00 	call	1ff0 <vStartCountingSemaphoreTasks+0x38>
   1fef0:	0001ffb8 	rdprs	zero,zero,2046
   1fef4:	0001ff08 	cmpgei	zero,zero,2044
   1fef8:	0001ff34 	movhi	zero,2044
   1fefc:	0001ff6c 	andhi	zero,zero,2045

  case 0:
    return (0);       /* initial nondigit */
   1ff00:	0005883a 	mov	r2,zero
   1ff04:	00003f06 	br	20004 <ipaddr_aton+0x3f0>

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL) {
   1ff08:	e0fff717 	ldw	r3,-36(fp)
   1ff0c:	00804034 	movhi	r2,256
   1ff10:	18800236 	bltu	r3,r2,1ff1c <ipaddr_aton+0x308>
      return (0);
   1ff14:	0005883a 	mov	r2,zero
   1ff18:	00003a06 	br	20004 <ipaddr_aton+0x3f0>
    }
    val |= parts[0] << 24;
   1ff1c:	e0bffa17 	ldw	r2,-24(fp)
   1ff20:	1004963a 	slli	r2,r2,24
   1ff24:	e0fff717 	ldw	r3,-36(fp)
   1ff28:	1884b03a 	or	r2,r3,r2
   1ff2c:	e0bff715 	stw	r2,-36(fp)
    break;
   1ff30:	00002206 	br	1ffbc <ipaddr_aton+0x3a8>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff) {
   1ff34:	e0bff717 	ldw	r2,-36(fp)
   1ff38:	00ffffd4 	movui	r3,65535
   1ff3c:	1880022e 	bgeu	r3,r2,1ff48 <ipaddr_aton+0x334>
      return (0);
   1ff40:	0005883a 	mov	r2,zero
   1ff44:	00002f06 	br	20004 <ipaddr_aton+0x3f0>
    }
    val |= (parts[0] << 24) | (parts[1] << 16);
   1ff48:	e0bffa17 	ldw	r2,-24(fp)
   1ff4c:	1006963a 	slli	r3,r2,24
   1ff50:	e0bffb17 	ldw	r2,-20(fp)
   1ff54:	1004943a 	slli	r2,r2,16
   1ff58:	1884b03a 	or	r2,r3,r2
   1ff5c:	e0fff717 	ldw	r3,-36(fp)
   1ff60:	1884b03a 	or	r2,r3,r2
   1ff64:	e0bff715 	stw	r2,-36(fp)
    break;
   1ff68:	00001406 	br	1ffbc <ipaddr_aton+0x3a8>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff) {
   1ff6c:	e0bff717 	ldw	r2,-36(fp)
   1ff70:	10804030 	cmpltui	r2,r2,256
   1ff74:	1000021e 	bne	r2,zero,1ff80 <ipaddr_aton+0x36c>
      return (0);
   1ff78:	0005883a 	mov	r2,zero
   1ff7c:	00002106 	br	20004 <ipaddr_aton+0x3f0>
    }
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
   1ff80:	e0bffa17 	ldw	r2,-24(fp)
   1ff84:	1006963a 	slli	r3,r2,24
   1ff88:	e0bffb17 	ldw	r2,-20(fp)
   1ff8c:	1004943a 	slli	r2,r2,16
   1ff90:	1886b03a 	or	r3,r3,r2
   1ff94:	e0bffc17 	ldw	r2,-16(fp)
   1ff98:	1004923a 	slli	r2,r2,8
   1ff9c:	1884b03a 	or	r2,r3,r2
   1ffa0:	e0fff717 	ldw	r3,-36(fp)
   1ffa4:	1884b03a 	or	r2,r3,r2
   1ffa8:	e0bff715 	stw	r2,-36(fp)
    break;
   1ffac:	00000306 	br	1ffbc <ipaddr_aton+0x3a8>
  default:
    LWIP_ASSERT("unhandled", 0);
    break;
   1ffb0:	0001883a 	nop
   1ffb4:	00000106 	br	1ffbc <ipaddr_aton+0x3a8>

  case 0:
    return (0);       /* initial nondigit */

  case 1:             /* a -- 32 bits */
    break;
   1ffb8:	0001883a 	nop
    break;
  default:
    LWIP_ASSERT("unhandled", 0);
    break;
  }
  if (addr) {
   1ffbc:	e0bfff17 	ldw	r2,-4(fp)
   1ffc0:	10000f26 	beq	r2,zero,20000 <ipaddr_aton+0x3ec>
    ip4_addr_set_u32(addr, htonl(val));
   1ffc4:	e0bff717 	ldw	r2,-36(fp)
   1ffc8:	1006d63a 	srli	r3,r2,24
   1ffcc:	e0bff717 	ldw	r2,-36(fp)
   1ffd0:	1004d23a 	srli	r2,r2,8
   1ffd4:	10bfc00c 	andi	r2,r2,65280
   1ffd8:	1886b03a 	or	r3,r3,r2
   1ffdc:	e0bff717 	ldw	r2,-36(fp)
   1ffe0:	10bfc00c 	andi	r2,r2,65280
   1ffe4:	1004923a 	slli	r2,r2,8
   1ffe8:	1886b03a 	or	r3,r3,r2
   1ffec:	e0bff717 	ldw	r2,-36(fp)
   1fff0:	1004963a 	slli	r2,r2,24
   1fff4:	1886b03a 	or	r3,r3,r2
   1fff8:	e0bfff17 	ldw	r2,-4(fp)
   1fffc:	10c00015 	stw	r3,0(r2)
  }
  return (1);
   20000:	00800044 	movi	r2,1
}
   20004:	e037883a 	mov	sp,fp
   20008:	df000017 	ldw	fp,0(sp)
   2000c:	dec00104 	addi	sp,sp,4
   20010:	f800283a 	ret

00020014 <ipaddr_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
ipaddr_ntoa(const ip_addr_t *addr)
{
   20014:	defffd04 	addi	sp,sp,-12
   20018:	dfc00215 	stw	ra,8(sp)
   2001c:	df000115 	stw	fp,4(sp)
   20020:	df000104 	addi	fp,sp,4
   20024:	e13fff15 	stw	r4,-4(fp)
  static char str[16];
  return ipaddr_ntoa_r(addr, str, 16);
   20028:	e13fff17 	ldw	r4,-4(fp)
   2002c:	01400174 	movhi	r5,5
   20030:	29606804 	addi	r5,r5,-32352
   20034:	01800404 	movi	r6,16
   20038:	00200500 	call	20050 <ipaddr_ntoa_r>
}
   2003c:	e037883a 	mov	sp,fp
   20040:	dfc00117 	ldw	ra,4(sp)
   20044:	df000017 	ldw	fp,0(sp)
   20048:	dec00204 	addi	sp,sp,8
   2004c:	f800283a 	ret

00020050 <ipaddr_ntoa_r>:
 * @param buflen length of buf
 * @return either pointer to buf which now holds the ASCII
 *         representation of addr or NULL if buf was too small
 */
char *ipaddr_ntoa_r(const ip_addr_t *addr, char *buf, int buflen)
{
   20050:	defff504 	addi	sp,sp,-44
   20054:	df000a15 	stw	fp,40(sp)
   20058:	df000a04 	addi	fp,sp,40
   2005c:	e13ffd15 	stw	r4,-12(fp)
   20060:	e17ffe15 	stw	r5,-8(fp)
   20064:	e1bfff15 	stw	r6,-4(fp)
  char *rp;
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;
  int len = 0;
   20068:	e03ff915 	stw	zero,-28(fp)

  s_addr = ip4_addr_get_u32(addr);
   2006c:	e0bffd17 	ldw	r2,-12(fp)
   20070:	10800017 	ldw	r2,0(r2)
   20074:	e0bffb15 	stw	r2,-20(fp)

  rp = buf;
   20078:	e0bffe17 	ldw	r2,-8(fp)
   2007c:	e0bff615 	stw	r2,-40(fp)
  ap = (u8_t *)&s_addr;
   20080:	e0bffb04 	addi	r2,fp,-20
   20084:	e0bff715 	stw	r2,-36(fp)
  for(n = 0; n < 4; n++) {
   20088:	e03ff805 	stb	zero,-32(fp)
   2008c:	00004f06 	br	201cc <ipaddr_ntoa_r+0x17c>
    i = 0;
   20090:	e03ff845 	stb	zero,-31(fp)
    do {
      rem = *ap % (u8_t)10;
   20094:	e0bff717 	ldw	r2,-36(fp)
   20098:	10800003 	ldbu	r2,0(r2)
   2009c:	10803fcc 	andi	r2,r2,255
   200a0:	00c00284 	movi	r3,10
   200a4:	10c7203a 	divu	r3,r2,r3
   200a8:	18c002a4 	muli	r3,r3,10
   200ac:	10c5c83a 	sub	r2,r2,r3
   200b0:	e0bffa05 	stb	r2,-24(fp)
      *ap /= (u8_t)10;
   200b4:	e0bff717 	ldw	r2,-36(fp)
   200b8:	10800003 	ldbu	r2,0(r2)
   200bc:	10c03fcc 	andi	r3,r2,255
   200c0:	00800284 	movi	r2,10
   200c4:	1885203a 	divu	r2,r3,r2
   200c8:	1007883a 	mov	r3,r2
   200cc:	e0bff717 	ldw	r2,-36(fp)
   200d0:	10c00005 	stb	r3,0(r2)
      inv[i++] = '0' + rem;
   200d4:	e0bff843 	ldbu	r2,-31(fp)
   200d8:	e0fffa03 	ldbu	r3,-24(fp)
   200dc:	18c00c04 	addi	r3,r3,48
   200e0:	e13ffc04 	addi	r4,fp,-16
   200e4:	2085883a 	add	r2,r4,r2
   200e8:	10c00005 	stb	r3,0(r2)
   200ec:	e0bff843 	ldbu	r2,-31(fp)
   200f0:	10800044 	addi	r2,r2,1
   200f4:	e0bff845 	stb	r2,-31(fp)
    } while(*ap);
   200f8:	e0bff717 	ldw	r2,-36(fp)
   200fc:	10800003 	ldbu	r2,0(r2)
   20100:	10803fcc 	andi	r2,r2,255
   20104:	103fe31e 	bne	r2,zero,20094 <ipaddr_ntoa_r+0x44>
    while(i--) {
   20108:	00001306 	br	20158 <ipaddr_ntoa_r+0x108>
      if (len++ >= buflen) {
   2010c:	e0fff917 	ldw	r3,-28(fp)
   20110:	e0bfff17 	ldw	r2,-4(fp)
   20114:	1884403a 	cmpge	r2,r3,r2
   20118:	e0fff917 	ldw	r3,-28(fp)
   2011c:	18c00044 	addi	r3,r3,1
   20120:	e0fff915 	stw	r3,-28(fp)
   20124:	10803fcc 	andi	r2,r2,255
   20128:	10000226 	beq	r2,zero,20134 <ipaddr_ntoa_r+0xe4>
        return NULL;
   2012c:	0005883a 	mov	r2,zero
   20130:	00002f06 	br	201f0 <ipaddr_ntoa_r+0x1a0>
      }
      *rp++ = inv[i];
   20134:	e0bff843 	ldbu	r2,-31(fp)
   20138:	e0fffc04 	addi	r3,fp,-16
   2013c:	1885883a 	add	r2,r3,r2
   20140:	10c00003 	ldbu	r3,0(r2)
   20144:	e0bff617 	ldw	r2,-40(fp)
   20148:	10c00005 	stb	r3,0(r2)
   2014c:	e0bff617 	ldw	r2,-40(fp)
   20150:	10800044 	addi	r2,r2,1
   20154:	e0bff615 	stw	r2,-40(fp)
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--) {
   20158:	e0bff843 	ldbu	r2,-31(fp)
   2015c:	1004c03a 	cmpne	r2,r2,zero
   20160:	e0fff843 	ldbu	r3,-31(fp)
   20164:	18ffffc4 	addi	r3,r3,-1
   20168:	e0fff845 	stb	r3,-31(fp)
   2016c:	10803fcc 	andi	r2,r2,255
   20170:	103fe61e 	bne	r2,zero,2010c <ipaddr_ntoa_r+0xbc>
      if (len++ >= buflen) {
        return NULL;
      }
      *rp++ = inv[i];
    }
    if (len++ >= buflen) {
   20174:	e0fff917 	ldw	r3,-28(fp)
   20178:	e0bfff17 	ldw	r2,-4(fp)
   2017c:	1884403a 	cmpge	r2,r3,r2
   20180:	e0fff917 	ldw	r3,-28(fp)
   20184:	18c00044 	addi	r3,r3,1
   20188:	e0fff915 	stw	r3,-28(fp)
   2018c:	10803fcc 	andi	r2,r2,255
   20190:	10000226 	beq	r2,zero,2019c <ipaddr_ntoa_r+0x14c>
      return NULL;
   20194:	0005883a 	mov	r2,zero
   20198:	00001506 	br	201f0 <ipaddr_ntoa_r+0x1a0>
    }
    *rp++ = '.';
   2019c:	e0bff617 	ldw	r2,-40(fp)
   201a0:	00c00b84 	movi	r3,46
   201a4:	10c00005 	stb	r3,0(r2)
   201a8:	e0bff617 	ldw	r2,-40(fp)
   201ac:	10800044 	addi	r2,r2,1
   201b0:	e0bff615 	stw	r2,-40(fp)
    ap++;
   201b4:	e0bff717 	ldw	r2,-36(fp)
   201b8:	10800044 	addi	r2,r2,1
   201bc:	e0bff715 	stw	r2,-36(fp)

  s_addr = ip4_addr_get_u32(addr);

  rp = buf;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
   201c0:	e0bff803 	ldbu	r2,-32(fp)
   201c4:	10800044 	addi	r2,r2,1
   201c8:	e0bff805 	stb	r2,-32(fp)
   201cc:	e0bff803 	ldbu	r2,-32(fp)
   201d0:	10800130 	cmpltui	r2,r2,4
   201d4:	103fae1e 	bne	r2,zero,20090 <ipaddr_ntoa_r+0x40>
      return NULL;
    }
    *rp++ = '.';
    ap++;
  }
  *--rp = 0;
   201d8:	e0bff617 	ldw	r2,-40(fp)
   201dc:	10bfffc4 	addi	r2,r2,-1
   201e0:	e0bff615 	stw	r2,-40(fp)
   201e4:	e0bff617 	ldw	r2,-40(fp)
   201e8:	10000005 	stb	zero,0(r2)
  return buf;
   201ec:	e0bffe17 	ldw	r2,-8(fp)
}
   201f0:	e037883a 	mov	sp,fp
   201f4:	df000017 	ldw	fp,0(sp)
   201f8:	dec00104 	addi	sp,sp,4
   201fc:	f800283a 	ret

00020200 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
   20200:	defffb04 	addi	sp,sp,-20
   20204:	dfc00415 	stw	ra,16(sp)
   20208:	df000315 	stw	fp,12(sp)
   2020c:	df000304 	addi	fp,sp,12
  struct ip_reassdata *r, *prev = NULL;
   20210:	e03ffe15 	stw	zero,-8(fp)

  r = reassdatagrams;
   20214:	d0a92a17 	ldw	r2,-23384(gp)
   20218:	e0bffd15 	stw	r2,-12(fp)
  while (r != NULL) {
   2021c:	00001806 	br	20280 <ip_reass_tmr+0x80>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
   20220:	e0bffd17 	ldw	r2,-12(fp)
   20224:	108007c3 	ldbu	r2,31(r2)
   20228:	10803fcc 	andi	r2,r2,255
   2022c:	10000c26 	beq	r2,zero,20260 <ip_reass_tmr+0x60>
      r->timer--;
   20230:	e0bffd17 	ldw	r2,-12(fp)
   20234:	108007c3 	ldbu	r2,31(r2)
   20238:	10bfffc4 	addi	r2,r2,-1
   2023c:	1007883a 	mov	r3,r2
   20240:	e0bffd17 	ldw	r2,-12(fp)
   20244:	10c007c5 	stb	r3,31(r2)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
   20248:	e0bffd17 	ldw	r2,-12(fp)
   2024c:	e0bffe15 	stw	r2,-8(fp)
      r = r->next;
   20250:	e0bffd17 	ldw	r2,-12(fp)
   20254:	10800017 	ldw	r2,0(r2)
   20258:	e0bffd15 	stw	r2,-12(fp)
   2025c:	00000806 	br	20280 <ip_reass_tmr+0x80>
    } else {
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
   20260:	e0bffd17 	ldw	r2,-12(fp)
   20264:	e0bfff15 	stw	r2,-4(fp)
      /* get the next pointer before freeing */
      r = r->next;
   20268:	e0bffd17 	ldw	r2,-12(fp)
   2026c:	10800017 	ldw	r2,0(r2)
   20270:	e0bffd15 	stw	r2,-12(fp)
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
   20274:	e13fff17 	ldw	r4,-4(fp)
   20278:	e17ffe17 	ldw	r5,-8(fp)
   2027c:	002029c0 	call	2029c <ip_reass_free_complete_datagram>
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
   20280:	e0bffd17 	ldw	r2,-12(fp)
   20284:	103fe61e 	bne	r2,zero,20220 <ip_reass_tmr+0x20>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
   20288:	e037883a 	mov	sp,fp
   2028c:	dfc00117 	ldw	ra,4(sp)
   20290:	df000017 	ldw	fp,0(sp)
   20294:	dec00204 	addi	sp,sp,8
   20298:	f800283a 	ret

0002029c <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
   2029c:	defff704 	addi	sp,sp,-36
   202a0:	dfc00815 	stw	ra,32(sp)
   202a4:	df000715 	stw	fp,28(sp)
   202a8:	df000704 	addi	fp,sp,28
   202ac:	e13ffe15 	stw	r4,-8(fp)
   202b0:	e17fff15 	stw	r5,-4(fp)
  u16_t pbufs_freed = 0;
   202b4:	e03ff90d 	sth	zero,-28(fp)
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
   202b8:	e0bffe17 	ldw	r2,-8(fp)
   202bc:	10800117 	ldw	r2,4(r2)
   202c0:	10800117 	ldw	r2,4(r2)
   202c4:	e0bffb15 	stw	r2,-20(fp)
  if (iprh->start == 0) {
   202c8:	e0bffb17 	ldw	r2,-20(fp)
   202cc:	10c00103 	ldbu	r3,4(r2)
   202d0:	10800143 	ldbu	r2,5(r2)
   202d4:	1004923a 	slli	r2,r2,8
   202d8:	10c4b03a 	or	r2,r2,r3
   202dc:	10bfffcc 	andi	r2,r2,65535
   202e0:	1000251e 	bne	r2,zero,20378 <ip_reass_free_complete_datagram+0xdc>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
   202e4:	e0bffe17 	ldw	r2,-8(fp)
   202e8:	10800117 	ldw	r2,4(r2)
   202ec:	e0bffa15 	stw	r2,-24(fp)
    ipr->p = iprh->next_pbuf;
   202f0:	e0bffb17 	ldw	r2,-20(fp)
   202f4:	10c00003 	ldbu	r3,0(r2)
   202f8:	11000043 	ldbu	r4,1(r2)
   202fc:	2008923a 	slli	r4,r4,8
   20300:	20c6b03a 	or	r3,r4,r3
   20304:	11000083 	ldbu	r4,2(r2)
   20308:	2008943a 	slli	r4,r4,16
   2030c:	20c6b03a 	or	r3,r4,r3
   20310:	108000c3 	ldbu	r2,3(r2)
   20314:	1004963a 	slli	r2,r2,24
   20318:	10c4b03a 	or	r2,r2,r3
   2031c:	1007883a 	mov	r3,r2
   20320:	e0bffe17 	ldw	r2,-8(fp)
   20324:	10c00115 	stw	r3,4(r2)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
   20328:	e0bffa17 	ldw	r2,-24(fp)
   2032c:	10c00117 	ldw	r3,4(r2)
   20330:	e0bffe17 	ldw	r2,-8(fp)
   20334:	10800204 	addi	r2,r2,8
   20338:	1809883a 	mov	r4,r3
   2033c:	100b883a 	mov	r5,r2
   20340:	01800504 	movi	r6,20
   20344:	00041f00 	call	41f0 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
   20348:	e13ffa17 	ldw	r4,-24(fp)
   2034c:	01400044 	movi	r5,1
   20350:	003de580 	call	3de58 <icmp_time_exceeded>
    clen = pbuf_clen(p);
   20354:	e13ffa17 	ldw	r4,-24(fp)
   20358:	00238a40 	call	238a4 <pbuf_clen>
   2035c:	e0bffc05 	stb	r2,-16(fp)
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
   20360:	e0fffc03 	ldbu	r3,-16(fp)
   20364:	e0bff90b 	ldhu	r2,-28(fp)
   20368:	1885883a 	add	r2,r3,r2
   2036c:	e0bff90d 	sth	r2,-28(fp)
    pbuf_free(p);
   20370:	e13ffa17 	ldw	r4,-24(fp)
   20374:	00237600 	call	23760 <pbuf_free>
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
   20378:	e0bffe17 	ldw	r2,-8(fp)
   2037c:	10800117 	ldw	r2,4(r2)
   20380:	e0bffa15 	stw	r2,-24(fp)
  while (p != NULL) {
   20384:	00001a06 	br	203f0 <ip_reass_free_complete_datagram+0x154>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
   20388:	e0bffa17 	ldw	r2,-24(fp)
   2038c:	10800117 	ldw	r2,4(r2)
   20390:	e0bffb15 	stw	r2,-20(fp)
    pcur = p;
   20394:	e0bffa17 	ldw	r2,-24(fp)
   20398:	e0bffd15 	stw	r2,-12(fp)
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
   2039c:	e0bffb17 	ldw	r2,-20(fp)
   203a0:	10c00003 	ldbu	r3,0(r2)
   203a4:	11000043 	ldbu	r4,1(r2)
   203a8:	2008923a 	slli	r4,r4,8
   203ac:	20c6b03a 	or	r3,r4,r3
   203b0:	11000083 	ldbu	r4,2(r2)
   203b4:	2008943a 	slli	r4,r4,16
   203b8:	20c6b03a 	or	r3,r4,r3
   203bc:	108000c3 	ldbu	r2,3(r2)
   203c0:	1004963a 	slli	r2,r2,24
   203c4:	10c4b03a 	or	r2,r2,r3
   203c8:	e0bffa15 	stw	r2,-24(fp)
    clen = pbuf_clen(pcur);
   203cc:	e13ffd17 	ldw	r4,-12(fp)
   203d0:	00238a40 	call	238a4 <pbuf_clen>
   203d4:	e0bffc05 	stb	r2,-16(fp)
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
   203d8:	e0fffc03 	ldbu	r3,-16(fp)
   203dc:	e0bff90b 	ldhu	r2,-28(fp)
   203e0:	1885883a 	add	r2,r3,r2
   203e4:	e0bff90d 	sth	r2,-28(fp)
    pbuf_free(pcur);
   203e8:	e13ffd17 	ldw	r4,-12(fp)
   203ec:	00237600 	call	23760 <pbuf_free>
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
   203f0:	e0bffa17 	ldw	r2,-24(fp)
   203f4:	103fe41e 	bne	r2,zero,20388 <ip_reass_free_complete_datagram+0xec>
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
    pbuf_free(pcur);
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
   203f8:	e13ffe17 	ldw	r4,-8(fp)
   203fc:	e17fff17 	ldw	r5,-4(fp)
   20400:	00206940 	call	20694 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  ip_reass_pbufcount -= pbufs_freed;
   20404:	d0e92b0b 	ldhu	r3,-23380(gp)
   20408:	e0bff90b 	ldhu	r2,-28(fp)
   2040c:	1885c83a 	sub	r2,r3,r2
   20410:	d0a92b0d 	sth	r2,-23380(gp)

  return pbufs_freed;
   20414:	e0bff90b 	ldhu	r2,-28(fp)
}
   20418:	e037883a 	mov	sp,fp
   2041c:	dfc00117 	ldw	ra,4(sp)
   20420:	df000017 	ldw	fp,0(sp)
   20424:	dec00204 	addi	sp,sp,8
   20428:	f800283a 	ret

0002042c <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
   2042c:	defff604 	addi	sp,sp,-40
   20430:	dfc00915 	stw	ra,36(sp)
   20434:	df000815 	stw	fp,32(sp)
   20438:	df000804 	addi	fp,sp,32
   2043c:	e13ffe15 	stw	r4,-8(fp)
   20440:	e17fff15 	stw	r5,-4(fp)
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
   20444:	e03ffb15 	stw	zero,-20(fp)
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
   20448:	e03ff915 	stw	zero,-28(fp)
    prev = NULL;
   2044c:	e03ffa15 	stw	zero,-24(fp)
    other_datagrams = 0;
   20450:	e03ffc15 	stw	zero,-16(fp)
    r = reassdatagrams;
   20454:	d0a92a17 	ldw	r2,-23384(gp)
   20458:	e0bff815 	stw	r2,-32(fp)
    while (r != NULL) {
   2045c:	00003f06 	br	2055c <ip_reass_remove_oldest_datagram+0x130>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
   20460:	e0bff817 	ldw	r2,-32(fp)
   20464:	10c00517 	ldw	r3,20(r2)
   20468:	e0bffe17 	ldw	r2,-8(fp)
   2046c:	11000303 	ldbu	r4,12(r2)
   20470:	11400343 	ldbu	r5,13(r2)
   20474:	280a923a 	slli	r5,r5,8
   20478:	2908b03a 	or	r4,r5,r4
   2047c:	11400383 	ldbu	r5,14(r2)
   20480:	280a943a 	slli	r5,r5,16
   20484:	2908b03a 	or	r4,r5,r4
   20488:	108003c3 	ldbu	r2,15(r2)
   2048c:	1004963a 	slli	r2,r2,24
   20490:	1104b03a 	or	r2,r2,r4
   20494:	1880181e 	bne	r3,r2,204f8 <ip_reass_remove_oldest_datagram+0xcc>
   20498:	e0bff817 	ldw	r2,-32(fp)
   2049c:	10c00617 	ldw	r3,24(r2)
   204a0:	e0bffe17 	ldw	r2,-8(fp)
   204a4:	11000403 	ldbu	r4,16(r2)
   204a8:	11400443 	ldbu	r5,17(r2)
   204ac:	280a923a 	slli	r5,r5,8
   204b0:	2908b03a 	or	r4,r5,r4
   204b4:	11400483 	ldbu	r5,18(r2)
   204b8:	280a943a 	slli	r5,r5,16
   204bc:	2908b03a 	or	r4,r5,r4
   204c0:	108004c3 	ldbu	r2,19(r2)
   204c4:	1004963a 	slli	r2,r2,24
   204c8:	1104b03a 	or	r2,r2,r4
   204cc:	18800a1e 	bne	r3,r2,204f8 <ip_reass_remove_oldest_datagram+0xcc>
   204d0:	e0bff817 	ldw	r2,-32(fp)
   204d4:	10c0030b 	ldhu	r3,12(r2)
   204d8:	e0bffe17 	ldw	r2,-8(fp)
   204dc:	11000103 	ldbu	r4,4(r2)
   204e0:	10800143 	ldbu	r2,5(r2)
   204e4:	1004923a 	slli	r2,r2,8
   204e8:	1104b03a 	or	r2,r2,r4
   204ec:	18ffffcc 	andi	r3,r3,65535
   204f0:	10bfffcc 	andi	r2,r2,65535
   204f4:	18801126 	beq	r3,r2,2053c <ip_reass_remove_oldest_datagram+0x110>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
   204f8:	e0bffc17 	ldw	r2,-16(fp)
   204fc:	10800044 	addi	r2,r2,1
   20500:	e0bffc15 	stw	r2,-16(fp)
        if (oldest == NULL) {
   20504:	e0bff917 	ldw	r2,-28(fp)
   20508:	1000031e 	bne	r2,zero,20518 <ip_reass_remove_oldest_datagram+0xec>
          oldest = r;
   2050c:	e0bff817 	ldw	r2,-32(fp)
   20510:	e0bff915 	stw	r2,-28(fp)
   20514:	00000906 	br	2053c <ip_reass_remove_oldest_datagram+0x110>
        } else if (r->timer <= oldest->timer) {
   20518:	e0bff817 	ldw	r2,-32(fp)
   2051c:	108007c3 	ldbu	r2,31(r2)
   20520:	e0fff917 	ldw	r3,-28(fp)
   20524:	18c007c3 	ldbu	r3,31(r3)
   20528:	10803fcc 	andi	r2,r2,255
   2052c:	18c03fcc 	andi	r3,r3,255
   20530:	18800236 	bltu	r3,r2,2053c <ip_reass_remove_oldest_datagram+0x110>
          /* older than the previous oldest */
          oldest = r;
   20534:	e0bff817 	ldw	r2,-32(fp)
   20538:	e0bff915 	stw	r2,-28(fp)
        }
      }
      if (r->next != NULL) {
   2053c:	e0bff817 	ldw	r2,-32(fp)
   20540:	10800017 	ldw	r2,0(r2)
   20544:	10000226 	beq	r2,zero,20550 <ip_reass_remove_oldest_datagram+0x124>
        prev = r;
   20548:	e0bff817 	ldw	r2,-32(fp)
   2054c:	e0bffa15 	stw	r2,-24(fp)
      }
      r = r->next;
   20550:	e0bff817 	ldw	r2,-32(fp)
   20554:	10800017 	ldw	r2,0(r2)
   20558:	e0bff815 	stw	r2,-32(fp)
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
   2055c:	e0bff817 	ldw	r2,-32(fp)
   20560:	103fbf1e 	bne	r2,zero,20460 <ip_reass_remove_oldest_datagram+0x34>
      if (r->next != NULL) {
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
   20564:	e0bff917 	ldw	r2,-28(fp)
   20568:	10000826 	beq	r2,zero,2058c <ip_reass_remove_oldest_datagram+0x160>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
   2056c:	e13ff917 	ldw	r4,-28(fp)
   20570:	e17ffa17 	ldw	r5,-24(fp)
   20574:	002029c0 	call	2029c <ip_reass_free_complete_datagram>
   20578:	e0bffd15 	stw	r2,-12(fp)
      pbufs_freed += pbufs_freed_current;
   2057c:	e0fffb17 	ldw	r3,-20(fp)
   20580:	e0bffd17 	ldw	r2,-12(fp)
   20584:	1885883a 	add	r2,r3,r2
   20588:	e0bffb15 	stw	r2,-20(fp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
   2058c:	e0fffb17 	ldw	r3,-20(fp)
   20590:	e0bfff17 	ldw	r2,-4(fp)
   20594:	1880030e 	bge	r3,r2,205a4 <ip_reass_remove_oldest_datagram+0x178>
   20598:	e0bffc17 	ldw	r2,-16(fp)
   2059c:	10800088 	cmpgei	r2,r2,2
   205a0:	103fa91e 	bne	r2,zero,20448 <ip_reass_remove_oldest_datagram+0x1c>
  return pbufs_freed;
   205a4:	e0bffb17 	ldw	r2,-20(fp)
}
   205a8:	e037883a 	mov	sp,fp
   205ac:	dfc00117 	ldw	ra,4(sp)
   205b0:	df000017 	ldw	fp,0(sp)
   205b4:	dec00204 	addi	sp,sp,8
   205b8:	f800283a 	ret

000205bc <ip_reass_enqueue_new_datagram>:
 * @param clen number of pbufs needed to enqueue (used for freeing other datagrams if not enough space)
 * @return A pointer to the queue location into which the fragment was enqueued
 */
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
   205bc:	defffb04 	addi	sp,sp,-20
   205c0:	dfc00415 	stw	ra,16(sp)
   205c4:	df000315 	stw	fp,12(sp)
   205c8:	df000304 	addi	fp,sp,12
   205cc:	e13ffe15 	stw	r4,-8(fp)
   205d0:	e17fff15 	stw	r5,-4(fp)
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
   205d4:	01000144 	movi	r4,5
   205d8:	00223cc0 	call	223cc <memp_malloc>
   205dc:	e0bffd15 	stw	r2,-12(fp)
  if (ipr == NULL) {
   205e0:	e0bffd17 	ldw	r2,-12(fp)
   205e4:	1000131e 	bne	r2,zero,20634 <ip_reass_enqueue_new_datagram+0x78>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
   205e8:	e13ffe17 	ldw	r4,-8(fp)
   205ec:	e17fff17 	ldw	r5,-4(fp)
   205f0:	002042c0 	call	2042c <ip_reass_remove_oldest_datagram>
   205f4:	e0ffff17 	ldw	r3,-4(fp)
   205f8:	10c00316 	blt	r2,r3,20608 <ip_reass_enqueue_new_datagram+0x4c>
      ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
   205fc:	01000144 	movi	r4,5
   20600:	00223cc0 	call	223cc <memp_malloc>
   20604:	e0bffd15 	stw	r2,-12(fp)
    }
    if (ipr == NULL)
   20608:	e0bffd17 	ldw	r2,-12(fp)
   2060c:	1000091e 	bne	r2,zero,20634 <ip_reass_enqueue_new_datagram+0x78>
#endif /* IP_REASS_FREE_OLDEST */
    {
      IPFRAG_STATS_INC(ip_frag.memerr);
   20610:	008001f4 	movhi	r2,7
   20614:	10ac6e04 	addi	r2,r2,-20040
   20618:	10801e17 	ldw	r2,120(r2)
   2061c:	10c00044 	addi	r3,r2,1
   20620:	008001f4 	movhi	r2,7
   20624:	10ac6e04 	addi	r2,r2,-20040
   20628:	10c01e15 	stw	r3,120(r2)
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
   2062c:	0005883a 	mov	r2,zero
   20630:	00001306 	br	20680 <ip_reass_enqueue_new_datagram+0xc4>
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
   20634:	e13ffd17 	ldw	r4,-12(fp)
   20638:	000b883a 	mov	r5,zero
   2063c:	01800804 	movi	r6,32
   20640:	00042e80 	call	42e8 <memset>
  ipr->timer = IP_REASS_MAXAGE;
   20644:	e0bffd17 	ldw	r2,-12(fp)
   20648:	00c000c4 	movi	r3,3
   2064c:	10c007c5 	stb	r3,31(r2)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
   20650:	d0e92a17 	ldw	r3,-23384(gp)
   20654:	e0bffd17 	ldw	r2,-12(fp)
   20658:	10c00015 	stw	r3,0(r2)
  reassdatagrams = ipr;
   2065c:	e0bffd17 	ldw	r2,-12(fp)
   20660:	d0a92a15 	stw	r2,-23384(gp)
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
   20664:	e0bffd17 	ldw	r2,-12(fp)
   20668:	10800204 	addi	r2,r2,8
   2066c:	1009883a 	mov	r4,r2
   20670:	e17ffe17 	ldw	r5,-8(fp)
   20674:	01800504 	movi	r6,20
   20678:	00041f00 	call	41f0 <memcpy>
  return ipr;
   2067c:	e0bffd17 	ldw	r2,-12(fp)
}
   20680:	e037883a 	mov	sp,fp
   20684:	dfc00117 	ldw	ra,4(sp)
   20688:	df000017 	ldw	fp,0(sp)
   2068c:	dec00204 	addi	sp,sp,8
   20690:	f800283a 	ret

00020694 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
   20694:	defffc04 	addi	sp,sp,-16
   20698:	dfc00315 	stw	ra,12(sp)
   2069c:	df000215 	stw	fp,8(sp)
   206a0:	df000204 	addi	fp,sp,8
   206a4:	e13ffe15 	stw	r4,-8(fp)
   206a8:	e17fff15 	stw	r5,-4(fp)
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
   206ac:	d0e92a17 	ldw	r3,-23384(gp)
   206b0:	e0bffe17 	ldw	r2,-8(fp)
   206b4:	1880041e 	bne	r3,r2,206c8 <ip_reass_dequeue_datagram+0x34>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
   206b8:	e0bffe17 	ldw	r2,-8(fp)
   206bc:	10800017 	ldw	r2,0(r2)
   206c0:	d0a92a15 	stw	r2,-23384(gp)
   206c4:	00000406 	br	206d8 <ip_reass_dequeue_datagram+0x44>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    prev->next = ipr->next;
   206c8:	e0bffe17 	ldw	r2,-8(fp)
   206cc:	10c00017 	ldw	r3,0(r2)
   206d0:	e0bfff17 	ldw	r2,-4(fp)
   206d4:	10c00015 	stw	r3,0(r2)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
   206d8:	01000144 	movi	r4,5
   206dc:	e17ffe17 	ldw	r5,-8(fp)
   206e0:	00225900 	call	22590 <memp_free>
}
   206e4:	e037883a 	mov	sp,fp
   206e8:	dfc00117 	ldw	ra,4(sp)
   206ec:	df000017 	ldw	fp,0(sp)
   206f0:	dec00204 	addi	sp,sp,8
   206f4:	f800283a 	ret

000206f8 <ip_reass_chain_frag_into_datagram_and_validate>:
 * @param new_p points to the pbuf for the current fragment
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
   206f8:	defff404 	addi	sp,sp,-48
   206fc:	dfc00b15 	stw	ra,44(sp)
   20700:	df000a15 	stw	fp,40(sp)
   20704:	dc000915 	stw	r16,36(sp)
   20708:	df000904 	addi	fp,sp,36
   2070c:	e13ffe15 	stw	r4,-8(fp)
   20710:	e17fff15 	stw	r5,-4(fp)
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
   20714:	e03ff715 	stw	zero,-36(fp)
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
   20718:	00800044 	movi	r2,1
   2071c:	e0bff915 	stw	r2,-28(fp)

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
   20720:	e0bfff17 	ldw	r2,-4(fp)
   20724:	10800117 	ldw	r2,4(r2)
   20728:	e0bffa15 	stw	r2,-24(fp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
   2072c:	e0bffa17 	ldw	r2,-24(fp)
   20730:	10c00083 	ldbu	r3,2(r2)
   20734:	108000c3 	ldbu	r2,3(r2)
   20738:	1004923a 	slli	r2,r2,8
   2073c:	10c4b03a 	or	r2,r2,r3
   20740:	10bfffcc 	andi	r2,r2,65535
   20744:	1004d23a 	srli	r2,r2,8
   20748:	1007883a 	mov	r3,r2
   2074c:	e0bffa17 	ldw	r2,-24(fp)
   20750:	11000083 	ldbu	r4,2(r2)
   20754:	108000c3 	ldbu	r2,3(r2)
   20758:	1004923a 	slli	r2,r2,8
   2075c:	1104b03a 	or	r2,r2,r4
   20760:	10bfffcc 	andi	r2,r2,65535
   20764:	1004923a 	slli	r2,r2,8
   20768:	1884b03a 	or	r2,r3,r2
   2076c:	1007883a 	mov	r3,r2
   20770:	e0bffa17 	ldw	r2,-24(fp)
   20774:	10800003 	ldbu	r2,0(r2)
   20778:	10803fcc 	andi	r2,r2,255
   2077c:	108003cc 	andi	r2,r2,15
   20780:	10bfff24 	muli	r2,r2,-4
   20784:	1885883a 	add	r2,r3,r2
   20788:	e0bffb0d 	sth	r2,-20(fp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
   2078c:	e0bffa17 	ldw	r2,-24(fp)
   20790:	10c00183 	ldbu	r3,6(r2)
   20794:	108001c3 	ldbu	r2,7(r2)
   20798:	1004923a 	slli	r2,r2,8
   2079c:	10c4b03a 	or	r2,r2,r3
   207a0:	10bfffcc 	andi	r2,r2,65535
   207a4:	1004d23a 	srli	r2,r2,8
   207a8:	10ffffcc 	andi	r3,r2,65535
   207ac:	e0bffa17 	ldw	r2,-24(fp)
   207b0:	11000183 	ldbu	r4,6(r2)
   207b4:	108001c3 	ldbu	r2,7(r2)
   207b8:	1004923a 	slli	r2,r2,8
   207bc:	1104b03a 	or	r2,r2,r4
   207c0:	10bfffcc 	andi	r2,r2,65535
   207c4:	1004923a 	slli	r2,r2,8
   207c8:	10bfffcc 	andi	r2,r2,65535
   207cc:	1884b03a 	or	r2,r3,r2
   207d0:	1087ffcc 	andi	r2,r2,8191
   207d4:	100490fa 	slli	r2,r2,3
   207d8:	e0bffb8d 	sth	r2,-18(fp)
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
   207dc:	e0bfff17 	ldw	r2,-4(fp)
   207e0:	10800117 	ldw	r2,4(r2)
   207e4:	e0bffc15 	stw	r2,-16(fp)
  iprh->next_pbuf = NULL;
   207e8:	e0bffc17 	ldw	r2,-16(fp)
   207ec:	10c00003 	ldbu	r3,0(r2)
   207f0:	1806703a 	and	r3,r3,zero
   207f4:	10c00005 	stb	r3,0(r2)
   207f8:	10c00043 	ldbu	r3,1(r2)
   207fc:	1806703a 	and	r3,r3,zero
   20800:	10c00045 	stb	r3,1(r2)
   20804:	10c00083 	ldbu	r3,2(r2)
   20808:	1806703a 	and	r3,r3,zero
   2080c:	10c00085 	stb	r3,2(r2)
   20810:	10c000c3 	ldbu	r3,3(r2)
   20814:	1806703a 	and	r3,r3,zero
   20818:	10c000c5 	stb	r3,3(r2)
  iprh->start = offset;
   2081c:	e0bffc17 	ldw	r2,-16(fp)
   20820:	e0fffb8b 	ldhu	r3,-18(fp)
   20824:	18c03fcc 	andi	r3,r3,255
   20828:	11000103 	ldbu	r4,4(r2)
   2082c:	2008703a 	and	r4,r4,zero
   20830:	20c6b03a 	or	r3,r4,r3
   20834:	10c00105 	stb	r3,4(r2)
   20838:	e0fffb8b 	ldhu	r3,-18(fp)
   2083c:	1806d23a 	srli	r3,r3,8
   20840:	18ffffcc 	andi	r3,r3,65535
   20844:	11000143 	ldbu	r4,5(r2)
   20848:	2008703a 	and	r4,r4,zero
   2084c:	20c6b03a 	or	r3,r4,r3
   20850:	10c00145 	stb	r3,5(r2)
  iprh->end = offset + len;
   20854:	e0fffb8b 	ldhu	r3,-18(fp)
   20858:	e0bffb0b 	ldhu	r2,-20(fp)
   2085c:	1885883a 	add	r2,r3,r2
   20860:	1007883a 	mov	r3,r2
   20864:	e0bffc17 	ldw	r2,-16(fp)
   20868:	193fffcc 	andi	r4,r3,65535
   2086c:	21003fcc 	andi	r4,r4,255
   20870:	11400183 	ldbu	r5,6(r2)
   20874:	280a703a 	and	r5,r5,zero
   20878:	2908b03a 	or	r4,r5,r4
   2087c:	11000185 	stb	r4,6(r2)
   20880:	18ffffcc 	andi	r3,r3,65535
   20884:	1806d23a 	srli	r3,r3,8
   20888:	18ffffcc 	andi	r3,r3,65535
   2088c:	110001c3 	ldbu	r4,7(r2)
   20890:	2008703a 	and	r4,r4,zero
   20894:	20c6b03a 	or	r3,r4,r3
   20898:	10c001c5 	stb	r3,7(r2)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
   2089c:	e0bffe17 	ldw	r2,-8(fp)
   208a0:	10800117 	ldw	r2,4(r2)
   208a4:	e0bff815 	stw	r2,-32(fp)
   208a8:	0000a606 	br	20b44 <ip_reass_chain_frag_into_datagram_and_validate+0x44c>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
   208ac:	e0bff817 	ldw	r2,-32(fp)
   208b0:	10800117 	ldw	r2,4(r2)
   208b4:	e0bffd15 	stw	r2,-12(fp)
    if (iprh->start < iprh_tmp->start) {
   208b8:	e0bffc17 	ldw	r2,-16(fp)
   208bc:	10c00103 	ldbu	r3,4(r2)
   208c0:	10800143 	ldbu	r2,5(r2)
   208c4:	1004923a 	slli	r2,r2,8
   208c8:	10c4b03a 	or	r2,r2,r3
   208cc:	1007883a 	mov	r3,r2
   208d0:	e0bffd17 	ldw	r2,-12(fp)
   208d4:	11000103 	ldbu	r4,4(r2)
   208d8:	10800143 	ldbu	r2,5(r2)
   208dc:	1004923a 	slli	r2,r2,8
   208e0:	1104b03a 	or	r2,r2,r4
   208e4:	18ffffcc 	andi	r3,r3,65535
   208e8:	10bfffcc 	andi	r2,r2,65535
   208ec:	18805a2e 	bgeu	r3,r2,20a58 <ip_reass_chain_frag_into_datagram_and_validate+0x360>
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
   208f0:	e0bffc17 	ldw	r2,-16(fp)
   208f4:	e0fff817 	ldw	r3,-32(fp)
   208f8:	18c03fcc 	andi	r3,r3,255
   208fc:	11000003 	ldbu	r4,0(r2)
   20900:	2008703a 	and	r4,r4,zero
   20904:	20c6b03a 	or	r3,r4,r3
   20908:	10c00005 	stb	r3,0(r2)
   2090c:	e0fff817 	ldw	r3,-32(fp)
   20910:	1806d23a 	srli	r3,r3,8
   20914:	18c03fcc 	andi	r3,r3,255
   20918:	11000043 	ldbu	r4,1(r2)
   2091c:	2008703a 	and	r4,r4,zero
   20920:	20c6b03a 	or	r3,r4,r3
   20924:	10c00045 	stb	r3,1(r2)
   20928:	e0fff817 	ldw	r3,-32(fp)
   2092c:	1806d43a 	srli	r3,r3,16
   20930:	18c03fcc 	andi	r3,r3,255
   20934:	11000083 	ldbu	r4,2(r2)
   20938:	2008703a 	and	r4,r4,zero
   2093c:	20c6b03a 	or	r3,r4,r3
   20940:	10c00085 	stb	r3,2(r2)
   20944:	e0fff817 	ldw	r3,-32(fp)
   20948:	1806d63a 	srli	r3,r3,24
   2094c:	110000c3 	ldbu	r4,3(r2)
   20950:	2008703a 	and	r4,r4,zero
   20954:	20c6b03a 	or	r3,r4,r3
   20958:	10c000c5 	stb	r3,3(r2)
      if (iprh_prev != NULL) {
   2095c:	e0bff717 	ldw	r2,-36(fp)
   20960:	10003926 	beq	r2,zero,20a48 <ip_reass_chain_frag_into_datagram_and_validate+0x350>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
   20964:	e0bffc17 	ldw	r2,-16(fp)
   20968:	10c00103 	ldbu	r3,4(r2)
   2096c:	10800143 	ldbu	r2,5(r2)
   20970:	1004923a 	slli	r2,r2,8
   20974:	10c4b03a 	or	r2,r2,r3
   20978:	1007883a 	mov	r3,r2
   2097c:	e0bff717 	ldw	r2,-36(fp)
   20980:	11000183 	ldbu	r4,6(r2)
   20984:	108001c3 	ldbu	r2,7(r2)
   20988:	1004923a 	slli	r2,r2,8
   2098c:	1104b03a 	or	r2,r2,r4
   20990:	18ffffcc 	andi	r3,r3,65535
   20994:	10bfffcc 	andi	r2,r2,65535
   20998:	1880e936 	bltu	r3,r2,20d40 <ip_reass_chain_frag_into_datagram_and_validate+0x648>
   2099c:	e0bffc17 	ldw	r2,-16(fp)
   209a0:	10c00183 	ldbu	r3,6(r2)
   209a4:	108001c3 	ldbu	r2,7(r2)
   209a8:	1004923a 	slli	r2,r2,8
   209ac:	10c4b03a 	or	r2,r2,r3
   209b0:	1009883a 	mov	r4,r2
   209b4:	e0bffd17 	ldw	r2,-12(fp)
   209b8:	10c00103 	ldbu	r3,4(r2)
   209bc:	10800143 	ldbu	r2,5(r2)
   209c0:	1004923a 	slli	r2,r2,8
   209c4:	10c4b03a 	or	r2,r2,r3
   209c8:	1007883a 	mov	r3,r2
   209cc:	20bfffcc 	andi	r2,r4,65535
   209d0:	18ffffcc 	andi	r3,r3,65535
   209d4:	1880da36 	bltu	r3,r2,20d40 <ip_reass_chain_frag_into_datagram_and_validate+0x648>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
   209d8:	e0bff717 	ldw	r2,-36(fp)
   209dc:	e0ffff17 	ldw	r3,-4(fp)
   209e0:	18c03fcc 	andi	r3,r3,255
   209e4:	11000003 	ldbu	r4,0(r2)
   209e8:	2008703a 	and	r4,r4,zero
   209ec:	20c6b03a 	or	r3,r4,r3
   209f0:	10c00005 	stb	r3,0(r2)
   209f4:	e0ffff17 	ldw	r3,-4(fp)
   209f8:	1806d23a 	srli	r3,r3,8
   209fc:	18c03fcc 	andi	r3,r3,255
   20a00:	11000043 	ldbu	r4,1(r2)
   20a04:	2008703a 	and	r4,r4,zero
   20a08:	20c6b03a 	or	r3,r4,r3
   20a0c:	10c00045 	stb	r3,1(r2)
   20a10:	e0ffff17 	ldw	r3,-4(fp)
   20a14:	1806d43a 	srli	r3,r3,16
   20a18:	18c03fcc 	andi	r3,r3,255
   20a1c:	11000083 	ldbu	r4,2(r2)
   20a20:	2008703a 	and	r4,r4,zero
   20a24:	20c6b03a 	or	r3,r4,r3
   20a28:	10c00085 	stb	r3,2(r2)
   20a2c:	e0ffff17 	ldw	r3,-4(fp)
   20a30:	1806d63a 	srli	r3,r3,24
   20a34:	110000c3 	ldbu	r4,3(r2)
   20a38:	2008703a 	and	r4,r4,zero
   20a3c:	20c6b03a 	or	r3,r4,r3
   20a40:	10c000c5 	stb	r3,3(r2)
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
   20a44:	00004106 	br	20b4c <ip_reass_chain_frag_into_datagram_and_validate+0x454>
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
   20a48:	e0bffe17 	ldw	r2,-8(fp)
   20a4c:	e0ffff17 	ldw	r3,-4(fp)
   20a50:	10c00115 	stw	r3,4(r2)
      }
      break;
   20a54:	00003d06 	br	20b4c <ip_reass_chain_frag_into_datagram_and_validate+0x454>
    } else if(iprh->start == iprh_tmp->start) {
   20a58:	e0bffc17 	ldw	r2,-16(fp)
   20a5c:	10c00103 	ldbu	r3,4(r2)
   20a60:	10800143 	ldbu	r2,5(r2)
   20a64:	1004923a 	slli	r2,r2,8
   20a68:	10c4b03a 	or	r2,r2,r3
   20a6c:	1007883a 	mov	r3,r2
   20a70:	e0bffd17 	ldw	r2,-12(fp)
   20a74:	11000103 	ldbu	r4,4(r2)
   20a78:	10800143 	ldbu	r2,5(r2)
   20a7c:	1004923a 	slli	r2,r2,8
   20a80:	1104b03a 	or	r2,r2,r4
   20a84:	18ffffcc 	andi	r3,r3,65535
   20a88:	10bfffcc 	andi	r2,r2,65535
   20a8c:	1880a926 	beq	r3,r2,20d34 <ip_reass_chain_frag_into_datagram_and_validate+0x63c>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
   20a90:	e0bffc17 	ldw	r2,-16(fp)
   20a94:	10c00103 	ldbu	r3,4(r2)
   20a98:	10800143 	ldbu	r2,5(r2)
   20a9c:	1004923a 	slli	r2,r2,8
   20aa0:	10c4b03a 	or	r2,r2,r3
   20aa4:	1007883a 	mov	r3,r2
   20aa8:	e0bffd17 	ldw	r2,-12(fp)
   20aac:	11000183 	ldbu	r4,6(r2)
   20ab0:	108001c3 	ldbu	r2,7(r2)
   20ab4:	1004923a 	slli	r2,r2,8
   20ab8:	1104b03a 	or	r2,r2,r4
   20abc:	18ffffcc 	andi	r3,r3,65535
   20ac0:	10bfffcc 	andi	r2,r2,65535
   20ac4:	18809d36 	bltu	r3,r2,20d3c <ip_reass_chain_frag_into_datagram_and_validate+0x644>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
   20ac8:	e0bff717 	ldw	r2,-36(fp)
   20acc:	10000f26 	beq	r2,zero,20b0c <ip_reass_chain_frag_into_datagram_and_validate+0x414>
        if (iprh_prev->end != iprh_tmp->start) {
   20ad0:	e0bff717 	ldw	r2,-36(fp)
   20ad4:	10c00183 	ldbu	r3,6(r2)
   20ad8:	108001c3 	ldbu	r2,7(r2)
   20adc:	1004923a 	slli	r2,r2,8
   20ae0:	10c4b03a 	or	r2,r2,r3
   20ae4:	1007883a 	mov	r3,r2
   20ae8:	e0bffd17 	ldw	r2,-12(fp)
   20aec:	11000103 	ldbu	r4,4(r2)
   20af0:	10800143 	ldbu	r2,5(r2)
   20af4:	1004923a 	slli	r2,r2,8
   20af8:	1104b03a 	or	r2,r2,r4
   20afc:	18ffffcc 	andi	r3,r3,65535
   20b00:	10bfffcc 	andi	r2,r2,65535
   20b04:	18800126 	beq	r3,r2,20b0c <ip_reass_chain_frag_into_datagram_and_validate+0x414>
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
   20b08:	e03ff915 	stw	zero,-28(fp)
        }
      }
    }
    q = iprh_tmp->next_pbuf;
   20b0c:	e0bffd17 	ldw	r2,-12(fp)
   20b10:	10c00003 	ldbu	r3,0(r2)
   20b14:	11000043 	ldbu	r4,1(r2)
   20b18:	2008923a 	slli	r4,r4,8
   20b1c:	20c6b03a 	or	r3,r4,r3
   20b20:	11000083 	ldbu	r4,2(r2)
   20b24:	2008943a 	slli	r4,r4,16
   20b28:	20c6b03a 	or	r3,r4,r3
   20b2c:	108000c3 	ldbu	r2,3(r2)
   20b30:	1004963a 	slli	r2,r2,24
   20b34:	10c4b03a 	or	r2,r2,r3
   20b38:	e0bff815 	stw	r2,-32(fp)
    iprh_prev = iprh_tmp;
   20b3c:	e0bffd17 	ldw	r2,-12(fp)
   20b40:	e0bff715 	stw	r2,-36(fp)
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
   20b44:	e0bff817 	ldw	r2,-32(fp)
   20b48:	103f581e 	bne	r2,zero,208ac <ip_reass_chain_frag_into_datagram_and_validate+0x1b4>
    q = iprh_tmp->next_pbuf;
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
   20b4c:	e0bff817 	ldw	r2,-32(fp)
   20b50:	1000301e 	bne	r2,zero,20c14 <ip_reass_chain_frag_into_datagram_and_validate+0x51c>
    if (iprh_prev != NULL) {
   20b54:	e0bff717 	ldw	r2,-36(fp)
   20b58:	10002b26 	beq	r2,zero,20c08 <ip_reass_chain_frag_into_datagram_and_validate+0x510>
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
   20b5c:	e0bff717 	ldw	r2,-36(fp)
   20b60:	e0ffff17 	ldw	r3,-4(fp)
   20b64:	18c03fcc 	andi	r3,r3,255
   20b68:	11000003 	ldbu	r4,0(r2)
   20b6c:	2008703a 	and	r4,r4,zero
   20b70:	20c6b03a 	or	r3,r4,r3
   20b74:	10c00005 	stb	r3,0(r2)
   20b78:	e0ffff17 	ldw	r3,-4(fp)
   20b7c:	1806d23a 	srli	r3,r3,8
   20b80:	18c03fcc 	andi	r3,r3,255
   20b84:	11000043 	ldbu	r4,1(r2)
   20b88:	2008703a 	and	r4,r4,zero
   20b8c:	20c6b03a 	or	r3,r4,r3
   20b90:	10c00045 	stb	r3,1(r2)
   20b94:	e0ffff17 	ldw	r3,-4(fp)
   20b98:	1806d43a 	srli	r3,r3,16
   20b9c:	18c03fcc 	andi	r3,r3,255
   20ba0:	11000083 	ldbu	r4,2(r2)
   20ba4:	2008703a 	and	r4,r4,zero
   20ba8:	20c6b03a 	or	r3,r4,r3
   20bac:	10c00085 	stb	r3,2(r2)
   20bb0:	e0ffff17 	ldw	r3,-4(fp)
   20bb4:	1806d63a 	srli	r3,r3,24
   20bb8:	110000c3 	ldbu	r4,3(r2)
   20bbc:	2008703a 	and	r4,r4,zero
   20bc0:	20c6b03a 	or	r3,r4,r3
   20bc4:	10c000c5 	stb	r3,3(r2)
      if (iprh_prev->end != iprh->start) {
   20bc8:	e0bff717 	ldw	r2,-36(fp)
   20bcc:	10c00183 	ldbu	r3,6(r2)
   20bd0:	108001c3 	ldbu	r2,7(r2)
   20bd4:	1004923a 	slli	r2,r2,8
   20bd8:	10c4b03a 	or	r2,r2,r3
   20bdc:	1007883a 	mov	r3,r2
   20be0:	e0bffc17 	ldw	r2,-16(fp)
   20be4:	11000103 	ldbu	r4,4(r2)
   20be8:	10800143 	ldbu	r2,5(r2)
   20bec:	1004923a 	slli	r2,r2,8
   20bf0:	1104b03a 	or	r2,r2,r4
   20bf4:	18ffffcc 	andi	r3,r3,65535
   20bf8:	10bfffcc 	andi	r2,r2,65535
   20bfc:	18800526 	beq	r3,r2,20c14 <ip_reass_chain_frag_into_datagram_and_validate+0x51c>
        valid = 0;
   20c00:	e03ff915 	stw	zero,-28(fp)
   20c04:	00000306 	br	20c14 <ip_reass_chain_frag_into_datagram_and_validate+0x51c>
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
   20c08:	e0bffe17 	ldw	r2,-8(fp)
   20c0c:	e0ffff17 	ldw	r3,-4(fp)
   20c10:	10c00115 	stw	r3,4(r2)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
   20c14:	e0bffe17 	ldw	r2,-8(fp)
   20c18:	10800783 	ldbu	r2,30(r2)
   20c1c:	10803fcc 	andi	r2,r2,255
   20c20:	1080004c 	andi	r2,r2,1
   20c24:	10004126 	beq	r2,zero,20d2c <ip_reass_chain_frag_into_datagram_and_validate+0x634>
    /* and had no wholes so far */
    if (valid) {
   20c28:	e0bff917 	ldw	r2,-28(fp)
   20c2c:	10003d26 	beq	r2,zero,20d24 <ip_reass_chain_frag_into_datagram_and_validate+0x62c>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
   20c30:	e0bffe17 	ldw	r2,-8(fp)
   20c34:	10800117 	ldw	r2,4(r2)
   20c38:	10800117 	ldw	r2,4(r2)
   20c3c:	10c00103 	ldbu	r3,4(r2)
   20c40:	10800143 	ldbu	r2,5(r2)
   20c44:	1004923a 	slli	r2,r2,8
   20c48:	10c4b03a 	or	r2,r2,r3
   20c4c:	10bfffcc 	andi	r2,r2,65535
   20c50:	10000226 	beq	r2,zero,20c5c <ip_reass_chain_frag_into_datagram_and_validate+0x564>
        valid = 0;
   20c54:	e03ff915 	stw	zero,-28(fp)
   20c58:	00003206 	br	20d24 <ip_reass_chain_frag_into_datagram_and_validate+0x62c>
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
   20c5c:	e0bffc17 	ldw	r2,-16(fp)
   20c60:	e0bff715 	stw	r2,-36(fp)
        q = iprh->next_pbuf;
   20c64:	e0bffc17 	ldw	r2,-16(fp)
   20c68:	10c00003 	ldbu	r3,0(r2)
   20c6c:	11000043 	ldbu	r4,1(r2)
   20c70:	2008923a 	slli	r4,r4,8
   20c74:	20c6b03a 	or	r3,r4,r3
   20c78:	11000083 	ldbu	r4,2(r2)
   20c7c:	2008943a 	slli	r4,r4,16
   20c80:	20c6b03a 	or	r3,r4,r3
   20c84:	108000c3 	ldbu	r2,3(r2)
   20c88:	1004963a 	slli	r2,r2,24
   20c8c:	10c4b03a 	or	r2,r2,r3
   20c90:	e0bff815 	stw	r2,-32(fp)
        while (q != NULL) {
   20c94:	00002106 	br	20d1c <ip_reass_chain_frag_into_datagram_and_validate+0x624>
          iprh = (struct ip_reass_helper*)q->payload;
   20c98:	e0bff817 	ldw	r2,-32(fp)
   20c9c:	10800117 	ldw	r2,4(r2)
   20ca0:	e0bffc15 	stw	r2,-16(fp)
          if (iprh_prev->end != iprh->start) {
   20ca4:	e0bff717 	ldw	r2,-36(fp)
   20ca8:	10c00183 	ldbu	r3,6(r2)
   20cac:	108001c3 	ldbu	r2,7(r2)
   20cb0:	1004923a 	slli	r2,r2,8
   20cb4:	10c4b03a 	or	r2,r2,r3
   20cb8:	1007883a 	mov	r3,r2
   20cbc:	e0bffc17 	ldw	r2,-16(fp)
   20cc0:	11000103 	ldbu	r4,4(r2)
   20cc4:	10800143 	ldbu	r2,5(r2)
   20cc8:	1004923a 	slli	r2,r2,8
   20ccc:	1104b03a 	or	r2,r2,r4
   20cd0:	18ffffcc 	andi	r3,r3,65535
   20cd4:	10bfffcc 	andi	r2,r2,65535
   20cd8:	18800226 	beq	r3,r2,20ce4 <ip_reass_chain_frag_into_datagram_and_validate+0x5ec>
            valid = 0;
   20cdc:	e03ff915 	stw	zero,-28(fp)
            break;
   20ce0:	00001006 	br	20d24 <ip_reass_chain_frag_into_datagram_and_validate+0x62c>
          }
          iprh_prev = iprh;
   20ce4:	e0bffc17 	ldw	r2,-16(fp)
   20ce8:	e0bff715 	stw	r2,-36(fp)
          q = iprh->next_pbuf;
   20cec:	e0bffc17 	ldw	r2,-16(fp)
   20cf0:	10c00003 	ldbu	r3,0(r2)
   20cf4:	11000043 	ldbu	r4,1(r2)
   20cf8:	2008923a 	slli	r4,r4,8
   20cfc:	20c6b03a 	or	r3,r4,r3
   20d00:	11000083 	ldbu	r4,2(r2)
   20d04:	2008943a 	slli	r4,r4,16
   20d08:	20c6b03a 	or	r3,r4,r3
   20d0c:	108000c3 	ldbu	r2,3(r2)
   20d10:	1004963a 	slli	r2,r2,24
   20d14:	10c4b03a 	or	r2,r2,r3
   20d18:	e0bff815 	stw	r2,-32(fp)
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
   20d1c:	e0bff817 	ldw	r2,-32(fp)
   20d20:	103fdd1e 	bne	r2,zero,20c98 <ip_reass_chain_frag_into_datagram_and_validate+0x5a0>
      }
    }
    /* If valid is 0 here, there are some fragments missing in the middle
     * (since MF == 0 has already arrived). Such datagrams simply time out if
     * no more fragments are received... */
    return valid;
   20d24:	e0bff917 	ldw	r2,-28(fp)
   20d28:	00000e06 	br	20d64 <ip_reass_chain_frag_into_datagram_and_validate+0x66c>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
   20d2c:	0005883a 	mov	r2,zero
   20d30:	00000c06 	br	20d64 <ip_reass_chain_frag_into_datagram_and_validate+0x66c>
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
   20d34:	0001883a 	nop
   20d38:	00000106 	br	20d40 <ip_reass_chain_frag_into_datagram_and_validate+0x648>
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
   20d3c:	0001883a 	nop
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
   20d40:	d4292b0b 	ldhu	r16,-23380(gp)
   20d44:	e13fff17 	ldw	r4,-4(fp)
   20d48:	00238a40 	call	238a4 <pbuf_clen>
   20d4c:	10803fcc 	andi	r2,r2,255
   20d50:	8085c83a 	sub	r2,r16,r2
   20d54:	d0a92b0d 	sth	r2,-23380(gp)
  pbuf_free(new_p);
   20d58:	e13fff17 	ldw	r4,-4(fp)
   20d5c:	00237600 	call	23760 <pbuf_free>
  return 0;
   20d60:	0005883a 	mov	r2,zero
#endif /* IP_REASS_CHECK_OVERLAP */
}
   20d64:	e037883a 	mov	sp,fp
   20d68:	dfc00217 	ldw	ra,8(sp)
   20d6c:	df000117 	ldw	fp,4(sp)
   20d70:	dc000017 	ldw	r16,0(sp)
   20d74:	dec00304 	addi	sp,sp,12
   20d78:	f800283a 	ret

00020d7c <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
   20d7c:	defff504 	addi	sp,sp,-44
   20d80:	dfc00a15 	stw	ra,40(sp)
   20d84:	df000915 	stw	fp,36(sp)
   20d88:	dc000815 	stw	r16,32(sp)
   20d8c:	df000804 	addi	fp,sp,32
   20d90:	e13fff15 	stw	r4,-4(fp)
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
   20d94:	e03ffa15 	stw	zero,-24(fp)

  IPFRAG_STATS_INC(ip_frag.recv);
   20d98:	008001f4 	movhi	r2,7
   20d9c:	10ac6e04 	addi	r2,r2,-20040
   20da0:	10801917 	ldw	r2,100(r2)
   20da4:	10c00044 	addi	r3,r2,1
   20da8:	008001f4 	movhi	r2,7
   20dac:	10ac6e04 	addi	r2,r2,-20040
   20db0:	10c01915 	stw	r3,100(r2)
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
   20db4:	e0bfff17 	ldw	r2,-4(fp)
   20db8:	10800117 	ldw	r2,4(r2)
   20dbc:	e0bffb15 	stw	r2,-20(fp)

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
   20dc0:	e0bffb17 	ldw	r2,-20(fp)
   20dc4:	10800003 	ldbu	r2,0(r2)
   20dc8:	10803fcc 	andi	r2,r2,255
   20dcc:	108003cc 	andi	r2,r2,15
   20dd0:	1085883a 	add	r2,r2,r2
   20dd4:	1085883a 	add	r2,r2,r2
   20dd8:	10800520 	cmpeqi	r2,r2,20
   20ddc:	1000081e 	bne	r2,zero,20e00 <ip_reass+0x84>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
   20de0:	008001f4 	movhi	r2,7
   20de4:	10ac6e04 	addi	r2,r2,-20040
   20de8:	10802217 	ldw	r2,136(r2)
   20dec:	10c00044 	addi	r3,r2,1
   20df0:	008001f4 	movhi	r2,7
   20df4:	10ac6e04 	addi	r2,r2,-20040
   20df8:	10c02215 	stw	r3,136(r2)
    goto nullreturn;
   20dfc:	00014b06 	br	2132c <ip_reass+0x5b0>
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
   20e00:	e0bffb17 	ldw	r2,-20(fp)
   20e04:	10c00183 	ldbu	r3,6(r2)
   20e08:	108001c3 	ldbu	r2,7(r2)
   20e0c:	1004923a 	slli	r2,r2,8
   20e10:	10c4b03a 	or	r2,r2,r3
   20e14:	10bfffcc 	andi	r2,r2,65535
   20e18:	1004d23a 	srli	r2,r2,8
   20e1c:	10ffffcc 	andi	r3,r2,65535
   20e20:	e0bffb17 	ldw	r2,-20(fp)
   20e24:	11000183 	ldbu	r4,6(r2)
   20e28:	108001c3 	ldbu	r2,7(r2)
   20e2c:	1004923a 	slli	r2,r2,8
   20e30:	1104b03a 	or	r2,r2,r4
   20e34:	10bfffcc 	andi	r2,r2,65535
   20e38:	1004923a 	slli	r2,r2,8
   20e3c:	10bfffcc 	andi	r2,r2,65535
   20e40:	1884b03a 	or	r2,r3,r2
   20e44:	1087ffcc 	andi	r2,r2,8191
   20e48:	100490fa 	slli	r2,r2,3
   20e4c:	e0bffc0d 	sth	r2,-16(fp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
   20e50:	e0bffb17 	ldw	r2,-20(fp)
   20e54:	10c00083 	ldbu	r3,2(r2)
   20e58:	108000c3 	ldbu	r2,3(r2)
   20e5c:	1004923a 	slli	r2,r2,8
   20e60:	10c4b03a 	or	r2,r2,r3
   20e64:	10bfffcc 	andi	r2,r2,65535
   20e68:	1004d23a 	srli	r2,r2,8
   20e6c:	1007883a 	mov	r3,r2
   20e70:	e0bffb17 	ldw	r2,-20(fp)
   20e74:	11000083 	ldbu	r4,2(r2)
   20e78:	108000c3 	ldbu	r2,3(r2)
   20e7c:	1004923a 	slli	r2,r2,8
   20e80:	1104b03a 	or	r2,r2,r4
   20e84:	10bfffcc 	andi	r2,r2,65535
   20e88:	1004923a 	slli	r2,r2,8
   20e8c:	1884b03a 	or	r2,r3,r2
   20e90:	1007883a 	mov	r3,r2
   20e94:	e0bffb17 	ldw	r2,-20(fp)
   20e98:	10800003 	ldbu	r2,0(r2)
   20e9c:	10803fcc 	andi	r2,r2,255
   20ea0:	108003cc 	andi	r2,r2,15
   20ea4:	10bfff24 	muli	r2,r2,-4
   20ea8:	1885883a 	add	r2,r3,r2
   20eac:	e0bffc8d 	sth	r2,-14(fp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
   20eb0:	e13fff17 	ldw	r4,-4(fp)
   20eb4:	00238a40 	call	238a4 <pbuf_clen>
   20eb8:	e0bffd05 	stb	r2,-12(fp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
   20ebc:	d0a92b0b 	ldhu	r2,-23380(gp)
   20ec0:	10ffffcc 	andi	r3,r2,65535
   20ec4:	e0bffd03 	ldbu	r2,-12(fp)
   20ec8:	1885883a 	add	r2,r3,r2
   20ecc:	108002d0 	cmplti	r2,r2,11
   20ed0:	1000131e 	bne	r2,zero,20f20 <ip_reass+0x1a4>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
   20ed4:	e0bffd03 	ldbu	r2,-12(fp)
   20ed8:	e13ffb17 	ldw	r4,-20(fp)
   20edc:	100b883a 	mov	r5,r2
   20ee0:	002042c0 	call	2042c <ip_reass_remove_oldest_datagram>
   20ee4:	10000626 	beq	r2,zero,20f00 <ip_reass+0x184>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
   20ee8:	d0a92b0b 	ldhu	r2,-23380(gp)
   20eec:	10ffffcc 	andi	r3,r2,65535
   20ef0:	e0bffd03 	ldbu	r2,-12(fp)
   20ef4:	1885883a 	add	r2,r3,r2

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
   20ef8:	108002d0 	cmplti	r2,r2,11
   20efc:	1000081e 	bne	r2,zero,20f20 <ip_reass+0x1a4>
#endif /* IP_REASS_FREE_OLDEST */
    {
      /* No datagram could be freed and still too many pbufs enqueued */
      LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: Overflow condition: pbufct=%d, clen=%d, MAX=%d\n",
        ip_reass_pbufcount, clen, IP_REASS_MAX_PBUFS));
      IPFRAG_STATS_INC(ip_frag.memerr);
   20f00:	008001f4 	movhi	r2,7
   20f04:	10ac6e04 	addi	r2,r2,-20040
   20f08:	10801e17 	ldw	r2,120(r2)
   20f0c:	10c00044 	addi	r3,r2,1
   20f10:	008001f4 	movhi	r2,7
   20f14:	10ac6e04 	addi	r2,r2,-20040
   20f18:	10c01e15 	stw	r3,120(r2)
      /* @todo: send ICMP time exceeded here? */
      /* drop this pbuf */
      goto nullreturn;
   20f1c:	00010306 	br	2132c <ip_reass+0x5b0>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
   20f20:	d0a92a17 	ldw	r2,-23384(gp)
   20f24:	e0bff915 	stw	r2,-28(fp)
   20f28:	00003306 	br	20ff8 <ip_reass+0x27c>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
   20f2c:	e0bff917 	ldw	r2,-28(fp)
   20f30:	10c00517 	ldw	r3,20(r2)
   20f34:	e0bffb17 	ldw	r2,-20(fp)
   20f38:	11000303 	ldbu	r4,12(r2)
   20f3c:	11400343 	ldbu	r5,13(r2)
   20f40:	280a923a 	slli	r5,r5,8
   20f44:	2908b03a 	or	r4,r5,r4
   20f48:	11400383 	ldbu	r5,14(r2)
   20f4c:	280a943a 	slli	r5,r5,16
   20f50:	2908b03a 	or	r4,r5,r4
   20f54:	108003c3 	ldbu	r2,15(r2)
   20f58:	1004963a 	slli	r2,r2,24
   20f5c:	1104b03a 	or	r2,r2,r4
   20f60:	1880201e 	bne	r3,r2,20fe4 <ip_reass+0x268>
   20f64:	e0bff917 	ldw	r2,-28(fp)
   20f68:	10c00617 	ldw	r3,24(r2)
   20f6c:	e0bffb17 	ldw	r2,-20(fp)
   20f70:	11000403 	ldbu	r4,16(r2)
   20f74:	11400443 	ldbu	r5,17(r2)
   20f78:	280a923a 	slli	r5,r5,8
   20f7c:	2908b03a 	or	r4,r5,r4
   20f80:	11400483 	ldbu	r5,18(r2)
   20f84:	280a943a 	slli	r5,r5,16
   20f88:	2908b03a 	or	r4,r5,r4
   20f8c:	108004c3 	ldbu	r2,19(r2)
   20f90:	1004963a 	slli	r2,r2,24
   20f94:	1104b03a 	or	r2,r2,r4
   20f98:	1880121e 	bne	r3,r2,20fe4 <ip_reass+0x268>
   20f9c:	e0bff917 	ldw	r2,-28(fp)
   20fa0:	10c0030b 	ldhu	r3,12(r2)
   20fa4:	e0bffb17 	ldw	r2,-20(fp)
   20fa8:	11000103 	ldbu	r4,4(r2)
   20fac:	10800143 	ldbu	r2,5(r2)
   20fb0:	1004923a 	slli	r2,r2,8
   20fb4:	1104b03a 	or	r2,r2,r4
   20fb8:	18ffffcc 	andi	r3,r3,65535
   20fbc:	10bfffcc 	andi	r2,r2,65535
   20fc0:	1880081e 	bne	r3,r2,20fe4 <ip_reass+0x268>
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
        ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
   20fc4:	008001f4 	movhi	r2,7
   20fc8:	10ac6e04 	addi	r2,r2,-20040
   20fcc:	10802317 	ldw	r2,140(r2)
   20fd0:	10c00044 	addi	r3,r2,1
   20fd4:	008001f4 	movhi	r2,7
   20fd8:	10ac6e04 	addi	r2,r2,-20040
   20fdc:	10c02315 	stw	r3,140(r2)
      break;
   20fe0:	00000706 	br	21000 <ip_reass+0x284>
    }
    ipr_prev = ipr;
   20fe4:	e0bff917 	ldw	r2,-28(fp)
   20fe8:	e0bffa15 	stw	r2,-24(fp)
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
   20fec:	e0bff917 	ldw	r2,-28(fp)
   20ff0:	10800017 	ldw	r2,0(r2)
   20ff4:	e0bff915 	stw	r2,-28(fp)
   20ff8:	e0bff917 	ldw	r2,-28(fp)
   20ffc:	103fcb1e 	bne	r2,zero,20f2c <ip_reass+0x1b0>
      break;
    }
    ipr_prev = ipr;
  }

  if (ipr == NULL) {
   21000:	e0bff917 	ldw	r2,-28(fp)
   21004:	1000081e 	bne	r2,zero,21028 <ip_reass+0x2ac>
  /* Enqueue a new datagram into the datagram queue */
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
   21008:	e0bffd03 	ldbu	r2,-12(fp)
   2100c:	e13ffb17 	ldw	r4,-20(fp)
   21010:	100b883a 	mov	r5,r2
   21014:	00205bc0 	call	205bc <ip_reass_enqueue_new_datagram>
   21018:	e0bff915 	stw	r2,-28(fp)
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
   2101c:	e0bff917 	ldw	r2,-28(fp)
   21020:	1000271e 	bne	r2,zero,210c0 <ip_reass+0x344>
      goto nullreturn;
   21024:	0000c106 	br	2132c <ip_reass+0x5b0>
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
   21028:	e0bffb17 	ldw	r2,-20(fp)
   2102c:	10c00183 	ldbu	r3,6(r2)
   21030:	108001c3 	ldbu	r2,7(r2)
   21034:	1004923a 	slli	r2,r2,8
   21038:	10c4b03a 	or	r2,r2,r3
   2103c:	10bfffcc 	andi	r2,r2,65535
   21040:	1004d23a 	srli	r2,r2,8
   21044:	10ffffcc 	andi	r3,r2,65535
   21048:	e0bffb17 	ldw	r2,-20(fp)
   2104c:	11000183 	ldbu	r4,6(r2)
   21050:	108001c3 	ldbu	r2,7(r2)
   21054:	1004923a 	slli	r2,r2,8
   21058:	1104b03a 	or	r2,r2,r4
   2105c:	10bfffcc 	andi	r2,r2,65535
   21060:	1004923a 	slli	r2,r2,8
   21064:	10bfffcc 	andi	r2,r2,65535
   21068:	1884b03a 	or	r2,r3,r2
   2106c:	1087ffcc 	andi	r2,r2,8191
   21070:	1000131e 	bne	r2,zero,210c0 <ip_reass+0x344>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
   21074:	e0bff917 	ldw	r2,-28(fp)
   21078:	1080038b 	ldhu	r2,14(r2)
   2107c:	10bfffcc 	andi	r2,r2,65535
   21080:	1004d23a 	srli	r2,r2,8
   21084:	10ffffcc 	andi	r3,r2,65535
   21088:	e0bff917 	ldw	r2,-28(fp)
   2108c:	1080038b 	ldhu	r2,14(r2)
   21090:	10bfffcc 	andi	r2,r2,65535
   21094:	1004923a 	slli	r2,r2,8
   21098:	10bfffcc 	andi	r2,r2,65535
   2109c:	1884b03a 	or	r2,r3,r2
   210a0:	1087ffcc 	andi	r2,r2,8191
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
   210a4:	10000626 	beq	r2,zero,210c0 <ip_reass+0x344>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
   210a8:	e0bff917 	ldw	r2,-28(fp)
   210ac:	10800204 	addi	r2,r2,8
   210b0:	1009883a 	mov	r4,r2
   210b4:	e17ffb17 	ldw	r5,-20(fp)
   210b8:	01800504 	movi	r6,20
   210bc:	00041f00 	call	41f0 <memcpy>
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
   210c0:	e0fffd03 	ldbu	r3,-12(fp)
   210c4:	d0a92b0b 	ldhu	r2,-23380(gp)
   210c8:	1885883a 	add	r2,r3,r2
   210cc:	d0a92b0d 	sth	r2,-23380(gp)

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
   210d0:	e0bffb17 	ldw	r2,-20(fp)
   210d4:	10c00183 	ldbu	r3,6(r2)
   210d8:	108001c3 	ldbu	r2,7(r2)
   210dc:	1004923a 	slli	r2,r2,8
   210e0:	10c4b03a 	or	r2,r2,r3
   210e4:	10bfffcc 	andi	r2,r2,65535
   210e8:	1080080c 	andi	r2,r2,32
   210ec:	10000c1e 	bne	r2,zero,21120 <ip_reass+0x3a4>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
   210f0:	e0bff917 	ldw	r2,-28(fp)
   210f4:	10800783 	ldbu	r2,30(r2)
   210f8:	10800054 	ori	r2,r2,1
   210fc:	1007883a 	mov	r3,r2
   21100:	e0bff917 	ldw	r2,-28(fp)
   21104:	10c00785 	stb	r3,30(r2)
    ipr->datagram_len = offset + len;
   21108:	e0fffc0b 	ldhu	r3,-16(fp)
   2110c:	e0bffc8b 	ldhu	r2,-14(fp)
   21110:	1885883a 	add	r2,r3,r2
   21114:	1007883a 	mov	r3,r2
   21118:	e0bff917 	ldw	r2,-28(fp)
   2111c:	10c0070d 	sth	r3,28(r2)
     ("ip_reass: last fragment seen, total len %"S16_F"\n",
      ipr->datagram_len));
  }
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
   21120:	e13ff917 	ldw	r4,-28(fp)
   21124:	e17fff17 	ldw	r5,-4(fp)
   21128:	00206f80 	call	206f8 <ip_reass_chain_frag_into_datagram_and_validate>
   2112c:	10007d26 	beq	r2,zero,21324 <ip_reass+0x5a8>
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
   21130:	e0bff917 	ldw	r2,-28(fp)
   21134:	1080070b 	ldhu	r2,28(r2)
   21138:	10800504 	addi	r2,r2,20
   2113c:	1007883a 	mov	r3,r2
   21140:	e0bff917 	ldw	r2,-28(fp)
   21144:	10c0070d 	sth	r3,28(r2)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
   21148:	e0bff917 	ldw	r2,-28(fp)
   2114c:	10800117 	ldw	r2,4(r2)
   21150:	10800117 	ldw	r2,4(r2)
   21154:	10c00003 	ldbu	r3,0(r2)
   21158:	11000043 	ldbu	r4,1(r2)
   2115c:	2008923a 	slli	r4,r4,8
   21160:	20c6b03a 	or	r3,r4,r3
   21164:	11000083 	ldbu	r4,2(r2)
   21168:	2008943a 	slli	r4,r4,16
   2116c:	20c6b03a 	or	r3,r4,r3
   21170:	108000c3 	ldbu	r2,3(r2)
   21174:	1004963a 	slli	r2,r2,24
   21178:	10c4b03a 	or	r2,r2,r3
   2117c:	e0bff815 	stw	r2,-32(fp)

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
   21180:	e0bff917 	ldw	r2,-28(fp)
   21184:	10800117 	ldw	r2,4(r2)
   21188:	10800117 	ldw	r2,4(r2)
   2118c:	e0bffb15 	stw	r2,-20(fp)
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
   21190:	e0bff917 	ldw	r2,-28(fp)
   21194:	10800204 	addi	r2,r2,8
   21198:	e13ffb17 	ldw	r4,-20(fp)
   2119c:	100b883a 	mov	r5,r2
   211a0:	01800504 	movi	r6,20
   211a4:	00041f00 	call	41f0 <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
   211a8:	e0bff917 	ldw	r2,-28(fp)
   211ac:	1080070b 	ldhu	r2,28(r2)
   211b0:	10bfffcc 	andi	r2,r2,65535
   211b4:	1004d23a 	srli	r2,r2,8
   211b8:	1007883a 	mov	r3,r2
   211bc:	e0bff917 	ldw	r2,-28(fp)
   211c0:	1080070b 	ldhu	r2,28(r2)
   211c4:	10bfffcc 	andi	r2,r2,65535
   211c8:	1004923a 	slli	r2,r2,8
   211cc:	1884b03a 	or	r2,r3,r2
   211d0:	1007883a 	mov	r3,r2
   211d4:	e0bffb17 	ldw	r2,-20(fp)
   211d8:	193fffcc 	andi	r4,r3,65535
   211dc:	21003fcc 	andi	r4,r4,255
   211e0:	11400083 	ldbu	r5,2(r2)
   211e4:	280a703a 	and	r5,r5,zero
   211e8:	2908b03a 	or	r4,r5,r4
   211ec:	11000085 	stb	r4,2(r2)
   211f0:	18ffffcc 	andi	r3,r3,65535
   211f4:	1806d23a 	srli	r3,r3,8
   211f8:	18ffffcc 	andi	r3,r3,65535
   211fc:	110000c3 	ldbu	r4,3(r2)
   21200:	2008703a 	and	r4,r4,zero
   21204:	20c6b03a 	or	r3,r4,r3
   21208:	10c000c5 	stb	r3,3(r2)
    IPH_OFFSET_SET(fraghdr, 0);
   2120c:	e0bffb17 	ldw	r2,-20(fp)
   21210:	10c00183 	ldbu	r3,6(r2)
   21214:	1806703a 	and	r3,r3,zero
   21218:	10c00185 	stb	r3,6(r2)
   2121c:	10c001c3 	ldbu	r3,7(r2)
   21220:	1806703a 	and	r3,r3,zero
   21224:	10c001c5 	stb	r3,7(r2)
    IPH_CHKSUM_SET(fraghdr, 0);
   21228:	e0bffb17 	ldw	r2,-20(fp)
   2122c:	10c00283 	ldbu	r3,10(r2)
   21230:	1806703a 	and	r3,r3,zero
   21234:	10c00285 	stb	r3,10(r2)
   21238:	10c002c3 	ldbu	r3,11(r2)
   2123c:	1806703a 	and	r3,r3,zero
   21240:	10c002c5 	stb	r3,11(r2)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
   21244:	e13ffb17 	ldw	r4,-20(fp)
   21248:	01400504 	movi	r5,20
   2124c:	003e6d40 	call	3e6d4 <inet_chksum>
   21250:	1007883a 	mov	r3,r2
   21254:	e0bffb17 	ldw	r2,-20(fp)
   21258:	193fffcc 	andi	r4,r3,65535
   2125c:	21003fcc 	andi	r4,r4,255
   21260:	11400283 	ldbu	r5,10(r2)
   21264:	280a703a 	and	r5,r5,zero
   21268:	2908b03a 	or	r4,r5,r4
   2126c:	11000285 	stb	r4,10(r2)
   21270:	18ffffcc 	andi	r3,r3,65535
   21274:	1806d23a 	srli	r3,r3,8
   21278:	18ffffcc 	andi	r3,r3,65535
   2127c:	110002c3 	ldbu	r4,11(r2)
   21280:	2008703a 	and	r4,r4,zero
   21284:	20c6b03a 	or	r3,r4,r3
   21288:	10c002c5 	stb	r3,11(r2)

    p = ipr->p;
   2128c:	e0bff917 	ldw	r2,-28(fp)
   21290:	10800117 	ldw	r2,4(r2)
   21294:	e0bfff15 	stw	r2,-4(fp)

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
   21298:	00001506 	br	212f0 <ip_reass+0x574>
      iprh = (struct ip_reass_helper*)r->payload;
   2129c:	e0bff817 	ldw	r2,-32(fp)
   212a0:	10800117 	ldw	r2,4(r2)
   212a4:	e0bffe15 	stw	r2,-8(fp)

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
   212a8:	e13ff817 	ldw	r4,-32(fp)
   212ac:	017ffb04 	movi	r5,-20
   212b0:	00235b00 	call	235b0 <pbuf_header>
      pbuf_cat(p, r);
   212b4:	e13fff17 	ldw	r4,-4(fp)
   212b8:	e17ff817 	ldw	r5,-32(fp)
   212bc:	00239500 	call	23950 <pbuf_cat>
      r = iprh->next_pbuf;
   212c0:	e0bffe17 	ldw	r2,-8(fp)
   212c4:	10c00003 	ldbu	r3,0(r2)
   212c8:	11000043 	ldbu	r4,1(r2)
   212cc:	2008923a 	slli	r4,r4,8
   212d0:	20c6b03a 	or	r3,r4,r3
   212d4:	11000083 	ldbu	r4,2(r2)
   212d8:	2008943a 	slli	r4,r4,16
   212dc:	20c6b03a 	or	r3,r4,r3
   212e0:	108000c3 	ldbu	r2,3(r2)
   212e4:	1004963a 	slli	r2,r2,24
   212e8:	10c4b03a 	or	r2,r2,r3
   212ec:	e0bff815 	stw	r2,-32(fp)
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
   212f0:	e0bff817 	ldw	r2,-32(fp)
   212f4:	103fe91e 	bne	r2,zero,2129c <ip_reass+0x520>
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
   212f8:	e13ff917 	ldw	r4,-28(fp)
   212fc:	e17ffa17 	ldw	r5,-24(fp)
   21300:	00206940 	call	20694 <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
   21304:	d4292b0b 	ldhu	r16,-23380(gp)
   21308:	e13fff17 	ldw	r4,-4(fp)
   2130c:	00238a40 	call	238a4 <pbuf_clen>
   21310:	10803fcc 	andi	r2,r2,255
   21314:	8085c83a 	sub	r2,r16,r2
   21318:	d0a92b0d 	sth	r2,-23380(gp)

    /* Return the pbuf chain */
    return p;
   2131c:	e0bfff17 	ldw	r2,-4(fp)
   21320:	00000c06 	br	21354 <ip_reass+0x5d8>
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
   21324:	0005883a 	mov	r2,zero
   21328:	00000a06 	br	21354 <ip_reass+0x5d8>

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
   2132c:	008001f4 	movhi	r2,7
   21330:	10ac6e04 	addi	r2,r2,-20040
   21334:	10801b17 	ldw	r2,108(r2)
   21338:	10c00044 	addi	r3,r2,1
   2133c:	008001f4 	movhi	r2,7
   21340:	10ac6e04 	addi	r2,r2,-20040
   21344:	10c01b15 	stw	r3,108(r2)
  pbuf_free(p);
   21348:	e13fff17 	ldw	r4,-4(fp)
   2134c:	00237600 	call	23760 <pbuf_free>
  return NULL;
   21350:	0005883a 	mov	r2,zero
}
   21354:	e037883a 	mov	sp,fp
   21358:	dfc00217 	ldw	ra,8(sp)
   2135c:	df000117 	ldw	fp,4(sp)
   21360:	dc000017 	ldw	r16,0(sp)
   21364:	dec00304 	addi	sp,sp,12
   21368:	f800283a 	ret

0002136c <ip_frag_alloc_pbuf_custom_ref>:

#if !LWIP_NETIF_TX_SINGLE_PBUF
/** Allocate a new struct pbuf_custom_ref */
static struct pbuf_custom_ref*
ip_frag_alloc_pbuf_custom_ref(void)
{
   2136c:	defffe04 	addi	sp,sp,-8
   21370:	dfc00115 	stw	ra,4(sp)
   21374:	df000015 	stw	fp,0(sp)
   21378:	d839883a 	mov	fp,sp
  return (struct pbuf_custom_ref*)memp_malloc(MEMP_FRAG_PBUF);
   2137c:	01000184 	movi	r4,6
   21380:	00223cc0 	call	223cc <memp_malloc>
}
   21384:	e037883a 	mov	sp,fp
   21388:	dfc00117 	ldw	ra,4(sp)
   2138c:	df000017 	ldw	fp,0(sp)
   21390:	dec00204 	addi	sp,sp,8
   21394:	f800283a 	ret

00021398 <ip_frag_free_pbuf_custom_ref>:

/** Free a struct pbuf_custom_ref */
static void
ip_frag_free_pbuf_custom_ref(struct pbuf_custom_ref* p)
{
   21398:	defffd04 	addi	sp,sp,-12
   2139c:	dfc00215 	stw	ra,8(sp)
   213a0:	df000115 	stw	fp,4(sp)
   213a4:	df000104 	addi	fp,sp,4
   213a8:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("p != NULL", p != NULL);
  memp_free(MEMP_FRAG_PBUF, p);
   213ac:	01000184 	movi	r4,6
   213b0:	e17fff17 	ldw	r5,-4(fp)
   213b4:	00225900 	call	22590 <memp_free>
}
   213b8:	e037883a 	mov	sp,fp
   213bc:	dfc00117 	ldw	ra,4(sp)
   213c0:	df000017 	ldw	fp,0(sp)
   213c4:	dec00204 	addi	sp,sp,8
   213c8:	f800283a 	ret

000213cc <ipfrag_free_pbuf_custom>:

/** Free-callback function to free a 'struct pbuf_custom_ref', called by
 * pbuf_free. */
static void
ipfrag_free_pbuf_custom(struct pbuf *p)
{
   213cc:	defffc04 	addi	sp,sp,-16
   213d0:	dfc00315 	stw	ra,12(sp)
   213d4:	df000215 	stw	fp,8(sp)
   213d8:	df000204 	addi	fp,sp,8
   213dc:	e13fff15 	stw	r4,-4(fp)
  struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref*)p;
   213e0:	e0bfff17 	ldw	r2,-4(fp)
   213e4:	e0bffe15 	stw	r2,-8(fp)
  LWIP_ASSERT("pcr != NULL", pcr != NULL);
  LWIP_ASSERT("pcr == p", (void*)pcr == (void*)p);
  if (pcr->original != NULL) {
   213e8:	e0bffe17 	ldw	r2,-8(fp)
   213ec:	10800517 	ldw	r2,20(r2)
   213f0:	10000426 	beq	r2,zero,21404 <ipfrag_free_pbuf_custom+0x38>
    pbuf_free(pcr->original);
   213f4:	e0bffe17 	ldw	r2,-8(fp)
   213f8:	10800517 	ldw	r2,20(r2)
   213fc:	1009883a 	mov	r4,r2
   21400:	00237600 	call	23760 <pbuf_free>
  }
  ip_frag_free_pbuf_custom_ref(pcr);
   21404:	e13ffe17 	ldw	r4,-8(fp)
   21408:	00213980 	call	21398 <ip_frag_free_pbuf_custom_ref>
}
   2140c:	e037883a 	mov	sp,fp
   21410:	dfc00117 	ldw	ra,4(sp)
   21414:	df000017 	ldw	fp,0(sp)
   21418:	dec00204 	addi	sp,sp,8
   2141c:	f800283a 	ret

00021420 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, ip_addr_t *dest)
{
   21420:	deffee04 	addi	sp,sp,-72
   21424:	dfc01115 	stw	ra,68(sp)
   21428:	df001015 	stw	fp,64(sp)
   2142c:	df001004 	addi	fp,sp,64
   21430:	e13ffd15 	stw	r4,-12(fp)
   21434:	e17ffe15 	stw	r5,-8(fp)
   21438:	e1bfff15 	stw	r6,-4(fp)
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
   2143c:	e0bffe17 	ldw	r2,-8(fp)
   21440:	10800c0b 	ldhu	r2,48(r2)
   21444:	e0bff50d 	sth	r2,-44(fp)
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
   21448:	00800504 	movi	r2,20
   2144c:	e0bff30d 	sth	r2,-52(fp)
  u16_t tmp;
#if !IP_FRAG_USES_STATIC_BUF && !LWIP_NETIF_TX_SINGLE_PBUF
  u16_t newpbuflen = 0;
   21450:	e03ff40d 	sth	zero,-48(fp)

  /* Copy the IP header in it */
  iphdr = (struct ip_hdr *)rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
#else /* IP_FRAG_USES_STATIC_BUF */
  original_iphdr = (struct ip_hdr *)p->payload;
   21454:	e0bffd17 	ldw	r2,-12(fp)
   21458:	10800117 	ldw	r2,4(r2)
   2145c:	e0bff615 	stw	r2,-40(fp)
  iphdr = original_iphdr;
   21460:	e0bff617 	ldw	r2,-40(fp)
   21464:	e0bff715 	stw	r2,-36(fp)
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
   21468:	e0bff717 	ldw	r2,-36(fp)
   2146c:	10c00183 	ldbu	r3,6(r2)
   21470:	108001c3 	ldbu	r2,7(r2)
   21474:	1004923a 	slli	r2,r2,8
   21478:	10c4b03a 	or	r2,r2,r3
   2147c:	10bfffcc 	andi	r2,r2,65535
   21480:	1004d23a 	srli	r2,r2,8
   21484:	1007883a 	mov	r3,r2
   21488:	e0bff717 	ldw	r2,-36(fp)
   2148c:	11000183 	ldbu	r4,6(r2)
   21490:	108001c3 	ldbu	r2,7(r2)
   21494:	1004923a 	slli	r2,r2,8
   21498:	1104b03a 	or	r2,r2,r4
   2149c:	10bfffcc 	andi	r2,r2,65535
   214a0:	1004923a 	slli	r2,r2,8
   214a4:	1884b03a 	or	r2,r3,r2
   214a8:	e0bff38d 	sth	r2,-50(fp)
  ofo = tmp & IP_OFFMASK;
   214ac:	e0bff38b 	ldhu	r2,-50(fp)
   214b0:	1087ffcc 	andi	r2,r2,8191
   214b4:	e0bff28d 	sth	r2,-54(fp)
  omf = tmp & IP_MF;
   214b8:	e0bff38b 	ldhu	r2,-50(fp)
   214bc:	1088000c 	andi	r2,r2,8192
   214c0:	e0bff80d 	sth	r2,-32(fp)

  left = p->tot_len - IP_HLEN;
   214c4:	e0bffd17 	ldw	r2,-12(fp)
   214c8:	1080020b 	ldhu	r2,8(r2)
   214cc:	10bffb04 	addi	r2,r2,-20
   214d0:	e0bff20d 	sth	r2,-56(fp)

  nfb = (mtu - IP_HLEN) / 8;
   214d4:	e0bff50b 	ldhu	r2,-44(fp)
   214d8:	10bffb04 	addi	r2,r2,-20
   214dc:	1000010e 	bge	r2,zero,214e4 <ip_frag+0xc4>
   214e0:	108001c4 	addi	r2,r2,7
   214e4:	1005d0fa 	srai	r2,r2,3
   214e8:	e0bff88d 	sth	r2,-30(fp)

  while (left) {
   214ec:	0000db06 	br	2185c <ip_frag+0x43c>
    last = (left <= mtu - IP_HLEN);
   214f0:	e0bff20b 	ldhu	r2,-56(fp)
   214f4:	e0fff50b 	ldhu	r3,-44(fp)
   214f8:	18fffb04 	addi	r3,r3,-20
   214fc:	1884403a 	cmpge	r2,r3,r2
   21500:	10803fcc 	andi	r2,r2,255
   21504:	e0bff90d 	sth	r2,-28(fp)

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
   21508:	e0bff28b 	ldhu	r2,-54(fp)
   2150c:	1087ffcc 	andi	r2,r2,8191
   21510:	1007883a 	mov	r3,r2
   21514:	e0bff80b 	ldhu	r2,-32(fp)
   21518:	1884b03a 	or	r2,r3,r2
   2151c:	e0bff38d 	sth	r2,-50(fp)
    if (!last) {
   21520:	e0bff90b 	ldhu	r2,-28(fp)
   21524:	1000031e 	bne	r2,zero,21534 <ip_frag+0x114>
      tmp = tmp | IP_MF;
   21528:	e0bff38b 	ldhu	r2,-50(fp)
   2152c:	10880014 	ori	r2,r2,8192
   21530:	e0bff38d 	sth	r2,-50(fp)
    }

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
   21534:	e0bff90b 	ldhu	r2,-28(fp)
   21538:	1000031e 	bne	r2,zero,21548 <ip_frag+0x128>
   2153c:	e0bff88b 	ldhu	r2,-30(fp)
   21540:	100490fa 	slli	r2,r2,3
   21544:	00000106 	br	2154c <ip_frag+0x12c>
   21548:	e0bff20b 	ldhu	r2,-56(fp)
   2154c:	e0bff98d 	sth	r2,-26(fp)
    /* When not using a static buffer, create a chain of pbufs.
     * The first will be a PBUF_RAM holding the link and IP header.
     * The rest will be PBUF_REFs mirroring the pbuf chain to be fragged,
     * but limited to the size of an mtu.
     */
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
   21550:	01000084 	movi	r4,2
   21554:	01400504 	movi	r5,20
   21558:	000d883a 	mov	r6,zero
   2155c:	0022fa00 	call	22fa0 <pbuf_alloc>
   21560:	e0bffa15 	stw	r2,-24(fp)
    if (rambuf == NULL) {
   21564:	e0bffa17 	ldw	r2,-24(fp)
   21568:	1000021e 	bne	r2,zero,21574 <ip_frag+0x154>
      return ERR_MEM;
   2156c:	00bfffc4 	movi	r2,-1
   21570:	0000bd06 	br	21868 <ip_frag+0x448>
    }
    LWIP_ASSERT("this needs a pbuf in one piece!",
                (p->len >= (IP_HLEN)));
    SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
   21574:	e0bffa17 	ldw	r2,-24(fp)
   21578:	10800117 	ldw	r2,4(r2)
   2157c:	1009883a 	mov	r4,r2
   21580:	e17ff617 	ldw	r5,-40(fp)
   21584:	01800504 	movi	r6,20
   21588:	00041f00 	call	41f0 <memcpy>
    iphdr = (struct ip_hdr *)rambuf->payload;
   2158c:	e0bffa17 	ldw	r2,-24(fp)
   21590:	10800117 	ldw	r2,4(r2)
   21594:	e0bff715 	stw	r2,-36(fp)

    /* Can just adjust p directly for needed offset. */
    p->payload = (u8_t *)p->payload + poff;
   21598:	e0bffd17 	ldw	r2,-12(fp)
   2159c:	10c00117 	ldw	r3,4(r2)
   215a0:	e0bff30b 	ldhu	r2,-52(fp)
   215a4:	1887883a 	add	r3,r3,r2
   215a8:	e0bffd17 	ldw	r2,-12(fp)
   215ac:	10c00115 	stw	r3,4(r2)
    p->len -= poff;
   215b0:	e0bffd17 	ldw	r2,-12(fp)
   215b4:	10c0028b 	ldhu	r3,10(r2)
   215b8:	e0bff30b 	ldhu	r2,-52(fp)
   215bc:	1885c83a 	sub	r2,r3,r2
   215c0:	1007883a 	mov	r3,r2
   215c4:	e0bffd17 	ldw	r2,-12(fp)
   215c8:	10c0028d 	sth	r3,10(r2)

    left_to_copy = cop;
   215cc:	e0bff98b 	ldhu	r2,-26(fp)
   215d0:	e0bff48d 	sth	r2,-46(fp)
    while (left_to_copy) {
   215d4:	00004006 	br	216d8 <ip_frag+0x2b8>
      struct pbuf_custom_ref *pcr;
      newpbuflen = (left_to_copy < p->len) ? left_to_copy : p->len;
   215d8:	e0bffd17 	ldw	r2,-12(fp)
   215dc:	1080028b 	ldhu	r2,10(r2)
   215e0:	e0fff48b 	ldhu	r3,-46(fp)
   215e4:	113fffcc 	andi	r4,r2,65535
   215e8:	197fffcc 	andi	r5,r3,65535
   215ec:	2900012e 	bgeu	r5,r4,215f4 <ip_frag+0x1d4>
   215f0:	1805883a 	mov	r2,r3
   215f4:	e0bff40d 	sth	r2,-48(fp)
      /* Is this pbuf already empty? */
      if (!newpbuflen) {
   215f8:	e0bff40b 	ldhu	r2,-48(fp)
   215fc:	1000041e 	bne	r2,zero,21610 <ip_frag+0x1f0>
        p = p->next;
   21600:	e0bffd17 	ldw	r2,-12(fp)
   21604:	10800017 	ldw	r2,0(r2)
   21608:	e0bffd15 	stw	r2,-12(fp)
        continue;
   2160c:	00003206 	br	216d8 <ip_frag+0x2b8>
      }
      pcr = ip_frag_alloc_pbuf_custom_ref();
   21610:	002136c0 	call	2136c <ip_frag_alloc_pbuf_custom_ref>
   21614:	e0bffb15 	stw	r2,-20(fp)
      if (pcr == NULL) {
   21618:	e0bffb17 	ldw	r2,-20(fp)
   2161c:	1000041e 	bne	r2,zero,21630 <ip_frag+0x210>
        pbuf_free(rambuf);
   21620:	e13ffa17 	ldw	r4,-24(fp)
   21624:	00237600 	call	23760 <pbuf_free>
        return ERR_MEM;
   21628:	00bfffc4 	movi	r2,-1
   2162c:	00008e06 	br	21868 <ip_frag+0x448>
      }
      /* Mirror this pbuf, although we might not need all of it. */
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
   21630:	e0fff40b 	ldhu	r3,-48(fp)
   21634:	e0bffb17 	ldw	r2,-20(fp)
   21638:	e13ffd17 	ldw	r4,-12(fp)
   2163c:	21400117 	ldw	r5,4(r4)
   21640:	e13ff40b 	ldhu	r4,-48(fp)
   21644:	d9400015 	stw	r5,0(sp)
   21648:	d9000115 	stw	r4,4(sp)
   2164c:	010000c4 	movi	r4,3
   21650:	180b883a 	mov	r5,r3
   21654:	01800084 	movi	r6,2
   21658:	100f883a 	mov	r7,r2
   2165c:	00233100 	call	23310 <pbuf_alloced_custom>
   21660:	e0bffc15 	stw	r2,-16(fp)
      if (newpbuf == NULL) {
   21664:	e0bffc17 	ldw	r2,-16(fp)
   21668:	1000061e 	bne	r2,zero,21684 <ip_frag+0x264>
        ip_frag_free_pbuf_custom_ref(pcr);
   2166c:	e13ffb17 	ldw	r4,-20(fp)
   21670:	00213980 	call	21398 <ip_frag_free_pbuf_custom_ref>
        pbuf_free(rambuf);
   21674:	e13ffa17 	ldw	r4,-24(fp)
   21678:	00237600 	call	23760 <pbuf_free>
        return ERR_MEM;
   2167c:	00bfffc4 	movi	r2,-1
   21680:	00007906 	br	21868 <ip_frag+0x448>
      }
      pbuf_ref(p);
   21684:	e13ffd17 	ldw	r4,-12(fp)
   21688:	00238f00 	call	238f0 <pbuf_ref>
      pcr->original = p;
   2168c:	e0bffb17 	ldw	r2,-20(fp)
   21690:	e0fffd17 	ldw	r3,-12(fp)
   21694:	10c00515 	stw	r3,20(r2)
      pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
   21698:	e0bffb17 	ldw	r2,-20(fp)
   2169c:	00c000b4 	movhi	r3,2
   216a0:	18c4f304 	addi	r3,r3,5068
   216a4:	10c00415 	stw	r3,16(r2)

      /* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
       * so that it is removed when pbuf_dechain is later called on rambuf.
       */
      pbuf_cat(rambuf, newpbuf);
   216a8:	e13ffa17 	ldw	r4,-24(fp)
   216ac:	e17ffc17 	ldw	r5,-16(fp)
   216b0:	00239500 	call	23950 <pbuf_cat>
      left_to_copy -= newpbuflen;
   216b4:	e0fff48b 	ldhu	r3,-46(fp)
   216b8:	e0bff40b 	ldhu	r2,-48(fp)
   216bc:	1885c83a 	sub	r2,r3,r2
   216c0:	e0bff48d 	sth	r2,-46(fp)
      if (left_to_copy) {
   216c4:	e0bff48b 	ldhu	r2,-46(fp)
   216c8:	10000326 	beq	r2,zero,216d8 <ip_frag+0x2b8>
        p = p->next;
   216cc:	e0bffd17 	ldw	r2,-12(fp)
   216d0:	10800017 	ldw	r2,0(r2)
   216d4:	e0bffd15 	stw	r2,-12(fp)
    /* Can just adjust p directly for needed offset. */
    p->payload = (u8_t *)p->payload + poff;
    p->len -= poff;

    left_to_copy = cop;
    while (left_to_copy) {
   216d8:	e0bff48b 	ldhu	r2,-46(fp)
   216dc:	103fbe1e 	bne	r2,zero,215d8 <ip_frag+0x1b8>
      left_to_copy -= newpbuflen;
      if (left_to_copy) {
        p = p->next;
      }
    }
    poff = newpbuflen;
   216e0:	e0bff40b 	ldhu	r2,-48(fp)
   216e4:	e0bff30d 	sth	r2,-52(fp)
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
   216e8:	e0bff38b 	ldhu	r2,-50(fp)
   216ec:	1004d23a 	srli	r2,r2,8
   216f0:	1007883a 	mov	r3,r2
   216f4:	e0bff38b 	ldhu	r2,-50(fp)
   216f8:	1004923a 	slli	r2,r2,8
   216fc:	1884b03a 	or	r2,r3,r2
   21700:	1007883a 	mov	r3,r2
   21704:	e0bff717 	ldw	r2,-36(fp)
   21708:	193fffcc 	andi	r4,r3,65535
   2170c:	21003fcc 	andi	r4,r4,255
   21710:	11400183 	ldbu	r5,6(r2)
   21714:	280a703a 	and	r5,r5,zero
   21718:	2908b03a 	or	r4,r5,r4
   2171c:	11000185 	stb	r4,6(r2)
   21720:	18ffffcc 	andi	r3,r3,65535
   21724:	1806d23a 	srli	r3,r3,8
   21728:	18ffffcc 	andi	r3,r3,65535
   2172c:	110001c3 	ldbu	r4,7(r2)
   21730:	2008703a 	and	r4,r4,zero
   21734:	20c6b03a 	or	r3,r4,r3
   21738:	10c001c5 	stb	r3,7(r2)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
   2173c:	e0bff98b 	ldhu	r2,-26(fp)
   21740:	10800504 	addi	r2,r2,20
   21744:	10bfc00c 	andi	r2,r2,65280
   21748:	1005d23a 	srai	r2,r2,8
   2174c:	1007883a 	mov	r3,r2
   21750:	e0bff98b 	ldhu	r2,-26(fp)
   21754:	10800504 	addi	r2,r2,20
   21758:	1004923a 	slli	r2,r2,8
   2175c:	1884b03a 	or	r2,r3,r2
   21760:	1007883a 	mov	r3,r2
   21764:	e0bff717 	ldw	r2,-36(fp)
   21768:	193fffcc 	andi	r4,r3,65535
   2176c:	21003fcc 	andi	r4,r4,255
   21770:	11400083 	ldbu	r5,2(r2)
   21774:	280a703a 	and	r5,r5,zero
   21778:	2908b03a 	or	r4,r5,r4
   2177c:	11000085 	stb	r4,2(r2)
   21780:	18ffffcc 	andi	r3,r3,65535
   21784:	1806d23a 	srli	r3,r3,8
   21788:	18ffffcc 	andi	r3,r3,65535
   2178c:	110000c3 	ldbu	r4,3(r2)
   21790:	2008703a 	and	r4,r4,zero
   21794:	20c6b03a 	or	r3,r4,r3
   21798:	10c000c5 	stb	r3,3(r2)
    IPH_CHKSUM_SET(iphdr, 0);
   2179c:	e0bff717 	ldw	r2,-36(fp)
   217a0:	10c00283 	ldbu	r3,10(r2)
   217a4:	1806703a 	and	r3,r3,zero
   217a8:	10c00285 	stb	r3,10(r2)
   217ac:	10c002c3 	ldbu	r3,11(r2)
   217b0:	1806703a 	and	r3,r3,zero
   217b4:	10c002c5 	stb	r3,11(r2)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
   217b8:	e13ff717 	ldw	r4,-36(fp)
   217bc:	01400504 	movi	r5,20
   217c0:	003e6d40 	call	3e6d4 <inet_chksum>
   217c4:	1007883a 	mov	r3,r2
   217c8:	e0bff717 	ldw	r2,-36(fp)
   217cc:	193fffcc 	andi	r4,r3,65535
   217d0:	21003fcc 	andi	r4,r4,255
   217d4:	11400283 	ldbu	r5,10(r2)
   217d8:	280a703a 	and	r5,r5,zero
   217dc:	2908b03a 	or	r4,r5,r4
   217e0:	11000285 	stb	r4,10(r2)
   217e4:	18ffffcc 	andi	r3,r3,65535
   217e8:	1806d23a 	srli	r3,r3,8
   217ec:	18ffffcc 	andi	r3,r3,65535
   217f0:	110002c3 	ldbu	r4,11(r2)
   217f4:	2008703a 	and	r4,r4,zero
   217f8:	20c6b03a 	or	r3,r4,r3
   217fc:	10c002c5 	stb	r3,11(r2)
    }
#else /* IP_FRAG_USES_STATIC_BUF */
    /* No need for separate header pbuf - we allowed room for it in rambuf
     * when allocated.
     */
    netif->output(netif, rambuf, dest);
   21800:	e0bffe17 	ldw	r2,-8(fp)
   21804:	10800517 	ldw	r2,20(r2)
   21808:	e13ffe17 	ldw	r4,-8(fp)
   2180c:	e17ffa17 	ldw	r5,-24(fp)
   21810:	e1bfff17 	ldw	r6,-4(fp)
   21814:	103ee83a 	callr	r2
    IPFRAG_STATS_INC(ip_frag.xmit);
   21818:	008001f4 	movhi	r2,7
   2181c:	10ac6e04 	addi	r2,r2,-20040
   21820:	10801817 	ldw	r2,96(r2)
   21824:	10c00044 	addi	r3,r2,1
   21828:	008001f4 	movhi	r2,7
   2182c:	10ac6e04 	addi	r2,r2,-20040
   21830:	10c01815 	stw	r3,96(r2)
     * recreate it next time round the loop. If we're lucky the hardware
     * will have already sent the packet, the free will really free, and
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
   21834:	e13ffa17 	ldw	r4,-24(fp)
   21838:	00237600 	call	23760 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
   2183c:	e0fff20b 	ldhu	r3,-56(fp)
   21840:	e0bff98b 	ldhu	r2,-26(fp)
   21844:	1885c83a 	sub	r2,r3,r2
   21848:	e0bff20d 	sth	r2,-56(fp)
    ofo += nfb;
   2184c:	e0fff28b 	ldhu	r3,-54(fp)
   21850:	e0bff88b 	ldhu	r2,-30(fp)
   21854:	1885883a 	add	r2,r3,r2
   21858:	e0bff28d 	sth	r2,-54(fp)

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
   2185c:	e0bff20b 	ldhu	r2,-56(fp)
   21860:	103f231e 	bne	r2,zero,214f0 <ip_frag+0xd0>
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
   21864:	0005883a 	mov	r2,zero
}
   21868:	e037883a 	mov	sp,fp
   2186c:	dfc00117 	ldw	ra,4(sp)
   21870:	df000017 	ldw	fp,0(sp)
   21874:	dec00204 	addi	sp,sp,8
   21878:	f800283a 	ret

0002187c <plug_holes>:
 * This assumes access to the heap is protected by the calling function
 * already.
 */
static void
plug_holes(struct mem *mem)
{
   2187c:	defffc04 	addi	sp,sp,-16
   21880:	df000315 	stw	fp,12(sp)
   21884:	df000304 	addi	fp,sp,12
   21888:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);

  nmem = (struct mem *)(void *)&ram[mem->next];
   2188c:	d0e92c17 	ldw	r3,-23376(gp)
   21890:	e0bfff17 	ldw	r2,-4(fp)
   21894:	1080000b 	ldhu	r2,0(r2)
   21898:	10bfffcc 	andi	r2,r2,65535
   2189c:	1885883a 	add	r2,r3,r2
   218a0:	e0bffd15 	stw	r2,-12(fp)
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
   218a4:	e0ffff17 	ldw	r3,-4(fp)
   218a8:	e0bffd17 	ldw	r2,-12(fp)
   218ac:	18801926 	beq	r3,r2,21914 <plug_holes+0x98>
   218b0:	e0bffd17 	ldw	r2,-12(fp)
   218b4:	10800103 	ldbu	r2,4(r2)
   218b8:	10803fcc 	andi	r2,r2,255
   218bc:	1000151e 	bne	r2,zero,21914 <plug_holes+0x98>
   218c0:	d0a92d17 	ldw	r2,-23372(gp)
   218c4:	e0fffd17 	ldw	r3,-12(fp)
   218c8:	18801226 	beq	r3,r2,21914 <plug_holes+0x98>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
   218cc:	d0e92e17 	ldw	r3,-23368(gp)
   218d0:	e0bffd17 	ldw	r2,-12(fp)
   218d4:	1880021e 	bne	r3,r2,218e0 <plug_holes+0x64>
      lfree = mem;
   218d8:	e0bfff17 	ldw	r2,-4(fp)
   218dc:	d0a92e15 	stw	r2,-23368(gp)
    }
    mem->next = nmem->next;
   218e0:	e0bffd17 	ldw	r2,-12(fp)
   218e4:	10c0000b 	ldhu	r3,0(r2)
   218e8:	e0bfff17 	ldw	r2,-4(fp)
   218ec:	10c0000d 	sth	r3,0(r2)
    ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
   218f0:	d0e92c17 	ldw	r3,-23376(gp)
   218f4:	e0bffd17 	ldw	r2,-12(fp)
   218f8:	1080000b 	ldhu	r2,0(r2)
   218fc:	10bfffcc 	andi	r2,r2,65535
   21900:	1885883a 	add	r2,r3,r2
   21904:	e13fff17 	ldw	r4,-4(fp)
   21908:	d0e92c17 	ldw	r3,-23376(gp)
   2190c:	20c7c83a 	sub	r3,r4,r3
   21910:	10c0008d 	sth	r3,2(r2)
  }

  /* plug hole backward */
  pmem = (struct mem *)(void *)&ram[mem->prev];
   21914:	d0e92c17 	ldw	r3,-23376(gp)
   21918:	e0bfff17 	ldw	r2,-4(fp)
   2191c:	1080008b 	ldhu	r2,2(r2)
   21920:	10bfffcc 	andi	r2,r2,65535
   21924:	1885883a 	add	r2,r3,r2
   21928:	e0bffe15 	stw	r2,-8(fp)
  if (pmem != mem && pmem->used == 0) {
   2192c:	e0fffe17 	ldw	r3,-8(fp)
   21930:	e0bfff17 	ldw	r2,-4(fp)
   21934:	18801626 	beq	r3,r2,21990 <plug_holes+0x114>
   21938:	e0bffe17 	ldw	r2,-8(fp)
   2193c:	10800103 	ldbu	r2,4(r2)
   21940:	10803fcc 	andi	r2,r2,255
   21944:	1000121e 	bne	r2,zero,21990 <plug_holes+0x114>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
   21948:	d0e92e17 	ldw	r3,-23368(gp)
   2194c:	e0bfff17 	ldw	r2,-4(fp)
   21950:	1880021e 	bne	r3,r2,2195c <plug_holes+0xe0>
      lfree = pmem;
   21954:	e0bffe17 	ldw	r2,-8(fp)
   21958:	d0a92e15 	stw	r2,-23368(gp)
    }
    pmem->next = mem->next;
   2195c:	e0bfff17 	ldw	r2,-4(fp)
   21960:	10c0000b 	ldhu	r3,0(r2)
   21964:	e0bffe17 	ldw	r2,-8(fp)
   21968:	10c0000d 	sth	r3,0(r2)
    ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
   2196c:	d0e92c17 	ldw	r3,-23376(gp)
   21970:	e0bfff17 	ldw	r2,-4(fp)
   21974:	1080000b 	ldhu	r2,0(r2)
   21978:	10bfffcc 	andi	r2,r2,65535
   2197c:	1885883a 	add	r2,r3,r2
   21980:	e13ffe17 	ldw	r4,-8(fp)
   21984:	d0e92c17 	ldw	r3,-23376(gp)
   21988:	20c7c83a 	sub	r3,r4,r3
   2198c:	10c0008d 	sth	r3,2(r2)
  }
}
   21990:	e037883a 	mov	sp,fp
   21994:	df000017 	ldw	fp,0(sp)
   21998:	dec00104 	addi	sp,sp,4
   2199c:	f800283a 	ret

000219a0 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
   219a0:	defffd04 	addi	sp,sp,-12
   219a4:	dfc00215 	stw	ra,8(sp)
   219a8:	df000115 	stw	fp,4(sp)
   219ac:	df000104 	addi	fp,sp,4

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
   219b0:	008001b4 	movhi	r2,6
   219b4:	108c6904 	addi	r2,r2,12708
   219b8:	10c000c4 	addi	r3,r2,3
   219bc:	00bfff04 	movi	r2,-4
   219c0:	1884703a 	and	r2,r3,r2
   219c4:	d0a92c15 	stw	r2,-23376(gp)
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
   219c8:	d0a92c17 	ldw	r2,-23376(gp)
   219cc:	e0bfff15 	stw	r2,-4(fp)
  mem->next = MEM_SIZE_ALIGNED;
   219d0:	e0bfff17 	ldw	r2,-4(fp)
   219d4:	00e00004 	movi	r3,-32768
   219d8:	10c0000d 	sth	r3,0(r2)
  mem->prev = 0;
   219dc:	e0bfff17 	ldw	r2,-4(fp)
   219e0:	1000008d 	sth	zero,2(r2)
  mem->used = 0;
   219e4:	e0bfff17 	ldw	r2,-4(fp)
   219e8:	10000105 	stb	zero,4(r2)
  /* initialize the end of the heap */
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
   219ec:	d0e92c17 	ldw	r3,-23376(gp)
   219f0:	00a00014 	movui	r2,32768
   219f4:	1885883a 	add	r2,r3,r2
   219f8:	d0a92d15 	stw	r2,-23372(gp)
  ram_end->used = 1;
   219fc:	d0a92d17 	ldw	r2,-23372(gp)
   21a00:	00c00044 	movi	r3,1
   21a04:	10c00105 	stb	r3,4(r2)
  ram_end->next = MEM_SIZE_ALIGNED;
   21a08:	d0a92d17 	ldw	r2,-23372(gp)
   21a0c:	00e00004 	movi	r3,-32768
   21a10:	10c0000d 	sth	r3,0(r2)
  ram_end->prev = MEM_SIZE_ALIGNED;
   21a14:	d0a92d17 	ldw	r2,-23372(gp)
   21a18:	00e00004 	movi	r3,-32768
   21a1c:	10c0008d 	sth	r3,2(r2)

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;
   21a20:	d0a92c17 	ldw	r2,-23376(gp)
   21a24:	d0a92e15 	stw	r2,-23368(gp)

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
   21a28:	008001f4 	movhi	r2,7
   21a2c:	10ac6e04 	addi	r2,r2,-20040
   21a30:	00e00004 	movi	r3,-32768
   21a34:	10c0540d 	sth	r3,336(r2)

  if(sys_mutex_new(&mem_mutex) != ERR_OK) {
   21a38:	d1292f04 	addi	r4,gp,-23364
   21a3c:	001b4200 	call	1b420 <sys_mutex_new>
    LWIP_ASSERT("failed to create mem_mutex", 0);
  }
}
   21a40:	e037883a 	mov	sp,fp
   21a44:	dfc00117 	ldw	ra,4(sp)
   21a48:	df000017 	ldw	fp,0(sp)
   21a4c:	dec00204 	addi	sp,sp,8
   21a50:	f800283a 	ret

00021a54 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
   21a54:	defffc04 	addi	sp,sp,-16
   21a58:	dfc00315 	stw	ra,12(sp)
   21a5c:	df000215 	stw	fp,8(sp)
   21a60:	df000204 	addi	fp,sp,8
   21a64:	e13fff15 	stw	r4,-4(fp)
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
   21a68:	e0bfff17 	ldw	r2,-4(fp)
   21a6c:	10003426 	beq	r2,zero,21b40 <mem_free+0xec>
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
   21a70:	d0a92c17 	ldw	r2,-23376(gp)
   21a74:	e0ffff17 	ldw	r3,-4(fp)
   21a78:	18800336 	bltu	r3,r2,21a88 <mem_free+0x34>
   21a7c:	d0a92d17 	ldw	r2,-23372(gp)
   21a80:	e0ffff17 	ldw	r3,-4(fp)
   21a84:	18800e36 	bltu	r3,r2,21ac0 <mem_free+0x6c>
    SYS_ARCH_DECL_PROTECT(lev);
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
   21a88:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   21a8c:	10000126 	beq	r2,zero,21a94 <mem_free+0x40>
   21a90:	00110d00 	call	110d0 <vTaskEnterCritical>
    MEM_STATS_INC(illegal);
   21a94:	008001f4 	movhi	r2,7
   21a98:	10ac6e04 	addi	r2,r2,-20040
   21a9c:	10805717 	ldw	r2,348(r2)
   21aa0:	10c00044 	addi	r3,r2,1
   21aa4:	008001f4 	movhi	r2,7
   21aa8:	10ac6e04 	addi	r2,r2,-20040
   21aac:	10c05715 	stw	r3,348(r2)
    SYS_ARCH_UNPROTECT(lev);
   21ab0:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   21ab4:	10002426 	beq	r2,zero,21b48 <mem_free+0xf4>
   21ab8:	00111100 	call	11110 <vTaskExitCritical>
    return;
   21abc:	00002206 	br	21b48 <mem_free+0xf4>
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
   21ac0:	d1292f04 	addi	r4,gp,-23364
   21ac4:	001b4dc0 	call	1b4dc <sys_mutex_lock>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
   21ac8:	e0bfff17 	ldw	r2,-4(fp)
   21acc:	10bffe04 	addi	r2,r2,-8
   21ad0:	e0bffe15 	stw	r2,-8(fp)
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;
   21ad4:	e0bffe17 	ldw	r2,-8(fp)
   21ad8:	10000105 	stb	zero,4(r2)

  if (mem < lfree) {
   21adc:	d0a92e17 	ldw	r2,-23368(gp)
   21ae0:	e0fffe17 	ldw	r3,-8(fp)
   21ae4:	1880022e 	bgeu	r3,r2,21af0 <mem_free+0x9c>
    /* the newly freed struct is now the lowest */
    lfree = mem;
   21ae8:	e0bffe17 	ldw	r2,-8(fp)
   21aec:	d0a92e15 	stw	r2,-23368(gp)
  }

  MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));
   21af0:	008001f4 	movhi	r2,7
   21af4:	10ac6e04 	addi	r2,r2,-20040
   21af8:	10c0548b 	ldhu	r3,338(r2)
   21afc:	e13ffe17 	ldw	r4,-8(fp)
   21b00:	d0a92c17 	ldw	r2,-23376(gp)
   21b04:	2085c83a 	sub	r2,r4,r2
   21b08:	1009883a 	mov	r4,r2
   21b0c:	e0bffe17 	ldw	r2,-8(fp)
   21b10:	1080000b 	ldhu	r2,0(r2)
   21b14:	2085c83a 	sub	r2,r4,r2
   21b18:	1885883a 	add	r2,r3,r2
   21b1c:	1007883a 	mov	r3,r2
   21b20:	008001f4 	movhi	r2,7
   21b24:	10ac6e04 	addi	r2,r2,-20040
   21b28:	10c0548d 	sth	r3,338(r2)

  /* finally, see if prev or next are free also */
  plug_holes(mem);
   21b2c:	e13ffe17 	ldw	r4,-8(fp)
   21b30:	002187c0 	call	2187c <plug_holes>
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
   21b34:	d1292f04 	addi	r4,gp,-23364
   21b38:	001b52c0 	call	1b52c <sys_mutex_unlock>
   21b3c:	00000306 	br	21b4c <mem_free+0xf8>
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
   21b40:	0001883a 	nop
   21b44:	00000106 	br	21b4c <mem_free+0xf8>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
   21b48:	0001883a 	nop
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
   21b4c:	e037883a 	mov	sp,fp
   21b50:	dfc00117 	ldw	ra,4(sp)
   21b54:	df000017 	ldw	fp,0(sp)
   21b58:	dec00204 	addi	sp,sp,8
   21b5c:	f800283a 	ret

00021b60 <mem_trim>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_trim(void *rmem, mem_size_t newsize)
{
   21b60:	defff804 	addi	sp,sp,-32
   21b64:	dfc00715 	stw	ra,28(sp)
   21b68:	df000615 	stw	fp,24(sp)
   21b6c:	df000604 	addi	fp,sp,24
   21b70:	e13ffe15 	stw	r4,-8(fp)
   21b74:	2805883a 	mov	r2,r5
   21b78:	e0bfff0d 	sth	r2,-4(fp)
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
   21b7c:	e0bfff0b 	ldhu	r2,-4(fp)
   21b80:	108000c4 	addi	r2,r2,3
   21b84:	1007883a 	mov	r3,r2
   21b88:	00bfff04 	movi	r2,-4
   21b8c:	1884703a 	and	r2,r3,r2
   21b90:	e0bfff0d 	sth	r2,-4(fp)

  if(newsize < MIN_SIZE_ALIGNED) {
   21b94:	e0bfff0b 	ldhu	r2,-4(fp)
   21b98:	10800328 	cmpgeui	r2,r2,12
   21b9c:	1000021e 	bne	r2,zero,21ba8 <mem_trim+0x48>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
   21ba0:	00800304 	movi	r2,12
   21ba4:	e0bfff0d 	sth	r2,-4(fp)
  }

  if (newsize > MEM_SIZE_ALIGNED) {
   21ba8:	e0bfff0b 	ldhu	r2,-4(fp)
   21bac:	10a00070 	cmpltui	r2,r2,32769
   21bb0:	1000021e 	bne	r2,zero,21bbc <mem_trim+0x5c>
    return NULL;
   21bb4:	0005883a 	mov	r2,zero
   21bb8:	0000a606 	br	21e54 <mem_trim+0x2f4>
  }

  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
   21bbc:	d0a92c17 	ldw	r2,-23376(gp)
   21bc0:	e0fffe17 	ldw	r3,-8(fp)
   21bc4:	18800336 	bltu	r3,r2,21bd4 <mem_trim+0x74>
   21bc8:	d0a92d17 	ldw	r2,-23372(gp)
   21bcc:	e0fffe17 	ldw	r3,-8(fp)
   21bd0:	18800f36 	bltu	r3,r2,21c10 <mem_trim+0xb0>
    SYS_ARCH_DECL_PROTECT(lev);
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_trim: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
   21bd4:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   21bd8:	10000126 	beq	r2,zero,21be0 <mem_trim+0x80>
   21bdc:	00110d00 	call	110d0 <vTaskEnterCritical>
    MEM_STATS_INC(illegal);
   21be0:	008001f4 	movhi	r2,7
   21be4:	10ac6e04 	addi	r2,r2,-20040
   21be8:	10805717 	ldw	r2,348(r2)
   21bec:	10c00044 	addi	r3,r2,1
   21bf0:	008001f4 	movhi	r2,7
   21bf4:	10ac6e04 	addi	r2,r2,-20040
   21bf8:	10c05715 	stw	r3,348(r2)
    SYS_ARCH_UNPROTECT(lev);
   21bfc:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   21c00:	10000126 	beq	r2,zero,21c08 <mem_trim+0xa8>
   21c04:	00111100 	call	11110 <vTaskExitCritical>
    return rmem;
   21c08:	e0bffe17 	ldw	r2,-8(fp)
   21c0c:	00009106 	br	21e54 <mem_trim+0x2f4>
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
   21c10:	e0bffe17 	ldw	r2,-8(fp)
   21c14:	10bffe04 	addi	r2,r2,-8
   21c18:	e0bffa15 	stw	r2,-24(fp)
  /* ... and its offset pointer */
  ptr = (mem_size_t)((u8_t *)mem - ram);
   21c1c:	e0fffa17 	ldw	r3,-24(fp)
   21c20:	d0a92c17 	ldw	r2,-23376(gp)
   21c24:	1885c83a 	sub	r2,r3,r2
   21c28:	e0bffb0d 	sth	r2,-20(fp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
   21c2c:	e0bffa17 	ldw	r2,-24(fp)
   21c30:	10c0000b 	ldhu	r3,0(r2)
   21c34:	e0bffb0b 	ldhu	r2,-20(fp)
   21c38:	1885c83a 	sub	r2,r3,r2
   21c3c:	10bffe04 	addi	r2,r2,-8
   21c40:	e0bffb8d 	sth	r2,-18(fp)
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
  if (newsize > size) {
   21c44:	e0bfff0b 	ldhu	r2,-4(fp)
   21c48:	e0fffb8b 	ldhu	r3,-18(fp)
   21c4c:	1880022e 	bgeu	r3,r2,21c58 <mem_trim+0xf8>
    /* not supported */
    return NULL;
   21c50:	0005883a 	mov	r2,zero
   21c54:	00007f06 	br	21e54 <mem_trim+0x2f4>
  }
  if (newsize == size) {
   21c58:	e0ffff0b 	ldhu	r3,-4(fp)
   21c5c:	e0bffb8b 	ldhu	r2,-18(fp)
   21c60:	1880021e 	bne	r3,r2,21c6c <mem_trim+0x10c>
    /* No change in size, simply return */
    return rmem;
   21c64:	e0bffe17 	ldw	r2,-8(fp)
   21c68:	00007a06 	br	21e54 <mem_trim+0x2f4>
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
   21c6c:	d1292f04 	addi	r4,gp,-23364
   21c70:	001b4dc0 	call	1b4dc <sys_mutex_lock>

  mem2 = (struct mem *)(void *)&ram[mem->next];
   21c74:	d0e92c17 	ldw	r3,-23376(gp)
   21c78:	e0bffa17 	ldw	r2,-24(fp)
   21c7c:	1080000b 	ldhu	r2,0(r2)
   21c80:	10bfffcc 	andi	r2,r2,65535
   21c84:	1885883a 	add	r2,r3,r2
   21c88:	e0bffc15 	stw	r2,-16(fp)
  if(mem2->used == 0) {
   21c8c:	e0bffc17 	ldw	r2,-16(fp)
   21c90:	10800103 	ldbu	r2,4(r2)
   21c94:	10803fcc 	andi	r2,r2,255
   21c98:	1000361e 	bne	r2,zero,21d74 <mem_trim+0x214>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
   21c9c:	e0bffc17 	ldw	r2,-16(fp)
   21ca0:	1080000b 	ldhu	r2,0(r2)
   21ca4:	e0bffd0d 	sth	r2,-12(fp)
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
   21ca8:	e0fffb0b 	ldhu	r3,-20(fp)
   21cac:	e0bfff0b 	ldhu	r2,-4(fp)
   21cb0:	1885883a 	add	r2,r3,r2
   21cb4:	10800204 	addi	r2,r2,8
   21cb8:	e0bffd8d 	sth	r2,-10(fp)
    if (lfree == mem2) {
   21cbc:	d0e92e17 	ldw	r3,-23368(gp)
   21cc0:	e0bffc17 	ldw	r2,-16(fp)
   21cc4:	1880041e 	bne	r3,r2,21cd8 <mem_trim+0x178>
      lfree = (struct mem *)(void *)&ram[ptr2];
   21cc8:	d0e92c17 	ldw	r3,-23376(gp)
   21ccc:	e0bffd8b 	ldhu	r2,-10(fp)
   21cd0:	1885883a 	add	r2,r3,r2
   21cd4:	d0a92e15 	stw	r2,-23368(gp)
    }
    mem2 = (struct mem *)(void *)&ram[ptr2];
   21cd8:	d0e92c17 	ldw	r3,-23376(gp)
   21cdc:	e0bffd8b 	ldhu	r2,-10(fp)
   21ce0:	1885883a 	add	r2,r3,r2
   21ce4:	e0bffc15 	stw	r2,-16(fp)
    mem2->used = 0;
   21ce8:	e0bffc17 	ldw	r2,-16(fp)
   21cec:	10000105 	stb	zero,4(r2)
    /* restore the next pointer */
    mem2->next = next;
   21cf0:	e0bffc17 	ldw	r2,-16(fp)
   21cf4:	e0fffd0b 	ldhu	r3,-12(fp)
   21cf8:	10c0000d 	sth	r3,0(r2)
    /* link it back to mem */
    mem2->prev = ptr;
   21cfc:	e0bffc17 	ldw	r2,-16(fp)
   21d00:	e0fffb0b 	ldhu	r3,-20(fp)
   21d04:	10c0008d 	sth	r3,2(r2)
    /* link mem to it */
    mem->next = ptr2;
   21d08:	e0bffa17 	ldw	r2,-24(fp)
   21d0c:	e0fffd8b 	ldhu	r3,-10(fp)
   21d10:	10c0000d 	sth	r3,0(r2)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
   21d14:	e0bffc17 	ldw	r2,-16(fp)
   21d18:	1080000b 	ldhu	r2,0(r2)
   21d1c:	10ffffcc 	andi	r3,r2,65535
   21d20:	00a00014 	movui	r2,32768
   21d24:	18800726 	beq	r3,r2,21d44 <mem_trim+0x1e4>
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
   21d28:	d0e92c17 	ldw	r3,-23376(gp)
   21d2c:	e0bffc17 	ldw	r2,-16(fp)
   21d30:	1080000b 	ldhu	r2,0(r2)
   21d34:	10bfffcc 	andi	r2,r2,65535
   21d38:	1885883a 	add	r2,r3,r2
   21d3c:	e0fffd8b 	ldhu	r3,-10(fp)
   21d40:	10c0008d 	sth	r3,2(r2)
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
   21d44:	008001f4 	movhi	r2,7
   21d48:	10ac6e04 	addi	r2,r2,-20040
   21d4c:	10c0548b 	ldhu	r3,338(r2)
   21d50:	e13fff0b 	ldhu	r4,-4(fp)
   21d54:	e0bffb8b 	ldhu	r2,-18(fp)
   21d58:	2085c83a 	sub	r2,r4,r2
   21d5c:	1885883a 	add	r2,r3,r2
   21d60:	1007883a 	mov	r3,r2
   21d64:	008001f4 	movhi	r2,7
   21d68:	10ac6e04 	addi	r2,r2,-20040
   21d6c:	10c0548d 	sth	r3,338(r2)
   21d70:	00003506 	br	21e48 <mem_trim+0x2e8>
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
   21d74:	e0bfff0b 	ldhu	r2,-4(fp)
   21d78:	10800504 	addi	r2,r2,20
   21d7c:	e0fffb8b 	ldhu	r3,-18(fp)
   21d80:	18803136 	bltu	r3,r2,21e48 <mem_trim+0x2e8>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
   21d84:	e0fffb0b 	ldhu	r3,-20(fp)
   21d88:	e0bfff0b 	ldhu	r2,-4(fp)
   21d8c:	1885883a 	add	r2,r3,r2
   21d90:	10800204 	addi	r2,r2,8
   21d94:	e0bffd8d 	sth	r2,-10(fp)
    mem2 = (struct mem *)(void *)&ram[ptr2];
   21d98:	d0e92c17 	ldw	r3,-23376(gp)
   21d9c:	e0bffd8b 	ldhu	r2,-10(fp)
   21da0:	1885883a 	add	r2,r3,r2
   21da4:	e0bffc15 	stw	r2,-16(fp)
    if (mem2 < lfree) {
   21da8:	d0a92e17 	ldw	r2,-23368(gp)
   21dac:	e0fffc17 	ldw	r3,-16(fp)
   21db0:	1880022e 	bgeu	r3,r2,21dbc <mem_trim+0x25c>
      lfree = mem2;
   21db4:	e0bffc17 	ldw	r2,-16(fp)
   21db8:	d0a92e15 	stw	r2,-23368(gp)
    }
    mem2->used = 0;
   21dbc:	e0bffc17 	ldw	r2,-16(fp)
   21dc0:	10000105 	stb	zero,4(r2)
    mem2->next = mem->next;
   21dc4:	e0bffa17 	ldw	r2,-24(fp)
   21dc8:	10c0000b 	ldhu	r3,0(r2)
   21dcc:	e0bffc17 	ldw	r2,-16(fp)
   21dd0:	10c0000d 	sth	r3,0(r2)
    mem2->prev = ptr;
   21dd4:	e0bffc17 	ldw	r2,-16(fp)
   21dd8:	e0fffb0b 	ldhu	r3,-20(fp)
   21ddc:	10c0008d 	sth	r3,2(r2)
    mem->next = ptr2;
   21de0:	e0bffa17 	ldw	r2,-24(fp)
   21de4:	e0fffd8b 	ldhu	r3,-10(fp)
   21de8:	10c0000d 	sth	r3,0(r2)
    if (mem2->next != MEM_SIZE_ALIGNED) {
   21dec:	e0bffc17 	ldw	r2,-16(fp)
   21df0:	1080000b 	ldhu	r2,0(r2)
   21df4:	10ffffcc 	andi	r3,r2,65535
   21df8:	00a00014 	movui	r2,32768
   21dfc:	18800726 	beq	r3,r2,21e1c <mem_trim+0x2bc>
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
   21e00:	d0e92c17 	ldw	r3,-23376(gp)
   21e04:	e0bffc17 	ldw	r2,-16(fp)
   21e08:	1080000b 	ldhu	r2,0(r2)
   21e0c:	10bfffcc 	andi	r2,r2,65535
   21e10:	1885883a 	add	r2,r3,r2
   21e14:	e0fffd8b 	ldhu	r3,-10(fp)
   21e18:	10c0008d 	sth	r3,2(r2)
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
   21e1c:	008001f4 	movhi	r2,7
   21e20:	10ac6e04 	addi	r2,r2,-20040
   21e24:	10c0548b 	ldhu	r3,338(r2)
   21e28:	e13fff0b 	ldhu	r4,-4(fp)
   21e2c:	e0bffb8b 	ldhu	r2,-18(fp)
   21e30:	2085c83a 	sub	r2,r4,r2
   21e34:	1885883a 	add	r2,r3,r2
   21e38:	1007883a 	mov	r3,r2
   21e3c:	008001f4 	movhi	r2,7
   21e40:	10ac6e04 	addi	r2,r2,-20040
   21e44:	10c0548d 	sth	r3,338(r2)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
   21e48:	d1292f04 	addi	r4,gp,-23364
   21e4c:	001b52c0 	call	1b52c <sys_mutex_unlock>
  return rmem;
   21e50:	e0bffe17 	ldw	r2,-8(fp)
}
   21e54:	e037883a 	mov	sp,fp
   21e58:	dfc00117 	ldw	ra,4(sp)
   21e5c:	df000017 	ldw	fp,0(sp)
   21e60:	dec00204 	addi	sp,sp,8
   21e64:	f800283a 	ret

00021e68 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
   21e68:	defff804 	addi	sp,sp,-32
   21e6c:	dfc00715 	stw	ra,28(sp)
   21e70:	df000615 	stw	fp,24(sp)
   21e74:	df000604 	addi	fp,sp,24
   21e78:	2005883a 	mov	r2,r4
   21e7c:	e0bfff0d 	sth	r2,-4(fp)
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
   21e80:	e0bfff0b 	ldhu	r2,-4(fp)
   21e84:	1000021e 	bne	r2,zero,21e90 <mem_malloc+0x28>
    return NULL;
   21e88:	0005883a 	mov	r2,zero
   21e8c:	0000bd06 	br	22184 <mem_malloc+0x31c>
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
   21e90:	e0bfff0b 	ldhu	r2,-4(fp)
   21e94:	108000c4 	addi	r2,r2,3
   21e98:	1007883a 	mov	r3,r2
   21e9c:	00bfff04 	movi	r2,-4
   21ea0:	1884703a 	and	r2,r3,r2
   21ea4:	e0bfff0d 	sth	r2,-4(fp)

  if(size < MIN_SIZE_ALIGNED) {
   21ea8:	e0bfff0b 	ldhu	r2,-4(fp)
   21eac:	10800328 	cmpgeui	r2,r2,12
   21eb0:	1000021e 	bne	r2,zero,21ebc <mem_malloc+0x54>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
   21eb4:	00800304 	movi	r2,12
   21eb8:	e0bfff0d 	sth	r2,-4(fp)
  }

  if (size > MEM_SIZE_ALIGNED) {
   21ebc:	e0bfff0b 	ldhu	r2,-4(fp)
   21ec0:	10a00070 	cmpltui	r2,r2,32769
   21ec4:	1000021e 	bne	r2,zero,21ed0 <mem_malloc+0x68>
    return NULL;
   21ec8:	0005883a 	mov	r2,zero
   21ecc:	0000ad06 	br	22184 <mem_malloc+0x31c>
  }

  /* protect the heap from concurrent access */
  sys_mutex_lock(&mem_mutex);
   21ed0:	d1292f04 	addi	r4,gp,-23364
   21ed4:	001b4dc0 	call	1b4dc <sys_mutex_lock>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
   21ed8:	d0a92e17 	ldw	r2,-23368(gp)
   21edc:	1007883a 	mov	r3,r2
   21ee0:	d0a92c17 	ldw	r2,-23376(gp)
   21ee4:	1885c83a 	sub	r2,r3,r2
   21ee8:	e0bffa0d 	sth	r2,-24(fp)
   21eec:	00009606 	br	22148 <mem_malloc+0x2e0>
         ptr = ((struct mem *)(void *)&ram[ptr])->next) {
      mem = (struct mem *)(void *)&ram[ptr];
   21ef0:	d0e92c17 	ldw	r3,-23376(gp)
   21ef4:	e0bffa0b 	ldhu	r2,-24(fp)
   21ef8:	1885883a 	add	r2,r3,r2
   21efc:	e0bffc15 	stw	r2,-16(fp)
        local_mem_free_count = 1;
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
   21f00:	e0bffc17 	ldw	r2,-16(fp)
   21f04:	10800103 	ldbu	r2,4(r2)
   21f08:	10803fcc 	andi	r2,r2,255
   21f0c:	1000891e 	bne	r2,zero,22134 <mem_malloc+0x2cc>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
   21f10:	e0bffc17 	ldw	r2,-16(fp)
   21f14:	1080000b 	ldhu	r2,0(r2)
   21f18:	10ffffcc 	andi	r3,r2,65535
   21f1c:	e0bffa0b 	ldhu	r2,-24(fp)
   21f20:	1885c83a 	sub	r2,r3,r2
   21f24:	10fffe04 	addi	r3,r2,-8
   21f28:	e0bfff0b 	ldhu	r2,-4(fp)
        local_mem_free_count = 1;
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
   21f2c:	18808136 	bltu	r3,r2,22134 <mem_malloc+0x2cc>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
   21f30:	e0bffc17 	ldw	r2,-16(fp)
   21f34:	1080000b 	ldhu	r2,0(r2)
   21f38:	10ffffcc 	andi	r3,r2,65535
   21f3c:	e0bffa0b 	ldhu	r2,-24(fp)
   21f40:	1885c83a 	sub	r2,r3,r2
   21f44:	10fffe04 	addi	r3,r2,-8
   21f48:	e0bfff0b 	ldhu	r2,-4(fp)
   21f4c:	10800504 	addi	r2,r2,20
   21f50:	18803e36 	bltu	r3,r2,2204c <mem_malloc+0x1e4>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
   21f54:	e0fffa0b 	ldhu	r3,-24(fp)
   21f58:	e0bfff0b 	ldhu	r2,-4(fp)
   21f5c:	1885883a 	add	r2,r3,r2
   21f60:	10800204 	addi	r2,r2,8
   21f64:	e0bffd0d 	sth	r2,-12(fp)
          /* create mem2 struct */
          mem2 = (struct mem *)(void *)&ram[ptr2];
   21f68:	d0e92c17 	ldw	r3,-23376(gp)
   21f6c:	e0bffd0b 	ldhu	r2,-12(fp)
   21f70:	1885883a 	add	r2,r3,r2
   21f74:	e0bffe15 	stw	r2,-8(fp)
          mem2->used = 0;
   21f78:	e0bffe17 	ldw	r2,-8(fp)
   21f7c:	10000105 	stb	zero,4(r2)
          mem2->next = mem->next;
   21f80:	e0bffc17 	ldw	r2,-16(fp)
   21f84:	10c0000b 	ldhu	r3,0(r2)
   21f88:	e0bffe17 	ldw	r2,-8(fp)
   21f8c:	10c0000d 	sth	r3,0(r2)
          mem2->prev = ptr;
   21f90:	e0bffe17 	ldw	r2,-8(fp)
   21f94:	e0fffa0b 	ldhu	r3,-24(fp)
   21f98:	10c0008d 	sth	r3,2(r2)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
   21f9c:	e0bffc17 	ldw	r2,-16(fp)
   21fa0:	e0fffd0b 	ldhu	r3,-12(fp)
   21fa4:	10c0000d 	sth	r3,0(r2)
          mem->used = 1;
   21fa8:	e0bffc17 	ldw	r2,-16(fp)
   21fac:	00c00044 	movi	r3,1
   21fb0:	10c00105 	stb	r3,4(r2)

          if (mem2->next != MEM_SIZE_ALIGNED) {
   21fb4:	e0bffe17 	ldw	r2,-8(fp)
   21fb8:	1080000b 	ldhu	r2,0(r2)
   21fbc:	10ffffcc 	andi	r3,r2,65535
   21fc0:	00a00014 	movui	r2,32768
   21fc4:	18800726 	beq	r3,r2,21fe4 <mem_malloc+0x17c>
            ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
   21fc8:	d0e92c17 	ldw	r3,-23376(gp)
   21fcc:	e0bffe17 	ldw	r2,-8(fp)
   21fd0:	1080000b 	ldhu	r2,0(r2)
   21fd4:	10bfffcc 	andi	r2,r2,65535
   21fd8:	1885883a 	add	r2,r3,r2
   21fdc:	e0fffd0b 	ldhu	r3,-12(fp)
   21fe0:	10c0008d 	sth	r3,2(r2)
          }
          MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
   21fe4:	008001f4 	movhi	r2,7
   21fe8:	10ac6e04 	addi	r2,r2,-20040
   21fec:	10c0548b 	ldhu	r3,338(r2)
   21ff0:	e0bfff0b 	ldhu	r2,-4(fp)
   21ff4:	1885883a 	add	r2,r3,r2
   21ff8:	10800204 	addi	r2,r2,8
   21ffc:	1007883a 	mov	r3,r2
   22000:	008001f4 	movhi	r2,7
   22004:	10ac6e04 	addi	r2,r2,-20040
   22008:	10c0548d 	sth	r3,338(r2)
   2200c:	008001f4 	movhi	r2,7
   22010:	10ac6e04 	addi	r2,r2,-20040
   22014:	10c0550b 	ldhu	r3,340(r2)
   22018:	008001f4 	movhi	r2,7
   2201c:	10ac6e04 	addi	r2,r2,-20040
   22020:	1080548b 	ldhu	r2,338(r2)
   22024:	18ffffcc 	andi	r3,r3,65535
   22028:	10bfffcc 	andi	r2,r2,65535
   2202c:	1880272e 	bgeu	r3,r2,220cc <mem_malloc+0x264>
   22030:	008001f4 	movhi	r2,7
   22034:	10ac6e04 	addi	r2,r2,-20040
   22038:	10c0548b 	ldhu	r3,338(r2)
   2203c:	008001f4 	movhi	r2,7
   22040:	10ac6e04 	addi	r2,r2,-20040
   22044:	10c0550d 	sth	r3,340(r2)
   22048:	00002006 	br	220cc <mem_malloc+0x264>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
   2204c:	e0bffc17 	ldw	r2,-16(fp)
   22050:	00c00044 	movi	r3,1
   22054:	10c00105 	stb	r3,4(r2)
          MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
   22058:	008001f4 	movhi	r2,7
   2205c:	10ac6e04 	addi	r2,r2,-20040
   22060:	10c0548b 	ldhu	r3,338(r2)
   22064:	e0bffc17 	ldw	r2,-16(fp)
   22068:	1100000b 	ldhu	r4,0(r2)
   2206c:	e17ffc17 	ldw	r5,-16(fp)
   22070:	d0a92c17 	ldw	r2,-23376(gp)
   22074:	2885c83a 	sub	r2,r5,r2
   22078:	2085c83a 	sub	r2,r4,r2
   2207c:	1885883a 	add	r2,r3,r2
   22080:	1007883a 	mov	r3,r2
   22084:	008001f4 	movhi	r2,7
   22088:	10ac6e04 	addi	r2,r2,-20040
   2208c:	10c0548d 	sth	r3,338(r2)
   22090:	008001f4 	movhi	r2,7
   22094:	10ac6e04 	addi	r2,r2,-20040
   22098:	10c0550b 	ldhu	r3,340(r2)
   2209c:	008001f4 	movhi	r2,7
   220a0:	10ac6e04 	addi	r2,r2,-20040
   220a4:	1080548b 	ldhu	r2,338(r2)
   220a8:	18ffffcc 	andi	r3,r3,65535
   220ac:	10bfffcc 	andi	r2,r2,65535
   220b0:	1880062e 	bgeu	r3,r2,220cc <mem_malloc+0x264>
   220b4:	008001f4 	movhi	r2,7
   220b8:	10ac6e04 	addi	r2,r2,-20040
   220bc:	10c0548b 	ldhu	r3,338(r2)
   220c0:	008001f4 	movhi	r2,7
   220c4:	10ac6e04 	addi	r2,r2,-20040
   220c8:	10c0550d 	sth	r3,340(r2)
        }
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
   220cc:	d0a92e17 	ldw	r2,-23368(gp)
   220d0:	e0fffc17 	ldw	r3,-16(fp)
   220d4:	1880121e 	bne	r3,r2,22120 <mem_malloc+0x2b8>
          struct mem *cur = lfree;
   220d8:	d0a92e17 	ldw	r2,-23368(gp)
   220dc:	e0bffb15 	stw	r2,-20(fp)
          /* Find next free block after mem and update lowest free pointer */
          while (cur->used && cur != ram_end) {
   220e0:	00000606 	br	220fc <mem_malloc+0x294>
              /* If mem_free or mem_trim have run, we have to restart since they
                 could have altered our current struct mem or lfree. */
              goto mem_malloc_adjust_lfree;
            }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
            cur = (struct mem *)(void *)&ram[cur->next];
   220e4:	d0e92c17 	ldw	r3,-23376(gp)
   220e8:	e0bffb17 	ldw	r2,-20(fp)
   220ec:	1080000b 	ldhu	r2,0(r2)
   220f0:	10bfffcc 	andi	r2,r2,65535
   220f4:	1885883a 	add	r2,r3,r2
   220f8:	e0bffb15 	stw	r2,-20(fp)
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
          struct mem *cur = lfree;
          /* Find next free block after mem and update lowest free pointer */
          while (cur->used && cur != ram_end) {
   220fc:	e0bffb17 	ldw	r2,-20(fp)
   22100:	10800103 	ldbu	r2,4(r2)
   22104:	10803fcc 	andi	r2,r2,255
   22108:	10000326 	beq	r2,zero,22118 <mem_malloc+0x2b0>
   2210c:	d0a92d17 	ldw	r2,-23372(gp)
   22110:	e0fffb17 	ldw	r3,-20(fp)
   22114:	18bff31e 	bne	r3,r2,220e4 <mem_malloc+0x27c>
              goto mem_malloc_adjust_lfree;
            }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
            cur = (struct mem *)(void *)&ram[cur->next];
          }
          lfree = cur;
   22118:	e0bffb17 	ldw	r2,-20(fp)
   2211c:	d0a92e15 	stw	r2,-23368(gp)
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_mutex_unlock(&mem_mutex);
   22120:	d1292f04 	addi	r4,gp,-23364
   22124:	001b52c0 	call	1b52c <sys_mutex_unlock>
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
         ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
   22128:	e0bffc17 	ldw	r2,-16(fp)
   2212c:	10800204 	addi	r2,r2,8
   22130:	00001406 	br	22184 <mem_malloc+0x31c>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)(void *)&ram[ptr])->next) {
   22134:	d0e92c17 	ldw	r3,-23376(gp)
   22138:	e0bffa0b 	ldhu	r2,-24(fp)
   2213c:	1885883a 	add	r2,r3,r2
   22140:	1080000b 	ldhu	r2,0(r2)
   22144:	e0bffa0d 	sth	r2,-24(fp)
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
   22148:	e0fffa0b 	ldhu	r3,-24(fp)
   2214c:	e0bfff0b 	ldhu	r2,-4(fp)
   22150:	01200014 	movui	r4,32768
   22154:	2085c83a 	sub	r2,r4,r2
   22158:	18bf6516 	blt	r3,r2,21ef0 <mem_malloc+0x88>
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
    /* if we got interrupted by a mem_free, try again */
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
   2215c:	008001f4 	movhi	r2,7
   22160:	10ac6e04 	addi	r2,r2,-20040
   22164:	10805617 	ldw	r2,344(r2)
   22168:	10c00044 	addi	r3,r2,1
   2216c:	008001f4 	movhi	r2,7
   22170:	10ac6e04 	addi	r2,r2,-20040
   22174:	10c05615 	stw	r3,344(r2)
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
   22178:	d1292f04 	addi	r4,gp,-23364
   2217c:	001b52c0 	call	1b52c <sys_mutex_unlock>
  return NULL;
   22180:	0005883a 	mov	r2,zero
}
   22184:	e037883a 	mov	sp,fp
   22188:	dfc00117 	ldw	ra,4(sp)
   2218c:	df000017 	ldw	fp,0(sp)
   22190:	dec00204 	addi	sp,sp,8
   22194:	f800283a 	ret

00022198 <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
   22198:	defffb04 	addi	sp,sp,-20
   2219c:	dfc00415 	stw	ra,16(sp)
   221a0:	df000315 	stw	fp,12(sp)
   221a4:	df000304 	addi	fp,sp,12
   221a8:	2007883a 	mov	r3,r4
   221ac:	2805883a 	mov	r2,r5
   221b0:	e0fffe0d 	sth	r3,-8(fp)
   221b4:	e0bfff0d 	sth	r2,-4(fp)
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
   221b8:	e0fffe0b 	ldhu	r3,-8(fp)
   221bc:	e0bfff0b 	ldhu	r2,-4(fp)
   221c0:	1885383a 	mul	r2,r3,r2
   221c4:	10bfffcc 	andi	r2,r2,65535
   221c8:	1009883a 	mov	r4,r2
   221cc:	0021e680 	call	21e68 <mem_malloc>
   221d0:	e0bffd15 	stw	r2,-12(fp)
  if (p) {
   221d4:	e0bffd17 	ldw	r2,-12(fp)
   221d8:	10000726 	beq	r2,zero,221f8 <mem_calloc+0x60>
    /* zero the memory */
    memset(p, 0, count * size);
   221dc:	e0fffe0b 	ldhu	r3,-8(fp)
   221e0:	e0bfff0b 	ldhu	r2,-4(fp)
   221e4:	1885383a 	mul	r2,r3,r2
   221e8:	e13ffd17 	ldw	r4,-12(fp)
   221ec:	000b883a 	mov	r5,zero
   221f0:	100d883a 	mov	r6,r2
   221f4:	00042e80 	call	42e8 <memset>
  }
  return p;
   221f8:	e0bffd17 	ldw	r2,-12(fp)
}
   221fc:	e037883a 	mov	sp,fp
   22200:	dfc00117 	ldw	ra,4(sp)
   22204:	df000017 	ldw	fp,0(sp)
   22208:	dec00204 	addi	sp,sp,8
   2220c:	f800283a 	ret

00022210 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
   22210:	defffd04 	addi	sp,sp,-12
   22214:	df000215 	stw	fp,8(sp)
   22218:	df000204 	addi	fp,sp,8
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
   2221c:	e03fff0d 	sth	zero,-4(fp)
   22220:	00002506 	br	222b8 <memp_init+0xa8>
    MEMP_STATS_AVAIL(used, i, 0);
   22224:	e0bfff0b 	ldhu	r2,-4(fp)
   22228:	00c001f4 	movhi	r3,7
   2222c:	18ec6e04 	addi	r3,r3,-20040
   22230:	10800584 	addi	r2,r2,22
   22234:	1004913a 	slli	r2,r2,4
   22238:	1885883a 	add	r2,r3,r2
   2223c:	1000008d 	sth	zero,2(r2)
    MEMP_STATS_AVAIL(max, i, 0);
   22240:	e0bfff0b 	ldhu	r2,-4(fp)
   22244:	00c001f4 	movhi	r3,7
   22248:	18ec6e04 	addi	r3,r3,-20040
   2224c:	1004913a 	slli	r2,r2,4
   22250:	1885883a 	add	r2,r3,r2
   22254:	10805904 	addi	r2,r2,356
   22258:	1000000d 	sth	zero,0(r2)
    MEMP_STATS_AVAIL(err, i, 0);
   2225c:	e0bfff0b 	ldhu	r2,-4(fp)
   22260:	00c001f4 	movhi	r3,7
   22264:	18ec6e04 	addi	r3,r3,-20040
   22268:	1004913a 	slli	r2,r2,4
   2226c:	1885883a 	add	r2,r3,r2
   22270:	10805a04 	addi	r2,r2,360
   22274:	10000015 	stw	zero,0(r2)
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
   22278:	e17fff0b 	ldhu	r5,-4(fp)
   2227c:	e0bfff0b 	ldhu	r2,-4(fp)
   22280:	00c00134 	movhi	r3,4
   22284:	18c46b84 	addi	r3,r3,4526
   22288:	1085883a 	add	r2,r2,r2
   2228c:	1885883a 	add	r2,r3,r2
   22290:	10c0000b 	ldhu	r3,0(r2)
   22294:	010001f4 	movhi	r4,7
   22298:	212c6e04 	addi	r4,r4,-20040
   2229c:	28800584 	addi	r2,r5,22
   222a0:	1004913a 	slli	r2,r2,4
   222a4:	2085883a 	add	r2,r4,r2
   222a8:	10c0000d 	sth	r3,0(r2)
memp_init(void)
{
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
   222ac:	e0bfff0b 	ldhu	r2,-4(fp)
   222b0:	10800044 	addi	r2,r2,1
   222b4:	e0bfff0d 	sth	r2,-4(fp)
   222b8:	e0bfff0b 	ldhu	r2,-4(fp)
   222bc:	108003f0 	cmpltui	r2,r2,15
   222c0:	103fd81e 	bne	r2,zero,22224 <memp_init+0x14>
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

#if !MEMP_SEPARATE_POOLS
  memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
   222c4:	00800174 	movhi	r2,5
   222c8:	10a07b04 	addi	r2,r2,-32276
   222cc:	10c000c4 	addi	r3,r2,3
   222d0:	00bfff04 	movi	r2,-4
   222d4:	1884703a 	and	r2,r3,r2
   222d8:	e0bffe15 	stw	r2,-8(fp)
#endif /* !MEMP_SEPARATE_POOLS */
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
   222dc:	e03fff0d 	sth	zero,-4(fp)
   222e0:	00003306 	br	223b0 <memp_init+0x1a0>
    memp_tab[i] = NULL;
   222e4:	e0bfff0b 	ldhu	r2,-4(fp)
   222e8:	00c00174 	movhi	r3,5
   222ec:	18e06c04 	addi	r3,r3,-32336
   222f0:	1085883a 	add	r2,r2,r2
   222f4:	1085883a 	add	r2,r2,r2
   222f8:	1885883a 	add	r2,r3,r2
   222fc:	10000015 	stw	zero,0(r2)
#if MEMP_SEPARATE_POOLS
    memp = (struct memp*)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
   22300:	e03fff8d 	sth	zero,-2(fp)
   22304:	00001e06 	br	22380 <memp_init+0x170>
      memp->next = memp_tab[i];
   22308:	e0bfff0b 	ldhu	r2,-4(fp)
   2230c:	00c00174 	movhi	r3,5
   22310:	18e06c04 	addi	r3,r3,-32336
   22314:	1085883a 	add	r2,r2,r2
   22318:	1085883a 	add	r2,r2,r2
   2231c:	1885883a 	add	r2,r3,r2
   22320:	10c00017 	ldw	r3,0(r2)
   22324:	e0bffe17 	ldw	r2,-8(fp)
   22328:	10c00015 	stw	r3,0(r2)
      memp_tab[i] = memp;
   2232c:	e0bfff0b 	ldhu	r2,-4(fp)
   22330:	00c00174 	movhi	r3,5
   22334:	18e06c04 	addi	r3,r3,-32336
   22338:	1085883a 	add	r2,r2,r2
   2233c:	1085883a 	add	r2,r2,r2
   22340:	1885883a 	add	r2,r3,r2
   22344:	e0fffe17 	ldw	r3,-8(fp)
   22348:	10c00015 	stw	r3,0(r2)
      memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
   2234c:	e0bfff0b 	ldhu	r2,-4(fp)
   22350:	00c00134 	movhi	r3,4
   22354:	18c46404 	addi	r3,r3,4496
   22358:	1085883a 	add	r2,r2,r2
   2235c:	1885883a 	add	r2,r3,r2
   22360:	1080000b 	ldhu	r2,0(r2)
   22364:	10bfffcc 	andi	r2,r2,65535
   22368:	e0fffe17 	ldw	r3,-8(fp)
   2236c:	1885883a 	add	r2,r3,r2
   22370:	e0bffe15 	stw	r2,-8(fp)
    memp_tab[i] = NULL;
#if MEMP_SEPARATE_POOLS
    memp = (struct memp*)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
   22374:	e0bfff8b 	ldhu	r2,-2(fp)
   22378:	10800044 	addi	r2,r2,1
   2237c:	e0bfff8d 	sth	r2,-2(fp)
   22380:	e0bfff0b 	ldhu	r2,-4(fp)
   22384:	00c00134 	movhi	r3,4
   22388:	18c46b84 	addi	r3,r3,4526
   2238c:	1085883a 	add	r2,r2,r2
   22390:	1885883a 	add	r2,r3,r2
   22394:	1080000b 	ldhu	r2,0(r2)
   22398:	10bfffcc 	andi	r2,r2,65535
   2239c:	e0ffff8b 	ldhu	r3,-2(fp)
   223a0:	18bfd936 	bltu	r3,r2,22308 <memp_init+0xf8>

#if !MEMP_SEPARATE_POOLS
  memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
#endif /* !MEMP_SEPARATE_POOLS */
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
   223a4:	e0bfff0b 	ldhu	r2,-4(fp)
   223a8:	10800044 	addi	r2,r2,1
   223ac:	e0bfff0d 	sth	r2,-4(fp)
   223b0:	e0bfff0b 	ldhu	r2,-4(fp)
   223b4:	108003f0 	cmpltui	r2,r2,15
   223b8:	103fca1e 	bne	r2,zero,222e4 <memp_init+0xd4>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
   223bc:	e037883a 	mov	sp,fp
   223c0:	df000017 	ldw	fp,0(sp)
   223c4:	dec00104 	addi	sp,sp,4
   223c8:	f800283a 	ret

000223cc <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
   223cc:	defffc04 	addi	sp,sp,-16
   223d0:	dfc00315 	stw	ra,12(sp)
   223d4:	df000215 	stw	fp,8(sp)
   223d8:	df000204 	addi	fp,sp,8
   223dc:	e13fff15 	stw	r4,-4(fp)
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
   223e0:	e0bfff17 	ldw	r2,-4(fp)
   223e4:	108003f0 	cmpltui	r2,r2,15
   223e8:	1000091e 	bne	r2,zero,22410 <memp_malloc+0x44>
   223ec:	01000134 	movhi	r4,4
   223f0:	21047304 	addi	r4,r4,4556
   223f4:	01400134 	movhi	r5,4
   223f8:	29447f04 	addi	r5,r5,4604
   223fc:	01806384 	movi	r6,398
   22400:	01c00134 	movhi	r7,4
   22404:	39c48704 	addi	r7,r7,4636
   22408:	00044740 	call	4474 <printf>
   2240c:	003fff06 	br	2240c <memp_malloc+0x40>

  SYS_ARCH_PROTECT(old_level);
   22410:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   22414:	10000126 	beq	r2,zero,2241c <memp_malloc+0x50>
   22418:	00110d00 	call	110d0 <vTaskEnterCritical>
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
   2241c:	00c00174 	movhi	r3,5
   22420:	18e06c04 	addi	r3,r3,-32336
   22424:	e0bfff17 	ldw	r2,-4(fp)
   22428:	1085883a 	add	r2,r2,r2
   2242c:	1085883a 	add	r2,r2,r2
   22430:	1885883a 	add	r2,r3,r2
   22434:	10800017 	ldw	r2,0(r2)
   22438:	e0bffe15 	stw	r2,-8(fp)
  
  if (memp != NULL) {
   2243c:	e0bffe17 	ldw	r2,-8(fp)
   22440:	10003926 	beq	r2,zero,22528 <memp_malloc+0x15c>
    memp_tab[type] = memp->next;
   22444:	e0bffe17 	ldw	r2,-8(fp)
   22448:	10c00017 	ldw	r3,0(r2)
   2244c:	01000174 	movhi	r4,5
   22450:	21206c04 	addi	r4,r4,-32336
   22454:	e0bfff17 	ldw	r2,-4(fp)
   22458:	1085883a 	add	r2,r2,r2
   2245c:	1085883a 	add	r2,r2,r2
   22460:	2085883a 	add	r2,r4,r2
   22464:	10c00015 	stw	r3,0(r2)
#if MEMP_OVERFLOW_CHECK
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
   22468:	00c001f4 	movhi	r3,7
   2246c:	18ec6e04 	addi	r3,r3,-20040
   22470:	e0bfff17 	ldw	r2,-4(fp)
   22474:	10800584 	addi	r2,r2,22
   22478:	1004913a 	slli	r2,r2,4
   2247c:	1885883a 	add	r2,r3,r2
   22480:	1080008b 	ldhu	r2,2(r2)
   22484:	10800044 	addi	r2,r2,1
   22488:	1007883a 	mov	r3,r2
   2248c:	010001f4 	movhi	r4,7
   22490:	212c6e04 	addi	r4,r4,-20040
   22494:	e0bfff17 	ldw	r2,-4(fp)
   22498:	10800584 	addi	r2,r2,22
   2249c:	1004913a 	slli	r2,r2,4
   224a0:	2085883a 	add	r2,r4,r2
   224a4:	10c0008d 	sth	r3,2(r2)
   224a8:	00c001f4 	movhi	r3,7
   224ac:	18ec6e04 	addi	r3,r3,-20040
   224b0:	e0bfff17 	ldw	r2,-4(fp)
   224b4:	1004913a 	slli	r2,r2,4
   224b8:	1885883a 	add	r2,r3,r2
   224bc:	10805904 	addi	r2,r2,356
   224c0:	10c0000b 	ldhu	r3,0(r2)
   224c4:	010001f4 	movhi	r4,7
   224c8:	212c6e04 	addi	r4,r4,-20040
   224cc:	e0bfff17 	ldw	r2,-4(fp)
   224d0:	10800584 	addi	r2,r2,22
   224d4:	1004913a 	slli	r2,r2,4
   224d8:	2085883a 	add	r2,r4,r2
   224dc:	1080008b 	ldhu	r2,2(r2)
   224e0:	18ffffcc 	andi	r3,r3,65535
   224e4:	10bfffcc 	andi	r2,r2,65535
   224e8:	18801f2e 	bgeu	r3,r2,22568 <memp_malloc+0x19c>
   224ec:	00c001f4 	movhi	r3,7
   224f0:	18ec6e04 	addi	r3,r3,-20040
   224f4:	e0bfff17 	ldw	r2,-4(fp)
   224f8:	10800584 	addi	r2,r2,22
   224fc:	1004913a 	slli	r2,r2,4
   22500:	1885883a 	add	r2,r3,r2
   22504:	10c0008b 	ldhu	r3,2(r2)
   22508:	010001f4 	movhi	r4,7
   2250c:	212c6e04 	addi	r4,r4,-20040
   22510:	e0bfff17 	ldw	r2,-4(fp)
   22514:	1004913a 	slli	r2,r2,4
   22518:	2085883a 	add	r2,r4,r2
   2251c:	10805904 	addi	r2,r2,356
   22520:	10c0000d 	sth	r3,0(r2)
   22524:	00001106 	br	2256c <memp_malloc+0x1a0>
    LWIP_ASSERT("memp_malloc: memp properly aligned",
                ((mem_ptr_t)memp % MEM_ALIGNMENT) == 0);
    memp = (struct memp*)(void *)((u8_t*)memp + MEMP_SIZE);
  } else {
    LWIP_DEBUGF(MEMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("memp_malloc: out of memory in pool %s\n", memp_desc[type]));
    MEMP_STATS_INC(err, type);
   22528:	00c001f4 	movhi	r3,7
   2252c:	18ec6e04 	addi	r3,r3,-20040
   22530:	e0bfff17 	ldw	r2,-4(fp)
   22534:	1004913a 	slli	r2,r2,4
   22538:	1885883a 	add	r2,r3,r2
   2253c:	10805a04 	addi	r2,r2,360
   22540:	10800017 	ldw	r2,0(r2)
   22544:	10c00044 	addi	r3,r2,1
   22548:	010001f4 	movhi	r4,7
   2254c:	212c6e04 	addi	r4,r4,-20040
   22550:	e0bfff17 	ldw	r2,-4(fp)
   22554:	1004913a 	slli	r2,r2,4
   22558:	2085883a 	add	r2,r4,r2
   2255c:	10805a04 	addi	r2,r2,360
   22560:	10c00015 	stw	r3,0(r2)
   22564:	00000106 	br	2256c <memp_malloc+0x1a0>
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
                ((mem_ptr_t)memp % MEM_ALIGNMENT) == 0);
    memp = (struct memp*)(void *)((u8_t*)memp + MEMP_SIZE);
   22568:	0001883a 	nop
  } else {
    LWIP_DEBUGF(MEMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("memp_malloc: out of memory in pool %s\n", memp_desc[type]));
    MEMP_STATS_INC(err, type);
  }

  SYS_ARCH_UNPROTECT(old_level);
   2256c:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   22570:	10000126 	beq	r2,zero,22578 <memp_malloc+0x1ac>
   22574:	00111100 	call	11110 <vTaskExitCritical>

  return memp;
   22578:	e0bffe17 	ldw	r2,-8(fp)
}
   2257c:	e037883a 	mov	sp,fp
   22580:	dfc00117 	ldw	ra,4(sp)
   22584:	df000017 	ldw	fp,0(sp)
   22588:	dec00204 	addi	sp,sp,8
   2258c:	f800283a 	ret

00022590 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
   22590:	defffb04 	addi	sp,sp,-20
   22594:	dfc00415 	stw	ra,16(sp)
   22598:	df000315 	stw	fp,12(sp)
   2259c:	df000304 	addi	fp,sp,12
   225a0:	e13ffe15 	stw	r4,-8(fp)
   225a4:	e17fff15 	stw	r5,-4(fp)
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
   225a8:	e0bfff17 	ldw	r2,-4(fp)
   225ac:	10002a26 	beq	r2,zero,22658 <memp_free+0xc8>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
                ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  memp = (struct memp *)(void *)((u8_t*)mem - MEMP_SIZE);
   225b0:	e0bfff17 	ldw	r2,-4(fp)
   225b4:	e0bffd15 	stw	r2,-12(fp)

  SYS_ARCH_PROTECT(old_level);
   225b8:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   225bc:	10000126 	beq	r2,zero,225c4 <memp_free+0x34>
   225c0:	00110d00 	call	110d0 <vTaskEnterCritical>
  memp_overflow_check_element_overflow(memp, type);
  memp_overflow_check_element_underflow(memp, type);
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
   225c4:	00c001f4 	movhi	r3,7
   225c8:	18ec6e04 	addi	r3,r3,-20040
   225cc:	e0bffe17 	ldw	r2,-8(fp)
   225d0:	10800584 	addi	r2,r2,22
   225d4:	1004913a 	slli	r2,r2,4
   225d8:	1885883a 	add	r2,r3,r2
   225dc:	1080008b 	ldhu	r2,2(r2)
   225e0:	10bfffc4 	addi	r2,r2,-1
   225e4:	1007883a 	mov	r3,r2
   225e8:	010001f4 	movhi	r4,7
   225ec:	212c6e04 	addi	r4,r4,-20040
   225f0:	e0bffe17 	ldw	r2,-8(fp)
   225f4:	10800584 	addi	r2,r2,22
   225f8:	1004913a 	slli	r2,r2,4
   225fc:	2085883a 	add	r2,r4,r2
   22600:	10c0008d 	sth	r3,2(r2)
  
  memp->next = memp_tab[type]; 
   22604:	00c00174 	movhi	r3,5
   22608:	18e06c04 	addi	r3,r3,-32336
   2260c:	e0bffe17 	ldw	r2,-8(fp)
   22610:	1085883a 	add	r2,r2,r2
   22614:	1085883a 	add	r2,r2,r2
   22618:	1885883a 	add	r2,r3,r2
   2261c:	10c00017 	ldw	r3,0(r2)
   22620:	e0bffd17 	ldw	r2,-12(fp)
   22624:	10c00015 	stw	r3,0(r2)
  memp_tab[type] = memp;
   22628:	00c00174 	movhi	r3,5
   2262c:	18e06c04 	addi	r3,r3,-32336
   22630:	e0bffe17 	ldw	r2,-8(fp)
   22634:	1085883a 	add	r2,r2,r2
   22638:	1085883a 	add	r2,r2,r2
   2263c:	1885883a 	add	r2,r3,r2
   22640:	e0fffd17 	ldw	r3,-12(fp)
   22644:	10c00015 	stw	r3,0(r2)

#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
   22648:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   2264c:	10000326 	beq	r2,zero,2265c <memp_free+0xcc>
   22650:	00111100 	call	11110 <vTaskExitCritical>
   22654:	00000106 	br	2265c <memp_free+0xcc>
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
    return;
   22658:	0001883a 	nop
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
   2265c:	e037883a 	mov	sp,fp
   22660:	dfc00117 	ldw	ra,4(sp)
   22664:	df000017 	ldw	fp,0(sp)
   22668:	dec00204 	addi	sp,sp,8
   2266c:	f800283a 	ret

00022670 <netif_init>:
}
#endif /* LWIP_HAVE_LOOPIF */

void
netif_init(void)
{
   22670:	deffff04 	addi	sp,sp,-4
   22674:	df000015 	stw	fp,0(sp)
   22678:	d839883a 	mov	fp,sp
  netif_add(&loop_netif, &loop_ipaddr, &loop_netmask, &loop_gw, NULL, netif_loopif_init, tcpip_input);
#endif /* NO_SYS */
  netif_set_up(&loop_netif);

#endif /* LWIP_HAVE_LOOPIF */
}
   2267c:	e037883a 	mov	sp,fp
   22680:	df000017 	ldw	fp,0(sp)
   22684:	dec00104 	addi	sp,sp,4
   22688:	f800283a 	ret

0002268c <netif_add>:
 * @return netif, or NULL if failed.
 */
struct netif *
netif_add(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
  ip_addr_t *gw, void *state, netif_init_fn init, netif_input_fn input)
{
   2268c:	defffa04 	addi	sp,sp,-24
   22690:	dfc00515 	stw	ra,20(sp)
   22694:	df000415 	stw	fp,16(sp)
   22698:	df000404 	addi	fp,sp,16
   2269c:	e13ffc15 	stw	r4,-16(fp)
   226a0:	e17ffd15 	stw	r5,-12(fp)
   226a4:	e1bffe15 	stw	r6,-8(fp)
   226a8:	e1ffff15 	stw	r7,-4(fp)

  LWIP_ASSERT("No init function given", init != NULL);

  /* reset new interface configuration state */
  ip_addr_set_zero(&netif->ip_addr);
   226ac:	e0bffc17 	ldw	r2,-16(fp)
   226b0:	10000115 	stw	zero,4(r2)
  ip_addr_set_zero(&netif->netmask);
   226b4:	e0bffc17 	ldw	r2,-16(fp)
   226b8:	10000215 	stw	zero,8(r2)
  ip_addr_set_zero(&netif->gw);
   226bc:	e0bffc17 	ldw	r2,-16(fp)
   226c0:	10000315 	stw	zero,12(r2)
  netif->flags = 0;
   226c4:	e0bffc17 	ldw	r2,-16(fp)
   226c8:	10000e45 	stb	zero,57(r2)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
   226cc:	e0bffc17 	ldw	r2,-16(fp)
   226d0:	10000a15 	stw	zero,40(r2)
#if LWIP_AUTOIP
  /* netif not under AutoIP control by default */
  netif->autoip = NULL;
#endif /* LWIP_AUTOIP */
#if LWIP_NETIF_STATUS_CALLBACK
  netif->status_callback = NULL;
   226d4:	e0bffc17 	ldw	r2,-16(fp)
   226d8:	10000715 	stw	zero,28(r2)
#endif /* LWIP_NETIF_STATUS_CALLBACK */
#if LWIP_NETIF_LINK_CALLBACK
  netif->link_callback = NULL;
   226dc:	e0bffc17 	ldw	r2,-16(fp)
   226e0:	10000815 	stw	zero,32(r2)
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
   226e4:	e0bffc17 	ldw	r2,-16(fp)
   226e8:	e0c00217 	ldw	r3,8(fp)
   226ec:	10c00915 	stw	r3,36(r2)
  netif->num = netif_num++;
   226f0:	d0a93003 	ldbu	r2,-23360(gp)
   226f4:	e0fffc17 	ldw	r3,-16(fp)
   226f8:	18800f05 	stb	r2,60(r3)
   226fc:	10800044 	addi	r2,r2,1
   22700:	d0a93005 	stb	r2,-23360(gp)
  netif->input = input;
   22704:	e0bffc17 	ldw	r2,-16(fp)
   22708:	e0c00417 	ldw	r3,16(fp)
   2270c:	10c00415 	stw	r3,16(r2)
  NETIF_SET_HWADDRHINT(netif, NULL);
   22710:	e0bffc17 	ldw	r2,-16(fp)
   22714:	10001015 	stw	zero,64(r2)
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
   22718:	e13ffc17 	ldw	r4,-16(fp)
   2271c:	e17ffd17 	ldw	r5,-12(fp)
   22720:	e1bffe17 	ldw	r6,-8(fp)
   22724:	e1ffff17 	ldw	r7,-4(fp)
   22728:	002277c0 	call	2277c <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
   2272c:	e0800317 	ldw	r2,12(fp)
   22730:	e13ffc17 	ldw	r4,-16(fp)
   22734:	103ee83a 	callr	r2
   22738:	10803fcc 	andi	r2,r2,255
   2273c:	1080201c 	xori	r2,r2,128
   22740:	10bfe004 	addi	r2,r2,-128
   22744:	10000226 	beq	r2,zero,22750 <netif_add+0xc4>
    return NULL;
   22748:	0005883a 	mov	r2,zero
   2274c:	00000606 	br	22768 <netif_add+0xdc>
  }

  /* add this netif to the list */
  netif->next = netif_list;
   22750:	d0e93117 	ldw	r3,-23356(gp)
   22754:	e0bffc17 	ldw	r2,-16(fp)
   22758:	10c00015 	stw	r3,0(r2)
  netif_list = netif;
   2275c:	e0bffc17 	ldw	r2,-16(fp)
   22760:	d0a93115 	stw	r2,-23356(gp)
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
   22764:	e0bffc17 	ldw	r2,-16(fp)
}
   22768:	e037883a 	mov	sp,fp
   2276c:	dfc00117 	ldw	ra,4(sp)
   22770:	df000017 	ldw	fp,0(sp)
   22774:	dec00204 	addi	sp,sp,8
   22778:	f800283a 	ret

0002277c <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
    ip_addr_t *gw)
{
   2277c:	defffa04 	addi	sp,sp,-24
   22780:	dfc00515 	stw	ra,20(sp)
   22784:	df000415 	stw	fp,16(sp)
   22788:	df000404 	addi	fp,sp,16
   2278c:	e13ffc15 	stw	r4,-16(fp)
   22790:	e17ffd15 	stw	r5,-12(fp)
   22794:	e1bffe15 	stw	r6,-8(fp)
   22798:	e1ffff15 	stw	r7,-4(fp)
  netif_set_ipaddr(netif, ipaddr);
   2279c:	e13ffc17 	ldw	r4,-16(fp)
   227a0:	e17ffd17 	ldw	r5,-12(fp)
   227a4:	002298c0 	call	2298c <netif_set_ipaddr>
  netif_set_netmask(netif, netmask);
   227a8:	e13ffc17 	ldw	r4,-16(fp)
   227ac:	e17ffe17 	ldw	r5,-8(fp)
   227b0:	0022b040 	call	22b04 <netif_set_netmask>
  netif_set_gw(netif, gw);
   227b4:	e13ffc17 	ldw	r4,-16(fp)
   227b8:	e17fff17 	ldw	r5,-4(fp)
   227bc:	0022ac00 	call	22ac0 <netif_set_gw>
}
   227c0:	e037883a 	mov	sp,fp
   227c4:	dfc00117 	ldw	ra,4(sp)
   227c8:	df000017 	ldw	fp,0(sp)
   227cc:	dec00204 	addi	sp,sp,8
   227d0:	f800283a 	ret

000227d4 <netif_remove>:
 *
 * @param netif the network interface to remove
 */
void
netif_remove(struct netif *netif)
{
   227d4:	defffc04 	addi	sp,sp,-16
   227d8:	dfc00315 	stw	ra,12(sp)
   227dc:	df000215 	stw	fp,8(sp)
   227e0:	df000204 	addi	fp,sp,8
   227e4:	e13fff15 	stw	r4,-4(fp)
  if (netif == NULL) {
   227e8:	e0bfff17 	ldw	r2,-4(fp)
   227ec:	10002726 	beq	r2,zero,2288c <netif_remove+0xb8>
  /* stop IGMP processing */
  if (netif->flags & NETIF_FLAG_IGMP) {
    igmp_stop(netif);
  }
#endif /* LWIP_IGMP */
  if (netif_is_up(netif)) {
   227f0:	e0bfff17 	ldw	r2,-4(fp)
   227f4:	10800e43 	ldbu	r2,57(r2)
   227f8:	10803fcc 	andi	r2,r2,255
   227fc:	1080004c 	andi	r2,r2,1
   22800:	10000226 	beq	r2,zero,2280c <netif_remove+0x38>
    /* set netif down before removing (call callback function) */
    netif_set_down(netif);
   22804:	e13fff17 	ldw	r4,-4(fp)
   22808:	0022c1c0 	call	22c1c <netif_set_down>
  }

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
   2280c:	d0e93117 	ldw	r3,-23356(gp)
   22810:	e0bfff17 	ldw	r2,-4(fp)
   22814:	1880041e 	bne	r3,r2,22828 <netif_remove+0x54>
    netif_list = netif->next;
   22818:	e0bfff17 	ldw	r2,-4(fp)
   2281c:	10800017 	ldw	r2,0(r2)
   22820:	d0a93115 	stw	r2,-23356(gp)
   22824:	00001306 	br	22874 <netif_remove+0xa0>
  } else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
   22828:	d0a93117 	ldw	r2,-23356(gp)
   2282c:	e0bffe15 	stw	r2,-8(fp)
   22830:	00000c06 	br	22864 <netif_remove+0x90>
      if (tmpNetif->next == netif) {
   22834:	e0bffe17 	ldw	r2,-8(fp)
   22838:	10c00017 	ldw	r3,0(r2)
   2283c:	e0bfff17 	ldw	r2,-4(fp)
   22840:	1880051e 	bne	r3,r2,22858 <netif_remove+0x84>
        tmpNetif->next = netif->next;
   22844:	e0bfff17 	ldw	r2,-4(fp)
   22848:	10c00017 	ldw	r3,0(r2)
   2284c:	e0bffe17 	ldw	r2,-8(fp)
   22850:	10c00015 	stw	r3,0(r2)
        break;
   22854:	00000506 	br	2286c <netif_remove+0x98>
  if (netif_list == netif) {
    netif_list = netif->next;
  } else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
   22858:	e0bffe17 	ldw	r2,-8(fp)
   2285c:	10800017 	ldw	r2,0(r2)
   22860:	e0bffe15 	stw	r2,-8(fp)
   22864:	e0bffe17 	ldw	r2,-8(fp)
   22868:	103ff21e 	bne	r2,zero,22834 <netif_remove+0x60>
      if (tmpNetif->next == netif) {
        tmpNetif->next = netif->next;
        break;
      }
    }
    if (tmpNetif == NULL)
   2286c:	e0bffe17 	ldw	r2,-8(fp)
   22870:	10000826 	beq	r2,zero,22894 <netif_remove+0xc0>
      return; /*  we didn't find any netif today */
  }
  snmp_dec_iflist();
  /* this netif is default? */
  if (netif_default == netif) {
   22874:	d0e93217 	ldw	r3,-23352(gp)
   22878:	e0bfff17 	ldw	r2,-4(fp)
   2287c:	1880061e 	bne	r3,r2,22898 <netif_remove+0xc4>
    /* reset default netif */
    netif_set_default(NULL);
   22880:	0009883a 	mov	r4,zero
   22884:	0022b480 	call	22b48 <netif_set_default>
   22888:	00000306 	br	22898 <netif_remove+0xc4>
 */
void
netif_remove(struct netif *netif)
{
  if (netif == NULL) {
    return;
   2288c:	0001883a 	nop
   22890:	00000106 	br	22898 <netif_remove+0xc4>
        tmpNetif->next = netif->next;
        break;
      }
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
   22894:	0001883a 	nop
  if (netif->remove_callback) {
    netif->remove_callback(netif);
  }
#endif /* LWIP_NETIF_REMOVE_CALLBACK */
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
   22898:	e037883a 	mov	sp,fp
   2289c:	dfc00117 	ldw	ra,4(sp)
   228a0:	df000017 	ldw	fp,0(sp)
   228a4:	dec00204 	addi	sp,sp,8
   228a8:	f800283a 	ret

000228ac <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
   228ac:	defffc04 	addi	sp,sp,-16
   228b0:	df000315 	stw	fp,12(sp)
   228b4:	df000304 	addi	fp,sp,12
   228b8:	e13fff15 	stw	r4,-4(fp)
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
   228bc:	e0bfff17 	ldw	r2,-4(fp)
   228c0:	1000021e 	bne	r2,zero,228cc <netif_find+0x20>
    return NULL;
   228c4:	0005883a 	mov	r2,zero
   228c8:	00002c06 	br	2297c <netif_find+0xd0>
  }

  num = name[2] - '0';
   228cc:	e0bfff17 	ldw	r2,-4(fp)
   228d0:	10800084 	addi	r2,r2,2
   228d4:	10800003 	ldbu	r2,0(r2)
   228d8:	10bff404 	addi	r2,r2,-48
   228dc:	e0bffe05 	stb	r2,-8(fp)

  for(netif = netif_list; netif != NULL; netif = netif->next) {
   228e0:	d0a93117 	ldw	r2,-23356(gp)
   228e4:	e0bffd15 	stw	r2,-12(fp)
   228e8:	00002106 	br	22970 <netif_find+0xc4>
    if (num == netif->num &&
   228ec:	e0bffd17 	ldw	r2,-12(fp)
   228f0:	10800f03 	ldbu	r2,60(r2)
   228f4:	10c03fcc 	andi	r3,r2,255
   228f8:	e0bffe03 	ldbu	r2,-8(fp)
   228fc:	1880191e 	bne	r3,r2,22964 <netif_find+0xb8>
       name[0] == netif->name[0] &&
   22900:	e0bfff17 	ldw	r2,-4(fp)
   22904:	10c00003 	ldbu	r3,0(r2)
   22908:	e0bffd17 	ldw	r2,-12(fp)
   2290c:	10800e83 	ldbu	r2,58(r2)
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
   22910:	18c03fcc 	andi	r3,r3,255
   22914:	18c0201c 	xori	r3,r3,128
   22918:	18ffe004 	addi	r3,r3,-128
   2291c:	10803fcc 	andi	r2,r2,255
   22920:	1080201c 	xori	r2,r2,128
   22924:	10bfe004 	addi	r2,r2,-128
   22928:	18800e1e 	bne	r3,r2,22964 <netif_find+0xb8>
       name[0] == netif->name[0] &&
       name[1] == netif->name[1]) {
   2292c:	e0bfff17 	ldw	r2,-4(fp)
   22930:	10800044 	addi	r2,r2,1
   22934:	10c00003 	ldbu	r3,0(r2)
   22938:	e0bffd17 	ldw	r2,-12(fp)
   2293c:	10800ec3 	ldbu	r2,59(r2)

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
       name[0] == netif->name[0] &&
   22940:	18c03fcc 	andi	r3,r3,255
   22944:	18c0201c 	xori	r3,r3,128
   22948:	18ffe004 	addi	r3,r3,-128
   2294c:	10803fcc 	andi	r2,r2,255
   22950:	1080201c 	xori	r2,r2,128
   22954:	10bfe004 	addi	r2,r2,-128
   22958:	1880021e 	bne	r3,r2,22964 <netif_find+0xb8>
       name[1] == netif->name[1]) {
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
   2295c:	e0bffd17 	ldw	r2,-12(fp)
   22960:	00000606 	br	2297c <netif_find+0xd0>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
   22964:	e0bffd17 	ldw	r2,-12(fp)
   22968:	10800017 	ldw	r2,0(r2)
   2296c:	e0bffd15 	stw	r2,-12(fp)
   22970:	e0bffd17 	ldw	r2,-12(fp)
   22974:	103fdd1e 	bne	r2,zero,228ec <netif_find+0x40>
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
   22978:	0005883a 	mov	r2,zero
}
   2297c:	e037883a 	mov	sp,fp
   22980:	df000017 	ldw	fp,0(sp)
   22984:	dec00104 	addi	sp,sp,4
   22988:	f800283a 	ret

0002298c <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, ip_addr_t *ipaddr)
{
   2298c:	defff904 	addi	sp,sp,-28
   22990:	dfc00615 	stw	ra,24(sp)
   22994:	df000515 	stw	fp,20(sp)
   22998:	df000504 	addi	fp,sp,20
   2299c:	e13ffe15 	stw	r4,-8(fp)
   229a0:	e17fff15 	stw	r5,-4(fp)
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
   229a4:	e0bfff17 	ldw	r2,-4(fp)
   229a8:	10003826 	beq	r2,zero,22a8c <netif_set_ipaddr+0x100>
   229ac:	e0bfff17 	ldw	r2,-4(fp)
   229b0:	10c00017 	ldw	r3,0(r2)
   229b4:	e0bffe17 	ldw	r2,-8(fp)
   229b8:	10800117 	ldw	r2,4(r2)
   229bc:	18803326 	beq	r3,r2,22a8c <netif_set_ipaddr+0x100>
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
   229c0:	00800134 	movhi	r2,4
   229c4:	109ef204 	addi	r2,r2,31688
   229c8:	10800017 	ldw	r2,0(r2)
   229cc:	e0bffb15 	stw	r2,-20(fp)
    while (pcb != NULL) {
   229d0:	00001006 	br	22a14 <netif_set_ipaddr+0x88>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
   229d4:	e0bffb17 	ldw	r2,-20(fp)
   229d8:	10c00017 	ldw	r3,0(r2)
   229dc:	e0bffe17 	ldw	r2,-8(fp)
   229e0:	10800117 	ldw	r2,4(r2)
   229e4:	1880081e 	bne	r3,r2,22a08 <netif_set_ipaddr+0x7c>
        /* connections to link-local addresses must persist (RFC3927 ch. 1.9) */
        && !ip_addr_islinklocal(&(pcb->local_ip))
#endif /* LWIP_AUTOIP */
        ) {
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
   229e8:	e0bffb17 	ldw	r2,-20(fp)
   229ec:	10800317 	ldw	r2,12(r2)
   229f0:	e0bffd15 	stw	r2,-12(fp)
        LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
   229f4:	e13ffb17 	ldw	r4,-20(fp)
   229f8:	002508c0 	call	2508c <tcp_abort>
        pcb = next;
   229fc:	e0bffd17 	ldw	r2,-12(fp)
   22a00:	e0bffb15 	stw	r2,-20(fp)
   22a04:	00000306 	br	22a14 <netif_set_ipaddr+0x88>
      } else {
        pcb = pcb->next;
   22a08:	e0bffb17 	ldw	r2,-20(fp)
   22a0c:	10800317 	ldw	r2,12(r2)
   22a10:	e0bffb15 	stw	r2,-20(fp)
  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
   22a14:	e0bffb17 	ldw	r2,-20(fp)
   22a18:	103fee1e 	bne	r2,zero,229d4 <netif_set_ipaddr+0x48>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
   22a1c:	00800134 	movhi	r2,4
   22a20:	109ef404 	addi	r2,r2,31696
   22a24:	10800017 	ldw	r2,0(r2)
   22a28:	e0bffc15 	stw	r2,-16(fp)
   22a2c:	00001506 	br	22a84 <netif_set_ipaddr+0xf8>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
   22a30:	e0bffc17 	ldw	r2,-16(fp)
   22a34:	10001026 	beq	r2,zero,22a78 <netif_set_ipaddr+0xec>
   22a38:	e0bffc17 	ldw	r2,-16(fp)
   22a3c:	10800017 	ldw	r2,0(r2)
   22a40:	10000d26 	beq	r2,zero,22a78 <netif_set_ipaddr+0xec>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
   22a44:	e0bffc17 	ldw	r2,-16(fp)
   22a48:	10c00017 	ldw	r3,0(r2)
   22a4c:	e0bffe17 	ldw	r2,-8(fp)
   22a50:	10800117 	ldw	r2,4(r2)
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
   22a54:	1880081e 	bne	r3,r2,22a78 <netif_set_ipaddr+0xec>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
   22a58:	e0bfff17 	ldw	r2,-4(fp)
   22a5c:	10000326 	beq	r2,zero,22a6c <netif_set_ipaddr+0xe0>
   22a60:	e0bfff17 	ldw	r2,-4(fp)
   22a64:	10800017 	ldw	r2,0(r2)
   22a68:	00000106 	br	22a70 <netif_set_ipaddr+0xe4>
   22a6c:	0005883a 	mov	r2,zero
   22a70:	e0fffc17 	ldw	r3,-16(fp)
   22a74:	18800015 	stw	r2,0(r3)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
   22a78:	e0bffc17 	ldw	r2,-16(fp)
   22a7c:	10800317 	ldw	r2,12(r2)
   22a80:	e0bffc15 	stw	r2,-16(fp)
   22a84:	e0bffc17 	ldw	r2,-16(fp)
   22a88:	103fe91e 	bne	r2,zero,22a30 <netif_set_ipaddr+0xa4>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
   22a8c:	e0bfff17 	ldw	r2,-4(fp)
   22a90:	10000326 	beq	r2,zero,22aa0 <netif_set_ipaddr+0x114>
   22a94:	e0bfff17 	ldw	r2,-4(fp)
   22a98:	10800017 	ldw	r2,0(r2)
   22a9c:	00000106 	br	22aa4 <netif_set_ipaddr+0x118>
   22aa0:	0005883a 	mov	r2,zero
   22aa4:	e0fffe17 	ldw	r3,-8(fp)
   22aa8:	18800115 	stw	r2,4(r3)
    netif->name[0], netif->name[1],
    ip4_addr1_16(&netif->ip_addr),
    ip4_addr2_16(&netif->ip_addr),
    ip4_addr3_16(&netif->ip_addr),
    ip4_addr4_16(&netif->ip_addr)));
}
   22aac:	e037883a 	mov	sp,fp
   22ab0:	dfc00117 	ldw	ra,4(sp)
   22ab4:	df000017 	ldw	fp,0(sp)
   22ab8:	dec00204 	addi	sp,sp,8
   22abc:	f800283a 	ret

00022ac0 <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, ip_addr_t *gw)
{
   22ac0:	defffd04 	addi	sp,sp,-12
   22ac4:	df000215 	stw	fp,8(sp)
   22ac8:	df000204 	addi	fp,sp,8
   22acc:	e13ffe15 	stw	r4,-8(fp)
   22ad0:	e17fff15 	stw	r5,-4(fp)
  ip_addr_set(&(netif->gw), gw);
   22ad4:	e0bfff17 	ldw	r2,-4(fp)
   22ad8:	10000326 	beq	r2,zero,22ae8 <netif_set_gw+0x28>
   22adc:	e0bfff17 	ldw	r2,-4(fp)
   22ae0:	10800017 	ldw	r2,0(r2)
   22ae4:	00000106 	br	22aec <netif_set_gw+0x2c>
   22ae8:	0005883a 	mov	r2,zero
   22aec:	e0fffe17 	ldw	r3,-8(fp)
   22af0:	18800315 	stw	r2,12(r3)
    netif->name[0], netif->name[1],
    ip4_addr1_16(&netif->gw),
    ip4_addr2_16(&netif->gw),
    ip4_addr3_16(&netif->gw),
    ip4_addr4_16(&netif->gw)));
}
   22af4:	e037883a 	mov	sp,fp
   22af8:	df000017 	ldw	fp,0(sp)
   22afc:	dec00104 	addi	sp,sp,4
   22b00:	f800283a 	ret

00022b04 <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
{
   22b04:	defffd04 	addi	sp,sp,-12
   22b08:	df000215 	stw	fp,8(sp)
   22b0c:	df000204 	addi	fp,sp,8
   22b10:	e13ffe15 	stw	r4,-8(fp)
   22b14:	e17fff15 	stw	r5,-4(fp)
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
   22b18:	e0bfff17 	ldw	r2,-4(fp)
   22b1c:	10000326 	beq	r2,zero,22b2c <netif_set_netmask+0x28>
   22b20:	e0bfff17 	ldw	r2,-4(fp)
   22b24:	10800017 	ldw	r2,0(r2)
   22b28:	00000106 	br	22b30 <netif_set_netmask+0x2c>
   22b2c:	0005883a 	mov	r2,zero
   22b30:	e0fffe17 	ldw	r3,-8(fp)
   22b34:	18800215 	stw	r2,8(r3)
    netif->name[0], netif->name[1],
    ip4_addr1_16(&netif->netmask),
    ip4_addr2_16(&netif->netmask),
    ip4_addr3_16(&netif->netmask),
    ip4_addr4_16(&netif->netmask)));
}
   22b38:	e037883a 	mov	sp,fp
   22b3c:	df000017 	ldw	fp,0(sp)
   22b40:	dec00104 	addi	sp,sp,4
   22b44:	f800283a 	ret

00022b48 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
   22b48:	defffe04 	addi	sp,sp,-8
   22b4c:	df000115 	stw	fp,4(sp)
   22b50:	df000104 	addi	fp,sp,4
   22b54:	e13fff15 	stw	r4,-4(fp)
    snmp_delete_iprteidx_tree(1, netif);
  } else {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
   22b58:	e0bfff17 	ldw	r2,-4(fp)
   22b5c:	d0a93215 	stw	r2,-23352(gp)
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
   22b60:	e037883a 	mov	sp,fp
   22b64:	df000017 	ldw	fp,0(sp)
   22b68:	dec00104 	addi	sp,sp,4
   22b6c:	f800283a 	ret

00022b70 <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
   22b70:	defffd04 	addi	sp,sp,-12
   22b74:	dfc00215 	stw	ra,8(sp)
   22b78:	df000115 	stw	fp,4(sp)
   22b7c:	df000104 	addi	fp,sp,4
   22b80:	e13fff15 	stw	r4,-4(fp)
  if (!(netif->flags & NETIF_FLAG_UP)) {
   22b84:	e0bfff17 	ldw	r2,-4(fp)
   22b88:	10800e43 	ldbu	r2,57(r2)
   22b8c:	10803fcc 	andi	r2,r2,255
   22b90:	1080004c 	andi	r2,r2,1
   22b94:	10001c1e 	bne	r2,zero,22c08 <netif_set_up+0x98>
    netif->flags |= NETIF_FLAG_UP;
   22b98:	e0bfff17 	ldw	r2,-4(fp)
   22b9c:	10800e43 	ldbu	r2,57(r2)
   22ba0:	10800054 	ori	r2,r2,1
   22ba4:	1007883a 	mov	r3,r2
   22ba8:	e0bfff17 	ldw	r2,-4(fp)
   22bac:	10c00e45 	stb	r3,57(r2)
    
#if LWIP_SNMP
    snmp_get_sysuptime(&netif->ts);
#endif /* LWIP_SNMP */

    NETIF_STATUS_CALLBACK(netif);
   22bb0:	e0bfff17 	ldw	r2,-4(fp)
   22bb4:	10800717 	ldw	r2,28(r2)
   22bb8:	10000426 	beq	r2,zero,22bcc <netif_set_up+0x5c>
   22bbc:	e0bfff17 	ldw	r2,-4(fp)
   22bc0:	10800717 	ldw	r2,28(r2)
   22bc4:	e13fff17 	ldw	r4,-4(fp)
   22bc8:	103ee83a 	callr	r2

    if (netif->flags & NETIF_FLAG_LINK_UP) {
   22bcc:	e0bfff17 	ldw	r2,-4(fp)
   22bd0:	10800e43 	ldbu	r2,57(r2)
   22bd4:	10803fcc 	andi	r2,r2,255
   22bd8:	1080040c 	andi	r2,r2,16
   22bdc:	10000a26 	beq	r2,zero,22c08 <netif_set_up+0x98>
#if LWIP_ARP
      /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
      if (netif->flags & (NETIF_FLAG_ETHARP)) {
   22be0:	e0bfff17 	ldw	r2,-4(fp)
   22be4:	10800e43 	ldbu	r2,57(r2)
   22be8:	10803fcc 	andi	r2,r2,255
   22bec:	1080080c 	andi	r2,r2,32
   22bf0:	10000526 	beq	r2,zero,22c08 <netif_set_up+0x98>
        etharp_gratuitous(netif);
   22bf4:	e0bfff17 	ldw	r2,-4(fp)
   22bf8:	10800104 	addi	r2,r2,4
   22bfc:	e13fff17 	ldw	r4,-4(fp)
   22c00:	100b883a 	mov	r5,r2
   22c04:	003149c0 	call	3149c <etharp_request>
        igmp_report_groups( netif);
      }
#endif /* LWIP_IGMP */
    }
  }
}
   22c08:	e037883a 	mov	sp,fp
   22c0c:	dfc00117 	ldw	ra,4(sp)
   22c10:	df000017 	ldw	fp,0(sp)
   22c14:	dec00204 	addi	sp,sp,8
   22c18:	f800283a 	ret

00022c1c <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
   22c1c:	defffd04 	addi	sp,sp,-12
   22c20:	dfc00215 	stw	ra,8(sp)
   22c24:	df000115 	stw	fp,4(sp)
   22c28:	df000104 	addi	fp,sp,4
   22c2c:	e13fff15 	stw	r4,-4(fp)
  if (netif->flags & NETIF_FLAG_UP) {
   22c30:	e0bfff17 	ldw	r2,-4(fp)
   22c34:	10800e43 	ldbu	r2,57(r2)
   22c38:	10803fcc 	andi	r2,r2,255
   22c3c:	1080004c 	andi	r2,r2,1
   22c40:	10001526 	beq	r2,zero,22c98 <netif_set_down+0x7c>
    netif->flags &= ~NETIF_FLAG_UP;
   22c44:	e0bfff17 	ldw	r2,-4(fp)
   22c48:	10c00e43 	ldbu	r3,57(r2)
   22c4c:	00bfff84 	movi	r2,-2
   22c50:	1884703a 	and	r2,r3,r2
   22c54:	1007883a 	mov	r3,r2
   22c58:	e0bfff17 	ldw	r2,-4(fp)
   22c5c:	10c00e45 	stb	r3,57(r2)
#if LWIP_SNMP
    snmp_get_sysuptime(&netif->ts);
#endif

#if LWIP_ARP
    if (netif->flags & NETIF_FLAG_ETHARP) {
   22c60:	e0bfff17 	ldw	r2,-4(fp)
   22c64:	10800e43 	ldbu	r2,57(r2)
   22c68:	10803fcc 	andi	r2,r2,255
   22c6c:	1080080c 	andi	r2,r2,32
   22c70:	10000226 	beq	r2,zero,22c7c <netif_set_down+0x60>
      etharp_cleanup_netif(netif);
   22c74:	e13fff17 	ldw	r4,-4(fp)
   22c78:	00304e80 	call	304e8 <etharp_cleanup_netif>
    }
#endif /* LWIP_ARP */
    NETIF_STATUS_CALLBACK(netif);
   22c7c:	e0bfff17 	ldw	r2,-4(fp)
   22c80:	10800717 	ldw	r2,28(r2)
   22c84:	10000426 	beq	r2,zero,22c98 <netif_set_down+0x7c>
   22c88:	e0bfff17 	ldw	r2,-4(fp)
   22c8c:	10800717 	ldw	r2,28(r2)
   22c90:	e13fff17 	ldw	r4,-4(fp)
   22c94:	103ee83a 	callr	r2
  }
}
   22c98:	e037883a 	mov	sp,fp
   22c9c:	dfc00117 	ldw	ra,4(sp)
   22ca0:	df000017 	ldw	fp,0(sp)
   22ca4:	dec00204 	addi	sp,sp,8
   22ca8:	f800283a 	ret

00022cac <netif_set_status_callback>:
#if LWIP_NETIF_STATUS_CALLBACK
/**
 * Set callback to be called when interface is brought up/down
 */
void netif_set_status_callback(struct netif *netif, netif_status_callback_fn status_callback)
{
   22cac:	defffd04 	addi	sp,sp,-12
   22cb0:	df000215 	stw	fp,8(sp)
   22cb4:	df000204 	addi	fp,sp,8
   22cb8:	e13ffe15 	stw	r4,-8(fp)
   22cbc:	e17fff15 	stw	r5,-4(fp)
  if (netif) {
   22cc0:	e0bffe17 	ldw	r2,-8(fp)
   22cc4:	10000326 	beq	r2,zero,22cd4 <netif_set_status_callback+0x28>
    netif->status_callback = status_callback;
   22cc8:	e0bffe17 	ldw	r2,-8(fp)
   22ccc:	e0ffff17 	ldw	r3,-4(fp)
   22cd0:	10c00715 	stw	r3,28(r2)
  }
}
   22cd4:	e037883a 	mov	sp,fp
   22cd8:	df000017 	ldw	fp,0(sp)
   22cdc:	dec00104 	addi	sp,sp,4
   22ce0:	f800283a 	ret

00022ce4 <netif_set_link_up>:

/**
 * Called by a driver when its link goes up
 */
void netif_set_link_up(struct netif *netif )
{
   22ce4:	defffd04 	addi	sp,sp,-12
   22ce8:	dfc00215 	stw	ra,8(sp)
   22cec:	df000115 	stw	fp,4(sp)
   22cf0:	df000104 	addi	fp,sp,4
   22cf4:	e13fff15 	stw	r4,-4(fp)
  if (!(netif->flags & NETIF_FLAG_LINK_UP)) {
   22cf8:	e0bfff17 	ldw	r2,-4(fp)
   22cfc:	10800e43 	ldbu	r2,57(r2)
   22d00:	10803fcc 	andi	r2,r2,255
   22d04:	1080040c 	andi	r2,r2,16
   22d08:	1000211e 	bne	r2,zero,22d90 <netif_set_link_up+0xac>
    netif->flags |= NETIF_FLAG_LINK_UP;
   22d0c:	e0bfff17 	ldw	r2,-4(fp)
   22d10:	10800e43 	ldbu	r2,57(r2)
   22d14:	10800414 	ori	r2,r2,16
   22d18:	1007883a 	mov	r3,r2
   22d1c:	e0bfff17 	ldw	r2,-4(fp)
   22d20:	10c00e45 	stb	r3,57(r2)

#if LWIP_DHCP
    if (netif->dhcp) {
   22d24:	e0bfff17 	ldw	r2,-4(fp)
   22d28:	10800a17 	ldw	r2,40(r2)
   22d2c:	10000226 	beq	r2,zero,22d38 <netif_set_link_up+0x54>
      dhcp_network_changed(netif);
   22d30:	e13fff17 	ldw	r4,-4(fp)
   22d34:	001c86c0 	call	1c86c <dhcp_network_changed>
    if (netif->autoip) {
      autoip_network_changed(netif);
    }
#endif /* LWIP_AUTOIP */

    if (netif->flags & NETIF_FLAG_UP) {
   22d38:	e0bfff17 	ldw	r2,-4(fp)
   22d3c:	10800e43 	ldbu	r2,57(r2)
   22d40:	10803fcc 	andi	r2,r2,255
   22d44:	1080004c 	andi	r2,r2,1
   22d48:	10000a26 	beq	r2,zero,22d74 <netif_set_link_up+0x90>
#if LWIP_ARP
      /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
      if (netif->flags & NETIF_FLAG_ETHARP) {
   22d4c:	e0bfff17 	ldw	r2,-4(fp)
   22d50:	10800e43 	ldbu	r2,57(r2)
   22d54:	10803fcc 	andi	r2,r2,255
   22d58:	1080080c 	andi	r2,r2,32
   22d5c:	10000526 	beq	r2,zero,22d74 <netif_set_link_up+0x90>
        etharp_gratuitous(netif);
   22d60:	e0bfff17 	ldw	r2,-4(fp)
   22d64:	10800104 	addi	r2,r2,4
   22d68:	e13fff17 	ldw	r4,-4(fp)
   22d6c:	100b883a 	mov	r5,r2
   22d70:	003149c0 	call	3149c <etharp_request>
      if (netif->flags & NETIF_FLAG_IGMP) {
        igmp_report_groups( netif);
      }
#endif /* LWIP_IGMP */
    }
    NETIF_LINK_CALLBACK(netif);
   22d74:	e0bfff17 	ldw	r2,-4(fp)
   22d78:	10800817 	ldw	r2,32(r2)
   22d7c:	10000426 	beq	r2,zero,22d90 <netif_set_link_up+0xac>
   22d80:	e0bfff17 	ldw	r2,-4(fp)
   22d84:	10800817 	ldw	r2,32(r2)
   22d88:	e13fff17 	ldw	r4,-4(fp)
   22d8c:	103ee83a 	callr	r2
  }
}
   22d90:	e037883a 	mov	sp,fp
   22d94:	dfc00117 	ldw	ra,4(sp)
   22d98:	df000017 	ldw	fp,0(sp)
   22d9c:	dec00204 	addi	sp,sp,8
   22da0:	f800283a 	ret

00022da4 <netif_set_link_down>:

/**
 * Called by a driver when its link goes down
 */
void netif_set_link_down(struct netif *netif )
{
   22da4:	defffd04 	addi	sp,sp,-12
   22da8:	dfc00215 	stw	ra,8(sp)
   22dac:	df000115 	stw	fp,4(sp)
   22db0:	df000104 	addi	fp,sp,4
   22db4:	e13fff15 	stw	r4,-4(fp)
  if (netif->flags & NETIF_FLAG_LINK_UP) {
   22db8:	e0bfff17 	ldw	r2,-4(fp)
   22dbc:	10800e43 	ldbu	r2,57(r2)
   22dc0:	10803fcc 	andi	r2,r2,255
   22dc4:	1080040c 	andi	r2,r2,16
   22dc8:	10000e26 	beq	r2,zero,22e04 <netif_set_link_down+0x60>
    netif->flags &= ~NETIF_FLAG_LINK_UP;
   22dcc:	e0bfff17 	ldw	r2,-4(fp)
   22dd0:	10c00e43 	ldbu	r3,57(r2)
   22dd4:	00bffbc4 	movi	r2,-17
   22dd8:	1884703a 	and	r2,r3,r2
   22ddc:	1007883a 	mov	r3,r2
   22de0:	e0bfff17 	ldw	r2,-4(fp)
   22de4:	10c00e45 	stb	r3,57(r2)
    NETIF_LINK_CALLBACK(netif);
   22de8:	e0bfff17 	ldw	r2,-4(fp)
   22dec:	10800817 	ldw	r2,32(r2)
   22df0:	10000426 	beq	r2,zero,22e04 <netif_set_link_down+0x60>
   22df4:	e0bfff17 	ldw	r2,-4(fp)
   22df8:	10800817 	ldw	r2,32(r2)
   22dfc:	e13fff17 	ldw	r4,-4(fp)
   22e00:	103ee83a 	callr	r2
  }
}
   22e04:	e037883a 	mov	sp,fp
   22e08:	dfc00117 	ldw	ra,4(sp)
   22e0c:	df000017 	ldw	fp,0(sp)
   22e10:	dec00204 	addi	sp,sp,8
   22e14:	f800283a 	ret

00022e18 <netif_set_link_callback>:
#if LWIP_NETIF_LINK_CALLBACK
/**
 * Set callback to be called when link is brought up/down
 */
void netif_set_link_callback(struct netif *netif, netif_status_callback_fn link_callback)
{
   22e18:	defffd04 	addi	sp,sp,-12
   22e1c:	df000215 	stw	fp,8(sp)
   22e20:	df000204 	addi	fp,sp,8
   22e24:	e13ffe15 	stw	r4,-8(fp)
   22e28:	e17fff15 	stw	r5,-4(fp)
  if (netif) {
   22e2c:	e0bffe17 	ldw	r2,-8(fp)
   22e30:	10000326 	beq	r2,zero,22e40 <netif_set_link_callback+0x28>
    netif->link_callback = link_callback;
   22e34:	e0bffe17 	ldw	r2,-8(fp)
   22e38:	e0ffff17 	ldw	r3,-4(fp)
   22e3c:	10c00815 	stw	r3,32(r2)
  }
}
   22e40:	e037883a 	mov	sp,fp
   22e44:	df000017 	ldw	fp,0(sp)
   22e48:	dec00104 	addi	sp,sp,4
   22e4c:	f800283a 	ret

00022e50 <pbuf_free_ooseq>:
#if !NO_SYS
static
#endif /* !NO_SYS */
void
pbuf_free_ooseq(void)
{
   22e50:	defffd04 	addi	sp,sp,-12
   22e54:	dfc00215 	stw	ra,8(sp)
   22e58:	df000115 	stw	fp,4(sp)
   22e5c:	df000104 	addi	fp,sp,4
  struct tcp_pcb* pcb;
  SYS_ARCH_DECL_PROTECT(old_level);

  SYS_ARCH_PROTECT(old_level);
   22e60:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   22e64:	10000126 	beq	r2,zero,22e6c <pbuf_free_ooseq+0x1c>
   22e68:	00110d00 	call	110d0 <vTaskEnterCritical>
  pbuf_free_ooseq_pending = 0;
   22e6c:	d0293305 	stb	zero,-23348(gp)
  SYS_ARCH_UNPROTECT(old_level);
   22e70:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   22e74:	10000126 	beq	r2,zero,22e7c <pbuf_free_ooseq+0x2c>
   22e78:	00111100 	call	11110 <vTaskExitCritical>

  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
   22e7c:	00800134 	movhi	r2,4
   22e80:	109ef204 	addi	r2,r2,31688
   22e84:	10800017 	ldw	r2,0(r2)
   22e88:	e0bfff15 	stw	r2,-4(fp)
   22e8c:	00000d06 	br	22ec4 <pbuf_free_ooseq+0x74>
    if (NULL != pcb->ooseq) {
   22e90:	e0bfff17 	ldw	r2,-4(fp)
   22e94:	10801e17 	ldw	r2,120(r2)
   22e98:	10000726 	beq	r2,zero,22eb8 <pbuf_free_ooseq+0x68>
      /** Free the ooseq pbufs of one PCB only */
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free_ooseq: freeing out-of-sequence pbufs\n"));
      tcp_segs_free(pcb->ooseq);
   22e9c:	e0bfff17 	ldw	r2,-4(fp)
   22ea0:	10801e17 	ldw	r2,120(r2)
   22ea4:	1009883a 	mov	r4,r2
   22ea8:	00264a80 	call	264a8 <tcp_segs_free>
      pcb->ooseq = NULL;
   22eac:	e0bfff17 	ldw	r2,-4(fp)
   22eb0:	10001e15 	stw	zero,120(r2)
      return;
   22eb4:	00000506 	br	22ecc <pbuf_free_ooseq+0x7c>

  SYS_ARCH_PROTECT(old_level);
  pbuf_free_ooseq_pending = 0;
  SYS_ARCH_UNPROTECT(old_level);

  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
   22eb8:	e0bfff17 	ldw	r2,-4(fp)
   22ebc:	10800317 	ldw	r2,12(r2)
   22ec0:	e0bfff15 	stw	r2,-4(fp)
   22ec4:	e0bfff17 	ldw	r2,-4(fp)
   22ec8:	103ff11e 	bne	r2,zero,22e90 <pbuf_free_ooseq+0x40>
      tcp_segs_free(pcb->ooseq);
      pcb->ooseq = NULL;
      return;
    }
  }
}
   22ecc:	e037883a 	mov	sp,fp
   22ed0:	dfc00117 	ldw	ra,4(sp)
   22ed4:	df000017 	ldw	fp,0(sp)
   22ed8:	dec00204 	addi	sp,sp,8
   22edc:	f800283a 	ret

00022ee0 <pbuf_free_ooseq_callback>:
/**
 * Just a callback function for tcpip_timeout() that calls pbuf_free_ooseq().
 */
static void
pbuf_free_ooseq_callback(void *arg)
{
   22ee0:	defffd04 	addi	sp,sp,-12
   22ee4:	dfc00215 	stw	ra,8(sp)
   22ee8:	df000115 	stw	fp,4(sp)
   22eec:	df000104 	addi	fp,sp,4
   22ef0:	e13fff15 	stw	r4,-4(fp)
  LWIP_UNUSED_ARG(arg);
  pbuf_free_ooseq();
   22ef4:	0022e500 	call	22e50 <pbuf_free_ooseq>
}
   22ef8:	e037883a 	mov	sp,fp
   22efc:	dfc00117 	ldw	ra,4(sp)
   22f00:	df000017 	ldw	fp,0(sp)
   22f04:	dec00204 	addi	sp,sp,8
   22f08:	f800283a 	ret

00022f0c <pbuf_pool_is_empty>:
#endif /* !NO_SYS */

/** Queue a call to pbuf_free_ooseq if not already queued. */
static void
pbuf_pool_is_empty(void)
{
   22f0c:	defffd04 	addi	sp,sp,-12
   22f10:	dfc00215 	stw	ra,8(sp)
   22f14:	df000115 	stw	fp,4(sp)
   22f18:	df000104 	addi	fp,sp,4
  pbuf_free_ooseq_pending = 1;
  SYS_ARCH_UNPROTECT(old_level);
#else /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
  u8_t queued;
  SYS_ARCH_DECL_PROTECT(old_level);
  SYS_ARCH_PROTECT(old_level);
   22f1c:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   22f20:	10000126 	beq	r2,zero,22f28 <pbuf_pool_is_empty+0x1c>
   22f24:	00110d00 	call	110d0 <vTaskEnterCritical>
  queued = pbuf_free_ooseq_pending;
   22f28:	d0a93303 	ldbu	r2,-23348(gp)
   22f2c:	e0bfff05 	stb	r2,-4(fp)
  pbuf_free_ooseq_pending = 1;
   22f30:	00800044 	movi	r2,1
   22f34:	d0a93305 	stb	r2,-23348(gp)
  SYS_ARCH_UNPROTECT(old_level);
   22f38:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   22f3c:	10000126 	beq	r2,zero,22f44 <pbuf_pool_is_empty+0x38>
   22f40:	00111100 	call	11110 <vTaskExitCritical>

  if(!queued) {
   22f44:	e0bfff03 	ldbu	r2,-4(fp)
   22f48:	1000101e 	bne	r2,zero,22f8c <pbuf_pool_is_empty+0x80>
    /* queue a call to pbuf_free_ooseq if not already queued */
    PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
   22f4c:	010000b4 	movhi	r4,2
   22f50:	210bb804 	addi	r4,r4,12000
   22f54:	000b883a 	mov	r5,zero
   22f58:	000d883a 	mov	r6,zero
   22f5c:	001954c0 	call	1954c <tcpip_callback_with_block>
   22f60:	10803fcc 	andi	r2,r2,255
   22f64:	1080201c 	xori	r2,r2,128
   22f68:	10bfe004 	addi	r2,r2,-128
   22f6c:	10000726 	beq	r2,zero,22f8c <pbuf_pool_is_empty+0x80>
   22f70:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   22f74:	10000126 	beq	r2,zero,22f7c <pbuf_pool_is_empty+0x70>
   22f78:	00110d00 	call	110d0 <vTaskEnterCritical>
   22f7c:	d0293305 	stb	zero,-23348(gp)
   22f80:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   22f84:	10000126 	beq	r2,zero,22f8c <pbuf_pool_is_empty+0x80>
   22f88:	00111100 	call	11110 <vTaskExitCritical>
  }
#endif /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
}
   22f8c:	e037883a 	mov	sp,fp
   22f90:	dfc00117 	ldw	ra,4(sp)
   22f94:	df000017 	ldw	fp,0(sp)
   22f98:	dec00204 	addi	sp,sp,8
   22f9c:	f800283a 	ret

00022fa0 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
   22fa0:	defff604 	addi	sp,sp,-40
   22fa4:	dfc00915 	stw	ra,36(sp)
   22fa8:	df000815 	stw	fp,32(sp)
   22fac:	df000804 	addi	fp,sp,32
   22fb0:	e13ffd15 	stw	r4,-12(fp)
   22fb4:	2805883a 	mov	r2,r5
   22fb8:	e1bfff15 	stw	r6,-4(fp)
   22fbc:	e0bffe0d 	sth	r2,-8(fp)
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  switch (layer) {
   22fc0:	e0bffd17 	ldw	r2,-12(fp)
   22fc4:	10c00060 	cmpeqi	r3,r2,1
   22fc8:	1800091e 	bne	r3,zero,22ff0 <pbuf_alloc+0x50>
   22fcc:	0080052e 	bgeu	zero,r2,22fe4 <pbuf_alloc+0x44>
   22fd0:	10c000a0 	cmpeqi	r3,r2,2
   22fd4:	1800091e 	bne	r3,zero,22ffc <pbuf_alloc+0x5c>
   22fd8:	108000e0 	cmpeqi	r2,r2,3
   22fdc:	10000a1e 	bne	r2,zero,23008 <pbuf_alloc+0x68>
   22fe0:	00000b06 	br	23010 <pbuf_alloc+0x70>
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
   22fe4:	00800e04 	movi	r2,56
   22fe8:	e0bffa0d 	sth	r2,-24(fp)
    break;
   22fec:	00000a06 	br	23018 <pbuf_alloc+0x78>
  case PBUF_IP:
    /* add room for IP layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
   22ff0:	00800904 	movi	r2,36
   22ff4:	e0bffa0d 	sth	r2,-24(fp)
    break;
   22ff8:	00000706 	br	23018 <pbuf_alloc+0x78>
  case PBUF_LINK:
    /* add room for link layer header */
    offset = PBUF_LINK_HLEN;
   22ffc:	00800404 	movi	r2,16
   23000:	e0bffa0d 	sth	r2,-24(fp)
    break;
   23004:	00000406 	br	23018 <pbuf_alloc+0x78>
  case PBUF_RAW:
    offset = 0;
   23008:	e03ffa0d 	sth	zero,-24(fp)
    break;
   2300c:	00000206 	br	23018 <pbuf_alloc+0x78>
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
   23010:	0005883a 	mov	r2,zero
   23014:	0000b906 	br	232fc <pbuf_alloc+0x35c>
  }

  switch (type) {
   23018:	e0bfff17 	ldw	r2,-4(fp)
   2301c:	10c000e8 	cmpgeui	r3,r2,3
   23020:	1800021e 	bne	r3,zero,2302c <pbuf_alloc+0x8c>
   23024:	00809636 	bltu	zero,r2,23280 <pbuf_alloc+0x2e0>
   23028:	00006906 	br	231d0 <pbuf_alloc+0x230>
   2302c:	108000e0 	cmpeqi	r2,r2,3
   23030:	1000aa26 	beq	r2,zero,232dc <pbuf_alloc+0x33c>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
    p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
   23034:	01000384 	movi	r4,14
   23038:	00223cc0 	call	223cc <memp_malloc>
   2303c:	e0bff815 	stw	r2,-32(fp)
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
   23040:	e0bff817 	ldw	r2,-32(fp)
   23044:	1000031e 	bne	r2,zero,23054 <pbuf_alloc+0xb4>
      PBUF_POOL_IS_EMPTY();
   23048:	0022f0c0 	call	22f0c <pbuf_pool_is_empty>
      return NULL;
   2304c:	0005883a 	mov	r2,zero
   23050:	0000aa06 	br	232fc <pbuf_alloc+0x35c>
    }
    p->type = type;
   23054:	e0bfff17 	ldw	r2,-4(fp)
   23058:	1007883a 	mov	r3,r2
   2305c:	e0bff817 	ldw	r2,-32(fp)
   23060:	10c00305 	stb	r3,12(r2)
    p->next = NULL;
   23064:	e0bff817 	ldw	r2,-32(fp)
   23068:	10000015 	stw	zero,0(r2)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
   2306c:	e0bffa0b 	ldhu	r2,-24(fp)
   23070:	10800404 	addi	r2,r2,16
   23074:	e0fff817 	ldw	r3,-32(fp)
   23078:	1885883a 	add	r2,r3,r2
   2307c:	10c000c4 	addi	r3,r2,3
   23080:	00bfff04 	movi	r2,-4
   23084:	1884703a 	and	r2,r3,r2
   23088:	1007883a 	mov	r3,r2
   2308c:	e0bff817 	ldw	r2,-32(fp)
   23090:	10c00115 	stw	r3,4(r2)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
   23094:	e0bff817 	ldw	r2,-32(fp)
   23098:	e0fffe0b 	ldhu	r3,-8(fp)
   2309c:	10c0020d 	sth	r3,8(r2)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
   230a0:	e0bffa0b 	ldhu	r2,-24(fp)
   230a4:	10c000c4 	addi	r3,r2,3
   230a8:	00bfff04 	movi	r2,-4
   230ac:	1884703a 	and	r2,r3,r2
   230b0:	00c17b04 	movi	r3,1516
   230b4:	1885c83a 	sub	r2,r3,r2
   230b8:	e0fffe0b 	ldhu	r3,-8(fp)
   230bc:	1880010e 	bge	r3,r2,230c4 <pbuf_alloc+0x124>
   230c0:	1805883a 	mov	r2,r3
   230c4:	1007883a 	mov	r3,r2
   230c8:	e0bff817 	ldw	r2,-32(fp)
   230cc:	10c0028d 	sth	r3,10(r2)
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
      (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
   230d0:	e0bff817 	ldw	r2,-32(fp)
   230d4:	00c00044 	movi	r3,1
   230d8:	10c0038d 	sth	r3,14(r2)

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
   230dc:	e0bff817 	ldw	r2,-32(fp)
   230e0:	e0bff915 	stw	r2,-28(fp)
    /* remaining length to be allocated */
    rem_len = length - p->len;
   230e4:	e0fffe0b 	ldhu	r3,-8(fp)
   230e8:	e0bff817 	ldw	r2,-32(fp)
   230ec:	1080028b 	ldhu	r2,10(r2)
   230f0:	10bfffcc 	andi	r2,r2,65535
   230f4:	1885c83a 	sub	r2,r3,r2
   230f8:	e0bffb15 	stw	r2,-20(fp)
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
   230fc:	00003106 	br	231c4 <pbuf_alloc+0x224>
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
   23100:	01000384 	movi	r4,14
   23104:	00223cc0 	call	223cc <memp_malloc>
   23108:	e0bffc15 	stw	r2,-16(fp)
      if (q == NULL) {
   2310c:	e0bffc17 	ldw	r2,-16(fp)
   23110:	1000051e 	bne	r2,zero,23128 <pbuf_alloc+0x188>
        PBUF_POOL_IS_EMPTY();
   23114:	0022f0c0 	call	22f0c <pbuf_pool_is_empty>
        /* free chain so far allocated */
        pbuf_free(p);
   23118:	e13ff817 	ldw	r4,-32(fp)
   2311c:	00237600 	call	23760 <pbuf_free>
        /* bail out unsuccesfully */
        return NULL;
   23120:	0005883a 	mov	r2,zero
   23124:	00007506 	br	232fc <pbuf_alloc+0x35c>
      }
      q->type = type;
   23128:	e0bfff17 	ldw	r2,-4(fp)
   2312c:	1007883a 	mov	r3,r2
   23130:	e0bffc17 	ldw	r2,-16(fp)
   23134:	10c00305 	stb	r3,12(r2)
      q->flags = 0;
   23138:	e0bffc17 	ldw	r2,-16(fp)
   2313c:	10000345 	stb	zero,13(r2)
      q->next = NULL;
   23140:	e0bffc17 	ldw	r2,-16(fp)
   23144:	10000015 	stw	zero,0(r2)
      /* make previous pbuf point to this pbuf */
      r->next = q;
   23148:	e0bff917 	ldw	r2,-28(fp)
   2314c:	e0fffc17 	ldw	r3,-16(fp)
   23150:	10c00015 	stw	r3,0(r2)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
   23154:	e0bffb17 	ldw	r2,-20(fp)
   23158:	1007883a 	mov	r3,r2
   2315c:	e0bffc17 	ldw	r2,-16(fp)
   23160:	10c0020d 	sth	r3,8(r2)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
   23164:	e0bffb17 	ldw	r2,-20(fp)
   23168:	10bfffcc 	andi	r2,r2,65535
   2316c:	10817b28 	cmpgeui	r2,r2,1516
   23170:	1000021e 	bne	r2,zero,2317c <pbuf_alloc+0x1dc>
   23174:	e0bffb17 	ldw	r2,-20(fp)
   23178:	00000106 	br	23180 <pbuf_alloc+0x1e0>
   2317c:	00817b04 	movi	r2,1516
   23180:	e0fffc17 	ldw	r3,-16(fp)
   23184:	1880028d 	sth	r2,10(r3)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
   23188:	e0bffc17 	ldw	r2,-16(fp)
   2318c:	10c00404 	addi	r3,r2,16
   23190:	e0bffc17 	ldw	r2,-16(fp)
   23194:	10c00115 	stw	r3,4(r2)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
   23198:	e0bffc17 	ldw	r2,-16(fp)
   2319c:	00c00044 	movi	r3,1
   231a0:	10c0038d 	sth	r3,14(r2)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
   231a4:	e0bffc17 	ldw	r2,-16(fp)
   231a8:	1080028b 	ldhu	r2,10(r2)
   231ac:	10bfffcc 	andi	r2,r2,65535
   231b0:	e0fffb17 	ldw	r3,-20(fp)
   231b4:	1885c83a 	sub	r2,r3,r2
   231b8:	e0bffb15 	stw	r2,-20(fp)
      /* remember this pbuf for linkage in next iteration */
      r = q;
   231bc:	e0bffc17 	ldw	r2,-16(fp)
   231c0:	e0bff915 	stw	r2,-28(fp)
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
   231c4:	e0bffb17 	ldw	r2,-20(fp)
   231c8:	00bfcd16 	blt	zero,r2,23100 <pbuf_alloc+0x160>
      r = q;
    }
    /* end of chain */
    /*r->next = NULL;*/

    break;
   231cc:	00004506 	br	232e4 <pbuf_alloc+0x344>
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
   231d0:	e0bffa0b 	ldhu	r2,-24(fp)
   231d4:	108004c4 	addi	r2,r2,19
   231d8:	1007883a 	mov	r3,r2
   231dc:	00bfff04 	movi	r2,-4
   231e0:	1884703a 	and	r2,r3,r2
   231e4:	1007883a 	mov	r3,r2
   231e8:	e0bffe0b 	ldhu	r2,-8(fp)
   231ec:	108000c4 	addi	r2,r2,3
   231f0:	1009883a 	mov	r4,r2
   231f4:	00bfff04 	movi	r2,-4
   231f8:	2084703a 	and	r2,r4,r2
   231fc:	1885883a 	add	r2,r3,r2
   23200:	10bfffcc 	andi	r2,r2,65535
   23204:	1009883a 	mov	r4,r2
   23208:	0021e680 	call	21e68 <mem_malloc>
   2320c:	e0bff815 	stw	r2,-32(fp)
    if (p == NULL) {
   23210:	e0bff817 	ldw	r2,-32(fp)
   23214:	1000021e 	bne	r2,zero,23220 <pbuf_alloc+0x280>
      return NULL;
   23218:	0005883a 	mov	r2,zero
   2321c:	00003706 	br	232fc <pbuf_alloc+0x35c>
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
   23220:	e0bffa0b 	ldhu	r2,-24(fp)
   23224:	10800404 	addi	r2,r2,16
   23228:	e0fff817 	ldw	r3,-32(fp)
   2322c:	1885883a 	add	r2,r3,r2
   23230:	10c000c4 	addi	r3,r2,3
   23234:	00bfff04 	movi	r2,-4
   23238:	1884703a 	and	r2,r3,r2
   2323c:	1007883a 	mov	r3,r2
   23240:	e0bff817 	ldw	r2,-32(fp)
   23244:	10c00115 	stw	r3,4(r2)
    p->len = p->tot_len = length;
   23248:	e0bff817 	ldw	r2,-32(fp)
   2324c:	e0fffe0b 	ldhu	r3,-8(fp)
   23250:	10c0020d 	sth	r3,8(r2)
   23254:	e0bff817 	ldw	r2,-32(fp)
   23258:	10c0020b 	ldhu	r3,8(r2)
   2325c:	e0bff817 	ldw	r2,-32(fp)
   23260:	10c0028d 	sth	r3,10(r2)
    p->next = NULL;
   23264:	e0bff817 	ldw	r2,-32(fp)
   23268:	10000015 	stw	zero,0(r2)
    p->type = type;
   2326c:	e0bfff17 	ldw	r2,-4(fp)
   23270:	1007883a 	mov	r3,r2
   23274:	e0bff817 	ldw	r2,-32(fp)
   23278:	10c00305 	stb	r3,12(r2)

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
           ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    break;
   2327c:	00001906 	br	232e4 <pbuf_alloc+0x344>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = (struct pbuf *)memp_malloc(MEMP_PBUF);
   23280:	01000344 	movi	r4,13
   23284:	00223cc0 	call	223cc <memp_malloc>
   23288:	e0bff815 	stw	r2,-32(fp)
    if (p == NULL) {
   2328c:	e0bff817 	ldw	r2,-32(fp)
   23290:	1000021e 	bne	r2,zero,2329c <pbuf_alloc+0x2fc>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                  ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
   23294:	0005883a 	mov	r2,zero
   23298:	00001806 	br	232fc <pbuf_alloc+0x35c>
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
   2329c:	e0bff817 	ldw	r2,-32(fp)
   232a0:	10000115 	stw	zero,4(r2)
    p->len = p->tot_len = length;
   232a4:	e0bff817 	ldw	r2,-32(fp)
   232a8:	e0fffe0b 	ldhu	r3,-8(fp)
   232ac:	10c0020d 	sth	r3,8(r2)
   232b0:	e0bff817 	ldw	r2,-32(fp)
   232b4:	10c0020b 	ldhu	r3,8(r2)
   232b8:	e0bff817 	ldw	r2,-32(fp)
   232bc:	10c0028d 	sth	r3,10(r2)
    p->next = NULL;
   232c0:	e0bff817 	ldw	r2,-32(fp)
   232c4:	10000015 	stw	zero,0(r2)
    p->type = type;
   232c8:	e0bfff17 	ldw	r2,-4(fp)
   232cc:	1007883a 	mov	r3,r2
   232d0:	e0bff817 	ldw	r2,-32(fp)
   232d4:	10c00305 	stb	r3,12(r2)
    break;
   232d8:	00000206 	br	232e4 <pbuf_alloc+0x344>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
    return NULL;
   232dc:	0005883a 	mov	r2,zero
   232e0:	00000606 	br	232fc <pbuf_alloc+0x35c>
  }
  /* set reference count */
  p->ref = 1;
   232e4:	e0bff817 	ldw	r2,-32(fp)
   232e8:	00c00044 	movi	r3,1
   232ec:	10c0038d 	sth	r3,14(r2)
  /* set flags */
  p->flags = 0;
   232f0:	e0bff817 	ldw	r2,-32(fp)
   232f4:	10000345 	stb	zero,13(r2)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
   232f8:	e0bff817 	ldw	r2,-32(fp)
}
   232fc:	e037883a 	mov	sp,fp
   23300:	dfc00117 	ldw	ra,4(sp)
   23304:	df000017 	ldw	fp,0(sp)
   23308:	dec00204 	addi	sp,sp,8
   2330c:	f800283a 	ret

00023310 <pbuf_alloced_custom>:
 *        big enough to hold 'length' plus the header size
 */
struct pbuf*
pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type, struct pbuf_custom *p,
                    void *payload_mem, u16_t payload_mem_len)
{
   23310:	defff904 	addi	sp,sp,-28
   23314:	df000615 	stw	fp,24(sp)
   23318:	df000604 	addi	fp,sp,24
   2331c:	e13ffb15 	stw	r4,-20(fp)
   23320:	2805883a 	mov	r2,r5
   23324:	e1bffd15 	stw	r6,-12(fp)
   23328:	e1fffe15 	stw	r7,-8(fp)
   2332c:	e0c00217 	ldw	r3,8(fp)
   23330:	e0bffc0d 	sth	r2,-16(fp)
   23334:	e0ffff0d 	sth	r3,-4(fp)
  u16_t offset;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloced_custom(length=%"U16_F")\n", length));

  /* determine header offset */
  switch (l) {
   23338:	e0bffb17 	ldw	r2,-20(fp)
   2333c:	10c00060 	cmpeqi	r3,r2,1
   23340:	1800091e 	bne	r3,zero,23368 <pbuf_alloced_custom+0x58>
   23344:	0080052e 	bgeu	zero,r2,2335c <pbuf_alloced_custom+0x4c>
   23348:	10c000a0 	cmpeqi	r3,r2,2
   2334c:	1800091e 	bne	r3,zero,23374 <pbuf_alloced_custom+0x64>
   23350:	108000e0 	cmpeqi	r2,r2,3
   23354:	10000a1e 	bne	r2,zero,23380 <pbuf_alloced_custom+0x70>
   23358:	00000b06 	br	23388 <pbuf_alloced_custom+0x78>
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
   2335c:	00800e04 	movi	r2,56
   23360:	e0bffa0d 	sth	r2,-24(fp)
    break;
   23364:	00000a06 	br	23390 <pbuf_alloced_custom+0x80>
  case PBUF_IP:
    /* add room for IP layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
   23368:	00800904 	movi	r2,36
   2336c:	e0bffa0d 	sth	r2,-24(fp)
    break;
   23370:	00000706 	br	23390 <pbuf_alloced_custom+0x80>
  case PBUF_LINK:
    /* add room for link layer header */
    offset = PBUF_LINK_HLEN;
   23374:	00800404 	movi	r2,16
   23378:	e0bffa0d 	sth	r2,-24(fp)
    break;
   2337c:	00000406 	br	23390 <pbuf_alloced_custom+0x80>
  case PBUF_RAW:
    offset = 0;
   23380:	e03ffa0d 	sth	zero,-24(fp)
    break;
   23384:	00000206 	br	23390 <pbuf_alloced_custom+0x80>
  default:
    LWIP_ASSERT("pbuf_alloced_custom: bad pbuf layer", 0);
    return NULL;
   23388:	0005883a 	mov	r2,zero
   2338c:	00002c06 	br	23440 <pbuf_alloced_custom+0x130>
  }

  if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
   23390:	e0bffa0b 	ldhu	r2,-24(fp)
   23394:	10c000c4 	addi	r3,r2,3
   23398:	00bfff04 	movi	r2,-4
   2339c:	1886703a 	and	r3,r3,r2
   233a0:	e0bffc0b 	ldhu	r2,-16(fp)
   233a4:	1885883a 	add	r2,r3,r2
   233a8:	e0ffff0b 	ldhu	r3,-4(fp)
   233ac:	1880020e 	bge	r3,r2,233b8 <pbuf_alloced_custom+0xa8>
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("pbuf_alloced_custom(length=%"U16_F") buffer too short\n", length));
    return NULL;
   233b0:	0005883a 	mov	r2,zero
   233b4:	00002206 	br	23440 <pbuf_alloced_custom+0x130>
  }

  p->pbuf.next = NULL;
   233b8:	e0bffe17 	ldw	r2,-8(fp)
   233bc:	10000015 	stw	zero,0(r2)
  if (payload_mem != NULL) {
   233c0:	e0800117 	ldw	r2,4(fp)
   233c4:	10000a26 	beq	r2,zero,233f0 <pbuf_alloced_custom+0xe0>
    p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
   233c8:	e0bffa0b 	ldhu	r2,-24(fp)
   233cc:	108000c4 	addi	r2,r2,3
   233d0:	1007883a 	mov	r3,r2
   233d4:	00bfff04 	movi	r2,-4
   233d8:	1884703a 	and	r2,r3,r2
   233dc:	e0c00117 	ldw	r3,4(fp)
   233e0:	1887883a 	add	r3,r3,r2
   233e4:	e0bffe17 	ldw	r2,-8(fp)
   233e8:	10c00115 	stw	r3,4(r2)
   233ec:	00000206 	br	233f8 <pbuf_alloced_custom+0xe8>
  } else {
    p->pbuf.payload = NULL;
   233f0:	e0bffe17 	ldw	r2,-8(fp)
   233f4:	10000115 	stw	zero,4(r2)
  }
  p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
   233f8:	e0bffe17 	ldw	r2,-8(fp)
   233fc:	00c00084 	movi	r3,2
   23400:	10c00345 	stb	r3,13(r2)
  p->pbuf.len = p->pbuf.tot_len = length;
   23404:	e0bffe17 	ldw	r2,-8(fp)
   23408:	e0fffc0b 	ldhu	r3,-16(fp)
   2340c:	10c0020d 	sth	r3,8(r2)
   23410:	e0bffe17 	ldw	r2,-8(fp)
   23414:	10c0020b 	ldhu	r3,8(r2)
   23418:	e0bffe17 	ldw	r2,-8(fp)
   2341c:	10c0028d 	sth	r3,10(r2)
  p->pbuf.type = type;
   23420:	e0bffd17 	ldw	r2,-12(fp)
   23424:	1007883a 	mov	r3,r2
   23428:	e0bffe17 	ldw	r2,-8(fp)
   2342c:	10c00305 	stb	r3,12(r2)
  p->pbuf.ref = 1;
   23430:	e0bffe17 	ldw	r2,-8(fp)
   23434:	00c00044 	movi	r3,1
   23438:	10c0038d 	sth	r3,14(r2)
  return &p->pbuf;
   2343c:	e0bffe17 	ldw	r2,-8(fp)
}
   23440:	e037883a 	mov	sp,fp
   23444:	df000017 	ldw	fp,0(sp)
   23448:	dec00104 	addi	sp,sp,4
   2344c:	f800283a 	ret

00023450 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
   23450:	defff904 	addi	sp,sp,-28
   23454:	dfc00615 	stw	ra,24(sp)
   23458:	df000515 	stw	fp,20(sp)
   2345c:	df000504 	addi	fp,sp,20
   23460:	e13ffe15 	stw	r4,-8(fp)
   23464:	2805883a 	mov	r2,r5
   23468:	e0bfff0d 	sth	r2,-4(fp)
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
   2346c:	e0bffe17 	ldw	r2,-8(fp)
   23470:	1080020b 	ldhu	r2,8(r2)
   23474:	10bfffcc 	andi	r2,r2,65535
   23478:	e0ffff0b 	ldhu	r3,-4(fp)
   2347c:	1880462e 	bgeu	r3,r2,23598 <pbuf_realloc+0x148>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
   23480:	e0ffff0b 	ldhu	r3,-4(fp)
   23484:	e0bffe17 	ldw	r2,-8(fp)
   23488:	1080020b 	ldhu	r2,8(r2)
   2348c:	10bfffcc 	andi	r2,r2,65535
   23490:	1885c83a 	sub	r2,r3,r2
   23494:	e0bffd15 	stw	r2,-12(fp)

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
   23498:	e0bfff0b 	ldhu	r2,-4(fp)
   2349c:	e0bffc0d 	sth	r2,-16(fp)
  q = p;
   234a0:	e0bffe17 	ldw	r2,-8(fp)
   234a4:	e0bffb15 	stw	r2,-20(fp)
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
   234a8:	00000f06 	br	234e8 <pbuf_realloc+0x98>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
   234ac:	e0bffb17 	ldw	r2,-20(fp)
   234b0:	1080028b 	ldhu	r2,10(r2)
   234b4:	e0fffc0b 	ldhu	r3,-16(fp)
   234b8:	1885c83a 	sub	r2,r3,r2
   234bc:	e0bffc0d 	sth	r2,-16(fp)
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
    q->tot_len += (u16_t)grow;
   234c0:	e0bffb17 	ldw	r2,-20(fp)
   234c4:	10c0020b 	ldhu	r3,8(r2)
   234c8:	e0bffd17 	ldw	r2,-12(fp)
   234cc:	1885883a 	add	r2,r3,r2
   234d0:	1007883a 	mov	r3,r2
   234d4:	e0bffb17 	ldw	r2,-20(fp)
   234d8:	10c0020d 	sth	r3,8(r2)
    /* proceed to next pbuf in chain */
    q = q->next;
   234dc:	e0bffb17 	ldw	r2,-20(fp)
   234e0:	10800017 	ldw	r2,0(r2)
   234e4:	e0bffb15 	stw	r2,-20(fp)

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
   234e8:	e0bffb17 	ldw	r2,-20(fp)
   234ec:	1080028b 	ldhu	r2,10(r2)
   234f0:	10ffffcc 	andi	r3,r2,65535
   234f4:	e0bffc0b 	ldhu	r2,-16(fp)
   234f8:	18bfec36 	bltu	r3,r2,234ac <pbuf_realloc+0x5c>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
   234fc:	e0bffb17 	ldw	r2,-20(fp)
   23500:	10800303 	ldbu	r2,12(r2)
   23504:	10803fcc 	andi	r2,r2,255
   23508:	1000121e 	bne	r2,zero,23554 <pbuf_realloc+0x104>
   2350c:	e0bffb17 	ldw	r2,-20(fp)
   23510:	1080028b 	ldhu	r2,10(r2)
   23514:	10ffffcc 	andi	r3,r2,65535
   23518:	e0bffc0b 	ldhu	r2,-16(fp)
   2351c:	18800d26 	beq	r3,r2,23554 <pbuf_realloc+0x104>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
   23520:	e0bffb17 	ldw	r2,-20(fp)
   23524:	10800117 	ldw	r2,4(r2)
   23528:	1007883a 	mov	r3,r2
   2352c:	e0bffb17 	ldw	r2,-20(fp)
   23530:	1885c83a 	sub	r2,r3,r2
   23534:	1007883a 	mov	r3,r2
   23538:	e0bffc0b 	ldhu	r2,-16(fp)
   2353c:	1885883a 	add	r2,r3,r2
   23540:	10bfffcc 	andi	r2,r2,65535
   23544:	e13ffb17 	ldw	r4,-20(fp)
   23548:	100b883a 	mov	r5,r2
   2354c:	0021b600 	call	21b60 <mem_trim>
   23550:	e0bffb15 	stw	r2,-20(fp)
    LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
   23554:	e0bffb17 	ldw	r2,-20(fp)
   23558:	e0fffc0b 	ldhu	r3,-16(fp)
   2355c:	10c0028d 	sth	r3,10(r2)
  q->tot_len = q->len;
   23560:	e0bffb17 	ldw	r2,-20(fp)
   23564:	10c0028b 	ldhu	r3,10(r2)
   23568:	e0bffb17 	ldw	r2,-20(fp)
   2356c:	10c0020d 	sth	r3,8(r2)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
   23570:	e0bffb17 	ldw	r2,-20(fp)
   23574:	10800017 	ldw	r2,0(r2)
   23578:	10000426 	beq	r2,zero,2358c <pbuf_realloc+0x13c>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
   2357c:	e0bffb17 	ldw	r2,-20(fp)
   23580:	10800017 	ldw	r2,0(r2)
   23584:	1009883a 	mov	r4,r2
   23588:	00237600 	call	23760 <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
   2358c:	e0bffb17 	ldw	r2,-20(fp)
   23590:	10000015 	stw	zero,0(r2)
   23594:	00000106 	br	2359c <pbuf_realloc+0x14c>
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
    /* enlarging not yet supported */
    return;
   23598:	0001883a 	nop
    pbuf_free(q->next);
  }
  /* q is last packet in chain */
  q->next = NULL;

}
   2359c:	e037883a 	mov	sp,fp
   235a0:	dfc00117 	ldw	ra,4(sp)
   235a4:	df000017 	ldw	fp,0(sp)
   235a8:	dec00204 	addi	sp,sp,8
   235ac:	f800283a 	ret

000235b0 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
   235b0:	defffa04 	addi	sp,sp,-24
   235b4:	dfc00515 	stw	ra,20(sp)
   235b8:	df000415 	stw	fp,16(sp)
   235bc:	df000404 	addi	fp,sp,16
   235c0:	e13ffe15 	stw	r4,-8(fp)
   235c4:	2805883a 	mov	r2,r5
   235c8:	e0bfff0d 	sth	r2,-4(fp)
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL)) {
   235cc:	e0bfff0f 	ldh	r2,-4(fp)
   235d0:	10000226 	beq	r2,zero,235dc <pbuf_header+0x2c>
   235d4:	e0bffe17 	ldw	r2,-8(fp)
   235d8:	1000021e 	bne	r2,zero,235e4 <pbuf_header+0x34>
    return 0;
   235dc:	0005883a 	mov	r2,zero
   235e0:	00005a06 	br	2374c <pbuf_header+0x19c>
  }
 
  if (header_size_increment < 0){
   235e4:	e0bfff0f 	ldh	r2,-4(fp)
   235e8:	1000110e 	bge	r2,zero,23630 <pbuf_header+0x80>
    increment_magnitude = -header_size_increment;
   235ec:	e0bfff0b 	ldhu	r2,-4(fp)
   235f0:	0085c83a 	sub	r2,zero,r2
   235f4:	e0bffc0d 	sth	r2,-16(fp)
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
   235f8:	e0bffe17 	ldw	r2,-8(fp)
   235fc:	1080028b 	ldhu	r2,10(r2)
   23600:	10ffffcc 	andi	r3,r2,65535
   23604:	e0bffc0b 	ldhu	r2,-16(fp)
   23608:	18800b2e 	bgeu	r3,r2,23638 <pbuf_header+0x88>
   2360c:	01000134 	movhi	r4,4
   23610:	21048d04 	addi	r4,r4,4660
   23614:	01400134 	movhi	r5,4
   23618:	29449904 	addi	r5,r5,4708
   2361c:	01808344 	movi	r6,525
   23620:	01c00134 	movhi	r7,4
   23624:	39c4a104 	addi	r7,r7,4740
   23628:	00044740 	call	4474 <printf>
   2362c:	003fff06 	br	2362c <pbuf_header+0x7c>
  } else {
    increment_magnitude = header_size_increment;
   23630:	e0bfff0b 	ldhu	r2,-4(fp)
   23634:	e0bffc0d 	sth	r2,-16(fp)
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
   23638:	e0bffe17 	ldw	r2,-8(fp)
   2363c:	10800303 	ldbu	r2,12(r2)
   23640:	10803fcc 	andi	r2,r2,255
   23644:	e0bffc8d 	sth	r2,-14(fp)
  /* remember current payload pointer */
  payload = p->payload;
   23648:	e0bffe17 	ldw	r2,-8(fp)
   2364c:	10800117 	ldw	r2,4(r2)
   23650:	e0bffd15 	stw	r2,-12(fp)

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
   23654:	e0bffc8b 	ldhu	r2,-14(fp)
   23658:	10000326 	beq	r2,zero,23668 <pbuf_header+0xb8>
   2365c:	e0bffc8b 	ldhu	r2,-14(fp)
   23660:	108000d8 	cmpnei	r2,r2,3
   23664:	1000111e 	bne	r2,zero,236ac <pbuf_header+0xfc>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
   23668:	e0bffe17 	ldw	r2,-8(fp)
   2366c:	10c00117 	ldw	r3,4(r2)
   23670:	e0bfff0f 	ldh	r2,-4(fp)
   23674:	0085c83a 	sub	r2,zero,r2
   23678:	1887883a 	add	r3,r3,r2
   2367c:	e0bffe17 	ldw	r2,-8(fp)
   23680:	10c00115 	stw	r3,4(r2)
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
   23684:	e0bffe17 	ldw	r2,-8(fp)
   23688:	10c00117 	ldw	r3,4(r2)
   2368c:	e0bffe17 	ldw	r2,-8(fp)
   23690:	10800404 	addi	r2,r2,16
   23694:	18801e2e 	bgeu	r3,r2,23710 <pbuf_header+0x160>
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload, (void *)(p + 1)));
      /* restore old payload pointer */
      p->payload = payload;
   23698:	e0bffe17 	ldw	r2,-8(fp)
   2369c:	e0fffd17 	ldw	r3,-12(fp)
   236a0:	10c00115 	stw	r3,4(r2)
      /* bail out unsuccesfully */
      return 1;
   236a4:	00800044 	movi	r2,1
   236a8:	00002806 	br	2374c <pbuf_header+0x19c>
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
   236ac:	e0bffc8b 	ldhu	r2,-14(fp)
   236b0:	108000a0 	cmpeqi	r2,r2,2
   236b4:	1000031e 	bne	r2,zero,236c4 <pbuf_header+0x114>
   236b8:	e0bffc8b 	ldhu	r2,-14(fp)
   236bc:	10800058 	cmpnei	r2,r2,1
   236c0:	1000111e 	bne	r2,zero,23708 <pbuf_header+0x158>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
   236c4:	e0bfff0f 	ldh	r2,-4(fp)
   236c8:	10000d0e 	bge	r2,zero,23700 <pbuf_header+0x150>
   236cc:	e0bffe17 	ldw	r2,-8(fp)
   236d0:	1080028b 	ldhu	r2,10(r2)
   236d4:	10ffffcc 	andi	r3,r2,65535
   236d8:	e0bffc0b 	ldhu	r2,-16(fp)
   236dc:	18800836 	bltu	r3,r2,23700 <pbuf_header+0x150>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
   236e0:	e0bffe17 	ldw	r2,-8(fp)
   236e4:	10c00117 	ldw	r3,4(r2)
   236e8:	e0bfff0f 	ldh	r2,-4(fp)
   236ec:	0085c83a 	sub	r2,zero,r2
   236f0:	1887883a 	add	r3,r3,r2
   236f4:	e0bffe17 	ldw	r2,-8(fp)
   236f8:	10c00115 	stw	r3,4(r2)
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
   236fc:	00000406 	br	23710 <pbuf_header+0x160>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
   23700:	00800044 	movi	r2,1
   23704:	00001106 	br	2374c <pbuf_header+0x19c>
    }
  } else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
   23708:	00800044 	movi	r2,1
   2370c:	00000f06 	br	2374c <pbuf_header+0x19c>
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
   23710:	e0bffe17 	ldw	r2,-8(fp)
   23714:	10c0028b 	ldhu	r3,10(r2)
   23718:	e0bfff0b 	ldhu	r2,-4(fp)
   2371c:	1885883a 	add	r2,r3,r2
   23720:	1007883a 	mov	r3,r2
   23724:	e0bffe17 	ldw	r2,-8(fp)
   23728:	10c0028d 	sth	r3,10(r2)
  p->tot_len += header_size_increment;
   2372c:	e0bffe17 	ldw	r2,-8(fp)
   23730:	10c0020b 	ldhu	r3,8(r2)
   23734:	e0bfff0b 	ldhu	r2,-4(fp)
   23738:	1885883a 	add	r2,r3,r2
   2373c:	1007883a 	mov	r3,r2
   23740:	e0bffe17 	ldw	r2,-8(fp)
   23744:	10c0020d 	sth	r3,8(r2)

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
   23748:	0005883a 	mov	r2,zero
}
   2374c:	e037883a 	mov	sp,fp
   23750:	dfc00117 	ldw	ra,4(sp)
   23754:	df000017 	ldw	fp,0(sp)
   23758:	dec00204 	addi	sp,sp,8
   2375c:	f800283a 	ret

00023760 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
   23760:	defff904 	addi	sp,sp,-28
   23764:	dfc00615 	stw	ra,24(sp)
   23768:	df000515 	stw	fp,20(sp)
   2376c:	df000504 	addi	fp,sp,20
   23770:	e13fff15 	stw	r4,-4(fp)
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
   23774:	e0bfff17 	ldw	r2,-4(fp)
   23778:	1000021e 	bne	r2,zero,23784 <pbuf_free+0x24>
    LWIP_ASSERT("p != NULL", p != NULL);
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
      ("pbuf_free(p == NULL) was called.\n"));
    return 0;
   2377c:	0005883a 	mov	r2,zero
   23780:	00004306 	br	23890 <pbuf_free+0x130>

  LWIP_ASSERT("pbuf_free: sane type",
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
   23784:	e03ffb05 	stb	zero,-20(fp)
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
   23788:	00003e06 	br	23884 <pbuf_free+0x124>
    u16_t ref;
    SYS_ARCH_DECL_PROTECT(old_level);
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
   2378c:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   23790:	10000126 	beq	r2,zero,23798 <pbuf_free+0x38>
   23794:	00110d00 	call	110d0 <vTaskEnterCritical>
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
   23798:	e0bfff17 	ldw	r2,-4(fp)
   2379c:	1080038b 	ldhu	r2,14(r2)
   237a0:	10bfffc4 	addi	r2,r2,-1
   237a4:	1007883a 	mov	r3,r2
   237a8:	e0bfff17 	ldw	r2,-4(fp)
   237ac:	10c0038d 	sth	r3,14(r2)
   237b0:	e0bfff17 	ldw	r2,-4(fp)
   237b4:	1080038b 	ldhu	r2,14(r2)
   237b8:	e0bffb8d 	sth	r2,-18(fp)
    SYS_ARCH_UNPROTECT(old_level);
   237bc:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   237c0:	10000126 	beq	r2,zero,237c8 <pbuf_free+0x68>
   237c4:	00111100 	call	11110 <vTaskExitCritical>
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
   237c8:	e0bffb8b 	ldhu	r2,-18(fp)
   237cc:	10002c1e 	bne	r2,zero,23880 <pbuf_free+0x120>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
   237d0:	e0bfff17 	ldw	r2,-4(fp)
   237d4:	10800017 	ldw	r2,0(r2)
   237d8:	e0bffc15 	stw	r2,-16(fp)
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
   237dc:	e0bfff17 	ldw	r2,-4(fp)
   237e0:	10800303 	ldbu	r2,12(r2)
   237e4:	10803fcc 	andi	r2,r2,255
   237e8:	e0bffd0d 	sth	r2,-12(fp)
#if LWIP_SUPPORT_CUSTOM_PBUF
      /* is this a custom pbuf? */
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
   237ec:	e0bfff17 	ldw	r2,-4(fp)
   237f0:	10800343 	ldbu	r2,13(r2)
   237f4:	10803fcc 	andi	r2,r2,255
   237f8:	1080008c 	andi	r2,r2,2
   237fc:	10000726 	beq	r2,zero,2381c <pbuf_free+0xbc>
        struct pbuf_custom *pc = (struct pbuf_custom*)p;
   23800:	e0bfff17 	ldw	r2,-4(fp)
   23804:	e0bffe15 	stw	r2,-8(fp)
        LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
        pc->custom_free_function(p);
   23808:	e0bffe17 	ldw	r2,-8(fp)
   2380c:	10800417 	ldw	r2,16(r2)
   23810:	e13fff17 	ldw	r4,-4(fp)
   23814:	103ee83a 	callr	r2
   23818:	00001306 	br	23868 <pbuf_free+0x108>
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
   2381c:	e0bffd0b 	ldhu	r2,-12(fp)
   23820:	108000d8 	cmpnei	r2,r2,3
   23824:	1000041e 	bne	r2,zero,23838 <pbuf_free+0xd8>
          memp_free(MEMP_PBUF_POOL, p);
   23828:	01000384 	movi	r4,14
   2382c:	e17fff17 	ldw	r5,-4(fp)
   23830:	00225900 	call	22590 <memp_free>
   23834:	00000c06 	br	23868 <pbuf_free+0x108>
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
   23838:	e0bffd0b 	ldhu	r2,-12(fp)
   2383c:	10800060 	cmpeqi	r2,r2,1
   23840:	1000031e 	bne	r2,zero,23850 <pbuf_free+0xf0>
   23844:	e0bffd0b 	ldhu	r2,-12(fp)
   23848:	10800098 	cmpnei	r2,r2,2
   2384c:	1000041e 	bne	r2,zero,23860 <pbuf_free+0x100>
          memp_free(MEMP_PBUF, p);
   23850:	01000344 	movi	r4,13
   23854:	e17fff17 	ldw	r5,-4(fp)
   23858:	00225900 	call	22590 <memp_free>
   2385c:	00000206 	br	23868 <pbuf_free+0x108>
        /* type == PBUF_RAM */
        } else {
          mem_free(p);
   23860:	e13fff17 	ldw	r4,-4(fp)
   23864:	0021a540 	call	21a54 <mem_free>
        }
      }
      count++;
   23868:	e0bffb03 	ldbu	r2,-20(fp)
   2386c:	10800044 	addi	r2,r2,1
   23870:	e0bffb05 	stb	r2,-20(fp)
      /* proceed to next pbuf */
      p = q;
   23874:	e0bffc17 	ldw	r2,-16(fp)
   23878:	e0bfff15 	stw	r2,-4(fp)
   2387c:	00000106 	br	23884 <pbuf_free+0x124>
    /* p->ref > 0, this pbuf is still referenced to */
    /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
      /* stop walking through the chain */
      p = NULL;
   23880:	e03fff15 	stw	zero,-4(fp)
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
   23884:	e0bfff17 	ldw	r2,-4(fp)
   23888:	103fc01e 	bne	r2,zero,2378c <pbuf_free+0x2c>
      p = NULL;
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
   2388c:	e0bffb03 	ldbu	r2,-20(fp)
}
   23890:	e037883a 	mov	sp,fp
   23894:	dfc00117 	ldw	ra,4(sp)
   23898:	df000017 	ldw	fp,0(sp)
   2389c:	dec00204 	addi	sp,sp,8
   238a0:	f800283a 	ret

000238a4 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
   238a4:	defffd04 	addi	sp,sp,-12
   238a8:	df000215 	stw	fp,8(sp)
   238ac:	df000204 	addi	fp,sp,8
   238b0:	e13fff15 	stw	r4,-4(fp)
  u8_t len;

  len = 0;
   238b4:	e03ffe05 	stb	zero,-8(fp)
  while (p != NULL) {
   238b8:	00000606 	br	238d4 <pbuf_clen+0x30>
    ++len;
   238bc:	e0bffe03 	ldbu	r2,-8(fp)
   238c0:	10800044 	addi	r2,r2,1
   238c4:	e0bffe05 	stb	r2,-8(fp)
    p = p->next;
   238c8:	e0bfff17 	ldw	r2,-4(fp)
   238cc:	10800017 	ldw	r2,0(r2)
   238d0:	e0bfff15 	stw	r2,-4(fp)
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
   238d4:	e0bfff17 	ldw	r2,-4(fp)
   238d8:	103ff81e 	bne	r2,zero,238bc <pbuf_clen+0x18>
    ++len;
    p = p->next;
  }
  return len;
   238dc:	e0bffe03 	ldbu	r2,-8(fp)
}
   238e0:	e037883a 	mov	sp,fp
   238e4:	df000017 	ldw	fp,0(sp)
   238e8:	dec00104 	addi	sp,sp,4
   238ec:	f800283a 	ret

000238f0 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
   238f0:	defffd04 	addi	sp,sp,-12
   238f4:	dfc00215 	stw	ra,8(sp)
   238f8:	df000115 	stw	fp,4(sp)
   238fc:	df000104 	addi	fp,sp,4
   23900:	e13fff15 	stw	r4,-4(fp)
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
   23904:	e0bfff17 	ldw	r2,-4(fp)
   23908:	10000c26 	beq	r2,zero,2393c <pbuf_ref+0x4c>
    SYS_ARCH_PROTECT(old_level);
   2390c:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   23910:	10000126 	beq	r2,zero,23918 <pbuf_ref+0x28>
   23914:	00110d00 	call	110d0 <vTaskEnterCritical>
    ++(p->ref);
   23918:	e0bfff17 	ldw	r2,-4(fp)
   2391c:	1080038b 	ldhu	r2,14(r2)
   23920:	10800044 	addi	r2,r2,1
   23924:	1007883a 	mov	r3,r2
   23928:	e0bfff17 	ldw	r2,-4(fp)
   2392c:	10c0038d 	sth	r3,14(r2)
    SYS_ARCH_UNPROTECT(old_level);
   23930:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   23934:	10000126 	beq	r2,zero,2393c <pbuf_ref+0x4c>
   23938:	00111100 	call	11110 <vTaskExitCritical>
  }
}
   2393c:	e037883a 	mov	sp,fp
   23940:	dfc00117 	ldw	ra,4(sp)
   23944:	df000017 	ldw	fp,0(sp)
   23948:	dec00204 	addi	sp,sp,8
   2394c:	f800283a 	ret

00023950 <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
   23950:	defffb04 	addi	sp,sp,-20
   23954:	dfc00415 	stw	ra,16(sp)
   23958:	df000315 	stw	fp,12(sp)
   2395c:	df000304 	addi	fp,sp,12
   23960:	e13ffe15 	stw	r4,-8(fp)
   23964:	e17fff15 	stw	r5,-4(fp)
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
   23968:	e0bffe17 	ldw	r2,-8(fp)
   2396c:	10000226 	beq	r2,zero,23978 <pbuf_cat+0x28>
   23970:	e0bfff17 	ldw	r2,-4(fp)
   23974:	1000091e 	bne	r2,zero,2399c <pbuf_cat+0x4c>
   23978:	01000134 	movhi	r4,4
   2397c:	21048d04 	addi	r4,r4,4660
   23980:	01400134 	movhi	r5,4
   23984:	2944a704 	addi	r5,r5,4764
   23988:	0180bb84 	movi	r6,750
   2398c:	01c00134 	movhi	r7,4
   23990:	39c4a104 	addi	r7,r7,4740
   23994:	00044740 	call	4474 <printf>
   23998:	003fff06 	br	23998 <pbuf_cat+0x48>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
   2399c:	e0bffe17 	ldw	r2,-8(fp)
   239a0:	e0bffd15 	stw	r2,-12(fp)
   239a4:	00000b06 	br	239d4 <pbuf_cat+0x84>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
   239a8:	e0bffd17 	ldw	r2,-12(fp)
   239ac:	10c0020b 	ldhu	r3,8(r2)
   239b0:	e0bfff17 	ldw	r2,-4(fp)
   239b4:	1080020b 	ldhu	r2,8(r2)
   239b8:	1885883a 	add	r2,r3,r2
   239bc:	1007883a 	mov	r3,r2
   239c0:	e0bffd17 	ldw	r2,-12(fp)
   239c4:	10c0020d 	sth	r3,8(r2)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
   239c8:	e0bffd17 	ldw	r2,-12(fp)
   239cc:	10800017 	ldw	r2,0(r2)
   239d0:	e0bffd15 	stw	r2,-12(fp)
   239d4:	e0bffd17 	ldw	r2,-12(fp)
   239d8:	10800017 	ldw	r2,0(r2)
   239dc:	103ff21e 	bne	r2,zero,239a8 <pbuf_cat+0x58>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
   239e0:	e0bffd17 	ldw	r2,-12(fp)
   239e4:	10c0020b 	ldhu	r3,8(r2)
   239e8:	e0bfff17 	ldw	r2,-4(fp)
   239ec:	1080020b 	ldhu	r2,8(r2)
   239f0:	1885883a 	add	r2,r3,r2
   239f4:	1007883a 	mov	r3,r2
   239f8:	e0bffd17 	ldw	r2,-12(fp)
   239fc:	10c0020d 	sth	r3,8(r2)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
   23a00:	e0bffd17 	ldw	r2,-12(fp)
   23a04:	e0ffff17 	ldw	r3,-4(fp)
   23a08:	10c00015 	stw	r3,0(r2)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
   23a0c:	e037883a 	mov	sp,fp
   23a10:	dfc00117 	ldw	ra,4(sp)
   23a14:	df000017 	ldw	fp,0(sp)
   23a18:	dec00204 	addi	sp,sp,8
   23a1c:	f800283a 	ret

00023a20 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
   23a20:	defffc04 	addi	sp,sp,-16
   23a24:	dfc00315 	stw	ra,12(sp)
   23a28:	df000215 	stw	fp,8(sp)
   23a2c:	df000204 	addi	fp,sp,8
   23a30:	e13ffe15 	stw	r4,-8(fp)
   23a34:	e17fff15 	stw	r5,-4(fp)
  pbuf_cat(h, t);
   23a38:	e13ffe17 	ldw	r4,-8(fp)
   23a3c:	e17fff17 	ldw	r5,-4(fp)
   23a40:	00239500 	call	23950 <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
   23a44:	e13fff17 	ldw	r4,-4(fp)
   23a48:	00238f00 	call	238f0 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
   23a4c:	e037883a 	mov	sp,fp
   23a50:	dfc00117 	ldw	ra,4(sp)
   23a54:	df000017 	ldw	fp,0(sp)
   23a58:	dec00204 	addi	sp,sp,8
   23a5c:	f800283a 	ret

00023a60 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
   23a60:	defffb04 	addi	sp,sp,-20
   23a64:	dfc00415 	stw	ra,16(sp)
   23a68:	df000315 	stw	fp,12(sp)
   23a6c:	df000304 	addi	fp,sp,12
   23a70:	e13fff15 	stw	r4,-4(fp)
  struct pbuf *q;
  u8_t tail_gone = 1;
   23a74:	00800044 	movi	r2,1
   23a78:	e0bffd05 	stb	r2,-12(fp)
  /* tail */
  q = p->next;
   23a7c:	e0bfff17 	ldw	r2,-4(fp)
   23a80:	10800017 	ldw	r2,0(r2)
   23a84:	e0bffe15 	stw	r2,-8(fp)
  /* pbuf has successor in chain? */
  if (q != NULL) {
   23a88:	e0bffe17 	ldw	r2,-8(fp)
   23a8c:	10001126 	beq	r2,zero,23ad4 <pbuf_dechain+0x74>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
   23a90:	e0bfff17 	ldw	r2,-4(fp)
   23a94:	10c0020b 	ldhu	r3,8(r2)
   23a98:	e0bfff17 	ldw	r2,-4(fp)
   23a9c:	1080028b 	ldhu	r2,10(r2)
   23aa0:	1885c83a 	sub	r2,r3,r2
   23aa4:	1007883a 	mov	r3,r2
   23aa8:	e0bffe17 	ldw	r2,-8(fp)
   23aac:	10c0020d 	sth	r3,8(r2)
    /* decouple pbuf from remainder */
    p->next = NULL;
   23ab0:	e0bfff17 	ldw	r2,-4(fp)
   23ab4:	10000015 	stw	zero,0(r2)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
   23ab8:	e0bfff17 	ldw	r2,-4(fp)
   23abc:	10c0028b 	ldhu	r3,10(r2)
   23ac0:	e0bfff17 	ldw	r2,-4(fp)
   23ac4:	10c0020d 	sth	r3,8(r2)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
   23ac8:	e13ffe17 	ldw	r4,-8(fp)
   23acc:	00237600 	call	23760 <pbuf_free>
   23ad0:	e0bffd05 	stb	r2,-12(fp)
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  return ((tail_gone > 0) ? NULL : q);
   23ad4:	e0bffd03 	ldbu	r2,-12(fp)
   23ad8:	1000021e 	bne	r2,zero,23ae4 <pbuf_dechain+0x84>
   23adc:	e0bffe17 	ldw	r2,-8(fp)
   23ae0:	00000106 	br	23ae8 <pbuf_dechain+0x88>
   23ae4:	0005883a 	mov	r2,zero
}
   23ae8:	e037883a 	mov	sp,fp
   23aec:	dfc00117 	ldw	ra,4(sp)
   23af0:	df000017 	ldw	fp,0(sp)
   23af4:	dec00204 	addi	sp,sp,8
   23af8:	f800283a 	ret

00023afc <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
   23afc:	defffa04 	addi	sp,sp,-24
   23b00:	dfc00515 	stw	ra,20(sp)
   23b04:	df000415 	stw	fp,16(sp)
   23b08:	df000404 	addi	fp,sp,16
   23b0c:	e13ffe15 	stw	r4,-8(fp)
   23b10:	e17fff15 	stw	r5,-4(fp)
  u16_t offset_to=0, offset_from=0, len;
   23b14:	e03ffc0d 	sth	zero,-16(fp)
   23b18:	e03ffc8d 	sth	zero,-14(fp)

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
   23b1c:	e0bffe17 	ldw	r2,-8(fp)
   23b20:	10000926 	beq	r2,zero,23b48 <pbuf_copy+0x4c>
   23b24:	e0bfff17 	ldw	r2,-4(fp)
   23b28:	10000726 	beq	r2,zero,23b48 <pbuf_copy+0x4c>
   23b2c:	e0bffe17 	ldw	r2,-8(fp)
   23b30:	10c0020b 	ldhu	r3,8(r2)
   23b34:	e0bfff17 	ldw	r2,-4(fp)
   23b38:	1080020b 	ldhu	r2,8(r2)
   23b3c:	18ffffcc 	andi	r3,r3,65535
   23b40:	10bfffcc 	andi	r2,r2,65535
   23b44:	1880092e 	bgeu	r3,r2,23b6c <pbuf_copy+0x70>
   23b48:	01000134 	movhi	r4,4
   23b4c:	21048d04 	addi	r4,r4,4660
   23b50:	01400134 	movhi	r5,4
   23b54:	2944b504 	addi	r5,r5,4820
   23b58:	0180d744 	movi	r6,861
   23b5c:	01c00134 	movhi	r7,4
   23b60:	39c4a104 	addi	r7,r7,4740
   23b64:	00044740 	call	4474 <printf>
   23b68:	003fff06 	br	23b68 <pbuf_copy+0x6c>

  /* iterate through pbuf chain */
  do
  {
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
   23b6c:	e0bffe17 	ldw	r2,-8(fp)
   23b70:	1080028b 	ldhu	r2,10(r2)
   23b74:	10ffffcc 	andi	r3,r2,65535
   23b78:	e0bffc0b 	ldhu	r2,-16(fp)
   23b7c:	1887c83a 	sub	r3,r3,r2
   23b80:	e0bfff17 	ldw	r2,-4(fp)
   23b84:	1080028b 	ldhu	r2,10(r2)
   23b88:	113fffcc 	andi	r4,r2,65535
   23b8c:	e0bffc8b 	ldhu	r2,-14(fp)
   23b90:	2085c83a 	sub	r2,r4,r2
   23b94:	18800616 	blt	r3,r2,23bb0 <pbuf_copy+0xb4>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
   23b98:	e0bfff17 	ldw	r2,-4(fp)
   23b9c:	10c0028b 	ldhu	r3,10(r2)
   23ba0:	e0bffc8b 	ldhu	r2,-14(fp)
   23ba4:	1885c83a 	sub	r2,r3,r2
   23ba8:	e0bffd0d 	sth	r2,-12(fp)
   23bac:	00000506 	br	23bc4 <pbuf_copy+0xc8>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
   23bb0:	e0bffe17 	ldw	r2,-8(fp)
   23bb4:	10c0028b 	ldhu	r3,10(r2)
   23bb8:	e0bffc0b 	ldhu	r2,-16(fp)
   23bbc:	1885c83a 	sub	r2,r3,r2
   23bc0:	e0bffd0d 	sth	r2,-12(fp)
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
   23bc4:	e0bffe17 	ldw	r2,-8(fp)
   23bc8:	10c00117 	ldw	r3,4(r2)
   23bcc:	e0bffc0b 	ldhu	r2,-16(fp)
   23bd0:	1889883a 	add	r4,r3,r2
   23bd4:	e0bfff17 	ldw	r2,-4(fp)
   23bd8:	10c00117 	ldw	r3,4(r2)
   23bdc:	e0bffc8b 	ldhu	r2,-14(fp)
   23be0:	1887883a 	add	r3,r3,r2
   23be4:	e0bffd0b 	ldhu	r2,-12(fp)
   23be8:	180b883a 	mov	r5,r3
   23bec:	100d883a 	mov	r6,r2
   23bf0:	00041f00 	call	41f0 <memcpy>
    offset_to += len;
   23bf4:	e0fffc0b 	ldhu	r3,-16(fp)
   23bf8:	e0bffd0b 	ldhu	r2,-12(fp)
   23bfc:	1885883a 	add	r2,r3,r2
   23c00:	e0bffc0d 	sth	r2,-16(fp)
    offset_from += len;
   23c04:	e0fffc8b 	ldhu	r3,-14(fp)
   23c08:	e0bffd0b 	ldhu	r2,-12(fp)
   23c0c:	1885883a 	add	r2,r3,r2
   23c10:	e0bffc8d 	sth	r2,-14(fp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
   23c14:	e0bfff17 	ldw	r2,-4(fp)
   23c18:	1080028b 	ldhu	r2,10(r2)
   23c1c:	10bfffcc 	andi	r2,r2,65535
   23c20:	e0fffc8b 	ldhu	r3,-14(fp)
   23c24:	18800436 	bltu	r3,r2,23c38 <pbuf_copy+0x13c>
      /* on to next p_from (if any) */
      offset_from = 0;
   23c28:	e03ffc8d 	sth	zero,-14(fp)
      p_from = p_from->next;
   23c2c:	e0bfff17 	ldw	r2,-4(fp)
   23c30:	10800017 	ldw	r2,0(r2)
   23c34:	e0bfff15 	stw	r2,-4(fp)
    }
    if (offset_to == p_to->len) {
   23c38:	e0bffe17 	ldw	r2,-8(fp)
   23c3c:	1080028b 	ldhu	r2,10(r2)
   23c40:	10ffffcc 	andi	r3,r2,65535
   23c44:	e0bffc0b 	ldhu	r2,-16(fp)
   23c48:	1880111e 	bne	r3,r2,23c90 <pbuf_copy+0x194>
      /* on to next p_to (if any) */
      offset_to = 0;
   23c4c:	e03ffc0d 	sth	zero,-16(fp)
      p_to = p_to->next;
   23c50:	e0bffe17 	ldw	r2,-8(fp)
   23c54:	10800017 	ldw	r2,0(r2)
   23c58:	e0bffe15 	stw	r2,-8(fp)
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
   23c5c:	e0bffe17 	ldw	r2,-8(fp)
   23c60:	10000b1e 	bne	r2,zero,23c90 <pbuf_copy+0x194>
   23c64:	e0bfff17 	ldw	r2,-4(fp)
   23c68:	10000926 	beq	r2,zero,23c90 <pbuf_copy+0x194>
   23c6c:	01000134 	movhi	r4,4
   23c70:	21048d04 	addi	r4,r4,4660
   23c74:	01400134 	movhi	r5,4
   23c78:	2944c104 	addi	r5,r5,4868
   23c7c:	0180de04 	movi	r6,888
   23c80:	01c00134 	movhi	r7,4
   23c84:	39c4a104 	addi	r7,r7,4740
   23c88:	00044740 	call	4474 <printf>
   23c8c:	003fff06 	br	23c8c <pbuf_copy+0x190>
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
   23c90:	e0bfff17 	ldw	r2,-4(fp)
   23c94:	10001326 	beq	r2,zero,23ce4 <pbuf_copy+0x1e8>
   23c98:	e0bfff17 	ldw	r2,-4(fp)
   23c9c:	10c0028b 	ldhu	r3,10(r2)
   23ca0:	e0bfff17 	ldw	r2,-4(fp)
   23ca4:	1080020b 	ldhu	r2,8(r2)
   23ca8:	18ffffcc 	andi	r3,r3,65535
   23cac:	10bfffcc 	andi	r2,r2,65535
   23cb0:	18800c1e 	bne	r3,r2,23ce4 <pbuf_copy+0x1e8>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
   23cb4:	e0bfff17 	ldw	r2,-4(fp)
   23cb8:	10800017 	ldw	r2,0(r2)
   23cbc:	10000926 	beq	r2,zero,23ce4 <pbuf_copy+0x1e8>
   23cc0:	01000134 	movhi	r4,4
   23cc4:	21048d04 	addi	r4,r4,4660
   23cc8:	01400134 	movhi	r5,4
   23ccc:	2944c504 	addi	r5,r5,4884
   23cd0:	0180df84 	movi	r6,894
   23cd4:	01c00134 	movhi	r7,4
   23cd8:	39c4a104 	addi	r7,r7,4740
   23cdc:	00044740 	call	4474 <printf>
   23ce0:	003fff06 	br	23ce0 <pbuf_copy+0x1e4>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
   23ce4:	e0bffe17 	ldw	r2,-8(fp)
   23ce8:	10001326 	beq	r2,zero,23d38 <pbuf_copy+0x23c>
   23cec:	e0bffe17 	ldw	r2,-8(fp)
   23cf0:	10c0028b 	ldhu	r3,10(r2)
   23cf4:	e0bffe17 	ldw	r2,-8(fp)
   23cf8:	1080020b 	ldhu	r2,8(r2)
   23cfc:	18ffffcc 	andi	r3,r3,65535
   23d00:	10bfffcc 	andi	r2,r2,65535
   23d04:	18800c1e 	bne	r3,r2,23d38 <pbuf_copy+0x23c>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
   23d08:	e0bffe17 	ldw	r2,-8(fp)
   23d0c:	10800017 	ldw	r2,0(r2)
   23d10:	10000926 	beq	r2,zero,23d38 <pbuf_copy+0x23c>
   23d14:	01000134 	movhi	r4,4
   23d18:	21048d04 	addi	r4,r4,4660
   23d1c:	01400134 	movhi	r5,4
   23d20:	2944c504 	addi	r5,r5,4884
   23d24:	0180e0c4 	movi	r6,899
   23d28:	01c00134 	movhi	r7,4
   23d2c:	39c4a104 	addi	r7,r7,4740
   23d30:	00044740 	call	4474 <printf>
   23d34:	003fff06 	br	23d34 <pbuf_copy+0x238>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
   23d38:	e0bfff17 	ldw	r2,-4(fp)
   23d3c:	103f8b1e 	bne	r2,zero,23b6c <pbuf_copy+0x70>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
   23d40:	0005883a 	mov	r2,zero
}
   23d44:	e037883a 	mov	sp,fp
   23d48:	dfc00117 	ldw	ra,4(sp)
   23d4c:	df000017 	ldw	fp,0(sp)
   23d50:	dec00204 	addi	sp,sp,8
   23d54:	f800283a 	ret

00023d58 <pbuf_copy_partial>:
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
   23d58:	defff704 	addi	sp,sp,-36
   23d5c:	dfc00815 	stw	ra,32(sp)
   23d60:	df000715 	stw	fp,28(sp)
   23d64:	df000704 	addi	fp,sp,28
   23d68:	e13ffc15 	stw	r4,-16(fp)
   23d6c:	e17ffd15 	stw	r5,-12(fp)
   23d70:	3007883a 	mov	r3,r6
   23d74:	3805883a 	mov	r2,r7
   23d78:	e0fffe0d 	sth	r3,-8(fp)
   23d7c:	e0bfff0d 	sth	r2,-4(fp)
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;
   23d80:	e03ffb0d 	sth	zero,-20(fp)

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
   23d84:	e0bffc17 	ldw	r2,-16(fp)
   23d88:	1000091e 	bne	r2,zero,23db0 <pbuf_copy_partial+0x58>
   23d8c:	01000134 	movhi	r4,4
   23d90:	21048d04 	addi	r4,r4,4660
   23d94:	01400134 	movhi	r5,4
   23d98:	2944d004 	addi	r5,r5,4928
   23d9c:	0180e744 	movi	r6,925
   23da0:	01c00134 	movhi	r7,4
   23da4:	39c4a104 	addi	r7,r7,4740
   23da8:	00044740 	call	4474 <printf>
   23dac:	003fff06 	br	23dac <pbuf_copy_partial+0x54>
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
   23db0:	e0bffd17 	ldw	r2,-12(fp)
   23db4:	1000091e 	bne	r2,zero,23ddc <pbuf_copy_partial+0x84>
   23db8:	01000134 	movhi	r4,4
   23dbc:	21048d04 	addi	r4,r4,4660
   23dc0:	01400134 	movhi	r5,4
   23dc4:	2944d804 	addi	r5,r5,4960
   23dc8:	0180e784 	movi	r6,926
   23dcc:	01c00134 	movhi	r7,4
   23dd0:	39c4a104 	addi	r7,r7,4740
   23dd4:	00044740 	call	4474 <printf>
   23dd8:	003fff06 	br	23dd8 <pbuf_copy_partial+0x80>

  left = 0;
   23ddc:	e03ffa0d 	sth	zero,-24(fp)

  if((buf == NULL) || (dataptr == NULL)) {
   23de0:	e0bffc17 	ldw	r2,-16(fp)
   23de4:	10000226 	beq	r2,zero,23df0 <pbuf_copy_partial+0x98>
   23de8:	e0bffd17 	ldw	r2,-12(fp)
   23dec:	1000021e 	bne	r2,zero,23df8 <pbuf_copy_partial+0xa0>
    return 0;
   23df0:	0005883a 	mov	r2,zero
   23df4:	00003a06 	br	23ee0 <pbuf_copy_partial+0x188>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
   23df8:	e0bffc17 	ldw	r2,-16(fp)
   23dfc:	e0bff915 	stw	r2,-28(fp)
   23e00:	00003206 	br	23ecc <pbuf_copy_partial+0x174>
    if ((offset != 0) && (offset >= p->len)) {
   23e04:	e0bfff0b 	ldhu	r2,-4(fp)
   23e08:	10000b26 	beq	r2,zero,23e38 <pbuf_copy_partial+0xe0>
   23e0c:	e0bff917 	ldw	r2,-28(fp)
   23e10:	1080028b 	ldhu	r2,10(r2)
   23e14:	10bfffcc 	andi	r2,r2,65535
   23e18:	e0ffff0b 	ldhu	r3,-4(fp)
   23e1c:	18800636 	bltu	r3,r2,23e38 <pbuf_copy_partial+0xe0>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
   23e20:	e0bff917 	ldw	r2,-28(fp)
   23e24:	1080028b 	ldhu	r2,10(r2)
   23e28:	e0ffff0b 	ldhu	r3,-4(fp)
   23e2c:	1885c83a 	sub	r2,r3,r2
   23e30:	e0bfff0d 	sth	r2,-4(fp)
   23e34:	00002206 	br	23ec0 <pbuf_copy_partial+0x168>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
   23e38:	e0bff917 	ldw	r2,-28(fp)
   23e3c:	10c0028b 	ldhu	r3,10(r2)
   23e40:	e0bfff0b 	ldhu	r2,-4(fp)
   23e44:	1885c83a 	sub	r2,r3,r2
   23e48:	e0bffa8d 	sth	r2,-22(fp)
      if (buf_copy_len > len)
   23e4c:	e0bffa8b 	ldhu	r2,-22(fp)
   23e50:	e0fffe0b 	ldhu	r3,-8(fp)
   23e54:	1880022e 	bgeu	r3,r2,23e60 <pbuf_copy_partial+0x108>
          buf_copy_len = len;
   23e58:	e0bffe0b 	ldhu	r2,-8(fp)
   23e5c:	e0bffa8d 	sth	r2,-22(fp)
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
   23e60:	e0bffa0b 	ldhu	r2,-24(fp)
   23e64:	e0fffd17 	ldw	r3,-12(fp)
   23e68:	1889883a 	add	r4,r3,r2
   23e6c:	e0bff917 	ldw	r2,-28(fp)
   23e70:	10c00117 	ldw	r3,4(r2)
   23e74:	e0bfff0b 	ldhu	r2,-4(fp)
   23e78:	1887883a 	add	r3,r3,r2
   23e7c:	e0bffa8b 	ldhu	r2,-22(fp)
   23e80:	180b883a 	mov	r5,r3
   23e84:	100d883a 	mov	r6,r2
   23e88:	00041f00 	call	41f0 <memcpy>
      copied_total += buf_copy_len;
   23e8c:	e0fffb0b 	ldhu	r3,-20(fp)
   23e90:	e0bffa8b 	ldhu	r2,-22(fp)
   23e94:	1885883a 	add	r2,r3,r2
   23e98:	e0bffb0d 	sth	r2,-20(fp)
      left += buf_copy_len;
   23e9c:	e0fffa0b 	ldhu	r3,-24(fp)
   23ea0:	e0bffa8b 	ldhu	r2,-22(fp)
   23ea4:	1885883a 	add	r2,r3,r2
   23ea8:	e0bffa0d 	sth	r2,-24(fp)
      len -= buf_copy_len;
   23eac:	e0fffe0b 	ldhu	r3,-8(fp)
   23eb0:	e0bffa8b 	ldhu	r2,-22(fp)
   23eb4:	1885c83a 	sub	r2,r3,r2
   23eb8:	e0bffe0d 	sth	r2,-8(fp)
      offset = 0;
   23ebc:	e03fff0d 	sth	zero,-4(fp)
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
   23ec0:	e0bff917 	ldw	r2,-28(fp)
   23ec4:	10800017 	ldw	r2,0(r2)
   23ec8:	e0bff915 	stw	r2,-28(fp)
   23ecc:	e0bffe0b 	ldhu	r2,-8(fp)
   23ed0:	10000226 	beq	r2,zero,23edc <pbuf_copy_partial+0x184>
   23ed4:	e0bff917 	ldw	r2,-28(fp)
   23ed8:	103fca1e 	bne	r2,zero,23e04 <pbuf_copy_partial+0xac>
      left += buf_copy_len;
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
   23edc:	e0bffb0b 	ldhu	r2,-20(fp)
}
   23ee0:	e037883a 	mov	sp,fp
   23ee4:	dfc00117 	ldw	ra,4(sp)
   23ee8:	df000017 	ldw	fp,0(sp)
   23eec:	dec00204 	addi	sp,sp,8
   23ef0:	f800283a 	ret

00023ef4 <pbuf_take>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
{
   23ef4:	defff804 	addi	sp,sp,-32
   23ef8:	dfc00715 	stw	ra,28(sp)
   23efc:	df000615 	stw	fp,24(sp)
   23f00:	df000604 	addi	fp,sp,24
   23f04:	e13ffd15 	stw	r4,-12(fp)
   23f08:	e17ffe15 	stw	r5,-8(fp)
   23f0c:	3005883a 	mov	r2,r6
   23f10:	e0bfff0d 	sth	r2,-4(fp)
  struct pbuf *p;
  u16_t buf_copy_len;
  u16_t total_copy_len = len;
   23f14:	e0bfff0b 	ldhu	r2,-4(fp)
   23f18:	e0bffb8d 	sth	r2,-18(fp)
  u16_t copied_total = 0;
   23f1c:	e03ffc0d 	sth	zero,-16(fp)

  LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return 0;);
   23f20:	e0bffd17 	ldw	r2,-12(fp)
   23f24:	1000091e 	bne	r2,zero,23f4c <pbuf_take+0x58>
   23f28:	01000134 	movhi	r4,4
   23f2c:	21048d04 	addi	r4,r4,4660
   23f30:	01400134 	movhi	r5,4
   23f34:	2944e104 	addi	r5,r5,4996
   23f38:	0180f344 	movi	r6,973
   23f3c:	01c00134 	movhi	r7,4
   23f40:	39c4a104 	addi	r7,r7,4740
   23f44:	00044740 	call	4474 <printf>
   23f48:	003fff06 	br	23f48 <pbuf_take+0x54>
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return 0;);
   23f4c:	e0bffe17 	ldw	r2,-8(fp)
   23f50:	1000091e 	bne	r2,zero,23f78 <pbuf_take+0x84>
   23f54:	01000134 	movhi	r4,4
   23f58:	21048d04 	addi	r4,r4,4660
   23f5c:	01400134 	movhi	r5,4
   23f60:	2944e704 	addi	r5,r5,5020
   23f64:	0180f384 	movi	r6,974
   23f68:	01c00134 	movhi	r7,4
   23f6c:	39c4a104 	addi	r7,r7,4740
   23f70:	00044740 	call	4474 <printf>
   23f74:	003fff06 	br	23f74 <pbuf_take+0x80>

  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
   23f78:	e0bffd17 	ldw	r2,-12(fp)
   23f7c:	10000726 	beq	r2,zero,23f9c <pbuf_take+0xa8>
   23f80:	e0bffe17 	ldw	r2,-8(fp)
   23f84:	10000526 	beq	r2,zero,23f9c <pbuf_take+0xa8>
   23f88:	e0bffd17 	ldw	r2,-12(fp)
   23f8c:	1080020b 	ldhu	r2,8(r2)
   23f90:	10ffffcc 	andi	r3,r2,65535
   23f94:	e0bfff0b 	ldhu	r2,-4(fp)
   23f98:	1880022e 	bgeu	r3,r2,23fa4 <pbuf_take+0xb0>
    return ERR_ARG;
   23f9c:	00bffc84 	movi	r2,-14
   23fa0:	00002406 	br	24034 <pbuf_take+0x140>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; total_copy_len != 0; p = p->next) {
   23fa4:	e0bffd17 	ldw	r2,-12(fp)
   23fa8:	e0bffa15 	stw	r2,-24(fp)
   23fac:	00001e06 	br	24028 <pbuf_take+0x134>
    LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
    buf_copy_len = total_copy_len;
   23fb0:	e0bffb8b 	ldhu	r2,-18(fp)
   23fb4:	e0bffb0d 	sth	r2,-20(fp)
    if (buf_copy_len > p->len) {
   23fb8:	e0bffa17 	ldw	r2,-24(fp)
   23fbc:	1080028b 	ldhu	r2,10(r2)
   23fc0:	10ffffcc 	andi	r3,r2,65535
   23fc4:	e0bffb0b 	ldhu	r2,-20(fp)
   23fc8:	1880032e 	bgeu	r3,r2,23fd8 <pbuf_take+0xe4>
      /* this pbuf cannot hold all remaining data */
      buf_copy_len = p->len;
   23fcc:	e0bffa17 	ldw	r2,-24(fp)
   23fd0:	1080028b 	ldhu	r2,10(r2)
   23fd4:	e0bffb0d 	sth	r2,-20(fp)
    }
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
   23fd8:	e0bffa17 	ldw	r2,-24(fp)
   23fdc:	11000117 	ldw	r4,4(r2)
   23fe0:	e0bffc0b 	ldhu	r2,-16(fp)
   23fe4:	e0fffe17 	ldw	r3,-8(fp)
   23fe8:	1887883a 	add	r3,r3,r2
   23fec:	e0bffb0b 	ldhu	r2,-20(fp)
   23ff0:	180b883a 	mov	r5,r3
   23ff4:	100d883a 	mov	r6,r2
   23ff8:	00041f00 	call	41f0 <memcpy>
    total_copy_len -= buf_copy_len;
   23ffc:	e0fffb8b 	ldhu	r3,-18(fp)
   24000:	e0bffb0b 	ldhu	r2,-20(fp)
   24004:	1885c83a 	sub	r2,r3,r2
   24008:	e0bffb8d 	sth	r2,-18(fp)
    copied_total += buf_copy_len;
   2400c:	e0fffc0b 	ldhu	r3,-16(fp)
   24010:	e0bffb0b 	ldhu	r2,-20(fp)
   24014:	1885883a 	add	r2,r3,r2
   24018:	e0bffc0d 	sth	r2,-16(fp)
  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
    return ERR_ARG;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; total_copy_len != 0; p = p->next) {
   2401c:	e0bffa17 	ldw	r2,-24(fp)
   24020:	10800017 	ldw	r2,0(r2)
   24024:	e0bffa15 	stw	r2,-24(fp)
   24028:	e0bffb8b 	ldhu	r2,-18(fp)
   2402c:	103fe01e 	bne	r2,zero,23fb0 <pbuf_take+0xbc>
    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
    total_copy_len -= buf_copy_len;
    copied_total += buf_copy_len;
  }
  LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
  return ERR_OK;
   24030:	0005883a 	mov	r2,zero
}
   24034:	e037883a 	mov	sp,fp
   24038:	dfc00117 	ldw	ra,4(sp)
   2403c:	df000017 	ldw	fp,0(sp)
   24040:	dec00204 	addi	sp,sp,8
   24044:	f800283a 	ret

00024048 <pbuf_coalesce>:
 * @return a new, single pbuf (p->next is NULL)
 *         or the old pbuf if allocation fails
 */
struct pbuf*
pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
{
   24048:	defffa04 	addi	sp,sp,-24
   2404c:	dfc00515 	stw	ra,20(sp)
   24050:	df000415 	stw	fp,16(sp)
   24054:	df000404 	addi	fp,sp,16
   24058:	e13ffe15 	stw	r4,-8(fp)
   2405c:	e17fff15 	stw	r5,-4(fp)
  struct pbuf *q;
  err_t err;
  if (p->next == NULL) {
   24060:	e0bffe17 	ldw	r2,-8(fp)
   24064:	10800017 	ldw	r2,0(r2)
   24068:	1000021e 	bne	r2,zero,24074 <pbuf_coalesce+0x2c>
    return p;
   2406c:	e0bffe17 	ldw	r2,-8(fp)
   24070:	00001306 	br	240c0 <pbuf_coalesce+0x78>
  }
  q = pbuf_alloc(layer, p->tot_len, PBUF_RAM);
   24074:	e0bffe17 	ldw	r2,-8(fp)
   24078:	1080020b 	ldhu	r2,8(r2)
   2407c:	10bfffcc 	andi	r2,r2,65535
   24080:	e13fff17 	ldw	r4,-4(fp)
   24084:	100b883a 	mov	r5,r2
   24088:	000d883a 	mov	r6,zero
   2408c:	0022fa00 	call	22fa0 <pbuf_alloc>
   24090:	e0bffc15 	stw	r2,-16(fp)
  if (q == NULL) {
   24094:	e0bffc17 	ldw	r2,-16(fp)
   24098:	1000021e 	bne	r2,zero,240a4 <pbuf_coalesce+0x5c>
    /* @todo: what do we do now? */
    return p;
   2409c:	e0bffe17 	ldw	r2,-8(fp)
   240a0:	00000706 	br	240c0 <pbuf_coalesce+0x78>
  }
  err = pbuf_copy(q, p);
   240a4:	e13ffc17 	ldw	r4,-16(fp)
   240a8:	e17ffe17 	ldw	r5,-8(fp)
   240ac:	0023afc0 	call	23afc <pbuf_copy>
   240b0:	e0bffd05 	stb	r2,-12(fp)
  LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
  pbuf_free(p);
   240b4:	e13ffe17 	ldw	r4,-8(fp)
   240b8:	00237600 	call	23760 <pbuf_free>
  return q;
   240bc:	e0bffc17 	ldw	r2,-16(fp)
}
   240c0:	e037883a 	mov	sp,fp
   240c4:	dfc00117 	ldw	ra,4(sp)
   240c8:	df000017 	ldw	fp,0(sp)
   240cc:	dec00204 	addi	sp,sp,8
   240d0:	f800283a 	ret

000240d4 <pbuf_fill_chksum>:
 *         within the (first) pbuf (no pbuf queues!)
 */
err_t
pbuf_fill_chksum(struct pbuf *p, u16_t start_offset, const void *dataptr,
                 u16_t len, u16_t *chksum)
{
   240d4:	defff704 	addi	sp,sp,-36
   240d8:	dfc00815 	stw	ra,32(sp)
   240dc:	df000715 	stw	fp,28(sp)
   240e0:	df000704 	addi	fp,sp,28
   240e4:	e13ffc15 	stw	r4,-16(fp)
   240e8:	2807883a 	mov	r3,r5
   240ec:	e1bffe15 	stw	r6,-8(fp)
   240f0:	3805883a 	mov	r2,r7
   240f4:	e0fffd0d 	sth	r3,-12(fp)
   240f8:	e0bfff0d 	sth	r2,-4(fp)
  LWIP_ASSERT("p != NULL", p != NULL);
  LWIP_ASSERT("dataptr != NULL", dataptr != NULL);
  LWIP_ASSERT("chksum != NULL", chksum != NULL);
  LWIP_ASSERT("len != 0", len != 0);

  if ((start_offset >= p->len) || (start_offset + len > p->len)) {
   240fc:	e0bffc17 	ldw	r2,-16(fp)
   24100:	1080028b 	ldhu	r2,10(r2)
   24104:	10bfffcc 	andi	r2,r2,65535
   24108:	e0fffd0b 	ldhu	r3,-12(fp)
   2410c:	1880072e 	bgeu	r3,r2,2412c <pbuf_fill_chksum+0x58>
   24110:	e0fffd0b 	ldhu	r3,-12(fp)
   24114:	e0bfff0b 	ldhu	r2,-4(fp)
   24118:	1885883a 	add	r2,r3,r2
   2411c:	e0fffc17 	ldw	r3,-16(fp)
   24120:	18c0028b 	ldhu	r3,10(r3)
   24124:	18ffffcc 	andi	r3,r3,65535
   24128:	1880020e 	bge	r3,r2,24134 <pbuf_fill_chksum+0x60>
    return ERR_ARG;
   2412c:	00bffc84 	movi	r2,-14
   24130:	00002606 	br	241cc <pbuf_fill_chksum+0xf8>
  }

  dst_ptr = ((char*)p->payload) + start_offset;
   24134:	e0bffc17 	ldw	r2,-16(fp)
   24138:	10c00117 	ldw	r3,4(r2)
   2413c:	e0bffd0b 	ldhu	r2,-12(fp)
   24140:	1885883a 	add	r2,r3,r2
   24144:	e0bffa15 	stw	r2,-24(fp)
  copy_chksum = LWIP_CHKSUM_COPY(dst_ptr, dataptr, len);
   24148:	e0bfff0b 	ldhu	r2,-4(fp)
   2414c:	e13ffa17 	ldw	r4,-24(fp)
   24150:	e17ffe17 	ldw	r5,-8(fp)
   24154:	100d883a 	mov	r6,r2
   24158:	003e8240 	call	3e824 <lwip_chksum_copy>
   2415c:	e0bff90d 	sth	r2,-28(fp)
  if ((start_offset & 1) != 0) {
   24160:	e0bffd0b 	ldhu	r2,-12(fp)
   24164:	1080004c 	andi	r2,r2,1
   24168:	10000726 	beq	r2,zero,24188 <pbuf_fill_chksum+0xb4>
    copy_chksum = SWAP_BYTES_IN_WORD(copy_chksum);
   2416c:	e0bff90b 	ldhu	r2,-28(fp)
   24170:	1004d23a 	srli	r2,r2,8
   24174:	1007883a 	mov	r3,r2
   24178:	e0bff90b 	ldhu	r2,-28(fp)
   2417c:	1004923a 	slli	r2,r2,8
   24180:	1884b03a 	or	r2,r3,r2
   24184:	e0bff90d 	sth	r2,-28(fp)
  }
  acc = *chksum;
   24188:	e0800217 	ldw	r2,8(fp)
   2418c:	1080000b 	ldhu	r2,0(r2)
   24190:	10bfffcc 	andi	r2,r2,65535
   24194:	e0bffb15 	stw	r2,-20(fp)
  acc += copy_chksum;
   24198:	e0bff90b 	ldhu	r2,-28(fp)
   2419c:	e0fffb17 	ldw	r3,-20(fp)
   241a0:	1885883a 	add	r2,r3,r2
   241a4:	e0bffb15 	stw	r2,-20(fp)
  *chksum = FOLD_U32T(acc);
   241a8:	e0bffb17 	ldw	r2,-20(fp)
   241ac:	1004d43a 	srli	r2,r2,16
   241b0:	1007883a 	mov	r3,r2
   241b4:	e0bffb17 	ldw	r2,-20(fp)
   241b8:	1885883a 	add	r2,r3,r2
   241bc:	1007883a 	mov	r3,r2
   241c0:	e0800217 	ldw	r2,8(fp)
   241c4:	10c0000d 	sth	r3,0(r2)
  return ERR_OK;
   241c8:	0005883a 	mov	r2,zero
}
   241cc:	e037883a 	mov	sp,fp
   241d0:	dfc00117 	ldw	ra,4(sp)
   241d4:	df000017 	ldw	fp,0(sp)
   241d8:	dec00204 	addi	sp,sp,8
   241dc:	f800283a 	ret

000241e0 <pbuf_get_at>:
 * @param offset offset into p of the byte to return
 * @return byte at an offset into p OR ZERO IF 'offset' >= p->tot_len
 */
u8_t
pbuf_get_at(struct pbuf* p, u16_t offset)
{
   241e0:	defffb04 	addi	sp,sp,-20
   241e4:	df000415 	stw	fp,16(sp)
   241e8:	df000404 	addi	fp,sp,16
   241ec:	e13ffe15 	stw	r4,-8(fp)
   241f0:	2805883a 	mov	r2,r5
   241f4:	e0bfff0d 	sth	r2,-4(fp)
  u16_t copy_from = offset;
   241f8:	e0bfff0b 	ldhu	r2,-4(fp)
   241fc:	e0bffc0d 	sth	r2,-16(fp)
  struct pbuf* q = p;
   24200:	e0bffe17 	ldw	r2,-8(fp)
   24204:	e0bffd15 	stw	r2,-12(fp)

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= copy_from)) {
   24208:	00000806 	br	2422c <pbuf_get_at+0x4c>
    copy_from -= q->len;
   2420c:	e0bffd17 	ldw	r2,-12(fp)
   24210:	1080028b 	ldhu	r2,10(r2)
   24214:	e0fffc0b 	ldhu	r3,-16(fp)
   24218:	1885c83a 	sub	r2,r3,r2
   2421c:	e0bffc0d 	sth	r2,-16(fp)
    q = q->next;
   24220:	e0bffd17 	ldw	r2,-12(fp)
   24224:	10800017 	ldw	r2,0(r2)
   24228:	e0bffd15 	stw	r2,-12(fp)
{
  u16_t copy_from = offset;
  struct pbuf* q = p;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= copy_from)) {
   2422c:	e0bffd17 	ldw	r2,-12(fp)
   24230:	10000526 	beq	r2,zero,24248 <pbuf_get_at+0x68>
   24234:	e0bffd17 	ldw	r2,-12(fp)
   24238:	1080028b 	ldhu	r2,10(r2)
   2423c:	10bfffcc 	andi	r2,r2,65535
   24240:	e0fffc0b 	ldhu	r3,-16(fp)
   24244:	18bff12e 	bgeu	r3,r2,2420c <pbuf_get_at+0x2c>
    copy_from -= q->len;
    q = q->next;
  }
  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > copy_from)) {
   24248:	e0bffd17 	ldw	r2,-12(fp)
   2424c:	10000b26 	beq	r2,zero,2427c <pbuf_get_at+0x9c>
   24250:	e0bffd17 	ldw	r2,-12(fp)
   24254:	1080028b 	ldhu	r2,10(r2)
   24258:	10bfffcc 	andi	r2,r2,65535
   2425c:	e0fffc0b 	ldhu	r3,-16(fp)
   24260:	1880062e 	bgeu	r3,r2,2427c <pbuf_get_at+0x9c>
    return ((u8_t*)q->payload)[copy_from];
   24264:	e0bffd17 	ldw	r2,-12(fp)
   24268:	10c00117 	ldw	r3,4(r2)
   2426c:	e0bffc0b 	ldhu	r2,-16(fp)
   24270:	1885883a 	add	r2,r3,r2
   24274:	10800003 	ldbu	r2,0(r2)
   24278:	00000106 	br	24280 <pbuf_get_at+0xa0>
  }
  return 0;
   2427c:	0005883a 	mov	r2,zero
}
   24280:	e037883a 	mov	sp,fp
   24284:	df000017 	ldw	fp,0(sp)
   24288:	dec00104 	addi	sp,sp,4
   2428c:	f800283a 	ret

00024290 <pbuf_memcmp>:
 * @return zero if equal, nonzero otherwise
 *         (0xffff if p is too short, diffoffset+1 otherwise)
 */
u16_t
pbuf_memcmp(struct pbuf* p, u16_t offset, const void* s2, u16_t n)
{
   24290:	defff704 	addi	sp,sp,-36
   24294:	dfc00815 	stw	ra,32(sp)
   24298:	df000715 	stw	fp,28(sp)
   2429c:	df000704 	addi	fp,sp,28
   242a0:	e13ffc15 	stw	r4,-16(fp)
   242a4:	2807883a 	mov	r3,r5
   242a8:	e1bffe15 	stw	r6,-8(fp)
   242ac:	3805883a 	mov	r2,r7
   242b0:	e0fffd0d 	sth	r3,-12(fp)
   242b4:	e0bfff0d 	sth	r2,-4(fp)
  u16_t start = offset;
   242b8:	e0bffd0b 	ldhu	r2,-12(fp)
   242bc:	e0bff90d 	sth	r2,-28(fp)
  struct pbuf* q = p;
   242c0:	e0bffc17 	ldw	r2,-16(fp)
   242c4:	e0bffa15 	stw	r2,-24(fp)

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= start)) {
   242c8:	00000806 	br	242ec <pbuf_memcmp+0x5c>
    start -= q->len;
   242cc:	e0bffa17 	ldw	r2,-24(fp)
   242d0:	1080028b 	ldhu	r2,10(r2)
   242d4:	e0fff90b 	ldhu	r3,-28(fp)
   242d8:	1885c83a 	sub	r2,r3,r2
   242dc:	e0bff90d 	sth	r2,-28(fp)
    q = q->next;
   242e0:	e0bffa17 	ldw	r2,-24(fp)
   242e4:	10800017 	ldw	r2,0(r2)
   242e8:	e0bffa15 	stw	r2,-24(fp)
{
  u16_t start = offset;
  struct pbuf* q = p;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= start)) {
   242ec:	e0bffa17 	ldw	r2,-24(fp)
   242f0:	10000526 	beq	r2,zero,24308 <pbuf_memcmp+0x78>
   242f4:	e0bffa17 	ldw	r2,-24(fp)
   242f8:	1080028b 	ldhu	r2,10(r2)
   242fc:	10bfffcc 	andi	r2,r2,65535
   24300:	e0fff90b 	ldhu	r3,-28(fp)
   24304:	18bff12e 	bgeu	r3,r2,242cc <pbuf_memcmp+0x3c>
    start -= q->len;
    q = q->next;
  }
  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > start)) {
   24308:	e0bffa17 	ldw	r2,-24(fp)
   2430c:	10002226 	beq	r2,zero,24398 <pbuf_memcmp+0x108>
   24310:	e0bffa17 	ldw	r2,-24(fp)
   24314:	1080028b 	ldhu	r2,10(r2)
   24318:	10bfffcc 	andi	r2,r2,65535
   2431c:	e0fff90b 	ldhu	r3,-28(fp)
   24320:	18801d2e 	bgeu	r3,r2,24398 <pbuf_memcmp+0x108>
    u16_t i;
    for(i = 0; i < n; i++) {
   24324:	e03ffb0d 	sth	zero,-20(fp)
   24328:	00001606 	br	24384 <pbuf_memcmp+0xf4>
      u8_t a = pbuf_get_at(q, start + i);
   2432c:	e0fff90b 	ldhu	r3,-28(fp)
   24330:	e0bffb0b 	ldhu	r2,-20(fp)
   24334:	1885883a 	add	r2,r3,r2
   24338:	10bfffcc 	andi	r2,r2,65535
   2433c:	e13ffa17 	ldw	r4,-24(fp)
   24340:	100b883a 	mov	r5,r2
   24344:	00241e00 	call	241e0 <pbuf_get_at>
   24348:	e0bffb85 	stb	r2,-18(fp)
      u8_t b = ((u8_t*)s2)[i];
   2434c:	e0bffb0b 	ldhu	r2,-20(fp)
   24350:	e0fffe17 	ldw	r3,-8(fp)
   24354:	1885883a 	add	r2,r3,r2
   24358:	10800003 	ldbu	r2,0(r2)
   2435c:	e0bffbc5 	stb	r2,-17(fp)
      if (a != b) {
   24360:	e0fffb83 	ldbu	r3,-18(fp)
   24364:	e0bffbc3 	ldbu	r2,-17(fp)
   24368:	18800326 	beq	r3,r2,24378 <pbuf_memcmp+0xe8>
        return i+1;
   2436c:	e0bffb0b 	ldhu	r2,-20(fp)
   24370:	10800044 	addi	r2,r2,1
   24374:	00000906 	br	2439c <pbuf_memcmp+0x10c>
    q = q->next;
  }
  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > start)) {
    u16_t i;
    for(i = 0; i < n; i++) {
   24378:	e0bffb0b 	ldhu	r2,-20(fp)
   2437c:	10800044 	addi	r2,r2,1
   24380:	e0bffb0d 	sth	r2,-20(fp)
   24384:	e0fffb0b 	ldhu	r3,-20(fp)
   24388:	e0bfff0b 	ldhu	r2,-4(fp)
   2438c:	18bfe736 	bltu	r3,r2,2432c <pbuf_memcmp+0x9c>
      u8_t b = ((u8_t*)s2)[i];
      if (a != b) {
        return i+1;
      }
    }
    return 0;
   24390:	0005883a 	mov	r2,zero
   24394:	00000106 	br	2439c <pbuf_memcmp+0x10c>
  }
  return 0xffff;
   24398:	00bfffc4 	movi	r2,-1
}
   2439c:	e037883a 	mov	sp,fp
   243a0:	dfc00117 	ldw	ra,4(sp)
   243a4:	df000017 	ldw	fp,0(sp)
   243a8:	dec00204 	addi	sp,sp,8
   243ac:	f800283a 	ret

000243b0 <pbuf_memfind>:
 * @param start_offset offset into p at which to start searching
 * @return 0xFFFF if substr was not found in p or the index where it was found
 */
u16_t
pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
{
   243b0:	defff804 	addi	sp,sp,-32
   243b4:	dfc00715 	stw	ra,28(sp)
   243b8:	df000615 	stw	fp,24(sp)
   243bc:	df000604 	addi	fp,sp,24
   243c0:	e13ffc15 	stw	r4,-16(fp)
   243c4:	e17ffd15 	stw	r5,-12(fp)
   243c8:	3007883a 	mov	r3,r6
   243cc:	3805883a 	mov	r2,r7
   243d0:	e0fffe0d 	sth	r3,-8(fp)
   243d4:	e0bfff0d 	sth	r2,-4(fp)
  u16_t i;
  u16_t max = p->tot_len - mem_len;
   243d8:	e0bffc17 	ldw	r2,-16(fp)
   243dc:	10c0020b 	ldhu	r3,8(r2)
   243e0:	e0bffe0b 	ldhu	r2,-8(fp)
   243e4:	1885c83a 	sub	r2,r3,r2
   243e8:	e0bffa8d 	sth	r2,-22(fp)
  if (p->tot_len >= mem_len + start_offset) {
   243ec:	e0bffc17 	ldw	r2,-16(fp)
   243f0:	1080020b 	ldhu	r2,8(r2)
   243f4:	10ffffcc 	andi	r3,r2,65535
   243f8:	e13ffe0b 	ldhu	r4,-8(fp)
   243fc:	e0bfff0b 	ldhu	r2,-4(fp)
   24400:	2085883a 	add	r2,r4,r2
   24404:	18801616 	blt	r3,r2,24460 <pbuf_memfind+0xb0>
    for(i = start_offset; i <= max; ) {
   24408:	e0bfff0b 	ldhu	r2,-4(fp)
   2440c:	e0bffa0d 	sth	r2,-24(fp)
   24410:	00001006 	br	24454 <pbuf_memfind+0xa4>
      u16_t plus = pbuf_memcmp(p, i, mem, mem_len);
   24414:	e0fffa0b 	ldhu	r3,-24(fp)
   24418:	e0bffe0b 	ldhu	r2,-8(fp)
   2441c:	e13ffc17 	ldw	r4,-16(fp)
   24420:	180b883a 	mov	r5,r3
   24424:	e1bffd17 	ldw	r6,-12(fp)
   24428:	100f883a 	mov	r7,r2
   2442c:	00242900 	call	24290 <pbuf_memcmp>
   24430:	e0bffb0d 	sth	r2,-20(fp)
      if (plus == 0) {
   24434:	e0bffb0b 	ldhu	r2,-20(fp)
   24438:	1000021e 	bne	r2,zero,24444 <pbuf_memfind+0x94>
        return i;
   2443c:	e0bffa0b 	ldhu	r2,-24(fp)
   24440:	00000806 	br	24464 <pbuf_memfind+0xb4>
      } else {
        i += plus;
   24444:	e0fffa0b 	ldhu	r3,-24(fp)
   24448:	e0bffb0b 	ldhu	r2,-20(fp)
   2444c:	1885883a 	add	r2,r3,r2
   24450:	e0bffa0d 	sth	r2,-24(fp)
pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
{
  u16_t i;
  u16_t max = p->tot_len - mem_len;
  if (p->tot_len >= mem_len + start_offset) {
    for(i = start_offset; i <= max; ) {
   24454:	e0bffa0b 	ldhu	r2,-24(fp)
   24458:	e0fffa8b 	ldhu	r3,-22(fp)
   2445c:	18bfed2e 	bgeu	r3,r2,24414 <pbuf_memfind+0x64>
      } else {
        i += plus;
      }
    }
  }
  return 0xFFFF;
   24460:	00bfffc4 	movi	r2,-1
}
   24464:	e037883a 	mov	sp,fp
   24468:	dfc00117 	ldw	ra,4(sp)
   2446c:	df000017 	ldw	fp,0(sp)
   24470:	dec00204 	addi	sp,sp,8
   24474:	f800283a 	ret

00024478 <pbuf_strstr>:
 * @param substr string to search for in p, maximum length is 0xFFFE
 * @return 0xFFFF if substr was not found in p or the index where it was found
 */
u16_t
pbuf_strstr(struct pbuf* p, const char* substr)
{
   24478:	defffb04 	addi	sp,sp,-20
   2447c:	dfc00415 	stw	ra,16(sp)
   24480:	df000315 	stw	fp,12(sp)
   24484:	df000304 	addi	fp,sp,12
   24488:	e13ffe15 	stw	r4,-8(fp)
   2448c:	e17fff15 	stw	r5,-4(fp)
  size_t substr_len;
  if ((substr == NULL) || (substr[0] == 0) || (p->tot_len == 0xFFFF)) {
   24490:	e0bfff17 	ldw	r2,-4(fp)
   24494:	10000b26 	beq	r2,zero,244c4 <pbuf_strstr+0x4c>
   24498:	e0bfff17 	ldw	r2,-4(fp)
   2449c:	10800003 	ldbu	r2,0(r2)
   244a0:	10803fcc 	andi	r2,r2,255
   244a4:	1080201c 	xori	r2,r2,128
   244a8:	10bfe004 	addi	r2,r2,-128
   244ac:	10000526 	beq	r2,zero,244c4 <pbuf_strstr+0x4c>
   244b0:	e0bffe17 	ldw	r2,-8(fp)
   244b4:	1080020b 	ldhu	r2,8(r2)
   244b8:	10ffffcc 	andi	r3,r2,65535
   244bc:	00bfffd4 	movui	r2,65535
   244c0:	1880021e 	bne	r3,r2,244cc <pbuf_strstr+0x54>
    return 0xFFFF;
   244c4:	00bfffc4 	movi	r2,-1
   244c8:	00000f06 	br	24508 <pbuf_strstr+0x90>
  }
  substr_len = strlen(substr);
   244cc:	e13fff17 	ldw	r4,-4(fp)
   244d0:	0004d9c0 	call	4d9c <strlen>
   244d4:	e0bffd15 	stw	r2,-12(fp)
  if (substr_len >= 0xFFFF) {
   244d8:	e0bffd17 	ldw	r2,-12(fp)
   244dc:	10bffff0 	cmpltui	r2,r2,65535
   244e0:	1000021e 	bne	r2,zero,244ec <pbuf_strstr+0x74>
    return 0xFFFF;
   244e4:	00bfffc4 	movi	r2,-1
   244e8:	00000706 	br	24508 <pbuf_strstr+0x90>
  }
  return pbuf_memfind(p, substr, (u16_t)substr_len, 0);
   244ec:	e0bffd17 	ldw	r2,-12(fp)
   244f0:	10bfffcc 	andi	r2,r2,65535
   244f4:	e13ffe17 	ldw	r4,-8(fp)
   244f8:	e17fff17 	ldw	r5,-4(fp)
   244fc:	100d883a 	mov	r6,r2
   24500:	000f883a 	mov	r7,zero
   24504:	00243b00 	call	243b0 <pbuf_memfind>
}
   24508:	e037883a 	mov	sp,fp
   2450c:	dfc00117 	ldw	ra,4(sp)
   24510:	df000017 	ldw	fp,0(sp)
   24514:	dec00204 	addi	sp,sp,8
   24518:	f800283a 	ret

0002451c <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
   2451c:	defff704 	addi	sp,sp,-36
   24520:	dfc00815 	stw	ra,32(sp)
   24524:	df000715 	stw	fp,28(sp)
   24528:	df000704 	addi	fp,sp,28
   2452c:	e13ffe15 	stw	r4,-8(fp)
   24530:	e17fff15 	stw	r5,-4(fp)
  struct raw_pcb *pcb, *prev;
  struct ip_hdr *iphdr;
  s16_t proto;
  u8_t eaten = 0;
   24534:	e03ffb05 	stb	zero,-20(fp)

  LWIP_UNUSED_ARG(inp);

  iphdr = (struct ip_hdr *)p->payload;
   24538:	e0bffe17 	ldw	r2,-8(fp)
   2453c:	10800117 	ldw	r2,4(r2)
   24540:	e0bffc15 	stw	r2,-16(fp)
  proto = IPH_PROTO(iphdr);
   24544:	e0bffc17 	ldw	r2,-16(fp)
   24548:	10800243 	ldbu	r2,9(r2)
   2454c:	10803fcc 	andi	r2,r2,255
   24550:	e0bffd0d 	sth	r2,-12(fp)

  prev = NULL;
   24554:	e03ffa15 	stw	zero,-24(fp)
  pcb = raw_pcbs;
   24558:	d0a93417 	ldw	r2,-23344(gp)
   2455c:	e0bff915 	stw	r2,-28(fp)
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
   24560:	00003206 	br	2462c <raw_input+0x110>
    if ((pcb->protocol == proto) &&
   24564:	e0bff917 	ldw	r2,-28(fp)
   24568:	10800403 	ldbu	r2,16(r2)
   2456c:	10c03fcc 	andi	r3,r2,255
   24570:	e0bffd0f 	ldh	r2,-12(fp)
   24574:	1880281e 	bne	r3,r2,24618 <raw_input+0xfc>
        (ip_addr_isany(&pcb->local_ip) ||
   24578:	e0bff917 	ldw	r2,-28(fp)
  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if ((pcb->protocol == proto) &&
   2457c:	10000926 	beq	r2,zero,245a4 <raw_input+0x88>
        (ip_addr_isany(&pcb->local_ip) ||
   24580:	e0bff917 	ldw	r2,-28(fp)
   24584:	10800017 	ldw	r2,0(r2)
   24588:	10000626 	beq	r2,zero,245a4 <raw_input+0x88>
         ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest))) {
   2458c:	e0bff917 	ldw	r2,-28(fp)
   24590:	10c00017 	ldw	r3,0(r2)
   24594:	00800134 	movhi	r2,4
   24598:	109ee404 	addi	r2,r2,31632
   2459c:	10800017 	ldw	r2,0(r2)
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if ((pcb->protocol == proto) &&
        (ip_addr_isany(&pcb->local_ip) ||
   245a0:	18801d1e 	bne	r3,r2,24618 <raw_input+0xfc>
      /* broadcast filter? */
      if (ip_get_option(pcb, SOF_BROADCAST) || !ip_addr_isbroadcast(&current_iphdr_dest, inp))
#endif /* IP_SOF_BROADCAST_RECV */
      {
        /* receive callback function available? */
        if (pcb->recv != NULL) {
   245a4:	e0bff917 	ldw	r2,-28(fp)
   245a8:	10800517 	ldw	r2,20(r2)
   245ac:	10001a26 	beq	r2,zero,24618 <raw_input+0xfc>
          /* the receive callback function did not eat the packet? */
          if (pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr()) != 0) {
   245b0:	e0bff917 	ldw	r2,-28(fp)
   245b4:	10c00517 	ldw	r3,20(r2)
   245b8:	e0bff917 	ldw	r2,-28(fp)
   245bc:	10800617 	ldw	r2,24(r2)
   245c0:	1009883a 	mov	r4,r2
   245c4:	e17ff917 	ldw	r5,-28(fp)
   245c8:	e1bffe17 	ldw	r6,-8(fp)
   245cc:	01c00134 	movhi	r7,4
   245d0:	39dee204 	addi	r7,r7,31624
   245d4:	183ee83a 	callr	r3
   245d8:	10803fcc 	andi	r2,r2,255
   245dc:	10000e26 	beq	r2,zero,24618 <raw_input+0xfc>
            /* receive function ate the packet */
            p = NULL;
   245e0:	e03ffe15 	stw	zero,-8(fp)
            eaten = 1;
   245e4:	00800044 	movi	r2,1
   245e8:	e0bffb05 	stb	r2,-20(fp)
            if (prev != NULL) {
   245ec:	e0bffa17 	ldw	r2,-24(fp)
   245f0:	10000926 	beq	r2,zero,24618 <raw_input+0xfc>
            /* move the pcb to the front of raw_pcbs so that is
               found faster next time */
              prev->next = pcb->next;
   245f4:	e0bff917 	ldw	r2,-28(fp)
   245f8:	10c00317 	ldw	r3,12(r2)
   245fc:	e0bffa17 	ldw	r2,-24(fp)
   24600:	10c00315 	stw	r3,12(r2)
              pcb->next = raw_pcbs;
   24604:	d0e93417 	ldw	r3,-23344(gp)
   24608:	e0bff917 	ldw	r2,-28(fp)
   2460c:	10c00315 	stw	r3,12(r2)
              raw_pcbs = pcb;
   24610:	e0bff917 	ldw	r2,-28(fp)
   24614:	d0a93415 	stw	r2,-23344(gp)
        }
        /* no receive callback function was set for this raw PCB */
      }
      /* drop the packet */
    }
    prev = pcb;
   24618:	e0bff917 	ldw	r2,-28(fp)
   2461c:	e0bffa15 	stw	r2,-24(fp)
    pcb = pcb->next;
   24620:	e0bff917 	ldw	r2,-28(fp)
   24624:	10800317 	ldw	r2,12(r2)
   24628:	e0bff915 	stw	r2,-28(fp)

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
   2462c:	e0bffb03 	ldbu	r2,-20(fp)
   24630:	1000021e 	bne	r2,zero,2463c <raw_input+0x120>
   24634:	e0bff917 	ldw	r2,-28(fp)
   24638:	103fca1e 	bne	r2,zero,24564 <raw_input+0x48>
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
   2463c:	e0bffb03 	ldbu	r2,-20(fp)
}
   24640:	e037883a 	mov	sp,fp
   24644:	dfc00117 	ldw	ra,4(sp)
   24648:	df000017 	ldw	fp,0(sp)
   2464c:	dec00204 	addi	sp,sp,8
   24650:	f800283a 	ret

00024654 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, ip_addr_t *ipaddr)
{
   24654:	defffd04 	addi	sp,sp,-12
   24658:	df000215 	stw	fp,8(sp)
   2465c:	df000204 	addi	fp,sp,8
   24660:	e13ffe15 	stw	r4,-8(fp)
   24664:	e17fff15 	stw	r5,-4(fp)
  ip_addr_set(&pcb->local_ip, ipaddr);
   24668:	e0bfff17 	ldw	r2,-4(fp)
   2466c:	10000326 	beq	r2,zero,2467c <raw_bind+0x28>
   24670:	e0bfff17 	ldw	r2,-4(fp)
   24674:	10800017 	ldw	r2,0(r2)
   24678:	00000106 	br	24680 <raw_bind+0x2c>
   2467c:	0005883a 	mov	r2,zero
   24680:	e0fffe17 	ldw	r3,-8(fp)
   24684:	18800015 	stw	r2,0(r3)
  return ERR_OK;
   24688:	0005883a 	mov	r2,zero
}
   2468c:	e037883a 	mov	sp,fp
   24690:	df000017 	ldw	fp,0(sp)
   24694:	dec00104 	addi	sp,sp,4
   24698:	f800283a 	ret

0002469c <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, ip_addr_t *ipaddr)
{
   2469c:	defffd04 	addi	sp,sp,-12
   246a0:	df000215 	stw	fp,8(sp)
   246a4:	df000204 	addi	fp,sp,8
   246a8:	e13ffe15 	stw	r4,-8(fp)
   246ac:	e17fff15 	stw	r5,-4(fp)
  ip_addr_set(&pcb->remote_ip, ipaddr);
   246b0:	e0bfff17 	ldw	r2,-4(fp)
   246b4:	10000326 	beq	r2,zero,246c4 <raw_connect+0x28>
   246b8:	e0bfff17 	ldw	r2,-4(fp)
   246bc:	10800017 	ldw	r2,0(r2)
   246c0:	00000106 	br	246c8 <raw_connect+0x2c>
   246c4:	0005883a 	mov	r2,zero
   246c8:	e0fffe17 	ldw	r3,-8(fp)
   246cc:	18800115 	stw	r2,4(r3)
  return ERR_OK;
   246d0:	0005883a 	mov	r2,zero
}
   246d4:	e037883a 	mov	sp,fp
   246d8:	df000017 	ldw	fp,0(sp)
   246dc:	dec00104 	addi	sp,sp,4
   246e0:	f800283a 	ret

000246e4 <raw_recv>:
 * @return non-zero if the packet was free()d, zero if the packet remains
 * available for others.
 */
void
raw_recv(struct raw_pcb *pcb, raw_recv_fn recv, void *recv_arg)
{
   246e4:	defffc04 	addi	sp,sp,-16
   246e8:	df000315 	stw	fp,12(sp)
   246ec:	df000304 	addi	fp,sp,12
   246f0:	e13ffd15 	stw	r4,-12(fp)
   246f4:	e17ffe15 	stw	r5,-8(fp)
   246f8:	e1bfff15 	stw	r6,-4(fp)
  /* remember recv() callback and user data */
  pcb->recv = recv;
   246fc:	e0bffd17 	ldw	r2,-12(fp)
   24700:	e0fffe17 	ldw	r3,-8(fp)
   24704:	10c00515 	stw	r3,20(r2)
  pcb->recv_arg = recv_arg;
   24708:	e0bffd17 	ldw	r2,-12(fp)
   2470c:	e0ffff17 	ldw	r3,-4(fp)
   24710:	10c00615 	stw	r3,24(r2)
}
   24714:	e037883a 	mov	sp,fp
   24718:	df000017 	ldw	fp,0(sp)
   2471c:	dec00104 	addi	sp,sp,4
   24720:	f800283a 	ret

00024724 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, ip_addr_t *ipaddr)
{
   24724:	defff404 	addi	sp,sp,-48
   24728:	dfc00b15 	stw	ra,44(sp)
   2472c:	df000a15 	stw	fp,40(sp)
   24730:	df000a04 	addi	fp,sp,40
   24734:	e13ffd15 	stw	r4,-12(fp)
   24738:	e17ffe15 	stw	r5,-8(fp)
   2473c:	e1bfff15 	stw	r6,-4(fp)
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
   24740:	e13ffe17 	ldw	r4,-8(fp)
   24744:	01400504 	movi	r5,20
   24748:	00235b00 	call	235b0 <pbuf_header>
   2474c:	10803fcc 	andi	r2,r2,255
   24750:	10001126 	beq	r2,zero,24798 <raw_sendto+0x74>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
   24754:	01000044 	movi	r4,1
   24758:	000b883a 	mov	r5,zero
   2475c:	000d883a 	mov	r6,zero
   24760:	0022fa00 	call	22fa0 <pbuf_alloc>
   24764:	e0bffa15 	stw	r2,-24(fp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
   24768:	e0bffa17 	ldw	r2,-24(fp)
   2476c:	1000021e 	bne	r2,zero,24778 <raw_sendto+0x54>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
   24770:	00bfffc4 	movi	r2,-1
   24774:	00004806 	br	24898 <raw_sendto+0x174>
    }
    if (p->tot_len != 0) {
   24778:	e0bffe17 	ldw	r2,-8(fp)
   2477c:	1080020b 	ldhu	r2,8(r2)
   24780:	10bfffcc 	andi	r2,r2,65535
   24784:	10000d26 	beq	r2,zero,247bc <raw_sendto+0x98>
      /* chain header q in front of given pbuf p */
      pbuf_chain(q, p);
   24788:	e13ffa17 	ldw	r4,-24(fp)
   2478c:	e17ffe17 	ldw	r5,-8(fp)
   24790:	0023a200 	call	23a20 <pbuf_chain>
   24794:	00000906 	br	247bc <raw_sendto+0x98>
    }
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
   24798:	e0bffe17 	ldw	r2,-8(fp)
   2479c:	e0bffa15 	stw	r2,-24(fp)
    if(pbuf_header(q, -IP_HLEN)) {
   247a0:	e13ffa17 	ldw	r4,-24(fp)
   247a4:	017ffb04 	movi	r5,-20
   247a8:	00235b00 	call	235b0 <pbuf_header>
   247ac:	10803fcc 	andi	r2,r2,255
   247b0:	10000226 	beq	r2,zero,247bc <raw_sendto+0x98>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
   247b4:	00bfffc4 	movi	r2,-1
   247b8:	00003706 	br	24898 <raw_sendto+0x174>
    }
  }

  if ((netif = ip_route((struct ip_pcb*)pcb, ipaddr)) == NULL) {
   247bc:	e13ffd17 	ldw	r4,-12(fp)
   247c0:	e17fff17 	ldw	r5,-4(fp)
   247c4:	001ecb40 	call	1ecb4 <ip_route>
   247c8:	e0bffb15 	stw	r2,-20(fp)
   247cc:	e0bffb17 	ldw	r2,-20(fp)
   247d0:	1000071e 	bne	r2,zero,247f0 <raw_sendto+0xcc>
    LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_LEVEL_WARNING, ("raw_sendto: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr)));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
   247d4:	e0fffa17 	ldw	r3,-24(fp)
   247d8:	e0bffe17 	ldw	r2,-8(fp)
   247dc:	18800226 	beq	r3,r2,247e8 <raw_sendto+0xc4>
      pbuf_free(q);
   247e0:	e13ffa17 	ldw	r4,-24(fp)
   247e4:	00237600 	call	23760 <pbuf_free>
    }
    return ERR_RTE;
   247e8:	00bfff04 	movi	r2,-4
   247ec:	00002a06 	br	24898 <raw_sendto+0x174>
    }
    return ERR_VAL;
  }
#endif /* IP_SOF_BROADCAST */

  if (ip_addr_isany(&pcb->local_ip)) {
   247f0:	e0bffd17 	ldw	r2,-12(fp)
   247f4:	10000326 	beq	r2,zero,24804 <raw_sendto+0xe0>
   247f8:	e0bffd17 	ldw	r2,-12(fp)
   247fc:	10800017 	ldw	r2,0(r2)
   24800:	1000041e 	bne	r2,zero,24814 <raw_sendto+0xf0>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
   24804:	e0bffb17 	ldw	r2,-20(fp)
   24808:	10800104 	addi	r2,r2,4
   2480c:	e0bff915 	stw	r2,-28(fp)
   24810:	00000206 	br	2481c <raw_sendto+0xf8>
  } else {
    /* use RAW PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
   24814:	e0bffd17 	ldw	r2,-12(fp)
   24818:	e0bff915 	stw	r2,-28(fp)
  }

  NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
   2481c:	e0bffd17 	ldw	r2,-12(fp)
   24820:	10c002c4 	addi	r3,r2,11
   24824:	e0bffb17 	ldw	r2,-20(fp)
   24828:	10c01015 	stw	r3,64(r2)
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
   2482c:	e0bffd17 	ldw	r2,-12(fp)
   24830:	10800283 	ldbu	r2,10(r2)
   24834:	10803fcc 	andi	r2,r2,255
   24838:	e0fffd17 	ldw	r3,-12(fp)
   2483c:	18c00243 	ldbu	r3,9(r3)
   24840:	19003fcc 	andi	r4,r3,255
   24844:	e0fffd17 	ldw	r3,-12(fp)
   24848:	18c00403 	ldbu	r3,16(r3)
   2484c:	18c03fcc 	andi	r3,r3,255
   24850:	d9000015 	stw	r4,0(sp)
   24854:	d8c00115 	stw	r3,4(sp)
   24858:	e0fffb17 	ldw	r3,-20(fp)
   2485c:	d8c00215 	stw	r3,8(sp)
   24860:	e13ffa17 	ldw	r4,-24(fp)
   24864:	e17ff917 	ldw	r5,-28(fp)
   24868:	e1bfff17 	ldw	r6,-4(fp)
   2486c:	100f883a 	mov	r7,r2
   24870:	001f3080 	call	1f308 <ip_output_if>
   24874:	e0bffc05 	stb	r2,-16(fp)
  NETIF_SET_HWADDRHINT(netif, NULL);
   24878:	e0bffb17 	ldw	r2,-20(fp)
   2487c:	10001015 	stw	zero,64(r2)

  /* did we chain a header earlier? */
  if (q != p) {
   24880:	e0fffa17 	ldw	r3,-24(fp)
   24884:	e0bffe17 	ldw	r2,-8(fp)
   24888:	18800226 	beq	r3,r2,24894 <raw_sendto+0x170>
    /* free the header */
    pbuf_free(q);
   2488c:	e13ffa17 	ldw	r4,-24(fp)
   24890:	00237600 	call	23760 <pbuf_free>
  }
  return err;
   24894:	e0bffc03 	ldbu	r2,-16(fp)
}
   24898:	e037883a 	mov	sp,fp
   2489c:	dfc00117 	ldw	ra,4(sp)
   248a0:	df000017 	ldw	fp,0(sp)
   248a4:	dec00204 	addi	sp,sp,8
   248a8:	f800283a 	ret

000248ac <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
   248ac:	defffc04 	addi	sp,sp,-16
   248b0:	dfc00315 	stw	ra,12(sp)
   248b4:	df000215 	stw	fp,8(sp)
   248b8:	df000204 	addi	fp,sp,8
   248bc:	e13ffe15 	stw	r4,-8(fp)
   248c0:	e17fff15 	stw	r5,-4(fp)
  return raw_sendto(pcb, p, &pcb->remote_ip);
   248c4:	e0bffe17 	ldw	r2,-8(fp)
   248c8:	10800104 	addi	r2,r2,4
   248cc:	e13ffe17 	ldw	r4,-8(fp)
   248d0:	e17fff17 	ldw	r5,-4(fp)
   248d4:	100d883a 	mov	r6,r2
   248d8:	00247240 	call	24724 <raw_sendto>
}
   248dc:	e037883a 	mov	sp,fp
   248e0:	dfc00117 	ldw	ra,4(sp)
   248e4:	df000017 	ldw	fp,0(sp)
   248e8:	dec00204 	addi	sp,sp,8
   248ec:	f800283a 	ret

000248f0 <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
   248f0:	defffc04 	addi	sp,sp,-16
   248f4:	dfc00315 	stw	ra,12(sp)
   248f8:	df000215 	stw	fp,8(sp)
   248fc:	df000204 	addi	fp,sp,8
   24900:	e13fff15 	stw	r4,-4(fp)
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
   24904:	d0e93417 	ldw	r3,-23344(gp)
   24908:	e0bfff17 	ldw	r2,-4(fp)
   2490c:	1880041e 	bne	r3,r2,24920 <raw_remove+0x30>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
   24910:	d0a93417 	ldw	r2,-23344(gp)
   24914:	10800317 	ldw	r2,12(r2)
   24918:	d0a93415 	stw	r2,-23344(gp)
   2491c:	00001306 	br	2496c <raw_remove+0x7c>
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
   24920:	d0a93417 	ldw	r2,-23344(gp)
   24924:	e0bffe15 	stw	r2,-8(fp)
   24928:	00000e06 	br	24964 <raw_remove+0x74>
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
   2492c:	e0bffe17 	ldw	r2,-8(fp)
   24930:	10800317 	ldw	r2,12(r2)
   24934:	10000826 	beq	r2,zero,24958 <raw_remove+0x68>
   24938:	e0bffe17 	ldw	r2,-8(fp)
   2493c:	10c00317 	ldw	r3,12(r2)
   24940:	e0bfff17 	ldw	r2,-4(fp)
   24944:	1880041e 	bne	r3,r2,24958 <raw_remove+0x68>
        /* remove pcb from list */
        pcb2->next = pcb->next;
   24948:	e0bfff17 	ldw	r2,-4(fp)
   2494c:	10c00317 	ldw	r3,12(r2)
   24950:	e0bffe17 	ldw	r2,-8(fp)
   24954:	10c00315 	stw	r3,12(r2)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
   24958:	e0bffe17 	ldw	r2,-8(fp)
   2495c:	10800317 	ldw	r2,12(r2)
   24960:	e0bffe15 	stw	r2,-8(fp)
   24964:	e0bffe17 	ldw	r2,-8(fp)
   24968:	103ff01e 	bne	r2,zero,2492c <raw_remove+0x3c>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
   2496c:	0009883a 	mov	r4,zero
   24970:	e17fff17 	ldw	r5,-4(fp)
   24974:	00225900 	call	22590 <memp_free>
}
   24978:	e037883a 	mov	sp,fp
   2497c:	dfc00117 	ldw	ra,4(sp)
   24980:	df000017 	ldw	fp,0(sp)
   24984:	dec00204 	addi	sp,sp,8
   24988:	f800283a 	ret

0002498c <raw_new>:
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto)
{
   2498c:	defffc04 	addi	sp,sp,-16
   24990:	dfc00315 	stw	ra,12(sp)
   24994:	df000215 	stw	fp,8(sp)
   24998:	df000204 	addi	fp,sp,8
   2499c:	2005883a 	mov	r2,r4
   249a0:	e0bfff05 	stb	r2,-4(fp)
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_new\n"));

  pcb = (struct raw_pcb *)memp_malloc(MEMP_RAW_PCB);
   249a4:	0009883a 	mov	r4,zero
   249a8:	00223cc0 	call	223cc <memp_malloc>
   249ac:	e0bffe15 	stw	r2,-8(fp)
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
   249b0:	e0bffe17 	ldw	r2,-8(fp)
   249b4:	10000f26 	beq	r2,zero,249f4 <raw_new+0x68>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
   249b8:	e13ffe17 	ldw	r4,-8(fp)
   249bc:	000b883a 	mov	r5,zero
   249c0:	01800704 	movi	r6,28
   249c4:	00042e80 	call	42e8 <memset>
    pcb->protocol = proto;
   249c8:	e0bffe17 	ldw	r2,-8(fp)
   249cc:	e0ffff03 	ldbu	r3,-4(fp)
   249d0:	10c00405 	stb	r3,16(r2)
    pcb->ttl = RAW_TTL;
   249d4:	e0bffe17 	ldw	r2,-8(fp)
   249d8:	00c01004 	movi	r3,64
   249dc:	10c00285 	stb	r3,10(r2)
    pcb->next = raw_pcbs;
   249e0:	d0e93417 	ldw	r3,-23344(gp)
   249e4:	e0bffe17 	ldw	r2,-8(fp)
   249e8:	10c00315 	stw	r3,12(r2)
    raw_pcbs = pcb;
   249ec:	e0bffe17 	ldw	r2,-8(fp)
   249f0:	d0a93415 	stw	r2,-23344(gp)
  }
  return pcb;
   249f4:	e0bffe17 	ldw	r2,-8(fp)
}
   249f8:	e037883a 	mov	sp,fp
   249fc:	dfc00117 	ldw	ra,4(sp)
   24a00:	df000017 	ldw	fp,0(sp)
   24a04:	dec00204 	addi	sp,sp,8
   24a08:	f800283a 	ret

00024a0c <stats_init>:
#include <string.h>

struct stats_ lwip_stats;

void stats_init(void)
{
   24a0c:	deffff04 	addi	sp,sp,-4
   24a10:	df000015 	stw	fp,0(sp)
   24a14:	d839883a 	mov	fp,sp
#endif /* MEMP_STATS */
#if MEM_STATS
  lwip_stats.mem.name = "MEM";
#endif /* MEM_STATS */
#endif /* LWIP_DEBUG */
}
   24a18:	e037883a 	mov	sp,fp
   24a1c:	df000017 	ldw	fp,0(sp)
   24a20:	dec00104 	addi	sp,sp,4
   24a24:	f800283a 	ret

00024a28 <tcp_init>:
/**
 * Initialize this module.
 */
void
tcp_init(void)
{
   24a28:	deffff04 	addi	sp,sp,-4
   24a2c:	df000015 	stw	fp,0(sp)
   24a30:	d839883a 	mov	fp,sp
#if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
  tcp_port = TCP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
#endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
}
   24a34:	e037883a 	mov	sp,fp
   24a38:	df000017 	ldw	fp,0(sp)
   24a3c:	dec00104 	addi	sp,sp,4
   24a40:	f800283a 	ret

00024a44 <tcp_tmr>:
/**
 * Called periodically to dispatch TCP timers.
 */
void
tcp_tmr(void)
{
   24a44:	defffe04 	addi	sp,sp,-8
   24a48:	dfc00115 	stw	ra,4(sp)
   24a4c:	df000015 	stw	fp,0(sp)
   24a50:	d839883a 	mov	fp,sp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
   24a54:	00262600 	call	26260 <tcp_fasttmr>

  if (++tcp_timer & 1) {
   24a58:	d0a93503 	ldbu	r2,-23340(gp)
   24a5c:	10800044 	addi	r2,r2,1
   24a60:	d0a93505 	stb	r2,-23340(gp)
   24a64:	d0a93503 	ldbu	r2,-23340(gp)
   24a68:	10803fcc 	andi	r2,r2,255
   24a6c:	1080004c 	andi	r2,r2,1
   24a70:	10000126 	beq	r2,zero,24a78 <tcp_tmr+0x34>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
   24a74:	0025b340 	call	25b34 <tcp_slowtmr>
  }
}
   24a78:	e037883a 	mov	sp,fp
   24a7c:	dfc00117 	ldw	ra,4(sp)
   24a80:	df000017 	ldw	fp,0(sp)
   24a84:	dec00204 	addi	sp,sp,8
   24a88:	f800283a 	ret

00024a8c <tcp_close_shutdown>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
static err_t
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
   24a8c:	defff904 	addi	sp,sp,-28
   24a90:	dfc00615 	stw	ra,24(sp)
   24a94:	df000515 	stw	fp,20(sp)
   24a98:	df000504 	addi	fp,sp,20
   24a9c:	e13ffe15 	stw	r4,-8(fp)
   24aa0:	2805883a 	mov	r2,r5
   24aa4:	e0bfff05 	stb	r2,-4(fp)
  err_t err;

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
   24aa8:	e0bfff03 	ldbu	r2,-4(fp)
   24aac:	10005326 	beq	r2,zero,24bfc <tcp_close_shutdown+0x170>
   24ab0:	e0bffe17 	ldw	r2,-8(fp)
   24ab4:	10800617 	ldw	r2,24(r2)
   24ab8:	10800120 	cmpeqi	r2,r2,4
   24abc:	1000041e 	bne	r2,zero,24ad0 <tcp_close_shutdown+0x44>
   24ac0:	e0bffe17 	ldw	r2,-8(fp)
   24ac4:	10800617 	ldw	r2,24(r2)
   24ac8:	108001d8 	cmpnei	r2,r2,7
   24acc:	10004b1e 	bne	r2,zero,24bfc <tcp_close_shutdown+0x170>
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
   24ad0:	e0bffe17 	ldw	r2,-8(fp)
   24ad4:	10801f17 	ldw	r2,124(r2)
   24ad8:	1000051e 	bne	r2,zero,24af0 <tcp_close_shutdown+0x64>
   24adc:	e0bffe17 	ldw	r2,-8(fp)
   24ae0:	10800c0b 	ldhu	r2,48(r2)
   24ae4:	10bfffcc 	andi	r2,r2,65535
   24ae8:	10880020 	cmpeqi	r2,r2,8192
   24aec:	1000431e 	bne	r2,zero,24bfc <tcp_close_shutdown+0x170>
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);

      /* don't call tcp_abort here: we must not deallocate the pcb since
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
   24af0:	e0bffe17 	ldw	r2,-8(fp)
   24af4:	11001517 	ldw	r4,84(r2)
   24af8:	e0bffe17 	ldw	r2,-8(fp)
   24afc:	11400b17 	ldw	r5,44(r2)
   24b00:	e0fffe17 	ldw	r3,-8(fp)
   24b04:	e0bffe17 	ldw	r2,-8(fp)
   24b08:	10800104 	addi	r2,r2,4
        pcb->local_port, pcb->remote_port);
   24b0c:	e1bffe17 	ldw	r6,-8(fp)
   24b10:	3180078b 	ldhu	r6,30(r6)
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);

      /* don't call tcp_abort here: we must not deallocate the pcb since
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
   24b14:	31ffffcc 	andi	r7,r6,65535
        pcb->local_port, pcb->remote_port);
   24b18:	e1bffe17 	ldw	r6,-8(fp)
   24b1c:	3180080b 	ldhu	r6,32(r6)
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);

      /* don't call tcp_abort here: we must not deallocate the pcb since
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
   24b20:	31bfffcc 	andi	r6,r6,65535
   24b24:	d9c00015 	stw	r7,0(sp)
   24b28:	d9800115 	stw	r6,4(sp)
   24b2c:	180d883a 	mov	r6,r3
   24b30:	100f883a 	mov	r7,r2
   24b34:	002da300 	call	2da30 <tcp_rst>
        pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
   24b38:	e13ffe17 	ldw	r4,-8(fp)
   24b3c:	0026b2c0 	call	26b2c <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
   24b40:	d0e93617 	ldw	r3,-23336(gp)
   24b44:	e0bffe17 	ldw	r2,-8(fp)
   24b48:	1880041e 	bne	r3,r2,24b5c <tcp_close_shutdown+0xd0>
   24b4c:	d0a93617 	ldw	r2,-23336(gp)
   24b50:	10800317 	ldw	r2,12(r2)
   24b54:	d0a93615 	stw	r2,-23336(gp)
   24b58:	00001106 	br	24ba0 <tcp_close_shutdown+0x114>
   24b5c:	d0a93617 	ldw	r2,-23336(gp)
   24b60:	d0a93915 	stw	r2,-23324(gp)
   24b64:	00000c06 	br	24b98 <tcp_close_shutdown+0x10c>
   24b68:	d0a93917 	ldw	r2,-23324(gp)
   24b6c:	10c00317 	ldw	r3,12(r2)
   24b70:	e0bffe17 	ldw	r2,-8(fp)
   24b74:	1880051e 	bne	r3,r2,24b8c <tcp_close_shutdown+0x100>
   24b78:	d0a93917 	ldw	r2,-23324(gp)
   24b7c:	e0fffe17 	ldw	r3,-8(fp)
   24b80:	18c00317 	ldw	r3,12(r3)
   24b84:	10c00315 	stw	r3,12(r2)
   24b88:	00000506 	br	24ba0 <tcp_close_shutdown+0x114>
   24b8c:	d0a93917 	ldw	r2,-23324(gp)
   24b90:	10800317 	ldw	r2,12(r2)
   24b94:	d0a93915 	stw	r2,-23324(gp)
   24b98:	d0a93917 	ldw	r2,-23324(gp)
   24b9c:	103ff21e 	bne	r2,zero,24b68 <tcp_close_shutdown+0xdc>
   24ba0:	e0bffe17 	ldw	r2,-8(fp)
   24ba4:	10000315 	stw	zero,12(r2)
   24ba8:	00800044 	movi	r2,1
   24bac:	d0a93585 	stb	r2,-23338(gp)
      if (pcb->state == ESTABLISHED) {
   24bb0:	e0bffe17 	ldw	r2,-8(fp)
   24bb4:	10800617 	ldw	r2,24(r2)
   24bb8:	10800118 	cmpnei	r2,r2,4
   24bbc:	10000a1e 	bne	r2,zero,24be8 <tcp_close_shutdown+0x15c>
        /* move to TIME_WAIT since we close actively */
        pcb->state = TIME_WAIT;
   24bc0:	e0bffe17 	ldw	r2,-8(fp)
   24bc4:	00c00284 	movi	r3,10
   24bc8:	10c00615 	stw	r3,24(r2)
        TCP_REG(&tcp_tw_pcbs, pcb);
   24bcc:	d0e93b17 	ldw	r3,-23316(gp)
   24bd0:	e0bffe17 	ldw	r2,-8(fp)
   24bd4:	10c00315 	stw	r3,12(r2)
   24bd8:	e0bffe17 	ldw	r2,-8(fp)
   24bdc:	d0a93b15 	stw	r2,-23316(gp)
   24be0:	002e6bc0 	call	2e6bc <tcp_timer_needed>
   24be4:	00000306 	br	24bf4 <tcp_close_shutdown+0x168>
      } else {
        /* CLOSE_WAIT: deallocate the pcb since we already sent a RST for it */
        memp_free(MEMP_TCP_PCB, pcb);
   24be8:	01000084 	movi	r4,2
   24bec:	e17ffe17 	ldw	r5,-8(fp)
   24bf0:	00225900 	call	22590 <memp_free>
      }
      return ERR_OK;
   24bf4:	0005883a 	mov	r2,zero
   24bf8:	00007506 	br	24dd0 <tcp_close_shutdown+0x344>
    }
  }

  switch (pcb->state) {
   24bfc:	e0bffe17 	ldw	r2,-8(fp)
   24c00:	10800617 	ldw	r2,24(r2)
   24c04:	10c00228 	cmpgeui	r3,r2,8
   24c08:	1800621e 	bne	r3,zero,24d94 <tcp_close_shutdown+0x308>
   24c0c:	1085883a 	add	r2,r2,r2
   24c10:	1087883a 	add	r3,r2,r2
   24c14:	008000b4 	movhi	r2,2
   24c18:	10930a04 	addi	r2,r2,19496
   24c1c:	1885883a 	add	r2,r3,r2
   24c20:	10800017 	ldw	r2,0(r2)
   24c24:	1000683a 	jmp	r2
   24c28:	00024c48 	cmpgei	zero,zero,2353
   24c2c:	00024cd8 	cmpnei	zero,zero,2355
   24c30:	00024cfc 	xorhi	zero,zero,2355
   24c34:	00024d28 	cmpgeui	zero,zero,2356
   24c38:	00024d4c 	andi	zero,zero,2357
   24c3c:	00024d94 	movui	zero,2358
   24c40:	00024d94 	movui	zero,2358
   24c44:	00024d70 	cmpltui	zero,zero,2357
     * and the user needs some way to free it should the need arise.
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
   24c48:	e03ffd05 	stb	zero,-12(fp)
    if (pcb->local_port != 0) {
   24c4c:	e0bffe17 	ldw	r2,-8(fp)
   24c50:	1080078b 	ldhu	r2,30(r2)
   24c54:	10bfffcc 	andi	r2,r2,65535
   24c58:	10001a26 	beq	r2,zero,24cc4 <tcp_close_shutdown+0x238>
      TCP_RMV(&tcp_bound_pcbs, pcb);
   24c5c:	d0e93a17 	ldw	r3,-23320(gp)
   24c60:	e0bffe17 	ldw	r2,-8(fp)
   24c64:	1880041e 	bne	r3,r2,24c78 <tcp_close_shutdown+0x1ec>
   24c68:	d0a93a17 	ldw	r2,-23320(gp)
   24c6c:	10800317 	ldw	r2,12(r2)
   24c70:	d0a93a15 	stw	r2,-23320(gp)
   24c74:	00001106 	br	24cbc <tcp_close_shutdown+0x230>
   24c78:	d0a93a17 	ldw	r2,-23320(gp)
   24c7c:	d0a93915 	stw	r2,-23324(gp)
   24c80:	00000c06 	br	24cb4 <tcp_close_shutdown+0x228>
   24c84:	d0a93917 	ldw	r2,-23324(gp)
   24c88:	10c00317 	ldw	r3,12(r2)
   24c8c:	e0bffe17 	ldw	r2,-8(fp)
   24c90:	1880051e 	bne	r3,r2,24ca8 <tcp_close_shutdown+0x21c>
   24c94:	d0a93917 	ldw	r2,-23324(gp)
   24c98:	e0fffe17 	ldw	r3,-8(fp)
   24c9c:	18c00317 	ldw	r3,12(r3)
   24ca0:	10c00315 	stw	r3,12(r2)
   24ca4:	00000506 	br	24cbc <tcp_close_shutdown+0x230>
   24ca8:	d0a93917 	ldw	r2,-23324(gp)
   24cac:	10800317 	ldw	r2,12(r2)
   24cb0:	d0a93915 	stw	r2,-23324(gp)
   24cb4:	d0a93917 	ldw	r2,-23324(gp)
   24cb8:	103ff21e 	bne	r2,zero,24c84 <tcp_close_shutdown+0x1f8>
   24cbc:	e0bffe17 	ldw	r2,-8(fp)
   24cc0:	10000315 	stw	zero,12(r2)
    }
    memp_free(MEMP_TCP_PCB, pcb);
   24cc4:	01000084 	movi	r4,2
   24cc8:	e17ffe17 	ldw	r5,-8(fp)
   24ccc:	00225900 	call	22590 <memp_free>
    pcb = NULL;
   24cd0:	e03ffe15 	stw	zero,-8(fp)
    break;
   24cd4:	00003706 	br	24db4 <tcp_close_shutdown+0x328>
  case LISTEN:
    err = ERR_OK;
   24cd8:	e03ffd05 	stb	zero,-12(fp)
    tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
   24cdc:	d1293804 	addi	r4,gp,-23328
   24ce0:	e17ffe17 	ldw	r5,-8(fp)
   24ce4:	0026c980 	call	26c98 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
   24ce8:	010000c4 	movi	r4,3
   24cec:	e17ffe17 	ldw	r5,-8(fp)
   24cf0:	00225900 	call	22590 <memp_free>
    pcb = NULL;
   24cf4:	e03ffe15 	stw	zero,-8(fp)
    break;
   24cf8:	00002e06 	br	24db4 <tcp_close_shutdown+0x328>
  case SYN_SENT:
    err = ERR_OK;
   24cfc:	e03ffd05 	stb	zero,-12(fp)
    TCP_PCB_REMOVE_ACTIVE(pcb);
   24d00:	d1293604 	addi	r4,gp,-23336
   24d04:	e17ffe17 	ldw	r5,-8(fp)
   24d08:	0026c980 	call	26c98 <tcp_pcb_remove>
   24d0c:	00800044 	movi	r2,1
   24d10:	d0a93585 	stb	r2,-23338(gp)
    memp_free(MEMP_TCP_PCB, pcb);
   24d14:	01000084 	movi	r4,2
   24d18:	e17ffe17 	ldw	r5,-8(fp)
   24d1c:	00225900 	call	22590 <memp_free>
    pcb = NULL;
   24d20:	e03ffe15 	stw	zero,-8(fp)
    snmp_inc_tcpattemptfails();
    break;
   24d24:	00002306 	br	24db4 <tcp_close_shutdown+0x328>
  case SYN_RCVD:
    err = tcp_send_fin(pcb);
   24d28:	e13ffe17 	ldw	r4,-8(fp)
   24d2c:	002b5200 	call	2b520 <tcp_send_fin>
   24d30:	e0bffd05 	stb	r2,-12(fp)
    if (err == ERR_OK) {
   24d34:	e0bffd07 	ldb	r2,-12(fp)
   24d38:	1000191e 	bne	r2,zero,24da0 <tcp_close_shutdown+0x314>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
   24d3c:	e0bffe17 	ldw	r2,-8(fp)
   24d40:	00c00144 	movi	r3,5
   24d44:	10c00615 	stw	r3,24(r2)
    }
    break;
   24d48:	00001506 	br	24da0 <tcp_close_shutdown+0x314>
  case ESTABLISHED:
    err = tcp_send_fin(pcb);
   24d4c:	e13ffe17 	ldw	r4,-8(fp)
   24d50:	002b5200 	call	2b520 <tcp_send_fin>
   24d54:	e0bffd05 	stb	r2,-12(fp)
    if (err == ERR_OK) {
   24d58:	e0bffd07 	ldb	r2,-12(fp)
   24d5c:	1000121e 	bne	r2,zero,24da8 <tcp_close_shutdown+0x31c>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
   24d60:	e0bffe17 	ldw	r2,-8(fp)
   24d64:	00c00144 	movi	r3,5
   24d68:	10c00615 	stw	r3,24(r2)
    }
    break;
   24d6c:	00000e06 	br	24da8 <tcp_close_shutdown+0x31c>
  case CLOSE_WAIT:
    err = tcp_send_fin(pcb);
   24d70:	e13ffe17 	ldw	r4,-8(fp)
   24d74:	002b5200 	call	2b520 <tcp_send_fin>
   24d78:	e0bffd05 	stb	r2,-12(fp)
    if (err == ERR_OK) {
   24d7c:	e0bffd07 	ldb	r2,-12(fp)
   24d80:	10000b1e 	bne	r2,zero,24db0 <tcp_close_shutdown+0x324>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
   24d84:	e0bffe17 	ldw	r2,-8(fp)
   24d88:	00c00244 	movi	r3,9
   24d8c:	10c00615 	stw	r3,24(r2)
    }
    break;
   24d90:	00000706 	br	24db0 <tcp_close_shutdown+0x324>
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
   24d94:	e03ffd05 	stb	zero,-12(fp)
    pcb = NULL;
   24d98:	e03ffe15 	stw	zero,-8(fp)
    break;
   24d9c:	00000506 	br	24db4 <tcp_close_shutdown+0x328>
    err = tcp_send_fin(pcb);
    if (err == ERR_OK) {
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
    }
    break;
   24da0:	0001883a 	nop
   24da4:	00000306 	br	24db4 <tcp_close_shutdown+0x328>
    err = tcp_send_fin(pcb);
    if (err == ERR_OK) {
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
    }
    break;
   24da8:	0001883a 	nop
   24dac:	00000106 	br	24db4 <tcp_close_shutdown+0x328>
    err = tcp_send_fin(pcb);
    if (err == ERR_OK) {
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
    }
    break;
   24db0:	0001883a 	nop
    err = ERR_OK;
    pcb = NULL;
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
   24db4:	e0bffe17 	ldw	r2,-8(fp)
   24db8:	10000426 	beq	r2,zero,24dcc <tcp_close_shutdown+0x340>
   24dbc:	e0bffd07 	ldb	r2,-12(fp)
   24dc0:	1000021e 	bne	r2,zero,24dcc <tcp_close_shutdown+0x340>
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent and acked before close returns.
       This can only be valid for sequential APIs, not for the raw API. */
    tcp_output(pcb);
   24dc4:	e13ffe17 	ldw	r4,-8(fp)
   24dc8:	002c9d00 	call	2c9d0 <tcp_output>
  }
  return err;
   24dcc:	e0bffd03 	ldbu	r2,-12(fp)
}
   24dd0:	e037883a 	mov	sp,fp
   24dd4:	dfc00117 	ldw	ra,4(sp)
   24dd8:	df000017 	ldw	fp,0(sp)
   24ddc:	dec00204 	addi	sp,sp,8
   24de0:	f800283a 	ret

00024de4 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
   24de4:	defffd04 	addi	sp,sp,-12
   24de8:	dfc00215 	stw	ra,8(sp)
   24dec:	df000115 	stw	fp,4(sp)
   24df0:	df000104 	addi	fp,sp,4
   24df4:	e13fff15 	stw	r4,-4(fp)
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  if (pcb->state != LISTEN) {
   24df8:	e0bfff17 	ldw	r2,-4(fp)
   24dfc:	10800617 	ldw	r2,24(r2)
   24e00:	10800060 	cmpeqi	r2,r2,1
   24e04:	1000061e 	bne	r2,zero,24e20 <tcp_close+0x3c>
    /* Set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
   24e08:	e0bfff17 	ldw	r2,-4(fp)
   24e0c:	10800883 	ldbu	r2,34(r2)
   24e10:	10800414 	ori	r2,r2,16
   24e14:	1007883a 	mov	r3,r2
   24e18:	e0bfff17 	ldw	r2,-4(fp)
   24e1c:	10c00885 	stb	r3,34(r2)
  }
  /* ... and close */
  return tcp_close_shutdown(pcb, 1);
   24e20:	e13fff17 	ldw	r4,-4(fp)
   24e24:	01400044 	movi	r5,1
   24e28:	0024a8c0 	call	24a8c <tcp_close_shutdown>
}
   24e2c:	e037883a 	mov	sp,fp
   24e30:	dfc00117 	ldw	ra,4(sp)
   24e34:	df000017 	ldw	fp,0(sp)
   24e38:	dec00204 	addi	sp,sp,8
   24e3c:	f800283a 	ret

00024e40 <tcp_shutdown>:
 * @return ERR_OK if shutdown succeeded (or the PCB has already been shut down)
 *         another err_t on error.
 */
err_t
tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx)
{
   24e40:	defffb04 	addi	sp,sp,-20
   24e44:	dfc00415 	stw	ra,16(sp)
   24e48:	df000315 	stw	fp,12(sp)
   24e4c:	df000304 	addi	fp,sp,12
   24e50:	e13ffd15 	stw	r4,-12(fp)
   24e54:	e17ffe15 	stw	r5,-8(fp)
   24e58:	e1bfff15 	stw	r6,-4(fp)
  if (pcb->state == LISTEN) {
   24e5c:	e0bffd17 	ldw	r2,-12(fp)
   24e60:	10800617 	ldw	r2,24(r2)
   24e64:	10800058 	cmpnei	r2,r2,1
   24e68:	1000021e 	bne	r2,zero,24e74 <tcp_shutdown+0x34>
    return ERR_CONN;
   24e6c:	00bffcc4 	movi	r2,-13
   24e70:	00002a06 	br	24f1c <tcp_shutdown+0xdc>
  }
  if (shut_rx) {
   24e74:	e0bffe17 	ldw	r2,-8(fp)
   24e78:	10001526 	beq	r2,zero,24ed0 <tcp_shutdown+0x90>
    /* shut down the receive side: set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
   24e7c:	e0bffd17 	ldw	r2,-12(fp)
   24e80:	10800883 	ldbu	r2,34(r2)
   24e84:	10800414 	ori	r2,r2,16
   24e88:	1007883a 	mov	r3,r2
   24e8c:	e0bffd17 	ldw	r2,-12(fp)
   24e90:	10c00885 	stb	r3,34(r2)
    if (shut_tx) {
   24e94:	e0bfff17 	ldw	r2,-4(fp)
   24e98:	10000426 	beq	r2,zero,24eac <tcp_shutdown+0x6c>
      /* shutting down the tx AND rx side is the same as closing for the raw API */
      return tcp_close_shutdown(pcb, 1);
   24e9c:	e13ffd17 	ldw	r4,-12(fp)
   24ea0:	01400044 	movi	r5,1
   24ea4:	0024a8c0 	call	24a8c <tcp_close_shutdown>
   24ea8:	00001c06 	br	24f1c <tcp_shutdown+0xdc>
    }
    /* ... and free buffered data */
    if (pcb->refused_data != NULL) {
   24eac:	e0bffd17 	ldw	r2,-12(fp)
   24eb0:	10801f17 	ldw	r2,124(r2)
   24eb4:	10000626 	beq	r2,zero,24ed0 <tcp_shutdown+0x90>
      pbuf_free(pcb->refused_data);
   24eb8:	e0bffd17 	ldw	r2,-12(fp)
   24ebc:	10801f17 	ldw	r2,124(r2)
   24ec0:	1009883a 	mov	r4,r2
   24ec4:	00237600 	call	23760 <pbuf_free>
      pcb->refused_data = NULL;
   24ec8:	e0bffd17 	ldw	r2,-12(fp)
   24ecc:	10001f15 	stw	zero,124(r2)
    }
  }
  if (shut_tx) {
   24ed0:	e0bfff17 	ldw	r2,-4(fp)
   24ed4:	10001026 	beq	r2,zero,24f18 <tcp_shutdown+0xd8>
    /* This can't happen twice since if it succeeds, the pcb's state is changed.
       Only close in these states as the others directly deallocate the PCB */
    switch (pcb->state) {
   24ed8:	e0bffd17 	ldw	r2,-12(fp)
   24edc:	10800617 	ldw	r2,24(r2)
   24ee0:	10c000f0 	cmpltui	r3,r2,3
   24ee4:	18000a1e 	bne	r3,zero,24f10 <tcp_shutdown+0xd0>
   24ee8:	10c00170 	cmpltui	r3,r2,5
   24eec:	1800021e 	bne	r3,zero,24ef8 <tcp_shutdown+0xb8>
   24ef0:	108001e0 	cmpeqi	r2,r2,7
   24ef4:	10000626 	beq	r2,zero,24f10 <tcp_shutdown+0xd0>
    case SYN_RCVD:
    case ESTABLISHED:
    case CLOSE_WAIT:
      return tcp_close_shutdown(pcb, shut_rx);
   24ef8:	e0bffe17 	ldw	r2,-8(fp)
   24efc:	10803fcc 	andi	r2,r2,255
   24f00:	e13ffd17 	ldw	r4,-12(fp)
   24f04:	100b883a 	mov	r5,r2
   24f08:	0024a8c0 	call	24a8c <tcp_close_shutdown>
   24f0c:	00000306 	br	24f1c <tcp_shutdown+0xdc>
    default:
      /* Not (yet?) connected, cannot shutdown the TX side as that would bring us
        into CLOSED state, where the PCB is deallocated. */
      return ERR_CONN;
   24f10:	00bffcc4 	movi	r2,-13
   24f14:	00000106 	br	24f1c <tcp_shutdown+0xdc>
    }
  }
  return ERR_OK;
   24f18:	0005883a 	mov	r2,zero
}
   24f1c:	e037883a 	mov	sp,fp
   24f20:	dfc00117 	ldw	ra,4(sp)
   24f24:	df000017 	ldw	fp,0(sp)
   24f28:	dec00204 	addi	sp,sp,8
   24f2c:	f800283a 	ret

00024f30 <tcp_abandon>:
 * @param pcb the tcp_pcb to abort
 * @param reset boolean to indicate whether a reset should be sent
 */
void
tcp_abandon(struct tcp_pcb *pcb, int reset)
{
   24f30:	defff604 	addi	sp,sp,-40
   24f34:	dfc00915 	stw	ra,36(sp)
   24f38:	df000815 	stw	fp,32(sp)
   24f3c:	df000804 	addi	fp,sp,32
   24f40:	e13ffe15 	stw	r4,-8(fp)
   24f44:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
    pcb->state != LISTEN);
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
   24f48:	e0bffe17 	ldw	r2,-8(fp)
   24f4c:	10800617 	ldw	r2,24(r2)
   24f50:	10800298 	cmpnei	r2,r2,10
   24f54:	1000071e 	bne	r2,zero,24f74 <tcp_abandon+0x44>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
   24f58:	d1293b04 	addi	r4,gp,-23316
   24f5c:	e17ffe17 	ldw	r5,-8(fp)
   24f60:	0026c980 	call	26c98 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
   24f64:	01000084 	movi	r4,2
   24f68:	e17ffe17 	ldw	r5,-8(fp)
   24f6c:	00225900 	call	22590 <memp_free>
   24f70:	00004106 	br	25078 <tcp_abandon+0x148>
  } else {
    seqno = pcb->snd_nxt;
   24f74:	e0bffe17 	ldw	r2,-8(fp)
   24f78:	10801517 	ldw	r2,84(r2)
   24f7c:	e0bffa15 	stw	r2,-24(fp)
    ackno = pcb->rcv_nxt;
   24f80:	e0bffe17 	ldw	r2,-8(fp)
   24f84:	10800b17 	ldw	r2,44(r2)
   24f88:	e0bffb15 	stw	r2,-20(fp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
   24f8c:	e0bffe17 	ldw	r2,-8(fp)
   24f90:	10802417 	ldw	r2,144(r2)
   24f94:	e0bffc15 	stw	r2,-16(fp)
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
   24f98:	e0bffe17 	ldw	r2,-8(fp)
   24f9c:	10800417 	ldw	r2,16(r2)
   24fa0:	e0bffd15 	stw	r2,-12(fp)
    TCP_PCB_REMOVE_ACTIVE(pcb);
   24fa4:	d1293604 	addi	r4,gp,-23336
   24fa8:	e17ffe17 	ldw	r5,-8(fp)
   24fac:	0026c980 	call	26c98 <tcp_pcb_remove>
   24fb0:	00800044 	movi	r2,1
   24fb4:	d0a93585 	stb	r2,-23338(gp)
    if (pcb->unacked != NULL) {
   24fb8:	e0bffe17 	ldw	r2,-8(fp)
   24fbc:	10801d17 	ldw	r2,116(r2)
   24fc0:	10000426 	beq	r2,zero,24fd4 <tcp_abandon+0xa4>
      tcp_segs_free(pcb->unacked);
   24fc4:	e0bffe17 	ldw	r2,-8(fp)
   24fc8:	10801d17 	ldw	r2,116(r2)
   24fcc:	1009883a 	mov	r4,r2
   24fd0:	00264a80 	call	264a8 <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
   24fd4:	e0bffe17 	ldw	r2,-8(fp)
   24fd8:	10801c17 	ldw	r2,112(r2)
   24fdc:	10000426 	beq	r2,zero,24ff0 <tcp_abandon+0xc0>
      tcp_segs_free(pcb->unsent);
   24fe0:	e0bffe17 	ldw	r2,-8(fp)
   24fe4:	10801c17 	ldw	r2,112(r2)
   24fe8:	1009883a 	mov	r4,r2
   24fec:	00264a80 	call	264a8 <tcp_segs_free>
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
   24ff0:	e0bffe17 	ldw	r2,-8(fp)
   24ff4:	10801e17 	ldw	r2,120(r2)
   24ff8:	10000426 	beq	r2,zero,2500c <tcp_abandon+0xdc>
      tcp_segs_free(pcb->ooseq);
   24ffc:	e0bffe17 	ldw	r2,-8(fp)
   25000:	10801e17 	ldw	r2,120(r2)
   25004:	1009883a 	mov	r4,r2
   25008:	00264a80 	call	264a8 <tcp_segs_free>
    }
#endif /* TCP_QUEUE_OOSEQ */
    if (reset) {
   2500c:	e0bfff17 	ldw	r2,-4(fp)
   25010:	10001026 	beq	r2,zero,25054 <tcp_abandon+0x124>
      LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
   25014:	e0fffe17 	ldw	r3,-8(fp)
   25018:	e0bffe17 	ldw	r2,-8(fp)
   2501c:	10800104 	addi	r2,r2,4
   25020:	e13ffe17 	ldw	r4,-8(fp)
   25024:	2100078b 	ldhu	r4,30(r4)
   25028:	217fffcc 	andi	r5,r4,65535
   2502c:	e13ffe17 	ldw	r4,-8(fp)
   25030:	2100080b 	ldhu	r4,32(r4)
   25034:	213fffcc 	andi	r4,r4,65535
   25038:	d9400015 	stw	r5,0(sp)
   2503c:	d9000115 	stw	r4,4(sp)
   25040:	e13ffa17 	ldw	r4,-24(fp)
   25044:	e17ffb17 	ldw	r5,-20(fp)
   25048:	180d883a 	mov	r6,r3
   2504c:	100f883a 	mov	r7,r2
   25050:	002da300 	call	2da30 <tcp_rst>
    }
    memp_free(MEMP_TCP_PCB, pcb);
   25054:	01000084 	movi	r4,2
   25058:	e17ffe17 	ldw	r5,-8(fp)
   2505c:	00225900 	call	22590 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
   25060:	e0bffc17 	ldw	r2,-16(fp)
   25064:	10000426 	beq	r2,zero,25078 <tcp_abandon+0x148>
   25068:	e0bffc17 	ldw	r2,-16(fp)
   2506c:	e13ffd17 	ldw	r4,-12(fp)
   25070:	017ffd84 	movi	r5,-10
   25074:	103ee83a 	callr	r2
  }
}
   25078:	e037883a 	mov	sp,fp
   2507c:	dfc00117 	ldw	ra,4(sp)
   25080:	df000017 	ldw	fp,0(sp)
   25084:	dec00204 	addi	sp,sp,8
   25088:	f800283a 	ret

0002508c <tcp_abort>:
 *
 * @param pcb the tcp pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
   2508c:	defffd04 	addi	sp,sp,-12
   25090:	dfc00215 	stw	ra,8(sp)
   25094:	df000115 	stw	fp,4(sp)
   25098:	df000104 	addi	fp,sp,4
   2509c:	e13fff15 	stw	r4,-4(fp)
  tcp_abandon(pcb, 1);
   250a0:	e13fff17 	ldw	r4,-4(fp)
   250a4:	01400044 	movi	r5,1
   250a8:	0024f300 	call	24f30 <tcp_abandon>
}
   250ac:	e037883a 	mov	sp,fp
   250b0:	dfc00117 	ldw	ra,4(sp)
   250b4:	df000017 	ldw	fp,0(sp)
   250b8:	dec00204 	addi	sp,sp,8
   250bc:	f800283a 	ret

000250c0 <tcp_bind>:
 *         ERR_VAL if bind failed because the PCB is not in a valid state
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
   250c0:	defff804 	addi	sp,sp,-32
   250c4:	dfc00715 	stw	ra,28(sp)
   250c8:	df000615 	stw	fp,24(sp)
   250cc:	df000604 	addi	fp,sp,24
   250d0:	e13ffd15 	stw	r4,-12(fp)
   250d4:	e17ffe15 	stw	r5,-8(fp)
   250d8:	3005883a 	mov	r2,r6
   250dc:	e0bfff0d 	sth	r2,-4(fp)
  int i;
  int max_pcb_list = NUM_TCP_PCB_LISTS;
   250e0:	00800104 	movi	r2,4
   250e4:	e0bffb15 	stw	r2,-20(fp)
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
   250e8:	e0bffd17 	ldw	r2,-12(fp)
   250ec:	10800617 	ldw	r2,24(r2)
   250f0:	10000926 	beq	r2,zero,25118 <tcp_bind+0x58>
   250f4:	01000134 	movhi	r4,4
   250f8:	21051f04 	addi	r4,r4,5244
   250fc:	01400134 	movhi	r5,4
   25100:	29452b04 	addi	r5,r5,5292
   25104:	01806dc4 	movi	r6,439
   25108:	01c00134 	movhi	r7,4
   2510c:	39c53504 	addi	r7,r7,5332
   25110:	00044740 	call	4474 <printf>
   25114:	003fff06 	br	25114 <tcp_bind+0x54>
  /* Unless the REUSEADDR flag is set,
     we have to check the pcbs in TIME-WAIT state, also.
     We do not dump TIME_WAIT pcb's; they can still be matched by incoming
     packets using both local and remote IP addresses and ports to distinguish.
   */
  if (ip_get_option(pcb, SOF_REUSEADDR)) {
   25118:	e0bffd17 	ldw	r2,-12(fp)
   2511c:	10800203 	ldbu	r2,8(r2)
   25120:	10803fcc 	andi	r2,r2,255
   25124:	1080010c 	andi	r2,r2,4
   25128:	10000226 	beq	r2,zero,25134 <tcp_bind+0x74>
    max_pcb_list = NUM_TCP_PCB_LISTS_NO_TIME_WAIT;
   2512c:	008000c4 	movi	r2,3
   25130:	e0bffb15 	stw	r2,-20(fp)
  }
#endif /* SO_REUSE */

  if (port == 0) {
   25134:	e0bfff0b 	ldhu	r2,-4(fp)
   25138:	1000061e 	bne	r2,zero,25154 <tcp_bind+0x94>
    port = tcp_new_port();
   2513c:	00256bc0 	call	256bc <tcp_new_port>
   25140:	e0bfff0d 	sth	r2,-4(fp)
    if (port == 0) {
   25144:	e0bfff0b 	ldhu	r2,-4(fp)
   25148:	1000021e 	bne	r2,zero,25154 <tcp_bind+0x94>
      return ERR_BUF;
   2514c:	00bfff84 	movi	r2,-2
   25150:	00004a06 	br	2527c <tcp_bind+0x1bc>
    }
  }

  /* Check if the address already is in use (on all lists) */
  for (i = 0; i < max_pcb_list; i++) {
   25154:	e03ffa15 	stw	zero,-24(fp)
   25158:	00003206 	br	25224 <tcp_bind+0x164>
    for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
   2515c:	00c00134 	movhi	r3,4
   25160:	18c51b04 	addi	r3,r3,5228
   25164:	e0bffa17 	ldw	r2,-24(fp)
   25168:	1085883a 	add	r2,r2,r2
   2516c:	1085883a 	add	r2,r2,r2
   25170:	1885883a 	add	r2,r3,r2
   25174:	10800017 	ldw	r2,0(r2)
   25178:	10800017 	ldw	r2,0(r2)
   2517c:	e0bffc15 	stw	r2,-16(fp)
   25180:	00002306 	br	25210 <tcp_bind+0x150>
      if (cpcb->local_port == port) {
   25184:	e0bffc17 	ldw	r2,-16(fp)
   25188:	1080078b 	ldhu	r2,30(r2)
   2518c:	10ffffcc 	andi	r3,r2,65535
   25190:	e0bfff0b 	ldhu	r2,-4(fp)
   25194:	18801b1e 	bne	r3,r2,25204 <tcp_bind+0x144>
#if SO_REUSE
        /* Omit checking for the same port if both pcbs have REUSEADDR set.
           For SO_REUSEADDR, the duplicate-check for a 5-tuple is done in
           tcp_connect. */
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
   25198:	e0bffd17 	ldw	r2,-12(fp)
   2519c:	10800203 	ldbu	r2,8(r2)
   251a0:	10803fcc 	andi	r2,r2,255
   251a4:	1080010c 	andi	r2,r2,4
   251a8:	10000526 	beq	r2,zero,251c0 <tcp_bind+0x100>
            !ip_get_option(cpcb, SOF_REUSEADDR))
   251ac:	e0bffc17 	ldw	r2,-16(fp)
   251b0:	10800203 	ldbu	r2,8(r2)
   251b4:	10803fcc 	andi	r2,r2,255
   251b8:	1080010c 	andi	r2,r2,4
      if (cpcb->local_port == port) {
#if SO_REUSE
        /* Omit checking for the same port if both pcbs have REUSEADDR set.
           For SO_REUSEADDR, the duplicate-check for a 5-tuple is done in
           tcp_connect. */
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
   251bc:	1000111e 	bne	r2,zero,25204 <tcp_bind+0x144>
            !ip_get_option(cpcb, SOF_REUSEADDR))
#endif /* SO_REUSE */
        {
          if (ip_addr_isany(&(cpcb->local_ip)) ||
   251c0:	e0bffc17 	ldw	r2,-16(fp)
   251c4:	10000d26 	beq	r2,zero,251fc <tcp_bind+0x13c>
   251c8:	e0bffc17 	ldw	r2,-16(fp)
   251cc:	10800017 	ldw	r2,0(r2)
   251d0:	10000a26 	beq	r2,zero,251fc <tcp_bind+0x13c>
   251d4:	e0bffe17 	ldw	r2,-8(fp)
   251d8:	10000826 	beq	r2,zero,251fc <tcp_bind+0x13c>
              ip_addr_isany(ipaddr) ||
   251dc:	e0bffe17 	ldw	r2,-8(fp)
   251e0:	10800017 	ldw	r2,0(r2)
   251e4:	10000526 	beq	r2,zero,251fc <tcp_bind+0x13c>
              ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
   251e8:	e0bffc17 	ldw	r2,-16(fp)
   251ec:	10c00017 	ldw	r3,0(r2)
   251f0:	e0bffe17 	ldw	r2,-8(fp)
   251f4:	10800017 	ldw	r2,0(r2)
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
            !ip_get_option(cpcb, SOF_REUSEADDR))
#endif /* SO_REUSE */
        {
          if (ip_addr_isany(&(cpcb->local_ip)) ||
              ip_addr_isany(ipaddr) ||
   251f8:	1880021e 	bne	r3,r2,25204 <tcp_bind+0x144>
              ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
            return ERR_USE;
   251fc:	00bffe04 	movi	r2,-8
   25200:	00001e06 	br	2527c <tcp_bind+0x1bc>
    }
  }

  /* Check if the address already is in use (on all lists) */
  for (i = 0; i < max_pcb_list; i++) {
    for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
   25204:	e0bffc17 	ldw	r2,-16(fp)
   25208:	10800317 	ldw	r2,12(r2)
   2520c:	e0bffc15 	stw	r2,-16(fp)
   25210:	e0bffc17 	ldw	r2,-16(fp)
   25214:	103fdb1e 	bne	r2,zero,25184 <tcp_bind+0xc4>
      return ERR_BUF;
    }
  }

  /* Check if the address already is in use (on all lists) */
  for (i = 0; i < max_pcb_list; i++) {
   25218:	e0bffa17 	ldw	r2,-24(fp)
   2521c:	10800044 	addi	r2,r2,1
   25220:	e0bffa15 	stw	r2,-24(fp)
   25224:	e0fffa17 	ldw	r3,-24(fp)
   25228:	e0bffb17 	ldw	r2,-20(fp)
   2522c:	18bfcb16 	blt	r3,r2,2515c <tcp_bind+0x9c>
        }
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
   25230:	e0bffe17 	ldw	r2,-8(fp)
   25234:	10000726 	beq	r2,zero,25254 <tcp_bind+0x194>
   25238:	e0bffe17 	ldw	r2,-8(fp)
   2523c:	10800017 	ldw	r2,0(r2)
   25240:	10000426 	beq	r2,zero,25254 <tcp_bind+0x194>
    pcb->local_ip = *ipaddr;
   25244:	e0bffd17 	ldw	r2,-12(fp)
   25248:	e0fffe17 	ldw	r3,-8(fp)
   2524c:	18c00017 	ldw	r3,0(r3)
   25250:	10c00015 	stw	r3,0(r2)
  }
  pcb->local_port = port;
   25254:	e0bffd17 	ldw	r2,-12(fp)
   25258:	e0ffff0b 	ldhu	r3,-4(fp)
   2525c:	10c0078d 	sth	r3,30(r2)
  TCP_REG(&tcp_bound_pcbs, pcb);
   25260:	d0e93a17 	ldw	r3,-23320(gp)
   25264:	e0bffd17 	ldw	r2,-12(fp)
   25268:	10c00315 	stw	r3,12(r2)
   2526c:	e0bffd17 	ldw	r2,-12(fp)
   25270:	d0a93a15 	stw	r2,-23320(gp)
   25274:	002e6bc0 	call	2e6bc <tcp_timer_needed>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
   25278:	0005883a 	mov	r2,zero
}
   2527c:	e037883a 	mov	sp,fp
   25280:	dfc00117 	ldw	ra,4(sp)
   25284:	df000017 	ldw	fp,0(sp)
   25288:	dec00204 	addi	sp,sp,8
   2528c:	f800283a 	ret

00025290 <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
   25290:	defffc04 	addi	sp,sp,-16
   25294:	df000315 	stw	fp,12(sp)
   25298:	df000304 	addi	fp,sp,12
   2529c:	e13ffd15 	stw	r4,-12(fp)
   252a0:	e17ffe15 	stw	r5,-8(fp)
   252a4:	3005883a 	mov	r2,r6
   252a8:	e0bfff05 	stb	r2,-4(fp)
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
   252ac:	00bffd84 	movi	r2,-10
}
   252b0:	e037883a 	mov	sp,fp
   252b4:	df000017 	ldw	fp,0(sp)
   252b8:	dec00104 	addi	sp,sp,4
   252bc:	f800283a 	ret

000252c0 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
   252c0:	defffb04 	addi	sp,sp,-20
   252c4:	dfc00415 	stw	ra,16(sp)
   252c8:	df000315 	stw	fp,12(sp)
   252cc:	df000304 	addi	fp,sp,12
   252d0:	e13ffe15 	stw	r4,-8(fp)
   252d4:	2805883a 	mov	r2,r5
   252d8:	e0bfff05 	stb	r2,-4(fp)
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
   252dc:	e0bffe17 	ldw	r2,-8(fp)
   252e0:	10800617 	ldw	r2,24(r2)
   252e4:	10000926 	beq	r2,zero,2530c <tcp_listen_with_backlog+0x4c>
   252e8:	01000134 	movhi	r4,4
   252ec:	21051f04 	addi	r4,r4,5244
   252f0:	01400134 	movhi	r5,4
   252f4:	29453a04 	addi	r5,r5,5352
   252f8:	01808304 	movi	r6,524
   252fc:	01c00134 	movhi	r7,4
   25300:	39c53504 	addi	r7,r7,5332
   25304:	00044740 	call	4474 <printf>
   25308:	003fff06 	br	25308 <tcp_listen_with_backlog+0x48>

  /* already listening? */
  if (pcb->state == LISTEN) {
   2530c:	e0bffe17 	ldw	r2,-8(fp)
   25310:	10800617 	ldw	r2,24(r2)
   25314:	10800058 	cmpnei	r2,r2,1
   25318:	1000021e 	bne	r2,zero,25324 <tcp_listen_with_backlog+0x64>
    return pcb;
   2531c:	e0bffe17 	ldw	r2,-8(fp)
   25320:	00007c06 	br	25514 <tcp_listen_with_backlog+0x254>
  }
#if SO_REUSE
  if (ip_get_option(pcb, SOF_REUSEADDR)) {
   25324:	e0bffe17 	ldw	r2,-8(fp)
   25328:	10800203 	ldbu	r2,8(r2)
   2532c:	10803fcc 	andi	r2,r2,255
   25330:	1080010c 	andi	r2,r2,4
   25334:	10001626 	beq	r2,zero,25390 <tcp_listen_with_backlog+0xd0>
    /* Since SOF_REUSEADDR allows reusing a local address before the pcb's usage
       is declared (listen-/connection-pcb), we have to make sure now that
       this port is only used once for every local IP. */
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
   25338:	d0a93817 	ldw	r2,-23328(gp)
   2533c:	e0bffd15 	stw	r2,-12(fp)
   25340:	00001106 	br	25388 <tcp_listen_with_backlog+0xc8>
      if (lpcb->local_port == pcb->local_port) {
   25344:	e0bffd17 	ldw	r2,-12(fp)
   25348:	10c0078b 	ldhu	r3,30(r2)
   2534c:	e0bffe17 	ldw	r2,-8(fp)
   25350:	1080078b 	ldhu	r2,30(r2)
   25354:	18ffffcc 	andi	r3,r3,65535
   25358:	10bfffcc 	andi	r2,r2,65535
   2535c:	1880071e 	bne	r3,r2,2537c <tcp_listen_with_backlog+0xbc>
        if (ip_addr_cmp(&lpcb->local_ip, &pcb->local_ip)) {
   25360:	e0bffd17 	ldw	r2,-12(fp)
   25364:	10c00017 	ldw	r3,0(r2)
   25368:	e0bffe17 	ldw	r2,-8(fp)
   2536c:	10800017 	ldw	r2,0(r2)
   25370:	1880021e 	bne	r3,r2,2537c <tcp_listen_with_backlog+0xbc>
          /* this address/port is already used */
          return NULL;
   25374:	0005883a 	mov	r2,zero
   25378:	00006606 	br	25514 <tcp_listen_with_backlog+0x254>
#if SO_REUSE
  if (ip_get_option(pcb, SOF_REUSEADDR)) {
    /* Since SOF_REUSEADDR allows reusing a local address before the pcb's usage
       is declared (listen-/connection-pcb), we have to make sure now that
       this port is only used once for every local IP. */
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
   2537c:	e0bffd17 	ldw	r2,-12(fp)
   25380:	10800317 	ldw	r2,12(r2)
   25384:	e0bffd15 	stw	r2,-12(fp)
   25388:	e0bffd17 	ldw	r2,-12(fp)
   2538c:	103fed1e 	bne	r2,zero,25344 <tcp_listen_with_backlog+0x84>
        }
      }
    }
  }
#endif /* SO_REUSE */
  lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
   25390:	010000c4 	movi	r4,3
   25394:	00223cc0 	call	223cc <memp_malloc>
   25398:	e0bffd15 	stw	r2,-12(fp)
  if (lpcb == NULL) {
   2539c:	e0bffd17 	ldw	r2,-12(fp)
   253a0:	1000021e 	bne	r2,zero,253ac <tcp_listen_with_backlog+0xec>
    return NULL;
   253a4:	0005883a 	mov	r2,zero
   253a8:	00005a06 	br	25514 <tcp_listen_with_backlog+0x254>
  }
  lpcb->callback_arg = pcb->callback_arg;
   253ac:	e0bffe17 	ldw	r2,-8(fp)
   253b0:	10c00417 	ldw	r3,16(r2)
   253b4:	e0bffd17 	ldw	r2,-12(fp)
   253b8:	10c00415 	stw	r3,16(r2)
  lpcb->local_port = pcb->local_port;
   253bc:	e0bffe17 	ldw	r2,-8(fp)
   253c0:	10c0078b 	ldhu	r3,30(r2)
   253c4:	e0bffd17 	ldw	r2,-12(fp)
   253c8:	10c0078d 	sth	r3,30(r2)
  lpcb->state = LISTEN;
   253cc:	e0bffd17 	ldw	r2,-12(fp)
   253d0:	00c00044 	movi	r3,1
   253d4:	10c00615 	stw	r3,24(r2)
  lpcb->prio = pcb->prio;
   253d8:	e0bffe17 	ldw	r2,-8(fp)
   253dc:	10c00703 	ldbu	r3,28(r2)
   253e0:	e0bffd17 	ldw	r2,-12(fp)
   253e4:	10c00705 	stb	r3,28(r2)
  lpcb->so_options = pcb->so_options;
   253e8:	e0bffe17 	ldw	r2,-8(fp)
   253ec:	10c00203 	ldbu	r3,8(r2)
   253f0:	e0bffd17 	ldw	r2,-12(fp)
   253f4:	10c00205 	stb	r3,8(r2)
  ip_set_option(lpcb, SOF_ACCEPTCONN);
   253f8:	e0bffd17 	ldw	r2,-12(fp)
   253fc:	10800203 	ldbu	r2,8(r2)
   25400:	10800094 	ori	r2,r2,2
   25404:	1007883a 	mov	r3,r2
   25408:	e0bffd17 	ldw	r2,-12(fp)
   2540c:	10c00205 	stb	r3,8(r2)
  lpcb->ttl = pcb->ttl;
   25410:	e0bffe17 	ldw	r2,-8(fp)
   25414:	10c00283 	ldbu	r3,10(r2)
   25418:	e0bffd17 	ldw	r2,-12(fp)
   2541c:	10c00285 	stb	r3,10(r2)
  lpcb->tos = pcb->tos;
   25420:	e0bffe17 	ldw	r2,-8(fp)
   25424:	10c00243 	ldbu	r3,9(r2)
   25428:	e0bffd17 	ldw	r2,-12(fp)
   2542c:	10c00245 	stb	r3,9(r2)
  ip_addr_copy(lpcb->local_ip, pcb->local_ip);
   25430:	e0bffe17 	ldw	r2,-8(fp)
   25434:	10c00017 	ldw	r3,0(r2)
   25438:	e0bffd17 	ldw	r2,-12(fp)
   2543c:	10c00015 	stw	r3,0(r2)
  if (pcb->local_port != 0) {
   25440:	e0bffe17 	ldw	r2,-8(fp)
   25444:	1080078b 	ldhu	r2,30(r2)
   25448:	10bfffcc 	andi	r2,r2,65535
   2544c:	10001a26 	beq	r2,zero,254b8 <tcp_listen_with_backlog+0x1f8>
    TCP_RMV(&tcp_bound_pcbs, pcb);
   25450:	d0e93a17 	ldw	r3,-23320(gp)
   25454:	e0bffe17 	ldw	r2,-8(fp)
   25458:	1880041e 	bne	r3,r2,2546c <tcp_listen_with_backlog+0x1ac>
   2545c:	d0a93a17 	ldw	r2,-23320(gp)
   25460:	10800317 	ldw	r2,12(r2)
   25464:	d0a93a15 	stw	r2,-23320(gp)
   25468:	00001106 	br	254b0 <tcp_listen_with_backlog+0x1f0>
   2546c:	d0a93a17 	ldw	r2,-23320(gp)
   25470:	d0a93915 	stw	r2,-23324(gp)
   25474:	00000c06 	br	254a8 <tcp_listen_with_backlog+0x1e8>
   25478:	d0a93917 	ldw	r2,-23324(gp)
   2547c:	10c00317 	ldw	r3,12(r2)
   25480:	e0bffe17 	ldw	r2,-8(fp)
   25484:	1880051e 	bne	r3,r2,2549c <tcp_listen_with_backlog+0x1dc>
   25488:	d0a93917 	ldw	r2,-23324(gp)
   2548c:	e0fffe17 	ldw	r3,-8(fp)
   25490:	18c00317 	ldw	r3,12(r3)
   25494:	10c00315 	stw	r3,12(r2)
   25498:	00000506 	br	254b0 <tcp_listen_with_backlog+0x1f0>
   2549c:	d0a93917 	ldw	r2,-23324(gp)
   254a0:	10800317 	ldw	r2,12(r2)
   254a4:	d0a93915 	stw	r2,-23324(gp)
   254a8:	d0a93917 	ldw	r2,-23324(gp)
   254ac:	103ff21e 	bne	r2,zero,25478 <tcp_listen_with_backlog+0x1b8>
   254b0:	e0bffe17 	ldw	r2,-8(fp)
   254b4:	10000315 	stw	zero,12(r2)
  }
  memp_free(MEMP_TCP_PCB, pcb);
   254b8:	01000084 	movi	r4,2
   254bc:	e17ffe17 	ldw	r5,-8(fp)
   254c0:	00225900 	call	22590 <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
   254c4:	e0bffd17 	ldw	r2,-12(fp)
   254c8:	00c000b4 	movhi	r3,2
   254cc:	18d4a404 	addi	r3,r3,21136
   254d0:	10c00515 	stw	r3,20(r2)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
   254d4:	e0bffd17 	ldw	r2,-12(fp)
   254d8:	10000845 	stb	zero,33(r2)
  lpcb->backlog = (backlog ? backlog : 1);
   254dc:	e0bfff03 	ldbu	r2,-4(fp)
   254e0:	10000226 	beq	r2,zero,254ec <tcp_listen_with_backlog+0x22c>
   254e4:	e0bfff03 	ldbu	r2,-4(fp)
   254e8:	00000106 	br	254f0 <tcp_listen_with_backlog+0x230>
   254ec:	00800044 	movi	r2,1
   254f0:	e0fffd17 	ldw	r3,-12(fp)
   254f4:	18800805 	stb	r2,32(r3)
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
   254f8:	d0e93817 	ldw	r3,-23328(gp)
   254fc:	e0bffd17 	ldw	r2,-12(fp)
   25500:	10c00315 	stw	r3,12(r2)
   25504:	e0bffd17 	ldw	r2,-12(fp)
   25508:	d0a93815 	stw	r2,-23328(gp)
   2550c:	002e6bc0 	call	2e6bc <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
   25510:	e0bffd17 	ldw	r2,-12(fp)
}
   25514:	e037883a 	mov	sp,fp
   25518:	dfc00117 	ldw	ra,4(sp)
   2551c:	df000017 	ldw	fp,0(sp)
   25520:	dec00204 	addi	sp,sp,8
   25524:	f800283a 	ret

00025528 <tcp_update_rcv_ann_wnd>:
 *
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
   25528:	defffc04 	addi	sp,sp,-16
   2552c:	df000315 	stw	fp,12(sp)
   25530:	df000304 	addi	fp,sp,12
   25534:	e13fff15 	stw	r4,-4(fp)
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
   25538:	e0bfff17 	ldw	r2,-4(fp)
   2553c:	10c00b17 	ldw	r3,44(r2)
   25540:	e0bfff17 	ldw	r2,-4(fp)
   25544:	10800c0b 	ldhu	r2,48(r2)
   25548:	10bfffcc 	andi	r2,r2,65535
   2554c:	1885883a 	add	r2,r3,r2
   25550:	e0bffd15 	stw	r2,-12(fp)

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
   25554:	e0bfff17 	ldw	r2,-4(fp)
   25558:	10c00d17 	ldw	r3,52(r2)
   2555c:	e0bfff17 	ldw	r2,-4(fp)
   25560:	10800e8b 	ldhu	r2,58(r2)
   25564:	10bfffcc 	andi	r2,r2,65535
   25568:	10840068 	cmpgeui	r2,r2,4097
   2556c:	1000041e 	bne	r2,zero,25580 <tcp_update_rcv_ann_wnd+0x58>
   25570:	e0bfff17 	ldw	r2,-4(fp)
   25574:	10800e8b 	ldhu	r2,58(r2)
   25578:	10bfffcc 	andi	r2,r2,65535
   2557c:	00000106 	br	25584 <tcp_update_rcv_ann_wnd+0x5c>
   25580:	00840004 	movi	r2,4096
   25584:	1885883a 	add	r2,r3,r2
   25588:	e0fffd17 	ldw	r3,-12(fp)
   2558c:	1885c83a 	sub	r2,r3,r2
   25590:	10000916 	blt	r2,zero,255b8 <tcp_update_rcv_ann_wnd+0x90>
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
   25594:	e0bfff17 	ldw	r2,-4(fp)
   25598:	10c00c0b 	ldhu	r3,48(r2)
   2559c:	e0bfff17 	ldw	r2,-4(fp)
   255a0:	10c00c8d 	sth	r3,50(r2)
    return new_right_edge - pcb->rcv_ann_right_edge;
   255a4:	e0bfff17 	ldw	r2,-4(fp)
   255a8:	10800d17 	ldw	r2,52(r2)
   255ac:	e0fffd17 	ldw	r3,-12(fp)
   255b0:	1885c83a 	sub	r2,r3,r2
   255b4:	00001406 	br	25608 <tcp_update_rcv_ann_wnd+0xe0>
  } else {
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
   255b8:	e0bfff17 	ldw	r2,-4(fp)
   255bc:	10c00b17 	ldw	r3,44(r2)
   255c0:	e0bfff17 	ldw	r2,-4(fp)
   255c4:	10800d17 	ldw	r2,52(r2)
   255c8:	1885c83a 	sub	r2,r3,r2
   255cc:	0080030e 	bge	zero,r2,255dc <tcp_update_rcv_ann_wnd+0xb4>
      /* Can happen due to other end sending out of advertised window,
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
   255d0:	e0bfff17 	ldw	r2,-4(fp)
   255d4:	10000c8d 	sth	zero,50(r2)
   255d8:	00000a06 	br	25604 <tcp_update_rcv_ann_wnd+0xdc>
    } else {
      /* keep the right edge of window constant */
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
   255dc:	e0bfff17 	ldw	r2,-4(fp)
   255e0:	10c00d17 	ldw	r3,52(r2)
   255e4:	e0bfff17 	ldw	r2,-4(fp)
   255e8:	10800b17 	ldw	r2,44(r2)
   255ec:	1885c83a 	sub	r2,r3,r2
   255f0:	e0bffe15 	stw	r2,-8(fp)
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
      pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
   255f4:	e0bffe17 	ldw	r2,-8(fp)
   255f8:	1007883a 	mov	r3,r2
   255fc:	e0bfff17 	ldw	r2,-4(fp)
   25600:	10c00c8d 	sth	r3,50(r2)
    }
    return 0;
   25604:	0005883a 	mov	r2,zero
  }
}
   25608:	e037883a 	mov	sp,fp
   2560c:	df000017 	ldw	fp,0(sp)
   25610:	dec00104 	addi	sp,sp,4
   25614:	f800283a 	ret

00025618 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
   25618:	defffb04 	addi	sp,sp,-20
   2561c:	dfc00415 	stw	ra,16(sp)
   25620:	df000315 	stw	fp,12(sp)
   25624:	df000304 	addi	fp,sp,12
   25628:	e13ffe15 	stw	r4,-8(fp)
   2562c:	2805883a 	mov	r2,r5
   25630:	e0bfff0d 	sth	r2,-4(fp)
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
    pcb->state != LISTEN);
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
   25634:	e0bffe17 	ldw	r2,-8(fp)
   25638:	10c00c0b 	ldhu	r3,48(r2)
   2563c:	e0bfff0b 	ldhu	r2,-4(fp)
   25640:	1885883a 	add	r2,r3,r2
   25644:	1007883a 	mov	r3,r2
   25648:	e0bffe17 	ldw	r2,-8(fp)
   2564c:	10c00c0d 	sth	r3,48(r2)
  if (pcb->rcv_wnd > TCP_WND) {
   25650:	e0bffe17 	ldw	r2,-8(fp)
   25654:	10800c0b 	ldhu	r2,48(r2)
   25658:	10bfffcc 	andi	r2,r2,65535
   2565c:	10880070 	cmpltui	r2,r2,8193
   25660:	1000031e 	bne	r2,zero,25670 <tcp_recved+0x58>
    pcb->rcv_wnd = TCP_WND;
   25664:	e0bffe17 	ldw	r2,-8(fp)
   25668:	00c80004 	movi	r3,8192
   2566c:	10c00c0d 	sth	r3,48(r2)
  }

  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
   25670:	e13ffe17 	ldw	r4,-8(fp)
   25674:	00255280 	call	25528 <tcp_update_rcv_ann_wnd>
   25678:	e0bffd15 	stw	r2,-12(fp)

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
   2567c:	e0bffd17 	ldw	r2,-12(fp)
   25680:	10820010 	cmplti	r2,r2,2048
   25684:	1000081e 	bne	r2,zero,256a8 <tcp_recved+0x90>
    tcp_ack_now(pcb);
   25688:	e0bffe17 	ldw	r2,-8(fp)
   2568c:	10800883 	ldbu	r2,34(r2)
   25690:	10800094 	ori	r2,r2,2
   25694:	1007883a 	mov	r3,r2
   25698:	e0bffe17 	ldw	r2,-8(fp)
   2569c:	10c00885 	stb	r3,34(r2)
    tcp_output(pcb);
   256a0:	e13ffe17 	ldw	r4,-8(fp)
   256a4:	002c9d00 	call	2c9d0 <tcp_output>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
   256a8:	e037883a 	mov	sp,fp
   256ac:	dfc00117 	ldw	ra,4(sp)
   256b0:	df000017 	ldw	fp,0(sp)
   256b4:	dec00204 	addi	sp,sp,8
   256b8:	f800283a 	ret

000256bc <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
   256bc:	defffd04 	addi	sp,sp,-12
   256c0:	df000215 	stw	fp,8(sp)
   256c4:	df000204 	addi	fp,sp,8
  u8_t i;
  u16_t n = 0;
   256c8:	e03ffe8d 	sth	zero,-6(fp)
   256cc:	00000106 	br	256d4 <tcp_new_port+0x18>
    for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
      if (pcb->local_port == tcp_port) {
        if (++n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
          return 0;
        }
        goto again;
   256d0:	0001883a 	nop
  u8_t i;
  u16_t n = 0;
  struct tcp_pcb *pcb;
  
again:
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
   256d4:	d0a0110b 	ldhu	r2,-32700(gp)
   256d8:	113fffcc 	andi	r4,r2,65535
   256dc:	00ffffd4 	movui	r3,65535
   256e0:	20c7003a 	cmpeq	r3,r4,r3
   256e4:	10800044 	addi	r2,r2,1
   256e8:	d0a0110d 	sth	r2,-32700(gp)
   256ec:	18803fcc 	andi	r2,r3,255
   256f0:	10000226 	beq	r2,zero,256fc <tcp_new_port+0x40>
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
   256f4:	00b00004 	movi	r2,-16384
   256f8:	d0a0110d 	sth	r2,-32700(gp)
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
   256fc:	e03ffe05 	stb	zero,-8(fp)
   25700:	00002006 	br	25784 <tcp_new_port+0xc8>
    for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
   25704:	e0bffe03 	ldbu	r2,-8(fp)
   25708:	00c00134 	movhi	r3,4
   2570c:	18c51b04 	addi	r3,r3,5228
   25710:	1085883a 	add	r2,r2,r2
   25714:	1085883a 	add	r2,r2,r2
   25718:	1885883a 	add	r2,r3,r2
   2571c:	10800017 	ldw	r2,0(r2)
   25720:	10800017 	ldw	r2,0(r2)
   25724:	e0bfff15 	stw	r2,-4(fp)
   25728:	00001106 	br	25770 <tcp_new_port+0xb4>
      if (pcb->local_port == tcp_port) {
   2572c:	e0bfff17 	ldw	r2,-4(fp)
   25730:	10c0078b 	ldhu	r3,30(r2)
   25734:	d0a0110b 	ldhu	r2,-32700(gp)
   25738:	18ffffcc 	andi	r3,r3,65535
   2573c:	10bfffcc 	andi	r2,r2,65535
   25740:	1880081e 	bne	r3,r2,25764 <tcp_new_port+0xa8>
        if (++n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
   25744:	e0bffe8b 	ldhu	r2,-6(fp)
   25748:	10800044 	addi	r2,r2,1
   2574c:	e0bffe8d 	sth	r2,-6(fp)
   25750:	e0bffe8b 	ldhu	r2,-6(fp)
   25754:	10900030 	cmpltui	r2,r2,16384
   25758:	103fdd1e 	bne	r2,zero,256d0 <tcp_new_port+0x14>
          return 0;
   2575c:	0005883a 	mov	r2,zero
   25760:	00000c06 	br	25794 <tcp_new_port+0xd8>
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
    for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
   25764:	e0bfff17 	ldw	r2,-4(fp)
   25768:	10800317 	ldw	r2,12(r2)
   2576c:	e0bfff15 	stw	r2,-4(fp)
   25770:	e0bfff17 	ldw	r2,-4(fp)
   25774:	103fed1e 	bne	r2,zero,2572c <tcp_new_port+0x70>
again:
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
   25778:	e0bffe03 	ldbu	r2,-8(fp)
   2577c:	10800044 	addi	r2,r2,1
   25780:	e0bffe05 	stb	r2,-8(fp)
   25784:	e0bffe03 	ldbu	r2,-8(fp)
   25788:	10800130 	cmpltui	r2,r2,4
   2578c:	103fdd1e 	bne	r2,zero,25704 <tcp_new_port+0x48>
        }
        goto again;
      }
    }
  }
  return tcp_port;
   25790:	d0a0110b 	ldhu	r2,-32700(gp)
}
   25794:	e037883a 	mov	sp,fp
   25798:	df000017 	ldw	fp,0(sp)
   2579c:	dec00104 	addi	sp,sp,4
   257a0:	f800283a 	ret

000257a4 <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port,
      tcp_connected_fn connected)
{
   257a4:	defff404 	addi	sp,sp,-48
   257a8:	dfc00b15 	stw	ra,44(sp)
   257ac:	df000a15 	stw	fp,40(sp)
   257b0:	df000a04 	addi	fp,sp,40
   257b4:	e13ffc15 	stw	r4,-16(fp)
   257b8:	e17ffd15 	stw	r5,-12(fp)
   257bc:	3005883a 	mov	r2,r6
   257c0:	e1ffff15 	stw	r7,-4(fp)
   257c4:	e0bffe0d 	sth	r2,-8(fp)
  err_t ret;
  u32_t iss;
  u16_t old_local_port;

  LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
   257c8:	e0bffc17 	ldw	r2,-16(fp)
   257cc:	10800617 	ldw	r2,24(r2)
   257d0:	10000926 	beq	r2,zero,257f8 <tcp_connect+0x54>
   257d4:	01000134 	movhi	r4,4
   257d8:	21051f04 	addi	r4,r4,5244
   257dc:	01400134 	movhi	r5,4
   257e0:	29454304 	addi	r5,r5,5388
   257e4:	0180acc4 	movi	r6,691
   257e8:	01c00134 	movhi	r7,4
   257ec:	39c53504 	addi	r7,r7,5332
   257f0:	00044740 	call	4474 <printf>
   257f4:	003fff06 	br	257f4 <tcp_connect+0x50>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
   257f8:	e0bffd17 	ldw	r2,-12(fp)
   257fc:	10000a26 	beq	r2,zero,25828 <tcp_connect+0x84>
    pcb->remote_ip = *ipaddr;
   25800:	e0bffc17 	ldw	r2,-16(fp)
   25804:	e0fffd17 	ldw	r3,-12(fp)
   25808:	18c00017 	ldw	r3,0(r3)
   2580c:	10c00115 	stw	r3,4(r2)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
   25810:	e0bffc17 	ldw	r2,-16(fp)
   25814:	e0fffe0b 	ldhu	r3,-8(fp)
   25818:	10c0080d 	sth	r3,32(r2)

  /* check if we have a route to the remote host */
  if (ip_addr_isany(&(pcb->local_ip))) {
   2581c:	e0bffc17 	ldw	r2,-16(fp)
   25820:	10000626 	beq	r2,zero,2583c <tcp_connect+0x98>
   25824:	00000206 	br	25830 <tcp_connect+0x8c>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
  } else {
    return ERR_VAL;
   25828:	00bffe84 	movi	r2,-6
   2582c:	0000bc06 	br	25b20 <tcp_connect+0x37c>
  }
  pcb->remote_port = port;

  /* check if we have a route to the remote host */
  if (ip_addr_isany(&(pcb->local_ip))) {
   25830:	e0bffc17 	ldw	r2,-16(fp)
   25834:	10800017 	ldw	r2,0(r2)
   25838:	10000f1e 	bne	r2,zero,25878 <tcp_connect+0xd4>
    /* no local IP address set, yet. */
    struct netif *netif = ip_route(&(pcb->local_ip), &(pcb->remote_ip));
   2583c:	e0fffc17 	ldw	r3,-16(fp)
   25840:	e0bffc17 	ldw	r2,-16(fp)
   25844:	10800104 	addi	r2,r2,4
   25848:	1809883a 	mov	r4,r3
   2584c:	100b883a 	mov	r5,r2
   25850:	001ecb40 	call	1ecb4 <ip_route>
   25854:	e0bff815 	stw	r2,-32(fp)
    if (netif == NULL) {
   25858:	e0bff817 	ldw	r2,-32(fp)
   2585c:	1000021e 	bne	r2,zero,25868 <tcp_connect+0xc4>
      /* Don't even try to send a SYN packet if we have no route
         since that will fail. */
      return ERR_RTE;
   25860:	00bfff04 	movi	r2,-4
   25864:	0000ae06 	br	25b20 <tcp_connect+0x37c>
    }
    /* Use the netif's IP address as local address. */
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
   25868:	e0bff817 	ldw	r2,-32(fp)
   2586c:	10c00117 	ldw	r3,4(r2)
   25870:	e0bffc17 	ldw	r2,-16(fp)
   25874:	10c00015 	stw	r3,0(r2)
  }

  old_local_port = pcb->local_port;
   25878:	e0bffc17 	ldw	r2,-16(fp)
   2587c:	1080078b 	ldhu	r2,30(r2)
   25880:	e0bff90d 	sth	r2,-28(fp)
  if (pcb->local_port == 0) {
   25884:	e0bffc17 	ldw	r2,-16(fp)
   25888:	1080078b 	ldhu	r2,30(r2)
   2588c:	10bfffcc 	andi	r2,r2,65535
   25890:	1000091e 	bne	r2,zero,258b8 <tcp_connect+0x114>
    pcb->local_port = tcp_new_port();
   25894:	00256bc0 	call	256bc <tcp_new_port>
   25898:	e0fffc17 	ldw	r3,-16(fp)
   2589c:	1880078d 	sth	r2,30(r3)
    if (pcb->local_port == 0) {
   258a0:	e0bffc17 	ldw	r2,-16(fp)
   258a4:	1080078b 	ldhu	r2,30(r2)
   258a8:	10bfffcc 	andi	r2,r2,65535
   258ac:	1000021e 	bne	r2,zero,258b8 <tcp_connect+0x114>
      return ERR_BUF;
   258b0:	00bfff84 	movi	r2,-2
   258b4:	00009a06 	br	25b20 <tcp_connect+0x37c>
    }
  }
#if SO_REUSE
  if (ip_get_option(pcb, SOF_REUSEADDR)) {
   258b8:	e0bffc17 	ldw	r2,-16(fp)
   258bc:	10800203 	ldbu	r2,8(r2)
   258c0:	10803fcc 	andi	r2,r2,255
   258c4:	1080010c 	andi	r2,r2,4
   258c8:	10003026 	beq	r2,zero,2598c <tcp_connect+0x1e8>
    /* Since SOF_REUSEADDR allows reusing a local address, we have to make sure
       now that the 5-tuple is unique. */
    struct tcp_pcb *cpcb;
    int i;
    /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
    for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
   258cc:	00800084 	movi	r2,2
   258d0:	e0bff715 	stw	r2,-36(fp)
   258d4:	00002a06 	br	25980 <tcp_connect+0x1dc>
      for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
   258d8:	00c00134 	movhi	r3,4
   258dc:	18c51b04 	addi	r3,r3,5228
   258e0:	e0bff717 	ldw	r2,-36(fp)
   258e4:	1085883a 	add	r2,r2,r2
   258e8:	1085883a 	add	r2,r2,r2
   258ec:	1885883a 	add	r2,r3,r2
   258f0:	10800017 	ldw	r2,0(r2)
   258f4:	10800017 	ldw	r2,0(r2)
   258f8:	e0bff615 	stw	r2,-40(fp)
   258fc:	00001b06 	br	2596c <tcp_connect+0x1c8>
        if ((cpcb->local_port == pcb->local_port) &&
   25900:	e0bff617 	ldw	r2,-40(fp)
   25904:	10c0078b 	ldhu	r3,30(r2)
   25908:	e0bffc17 	ldw	r2,-16(fp)
   2590c:	1080078b 	ldhu	r2,30(r2)
   25910:	18ffffcc 	andi	r3,r3,65535
   25914:	10bfffcc 	andi	r2,r2,65535
   25918:	1880111e 	bne	r3,r2,25960 <tcp_connect+0x1bc>
            (cpcb->remote_port == port) &&
   2591c:	e0bff617 	ldw	r2,-40(fp)
   25920:	1080080b 	ldhu	r2,32(r2)
    struct tcp_pcb *cpcb;
    int i;
    /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
    for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
      for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
        if ((cpcb->local_port == pcb->local_port) &&
   25924:	10ffffcc 	andi	r3,r2,65535
   25928:	e0bffe0b 	ldhu	r2,-8(fp)
   2592c:	18800c1e 	bne	r3,r2,25960 <tcp_connect+0x1bc>
            (cpcb->remote_port == port) &&
            ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
   25930:	e0bff617 	ldw	r2,-40(fp)
   25934:	10c00017 	ldw	r3,0(r2)
   25938:	e0bffc17 	ldw	r2,-16(fp)
   2593c:	10800017 	ldw	r2,0(r2)
    int i;
    /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
    for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
      for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
        if ((cpcb->local_port == pcb->local_port) &&
            (cpcb->remote_port == port) &&
   25940:	1880071e 	bne	r3,r2,25960 <tcp_connect+0x1bc>
            ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
            ip_addr_cmp(&cpcb->remote_ip, ipaddr)) {
   25944:	e0bff617 	ldw	r2,-40(fp)
   25948:	10c00117 	ldw	r3,4(r2)
   2594c:	e0bffd17 	ldw	r2,-12(fp)
   25950:	10800017 	ldw	r2,0(r2)
    /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
    for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
      for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
        if ((cpcb->local_port == pcb->local_port) &&
            (cpcb->remote_port == port) &&
            ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
   25954:	1880021e 	bne	r3,r2,25960 <tcp_connect+0x1bc>
            ip_addr_cmp(&cpcb->remote_ip, ipaddr)) {
          /* linux returns EISCONN here, but ERR_USE should be OK for us */
          return ERR_USE;
   25958:	00bffe04 	movi	r2,-8
   2595c:	00007006 	br	25b20 <tcp_connect+0x37c>
       now that the 5-tuple is unique. */
    struct tcp_pcb *cpcb;
    int i;
    /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
    for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
      for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
   25960:	e0bff617 	ldw	r2,-40(fp)
   25964:	10800317 	ldw	r2,12(r2)
   25968:	e0bff615 	stw	r2,-40(fp)
   2596c:	e0bff617 	ldw	r2,-40(fp)
   25970:	103fe31e 	bne	r2,zero,25900 <tcp_connect+0x15c>
    /* Since SOF_REUSEADDR allows reusing a local address, we have to make sure
       now that the 5-tuple is unique. */
    struct tcp_pcb *cpcb;
    int i;
    /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
    for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
   25974:	e0bff717 	ldw	r2,-36(fp)
   25978:	10800044 	addi	r2,r2,1
   2597c:	e0bff715 	stw	r2,-36(fp)
   25980:	e0bff717 	ldw	r2,-36(fp)
   25984:	10800110 	cmplti	r2,r2,4
   25988:	103fd31e 	bne	r2,zero,258d8 <tcp_connect+0x134>
        }
      }
    }
  }
#endif /* SO_REUSE */
  iss = tcp_next_iss();
   2598c:	0026da00 	call	26da0 <tcp_next_iss>
   25990:	e0bffa15 	stw	r2,-24(fp)
  pcb->rcv_nxt = 0;
   25994:	e0bffc17 	ldw	r2,-16(fp)
   25998:	10000b15 	stw	zero,44(r2)
  pcb->snd_nxt = iss;
   2599c:	e0bffc17 	ldw	r2,-16(fp)
   259a0:	e0fffa17 	ldw	r3,-24(fp)
   259a4:	10c01515 	stw	r3,84(r2)
  pcb->lastack = iss - 1;
   259a8:	e0bffa17 	ldw	r2,-24(fp)
   259ac:	10ffffc4 	addi	r3,r2,-1
   259b0:	e0bffc17 	ldw	r2,-16(fp)
   259b4:	10c01315 	stw	r3,76(r2)
  pcb->snd_lbb = iss - 1;
   259b8:	e0bffa17 	ldw	r2,-24(fp)
   259bc:	10ffffc4 	addi	r3,r2,-1
   259c0:	e0bffc17 	ldw	r2,-16(fp)
   259c4:	10c01815 	stw	r3,96(r2)
  pcb->rcv_wnd = TCP_WND;
   259c8:	e0bffc17 	ldw	r2,-16(fp)
   259cc:	00c80004 	movi	r3,8192
   259d0:	10c00c0d 	sth	r3,48(r2)
  pcb->rcv_ann_wnd = TCP_WND;
   259d4:	e0bffc17 	ldw	r2,-16(fp)
   259d8:	00c80004 	movi	r3,8192
   259dc:	10c00c8d 	sth	r3,50(r2)
  pcb->rcv_ann_right_edge = pcb->rcv_nxt;
   259e0:	e0bffc17 	ldw	r2,-16(fp)
   259e4:	10c00b17 	ldw	r3,44(r2)
   259e8:	e0bffc17 	ldw	r2,-16(fp)
   259ec:	10c00d15 	stw	r3,52(r2)
  pcb->snd_wnd = TCP_WND;
   259f0:	e0bffc17 	ldw	r2,-16(fp)
   259f4:	00c80004 	movi	r3,8192
   259f8:	10c0190d 	sth	r3,100(r2)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
   259fc:	e0bffc17 	ldw	r2,-16(fp)
   25a00:	00c08604 	movi	r3,536
   25a04:	10c00e8d 	sth	r3,58(r2)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->local_ip), ipaddr);
   25a08:	e0bffc17 	ldw	r2,-16(fp)
   25a0c:	10800e8b 	ldhu	r2,58(r2)
   25a10:	10ffffcc 	andi	r3,r2,65535
   25a14:	e0bffc17 	ldw	r2,-16(fp)
   25a18:	1809883a 	mov	r4,r3
   25a1c:	100b883a 	mov	r5,r2
   25a20:	e1bffd17 	ldw	r6,-12(fp)
   25a24:	0026dd00 	call	26dd0 <tcp_eff_send_mss>
   25a28:	e0fffc17 	ldw	r3,-16(fp)
   25a2c:	18800e8d 	sth	r2,58(r3)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
   25a30:	e0bffc17 	ldw	r2,-16(fp)
   25a34:	00c00044 	movi	r3,1
   25a38:	10c0140d 	sth	r3,80(r2)
  pcb->ssthresh = pcb->mss * 10;
   25a3c:	e0bffc17 	ldw	r2,-16(fp)
   25a40:	10800e8b 	ldhu	r2,58(r2)
   25a44:	108002a4 	muli	r2,r2,10
   25a48:	1007883a 	mov	r3,r2
   25a4c:	e0bffc17 	ldw	r2,-16(fp)
   25a50:	10c0148d 	sth	r3,82(r2)
#if LWIP_CALLBACK_API
  pcb->connected = connected;
   25a54:	e0bffc17 	ldw	r2,-16(fp)
   25a58:	e0ffff17 	ldw	r3,-4(fp)
   25a5c:	10c02215 	stw	r3,136(r2)
#else /* LWIP_CALLBACK_API */  
  LWIP_UNUSED_ARG(connected);
#endif /* LWIP_CALLBACK_API */

  /* Send a SYN together with the MSS option. */
  ret = tcp_enqueue_flags(pcb, TCP_SYN);
   25a60:	e13ffc17 	ldw	r4,-16(fp)
   25a64:	01400084 	movi	r5,2
   25a68:	002c55c0 	call	2c55c <tcp_enqueue_flags>
   25a6c:	e0bffb05 	stb	r2,-20(fp)
  if (ret == ERR_OK) {
   25a70:	e0bffb07 	ldb	r2,-20(fp)
   25a74:	1000291e 	bne	r2,zero,25b1c <tcp_connect+0x378>
    /* SYN segment was enqueued, changed the pcbs state now */
    pcb->state = SYN_SENT;
   25a78:	e0bffc17 	ldw	r2,-16(fp)
   25a7c:	00c00084 	movi	r3,2
   25a80:	10c00615 	stw	r3,24(r2)
    if (old_local_port != 0) {
   25a84:	e0bff90b 	ldhu	r2,-28(fp)
   25a88:	10001a26 	beq	r2,zero,25af4 <tcp_connect+0x350>
      TCP_RMV(&tcp_bound_pcbs, pcb);
   25a8c:	d0e93a17 	ldw	r3,-23320(gp)
   25a90:	e0bffc17 	ldw	r2,-16(fp)
   25a94:	1880041e 	bne	r3,r2,25aa8 <tcp_connect+0x304>
   25a98:	d0a93a17 	ldw	r2,-23320(gp)
   25a9c:	10800317 	ldw	r2,12(r2)
   25aa0:	d0a93a15 	stw	r2,-23320(gp)
   25aa4:	00001106 	br	25aec <tcp_connect+0x348>
   25aa8:	d0a93a17 	ldw	r2,-23320(gp)
   25aac:	d0a93915 	stw	r2,-23324(gp)
   25ab0:	00000c06 	br	25ae4 <tcp_connect+0x340>
   25ab4:	d0a93917 	ldw	r2,-23324(gp)
   25ab8:	10c00317 	ldw	r3,12(r2)
   25abc:	e0bffc17 	ldw	r2,-16(fp)
   25ac0:	1880051e 	bne	r3,r2,25ad8 <tcp_connect+0x334>
   25ac4:	d0a93917 	ldw	r2,-23324(gp)
   25ac8:	e0fffc17 	ldw	r3,-16(fp)
   25acc:	18c00317 	ldw	r3,12(r3)
   25ad0:	10c00315 	stw	r3,12(r2)
   25ad4:	00000506 	br	25aec <tcp_connect+0x348>
   25ad8:	d0a93917 	ldw	r2,-23324(gp)
   25adc:	10800317 	ldw	r2,12(r2)
   25ae0:	d0a93915 	stw	r2,-23324(gp)
   25ae4:	d0a93917 	ldw	r2,-23324(gp)
   25ae8:	103ff21e 	bne	r2,zero,25ab4 <tcp_connect+0x310>
   25aec:	e0bffc17 	ldw	r2,-16(fp)
   25af0:	10000315 	stw	zero,12(r2)
    }
    TCP_REG_ACTIVE(pcb);
   25af4:	d0e93617 	ldw	r3,-23336(gp)
   25af8:	e0bffc17 	ldw	r2,-16(fp)
   25afc:	10c00315 	stw	r3,12(r2)
   25b00:	e0bffc17 	ldw	r2,-16(fp)
   25b04:	d0a93615 	stw	r2,-23336(gp)
   25b08:	002e6bc0 	call	2e6bc <tcp_timer_needed>
   25b0c:	00800044 	movi	r2,1
   25b10:	d0a93585 	stb	r2,-23338(gp)
    snmp_inc_tcpactiveopens();

    tcp_output(pcb);
   25b14:	e13ffc17 	ldw	r4,-16(fp)
   25b18:	002c9d00 	call	2c9d0 <tcp_output>
  }
  return ret;
   25b1c:	e0bffb03 	ldbu	r2,-20(fp)
}
   25b20:	e037883a 	mov	sp,fp
   25b24:	dfc00117 	ldw	ra,4(sp)
   25b28:	df000017 	ldw	fp,0(sp)
   25b2c:	dec00204 	addi	sp,sp,8
   25b30:	f800283a 	ret

00025b34 <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
   25b34:	defff404 	addi	sp,sp,-48
   25b38:	dfc00b15 	stw	ra,44(sp)
   25b3c:	df000a15 	stw	fp,40(sp)
   25b40:	df000a04 	addi	fp,sp,40
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;
   25b44:	e03ffa85 	stb	zero,-22(fp)

  ++tcp_ticks;
   25b48:	d0a93717 	ldw	r2,-23332(gp)
   25b4c:	10800044 	addi	r2,r2,1
   25b50:	d0a93715 	stw	r2,-23332(gp)
  ++tcp_timer_ctr;
   25b54:	d0a93543 	ldbu	r2,-23339(gp)
   25b58:	10800044 	addi	r2,r2,1
   25b5c:	d0a93545 	stb	r2,-23339(gp)
   25b60:	00000106 	br	25b68 <tcp_slowtmr+0x34>
        prev->polltmr = 0;
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        tcp_active_pcbs_changed = 0;
        TCP_EVENT_POLL(prev, err);
        if (tcp_active_pcbs_changed) {
          goto tcp_slowtmr_start;
   25b64:	0001883a 	nop
  ++tcp_ticks;
  ++tcp_timer_ctr;

tcp_slowtmr_start:
  /* Steps through all of the active PCBs. */
  prev = NULL;
   25b68:	e03ff915 	stw	zero,-28(fp)
  pcb = tcp_active_pcbs;
   25b6c:	d0a93617 	ldw	r2,-23336(gp)
   25b70:	e0bff815 	stw	r2,-32(fp)
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
   25b74:	00018706 	br	26194 <tcp_slowtmr+0x660>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
    if (pcb->last_timer == tcp_timer_ctr) {
   25b78:	e0bff817 	ldw	r2,-32(fp)
   25b7c:	10c00943 	ldbu	r3,37(r2)
   25b80:	d0a93543 	ldbu	r2,-23339(gp)
   25b84:	18c03fcc 	andi	r3,r3,255
   25b88:	10803fcc 	andi	r2,r2,255
   25b8c:	1880041e 	bne	r3,r2,25ba0 <tcp_slowtmr+0x6c>
      /* skip this pcb, we have already processed it */
      pcb = pcb->next;
   25b90:	e0bff817 	ldw	r2,-32(fp)
   25b94:	10800317 	ldw	r2,12(r2)
   25b98:	e0bff815 	stw	r2,-32(fp)
      continue;
   25b9c:	00017d06 	br	26194 <tcp_slowtmr+0x660>
    }
    pcb->last_timer = tcp_timer_ctr;
   25ba0:	d0e93543 	ldbu	r3,-23339(gp)
   25ba4:	e0bff817 	ldw	r2,-32(fp)
   25ba8:	10c00945 	stb	r3,37(r2)

    pcb_remove = 0;
   25bac:	e03ffa05 	stb	zero,-24(fp)
    pcb_reset = 0;
   25bb0:	e03ffa45 	stb	zero,-23(fp)

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
   25bb4:	e0bff817 	ldw	r2,-32(fp)
   25bb8:	10800617 	ldw	r2,24(r2)
   25bbc:	10800098 	cmpnei	r2,r2,2
   25bc0:	1000091e 	bne	r2,zero,25be8 <tcp_slowtmr+0xb4>
   25bc4:	e0bff817 	ldw	r2,-32(fp)
   25bc8:	10801283 	ldbu	r2,74(r2)
   25bcc:	10803fcc 	andi	r2,r2,255
   25bd0:	10800198 	cmpnei	r2,r2,6
   25bd4:	1000041e 	bne	r2,zero,25be8 <tcp_slowtmr+0xb4>
      ++pcb_remove;
   25bd8:	e0bffa03 	ldbu	r2,-24(fp)
   25bdc:	10800044 	addi	r2,r2,1
   25be0:	e0bffa05 	stb	r2,-24(fp)
   25be4:	00008c06 	br	25e18 <tcp_slowtmr+0x2e4>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
   25be8:	e0bff817 	ldw	r2,-32(fp)
   25bec:	10801283 	ldbu	r2,74(r2)
   25bf0:	10803fcc 	andi	r2,r2,255
   25bf4:	10800318 	cmpnei	r2,r2,12
   25bf8:	1000041e 	bne	r2,zero,25c0c <tcp_slowtmr+0xd8>
      ++pcb_remove;
   25bfc:	e0bffa03 	ldbu	r2,-24(fp)
   25c00:	10800044 	addi	r2,r2,1
   25c04:	e0bffa05 	stb	r2,-24(fp)
   25c08:	00008306 	br	25e18 <tcp_slowtmr+0x2e4>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
   25c0c:	e0bff817 	ldw	r2,-32(fp)
   25c10:	10802843 	ldbu	r2,161(r2)
   25c14:	10803fcc 	andi	r2,r2,255
   25c18:	10002226 	beq	r2,zero,25ca4 <tcp_slowtmr+0x170>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
   25c1c:	e0bff817 	ldw	r2,-32(fp)
   25c20:	10802803 	ldbu	r2,160(r2)
   25c24:	10800044 	addi	r2,r2,1
   25c28:	1007883a 	mov	r3,r2
   25c2c:	e0bff817 	ldw	r2,-32(fp)
   25c30:	10c02805 	stb	r3,160(r2)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
   25c34:	e0bff817 	ldw	r2,-32(fp)
   25c38:	10c02803 	ldbu	r3,160(r2)
   25c3c:	e0bff817 	ldw	r2,-32(fp)
   25c40:	10802843 	ldbu	r2,161(r2)
   25c44:	10803fcc 	andi	r2,r2,255
   25c48:	113fffc4 	addi	r4,r2,-1
   25c4c:	d0a01184 	addi	r2,gp,-32698
   25c50:	2085883a 	add	r2,r4,r2
   25c54:	10800003 	ldbu	r2,0(r2)
   25c58:	18c03fcc 	andi	r3,r3,255
   25c5c:	10803fcc 	andi	r2,r2,255
   25c60:	18806d36 	bltu	r3,r2,25e18 <tcp_slowtmr+0x2e4>
          pcb->persist_cnt = 0;
   25c64:	e0bff817 	ldw	r2,-32(fp)
   25c68:	10002805 	stb	zero,160(r2)
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
   25c6c:	e0bff817 	ldw	r2,-32(fp)
   25c70:	10802843 	ldbu	r2,161(r2)
   25c74:	10803fcc 	andi	r2,r2,255
   25c78:	108001e8 	cmpgeui	r2,r2,7
   25c7c:	1000061e 	bne	r2,zero,25c98 <tcp_slowtmr+0x164>
            pcb->persist_backoff++;
   25c80:	e0bff817 	ldw	r2,-32(fp)
   25c84:	10802843 	ldbu	r2,161(r2)
   25c88:	10800044 	addi	r2,r2,1
   25c8c:	1007883a 	mov	r3,r2
   25c90:	e0bff817 	ldw	r2,-32(fp)
   25c94:	10c02845 	stb	r3,161(r2)
          }
          tcp_zero_window_probe(pcb);
   25c98:	e13ff817 	ldw	r4,-32(fp)
   25c9c:	002e38c0 	call	2e38c <tcp_zero_window_probe>
   25ca0:	00005d06 	br	25e18 <tcp_slowtmr+0x2e4>
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0) {
   25ca4:	e0bff817 	ldw	r2,-32(fp)
   25ca8:	10800e0b 	ldhu	r2,56(r2)
   25cac:	10bfffcc 	andi	r2,r2,65535
   25cb0:	10a0001c 	xori	r2,r2,32768
   25cb4:	10a00004 	addi	r2,r2,-32768
   25cb8:	10000616 	blt	r2,zero,25cd4 <tcp_slowtmr+0x1a0>
          ++pcb->rtime;
   25cbc:	e0bff817 	ldw	r2,-32(fp)
   25cc0:	10800e0b 	ldhu	r2,56(r2)
   25cc4:	10800044 	addi	r2,r2,1
   25cc8:	1007883a 	mov	r3,r2
   25ccc:	e0bff817 	ldw	r2,-32(fp)
   25cd0:	10c00e0d 	sth	r3,56(r2)
        }

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
   25cd4:	e0bff817 	ldw	r2,-32(fp)
   25cd8:	10801d17 	ldw	r2,116(r2)
   25cdc:	10004e26 	beq	r2,zero,25e18 <tcp_slowtmr+0x2e4>
   25ce0:	e0bff817 	ldw	r2,-32(fp)
   25ce4:	10c00e0b 	ldhu	r3,56(r2)
   25ce8:	e0bff817 	ldw	r2,-32(fp)
   25cec:	1080120b 	ldhu	r2,72(r2)
   25cf0:	18ffffcc 	andi	r3,r3,65535
   25cf4:	18e0001c 	xori	r3,r3,32768
   25cf8:	18e00004 	addi	r3,r3,-32768
   25cfc:	10bfffcc 	andi	r2,r2,65535
   25d00:	10a0001c 	xori	r2,r2,32768
   25d04:	10a00004 	addi	r2,r2,-32768
   25d08:	18804316 	blt	r3,r2,25e18 <tcp_slowtmr+0x2e4>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
   25d0c:	e0bff817 	ldw	r2,-32(fp)
   25d10:	10800617 	ldw	r2,24(r2)
   25d14:	108000a0 	cmpeqi	r2,r2,2
   25d18:	10001b1e 	bne	r2,zero,25d88 <tcp_slowtmr+0x254>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
   25d1c:	e0bff817 	ldw	r2,-32(fp)
   25d20:	1080110b 	ldhu	r2,68(r2)
   25d24:	10bfffcc 	andi	r2,r2,65535
   25d28:	10a0001c 	xori	r2,r2,32768
   25d2c:	10a00004 	addi	r2,r2,-32768
   25d30:	1005d0fa 	srai	r2,r2,3
   25d34:	10ffffcc 	andi	r3,r2,65535
   25d38:	18e0001c 	xori	r3,r3,32768
   25d3c:	18e00004 	addi	r3,r3,-32768
   25d40:	e0bff817 	ldw	r2,-32(fp)
   25d44:	1080118b 	ldhu	r2,70(r2)
   25d48:	10bfffcc 	andi	r2,r2,65535
   25d4c:	10a0001c 	xori	r2,r2,32768
   25d50:	10a00004 	addi	r2,r2,-32768
   25d54:	1887883a 	add	r3,r3,r2
   25d58:	e0bff817 	ldw	r2,-32(fp)
   25d5c:	10801283 	ldbu	r2,74(r2)
   25d60:	10803fcc 	andi	r2,r2,255
   25d64:	01000134 	movhi	r4,4
   25d68:	21051704 	addi	r4,r4,5212
   25d6c:	2085883a 	add	r2,r4,r2
   25d70:	10800003 	ldbu	r2,0(r2)
   25d74:	10803fcc 	andi	r2,r2,255
   25d78:	1884983a 	sll	r2,r3,r2
   25d7c:	1007883a 	mov	r3,r2
   25d80:	e0bff817 	ldw	r2,-32(fp)
   25d84:	10c0120d 	sth	r3,72(r2)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
   25d88:	e0bff817 	ldw	r2,-32(fp)
   25d8c:	10000e0d 	sth	zero,56(r2)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
   25d90:	e0bff817 	ldw	r2,-32(fp)
   25d94:	1080190b 	ldhu	r2,100(r2)
   25d98:	e0fff817 	ldw	r3,-32(fp)
   25d9c:	18c0140b 	ldhu	r3,80(r3)
   25da0:	113fffcc 	andi	r4,r2,65535
   25da4:	197fffcc 	andi	r5,r3,65535
   25da8:	2900012e 	bgeu	r5,r4,25db0 <tcp_slowtmr+0x27c>
   25dac:	1805883a 	mov	r2,r3
   25db0:	e0bffb0d 	sth	r2,-20(fp)
          pcb->ssthresh = eff_wnd >> 1;
   25db4:	e0bffb0b 	ldhu	r2,-20(fp)
   25db8:	1004d07a 	srli	r2,r2,1
   25dbc:	1007883a 	mov	r3,r2
   25dc0:	e0bff817 	ldw	r2,-32(fp)
   25dc4:	10c0148d 	sth	r3,82(r2)
          if (pcb->ssthresh < (pcb->mss << 1)) {
   25dc8:	e0bff817 	ldw	r2,-32(fp)
   25dcc:	1080148b 	ldhu	r2,82(r2)
   25dd0:	10ffffcc 	andi	r3,r2,65535
   25dd4:	e0bff817 	ldw	r2,-32(fp)
   25dd8:	10800e8b 	ldhu	r2,58(r2)
   25ddc:	10bfffcc 	andi	r2,r2,65535
   25de0:	1085883a 	add	r2,r2,r2
   25de4:	1880060e 	bge	r3,r2,25e00 <tcp_slowtmr+0x2cc>
            pcb->ssthresh = (pcb->mss << 1);
   25de8:	e0bff817 	ldw	r2,-32(fp)
   25dec:	10800e8b 	ldhu	r2,58(r2)
   25df0:	1085883a 	add	r2,r2,r2
   25df4:	1007883a 	mov	r3,r2
   25df8:	e0bff817 	ldw	r2,-32(fp)
   25dfc:	10c0148d 	sth	r3,82(r2)
          }
          pcb->cwnd = pcb->mss;
   25e00:	e0bff817 	ldw	r2,-32(fp)
   25e04:	10c00e8b 	ldhu	r3,58(r2)
   25e08:	e0bff817 	ldw	r2,-32(fp)
   25e0c:	10c0140d 	sth	r3,80(r2)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
   25e10:	e13ff817 	ldw	r4,-32(fp)
   25e14:	002dd8c0 	call	2dd8c <tcp_rexmit_rto>
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
   25e18:	e0bff817 	ldw	r2,-32(fp)
   25e1c:	10800617 	ldw	r2,24(r2)
   25e20:	10800198 	cmpnei	r2,r2,6
   25e24:	10000e1e 	bne	r2,zero,25e60 <tcp_slowtmr+0x32c>
      /* If this PCB is in FIN_WAIT_2 because of SHUT_WR don't let it time out. */
      if (pcb->flags & TF_RXCLOSED) {
   25e28:	e0bff817 	ldw	r2,-32(fp)
   25e2c:	10800883 	ldbu	r2,34(r2)
   25e30:	10803fcc 	andi	r2,r2,255
   25e34:	1080040c 	andi	r2,r2,16
   25e38:	10000926 	beq	r2,zero,25e60 <tcp_slowtmr+0x32c>
        /* PCB was fully closed (either through close() or SHUT_RDWR):
           normal FIN-WAIT timeout handling. */
        if ((u32_t)(tcp_ticks - pcb->tmr) >
   25e3c:	d0e93717 	ldw	r3,-23332(gp)
   25e40:	e0bff817 	ldw	r2,-32(fp)
   25e44:	10800a17 	ldw	r2,40(r2)
   25e48:	1885c83a 	sub	r2,r3,r2
   25e4c:	10800a70 	cmpltui	r2,r2,41
   25e50:	1000031e 	bne	r2,zero,25e60 <tcp_slowtmr+0x32c>
            TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
          ++pcb_remove;
   25e54:	e0bffa03 	ldbu	r2,-24(fp)
   25e58:	10800044 	addi	r2,r2,1
   25e5c:	e0bffa05 	stb	r2,-24(fp)
        }
      }
    }

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
   25e60:	e0bff817 	ldw	r2,-32(fp)
   25e64:	10800203 	ldbu	r2,8(r2)
   25e68:	10803fcc 	andi	r2,r2,255
   25e6c:	1080020c 	andi	r2,r2,8
   25e70:	10003626 	beq	r2,zero,25f4c <tcp_slowtmr+0x418>
       ((pcb->state == ESTABLISHED) ||
   25e74:	e0bff817 	ldw	r2,-32(fp)
   25e78:	10800617 	ldw	r2,24(r2)
        }
      }
    }

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
   25e7c:	10800120 	cmpeqi	r2,r2,4
   25e80:	1000041e 	bne	r2,zero,25e94 <tcp_slowtmr+0x360>
       ((pcb->state == ESTABLISHED) ||
        (pcb->state == CLOSE_WAIT))) {
   25e84:	e0bff817 	ldw	r2,-32(fp)
   25e88:	10800617 	ldw	r2,24(r2)
      }
    }

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
       ((pcb->state == ESTABLISHED) ||
   25e8c:	108001d8 	cmpnei	r2,r2,7
   25e90:	10002e1e 	bne	r2,zero,25f4c <tcp_slowtmr+0x418>
        (pcb->state == CLOSE_WAIT))) {
      if((u32_t)(tcp_ticks - pcb->tmr) >
   25e94:	d0e93717 	ldw	r3,-23332(gp)
   25e98:	e0bff817 	ldw	r2,-32(fp)
   25e9c:	10800a17 	ldw	r2,40(r2)
   25ea0:	1885c83a 	sub	r2,r3,r2
         (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
   25ea4:	e0fff817 	ldw	r3,-32(fp)
   25ea8:	19002517 	ldw	r4,148(r3)
   25eac:	e0fff817 	ldw	r3,-32(fp)
   25eb0:	19402717 	ldw	r5,156(r3)
   25eb4:	e0fff817 	ldw	r3,-32(fp)
   25eb8:	18c02617 	ldw	r3,152(r3)
   25ebc:	28c7383a 	mul	r3,r5,r3
   25ec0:	20c9883a 	add	r4,r4,r3
   25ec4:	00c07d04 	movi	r3,500
   25ec8:	20c7203a 	divu	r3,r4,r3

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
       ((pcb->state == ESTABLISHED) ||
        (pcb->state == CLOSE_WAIT))) {
      if((u32_t)(tcp_ticks - pcb->tmr) >
   25ecc:	1880072e 	bgeu	r3,r2,25eec <tcp_slowtmr+0x3b8>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                                ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
        
        ++pcb_remove;
   25ed0:	e0bffa03 	ldbu	r2,-24(fp)
   25ed4:	10800044 	addi	r2,r2,1
   25ed8:	e0bffa05 	stb	r2,-24(fp)
        ++pcb_reset;
   25edc:	e0bffa43 	ldbu	r2,-23(fp)
   25ee0:	10800044 	addi	r2,r2,1
   25ee4:	e0bffa45 	stb	r2,-23(fp)
   25ee8:	00001806 	br	25f4c <tcp_slowtmr+0x418>
      }
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
   25eec:	d0e93717 	ldw	r3,-23332(gp)
   25ef0:	e0bff817 	ldw	r2,-32(fp)
   25ef4:	10800a17 	ldw	r2,40(r2)
   25ef8:	1885c83a 	sub	r2,r3,r2
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
   25efc:	e0fff817 	ldw	r3,-32(fp)
   25f00:	19002517 	ldw	r4,148(r3)
   25f04:	e0fff817 	ldw	r3,-32(fp)
   25f08:	18c02883 	ldbu	r3,162(r3)
   25f0c:	19403fcc 	andi	r5,r3,255
   25f10:	e0fff817 	ldw	r3,-32(fp)
   25f14:	18c02617 	ldw	r3,152(r3)
   25f18:	28c7383a 	mul	r3,r5,r3
   25f1c:	20c9883a 	add	r4,r4,r3
              / TCP_SLOW_INTERVAL)
   25f20:	00c07d04 	movi	r3,500
   25f24:	20c7203a 	divu	r3,r4,r3
                                ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
        
        ++pcb_remove;
        ++pcb_reset;
      }
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
   25f28:	1880082e 	bgeu	r3,r2,25f4c <tcp_slowtmr+0x418>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
              / TCP_SLOW_INTERVAL)
      {
        tcp_keepalive(pcb);
   25f2c:	e13ff817 	ldw	r4,-32(fp)
   25f30:	002e20c0 	call	2e20c <tcp_keepalive>
        pcb->keep_cnt_sent++;
   25f34:	e0bff817 	ldw	r2,-32(fp)
   25f38:	10802883 	ldbu	r2,162(r2)
   25f3c:	10800044 	addi	r2,r2,1
   25f40:	1007883a 	mov	r3,r2
   25f44:	e0bff817 	ldw	r2,-32(fp)
   25f48:	10c02885 	stb	r3,162(r2)

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL &&
   25f4c:	e0bff817 	ldw	r2,-32(fp)
   25f50:	10801e17 	ldw	r2,120(r2)
   25f54:	10001126 	beq	r2,zero,25f9c <tcp_slowtmr+0x468>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
   25f58:	d0e93717 	ldw	r3,-23332(gp)
   25f5c:	e0bff817 	ldw	r2,-32(fp)
   25f60:	10800a17 	ldw	r2,40(r2)
   25f64:	1887c83a 	sub	r3,r3,r2
   25f68:	e0bff817 	ldw	r2,-32(fp)
   25f6c:	1080120b 	ldhu	r2,72(r2)
   25f70:	10bfffcc 	andi	r2,r2,65535
   25f74:	10a0001c 	xori	r2,r2,32768
   25f78:	10a00004 	addi	r2,r2,-32768
   25f7c:	108001a4 	muli	r2,r2,6

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL &&
   25f80:	18800636 	bltu	r3,r2,25f9c <tcp_slowtmr+0x468>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
   25f84:	e0bff817 	ldw	r2,-32(fp)
   25f88:	10801e17 	ldw	r2,120(r2)
   25f8c:	1009883a 	mov	r4,r2
   25f90:	00264a80 	call	264a8 <tcp_segs_free>
      pcb->ooseq = NULL;
   25f94:	e0bff817 	ldw	r2,-32(fp)
   25f98:	10001e15 	stw	zero,120(r2)
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
   25f9c:	e0bff817 	ldw	r2,-32(fp)
   25fa0:	10800617 	ldw	r2,24(r2)
   25fa4:	108000d8 	cmpnei	r2,r2,3
   25fa8:	1000091e 	bne	r2,zero,25fd0 <tcp_slowtmr+0x49c>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
   25fac:	d0e93717 	ldw	r3,-23332(gp)
   25fb0:	e0bff817 	ldw	r2,-32(fp)
   25fb4:	10800a17 	ldw	r2,40(r2)
   25fb8:	1885c83a 	sub	r2,r3,r2
   25fbc:	10800a70 	cmpltui	r2,r2,41
   25fc0:	1000031e 	bne	r2,zero,25fd0 <tcp_slowtmr+0x49c>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
   25fc4:	e0bffa03 	ldbu	r2,-24(fp)
   25fc8:	10800044 	addi	r2,r2,1
   25fcc:	e0bffa05 	stb	r2,-24(fp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
   25fd0:	e0bff817 	ldw	r2,-32(fp)
   25fd4:	10800617 	ldw	r2,24(r2)
   25fd8:	10800258 	cmpnei	r2,r2,9
   25fdc:	1000091e 	bne	r2,zero,26004 <tcp_slowtmr+0x4d0>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
   25fe0:	d0e93717 	ldw	r3,-23332(gp)
   25fe4:	e0bff817 	ldw	r2,-32(fp)
   25fe8:	10800a17 	ldw	r2,40(r2)
   25fec:	1885c83a 	sub	r2,r3,r2
   25ff0:	10803c70 	cmpltui	r2,r2,241
   25ff4:	1000031e 	bne	r2,zero,26004 <tcp_slowtmr+0x4d0>
        ++pcb_remove;
   25ff8:	e0bffa03 	ldbu	r2,-24(fp)
   25ffc:	10800044 	addi	r2,r2,1
   26000:	e0bffa05 	stb	r2,-24(fp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
   26004:	e0bffa03 	ldbu	r2,-24(fp)
   26008:	10003926 	beq	r2,zero,260f0 <tcp_slowtmr+0x5bc>
      struct tcp_pcb *pcb2;
      tcp_err_fn err_fn;
      void *err_arg;
      tcp_pcb_purge(pcb);
   2600c:	e13ff817 	ldw	r4,-32(fp)
   26010:	0026b2c0 	call	26b2c <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
   26014:	e0bff917 	ldw	r2,-28(fp)
   26018:	10000526 	beq	r2,zero,26030 <tcp_slowtmr+0x4fc>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
        prev->next = pcb->next;
   2601c:	e0bff817 	ldw	r2,-32(fp)
   26020:	10c00317 	ldw	r3,12(r2)
   26024:	e0bff917 	ldw	r2,-28(fp)
   26028:	10c00315 	stw	r3,12(r2)
   2602c:	00000306 	br	2603c <tcp_slowtmr+0x508>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
   26030:	e0bff817 	ldw	r2,-32(fp)
   26034:	10800317 	ldw	r2,12(r2)
   26038:	d0a93615 	stw	r2,-23336(gp)
      }

      if (pcb_reset) {
   2603c:	e0bffa43 	ldbu	r2,-23(fp)
   26040:	10001226 	beq	r2,zero,2608c <tcp_slowtmr+0x558>
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
   26044:	e0bff817 	ldw	r2,-32(fp)
   26048:	11001517 	ldw	r4,84(r2)
   2604c:	e0bff817 	ldw	r2,-32(fp)
   26050:	11400b17 	ldw	r5,44(r2)
   26054:	e0fff817 	ldw	r3,-32(fp)
   26058:	e0bff817 	ldw	r2,-32(fp)
   2605c:	10800104 	addi	r2,r2,4
          pcb->local_port, pcb->remote_port);
   26060:	e1bff817 	ldw	r6,-32(fp)
   26064:	3180078b 	ldhu	r6,30(r6)
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
      }

      if (pcb_reset) {
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
   26068:	31ffffcc 	andi	r7,r6,65535
          pcb->local_port, pcb->remote_port);
   2606c:	e1bff817 	ldw	r6,-32(fp)
   26070:	3180080b 	ldhu	r6,32(r6)
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
      }

      if (pcb_reset) {
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
   26074:	31bfffcc 	andi	r6,r6,65535
   26078:	d9c00015 	stw	r7,0(sp)
   2607c:	d9800115 	stw	r6,4(sp)
   26080:	180d883a 	mov	r6,r3
   26084:	100f883a 	mov	r7,r2
   26088:	002da300 	call	2da30 <tcp_rst>
          pcb->local_port, pcb->remote_port);
      }

      err_fn = pcb->errf;
   2608c:	e0bff817 	ldw	r2,-32(fp)
   26090:	10802417 	ldw	r2,144(r2)
   26094:	e0bffc15 	stw	r2,-16(fp)
      err_arg = pcb->callback_arg;
   26098:	e0bff817 	ldw	r2,-32(fp)
   2609c:	10800417 	ldw	r2,16(r2)
   260a0:	e0bffd15 	stw	r2,-12(fp)
      pcb2 = pcb;
   260a4:	e0bff817 	ldw	r2,-32(fp)
   260a8:	e0bffe15 	stw	r2,-8(fp)
      pcb = pcb->next;
   260ac:	e0bff817 	ldw	r2,-32(fp)
   260b0:	10800317 	ldw	r2,12(r2)
   260b4:	e0bff815 	stw	r2,-32(fp)
      memp_free(MEMP_TCP_PCB, pcb2);
   260b8:	01000084 	movi	r4,2
   260bc:	e17ffe17 	ldw	r5,-8(fp)
   260c0:	00225900 	call	22590 <memp_free>

      tcp_active_pcbs_changed = 0;
   260c4:	d0293585 	stb	zero,-23338(gp)
      TCP_EVENT_ERR(err_fn, err_arg, ERR_ABRT);
   260c8:	e0bffc17 	ldw	r2,-16(fp)
   260cc:	10000426 	beq	r2,zero,260e0 <tcp_slowtmr+0x5ac>
   260d0:	e0bffc17 	ldw	r2,-16(fp)
   260d4:	e13ffd17 	ldw	r4,-12(fp)
   260d8:	017ffd84 	movi	r5,-10
   260dc:	103ee83a 	callr	r2
      if (tcp_active_pcbs_changed) {
   260e0:	d0a93583 	ldbu	r2,-23338(gp)
   260e4:	10803fcc 	andi	r2,r2,255
   260e8:	10002a26 	beq	r2,zero,26194 <tcp_slowtmr+0x660>
        goto tcp_slowtmr_start;
   260ec:	003e9e06 	br	25b68 <tcp_slowtmr+0x34>
      }
    } else {
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
   260f0:	e0bff817 	ldw	r2,-32(fp)
   260f4:	e0bff915 	stw	r2,-28(fp)
      pcb = pcb->next;
   260f8:	e0bff817 	ldw	r2,-32(fp)
   260fc:	10800317 	ldw	r2,12(r2)
   26100:	e0bff815 	stw	r2,-32(fp)

      /* We check if we should poll the connection. */
      ++prev->polltmr;
   26104:	e0bff917 	ldw	r2,-28(fp)
   26108:	108008c3 	ldbu	r2,35(r2)
   2610c:	10800044 	addi	r2,r2,1
   26110:	1007883a 	mov	r3,r2
   26114:	e0bff917 	ldw	r2,-28(fp)
   26118:	10c008c5 	stb	r3,35(r2)
      if (prev->polltmr >= prev->pollinterval) {
   2611c:	e0bff917 	ldw	r2,-28(fp)
   26120:	10c008c3 	ldbu	r3,35(r2)
   26124:	e0bff917 	ldw	r2,-28(fp)
   26128:	10800903 	ldbu	r2,36(r2)
   2612c:	18c03fcc 	andi	r3,r3,255
   26130:	10803fcc 	andi	r2,r2,255
   26134:	18801736 	bltu	r3,r2,26194 <tcp_slowtmr+0x660>
        prev->polltmr = 0;
   26138:	e0bff917 	ldw	r2,-28(fp)
   2613c:	100008c5 	stb	zero,35(r2)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        tcp_active_pcbs_changed = 0;
   26140:	d0293585 	stb	zero,-23338(gp)
        TCP_EVENT_POLL(prev, err);
   26144:	e0bff917 	ldw	r2,-28(fp)
   26148:	10802317 	ldw	r2,140(r2)
   2614c:	10000926 	beq	r2,zero,26174 <tcp_slowtmr+0x640>
   26150:	e0bff917 	ldw	r2,-28(fp)
   26154:	10c02317 	ldw	r3,140(r2)
   26158:	e0bff917 	ldw	r2,-28(fp)
   2615c:	10800417 	ldw	r2,16(r2)
   26160:	1009883a 	mov	r4,r2
   26164:	e17ff917 	ldw	r5,-28(fp)
   26168:	183ee83a 	callr	r3
   2616c:	e0bffa85 	stb	r2,-22(fp)
   26170:	00000106 	br	26178 <tcp_slowtmr+0x644>
   26174:	e03ffa85 	stb	zero,-22(fp)
        if (tcp_active_pcbs_changed) {
   26178:	d0a93583 	ldbu	r2,-23338(gp)
   2617c:	10803fcc 	andi	r2,r2,255
   26180:	103e781e 	bne	r2,zero,25b64 <tcp_slowtmr+0x30>
          goto tcp_slowtmr_start;
        }
        /* if err == ERR_ABRT, 'prev' is already deallocated */
        if (err == ERR_OK) {
   26184:	e0bffa87 	ldb	r2,-22(fp)
   26188:	1000021e 	bne	r2,zero,26194 <tcp_slowtmr+0x660>
          tcp_output(prev);
   2618c:	e13ff917 	ldw	r4,-28(fp)
   26190:	002c9d00 	call	2c9d0 <tcp_output>
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
   26194:	e0bff817 	ldw	r2,-32(fp)
   26198:	103e771e 	bne	r2,zero,25b78 <tcp_slowtmr+0x44>
    }
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
   2619c:	e03ff915 	stw	zero,-28(fp)
  pcb = tcp_tw_pcbs;
   261a0:	d0a93b17 	ldw	r2,-23316(gp)
   261a4:	e0bff815 	stw	r2,-32(fp)
  while (pcb != NULL) {
   261a8:	00002606 	br	26244 <tcp_slowtmr+0x710>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
    pcb_remove = 0;
   261ac:	e03ffa05 	stb	zero,-24(fp)

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
   261b0:	d0e93717 	ldw	r3,-23332(gp)
   261b4:	e0bff817 	ldw	r2,-32(fp)
   261b8:	10800a17 	ldw	r2,40(r2)
   261bc:	1885c83a 	sub	r2,r3,r2
   261c0:	10803c70 	cmpltui	r2,r2,241
   261c4:	1000031e 	bne	r2,zero,261d4 <tcp_slowtmr+0x6a0>
      ++pcb_remove;
   261c8:	e0bffa03 	ldbu	r2,-24(fp)
   261cc:	10800044 	addi	r2,r2,1
   261d0:	e0bffa05 	stb	r2,-24(fp)
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
   261d4:	e0bffa03 	ldbu	r2,-24(fp)
   261d8:	10001526 	beq	r2,zero,26230 <tcp_slowtmr+0x6fc>
      struct tcp_pcb *pcb2;
      tcp_pcb_purge(pcb);
   261dc:	e13ff817 	ldw	r4,-32(fp)
   261e0:	0026b2c0 	call	26b2c <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
   261e4:	e0bff917 	ldw	r2,-28(fp)
   261e8:	10000526 	beq	r2,zero,26200 <tcp_slowtmr+0x6cc>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
        prev->next = pcb->next;
   261ec:	e0bff817 	ldw	r2,-32(fp)
   261f0:	10c00317 	ldw	r3,12(r2)
   261f4:	e0bff917 	ldw	r2,-28(fp)
   261f8:	10c00315 	stw	r3,12(r2)
   261fc:	00000306 	br	2620c <tcp_slowtmr+0x6d8>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
        tcp_tw_pcbs = pcb->next;
   26200:	e0bff817 	ldw	r2,-32(fp)
   26204:	10800317 	ldw	r2,12(r2)
   26208:	d0a93b15 	stw	r2,-23316(gp)
      }
      pcb2 = pcb;
   2620c:	e0bff817 	ldw	r2,-32(fp)
   26210:	e0bfff15 	stw	r2,-4(fp)
      pcb = pcb->next;
   26214:	e0bff817 	ldw	r2,-32(fp)
   26218:	10800317 	ldw	r2,12(r2)
   2621c:	e0bff815 	stw	r2,-32(fp)
      memp_free(MEMP_TCP_PCB, pcb2);
   26220:	01000084 	movi	r4,2
   26224:	e17fff17 	ldw	r5,-4(fp)
   26228:	00225900 	call	22590 <memp_free>
   2622c:	00000506 	br	26244 <tcp_slowtmr+0x710>
    } else {
      prev = pcb;
   26230:	e0bff817 	ldw	r2,-32(fp)
   26234:	e0bff915 	stw	r2,-28(fp)
      pcb = pcb->next;
   26238:	e0bff817 	ldw	r2,-32(fp)
   2623c:	10800317 	ldw	r2,12(r2)
   26240:	e0bff815 	stw	r2,-32(fp)

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
   26244:	e0bff817 	ldw	r2,-32(fp)
   26248:	103fd81e 	bne	r2,zero,261ac <tcp_slowtmr+0x678>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
   2624c:	e037883a 	mov	sp,fp
   26250:	dfc00117 	ldw	ra,4(sp)
   26254:	df000017 	ldw	fp,0(sp)
   26258:	dec00204 	addi	sp,sp,8
   2625c:	f800283a 	ret

00026260 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
   26260:	defffc04 	addi	sp,sp,-16
   26264:	dfc00315 	stw	ra,12(sp)
   26268:	df000215 	stw	fp,8(sp)
   2626c:	df000204 	addi	fp,sp,8
  struct tcp_pcb *pcb;

  ++tcp_timer_ctr;
   26270:	d0a93543 	ldbu	r2,-23339(gp)
   26274:	10800044 	addi	r2,r2,1
   26278:	d0a93545 	stb	r2,-23339(gp)
   2627c:	00000106 	br	26284 <tcp_fasttmr+0x24>
      if (pcb->refused_data != NULL) {
        tcp_active_pcbs_changed = 0;
        tcp_process_refused_data(pcb);
        if (tcp_active_pcbs_changed) {
          /* application callback has changed the pcb list: restart the loop */
          goto tcp_fasttmr_start;
   26280:	0001883a 	nop
  struct tcp_pcb *pcb;

  ++tcp_timer_ctr;

tcp_fasttmr_start:
  pcb = tcp_active_pcbs;
   26284:	d0a93617 	ldw	r2,-23336(gp)
   26288:	e0bffe15 	stw	r2,-8(fp)

  while(pcb != NULL) {
   2628c:	00002b06 	br	2633c <tcp_fasttmr+0xdc>
    if (pcb->last_timer != tcp_timer_ctr) {
   26290:	e0bffe17 	ldw	r2,-8(fp)
   26294:	10c00943 	ldbu	r3,37(r2)
   26298:	d0a93543 	ldbu	r2,-23339(gp)
   2629c:	18c03fcc 	andi	r3,r3,255
   262a0:	10803fcc 	andi	r2,r2,255
   262a4:	18802526 	beq	r3,r2,2633c <tcp_fasttmr+0xdc>
      struct tcp_pcb *next;
      pcb->last_timer = tcp_timer_ctr;
   262a8:	d0e93543 	ldbu	r3,-23339(gp)
   262ac:	e0bffe17 	ldw	r2,-8(fp)
   262b0:	10c00945 	stb	r3,37(r2)
      /* send delayed ACKs */
      if (pcb->flags & TF_ACK_DELAY) {
   262b4:	e0bffe17 	ldw	r2,-8(fp)
   262b8:	10800883 	ldbu	r2,34(r2)
   262bc:	10803fcc 	andi	r2,r2,255
   262c0:	1080004c 	andi	r2,r2,1
   262c4:	10000f26 	beq	r2,zero,26304 <tcp_fasttmr+0xa4>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
        tcp_ack_now(pcb);
   262c8:	e0bffe17 	ldw	r2,-8(fp)
   262cc:	10800883 	ldbu	r2,34(r2)
   262d0:	10800094 	ori	r2,r2,2
   262d4:	1007883a 	mov	r3,r2
   262d8:	e0bffe17 	ldw	r2,-8(fp)
   262dc:	10c00885 	stb	r3,34(r2)
        tcp_output(pcb);
   262e0:	e13ffe17 	ldw	r4,-8(fp)
   262e4:	002c9d00 	call	2c9d0 <tcp_output>
        pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
   262e8:	e0bffe17 	ldw	r2,-8(fp)
   262ec:	10c00883 	ldbu	r3,34(r2)
   262f0:	00bfff04 	movi	r2,-4
   262f4:	1884703a 	and	r2,r3,r2
   262f8:	1007883a 	mov	r3,r2
   262fc:	e0bffe17 	ldw	r2,-8(fp)
   26300:	10c00885 	stb	r3,34(r2)
      }

      next = pcb->next;
   26304:	e0bffe17 	ldw	r2,-8(fp)
   26308:	10800317 	ldw	r2,12(r2)
   2630c:	e0bfff15 	stw	r2,-4(fp)

      /* If there is data which was previously "refused" by upper layer */
      if (pcb->refused_data != NULL) {
   26310:	e0bffe17 	ldw	r2,-8(fp)
   26314:	10801f17 	ldw	r2,124(r2)
   26318:	10000626 	beq	r2,zero,26334 <tcp_fasttmr+0xd4>
        tcp_active_pcbs_changed = 0;
   2631c:	d0293585 	stb	zero,-23338(gp)
        tcp_process_refused_data(pcb);
   26320:	e13ffe17 	ldw	r4,-8(fp)
   26324:	00263580 	call	26358 <tcp_process_refused_data>
        if (tcp_active_pcbs_changed) {
   26328:	d0a93583 	ldbu	r2,-23338(gp)
   2632c:	10803fcc 	andi	r2,r2,255
   26330:	103fd31e 	bne	r2,zero,26280 <tcp_fasttmr+0x20>
          /* application callback has changed the pcb list: restart the loop */
          goto tcp_fasttmr_start;
        }
      }
      pcb = next;
   26334:	e0bfff17 	ldw	r2,-4(fp)
   26338:	e0bffe15 	stw	r2,-8(fp)
  ++tcp_timer_ctr;

tcp_fasttmr_start:
  pcb = tcp_active_pcbs;

  while(pcb != NULL) {
   2633c:	e0bffe17 	ldw	r2,-8(fp)
   26340:	103fd31e 	bne	r2,zero,26290 <tcp_fasttmr+0x30>
        }
      }
      pcb = next;
    }
  }
}
   26344:	e037883a 	mov	sp,fp
   26348:	dfc00117 	ldw	ra,4(sp)
   2634c:	df000017 	ldw	fp,0(sp)
   26350:	dec00204 	addi	sp,sp,8
   26354:	f800283a 	ret

00026358 <tcp_process_refused_data>:

/** Pass pcb->refused_data to the recv callback */
err_t
tcp_process_refused_data(struct tcp_pcb *pcb)
{
   26358:	defffb04 	addi	sp,sp,-20
   2635c:	dfc00415 	stw	ra,16(sp)
   26360:	df000315 	stw	fp,12(sp)
   26364:	df000304 	addi	fp,sp,12
   26368:	e13fff15 	stw	r4,-4(fp)
  err_t err;
  u8_t refused_flags = pcb->refused_data->flags;
   2636c:	e0bfff17 	ldw	r2,-4(fp)
   26370:	10801f17 	ldw	r2,124(r2)
   26374:	10800343 	ldbu	r2,13(r2)
   26378:	e0bffd45 	stb	r2,-11(fp)
  /* set pcb->refused_data to NULL in case the callback frees it and then
     closes the pcb */
  struct pbuf *refused_data = pcb->refused_data;
   2637c:	e0bfff17 	ldw	r2,-4(fp)
   26380:	10801f17 	ldw	r2,124(r2)
   26384:	e0bffe15 	stw	r2,-8(fp)
  pcb->refused_data = NULL;
   26388:	e0bfff17 	ldw	r2,-4(fp)
   2638c:	10001f15 	stw	zero,124(r2)
  /* Notify again application with data previously received. */
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
  TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
   26390:	e0bfff17 	ldw	r2,-4(fp)
   26394:	10802117 	ldw	r2,132(r2)
   26398:	10000b26 	beq	r2,zero,263c8 <tcp_process_refused_data+0x70>
   2639c:	e0bfff17 	ldw	r2,-4(fp)
   263a0:	10c02117 	ldw	r3,132(r2)
   263a4:	e0bfff17 	ldw	r2,-4(fp)
   263a8:	10800417 	ldw	r2,16(r2)
   263ac:	1009883a 	mov	r4,r2
   263b0:	e17fff17 	ldw	r5,-4(fp)
   263b4:	e1bffe17 	ldw	r6,-8(fp)
   263b8:	000f883a 	mov	r7,zero
   263bc:	183ee83a 	callr	r3
   263c0:	e0bffd05 	stb	r2,-12(fp)
   263c4:	00000606 	br	263e0 <tcp_process_refused_data+0x88>
   263c8:	0009883a 	mov	r4,zero
   263cc:	e17fff17 	ldw	r5,-4(fp)
   263d0:	e1bffe17 	ldw	r6,-8(fp)
   263d4:	000f883a 	mov	r7,zero
   263d8:	00265ec0 	call	265ec <tcp_recv_null>
   263dc:	e0bffd05 	stb	r2,-12(fp)
  if (err == ERR_OK) {
   263e0:	e0bffd07 	ldb	r2,-12(fp)
   263e4:	1000221e 	bne	r2,zero,26470 <tcp_process_refused_data+0x118>
    /* did refused_data include a FIN? */
    if (refused_flags & PBUF_FLAG_TCP_FIN) {
   263e8:	e0bffd43 	ldbu	r2,-11(fp)
   263ec:	1080080c 	andi	r2,r2,32
   263f0:	10002726 	beq	r2,zero,26490 <tcp_process_refused_data+0x138>
      /* correct rcv_wnd as the application won't call tcp_recved()
         for the FIN's seqno */
      if (pcb->rcv_wnd != TCP_WND) {
   263f4:	e0bfff17 	ldw	r2,-4(fp)
   263f8:	10800c0b 	ldhu	r2,48(r2)
   263fc:	10bfffcc 	andi	r2,r2,65535
   26400:	10880020 	cmpeqi	r2,r2,8192
   26404:	1000061e 	bne	r2,zero,26420 <tcp_process_refused_data+0xc8>
        pcb->rcv_wnd++;
   26408:	e0bfff17 	ldw	r2,-4(fp)
   2640c:	10800c0b 	ldhu	r2,48(r2)
   26410:	10800044 	addi	r2,r2,1
   26414:	1007883a 	mov	r3,r2
   26418:	e0bfff17 	ldw	r2,-4(fp)
   2641c:	10c00c0d 	sth	r3,48(r2)
      }
      TCP_EVENT_CLOSED(pcb, err);
   26420:	e0bfff17 	ldw	r2,-4(fp)
   26424:	10802117 	ldw	r2,132(r2)
   26428:	10000b26 	beq	r2,zero,26458 <tcp_process_refused_data+0x100>
   2642c:	e0bfff17 	ldw	r2,-4(fp)
   26430:	10c02117 	ldw	r3,132(r2)
   26434:	e0bfff17 	ldw	r2,-4(fp)
   26438:	10800417 	ldw	r2,16(r2)
   2643c:	1009883a 	mov	r4,r2
   26440:	e17fff17 	ldw	r5,-4(fp)
   26444:	000d883a 	mov	r6,zero
   26448:	000f883a 	mov	r7,zero
   2644c:	183ee83a 	callr	r3
   26450:	e0bffd05 	stb	r2,-12(fp)
   26454:	00000106 	br	2645c <tcp_process_refused_data+0x104>
   26458:	e03ffd05 	stb	zero,-12(fp)
      if (err == ERR_ABRT) {
   2645c:	e0bffd07 	ldb	r2,-12(fp)
   26460:	10bffd98 	cmpnei	r2,r2,-10
   26464:	10000a1e 	bne	r2,zero,26490 <tcp_process_refused_data+0x138>
        return ERR_ABRT;
   26468:	00bffd84 	movi	r2,-10
   2646c:	00000906 	br	26494 <tcp_process_refused_data+0x13c>
      }
    }
  } else if (err == ERR_ABRT) {
   26470:	e0bffd07 	ldb	r2,-12(fp)
   26474:	10bffd98 	cmpnei	r2,r2,-10
   26478:	1000021e 	bne	r2,zero,26484 <tcp_process_refused_data+0x12c>
    /* if err == ERR_ABRT, 'pcb' is already deallocated */
    /* Drop incoming packets because pcb is "full" (only if the incoming
       segment contains data). */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
    return ERR_ABRT;
   2647c:	00bffd84 	movi	r2,-10
   26480:	00000406 	br	26494 <tcp_process_refused_data+0x13c>
  } else {
    /* data is still refused, pbuf is still valid (go on for ACK-only packets) */
    pcb->refused_data = refused_data;
   26484:	e0bfff17 	ldw	r2,-4(fp)
   26488:	e0fffe17 	ldw	r3,-8(fp)
   2648c:	10c01f15 	stw	r3,124(r2)
  }
  return ERR_OK;
   26490:	0005883a 	mov	r2,zero
}
   26494:	e037883a 	mov	sp,fp
   26498:	dfc00117 	ldw	ra,4(sp)
   2649c:	df000017 	ldw	fp,0(sp)
   264a0:	dec00204 	addi	sp,sp,8
   264a4:	f800283a 	ret

000264a8 <tcp_segs_free>:
 *
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
   264a8:	defffc04 	addi	sp,sp,-16
   264ac:	dfc00315 	stw	ra,12(sp)
   264b0:	df000215 	stw	fp,8(sp)
   264b4:	df000204 	addi	fp,sp,8
   264b8:	e13fff15 	stw	r4,-4(fp)
  while (seg != NULL) {
   264bc:	00000706 	br	264dc <tcp_segs_free+0x34>
    struct tcp_seg *next = seg->next;
   264c0:	e0bfff17 	ldw	r2,-4(fp)
   264c4:	10800017 	ldw	r2,0(r2)
   264c8:	e0bffe15 	stw	r2,-8(fp)
    tcp_seg_free(seg);
   264cc:	e13fff17 	ldw	r4,-4(fp)
   264d0:	00264f80 	call	264f8 <tcp_seg_free>
    seg = next;
   264d4:	e0bffe17 	ldw	r2,-8(fp)
   264d8:	e0bfff15 	stw	r2,-4(fp)
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
   264dc:	e0bfff17 	ldw	r2,-4(fp)
   264e0:	103ff71e 	bne	r2,zero,264c0 <tcp_segs_free+0x18>
    struct tcp_seg *next = seg->next;
    tcp_seg_free(seg);
    seg = next;
  }
}
   264e4:	e037883a 	mov	sp,fp
   264e8:	dfc00117 	ldw	ra,4(sp)
   264ec:	df000017 	ldw	fp,0(sp)
   264f0:	dec00204 	addi	sp,sp,8
   264f4:	f800283a 	ret

000264f8 <tcp_seg_free>:
 *
 * @param seg single tcp_seg to free
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
   264f8:	defffd04 	addi	sp,sp,-12
   264fc:	dfc00215 	stw	ra,8(sp)
   26500:	df000115 	stw	fp,4(sp)
   26504:	df000104 	addi	fp,sp,4
   26508:	e13fff15 	stw	r4,-4(fp)
  if (seg != NULL) {
   2650c:	e0bfff17 	ldw	r2,-4(fp)
   26510:	10000a26 	beq	r2,zero,2653c <tcp_seg_free+0x44>
    if (seg->p != NULL) {
   26514:	e0bfff17 	ldw	r2,-4(fp)
   26518:	10800117 	ldw	r2,4(r2)
   2651c:	10000426 	beq	r2,zero,26530 <tcp_seg_free+0x38>
      pbuf_free(seg->p);
   26520:	e0bfff17 	ldw	r2,-4(fp)
   26524:	10800117 	ldw	r2,4(r2)
   26528:	1009883a 	mov	r4,r2
   2652c:	00237600 	call	23760 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
   26530:	01000104 	movi	r4,4
   26534:	e17fff17 	ldw	r5,-4(fp)
   26538:	00225900 	call	22590 <memp_free>
  }
}
   2653c:	e037883a 	mov	sp,fp
   26540:	dfc00117 	ldw	ra,4(sp)
   26544:	df000017 	ldw	fp,0(sp)
   26548:	dec00204 	addi	sp,sp,8
   2654c:	f800283a 	ret

00026550 <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
   26550:	defffd04 	addi	sp,sp,-12
   26554:	df000215 	stw	fp,8(sp)
   26558:	df000204 	addi	fp,sp,8
   2655c:	e13ffe15 	stw	r4,-8(fp)
   26560:	2805883a 	mov	r2,r5
   26564:	e0bfff05 	stb	r2,-4(fp)
  pcb->prio = prio;
   26568:	e0bffe17 	ldw	r2,-8(fp)
   2656c:	e0ffff03 	ldbu	r3,-4(fp)
   26570:	10c00705 	stb	r3,28(r2)
}
   26574:	e037883a 	mov	sp,fp
   26578:	df000017 	ldw	fp,0(sp)
   2657c:	dec00104 	addi	sp,sp,4
   26580:	f800283a 	ret

00026584 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
   26584:	defffc04 	addi	sp,sp,-16
   26588:	dfc00315 	stw	ra,12(sp)
   2658c:	df000215 	stw	fp,8(sp)
   26590:	df000204 	addi	fp,sp,8
   26594:	e13fff15 	stw	r4,-4(fp)
  struct tcp_seg *cseg;

  cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
   26598:	01000104 	movi	r4,4
   2659c:	00223cc0 	call	223cc <memp_malloc>
   265a0:	e0bffe15 	stw	r2,-8(fp)
  if (cseg == NULL) {
   265a4:	e0bffe17 	ldw	r2,-8(fp)
   265a8:	1000021e 	bne	r2,zero,265b4 <tcp_seg_copy+0x30>
    return NULL;
   265ac:	0005883a 	mov	r2,zero
   265b0:	00000906 	br	265d8 <tcp_seg_copy+0x54>
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
   265b4:	e13ffe17 	ldw	r4,-8(fp)
   265b8:	e17fff17 	ldw	r5,-4(fp)
   265bc:	01800504 	movi	r6,20
   265c0:	00041f00 	call	41f0 <memcpy>
  pbuf_ref(cseg->p);
   265c4:	e0bffe17 	ldw	r2,-8(fp)
   265c8:	10800117 	ldw	r2,4(r2)
   265cc:	1009883a 	mov	r4,r2
   265d0:	00238f00 	call	238f0 <pbuf_ref>
  return cseg;
   265d4:	e0bffe17 	ldw	r2,-8(fp)
}
   265d8:	e037883a 	mov	sp,fp
   265dc:	dfc00117 	ldw	ra,4(sp)
   265e0:	df000017 	ldw	fp,0(sp)
   265e4:	dec00204 	addi	sp,sp,8
   265e8:	f800283a 	ret

000265ec <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
   265ec:	defffa04 	addi	sp,sp,-24
   265f0:	dfc00515 	stw	ra,20(sp)
   265f4:	df000415 	stw	fp,16(sp)
   265f8:	df000404 	addi	fp,sp,16
   265fc:	e13ffc15 	stw	r4,-16(fp)
   26600:	e17ffd15 	stw	r5,-12(fp)
   26604:	e1bffe15 	stw	r6,-8(fp)
   26608:	3805883a 	mov	r2,r7
   2660c:	e0bfff05 	stb	r2,-4(fp)
  LWIP_UNUSED_ARG(arg);
  if (p != NULL) {
   26610:	e0bffe17 	ldw	r2,-8(fp)
   26614:	10000926 	beq	r2,zero,2663c <tcp_recv_null+0x50>
    tcp_recved(pcb, p->tot_len);
   26618:	e0bffe17 	ldw	r2,-8(fp)
   2661c:	1080020b 	ldhu	r2,8(r2)
   26620:	10bfffcc 	andi	r2,r2,65535
   26624:	e13ffd17 	ldw	r4,-12(fp)
   26628:	100b883a 	mov	r5,r2
   2662c:	00256180 	call	25618 <tcp_recved>
    pbuf_free(p);
   26630:	e13ffe17 	ldw	r4,-8(fp)
   26634:	00237600 	call	23760 <pbuf_free>
   26638:	00000506 	br	26650 <tcp_recv_null+0x64>
  } else if (err == ERR_OK) {
   2663c:	e0bfff07 	ldb	r2,-4(fp)
   26640:	1000031e 	bne	r2,zero,26650 <tcp_recv_null+0x64>
    return tcp_close(pcb);
   26644:	e13ffd17 	ldw	r4,-12(fp)
   26648:	0024de40 	call	24de4 <tcp_close>
   2664c:	00000106 	br	26654 <tcp_recv_null+0x68>
  }
  return ERR_OK;
   26650:	0005883a 	mov	r2,zero
}
   26654:	e037883a 	mov	sp,fp
   26658:	dfc00117 	ldw	ra,4(sp)
   2665c:	df000017 	ldw	fp,0(sp)
   26660:	dec00204 	addi	sp,sp,8
   26664:	f800283a 	ret

00026668 <tcp_kill_prio>:
 *
 * @param prio minimum priority
 */
static void
tcp_kill_prio(u8_t prio)
{
   26668:	defff904 	addi	sp,sp,-28
   2666c:	dfc00615 	stw	ra,24(sp)
   26670:	df000515 	stw	fp,20(sp)
   26674:	df000504 	addi	fp,sp,20
   26678:	2005883a 	mov	r2,r4
   2667c:	e0bfff05 	stb	r2,-4(fp)
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
   26680:	00801fc4 	movi	r2,127
   26684:	e0bffe05 	stb	r2,-8(fp)
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
   26688:	e03ffd15 	stw	zero,-12(fp)
  inactive = NULL;
   2668c:	e03ffc15 	stw	zero,-16(fp)
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
   26690:	d0a93617 	ldw	r2,-23336(gp)
   26694:	e0bffb15 	stw	r2,-20(fp)
   26698:	00001d06 	br	26710 <tcp_kill_prio+0xa8>
    if (pcb->prio <= prio &&
   2669c:	e0bffb17 	ldw	r2,-20(fp)
   266a0:	10800703 	ldbu	r2,28(r2)
   266a4:	10803fcc 	andi	r2,r2,255
   266a8:	e0ffff03 	ldbu	r3,-4(fp)
   266ac:	18801536 	bltu	r3,r2,26704 <tcp_kill_prio+0x9c>
       pcb->prio <= mprio &&
   266b0:	e0bffb17 	ldw	r2,-20(fp)
   266b4:	10800703 	ldbu	r2,28(r2)
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
   266b8:	10803fcc 	andi	r2,r2,255
   266bc:	e0fffe03 	ldbu	r3,-8(fp)
   266c0:	18801036 	bltu	r3,r2,26704 <tcp_kill_prio+0x9c>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
   266c4:	d0e93717 	ldw	r3,-23332(gp)
   266c8:	e0bffb17 	ldw	r2,-20(fp)
   266cc:	10800a17 	ldw	r2,40(r2)
   266d0:	1887c83a 	sub	r3,r3,r2
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
   266d4:	e0bffd17 	ldw	r2,-12(fp)
   266d8:	18800a36 	bltu	r3,r2,26704 <tcp_kill_prio+0x9c>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
   266dc:	d0e93717 	ldw	r3,-23332(gp)
   266e0:	e0bffb17 	ldw	r2,-20(fp)
   266e4:	10800a17 	ldw	r2,40(r2)
   266e8:	1885c83a 	sub	r2,r3,r2
   266ec:	e0bffd15 	stw	r2,-12(fp)
      inactive = pcb;
   266f0:	e0bffb17 	ldw	r2,-20(fp)
   266f4:	e0bffc15 	stw	r2,-16(fp)
      mprio = pcb->prio;
   266f8:	e0bffb17 	ldw	r2,-20(fp)
   266fc:	10800703 	ldbu	r2,28(r2)
   26700:	e0bffe05 	stb	r2,-8(fp)
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
   26704:	e0bffb17 	ldw	r2,-20(fp)
   26708:	10800317 	ldw	r2,12(r2)
   2670c:	e0bffb15 	stw	r2,-20(fp)
   26710:	e0bffb17 	ldw	r2,-20(fp)
   26714:	103fe11e 	bne	r2,zero,2669c <tcp_kill_prio+0x34>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
   26718:	e0bffc17 	ldw	r2,-16(fp)
   2671c:	10000226 	beq	r2,zero,26728 <tcp_kill_prio+0xc0>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
   26720:	e13ffc17 	ldw	r4,-16(fp)
   26724:	002508c0 	call	2508c <tcp_abort>
  }
}
   26728:	e037883a 	mov	sp,fp
   2672c:	dfc00117 	ldw	ra,4(sp)
   26730:	df000017 	ldw	fp,0(sp)
   26734:	dec00204 	addi	sp,sp,8
   26738:	f800283a 	ret

0002673c <tcp_kill_timewait>:
 * Kills the oldest connection that is in TIME_WAIT state.
 * Called from tcp_alloc() if no more connections are available.
 */
static void
tcp_kill_timewait(void)
{
   2673c:	defffb04 	addi	sp,sp,-20
   26740:	dfc00415 	stw	ra,16(sp)
   26744:	df000315 	stw	fp,12(sp)
   26748:	df000304 	addi	fp,sp,12
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
   2674c:	e03fff15 	stw	zero,-4(fp)
  inactive = NULL;
   26750:	e03ffe15 	stw	zero,-8(fp)
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
   26754:	d0a93b17 	ldw	r2,-23316(gp)
   26758:	e0bffd15 	stw	r2,-12(fp)
   2675c:	00001006 	br	267a0 <tcp_kill_timewait+0x64>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
   26760:	d0e93717 	ldw	r3,-23332(gp)
   26764:	e0bffd17 	ldw	r2,-12(fp)
   26768:	10800a17 	ldw	r2,40(r2)
   2676c:	1887c83a 	sub	r3,r3,r2
   26770:	e0bfff17 	ldw	r2,-4(fp)
   26774:	18800736 	bltu	r3,r2,26794 <tcp_kill_timewait+0x58>
      inactivity = tcp_ticks - pcb->tmr;
   26778:	d0e93717 	ldw	r3,-23332(gp)
   2677c:	e0bffd17 	ldw	r2,-12(fp)
   26780:	10800a17 	ldw	r2,40(r2)
   26784:	1885c83a 	sub	r2,r3,r2
   26788:	e0bfff15 	stw	r2,-4(fp)
      inactive = pcb;
   2678c:	e0bffd17 	ldw	r2,-12(fp)
   26790:	e0bffe15 	stw	r2,-8(fp)
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
   26794:	e0bffd17 	ldw	r2,-12(fp)
   26798:	10800317 	ldw	r2,12(r2)
   2679c:	e0bffd15 	stw	r2,-12(fp)
   267a0:	e0bffd17 	ldw	r2,-12(fp)
   267a4:	103fee1e 	bne	r2,zero,26760 <tcp_kill_timewait+0x24>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
   267a8:	e0bffe17 	ldw	r2,-8(fp)
   267ac:	10000226 	beq	r2,zero,267b8 <tcp_kill_timewait+0x7c>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
   267b0:	e13ffe17 	ldw	r4,-8(fp)
   267b4:	002508c0 	call	2508c <tcp_abort>
  }
}
   267b8:	e037883a 	mov	sp,fp
   267bc:	dfc00117 	ldw	ra,4(sp)
   267c0:	df000017 	ldw	fp,0(sp)
   267c4:	dec00204 	addi	sp,sp,8
   267c8:	f800283a 	ret

000267cc <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
   267cc:	defffb04 	addi	sp,sp,-20
   267d0:	dfc00415 	stw	ra,16(sp)
   267d4:	df000315 	stw	fp,12(sp)
   267d8:	df000304 	addi	fp,sp,12
   267dc:	2005883a 	mov	r2,r4
   267e0:	e0bfff05 	stb	r2,-4(fp)
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
   267e4:	01000084 	movi	r4,2
   267e8:	00223cc0 	call	223cc <memp_malloc>
   267ec:	e0bffd15 	stw	r2,-12(fp)
  if (pcb == NULL) {
   267f0:	e0bffd17 	ldw	r2,-12(fp)
   267f4:	10001e1e 	bne	r2,zero,26870 <tcp_alloc+0xa4>
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
   267f8:	002673c0 	call	2673c <tcp_kill_timewait>
    /* Try to allocate a tcp_pcb again. */
    pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
   267fc:	01000084 	movi	r4,2
   26800:	00223cc0 	call	223cc <memp_malloc>
   26804:	e0bffd15 	stw	r2,-12(fp)
    if (pcb == NULL) {
   26808:	e0bffd17 	ldw	r2,-12(fp)
   2680c:	10000f1e 	bne	r2,zero,2684c <tcp_alloc+0x80>
      /* Try killing active connections with lower priority than the new one. */
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing connection with prio lower than %d\n", prio));
      tcp_kill_prio(prio);
   26810:	e0bfff03 	ldbu	r2,-4(fp)
   26814:	1009883a 	mov	r4,r2
   26818:	00266680 	call	26668 <tcp_kill_prio>
      /* Try to allocate a tcp_pcb again. */
      pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
   2681c:	01000084 	movi	r4,2
   26820:	00223cc0 	call	223cc <memp_malloc>
   26824:	e0bffd15 	stw	r2,-12(fp)
      if (pcb != NULL) {
   26828:	e0bffd17 	ldw	r2,-12(fp)
   2682c:	10000726 	beq	r2,zero,2684c <tcp_alloc+0x80>
        /* adjust err stats: memp_malloc failed twice before */
        MEMP_STATS_DEC(err, MEMP_TCP_PCB);
   26830:	008001f4 	movhi	r2,7
   26834:	10ac6e04 	addi	r2,r2,-20040
   26838:	10806217 	ldw	r2,392(r2)
   2683c:	10ffffc4 	addi	r3,r2,-1
   26840:	008001f4 	movhi	r2,7
   26844:	10ac6e04 	addi	r2,r2,-20040
   26848:	10c06215 	stw	r3,392(r2)
      }
    }
    if (pcb != NULL) {
   2684c:	e0bffd17 	ldw	r2,-12(fp)
   26850:	10000726 	beq	r2,zero,26870 <tcp_alloc+0xa4>
      /* adjust err stats: timewait PCB was freed above */
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
   26854:	008001f4 	movhi	r2,7
   26858:	10ac6e04 	addi	r2,r2,-20040
   2685c:	10806217 	ldw	r2,392(r2)
   26860:	10ffffc4 	addi	r3,r2,-1
   26864:	008001f4 	movhi	r2,7
   26868:	10ac6e04 	addi	r2,r2,-20040
   2686c:	10c06215 	stw	r3,392(r2)
    }
  }
  if (pcb != NULL) {
   26870:	e0bffd17 	ldw	r2,-12(fp)
   26874:	10004f26 	beq	r2,zero,269b4 <tcp_alloc+0x1e8>
    memset(pcb, 0, sizeof(struct tcp_pcb));
   26878:	e13ffd17 	ldw	r4,-12(fp)
   2687c:	000b883a 	mov	r5,zero
   26880:	01802904 	movi	r6,164
   26884:	00042e80 	call	42e8 <memset>
    pcb->prio = prio;
   26888:	e0bffd17 	ldw	r2,-12(fp)
   2688c:	e0ffff03 	ldbu	r3,-4(fp)
   26890:	10c00705 	stb	r3,28(r2)
    pcb->snd_buf = TCP_SND_BUF;
   26894:	e0bffd17 	ldw	r2,-12(fp)
   26898:	00c2da04 	movi	r3,2920
   2689c:	10c01a8d 	sth	r3,106(r2)
    pcb->snd_queuelen = 0;
   268a0:	e0bffd17 	ldw	r2,-12(fp)
   268a4:	10001b0d 	sth	zero,108(r2)
    pcb->rcv_wnd = TCP_WND;
   268a8:	e0bffd17 	ldw	r2,-12(fp)
   268ac:	00c80004 	movi	r3,8192
   268b0:	10c00c0d 	sth	r3,48(r2)
    pcb->rcv_ann_wnd = TCP_WND;
   268b4:	e0bffd17 	ldw	r2,-12(fp)
   268b8:	00c80004 	movi	r3,8192
   268bc:	10c00c8d 	sth	r3,50(r2)
    pcb->tos = 0;
   268c0:	e0bffd17 	ldw	r2,-12(fp)
   268c4:	10000245 	stb	zero,9(r2)
    pcb->ttl = TCP_TTL;
   268c8:	e0bffd17 	ldw	r2,-12(fp)
   268cc:	00c01004 	movi	r3,64
   268d0:	10c00285 	stb	r3,10(r2)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
   268d4:	e0bffd17 	ldw	r2,-12(fp)
   268d8:	00c08604 	movi	r3,536
   268dc:	10c00e8d 	sth	r3,58(r2)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
   268e0:	e0bffd17 	ldw	r2,-12(fp)
   268e4:	00c00184 	movi	r3,6
   268e8:	10c0120d 	sth	r3,72(r2)
    pcb->sa = 0;
   268ec:	e0bffd17 	ldw	r2,-12(fp)
   268f0:	1000110d 	sth	zero,68(r2)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
   268f4:	e0bffd17 	ldw	r2,-12(fp)
   268f8:	00c00184 	movi	r3,6
   268fc:	10c0118d 	sth	r3,70(r2)
    pcb->rtime = -1;
   26900:	e0bffd17 	ldw	r2,-12(fp)
   26904:	00ffffc4 	movi	r3,-1
   26908:	10c00e0d 	sth	r3,56(r2)
    pcb->cwnd = 1;
   2690c:	e0bffd17 	ldw	r2,-12(fp)
   26910:	00c00044 	movi	r3,1
   26914:	10c0140d 	sth	r3,80(r2)
    iss = tcp_next_iss();
   26918:	0026da00 	call	26da0 <tcp_next_iss>
   2691c:	e0bffe15 	stw	r2,-8(fp)
    pcb->snd_wl2 = iss;
   26920:	e0bffd17 	ldw	r2,-12(fp)
   26924:	e0fffe17 	ldw	r3,-8(fp)
   26928:	10c01715 	stw	r3,92(r2)
    pcb->snd_nxt = iss;
   2692c:	e0bffd17 	ldw	r2,-12(fp)
   26930:	e0fffe17 	ldw	r3,-8(fp)
   26934:	10c01515 	stw	r3,84(r2)
    pcb->lastack = iss;
   26938:	e0bffd17 	ldw	r2,-12(fp)
   2693c:	e0fffe17 	ldw	r3,-8(fp)
   26940:	10c01315 	stw	r3,76(r2)
    pcb->snd_lbb = iss;   
   26944:	e0bffd17 	ldw	r2,-12(fp)
   26948:	e0fffe17 	ldw	r3,-8(fp)
   2694c:	10c01815 	stw	r3,96(r2)
    pcb->tmr = tcp_ticks;
   26950:	d0e93717 	ldw	r3,-23332(gp)
   26954:	e0bffd17 	ldw	r2,-12(fp)
   26958:	10c00a15 	stw	r3,40(r2)
    pcb->last_timer = tcp_timer_ctr;
   2695c:	d0e93543 	ldbu	r3,-23339(gp)
   26960:	e0bffd17 	ldw	r2,-12(fp)
   26964:	10c00945 	stb	r3,37(r2)

    pcb->polltmr = 0;
   26968:	e0bffd17 	ldw	r2,-12(fp)
   2696c:	100008c5 	stb	zero,35(r2)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
   26970:	e0bffd17 	ldw	r2,-12(fp)
   26974:	00c000b4 	movhi	r3,2
   26978:	18d97b04 	addi	r3,r3,26092
   2697c:	10c02115 	stw	r3,132(r2)
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
   26980:	e0bffd17 	ldw	r2,-12(fp)
   26984:	00c01bb4 	movhi	r3,110
   26988:	18f74004 	addi	r3,r3,-8960
   2698c:	10c02515 	stw	r3,148(r2)
    
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
   26990:	e0bffd17 	ldw	r2,-12(fp)
   26994:	00c00074 	movhi	r3,1
   26998:	18c93e04 	addi	r3,r3,9464
   2699c:	10c02615 	stw	r3,152(r2)
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
   269a0:	e0bffd17 	ldw	r2,-12(fp)
   269a4:	00c00244 	movi	r3,9
   269a8:	10c02715 	stw	r3,156(r2)
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
   269ac:	e0bffd17 	ldw	r2,-12(fp)
   269b0:	10002885 	stb	zero,162(r2)
  }
  return pcb;
   269b4:	e0bffd17 	ldw	r2,-12(fp)
}
   269b8:	e037883a 	mov	sp,fp
   269bc:	dfc00117 	ldw	ra,4(sp)
   269c0:	df000017 	ldw	fp,0(sp)
   269c4:	dec00204 	addi	sp,sp,8
   269c8:	f800283a 	ret

000269cc <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
   269cc:	defffe04 	addi	sp,sp,-8
   269d0:	dfc00115 	stw	ra,4(sp)
   269d4:	df000015 	stw	fp,0(sp)
   269d8:	d839883a 	mov	fp,sp
  return tcp_alloc(TCP_PRIO_NORMAL);
   269dc:	01001004 	movi	r4,64
   269e0:	00267cc0 	call	267cc <tcp_alloc>
}
   269e4:	e037883a 	mov	sp,fp
   269e8:	dfc00117 	ldw	ra,4(sp)
   269ec:	df000017 	ldw	fp,0(sp)
   269f0:	dec00204 	addi	sp,sp,8
   269f4:	f800283a 	ret

000269f8 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{
   269f8:	defffd04 	addi	sp,sp,-12
   269fc:	df000215 	stw	fp,8(sp)
   26a00:	df000204 	addi	fp,sp,8
   26a04:	e13ffe15 	stw	r4,-8(fp)
   26a08:	e17fff15 	stw	r5,-4(fp)
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  pcb->callback_arg = arg;
   26a0c:	e0bffe17 	ldw	r2,-8(fp)
   26a10:	e0ffff17 	ldw	r3,-4(fp)
   26a14:	10c00415 	stw	r3,16(r2)
}
   26a18:	e037883a 	mov	sp,fp
   26a1c:	df000017 	ldw	fp,0(sp)
   26a20:	dec00104 	addi	sp,sp,4
   26a24:	f800283a 	ret

00026a28 <tcp_recv>:
 * @param pcb tcp_pcb to set the recv callback
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
   26a28:	defffd04 	addi	sp,sp,-12
   26a2c:	df000215 	stw	fp,8(sp)
   26a30:	df000204 	addi	fp,sp,8
   26a34:	e13ffe15 	stw	r4,-8(fp)
   26a38:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
  pcb->recv = recv;
   26a3c:	e0bffe17 	ldw	r2,-8(fp)
   26a40:	e0ffff17 	ldw	r3,-4(fp)
   26a44:	10c02115 	stw	r3,132(r2)
}
   26a48:	e037883a 	mov	sp,fp
   26a4c:	df000017 	ldw	fp,0(sp)
   26a50:	dec00104 	addi	sp,sp,4
   26a54:	f800283a 	ret

00026a58 <tcp_sent>:
 * @param pcb tcp_pcb to set the sent callback
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
   26a58:	defffd04 	addi	sp,sp,-12
   26a5c:	df000215 	stw	fp,8(sp)
   26a60:	df000204 	addi	fp,sp,8
   26a64:	e13ffe15 	stw	r4,-8(fp)
   26a68:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
  pcb->sent = sent;
   26a6c:	e0bffe17 	ldw	r2,-8(fp)
   26a70:	e0ffff17 	ldw	r3,-4(fp)
   26a74:	10c02015 	stw	r3,128(r2)
}
   26a78:	e037883a 	mov	sp,fp
   26a7c:	df000017 	ldw	fp,0(sp)
   26a80:	dec00104 	addi	sp,sp,4
   26a84:	f800283a 	ret

00026a88 <tcp_err>:
 * @param err callback function to call for this pcb when a fatal error
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
   26a88:	defffd04 	addi	sp,sp,-12
   26a8c:	df000215 	stw	fp,8(sp)
   26a90:	df000204 	addi	fp,sp,8
   26a94:	e13ffe15 	stw	r4,-8(fp)
   26a98:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
  pcb->errf = err;
   26a9c:	e0bffe17 	ldw	r2,-8(fp)
   26aa0:	e0ffff17 	ldw	r3,-4(fp)
   26aa4:	10c02415 	stw	r3,144(r2)
}
   26aa8:	e037883a 	mov	sp,fp
   26aac:	df000017 	ldw	fp,0(sp)
   26ab0:	dec00104 	addi	sp,sp,4
   26ab4:	f800283a 	ret

00026ab8 <tcp_accept>:
 * @param accept callback function to call for this pcb when LISTENing
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
{
   26ab8:	defffd04 	addi	sp,sp,-12
   26abc:	df000215 	stw	fp,8(sp)
   26ac0:	df000204 	addi	fp,sp,8
   26ac4:	e13ffe15 	stw	r4,-8(fp)
   26ac8:	e17fff15 	stw	r5,-4(fp)
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  pcb->accept = accept;
   26acc:	e0bffe17 	ldw	r2,-8(fp)
   26ad0:	e0ffff17 	ldw	r3,-4(fp)
   26ad4:	10c00515 	stw	r3,20(r2)
}
   26ad8:	e037883a 	mov	sp,fp
   26adc:	df000017 	ldw	fp,0(sp)
   26ae0:	dec00104 	addi	sp,sp,4
   26ae4:	f800283a 	ret

00026ae8 <tcp_poll>:
 * timer interval, which is called twice a second.
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
   26ae8:	defffc04 	addi	sp,sp,-16
   26aec:	df000315 	stw	fp,12(sp)
   26af0:	df000304 	addi	fp,sp,12
   26af4:	e13ffd15 	stw	r4,-12(fp)
   26af8:	e17ffe15 	stw	r5,-8(fp)
   26afc:	3005883a 	mov	r2,r6
   26b00:	e0bfff05 	stb	r2,-4(fp)
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
#if LWIP_CALLBACK_API
  pcb->poll = poll;
   26b04:	e0bffd17 	ldw	r2,-12(fp)
   26b08:	e0fffe17 	ldw	r3,-8(fp)
   26b0c:	10c02315 	stw	r3,140(r2)
#else /* LWIP_CALLBACK_API */  
  LWIP_UNUSED_ARG(poll);
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
   26b10:	e0bffd17 	ldw	r2,-12(fp)
   26b14:	e0ffff03 	ldbu	r3,-4(fp)
   26b18:	10c00905 	stb	r3,36(r2)
}
   26b1c:	e037883a 	mov	sp,fp
   26b20:	df000017 	ldw	fp,0(sp)
   26b24:	dec00104 	addi	sp,sp,4
   26b28:	f800283a 	ret

00026b2c <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
   26b2c:	defffc04 	addi	sp,sp,-16
   26b30:	dfc00315 	stw	ra,12(sp)
   26b34:	df000215 	stw	fp,8(sp)
   26b38:	df000204 	addi	fp,sp,8
   26b3c:	e13fff15 	stw	r4,-4(fp)
  if (pcb->state != CLOSED &&
   26b40:	e0bfff17 	ldw	r2,-4(fp)
   26b44:	10800617 	ldw	r2,24(r2)
   26b48:	10004e26 	beq	r2,zero,26c84 <tcp_pcb_purge+0x158>
     pcb->state != TIME_WAIT &&
   26b4c:	e0bfff17 	ldw	r2,-4(fp)
   26b50:	10800617 	ldw	r2,24(r2)
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
   26b54:	108002a0 	cmpeqi	r2,r2,10
   26b58:	10004a1e 	bne	r2,zero,26c84 <tcp_pcb_purge+0x158>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {
   26b5c:	e0bfff17 	ldw	r2,-4(fp)
   26b60:	10800617 	ldw	r2,24(r2)
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
     pcb->state != TIME_WAIT &&
   26b64:	10800060 	cmpeqi	r2,r2,1
   26b68:	1000461e 	bne	r2,zero,26c84 <tcp_pcb_purge+0x158>
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

#if TCP_LISTEN_BACKLOG
    if (pcb->state == SYN_RCVD) {
   26b6c:	e0bfff17 	ldw	r2,-4(fp)
   26b70:	10800617 	ldw	r2,24(r2)
   26b74:	108000d8 	cmpnei	r2,r2,3
   26b78:	1000201e 	bne	r2,zero,26bfc <tcp_pcb_purge+0xd0>
      /* Need to find the corresponding listen_pcb and decrease its accepts_pending */
      struct tcp_pcb_listen *lpcb;
      LWIP_ASSERT("tcp_pcb_purge: pcb->state == SYN_RCVD but tcp_listen_pcbs is NULL",
        tcp_listen_pcbs.listen_pcbs != NULL);
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
   26b7c:	d0a93817 	ldw	r2,-23328(gp)
   26b80:	e0bffe15 	stw	r2,-8(fp)
   26b84:	00001b06 	br	26bf4 <tcp_pcb_purge+0xc8>
        if ((lpcb->local_port == pcb->local_port) &&
   26b88:	e0bffe17 	ldw	r2,-8(fp)
   26b8c:	10c0078b 	ldhu	r3,30(r2)
   26b90:	e0bfff17 	ldw	r2,-4(fp)
   26b94:	1080078b 	ldhu	r2,30(r2)
   26b98:	18ffffcc 	andi	r3,r3,65535
   26b9c:	10bfffcc 	andi	r2,r2,65535
   26ba0:	1880111e 	bne	r3,r2,26be8 <tcp_pcb_purge+0xbc>
            (ip_addr_isany(&lpcb->local_ip) ||
   26ba4:	e0bffe17 	ldw	r2,-8(fp)
      /* Need to find the corresponding listen_pcb and decrease its accepts_pending */
      struct tcp_pcb_listen *lpcb;
      LWIP_ASSERT("tcp_pcb_purge: pcb->state == SYN_RCVD but tcp_listen_pcbs is NULL",
        tcp_listen_pcbs.listen_pcbs != NULL);
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
        if ((lpcb->local_port == pcb->local_port) &&
   26ba8:	10000826 	beq	r2,zero,26bcc <tcp_pcb_purge+0xa0>
            (ip_addr_isany(&lpcb->local_ip) ||
   26bac:	e0bffe17 	ldw	r2,-8(fp)
   26bb0:	10800017 	ldw	r2,0(r2)
   26bb4:	10000526 	beq	r2,zero,26bcc <tcp_pcb_purge+0xa0>
             ip_addr_cmp(&pcb->local_ip, &lpcb->local_ip))) {
   26bb8:	e0bfff17 	ldw	r2,-4(fp)
   26bbc:	10c00017 	ldw	r3,0(r2)
   26bc0:	e0bffe17 	ldw	r2,-8(fp)
   26bc4:	10800017 	ldw	r2,0(r2)
      struct tcp_pcb_listen *lpcb;
      LWIP_ASSERT("tcp_pcb_purge: pcb->state == SYN_RCVD but tcp_listen_pcbs is NULL",
        tcp_listen_pcbs.listen_pcbs != NULL);
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
        if ((lpcb->local_port == pcb->local_port) &&
            (ip_addr_isany(&lpcb->local_ip) ||
   26bc8:	1880071e 	bne	r3,r2,26be8 <tcp_pcb_purge+0xbc>
             ip_addr_cmp(&pcb->local_ip, &lpcb->local_ip))) {
            /* port and address of the listen pcb match the timed-out pcb */
            LWIP_ASSERT("tcp_pcb_purge: listen pcb does not have accepts pending",
              lpcb->accepts_pending > 0);
            lpcb->accepts_pending--;
   26bcc:	e0bffe17 	ldw	r2,-8(fp)
   26bd0:	10800843 	ldbu	r2,33(r2)
   26bd4:	10bfffc4 	addi	r2,r2,-1
   26bd8:	1007883a 	mov	r3,r2
   26bdc:	e0bffe17 	ldw	r2,-8(fp)
   26be0:	10c00845 	stb	r3,33(r2)
            break;
   26be4:	00000506 	br	26bfc <tcp_pcb_purge+0xd0>
    if (pcb->state == SYN_RCVD) {
      /* Need to find the corresponding listen_pcb and decrease its accepts_pending */
      struct tcp_pcb_listen *lpcb;
      LWIP_ASSERT("tcp_pcb_purge: pcb->state == SYN_RCVD but tcp_listen_pcbs is NULL",
        tcp_listen_pcbs.listen_pcbs != NULL);
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
   26be8:	e0bffe17 	ldw	r2,-8(fp)
   26bec:	10800317 	ldw	r2,12(r2)
   26bf0:	e0bffe15 	stw	r2,-8(fp)
   26bf4:	e0bffe17 	ldw	r2,-8(fp)
   26bf8:	103fe31e 	bne	r2,zero,26b88 <tcp_pcb_purge+0x5c>
      }
    }
#endif /* TCP_LISTEN_BACKLOG */


    if (pcb->refused_data != NULL) {
   26bfc:	e0bfff17 	ldw	r2,-4(fp)
   26c00:	10801f17 	ldw	r2,124(r2)
   26c04:	10000626 	beq	r2,zero,26c20 <tcp_pcb_purge+0xf4>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
   26c08:	e0bfff17 	ldw	r2,-4(fp)
   26c0c:	10801f17 	ldw	r2,124(r2)
   26c10:	1009883a 	mov	r4,r2
   26c14:	00237600 	call	23760 <pbuf_free>
      pcb->refused_data = NULL;
   26c18:	e0bfff17 	ldw	r2,-4(fp)
   26c1c:	10001f15 	stw	zero,124(r2)
    }
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }
    tcp_segs_free(pcb->ooseq);
   26c20:	e0bfff17 	ldw	r2,-4(fp)
   26c24:	10801e17 	ldw	r2,120(r2)
   26c28:	1009883a 	mov	r4,r2
   26c2c:	00264a80 	call	264a8 <tcp_segs_free>
    pcb->ooseq = NULL;
   26c30:	e0bfff17 	ldw	r2,-4(fp)
   26c34:	10001e15 	stw	zero,120(r2)
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
   26c38:	e0bfff17 	ldw	r2,-4(fp)
   26c3c:	00ffffc4 	movi	r3,-1
   26c40:	10c00e0d 	sth	r3,56(r2)

    tcp_segs_free(pcb->unsent);
   26c44:	e0bfff17 	ldw	r2,-4(fp)
   26c48:	10801c17 	ldw	r2,112(r2)
   26c4c:	1009883a 	mov	r4,r2
   26c50:	00264a80 	call	264a8 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
   26c54:	e0bfff17 	ldw	r2,-4(fp)
   26c58:	10801d17 	ldw	r2,116(r2)
   26c5c:	1009883a 	mov	r4,r2
   26c60:	00264a80 	call	264a8 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
   26c64:	e0bfff17 	ldw	r2,-4(fp)
   26c68:	10001c15 	stw	zero,112(r2)
   26c6c:	e0bfff17 	ldw	r2,-4(fp)
   26c70:	10c01c17 	ldw	r3,112(r2)
   26c74:	e0bfff17 	ldw	r2,-4(fp)
   26c78:	10c01d15 	stw	r3,116(r2)
#if TCP_OVERSIZE
    pcb->unsent_oversize = 0;
   26c7c:	e0bfff17 	ldw	r2,-4(fp)
   26c80:	10001b8d 	sth	zero,110(r2)
#endif /* TCP_OVERSIZE */
  }
}
   26c84:	e037883a 	mov	sp,fp
   26c88:	dfc00117 	ldw	ra,4(sp)
   26c8c:	df000017 	ldw	fp,0(sp)
   26c90:	dec00204 	addi	sp,sp,8
   26c94:	f800283a 	ret

00026c98 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
   26c98:	defffc04 	addi	sp,sp,-16
   26c9c:	dfc00315 	stw	ra,12(sp)
   26ca0:	df000215 	stw	fp,8(sp)
   26ca4:	df000204 	addi	fp,sp,8
   26ca8:	e13ffe15 	stw	r4,-8(fp)
   26cac:	e17fff15 	stw	r5,-4(fp)
  TCP_RMV(pcblist, pcb);
   26cb0:	e0bffe17 	ldw	r2,-8(fp)
   26cb4:	10c00017 	ldw	r3,0(r2)
   26cb8:	e0bfff17 	ldw	r2,-4(fp)
   26cbc:	1880061e 	bne	r3,r2,26cd8 <tcp_pcb_remove+0x40>
   26cc0:	e0bffe17 	ldw	r2,-8(fp)
   26cc4:	10800017 	ldw	r2,0(r2)
   26cc8:	10c00317 	ldw	r3,12(r2)
   26ccc:	e0bffe17 	ldw	r2,-8(fp)
   26cd0:	10c00015 	stw	r3,0(r2)
   26cd4:	00001206 	br	26d20 <tcp_pcb_remove+0x88>
   26cd8:	e0bffe17 	ldw	r2,-8(fp)
   26cdc:	10800017 	ldw	r2,0(r2)
   26ce0:	d0a93915 	stw	r2,-23324(gp)
   26ce4:	00000c06 	br	26d18 <tcp_pcb_remove+0x80>
   26ce8:	d0a93917 	ldw	r2,-23324(gp)
   26cec:	10c00317 	ldw	r3,12(r2)
   26cf0:	e0bfff17 	ldw	r2,-4(fp)
   26cf4:	1880051e 	bne	r3,r2,26d0c <tcp_pcb_remove+0x74>
   26cf8:	d0a93917 	ldw	r2,-23324(gp)
   26cfc:	e0ffff17 	ldw	r3,-4(fp)
   26d00:	18c00317 	ldw	r3,12(r3)
   26d04:	10c00315 	stw	r3,12(r2)
   26d08:	00000506 	br	26d20 <tcp_pcb_remove+0x88>
   26d0c:	d0a93917 	ldw	r2,-23324(gp)
   26d10:	10800317 	ldw	r2,12(r2)
   26d14:	d0a93915 	stw	r2,-23324(gp)
   26d18:	d0a93917 	ldw	r2,-23324(gp)
   26d1c:	103ff21e 	bne	r2,zero,26ce8 <tcp_pcb_remove+0x50>
   26d20:	e0bfff17 	ldw	r2,-4(fp)
   26d24:	10000315 	stw	zero,12(r2)

  tcp_pcb_purge(pcb);
   26d28:	e13fff17 	ldw	r4,-4(fp)
   26d2c:	0026b2c0 	call	26b2c <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
   26d30:	e0bfff17 	ldw	r2,-4(fp)
   26d34:	10800617 	ldw	r2,24(r2)
   26d38:	108002a0 	cmpeqi	r2,r2,10
   26d3c:	1000111e 	bne	r2,zero,26d84 <tcp_pcb_remove+0xec>
     pcb->state != LISTEN &&
   26d40:	e0bfff17 	ldw	r2,-4(fp)
   26d44:	10800617 	ldw	r2,24(r2)
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
   26d48:	10800060 	cmpeqi	r2,r2,1
   26d4c:	10000d1e 	bne	r2,zero,26d84 <tcp_pcb_remove+0xec>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
   26d50:	e0bfff17 	ldw	r2,-4(fp)
   26d54:	10800883 	ldbu	r2,34(r2)
   26d58:	10803fcc 	andi	r2,r2,255
   26d5c:	1080004c 	andi	r2,r2,1

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
   26d60:	10000826 	beq	r2,zero,26d84 <tcp_pcb_remove+0xec>
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
   26d64:	e0bfff17 	ldw	r2,-4(fp)
   26d68:	10800883 	ldbu	r2,34(r2)
   26d6c:	10800094 	ori	r2,r2,2
   26d70:	1007883a 	mov	r3,r2
   26d74:	e0bfff17 	ldw	r2,-4(fp)
   26d78:	10c00885 	stb	r3,34(r2)
    tcp_output(pcb);
   26d7c:	e13fff17 	ldw	r4,-4(fp)
   26d80:	002c9d00 	call	2c9d0 <tcp_output>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
   26d84:	e0bfff17 	ldw	r2,-4(fp)
   26d88:	10000615 	stw	zero,24(r2)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
   26d8c:	e037883a 	mov	sp,fp
   26d90:	dfc00117 	ldw	ra,4(sp)
   26d94:	df000017 	ldw	fp,0(sp)
   26d98:	dec00204 	addi	sp,sp,8
   26d9c:	f800283a 	ret

00026da0 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
   26da0:	deffff04 	addi	sp,sp,-4
   26da4:	df000015 	stw	fp,0(sp)
   26da8:	d839883a 	mov	fp,sp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
   26dac:	d0e01417 	ldw	r3,-32688(gp)
   26db0:	d0a93717 	ldw	r2,-23332(gp)
   26db4:	1885883a 	add	r2,r3,r2
   26db8:	d0a01415 	stw	r2,-32688(gp)
  return iss;
   26dbc:	d0a01417 	ldw	r2,-32688(gp)
}
   26dc0:	e037883a 	mov	sp,fp
   26dc4:	df000017 	ldw	fp,0(sp)
   26dc8:	dec00104 	addi	sp,sp,4
   26dcc:	f800283a 	ret

00026dd0 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, ip_addr_t *src, ip_addr_t *addr)
{
   26dd0:	defff904 	addi	sp,sp,-28
   26dd4:	dfc00615 	stw	ra,24(sp)
   26dd8:	df000515 	stw	fp,20(sp)
   26ddc:	df000504 	addi	fp,sp,20
   26de0:	2005883a 	mov	r2,r4
   26de4:	e17ffe15 	stw	r5,-8(fp)
   26de8:	e1bfff15 	stw	r6,-4(fp)
   26dec:	e0bffd0d 	sth	r2,-12(fp)
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(src, addr);
   26df0:	e13ffe17 	ldw	r4,-8(fp)
   26df4:	e17fff17 	ldw	r5,-4(fp)
   26df8:	001ecb40 	call	1ecb4 <ip_route>
   26dfc:	e0bffb15 	stw	r2,-20(fp)
  if ((outif != NULL) && (outif->mtu != 0)) {
   26e00:	e0bffb17 	ldw	r2,-20(fp)
   26e04:	10000f26 	beq	r2,zero,26e44 <tcp_eff_send_mss+0x74>
   26e08:	e0bffb17 	ldw	r2,-20(fp)
   26e0c:	10800c0b 	ldhu	r2,48(r2)
   26e10:	10bfffcc 	andi	r2,r2,65535
   26e14:	10000b26 	beq	r2,zero,26e44 <tcp_eff_send_mss+0x74>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
   26e18:	e0bffb17 	ldw	r2,-20(fp)
   26e1c:	10800c0b 	ldhu	r2,48(r2)
   26e20:	10bff604 	addi	r2,r2,-40
   26e24:	e0bffc0d 	sth	r2,-16(fp)
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * We correct for TCP options in tcp_write(), and don't support IP options.
     */
    sendmss = LWIP_MIN(sendmss, mss_s);
   26e28:	e0fffd0b 	ldhu	r3,-12(fp)
   26e2c:	e0bffc0b 	ldhu	r2,-16(fp)
   26e30:	113fffcc 	andi	r4,r2,65535
   26e34:	197fffcc 	andi	r5,r3,65535
   26e38:	2900012e 	bgeu	r5,r4,26e40 <tcp_eff_send_mss+0x70>
   26e3c:	1805883a 	mov	r2,r3
   26e40:	e0bffd0d 	sth	r2,-12(fp)
  }
  return sendmss;
   26e44:	e0bffd0b 	ldhu	r2,-12(fp)
}
   26e48:	e037883a 	mov	sp,fp
   26e4c:	dfc00117 	ldw	ra,4(sp)
   26e50:	df000017 	ldw	fp,0(sp)
   26e54:	dec00204 	addi	sp,sp,8
   26e58:	f800283a 	ret

00026e5c <tcp_debug_state_str>:
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

const char*
tcp_debug_state_str(enum tcp_state s)
{
   26e5c:	defffe04 	addi	sp,sp,-8
   26e60:	df000115 	stw	fp,4(sp)
   26e64:	df000104 	addi	fp,sp,4
   26e68:	e13fff15 	stw	r4,-4(fp)
  return tcp_state_str[s];
   26e6c:	00c00134 	movhi	r3,4
   26e70:	18c50c04 	addi	r3,r3,5168
   26e74:	e0bfff17 	ldw	r2,-4(fp)
   26e78:	1085883a 	add	r2,r2,r2
   26e7c:	1085883a 	add	r2,r2,r2
   26e80:	1885883a 	add	r2,r3,r2
   26e84:	10800017 	ldw	r2,0(r2)
}
   26e88:	e037883a 	mov	sp,fp
   26e8c:	df000017 	ldw	fp,0(sp)
   26e90:	dec00104 	addi	sp,sp,4
   26e94:	f800283a 	ret

00026e98 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
   26e98:	defff404 	addi	sp,sp,-48
   26e9c:	dfc00b15 	stw	ra,44(sp)
   26ea0:	df000a15 	stw	fp,40(sp)
   26ea4:	df000a04 	addi	fp,sp,40
   26ea8:	e13ffe15 	stw	r4,-8(fp)
   26eac:	e17fff15 	stw	r5,-4(fp)
  struct tcp_pcb *pcb, *prev;
  struct tcp_pcb_listen *lpcb;
#if SO_REUSE
  struct tcp_pcb *lpcb_prev = NULL;
   26eb0:	e03ffb15 	stw	zero,-20(fp)
  struct tcp_pcb_listen *lpcb_any = NULL;
   26eb4:	e03ffc15 	stw	zero,-16(fp)
  u8_t hdrlen;
  err_t err;

  PERF_START;

  TCP_STATS_INC(tcp.recv);
   26eb8:	008001f4 	movhi	r2,7
   26ebc:	10ac6e04 	addi	r2,r2,-20040
   26ec0:	10804917 	ldw	r2,292(r2)
   26ec4:	10c00044 	addi	r3,r2,1
   26ec8:	008001f4 	movhi	r2,7
   26ecc:	10ac6e04 	addi	r2,r2,-20040
   26ed0:	10c04915 	stw	r3,292(r2)
  snmp_inc_tcpinsegs();

  iphdr = (struct ip_hdr *)p->payload;
   26ed4:	e0bffe17 	ldw	r2,-8(fp)
   26ed8:	10800117 	ldw	r2,4(r2)
   26edc:	d0a93d15 	stw	r2,-23308(gp)
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
   26ee0:	e0bffe17 	ldw	r2,-8(fp)
   26ee4:	10c00117 	ldw	r3,4(r2)
   26ee8:	d0a93d17 	ldw	r2,-23308(gp)
   26eec:	10800003 	ldbu	r2,0(r2)
   26ef0:	10803fcc 	andi	r2,r2,255
   26ef4:	108003cc 	andi	r2,r2,15
   26ef8:	1085883a 	add	r2,r2,r2
   26efc:	1085883a 	add	r2,r2,r2
   26f00:	1885883a 	add	r2,r3,r2
   26f04:	d0a93c15 	stw	r2,-23312(gp)
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
   26f08:	d0a93d17 	ldw	r2,-23308(gp)
   26f0c:	10800003 	ldbu	r2,0(r2)
   26f10:	10803fcc 	andi	r2,r2,255
   26f14:	108003cc 	andi	r2,r2,15
   26f18:	1085883a 	add	r2,r2,r2
   26f1c:	1085883a 	add	r2,r2,r2
   26f20:	0085c83a 	sub	r2,zero,r2
   26f24:	10bfffcc 	andi	r2,r2,65535
   26f28:	10a0001c 	xori	r2,r2,32768
   26f2c:	10a00004 	addi	r2,r2,-32768
   26f30:	e13ffe17 	ldw	r4,-8(fp)
   26f34:	100b883a 	mov	r5,r2
   26f38:	00235b00 	call	235b0 <pbuf_header>
   26f3c:	10803fcc 	andi	r2,r2,255
   26f40:	1000051e 	bne	r2,zero,26f58 <tcp_input+0xc0>
   26f44:	e0bffe17 	ldw	r2,-8(fp)
   26f48:	1080020b 	ldhu	r2,8(r2)
   26f4c:	10bfffcc 	andi	r2,r2,65535
   26f50:	10800528 	cmpgeui	r2,r2,20
   26f54:	1000081e 	bne	r2,zero,26f78 <tcp_input+0xe0>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
   26f58:	008001f4 	movhi	r2,7
   26f5c:	10ac6e04 	addi	r2,r2,-20040
   26f60:	10804d17 	ldw	r2,308(r2)
   26f64:	10c00044 	addi	r3,r2,1
   26f68:	008001f4 	movhi	r2,7
   26f6c:	10ac6e04 	addi	r2,r2,-20040
   26f70:	10c04d15 	stw	r3,308(r2)
    goto dropped;
   26f74:	00035b06 	br	27ce4 <tcp_input+0xe4c>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
   26f78:	00800134 	movhi	r2,4
   26f7c:	109ee404 	addi	r2,r2,31632
   26f80:	10800017 	ldw	r2,0(r2)
   26f84:	1009883a 	mov	r4,r2
   26f88:	e17fff17 	ldw	r5,-4(fp)
   26f8c:	001fa400 	call	1fa40 <ip4_addr_isbroadcast>
   26f90:	10803fcc 	andi	r2,r2,255
   26f94:	1000061e 	bne	r2,zero,26fb0 <tcp_input+0x118>
      ip_addr_ismulticast(&current_iphdr_dest)) {
   26f98:	00800134 	movhi	r2,4
   26f9c:	109ee404 	addi	r2,r2,31632
   26fa0:	10800017 	ldw	r2,0(r2)
   26fa4:	10803c0c 	andi	r2,r2,240
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
   26fa8:	10803818 	cmpnei	r2,r2,224
   26fac:	1000081e 	bne	r2,zero,26fd0 <tcp_input+0x138>
      ip_addr_ismulticast(&current_iphdr_dest)) {
    TCP_STATS_INC(tcp.proterr);
   26fb0:	008001f4 	movhi	r2,7
   26fb4:	10ac6e04 	addi	r2,r2,-20040
   26fb8:	10805017 	ldw	r2,320(r2)
   26fbc:	10c00044 	addi	r3,r2,1
   26fc0:	008001f4 	movhi	r2,7
   26fc4:	10ac6e04 	addi	r2,r2,-20040
   26fc8:	10c05015 	stw	r3,320(r2)
    goto dropped;
   26fcc:	00034506 	br	27ce4 <tcp_input+0xe4c>
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
      IP_PROTO_TCP, p->tot_len) != 0) {
   26fd0:	e0bffe17 	ldw	r2,-8(fp)
   26fd4:	1080020b 	ldhu	r2,8(r2)
    goto dropped;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
   26fd8:	10bfffcc 	andi	r2,r2,65535
   26fdc:	d8800015 	stw	r2,0(sp)
   26fe0:	e13ffe17 	ldw	r4,-8(fp)
   26fe4:	01400134 	movhi	r5,4
   26fe8:	295ee204 	addi	r5,r5,31624
   26fec:	01800134 	movhi	r6,4
   26ff0:	319ee404 	addi	r6,r6,31632
   26ff4:	01c00184 	movi	r7,6
   26ff8:	003e2ac0 	call	3e2ac <inet_chksum_pseudo>
   26ffc:	10bfffcc 	andi	r2,r2,65535
   27000:	10000826 	beq	r2,zero,27024 <tcp_input+0x18c>
        inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
      IP_PROTO_TCP, p->tot_len)));
#if TCP_DEBUG
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
   27004:	008001f4 	movhi	r2,7
   27008:	10ac6e04 	addi	r2,r2,-20040
   2700c:	10804c17 	ldw	r2,304(r2)
   27010:	10c00044 	addi	r3,r2,1
   27014:	008001f4 	movhi	r2,7
   27018:	10ac6e04 	addi	r2,r2,-20040
   2701c:	10c04c15 	stw	r3,304(r2)
    goto dropped;
   27020:	00033006 	br	27ce4 <tcp_input+0xe4c>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
   27024:	d0a93c17 	ldw	r2,-23312(gp)
   27028:	10c00303 	ldbu	r3,12(r2)
   2702c:	10800343 	ldbu	r2,13(r2)
   27030:	1004923a 	slli	r2,r2,8
   27034:	10c4b03a 	or	r2,r2,r3
   27038:	10bfffcc 	andi	r2,r2,65535
   2703c:	1004d23a 	srli	r2,r2,8
   27040:	10ffffcc 	andi	r3,r2,65535
   27044:	d0a93c17 	ldw	r2,-23312(gp)
   27048:	11000303 	ldbu	r4,12(r2)
   2704c:	10800343 	ldbu	r2,13(r2)
   27050:	1004923a 	slli	r2,r2,8
   27054:	1104b03a 	or	r2,r2,r4
   27058:	10bfffcc 	andi	r2,r2,65535
   2705c:	1004923a 	slli	r2,r2,8
   27060:	10bfffcc 	andi	r2,r2,65535
   27064:	1884b03a 	or	r2,r3,r2
   27068:	1005d33a 	srai	r2,r2,12
   2706c:	e0bffd45 	stb	r2,-11(fp)
  if(pbuf_header(p, -(hdrlen * 4))){
   27070:	e0bffd43 	ldbu	r2,-11(fp)
   27074:	10bfff24 	muli	r2,r2,-4
   27078:	10bfffcc 	andi	r2,r2,65535
   2707c:	10a0001c 	xori	r2,r2,32768
   27080:	10a00004 	addi	r2,r2,-32768
   27084:	e13ffe17 	ldw	r4,-8(fp)
   27088:	100b883a 	mov	r5,r2
   2708c:	00235b00 	call	235b0 <pbuf_header>
   27090:	10803fcc 	andi	r2,r2,255
   27094:	10000826 	beq	r2,zero,270b8 <tcp_input+0x220>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
   27098:	008001f4 	movhi	r2,7
   2709c:	10ac6e04 	addi	r2,r2,-20040
   270a0:	10804d17 	ldw	r2,308(r2)
   270a4:	10c00044 	addi	r3,r2,1
   270a8:	008001f4 	movhi	r2,7
   270ac:	10ac6e04 	addi	r2,r2,-20040
   270b0:	10c04d15 	stw	r3,308(r2)
    goto dropped;
   270b4:	00030b06 	br	27ce4 <tcp_input+0xe4c>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
   270b8:	d0a93c17 	ldw	r2,-23312(gp)
   270bc:	d0e93c17 	ldw	r3,-23312(gp)
   270c0:	19000003 	ldbu	r4,0(r3)
   270c4:	18c00043 	ldbu	r3,1(r3)
   270c8:	1806923a 	slli	r3,r3,8
   270cc:	1906b03a 	or	r3,r3,r4
   270d0:	18ffffcc 	andi	r3,r3,65535
   270d4:	1806d23a 	srli	r3,r3,8
   270d8:	1809883a 	mov	r4,r3
   270dc:	d0e93c17 	ldw	r3,-23312(gp)
   270e0:	19400003 	ldbu	r5,0(r3)
   270e4:	18c00043 	ldbu	r3,1(r3)
   270e8:	1806923a 	slli	r3,r3,8
   270ec:	1946b03a 	or	r3,r3,r5
   270f0:	18ffffcc 	andi	r3,r3,65535
   270f4:	1806923a 	slli	r3,r3,8
   270f8:	20c6b03a 	or	r3,r4,r3
   270fc:	193fffcc 	andi	r4,r3,65535
   27100:	21003fcc 	andi	r4,r4,255
   27104:	11400003 	ldbu	r5,0(r2)
   27108:	280a703a 	and	r5,r5,zero
   2710c:	2908b03a 	or	r4,r5,r4
   27110:	11000005 	stb	r4,0(r2)
   27114:	18ffffcc 	andi	r3,r3,65535
   27118:	1806d23a 	srli	r3,r3,8
   2711c:	18ffffcc 	andi	r3,r3,65535
   27120:	11000043 	ldbu	r4,1(r2)
   27124:	2008703a 	and	r4,r4,zero
   27128:	20c6b03a 	or	r3,r4,r3
   2712c:	10c00045 	stb	r3,1(r2)
  tcphdr->dest = ntohs(tcphdr->dest);
   27130:	d0a93c17 	ldw	r2,-23312(gp)
   27134:	d0e93c17 	ldw	r3,-23312(gp)
   27138:	19000083 	ldbu	r4,2(r3)
   2713c:	18c000c3 	ldbu	r3,3(r3)
   27140:	1806923a 	slli	r3,r3,8
   27144:	1906b03a 	or	r3,r3,r4
   27148:	18ffffcc 	andi	r3,r3,65535
   2714c:	1806d23a 	srli	r3,r3,8
   27150:	1809883a 	mov	r4,r3
   27154:	d0e93c17 	ldw	r3,-23312(gp)
   27158:	19400083 	ldbu	r5,2(r3)
   2715c:	18c000c3 	ldbu	r3,3(r3)
   27160:	1806923a 	slli	r3,r3,8
   27164:	1946b03a 	or	r3,r3,r5
   27168:	18ffffcc 	andi	r3,r3,65535
   2716c:	1806923a 	slli	r3,r3,8
   27170:	20c6b03a 	or	r3,r4,r3
   27174:	193fffcc 	andi	r4,r3,65535
   27178:	21003fcc 	andi	r4,r4,255
   2717c:	11400083 	ldbu	r5,2(r2)
   27180:	280a703a 	and	r5,r5,zero
   27184:	2908b03a 	or	r4,r5,r4
   27188:	11000085 	stb	r4,2(r2)
   2718c:	18ffffcc 	andi	r3,r3,65535
   27190:	1806d23a 	srli	r3,r3,8
   27194:	18ffffcc 	andi	r3,r3,65535
   27198:	110000c3 	ldbu	r4,3(r2)
   2719c:	2008703a 	and	r4,r4,zero
   271a0:	20c6b03a 	or	r3,r4,r3
   271a4:	10c000c5 	stb	r3,3(r2)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
   271a8:	d0a93c17 	ldw	r2,-23312(gp)
   271ac:	d0e93c17 	ldw	r3,-23312(gp)
   271b0:	19000103 	ldbu	r4,4(r3)
   271b4:	19400143 	ldbu	r5,5(r3)
   271b8:	280a923a 	slli	r5,r5,8
   271bc:	2908b03a 	or	r4,r5,r4
   271c0:	19400183 	ldbu	r5,6(r3)
   271c4:	280a943a 	slli	r5,r5,16
   271c8:	2908b03a 	or	r4,r5,r4
   271cc:	18c001c3 	ldbu	r3,7(r3)
   271d0:	1806963a 	slli	r3,r3,24
   271d4:	1906b03a 	or	r3,r3,r4
   271d8:	1808d63a 	srli	r4,r3,24
   271dc:	d0e93c17 	ldw	r3,-23312(gp)
   271e0:	19400103 	ldbu	r5,4(r3)
   271e4:	19800143 	ldbu	r6,5(r3)
   271e8:	300c923a 	slli	r6,r6,8
   271ec:	314ab03a 	or	r5,r6,r5
   271f0:	19800183 	ldbu	r6,6(r3)
   271f4:	300c943a 	slli	r6,r6,16
   271f8:	314ab03a 	or	r5,r6,r5
   271fc:	18c001c3 	ldbu	r3,7(r3)
   27200:	1806963a 	slli	r3,r3,24
   27204:	1946b03a 	or	r3,r3,r5
   27208:	1806d23a 	srli	r3,r3,8
   2720c:	18ffc00c 	andi	r3,r3,65280
   27210:	20c8b03a 	or	r4,r4,r3
   27214:	d0e93c17 	ldw	r3,-23312(gp)
   27218:	19400103 	ldbu	r5,4(r3)
   2721c:	19800143 	ldbu	r6,5(r3)
   27220:	300c923a 	slli	r6,r6,8
   27224:	314ab03a 	or	r5,r6,r5
   27228:	19800183 	ldbu	r6,6(r3)
   2722c:	300c943a 	slli	r6,r6,16
   27230:	314ab03a 	or	r5,r6,r5
   27234:	18c001c3 	ldbu	r3,7(r3)
   27238:	1806963a 	slli	r3,r3,24
   2723c:	1946b03a 	or	r3,r3,r5
   27240:	18ffc00c 	andi	r3,r3,65280
   27244:	1806923a 	slli	r3,r3,8
   27248:	20c8b03a 	or	r4,r4,r3
   2724c:	d0e93c17 	ldw	r3,-23312(gp)
   27250:	19400103 	ldbu	r5,4(r3)
   27254:	19800143 	ldbu	r6,5(r3)
   27258:	300c923a 	slli	r6,r6,8
   2725c:	314ab03a 	or	r5,r6,r5
   27260:	19800183 	ldbu	r6,6(r3)
   27264:	300c943a 	slli	r6,r6,16
   27268:	314ab03a 	or	r5,r6,r5
   2726c:	18c001c3 	ldbu	r3,7(r3)
   27270:	1806963a 	slli	r3,r3,24
   27274:	1946b03a 	or	r3,r3,r5
   27278:	1806963a 	slli	r3,r3,24
   2727c:	20c6b03a 	or	r3,r4,r3
   27280:	19003fcc 	andi	r4,r3,255
   27284:	11400103 	ldbu	r5,4(r2)
   27288:	280a703a 	and	r5,r5,zero
   2728c:	2908b03a 	or	r4,r5,r4
   27290:	11000105 	stb	r4,4(r2)
   27294:	1808d23a 	srli	r4,r3,8
   27298:	21003fcc 	andi	r4,r4,255
   2729c:	11400143 	ldbu	r5,5(r2)
   272a0:	280a703a 	and	r5,r5,zero
   272a4:	2908b03a 	or	r4,r5,r4
   272a8:	11000145 	stb	r4,5(r2)
   272ac:	1808d43a 	srli	r4,r3,16
   272b0:	21003fcc 	andi	r4,r4,255
   272b4:	11400183 	ldbu	r5,6(r2)
   272b8:	280a703a 	and	r5,r5,zero
   272bc:	2908b03a 	or	r4,r5,r4
   272c0:	11000185 	stb	r4,6(r2)
   272c4:	1806d63a 	srli	r3,r3,24
   272c8:	110001c3 	ldbu	r4,7(r2)
   272cc:	2008703a 	and	r4,r4,zero
   272d0:	20c6b03a 	or	r3,r4,r3
   272d4:	10c001c5 	stb	r3,7(r2)
   272d8:	10c00103 	ldbu	r3,4(r2)
   272dc:	11000143 	ldbu	r4,5(r2)
   272e0:	2008923a 	slli	r4,r4,8
   272e4:	20c6b03a 	or	r3,r4,r3
   272e8:	11000183 	ldbu	r4,6(r2)
   272ec:	2008943a 	slli	r4,r4,16
   272f0:	20c6b03a 	or	r3,r4,r3
   272f4:	108001c3 	ldbu	r2,7(r2)
   272f8:	1004963a 	slli	r2,r2,24
   272fc:	10c4b03a 	or	r2,r2,r3
   27300:	d0a93e15 	stw	r2,-23304(gp)
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
   27304:	d0a93c17 	ldw	r2,-23312(gp)
   27308:	d0e93c17 	ldw	r3,-23312(gp)
   2730c:	19000203 	ldbu	r4,8(r3)
   27310:	19400243 	ldbu	r5,9(r3)
   27314:	280a923a 	slli	r5,r5,8
   27318:	2908b03a 	or	r4,r5,r4
   2731c:	19400283 	ldbu	r5,10(r3)
   27320:	280a943a 	slli	r5,r5,16
   27324:	2908b03a 	or	r4,r5,r4
   27328:	18c002c3 	ldbu	r3,11(r3)
   2732c:	1806963a 	slli	r3,r3,24
   27330:	1906b03a 	or	r3,r3,r4
   27334:	1808d63a 	srli	r4,r3,24
   27338:	d0e93c17 	ldw	r3,-23312(gp)
   2733c:	19400203 	ldbu	r5,8(r3)
   27340:	19800243 	ldbu	r6,9(r3)
   27344:	300c923a 	slli	r6,r6,8
   27348:	314ab03a 	or	r5,r6,r5
   2734c:	19800283 	ldbu	r6,10(r3)
   27350:	300c943a 	slli	r6,r6,16
   27354:	314ab03a 	or	r5,r6,r5
   27358:	18c002c3 	ldbu	r3,11(r3)
   2735c:	1806963a 	slli	r3,r3,24
   27360:	1946b03a 	or	r3,r3,r5
   27364:	1806d23a 	srli	r3,r3,8
   27368:	18ffc00c 	andi	r3,r3,65280
   2736c:	20c8b03a 	or	r4,r4,r3
   27370:	d0e93c17 	ldw	r3,-23312(gp)
   27374:	19400203 	ldbu	r5,8(r3)
   27378:	19800243 	ldbu	r6,9(r3)
   2737c:	300c923a 	slli	r6,r6,8
   27380:	314ab03a 	or	r5,r6,r5
   27384:	19800283 	ldbu	r6,10(r3)
   27388:	300c943a 	slli	r6,r6,16
   2738c:	314ab03a 	or	r5,r6,r5
   27390:	18c002c3 	ldbu	r3,11(r3)
   27394:	1806963a 	slli	r3,r3,24
   27398:	1946b03a 	or	r3,r3,r5
   2739c:	18ffc00c 	andi	r3,r3,65280
   273a0:	1806923a 	slli	r3,r3,8
   273a4:	20c8b03a 	or	r4,r4,r3
   273a8:	d0e93c17 	ldw	r3,-23312(gp)
   273ac:	19400203 	ldbu	r5,8(r3)
   273b0:	19800243 	ldbu	r6,9(r3)
   273b4:	300c923a 	slli	r6,r6,8
   273b8:	314ab03a 	or	r5,r6,r5
   273bc:	19800283 	ldbu	r6,10(r3)
   273c0:	300c943a 	slli	r6,r6,16
   273c4:	314ab03a 	or	r5,r6,r5
   273c8:	18c002c3 	ldbu	r3,11(r3)
   273cc:	1806963a 	slli	r3,r3,24
   273d0:	1946b03a 	or	r3,r3,r5
   273d4:	1806963a 	slli	r3,r3,24
   273d8:	20c6b03a 	or	r3,r4,r3
   273dc:	19003fcc 	andi	r4,r3,255
   273e0:	11400203 	ldbu	r5,8(r2)
   273e4:	280a703a 	and	r5,r5,zero
   273e8:	2908b03a 	or	r4,r5,r4
   273ec:	11000205 	stb	r4,8(r2)
   273f0:	1808d23a 	srli	r4,r3,8
   273f4:	21003fcc 	andi	r4,r4,255
   273f8:	11400243 	ldbu	r5,9(r2)
   273fc:	280a703a 	and	r5,r5,zero
   27400:	2908b03a 	or	r4,r5,r4
   27404:	11000245 	stb	r4,9(r2)
   27408:	1808d43a 	srli	r4,r3,16
   2740c:	21003fcc 	andi	r4,r4,255
   27410:	11400283 	ldbu	r5,10(r2)
   27414:	280a703a 	and	r5,r5,zero
   27418:	2908b03a 	or	r4,r5,r4
   2741c:	11000285 	stb	r4,10(r2)
   27420:	1806d63a 	srli	r3,r3,24
   27424:	110002c3 	ldbu	r4,11(r2)
   27428:	2008703a 	and	r4,r4,zero
   2742c:	20c6b03a 	or	r3,r4,r3
   27430:	10c002c5 	stb	r3,11(r2)
   27434:	10c00203 	ldbu	r3,8(r2)
   27438:	11000243 	ldbu	r4,9(r2)
   2743c:	2008923a 	slli	r4,r4,8
   27440:	20c6b03a 	or	r3,r4,r3
   27444:	11000283 	ldbu	r4,10(r2)
   27448:	2008943a 	slli	r4,r4,16
   2744c:	20c6b03a 	or	r3,r4,r3
   27450:	108002c3 	ldbu	r2,11(r2)
   27454:	1004963a 	slli	r2,r2,24
   27458:	10c4b03a 	or	r2,r2,r3
   2745c:	d0a93f15 	stw	r2,-23300(gp)
  tcphdr->wnd = ntohs(tcphdr->wnd);
   27460:	d0a93c17 	ldw	r2,-23312(gp)
   27464:	d0e93c17 	ldw	r3,-23312(gp)
   27468:	19000383 	ldbu	r4,14(r3)
   2746c:	18c003c3 	ldbu	r3,15(r3)
   27470:	1806923a 	slli	r3,r3,8
   27474:	1906b03a 	or	r3,r3,r4
   27478:	18ffffcc 	andi	r3,r3,65535
   2747c:	1806d23a 	srli	r3,r3,8
   27480:	1809883a 	mov	r4,r3
   27484:	d0e93c17 	ldw	r3,-23312(gp)
   27488:	19400383 	ldbu	r5,14(r3)
   2748c:	18c003c3 	ldbu	r3,15(r3)
   27490:	1806923a 	slli	r3,r3,8
   27494:	1946b03a 	or	r3,r3,r5
   27498:	18ffffcc 	andi	r3,r3,65535
   2749c:	1806923a 	slli	r3,r3,8
   274a0:	20c6b03a 	or	r3,r4,r3
   274a4:	193fffcc 	andi	r4,r3,65535
   274a8:	21003fcc 	andi	r4,r4,255
   274ac:	11400383 	ldbu	r5,14(r2)
   274b0:	280a703a 	and	r5,r5,zero
   274b4:	2908b03a 	or	r4,r5,r4
   274b8:	11000385 	stb	r4,14(r2)
   274bc:	18ffffcc 	andi	r3,r3,65535
   274c0:	1806d23a 	srli	r3,r3,8
   274c4:	18ffffcc 	andi	r3,r3,65535
   274c8:	110003c3 	ldbu	r4,15(r2)
   274cc:	2008703a 	and	r4,r4,zero
   274d0:	20c6b03a 	or	r3,r4,r3
   274d4:	10c003c5 	stb	r3,15(r2)

  flags = TCPH_FLAGS(tcphdr);
   274d8:	d0a93c17 	ldw	r2,-23312(gp)
   274dc:	10c00303 	ldbu	r3,12(r2)
   274e0:	10800343 	ldbu	r2,13(r2)
   274e4:	1004923a 	slli	r2,r2,8
   274e8:	10c4b03a 	or	r2,r2,r3
   274ec:	10bfffcc 	andi	r2,r2,65535
   274f0:	1004d23a 	srli	r2,r2,8
   274f4:	1007883a 	mov	r3,r2
   274f8:	d0a93c17 	ldw	r2,-23312(gp)
   274fc:	11000303 	ldbu	r4,12(r2)
   27500:	10800343 	ldbu	r2,13(r2)
   27504:	1004923a 	slli	r2,r2,8
   27508:	1104b03a 	or	r2,r2,r4
   2750c:	10bfffcc 	andi	r2,r2,65535
   27510:	1004923a 	slli	r2,r2,8
   27514:	1884b03a 	or	r2,r3,r2
   27518:	10800fcc 	andi	r2,r2,63
   2751c:	d0a94005 	stb	r2,-23296(gp)
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
   27520:	e0bffe17 	ldw	r2,-8(fp)
   27524:	10c0020b 	ldhu	r3,8(r2)
   27528:	d0a94003 	ldbu	r2,-23296(gp)
   2752c:	10803fcc 	andi	r2,r2,255
   27530:	108000cc 	andi	r2,r2,3
   27534:	1004c03a 	cmpne	r2,r2,zero
   27538:	10803fcc 	andi	r2,r2,255
   2753c:	1885883a 	add	r2,r3,r2
   27540:	d0a9408d 	sth	r2,-23294(gp)

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
   27544:	e03ff915 	stw	zero,-28(fp)

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
   27548:	00800134 	movhi	r2,4
   2754c:	109ef204 	addi	r2,r2,31688
   27550:	10800017 	ldw	r2,0(r2)
   27554:	e0bff815 	stw	r2,-32(fp)
   27558:	00003506 	br	27630 <tcp_input+0x798>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
   2755c:	e0bff817 	ldw	r2,-32(fp)
   27560:	10c0080b 	ldhu	r3,32(r2)
   27564:	d0a93c17 	ldw	r2,-23312(gp)
   27568:	11000003 	ldbu	r4,0(r2)
   2756c:	10800043 	ldbu	r2,1(r2)
   27570:	1004923a 	slli	r2,r2,8
   27574:	1104b03a 	or	r2,r2,r4
   27578:	18ffffcc 	andi	r3,r3,65535
   2757c:	10bfffcc 	andi	r2,r2,65535
   27580:	1880261e 	bne	r3,r2,2761c <tcp_input+0x784>
       pcb->local_port == tcphdr->dest &&
   27584:	e0bff817 	ldw	r2,-32(fp)
   27588:	10c0078b 	ldhu	r3,30(r2)
   2758c:	d0a93c17 	ldw	r2,-23312(gp)
   27590:	11000083 	ldbu	r4,2(r2)
   27594:	108000c3 	ldbu	r2,3(r2)
   27598:	1004923a 	slli	r2,r2,8
   2759c:	1104b03a 	or	r2,r2,r4
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
   275a0:	18ffffcc 	andi	r3,r3,65535
   275a4:	10bfffcc 	andi	r2,r2,65535
   275a8:	18801c1e 	bne	r3,r2,2761c <tcp_input+0x784>
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
   275ac:	e0bff817 	ldw	r2,-32(fp)
   275b0:	10c00117 	ldw	r3,4(r2)
   275b4:	00800134 	movhi	r2,4
   275b8:	109ee204 	addi	r2,r2,31624
   275bc:	10800017 	ldw	r2,0(r2)
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
   275c0:	1880161e 	bne	r3,r2,2761c <tcp_input+0x784>
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
       ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
   275c4:	e0bff817 	ldw	r2,-32(fp)
   275c8:	10c00017 	ldw	r3,0(r2)
   275cc:	00800134 	movhi	r2,4
   275d0:	109ee404 	addi	r2,r2,31632
   275d4:	10800017 	ldw	r2,0(r2)
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
   275d8:	1880101e 	bne	r3,r2,2761c <tcp_input+0x784>

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
      if (prev != NULL) {
   275dc:	e0bff917 	ldw	r2,-28(fp)
   275e0:	10001626 	beq	r2,zero,2763c <tcp_input+0x7a4>
        prev->next = pcb->next;
   275e4:	e0bff817 	ldw	r2,-32(fp)
   275e8:	10c00317 	ldw	r3,12(r2)
   275ec:	e0bff917 	ldw	r2,-28(fp)
   275f0:	10c00315 	stw	r3,12(r2)
        pcb->next = tcp_active_pcbs;
   275f4:	00800134 	movhi	r2,4
   275f8:	109ef204 	addi	r2,r2,31688
   275fc:	10c00017 	ldw	r3,0(r2)
   27600:	e0bff817 	ldw	r2,-32(fp)
   27604:	10c00315 	stw	r3,12(r2)
        tcp_active_pcbs = pcb;
   27608:	00800134 	movhi	r2,4
   2760c:	109ef204 	addi	r2,r2,31688
   27610:	e0fff817 	ldw	r3,-32(fp)
   27614:	10c00015 	stw	r3,0(r2)
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
      break;
   27618:	00000806 	br	2763c <tcp_input+0x7a4>
    }
    prev = pcb;
   2761c:	e0bff817 	ldw	r2,-32(fp)
   27620:	e0bff915 	stw	r2,-28(fp)
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
   27624:	e0bff817 	ldw	r2,-32(fp)
   27628:	10800317 	ldw	r2,12(r2)
   2762c:	e0bff815 	stw	r2,-32(fp)
   27630:	e0bff817 	ldw	r2,-32(fp)
   27634:	103fc91e 	bne	r2,zero,2755c <tcp_input+0x6c4>
   27638:	00000106 	br	27640 <tcp_input+0x7a8>
        prev->next = pcb->next;
        pcb->next = tcp_active_pcbs;
        tcp_active_pcbs = pcb;
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
      break;
   2763c:	0001883a 	nop
    }
    prev = pcb;
  }

  if (pcb == NULL) {
   27640:	e0bff817 	ldw	r2,-32(fp)
   27644:	1000731e 	bne	r2,zero,27814 <tcp_input+0x97c>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
   27648:	00800134 	movhi	r2,4
   2764c:	109ef704 	addi	r2,r2,31708
   27650:	10800017 	ldw	r2,0(r2)
   27654:	e0bff815 	stw	r2,-32(fp)
   27658:	00002806 	br	276fc <tcp_input+0x864>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
   2765c:	e0bff817 	ldw	r2,-32(fp)
   27660:	10c0080b 	ldhu	r3,32(r2)
   27664:	d0a93c17 	ldw	r2,-23312(gp)
   27668:	11000003 	ldbu	r4,0(r2)
   2766c:	10800043 	ldbu	r2,1(r2)
   27670:	1004923a 	slli	r2,r2,8
   27674:	1104b03a 	or	r2,r2,r4
   27678:	18ffffcc 	andi	r3,r3,65535
   2767c:	10bfffcc 	andi	r2,r2,65535
   27680:	18801b1e 	bne	r3,r2,276f0 <tcp_input+0x858>
         pcb->local_port == tcphdr->dest &&
   27684:	e0bff817 	ldw	r2,-32(fp)
   27688:	10c0078b 	ldhu	r3,30(r2)
   2768c:	d0a93c17 	ldw	r2,-23312(gp)
   27690:	11000083 	ldbu	r4,2(r2)
   27694:	108000c3 	ldbu	r2,3(r2)
   27698:	1004923a 	slli	r2,r2,8
   2769c:	1104b03a 	or	r2,r2,r4
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
   276a0:	18ffffcc 	andi	r3,r3,65535
   276a4:	10bfffcc 	andi	r2,r2,65535
   276a8:	1880111e 	bne	r3,r2,276f0 <tcp_input+0x858>
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
   276ac:	e0bff817 	ldw	r2,-32(fp)
   276b0:	10c00117 	ldw	r3,4(r2)
   276b4:	00800134 	movhi	r2,4
   276b8:	109ee204 	addi	r2,r2,31624
   276bc:	10800017 	ldw	r2,0(r2)
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
   276c0:	18800b1e 	bne	r3,r2,276f0 <tcp_input+0x858>
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
         ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
   276c4:	e0bff817 	ldw	r2,-32(fp)
   276c8:	10c00017 	ldw	r3,0(r2)
   276cc:	00800134 	movhi	r2,4
   276d0:	109ee404 	addi	r2,r2,31632
   276d4:	10800017 	ldw	r2,0(r2)
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
   276d8:	1880051e 	bne	r3,r2,276f0 <tcp_input+0x858>
         ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
   276dc:	e13ff817 	ldw	r4,-32(fp)
   276e0:	00280340 	call	28034 <tcp_timewait_input>
        pbuf_free(p);
   276e4:	e13ffe17 	ldw	r4,-8(fp)
   276e8:	00237600 	call	23760 <pbuf_free>
        return;
   276ec:	00018806 	br	27d10 <tcp_input+0xe78>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
   276f0:	e0bff817 	ldw	r2,-32(fp)
   276f4:	10800317 	ldw	r2,12(r2)
   276f8:	e0bff815 	stw	r2,-32(fp)
   276fc:	e0bff817 	ldw	r2,-32(fp)
   27700:	103fd61e 	bne	r2,zero,2765c <tcp_input+0x7c4>
      }
    }

    /* Finally, if we still did not get a match, we check all PCBs that
       are LISTENing for incoming connections. */
    prev = NULL;
   27704:	e03ff915 	stw	zero,-28(fp)
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
   27708:	00800134 	movhi	r2,4
   2770c:	109ef404 	addi	r2,r2,31696
   27710:	10800017 	ldw	r2,0(r2)
   27714:	e0bffa15 	stw	r2,-24(fp)
   27718:	00001e06 	br	27794 <tcp_input+0x8fc>
      if (lpcb->local_port == tcphdr->dest) {
   2771c:	e0bffa17 	ldw	r2,-24(fp)
   27720:	10c0078b 	ldhu	r3,30(r2)
   27724:	d0a93c17 	ldw	r2,-23312(gp)
   27728:	11000083 	ldbu	r4,2(r2)
   2772c:	108000c3 	ldbu	r2,3(r2)
   27730:	1004923a 	slli	r2,r2,8
   27734:	1104b03a 	or	r2,r2,r4
   27738:	18ffffcc 	andi	r3,r3,65535
   2773c:	10bfffcc 	andi	r2,r2,65535
   27740:	18800f1e 	bne	r3,r2,27780 <tcp_input+0x8e8>
#if SO_REUSE
        if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest)) {
   27744:	e0bffa17 	ldw	r2,-24(fp)
   27748:	10c00017 	ldw	r3,0(r2)
   2774c:	00800134 	movhi	r2,4
   27750:	109ee404 	addi	r2,r2,31632
   27754:	10800017 	ldw	r2,0(r2)
   27758:	18801126 	beq	r3,r2,277a0 <tcp_input+0x908>
          /* found an exact match */
          break;
        } else if(ip_addr_isany(&(lpcb->local_ip))) {
   2775c:	e0bffa17 	ldw	r2,-24(fp)
   27760:	10000326 	beq	r2,zero,27770 <tcp_input+0x8d8>
   27764:	e0bffa17 	ldw	r2,-24(fp)
   27768:	10800017 	ldw	r2,0(r2)
   2776c:	1000041e 	bne	r2,zero,27780 <tcp_input+0x8e8>
          /* found an ANY-match */
          lpcb_any = lpcb;
   27770:	e0bffa17 	ldw	r2,-24(fp)
   27774:	e0bffc15 	stw	r2,-16(fp)
          lpcb_prev = prev;
   27778:	e0bff917 	ldw	r2,-28(fp)
   2777c:	e0bffb15 	stw	r2,-20(fp)
          /* found a match */
          break;
        }
#endif /* SO_REUSE */
      }
      prev = (struct tcp_pcb *)lpcb;
   27780:	e0bffa17 	ldw	r2,-24(fp)
   27784:	e0bff915 	stw	r2,-28(fp)
    }

    /* Finally, if we still did not get a match, we check all PCBs that
       are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
   27788:	e0bffa17 	ldw	r2,-24(fp)
   2778c:	10800317 	ldw	r2,12(r2)
   27790:	e0bffa15 	stw	r2,-24(fp)
   27794:	e0bffa17 	ldw	r2,-24(fp)
   27798:	103fe01e 	bne	r2,zero,2771c <tcp_input+0x884>
   2779c:	00000106 	br	277a4 <tcp_input+0x90c>
      if (lpcb->local_port == tcphdr->dest) {
#if SO_REUSE
        if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest)) {
          /* found an exact match */
          break;
   277a0:	0001883a 	nop
      }
      prev = (struct tcp_pcb *)lpcb;
    }
#if SO_REUSE
    /* first try specific local IP */
    if (lpcb == NULL) {
   277a4:	e0bffa17 	ldw	r2,-24(fp)
   277a8:	1000041e 	bne	r2,zero,277bc <tcp_input+0x924>
      /* only pass to ANY if no specific local IP has been found */
      lpcb = lpcb_any;
   277ac:	e0bffc17 	ldw	r2,-16(fp)
   277b0:	e0bffa15 	stw	r2,-24(fp)
      prev = lpcb_prev;
   277b4:	e0bffb17 	ldw	r2,-20(fp)
   277b8:	e0bff915 	stw	r2,-28(fp)
    }
#endif /* SO_REUSE */
    if (lpcb != NULL) {
   277bc:	e0bffa17 	ldw	r2,-24(fp)
   277c0:	10001426 	beq	r2,zero,27814 <tcp_input+0x97c>
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      if (prev != NULL) {
   277c4:	e0bff917 	ldw	r2,-28(fp)
   277c8:	10000d26 	beq	r2,zero,27800 <tcp_input+0x968>
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
   277cc:	e0bffa17 	ldw	r2,-24(fp)
   277d0:	10c00317 	ldw	r3,12(r2)
   277d4:	e0bff917 	ldw	r2,-28(fp)
   277d8:	10c00315 	stw	r3,12(r2)
              /* our successor is the remainder of the listening list */
        lpcb->next = tcp_listen_pcbs.listen_pcbs;
   277dc:	00800134 	movhi	r2,4
   277e0:	109ef404 	addi	r2,r2,31696
   277e4:	10c00017 	ldw	r3,0(r2)
   277e8:	e0bffa17 	ldw	r2,-24(fp)
   277ec:	10c00315 	stw	r3,12(r2)
              /* put this listening pcb at the head of the listening list */
        tcp_listen_pcbs.listen_pcbs = lpcb;
   277f0:	00800134 	movhi	r2,4
   277f4:	109ef404 	addi	r2,r2,31696
   277f8:	e0fffa17 	ldw	r3,-24(fp)
   277fc:	10c00015 	stw	r3,0(r2)
      }
    
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
      tcp_listen_input(lpcb);
   27800:	e13ffa17 	ldw	r4,-24(fp)
   27804:	0027d240 	call	27d24 <tcp_listen_input>
      pbuf_free(p);
   27808:	e13ffe17 	ldw	r4,-8(fp)
   2780c:	00237600 	call	23760 <pbuf_free>
      return;
   27810:	00013f06 	br	27d10 <tcp_input+0xe78>
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
#endif /* TCP_INPUT_DEBUG */


  if (pcb != NULL) {
   27814:	e0bff817 	ldw	r2,-32(fp)
   27818:	1000f526 	beq	r2,zero,27bf0 <tcp_input+0xd58>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
   2781c:	008001b4 	movhi	r2,6
   27820:	1088d704 	addi	r2,r2,9052
   27824:	10000015 	stw	zero,0(r2)
    inseg.len = p->tot_len;
   27828:	e0bffe17 	ldw	r2,-8(fp)
   2782c:	10c0020b 	ldhu	r3,8(r2)
   27830:	008001b4 	movhi	r2,6
   27834:	1088d704 	addi	r2,r2,9052
   27838:	10c0020d 	sth	r3,8(r2)
    inseg.p = p;
   2783c:	008001b4 	movhi	r2,6
   27840:	1088d704 	addi	r2,r2,9052
   27844:	e0fffe17 	ldw	r3,-8(fp)
   27848:	10c00115 	stw	r3,4(r2)
    inseg.tcphdr = tcphdr;
   2784c:	d0e93c17 	ldw	r3,-23312(gp)
   27850:	008001b4 	movhi	r2,6
   27854:	1088d704 	addi	r2,r2,9052
   27858:	10c00415 	stw	r3,16(r2)

    recv_data = NULL;
   2785c:	d0294215 	stw	zero,-23288(gp)
    recv_flags = 0;
   27860:	d0294105 	stb	zero,-23292(gp)

    if (flags & TCP_PSH) {
   27864:	d0a94003 	ldbu	r2,-23296(gp)
   27868:	10803fcc 	andi	r2,r2,255
   2786c:	1080020c 	andi	r2,r2,8
   27870:	10000626 	beq	r2,zero,2788c <tcp_input+0x9f4>
      p->flags |= PBUF_FLAG_PUSH;
   27874:	e0bffe17 	ldw	r2,-8(fp)
   27878:	10800343 	ldbu	r2,13(r2)
   2787c:	10800054 	ori	r2,r2,1
   27880:	1007883a 	mov	r3,r2
   27884:	e0bffe17 	ldw	r2,-8(fp)
   27888:	10c00345 	stb	r3,13(r2)
    }

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
   2788c:	e0bff817 	ldw	r2,-32(fp)
   27890:	10801f17 	ldw	r2,124(r2)
   27894:	10001526 	beq	r2,zero,278ec <tcp_input+0xa54>
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
   27898:	e13ff817 	ldw	r4,-32(fp)
   2789c:	00263580 	call	26358 <tcp_process_refused_data>
   278a0:	10803fcc 	andi	r2,r2,255
   278a4:	1080201c 	xori	r2,r2,128
   278a8:	10bfe004 	addi	r2,r2,-128
   278ac:	10bffda0 	cmpeqi	r2,r2,-10
   278b0:	1000061e 	bne	r2,zero,278cc <tcp_input+0xa34>
        ((pcb->refused_data != NULL) && (tcplen > 0))) {
   278b4:	e0bff817 	ldw	r2,-32(fp)
   278b8:	10801f17 	ldw	r2,124(r2)
      p->flags |= PBUF_FLAG_PUSH;
    }

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
   278bc:	10000b26 	beq	r2,zero,278ec <tcp_input+0xa54>
        ((pcb->refused_data != NULL) && (tcplen > 0))) {
   278c0:	d0a9408b 	ldhu	r2,-23294(gp)
   278c4:	10bfffcc 	andi	r2,r2,65535
   278c8:	10000826 	beq	r2,zero,278ec <tcp_input+0xa54>
        /* pcb has been aborted or refused data is still refused and the new
           segment contains data */
        TCP_STATS_INC(tcp.drop);
   278cc:	008001f4 	movhi	r2,7
   278d0:	10ac6e04 	addi	r2,r2,-20040
   278d4:	10804b17 	ldw	r2,300(r2)
   278d8:	10c00044 	addi	r3,r2,1
   278dc:	008001f4 	movhi	r2,7
   278e0:	10ac6e04 	addi	r2,r2,-20040
   278e4:	10c04b15 	stw	r3,300(r2)
        snmp_inc_tcpinerrs();
        goto aborted;
   278e8:	0000b206 	br	27bb4 <tcp_input+0xd1c>
      }
    }
    tcp_input_pcb = pcb;
   278ec:	e0bff817 	ldw	r2,-32(fp)
   278f0:	d0a94315 	stw	r2,-23284(gp)
    err = tcp_process(pcb);
   278f4:	e13ff817 	ldw	r4,-32(fp)
   278f8:	00281800 	call	28180 <tcp_process>
   278fc:	e0bffd05 	stb	r2,-12(fp)
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
   27900:	e0bffd07 	ldb	r2,-12(fp)
   27904:	10bffda0 	cmpeqi	r2,r2,-10
   27908:	1000aa1e 	bne	r2,zero,27bb4 <tcp_input+0xd1c>
      if (recv_flags & TF_RESET) {
   2790c:	d0a94103 	ldbu	r2,-23292(gp)
   27910:	10803fcc 	andi	r2,r2,255
   27914:	1080020c 	andi	r2,r2,8
   27918:	10001226 	beq	r2,zero,27964 <tcp_input+0xacc>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
   2791c:	e0bff817 	ldw	r2,-32(fp)
   27920:	10802417 	ldw	r2,144(r2)
   27924:	10000726 	beq	r2,zero,27944 <tcp_input+0xaac>
   27928:	e0bff817 	ldw	r2,-32(fp)
   2792c:	10c02417 	ldw	r3,144(r2)
   27930:	e0bff817 	ldw	r2,-32(fp)
   27934:	10800417 	ldw	r2,16(r2)
   27938:	1009883a 	mov	r4,r2
   2793c:	017ffd44 	movi	r5,-11
   27940:	183ee83a 	callr	r3
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
   27944:	01000134 	movhi	r4,4
   27948:	211ef204 	addi	r4,r4,31688
   2794c:	e17ff817 	ldw	r5,-32(fp)
   27950:	0026c980 	call	26c98 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
   27954:	01000084 	movi	r4,2
   27958:	e17ff817 	ldw	r5,-32(fp)
   2795c:	00225900 	call	22590 <memp_free>
   27960:	00009406 	br	27bb4 <tcp_input+0xd1c>
      } else if (recv_flags & TF_CLOSED) {
   27964:	d0a94103 	ldbu	r2,-23292(gp)
   27968:	10803fcc 	andi	r2,r2,255
   2796c:	1080040c 	andi	r2,r2,16
   27970:	10001726 	beq	r2,zero,279d0 <tcp_input+0xb38>
        /* The connection has been closed and we will deallocate the
           PCB. */
        if (!(pcb->flags & TF_RXCLOSED)) {
   27974:	e0bff817 	ldw	r2,-32(fp)
   27978:	10800883 	ldbu	r2,34(r2)
   2797c:	10803fcc 	andi	r2,r2,255
   27980:	1080040c 	andi	r2,r2,16
   27984:	10000a1e 	bne	r2,zero,279b0 <tcp_input+0xb18>
          /* Connection closed although the application has only shut down the
             tx side: call the PCB's err callback and indicate the closure to
             ensure the application doesn't continue using the PCB. */
          TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
   27988:	e0bff817 	ldw	r2,-32(fp)
   2798c:	10802417 	ldw	r2,144(r2)
   27990:	10000726 	beq	r2,zero,279b0 <tcp_input+0xb18>
   27994:	e0bff817 	ldw	r2,-32(fp)
   27998:	10c02417 	ldw	r3,144(r2)
   2799c:	e0bff817 	ldw	r2,-32(fp)
   279a0:	10800417 	ldw	r2,16(r2)
   279a4:	1009883a 	mov	r4,r2
   279a8:	017ffd04 	movi	r5,-12
   279ac:	183ee83a 	callr	r3
        }
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
   279b0:	01000134 	movhi	r4,4
   279b4:	211ef204 	addi	r4,r4,31688
   279b8:	e17ff817 	ldw	r5,-32(fp)
   279bc:	0026c980 	call	26c98 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
   279c0:	01000084 	movi	r4,2
   279c4:	e17ff817 	ldw	r5,-32(fp)
   279c8:	00225900 	call	22590 <memp_free>
   279cc:	00007906 	br	27bb4 <tcp_input+0xd1c>
      } else {
        err = ERR_OK;
   279d0:	e03ffd05 	stb	zero,-12(fp)
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
   279d4:	e0bff817 	ldw	r2,-32(fp)
   279d8:	10801a0b 	ldhu	r2,104(r2)
   279dc:	10bfffcc 	andi	r2,r2,65535
   279e0:	10001426 	beq	r2,zero,27a34 <tcp_input+0xb9c>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
   279e4:	e0bff817 	ldw	r2,-32(fp)
   279e8:	10802017 	ldw	r2,128(r2)
   279ec:	10000d26 	beq	r2,zero,27a24 <tcp_input+0xb8c>
   279f0:	e0bff817 	ldw	r2,-32(fp)
   279f4:	11c02017 	ldw	r7,128(r2)
   279f8:	e0bff817 	ldw	r2,-32(fp)
   279fc:	10c00417 	ldw	r3,16(r2)
   27a00:	e0bff817 	ldw	r2,-32(fp)
   27a04:	10801a0b 	ldhu	r2,104(r2)
   27a08:	10bfffcc 	andi	r2,r2,65535
   27a0c:	1809883a 	mov	r4,r3
   27a10:	e17ff817 	ldw	r5,-32(fp)
   27a14:	100d883a 	mov	r6,r2
   27a18:	383ee83a 	callr	r7
   27a1c:	e0bffd05 	stb	r2,-12(fp)
   27a20:	00000106 	br	27a28 <tcp_input+0xb90>
   27a24:	e03ffd05 	stb	zero,-12(fp)
          if (err == ERR_ABRT) {
   27a28:	e0bffd07 	ldb	r2,-12(fp)
   27a2c:	10bffd98 	cmpnei	r2,r2,-10
   27a30:	10005b26 	beq	r2,zero,27ba0 <tcp_input+0xd08>
            goto aborted;
          }
        }

        if (recv_data != NULL) {
   27a34:	d0a94217 	ldw	r2,-23288(gp)
   27a38:	10002926 	beq	r2,zero,27ae0 <tcp_input+0xc48>
          LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
          if (pcb->flags & TF_RXCLOSED) {
   27a3c:	e0bff817 	ldw	r2,-32(fp)
   27a40:	10800883 	ldbu	r2,34(r2)
   27a44:	10803fcc 	andi	r2,r2,255
   27a48:	1080040c 	andi	r2,r2,16
   27a4c:	10000626 	beq	r2,zero,27a68 <tcp_input+0xbd0>
            /* received data although already closed -> abort (send RST) to
               notify the remote host that not all data has been processed */
            pbuf_free(recv_data);
   27a50:	d0a94217 	ldw	r2,-23288(gp)
   27a54:	1009883a 	mov	r4,r2
   27a58:	00237600 	call	23760 <pbuf_free>
            tcp_abort(pcb);
   27a5c:	e13ff817 	ldw	r4,-32(fp)
   27a60:	002508c0 	call	2508c <tcp_abort>
            goto aborted;
   27a64:	00005306 	br	27bb4 <tcp_input+0xd1c>
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
   27a68:	e0bff817 	ldw	r2,-32(fp)
   27a6c:	10802117 	ldw	r2,132(r2)
   27a70:	10000c26 	beq	r2,zero,27aa4 <tcp_input+0xc0c>
   27a74:	e0bff817 	ldw	r2,-32(fp)
   27a78:	12002117 	ldw	r8,132(r2)
   27a7c:	e0bff817 	ldw	r2,-32(fp)
   27a80:	10c00417 	ldw	r3,16(r2)
   27a84:	d0a94217 	ldw	r2,-23288(gp)
   27a88:	1809883a 	mov	r4,r3
   27a8c:	e17ff817 	ldw	r5,-32(fp)
   27a90:	100d883a 	mov	r6,r2
   27a94:	000f883a 	mov	r7,zero
   27a98:	403ee83a 	callr	r8
   27a9c:	e0bffd05 	stb	r2,-12(fp)
   27aa0:	00000706 	br	27ac0 <tcp_input+0xc28>
   27aa4:	d0a94217 	ldw	r2,-23288(gp)
   27aa8:	0009883a 	mov	r4,zero
   27aac:	e17ff817 	ldw	r5,-32(fp)
   27ab0:	100d883a 	mov	r6,r2
   27ab4:	000f883a 	mov	r7,zero
   27ab8:	00265ec0 	call	265ec <tcp_recv_null>
   27abc:	e0bffd05 	stb	r2,-12(fp)
          if (err == ERR_ABRT) {
   27ac0:	e0bffd07 	ldb	r2,-12(fp)
   27ac4:	10bffd98 	cmpnei	r2,r2,-10
   27ac8:	10003726 	beq	r2,zero,27ba8 <tcp_input+0xd10>
            goto aborted;
          }

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
   27acc:	e0bffd07 	ldb	r2,-12(fp)
   27ad0:	10000326 	beq	r2,zero,27ae0 <tcp_input+0xc48>
            pcb->refused_data = recv_data;
   27ad4:	d0e94217 	ldw	r3,-23288(gp)
   27ad8:	e0bff817 	ldw	r2,-32(fp)
   27adc:	10c01f15 	stw	r3,124(r2)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
   27ae0:	d0a94103 	ldbu	r2,-23292(gp)
   27ae4:	10803fcc 	andi	r2,r2,255
   27ae8:	1080080c 	andi	r2,r2,32
   27aec:	10002826 	beq	r2,zero,27b90 <tcp_input+0xcf8>
          if (pcb->refused_data != NULL) {
   27af0:	e0bff817 	ldw	r2,-32(fp)
   27af4:	10801f17 	ldw	r2,124(r2)
   27af8:	10000826 	beq	r2,zero,27b1c <tcp_input+0xc84>
            /* Delay this if we have refused data. */
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
   27afc:	e0bff817 	ldw	r2,-32(fp)
   27b00:	10801f17 	ldw	r2,124(r2)
   27b04:	e0fff817 	ldw	r3,-32(fp)
   27b08:	18c01f17 	ldw	r3,124(r3)
   27b0c:	18c00343 	ldbu	r3,13(r3)
   27b10:	18c00814 	ori	r3,r3,32
   27b14:	10c00345 	stb	r3,13(r2)
   27b18:	00001d06 	br	27b90 <tcp_input+0xcf8>
          } else {
            /* correct rcv_wnd as the application won't call tcp_recved()
               for the FIN's seqno */
            if (pcb->rcv_wnd != TCP_WND) {
   27b1c:	e0bff817 	ldw	r2,-32(fp)
   27b20:	10800c0b 	ldhu	r2,48(r2)
   27b24:	10bfffcc 	andi	r2,r2,65535
   27b28:	10880020 	cmpeqi	r2,r2,8192
   27b2c:	1000061e 	bne	r2,zero,27b48 <tcp_input+0xcb0>
              pcb->rcv_wnd++;
   27b30:	e0bff817 	ldw	r2,-32(fp)
   27b34:	10800c0b 	ldhu	r2,48(r2)
   27b38:	10800044 	addi	r2,r2,1
   27b3c:	1007883a 	mov	r3,r2
   27b40:	e0bff817 	ldw	r2,-32(fp)
   27b44:	10c00c0d 	sth	r3,48(r2)
            }
            TCP_EVENT_CLOSED(pcb, err);
   27b48:	e0bff817 	ldw	r2,-32(fp)
   27b4c:	10802117 	ldw	r2,132(r2)
   27b50:	10000b26 	beq	r2,zero,27b80 <tcp_input+0xce8>
   27b54:	e0bff817 	ldw	r2,-32(fp)
   27b58:	10c02117 	ldw	r3,132(r2)
   27b5c:	e0bff817 	ldw	r2,-32(fp)
   27b60:	10800417 	ldw	r2,16(r2)
   27b64:	1009883a 	mov	r4,r2
   27b68:	e17ff817 	ldw	r5,-32(fp)
   27b6c:	000d883a 	mov	r6,zero
   27b70:	000f883a 	mov	r7,zero
   27b74:	183ee83a 	callr	r3
   27b78:	e0bffd05 	stb	r2,-12(fp)
   27b7c:	00000106 	br	27b84 <tcp_input+0xcec>
   27b80:	e03ffd05 	stb	zero,-12(fp)
            if (err == ERR_ABRT) {
   27b84:	e0bffd07 	ldb	r2,-12(fp)
   27b88:	10bffd98 	cmpnei	r2,r2,-10
   27b8c:	10000826 	beq	r2,zero,27bb0 <tcp_input+0xd18>
              goto aborted;
            }
          }
        }

        tcp_input_pcb = NULL;
   27b90:	d0294315 	stw	zero,-23284(gp)
        /* Try to send something out. */
        tcp_output(pcb);
   27b94:	e13ff817 	ldw	r4,-32(fp)
   27b98:	002c9d00 	call	2c9d0 <tcp_output>
   27b9c:	00000506 	br	27bb4 <tcp_input+0xd1c>
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
          TCP_EVENT_SENT(pcb, pcb->acked, err);
          if (err == ERR_ABRT) {
            goto aborted;
   27ba0:	0001883a 	nop
   27ba4:	00000306 	br	27bb4 <tcp_input+0xd1c>
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
          if (err == ERR_ABRT) {
            goto aborted;
   27ba8:	0001883a 	nop
   27bac:	00000106 	br	27bb4 <tcp_input+0xd1c>
            if (pcb->rcv_wnd != TCP_WND) {
              pcb->rcv_wnd++;
            }
            TCP_EVENT_CLOSED(pcb, err);
            if (err == ERR_ABRT) {
              goto aborted;
   27bb0:	0001883a 	nop
      }
    }
    /* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).
       Below this line, 'pcb' may not be dereferenced! */
aborted:
    tcp_input_pcb = NULL;
   27bb4:	d0294315 	stw	zero,-23284(gp)
    recv_data = NULL;
   27bb8:	d0294215 	stw	zero,-23288(gp)

    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
   27bbc:	008001b4 	movhi	r2,6
   27bc0:	1088d704 	addi	r2,r2,9052
   27bc4:	10800117 	ldw	r2,4(r2)
   27bc8:	10005026 	beq	r2,zero,27d0c <tcp_input+0xe74>
    {
      pbuf_free(inseg.p);
   27bcc:	008001b4 	movhi	r2,6
   27bd0:	1088d704 	addi	r2,r2,9052
   27bd4:	10800117 	ldw	r2,4(r2)
   27bd8:	1009883a 	mov	r4,r2
   27bdc:	00237600 	call	23760 <pbuf_free>
      inseg.p = NULL;
   27be0:	008001b4 	movhi	r2,6
   27be4:	1088d704 	addi	r2,r2,9052
   27be8:	10000115 	stw	zero,4(r2)
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
   27bec:	00004706 	br	27d0c <tcp_input+0xe74>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
   27bf0:	d0a93c17 	ldw	r2,-23312(gp)
   27bf4:	10c00303 	ldbu	r3,12(r2)
   27bf8:	10800343 	ldbu	r2,13(r2)
   27bfc:	1004923a 	slli	r2,r2,8
   27c00:	10c4b03a 	or	r2,r2,r3
   27c04:	10bfffcc 	andi	r2,r2,65535
   27c08:	1004d23a 	srli	r2,r2,8
   27c0c:	10ffffcc 	andi	r3,r2,65535
   27c10:	d0a93c17 	ldw	r2,-23312(gp)
   27c14:	11000303 	ldbu	r4,12(r2)
   27c18:	10800343 	ldbu	r2,13(r2)
   27c1c:	1004923a 	slli	r2,r2,8
   27c20:	1104b03a 	or	r2,r2,r4
   27c24:	10bfffcc 	andi	r2,r2,65535
   27c28:	1004923a 	slli	r2,r2,8
   27c2c:	10bfffcc 	andi	r2,r2,65535
   27c30:	1884b03a 	or	r2,r3,r2
   27c34:	1080010c 	andi	r2,r2,4
   27c38:	1000271e 	bne	r2,zero,27cd8 <tcp_input+0xe40>
      TCP_STATS_INC(tcp.proterr);
   27c3c:	008001f4 	movhi	r2,7
   27c40:	10ac6e04 	addi	r2,r2,-20040
   27c44:	10805017 	ldw	r2,320(r2)
   27c48:	10c00044 	addi	r3,r2,1
   27c4c:	008001f4 	movhi	r2,7
   27c50:	10ac6e04 	addi	r2,r2,-20040
   27c54:	10c05015 	stw	r3,320(r2)
      TCP_STATS_INC(tcp.drop);
   27c58:	008001f4 	movhi	r2,7
   27c5c:	10ac6e04 	addi	r2,r2,-20040
   27c60:	10804b17 	ldw	r2,300(r2)
   27c64:	10c00044 	addi	r3,r2,1
   27c68:	008001f4 	movhi	r2,7
   27c6c:	10ac6e04 	addi	r2,r2,-20040
   27c70:	10c04b15 	stw	r3,300(r2)
      tcp_rst(ackno, seqno + tcplen,
   27c74:	d1293f17 	ldw	r4,-23300(gp)
   27c78:	d0a9408b 	ldhu	r2,-23294(gp)
   27c7c:	10ffffcc 	andi	r3,r2,65535
   27c80:	d0a93e17 	ldw	r2,-23304(gp)
   27c84:	1887883a 	add	r3,r3,r2
        ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
   27c88:	d0a93c17 	ldw	r2,-23312(gp)
   27c8c:	11400083 	ldbu	r5,2(r2)
   27c90:	108000c3 	ldbu	r2,3(r2)
   27c94:	1004923a 	slli	r2,r2,8
   27c98:	1144b03a 	or	r2,r2,r5
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
   27c9c:	117fffcc 	andi	r5,r2,65535
        ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
   27ca0:	d0a93c17 	ldw	r2,-23312(gp)
   27ca4:	11800003 	ldbu	r6,0(r2)
   27ca8:	10800043 	ldbu	r2,1(r2)
   27cac:	1004923a 	slli	r2,r2,8
   27cb0:	1184b03a 	or	r2,r2,r6
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
   27cb4:	10bfffcc 	andi	r2,r2,65535
   27cb8:	d9400015 	stw	r5,0(sp)
   27cbc:	d8800115 	stw	r2,4(sp)
   27cc0:	180b883a 	mov	r5,r3
   27cc4:	01800134 	movhi	r6,4
   27cc8:	319ee404 	addi	r6,r6,31632
   27ccc:	01c00134 	movhi	r7,4
   27cd0:	39dee204 	addi	r7,r7,31624
   27cd4:	002da300 	call	2da30 <tcp_rst>
        ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
   27cd8:	e13ffe17 	ldw	r4,-8(fp)
   27cdc:	00237600 	call	23760 <pbuf_free>
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
   27ce0:	00000a06 	br	27d0c <tcp_input+0xe74>
dropped:
  TCP_STATS_INC(tcp.drop);
   27ce4:	008001f4 	movhi	r2,7
   27ce8:	10ac6e04 	addi	r2,r2,-20040
   27cec:	10804b17 	ldw	r2,300(r2)
   27cf0:	10c00044 	addi	r3,r2,1
   27cf4:	008001f4 	movhi	r2,7
   27cf8:	10ac6e04 	addi	r2,r2,-20040
   27cfc:	10c04b15 	stw	r3,300(r2)
  snmp_inc_tcpinerrs();
  pbuf_free(p);
   27d00:	e13ffe17 	ldw	r4,-8(fp)
   27d04:	00237600 	call	23760 <pbuf_free>
   27d08:	00000106 	br	27d10 <tcp_input+0xe78>
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
   27d0c:	0001883a 	nop
dropped:
  TCP_STATS_INC(tcp.drop);
  snmp_inc_tcpinerrs();
  pbuf_free(p);
}
   27d10:	e037883a 	mov	sp,fp
   27d14:	dfc00117 	ldw	ra,4(sp)
   27d18:	df000017 	ldw	fp,0(sp)
   27d1c:	dec00204 	addi	sp,sp,8
   27d20:	f800283a 	ret

00027d24 <tcp_listen_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
   27d24:	defff904 	addi	sp,sp,-28
   27d28:	dfc00615 	stw	ra,24(sp)
   27d2c:	df000515 	stw	fp,20(sp)
   27d30:	df000504 	addi	fp,sp,20
   27d34:	e13fff15 	stw	r4,-4(fp)
  struct tcp_pcb *npcb;
  err_t rc;

  if (flags & TCP_RST) {
   27d38:	d0a94003 	ldbu	r2,-23296(gp)
   27d3c:	10803fcc 	andi	r2,r2,255
   27d40:	1080010c 	andi	r2,r2,4
   27d44:	10000226 	beq	r2,zero,27d50 <tcp_listen_input+0x2c>
    /* An incoming RST should be ignored. Return. */
    return ERR_OK;
   27d48:	0005883a 	mov	r2,zero
   27d4c:	0000b406 	br	28020 <tcp_listen_input+0x2fc>
  }

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
   27d50:	d0a94003 	ldbu	r2,-23296(gp)
   27d54:	10803fcc 	andi	r2,r2,255
   27d58:	1080040c 	andi	r2,r2,16
   27d5c:	10001a26 	beq	r2,zero,27dc8 <tcp_listen_input+0xa4>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
   27d60:	d1293f17 	ldw	r4,-23300(gp)
   27d64:	d0a9408b 	ldhu	r2,-23294(gp)
   27d68:	10ffffcc 	andi	r3,r2,65535
   27d6c:	d0a93e17 	ldw	r2,-23304(gp)
   27d70:	1887883a 	add	r3,r3,r2
      ip_current_src_addr(), tcphdr->dest, tcphdr->src);
   27d74:	d0a93c17 	ldw	r2,-23312(gp)
   27d78:	11400083 	ldbu	r5,2(r2)
   27d7c:	108000c3 	ldbu	r2,3(r2)
   27d80:	1004923a 	slli	r2,r2,8
   27d84:	1144b03a 	or	r2,r2,r5
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
   27d88:	117fffcc 	andi	r5,r2,65535
      ip_current_src_addr(), tcphdr->dest, tcphdr->src);
   27d8c:	d0a93c17 	ldw	r2,-23312(gp)
   27d90:	11800003 	ldbu	r6,0(r2)
   27d94:	10800043 	ldbu	r2,1(r2)
   27d98:	1004923a 	slli	r2,r2,8
   27d9c:	1184b03a 	or	r2,r2,r6
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
   27da0:	10bfffcc 	andi	r2,r2,65535
   27da4:	d9400015 	stw	r5,0(sp)
   27da8:	d8800115 	stw	r2,4(sp)
   27dac:	180b883a 	mov	r5,r3
   27db0:	01800134 	movhi	r6,4
   27db4:	319ee404 	addi	r6,r6,31632
   27db8:	01c00134 	movhi	r7,4
   27dbc:	39dee204 	addi	r7,r7,31624
   27dc0:	002da300 	call	2da30 <tcp_rst>
   27dc4:	00009506 	br	2801c <tcp_listen_input+0x2f8>
      ip_current_src_addr(), tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
   27dc8:	d0a94003 	ldbu	r2,-23296(gp)
   27dcc:	10803fcc 	andi	r2,r2,255
   27dd0:	1080008c 	andi	r2,r2,2
   27dd4:	10009126 	beq	r2,zero,2801c <tcp_listen_input+0x2f8>
    LWIP_DEBUGF(TCP_DEBUG, ("TCP connection request %"U16_F" -> %"U16_F".\n", tcphdr->src, tcphdr->dest));
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
   27dd8:	e0bfff17 	ldw	r2,-4(fp)
   27ddc:	10c00843 	ldbu	r3,33(r2)
   27de0:	e0bfff17 	ldw	r2,-4(fp)
   27de4:	10800803 	ldbu	r2,32(r2)
   27de8:	18c03fcc 	andi	r3,r3,255
   27dec:	10803fcc 	andi	r2,r2,255
   27df0:	18800236 	bltu	r3,r2,27dfc <tcp_listen_input+0xd8>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: listen backlog exceeded for port %"U16_F"\n", tcphdr->dest));
      return ERR_ABRT;
   27df4:	00bffd84 	movi	r2,-10
   27df8:	00008906 	br	28020 <tcp_listen_input+0x2fc>
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
   27dfc:	e0bfff17 	ldw	r2,-4(fp)
   27e00:	10800703 	ldbu	r2,28(r2)
   27e04:	10803fcc 	andi	r2,r2,255
   27e08:	1009883a 	mov	r4,r2
   27e0c:	00267cc0 	call	267cc <tcp_alloc>
   27e10:	e0bffd15 	stw	r2,-12(fp)
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
   27e14:	e0bffd17 	ldw	r2,-12(fp)
   27e18:	1000091e 	bne	r2,zero,27e40 <tcp_listen_input+0x11c>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
      TCP_STATS_INC(tcp.memerr);
   27e1c:	008001f4 	movhi	r2,7
   27e20:	10ac6e04 	addi	r2,r2,-20040
   27e24:	10804e17 	ldw	r2,312(r2)
   27e28:	10c00044 	addi	r3,r2,1
   27e2c:	008001f4 	movhi	r2,7
   27e30:	10ac6e04 	addi	r2,r2,-20040
   27e34:	10c04e15 	stw	r3,312(r2)
      return ERR_MEM;
   27e38:	00bfffc4 	movi	r2,-1
   27e3c:	00007806 	br	28020 <tcp_listen_input+0x2fc>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
   27e40:	e0bfff17 	ldw	r2,-4(fp)
   27e44:	10800843 	ldbu	r2,33(r2)
   27e48:	10800044 	addi	r2,r2,1
   27e4c:	1007883a 	mov	r3,r2
   27e50:	e0bfff17 	ldw	r2,-4(fp)
   27e54:	10c00845 	stb	r3,33(r2)
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
   27e58:	00800134 	movhi	r2,4
   27e5c:	109ee404 	addi	r2,r2,31632
   27e60:	10c00017 	ldw	r3,0(r2)
   27e64:	e0bffd17 	ldw	r2,-12(fp)
   27e68:	10c00015 	stw	r3,0(r2)
    npcb->local_port = pcb->local_port;
   27e6c:	e0bfff17 	ldw	r2,-4(fp)
   27e70:	10c0078b 	ldhu	r3,30(r2)
   27e74:	e0bffd17 	ldw	r2,-12(fp)
   27e78:	10c0078d 	sth	r3,30(r2)
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
   27e7c:	00800134 	movhi	r2,4
   27e80:	109ee204 	addi	r2,r2,31624
   27e84:	10c00017 	ldw	r3,0(r2)
   27e88:	e0bffd17 	ldw	r2,-12(fp)
   27e8c:	10c00115 	stw	r3,4(r2)
    npcb->remote_port = tcphdr->src;
   27e90:	d0a93c17 	ldw	r2,-23312(gp)
   27e94:	10c00003 	ldbu	r3,0(r2)
   27e98:	10800043 	ldbu	r2,1(r2)
   27e9c:	1004923a 	slli	r2,r2,8
   27ea0:	10c4b03a 	or	r2,r2,r3
   27ea4:	1007883a 	mov	r3,r2
   27ea8:	e0bffd17 	ldw	r2,-12(fp)
   27eac:	10c0080d 	sth	r3,32(r2)
    npcb->state = SYN_RCVD;
   27eb0:	e0bffd17 	ldw	r2,-12(fp)
   27eb4:	00c000c4 	movi	r3,3
   27eb8:	10c00615 	stw	r3,24(r2)
    npcb->rcv_nxt = seqno + 1;
   27ebc:	d0a93e17 	ldw	r2,-23304(gp)
   27ec0:	10c00044 	addi	r3,r2,1
   27ec4:	e0bffd17 	ldw	r2,-12(fp)
   27ec8:	10c00b15 	stw	r3,44(r2)
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
   27ecc:	e0bffd17 	ldw	r2,-12(fp)
   27ed0:	10c00b17 	ldw	r3,44(r2)
   27ed4:	e0bffd17 	ldw	r2,-12(fp)
   27ed8:	10c00d15 	stw	r3,52(r2)
    npcb->snd_wnd = tcphdr->wnd;
   27edc:	d0a93c17 	ldw	r2,-23312(gp)
   27ee0:	10c00383 	ldbu	r3,14(r2)
   27ee4:	108003c3 	ldbu	r2,15(r2)
   27ee8:	1004923a 	slli	r2,r2,8
   27eec:	10c4b03a 	or	r2,r2,r3
   27ef0:	1007883a 	mov	r3,r2
   27ef4:	e0bffd17 	ldw	r2,-12(fp)
   27ef8:	10c0190d 	sth	r3,100(r2)
    npcb->snd_wnd_max = tcphdr->wnd;
   27efc:	d0a93c17 	ldw	r2,-23312(gp)
   27f00:	10c00383 	ldbu	r3,14(r2)
   27f04:	108003c3 	ldbu	r2,15(r2)
   27f08:	1004923a 	slli	r2,r2,8
   27f0c:	10c4b03a 	or	r2,r2,r3
   27f10:	1007883a 	mov	r3,r2
   27f14:	e0bffd17 	ldw	r2,-12(fp)
   27f18:	10c0198d 	sth	r3,102(r2)
    npcb->ssthresh = npcb->snd_wnd;
   27f1c:	e0bffd17 	ldw	r2,-12(fp)
   27f20:	10c0190b 	ldhu	r3,100(r2)
   27f24:	e0bffd17 	ldw	r2,-12(fp)
   27f28:	10c0148d 	sth	r3,82(r2)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
   27f2c:	d0a93e17 	ldw	r2,-23304(gp)
   27f30:	10ffffc4 	addi	r3,r2,-1
   27f34:	e0bffd17 	ldw	r2,-12(fp)
   27f38:	10c01615 	stw	r3,88(r2)
    npcb->callback_arg = pcb->callback_arg;
   27f3c:	e0bfff17 	ldw	r2,-4(fp)
   27f40:	10c00417 	ldw	r3,16(r2)
   27f44:	e0bffd17 	ldw	r2,-12(fp)
   27f48:	10c00415 	stw	r3,16(r2)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
   27f4c:	e0bfff17 	ldw	r2,-4(fp)
   27f50:	10c00517 	ldw	r3,20(r2)
   27f54:	e0bffd17 	ldw	r2,-12(fp)
   27f58:	10c00515 	stw	r3,20(r2)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & SOF_INHERITED;
   27f5c:	e0bfff17 	ldw	r2,-4(fp)
   27f60:	10c00203 	ldbu	r3,8(r2)
   27f64:	00bfe304 	movi	r2,-116
   27f68:	1884703a 	and	r2,r3,r2
   27f6c:	1007883a 	mov	r3,r2
   27f70:	e0bffd17 	ldw	r2,-12(fp)
   27f74:	10c00205 	stb	r3,8(r2)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG_ACTIVE(npcb);
   27f78:	00800134 	movhi	r2,4
   27f7c:	109ef204 	addi	r2,r2,31688
   27f80:	10c00017 	ldw	r3,0(r2)
   27f84:	e0bffd17 	ldw	r2,-12(fp)
   27f88:	10c00315 	stw	r3,12(r2)
   27f8c:	00800134 	movhi	r2,4
   27f90:	109ef204 	addi	r2,r2,31688
   27f94:	e0fffd17 	ldw	r3,-12(fp)
   27f98:	10c00015 	stw	r3,0(r2)
   27f9c:	002e6bc0 	call	2e6bc <tcp_timer_needed>
   27fa0:	00800134 	movhi	r2,4
   27fa4:	109ef184 	addi	r2,r2,31686
   27fa8:	00c00044 	movi	r3,1
   27fac:	10c00005 	stb	r3,0(r2)

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
   27fb0:	e13ffd17 	ldw	r4,-12(fp)
   27fb4:	002af900 	call	2af90 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->local_ip), &(npcb->remote_ip));
   27fb8:	e0bffd17 	ldw	r2,-12(fp)
   27fbc:	10800e8b 	ldhu	r2,58(r2)
   27fc0:	113fffcc 	andi	r4,r2,65535
   27fc4:	e0fffd17 	ldw	r3,-12(fp)
   27fc8:	e0bffd17 	ldw	r2,-12(fp)
   27fcc:	10800104 	addi	r2,r2,4
   27fd0:	180b883a 	mov	r5,r3
   27fd4:	100d883a 	mov	r6,r2
   27fd8:	0026dd00 	call	26dd0 <tcp_eff_send_mss>
   27fdc:	e0fffd17 	ldw	r3,-12(fp)
   27fe0:	18800e8d 	sth	r2,58(r3)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Send a SYN|ACK together with the MSS option. */
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
   27fe4:	e13ffd17 	ldw	r4,-12(fp)
   27fe8:	01400484 	movi	r5,18
   27fec:	002c55c0 	call	2c55c <tcp_enqueue_flags>
   27ff0:	e0bffe05 	stb	r2,-8(fp)
    if (rc != ERR_OK) {
   27ff4:	e0bffe07 	ldb	r2,-8(fp)
   27ff8:	10000526 	beq	r2,zero,28010 <tcp_listen_input+0x2ec>
      tcp_abandon(npcb, 0);
   27ffc:	e13ffd17 	ldw	r4,-12(fp)
   28000:	000b883a 	mov	r5,zero
   28004:	0024f300 	call	24f30 <tcp_abandon>
      return rc;
   28008:	e0bffe03 	ldbu	r2,-8(fp)
   2800c:	00000406 	br	28020 <tcp_listen_input+0x2fc>
    }
    return tcp_output(npcb);
   28010:	e13ffd17 	ldw	r4,-12(fp)
   28014:	002c9d00 	call	2c9d0 <tcp_output>
   28018:	00000106 	br	28020 <tcp_listen_input+0x2fc>
  }
  return ERR_OK;
   2801c:	0005883a 	mov	r2,zero
}
   28020:	e037883a 	mov	sp,fp
   28024:	dfc00117 	ldw	ra,4(sp)
   28028:	df000017 	ldw	fp,0(sp)
   2802c:	dec00204 	addi	sp,sp,8
   28030:	f800283a 	ret

00028034 <tcp_timewait_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
   28034:	defffb04 	addi	sp,sp,-20
   28038:	dfc00415 	stw	ra,16(sp)
   2803c:	df000315 	stw	fp,12(sp)
   28040:	df000304 	addi	fp,sp,12
   28044:	e13fff15 	stw	r4,-4(fp)
  /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
  /* RFC 793 3.9 Event Processing - Segment Arrives:
   * - first check sequence number - we skip that one in TIME_WAIT (always
   *   acceptable since we only send ACKs)
   * - second check the RST bit (... return) */
  if (flags & TCP_RST)  {
   28048:	d0a94003 	ldbu	r2,-23296(gp)
   2804c:	10803fcc 	andi	r2,r2,255
   28050:	1080010c 	andi	r2,r2,4
   28054:	10000226 	beq	r2,zero,28060 <tcp_timewait_input+0x2c>
    return ERR_OK;
   28058:	0005883a 	mov	r2,zero
   2805c:	00004306 	br	2816c <tcp_timewait_input+0x138>
  }
  /* - fourth, check the SYN bit, */
  if (flags & TCP_SYN) {
   28060:	d0a94003 	ldbu	r2,-23296(gp)
   28064:	10803fcc 	andi	r2,r2,255
   28068:	1080008c 	andi	r2,r2,2
   2806c:	10002926 	beq	r2,zero,28114 <tcp_timewait_input+0xe0>
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
   28070:	d0e93e17 	ldw	r3,-23304(gp)
   28074:	e0bfff17 	ldw	r2,-4(fp)
   28078:	10800b17 	ldw	r2,44(r2)
   2807c:	1885c83a 	sub	r2,r3,r2
   28080:	10002d16 	blt	r2,zero,28138 <tcp_timewait_input+0x104>
   28084:	d0e93e17 	ldw	r3,-23304(gp)
   28088:	e0bfff17 	ldw	r2,-4(fp)
   2808c:	11000b17 	ldw	r4,44(r2)
   28090:	e0bfff17 	ldw	r2,-4(fp)
   28094:	10800c0b 	ldhu	r2,48(r2)
   28098:	10bfffcc 	andi	r2,r2,65535
   2809c:	2085883a 	add	r2,r4,r2
   280a0:	1885c83a 	sub	r2,r3,r2
   280a4:	00802416 	blt	zero,r2,28138 <tcp_timewait_input+0x104>
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
   280a8:	d1293f17 	ldw	r4,-23300(gp)
   280ac:	d0a9408b 	ldhu	r2,-23294(gp)
   280b0:	10ffffcc 	andi	r3,r2,65535
   280b4:	d0a93e17 	ldw	r2,-23304(gp)
   280b8:	1887883a 	add	r3,r3,r2
        tcphdr->dest, tcphdr->src);
   280bc:	d0a93c17 	ldw	r2,-23312(gp)
   280c0:	11400083 	ldbu	r5,2(r2)
   280c4:	108000c3 	ldbu	r2,3(r2)
   280c8:	1004923a 	slli	r2,r2,8
   280cc:	1144b03a 	or	r2,r2,r5
  if (flags & TCP_SYN) {
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
   280d0:	117fffcc 	andi	r5,r2,65535
        tcphdr->dest, tcphdr->src);
   280d4:	d0a93c17 	ldw	r2,-23312(gp)
   280d8:	11800003 	ldbu	r6,0(r2)
   280dc:	10800043 	ldbu	r2,1(r2)
   280e0:	1004923a 	slli	r2,r2,8
   280e4:	1184b03a 	or	r2,r2,r6
  if (flags & TCP_SYN) {
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
   280e8:	10bfffcc 	andi	r2,r2,65535
   280ec:	d9400015 	stw	r5,0(sp)
   280f0:	d8800115 	stw	r2,4(sp)
   280f4:	180b883a 	mov	r5,r3
   280f8:	01800134 	movhi	r6,4
   280fc:	319ee404 	addi	r6,r6,31632
   28100:	01c00134 	movhi	r7,4
   28104:	39dee204 	addi	r7,r7,31624
   28108:	002da300 	call	2da30 <tcp_rst>
        tcphdr->dest, tcphdr->src);
      return ERR_OK;
   2810c:	0005883a 	mov	r2,zero
   28110:	00001606 	br	2816c <tcp_timewait_input+0x138>
    }
  } else if (flags & TCP_FIN) {
   28114:	d0a94003 	ldbu	r2,-23296(gp)
   28118:	10803fcc 	andi	r2,r2,255
   2811c:	1080004c 	andi	r2,r2,1
   28120:	10000526 	beq	r2,zero,28138 <tcp_timewait_input+0x104>
    /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
         Restart the 2 MSL time-wait timeout.*/
    pcb->tmr = tcp_ticks;
   28124:	00800134 	movhi	r2,4
   28128:	109ef304 	addi	r2,r2,31692
   2812c:	10c00017 	ldw	r3,0(r2)
   28130:	e0bfff17 	ldw	r2,-4(fp)
   28134:	10c00a15 	stw	r3,40(r2)
  }

  if ((tcplen > 0))  {
   28138:	d0a9408b 	ldhu	r2,-23294(gp)
   2813c:	10bfffcc 	andi	r2,r2,65535
   28140:	10000926 	beq	r2,zero,28168 <tcp_timewait_input+0x134>
    /* Acknowledge data, FIN or out-of-window SYN */
    pcb->flags |= TF_ACK_NOW;
   28144:	e0bfff17 	ldw	r2,-4(fp)
   28148:	10800883 	ldbu	r2,34(r2)
   2814c:	10800094 	ori	r2,r2,2
   28150:	1007883a 	mov	r3,r2
   28154:	e0bfff17 	ldw	r2,-4(fp)
   28158:	10c00885 	stb	r3,34(r2)
    return tcp_output(pcb);
   2815c:	e13fff17 	ldw	r4,-4(fp)
   28160:	002c9d00 	call	2c9d0 <tcp_output>
   28164:	00000106 	br	2816c <tcp_timewait_input+0x138>
  }
  return ERR_OK;
   28168:	0005883a 	mov	r2,zero
}
   2816c:	e037883a 	mov	sp,fp
   28170:	dfc00117 	ldw	ra,4(sp)
   28174:	df000017 	ldw	fp,0(sp)
   28178:	dec00204 	addi	sp,sp,8
   2817c:	f800283a 	ret

00028180 <tcp_process>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
   28180:	defff804 	addi	sp,sp,-32
   28184:	dfc00715 	stw	ra,28(sp)
   28188:	df000615 	stw	fp,24(sp)
   2818c:	df000604 	addi	fp,sp,24
   28190:	e13fff15 	stw	r4,-4(fp)
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
   28194:	e03ffc05 	stb	zero,-16(fp)
  err_t err;

  err = ERR_OK;
   28198:	e03ffc45 	stb	zero,-15(fp)

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
   2819c:	d0a94003 	ldbu	r2,-23296(gp)
   281a0:	10803fcc 	andi	r2,r2,255
   281a4:	1080010c 	andi	r2,r2,4
   281a8:	10002b26 	beq	r2,zero,28258 <tcp_process+0xd8>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
   281ac:	e0bfff17 	ldw	r2,-4(fp)
   281b0:	10800617 	ldw	r2,24(r2)
   281b4:	10800098 	cmpnei	r2,r2,2
   281b8:	1000071e 	bne	r2,zero,281d8 <tcp_process+0x58>
      if (ackno == pcb->snd_nxt) {
   281bc:	e0bfff17 	ldw	r2,-4(fp)
   281c0:	10c01517 	ldw	r3,84(r2)
   281c4:	d0a93f17 	ldw	r2,-23300(gp)
   281c8:	1880131e 	bne	r3,r2,28218 <tcp_process+0x98>
        acceptable = 1;
   281cc:	00800044 	movi	r2,1
   281d0:	e0bffc05 	stb	r2,-16(fp)
   281d4:	00001006 	br	28218 <tcp_process+0x98>
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
   281d8:	d0e93e17 	ldw	r3,-23304(gp)
   281dc:	e0bfff17 	ldw	r2,-4(fp)
   281e0:	10800b17 	ldw	r2,44(r2)
   281e4:	1885c83a 	sub	r2,r3,r2
   281e8:	10000b16 	blt	r2,zero,28218 <tcp_process+0x98>
   281ec:	d0e93e17 	ldw	r3,-23304(gp)
   281f0:	e0bfff17 	ldw	r2,-4(fp)
   281f4:	11000b17 	ldw	r4,44(r2)
   281f8:	e0bfff17 	ldw	r2,-4(fp)
   281fc:	10800c0b 	ldhu	r2,48(r2)
   28200:	10bfffcc 	andi	r2,r2,65535
   28204:	2085883a 	add	r2,r4,r2
   28208:	1885c83a 	sub	r2,r3,r2
   2820c:	00800216 	blt	zero,r2,28218 <tcp_process+0x98>
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
   28210:	00800044 	movi	r2,1
   28214:	e0bffc05 	stb	r2,-16(fp)
      }
    }

    if (acceptable) {
   28218:	e0bffc03 	ldbu	r2,-16(fp)
   2821c:	10000c26 	beq	r2,zero,28250 <tcp_process+0xd0>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
      recv_flags |= TF_RESET;
   28220:	d0a94103 	ldbu	r2,-23292(gp)
   28224:	10800214 	ori	r2,r2,8
   28228:	d0a94105 	stb	r2,-23292(gp)
      pcb->flags &= ~TF_ACK_DELAY;
   2822c:	e0bfff17 	ldw	r2,-4(fp)
   28230:	10c00883 	ldbu	r3,34(r2)
   28234:	00bfff84 	movi	r2,-2
   28238:	1884703a 	and	r2,r3,r2
   2823c:	1007883a 	mov	r3,r2
   28240:	e0bfff17 	ldw	r2,-4(fp)
   28244:	10c00885 	stb	r3,34(r2)
      return ERR_RST;
   28248:	00bffd44 	movi	r2,-11
   2824c:	0002c706 	br	28d6c <tcp_process+0xbec>
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      return ERR_OK;
   28250:	0005883a 	mov	r2,zero
   28254:	0002c506 	br	28d6c <tcp_process+0xbec>
    }
  }

  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) { 
   28258:	d0a94003 	ldbu	r2,-23296(gp)
   2825c:	10803fcc 	andi	r2,r2,255
   28260:	1080008c 	andi	r2,r2,2
   28264:	10001026 	beq	r2,zero,282a8 <tcp_process+0x128>
   28268:	e0bfff17 	ldw	r2,-4(fp)
   2826c:	10800617 	ldw	r2,24(r2)
   28270:	108000a0 	cmpeqi	r2,r2,2
   28274:	10000c1e 	bne	r2,zero,282a8 <tcp_process+0x128>
   28278:	e0bfff17 	ldw	r2,-4(fp)
   2827c:	10800617 	ldw	r2,24(r2)
   28280:	108000e0 	cmpeqi	r2,r2,3
   28284:	1000081e 	bne	r2,zero,282a8 <tcp_process+0x128>
    /* Cope with new connection attempt after remote end crashed */
    tcp_ack_now(pcb);
   28288:	e0bfff17 	ldw	r2,-4(fp)
   2828c:	10800883 	ldbu	r2,34(r2)
   28290:	10800094 	ori	r2,r2,2
   28294:	1007883a 	mov	r3,r2
   28298:	e0bfff17 	ldw	r2,-4(fp)
   2829c:	10c00885 	stb	r3,34(r2)
    return ERR_OK;
   282a0:	0005883a 	mov	r2,zero
   282a4:	0002b106 	br	28d6c <tcp_process+0xbec>
  }
  
  if ((pcb->flags & TF_RXCLOSED) == 0) {
   282a8:	e0bfff17 	ldw	r2,-4(fp)
   282ac:	10800883 	ldbu	r2,34(r2)
   282b0:	10803fcc 	andi	r2,r2,255
   282b4:	1080040c 	andi	r2,r2,16
   282b8:	1000051e 	bne	r2,zero,282d0 <tcp_process+0x150>
    /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
    pcb->tmr = tcp_ticks;
   282bc:	00800134 	movhi	r2,4
   282c0:	109ef304 	addi	r2,r2,31692
   282c4:	10c00017 	ldw	r3,0(r2)
   282c8:	e0bfff17 	ldw	r2,-4(fp)
   282cc:	10c00a15 	stw	r3,40(r2)
  }
  pcb->keep_cnt_sent = 0;
   282d0:	e0bfff17 	ldw	r2,-4(fp)
   282d4:	10002885 	stb	zero,162(r2)

  tcp_parseopt(pcb);
   282d8:	e13fff17 	ldw	r4,-4(fp)
   282dc:	002af900 	call	2af90 <tcp_parseopt>

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
   282e0:	e0bfff17 	ldw	r2,-4(fp)
   282e4:	10800617 	ldw	r2,24(r2)
   282e8:	10c002a8 	cmpgeui	r3,r2,10
   282ec:	18028f1e 	bne	r3,zero,28d2c <tcp_process+0xbac>
   282f0:	1085883a 	add	r2,r2,r2
   282f4:	1087883a 	add	r3,r2,r2
   282f8:	008000f4 	movhi	r2,3
   282fc:	10a0c304 	addi	r2,r2,-31988
   28300:	1885883a 	add	r2,r3,r2
   28304:	10800017 	ldw	r2,0(r2)
   28308:	1000683a 	jmp	r2
   2830c:	00028d2c 	andhi	zero,zero,2612
   28310:	00028d2c 	andhi	zero,zero,2612
   28314:	00028334 	movhi	zero,2572
   28318:	000286b4 	movhi	zero,2586
   2831c:	0002889c 	xori	zero,zero,2594
   28320:	000288dc 	xori	zero,zero,2595
   28324:	00028a8c 	andi	zero,zero,2602
   28328:	0002889c 	xori	zero,zero,2594
   2832c:	00028bc4 	movi	zero,2607
   28330:	00028cf4 	movhi	zero,2611
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
   28334:	d0a94003 	ldbu	r2,-23296(gp)
   28338:	10803fcc 	andi	r2,r2,255
   2833c:	1080040c 	andi	r2,r2,16
   28340:	1000be26 	beq	r2,zero,2863c <tcp_process+0x4bc>
   28344:	d0a94003 	ldbu	r2,-23296(gp)
   28348:	10803fcc 	andi	r2,r2,255
   2834c:	1080008c 	andi	r2,r2,2
   28350:	1000ba26 	beq	r2,zero,2863c <tcp_process+0x4bc>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
   28354:	e0bfff17 	ldw	r2,-4(fp)
   28358:	10801d17 	ldw	r2,116(r2)
   2835c:	10800417 	ldw	r2,16(r2)
   28360:	10c00103 	ldbu	r3,4(r2)
   28364:	11000143 	ldbu	r4,5(r2)
   28368:	2008923a 	slli	r4,r4,8
   2836c:	20c6b03a 	or	r3,r4,r3
   28370:	11000183 	ldbu	r4,6(r2)
   28374:	2008943a 	slli	r4,r4,16
   28378:	20c6b03a 	or	r3,r4,r3
   2837c:	108001c3 	ldbu	r2,7(r2)
   28380:	1004963a 	slli	r2,r2,24
   28384:	10c4b03a 	or	r2,r2,r3
   28388:	1006d63a 	srli	r3,r2,24
   2838c:	e0bfff17 	ldw	r2,-4(fp)
   28390:	10801d17 	ldw	r2,116(r2)
   28394:	10800417 	ldw	r2,16(r2)
   28398:	11000103 	ldbu	r4,4(r2)
   2839c:	11400143 	ldbu	r5,5(r2)
   283a0:	280a923a 	slli	r5,r5,8
   283a4:	2908b03a 	or	r4,r5,r4
   283a8:	11400183 	ldbu	r5,6(r2)
   283ac:	280a943a 	slli	r5,r5,16
   283b0:	2908b03a 	or	r4,r5,r4
   283b4:	108001c3 	ldbu	r2,7(r2)
   283b8:	1004963a 	slli	r2,r2,24
   283bc:	1104b03a 	or	r2,r2,r4
   283c0:	1004d23a 	srli	r2,r2,8
   283c4:	10bfc00c 	andi	r2,r2,65280
   283c8:	1886b03a 	or	r3,r3,r2
   283cc:	e0bfff17 	ldw	r2,-4(fp)
   283d0:	10801d17 	ldw	r2,116(r2)
   283d4:	10800417 	ldw	r2,16(r2)
   283d8:	11000103 	ldbu	r4,4(r2)
   283dc:	11400143 	ldbu	r5,5(r2)
   283e0:	280a923a 	slli	r5,r5,8
   283e4:	2908b03a 	or	r4,r5,r4
   283e8:	11400183 	ldbu	r5,6(r2)
   283ec:	280a943a 	slli	r5,r5,16
   283f0:	2908b03a 	or	r4,r5,r4
   283f4:	108001c3 	ldbu	r2,7(r2)
   283f8:	1004963a 	slli	r2,r2,24
   283fc:	1104b03a 	or	r2,r2,r4
   28400:	10bfc00c 	andi	r2,r2,65280
   28404:	1004923a 	slli	r2,r2,8
   28408:	1886b03a 	or	r3,r3,r2
   2840c:	e0bfff17 	ldw	r2,-4(fp)
   28410:	10801d17 	ldw	r2,116(r2)
   28414:	10800417 	ldw	r2,16(r2)
   28418:	11000103 	ldbu	r4,4(r2)
   2841c:	11400143 	ldbu	r5,5(r2)
   28420:	280a923a 	slli	r5,r5,8
   28424:	2908b03a 	or	r4,r5,r4
   28428:	11400183 	ldbu	r5,6(r2)
   2842c:	280a943a 	slli	r5,r5,16
   28430:	2908b03a 	or	r4,r5,r4
   28434:	108001c3 	ldbu	r2,7(r2)
   28438:	1004963a 	slli	r2,r2,24
   2843c:	1104b03a 	or	r2,r2,r4
   28440:	1004963a 	slli	r2,r2,24
   28444:	1884b03a 	or	r2,r3,r2
   28448:	10c00044 	addi	r3,r2,1
   2844c:	d0a93f17 	ldw	r2,-23300(gp)
   28450:	18807a1e 	bne	r3,r2,2863c <tcp_process+0x4bc>
      pcb->snd_buf++;
   28454:	e0bfff17 	ldw	r2,-4(fp)
   28458:	10801a8b 	ldhu	r2,106(r2)
   2845c:	10800044 	addi	r2,r2,1
   28460:	1007883a 	mov	r3,r2
   28464:	e0bfff17 	ldw	r2,-4(fp)
   28468:	10c01a8d 	sth	r3,106(r2)
      pcb->rcv_nxt = seqno + 1;
   2846c:	d0a93e17 	ldw	r2,-23304(gp)
   28470:	10c00044 	addi	r3,r2,1
   28474:	e0bfff17 	ldw	r2,-4(fp)
   28478:	10c00b15 	stw	r3,44(r2)
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
   2847c:	e0bfff17 	ldw	r2,-4(fp)
   28480:	10c00b17 	ldw	r3,44(r2)
   28484:	e0bfff17 	ldw	r2,-4(fp)
   28488:	10c00d15 	stw	r3,52(r2)
      pcb->lastack = ackno;
   2848c:	d0e93f17 	ldw	r3,-23300(gp)
   28490:	e0bfff17 	ldw	r2,-4(fp)
   28494:	10c01315 	stw	r3,76(r2)
      pcb->snd_wnd = tcphdr->wnd;
   28498:	d0a93c17 	ldw	r2,-23312(gp)
   2849c:	10c00383 	ldbu	r3,14(r2)
   284a0:	108003c3 	ldbu	r2,15(r2)
   284a4:	1004923a 	slli	r2,r2,8
   284a8:	10c4b03a 	or	r2,r2,r3
   284ac:	1007883a 	mov	r3,r2
   284b0:	e0bfff17 	ldw	r2,-4(fp)
   284b4:	10c0190d 	sth	r3,100(r2)
      pcb->snd_wnd_max = tcphdr->wnd;
   284b8:	d0a93c17 	ldw	r2,-23312(gp)
   284bc:	10c00383 	ldbu	r3,14(r2)
   284c0:	108003c3 	ldbu	r2,15(r2)
   284c4:	1004923a 	slli	r2,r2,8
   284c8:	10c4b03a 	or	r2,r2,r3
   284cc:	1007883a 	mov	r3,r2
   284d0:	e0bfff17 	ldw	r2,-4(fp)
   284d4:	10c0198d 	sth	r3,102(r2)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
   284d8:	d0a93e17 	ldw	r2,-23304(gp)
   284dc:	10ffffc4 	addi	r3,r2,-1
   284e0:	e0bfff17 	ldw	r2,-4(fp)
   284e4:	10c01615 	stw	r3,88(r2)
      pcb->state = ESTABLISHED;
   284e8:	e0bfff17 	ldw	r2,-4(fp)
   284ec:	00c00104 	movi	r3,4
   284f0:	10c00615 	stw	r3,24(r2)

#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->local_ip), &(pcb->remote_ip));
   284f4:	e0bfff17 	ldw	r2,-4(fp)
   284f8:	10800e8b 	ldhu	r2,58(r2)
   284fc:	113fffcc 	andi	r4,r2,65535
   28500:	e0ffff17 	ldw	r3,-4(fp)
   28504:	e0bfff17 	ldw	r2,-4(fp)
   28508:	10800104 	addi	r2,r2,4
   2850c:	180b883a 	mov	r5,r3
   28510:	100d883a 	mov	r6,r2
   28514:	0026dd00 	call	26dd0 <tcp_eff_send_mss>
   28518:	e0ffff17 	ldw	r3,-4(fp)
   2851c:	18800e8d 	sth	r2,58(r3)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
   28520:	e0bfff17 	ldw	r2,-4(fp)
   28524:	10800e8b 	ldhu	r2,58(r2)
   28528:	108002a4 	muli	r2,r2,10
   2852c:	1007883a 	mov	r3,r2
   28530:	e0bfff17 	ldw	r2,-4(fp)
   28534:	10c0148d 	sth	r3,82(r2)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
   28538:	e0bfff17 	ldw	r2,-4(fp)
   2853c:	1080140b 	ldhu	r2,80(r2)
   28540:	10bfffcc 	andi	r2,r2,65535
   28544:	10800058 	cmpnei	r2,r2,1
   28548:	1000041e 	bne	r2,zero,2855c <tcp_process+0x3dc>
   2854c:	e0bfff17 	ldw	r2,-4(fp)
   28550:	10800e8b 	ldhu	r2,58(r2)
   28554:	1085883a 	add	r2,r2,r2
   28558:	00000206 	br	28564 <tcp_process+0x3e4>
   2855c:	e0bfff17 	ldw	r2,-4(fp)
   28560:	10800e8b 	ldhu	r2,58(r2)
   28564:	e0ffff17 	ldw	r3,-4(fp)
   28568:	1880140d 	sth	r2,80(r3)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
      --pcb->snd_queuelen;
   2856c:	e0bfff17 	ldw	r2,-4(fp)
   28570:	10801b0b 	ldhu	r2,108(r2)
   28574:	10bfffc4 	addi	r2,r2,-1
   28578:	1007883a 	mov	r3,r2
   2857c:	e0bfff17 	ldw	r2,-4(fp)
   28580:	10c01b0d 	sth	r3,108(r2)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
   28584:	e0bfff17 	ldw	r2,-4(fp)
   28588:	10801d17 	ldw	r2,116(r2)
   2858c:	e0bffd15 	stw	r2,-12(fp)
      pcb->unacked = rseg->next;
   28590:	e0bffd17 	ldw	r2,-12(fp)
   28594:	10c00017 	ldw	r3,0(r2)
   28598:	e0bfff17 	ldw	r2,-4(fp)
   2859c:	10c01d15 	stw	r3,116(r2)
      tcp_seg_free(rseg);
   285a0:	e13ffd17 	ldw	r4,-12(fp)
   285a4:	00264f80 	call	264f8 <tcp_seg_free>

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
   285a8:	e0bfff17 	ldw	r2,-4(fp)
   285ac:	10801d17 	ldw	r2,116(r2)
   285b0:	1000041e 	bne	r2,zero,285c4 <tcp_process+0x444>
        pcb->rtime = -1;
   285b4:	e0bfff17 	ldw	r2,-4(fp)
   285b8:	00ffffc4 	movi	r3,-1
   285bc:	10c00e0d 	sth	r3,56(r2)
   285c0:	00000406 	br	285d4 <tcp_process+0x454>
      else {
        pcb->rtime = 0;
   285c4:	e0bfff17 	ldw	r2,-4(fp)
   285c8:	10000e0d 	sth	zero,56(r2)
        pcb->nrtx = 0;
   285cc:	e0bfff17 	ldw	r2,-4(fp)
   285d0:	10001285 	stb	zero,74(r2)
      }

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
   285d4:	e0bfff17 	ldw	r2,-4(fp)
   285d8:	10802217 	ldw	r2,136(r2)
   285dc:	10000a26 	beq	r2,zero,28608 <tcp_process+0x488>
   285e0:	e0bfff17 	ldw	r2,-4(fp)
   285e4:	10c02217 	ldw	r3,136(r2)
   285e8:	e0bfff17 	ldw	r2,-4(fp)
   285ec:	10800417 	ldw	r2,16(r2)
   285f0:	1009883a 	mov	r4,r2
   285f4:	e17fff17 	ldw	r5,-4(fp)
   285f8:	000d883a 	mov	r6,zero
   285fc:	183ee83a 	callr	r3
   28600:	e0bffc45 	stb	r2,-15(fp)
   28604:	00000106 	br	2860c <tcp_process+0x48c>
   28608:	e03ffc45 	stb	zero,-15(fp)
      if (err == ERR_ABRT) {
   2860c:	e0bffc47 	ldb	r2,-15(fp)
   28610:	10bffd98 	cmpnei	r2,r2,-10
   28614:	1000021e 	bne	r2,zero,28620 <tcp_process+0x4a0>
        return ERR_ABRT;
   28618:	00bffd84 	movi	r2,-10
   2861c:	0001d306 	br	28d6c <tcp_process+0xbec>
      }
      tcp_ack_now(pcb);
   28620:	e0bfff17 	ldw	r2,-4(fp)
   28624:	10800883 	ldbu	r2,34(r2)
   28628:	10800094 	ori	r2,r2,2
   2862c:	1007883a 	mov	r3,r2
   28630:	e0bfff17 	ldw	r2,-4(fp)
   28634:	10c00885 	stb	r3,34(r2)
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
    }
    break;
   28638:	0001be06 	br	28d34 <tcp_process+0xbb4>
        return ERR_ABRT;
      }
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
   2863c:	d0a94003 	ldbu	r2,-23296(gp)
   28640:	10803fcc 	andi	r2,r2,255
   28644:	1080040c 	andi	r2,r2,16
   28648:	1001ba26 	beq	r2,zero,28d34 <tcp_process+0xbb4>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
   2864c:	d1293f17 	ldw	r4,-23300(gp)
   28650:	d0a9408b 	ldhu	r2,-23294(gp)
   28654:	10ffffcc 	andi	r3,r2,65535
   28658:	d0a93e17 	ldw	r2,-23304(gp)
   2865c:	1887883a 	add	r3,r3,r2
        tcphdr->dest, tcphdr->src);
   28660:	d0a93c17 	ldw	r2,-23312(gp)
   28664:	11400083 	ldbu	r5,2(r2)
   28668:	108000c3 	ldbu	r2,3(r2)
   2866c:	1004923a 	slli	r2,r2,8
   28670:	1144b03a 	or	r2,r2,r5
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
   28674:	117fffcc 	andi	r5,r2,65535
        tcphdr->dest, tcphdr->src);
   28678:	d0a93c17 	ldw	r2,-23312(gp)
   2867c:	11800003 	ldbu	r6,0(r2)
   28680:	10800043 	ldbu	r2,1(r2)
   28684:	1004923a 	slli	r2,r2,8
   28688:	1184b03a 	or	r2,r2,r6
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
   2868c:	10bfffcc 	andi	r2,r2,65535
   28690:	d9400015 	stw	r5,0(sp)
   28694:	d8800115 	stw	r2,4(sp)
   28698:	180b883a 	mov	r5,r3
   2869c:	01800134 	movhi	r6,4
   286a0:	319ee404 	addi	r6,r6,31632
   286a4:	01c00134 	movhi	r7,4
   286a8:	39dee204 	addi	r7,r7,31624
   286ac:	002da300 	call	2da30 <tcp_rst>
        tcphdr->dest, tcphdr->src);
    }
    break;
   286b0:	0001a006 	br	28d34 <tcp_process+0xbb4>
  case SYN_RCVD:
    if (flags & TCP_ACK) {
   286b4:	d0a94003 	ldbu	r2,-23296(gp)
   286b8:	10803fcc 	andi	r2,r2,255
   286bc:	1080040c 	andi	r2,r2,16
   286c0:	10006a26 	beq	r2,zero,2886c <tcp_process+0x6ec>
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
   286c4:	e0bfff17 	ldw	r2,-4(fp)
   286c8:	10801317 	ldw	r2,76(r2)
   286cc:	0086303a 	nor	r3,zero,r2
   286d0:	d0a93f17 	ldw	r2,-23300(gp)
   286d4:	1885883a 	add	r2,r3,r2
   286d8:	10004816 	blt	r2,zero,287fc <tcp_process+0x67c>
   286dc:	d0e93f17 	ldw	r3,-23300(gp)
   286e0:	e0bfff17 	ldw	r2,-4(fp)
   286e4:	10801517 	ldw	r2,84(r2)
   286e8:	1885c83a 	sub	r2,r3,r2
   286ec:	00804316 	blt	zero,r2,287fc <tcp_process+0x67c>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
   286f0:	e0bfff17 	ldw	r2,-4(fp)
   286f4:	00c00104 	movi	r3,4
   286f8:	10c00615 	stw	r3,24(r2)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
   286fc:	e0bfff17 	ldw	r2,-4(fp)
   28700:	10800517 	ldw	r2,20(r2)
   28704:	10000a26 	beq	r2,zero,28730 <tcp_process+0x5b0>
   28708:	e0bfff17 	ldw	r2,-4(fp)
   2870c:	10c00517 	ldw	r3,20(r2)
   28710:	e0bfff17 	ldw	r2,-4(fp)
   28714:	10800417 	ldw	r2,16(r2)
   28718:	1009883a 	mov	r4,r2
   2871c:	e17fff17 	ldw	r5,-4(fp)
   28720:	000d883a 	mov	r6,zero
   28724:	183ee83a 	callr	r3
   28728:	e0bffc45 	stb	r2,-15(fp)
   2872c:	00000206 	br	28738 <tcp_process+0x5b8>
   28730:	00bffc84 	movi	r2,-14
   28734:	e0bffc45 	stb	r2,-15(fp)
        if (err != ERR_OK) {
   28738:	e0bffc47 	ldb	r2,-15(fp)
   2873c:	10000726 	beq	r2,zero,2875c <tcp_process+0x5dc>
          /* If the accept function returns with an error, we abort
           * the connection. */
          /* Already aborted? */
          if (err != ERR_ABRT) {
   28740:	e0bffc47 	ldb	r2,-15(fp)
   28744:	10bffda0 	cmpeqi	r2,r2,-10
   28748:	1000021e 	bne	r2,zero,28754 <tcp_process+0x5d4>
            tcp_abort(pcb);
   2874c:	e13fff17 	ldw	r4,-4(fp)
   28750:	002508c0 	call	2508c <tcp_abort>
          }
          return ERR_ABRT;
   28754:	00bffd84 	movi	r2,-10
   28758:	00018406 	br	28d6c <tcp_process+0xbec>
        }
        old_cwnd = pcb->cwnd;
   2875c:	e0bfff17 	ldw	r2,-4(fp)
   28760:	1080140b 	ldhu	r2,80(r2)
   28764:	e0bffe0d 	sth	r2,-8(fp)
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        tcp_receive(pcb);
   28768:	e13fff17 	ldw	r4,-4(fp)
   2876c:	00290080 	call	29008 <tcp_receive>

        /* Prevent ACK for SYN to generate a sent event */
        if (pcb->acked != 0) {
   28770:	e0bfff17 	ldw	r2,-4(fp)
   28774:	10801a0b 	ldhu	r2,104(r2)
   28778:	10bfffcc 	andi	r2,r2,65535
   2877c:	10000626 	beq	r2,zero,28798 <tcp_process+0x618>
          pcb->acked--;
   28780:	e0bfff17 	ldw	r2,-4(fp)
   28784:	10801a0b 	ldhu	r2,104(r2)
   28788:	10bfffc4 	addi	r2,r2,-1
   2878c:	1007883a 	mov	r3,r2
   28790:	e0bfff17 	ldw	r2,-4(fp)
   28794:	10c01a0d 	sth	r3,104(r2)
        }

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
   28798:	e0bffe0b 	ldhu	r2,-8(fp)
   2879c:	10800058 	cmpnei	r2,r2,1
   287a0:	1000041e 	bne	r2,zero,287b4 <tcp_process+0x634>
   287a4:	e0bfff17 	ldw	r2,-4(fp)
   287a8:	10800e8b 	ldhu	r2,58(r2)
   287ac:	1085883a 	add	r2,r2,r2
   287b0:	00000206 	br	287bc <tcp_process+0x63c>
   287b4:	e0bfff17 	ldw	r2,-4(fp)
   287b8:	10800e8b 	ldhu	r2,58(r2)
   287bc:	e0ffff17 	ldw	r3,-4(fp)
   287c0:	1880140d 	sth	r2,80(r3)

        if (recv_flags & TF_GOT_FIN) {
   287c4:	d0a94103 	ldbu	r2,-23292(gp)
   287c8:	10803fcc 	andi	r2,r2,255
   287cc:	1080080c 	andi	r2,r2,32
   287d0:	10002426 	beq	r2,zero,28864 <tcp_process+0x6e4>
          tcp_ack_now(pcb);
   287d4:	e0bfff17 	ldw	r2,-4(fp)
   287d8:	10800883 	ldbu	r2,34(r2)
   287dc:	10800094 	ori	r2,r2,2
   287e0:	1007883a 	mov	r3,r2
   287e4:	e0bfff17 	ldw	r2,-4(fp)
   287e8:	10c00885 	stb	r3,34(r2)
          pcb->state = CLOSE_WAIT;
   287ec:	e0bfff17 	ldw	r2,-4(fp)
   287f0:	00c001c4 	movi	r3,7
   287f4:	10c00615 	stw	r3,24(r2)
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
   287f8:	00001a06 	br	28864 <tcp_process+0x6e4>
          tcp_ack_now(pcb);
          pcb->state = CLOSE_WAIT;
        }
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
   287fc:	d1293f17 	ldw	r4,-23300(gp)
   28800:	d0a9408b 	ldhu	r2,-23294(gp)
   28804:	10ffffcc 	andi	r3,r2,65535
   28808:	d0a93e17 	ldw	r2,-23304(gp)
   2880c:	1887883a 	add	r3,r3,r2
                tcphdr->dest, tcphdr->src);
   28810:	d0a93c17 	ldw	r2,-23312(gp)
   28814:	11400083 	ldbu	r5,2(r2)
   28818:	108000c3 	ldbu	r2,3(r2)
   2881c:	1004923a 	slli	r2,r2,8
   28820:	1144b03a 	or	r2,r2,r5
          tcp_ack_now(pcb);
          pcb->state = CLOSE_WAIT;
        }
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
   28824:	117fffcc 	andi	r5,r2,65535
                tcphdr->dest, tcphdr->src);
   28828:	d0a93c17 	ldw	r2,-23312(gp)
   2882c:	11800003 	ldbu	r6,0(r2)
   28830:	10800043 	ldbu	r2,1(r2)
   28834:	1004923a 	slli	r2,r2,8
   28838:	1184b03a 	or	r2,r2,r6
          tcp_ack_now(pcb);
          pcb->state = CLOSE_WAIT;
        }
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
   2883c:	10bfffcc 	andi	r2,r2,65535
   28840:	d9400015 	stw	r5,0(sp)
   28844:	d8800115 	stw	r2,4(sp)
   28848:	180b883a 	mov	r5,r3
   2884c:	01800134 	movhi	r6,4
   28850:	319ee404 	addi	r6,r6,31632
   28854:	01c00134 	movhi	r7,4
   28858:	39dee204 	addi	r7,r7,31624
   2885c:	002da300 	call	2da30 <tcp_rst>
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    }
    break;
   28860:	00013606 	br	28d3c <tcp_process+0xbbc>
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
   28864:	0001883a 	nop
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    }
    break;
   28868:	00013406 	br	28d3c <tcp_process+0xbbc>
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
                tcphdr->dest, tcphdr->src);
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
   2886c:	d0a94003 	ldbu	r2,-23296(gp)
   28870:	10803fcc 	andi	r2,r2,255
   28874:	1080008c 	andi	r2,r2,2
   28878:	10013026 	beq	r2,zero,28d3c <tcp_process+0xbbc>
   2887c:	e0bfff17 	ldw	r2,-4(fp)
   28880:	10800b17 	ldw	r2,44(r2)
   28884:	10ffffc4 	addi	r3,r2,-1
   28888:	d0a93e17 	ldw	r2,-23304(gp)
   2888c:	18812b1e 	bne	r3,r2,28d3c <tcp_process+0xbbc>
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
   28890:	e13fff17 	ldw	r4,-4(fp)
   28894:	002de400 	call	2de40 <tcp_rexmit>
    }
    break;
   28898:	00012806 	br	28d3c <tcp_process+0xbbc>
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    tcp_receive(pcb);
   2889c:	e13fff17 	ldw	r4,-4(fp)
   288a0:	00290080 	call	29008 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) { /* passive close */
   288a4:	d0a94103 	ldbu	r2,-23292(gp)
   288a8:	10803fcc 	andi	r2,r2,255
   288ac:	1080080c 	andi	r2,r2,32
   288b0:	10012426 	beq	r2,zero,28d44 <tcp_process+0xbc4>
      tcp_ack_now(pcb);
   288b4:	e0bfff17 	ldw	r2,-4(fp)
   288b8:	10800883 	ldbu	r2,34(r2)
   288bc:	10800094 	ori	r2,r2,2
   288c0:	1007883a 	mov	r3,r2
   288c4:	e0bfff17 	ldw	r2,-4(fp)
   288c8:	10c00885 	stb	r3,34(r2)
      pcb->state = CLOSE_WAIT;
   288cc:	e0bfff17 	ldw	r2,-4(fp)
   288d0:	00c001c4 	movi	r3,7
   288d4:	10c00615 	stw	r3,24(r2)
    }
    break;
   288d8:	00011a06 	br	28d44 <tcp_process+0xbc4>
  case FIN_WAIT_1:
    tcp_receive(pcb);
   288dc:	e13fff17 	ldw	r4,-4(fp)
   288e0:	00290080 	call	29008 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
   288e4:	d0a94103 	ldbu	r2,-23292(gp)
   288e8:	10803fcc 	andi	r2,r2,255
   288ec:	1080080c 	andi	r2,r2,32
   288f0:	10005a26 	beq	r2,zero,28a5c <tcp_process+0x8dc>
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
   288f4:	d0a94003 	ldbu	r2,-23296(gp)
   288f8:	10803fcc 	andi	r2,r2,255
   288fc:	1080040c 	andi	r2,r2,16
   28900:	10004c26 	beq	r2,zero,28a34 <tcp_process+0x8b4>
   28904:	e0bfff17 	ldw	r2,-4(fp)
   28908:	10c01517 	ldw	r3,84(r2)
   2890c:	d0a93f17 	ldw	r2,-23300(gp)
   28910:	1880481e 	bne	r3,r2,28a34 <tcp_process+0x8b4>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
   28914:	e0bfff17 	ldw	r2,-4(fp)
   28918:	10800883 	ldbu	r2,34(r2)
   2891c:	10800094 	ori	r2,r2,2
   28920:	1007883a 	mov	r3,r2
   28924:	e0bfff17 	ldw	r2,-4(fp)
   28928:	10c00885 	stb	r3,34(r2)
        tcp_pcb_purge(pcb);
   2892c:	e13fff17 	ldw	r4,-4(fp)
   28930:	0026b2c0 	call	26b2c <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
   28934:	00800134 	movhi	r2,4
   28938:	109ef204 	addi	r2,r2,31688
   2893c:	10c00017 	ldw	r3,0(r2)
   28940:	e0bfff17 	ldw	r2,-4(fp)
   28944:	1880081e 	bne	r3,r2,28968 <tcp_process+0x7e8>
   28948:	00800134 	movhi	r2,4
   2894c:	109ef204 	addi	r2,r2,31688
   28950:	10800017 	ldw	r2,0(r2)
   28954:	10c00317 	ldw	r3,12(r2)
   28958:	00800134 	movhi	r2,4
   2895c:	109ef204 	addi	r2,r2,31688
   28960:	10c00015 	stw	r3,0(r2)
   28964:	00001f06 	br	289e4 <tcp_process+0x864>
   28968:	00800134 	movhi	r2,4
   2896c:	109ef204 	addi	r2,r2,31688
   28970:	10c00017 	ldw	r3,0(r2)
   28974:	00800134 	movhi	r2,4
   28978:	109ef504 	addi	r2,r2,31700
   2897c:	10c00015 	stw	r3,0(r2)
   28980:	00001406 	br	289d4 <tcp_process+0x854>
   28984:	00800134 	movhi	r2,4
   28988:	109ef504 	addi	r2,r2,31700
   2898c:	10800017 	ldw	r2,0(r2)
   28990:	10c00317 	ldw	r3,12(r2)
   28994:	e0bfff17 	ldw	r2,-4(fp)
   28998:	1880071e 	bne	r3,r2,289b8 <tcp_process+0x838>
   2899c:	00800134 	movhi	r2,4
   289a0:	109ef504 	addi	r2,r2,31700
   289a4:	10800017 	ldw	r2,0(r2)
   289a8:	e0ffff17 	ldw	r3,-4(fp)
   289ac:	18c00317 	ldw	r3,12(r3)
   289b0:	10c00315 	stw	r3,12(r2)
   289b4:	00000b06 	br	289e4 <tcp_process+0x864>
   289b8:	00800134 	movhi	r2,4
   289bc:	109ef504 	addi	r2,r2,31700
   289c0:	10800017 	ldw	r2,0(r2)
   289c4:	10c00317 	ldw	r3,12(r2)
   289c8:	00800134 	movhi	r2,4
   289cc:	109ef504 	addi	r2,r2,31700
   289d0:	10c00015 	stw	r3,0(r2)
   289d4:	00800134 	movhi	r2,4
   289d8:	109ef504 	addi	r2,r2,31700
   289dc:	10800017 	ldw	r2,0(r2)
   289e0:	103fe81e 	bne	r2,zero,28984 <tcp_process+0x804>
   289e4:	e0bfff17 	ldw	r2,-4(fp)
   289e8:	10000315 	stw	zero,12(r2)
   289ec:	00800134 	movhi	r2,4
   289f0:	109ef184 	addi	r2,r2,31686
   289f4:	00c00044 	movi	r3,1
   289f8:	10c00005 	stb	r3,0(r2)
        pcb->state = TIME_WAIT;
   289fc:	e0bfff17 	ldw	r2,-4(fp)
   28a00:	00c00284 	movi	r3,10
   28a04:	10c00615 	stw	r3,24(r2)
        TCP_REG(&tcp_tw_pcbs, pcb);
   28a08:	00800134 	movhi	r2,4
   28a0c:	109ef704 	addi	r2,r2,31708
   28a10:	10c00017 	ldw	r3,0(r2)
   28a14:	e0bfff17 	ldw	r2,-4(fp)
   28a18:	10c00315 	stw	r3,12(r2)
   28a1c:	00800134 	movhi	r2,4
   28a20:	109ef704 	addi	r2,r2,31708
   28a24:	e0ffff17 	ldw	r3,-4(fp)
   28a28:	10c00015 	stw	r3,0(r2)
   28a2c:	002e6bc0 	call	2e6bc <tcp_timer_needed>
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
   28a30:	0000c606 	br	28d4c <tcp_process+0xbcc>
        tcp_pcb_purge(pcb);
        TCP_RMV_ACTIVE(pcb);
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
   28a34:	e0bfff17 	ldw	r2,-4(fp)
   28a38:	10800883 	ldbu	r2,34(r2)
   28a3c:	10800094 	ori	r2,r2,2
   28a40:	1007883a 	mov	r3,r2
   28a44:	e0bfff17 	ldw	r2,-4(fp)
   28a48:	10c00885 	stb	r3,34(r2)
        pcb->state = CLOSING;
   28a4c:	e0bfff17 	ldw	r2,-4(fp)
   28a50:	00c00204 	movi	r3,8
   28a54:	10c00615 	stw	r3,24(r2)
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
   28a58:	0000bc06 	br	28d4c <tcp_process+0xbcc>
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
   28a5c:	d0a94003 	ldbu	r2,-23296(gp)
   28a60:	10803fcc 	andi	r2,r2,255
   28a64:	1080040c 	andi	r2,r2,16
   28a68:	1000b826 	beq	r2,zero,28d4c <tcp_process+0xbcc>
   28a6c:	e0bfff17 	ldw	r2,-4(fp)
   28a70:	10c01517 	ldw	r3,84(r2)
   28a74:	d0a93f17 	ldw	r2,-23300(gp)
   28a78:	1880b41e 	bne	r3,r2,28d4c <tcp_process+0xbcc>
      pcb->state = FIN_WAIT_2;
   28a7c:	e0bfff17 	ldw	r2,-4(fp)
   28a80:	00c00184 	movi	r3,6
   28a84:	10c00615 	stw	r3,24(r2)
    }
    break;
   28a88:	0000b006 	br	28d4c <tcp_process+0xbcc>
  case FIN_WAIT_2:
    tcp_receive(pcb);
   28a8c:	e13fff17 	ldw	r4,-4(fp)
   28a90:	00290080 	call	29008 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
   28a94:	d0a94103 	ldbu	r2,-23292(gp)
   28a98:	10803fcc 	andi	r2,r2,255
   28a9c:	1080080c 	andi	r2,r2,32
   28aa0:	1000ac26 	beq	r2,zero,28d54 <tcp_process+0xbd4>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
   28aa4:	e0bfff17 	ldw	r2,-4(fp)
   28aa8:	10800883 	ldbu	r2,34(r2)
   28aac:	10800094 	ori	r2,r2,2
   28ab0:	1007883a 	mov	r3,r2
   28ab4:	e0bfff17 	ldw	r2,-4(fp)
   28ab8:	10c00885 	stb	r3,34(r2)
      tcp_pcb_purge(pcb);
   28abc:	e13fff17 	ldw	r4,-4(fp)
   28ac0:	0026b2c0 	call	26b2c <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
   28ac4:	00800134 	movhi	r2,4
   28ac8:	109ef204 	addi	r2,r2,31688
   28acc:	10c00017 	ldw	r3,0(r2)
   28ad0:	e0bfff17 	ldw	r2,-4(fp)
   28ad4:	1880081e 	bne	r3,r2,28af8 <tcp_process+0x978>
   28ad8:	00800134 	movhi	r2,4
   28adc:	109ef204 	addi	r2,r2,31688
   28ae0:	10800017 	ldw	r2,0(r2)
   28ae4:	10c00317 	ldw	r3,12(r2)
   28ae8:	00800134 	movhi	r2,4
   28aec:	109ef204 	addi	r2,r2,31688
   28af0:	10c00015 	stw	r3,0(r2)
   28af4:	00001f06 	br	28b74 <tcp_process+0x9f4>
   28af8:	00800134 	movhi	r2,4
   28afc:	109ef204 	addi	r2,r2,31688
   28b00:	10c00017 	ldw	r3,0(r2)
   28b04:	00800134 	movhi	r2,4
   28b08:	109ef504 	addi	r2,r2,31700
   28b0c:	10c00015 	stw	r3,0(r2)
   28b10:	00001406 	br	28b64 <tcp_process+0x9e4>
   28b14:	00800134 	movhi	r2,4
   28b18:	109ef504 	addi	r2,r2,31700
   28b1c:	10800017 	ldw	r2,0(r2)
   28b20:	10c00317 	ldw	r3,12(r2)
   28b24:	e0bfff17 	ldw	r2,-4(fp)
   28b28:	1880071e 	bne	r3,r2,28b48 <tcp_process+0x9c8>
   28b2c:	00800134 	movhi	r2,4
   28b30:	109ef504 	addi	r2,r2,31700
   28b34:	10800017 	ldw	r2,0(r2)
   28b38:	e0ffff17 	ldw	r3,-4(fp)
   28b3c:	18c00317 	ldw	r3,12(r3)
   28b40:	10c00315 	stw	r3,12(r2)
   28b44:	00000b06 	br	28b74 <tcp_process+0x9f4>
   28b48:	00800134 	movhi	r2,4
   28b4c:	109ef504 	addi	r2,r2,31700
   28b50:	10800017 	ldw	r2,0(r2)
   28b54:	10c00317 	ldw	r3,12(r2)
   28b58:	00800134 	movhi	r2,4
   28b5c:	109ef504 	addi	r2,r2,31700
   28b60:	10c00015 	stw	r3,0(r2)
   28b64:	00800134 	movhi	r2,4
   28b68:	109ef504 	addi	r2,r2,31700
   28b6c:	10800017 	ldw	r2,0(r2)
   28b70:	103fe81e 	bne	r2,zero,28b14 <tcp_process+0x994>
   28b74:	e0bfff17 	ldw	r2,-4(fp)
   28b78:	10000315 	stw	zero,12(r2)
   28b7c:	00800134 	movhi	r2,4
   28b80:	109ef184 	addi	r2,r2,31686
   28b84:	00c00044 	movi	r3,1
   28b88:	10c00005 	stb	r3,0(r2)
      pcb->state = TIME_WAIT;
   28b8c:	e0bfff17 	ldw	r2,-4(fp)
   28b90:	00c00284 	movi	r3,10
   28b94:	10c00615 	stw	r3,24(r2)
      TCP_REG(&tcp_tw_pcbs, pcb);
   28b98:	00800134 	movhi	r2,4
   28b9c:	109ef704 	addi	r2,r2,31708
   28ba0:	10c00017 	ldw	r3,0(r2)
   28ba4:	e0bfff17 	ldw	r2,-4(fp)
   28ba8:	10c00315 	stw	r3,12(r2)
   28bac:	00800134 	movhi	r2,4
   28bb0:	109ef704 	addi	r2,r2,31708
   28bb4:	e0ffff17 	ldw	r3,-4(fp)
   28bb8:	10c00015 	stw	r3,0(r2)
   28bbc:	002e6bc0 	call	2e6bc <tcp_timer_needed>
    }
    break;
   28bc0:	00006406 	br	28d54 <tcp_process+0xbd4>
  case CLOSING:
    tcp_receive(pcb);
   28bc4:	e13fff17 	ldw	r4,-4(fp)
   28bc8:	00290080 	call	29008 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
   28bcc:	d0a94003 	ldbu	r2,-23296(gp)
   28bd0:	10803fcc 	andi	r2,r2,255
   28bd4:	1080040c 	andi	r2,r2,16
   28bd8:	10006026 	beq	r2,zero,28d5c <tcp_process+0xbdc>
   28bdc:	e0bfff17 	ldw	r2,-4(fp)
   28be0:	10c01517 	ldw	r3,84(r2)
   28be4:	d0a93f17 	ldw	r2,-23300(gp)
   28be8:	18805c1e 	bne	r3,r2,28d5c <tcp_process+0xbdc>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
   28bec:	e13fff17 	ldw	r4,-4(fp)
   28bf0:	0026b2c0 	call	26b2c <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
   28bf4:	00800134 	movhi	r2,4
   28bf8:	109ef204 	addi	r2,r2,31688
   28bfc:	10c00017 	ldw	r3,0(r2)
   28c00:	e0bfff17 	ldw	r2,-4(fp)
   28c04:	1880081e 	bne	r3,r2,28c28 <tcp_process+0xaa8>
   28c08:	00800134 	movhi	r2,4
   28c0c:	109ef204 	addi	r2,r2,31688
   28c10:	10800017 	ldw	r2,0(r2)
   28c14:	10c00317 	ldw	r3,12(r2)
   28c18:	00800134 	movhi	r2,4
   28c1c:	109ef204 	addi	r2,r2,31688
   28c20:	10c00015 	stw	r3,0(r2)
   28c24:	00001f06 	br	28ca4 <tcp_process+0xb24>
   28c28:	00800134 	movhi	r2,4
   28c2c:	109ef204 	addi	r2,r2,31688
   28c30:	10c00017 	ldw	r3,0(r2)
   28c34:	00800134 	movhi	r2,4
   28c38:	109ef504 	addi	r2,r2,31700
   28c3c:	10c00015 	stw	r3,0(r2)
   28c40:	00001406 	br	28c94 <tcp_process+0xb14>
   28c44:	00800134 	movhi	r2,4
   28c48:	109ef504 	addi	r2,r2,31700
   28c4c:	10800017 	ldw	r2,0(r2)
   28c50:	10c00317 	ldw	r3,12(r2)
   28c54:	e0bfff17 	ldw	r2,-4(fp)
   28c58:	1880071e 	bne	r3,r2,28c78 <tcp_process+0xaf8>
   28c5c:	00800134 	movhi	r2,4
   28c60:	109ef504 	addi	r2,r2,31700
   28c64:	10800017 	ldw	r2,0(r2)
   28c68:	e0ffff17 	ldw	r3,-4(fp)
   28c6c:	18c00317 	ldw	r3,12(r3)
   28c70:	10c00315 	stw	r3,12(r2)
   28c74:	00000b06 	br	28ca4 <tcp_process+0xb24>
   28c78:	00800134 	movhi	r2,4
   28c7c:	109ef504 	addi	r2,r2,31700
   28c80:	10800017 	ldw	r2,0(r2)
   28c84:	10c00317 	ldw	r3,12(r2)
   28c88:	00800134 	movhi	r2,4
   28c8c:	109ef504 	addi	r2,r2,31700
   28c90:	10c00015 	stw	r3,0(r2)
   28c94:	00800134 	movhi	r2,4
   28c98:	109ef504 	addi	r2,r2,31700
   28c9c:	10800017 	ldw	r2,0(r2)
   28ca0:	103fe81e 	bne	r2,zero,28c44 <tcp_process+0xac4>
   28ca4:	e0bfff17 	ldw	r2,-4(fp)
   28ca8:	10000315 	stw	zero,12(r2)
   28cac:	00800134 	movhi	r2,4
   28cb0:	109ef184 	addi	r2,r2,31686
   28cb4:	00c00044 	movi	r3,1
   28cb8:	10c00005 	stb	r3,0(r2)
      pcb->state = TIME_WAIT;
   28cbc:	e0bfff17 	ldw	r2,-4(fp)
   28cc0:	00c00284 	movi	r3,10
   28cc4:	10c00615 	stw	r3,24(r2)
      TCP_REG(&tcp_tw_pcbs, pcb);
   28cc8:	00800134 	movhi	r2,4
   28ccc:	109ef704 	addi	r2,r2,31708
   28cd0:	10c00017 	ldw	r3,0(r2)
   28cd4:	e0bfff17 	ldw	r2,-4(fp)
   28cd8:	10c00315 	stw	r3,12(r2)
   28cdc:	00800134 	movhi	r2,4
   28ce0:	109ef704 	addi	r2,r2,31708
   28ce4:	e0ffff17 	ldw	r3,-4(fp)
   28ce8:	10c00015 	stw	r3,0(r2)
   28cec:	002e6bc0 	call	2e6bc <tcp_timer_needed>
    }
    break;
   28cf0:	00001a06 	br	28d5c <tcp_process+0xbdc>
  case LAST_ACK:
    tcp_receive(pcb);
   28cf4:	e13fff17 	ldw	r4,-4(fp)
   28cf8:	00290080 	call	29008 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
   28cfc:	d0a94003 	ldbu	r2,-23296(gp)
   28d00:	10803fcc 	andi	r2,r2,255
   28d04:	1080040c 	andi	r2,r2,16
   28d08:	10001626 	beq	r2,zero,28d64 <tcp_process+0xbe4>
   28d0c:	e0bfff17 	ldw	r2,-4(fp)
   28d10:	10c01517 	ldw	r3,84(r2)
   28d14:	d0a93f17 	ldw	r2,-23300(gp)
   28d18:	1880121e 	bne	r3,r2,28d64 <tcp_process+0xbe4>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags |= TF_CLOSED;
   28d1c:	d0a94103 	ldbu	r2,-23292(gp)
   28d20:	10800414 	ori	r2,r2,16
   28d24:	d0a94105 	stb	r2,-23292(gp)
    }
    break;
   28d28:	00000e06 	br	28d64 <tcp_process+0xbe4>
  default:
    break;
   28d2c:	0001883a 	nop
   28d30:	00000d06 	br	28d68 <tcp_process+0xbe8>
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
    }
    break;
   28d34:	0001883a 	nop
   28d38:	00000b06 	br	28d68 <tcp_process+0xbe8>
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    }
    break;
   28d3c:	0001883a 	nop
   28d40:	00000906 	br	28d68 <tcp_process+0xbe8>
    tcp_receive(pcb);
    if (recv_flags & TF_GOT_FIN) { /* passive close */
      tcp_ack_now(pcb);
      pcb->state = CLOSE_WAIT;
    }
    break;
   28d44:	0001883a 	nop
   28d48:	00000706 	br	28d68 <tcp_process+0xbe8>
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
   28d4c:	0001883a 	nop
   28d50:	00000506 	br	28d68 <tcp_process+0xbe8>
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
   28d54:	0001883a 	nop
   28d58:	00000306 	br	28d68 <tcp_process+0xbe8>
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
   28d5c:	0001883a 	nop
   28d60:	00000106 	br	28d68 <tcp_process+0xbe8>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags |= TF_CLOSED;
    }
    break;
   28d64:	0001883a 	nop
  default:
    break;
  }
  return ERR_OK;
   28d68:	0005883a 	mov	r2,zero
}
   28d6c:	e037883a 	mov	sp,fp
   28d70:	dfc00117 	ldw	ra,4(sp)
   28d74:	df000017 	ldw	fp,0(sp)
   28d78:	dec00204 	addi	sp,sp,8
   28d7c:	f800283a 	ret

00028d80 <tcp_oos_insert_segment>:
 *
 * Called from tcp_receive()
 */
static void
tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
{
   28d80:	defffb04 	addi	sp,sp,-20
   28d84:	dfc00415 	stw	ra,16(sp)
   28d88:	df000315 	stw	fp,12(sp)
   28d8c:	df000304 	addi	fp,sp,12
   28d90:	e13ffe15 	stw	r4,-8(fp)
   28d94:	e17fff15 	stw	r5,-4(fp)
  struct tcp_seg *old_seg;

  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
   28d98:	e0bffe17 	ldw	r2,-8(fp)
   28d9c:	10800417 	ldw	r2,16(r2)
   28da0:	10c00303 	ldbu	r3,12(r2)
   28da4:	10800343 	ldbu	r2,13(r2)
   28da8:	1004923a 	slli	r2,r2,8
   28dac:	10c4b03a 	or	r2,r2,r3
   28db0:	10bfffcc 	andi	r2,r2,65535
   28db4:	1004d23a 	srli	r2,r2,8
   28db8:	10ffffcc 	andi	r3,r2,65535
   28dbc:	e0bffe17 	ldw	r2,-8(fp)
   28dc0:	10800417 	ldw	r2,16(r2)
   28dc4:	11000303 	ldbu	r4,12(r2)
   28dc8:	10800343 	ldbu	r2,13(r2)
   28dcc:	1004923a 	slli	r2,r2,8
   28dd0:	1104b03a 	or	r2,r2,r4
   28dd4:	10bfffcc 	andi	r2,r2,65535
   28dd8:	1004923a 	slli	r2,r2,8
   28ddc:	10bfffcc 	andi	r2,r2,65535
   28de0:	1884b03a 	or	r2,r3,r2
   28de4:	1080004c 	andi	r2,r2,1
   28de8:	10003626 	beq	r2,zero,28ec4 <tcp_oos_insert_segment+0x144>
    /* received segment overlaps all following segments */
    tcp_segs_free(next);
   28dec:	e13fff17 	ldw	r4,-4(fp)
   28df0:	00264a80 	call	264a8 <tcp_segs_free>
    next = NULL;
   28df4:	e03fff15 	stw	zero,-4(fp)
   28df8:	00007b06 	br	28fe8 <tcp_oos_insert_segment+0x268>
       oos queue may have segments with FIN flag */
    while (next &&
           TCP_SEQ_GEQ((seqno + cseg->len),
                      (next->tcphdr->seqno + next->len))) {
      /* cseg with FIN already processed */
      if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
   28dfc:	e0bfff17 	ldw	r2,-4(fp)
   28e00:	10800417 	ldw	r2,16(r2)
   28e04:	10c00303 	ldbu	r3,12(r2)
   28e08:	10800343 	ldbu	r2,13(r2)
   28e0c:	1004923a 	slli	r2,r2,8
   28e10:	10c4b03a 	or	r2,r2,r3
   28e14:	10bfffcc 	andi	r2,r2,65535
   28e18:	1004d23a 	srli	r2,r2,8
   28e1c:	10ffffcc 	andi	r3,r2,65535
   28e20:	e0bfff17 	ldw	r2,-4(fp)
   28e24:	10800417 	ldw	r2,16(r2)
   28e28:	11000303 	ldbu	r4,12(r2)
   28e2c:	10800343 	ldbu	r2,13(r2)
   28e30:	1004923a 	slli	r2,r2,8
   28e34:	1104b03a 	or	r2,r2,r4
   28e38:	10bfffcc 	andi	r2,r2,65535
   28e3c:	1004923a 	slli	r2,r2,8
   28e40:	10bfffcc 	andi	r2,r2,65535
   28e44:	1884b03a 	or	r2,r3,r2
   28e48:	1080004c 	andi	r2,r2,1
   28e4c:	10001626 	beq	r2,zero,28ea8 <tcp_oos_insert_segment+0x128>
        TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
   28e50:	e0bffe17 	ldw	r2,-8(fp)
   28e54:	10800417 	ldw	r2,16(r2)
   28e58:	e0fffe17 	ldw	r3,-8(fp)
   28e5c:	18c00417 	ldw	r3,16(r3)
   28e60:	19000303 	ldbu	r4,12(r3)
   28e64:	18c00343 	ldbu	r3,13(r3)
   28e68:	1806923a 	slli	r3,r3,8
   28e6c:	1906b03a 	or	r3,r3,r4
   28e70:	18c04014 	ori	r3,r3,256
   28e74:	193fffcc 	andi	r4,r3,65535
   28e78:	21003fcc 	andi	r4,r4,255
   28e7c:	11400303 	ldbu	r5,12(r2)
   28e80:	280a703a 	and	r5,r5,zero
   28e84:	2908b03a 	or	r4,r5,r4
   28e88:	11000305 	stb	r4,12(r2)
   28e8c:	18ffffcc 	andi	r3,r3,65535
   28e90:	1806d23a 	srli	r3,r3,8
   28e94:	18ffffcc 	andi	r3,r3,65535
   28e98:	11000343 	ldbu	r4,13(r2)
   28e9c:	2008703a 	and	r4,r4,zero
   28ea0:	20c6b03a 	or	r3,r4,r3
   28ea4:	10c00345 	stb	r3,13(r2)
      }
      old_seg = next;
   28ea8:	e0bfff17 	ldw	r2,-4(fp)
   28eac:	e0bffd15 	stw	r2,-12(fp)
      next = next->next;
   28eb0:	e0bfff17 	ldw	r2,-4(fp)
   28eb4:	10800017 	ldw	r2,0(r2)
   28eb8:	e0bfff15 	stw	r2,-4(fp)
      tcp_seg_free(old_seg);
   28ebc:	e13ffd17 	ldw	r4,-12(fp)
   28ec0:	00264f80 	call	264f8 <tcp_seg_free>
    next = NULL;
  }
  else {
    /* delete some following segments
       oos queue may have segments with FIN flag */
    while (next &&
   28ec4:	e0bfff17 	ldw	r2,-4(fp)
   28ec8:	10001826 	beq	r2,zero,28f2c <tcp_oos_insert_segment+0x1ac>
           TCP_SEQ_GEQ((seqno + cseg->len),
   28ecc:	e0bffe17 	ldw	r2,-8(fp)
   28ed0:	1080020b 	ldhu	r2,8(r2)
   28ed4:	10ffffcc 	andi	r3,r2,65535
   28ed8:	d0a93e17 	ldw	r2,-23304(gp)
   28edc:	1887883a 	add	r3,r3,r2
   28ee0:	e0bfff17 	ldw	r2,-4(fp)
   28ee4:	10800417 	ldw	r2,16(r2)
   28ee8:	11000103 	ldbu	r4,4(r2)
   28eec:	11400143 	ldbu	r5,5(r2)
   28ef0:	280a923a 	slli	r5,r5,8
   28ef4:	2908b03a 	or	r4,r5,r4
   28ef8:	11400183 	ldbu	r5,6(r2)
   28efc:	280a943a 	slli	r5,r5,16
   28f00:	2908b03a 	or	r4,r5,r4
   28f04:	108001c3 	ldbu	r2,7(r2)
   28f08:	1004963a 	slli	r2,r2,24
   28f0c:	1104b03a 	or	r2,r2,r4
   28f10:	1009883a 	mov	r4,r2
   28f14:	e0bfff17 	ldw	r2,-4(fp)
   28f18:	1080020b 	ldhu	r2,8(r2)
   28f1c:	10bfffcc 	andi	r2,r2,65535
   28f20:	2085883a 	add	r2,r4,r2
   28f24:	1885c83a 	sub	r2,r3,r2
    next = NULL;
  }
  else {
    /* delete some following segments
       oos queue may have segments with FIN flag */
    while (next &&
   28f28:	103fb40e 	bge	r2,zero,28dfc <tcp_oos_insert_segment+0x7c>
      }
      old_seg = next;
      next = next->next;
      tcp_seg_free(old_seg);
    }
    if (next &&
   28f2c:	e0bfff17 	ldw	r2,-4(fp)
   28f30:	10002d26 	beq	r2,zero,28fe8 <tcp_oos_insert_segment+0x268>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
   28f34:	e0bffe17 	ldw	r2,-8(fp)
   28f38:	1080020b 	ldhu	r2,8(r2)
   28f3c:	10ffffcc 	andi	r3,r2,65535
   28f40:	d0a93e17 	ldw	r2,-23304(gp)
   28f44:	1887883a 	add	r3,r3,r2
   28f48:	e0bfff17 	ldw	r2,-4(fp)
   28f4c:	10800417 	ldw	r2,16(r2)
   28f50:	11000103 	ldbu	r4,4(r2)
   28f54:	11400143 	ldbu	r5,5(r2)
   28f58:	280a923a 	slli	r5,r5,8
   28f5c:	2908b03a 	or	r4,r5,r4
   28f60:	11400183 	ldbu	r5,6(r2)
   28f64:	280a943a 	slli	r5,r5,16
   28f68:	2908b03a 	or	r4,r5,r4
   28f6c:	108001c3 	ldbu	r2,7(r2)
   28f70:	1004963a 	slli	r2,r2,24
   28f74:	1104b03a 	or	r2,r2,r4
   28f78:	1885c83a 	sub	r2,r3,r2
      }
      old_seg = next;
      next = next->next;
      tcp_seg_free(old_seg);
    }
    if (next &&
   28f7c:	00801a0e 	bge	zero,r2,28fe8 <tcp_oos_insert_segment+0x268>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
      /* We need to trim the incoming segment. */
      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
   28f80:	e0bfff17 	ldw	r2,-4(fp)
   28f84:	10800417 	ldw	r2,16(r2)
   28f88:	10c00103 	ldbu	r3,4(r2)
   28f8c:	11000143 	ldbu	r4,5(r2)
   28f90:	2008923a 	slli	r4,r4,8
   28f94:	20c6b03a 	or	r3,r4,r3
   28f98:	11000183 	ldbu	r4,6(r2)
   28f9c:	2008943a 	slli	r4,r4,16
   28fa0:	20c6b03a 	or	r3,r4,r3
   28fa4:	108001c3 	ldbu	r2,7(r2)
   28fa8:	1004963a 	slli	r2,r2,24
   28fac:	10c4b03a 	or	r2,r2,r3
   28fb0:	1007883a 	mov	r3,r2
   28fb4:	d0a93e17 	ldw	r2,-23304(gp)
   28fb8:	1885c83a 	sub	r2,r3,r2
   28fbc:	1007883a 	mov	r3,r2
   28fc0:	e0bffe17 	ldw	r2,-8(fp)
   28fc4:	10c0020d 	sth	r3,8(r2)
      pbuf_realloc(cseg->p, cseg->len);
   28fc8:	e0bffe17 	ldw	r2,-8(fp)
   28fcc:	10c00117 	ldw	r3,4(r2)
   28fd0:	e0bffe17 	ldw	r2,-8(fp)
   28fd4:	1080020b 	ldhu	r2,8(r2)
   28fd8:	10bfffcc 	andi	r2,r2,65535
   28fdc:	1809883a 	mov	r4,r3
   28fe0:	100b883a 	mov	r5,r2
   28fe4:	00234500 	call	23450 <pbuf_realloc>
    }
  }
  cseg->next = next;
   28fe8:	e0bffe17 	ldw	r2,-8(fp)
   28fec:	e0ffff17 	ldw	r3,-4(fp)
   28ff0:	10c00015 	stw	r3,0(r2)
}
   28ff4:	e037883a 	mov	sp,fp
   28ff8:	dfc00117 	ldw	ra,4(sp)
   28ffc:	df000017 	ldw	fp,0(sp)
   29000:	dec00204 	addi	sp,sp,8
   29004:	f800283a 	ret

00029008 <tcp_receive>:
 *
 * Called from tcp_process().
 */
static void
tcp_receive(struct tcp_pcb *pcb)
{
   29008:	defff204 	addi	sp,sp,-56
   2900c:	dfc00d15 	stw	ra,52(sp)
   29010:	df000c15 	stw	fp,48(sp)
   29014:	dc000b15 	stw	r16,44(sp)
   29018:	df000b04 	addi	fp,sp,44
   2901c:	e13fff15 	stw	r4,-4(fp)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  int found_dupack = 0;
   29020:	e03ffa15 	stw	zero,-24(fp)
  u16_t ooseq_qlen;
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */

  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);

  if (flags & TCP_ACK) {
   29024:	d0a94003 	ldbu	r2,-23296(gp)
   29028:	10803fcc 	andi	r2,r2,255
   2902c:	1080040c 	andi	r2,r2,16
   29030:	1002a926 	beq	r2,zero,29ad8 <tcp_receive+0xad0>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
   29034:	e0bfff17 	ldw	r2,-4(fp)
   29038:	1080190b 	ldhu	r2,100(r2)
   2903c:	10ffffcc 	andi	r3,r2,65535
   29040:	e0bfff17 	ldw	r2,-4(fp)
   29044:	10801717 	ldw	r2,92(r2)
   29048:	1885883a 	add	r2,r3,r2
   2904c:	e0bffb15 	stw	r2,-20(fp)

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
   29050:	e0bfff17 	ldw	r2,-4(fp)
   29054:	10c01617 	ldw	r3,88(r2)
   29058:	d0a93e17 	ldw	r2,-23304(gp)
   2905c:	1885c83a 	sub	r2,r3,r2
   29060:	10001716 	blt	r2,zero,290c0 <tcp_receive+0xb8>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
   29064:	e0bfff17 	ldw	r2,-4(fp)
   29068:	10c01617 	ldw	r3,88(r2)
   2906c:	d0a93e17 	ldw	r2,-23304(gp)

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
   29070:	1880051e 	bne	r3,r2,29088 <tcp_receive+0x80>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
   29074:	e0bfff17 	ldw	r2,-4(fp)
   29078:	10c01717 	ldw	r3,92(r2)
   2907c:	d0a93f17 	ldw	r2,-23300(gp)
   29080:	1885c83a 	sub	r2,r3,r2
   29084:	10000e16 	blt	r2,zero,290c0 <tcp_receive+0xb8>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
   29088:	e0bfff17 	ldw	r2,-4(fp)
   2908c:	10c01717 	ldw	r3,92(r2)
   29090:	d0a93f17 	ldw	r2,-23300(gp)
  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
   29094:	18803e1e 	bne	r3,r2,29190 <tcp_receive+0x188>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
   29098:	d0a93c17 	ldw	r2,-23312(gp)
   2909c:	10c00383 	ldbu	r3,14(r2)
   290a0:	108003c3 	ldbu	r2,15(r2)
   290a4:	1004923a 	slli	r2,r2,8
   290a8:	10c4b03a 	or	r2,r2,r3
   290ac:	e0ffff17 	ldw	r3,-4(fp)
   290b0:	18c0190b 	ldhu	r3,100(r3)
   290b4:	10bfffcc 	andi	r2,r2,65535
   290b8:	18ffffcc 	andi	r3,r3,65535
   290bc:	1880342e 	bgeu	r3,r2,29190 <tcp_receive+0x188>
      pcb->snd_wnd = tcphdr->wnd;
   290c0:	d0a93c17 	ldw	r2,-23312(gp)
   290c4:	10c00383 	ldbu	r3,14(r2)
   290c8:	108003c3 	ldbu	r2,15(r2)
   290cc:	1004923a 	slli	r2,r2,8
   290d0:	10c4b03a 	or	r2,r2,r3
   290d4:	1007883a 	mov	r3,r2
   290d8:	e0bfff17 	ldw	r2,-4(fp)
   290dc:	10c0190d 	sth	r3,100(r2)
      /* keep track of the biggest window announced by the remote host to calculate
         the maximum segment size */
      if (pcb->snd_wnd_max < tcphdr->wnd) {
   290e0:	e0bfff17 	ldw	r2,-4(fp)
   290e4:	10c0198b 	ldhu	r3,102(r2)
   290e8:	d0a93c17 	ldw	r2,-23312(gp)
   290ec:	11000383 	ldbu	r4,14(r2)
   290f0:	108003c3 	ldbu	r2,15(r2)
   290f4:	1004923a 	slli	r2,r2,8
   290f8:	1104b03a 	or	r2,r2,r4
   290fc:	18ffffcc 	andi	r3,r3,65535
   29100:	10bfffcc 	andi	r2,r2,65535
   29104:	1880082e 	bgeu	r3,r2,29128 <tcp_receive+0x120>
        pcb->snd_wnd_max = tcphdr->wnd;
   29108:	d0a93c17 	ldw	r2,-23312(gp)
   2910c:	10c00383 	ldbu	r3,14(r2)
   29110:	108003c3 	ldbu	r2,15(r2)
   29114:	1004923a 	slli	r2,r2,8
   29118:	10c4b03a 	or	r2,r2,r3
   2911c:	1007883a 	mov	r3,r2
   29120:	e0bfff17 	ldw	r2,-4(fp)
   29124:	10c0198d 	sth	r3,102(r2)
      }
      pcb->snd_wl1 = seqno;
   29128:	d0e93e17 	ldw	r3,-23304(gp)
   2912c:	e0bfff17 	ldw	r2,-4(fp)
   29130:	10c01615 	stw	r3,88(r2)
      pcb->snd_wl2 = ackno;
   29134:	d0e93f17 	ldw	r3,-23300(gp)
   29138:	e0bfff17 	ldw	r2,-4(fp)
   2913c:	10c01715 	stw	r3,92(r2)
      if (pcb->snd_wnd == 0) {
   29140:	e0bfff17 	ldw	r2,-4(fp)
   29144:	1080190b 	ldhu	r2,100(r2)
   29148:	10bfffcc 	andi	r2,r2,65535
   2914c:	10000a1e 	bne	r2,zero,29178 <tcp_receive+0x170>
        if (pcb->persist_backoff == 0) {
   29150:	e0bfff17 	ldw	r2,-4(fp)
   29154:	10802843 	ldbu	r2,161(r2)
   29158:	10803fcc 	andi	r2,r2,255
   2915c:	10000c1e 	bne	r2,zero,29190 <tcp_receive+0x188>
          /* start persist timer */
          pcb->persist_cnt = 0;
   29160:	e0bfff17 	ldw	r2,-4(fp)
   29164:	10002805 	stb	zero,160(r2)
          pcb->persist_backoff = 1;
   29168:	e0bfff17 	ldw	r2,-4(fp)
   2916c:	00c00044 	movi	r3,1
   29170:	10c02845 	stb	r3,161(r2)
   29174:	00000606 	br	29190 <tcp_receive+0x188>
        }
      } else if (pcb->persist_backoff > 0) {
   29178:	e0bfff17 	ldw	r2,-4(fp)
   2917c:	10802843 	ldbu	r2,161(r2)
   29180:	10803fcc 	andi	r2,r2,255
   29184:	10000226 	beq	r2,zero,29190 <tcp_receive+0x188>
        /* stop persist timer */
          pcb->persist_backoff = 0;
   29188:	e0bfff17 	ldw	r2,-4(fp)
   2918c:	10002845 	stb	zero,161(r2)
     * If it only passes 1, should reset dupack counter
     *
     */

    /* Clause 1 */
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
   29190:	d0e93f17 	ldw	r3,-23300(gp)
   29194:	e0bfff17 	ldw	r2,-4(fp)
   29198:	10801317 	ldw	r2,76(r2)
   2919c:	1885c83a 	sub	r2,r3,r2
   291a0:	00804b16 	blt	zero,r2,292d0 <tcp_receive+0x2c8>
      pcb->acked = 0;
   291a4:	e0bfff17 	ldw	r2,-4(fp)
   291a8:	10001a0d 	sth	zero,104(r2)
      /* Clause 2 */
      if (tcplen == 0) {
   291ac:	d0a9408b 	ldhu	r2,-23294(gp)
   291b0:	10bfffcc 	andi	r2,r2,65535
   291b4:	1000411e 	bne	r2,zero,292bc <tcp_receive+0x2b4>
        /* Clause 3 */
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
   291b8:	e0bfff17 	ldw	r2,-4(fp)
   291bc:	10c01717 	ldw	r3,92(r2)
   291c0:	e0bfff17 	ldw	r2,-4(fp)
   291c4:	1080190b 	ldhu	r2,100(r2)
   291c8:	10bfffcc 	andi	r2,r2,65535
   291cc:	1887883a 	add	r3,r3,r2
   291d0:	e0bffb17 	ldw	r2,-20(fp)
   291d4:	1880391e 	bne	r3,r2,292bc <tcp_receive+0x2b4>
          /* Clause 4 */
          if (pcb->rtime >= 0) {
   291d8:	e0bfff17 	ldw	r2,-4(fp)
   291dc:	10800e0b 	ldhu	r2,56(r2)
   291e0:	10bfffcc 	andi	r2,r2,65535
   291e4:	10a0001c 	xori	r2,r2,32768
   291e8:	10a00004 	addi	r2,r2,-32768
   291ec:	10003316 	blt	r2,zero,292bc <tcp_receive+0x2b4>
            /* Clause 5 */
            if (pcb->lastack == ackno) {
   291f0:	e0bfff17 	ldw	r2,-4(fp)
   291f4:	10c01317 	ldw	r3,76(r2)
   291f8:	d0a93f17 	ldw	r2,-23300(gp)
   291fc:	18802f1e 	bne	r3,r2,292bc <tcp_receive+0x2b4>
              found_dupack = 1;
   29200:	00800044 	movi	r2,1
   29204:	e0bffa15 	stw	r2,-24(fp)
              if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
   29208:	e0bfff17 	ldw	r2,-4(fp)
   2920c:	108012c3 	ldbu	r2,75(r2)
   29210:	10800044 	addi	r2,r2,1
   29214:	e0ffff17 	ldw	r3,-4(fp)
   29218:	18c012c3 	ldbu	r3,75(r3)
   2921c:	10803fcc 	andi	r2,r2,255
   29220:	18c03fcc 	andi	r3,r3,255
   29224:	1880062e 	bgeu	r3,r2,29240 <tcp_receive+0x238>
                ++pcb->dupacks;
   29228:	e0bfff17 	ldw	r2,-4(fp)
   2922c:	108012c3 	ldbu	r2,75(r2)
   29230:	10800044 	addi	r2,r2,1
   29234:	1007883a 	mov	r3,r2
   29238:	e0bfff17 	ldw	r2,-4(fp)
   2923c:	10c012c5 	stb	r3,75(r2)
              }
              if (pcb->dupacks > 3) {
   29240:	e0bfff17 	ldw	r2,-4(fp)
   29244:	108012c3 	ldbu	r2,75(r2)
   29248:	10803fcc 	andi	r2,r2,255
   2924c:	10800130 	cmpltui	r2,r2,4
   29250:	1000131e 	bne	r2,zero,292a0 <tcp_receive+0x298>
                /* Inflate the congestion window, but not if it means that
                   the value overflows. */
                if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
   29254:	e0bfff17 	ldw	r2,-4(fp)
   29258:	10c0140b 	ldhu	r3,80(r2)
   2925c:	e0bfff17 	ldw	r2,-4(fp)
   29260:	10800e8b 	ldhu	r2,58(r2)
   29264:	1885883a 	add	r2,r3,r2
   29268:	e0ffff17 	ldw	r3,-4(fp)
   2926c:	18c0140b 	ldhu	r3,80(r3)
   29270:	10bfffcc 	andi	r2,r2,65535
   29274:	18ffffcc 	andi	r3,r3,65535
   29278:	1880102e 	bgeu	r3,r2,292bc <tcp_receive+0x2b4>
                  pcb->cwnd += pcb->mss;
   2927c:	e0bfff17 	ldw	r2,-4(fp)
   29280:	10c0140b 	ldhu	r3,80(r2)
   29284:	e0bfff17 	ldw	r2,-4(fp)
   29288:	10800e8b 	ldhu	r2,58(r2)
   2928c:	1885883a 	add	r2,r3,r2
   29290:	1007883a 	mov	r3,r2
   29294:	e0bfff17 	ldw	r2,-4(fp)
   29298:	10c0140d 	sth	r3,80(r2)
   2929c:	00000706 	br	292bc <tcp_receive+0x2b4>
                }
              } else if (pcb->dupacks == 3) {
   292a0:	e0bfff17 	ldw	r2,-4(fp)
   292a4:	108012c3 	ldbu	r2,75(r2)
   292a8:	10803fcc 	andi	r2,r2,255
   292ac:	108000d8 	cmpnei	r2,r2,3
   292b0:	1000021e 	bne	r2,zero,292bc <tcp_receive+0x2b4>
                /* Do fast retransmit */
                tcp_rexmit_fast(pcb);
   292b4:	e13fff17 	ldw	r4,-4(fp)
   292b8:	002e0e80 	call	2e0e8 <tcp_rexmit_fast>
          }
        }
      }
      /* If Clause (1) or more is true, but not a duplicate ack, reset
       * count of consecutive duplicate acks */
      if (!found_dupack) {
   292bc:	e0bffa17 	ldw	r2,-24(fp)
   292c0:	1001581e 	bne	r2,zero,29824 <tcp_receive+0x81c>
        pcb->dupacks = 0;
   292c4:	e0bfff17 	ldw	r2,-4(fp)
   292c8:	100012c5 	stb	zero,75(r2)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
   292cc:	00015506 	br	29824 <tcp_receive+0x81c>
      /* If Clause (1) or more is true, but not a duplicate ack, reset
       * count of consecutive duplicate acks */
      if (!found_dupack) {
        pcb->dupacks = 0;
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)){
   292d0:	e0bfff17 	ldw	r2,-4(fp)
   292d4:	10801317 	ldw	r2,76(r2)
   292d8:	0086303a 	nor	r3,zero,r2
   292dc:	d0a93f17 	ldw	r2,-23300(gp)
   292e0:	1885883a 	add	r2,r3,r2
   292e4:	10011216 	blt	r2,zero,29730 <tcp_receive+0x728>
   292e8:	d0e93f17 	ldw	r3,-23300(gp)
   292ec:	e0bfff17 	ldw	r2,-4(fp)
   292f0:	10801517 	ldw	r2,84(r2)
   292f4:	1885c83a 	sub	r2,r3,r2
   292f8:	00810d16 	blt	zero,r2,29730 <tcp_receive+0x728>
      /* We come here when the ACK acknowledges new data. */

      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
   292fc:	e0bfff17 	ldw	r2,-4(fp)
   29300:	10800883 	ldbu	r2,34(r2)
   29304:	10803fcc 	andi	r2,r2,255
   29308:	1080010c 	andi	r2,r2,4
   2930c:	10000b26 	beq	r2,zero,2933c <tcp_receive+0x334>
        pcb->flags &= ~TF_INFR;
   29310:	e0bfff17 	ldw	r2,-4(fp)
   29314:	10c00883 	ldbu	r3,34(r2)
   29318:	00bffec4 	movi	r2,-5
   2931c:	1884703a 	and	r2,r3,r2
   29320:	1007883a 	mov	r3,r2
   29324:	e0bfff17 	ldw	r2,-4(fp)
   29328:	10c00885 	stb	r3,34(r2)
        pcb->cwnd = pcb->ssthresh;
   2932c:	e0bfff17 	ldw	r2,-4(fp)
   29330:	10c0148b 	ldhu	r3,82(r2)
   29334:	e0bfff17 	ldw	r2,-4(fp)
   29338:	10c0140d 	sth	r3,80(r2)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
   2933c:	e0bfff17 	ldw	r2,-4(fp)
   29340:	10001285 	stb	zero,74(r2)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
   29344:	e0bfff17 	ldw	r2,-4(fp)
   29348:	1080110b 	ldhu	r2,68(r2)
   2934c:	10bfffcc 	andi	r2,r2,65535
   29350:	10a0001c 	xori	r2,r2,32768
   29354:	10a00004 	addi	r2,r2,-32768
   29358:	1005d0fa 	srai	r2,r2,3
   2935c:	1007883a 	mov	r3,r2
   29360:	e0bfff17 	ldw	r2,-4(fp)
   29364:	1080118b 	ldhu	r2,70(r2)
   29368:	1885883a 	add	r2,r3,r2
   2936c:	1007883a 	mov	r3,r2
   29370:	e0bfff17 	ldw	r2,-4(fp)
   29374:	10c0120d 	sth	r3,72(r2)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
   29378:	d0a93f17 	ldw	r2,-23300(gp)
   2937c:	1007883a 	mov	r3,r2
   29380:	e0bfff17 	ldw	r2,-4(fp)
   29384:	10801317 	ldw	r2,76(r2)
   29388:	1885c83a 	sub	r2,r3,r2
   2938c:	1007883a 	mov	r3,r2
   29390:	e0bfff17 	ldw	r2,-4(fp)
   29394:	10c01a0d 	sth	r3,104(r2)

      pcb->snd_buf += pcb->acked;
   29398:	e0bfff17 	ldw	r2,-4(fp)
   2939c:	10c01a8b 	ldhu	r3,106(r2)
   293a0:	e0bfff17 	ldw	r2,-4(fp)
   293a4:	10801a0b 	ldhu	r2,104(r2)
   293a8:	1885883a 	add	r2,r3,r2
   293ac:	1007883a 	mov	r3,r2
   293b0:	e0bfff17 	ldw	r2,-4(fp)
   293b4:	10c01a8d 	sth	r3,106(r2)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
   293b8:	e0bfff17 	ldw	r2,-4(fp)
   293bc:	100012c5 	stb	zero,75(r2)
      pcb->lastack = ackno;
   293c0:	d0e93f17 	ldw	r3,-23300(gp)
   293c4:	e0bfff17 	ldw	r2,-4(fp)
   293c8:	10c01315 	stw	r3,76(r2)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
   293cc:	e0bfff17 	ldw	r2,-4(fp)
   293d0:	10800617 	ldw	r2,24(r2)
   293d4:	10800130 	cmpltui	r2,r2,4
   293d8:	1000671e 	bne	r2,zero,29578 <tcp_receive+0x570>
        if (pcb->cwnd < pcb->ssthresh) {
   293dc:	e0bfff17 	ldw	r2,-4(fp)
   293e0:	10c0140b 	ldhu	r3,80(r2)
   293e4:	e0bfff17 	ldw	r2,-4(fp)
   293e8:	1080148b 	ldhu	r2,82(r2)
   293ec:	18ffffcc 	andi	r3,r3,65535
   293f0:	10bfffcc 	andi	r2,r2,65535
   293f4:	1880132e 	bgeu	r3,r2,29444 <tcp_receive+0x43c>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
   293f8:	e0bfff17 	ldw	r2,-4(fp)
   293fc:	10c0140b 	ldhu	r3,80(r2)
   29400:	e0bfff17 	ldw	r2,-4(fp)
   29404:	10800e8b 	ldhu	r2,58(r2)
   29408:	1885883a 	add	r2,r3,r2
   2940c:	e0ffff17 	ldw	r3,-4(fp)
   29410:	18c0140b 	ldhu	r3,80(r3)
   29414:	10bfffcc 	andi	r2,r2,65535
   29418:	18ffffcc 	andi	r3,r3,65535
   2941c:	1880562e 	bgeu	r3,r2,29578 <tcp_receive+0x570>
            pcb->cwnd += pcb->mss;
   29420:	e0bfff17 	ldw	r2,-4(fp)
   29424:	10c0140b 	ldhu	r3,80(r2)
   29428:	e0bfff17 	ldw	r2,-4(fp)
   2942c:	10800e8b 	ldhu	r2,58(r2)
   29430:	1885883a 	add	r2,r3,r2
   29434:	1007883a 	mov	r3,r2
   29438:	e0bfff17 	ldw	r2,-4(fp)
   2943c:	10c0140d 	sth	r3,80(r2)
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
   29440:	00004d06 	br	29578 <tcp_receive+0x570>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
            pcb->cwnd += pcb->mss;
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
   29444:	e0bfff17 	ldw	r2,-4(fp)
   29448:	10c0140b 	ldhu	r3,80(r2)
   2944c:	e0bfff17 	ldw	r2,-4(fp)
   29450:	10800e8b 	ldhu	r2,58(r2)
   29454:	113fffcc 	andi	r4,r2,65535
   29458:	e0bfff17 	ldw	r2,-4(fp)
   2945c:	10800e8b 	ldhu	r2,58(r2)
   29460:	10bfffcc 	andi	r2,r2,65535
   29464:	2089383a 	mul	r4,r4,r2
   29468:	e0bfff17 	ldw	r2,-4(fp)
   2946c:	1080140b 	ldhu	r2,80(r2)
   29470:	10bfffcc 	andi	r2,r2,65535
   29474:	2085283a 	div	r2,r4,r2
   29478:	1885883a 	add	r2,r3,r2
   2947c:	e0bffc0d 	sth	r2,-16(fp)
          if (new_cwnd > pcb->cwnd) {
   29480:	e0bfff17 	ldw	r2,-4(fp)
   29484:	1080140b 	ldhu	r2,80(r2)
   29488:	10ffffcc 	andi	r3,r2,65535
   2948c:	e0bffc0b 	ldhu	r2,-16(fp)
   29490:	1880392e 	bgeu	r3,r2,29578 <tcp_receive+0x570>
            pcb->cwnd = new_cwnd;
   29494:	e0bfff17 	ldw	r2,-4(fp)
   29498:	e0fffc0b 	ldhu	r3,-16(fp)
   2949c:	10c0140d 	sth	r3,80(r2)
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
   294a0:	00003506 	br	29578 <tcp_receive+0x570>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
   294a4:	e0bfff17 	ldw	r2,-4(fp)
   294a8:	10801d17 	ldw	r2,116(r2)
   294ac:	e0bff515 	stw	r2,-44(fp)
        pcb->unacked = pcb->unacked->next;
   294b0:	e0bfff17 	ldw	r2,-4(fp)
   294b4:	10801d17 	ldw	r2,116(r2)
   294b8:	10c00017 	ldw	r3,0(r2)
   294bc:	e0bfff17 	ldw	r2,-4(fp)
   294c0:	10c01d15 	stw	r3,116(r2)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
        /* Prevent ACK for FIN to generate a sent event */
        if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
   294c4:	e0bfff17 	ldw	r2,-4(fp)
   294c8:	10801a0b 	ldhu	r2,104(r2)
   294cc:	10bfffcc 	andi	r2,r2,65535
   294d0:	10001b26 	beq	r2,zero,29540 <tcp_receive+0x538>
   294d4:	e0bff517 	ldw	r2,-44(fp)
   294d8:	10800417 	ldw	r2,16(r2)
   294dc:	10c00303 	ldbu	r3,12(r2)
   294e0:	10800343 	ldbu	r2,13(r2)
   294e4:	1004923a 	slli	r2,r2,8
   294e8:	10c4b03a 	or	r2,r2,r3
   294ec:	10bfffcc 	andi	r2,r2,65535
   294f0:	1004d23a 	srli	r2,r2,8
   294f4:	10ffffcc 	andi	r3,r2,65535
   294f8:	e0bff517 	ldw	r2,-44(fp)
   294fc:	10800417 	ldw	r2,16(r2)
   29500:	11000303 	ldbu	r4,12(r2)
   29504:	10800343 	ldbu	r2,13(r2)
   29508:	1004923a 	slli	r2,r2,8
   2950c:	1104b03a 	or	r2,r2,r4
   29510:	10bfffcc 	andi	r2,r2,65535
   29514:	1004923a 	slli	r2,r2,8
   29518:	10bfffcc 	andi	r2,r2,65535
   2951c:	1884b03a 	or	r2,r3,r2
   29520:	1080004c 	andi	r2,r2,1
   29524:	10000626 	beq	r2,zero,29540 <tcp_receive+0x538>
          pcb->acked--;
   29528:	e0bfff17 	ldw	r2,-4(fp)
   2952c:	10801a0b 	ldhu	r2,104(r2)
   29530:	10bfffc4 	addi	r2,r2,-1
   29534:	1007883a 	mov	r3,r2
   29538:	e0bfff17 	ldw	r2,-4(fp)
   2953c:	10c01a0d 	sth	r3,104(r2)
        }

        pcb->snd_queuelen -= pbuf_clen(next->p);
   29540:	e0bfff17 	ldw	r2,-4(fp)
   29544:	14001b0b 	ldhu	r16,108(r2)
   29548:	e0bff517 	ldw	r2,-44(fp)
   2954c:	10800117 	ldw	r2,4(r2)
   29550:	1009883a 	mov	r4,r2
   29554:	00238a40 	call	238a4 <pbuf_clen>
   29558:	10803fcc 	andi	r2,r2,255
   2955c:	8085c83a 	sub	r2,r16,r2
   29560:	1007883a 	mov	r3,r2
   29564:	e0bfff17 	ldw	r2,-4(fp)
   29568:	10c01b0d 	sth	r3,108(r2)
        tcp_seg_free(next);
   2956c:	e13ff517 	ldw	r4,-44(fp)
   29570:	00264f80 	call	264f8 <tcp_seg_free>
   29574:	00000106 	br	2957c <tcp_receive+0x574>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
   29578:	0001883a 	nop
   2957c:	e0bfff17 	ldw	r2,-4(fp)
   29580:	10801d17 	ldw	r2,116(r2)
   29584:	10005e26 	beq	r2,zero,29700 <tcp_receive+0x6f8>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
   29588:	e0bfff17 	ldw	r2,-4(fp)
   2958c:	10801d17 	ldw	r2,116(r2)
   29590:	10800417 	ldw	r2,16(r2)
   29594:	10c00103 	ldbu	r3,4(r2)
   29598:	11000143 	ldbu	r4,5(r2)
   2959c:	2008923a 	slli	r4,r4,8
   295a0:	20c6b03a 	or	r3,r4,r3
   295a4:	11000183 	ldbu	r4,6(r2)
   295a8:	2008943a 	slli	r4,r4,16
   295ac:	20c6b03a 	or	r3,r4,r3
   295b0:	108001c3 	ldbu	r2,7(r2)
   295b4:	1004963a 	slli	r2,r2,24
   295b8:	10c4b03a 	or	r2,r2,r3
   295bc:	1006d63a 	srli	r3,r2,24
   295c0:	e0bfff17 	ldw	r2,-4(fp)
   295c4:	10801d17 	ldw	r2,116(r2)
   295c8:	10800417 	ldw	r2,16(r2)
   295cc:	11000103 	ldbu	r4,4(r2)
   295d0:	11400143 	ldbu	r5,5(r2)
   295d4:	280a923a 	slli	r5,r5,8
   295d8:	2908b03a 	or	r4,r5,r4
   295dc:	11400183 	ldbu	r5,6(r2)
   295e0:	280a943a 	slli	r5,r5,16
   295e4:	2908b03a 	or	r4,r5,r4
   295e8:	108001c3 	ldbu	r2,7(r2)
   295ec:	1004963a 	slli	r2,r2,24
   295f0:	1104b03a 	or	r2,r2,r4
   295f4:	1004d23a 	srli	r2,r2,8
   295f8:	10bfc00c 	andi	r2,r2,65280
   295fc:	1886b03a 	or	r3,r3,r2
   29600:	e0bfff17 	ldw	r2,-4(fp)
   29604:	10801d17 	ldw	r2,116(r2)
   29608:	10800417 	ldw	r2,16(r2)
   2960c:	11000103 	ldbu	r4,4(r2)
   29610:	11400143 	ldbu	r5,5(r2)
   29614:	280a923a 	slli	r5,r5,8
   29618:	2908b03a 	or	r4,r5,r4
   2961c:	11400183 	ldbu	r5,6(r2)
   29620:	280a943a 	slli	r5,r5,16
   29624:	2908b03a 	or	r4,r5,r4
   29628:	108001c3 	ldbu	r2,7(r2)
   2962c:	1004963a 	slli	r2,r2,24
   29630:	1104b03a 	or	r2,r2,r4
   29634:	10bfc00c 	andi	r2,r2,65280
   29638:	1004923a 	slli	r2,r2,8
   2963c:	1886b03a 	or	r3,r3,r2
   29640:	e0bfff17 	ldw	r2,-4(fp)
   29644:	10801d17 	ldw	r2,116(r2)
   29648:	10800417 	ldw	r2,16(r2)
   2964c:	11000103 	ldbu	r4,4(r2)
   29650:	11400143 	ldbu	r5,5(r2)
   29654:	280a923a 	slli	r5,r5,8
   29658:	2908b03a 	or	r4,r5,r4
   2965c:	11400183 	ldbu	r5,6(r2)
   29660:	280a943a 	slli	r5,r5,16
   29664:	2908b03a 	or	r4,r5,r4
   29668:	108001c3 	ldbu	r2,7(r2)
   2966c:	1004963a 	slli	r2,r2,24
   29670:	1104b03a 	or	r2,r2,r4
   29674:	1004963a 	slli	r2,r2,24
   29678:	1886b03a 	or	r3,r3,r2
   2967c:	e0bfff17 	ldw	r2,-4(fp)
   29680:	10801d17 	ldw	r2,116(r2)
   29684:	1080020b 	ldhu	r2,8(r2)
   29688:	113fffcc 	andi	r4,r2,65535
   2968c:	e0bfff17 	ldw	r2,-4(fp)
   29690:	10801d17 	ldw	r2,116(r2)
   29694:	10800417 	ldw	r2,16(r2)
   29698:	11400303 	ldbu	r5,12(r2)
   2969c:	10800343 	ldbu	r2,13(r2)
   296a0:	1004923a 	slli	r2,r2,8
   296a4:	1144b03a 	or	r2,r2,r5
   296a8:	10bfffcc 	andi	r2,r2,65535
   296ac:	1004d23a 	srli	r2,r2,8
   296b0:	117fffcc 	andi	r5,r2,65535
   296b4:	e0bfff17 	ldw	r2,-4(fp)
   296b8:	10801d17 	ldw	r2,116(r2)
   296bc:	10800417 	ldw	r2,16(r2)
   296c0:	11800303 	ldbu	r6,12(r2)
   296c4:	10800343 	ldbu	r2,13(r2)
   296c8:	1004923a 	slli	r2,r2,8
   296cc:	1184b03a 	or	r2,r2,r6
   296d0:	10bfffcc 	andi	r2,r2,65535
   296d4:	1004923a 	slli	r2,r2,8
   296d8:	10bfffcc 	andi	r2,r2,65535
   296dc:	2884b03a 	or	r2,r5,r2
   296e0:	108000cc 	andi	r2,r2,3
   296e4:	1004c03a 	cmpne	r2,r2,zero
   296e8:	10803fcc 	andi	r2,r2,255
   296ec:	2085883a 	add	r2,r4,r2
   296f0:	1887883a 	add	r3,r3,r2
   296f4:	d0a93f17 	ldw	r2,-23300(gp)
   296f8:	1885c83a 	sub	r2,r3,r2
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
   296fc:	00bf690e 	bge	zero,r2,294a4 <tcp_receive+0x49c>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
   29700:	e0bfff17 	ldw	r2,-4(fp)
   29704:	10801d17 	ldw	r2,116(r2)
   29708:	1000041e 	bne	r2,zero,2971c <tcp_receive+0x714>
        pcb->rtime = -1;
   2970c:	e0bfff17 	ldw	r2,-4(fp)
   29710:	00ffffc4 	movi	r3,-1
   29714:	10c00e0d 	sth	r3,56(r2)
   29718:	00000206 	br	29724 <tcp_receive+0x71c>
      else
        pcb->rtime = 0;
   2971c:	e0bfff17 	ldw	r2,-4(fp)
   29720:	10000e0d 	sth	zero,56(r2)

      pcb->polltmr = 0;
   29724:	e0bfff17 	ldw	r2,-4(fp)
   29728:	100008c5 	stb	zero,35(r2)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
   2972c:	00003d06 	br	29824 <tcp_receive+0x81c>
        pcb->rtime = 0;

      pcb->polltmr = 0;
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
   29730:	e0bfff17 	ldw	r2,-4(fp)
   29734:	10001a0d 	sth	zero,104(r2)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
   29738:	00003a06 	br	29824 <tcp_receive+0x81c>
                           TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
   2973c:	e0bfff17 	ldw	r2,-4(fp)
   29740:	10801c17 	ldw	r2,112(r2)
   29744:	e0bff515 	stw	r2,-44(fp)
      pcb->unsent = pcb->unsent->next;
   29748:	e0bfff17 	ldw	r2,-4(fp)
   2974c:	10801c17 	ldw	r2,112(r2)
   29750:	10c00017 	ldw	r3,0(r2)
   29754:	e0bfff17 	ldw	r2,-4(fp)
   29758:	10c01c15 	stw	r3,112(r2)
#if TCP_OVERSIZE
      if (pcb->unsent == NULL) {
   2975c:	e0bfff17 	ldw	r2,-4(fp)
   29760:	10801c17 	ldw	r2,112(r2)
   29764:	1000021e 	bne	r2,zero,29770 <tcp_receive+0x768>
        pcb->unsent_oversize = 0;
   29768:	e0bfff17 	ldw	r2,-4(fp)
   2976c:	10001b8d 	sth	zero,110(r2)
      }
#endif /* TCP_OVERSIZE */ 
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
      /* Prevent ACK for FIN to generate a sent event */
      if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
   29770:	e0bfff17 	ldw	r2,-4(fp)
   29774:	10801a0b 	ldhu	r2,104(r2)
   29778:	10bfffcc 	andi	r2,r2,65535
   2977c:	10001b26 	beq	r2,zero,297ec <tcp_receive+0x7e4>
   29780:	e0bff517 	ldw	r2,-44(fp)
   29784:	10800417 	ldw	r2,16(r2)
   29788:	10c00303 	ldbu	r3,12(r2)
   2978c:	10800343 	ldbu	r2,13(r2)
   29790:	1004923a 	slli	r2,r2,8
   29794:	10c4b03a 	or	r2,r2,r3
   29798:	10bfffcc 	andi	r2,r2,65535
   2979c:	1004d23a 	srli	r2,r2,8
   297a0:	10ffffcc 	andi	r3,r2,65535
   297a4:	e0bff517 	ldw	r2,-44(fp)
   297a8:	10800417 	ldw	r2,16(r2)
   297ac:	11000303 	ldbu	r4,12(r2)
   297b0:	10800343 	ldbu	r2,13(r2)
   297b4:	1004923a 	slli	r2,r2,8
   297b8:	1104b03a 	or	r2,r2,r4
   297bc:	10bfffcc 	andi	r2,r2,65535
   297c0:	1004923a 	slli	r2,r2,8
   297c4:	10bfffcc 	andi	r2,r2,65535
   297c8:	1884b03a 	or	r2,r3,r2
   297cc:	1080004c 	andi	r2,r2,1
   297d0:	10000626 	beq	r2,zero,297ec <tcp_receive+0x7e4>
        pcb->acked--;
   297d4:	e0bfff17 	ldw	r2,-4(fp)
   297d8:	10801a0b 	ldhu	r2,104(r2)
   297dc:	10bfffc4 	addi	r2,r2,-1
   297e0:	1007883a 	mov	r3,r2
   297e4:	e0bfff17 	ldw	r2,-4(fp)
   297e8:	10c01a0d 	sth	r3,104(r2)
      }
      pcb->snd_queuelen -= pbuf_clen(next->p);
   297ec:	e0bfff17 	ldw	r2,-4(fp)
   297f0:	14001b0b 	ldhu	r16,108(r2)
   297f4:	e0bff517 	ldw	r2,-44(fp)
   297f8:	10800117 	ldw	r2,4(r2)
   297fc:	1009883a 	mov	r4,r2
   29800:	00238a40 	call	238a4 <pbuf_clen>
   29804:	10803fcc 	andi	r2,r2,255
   29808:	8085c83a 	sub	r2,r16,r2
   2980c:	1007883a 	mov	r3,r2
   29810:	e0bfff17 	ldw	r2,-4(fp)
   29814:	10c01b0d 	sth	r3,108(r2)
      tcp_seg_free(next);
   29818:	e13ff517 	ldw	r4,-44(fp)
   2981c:	00264f80 	call	264f8 <tcp_seg_free>
   29820:	00000106 	br	29828 <tcp_receive+0x820>
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
   29824:	0001883a 	nop
   29828:	e0bfff17 	ldw	r2,-4(fp)
   2982c:	10801c17 	ldw	r2,112(r2)
   29830:	10006326 	beq	r2,zero,299c0 <tcp_receive+0x9b8>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
   29834:	d0e93f17 	ldw	r3,-23300(gp)
   29838:	e0bfff17 	ldw	r2,-4(fp)
   2983c:	10801c17 	ldw	r2,112(r2)
   29840:	10800417 	ldw	r2,16(r2)
   29844:	11000103 	ldbu	r4,4(r2)
   29848:	11400143 	ldbu	r5,5(r2)
   2984c:	280a923a 	slli	r5,r5,8
   29850:	2908b03a 	or	r4,r5,r4
   29854:	11400183 	ldbu	r5,6(r2)
   29858:	280a943a 	slli	r5,r5,16
   2985c:	2908b03a 	or	r4,r5,r4
   29860:	108001c3 	ldbu	r2,7(r2)
   29864:	1004963a 	slli	r2,r2,24
   29868:	1104b03a 	or	r2,r2,r4
   2986c:	1008d63a 	srli	r4,r2,24
   29870:	e0bfff17 	ldw	r2,-4(fp)
   29874:	10801c17 	ldw	r2,112(r2)
   29878:	10800417 	ldw	r2,16(r2)
   2987c:	11400103 	ldbu	r5,4(r2)
   29880:	11800143 	ldbu	r6,5(r2)
   29884:	300c923a 	slli	r6,r6,8
   29888:	314ab03a 	or	r5,r6,r5
   2988c:	11800183 	ldbu	r6,6(r2)
   29890:	300c943a 	slli	r6,r6,16
   29894:	314ab03a 	or	r5,r6,r5
   29898:	108001c3 	ldbu	r2,7(r2)
   2989c:	1004963a 	slli	r2,r2,24
   298a0:	1144b03a 	or	r2,r2,r5
   298a4:	1004d23a 	srli	r2,r2,8
   298a8:	10bfc00c 	andi	r2,r2,65280
   298ac:	2088b03a 	or	r4,r4,r2
   298b0:	e0bfff17 	ldw	r2,-4(fp)
   298b4:	10801c17 	ldw	r2,112(r2)
   298b8:	10800417 	ldw	r2,16(r2)
   298bc:	11400103 	ldbu	r5,4(r2)
   298c0:	11800143 	ldbu	r6,5(r2)
   298c4:	300c923a 	slli	r6,r6,8
   298c8:	314ab03a 	or	r5,r6,r5
   298cc:	11800183 	ldbu	r6,6(r2)
   298d0:	300c943a 	slli	r6,r6,16
   298d4:	314ab03a 	or	r5,r6,r5
   298d8:	108001c3 	ldbu	r2,7(r2)
   298dc:	1004963a 	slli	r2,r2,24
   298e0:	1144b03a 	or	r2,r2,r5
   298e4:	10bfc00c 	andi	r2,r2,65280
   298e8:	1004923a 	slli	r2,r2,8
   298ec:	2088b03a 	or	r4,r4,r2
   298f0:	e0bfff17 	ldw	r2,-4(fp)
   298f4:	10801c17 	ldw	r2,112(r2)
   298f8:	10800417 	ldw	r2,16(r2)
   298fc:	11400103 	ldbu	r5,4(r2)
   29900:	11800143 	ldbu	r6,5(r2)
   29904:	300c923a 	slli	r6,r6,8
   29908:	314ab03a 	or	r5,r6,r5
   2990c:	11800183 	ldbu	r6,6(r2)
   29910:	300c943a 	slli	r6,r6,16
   29914:	314ab03a 	or	r5,r6,r5
   29918:	108001c3 	ldbu	r2,7(r2)
   2991c:	1004963a 	slli	r2,r2,24
   29920:	1144b03a 	or	r2,r2,r5
   29924:	1004963a 	slli	r2,r2,24
   29928:	2088b03a 	or	r4,r4,r2
   2992c:	e0bfff17 	ldw	r2,-4(fp)
   29930:	10801c17 	ldw	r2,112(r2)
   29934:	1080020b 	ldhu	r2,8(r2)
   29938:	117fffcc 	andi	r5,r2,65535
   2993c:	e0bfff17 	ldw	r2,-4(fp)
   29940:	10801c17 	ldw	r2,112(r2)
   29944:	10800417 	ldw	r2,16(r2)
   29948:	11800303 	ldbu	r6,12(r2)
   2994c:	10800343 	ldbu	r2,13(r2)
   29950:	1004923a 	slli	r2,r2,8
   29954:	1184b03a 	or	r2,r2,r6
   29958:	10bfffcc 	andi	r2,r2,65535
   2995c:	1004d23a 	srli	r2,r2,8
   29960:	11bfffcc 	andi	r6,r2,65535
   29964:	e0bfff17 	ldw	r2,-4(fp)
   29968:	10801c17 	ldw	r2,112(r2)
   2996c:	10800417 	ldw	r2,16(r2)
   29970:	11c00303 	ldbu	r7,12(r2)
   29974:	10800343 	ldbu	r2,13(r2)
   29978:	1004923a 	slli	r2,r2,8
   2997c:	11c4b03a 	or	r2,r2,r7
   29980:	10bfffcc 	andi	r2,r2,65535
   29984:	1004923a 	slli	r2,r2,8
   29988:	10bfffcc 	andi	r2,r2,65535
   2998c:	3084b03a 	or	r2,r6,r2
   29990:	108000cc 	andi	r2,r2,3
   29994:	1004c03a 	cmpne	r2,r2,zero
   29998:	10803fcc 	andi	r2,r2,255
   2999c:	2885883a 	add	r2,r5,r2
   299a0:	2085883a 	add	r2,r4,r2
   299a4:	1885c83a 	sub	r2,r3,r2
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
   299a8:	10000516 	blt	r2,zero,299c0 <tcp_receive+0x9b8>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
   299ac:	d0e93f17 	ldw	r3,-23300(gp)
   299b0:	e0bfff17 	ldw	r2,-4(fp)
   299b4:	10801517 	ldw	r2,84(r2)
   299b8:	1885c83a 	sub	r2,r3,r2
   299bc:	00bf5f0e 	bge	zero,r2,2973c <tcp_receive+0x734>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
   299c0:	e0bfff17 	ldw	r2,-4(fp)
   299c4:	10800f17 	ldw	r2,60(r2)
   299c8:	10004326 	beq	r2,zero,29ad8 <tcp_receive+0xad0>
   299cc:	e0bfff17 	ldw	r2,-4(fp)
   299d0:	10c01017 	ldw	r3,64(r2)
   299d4:	d0a93f17 	ldw	r2,-23300(gp)
   299d8:	1885c83a 	sub	r2,r3,r2
   299dc:	10003e0e 	bge	r2,zero,29ad8 <tcp_receive+0xad0>
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
   299e0:	00800134 	movhi	r2,4
   299e4:	109ef304 	addi	r2,r2,31692
   299e8:	10800017 	ldw	r2,0(r2)
   299ec:	1007883a 	mov	r3,r2
   299f0:	e0bfff17 	ldw	r2,-4(fp)
   299f4:	10800f17 	ldw	r2,60(r2)
   299f8:	1885c83a 	sub	r2,r3,r2
   299fc:	e0bff90d 	sth	r2,-28(fp)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
   29a00:	e0fff90b 	ldhu	r3,-28(fp)
   29a04:	e0bfff17 	ldw	r2,-4(fp)
   29a08:	1080110b 	ldhu	r2,68(r2)
   29a0c:	10bfffcc 	andi	r2,r2,65535
   29a10:	10a0001c 	xori	r2,r2,32768
   29a14:	10a00004 	addi	r2,r2,-32768
   29a18:	1005d0fa 	srai	r2,r2,3
   29a1c:	1885c83a 	sub	r2,r3,r2
   29a20:	e0bff90d 	sth	r2,-28(fp)
      pcb->sa += m;
   29a24:	e0bfff17 	ldw	r2,-4(fp)
   29a28:	1080110b 	ldhu	r2,68(r2)
   29a2c:	1007883a 	mov	r3,r2
   29a30:	e0bff90b 	ldhu	r2,-28(fp)
   29a34:	1885883a 	add	r2,r3,r2
   29a38:	1007883a 	mov	r3,r2
   29a3c:	e0bfff17 	ldw	r2,-4(fp)
   29a40:	10c0110d 	sth	r3,68(r2)
      if (m < 0) {
   29a44:	e0bff90f 	ldh	r2,-28(fp)
   29a48:	1000030e 	bge	r2,zero,29a58 <tcp_receive+0xa50>
        m = -m;
   29a4c:	e0bff90b 	ldhu	r2,-28(fp)
   29a50:	0085c83a 	sub	r2,zero,r2
   29a54:	e0bff90d 	sth	r2,-28(fp)
      }
      m = m - (pcb->sv >> 2);
   29a58:	e0fff90b 	ldhu	r3,-28(fp)
   29a5c:	e0bfff17 	ldw	r2,-4(fp)
   29a60:	1080118b 	ldhu	r2,70(r2)
   29a64:	10bfffcc 	andi	r2,r2,65535
   29a68:	10a0001c 	xori	r2,r2,32768
   29a6c:	10a00004 	addi	r2,r2,-32768
   29a70:	1005d0ba 	srai	r2,r2,2
   29a74:	1885c83a 	sub	r2,r3,r2
   29a78:	e0bff90d 	sth	r2,-28(fp)
      pcb->sv += m;
   29a7c:	e0bfff17 	ldw	r2,-4(fp)
   29a80:	1080118b 	ldhu	r2,70(r2)
   29a84:	1007883a 	mov	r3,r2
   29a88:	e0bff90b 	ldhu	r2,-28(fp)
   29a8c:	1885883a 	add	r2,r3,r2
   29a90:	1007883a 	mov	r3,r2
   29a94:	e0bfff17 	ldw	r2,-4(fp)
   29a98:	10c0118d 	sth	r3,70(r2)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
   29a9c:	e0bfff17 	ldw	r2,-4(fp)
   29aa0:	1080110b 	ldhu	r2,68(r2)
   29aa4:	10bfffcc 	andi	r2,r2,65535
   29aa8:	10a0001c 	xori	r2,r2,32768
   29aac:	10a00004 	addi	r2,r2,-32768
   29ab0:	1005d0fa 	srai	r2,r2,3
   29ab4:	1007883a 	mov	r3,r2
   29ab8:	e0bfff17 	ldw	r2,-4(fp)
   29abc:	1080118b 	ldhu	r2,70(r2)
   29ac0:	1885883a 	add	r2,r3,r2
   29ac4:	1007883a 	mov	r3,r2
   29ac8:	e0bfff17 	ldw	r2,-4(fp)
   29acc:	10c0120d 	sth	r3,72(r2)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
   29ad0:	e0bfff17 	ldw	r2,-4(fp)
   29ad4:	10000f15 	stw	zero,60(r2)

  /* If the incoming segment contains data, we must process it
     further unless the pcb already received a FIN.
     (RFC 793, chapeter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
     LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
  if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
   29ad8:	d0a9408b 	ldhu	r2,-23294(gp)
   29adc:	10bfffcc 	andi	r2,r2,65535
   29ae0:	10051026 	beq	r2,zero,2af24 <tcp_receive+0x1f1c>
   29ae4:	e0bfff17 	ldw	r2,-4(fp)
   29ae8:	10800617 	ldw	r2,24(r2)
   29aec:	108001e8 	cmpgeui	r2,r2,7
   29af0:	10050c1e 	bne	r2,zero,2af24 <tcp_receive+0x1f1c>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
   29af4:	e0bfff17 	ldw	r2,-4(fp)
   29af8:	10c00b17 	ldw	r3,44(r2)
   29afc:	d0a93e17 	ldw	r2,-23304(gp)
   29b00:	0084303a 	nor	r2,zero,r2
   29b04:	1885883a 	add	r2,r3,r2
   29b08:	10007316 	blt	r2,zero,29cd8 <tcp_receive+0xcd0>
   29b0c:	e0bfff17 	ldw	r2,-4(fp)
   29b10:	10c00b17 	ldw	r3,44(r2)
   29b14:	d0a9408b 	ldhu	r2,-23294(gp)
   29b18:	113fffcc 	andi	r4,r2,65535
   29b1c:	d0a93e17 	ldw	r2,-23304(gp)
   29b20:	2085883a 	add	r2,r4,r2
   29b24:	1885c83a 	sub	r2,r3,r2
   29b28:	10800044 	addi	r2,r2,1
   29b2c:	00806a16 	blt	zero,r2,29cd8 <tcp_receive+0xcd0>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
   29b30:	e0bfff17 	ldw	r2,-4(fp)
   29b34:	10c00b17 	ldw	r3,44(r2)
   29b38:	d0a93e17 	ldw	r2,-23304(gp)
   29b3c:	1885c83a 	sub	r2,r3,r2
   29b40:	e0bff815 	stw	r2,-32(fp)
      p = inseg.p;
   29b44:	008001b4 	movhi	r2,6
   29b48:	1088d704 	addi	r2,r2,9052
   29b4c:	10800117 	ldw	r2,4(r2)
   29b50:	e0bff715 	stw	r2,-36(fp)
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
   29b54:	008001b4 	movhi	r2,6
   29b58:	1088d704 	addi	r2,r2,9052
   29b5c:	10800117 	ldw	r2,4(r2)
   29b60:	1080028b 	ldhu	r2,10(r2)
   29b64:	10ffffcc 	andi	r3,r2,65535
   29b68:	e0bff817 	ldw	r2,-32(fp)
   29b6c:	1880240e 	bge	r3,r2,29c00 <tcp_receive+0xbf8>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
   29b70:	008001b4 	movhi	r2,6
   29b74:	1088d704 	addi	r2,r2,9052
   29b78:	10800117 	ldw	r2,4(r2)
   29b7c:	10c0020b 	ldhu	r3,8(r2)
   29b80:	e0bff817 	ldw	r2,-32(fp)
   29b84:	1885c83a 	sub	r2,r3,r2
   29b88:	e0bffc8d 	sth	r2,-14(fp)
        while (p->len < off) {
   29b8c:	00000e06 	br	29bc8 <tcp_receive+0xbc0>
          off -= p->len;
   29b90:	e0bff717 	ldw	r2,-36(fp)
   29b94:	1080028b 	ldhu	r2,10(r2)
   29b98:	10bfffcc 	andi	r2,r2,65535
   29b9c:	e0fff817 	ldw	r3,-32(fp)
   29ba0:	1885c83a 	sub	r2,r3,r2
   29ba4:	e0bff815 	stw	r2,-32(fp)
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
   29ba8:	e0bff717 	ldw	r2,-36(fp)
   29bac:	e0fffc8b 	ldhu	r3,-14(fp)
   29bb0:	10c0020d 	sth	r3,8(r2)
          p->len = 0;
   29bb4:	e0bff717 	ldw	r2,-36(fp)
   29bb8:	1000028d 	sth	zero,10(r2)
          p = p->next;
   29bbc:	e0bff717 	ldw	r2,-36(fp)
   29bc0:	10800017 	ldw	r2,0(r2)
   29bc4:	e0bff715 	stw	r2,-36(fp)
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
   29bc8:	e0bff717 	ldw	r2,-36(fp)
   29bcc:	1080028b 	ldhu	r2,10(r2)
   29bd0:	10ffffcc 	andi	r3,r2,65535
   29bd4:	e0bff817 	ldw	r2,-32(fp)
   29bd8:	18bfed16 	blt	r3,r2,29b90 <tcp_receive+0xb88>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
   29bdc:	e0bff817 	ldw	r2,-32(fp)
   29be0:	0085c83a 	sub	r2,zero,r2
   29be4:	10bfffcc 	andi	r2,r2,65535
   29be8:	10a0001c 	xori	r2,r2,32768
   29bec:	10a00004 	addi	r2,r2,-32768
   29bf0:	e13ff717 	ldw	r4,-36(fp)
   29bf4:	100b883a 	mov	r5,r2
   29bf8:	00235b00 	call	235b0 <pbuf_header>
   29bfc:	00000b06 	br	29c2c <tcp_receive+0xc24>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
   29c00:	008001b4 	movhi	r2,6
   29c04:	1088d704 	addi	r2,r2,9052
   29c08:	10c00117 	ldw	r3,4(r2)
   29c0c:	e0bff817 	ldw	r2,-32(fp)
   29c10:	0085c83a 	sub	r2,zero,r2
   29c14:	10bfffcc 	andi	r2,r2,65535
   29c18:	10a0001c 	xori	r2,r2,32768
   29c1c:	10a00004 	addi	r2,r2,-32768
   29c20:	1809883a 	mov	r4,r3
   29c24:	100b883a 	mov	r5,r2
   29c28:	00235b00 	call	235b0 <pbuf_header>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      }
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
   29c2c:	008001b4 	movhi	r2,6
   29c30:	1088d704 	addi	r2,r2,9052
   29c34:	10c0020b 	ldhu	r3,8(r2)
   29c38:	d0a93e17 	ldw	r2,-23304(gp)
   29c3c:	1009883a 	mov	r4,r2
   29c40:	e0bfff17 	ldw	r2,-4(fp)
   29c44:	10800b17 	ldw	r2,44(r2)
   29c48:	2085c83a 	sub	r2,r4,r2
   29c4c:	1885883a 	add	r2,r3,r2
   29c50:	1007883a 	mov	r3,r2
   29c54:	008001b4 	movhi	r2,6
   29c58:	1088d704 	addi	r2,r2,9052
   29c5c:	10c0020d 	sth	r3,8(r2)
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
   29c60:	008001b4 	movhi	r2,6
   29c64:	1088d704 	addi	r2,r2,9052
   29c68:	10800417 	ldw	r2,16(r2)
   29c6c:	e0ffff17 	ldw	r3,-4(fp)
   29c70:	18c00b17 	ldw	r3,44(r3)
   29c74:	d0e93e15 	stw	r3,-23304(gp)
   29c78:	d0e93e17 	ldw	r3,-23304(gp)
   29c7c:	19003fcc 	andi	r4,r3,255
   29c80:	11400103 	ldbu	r5,4(r2)
   29c84:	280a703a 	and	r5,r5,zero
   29c88:	2908b03a 	or	r4,r5,r4
   29c8c:	11000105 	stb	r4,4(r2)
   29c90:	1808d23a 	srli	r4,r3,8
   29c94:	21003fcc 	andi	r4,r4,255
   29c98:	11400143 	ldbu	r5,5(r2)
   29c9c:	280a703a 	and	r5,r5,zero
   29ca0:	2908b03a 	or	r4,r5,r4
   29ca4:	11000145 	stb	r4,5(r2)
   29ca8:	1808d43a 	srli	r4,r3,16
   29cac:	21003fcc 	andi	r4,r4,255
   29cb0:	11400183 	ldbu	r5,6(r2)
   29cb4:	280a703a 	and	r5,r5,zero
   29cb8:	2908b03a 	or	r4,r5,r4
   29cbc:	11000185 	stb	r4,6(r2)
   29cc0:	1806d63a 	srli	r3,r3,24
   29cc4:	110001c3 	ldbu	r4,7(r2)
   29cc8:	2008703a 	and	r4,r4,zero
   29ccc:	20c6b03a 	or	r3,r4,r3
   29cd0:	10c001c5 	stb	r3,7(r2)
   29cd4:	00000b06 	br	29d04 <tcp_receive+0xcfc>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
   29cd8:	d0e93e17 	ldw	r3,-23304(gp)
   29cdc:	e0bfff17 	ldw	r2,-4(fp)
   29ce0:	10800b17 	ldw	r2,44(r2)
   29ce4:	1885c83a 	sub	r2,r3,r2
   29ce8:	1000060e 	bge	r2,zero,29d04 <tcp_receive+0xcfc>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
   29cec:	e0bfff17 	ldw	r2,-4(fp)
   29cf0:	10800883 	ldbu	r2,34(r2)
   29cf4:	10800094 	ori	r2,r2,2
   29cf8:	1007883a 	mov	r3,r2
   29cfc:	e0bfff17 	ldw	r2,-4(fp)
   29d00:	10c00885 	stb	r3,34(r2)
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
   29d04:	d0e93e17 	ldw	r3,-23304(gp)
   29d08:	e0bfff17 	ldw	r2,-4(fp)
   29d0c:	10800b17 	ldw	r2,44(r2)
   29d10:	1885c83a 	sub	r2,r3,r2
   29d14:	10047f16 	blt	r2,zero,2af14 <tcp_receive+0x1f0c>
   29d18:	d0e93e17 	ldw	r3,-23304(gp)
   29d1c:	e0bfff17 	ldw	r2,-4(fp)
   29d20:	11000b17 	ldw	r4,44(r2)
   29d24:	e0bfff17 	ldw	r2,-4(fp)
   29d28:	10800c0b 	ldhu	r2,48(r2)
   29d2c:	10bfffcc 	andi	r2,r2,65535
   29d30:	2085883a 	add	r2,r4,r2
   29d34:	1885c83a 	sub	r2,r3,r2
   29d38:	10800044 	addi	r2,r2,1
   29d3c:	00847516 	blt	zero,r2,2af14 <tcp_receive+0x1f0c>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
   29d40:	e0bfff17 	ldw	r2,-4(fp)
   29d44:	10c00b17 	ldw	r3,44(r2)
   29d48:	d0a93e17 	ldw	r2,-23304(gp)
   29d4c:	1882c51e 	bne	r3,r2,2a864 <tcp_receive+0x185c>
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
        tcplen = TCP_TCPLEN(&inseg);
   29d50:	008001b4 	movhi	r2,6
   29d54:	1088d704 	addi	r2,r2,9052
   29d58:	10c0020b 	ldhu	r3,8(r2)
   29d5c:	008001b4 	movhi	r2,6
   29d60:	1088d704 	addi	r2,r2,9052
   29d64:	10800417 	ldw	r2,16(r2)
   29d68:	11000303 	ldbu	r4,12(r2)
   29d6c:	10800343 	ldbu	r2,13(r2)
   29d70:	1004923a 	slli	r2,r2,8
   29d74:	1104b03a 	or	r2,r2,r4
   29d78:	10bfffcc 	andi	r2,r2,65535
   29d7c:	1004d23a 	srli	r2,r2,8
   29d80:	113fffcc 	andi	r4,r2,65535
   29d84:	008001b4 	movhi	r2,6
   29d88:	1088d704 	addi	r2,r2,9052
   29d8c:	10800417 	ldw	r2,16(r2)
   29d90:	11400303 	ldbu	r5,12(r2)
   29d94:	10800343 	ldbu	r2,13(r2)
   29d98:	1004923a 	slli	r2,r2,8
   29d9c:	1144b03a 	or	r2,r2,r5
   29da0:	10bfffcc 	andi	r2,r2,65535
   29da4:	1004923a 	slli	r2,r2,8
   29da8:	10bfffcc 	andi	r2,r2,65535
   29dac:	2084b03a 	or	r2,r4,r2
   29db0:	108000cc 	andi	r2,r2,3
   29db4:	1004c03a 	cmpne	r2,r2,zero
   29db8:	10803fcc 	andi	r2,r2,255
   29dbc:	1885883a 	add	r2,r3,r2
   29dc0:	d0a9408d 	sth	r2,-23294(gp)

        if (tcplen > pcb->rcv_wnd) {
   29dc4:	e0bfff17 	ldw	r2,-4(fp)
   29dc8:	10c00c0b 	ldhu	r3,48(r2)
   29dcc:	d0a9408b 	ldhu	r2,-23294(gp)
   29dd0:	18ffffcc 	andi	r3,r3,65535
   29dd4:	10bfffcc 	andi	r2,r2,65535
   29dd8:	1880942e 	bgeu	r3,r2,2a02c <tcp_receive+0x1024>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                      ("tcp_receive: other end overran receive window"
                       "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                       seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
   29ddc:	008001b4 	movhi	r2,6
   29de0:	1088d704 	addi	r2,r2,9052
   29de4:	10800417 	ldw	r2,16(r2)
   29de8:	10c00303 	ldbu	r3,12(r2)
   29dec:	10800343 	ldbu	r2,13(r2)
   29df0:	1004923a 	slli	r2,r2,8
   29df4:	10c4b03a 	or	r2,r2,r3
   29df8:	10bfffcc 	andi	r2,r2,65535
   29dfc:	1004d23a 	srli	r2,r2,8
   29e00:	10ffffcc 	andi	r3,r2,65535
   29e04:	008001b4 	movhi	r2,6
   29e08:	1088d704 	addi	r2,r2,9052
   29e0c:	10800417 	ldw	r2,16(r2)
   29e10:	11000303 	ldbu	r4,12(r2)
   29e14:	10800343 	ldbu	r2,13(r2)
   29e18:	1004923a 	slli	r2,r2,8
   29e1c:	1104b03a 	or	r2,r2,r4
   29e20:	10bfffcc 	andi	r2,r2,65535
   29e24:	1004923a 	slli	r2,r2,8
   29e28:	10bfffcc 	andi	r2,r2,65535
   29e2c:	1884b03a 	or	r2,r3,r2
   29e30:	1080004c 	andi	r2,r2,1
   29e34:	10003226 	beq	r2,zero,29f00 <tcp_receive+0xef8>
            /* Must remove the FIN from the header as we're trimming 
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
   29e38:	008001b4 	movhi	r2,6
   29e3c:	1088d704 	addi	r2,r2,9052
   29e40:	10800417 	ldw	r2,16(r2)
   29e44:	00c001b4 	movhi	r3,6
   29e48:	18c8d704 	addi	r3,r3,9052
   29e4c:	18c00417 	ldw	r3,16(r3)
   29e50:	19000303 	ldbu	r4,12(r3)
   29e54:	18c00343 	ldbu	r3,13(r3)
   29e58:	1806923a 	slli	r3,r3,8
   29e5c:	1906b03a 	or	r3,r3,r4
   29e60:	1809883a 	mov	r4,r3
   29e64:	00f03fc4 	movi	r3,-16129
   29e68:	20c6703a 	and	r3,r4,r3
   29e6c:	1809883a 	mov	r4,r3
   29e70:	00c001b4 	movhi	r3,6
   29e74:	18c8d704 	addi	r3,r3,9052
   29e78:	18c00417 	ldw	r3,16(r3)
   29e7c:	19400303 	ldbu	r5,12(r3)
   29e80:	18c00343 	ldbu	r3,13(r3)
   29e84:	1806923a 	slli	r3,r3,8
   29e88:	1946b03a 	or	r3,r3,r5
   29e8c:	18ffffcc 	andi	r3,r3,65535
   29e90:	1806d23a 	srli	r3,r3,8
   29e94:	180b883a 	mov	r5,r3
   29e98:	00c001b4 	movhi	r3,6
   29e9c:	18c8d704 	addi	r3,r3,9052
   29ea0:	18c00417 	ldw	r3,16(r3)
   29ea4:	19800303 	ldbu	r6,12(r3)
   29ea8:	18c00343 	ldbu	r3,13(r3)
   29eac:	1806923a 	slli	r3,r3,8
   29eb0:	1986b03a 	or	r3,r3,r6
   29eb4:	18ffffcc 	andi	r3,r3,65535
   29eb8:	1806923a 	slli	r3,r3,8
   29ebc:	28c6b03a 	or	r3,r5,r3
   29ec0:	18c00f8c 	andi	r3,r3,62
   29ec4:	1806923a 	slli	r3,r3,8
   29ec8:	20c6b03a 	or	r3,r4,r3
   29ecc:	193fffcc 	andi	r4,r3,65535
   29ed0:	21003fcc 	andi	r4,r4,255
   29ed4:	11400303 	ldbu	r5,12(r2)
   29ed8:	280a703a 	and	r5,r5,zero
   29edc:	2908b03a 	or	r4,r5,r4
   29ee0:	11000305 	stb	r4,12(r2)
   29ee4:	18ffffcc 	andi	r3,r3,65535
   29ee8:	1806d23a 	srli	r3,r3,8
   29eec:	18ffffcc 	andi	r3,r3,65535
   29ef0:	11000343 	ldbu	r4,13(r2)
   29ef4:	2008703a 	and	r4,r4,zero
   29ef8:	20c6b03a 	or	r3,r4,r3
   29efc:	10c00345 	stb	r3,13(r2)
          }
          /* Adjust length of segment to fit in the window. */
          inseg.len = pcb->rcv_wnd;
   29f00:	e0bfff17 	ldw	r2,-4(fp)
   29f04:	10c00c0b 	ldhu	r3,48(r2)
   29f08:	008001b4 	movhi	r2,6
   29f0c:	1088d704 	addi	r2,r2,9052
   29f10:	10c0020d 	sth	r3,8(r2)
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
   29f14:	008001b4 	movhi	r2,6
   29f18:	1088d704 	addi	r2,r2,9052
   29f1c:	10800417 	ldw	r2,16(r2)
   29f20:	10c00303 	ldbu	r3,12(r2)
   29f24:	10800343 	ldbu	r2,13(r2)
   29f28:	1004923a 	slli	r2,r2,8
   29f2c:	10c4b03a 	or	r2,r2,r3
   29f30:	10bfffcc 	andi	r2,r2,65535
   29f34:	1004d23a 	srli	r2,r2,8
   29f38:	10ffffcc 	andi	r3,r2,65535
   29f3c:	008001b4 	movhi	r2,6
   29f40:	1088d704 	addi	r2,r2,9052
   29f44:	10800417 	ldw	r2,16(r2)
   29f48:	11000303 	ldbu	r4,12(r2)
   29f4c:	10800343 	ldbu	r2,13(r2)
   29f50:	1004923a 	slli	r2,r2,8
   29f54:	1104b03a 	or	r2,r2,r4
   29f58:	10bfffcc 	andi	r2,r2,65535
   29f5c:	1004923a 	slli	r2,r2,8
   29f60:	10bfffcc 	andi	r2,r2,65535
   29f64:	1884b03a 	or	r2,r3,r2
   29f68:	1080008c 	andi	r2,r2,2
   29f6c:	10000826 	beq	r2,zero,29f90 <tcp_receive+0xf88>
            inseg.len -= 1;
   29f70:	008001b4 	movhi	r2,6
   29f74:	1088d704 	addi	r2,r2,9052
   29f78:	1080020b 	ldhu	r2,8(r2)
   29f7c:	10bfffc4 	addi	r2,r2,-1
   29f80:	1007883a 	mov	r3,r2
   29f84:	008001b4 	movhi	r2,6
   29f88:	1088d704 	addi	r2,r2,9052
   29f8c:	10c0020d 	sth	r3,8(r2)
          }
          pbuf_realloc(inseg.p, inseg.len);
   29f90:	008001b4 	movhi	r2,6
   29f94:	1088d704 	addi	r2,r2,9052
   29f98:	10c00117 	ldw	r3,4(r2)
   29f9c:	008001b4 	movhi	r2,6
   29fa0:	1088d704 	addi	r2,r2,9052
   29fa4:	1080020b 	ldhu	r2,8(r2)
   29fa8:	10bfffcc 	andi	r2,r2,65535
   29fac:	1809883a 	mov	r4,r3
   29fb0:	100b883a 	mov	r5,r2
   29fb4:	00234500 	call	23450 <pbuf_realloc>
          tcplen = TCP_TCPLEN(&inseg);
   29fb8:	008001b4 	movhi	r2,6
   29fbc:	1088d704 	addi	r2,r2,9052
   29fc0:	10c0020b 	ldhu	r3,8(r2)
   29fc4:	008001b4 	movhi	r2,6
   29fc8:	1088d704 	addi	r2,r2,9052
   29fcc:	10800417 	ldw	r2,16(r2)
   29fd0:	11000303 	ldbu	r4,12(r2)
   29fd4:	10800343 	ldbu	r2,13(r2)
   29fd8:	1004923a 	slli	r2,r2,8
   29fdc:	1104b03a 	or	r2,r2,r4
   29fe0:	10bfffcc 	andi	r2,r2,65535
   29fe4:	1004d23a 	srli	r2,r2,8
   29fe8:	113fffcc 	andi	r4,r2,65535
   29fec:	008001b4 	movhi	r2,6
   29ff0:	1088d704 	addi	r2,r2,9052
   29ff4:	10800417 	ldw	r2,16(r2)
   29ff8:	11400303 	ldbu	r5,12(r2)
   29ffc:	10800343 	ldbu	r2,13(r2)
   2a000:	1004923a 	slli	r2,r2,8
   2a004:	1144b03a 	or	r2,r2,r5
   2a008:	10bfffcc 	andi	r2,r2,65535
   2a00c:	1004923a 	slli	r2,r2,8
   2a010:	10bfffcc 	andi	r2,r2,65535
   2a014:	2084b03a 	or	r2,r4,r2
   2a018:	108000cc 	andi	r2,r2,3
   2a01c:	1004c03a 	cmpne	r2,r2,zero
   2a020:	10803fcc 	andi	r2,r2,255
   2a024:	1885883a 	add	r2,r3,r2
   2a028:	d0a9408d 	sth	r2,-23294(gp)
        }
#if TCP_QUEUE_OOSEQ
        /* Received in-sequence data, adjust ooseq data if:
           - FIN has been received or
           - inseq overlaps with ooseq */
        if (pcb->ooseq != NULL) {
   2a02c:	e0bfff17 	ldw	r2,-4(fp)
   2a030:	10801e17 	ldw	r2,120(r2)
   2a034:	10011b26 	beq	r2,zero,2a4a4 <tcp_receive+0x149c>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
   2a038:	008001b4 	movhi	r2,6
   2a03c:	1088d704 	addi	r2,r2,9052
   2a040:	10800417 	ldw	r2,16(r2)
   2a044:	10c00303 	ldbu	r3,12(r2)
   2a048:	10800343 	ldbu	r2,13(r2)
   2a04c:	1004923a 	slli	r2,r2,8
   2a050:	10c4b03a 	or	r2,r2,r3
   2a054:	10bfffcc 	andi	r2,r2,65535
   2a058:	1004d23a 	srli	r2,r2,8
   2a05c:	10ffffcc 	andi	r3,r2,65535
   2a060:	008001b4 	movhi	r2,6
   2a064:	1088d704 	addi	r2,r2,9052
   2a068:	10800417 	ldw	r2,16(r2)
   2a06c:	11000303 	ldbu	r4,12(r2)
   2a070:	10800343 	ldbu	r2,13(r2)
   2a074:	1004923a 	slli	r2,r2,8
   2a078:	1104b03a 	or	r2,r2,r4
   2a07c:	10bfffcc 	andi	r2,r2,65535
   2a080:	1004923a 	slli	r2,r2,8
   2a084:	10bfffcc 	andi	r2,r2,65535
   2a088:	1884b03a 	or	r2,r3,r2
   2a08c:	1080004c 	andi	r2,r2,1
   2a090:	10000f26 	beq	r2,zero,2a0d0 <tcp_receive+0x10c8>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                        ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
            /* Received in-order FIN means anything that was received
             * out of order must now have been received in-order, so
             * bin the ooseq queue */
            while (pcb->ooseq != NULL) {
   2a094:	00000a06 	br	2a0c0 <tcp_receive+0x10b8>
              struct tcp_seg *old_ooseq = pcb->ooseq;
   2a098:	e0bfff17 	ldw	r2,-4(fp)
   2a09c:	10801e17 	ldw	r2,120(r2)
   2a0a0:	e0bffd15 	stw	r2,-12(fp)
              pcb->ooseq = pcb->ooseq->next;
   2a0a4:	e0bfff17 	ldw	r2,-4(fp)
   2a0a8:	10801e17 	ldw	r2,120(r2)
   2a0ac:	10c00017 	ldw	r3,0(r2)
   2a0b0:	e0bfff17 	ldw	r2,-4(fp)
   2a0b4:	10c01e15 	stw	r3,120(r2)
              tcp_seg_free(old_ooseq);
   2a0b8:	e13ffd17 	ldw	r4,-12(fp)
   2a0bc:	00264f80 	call	264f8 <tcp_seg_free>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                        ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
            /* Received in-order FIN means anything that was received
             * out of order must now have been received in-order, so
             * bin the ooseq queue */
            while (pcb->ooseq != NULL) {
   2a0c0:	e0bfff17 	ldw	r2,-4(fp)
   2a0c4:	10801e17 	ldw	r2,120(r2)
   2a0c8:	103ff31e 	bne	r2,zero,2a098 <tcp_receive+0x1090>
   2a0cc:	0000f506 	br	2a4a4 <tcp_receive+0x149c>
              struct tcp_seg *old_ooseq = pcb->ooseq;
              pcb->ooseq = pcb->ooseq->next;
              tcp_seg_free(old_ooseq);
            }
          } else {
            next = pcb->ooseq;
   2a0d0:	e0bfff17 	ldw	r2,-4(fp)
   2a0d4:	10801e17 	ldw	r2,120(r2)
   2a0d8:	e0bff515 	stw	r2,-44(fp)
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
   2a0dc:	00006806 	br	2a280 <tcp_receive+0x1278>
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              /* inseg cannot have FIN here (already processed above) */
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
   2a0e0:	e0bff517 	ldw	r2,-44(fp)
   2a0e4:	10800417 	ldw	r2,16(r2)
   2a0e8:	10c00303 	ldbu	r3,12(r2)
   2a0ec:	10800343 	ldbu	r2,13(r2)
   2a0f0:	1004923a 	slli	r2,r2,8
   2a0f4:	10c4b03a 	or	r2,r2,r3
   2a0f8:	10bfffcc 	andi	r2,r2,65535
   2a0fc:	1004d23a 	srli	r2,r2,8
   2a100:	10ffffcc 	andi	r3,r2,65535
   2a104:	e0bff517 	ldw	r2,-44(fp)
   2a108:	10800417 	ldw	r2,16(r2)
   2a10c:	11000303 	ldbu	r4,12(r2)
   2a110:	10800343 	ldbu	r2,13(r2)
   2a114:	1004923a 	slli	r2,r2,8
   2a118:	1104b03a 	or	r2,r2,r4
   2a11c:	10bfffcc 	andi	r2,r2,65535
   2a120:	1004923a 	slli	r2,r2,8
   2a124:	10bfffcc 	andi	r2,r2,65535
   2a128:	1884b03a 	or	r2,r3,r2
   2a12c:	1080004c 	andi	r2,r2,1
   2a130:	10004c26 	beq	r2,zero,2a264 <tcp_receive+0x125c>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
   2a134:	008001b4 	movhi	r2,6
   2a138:	1088d704 	addi	r2,r2,9052
   2a13c:	10800417 	ldw	r2,16(r2)
   2a140:	10c00303 	ldbu	r3,12(r2)
   2a144:	10800343 	ldbu	r2,13(r2)
   2a148:	1004923a 	slli	r2,r2,8
   2a14c:	10c4b03a 	or	r2,r2,r3
   2a150:	10bfffcc 	andi	r2,r2,65535
   2a154:	1004d23a 	srli	r2,r2,8
   2a158:	10ffffcc 	andi	r3,r2,65535
   2a15c:	008001b4 	movhi	r2,6
   2a160:	1088d704 	addi	r2,r2,9052
   2a164:	10800417 	ldw	r2,16(r2)
   2a168:	11000303 	ldbu	r4,12(r2)
   2a16c:	10800343 	ldbu	r2,13(r2)
   2a170:	1004923a 	slli	r2,r2,8
   2a174:	1104b03a 	or	r2,r2,r4
   2a178:	10bfffcc 	andi	r2,r2,65535
   2a17c:	1004923a 	slli	r2,r2,8
   2a180:	10bfffcc 	andi	r2,r2,65535
   2a184:	1884b03a 	or	r2,r3,r2
   2a188:	1080008c 	andi	r2,r2,2
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              /* inseg cannot have FIN here (already processed above) */
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
   2a18c:	1000351e 	bne	r2,zero,2a264 <tcp_receive+0x125c>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
   2a190:	008001b4 	movhi	r2,6
   2a194:	1088d704 	addi	r2,r2,9052
   2a198:	10800417 	ldw	r2,16(r2)
   2a19c:	00c001b4 	movhi	r3,6
   2a1a0:	18c8d704 	addi	r3,r3,9052
   2a1a4:	18c00417 	ldw	r3,16(r3)
   2a1a8:	19000303 	ldbu	r4,12(r3)
   2a1ac:	18c00343 	ldbu	r3,13(r3)
   2a1b0:	1806923a 	slli	r3,r3,8
   2a1b4:	1906b03a 	or	r3,r3,r4
   2a1b8:	18c04014 	ori	r3,r3,256
   2a1bc:	193fffcc 	andi	r4,r3,65535
   2a1c0:	21003fcc 	andi	r4,r4,255
   2a1c4:	11400303 	ldbu	r5,12(r2)
   2a1c8:	280a703a 	and	r5,r5,zero
   2a1cc:	2908b03a 	or	r4,r5,r4
   2a1d0:	11000305 	stb	r4,12(r2)
   2a1d4:	18ffffcc 	andi	r3,r3,65535
   2a1d8:	1806d23a 	srli	r3,r3,8
   2a1dc:	18ffffcc 	andi	r3,r3,65535
   2a1e0:	11000343 	ldbu	r4,13(r2)
   2a1e4:	2008703a 	and	r4,r4,zero
   2a1e8:	20c6b03a 	or	r3,r4,r3
   2a1ec:	10c00345 	stb	r3,13(r2)
                tcplen = TCP_TCPLEN(&inseg);
   2a1f0:	008001b4 	movhi	r2,6
   2a1f4:	1088d704 	addi	r2,r2,9052
   2a1f8:	10c0020b 	ldhu	r3,8(r2)
   2a1fc:	008001b4 	movhi	r2,6
   2a200:	1088d704 	addi	r2,r2,9052
   2a204:	10800417 	ldw	r2,16(r2)
   2a208:	11000303 	ldbu	r4,12(r2)
   2a20c:	10800343 	ldbu	r2,13(r2)
   2a210:	1004923a 	slli	r2,r2,8
   2a214:	1104b03a 	or	r2,r2,r4
   2a218:	10bfffcc 	andi	r2,r2,65535
   2a21c:	1004d23a 	srli	r2,r2,8
   2a220:	113fffcc 	andi	r4,r2,65535
   2a224:	008001b4 	movhi	r2,6
   2a228:	1088d704 	addi	r2,r2,9052
   2a22c:	10800417 	ldw	r2,16(r2)
   2a230:	11400303 	ldbu	r5,12(r2)
   2a234:	10800343 	ldbu	r2,13(r2)
   2a238:	1004923a 	slli	r2,r2,8
   2a23c:	1144b03a 	or	r2,r2,r5
   2a240:	10bfffcc 	andi	r2,r2,65535
   2a244:	1004923a 	slli	r2,r2,8
   2a248:	10bfffcc 	andi	r2,r2,65535
   2a24c:	2084b03a 	or	r2,r4,r2
   2a250:	108000cc 	andi	r2,r2,3
   2a254:	1004c03a 	cmpne	r2,r2,zero
   2a258:	10803fcc 	andi	r2,r2,255
   2a25c:	1885883a 	add	r2,r3,r2
   2a260:	d0a9408d 	sth	r2,-23294(gp)
              }
              prev = next;
   2a264:	e0bff517 	ldw	r2,-44(fp)
   2a268:	e0bff615 	stw	r2,-40(fp)
              next = next->next;
   2a26c:	e0bff517 	ldw	r2,-44(fp)
   2a270:	10800017 	ldw	r2,0(r2)
   2a274:	e0bff515 	stw	r2,-44(fp)
              tcp_seg_free(prev);
   2a278:	e13ff617 	ldw	r4,-40(fp)
   2a27c:	00264f80 	call	264f8 <tcp_seg_free>
            }
          } else {
            next = pcb->ooseq;
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
   2a280:	e0bff517 	ldw	r2,-44(fp)
   2a284:	10001726 	beq	r2,zero,2a2e4 <tcp_receive+0x12dc>
                   TCP_SEQ_GEQ(seqno + tcplen,
   2a288:	d0a9408b 	ldhu	r2,-23294(gp)
   2a28c:	10ffffcc 	andi	r3,r2,65535
   2a290:	d0a93e17 	ldw	r2,-23304(gp)
   2a294:	1887883a 	add	r3,r3,r2
   2a298:	e0bff517 	ldw	r2,-44(fp)
   2a29c:	10800417 	ldw	r2,16(r2)
   2a2a0:	11000103 	ldbu	r4,4(r2)
   2a2a4:	11400143 	ldbu	r5,5(r2)
   2a2a8:	280a923a 	slli	r5,r5,8
   2a2ac:	2908b03a 	or	r4,r5,r4
   2a2b0:	11400183 	ldbu	r5,6(r2)
   2a2b4:	280a943a 	slli	r5,r5,16
   2a2b8:	2908b03a 	or	r4,r5,r4
   2a2bc:	108001c3 	ldbu	r2,7(r2)
   2a2c0:	1004963a 	slli	r2,r2,24
   2a2c4:	1104b03a 	or	r2,r2,r4
   2a2c8:	1009883a 	mov	r4,r2
   2a2cc:	e0bff517 	ldw	r2,-44(fp)
   2a2d0:	1080020b 	ldhu	r2,8(r2)
   2a2d4:	10bfffcc 	andi	r2,r2,65535
   2a2d8:	2085883a 	add	r2,r4,r2
   2a2dc:	1885c83a 	sub	r2,r3,r2
            }
          } else {
            next = pcb->ooseq;
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
   2a2e0:	103f7f0e 	bge	r2,zero,2a0e0 <tcp_receive+0x10d8>
              next = next->next;
              tcp_seg_free(prev);
            }
            /* Now trim right side of inseg if it overlaps with the first
             * segment on ooseq */
            if (next &&
   2a2e4:	e0bff517 	ldw	r2,-44(fp)
   2a2e8:	10006b26 	beq	r2,zero,2a498 <tcp_receive+0x1490>
                TCP_SEQ_GT(seqno + tcplen,
   2a2ec:	d0a9408b 	ldhu	r2,-23294(gp)
   2a2f0:	10ffffcc 	andi	r3,r2,65535
   2a2f4:	d0a93e17 	ldw	r2,-23304(gp)
   2a2f8:	1887883a 	add	r3,r3,r2
   2a2fc:	e0bff517 	ldw	r2,-44(fp)
   2a300:	10800417 	ldw	r2,16(r2)
   2a304:	11000103 	ldbu	r4,4(r2)
   2a308:	11400143 	ldbu	r5,5(r2)
   2a30c:	280a923a 	slli	r5,r5,8
   2a310:	2908b03a 	or	r4,r5,r4
   2a314:	11400183 	ldbu	r5,6(r2)
   2a318:	280a943a 	slli	r5,r5,16
   2a31c:	2908b03a 	or	r4,r5,r4
   2a320:	108001c3 	ldbu	r2,7(r2)
   2a324:	1004963a 	slli	r2,r2,24
   2a328:	1104b03a 	or	r2,r2,r4
   2a32c:	1885c83a 	sub	r2,r3,r2
              next = next->next;
              tcp_seg_free(prev);
            }
            /* Now trim right side of inseg if it overlaps with the first
             * segment on ooseq */
            if (next &&
   2a330:	0080590e 	bge	zero,r2,2a498 <tcp_receive+0x1490>
                TCP_SEQ_GT(seqno + tcplen,
                           next->tcphdr->seqno)) {
              /* inseg cannot have FIN here (already processed above) */
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
   2a334:	e0bff517 	ldw	r2,-44(fp)
   2a338:	10800417 	ldw	r2,16(r2)
   2a33c:	10c00103 	ldbu	r3,4(r2)
   2a340:	11000143 	ldbu	r4,5(r2)
   2a344:	2008923a 	slli	r4,r4,8
   2a348:	20c6b03a 	or	r3,r4,r3
   2a34c:	11000183 	ldbu	r4,6(r2)
   2a350:	2008943a 	slli	r4,r4,16
   2a354:	20c6b03a 	or	r3,r4,r3
   2a358:	108001c3 	ldbu	r2,7(r2)
   2a35c:	1004963a 	slli	r2,r2,24
   2a360:	10c4b03a 	or	r2,r2,r3
   2a364:	1007883a 	mov	r3,r2
   2a368:	d0a93e17 	ldw	r2,-23304(gp)
   2a36c:	1885c83a 	sub	r2,r3,r2
   2a370:	1007883a 	mov	r3,r2
   2a374:	008001b4 	movhi	r2,6
   2a378:	1088d704 	addi	r2,r2,9052
   2a37c:	10c0020d 	sth	r3,8(r2)
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
   2a380:	008001b4 	movhi	r2,6
   2a384:	1088d704 	addi	r2,r2,9052
   2a388:	10800417 	ldw	r2,16(r2)
   2a38c:	10c00303 	ldbu	r3,12(r2)
   2a390:	10800343 	ldbu	r2,13(r2)
   2a394:	1004923a 	slli	r2,r2,8
   2a398:	10c4b03a 	or	r2,r2,r3
   2a39c:	10bfffcc 	andi	r2,r2,65535
   2a3a0:	1004d23a 	srli	r2,r2,8
   2a3a4:	10ffffcc 	andi	r3,r2,65535
   2a3a8:	008001b4 	movhi	r2,6
   2a3ac:	1088d704 	addi	r2,r2,9052
   2a3b0:	10800417 	ldw	r2,16(r2)
   2a3b4:	11000303 	ldbu	r4,12(r2)
   2a3b8:	10800343 	ldbu	r2,13(r2)
   2a3bc:	1004923a 	slli	r2,r2,8
   2a3c0:	1104b03a 	or	r2,r2,r4
   2a3c4:	10bfffcc 	andi	r2,r2,65535
   2a3c8:	1004923a 	slli	r2,r2,8
   2a3cc:	10bfffcc 	andi	r2,r2,65535
   2a3d0:	1884b03a 	or	r2,r3,r2
   2a3d4:	1080008c 	andi	r2,r2,2
   2a3d8:	10000826 	beq	r2,zero,2a3fc <tcp_receive+0x13f4>
                inseg.len -= 1;
   2a3dc:	008001b4 	movhi	r2,6
   2a3e0:	1088d704 	addi	r2,r2,9052
   2a3e4:	1080020b 	ldhu	r2,8(r2)
   2a3e8:	10bfffc4 	addi	r2,r2,-1
   2a3ec:	1007883a 	mov	r3,r2
   2a3f0:	008001b4 	movhi	r2,6
   2a3f4:	1088d704 	addi	r2,r2,9052
   2a3f8:	10c0020d 	sth	r3,8(r2)
              }
              pbuf_realloc(inseg.p, inseg.len);
   2a3fc:	008001b4 	movhi	r2,6
   2a400:	1088d704 	addi	r2,r2,9052
   2a404:	10c00117 	ldw	r3,4(r2)
   2a408:	008001b4 	movhi	r2,6
   2a40c:	1088d704 	addi	r2,r2,9052
   2a410:	1080020b 	ldhu	r2,8(r2)
   2a414:	10bfffcc 	andi	r2,r2,65535
   2a418:	1809883a 	mov	r4,r3
   2a41c:	100b883a 	mov	r5,r2
   2a420:	00234500 	call	23450 <pbuf_realloc>
              tcplen = TCP_TCPLEN(&inseg);
   2a424:	008001b4 	movhi	r2,6
   2a428:	1088d704 	addi	r2,r2,9052
   2a42c:	10c0020b 	ldhu	r3,8(r2)
   2a430:	008001b4 	movhi	r2,6
   2a434:	1088d704 	addi	r2,r2,9052
   2a438:	10800417 	ldw	r2,16(r2)
   2a43c:	11000303 	ldbu	r4,12(r2)
   2a440:	10800343 	ldbu	r2,13(r2)
   2a444:	1004923a 	slli	r2,r2,8
   2a448:	1104b03a 	or	r2,r2,r4
   2a44c:	10bfffcc 	andi	r2,r2,65535
   2a450:	1004d23a 	srli	r2,r2,8
   2a454:	113fffcc 	andi	r4,r2,65535
   2a458:	008001b4 	movhi	r2,6
   2a45c:	1088d704 	addi	r2,r2,9052
   2a460:	10800417 	ldw	r2,16(r2)
   2a464:	11400303 	ldbu	r5,12(r2)
   2a468:	10800343 	ldbu	r2,13(r2)
   2a46c:	1004923a 	slli	r2,r2,8
   2a470:	1144b03a 	or	r2,r2,r5
   2a474:	10bfffcc 	andi	r2,r2,65535
   2a478:	1004923a 	slli	r2,r2,8
   2a47c:	10bfffcc 	andi	r2,r2,65535
   2a480:	2084b03a 	or	r2,r4,r2
   2a484:	108000cc 	andi	r2,r2,3
   2a488:	1004c03a 	cmpne	r2,r2,zero
   2a48c:	10803fcc 	andi	r2,r2,255
   2a490:	1885883a 	add	r2,r3,r2
   2a494:	d0a9408d 	sth	r2,-23294(gp)
              LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
                          (seqno + tcplen) == next->tcphdr->seqno);
            }
            pcb->ooseq = next;
   2a498:	e0bfff17 	ldw	r2,-4(fp)
   2a49c:	e0fff517 	ldw	r3,-44(fp)
   2a4a0:	10c01e15 	stw	r3,120(r2)
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;
   2a4a4:	d0a9408b 	ldhu	r2,-23294(gp)
   2a4a8:	10ffffcc 	andi	r3,r2,65535
   2a4ac:	d0a93e17 	ldw	r2,-23304(gp)
   2a4b0:	1887883a 	add	r3,r3,r2
   2a4b4:	e0bfff17 	ldw	r2,-4(fp)
   2a4b8:	10c00b15 	stw	r3,44(r2)

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
        pcb->rcv_wnd -= tcplen;
   2a4bc:	e0bfff17 	ldw	r2,-4(fp)
   2a4c0:	10c00c0b 	ldhu	r3,48(r2)
   2a4c4:	d0a9408b 	ldhu	r2,-23294(gp)
   2a4c8:	1885c83a 	sub	r2,r3,r2
   2a4cc:	1007883a 	mov	r3,r2
   2a4d0:	e0bfff17 	ldw	r2,-4(fp)
   2a4d4:	10c00c0d 	sth	r3,48(r2)

        tcp_update_rcv_ann_wnd(pcb);
   2a4d8:	e13fff17 	ldw	r4,-4(fp)
   2a4dc:	00255280 	call	25528 <tcp_update_rcv_ann_wnd>
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
   2a4e0:	008001b4 	movhi	r2,6
   2a4e4:	1088d704 	addi	r2,r2,9052
   2a4e8:	10800117 	ldw	r2,4(r2)
   2a4ec:	1080020b 	ldhu	r2,8(r2)
   2a4f0:	10bfffcc 	andi	r2,r2,65535
   2a4f4:	10000726 	beq	r2,zero,2a514 <tcp_receive+0x150c>
          recv_data = inseg.p;
   2a4f8:	008001b4 	movhi	r2,6
   2a4fc:	1088d704 	addi	r2,r2,9052
   2a500:	10800117 	ldw	r2,4(r2)
   2a504:	d0a94215 	stw	r2,-23288(gp)
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
   2a508:	008001b4 	movhi	r2,6
   2a50c:	1088d704 	addi	r2,r2,9052
   2a510:	10000115 	stw	zero,4(r2)
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
   2a514:	008001b4 	movhi	r2,6
   2a518:	1088d704 	addi	r2,r2,9052
   2a51c:	10800417 	ldw	r2,16(r2)
   2a520:	10c00303 	ldbu	r3,12(r2)
   2a524:	10800343 	ldbu	r2,13(r2)
   2a528:	1004923a 	slli	r2,r2,8
   2a52c:	10c4b03a 	or	r2,r2,r3
   2a530:	10bfffcc 	andi	r2,r2,65535
   2a534:	1004d23a 	srli	r2,r2,8
   2a538:	10ffffcc 	andi	r3,r2,65535
   2a53c:	008001b4 	movhi	r2,6
   2a540:	1088d704 	addi	r2,r2,9052
   2a544:	10800417 	ldw	r2,16(r2)
   2a548:	11000303 	ldbu	r4,12(r2)
   2a54c:	10800343 	ldbu	r2,13(r2)
   2a550:	1004923a 	slli	r2,r2,8
   2a554:	1104b03a 	or	r2,r2,r4
   2a558:	10bfffcc 	andi	r2,r2,65535
   2a55c:	1004923a 	slli	r2,r2,8
   2a560:	10bfffcc 	andi	r2,r2,65535
   2a564:	1884b03a 	or	r2,r3,r2
   2a568:	1080004c 	andi	r2,r2,1
   2a56c:	10008e26 	beq	r2,zero,2a7a8 <tcp_receive+0x17a0>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags |= TF_GOT_FIN;
   2a570:	d0a94103 	ldbu	r2,-23292(gp)
   2a574:	10800814 	ori	r2,r2,32
   2a578:	d0a94105 	stb	r2,-23292(gp)
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
   2a57c:	00008a06 	br	2a7a8 <tcp_receive+0x17a0>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
   2a580:	e0bfff17 	ldw	r2,-4(fp)
   2a584:	10801e17 	ldw	r2,120(r2)
   2a588:	e0bffe15 	stw	r2,-8(fp)
          seqno = pcb->ooseq->tcphdr->seqno;
   2a58c:	e0bfff17 	ldw	r2,-4(fp)
   2a590:	10801e17 	ldw	r2,120(r2)
   2a594:	10800417 	ldw	r2,16(r2)
   2a598:	10c00103 	ldbu	r3,4(r2)
   2a59c:	11000143 	ldbu	r4,5(r2)
   2a5a0:	2008923a 	slli	r4,r4,8
   2a5a4:	20c6b03a 	or	r3,r4,r3
   2a5a8:	11000183 	ldbu	r4,6(r2)
   2a5ac:	2008943a 	slli	r4,r4,16
   2a5b0:	20c6b03a 	or	r3,r4,r3
   2a5b4:	108001c3 	ldbu	r2,7(r2)
   2a5b8:	1004963a 	slli	r2,r2,24
   2a5bc:	10c4b03a 	or	r2,r2,r3
   2a5c0:	d0a93e15 	stw	r2,-23304(gp)

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
   2a5c4:	e0bfff17 	ldw	r2,-4(fp)
   2a5c8:	10c00b17 	ldw	r3,44(r2)
   2a5cc:	e0bffe17 	ldw	r2,-8(fp)
   2a5d0:	1080020b 	ldhu	r2,8(r2)
   2a5d4:	113fffcc 	andi	r4,r2,65535
   2a5d8:	e0bffe17 	ldw	r2,-8(fp)
   2a5dc:	10800417 	ldw	r2,16(r2)
   2a5e0:	11400303 	ldbu	r5,12(r2)
   2a5e4:	10800343 	ldbu	r2,13(r2)
   2a5e8:	1004923a 	slli	r2,r2,8
   2a5ec:	1144b03a 	or	r2,r2,r5
   2a5f0:	10bfffcc 	andi	r2,r2,65535
   2a5f4:	1004d23a 	srli	r2,r2,8
   2a5f8:	117fffcc 	andi	r5,r2,65535
   2a5fc:	e0bffe17 	ldw	r2,-8(fp)
   2a600:	10800417 	ldw	r2,16(r2)
   2a604:	11800303 	ldbu	r6,12(r2)
   2a608:	10800343 	ldbu	r2,13(r2)
   2a60c:	1004923a 	slli	r2,r2,8
   2a610:	1184b03a 	or	r2,r2,r6
   2a614:	10bfffcc 	andi	r2,r2,65535
   2a618:	1004923a 	slli	r2,r2,8
   2a61c:	10bfffcc 	andi	r2,r2,65535
   2a620:	2884b03a 	or	r2,r5,r2
   2a624:	108000cc 	andi	r2,r2,3
   2a628:	1004c03a 	cmpne	r2,r2,zero
   2a62c:	10803fcc 	andi	r2,r2,255
   2a630:	2085883a 	add	r2,r4,r2
   2a634:	1887883a 	add	r3,r3,r2
   2a638:	e0bfff17 	ldw	r2,-4(fp)
   2a63c:	10c00b15 	stw	r3,44(r2)
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
                      pcb->rcv_wnd >= TCP_TCPLEN(cseg));
          pcb->rcv_wnd -= TCP_TCPLEN(cseg);
   2a640:	e0bfff17 	ldw	r2,-4(fp)
   2a644:	10c00c0b 	ldhu	r3,48(r2)
   2a648:	e0bffe17 	ldw	r2,-8(fp)
   2a64c:	1100020b 	ldhu	r4,8(r2)
   2a650:	e0bffe17 	ldw	r2,-8(fp)
   2a654:	10800417 	ldw	r2,16(r2)
   2a658:	11400303 	ldbu	r5,12(r2)
   2a65c:	10800343 	ldbu	r2,13(r2)
   2a660:	1004923a 	slli	r2,r2,8
   2a664:	1144b03a 	or	r2,r2,r5
   2a668:	10bfffcc 	andi	r2,r2,65535
   2a66c:	1004d23a 	srli	r2,r2,8
   2a670:	117fffcc 	andi	r5,r2,65535
   2a674:	e0bffe17 	ldw	r2,-8(fp)
   2a678:	10800417 	ldw	r2,16(r2)
   2a67c:	11800303 	ldbu	r6,12(r2)
   2a680:	10800343 	ldbu	r2,13(r2)
   2a684:	1004923a 	slli	r2,r2,8
   2a688:	1184b03a 	or	r2,r2,r6
   2a68c:	10bfffcc 	andi	r2,r2,65535
   2a690:	1004923a 	slli	r2,r2,8
   2a694:	10bfffcc 	andi	r2,r2,65535
   2a698:	2884b03a 	or	r2,r5,r2
   2a69c:	108000cc 	andi	r2,r2,3
   2a6a0:	1004c03a 	cmpne	r2,r2,zero
   2a6a4:	10803fcc 	andi	r2,r2,255
   2a6a8:	2085883a 	add	r2,r4,r2
   2a6ac:	1885c83a 	sub	r2,r3,r2
   2a6b0:	1007883a 	mov	r3,r2
   2a6b4:	e0bfff17 	ldw	r2,-4(fp)
   2a6b8:	10c00c0d 	sth	r3,48(r2)

          tcp_update_rcv_ann_wnd(pcb);
   2a6bc:	e13fff17 	ldw	r4,-4(fp)
   2a6c0:	00255280 	call	25528 <tcp_update_rcv_ann_wnd>

          if (cseg->p->tot_len > 0) {
   2a6c4:	e0bffe17 	ldw	r2,-8(fp)
   2a6c8:	10800117 	ldw	r2,4(r2)
   2a6cc:	1080020b 	ldhu	r2,8(r2)
   2a6d0:	10bfffcc 	andi	r2,r2,65535
   2a6d4:	10000e26 	beq	r2,zero,2a710 <tcp_receive+0x1708>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
   2a6d8:	d0a94217 	ldw	r2,-23288(gp)
   2a6dc:	10000726 	beq	r2,zero,2a6fc <tcp_receive+0x16f4>
              pbuf_cat(recv_data, cseg->p);
   2a6e0:	d0e94217 	ldw	r3,-23288(gp)
   2a6e4:	e0bffe17 	ldw	r2,-8(fp)
   2a6e8:	10800117 	ldw	r2,4(r2)
   2a6ec:	1809883a 	mov	r4,r3
   2a6f0:	100b883a 	mov	r5,r2
   2a6f4:	00239500 	call	23950 <pbuf_cat>
   2a6f8:	00000306 	br	2a708 <tcp_receive+0x1700>
            } else {
              recv_data = cseg->p;
   2a6fc:	e0bffe17 	ldw	r2,-8(fp)
   2a700:	10800117 	ldw	r2,4(r2)
   2a704:	d0a94215 	stw	r2,-23288(gp)
            }
            cseg->p = NULL;
   2a708:	e0bffe17 	ldw	r2,-8(fp)
   2a70c:	10000115 	stw	zero,4(r2)
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
   2a710:	e0bffe17 	ldw	r2,-8(fp)
   2a714:	10800417 	ldw	r2,16(r2)
   2a718:	10c00303 	ldbu	r3,12(r2)
   2a71c:	10800343 	ldbu	r2,13(r2)
   2a720:	1004923a 	slli	r2,r2,8
   2a724:	10c4b03a 	or	r2,r2,r3
   2a728:	10bfffcc 	andi	r2,r2,65535
   2a72c:	1004d23a 	srli	r2,r2,8
   2a730:	10ffffcc 	andi	r3,r2,65535
   2a734:	e0bffe17 	ldw	r2,-8(fp)
   2a738:	10800417 	ldw	r2,16(r2)
   2a73c:	11000303 	ldbu	r4,12(r2)
   2a740:	10800343 	ldbu	r2,13(r2)
   2a744:	1004923a 	slli	r2,r2,8
   2a748:	1104b03a 	or	r2,r2,r4
   2a74c:	10bfffcc 	andi	r2,r2,65535
   2a750:	1004923a 	slli	r2,r2,8
   2a754:	10bfffcc 	andi	r2,r2,65535
   2a758:	1884b03a 	or	r2,r3,r2
   2a75c:	1080004c 	andi	r2,r2,1
   2a760:	10000a26 	beq	r2,zero,2a78c <tcp_receive+0x1784>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags |= TF_GOT_FIN;
   2a764:	d0a94103 	ldbu	r2,-23292(gp)
   2a768:	10800814 	ori	r2,r2,32
   2a76c:	d0a94105 	stb	r2,-23292(gp)
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
   2a770:	e0bfff17 	ldw	r2,-4(fp)
   2a774:	10800617 	ldw	r2,24(r2)
   2a778:	10800118 	cmpnei	r2,r2,4
   2a77c:	1000031e 	bne	r2,zero,2a78c <tcp_receive+0x1784>
              pcb->state = CLOSE_WAIT;
   2a780:	e0bfff17 	ldw	r2,-4(fp)
   2a784:	00c001c4 	movi	r3,7
   2a788:	10c00615 	stw	r3,24(r2)
            } 
          }

          pcb->ooseq = cseg->next;
   2a78c:	e0bffe17 	ldw	r2,-8(fp)
   2a790:	10c00017 	ldw	r3,0(r2)
   2a794:	e0bfff17 	ldw	r2,-4(fp)
   2a798:	10c01e15 	stw	r3,120(r2)
          tcp_seg_free(cseg);
   2a79c:	e13ffe17 	ldw	r4,-8(fp)
   2a7a0:	00264f80 	call	264f8 <tcp_seg_free>
   2a7a4:	00000106 	br	2a7ac <tcp_receive+0x17a4>
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
   2a7a8:	0001883a 	nop
   2a7ac:	e0bfff17 	ldw	r2,-4(fp)
   2a7b0:	10801e17 	ldw	r2,120(r2)
   2a7b4:	10001126 	beq	r2,zero,2a7fc <tcp_receive+0x17f4>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
   2a7b8:	e0bfff17 	ldw	r2,-4(fp)
   2a7bc:	10801e17 	ldw	r2,120(r2)
   2a7c0:	10800417 	ldw	r2,16(r2)
   2a7c4:	10c00103 	ldbu	r3,4(r2)
   2a7c8:	11000143 	ldbu	r4,5(r2)
   2a7cc:	2008923a 	slli	r4,r4,8
   2a7d0:	20c6b03a 	or	r3,r4,r3
   2a7d4:	11000183 	ldbu	r4,6(r2)
   2a7d8:	2008943a 	slli	r4,r4,16
   2a7dc:	20c6b03a 	or	r3,r4,r3
   2a7e0:	108001c3 	ldbu	r2,7(r2)
   2a7e4:	1004963a 	slli	r2,r2,24
   2a7e8:	10c4b03a 	or	r2,r2,r3
   2a7ec:	1007883a 	mov	r3,r2
   2a7f0:	e0bfff17 	ldw	r2,-4(fp)
   2a7f4:	10800b17 	ldw	r2,44(r2)
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
   2a7f8:	18bf6126 	beq	r3,r2,2a580 <tcp_receive+0x1578>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
   2a7fc:	e0bfff17 	ldw	r2,-4(fp)
   2a800:	10800883 	ldbu	r2,34(r2)
   2a804:	10803fcc 	andi	r2,r2,255
   2a808:	1080004c 	andi	r2,r2,1
   2a80c:	10000e26 	beq	r2,zero,2a848 <tcp_receive+0x1840>
   2a810:	e0bfff17 	ldw	r2,-4(fp)
   2a814:	10c00883 	ldbu	r3,34(r2)
   2a818:	00bfff84 	movi	r2,-2
   2a81c:	1884703a 	and	r2,r3,r2
   2a820:	1007883a 	mov	r3,r2
   2a824:	e0bfff17 	ldw	r2,-4(fp)
   2a828:	10c00885 	stb	r3,34(r2)
   2a82c:	e0bfff17 	ldw	r2,-4(fp)
   2a830:	10800883 	ldbu	r2,34(r2)
   2a834:	10800094 	ori	r2,r2,2
   2a838:	1007883a 	mov	r3,r2
   2a83c:	e0bfff17 	ldw	r2,-4(fp)
   2a840:	10c00885 	stb	r3,34(r2)
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
   2a844:	0001b606 	br	2af20 <tcp_receive+0x1f18>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
   2a848:	e0bfff17 	ldw	r2,-4(fp)
   2a84c:	10800883 	ldbu	r2,34(r2)
   2a850:	10800054 	ori	r2,r2,1
   2a854:	1007883a 	mov	r3,r2
   2a858:	e0bfff17 	ldw	r2,-4(fp)
   2a85c:	10c00885 	stb	r3,34(r2)
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
   2a860:	0001af06 	br	2af20 <tcp_receive+0x1f18>
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_send_empty_ack(pcb);
   2a864:	e13fff17 	ldw	r4,-4(fp)
   2a868:	002c8480 	call	2c848 <tcp_send_empty_ack>
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
   2a86c:	e0bfff17 	ldw	r2,-4(fp)
   2a870:	10801e17 	ldw	r2,120(r2)
   2a874:	1000061e 	bne	r2,zero,2a890 <tcp_receive+0x1888>
          pcb->ooseq = tcp_seg_copy(&inseg);
   2a878:	010001b4 	movhi	r4,6
   2a87c:	2108d704 	addi	r4,r4,9052
   2a880:	00265840 	call	26584 <tcp_seg_copy>
   2a884:	e0ffff17 	ldw	r3,-4(fp)
   2a888:	18801e15 	stw	r2,120(r3)
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
   2a88c:	0001a406 	br	2af20 <tcp_receive+0x1f18>

             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
   2a890:	e03ff615 	stw	zero,-40(fp)
          for(next = pcb->ooseq; next != NULL; next = next->next) {
   2a894:	e0bfff17 	ldw	r2,-4(fp)
   2a898:	10801e17 	ldw	r2,120(r2)
   2a89c:	e0bff515 	stw	r2,-44(fp)
   2a8a0:	00018d06 	br	2aed8 <tcp_receive+0x1ed0>
            if (seqno == next->tcphdr->seqno) {
   2a8a4:	e0bff517 	ldw	r2,-44(fp)
   2a8a8:	10800417 	ldw	r2,16(r2)
   2a8ac:	10c00103 	ldbu	r3,4(r2)
   2a8b0:	11000143 	ldbu	r4,5(r2)
   2a8b4:	2008923a 	slli	r4,r4,8
   2a8b8:	20c6b03a 	or	r3,r4,r3
   2a8bc:	11000183 	ldbu	r4,6(r2)
   2a8c0:	2008943a 	slli	r4,r4,16
   2a8c4:	20c6b03a 	or	r3,r4,r3
   2a8c8:	108001c3 	ldbu	r2,7(r2)
   2a8cc:	1004963a 	slli	r2,r2,24
   2a8d0:	10c4b03a 	or	r2,r2,r3
   2a8d4:	1007883a 	mov	r3,r2
   2a8d8:	d0a93e17 	ldw	r2,-23304(gp)
   2a8dc:	18801b1e 	bne	r3,r2,2a94c <tcp_receive+0x1944>
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
   2a8e0:	008001b4 	movhi	r2,6
   2a8e4:	1088d704 	addi	r2,r2,9052
   2a8e8:	1080020b 	ldhu	r2,8(r2)
   2a8ec:	e0fff517 	ldw	r3,-44(fp)
   2a8f0:	18c0020b 	ldhu	r3,8(r3)
   2a8f4:	10bfffcc 	andi	r2,r2,65535
   2a8f8:	18ffffcc 	andi	r3,r3,65535
   2a8fc:	1881792e 	bgeu	r3,r2,2aee4 <tcp_receive+0x1edc>
                /* The incoming segment is larger than the old
                   segment. We replace some segments with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
   2a900:	010001b4 	movhi	r4,6
   2a904:	2108d704 	addi	r4,r4,9052
   2a908:	00265840 	call	26584 <tcp_seg_copy>
   2a90c:	e0bffe15 	stw	r2,-8(fp)
                if (cseg != NULL) {
   2a910:	e0bffe17 	ldw	r2,-8(fp)
   2a914:	10017526 	beq	r2,zero,2aeec <tcp_receive+0x1ee4>
                  if (prev != NULL) {
   2a918:	e0bff617 	ldw	r2,-40(fp)
   2a91c:	10000426 	beq	r2,zero,2a930 <tcp_receive+0x1928>
                    prev->next = cseg;
   2a920:	e0bff617 	ldw	r2,-40(fp)
   2a924:	e0fffe17 	ldw	r3,-8(fp)
   2a928:	10c00015 	stw	r3,0(r2)
   2a92c:	00000306 	br	2a93c <tcp_receive+0x1934>
                  } else {
                    pcb->ooseq = cseg;
   2a930:	e0bfff17 	ldw	r2,-4(fp)
   2a934:	e0fffe17 	ldw	r3,-8(fp)
   2a938:	10c01e15 	stw	r3,120(r2)
                  }
                  tcp_oos_insert_segment(cseg, next);
   2a93c:	e13ffe17 	ldw	r4,-8(fp)
   2a940:	e17ff517 	ldw	r5,-44(fp)
   2a944:	0028d800 	call	28d80 <tcp_oos_insert_segment>
                }
                break;
   2a948:	00016806 	br	2aeec <tcp_receive+0x1ee4>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
   2a94c:	e0bff617 	ldw	r2,-40(fp)
   2a950:	10001c1e 	bne	r2,zero,2a9c4 <tcp_receive+0x19bc>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
   2a954:	d0e93e17 	ldw	r3,-23304(gp)
   2a958:	e0bff517 	ldw	r2,-44(fp)
   2a95c:	10800417 	ldw	r2,16(r2)
   2a960:	11000103 	ldbu	r4,4(r2)
   2a964:	11400143 	ldbu	r5,5(r2)
   2a968:	280a923a 	slli	r5,r5,8
   2a96c:	2908b03a 	or	r4,r5,r4
   2a970:	11400183 	ldbu	r5,6(r2)
   2a974:	280a943a 	slli	r5,r5,16
   2a978:	2908b03a 	or	r4,r5,r4
   2a97c:	108001c3 	ldbu	r2,7(r2)
   2a980:	1004963a 	slli	r2,r2,24
   2a984:	1104b03a 	or	r2,r2,r4
   2a988:	1885c83a 	sub	r2,r3,r2
   2a98c:	1000680e 	bge	r2,zero,2ab30 <tcp_receive+0x1b28>
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */
                  cseg = tcp_seg_copy(&inseg);
   2a990:	010001b4 	movhi	r4,6
   2a994:	2108d704 	addi	r4,r4,9052
   2a998:	00265840 	call	26584 <tcp_seg_copy>
   2a99c:	e0bffe15 	stw	r2,-8(fp)
                  if (cseg != NULL) {
   2a9a0:	e0bffe17 	ldw	r2,-8(fp)
   2a9a4:	10015326 	beq	r2,zero,2aef4 <tcp_receive+0x1eec>
                    pcb->ooseq = cseg;
   2a9a8:	e0bfff17 	ldw	r2,-4(fp)
   2a9ac:	e0fffe17 	ldw	r3,-8(fp)
   2a9b0:	10c01e15 	stw	r3,120(r2)
                    tcp_oos_insert_segment(cseg, next);
   2a9b4:	e13ffe17 	ldw	r4,-8(fp)
   2a9b8:	e17ff517 	ldw	r5,-44(fp)
   2a9bc:	0028d800 	call	28d80 <tcp_oos_insert_segment>
                  }
                  break;
   2a9c0:	00014c06 	br	2aef4 <tcp_receive+0x1eec>
                }
              } else {
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
   2a9c4:	e0bff617 	ldw	r2,-40(fp)
   2a9c8:	10800417 	ldw	r2,16(r2)
   2a9cc:	10c00103 	ldbu	r3,4(r2)
   2a9d0:	11000143 	ldbu	r4,5(r2)
   2a9d4:	2008923a 	slli	r4,r4,8
   2a9d8:	20c6b03a 	or	r3,r4,r3
   2a9dc:	11000183 	ldbu	r4,6(r2)
   2a9e0:	2008943a 	slli	r4,r4,16
   2a9e4:	20c6b03a 	or	r3,r4,r3
   2a9e8:	108001c3 	ldbu	r2,7(r2)
   2a9ec:	1004963a 	slli	r2,r2,24
   2a9f0:	10c4b03a 	or	r2,r2,r3
   2a9f4:	0086303a 	nor	r3,zero,r2
   2a9f8:	d0a93e17 	ldw	r2,-23304(gp)
   2a9fc:	1885883a 	add	r2,r3,r2
   2aa00:	10004b16 	blt	r2,zero,2ab30 <tcp_receive+0x1b28>
   2aa04:	d0e93e17 	ldw	r3,-23304(gp)
   2aa08:	e0bff517 	ldw	r2,-44(fp)
   2aa0c:	10800417 	ldw	r2,16(r2)
   2aa10:	11000103 	ldbu	r4,4(r2)
   2aa14:	11400143 	ldbu	r5,5(r2)
   2aa18:	280a923a 	slli	r5,r5,8
   2aa1c:	2908b03a 	or	r4,r5,r4
   2aa20:	11400183 	ldbu	r5,6(r2)
   2aa24:	280a943a 	slli	r5,r5,16
   2aa28:	2908b03a 	or	r4,r5,r4
   2aa2c:	108001c3 	ldbu	r2,7(r2)
   2aa30:	1004963a 	slli	r2,r2,24
   2aa34:	1104b03a 	or	r2,r2,r4
   2aa38:	1885c83a 	sub	r2,r3,r2
   2aa3c:	10800044 	addi	r2,r2,1
   2aa40:	00803b16 	blt	zero,r2,2ab30 <tcp_receive+0x1b28>
                  /* The sequence number of the incoming segment is in
                     between the sequence numbers of the previous and
                     the next segment on ->ooseq. We trim trim the previous
                     segment, delete next segments that included in received segment
                     and trim received, if needed. */
                  cseg = tcp_seg_copy(&inseg);
   2aa44:	010001b4 	movhi	r4,6
   2aa48:	2108d704 	addi	r4,r4,9052
   2aa4c:	00265840 	call	26584 <tcp_seg_copy>
   2aa50:	e0bffe15 	stw	r2,-8(fp)
                  if (cseg != NULL) {
   2aa54:	e0bffe17 	ldw	r2,-8(fp)
   2aa58:	10012826 	beq	r2,zero,2aefc <tcp_receive+0x1ef4>
                    if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
   2aa5c:	e0bff617 	ldw	r2,-40(fp)
   2aa60:	10800417 	ldw	r2,16(r2)
   2aa64:	10c00103 	ldbu	r3,4(r2)
   2aa68:	11000143 	ldbu	r4,5(r2)
   2aa6c:	2008923a 	slli	r4,r4,8
   2aa70:	20c6b03a 	or	r3,r4,r3
   2aa74:	11000183 	ldbu	r4,6(r2)
   2aa78:	2008943a 	slli	r4,r4,16
   2aa7c:	20c6b03a 	or	r3,r4,r3
   2aa80:	108001c3 	ldbu	r2,7(r2)
   2aa84:	1004963a 	slli	r2,r2,24
   2aa88:	10c4b03a 	or	r2,r2,r3
   2aa8c:	1007883a 	mov	r3,r2
   2aa90:	e0bff617 	ldw	r2,-40(fp)
   2aa94:	1080020b 	ldhu	r2,8(r2)
   2aa98:	10bfffcc 	andi	r2,r2,65535
   2aa9c:	1887883a 	add	r3,r3,r2
   2aaa0:	d0a93e17 	ldw	r2,-23304(gp)
   2aaa4:	1885c83a 	sub	r2,r3,r2
   2aaa8:	00801a0e 	bge	zero,r2,2ab14 <tcp_receive+0x1b0c>
                      /* We need to trim the prev segment. */
                      prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
   2aaac:	d0a93e17 	ldw	r2,-23304(gp)
   2aab0:	1007883a 	mov	r3,r2
   2aab4:	e0bff617 	ldw	r2,-40(fp)
   2aab8:	10800417 	ldw	r2,16(r2)
   2aabc:	11000103 	ldbu	r4,4(r2)
   2aac0:	11400143 	ldbu	r5,5(r2)
   2aac4:	280a923a 	slli	r5,r5,8
   2aac8:	2908b03a 	or	r4,r5,r4
   2aacc:	11400183 	ldbu	r5,6(r2)
   2aad0:	280a943a 	slli	r5,r5,16
   2aad4:	2908b03a 	or	r4,r5,r4
   2aad8:	108001c3 	ldbu	r2,7(r2)
   2aadc:	1004963a 	slli	r2,r2,24
   2aae0:	1104b03a 	or	r2,r2,r4
   2aae4:	1885c83a 	sub	r2,r3,r2
   2aae8:	1007883a 	mov	r3,r2
   2aaec:	e0bff617 	ldw	r2,-40(fp)
   2aaf0:	10c0020d 	sth	r3,8(r2)
                      pbuf_realloc(prev->p, prev->len);
   2aaf4:	e0bff617 	ldw	r2,-40(fp)
   2aaf8:	10c00117 	ldw	r3,4(r2)
   2aafc:	e0bff617 	ldw	r2,-40(fp)
   2ab00:	1080020b 	ldhu	r2,8(r2)
   2ab04:	10bfffcc 	andi	r2,r2,65535
   2ab08:	1809883a 	mov	r4,r3
   2ab0c:	100b883a 	mov	r5,r2
   2ab10:	00234500 	call	23450 <pbuf_realloc>
                    }
                    prev->next = cseg;
   2ab14:	e0bff617 	ldw	r2,-40(fp)
   2ab18:	e0fffe17 	ldw	r3,-8(fp)
   2ab1c:	10c00015 	stw	r3,0(r2)
                    tcp_oos_insert_segment(cseg, next);
   2ab20:	e13ffe17 	ldw	r4,-8(fp)
   2ab24:	e17ff517 	ldw	r5,-44(fp)
   2ab28:	0028d800 	call	28d80 <tcp_oos_insert_segment>
                  }
                  break;
   2ab2c:	0000f306 	br	2aefc <tcp_receive+0x1ef4>
                }
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
   2ab30:	e0bff517 	ldw	r2,-44(fp)
   2ab34:	10800017 	ldw	r2,0(r2)
   2ab38:	1000e21e 	bne	r2,zero,2aec4 <tcp_receive+0x1ebc>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
   2ab3c:	d0e93e17 	ldw	r3,-23304(gp)
   2ab40:	e0bff517 	ldw	r2,-44(fp)
   2ab44:	10800417 	ldw	r2,16(r2)
   2ab48:	11000103 	ldbu	r4,4(r2)
   2ab4c:	11400143 	ldbu	r5,5(r2)
   2ab50:	280a923a 	slli	r5,r5,8
   2ab54:	2908b03a 	or	r4,r5,r4
   2ab58:	11400183 	ldbu	r5,6(r2)
   2ab5c:	280a943a 	slli	r5,r5,16
   2ab60:	2908b03a 	or	r4,r5,r4
   2ab64:	108001c3 	ldbu	r2,7(r2)
   2ab68:	1004963a 	slli	r2,r2,24
   2ab6c:	1104b03a 	or	r2,r2,r4
   2ab70:	1885c83a 	sub	r2,r3,r2
                }
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
   2ab74:	0080d30e 	bge	zero,r2,2aec4 <tcp_receive+0x1ebc>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
   2ab78:	e0bff517 	ldw	r2,-44(fp)
   2ab7c:	10800417 	ldw	r2,16(r2)
   2ab80:	10c00303 	ldbu	r3,12(r2)
   2ab84:	10800343 	ldbu	r2,13(r2)
   2ab88:	1004923a 	slli	r2,r2,8
   2ab8c:	10c4b03a 	or	r2,r2,r3
   2ab90:	10bfffcc 	andi	r2,r2,65535
   2ab94:	1004d23a 	srli	r2,r2,8
   2ab98:	10ffffcc 	andi	r3,r2,65535
   2ab9c:	e0bff517 	ldw	r2,-44(fp)
   2aba0:	10800417 	ldw	r2,16(r2)
   2aba4:	11000303 	ldbu	r4,12(r2)
   2aba8:	10800343 	ldbu	r2,13(r2)
   2abac:	1004923a 	slli	r2,r2,8
   2abb0:	1104b03a 	or	r2,r2,r4
   2abb4:	10bfffcc 	andi	r2,r2,65535
   2abb8:	1004923a 	slli	r2,r2,8
   2abbc:	10bfffcc 	andi	r2,r2,65535
   2abc0:	1884b03a 	or	r2,r3,r2
   2abc4:	1080004c 	andi	r2,r2,1
   2abc8:	1000ce1e 	bne	r2,zero,2af04 <tcp_receive+0x1efc>
                  /* segment "next" already contains all data */
                  break;
                }
                next->next = tcp_seg_copy(&inseg);
   2abcc:	010001b4 	movhi	r4,6
   2abd0:	2108d704 	addi	r4,r4,9052
   2abd4:	00265840 	call	26584 <tcp_seg_copy>
   2abd8:	e0fff517 	ldw	r3,-44(fp)
   2abdc:	18800015 	stw	r2,0(r3)
                if (next->next != NULL) {
   2abe0:	e0bff517 	ldw	r2,-44(fp)
   2abe4:	10800017 	ldw	r2,0(r2)
   2abe8:	1000c826 	beq	r2,zero,2af0c <tcp_receive+0x1f04>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
   2abec:	e0bff517 	ldw	r2,-44(fp)
   2abf0:	10800417 	ldw	r2,16(r2)
   2abf4:	10c00103 	ldbu	r3,4(r2)
   2abf8:	11000143 	ldbu	r4,5(r2)
   2abfc:	2008923a 	slli	r4,r4,8
   2ac00:	20c6b03a 	or	r3,r4,r3
   2ac04:	11000183 	ldbu	r4,6(r2)
   2ac08:	2008943a 	slli	r4,r4,16
   2ac0c:	20c6b03a 	or	r3,r4,r3
   2ac10:	108001c3 	ldbu	r2,7(r2)
   2ac14:	1004963a 	slli	r2,r2,24
   2ac18:	10c4b03a 	or	r2,r2,r3
   2ac1c:	1007883a 	mov	r3,r2
   2ac20:	e0bff517 	ldw	r2,-44(fp)
   2ac24:	1080020b 	ldhu	r2,8(r2)
   2ac28:	10bfffcc 	andi	r2,r2,65535
   2ac2c:	1887883a 	add	r3,r3,r2
   2ac30:	d0a93e17 	ldw	r2,-23304(gp)
   2ac34:	1885c83a 	sub	r2,r3,r2
   2ac38:	00801a0e 	bge	zero,r2,2aca4 <tcp_receive+0x1c9c>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
   2ac3c:	d0a93e17 	ldw	r2,-23304(gp)
   2ac40:	1007883a 	mov	r3,r2
   2ac44:	e0bff517 	ldw	r2,-44(fp)
   2ac48:	10800417 	ldw	r2,16(r2)
   2ac4c:	11000103 	ldbu	r4,4(r2)
   2ac50:	11400143 	ldbu	r5,5(r2)
   2ac54:	280a923a 	slli	r5,r5,8
   2ac58:	2908b03a 	or	r4,r5,r4
   2ac5c:	11400183 	ldbu	r5,6(r2)
   2ac60:	280a943a 	slli	r5,r5,16
   2ac64:	2908b03a 	or	r4,r5,r4
   2ac68:	108001c3 	ldbu	r2,7(r2)
   2ac6c:	1004963a 	slli	r2,r2,24
   2ac70:	1104b03a 	or	r2,r2,r4
   2ac74:	1885c83a 	sub	r2,r3,r2
   2ac78:	1007883a 	mov	r3,r2
   2ac7c:	e0bff517 	ldw	r2,-44(fp)
   2ac80:	10c0020d 	sth	r3,8(r2)
                    pbuf_realloc(next->p, next->len);
   2ac84:	e0bff517 	ldw	r2,-44(fp)
   2ac88:	10c00117 	ldw	r3,4(r2)
   2ac8c:	e0bff517 	ldw	r2,-44(fp)
   2ac90:	1080020b 	ldhu	r2,8(r2)
   2ac94:	10bfffcc 	andi	r2,r2,65535
   2ac98:	1809883a 	mov	r4,r3
   2ac9c:	100b883a 	mov	r5,r2
   2aca0:	00234500 	call	23450 <pbuf_realloc>
                  }
                  /* check if the remote side overruns our receive window */
                  if ((u32_t)tcplen + seqno > pcb->rcv_nxt + (u32_t)pcb->rcv_wnd) {
   2aca4:	d0a9408b 	ldhu	r2,-23294(gp)
   2aca8:	10ffffcc 	andi	r3,r2,65535
   2acac:	d0a93e17 	ldw	r2,-23304(gp)
   2acb0:	1885883a 	add	r2,r3,r2
   2acb4:	e0ffff17 	ldw	r3,-4(fp)
   2acb8:	19000b17 	ldw	r4,44(r3)
   2acbc:	e0ffff17 	ldw	r3,-4(fp)
   2acc0:	18c00c0b 	ldhu	r3,48(r3)
   2acc4:	18ffffcc 	andi	r3,r3,65535
   2acc8:	20c7883a 	add	r3,r4,r3
   2accc:	18808f2e 	bgeu	r3,r2,2af0c <tcp_receive+0x1f04>
                    LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                                ("tcp_receive: other end overran receive window"
                                 "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                                 seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
                    if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
   2acd0:	e0bff517 	ldw	r2,-44(fp)
   2acd4:	10800017 	ldw	r2,0(r2)
   2acd8:	10800417 	ldw	r2,16(r2)
   2acdc:	10c00303 	ldbu	r3,12(r2)
   2ace0:	10800343 	ldbu	r2,13(r2)
   2ace4:	1004923a 	slli	r2,r2,8
   2ace8:	10c4b03a 	or	r2,r2,r3
   2acec:	10bfffcc 	andi	r2,r2,65535
   2acf0:	1004d23a 	srli	r2,r2,8
   2acf4:	10ffffcc 	andi	r3,r2,65535
   2acf8:	e0bff517 	ldw	r2,-44(fp)
   2acfc:	10800017 	ldw	r2,0(r2)
   2ad00:	10800417 	ldw	r2,16(r2)
   2ad04:	11000303 	ldbu	r4,12(r2)
   2ad08:	10800343 	ldbu	r2,13(r2)
   2ad0c:	1004923a 	slli	r2,r2,8
   2ad10:	1104b03a 	or	r2,r2,r4
   2ad14:	10bfffcc 	andi	r2,r2,65535
   2ad18:	1004923a 	slli	r2,r2,8
   2ad1c:	10bfffcc 	andi	r2,r2,65535
   2ad20:	1884b03a 	or	r2,r3,r2
   2ad24:	1080004c 	andi	r2,r2,1
   2ad28:	10003226 	beq	r2,zero,2adf4 <tcp_receive+0x1dec>
                      /* Must remove the FIN from the header as we're trimming 
                       * that byte of sequence-space from the packet */
                      TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) &~ TCP_FIN);
   2ad2c:	e0bff517 	ldw	r2,-44(fp)
   2ad30:	10800017 	ldw	r2,0(r2)
   2ad34:	10800417 	ldw	r2,16(r2)
   2ad38:	e0fff517 	ldw	r3,-44(fp)
   2ad3c:	18c00017 	ldw	r3,0(r3)
   2ad40:	18c00417 	ldw	r3,16(r3)
   2ad44:	19000303 	ldbu	r4,12(r3)
   2ad48:	18c00343 	ldbu	r3,13(r3)
   2ad4c:	1806923a 	slli	r3,r3,8
   2ad50:	1906b03a 	or	r3,r3,r4
   2ad54:	1809883a 	mov	r4,r3
   2ad58:	00f03fc4 	movi	r3,-16129
   2ad5c:	20c6703a 	and	r3,r4,r3
   2ad60:	1809883a 	mov	r4,r3
   2ad64:	e0fff517 	ldw	r3,-44(fp)
   2ad68:	18c00017 	ldw	r3,0(r3)
   2ad6c:	18c00417 	ldw	r3,16(r3)
   2ad70:	19400303 	ldbu	r5,12(r3)
   2ad74:	18c00343 	ldbu	r3,13(r3)
   2ad78:	1806923a 	slli	r3,r3,8
   2ad7c:	1946b03a 	or	r3,r3,r5
   2ad80:	18ffffcc 	andi	r3,r3,65535
   2ad84:	1806d23a 	srli	r3,r3,8
   2ad88:	180b883a 	mov	r5,r3
   2ad8c:	e0fff517 	ldw	r3,-44(fp)
   2ad90:	18c00017 	ldw	r3,0(r3)
   2ad94:	18c00417 	ldw	r3,16(r3)
   2ad98:	19800303 	ldbu	r6,12(r3)
   2ad9c:	18c00343 	ldbu	r3,13(r3)
   2ada0:	1806923a 	slli	r3,r3,8
   2ada4:	1986b03a 	or	r3,r3,r6
   2ada8:	18ffffcc 	andi	r3,r3,65535
   2adac:	1806923a 	slli	r3,r3,8
   2adb0:	28c6b03a 	or	r3,r5,r3
   2adb4:	18c00f8c 	andi	r3,r3,62
   2adb8:	1806923a 	slli	r3,r3,8
   2adbc:	20c6b03a 	or	r3,r4,r3
   2adc0:	193fffcc 	andi	r4,r3,65535
   2adc4:	21003fcc 	andi	r4,r4,255
   2adc8:	11400303 	ldbu	r5,12(r2)
   2adcc:	280a703a 	and	r5,r5,zero
   2add0:	2908b03a 	or	r4,r5,r4
   2add4:	11000305 	stb	r4,12(r2)
   2add8:	18ffffcc 	andi	r3,r3,65535
   2addc:	1806d23a 	srli	r3,r3,8
   2ade0:	18ffffcc 	andi	r3,r3,65535
   2ade4:	11000343 	ldbu	r4,13(r2)
   2ade8:	2008703a 	and	r4,r4,zero
   2adec:	20c6b03a 	or	r3,r4,r3
   2adf0:	10c00345 	stb	r3,13(r2)
                    }
                    /* Adjust length of segment to fit in the window. */
                    next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
   2adf4:	e0bff517 	ldw	r2,-44(fp)
   2adf8:	10800017 	ldw	r2,0(r2)
   2adfc:	e0ffff17 	ldw	r3,-4(fp)
   2ae00:	18c00b17 	ldw	r3,44(r3)
   2ae04:	1809883a 	mov	r4,r3
   2ae08:	e0ffff17 	ldw	r3,-4(fp)
   2ae0c:	18c00c0b 	ldhu	r3,48(r3)
   2ae10:	20c7883a 	add	r3,r4,r3
   2ae14:	1809883a 	mov	r4,r3
   2ae18:	d0e93e17 	ldw	r3,-23304(gp)
   2ae1c:	20c7c83a 	sub	r3,r4,r3
   2ae20:	10c0020d 	sth	r3,8(r2)
                    pbuf_realloc(next->next->p, next->next->len);
   2ae24:	e0bff517 	ldw	r2,-44(fp)
   2ae28:	10800017 	ldw	r2,0(r2)
   2ae2c:	10c00117 	ldw	r3,4(r2)
   2ae30:	e0bff517 	ldw	r2,-44(fp)
   2ae34:	10800017 	ldw	r2,0(r2)
   2ae38:	1080020b 	ldhu	r2,8(r2)
   2ae3c:	10bfffcc 	andi	r2,r2,65535
   2ae40:	1809883a 	mov	r4,r3
   2ae44:	100b883a 	mov	r5,r2
   2ae48:	00234500 	call	23450 <pbuf_realloc>
                    tcplen = TCP_TCPLEN(next->next);
   2ae4c:	e0bff517 	ldw	r2,-44(fp)
   2ae50:	10800017 	ldw	r2,0(r2)
   2ae54:	10c0020b 	ldhu	r3,8(r2)
   2ae58:	e0bff517 	ldw	r2,-44(fp)
   2ae5c:	10800017 	ldw	r2,0(r2)
   2ae60:	10800417 	ldw	r2,16(r2)
   2ae64:	11000303 	ldbu	r4,12(r2)
   2ae68:	10800343 	ldbu	r2,13(r2)
   2ae6c:	1004923a 	slli	r2,r2,8
   2ae70:	1104b03a 	or	r2,r2,r4
   2ae74:	10bfffcc 	andi	r2,r2,65535
   2ae78:	1004d23a 	srli	r2,r2,8
   2ae7c:	113fffcc 	andi	r4,r2,65535
   2ae80:	e0bff517 	ldw	r2,-44(fp)
   2ae84:	10800017 	ldw	r2,0(r2)
   2ae88:	10800417 	ldw	r2,16(r2)
   2ae8c:	11400303 	ldbu	r5,12(r2)
   2ae90:	10800343 	ldbu	r2,13(r2)
   2ae94:	1004923a 	slli	r2,r2,8
   2ae98:	1144b03a 	or	r2,r2,r5
   2ae9c:	10bfffcc 	andi	r2,r2,65535
   2aea0:	1004923a 	slli	r2,r2,8
   2aea4:	10bfffcc 	andi	r2,r2,65535
   2aea8:	2084b03a 	or	r2,r4,r2
   2aeac:	108000cc 	andi	r2,r2,3
   2aeb0:	1004c03a 	cmpne	r2,r2,zero
   2aeb4:	10803fcc 	andi	r2,r2,255
   2aeb8:	1885883a 	add	r2,r3,r2
   2aebc:	d0a9408d 	sth	r2,-23294(gp)
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
                                (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
                  }
                }
                break;
   2aec0:	00001206 	br	2af0c <tcp_receive+0x1f04>
              }
            }
            prev = next;
   2aec4:	e0bff517 	ldw	r2,-44(fp)
   2aec8:	e0bff615 	stw	r2,-40(fp)
             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
   2aecc:	e0bff517 	ldw	r2,-44(fp)
   2aed0:	10800017 	ldw	r2,0(r2)
   2aed4:	e0bff515 	stw	r2,-44(fp)
   2aed8:	e0bff517 	ldw	r2,-44(fp)
   2aedc:	103e711e 	bne	r2,zero,2a8a4 <tcp_receive+0x189c>
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
   2aee0:	00000f06 	br	2af20 <tcp_receive+0x1f18>
                break;
              } else {
                /* Either the lenghts are the same or the incoming
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
   2aee4:	0001883a 	nop
   2aee8:	00000906 	br	2af10 <tcp_receive+0x1f08>
                  } else {
                    pcb->ooseq = cseg;
                  }
                  tcp_oos_insert_segment(cseg, next);
                }
                break;
   2aeec:	0001883a 	nop
   2aef0:	00000706 	br	2af10 <tcp_receive+0x1f08>
                  cseg = tcp_seg_copy(&inseg);
                  if (cseg != NULL) {
                    pcb->ooseq = cseg;
                    tcp_oos_insert_segment(cseg, next);
                  }
                  break;
   2aef4:	0001883a 	nop
   2aef8:	00000506 	br	2af10 <tcp_receive+0x1f08>
                      pbuf_realloc(prev->p, prev->len);
                    }
                    prev->next = cseg;
                    tcp_oos_insert_segment(cseg, next);
                  }
                  break;
   2aefc:	0001883a 	nop
   2af00:	00000306 	br	2af10 <tcp_receive+0x1f08>
                 of the list. */
              if (next->next == NULL &&
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
                  /* segment "next" already contains all data */
                  break;
   2af04:	0001883a 	nop
   2af08:	00000106 	br	2af10 <tcp_receive+0x1f08>
                    tcplen = TCP_TCPLEN(next->next);
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
                                (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
                  }
                }
                break;
   2af0c:	0001883a 	nop
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
   2af10:	00000306 	br	2af20 <tcp_receive+0x1f18>
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */
#endif /* TCP_QUEUE_OOSEQ */
      }
    } else {
      /* The incoming segment is not withing the window. */
      tcp_send_empty_ack(pcb);
   2af14:	e13fff17 	ldw	r4,-4(fp)
   2af18:	002c8480 	call	2c848 <tcp_send_empty_ack>
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
   2af1c:	00001606 	br	2af78 <tcp_receive+0x1f70>
   2af20:	00001506 	br	2af78 <tcp_receive+0x1f70>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
   2af24:	d0e93e17 	ldw	r3,-23304(gp)
   2af28:	e0bfff17 	ldw	r2,-4(fp)
   2af2c:	10800b17 	ldw	r2,44(r2)
   2af30:	1885c83a 	sub	r2,r3,r2
   2af34:	10000a16 	blt	r2,zero,2af60 <tcp_receive+0x1f58>
   2af38:	d0e93e17 	ldw	r3,-23304(gp)
   2af3c:	e0bfff17 	ldw	r2,-4(fp)
   2af40:	11000b17 	ldw	r4,44(r2)
   2af44:	e0bfff17 	ldw	r2,-4(fp)
   2af48:	10800c0b 	ldhu	r2,48(r2)
   2af4c:	10bfffcc 	andi	r2,r2,65535
   2af50:	2085883a 	add	r2,r4,r2
   2af54:	1885c83a 	sub	r2,r3,r2
   2af58:	10800044 	addi	r2,r2,1
   2af5c:	0080060e 	bge	zero,r2,2af78 <tcp_receive+0x1f70>
      tcp_ack_now(pcb);
   2af60:	e0bfff17 	ldw	r2,-4(fp)
   2af64:	10800883 	ldbu	r2,34(r2)
   2af68:	10800094 	ori	r2,r2,2
   2af6c:	1007883a 	mov	r3,r2
   2af70:	e0bfff17 	ldw	r2,-4(fp)
   2af74:	10c00885 	stb	r3,34(r2)
    }
  }
}
   2af78:	e037883a 	mov	sp,fp
   2af7c:	dfc00217 	ldw	ra,8(sp)
   2af80:	df000117 	ldw	fp,4(sp)
   2af84:	dc000017 	ldw	r16,0(sp)
   2af88:	dec00304 	addi	sp,sp,12
   2af8c:	f800283a 	ret

0002af90 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
   2af90:	defffa04 	addi	sp,sp,-24
   2af94:	df000515 	stw	fp,20(sp)
   2af98:	df000504 	addi	fp,sp,20
   2af9c:	e13fff15 	stw	r4,-4(fp)
  u8_t *opts, opt;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  opts = (u8_t *)tcphdr + TCP_HLEN;
   2afa0:	d0a93c17 	ldw	r2,-23312(gp)
   2afa4:	10800504 	addi	r2,r2,20
   2afa8:	e0bffc15 	stw	r2,-16(fp)

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
   2afac:	d0a93c17 	ldw	r2,-23312(gp)
   2afb0:	10c00303 	ldbu	r3,12(r2)
   2afb4:	10800343 	ldbu	r2,13(r2)
   2afb8:	1004923a 	slli	r2,r2,8
   2afbc:	10c4b03a 	or	r2,r2,r3
   2afc0:	10bfffcc 	andi	r2,r2,65535
   2afc4:	1004d23a 	srli	r2,r2,8
   2afc8:	10ffffcc 	andi	r3,r2,65535
   2afcc:	d0a93c17 	ldw	r2,-23312(gp)
   2afd0:	11000303 	ldbu	r4,12(r2)
   2afd4:	10800343 	ldbu	r2,13(r2)
   2afd8:	1004923a 	slli	r2,r2,8
   2afdc:	1104b03a 	or	r2,r2,r4
   2afe0:	10bfffcc 	andi	r2,r2,65535
   2afe4:	1004923a 	slli	r2,r2,8
   2afe8:	10bfffcc 	andi	r2,r2,65535
   2afec:	1884b03a 	or	r2,r3,r2
   2aff0:	1005d33a 	srai	r2,r2,12
   2aff4:	10800190 	cmplti	r2,r2,6
   2aff8:	10006b1e 	bne	r2,zero,2b1a8 <tcp_parseopt+0x218>
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
   2affc:	d0a93c17 	ldw	r2,-23312(gp)
   2b000:	10c00303 	ldbu	r3,12(r2)
   2b004:	10800343 	ldbu	r2,13(r2)
   2b008:	1004923a 	slli	r2,r2,8
   2b00c:	10c4b03a 	or	r2,r2,r3
   2b010:	10bfffcc 	andi	r2,r2,65535
   2b014:	1004d23a 	srli	r2,r2,8
   2b018:	10ffffcc 	andi	r3,r2,65535
   2b01c:	d0a93c17 	ldw	r2,-23312(gp)
   2b020:	11000303 	ldbu	r4,12(r2)
   2b024:	10800343 	ldbu	r2,13(r2)
   2b028:	1004923a 	slli	r2,r2,8
   2b02c:	1104b03a 	or	r2,r2,r4
   2b030:	10bfffcc 	andi	r2,r2,65535
   2b034:	1004923a 	slli	r2,r2,8
   2b038:	10bfffcc 	andi	r2,r2,65535
   2b03c:	1884b03a 	or	r2,r3,r2
   2b040:	1005d33a 	srai	r2,r2,12
   2b044:	10bffec4 	addi	r2,r2,-5
   2b048:	1085883a 	add	r2,r2,r2
   2b04c:	1085883a 	add	r2,r2,r2
   2b050:	e0bffd0d 	sth	r2,-12(fp)
    for (c = 0; c < max_c; ) {
   2b054:	e03ffb0d 	sth	zero,-20(fp)
   2b058:	00004a06 	br	2b184 <tcp_parseopt+0x1f4>
      opt = opts[c];
   2b05c:	e0bffb0b 	ldhu	r2,-20(fp)
   2b060:	e0fffc17 	ldw	r3,-16(fp)
   2b064:	1885883a 	add	r2,r3,r2
   2b068:	10800003 	ldbu	r2,0(r2)
   2b06c:	e0bffd85 	stb	r2,-10(fp)
      switch (opt) {
   2b070:	e0bffd83 	ldbu	r2,-10(fp)
   2b074:	10c00060 	cmpeqi	r3,r2,1
   2b078:	1800041e 	bne	r3,zero,2b08c <tcp_parseopt+0xfc>
   2b07c:	10c000a0 	cmpeqi	r3,r2,2
   2b080:	1800061e 	bne	r3,zero,2b09c <tcp_parseopt+0x10c>
   2b084:	10004326 	beq	r2,zero,2b194 <tcp_parseopt+0x204>
   2b088:	00002e06 	br	2b144 <tcp_parseopt+0x1b4>
        /* End of options. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
        return;
      case 0x01:
        /* NOP option. */
        ++c;
   2b08c:	e0bffb0b 	ldhu	r2,-20(fp)
   2b090:	10800044 	addi	r2,r2,1
   2b094:	e0bffb0d 	sth	r2,-20(fp)
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
        break;
   2b098:	00003a06 	br	2b184 <tcp_parseopt+0x1f4>
      case 0x02:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
        if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
   2b09c:	e0bffb0b 	ldhu	r2,-20(fp)
   2b0a0:	10800044 	addi	r2,r2,1
   2b0a4:	e0fffc17 	ldw	r3,-16(fp)
   2b0a8:	1885883a 	add	r2,r3,r2
   2b0ac:	10800003 	ldbu	r2,0(r2)
   2b0b0:	10803fcc 	andi	r2,r2,255
   2b0b4:	10800118 	cmpnei	r2,r2,4
   2b0b8:	1000381e 	bne	r2,zero,2b19c <tcp_parseopt+0x20c>
   2b0bc:	e0bffb0b 	ldhu	r2,-20(fp)
   2b0c0:	10800104 	addi	r2,r2,4
   2b0c4:	e0fffd0b 	ldhu	r3,-12(fp)
   2b0c8:	18803416 	blt	r3,r2,2b19c <tcp_parseopt+0x20c>
          /* Bad length */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
   2b0cc:	e0bffb0b 	ldhu	r2,-20(fp)
   2b0d0:	10800084 	addi	r2,r2,2
   2b0d4:	e0fffc17 	ldw	r3,-16(fp)
   2b0d8:	1885883a 	add	r2,r3,r2
   2b0dc:	10800003 	ldbu	r2,0(r2)
   2b0e0:	10803fcc 	andi	r2,r2,255
   2b0e4:	1004923a 	slli	r2,r2,8
   2b0e8:	1007883a 	mov	r3,r2
   2b0ec:	e0bffb0b 	ldhu	r2,-20(fp)
   2b0f0:	108000c4 	addi	r2,r2,3
   2b0f4:	e13ffc17 	ldw	r4,-16(fp)
   2b0f8:	2085883a 	add	r2,r4,r2
   2b0fc:	10800003 	ldbu	r2,0(r2)
   2b100:	10803fcc 	andi	r2,r2,255
   2b104:	1884b03a 	or	r2,r3,r2
   2b108:	e0bffe0d 	sth	r2,-8(fp)
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
   2b10c:	e0bffe0b 	ldhu	r2,-8(fp)
   2b110:	10816d68 	cmpgeui	r2,r2,1461
   2b114:	1000041e 	bne	r2,zero,2b128 <tcp_parseopt+0x198>
   2b118:	e0bffe0b 	ldhu	r2,-8(fp)
   2b11c:	10000226 	beq	r2,zero,2b128 <tcp_parseopt+0x198>
   2b120:	e0bffe0b 	ldhu	r2,-8(fp)
   2b124:	00000106 	br	2b12c <tcp_parseopt+0x19c>
   2b128:	00816d04 	movi	r2,1460
   2b12c:	e0ffff17 	ldw	r3,-4(fp)
   2b130:	18800e8d 	sth	r2,58(r3)
        /* Advance to next option */
        c += 0x04;
   2b134:	e0bffb0b 	ldhu	r2,-20(fp)
   2b138:	10800104 	addi	r2,r2,4
   2b13c:	e0bffb0d 	sth	r2,-20(fp)
        break;
   2b140:	00001006 	br	2b184 <tcp_parseopt+0x1f4>
        c += 0x0A;
        break;
#endif
      default:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        if (opts[c + 1] == 0) {
   2b144:	e0bffb0b 	ldhu	r2,-20(fp)
   2b148:	10800044 	addi	r2,r2,1
   2b14c:	e0fffc17 	ldw	r3,-16(fp)
   2b150:	1885883a 	add	r2,r3,r2
   2b154:	10800003 	ldbu	r2,0(r2)
   2b158:	10803fcc 	andi	r2,r2,255
   2b15c:	10001126 	beq	r2,zero,2b1a4 <tcp_parseopt+0x214>
             and we don't process them further. */
          return;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
   2b160:	e0bffb0b 	ldhu	r2,-20(fp)
   2b164:	10800044 	addi	r2,r2,1
   2b168:	e0fffc17 	ldw	r3,-16(fp)
   2b16c:	1885883a 	add	r2,r3,r2
   2b170:	10800003 	ldbu	r2,0(r2)
   2b174:	10c03fcc 	andi	r3,r2,255
   2b178:	e0bffb0b 	ldhu	r2,-20(fp)
   2b17c:	1885883a 	add	r2,r3,r2
   2b180:	e0bffb0d 	sth	r2,-20(fp)
  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    for (c = 0; c < max_c; ) {
   2b184:	e0fffb0b 	ldhu	r3,-20(fp)
   2b188:	e0bffd0b 	ldhu	r2,-12(fp)
   2b18c:	18bfb336 	bltu	r3,r2,2b05c <tcp_parseopt+0xcc>
   2b190:	00000506 	br	2b1a8 <tcp_parseopt+0x218>
      opt = opts[c];
      switch (opt) {
      case 0x00:
        /* End of options. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
        return;
   2b194:	0001883a 	nop
   2b198:	00000306 	br	2b1a8 <tcp_parseopt+0x218>
      case 0x02:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
        if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
          /* Bad length */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          return;
   2b19c:	0001883a 	nop
   2b1a0:	00000106 	br	2b1a8 <tcp_parseopt+0x218>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        if (opts[c + 1] == 0) {
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          /* If the length field is zero, the options are malformed
             and we don't process them further. */
          return;
   2b1a4:	0001883a 	nop
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
   2b1a8:	e037883a 	mov	sp,fp
   2b1ac:	df000017 	ldw	fp,0(sp)
   2b1b0:	dec00104 	addi	sp,sp,4
   2b1b4:	f800283a 	ret

0002b1b8 <tcp_output_alloc_header>:
 * @return pbuf with p->payload being the tcp_hdr
 */
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
                      u32_t seqno_be /* already in network byte order */)
{
   2b1b8:	defff804 	addi	sp,sp,-32
   2b1bc:	dfc00715 	stw	ra,28(sp)
   2b1c0:	df000615 	stw	fp,24(sp)
   2b1c4:	df000604 	addi	fp,sp,24
   2b1c8:	e13ffc15 	stw	r4,-16(fp)
   2b1cc:	2807883a 	mov	r3,r5
   2b1d0:	3005883a 	mov	r2,r6
   2b1d4:	e1ffff15 	stw	r7,-4(fp)
   2b1d8:	e0fffd0d 	sth	r3,-12(fp)
   2b1dc:	e0bffe0d 	sth	r2,-8(fp)
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
   2b1e0:	e0fffd0b 	ldhu	r3,-12(fp)
   2b1e4:	e0bffe0b 	ldhu	r2,-8(fp)
   2b1e8:	1885883a 	add	r2,r3,r2
   2b1ec:	10800504 	addi	r2,r2,20
   2b1f0:	10bfffcc 	andi	r2,r2,65535
   2b1f4:	01000044 	movi	r4,1
   2b1f8:	100b883a 	mov	r5,r2
   2b1fc:	000d883a 	mov	r6,zero
   2b200:	0022fa00 	call	22fa0 <pbuf_alloc>
   2b204:	e0bffa15 	stw	r2,-24(fp)
  if (p != NULL) {
   2b208:	e0bffa17 	ldw	r2,-24(fp)
   2b20c:	1000be26 	beq	r2,zero,2b508 <tcp_output_alloc_header+0x350>
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
   2b210:	e0bffa17 	ldw	r2,-24(fp)
   2b214:	10800117 	ldw	r2,4(r2)
   2b218:	e0bffb15 	stw	r2,-20(fp)
    tcphdr->src = htons(pcb->local_port);
   2b21c:	e0bffc17 	ldw	r2,-16(fp)
   2b220:	1080078b 	ldhu	r2,30(r2)
   2b224:	10bfffcc 	andi	r2,r2,65535
   2b228:	1004d23a 	srli	r2,r2,8
   2b22c:	1007883a 	mov	r3,r2
   2b230:	e0bffc17 	ldw	r2,-16(fp)
   2b234:	1080078b 	ldhu	r2,30(r2)
   2b238:	10bfffcc 	andi	r2,r2,65535
   2b23c:	1004923a 	slli	r2,r2,8
   2b240:	1884b03a 	or	r2,r3,r2
   2b244:	1007883a 	mov	r3,r2
   2b248:	e0bffb17 	ldw	r2,-20(fp)
   2b24c:	193fffcc 	andi	r4,r3,65535
   2b250:	21003fcc 	andi	r4,r4,255
   2b254:	11400003 	ldbu	r5,0(r2)
   2b258:	280a703a 	and	r5,r5,zero
   2b25c:	2908b03a 	or	r4,r5,r4
   2b260:	11000005 	stb	r4,0(r2)
   2b264:	18ffffcc 	andi	r3,r3,65535
   2b268:	1806d23a 	srli	r3,r3,8
   2b26c:	18ffffcc 	andi	r3,r3,65535
   2b270:	11000043 	ldbu	r4,1(r2)
   2b274:	2008703a 	and	r4,r4,zero
   2b278:	20c6b03a 	or	r3,r4,r3
   2b27c:	10c00045 	stb	r3,1(r2)
    tcphdr->dest = htons(pcb->remote_port);
   2b280:	e0bffc17 	ldw	r2,-16(fp)
   2b284:	1080080b 	ldhu	r2,32(r2)
   2b288:	10bfffcc 	andi	r2,r2,65535
   2b28c:	1004d23a 	srli	r2,r2,8
   2b290:	1007883a 	mov	r3,r2
   2b294:	e0bffc17 	ldw	r2,-16(fp)
   2b298:	1080080b 	ldhu	r2,32(r2)
   2b29c:	10bfffcc 	andi	r2,r2,65535
   2b2a0:	1004923a 	slli	r2,r2,8
   2b2a4:	1884b03a 	or	r2,r3,r2
   2b2a8:	1007883a 	mov	r3,r2
   2b2ac:	e0bffb17 	ldw	r2,-20(fp)
   2b2b0:	193fffcc 	andi	r4,r3,65535
   2b2b4:	21003fcc 	andi	r4,r4,255
   2b2b8:	11400083 	ldbu	r5,2(r2)
   2b2bc:	280a703a 	and	r5,r5,zero
   2b2c0:	2908b03a 	or	r4,r5,r4
   2b2c4:	11000085 	stb	r4,2(r2)
   2b2c8:	18ffffcc 	andi	r3,r3,65535
   2b2cc:	1806d23a 	srli	r3,r3,8
   2b2d0:	18ffffcc 	andi	r3,r3,65535
   2b2d4:	110000c3 	ldbu	r4,3(r2)
   2b2d8:	2008703a 	and	r4,r4,zero
   2b2dc:	20c6b03a 	or	r3,r4,r3
   2b2e0:	10c000c5 	stb	r3,3(r2)
    tcphdr->seqno = seqno_be;
   2b2e4:	e0bffb17 	ldw	r2,-20(fp)
   2b2e8:	e0ffff17 	ldw	r3,-4(fp)
   2b2ec:	18c03fcc 	andi	r3,r3,255
   2b2f0:	11000103 	ldbu	r4,4(r2)
   2b2f4:	2008703a 	and	r4,r4,zero
   2b2f8:	20c6b03a 	or	r3,r4,r3
   2b2fc:	10c00105 	stb	r3,4(r2)
   2b300:	e0ffff17 	ldw	r3,-4(fp)
   2b304:	1806d23a 	srli	r3,r3,8
   2b308:	18c03fcc 	andi	r3,r3,255
   2b30c:	11000143 	ldbu	r4,5(r2)
   2b310:	2008703a 	and	r4,r4,zero
   2b314:	20c6b03a 	or	r3,r4,r3
   2b318:	10c00145 	stb	r3,5(r2)
   2b31c:	e0ffff17 	ldw	r3,-4(fp)
   2b320:	1806d43a 	srli	r3,r3,16
   2b324:	18c03fcc 	andi	r3,r3,255
   2b328:	11000183 	ldbu	r4,6(r2)
   2b32c:	2008703a 	and	r4,r4,zero
   2b330:	20c6b03a 	or	r3,r4,r3
   2b334:	10c00185 	stb	r3,6(r2)
   2b338:	e0ffff17 	ldw	r3,-4(fp)
   2b33c:	1806d63a 	srli	r3,r3,24
   2b340:	110001c3 	ldbu	r4,7(r2)
   2b344:	2008703a 	and	r4,r4,zero
   2b348:	20c6b03a 	or	r3,r4,r3
   2b34c:	10c001c5 	stb	r3,7(r2)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
   2b350:	e0bffc17 	ldw	r2,-16(fp)
   2b354:	10800b17 	ldw	r2,44(r2)
   2b358:	1006d63a 	srli	r3,r2,24
   2b35c:	e0bffc17 	ldw	r2,-16(fp)
   2b360:	10800b17 	ldw	r2,44(r2)
   2b364:	1004d23a 	srli	r2,r2,8
   2b368:	10bfc00c 	andi	r2,r2,65280
   2b36c:	1886b03a 	or	r3,r3,r2
   2b370:	e0bffc17 	ldw	r2,-16(fp)
   2b374:	10800b17 	ldw	r2,44(r2)
   2b378:	10bfc00c 	andi	r2,r2,65280
   2b37c:	1004923a 	slli	r2,r2,8
   2b380:	1886b03a 	or	r3,r3,r2
   2b384:	e0bffc17 	ldw	r2,-16(fp)
   2b388:	10800b17 	ldw	r2,44(r2)
   2b38c:	1004963a 	slli	r2,r2,24
   2b390:	1886b03a 	or	r3,r3,r2
   2b394:	e0bffb17 	ldw	r2,-20(fp)
   2b398:	19003fcc 	andi	r4,r3,255
   2b39c:	11400203 	ldbu	r5,8(r2)
   2b3a0:	280a703a 	and	r5,r5,zero
   2b3a4:	2908b03a 	or	r4,r5,r4
   2b3a8:	11000205 	stb	r4,8(r2)
   2b3ac:	1808d23a 	srli	r4,r3,8
   2b3b0:	21003fcc 	andi	r4,r4,255
   2b3b4:	11400243 	ldbu	r5,9(r2)
   2b3b8:	280a703a 	and	r5,r5,zero
   2b3bc:	2908b03a 	or	r4,r5,r4
   2b3c0:	11000245 	stb	r4,9(r2)
   2b3c4:	1808d43a 	srli	r4,r3,16
   2b3c8:	21003fcc 	andi	r4,r4,255
   2b3cc:	11400283 	ldbu	r5,10(r2)
   2b3d0:	280a703a 	and	r5,r5,zero
   2b3d4:	2908b03a 	or	r4,r5,r4
   2b3d8:	11000285 	stb	r4,10(r2)
   2b3dc:	1806d63a 	srli	r3,r3,24
   2b3e0:	110002c3 	ldbu	r4,11(r2)
   2b3e4:	2008703a 	and	r4,r4,zero
   2b3e8:	20c6b03a 	or	r3,r4,r3
   2b3ec:	10c002c5 	stb	r3,11(r2)
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
   2b3f0:	e0bffd0b 	ldhu	r2,-12(fp)
   2b3f4:	1004d0ba 	srli	r2,r2,2
   2b3f8:	10bfffcc 	andi	r2,r2,65535
   2b3fc:	10800144 	addi	r2,r2,5
   2b400:	1004933a 	slli	r2,r2,12
   2b404:	10bfffcc 	andi	r2,r2,65535
   2b408:	1004d23a 	srli	r2,r2,8
   2b40c:	10840014 	ori	r2,r2,4096
   2b410:	1007883a 	mov	r3,r2
   2b414:	e0bffb17 	ldw	r2,-20(fp)
   2b418:	193fffcc 	andi	r4,r3,65535
   2b41c:	21003fcc 	andi	r4,r4,255
   2b420:	11400303 	ldbu	r5,12(r2)
   2b424:	280a703a 	and	r5,r5,zero
   2b428:	2908b03a 	or	r4,r5,r4
   2b42c:	11000305 	stb	r4,12(r2)
   2b430:	18ffffcc 	andi	r3,r3,65535
   2b434:	1806d23a 	srli	r3,r3,8
   2b438:	18ffffcc 	andi	r3,r3,65535
   2b43c:	11000343 	ldbu	r4,13(r2)
   2b440:	2008703a 	and	r4,r4,zero
   2b444:	20c6b03a 	or	r3,r4,r3
   2b448:	10c00345 	stb	r3,13(r2)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
   2b44c:	e0bffc17 	ldw	r2,-16(fp)
   2b450:	10800c8b 	ldhu	r2,50(r2)
   2b454:	10bfffcc 	andi	r2,r2,65535
   2b458:	1004d23a 	srli	r2,r2,8
   2b45c:	1007883a 	mov	r3,r2
   2b460:	e0bffc17 	ldw	r2,-16(fp)
   2b464:	10800c8b 	ldhu	r2,50(r2)
   2b468:	10bfffcc 	andi	r2,r2,65535
   2b46c:	1004923a 	slli	r2,r2,8
   2b470:	1884b03a 	or	r2,r3,r2
   2b474:	1007883a 	mov	r3,r2
   2b478:	e0bffb17 	ldw	r2,-20(fp)
   2b47c:	193fffcc 	andi	r4,r3,65535
   2b480:	21003fcc 	andi	r4,r4,255
   2b484:	11400383 	ldbu	r5,14(r2)
   2b488:	280a703a 	and	r5,r5,zero
   2b48c:	2908b03a 	or	r4,r5,r4
   2b490:	11000385 	stb	r4,14(r2)
   2b494:	18ffffcc 	andi	r3,r3,65535
   2b498:	1806d23a 	srli	r3,r3,8
   2b49c:	18ffffcc 	andi	r3,r3,65535
   2b4a0:	110003c3 	ldbu	r4,15(r2)
   2b4a4:	2008703a 	and	r4,r4,zero
   2b4a8:	20c6b03a 	or	r3,r4,r3
   2b4ac:	10c003c5 	stb	r3,15(r2)
    tcphdr->chksum = 0;
   2b4b0:	e0bffb17 	ldw	r2,-20(fp)
   2b4b4:	10c00403 	ldbu	r3,16(r2)
   2b4b8:	1806703a 	and	r3,r3,zero
   2b4bc:	10c00405 	stb	r3,16(r2)
   2b4c0:	10c00443 	ldbu	r3,17(r2)
   2b4c4:	1806703a 	and	r3,r3,zero
   2b4c8:	10c00445 	stb	r3,17(r2)
    tcphdr->urgp = 0;
   2b4cc:	e0bffb17 	ldw	r2,-20(fp)
   2b4d0:	10c00483 	ldbu	r3,18(r2)
   2b4d4:	1806703a 	and	r3,r3,zero
   2b4d8:	10c00485 	stb	r3,18(r2)
   2b4dc:	10c004c3 	ldbu	r3,19(r2)
   2b4e0:	1806703a 	and	r3,r3,zero
   2b4e4:	10c004c5 	stb	r3,19(r2)

    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
   2b4e8:	e0bffc17 	ldw	r2,-16(fp)
   2b4ec:	10c00b17 	ldw	r3,44(r2)
   2b4f0:	e0bffc17 	ldw	r2,-16(fp)
   2b4f4:	10800c8b 	ldhu	r2,50(r2)
   2b4f8:	10bfffcc 	andi	r2,r2,65535
   2b4fc:	1887883a 	add	r3,r3,r2
   2b500:	e0bffc17 	ldw	r2,-16(fp)
   2b504:	10c00d15 	stw	r3,52(r2)
  }
  return p;
   2b508:	e0bffa17 	ldw	r2,-24(fp)
}
   2b50c:	e037883a 	mov	sp,fp
   2b510:	dfc00117 	ldw	ra,4(sp)
   2b514:	df000017 	ldw	fp,0(sp)
   2b518:	dec00204 	addi	sp,sp,8
   2b51c:	f800283a 	ret

0002b520 <tcp_send_fin>:
 * @param pcb the tcp_pcb over which to send a segment
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_fin(struct tcp_pcb *pcb)
{
   2b520:	defffc04 	addi	sp,sp,-16
   2b524:	dfc00315 	stw	ra,12(sp)
   2b528:	df000215 	stw	fp,8(sp)
   2b52c:	df000204 	addi	fp,sp,8
   2b530:	e13fff15 	stw	r4,-4(fp)
  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
   2b534:	e0bfff17 	ldw	r2,-4(fp)
   2b538:	10801c17 	ldw	r2,112(r2)
   2b53c:	10003d26 	beq	r2,zero,2b634 <tcp_send_fin+0x114>
    struct tcp_seg *last_unsent;
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
   2b540:	e0bfff17 	ldw	r2,-4(fp)
   2b544:	10801c17 	ldw	r2,112(r2)
   2b548:	e0bffe15 	stw	r2,-8(fp)
   2b54c:	00000306 	br	2b55c <tcp_send_fin+0x3c>
         last_unsent = last_unsent->next);
   2b550:	e0bffe17 	ldw	r2,-8(fp)
   2b554:	10800017 	ldw	r2,0(r2)
   2b558:	e0bffe15 	stw	r2,-8(fp)
tcp_send_fin(struct tcp_pcb *pcb)
{
  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
    struct tcp_seg *last_unsent;
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
   2b55c:	e0bffe17 	ldw	r2,-8(fp)
   2b560:	10800017 	ldw	r2,0(r2)
   2b564:	103ffa1e 	bne	r2,zero,2b550 <tcp_send_fin+0x30>
         last_unsent = last_unsent->next);

    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
   2b568:	e0bffe17 	ldw	r2,-8(fp)
   2b56c:	10800417 	ldw	r2,16(r2)
   2b570:	10c00303 	ldbu	r3,12(r2)
   2b574:	10800343 	ldbu	r2,13(r2)
   2b578:	1004923a 	slli	r2,r2,8
   2b57c:	10c4b03a 	or	r2,r2,r3
   2b580:	10bfffcc 	andi	r2,r2,65535
   2b584:	1004d23a 	srli	r2,r2,8
   2b588:	10ffffcc 	andi	r3,r2,65535
   2b58c:	e0bffe17 	ldw	r2,-8(fp)
   2b590:	10800417 	ldw	r2,16(r2)
   2b594:	11000303 	ldbu	r4,12(r2)
   2b598:	10800343 	ldbu	r2,13(r2)
   2b59c:	1004923a 	slli	r2,r2,8
   2b5a0:	1104b03a 	or	r2,r2,r4
   2b5a4:	10bfffcc 	andi	r2,r2,65535
   2b5a8:	1004923a 	slli	r2,r2,8
   2b5ac:	10bfffcc 	andi	r2,r2,65535
   2b5b0:	1884b03a 	or	r2,r3,r2
   2b5b4:	108001cc 	andi	r2,r2,7
   2b5b8:	10001e1e 	bne	r2,zero,2b634 <tcp_send_fin+0x114>
      /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
   2b5bc:	e0bffe17 	ldw	r2,-8(fp)
   2b5c0:	10800417 	ldw	r2,16(r2)
   2b5c4:	e0fffe17 	ldw	r3,-8(fp)
   2b5c8:	18c00417 	ldw	r3,16(r3)
   2b5cc:	19000303 	ldbu	r4,12(r3)
   2b5d0:	18c00343 	ldbu	r3,13(r3)
   2b5d4:	1806923a 	slli	r3,r3,8
   2b5d8:	1906b03a 	or	r3,r3,r4
   2b5dc:	18c04014 	ori	r3,r3,256
   2b5e0:	193fffcc 	andi	r4,r3,65535
   2b5e4:	21003fcc 	andi	r4,r4,255
   2b5e8:	11400303 	ldbu	r5,12(r2)
   2b5ec:	280a703a 	and	r5,r5,zero
   2b5f0:	2908b03a 	or	r4,r5,r4
   2b5f4:	11000305 	stb	r4,12(r2)
   2b5f8:	18ffffcc 	andi	r3,r3,65535
   2b5fc:	1806d23a 	srli	r3,r3,8
   2b600:	18ffffcc 	andi	r3,r3,65535
   2b604:	11000343 	ldbu	r4,13(r2)
   2b608:	2008703a 	and	r4,r4,zero
   2b60c:	20c6b03a 	or	r3,r4,r3
   2b610:	10c00345 	stb	r3,13(r2)
      pcb->flags |= TF_FIN;
   2b614:	e0bfff17 	ldw	r2,-4(fp)
   2b618:	10800883 	ldbu	r2,34(r2)
   2b61c:	10800814 	ori	r2,r2,32
   2b620:	1007883a 	mov	r3,r2
   2b624:	e0bfff17 	ldw	r2,-4(fp)
   2b628:	10c00885 	stb	r3,34(r2)
      return ERR_OK;
   2b62c:	0005883a 	mov	r2,zero
   2b630:	00000306 	br	2b640 <tcp_send_fin+0x120>
    }
  }
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue_flags(pcb, TCP_FIN);
   2b634:	e13fff17 	ldw	r4,-4(fp)
   2b638:	01400044 	movi	r5,1
   2b63c:	002c55c0 	call	2c55c <tcp_enqueue_flags>
}
   2b640:	e037883a 	mov	sp,fp
   2b644:	dfc00117 	ldw	ra,4(sp)
   2b648:	df000017 	ldw	fp,0(sp)
   2b64c:	dec00204 	addi	sp,sp,8
   2b650:	f800283a 	ret

0002b654 <tcp_create_segment>:
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
   2b654:	defff704 	addi	sp,sp,-36
   2b658:	dfc00815 	stw	ra,32(sp)
   2b65c:	df000715 	stw	fp,28(sp)
   2b660:	df000704 	addi	fp,sp,28
   2b664:	e13ffb15 	stw	r4,-20(fp)
   2b668:	e17ffc15 	stw	r5,-16(fp)
   2b66c:	3005883a 	mov	r2,r6
   2b670:	e1fffe15 	stw	r7,-8(fp)
   2b674:	e0c00217 	ldw	r3,8(fp)
   2b678:	e0bffd05 	stb	r2,-12(fp)
   2b67c:	e0ffff05 	stb	r3,-4(fp)
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
   2b680:	e0bfff03 	ldbu	r2,-4(fp)
   2b684:	1080004c 	andi	r2,r2,1
   2b688:	10000226 	beq	r2,zero,2b694 <tcp_create_segment+0x40>
   2b68c:	00c00104 	movi	r3,4
   2b690:	00000106 	br	2b698 <tcp_create_segment+0x44>
   2b694:	0007883a 	mov	r3,zero
   2b698:	e0bfff03 	ldbu	r2,-4(fp)
   2b69c:	1080008c 	andi	r2,r2,2
   2b6a0:	10000226 	beq	r2,zero,2b6ac <tcp_create_segment+0x58>
   2b6a4:	00800304 	movi	r2,12
   2b6a8:	00000106 	br	2b6b0 <tcp_create_segment+0x5c>
   2b6ac:	0005883a 	mov	r2,zero
   2b6b0:	1885883a 	add	r2,r3,r2
   2b6b4:	e0bff905 	stb	r2,-28(fp)

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
   2b6b8:	01000104 	movi	r4,4
   2b6bc:	00223cc0 	call	223cc <memp_malloc>
   2b6c0:	e0bffa15 	stw	r2,-24(fp)
   2b6c4:	e0bffa17 	ldw	r2,-24(fp)
   2b6c8:	1000041e 	bne	r2,zero,2b6dc <tcp_create_segment+0x88>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
   2b6cc:	e13ffc17 	ldw	r4,-16(fp)
   2b6d0:	00237600 	call	23760 <pbuf_free>
    return NULL;
   2b6d4:	0005883a 	mov	r2,zero
   2b6d8:	0000aa06 	br	2b984 <tcp_create_segment+0x330>
  }
  seg->flags = optflags;
   2b6dc:	e0bffa17 	ldw	r2,-24(fp)
   2b6e0:	e0ffff03 	ldbu	r3,-4(fp)
   2b6e4:	10c00345 	stb	r3,13(r2)
  seg->next = NULL;
   2b6e8:	e0bffa17 	ldw	r2,-24(fp)
   2b6ec:	10000015 	stw	zero,0(r2)
  seg->p = p;
   2b6f0:	e0bffa17 	ldw	r2,-24(fp)
   2b6f4:	e0fffc17 	ldw	r3,-16(fp)
   2b6f8:	10c00115 	stw	r3,4(r2)
  seg->len = p->tot_len - optlen;
   2b6fc:	e0bffc17 	ldw	r2,-16(fp)
   2b700:	10c0020b 	ldhu	r3,8(r2)
   2b704:	e0bff903 	ldbu	r2,-28(fp)
   2b708:	1885c83a 	sub	r2,r3,r2
   2b70c:	1007883a 	mov	r3,r2
   2b710:	e0bffa17 	ldw	r2,-24(fp)
   2b714:	10c0020d 	sth	r3,8(r2)
#if TCP_OVERSIZE_DBGCHECK
  seg->oversize_left = 0;
#endif /* TCP_OVERSIZE_DBGCHECK */
#if TCP_CHECKSUM_ON_COPY
  seg->chksum = 0;
   2b718:	e0bffa17 	ldw	r2,-24(fp)
   2b71c:	1000028d 	sth	zero,10(r2)
  seg->chksum_swapped = 0;
   2b720:	e0bffa17 	ldw	r2,-24(fp)
   2b724:	10000305 	stb	zero,12(r2)
  LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
              (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_header(p, TCP_HLEN)) {
   2b728:	e13ffc17 	ldw	r4,-16(fp)
   2b72c:	01400504 	movi	r5,20
   2b730:	00235b00 	call	235b0 <pbuf_header>
   2b734:	10803fcc 	andi	r2,r2,255
   2b738:	10000b26 	beq	r2,zero,2b768 <tcp_create_segment+0x114>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
   2b73c:	008001f4 	movhi	r2,7
   2b740:	10ac6e04 	addi	r2,r2,-20040
   2b744:	10805217 	ldw	r2,328(r2)
   2b748:	10c00044 	addi	r3,r2,1
   2b74c:	008001f4 	movhi	r2,7
   2b750:	10ac6e04 	addi	r2,r2,-20040
   2b754:	10c05215 	stw	r3,328(r2)
    tcp_seg_free(seg);
   2b758:	e13ffa17 	ldw	r4,-24(fp)
   2b75c:	00264f80 	call	264f8 <tcp_seg_free>
    return NULL;
   2b760:	0005883a 	mov	r2,zero
   2b764:	00008706 	br	2b984 <tcp_create_segment+0x330>
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
   2b768:	e0bffa17 	ldw	r2,-24(fp)
   2b76c:	10800117 	ldw	r2,4(r2)
   2b770:	10c00117 	ldw	r3,4(r2)
   2b774:	e0bffa17 	ldw	r2,-24(fp)
   2b778:	10c00415 	stw	r3,16(r2)
  seg->tcphdr->src = htons(pcb->local_port);
   2b77c:	e0bffa17 	ldw	r2,-24(fp)
   2b780:	10800417 	ldw	r2,16(r2)
   2b784:	e0fffb17 	ldw	r3,-20(fp)
   2b788:	18c0078b 	ldhu	r3,30(r3)
   2b78c:	18ffffcc 	andi	r3,r3,65535
   2b790:	1806d23a 	srli	r3,r3,8
   2b794:	1809883a 	mov	r4,r3
   2b798:	e0fffb17 	ldw	r3,-20(fp)
   2b79c:	18c0078b 	ldhu	r3,30(r3)
   2b7a0:	18ffffcc 	andi	r3,r3,65535
   2b7a4:	1806923a 	slli	r3,r3,8
   2b7a8:	20c6b03a 	or	r3,r4,r3
   2b7ac:	193fffcc 	andi	r4,r3,65535
   2b7b0:	21003fcc 	andi	r4,r4,255
   2b7b4:	11400003 	ldbu	r5,0(r2)
   2b7b8:	280a703a 	and	r5,r5,zero
   2b7bc:	2908b03a 	or	r4,r5,r4
   2b7c0:	11000005 	stb	r4,0(r2)
   2b7c4:	18ffffcc 	andi	r3,r3,65535
   2b7c8:	1806d23a 	srli	r3,r3,8
   2b7cc:	18ffffcc 	andi	r3,r3,65535
   2b7d0:	11000043 	ldbu	r4,1(r2)
   2b7d4:	2008703a 	and	r4,r4,zero
   2b7d8:	20c6b03a 	or	r3,r4,r3
   2b7dc:	10c00045 	stb	r3,1(r2)
  seg->tcphdr->dest = htons(pcb->remote_port);
   2b7e0:	e0bffa17 	ldw	r2,-24(fp)
   2b7e4:	10800417 	ldw	r2,16(r2)
   2b7e8:	e0fffb17 	ldw	r3,-20(fp)
   2b7ec:	18c0080b 	ldhu	r3,32(r3)
   2b7f0:	18ffffcc 	andi	r3,r3,65535
   2b7f4:	1806d23a 	srli	r3,r3,8
   2b7f8:	1809883a 	mov	r4,r3
   2b7fc:	e0fffb17 	ldw	r3,-20(fp)
   2b800:	18c0080b 	ldhu	r3,32(r3)
   2b804:	18ffffcc 	andi	r3,r3,65535
   2b808:	1806923a 	slli	r3,r3,8
   2b80c:	20c6b03a 	or	r3,r4,r3
   2b810:	193fffcc 	andi	r4,r3,65535
   2b814:	21003fcc 	andi	r4,r4,255
   2b818:	11400083 	ldbu	r5,2(r2)
   2b81c:	280a703a 	and	r5,r5,zero
   2b820:	2908b03a 	or	r4,r5,r4
   2b824:	11000085 	stb	r4,2(r2)
   2b828:	18ffffcc 	andi	r3,r3,65535
   2b82c:	1806d23a 	srli	r3,r3,8
   2b830:	18ffffcc 	andi	r3,r3,65535
   2b834:	110000c3 	ldbu	r4,3(r2)
   2b838:	2008703a 	and	r4,r4,zero
   2b83c:	20c6b03a 	or	r3,r4,r3
   2b840:	10c000c5 	stb	r3,3(r2)
  seg->tcphdr->seqno = htonl(seqno);
   2b844:	e0bffa17 	ldw	r2,-24(fp)
   2b848:	10800417 	ldw	r2,16(r2)
   2b84c:	e0fffe17 	ldw	r3,-8(fp)
   2b850:	1808d63a 	srli	r4,r3,24
   2b854:	e0fffe17 	ldw	r3,-8(fp)
   2b858:	1806d23a 	srli	r3,r3,8
   2b85c:	18ffc00c 	andi	r3,r3,65280
   2b860:	20c8b03a 	or	r4,r4,r3
   2b864:	e0fffe17 	ldw	r3,-8(fp)
   2b868:	18ffc00c 	andi	r3,r3,65280
   2b86c:	1806923a 	slli	r3,r3,8
   2b870:	20c8b03a 	or	r4,r4,r3
   2b874:	e0fffe17 	ldw	r3,-8(fp)
   2b878:	1806963a 	slli	r3,r3,24
   2b87c:	20c6b03a 	or	r3,r4,r3
   2b880:	19003fcc 	andi	r4,r3,255
   2b884:	11400103 	ldbu	r5,4(r2)
   2b888:	280a703a 	and	r5,r5,zero
   2b88c:	2908b03a 	or	r4,r5,r4
   2b890:	11000105 	stb	r4,4(r2)
   2b894:	1808d23a 	srli	r4,r3,8
   2b898:	21003fcc 	andi	r4,r4,255
   2b89c:	11400143 	ldbu	r5,5(r2)
   2b8a0:	280a703a 	and	r5,r5,zero
   2b8a4:	2908b03a 	or	r4,r5,r4
   2b8a8:	11000145 	stb	r4,5(r2)
   2b8ac:	1808d43a 	srli	r4,r3,16
   2b8b0:	21003fcc 	andi	r4,r4,255
   2b8b4:	11400183 	ldbu	r5,6(r2)
   2b8b8:	280a703a 	and	r5,r5,zero
   2b8bc:	2908b03a 	or	r4,r5,r4
   2b8c0:	11000185 	stb	r4,6(r2)
   2b8c4:	1806d63a 	srli	r3,r3,24
   2b8c8:	110001c3 	ldbu	r4,7(r2)
   2b8cc:	2008703a 	and	r4,r4,zero
   2b8d0:	20c6b03a 	or	r3,r4,r3
   2b8d4:	10c001c5 	stb	r3,7(r2)
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
   2b8d8:	e0bffa17 	ldw	r2,-24(fp)
   2b8dc:	10800417 	ldw	r2,16(r2)
   2b8e0:	e0fff903 	ldbu	r3,-28(fp)
   2b8e4:	1806d0ba 	srli	r3,r3,2
   2b8e8:	18c03fcc 	andi	r3,r3,255
   2b8ec:	18c00144 	addi	r3,r3,5
   2b8f0:	1808933a 	slli	r4,r3,12
   2b8f4:	e0fffd03 	ldbu	r3,-12(fp)
   2b8f8:	20c6b03a 	or	r3,r4,r3
   2b8fc:	18ffc00c 	andi	r3,r3,65280
   2b900:	1807d23a 	srai	r3,r3,8
   2b904:	1809883a 	mov	r4,r3
   2b908:	e0fff903 	ldbu	r3,-28(fp)
   2b90c:	1806d0ba 	srli	r3,r3,2
   2b910:	18c03fcc 	andi	r3,r3,255
   2b914:	18c00144 	addi	r3,r3,5
   2b918:	180a933a 	slli	r5,r3,12
   2b91c:	e0fffd03 	ldbu	r3,-12(fp)
   2b920:	28c6b03a 	or	r3,r5,r3
   2b924:	1806923a 	slli	r3,r3,8
   2b928:	20c6b03a 	or	r3,r4,r3
   2b92c:	193fffcc 	andi	r4,r3,65535
   2b930:	21003fcc 	andi	r4,r4,255
   2b934:	11400303 	ldbu	r5,12(r2)
   2b938:	280a703a 	and	r5,r5,zero
   2b93c:	2908b03a 	or	r4,r5,r4
   2b940:	11000305 	stb	r4,12(r2)
   2b944:	18ffffcc 	andi	r3,r3,65535
   2b948:	1806d23a 	srli	r3,r3,8
   2b94c:	18ffffcc 	andi	r3,r3,65535
   2b950:	11000343 	ldbu	r4,13(r2)
   2b954:	2008703a 	and	r4,r4,zero
   2b958:	20c6b03a 	or	r3,r4,r3
   2b95c:	10c00345 	stb	r3,13(r2)
  /* wnd and chksum are set in tcp_output */
  seg->tcphdr->urgp = 0;
   2b960:	e0bffa17 	ldw	r2,-24(fp)
   2b964:	10800417 	ldw	r2,16(r2)
   2b968:	10c00483 	ldbu	r3,18(r2)
   2b96c:	1806703a 	and	r3,r3,zero
   2b970:	10c00485 	stb	r3,18(r2)
   2b974:	10c004c3 	ldbu	r3,19(r2)
   2b978:	1806703a 	and	r3,r3,zero
   2b97c:	10c004c5 	stb	r3,19(r2)
  return seg;
   2b980:	e0bffa17 	ldw	r2,-24(fp)
} 
   2b984:	e037883a 	mov	sp,fp
   2b988:	dfc00117 	ldw	ra,4(sp)
   2b98c:	df000017 	ldw	fp,0(sp)
   2b990:	dec00204 	addi	sp,sp,8
   2b994:	f800283a 	ret

0002b998 <tcp_pbuf_prealloc>:
#if TCP_OVERSIZE
static struct pbuf *
tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
                  u16_t *oversize, struct tcp_pcb *pcb, u8_t apiflags,
                  u8_t first_seg)
{
   2b998:	defff604 	addi	sp,sp,-40
   2b99c:	dfc00915 	stw	ra,36(sp)
   2b9a0:	df000815 	stw	fp,32(sp)
   2b9a4:	df000804 	addi	fp,sp,32
   2b9a8:	e13ffa15 	stw	r4,-24(fp)
   2b9ac:	2807883a 	mov	r3,r5
   2b9b0:	3005883a 	mov	r2,r6
   2b9b4:	e1fffd15 	stw	r7,-12(fp)
   2b9b8:	e1400317 	ldw	r5,12(fp)
   2b9bc:	e1000417 	ldw	r4,16(fp)
   2b9c0:	e0fffb0d 	sth	r3,-20(fp)
   2b9c4:	e0bffc0d 	sth	r2,-16(fp)
   2b9c8:	e17ffe05 	stb	r5,-8(fp)
   2b9cc:	e13fff05 	stb	r4,-4(fp)
  struct pbuf *p;
  u16_t alloc = length;
   2b9d0:	e0bffb0b 	ldhu	r2,-20(fp)
   2b9d4:	e0bff80d 	sth	r2,-32(fp)
  LWIP_UNUSED_ARG(apiflags);
  LWIP_UNUSED_ARG(first_seg);
  /* always create MSS-sized pbufs */
  alloc = max_length;
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (length < max_length) {
   2b9d8:	e0fffb0b 	ldhu	r3,-20(fp)
   2b9dc:	e0bffc0b 	ldhu	r2,-16(fp)
   2b9e0:	1880182e 	bgeu	r3,r2,2ba44 <tcp_pbuf_prealloc+0xac>
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
   2b9e4:	e0bffe03 	ldbu	r2,-8(fp)
   2b9e8:	1080008c 	andi	r2,r2,2
   2b9ec:	10000d1e 	bne	r2,zero,2ba24 <tcp_pbuf_prealloc+0x8c>
        (!(pcb->flags & TF_NODELAY) &&
   2b9f0:	e0800217 	ldw	r2,8(fp)
   2b9f4:	10800883 	ldbu	r2,34(r2)
   2b9f8:	10803fcc 	andi	r2,r2,255
   2b9fc:	1080100c 	andi	r2,r2,64
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
   2ba00:	1000101e 	bne	r2,zero,2ba44 <tcp_pbuf_prealloc+0xac>
        (!(pcb->flags & TF_NODELAY) &&
   2ba04:	e0bfff03 	ldbu	r2,-4(fp)
   2ba08:	10000626 	beq	r2,zero,2ba24 <tcp_pbuf_prealloc+0x8c>
         (!first_seg ||
          pcb->unsent != NULL ||
   2ba0c:	e0800217 	ldw	r2,8(fp)
   2ba10:	10801c17 	ldw	r2,112(r2)
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
        (!(pcb->flags & TF_NODELAY) &&
         (!first_seg ||
   2ba14:	1000031e 	bne	r2,zero,2ba24 <tcp_pbuf_prealloc+0x8c>
          pcb->unsent != NULL ||
          pcb->unacked != NULL))) {
   2ba18:	e0800217 	ldw	r2,8(fp)
   2ba1c:	10801d17 	ldw	r2,116(r2)
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
        (!(pcb->flags & TF_NODELAY) &&
         (!first_seg ||
          pcb->unsent != NULL ||
   2ba20:	10000826 	beq	r2,zero,2ba44 <tcp_pbuf_prealloc+0xac>
          pcb->unacked != NULL))) {
      alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(length + TCP_OVERSIZE));
   2ba24:	e0bffb0b 	ldhu	r2,-20(fp)
   2ba28:	10c16dc4 	addi	r3,r2,1463
   2ba2c:	00bfff04 	movi	r2,-4
   2ba30:	1884703a 	and	r2,r3,r2
   2ba34:	e0fffc0b 	ldhu	r3,-16(fp)
   2ba38:	1880010e 	bge	r3,r2,2ba40 <tcp_pbuf_prealloc+0xa8>
   2ba3c:	1805883a 	mov	r2,r3
   2ba40:	e0bff80d 	sth	r2,-32(fp)
    }
  }
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
   2ba44:	e0bff80b 	ldhu	r2,-32(fp)
   2ba48:	e13ffa17 	ldw	r4,-24(fp)
   2ba4c:	100b883a 	mov	r5,r2
   2ba50:	000d883a 	mov	r6,zero
   2ba54:	0022fa00 	call	22fa0 <pbuf_alloc>
   2ba58:	e0bff915 	stw	r2,-28(fp)
  if (p == NULL) {
   2ba5c:	e0bff917 	ldw	r2,-28(fp)
   2ba60:	1000021e 	bne	r2,zero,2ba6c <tcp_pbuf_prealloc+0xd4>
    return NULL;
   2ba64:	0005883a 	mov	r2,zero
   2ba68:	00000f06 	br	2baa8 <tcp_pbuf_prealloc+0x110>
  }
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
  *oversize = p->len - length;
   2ba6c:	e0bff917 	ldw	r2,-28(fp)
   2ba70:	10c0028b 	ldhu	r3,10(r2)
   2ba74:	e0bffb0b 	ldhu	r2,-20(fp)
   2ba78:	1885c83a 	sub	r2,r3,r2
   2ba7c:	1007883a 	mov	r3,r2
   2ba80:	e0bffd17 	ldw	r2,-12(fp)
   2ba84:	10c0000d 	sth	r3,0(r2)
  /* trim p->len to the currently used size */
  p->len = p->tot_len = length;
   2ba88:	e0bff917 	ldw	r2,-28(fp)
   2ba8c:	e0fffb0b 	ldhu	r3,-20(fp)
   2ba90:	10c0020d 	sth	r3,8(r2)
   2ba94:	e0bff917 	ldw	r2,-28(fp)
   2ba98:	10c0020b 	ldhu	r3,8(r2)
   2ba9c:	e0bff917 	ldw	r2,-28(fp)
   2baa0:	10c0028d 	sth	r3,10(r2)
  return p;
   2baa4:	e0bff917 	ldw	r2,-28(fp)
}
   2baa8:	e037883a 	mov	sp,fp
   2baac:	dfc00117 	ldw	ra,4(sp)
   2bab0:	df000017 	ldw	fp,0(sp)
   2bab4:	dec00204 	addi	sp,sp,8
   2bab8:	f800283a 	ret

0002babc <tcp_seg_add_chksum>:
#if TCP_CHECKSUM_ON_COPY
/** Add a checksum of newly added data to the segment */
static void
tcp_seg_add_chksum(u16_t chksum, u16_t len, u16_t *seg_chksum,
                   u8_t *seg_chksum_swapped)
{
   2babc:	defffa04 	addi	sp,sp,-24
   2bac0:	df000515 	stw	fp,20(sp)
   2bac4:	df000504 	addi	fp,sp,20
   2bac8:	2007883a 	mov	r3,r4
   2bacc:	2805883a 	mov	r2,r5
   2bad0:	e1bffe15 	stw	r6,-8(fp)
   2bad4:	e1ffff15 	stw	r7,-4(fp)
   2bad8:	e0fffc0d 	sth	r3,-16(fp)
   2badc:	e0bffd0d 	sth	r2,-12(fp)
  u32_t helper;
  /* add chksum to old chksum and fold to u16_t */
  helper = chksum + *seg_chksum;
   2bae0:	e0fffc0b 	ldhu	r3,-16(fp)
   2bae4:	e0bffe17 	ldw	r2,-8(fp)
   2bae8:	1080000b 	ldhu	r2,0(r2)
   2baec:	10bfffcc 	andi	r2,r2,65535
   2baf0:	1885883a 	add	r2,r3,r2
   2baf4:	e0bffb15 	stw	r2,-20(fp)
  chksum = FOLD_U32T(helper);
   2baf8:	e0bffb17 	ldw	r2,-20(fp)
   2bafc:	1004d43a 	srli	r2,r2,16
   2bb00:	1007883a 	mov	r3,r2
   2bb04:	e0bffb17 	ldw	r2,-20(fp)
   2bb08:	1885883a 	add	r2,r3,r2
   2bb0c:	e0bffc0d 	sth	r2,-16(fp)
  if ((len & 1) != 0) {
   2bb10:	e0bffd0b 	ldhu	r2,-12(fp)
   2bb14:	1080004c 	andi	r2,r2,1
   2bb18:	10000e26 	beq	r2,zero,2bb54 <tcp_seg_add_chksum+0x98>
    *seg_chksum_swapped = 1 - *seg_chksum_swapped;
   2bb1c:	e0bfff17 	ldw	r2,-4(fp)
   2bb20:	10800003 	ldbu	r2,0(r2)
   2bb24:	00c00044 	movi	r3,1
   2bb28:	1885c83a 	sub	r2,r3,r2
   2bb2c:	1007883a 	mov	r3,r2
   2bb30:	e0bfff17 	ldw	r2,-4(fp)
   2bb34:	10c00005 	stb	r3,0(r2)
    chksum = SWAP_BYTES_IN_WORD(chksum);
   2bb38:	e0bffc0b 	ldhu	r2,-16(fp)
   2bb3c:	1004d23a 	srli	r2,r2,8
   2bb40:	1007883a 	mov	r3,r2
   2bb44:	e0bffc0b 	ldhu	r2,-16(fp)
   2bb48:	1004923a 	slli	r2,r2,8
   2bb4c:	1884b03a 	or	r2,r3,r2
   2bb50:	e0bffc0d 	sth	r2,-16(fp)
  }
  *seg_chksum = chksum;
   2bb54:	e0bffe17 	ldw	r2,-8(fp)
   2bb58:	e0fffc0b 	ldhu	r3,-16(fp)
   2bb5c:	10c0000d 	sth	r3,0(r2)
}
   2bb60:	e037883a 	mov	sp,fp
   2bb64:	df000017 	ldw	fp,0(sp)
   2bb68:	dec00104 	addi	sp,sp,4
   2bb6c:	f800283a 	ret

0002bb70 <tcp_write_checks>:
 * @param len length of data to send (checked agains snd_buf)
 * @return ERR_OK if tcp_write is allowed to proceed, another err_t otherwise
 */
static err_t
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
   2bb70:	defffd04 	addi	sp,sp,-12
   2bb74:	df000215 	stw	fp,8(sp)
   2bb78:	df000204 	addi	fp,sp,8
   2bb7c:	e13ffe15 	stw	r4,-8(fp)
   2bb80:	2805883a 	mov	r2,r5
   2bb84:	e0bfff0d 	sth	r2,-4(fp)
  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
   2bb88:	e0bffe17 	ldw	r2,-8(fp)
   2bb8c:	10800617 	ldw	r2,24(r2)
   2bb90:	10800120 	cmpeqi	r2,r2,4
   2bb94:	10000e1e 	bne	r2,zero,2bbd0 <tcp_write_checks+0x60>
      (pcb->state != CLOSE_WAIT) &&
   2bb98:	e0bffe17 	ldw	r2,-8(fp)
   2bb9c:	10800617 	ldw	r2,24(r2)
 */
static err_t
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
   2bba0:	108001e0 	cmpeqi	r2,r2,7
   2bba4:	10000a1e 	bne	r2,zero,2bbd0 <tcp_write_checks+0x60>
      (pcb->state != CLOSE_WAIT) &&
      (pcb->state != SYN_SENT) &&
   2bba8:	e0bffe17 	ldw	r2,-8(fp)
   2bbac:	10800617 	ldw	r2,24(r2)
static err_t
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
      (pcb->state != CLOSE_WAIT) &&
   2bbb0:	108000a0 	cmpeqi	r2,r2,2
   2bbb4:	1000061e 	bne	r2,zero,2bbd0 <tcp_write_checks+0x60>
      (pcb->state != SYN_SENT) &&
      (pcb->state != SYN_RCVD)) {
   2bbb8:	e0bffe17 	ldw	r2,-8(fp)
   2bbbc:	10800617 	ldw	r2,24(r2)
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
      (pcb->state != CLOSE_WAIT) &&
      (pcb->state != SYN_SENT) &&
   2bbc0:	108000e0 	cmpeqi	r2,r2,3
   2bbc4:	1000021e 	bne	r2,zero,2bbd0 <tcp_write_checks+0x60>
      (pcb->state != SYN_RCVD)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
   2bbc8:	00bffcc4 	movi	r2,-13
   2bbcc:	00002d06 	br	2bc84 <tcp_write_checks+0x114>
  } else if (len == 0) {
   2bbd0:	e0bfff0b 	ldhu	r2,-4(fp)
   2bbd4:	1000021e 	bne	r2,zero,2bbe0 <tcp_write_checks+0x70>
    return ERR_OK;
   2bbd8:	0005883a 	mov	r2,zero
   2bbdc:	00002906 	br	2bc84 <tcp_write_checks+0x114>
  }

  /* fail on too much data */
  if (len > pcb->snd_buf) {
   2bbe0:	e0bffe17 	ldw	r2,-8(fp)
   2bbe4:	10801a8b 	ldhu	r2,106(r2)
   2bbe8:	10ffffcc 	andi	r3,r2,65535
   2bbec:	e0bfff0b 	ldhu	r2,-4(fp)
   2bbf0:	1880092e 	bgeu	r3,r2,2bc18 <tcp_write_checks+0xa8>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n",
      len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
   2bbf4:	e0bffe17 	ldw	r2,-8(fp)
   2bbf8:	10c00883 	ldbu	r3,34(r2)
   2bbfc:	00bfe004 	movi	r2,-128
   2bc00:	1884b03a 	or	r2,r3,r2
   2bc04:	1007883a 	mov	r3,r2
   2bc08:	e0bffe17 	ldw	r2,-8(fp)
   2bc0c:	10c00885 	stb	r3,34(r2)
    return ERR_MEM;
   2bc10:	00bfffc4 	movi	r2,-1
   2bc14:	00001b06 	br	2bc84 <tcp_write_checks+0x114>
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
   2bc18:	e0bffe17 	ldw	r2,-8(fp)
   2bc1c:	10801b0b 	ldhu	r2,108(r2)
   2bc20:	10bfffcc 	andi	r2,r2,65535
   2bc24:	10800228 	cmpgeui	r2,r2,8
   2bc28:	1000051e 	bne	r2,zero,2bc40 <tcp_write_checks+0xd0>
   2bc2c:	e0bffe17 	ldw	r2,-8(fp)
   2bc30:	10801b0b 	ldhu	r2,108(r2)
   2bc34:	10bfffcc 	andi	r2,r2,65535
   2bc38:	10bfff70 	cmpltui	r2,r2,65533
   2bc3c:	1000101e 	bne	r2,zero,2bc80 <tcp_write_checks+0x110>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too long queue %"U16_F" (max %"U16_F")\n",
      pcb->snd_queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
   2bc40:	008001f4 	movhi	r2,7
   2bc44:	10ac6e04 	addi	r2,r2,-20040
   2bc48:	10804e17 	ldw	r2,312(r2)
   2bc4c:	10c00044 	addi	r3,r2,1
   2bc50:	008001f4 	movhi	r2,7
   2bc54:	10ac6e04 	addi	r2,r2,-20040
   2bc58:	10c04e15 	stw	r3,312(r2)
    pcb->flags |= TF_NAGLEMEMERR;
   2bc5c:	e0bffe17 	ldw	r2,-8(fp)
   2bc60:	10c00883 	ldbu	r3,34(r2)
   2bc64:	00bfe004 	movi	r2,-128
   2bc68:	1884b03a 	or	r2,r3,r2
   2bc6c:	1007883a 	mov	r3,r2
   2bc70:	e0bffe17 	ldw	r2,-8(fp)
   2bc74:	10c00885 	stb	r3,34(r2)
    return ERR_MEM;
   2bc78:	00bfffc4 	movi	r2,-1
   2bc7c:	00000106 	br	2bc84 <tcp_write_checks+0x114>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
      pcb->unacked == NULL && pcb->unsent == NULL);
  }
  return ERR_OK;
   2bc80:	0005883a 	mov	r2,zero
}
   2bc84:	e037883a 	mov	sp,fp
   2bc88:	df000017 	ldw	fp,0(sp)
   2bc8c:	dec00104 	addi	sp,sp,4
   2bc90:	f800283a 	ret

0002bc94 <tcp_write>:
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
   2bc94:	deffe504 	addi	sp,sp,-108
   2bc98:	dfc01a15 	stw	ra,104(sp)
   2bc9c:	df001915 	stw	fp,100(sp)
   2bca0:	df001904 	addi	fp,sp,100
   2bca4:	e13ffc15 	stw	r4,-16(fp)
   2bca8:	e17ffd15 	stw	r5,-12(fp)
   2bcac:	3007883a 	mov	r3,r6
   2bcb0:	3805883a 	mov	r2,r7
   2bcb4:	e0fffe0d 	sth	r3,-8(fp)
   2bcb8:	e0bfff05 	stb	r2,-4(fp)
  struct pbuf *concat_p = NULL;
   2bcbc:	e03fea15 	stw	zero,-88(fp)
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
   2bcc0:	e03feb15 	stw	zero,-84(fp)
   2bcc4:	e03fec15 	stw	zero,-80(fp)
   2bcc8:	e03fed15 	stw	zero,-76(fp)
   2bccc:	e03fee15 	stw	zero,-72(fp)
  u16_t pos = 0; /* position in 'arg' data */
   2bcd0:	e03fef0d 	sth	zero,-68(fp)
  u16_t queuelen;
  u8_t optlen = 0;
   2bcd4:	e03ff405 	stb	zero,-48(fp)
  u8_t optflags = 0;
   2bcd8:	e03ff445 	stb	zero,-47(fp)
#if TCP_OVERSIZE
  u16_t oversize = 0;
   2bcdc:	e03ff90d 	sth	zero,-28(fp)
  u16_t oversize_used = 0;
   2bce0:	e03ff00d 	sth	zero,-64(fp)
#endif /* TCP_OVERSIZE */
#if TCP_CHECKSUM_ON_COPY
  u16_t concat_chksum = 0;
   2bce4:	e03ff98d 	sth	zero,-26(fp)
  u8_t concat_chksum_swapped = 0;
   2bce8:	e03ffa05 	stb	zero,-24(fp)
  u16_t concat_chksummed = 0;
   2bcec:	e03ff08d 	sth	zero,-62(fp)
#endif /* TCP_CHECKSUM_ON_COPY */
  err_t err;
  /* don't allocate segments bigger than half the maximum window we ever received */
  u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max/2);
   2bcf0:	e0bffc17 	ldw	r2,-16(fp)
   2bcf4:	1080198b 	ldhu	r2,102(r2)
   2bcf8:	10bfffcc 	andi	r2,r2,65535
   2bcfc:	1004d07a 	srli	r2,r2,1
   2bd00:	e0fffc17 	ldw	r3,-16(fp)
   2bd04:	18c00e8b 	ldhu	r3,58(r3)
   2bd08:	113fffcc 	andi	r4,r2,65535
   2bd0c:	197fffcc 	andi	r5,r3,65535
   2bd10:	2900012e 	bgeu	r5,r4,2bd18 <tcp_write+0x84>
   2bd14:	1805883a 	mov	r2,r3
   2bd18:	e0bff48d 	sth	r2,-46(fp)
  apiflags |= TCP_WRITE_FLAG_COPY;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)apiflags));
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)", 
   2bd1c:	e0bffd17 	ldw	r2,-12(fp)
   2bd20:	1000091e 	bne	r2,zero,2bd48 <tcp_write+0xb4>
   2bd24:	01000134 	movhi	r4,4
   2bd28:	21054f04 	addi	r4,r4,5436
   2bd2c:	01400134 	movhi	r5,4
   2bd30:	29455b04 	addi	r5,r5,5484
   2bd34:	01805fc4 	movi	r6,383
   2bd38:	01c00134 	movhi	r7,4
   2bd3c:	39c56804 	addi	r7,r7,5536
   2bd40:	00044740 	call	4474 <printf>
   2bd44:	003fff06 	br	2bd44 <tcp_write+0xb0>
             arg != NULL, return ERR_ARG;);

  err = tcp_write_checks(pcb, len);
   2bd48:	e0bffe0b 	ldhu	r2,-8(fp)
   2bd4c:	e13ffc17 	ldw	r4,-16(fp)
   2bd50:	100b883a 	mov	r5,r2
   2bd54:	002bb700 	call	2bb70 <tcp_write_checks>
   2bd58:	e0bff505 	stb	r2,-44(fp)
  if (err != ERR_OK) {
   2bd5c:	e0bff507 	ldb	r2,-44(fp)
   2bd60:	10000226 	beq	r2,zero,2bd6c <tcp_write+0xd8>
    return err;
   2bd64:	e0bff503 	ldbu	r2,-44(fp)
   2bd68:	0001f706 	br	2c548 <tcp_write+0x8b4>
  }
  queuelen = pcb->snd_queuelen;
   2bd6c:	e0bffc17 	ldw	r2,-16(fp)
   2bd70:	10801b0b 	ldhu	r2,108(r2)
   2bd74:	e0bfef8d 	sth	r2,-66(fp)
   *
   * pos records progress as data is segmented.
   */

  /* Find the tail of the unsent queue. */
  if (pcb->unsent != NULL) {
   2bd78:	e0bffc17 	ldw	r2,-16(fp)
   2bd7c:	10801c17 	ldw	r2,112(r2)
   2bd80:	10013a26 	beq	r2,zero,2c26c <tcp_write+0x5d8>
    u16_t space;
    u16_t unsent_optlen;

    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
   2bd84:	e0bffc17 	ldw	r2,-16(fp)
   2bd88:	10801c17 	ldw	r2,112(r2)
   2bd8c:	e0bfeb15 	stw	r2,-84(fp)
   2bd90:	00000306 	br	2bda0 <tcp_write+0x10c>
         last_unsent = last_unsent->next);
   2bd94:	e0bfeb17 	ldw	r2,-84(fp)
   2bd98:	10800017 	ldw	r2,0(r2)
   2bd9c:	e0bfeb15 	stw	r2,-84(fp)
  if (pcb->unsent != NULL) {
    u16_t space;
    u16_t unsent_optlen;

    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
   2bda0:	e0bfeb17 	ldw	r2,-84(fp)
   2bda4:	10800017 	ldw	r2,0(r2)
   2bda8:	103ffa1e 	bne	r2,zero,2bd94 <tcp_write+0x100>
         last_unsent = last_unsent->next);

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
   2bdac:	e0bfeb17 	ldw	r2,-84(fp)
   2bdb0:	10800343 	ldbu	r2,13(r2)
   2bdb4:	10803fcc 	andi	r2,r2,255
   2bdb8:	1080004c 	andi	r2,r2,1
   2bdbc:	10000226 	beq	r2,zero,2bdc8 <tcp_write+0x134>
   2bdc0:	00c00104 	movi	r3,4
   2bdc4:	00000106 	br	2bdcc <tcp_write+0x138>
   2bdc8:	0007883a 	mov	r3,zero
   2bdcc:	e0bfeb17 	ldw	r2,-84(fp)
   2bdd0:	10800343 	ldbu	r2,13(r2)
   2bdd4:	10803fcc 	andi	r2,r2,255
   2bdd8:	1080008c 	andi	r2,r2,2
   2bddc:	10000226 	beq	r2,zero,2bde8 <tcp_write+0x154>
   2bde0:	00800304 	movi	r2,12
   2bde4:	00000106 	br	2bdec <tcp_write+0x158>
   2bde8:	0005883a 	mov	r2,zero
   2bdec:	1885883a 	add	r2,r3,r2
   2bdf0:	e0bff58d 	sth	r2,-42(fp)
    space = mss_local - (last_unsent->len + unsent_optlen);
   2bdf4:	e0bfeb17 	ldw	r2,-84(fp)
   2bdf8:	10c0020b 	ldhu	r3,8(r2)
   2bdfc:	e0bff58b 	ldhu	r2,-42(fp)
   2be00:	1885883a 	add	r2,r3,r2
   2be04:	e0fff48b 	ldhu	r3,-46(fp)
   2be08:	1885c83a 	sub	r2,r3,r2
   2be0c:	e0bff10d 	sth	r2,-60(fp)
#if TCP_OVERSIZE_DBGCHECK
    /* check that pcb->unsent_oversize matches last_unsent->unsent_oversize */
    LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
                pcb->unsent_oversize == last_unsent->oversize_left);
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
   2be10:	e0bffc17 	ldw	r2,-16(fp)
   2be14:	10801b8b 	ldhu	r2,110(r2)
   2be18:	e0bff90d 	sth	r2,-28(fp)
    if (oversize > 0) {
   2be1c:	e0bff90b 	ldhu	r2,-28(fp)
   2be20:	10bfffcc 	andi	r2,r2,65535
   2be24:	10001526 	beq	r2,zero,2be7c <tcp_write+0x1e8>
      LWIP_ASSERT("inconsistent oversize vs. space", oversize_used <= space);
      seg = last_unsent;
   2be28:	e0bfeb17 	ldw	r2,-84(fp)
   2be2c:	e0bfec15 	stw	r2,-80(fp)
      oversize_used = oversize < len ? oversize : len;
   2be30:	e0fff90b 	ldhu	r3,-28(fp)
   2be34:	e0bffe0b 	ldhu	r2,-8(fp)
   2be38:	113fffcc 	andi	r4,r2,65535
   2be3c:	197fffcc 	andi	r5,r3,65535
   2be40:	2900012e 	bgeu	r5,r4,2be48 <tcp_write+0x1b4>
   2be44:	1805883a 	mov	r2,r3
   2be48:	e0bff00d 	sth	r2,-64(fp)
      pos += oversize_used;
   2be4c:	e0ffef0b 	ldhu	r3,-68(fp)
   2be50:	e0bff00b 	ldhu	r2,-64(fp)
   2be54:	1885883a 	add	r2,r3,r2
   2be58:	e0bfef0d 	sth	r2,-68(fp)
      oversize -= oversize_used;
   2be5c:	e0fff90b 	ldhu	r3,-28(fp)
   2be60:	e0bff00b 	ldhu	r2,-64(fp)
   2be64:	1885c83a 	sub	r2,r3,r2
   2be68:	e0bff90d 	sth	r2,-28(fp)
      space -= oversize_used;
   2be6c:	e0fff10b 	ldhu	r3,-60(fp)
   2be70:	e0bff00b 	ldhu	r2,-64(fp)
   2be74:	1885c83a 	sub	r2,r3,r2
   2be78:	e0bff10d 	sth	r2,-60(fp)
     *
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
     * the end.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
   2be7c:	e0ffef0b 	ldhu	r3,-68(fp)
   2be80:	e0bffe0b 	ldhu	r2,-8(fp)
   2be84:	1880f92e 	bgeu	r3,r2,2c26c <tcp_write+0x5d8>
   2be88:	e0bff10b 	ldhu	r2,-60(fp)
   2be8c:	1000f726 	beq	r2,zero,2c26c <tcp_write+0x5d8>
   2be90:	e0bfeb17 	ldw	r2,-84(fp)
   2be94:	1080020b 	ldhu	r2,8(r2)
   2be98:	10bfffcc 	andi	r2,r2,65535
   2be9c:	1000f326 	beq	r2,zero,2c26c <tcp_write+0x5d8>
      u16_t seglen = space < len - pos ? space : len - pos;
   2bea0:	e0fffe0b 	ldhu	r3,-8(fp)
   2bea4:	e0bfef0b 	ldhu	r2,-68(fp)
   2bea8:	1885c83a 	sub	r2,r3,r2
   2beac:	e0fff10b 	ldhu	r3,-60(fp)
   2beb0:	1880010e 	bge	r3,r2,2beb8 <tcp_write+0x224>
   2beb4:	1805883a 	mov	r2,r3
   2beb8:	e0bff60d 	sth	r2,-40(fp)
      seg = last_unsent;
   2bebc:	e0bfeb17 	ldw	r2,-84(fp)
   2bec0:	e0bfec15 	stw	r2,-80(fp)

      /* Create a pbuf with a copy or reference to seglen bytes. We
       * can use PBUF_RAW here since the data appears in the middle of
       * a segment. A header will never be prepended. */
      if (apiflags & TCP_WRITE_FLAG_COPY) {
   2bec4:	e0bfff03 	ldbu	r2,-4(fp)
   2bec8:	1080004c 	andi	r2,r2,1
   2becc:	10002526 	beq	r2,zero,2bf64 <tcp_write+0x2d0>
        /* Data is copied */
        if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
   2bed0:	e17ff60b 	ldhu	r5,-40(fp)
   2bed4:	e0fff10b 	ldhu	r3,-60(fp)
   2bed8:	e13fff03 	ldbu	r4,-4(fp)
   2bedc:	e0bff904 	addi	r2,fp,-28
   2bee0:	e1bffc17 	ldw	r6,-16(fp)
   2bee4:	d9800015 	stw	r6,0(sp)
   2bee8:	d9000115 	stw	r4,4(sp)
   2beec:	01000044 	movi	r4,1
   2bef0:	d9000215 	stw	r4,8(sp)
   2bef4:	010000c4 	movi	r4,3
   2bef8:	180d883a 	mov	r6,r3
   2befc:	100f883a 	mov	r7,r2
   2bf00:	002b9980 	call	2b998 <tcp_pbuf_prealloc>
   2bf04:	e0bfea15 	stw	r2,-88(fp)
   2bf08:	e0bfea17 	ldw	r2,-88(fp)
   2bf0c:	10017426 	beq	r2,zero,2c4e0 <tcp_write+0x84c>
          goto memerr;
        }
#if TCP_OVERSIZE_DBGCHECK
        last_unsent->oversize_left += oversize;
#endif /* TCP_OVERSIZE_DBGCHECK */
        TCP_DATA_COPY2(concat_p->payload, (u8_t*)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
   2bf10:	e0bfea17 	ldw	r2,-88(fp)
   2bf14:	11000117 	ldw	r4,4(r2)
   2bf18:	e0bfef0b 	ldhu	r2,-68(fp)
   2bf1c:	e0fffd17 	ldw	r3,-12(fp)
   2bf20:	1887883a 	add	r3,r3,r2
   2bf24:	e0bff60b 	ldhu	r2,-40(fp)
   2bf28:	180b883a 	mov	r5,r3
   2bf2c:	100d883a 	mov	r6,r2
   2bf30:	003e8240 	call	3e824 <lwip_chksum_copy>
   2bf34:	113fffcc 	andi	r4,r2,65535
   2bf38:	e17ff60b 	ldhu	r5,-40(fp)
   2bf3c:	e0fff984 	addi	r3,fp,-26
   2bf40:	e0bffa04 	addi	r2,fp,-24
   2bf44:	180d883a 	mov	r6,r3
   2bf48:	100f883a 	mov	r7,r2
   2bf4c:	002babc0 	call	2babc <tcp_seg_add_chksum>
#if TCP_CHECKSUM_ON_COPY
        concat_chksummed += seglen;
   2bf50:	e0fff08b 	ldhu	r3,-62(fp)
   2bf54:	e0bff60b 	ldhu	r2,-40(fp)
   2bf58:	1885883a 	add	r2,r3,r2
   2bf5c:	e0bff08d 	sth	r2,-62(fp)
   2bf60:	00002006 	br	2bfe4 <tcp_write+0x350>
#endif /* TCP_CHECKSUM_ON_COPY */
      } else {
        /* Data is not copied */
        if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
   2bf64:	e0bff60b 	ldhu	r2,-40(fp)
   2bf68:	010000c4 	movi	r4,3
   2bf6c:	100b883a 	mov	r5,r2
   2bf70:	01800044 	movi	r6,1
   2bf74:	0022fa00 	call	22fa0 <pbuf_alloc>
   2bf78:	e0bfea15 	stw	r2,-88(fp)
   2bf7c:	e0bfea17 	ldw	r2,-88(fp)
   2bf80:	10015926 	beq	r2,zero,2c4e8 <tcp_write+0x854>
                      ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
          goto memerr;
        }
#if TCP_CHECKSUM_ON_COPY
        /* calculate the checksum of nocopy-data */
        tcp_seg_add_chksum(~inet_chksum((u8_t*)arg + pos, seglen), seglen,
   2bf84:	e0bfef0b 	ldhu	r2,-68(fp)
   2bf88:	e0fffd17 	ldw	r3,-12(fp)
   2bf8c:	1887883a 	add	r3,r3,r2
   2bf90:	e0bff60b 	ldhu	r2,-40(fp)
   2bf94:	1809883a 	mov	r4,r3
   2bf98:	100b883a 	mov	r5,r2
   2bf9c:	003e6d40 	call	3e6d4 <inet_chksum>
   2bfa0:	0084303a 	nor	r2,zero,r2
   2bfa4:	113fffcc 	andi	r4,r2,65535
   2bfa8:	e17ff60b 	ldhu	r5,-40(fp)
   2bfac:	e0fff984 	addi	r3,fp,-26
   2bfb0:	e0bffa04 	addi	r2,fp,-24
   2bfb4:	180d883a 	mov	r6,r3
   2bfb8:	100f883a 	mov	r7,r2
   2bfbc:	002babc0 	call	2babc <tcp_seg_add_chksum>
          &concat_chksum, &concat_chksum_swapped);
        concat_chksummed += seglen;
   2bfc0:	e0fff08b 	ldhu	r3,-62(fp)
   2bfc4:	e0bff60b 	ldhu	r2,-40(fp)
   2bfc8:	1885883a 	add	r2,r3,r2
   2bfcc:	e0bff08d 	sth	r2,-62(fp)
#endif /* TCP_CHECKSUM_ON_COPY */
        /* reference the non-volatile payload data */
        concat_p->payload = (u8_t*)arg + pos;
   2bfd0:	e0bfef0b 	ldhu	r2,-68(fp)
   2bfd4:	e0fffd17 	ldw	r3,-12(fp)
   2bfd8:	1887883a 	add	r3,r3,r2
   2bfdc:	e0bfea17 	ldw	r2,-88(fp)
   2bfe0:	10c00115 	stw	r3,4(r2)
      }

      pos += seglen;
   2bfe4:	e0ffef0b 	ldhu	r3,-68(fp)
   2bfe8:	e0bff60b 	ldhu	r2,-40(fp)
   2bfec:	1885883a 	add	r2,r3,r2
   2bff0:	e0bfef0d 	sth	r2,-68(fp)
      queuelen += pbuf_clen(concat_p);
   2bff4:	e13fea17 	ldw	r4,-88(fp)
   2bff8:	00238a40 	call	238a4 <pbuf_clen>
   2bffc:	10c03fcc 	andi	r3,r2,255
   2c000:	e0bfef8b 	ldhu	r2,-66(fp)
   2c004:	1885883a 	add	r2,r3,r2
   2c008:	e0bfef8d 	sth	r2,-66(fp)
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
   2c00c:	00009706 	br	2c26c <tcp_write+0x5d8>
    struct pbuf *p;
    u16_t left = len - pos;
   2c010:	e0fffe0b 	ldhu	r3,-8(fp)
   2c014:	e0bfef0b 	ldhu	r2,-68(fp)
   2c018:	1885c83a 	sub	r2,r3,r2
   2c01c:	e0bff68d 	sth	r2,-38(fp)
    u16_t max_len = mss_local - optlen;
   2c020:	e0bff403 	ldbu	r2,-48(fp)
   2c024:	e0fff48b 	ldhu	r3,-46(fp)
   2c028:	1885c83a 	sub	r2,r3,r2
   2c02c:	e0bff70d 	sth	r2,-36(fp)
    u16_t seglen = left > max_len ? max_len : left;
   2c030:	e0fff70b 	ldhu	r3,-36(fp)
   2c034:	e0bff68b 	ldhu	r2,-38(fp)
   2c038:	113fffcc 	andi	r4,r2,65535
   2c03c:	197fffcc 	andi	r5,r3,65535
   2c040:	2900012e 	bgeu	r5,r4,2c048 <tcp_write+0x3b4>
   2c044:	1805883a 	mov	r2,r3
   2c048:	e0bff78d 	sth	r2,-34(fp)
#if TCP_CHECKSUM_ON_COPY
    u16_t chksum = 0;
   2c04c:	e03ffa8d 	sth	zero,-22(fp)
    u8_t chksum_swapped = 0;
   2c050:	e03ffb05 	stb	zero,-20(fp)
#endif /* TCP_CHECKSUM_ON_COPY */

    if (apiflags & TCP_WRITE_FLAG_COPY) {
   2c054:	e0bfff03 	ldbu	r2,-4(fp)
   2c058:	1080004c 	andi	r2,r2,1
   2c05c:	10002826 	beq	r2,zero,2c100 <tcp_write+0x46c>
      /* If copy is set, memory should be allocated and data copied
       * into pbuf */
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
   2c060:	e0fff403 	ldbu	r3,-48(fp)
   2c064:	e0bff78b 	ldhu	r2,-34(fp)
   2c068:	1885883a 	add	r2,r3,r2
   2c06c:	117fffcc 	andi	r5,r2,65535
   2c070:	e0fff48b 	ldhu	r3,-46(fp)
   2c074:	e1bfff03 	ldbu	r6,-4(fp)
   2c078:	e0bfee17 	ldw	r2,-72(fp)
   2c07c:	1005003a 	cmpeq	r2,r2,zero
   2c080:	11003fcc 	andi	r4,r2,255
   2c084:	e0bff904 	addi	r2,fp,-28
   2c088:	e1fffc17 	ldw	r7,-16(fp)
   2c08c:	d9c00015 	stw	r7,0(sp)
   2c090:	d9800115 	stw	r6,4(sp)
   2c094:	d9000215 	stw	r4,8(sp)
   2c098:	0009883a 	mov	r4,zero
   2c09c:	180d883a 	mov	r6,r3
   2c0a0:	100f883a 	mov	r7,r2
   2c0a4:	002b9980 	call	2b998 <tcp_pbuf_prealloc>
   2c0a8:	e0bff215 	stw	r2,-56(fp)
   2c0ac:	e0bff217 	ldw	r2,-56(fp)
   2c0b0:	10010e26 	beq	r2,zero,2c4ec <tcp_write+0x858>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
                  (p->len >= seglen));
      TCP_DATA_COPY2((char *)p->payload + optlen, (u8_t*)arg + pos, seglen, &chksum, &chksum_swapped);
   2c0b4:	e0bff217 	ldw	r2,-56(fp)
   2c0b8:	10c00117 	ldw	r3,4(r2)
   2c0bc:	e0bff403 	ldbu	r2,-48(fp)
   2c0c0:	1889883a 	add	r4,r3,r2
   2c0c4:	e0bfef0b 	ldhu	r2,-68(fp)
   2c0c8:	e0fffd17 	ldw	r3,-12(fp)
   2c0cc:	1887883a 	add	r3,r3,r2
   2c0d0:	e0bff78b 	ldhu	r2,-34(fp)
   2c0d4:	180b883a 	mov	r5,r3
   2c0d8:	100d883a 	mov	r6,r2
   2c0dc:	003e8240 	call	3e824 <lwip_chksum_copy>
   2c0e0:	113fffcc 	andi	r4,r2,65535
   2c0e4:	e17ff78b 	ldhu	r5,-34(fp)
   2c0e8:	e0fffa84 	addi	r3,fp,-22
   2c0ec:	e0bffb04 	addi	r2,fp,-20
   2c0f0:	180d883a 	mov	r6,r3
   2c0f4:	100f883a 	mov	r7,r2
   2c0f8:	002babc0 	call	2babc <tcp_seg_add_chksum>
   2c0fc:	00002406 	br	2c190 <tcp_write+0x4fc>
       */
      struct pbuf *p2;
#if TCP_OVERSIZE
      LWIP_ASSERT("oversize == 0", oversize == 0);
#endif /* TCP_OVERSIZE */
      if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
   2c100:	e0bff78b 	ldhu	r2,-34(fp)
   2c104:	0009883a 	mov	r4,zero
   2c108:	100b883a 	mov	r5,r2
   2c10c:	01800044 	movi	r6,1
   2c110:	0022fa00 	call	22fa0 <pbuf_alloc>
   2c114:	e0bff815 	stw	r2,-32(fp)
   2c118:	e0bff817 	ldw	r2,-32(fp)
   2c11c:	1000f326 	beq	r2,zero,2c4ec <tcp_write+0x858>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
#if TCP_CHECKSUM_ON_COPY
      /* calculate the checksum of nocopy-data */
      chksum = ~inet_chksum((u8_t*)arg + pos, seglen);
   2c120:	e0bfef0b 	ldhu	r2,-68(fp)
   2c124:	e0fffd17 	ldw	r3,-12(fp)
   2c128:	1887883a 	add	r3,r3,r2
   2c12c:	e0bff78b 	ldhu	r2,-34(fp)
   2c130:	1809883a 	mov	r4,r3
   2c134:	100b883a 	mov	r5,r2
   2c138:	003e6d40 	call	3e6d4 <inet_chksum>
   2c13c:	0084303a 	nor	r2,zero,r2
   2c140:	e0bffa8d 	sth	r2,-22(fp)
#endif /* TCP_CHECKSUM_ON_COPY */
      /* reference the non-volatile payload data */
      p2->payload = (u8_t*)arg + pos;
   2c144:	e0bfef0b 	ldhu	r2,-68(fp)
   2c148:	e0fffd17 	ldw	r3,-12(fp)
   2c14c:	1887883a 	add	r3,r3,r2
   2c150:	e0bff817 	ldw	r2,-32(fp)
   2c154:	10c00115 	stw	r3,4(r2)

      /* Second, allocate a pbuf for the headers. */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
   2c158:	e0bff403 	ldbu	r2,-48(fp)
   2c15c:	0009883a 	mov	r4,zero
   2c160:	100b883a 	mov	r5,r2
   2c164:	000d883a 	mov	r6,zero
   2c168:	0022fa00 	call	22fa0 <pbuf_alloc>
   2c16c:	e0bff215 	stw	r2,-56(fp)
   2c170:	e0bff217 	ldw	r2,-56(fp)
   2c174:	1000031e 	bne	r2,zero,2c184 <tcp_write+0x4f0>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p2);
   2c178:	e13ff817 	ldw	r4,-32(fp)
   2c17c:	00237600 	call	23760 <pbuf_free>
   2c180:	0000da06 	br	2c4ec <tcp_write+0x858>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for header pbuf\n"));
        goto memerr;
      }
      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(p/*header*/, p2/*data*/);
   2c184:	e13ff217 	ldw	r4,-56(fp)
   2c188:	e17ff817 	ldw	r5,-32(fp)
   2c18c:	00239500 	call	23950 <pbuf_cat>
    }

    queuelen += pbuf_clen(p);
   2c190:	e13ff217 	ldw	r4,-56(fp)
   2c194:	00238a40 	call	238a4 <pbuf_clen>
   2c198:	10c03fcc 	andi	r3,r2,255
   2c19c:	e0bfef8b 	ldhu	r2,-66(fp)
   2c1a0:	1885883a 	add	r2,r3,r2
   2c1a4:	e0bfef8d 	sth	r2,-66(fp)

    /* Now that there are more segments queued, we check again if the
     * length of the queue exceeds the configured maximum or
     * overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
   2c1a8:	e0bfef8b 	ldhu	r2,-66(fp)
   2c1ac:	10800268 	cmpgeui	r2,r2,9
   2c1b0:	1000031e 	bne	r2,zero,2c1c0 <tcp_write+0x52c>
   2c1b4:	e0bfef8b 	ldhu	r2,-66(fp)
   2c1b8:	10bfff70 	cmpltui	r2,r2,65533
   2c1bc:	1000031e 	bne	r2,zero,2c1cc <tcp_write+0x538>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      pbuf_free(p);
   2c1c0:	e13ff217 	ldw	r4,-56(fp)
   2c1c4:	00237600 	call	23760 <pbuf_free>
   2c1c8:	0000c806 	br	2c4ec <tcp_write+0x858>
      goto memerr;
    }

    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
   2c1cc:	e0bffc17 	ldw	r2,-16(fp)
   2c1d0:	10c01817 	ldw	r3,96(r2)
   2c1d4:	e0bfef0b 	ldhu	r2,-68(fp)
   2c1d8:	1885883a 	add	r2,r3,r2
   2c1dc:	e0fff443 	ldbu	r3,-47(fp)
   2c1e0:	d8c00015 	stw	r3,0(sp)
   2c1e4:	e13ffc17 	ldw	r4,-16(fp)
   2c1e8:	e17ff217 	ldw	r5,-56(fp)
   2c1ec:	000d883a 	mov	r6,zero
   2c1f0:	100f883a 	mov	r7,r2
   2c1f4:	002b6540 	call	2b654 <tcp_create_segment>
   2c1f8:	e0bfec15 	stw	r2,-80(fp)
   2c1fc:	e0bfec17 	ldw	r2,-80(fp)
   2c200:	1000ba26 	beq	r2,zero,2c4ec <tcp_write+0x858>
    }
#if TCP_OVERSIZE_DBGCHECK
    seg->oversize_left = oversize;
#endif /* TCP_OVERSIZE_DBGCHECK */
#if TCP_CHECKSUM_ON_COPY
    seg->chksum = chksum;
   2c204:	e0fffa8b 	ldhu	r3,-22(fp)
   2c208:	e0bfec17 	ldw	r2,-80(fp)
   2c20c:	10c0028d 	sth	r3,10(r2)
    seg->chksum_swapped = chksum_swapped;
   2c210:	e0fffb03 	ldbu	r3,-20(fp)
   2c214:	e0bfec17 	ldw	r2,-80(fp)
   2c218:	10c00305 	stb	r3,12(r2)
    seg->flags |= TF_SEG_DATA_CHECKSUMMED;
   2c21c:	e0bfec17 	ldw	r2,-80(fp)
   2c220:	10800343 	ldbu	r2,13(r2)
   2c224:	10800114 	ori	r2,r2,4
   2c228:	1007883a 	mov	r3,r2
   2c22c:	e0bfec17 	ldw	r2,-80(fp)
   2c230:	10c00345 	stb	r3,13(r2)
#endif /* TCP_CHECKSUM_ON_COPY */

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
   2c234:	e0bfee17 	ldw	r2,-72(fp)
   2c238:	1000031e 	bne	r2,zero,2c248 <tcp_write+0x5b4>
      queue = seg;
   2c23c:	e0bfec17 	ldw	r2,-80(fp)
   2c240:	e0bfee15 	stw	r2,-72(fp)
   2c244:	00000306 	br	2c254 <tcp_write+0x5c0>
    } else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
      prev_seg->next = seg;
   2c248:	e0bfed17 	ldw	r2,-76(fp)
   2c24c:	e0ffec17 	ldw	r3,-80(fp)
   2c250:	10c00015 	stw	r3,0(r2)
    }
    /* remember last segment of to-be-queued data for next iteration */
    prev_seg = seg;
   2c254:	e0bfec17 	ldw	r2,-80(fp)
   2c258:	e0bfed15 	stw	r2,-76(fp)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));

    pos += seglen;
   2c25c:	e0ffef0b 	ldhu	r3,-68(fp)
   2c260:	e0bff78b 	ldhu	r2,-34(fp)
   2c264:	1885883a 	add	r2,r3,r2
   2c268:	e0bfef0d 	sth	r2,-68(fp)
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
   2c26c:	e0ffef0b 	ldhu	r3,-68(fp)
   2c270:	e0bffe0b 	ldhu	r2,-8(fp)
   2c274:	18bf6636 	bltu	r3,r2,2c010 <tcp_write+0x37c>
  /*
   * Phase 1: If data has been added to the preallocated tail of
   * last_unsent, we update the length fields of the pbuf chain.
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
   2c278:	e0bff00b 	ldhu	r2,-64(fp)
   2c27c:	10003b26 	beq	r2,zero,2c36c <tcp_write+0x6d8>
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
   2c280:	e0bfeb17 	ldw	r2,-84(fp)
   2c284:	10800117 	ldw	r2,4(r2)
   2c288:	e0bff315 	stw	r2,-52(fp)
   2c28c:	00002e06 	br	2c348 <tcp_write+0x6b4>
      p->tot_len += oversize_used;
   2c290:	e0bff317 	ldw	r2,-52(fp)
   2c294:	10c0020b 	ldhu	r3,8(r2)
   2c298:	e0bff00b 	ldhu	r2,-64(fp)
   2c29c:	1885883a 	add	r2,r3,r2
   2c2a0:	1007883a 	mov	r3,r2
   2c2a4:	e0bff317 	ldw	r2,-52(fp)
   2c2a8:	10c0020d 	sth	r3,8(r2)
      if (p->next == NULL) {
   2c2ac:	e0bff317 	ldw	r2,-52(fp)
   2c2b0:	10800017 	ldw	r2,0(r2)
   2c2b4:	1000211e 	bne	r2,zero,2c33c <tcp_write+0x6a8>
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
   2c2b8:	e0bff317 	ldw	r2,-52(fp)
   2c2bc:	10c00117 	ldw	r3,4(r2)
   2c2c0:	e0bff317 	ldw	r2,-52(fp)
   2c2c4:	1080028b 	ldhu	r2,10(r2)
   2c2c8:	10bfffcc 	andi	r2,r2,65535
   2c2cc:	1887883a 	add	r3,r3,r2
   2c2d0:	e0bff00b 	ldhu	r2,-64(fp)
   2c2d4:	1809883a 	mov	r4,r3
   2c2d8:	e17ffd17 	ldw	r5,-12(fp)
   2c2dc:	100d883a 	mov	r6,r2
   2c2e0:	003e8240 	call	3e824 <lwip_chksum_copy>
   2c2e4:	113fffcc 	andi	r4,r2,65535
   2c2e8:	e17ff00b 	ldhu	r5,-64(fp)
   2c2ec:	e0bfeb17 	ldw	r2,-84(fp)
   2c2f0:	10c00284 	addi	r3,r2,10
   2c2f4:	e0bfeb17 	ldw	r2,-84(fp)
   2c2f8:	10800304 	addi	r2,r2,12
   2c2fc:	180d883a 	mov	r6,r3
   2c300:	100f883a 	mov	r7,r2
   2c304:	002babc0 	call	2babc <tcp_seg_add_chksum>
   2c308:	e0bfeb17 	ldw	r2,-84(fp)
   2c30c:	10800343 	ldbu	r2,13(r2)
   2c310:	10800114 	ori	r2,r2,4
   2c314:	1007883a 	mov	r3,r2
   2c318:	e0bfeb17 	ldw	r2,-84(fp)
   2c31c:	10c00345 	stb	r3,13(r2)
        p->len += oversize_used;
   2c320:	e0bff317 	ldw	r2,-52(fp)
   2c324:	10c0028b 	ldhu	r3,10(r2)
   2c328:	e0bff00b 	ldhu	r2,-64(fp)
   2c32c:	1885883a 	add	r2,r3,r2
   2c330:	1007883a 	mov	r3,r2
   2c334:	e0bff317 	ldw	r2,-52(fp)
   2c338:	10c0028d 	sth	r3,10(r2)
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
   2c33c:	e0bff317 	ldw	r2,-52(fp)
   2c340:	10800017 	ldw	r2,0(r2)
   2c344:	e0bff315 	stw	r2,-52(fp)
   2c348:	e0bff317 	ldw	r2,-52(fp)
   2c34c:	103fd01e 	bne	r2,zero,2c290 <tcp_write+0x5fc>
      if (p->next == NULL) {
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
        p->len += oversize_used;
      }
    }
    last_unsent->len += oversize_used;
   2c350:	e0bfeb17 	ldw	r2,-84(fp)
   2c354:	10c0020b 	ldhu	r3,8(r2)
   2c358:	e0bff00b 	ldhu	r2,-64(fp)
   2c35c:	1885883a 	add	r2,r3,r2
   2c360:	1007883a 	mov	r3,r2
   2c364:	e0bfeb17 	ldw	r2,-84(fp)
   2c368:	10c0020d 	sth	r3,8(r2)
    LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
                last_unsent->oversize_left >= oversize_used);
    last_unsent->oversize_left -= oversize_used;
#endif /* TCP_OVERSIZE_DBGCHECK */
  }
  pcb->unsent_oversize = oversize;
   2c36c:	e0fff90b 	ldhu	r3,-28(fp)
   2c370:	e0bffc17 	ldw	r2,-16(fp)
   2c374:	10c01b8d 	sth	r3,110(r2)
#endif /* TCP_OVERSIZE */

  /*
   * Phase 2: concat_p can be concatenated onto last_unsent->p
   */
  if (concat_p != NULL) {
   2c378:	e0bfea17 	ldw	r2,-88(fp)
   2c37c:	10001f26 	beq	r2,zero,2c3fc <tcp_write+0x768>
    LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
      (last_unsent != NULL));
    pbuf_cat(last_unsent->p, concat_p);
   2c380:	e0bfeb17 	ldw	r2,-84(fp)
   2c384:	10800117 	ldw	r2,4(r2)
   2c388:	1009883a 	mov	r4,r2
   2c38c:	e17fea17 	ldw	r5,-88(fp)
   2c390:	00239500 	call	23950 <pbuf_cat>
    last_unsent->len += concat_p->tot_len;
   2c394:	e0bfeb17 	ldw	r2,-84(fp)
   2c398:	10c0020b 	ldhu	r3,8(r2)
   2c39c:	e0bfea17 	ldw	r2,-88(fp)
   2c3a0:	1080020b 	ldhu	r2,8(r2)
   2c3a4:	1885883a 	add	r2,r3,r2
   2c3a8:	1007883a 	mov	r3,r2
   2c3ac:	e0bfeb17 	ldw	r2,-84(fp)
   2c3b0:	10c0020d 	sth	r3,8(r2)
#if TCP_CHECKSUM_ON_COPY
    if (concat_chksummed) {
   2c3b4:	e0bff08b 	ldhu	r2,-62(fp)
   2c3b8:	10001026 	beq	r2,zero,2c3fc <tcp_write+0x768>
      tcp_seg_add_chksum(concat_chksum, concat_chksummed, &last_unsent->chksum,
   2c3bc:	e0bff98b 	ldhu	r2,-26(fp)
   2c3c0:	113fffcc 	andi	r4,r2,65535
   2c3c4:	e17ff08b 	ldhu	r5,-62(fp)
   2c3c8:	e0bfeb17 	ldw	r2,-84(fp)
   2c3cc:	10c00284 	addi	r3,r2,10
   2c3d0:	e0bfeb17 	ldw	r2,-84(fp)
   2c3d4:	10800304 	addi	r2,r2,12
   2c3d8:	180d883a 	mov	r6,r3
   2c3dc:	100f883a 	mov	r7,r2
   2c3e0:	002babc0 	call	2babc <tcp_seg_add_chksum>
        &last_unsent->chksum_swapped);
      last_unsent->flags |= TF_SEG_DATA_CHECKSUMMED;
   2c3e4:	e0bfeb17 	ldw	r2,-84(fp)
   2c3e8:	10800343 	ldbu	r2,13(r2)
   2c3ec:	10800114 	ori	r2,r2,4
   2c3f0:	1007883a 	mov	r3,r2
   2c3f4:	e0bfeb17 	ldw	r2,-84(fp)
   2c3f8:	10c00345 	stb	r3,13(r2)

  /*
   * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
   * is harmless
   */
  if (last_unsent == NULL) {
   2c3fc:	e0bfeb17 	ldw	r2,-84(fp)
   2c400:	1000041e 	bne	r2,zero,2c414 <tcp_write+0x780>
    pcb->unsent = queue;
   2c404:	e0bffc17 	ldw	r2,-16(fp)
   2c408:	e0ffee17 	ldw	r3,-72(fp)
   2c40c:	10c01c15 	stw	r3,112(r2)
   2c410:	00000306 	br	2c420 <tcp_write+0x78c>
  } else {
    last_unsent->next = queue;
   2c414:	e0bfeb17 	ldw	r2,-84(fp)
   2c418:	e0ffee17 	ldw	r3,-72(fp)
   2c41c:	10c00015 	stw	r3,0(r2)
  }

  /*
   * Finally update the pcb state.
   */
  pcb->snd_lbb += len;
   2c420:	e0bffc17 	ldw	r2,-16(fp)
   2c424:	10c01817 	ldw	r3,96(r2)
   2c428:	e0bffe0b 	ldhu	r2,-8(fp)
   2c42c:	1887883a 	add	r3,r3,r2
   2c430:	e0bffc17 	ldw	r2,-16(fp)
   2c434:	10c01815 	stw	r3,96(r2)
  pcb->snd_buf -= len;
   2c438:	e0bffc17 	ldw	r2,-16(fp)
   2c43c:	10c01a8b 	ldhu	r3,106(r2)
   2c440:	e0bffe0b 	ldhu	r2,-8(fp)
   2c444:	1885c83a 	sub	r2,r3,r2
   2c448:	1007883a 	mov	r3,r2
   2c44c:	e0bffc17 	ldw	r2,-16(fp)
   2c450:	10c01a8d 	sth	r3,106(r2)
  pcb->snd_queuelen = queuelen;
   2c454:	e0bffc17 	ldw	r2,-16(fp)
   2c458:	e0ffef8b 	ldhu	r3,-66(fp)
   2c45c:	10c01b0d 	sth	r3,108(r2)
    LWIP_ASSERT("tcp_write: valid queue length",
                pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued. */
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
   2c460:	e0bfec17 	ldw	r2,-80(fp)
   2c464:	10001c26 	beq	r2,zero,2c4d8 <tcp_write+0x844>
   2c468:	e0bfec17 	ldw	r2,-80(fp)
   2c46c:	10800417 	ldw	r2,16(r2)
   2c470:	10001926 	beq	r2,zero,2c4d8 <tcp_write+0x844>
   2c474:	e0bfff03 	ldbu	r2,-4(fp)
   2c478:	1080008c 	andi	r2,r2,2
   2c47c:	1000161e 	bne	r2,zero,2c4d8 <tcp_write+0x844>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
   2c480:	e0bfec17 	ldw	r2,-80(fp)
   2c484:	10800417 	ldw	r2,16(r2)
   2c488:	e0ffec17 	ldw	r3,-80(fp)
   2c48c:	18c00417 	ldw	r3,16(r3)
   2c490:	19000303 	ldbu	r4,12(r3)
   2c494:	18c00343 	ldbu	r3,13(r3)
   2c498:	1806923a 	slli	r3,r3,8
   2c49c:	1906b03a 	or	r3,r3,r4
   2c4a0:	18c20014 	ori	r3,r3,2048
   2c4a4:	193fffcc 	andi	r4,r3,65535
   2c4a8:	21003fcc 	andi	r4,r4,255
   2c4ac:	11400303 	ldbu	r5,12(r2)
   2c4b0:	280a703a 	and	r5,r5,zero
   2c4b4:	2908b03a 	or	r4,r5,r4
   2c4b8:	11000305 	stb	r4,12(r2)
   2c4bc:	18ffffcc 	andi	r3,r3,65535
   2c4c0:	1806d23a 	srli	r3,r3,8
   2c4c4:	18ffffcc 	andi	r3,r3,65535
   2c4c8:	11000343 	ldbu	r4,13(r2)
   2c4cc:	2008703a 	and	r4,r4,zero
   2c4d0:	20c6b03a 	or	r3,r4,r3
   2c4d4:	10c00345 	stb	r3,13(r2)
  }

  return ERR_OK;
   2c4d8:	0005883a 	mov	r2,zero
   2c4dc:	00001a06 	br	2c548 <tcp_write+0x8b4>
        /* Data is copied */
        if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
          LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,
                      ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n",
                       seglen));
          goto memerr;
   2c4e0:	0001883a 	nop
   2c4e4:	00000106 	br	2c4ec <tcp_write+0x858>
      } else {
        /* Data is not copied */
        if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
          LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,
                      ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
          goto memerr;
   2c4e8:	0001883a 	nop
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
   2c4ec:	e0bffc17 	ldw	r2,-16(fp)
   2c4f0:	10c00883 	ldbu	r3,34(r2)
   2c4f4:	00bfe004 	movi	r2,-128
   2c4f8:	1884b03a 	or	r2,r3,r2
   2c4fc:	1007883a 	mov	r3,r2
   2c500:	e0bffc17 	ldw	r2,-16(fp)
   2c504:	10c00885 	stb	r3,34(r2)
  TCP_STATS_INC(tcp.memerr);
   2c508:	008001f4 	movhi	r2,7
   2c50c:	10ac6e04 	addi	r2,r2,-20040
   2c510:	10804e17 	ldw	r2,312(r2)
   2c514:	10c00044 	addi	r3,r2,1
   2c518:	008001f4 	movhi	r2,7
   2c51c:	10ac6e04 	addi	r2,r2,-20040
   2c520:	10c04e15 	stw	r3,312(r2)

  if (concat_p != NULL) {
   2c524:	e0bfea17 	ldw	r2,-88(fp)
   2c528:	10000226 	beq	r2,zero,2c534 <tcp_write+0x8a0>
    pbuf_free(concat_p);
   2c52c:	e13fea17 	ldw	r4,-88(fp)
   2c530:	00237600 	call	23760 <pbuf_free>
  }
  if (queue != NULL) {
   2c534:	e0bfee17 	ldw	r2,-72(fp)
   2c538:	10000226 	beq	r2,zero,2c544 <tcp_write+0x8b0>
    tcp_segs_free(queue);
   2c53c:	e13fee17 	ldw	r4,-72(fp)
   2c540:	00264a80 	call	264a8 <tcp_segs_free>
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
   2c544:	00bfffc4 	movi	r2,-1
}
   2c548:	e037883a 	mov	sp,fp
   2c54c:	dfc00117 	ldw	ra,4(sp)
   2c550:	df000017 	ldw	fp,0(sp)
   2c554:	dec00204 	addi	sp,sp,8
   2c558:	f800283a 	ret

0002c55c <tcp_enqueue_flags>:
 * @param optdata pointer to TCP options, or NULL.
 * @param optlen length of TCP options in bytes.
 */
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
   2c55c:	defff504 	addi	sp,sp,-44
   2c560:	dfc00a15 	stw	ra,40(sp)
   2c564:	df000915 	stw	fp,36(sp)
   2c568:	dc000815 	stw	r16,32(sp)
   2c56c:	df000804 	addi	fp,sp,32
   2c570:	e13ffe15 	stw	r4,-8(fp)
   2c574:	2805883a 	mov	r2,r5
   2c578:	e0bfff05 	stb	r2,-4(fp)
  struct pbuf *p;
  struct tcp_seg *seg;
  u8_t optflags = 0;
   2c57c:	e03ff905 	stb	zero,-28(fp)
  u8_t optlen = 0;
   2c580:	e03ffb05 	stb	zero,-20(fp)

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
              (flags & (TCP_SYN | TCP_FIN)) != 0);

  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
   2c584:	e0bffe17 	ldw	r2,-8(fp)
   2c588:	10801b0b 	ldhu	r2,108(r2)
   2c58c:	10bfffcc 	andi	r2,r2,65535
   2c590:	10800228 	cmpgeui	r2,r2,8
   2c594:	1000051e 	bne	r2,zero,2c5ac <tcp_enqueue_flags+0x50>
   2c598:	e0bffe17 	ldw	r2,-8(fp)
   2c59c:	10801b0b 	ldhu	r2,108(r2)
   2c5a0:	10bfffcc 	andi	r2,r2,65535
   2c5a4:	10bfff70 	cmpltui	r2,r2,65533
   2c5a8:	1000101e 	bne	r2,zero,2c5ec <tcp_enqueue_flags+0x90>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: too long queue %"U16_F" (max %"U16_F")\n",
                                       pcb->snd_queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
   2c5ac:	008001f4 	movhi	r2,7
   2c5b0:	10ac6e04 	addi	r2,r2,-20040
   2c5b4:	10804e17 	ldw	r2,312(r2)
   2c5b8:	10c00044 	addi	r3,r2,1
   2c5bc:	008001f4 	movhi	r2,7
   2c5c0:	10ac6e04 	addi	r2,r2,-20040
   2c5c4:	10c04e15 	stw	r3,312(r2)
    pcb->flags |= TF_NAGLEMEMERR;
   2c5c8:	e0bffe17 	ldw	r2,-8(fp)
   2c5cc:	10c00883 	ldbu	r3,34(r2)
   2c5d0:	00bfe004 	movi	r2,-128
   2c5d4:	1884b03a 	or	r2,r3,r2
   2c5d8:	1007883a 	mov	r3,r2
   2c5dc:	e0bffe17 	ldw	r2,-8(fp)
   2c5e0:	10c00885 	stb	r3,34(r2)
    return ERR_MEM;
   2c5e4:	00bfffc4 	movi	r2,-1
   2c5e8:	00009106 	br	2c830 <tcp_enqueue_flags+0x2d4>
  }

  if (flags & TCP_SYN) {
   2c5ec:	e0bfff03 	ldbu	r2,-4(fp)
   2c5f0:	1080008c 	andi	r2,r2,2
   2c5f4:	10000226 	beq	r2,zero,2c600 <tcp_enqueue_flags+0xa4>
    optflags = TF_SEG_OPTS_MSS;
   2c5f8:	00800044 	movi	r2,1
   2c5fc:	e0bff905 	stb	r2,-28(fp)
#if LWIP_TCP_TIMESTAMPS
  if ((pcb->flags & TF_TIMESTAMP)) {
    optflags |= TF_SEG_OPTS_TS;
  }
#endif /* LWIP_TCP_TIMESTAMPS */
  optlen = LWIP_TCP_OPT_LENGTH(optflags);
   2c600:	e0bff903 	ldbu	r2,-28(fp)
   2c604:	1080004c 	andi	r2,r2,1
   2c608:	10000226 	beq	r2,zero,2c614 <tcp_enqueue_flags+0xb8>
   2c60c:	00c00104 	movi	r3,4
   2c610:	00000106 	br	2c618 <tcp_enqueue_flags+0xbc>
   2c614:	0007883a 	mov	r3,zero
   2c618:	e0bff903 	ldbu	r2,-28(fp)
   2c61c:	1080008c 	andi	r2,r2,2
   2c620:	10000226 	beq	r2,zero,2c62c <tcp_enqueue_flags+0xd0>
   2c624:	00800304 	movi	r2,12
   2c628:	00000106 	br	2c630 <tcp_enqueue_flags+0xd4>
   2c62c:	0005883a 	mov	r2,zero
   2c630:	1885883a 	add	r2,r3,r2
   2c634:	e0bffb05 	stb	r2,-20(fp)

  /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
   * We need one available snd_buf byte to do that.
   * This means we can't send FIN while snd_buf==0. A better fix would be to
   * not include SYN and FIN sequence numbers in the snd_buf count. */
  if (pcb->snd_buf == 0) {
   2c638:	e0bffe17 	ldw	r2,-8(fp)
   2c63c:	10801a8b 	ldhu	r2,106(r2)
   2c640:	10bfffcc 	andi	r2,r2,65535
   2c644:	1000091e 	bne	r2,zero,2c66c <tcp_enqueue_flags+0x110>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: no send buffer available\n"));
    TCP_STATS_INC(tcp.memerr);
   2c648:	008001f4 	movhi	r2,7
   2c64c:	10ac6e04 	addi	r2,r2,-20040
   2c650:	10804e17 	ldw	r2,312(r2)
   2c654:	10c00044 	addi	r3,r2,1
   2c658:	008001f4 	movhi	r2,7
   2c65c:	10ac6e04 	addi	r2,r2,-20040
   2c660:	10c04e15 	stw	r3,312(r2)
    return ERR_MEM;
   2c664:	00bfffc4 	movi	r2,-1
   2c668:	00007106 	br	2c830 <tcp_enqueue_flags+0x2d4>
  }

  /* Allocate pbuf with room for TCP header + options */
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
   2c66c:	e0bffb03 	ldbu	r2,-20(fp)
   2c670:	0009883a 	mov	r4,zero
   2c674:	100b883a 	mov	r5,r2
   2c678:	000d883a 	mov	r6,zero
   2c67c:	0022fa00 	call	22fa0 <pbuf_alloc>
   2c680:	e0bffc15 	stw	r2,-16(fp)
   2c684:	e0bffc17 	ldw	r2,-16(fp)
   2c688:	1000101e 	bne	r2,zero,2c6cc <tcp_enqueue_flags+0x170>
    pcb->flags |= TF_NAGLEMEMERR;
   2c68c:	e0bffe17 	ldw	r2,-8(fp)
   2c690:	10c00883 	ldbu	r3,34(r2)
   2c694:	00bfe004 	movi	r2,-128
   2c698:	1884b03a 	or	r2,r3,r2
   2c69c:	1007883a 	mov	r3,r2
   2c6a0:	e0bffe17 	ldw	r2,-8(fp)
   2c6a4:	10c00885 	stb	r3,34(r2)
    TCP_STATS_INC(tcp.memerr);
   2c6a8:	008001f4 	movhi	r2,7
   2c6ac:	10ac6e04 	addi	r2,r2,-20040
   2c6b0:	10804e17 	ldw	r2,312(r2)
   2c6b4:	10c00044 	addi	r3,r2,1
   2c6b8:	008001f4 	movhi	r2,7
   2c6bc:	10ac6e04 	addi	r2,r2,-20040
   2c6c0:	10c04e15 	stw	r3,312(r2)
    return ERR_MEM;
   2c6c4:	00bfffc4 	movi	r2,-1
   2c6c8:	00005906 	br	2c830 <tcp_enqueue_flags+0x2d4>
  }
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
   2c6cc:	e0ffff03 	ldbu	r3,-4(fp)
   2c6d0:	e0bffe17 	ldw	r2,-8(fp)
   2c6d4:	10801817 	ldw	r2,96(r2)
   2c6d8:	e13ff903 	ldbu	r4,-28(fp)
   2c6dc:	d9000015 	stw	r4,0(sp)
   2c6e0:	e13ffe17 	ldw	r4,-8(fp)
   2c6e4:	e17ffc17 	ldw	r5,-16(fp)
   2c6e8:	180d883a 	mov	r6,r3
   2c6ec:	100f883a 	mov	r7,r2
   2c6f0:	002b6540 	call	2b654 <tcp_create_segment>
   2c6f4:	e0bffd15 	stw	r2,-12(fp)
   2c6f8:	e0bffd17 	ldw	r2,-12(fp)
   2c6fc:	1000101e 	bne	r2,zero,2c740 <tcp_enqueue_flags+0x1e4>
    pcb->flags |= TF_NAGLEMEMERR;
   2c700:	e0bffe17 	ldw	r2,-8(fp)
   2c704:	10c00883 	ldbu	r3,34(r2)
   2c708:	00bfe004 	movi	r2,-128
   2c70c:	1884b03a 	or	r2,r3,r2
   2c710:	1007883a 	mov	r3,r2
   2c714:	e0bffe17 	ldw	r2,-8(fp)
   2c718:	10c00885 	stb	r3,34(r2)
    TCP_STATS_INC(tcp.memerr);
   2c71c:	008001f4 	movhi	r2,7
   2c720:	10ac6e04 	addi	r2,r2,-20040
   2c724:	10804e17 	ldw	r2,312(r2)
   2c728:	10c00044 	addi	r3,r2,1
   2c72c:	008001f4 	movhi	r2,7
   2c730:	10ac6e04 	addi	r2,r2,-20040
   2c734:	10c04e15 	stw	r3,312(r2)
    return ERR_MEM;
   2c738:	00bfffc4 	movi	r2,-1
   2c73c:	00003c06 	br	2c830 <tcp_enqueue_flags+0x2d4>
               ntohl(seg->tcphdr->seqno),
               ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
   2c740:	e0bffe17 	ldw	r2,-8(fp)
   2c744:	10801c17 	ldw	r2,112(r2)
   2c748:	1000041e 	bne	r2,zero,2c75c <tcp_enqueue_flags+0x200>
    pcb->unsent = seg;
   2c74c:	e0bffe17 	ldw	r2,-8(fp)
   2c750:	e0fffd17 	ldw	r3,-12(fp)
   2c754:	10c01c15 	stw	r3,112(r2)
   2c758:	00000d06 	br	2c790 <tcp_enqueue_flags+0x234>
  } else {
    struct tcp_seg *useg;
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
   2c75c:	e0bffe17 	ldw	r2,-8(fp)
   2c760:	10801c17 	ldw	r2,112(r2)
   2c764:	e0bffa15 	stw	r2,-24(fp)
   2c768:	00000306 	br	2c778 <tcp_enqueue_flags+0x21c>
   2c76c:	e0bffa17 	ldw	r2,-24(fp)
   2c770:	10800017 	ldw	r2,0(r2)
   2c774:	e0bffa15 	stw	r2,-24(fp)
   2c778:	e0bffa17 	ldw	r2,-24(fp)
   2c77c:	10800017 	ldw	r2,0(r2)
   2c780:	103ffa1e 	bne	r2,zero,2c76c <tcp_enqueue_flags+0x210>
    useg->next = seg;
   2c784:	e0bffa17 	ldw	r2,-24(fp)
   2c788:	e0fffd17 	ldw	r3,-12(fp)
   2c78c:	10c00015 	stw	r3,0(r2)
  }
#if TCP_OVERSIZE
  /* The new unsent tail has no space */
  pcb->unsent_oversize = 0;
   2c790:	e0bffe17 	ldw	r2,-8(fp)
   2c794:	10001b8d 	sth	zero,110(r2)
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
   2c798:	e0bfff03 	ldbu	r2,-4(fp)
   2c79c:	1080008c 	andi	r2,r2,2
   2c7a0:	1000031e 	bne	r2,zero,2c7b0 <tcp_enqueue_flags+0x254>
   2c7a4:	e0bfff03 	ldbu	r2,-4(fp)
   2c7a8:	1080004c 	andi	r2,r2,1
   2c7ac:	10000b26 	beq	r2,zero,2c7dc <tcp_enqueue_flags+0x280>
    pcb->snd_lbb++;
   2c7b0:	e0bffe17 	ldw	r2,-8(fp)
   2c7b4:	10801817 	ldw	r2,96(r2)
   2c7b8:	10c00044 	addi	r3,r2,1
   2c7bc:	e0bffe17 	ldw	r2,-8(fp)
   2c7c0:	10c01815 	stw	r3,96(r2)
    /* optlen does not influence snd_buf */
    pcb->snd_buf--;
   2c7c4:	e0bffe17 	ldw	r2,-8(fp)
   2c7c8:	10801a8b 	ldhu	r2,106(r2)
   2c7cc:	10bfffc4 	addi	r2,r2,-1
   2c7d0:	1007883a 	mov	r3,r2
   2c7d4:	e0bffe17 	ldw	r2,-8(fp)
   2c7d8:	10c01a8d 	sth	r3,106(r2)
  }
  if (flags & TCP_FIN) {
   2c7dc:	e0bfff03 	ldbu	r2,-4(fp)
   2c7e0:	1080004c 	andi	r2,r2,1
   2c7e4:	10000626 	beq	r2,zero,2c800 <tcp_enqueue_flags+0x2a4>
    pcb->flags |= TF_FIN;
   2c7e8:	e0bffe17 	ldw	r2,-8(fp)
   2c7ec:	10800883 	ldbu	r2,34(r2)
   2c7f0:	10800814 	ori	r2,r2,32
   2c7f4:	1007883a 	mov	r3,r2
   2c7f8:	e0bffe17 	ldw	r2,-8(fp)
   2c7fc:	10c00885 	stb	r3,34(r2)
  }

  /* update number of segments on the queues */
  pcb->snd_queuelen += pbuf_clen(seg->p);
   2c800:	e0bffe17 	ldw	r2,-8(fp)
   2c804:	14001b0b 	ldhu	r16,108(r2)
   2c808:	e0bffd17 	ldw	r2,-12(fp)
   2c80c:	10800117 	ldw	r2,4(r2)
   2c810:	1009883a 	mov	r4,r2
   2c814:	00238a40 	call	238a4 <pbuf_clen>
   2c818:	10803fcc 	andi	r2,r2,255
   2c81c:	8085883a 	add	r2,r16,r2
   2c820:	1007883a 	mov	r3,r2
   2c824:	e0bffe17 	ldw	r2,-8(fp)
   2c828:	10c01b0d 	sth	r3,108(r2)
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
   2c82c:	0005883a 	mov	r2,zero
}
   2c830:	e037883a 	mov	sp,fp
   2c834:	dfc00217 	ldw	ra,8(sp)
   2c838:	df000117 	ldw	fp,4(sp)
   2c83c:	dc000017 	ldw	r16,0(sp)
   2c840:	dec00304 	addi	sp,sp,12
   2c844:	f800283a 	ret

0002c848 <tcp_send_empty_ack>:
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
   2c848:	defff704 	addi	sp,sp,-36
   2c84c:	dfc00815 	stw	ra,32(sp)
   2c850:	df000715 	stw	fp,28(sp)
   2c854:	df000704 	addi	fp,sp,28
   2c858:	e13fff15 	stw	r4,-4(fp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  u8_t optlen = 0;
   2c85c:	e03ffc05 	stb	zero,-16(fp)
  if (pcb->flags & TF_TIMESTAMP) {
    optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
  }
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
   2c860:	e0fffc03 	ldbu	r3,-16(fp)
   2c864:	e0bfff17 	ldw	r2,-4(fp)
   2c868:	10801517 	ldw	r2,84(r2)
   2c86c:	1008d63a 	srli	r4,r2,24
   2c870:	e0bfff17 	ldw	r2,-4(fp)
   2c874:	10801517 	ldw	r2,84(r2)
   2c878:	1004d23a 	srli	r2,r2,8
   2c87c:	10bfc00c 	andi	r2,r2,65280
   2c880:	2088b03a 	or	r4,r4,r2
   2c884:	e0bfff17 	ldw	r2,-4(fp)
   2c888:	10801517 	ldw	r2,84(r2)
   2c88c:	10bfc00c 	andi	r2,r2,65280
   2c890:	1004923a 	slli	r2,r2,8
   2c894:	2088b03a 	or	r4,r4,r2
   2c898:	e0bfff17 	ldw	r2,-4(fp)
   2c89c:	10801517 	ldw	r2,84(r2)
   2c8a0:	1004963a 	slli	r2,r2,24
   2c8a4:	2084b03a 	or	r2,r4,r2
   2c8a8:	e13fff17 	ldw	r4,-4(fp)
   2c8ac:	180b883a 	mov	r5,r3
   2c8b0:	000d883a 	mov	r6,zero
   2c8b4:	100f883a 	mov	r7,r2
   2c8b8:	002b1b80 	call	2b1b8 <tcp_output_alloc_header>
   2c8bc:	e0bffd15 	stw	r2,-12(fp)
  if (p == NULL) {
   2c8c0:	e0bffd17 	ldw	r2,-12(fp)
   2c8c4:	1000021e 	bne	r2,zero,2c8d0 <tcp_send_empty_ack+0x88>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
   2c8c8:	00bfff84 	movi	r2,-2
   2c8cc:	00003b06 	br	2c9bc <tcp_send_empty_ack+0x174>
  }
  tcphdr = (struct tcp_hdr *)p->payload;
   2c8d0:	e0bffd17 	ldw	r2,-12(fp)
   2c8d4:	10800117 	ldw	r2,4(r2)
   2c8d8:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  /* remove ACK flags from the PCB, as we send an empty ACK now */
  pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
   2c8dc:	e0bfff17 	ldw	r2,-4(fp)
   2c8e0:	10c00883 	ldbu	r3,34(r2)
   2c8e4:	00bfff04 	movi	r2,-4
   2c8e8:	1884703a 	and	r2,r3,r2
   2c8ec:	1007883a 	mov	r3,r2
   2c8f0:	e0bfff17 	ldw	r2,-4(fp)
   2c8f4:	10c00885 	stb	r3,34(r2)
    tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
  }
#endif 

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
   2c8f8:	e0ffff17 	ldw	r3,-4(fp)
   2c8fc:	e0bfff17 	ldw	r2,-4(fp)
   2c900:	10800104 	addi	r2,r2,4
        IP_PROTO_TCP, p->tot_len);
   2c904:	e13ffd17 	ldw	r4,-12(fp)
   2c908:	2100020b 	ldhu	r4,8(r4)
    tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
  }
#endif 

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
   2c90c:	213fffcc 	andi	r4,r4,65535
   2c910:	d9000015 	stw	r4,0(sp)
   2c914:	e13ffd17 	ldw	r4,-12(fp)
   2c918:	180b883a 	mov	r5,r3
   2c91c:	100d883a 	mov	r6,r2
   2c920:	01c00184 	movi	r7,6
   2c924:	003e2ac0 	call	3e2ac <inet_chksum_pseudo>
   2c928:	1007883a 	mov	r3,r2
   2c92c:	e0bffe17 	ldw	r2,-8(fp)
   2c930:	193fffcc 	andi	r4,r3,65535
   2c934:	21003fcc 	andi	r4,r4,255
   2c938:	11400403 	ldbu	r5,16(r2)
   2c93c:	280a703a 	and	r5,r5,zero
   2c940:	2908b03a 	or	r4,r5,r4
   2c944:	11000405 	stb	r4,16(r2)
   2c948:	18ffffcc 	andi	r3,r3,65535
   2c94c:	1806d23a 	srli	r3,r3,8
   2c950:	18ffffcc 	andi	r3,r3,65535
   2c954:	11000443 	ldbu	r4,17(r2)
   2c958:	2008703a 	and	r4,r4,zero
   2c95c:	20c6b03a 	or	r3,r4,r3
   2c960:	10c00445 	stb	r3,17(r2)
        IP_PROTO_TCP, p->tot_len);
#endif
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
   2c964:	e17fff17 	ldw	r5,-4(fp)
   2c968:	e0bfff17 	ldw	r2,-4(fp)
   2c96c:	10c00104 	addi	r3,r2,4
   2c970:	e0bfff17 	ldw	r2,-4(fp)
   2c974:	10800283 	ldbu	r2,10(r2)
   2c978:	10803fcc 	andi	r2,r2,255
   2c97c:	e13fff17 	ldw	r4,-4(fp)
   2c980:	21000243 	ldbu	r4,9(r4)
   2c984:	21803fcc 	andi	r6,r4,255
   2c988:	e13fff17 	ldw	r4,-4(fp)
   2c98c:	210002c4 	addi	r4,r4,11
   2c990:	d9800015 	stw	r6,0(sp)
   2c994:	01800184 	movi	r6,6
   2c998:	d9800115 	stw	r6,4(sp)
   2c99c:	d9000215 	stw	r4,8(sp)
   2c9a0:	e13ffd17 	ldw	r4,-12(fp)
   2c9a4:	180d883a 	mov	r6,r3
   2c9a8:	100f883a 	mov	r7,r2
   2c9ac:	001f9700 	call	1f970 <ip_output_hinted>
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
  pbuf_free(p);
   2c9b0:	e13ffd17 	ldw	r4,-12(fp)
   2c9b4:	00237600 	call	23760 <pbuf_free>

  return ERR_OK;
   2c9b8:	0005883a 	mov	r2,zero
}
   2c9bc:	e037883a 	mov	sp,fp
   2c9c0:	dfc00117 	ldw	ra,4(sp)
   2c9c4:	df000017 	ldw	fp,0(sp)
   2c9c8:	dec00204 	addi	sp,sp,8
   2c9cc:	f800283a 	ret

0002c9d0 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
   2c9d0:	defff804 	addi	sp,sp,-32
   2c9d4:	dfc00715 	stw	ra,28(sp)
   2c9d8:	df000615 	stw	fp,24(sp)
   2c9dc:	df000604 	addi	fp,sp,24
   2c9e0:	e13fff15 	stw	r4,-4(fp)

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
   2c9e4:	00800134 	movhi	r2,4
   2c9e8:	109eff04 	addi	r2,r2,31740
   2c9ec:	10c00017 	ldw	r3,0(r2)
   2c9f0:	e0bfff17 	ldw	r2,-4(fp)
   2c9f4:	1880021e 	bne	r3,r2,2ca00 <tcp_output+0x30>
    return ERR_OK;
   2c9f8:	0005883a 	mov	r2,zero
   2c9fc:	00029606 	br	2d458 <tcp_output+0xa88>
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
   2ca00:	e0bfff17 	ldw	r2,-4(fp)
   2ca04:	1080140b 	ldhu	r2,80(r2)
   2ca08:	e0ffff17 	ldw	r3,-4(fp)
   2ca0c:	18c0190b 	ldhu	r3,100(r3)
   2ca10:	113fffcc 	andi	r4,r2,65535
   2ca14:	197fffcc 	andi	r5,r3,65535
   2ca18:	2900012e 	bgeu	r5,r4,2ca20 <tcp_output+0x50>
   2ca1c:	1805883a 	mov	r2,r3
   2ca20:	10bfffcc 	andi	r2,r2,65535
   2ca24:	e0bffd15 	stw	r2,-12(fp)

  seg = pcb->unsent;
   2ca28:	e0bfff17 	ldw	r2,-4(fp)
   2ca2c:	10801c17 	ldw	r2,112(r2)
   2ca30:	e0bffa15 	stw	r2,-24(fp)
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
   2ca34:	e0bfff17 	ldw	r2,-4(fp)
   2ca38:	10800883 	ldbu	r2,34(r2)
   2ca3c:	10803fcc 	andi	r2,r2,255
   2ca40:	1080008c 	andi	r2,r2,2
   2ca44:	10004726 	beq	r2,zero,2cb64 <tcp_output+0x194>
   2ca48:	e0bffa17 	ldw	r2,-24(fp)
   2ca4c:	10004226 	beq	r2,zero,2cb58 <tcp_output+0x188>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
   2ca50:	e0bffa17 	ldw	r2,-24(fp)
   2ca54:	10800417 	ldw	r2,16(r2)
   2ca58:	10c00103 	ldbu	r3,4(r2)
   2ca5c:	11000143 	ldbu	r4,5(r2)
   2ca60:	2008923a 	slli	r4,r4,8
   2ca64:	20c6b03a 	or	r3,r4,r3
   2ca68:	11000183 	ldbu	r4,6(r2)
   2ca6c:	2008943a 	slli	r4,r4,16
   2ca70:	20c6b03a 	or	r3,r4,r3
   2ca74:	108001c3 	ldbu	r2,7(r2)
   2ca78:	1004963a 	slli	r2,r2,24
   2ca7c:	10c4b03a 	or	r2,r2,r3
   2ca80:	1006d63a 	srli	r3,r2,24
   2ca84:	e0bffa17 	ldw	r2,-24(fp)
   2ca88:	10800417 	ldw	r2,16(r2)
   2ca8c:	11000103 	ldbu	r4,4(r2)
   2ca90:	11400143 	ldbu	r5,5(r2)
   2ca94:	280a923a 	slli	r5,r5,8
   2ca98:	2908b03a 	or	r4,r5,r4
   2ca9c:	11400183 	ldbu	r5,6(r2)
   2caa0:	280a943a 	slli	r5,r5,16
   2caa4:	2908b03a 	or	r4,r5,r4
   2caa8:	108001c3 	ldbu	r2,7(r2)
   2caac:	1004963a 	slli	r2,r2,24
   2cab0:	1104b03a 	or	r2,r2,r4
   2cab4:	1004d23a 	srli	r2,r2,8
   2cab8:	10bfc00c 	andi	r2,r2,65280
   2cabc:	1886b03a 	or	r3,r3,r2
   2cac0:	e0bffa17 	ldw	r2,-24(fp)
   2cac4:	10800417 	ldw	r2,16(r2)
   2cac8:	11000103 	ldbu	r4,4(r2)
   2cacc:	11400143 	ldbu	r5,5(r2)
   2cad0:	280a923a 	slli	r5,r5,8
   2cad4:	2908b03a 	or	r4,r5,r4
   2cad8:	11400183 	ldbu	r5,6(r2)
   2cadc:	280a943a 	slli	r5,r5,16
   2cae0:	2908b03a 	or	r4,r5,r4
   2cae4:	108001c3 	ldbu	r2,7(r2)
   2cae8:	1004963a 	slli	r2,r2,24
   2caec:	1104b03a 	or	r2,r2,r4
   2caf0:	10bfc00c 	andi	r2,r2,65280
   2caf4:	1004923a 	slli	r2,r2,8
   2caf8:	1886b03a 	or	r3,r3,r2
   2cafc:	e0bffa17 	ldw	r2,-24(fp)
   2cb00:	10800417 	ldw	r2,16(r2)
   2cb04:	11000103 	ldbu	r4,4(r2)
   2cb08:	11400143 	ldbu	r5,5(r2)
   2cb0c:	280a923a 	slli	r5,r5,8
   2cb10:	2908b03a 	or	r4,r5,r4
   2cb14:	11400183 	ldbu	r5,6(r2)
   2cb18:	280a943a 	slli	r5,r5,16
   2cb1c:	2908b03a 	or	r4,r5,r4
   2cb20:	108001c3 	ldbu	r2,7(r2)
   2cb24:	1004963a 	slli	r2,r2,24
   2cb28:	1104b03a 	or	r2,r2,r4
   2cb2c:	1004963a 	slli	r2,r2,24
   2cb30:	1886b03a 	or	r3,r3,r2
   2cb34:	e0bfff17 	ldw	r2,-4(fp)
   2cb38:	10801317 	ldw	r2,76(r2)
   2cb3c:	1887c83a 	sub	r3,r3,r2
   2cb40:	e0bffa17 	ldw	r2,-24(fp)
   2cb44:	1080020b 	ldhu	r2,8(r2)
   2cb48:	10bfffcc 	andi	r2,r2,65535
   2cb4c:	1885883a 	add	r2,r3,r2
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
   2cb50:	e0fffd17 	ldw	r3,-12(fp)
   2cb54:	1880032e 	bgeu	r3,r2,2cb64 <tcp_output+0x194>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
     return tcp_send_empty_ack(pcb);
   2cb58:	e13fff17 	ldw	r4,-4(fp)
   2cb5c:	002c8480 	call	2c848 <tcp_send_empty_ack>
   2cb60:	00023d06 	br	2d458 <tcp_output+0xa88>
  }

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
   2cb64:	e0bfff17 	ldw	r2,-4(fp)
   2cb68:	10801d17 	ldw	r2,116(r2)
   2cb6c:	e0bffb15 	stw	r2,-20(fp)
  if (useg != NULL) {
   2cb70:	e0bffb17 	ldw	r2,-20(fp)
   2cb74:	1001e626 	beq	r2,zero,2d310 <tcp_output+0x940>
    for (; useg->next != NULL; useg = useg->next);
   2cb78:	00000306 	br	2cb88 <tcp_output+0x1b8>
   2cb7c:	e0bffb17 	ldw	r2,-20(fp)
   2cb80:	10800017 	ldw	r2,0(r2)
   2cb84:	e0bffb15 	stw	r2,-20(fp)
   2cb88:	e0bffb17 	ldw	r2,-20(fp)
   2cb8c:	10800017 	ldw	r2,0(r2)
   2cb90:	103ffa1e 	bne	r2,zero,2cb7c <tcp_output+0x1ac>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
   2cb94:	0001de06 	br	2d310 <tcp_output+0x940>
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
   2cb98:	e0bfff17 	ldw	r2,-4(fp)
   2cb9c:	10801d17 	ldw	r2,116(r2)
   2cba0:	10001d26 	beq	r2,zero,2cc18 <tcp_output+0x248>
   2cba4:	e0bfff17 	ldw	r2,-4(fp)
   2cba8:	10800883 	ldbu	r2,34(r2)
   2cbac:	10803fcc 	andi	r2,r2,255
   2cbb0:	1080110c 	andi	r2,r2,68
   2cbb4:	1000181e 	bne	r2,zero,2cc18 <tcp_output+0x248>
   2cbb8:	e0bfff17 	ldw	r2,-4(fp)
   2cbbc:	10801c17 	ldw	r2,112(r2)
   2cbc0:	10000c26 	beq	r2,zero,2cbf4 <tcp_output+0x224>
   2cbc4:	e0bfff17 	ldw	r2,-4(fp)
   2cbc8:	10801c17 	ldw	r2,112(r2)
   2cbcc:	10800017 	ldw	r2,0(r2)
   2cbd0:	1000111e 	bne	r2,zero,2cc18 <tcp_output+0x248>
   2cbd4:	e0bfff17 	ldw	r2,-4(fp)
   2cbd8:	10801c17 	ldw	r2,112(r2)
   2cbdc:	10c0020b 	ldhu	r3,8(r2)
   2cbe0:	e0bfff17 	ldw	r2,-4(fp)
   2cbe4:	10800e8b 	ldhu	r2,58(r2)
   2cbe8:	18ffffcc 	andi	r3,r3,65535
   2cbec:	10bfffcc 	andi	r2,r2,65535
   2cbf0:	1880092e 	bgeu	r3,r2,2cc18 <tcp_output+0x248>
   2cbf4:	e0bfff17 	ldw	r2,-4(fp)
   2cbf8:	10801a8b 	ldhu	r2,106(r2)
   2cbfc:	10bfffcc 	andi	r2,r2,65535
   2cc00:	10000526 	beq	r2,zero,2cc18 <tcp_output+0x248>
   2cc04:	e0bfff17 	ldw	r2,-4(fp)
   2cc08:	10801b0b 	ldhu	r2,108(r2)
   2cc0c:	10bfffcc 	andi	r2,r2,65535
   2cc10:	10800230 	cmpltui	r2,r2,8
   2cc14:	1000021e 	bne	r2,zero,2cc20 <tcp_output+0x250>
   2cc18:	00800044 	movi	r2,1
   2cc1c:	00000106 	br	2cc24 <tcp_output+0x254>
   2cc20:	0005883a 	mov	r2,zero
   2cc24:	1000051e 	bne	r2,zero,2cc3c <tcp_output+0x26c>
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
   2cc28:	e0bfff17 	ldw	r2,-4(fp)
   2cc2c:	10800883 	ldbu	r2,34(r2)
   2cc30:	10803fcc 	andi	r2,r2,255
   2cc34:	1080280c 	andi	r2,r2,160
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
   2cc38:	1001fa26 	beq	r2,zero,2d424 <tcp_output+0xa54>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
   2cc3c:	e0bffa17 	ldw	r2,-24(fp)
   2cc40:	10c00017 	ldw	r3,0(r2)
   2cc44:	e0bfff17 	ldw	r2,-4(fp)
   2cc48:	10c01c15 	stw	r3,112(r2)

    if (pcb->state != SYN_SENT) {
   2cc4c:	e0bfff17 	ldw	r2,-4(fp)
   2cc50:	10800617 	ldw	r2,24(r2)
   2cc54:	108000a0 	cmpeqi	r2,r2,2
   2cc58:	10001d1e 	bne	r2,zero,2ccd0 <tcp_output+0x300>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
   2cc5c:	e0bffa17 	ldw	r2,-24(fp)
   2cc60:	10800417 	ldw	r2,16(r2)
   2cc64:	e0fffa17 	ldw	r3,-24(fp)
   2cc68:	18c00417 	ldw	r3,16(r3)
   2cc6c:	19000303 	ldbu	r4,12(r3)
   2cc70:	18c00343 	ldbu	r3,13(r3)
   2cc74:	1806923a 	slli	r3,r3,8
   2cc78:	1906b03a 	or	r3,r3,r4
   2cc7c:	18c40014 	ori	r3,r3,4096
   2cc80:	193fffcc 	andi	r4,r3,65535
   2cc84:	21003fcc 	andi	r4,r4,255
   2cc88:	11400303 	ldbu	r5,12(r2)
   2cc8c:	280a703a 	and	r5,r5,zero
   2cc90:	2908b03a 	or	r4,r5,r4
   2cc94:	11000305 	stb	r4,12(r2)
   2cc98:	18ffffcc 	andi	r3,r3,65535
   2cc9c:	1806d23a 	srli	r3,r3,8
   2cca0:	18ffffcc 	andi	r3,r3,65535
   2cca4:	11000343 	ldbu	r4,13(r2)
   2cca8:	2008703a 	and	r4,r4,zero
   2ccac:	20c6b03a 	or	r3,r4,r3
   2ccb0:	10c00345 	stb	r3,13(r2)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
   2ccb4:	e0bfff17 	ldw	r2,-4(fp)
   2ccb8:	10c00883 	ldbu	r3,34(r2)
   2ccbc:	00bfff04 	movi	r2,-4
   2ccc0:	1884703a 	and	r2,r3,r2
   2ccc4:	1007883a 	mov	r3,r2
   2ccc8:	e0bfff17 	ldw	r2,-4(fp)
   2cccc:	10c00885 	stb	r3,34(r2)
    }

    tcp_output_segment(seg, pcb);
   2ccd0:	e13ffa17 	ldw	r4,-24(fp)
   2ccd4:	e17fff17 	ldw	r5,-4(fp)
   2ccd8:	002d46c0 	call	2d46c <tcp_output_segment>
    snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
   2ccdc:	e0bffa17 	ldw	r2,-24(fp)
   2cce0:	10800417 	ldw	r2,16(r2)
   2cce4:	10c00103 	ldbu	r3,4(r2)
   2cce8:	11000143 	ldbu	r4,5(r2)
   2ccec:	2008923a 	slli	r4,r4,8
   2ccf0:	20c6b03a 	or	r3,r4,r3
   2ccf4:	11000183 	ldbu	r4,6(r2)
   2ccf8:	2008943a 	slli	r4,r4,16
   2ccfc:	20c6b03a 	or	r3,r4,r3
   2cd00:	108001c3 	ldbu	r2,7(r2)
   2cd04:	1004963a 	slli	r2,r2,24
   2cd08:	10c4b03a 	or	r2,r2,r3
   2cd0c:	1006d63a 	srli	r3,r2,24
   2cd10:	e0bffa17 	ldw	r2,-24(fp)
   2cd14:	10800417 	ldw	r2,16(r2)
   2cd18:	11000103 	ldbu	r4,4(r2)
   2cd1c:	11400143 	ldbu	r5,5(r2)
   2cd20:	280a923a 	slli	r5,r5,8
   2cd24:	2908b03a 	or	r4,r5,r4
   2cd28:	11400183 	ldbu	r5,6(r2)
   2cd2c:	280a943a 	slli	r5,r5,16
   2cd30:	2908b03a 	or	r4,r5,r4
   2cd34:	108001c3 	ldbu	r2,7(r2)
   2cd38:	1004963a 	slli	r2,r2,24
   2cd3c:	1104b03a 	or	r2,r2,r4
   2cd40:	1004d23a 	srli	r2,r2,8
   2cd44:	10bfc00c 	andi	r2,r2,65280
   2cd48:	1886b03a 	or	r3,r3,r2
   2cd4c:	e0bffa17 	ldw	r2,-24(fp)
   2cd50:	10800417 	ldw	r2,16(r2)
   2cd54:	11000103 	ldbu	r4,4(r2)
   2cd58:	11400143 	ldbu	r5,5(r2)
   2cd5c:	280a923a 	slli	r5,r5,8
   2cd60:	2908b03a 	or	r4,r5,r4
   2cd64:	11400183 	ldbu	r5,6(r2)
   2cd68:	280a943a 	slli	r5,r5,16
   2cd6c:	2908b03a 	or	r4,r5,r4
   2cd70:	108001c3 	ldbu	r2,7(r2)
   2cd74:	1004963a 	slli	r2,r2,24
   2cd78:	1104b03a 	or	r2,r2,r4
   2cd7c:	10bfc00c 	andi	r2,r2,65280
   2cd80:	1004923a 	slli	r2,r2,8
   2cd84:	1886b03a 	or	r3,r3,r2
   2cd88:	e0bffa17 	ldw	r2,-24(fp)
   2cd8c:	10800417 	ldw	r2,16(r2)
   2cd90:	11000103 	ldbu	r4,4(r2)
   2cd94:	11400143 	ldbu	r5,5(r2)
   2cd98:	280a923a 	slli	r5,r5,8
   2cd9c:	2908b03a 	or	r4,r5,r4
   2cda0:	11400183 	ldbu	r5,6(r2)
   2cda4:	280a943a 	slli	r5,r5,16
   2cda8:	2908b03a 	or	r4,r5,r4
   2cdac:	108001c3 	ldbu	r2,7(r2)
   2cdb0:	1004963a 	slli	r2,r2,24
   2cdb4:	1104b03a 	or	r2,r2,r4
   2cdb8:	1004963a 	slli	r2,r2,24
   2cdbc:	1886b03a 	or	r3,r3,r2
   2cdc0:	e0bffa17 	ldw	r2,-24(fp)
   2cdc4:	1080020b 	ldhu	r2,8(r2)
   2cdc8:	113fffcc 	andi	r4,r2,65535
   2cdcc:	e0bffa17 	ldw	r2,-24(fp)
   2cdd0:	10800417 	ldw	r2,16(r2)
   2cdd4:	11400303 	ldbu	r5,12(r2)
   2cdd8:	10800343 	ldbu	r2,13(r2)
   2cddc:	1004923a 	slli	r2,r2,8
   2cde0:	1144b03a 	or	r2,r2,r5
   2cde4:	10bfffcc 	andi	r2,r2,65535
   2cde8:	1004d23a 	srli	r2,r2,8
   2cdec:	117fffcc 	andi	r5,r2,65535
   2cdf0:	e0bffa17 	ldw	r2,-24(fp)
   2cdf4:	10800417 	ldw	r2,16(r2)
   2cdf8:	11800303 	ldbu	r6,12(r2)
   2cdfc:	10800343 	ldbu	r2,13(r2)
   2ce00:	1004923a 	slli	r2,r2,8
   2ce04:	1184b03a 	or	r2,r2,r6
   2ce08:	10bfffcc 	andi	r2,r2,65535
   2ce0c:	1004923a 	slli	r2,r2,8
   2ce10:	10bfffcc 	andi	r2,r2,65535
   2ce14:	2884b03a 	or	r2,r5,r2
   2ce18:	108000cc 	andi	r2,r2,3
   2ce1c:	1004c03a 	cmpne	r2,r2,zero
   2ce20:	10803fcc 	andi	r2,r2,255
   2ce24:	2085883a 	add	r2,r4,r2
   2ce28:	1885883a 	add	r2,r3,r2
   2ce2c:	e0bffe15 	stw	r2,-8(fp)
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
   2ce30:	e0bfff17 	ldw	r2,-4(fp)
   2ce34:	10c01517 	ldw	r3,84(r2)
   2ce38:	e0bffe17 	ldw	r2,-8(fp)
   2ce3c:	1885c83a 	sub	r2,r3,r2
   2ce40:	1000030e 	bge	r2,zero,2ce50 <tcp_output+0x480>
      pcb->snd_nxt = snd_nxt;
   2ce44:	e0bfff17 	ldw	r2,-4(fp)
   2ce48:	e0fffe17 	ldw	r3,-8(fp)
   2ce4c:	10c01515 	stw	r3,84(r2)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
   2ce50:	e0bffa17 	ldw	r2,-24(fp)
   2ce54:	1080020b 	ldhu	r2,8(r2)
   2ce58:	10ffffcc 	andi	r3,r2,65535
   2ce5c:	e0bffa17 	ldw	r2,-24(fp)
   2ce60:	10800417 	ldw	r2,16(r2)
   2ce64:	11000303 	ldbu	r4,12(r2)
   2ce68:	10800343 	ldbu	r2,13(r2)
   2ce6c:	1004923a 	slli	r2,r2,8
   2ce70:	1104b03a 	or	r2,r2,r4
   2ce74:	10bfffcc 	andi	r2,r2,65535
   2ce78:	1004d23a 	srli	r2,r2,8
   2ce7c:	113fffcc 	andi	r4,r2,65535
   2ce80:	e0bffa17 	ldw	r2,-24(fp)
   2ce84:	10800417 	ldw	r2,16(r2)
   2ce88:	11400303 	ldbu	r5,12(r2)
   2ce8c:	10800343 	ldbu	r2,13(r2)
   2ce90:	1004923a 	slli	r2,r2,8
   2ce94:	1144b03a 	or	r2,r2,r5
   2ce98:	10bfffcc 	andi	r2,r2,65535
   2ce9c:	1004923a 	slli	r2,r2,8
   2cea0:	10bfffcc 	andi	r2,r2,65535
   2cea4:	2084b03a 	or	r2,r4,r2
   2cea8:	108000cc 	andi	r2,r2,3
   2ceac:	1004c03a 	cmpne	r2,r2,zero
   2ceb0:	10803fcc 	andi	r2,r2,255
   2ceb4:	1885883a 	add	r2,r3,r2
   2ceb8:	0081100e 	bge	zero,r2,2d2fc <tcp_output+0x92c>
      seg->next = NULL;
   2cebc:	e0bffa17 	ldw	r2,-24(fp)
   2cec0:	10000015 	stw	zero,0(r2)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
   2cec4:	e0bfff17 	ldw	r2,-4(fp)
   2cec8:	10801d17 	ldw	r2,116(r2)
   2cecc:	1000061e 	bne	r2,zero,2cee8 <tcp_output+0x518>
        pcb->unacked = seg;
   2ced0:	e0bfff17 	ldw	r2,-4(fp)
   2ced4:	e0fffa17 	ldw	r3,-24(fp)
   2ced8:	10c01d15 	stw	r3,116(r2)
        useg = seg;
   2cedc:	e0bffa17 	ldw	r2,-24(fp)
   2cee0:	e0bffb15 	stw	r2,-20(fp)
   2cee4:	00010706 	br	2d304 <tcp_output+0x934>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
   2cee8:	e0bffa17 	ldw	r2,-24(fp)
   2ceec:	10800417 	ldw	r2,16(r2)
   2cef0:	10c00103 	ldbu	r3,4(r2)
   2cef4:	11000143 	ldbu	r4,5(r2)
   2cef8:	2008923a 	slli	r4,r4,8
   2cefc:	20c6b03a 	or	r3,r4,r3
   2cf00:	11000183 	ldbu	r4,6(r2)
   2cf04:	2008943a 	slli	r4,r4,16
   2cf08:	20c6b03a 	or	r3,r4,r3
   2cf0c:	108001c3 	ldbu	r2,7(r2)
   2cf10:	1004963a 	slli	r2,r2,24
   2cf14:	10c4b03a 	or	r2,r2,r3
   2cf18:	1006d63a 	srli	r3,r2,24
   2cf1c:	e0bffa17 	ldw	r2,-24(fp)
   2cf20:	10800417 	ldw	r2,16(r2)
   2cf24:	11000103 	ldbu	r4,4(r2)
   2cf28:	11400143 	ldbu	r5,5(r2)
   2cf2c:	280a923a 	slli	r5,r5,8
   2cf30:	2908b03a 	or	r4,r5,r4
   2cf34:	11400183 	ldbu	r5,6(r2)
   2cf38:	280a943a 	slli	r5,r5,16
   2cf3c:	2908b03a 	or	r4,r5,r4
   2cf40:	108001c3 	ldbu	r2,7(r2)
   2cf44:	1004963a 	slli	r2,r2,24
   2cf48:	1104b03a 	or	r2,r2,r4
   2cf4c:	1004d23a 	srli	r2,r2,8
   2cf50:	10bfc00c 	andi	r2,r2,65280
   2cf54:	1886b03a 	or	r3,r3,r2
   2cf58:	e0bffa17 	ldw	r2,-24(fp)
   2cf5c:	10800417 	ldw	r2,16(r2)
   2cf60:	11000103 	ldbu	r4,4(r2)
   2cf64:	11400143 	ldbu	r5,5(r2)
   2cf68:	280a923a 	slli	r5,r5,8
   2cf6c:	2908b03a 	or	r4,r5,r4
   2cf70:	11400183 	ldbu	r5,6(r2)
   2cf74:	280a943a 	slli	r5,r5,16
   2cf78:	2908b03a 	or	r4,r5,r4
   2cf7c:	108001c3 	ldbu	r2,7(r2)
   2cf80:	1004963a 	slli	r2,r2,24
   2cf84:	1104b03a 	or	r2,r2,r4
   2cf88:	10bfc00c 	andi	r2,r2,65280
   2cf8c:	1004923a 	slli	r2,r2,8
   2cf90:	1886b03a 	or	r3,r3,r2
   2cf94:	e0bffa17 	ldw	r2,-24(fp)
   2cf98:	10800417 	ldw	r2,16(r2)
   2cf9c:	11000103 	ldbu	r4,4(r2)
   2cfa0:	11400143 	ldbu	r5,5(r2)
   2cfa4:	280a923a 	slli	r5,r5,8
   2cfa8:	2908b03a 	or	r4,r5,r4
   2cfac:	11400183 	ldbu	r5,6(r2)
   2cfb0:	280a943a 	slli	r5,r5,16
   2cfb4:	2908b03a 	or	r4,r5,r4
   2cfb8:	108001c3 	ldbu	r2,7(r2)
   2cfbc:	1004963a 	slli	r2,r2,24
   2cfc0:	1104b03a 	or	r2,r2,r4
   2cfc4:	1004963a 	slli	r2,r2,24
   2cfc8:	1886b03a 	or	r3,r3,r2
   2cfcc:	e0bffb17 	ldw	r2,-20(fp)
   2cfd0:	10800417 	ldw	r2,16(r2)
   2cfd4:	11000103 	ldbu	r4,4(r2)
   2cfd8:	11400143 	ldbu	r5,5(r2)
   2cfdc:	280a923a 	slli	r5,r5,8
   2cfe0:	2908b03a 	or	r4,r5,r4
   2cfe4:	11400183 	ldbu	r5,6(r2)
   2cfe8:	280a943a 	slli	r5,r5,16
   2cfec:	2908b03a 	or	r4,r5,r4
   2cff0:	108001c3 	ldbu	r2,7(r2)
   2cff4:	1004963a 	slli	r2,r2,24
   2cff8:	1104b03a 	or	r2,r2,r4
   2cffc:	1008d63a 	srli	r4,r2,24
   2d000:	e0bffb17 	ldw	r2,-20(fp)
   2d004:	10800417 	ldw	r2,16(r2)
   2d008:	11400103 	ldbu	r5,4(r2)
   2d00c:	11800143 	ldbu	r6,5(r2)
   2d010:	300c923a 	slli	r6,r6,8
   2d014:	314ab03a 	or	r5,r6,r5
   2d018:	11800183 	ldbu	r6,6(r2)
   2d01c:	300c943a 	slli	r6,r6,16
   2d020:	314ab03a 	or	r5,r6,r5
   2d024:	108001c3 	ldbu	r2,7(r2)
   2d028:	1004963a 	slli	r2,r2,24
   2d02c:	1144b03a 	or	r2,r2,r5
   2d030:	1004d23a 	srli	r2,r2,8
   2d034:	10bfc00c 	andi	r2,r2,65280
   2d038:	2088b03a 	or	r4,r4,r2
   2d03c:	e0bffb17 	ldw	r2,-20(fp)
   2d040:	10800417 	ldw	r2,16(r2)
   2d044:	11400103 	ldbu	r5,4(r2)
   2d048:	11800143 	ldbu	r6,5(r2)
   2d04c:	300c923a 	slli	r6,r6,8
   2d050:	314ab03a 	or	r5,r6,r5
   2d054:	11800183 	ldbu	r6,6(r2)
   2d058:	300c943a 	slli	r6,r6,16
   2d05c:	314ab03a 	or	r5,r6,r5
   2d060:	108001c3 	ldbu	r2,7(r2)
   2d064:	1004963a 	slli	r2,r2,24
   2d068:	1144b03a 	or	r2,r2,r5
   2d06c:	10bfc00c 	andi	r2,r2,65280
   2d070:	1004923a 	slli	r2,r2,8
   2d074:	2088b03a 	or	r4,r4,r2
   2d078:	e0bffb17 	ldw	r2,-20(fp)
   2d07c:	10800417 	ldw	r2,16(r2)
   2d080:	11400103 	ldbu	r5,4(r2)
   2d084:	11800143 	ldbu	r6,5(r2)
   2d088:	300c923a 	slli	r6,r6,8
   2d08c:	314ab03a 	or	r5,r6,r5
   2d090:	11800183 	ldbu	r6,6(r2)
   2d094:	300c943a 	slli	r6,r6,16
   2d098:	314ab03a 	or	r5,r6,r5
   2d09c:	108001c3 	ldbu	r2,7(r2)
   2d0a0:	1004963a 	slli	r2,r2,24
   2d0a4:	1144b03a 	or	r2,r2,r5
   2d0a8:	1004963a 	slli	r2,r2,24
   2d0ac:	2084b03a 	or	r2,r4,r2
   2d0b0:	1885c83a 	sub	r2,r3,r2
   2d0b4:	10008a0e 	bge	r2,zero,2d2e0 <tcp_output+0x910>
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
   2d0b8:	e0bfff17 	ldw	r2,-4(fp)
   2d0bc:	10801d04 	addi	r2,r2,116
   2d0c0:	e0bffc15 	stw	r2,-16(fp)
          while (*cur_seg &&
   2d0c4:	00000306 	br	2d0d4 <tcp_output+0x704>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
              cur_seg = &((*cur_seg)->next );
   2d0c8:	e0bffc17 	ldw	r2,-16(fp)
   2d0cc:	10800017 	ldw	r2,0(r2)
   2d0d0:	e0bffc15 	stw	r2,-16(fp)
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
   2d0d4:	e0bffc17 	ldw	r2,-16(fp)
   2d0d8:	10800017 	ldw	r2,0(r2)
   2d0dc:	10007826 	beq	r2,zero,2d2c0 <tcp_output+0x8f0>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
   2d0e0:	e0bffc17 	ldw	r2,-16(fp)
   2d0e4:	10800017 	ldw	r2,0(r2)
   2d0e8:	10800417 	ldw	r2,16(r2)
   2d0ec:	10c00103 	ldbu	r3,4(r2)
   2d0f0:	11000143 	ldbu	r4,5(r2)
   2d0f4:	2008923a 	slli	r4,r4,8
   2d0f8:	20c6b03a 	or	r3,r4,r3
   2d0fc:	11000183 	ldbu	r4,6(r2)
   2d100:	2008943a 	slli	r4,r4,16
   2d104:	20c6b03a 	or	r3,r4,r3
   2d108:	108001c3 	ldbu	r2,7(r2)
   2d10c:	1004963a 	slli	r2,r2,24
   2d110:	10c4b03a 	or	r2,r2,r3
   2d114:	1006d63a 	srli	r3,r2,24
   2d118:	e0bffc17 	ldw	r2,-16(fp)
   2d11c:	10800017 	ldw	r2,0(r2)
   2d120:	10800417 	ldw	r2,16(r2)
   2d124:	11000103 	ldbu	r4,4(r2)
   2d128:	11400143 	ldbu	r5,5(r2)
   2d12c:	280a923a 	slli	r5,r5,8
   2d130:	2908b03a 	or	r4,r5,r4
   2d134:	11400183 	ldbu	r5,6(r2)
   2d138:	280a943a 	slli	r5,r5,16
   2d13c:	2908b03a 	or	r4,r5,r4
   2d140:	108001c3 	ldbu	r2,7(r2)
   2d144:	1004963a 	slli	r2,r2,24
   2d148:	1104b03a 	or	r2,r2,r4
   2d14c:	1004d23a 	srli	r2,r2,8
   2d150:	10bfc00c 	andi	r2,r2,65280
   2d154:	1886b03a 	or	r3,r3,r2
   2d158:	e0bffc17 	ldw	r2,-16(fp)
   2d15c:	10800017 	ldw	r2,0(r2)
   2d160:	10800417 	ldw	r2,16(r2)
   2d164:	11000103 	ldbu	r4,4(r2)
   2d168:	11400143 	ldbu	r5,5(r2)
   2d16c:	280a923a 	slli	r5,r5,8
   2d170:	2908b03a 	or	r4,r5,r4
   2d174:	11400183 	ldbu	r5,6(r2)
   2d178:	280a943a 	slli	r5,r5,16
   2d17c:	2908b03a 	or	r4,r5,r4
   2d180:	108001c3 	ldbu	r2,7(r2)
   2d184:	1004963a 	slli	r2,r2,24
   2d188:	1104b03a 	or	r2,r2,r4
   2d18c:	10bfc00c 	andi	r2,r2,65280
   2d190:	1004923a 	slli	r2,r2,8
   2d194:	1886b03a 	or	r3,r3,r2
   2d198:	e0bffc17 	ldw	r2,-16(fp)
   2d19c:	10800017 	ldw	r2,0(r2)
   2d1a0:	10800417 	ldw	r2,16(r2)
   2d1a4:	11000103 	ldbu	r4,4(r2)
   2d1a8:	11400143 	ldbu	r5,5(r2)
   2d1ac:	280a923a 	slli	r5,r5,8
   2d1b0:	2908b03a 	or	r4,r5,r4
   2d1b4:	11400183 	ldbu	r5,6(r2)
   2d1b8:	280a943a 	slli	r5,r5,16
   2d1bc:	2908b03a 	or	r4,r5,r4
   2d1c0:	108001c3 	ldbu	r2,7(r2)
   2d1c4:	1004963a 	slli	r2,r2,24
   2d1c8:	1104b03a 	or	r2,r2,r4
   2d1cc:	1004963a 	slli	r2,r2,24
   2d1d0:	1886b03a 	or	r3,r3,r2
   2d1d4:	e0bffa17 	ldw	r2,-24(fp)
   2d1d8:	10800417 	ldw	r2,16(r2)
   2d1dc:	11000103 	ldbu	r4,4(r2)
   2d1e0:	11400143 	ldbu	r5,5(r2)
   2d1e4:	280a923a 	slli	r5,r5,8
   2d1e8:	2908b03a 	or	r4,r5,r4
   2d1ec:	11400183 	ldbu	r5,6(r2)
   2d1f0:	280a943a 	slli	r5,r5,16
   2d1f4:	2908b03a 	or	r4,r5,r4
   2d1f8:	108001c3 	ldbu	r2,7(r2)
   2d1fc:	1004963a 	slli	r2,r2,24
   2d200:	1104b03a 	or	r2,r2,r4
   2d204:	1008d63a 	srli	r4,r2,24
   2d208:	e0bffa17 	ldw	r2,-24(fp)
   2d20c:	10800417 	ldw	r2,16(r2)
   2d210:	11400103 	ldbu	r5,4(r2)
   2d214:	11800143 	ldbu	r6,5(r2)
   2d218:	300c923a 	slli	r6,r6,8
   2d21c:	314ab03a 	or	r5,r6,r5
   2d220:	11800183 	ldbu	r6,6(r2)
   2d224:	300c943a 	slli	r6,r6,16
   2d228:	314ab03a 	or	r5,r6,r5
   2d22c:	108001c3 	ldbu	r2,7(r2)
   2d230:	1004963a 	slli	r2,r2,24
   2d234:	1144b03a 	or	r2,r2,r5
   2d238:	1004d23a 	srli	r2,r2,8
   2d23c:	10bfc00c 	andi	r2,r2,65280
   2d240:	2088b03a 	or	r4,r4,r2
   2d244:	e0bffa17 	ldw	r2,-24(fp)
   2d248:	10800417 	ldw	r2,16(r2)
   2d24c:	11400103 	ldbu	r5,4(r2)
   2d250:	11800143 	ldbu	r6,5(r2)
   2d254:	300c923a 	slli	r6,r6,8
   2d258:	314ab03a 	or	r5,r6,r5
   2d25c:	11800183 	ldbu	r6,6(r2)
   2d260:	300c943a 	slli	r6,r6,16
   2d264:	314ab03a 	or	r5,r6,r5
   2d268:	108001c3 	ldbu	r2,7(r2)
   2d26c:	1004963a 	slli	r2,r2,24
   2d270:	1144b03a 	or	r2,r2,r5
   2d274:	10bfc00c 	andi	r2,r2,65280
   2d278:	1004923a 	slli	r2,r2,8
   2d27c:	2088b03a 	or	r4,r4,r2
   2d280:	e0bffa17 	ldw	r2,-24(fp)
   2d284:	10800417 	ldw	r2,16(r2)
   2d288:	11400103 	ldbu	r5,4(r2)
   2d28c:	11800143 	ldbu	r6,5(r2)
   2d290:	300c923a 	slli	r6,r6,8
   2d294:	314ab03a 	or	r5,r6,r5
   2d298:	11800183 	ldbu	r6,6(r2)
   2d29c:	300c943a 	slli	r6,r6,16
   2d2a0:	314ab03a 	or	r5,r6,r5
   2d2a4:	108001c3 	ldbu	r2,7(r2)
   2d2a8:	1004963a 	slli	r2,r2,24
   2d2ac:	1144b03a 	or	r2,r2,r5
   2d2b0:	1004963a 	slli	r2,r2,24
   2d2b4:	2084b03a 	or	r2,r4,r2
   2d2b8:	1885c83a 	sub	r2,r3,r2
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
   2d2bc:	103f8216 	blt	r2,zero,2d0c8 <tcp_output+0x6f8>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
              cur_seg = &((*cur_seg)->next );
          }
          seg->next = (*cur_seg);
   2d2c0:	e0bffc17 	ldw	r2,-16(fp)
   2d2c4:	10c00017 	ldw	r3,0(r2)
   2d2c8:	e0bffa17 	ldw	r2,-24(fp)
   2d2cc:	10c00015 	stw	r3,0(r2)
          (*cur_seg) = seg;
   2d2d0:	e0bffc17 	ldw	r2,-16(fp)
   2d2d4:	e0fffa17 	ldw	r3,-24(fp)
   2d2d8:	10c00015 	stw	r3,0(r2)
   2d2dc:	00000906 	br	2d304 <tcp_output+0x934>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
   2d2e0:	e0bffb17 	ldw	r2,-20(fp)
   2d2e4:	e0fffa17 	ldw	r3,-24(fp)
   2d2e8:	10c00015 	stw	r3,0(r2)
          useg = useg->next;
   2d2ec:	e0bffb17 	ldw	r2,-20(fp)
   2d2f0:	10800017 	ldw	r2,0(r2)
   2d2f4:	e0bffb15 	stw	r2,-20(fp)
   2d2f8:	00000206 	br	2d304 <tcp_output+0x934>
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
   2d2fc:	e13ffa17 	ldw	r4,-24(fp)
   2d300:	00264f80 	call	264f8 <tcp_seg_free>
    }
    seg = pcb->unsent;
   2d304:	e0bfff17 	ldw	r2,-4(fp)
   2d308:	10801c17 	ldw	r2,112(r2)
   2d30c:	e0bffa15 	stw	r2,-24(fp)
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
   2d310:	e0bffa17 	ldw	r2,-24(fp)
   2d314:	10004426 	beq	r2,zero,2d428 <tcp_output+0xa58>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
   2d318:	e0bffa17 	ldw	r2,-24(fp)
   2d31c:	10800417 	ldw	r2,16(r2)
   2d320:	10c00103 	ldbu	r3,4(r2)
   2d324:	11000143 	ldbu	r4,5(r2)
   2d328:	2008923a 	slli	r4,r4,8
   2d32c:	20c6b03a 	or	r3,r4,r3
   2d330:	11000183 	ldbu	r4,6(r2)
   2d334:	2008943a 	slli	r4,r4,16
   2d338:	20c6b03a 	or	r3,r4,r3
   2d33c:	108001c3 	ldbu	r2,7(r2)
   2d340:	1004963a 	slli	r2,r2,24
   2d344:	10c4b03a 	or	r2,r2,r3
   2d348:	1006d63a 	srli	r3,r2,24
   2d34c:	e0bffa17 	ldw	r2,-24(fp)
   2d350:	10800417 	ldw	r2,16(r2)
   2d354:	11000103 	ldbu	r4,4(r2)
   2d358:	11400143 	ldbu	r5,5(r2)
   2d35c:	280a923a 	slli	r5,r5,8
   2d360:	2908b03a 	or	r4,r5,r4
   2d364:	11400183 	ldbu	r5,6(r2)
   2d368:	280a943a 	slli	r5,r5,16
   2d36c:	2908b03a 	or	r4,r5,r4
   2d370:	108001c3 	ldbu	r2,7(r2)
   2d374:	1004963a 	slli	r2,r2,24
   2d378:	1104b03a 	or	r2,r2,r4
   2d37c:	1004d23a 	srli	r2,r2,8
   2d380:	10bfc00c 	andi	r2,r2,65280
   2d384:	1886b03a 	or	r3,r3,r2
   2d388:	e0bffa17 	ldw	r2,-24(fp)
   2d38c:	10800417 	ldw	r2,16(r2)
   2d390:	11000103 	ldbu	r4,4(r2)
   2d394:	11400143 	ldbu	r5,5(r2)
   2d398:	280a923a 	slli	r5,r5,8
   2d39c:	2908b03a 	or	r4,r5,r4
   2d3a0:	11400183 	ldbu	r5,6(r2)
   2d3a4:	280a943a 	slli	r5,r5,16
   2d3a8:	2908b03a 	or	r4,r5,r4
   2d3ac:	108001c3 	ldbu	r2,7(r2)
   2d3b0:	1004963a 	slli	r2,r2,24
   2d3b4:	1104b03a 	or	r2,r2,r4
   2d3b8:	10bfc00c 	andi	r2,r2,65280
   2d3bc:	1004923a 	slli	r2,r2,8
   2d3c0:	1886b03a 	or	r3,r3,r2
   2d3c4:	e0bffa17 	ldw	r2,-24(fp)
   2d3c8:	10800417 	ldw	r2,16(r2)
   2d3cc:	11000103 	ldbu	r4,4(r2)
   2d3d0:	11400143 	ldbu	r5,5(r2)
   2d3d4:	280a923a 	slli	r5,r5,8
   2d3d8:	2908b03a 	or	r4,r5,r4
   2d3dc:	11400183 	ldbu	r5,6(r2)
   2d3e0:	280a943a 	slli	r5,r5,16
   2d3e4:	2908b03a 	or	r4,r5,r4
   2d3e8:	108001c3 	ldbu	r2,7(r2)
   2d3ec:	1004963a 	slli	r2,r2,24
   2d3f0:	1104b03a 	or	r2,r2,r4
   2d3f4:	1004963a 	slli	r2,r2,24
   2d3f8:	1886b03a 	or	r3,r3,r2
   2d3fc:	e0bfff17 	ldw	r2,-4(fp)
   2d400:	10801317 	ldw	r2,76(r2)
   2d404:	1887c83a 	sub	r3,r3,r2
   2d408:	e0bffa17 	ldw	r2,-24(fp)
   2d40c:	1080020b 	ldhu	r2,8(r2)
   2d410:	10bfffcc 	andi	r2,r2,65535
   2d414:	1885883a 	add	r2,r3,r2
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
   2d418:	e0fffd17 	ldw	r3,-12(fp)
   2d41c:	18bdde2e 	bgeu	r3,r2,2cb98 <tcp_output+0x1c8>
   2d420:	00000106 	br	2d428 <tcp_output+0xa58>
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
      break;
   2d424:	0001883a 	nop
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }
#if TCP_OVERSIZE
  if (pcb->unsent == NULL) {
   2d428:	e0bfff17 	ldw	r2,-4(fp)
   2d42c:	10801c17 	ldw	r2,112(r2)
   2d430:	1000021e 	bne	r2,zero,2d43c <tcp_output+0xa6c>
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
   2d434:	e0bfff17 	ldw	r2,-4(fp)
   2d438:	10001b8d 	sth	zero,110(r2)
  }
#endif /* TCP_OVERSIZE */

  pcb->flags &= ~TF_NAGLEMEMERR;
   2d43c:	e0bfff17 	ldw	r2,-4(fp)
   2d440:	10800883 	ldbu	r2,34(r2)
   2d444:	10801fcc 	andi	r2,r2,127
   2d448:	1007883a 	mov	r3,r2
   2d44c:	e0bfff17 	ldw	r2,-4(fp)
   2d450:	10c00885 	stb	r3,34(r2)
  return ERR_OK;
   2d454:	0005883a 	mov	r2,zero
}
   2d458:	e037883a 	mov	sp,fp
   2d45c:	dfc00117 	ldw	ra,4(sp)
   2d460:	df000017 	ldw	fp,0(sp)
   2d464:	dec00204 	addi	sp,sp,8
   2d468:	f800283a 	ret

0002d46c <tcp_output_segment>:
 * @param seg the tcp_seg to send
 * @param pcb the tcp_pcb for the TCP connection used to send the segment
 */
static void
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
{
   2d46c:	defff404 	addi	sp,sp,-48
   2d470:	dfc00b15 	stw	ra,44(sp)
   2d474:	df000a15 	stw	fp,40(sp)
   2d478:	df000a04 	addi	fp,sp,40
   2d47c:	e13ffe15 	stw	r4,-8(fp)
   2d480:	e17fff15 	stw	r5,-4(fp)
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
   2d484:	e0bffe17 	ldw	r2,-8(fp)
   2d488:	10800417 	ldw	r2,16(r2)
   2d48c:	e0ffff17 	ldw	r3,-4(fp)
   2d490:	18c00b17 	ldw	r3,44(r3)
   2d494:	1808d63a 	srli	r4,r3,24
   2d498:	e0ffff17 	ldw	r3,-4(fp)
   2d49c:	18c00b17 	ldw	r3,44(r3)
   2d4a0:	1806d23a 	srli	r3,r3,8
   2d4a4:	18ffc00c 	andi	r3,r3,65280
   2d4a8:	20c8b03a 	or	r4,r4,r3
   2d4ac:	e0ffff17 	ldw	r3,-4(fp)
   2d4b0:	18c00b17 	ldw	r3,44(r3)
   2d4b4:	18ffc00c 	andi	r3,r3,65280
   2d4b8:	1806923a 	slli	r3,r3,8
   2d4bc:	20c8b03a 	or	r4,r4,r3
   2d4c0:	e0ffff17 	ldw	r3,-4(fp)
   2d4c4:	18c00b17 	ldw	r3,44(r3)
   2d4c8:	1806963a 	slli	r3,r3,24
   2d4cc:	20c6b03a 	or	r3,r4,r3
   2d4d0:	19003fcc 	andi	r4,r3,255
   2d4d4:	11400203 	ldbu	r5,8(r2)
   2d4d8:	280a703a 	and	r5,r5,zero
   2d4dc:	2908b03a 	or	r4,r5,r4
   2d4e0:	11000205 	stb	r4,8(r2)
   2d4e4:	1808d23a 	srli	r4,r3,8
   2d4e8:	21003fcc 	andi	r4,r4,255
   2d4ec:	11400243 	ldbu	r5,9(r2)
   2d4f0:	280a703a 	and	r5,r5,zero
   2d4f4:	2908b03a 	or	r4,r5,r4
   2d4f8:	11000245 	stb	r4,9(r2)
   2d4fc:	1808d43a 	srli	r4,r3,16
   2d500:	21003fcc 	andi	r4,r4,255
   2d504:	11400283 	ldbu	r5,10(r2)
   2d508:	280a703a 	and	r5,r5,zero
   2d50c:	2908b03a 	or	r4,r5,r4
   2d510:	11000285 	stb	r4,10(r2)
   2d514:	1806d63a 	srli	r3,r3,24
   2d518:	110002c3 	ldbu	r4,11(r2)
   2d51c:	2008703a 	and	r4,r4,zero
   2d520:	20c6b03a 	or	r3,r4,r3
   2d524:	10c002c5 	stb	r3,11(r2)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
   2d528:	e0bffe17 	ldw	r2,-8(fp)
   2d52c:	10800417 	ldw	r2,16(r2)
   2d530:	e0ffff17 	ldw	r3,-4(fp)
   2d534:	18c00c8b 	ldhu	r3,50(r3)
   2d538:	18ffffcc 	andi	r3,r3,65535
   2d53c:	1806d23a 	srli	r3,r3,8
   2d540:	1809883a 	mov	r4,r3
   2d544:	e0ffff17 	ldw	r3,-4(fp)
   2d548:	18c00c8b 	ldhu	r3,50(r3)
   2d54c:	18ffffcc 	andi	r3,r3,65535
   2d550:	1806923a 	slli	r3,r3,8
   2d554:	20c6b03a 	or	r3,r4,r3
   2d558:	193fffcc 	andi	r4,r3,65535
   2d55c:	21003fcc 	andi	r4,r4,255
   2d560:	11400383 	ldbu	r5,14(r2)
   2d564:	280a703a 	and	r5,r5,zero
   2d568:	2908b03a 	or	r4,r5,r4
   2d56c:	11000385 	stb	r4,14(r2)
   2d570:	18ffffcc 	andi	r3,r3,65535
   2d574:	1806d23a 	srli	r3,r3,8
   2d578:	18ffffcc 	andi	r3,r3,65535
   2d57c:	110003c3 	ldbu	r4,15(r2)
   2d580:	2008703a 	and	r4,r4,zero
   2d584:	20c6b03a 	or	r3,r4,r3
   2d588:	10c003c5 	stb	r3,15(r2)

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
   2d58c:	e0bfff17 	ldw	r2,-4(fp)
   2d590:	10c00b17 	ldw	r3,44(r2)
   2d594:	e0bfff17 	ldw	r2,-4(fp)
   2d598:	10800c8b 	ldhu	r2,50(r2)
   2d59c:	10bfffcc 	andi	r2,r2,65535
   2d5a0:	1887883a 	add	r3,r3,r2
   2d5a4:	e0bfff17 	ldw	r2,-4(fp)
   2d5a8:	10c00d15 	stw	r3,52(r2)

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
   2d5ac:	e0bffe17 	ldw	r2,-8(fp)
   2d5b0:	10800417 	ldw	r2,16(r2)
   2d5b4:	10800504 	addi	r2,r2,20
   2d5b8:	e0bff915 	stw	r2,-28(fp)
  if (seg->flags & TF_SEG_OPTS_MSS) {
   2d5bc:	e0bffe17 	ldw	r2,-8(fp)
   2d5c0:	10800343 	ldbu	r2,13(r2)
   2d5c4:	10803fcc 	andi	r2,r2,255
   2d5c8:	1080004c 	andi	r2,r2,1
   2d5cc:	10001e26 	beq	r2,zero,2d648 <tcp_output_segment+0x1dc>
    u16_t mss;
#if TCP_CALCULATE_EFF_SEND_MSS
    mss = tcp_eff_send_mss(TCP_MSS, &(pcb->local_ip), &(pcb->remote_ip));
   2d5d0:	e0ffff17 	ldw	r3,-4(fp)
   2d5d4:	e0bfff17 	ldw	r2,-4(fp)
   2d5d8:	10800104 	addi	r2,r2,4
   2d5dc:	01016d04 	movi	r4,1460
   2d5e0:	180b883a 	mov	r5,r3
   2d5e4:	100d883a 	mov	r6,r2
   2d5e8:	0026dd00 	call	26dd0 <tcp_eff_send_mss>
   2d5ec:	e0bffa0d 	sth	r2,-24(fp)
#else /* TCP_CALCULATE_EFF_SEND_MSS */
    mss = TCP_MSS;
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
    *opts = TCP_BUILD_MSS_OPTION(mss);
   2d5f0:	e0bffa0b 	ldhu	r2,-24(fp)
   2d5f4:	10808134 	orhi	r2,r2,516
   2d5f8:	1004d63a 	srli	r2,r2,24
   2d5fc:	1007883a 	mov	r3,r2
   2d600:	e0bffa0b 	ldhu	r2,-24(fp)
   2d604:	10808134 	orhi	r2,r2,516
   2d608:	1005d23a 	srai	r2,r2,8
   2d60c:	10bfc00c 	andi	r2,r2,65280
   2d610:	1886b03a 	or	r3,r3,r2
   2d614:	e0bffa0b 	ldhu	r2,-24(fp)
   2d618:	10bfc00c 	andi	r2,r2,65280
   2d61c:	1004923a 	slli	r2,r2,8
   2d620:	1886b03a 	or	r3,r3,r2
   2d624:	e0bffa0b 	ldhu	r2,-24(fp)
   2d628:	1004963a 	slli	r2,r2,24
   2d62c:	1884b03a 	or	r2,r3,r2
   2d630:	1007883a 	mov	r3,r2
   2d634:	e0bff917 	ldw	r2,-28(fp)
   2d638:	10c00015 	stw	r3,0(r2)
    opts += 1;
   2d63c:	e0bff917 	ldw	r2,-28(fp)
   2d640:	10800104 	addi	r2,r2,4
   2d644:	e0bff915 	stw	r2,-28(fp)
  }
#endif

  /* Set retransmission timer running if it is not currently enabled 
     This must be set before checking the route. */
  if (pcb->rtime == -1) {
   2d648:	e0bfff17 	ldw	r2,-4(fp)
   2d64c:	10800e0b 	ldhu	r2,56(r2)
   2d650:	10bfffcc 	andi	r2,r2,65535
   2d654:	10a0001c 	xori	r2,r2,32768
   2d658:	10a00004 	addi	r2,r2,-32768
   2d65c:	10bfffd8 	cmpnei	r2,r2,-1
   2d660:	1000021e 	bne	r2,zero,2d66c <tcp_output_segment+0x200>
    pcb->rtime = 0;
   2d664:	e0bfff17 	ldw	r2,-4(fp)
   2d668:	10000e0d 	sth	zero,56(r2)
  }

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
   2d66c:	e0bfff17 	ldw	r2,-4(fp)
   2d670:	10000326 	beq	r2,zero,2d680 <tcp_output_segment+0x214>
   2d674:	e0bfff17 	ldw	r2,-4(fp)
   2d678:	10800017 	ldw	r2,0(r2)
   2d67c:	10000d1e 	bne	r2,zero,2d6b4 <tcp_output_segment+0x248>
    netif = ip_route(&(pcb->local_ip), &(pcb->remote_ip));
   2d680:	e0ffff17 	ldw	r3,-4(fp)
   2d684:	e0bfff17 	ldw	r2,-4(fp)
   2d688:	10800104 	addi	r2,r2,4
   2d68c:	1809883a 	mov	r4,r3
   2d690:	100b883a 	mov	r5,r2
   2d694:	001ecb40 	call	1ecb4 <ip_route>
   2d698:	e0bffb15 	stw	r2,-20(fp)
    if (netif == NULL) {
   2d69c:	e0bffb17 	ldw	r2,-20(fp)
   2d6a0:	1000dd26 	beq	r2,zero,2da18 <tcp_output_segment+0x5ac>
      return;
    }
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
   2d6a4:	e0bffb17 	ldw	r2,-20(fp)
   2d6a8:	10c00117 	ldw	r3,4(r2)
   2d6ac:	e0bfff17 	ldw	r2,-4(fp)
   2d6b0:	10c00015 	stw	r3,0(r2)
  }

  if (pcb->rttest == 0) {
   2d6b4:	e0bfff17 	ldw	r2,-4(fp)
   2d6b8:	10800f17 	ldw	r2,60(r2)
   2d6bc:	1000401e 	bne	r2,zero,2d7c0 <tcp_output_segment+0x354>
    pcb->rttest = tcp_ticks;
   2d6c0:	00800134 	movhi	r2,4
   2d6c4:	109ef304 	addi	r2,r2,31692
   2d6c8:	10c00017 	ldw	r3,0(r2)
   2d6cc:	e0bfff17 	ldw	r2,-4(fp)
   2d6d0:	10c00f15 	stw	r3,60(r2)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
   2d6d4:	e0bffe17 	ldw	r2,-8(fp)
   2d6d8:	10800417 	ldw	r2,16(r2)
   2d6dc:	10c00103 	ldbu	r3,4(r2)
   2d6e0:	11000143 	ldbu	r4,5(r2)
   2d6e4:	2008923a 	slli	r4,r4,8
   2d6e8:	20c6b03a 	or	r3,r4,r3
   2d6ec:	11000183 	ldbu	r4,6(r2)
   2d6f0:	2008943a 	slli	r4,r4,16
   2d6f4:	20c6b03a 	or	r3,r4,r3
   2d6f8:	108001c3 	ldbu	r2,7(r2)
   2d6fc:	1004963a 	slli	r2,r2,24
   2d700:	10c4b03a 	or	r2,r2,r3
   2d704:	1006d63a 	srli	r3,r2,24
   2d708:	e0bffe17 	ldw	r2,-8(fp)
   2d70c:	10800417 	ldw	r2,16(r2)
   2d710:	11000103 	ldbu	r4,4(r2)
   2d714:	11400143 	ldbu	r5,5(r2)
   2d718:	280a923a 	slli	r5,r5,8
   2d71c:	2908b03a 	or	r4,r5,r4
   2d720:	11400183 	ldbu	r5,6(r2)
   2d724:	280a943a 	slli	r5,r5,16
   2d728:	2908b03a 	or	r4,r5,r4
   2d72c:	108001c3 	ldbu	r2,7(r2)
   2d730:	1004963a 	slli	r2,r2,24
   2d734:	1104b03a 	or	r2,r2,r4
   2d738:	1004d23a 	srli	r2,r2,8
   2d73c:	10bfc00c 	andi	r2,r2,65280
   2d740:	1886b03a 	or	r3,r3,r2
   2d744:	e0bffe17 	ldw	r2,-8(fp)
   2d748:	10800417 	ldw	r2,16(r2)
   2d74c:	11000103 	ldbu	r4,4(r2)
   2d750:	11400143 	ldbu	r5,5(r2)
   2d754:	280a923a 	slli	r5,r5,8
   2d758:	2908b03a 	or	r4,r5,r4
   2d75c:	11400183 	ldbu	r5,6(r2)
   2d760:	280a943a 	slli	r5,r5,16
   2d764:	2908b03a 	or	r4,r5,r4
   2d768:	108001c3 	ldbu	r2,7(r2)
   2d76c:	1004963a 	slli	r2,r2,24
   2d770:	1104b03a 	or	r2,r2,r4
   2d774:	10bfc00c 	andi	r2,r2,65280
   2d778:	1004923a 	slli	r2,r2,8
   2d77c:	1886b03a 	or	r3,r3,r2
   2d780:	e0bffe17 	ldw	r2,-8(fp)
   2d784:	10800417 	ldw	r2,16(r2)
   2d788:	11000103 	ldbu	r4,4(r2)
   2d78c:	11400143 	ldbu	r5,5(r2)
   2d790:	280a923a 	slli	r5,r5,8
   2d794:	2908b03a 	or	r4,r5,r4
   2d798:	11400183 	ldbu	r5,6(r2)
   2d79c:	280a943a 	slli	r5,r5,16
   2d7a0:	2908b03a 	or	r4,r5,r4
   2d7a4:	108001c3 	ldbu	r2,7(r2)
   2d7a8:	1004963a 	slli	r2,r2,24
   2d7ac:	1104b03a 	or	r2,r2,r4
   2d7b0:	1004963a 	slli	r2,r2,24
   2d7b4:	1886b03a 	or	r3,r3,r2
   2d7b8:	e0bfff17 	ldw	r2,-4(fp)
   2d7bc:	10c01015 	stw	r3,64(r2)
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
   2d7c0:	e0bffe17 	ldw	r2,-8(fp)
   2d7c4:	10800417 	ldw	r2,16(r2)
   2d7c8:	1007883a 	mov	r3,r2
   2d7cc:	e0bffe17 	ldw	r2,-8(fp)
   2d7d0:	10800117 	ldw	r2,4(r2)
   2d7d4:	10800117 	ldw	r2,4(r2)
   2d7d8:	1885c83a 	sub	r2,r3,r2
   2d7dc:	e0bffc0d 	sth	r2,-16(fp)

  seg->p->len -= len;
   2d7e0:	e0bffe17 	ldw	r2,-8(fp)
   2d7e4:	10800117 	ldw	r2,4(r2)
   2d7e8:	e0fffe17 	ldw	r3,-8(fp)
   2d7ec:	18c00117 	ldw	r3,4(r3)
   2d7f0:	1900028b 	ldhu	r4,10(r3)
   2d7f4:	e0fffc0b 	ldhu	r3,-16(fp)
   2d7f8:	20c7c83a 	sub	r3,r4,r3
   2d7fc:	10c0028d 	sth	r3,10(r2)
  seg->p->tot_len -= len;
   2d800:	e0bffe17 	ldw	r2,-8(fp)
   2d804:	10800117 	ldw	r2,4(r2)
   2d808:	e0fffe17 	ldw	r3,-8(fp)
   2d80c:	18c00117 	ldw	r3,4(r3)
   2d810:	1900020b 	ldhu	r4,8(r3)
   2d814:	e0fffc0b 	ldhu	r3,-16(fp)
   2d818:	20c7c83a 	sub	r3,r4,r3
   2d81c:	10c0020d 	sth	r3,8(r2)

  seg->p->payload = seg->tcphdr;
   2d820:	e0bffe17 	ldw	r2,-8(fp)
   2d824:	10800117 	ldw	r2,4(r2)
   2d828:	e0fffe17 	ldw	r3,-8(fp)
   2d82c:	18c00417 	ldw	r3,16(r3)
   2d830:	10c00115 	stw	r3,4(r2)

  seg->tcphdr->chksum = 0;
   2d834:	e0bffe17 	ldw	r2,-8(fp)
   2d838:	10800417 	ldw	r2,16(r2)
   2d83c:	10c00403 	ldbu	r3,16(r2)
   2d840:	1806703a 	and	r3,r3,zero
   2d844:	10c00405 	stb	r3,16(r2)
   2d848:	10c00443 	ldbu	r3,17(r2)
   2d84c:	1806703a 	and	r3,r3,zero
   2d850:	10c00445 	stb	r3,17(r2)
      LWIP_ASSERT("data included but not checksummed",
        seg->p->tot_len == (TCPH_HDRLEN(seg->tcphdr) * 4));
    }

    /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
    acc = inet_chksum_pseudo_partial(seg->p, &(pcb->local_ip),
   2d854:	e0bffe17 	ldw	r2,-8(fp)
   2d858:	11000117 	ldw	r4,4(r2)
   2d85c:	e17fff17 	ldw	r5,-4(fp)
   2d860:	e0bfff17 	ldw	r2,-4(fp)
   2d864:	10c00104 	addi	r3,r2,4
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len, TCPH_HDRLEN(seg->tcphdr) * 4);
   2d868:	e0bffe17 	ldw	r2,-8(fp)
   2d86c:	10800117 	ldw	r2,4(r2)
   2d870:	1080020b 	ldhu	r2,8(r2)
      LWIP_ASSERT("data included but not checksummed",
        seg->p->tot_len == (TCPH_HDRLEN(seg->tcphdr) * 4));
    }

    /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
    acc = inet_chksum_pseudo_partial(seg->p, &(pcb->local_ip),
   2d874:	11bfffcc 	andi	r6,r2,65535
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len, TCPH_HDRLEN(seg->tcphdr) * 4);
   2d878:	e0bffe17 	ldw	r2,-8(fp)
   2d87c:	10800417 	ldw	r2,16(r2)
   2d880:	11c00303 	ldbu	r7,12(r2)
   2d884:	10800343 	ldbu	r2,13(r2)
   2d888:	1004923a 	slli	r2,r2,8
   2d88c:	11c4b03a 	or	r2,r2,r7
   2d890:	10bfffcc 	andi	r2,r2,65535
   2d894:	1004d23a 	srli	r2,r2,8
   2d898:	11ffffcc 	andi	r7,r2,65535
   2d89c:	e0bffe17 	ldw	r2,-8(fp)
   2d8a0:	10800417 	ldw	r2,16(r2)
   2d8a4:	12000303 	ldbu	r8,12(r2)
   2d8a8:	10800343 	ldbu	r2,13(r2)
   2d8ac:	1004923a 	slli	r2,r2,8
   2d8b0:	1204b03a 	or	r2,r2,r8
   2d8b4:	10bfffcc 	andi	r2,r2,65535
   2d8b8:	1004923a 	slli	r2,r2,8
   2d8bc:	10bfffcc 	andi	r2,r2,65535
   2d8c0:	3884b03a 	or	r2,r7,r2
   2d8c4:	1005d33a 	srai	r2,r2,12
      LWIP_ASSERT("data included but not checksummed",
        seg->p->tot_len == (TCPH_HDRLEN(seg->tcphdr) * 4));
    }

    /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
    acc = inet_chksum_pseudo_partial(seg->p, &(pcb->local_ip),
   2d8c8:	1085883a 	add	r2,r2,r2
   2d8cc:	1085883a 	add	r2,r2,r2
   2d8d0:	10bfffcc 	andi	r2,r2,65535
   2d8d4:	d9800015 	stw	r6,0(sp)
   2d8d8:	d8800115 	stw	r2,4(sp)
   2d8dc:	180d883a 	mov	r6,r3
   2d8e0:	01c00184 	movi	r7,6
   2d8e4:	003e4a40 	call	3e4a4 <inet_chksum_pseudo_partial>
   2d8e8:	10bfffcc 	andi	r2,r2,65535
   2d8ec:	e0bffd15 	stw	r2,-12(fp)
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len, TCPH_HDRLEN(seg->tcphdr) * 4);
    /* add payload checksum */
    if (seg->chksum_swapped) {
   2d8f0:	e0bffe17 	ldw	r2,-8(fp)
   2d8f4:	10800303 	ldbu	r2,12(r2)
   2d8f8:	10803fcc 	andi	r2,r2,255
   2d8fc:	10000f26 	beq	r2,zero,2d93c <tcp_output_segment+0x4d0>
      seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
   2d900:	e0bffe17 	ldw	r2,-8(fp)
   2d904:	1080028b 	ldhu	r2,10(r2)
   2d908:	10bfffcc 	andi	r2,r2,65535
   2d90c:	1004d23a 	srli	r2,r2,8
   2d910:	1007883a 	mov	r3,r2
   2d914:	e0bffe17 	ldw	r2,-8(fp)
   2d918:	1080028b 	ldhu	r2,10(r2)
   2d91c:	10bfffcc 	andi	r2,r2,65535
   2d920:	1004923a 	slli	r2,r2,8
   2d924:	1884b03a 	or	r2,r3,r2
   2d928:	1007883a 	mov	r3,r2
   2d92c:	e0bffe17 	ldw	r2,-8(fp)
   2d930:	10c0028d 	sth	r3,10(r2)
      seg->chksum_swapped = 0;
   2d934:	e0bffe17 	ldw	r2,-8(fp)
   2d938:	10000305 	stb	zero,12(r2)
    }
    acc += (u16_t)~(seg->chksum);
   2d93c:	e0bffe17 	ldw	r2,-8(fp)
   2d940:	1080028b 	ldhu	r2,10(r2)
   2d944:	0084303a 	nor	r2,zero,r2
   2d948:	10bfffcc 	andi	r2,r2,65535
   2d94c:	e0fffd17 	ldw	r3,-12(fp)
   2d950:	1885883a 	add	r2,r3,r2
   2d954:	e0bffd15 	stw	r2,-12(fp)
    seg->tcphdr->chksum = FOLD_U32T(acc);
   2d958:	e0bffe17 	ldw	r2,-8(fp)
   2d95c:	10800417 	ldw	r2,16(r2)
   2d960:	e0fffd17 	ldw	r3,-12(fp)
   2d964:	1806d43a 	srli	r3,r3,16
   2d968:	1809883a 	mov	r4,r3
   2d96c:	e0fffd17 	ldw	r3,-12(fp)
   2d970:	20c7883a 	add	r3,r4,r3
   2d974:	193fffcc 	andi	r4,r3,65535
   2d978:	21003fcc 	andi	r4,r4,255
   2d97c:	11400403 	ldbu	r5,16(r2)
   2d980:	280a703a 	and	r5,r5,zero
   2d984:	2908b03a 	or	r4,r5,r4
   2d988:	11000405 	stb	r4,16(r2)
   2d98c:	18ffffcc 	andi	r3,r3,65535
   2d990:	1806d23a 	srli	r3,r3,8
   2d994:	18ffffcc 	andi	r3,r3,65535
   2d998:	11000443 	ldbu	r4,17(r2)
   2d99c:	2008703a 	and	r4,r4,zero
   2d9a0:	20c6b03a 	or	r3,r4,r3
   2d9a4:	10c00445 	stb	r3,17(r2)
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
         &(pcb->remote_ip),
         IP_PROTO_TCP, seg->p->tot_len);
#endif /* TCP_CHECKSUM_ON_COPY */
#endif /* CHECKSUM_GEN_TCP */
  TCP_STATS_INC(tcp.xmit);
   2d9a8:	008001f4 	movhi	r2,7
   2d9ac:	10ac6e04 	addi	r2,r2,-20040
   2d9b0:	10804817 	ldw	r2,288(r2)
   2d9b4:	10c00044 	addi	r3,r2,1
   2d9b8:	008001f4 	movhi	r2,7
   2d9bc:	10ac6e04 	addi	r2,r2,-20040
   2d9c0:	10c04815 	stw	r3,288(r2)

#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
   2d9c4:	e0bffe17 	ldw	r2,-8(fp)
   2d9c8:	11000117 	ldw	r4,4(r2)
   2d9cc:	e17fff17 	ldw	r5,-4(fp)
   2d9d0:	e0bfff17 	ldw	r2,-4(fp)
   2d9d4:	10c00104 	addi	r3,r2,4
   2d9d8:	e0bfff17 	ldw	r2,-4(fp)
   2d9dc:	10800283 	ldbu	r2,10(r2)
   2d9e0:	10803fcc 	andi	r2,r2,255
   2d9e4:	e1bfff17 	ldw	r6,-4(fp)
   2d9e8:	31800243 	ldbu	r6,9(r6)
   2d9ec:	31c03fcc 	andi	r7,r6,255
   2d9f0:	e1bfff17 	ldw	r6,-4(fp)
   2d9f4:	318002c4 	addi	r6,r6,11
   2d9f8:	d9c00015 	stw	r7,0(sp)
   2d9fc:	01c00184 	movi	r7,6
   2da00:	d9c00115 	stw	r7,4(sp)
   2da04:	d9800215 	stw	r6,8(sp)
   2da08:	180d883a 	mov	r6,r3
   2da0c:	100f883a 	mov	r7,r2
   2da10:	001f9700 	call	1f970 <ip_output_hinted>
   2da14:	00000106 	br	2da1c <tcp_output_segment+0x5b0>
  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
    netif = ip_route(&(pcb->local_ip), &(pcb->remote_ip));
    if (netif == NULL) {
      return;
   2da18:	0001883a 	nop
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
}
   2da1c:	e037883a 	mov	sp,fp
   2da20:	dfc00117 	ldw	ra,4(sp)
   2da24:	df000017 	ldw	fp,0(sp)
   2da28:	dec00204 	addi	sp,sp,8
   2da2c:	f800283a 	ret

0002da30 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  ip_addr_t *local_ip, ip_addr_t *remote_ip,
  u16_t local_port, u16_t remote_port)
{
   2da30:	defff404 	addi	sp,sp,-48
   2da34:	dfc00b15 	stw	ra,44(sp)
   2da38:	df000a15 	stw	fp,40(sp)
   2da3c:	df000a04 	addi	fp,sp,40
   2da40:	e13ffa15 	stw	r4,-24(fp)
   2da44:	e17ffb15 	stw	r5,-20(fp)
   2da48:	e1bffc15 	stw	r6,-16(fp)
   2da4c:	e1fffd15 	stw	r7,-12(fp)
   2da50:	e0c00217 	ldw	r3,8(fp)
   2da54:	e0800317 	ldw	r2,12(fp)
   2da58:	e0fffe0d 	sth	r3,-8(fp)
   2da5c:	e0bfff0d 	sth	r2,-4(fp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
   2da60:	01000044 	movi	r4,1
   2da64:	01400504 	movi	r5,20
   2da68:	000d883a 	mov	r6,zero
   2da6c:	0022fa00 	call	22fa0 <pbuf_alloc>
   2da70:	e0bff815 	stw	r2,-32(fp)
  if (p == NULL) {
   2da74:	e0bff817 	ldw	r2,-32(fp)
   2da78:	1000be26 	beq	r2,zero,2dd74 <tcp_rst+0x344>
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
   2da7c:	e0bff817 	ldw	r2,-32(fp)
   2da80:	10800117 	ldw	r2,4(r2)
   2da84:	e0bff915 	stw	r2,-28(fp)
  tcphdr->src = htons(local_port);
   2da88:	e0bffe0b 	ldhu	r2,-8(fp)
   2da8c:	1004d23a 	srli	r2,r2,8
   2da90:	1007883a 	mov	r3,r2
   2da94:	e0bffe0b 	ldhu	r2,-8(fp)
   2da98:	1004923a 	slli	r2,r2,8
   2da9c:	1884b03a 	or	r2,r3,r2
   2daa0:	1007883a 	mov	r3,r2
   2daa4:	e0bff917 	ldw	r2,-28(fp)
   2daa8:	193fffcc 	andi	r4,r3,65535
   2daac:	21003fcc 	andi	r4,r4,255
   2dab0:	11400003 	ldbu	r5,0(r2)
   2dab4:	280a703a 	and	r5,r5,zero
   2dab8:	2908b03a 	or	r4,r5,r4
   2dabc:	11000005 	stb	r4,0(r2)
   2dac0:	18ffffcc 	andi	r3,r3,65535
   2dac4:	1806d23a 	srli	r3,r3,8
   2dac8:	18ffffcc 	andi	r3,r3,65535
   2dacc:	11000043 	ldbu	r4,1(r2)
   2dad0:	2008703a 	and	r4,r4,zero
   2dad4:	20c6b03a 	or	r3,r4,r3
   2dad8:	10c00045 	stb	r3,1(r2)
  tcphdr->dest = htons(remote_port);
   2dadc:	e0bfff0b 	ldhu	r2,-4(fp)
   2dae0:	1004d23a 	srli	r2,r2,8
   2dae4:	1007883a 	mov	r3,r2
   2dae8:	e0bfff0b 	ldhu	r2,-4(fp)
   2daec:	1004923a 	slli	r2,r2,8
   2daf0:	1884b03a 	or	r2,r3,r2
   2daf4:	1007883a 	mov	r3,r2
   2daf8:	e0bff917 	ldw	r2,-28(fp)
   2dafc:	193fffcc 	andi	r4,r3,65535
   2db00:	21003fcc 	andi	r4,r4,255
   2db04:	11400083 	ldbu	r5,2(r2)
   2db08:	280a703a 	and	r5,r5,zero
   2db0c:	2908b03a 	or	r4,r5,r4
   2db10:	11000085 	stb	r4,2(r2)
   2db14:	18ffffcc 	andi	r3,r3,65535
   2db18:	1806d23a 	srli	r3,r3,8
   2db1c:	18ffffcc 	andi	r3,r3,65535
   2db20:	110000c3 	ldbu	r4,3(r2)
   2db24:	2008703a 	and	r4,r4,zero
   2db28:	20c6b03a 	or	r3,r4,r3
   2db2c:	10c000c5 	stb	r3,3(r2)
  tcphdr->seqno = htonl(seqno);
   2db30:	e0bffa17 	ldw	r2,-24(fp)
   2db34:	1006d63a 	srli	r3,r2,24
   2db38:	e0bffa17 	ldw	r2,-24(fp)
   2db3c:	1004d23a 	srli	r2,r2,8
   2db40:	10bfc00c 	andi	r2,r2,65280
   2db44:	1886b03a 	or	r3,r3,r2
   2db48:	e0bffa17 	ldw	r2,-24(fp)
   2db4c:	10bfc00c 	andi	r2,r2,65280
   2db50:	1004923a 	slli	r2,r2,8
   2db54:	1886b03a 	or	r3,r3,r2
   2db58:	e0bffa17 	ldw	r2,-24(fp)
   2db5c:	1004963a 	slli	r2,r2,24
   2db60:	1886b03a 	or	r3,r3,r2
   2db64:	e0bff917 	ldw	r2,-28(fp)
   2db68:	19003fcc 	andi	r4,r3,255
   2db6c:	11400103 	ldbu	r5,4(r2)
   2db70:	280a703a 	and	r5,r5,zero
   2db74:	2908b03a 	or	r4,r5,r4
   2db78:	11000105 	stb	r4,4(r2)
   2db7c:	1808d23a 	srli	r4,r3,8
   2db80:	21003fcc 	andi	r4,r4,255
   2db84:	11400143 	ldbu	r5,5(r2)
   2db88:	280a703a 	and	r5,r5,zero
   2db8c:	2908b03a 	or	r4,r5,r4
   2db90:	11000145 	stb	r4,5(r2)
   2db94:	1808d43a 	srli	r4,r3,16
   2db98:	21003fcc 	andi	r4,r4,255
   2db9c:	11400183 	ldbu	r5,6(r2)
   2dba0:	280a703a 	and	r5,r5,zero
   2dba4:	2908b03a 	or	r4,r5,r4
   2dba8:	11000185 	stb	r4,6(r2)
   2dbac:	1806d63a 	srli	r3,r3,24
   2dbb0:	110001c3 	ldbu	r4,7(r2)
   2dbb4:	2008703a 	and	r4,r4,zero
   2dbb8:	20c6b03a 	or	r3,r4,r3
   2dbbc:	10c001c5 	stb	r3,7(r2)
  tcphdr->ackno = htonl(ackno);
   2dbc0:	e0bffb17 	ldw	r2,-20(fp)
   2dbc4:	1006d63a 	srli	r3,r2,24
   2dbc8:	e0bffb17 	ldw	r2,-20(fp)
   2dbcc:	1004d23a 	srli	r2,r2,8
   2dbd0:	10bfc00c 	andi	r2,r2,65280
   2dbd4:	1886b03a 	or	r3,r3,r2
   2dbd8:	e0bffb17 	ldw	r2,-20(fp)
   2dbdc:	10bfc00c 	andi	r2,r2,65280
   2dbe0:	1004923a 	slli	r2,r2,8
   2dbe4:	1886b03a 	or	r3,r3,r2
   2dbe8:	e0bffb17 	ldw	r2,-20(fp)
   2dbec:	1004963a 	slli	r2,r2,24
   2dbf0:	1886b03a 	or	r3,r3,r2
   2dbf4:	e0bff917 	ldw	r2,-28(fp)
   2dbf8:	19003fcc 	andi	r4,r3,255
   2dbfc:	11400203 	ldbu	r5,8(r2)
   2dc00:	280a703a 	and	r5,r5,zero
   2dc04:	2908b03a 	or	r4,r5,r4
   2dc08:	11000205 	stb	r4,8(r2)
   2dc0c:	1808d23a 	srli	r4,r3,8
   2dc10:	21003fcc 	andi	r4,r4,255
   2dc14:	11400243 	ldbu	r5,9(r2)
   2dc18:	280a703a 	and	r5,r5,zero
   2dc1c:	2908b03a 	or	r4,r5,r4
   2dc20:	11000245 	stb	r4,9(r2)
   2dc24:	1808d43a 	srli	r4,r3,16
   2dc28:	21003fcc 	andi	r4,r4,255
   2dc2c:	11400283 	ldbu	r5,10(r2)
   2dc30:	280a703a 	and	r5,r5,zero
   2dc34:	2908b03a 	or	r4,r5,r4
   2dc38:	11000285 	stb	r4,10(r2)
   2dc3c:	1806d63a 	srli	r3,r3,24
   2dc40:	110002c3 	ldbu	r4,11(r2)
   2dc44:	2008703a 	and	r4,r4,zero
   2dc48:	20c6b03a 	or	r3,r4,r3
   2dc4c:	10c002c5 	stb	r3,11(r2)
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
   2dc50:	e0bff917 	ldw	r2,-28(fp)
   2dc54:	10c00303 	ldbu	r3,12(r2)
   2dc58:	1806703a 	and	r3,r3,zero
   2dc5c:	18c01414 	ori	r3,r3,80
   2dc60:	10c00305 	stb	r3,12(r2)
   2dc64:	10c00343 	ldbu	r3,13(r2)
   2dc68:	1806703a 	and	r3,r3,zero
   2dc6c:	18c00514 	ori	r3,r3,20
   2dc70:	10c00345 	stb	r3,13(r2)
  tcphdr->wnd = PP_HTONS(TCP_WND);
   2dc74:	e0bff917 	ldw	r2,-28(fp)
   2dc78:	10c00383 	ldbu	r3,14(r2)
   2dc7c:	1806703a 	and	r3,r3,zero
   2dc80:	18c00814 	ori	r3,r3,32
   2dc84:	10c00385 	stb	r3,14(r2)
   2dc88:	10c003c3 	ldbu	r3,15(r2)
   2dc8c:	1806703a 	and	r3,r3,zero
   2dc90:	10c003c5 	stb	r3,15(r2)
  tcphdr->chksum = 0;
   2dc94:	e0bff917 	ldw	r2,-28(fp)
   2dc98:	10c00403 	ldbu	r3,16(r2)
   2dc9c:	1806703a 	and	r3,r3,zero
   2dca0:	10c00405 	stb	r3,16(r2)
   2dca4:	10c00443 	ldbu	r3,17(r2)
   2dca8:	1806703a 	and	r3,r3,zero
   2dcac:	10c00445 	stb	r3,17(r2)
  tcphdr->urgp = 0;
   2dcb0:	e0bff917 	ldw	r2,-28(fp)
   2dcb4:	10c00483 	ldbu	r3,18(r2)
   2dcb8:	1806703a 	and	r3,r3,zero
   2dcbc:	10c00485 	stb	r3,18(r2)
   2dcc0:	10c004c3 	ldbu	r3,19(r2)
   2dcc4:	1806703a 	and	r3,r3,zero
   2dcc8:	10c004c5 	stb	r3,19(r2)

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
              IP_PROTO_TCP, p->tot_len);
   2dccc:	e0bff817 	ldw	r2,-32(fp)
   2dcd0:	1080020b 	ldhu	r2,8(r2)
  tcphdr->wnd = PP_HTONS(TCP_WND);
  tcphdr->chksum = 0;
  tcphdr->urgp = 0;

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
   2dcd4:	10bfffcc 	andi	r2,r2,65535
   2dcd8:	d8800015 	stw	r2,0(sp)
   2dcdc:	e13ff817 	ldw	r4,-32(fp)
   2dce0:	e17ffc17 	ldw	r5,-16(fp)
   2dce4:	e1bffd17 	ldw	r6,-12(fp)
   2dce8:	01c00184 	movi	r7,6
   2dcec:	003e2ac0 	call	3e2ac <inet_chksum_pseudo>
   2dcf0:	1007883a 	mov	r3,r2
   2dcf4:	e0bff917 	ldw	r2,-28(fp)
   2dcf8:	193fffcc 	andi	r4,r3,65535
   2dcfc:	21003fcc 	andi	r4,r4,255
   2dd00:	11400403 	ldbu	r5,16(r2)
   2dd04:	280a703a 	and	r5,r5,zero
   2dd08:	2908b03a 	or	r4,r5,r4
   2dd0c:	11000405 	stb	r4,16(r2)
   2dd10:	18ffffcc 	andi	r3,r3,65535
   2dd14:	1806d23a 	srli	r3,r3,8
   2dd18:	18ffffcc 	andi	r3,r3,65535
   2dd1c:	11000443 	ldbu	r4,17(r2)
   2dd20:	2008703a 	and	r4,r4,zero
   2dd24:	20c6b03a 	or	r3,r4,r3
   2dd28:	10c00445 	stb	r3,17(r2)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
   2dd2c:	008001f4 	movhi	r2,7
   2dd30:	10ac6e04 	addi	r2,r2,-20040
   2dd34:	10804817 	ldw	r2,288(r2)
   2dd38:	10c00044 	addi	r3,r2,1
   2dd3c:	008001f4 	movhi	r2,7
   2dd40:	10ac6e04 	addi	r2,r2,-20040
   2dd44:	10c04815 	stw	r3,288(r2)
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
   2dd48:	d8000015 	stw	zero,0(sp)
   2dd4c:	00800184 	movi	r2,6
   2dd50:	d8800115 	stw	r2,4(sp)
   2dd54:	e13ff817 	ldw	r4,-32(fp)
   2dd58:	e17ffc17 	ldw	r5,-16(fp)
   2dd5c:	e1bffd17 	ldw	r6,-12(fp)
   2dd60:	01c01004 	movi	r7,64
   2dd64:	001f8bc0 	call	1f8bc <ip_output>
  pbuf_free(p);
   2dd68:	e13ff817 	ldw	r4,-32(fp)
   2dd6c:	00237600 	call	23760 <pbuf_free>
   2dd70:	00000106 	br	2dd78 <tcp_rst+0x348>
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  if (p == NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
   2dd74:	0001883a 	nop
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  pbuf_free(p);
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
   2dd78:	e037883a 	mov	sp,fp
   2dd7c:	dfc00117 	ldw	ra,4(sp)
   2dd80:	df000017 	ldw	fp,0(sp)
   2dd84:	dec00204 	addi	sp,sp,8
   2dd88:	f800283a 	ret

0002dd8c <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
   2dd8c:	defffc04 	addi	sp,sp,-16
   2dd90:	dfc00315 	stw	ra,12(sp)
   2dd94:	df000215 	stw	fp,8(sp)
   2dd98:	df000204 	addi	fp,sp,8
   2dd9c:	e13fff15 	stw	r4,-4(fp)
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
   2dda0:	e0bfff17 	ldw	r2,-4(fp)
   2dda4:	10801d17 	ldw	r2,116(r2)
   2dda8:	10001f26 	beq	r2,zero,2de28 <tcp_rexmit_rto+0x9c>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
   2ddac:	e0bfff17 	ldw	r2,-4(fp)
   2ddb0:	10801d17 	ldw	r2,116(r2)
   2ddb4:	e0bffe15 	stw	r2,-8(fp)
   2ddb8:	00000306 	br	2ddc8 <tcp_rexmit_rto+0x3c>
   2ddbc:	e0bffe17 	ldw	r2,-8(fp)
   2ddc0:	10800017 	ldw	r2,0(r2)
   2ddc4:	e0bffe15 	stw	r2,-8(fp)
   2ddc8:	e0bffe17 	ldw	r2,-8(fp)
   2ddcc:	10800017 	ldw	r2,0(r2)
   2ddd0:	103ffa1e 	bne	r2,zero,2ddbc <tcp_rexmit_rto+0x30>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
   2ddd4:	e0bfff17 	ldw	r2,-4(fp)
   2ddd8:	10c01c17 	ldw	r3,112(r2)
   2dddc:	e0bffe17 	ldw	r2,-8(fp)
   2dde0:	10c00015 	stw	r3,0(r2)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
   2dde4:	e0bfff17 	ldw	r2,-4(fp)
   2dde8:	10c01d17 	ldw	r3,116(r2)
   2ddec:	e0bfff17 	ldw	r2,-4(fp)
   2ddf0:	10c01c15 	stw	r3,112(r2)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
   2ddf4:	e0bfff17 	ldw	r2,-4(fp)
   2ddf8:	10001d15 	stw	zero,116(r2)
  /* last unsent hasn't changed, no need to reset unsent_oversize */

  /* increment number of retransmissions */
  ++pcb->nrtx;
   2ddfc:	e0bfff17 	ldw	r2,-4(fp)
   2de00:	10801283 	ldbu	r2,74(r2)
   2de04:	10800044 	addi	r2,r2,1
   2de08:	1007883a 	mov	r3,r2
   2de0c:	e0bfff17 	ldw	r2,-4(fp)
   2de10:	10c01285 	stb	r3,74(r2)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
   2de14:	e0bfff17 	ldw	r2,-4(fp)
   2de18:	10000f15 	stw	zero,60(r2)

  /* Do the actual retransmission */
  tcp_output(pcb);
   2de1c:	e13fff17 	ldw	r4,-4(fp)
   2de20:	002c9d00 	call	2c9d0 <tcp_output>
   2de24:	00000106 	br	2de2c <tcp_rexmit_rto+0xa0>
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
    return;
   2de28:	0001883a 	nop
  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;

  /* Do the actual retransmission */
  tcp_output(pcb);
}
   2de2c:	e037883a 	mov	sp,fp
   2de30:	dfc00117 	ldw	ra,4(sp)
   2de34:	df000017 	ldw	fp,0(sp)
   2de38:	dec00204 	addi	sp,sp,8
   2de3c:	f800283a 	ret

0002de40 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
   2de40:	defffc04 	addi	sp,sp,-16
   2de44:	df000315 	stw	fp,12(sp)
   2de48:	df000304 	addi	fp,sp,12
   2de4c:	e13fff15 	stw	r4,-4(fp)
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
   2de50:	e0bfff17 	ldw	r2,-4(fp)
   2de54:	10801d17 	ldw	r2,116(r2)
   2de58:	10009e26 	beq	r2,zero,2e0d4 <tcp_rexmit+0x294>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
   2de5c:	e0bfff17 	ldw	r2,-4(fp)
   2de60:	10801d17 	ldw	r2,116(r2)
   2de64:	e0bffe15 	stw	r2,-8(fp)
  pcb->unacked = seg->next;
   2de68:	e0bffe17 	ldw	r2,-8(fp)
   2de6c:	10c00017 	ldw	r3,0(r2)
   2de70:	e0bfff17 	ldw	r2,-4(fp)
   2de74:	10c01d15 	stw	r3,116(r2)

  cur_seg = &(pcb->unsent);
   2de78:	e0bfff17 	ldw	r2,-4(fp)
   2de7c:	10801c04 	addi	r2,r2,112
   2de80:	e0bffd15 	stw	r2,-12(fp)
  while (*cur_seg &&
   2de84:	00000306 	br	2de94 <tcp_rexmit+0x54>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
   2de88:	e0bffd17 	ldw	r2,-12(fp)
   2de8c:	10800017 	ldw	r2,0(r2)
   2de90:	e0bffd15 	stw	r2,-12(fp)
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
   2de94:	e0bffd17 	ldw	r2,-12(fp)
   2de98:	10800017 	ldw	r2,0(r2)
   2de9c:	10007826 	beq	r2,zero,2e080 <tcp_rexmit+0x240>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
   2dea0:	e0bffd17 	ldw	r2,-12(fp)
   2dea4:	10800017 	ldw	r2,0(r2)
   2dea8:	10800417 	ldw	r2,16(r2)
   2deac:	10c00103 	ldbu	r3,4(r2)
   2deb0:	11000143 	ldbu	r4,5(r2)
   2deb4:	2008923a 	slli	r4,r4,8
   2deb8:	20c6b03a 	or	r3,r4,r3
   2debc:	11000183 	ldbu	r4,6(r2)
   2dec0:	2008943a 	slli	r4,r4,16
   2dec4:	20c6b03a 	or	r3,r4,r3
   2dec8:	108001c3 	ldbu	r2,7(r2)
   2decc:	1004963a 	slli	r2,r2,24
   2ded0:	10c4b03a 	or	r2,r2,r3
   2ded4:	1006d63a 	srli	r3,r2,24
   2ded8:	e0bffd17 	ldw	r2,-12(fp)
   2dedc:	10800017 	ldw	r2,0(r2)
   2dee0:	10800417 	ldw	r2,16(r2)
   2dee4:	11000103 	ldbu	r4,4(r2)
   2dee8:	11400143 	ldbu	r5,5(r2)
   2deec:	280a923a 	slli	r5,r5,8
   2def0:	2908b03a 	or	r4,r5,r4
   2def4:	11400183 	ldbu	r5,6(r2)
   2def8:	280a943a 	slli	r5,r5,16
   2defc:	2908b03a 	or	r4,r5,r4
   2df00:	108001c3 	ldbu	r2,7(r2)
   2df04:	1004963a 	slli	r2,r2,24
   2df08:	1104b03a 	or	r2,r2,r4
   2df0c:	1004d23a 	srli	r2,r2,8
   2df10:	10bfc00c 	andi	r2,r2,65280
   2df14:	1886b03a 	or	r3,r3,r2
   2df18:	e0bffd17 	ldw	r2,-12(fp)
   2df1c:	10800017 	ldw	r2,0(r2)
   2df20:	10800417 	ldw	r2,16(r2)
   2df24:	11000103 	ldbu	r4,4(r2)
   2df28:	11400143 	ldbu	r5,5(r2)
   2df2c:	280a923a 	slli	r5,r5,8
   2df30:	2908b03a 	or	r4,r5,r4
   2df34:	11400183 	ldbu	r5,6(r2)
   2df38:	280a943a 	slli	r5,r5,16
   2df3c:	2908b03a 	or	r4,r5,r4
   2df40:	108001c3 	ldbu	r2,7(r2)
   2df44:	1004963a 	slli	r2,r2,24
   2df48:	1104b03a 	or	r2,r2,r4
   2df4c:	10bfc00c 	andi	r2,r2,65280
   2df50:	1004923a 	slli	r2,r2,8
   2df54:	1886b03a 	or	r3,r3,r2
   2df58:	e0bffd17 	ldw	r2,-12(fp)
   2df5c:	10800017 	ldw	r2,0(r2)
   2df60:	10800417 	ldw	r2,16(r2)
   2df64:	11000103 	ldbu	r4,4(r2)
   2df68:	11400143 	ldbu	r5,5(r2)
   2df6c:	280a923a 	slli	r5,r5,8
   2df70:	2908b03a 	or	r4,r5,r4
   2df74:	11400183 	ldbu	r5,6(r2)
   2df78:	280a943a 	slli	r5,r5,16
   2df7c:	2908b03a 	or	r4,r5,r4
   2df80:	108001c3 	ldbu	r2,7(r2)
   2df84:	1004963a 	slli	r2,r2,24
   2df88:	1104b03a 	or	r2,r2,r4
   2df8c:	1004963a 	slli	r2,r2,24
   2df90:	1886b03a 	or	r3,r3,r2
   2df94:	e0bffe17 	ldw	r2,-8(fp)
   2df98:	10800417 	ldw	r2,16(r2)
   2df9c:	11000103 	ldbu	r4,4(r2)
   2dfa0:	11400143 	ldbu	r5,5(r2)
   2dfa4:	280a923a 	slli	r5,r5,8
   2dfa8:	2908b03a 	or	r4,r5,r4
   2dfac:	11400183 	ldbu	r5,6(r2)
   2dfb0:	280a943a 	slli	r5,r5,16
   2dfb4:	2908b03a 	or	r4,r5,r4
   2dfb8:	108001c3 	ldbu	r2,7(r2)
   2dfbc:	1004963a 	slli	r2,r2,24
   2dfc0:	1104b03a 	or	r2,r2,r4
   2dfc4:	1008d63a 	srli	r4,r2,24
   2dfc8:	e0bffe17 	ldw	r2,-8(fp)
   2dfcc:	10800417 	ldw	r2,16(r2)
   2dfd0:	11400103 	ldbu	r5,4(r2)
   2dfd4:	11800143 	ldbu	r6,5(r2)
   2dfd8:	300c923a 	slli	r6,r6,8
   2dfdc:	314ab03a 	or	r5,r6,r5
   2dfe0:	11800183 	ldbu	r6,6(r2)
   2dfe4:	300c943a 	slli	r6,r6,16
   2dfe8:	314ab03a 	or	r5,r6,r5
   2dfec:	108001c3 	ldbu	r2,7(r2)
   2dff0:	1004963a 	slli	r2,r2,24
   2dff4:	1144b03a 	or	r2,r2,r5
   2dff8:	1004d23a 	srli	r2,r2,8
   2dffc:	10bfc00c 	andi	r2,r2,65280
   2e000:	2088b03a 	or	r4,r4,r2
   2e004:	e0bffe17 	ldw	r2,-8(fp)
   2e008:	10800417 	ldw	r2,16(r2)
   2e00c:	11400103 	ldbu	r5,4(r2)
   2e010:	11800143 	ldbu	r6,5(r2)
   2e014:	300c923a 	slli	r6,r6,8
   2e018:	314ab03a 	or	r5,r6,r5
   2e01c:	11800183 	ldbu	r6,6(r2)
   2e020:	300c943a 	slli	r6,r6,16
   2e024:	314ab03a 	or	r5,r6,r5
   2e028:	108001c3 	ldbu	r2,7(r2)
   2e02c:	1004963a 	slli	r2,r2,24
   2e030:	1144b03a 	or	r2,r2,r5
   2e034:	10bfc00c 	andi	r2,r2,65280
   2e038:	1004923a 	slli	r2,r2,8
   2e03c:	2088b03a 	or	r4,r4,r2
   2e040:	e0bffe17 	ldw	r2,-8(fp)
   2e044:	10800417 	ldw	r2,16(r2)
   2e048:	11400103 	ldbu	r5,4(r2)
   2e04c:	11800143 	ldbu	r6,5(r2)
   2e050:	300c923a 	slli	r6,r6,8
   2e054:	314ab03a 	or	r5,r6,r5
   2e058:	11800183 	ldbu	r6,6(r2)
   2e05c:	300c943a 	slli	r6,r6,16
   2e060:	314ab03a 	or	r5,r6,r5
   2e064:	108001c3 	ldbu	r2,7(r2)
   2e068:	1004963a 	slli	r2,r2,24
   2e06c:	1144b03a 	or	r2,r2,r5
   2e070:	1004963a 	slli	r2,r2,24
   2e074:	2084b03a 	or	r2,r4,r2
   2e078:	1885c83a 	sub	r2,r3,r2
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
   2e07c:	103f8216 	blt	r2,zero,2de88 <tcp_rexmit+0x48>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
  }
  seg->next = *cur_seg;
   2e080:	e0bffd17 	ldw	r2,-12(fp)
   2e084:	10c00017 	ldw	r3,0(r2)
   2e088:	e0bffe17 	ldw	r2,-8(fp)
   2e08c:	10c00015 	stw	r3,0(r2)
  *cur_seg = seg;
   2e090:	e0bffd17 	ldw	r2,-12(fp)
   2e094:	e0fffe17 	ldw	r3,-8(fp)
   2e098:	10c00015 	stw	r3,0(r2)
#if TCP_OVERSIZE
  if (seg->next == NULL) {
   2e09c:	e0bffe17 	ldw	r2,-8(fp)
   2e0a0:	10800017 	ldw	r2,0(r2)
   2e0a4:	1000021e 	bne	r2,zero,2e0b0 <tcp_rexmit+0x270>
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
   2e0a8:	e0bfff17 	ldw	r2,-4(fp)
   2e0ac:	10001b8d 	sth	zero,110(r2)
  }
#endif /* TCP_OVERSIZE */

  ++pcb->nrtx;
   2e0b0:	e0bfff17 	ldw	r2,-4(fp)
   2e0b4:	10801283 	ldbu	r2,74(r2)
   2e0b8:	10800044 	addi	r2,r2,1
   2e0bc:	1007883a 	mov	r3,r2
   2e0c0:	e0bfff17 	ldw	r2,-4(fp)
   2e0c4:	10c01285 	stb	r3,74(r2)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
   2e0c8:	e0bfff17 	ldw	r2,-4(fp)
   2e0cc:	10000f15 	stw	zero,60(r2)
   2e0d0:	00000106 	br	2e0d8 <tcp_rexmit+0x298>
{
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
    return;
   2e0d4:	0001883a 	nop

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  /* No need to call tcp_output: we are always called from tcp_input()
     and thus tcp_output directly returns. */
}
   2e0d8:	e037883a 	mov	sp,fp
   2e0dc:	df000017 	ldw	fp,0(sp)
   2e0e0:	dec00104 	addi	sp,sp,4
   2e0e4:	f800283a 	ret

0002e0e8 <tcp_rexmit_fast>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void 
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
   2e0e8:	defffd04 	addi	sp,sp,-12
   2e0ec:	dfc00215 	stw	ra,8(sp)
   2e0f0:	df000115 	stw	fp,4(sp)
   2e0f4:	df000104 	addi	fp,sp,4
   2e0f8:	e13fff15 	stw	r4,-4(fp)
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
   2e0fc:	e0bfff17 	ldw	r2,-4(fp)
   2e100:	10801d17 	ldw	r2,116(r2)
   2e104:	10003c26 	beq	r2,zero,2e1f8 <tcp_rexmit_fast+0x110>
   2e108:	e0bfff17 	ldw	r2,-4(fp)
   2e10c:	10800883 	ldbu	r2,34(r2)
   2e110:	10803fcc 	andi	r2,r2,255
   2e114:	1080010c 	andi	r2,r2,4
   2e118:	1000371e 	bne	r2,zero,2e1f8 <tcp_rexmit_fast+0x110>
    LWIP_DEBUGF(TCP_FR_DEBUG, 
                ("tcp_receive: dupacks %"U16_F" (%"U32_F
                 "), fast retransmit %"U32_F"\n",
                 (u16_t)pcb->dupacks, pcb->lastack,
                 ntohl(pcb->unacked->tcphdr->seqno)));
    tcp_rexmit(pcb);
   2e11c:	e13fff17 	ldw	r4,-4(fp)
   2e120:	002de400 	call	2de40 <tcp_rexmit>

    /* Set ssthresh to half of the minimum of the current
     * cwnd and the advertised window */
    if (pcb->cwnd > pcb->snd_wnd) {
   2e124:	e0bfff17 	ldw	r2,-4(fp)
   2e128:	1080140b 	ldhu	r2,80(r2)
   2e12c:	e0ffff17 	ldw	r3,-4(fp)
   2e130:	18c0190b 	ldhu	r3,100(r3)
   2e134:	10bfffcc 	andi	r2,r2,65535
   2e138:	18ffffcc 	andi	r3,r3,65535
   2e13c:	1880082e 	bgeu	r3,r2,2e160 <tcp_rexmit_fast+0x78>
      pcb->ssthresh = pcb->snd_wnd / 2;
   2e140:	e0bfff17 	ldw	r2,-4(fp)
   2e144:	1080190b 	ldhu	r2,100(r2)
   2e148:	10bfffcc 	andi	r2,r2,65535
   2e14c:	1004d07a 	srli	r2,r2,1
   2e150:	1007883a 	mov	r3,r2
   2e154:	e0bfff17 	ldw	r2,-4(fp)
   2e158:	10c0148d 	sth	r3,82(r2)
   2e15c:	00000706 	br	2e17c <tcp_rexmit_fast+0x94>
    } else {
      pcb->ssthresh = pcb->cwnd / 2;
   2e160:	e0bfff17 	ldw	r2,-4(fp)
   2e164:	1080140b 	ldhu	r2,80(r2)
   2e168:	10bfffcc 	andi	r2,r2,65535
   2e16c:	1004d07a 	srli	r2,r2,1
   2e170:	1007883a 	mov	r3,r2
   2e174:	e0bfff17 	ldw	r2,-4(fp)
   2e178:	10c0148d 	sth	r3,82(r2)
    }
    
    /* The minimum value for ssthresh should be 2 MSS */
    if (pcb->ssthresh < 2*pcb->mss) {
   2e17c:	e0bfff17 	ldw	r2,-4(fp)
   2e180:	1080148b 	ldhu	r2,82(r2)
   2e184:	10ffffcc 	andi	r3,r2,65535
   2e188:	e0bfff17 	ldw	r2,-4(fp)
   2e18c:	10800e8b 	ldhu	r2,58(r2)
   2e190:	10bfffcc 	andi	r2,r2,65535
   2e194:	1085883a 	add	r2,r2,r2
   2e198:	1880060e 	bge	r3,r2,2e1b4 <tcp_rexmit_fast+0xcc>
      LWIP_DEBUGF(TCP_FR_DEBUG, 
                  ("tcp_receive: The minimum value for ssthresh %"U16_F
                   " should be min 2 mss %"U16_F"...\n",
                   pcb->ssthresh, 2*pcb->mss));
      pcb->ssthresh = 2*pcb->mss;
   2e19c:	e0bfff17 	ldw	r2,-4(fp)
   2e1a0:	10800e8b 	ldhu	r2,58(r2)
   2e1a4:	1085883a 	add	r2,r2,r2
   2e1a8:	1007883a 	mov	r3,r2
   2e1ac:	e0bfff17 	ldw	r2,-4(fp)
   2e1b0:	10c0148d 	sth	r3,82(r2)
    }
    
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
   2e1b4:	e0bfff17 	ldw	r2,-4(fp)
   2e1b8:	1100148b 	ldhu	r4,82(r2)
   2e1bc:	e0bfff17 	ldw	r2,-4(fp)
   2e1c0:	10c00e8b 	ldhu	r3,58(r2)
   2e1c4:	1805883a 	mov	r2,r3
   2e1c8:	1085883a 	add	r2,r2,r2
   2e1cc:	10c5883a 	add	r2,r2,r3
   2e1d0:	2085883a 	add	r2,r4,r2
   2e1d4:	1007883a 	mov	r3,r2
   2e1d8:	e0bfff17 	ldw	r2,-4(fp)
   2e1dc:	10c0140d 	sth	r3,80(r2)
    pcb->flags |= TF_INFR;
   2e1e0:	e0bfff17 	ldw	r2,-4(fp)
   2e1e4:	10800883 	ldbu	r2,34(r2)
   2e1e8:	10800114 	ori	r2,r2,4
   2e1ec:	1007883a 	mov	r3,r2
   2e1f0:	e0bfff17 	ldw	r2,-4(fp)
   2e1f4:	10c00885 	stb	r3,34(r2)
  } 
}
   2e1f8:	e037883a 	mov	sp,fp
   2e1fc:	dfc00117 	ldw	ra,4(sp)
   2e200:	df000017 	ldw	fp,0(sp)
   2e204:	dec00204 	addi	sp,sp,8
   2e208:	f800283a 	ret

0002e20c <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
   2e20c:	defff804 	addi	sp,sp,-32
   2e210:	dfc00715 	stw	ra,28(sp)
   2e214:	df000615 	stw	fp,24(sp)
   2e218:	df000604 	addi	fp,sp,24
   2e21c:	e13fff15 	stw	r4,-4(fp)
                          ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
   2e220:	e0bfff17 	ldw	r2,-4(fp)
   2e224:	10801517 	ldw	r2,84(r2)
   2e228:	10bfffc4 	addi	r2,r2,-1
   2e22c:	1006d63a 	srli	r3,r2,24
   2e230:	e0bfff17 	ldw	r2,-4(fp)
   2e234:	10801517 	ldw	r2,84(r2)
   2e238:	10bfffc4 	addi	r2,r2,-1
   2e23c:	1004d23a 	srli	r2,r2,8
   2e240:	10bfc00c 	andi	r2,r2,65280
   2e244:	1886b03a 	or	r3,r3,r2
   2e248:	e0bfff17 	ldw	r2,-4(fp)
   2e24c:	10801517 	ldw	r2,84(r2)
   2e250:	10bfffc4 	addi	r2,r2,-1
   2e254:	10bfc00c 	andi	r2,r2,65280
   2e258:	1004923a 	slli	r2,r2,8
   2e25c:	1886b03a 	or	r3,r3,r2
   2e260:	e0bfff17 	ldw	r2,-4(fp)
   2e264:	10801517 	ldw	r2,84(r2)
   2e268:	10bfffc4 	addi	r2,r2,-1
   2e26c:	1004963a 	slli	r2,r2,24
   2e270:	1884b03a 	or	r2,r3,r2
   2e274:	e13fff17 	ldw	r4,-4(fp)
   2e278:	000b883a 	mov	r5,zero
   2e27c:	000d883a 	mov	r6,zero
   2e280:	100f883a 	mov	r7,r2
   2e284:	002b1b80 	call	2b1b8 <tcp_output_alloc_header>
   2e288:	e0bffd15 	stw	r2,-12(fp)
  if(p == NULL) {
   2e28c:	e0bffd17 	ldw	r2,-12(fp)
   2e290:	10003826 	beq	r2,zero,2e374 <tcp_keepalive+0x168>
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
   2e294:	e0bffd17 	ldw	r2,-12(fp)
   2e298:	10800117 	ldw	r2,4(r2)
   2e29c:	e0bffe15 	stw	r2,-8(fp)

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
   2e2a0:	e0ffff17 	ldw	r3,-4(fp)
   2e2a4:	e0bfff17 	ldw	r2,-4(fp)
   2e2a8:	10800104 	addi	r2,r2,4
                                      IP_PROTO_TCP, p->tot_len);
   2e2ac:	e13ffd17 	ldw	r4,-12(fp)
   2e2b0:	2100020b 	ldhu	r4,8(r4)
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
   2e2b4:	213fffcc 	andi	r4,r4,65535
   2e2b8:	d9000015 	stw	r4,0(sp)
   2e2bc:	e13ffd17 	ldw	r4,-12(fp)
   2e2c0:	180b883a 	mov	r5,r3
   2e2c4:	100d883a 	mov	r6,r2
   2e2c8:	01c00184 	movi	r7,6
   2e2cc:	003e2ac0 	call	3e2ac <inet_chksum_pseudo>
   2e2d0:	1007883a 	mov	r3,r2
   2e2d4:	e0bffe17 	ldw	r2,-8(fp)
   2e2d8:	193fffcc 	andi	r4,r3,65535
   2e2dc:	21003fcc 	andi	r4,r4,255
   2e2e0:	11400403 	ldbu	r5,16(r2)
   2e2e4:	280a703a 	and	r5,r5,zero
   2e2e8:	2908b03a 	or	r4,r5,r4
   2e2ec:	11000405 	stb	r4,16(r2)
   2e2f0:	18ffffcc 	andi	r3,r3,65535
   2e2f4:	1806d23a 	srli	r3,r3,8
   2e2f8:	18ffffcc 	andi	r3,r3,65535
   2e2fc:	11000443 	ldbu	r4,17(r2)
   2e300:	2008703a 	and	r4,r4,zero
   2e304:	20c6b03a 	or	r3,r4,r3
   2e308:	10c00445 	stb	r3,17(r2)
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
   2e30c:	008001f4 	movhi	r2,7
   2e310:	10ac6e04 	addi	r2,r2,-20040
   2e314:	10804817 	ldw	r2,288(r2)
   2e318:	10c00044 	addi	r3,r2,1
   2e31c:	008001f4 	movhi	r2,7
   2e320:	10ac6e04 	addi	r2,r2,-20040
   2e324:	10c04815 	stw	r3,288(r2)

  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
   2e328:	e17fff17 	ldw	r5,-4(fp)
   2e32c:	e0bfff17 	ldw	r2,-4(fp)
   2e330:	10c00104 	addi	r3,r2,4
   2e334:	e0bfff17 	ldw	r2,-4(fp)
   2e338:	10800283 	ldbu	r2,10(r2)
   2e33c:	10803fcc 	andi	r2,r2,255
   2e340:	e13fff17 	ldw	r4,-4(fp)
   2e344:	210002c4 	addi	r4,r4,11
   2e348:	d8000015 	stw	zero,0(sp)
   2e34c:	01800184 	movi	r6,6
   2e350:	d9800115 	stw	r6,4(sp)
   2e354:	d9000215 	stw	r4,8(sp)
   2e358:	e13ffd17 	ldw	r4,-12(fp)
   2e35c:	180d883a 	mov	r6,r3
   2e360:	100f883a 	mov	r7,r2
   2e364:	001f9700 	call	1f970 <ip_output_hinted>
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
   2e368:	e13ffd17 	ldw	r4,-12(fp)
   2e36c:	00237600 	call	23760 <pbuf_free>
   2e370:	00000106 	br	2e378 <tcp_keepalive+0x16c>
   
  p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
   2e374:	0001883a 	nop

  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
   2e378:	e037883a 	mov	sp,fp
   2e37c:	dfc00117 	ldw	ra,4(sp)
   2e380:	df000017 	ldw	fp,0(sp)
   2e384:	dec00204 	addi	sp,sp,8
   2e388:	f800283a 	ret

0002e38c <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
   2e38c:	defff504 	addi	sp,sp,-44
   2e390:	dfc00a15 	stw	ra,40(sp)
   2e394:	df000915 	stw	fp,36(sp)
   2e398:	df000904 	addi	fp,sp,36
   2e39c:	e13fff15 	stw	r4,-4(fp)
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
   2e3a0:	e0bfff17 	ldw	r2,-4(fp)
   2e3a4:	10801d17 	ldw	r2,116(r2)
   2e3a8:	e0bffa15 	stw	r2,-24(fp)

  if(seg == NULL) {
   2e3ac:	e0bffa17 	ldw	r2,-24(fp)
   2e3b0:	1000031e 	bne	r2,zero,2e3c0 <tcp_zero_window_probe+0x34>
    seg = pcb->unsent;
   2e3b4:	e0bfff17 	ldw	r2,-4(fp)
   2e3b8:	10801c17 	ldw	r2,112(r2)
   2e3bc:	e0bffa15 	stw	r2,-24(fp)
  }
  if(seg == NULL) {
   2e3c0:	e0bffa17 	ldw	r2,-24(fp)
   2e3c4:	10009b26 	beq	r2,zero,2e634 <tcp_zero_window_probe+0x2a8>
    return;
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
   2e3c8:	e0bffa17 	ldw	r2,-24(fp)
   2e3cc:	10800417 	ldw	r2,16(r2)
   2e3d0:	10c00303 	ldbu	r3,12(r2)
   2e3d4:	10800343 	ldbu	r2,13(r2)
   2e3d8:	1004923a 	slli	r2,r2,8
   2e3dc:	10c4b03a 	or	r2,r2,r3
   2e3e0:	10bfffcc 	andi	r2,r2,65535
   2e3e4:	1004d23a 	srli	r2,r2,8
   2e3e8:	10ffffcc 	andi	r3,r2,65535
   2e3ec:	e0bffa17 	ldw	r2,-24(fp)
   2e3f0:	10800417 	ldw	r2,16(r2)
   2e3f4:	11000303 	ldbu	r4,12(r2)
   2e3f8:	10800343 	ldbu	r2,13(r2)
   2e3fc:	1004923a 	slli	r2,r2,8
   2e400:	1104b03a 	or	r2,r2,r4
   2e404:	10bfffcc 	andi	r2,r2,65535
   2e408:	1004923a 	slli	r2,r2,8
   2e40c:	10bfffcc 	andi	r2,r2,65535
   2e410:	1884b03a 	or	r2,r3,r2
   2e414:	1080004c 	andi	r2,r2,1
   2e418:	10000626 	beq	r2,zero,2e434 <tcp_zero_window_probe+0xa8>
   2e41c:	e0bffa17 	ldw	r2,-24(fp)
   2e420:	1080020b 	ldhu	r2,8(r2)
   2e424:	10bfffcc 	andi	r2,r2,65535
   2e428:	1000021e 	bne	r2,zero,2e434 <tcp_zero_window_probe+0xa8>
   2e42c:	00800044 	movi	r2,1
   2e430:	00000106 	br	2e438 <tcp_zero_window_probe+0xac>
   2e434:	0005883a 	mov	r2,zero
   2e438:	e0bffb05 	stb	r2,-20(fp)
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;
   2e43c:	e0bffb03 	ldbu	r2,-20(fp)
   2e440:	1005003a 	cmpeq	r2,r2,zero
   2e444:	10803fcc 	andi	r2,r2,255
   2e448:	e0bffb8d 	sth	r2,-18(fp)

  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
   2e44c:	e0fffb8b 	ldhu	r3,-18(fp)
   2e450:	e0bffa17 	ldw	r2,-24(fp)
   2e454:	10800417 	ldw	r2,16(r2)
   2e458:	11000103 	ldbu	r4,4(r2)
   2e45c:	11400143 	ldbu	r5,5(r2)
   2e460:	280a923a 	slli	r5,r5,8
   2e464:	2908b03a 	or	r4,r5,r4
   2e468:	11400183 	ldbu	r5,6(r2)
   2e46c:	280a943a 	slli	r5,r5,16
   2e470:	2908b03a 	or	r4,r5,r4
   2e474:	108001c3 	ldbu	r2,7(r2)
   2e478:	1004963a 	slli	r2,r2,24
   2e47c:	1104b03a 	or	r2,r2,r4
   2e480:	e13fff17 	ldw	r4,-4(fp)
   2e484:	000b883a 	mov	r5,zero
   2e488:	180d883a 	mov	r6,r3
   2e48c:	100f883a 	mov	r7,r2
   2e490:	002b1b80 	call	2b1b8 <tcp_output_alloc_header>
   2e494:	e0bffc15 	stw	r2,-16(fp)
  if(p == NULL) {
   2e498:	e0bffc17 	ldw	r2,-16(fp)
   2e49c:	10006726 	beq	r2,zero,2e63c <tcp_zero_window_probe+0x2b0>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
   2e4a0:	e0bffc17 	ldw	r2,-16(fp)
   2e4a4:	10800117 	ldw	r2,4(r2)
   2e4a8:	e0bffd15 	stw	r2,-12(fp)

  if (is_fin) {
   2e4ac:	e0bffb03 	ldbu	r2,-20(fp)
   2e4b0:	10001926 	beq	r2,zero,2e518 <tcp_zero_window_probe+0x18c>
    /* FIN segment, no data */
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
   2e4b4:	e0bffd17 	ldw	r2,-12(fp)
   2e4b8:	10c00303 	ldbu	r3,12(r2)
   2e4bc:	10800343 	ldbu	r2,13(r2)
   2e4c0:	1004923a 	slli	r2,r2,8
   2e4c4:	10c4b03a 	or	r2,r2,r3
   2e4c8:	1007883a 	mov	r3,r2
   2e4cc:	00b03fc4 	movi	r2,-16129
   2e4d0:	1884703a 	and	r2,r3,r2
   2e4d4:	10844014 	ori	r2,r2,4352
   2e4d8:	1007883a 	mov	r3,r2
   2e4dc:	e0bffd17 	ldw	r2,-12(fp)
   2e4e0:	193fffcc 	andi	r4,r3,65535
   2e4e4:	21003fcc 	andi	r4,r4,255
   2e4e8:	11400303 	ldbu	r5,12(r2)
   2e4ec:	280a703a 	and	r5,r5,zero
   2e4f0:	2908b03a 	or	r4,r5,r4
   2e4f4:	11000305 	stb	r4,12(r2)
   2e4f8:	18ffffcc 	andi	r3,r3,65535
   2e4fc:	1806d23a 	srli	r3,r3,8
   2e500:	18ffffcc 	andi	r3,r3,65535
   2e504:	11000343 	ldbu	r4,13(r2)
   2e508:	2008703a 	and	r4,r4,zero
   2e50c:	20c6b03a 	or	r3,r4,r3
   2e510:	10c00345 	stb	r3,13(r2)
   2e514:	00001206 	br	2e560 <tcp_zero_window_probe+0x1d4>
  } else {
    /* Data segment, copy in one byte from the head of the unacked queue */
    char *d = ((char *)p->payload + TCP_HLEN);
   2e518:	e0bffc17 	ldw	r2,-16(fp)
   2e51c:	10800117 	ldw	r2,4(r2)
   2e520:	10800504 	addi	r2,r2,20
   2e524:	e0bffe15 	stw	r2,-8(fp)
    /* Depending on whether the segment has already been sent (unacked) or not
       (unsent), seg->p->payload points to the IP header or TCP header.
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
   2e528:	e0bffa17 	ldw	r2,-24(fp)
   2e52c:	10c00117 	ldw	r3,4(r2)
   2e530:	e0bffa17 	ldw	r2,-24(fp)
   2e534:	10800117 	ldw	r2,4(r2)
   2e538:	1100020b 	ldhu	r4,8(r2)
   2e53c:	e0bffa17 	ldw	r2,-24(fp)
   2e540:	1080020b 	ldhu	r2,8(r2)
   2e544:	2085c83a 	sub	r2,r4,r2
   2e548:	10bfffcc 	andi	r2,r2,65535
   2e54c:	1809883a 	mov	r4,r3
   2e550:	e17ffe17 	ldw	r5,-8(fp)
   2e554:	01800044 	movi	r6,1
   2e558:	100f883a 	mov	r7,r2
   2e55c:	0023d580 	call	23d58 <pbuf_copy_partial>
  }

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
   2e560:	e0ffff17 	ldw	r3,-4(fp)
   2e564:	e0bfff17 	ldw	r2,-4(fp)
   2e568:	10800104 	addi	r2,r2,4
                                      IP_PROTO_TCP, p->tot_len);
   2e56c:	e13ffc17 	ldw	r4,-16(fp)
   2e570:	2100020b 	ldhu	r4,8(r4)
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
  }

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
   2e574:	213fffcc 	andi	r4,r4,65535
   2e578:	d9000015 	stw	r4,0(sp)
   2e57c:	e13ffc17 	ldw	r4,-16(fp)
   2e580:	180b883a 	mov	r5,r3
   2e584:	100d883a 	mov	r6,r2
   2e588:	01c00184 	movi	r7,6
   2e58c:	003e2ac0 	call	3e2ac <inet_chksum_pseudo>
   2e590:	1007883a 	mov	r3,r2
   2e594:	e0bffd17 	ldw	r2,-12(fp)
   2e598:	193fffcc 	andi	r4,r3,65535
   2e59c:	21003fcc 	andi	r4,r4,255
   2e5a0:	11400403 	ldbu	r5,16(r2)
   2e5a4:	280a703a 	and	r5,r5,zero
   2e5a8:	2908b03a 	or	r4,r5,r4
   2e5ac:	11000405 	stb	r4,16(r2)
   2e5b0:	18ffffcc 	andi	r3,r3,65535
   2e5b4:	1806d23a 	srli	r3,r3,8
   2e5b8:	18ffffcc 	andi	r3,r3,65535
   2e5bc:	11000443 	ldbu	r4,17(r2)
   2e5c0:	2008703a 	and	r4,r4,zero
   2e5c4:	20c6b03a 	or	r3,r4,r3
   2e5c8:	10c00445 	stb	r3,17(r2)
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
   2e5cc:	008001f4 	movhi	r2,7
   2e5d0:	10ac6e04 	addi	r2,r2,-20040
   2e5d4:	10804817 	ldw	r2,288(r2)
   2e5d8:	10c00044 	addi	r3,r2,1
   2e5dc:	008001f4 	movhi	r2,7
   2e5e0:	10ac6e04 	addi	r2,r2,-20040
   2e5e4:	10c04815 	stw	r3,288(r2)

  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
   2e5e8:	e17fff17 	ldw	r5,-4(fp)
   2e5ec:	e0bfff17 	ldw	r2,-4(fp)
   2e5f0:	10c00104 	addi	r3,r2,4
   2e5f4:	e0bfff17 	ldw	r2,-4(fp)
   2e5f8:	10800283 	ldbu	r2,10(r2)
   2e5fc:	10803fcc 	andi	r2,r2,255
   2e600:	e13fff17 	ldw	r4,-4(fp)
   2e604:	210002c4 	addi	r4,r4,11
   2e608:	d8000015 	stw	zero,0(sp)
   2e60c:	01800184 	movi	r6,6
   2e610:	d9800115 	stw	r6,4(sp)
   2e614:	d9000215 	stw	r4,8(sp)
   2e618:	e13ffc17 	ldw	r4,-16(fp)
   2e61c:	180d883a 	mov	r6,r3
   2e620:	100f883a 	mov	r7,r2
   2e624:	001f9700 	call	1f970 <ip_output_hinted>
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
   2e628:	e13ffc17 	ldw	r4,-16(fp)
   2e62c:	00237600 	call	23760 <pbuf_free>
   2e630:	00000306 	br	2e640 <tcp_zero_window_probe+0x2b4>

  if(seg == NULL) {
    seg = pcb->unsent;
  }
  if(seg == NULL) {
    return;
   2e634:	0001883a 	nop
   2e638:	00000106 	br	2e640 <tcp_zero_window_probe+0x2b4>
  len = is_fin ? 0 : 1;

  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
   2e63c:	0001883a 	nop
  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
   2e640:	e037883a 	mov	sp,fp
   2e644:	dfc00117 	ldw	ra,4(sp)
   2e648:	df000017 	ldw	fp,0(sp)
   2e64c:	dec00204 	addi	sp,sp,8
   2e650:	f800283a 	ret

0002e654 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
   2e654:	defffd04 	addi	sp,sp,-12
   2e658:	dfc00215 	stw	ra,8(sp)
   2e65c:	df000115 	stw	fp,4(sp)
   2e660:	df000104 	addi	fp,sp,4
   2e664:	e13fff15 	stw	r4,-4(fp)
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
   2e668:	0024a440 	call	24a44 <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
   2e66c:	00800134 	movhi	r2,4
   2e670:	109ef204 	addi	r2,r2,31688
   2e674:	10800017 	ldw	r2,0(r2)
   2e678:	1000041e 	bne	r2,zero,2e68c <tcpip_tcp_timer+0x38>
   2e67c:	00800134 	movhi	r2,4
   2e680:	109ef704 	addi	r2,r2,31708
   2e684:	10800017 	ldw	r2,0(r2)
   2e688:	10000626 	beq	r2,zero,2e6a4 <tcpip_tcp_timer+0x50>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
   2e68c:	01003e84 	movi	r4,250
   2e690:	014000f4 	movhi	r5,3
   2e694:	29799504 	addi	r5,r5,-6572
   2e698:	000d883a 	mov	r6,zero
   2e69c:	002e8980 	call	2e898 <sys_timeout>
   2e6a0:	00000106 	br	2e6a8 <tcpip_tcp_timer+0x54>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
   2e6a4:	d0294515 	stw	zero,-23276(gp)
  }
}
   2e6a8:	e037883a 	mov	sp,fp
   2e6ac:	dfc00117 	ldw	ra,4(sp)
   2e6b0:	df000017 	ldw	fp,0(sp)
   2e6b4:	dec00204 	addi	sp,sp,8
   2e6b8:	f800283a 	ret

0002e6bc <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
   2e6bc:	defffe04 	addi	sp,sp,-8
   2e6c0:	dfc00115 	stw	ra,4(sp)
   2e6c4:	df000015 	stw	fp,0(sp)
   2e6c8:	d839883a 	mov	fp,sp
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
   2e6cc:	d0a94517 	ldw	r2,-23276(gp)
   2e6d0:	10000f1e 	bne	r2,zero,2e710 <tcp_timer_needed+0x54>
   2e6d4:	00800134 	movhi	r2,4
   2e6d8:	109ef204 	addi	r2,r2,31688
   2e6dc:	10800017 	ldw	r2,0(r2)
   2e6e0:	1000041e 	bne	r2,zero,2e6f4 <tcp_timer_needed+0x38>
   2e6e4:	00800134 	movhi	r2,4
   2e6e8:	109ef704 	addi	r2,r2,31708
   2e6ec:	10800017 	ldw	r2,0(r2)
   2e6f0:	10000726 	beq	r2,zero,2e710 <tcp_timer_needed+0x54>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
   2e6f4:	00800044 	movi	r2,1
   2e6f8:	d0a94515 	stw	r2,-23276(gp)
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
   2e6fc:	01003e84 	movi	r4,250
   2e700:	014000f4 	movhi	r5,3
   2e704:	29799504 	addi	r5,r5,-6572
   2e708:	000d883a 	mov	r6,zero
   2e70c:	002e8980 	call	2e898 <sys_timeout>
  }
}
   2e710:	e037883a 	mov	sp,fp
   2e714:	dfc00117 	ldw	ra,4(sp)
   2e718:	df000017 	ldw	fp,0(sp)
   2e71c:	dec00204 	addi	sp,sp,8
   2e720:	f800283a 	ret

0002e724 <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
   2e724:	defffd04 	addi	sp,sp,-12
   2e728:	dfc00215 	stw	ra,8(sp)
   2e72c:	df000115 	stw	fp,4(sp)
   2e730:	df000104 	addi	fp,sp,4
   2e734:	e13fff15 	stw	r4,-4(fp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
   2e738:	00202000 	call	20200 <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
   2e73c:	0100fa04 	movi	r4,1000
   2e740:	014000f4 	movhi	r5,3
   2e744:	2979c904 	addi	r5,r5,-6364
   2e748:	000d883a 	mov	r6,zero
   2e74c:	002e8980 	call	2e898 <sys_timeout>
}
   2e750:	e037883a 	mov	sp,fp
   2e754:	dfc00117 	ldw	ra,4(sp)
   2e758:	df000017 	ldw	fp,0(sp)
   2e75c:	dec00204 	addi	sp,sp,8
   2e760:	f800283a 	ret

0002e764 <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
   2e764:	defffd04 	addi	sp,sp,-12
   2e768:	dfc00215 	stw	ra,8(sp)
   2e76c:	df000115 	stw	fp,4(sp)
   2e770:	df000104 	addi	fp,sp,4
   2e774:	e13fff15 	stw	r4,-4(fp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
   2e778:	002fdcc0 	call	2fdcc <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
   2e77c:	0104e204 	movi	r4,5000
   2e780:	014000f4 	movhi	r5,3
   2e784:	2979d904 	addi	r5,r5,-6300
   2e788:	000d883a 	mov	r6,zero
   2e78c:	002e8980 	call	2e898 <sys_timeout>
}
   2e790:	e037883a 	mov	sp,fp
   2e794:	dfc00117 	ldw	ra,4(sp)
   2e798:	df000017 	ldw	fp,0(sp)
   2e79c:	dec00204 	addi	sp,sp,8
   2e7a0:	f800283a 	ret

0002e7a4 <dhcp_timer_coarse>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_coarse(void *arg)
{
   2e7a4:	defffd04 	addi	sp,sp,-12
   2e7a8:	dfc00215 	stw	ra,8(sp)
   2e7ac:	df000115 	stw	fp,4(sp)
   2e7b0:	df000104 	addi	fp,sp,4
   2e7b4:	e13fff15 	stw	r4,-4(fp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
  dhcp_coarse_tmr();
   2e7b8:	001be340 	call	1be34 <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
   2e7bc:	013a9814 	movui	r4,60000
   2e7c0:	014000f4 	movhi	r5,3
   2e7c4:	2979e904 	addi	r5,r5,-6236
   2e7c8:	000d883a 	mov	r6,zero
   2e7cc:	002e8980 	call	2e898 <sys_timeout>
}
   2e7d0:	e037883a 	mov	sp,fp
   2e7d4:	dfc00117 	ldw	ra,4(sp)
   2e7d8:	df000017 	ldw	fp,0(sp)
   2e7dc:	dec00204 	addi	sp,sp,8
   2e7e0:	f800283a 	ret

0002e7e4 <dhcp_timer_fine>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_fine(void *arg)
{
   2e7e4:	defffd04 	addi	sp,sp,-12
   2e7e8:	dfc00215 	stw	ra,8(sp)
   2e7ec:	df000115 	stw	fp,4(sp)
   2e7f0:	df000104 	addi	fp,sp,4
   2e7f4:	e13fff15 	stw	r4,-4(fp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
  dhcp_fine_tmr();
   2e7f8:	001bee80 	call	1bee8 <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
   2e7fc:	01007d04 	movi	r4,500
   2e800:	014000f4 	movhi	r5,3
   2e804:	2979f904 	addi	r5,r5,-6172
   2e808:	000d883a 	mov	r6,zero
   2e80c:	002e8980 	call	2e898 <sys_timeout>
}
   2e810:	e037883a 	mov	sp,fp
   2e814:	dfc00117 	ldw	ra,4(sp)
   2e818:	df000017 	ldw	fp,0(sp)
   2e81c:	dec00204 	addi	sp,sp,8
   2e820:	f800283a 	ret

0002e824 <sys_timeouts_init>:
}
#endif /* LWIP_DNS */

/** Initialize this module */
void sys_timeouts_init(void)
{
   2e824:	defffe04 	addi	sp,sp,-8
   2e828:	dfc00115 	stw	ra,4(sp)
   2e82c:	df000015 	stw	fp,0(sp)
   2e830:	d839883a 	mov	fp,sp
#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
   2e834:	0100fa04 	movi	r4,1000
   2e838:	014000f4 	movhi	r5,3
   2e83c:	2979c904 	addi	r5,r5,-6364
   2e840:	000d883a 	mov	r6,zero
   2e844:	002e8980 	call	2e898 <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
   2e848:	0104e204 	movi	r4,5000
   2e84c:	014000f4 	movhi	r5,3
   2e850:	2979d904 	addi	r5,r5,-6300
   2e854:	000d883a 	mov	r6,zero
   2e858:	002e8980 	call	2e898 <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
   2e85c:	013a9814 	movui	r4,60000
   2e860:	014000f4 	movhi	r5,3
   2e864:	2979e904 	addi	r5,r5,-6236
   2e868:	000d883a 	mov	r6,zero
   2e86c:	002e8980 	call	2e898 <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
   2e870:	01007d04 	movi	r4,500
   2e874:	014000f4 	movhi	r5,3
   2e878:	2979f904 	addi	r5,r5,-6172
   2e87c:	000d883a 	mov	r6,zero
   2e880:	002e8980 	call	2e898 <sys_timeout>

#if NO_SYS
  /* Initialise timestamp for sys_check_timeouts */
  timeouts_last_time = sys_now();
#endif
}
   2e884:	e037883a 	mov	sp,fp
   2e888:	dfc00117 	ldw	ra,4(sp)
   2e88c:	df000017 	ldw	fp,0(sp)
   2e890:	dec00204 	addi	sp,sp,8
   2e894:	f800283a 	ret

0002e898 <sys_timeout>:
sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char* handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
void
sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
   2e898:	defff904 	addi	sp,sp,-28
   2e89c:	dfc00615 	stw	ra,24(sp)
   2e8a0:	df000515 	stw	fp,20(sp)
   2e8a4:	df000504 	addi	fp,sp,20
   2e8a8:	e13ffd15 	stw	r4,-12(fp)
   2e8ac:	e17ffe15 	stw	r5,-8(fp)
   2e8b0:	e1bfff15 	stw	r6,-4(fp)
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
   2e8b4:	01000304 	movi	r4,12
   2e8b8:	00223cc0 	call	223cc <memp_malloc>
   2e8bc:	e0bffc15 	stw	r2,-16(fp)
  if (timeout == NULL) {
   2e8c0:	e0bffc17 	ldw	r2,-16(fp)
   2e8c4:	10004d26 	beq	r2,zero,2e9fc <sys_timeout+0x164>
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
    return;
  }
  timeout->next = NULL;
   2e8c8:	e0bffc17 	ldw	r2,-16(fp)
   2e8cc:	10000015 	stw	zero,0(r2)
  timeout->h = handler;
   2e8d0:	e0bffc17 	ldw	r2,-16(fp)
   2e8d4:	e0fffe17 	ldw	r3,-8(fp)
   2e8d8:	10c00215 	stw	r3,8(r2)
  timeout->arg = arg;
   2e8dc:	e0bffc17 	ldw	r2,-16(fp)
   2e8e0:	e0ffff17 	ldw	r3,-4(fp)
   2e8e4:	10c00315 	stw	r3,12(r2)
  timeout->time = msecs;
   2e8e8:	e0bffc17 	ldw	r2,-16(fp)
   2e8ec:	e0fffd17 	ldw	r3,-12(fp)
   2e8f0:	10c00115 	stw	r3,4(r2)
  timeout->handler_name = handler_name;
  LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" handler=%s arg=%p\n",
    (void *)timeout, msecs, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

  if (next_timeout == NULL) {
   2e8f4:	d0a94417 	ldw	r2,-23280(gp)
   2e8f8:	1000031e 	bne	r2,zero,2e908 <sys_timeout+0x70>
    next_timeout = timeout;
   2e8fc:	e0bffc17 	ldw	r2,-16(fp)
   2e900:	d0a94415 	stw	r2,-23280(gp)
    return;
   2e904:	00003e06 	br	2ea00 <sys_timeout+0x168>
  }

  if (next_timeout->time > msecs) {
   2e908:	d0a94417 	ldw	r2,-23280(gp)
   2e90c:	10800117 	ldw	r2,4(r2)
   2e910:	e0fffd17 	ldw	r3,-12(fp)
   2e914:	18800c2e 	bgeu	r3,r2,2e948 <sys_timeout+0xb0>
    next_timeout->time -= msecs;
   2e918:	d0a94417 	ldw	r2,-23280(gp)
   2e91c:	d0e94417 	ldw	r3,-23280(gp)
   2e920:	19000117 	ldw	r4,4(r3)
   2e924:	e0fffd17 	ldw	r3,-12(fp)
   2e928:	20c7c83a 	sub	r3,r4,r3
   2e92c:	10c00115 	stw	r3,4(r2)
    timeout->next = next_timeout;
   2e930:	d0e94417 	ldw	r3,-23280(gp)
   2e934:	e0bffc17 	ldw	r2,-16(fp)
   2e938:	10c00015 	stw	r3,0(r2)
    next_timeout = timeout;
   2e93c:	e0bffc17 	ldw	r2,-16(fp)
   2e940:	d0a94415 	stw	r2,-23280(gp)
   2e944:	00002e06 	br	2ea00 <sys_timeout+0x168>
  } else {
    for(t = next_timeout; t != NULL; t = t->next) {
   2e948:	d0a94417 	ldw	r2,-23280(gp)
   2e94c:	e0bffb15 	stw	r2,-20(fp)
   2e950:	00002706 	br	2e9f0 <sys_timeout+0x158>
      timeout->time -= t->time;
   2e954:	e0bffc17 	ldw	r2,-16(fp)
   2e958:	10c00117 	ldw	r3,4(r2)
   2e95c:	e0bffb17 	ldw	r2,-20(fp)
   2e960:	10800117 	ldw	r2,4(r2)
   2e964:	1887c83a 	sub	r3,r3,r2
   2e968:	e0bffc17 	ldw	r2,-16(fp)
   2e96c:	10c00115 	stw	r3,4(r2)
      if (t->next == NULL || t->next->time > timeout->time) {
   2e970:	e0bffb17 	ldw	r2,-20(fp)
   2e974:	10800017 	ldw	r2,0(r2)
   2e978:	10000626 	beq	r2,zero,2e994 <sys_timeout+0xfc>
   2e97c:	e0bffb17 	ldw	r2,-20(fp)
   2e980:	10800017 	ldw	r2,0(r2)
   2e984:	10800117 	ldw	r2,4(r2)
   2e988:	e0fffc17 	ldw	r3,-16(fp)
   2e98c:	18c00117 	ldw	r3,4(r3)
   2e990:	1880142e 	bgeu	r3,r2,2e9e4 <sys_timeout+0x14c>
        if (t->next != NULL) {
   2e994:	e0bffb17 	ldw	r2,-20(fp)
   2e998:	10800017 	ldw	r2,0(r2)
   2e99c:	10000926 	beq	r2,zero,2e9c4 <sys_timeout+0x12c>
          t->next->time -= timeout->time;
   2e9a0:	e0bffb17 	ldw	r2,-20(fp)
   2e9a4:	10800017 	ldw	r2,0(r2)
   2e9a8:	e0fffb17 	ldw	r3,-20(fp)
   2e9ac:	18c00017 	ldw	r3,0(r3)
   2e9b0:	19000117 	ldw	r4,4(r3)
   2e9b4:	e0fffc17 	ldw	r3,-16(fp)
   2e9b8:	18c00117 	ldw	r3,4(r3)
   2e9bc:	20c7c83a 	sub	r3,r4,r3
   2e9c0:	10c00115 	stw	r3,4(r2)
        }
        timeout->next = t->next;
   2e9c4:	e0bffb17 	ldw	r2,-20(fp)
   2e9c8:	10c00017 	ldw	r3,0(r2)
   2e9cc:	e0bffc17 	ldw	r2,-16(fp)
   2e9d0:	10c00015 	stw	r3,0(r2)
        t->next = timeout;
   2e9d4:	e0bffb17 	ldw	r2,-20(fp)
   2e9d8:	e0fffc17 	ldw	r3,-16(fp)
   2e9dc:	10c00015 	stw	r3,0(r2)
        break;
   2e9e0:	00000706 	br	2ea00 <sys_timeout+0x168>
  if (next_timeout->time > msecs) {
    next_timeout->time -= msecs;
    timeout->next = next_timeout;
    next_timeout = timeout;
  } else {
    for(t = next_timeout; t != NULL; t = t->next) {
   2e9e4:	e0bffb17 	ldw	r2,-20(fp)
   2e9e8:	10800017 	ldw	r2,0(r2)
   2e9ec:	e0bffb15 	stw	r2,-20(fp)
   2e9f0:	e0bffb17 	ldw	r2,-20(fp)
   2e9f4:	103fd71e 	bne	r2,zero,2e954 <sys_timeout+0xbc>
   2e9f8:	00000106 	br	2ea00 <sys_timeout+0x168>
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
  if (timeout == NULL) {
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
    return;
   2e9fc:	0001883a 	nop
        t->next = timeout;
        break;
      }
    }
  }
}
   2ea00:	e037883a 	mov	sp,fp
   2ea04:	dfc00117 	ldw	ra,4(sp)
   2ea08:	df000017 	ldw	fp,0(sp)
   2ea0c:	dec00204 	addi	sp,sp,8
   2ea10:	f800283a 	ret

0002ea14 <sys_untimeout>:
 * @param handler callback function that would be called by the timeout
 * @param arg callback argument that would be passed to handler
*/
void
sys_untimeout(sys_timeout_handler handler, void *arg)
{
   2ea14:	defffa04 	addi	sp,sp,-24
   2ea18:	dfc00515 	stw	ra,20(sp)
   2ea1c:	df000415 	stw	fp,16(sp)
   2ea20:	df000404 	addi	fp,sp,16
   2ea24:	e13ffe15 	stw	r4,-8(fp)
   2ea28:	e17fff15 	stw	r5,-4(fp)
  struct sys_timeo *prev_t, *t;

  if (next_timeout == NULL) {
   2ea2c:	d0a94417 	ldw	r2,-23280(gp)
   2ea30:	10002e26 	beq	r2,zero,2eaec <sys_untimeout+0xd8>
    return;
  }

  for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
   2ea34:	d0a94417 	ldw	r2,-23280(gp)
   2ea38:	e0bffd15 	stw	r2,-12(fp)
   2ea3c:	e03ffc15 	stw	zero,-16(fp)
   2ea40:	00002706 	br	2eae0 <sys_untimeout+0xcc>
    if ((t->h == handler) && (t->arg == arg)) {
   2ea44:	e0bffd17 	ldw	r2,-12(fp)
   2ea48:	10c00217 	ldw	r3,8(r2)
   2ea4c:	e0bffe17 	ldw	r2,-8(fp)
   2ea50:	18801e1e 	bne	r3,r2,2eacc <sys_untimeout+0xb8>
   2ea54:	e0bffd17 	ldw	r2,-12(fp)
   2ea58:	10c00317 	ldw	r3,12(r2)
   2ea5c:	e0bfff17 	ldw	r2,-4(fp)
   2ea60:	18801a1e 	bne	r3,r2,2eacc <sys_untimeout+0xb8>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL) {
   2ea64:	e0bffc17 	ldw	r2,-16(fp)
   2ea68:	1000041e 	bne	r2,zero,2ea7c <sys_untimeout+0x68>
        next_timeout = t->next;
   2ea6c:	e0bffd17 	ldw	r2,-12(fp)
   2ea70:	10800017 	ldw	r2,0(r2)
   2ea74:	d0a94415 	stw	r2,-23280(gp)
   2ea78:	00000406 	br	2ea8c <sys_untimeout+0x78>
      } else {
        prev_t->next = t->next;
   2ea7c:	e0bffd17 	ldw	r2,-12(fp)
   2ea80:	10c00017 	ldw	r3,0(r2)
   2ea84:	e0bffc17 	ldw	r2,-16(fp)
   2ea88:	10c00015 	stw	r3,0(r2)
      }
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL) {
   2ea8c:	e0bffd17 	ldw	r2,-12(fp)
   2ea90:	10800017 	ldw	r2,0(r2)
   2ea94:	10000926 	beq	r2,zero,2eabc <sys_untimeout+0xa8>
        t->next->time += t->time;
   2ea98:	e0bffd17 	ldw	r2,-12(fp)
   2ea9c:	10800017 	ldw	r2,0(r2)
   2eaa0:	e0fffd17 	ldw	r3,-12(fp)
   2eaa4:	18c00017 	ldw	r3,0(r3)
   2eaa8:	19000117 	ldw	r4,4(r3)
   2eaac:	e0fffd17 	ldw	r3,-12(fp)
   2eab0:	18c00117 	ldw	r3,4(r3)
   2eab4:	20c7883a 	add	r3,r4,r3
   2eab8:	10c00115 	stw	r3,4(r2)
      }
      memp_free(MEMP_SYS_TIMEOUT, t);
   2eabc:	01000304 	movi	r4,12
   2eac0:	e17ffd17 	ldw	r5,-12(fp)
   2eac4:	00225900 	call	22590 <memp_free>
      return;
   2eac8:	00000906 	br	2eaf0 <sys_untimeout+0xdc>

  if (next_timeout == NULL) {
    return;
  }

  for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
   2eacc:	e0bffd17 	ldw	r2,-12(fp)
   2ead0:	e0bffc15 	stw	r2,-16(fp)
   2ead4:	e0bffd17 	ldw	r2,-12(fp)
   2ead8:	10800017 	ldw	r2,0(r2)
   2eadc:	e0bffd15 	stw	r2,-12(fp)
   2eae0:	e0bffd17 	ldw	r2,-12(fp)
   2eae4:	103fd71e 	bne	r2,zero,2ea44 <sys_untimeout+0x30>
      }
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
   2eae8:	00000106 	br	2eaf0 <sys_untimeout+0xdc>
sys_untimeout(sys_timeout_handler handler, void *arg)
{
  struct sys_timeo *prev_t, *t;

  if (next_timeout == NULL) {
    return;
   2eaec:	0001883a 	nop
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
}
   2eaf0:	e037883a 	mov	sp,fp
   2eaf4:	dfc00117 	ldw	ra,4(sp)
   2eaf8:	df000017 	ldw	fp,0(sp)
   2eafc:	dec00204 	addi	sp,sp,8
   2eb00:	f800283a 	ret

0002eb04 <sys_timeouts_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_timeouts_mbox_fetch(sys_mbox_t *mbox, void **msg)
{
   2eb04:	defff804 	addi	sp,sp,-32
   2eb08:	dfc00715 	stw	ra,28(sp)
   2eb0c:	df000615 	stw	fp,24(sp)
   2eb10:	df000604 	addi	fp,sp,24
   2eb14:	e13ffe15 	stw	r4,-8(fp)
   2eb18:	e17fff15 	stw	r5,-4(fp)
   2eb1c:	00000106 	br	2eb24 <sys_timeouts_mbox_fetch+0x20>
        UNLOCK_TCPIP_CORE();
      }
      LWIP_TCPIP_THREAD_ALIVE();

      /* We try again to fetch a message from the mbox. */
      goto again;
   2eb20:	0001883a 	nop
  struct sys_timeo *tmptimeout;
  sys_timeout_handler handler;
  void *arg;

 again:
  if (!next_timeout) {
   2eb24:	d0a94417 	ldw	r2,-23280(gp)
   2eb28:	1000061e 	bne	r2,zero,2eb44 <sys_timeouts_mbox_fetch+0x40>
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
   2eb2c:	e13ffe17 	ldw	r4,-8(fp)
   2eb30:	e17fff17 	ldw	r5,-4(fp)
   2eb34:	000d883a 	mov	r6,zero
   2eb38:	001b7a80 	call	1b7a8 <sys_arch_mbox_fetch>
   2eb3c:	e0bffa15 	stw	r2,-24(fp)
   2eb40:	00003106 	br	2ec08 <sys_timeouts_mbox_fetch+0x104>
  } else {
    if (next_timeout->time > 0) {
   2eb44:	d0a94417 	ldw	r2,-23280(gp)
   2eb48:	10800117 	ldw	r2,4(r2)
   2eb4c:	10000826 	beq	r2,zero,2eb70 <sys_timeouts_mbox_fetch+0x6c>
      time_needed = sys_arch_mbox_fetch(mbox, msg, next_timeout->time);
   2eb50:	d0a94417 	ldw	r2,-23280(gp)
   2eb54:	10800117 	ldw	r2,4(r2)
   2eb58:	e13ffe17 	ldw	r4,-8(fp)
   2eb5c:	e17fff17 	ldw	r5,-4(fp)
   2eb60:	100d883a 	mov	r6,r2
   2eb64:	001b7a80 	call	1b7a8 <sys_arch_mbox_fetch>
   2eb68:	e0bffa15 	stw	r2,-24(fp)
   2eb6c:	00000206 	br	2eb78 <sys_timeouts_mbox_fetch+0x74>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
   2eb70:	00bfffc4 	movi	r2,-1
   2eb74:	e0bffa15 	stw	r2,-24(fp)
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
   2eb78:	e0bffa17 	ldw	r2,-24(fp)
   2eb7c:	10bfffd8 	cmpnei	r2,r2,-1
   2eb80:	1000141e 	bne	r2,zero,2ebd4 <sys_timeouts_mbox_fetch+0xd0>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = next_timeout;
   2eb84:	d0a94417 	ldw	r2,-23280(gp)
   2eb88:	e0bffb15 	stw	r2,-20(fp)
      next_timeout = tmptimeout->next;
   2eb8c:	e0bffb17 	ldw	r2,-20(fp)
   2eb90:	10800017 	ldw	r2,0(r2)
   2eb94:	d0a94415 	stw	r2,-23280(gp)
      handler = tmptimeout->h;
   2eb98:	e0bffb17 	ldw	r2,-20(fp)
   2eb9c:	10800217 	ldw	r2,8(r2)
   2eba0:	e0bffc15 	stw	r2,-16(fp)
      arg = tmptimeout->arg;
   2eba4:	e0bffb17 	ldw	r2,-20(fp)
   2eba8:	10800317 	ldw	r2,12(r2)
   2ebac:	e0bffd15 	stw	r2,-12(fp)
      if (handler != NULL) {
        LWIP_DEBUGF(TIMERS_DEBUG, ("stmf calling h=%s arg=%p\n",
          tmptimeout->handler_name, arg));
      }
#endif /* LWIP_DEBUG_TIMERNAMES */
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
   2ebb0:	01000304 	movi	r4,12
   2ebb4:	e17ffb17 	ldw	r5,-20(fp)
   2ebb8:	00225900 	call	22590 <memp_free>
      if (handler != NULL) {
   2ebbc:	e0bffc17 	ldw	r2,-16(fp)
   2ebc0:	103fd726 	beq	r2,zero,2eb20 <sys_timeouts_mbox_fetch+0x1c>
        /* For LWIP_TCPIP_CORE_LOCKING, lock the core before calling the
           timeout handler function. */
        LOCK_TCPIP_CORE();
        handler(arg);
   2ebc4:	e0bffc17 	ldw	r2,-16(fp)
   2ebc8:	e13ffd17 	ldw	r4,-12(fp)
   2ebcc:	103ee83a 	callr	r2
        UNLOCK_TCPIP_CORE();
      }
      LWIP_TCPIP_THREAD_ALIVE();

      /* We try again to fetch a message from the mbox. */
      goto again;
   2ebd0:	003fd306 	br	2eb20 <sys_timeouts_mbox_fetch+0x1c>
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < next_timeout->time) {
   2ebd4:	d0a94417 	ldw	r2,-23280(gp)
   2ebd8:	10800117 	ldw	r2,4(r2)
   2ebdc:	e0fffa17 	ldw	r3,-24(fp)
   2ebe0:	1880072e 	bgeu	r3,r2,2ec00 <sys_timeouts_mbox_fetch+0xfc>
        next_timeout->time -= time_needed;
   2ebe4:	d0a94417 	ldw	r2,-23280(gp)
   2ebe8:	d0e94417 	ldw	r3,-23280(gp)
   2ebec:	19000117 	ldw	r4,4(r3)
   2ebf0:	e0fffa17 	ldw	r3,-24(fp)
   2ebf4:	20c7c83a 	sub	r3,r4,r3
   2ebf8:	10c00115 	stw	r3,4(r2)
   2ebfc:	00000206 	br	2ec08 <sys_timeouts_mbox_fetch+0x104>
      } else {
        next_timeout->time = 0;
   2ec00:	d0a94417 	ldw	r2,-23280(gp)
   2ec04:	10000115 	stw	zero,4(r2)
      }
    }
  }
}
   2ec08:	e037883a 	mov	sp,fp
   2ec0c:	dfc00117 	ldw	ra,4(sp)
   2ec10:	df000017 	ldw	fp,0(sp)
   2ec14:	dec00204 	addi	sp,sp,8
   2ec18:	f800283a 	ret

0002ec1c <udp_init>:
/**
 * Initialize this module.
 */
void
udp_init(void)
{
   2ec1c:	deffff04 	addi	sp,sp,-4
   2ec20:	df000015 	stw	fp,0(sp)
   2ec24:	d839883a 	mov	fp,sp
#if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
  udp_port = UDP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
#endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
}
   2ec28:	e037883a 	mov	sp,fp
   2ec2c:	df000017 	ldw	fp,0(sp)
   2ec30:	dec00104 	addi	sp,sp,4
   2ec34:	f800283a 	ret

0002ec38 <udp_new_port>:
 *
 * @return a new (free) local UDP port number
 */
static u16_t
udp_new_port(void)
{
   2ec38:	defffd04 	addi	sp,sp,-12
   2ec3c:	df000215 	stw	fp,8(sp)
   2ec40:	df000204 	addi	fp,sp,8
  u16_t n = 0;
   2ec44:	e03ffe0d 	sth	zero,-8(fp)
   2ec48:	00000106 	br	2ec50 <udp_new_port+0x18>
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == udp_port) {
      if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
        return 0;
      }
      goto again;
   2ec4c:	0001883a 	nop
{
  u16_t n = 0;
  struct udp_pcb *pcb;
  
again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
   2ec50:	d0a0150b 	ldhu	r2,-32684(gp)
   2ec54:	113fffcc 	andi	r4,r2,65535
   2ec58:	00ffffd4 	movui	r3,65535
   2ec5c:	20c7003a 	cmpeq	r3,r4,r3
   2ec60:	10800044 	addi	r2,r2,1
   2ec64:	d0a0150d 	sth	r2,-32684(gp)
   2ec68:	18803fcc 	andi	r2,r3,255
   2ec6c:	10000226 	beq	r2,zero,2ec78 <udp_new_port+0x40>
    udp_port = UDP_LOCAL_PORT_RANGE_START;
   2ec70:	00b00004 	movi	r2,-16384
   2ec74:	d0a0150d 	sth	r2,-32684(gp)
  }
  /* Check all PCBs. */
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
   2ec78:	d0a94617 	ldw	r2,-23272(gp)
   2ec7c:	e0bfff15 	stw	r2,-4(fp)
   2ec80:	00001106 	br	2ecc8 <udp_new_port+0x90>
    if (pcb->local_port == udp_port) {
   2ec84:	e0bfff17 	ldw	r2,-4(fp)
   2ec88:	10c0048b 	ldhu	r3,18(r2)
   2ec8c:	d0a0150b 	ldhu	r2,-32684(gp)
   2ec90:	18ffffcc 	andi	r3,r3,65535
   2ec94:	10bfffcc 	andi	r2,r2,65535
   2ec98:	1880081e 	bne	r3,r2,2ecbc <udp_new_port+0x84>
      if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
   2ec9c:	e0bffe0b 	ldhu	r2,-8(fp)
   2eca0:	10800044 	addi	r2,r2,1
   2eca4:	e0bffe0d 	sth	r2,-8(fp)
   2eca8:	e0bffe0b 	ldhu	r2,-8(fp)
   2ecac:	10900030 	cmpltui	r2,r2,16384
   2ecb0:	103fe61e 	bne	r2,zero,2ec4c <udp_new_port+0x14>
        return 0;
   2ecb4:	0005883a 	mov	r2,zero
   2ecb8:	00000606 	br	2ecd4 <udp_new_port+0x9c>
again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
    udp_port = UDP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCBs. */
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
   2ecbc:	e0bfff17 	ldw	r2,-4(fp)
   2ecc0:	10800317 	ldw	r2,12(r2)
   2ecc4:	e0bfff15 	stw	r2,-4(fp)
   2ecc8:	e0bfff17 	ldw	r2,-4(fp)
   2eccc:	103fed1e 	bne	r2,zero,2ec84 <udp_new_port+0x4c>
        return 0;
      }
      goto again;
    }
  }
  return udp_port;
   2ecd0:	d0a0150b 	ldhu	r2,-32684(gp)
  if (ipcb != NULL) {
    return 0;
  }
  return udp_port;
#endif
}
   2ecd4:	e037883a 	mov	sp,fp
   2ecd8:	df000017 	ldw	fp,0(sp)
   2ecdc:	dec00104 	addi	sp,sp,4
   2ece0:	f800283a 	ret

0002ece4 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
   2ece4:	defff304 	addi	sp,sp,-52
   2ece8:	dfc00c15 	stw	ra,48(sp)
   2ecec:	df000b15 	stw	fp,44(sp)
   2ecf0:	df000b04 	addi	fp,sp,44
   2ecf4:	e13ffe15 	stw	r4,-8(fp)
   2ecf8:	e17fff15 	stw	r5,-4(fp)
  u8_t local_match;
  u8_t broadcast;

  PERF_START;

  UDP_STATS_INC(udp.recv);
   2ecfc:	008001f4 	movhi	r2,7
   2ed00:	10ac6e04 	addi	r2,r2,-20040
   2ed04:	10803d17 	ldw	r2,244(r2)
   2ed08:	10c00044 	addi	r3,r2,1
   2ed0c:	008001f4 	movhi	r2,7
   2ed10:	10ac6e04 	addi	r2,r2,-20040
   2ed14:	10c03d15 	stw	r3,244(r2)

  iphdr = (struct ip_hdr *)p->payload;
   2ed18:	e0bffe17 	ldw	r2,-8(fp)
   2ed1c:	10800117 	ldw	r2,4(r2)
   2ed20:	e0bffa15 	stw	r2,-24(fp)

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
   2ed24:	e0bffe17 	ldw	r2,-8(fp)
   2ed28:	1080020b 	ldhu	r2,8(r2)
   2ed2c:	10ffffcc 	andi	r3,r2,65535
   2ed30:	e0bffa17 	ldw	r2,-24(fp)
   2ed34:	10800003 	ldbu	r2,0(r2)
   2ed38:	10803fcc 	andi	r2,r2,255
   2ed3c:	108003cc 	andi	r2,r2,15
   2ed40:	10800084 	addi	r2,r2,2
   2ed44:	1085883a 	add	r2,r2,r2
   2ed48:	1085883a 	add	r2,r2,r2
   2ed4c:	18800f16 	blt	r3,r2,2ed8c <udp_input+0xa8>
   2ed50:	e0bffa17 	ldw	r2,-24(fp)
   2ed54:	10800003 	ldbu	r2,0(r2)
   2ed58:	10803fcc 	andi	r2,r2,255
   2ed5c:	108003cc 	andi	r2,r2,15
   2ed60:	1085883a 	add	r2,r2,r2
   2ed64:	1085883a 	add	r2,r2,r2
   2ed68:	0085c83a 	sub	r2,zero,r2
   2ed6c:	10bfffcc 	andi	r2,r2,65535
   2ed70:	10a0001c 	xori	r2,r2,32768
   2ed74:	10a00004 	addi	r2,r2,-32768
   2ed78:	e13ffe17 	ldw	r4,-8(fp)
   2ed7c:	100b883a 	mov	r5,r2
   2ed80:	00235b00 	call	235b0 <pbuf_header>
   2ed84:	10803fcc 	andi	r2,r2,255
   2ed88:	10001126 	beq	r2,zero,2edd0 <udp_input+0xec>
    /* drop short packets */
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
   2ed8c:	008001f4 	movhi	r2,7
   2ed90:	10ac6e04 	addi	r2,r2,-20040
   2ed94:	10804117 	ldw	r2,260(r2)
   2ed98:	10c00044 	addi	r3,r2,1
   2ed9c:	008001f4 	movhi	r2,7
   2eda0:	10ac6e04 	addi	r2,r2,-20040
   2eda4:	10c04115 	stw	r3,260(r2)
    UDP_STATS_INC(udp.drop);
   2eda8:	008001f4 	movhi	r2,7
   2edac:	10ac6e04 	addi	r2,r2,-20040
   2edb0:	10803f17 	ldw	r2,252(r2)
   2edb4:	10c00044 	addi	r3,r2,1
   2edb8:	008001f4 	movhi	r2,7
   2edbc:	10ac6e04 	addi	r2,r2,-20040
   2edc0:	10c03f15 	stw	r3,252(r2)
    snmp_inc_udpinerrors();
    pbuf_free(p);
   2edc4:	e13ffe17 	ldw	r4,-8(fp)
   2edc8:	00237600 	call	23760 <pbuf_free>
    goto end;
   2edcc:	00012f06 	br	2f28c <udp_input+0x5a8>
  }

  udphdr = (struct udp_hdr *)p->payload;
   2edd0:	e0bffe17 	ldw	r2,-8(fp)
   2edd4:	10800117 	ldw	r2,4(r2)
   2edd8:	e0bffb15 	stw	r2,-20(fp)

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
   2eddc:	00800134 	movhi	r2,4
   2ede0:	109ee404 	addi	r2,r2,31632
   2ede4:	10800017 	ldw	r2,0(r2)
   2ede8:	1009883a 	mov	r4,r2
   2edec:	e17fff17 	ldw	r5,-4(fp)
   2edf0:	001fa400 	call	1fa40 <ip4_addr_isbroadcast>
   2edf4:	e0bffc05 	stb	r2,-16(fp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
   2edf8:	e0bffb17 	ldw	r2,-20(fp)
   2edfc:	10c00003 	ldbu	r3,0(r2)
   2ee00:	10800043 	ldbu	r2,1(r2)
   2ee04:	1004923a 	slli	r2,r2,8
   2ee08:	10c4b03a 	or	r2,r2,r3
   2ee0c:	10bfffcc 	andi	r2,r2,65535
   2ee10:	1004d23a 	srli	r2,r2,8
   2ee14:	1007883a 	mov	r3,r2
   2ee18:	e0bffb17 	ldw	r2,-20(fp)
   2ee1c:	11000003 	ldbu	r4,0(r2)
   2ee20:	10800043 	ldbu	r2,1(r2)
   2ee24:	1004923a 	slli	r2,r2,8
   2ee28:	1104b03a 	or	r2,r2,r4
   2ee2c:	10bfffcc 	andi	r2,r2,65535
   2ee30:	1004923a 	slli	r2,r2,8
   2ee34:	1884b03a 	or	r2,r3,r2
   2ee38:	e0bffc8d 	sth	r2,-14(fp)
  dest = ntohs(udphdr->dest);
   2ee3c:	e0bffb17 	ldw	r2,-20(fp)
   2ee40:	10c00083 	ldbu	r3,2(r2)
   2ee44:	108000c3 	ldbu	r2,3(r2)
   2ee48:	1004923a 	slli	r2,r2,8
   2ee4c:	10c4b03a 	or	r2,r2,r3
   2ee50:	10bfffcc 	andi	r2,r2,65535
   2ee54:	1004d23a 	srli	r2,r2,8
   2ee58:	1007883a 	mov	r3,r2
   2ee5c:	e0bffb17 	ldw	r2,-20(fp)
   2ee60:	11000083 	ldbu	r4,2(r2)
   2ee64:	108000c3 	ldbu	r2,3(r2)
   2ee68:	1004923a 	slli	r2,r2,8
   2ee6c:	1104b03a 	or	r2,r2,r4
   2ee70:	10bfffcc 	andi	r2,r2,65535
   2ee74:	1004923a 	slli	r2,r2,8
   2ee78:	1884b03a 	or	r2,r3,r2
   2ee7c:	e0bffd0d 	sth	r2,-12(fp)
               ip4_addr3_16(&iphdr->dest), ip4_addr4_16(&iphdr->dest), ntohs(udphdr->dest),
               ip4_addr1_16(&iphdr->src), ip4_addr2_16(&iphdr->src),
               ip4_addr3_16(&iphdr->src), ip4_addr4_16(&iphdr->src), ntohs(udphdr->src)));

#if LWIP_DHCP
  pcb = NULL;
   2ee80:	e03ff615 	stw	zero,-40(fp)
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
   2ee84:	e0bffd0b 	ldhu	r2,-12(fp)
   2ee88:	10801118 	cmpnei	r2,r2,68
   2ee8c:	1000211e 	bne	r2,zero,2ef14 <udp_input+0x230>
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
   2ee90:	e0bffc8b 	ldhu	r2,-14(fp)
   2ee94:	108010d8 	cmpnei	r2,r2,67
   2ee98:	1000801e 	bne	r2,zero,2f09c <udp_input+0x3b8>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
   2ee9c:	e0bfff17 	ldw	r2,-4(fp)
   2eea0:	10800a17 	ldw	r2,40(r2)
   2eea4:	10007d26 	beq	r2,zero,2f09c <udp_input+0x3b8>
   2eea8:	e0bfff17 	ldw	r2,-4(fp)
   2eeac:	10800a17 	ldw	r2,40(r2)
   2eeb0:	10800117 	ldw	r2,4(r2)
   2eeb4:	10007926 	beq	r2,zero,2f09c <udp_input+0x3b8>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
   2eeb8:	e0bfff17 	ldw	r2,-4(fp)
   2eebc:	10800a17 	ldw	r2,40(r2)
   2eec0:	10800117 	ldw	r2,4(r2)
   2eec4:	10800104 	addi	r2,r2,4
   2eec8:	10000d26 	beq	r2,zero,2ef00 <udp_input+0x21c>
   2eecc:	e0bfff17 	ldw	r2,-4(fp)
   2eed0:	10800a17 	ldw	r2,40(r2)
   2eed4:	10800117 	ldw	r2,4(r2)
   2eed8:	10800117 	ldw	r2,4(r2)
   2eedc:	10000826 	beq	r2,zero,2ef00 <udp_input+0x21c>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &current_iphdr_src))) {
   2eee0:	e0bfff17 	ldw	r2,-4(fp)
   2eee4:	10800a17 	ldw	r2,40(r2)
   2eee8:	10800117 	ldw	r2,4(r2)
   2eeec:	10c00117 	ldw	r3,4(r2)
   2eef0:	00800134 	movhi	r2,4
   2eef4:	109ee204 	addi	r2,r2,31624
   2eef8:	10800017 	ldw	r2,0(r2)
    if (src == DHCP_SERVER_PORT) {
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
   2eefc:	1880671e 	bne	r3,r2,2f09c <udp_input+0x3b8>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &current_iphdr_src))) {
          pcb = inp->dhcp->pcb;
   2ef00:	e0bfff17 	ldw	r2,-4(fp)
   2ef04:	10800a17 	ldw	r2,40(r2)
   2ef08:	10800117 	ldw	r2,4(r2)
   2ef0c:	e0bff615 	stw	r2,-40(fp)
   2ef10:	00006206 	br	2f09c <udp_input+0x3b8>
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
   2ef14:	e03ff715 	stw	zero,-36(fp)
    local_match = 0;
   2ef18:	e03ff905 	stb	zero,-28(fp)
    uncon_pcb = NULL;
   2ef1c:	e03ff815 	stw	zero,-32(fp)
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
   2ef20:	d0a94617 	ldw	r2,-23272(gp)
   2ef24:	e0bff615 	stw	r2,-40(fp)
   2ef28:	00005606 	br	2f084 <udp_input+0x3a0>
      local_match = 0;
   2ef2c:	e03ff905 	stb	zero,-28(fp)
                   ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip), pcb->local_port,
                   ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                   ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
   2ef30:	e0bff617 	ldw	r2,-40(fp)
   2ef34:	1080048b 	ldhu	r2,18(r2)
   2ef38:	10ffffcc 	andi	r3,r2,65535
   2ef3c:	e0bffd0b 	ldhu	r2,-12(fp)
   2ef40:	1880241e 	bne	r3,r2,2efd4 <udp_input+0x2f0>
   2ef44:	e0bffc03 	ldbu	r2,-16(fp)
   2ef48:	1000051e 	bne	r2,zero,2ef60 <udp_input+0x27c>
          ((!broadcast && ip_addr_isany(&pcb->local_ip)) ||
   2ef4c:	e0bff617 	ldw	r2,-40(fp)
   2ef50:	10001526 	beq	r2,zero,2efa8 <udp_input+0x2c4>
   2ef54:	e0bff617 	ldw	r2,-40(fp)
   2ef58:	10800017 	ldw	r2,0(r2)
   2ef5c:	10001226 	beq	r2,zero,2efa8 <udp_input+0x2c4>
           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest) ||
   2ef60:	e0bff617 	ldw	r2,-40(fp)
   2ef64:	10c00017 	ldw	r3,0(r2)
   2ef68:	00800134 	movhi	r2,4
   2ef6c:	109ee404 	addi	r2,r2,31632
   2ef70:	10800017 	ldw	r2,0(r2)
                   ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                   ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
          ((!broadcast && ip_addr_isany(&pcb->local_ip)) ||
   2ef74:	18800c26 	beq	r3,r2,2efa8 <udp_input+0x2c4>
           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest) ||
   2ef78:	e0bffc03 	ldbu	r2,-16(fp)
   2ef7c:	10001526 	beq	r2,zero,2efd4 <udp_input+0x2f0>
#endif /* LWIP_IGMP */
#if IP_SOF_BROADCAST_RECV
            (broadcast && ip_get_option(pcb, SOF_BROADCAST) &&
#else /* IP_SOF_BROADCAST_RECV */
            (broadcast &&
			(ip_addr_cmp(&(pcb->local_ip), &(inp->ip_addr)) || 
   2ef80:	e0bff617 	ldw	r2,-40(fp)
   2ef84:	10c00017 	ldw	r3,0(r2)
   2ef88:	e0bfff17 	ldw	r2,-4(fp)
   2ef8c:	10800117 	ldw	r2,4(r2)
           ip_addr_ismulticast(&current_iphdr_dest) ||
#endif /* LWIP_IGMP */
#if IP_SOF_BROADCAST_RECV
            (broadcast && ip_get_option(pcb, SOF_BROADCAST) &&
#else /* IP_SOF_BROADCAST_RECV */
            (broadcast &&
   2ef90:	18800526 	beq	r3,r2,2efa8 <udp_input+0x2c4>
			(ip_addr_cmp(&(pcb->local_ip), &(inp->ip_addr)) || 
			 ip_addr_isany(&pcb->local_ip))))) {
   2ef94:	e0bff617 	ldw	r2,-40(fp)
#endif /* LWIP_IGMP */
#if IP_SOF_BROADCAST_RECV
            (broadcast && ip_get_option(pcb, SOF_BROADCAST) &&
#else /* IP_SOF_BROADCAST_RECV */
            (broadcast &&
			(ip_addr_cmp(&(pcb->local_ip), &(inp->ip_addr)) || 
   2ef98:	10000326 	beq	r2,zero,2efa8 <udp_input+0x2c4>
			 ip_addr_isany(&pcb->local_ip))))) {
   2ef9c:	e0bff617 	ldw	r2,-40(fp)
   2efa0:	10800017 	ldw	r2,0(r2)
   2efa4:	10000b1e 	bne	r2,zero,2efd4 <udp_input+0x2f0>
#endif /* IP_SOF_BROADCAST_RECV */ 
          local_match = 1;
   2efa8:	00800044 	movi	r2,1
   2efac:	e0bff905 	stb	r2,-28(fp)
          if ((uncon_pcb == NULL) && 
   2efb0:	e0bff817 	ldw	r2,-32(fp)
   2efb4:	1000071e 	bne	r2,zero,2efd4 <udp_input+0x2f0>
              ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
   2efb8:	e0bff617 	ldw	r2,-40(fp)
   2efbc:	10800403 	ldbu	r2,16(r2)
   2efc0:	10803fcc 	andi	r2,r2,255
   2efc4:	1080010c 	andi	r2,r2,4
            (broadcast &&
			(ip_addr_cmp(&(pcb->local_ip), &(inp->ip_addr)) || 
			 ip_addr_isany(&pcb->local_ip))))) {
#endif /* IP_SOF_BROADCAST_RECV */ 
          local_match = 1;
          if ((uncon_pcb == NULL) && 
   2efc8:	1000021e 	bne	r2,zero,2efd4 <udp_input+0x2f0>
              ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
            /* the first unconnected matching PCB */
            uncon_pcb = pcb;
   2efcc:	e0bff617 	ldw	r2,-40(fp)
   2efd0:	e0bff815 	stw	r2,-32(fp)
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
   2efd4:	e0bff903 	ldbu	r2,-28(fp)
   2efd8:	10002526 	beq	r2,zero,2f070 <udp_input+0x38c>
          (pcb->remote_port == src) &&
   2efdc:	e0bff617 	ldw	r2,-40(fp)
   2efe0:	1080050b 	ldhu	r2,20(r2)
            /* the first unconnected matching PCB */
            uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
   2efe4:	10ffffcc 	andi	r3,r2,65535
   2efe8:	e0bffc8b 	ldhu	r2,-14(fp)
   2efec:	1880201e 	bne	r3,r2,2f070 <udp_input+0x38c>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
   2eff0:	e0bff617 	ldw	r2,-40(fp)
   2eff4:	10800104 	addi	r2,r2,4
            uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
   2eff8:	10000926 	beq	r2,zero,2f020 <udp_input+0x33c>
          (ip_addr_isany(&pcb->remote_ip) ||
   2effc:	e0bff617 	ldw	r2,-40(fp)
   2f000:	10800117 	ldw	r2,4(r2)
   2f004:	10000626 	beq	r2,zero,2f020 <udp_input+0x33c>
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
   2f008:	e0bff617 	ldw	r2,-40(fp)
   2f00c:	10c00117 	ldw	r3,4(r2)
   2f010:	00800134 	movhi	r2,4
   2f014:	109ee204 	addi	r2,r2,31624
   2f018:	10800017 	ldw	r2,0(r2)
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
   2f01c:	1880141e 	bne	r3,r2,2f070 <udp_input+0x38c>
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
   2f020:	e0bff717 	ldw	r2,-36(fp)
   2f024:	10000a26 	beq	r2,zero,2f050 <udp_input+0x36c>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
   2f028:	e0bff617 	ldw	r2,-40(fp)
   2f02c:	10c00317 	ldw	r3,12(r2)
   2f030:	e0bff717 	ldw	r2,-36(fp)
   2f034:	10c00315 	stw	r3,12(r2)
          pcb->next = udp_pcbs;
   2f038:	d0e94617 	ldw	r3,-23272(gp)
   2f03c:	e0bff617 	ldw	r2,-40(fp)
   2f040:	10c00315 	stw	r3,12(r2)
          udp_pcbs = pcb;
   2f044:	e0bff617 	ldw	r2,-40(fp)
   2f048:	d0a94615 	stw	r2,-23272(gp)
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
   2f04c:	00000f06 	br	2f08c <udp_input+0x3a8>
             found faster next time */
          prev->next = pcb->next;
          pcb->next = udp_pcbs;
          udp_pcbs = pcb;
        } else {
          UDP_STATS_INC(udp.cachehit);
   2f050:	008001f4 	movhi	r2,7
   2f054:	10ac6e04 	addi	r2,r2,-20040
   2f058:	10804717 	ldw	r2,284(r2)
   2f05c:	10c00044 	addi	r3,r2,1
   2f060:	008001f4 	movhi	r2,7
   2f064:	10ac6e04 	addi	r2,r2,-20040
   2f068:	10c04715 	stw	r3,284(r2)
        }
        break;
   2f06c:	00000706 	br	2f08c <udp_input+0x3a8>
      }
      prev = pcb;
   2f070:	e0bff617 	ldw	r2,-40(fp)
   2f074:	e0bff715 	stw	r2,-36(fp)
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
   2f078:	e0bff617 	ldw	r2,-40(fp)
   2f07c:	10800317 	ldw	r2,12(r2)
   2f080:	e0bff615 	stw	r2,-40(fp)
   2f084:	e0bff617 	ldw	r2,-40(fp)
   2f088:	103fa81e 	bne	r2,zero,2ef2c <udp_input+0x248>
        break;
      }
      prev = pcb;
    }
    /* no fully matching pcb found? then look for an unconnected pcb */
    if (pcb == NULL) {
   2f08c:	e0bff617 	ldw	r2,-40(fp)
   2f090:	1000021e 	bne	r2,zero,2f09c <udp_input+0x3b8>
      pcb = uncon_pcb;
   2f094:	e0bff817 	ldw	r2,-32(fp)
   2f098:	e0bff615 	stw	r2,-40(fp)
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
   2f09c:	e0bff617 	ldw	r2,-40(fp)
   2f0a0:	1000061e 	bne	r2,zero,2f0bc <udp_input+0x3d8>
   2f0a4:	e0bfff17 	ldw	r2,-4(fp)
   2f0a8:	10c00117 	ldw	r3,4(r2)
   2f0ac:	00800134 	movhi	r2,4
   2f0b0:	109ee404 	addi	r2,r2,31632
   2f0b4:	10800017 	ldw	r2,0(r2)
   2f0b8:	1880721e 	bne	r3,r2,2f284 <udp_input+0x5a0>
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
   2f0bc:	e0bffb17 	ldw	r2,-20(fp)
   2f0c0:	10c00183 	ldbu	r3,6(r2)
   2f0c4:	108001c3 	ldbu	r2,7(r2)
   2f0c8:	1004923a 	slli	r2,r2,8
   2f0cc:	10c4b03a 	or	r2,r2,r3
   2f0d0:	10bfffcc 	andi	r2,r2,65535
   2f0d4:	10001e26 	beq	r2,zero,2f150 <udp_input+0x46c>
        if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
                               IP_PROTO_UDP, p->tot_len) != 0) {
   2f0d8:	e0bffe17 	ldw	r2,-8(fp)
   2f0dc:	1080020b 	ldhu	r2,8(r2)
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
        if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
   2f0e0:	10bfffcc 	andi	r2,r2,65535
   2f0e4:	d8800015 	stw	r2,0(sp)
   2f0e8:	e13ffe17 	ldw	r4,-8(fp)
   2f0ec:	01400134 	movhi	r5,4
   2f0f0:	295ee204 	addi	r5,r5,31624
   2f0f4:	01800134 	movhi	r6,4
   2f0f8:	319ee404 	addi	r6,r6,31632
   2f0fc:	01c00444 	movi	r7,17
   2f100:	003e2ac0 	call	3e2ac <inet_chksum_pseudo>
   2f104:	10bfffcc 	andi	r2,r2,65535
   2f108:	10001126 	beq	r2,zero,2f150 <udp_input+0x46c>
                               IP_PROTO_UDP, p->tot_len) != 0) {
          LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
   2f10c:	008001f4 	movhi	r2,7
   2f110:	10ac6e04 	addi	r2,r2,-20040
   2f114:	10804017 	ldw	r2,256(r2)
   2f118:	10c00044 	addi	r3,r2,1
   2f11c:	008001f4 	movhi	r2,7
   2f120:	10ac6e04 	addi	r2,r2,-20040
   2f124:	10c04015 	stw	r3,256(r2)
          UDP_STATS_INC(udp.drop);
   2f128:	008001f4 	movhi	r2,7
   2f12c:	10ac6e04 	addi	r2,r2,-20040
   2f130:	10803f17 	ldw	r2,252(r2)
   2f134:	10c00044 	addi	r3,r2,1
   2f138:	008001f4 	movhi	r2,7
   2f13c:	10ac6e04 	addi	r2,r2,-20040
   2f140:	10c03f15 	stw	r3,252(r2)
          snmp_inc_udpinerrors();
          pbuf_free(p);
   2f144:	e13ffe17 	ldw	r4,-8(fp)
   2f148:	00237600 	call	23760 <pbuf_free>
          goto end;
   2f14c:	00004f06 	br	2f28c <udp_input+0x5a8>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
   2f150:	e13ffe17 	ldw	r4,-8(fp)
   2f154:	017ffe04 	movi	r5,-8
   2f158:	00235b00 	call	235b0 <pbuf_header>
   2f15c:	10803fcc 	andi	r2,r2,255
   2f160:	10000a26 	beq	r2,zero,2f18c <udp_input+0x4a8>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
      UDP_STATS_INC(udp.drop);
   2f164:	008001f4 	movhi	r2,7
   2f168:	10ac6e04 	addi	r2,r2,-20040
   2f16c:	10803f17 	ldw	r2,252(r2)
   2f170:	10c00044 	addi	r3,r2,1
   2f174:	008001f4 	movhi	r2,7
   2f178:	10ac6e04 	addi	r2,r2,-20040
   2f17c:	10c03f15 	stw	r3,252(r2)
      snmp_inc_udpinerrors();
      pbuf_free(p);
   2f180:	e13ffe17 	ldw	r4,-8(fp)
   2f184:	00237600 	call	23760 <pbuf_free>
      goto end;
   2f188:	00004006 	br	2f28c <udp_input+0x5a8>
    }
    if (pcb != NULL) {
   2f18c:	e0bff617 	ldw	r2,-40(fp)
   2f190:	10001326 	beq	r2,zero,2f1e0 <udp_input+0x4fc>
          pbuf_header(p, -(s16_t)((IPH_HL(iphdr) * 4) + UDP_HLEN));
        }
      }
#endif /* SO_REUSE && SO_REUSE_RXTOALL */
      /* callback */
      if (pcb->recv != NULL) {
   2f194:	e0bff617 	ldw	r2,-40(fp)
   2f198:	10800617 	ldw	r2,24(r2)
   2f19c:	10000d26 	beq	r2,zero,2f1d4 <udp_input+0x4f0>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
   2f1a0:	e0bff617 	ldw	r2,-40(fp)
   2f1a4:	10c00617 	ldw	r3,24(r2)
   2f1a8:	e0bff617 	ldw	r2,-40(fp)
   2f1ac:	10800717 	ldw	r2,28(r2)
   2f1b0:	e13ffc8b 	ldhu	r4,-14(fp)
   2f1b4:	d9000015 	stw	r4,0(sp)
   2f1b8:	1009883a 	mov	r4,r2
   2f1bc:	e17ff617 	ldw	r5,-40(fp)
   2f1c0:	e1bffe17 	ldw	r6,-8(fp)
   2f1c4:	01c00134 	movhi	r7,4
   2f1c8:	39dee204 	addi	r7,r7,31624
   2f1cc:	183ee83a 	callr	r3
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
   2f1d0:	00002e06 	br	2f28c <udp_input+0x5a8>
      if (pcb->recv != NULL) {
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
   2f1d4:	e13ffe17 	ldw	r4,-8(fp)
   2f1d8:	00237600 	call	23760 <pbuf_free>
        goto end;
   2f1dc:	00002b06 	br	2f28c <udp_input+0x5a8>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!broadcast &&
   2f1e0:	e0bffc03 	ldbu	r2,-16(fp)
   2f1e4:	1000161e 	bne	r2,zero,2f240 <udp_input+0x55c>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
   2f1e8:	00800134 	movhi	r2,4
   2f1ec:	109ee404 	addi	r2,r2,31632
   2f1f0:	10800017 	ldw	r2,0(r2)
   2f1f4:	10803c0c 	andi	r2,r2,240
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!broadcast &&
   2f1f8:	10803820 	cmpeqi	r2,r2,224
   2f1fc:	1000101e 	bne	r2,zero,2f240 <udp_input+0x55c>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
   2f200:	e0bffa17 	ldw	r2,-24(fp)
   2f204:	10800003 	ldbu	r2,0(r2)
   2f208:	10803fcc 	andi	r2,r2,255
   2f20c:	108003cc 	andi	r2,r2,15
   2f210:	10800084 	addi	r2,r2,2
   2f214:	1085883a 	add	r2,r2,r2
   2f218:	1085883a 	add	r2,r2,r2
   2f21c:	10bfffcc 	andi	r2,r2,65535
   2f220:	10a0001c 	xori	r2,r2,32768
   2f224:	10a00004 	addi	r2,r2,-32768
   2f228:	e13ffe17 	ldw	r4,-8(fp)
   2f22c:	100b883a 	mov	r5,r2
   2f230:	00235b00 	call	235b0 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
        icmp_dest_unreach(p, ICMP_DUR_PORT);
   2f234:	e13ffe17 	ldw	r4,-8(fp)
   2f238:	014000c4 	movi	r5,3
   2f23c:	003de140 	call	3de14 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
   2f240:	008001f4 	movhi	r2,7
   2f244:	10ac6e04 	addi	r2,r2,-20040
   2f248:	10804417 	ldw	r2,272(r2)
   2f24c:	10c00044 	addi	r3,r2,1
   2f250:	008001f4 	movhi	r2,7
   2f254:	10ac6e04 	addi	r2,r2,-20040
   2f258:	10c04415 	stw	r3,272(r2)
      UDP_STATS_INC(udp.drop);
   2f25c:	008001f4 	movhi	r2,7
   2f260:	10ac6e04 	addi	r2,r2,-20040
   2f264:	10803f17 	ldw	r2,252(r2)
   2f268:	10c00044 	addi	r3,r2,1
   2f26c:	008001f4 	movhi	r2,7
   2f270:	10ac6e04 	addi	r2,r2,-20040
   2f274:	10c03f15 	stw	r3,252(r2)
      snmp_inc_udpnoports();
      pbuf_free(p);
   2f278:	e13ffe17 	ldw	r4,-8(fp)
   2f27c:	00237600 	call	23760 <pbuf_free>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
   2f280:	00000206 	br	2f28c <udp_input+0x5a8>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
    }
  } else {
    pbuf_free(p);
   2f284:	e13ffe17 	ldw	r4,-8(fp)
   2f288:	00237600 	call	23760 <pbuf_free>
  }
end:
  PERF_STOP("udp_input");
}
   2f28c:	e037883a 	mov	sp,fp
   2f290:	dfc00117 	ldw	ra,4(sp)
   2f294:	df000017 	ldw	fp,0(sp)
   2f298:	dec00204 	addi	sp,sp,8
   2f29c:	f800283a 	ret

0002f2a0 <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
   2f2a0:	defffc04 	addi	sp,sp,-16
   2f2a4:	dfc00315 	stw	ra,12(sp)
   2f2a8:	df000215 	stw	fp,8(sp)
   2f2ac:	df000204 	addi	fp,sp,8
   2f2b0:	e13ffe15 	stw	r4,-8(fp)
   2f2b4:	e17fff15 	stw	r5,-4(fp)
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
   2f2b8:	e0bffe17 	ldw	r2,-8(fp)
   2f2bc:	10c00104 	addi	r3,r2,4
   2f2c0:	e0bffe17 	ldw	r2,-8(fp)
   2f2c4:	1080050b 	ldhu	r2,20(r2)
   2f2c8:	10bfffcc 	andi	r2,r2,65535
   2f2cc:	e13ffe17 	ldw	r4,-8(fp)
   2f2d0:	e17fff17 	ldw	r5,-4(fp)
   2f2d4:	180d883a 	mov	r6,r3
   2f2d8:	100f883a 	mov	r7,r2
   2f2dc:	002f3680 	call	2f368 <udp_sendto>
}
   2f2e0:	e037883a 	mov	sp,fp
   2f2e4:	dfc00117 	ldw	ra,4(sp)
   2f2e8:	df000017 	ldw	fp,0(sp)
   2f2ec:	dec00204 	addi	sp,sp,8
   2f2f0:	f800283a 	ret

0002f2f4 <udp_send_chksum>:
/** Same as udp_send() but with checksum
 */
err_t
udp_send_chksum(struct udp_pcb *pcb, struct pbuf *p,
                u8_t have_chksum, u16_t chksum)
{
   2f2f4:	defff804 	addi	sp,sp,-32
   2f2f8:	dfc00715 	stw	ra,28(sp)
   2f2fc:	df000615 	stw	fp,24(sp)
   2f300:	df000604 	addi	fp,sp,24
   2f304:	e13ffc15 	stw	r4,-16(fp)
   2f308:	e17ffd15 	stw	r5,-12(fp)
   2f30c:	3007883a 	mov	r3,r6
   2f310:	3805883a 	mov	r2,r7
   2f314:	e0fffe05 	stb	r3,-8(fp)
   2f318:	e0bfff0d 	sth	r2,-4(fp)
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto_chksum(pcb, p, &pcb->remote_ip, pcb->remote_port,
   2f31c:	e0bffc17 	ldw	r2,-16(fp)
   2f320:	10c00104 	addi	r3,r2,4
   2f324:	e0bffc17 	ldw	r2,-16(fp)
   2f328:	1080050b 	ldhu	r2,20(r2)
   2f32c:	10bfffcc 	andi	r2,r2,65535
   2f330:	e17ffe03 	ldbu	r5,-8(fp)
   2f334:	e13fff0b 	ldhu	r4,-4(fp)
   2f338:	d9400015 	stw	r5,0(sp)
   2f33c:	d9000115 	stw	r4,4(sp)
   2f340:	e13ffc17 	ldw	r4,-16(fp)
   2f344:	e17ffd17 	ldw	r5,-12(fp)
   2f348:	180d883a 	mov	r6,r3
   2f34c:	100f883a 	mov	r7,r2
   2f350:	002f3c00 	call	2f3c0 <udp_sendto_chksum>
    have_chksum, chksum);
}
   2f354:	e037883a 	mov	sp,fp
   2f358:	dfc00117 	ldw	ra,4(sp)
   2f35c:	df000017 	ldw	fp,0(sp)
   2f360:	dec00204 	addi	sp,sp,8
   2f364:	f800283a 	ret

0002f368 <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  ip_addr_t *dst_ip, u16_t dst_port)
{
   2f368:	defff804 	addi	sp,sp,-32
   2f36c:	dfc00715 	stw	ra,28(sp)
   2f370:	df000615 	stw	fp,24(sp)
   2f374:	df000604 	addi	fp,sp,24
   2f378:	e13ffc15 	stw	r4,-16(fp)
   2f37c:	e17ffd15 	stw	r5,-12(fp)
   2f380:	e1bffe15 	stw	r6,-8(fp)
   2f384:	3805883a 	mov	r2,r7
   2f388:	e0bfff0d 	sth	r2,-4(fp)
#if LWIP_CHECKSUM_ON_COPY
  return udp_sendto_chksum(pcb, p, dst_ip, dst_port, 0, 0);
   2f38c:	e0bfff0b 	ldhu	r2,-4(fp)
   2f390:	d8000015 	stw	zero,0(sp)
   2f394:	d8000115 	stw	zero,4(sp)
   2f398:	e13ffc17 	ldw	r4,-16(fp)
   2f39c:	e17ffd17 	ldw	r5,-12(fp)
   2f3a0:	e1bffe17 	ldw	r6,-8(fp)
   2f3a4:	100f883a 	mov	r7,r2
   2f3a8:	002f3c00 	call	2f3c0 <udp_sendto_chksum>
}
   2f3ac:	e037883a 	mov	sp,fp
   2f3b0:	dfc00117 	ldw	ra,4(sp)
   2f3b4:	df000017 	ldw	fp,0(sp)
   2f3b8:	dec00204 	addi	sp,sp,8
   2f3bc:	f800283a 	ret

0002f3c0 <udp_sendto_chksum>:

/** Same as udp_sendto(), but with checksum */
err_t
udp_sendto_chksum(struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *dst_ip,
                  u16_t dst_port, u8_t have_chksum, u16_t chksum)
{
   2f3c0:	defff404 	addi	sp,sp,-48
   2f3c4:	dfc00b15 	stw	ra,44(sp)
   2f3c8:	df000a15 	stw	fp,40(sp)
   2f3cc:	df000a04 	addi	fp,sp,40
   2f3d0:	e13ffa15 	stw	r4,-24(fp)
   2f3d4:	e17ffb15 	stw	r5,-20(fp)
   2f3d8:	e1bffc15 	stw	r6,-16(fp)
   2f3dc:	3805883a 	mov	r2,r7
   2f3e0:	e1000217 	ldw	r4,8(fp)
   2f3e4:	e0c00317 	ldw	r3,12(fp)
   2f3e8:	e0bffd0d 	sth	r2,-12(fp)
   2f3ec:	e13ffe05 	stb	r4,-8(fp)
   2f3f0:	e0ffff0d 	sth	r3,-4(fp)

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(&(pcb->local_ip), dst_ip);
   2f3f4:	e0bffa17 	ldw	r2,-24(fp)
   2f3f8:	1009883a 	mov	r4,r2
   2f3fc:	e17ffc17 	ldw	r5,-16(fp)
   2f400:	001ecb40 	call	1ecb4 <ip_route>
   2f404:	e0bff915 	stw	r2,-28(fp)
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
   2f408:	e0bff917 	ldw	r2,-28(fp)
   2f40c:	1000091e 	bne	r2,zero,2f434 <udp_sendto_chksum+0x74>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dst_ip), ip4_addr2_16(dst_ip), ip4_addr3_16(dst_ip), ip4_addr4_16(dst_ip)));
    UDP_STATS_INC(udp.rterr);
   2f410:	008001f4 	movhi	r2,7
   2f414:	10ac6e04 	addi	r2,r2,-20040
   2f418:	10804317 	ldw	r2,268(r2)
   2f41c:	10c00044 	addi	r3,r2,1
   2f420:	008001f4 	movhi	r2,7
   2f424:	10ac6e04 	addi	r2,r2,-20040
   2f428:	10c04315 	stw	r3,268(r2)
    return ERR_RTE;
   2f42c:	00bfff04 	movi	r2,-4
   2f430:	00000c06 	br	2f464 <udp_sendto_chksum+0xa4>
  }
#if LWIP_CHECKSUM_ON_COPY
  return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum);
   2f434:	e0bffd0b 	ldhu	r2,-12(fp)
   2f438:	e13ffe03 	ldbu	r4,-8(fp)
   2f43c:	e0ffff0b 	ldhu	r3,-4(fp)
   2f440:	e17ff917 	ldw	r5,-28(fp)
   2f444:	d9400015 	stw	r5,0(sp)
   2f448:	d9000115 	stw	r4,4(sp)
   2f44c:	d8c00215 	stw	r3,8(sp)
   2f450:	e13ffa17 	ldw	r4,-24(fp)
   2f454:	e17ffb17 	ldw	r5,-20(fp)
   2f458:	e1bffc17 	ldw	r6,-16(fp)
   2f45c:	100f883a 	mov	r7,r2
   2f460:	002f4d80 	call	2f4d8 <udp_sendto_if_chksum>
#else /* LWIP_CHECKSUM_ON_COPY */
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
#endif /* LWIP_CHECKSUM_ON_COPY */
}
   2f464:	e037883a 	mov	sp,fp
   2f468:	dfc00117 	ldw	ra,4(sp)
   2f46c:	df000017 	ldw	fp,0(sp)
   2f470:	dec00204 	addi	sp,sp,8
   2f474:	f800283a 	ret

0002f478 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif)
{
   2f478:	defff704 	addi	sp,sp,-36
   2f47c:	dfc00815 	stw	ra,32(sp)
   2f480:	df000715 	stw	fp,28(sp)
   2f484:	df000704 	addi	fp,sp,28
   2f488:	e13ffc15 	stw	r4,-16(fp)
   2f48c:	e17ffd15 	stw	r5,-12(fp)
   2f490:	e1bffe15 	stw	r6,-8(fp)
   2f494:	3805883a 	mov	r2,r7
   2f498:	e0bfff0d 	sth	r2,-4(fp)
#if LWIP_CHECKSUM_ON_COPY
  return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, 0, 0);
   2f49c:	e0bfff0b 	ldhu	r2,-4(fp)
   2f4a0:	e0c00217 	ldw	r3,8(fp)
   2f4a4:	d8c00015 	stw	r3,0(sp)
   2f4a8:	d8000115 	stw	zero,4(sp)
   2f4ac:	d8000215 	stw	zero,8(sp)
   2f4b0:	e13ffc17 	ldw	r4,-16(fp)
   2f4b4:	e17ffd17 	ldw	r5,-12(fp)
   2f4b8:	e1bffe17 	ldw	r6,-8(fp)
   2f4bc:	100f883a 	mov	r7,r2
   2f4c0:	002f4d80 	call	2f4d8 <udp_sendto_if_chksum>
}
   2f4c4:	e037883a 	mov	sp,fp
   2f4c8:	dfc00117 	ldw	ra,4(sp)
   2f4cc:	df000017 	ldw	fp,0(sp)
   2f4d0:	dec00204 	addi	sp,sp,8
   2f4d4:	f800283a 	ret

0002f4d8 <udp_sendto_if_chksum>:
/** Same as udp_sendto_if(), but with checksum */
err_t
udp_sendto_if_chksum(struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *dst_ip,
                     u16_t dst_port, struct netif *netif, u8_t have_chksum,
                     u16_t chksum)
{
   2f4d8:	defff004 	addi	sp,sp,-64
   2f4dc:	dfc00f15 	stw	ra,60(sp)
   2f4e0:	df000e15 	stw	fp,56(sp)
   2f4e4:	df000e04 	addi	fp,sp,56
   2f4e8:	e13ffa15 	stw	r4,-24(fp)
   2f4ec:	e17ffb15 	stw	r5,-20(fp)
   2f4f0:	e1bffc15 	stw	r6,-16(fp)
   2f4f4:	3805883a 	mov	r2,r7
   2f4f8:	e1000317 	ldw	r4,12(fp)
   2f4fc:	e0c00417 	ldw	r3,16(fp)
   2f500:	e0bffd0d 	sth	r2,-12(fp)
   2f504:	e13ffe05 	stb	r4,-8(fp)
   2f508:	e0ffff0d 	sth	r3,-4(fp)
    return ERR_VAL;
  }
#endif /* IP_SOF_BROADCAST */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
   2f50c:	e0bffa17 	ldw	r2,-24(fp)
   2f510:	1080048b 	ldhu	r2,18(r2)
   2f514:	10bfffcc 	andi	r2,r2,65535
   2f518:	10000d1e 	bne	r2,zero,2f550 <udp_sendto_if_chksum+0x78>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
   2f51c:	e0fffa17 	ldw	r3,-24(fp)
   2f520:	e0bffa17 	ldw	r2,-24(fp)
   2f524:	1080048b 	ldhu	r2,18(r2)
   2f528:	10bfffcc 	andi	r2,r2,65535
   2f52c:	e13ffa17 	ldw	r4,-24(fp)
   2f530:	180b883a 	mov	r5,r3
   2f534:	100d883a 	mov	r6,r2
   2f538:	002f8ec0 	call	2f8ec <udp_bind>
   2f53c:	e0bff785 	stb	r2,-34(fp)
    if (err != ERR_OK) {
   2f540:	e0bff787 	ldb	r2,-34(fp)
   2f544:	10000226 	beq	r2,zero,2f550 <udp_sendto_if_chksum+0x78>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind failed\n"));
      return err;
   2f548:	e0bff783 	ldbu	r2,-34(fp)
   2f54c:	0000e206 	br	2f8d8 <udp_sendto_if_chksum+0x400>
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
   2f550:	e13ffb17 	ldw	r4,-20(fp)
   2f554:	01400204 	movi	r5,8
   2f558:	00235b00 	call	235b0 <pbuf_header>
   2f55c:	10803fcc 	andi	r2,r2,255
   2f560:	10001126 	beq	r2,zero,2f5a8 <udp_sendto_if_chksum+0xd0>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
   2f564:	01000044 	movi	r4,1
   2f568:	01400204 	movi	r5,8
   2f56c:	000d883a 	mov	r6,zero
   2f570:	0022fa00 	call	22fa0 <pbuf_alloc>
   2f574:	e0bff615 	stw	r2,-40(fp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
   2f578:	e0bff617 	ldw	r2,-40(fp)
   2f57c:	1000021e 	bne	r2,zero,2f588 <udp_sendto_if_chksum+0xb0>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
   2f580:	00bfffc4 	movi	r2,-1
   2f584:	0000d406 	br	2f8d8 <udp_sendto_if_chksum+0x400>
    }
    if (p->tot_len != 0) {
   2f588:	e0bffb17 	ldw	r2,-20(fp)
   2f58c:	1080020b 	ldhu	r2,8(r2)
   2f590:	10bfffcc 	andi	r2,r2,65535
   2f594:	10000626 	beq	r2,zero,2f5b0 <udp_sendto_if_chksum+0xd8>
      /* chain header q in front of given pbuf p (only if p contains data) */
      pbuf_chain(q, p);
   2f598:	e13ff617 	ldw	r4,-40(fp)
   2f59c:	e17ffb17 	ldw	r5,-20(fp)
   2f5a0:	0023a200 	call	23a20 <pbuf_chain>
   2f5a4:	00000206 	br	2f5b0 <udp_sendto_if_chksum+0xd8>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
   2f5a8:	e0bffb17 	ldw	r2,-20(fp)
   2f5ac:	e0bff615 	stw	r2,-40(fp)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = (struct udp_hdr *)q->payload;
   2f5b0:	e0bff617 	ldw	r2,-40(fp)
   2f5b4:	10800117 	ldw	r2,4(r2)
   2f5b8:	e0bff815 	stw	r2,-32(fp)
  udphdr->src = htons(pcb->local_port);
   2f5bc:	e0bffa17 	ldw	r2,-24(fp)
   2f5c0:	1080048b 	ldhu	r2,18(r2)
   2f5c4:	10bfffcc 	andi	r2,r2,65535
   2f5c8:	1004d23a 	srli	r2,r2,8
   2f5cc:	1007883a 	mov	r3,r2
   2f5d0:	e0bffa17 	ldw	r2,-24(fp)
   2f5d4:	1080048b 	ldhu	r2,18(r2)
   2f5d8:	10bfffcc 	andi	r2,r2,65535
   2f5dc:	1004923a 	slli	r2,r2,8
   2f5e0:	1884b03a 	or	r2,r3,r2
   2f5e4:	1007883a 	mov	r3,r2
   2f5e8:	e0bff817 	ldw	r2,-32(fp)
   2f5ec:	193fffcc 	andi	r4,r3,65535
   2f5f0:	21003fcc 	andi	r4,r4,255
   2f5f4:	11400003 	ldbu	r5,0(r2)
   2f5f8:	280a703a 	and	r5,r5,zero
   2f5fc:	2908b03a 	or	r4,r5,r4
   2f600:	11000005 	stb	r4,0(r2)
   2f604:	18ffffcc 	andi	r3,r3,65535
   2f608:	1806d23a 	srli	r3,r3,8
   2f60c:	18ffffcc 	andi	r3,r3,65535
   2f610:	11000043 	ldbu	r4,1(r2)
   2f614:	2008703a 	and	r4,r4,zero
   2f618:	20c6b03a 	or	r3,r4,r3
   2f61c:	10c00045 	stb	r3,1(r2)
  udphdr->dest = htons(dst_port);
   2f620:	e0bffd0b 	ldhu	r2,-12(fp)
   2f624:	1004d23a 	srli	r2,r2,8
   2f628:	1007883a 	mov	r3,r2
   2f62c:	e0bffd0b 	ldhu	r2,-12(fp)
   2f630:	1004923a 	slli	r2,r2,8
   2f634:	1884b03a 	or	r2,r3,r2
   2f638:	1007883a 	mov	r3,r2
   2f63c:	e0bff817 	ldw	r2,-32(fp)
   2f640:	193fffcc 	andi	r4,r3,65535
   2f644:	21003fcc 	andi	r4,r4,255
   2f648:	11400083 	ldbu	r5,2(r2)
   2f64c:	280a703a 	and	r5,r5,zero
   2f650:	2908b03a 	or	r4,r5,r4
   2f654:	11000085 	stb	r4,2(r2)
   2f658:	18ffffcc 	andi	r3,r3,65535
   2f65c:	1806d23a 	srli	r3,r3,8
   2f660:	18ffffcc 	andi	r3,r3,65535
   2f664:	110000c3 	ldbu	r4,3(r2)
   2f668:	2008703a 	and	r4,r4,zero
   2f66c:	20c6b03a 	or	r3,r4,r3
   2f670:	10c000c5 	stb	r3,3(r2)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
   2f674:	e0bff817 	ldw	r2,-32(fp)
   2f678:	10c00183 	ldbu	r3,6(r2)
   2f67c:	1806703a 	and	r3,r3,zero
   2f680:	10c00185 	stb	r3,6(r2)
   2f684:	10c001c3 	ldbu	r3,7(r2)
   2f688:	1806703a 	and	r3,r3,zero
   2f68c:	10c001c5 	stb	r3,7(r2)
  }
#endif /* LWIP_IGMP */


  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
   2f690:	e0bffa17 	ldw	r2,-24(fp)
   2f694:	10000326 	beq	r2,zero,2f6a4 <udp_sendto_if_chksum+0x1cc>
   2f698:	e0bffa17 	ldw	r2,-24(fp)
   2f69c:	10800017 	ldw	r2,0(r2)
   2f6a0:	1000041e 	bne	r2,zero,2f6b4 <udp_sendto_if_chksum+0x1dc>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
   2f6a4:	e0800217 	ldw	r2,8(fp)
   2f6a8:	10800104 	addi	r2,r2,4
   2f6ac:	e0bff515 	stw	r2,-44(fp)
   2f6b0:	00000f06 	br	2f6f0 <udp_sendto_if_chksum+0x218>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
   2f6b4:	e0bffa17 	ldw	r2,-24(fp)
   2f6b8:	10c00017 	ldw	r3,0(r2)
   2f6bc:	e0800217 	ldw	r2,8(fp)
   2f6c0:	10800117 	ldw	r2,4(r2)
   2f6c4:	18800826 	beq	r3,r2,2f6e8 <udp_sendto_if_chksum+0x210>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
   2f6c8:	e0fff617 	ldw	r3,-40(fp)
   2f6cc:	e0bffb17 	ldw	r2,-20(fp)
   2f6d0:	18800326 	beq	r3,r2,2f6e0 <udp_sendto_if_chksum+0x208>
        /* free the header pbuf */
        pbuf_free(q);
   2f6d4:	e13ff617 	ldw	r4,-40(fp)
   2f6d8:	00237600 	call	23760 <pbuf_free>
        q = NULL;
   2f6dc:	e03ff615 	stw	zero,-40(fp)
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
   2f6e0:	00bffe84 	movi	r2,-6
   2f6e4:	00007c06 	br	2f8d8 <udp_sendto_if_chksum+0x400>
    }
    /* use UDP PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
   2f6e8:	e0bffa17 	ldw	r2,-24(fp)
   2f6ec:	e0bff515 	stw	r2,-44(fp)
    NETIF_SET_HWADDRHINT(netif, NULL);
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
   2f6f0:	e0bff617 	ldw	r2,-40(fp)
   2f6f4:	1080020b 	ldhu	r2,8(r2)
   2f6f8:	10bfffcc 	andi	r2,r2,65535
   2f6fc:	1004d23a 	srli	r2,r2,8
   2f700:	1007883a 	mov	r3,r2
   2f704:	e0bff617 	ldw	r2,-40(fp)
   2f708:	1080020b 	ldhu	r2,8(r2)
   2f70c:	10bfffcc 	andi	r2,r2,65535
   2f710:	1004923a 	slli	r2,r2,8
   2f714:	1884b03a 	or	r2,r3,r2
   2f718:	1007883a 	mov	r3,r2
   2f71c:	e0bff817 	ldw	r2,-32(fp)
   2f720:	193fffcc 	andi	r4,r3,65535
   2f724:	21003fcc 	andi	r4,r4,255
   2f728:	11400103 	ldbu	r5,4(r2)
   2f72c:	280a703a 	and	r5,r5,zero
   2f730:	2908b03a 	or	r4,r5,r4
   2f734:	11000105 	stb	r4,4(r2)
   2f738:	18ffffcc 	andi	r3,r3,65535
   2f73c:	1806d23a 	srli	r3,r3,8
   2f740:	18ffffcc 	andi	r3,r3,65535
   2f744:	11000143 	ldbu	r4,5(r2)
   2f748:	2008703a 	and	r4,r4,zero
   2f74c:	20c6b03a 	or	r3,r4,r3
   2f750:	10c00145 	stb	r3,5(r2)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
   2f754:	e0bffa17 	ldw	r2,-24(fp)
   2f758:	10800403 	ldbu	r2,16(r2)
   2f75c:	10803fcc 	andi	r2,r2,255
   2f760:	1080004c 	andi	r2,r2,1
   2f764:	1000371e 	bne	r2,zero,2f844 <udp_sendto_if_chksum+0x36c>
      u16_t udpchksum;
#if LWIP_CHECKSUM_ON_COPY
      if (have_chksum) {
   2f768:	e0bffe03 	ldbu	r2,-8(fp)
   2f76c:	10001926 	beq	r2,zero,2f7d4 <udp_sendto_if_chksum+0x2fc>
        u32_t acc;
        udpchksum = inet_chksum_pseudo_partial(q, src_ip, dst_ip, IP_PROTO_UDP,
          q->tot_len, UDP_HLEN);
   2f770:	e0bff617 	ldw	r2,-40(fp)
   2f774:	1080020b 	ldhu	r2,8(r2)
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
      u16_t udpchksum;
#if LWIP_CHECKSUM_ON_COPY
      if (have_chksum) {
        u32_t acc;
        udpchksum = inet_chksum_pseudo_partial(q, src_ip, dst_ip, IP_PROTO_UDP,
   2f778:	10bfffcc 	andi	r2,r2,65535
   2f77c:	d8800015 	stw	r2,0(sp)
   2f780:	00800204 	movi	r2,8
   2f784:	d8800115 	stw	r2,4(sp)
   2f788:	e13ff617 	ldw	r4,-40(fp)
   2f78c:	e17ff517 	ldw	r5,-44(fp)
   2f790:	e1bffc17 	ldw	r6,-16(fp)
   2f794:	01c00444 	movi	r7,17
   2f798:	003e4a40 	call	3e4a4 <inet_chksum_pseudo_partial>
   2f79c:	e0bff70d 	sth	r2,-36(fp)
          q->tot_len, UDP_HLEN);
        acc = udpchksum + (u16_t)~(chksum);
   2f7a0:	e0fff70b 	ldhu	r3,-36(fp)
   2f7a4:	e0bfff0b 	ldhu	r2,-4(fp)
   2f7a8:	0084303a 	nor	r2,zero,r2
   2f7ac:	10bfffcc 	andi	r2,r2,65535
   2f7b0:	1885883a 	add	r2,r3,r2
   2f7b4:	e0bff915 	stw	r2,-28(fp)
        udpchksum = FOLD_U32T(acc);
   2f7b8:	e0bff917 	ldw	r2,-28(fp)
   2f7bc:	1004d43a 	srli	r2,r2,16
   2f7c0:	1007883a 	mov	r3,r2
   2f7c4:	e0bff917 	ldw	r2,-28(fp)
   2f7c8:	1885883a 	add	r2,r3,r2
   2f7cc:	e0bff70d 	sth	r2,-36(fp)
   2f7d0:	00000a06 	br	2f7fc <udp_sendto_if_chksum+0x324>
      } else
#endif /* LWIP_CHECKSUM_ON_COPY */
      {
        udpchksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
   2f7d4:	e0bff617 	ldw	r2,-40(fp)
   2f7d8:	1080020b 	ldhu	r2,8(r2)
   2f7dc:	10bfffcc 	andi	r2,r2,65535
   2f7e0:	d8800015 	stw	r2,0(sp)
   2f7e4:	e13ff617 	ldw	r4,-40(fp)
   2f7e8:	e17ff517 	ldw	r5,-44(fp)
   2f7ec:	e1bffc17 	ldw	r6,-16(fp)
   2f7f0:	01c00444 	movi	r7,17
   2f7f4:	003e2ac0 	call	3e2ac <inet_chksum_pseudo>
   2f7f8:	e0bff70d 	sth	r2,-36(fp)
      }

      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udpchksum == 0x0000) {
   2f7fc:	e0bff70b 	ldhu	r2,-36(fp)
   2f800:	1000021e 	bne	r2,zero,2f80c <udp_sendto_if_chksum+0x334>
        udpchksum = 0xffff;
   2f804:	00bfffc4 	movi	r2,-1
   2f808:	e0bff70d 	sth	r2,-36(fp)
      }
      udphdr->chksum = udpchksum;
   2f80c:	e0bff817 	ldw	r2,-32(fp)
   2f810:	e0fff70b 	ldhu	r3,-36(fp)
   2f814:	18c03fcc 	andi	r3,r3,255
   2f818:	11000183 	ldbu	r4,6(r2)
   2f81c:	2008703a 	and	r4,r4,zero
   2f820:	20c6b03a 	or	r3,r4,r3
   2f824:	10c00185 	stb	r3,6(r2)
   2f828:	e0fff70b 	ldhu	r3,-36(fp)
   2f82c:	1806d23a 	srli	r3,r3,8
   2f830:	18ffffcc 	andi	r3,r3,65535
   2f834:	110001c3 	ldbu	r4,7(r2)
   2f838:	2008703a 	and	r4,r4,zero
   2f83c:	20c6b03a 	or	r3,r4,r3
   2f840:	10c001c5 	stb	r3,7(r2)
    }
#endif /* CHECKSUM_GEN_UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04"X16_F"\n", udphdr->chksum));
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
    NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
   2f844:	e0bffa17 	ldw	r2,-24(fp)
   2f848:	10c002c4 	addi	r3,r2,11
   2f84c:	e0800217 	ldw	r2,8(fp)
   2f850:	10c01015 	stw	r3,64(r2)
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
   2f854:	e0bffa17 	ldw	r2,-24(fp)
   2f858:	10800283 	ldbu	r2,10(r2)
   2f85c:	10803fcc 	andi	r2,r2,255
   2f860:	e0fffa17 	ldw	r3,-24(fp)
   2f864:	18c00243 	ldbu	r3,9(r3)
   2f868:	18c03fcc 	andi	r3,r3,255
   2f86c:	d8c00015 	stw	r3,0(sp)
   2f870:	00c00444 	movi	r3,17
   2f874:	d8c00115 	stw	r3,4(sp)
   2f878:	e0c00217 	ldw	r3,8(fp)
   2f87c:	d8c00215 	stw	r3,8(sp)
   2f880:	e13ff617 	ldw	r4,-40(fp)
   2f884:	e17ff517 	ldw	r5,-44(fp)
   2f888:	e1bffc17 	ldw	r6,-16(fp)
   2f88c:	100f883a 	mov	r7,r2
   2f890:	001f3080 	call	1f308 <ip_output_if>
   2f894:	e0bff785 	stb	r2,-34(fp)
    NETIF_SET_HWADDRHINT(netif, NULL);
   2f898:	e0800217 	ldw	r2,8(fp)
   2f89c:	10001015 	stw	zero,64(r2)
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
   2f8a0:	e0fff617 	ldw	r3,-40(fp)
   2f8a4:	e0bffb17 	ldw	r2,-20(fp)
   2f8a8:	18800326 	beq	r3,r2,2f8b8 <udp_sendto_if_chksum+0x3e0>
    /* free the header pbuf */
    pbuf_free(q);
   2f8ac:	e13ff617 	ldw	r4,-40(fp)
   2f8b0:	00237600 	call	23760 <pbuf_free>
    q = NULL;
   2f8b4:	e03ff615 	stw	zero,-40(fp)
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
   2f8b8:	008001f4 	movhi	r2,7
   2f8bc:	10ac6e04 	addi	r2,r2,-20040
   2f8c0:	10803c17 	ldw	r2,240(r2)
   2f8c4:	10c00044 	addi	r3,r2,1
   2f8c8:	008001f4 	movhi	r2,7
   2f8cc:	10ac6e04 	addi	r2,r2,-20040
   2f8d0:	10c03c15 	stw	r3,240(r2)
  return err;
   2f8d4:	e0bff783 	ldbu	r2,-34(fp)
}
   2f8d8:	e037883a 	mov	sp,fp
   2f8dc:	dfc00117 	ldw	ra,4(sp)
   2f8e0:	df000017 	ldw	fp,0(sp)
   2f8e4:	dec00204 	addi	sp,sp,8
   2f8e8:	f800283a 	ret

0002f8ec <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
   2f8ec:	defff904 	addi	sp,sp,-28
   2f8f0:	dfc00615 	stw	ra,24(sp)
   2f8f4:	df000515 	stw	fp,20(sp)
   2f8f8:	df000504 	addi	fp,sp,20
   2f8fc:	e13ffd15 	stw	r4,-12(fp)
   2f900:	e17ffe15 	stw	r5,-8(fp)
   2f904:	3005883a 	mov	r2,r6
   2f908:	e0bfff0d 	sth	r2,-4(fp)

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
   2f90c:	e03ffc05 	stb	zero,-16(fp)
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
   2f910:	d0a94617 	ldw	r2,-23272(gp)
   2f914:	e0bffb15 	stw	r2,-20(fp)
   2f918:	00002906 	br	2f9c0 <udp_bind+0xd4>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
   2f91c:	e0fffd17 	ldw	r3,-12(fp)
   2f920:	e0bffb17 	ldw	r2,-20(fp)
   2f924:	1880031e 	bne	r3,r2,2f934 <udp_bind+0x48>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
      /* pcb already in list, just rebind */
      rebind = 1;
   2f928:	00800044 	movi	r2,1
   2f92c:	e0bffc05 	stb	r2,-16(fp)
   2f930:	00002006 	br	2f9b4 <udp_bind+0xc8>

    /* By default, we don't allow to bind to a port that any other udp
       PCB is alread bound to, unless *all* PCBs with that port have tha
       REUSEADDR flag set. */
#if SO_REUSE
    else if (!ip_get_option(pcb, SOF_REUSEADDR) &&
   2f934:	e0bffd17 	ldw	r2,-12(fp)
   2f938:	10800203 	ldbu	r2,8(r2)
   2f93c:	10803fcc 	andi	r2,r2,255
   2f940:	1080010c 	andi	r2,r2,4
   2f944:	10001b1e 	bne	r2,zero,2f9b4 <udp_bind+0xc8>
             !ip_get_option(ipcb, SOF_REUSEADDR)) {
   2f948:	e0bffb17 	ldw	r2,-20(fp)
   2f94c:	10800203 	ldbu	r2,8(r2)
   2f950:	10803fcc 	andi	r2,r2,255
   2f954:	1080010c 	andi	r2,r2,4

    /* By default, we don't allow to bind to a port that any other udp
       PCB is alread bound to, unless *all* PCBs with that port have tha
       REUSEADDR flag set. */
#if SO_REUSE
    else if (!ip_get_option(pcb, SOF_REUSEADDR) &&
   2f958:	1000161e 	bne	r2,zero,2f9b4 <udp_bind+0xc8>
             !ip_get_option(ipcb, SOF_REUSEADDR)) {
#else /* SO_REUSE */
    /* port matches that of PCB in list and REUSEADDR not set -> reject */
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
   2f95c:	e0bffb17 	ldw	r2,-20(fp)
   2f960:	1080048b 	ldhu	r2,18(r2)
   2f964:	10ffffcc 	andi	r3,r2,65535
   2f968:	e0bfff0b 	ldhu	r2,-4(fp)
   2f96c:	1880111e 	bne	r3,r2,2f9b4 <udp_bind+0xc8>
          /* IP address matches, or one is IP_ADDR_ANY? */
          (ip_addr_isany(&(ipcb->local_ip)) ||
   2f970:	e0bffb17 	ldw	r2,-20(fp)
             !ip_get_option(ipcb, SOF_REUSEADDR)) {
#else /* SO_REUSE */
    /* port matches that of PCB in list and REUSEADDR not set -> reject */
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
   2f974:	10000d26 	beq	r2,zero,2f9ac <udp_bind+0xc0>
          /* IP address matches, or one is IP_ADDR_ANY? */
          (ip_addr_isany(&(ipcb->local_ip)) ||
   2f978:	e0bffb17 	ldw	r2,-20(fp)
   2f97c:	10800017 	ldw	r2,0(r2)
   2f980:	10000a26 	beq	r2,zero,2f9ac <udp_bind+0xc0>
   2f984:	e0bffe17 	ldw	r2,-8(fp)
   2f988:	10000826 	beq	r2,zero,2f9ac <udp_bind+0xc0>
           ip_addr_isany(ipaddr) ||
   2f98c:	e0bffe17 	ldw	r2,-8(fp)
   2f990:	10800017 	ldw	r2,0(r2)
   2f994:	10000526 	beq	r2,zero,2f9ac <udp_bind+0xc0>
           ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
   2f998:	e0bffb17 	ldw	r2,-20(fp)
   2f99c:	10c00017 	ldw	r3,0(r2)
   2f9a0:	e0bffe17 	ldw	r2,-8(fp)
   2f9a4:	10800017 	ldw	r2,0(r2)
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
          /* IP address matches, or one is IP_ADDR_ANY? */
          (ip_addr_isany(&(ipcb->local_ip)) ||
           ip_addr_isany(ipaddr) ||
   2f9a8:	1880021e 	bne	r3,r2,2f9b4 <udp_bind+0xc8>
           ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
        /* other PCB already binds to this local IP and port */
        LWIP_DEBUGF(UDP_DEBUG,
                    ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
        return ERR_USE;
   2f9ac:	00bffe04 	movi	r2,-8
   2f9b0:	00002006 	br	2fa34 <udp_bind+0x148>
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
   2f9b4:	e0bffb17 	ldw	r2,-20(fp)
   2f9b8:	10800317 	ldw	r2,12(r2)
   2f9bc:	e0bffb15 	stw	r2,-20(fp)
   2f9c0:	e0bffb17 	ldw	r2,-20(fp)
   2f9c4:	103fd51e 	bne	r2,zero,2f91c <udp_bind+0x30>
        return ERR_USE;
      }
    }
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
   2f9c8:	e0bffe17 	ldw	r2,-8(fp)
   2f9cc:	10000326 	beq	r2,zero,2f9dc <udp_bind+0xf0>
   2f9d0:	e0bffe17 	ldw	r2,-8(fp)
   2f9d4:	10800017 	ldw	r2,0(r2)
   2f9d8:	00000106 	br	2f9e0 <udp_bind+0xf4>
   2f9dc:	0005883a 	mov	r2,zero
   2f9e0:	e0fffd17 	ldw	r3,-12(fp)
   2f9e4:	18800015 	stw	r2,0(r3)

  /* no port specified? */
  if (port == 0) {
   2f9e8:	e0bfff0b 	ldhu	r2,-4(fp)
   2f9ec:	1000061e 	bne	r2,zero,2fa08 <udp_bind+0x11c>
    port = udp_new_port();
   2f9f0:	002ec380 	call	2ec38 <udp_new_port>
   2f9f4:	e0bfff0d 	sth	r2,-4(fp)
    if (port == 0) {
   2f9f8:	e0bfff0b 	ldhu	r2,-4(fp)
   2f9fc:	1000021e 	bne	r2,zero,2fa08 <udp_bind+0x11c>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
   2fa00:	00bffe04 	movi	r2,-8
   2fa04:	00000b06 	br	2fa34 <udp_bind+0x148>
    }
  }
  pcb->local_port = port;
   2fa08:	e0bffd17 	ldw	r2,-12(fp)
   2fa0c:	e0ffff0b 	ldhu	r3,-4(fp)
   2fa10:	10c0048d 	sth	r3,18(r2)
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
   2fa14:	e0bffc03 	ldbu	r2,-16(fp)
   2fa18:	1000051e 	bne	r2,zero,2fa30 <udp_bind+0x144>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
   2fa1c:	d0e94617 	ldw	r3,-23272(gp)
   2fa20:	e0bffd17 	ldw	r2,-12(fp)
   2fa24:	10c00315 	stw	r3,12(r2)
    udp_pcbs = pcb;
   2fa28:	e0bffd17 	ldw	r2,-12(fp)
   2fa2c:	d0a94615 	stw	r2,-23272(gp)
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));
  return ERR_OK;
   2fa30:	0005883a 	mov	r2,zero
}
   2fa34:	e037883a 	mov	sp,fp
   2fa38:	dfc00117 	ldw	ra,4(sp)
   2fa3c:	df000017 	ldw	fp,0(sp)
   2fa40:	dec00204 	addi	sp,sp,8
   2fa44:	f800283a 	ret

0002fa48 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
   2fa48:	defff904 	addi	sp,sp,-28
   2fa4c:	dfc00615 	stw	ra,24(sp)
   2fa50:	df000515 	stw	fp,20(sp)
   2fa54:	df000504 	addi	fp,sp,20
   2fa58:	e13ffd15 	stw	r4,-12(fp)
   2fa5c:	e17ffe15 	stw	r5,-8(fp)
   2fa60:	3005883a 	mov	r2,r6
   2fa64:	e0bfff0d 	sth	r2,-4(fp)
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
   2fa68:	e0bffd17 	ldw	r2,-12(fp)
   2fa6c:	1080048b 	ldhu	r2,18(r2)
   2fa70:	10bfffcc 	andi	r2,r2,65535
   2fa74:	10000d1e 	bne	r2,zero,2faac <udp_connect+0x64>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
   2fa78:	e0fffd17 	ldw	r3,-12(fp)
   2fa7c:	e0bffd17 	ldw	r2,-12(fp)
   2fa80:	1080048b 	ldhu	r2,18(r2)
   2fa84:	10bfffcc 	andi	r2,r2,65535
   2fa88:	e13ffd17 	ldw	r4,-12(fp)
   2fa8c:	180b883a 	mov	r5,r3
   2fa90:	100d883a 	mov	r6,r2
   2fa94:	002f8ec0 	call	2f8ec <udp_bind>
   2fa98:	e0bffc05 	stb	r2,-16(fp)
    if (err != ERR_OK) {
   2fa9c:	e0bffc07 	ldb	r2,-16(fp)
   2faa0:	10000226 	beq	r2,zero,2faac <udp_connect+0x64>
      return err;
   2faa4:	e0bffc03 	ldbu	r2,-16(fp)
   2faa8:	00002406 	br	2fb3c <udp_connect+0xf4>
    }
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
   2faac:	e0bffe17 	ldw	r2,-8(fp)
   2fab0:	10000326 	beq	r2,zero,2fac0 <udp_connect+0x78>
   2fab4:	e0bffe17 	ldw	r2,-8(fp)
   2fab8:	10800017 	ldw	r2,0(r2)
   2fabc:	00000106 	br	2fac4 <udp_connect+0x7c>
   2fac0:	0005883a 	mov	r2,zero
   2fac4:	e0fffd17 	ldw	r3,-12(fp)
   2fac8:	18800115 	stw	r2,4(r3)
  pcb->remote_port = port;
   2facc:	e0bffd17 	ldw	r2,-12(fp)
   2fad0:	e0ffff0b 	ldhu	r3,-4(fp)
   2fad4:	10c0050d 	sth	r3,20(r2)
  pcb->flags |= UDP_FLAGS_CONNECTED;
   2fad8:	e0bffd17 	ldw	r2,-12(fp)
   2fadc:	10800403 	ldbu	r2,16(r2)
   2fae0:	10800114 	ori	r2,r2,4
   2fae4:	1007883a 	mov	r3,r2
   2fae8:	e0bffd17 	ldw	r2,-12(fp)
   2faec:	10c00405 	stb	r3,16(r2)
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
   2faf0:	d0a94617 	ldw	r2,-23272(gp)
   2faf4:	e0bffb15 	stw	r2,-20(fp)
   2faf8:	00000806 	br	2fb1c <udp_connect+0xd4>
    if (pcb == ipcb) {
   2fafc:	e0fffd17 	ldw	r3,-12(fp)
   2fb00:	e0bffb17 	ldw	r2,-20(fp)
   2fb04:	1880021e 	bne	r3,r2,2fb10 <udp_connect+0xc8>
      /* already on the list, just return */
      return ERR_OK;
   2fb08:	0005883a 	mov	r2,zero
   2fb0c:	00000b06 	br	2fb3c <udp_connect+0xf4>
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
   2fb10:	e0bffb17 	ldw	r2,-20(fp)
   2fb14:	10800317 	ldw	r2,12(r2)
   2fb18:	e0bffb15 	stw	r2,-20(fp)
   2fb1c:	e0bffb17 	ldw	r2,-20(fp)
   2fb20:	103ff61e 	bne	r2,zero,2fafc <udp_connect+0xb4>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
   2fb24:	d0e94617 	ldw	r3,-23272(gp)
   2fb28:	e0bffd17 	ldw	r2,-12(fp)
   2fb2c:	10c00315 	stw	r3,12(r2)
  udp_pcbs = pcb;
   2fb30:	e0bffd17 	ldw	r2,-12(fp)
   2fb34:	d0a94615 	stw	r2,-23272(gp)
  return ERR_OK;
   2fb38:	0005883a 	mov	r2,zero
}
   2fb3c:	e037883a 	mov	sp,fp
   2fb40:	dfc00117 	ldw	ra,4(sp)
   2fb44:	df000017 	ldw	fp,0(sp)
   2fb48:	dec00204 	addi	sp,sp,8
   2fb4c:	f800283a 	ret

0002fb50 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
   2fb50:	defffe04 	addi	sp,sp,-8
   2fb54:	df000115 	stw	fp,4(sp)
   2fb58:	df000104 	addi	fp,sp,4
   2fb5c:	e13fff15 	stw	r4,-4(fp)
  /* reset remote address association */
  ip_addr_set_any(&pcb->remote_ip);
   2fb60:	e0bfff17 	ldw	r2,-4(fp)
   2fb64:	10000115 	stw	zero,4(r2)
  pcb->remote_port = 0;
   2fb68:	e0bfff17 	ldw	r2,-4(fp)
   2fb6c:	1000050d 	sth	zero,20(r2)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
   2fb70:	e0bfff17 	ldw	r2,-4(fp)
   2fb74:	10c00403 	ldbu	r3,16(r2)
   2fb78:	00bffec4 	movi	r2,-5
   2fb7c:	1884703a 	and	r2,r3,r2
   2fb80:	1007883a 	mov	r3,r2
   2fb84:	e0bfff17 	ldw	r2,-4(fp)
   2fb88:	10c00405 	stb	r3,16(r2)
}
   2fb8c:	e037883a 	mov	sp,fp
   2fb90:	df000017 	ldw	fp,0(sp)
   2fb94:	dec00104 	addi	sp,sp,4
   2fb98:	f800283a 	ret

0002fb9c <udp_recv>:
 * @param recv function pointer of the callback function
 * @param recv_arg additional argument to pass to the callback function
 */
void
udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
   2fb9c:	defffc04 	addi	sp,sp,-16
   2fba0:	df000315 	stw	fp,12(sp)
   2fba4:	df000304 	addi	fp,sp,12
   2fba8:	e13ffd15 	stw	r4,-12(fp)
   2fbac:	e17ffe15 	stw	r5,-8(fp)
   2fbb0:	e1bfff15 	stw	r6,-4(fp)
  /* remember recv() callback and user data */
  pcb->recv = recv;
   2fbb4:	e0bffd17 	ldw	r2,-12(fp)
   2fbb8:	e0fffe17 	ldw	r3,-8(fp)
   2fbbc:	10c00615 	stw	r3,24(r2)
  pcb->recv_arg = recv_arg;
   2fbc0:	e0bffd17 	ldw	r2,-12(fp)
   2fbc4:	e0ffff17 	ldw	r3,-4(fp)
   2fbc8:	10c00715 	stw	r3,28(r2)
}
   2fbcc:	e037883a 	mov	sp,fp
   2fbd0:	df000017 	ldw	fp,0(sp)
   2fbd4:	dec00104 	addi	sp,sp,4
   2fbd8:	f800283a 	ret

0002fbdc <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
   2fbdc:	defffc04 	addi	sp,sp,-16
   2fbe0:	dfc00315 	stw	ra,12(sp)
   2fbe4:	df000215 	stw	fp,8(sp)
   2fbe8:	df000204 	addi	fp,sp,8
   2fbec:	e13fff15 	stw	r4,-4(fp)
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
   2fbf0:	d0e94617 	ldw	r3,-23272(gp)
   2fbf4:	e0bfff17 	ldw	r2,-4(fp)
   2fbf8:	1880041e 	bne	r3,r2,2fc0c <udp_remove+0x30>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
   2fbfc:	d0a94617 	ldw	r2,-23272(gp)
   2fc00:	10800317 	ldw	r2,12(r2)
   2fc04:	d0a94615 	stw	r2,-23272(gp)
   2fc08:	00001306 	br	2fc58 <udp_remove+0x7c>
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
   2fc0c:	d0a94617 	ldw	r2,-23272(gp)
   2fc10:	e0bffe15 	stw	r2,-8(fp)
   2fc14:	00000e06 	br	2fc50 <udp_remove+0x74>
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
   2fc18:	e0bffe17 	ldw	r2,-8(fp)
   2fc1c:	10800317 	ldw	r2,12(r2)
   2fc20:	10000826 	beq	r2,zero,2fc44 <udp_remove+0x68>
   2fc24:	e0bffe17 	ldw	r2,-8(fp)
   2fc28:	10c00317 	ldw	r3,12(r2)
   2fc2c:	e0bfff17 	ldw	r2,-4(fp)
   2fc30:	1880041e 	bne	r3,r2,2fc44 <udp_remove+0x68>
        /* remove pcb from list */
        pcb2->next = pcb->next;
   2fc34:	e0bfff17 	ldw	r2,-4(fp)
   2fc38:	10c00317 	ldw	r3,12(r2)
   2fc3c:	e0bffe17 	ldw	r2,-8(fp)
   2fc40:	10c00315 	stw	r3,12(r2)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
   2fc44:	e0bffe17 	ldw	r2,-8(fp)
   2fc48:	10800317 	ldw	r2,12(r2)
   2fc4c:	e0bffe15 	stw	r2,-8(fp)
   2fc50:	e0bffe17 	ldw	r2,-8(fp)
   2fc54:	103ff01e 	bne	r2,zero,2fc18 <udp_remove+0x3c>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
   2fc58:	01000044 	movi	r4,1
   2fc5c:	e17fff17 	ldw	r5,-4(fp)
   2fc60:	00225900 	call	22590 <memp_free>
}
   2fc64:	e037883a 	mov	sp,fp
   2fc68:	dfc00117 	ldw	ra,4(sp)
   2fc6c:	df000017 	ldw	fp,0(sp)
   2fc70:	dec00204 	addi	sp,sp,8
   2fc74:	f800283a 	ret

0002fc78 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
   2fc78:	defffd04 	addi	sp,sp,-12
   2fc7c:	dfc00215 	stw	ra,8(sp)
   2fc80:	df000115 	stw	fp,4(sp)
   2fc84:	df000104 	addi	fp,sp,4
  struct udp_pcb *pcb;
  pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
   2fc88:	01000044 	movi	r4,1
   2fc8c:	00223cc0 	call	223cc <memp_malloc>
   2fc90:	e0bfff15 	stw	r2,-4(fp)
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
   2fc94:	e0bfff17 	ldw	r2,-4(fp)
   2fc98:	10000726 	beq	r2,zero,2fcb8 <udp_new+0x40>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
   2fc9c:	e13fff17 	ldw	r4,-4(fp)
   2fca0:	000b883a 	mov	r5,zero
   2fca4:	01800804 	movi	r6,32
   2fca8:	00042e80 	call	42e8 <memset>
    pcb->ttl = UDP_TTL;
   2fcac:	e0bfff17 	ldw	r2,-4(fp)
   2fcb0:	00c01004 	movi	r3,64
   2fcb4:	10c00285 	stb	r3,10(r2)
  }
  return pcb;
   2fcb8:	e0bfff17 	ldw	r2,-4(fp)
}
   2fcbc:	e037883a 	mov	sp,fp
   2fcc0:	dfc00117 	ldw	ra,4(sp)
   2fcc4:	df000017 	ldw	fp,0(sp)
   2fcc8:	dec00204 	addi	sp,sp,8
   2fccc:	f800283a 	ret

0002fcd0 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
   2fcd0:	defffc04 	addi	sp,sp,-16
   2fcd4:	dfc00315 	stw	ra,12(sp)
   2fcd8:	df000215 	stw	fp,8(sp)
   2fcdc:	df000204 	addi	fp,sp,8
   2fce0:	e13fff15 	stw	r4,-4(fp)
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
   2fce4:	00000c06 	br	2fd18 <free_etharp_q+0x48>
    r = q;
   2fce8:	e0bfff17 	ldw	r2,-4(fp)
   2fcec:	e0bffe15 	stw	r2,-8(fp)
    q = q->next;
   2fcf0:	e0bfff17 	ldw	r2,-4(fp)
   2fcf4:	10800017 	ldw	r2,0(r2)
   2fcf8:	e0bfff15 	stw	r2,-4(fp)
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
   2fcfc:	e0bffe17 	ldw	r2,-8(fp)
   2fd00:	10800117 	ldw	r2,4(r2)
   2fd04:	1009883a 	mov	r4,r2
   2fd08:	00237600 	call	23760 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
   2fd0c:	010002c4 	movi	r4,11
   2fd10:	e17ffe17 	ldw	r5,-8(fp)
   2fd14:	00225900 	call	22590 <memp_free>
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
   2fd18:	e0bfff17 	ldw	r2,-4(fp)
   2fd1c:	103ff21e 	bne	r2,zero,2fce8 <free_etharp_q+0x18>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
   2fd20:	e037883a 	mov	sp,fp
   2fd24:	dfc00117 	ldw	ra,4(sp)
   2fd28:	df000017 	ldw	fp,0(sp)
   2fd2c:	dec00204 	addi	sp,sp,8
   2fd30:	f800283a 	ret

0002fd34 <etharp_free_entry>:
#endif /* ARP_QUEUEING */

/** Clean up ARP table entries */
static void
etharp_free_entry(int i)
{
   2fd34:	defffd04 	addi	sp,sp,-12
   2fd38:	dfc00215 	stw	ra,8(sp)
   2fd3c:	df000115 	stw	fp,4(sp)
   2fd40:	df000104 	addi	fp,sp,4
   2fd44:	e13fff15 	stw	r4,-4(fp)
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
   2fd48:	00c001b4 	movhi	r3,6
   2fd4c:	18c8dc04 	addi	r3,r3,9072
   2fd50:	e0bfff17 	ldw	r2,-4(fp)
   2fd54:	10800524 	muli	r2,r2,20
   2fd58:	1885883a 	add	r2,r3,r2
   2fd5c:	10800017 	ldw	r2,0(r2)
   2fd60:	10000e26 	beq	r2,zero,2fd9c <etharp_free_entry+0x68>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
   2fd64:	00c001b4 	movhi	r3,6
   2fd68:	18c8dc04 	addi	r3,r3,9072
   2fd6c:	e0bfff17 	ldw	r2,-4(fp)
   2fd70:	10800524 	muli	r2,r2,20
   2fd74:	1885883a 	add	r2,r3,r2
   2fd78:	10800017 	ldw	r2,0(r2)
   2fd7c:	1009883a 	mov	r4,r2
   2fd80:	002fcd00 	call	2fcd0 <free_etharp_q>
    arp_table[i].q = NULL;
   2fd84:	00c001b4 	movhi	r3,6
   2fd88:	18c8dc04 	addi	r3,r3,9072
   2fd8c:	e0bfff17 	ldw	r2,-4(fp)
   2fd90:	10800524 	muli	r2,r2,20
   2fd94:	1885883a 	add	r2,r3,r2
   2fd98:	10000015 	stw	zero,0(r2)
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
   2fd9c:	00c001b4 	movhi	r3,6
   2fda0:	18c8dc04 	addi	r3,r3,9072
   2fda4:	e0bfff17 	ldw	r2,-4(fp)
   2fda8:	10800524 	muli	r2,r2,20
   2fdac:	1885883a 	add	r2,r3,r2
   2fdb0:	10800404 	addi	r2,r2,16
   2fdb4:	10000085 	stb	zero,2(r2)
  arp_table[i].ctime = 0;
  arp_table[i].netif = NULL;
  ip_addr_set_zero(&arp_table[i].ipaddr);
  arp_table[i].ethaddr = ethzero;
#endif /* LWIP_DEBUG */
}
   2fdb8:	e037883a 	mov	sp,fp
   2fdbc:	dfc00117 	ldw	ra,4(sp)
   2fdc0:	df000017 	ldw	fp,0(sp)
   2fdc4:	dec00204 	addi	sp,sp,8
   2fdc8:	f800283a 	ret

0002fdcc <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL milliseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
   2fdcc:	defffd04 	addi	sp,sp,-12
   2fdd0:	dfc00215 	stw	ra,8(sp)
   2fdd4:	df000115 	stw	fp,4(sp)
   2fdd8:	df000104 	addi	fp,sp,4
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
   2fddc:	e03fff05 	stb	zero,-4(fp)
   2fde0:	00004f06 	br	2ff20 <etharp_tmr+0x154>
    u8_t state = arp_table[i].state;
   2fde4:	e0bfff03 	ldbu	r2,-4(fp)
   2fde8:	00c001b4 	movhi	r3,6
   2fdec:	18c8dc04 	addi	r3,r3,9072
   2fdf0:	10800524 	muli	r2,r2,20
   2fdf4:	1885883a 	add	r2,r3,r2
   2fdf8:	10800404 	addi	r2,r2,16
   2fdfc:	10800083 	ldbu	r2,2(r2)
   2fe00:	e0bfff45 	stb	r2,-3(fp)
    if (state != ETHARP_STATE_EMPTY
   2fe04:	e0bfff43 	ldbu	r2,-3(fp)
   2fe08:	10004226 	beq	r2,zero,2ff14 <etharp_tmr+0x148>
#if ETHARP_SUPPORT_STATIC_ENTRIES
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
   2fe0c:	e0bfff03 	ldbu	r2,-4(fp)
   2fe10:	010001b4 	movhi	r4,6
   2fe14:	2108dc04 	addi	r4,r4,9072
   2fe18:	10c00524 	muli	r3,r2,20
   2fe1c:	20c7883a 	add	r3,r4,r3
   2fe20:	18c00404 	addi	r3,r3,16
   2fe24:	18c000c3 	ldbu	r3,3(r3)
   2fe28:	18c00044 	addi	r3,r3,1
   2fe2c:	010001b4 	movhi	r4,6
   2fe30:	2108dc04 	addi	r4,r4,9072
   2fe34:	10800524 	muli	r2,r2,20
   2fe38:	2085883a 	add	r2,r4,r2
   2fe3c:	10800404 	addi	r2,r2,16
   2fe40:	10c000c5 	stb	r3,3(r2)
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
   2fe44:	e0bfff03 	ldbu	r2,-4(fp)
   2fe48:	00c001b4 	movhi	r3,6
   2fe4c:	18c8dc04 	addi	r3,r3,9072
   2fe50:	10800524 	muli	r2,r2,20
   2fe54:	1885883a 	add	r2,r3,r2
   2fe58:	10800404 	addi	r2,r2,16
   2fe5c:	108000c3 	ldbu	r2,3(r2)
   2fe60:	10803fcc 	andi	r2,r2,255
   2fe64:	10803c28 	cmpgeui	r2,r2,240
   2fe68:	1000141e 	bne	r2,zero,2febc <etharp_tmr+0xf0>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
   2fe6c:	e0bfff03 	ldbu	r2,-4(fp)
   2fe70:	00c001b4 	movhi	r3,6
   2fe74:	18c8dc04 	addi	r3,r3,9072
   2fe78:	10800524 	muli	r2,r2,20
   2fe7c:	1885883a 	add	r2,r3,r2
   2fe80:	10800404 	addi	r2,r2,16
   2fe84:	10800083 	ldbu	r2,2(r2)
#if ETHARP_SUPPORT_STATIC_ENTRIES
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
   2fe88:	10803fcc 	andi	r2,r2,255
   2fe8c:	10800058 	cmpnei	r2,r2,1
   2fe90:	10000e1e 	bne	r2,zero,2fecc <etharp_tmr+0x100>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
           (arp_table[i].ctime >= ARP_MAXPENDING))) {
   2fe94:	e0bfff03 	ldbu	r2,-4(fp)
   2fe98:	00c001b4 	movhi	r3,6
   2fe9c:	18c8dc04 	addi	r3,r3,9072
   2fea0:	10800524 	muli	r2,r2,20
   2fea4:	1885883a 	add	r2,r3,r2
   2fea8:	10800404 	addi	r2,r2,16
   2feac:	108000c3 	ldbu	r2,3(r2)
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
   2feb0:	10803fcc 	andi	r2,r2,255
   2feb4:	108000b0 	cmpltui	r2,r2,2
   2feb8:	1000041e 	bne	r2,zero,2fecc <etharp_tmr+0x100>
           (arp_table[i].ctime >= ARP_MAXPENDING))) {
        /* pending or stable entry has become old! */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %"U16_F".\n",
             arp_table[i].state >= ETHARP_STATE_STABLE ? "stable" : "pending", (u16_t)i));
        /* clean up entries that have just been expired */
        etharp_free_entry(i);
   2febc:	e0bfff03 	ldbu	r2,-4(fp)
   2fec0:	1009883a 	mov	r4,r2
   2fec4:	002fd340 	call	2fd34 <etharp_free_entry>
   2fec8:	00001206 	br	2ff14 <etharp_tmr+0x148>
      }
      else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
   2fecc:	e0bfff03 	ldbu	r2,-4(fp)
   2fed0:	00c001b4 	movhi	r3,6
   2fed4:	18c8dc04 	addi	r3,r3,9072
   2fed8:	10800524 	muli	r2,r2,20
   2fedc:	1885883a 	add	r2,r3,r2
   2fee0:	10800404 	addi	r2,r2,16
   2fee4:	10800083 	ldbu	r2,2(r2)
   2fee8:	10803fcc 	andi	r2,r2,255
   2feec:	108000d8 	cmpnei	r2,r2,3
   2fef0:	1000081e 	bne	r2,zero,2ff14 <etharp_tmr+0x148>
        /* Reset state to stable, so that the next transmitted packet will
           re-send an ARP request. */
        arp_table[i].state = ETHARP_STATE_STABLE;
   2fef4:	e0bfff03 	ldbu	r2,-4(fp)
   2fef8:	00c001b4 	movhi	r3,6
   2fefc:	18c8dc04 	addi	r3,r3,9072
   2ff00:	10800524 	muli	r2,r2,20
   2ff04:	1885883a 	add	r2,r3,r2
   2ff08:	10800404 	addi	r2,r2,16
   2ff0c:	00c00084 	movi	r3,2
   2ff10:	10c00085 	stb	r3,2(r2)
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
   2ff14:	e0bfff03 	ldbu	r2,-4(fp)
   2ff18:	10800044 	addi	r2,r2,1
   2ff1c:	e0bfff05 	stb	r2,-4(fp)
   2ff20:	e0bfff03 	ldbu	r2,-4(fp)
   2ff24:	10800670 	cmpltui	r2,r2,25
   2ff28:	103fae1e 	bne	r2,zero,2fde4 <etharp_tmr+0x18>
        /* resend an ARP query here? */
      }
#endif /* ARP_QUEUEING */
    }
  }
}
   2ff2c:	e037883a 	mov	sp,fp
   2ff30:	dfc00117 	ldw	ra,4(sp)
   2ff34:	df000017 	ldw	fp,0(sp)
   2ff38:	dec00204 	addi	sp,sp,8
   2ff3c:	f800283a 	ret

0002ff40 <etharp_find_entry>:
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
   2ff40:	defff904 	addi	sp,sp,-28
   2ff44:	dfc00615 	stw	ra,24(sp)
   2ff48:	df000515 	stw	fp,20(sp)
   2ff4c:	df000504 	addi	fp,sp,20
   2ff50:	e13ffe15 	stw	r4,-8(fp)
   2ff54:	2805883a 	mov	r2,r5
   2ff58:	e0bfff05 	stb	r2,-4(fp)
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
   2ff5c:	00800644 	movi	r2,25
   2ff60:	e0bffb05 	stb	r2,-20(fp)
   2ff64:	00800644 	movi	r2,25
   2ff68:	e0bffb45 	stb	r2,-19(fp)
  s8_t empty = ARP_TABLE_SIZE;
   2ff6c:	00800644 	movi	r2,25
   2ff70:	e0bffb85 	stb	r2,-18(fp)
  u8_t i = 0, age_pending = 0, age_stable = 0;
   2ff74:	e03ffbc5 	stb	zero,-17(fp)
   2ff78:	e03ffc05 	stb	zero,-16(fp)
   2ff7c:	e03ffc45 	stb	zero,-15(fp)
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
   2ff80:	00800644 	movi	r2,25
   2ff84:	e0bffc85 	stb	r2,-14(fp)
  /* its age */
  u8_t age_queue = 0;
   2ff88:	e03ffcc5 	stb	zero,-13(fp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
   2ff8c:	e03ffbc5 	stb	zero,-17(fp)
   2ff90:	00006e06 	br	3014c <etharp_find_entry+0x20c>
    u8_t state = arp_table[i].state;
   2ff94:	e0bffbc3 	ldbu	r2,-17(fp)
   2ff98:	00c001b4 	movhi	r3,6
   2ff9c:	18c8dc04 	addi	r3,r3,9072
   2ffa0:	10800524 	muli	r2,r2,20
   2ffa4:	1885883a 	add	r2,r3,r2
   2ffa8:	10800404 	addi	r2,r2,16
   2ffac:	10800083 	ldbu	r2,2(r2)
   2ffb0:	e0bffd05 	stb	r2,-12(fp)
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
   2ffb4:	e0bffb87 	ldb	r2,-18(fp)
   2ffb8:	10800658 	cmpnei	r2,r2,25
   2ffbc:	1000051e 	bne	r2,zero,2ffd4 <etharp_find_entry+0x94>
   2ffc0:	e0bffd03 	ldbu	r2,-12(fp)
   2ffc4:	1000031e 	bne	r2,zero,2ffd4 <etharp_find_entry+0x94>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
   2ffc8:	e0bffbc3 	ldbu	r2,-17(fp)
   2ffcc:	e0bffb85 	stb	r2,-18(fp)
   2ffd0:	00005b06 	br	30140 <etharp_find_entry+0x200>
    } else if (state != ETHARP_STATE_EMPTY) {
   2ffd4:	e0bffd03 	ldbu	r2,-12(fp)
   2ffd8:	10005926 	beq	r2,zero,30140 <etharp_find_entry+0x200>
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
        state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
   2ffdc:	e0bffe17 	ldw	r2,-8(fp)
   2ffe0:	10000c26 	beq	r2,zero,30014 <etharp_find_entry+0xd4>
   2ffe4:	e0bffe17 	ldw	r2,-8(fp)
   2ffe8:	10c00017 	ldw	r3,0(r2)
   2ffec:	e0bffbc3 	ldbu	r2,-17(fp)
   2fff0:	010001b4 	movhi	r4,6
   2fff4:	2108dc04 	addi	r4,r4,9072
   2fff8:	10800524 	muli	r2,r2,20
   2fffc:	2085883a 	add	r2,r4,r2
   30000:	10800104 	addi	r2,r2,4
   30004:	10800017 	ldw	r2,0(r2)
   30008:	1880021e 	bne	r3,r2,30014 <etharp_find_entry+0xd4>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
   3000c:	e0bffbc3 	ldbu	r2,-17(fp)
   30010:	00008c06 	br	30244 <etharp_find_entry+0x304>
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
   30014:	e0bffd03 	ldbu	r2,-12(fp)
   30018:	10800058 	cmpnei	r2,r2,1
   3001c:	1000311e 	bne	r2,zero,300e4 <etharp_find_entry+0x1a4>
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
   30020:	e0bffbc3 	ldbu	r2,-17(fp)
   30024:	00c001b4 	movhi	r3,6
   30028:	18c8dc04 	addi	r3,r3,9072
   3002c:	10800524 	muli	r2,r2,20
   30030:	1885883a 	add	r2,r3,r2
   30034:	10800017 	ldw	r2,0(r2)
   30038:	10001526 	beq	r2,zero,30090 <etharp_find_entry+0x150>
          if (arp_table[i].ctime >= age_queue) {
   3003c:	e0bffbc3 	ldbu	r2,-17(fp)
   30040:	00c001b4 	movhi	r3,6
   30044:	18c8dc04 	addi	r3,r3,9072
   30048:	10800524 	muli	r2,r2,20
   3004c:	1885883a 	add	r2,r3,r2
   30050:	10800404 	addi	r2,r2,16
   30054:	108000c3 	ldbu	r2,3(r2)
   30058:	10c03fcc 	andi	r3,r2,255
   3005c:	e0bffcc3 	ldbu	r2,-13(fp)
   30060:	18803736 	bltu	r3,r2,30140 <etharp_find_entry+0x200>
            old_queue = i;
   30064:	e0bffbc3 	ldbu	r2,-17(fp)
   30068:	e0bffc85 	stb	r2,-14(fp)
            age_queue = arp_table[i].ctime;
   3006c:	e0bffbc3 	ldbu	r2,-17(fp)
   30070:	00c001b4 	movhi	r3,6
   30074:	18c8dc04 	addi	r3,r3,9072
   30078:	10800524 	muli	r2,r2,20
   3007c:	1885883a 	add	r2,r3,r2
   30080:	10800404 	addi	r2,r2,16
   30084:	108000c3 	ldbu	r2,3(r2)
   30088:	e0bffcc5 	stb	r2,-13(fp)
   3008c:	00002c06 	br	30140 <etharp_find_entry+0x200>
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
   30090:	e0bffbc3 	ldbu	r2,-17(fp)
   30094:	00c001b4 	movhi	r3,6
   30098:	18c8dc04 	addi	r3,r3,9072
   3009c:	10800524 	muli	r2,r2,20
   300a0:	1885883a 	add	r2,r3,r2
   300a4:	10800404 	addi	r2,r2,16
   300a8:	108000c3 	ldbu	r2,3(r2)
   300ac:	10c03fcc 	andi	r3,r2,255
   300b0:	e0bffc03 	ldbu	r2,-16(fp)
   300b4:	18802236 	bltu	r3,r2,30140 <etharp_find_entry+0x200>
            old_pending = i;
   300b8:	e0bffbc3 	ldbu	r2,-17(fp)
   300bc:	e0bffb05 	stb	r2,-20(fp)
            age_pending = arp_table[i].ctime;
   300c0:	e0bffbc3 	ldbu	r2,-17(fp)
   300c4:	00c001b4 	movhi	r3,6
   300c8:	18c8dc04 	addi	r3,r3,9072
   300cc:	10800524 	muli	r2,r2,20
   300d0:	1885883a 	add	r2,r3,r2
   300d4:	10800404 	addi	r2,r2,16
   300d8:	108000c3 	ldbu	r2,3(r2)
   300dc:	e0bffc05 	stb	r2,-16(fp)
   300e0:	00001706 	br	30140 <etharp_find_entry+0x200>
          }
        }
      /* stable entry? */
      } else if (state >= ETHARP_STATE_STABLE) {
   300e4:	e0bffd03 	ldbu	r2,-12(fp)
   300e8:	108000b0 	cmpltui	r2,r2,2
   300ec:	1000141e 	bne	r2,zero,30140 <etharp_find_entry+0x200>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
   300f0:	e0bffbc3 	ldbu	r2,-17(fp)
   300f4:	00c001b4 	movhi	r3,6
   300f8:	18c8dc04 	addi	r3,r3,9072
   300fc:	10800524 	muli	r2,r2,20
   30100:	1885883a 	add	r2,r3,r2
   30104:	10800404 	addi	r2,r2,16
   30108:	108000c3 	ldbu	r2,3(r2)
   3010c:	10c03fcc 	andi	r3,r2,255
   30110:	e0bffc43 	ldbu	r2,-15(fp)
   30114:	18800a36 	bltu	r3,r2,30140 <etharp_find_entry+0x200>
            old_stable = i;
   30118:	e0bffbc3 	ldbu	r2,-17(fp)
   3011c:	e0bffb45 	stb	r2,-19(fp)
            age_stable = arp_table[i].ctime;
   30120:	e0bffbc3 	ldbu	r2,-17(fp)
   30124:	00c001b4 	movhi	r3,6
   30128:	18c8dc04 	addi	r3,r3,9072
   3012c:	10800524 	muli	r2,r2,20
   30130:	1885883a 	add	r2,r3,r2
   30134:	10800404 	addi	r2,r2,16
   30138:	108000c3 	ldbu	r2,3(r2)
   3013c:	e0bffc45 	stb	r2,-15(fp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
   30140:	e0bffbc3 	ldbu	r2,-17(fp)
   30144:	10800044 	addi	r2,r2,1
   30148:	e0bffbc5 	stb	r2,-17(fp)
   3014c:	e0bffbc3 	ldbu	r2,-17(fp)
   30150:	10800670 	cmpltui	r2,r2,25
   30154:	103f8f1e 	bne	r2,zero,2ff94 <etharp_find_entry+0x54>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
   30158:	e0bfff03 	ldbu	r2,-4(fp)
   3015c:	1080008c 	andi	r2,r2,2
   30160:	1000061e 	bne	r2,zero,3017c <etharp_find_entry+0x23c>
   30164:	e0bffb87 	ldb	r2,-18(fp)
   30168:	10800658 	cmpnei	r2,r2,25
   3016c:	1000051e 	bne	r2,zero,30184 <etharp_find_entry+0x244>
      /* or no empty entry found and not allowed to recycle? */
      ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
   30170:	e0bfff03 	ldbu	r2,-4(fp)
   30174:	1080004c 	andi	r2,r2,1
   30178:	1000021e 	bne	r2,zero,30184 <etharp_find_entry+0x244>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
   3017c:	00bfffc4 	movi	r2,-1
   30180:	00003006 	br	30244 <etharp_find_entry+0x304>
   * 
   * { ETHARP_FLAG_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
   30184:	e0bffb87 	ldb	r2,-18(fp)
   30188:	10800648 	cmpgei	r2,r2,25
   3018c:	1000031e 	bne	r2,zero,3019c <etharp_find_entry+0x25c>
    i = empty;
   30190:	e0bffb83 	ldbu	r2,-18(fp)
   30194:	e0bffbc5 	stb	r2,-17(fp)
   30198:	00001706 	br	301f8 <etharp_find_entry+0x2b8>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  } else {
    /* 2) found recyclable stable entry? */
    if (old_stable < ARP_TABLE_SIZE) {
   3019c:	e0bffb47 	ldb	r2,-19(fp)
   301a0:	10800648 	cmpgei	r2,r2,25
   301a4:	1000031e 	bne	r2,zero,301b4 <etharp_find_entry+0x274>
      /* recycle oldest stable*/
      i = old_stable;
   301a8:	e0bffb43 	ldbu	r2,-19(fp)
   301ac:	e0bffbc5 	stb	r2,-17(fp)
   301b0:	00000e06 	br	301ec <etharp_find_entry+0x2ac>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
      /* no queued packets should exist on stable entries */
      LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
    /* 3) found recyclable pending entry without queued packets? */
    } else if (old_pending < ARP_TABLE_SIZE) {
   301b4:	e0bffb07 	ldb	r2,-20(fp)
   301b8:	10800648 	cmpgei	r2,r2,25
   301bc:	1000031e 	bne	r2,zero,301cc <etharp_find_entry+0x28c>
      /* recycle oldest pending */
      i = old_pending;
   301c0:	e0bffb03 	ldbu	r2,-20(fp)
   301c4:	e0bffbc5 	stb	r2,-17(fp)
   301c8:	00000806 	br	301ec <etharp_find_entry+0x2ac>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
    /* 4) found recyclable pending entry with queued packets? */
    } else if (old_queue < ARP_TABLE_SIZE) {
   301cc:	e0bffc87 	ldb	r2,-14(fp)
   301d0:	10800648 	cmpgei	r2,r2,25
   301d4:	1000031e 	bne	r2,zero,301e4 <etharp_find_entry+0x2a4>
      /* recycle oldest pending (queued packets are free in etharp_free_entry) */
      i = old_queue;
   301d8:	e0bffc83 	ldbu	r2,-14(fp)
   301dc:	e0bffbc5 	stb	r2,-17(fp)
   301e0:	00000206 	br	301ec <etharp_find_entry+0x2ac>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
      /* no empty or recyclable entries found */
    } else {
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty or recyclable entries found\n"));
      return (s8_t)ERR_MEM;
   301e4:	00bfffc4 	movi	r2,-1
   301e8:	00001606 	br	30244 <etharp_find_entry+0x304>
    }

    /* { empty or recyclable entry found } */
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
    etharp_free_entry(i);
   301ec:	e0bffbc3 	ldbu	r2,-17(fp)
   301f0:	1009883a 	mov	r4,r2
   301f4:	002fd340 	call	2fd34 <etharp_free_entry>
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
    arp_table[i].state == ETHARP_STATE_EMPTY);

  /* IP address given? */
  if (ipaddr != NULL) {
   301f8:	e0bffe17 	ldw	r2,-8(fp)
   301fc:	10000926 	beq	r2,zero,30224 <etharp_find_entry+0x2e4>
    /* set IP address */
    ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
   30200:	e0bffbc3 	ldbu	r2,-17(fp)
   30204:	e0fffe17 	ldw	r3,-8(fp)
   30208:	18c00017 	ldw	r3,0(r3)
   3020c:	010001b4 	movhi	r4,6
   30210:	2108dc04 	addi	r4,r4,9072
   30214:	10800524 	muli	r2,r2,20
   30218:	2085883a 	add	r2,r4,r2
   3021c:	10800104 	addi	r2,r2,4
   30220:	10c00015 	stw	r3,0(r2)
  }
  arp_table[i].ctime = 0;
   30224:	e0bffbc3 	ldbu	r2,-17(fp)
   30228:	00c001b4 	movhi	r3,6
   3022c:	18c8dc04 	addi	r3,r3,9072
   30230:	10800524 	muli	r2,r2,20
   30234:	1885883a 	add	r2,r3,r2
   30238:	10800404 	addi	r2,r2,16
   3023c:	100000c5 	stb	zero,3(r2)
  return (err_t)i;
   30240:	e0bffbc3 	ldbu	r2,-17(fp)
}
   30244:	e037883a 	mov	sp,fp
   30248:	dfc00117 	ldw	ra,4(sp)
   3024c:	df000017 	ldw	fp,0(sp)
   30250:	dec00204 	addi	sp,sp,8
   30254:	f800283a 	ret

00030258 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
   30258:	defff904 	addi	sp,sp,-28
   3025c:	dfc00615 	stw	ra,24(sp)
   30260:	df000515 	stw	fp,20(sp)
   30264:	df000504 	addi	fp,sp,20
   30268:	e13ffc15 	stw	r4,-16(fp)
   3026c:	e17ffd15 	stw	r5,-12(fp)
   30270:	e1bffe15 	stw	r6,-8(fp)
   30274:	e1ffff15 	stw	r7,-4(fp)
  struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
   30278:	e0bffd17 	ldw	r2,-12(fp)
   3027c:	10800117 	ldw	r2,4(r2)
   30280:	e0bffb15 	stw	r2,-20(fp)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  ETHADDR32_COPY(&ethhdr->dest, dst);
   30284:	e0bffb17 	ldw	r2,-20(fp)
   30288:	10800084 	addi	r2,r2,2
   3028c:	1009883a 	mov	r4,r2
   30290:	e17fff17 	ldw	r5,-4(fp)
   30294:	01800184 	movi	r6,6
   30298:	00041f00 	call	41f0 <memcpy>
  ETHADDR16_COPY(&ethhdr->src, src);
   3029c:	e0bffb17 	ldw	r2,-20(fp)
   302a0:	10800204 	addi	r2,r2,8
   302a4:	1009883a 	mov	r4,r2
   302a8:	e17ffe17 	ldw	r5,-8(fp)
   302ac:	01800184 	movi	r6,6
   302b0:	00041f00 	call	41f0 <memcpy>
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
   302b4:	e0bffb17 	ldw	r2,-20(fp)
   302b8:	10c00383 	ldbu	r3,14(r2)
   302bc:	1806703a 	and	r3,r3,zero
   302c0:	18c00214 	ori	r3,r3,8
   302c4:	10c00385 	stb	r3,14(r2)
   302c8:	10c003c3 	ldbu	r3,15(r2)
   302cc:	1806703a 	and	r3,r3,zero
   302d0:	10c003c5 	stb	r3,15(r2)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
   302d4:	e0bffc17 	ldw	r2,-16(fp)
   302d8:	10800617 	ldw	r2,24(r2)
   302dc:	e13ffc17 	ldw	r4,-16(fp)
   302e0:	e17ffd17 	ldw	r5,-12(fp)
   302e4:	103ee83a 	callr	r2
}
   302e8:	e037883a 	mov	sp,fp
   302ec:	dfc00117 	ldw	ra,4(sp)
   302f0:	df000017 	ldw	fp,0(sp)
   302f4:	dec00204 	addi	sp,sp,8
   302f8:	f800283a 	ret

000302fc <etharp_update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
etharp_update_arp_entry(struct netif *netif, ip_addr_t *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
   302fc:	defff704 	addi	sp,sp,-36
   30300:	dfc00815 	stw	ra,32(sp)
   30304:	df000715 	stw	fp,28(sp)
   30308:	df000704 	addi	fp,sp,28
   3030c:	e13ffc15 	stw	r4,-16(fp)
   30310:	e17ffd15 	stw	r5,-12(fp)
   30314:	e1bffe15 	stw	r6,-8(fp)
   30318:	3805883a 	mov	r2,r7
   3031c:	e0bfff05 	stb	r2,-4(fp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
   30320:	e0bffd17 	ldw	r2,-12(fp)
   30324:	10000f26 	beq	r2,zero,30364 <etharp_update_arp_entry+0x68>
   30328:	e0bffd17 	ldw	r2,-12(fp)
   3032c:	10800017 	ldw	r2,0(r2)
   30330:	10000c26 	beq	r2,zero,30364 <etharp_update_arp_entry+0x68>
      ip_addr_isbroadcast(ipaddr, netif) ||
   30334:	e0bffd17 	ldw	r2,-12(fp)
   30338:	10800017 	ldw	r2,0(r2)
   3033c:	1009883a 	mov	r4,r2
   30340:	e17ffc17 	ldw	r5,-16(fp)
   30344:	001fa400 	call	1fa40 <ip4_addr_isbroadcast>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
   30348:	10803fcc 	andi	r2,r2,255
   3034c:	1000051e 	bne	r2,zero,30364 <etharp_update_arp_entry+0x68>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
   30350:	e0bffd17 	ldw	r2,-12(fp)
   30354:	10800017 	ldw	r2,0(r2)
   30358:	10803c0c 	andi	r2,r2,240
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
   3035c:	10803818 	cmpnei	r2,r2,224
   30360:	1000021e 	bne	r2,zero,3036c <etharp_update_arp_entry+0x70>
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
   30364:	00bffc84 	movi	r2,-14
   30368:	00005a06 	br	304d4 <etharp_update_arp_entry+0x1d8>
  }
  /* find or create ARP entry */
  i = etharp_find_entry(ipaddr, flags);
   3036c:	e0bfff03 	ldbu	r2,-4(fp)
   30370:	e13ffd17 	ldw	r4,-12(fp)
   30374:	100b883a 	mov	r5,r2
   30378:	002ff400 	call	2ff40 <etharp_find_entry>
   3037c:	e0bff905 	stb	r2,-28(fp)
  /* bail out if no entry could be found */
  if (i < 0) {
   30380:	e0bff907 	ldb	r2,-28(fp)
   30384:	1000020e 	bge	r2,zero,30390 <etharp_update_arp_entry+0x94>
    return (err_t)i;
   30388:	e0bff903 	ldbu	r2,-28(fp)
   3038c:	00005106 	br	304d4 <etharp_update_arp_entry+0x1d8>
    arp_table[i].state = ETHARP_STATE_STATIC;
  } else
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
  {
    /* mark it stable */
    arp_table[i].state = ETHARP_STATE_STABLE;
   30390:	e0bff907 	ldb	r2,-28(fp)
   30394:	00c001b4 	movhi	r3,6
   30398:	18c8dc04 	addi	r3,r3,9072
   3039c:	10800524 	muli	r2,r2,20
   303a0:	1885883a 	add	r2,r3,r2
   303a4:	10800404 	addi	r2,r2,16
   303a8:	00c00084 	movi	r3,2
   303ac:	10c00085 	stb	r3,2(r2)
  }

  /* record network interface */
  arp_table[i].netif = netif;
   303b0:	e0bff907 	ldb	r2,-28(fp)
   303b4:	00c001b4 	movhi	r3,6
   303b8:	18c8dc04 	addi	r3,r3,9072
   303bc:	10800524 	muli	r2,r2,20
   303c0:	1885883a 	add	r2,r3,r2
   303c4:	10800204 	addi	r2,r2,8
   303c8:	e0fffc17 	ldw	r3,-16(fp)
   303cc:	10c00015 	stw	r3,0(r2)
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
   303d0:	e0bff907 	ldb	r2,-28(fp)
   303d4:	10800524 	muli	r2,r2,20
   303d8:	10c00304 	addi	r3,r2,12
   303dc:	008001b4 	movhi	r2,6
   303e0:	1088dc04 	addi	r2,r2,9072
   303e4:	1885883a 	add	r2,r3,r2
   303e8:	e0fffe17 	ldw	r3,-8(fp)
   303ec:	19000003 	ldbu	r4,0(r3)
   303f0:	11000005 	stb	r4,0(r2)
   303f4:	19000043 	ldbu	r4,1(r3)
   303f8:	11000045 	stb	r4,1(r2)
   303fc:	19000083 	ldbu	r4,2(r3)
   30400:	11000085 	stb	r4,2(r2)
   30404:	190000c3 	ldbu	r4,3(r3)
   30408:	110000c5 	stb	r4,3(r2)
   3040c:	19000103 	ldbu	r4,4(r3)
   30410:	11000105 	stb	r4,4(r2)
   30414:	18c00143 	ldbu	r3,5(r3)
   30418:	10c00145 	stb	r3,5(r2)
  /* reset time stamp */
  arp_table[i].ctime = 0;
   3041c:	e0bff907 	ldb	r2,-28(fp)
   30420:	00c001b4 	movhi	r3,6
   30424:	18c8dc04 	addi	r3,r3,9072
   30428:	10800524 	muli	r2,r2,20
   3042c:	1885883a 	add	r2,r3,r2
   30430:	10800404 	addi	r2,r2,16
   30434:	100000c5 	stb	zero,3(r2)
  /* this is where we will send out queued packets! */
#if ARP_QUEUEING
  while (arp_table[i].q != NULL) {
   30438:	00001e06 	br	304b4 <etharp_update_arp_entry+0x1b8>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
   3043c:	e0bff907 	ldb	r2,-28(fp)
   30440:	00c001b4 	movhi	r3,6
   30444:	18c8dc04 	addi	r3,r3,9072
   30448:	10800524 	muli	r2,r2,20
   3044c:	1885883a 	add	r2,r3,r2
   30450:	10800017 	ldw	r2,0(r2)
   30454:	e0bffa15 	stw	r2,-24(fp)
    /* pop first item off the queue */
    arp_table[i].q = q->next;
   30458:	e0bff907 	ldb	r2,-28(fp)
   3045c:	e0fffa17 	ldw	r3,-24(fp)
   30460:	18c00017 	ldw	r3,0(r3)
   30464:	010001b4 	movhi	r4,6
   30468:	2108dc04 	addi	r4,r4,9072
   3046c:	10800524 	muli	r2,r2,20
   30470:	2085883a 	add	r2,r4,r2
   30474:	10c00015 	stw	r3,0(r2)
    /* get the packet pointer */
    p = q->p;
   30478:	e0bffa17 	ldw	r2,-24(fp)
   3047c:	10800117 	ldw	r2,4(r2)
   30480:	e0bffb15 	stw	r2,-20(fp)
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
   30484:	010002c4 	movi	r4,11
   30488:	e17ffa17 	ldw	r5,-24(fp)
   3048c:	00225900 	call	22590 <memp_free>
  if (arp_table[i].q != NULL) {
    struct pbuf *p = arp_table[i].q;
    arp_table[i].q = NULL;
#endif /* ARP_QUEUEING */
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
   30490:	e0bffc17 	ldw	r2,-16(fp)
   30494:	10800cc4 	addi	r2,r2,51
   30498:	e13ffc17 	ldw	r4,-16(fp)
   3049c:	e17ffb17 	ldw	r5,-20(fp)
   304a0:	100d883a 	mov	r6,r2
   304a4:	e1fffe17 	ldw	r7,-8(fp)
   304a8:	00302580 	call	30258 <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
   304ac:	e13ffb17 	ldw	r4,-20(fp)
   304b0:	00237600 	call	23760 <pbuf_free>
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
  /* reset time stamp */
  arp_table[i].ctime = 0;
  /* this is where we will send out queued packets! */
#if ARP_QUEUEING
  while (arp_table[i].q != NULL) {
   304b4:	e0bff907 	ldb	r2,-28(fp)
   304b8:	00c001b4 	movhi	r3,6
   304bc:	18c8dc04 	addi	r3,r3,9072
   304c0:	10800524 	muli	r2,r2,20
   304c4:	1885883a 	add	r2,r3,r2
   304c8:	10800017 	ldw	r2,0(r2)
   304cc:	103fdb1e 	bne	r2,zero,3043c <etharp_update_arp_entry+0x140>
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
    /* free the queued IP packet */
    pbuf_free(p);
  }
  return ERR_OK;
   304d0:	0005883a 	mov	r2,zero
}
   304d4:	e037883a 	mov	sp,fp
   304d8:	dfc00117 	ldw	ra,4(sp)
   304dc:	df000017 	ldw	fp,0(sp)
   304e0:	dec00204 	addi	sp,sp,8
   304e4:	f800283a 	ret

000304e8 <etharp_cleanup_netif>:
 * Remove all ARP table entries of the specified netif.
 *
 * @param netif points to a network interface
 */
void etharp_cleanup_netif(struct netif *netif)
{
   304e8:	defffc04 	addi	sp,sp,-16
   304ec:	dfc00315 	stw	ra,12(sp)
   304f0:	df000215 	stw	fp,8(sp)
   304f4:	df000204 	addi	fp,sp,8
   304f8:	e13fff15 	stw	r4,-4(fp)
  u8_t i;

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
   304fc:	e03ffe05 	stb	zero,-8(fp)
   30500:	00001906 	br	30568 <etharp_cleanup_netif+0x80>
    u8_t state = arp_table[i].state;
   30504:	e0bffe03 	ldbu	r2,-8(fp)
   30508:	00c001b4 	movhi	r3,6
   3050c:	18c8dc04 	addi	r3,r3,9072
   30510:	10800524 	muli	r2,r2,20
   30514:	1885883a 	add	r2,r3,r2
   30518:	10800404 	addi	r2,r2,16
   3051c:	10800083 	ldbu	r2,2(r2)
   30520:	e0bffe45 	stb	r2,-7(fp)
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
   30524:	e0bffe43 	ldbu	r2,-7(fp)
   30528:	10000c26 	beq	r2,zero,3055c <etharp_cleanup_netif+0x74>
   3052c:	e0bffe03 	ldbu	r2,-8(fp)
   30530:	00c001b4 	movhi	r3,6
   30534:	18c8dc04 	addi	r3,r3,9072
   30538:	10800524 	muli	r2,r2,20
   3053c:	1885883a 	add	r2,r3,r2
   30540:	10800204 	addi	r2,r2,8
   30544:	10c00017 	ldw	r3,0(r2)
   30548:	e0bfff17 	ldw	r2,-4(fp)
   3054c:	1880031e 	bne	r3,r2,3055c <etharp_cleanup_netif+0x74>
      etharp_free_entry(i);
   30550:	e0bffe03 	ldbu	r2,-8(fp)
   30554:	1009883a 	mov	r4,r2
   30558:	002fd340 	call	2fd34 <etharp_free_entry>
 */
void etharp_cleanup_netif(struct netif *netif)
{
  u8_t i;

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
   3055c:	e0bffe03 	ldbu	r2,-8(fp)
   30560:	10800044 	addi	r2,r2,1
   30564:	e0bffe05 	stb	r2,-8(fp)
   30568:	e0bffe03 	ldbu	r2,-8(fp)
   3056c:	10800670 	cmpltui	r2,r2,25
   30570:	103fe41e 	bne	r2,zero,30504 <etharp_cleanup_netif+0x1c>
    u8_t state = arp_table[i].state;
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
      etharp_free_entry(i);
    }
  }
}
   30574:	e037883a 	mov	sp,fp
   30578:	dfc00117 	ldw	ra,4(sp)
   3057c:	df000017 	ldw	fp,0(sp)
   30580:	dec00204 	addi	sp,sp,8
   30584:	f800283a 	ret

00030588 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, ip_addr_t *ipaddr,
         struct eth_addr **eth_ret, ip_addr_t **ip_ret)
{
   30588:	defff904 	addi	sp,sp,-28
   3058c:	dfc00615 	stw	ra,24(sp)
   30590:	df000515 	stw	fp,20(sp)
   30594:	df000504 	addi	fp,sp,20
   30598:	e13ffc15 	stw	r4,-16(fp)
   3059c:	e17ffd15 	stw	r5,-12(fp)
   305a0:	e1bffe15 	stw	r6,-8(fp)
   305a4:	e1ffff15 	stw	r7,-4(fp)
  LWIP_ASSERT("eth_ret != NULL && ip_ret != NULL",
    eth_ret != NULL && ip_ret != NULL);

  LWIP_UNUSED_ARG(netif);

  i = etharp_find_entry(ipaddr, ETHARP_FLAG_FIND_ONLY);
   305a8:	e13ffd17 	ldw	r4,-12(fp)
   305ac:	01400084 	movi	r5,2
   305b0:	002ff400 	call	2ff40 <etharp_find_entry>
   305b4:	e0bffb05 	stb	r2,-20(fp)
  if((i >= 0) && (arp_table[i].state >= ETHARP_STATE_STABLE)) {
   305b8:	e0bffb07 	ldb	r2,-20(fp)
   305bc:	10001c16 	blt	r2,zero,30630 <etharp_find_addr+0xa8>
   305c0:	e0bffb07 	ldb	r2,-20(fp)
   305c4:	00c001b4 	movhi	r3,6
   305c8:	18c8dc04 	addi	r3,r3,9072
   305cc:	10800524 	muli	r2,r2,20
   305d0:	1885883a 	add	r2,r3,r2
   305d4:	10800404 	addi	r2,r2,16
   305d8:	10800083 	ldbu	r2,2(r2)
   305dc:	10803fcc 	andi	r2,r2,255
   305e0:	108000b0 	cmpltui	r2,r2,2
   305e4:	1000121e 	bne	r2,zero,30630 <etharp_find_addr+0xa8>
      *eth_ret = &arp_table[i].ethaddr;
   305e8:	e0bffb07 	ldb	r2,-20(fp)
   305ec:	10800524 	muli	r2,r2,20
   305f0:	10c00304 	addi	r3,r2,12
   305f4:	008001b4 	movhi	r2,6
   305f8:	1088dc04 	addi	r2,r2,9072
   305fc:	1887883a 	add	r3,r3,r2
   30600:	e0bffe17 	ldw	r2,-8(fp)
   30604:	10c00015 	stw	r3,0(r2)
      *ip_ret = &arp_table[i].ipaddr;
   30608:	e0bffb07 	ldb	r2,-20(fp)
   3060c:	10800524 	muli	r2,r2,20
   30610:	10c00104 	addi	r3,r2,4
   30614:	008001b4 	movhi	r2,6
   30618:	1088dc04 	addi	r2,r2,9072
   3061c:	1887883a 	add	r3,r3,r2
   30620:	e0bfff17 	ldw	r2,-4(fp)
   30624:	10c00015 	stw	r3,0(r2)
      return i;
   30628:	e0bffb03 	ldbu	r2,-20(fp)
   3062c:	00000106 	br	30634 <etharp_find_addr+0xac>
  }
  return -1;
   30630:	00bfffc4 	movi	r2,-1
}
   30634:	e037883a 	mov	sp,fp
   30638:	dfc00117 	ldw	ra,4(sp)
   3063c:	df000017 	ldw	fp,0(sp)
   30640:	dec00204 	addi	sp,sp,8
   30644:	f800283a 	ret

00030648 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
static void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
   30648:	defff904 	addi	sp,sp,-28
   3064c:	dfc00615 	stw	ra,24(sp)
   30650:	df000515 	stw	fp,20(sp)
   30654:	df000504 	addi	fp,sp,20
   30658:	e13ffe15 	stw	r4,-8(fp)
   3065c:	e17fff15 	stw	r5,-4(fp)
  struct eth_hdr *ethhdr;
  struct ip_hdr *iphdr;
  ip_addr_t iphdr_src;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
   30660:	e0bffe17 	ldw	r2,-8(fp)
   30664:	1000091e 	bne	r2,zero,3068c <etharp_ip_input+0x44>
   30668:	01000134 	movhi	r4,4
   3066c:	21056e04 	addi	r4,r4,5560
   30670:	01400134 	movhi	r5,4
   30674:	29457a04 	addi	r5,r5,5608
   30678:	0180a104 	movi	r6,644
   3067c:	01c00134 	movhi	r7,4
   30680:	39c57e04 	addi	r7,r7,5624
   30684:	00044740 	call	4474 <printf>
   30688:	003fff06 	br	30688 <etharp_ip_input+0x40>

  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  ethhdr = (struct eth_hdr *)p->payload;
   3068c:	e0bfff17 	ldw	r2,-4(fp)
   30690:	10800117 	ldw	r2,4(r2)
   30694:	e0bffb15 	stw	r2,-20(fp)
  iphdr = (struct ip_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
   30698:	e0bffb17 	ldw	r2,-20(fp)
   3069c:	10800404 	addi	r2,r2,16
   306a0:	e0bffc15 	stw	r2,-16(fp)
  if (ethhdr->type == PP_HTONS(ETHTYPE_VLAN)) {
    iphdr = (struct ip_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  ip_addr_copy(iphdr_src, iphdr->src);
   306a4:	e0bffc17 	ldw	r2,-16(fp)
   306a8:	10c00303 	ldbu	r3,12(r2)
   306ac:	11000343 	ldbu	r4,13(r2)
   306b0:	2008923a 	slli	r4,r4,8
   306b4:	20c6b03a 	or	r3,r4,r3
   306b8:	11000383 	ldbu	r4,14(r2)
   306bc:	2008943a 	slli	r4,r4,16
   306c0:	20c6b03a 	or	r3,r4,r3
   306c4:	108003c3 	ldbu	r2,15(r2)
   306c8:	1004963a 	slli	r2,r2,24
   306cc:	10c4b03a 	or	r2,r2,r3
   306d0:	e0bffd15 	stw	r2,-12(fp)

  /* source is not on the local network? */
  if (!ip_addr_netcmp(&iphdr_src, &(netif->ip_addr), &(netif->netmask))) {
   306d4:	e0fffd17 	ldw	r3,-12(fp)
   306d8:	e0bffe17 	ldw	r2,-8(fp)
   306dc:	10800117 	ldw	r2,4(r2)
   306e0:	1886f03a 	xor	r3,r3,r2
   306e4:	e0bffe17 	ldw	r2,-8(fp)
   306e8:	10800217 	ldw	r2,8(r2)
   306ec:	1884703a 	and	r2,r3,r2
   306f0:	1000081e 	bne	r2,zero,30714 <etharp_ip_input+0xcc>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update the source IP address in the cache, if present */
  /* @todo We could use ETHARP_FLAG_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  etharp_update_arp_entry(netif, &iphdr_src, &(ethhdr->src), ETHARP_FLAG_FIND_ONLY);
   306f4:	e0bffb17 	ldw	r2,-20(fp)
   306f8:	10800204 	addi	r2,r2,8
   306fc:	e0fffd04 	addi	r3,fp,-12
   30700:	e13ffe17 	ldw	r4,-8(fp)
   30704:	180b883a 	mov	r5,r3
   30708:	100d883a 	mov	r6,r2
   3070c:	01c00084 	movi	r7,2
   30710:	00302fc0 	call	302fc <etharp_update_arp_entry>
}
   30714:	e037883a 	mov	sp,fp
   30718:	dfc00117 	ldw	ra,4(sp)
   3071c:	df000017 	ldw	fp,0(sp)
   30720:	dec00204 	addi	sp,sp,8
   30724:	f800283a 	ret

00030728 <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
static void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
   30728:	defff604 	addi	sp,sp,-40
   3072c:	dfc00915 	stw	ra,36(sp)
   30730:	df000815 	stw	fp,32(sp)
   30734:	df000804 	addi	fp,sp,32
   30738:	e13ffd15 	stw	r4,-12(fp)
   3073c:	e17ffe15 	stw	r5,-8(fp)
   30740:	e1bfff15 	stw	r6,-4(fp)
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
   30744:	e0bffd17 	ldw	r2,-12(fp)
   30748:	1000091e 	bne	r2,zero,30770 <etharp_arp_input+0x48>
   3074c:	01000134 	movhi	r4,4
   30750:	21056e04 	addi	r4,r4,5560
   30754:	01400134 	movhi	r5,4
   30758:	29457a04 	addi	r5,r5,5608
   3075c:	0180aec4 	movi	r6,699
   30760:	01c00134 	movhi	r7,4
   30764:	39c57e04 	addi	r7,r7,5624
   30768:	00044740 	call	4474 <printf>
   3076c:	003fff06 	br	3076c <etharp_arp_input+0x44>

  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < SIZEOF_ETHARP_PACKET) {
   30770:	e0bfff17 	ldw	r2,-4(fp)
   30774:	1080028b 	ldhu	r2,10(r2)
   30778:	10bfffcc 	andi	r2,r2,65535
   3077c:	10800b28 	cmpgeui	r2,r2,44
   30780:	1000111e 	bne	r2,zero,307c8 <etharp_arp_input+0xa0>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len,
      (s16_t)SIZEOF_ETHARP_PACKET));
    ETHARP_STATS_INC(etharp.lenerr);
   30784:	008001f4 	movhi	r2,7
   30788:	10ac6e04 	addi	r2,r2,-20040
   3078c:	10801117 	ldw	r2,68(r2)
   30790:	10c00044 	addi	r3,r2,1
   30794:	008001f4 	movhi	r2,7
   30798:	10ac6e04 	addi	r2,r2,-20040
   3079c:	10c01115 	stw	r3,68(r2)
    ETHARP_STATS_INC(etharp.drop);
   307a0:	008001f4 	movhi	r2,7
   307a4:	10ac6e04 	addi	r2,r2,-20040
   307a8:	10800f17 	ldw	r2,60(r2)
   307ac:	10c00044 	addi	r3,r2,1
   307b0:	008001f4 	movhi	r2,7
   307b4:	10ac6e04 	addi	r2,r2,-20040
   307b8:	10c00f15 	stw	r3,60(r2)
    pbuf_free(p);
   307bc:	e13fff17 	ldw	r4,-4(fp)
   307c0:	00237600 	call	23760 <pbuf_free>
   307c4:	0000b606 	br	30aa0 <etharp_arp_input+0x378>
    return;
  }

  ethhdr = (struct eth_hdr *)p->payload;
   307c8:	e0bfff17 	ldw	r2,-4(fp)
   307cc:	10800117 	ldw	r2,4(r2)
   307d0:	e0bff915 	stw	r2,-28(fp)
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
   307d4:	e0bff917 	ldw	r2,-28(fp)
   307d8:	10800404 	addi	r2,r2,16
   307dc:	e0bffa15 	stw	r2,-24(fp)
    hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
   307e0:	e0bffa17 	ldw	r2,-24(fp)
   307e4:	10c00003 	ldbu	r3,0(r2)
   307e8:	10800043 	ldbu	r2,1(r2)
   307ec:	1004923a 	slli	r2,r2,8
   307f0:	10c4b03a 	or	r2,r2,r3
   307f4:	10bfffcc 	andi	r2,r2,65535
   307f8:	10804018 	cmpnei	r2,r2,256
   307fc:	1000121e 	bne	r2,zero,30848 <etharp_arp_input+0x120>
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
   30800:	e0bffa17 	ldw	r2,-24(fp)
   30804:	10800103 	ldbu	r2,4(r2)
    hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
   30808:	10803fcc 	andi	r2,r2,255
   3080c:	10800198 	cmpnei	r2,r2,6
   30810:	10000d1e 	bne	r2,zero,30848 <etharp_arp_input+0x120>
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
      (hdr->protolen != sizeof(ip_addr_t)) ||
   30814:	e0bffa17 	ldw	r2,-24(fp)
   30818:	10800143 	ldbu	r2,5(r2)
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
   3081c:	10803fcc 	andi	r2,r2,255
   30820:	10800118 	cmpnei	r2,r2,4
   30824:	1000081e 	bne	r2,zero,30848 <etharp_arp_input+0x120>
      (hdr->protolen != sizeof(ip_addr_t)) ||
      (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
   30828:	e0bffa17 	ldw	r2,-24(fp)
   3082c:	10c00083 	ldbu	r3,2(r2)
   30830:	108000c3 	ldbu	r2,3(r2)
   30834:	1004923a 	slli	r2,r2,8
   30838:	10c4b03a 	or	r2,r2,r3
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
      (hdr->protolen != sizeof(ip_addr_t)) ||
   3083c:	10bfffcc 	andi	r2,r2,65535
   30840:	10800220 	cmpeqi	r2,r2,8
   30844:	1000111e 	bne	r2,zero,3088c <etharp_arp_input+0x164>
      (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, hdr->hwlen, hdr->proto, hdr->protolen));
    ETHARP_STATS_INC(etharp.proterr);
   30848:	008001f4 	movhi	r2,7
   3084c:	10ac6e04 	addi	r2,r2,-20040
   30850:	10801417 	ldw	r2,80(r2)
   30854:	10c00044 	addi	r3,r2,1
   30858:	008001f4 	movhi	r2,7
   3085c:	10ac6e04 	addi	r2,r2,-20040
   30860:	10c01415 	stw	r3,80(r2)
    ETHARP_STATS_INC(etharp.drop);
   30864:	008001f4 	movhi	r2,7
   30868:	10ac6e04 	addi	r2,r2,-20040
   3086c:	10800f17 	ldw	r2,60(r2)
   30870:	10c00044 	addi	r3,r2,1
   30874:	008001f4 	movhi	r2,7
   30878:	10ac6e04 	addi	r2,r2,-20040
   3087c:	10c00f15 	stw	r3,60(r2)
    pbuf_free(p);
   30880:	e13fff17 	ldw	r4,-4(fp)
   30884:	00237600 	call	23760 <pbuf_free>
   30888:	00008506 	br	30aa0 <etharp_arp_input+0x378>
    return;
  }
  ETHARP_STATS_INC(etharp.recv);
   3088c:	008001f4 	movhi	r2,7
   30890:	10ac6e04 	addi	r2,r2,-20040
   30894:	10800d17 	ldw	r2,52(r2)
   30898:	10c00044 	addi	r3,r2,1
   3089c:	008001f4 	movhi	r2,7
   308a0:	10ac6e04 	addi	r2,r2,-20040
   308a4:	10c00d15 	stw	r3,52(r2)
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
   308a8:	e0bffa17 	ldw	r2,-24(fp)
   308ac:	10800384 	addi	r2,r2,14
   308b0:	e0fffb04 	addi	r3,fp,-20
   308b4:	1809883a 	mov	r4,r3
   308b8:	100b883a 	mov	r5,r2
   308bc:	01800104 	movi	r6,4
   308c0:	00041f00 	call	41f0 <memcpy>
  IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
   308c4:	e0bffa17 	ldw	r2,-24(fp)
   308c8:	10800604 	addi	r2,r2,24
   308cc:	e0fffc04 	addi	r3,fp,-16
   308d0:	1809883a 	mov	r4,r3
   308d4:	100b883a 	mov	r5,r2
   308d8:	01800104 	movi	r6,4
   308dc:	00041f00 	call	41f0 <memcpy>

  /* this interface is not configured? */
  if (ip_addr_isany(&netif->ip_addr)) {
   308e0:	e0bffd17 	ldw	r2,-12(fp)
   308e4:	10800104 	addi	r2,r2,4
   308e8:	10000326 	beq	r2,zero,308f8 <etharp_arp_input+0x1d0>
   308ec:	e0bffd17 	ldw	r2,-12(fp)
   308f0:	10800117 	ldw	r2,4(r2)
   308f4:	1000021e 	bne	r2,zero,30900 <etharp_arp_input+0x1d8>
    for_us = 0;
   308f8:	e03ff805 	stb	zero,-32(fp)
   308fc:	00000506 	br	30914 <etharp_arp_input+0x1ec>
  } else {
    /* ARP packet directed to us? */
    for_us = (u8_t)ip_addr_cmp(&dipaddr, &(netif->ip_addr));
   30900:	e0fffc17 	ldw	r3,-16(fp)
   30904:	e0bffd17 	ldw	r2,-12(fp)
   30908:	10800117 	ldw	r2,4(r2)
   3090c:	1885003a 	cmpeq	r2,r3,r2
   30910:	e0bff805 	stb	r2,-32(fp)
  /* ARP message directed to us?
      -> add IP address in ARP cache; assume requester wants to talk to us,
         can result in directly sending the queued packets for this host.
     ARP message not directed to us?
      ->  update the source IP address in the cache, if present */
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
   30914:	e0bffa17 	ldw	r2,-24(fp)
   30918:	10c00204 	addi	r3,r2,8
   3091c:	e0bff803 	ldbu	r2,-32(fp)
   30920:	10000226 	beq	r2,zero,3092c <etharp_arp_input+0x204>
   30924:	00800044 	movi	r2,1
   30928:	00000106 	br	30930 <etharp_arp_input+0x208>
   3092c:	00800084 	movi	r2,2
   30930:	e17ffb04 	addi	r5,fp,-20
   30934:	e13ffd17 	ldw	r4,-12(fp)
   30938:	180d883a 	mov	r6,r3
   3093c:	100f883a 	mov	r7,r2
   30940:	00302fc0 	call	302fc <etharp_update_arp_entry>
                   for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);

  /* now act on the message itself */
  switch (hdr->opcode) {
   30944:	e0bffa17 	ldw	r2,-24(fp)
   30948:	10c00183 	ldbu	r3,6(r2)
   3094c:	108001c3 	ldbu	r2,7(r2)
   30950:	1004923a 	slli	r2,r2,8
   30954:	10c4b03a 	or	r2,r2,r3
   30958:	10bfffcc 	andi	r2,r2,65535
   3095c:	10c04020 	cmpeqi	r3,r2,256
   30960:	1800031e 	bne	r3,zero,30970 <etharp_arp_input+0x248>
   30964:	10808020 	cmpeqi	r2,r2,512
   30968:	10003e1e 	bne	r2,zero,30a64 <etharp_arp_input+0x33c>
   3096c:	00004206 	br	30a78 <etharp_arp_input+0x350>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
   30970:	e0bff803 	ldbu	r2,-32(fp)
   30974:	10003a26 	beq	r2,zero,30a60 <etharp_arp_input+0x338>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
   30978:	e0bffa17 	ldw	r2,-24(fp)
   3097c:	10c00183 	ldbu	r3,6(r2)
   30980:	1806703a 	and	r3,r3,zero
   30984:	10c00185 	stb	r3,6(r2)
   30988:	10c001c3 	ldbu	r3,7(r2)
   3098c:	1806703a 	and	r3,r3,zero
   30990:	18c00094 	ori	r3,r3,2
   30994:	10c001c5 	stb	r3,7(r2)

      IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
   30998:	e0bffa17 	ldw	r2,-24(fp)
   3099c:	10c00604 	addi	r3,r2,24
   309a0:	e0bffa17 	ldw	r2,-24(fp)
   309a4:	10800384 	addi	r2,r2,14
   309a8:	1809883a 	mov	r4,r3
   309ac:	100b883a 	mov	r5,r2
   309b0:	01800104 	movi	r6,4
   309b4:	00041f00 	call	41f0 <memcpy>
      IPADDR2_COPY(&hdr->sipaddr, &netif->ip_addr);
   309b8:	e0bffa17 	ldw	r2,-24(fp)
   309bc:	10c00384 	addi	r3,r2,14
   309c0:	e0bffd17 	ldw	r2,-12(fp)
   309c4:	10800104 	addi	r2,r2,4
   309c8:	1809883a 	mov	r4,r3
   309cc:	100b883a 	mov	r5,r2
   309d0:	01800104 	movi	r6,4
   309d4:	00041f00 	call	41f0 <memcpy>
       * 'sender IP address' MUST be sent using link-layer broadcast instead of
       * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
      ethdst_hwaddr = ip_addr_islinklocal(&netif->ip_addr) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
   309d8:	e0bffa17 	ldw	r2,-24(fp)
   309dc:	10c00484 	addi	r3,r2,18
   309e0:	e0bffa17 	ldw	r2,-24(fp)
   309e4:	10800204 	addi	r2,r2,8
   309e8:	1809883a 	mov	r4,r3
   309ec:	100b883a 	mov	r5,r2
   309f0:	01800184 	movi	r6,6
   309f4:	00041f00 	call	41f0 <memcpy>
#if LWIP_AUTOIP
      ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
      ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
   309f8:	e0bff917 	ldw	r2,-28(fp)
   309fc:	10c00084 	addi	r3,r2,2
   30a00:	e0bffa17 	ldw	r2,-24(fp)
   30a04:	10800204 	addi	r2,r2,8
   30a08:	1809883a 	mov	r4,r3
   30a0c:	100b883a 	mov	r5,r2
   30a10:	01800184 	movi	r6,6
   30a14:	00041f00 	call	41f0 <memcpy>
#endif /* LWIP_AUTOIP */
      ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
   30a18:	e0bffa17 	ldw	r2,-24(fp)
   30a1c:	10800204 	addi	r2,r2,8
   30a20:	1009883a 	mov	r4,r2
   30a24:	e17ffe17 	ldw	r5,-8(fp)
   30a28:	01800184 	movi	r6,6
   30a2c:	00041f00 	call	41f0 <memcpy>
      ETHADDR16_COPY(&ethhdr->src, ethaddr);
   30a30:	e0bff917 	ldw	r2,-28(fp)
   30a34:	10800204 	addi	r2,r2,8
   30a38:	1009883a 	mov	r4,r2
   30a3c:	e17ffe17 	ldw	r5,-8(fp)
   30a40:	01800184 	movi	r6,6
   30a44:	00041f00 	call	41f0 <memcpy>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
   30a48:	e0bffd17 	ldw	r2,-12(fp)
   30a4c:	10800617 	ldw	r2,24(r2)
   30a50:	e13ffd17 	ldw	r4,-12(fp)
   30a54:	e17fff17 	ldw	r5,-4(fp)
   30a58:	103ee83a 	callr	r2
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
    }
    break;
   30a5c:	00000e06 	br	30a98 <etharp_arp_input+0x370>
   30a60:	00000d06 	br	30a98 <etharp_arp_input+0x370>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
   30a64:	e0bffb04 	addi	r2,fp,-20
   30a68:	e13ffd17 	ldw	r4,-12(fp)
   30a6c:	100b883a 	mov	r5,r2
   30a70:	001c9140 	call	1c914 <dhcp_arp_reply>
#endif /* (LWIP_DHCP && DHCP_DOES_ARP_CHECK) */
    break;
   30a74:	00000806 	br	30a98 <etharp_arp_input+0x370>
  default:
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
   30a78:	008001f4 	movhi	r2,7
   30a7c:	10ac6e04 	addi	r2,r2,-20040
   30a80:	10801617 	ldw	r2,88(r2)
   30a84:	10c00044 	addi	r3,r2,1
   30a88:	008001f4 	movhi	r2,7
   30a8c:	10ac6e04 	addi	r2,r2,-20040
   30a90:	10c01615 	stw	r3,88(r2)
    break;
   30a94:	0001883a 	nop
  }
  /* free ARP packet */
  pbuf_free(p);
   30a98:	e13fff17 	ldw	r4,-4(fp)
   30a9c:	00237600 	call	23760 <pbuf_free>
}
   30aa0:	e037883a 	mov	sp,fp
   30aa4:	dfc00117 	ldw	ra,4(sp)
   30aa8:	df000017 	ldw	fp,0(sp)
   30aac:	dec00204 	addi	sp,sp,8
   30ab0:	f800283a 	ret

00030ab4 <etharp_output_to_arp_index>:
/** Just a small helper function that sends a pbuf to an ethernet address
 * in the arp_table specified by the index 'arp_idx'.
 */
static err_t
etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
{
   30ab4:	defffb04 	addi	sp,sp,-20
   30ab8:	dfc00415 	stw	ra,16(sp)
   30abc:	df000315 	stw	fp,12(sp)
   30ac0:	df000304 	addi	fp,sp,12
   30ac4:	e13ffd15 	stw	r4,-12(fp)
   30ac8:	e17ffe15 	stw	r5,-8(fp)
   30acc:	3005883a 	mov	r2,r6
   30ad0:	e0bfff05 	stb	r2,-4(fp)
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
   30ad4:	e0bfff03 	ldbu	r2,-4(fp)
   30ad8:	00c001b4 	movhi	r3,6
   30adc:	18c8dc04 	addi	r3,r3,9072
   30ae0:	10800524 	muli	r2,r2,20
   30ae4:	1885883a 	add	r2,r3,r2
   30ae8:	10800404 	addi	r2,r2,16
   30aec:	10800083 	ldbu	r2,2(r2)
   30af0:	10803fcc 	andi	r2,r2,255
   30af4:	10800098 	cmpnei	r2,r2,2
   30af8:	10001f1e 	bne	r2,zero,30b78 <etharp_output_to_arp_index+0xc4>
      (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
   30afc:	e0bfff03 	ldbu	r2,-4(fp)
   30b00:	00c001b4 	movhi	r3,6
   30b04:	18c8dc04 	addi	r3,r3,9072
   30b08:	10800524 	muli	r2,r2,20
   30b0c:	1885883a 	add	r2,r3,r2
   30b10:	10800404 	addi	r2,r2,16
   30b14:	108000c3 	ldbu	r2,3(r2)
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
   30b18:	10803fcc 	andi	r2,r2,255
   30b1c:	10803930 	cmpltui	r2,r2,228
   30b20:	1000151e 	bne	r2,zero,30b78 <etharp_output_to_arp_index+0xc4>
      (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
    if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
   30b24:	e0bfff03 	ldbu	r2,-4(fp)
   30b28:	10800524 	muli	r2,r2,20
   30b2c:	10c00104 	addi	r3,r2,4
   30b30:	008001b4 	movhi	r2,6
   30b34:	1088dc04 	addi	r2,r2,9072
   30b38:	1885883a 	add	r2,r3,r2
   30b3c:	e13ffd17 	ldw	r4,-12(fp)
   30b40:	100b883a 	mov	r5,r2
   30b44:	003149c0 	call	3149c <etharp_request>
   30b48:	10803fcc 	andi	r2,r2,255
   30b4c:	1080201c 	xori	r2,r2,128
   30b50:	10bfe004 	addi	r2,r2,-128
   30b54:	1000081e 	bne	r2,zero,30b78 <etharp_output_to_arp_index+0xc4>
      arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
   30b58:	e0bfff03 	ldbu	r2,-4(fp)
   30b5c:	00c001b4 	movhi	r3,6
   30b60:	18c8dc04 	addi	r3,r3,9072
   30b64:	10800524 	muli	r2,r2,20
   30b68:	1885883a 	add	r2,r3,r2
   30b6c:	10800404 	addi	r2,r2,16
   30b70:	00c000c4 	movi	r3,3
   30b74:	10c00085 	stb	r3,2(r2)
    }
  }
  
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
   30b78:	e0bffd17 	ldw	r2,-12(fp)
   30b7c:	10c00cc4 	addi	r3,r2,51
    &arp_table[arp_idx].ethaddr);
   30b80:	e0bfff03 	ldbu	r2,-4(fp)
    if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
      arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
    }
  }
  
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
   30b84:	10800524 	muli	r2,r2,20
   30b88:	11000304 	addi	r4,r2,12
   30b8c:	008001b4 	movhi	r2,6
   30b90:	1088dc04 	addi	r2,r2,9072
   30b94:	2085883a 	add	r2,r4,r2
   30b98:	e13ffd17 	ldw	r4,-12(fp)
   30b9c:	e17ffe17 	ldw	r5,-8(fp)
   30ba0:	180d883a 	mov	r6,r3
   30ba4:	100f883a 	mov	r7,r2
   30ba8:	00302580 	call	30258 <etharp_send_ip>
    &arp_table[arp_idx].ethaddr);
}
   30bac:	e037883a 	mov	sp,fp
   30bb0:	dfc00117 	ldw	ra,4(sp)
   30bb4:	df000017 	ldw	fp,0(sp)
   30bb8:	dec00204 	addi	sp,sp,8
   30bbc:	f800283a 	ret

00030bc0 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, ip_addr_t *ipaddr)
{
   30bc0:	defff704 	addi	sp,sp,-36
   30bc4:	dfc00815 	stw	ra,32(sp)
   30bc8:	df000715 	stw	fp,28(sp)
   30bcc:	df000704 	addi	fp,sp,28
   30bd0:	e13ffd15 	stw	r4,-12(fp)
   30bd4:	e17ffe15 	stw	r5,-8(fp)
   30bd8:	e1bfff15 	stw	r6,-4(fp)
  struct eth_addr *dest;
  struct eth_addr mcastaddr;
  ip_addr_t *dst_addr = ipaddr;
   30bdc:	e0bfff17 	ldw	r2,-4(fp)
   30be0:	e0bffa15 	stw	r2,-24(fp)
  LWIP_ASSERT("netif != NULL", netif != NULL);
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
   30be4:	e13ffe17 	ldw	r4,-8(fp)
   30be8:	01400404 	movi	r5,16
   30bec:	00235b00 	call	235b0 <pbuf_header>
   30bf0:	10803fcc 	andi	r2,r2,255
   30bf4:	10000926 	beq	r2,zero,30c1c <etharp_output+0x5c>
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
   30bf8:	008001f4 	movhi	r2,7
   30bfc:	10ac6e04 	addi	r2,r2,-20040
   30c00:	10800517 	ldw	r2,20(r2)
   30c04:	10c00044 	addi	r3,r2,1
   30c08:	008001f4 	movhi	r2,7
   30c0c:	10ac6e04 	addi	r2,r2,-20040
   30c10:	10c00515 	stw	r3,20(r2)
    return ERR_BUF;
   30c14:	00bfff84 	movi	r2,-2
   30c18:	00009f06 	br	30e98 <etharp_output+0x2d8>

  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
   30c1c:	e0bfff17 	ldw	r2,-4(fp)
   30c20:	10800017 	ldw	r2,0(r2)
   30c24:	1009883a 	mov	r4,r2
   30c28:	e17ffd17 	ldw	r5,-12(fp)
   30c2c:	001fa400 	call	1fa40 <ip4_addr_isbroadcast>
   30c30:	10803fcc 	andi	r2,r2,255
   30c34:	10000326 	beq	r2,zero,30c44 <etharp_output+0x84>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
   30c38:	d0a01584 	addi	r2,gp,-32682
   30c3c:	e0bff915 	stw	r2,-28(fp)
   30c40:	00008e06 	br	30e7c <etharp_output+0x2bc>
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
   30c44:	e0bfff17 	ldw	r2,-4(fp)
   30c48:	10800017 	ldw	r2,0(r2)
   30c4c:	10803c0c 	andi	r2,r2,240
   30c50:	10803818 	cmpnei	r2,r2,224
   30c54:	1000131e 	bne	r2,zero,30ca4 <etharp_output+0xe4>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
   30c58:	00800044 	movi	r2,1
   30c5c:	e0bffb85 	stb	r2,-18(fp)
    mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
   30c60:	e03ffbc5 	stb	zero,-17(fp)
    mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
   30c64:	00801784 	movi	r2,94
   30c68:	e0bffc05 	stb	r2,-16(fp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
   30c6c:	e0bfff17 	ldw	r2,-4(fp)
   30c70:	10800044 	addi	r2,r2,1
   30c74:	10800003 	ldbu	r2,0(r2)
   30c78:	10801fcc 	andi	r2,r2,127
   30c7c:	e0bffc45 	stb	r2,-15(fp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
   30c80:	e0bfff17 	ldw	r2,-4(fp)
   30c84:	10800083 	ldbu	r2,2(r2)
   30c88:	e0bffc85 	stb	r2,-14(fp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
   30c8c:	e0bfff17 	ldw	r2,-4(fp)
   30c90:	108000c3 	ldbu	r2,3(r2)
   30c94:	e0bffcc5 	stb	r2,-13(fp)
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
   30c98:	e0bffb84 	addi	r2,fp,-18
   30c9c:	e0bff915 	stw	r2,-28(fp)
   30ca0:	00007606 	br	30e7c <etharp_output+0x2bc>
  /* unicast destination IP address? */
  } else {
    s8_t i;
    /* outside local network? if so, this can neither be a global broadcast nor
       a subnet broadcast. */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
   30ca4:	e0bfff17 	ldw	r2,-4(fp)
   30ca8:	10c00017 	ldw	r3,0(r2)
   30cac:	e0bffd17 	ldw	r2,-12(fp)
   30cb0:	10800117 	ldw	r2,4(r2)
   30cb4:	1886f03a 	xor	r3,r3,r2
   30cb8:	e0bffd17 	ldw	r2,-12(fp)
   30cbc:	10800217 	ldw	r2,8(r2)
   30cc0:	1884703a 	and	r2,r3,r2
   30cc4:	10001126 	beq	r2,zero,30d0c <etharp_output+0x14c>
        !ip_addr_islinklocal(ipaddr)) {
   30cc8:	e0bfff17 	ldw	r2,-4(fp)
   30ccc:	10800017 	ldw	r2,0(r2)
   30cd0:	10ffffcc 	andi	r3,r2,65535
  /* unicast destination IP address? */
  } else {
    s8_t i;
    /* outside local network? if so, this can neither be a global broadcast nor
       a subnet broadcast. */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
   30cd4:	00bfaa54 	movui	r2,65193
   30cd8:	18800c26 	beq	r3,r2,30d0c <etharp_output+0x14c>
         router for forwarding". */
      if (!ip_addr_islinklocal(&iphdr->src))
#endif /* LWIP_AUTOIP */
      {
        /* interface has default gateway? */
        if (!ip_addr_isany(&netif->gw)) {
   30cdc:	e0bffd17 	ldw	r2,-12(fp)
   30ce0:	10800304 	addi	r2,r2,12
   30ce4:	10000726 	beq	r2,zero,30d04 <etharp_output+0x144>
   30ce8:	e0bffd17 	ldw	r2,-12(fp)
   30cec:	10800317 	ldw	r2,12(r2)
   30cf0:	10000426 	beq	r2,zero,30d04 <etharp_output+0x144>
          /* send to hardware address of default gateway IP address */
          dst_addr = &(netif->gw);
   30cf4:	e0bffd17 	ldw	r2,-12(fp)
   30cf8:	10800304 	addi	r2,r2,12
   30cfc:	e0bffa15 	stw	r2,-24(fp)
   30d00:	00000206 	br	30d0c <etharp_output+0x14c>
        /* no default gateway available */
        } else {
          /* no route to destination error (default gateway missing) */
          return ERR_RTE;
   30d04:	00bfff04 	movi	r2,-4
   30d08:	00006306 	br	30e98 <etharp_output+0x2d8>
        }
      }
    }
#if LWIP_NETIF_HWADDRHINT
    if (netif->addr_hint != NULL) {
   30d0c:	e0bffd17 	ldw	r2,-12(fp)
   30d10:	10801017 	ldw	r2,64(r2)
   30d14:	10002826 	beq	r2,zero,30db8 <etharp_output+0x1f8>
      /* per-pcb cached entry was given */
      u8_t etharp_cached_entry = *(netif->addr_hint);
   30d18:	e0bffd17 	ldw	r2,-12(fp)
   30d1c:	10801017 	ldw	r2,64(r2)
   30d20:	10800003 	ldbu	r2,0(r2)
   30d24:	e0bffb45 	stb	r2,-19(fp)
      if (etharp_cached_entry < ARP_TABLE_SIZE) {
   30d28:	e0bffb43 	ldbu	r2,-19(fp)
   30d2c:	10800668 	cmpgeui	r2,r2,25
   30d30:	1000211e 	bne	r2,zero,30db8 <etharp_output+0x1f8>
#endif /* LWIP_NETIF_HWADDRHINT */
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
   30d34:	e0bffb43 	ldbu	r2,-19(fp)
   30d38:	00c001b4 	movhi	r3,6
   30d3c:	18c8dc04 	addi	r3,r3,9072
   30d40:	10800524 	muli	r2,r2,20
   30d44:	1885883a 	add	r2,r3,r2
   30d48:	10800404 	addi	r2,r2,16
   30d4c:	10800083 	ldbu	r2,2(r2)
   30d50:	10803fcc 	andi	r2,r2,255
   30d54:	108000b0 	cmpltui	r2,r2,2
   30d58:	1000171e 	bne	r2,zero,30db8 <etharp_output+0x1f8>
            (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
   30d5c:	e0bffa17 	ldw	r2,-24(fp)
   30d60:	10c00017 	ldw	r3,0(r2)
   30d64:	e0bffb43 	ldbu	r2,-19(fp)
   30d68:	010001b4 	movhi	r4,6
   30d6c:	2108dc04 	addi	r4,r4,9072
   30d70:	10800524 	muli	r2,r2,20
   30d74:	2085883a 	add	r2,r4,r2
   30d78:	10800104 	addi	r2,r2,4
   30d7c:	10800017 	ldw	r2,0(r2)
    if (netif->addr_hint != NULL) {
      /* per-pcb cached entry was given */
      u8_t etharp_cached_entry = *(netif->addr_hint);
      if (etharp_cached_entry < ARP_TABLE_SIZE) {
#endif /* LWIP_NETIF_HWADDRHINT */
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
   30d80:	18800d1e 	bne	r3,r2,30db8 <etharp_output+0x1f8>
            (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
          /* the per-pcb-cached entry is stable and the right one! */
          ETHARP_STATS_INC(etharp.cachehit);
   30d84:	008001f4 	movhi	r2,7
   30d88:	10ac6e04 	addi	r2,r2,-20040
   30d8c:	10801717 	ldw	r2,92(r2)
   30d90:	10c00044 	addi	r3,r2,1
   30d94:	008001f4 	movhi	r2,7
   30d98:	10ac6e04 	addi	r2,r2,-20040
   30d9c:	10c01715 	stw	r3,92(r2)
          return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
   30da0:	e0bffb43 	ldbu	r2,-19(fp)
   30da4:	e13ffd17 	ldw	r4,-12(fp)
   30da8:	e17ffe17 	ldw	r5,-8(fp)
   30dac:	100d883a 	mov	r6,r2
   30db0:	0030ab40 	call	30ab4 <etharp_output_to_arp_index>
   30db4:	00003806 	br	30e98 <etharp_output+0x2d8>
    }
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
   30db8:	e03ffb05 	stb	zero,-20(fp)
   30dbc:	00002706 	br	30e5c <etharp_output+0x29c>
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
   30dc0:	e0bffb07 	ldb	r2,-20(fp)
   30dc4:	00c001b4 	movhi	r3,6
   30dc8:	18c8dc04 	addi	r3,r3,9072
   30dcc:	10800524 	muli	r2,r2,20
   30dd0:	1885883a 	add	r2,r3,r2
   30dd4:	10800404 	addi	r2,r2,16
   30dd8:	10800083 	ldbu	r2,2(r2)
   30ddc:	10803fcc 	andi	r2,r2,255
   30de0:	108000b0 	cmpltui	r2,r2,2
   30de4:	10001a1e 	bne	r2,zero,30e50 <etharp_output+0x290>
          (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
   30de8:	e0bffa17 	ldw	r2,-24(fp)
   30dec:	10c00017 	ldw	r3,0(r2)
   30df0:	e0bffb07 	ldb	r2,-20(fp)
   30df4:	010001b4 	movhi	r4,6
   30df8:	2108dc04 	addi	r4,r4,9072
   30dfc:	10800524 	muli	r2,r2,20
   30e00:	2085883a 	add	r2,r4,r2
   30e04:	10800104 	addi	r2,r2,4
   30e08:	10800017 	ldw	r2,0(r2)
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
   30e0c:	1880101e 	bne	r3,r2,30e50 <etharp_output+0x290>
          (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
        /* found an existing, stable entry */
        ETHARP_SET_HINT(netif, i);
   30e10:	e0bffd17 	ldw	r2,-12(fp)
   30e14:	10000726 	beq	r2,zero,30e34 <etharp_output+0x274>
   30e18:	e0bffd17 	ldw	r2,-12(fp)
   30e1c:	10801017 	ldw	r2,64(r2)
   30e20:	10000426 	beq	r2,zero,30e34 <etharp_output+0x274>
   30e24:	e0bffd17 	ldw	r2,-12(fp)
   30e28:	10801017 	ldw	r2,64(r2)
   30e2c:	e0fffb03 	ldbu	r3,-20(fp)
   30e30:	10c00005 	stb	r3,0(r2)
        return etharp_output_to_arp_index(netif, q, i);
   30e34:	e0bffb03 	ldbu	r2,-20(fp)
   30e38:	10803fcc 	andi	r2,r2,255
   30e3c:	e13ffd17 	ldw	r4,-12(fp)
   30e40:	e17ffe17 	ldw	r5,-8(fp)
   30e44:	100d883a 	mov	r6,r2
   30e48:	0030ab40 	call	30ab4 <etharp_output_to_arp_index>
   30e4c:	00001206 	br	30e98 <etharp_output+0x2d8>
    }
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
   30e50:	e0bffb03 	ldbu	r2,-20(fp)
   30e54:	10800044 	addi	r2,r2,1
   30e58:	e0bffb05 	stb	r2,-20(fp)
   30e5c:	e0bffb07 	ldb	r2,-20(fp)
   30e60:	10800650 	cmplti	r2,r2,25
   30e64:	103fd61e 	bne	r2,zero,30dc0 <etharp_output+0x200>
        return etharp_output_to_arp_index(netif, q, i);
      }
    }
    /* no stable entry found, use the (slower) query function:
       queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, dst_addr, q);
   30e68:	e13ffd17 	ldw	r4,-12(fp)
   30e6c:	e17ffa17 	ldw	r5,-24(fp)
   30e70:	e1bffe17 	ldw	r6,-8(fp)
   30e74:	0030eac0 	call	30eac <etharp_query>
   30e78:	00000706 	br	30e98 <etharp_output+0x2d8>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
   30e7c:	e0bffd17 	ldw	r2,-12(fp)
   30e80:	10800cc4 	addi	r2,r2,51
   30e84:	e13ffd17 	ldw	r4,-12(fp)
   30e88:	e17ffe17 	ldw	r5,-8(fp)
   30e8c:	100d883a 	mov	r6,r2
   30e90:	e1fff917 	ldw	r7,-28(fp)
   30e94:	00302580 	call	30258 <etharp_send_ip>
}
   30e98:	e037883a 	mov	sp,fp
   30e9c:	dfc00117 	ldw	ra,4(sp)
   30ea0:	df000017 	ldw	fp,0(sp)
   30ea4:	dec00204 	addi	sp,sp,8
   30ea8:	f800283a 	ret

00030eac <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, ip_addr_t *ipaddr, struct pbuf *q)
{
   30eac:	defff404 	addi	sp,sp,-48
   30eb0:	dfc00b15 	stw	ra,44(sp)
   30eb4:	df000a15 	stw	fp,40(sp)
   30eb8:	df000a04 	addi	fp,sp,40
   30ebc:	e13ffd15 	stw	r4,-12(fp)
   30ec0:	e17ffe15 	stw	r5,-8(fp)
   30ec4:	e1bfff15 	stw	r6,-4(fp)
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
   30ec8:	e0bffd17 	ldw	r2,-12(fp)
   30ecc:	10800cc4 	addi	r2,r2,51
   30ed0:	e0bffa15 	stw	r2,-24(fp)
  err_t result = ERR_MEM;
   30ed4:	00bfffc4 	movi	r2,-1
   30ed8:	e0bff605 	stb	r2,-40(fp)
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
   30edc:	e0bffe17 	ldw	r2,-8(fp)
   30ee0:	10800017 	ldw	r2,0(r2)
   30ee4:	1009883a 	mov	r4,r2
   30ee8:	e17ffd17 	ldw	r5,-12(fp)
   30eec:	001fa400 	call	1fa40 <ip4_addr_isbroadcast>
   30ef0:	10803fcc 	andi	r2,r2,255
   30ef4:	10000a1e 	bne	r2,zero,30f20 <etharp_query+0x74>
      ip_addr_ismulticast(ipaddr) ||
   30ef8:	e0bffe17 	ldw	r2,-8(fp)
   30efc:	10800017 	ldw	r2,0(r2)
   30f00:	10803c0c 	andi	r2,r2,240
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
   30f04:	10803820 	cmpeqi	r2,r2,224
   30f08:	1000051e 	bne	r2,zero,30f20 <etharp_query+0x74>
      ip_addr_ismulticast(ipaddr) ||
   30f0c:	e0bffe17 	ldw	r2,-8(fp)
   30f10:	10000326 	beq	r2,zero,30f20 <etharp_query+0x74>
      ip_addr_isany(ipaddr)) {
   30f14:	e0bffe17 	ldw	r2,-8(fp)
   30f18:	10800017 	ldw	r2,0(r2)
   30f1c:	1000021e 	bne	r2,zero,30f28 <etharp_query+0x7c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
   30f20:	00bffc84 	movi	r2,-14
   30f24:	0000c906 	br	3124c <etharp_query+0x3a0>
  }

  /* find entry in ARP cache, ask to create entry if queueing packet */
  i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);
   30f28:	e13ffe17 	ldw	r4,-8(fp)
   30f2c:	01400044 	movi	r5,1
   30f30:	002ff400 	call	2ff40 <etharp_find_entry>
   30f34:	e0bffb05 	stb	r2,-20(fp)

  /* could not find or create entry? */
  if (i < 0) {
   30f38:	e0bffb07 	ldb	r2,-20(fp)
   30f3c:	10000b0e 	bge	r2,zero,30f6c <etharp_query+0xc0>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
    if (q) {
   30f40:	e0bfff17 	ldw	r2,-4(fp)
   30f44:	10000726 	beq	r2,zero,30f64 <etharp_query+0xb8>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
      ETHARP_STATS_INC(etharp.memerr);
   30f48:	008001f4 	movhi	r2,7
   30f4c:	10ac6e04 	addi	r2,r2,-20040
   30f50:	10801217 	ldw	r2,72(r2)
   30f54:	10c00044 	addi	r3,r2,1
   30f58:	008001f4 	movhi	r2,7
   30f5c:	10ac6e04 	addi	r2,r2,-20040
   30f60:	10c01215 	stw	r3,72(r2)
    }
    return (err_t)i;
   30f64:	e0bffb03 	ldbu	r2,-20(fp)
   30f68:	0000b806 	br	3124c <etharp_query+0x3a0>
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
   30f6c:	e0bffb07 	ldb	r2,-20(fp)
   30f70:	00c001b4 	movhi	r3,6
   30f74:	18c8dc04 	addi	r3,r3,9072
   30f78:	10800524 	muli	r2,r2,20
   30f7c:	1885883a 	add	r2,r3,r2
   30f80:	10800404 	addi	r2,r2,16
   30f84:	10800083 	ldbu	r2,2(r2)
   30f88:	10803fcc 	andi	r2,r2,255
   30f8c:	1000081e 	bne	r2,zero,30fb0 <etharp_query+0x104>
    arp_table[i].state = ETHARP_STATE_PENDING;
   30f90:	e0bffb07 	ldb	r2,-20(fp)
   30f94:	00c001b4 	movhi	r3,6
   30f98:	18c8dc04 	addi	r3,r3,9072
   30f9c:	10800524 	muli	r2,r2,20
   30fa0:	1885883a 	add	r2,r3,r2
   30fa4:	10800404 	addi	r2,r2,16
   30fa8:	00c00044 	movi	r3,1
   30fac:	10c00085 	stb	r3,2(r2)
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state >= ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
   30fb0:	e0bffb07 	ldb	r2,-20(fp)
   30fb4:	00c001b4 	movhi	r3,6
   30fb8:	18c8dc04 	addi	r3,r3,9072
   30fbc:	10800524 	muli	r2,r2,20
   30fc0:	1885883a 	add	r2,r3,r2
   30fc4:	10800404 	addi	r2,r2,16
   30fc8:	10800083 	ldbu	r2,2(r2)
   30fcc:	10803fcc 	andi	r2,r2,255
   30fd0:	10800060 	cmpeqi	r2,r2,1
   30fd4:	1000021e 	bne	r2,zero,30fe0 <etharp_query+0x134>
   30fd8:	e0bfff17 	ldw	r2,-4(fp)
   30fdc:	1000081e 	bne	r2,zero,31000 <etharp_query+0x154>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
   30fe0:	e13ffd17 	ldw	r4,-12(fp)
   30fe4:	e17ffe17 	ldw	r5,-8(fp)
   30fe8:	003149c0 	call	3149c <etharp_request>
   30fec:	e0bff605 	stb	r2,-40(fp)
      /* ARP request couldn't be sent */
      /* We don't re-send arp request in etharp_tmr, but we still queue packets,
         since this failure could be temporary, and the next packet calling
         etharp_query again could lead to sending the queued packets. */
    }
    if (q == NULL) {
   30ff0:	e0bfff17 	ldw	r2,-4(fp)
   30ff4:	1000021e 	bne	r2,zero,31000 <etharp_query+0x154>
      return result;
   30ff8:	e0bff603 	ldbu	r2,-40(fp)
   30ffc:	00009306 	br	3124c <etharp_query+0x3a0>
  }

  /* packet given? */
  LWIP_ASSERT("q != NULL", q != NULL);
  /* stable entry? */
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
   31000:	e0bffb07 	ldb	r2,-20(fp)
   31004:	00c001b4 	movhi	r3,6
   31008:	18c8dc04 	addi	r3,r3,9072
   3100c:	10800524 	muli	r2,r2,20
   31010:	1885883a 	add	r2,r3,r2
   31014:	10800404 	addi	r2,r2,16
   31018:	10800083 	ldbu	r2,2(r2)
   3101c:	10803fcc 	andi	r2,r2,255
   31020:	108000b0 	cmpltui	r2,r2,2
   31024:	1000161e 	bne	r2,zero,31080 <etharp_query+0x1d4>
    /* we have a valid IP->Ethernet address mapping */
    ETHARP_SET_HINT(netif, i);
   31028:	e0bffd17 	ldw	r2,-12(fp)
   3102c:	10000726 	beq	r2,zero,3104c <etharp_query+0x1a0>
   31030:	e0bffd17 	ldw	r2,-12(fp)
   31034:	10801017 	ldw	r2,64(r2)
   31038:	10000426 	beq	r2,zero,3104c <etharp_query+0x1a0>
   3103c:	e0bffd17 	ldw	r2,-12(fp)
   31040:	10801017 	ldw	r2,64(r2)
   31044:	e0fffb03 	ldbu	r3,-20(fp)
   31048:	10c00005 	stb	r3,0(r2)
    /* send the packet */
    result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
   3104c:	e0bffb07 	ldb	r2,-20(fp)
   31050:	10800524 	muli	r2,r2,20
   31054:	10c00304 	addi	r3,r2,12
   31058:	008001b4 	movhi	r2,6
   3105c:	1088dc04 	addi	r2,r2,9072
   31060:	1885883a 	add	r2,r3,r2
   31064:	e13ffd17 	ldw	r4,-12(fp)
   31068:	e17fff17 	ldw	r5,-4(fp)
   3106c:	e1bffa17 	ldw	r6,-24(fp)
   31070:	100f883a 	mov	r7,r2
   31074:	00302580 	call	30258 <etharp_send_ip>
   31078:	e0bff605 	stb	r2,-40(fp)
   3107c:	00007206 	br	31248 <etharp_query+0x39c>
  /* pending entry? (either just created or already pending */
  } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
   31080:	e0bffb07 	ldb	r2,-20(fp)
   31084:	00c001b4 	movhi	r3,6
   31088:	18c8dc04 	addi	r3,r3,9072
   3108c:	10800524 	muli	r2,r2,20
   31090:	1885883a 	add	r2,r3,r2
   31094:	10800404 	addi	r2,r2,16
   31098:	10800083 	ldbu	r2,2(r2)
   3109c:	10803fcc 	andi	r2,r2,255
   310a0:	10800058 	cmpnei	r2,r2,1
   310a4:	1000681e 	bne	r2,zero,31248 <etharp_query+0x39c>
    /* entry is still pending, queue the given packet 'q' */
    struct pbuf *p;
    int copy_needed = 0;
   310a8:	e03ff815 	stw	zero,-32(fp)
    /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
     * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
     * PBUF_ROMs can be left as they are, since ROM must not get changed. */
    p = q;
   310ac:	e0bfff17 	ldw	r2,-4(fp)
   310b0:	e0bff715 	stw	r2,-36(fp)
    while (p) {
   310b4:	00000b06 	br	310e4 <etharp_query+0x238>
      LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
      if(p->type != PBUF_ROM) {
   310b8:	e0bff717 	ldw	r2,-36(fp)
   310bc:	10800303 	ldbu	r2,12(r2)
   310c0:	10803fcc 	andi	r2,r2,255
   310c4:	10800060 	cmpeqi	r2,r2,1
   310c8:	1000031e 	bne	r2,zero,310d8 <etharp_query+0x22c>
        copy_needed = 1;
   310cc:	00800044 	movi	r2,1
   310d0:	e0bff815 	stw	r2,-32(fp)
        break;
   310d4:	00000506 	br	310ec <etharp_query+0x240>
      }
      p = p->next;
   310d8:	e0bff717 	ldw	r2,-36(fp)
   310dc:	10800017 	ldw	r2,0(r2)
   310e0:	e0bff715 	stw	r2,-36(fp)
    int copy_needed = 0;
    /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
     * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
     * PBUF_ROMs can be left as they are, since ROM must not get changed. */
    p = q;
    while (p) {
   310e4:	e0bff717 	ldw	r2,-36(fp)
   310e8:	103ff31e 	bne	r2,zero,310b8 <etharp_query+0x20c>
        copy_needed = 1;
        break;
      }
      p = p->next;
    }
    if(copy_needed) {
   310ec:	e0bff817 	ldw	r2,-32(fp)
   310f0:	10001526 	beq	r2,zero,31148 <etharp_query+0x29c>
      /* copy the whole packet into new pbufs */
      p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
   310f4:	e0bff717 	ldw	r2,-36(fp)
   310f8:	1080020b 	ldhu	r2,8(r2)
   310fc:	10bfffcc 	andi	r2,r2,65535
   31100:	010000c4 	movi	r4,3
   31104:	100b883a 	mov	r5,r2
   31108:	000d883a 	mov	r6,zero
   3110c:	0022fa00 	call	22fa0 <pbuf_alloc>
   31110:	e0bff715 	stw	r2,-36(fp)
      if(p != NULL) {
   31114:	e0bff717 	ldw	r2,-36(fp)
   31118:	10000f26 	beq	r2,zero,31158 <etharp_query+0x2ac>
        if (pbuf_copy(p, q) != ERR_OK) {
   3111c:	e13ff717 	ldw	r4,-36(fp)
   31120:	e17fff17 	ldw	r5,-4(fp)
   31124:	0023afc0 	call	23afc <pbuf_copy>
   31128:	10803fcc 	andi	r2,r2,255
   3112c:	1080201c 	xori	r2,r2,128
   31130:	10bfe004 	addi	r2,r2,-128
   31134:	10000826 	beq	r2,zero,31158 <etharp_query+0x2ac>
          pbuf_free(p);
   31138:	e13ff717 	ldw	r4,-36(fp)
   3113c:	00237600 	call	23760 <pbuf_free>
          p = NULL;
   31140:	e03ff715 	stw	zero,-36(fp)
   31144:	00000406 	br	31158 <etharp_query+0x2ac>
        }
      }
    } else {
      /* referencing the old pbuf is enough */
      p = q;
   31148:	e0bfff17 	ldw	r2,-4(fp)
   3114c:	e0bff715 	stw	r2,-36(fp)
      pbuf_ref(p);
   31150:	e13ff717 	ldw	r4,-36(fp)
   31154:	00238f00 	call	238f0 <pbuf_ref>
    }
    /* packet could be taken over? */
    if (p != NULL) {
   31158:	e0bff717 	ldw	r2,-36(fp)
   3115c:	10003126 	beq	r2,zero,31224 <etharp_query+0x378>
      /* queue packet ... */
#if ARP_QUEUEING
      struct etharp_q_entry *new_entry;
      /* allocate a new arp queue entry */
      new_entry = (struct etharp_q_entry *)memp_malloc(MEMP_ARP_QUEUE);
   31160:	010002c4 	movi	r4,11
   31164:	00223cc0 	call	223cc <memp_malloc>
   31168:	e0bffc15 	stw	r2,-16(fp)
      if (new_entry != NULL) {
   3116c:	e0bffc17 	ldw	r2,-16(fp)
   31170:	10002726 	beq	r2,zero,31210 <etharp_query+0x364>
        new_entry->next = 0;
   31174:	e0bffc17 	ldw	r2,-16(fp)
   31178:	10000015 	stw	zero,0(r2)
        new_entry->p = p;
   3117c:	e0bffc17 	ldw	r2,-16(fp)
   31180:	e0fff717 	ldw	r3,-36(fp)
   31184:	10c00115 	stw	r3,4(r2)
        if(arp_table[i].q != NULL) {
   31188:	e0bffb07 	ldb	r2,-20(fp)
   3118c:	00c001b4 	movhi	r3,6
   31190:	18c8dc04 	addi	r3,r3,9072
   31194:	10800524 	muli	r2,r2,20
   31198:	1885883a 	add	r2,r3,r2
   3119c:	10800017 	ldw	r2,0(r2)
   311a0:	10001226 	beq	r2,zero,311ec <etharp_query+0x340>
          /* queue was already existent, append the new entry to the end */
          struct etharp_q_entry *r;
          r = arp_table[i].q;
   311a4:	e0bffb07 	ldb	r2,-20(fp)
   311a8:	00c001b4 	movhi	r3,6
   311ac:	18c8dc04 	addi	r3,r3,9072
   311b0:	10800524 	muli	r2,r2,20
   311b4:	1885883a 	add	r2,r3,r2
   311b8:	10800017 	ldw	r2,0(r2)
   311bc:	e0bff915 	stw	r2,-28(fp)
          while (r->next != NULL) {
   311c0:	00000306 	br	311d0 <etharp_query+0x324>
            r = r->next;
   311c4:	e0bff917 	ldw	r2,-28(fp)
   311c8:	10800017 	ldw	r2,0(r2)
   311cc:	e0bff915 	stw	r2,-28(fp)
        new_entry->p = p;
        if(arp_table[i].q != NULL) {
          /* queue was already existent, append the new entry to the end */
          struct etharp_q_entry *r;
          r = arp_table[i].q;
          while (r->next != NULL) {
   311d0:	e0bff917 	ldw	r2,-28(fp)
   311d4:	10800017 	ldw	r2,0(r2)
   311d8:	103ffa1e 	bne	r2,zero,311c4 <etharp_query+0x318>
            r = r->next;
          }
          r->next = new_entry;
   311dc:	e0bff917 	ldw	r2,-28(fp)
   311e0:	e0fffc17 	ldw	r3,-16(fp)
   311e4:	10c00015 	stw	r3,0(r2)
   311e8:	00000706 	br	31208 <etharp_query+0x35c>
        } else {
          /* queue did not exist, first item in queue */
          arp_table[i].q = new_entry;
   311ec:	e0bffb07 	ldb	r2,-20(fp)
   311f0:	00c001b4 	movhi	r3,6
   311f4:	18c8dc04 	addi	r3,r3,9072
   311f8:	10800524 	muli	r2,r2,20
   311fc:	1885883a 	add	r2,r3,r2
   31200:	e0fffc17 	ldw	r3,-16(fp)
   31204:	10c00015 	stw	r3,0(r2)
        }
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
        result = ERR_OK;
   31208:	e03ff605 	stb	zero,-40(fp)
   3120c:	00000e06 	br	31248 <etharp_query+0x39c>
      } else {
        /* the pool MEMP_ARP_QUEUE is empty */
        pbuf_free(p);
   31210:	e13ff717 	ldw	r4,-36(fp)
   31214:	00237600 	call	23760 <pbuf_free>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
        result = ERR_MEM;
   31218:	00bfffc4 	movi	r2,-1
   3121c:	e0bff605 	stb	r2,-40(fp)
   31220:	00000906 	br	31248 <etharp_query+0x39c>
      arp_table[i].q = p;
      result = ERR_OK;
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
#endif /* ARP_QUEUEING */
    } else {
      ETHARP_STATS_INC(etharp.memerr);
   31224:	008001f4 	movhi	r2,7
   31228:	10ac6e04 	addi	r2,r2,-20040
   3122c:	10801217 	ldw	r2,72(r2)
   31230:	10c00044 	addi	r3,r2,1
   31234:	008001f4 	movhi	r2,7
   31238:	10ac6e04 	addi	r2,r2,-20040
   3123c:	10c01215 	stw	r3,72(r2)
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
      result = ERR_MEM;
   31240:	00bfffc4 	movi	r2,-1
   31244:	e0bff605 	stb	r2,-40(fp)
    }
  }
  return result;
   31248:	e0bff603 	ldbu	r2,-40(fp)
}
   3124c:	e037883a 	mov	sp,fp
   31250:	dfc00117 	ldw	ra,4(sp)
   31254:	df000017 	ldw	fp,0(sp)
   31258:	dec00204 	addi	sp,sp,8
   3125c:	f800283a 	ret

00031260 <etharp_raw>:
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const ip_addr_t *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const ip_addr_t *ipdst_addr,
           const u16_t opcode)
{
   31260:	defff504 	addi	sp,sp,-44
   31264:	dfc00a15 	stw	ra,40(sp)
   31268:	df000915 	stw	fp,36(sp)
   3126c:	df000904 	addi	fp,sp,36
   31270:	e13ffb15 	stw	r4,-20(fp)
   31274:	e17ffc15 	stw	r5,-16(fp)
   31278:	e1bffd15 	stw	r6,-12(fp)
   3127c:	e1fffe15 	stw	r7,-8(fp)
   31280:	e0800517 	ldw	r2,20(fp)
   31284:	e0bfff0d 	sth	r2,-4(fp)
  struct pbuf *p;
  err_t result = ERR_OK;
   31288:	e03ff705 	stb	zero,-36(fp)
#endif /* LWIP_AUTOIP */

  LWIP_ASSERT("netif != NULL", netif != NULL);

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
   3128c:	010000c4 	movi	r4,3
   31290:	01400b04 	movi	r5,44
   31294:	000d883a 	mov	r6,zero
   31298:	0022fa00 	call	22fa0 <pbuf_alloc>
   3129c:	e0bff815 	stw	r2,-32(fp)
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
   312a0:	e0bff817 	ldw	r2,-32(fp)
   312a4:	1000091e 	bne	r2,zero,312cc <etharp_raw+0x6c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
   312a8:	008001f4 	movhi	r2,7
   312ac:	10ac6e04 	addi	r2,r2,-20040
   312b0:	10801217 	ldw	r2,72(r2)
   312b4:	10c00044 	addi	r3,r2,1
   312b8:	008001f4 	movhi	r2,7
   312bc:	10ac6e04 	addi	r2,r2,-20040
   312c0:	10c01215 	stw	r3,72(r2)
    return ERR_MEM;
   312c4:	00bfffc4 	movi	r2,-1
   312c8:	00006f06 	br	31488 <etharp_raw+0x228>
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
              (p->len >= SIZEOF_ETHARP_PACKET));

  ethhdr = (struct eth_hdr *)p->payload;
   312cc:	e0bff817 	ldw	r2,-32(fp)
   312d0:	10800117 	ldw	r2,4(r2)
   312d4:	e0bff915 	stw	r2,-28(fp)
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
   312d8:	e0bff917 	ldw	r2,-28(fp)
   312dc:	10800404 	addi	r2,r2,16
   312e0:	e0bffa15 	stw	r2,-24(fp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
   312e4:	e0bfff0b 	ldhu	r2,-4(fp)
   312e8:	1004d23a 	srli	r2,r2,8
   312ec:	1007883a 	mov	r3,r2
   312f0:	e0bfff0b 	ldhu	r2,-4(fp)
   312f4:	1004923a 	slli	r2,r2,8
   312f8:	1884b03a 	or	r2,r3,r2
   312fc:	1007883a 	mov	r3,r2
   31300:	e0bffa17 	ldw	r2,-24(fp)
   31304:	193fffcc 	andi	r4,r3,65535
   31308:	21003fcc 	andi	r4,r4,255
   3130c:	11400183 	ldbu	r5,6(r2)
   31310:	280a703a 	and	r5,r5,zero
   31314:	2908b03a 	or	r4,r5,r4
   31318:	11000185 	stb	r4,6(r2)
   3131c:	18ffffcc 	andi	r3,r3,65535
   31320:	1806d23a 	srli	r3,r3,8
   31324:	18ffffcc 	andi	r3,r3,65535
   31328:	110001c3 	ldbu	r4,7(r2)
   3132c:	2008703a 	and	r4,r4,zero
   31330:	20c6b03a 	or	r3,r4,r3
   31334:	10c001c5 	stb	r3,7(r2)
   * 'sender IP address' MUST be sent using link-layer broadcast instead of
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
   31338:	e0bffa17 	ldw	r2,-24(fp)
   3133c:	10800204 	addi	r2,r2,8
   31340:	1009883a 	mov	r4,r2
   31344:	e17ffe17 	ldw	r5,-8(fp)
   31348:	01800184 	movi	r6,6
   3134c:	00041f00 	call	41f0 <memcpy>
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
   31350:	e0bffa17 	ldw	r2,-24(fp)
   31354:	10800484 	addi	r2,r2,18
   31358:	1009883a 	mov	r4,r2
   3135c:	e1400317 	ldw	r5,12(fp)
   31360:	01800184 	movi	r6,6
   31364:	00041f00 	call	41f0 <memcpy>
  /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
  ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
   31368:	e0bff917 	ldw	r2,-28(fp)
   3136c:	10800084 	addi	r2,r2,2
   31370:	1009883a 	mov	r4,r2
   31374:	e17ffd17 	ldw	r5,-12(fp)
   31378:	01800184 	movi	r6,6
   3137c:	00041f00 	call	41f0 <memcpy>
#endif /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
   31380:	e0bff917 	ldw	r2,-28(fp)
   31384:	10800204 	addi	r2,r2,8
   31388:	1009883a 	mov	r4,r2
   3138c:	e17ffc17 	ldw	r5,-16(fp)
   31390:	01800184 	movi	r6,6
   31394:	00041f00 	call	41f0 <memcpy>
  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
   31398:	e0bffa17 	ldw	r2,-24(fp)
   3139c:	10800384 	addi	r2,r2,14
   313a0:	1009883a 	mov	r4,r2
   313a4:	e1400217 	ldw	r5,8(fp)
   313a8:	01800104 	movi	r6,4
   313ac:	00041f00 	call	41f0 <memcpy>
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
   313b0:	e0bffa17 	ldw	r2,-24(fp)
   313b4:	10800604 	addi	r2,r2,24
   313b8:	1009883a 	mov	r4,r2
   313bc:	e1400417 	ldw	r5,16(fp)
   313c0:	01800104 	movi	r6,4
   313c4:	00041f00 	call	41f0 <memcpy>

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
   313c8:	e0bffa17 	ldw	r2,-24(fp)
   313cc:	10c00003 	ldbu	r3,0(r2)
   313d0:	1806703a 	and	r3,r3,zero
   313d4:	10c00005 	stb	r3,0(r2)
   313d8:	10c00043 	ldbu	r3,1(r2)
   313dc:	1806703a 	and	r3,r3,zero
   313e0:	18c00054 	ori	r3,r3,1
   313e4:	10c00045 	stb	r3,1(r2)
  hdr->proto = PP_HTONS(ETHTYPE_IP);
   313e8:	e0bffa17 	ldw	r2,-24(fp)
   313ec:	10c00083 	ldbu	r3,2(r2)
   313f0:	1806703a 	and	r3,r3,zero
   313f4:	18c00214 	ori	r3,r3,8
   313f8:	10c00085 	stb	r3,2(r2)
   313fc:	10c000c3 	ldbu	r3,3(r2)
   31400:	1806703a 	and	r3,r3,zero
   31404:	10c000c5 	stb	r3,3(r2)
  /* set hwlen and protolen */
  hdr->hwlen = ETHARP_HWADDR_LEN;
   31408:	e0bffa17 	ldw	r2,-24(fp)
   3140c:	00c00184 	movi	r3,6
   31410:	10c00105 	stb	r3,4(r2)
  hdr->protolen = sizeof(ip_addr_t);
   31414:	e0bffa17 	ldw	r2,-24(fp)
   31418:	00c00104 	movi	r3,4
   3141c:	10c00145 	stb	r3,5(r2)

  ethhdr->type = PP_HTONS(ETHTYPE_ARP);
   31420:	e0bff917 	ldw	r2,-28(fp)
   31424:	10c00383 	ldbu	r3,14(r2)
   31428:	1806703a 	and	r3,r3,zero
   3142c:	18c00214 	ori	r3,r3,8
   31430:	10c00385 	stb	r3,14(r2)
   31434:	10c003c3 	ldbu	r3,15(r2)
   31438:	1806703a 	and	r3,r3,zero
   3143c:	18c00194 	ori	r3,r3,6
   31440:	10c003c5 	stb	r3,15(r2)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
   31444:	e0bffb17 	ldw	r2,-20(fp)
   31448:	10800617 	ldw	r2,24(r2)
   3144c:	e13ffb17 	ldw	r4,-20(fp)
   31450:	e17ff817 	ldw	r5,-32(fp)
   31454:	103ee83a 	callr	r2
   31458:	e0bff705 	stb	r2,-36(fp)
  ETHARP_STATS_INC(etharp.xmit);
   3145c:	008001f4 	movhi	r2,7
   31460:	10ac6e04 	addi	r2,r2,-20040
   31464:	10800c17 	ldw	r2,48(r2)
   31468:	10c00044 	addi	r3,r2,1
   3146c:	008001f4 	movhi	r2,7
   31470:	10ac6e04 	addi	r2,r2,-20040
   31474:	10c00c15 	stw	r3,48(r2)
  /* free ARP query packet */
  pbuf_free(p);
   31478:	e13ff817 	ldw	r4,-32(fp)
   3147c:	00237600 	call	23760 <pbuf_free>
  p = NULL;
   31480:	e03ff815 	stw	zero,-32(fp)
  /* could not allocate pbuf for ARP request */

  return result;
   31484:	e0bff703 	ldbu	r2,-36(fp)
}
   31488:	e037883a 	mov	sp,fp
   3148c:	dfc00117 	ldw	ra,4(sp)
   31490:	df000017 	ldw	fp,0(sp)
   31494:	dec00204 	addi	sp,sp,8
   31498:	f800283a 	ret

0003149c <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
   3149c:	defff804 	addi	sp,sp,-32
   314a0:	dfc00715 	stw	ra,28(sp)
   314a4:	df000615 	stw	fp,24(sp)
   314a8:	df000604 	addi	fp,sp,24
   314ac:	e13ffe15 	stw	r4,-8(fp)
   314b0:	e17fff15 	stw	r5,-4(fp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
   314b4:	e0bffe17 	ldw	r2,-8(fp)
   314b8:	10c00cc4 	addi	r3,r2,51
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
   314bc:	e0bffe17 	ldw	r2,-8(fp)
   314c0:	10800cc4 	addi	r2,r2,51
   314c4:	e13ffe17 	ldw	r4,-8(fp)
   314c8:	21000104 	addi	r4,r4,4
 */
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
   314cc:	d9000015 	stw	r4,0(sp)
   314d0:	d1201704 	addi	r4,gp,-32676
   314d4:	d9000115 	stw	r4,4(sp)
   314d8:	e13fff17 	ldw	r4,-4(fp)
   314dc:	d9000215 	stw	r4,8(sp)
   314e0:	01000044 	movi	r4,1
   314e4:	d9000315 	stw	r4,12(sp)
   314e8:	e13ffe17 	ldw	r4,-8(fp)
   314ec:	180b883a 	mov	r5,r3
   314f0:	d1a01584 	addi	r6,gp,-32682
   314f4:	100f883a 	mov	r7,r2
   314f8:	00312600 	call	31260 <etharp_raw>
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
   314fc:	e037883a 	mov	sp,fp
   31500:	dfc00117 	ldw	ra,4(sp)
   31504:	df000017 	ldw	fp,0(sp)
   31508:	dec00204 	addi	sp,sp,8
   3150c:	f800283a 	ret

00031510 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
   31510:	defff904 	addi	sp,sp,-28
   31514:	dfc00615 	stw	ra,24(sp)
   31518:	df000515 	stw	fp,20(sp)
   3151c:	df000504 	addi	fp,sp,20
   31520:	e13ffe15 	stw	r4,-8(fp)
   31524:	e17fff15 	stw	r5,-4(fp)
  struct eth_hdr* ethhdr;
  u16_t type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN
  s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
   31528:	00800404 	movi	r2,16
   3152c:	e0bffb0d 	sth	r2,-20(fp)
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

  if (p->len <= SIZEOF_ETH_HDR) {
   31530:	e0bffe17 	ldw	r2,-8(fp)
   31534:	1080028b 	ldhu	r2,10(r2)
   31538:	10bfffcc 	andi	r2,r2,65535
   3153c:	10800468 	cmpgeui	r2,r2,17
   31540:	10000f1e 	bne	r2,zero,31580 <ethernet_input+0x70>
    /* a packet with only an ethernet header (or less) is not valid for us */
    ETHARP_STATS_INC(etharp.proterr);
   31544:	008001f4 	movhi	r2,7
   31548:	10ac6e04 	addi	r2,r2,-20040
   3154c:	10801417 	ldw	r2,80(r2)
   31550:	10c00044 	addi	r3,r2,1
   31554:	008001f4 	movhi	r2,7
   31558:	10ac6e04 	addi	r2,r2,-20040
   3155c:	10c01415 	stw	r3,80(r2)
    ETHARP_STATS_INC(etharp.drop);
   31560:	008001f4 	movhi	r2,7
   31564:	10ac6e04 	addi	r2,r2,-20040
   31568:	10800f17 	ldw	r2,60(r2)
   3156c:	10c00044 	addi	r3,r2,1
   31570:	008001f4 	movhi	r2,7
   31574:	10ac6e04 	addi	r2,r2,-20040
   31578:	10c00f15 	stw	r3,60(r2)
    goto free_and_return;
   3157c:	00006e06 	br	31738 <ethernet_input+0x228>
  }

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = (struct eth_hdr *)p->payload;
   31580:	e0bffe17 	ldw	r2,-8(fp)
   31584:	10800117 	ldw	r2,4(r2)
   31588:	e0bffc15 	stw	r2,-16(fp)
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  type = ethhdr->type;
   3158c:	e0bffc17 	ldw	r2,-16(fp)
   31590:	10c00383 	ldbu	r3,14(r2)
   31594:	108003c3 	ldbu	r2,15(r2)
   31598:	1004923a 	slli	r2,r2,8
   3159c:	10c4b03a 	or	r2,r2,r3
   315a0:	e0bffd0d 	sth	r2,-12(fp)

#if LWIP_ARP_FILTER_NETIF
  netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
   315a4:	e0bffc17 	ldw	r2,-16(fp)
   315a8:	10800083 	ldbu	r2,2(r2)
   315ac:	10803fcc 	andi	r2,r2,255
   315b0:	1080004c 	andi	r2,r2,1
   315b4:	10002226 	beq	r2,zero,31640 <ethernet_input+0x130>
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
   315b8:	e0bffc17 	ldw	r2,-16(fp)
   315bc:	10800083 	ldbu	r2,2(r2)
   315c0:	10803fcc 	andi	r2,r2,255
   315c4:	10800058 	cmpnei	r2,r2,1
   315c8:	1000101e 	bne	r2,zero,3160c <ethernet_input+0xfc>
      if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
   315cc:	e0bffc17 	ldw	r2,-16(fp)
   315d0:	108000c3 	ldbu	r2,3(r2)
   315d4:	10803fcc 	andi	r2,r2,255
   315d8:	1000191e 	bne	r2,zero,31640 <ethernet_input+0x130>
          (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
   315dc:	e0bffc17 	ldw	r2,-16(fp)
   315e0:	10800103 	ldbu	r2,4(r2)
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
      if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
   315e4:	10803fcc 	andi	r2,r2,255
   315e8:	10801798 	cmpnei	r2,r2,94
   315ec:	1000141e 	bne	r2,zero,31640 <ethernet_input+0x130>
          (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
        /* mark the pbuf as link-layer multicast */
        p->flags |= PBUF_FLAG_LLMCAST;
   315f0:	e0bffe17 	ldw	r2,-8(fp)
   315f4:	10800343 	ldbu	r2,13(r2)
   315f8:	10800414 	ori	r2,r2,16
   315fc:	1007883a 	mov	r3,r2
   31600:	e0bffe17 	ldw	r2,-8(fp)
   31604:	10c00345 	stb	r3,13(r2)
   31608:	00000d06 	br	31640 <ethernet_input+0x130>
      }
    } else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
   3160c:	e0bffc17 	ldw	r2,-16(fp)
   31610:	10800084 	addi	r2,r2,2
   31614:	1009883a 	mov	r4,r2
   31618:	d1601584 	addi	r5,gp,-32682
   3161c:	01800184 	movi	r6,6
   31620:	003f2240 	call	3f224 <memcmp>
   31624:	1000061e 	bne	r2,zero,31640 <ethernet_input+0x130>
      /* mark the pbuf as link-layer broadcast */
      p->flags |= PBUF_FLAG_LLBCAST;
   31628:	e0bffe17 	ldw	r2,-8(fp)
   3162c:	10800343 	ldbu	r2,13(r2)
   31630:	10800214 	ori	r2,r2,8
   31634:	1007883a 	mov	r3,r2
   31638:	e0bffe17 	ldw	r2,-8(fp)
   3163c:	10c00345 	stb	r3,13(r2)
    }
  }

  switch (type) {
   31640:	e0bffd0b 	ldhu	r2,-12(fp)
   31644:	10c00220 	cmpeqi	r3,r2,8
   31648:	1800031e 	bne	r3,zero,31658 <ethernet_input+0x148>
   3164c:	10818220 	cmpeqi	r2,r2,1544
   31650:	1000171e 	bne	r2,zero,316b0 <ethernet_input+0x1a0>
   31654:	00002206 	br	316e0 <ethernet_input+0x1d0>
#if LWIP_ARP
    /* IP packet? */
    case PP_HTONS(ETHTYPE_IP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
   31658:	e0bfff17 	ldw	r2,-4(fp)
   3165c:	10800e43 	ldbu	r2,57(r2)
   31660:	10803fcc 	andi	r2,r2,255
   31664:	1080080c 	andi	r2,r2,32
   31668:	10002e26 	beq	r2,zero,31724 <ethernet_input+0x214>
        goto free_and_return;
      }
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
   3166c:	e13fff17 	ldw	r4,-4(fp)
   31670:	e17ffe17 	ldw	r5,-8(fp)
   31674:	00306480 	call	30648 <etharp_ip_input>
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -ip_hdr_offset)) {
   31678:	e0bffb0b 	ldhu	r2,-20(fp)
   3167c:	0085c83a 	sub	r2,zero,r2
   31680:	10bfffcc 	andi	r2,r2,65535
   31684:	10a0001c 	xori	r2,r2,32768
   31688:	10a00004 	addi	r2,r2,-32768
   3168c:	e13ffe17 	ldw	r4,-8(fp)
   31690:	100b883a 	mov	r5,r2
   31694:	00235b00 	call	235b0 <pbuf_header>
   31698:	10803fcc 	andi	r2,r2,255
   3169c:	1000231e 	bne	r2,zero,3172c <ethernet_input+0x21c>
        LWIP_ASSERT("Can't move over header in packet", 0);
        goto free_and_return;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
   316a0:	e13ffe17 	ldw	r4,-8(fp)
   316a4:	e17fff17 	ldw	r5,-4(fp)
   316a8:	001edc40 	call	1edc4 <ip_input>
      }
      break;
   316ac:	00001b06 	br	3171c <ethernet_input+0x20c>
      
    case PP_HTONS(ETHTYPE_ARP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
   316b0:	e0bfff17 	ldw	r2,-4(fp)
   316b4:	10800e43 	ldbu	r2,57(r2)
   316b8:	10803fcc 	andi	r2,r2,255
   316bc:	1080080c 	andi	r2,r2,32
   316c0:	10001c26 	beq	r2,zero,31734 <ethernet_input+0x224>
        goto free_and_return;
      }
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
   316c4:	e0bfff17 	ldw	r2,-4(fp)
   316c8:	10800cc4 	addi	r2,r2,51
   316cc:	e13fff17 	ldw	r4,-4(fp)
   316d0:	100b883a 	mov	r5,r2
   316d4:	e1bffe17 	ldw	r6,-8(fp)
   316d8:	00307280 	call	30728 <etharp_arp_input>
      break;
   316dc:	00000f06 	br	3171c <ethernet_input+0x20c>
      pppoe_data_input(netif, p);
      break;
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
   316e0:	008001f4 	movhi	r2,7
   316e4:	10ac6e04 	addi	r2,r2,-20040
   316e8:	10801417 	ldw	r2,80(r2)
   316ec:	10c00044 	addi	r3,r2,1
   316f0:	008001f4 	movhi	r2,7
   316f4:	10ac6e04 	addi	r2,r2,-20040
   316f8:	10c01415 	stw	r3,80(r2)
      ETHARP_STATS_INC(etharp.drop);
   316fc:	008001f4 	movhi	r2,7
   31700:	10ac6e04 	addi	r2,r2,-20040
   31704:	10800f17 	ldw	r2,60(r2)
   31708:	10c00044 	addi	r3,r2,1
   3170c:	008001f4 	movhi	r2,7
   31710:	10ac6e04 	addi	r2,r2,-20040
   31714:	10c00f15 	stw	r3,60(r2)
      goto free_and_return;
   31718:	00000706 	br	31738 <ethernet_input+0x228>
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
   3171c:	0005883a 	mov	r2,zero
   31720:	00000806 	br	31744 <ethernet_input+0x234>
  switch (type) {
#if LWIP_ARP
    /* IP packet? */
    case PP_HTONS(ETHTYPE_IP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
        goto free_and_return;
   31724:	0001883a 	nop
   31728:	00000306 	br	31738 <ethernet_input+0x228>
      etharp_ip_input(netif, p);
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -ip_hdr_offset)) {
        LWIP_ASSERT("Can't move over header in packet", 0);
        goto free_and_return;
   3172c:	0001883a 	nop
   31730:	00000106 	br	31738 <ethernet_input+0x228>
      }
      break;
      
    case PP_HTONS(ETHTYPE_ARP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
        goto free_and_return;
   31734:	0001883a 	nop
  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;

free_and_return:
  pbuf_free(p);
   31738:	e13ffe17 	ldw	r4,-8(fp)
   3173c:	00237600 	call	23760 <pbuf_free>
  return ERR_OK;
   31740:	0005883a 	mov	r2,zero
}
   31744:	e037883a 	mov	sp,fp
   31748:	dfc00117 	ldw	ra,4(sp)
   3174c:	df000017 	ldw	fp,0(sp)
   31750:	dec00204 	addi	sp,sp,8
   31754:	f800283a 	ret

00031758 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
   31758:	defffd04 	addi	sp,sp,-12
   3175c:	dfc00215 	stw	ra,8(sp)
   31760:	df000115 	stw	fp,4(sp)
   31764:	df000104 	addi	fp,sp,4
   31768:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
   3176c:	e13fff17 	ldw	r4,-4(fp)
   31770:	01400134 	movhi	r5,4
   31774:	2955c604 	addi	r5,r5,22296
   31778:	003c80c0 	call	3c80c <alt_dev_llist_insert>
}
   3177c:	e037883a 	mov	sp,fp
   31780:	dfc00117 	ldw	ra,4(sp)
   31784:	df000017 	ldw	fp,0(sp)
   31788:	dec00204 	addi	sp,sp,8
   3178c:	f800283a 	ret

00031790 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
   31790:	defffd04 	addi	sp,sp,-12
   31794:	dfc00215 	stw	ra,8(sp)
   31798:	df000115 	stw	fp,4(sp)
   3179c:	df000104 	addi	fp,sp,4
   317a0:	e13fff15 	stw	r4,-4(fp)
    ALTERA_VIC_IRQ_INIT ( VIC_0, vic_0);
   317a4:	01000134 	movhi	r4,4
   317a8:	210fbb04 	addi	r4,r4,16108
   317ac:	003bbcc0 	call	3bbcc <alt_vic_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
   317b0:	00802034 	movhi	r2,128
   317b4:	10800044 	addi	r2,r2,1
   317b8:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
   317bc:	e037883a 	mov	sp,fp
   317c0:	dfc00117 	ldw	ra,4(sp)
   317c4:	df000017 	ldw	fp,0(sp)
   317c8:	dec00204 	addi	sp,sp,8
   317cc:	f800283a 	ret

000317d0 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
   317d0:	defffe04 	addi	sp,sp,-8
   317d4:	dfc00115 	stw	ra,4(sp)
   317d8:	df000015 	stw	fp,0(sp)
   317dc:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( SYS_CLK_TIMER, sys_clk_timer);
   317e0:	01020034 	movhi	r4,2048
   317e4:	21005804 	addi	r4,r4,352
   317e8:	000b883a 	mov	r5,zero
   317ec:	000d883a 	mov	r6,zero
   317f0:	01c0fa04 	movi	r7,1000
   317f4:	0035eb00 	call	35eb0 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMER_5, timer_5);
    ALTERA_AVALON_TIMER_INIT ( TIMER_6, timer_6);
    ALTERA_AVALON_TIMER_INIT ( TIMER_7, timer_7);
    ALTERA_AVALON_TIMER_INIT ( TIMER_8, timer_8);
    ALTERA_AVALON_TIMER_INIT ( TIMER_9, timer_9);
    ALTERA_AVALON_CFI_FLASH_INIT ( CFI_FLASH, cfi_flash);
   317f8:	01000134 	movhi	r4,4
   317fc:	210fe204 	addi	r4,r4,16264
   31800:	00319180 	call	31918 <alt_flash_cfi_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
   31804:	01000134 	movhi	r4,4
   31808:	21102204 	addi	r4,r4,16520
   3180c:	000b883a 	mov	r5,zero
   31810:	01800044 	movi	r6,1
   31814:	00337080 	call	33708 <altera_avalon_jtag_uart_init>
   31818:	01000134 	movhi	r4,4
   3181c:	21101804 	addi	r4,r4,16480
   31820:	00317580 	call	31758 <alt_dev_reg>
    ALTERA_AVALON_LCD_16207_INIT ( LCD, lcd);
   31824:	01000134 	movhi	r4,4
   31828:	21143c04 	addi	r4,r4,20720
   3182c:	0034f0c0 	call	34f0c <altera_avalon_lcd_16207_init>
   31830:	01000134 	movhi	r4,4
   31834:	21143204 	addi	r4,r4,20680
   31838:	00317580 	call	31758 <alt_dev_reg>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
   3183c:	01000134 	movhi	r4,4
   31840:	21147b04 	addi	r4,r4,20972
   31844:	000b883a 	mov	r5,zero
   31848:	01800304 	movi	r6,12
   3184c:	0035d6c0 	call	35d6c <alt_avalon_sgdma_init>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TX, sgdma_tx);
   31850:	01000134 	movhi	r4,4
   31854:	21148704 	addi	r4,r4,21020
   31858:	000b883a 	mov	r5,zero
   3185c:	01800344 	movi	r6,13
   31860:	0035d6c0 	call	35d6c <alt_avalon_sgdma_init>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, sysid);
   31864:	0001883a 	nop
    ALTERA_AVALON_UART_INIT ( RS232, rs232);
   31868:	01000134 	movhi	r4,4
   3186c:	21149d04 	addi	r4,r4,21108
   31870:	000b883a 	mov	r5,zero
   31874:	018001c4 	movi	r6,7
   31878:	003afd80 	call	3afd8 <altera_avalon_uart_init>
   3187c:	01000134 	movhi	r4,4
   31880:	21149304 	addi	r4,r4,21068
   31884:	00317580 	call	31758 <alt_dev_reg>
    ALTERA_AVALON_UART_INIT ( UART_0, uart_0);
   31888:	01000134 	movhi	r4,4
   3188c:	2114d004 	addi	r4,r4,21312
   31890:	000b883a 	mov	r5,zero
   31894:	018000c4 	movi	r6,3
   31898:	003afd80 	call	3afd8 <altera_avalon_uart_init>
   3189c:	01000134 	movhi	r4,4
   318a0:	2114c604 	addi	r4,r4,21272
   318a4:	00317580 	call	31758 <alt_dev_reg>
    ALTERA_AVALON_UART_INIT ( UART_1, uart_1);
   318a8:	01000134 	movhi	r4,4
   318ac:	21150304 	addi	r4,r4,21516
   318b0:	000b883a 	mov	r5,zero
   318b4:	01800104 	movi	r6,4
   318b8:	003afd80 	call	3afd8 <altera_avalon_uart_init>
   318bc:	01000134 	movhi	r4,4
   318c0:	2114f904 	addi	r4,r4,21476
   318c4:	00317580 	call	31758 <alt_dev_reg>
    ALTERA_ETH_TSE_INIT ( TSE_MAC, tse_mac);
   318c8:	0001883a 	nop
}
   318cc:	e037883a 	mov	sp,fp
   318d0:	dfc00117 	ldw	ra,4(sp)
   318d4:	df000017 	ldw	fp,0(sp)
   318d8:	dec00204 	addi	sp,sp,8
   318dc:	f800283a 	ret

000318e0 <alt_flash_device_register>:

typedef struct alt_flash_dev alt_flash_dev; 
typedef alt_flash_dev alt_flash_fd;

static ALT_INLINE int alt_flash_device_register( alt_flash_fd* fd)
{
   318e0:	defffd04 	addi	sp,sp,-12
   318e4:	dfc00215 	stw	ra,8(sp)
   318e8:	df000115 	stw	fp,4(sp)
   318ec:	df000104 	addi	fp,sp,4
   318f0:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_flash_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) fd, &alt_flash_dev_list);
   318f4:	e13fff17 	ldw	r4,-4(fp)
   318f8:	01400134 	movhi	r5,4
   318fc:	2955da04 	addi	r5,r5,22376
   31900:	003c80c0 	call	3c80c <alt_dev_llist_insert>
}
   31904:	e037883a 	mov	sp,fp
   31908:	dfc00117 	ldw	ra,4(sp)
   3190c:	df000017 	ldw	fp,0(sp)
   31910:	dec00204 	addi	sp,sp,8
   31914:	f800283a 	ret

00031918 <alt_flash_cfi_init>:
 * Read the CFI table and fill out the alt_flash_cfi_dev structure with all the 
 * information we need to program the flash.
 * 
 */
int alt_flash_cfi_init( alt_flash_cfi_dev* flash  )
{
   31918:	defffc04 	addi	sp,sp,-16
   3191c:	dfc00315 	stw	ra,12(sp)
   31920:	df000215 	stw	fp,8(sp)
   31924:	df000204 	addi	fp,sp,8
   31928:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
   3192c:	e03ffe15 	stw	zero,-8(fp)
 
  ret_code = alt_read_cfi_width( flash );
   31930:	e13fff17 	ldw	r4,-4(fp)
   31934:	0032d600 	call	32d60 <alt_read_cfi_width>
   31938:	e0bffe15 	stw	r2,-8(fp)
  
  if (!ret_code)
   3193c:	e0bffe17 	ldw	r2,-8(fp)
   31940:	1000031e 	bne	r2,zero,31950 <alt_flash_cfi_init+0x38>
    ret_code = alt_set_flash_width_func( flash );
   31944:	e13fff17 	ldw	r4,-4(fp)
   31948:	00324b80 	call	324b8 <alt_set_flash_width_func>
   3194c:	e0bffe15 	stw	r2,-8(fp)
  
  if (!ret_code)
   31950:	e0bffe17 	ldw	r2,-8(fp)
   31954:	1000031e 	bne	r2,zero,31964 <alt_flash_cfi_init+0x4c>
    ret_code = alt_read_cfi_table( flash );
   31958:	e13fff17 	ldw	r4,-4(fp)
   3195c:	00327980 	call	32798 <alt_read_cfi_table>
   31960:	e0bffe15 	stw	r2,-8(fp)

  if (!ret_code) 
   31964:	e0bffe17 	ldw	r2,-8(fp)
   31968:	1000031e 	bne	r2,zero,31978 <alt_flash_cfi_init+0x60>
    ret_code = alt_set_flash_algorithm_func( flash);
   3196c:	e13fff17 	ldw	r4,-4(fp)
   31970:	003267c0 	call	3267c <alt_set_flash_algorithm_func>
   31974:	e0bffe15 	stw	r2,-8(fp)

  /*
  *  Register this device as a valid flash device type
  */ 
  if (!ret_code)
   31978:	e0bffe17 	ldw	r2,-8(fp)
   3197c:	1000041e 	bne	r2,zero,31990 <alt_flash_cfi_init+0x78>
    ret_code = alt_flash_device_register(&(flash->dev));
   31980:	e0bfff17 	ldw	r2,-4(fp)
   31984:	1009883a 	mov	r4,r2
   31988:	00318e00 	call	318e0 <alt_flash_device_register>
   3198c:	e0bffe15 	stw	r2,-8(fp)
 
  return ret_code;
   31990:	e0bffe17 	ldw	r2,-8(fp)
}
   31994:	e037883a 	mov	sp,fp
   31998:	dfc00117 	ldw	ra,4(sp)
   3199c:	df000017 	ldw	fp,0(sp)
   319a0:	dec00204 	addi	sp,sp,8
   319a4:	f800283a 	ret

000319a8 <alt_flash_cfi_write>:
 * large buffer to tie up in our programming library, when not all users will 
 * want that functionality.
 */
 int alt_flash_cfi_write( alt_flash_dev* flash_info, int offset, 
                          const void* src_addr, int length )
 {
   319a8:	defff104 	addi	sp,sp,-60
   319ac:	dfc00e15 	stw	ra,56(sp)
   319b0:	df000d15 	stw	fp,52(sp)
   319b4:	df000d04 	addi	fp,sp,52
   319b8:	e13ffc15 	stw	r4,-16(fp)
   319bc:	e17ffd15 	stw	r5,-12(fp)
   319c0:	e1bffe15 	stw	r6,-8(fp)
   319c4:	e1ffff15 	stw	r7,-4(fp)
  int         ret_code = 0;
   319c8:	e03ff415 	stw	zero,-48(fp)
  int         i,j;
  int         data_to_write;
  int         full_length = length;
   319cc:	e0bfff17 	ldw	r2,-4(fp)
   319d0:	e0bff815 	stw	r2,-32(fp)
  int         current_offset;
  int         start_offset = offset;
   319d4:	e0bffd17 	ldw	r2,-12(fp)
   319d8:	e0bff915 	stw	r2,-28(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
   319dc:	e0bffc17 	ldw	r2,-16(fp)
   319e0:	e0bffa15 	stw	r2,-24(fp)

  /*
   * First and foremost which sectors are affected?
   */   
  for(i=0;i<flash->dev.number_of_regions;i++)
   319e4:	e03ff515 	stw	zero,-44(fp)
   319e8:	00008806 	br	31c0c <alt_flash_cfi_write+0x264>
  {
    /* Is it in this erase block region?*/
    if((offset >= flash->dev.region_info[i].offset) &&
   319ec:	e0fffa17 	ldw	r3,-24(fp)
   319f0:	e0bff517 	ldw	r2,-44(fp)
   319f4:	1004913a 	slli	r2,r2,4
   319f8:	1885883a 	add	r2,r3,r2
   319fc:	10800d04 	addi	r2,r2,52
   31a00:	10800017 	ldw	r2,0(r2)
   31a04:	e0fffd17 	ldw	r3,-12(fp)
   31a08:	18807d16 	blt	r3,r2,31c00 <alt_flash_cfi_write+0x258>
      (offset < (flash->dev.region_info[i].offset + 
   31a0c:	e0fffa17 	ldw	r3,-24(fp)
   31a10:	e0bff517 	ldw	r2,-44(fp)
   31a14:	1004913a 	slli	r2,r2,4
   31a18:	1885883a 	add	r2,r3,r2
   31a1c:	10800d04 	addi	r2,r2,52
   31a20:	10c00017 	ldw	r3,0(r2)
      flash->dev.region_info[i].region_size)))
   31a24:	e13ffa17 	ldw	r4,-24(fp)
   31a28:	e0bff517 	ldw	r2,-44(fp)
   31a2c:	1004913a 	slli	r2,r2,4
   31a30:	2085883a 	add	r2,r4,r2
   31a34:	10800e04 	addi	r2,r2,56
   31a38:	10800017 	ldw	r2,0(r2)
   */   
  for(i=0;i<flash->dev.number_of_regions;i++)
  {
    /* Is it in this erase block region?*/
    if((offset >= flash->dev.region_info[i].offset) &&
      (offset < (flash->dev.region_info[i].offset + 
   31a3c:	1885883a 	add	r2,r3,r2
   * First and foremost which sectors are affected?
   */   
  for(i=0;i<flash->dev.number_of_regions;i++)
  {
    /* Is it in this erase block region?*/
    if((offset >= flash->dev.region_info[i].offset) &&
   31a40:	e0fffd17 	ldw	r3,-12(fp)
   31a44:	18806e0e 	bge	r3,r2,31c00 <alt_flash_cfi_write+0x258>
      (offset < (flash->dev.region_info[i].offset + 
      flash->dev.region_info[i].region_size)))
    {
      current_offset = flash->dev.region_info[i].offset;
   31a48:	e0fffa17 	ldw	r3,-24(fp)
   31a4c:	e0bff517 	ldw	r2,-44(fp)
   31a50:	1004913a 	slli	r2,r2,4
   31a54:	1885883a 	add	r2,r3,r2
   31a58:	10800d04 	addi	r2,r2,52
   31a5c:	10800017 	ldw	r2,0(r2)
   31a60:	e0bff715 	stw	r2,-36(fp)

      for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
   31a64:	e03ff615 	stw	zero,-40(fp)
   31a68:	00005d06 	br	31be0 <alt_flash_cfi_write+0x238>
      {
        if ((offset >= current_offset ) && 
   31a6c:	e0fffd17 	ldw	r3,-12(fp)
   31a70:	e0bff717 	ldw	r2,-36(fp)
   31a74:	18804e16 	blt	r3,r2,31bb0 <alt_flash_cfi_write+0x208>
            (offset < (current_offset + 
            flash->dev.region_info[i].block_size)))
   31a78:	e0fffa17 	ldw	r3,-24(fp)
   31a7c:	e0bff517 	ldw	r2,-44(fp)
   31a80:	10800104 	addi	r2,r2,4
   31a84:	1004913a 	slli	r2,r2,4
   31a88:	1885883a 	add	r2,r3,r2
   31a8c:	10c00017 	ldw	r3,0(r2)
      current_offset = flash->dev.region_info[i].offset;

      for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
      {
        if ((offset >= current_offset ) && 
            (offset < (current_offset + 
   31a90:	e0bff717 	ldw	r2,-36(fp)
   31a94:	1885883a 	add	r2,r3,r2
    {
      current_offset = flash->dev.region_info[i].offset;

      for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
      {
        if ((offset >= current_offset ) && 
   31a98:	e0fffd17 	ldw	r3,-12(fp)
   31a9c:	1880440e 	bge	r3,r2,31bb0 <alt_flash_cfi_write+0x208>
        {
          /*
           * Check if the contents of the block are different
           * from the data we wish to put there
           */
          data_to_write = ( current_offset + flash->dev.region_info[i].block_size 
   31aa0:	e0fffa17 	ldw	r3,-24(fp)
   31aa4:	e0bff517 	ldw	r2,-44(fp)
   31aa8:	10800104 	addi	r2,r2,4
   31aac:	1004913a 	slli	r2,r2,4
   31ab0:	1885883a 	add	r2,r3,r2
   31ab4:	10c00017 	ldw	r3,0(r2)
   31ab8:	e0bff717 	ldw	r2,-36(fp)
   31abc:	1887883a 	add	r3,r3,r2
   31ac0:	e0bffd17 	ldw	r2,-12(fp)
   31ac4:	1885c83a 	sub	r2,r3,r2
   31ac8:	e0bffb15 	stw	r2,-20(fp)
                            - offset); 
          data_to_write = MIN(data_to_write, length);
   31acc:	e0fffb17 	ldw	r3,-20(fp)
   31ad0:	e0bfff17 	ldw	r2,-4(fp)
   31ad4:	1880010e 	bge	r3,r2,31adc <alt_flash_cfi_write+0x134>
   31ad8:	1805883a 	mov	r2,r3
   31adc:	e0bffb15 	stw	r2,-20(fp)
          if(memcmp(src_addr, 
                    (alt_u8*)flash->dev.base_addr+offset,
   31ae0:	e0bffa17 	ldw	r2,-24(fp)
   31ae4:	10c00a17 	ldw	r3,40(r2)
           * from the data we wish to put there
           */
          data_to_write = ( current_offset + flash->dev.region_info[i].block_size 
                            - offset); 
          data_to_write = MIN(data_to_write, length);
          if(memcmp(src_addr, 
   31ae8:	e0bffd17 	ldw	r2,-12(fp)
   31aec:	1887883a 	add	r3,r3,r2
   31af0:	e0bffb17 	ldw	r2,-20(fp)
   31af4:	e13ffe17 	ldw	r4,-8(fp)
   31af8:	180b883a 	mov	r5,r3
   31afc:	100d883a 	mov	r6,r2
   31b00:	003f2240 	call	3f224 <memcmp>
   31b04:	10001426 	beq	r2,zero,31b58 <alt_flash_cfi_write+0x1b0>
                    (alt_u8*)flash->dev.base_addr+offset,
                    data_to_write))
          {
            ret_code = (*flash->dev.erase_block)( &flash->dev, current_offset);
   31b08:	e0bffa17 	ldw	r2,-24(fp)
   31b0c:	10c00817 	ldw	r3,32(r2)
   31b10:	e0bffa17 	ldw	r2,-24(fp)
   31b14:	1009883a 	mov	r4,r2
   31b18:	e17ff717 	ldw	r5,-36(fp)
   31b1c:	183ee83a 	callr	r3
   31b20:	e0bff415 	stw	r2,-48(fp)

            if (!ret_code)
   31b24:	e0bff417 	ldw	r2,-48(fp)
   31b28:	10000b1e 	bne	r2,zero,31b58 <alt_flash_cfi_write+0x1b0>
            {
              ret_code = (*flash->dev.write_block)( 
   31b2c:	e0bffa17 	ldw	r2,-24(fp)
   31b30:	10c00917 	ldw	r3,36(r2)
   31b34:	e0bffa17 	ldw	r2,-24(fp)
   31b38:	e13ffb17 	ldw	r4,-20(fp)
   31b3c:	d9000015 	stw	r4,0(sp)
   31b40:	1009883a 	mov	r4,r2
   31b44:	e17ff717 	ldw	r5,-36(fp)
   31b48:	e1bffd17 	ldw	r6,-12(fp)
   31b4c:	e1fffe17 	ldw	r7,-8(fp)
   31b50:	183ee83a 	callr	r3
   31b54:	e0bff415 	stw	r2,-48(fp)
                                                  data_to_write);
            }
          }    
    
          /* Was this the last block? */    
          if ((length == data_to_write) || ret_code)
   31b58:	e0ffff17 	ldw	r3,-4(fp)
   31b5c:	e0bffb17 	ldw	r2,-20(fp)
   31b60:	18802e26 	beq	r3,r2,31c1c <alt_flash_cfi_write+0x274>
   31b64:	e0bff417 	ldw	r2,-48(fp)
   31b68:	10002c1e 	bne	r2,zero,31c1c <alt_flash_cfi_write+0x274>
          {
            goto finished;
          }
          
          length -= data_to_write;
   31b6c:	e0ffff17 	ldw	r3,-4(fp)
   31b70:	e0bffb17 	ldw	r2,-20(fp)
   31b74:	1885c83a 	sub	r2,r3,r2
   31b78:	e0bfff15 	stw	r2,-4(fp)
          offset = current_offset + flash->dev.region_info[i].block_size;
   31b7c:	e0fffa17 	ldw	r3,-24(fp)
   31b80:	e0bff517 	ldw	r2,-44(fp)
   31b84:	10800104 	addi	r2,r2,4
   31b88:	1004913a 	slli	r2,r2,4
   31b8c:	1885883a 	add	r2,r3,r2
   31b90:	10c00017 	ldw	r3,0(r2)
   31b94:	e0bff717 	ldw	r2,-36(fp)
   31b98:	1885883a 	add	r2,r3,r2
   31b9c:	e0bffd15 	stw	r2,-12(fp)
          src_addr = (alt_u8*)src_addr + data_to_write;
   31ba0:	e0bffb17 	ldw	r2,-20(fp)
   31ba4:	e0fffe17 	ldw	r3,-8(fp)
   31ba8:	1885883a 	add	r2,r3,r2
   31bac:	e0bffe15 	stw	r2,-8(fp)
        }
        current_offset += flash->dev.region_info[i].block_size;
   31bb0:	e0fffa17 	ldw	r3,-24(fp)
   31bb4:	e0bff517 	ldw	r2,-44(fp)
   31bb8:	10800104 	addi	r2,r2,4
   31bbc:	1004913a 	slli	r2,r2,4
   31bc0:	1885883a 	add	r2,r3,r2
   31bc4:	10800017 	ldw	r2,0(r2)
   31bc8:	e0fff717 	ldw	r3,-36(fp)
   31bcc:	1885883a 	add	r2,r3,r2
   31bd0:	e0bff715 	stw	r2,-36(fp)
      (offset < (flash->dev.region_info[i].offset + 
      flash->dev.region_info[i].region_size)))
    {
      current_offset = flash->dev.region_info[i].offset;

      for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
   31bd4:	e0bff617 	ldw	r2,-40(fp)
   31bd8:	10800044 	addi	r2,r2,1
   31bdc:	e0bff615 	stw	r2,-40(fp)
   31be0:	e0fffa17 	ldw	r3,-24(fp)
   31be4:	e0bff517 	ldw	r2,-44(fp)
   31be8:	1004913a 	slli	r2,r2,4
   31bec:	1885883a 	add	r2,r3,r2
   31bf0:	10800f04 	addi	r2,r2,60
   31bf4:	10800017 	ldw	r2,0(r2)
   31bf8:	e0fff617 	ldw	r3,-40(fp)
   31bfc:	18bf9b16 	blt	r3,r2,31a6c <alt_flash_cfi_write+0xc4>
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;

  /*
   * First and foremost which sectors are affected?
   */   
  for(i=0;i<flash->dev.number_of_regions;i++)
   31c00:	e0bff517 	ldw	r2,-44(fp)
   31c04:	10800044 	addi	r2,r2,1
   31c08:	e0bff515 	stw	r2,-44(fp)
   31c0c:	e0bffa17 	ldw	r2,-24(fp)
   31c10:	10800c17 	ldw	r2,48(r2)
   31c14:	e0fff517 	ldw	r3,-44(fp)
   31c18:	18bf7416 	blt	r3,r2,319ec <alt_flash_cfi_write+0x44>
      }     
    } 
  }
finished:    

  alt_dcache_flush((alt_u8*)flash->dev.base_addr+start_offset, full_length);
   31c1c:	e0bffa17 	ldw	r2,-24(fp)
   31c20:	10c00a17 	ldw	r3,40(r2)
   31c24:	e0bff917 	ldw	r2,-28(fp)
   31c28:	1887883a 	add	r3,r3,r2
   31c2c:	e0bff817 	ldw	r2,-32(fp)
   31c30:	1809883a 	mov	r4,r3
   31c34:	100b883a 	mov	r5,r2
   31c38:	003c77c0 	call	3c77c <alt_dcache_flush>
  return ret_code;
   31c3c:	e0bff417 	ldw	r2,-48(fp)
}
   31c40:	e037883a 	mov	sp,fp
   31c44:	dfc00117 	ldw	ra,4(sp)
   31c48:	df000017 	ldw	fp,0(sp)
   31c4c:	dec00204 	addi	sp,sp,8
   31c50:	f800283a 	ret

00031c54 <alt_flash_cfi_get_info>:
 * 
 *  Pass the table of erase blocks to the user
 */
int alt_flash_cfi_get_info( alt_flash_fd* fd, flash_region** info, 
                            int* number_of_regions)
{
   31c54:	defffa04 	addi	sp,sp,-24
   31c58:	df000515 	stw	fp,20(sp)
   31c5c:	df000504 	addi	fp,sp,20
   31c60:	e13ffd15 	stw	r4,-12(fp)
   31c64:	e17ffe15 	stw	r5,-8(fp)
   31c68:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
   31c6c:	e03ffb15 	stw	zero,-20(fp)
  alt_flash_dev* flash = (alt_flash_dev*)fd;
   31c70:	e0bffd17 	ldw	r2,-12(fp)
   31c74:	e0bffc15 	stw	r2,-16(fp)

  *number_of_regions = flash->number_of_regions;
   31c78:	e0bffc17 	ldw	r2,-16(fp)
   31c7c:	10c00c17 	ldw	r3,48(r2)
   31c80:	e0bfff17 	ldw	r2,-4(fp)
   31c84:	10c00015 	stw	r3,0(r2)

  if (!flash->number_of_regions)
   31c88:	e0bffc17 	ldw	r2,-16(fp)
   31c8c:	10800c17 	ldw	r2,48(r2)
   31c90:	1000031e 	bne	r2,zero,31ca0 <alt_flash_cfi_get_info+0x4c>
  {
    ret_code = -EIO;
   31c94:	00bffec4 	movi	r2,-5
   31c98:	e0bffb15 	stw	r2,-20(fp)
   31c9c:	00000b06 	br	31ccc <alt_flash_cfi_get_info+0x78>
  }
  else if (flash->number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
   31ca0:	e0bffc17 	ldw	r2,-16(fp)
   31ca4:	10800c17 	ldw	r2,48(r2)
   31ca8:	10800250 	cmplti	r2,r2,9
   31cac:	1000031e 	bne	r2,zero,31cbc <alt_flash_cfi_get_info+0x68>
  {
    ret_code = -ENOMEM;
   31cb0:	00bffd04 	movi	r2,-12
   31cb4:	e0bffb15 	stw	r2,-20(fp)
   31cb8:	00000406 	br	31ccc <alt_flash_cfi_get_info+0x78>
  }
  else
  {
    *info = &flash->region_info[0];
   31cbc:	e0bffc17 	ldw	r2,-16(fp)
   31cc0:	10c00d04 	addi	r3,r2,52
   31cc4:	e0bffe17 	ldw	r2,-8(fp)
   31cc8:	10c00015 	stw	r3,0(r2)
  }

  return ret_code;
   31ccc:	e0bffb17 	ldw	r2,-20(fp)
}
   31cd0:	e037883a 	mov	sp,fp
   31cd4:	df000017 	ldw	fp,0(sp)
   31cd8:	dec00104 	addi	sp,sp,4
   31cdc:	f800283a 	ret

00031ce0 <alt_flash_cfi_read>:
 *  Read from an area in flash, you could use memcopy yourself
 *  for these flash types, but we're trying to be generic and future proof
 */
int alt_flash_cfi_read( alt_flash_dev* flash_info, int offset, 
                        void* dest_addr, int length )
{
   31ce0:	defff904 	addi	sp,sp,-28
   31ce4:	dfc00615 	stw	ra,24(sp)
   31ce8:	df000515 	stw	fp,20(sp)
   31cec:	df000504 	addi	fp,sp,20
   31cf0:	e13ffc15 	stw	r4,-16(fp)
   31cf4:	e17ffd15 	stw	r5,-12(fp)
   31cf8:	e1bffe15 	stw	r6,-8(fp)
   31cfc:	e1ffff15 	stw	r7,-4(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
   31d00:	e0bffc17 	ldw	r2,-16(fp)
   31d04:	e0bffb15 	stw	r2,-20(fp)
  memcpy(dest_addr, (alt_u8*)flash->dev.base_addr+offset, length);
   31d08:	e0bffb17 	ldw	r2,-20(fp)
   31d0c:	10c00a17 	ldw	r3,40(r2)
   31d10:	e0bffd17 	ldw	r2,-12(fp)
   31d14:	1887883a 	add	r3,r3,r2
   31d18:	e0bfff17 	ldw	r2,-4(fp)
   31d1c:	e13ffe17 	ldw	r4,-8(fp)
   31d20:	180b883a 	mov	r5,r3
   31d24:	100d883a 	mov	r6,r2
   31d28:	00041f00 	call	41f0 <memcpy>
  return 0;
   31d2c:	0005883a 	mov	r2,zero
}
   31d30:	e037883a 	mov	sp,fp
   31d34:	dfc00117 	ldw	ra,4(sp)
   31d38:	df000017 	ldw	fp,0(sp)
   31d3c:	dec00204 	addi	sp,sp,8
   31d40:	f800283a 	ret

00031d44 <alt_write_value_to_flash>:
* It writes the largest word size that the flash can support
* so if it's an 8 bit flash it writes bytes
* 16 bit half word etc.
*/
void alt_write_value_to_flash(alt_flash_cfi_dev* flash, int offset, const alt_u8* src_addr)
{
   31d44:	defffa04 	addi	sp,sp,-24
   31d48:	df000515 	stw	fp,20(sp)
   31d4c:	df000504 	addi	fp,sp,20
   31d50:	e13ffd15 	stw	r4,-12(fp)
   31d54:	e17ffe15 	stw	r5,-8(fp)
   31d58:	e1bfff15 	stw	r6,-4(fp)
  alt_u16 half_word_value;
  alt_u32 word_value;

  if (flash->mode_width == 1)
   31d5c:	e0bffd17 	ldw	r2,-12(fp)
   31d60:	10802e17 	ldw	r2,184(r2)
   31d64:	10800058 	cmpnei	r2,r2,1
   31d68:	1000091e 	bne	r2,zero,31d90 <alt_write_value_to_flash+0x4c>
  {
    IOWR_8DIRECT(flash->dev.base_addr, offset, *src_addr);
   31d6c:	e0bffd17 	ldw	r2,-12(fp)
   31d70:	10c00a17 	ldw	r3,40(r2)
   31d74:	e0bffe17 	ldw	r2,-8(fp)
   31d78:	1885883a 	add	r2,r3,r2
   31d7c:	e0ffff17 	ldw	r3,-4(fp)
   31d80:	18c00003 	ldbu	r3,0(r3)
   31d84:	18c03fcc 	andi	r3,r3,255
   31d88:	10c00025 	stbio	r3,0(r2)
    word_value |= ((alt_u32)(*(src_addr + 2)) << 16);
    word_value |= ((alt_u32)(*(src_addr + 3)) << 24);
    IOWR_32DIRECT(flash->dev.base_addr, offset, word_value);
  }

  return;
   31d8c:	00003e06 	br	31e88 <alt_write_value_to_flash+0x144>

  if (flash->mode_width == 1)
  {
    IOWR_8DIRECT(flash->dev.base_addr, offset, *src_addr);
  }
  else if (flash->mode_width == 2)
   31d90:	e0bffd17 	ldw	r2,-12(fp)
   31d94:	10802e17 	ldw	r2,184(r2)
   31d98:	10800098 	cmpnei	r2,r2,2
   31d9c:	1000141e 	bne	r2,zero,31df0 <alt_write_value_to_flash+0xac>
  {
    half_word_value = (alt_u16)(*src_addr);
   31da0:	e0bfff17 	ldw	r2,-4(fp)
   31da4:	10800003 	ldbu	r2,0(r2)
   31da8:	10803fcc 	andi	r2,r2,255
   31dac:	e0bffb0d 	sth	r2,-20(fp)
    half_word_value |= (alt_u16)(*(src_addr + 1)) << 8;
   31db0:	e0bfff17 	ldw	r2,-4(fp)
   31db4:	10800044 	addi	r2,r2,1
   31db8:	10800003 	ldbu	r2,0(r2)
   31dbc:	10803fcc 	andi	r2,r2,255
   31dc0:	1004923a 	slli	r2,r2,8
   31dc4:	1007883a 	mov	r3,r2
   31dc8:	e0bffb0b 	ldhu	r2,-20(fp)
   31dcc:	1884b03a 	or	r2,r3,r2
   31dd0:	e0bffb0d 	sth	r2,-20(fp)
    IOWR_16DIRECT(flash->dev.base_addr, offset, half_word_value);
   31dd4:	e0bffd17 	ldw	r2,-12(fp)
   31dd8:	10c00a17 	ldw	r3,40(r2)
   31ddc:	e0bffe17 	ldw	r2,-8(fp)
   31de0:	1885883a 	add	r2,r3,r2
   31de4:	e0fffb0b 	ldhu	r3,-20(fp)
   31de8:	10c0002d 	sthio	r3,0(r2)
    word_value |= ((alt_u32)(*(src_addr + 2)) << 16);
    word_value |= ((alt_u32)(*(src_addr + 3)) << 24);
    IOWR_32DIRECT(flash->dev.base_addr, offset, word_value);
  }

  return;
   31dec:	00002606 	br	31e88 <alt_write_value_to_flash+0x144>
  {
    half_word_value = (alt_u16)(*src_addr);
    half_word_value |= (alt_u16)(*(src_addr + 1)) << 8;
    IOWR_16DIRECT(flash->dev.base_addr, offset, half_word_value);
  }
  else if (flash->mode_width == 4)
   31df0:	e0bffd17 	ldw	r2,-12(fp)
   31df4:	10802e17 	ldw	r2,184(r2)
   31df8:	10800118 	cmpnei	r2,r2,4
   31dfc:	1000221e 	bne	r2,zero,31e88 <alt_write_value_to_flash+0x144>
  {
    word_value = (alt_u32)(*src_addr);
   31e00:	e0bfff17 	ldw	r2,-4(fp)
   31e04:	10800003 	ldbu	r2,0(r2)
   31e08:	10803fcc 	andi	r2,r2,255
   31e0c:	e0bffc15 	stw	r2,-16(fp)
    word_value |= ((alt_u32)(*(src_addr + 1)) << 8);
   31e10:	e0bfff17 	ldw	r2,-4(fp)
   31e14:	10800044 	addi	r2,r2,1
   31e18:	10800003 	ldbu	r2,0(r2)
   31e1c:	10803fcc 	andi	r2,r2,255
   31e20:	1004923a 	slli	r2,r2,8
   31e24:	e0fffc17 	ldw	r3,-16(fp)
   31e28:	1884b03a 	or	r2,r3,r2
   31e2c:	e0bffc15 	stw	r2,-16(fp)
    word_value |= ((alt_u32)(*(src_addr + 2)) << 16);
   31e30:	e0bfff17 	ldw	r2,-4(fp)
   31e34:	10800084 	addi	r2,r2,2
   31e38:	10800003 	ldbu	r2,0(r2)
   31e3c:	10803fcc 	andi	r2,r2,255
   31e40:	1004943a 	slli	r2,r2,16
   31e44:	e0fffc17 	ldw	r3,-16(fp)
   31e48:	1884b03a 	or	r2,r3,r2
   31e4c:	e0bffc15 	stw	r2,-16(fp)
    word_value |= ((alt_u32)(*(src_addr + 3)) << 24);
   31e50:	e0bfff17 	ldw	r2,-4(fp)
   31e54:	108000c4 	addi	r2,r2,3
   31e58:	10800003 	ldbu	r2,0(r2)
   31e5c:	10803fcc 	andi	r2,r2,255
   31e60:	1004963a 	slli	r2,r2,24
   31e64:	e0fffc17 	ldw	r3,-16(fp)
   31e68:	1884b03a 	or	r2,r3,r2
   31e6c:	e0bffc15 	stw	r2,-16(fp)
    IOWR_32DIRECT(flash->dev.base_addr, offset, word_value);
   31e70:	e0bffd17 	ldw	r2,-12(fp)
   31e74:	10c00a17 	ldw	r3,40(r2)
   31e78:	e0bffe17 	ldw	r2,-8(fp)
   31e7c:	1885883a 	add	r2,r3,r2
   31e80:	e0fffc17 	ldw	r3,-16(fp)
   31e84:	10c00035 	stwio	r3,0(r2)
  }

  return;
   31e88:	0001883a 	nop
}
   31e8c:	e037883a 	mov	sp,fp
   31e90:	df000017 	ldw	fp,0(sp)
   31e94:	dec00104 	addi	sp,sp,4
   31e98:	f800283a 	ret

00031e9c <alt_flash_program_block>:
*/
int alt_flash_program_block(  alt_flash_cfi_dev* flash, const int offset, 
                        const alt_u8* src_addr, 
                        const int length,
                        alt_program_word_fn program_word_func)
{
   31e9c:	defff304 	addi	sp,sp,-52
   31ea0:	dfc00c15 	stw	ra,48(sp)
   31ea4:	df000b15 	stw	fp,44(sp)
   31ea8:	df000b04 	addi	fp,sp,44
   31eac:	e13ffc15 	stw	r4,-16(fp)
   31eb0:	e17ffd15 	stw	r5,-12(fp)
   31eb4:	e1bffe15 	stw	r6,-8(fp)
   31eb8:	e1ffff15 	stw	r7,-4(fp)
  int     ret_code = 0;
   31ebc:	e03ff515 	stw	zero,-44(fp)

  /*
   * First take care of any writes which are on none native boundaries
   * as far as the flash is concerned.
   */
  bytes_to_preserve = ((int)((alt_u8*)flash->dev.base_addr + offset) % 
   31ec0:	e0bffc17 	ldw	r2,-16(fp)
   31ec4:	10c00a17 	ldw	r3,40(r2)
   31ec8:	e0bffd17 	ldw	r2,-12(fp)
   31ecc:	1885883a 	add	r2,r3,r2
                      flash->mode_width);
   31ed0:	e0fffc17 	ldw	r3,-16(fp)
   31ed4:	18c02e17 	ldw	r3,184(r3)

  /*
   * First take care of any writes which are on none native boundaries
   * as far as the flash is concerned.
   */
  bytes_to_preserve = ((int)((alt_u8*)flash->dev.base_addr + offset) % 
   31ed8:	10c9283a 	div	r4,r2,r3
   31edc:	20c7383a 	mul	r3,r4,r3
   31ee0:	10c5c83a 	sub	r2,r2,r3
   31ee4:	e0bff815 	stw	r2,-32(fp)
                      flash->mode_width);
  if ( bytes_to_preserve != 0)
   31ee8:	e0bff817 	ldw	r2,-32(fp)
   31eec:	10003b26 	beq	r2,zero,31fdc <alt_flash_program_block+0x140>
  {
    unaligned_bytes = flash->mode_width - bytes_to_preserve;
   31ef0:	e0bffc17 	ldw	r2,-16(fp)
   31ef4:	10c02e17 	ldw	r3,184(r2)
   31ef8:	e0bff817 	ldw	r2,-32(fp)
   31efc:	1885c83a 	sub	r2,r3,r2
   31f00:	e0bff915 	stw	r2,-28(fp)
    /*
     * Read the bytes we wish to preserve out of flash
     */
    for (i=0;i<bytes_to_preserve;i++)
   31f04:	e03ff615 	stw	zero,-40(fp)
   31f08:	00001206 	br	31f54 <alt_flash_program_block+0xb8>
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
   31f0c:	e0bffc17 	ldw	r2,-16(fp)
   31f10:	10c00a17 	ldw	r3,40(r2)
   31f14:	e13ffd17 	ldw	r4,-12(fp)
   31f18:	e0bff817 	ldw	r2,-32(fp)
   31f1c:	2089c83a 	sub	r4,r4,r2
   31f20:	e0bff617 	ldw	r2,-40(fp)
   31f24:	2085883a 	add	r2,r4,r2
   31f28:	1885883a 	add	r2,r3,r2
   31f2c:	10800023 	ldbuio	r2,0(r2)
   31f30:	10803fcc 	andi	r2,r2,255
   31f34:	1007883a 	mov	r3,r2
   31f38:	e13ffb04 	addi	r4,fp,-20
   31f3c:	e0bff617 	ldw	r2,-40(fp)
   31f40:	2085883a 	add	r2,r4,r2
   31f44:	10c00005 	stb	r3,0(r2)
  {
    unaligned_bytes = flash->mode_width - bytes_to_preserve;
    /*
     * Read the bytes we wish to preserve out of flash
     */
    for (i=0;i<bytes_to_preserve;i++)
   31f48:	e0bff617 	ldw	r2,-40(fp)
   31f4c:	10800044 	addi	r2,r2,1
   31f50:	e0bff615 	stw	r2,-40(fp)
   31f54:	e0fff617 	ldw	r3,-40(fp)
   31f58:	e0bff817 	ldw	r2,-32(fp)
   31f5c:	18bfeb16 	blt	r3,r2,31f0c <alt_flash_program_block+0x70>
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
                                offset-bytes_to_preserve+i);
    }

    for (i=0;i<unaligned_bytes;i++)
   31f60:	e03ff615 	stw	zero,-40(fp)
   31f64:	00000d06 	br	31f9c <alt_flash_program_block+0x100>
    {
      unaligned[bytes_to_preserve + i] = *(alt_u8*)(src_addr + i);
   31f68:	e0fff817 	ldw	r3,-32(fp)
   31f6c:	e0bff617 	ldw	r2,-40(fp)
   31f70:	1885883a 	add	r2,r3,r2
   31f74:	e0fff617 	ldw	r3,-40(fp)
   31f78:	e13ffe17 	ldw	r4,-8(fp)
   31f7c:	20c7883a 	add	r3,r4,r3
   31f80:	18c00003 	ldbu	r3,0(r3)
   31f84:	e13ffb04 	addi	r4,fp,-20
   31f88:	2085883a 	add	r2,r4,r2
   31f8c:	10c00005 	stb	r3,0(r2)
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
                                offset-bytes_to_preserve+i);
    }

    for (i=0;i<unaligned_bytes;i++)
   31f90:	e0bff617 	ldw	r2,-40(fp)
   31f94:	10800044 	addi	r2,r2,1
   31f98:	e0bff615 	stw	r2,-40(fp)
   31f9c:	e0fff617 	ldw	r3,-40(fp)
   31fa0:	e0bff917 	ldw	r2,-28(fp)
   31fa4:	18bff016 	blt	r3,r2,31f68 <alt_flash_program_block+0xcc>
    {
      unaligned[bytes_to_preserve + i] = *(alt_u8*)(src_addr + i);
    }
    
    ret_code = (*program_word_func)(flash, offset-bytes_to_preserve, unaligned);
   31fa8:	e0fffd17 	ldw	r3,-12(fp)
   31fac:	e0bff817 	ldw	r2,-32(fp)
   31fb0:	1887c83a 	sub	r3,r3,r2
   31fb4:	e0bffb04 	addi	r2,fp,-20
   31fb8:	e1c00217 	ldw	r7,8(fp)
   31fbc:	e13ffc17 	ldw	r4,-16(fp)
   31fc0:	180b883a 	mov	r5,r3
   31fc4:	100d883a 	mov	r6,r2
   31fc8:	383ee83a 	callr	r7
   31fcc:	e0bff515 	stw	r2,-44(fp)
    i = unaligned_bytes;
   31fd0:	e0bff917 	ldw	r2,-28(fp)
   31fd4:	e0bff615 	stw	r2,-40(fp)
   31fd8:	00000106 	br	31fe0 <alt_flash_program_block+0x144>
  }
  else
  {
    i = 0;
   31fdc:	e03ff615 	stw	zero,-40(fp)
  }

  unaligned_end_bytes = (offset+length) % flash->mode_width;
   31fe0:	e0fffd17 	ldw	r3,-12(fp)
   31fe4:	e0bfff17 	ldw	r2,-4(fp)
   31fe8:	1885883a 	add	r2,r3,r2
   31fec:	e0fffc17 	ldw	r3,-16(fp)
   31ff0:	18c02e17 	ldw	r3,184(r3)
   31ff4:	10c9283a 	div	r4,r2,r3
   31ff8:	20c7383a 	mul	r3,r4,r3
   31ffc:	10c5c83a 	sub	r2,r2,r3
   32000:	e0bffa15 	stw	r2,-24(fp)
  while ((ret_code == 0) && (i < (length-unaligned_end_bytes)))
   32004:	00001106 	br	3204c <alt_flash_program_block+0x1b0>
  {
    ret_code = (*program_word_func)(flash, offset+i, src_addr+i);
   32008:	e0fffd17 	ldw	r3,-12(fp)
   3200c:	e0bff617 	ldw	r2,-40(fp)
   32010:	1887883a 	add	r3,r3,r2
   32014:	e0bff617 	ldw	r2,-40(fp)
   32018:	e13ffe17 	ldw	r4,-8(fp)
   3201c:	2085883a 	add	r2,r4,r2
   32020:	e1c00217 	ldw	r7,8(fp)
   32024:	e13ffc17 	ldw	r4,-16(fp)
   32028:	180b883a 	mov	r5,r3
   3202c:	100d883a 	mov	r6,r2
   32030:	383ee83a 	callr	r7
   32034:	e0bff515 	stw	r2,-44(fp)
    i += flash->mode_width;     
   32038:	e0bffc17 	ldw	r2,-16(fp)
   3203c:	10802e17 	ldw	r2,184(r2)
   32040:	e0fff617 	ldw	r3,-40(fp)
   32044:	1885883a 	add	r2,r3,r2
   32048:	e0bff615 	stw	r2,-40(fp)
  {
    i = 0;
  }

  unaligned_end_bytes = (offset+length) % flash->mode_width;
  while ((ret_code == 0) && (i < (length-unaligned_end_bytes)))
   3204c:	e0bff517 	ldw	r2,-44(fp)
   32050:	1000051e 	bne	r2,zero,32068 <alt_flash_program_block+0x1cc>
   32054:	e0ffff17 	ldw	r3,-4(fp)
   32058:	e0bffa17 	ldw	r2,-24(fp)
   3205c:	1885c83a 	sub	r2,r3,r2
   32060:	e0fff617 	ldw	r3,-40(fp)
   32064:	18bfe816 	blt	r3,r2,32008 <alt_flash_program_block+0x16c>

  /*
   * Now take care of any writes at the end of the buffer which are on none 
   * native boundaries as far as the flash is concerned.
   */
  if (unaligned_end_bytes && !ret_code)
   32068:	e0bffa17 	ldw	r2,-24(fp)
   3206c:	10003b26 	beq	r2,zero,3215c <alt_flash_program_block+0x2c0>
   32070:	e0bff517 	ldw	r2,-44(fp)
   32074:	1000391e 	bne	r2,zero,3215c <alt_flash_program_block+0x2c0>
  {
    bytes_to_preserve = flash->mode_width - unaligned_end_bytes;
   32078:	e0bffc17 	ldw	r2,-16(fp)
   3207c:	10c02e17 	ldw	r3,184(r2)
   32080:	e0bffa17 	ldw	r2,-24(fp)
   32084:	1885c83a 	sub	r2,r3,r2
   32088:	e0bff815 	stw	r2,-32(fp)
    
    for (j=0;j<unaligned_end_bytes;j++)
   3208c:	e03ff715 	stw	zero,-36(fp)
   32090:	00000d06 	br	320c8 <alt_flash_program_block+0x22c>
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
   32094:	e0fff617 	ldw	r3,-40(fp)
   32098:	e0bff717 	ldw	r2,-36(fp)
   3209c:	1885883a 	add	r2,r3,r2
   320a0:	e0fffe17 	ldw	r3,-8(fp)
   320a4:	1885883a 	add	r2,r3,r2
   320a8:	10c00003 	ldbu	r3,0(r2)
   320ac:	e13ffb04 	addi	r4,fp,-20
   320b0:	e0bff717 	ldw	r2,-36(fp)
   320b4:	2085883a 	add	r2,r4,r2
   320b8:	10c00005 	stb	r3,0(r2)
   */
  if (unaligned_end_bytes && !ret_code)
  {
    bytes_to_preserve = flash->mode_width - unaligned_end_bytes;
    
    for (j=0;j<unaligned_end_bytes;j++)
   320bc:	e0bff717 	ldw	r2,-36(fp)
   320c0:	10800044 	addi	r2,r2,1
   320c4:	e0bff715 	stw	r2,-36(fp)
   320c8:	e0fff717 	ldw	r3,-36(fp)
   320cc:	e0bffa17 	ldw	r2,-24(fp)
   320d0:	18bff016 	blt	r3,r2,32094 <alt_flash_program_block+0x1f8>
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
    }
    
    for (j=0;j<bytes_to_preserve;j++)
   320d4:	e03ff715 	stw	zero,-36(fp)
   320d8:	00001306 	br	32128 <alt_flash_program_block+0x28c>
    {
      unaligned[unaligned_end_bytes+j] = IORD_8DIRECT(flash->dev.base_addr, 
   320dc:	e0fffa17 	ldw	r3,-24(fp)
   320e0:	e0bff717 	ldw	r2,-36(fp)
   320e4:	1885883a 	add	r2,r3,r2
   320e8:	e0fffc17 	ldw	r3,-16(fp)
   320ec:	19000a17 	ldw	r4,40(r3)
   320f0:	e17ffd17 	ldw	r5,-12(fp)
   320f4:	e0ffff17 	ldw	r3,-4(fp)
   320f8:	28cb883a 	add	r5,r5,r3
   320fc:	e0fff717 	ldw	r3,-36(fp)
   32100:	28c7883a 	add	r3,r5,r3
   32104:	20c7883a 	add	r3,r4,r3
   32108:	18c00023 	ldbuio	r3,0(r3)
   3210c:	18c03fcc 	andi	r3,r3,255
   32110:	e13ffb04 	addi	r4,fp,-20
   32114:	2085883a 	add	r2,r4,r2
   32118:	10c00005 	stb	r3,0(r2)
    for (j=0;j<unaligned_end_bytes;j++)
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
    }
    
    for (j=0;j<bytes_to_preserve;j++)
   3211c:	e0bff717 	ldw	r2,-36(fp)
   32120:	10800044 	addi	r2,r2,1
   32124:	e0bff715 	stw	r2,-36(fp)
   32128:	e0fff717 	ldw	r3,-36(fp)
   3212c:	e0bff817 	ldw	r2,-32(fp)
   32130:	18bfea16 	blt	r3,r2,320dc <alt_flash_program_block+0x240>
    {
      unaligned[unaligned_end_bytes+j] = IORD_8DIRECT(flash->dev.base_addr, 
                                                      offset+length+j);
    }

    ret_code = (*program_word_func)(flash, offset+i, unaligned);      
   32134:	e0fffd17 	ldw	r3,-12(fp)
   32138:	e0bff617 	ldw	r2,-40(fp)
   3213c:	1887883a 	add	r3,r3,r2
   32140:	e0bffb04 	addi	r2,fp,-20
   32144:	e1c00217 	ldw	r7,8(fp)
   32148:	e13ffc17 	ldw	r4,-16(fp)
   3214c:	180b883a 	mov	r5,r3
   32150:	100d883a 	mov	r6,r2
   32154:	383ee83a 	callr	r7
   32158:	e0bff515 	stw	r2,-44(fp)
  }

  return ret_code;
   3215c:	e0bff517 	ldw	r2,-44(fp)
}
   32160:	e037883a 	mov	sp,fp
   32164:	dfc00117 	ldw	ra,4(sp)
   32168:	df000017 	ldw	fp,0(sp)
   3216c:	dec00204 	addi	sp,sp,8
   32170:	f800283a 	ret

00032174 <alt_read_query_entry_8bit>:

/*
 *  Read an 8 bit value from the CFI query table in flash
 */
alt_u8 alt_read_query_entry_8bit( alt_flash_cfi_dev* flash, int address)
{
   32174:	defffd04 	addi	sp,sp,-12
   32178:	df000215 	stw	fp,8(sp)
   3217c:	df000204 	addi	fp,sp,8
   32180:	e13ffe15 	stw	r4,-8(fp)
   32184:	e17fff15 	stw	r5,-4(fp)
  return IORD_8DIRECT((alt_u8*)flash->dev.base_addr, address);
   32188:	e0bffe17 	ldw	r2,-8(fp)
   3218c:	10c00a17 	ldw	r3,40(r2)
   32190:	e0bfff17 	ldw	r2,-4(fp)
   32194:	1885883a 	add	r2,r3,r2
   32198:	10800023 	ldbuio	r2,0(r2)
   3219c:	10803fcc 	andi	r2,r2,255
}
   321a0:	e037883a 	mov	sp,fp
   321a4:	df000017 	ldw	fp,0(sp)
   321a8:	dec00104 	addi	sp,sp,4
   321ac:	f800283a 	ret

000321b0 <alt_read_query_entry_16bit>:

alt_u8 alt_read_query_entry_16bit( alt_flash_cfi_dev* flash, int address)
{
   321b0:	defffd04 	addi	sp,sp,-12
   321b4:	df000215 	stw	fp,8(sp)
   321b8:	df000204 	addi	fp,sp,8
   321bc:	e13ffe15 	stw	r4,-8(fp)
   321c0:	e17fff15 	stw	r5,-4(fp)
  return (IORD_16DIRECT((alt_u8*)flash->dev.base_addr, address*2) & 0xff);
   321c4:	e0bffe17 	ldw	r2,-8(fp)
   321c8:	10c00a17 	ldw	r3,40(r2)
   321cc:	e0bfff17 	ldw	r2,-4(fp)
   321d0:	1085883a 	add	r2,r2,r2
   321d4:	1885883a 	add	r2,r3,r2
   321d8:	1080002b 	ldhuio	r2,0(r2)
   321dc:	10bfffcc 	andi	r2,r2,65535
}
   321e0:	e037883a 	mov	sp,fp
   321e4:	df000017 	ldw	fp,0(sp)
   321e8:	dec00104 	addi	sp,sp,4
   321ec:	f800283a 	ret

000321f0 <alt_read_query_entry_32bit>:

alt_u8 alt_read_query_entry_32bit( alt_flash_cfi_dev* flash, int address)
{
   321f0:	defffd04 	addi	sp,sp,-12
   321f4:	df000215 	stw	fp,8(sp)
   321f8:	df000204 	addi	fp,sp,8
   321fc:	e13ffe15 	stw	r4,-8(fp)
   32200:	e17fff15 	stw	r5,-4(fp)
  return (IORD_32DIRECT((alt_u8*)flash->dev.base_addr, address*4) & 0xff);
   32204:	e0bffe17 	ldw	r2,-8(fp)
   32208:	10c00a17 	ldw	r3,40(r2)
   3220c:	e0bfff17 	ldw	r2,-4(fp)
   32210:	1085883a 	add	r2,r2,r2
   32214:	1085883a 	add	r2,r2,r2
   32218:	1885883a 	add	r2,r3,r2
   3221c:	10800037 	ldwio	r2,0(r2)
}
   32220:	e037883a 	mov	sp,fp
   32224:	df000017 	ldw	fp,0(sp)
   32228:	dec00104 	addi	sp,sp,4
   3222c:	f800283a 	ret

00032230 <alt_write_flash_command_8bit_device_8bit_mode>:

/*
 * Write an 8 bit command to a flash
 */
void alt_write_flash_command_8bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
   32230:	defffc04 	addi	sp,sp,-16
   32234:	df000315 	stw	fp,12(sp)
   32238:	df000304 	addi	fp,sp,12
   3223c:	e13ffd15 	stw	r4,-12(fp)
   32240:	e17ffe15 	stw	r5,-8(fp)
   32244:	3005883a 	mov	r2,r6
   32248:	e0bfff05 	stb	r2,-4(fp)
  IOWR_8DIRECT(base_addr, offset, value);
   3224c:	e0bffe17 	ldw	r2,-8(fp)
   32250:	e0fffd17 	ldw	r3,-12(fp)
   32254:	1885883a 	add	r2,r3,r2
   32258:	e0ffff03 	ldbu	r3,-4(fp)
   3225c:	10c00025 	stbio	r3,0(r2)
  return;
   32260:	0001883a 	nop
}
   32264:	e037883a 	mov	sp,fp
   32268:	df000017 	ldw	fp,0(sp)
   3226c:	dec00104 	addi	sp,sp,4
   32270:	f800283a 	ret

00032274 <alt_write_flash_command_16bit_device_8bit_mode>:

void alt_write_flash_command_16bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
   32274:	defffc04 	addi	sp,sp,-16
   32278:	df000315 	stw	fp,12(sp)
   3227c:	df000304 	addi	fp,sp,12
   32280:	e13ffd15 	stw	r4,-12(fp)
   32284:	e17ffe15 	stw	r5,-8(fp)
   32288:	3005883a 	mov	r2,r6
   3228c:	e0bfff05 	stb	r2,-4(fp)
  if (offset % 2)
   32290:	e0bffe17 	ldw	r2,-8(fp)
   32294:	1080004c 	andi	r2,r2,1
   32298:	10000726 	beq	r2,zero,322b8 <alt_write_flash_command_16bit_device_8bit_mode+0x44>
  {
    IOWR_8DIRECT(base_addr, offset*2, value);
   3229c:	e0bffe17 	ldw	r2,-8(fp)
   322a0:	1085883a 	add	r2,r2,r2
   322a4:	e0fffd17 	ldw	r3,-12(fp)
   322a8:	1885883a 	add	r2,r3,r2
   322ac:	e0ffff03 	ldbu	r3,-4(fp)
   322b0:	10c00025 	stbio	r3,0(r2)
  }
  else
  {
    IOWR_8DIRECT(base_addr, (offset*2)+1, value);
  }
  return;
   322b4:	00000706 	br	322d4 <alt_write_flash_command_16bit_device_8bit_mode+0x60>
  {
    IOWR_8DIRECT(base_addr, offset*2, value);
  }
  else
  {
    IOWR_8DIRECT(base_addr, (offset*2)+1, value);
   322b8:	e0bffe17 	ldw	r2,-8(fp)
   322bc:	1085883a 	add	r2,r2,r2
   322c0:	10800044 	addi	r2,r2,1
   322c4:	e0fffd17 	ldw	r3,-12(fp)
   322c8:	1885883a 	add	r2,r3,r2
   322cc:	e0ffff03 	ldbu	r3,-4(fp)
   322d0:	10c00025 	stbio	r3,0(r2)
  }
  return;
   322d4:	0001883a 	nop
}
   322d8:	e037883a 	mov	sp,fp
   322dc:	df000017 	ldw	fp,0(sp)
   322e0:	dec00104 	addi	sp,sp,4
   322e4:	f800283a 	ret

000322e8 <alt_write_flash_command_32bit_device_8bit_mode>:

void alt_write_flash_command_32bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
   322e8:	defffc04 	addi	sp,sp,-16
   322ec:	df000315 	stw	fp,12(sp)
   322f0:	df000304 	addi	fp,sp,12
   322f4:	e13ffd15 	stw	r4,-12(fp)
   322f8:	e17ffe15 	stw	r5,-8(fp)
   322fc:	3005883a 	mov	r2,r6
   32300:	e0bfff05 	stb	r2,-4(fp)
  IOWR_8DIRECT(base_addr, offset*4, value);
   32304:	e0bffe17 	ldw	r2,-8(fp)
   32308:	1085883a 	add	r2,r2,r2
   3230c:	1085883a 	add	r2,r2,r2
   32310:	e0fffd17 	ldw	r3,-12(fp)
   32314:	1885883a 	add	r2,r3,r2
   32318:	e0ffff03 	ldbu	r3,-4(fp)
   3231c:	10c00025 	stbio	r3,0(r2)
  return;
   32320:	0001883a 	nop
}
   32324:	e037883a 	mov	sp,fp
   32328:	df000017 	ldw	fp,0(sp)
   3232c:	dec00104 	addi	sp,sp,4
   32330:	f800283a 	ret

00032334 <alt_write_flash_command_16bit_device_16bit_mode>:

void alt_write_flash_command_16bit_device_16bit_mode( void* base_addr, int offset, alt_u8 value)
{
   32334:	defffc04 	addi	sp,sp,-16
   32338:	df000315 	stw	fp,12(sp)
   3233c:	df000304 	addi	fp,sp,12
   32340:	e13ffd15 	stw	r4,-12(fp)
   32344:	e17ffe15 	stw	r5,-8(fp)
   32348:	3005883a 	mov	r2,r6
   3234c:	e0bfff05 	stb	r2,-4(fp)
  IOWR_16DIRECT(base_addr, offset*2, ((alt_u16)value)& 0x00ff);
   32350:	e0bffe17 	ldw	r2,-8(fp)
   32354:	1085883a 	add	r2,r2,r2
   32358:	e0fffd17 	ldw	r3,-12(fp)
   3235c:	1885883a 	add	r2,r3,r2
   32360:	e0ffff03 	ldbu	r3,-4(fp)
   32364:	10c0002d 	sthio	r3,0(r2)
  return;
   32368:	0001883a 	nop
}
   3236c:	e037883a 	mov	sp,fp
   32370:	df000017 	ldw	fp,0(sp)
   32374:	dec00104 	addi	sp,sp,4
   32378:	f800283a 	ret

0003237c <alt_write_flash_command_32bit_device_16bit_mode>:

void alt_write_flash_command_32bit_device_16bit_mode( void* base_addr, int offset, alt_u8 value)
{
   3237c:	defffc04 	addi	sp,sp,-16
   32380:	df000315 	stw	fp,12(sp)
   32384:	df000304 	addi	fp,sp,12
   32388:	e13ffd15 	stw	r4,-12(fp)
   3238c:	e17ffe15 	stw	r5,-8(fp)
   32390:	3005883a 	mov	r2,r6
   32394:	e0bfff05 	stb	r2,-4(fp)
  IOWR_16DIRECT(base_addr, offset*4, ((alt_u16)value)& 0x00ff);
   32398:	e0bffe17 	ldw	r2,-8(fp)
   3239c:	1085883a 	add	r2,r2,r2
   323a0:	1085883a 	add	r2,r2,r2
   323a4:	e0fffd17 	ldw	r3,-12(fp)
   323a8:	1885883a 	add	r2,r3,r2
   323ac:	e0ffff03 	ldbu	r3,-4(fp)
   323b0:	10c0002d 	sthio	r3,0(r2)
  return;
   323b4:	0001883a 	nop
}
   323b8:	e037883a 	mov	sp,fp
   323bc:	df000017 	ldw	fp,0(sp)
   323c0:	dec00104 	addi	sp,sp,4
   323c4:	f800283a 	ret

000323c8 <alt_write_flash_command_32bit_device_32bit_mode>:

void alt_write_flash_command_32bit_device_32bit_mode( void* base_addr, int offset, alt_u8 value)
{
   323c8:	defffc04 	addi	sp,sp,-16
   323cc:	df000315 	stw	fp,12(sp)
   323d0:	df000304 	addi	fp,sp,12
   323d4:	e13ffd15 	stw	r4,-12(fp)
   323d8:	e17ffe15 	stw	r5,-8(fp)
   323dc:	3005883a 	mov	r2,r6
   323e0:	e0bfff05 	stb	r2,-4(fp)
  IOWR_32DIRECT(base_addr, offset*4, ((alt_u32)value)& 0x000000ff);
   323e4:	e0bffe17 	ldw	r2,-8(fp)
   323e8:	1085883a 	add	r2,r2,r2
   323ec:	1085883a 	add	r2,r2,r2
   323f0:	e0fffd17 	ldw	r3,-12(fp)
   323f4:	1885883a 	add	r2,r3,r2
   323f8:	e0ffff03 	ldbu	r3,-4(fp)
   323fc:	10c00035 	stwio	r3,0(r2)
  return;
   32400:	0001883a 	nop
}
   32404:	e037883a 	mov	sp,fp
   32408:	df000017 	ldw	fp,0(sp)
   3240c:	dec00104 	addi	sp,sp,4
   32410:	f800283a 	ret

00032414 <alt_write_native_8bit>:

/*
 * Write the value passed to the flash
 */
void alt_write_native_8bit( void* address, alt_u32 value)
{
   32414:	defffd04 	addi	sp,sp,-12
   32418:	df000215 	stw	fp,8(sp)
   3241c:	df000204 	addi	fp,sp,8
   32420:	e13ffe15 	stw	r4,-8(fp)
   32424:	e17fff15 	stw	r5,-4(fp)
  IOWR_8DIRECT(address, 0, (alt_u8)(value&0xff));
   32428:	e0bfff17 	ldw	r2,-4(fp)
   3242c:	10c03fcc 	andi	r3,r2,255
   32430:	e0bffe17 	ldw	r2,-8(fp)
   32434:	10c00025 	stbio	r3,0(r2)
  return;
   32438:	0001883a 	nop
}
   3243c:	e037883a 	mov	sp,fp
   32440:	df000017 	ldw	fp,0(sp)
   32444:	dec00104 	addi	sp,sp,4
   32448:	f800283a 	ret

0003244c <alt_write_native_16bit>:

void alt_write_native_16bit( void* address, alt_u32 value)
{
   3244c:	defffd04 	addi	sp,sp,-12
   32450:	df000215 	stw	fp,8(sp)
   32454:	df000204 	addi	fp,sp,8
   32458:	e13ffe15 	stw	r4,-8(fp)
   3245c:	e17fff15 	stw	r5,-4(fp)
  IOWR_16DIRECT(address, 0, ((alt_u16)value)& 0xffff);
   32460:	e0bfff17 	ldw	r2,-4(fp)
   32464:	10ffffcc 	andi	r3,r2,65535
   32468:	e0bffe17 	ldw	r2,-8(fp)
   3246c:	10c0002d 	sthio	r3,0(r2)
  return;
   32470:	0001883a 	nop
}
   32474:	e037883a 	mov	sp,fp
   32478:	df000017 	ldw	fp,0(sp)
   3247c:	dec00104 	addi	sp,sp,4
   32480:	f800283a 	ret

00032484 <alt_write_native_32bit>:

void alt_write_native_32bit( void* address, alt_u32 value)
{
   32484:	defffd04 	addi	sp,sp,-12
   32488:	df000215 	stw	fp,8(sp)
   3248c:	df000204 	addi	fp,sp,8
   32490:	e13ffe15 	stw	r4,-8(fp)
   32494:	e17fff15 	stw	r5,-4(fp)
  IOWR_32DIRECT(address, 0, value);
   32498:	e0ffff17 	ldw	r3,-4(fp)
   3249c:	e0bffe17 	ldw	r2,-8(fp)
   324a0:	10c00035 	stwio	r3,0(r2)
  return;
   324a4:	0001883a 	nop
}
   324a8:	e037883a 	mov	sp,fp
   324ac:	df000017 	ldw	fp,0(sp)
   324b0:	dec00104 	addi	sp,sp,4
   324b4:	f800283a 	ret

000324b8 <alt_set_flash_width_func>:
 * 
 * Setup the function pointers for writing a byte to the flash for the width
 * of the device
 */
int alt_set_flash_width_func( alt_flash_cfi_dev* flash)
{ 
   324b8:	defffd04 	addi	sp,sp,-12
   324bc:	df000215 	stw	fp,8(sp)
   324c0:	df000204 	addi	fp,sp,8
   324c4:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
   324c8:	e03ffe15 	stw	zero,-8(fp)
  
  switch(flash->mode_width)
   324cc:	e0bfff17 	ldw	r2,-4(fp)
   324d0:	10802e17 	ldw	r2,184(r2)
   324d4:	10c000a0 	cmpeqi	r3,r2,2
   324d8:	1800231e 	bne	r3,zero,32568 <alt_set_flash_width_func+0xb0>
   324dc:	10c00120 	cmpeqi	r3,r2,4
   324e0:	1800371e 	bne	r3,zero,325c0 <alt_set_flash_width_func+0x108>
   324e4:	10800060 	cmpeqi	r2,r2,1
   324e8:	10003e26 	beq	r2,zero,325e4 <alt_set_flash_width_func+0x12c>
  {
    case 1:
    {
      flash->write_native = alt_write_native_8bit;
   324ec:	e0bfff17 	ldw	r2,-4(fp)
   324f0:	00c000f4 	movhi	r3,3
   324f4:	18c90504 	addi	r3,r3,9236
   324f8:	10c03515 	stw	r3,212(r2)

      if (flash->device_width == 1)
   324fc:	e0bfff17 	ldw	r2,-4(fp)
   32500:	10802f17 	ldw	r2,188(r2)
   32504:	10800058 	cmpnei	r2,r2,1
   32508:	1000051e 	bne	r2,zero,32520 <alt_set_flash_width_func+0x68>
      {
        flash->write_command = alt_write_flash_command_8bit_device_8bit_mode;
   3250c:	e0bfff17 	ldw	r2,-4(fp)
   32510:	00c000f4 	movhi	r3,3
   32514:	18c88c04 	addi	r3,r3,8752
   32518:	10c03315 	stw	r3,204(r2)
      }
      else if (flash->device_width == 4)
      {
        flash->write_command = alt_write_flash_command_32bit_device_8bit_mode;
      }
      break;
   3251c:	00003406 	br	325f0 <alt_set_flash_width_func+0x138>

      if (flash->device_width == 1)
      {
        flash->write_command = alt_write_flash_command_8bit_device_8bit_mode;
      }
      else if (flash->device_width == 2)
   32520:	e0bfff17 	ldw	r2,-4(fp)
   32524:	10802f17 	ldw	r2,188(r2)
   32528:	10800098 	cmpnei	r2,r2,2
   3252c:	1000051e 	bne	r2,zero,32544 <alt_set_flash_width_func+0x8c>
      {
        flash->write_command = alt_write_flash_command_16bit_device_8bit_mode;
   32530:	e0bfff17 	ldw	r2,-4(fp)
   32534:	00c000f4 	movhi	r3,3
   32538:	18c89d04 	addi	r3,r3,8820
   3253c:	10c03315 	stw	r3,204(r2)
      }
      else if (flash->device_width == 4)
      {
        flash->write_command = alt_write_flash_command_32bit_device_8bit_mode;
      }
      break;
   32540:	00002b06 	br	325f0 <alt_set_flash_width_func+0x138>
      }
      else if (flash->device_width == 2)
      {
        flash->write_command = alt_write_flash_command_16bit_device_8bit_mode;
      }
      else if (flash->device_width == 4)
   32544:	e0bfff17 	ldw	r2,-4(fp)
   32548:	10802f17 	ldw	r2,188(r2)
   3254c:	10800118 	cmpnei	r2,r2,4
   32550:	1000271e 	bne	r2,zero,325f0 <alt_set_flash_width_func+0x138>
      {
        flash->write_command = alt_write_flash_command_32bit_device_8bit_mode;
   32554:	e0bfff17 	ldw	r2,-4(fp)
   32558:	00c000f4 	movhi	r3,3
   3255c:	18c8ba04 	addi	r3,r3,8936
   32560:	10c03315 	stw	r3,204(r2)
      }
      break;
   32564:	00002206 	br	325f0 <alt_set_flash_width_func+0x138>
    }
    case 2:
    {
      flash->write_native = alt_write_native_16bit;
   32568:	e0bfff17 	ldw	r2,-4(fp)
   3256c:	00c000f4 	movhi	r3,3
   32570:	18c91304 	addi	r3,r3,9292
   32574:	10c03515 	stw	r3,212(r2)

      if (flash->device_width == 2)
   32578:	e0bfff17 	ldw	r2,-4(fp)
   3257c:	10802f17 	ldw	r2,188(r2)
   32580:	10800098 	cmpnei	r2,r2,2
   32584:	1000051e 	bne	r2,zero,3259c <alt_set_flash_width_func+0xe4>
      {
        flash->write_command = alt_write_flash_command_16bit_device_16bit_mode;
   32588:	e0bfff17 	ldw	r2,-4(fp)
   3258c:	00c000f4 	movhi	r3,3
   32590:	18c8cd04 	addi	r3,r3,9012
   32594:	10c03315 	stw	r3,204(r2)
      else if (flash->device_width == 4)
      {
        flash->write_command = alt_write_flash_command_32bit_device_16bit_mode;
      }

      break;
   32598:	00001706 	br	325f8 <alt_set_flash_width_func+0x140>

      if (flash->device_width == 2)
      {
        flash->write_command = alt_write_flash_command_16bit_device_16bit_mode;
      }
      else if (flash->device_width == 4)
   3259c:	e0bfff17 	ldw	r2,-4(fp)
   325a0:	10802f17 	ldw	r2,188(r2)
   325a4:	10800118 	cmpnei	r2,r2,4
   325a8:	1000131e 	bne	r2,zero,325f8 <alt_set_flash_width_func+0x140>
      {
        flash->write_command = alt_write_flash_command_32bit_device_16bit_mode;
   325ac:	e0bfff17 	ldw	r2,-4(fp)
   325b0:	00c000f4 	movhi	r3,3
   325b4:	18c8df04 	addi	r3,r3,9084
   325b8:	10c03315 	stw	r3,204(r2)
      }

      break;
   325bc:	00000e06 	br	325f8 <alt_set_flash_width_func+0x140>
    }
    case 4:
    {
      flash->write_native = alt_write_native_32bit;
   325c0:	e0bfff17 	ldw	r2,-4(fp)
   325c4:	00c000f4 	movhi	r3,3
   325c8:	18c92104 	addi	r3,r3,9348
   325cc:	10c03515 	stw	r3,212(r2)
      flash->write_command = alt_write_flash_command_32bit_device_32bit_mode;
   325d0:	e0bfff17 	ldw	r2,-4(fp)
   325d4:	00c000f4 	movhi	r3,3
   325d8:	18c8f204 	addi	r3,r3,9160
   325dc:	10c03315 	stw	r3,204(r2)
      break;
   325e0:	00000606 	br	325fc <alt_set_flash_width_func+0x144>
    }
    default:
    {
      ret_code = -EACCES;
   325e4:	00bffcc4 	movi	r2,-13
   325e8:	e0bffe15 	stw	r2,-8(fp)
   325ec:	00000306 	br	325fc <alt_set_flash_width_func+0x144>
      }
      else if (flash->device_width == 4)
      {
        flash->write_command = alt_write_flash_command_32bit_device_8bit_mode;
      }
      break;
   325f0:	0001883a 	nop
   325f4:	00000106 	br	325fc <alt_set_flash_width_func+0x144>
      else if (flash->device_width == 4)
      {
        flash->write_command = alt_write_flash_command_32bit_device_16bit_mode;
      }

      break;
   325f8:	0001883a 	nop
    {
      ret_code = -EACCES;
    }
  }

  if (!ret_code)
   325fc:	e0bffe17 	ldw	r2,-8(fp)
   32600:	1000191e 	bne	r2,zero,32668 <alt_set_flash_width_func+0x1b0>
  {
    switch(flash->device_width)
   32604:	e0bfff17 	ldw	r2,-4(fp)
   32608:	10802f17 	ldw	r2,188(r2)
   3260c:	10c000a0 	cmpeqi	r3,r2,2
   32610:	1800091e 	bne	r3,zero,32638 <alt_set_flash_width_func+0x180>
   32614:	10c00120 	cmpeqi	r3,r2,4
   32618:	18000c1e 	bne	r3,zero,3264c <alt_set_flash_width_func+0x194>
   3261c:	10800060 	cmpeqi	r2,r2,1
   32620:	10000f26 	beq	r2,zero,32660 <alt_set_flash_width_func+0x1a8>
    {
      case 1:
      {
        flash->read_query = alt_read_query_entry_8bit;
   32624:	e0bfff17 	ldw	r2,-4(fp)
   32628:	00c000f4 	movhi	r3,3
   3262c:	18c85d04 	addi	r3,r3,8564
   32630:	10c03415 	stw	r3,208(r2)
        break;
   32634:	00000c06 	br	32668 <alt_set_flash_width_func+0x1b0>
      }
      case 2:
      {
        flash->read_query = alt_read_query_entry_16bit;
   32638:	e0bfff17 	ldw	r2,-4(fp)
   3263c:	00c000f4 	movhi	r3,3
   32640:	18c86c04 	addi	r3,r3,8624
   32644:	10c03415 	stw	r3,208(r2)
        break;
   32648:	00000706 	br	32668 <alt_set_flash_width_func+0x1b0>
      }
      case 4:
      {
        flash->read_query = alt_read_query_entry_32bit;
   3264c:	e0bfff17 	ldw	r2,-4(fp)
   32650:	00c000f4 	movhi	r3,3
   32654:	18c87c04 	addi	r3,r3,8688
   32658:	10c03415 	stw	r3,208(r2)
        break;
   3265c:	00000206 	br	32668 <alt_set_flash_width_func+0x1b0>
      }
      default:
      {
        ret_code = -EACCES;
   32660:	00bffcc4 	movi	r2,-13
   32664:	e0bffe15 	stw	r2,-8(fp)
      }
    }
  }

  return ret_code;
   32668:	e0bffe17 	ldw	r2,-8(fp)
}
   3266c:	e037883a 	mov	sp,fp
   32670:	df000017 	ldw	fp,0(sp)
   32674:	dec00104 	addi	sp,sp,4
   32678:	f800283a 	ret

0003267c <alt_set_flash_algorithm_func>:
 * 
 * Setup the function pointers to the functions for this algorithm
 * 
 */
int alt_set_flash_algorithm_func( alt_flash_cfi_dev* flash)
{
   3267c:	defffd04 	addi	sp,sp,-12
   32680:	df000215 	stw	fp,8(sp)
   32684:	df000204 	addi	fp,sp,8
   32688:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
   3268c:	e03ffe15 	stw	zero,-8(fp)
 
  switch(flash->algorithm)
   32690:	e0bfff17 	ldw	r2,-4(fp)
   32694:	10802d17 	ldw	r2,180(r2)
   32698:	10c000a0 	cmpeqi	r3,r2,2
   3269c:	1800051e 	bne	r3,zero,326b4 <alt_set_flash_algorithm_func+0x38>
   326a0:	10c000e0 	cmpeqi	r3,r2,3
   326a4:	18000c1e 	bne	r3,zero,326d8 <alt_set_flash_algorithm_func+0x5c>
   326a8:	10800060 	cmpeqi	r2,r2,1
   326ac:	10000a1e 	bne	r2,zero,326d8 <alt_set_flash_algorithm_func+0x5c>
   326b0:	00001206 	br	326fc <alt_set_flash_algorithm_func+0x80>
  {
    case CFI_ALG_AMD:
    {
      flash->dev.erase_block = alt_erase_block_amd;
   326b4:	e0bfff17 	ldw	r2,-4(fp)
   326b8:	00c00134 	movhi	r3,4
   326bc:	18fa3904 	addi	r3,r3,-5916
   326c0:	10c00815 	stw	r3,32(r2)
      flash->dev.write_block = alt_program_amd;
   326c4:	e0bfff17 	ldw	r2,-4(fp)
   326c8:	00c00134 	movhi	r3,4
   326cc:	18fa1f04 	addi	r3,r3,-6020
   326d0:	10c00915 	stw	r3,36(r2)
      break;
   326d4:	00000b06 	br	32704 <alt_set_flash_algorithm_func+0x88>
    }
    case CFI_ALG_INTEL:
    case CFI_ALG_INTEL_STRATA:
    {
      flash->dev.erase_block = alt_erase_block_intel;
   326d8:	e0bfff17 	ldw	r2,-4(fp)
   326dc:	00c00134 	movhi	r3,4
   326e0:	18fb5704 	addi	r3,r3,-4772
   326e4:	10c00815 	stw	r3,32(r2)
      flash->dev.write_block = alt_program_intel;
   326e8:	e0bfff17 	ldw	r2,-4(fp)
   326ec:	00c00134 	movhi	r3,4
   326f0:	18fb3704 	addi	r3,r3,-4900
   326f4:	10c00915 	stw	r3,36(r2)
      break;
   326f8:	00000206 	br	32704 <alt_set_flash_algorithm_func+0x88>
    }
    default:
    {
      ret_code = -EIO;
   326fc:	00bffec4 	movi	r2,-5
   32700:	e0bffe15 	stw	r2,-8(fp)
    }
  } 
  return ret_code;  
   32704:	e0bffe17 	ldw	r2,-8(fp)
}
   32708:	e037883a 	mov	sp,fp
   3270c:	df000017 	ldw	fp,0(sp)
   32710:	dec00104 	addi	sp,sp,4
   32714:	f800283a 	ret

00032718 <alt_read_16bit_query_entry>:
 * read_16bit_query_entry
 * 
 * Read a 16 bit entry from the CFI Query table
 */
static alt_u16 alt_read_16bit_query_entry(alt_flash_cfi_dev* flash, int address)
{
   32718:	defffb04 	addi	sp,sp,-20
   3271c:	dfc00415 	stw	ra,16(sp)
   32720:	df000315 	stw	fp,12(sp)
   32724:	df000304 	addi	fp,sp,12
   32728:	e13ffe15 	stw	r4,-8(fp)
   3272c:	e17fff15 	stw	r5,-4(fp)
  alt_u16 ret_code;

  ret_code = (*flash->read_query)( flash, address);
   32730:	e0bffe17 	ldw	r2,-8(fp)
   32734:	10803417 	ldw	r2,208(r2)
   32738:	e13ffe17 	ldw	r4,-8(fp)
   3273c:	e17fff17 	ldw	r5,-4(fp)
   32740:	103ee83a 	callr	r2
   32744:	10803fcc 	andi	r2,r2,255
   32748:	e0bffd0d 	sth	r2,-12(fp)
  ret_code |= (((int)(*flash->read_query)(flash, address+1)) << 8);                   
   3274c:	e0bffe17 	ldw	r2,-8(fp)
   32750:	10c03417 	ldw	r3,208(r2)
   32754:	e0bfff17 	ldw	r2,-4(fp)
   32758:	10800044 	addi	r2,r2,1
   3275c:	e13ffe17 	ldw	r4,-8(fp)
   32760:	100b883a 	mov	r5,r2
   32764:	183ee83a 	callr	r3
   32768:	10803fcc 	andi	r2,r2,255
   3276c:	1004923a 	slli	r2,r2,8
   32770:	1007883a 	mov	r3,r2
   32774:	e0bffd0b 	ldhu	r2,-12(fp)
   32778:	1884b03a 	or	r2,r3,r2
   3277c:	e0bffd0d 	sth	r2,-12(fp)

  return ret_code;
   32780:	e0bffd0b 	ldhu	r2,-12(fp)
}
   32784:	e037883a 	mov	sp,fp
   32788:	dfc00117 	ldw	ra,4(sp)
   3278c:	df000017 	ldw	fp,0(sp)
   32790:	dec00204 	addi	sp,sp,8
   32794:	f800283a 	ret

00032798 <alt_read_cfi_table>:
 * read_cfi_table
 * 
 * Read the CFI Table
 */
int alt_read_cfi_table(alt_flash_cfi_dev* flash)
{
   32798:	defff304 	addi	sp,sp,-52
   3279c:	dfc00c15 	stw	ra,48(sp)
   327a0:	df000b15 	stw	fp,44(sp)
   327a4:	df000b04 	addi	fp,sp,44
   327a8:	e13fff15 	stw	r4,-4(fp)
  int   i,j;
  int   device_size;
  int   ret_code = 0;
   327ac:	e03ff715 	stw	zero,-36(fp)
  int   size = 0;
   327b0:	e03ff815 	stw	zero,-32(fp)
  int   swap;
  int   typical_timeout;
  int   max_timeout;
  int   offset = 0;
   327b4:	e03ff915 	stw	zero,-28(fp)
   
  /*
  * Check that the Primary Vendor Specific table
  * starts with the letters PRI                                                         
  */
  ret_code = alt_check_primary_table(flash);
   327b8:	e13fff17 	ldw	r4,-4(fp)
   327bc:	00334d00 	call	334d0 <alt_check_primary_table>
   327c0:	e0bff715 	stw	r2,-36(fp)

  if (!ret_code)
   327c4:	e0bff717 	ldw	r2,-36(fp)
   327c8:	10015f1e 	bne	r2,zero,32d48 <alt_read_cfi_table+0x5b0>
  {
    flash->algorithm = (*flash->read_query)(flash, 0x13);
   327cc:	e0bfff17 	ldw	r2,-4(fp)
   327d0:	10803417 	ldw	r2,208(r2)
   327d4:	e13fff17 	ldw	r4,-4(fp)
   327d8:	014004c4 	movi	r5,19
   327dc:	103ee83a 	callr	r2
   327e0:	10c03fcc 	andi	r3,r2,255
   327e4:	e0bfff17 	ldw	r2,-4(fp)
   327e8:	10c02d15 	stw	r3,180(r2)
  
    /* 
     * Let's read the write timeout values from the flash 
     * 
     */
    typical_timeout = (*flash->read_query)( flash, 0x1f);
   327ec:	e0bfff17 	ldw	r2,-4(fp)
   327f0:	10803417 	ldw	r2,208(r2)
   327f4:	e13fff17 	ldw	r4,-4(fp)
   327f8:	014007c4 	movi	r5,31
   327fc:	103ee83a 	callr	r2
   32800:	10803fcc 	andi	r2,r2,255
   32804:	e0bffa15 	stw	r2,-24(fp)
    max_timeout = (*flash->read_query)( flash, 0x23);
   32808:	e0bfff17 	ldw	r2,-4(fp)
   3280c:	10803417 	ldw	r2,208(r2)
   32810:	e13fff17 	ldw	r4,-4(fp)
   32814:	014008c4 	movi	r5,35
   32818:	103ee83a 	callr	r2
   3281c:	10803fcc 	andi	r2,r2,255
   32820:	e0bffb15 	stw	r2,-20(fp)
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
   32824:	e0bffa17 	ldw	r2,-24(fp)
   32828:	10000226 	beq	r2,zero,32834 <alt_read_cfi_table+0x9c>
   3282c:	e0bffb17 	ldw	r2,-20(fp)
   32830:	1000041e 	bne	r2,zero,32844 <alt_read_cfi_table+0xac>
    {
      flash->write_timeout = 1000; /* 1ms should be more than enough */
   32834:	e0bfff17 	ldw	r2,-4(fp)
   32838:	00c0fa04 	movi	r3,1000
   3283c:	10c03015 	stw	r3,192(r2)
   32840:	00000706 	br	32860 <alt_read_cfi_table+0xc8>
    }
    else
    {
      flash->write_timeout = (1 << typical_timeout) * (1 << max_timeout);
   32844:	00c00044 	movi	r3,1
   32848:	e0bffa17 	ldw	r2,-24(fp)
   3284c:	1886983a 	sll	r3,r3,r2
   32850:	e0bffb17 	ldw	r2,-20(fp)
   32854:	1886983a 	sll	r3,r3,r2
   32858:	e0bfff17 	ldw	r2,-4(fp)
   3285c:	10c03015 	stw	r3,192(r2)
    }
   
    /* Let's read the block erase timeout values from the flash */
    typical_timeout = (*flash->read_query)( flash, 0x21);
   32860:	e0bfff17 	ldw	r2,-4(fp)
   32864:	10803417 	ldw	r2,208(r2)
   32868:	e13fff17 	ldw	r4,-4(fp)
   3286c:	01400844 	movi	r5,33
   32870:	103ee83a 	callr	r2
   32874:	10803fcc 	andi	r2,r2,255
   32878:	e0bffa15 	stw	r2,-24(fp)
    max_timeout = (*flash->read_query)( flash, 0x25);
   3287c:	e0bfff17 	ldw	r2,-4(fp)
   32880:	10803417 	ldw	r2,208(r2)
   32884:	e13fff17 	ldw	r4,-4(fp)
   32888:	01400944 	movi	r5,37
   3288c:	103ee83a 	callr	r2
   32890:	10803fcc 	andi	r2,r2,255
   32894:	e0bffb15 	stw	r2,-20(fp)
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
   32898:	e0bffa17 	ldw	r2,-24(fp)
   3289c:	10000226 	beq	r2,zero,328a8 <alt_read_cfi_table+0x110>
   328a0:	e0bffb17 	ldw	r2,-20(fp)
   328a4:	1000051e 	bne	r2,zero,328bc <alt_read_cfi_table+0x124>
    {
      flash->erase_timeout = 20000000; /* 20s should be more than enough */
   328a8:	e0bfff17 	ldw	r2,-4(fp)
   328ac:	00c04c74 	movhi	r3,305
   328b0:	18cb4004 	addi	r3,r3,11520
   328b4:	10c03115 	stw	r3,196(r2)
   328b8:	00000806 	br	328dc <alt_read_cfi_table+0x144>
    }
    else
    {
      flash->erase_timeout = (1 << typical_timeout) * (1 << max_timeout) * 1000;
   328bc:	00c00044 	movi	r3,1
   328c0:	e0bffa17 	ldw	r2,-24(fp)
   328c4:	1886983a 	sll	r3,r3,r2
   328c8:	e0bffb17 	ldw	r2,-20(fp)
   328cc:	1884983a 	sll	r2,r3,r2
   328d0:	10c0fa24 	muli	r3,r2,1000
   328d4:	e0bfff17 	ldw	r2,-4(fp)
   328d8:	10c03115 	stw	r3,196(r2)
    }
   
    device_size = 0x1 << (*flash->read_query)( flash, 0x27);
   328dc:	e0bfff17 	ldw	r2,-4(fp)
   328e0:	10803417 	ldw	r2,208(r2)
   328e4:	e13fff17 	ldw	r4,-4(fp)
   328e8:	014009c4 	movi	r5,39
   328ec:	103ee83a 	callr	r2
   328f0:	10803fcc 	andi	r2,r2,255
   328f4:	00c00044 	movi	r3,1
   328f8:	1884983a 	sll	r2,r3,r2
   328fc:	e0bffc15 	stw	r2,-16(fp)
  
    flash->dev.number_of_regions = (*flash->read_query)(flash, 0x2c);
   32900:	e0bfff17 	ldw	r2,-4(fp)
   32904:	10803417 	ldw	r2,208(r2)
   32908:	e13fff17 	ldw	r4,-4(fp)
   3290c:	01400b04 	movi	r5,44
   32910:	103ee83a 	callr	r2
   32914:	10c03fcc 	andi	r3,r2,255
   32918:	e0bfff17 	ldw	r2,-4(fp)
   3291c:	10c00c15 	stw	r3,48(r2)
    
    if (flash->dev.number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
   32920:	e0bfff17 	ldw	r2,-4(fp)
   32924:	10800c17 	ldw	r2,48(r2)
   32928:	10800250 	cmplti	r2,r2,9
   3292c:	1000031e 	bne	r2,zero,3293c <alt_read_cfi_table+0x1a4>
    {
      ret_code = -ENOMEM;
   32930:	00bffd04 	movi	r2,-12
   32934:	e0bff715 	stw	r2,-36(fp)
   32938:	00006006 	br	32abc <alt_read_cfi_table+0x324>
    }
    else
    {
      for(i=0;i<flash->dev.number_of_regions;i++)
   3293c:	e03ff515 	stw	zero,-44(fp)
   32940:	00005506 	br	32a98 <alt_read_cfi_table+0x300>
      {
        flash->dev.region_info[i].number_of_blocks =  alt_read_16bit_query_entry( 
                                                            flash,
                                                            (0x2D+i*4));
   32944:	e0bff517 	ldw	r2,-44(fp)
   32948:	1085883a 	add	r2,r2,r2
   3294c:	1085883a 	add	r2,r2,r2
    }
    else
    {
      for(i=0;i<flash->dev.number_of_regions;i++)
      {
        flash->dev.region_info[i].number_of_blocks =  alt_read_16bit_query_entry( 
   32950:	10800b44 	addi	r2,r2,45
   32954:	e13fff17 	ldw	r4,-4(fp)
   32958:	100b883a 	mov	r5,r2
   3295c:	00327180 	call	32718 <alt_read_16bit_query_entry>
   32960:	10ffffcc 	andi	r3,r2,65535
   32964:	e13fff17 	ldw	r4,-4(fp)
   32968:	e0bff517 	ldw	r2,-44(fp)
   3296c:	1004913a 	slli	r2,r2,4
   32970:	2085883a 	add	r2,r4,r2
   32974:	10800f04 	addi	r2,r2,60
   32978:	10c00015 	stw	r3,0(r2)
                                                            flash,
                                                            (0x2D+i*4));
        flash->dev.region_info[i].number_of_blocks += 1; 
   3297c:	e0ffff17 	ldw	r3,-4(fp)
   32980:	e0bff517 	ldw	r2,-44(fp)
   32984:	1004913a 	slli	r2,r2,4
   32988:	1885883a 	add	r2,r3,r2
   3298c:	10800f04 	addi	r2,r2,60
   32990:	10800017 	ldw	r2,0(r2)
   32994:	10c00044 	addi	r3,r2,1
   32998:	e13fff17 	ldw	r4,-4(fp)
   3299c:	e0bff517 	ldw	r2,-44(fp)
   329a0:	1004913a 	slli	r2,r2,4
   329a4:	2085883a 	add	r2,r4,r2
   329a8:	10800f04 	addi	r2,r2,60
   329ac:	10c00015 	stw	r3,0(r2)
        flash->dev.region_info[i].block_size =  alt_read_16bit_query_entry( flash, 
                                                              (0x2F+i*4));
   329b0:	e0bff517 	ldw	r2,-44(fp)
   329b4:	1085883a 	add	r2,r2,r2
   329b8:	1085883a 	add	r2,r2,r2
      {
        flash->dev.region_info[i].number_of_blocks =  alt_read_16bit_query_entry( 
                                                            flash,
                                                            (0x2D+i*4));
        flash->dev.region_info[i].number_of_blocks += 1; 
        flash->dev.region_info[i].block_size =  alt_read_16bit_query_entry( flash, 
   329bc:	10800bc4 	addi	r2,r2,47
   329c0:	e13fff17 	ldw	r4,-4(fp)
   329c4:	100b883a 	mov	r5,r2
   329c8:	00327180 	call	32718 <alt_read_16bit_query_entry>
   329cc:	10ffffcc 	andi	r3,r2,65535
   329d0:	e13fff17 	ldw	r4,-4(fp)
   329d4:	e0bff517 	ldw	r2,-44(fp)
   329d8:	10800104 	addi	r2,r2,4
   329dc:	1004913a 	slli	r2,r2,4
   329e0:	2085883a 	add	r2,r4,r2
   329e4:	10c00015 	stw	r3,0(r2)
                                                              (0x2F+i*4));
        flash->dev.region_info[i].block_size *= 256;
   329e8:	e0ffff17 	ldw	r3,-4(fp)
   329ec:	e0bff517 	ldw	r2,-44(fp)
   329f0:	10800104 	addi	r2,r2,4
   329f4:	1004913a 	slli	r2,r2,4
   329f8:	1885883a 	add	r2,r3,r2
   329fc:	10800017 	ldw	r2,0(r2)
   32a00:	1006923a 	slli	r3,r2,8
   32a04:	e13fff17 	ldw	r4,-4(fp)
   32a08:	e0bff517 	ldw	r2,-44(fp)
   32a0c:	10800104 	addi	r2,r2,4
   32a10:	1004913a 	slli	r2,r2,4
   32a14:	2085883a 	add	r2,r4,r2
   32a18:	10c00015 	stw	r3,0(r2)
        flash->dev.region_info[i].region_size = 
                                    flash->dev.region_info[i].number_of_blocks 
   32a1c:	e0ffff17 	ldw	r3,-4(fp)
   32a20:	e0bff517 	ldw	r2,-44(fp)
   32a24:	1004913a 	slli	r2,r2,4
   32a28:	1885883a 	add	r2,r3,r2
   32a2c:	10800f04 	addi	r2,r2,60
   32a30:	10c00017 	ldw	r3,0(r2)
                                    * flash->dev.region_info[i].block_size;
   32a34:	e13fff17 	ldw	r4,-4(fp)
   32a38:	e0bff517 	ldw	r2,-44(fp)
   32a3c:	10800104 	addi	r2,r2,4
   32a40:	1004913a 	slli	r2,r2,4
   32a44:	2085883a 	add	r2,r4,r2
   32a48:	10800017 	ldw	r2,0(r2)
   32a4c:	1887383a 	mul	r3,r3,r2
                                                            (0x2D+i*4));
        flash->dev.region_info[i].number_of_blocks += 1; 
        flash->dev.region_info[i].block_size =  alt_read_16bit_query_entry( flash, 
                                                              (0x2F+i*4));
        flash->dev.region_info[i].block_size *= 256;
        flash->dev.region_info[i].region_size = 
   32a50:	e13fff17 	ldw	r4,-4(fp)
   32a54:	e0bff517 	ldw	r2,-44(fp)
   32a58:	1004913a 	slli	r2,r2,4
   32a5c:	2085883a 	add	r2,r4,r2
   32a60:	10800e04 	addi	r2,r2,56
   32a64:	10c00015 	stw	r3,0(r2)
                                    flash->dev.region_info[i].number_of_blocks 
                                    * flash->dev.region_info[i].block_size;
        size += flash->dev.region_info[i].region_size;
   32a68:	e0ffff17 	ldw	r3,-4(fp)
   32a6c:	e0bff517 	ldw	r2,-44(fp)
   32a70:	1004913a 	slli	r2,r2,4
   32a74:	1885883a 	add	r2,r3,r2
   32a78:	10800e04 	addi	r2,r2,56
   32a7c:	10800017 	ldw	r2,0(r2)
   32a80:	e0fff817 	ldw	r3,-32(fp)
   32a84:	1885883a 	add	r2,r3,r2
   32a88:	e0bff815 	stw	r2,-32(fp)
    {
      ret_code = -ENOMEM;
    }
    else
    {
      for(i=0;i<flash->dev.number_of_regions;i++)
   32a8c:	e0bff517 	ldw	r2,-44(fp)
   32a90:	10800044 	addi	r2,r2,1
   32a94:	e0bff515 	stw	r2,-44(fp)
   32a98:	e0bfff17 	ldw	r2,-4(fp)
   32a9c:	10800c17 	ldw	r2,48(r2)
   32aa0:	e0fff517 	ldw	r3,-44(fp)
   32aa4:	18bfa716 	blt	r3,r2,32944 <alt_read_cfi_table+0x1ac>
                                    flash->dev.region_info[i].number_of_blocks 
                                    * flash->dev.region_info[i].block_size;
        size += flash->dev.region_info[i].region_size;
      }
       
      if (size != device_size)
   32aa8:	e0fff817 	ldw	r3,-32(fp)
   32aac:	e0bffc17 	ldw	r2,-16(fp)
   32ab0:	18800226 	beq	r3,r2,32abc <alt_read_cfi_table+0x324>
      {
        ret_code = -ENODEV;
   32ab4:	00bffb44 	movi	r2,-19
   32ab8:	e0bff715 	stw	r2,-36(fp)
      }
    }
    
    boot_mode = (*flash->read_query)( flash, flash->primary_address + 0xf);
   32abc:	e0bfff17 	ldw	r2,-4(fp)
   32ac0:	10c03417 	ldw	r3,208(r2)
   32ac4:	e0bfff17 	ldw	r2,-4(fp)
   32ac8:	10803217 	ldw	r2,200(r2)
   32acc:	108003c4 	addi	r2,r2,15
   32ad0:	e13fff17 	ldw	r4,-4(fp)
   32ad4:	100b883a 	mov	r5,r2
   32ad8:	183ee83a 	callr	r3
   32adc:	e0bffd05 	stb	r2,-12(fp)
     * Intel Flash parts describe the sections in the order they appear
     * for AMD they just put all the small ones first then the bigger ones
     * So if it's a top boot part we have to reverse the order of the sectors
     * so they're in the correct order
     */
    if ((flash->algorithm == CFI_ALG_AMD) && (boot_mode == TOP_BOOT_DEVICE))
   32ae0:	e0bfff17 	ldw	r2,-4(fp)
   32ae4:	10802d17 	ldw	r2,180(r2)
   32ae8:	10800098 	cmpnei	r2,r2,2
   32aec:	1000601e 	bne	r2,zero,32c70 <alt_read_cfi_table+0x4d8>
   32af0:	e0bffd03 	ldbu	r2,-12(fp)
   32af4:	108000d8 	cmpnei	r2,r2,3
   32af8:	10005d1e 	bne	r2,zero,32c70 <alt_read_cfi_table+0x4d8>
    {
      for(i=flash->dev.number_of_regions-1, j=0;
   32afc:	e0bfff17 	ldw	r2,-4(fp)
   32b00:	10800c17 	ldw	r2,48(r2)
   32b04:	10bfffc4 	addi	r2,r2,-1
   32b08:	e0bff515 	stw	r2,-44(fp)
   32b0c:	e03ff615 	stw	zero,-40(fp)
   32b10:	00005406 	br	32c64 <alt_read_cfi_table+0x4cc>
          j<=i;i--,j++)
      {
        swap = flash->dev.region_info[i].region_size;
   32b14:	e0ffff17 	ldw	r3,-4(fp)
   32b18:	e0bff517 	ldw	r2,-44(fp)
   32b1c:	1004913a 	slli	r2,r2,4
   32b20:	1885883a 	add	r2,r3,r2
   32b24:	10800e04 	addi	r2,r2,56
   32b28:	10800017 	ldw	r2,0(r2)
   32b2c:	e0bffe15 	stw	r2,-8(fp)
        flash->dev.region_info[i].region_size =  
                                flash->dev.region_info[j].region_size;
   32b30:	e0ffff17 	ldw	r3,-4(fp)
   32b34:	e0bff617 	ldw	r2,-40(fp)
   32b38:	1004913a 	slli	r2,r2,4
   32b3c:	1885883a 	add	r2,r3,r2
   32b40:	10800e04 	addi	r2,r2,56
   32b44:	10c00017 	ldw	r3,0(r2)
    {
      for(i=flash->dev.number_of_regions-1, j=0;
          j<=i;i--,j++)
      {
        swap = flash->dev.region_info[i].region_size;
        flash->dev.region_info[i].region_size =  
   32b48:	e13fff17 	ldw	r4,-4(fp)
   32b4c:	e0bff517 	ldw	r2,-44(fp)
   32b50:	1004913a 	slli	r2,r2,4
   32b54:	2085883a 	add	r2,r4,r2
   32b58:	10800e04 	addi	r2,r2,56
   32b5c:	10c00015 	stw	r3,0(r2)
                                flash->dev.region_info[j].region_size;
        flash->dev.region_info[j].region_size = swap;
   32b60:	e0ffff17 	ldw	r3,-4(fp)
   32b64:	e0bff617 	ldw	r2,-40(fp)
   32b68:	1004913a 	slli	r2,r2,4
   32b6c:	1885883a 	add	r2,r3,r2
   32b70:	10800e04 	addi	r2,r2,56
   32b74:	e0fffe17 	ldw	r3,-8(fp)
   32b78:	10c00015 	stw	r3,0(r2)

        swap = flash->dev.region_info[i].block_size;
   32b7c:	e0ffff17 	ldw	r3,-4(fp)
   32b80:	e0bff517 	ldw	r2,-44(fp)
   32b84:	10800104 	addi	r2,r2,4
   32b88:	1004913a 	slli	r2,r2,4
   32b8c:	1885883a 	add	r2,r3,r2
   32b90:	10800017 	ldw	r2,0(r2)
   32b94:	e0bffe15 	stw	r2,-8(fp)
        flash->dev.region_info[i].block_size =  
                                flash->dev.region_info[j].block_size;
   32b98:	e0ffff17 	ldw	r3,-4(fp)
   32b9c:	e0bff617 	ldw	r2,-40(fp)
   32ba0:	10800104 	addi	r2,r2,4
   32ba4:	1004913a 	slli	r2,r2,4
   32ba8:	1885883a 	add	r2,r3,r2
   32bac:	10c00017 	ldw	r3,0(r2)
        flash->dev.region_info[i].region_size =  
                                flash->dev.region_info[j].region_size;
        flash->dev.region_info[j].region_size = swap;

        swap = flash->dev.region_info[i].block_size;
        flash->dev.region_info[i].block_size =  
   32bb0:	e13fff17 	ldw	r4,-4(fp)
   32bb4:	e0bff517 	ldw	r2,-44(fp)
   32bb8:	10800104 	addi	r2,r2,4
   32bbc:	1004913a 	slli	r2,r2,4
   32bc0:	2085883a 	add	r2,r4,r2
   32bc4:	10c00015 	stw	r3,0(r2)
                                flash->dev.region_info[j].block_size;
        flash->dev.region_info[j].block_size = swap;
   32bc8:	e0ffff17 	ldw	r3,-4(fp)
   32bcc:	e0bff617 	ldw	r2,-40(fp)
   32bd0:	10800104 	addi	r2,r2,4
   32bd4:	1004913a 	slli	r2,r2,4
   32bd8:	1885883a 	add	r2,r3,r2
   32bdc:	e0fffe17 	ldw	r3,-8(fp)
   32be0:	10c00015 	stw	r3,0(r2)
 
        swap = flash->dev.region_info[i].number_of_blocks;
   32be4:	e0ffff17 	ldw	r3,-4(fp)
   32be8:	e0bff517 	ldw	r2,-44(fp)
   32bec:	1004913a 	slli	r2,r2,4
   32bf0:	1885883a 	add	r2,r3,r2
   32bf4:	10800f04 	addi	r2,r2,60
   32bf8:	10800017 	ldw	r2,0(r2)
   32bfc:	e0bffe15 	stw	r2,-8(fp)
        flash->dev.region_info[i].number_of_blocks =  
                                flash->dev.region_info[j].number_of_blocks;
   32c00:	e0ffff17 	ldw	r3,-4(fp)
   32c04:	e0bff617 	ldw	r2,-40(fp)
   32c08:	1004913a 	slli	r2,r2,4
   32c0c:	1885883a 	add	r2,r3,r2
   32c10:	10800f04 	addi	r2,r2,60
   32c14:	10c00017 	ldw	r3,0(r2)
        flash->dev.region_info[i].block_size =  
                                flash->dev.region_info[j].block_size;
        flash->dev.region_info[j].block_size = swap;
 
        swap = flash->dev.region_info[i].number_of_blocks;
        flash->dev.region_info[i].number_of_blocks =  
   32c18:	e13fff17 	ldw	r4,-4(fp)
   32c1c:	e0bff517 	ldw	r2,-44(fp)
   32c20:	1004913a 	slli	r2,r2,4
   32c24:	2085883a 	add	r2,r4,r2
   32c28:	10800f04 	addi	r2,r2,60
   32c2c:	10c00015 	stw	r3,0(r2)
                                flash->dev.region_info[j].number_of_blocks;
        flash->dev.region_info[j].number_of_blocks = swap;
   32c30:	e0ffff17 	ldw	r3,-4(fp)
   32c34:	e0bff617 	ldw	r2,-40(fp)
   32c38:	1004913a 	slli	r2,r2,4
   32c3c:	1885883a 	add	r2,r3,r2
   32c40:	10800f04 	addi	r2,r2,60
   32c44:	e0fffe17 	ldw	r3,-8(fp)
   32c48:	10c00015 	stw	r3,0(r2)
     * so they're in the correct order
     */
    if ((flash->algorithm == CFI_ALG_AMD) && (boot_mode == TOP_BOOT_DEVICE))
    {
      for(i=flash->dev.number_of_regions-1, j=0;
          j<=i;i--,j++)
   32c4c:	e0bff517 	ldw	r2,-44(fp)
   32c50:	10bfffc4 	addi	r2,r2,-1
   32c54:	e0bff515 	stw	r2,-44(fp)
   32c58:	e0bff617 	ldw	r2,-40(fp)
   32c5c:	10800044 	addi	r2,r2,1
   32c60:	e0bff615 	stw	r2,-40(fp)
     * So if it's a top boot part we have to reverse the order of the sectors
     * so they're in the correct order
     */
    if ((flash->algorithm == CFI_ALG_AMD) && (boot_mode == TOP_BOOT_DEVICE))
    {
      for(i=flash->dev.number_of_regions-1, j=0;
   32c64:	e0bff617 	ldw	r2,-40(fp)
   32c68:	e0fff517 	ldw	r3,-44(fp)
   32c6c:	18bfa90e 	bge	r3,r2,32b14 <alt_read_cfi_table+0x37c>
        flash->dev.region_info[j].number_of_blocks = swap;

      } 
    }
    
    for(i=0;i<flash->dev.number_of_regions;i++)
   32c70:	e03ff515 	stw	zero,-44(fp)
   32c74:	00001306 	br	32cc4 <alt_read_cfi_table+0x52c>
    {
      flash->dev.region_info[i].offset = offset;
   32c78:	e0ffff17 	ldw	r3,-4(fp)
   32c7c:	e0bff517 	ldw	r2,-44(fp)
   32c80:	1004913a 	slli	r2,r2,4
   32c84:	1885883a 	add	r2,r3,r2
   32c88:	10800d04 	addi	r2,r2,52
   32c8c:	e0fff917 	ldw	r3,-28(fp)
   32c90:	10c00015 	stw	r3,0(r2)
      offset += flash->dev.region_info[i].region_size;
   32c94:	e0ffff17 	ldw	r3,-4(fp)
   32c98:	e0bff517 	ldw	r2,-44(fp)
   32c9c:	1004913a 	slli	r2,r2,4
   32ca0:	1885883a 	add	r2,r3,r2
   32ca4:	10800e04 	addi	r2,r2,56
   32ca8:	10800017 	ldw	r2,0(r2)
   32cac:	e0fff917 	ldw	r3,-28(fp)
   32cb0:	1885883a 	add	r2,r3,r2
   32cb4:	e0bff915 	stw	r2,-28(fp)
        flash->dev.region_info[j].number_of_blocks = swap;

      } 
    }
    
    for(i=0;i<flash->dev.number_of_regions;i++)
   32cb8:	e0bff517 	ldw	r2,-44(fp)
   32cbc:	10800044 	addi	r2,r2,1
   32cc0:	e0bff515 	stw	r2,-44(fp)
   32cc4:	e0bfff17 	ldw	r2,-4(fp)
   32cc8:	10800c17 	ldw	r2,48(r2)
   32ccc:	e0fff517 	ldw	r3,-44(fp)
   32cd0:	18bfe916 	blt	r3,r2,32c78 <alt_read_cfi_table+0x4e0>
    {
      flash->dev.region_info[i].offset = offset;
      offset += flash->dev.region_info[i].region_size;
    }

    switch(flash->algorithm)
   32cd4:	e0bfff17 	ldw	r2,-4(fp)
   32cd8:	10802d17 	ldw	r2,180(r2)
   32cdc:	10c000a0 	cmpeqi	r3,r2,2
   32ce0:	1800051e 	bne	r3,zero,32cf8 <alt_read_cfi_table+0x560>
   32ce4:	10c000e0 	cmpeqi	r3,r2,3
   32ce8:	18000c1e 	bne	r3,zero,32d1c <alt_read_cfi_table+0x584>
   32cec:	10800060 	cmpeqi	r2,r2,1
   32cf0:	10000a1e 	bne	r2,zero,32d1c <alt_read_cfi_table+0x584>
   32cf4:	00001206 	br	32d40 <alt_read_cfi_table+0x5a8>
    {
      case CFI_ALG_AMD:
      {
        (*flash->write_command)(flash->dev.base_addr, 
   32cf8:	e0bfff17 	ldw	r2,-4(fp)
   32cfc:	10c03317 	ldw	r3,204(r2)
   32d00:	e0bfff17 	ldw	r2,-4(fp)
   32d04:	10800a17 	ldw	r2,40(r2)
   32d08:	1009883a 	mov	r4,r2
   32d0c:	01401544 	movi	r5,85
   32d10:	01803c04 	movi	r6,240
   32d14:	183ee83a 	callr	r3
                            0x55, 
                            READ_ARRAY_AMD_MODE);
        break;
   32d18:	00000b06 	br	32d48 <alt_read_cfi_table+0x5b0>
      }
      case CFI_ALG_INTEL:
      case CFI_ALG_INTEL_STRATA:
      {
        (*flash->write_command)(flash->dev.base_addr, 
   32d1c:	e0bfff17 	ldw	r2,-4(fp)
   32d20:	10c03317 	ldw	r3,204(r2)
   32d24:	e0bfff17 	ldw	r2,-4(fp)
   32d28:	10800a17 	ldw	r2,40(r2)
   32d2c:	1009883a 	mov	r4,r2
   32d30:	01401544 	movi	r5,85
   32d34:	01803fc4 	movi	r6,255
   32d38:	183ee83a 	callr	r3
                            0x55, 
                            READ_ARRAY_INTEL_MODE);
        break;
   32d3c:	00000206 	br	32d48 <alt_read_cfi_table+0x5b0>
      }
      default:
      {
        ret_code = -EIO;
   32d40:	00bffec4 	movi	r2,-5
   32d44:	e0bff715 	stw	r2,-36(fp)
      }
    } 
  }  

  return ret_code;
   32d48:	e0bff717 	ldw	r2,-36(fp)
}
   32d4c:	e037883a 	mov	sp,fp
   32d50:	dfc00117 	ldw	ra,4(sp)
   32d54:	df000017 	ldw	fp,0(sp)
   32d58:	dec00204 	addi	sp,sp,8
   32d5c:	f800283a 	ret

00032d60 <alt_read_cfi_width>:
 * 
 * Work out the width of the device we're talking to and sanity check that we  
 * can read the CFI and the Primary Vendor specific Table
 */
int alt_read_cfi_width(alt_flash_cfi_dev* flash)
{
   32d60:	defff704 	addi	sp,sp,-36
   32d64:	dfc00815 	stw	ra,32(sp)
   32d68:	df000715 	stw	fp,28(sp)
   32d6c:	df000704 	addi	fp,sp,28
   32d70:	e13fff15 	stw	r4,-4(fp)
  int i;
  alt_u8 byte_id[12];
  alt_u16 iface;
  int ret_code = 0;
   32d74:	e03ffa15 	stw	zero,-24(fp)

  /*
  * Check for 8 bit wide flash
  */
  alt_write_flash_command_8bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
   32d78:	e0bfff17 	ldw	r2,-4(fp)
   32d7c:	10800a17 	ldw	r2,40(r2)
   32d80:	1009883a 	mov	r4,r2
   32d84:	01401544 	movi	r5,85
   32d88:	01802604 	movi	r6,152
   32d8c:	00322300 	call	32230 <alt_write_flash_command_8bit_device_8bit_mode>

  for(i=0;i<3;i++)
   32d90:	e03ff915 	stw	zero,-28(fp)
   32d94:	00000f06 	br	32dd4 <alt_read_cfi_width+0x74>
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
   32d98:	e0bfff17 	ldw	r2,-4(fp)
   32d9c:	10c00a17 	ldw	r3,40(r2)
   32da0:	e0bff917 	ldw	r2,-28(fp)
   32da4:	10800404 	addi	r2,r2,16
   32da8:	1885883a 	add	r2,r3,r2
   32dac:	10800023 	ldbuio	r2,0(r2)
   32db0:	10803fcc 	andi	r2,r2,255
   32db4:	1007883a 	mov	r3,r2
   32db8:	e13ffb84 	addi	r4,fp,-18
   32dbc:	e0bff917 	ldw	r2,-28(fp)
   32dc0:	2085883a 	add	r2,r4,r2
   32dc4:	10c00005 	stb	r3,0(r2)
  /*
  * Check for 8 bit wide flash
  */
  alt_write_flash_command_8bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);

  for(i=0;i<3;i++)
   32dc8:	e0bff917 	ldw	r2,-28(fp)
   32dcc:	10800044 	addi	r2,r2,1
   32dd0:	e0bff915 	stw	r2,-28(fp)
   32dd4:	e0bff917 	ldw	r2,-28(fp)
   32dd8:	108000d0 	cmplti	r2,r2,3
   32ddc:	103fee1e 	bne	r2,zero,32d98 <alt_read_cfi_width+0x38>
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
  }

  if ((byte_id[0] == 'Q') &&
   32de0:	e0bffb83 	ldbu	r2,-18(fp)
   32de4:	10803fcc 	andi	r2,r2,255
   32de8:	10801458 	cmpnei	r2,r2,81
   32dec:	10001d1e 	bne	r2,zero,32e64 <alt_read_cfi_width+0x104>
      (byte_id[1] == 'R') &&
   32df0:	e0bffbc3 	ldbu	r2,-17(fp)
  for(i=0;i<3;i++)
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
  }

  if ((byte_id[0] == 'Q') &&
   32df4:	10803fcc 	andi	r2,r2,255
   32df8:	10801498 	cmpnei	r2,r2,82
   32dfc:	1000191e 	bne	r2,zero,32e64 <alt_read_cfi_width+0x104>
      (byte_id[1] == 'R') &&
      (byte_id[2] == 'Y'))
   32e00:	e0bffc03 	ldbu	r2,-16(fp)
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
  }

  if ((byte_id[0] == 'Q') &&
      (byte_id[1] == 'R') &&
   32e04:	10803fcc 	andi	r2,r2,255
   32e08:	10801658 	cmpnei	r2,r2,89
   32e0c:	1000151e 	bne	r2,zero,32e64 <alt_read_cfi_width+0x104>
      (byte_id[2] == 'Y'))
  {
    flash->mode_width = 1;
   32e10:	e0bfff17 	ldw	r2,-4(fp)
   32e14:	00c00044 	movi	r3,1
   32e18:	10c02e15 	stw	r3,184(r2)
    flash->device_width = 1; 
   32e1c:	e0bfff17 	ldw	r2,-4(fp)
   32e20:	00c00044 	movi	r3,1
   32e24:	10c02f15 	stw	r3,188(r2)
    iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR);
   32e28:	e0bfff17 	ldw	r2,-4(fp)
   32e2c:	10800a17 	ldw	r2,40(r2)
   32e30:	10800a04 	addi	r2,r2,40
   32e34:	1080002b 	ldhuio	r2,0(r2)
   32e38:	10bfffcc 	andi	r2,r2,65535
   32e3c:	e0bffb0d 	sth	r2,-20(fp)
    iface += 1;
   32e40:	e0bffb0b 	ldhu	r2,-20(fp)
   32e44:	10800044 	addi	r2,r2,1
   32e48:	e0bffb0d 	sth	r2,-20(fp)
    if (!(iface & 0x1))
   32e4c:	e0bffb0b 	ldhu	r2,-20(fp)
   32e50:	1080004c 	andi	r2,r2,1
   32e54:	1001981e 	bne	r2,zero,334b8 <alt_read_cfi_width+0x758>
    {
      ret_code = -ENODEV;
   32e58:	00bffb44 	movi	r2,-19
   32e5c:	e0bffa15 	stw	r2,-24(fp)
  {
    flash->mode_width = 1;
    flash->device_width = 1; 
    iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR);
    iface += 1;
    if (!(iface & 0x1))
   32e60:	00019506 	br	334b8 <alt_read_cfi_width+0x758>
  else
  {
    /*
    * Check for 8/16 bit in byte wide mode
    */
    alt_write_flash_command_16bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
   32e64:	e0bfff17 	ldw	r2,-4(fp)
   32e68:	10800a17 	ldw	r2,40(r2)
   32e6c:	1009883a 	mov	r4,r2
   32e70:	01401544 	movi	r5,85
   32e74:	01802604 	movi	r6,152
   32e78:	00322740 	call	32274 <alt_write_flash_command_16bit_device_8bit_mode>
    for(i=0;i<6;i++)
   32e7c:	e03ff915 	stw	zero,-28(fp)
   32e80:	00000f06 	br	32ec0 <alt_read_cfi_width+0x160>
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
   32e84:	e0bfff17 	ldw	r2,-4(fp)
   32e88:	10c00a17 	ldw	r3,40(r2)
   32e8c:	e0bff917 	ldw	r2,-28(fp)
   32e90:	10800804 	addi	r2,r2,32
   32e94:	1885883a 	add	r2,r3,r2
   32e98:	10800023 	ldbuio	r2,0(r2)
   32e9c:	10803fcc 	andi	r2,r2,255
   32ea0:	1007883a 	mov	r3,r2
   32ea4:	e13ffb84 	addi	r4,fp,-18
   32ea8:	e0bff917 	ldw	r2,-28(fp)
   32eac:	2085883a 	add	r2,r4,r2
   32eb0:	10c00005 	stb	r3,0(r2)
  {
    /*
    * Check for 8/16 bit in byte wide mode
    */
    alt_write_flash_command_16bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
    for(i=0;i<6;i++)
   32eb4:	e0bff917 	ldw	r2,-28(fp)
   32eb8:	10800044 	addi	r2,r2,1
   32ebc:	e0bff915 	stw	r2,-28(fp)
   32ec0:	e0bff917 	ldw	r2,-28(fp)
   32ec4:	10800190 	cmplti	r2,r2,6
   32ec8:	103fee1e 	bne	r2,zero,32e84 <alt_read_cfi_width+0x124>
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
    }

    if ((byte_id[0] == 'Q') && 
   32ecc:	e0bffb83 	ldbu	r2,-18(fp)
   32ed0:	10803fcc 	andi	r2,r2,255
   32ed4:	10801458 	cmpnei	r2,r2,81
   32ed8:	1000291e 	bne	r2,zero,32f80 <alt_read_cfi_width+0x220>
        (byte_id[1] == 'Q') && 
   32edc:	e0bffbc3 	ldbu	r2,-17(fp)
    for(i=0;i<6;i++)
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
    }

    if ((byte_id[0] == 'Q') && 
   32ee0:	10803fcc 	andi	r2,r2,255
   32ee4:	10801458 	cmpnei	r2,r2,81
   32ee8:	1000251e 	bne	r2,zero,32f80 <alt_read_cfi_width+0x220>
        (byte_id[1] == 'Q') && 
        (byte_id[2] == 'R') &&
   32eec:	e0bffc03 	ldbu	r2,-16(fp)
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
    }

    if ((byte_id[0] == 'Q') && 
        (byte_id[1] == 'Q') && 
   32ef0:	10803fcc 	andi	r2,r2,255
   32ef4:	10801498 	cmpnei	r2,r2,82
   32ef8:	1000211e 	bne	r2,zero,32f80 <alt_read_cfi_width+0x220>
        (byte_id[2] == 'R') &&
        (byte_id[3] == 'R') && 
   32efc:	e0bffc43 	ldbu	r2,-15(fp)
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
    }

    if ((byte_id[0] == 'Q') && 
        (byte_id[1] == 'Q') && 
        (byte_id[2] == 'R') &&
   32f00:	10803fcc 	andi	r2,r2,255
   32f04:	10801498 	cmpnei	r2,r2,82
   32f08:	10001d1e 	bne	r2,zero,32f80 <alt_read_cfi_width+0x220>
        (byte_id[3] == 'R') && 
        (byte_id[4] == 'Y') && 
   32f0c:	e0bffc83 	ldbu	r2,-14(fp)
    }

    if ((byte_id[0] == 'Q') && 
        (byte_id[1] == 'Q') && 
        (byte_id[2] == 'R') &&
        (byte_id[3] == 'R') && 
   32f10:	10803fcc 	andi	r2,r2,255
   32f14:	10801658 	cmpnei	r2,r2,89
   32f18:	1000191e 	bne	r2,zero,32f80 <alt_read_cfi_width+0x220>
        (byte_id[4] == 'Y') && 
        (byte_id[5] == 'Y'))
   32f1c:	e0bffcc3 	ldbu	r2,-13(fp)

    if ((byte_id[0] == 'Q') && 
        (byte_id[1] == 'Q') && 
        (byte_id[2] == 'R') &&
        (byte_id[3] == 'R') && 
        (byte_id[4] == 'Y') && 
   32f20:	10803fcc 	andi	r2,r2,255
   32f24:	10801658 	cmpnei	r2,r2,89
   32f28:	1000151e 	bne	r2,zero,32f80 <alt_read_cfi_width+0x220>
        (byte_id[5] == 'Y'))
    {
      flash->mode_width = 1;
   32f2c:	e0bfff17 	ldw	r2,-4(fp)
   32f30:	00c00044 	movi	r3,1
   32f34:	10c02e15 	stw	r3,184(r2)
      flash->device_width = 2; 
   32f38:	e0bfff17 	ldw	r2,-4(fp)
   32f3c:	00c00084 	movi	r3,2
   32f40:	10c02f15 	stw	r3,188(r2)
      iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR*2);
   32f44:	e0bfff17 	ldw	r2,-4(fp)
   32f48:	10800a17 	ldw	r2,40(r2)
   32f4c:	10801404 	addi	r2,r2,80
   32f50:	1080002b 	ldhuio	r2,0(r2)
   32f54:	10bfffcc 	andi	r2,r2,65535
   32f58:	e0bffb0d 	sth	r2,-20(fp)
      iface += 1;
   32f5c:	e0bffb0b 	ldhu	r2,-20(fp)
   32f60:	10800044 	addi	r2,r2,1
   32f64:	e0bffb0d 	sth	r2,-20(fp)
      if (!(iface & 0x1))
   32f68:	e0bffb0b 	ldhu	r2,-20(fp)
   32f6c:	1080004c 	andi	r2,r2,1
   32f70:	1001511e 	bne	r2,zero,334b8 <alt_read_cfi_width+0x758>
      {
        ret_code = -ENODEV;
   32f74:	00bffb44 	movi	r2,-19
   32f78:	e0bffa15 	stw	r2,-24(fp)
    {
      flash->mode_width = 1;
      flash->device_width = 2; 
      iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR*2);
      iface += 1;
      if (!(iface & 0x1))
   32f7c:	00014e06 	br	334b8 <alt_read_cfi_width+0x758>
    else
    {
      /*
      * Check for 16 bit flash in word mode
      */
      alt_write_flash_command_16bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
   32f80:	e0bfff17 	ldw	r2,-4(fp)
   32f84:	10800a17 	ldw	r2,40(r2)
   32f88:	1009883a 	mov	r4,r2
   32f8c:	01401544 	movi	r5,85
   32f90:	01802604 	movi	r6,152
   32f94:	00323340 	call	32334 <alt_write_flash_command_16bit_device_16bit_mode>
      for(i=0;i<6;i++)
   32f98:	e03ff915 	stw	zero,-28(fp)
   32f9c:	00000f06 	br	32fdc <alt_read_cfi_width+0x27c>
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
   32fa0:	e0bfff17 	ldw	r2,-4(fp)
   32fa4:	10c00a17 	ldw	r3,40(r2)
   32fa8:	e0bff917 	ldw	r2,-28(fp)
   32fac:	10800804 	addi	r2,r2,32
   32fb0:	1885883a 	add	r2,r3,r2
   32fb4:	10800023 	ldbuio	r2,0(r2)
   32fb8:	10803fcc 	andi	r2,r2,255
   32fbc:	1007883a 	mov	r3,r2
   32fc0:	e13ffb84 	addi	r4,fp,-18
   32fc4:	e0bff917 	ldw	r2,-28(fp)
   32fc8:	2085883a 	add	r2,r4,r2
   32fcc:	10c00005 	stb	r3,0(r2)
    {
      /*
      * Check for 16 bit flash in word mode
      */
      alt_write_flash_command_16bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
      for(i=0;i<6;i++)
   32fd0:	e0bff917 	ldw	r2,-28(fp)
   32fd4:	10800044 	addi	r2,r2,1
   32fd8:	e0bff915 	stw	r2,-28(fp)
   32fdc:	e0bff917 	ldw	r2,-28(fp)
   32fe0:	10800190 	cmplti	r2,r2,6
   32fe4:	103fee1e 	bne	r2,zero,32fa0 <alt_read_cfi_width+0x240>
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
      }

      if ((byte_id[0] == 'Q') && 
   32fe8:	e0bffb83 	ldbu	r2,-18(fp)
   32fec:	10803fcc 	andi	r2,r2,255
   32ff0:	10801458 	cmpnei	r2,r2,81
   32ff4:	1000261e 	bne	r2,zero,33090 <alt_read_cfi_width+0x330>
          (byte_id[1] == '\0') && 
   32ff8:	e0bffbc3 	ldbu	r2,-17(fp)
      for(i=0;i<6;i++)
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
      }

      if ((byte_id[0] == 'Q') && 
   32ffc:	10803fcc 	andi	r2,r2,255
   33000:	1000231e 	bne	r2,zero,33090 <alt_read_cfi_width+0x330>
          (byte_id[1] == '\0') && 
          (byte_id[2] == 'R') && 
   33004:	e0bffc03 	ldbu	r2,-16(fp)
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
      }

      if ((byte_id[0] == 'Q') && 
          (byte_id[1] == '\0') && 
   33008:	10803fcc 	andi	r2,r2,255
   3300c:	10801498 	cmpnei	r2,r2,82
   33010:	10001f1e 	bne	r2,zero,33090 <alt_read_cfi_width+0x330>
          (byte_id[2] == 'R') && 
          (byte_id[3] == '\0') && 
   33014:	e0bffc43 	ldbu	r2,-15(fp)
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
      }

      if ((byte_id[0] == 'Q') && 
          (byte_id[1] == '\0') && 
          (byte_id[2] == 'R') && 
   33018:	10803fcc 	andi	r2,r2,255
   3301c:	10001c1e 	bne	r2,zero,33090 <alt_read_cfi_width+0x330>
          (byte_id[3] == '\0') && 
          (byte_id[4] == 'Y') && 
   33020:	e0bffc83 	ldbu	r2,-14(fp)
      }

      if ((byte_id[0] == 'Q') && 
          (byte_id[1] == '\0') && 
          (byte_id[2] == 'R') && 
          (byte_id[3] == '\0') && 
   33024:	10803fcc 	andi	r2,r2,255
   33028:	10801658 	cmpnei	r2,r2,89
   3302c:	1000181e 	bne	r2,zero,33090 <alt_read_cfi_width+0x330>
          (byte_id[4] == 'Y') && 
          (byte_id[5] == '\0'))
   33030:	e0bffcc3 	ldbu	r2,-13(fp)

      if ((byte_id[0] == 'Q') && 
          (byte_id[1] == '\0') && 
          (byte_id[2] == 'R') && 
          (byte_id[3] == '\0') && 
          (byte_id[4] == 'Y') && 
   33034:	10803fcc 	andi	r2,r2,255
   33038:	1000151e 	bne	r2,zero,33090 <alt_read_cfi_width+0x330>
          (byte_id[5] == '\0'))
      {
        flash->mode_width = 2;
   3303c:	e0bfff17 	ldw	r2,-4(fp)
   33040:	00c00084 	movi	r3,2
   33044:	10c02e15 	stw	r3,184(r2)
        flash->device_width = 2; 
   33048:	e0bfff17 	ldw	r2,-4(fp)
   3304c:	00c00084 	movi	r3,2
   33050:	10c02f15 	stw	r3,188(r2)
        iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR*2);
   33054:	e0bfff17 	ldw	r2,-4(fp)
   33058:	10800a17 	ldw	r2,40(r2)
   3305c:	10801404 	addi	r2,r2,80
   33060:	1080002b 	ldhuio	r2,0(r2)
   33064:	10bfffcc 	andi	r2,r2,65535
   33068:	e0bffb0d 	sth	r2,-20(fp)
        iface += 1;
   3306c:	e0bffb0b 	ldhu	r2,-20(fp)
   33070:	10800044 	addi	r2,r2,1
   33074:	e0bffb0d 	sth	r2,-20(fp)
        if (!(iface & 0x2))
   33078:	e0bffb0b 	ldhu	r2,-20(fp)
   3307c:	1080008c 	andi	r2,r2,2
   33080:	10010d1e 	bne	r2,zero,334b8 <alt_read_cfi_width+0x758>
        {
          ret_code = -ENODEV;
   33084:	00bffb44 	movi	r2,-19
   33088:	e0bffa15 	stw	r2,-24(fp)
      {
        flash->mode_width = 2;
        flash->device_width = 2; 
        iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR*2);
        iface += 1;
        if (!(iface & 0x2))
   3308c:	00010a06 	br	334b8 <alt_read_cfi_width+0x758>
      else
      {
        /*
        * Check for 32bit wide flash in 32 bit mode
        */
        alt_write_flash_command_32bit_device_32bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
   33090:	e0bfff17 	ldw	r2,-4(fp)
   33094:	10800a17 	ldw	r2,40(r2)
   33098:	1009883a 	mov	r4,r2
   3309c:	01401544 	movi	r5,85
   330a0:	01802604 	movi	r6,152
   330a4:	00323c80 	call	323c8 <alt_write_flash_command_32bit_device_32bit_mode>
        for(i=0;i<12;i++)
   330a8:	e03ff915 	stw	zero,-28(fp)
   330ac:	00000f06 	br	330ec <alt_read_cfi_width+0x38c>
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
   330b0:	e0bfff17 	ldw	r2,-4(fp)
   330b4:	10c00a17 	ldw	r3,40(r2)
   330b8:	e0bff917 	ldw	r2,-28(fp)
   330bc:	10801004 	addi	r2,r2,64
   330c0:	1885883a 	add	r2,r3,r2
   330c4:	10800023 	ldbuio	r2,0(r2)
   330c8:	10803fcc 	andi	r2,r2,255
   330cc:	1007883a 	mov	r3,r2
   330d0:	e13ffb84 	addi	r4,fp,-18
   330d4:	e0bff917 	ldw	r2,-28(fp)
   330d8:	2085883a 	add	r2,r4,r2
   330dc:	10c00005 	stb	r3,0(r2)
      {
        /*
        * Check for 32bit wide flash in 32 bit mode
        */
        alt_write_flash_command_32bit_device_32bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
        for(i=0;i<12;i++)
   330e0:	e0bff917 	ldw	r2,-28(fp)
   330e4:	10800044 	addi	r2,r2,1
   330e8:	e0bff915 	stw	r2,-28(fp)
   330ec:	e0bff917 	ldw	r2,-28(fp)
   330f0:	10800310 	cmplti	r2,r2,12
   330f4:	103fee1e 	bne	r2,zero,330b0 <alt_read_cfi_width+0x350>
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
        }

        if ((byte_id[0] == 'Q') &&
   330f8:	e0bffb83 	ldbu	r2,-18(fp)
   330fc:	10803fcc 	andi	r2,r2,255
   33100:	10801458 	cmpnei	r2,r2,81
   33104:	1000371e 	bne	r2,zero,331e4 <alt_read_cfi_width+0x484>
          (byte_id[1] == '\0') && 
   33108:	e0bffbc3 	ldbu	r2,-17(fp)
        for(i=0;i<12;i++)
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
        }

        if ((byte_id[0] == 'Q') &&
   3310c:	10803fcc 	andi	r2,r2,255
   33110:	1000341e 	bne	r2,zero,331e4 <alt_read_cfi_width+0x484>
          (byte_id[1] == '\0') && 
          (byte_id[2] == '\0') && 
   33114:	e0bffc03 	ldbu	r2,-16(fp)
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
        }

        if ((byte_id[0] == 'Q') &&
          (byte_id[1] == '\0') && 
   33118:	10803fcc 	andi	r2,r2,255
   3311c:	1000311e 	bne	r2,zero,331e4 <alt_read_cfi_width+0x484>
          (byte_id[2] == '\0') && 
          (byte_id[3] == '\0') && 
   33120:	e0bffc43 	ldbu	r2,-15(fp)
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
        }

        if ((byte_id[0] == 'Q') &&
          (byte_id[1] == '\0') && 
          (byte_id[2] == '\0') && 
   33124:	10803fcc 	andi	r2,r2,255
   33128:	10002e1e 	bne	r2,zero,331e4 <alt_read_cfi_width+0x484>
          (byte_id[3] == '\0') && 
          (byte_id[4] == 'R') && 
   3312c:	e0bffc83 	ldbu	r2,-14(fp)
        }

        if ((byte_id[0] == 'Q') &&
          (byte_id[1] == '\0') && 
          (byte_id[2] == '\0') && 
          (byte_id[3] == '\0') && 
   33130:	10803fcc 	andi	r2,r2,255
   33134:	10801498 	cmpnei	r2,r2,82
   33138:	10002a1e 	bne	r2,zero,331e4 <alt_read_cfi_width+0x484>
          (byte_id[4] == 'R') && 
          (byte_id[5] == '\0') && 
   3313c:	e0bffcc3 	ldbu	r2,-13(fp)

        if ((byte_id[0] == 'Q') &&
          (byte_id[1] == '\0') && 
          (byte_id[2] == '\0') && 
          (byte_id[3] == '\0') && 
          (byte_id[4] == 'R') && 
   33140:	10803fcc 	andi	r2,r2,255
   33144:	1000271e 	bne	r2,zero,331e4 <alt_read_cfi_width+0x484>
          (byte_id[5] == '\0') && 
          (byte_id[6] == '\0') && 
   33148:	e0bffd03 	ldbu	r2,-12(fp)
        if ((byte_id[0] == 'Q') &&
          (byte_id[1] == '\0') && 
          (byte_id[2] == '\0') && 
          (byte_id[3] == '\0') && 
          (byte_id[4] == 'R') && 
          (byte_id[5] == '\0') && 
   3314c:	10803fcc 	andi	r2,r2,255
   33150:	1000241e 	bne	r2,zero,331e4 <alt_read_cfi_width+0x484>
          (byte_id[6] == '\0') && 
          (byte_id[7] == '\0') && 
   33154:	e0bffd43 	ldbu	r2,-11(fp)
          (byte_id[1] == '\0') && 
          (byte_id[2] == '\0') && 
          (byte_id[3] == '\0') && 
          (byte_id[4] == 'R') && 
          (byte_id[5] == '\0') && 
          (byte_id[6] == '\0') && 
   33158:	10803fcc 	andi	r2,r2,255
   3315c:	1000211e 	bne	r2,zero,331e4 <alt_read_cfi_width+0x484>
          (byte_id[7] == '\0') && 
          (byte_id[8] == 'Y') && 
   33160:	e0bffd83 	ldbu	r2,-10(fp)
          (byte_id[2] == '\0') && 
          (byte_id[3] == '\0') && 
          (byte_id[4] == 'R') && 
          (byte_id[5] == '\0') && 
          (byte_id[6] == '\0') && 
          (byte_id[7] == '\0') && 
   33164:	10803fcc 	andi	r2,r2,255
   33168:	10801658 	cmpnei	r2,r2,89
   3316c:	10001d1e 	bne	r2,zero,331e4 <alt_read_cfi_width+0x484>
          (byte_id[8] == 'Y') && 
          (byte_id[9] == '\0') && 
   33170:	e0bffdc3 	ldbu	r2,-9(fp)
          (byte_id[3] == '\0') && 
          (byte_id[4] == 'R') && 
          (byte_id[5] == '\0') && 
          (byte_id[6] == '\0') && 
          (byte_id[7] == '\0') && 
          (byte_id[8] == 'Y') && 
   33174:	10803fcc 	andi	r2,r2,255
   33178:	10001a1e 	bne	r2,zero,331e4 <alt_read_cfi_width+0x484>
          (byte_id[9] == '\0') && 
          (byte_id[10] == '\0') && 
   3317c:	e0bffe03 	ldbu	r2,-8(fp)
          (byte_id[4] == 'R') && 
          (byte_id[5] == '\0') && 
          (byte_id[6] == '\0') && 
          (byte_id[7] == '\0') && 
          (byte_id[8] == 'Y') && 
          (byte_id[9] == '\0') && 
   33180:	10803fcc 	andi	r2,r2,255
   33184:	1000171e 	bne	r2,zero,331e4 <alt_read_cfi_width+0x484>
          (byte_id[10] == '\0') && 
          (byte_id[11] == '\0'))
   33188:	e0bffe43 	ldbu	r2,-7(fp)
          (byte_id[5] == '\0') && 
          (byte_id[6] == '\0') && 
          (byte_id[7] == '\0') && 
          (byte_id[8] == 'Y') && 
          (byte_id[9] == '\0') && 
          (byte_id[10] == '\0') && 
   3318c:	10803fcc 	andi	r2,r2,255
   33190:	1000141e 	bne	r2,zero,331e4 <alt_read_cfi_width+0x484>
          (byte_id[11] == '\0'))
        {
          flash->mode_width = 4;
   33194:	e0bfff17 	ldw	r2,-4(fp)
   33198:	00c00104 	movi	r3,4
   3319c:	10c02e15 	stw	r3,184(r2)
          flash->device_width = 4; 
   331a0:	e0bfff17 	ldw	r2,-4(fp)
   331a4:	00c00104 	movi	r3,4
   331a8:	10c02f15 	stw	r3,188(r2)
          iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
   331ac:	e0bfff17 	ldw	r2,-4(fp)
   331b0:	10800a17 	ldw	r2,40(r2)
   331b4:	10802804 	addi	r2,r2,160
   331b8:	10800037 	ldwio	r2,0(r2)
   331bc:	e0bffb0d 	sth	r2,-20(fp)
          iface += 1;
   331c0:	e0bffb0b 	ldhu	r2,-20(fp)
   331c4:	10800044 	addi	r2,r2,1
   331c8:	e0bffb0d 	sth	r2,-20(fp)
          if (!(iface & 0x4))
   331cc:	e0bffb0b 	ldhu	r2,-20(fp)
   331d0:	1080010c 	andi	r2,r2,4
   331d4:	1000b81e 	bne	r2,zero,334b8 <alt_read_cfi_width+0x758>
          {
            ret_code = -ENODEV;
   331d8:	00bffb44 	movi	r2,-19
   331dc:	e0bffa15 	stw	r2,-24(fp)
        {
          flash->mode_width = 4;
          flash->device_width = 4; 
          iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
          iface += 1;
          if (!(iface & 0x4))
   331e0:	0000b506 	br	334b8 <alt_read_cfi_width+0x758>
        else
        {
          /*
          * Check for 32 bit wide in 16 bit mode
          */
          alt_write_flash_command_32bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
   331e4:	e0bfff17 	ldw	r2,-4(fp)
   331e8:	10800a17 	ldw	r2,40(r2)
   331ec:	1009883a 	mov	r4,r2
   331f0:	01401544 	movi	r5,85
   331f4:	01802604 	movi	r6,152
   331f8:	003237c0 	call	3237c <alt_write_flash_command_32bit_device_16bit_mode>
          for(i=0;i<12;i++)
   331fc:	e03ff915 	stw	zero,-28(fp)
   33200:	00000f06 	br	33240 <alt_read_cfi_width+0x4e0>
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
   33204:	e0bfff17 	ldw	r2,-4(fp)
   33208:	10c00a17 	ldw	r3,40(r2)
   3320c:	e0bff917 	ldw	r2,-28(fp)
   33210:	10801004 	addi	r2,r2,64
   33214:	1885883a 	add	r2,r3,r2
   33218:	10800023 	ldbuio	r2,0(r2)
   3321c:	10803fcc 	andi	r2,r2,255
   33220:	1007883a 	mov	r3,r2
   33224:	e13ffb84 	addi	r4,fp,-18
   33228:	e0bff917 	ldw	r2,-28(fp)
   3322c:	2085883a 	add	r2,r4,r2
   33230:	10c00005 	stb	r3,0(r2)
        {
          /*
          * Check for 32 bit wide in 16 bit mode
          */
          alt_write_flash_command_32bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
          for(i=0;i<12;i++)
   33234:	e0bff917 	ldw	r2,-28(fp)
   33238:	10800044 	addi	r2,r2,1
   3323c:	e0bff915 	stw	r2,-28(fp)
   33240:	e0bff917 	ldw	r2,-28(fp)
   33244:	10800310 	cmplti	r2,r2,12
   33248:	103fee1e 	bne	r2,zero,33204 <alt_read_cfi_width+0x4a4>
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
          }

          if ((byte_id[0] == 'Q') &&
   3324c:	e0bffb83 	ldbu	r2,-18(fp)
   33250:	10803fcc 	andi	r2,r2,255
   33254:	10801458 	cmpnei	r2,r2,81
   33258:	10003a1e 	bne	r2,zero,33344 <alt_read_cfi_width+0x5e4>
              (byte_id[1] == '\0') &&
   3325c:	e0bffbc3 	ldbu	r2,-17(fp)
          for(i=0;i<12;i++)
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
          }

          if ((byte_id[0] == 'Q') &&
   33260:	10803fcc 	andi	r2,r2,255
   33264:	1000371e 	bne	r2,zero,33344 <alt_read_cfi_width+0x5e4>
              (byte_id[1] == '\0') &&
              (byte_id[2] == 'Q') &&
   33268:	e0bffc03 	ldbu	r2,-16(fp)
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
          }

          if ((byte_id[0] == 'Q') &&
              (byte_id[1] == '\0') &&
   3326c:	10803fcc 	andi	r2,r2,255
   33270:	10801458 	cmpnei	r2,r2,81
   33274:	1000331e 	bne	r2,zero,33344 <alt_read_cfi_width+0x5e4>
              (byte_id[2] == 'Q') &&
              (byte_id[3] == '\0') &&
   33278:	e0bffc43 	ldbu	r2,-15(fp)
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
          }

          if ((byte_id[0] == 'Q') &&
              (byte_id[1] == '\0') &&
              (byte_id[2] == 'Q') &&
   3327c:	10803fcc 	andi	r2,r2,255
   33280:	1000301e 	bne	r2,zero,33344 <alt_read_cfi_width+0x5e4>
              (byte_id[3] == '\0') &&
              (byte_id[4] == 'R') &&
   33284:	e0bffc83 	ldbu	r2,-14(fp)
          }

          if ((byte_id[0] == 'Q') &&
              (byte_id[1] == '\0') &&
              (byte_id[2] == 'Q') &&
              (byte_id[3] == '\0') &&
   33288:	10803fcc 	andi	r2,r2,255
   3328c:	10801498 	cmpnei	r2,r2,82
   33290:	10002c1e 	bne	r2,zero,33344 <alt_read_cfi_width+0x5e4>
              (byte_id[4] == 'R') &&
              (byte_id[5] == '\0') &&
   33294:	e0bffcc3 	ldbu	r2,-13(fp)

          if ((byte_id[0] == 'Q') &&
              (byte_id[1] == '\0') &&
              (byte_id[2] == 'Q') &&
              (byte_id[3] == '\0') &&
              (byte_id[4] == 'R') &&
   33298:	10803fcc 	andi	r2,r2,255
   3329c:	1000291e 	bne	r2,zero,33344 <alt_read_cfi_width+0x5e4>
              (byte_id[5] == '\0') &&
              (byte_id[6] == 'R') &&
   332a0:	e0bffd03 	ldbu	r2,-12(fp)
          if ((byte_id[0] == 'Q') &&
              (byte_id[1] == '\0') &&
              (byte_id[2] == 'Q') &&
              (byte_id[3] == '\0') &&
              (byte_id[4] == 'R') &&
              (byte_id[5] == '\0') &&
   332a4:	10803fcc 	andi	r2,r2,255
   332a8:	10801498 	cmpnei	r2,r2,82
   332ac:	1000251e 	bne	r2,zero,33344 <alt_read_cfi_width+0x5e4>
              (byte_id[6] == 'R') &&
              (byte_id[7] == '\0') &&
   332b0:	e0bffd43 	ldbu	r2,-11(fp)
              (byte_id[1] == '\0') &&
              (byte_id[2] == 'Q') &&
              (byte_id[3] == '\0') &&
              (byte_id[4] == 'R') &&
              (byte_id[5] == '\0') &&
              (byte_id[6] == 'R') &&
   332b4:	10803fcc 	andi	r2,r2,255
   332b8:	1000221e 	bne	r2,zero,33344 <alt_read_cfi_width+0x5e4>
              (byte_id[7] == '\0') &&
              (byte_id[8] == 'Y') &&
   332bc:	e0bffd83 	ldbu	r2,-10(fp)
              (byte_id[2] == 'Q') &&
              (byte_id[3] == '\0') &&
              (byte_id[4] == 'R') &&
              (byte_id[5] == '\0') &&
              (byte_id[6] == 'R') &&
              (byte_id[7] == '\0') &&
   332c0:	10803fcc 	andi	r2,r2,255
   332c4:	10801658 	cmpnei	r2,r2,89
   332c8:	10001e1e 	bne	r2,zero,33344 <alt_read_cfi_width+0x5e4>
              (byte_id[8] == 'Y') &&
              (byte_id[9] == '\0') &&
   332cc:	e0bffdc3 	ldbu	r2,-9(fp)
              (byte_id[3] == '\0') &&
              (byte_id[4] == 'R') &&
              (byte_id[5] == '\0') &&
              (byte_id[6] == 'R') &&
              (byte_id[7] == '\0') &&
              (byte_id[8] == 'Y') &&
   332d0:	10803fcc 	andi	r2,r2,255
   332d4:	10001b1e 	bne	r2,zero,33344 <alt_read_cfi_width+0x5e4>
              (byte_id[9] == '\0') &&
              (byte_id[10] == 'Y') &&
   332d8:	e0bffe03 	ldbu	r2,-8(fp)
              (byte_id[4] == 'R') &&
              (byte_id[5] == '\0') &&
              (byte_id[6] == 'R') &&
              (byte_id[7] == '\0') &&
              (byte_id[8] == 'Y') &&
              (byte_id[9] == '\0') &&
   332dc:	10803fcc 	andi	r2,r2,255
   332e0:	10801658 	cmpnei	r2,r2,89
   332e4:	1000171e 	bne	r2,zero,33344 <alt_read_cfi_width+0x5e4>
              (byte_id[10] == 'Y') &&
              (byte_id[11] == '\0'))
   332e8:	e0bffe43 	ldbu	r2,-7(fp)
              (byte_id[5] == '\0') &&
              (byte_id[6] == 'R') &&
              (byte_id[7] == '\0') &&
              (byte_id[8] == 'Y') &&
              (byte_id[9] == '\0') &&
              (byte_id[10] == 'Y') &&
   332ec:	10803fcc 	andi	r2,r2,255
   332f0:	1000141e 	bne	r2,zero,33344 <alt_read_cfi_width+0x5e4>
              (byte_id[11] == '\0'))
          {
            flash->mode_width = 2;
   332f4:	e0bfff17 	ldw	r2,-4(fp)
   332f8:	00c00084 	movi	r3,2
   332fc:	10c02e15 	stw	r3,184(r2)
            flash->device_width = 4; 
   33300:	e0bfff17 	ldw	r2,-4(fp)
   33304:	00c00104 	movi	r3,4
   33308:	10c02f15 	stw	r3,188(r2)
            iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
   3330c:	e0bfff17 	ldw	r2,-4(fp)
   33310:	10800a17 	ldw	r2,40(r2)
   33314:	10802804 	addi	r2,r2,160
   33318:	10800037 	ldwio	r2,0(r2)
   3331c:	e0bffb0d 	sth	r2,-20(fp)
            iface += 1;
   33320:	e0bffb0b 	ldhu	r2,-20(fp)
   33324:	10800044 	addi	r2,r2,1
   33328:	e0bffb0d 	sth	r2,-20(fp)
            if (!(iface & 0x4))
   3332c:	e0bffb0b 	ldhu	r2,-20(fp)
   33330:	1080010c 	andi	r2,r2,4
   33334:	1000601e 	bne	r2,zero,334b8 <alt_read_cfi_width+0x758>
            {
              ret_code = -ENODEV;
   33338:	00bffb44 	movi	r2,-19
   3333c:	e0bffa15 	stw	r2,-24(fp)
          {
            flash->mode_width = 2;
            flash->device_width = 4; 
            iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
            iface += 1;
            if (!(iface & 0x4))
   33340:	00005d06 	br	334b8 <alt_read_cfi_width+0x758>
          else
          {
            /*
            * 32 Bit wide flash in byte mode
            */
            alt_write_flash_command_32bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
   33344:	e0bfff17 	ldw	r2,-4(fp)
   33348:	10800a17 	ldw	r2,40(r2)
   3334c:	1009883a 	mov	r4,r2
   33350:	01401544 	movi	r5,85
   33354:	01802604 	movi	r6,152
   33358:	00322e80 	call	322e8 <alt_write_flash_command_32bit_device_8bit_mode>
            for(i=0;i<12;i++)
   3335c:	e03ff915 	stw	zero,-28(fp)
   33360:	00000f06 	br	333a0 <alt_read_cfi_width+0x640>
            {
              byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
   33364:	e0bfff17 	ldw	r2,-4(fp)
   33368:	10c00a17 	ldw	r3,40(r2)
   3336c:	e0bff917 	ldw	r2,-28(fp)
   33370:	10801004 	addi	r2,r2,64
   33374:	1885883a 	add	r2,r3,r2
   33378:	10800023 	ldbuio	r2,0(r2)
   3337c:	10803fcc 	andi	r2,r2,255
   33380:	1007883a 	mov	r3,r2
   33384:	e13ffb84 	addi	r4,fp,-18
   33388:	e0bff917 	ldw	r2,-28(fp)
   3338c:	2085883a 	add	r2,r4,r2
   33390:	10c00005 	stb	r3,0(r2)
          {
            /*
            * 32 Bit wide flash in byte mode
            */
            alt_write_flash_command_32bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
            for(i=0;i<12;i++)
   33394:	e0bff917 	ldw	r2,-28(fp)
   33398:	10800044 	addi	r2,r2,1
   3339c:	e0bff915 	stw	r2,-28(fp)
   333a0:	e0bff917 	ldw	r2,-28(fp)
   333a4:	10800310 	cmplti	r2,r2,12
   333a8:	103fee1e 	bne	r2,zero,33364 <alt_read_cfi_width+0x604>
            {
              byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
            }

            if ((byte_id[0] == 'Q') &&
   333ac:	e0bffb83 	ldbu	r2,-18(fp)
   333b0:	10803fcc 	andi	r2,r2,255
   333b4:	10801458 	cmpnei	r2,r2,81
   333b8:	10003f1e 	bne	r2,zero,334b8 <alt_read_cfi_width+0x758>
                (byte_id[1] == 'Q') &&
   333bc:	e0bffbc3 	ldbu	r2,-17(fp)
            for(i=0;i<12;i++)
            {
              byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
            }

            if ((byte_id[0] == 'Q') &&
   333c0:	10803fcc 	andi	r2,r2,255
   333c4:	10801458 	cmpnei	r2,r2,81
   333c8:	10003b1e 	bne	r2,zero,334b8 <alt_read_cfi_width+0x758>
                (byte_id[1] == 'Q') &&
                (byte_id[2] == 'Q') &&
   333cc:	e0bffc03 	ldbu	r2,-16(fp)
            {
              byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
            }

            if ((byte_id[0] == 'Q') &&
                (byte_id[1] == 'Q') &&
   333d0:	10803fcc 	andi	r2,r2,255
   333d4:	10801458 	cmpnei	r2,r2,81
   333d8:	1000371e 	bne	r2,zero,334b8 <alt_read_cfi_width+0x758>
                (byte_id[2] == 'Q') &&
                (byte_id[3] == 'Q') &&
   333dc:	e0bffc43 	ldbu	r2,-15(fp)
              byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
            }

            if ((byte_id[0] == 'Q') &&
                (byte_id[1] == 'Q') &&
                (byte_id[2] == 'Q') &&
   333e0:	10803fcc 	andi	r2,r2,255
   333e4:	10801458 	cmpnei	r2,r2,81
   333e8:	1000331e 	bne	r2,zero,334b8 <alt_read_cfi_width+0x758>
                (byte_id[3] == 'Q') &&
                (byte_id[4] == 'R') && 
   333ec:	e0bffc83 	ldbu	r2,-14(fp)
            }

            if ((byte_id[0] == 'Q') &&
                (byte_id[1] == 'Q') &&
                (byte_id[2] == 'Q') &&
                (byte_id[3] == 'Q') &&
   333f0:	10803fcc 	andi	r2,r2,255
   333f4:	10801498 	cmpnei	r2,r2,82
   333f8:	10002f1e 	bne	r2,zero,334b8 <alt_read_cfi_width+0x758>
                (byte_id[4] == 'R') && 
                (byte_id[5] == 'R') && 
   333fc:	e0bffcc3 	ldbu	r2,-13(fp)

            if ((byte_id[0] == 'Q') &&
                (byte_id[1] == 'Q') &&
                (byte_id[2] == 'Q') &&
                (byte_id[3] == 'Q') &&
                (byte_id[4] == 'R') && 
   33400:	10803fcc 	andi	r2,r2,255
   33404:	10801498 	cmpnei	r2,r2,82
   33408:	10002b1e 	bne	r2,zero,334b8 <alt_read_cfi_width+0x758>
                (byte_id[5] == 'R') && 
                (byte_id[6] == 'R') && 
   3340c:	e0bffd03 	ldbu	r2,-12(fp)
            if ((byte_id[0] == 'Q') &&
                (byte_id[1] == 'Q') &&
                (byte_id[2] == 'Q') &&
                (byte_id[3] == 'Q') &&
                (byte_id[4] == 'R') && 
                (byte_id[5] == 'R') && 
   33410:	10803fcc 	andi	r2,r2,255
   33414:	10801498 	cmpnei	r2,r2,82
   33418:	1000271e 	bne	r2,zero,334b8 <alt_read_cfi_width+0x758>
                (byte_id[6] == 'R') && 
                (byte_id[7] == 'R') && 
   3341c:	e0bffd43 	ldbu	r2,-11(fp)
                (byte_id[1] == 'Q') &&
                (byte_id[2] == 'Q') &&
                (byte_id[3] == 'Q') &&
                (byte_id[4] == 'R') && 
                (byte_id[5] == 'R') && 
                (byte_id[6] == 'R') && 
   33420:	10803fcc 	andi	r2,r2,255
   33424:	10801498 	cmpnei	r2,r2,82
   33428:	1000231e 	bne	r2,zero,334b8 <alt_read_cfi_width+0x758>
                (byte_id[7] == 'R') && 
                (byte_id[8] == 'Y') && 
   3342c:	e0bffd83 	ldbu	r2,-10(fp)
                (byte_id[2] == 'Q') &&
                (byte_id[3] == 'Q') &&
                (byte_id[4] == 'R') && 
                (byte_id[5] == 'R') && 
                (byte_id[6] == 'R') && 
                (byte_id[7] == 'R') && 
   33430:	10803fcc 	andi	r2,r2,255
   33434:	10801658 	cmpnei	r2,r2,89
   33438:	10001f1e 	bne	r2,zero,334b8 <alt_read_cfi_width+0x758>
                (byte_id[8] == 'Y') && 
                (byte_id[9] == 'Y') && 
   3343c:	e0bffdc3 	ldbu	r2,-9(fp)
                (byte_id[3] == 'Q') &&
                (byte_id[4] == 'R') && 
                (byte_id[5] == 'R') && 
                (byte_id[6] == 'R') && 
                (byte_id[7] == 'R') && 
                (byte_id[8] == 'Y') && 
   33440:	10803fcc 	andi	r2,r2,255
   33444:	10801658 	cmpnei	r2,r2,89
   33448:	10001b1e 	bne	r2,zero,334b8 <alt_read_cfi_width+0x758>
                (byte_id[9] == 'Y') && 
                (byte_id[10] == 'Y') && 
   3344c:	e0bffe03 	ldbu	r2,-8(fp)
                (byte_id[4] == 'R') && 
                (byte_id[5] == 'R') && 
                (byte_id[6] == 'R') && 
                (byte_id[7] == 'R') && 
                (byte_id[8] == 'Y') && 
                (byte_id[9] == 'Y') && 
   33450:	10803fcc 	andi	r2,r2,255
   33454:	10801658 	cmpnei	r2,r2,89
   33458:	1000171e 	bne	r2,zero,334b8 <alt_read_cfi_width+0x758>
                (byte_id[10] == 'Y') && 
                (byte_id[11] == 'Y'))
   3345c:	e0bffe43 	ldbu	r2,-7(fp)
                (byte_id[5] == 'R') && 
                (byte_id[6] == 'R') && 
                (byte_id[7] == 'R') && 
                (byte_id[8] == 'Y') && 
                (byte_id[9] == 'Y') && 
                (byte_id[10] == 'Y') && 
   33460:	10803fcc 	andi	r2,r2,255
   33464:	10801658 	cmpnei	r2,r2,89
   33468:	1000131e 	bne	r2,zero,334b8 <alt_read_cfi_width+0x758>
                (byte_id[11] == 'Y'))
            {
              flash->mode_width = 1;
   3346c:	e0bfff17 	ldw	r2,-4(fp)
   33470:	00c00044 	movi	r3,1
   33474:	10c02e15 	stw	r3,184(r2)
              flash->device_width = 4; 
   33478:	e0bfff17 	ldw	r2,-4(fp)
   3347c:	00c00104 	movi	r3,4
   33480:	10c02f15 	stw	r3,188(r2)
              iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
   33484:	e0bfff17 	ldw	r2,-4(fp)
   33488:	10800a17 	ldw	r2,40(r2)
   3348c:	10802804 	addi	r2,r2,160
   33490:	10800037 	ldwio	r2,0(r2)
   33494:	e0bffb0d 	sth	r2,-20(fp)
              iface += 1;
   33498:	e0bffb0b 	ldhu	r2,-20(fp)
   3349c:	10800044 	addi	r2,r2,1
   334a0:	e0bffb0d 	sth	r2,-20(fp)
              if (!(iface & 0x4))
   334a4:	e0bffb0b 	ldhu	r2,-20(fp)
   334a8:	1080010c 	andi	r2,r2,4
   334ac:	1000021e 	bne	r2,zero,334b8 <alt_read_cfi_width+0x758>
              {
                ret_code = -ENODEV;
   334b0:	00bffb44 	movi	r2,-19
   334b4:	e0bffa15 	stw	r2,-24(fp)
        }
      }
    }
  }
  
  return ret_code;
   334b8:	e0bffa17 	ldw	r2,-24(fp)
}
   334bc:	e037883a 	mov	sp,fp
   334c0:	dfc00117 	ldw	ra,4(sp)
   334c4:	df000017 	ldw	fp,0(sp)
   334c8:	dec00204 	addi	sp,sp,8
   334cc:	f800283a 	ret

000334d0 <alt_check_primary_table>:
 * 
 * Check that the primary Vendor table starts with the 
 * correct pattern
 */
int alt_check_primary_table(alt_flash_cfi_dev* flash)
{
   334d0:	defffa04 	addi	sp,sp,-24
   334d4:	dfc00515 	stw	ra,20(sp)
   334d8:	df000415 	stw	fp,16(sp)
   334dc:	df000404 	addi	fp,sp,16
   334e0:	e13fff15 	stw	r4,-4(fp)
  int i;
  int ret_code = 0;
   334e4:	e03ffd15 	stw	zero,-12(fp)
  alt_u8 primary_query_string[3];
  
  flash->primary_address = alt_read_16bit_query_entry( flash, 
   334e8:	e13fff17 	ldw	r4,-4(fp)
   334ec:	01400544 	movi	r5,21
   334f0:	00327180 	call	32718 <alt_read_16bit_query_entry>
   334f4:	10ffffcc 	andi	r3,r2,65535
   334f8:	e0bfff17 	ldw	r2,-4(fp)
   334fc:	10c03215 	stw	r3,200(r2)
                            PRIMARY_ADDR);
  
  for(i=0;i<3;i++)
   33500:	e03ffc15 	stw	zero,-16(fp)
   33504:	00001006 	br	33548 <alt_check_primary_table+0x78>
  {
    primary_query_string[i] = 
          (*flash->read_query)( flash,(flash->primary_address + i));
   33508:	e0bfff17 	ldw	r2,-4(fp)
   3350c:	10c03417 	ldw	r3,208(r2)
   33510:	e0bfff17 	ldw	r2,-4(fp)
   33514:	11003217 	ldw	r4,200(r2)
   33518:	e0bffc17 	ldw	r2,-16(fp)
   3351c:	2085883a 	add	r2,r4,r2
   33520:	e13fff17 	ldw	r4,-4(fp)
   33524:	100b883a 	mov	r5,r2
   33528:	183ee83a 	callr	r3
  flash->primary_address = alt_read_16bit_query_entry( flash, 
                            PRIMARY_ADDR);
  
  for(i=0;i<3;i++)
  {
    primary_query_string[i] = 
   3352c:	e13ffe04 	addi	r4,fp,-8
   33530:	e0fffc17 	ldw	r3,-16(fp)
   33534:	20c7883a 	add	r3,r4,r3
   33538:	18800005 	stb	r2,0(r3)
  alt_u8 primary_query_string[3];
  
  flash->primary_address = alt_read_16bit_query_entry( flash, 
                            PRIMARY_ADDR);
  
  for(i=0;i<3;i++)
   3353c:	e0bffc17 	ldw	r2,-16(fp)
   33540:	10800044 	addi	r2,r2,1
   33544:	e0bffc15 	stw	r2,-16(fp)
   33548:	e0bffc17 	ldw	r2,-16(fp)
   3354c:	108000d0 	cmplti	r2,r2,3
   33550:	103fed1e 	bne	r2,zero,33508 <alt_check_primary_table+0x38>
  {
    primary_query_string[i] = 
          (*flash->read_query)( flash,(flash->primary_address + i));
  }
    
  if ((primary_query_string[0] != 'P') ||
   33554:	e0bffe03 	ldbu	r2,-8(fp)
   33558:	10803fcc 	andi	r2,r2,255
   3355c:	10801418 	cmpnei	r2,r2,80
   33560:	1000081e 	bne	r2,zero,33584 <alt_check_primary_table+0xb4>
      (primary_query_string[1] != 'R') ||
   33564:	e0bffe43 	ldbu	r2,-7(fp)
  {
    primary_query_string[i] = 
          (*flash->read_query)( flash,(flash->primary_address + i));
  }
    
  if ((primary_query_string[0] != 'P') ||
   33568:	10803fcc 	andi	r2,r2,255
   3356c:	10801498 	cmpnei	r2,r2,82
   33570:	1000041e 	bne	r2,zero,33584 <alt_check_primary_table+0xb4>
      (primary_query_string[1] != 'R') ||
      (primary_query_string[2] != 'I'))
   33574:	e0bffe83 	ldbu	r2,-6(fp)
    primary_query_string[i] = 
          (*flash->read_query)( flash,(flash->primary_address + i));
  }
    
  if ((primary_query_string[0] != 'P') ||
      (primary_query_string[1] != 'R') ||
   33578:	10803fcc 	andi	r2,r2,255
   3357c:	10801260 	cmpeqi	r2,r2,73
   33580:	1000021e 	bne	r2,zero,3358c <alt_check_primary_table+0xbc>
      (primary_query_string[2] != 'I'))
  {
    ret_code = -ENODEV;
   33584:	00bffb44 	movi	r2,-19
   33588:	e0bffd15 	stw	r2,-12(fp)
  }
  
  return ret_code;
   3358c:	e0bffd17 	ldw	r2,-12(fp)
}
   33590:	e037883a 	mov	sp,fp
   33594:	dfc00117 	ldw	ra,4(sp)
   33598:	df000017 	ldw	fp,0(sp)
   3359c:	dec00204 	addi	sp,sp,8
   335a0:	f800283a 	ret

000335a4 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
   335a4:	defffa04 	addi	sp,sp,-24
   335a8:	dfc00515 	stw	ra,20(sp)
   335ac:	df000415 	stw	fp,16(sp)
   335b0:	df000404 	addi	fp,sp,16
   335b4:	e13ffd15 	stw	r4,-12(fp)
   335b8:	e17ffe15 	stw	r5,-8(fp)
   335bc:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   335c0:	e0bffd17 	ldw	r2,-12(fp)
   335c4:	10800017 	ldw	r2,0(r2)
   335c8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
   335cc:	e0bffc17 	ldw	r2,-16(fp)
   335d0:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
   335d4:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
   335d8:	10800217 	ldw	r2,8(r2)
   335dc:	1809883a 	mov	r4,r3
   335e0:	e17ffe17 	ldw	r5,-8(fp)
   335e4:	e1bfff17 	ldw	r6,-4(fp)
   335e8:	100f883a 	mov	r7,r2
   335ec:	0033c4c0 	call	33c4c <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
   335f0:	e037883a 	mov	sp,fp
   335f4:	dfc00117 	ldw	ra,4(sp)
   335f8:	df000017 	ldw	fp,0(sp)
   335fc:	dec00204 	addi	sp,sp,8
   33600:	f800283a 	ret

00033604 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
   33604:	defffa04 	addi	sp,sp,-24
   33608:	dfc00515 	stw	ra,20(sp)
   3360c:	df000415 	stw	fp,16(sp)
   33610:	df000404 	addi	fp,sp,16
   33614:	e13ffd15 	stw	r4,-12(fp)
   33618:	e17ffe15 	stw	r5,-8(fp)
   3361c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   33620:	e0bffd17 	ldw	r2,-12(fp)
   33624:	10800017 	ldw	r2,0(r2)
   33628:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
   3362c:	e0bffc17 	ldw	r2,-16(fp)
   33630:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
   33634:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
   33638:	10800217 	ldw	r2,8(r2)
   3363c:	1809883a 	mov	r4,r3
   33640:	e17ffe17 	ldw	r5,-8(fp)
   33644:	e1bfff17 	ldw	r6,-4(fp)
   33648:	100f883a 	mov	r7,r2
   3364c:	0033ed80 	call	33ed8 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
   33650:	e037883a 	mov	sp,fp
   33654:	dfc00117 	ldw	ra,4(sp)
   33658:	df000017 	ldw	fp,0(sp)
   3365c:	dec00204 	addi	sp,sp,8
   33660:	f800283a 	ret

00033664 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
   33664:	defffc04 	addi	sp,sp,-16
   33668:	dfc00315 	stw	ra,12(sp)
   3366c:	df000215 	stw	fp,8(sp)
   33670:	df000204 	addi	fp,sp,8
   33674:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
   33678:	e0bfff17 	ldw	r2,-4(fp)
   3367c:	10800017 	ldw	r2,0(r2)
   33680:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
   33684:	e0bffe17 	ldw	r2,-8(fp)
   33688:	10c00a04 	addi	r3,r2,40
   3368c:	e0bfff17 	ldw	r2,-4(fp)
   33690:	10800217 	ldw	r2,8(r2)
   33694:	1809883a 	mov	r4,r3
   33698:	100b883a 	mov	r5,r2
   3369c:	0033af00 	call	33af0 <altera_avalon_jtag_uart_close>
}
   336a0:	e037883a 	mov	sp,fp
   336a4:	dfc00117 	ldw	ra,4(sp)
   336a8:	df000017 	ldw	fp,0(sp)
   336ac:	dec00204 	addi	sp,sp,8
   336b0:	f800283a 	ret

000336b4 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
   336b4:	defffa04 	addi	sp,sp,-24
   336b8:	dfc00515 	stw	ra,20(sp)
   336bc:	df000415 	stw	fp,16(sp)
   336c0:	df000404 	addi	fp,sp,16
   336c4:	e13ffd15 	stw	r4,-12(fp)
   336c8:	e17ffe15 	stw	r5,-8(fp)
   336cc:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
   336d0:	e0bffd17 	ldw	r2,-12(fp)
   336d4:	10800017 	ldw	r2,0(r2)
   336d8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
   336dc:	e0bffc17 	ldw	r2,-16(fp)
   336e0:	10800a04 	addi	r2,r2,40
   336e4:	1009883a 	mov	r4,r2
   336e8:	e17ffe17 	ldw	r5,-8(fp)
   336ec:	e1bfff17 	ldw	r6,-4(fp)
   336f0:	0033b580 	call	33b58 <altera_avalon_jtag_uart_ioctl>
}
   336f4:	e037883a 	mov	sp,fp
   336f8:	dfc00117 	ldw	ra,4(sp)
   336fc:	df000017 	ldw	fp,0(sp)
   33700:	dec00204 	addi	sp,sp,8
   33704:	f800283a 	ret

00033708 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
   33708:	defff604 	addi	sp,sp,-40
   3370c:	dfc00915 	stw	ra,36(sp)
   33710:	df000815 	stw	fp,32(sp)
   33714:	df000804 	addi	fp,sp,32
   33718:	e13ffd15 	stw	r4,-12(fp)
   3371c:	e17ffe15 	stw	r5,-8(fp)
   33720:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
   33724:	e0bffd17 	ldw	r2,-12(fp)
   33728:	10800a04 	addi	r2,r2,40
   3372c:	e0bff915 	stw	r2,-28(fp)
   33730:	00800044 	movi	r2,1
   33734:	e0bffa0d 	sth	r2,-24(fp)
 * alt_sem_create() is a wrapper for xSemaphoreCreateCounting(). The return value is 0 if 
 * the semaphore has been successfully created, or non-zero otherwise.
 */
static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (xSemaphoreHandle* sem, alt_u16 value)
{
	*sem = xSemaphoreCreateCounting(value ? value : 1, value);
   33738:	e0bffa0b 	ldhu	r2,-24(fp)
   3373c:	10000226 	beq	r2,zero,33748 <altera_avalon_jtag_uart_init+0x40>
   33740:	e0bffa0b 	ldhu	r2,-24(fp)
   33744:	00000106 	br	3374c <altera_avalon_jtag_uart_init+0x44>
   33748:	00800044 	movi	r2,1
   3374c:	e0fffa0b 	ldhu	r3,-24(fp)
   33750:	1009883a 	mov	r4,r2
   33754:	180b883a 	mov	r5,r3
   33758:	000e9040 	call	e904 <xQueueCreateCountingSemaphore>
   3375c:	e0fff917 	ldw	r3,-28(fp)
   33760:	18800015 	stw	r2,0(r3)
  ALT_SEM_CREATE(&sp->write_lock, 1);
   33764:	e0bffd17 	ldw	r2,-12(fp)
   33768:	10800b04 	addi	r2,r2,44
   3376c:	e0bffb15 	stw	r2,-20(fp)
   33770:	00800044 	movi	r2,1
   33774:	e0bffc0d 	sth	r2,-16(fp)
   33778:	e0bffc0b 	ldhu	r2,-16(fp)
   3377c:	10000226 	beq	r2,zero,33788 <altera_avalon_jtag_uart_init+0x80>
   33780:	e0bffc0b 	ldhu	r2,-16(fp)
   33784:	00000106 	br	3378c <altera_avalon_jtag_uart_init+0x84>
   33788:	00800044 	movi	r2,1
   3378c:	e0fffc0b 	ldhu	r3,-16(fp)
   33790:	1009883a 	mov	r4,r2
   33794:	180b883a 	mov	r5,r3
   33798:	000e9040 	call	e904 <xQueueCreateCountingSemaphore>
   3379c:	e0fffb17 	ldw	r3,-20(fp)
   337a0:	18800015 	stw	r2,0(r3)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
   337a4:	e0bffd17 	ldw	r2,-12(fp)
   337a8:	00c00044 	movi	r3,1
   337ac:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
   337b0:	e0bffd17 	ldw	r2,-12(fp)
   337b4:	10800017 	ldw	r2,0(r2)
   337b8:	10800104 	addi	r2,r2,4
   337bc:	e0fffd17 	ldw	r3,-12(fp)
   337c0:	18c00817 	ldw	r3,32(r3)
   337c4:	10c00035 	stwio	r3,0(r2)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
   337c8:	e0fffe17 	ldw	r3,-8(fp)
   337cc:	e0bfff17 	ldw	r2,-4(fp)
   337d0:	d8000015 	stw	zero,0(sp)
   337d4:	1809883a 	mov	r4,r3
   337d8:	100b883a 	mov	r5,r2
   337dc:	018000f4 	movhi	r6,3
   337e0:	318e1204 	addi	r6,r6,14408
   337e4:	e1fffd17 	ldw	r7,-12(fp)
   337e8:	003bd080 	call	3bd08 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
   337ec:	e0bffd17 	ldw	r2,-12(fp)
   337f0:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
   337f4:	e0bffd17 	ldw	r2,-12(fp)
   337f8:	10c00204 	addi	r3,r2,8
   337fc:	00800134 	movhi	r2,4
   33800:	109f0c04 	addi	r2,r2,31792
   33804:	10800017 	ldw	r2,0(r2)
   33808:	1809883a 	mov	r4,r3
   3380c:	100b883a 	mov	r5,r2
   33810:	018000f4 	movhi	r6,3
   33814:	318e9304 	addi	r6,r6,14924
   33818:	e1fffd17 	ldw	r7,-12(fp)
   3381c:	003c3d00 	call	3c3d0 <alt_alarm_start>
   33820:	1000040e 	bge	r2,zero,33834 <altera_avalon_jtag_uart_init+0x12c>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
   33824:	e0bffd17 	ldw	r2,-12(fp)
   33828:	00e00034 	movhi	r3,32768
   3382c:	18ffffc4 	addi	r3,r3,-1
   33830:	10c00115 	stw	r3,4(r2)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
   33834:	e037883a 	mov	sp,fp
   33838:	dfc00117 	ldw	ra,4(sp)
   3383c:	df000017 	ldw	fp,0(sp)
   33840:	dec00204 	addi	sp,sp,8
   33844:	f800283a 	ret

00033848 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
   33848:	defff804 	addi	sp,sp,-32
   3384c:	df000715 	stw	fp,28(sp)
   33850:	df000704 	addi	fp,sp,28
   33854:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
   33858:	e0bfff17 	ldw	r2,-4(fp)
   3385c:	e0bffb15 	stw	r2,-20(fp)
  unsigned int base = sp->base;
   33860:	e0bffb17 	ldw	r2,-20(fp)
   33864:	10800017 	ldw	r2,0(r2)
   33868:	e0bffc15 	stw	r2,-16(fp)
   3386c:	00000106 	br	33874 <altera_avalon_jtag_uart_irq+0x2c>
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
   33870:	0001883a 	nop
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
   33874:	e0bffc17 	ldw	r2,-16(fp)
   33878:	10800104 	addi	r2,r2,4
   3387c:	10800037 	ldwio	r2,0(r2)
   33880:	e0bffd15 	stw	r2,-12(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
   33884:	e0bffd17 	ldw	r2,-12(fp)
   33888:	1080c00c 	andi	r2,r2,768
   3388c:	10006a26 	beq	r2,zero,33a38 <altera_avalon_jtag_uart_irq+0x1f0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
   33890:	e0bffd17 	ldw	r2,-12(fp)
   33894:	1080400c 	andi	r2,r2,256
   33898:	10003326 	beq	r2,zero,33968 <altera_avalon_jtag_uart_irq+0x120>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
   3389c:	00800074 	movhi	r2,1
   338a0:	e0bff915 	stw	r2,-28(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   338a4:	e0bffb17 	ldw	r2,-20(fp)
   338a8:	10800c17 	ldw	r2,48(r2)
   338ac:	10800044 	addi	r2,r2,1
   338b0:	1081ffcc 	andi	r2,r2,2047
   338b4:	e0bffe15 	stw	r2,-8(fp)
        if (next == sp->rx_out)
   338b8:	e0bffb17 	ldw	r2,-20(fp)
   338bc:	10c00d17 	ldw	r3,52(r2)
   338c0:	e0bffe17 	ldw	r2,-8(fp)
   338c4:	18801426 	beq	r3,r2,33918 <altera_avalon_jtag_uart_irq+0xd0>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
   338c8:	e0bffc17 	ldw	r2,-16(fp)
   338cc:	10800037 	ldwio	r2,0(r2)
   338d0:	e0bff915 	stw	r2,-28(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
   338d4:	e0bff917 	ldw	r2,-28(fp)
   338d8:	10a0000c 	andi	r2,r2,32768
   338dc:	10001026 	beq	r2,zero,33920 <altera_avalon_jtag_uart_irq+0xd8>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
   338e0:	e0bffb17 	ldw	r2,-20(fp)
   338e4:	10800c17 	ldw	r2,48(r2)
   338e8:	e0fff917 	ldw	r3,-28(fp)
   338ec:	e13ffb17 	ldw	r4,-20(fp)
   338f0:	2085883a 	add	r2,r4,r2
   338f4:	10801004 	addi	r2,r2,64
   338f8:	10c00005 	stb	r3,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   338fc:	e0bffb17 	ldw	r2,-20(fp)
   33900:	10800c17 	ldw	r2,48(r2)
   33904:	10800044 	addi	r2,r2,1
   33908:	10c1ffcc 	andi	r3,r2,2047
   3390c:	e0bffb17 	ldw	r2,-20(fp)
   33910:	10c00c15 	stw	r3,48(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
   33914:	003fe306 	br	338a4 <altera_avalon_jtag_uart_irq+0x5c>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
   33918:	0001883a 	nop
   3391c:	00000106 	br	33924 <altera_avalon_jtag_uart_irq+0xdc>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
   33920:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
   33924:	e0bff917 	ldw	r2,-28(fp)
   33928:	10bfffec 	andhi	r2,r2,65535
   3392c:	10000e26 	beq	r2,zero,33968 <altera_avalon_jtag_uart_irq+0x120>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
   33930:	e0bffb17 	ldw	r2,-20(fp)
   33934:	10c00817 	ldw	r3,32(r2)
   33938:	00bfff84 	movi	r2,-2
   3393c:	1886703a 	and	r3,r3,r2
   33940:	e0bffb17 	ldw	r2,-20(fp)
   33944:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
   33948:	e0bffc17 	ldw	r2,-16(fp)
   3394c:	10800104 	addi	r2,r2,4
   33950:	e0fffb17 	ldw	r3,-20(fp)
   33954:	18c00817 	ldw	r3,32(r3)
   33958:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
   3395c:	e0bffc17 	ldw	r2,-16(fp)
   33960:	10800104 	addi	r2,r2,4
   33964:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
   33968:	e0bffd17 	ldw	r2,-12(fp)
   3396c:	1080800c 	andi	r2,r2,512
   33970:	103fbf26 	beq	r2,zero,33870 <altera_avalon_jtag_uart_irq+0x28>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
   33974:	e0bffd17 	ldw	r2,-12(fp)
   33978:	1004d43a 	srli	r2,r2,16
   3397c:	e0bffa15 	stw	r2,-24(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
   33980:	00001406 	br	339d4 <altera_avalon_jtag_uart_irq+0x18c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
   33984:	e0bffc17 	ldw	r2,-16(fp)
   33988:	e0fffb17 	ldw	r3,-20(fp)
   3398c:	18c00f17 	ldw	r3,60(r3)
   33990:	e13ffb17 	ldw	r4,-20(fp)
   33994:	20c7883a 	add	r3,r4,r3
   33998:	18c21004 	addi	r3,r3,2112
   3399c:	18c00003 	ldbu	r3,0(r3)
   339a0:	18c03fcc 	andi	r3,r3,255
   339a4:	18c0201c 	xori	r3,r3,128
   339a8:	18ffe004 	addi	r3,r3,-128
   339ac:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   339b0:	e0bffb17 	ldw	r2,-20(fp)
   339b4:	10800f17 	ldw	r2,60(r2)
   339b8:	10800044 	addi	r2,r2,1
   339bc:	10c1ffcc 	andi	r3,r2,2047
   339c0:	e0bffb17 	ldw	r2,-20(fp)
   339c4:	10c00f15 	stw	r3,60(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
   339c8:	e0bffa17 	ldw	r2,-24(fp)
   339cc:	10bfffc4 	addi	r2,r2,-1
   339d0:	e0bffa15 	stw	r2,-24(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
   339d4:	e0bffa17 	ldw	r2,-24(fp)
   339d8:	10000526 	beq	r2,zero,339f0 <altera_avalon_jtag_uart_irq+0x1a8>
   339dc:	e0bffb17 	ldw	r2,-20(fp)
   339e0:	10c00f17 	ldw	r3,60(r2)
   339e4:	e0bffb17 	ldw	r2,-20(fp)
   339e8:	10800e17 	ldw	r2,56(r2)
   339ec:	18bfe51e 	bne	r3,r2,33984 <altera_avalon_jtag_uart_irq+0x13c>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
   339f0:	e0bffa17 	ldw	r2,-24(fp)
   339f4:	103f9e26 	beq	r2,zero,33870 <altera_avalon_jtag_uart_irq+0x28>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
   339f8:	e0bffb17 	ldw	r2,-20(fp)
   339fc:	10c00817 	ldw	r3,32(r2)
   33a00:	00bfff44 	movi	r2,-3
   33a04:	1886703a 	and	r3,r3,r2
   33a08:	e0bffb17 	ldw	r2,-20(fp)
   33a0c:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
   33a10:	e0bffb17 	ldw	r2,-20(fp)
   33a14:	10800017 	ldw	r2,0(r2)
   33a18:	10800104 	addi	r2,r2,4
   33a1c:	e0fffb17 	ldw	r3,-20(fp)
   33a20:	18c00817 	ldw	r3,32(r3)
   33a24:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
   33a28:	e0bffc17 	ldw	r2,-16(fp)
   33a2c:	10800104 	addi	r2,r2,4
   33a30:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
   33a34:	003f8e06 	br	33870 <altera_avalon_jtag_uart_irq+0x28>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
   33a38:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
   33a3c:	e037883a 	mov	sp,fp
   33a40:	df000017 	ldw	fp,0(sp)
   33a44:	dec00104 	addi	sp,sp,4
   33a48:	f800283a 	ret

00033a4c <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
   33a4c:	defffc04 	addi	sp,sp,-16
   33a50:	df000315 	stw	fp,12(sp)
   33a54:	df000304 	addi	fp,sp,12
   33a58:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
   33a5c:	e0bfff17 	ldw	r2,-4(fp)
   33a60:	e0bffd15 	stw	r2,-12(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
   33a64:	e0bffd17 	ldw	r2,-12(fp)
   33a68:	10800017 	ldw	r2,0(r2)
   33a6c:	10800104 	addi	r2,r2,4
   33a70:	10800037 	ldwio	r2,0(r2)
   33a74:	e0bffe15 	stw	r2,-8(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
   33a78:	e0bffe17 	ldw	r2,-8(fp)
   33a7c:	1081000c 	andi	r2,r2,1024
   33a80:	10000a26 	beq	r2,zero,33aac <altera_avalon_jtag_uart_timeout+0x60>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
   33a84:	e0bffd17 	ldw	r2,-12(fp)
   33a88:	10800017 	ldw	r2,0(r2)
   33a8c:	10800104 	addi	r2,r2,4
   33a90:	e0fffd17 	ldw	r3,-12(fp)
   33a94:	18c00817 	ldw	r3,32(r3)
   33a98:	18c10014 	ori	r3,r3,1024
   33a9c:	10c00035 	stwio	r3,0(r2)
    sp->host_inactive = 0;
   33aa0:	e0bffd17 	ldw	r2,-12(fp)
   33aa4:	10000915 	stw	zero,36(r2)
   33aa8:	00000a06 	br	33ad4 <altera_avalon_jtag_uart_timeout+0x88>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
   33aac:	e0bffd17 	ldw	r2,-12(fp)
   33ab0:	10800917 	ldw	r2,36(r2)
   33ab4:	00e00034 	movhi	r3,32768
   33ab8:	18ffff04 	addi	r3,r3,-4
   33abc:	18800536 	bltu	r3,r2,33ad4 <altera_avalon_jtag_uart_timeout+0x88>
    sp->host_inactive++;
   33ac0:	e0bffd17 	ldw	r2,-12(fp)
   33ac4:	10800917 	ldw	r2,36(r2)
   33ac8:	10c00044 	addi	r3,r2,1
   33acc:	e0bffd17 	ldw	r2,-12(fp)
   33ad0:	10c00915 	stw	r3,36(r2)
   33ad4:	00800134 	movhi	r2,4
   33ad8:	109f0c04 	addi	r2,r2,31792
   33adc:	10800017 	ldw	r2,0(r2)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
   33ae0:	e037883a 	mov	sp,fp
   33ae4:	df000017 	ldw	fp,0(sp)
   33ae8:	dec00104 	addi	sp,sp,4
   33aec:	f800283a 	ret

00033af0 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
   33af0:	defffd04 	addi	sp,sp,-12
   33af4:	df000215 	stw	fp,8(sp)
   33af8:	df000204 	addi	fp,sp,8
   33afc:	e13ffe15 	stw	r4,-8(fp)
   33b00:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
   33b04:	00000506 	br	33b1c <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
   33b08:	e0bfff17 	ldw	r2,-4(fp)
   33b0c:	1090000c 	andi	r2,r2,16384
   33b10:	10000226 	beq	r2,zero,33b1c <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
   33b14:	00bffd44 	movi	r2,-11
   33b18:	00000b06 	br	33b48 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
   33b1c:	e0bffe17 	ldw	r2,-8(fp)
   33b20:	10c00f17 	ldw	r3,60(r2)
   33b24:	e0bffe17 	ldw	r2,-8(fp)
   33b28:	10800e17 	ldw	r2,56(r2)
   33b2c:	18800526 	beq	r3,r2,33b44 <altera_avalon_jtag_uart_close+0x54>
   33b30:	e0bffe17 	ldw	r2,-8(fp)
   33b34:	10c00917 	ldw	r3,36(r2)
   33b38:	e0bffe17 	ldw	r2,-8(fp)
   33b3c:	10800117 	ldw	r2,4(r2)
   33b40:	18bff136 	bltu	r3,r2,33b08 <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
   33b44:	0005883a 	mov	r2,zero
}
   33b48:	e037883a 	mov	sp,fp
   33b4c:	df000017 	ldw	fp,0(sp)
   33b50:	dec00104 	addi	sp,sp,4
   33b54:	f800283a 	ret

00033b58 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
   33b58:	defffa04 	addi	sp,sp,-24
   33b5c:	df000515 	stw	fp,20(sp)
   33b60:	df000504 	addi	fp,sp,20
   33b64:	e13ffd15 	stw	r4,-12(fp)
   33b68:	e17ffe15 	stw	r5,-8(fp)
   33b6c:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
   33b70:	00bff9c4 	movi	r2,-25
   33b74:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
   33b78:	e0bffe17 	ldw	r2,-8(fp)
   33b7c:	10da8060 	cmpeqi	r3,r2,27137
   33b80:	1800031e 	bne	r3,zero,33b90 <altera_avalon_jtag_uart_ioctl+0x38>
   33b84:	109a80a0 	cmpeqi	r2,r2,27138
   33b88:	1000181e 	bne	r2,zero,33bec <altera_avalon_jtag_uart_ioctl+0x94>
   33b8c:	00002606 	br	33c28 <altera_avalon_jtag_uart_ioctl+0xd0>
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
   33b90:	e0bffd17 	ldw	r2,-12(fp)
   33b94:	10c00117 	ldw	r3,4(r2)
   33b98:	00a00034 	movhi	r2,32768
   33b9c:	10bfffc4 	addi	r2,r2,-1
   33ba0:	18802226 	beq	r3,r2,33c2c <altera_avalon_jtag_uart_ioctl+0xd4>
    {
      int timeout = *((int *)arg);
   33ba4:	e0bfff17 	ldw	r2,-4(fp)
   33ba8:	10800017 	ldw	r2,0(r2)
   33bac:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
   33bb0:	e0bffc17 	ldw	r2,-16(fp)
   33bb4:	10800090 	cmplti	r2,r2,2
   33bb8:	1000061e 	bne	r2,zero,33bd4 <altera_avalon_jtag_uart_ioctl+0x7c>
   33bbc:	e0fffc17 	ldw	r3,-16(fp)
   33bc0:	00a00034 	movhi	r2,32768
   33bc4:	10bfffc4 	addi	r2,r2,-1
   33bc8:	18800226 	beq	r3,r2,33bd4 <altera_avalon_jtag_uart_ioctl+0x7c>
   33bcc:	e0bffc17 	ldw	r2,-16(fp)
   33bd0:	00000206 	br	33bdc <altera_avalon_jtag_uart_ioctl+0x84>
   33bd4:	00a00034 	movhi	r2,32768
   33bd8:	10bfff84 	addi	r2,r2,-2
   33bdc:	e0fffd17 	ldw	r3,-12(fp)
   33be0:	18800115 	stw	r2,4(r3)
      rc = 0;
   33be4:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
   33be8:	00001006 	br	33c2c <altera_avalon_jtag_uart_ioctl+0xd4>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
   33bec:	e0bffd17 	ldw	r2,-12(fp)
   33bf0:	10c00117 	ldw	r3,4(r2)
   33bf4:	00a00034 	movhi	r2,32768
   33bf8:	10bfffc4 	addi	r2,r2,-1
   33bfc:	18800d26 	beq	r3,r2,33c34 <altera_avalon_jtag_uart_ioctl+0xdc>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
   33c00:	e0bffd17 	ldw	r2,-12(fp)
   33c04:	10c00917 	ldw	r3,36(r2)
   33c08:	e0bffd17 	ldw	r2,-12(fp)
   33c0c:	10800117 	ldw	r2,4(r2)
   33c10:	1885803a 	cmpltu	r2,r3,r2
   33c14:	10c03fcc 	andi	r3,r2,255
   33c18:	e0bfff17 	ldw	r2,-4(fp)
   33c1c:	10c00015 	stw	r3,0(r2)
      rc = 0;
   33c20:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
   33c24:	00000306 	br	33c34 <altera_avalon_jtag_uart_ioctl+0xdc>

  default:
    break;
   33c28:	00000306 	br	33c38 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
   33c2c:	0001883a 	nop
   33c30:	00000106 	br	33c38 <altera_avalon_jtag_uart_ioctl+0xe0>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
   33c34:	0001883a 	nop

  default:
    break;
  }

  return rc;
   33c38:	e0bffb17 	ldw	r2,-20(fp)
}
   33c3c:	e037883a 	mov	sp,fp
   33c40:	df000017 	ldw	fp,0(sp)
   33c44:	dec00104 	addi	sp,sp,4
   33c48:	f800283a 	ret

00033c4c <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
   33c4c:	defff004 	addi	sp,sp,-64
   33c50:	dfc00f15 	stw	ra,60(sp)
   33c54:	df000e15 	stw	fp,56(sp)
   33c58:	df000e04 	addi	fp,sp,56
   33c5c:	e13ffc15 	stw	r4,-16(fp)
   33c60:	e17ffd15 	stw	r5,-12(fp)
   33c64:	e1bffe15 	stw	r6,-8(fp)
   33c68:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
   33c6c:	e0bffd17 	ldw	r2,-12(fp)
   33c70:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
   33c74:	e0bffc17 	ldw	r2,-16(fp)
   33c78:	10800a17 	ldw	r2,40(r2)
   33c7c:	e0bff715 	stw	r2,-36(fp)
   33c80:	e03ff80d 	sth	zero,-32(fp)
 * converted into the functions return value.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (xSemaphoreHandle sem, alt_u16 timeout)
{
	return xSemaphoreTake(sem, timeout) ? 0 : -1;
   33c84:	e0bff80b 	ldhu	r2,-32(fp)
   33c88:	e13ff717 	ldw	r4,-36(fp)
   33c8c:	000b883a 	mov	r5,zero
   33c90:	100d883a 	mov	r6,r2
   33c94:	000f883a 	mov	r7,zero
   33c98:	000ebd80 	call	ebd8 <xQueueGenericReceive>
   33c9c:	10004826 	beq	r2,zero,33dc0 <altera_avalon_jtag_uart_read+0x174>

  while (space > 0)
   33ca0:	00004706 	br	33dc0 <altera_avalon_jtag_uart_read+0x174>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
   33ca4:	e0bffc17 	ldw	r2,-16(fp)
   33ca8:	10800c17 	ldw	r2,48(r2)
   33cac:	e0bff415 	stw	r2,-48(fp)
      out = sp->rx_out;
   33cb0:	e0bffc17 	ldw	r2,-16(fp)
   33cb4:	10800d17 	ldw	r2,52(r2)
   33cb8:	e0bff515 	stw	r2,-44(fp)

      if (in >= out)
   33cbc:	e0fff417 	ldw	r3,-48(fp)
   33cc0:	e0bff517 	ldw	r2,-44(fp)
   33cc4:	18800536 	bltu	r3,r2,33cdc <altera_avalon_jtag_uart_read+0x90>
        n = in - out;
   33cc8:	e0fff417 	ldw	r3,-48(fp)
   33ccc:	e0bff517 	ldw	r2,-44(fp)
   33cd0:	1885c83a 	sub	r2,r3,r2
   33cd4:	e0bff315 	stw	r2,-52(fp)
   33cd8:	00000406 	br	33cec <altera_avalon_jtag_uart_read+0xa0>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
   33cdc:	00c20004 	movi	r3,2048
   33ce0:	e0bff517 	ldw	r2,-44(fp)
   33ce4:	1885c83a 	sub	r2,r3,r2
   33ce8:	e0bff315 	stw	r2,-52(fp)

      if (n == 0)
   33cec:	e0bff317 	ldw	r2,-52(fp)
   33cf0:	10001e26 	beq	r2,zero,33d6c <altera_avalon_jtag_uart_read+0x120>
        break; /* No more data available */

      if (n > space)
   33cf4:	e0fffe17 	ldw	r3,-8(fp)
   33cf8:	e0bff317 	ldw	r2,-52(fp)
   33cfc:	1880022e 	bgeu	r3,r2,33d08 <altera_avalon_jtag_uart_read+0xbc>
        n = space;
   33d00:	e0bffe17 	ldw	r2,-8(fp)
   33d04:	e0bff315 	stw	r2,-52(fp)

      memcpy(ptr, sp->rx_buf + out, n);
   33d08:	e0bff517 	ldw	r2,-44(fp)
   33d0c:	10801004 	addi	r2,r2,64
   33d10:	e0fffc17 	ldw	r3,-16(fp)
   33d14:	1885883a 	add	r2,r3,r2
   33d18:	e13ff217 	ldw	r4,-56(fp)
   33d1c:	100b883a 	mov	r5,r2
   33d20:	e1bff317 	ldw	r6,-52(fp)
   33d24:	00041f00 	call	41f0 <memcpy>
      ptr   += n;
   33d28:	e0fff217 	ldw	r3,-56(fp)
   33d2c:	e0bff317 	ldw	r2,-52(fp)
   33d30:	1885883a 	add	r2,r3,r2
   33d34:	e0bff215 	stw	r2,-56(fp)
      space -= n;
   33d38:	e0fffe17 	ldw	r3,-8(fp)
   33d3c:	e0bff317 	ldw	r2,-52(fp)
   33d40:	1885c83a 	sub	r2,r3,r2
   33d44:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   33d48:	e0fff517 	ldw	r3,-44(fp)
   33d4c:	e0bff317 	ldw	r2,-52(fp)
   33d50:	1885883a 	add	r2,r3,r2
   33d54:	10c1ffcc 	andi	r3,r2,2047
   33d58:	e0bffc17 	ldw	r2,-16(fp)
   33d5c:	10c00d15 	stw	r3,52(r2)
    }
    while (space > 0);
   33d60:	e0bffe17 	ldw	r2,-8(fp)
   33d64:	00bfcf16 	blt	zero,r2,33ca4 <altera_avalon_jtag_uart_read+0x58>
   33d68:	00000106 	br	33d70 <altera_avalon_jtag_uart_read+0x124>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
   33d6c:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
   33d70:	e0fff217 	ldw	r3,-56(fp)
   33d74:	e0bffd17 	ldw	r2,-12(fp)
   33d78:	1880141e 	bne	r3,r2,33dcc <altera_avalon_jtag_uart_read+0x180>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
   33d7c:	e0bfff17 	ldw	r2,-4(fp)
   33d80:	1090000c 	andi	r2,r2,16384
   33d84:	1000131e 	bne	r2,zero,33dd4 <altera_avalon_jtag_uart_read+0x188>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
   33d88:	0001883a 	nop
   33d8c:	e0bffc17 	ldw	r2,-16(fp)
   33d90:	10c00c17 	ldw	r3,48(r2)
   33d94:	e0bff417 	ldw	r2,-48(fp)
   33d98:	1880051e 	bne	r3,r2,33db0 <altera_avalon_jtag_uart_read+0x164>
   33d9c:	e0bffc17 	ldw	r2,-16(fp)
   33da0:	10c00917 	ldw	r3,36(r2)
   33da4:	e0bffc17 	ldw	r2,-16(fp)
   33da8:	10800117 	ldw	r2,4(r2)
   33dac:	18bff736 	bltu	r3,r2,33d8c <altera_avalon_jtag_uart_read+0x140>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
   33db0:	e0bffc17 	ldw	r2,-16(fp)
   33db4:	10c00c17 	ldw	r3,48(r2)
   33db8:	e0bff417 	ldw	r2,-48(fp)
   33dbc:	18800726 	beq	r3,r2,33ddc <altera_avalon_jtag_uart_read+0x190>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
   33dc0:	e0bffe17 	ldw	r2,-8(fp)
   33dc4:	00bfb716 	blt	zero,r2,33ca4 <altera_avalon_jtag_uart_read+0x58>
   33dc8:	00000506 	br	33de0 <altera_avalon_jtag_uart_read+0x194>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
   33dcc:	0001883a 	nop
   33dd0:	00000306 	br	33de0 <altera_avalon_jtag_uart_read+0x194>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
   33dd4:	0001883a 	nop
   33dd8:	00000106 	br	33de0 <altera_avalon_jtag_uart_read+0x194>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
   33ddc:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
   33de0:	e0bffc17 	ldw	r2,-16(fp)
   33de4:	10800a17 	ldw	r2,40(r2)
   33de8:	1009883a 	mov	r4,r2
   33dec:	000b883a 	mov	r5,zero
   33df0:	000d883a 	mov	r6,zero
   33df4:	000f883a 	mov	r7,zero
   33df8:	000e95c0 	call	e95c <xQueueGenericSend>

  if (ptr != buffer)
   33dfc:	e0fff217 	ldw	r3,-56(fp)
   33e00:	e0bffd17 	ldw	r2,-12(fp)
   33e04:	18802226 	beq	r3,r2,33e90 <altera_avalon_jtag_uart_read+0x244>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   33e08:	0005303a 	rdctl	r2,status
   33e0c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   33e10:	e0fff917 	ldw	r3,-28(fp)
   33e14:	00bfff84 	movi	r2,-2
   33e18:	1884703a 	and	r2,r3,r2
   33e1c:	1001703a 	wrctl	status,r2
  
  return context;
   33e20:	e0bff917 	ldw	r2,-28(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
   33e24:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
   33e28:	e0bffc17 	ldw	r2,-16(fp)
   33e2c:	10800817 	ldw	r2,32(r2)
   33e30:	10c00054 	ori	r3,r2,1
   33e34:	e0bffc17 	ldw	r2,-16(fp)
   33e38:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
   33e3c:	e0bffc17 	ldw	r2,-16(fp)
   33e40:	10800017 	ldw	r2,0(r2)
   33e44:	10800104 	addi	r2,r2,4
   33e48:	e0fffc17 	ldw	r3,-16(fp)
   33e4c:	18c00817 	ldw	r3,32(r3)
   33e50:	10c00035 	stwio	r3,0(r2)
   33e54:	e0bff617 	ldw	r2,-40(fp)
   33e58:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   33e5c:	0005303a 	rdctl	r2,status
   33e60:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   33e64:	e0fffb17 	ldw	r3,-20(fp)
   33e68:	00bfff84 	movi	r2,-2
   33e6c:	1884703a 	and	r2,r3,r2
   33e70:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   33e74:	e0bffa17 	ldw	r2,-24(fp)
   33e78:	1080004c 	andi	r2,r2,1
   33e7c:	e0fffb17 	ldw	r3,-20(fp)
   33e80:	1884b03a 	or	r2,r3,r2
   33e84:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
   33e88:	e0bffb17 	ldw	r2,-20(fp)
   33e8c:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
   33e90:	e0fff217 	ldw	r3,-56(fp)
   33e94:	e0bffd17 	ldw	r2,-12(fp)
   33e98:	18800426 	beq	r3,r2,33eac <altera_avalon_jtag_uart_read+0x260>
    return ptr - buffer;
   33e9c:	e0fff217 	ldw	r3,-56(fp)
   33ea0:	e0bffd17 	ldw	r2,-12(fp)
   33ea4:	1885c83a 	sub	r2,r3,r2
   33ea8:	00000606 	br	33ec4 <altera_avalon_jtag_uart_read+0x278>
  else if (flags & O_NONBLOCK)
   33eac:	e0bfff17 	ldw	r2,-4(fp)
   33eb0:	1090000c 	andi	r2,r2,16384
   33eb4:	10000226 	beq	r2,zero,33ec0 <altera_avalon_jtag_uart_read+0x274>
    return -EWOULDBLOCK;
   33eb8:	00bffd44 	movi	r2,-11
   33ebc:	00000106 	br	33ec4 <altera_avalon_jtag_uart_read+0x278>
  else
    return -EIO;
   33ec0:	00bffec4 	movi	r2,-5
}
   33ec4:	e037883a 	mov	sp,fp
   33ec8:	dfc00117 	ldw	ra,4(sp)
   33ecc:	df000017 	ldw	fp,0(sp)
   33ed0:	dec00204 	addi	sp,sp,8
   33ed4:	f800283a 	ret

00033ed8 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
   33ed8:	defff004 	addi	sp,sp,-64
   33edc:	dfc00f15 	stw	ra,60(sp)
   33ee0:	df000e15 	stw	fp,56(sp)
   33ee4:	df000e04 	addi	fp,sp,56
   33ee8:	e13ffc15 	stw	r4,-16(fp)
   33eec:	e17ffd15 	stw	r5,-12(fp)
   33ef0:	e1bffe15 	stw	r6,-8(fp)
   33ef4:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
   33ef8:	e03ff215 	stw	zero,-56(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
   33efc:	e0bffd17 	ldw	r2,-12(fp)
   33f00:	e0bff415 	stw	r2,-48(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
   33f04:	e0bffc17 	ldw	r2,-16(fp)
   33f08:	10800b17 	ldw	r2,44(r2)
   33f0c:	e0bff715 	stw	r2,-36(fp)
   33f10:	e03ff80d 	sth	zero,-32(fp)
   33f14:	e0bff80b 	ldhu	r2,-32(fp)
   33f18:	e13ff717 	ldw	r4,-36(fp)
   33f1c:	000b883a 	mov	r5,zero
   33f20:	100d883a 	mov	r6,r2
   33f24:	000f883a 	mov	r7,zero
   33f28:	000ebd80 	call	ebd8 <xQueueGenericReceive>
   33f2c:	10003826 	beq	r2,zero,34010 <altera_avalon_jtag_uart_write+0x138>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
   33f30:	00003706 	br	34010 <altera_avalon_jtag_uart_write+0x138>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
   33f34:	e0bffc17 	ldw	r2,-16(fp)
   33f38:	10800e17 	ldw	r2,56(r2)
   33f3c:	e0bff515 	stw	r2,-44(fp)
      out = sp->tx_out;
   33f40:	e0bffc17 	ldw	r2,-16(fp)
   33f44:	10800f17 	ldw	r2,60(r2)
   33f48:	e0bff215 	stw	r2,-56(fp)

      if (in < out)
   33f4c:	e0fff517 	ldw	r3,-44(fp)
   33f50:	e0bff217 	ldw	r2,-56(fp)
   33f54:	1880062e 	bgeu	r3,r2,33f70 <altera_avalon_jtag_uart_write+0x98>
        n = out - 1 - in;
   33f58:	e0fff217 	ldw	r3,-56(fp)
   33f5c:	e0bff517 	ldw	r2,-44(fp)
   33f60:	1885c83a 	sub	r2,r3,r2
   33f64:	10bfffc4 	addi	r2,r2,-1
   33f68:	e0bff315 	stw	r2,-52(fp)
   33f6c:	00000b06 	br	33f9c <altera_avalon_jtag_uart_write+0xc4>
      else if (out > 0)
   33f70:	e0bff217 	ldw	r2,-56(fp)
   33f74:	10000526 	beq	r2,zero,33f8c <altera_avalon_jtag_uart_write+0xb4>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
   33f78:	00c20004 	movi	r3,2048
   33f7c:	e0bff517 	ldw	r2,-44(fp)
   33f80:	1885c83a 	sub	r2,r3,r2
   33f84:	e0bff315 	stw	r2,-52(fp)
   33f88:	00000406 	br	33f9c <altera_avalon_jtag_uart_write+0xc4>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
   33f8c:	00c1ffc4 	movi	r3,2047
   33f90:	e0bff517 	ldw	r2,-44(fp)
   33f94:	1885c83a 	sub	r2,r3,r2
   33f98:	e0bff315 	stw	r2,-52(fp)

      if (n == 0)
   33f9c:	e0bff317 	ldw	r2,-52(fp)
   33fa0:	10001e26 	beq	r2,zero,3401c <altera_avalon_jtag_uart_write+0x144>
        break;

      if (n > count)
   33fa4:	e0fffe17 	ldw	r3,-8(fp)
   33fa8:	e0bff317 	ldw	r2,-52(fp)
   33fac:	1880022e 	bgeu	r3,r2,33fb8 <altera_avalon_jtag_uart_write+0xe0>
        n = count;
   33fb0:	e0bffe17 	ldw	r2,-8(fp)
   33fb4:	e0bff315 	stw	r2,-52(fp)

      memcpy(sp->tx_buf + in, ptr, n);
   33fb8:	e0bff517 	ldw	r2,-44(fp)
   33fbc:	10821004 	addi	r2,r2,2112
   33fc0:	e0fffc17 	ldw	r3,-16(fp)
   33fc4:	1885883a 	add	r2,r3,r2
   33fc8:	1009883a 	mov	r4,r2
   33fcc:	e17ffd17 	ldw	r5,-12(fp)
   33fd0:	e1bff317 	ldw	r6,-52(fp)
   33fd4:	00041f00 	call	41f0 <memcpy>
      ptr   += n;
   33fd8:	e0fffd17 	ldw	r3,-12(fp)
   33fdc:	e0bff317 	ldw	r2,-52(fp)
   33fe0:	1885883a 	add	r2,r3,r2
   33fe4:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
   33fe8:	e0fffe17 	ldw	r3,-8(fp)
   33fec:	e0bff317 	ldw	r2,-52(fp)
   33ff0:	1885c83a 	sub	r2,r3,r2
   33ff4:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
   33ff8:	e0fff517 	ldw	r3,-44(fp)
   33ffc:	e0bff317 	ldw	r2,-52(fp)
   34000:	1885883a 	add	r2,r3,r2
   34004:	10c1ffcc 	andi	r3,r2,2047
   34008:	e0bffc17 	ldw	r2,-16(fp)
   3400c:	10c00e15 	stw	r3,56(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
   34010:	e0bffe17 	ldw	r2,-8(fp)
   34014:	00bfc716 	blt	zero,r2,33f34 <altera_avalon_jtag_uart_write+0x5c>
   34018:	00000106 	br	34020 <altera_avalon_jtag_uart_write+0x148>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
   3401c:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   34020:	0005303a 	rdctl	r2,status
   34024:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   34028:	e0fff917 	ldw	r3,-28(fp)
   3402c:	00bfff84 	movi	r2,-2
   34030:	1884703a 	and	r2,r3,r2
   34034:	1001703a 	wrctl	status,r2
  
  return context;
   34038:	e0bff917 	ldw	r2,-28(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
   3403c:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
   34040:	e0bffc17 	ldw	r2,-16(fp)
   34044:	10800817 	ldw	r2,32(r2)
   34048:	10c00094 	ori	r3,r2,2
   3404c:	e0bffc17 	ldw	r2,-16(fp)
   34050:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
   34054:	e0bffc17 	ldw	r2,-16(fp)
   34058:	10800017 	ldw	r2,0(r2)
   3405c:	10800104 	addi	r2,r2,4
   34060:	e0fffc17 	ldw	r3,-16(fp)
   34064:	18c00817 	ldw	r3,32(r3)
   34068:	10c00035 	stwio	r3,0(r2)
   3406c:	e0bff617 	ldw	r2,-40(fp)
   34070:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   34074:	0005303a 	rdctl	r2,status
   34078:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   3407c:	e0fffb17 	ldw	r3,-20(fp)
   34080:	00bfff84 	movi	r2,-2
   34084:	1884703a 	and	r2,r3,r2
   34088:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   3408c:	e0bffa17 	ldw	r2,-24(fp)
   34090:	1080004c 	andi	r2,r2,1
   34094:	e0fffb17 	ldw	r3,-20(fp)
   34098:	1884b03a 	or	r2,r3,r2
   3409c:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
   340a0:	e0bffb17 	ldw	r2,-20(fp)
   340a4:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
   340a8:	e0bffe17 	ldw	r2,-8(fp)
   340ac:	0080110e 	bge	zero,r2,340f4 <altera_avalon_jtag_uart_write+0x21c>
    {
      if (flags & O_NONBLOCK)
   340b0:	e0bfff17 	ldw	r2,-4(fp)
   340b4:	1090000c 	andi	r2,r2,16384
   340b8:	1000111e 	bne	r2,zero,34100 <altera_avalon_jtag_uart_write+0x228>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
   340bc:	0001883a 	nop
   340c0:	e0bffc17 	ldw	r2,-16(fp)
   340c4:	10c00f17 	ldw	r3,60(r2)
   340c8:	e0bff217 	ldw	r2,-56(fp)
   340cc:	1880051e 	bne	r3,r2,340e4 <altera_avalon_jtag_uart_write+0x20c>
   340d0:	e0bffc17 	ldw	r2,-16(fp)
   340d4:	10c00917 	ldw	r3,36(r2)
   340d8:	e0bffc17 	ldw	r2,-16(fp)
   340dc:	10800117 	ldw	r2,4(r2)
   340e0:	18bff736 	bltu	r3,r2,340c0 <altera_avalon_jtag_uart_write+0x1e8>
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
   340e4:	e0bffc17 	ldw	r2,-16(fp)
   340e8:	10c00f17 	ldw	r3,60(r2)
   340ec:	e0bff217 	ldw	r2,-56(fp)
   340f0:	18800526 	beq	r3,r2,34108 <altera_avalon_jtag_uart_write+0x230>
         break;
    }
  }
  while (count > 0);
   340f4:	e0bffe17 	ldw	r2,-8(fp)
   340f8:	00bfc516 	blt	zero,r2,34010 <altera_avalon_jtag_uart_write+0x138>
   340fc:	00000306 	br	3410c <altera_avalon_jtag_uart_write+0x234>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
   34100:	0001883a 	nop
   34104:	00000106 	br	3410c <altera_avalon_jtag_uart_write+0x234>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
         break;
   34108:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
   3410c:	e0bffc17 	ldw	r2,-16(fp)
   34110:	10800b17 	ldw	r2,44(r2)
   34114:	1009883a 	mov	r4,r2
   34118:	000b883a 	mov	r5,zero
   3411c:	000d883a 	mov	r6,zero
   34120:	000f883a 	mov	r7,zero
   34124:	000e95c0 	call	e95c <xQueueGenericSend>

  if (ptr != start)
   34128:	e0fffd17 	ldw	r3,-12(fp)
   3412c:	e0bff417 	ldw	r2,-48(fp)
   34130:	18800426 	beq	r3,r2,34144 <altera_avalon_jtag_uart_write+0x26c>
    return ptr - start;
   34134:	e0fffd17 	ldw	r3,-12(fp)
   34138:	e0bff417 	ldw	r2,-48(fp)
   3413c:	1885c83a 	sub	r2,r3,r2
   34140:	00000606 	br	3415c <altera_avalon_jtag_uart_write+0x284>
  else if (flags & O_NONBLOCK)
   34144:	e0bfff17 	ldw	r2,-4(fp)
   34148:	1090000c 	andi	r2,r2,16384
   3414c:	10000226 	beq	r2,zero,34158 <altera_avalon_jtag_uart_write+0x280>
    return -EWOULDBLOCK;
   34150:	00bffd44 	movi	r2,-11
   34154:	00000106 	br	3415c <altera_avalon_jtag_uart_write+0x284>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
   34158:	00bffec4 	movi	r2,-5
}
   3415c:	e037883a 	mov	sp,fp
   34160:	dfc00117 	ldw	ra,4(sp)
   34164:	df000017 	ldw	fp,0(sp)
   34168:	dec00204 	addi	sp,sp,8
   3416c:	f800283a 	ret

00034170 <lcd_write_command>:

/* --------------------------------------------------------------------- */

static void lcd_write_command(altera_avalon_lcd_16207_state* sp, 
  unsigned char command)
{
   34170:	defffa04 	addi	sp,sp,-24
   34174:	dfc00515 	stw	ra,20(sp)
   34178:	df000415 	stw	fp,16(sp)
   3417c:	df000404 	addi	fp,sp,16
   34180:	e13ffe15 	stw	r4,-8(fp)
   34184:	2805883a 	mov	r2,r5
   34188:	e0bfff05 	stb	r2,-4(fp)
  unsigned int base = sp->base;
   3418c:	e0bffe17 	ldw	r2,-8(fp)
   34190:	10800017 	ldw	r2,0(r2)
   34194:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
   34198:	008003f4 	movhi	r2,15
   3419c:	10909004 	addi	r2,r2,16960
   341a0:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
   341a4:	e0bffe17 	ldw	r2,-8(fp)
   341a8:	10800803 	ldbu	r2,32(r2)
   341ac:	10803fcc 	andi	r2,r2,255
   341b0:	1080201c 	xori	r2,r2,128
   341b4:	10bfe004 	addi	r2,r2,-128
   341b8:	10000a26 	beq	r2,zero,341e4 <lcd_write_command+0x74>
    return;
   341bc:	00001406 	br	34210 <lcd_write_command+0xa0>

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
    if (--i == 0)
   341c0:	e0bffc17 	ldw	r2,-16(fp)
   341c4:	10bfffc4 	addi	r2,r2,-1
   341c8:	e0bffc15 	stw	r2,-16(fp)
   341cc:	e0bffc17 	ldw	r2,-16(fp)
   341d0:	1000051e 	bne	r2,zero,341e8 <lcd_write_command+0x78>
    {
      sp->broken = 1;
   341d4:	e0bffe17 	ldw	r2,-8(fp)
   341d8:	00c00044 	movi	r3,1
   341dc:	10c00805 	stb	r3,32(r2)
      return;
   341e0:	00000b06 	br	34210 <lcd_write_command+0xa0>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
   341e4:	0001883a 	nop
   341e8:	e0bffd17 	ldw	r2,-12(fp)
   341ec:	10800104 	addi	r2,r2,4
   341f0:	10800037 	ldwio	r2,0(r2)
   341f4:	1080200c 	andi	r2,r2,128
   341f8:	103ff11e 	bne	r2,zero,341c0 <lcd_write_command+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
   341fc:	01001904 	movi	r4,100
   34200:	00124300 	call	12430 <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, command);
   34204:	e0bffd17 	ldw	r2,-12(fp)
   34208:	e0ffff03 	ldbu	r3,-4(fp)
   3420c:	10c00035 	stwio	r3,0(r2)
}
   34210:	e037883a 	mov	sp,fp
   34214:	dfc00117 	ldw	ra,4(sp)
   34218:	df000017 	ldw	fp,0(sp)
   3421c:	dec00204 	addi	sp,sp,8
   34220:	f800283a 	ret

00034224 <lcd_write_data>:

/* --------------------------------------------------------------------- */

static void lcd_write_data(altera_avalon_lcd_16207_state* sp, 
  unsigned char data)
{
   34224:	defffa04 	addi	sp,sp,-24
   34228:	dfc00515 	stw	ra,20(sp)
   3422c:	df000415 	stw	fp,16(sp)
   34230:	df000404 	addi	fp,sp,16
   34234:	e13ffe15 	stw	r4,-8(fp)
   34238:	2805883a 	mov	r2,r5
   3423c:	e0bfff05 	stb	r2,-4(fp)
  unsigned int base = sp->base;
   34240:	e0bffe17 	ldw	r2,-8(fp)
   34244:	10800017 	ldw	r2,0(r2)
   34248:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
   3424c:	008003f4 	movhi	r2,15
   34250:	10909004 	addi	r2,r2,16960
   34254:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
   34258:	e0bffe17 	ldw	r2,-8(fp)
   3425c:	10800803 	ldbu	r2,32(r2)
   34260:	10803fcc 	andi	r2,r2,255
   34264:	1080201c 	xori	r2,r2,128
   34268:	10bfe004 	addi	r2,r2,-128
   3426c:	10000a26 	beq	r2,zero,34298 <lcd_write_data+0x74>
    return;
   34270:	00001b06 	br	342e0 <lcd_write_data+0xbc>

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
    if (--i == 0)
   34274:	e0bffc17 	ldw	r2,-16(fp)
   34278:	10bfffc4 	addi	r2,r2,-1
   3427c:	e0bffc15 	stw	r2,-16(fp)
   34280:	e0bffc17 	ldw	r2,-16(fp)
   34284:	1000051e 	bne	r2,zero,3429c <lcd_write_data+0x78>
    {
      sp->broken = 1;
   34288:	e0bffe17 	ldw	r2,-8(fp)
   3428c:	00c00044 	movi	r3,1
   34290:	10c00805 	stb	r3,32(r2)
      return;
   34294:	00001206 	br	342e0 <lcd_write_data+0xbc>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
   34298:	0001883a 	nop
   3429c:	e0bffd17 	ldw	r2,-12(fp)
   342a0:	10800104 	addi	r2,r2,4
   342a4:	10800037 	ldwio	r2,0(r2)
   342a8:	1080200c 	andi	r2,r2,128
   342ac:	103ff11e 	bne	r2,zero,34274 <lcd_write_data+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
   342b0:	01001904 	movi	r4,100
   342b4:	00124300 	call	12430 <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_DATA(base, data);
   342b8:	e0bffd17 	ldw	r2,-12(fp)
   342bc:	10800204 	addi	r2,r2,8
   342c0:	e0ffff03 	ldbu	r3,-4(fp)
   342c4:	10c00035 	stwio	r3,0(r2)

  sp->address++;
   342c8:	e0bffe17 	ldw	r2,-8(fp)
   342cc:	108008c3 	ldbu	r2,35(r2)
   342d0:	10800044 	addi	r2,r2,1
   342d4:	1007883a 	mov	r3,r2
   342d8:	e0bffe17 	ldw	r2,-8(fp)
   342dc:	10c008c5 	stb	r3,35(r2)
}
   342e0:	e037883a 	mov	sp,fp
   342e4:	dfc00117 	ldw	ra,4(sp)
   342e8:	df000017 	ldw	fp,0(sp)
   342ec:	dec00204 	addi	sp,sp,8
   342f0:	f800283a 	ret

000342f4 <lcd_clear_screen>:

/* --------------------------------------------------------------------- */

static void lcd_clear_screen(altera_avalon_lcd_16207_state* sp)
{
   342f4:	defffc04 	addi	sp,sp,-16
   342f8:	dfc00315 	stw	ra,12(sp)
   342fc:	df000215 	stw	fp,8(sp)
   34300:	df000204 	addi	fp,sp,8
   34304:	e13fff15 	stw	r4,-4(fp)
  int y;

  lcd_write_command(sp, LCD_CMD_CLEAR);
   34308:	e13fff17 	ldw	r4,-4(fp)
   3430c:	01400044 	movi	r5,1
   34310:	00341700 	call	34170 <lcd_write_command>

  sp->x = 0;
   34314:	e0bfff17 	ldw	r2,-4(fp)
   34318:	10000845 	stb	zero,33(r2)
  sp->y = 0;
   3431c:	e0bfff17 	ldw	r2,-4(fp)
   34320:	10000885 	stb	zero,34(r2)
  sp->address = 0;
   34324:	e0bfff17 	ldw	r2,-4(fp)
   34328:	100008c5 	stb	zero,35(r2)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   3432c:	e03ffe15 	stw	zero,-8(fp)
   34330:	00001b06 	br	343a0 <lcd_clear_screen+0xac>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
   34334:	e0bffe17 	ldw	r2,-8(fp)
   34338:	108018e4 	muli	r2,r2,99
   3433c:	10801004 	addi	r2,r2,64
   34340:	e0ffff17 	ldw	r3,-4(fp)
   34344:	1885883a 	add	r2,r3,r2
   34348:	1009883a 	mov	r4,r2
   3434c:	01400804 	movi	r5,32
   34350:	01801444 	movi	r6,81
   34354:	00042e80 	call	42e8 <memset>
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
   34358:	e0bffe17 	ldw	r2,-8(fp)
   3435c:	108018e4 	muli	r2,r2,99
   34360:	10800c04 	addi	r2,r2,48
   34364:	e0ffff17 	ldw	r3,-4(fp)
   34368:	1885883a 	add	r2,r3,r2
   3436c:	1009883a 	mov	r4,r2
   34370:	01400804 	movi	r5,32
   34374:	01800404 	movi	r6,16
   34378:	00042e80 	call	42e8 <memset>
    sp->line[y].width = 0;
   3437c:	e0ffff17 	ldw	r3,-4(fp)
   34380:	e0bffe17 	ldw	r2,-8(fp)
   34384:	108018e4 	muli	r2,r2,99
   34388:	1885883a 	add	r2,r3,r2
   3438c:	10802404 	addi	r2,r2,144
   34390:	10000045 	stb	zero,1(r2)

  sp->x = 0;
  sp->y = 0;
  sp->address = 0;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   34394:	e0bffe17 	ldw	r2,-8(fp)
   34398:	10800044 	addi	r2,r2,1
   3439c:	e0bffe15 	stw	r2,-8(fp)
   343a0:	e0bffe17 	ldw	r2,-8(fp)
   343a4:	10800090 	cmplti	r2,r2,2
   343a8:	103fe21e 	bne	r2,zero,34334 <lcd_clear_screen+0x40>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
    sp->line[y].width = 0;
  }
}
   343ac:	e037883a 	mov	sp,fp
   343b0:	dfc00117 	ldw	ra,4(sp)
   343b4:	df000017 	ldw	fp,0(sp)
   343b8:	dec00204 	addi	sp,sp,8
   343bc:	f800283a 	ret

000343c0 <lcd_repaint_screen>:

/* --------------------------------------------------------------------- */

static void lcd_repaint_screen(altera_avalon_lcd_16207_state* sp)
{
   343c0:	defff704 	addi	sp,sp,-36
   343c4:	dfc00815 	stw	ra,32(sp)
   343c8:	df000715 	stw	fp,28(sp)
   343cc:	df000704 	addi	fp,sp,28
   343d0:	e13fff15 	stw	r4,-4(fp)
  /* scrollpos controls how much the lines have scrolled round.  The speed
   * each line scrolls at is controlled by its speed variable - while
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;
   343d4:	e0bfff17 	ldw	r2,-4(fp)
   343d8:	10800943 	ldbu	r2,37(r2)
   343dc:	10803fcc 	andi	r2,r2,255
   343e0:	e0bffc15 	stw	r2,-16(fp)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   343e4:	e03ff915 	stw	zero,-28(fp)
   343e8:	00006806 	br	3458c <lcd_repaint_screen+0x1cc>
  {
    int width  = sp->line[y].width;
   343ec:	e0ffff17 	ldw	r3,-4(fp)
   343f0:	e0bff917 	ldw	r2,-28(fp)
   343f4:	108018e4 	muli	r2,r2,99
   343f8:	1885883a 	add	r2,r3,r2
   343fc:	10802404 	addi	r2,r2,144
   34400:	10800043 	ldbu	r2,1(r2)
   34404:	10803fcc 	andi	r2,r2,255
   34408:	1080201c 	xori	r2,r2,128
   3440c:	10bfe004 	addi	r2,r2,-128
   34410:	e0bffd15 	stw	r2,-12(fp)
    int offset = (scrollpos * sp->line[y].speed) >> 8;
   34414:	e0ffff17 	ldw	r3,-4(fp)
   34418:	e0bff917 	ldw	r2,-28(fp)
   3441c:	108018e4 	muli	r2,r2,99
   34420:	1885883a 	add	r2,r3,r2
   34424:	10802404 	addi	r2,r2,144
   34428:	10800083 	ldbu	r2,2(r2)
   3442c:	10c03fcc 	andi	r3,r2,255
   34430:	e0bffc17 	ldw	r2,-16(fp)
   34434:	1885383a 	mul	r2,r3,r2
   34438:	1005d23a 	srai	r2,r2,8
   3443c:	e0bffb15 	stw	r2,-20(fp)
    if (offset >= width)
   34440:	e0fffb17 	ldw	r3,-20(fp)
   34444:	e0bffd17 	ldw	r2,-12(fp)
   34448:	18800116 	blt	r3,r2,34450 <lcd_repaint_screen+0x90>
      offset = 0;
   3444c:	e03ffb15 	stw	zero,-20(fp)

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
   34450:	e03ffa15 	stw	zero,-24(fp)
   34454:	00004706 	br	34574 <lcd_repaint_screen+0x1b4>
    {
      char c = sp->line[y].data[(x + offset) % width];
   34458:	e0fffa17 	ldw	r3,-24(fp)
   3445c:	e0bffb17 	ldw	r2,-20(fp)
   34460:	1885883a 	add	r2,r3,r2
   34464:	e0fffd17 	ldw	r3,-12(fp)
   34468:	10c9283a 	div	r4,r2,r3
   3446c:	e0fffd17 	ldw	r3,-12(fp)
   34470:	20c7383a 	mul	r3,r4,r3
   34474:	10c5c83a 	sub	r2,r2,r3
   34478:	e13fff17 	ldw	r4,-4(fp)
   3447c:	e0fff917 	ldw	r3,-28(fp)
   34480:	18c018e4 	muli	r3,r3,99
   34484:	20c7883a 	add	r3,r4,r3
   34488:	1885883a 	add	r2,r3,r2
   3448c:	10801004 	addi	r2,r2,64
   34490:	10800003 	ldbu	r2,0(r2)
   34494:	e0bffe05 	stb	r2,-8(fp)

      /* Writing data takes 40us, so don't do it unless required */
      if (sp->line[y].visible[x] != c)
   34498:	e0ffff17 	ldw	r3,-4(fp)
   3449c:	e0bff917 	ldw	r2,-28(fp)
   344a0:	108018e4 	muli	r2,r2,99
   344a4:	1887883a 	add	r3,r3,r2
   344a8:	e0bffa17 	ldw	r2,-24(fp)
   344ac:	1885883a 	add	r2,r3,r2
   344b0:	10800c04 	addi	r2,r2,48
   344b4:	10800003 	ldbu	r2,0(r2)
   344b8:	10c03fcc 	andi	r3,r2,255
   344bc:	18c0201c 	xori	r3,r3,128
   344c0:	18ffe004 	addi	r3,r3,-128
   344c4:	e0bffe07 	ldb	r2,-8(fp)
   344c8:	18802726 	beq	r3,r2,34568 <lcd_repaint_screen+0x1a8>
      {
        unsigned char address = x + colstart[y];
   344cc:	e0fff917 	ldw	r3,-28(fp)
   344d0:	d0a01884 	addi	r2,gp,-32670
   344d4:	1885883a 	add	r2,r3,r2
   344d8:	10800003 	ldbu	r2,0(r2)
   344dc:	1007883a 	mov	r3,r2
   344e0:	e0bffa17 	ldw	r2,-24(fp)
   344e4:	1885883a 	add	r2,r3,r2
   344e8:	e0bffe45 	stb	r2,-7(fp)

        if (address != sp->address)
   344ec:	e0fffe43 	ldbu	r3,-7(fp)
   344f0:	e0bfff17 	ldw	r2,-4(fp)
   344f4:	108008c3 	ldbu	r2,35(r2)
   344f8:	10803fcc 	andi	r2,r2,255
   344fc:	1080201c 	xori	r2,r2,128
   34500:	10bfe004 	addi	r2,r2,-128
   34504:	18800a26 	beq	r3,r2,34530 <lcd_repaint_screen+0x170>
        {
          lcd_write_command(sp, LCD_CMD_WRITE_DATA | address);
   34508:	e0fffe43 	ldbu	r3,-7(fp)
   3450c:	00bfe004 	movi	r2,-128
   34510:	1884b03a 	or	r2,r3,r2
   34514:	10803fcc 	andi	r2,r2,255
   34518:	e13fff17 	ldw	r4,-4(fp)
   3451c:	100b883a 	mov	r5,r2
   34520:	00341700 	call	34170 <lcd_write_command>
          sp->address = address;
   34524:	e0fffe43 	ldbu	r3,-7(fp)
   34528:	e0bfff17 	ldw	r2,-4(fp)
   3452c:	10c008c5 	stb	r3,35(r2)
        }

        lcd_write_data(sp, c);
   34530:	e0bffe03 	ldbu	r2,-8(fp)
   34534:	10803fcc 	andi	r2,r2,255
   34538:	e13fff17 	ldw	r4,-4(fp)
   3453c:	100b883a 	mov	r5,r2
   34540:	00342240 	call	34224 <lcd_write_data>
        sp->line[y].visible[x] = c;
   34544:	e0ffff17 	ldw	r3,-4(fp)
   34548:	e0bff917 	ldw	r2,-28(fp)
   3454c:	108018e4 	muli	r2,r2,99
   34550:	1887883a 	add	r3,r3,r2
   34554:	e0bffa17 	ldw	r2,-24(fp)
   34558:	1885883a 	add	r2,r3,r2
   3455c:	10800c04 	addi	r2,r2,48
   34560:	e0fffe03 	ldbu	r3,-8(fp)
   34564:	10c00005 	stb	r3,0(r2)
    int width  = sp->line[y].width;
    int offset = (scrollpos * sp->line[y].speed) >> 8;
    if (offset >= width)
      offset = 0;

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
   34568:	e0bffa17 	ldw	r2,-24(fp)
   3456c:	10800044 	addi	r2,r2,1
   34570:	e0bffa15 	stw	r2,-24(fp)
   34574:	e0bffa17 	ldw	r2,-24(fp)
   34578:	10800410 	cmplti	r2,r2,16
   3457c:	103fb61e 	bne	r2,zero,34458 <lcd_repaint_screen+0x98>
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   34580:	e0bff917 	ldw	r2,-28(fp)
   34584:	10800044 	addi	r2,r2,1
   34588:	e0bff915 	stw	r2,-28(fp)
   3458c:	e0bff917 	ldw	r2,-28(fp)
   34590:	10800090 	cmplti	r2,r2,2
   34594:	103f951e 	bne	r2,zero,343ec <lcd_repaint_screen+0x2c>
        lcd_write_data(sp, c);
        sp->line[y].visible[x] = c;
      }
    }
  }
}
   34598:	e037883a 	mov	sp,fp
   3459c:	dfc00117 	ldw	ra,4(sp)
   345a0:	df000017 	ldw	fp,0(sp)
   345a4:	dec00204 	addi	sp,sp,8
   345a8:	f800283a 	ret

000345ac <lcd_scroll_up>:

/* --------------------------------------------------------------------- */

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
   345ac:	defffc04 	addi	sp,sp,-16
   345b0:	dfc00315 	stw	ra,12(sp)
   345b4:	df000215 	stw	fp,8(sp)
   345b8:	df000204 	addi	fp,sp,8
   345bc:	e13fff15 	stw	r4,-4(fp)
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   345c0:	e03ffe15 	stw	zero,-8(fp)
   345c4:	00001e06 	br	34640 <lcd_scroll_up+0x94>
  {
    if (y < ALT_LCD_HEIGHT-1)
   345c8:	e0bffe17 	ldw	r2,-8(fp)
   345cc:	00801016 	blt	zero,r2,34610 <lcd_scroll_up+0x64>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
   345d0:	e0bffe17 	ldw	r2,-8(fp)
   345d4:	108018e4 	muli	r2,r2,99
   345d8:	10801004 	addi	r2,r2,64
   345dc:	e0ffff17 	ldw	r3,-4(fp)
   345e0:	1887883a 	add	r3,r3,r2
   345e4:	e0bffe17 	ldw	r2,-8(fp)
   345e8:	10800044 	addi	r2,r2,1
   345ec:	108018e4 	muli	r2,r2,99
   345f0:	10801004 	addi	r2,r2,64
   345f4:	e13fff17 	ldw	r4,-4(fp)
   345f8:	2085883a 	add	r2,r4,r2
   345fc:	1809883a 	mov	r4,r3
   34600:	100b883a 	mov	r5,r2
   34604:	01801404 	movi	r6,80
   34608:	00041f00 	call	41f0 <memcpy>
   3460c:	00000906 	br	34634 <lcd_scroll_up+0x88>
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
   34610:	e0bffe17 	ldw	r2,-8(fp)
   34614:	108018e4 	muli	r2,r2,99
   34618:	10801004 	addi	r2,r2,64
   3461c:	e0ffff17 	ldw	r3,-4(fp)
   34620:	1885883a 	add	r2,r3,r2
   34624:	1009883a 	mov	r4,r2
   34628:	01400804 	movi	r5,32
   3462c:	01801404 	movi	r6,80
   34630:	00042e80 	call	42e8 <memset>

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   34634:	e0bffe17 	ldw	r2,-8(fp)
   34638:	10800044 	addi	r2,r2,1
   3463c:	e0bffe15 	stw	r2,-8(fp)
   34640:	e0bffe17 	ldw	r2,-8(fp)
   34644:	10800090 	cmplti	r2,r2,2
   34648:	103fdf1e 	bne	r2,zero,345c8 <lcd_scroll_up+0x1c>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
  }

  sp->y--;
   3464c:	e0bfff17 	ldw	r2,-4(fp)
   34650:	10800883 	ldbu	r2,34(r2)
   34654:	10bfffc4 	addi	r2,r2,-1
   34658:	1007883a 	mov	r3,r2
   3465c:	e0bfff17 	ldw	r2,-4(fp)
   34660:	10c00885 	stb	r3,34(r2)
}
   34664:	e037883a 	mov	sp,fp
   34668:	dfc00117 	ldw	ra,4(sp)
   3466c:	df000017 	ldw	fp,0(sp)
   34670:	dec00204 	addi	sp,sp,8
   34674:	f800283a 	ret

00034678 <lcd_handle_escape>:

/* --------------------------------------------------------------------- */

static void lcd_handle_escape(altera_avalon_lcd_16207_state* sp, char c)
{
   34678:	defff904 	addi	sp,sp,-28
   3467c:	dfc00615 	stw	ra,24(sp)
   34680:	df000515 	stw	fp,20(sp)
   34684:	df000504 	addi	fp,sp,20
   34688:	e13ffe15 	stw	r4,-8(fp)
   3468c:	2805883a 	mov	r2,r5
   34690:	e0bfff05 	stb	r2,-4(fp)
  int parm1 = 0, parm2 = 0;
   34694:	e03ffb15 	stw	zero,-20(fp)
   34698:	e03ffc15 	stw	zero,-16(fp)

  if (sp->escape[0] == '[')
   3469c:	e0bffe17 	ldw	r2,-8(fp)
   346a0:	10800a03 	ldbu	r2,40(r2)
   346a4:	10803fcc 	andi	r2,r2,255
   346a8:	1080201c 	xori	r2,r2,128
   346ac:	10bfe004 	addi	r2,r2,-128
   346b0:	108016d8 	cmpnei	r2,r2,91
   346b4:	1000441e 	bne	r2,zero,347c8 <lcd_handle_escape+0x150>
  {
    char * ptr = sp->escape+1;
   346b8:	e0bffe17 	ldw	r2,-8(fp)
   346bc:	10800a44 	addi	r2,r2,41
   346c0:	e0bffd15 	stw	r2,-12(fp)
    while (isdigit(*ptr))
   346c4:	00000d06 	br	346fc <lcd_handle_escape+0x84>
      parm1 = (parm1 * 10) + (*ptr++ - '0');
   346c8:	e0bffb17 	ldw	r2,-20(fp)
   346cc:	10c002a4 	muli	r3,r2,10
   346d0:	e0bffd17 	ldw	r2,-12(fp)
   346d4:	10800003 	ldbu	r2,0(r2)
   346d8:	10803fcc 	andi	r2,r2,255
   346dc:	1080201c 	xori	r2,r2,128
   346e0:	10bfe004 	addi	r2,r2,-128
   346e4:	10bff404 	addi	r2,r2,-48
   346e8:	1885883a 	add	r2,r3,r2
   346ec:	e0bffb15 	stw	r2,-20(fp)
   346f0:	e0bffd17 	ldw	r2,-12(fp)
   346f4:	10800044 	addi	r2,r2,1
   346f8:	e0bffd15 	stw	r2,-12(fp)
  int parm1 = 0, parm2 = 0;

  if (sp->escape[0] == '[')
  {
    char * ptr = sp->escape+1;
    while (isdigit(*ptr))
   346fc:	00800134 	movhi	r2,4
   34700:	1095de04 	addi	r2,r2,22392
   34704:	10c00017 	ldw	r3,0(r2)
   34708:	e0bffd17 	ldw	r2,-12(fp)
   3470c:	10800003 	ldbu	r2,0(r2)
   34710:	10803fcc 	andi	r2,r2,255
   34714:	1080201c 	xori	r2,r2,128
   34718:	10bfe004 	addi	r2,r2,-128
   3471c:	1885883a 	add	r2,r3,r2
   34720:	10800003 	ldbu	r2,0(r2)
   34724:	10803fcc 	andi	r2,r2,255
   34728:	1080010c 	andi	r2,r2,4
   3472c:	103fe61e 	bne	r2,zero,346c8 <lcd_handle_escape+0x50>
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
   34730:	e0bffd17 	ldw	r2,-12(fp)
   34734:	10800003 	ldbu	r2,0(r2)
   34738:	10803fcc 	andi	r2,r2,255
   3473c:	1080201c 	xori	r2,r2,128
   34740:	10bfe004 	addi	r2,r2,-128
   34744:	10800ed8 	cmpnei	r2,r2,59
   34748:	1000211e 	bne	r2,zero,347d0 <lcd_handle_escape+0x158>
    {
      ptr++;
   3474c:	e0bffd17 	ldw	r2,-12(fp)
   34750:	10800044 	addi	r2,r2,1
   34754:	e0bffd15 	stw	r2,-12(fp)
      while (isdigit(*ptr))
   34758:	00000d06 	br	34790 <lcd_handle_escape+0x118>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
   3475c:	e0bffc17 	ldw	r2,-16(fp)
   34760:	10c002a4 	muli	r3,r2,10
   34764:	e0bffd17 	ldw	r2,-12(fp)
   34768:	10800003 	ldbu	r2,0(r2)
   3476c:	10803fcc 	andi	r2,r2,255
   34770:	1080201c 	xori	r2,r2,128
   34774:	10bfe004 	addi	r2,r2,-128
   34778:	10bff404 	addi	r2,r2,-48
   3477c:	1885883a 	add	r2,r3,r2
   34780:	e0bffc15 	stw	r2,-16(fp)
   34784:	e0bffd17 	ldw	r2,-12(fp)
   34788:	10800044 	addi	r2,r2,1
   3478c:	e0bffd15 	stw	r2,-12(fp)
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
    {
      ptr++;
      while (isdigit(*ptr))
   34790:	00800134 	movhi	r2,4
   34794:	1095de04 	addi	r2,r2,22392
   34798:	10c00017 	ldw	r3,0(r2)
   3479c:	e0bffd17 	ldw	r2,-12(fp)
   347a0:	10800003 	ldbu	r2,0(r2)
   347a4:	10803fcc 	andi	r2,r2,255
   347a8:	1080201c 	xori	r2,r2,128
   347ac:	10bfe004 	addi	r2,r2,-128
   347b0:	1885883a 	add	r2,r3,r2
   347b4:	10800003 	ldbu	r2,0(r2)
   347b8:	10803fcc 	andi	r2,r2,255
   347bc:	1080010c 	andi	r2,r2,4
   347c0:	103fe61e 	bne	r2,zero,3475c <lcd_handle_escape+0xe4>
   347c4:	00000206 	br	347d0 <lcd_handle_escape+0x158>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
    }
  }
  else
    parm1 = -1;
   347c8:	00bfffc4 	movi	r2,-1
   347cc:	e0bffb15 	stw	r2,-20(fp)

  switch (c)
   347d0:	e0bfff07 	ldb	r2,-4(fp)
   347d4:	10c012a0 	cmpeqi	r3,r2,74
   347d8:	18002a1e 	bne	r3,zero,34884 <lcd_handle_escape+0x20c>
   347dc:	10c012c8 	cmpgei	r3,r2,75
   347e0:	1800031e 	bne	r3,zero,347f0 <lcd_handle_escape+0x178>
   347e4:	10801220 	cmpeqi	r2,r2,72
   347e8:	1000051e 	bne	r2,zero,34800 <lcd_handle_escape+0x188>
   347ec:	00004c06 	br	34920 <lcd_handle_escape+0x2a8>
   347f0:	10c012e0 	cmpeqi	r3,r2,75
   347f4:	1800291e 	bne	r3,zero,3489c <lcd_handle_escape+0x224>
   347f8:	108019a0 	cmpeqi	r2,r2,102
   347fc:	10004826 	beq	r2,zero,34920 <lcd_handle_escape+0x2a8>
  {
  case 'H': /* ESC '[' <y> ';' <x> 'H'  : Move cursor to location */
  case 'f': /* Same as above */
    if (parm2 > 0)
   34800:	e0bffc17 	ldw	r2,-16(fp)
   34804:	0080050e 	bge	zero,r2,3481c <lcd_handle_escape+0x1a4>
      sp->x = parm2 - 1;
   34808:	e0bffc17 	ldw	r2,-16(fp)
   3480c:	10bfffc4 	addi	r2,r2,-1
   34810:	1007883a 	mov	r3,r2
   34814:	e0bffe17 	ldw	r2,-8(fp)
   34818:	10c00845 	stb	r3,33(r2)
    if (parm1 > 0)
   3481c:	e0bffb17 	ldw	r2,-20(fp)
   34820:	00803a0e 	bge	zero,r2,3490c <lcd_handle_escape+0x294>
    {
      sp->y = parm1 - 1;
   34824:	e0bffb17 	ldw	r2,-20(fp)
   34828:	10bfffc4 	addi	r2,r2,-1
   3482c:	1007883a 	mov	r3,r2
   34830:	e0bffe17 	ldw	r2,-8(fp)
   34834:	10c00885 	stb	r3,34(r2)
      if (sp->y > ALT_LCD_HEIGHT * 2)
   34838:	e0bffe17 	ldw	r2,-8(fp)
   3483c:	10800883 	ldbu	r2,34(r2)
   34840:	10803fcc 	andi	r2,r2,255
   34844:	10800170 	cmpltui	r2,r2,5
   34848:	1000071e 	bne	r2,zero,34868 <lcd_handle_escape+0x1f0>
        sp->y = ALT_LCD_HEIGHT * 2;
   3484c:	e0bffe17 	ldw	r2,-8(fp)
   34850:	00c00104 	movi	r3,4
   34854:	10c00885 	stb	r3,34(r2)
      while (sp->y > ALT_LCD_HEIGHT)
   34858:	00000306 	br	34868 <lcd_handle_escape+0x1f0>
        lcd_scroll_up(sp);
   3485c:	e13ffe17 	ldw	r4,-8(fp)
   34860:	00345ac0 	call	345ac <lcd_scroll_up>
   34864:	00000106 	br	3486c <lcd_handle_escape+0x1f4>
    if (parm1 > 0)
    {
      sp->y = parm1 - 1;
      if (sp->y > ALT_LCD_HEIGHT * 2)
        sp->y = ALT_LCD_HEIGHT * 2;
      while (sp->y > ALT_LCD_HEIGHT)
   34868:	0001883a 	nop
   3486c:	e0bffe17 	ldw	r2,-8(fp)
   34870:	10800883 	ldbu	r2,34(r2)
   34874:	10803fcc 	andi	r2,r2,255
   34878:	108000e8 	cmpgeui	r2,r2,3
   3487c:	103ff71e 	bne	r2,zero,3485c <lcd_handle_escape+0x1e4>
        lcd_scroll_up(sp);
    }
    break;
   34880:	00002206 	br	3490c <lcd_handle_escape+0x294>
    /*   ESC J      is clear to beginning of line    [unimplemented]
     *   ESC [ 0 J  is clear to bottom of screen     [unimplemented]
     *   ESC [ 1 J  is clear to beginning of screen  [unimplemented]
     *   ESC [ 2 J  is clear screen
     */
    if (parm1 == 2)
   34884:	e0bffb17 	ldw	r2,-20(fp)
   34888:	10800098 	cmpnei	r2,r2,2
   3488c:	1000211e 	bne	r2,zero,34914 <lcd_handle_escape+0x29c>
      lcd_clear_screen(sp);
   34890:	e13ffe17 	ldw	r4,-8(fp)
   34894:	00342f40 	call	342f4 <lcd_clear_screen>
    break;
   34898:	00001e06 	br	34914 <lcd_handle_escape+0x29c>
    /*   ESC K      is clear to end of line
     *   ESC [ 0 K  is clear to end of line
     *   ESC [ 1 K  is clear to beginning of line    [unimplemented]
     *   ESC [ 2 K  is clear line                    [unimplemented]
     */
    if (parm1 < 1)
   3489c:	e0bffb17 	ldw	r2,-20(fp)
   348a0:	00801e16 	blt	zero,r2,3491c <lcd_handle_escape+0x2a4>
    {
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
   348a4:	e0bffe17 	ldw	r2,-8(fp)
   348a8:	10800843 	ldbu	r2,33(r2)
   348ac:	10803fcc 	andi	r2,r2,255
   348b0:	10801428 	cmpgeui	r2,r2,80
   348b4:	1000191e 	bne	r2,zero,3491c <lcd_handle_escape+0x2a4>
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
   348b8:	e0bffe17 	ldw	r2,-8(fp)
   348bc:	10800883 	ldbu	r2,34(r2)
   348c0:	10803fcc 	andi	r2,r2,255
   348c4:	108018e4 	muli	r2,r2,99
   348c8:	10801004 	addi	r2,r2,64
   348cc:	e0fffe17 	ldw	r3,-8(fp)
   348d0:	1887883a 	add	r3,r3,r2
   348d4:	e0bffe17 	ldw	r2,-8(fp)
   348d8:	10800843 	ldbu	r2,33(r2)
   348dc:	10803fcc 	andi	r2,r2,255
   348e0:	1887883a 	add	r3,r3,r2
   348e4:	e0bffe17 	ldw	r2,-8(fp)
   348e8:	10800843 	ldbu	r2,33(r2)
   348ec:	10803fcc 	andi	r2,r2,255
   348f0:	01001404 	movi	r4,80
   348f4:	2085c83a 	sub	r2,r4,r2
   348f8:	1809883a 	mov	r4,r3
   348fc:	01400804 	movi	r5,32
   34900:	100d883a 	mov	r6,r2
   34904:	00042e80 	call	42e8 <memset>
    }
    break;
   34908:	00000406 	br	3491c <lcd_handle_escape+0x2a4>
      if (sp->y > ALT_LCD_HEIGHT * 2)
        sp->y = ALT_LCD_HEIGHT * 2;
      while (sp->y > ALT_LCD_HEIGHT)
        lcd_scroll_up(sp);
    }
    break;
   3490c:	0001883a 	nop
   34910:	00000306 	br	34920 <lcd_handle_escape+0x2a8>
     *   ESC [ 1 J  is clear to beginning of screen  [unimplemented]
     *   ESC [ 2 J  is clear screen
     */
    if (parm1 == 2)
      lcd_clear_screen(sp);
    break;
   34914:	0001883a 	nop
   34918:	00000106 	br	34920 <lcd_handle_escape+0x2a8>
    if (parm1 < 1)
    {
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
    }
    break;
   3491c:	0001883a 	nop
  }
}
   34920:	e037883a 	mov	sp,fp
   34924:	dfc00117 	ldw	ra,4(sp)
   34928:	df000017 	ldw	fp,0(sp)
   3492c:	dec00204 	addi	sp,sp,8
   34930:	f800283a 	ret

00034934 <altera_avalon_lcd_16207_write>:

/* --------------------------------------------------------------------- */

int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp, 
  const char* ptr, int len, int flags)
{
   34934:	defff104 	addi	sp,sp,-60
   34938:	dfc00e15 	stw	ra,56(sp)
   3493c:	df000d15 	stw	fp,52(sp)
   34940:	df000d04 	addi	fp,sp,52
   34944:	e13ffc15 	stw	r4,-16(fp)
   34948:	e17ffd15 	stw	r5,-12(fp)
   3494c:	e1bffe15 	stw	r6,-8(fp)
   34950:	e1ffff15 	stw	r7,-4(fp)
  const char* end = ptr + len;
   34954:	e0bffe17 	ldw	r2,-8(fp)
   34958:	e0fffd17 	ldw	r3,-12(fp)
   3495c:	1885883a 	add	r2,r3,r2
   34960:	e0bff615 	stw	r2,-40(fp)

  /* When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
   34964:	e0bffc17 	ldw	r2,-16(fp)
   34968:	10803e17 	ldw	r2,248(r2)
   3496c:	e0bffa15 	stw	r2,-24(fp)
   34970:	e03ffb0d 	sth	zero,-20(fp)
   34974:	e0bffb0b 	ldhu	r2,-20(fp)
   34978:	e13ffa17 	ldw	r4,-24(fp)
   3497c:	000b883a 	mov	r5,zero
   34980:	100d883a 	mov	r6,r2
   34984:	000f883a 	mov	r7,zero
   34988:	000ebd80 	call	ebd8 <xQueueGenericReceive>
   3498c:	0001883a 	nop

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;
   34990:	e0bffc17 	ldw	r2,-16(fp)
   34994:	00c00044 	movi	r3,1
   34998:	10c009c5 	stb	r3,39(r2)

  for ( ; ptr < end ; ptr++)
   3499c:	00009d06 	br	34c14 <altera_avalon_lcd_16207_write+0x2e0>
  {
    char c = *ptr;
   349a0:	e0bffd17 	ldw	r2,-12(fp)
   349a4:	10800003 	ldbu	r2,0(r2)
   349a8:	e0bff705 	stb	r2,-36(fp)

    if (sp->esccount >= 0)
   349ac:	e0bffc17 	ldw	r2,-16(fp)
   349b0:	10800903 	ldbu	r2,36(r2)
   349b4:	10803fcc 	andi	r2,r2,255
   349b8:	1080201c 	xori	r2,r2,128
   349bc:	10bfe004 	addi	r2,r2,-128
   349c0:	10003816 	blt	r2,zero,34aa4 <altera_avalon_lcd_16207_write+0x170>
    {
      unsigned int esccount = sp->esccount;
   349c4:	e0bffc17 	ldw	r2,-16(fp)
   349c8:	10800903 	ldbu	r2,36(r2)
   349cc:	10803fcc 	andi	r2,r2,255
   349d0:	1080201c 	xori	r2,r2,128
   349d4:	10bfe004 	addi	r2,r2,-128
   349d8:	e0bff815 	stw	r2,-32(fp)

      /* Single character escape sequences can end with any character
       * Multi character escape sequences start with '[' and contain
       * digits and semicolons before terminating
       */
      if ((esccount == 0 && c != '[') ||
   349dc:	e0bff817 	ldw	r2,-32(fp)
   349e0:	1000031e 	bne	r2,zero,349f0 <altera_avalon_lcd_16207_write+0xbc>
   349e4:	e0bff707 	ldb	r2,-36(fp)
   349e8:	108016d8 	cmpnei	r2,r2,91
   349ec:	10000e1e 	bne	r2,zero,34a28 <altera_avalon_lcd_16207_write+0xf4>
   349f0:	e0bff817 	ldw	r2,-32(fp)
   349f4:	10001926 	beq	r2,zero,34a5c <altera_avalon_lcd_16207_write+0x128>
          (esccount > 0 && !isdigit(c) && c != ';'))
   349f8:	00800134 	movhi	r2,4
   349fc:	1095de04 	addi	r2,r2,22392
   34a00:	10c00017 	ldw	r3,0(r2)
   34a04:	e0bff707 	ldb	r2,-36(fp)
   34a08:	1885883a 	add	r2,r3,r2
   34a0c:	10800003 	ldbu	r2,0(r2)
   34a10:	10803fcc 	andi	r2,r2,255
   34a14:	1080010c 	andi	r2,r2,4
   34a18:	1000101e 	bne	r2,zero,34a5c <altera_avalon_lcd_16207_write+0x128>
   34a1c:	e0bff707 	ldb	r2,-36(fp)
   34a20:	10800ee0 	cmpeqi	r2,r2,59
   34a24:	10000d1e 	bne	r2,zero,34a5c <altera_avalon_lcd_16207_write+0x128>
      {
        sp->escape[esccount] = 0;
   34a28:	e0fffc17 	ldw	r3,-16(fp)
   34a2c:	e0bff817 	ldw	r2,-32(fp)
   34a30:	1885883a 	add	r2,r3,r2
   34a34:	10800a04 	addi	r2,r2,40
   34a38:	10000005 	stb	zero,0(r2)

        lcd_handle_escape(sp, c);
   34a3c:	e0bff707 	ldb	r2,-36(fp)
   34a40:	e13ffc17 	ldw	r4,-16(fp)
   34a44:	100b883a 	mov	r5,r2
   34a48:	00346780 	call	34678 <lcd_handle_escape>

        sp->esccount = -1;
   34a4c:	e0bffc17 	ldw	r2,-16(fp)
   34a50:	00ffffc4 	movi	r3,-1
   34a54:	10c00905 	stb	r3,36(r2)
   34a58:	00006b06 	br	34c08 <altera_avalon_lcd_16207_write+0x2d4>
      }
      else if (sp->esccount < sizeof(sp->escape)-1)
   34a5c:	e0bffc17 	ldw	r2,-16(fp)
   34a60:	10800903 	ldbu	r2,36(r2)
   34a64:	10803fcc 	andi	r2,r2,255
   34a68:	108001e8 	cmpgeui	r2,r2,7
   34a6c:	1000651e 	bne	r2,zero,34c04 <altera_avalon_lcd_16207_write+0x2d0>
      {
        sp->escape[esccount] = c;
   34a70:	e0fffc17 	ldw	r3,-16(fp)
   34a74:	e0bff817 	ldw	r2,-32(fp)
   34a78:	1885883a 	add	r2,r3,r2
   34a7c:	10800a04 	addi	r2,r2,40
   34a80:	e0fff703 	ldbu	r3,-36(fp)
   34a84:	10c00005 	stb	r3,0(r2)
        sp->esccount++;
   34a88:	e0bffc17 	ldw	r2,-16(fp)
   34a8c:	10800903 	ldbu	r2,36(r2)
   34a90:	10800044 	addi	r2,r2,1
   34a94:	1007883a 	mov	r3,r2
   34a98:	e0bffc17 	ldw	r2,-16(fp)
   34a9c:	10c00905 	stb	r3,36(r2)
   34aa0:	00005806 	br	34c04 <altera_avalon_lcd_16207_write+0x2d0>
      }
    }
    else if (c == 27) /* ESC */
   34aa4:	e0bff707 	ldb	r2,-36(fp)
   34aa8:	108006d8 	cmpnei	r2,r2,27
   34aac:	1000031e 	bne	r2,zero,34abc <altera_avalon_lcd_16207_write+0x188>
    {
      sp->esccount = 0;
   34ab0:	e0bffc17 	ldw	r2,-16(fp)
   34ab4:	10000905 	stb	zero,36(r2)
   34ab8:	00005306 	br	34c08 <altera_avalon_lcd_16207_write+0x2d4>
    }
    else if (c == '\r')
   34abc:	e0bff707 	ldb	r2,-36(fp)
   34ac0:	10800358 	cmpnei	r2,r2,13
   34ac4:	1000031e 	bne	r2,zero,34ad4 <altera_avalon_lcd_16207_write+0x1a0>
    {
      sp->x = 0;
   34ac8:	e0bffc17 	ldw	r2,-16(fp)
   34acc:	10000845 	stb	zero,33(r2)
   34ad0:	00004d06 	br	34c08 <altera_avalon_lcd_16207_write+0x2d4>
    }
    else if (c == '\n')
   34ad4:	e0bff707 	ldb	r2,-36(fp)
   34ad8:	10800298 	cmpnei	r2,r2,10
   34adc:	1000101e 	bne	r2,zero,34b20 <altera_avalon_lcd_16207_write+0x1ec>
    {
      sp->x = 0;
   34ae0:	e0bffc17 	ldw	r2,-16(fp)
   34ae4:	10000845 	stb	zero,33(r2)
      sp->y++;
   34ae8:	e0bffc17 	ldw	r2,-16(fp)
   34aec:	10800883 	ldbu	r2,34(r2)
   34af0:	10800044 	addi	r2,r2,1
   34af4:	1007883a 	mov	r3,r2
   34af8:	e0bffc17 	ldw	r2,-16(fp)
   34afc:	10c00885 	stb	r3,34(r2)

      /* Let the cursor sit at X=0, Y=HEIGHT without scrolling so the user
       * can print two lines of data without losing one.
       */
      if (sp->y > ALT_LCD_HEIGHT)
   34b00:	e0bffc17 	ldw	r2,-16(fp)
   34b04:	10800883 	ldbu	r2,34(r2)
   34b08:	10803fcc 	andi	r2,r2,255
   34b0c:	108000f0 	cmpltui	r2,r2,3
   34b10:	10003d1e 	bne	r2,zero,34c08 <altera_avalon_lcd_16207_write+0x2d4>
        lcd_scroll_up(sp);
   34b14:	e13ffc17 	ldw	r4,-16(fp)
   34b18:	00345ac0 	call	345ac <lcd_scroll_up>
   34b1c:	00003a06 	br	34c08 <altera_avalon_lcd_16207_write+0x2d4>
    }
    else if (c == '\b')
   34b20:	e0bff707 	ldb	r2,-36(fp)
   34b24:	10800218 	cmpnei	r2,r2,8
   34b28:	10000b1e 	bne	r2,zero,34b58 <altera_avalon_lcd_16207_write+0x224>
    {
      if (sp->x > 0)
   34b2c:	e0bffc17 	ldw	r2,-16(fp)
   34b30:	10800843 	ldbu	r2,33(r2)
   34b34:	10803fcc 	andi	r2,r2,255
   34b38:	10003326 	beq	r2,zero,34c08 <altera_avalon_lcd_16207_write+0x2d4>
        sp->x--;
   34b3c:	e0bffc17 	ldw	r2,-16(fp)
   34b40:	10800843 	ldbu	r2,33(r2)
   34b44:	10bfffc4 	addi	r2,r2,-1
   34b48:	1007883a 	mov	r3,r2
   34b4c:	e0bffc17 	ldw	r2,-16(fp)
   34b50:	10c00845 	stb	r3,33(r2)
   34b54:	00002c06 	br	34c08 <altera_avalon_lcd_16207_write+0x2d4>
    }
    else if (isprint(c))
   34b58:	00800134 	movhi	r2,4
   34b5c:	1095de04 	addi	r2,r2,22392
   34b60:	10c00017 	ldw	r3,0(r2)
   34b64:	e0bff707 	ldb	r2,-36(fp)
   34b68:	1885883a 	add	r2,r3,r2
   34b6c:	10800003 	ldbu	r2,0(r2)
   34b70:	10803fcc 	andi	r2,r2,255
   34b74:	1080201c 	xori	r2,r2,128
   34b78:	10bfe004 	addi	r2,r2,-128
   34b7c:	108025cc 	andi	r2,r2,151
   34b80:	10002126 	beq	r2,zero,34c08 <altera_avalon_lcd_16207_write+0x2d4>
    {
      /* If we didn't scroll on the last linefeed then we might need to do
       * it now. */
      if (sp->y >= ALT_LCD_HEIGHT)
   34b84:	e0bffc17 	ldw	r2,-16(fp)
   34b88:	10800883 	ldbu	r2,34(r2)
   34b8c:	10803fcc 	andi	r2,r2,255
   34b90:	108000b0 	cmpltui	r2,r2,2
   34b94:	1000021e 	bne	r2,zero,34ba0 <altera_avalon_lcd_16207_write+0x26c>
        lcd_scroll_up(sp);
   34b98:	e13ffc17 	ldw	r4,-16(fp)
   34b9c:	00345ac0 	call	345ac <lcd_scroll_up>

      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
   34ba0:	e0bffc17 	ldw	r2,-16(fp)
   34ba4:	10800843 	ldbu	r2,33(r2)
   34ba8:	10803fcc 	andi	r2,r2,255
   34bac:	10801428 	cmpgeui	r2,r2,80
   34bb0:	10000d1e 	bne	r2,zero,34be8 <altera_avalon_lcd_16207_write+0x2b4>
        sp->line[sp->y].data[sp->x] = c;
   34bb4:	e0bffc17 	ldw	r2,-16(fp)
   34bb8:	10800883 	ldbu	r2,34(r2)
   34bbc:	10c03fcc 	andi	r3,r2,255
   34bc0:	e0bffc17 	ldw	r2,-16(fp)
   34bc4:	10800843 	ldbu	r2,33(r2)
   34bc8:	10803fcc 	andi	r2,r2,255
   34bcc:	e13ffc17 	ldw	r4,-16(fp)
   34bd0:	18c018e4 	muli	r3,r3,99
   34bd4:	20c7883a 	add	r3,r4,r3
   34bd8:	1885883a 	add	r2,r3,r2
   34bdc:	10801004 	addi	r2,r2,64
   34be0:	e0fff703 	ldbu	r3,-36(fp)
   34be4:	10c00005 	stb	r3,0(r2)

      sp->x++;
   34be8:	e0bffc17 	ldw	r2,-16(fp)
   34bec:	10800843 	ldbu	r2,33(r2)
   34bf0:	10800044 	addi	r2,r2,1
   34bf4:	1007883a 	mov	r3,r2
   34bf8:	e0bffc17 	ldw	r2,-16(fp)
   34bfc:	10c00845 	stb	r3,33(r2)
   34c00:	00000106 	br	34c08 <altera_avalon_lcd_16207_write+0x2d4>
        sp->esccount = -1;
      }
      else if (sp->esccount < sizeof(sp->escape)-1)
      {
        sp->escape[esccount] = c;
        sp->esccount++;
   34c04:	0001883a 	nop

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;

  for ( ; ptr < end ; ptr++)
   34c08:	e0bffd17 	ldw	r2,-12(fp)
   34c0c:	10800044 	addi	r2,r2,1
   34c10:	e0bffd15 	stw	r2,-12(fp)
   34c14:	e0fffd17 	ldw	r3,-12(fp)
   34c18:	e0bff617 	ldw	r2,-40(fp)
   34c1c:	18bf6036 	bltu	r3,r2,349a0 <altera_avalon_lcd_16207_write+0x6c>
      sp->x++;
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
   34c20:	00800404 	movi	r2,16
   34c24:	e0bff415 	stw	r2,-48(fp)
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   34c28:	e03ff315 	stw	zero,-52(fp)
   34c2c:	00003706 	br	34d0c <altera_avalon_lcd_16207_write+0x3d8>
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
   34c30:	00801404 	movi	r2,80
   34c34:	e0bff515 	stw	r2,-44(fp)
   34c38:	00001106 	br	34c80 <altera_avalon_lcd_16207_write+0x34c>
      if (sp->line[y].data[width-1] != ' ')
   34c3c:	e0bff517 	ldw	r2,-44(fp)
   34c40:	10bfffc4 	addi	r2,r2,-1
   34c44:	e13ffc17 	ldw	r4,-16(fp)
   34c48:	e0fff317 	ldw	r3,-52(fp)
   34c4c:	18c018e4 	muli	r3,r3,99
   34c50:	20c7883a 	add	r3,r4,r3
   34c54:	1885883a 	add	r2,r3,r2
   34c58:	10801004 	addi	r2,r2,64
   34c5c:	10800003 	ldbu	r2,0(r2)
   34c60:	10803fcc 	andi	r2,r2,255
   34c64:	1080201c 	xori	r2,r2,128
   34c68:	10bfe004 	addi	r2,r2,-128
   34c6c:	10800820 	cmpeqi	r2,r2,32
   34c70:	10000626 	beq	r2,zero,34c8c <altera_avalon_lcd_16207_write+0x358>
  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
   34c74:	e0bff517 	ldw	r2,-44(fp)
   34c78:	10bfffc4 	addi	r2,r2,-1
   34c7c:	e0bff515 	stw	r2,-44(fp)
   34c80:	e0bff517 	ldw	r2,-44(fp)
   34c84:	00bfed16 	blt	zero,r2,34c3c <altera_avalon_lcd_16207_write+0x308>
   34c88:	00000106 	br	34c90 <altera_avalon_lcd_16207_write+0x35c>
      if (sp->line[y].data[width-1] != ' ')
        break;
   34c8c:	0001883a 	nop

    /* The minimum width is the size of the LCD panel.  If the real width
     * is long enough to require scrolling then add an extra space so the
     * end of the message doesn't run into the beginning of it.
     */
    if (width <= ALT_LCD_WIDTH)
   34c90:	e0bff517 	ldw	r2,-44(fp)
   34c94:	10800448 	cmpgei	r2,r2,17
   34c98:	1000031e 	bne	r2,zero,34ca8 <altera_avalon_lcd_16207_write+0x374>
      width = ALT_LCD_WIDTH;
   34c9c:	00800404 	movi	r2,16
   34ca0:	e0bff515 	stw	r2,-44(fp)
   34ca4:	00000306 	br	34cb4 <altera_avalon_lcd_16207_write+0x380>
    else
      width++;
   34ca8:	e0bff517 	ldw	r2,-44(fp)
   34cac:	10800044 	addi	r2,r2,1
   34cb0:	e0bff515 	stw	r2,-44(fp)

    sp->line[y].width = width;
   34cb4:	e0bff517 	ldw	r2,-44(fp)
   34cb8:	1007883a 	mov	r3,r2
   34cbc:	e13ffc17 	ldw	r4,-16(fp)
   34cc0:	e0bff317 	ldw	r2,-52(fp)
   34cc4:	108018e4 	muli	r2,r2,99
   34cc8:	2085883a 	add	r2,r4,r2
   34ccc:	10802404 	addi	r2,r2,144
   34cd0:	10c00045 	stb	r3,1(r2)
    if (widthmax < width)
   34cd4:	e0fff417 	ldw	r3,-48(fp)
   34cd8:	e0bff517 	ldw	r2,-44(fp)
   34cdc:	1880020e 	bge	r3,r2,34ce8 <altera_avalon_lcd_16207_write+0x3b4>
      widthmax = width;
   34ce0:	e0bff517 	ldw	r2,-44(fp)
   34ce4:	e0bff415 	stw	r2,-48(fp)
    sp->line[y].speed = 0; /* By default lines don't scroll */
   34ce8:	e0fffc17 	ldw	r3,-16(fp)
   34cec:	e0bff317 	ldw	r2,-52(fp)
   34cf0:	108018e4 	muli	r2,r2,99
   34cf4:	1885883a 	add	r2,r3,r2
   34cf8:	10802404 	addi	r2,r2,144
   34cfc:	10000085 	stb	zero,2(r2)
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   34d00:	e0bff317 	ldw	r2,-52(fp)
   34d04:	10800044 	addi	r2,r2,1
   34d08:	e0bff315 	stw	r2,-52(fp)
   34d0c:	e0bff317 	ldw	r2,-52(fp)
   34d10:	10800090 	cmplti	r2,r2,2
   34d14:	103fc61e 	bne	r2,zero,34c30 <altera_avalon_lcd_16207_write+0x2fc>
    if (widthmax < width)
      widthmax = width;
    sp->line[y].speed = 0; /* By default lines don't scroll */
  }

  if (widthmax <= ALT_LCD_WIDTH)
   34d18:	e0bff417 	ldw	r2,-48(fp)
   34d1c:	10800448 	cmpgei	r2,r2,17
   34d20:	1000031e 	bne	r2,zero,34d30 <altera_avalon_lcd_16207_write+0x3fc>
    sp->scrollmax = 0;
   34d24:	e0bffc17 	ldw	r2,-16(fp)
   34d28:	10000985 	stb	zero,38(r2)
   34d2c:	00002d06 	br	34de4 <altera_avalon_lcd_16207_write+0x4b0>
  else
  {
    widthmax *= 2;
   34d30:	e0bff417 	ldw	r2,-48(fp)
   34d34:	1085883a 	add	r2,r2,r2
   34d38:	e0bff415 	stw	r2,-48(fp)
    sp->scrollmax = widthmax;
   34d3c:	e0bff417 	ldw	r2,-48(fp)
   34d40:	1007883a 	mov	r3,r2
   34d44:	e0bffc17 	ldw	r2,-16(fp)
   34d48:	10c00985 	stb	r3,38(r2)

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   34d4c:	e03ff315 	stw	zero,-52(fp)
   34d50:	00002106 	br	34dd8 <altera_avalon_lcd_16207_write+0x4a4>
      if (sp->line[y].width > ALT_LCD_WIDTH)
   34d54:	e0fffc17 	ldw	r3,-16(fp)
   34d58:	e0bff317 	ldw	r2,-52(fp)
   34d5c:	108018e4 	muli	r2,r2,99
   34d60:	1885883a 	add	r2,r3,r2
   34d64:	10802404 	addi	r2,r2,144
   34d68:	10800043 	ldbu	r2,1(r2)
   34d6c:	10803fcc 	andi	r2,r2,255
   34d70:	1080201c 	xori	r2,r2,128
   34d74:	10bfe004 	addi	r2,r2,-128
   34d78:	10800450 	cmplti	r2,r2,17
   34d7c:	1000131e 	bne	r2,zero,34dcc <altera_avalon_lcd_16207_write+0x498>
         */
#if 1
        /* This option makes all the lines scroll round at different speeds
         * which are chosen so that all the scrolls finish at the same time.
         */
        sp->line[y].speed = 256 * sp->line[y].width / widthmax;
   34d80:	e0fffc17 	ldw	r3,-16(fp)
   34d84:	e0bff317 	ldw	r2,-52(fp)
   34d88:	108018e4 	muli	r2,r2,99
   34d8c:	1885883a 	add	r2,r3,r2
   34d90:	10802404 	addi	r2,r2,144
   34d94:	10800043 	ldbu	r2,1(r2)
   34d98:	10803fcc 	andi	r2,r2,255
   34d9c:	1080201c 	xori	r2,r2,128
   34da0:	10bfe004 	addi	r2,r2,-128
   34da4:	1006923a 	slli	r3,r2,8
   34da8:	e0bff417 	ldw	r2,-48(fp)
   34dac:	1885283a 	div	r2,r3,r2
   34db0:	1007883a 	mov	r3,r2
   34db4:	e13ffc17 	ldw	r4,-16(fp)
   34db8:	e0bff317 	ldw	r2,-52(fp)
   34dbc:	108018e4 	muli	r2,r2,99
   34dc0:	2085883a 	add	r2,r4,r2
   34dc4:	10802404 	addi	r2,r2,144
   34dc8:	10c00085 	stb	r3,2(r2)
  {
    widthmax *= 2;
    sp->scrollmax = widthmax;

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
   34dcc:	e0bff317 	ldw	r2,-52(fp)
   34dd0:	10800044 	addi	r2,r2,1
   34dd4:	e0bff315 	stw	r2,-52(fp)
   34dd8:	e0bff317 	ldw	r2,-52(fp)
   34ddc:	10800090 	cmplti	r2,r2,2
   34de0:	103fdc1e 	bne	r2,zero,34d54 <altera_avalon_lcd_16207_write+0x420>
   * (because active was set when the timer interrupt occurred).  If there
   * has been a missed repaint then paint again.  And again.  etc.
   */
  for ( ; ; )
  {
    int old_scrollpos = sp->scrollpos;
   34de4:	e0bffc17 	ldw	r2,-16(fp)
   34de8:	10800943 	ldbu	r2,37(r2)
   34dec:	10803fcc 	andi	r2,r2,255
   34df0:	e0bff915 	stw	r2,-28(fp)

    lcd_repaint_screen(sp);
   34df4:	e13ffc17 	ldw	r4,-16(fp)
   34df8:	00343c00 	call	343c0 <lcd_repaint_screen>

    /* Let the timer routines repaint the display again */
    sp->active = 0;
   34dfc:	e0bffc17 	ldw	r2,-16(fp)
   34e00:	100009c5 	stb	zero,39(r2)

    /* Have the timer routines tried to scroll while we were painting?
     * If not then we can exit */
    if (sp->scrollpos == old_scrollpos)
   34e04:	e0bffc17 	ldw	r2,-16(fp)
   34e08:	10800943 	ldbu	r2,37(r2)
   34e0c:	10c03fcc 	andi	r3,r2,255
   34e10:	e0bff917 	ldw	r2,-28(fp)
   34e14:	18800426 	beq	r3,r2,34e28 <altera_avalon_lcd_16207_write+0x4f4>
      break;

    /* We need to repaint again since the display scrolled while we were
     * painting last time */
    sp->active = 1;
   34e18:	e0bffc17 	ldw	r2,-16(fp)
   34e1c:	00c00044 	movi	r3,1
   34e20:	10c009c5 	stb	r3,39(r2)
  }
   34e24:	003fef06 	br	34de4 <altera_avalon_lcd_16207_write+0x4b0>
    sp->active = 0;

    /* Have the timer routines tried to scroll while we were painting?
     * If not then we can exit */
    if (sp->scrollpos == old_scrollpos)
      break;
   34e28:	0001883a 	nop

  /* Now that access to the display is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
   34e2c:	e0bffc17 	ldw	r2,-16(fp)
   34e30:	10803e17 	ldw	r2,248(r2)
   34e34:	1009883a 	mov	r4,r2
   34e38:	000b883a 	mov	r5,zero
   34e3c:	000d883a 	mov	r6,zero
   34e40:	000f883a 	mov	r7,zero
   34e44:	000e95c0 	call	e95c <xQueueGenericSend>

  return len;
   34e48:	e0bffe17 	ldw	r2,-8(fp)
}
   34e4c:	e037883a 	mov	sp,fp
   34e50:	dfc00117 	ldw	ra,4(sp)
   34e54:	df000017 	ldw	fp,0(sp)
   34e58:	dec00204 	addi	sp,sp,8
   34e5c:	f800283a 	ret

00034e60 <alt_lcd_16207_timeout>:
/*
 * Timeout routine is called every second
 */

static alt_u32 alt_lcd_16207_timeout(void* context) 
{
   34e60:	defffc04 	addi	sp,sp,-16
   34e64:	dfc00315 	stw	ra,12(sp)
   34e68:	df000215 	stw	fp,8(sp)
   34e6c:	df000204 	addi	fp,sp,8
   34e70:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_lcd_16207_state* sp = (altera_avalon_lcd_16207_state*)context;
   34e74:	e0bfff17 	ldw	r2,-4(fp)
   34e78:	e0bffe15 	stw	r2,-8(fp)

  /* Update the scrolling position */
  if (sp->scrollpos + 1 >= sp->scrollmax)
   34e7c:	e0bffe17 	ldw	r2,-8(fp)
   34e80:	10800943 	ldbu	r2,37(r2)
   34e84:	10803fcc 	andi	r2,r2,255
   34e88:	10c00044 	addi	r3,r2,1
   34e8c:	e0bffe17 	ldw	r2,-8(fp)
   34e90:	10800983 	ldbu	r2,38(r2)
   34e94:	10803fcc 	andi	r2,r2,255
   34e98:	18800316 	blt	r3,r2,34ea8 <alt_lcd_16207_timeout+0x48>
    sp->scrollpos = 0;
   34e9c:	e0bffe17 	ldw	r2,-8(fp)
   34ea0:	10000945 	stb	zero,37(r2)
   34ea4:	00000606 	br	34ec0 <alt_lcd_16207_timeout+0x60>
  else
    sp->scrollpos = sp->scrollpos + 1;
   34ea8:	e0bffe17 	ldw	r2,-8(fp)
   34eac:	10800943 	ldbu	r2,37(r2)
   34eb0:	10800044 	addi	r2,r2,1
   34eb4:	1007883a 	mov	r3,r2
   34eb8:	e0bffe17 	ldw	r2,-8(fp)
   34ebc:	10c00945 	stb	r3,37(r2)

  /* Repaint the panel unless the foreground will do it again soon */
  if (sp->scrollmax > 0 && !sp->active)
   34ec0:	e0bffe17 	ldw	r2,-8(fp)
   34ec4:	10800983 	ldbu	r2,38(r2)
   34ec8:	10803fcc 	andi	r2,r2,255
   34ecc:	10000826 	beq	r2,zero,34ef0 <alt_lcd_16207_timeout+0x90>
   34ed0:	e0bffe17 	ldw	r2,-8(fp)
   34ed4:	108009c3 	ldbu	r2,39(r2)
   34ed8:	10803fcc 	andi	r2,r2,255
   34edc:	1080201c 	xori	r2,r2,128
   34ee0:	10bfe004 	addi	r2,r2,-128
   34ee4:	1000021e 	bne	r2,zero,34ef0 <alt_lcd_16207_timeout+0x90>
    lcd_repaint_screen(sp);
   34ee8:	e13ffe17 	ldw	r4,-8(fp)
   34eec:	00343c00 	call	343c0 <lcd_repaint_screen>

  return sp->period;
   34ef0:	e0bffe17 	ldw	r2,-8(fp)
   34ef4:	10800717 	ldw	r2,28(r2)
}
   34ef8:	e037883a 	mov	sp,fp
   34efc:	dfc00117 	ldw	ra,4(sp)
   34f00:	df000017 	ldw	fp,0(sp)
   34f04:	dec00204 	addi	sp,sp,8
   34f08:	f800283a 	ret

00034f0c <altera_avalon_lcd_16207_init>:

/*
 * Called at boot time to initialise the LCD driver
 */
void altera_avalon_lcd_16207_init(altera_avalon_lcd_16207_state* sp)
{
   34f0c:	defffa04 	addi	sp,sp,-24
   34f10:	dfc00515 	stw	ra,20(sp)
   34f14:	df000415 	stw	fp,16(sp)
   34f18:	df000404 	addi	fp,sp,16
   34f1c:	e13fff15 	stw	r4,-4(fp)
  unsigned int base = sp->base;
   34f20:	e0bfff17 	ldw	r2,-4(fp)
   34f24:	10800017 	ldw	r2,0(r2)
   34f28:	e0bffc15 	stw	r2,-16(fp)

  /* Mark the device as functional */
  sp->broken = 0;
   34f2c:	e0bfff17 	ldw	r2,-4(fp)
   34f30:	10000805 	stb	zero,32(r2)

  ALT_SEM_CREATE (&sp->write_lock, 1);
   34f34:	e0bfff17 	ldw	r2,-4(fp)
   34f38:	10803e04 	addi	r2,r2,248
   34f3c:	e0bffd15 	stw	r2,-12(fp)
   34f40:	00800044 	movi	r2,1
   34f44:	e0bffe0d 	sth	r2,-8(fp)
 * alt_sem_create() is a wrapper for xSemaphoreCreateCounting(). The return value is 0 if 
 * the semaphore has been successfully created, or non-zero otherwise.
 */
static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (xSemaphoreHandle* sem, alt_u16 value)
{
	*sem = xSemaphoreCreateCounting(value ? value : 1, value);
   34f48:	e0bffe0b 	ldhu	r2,-8(fp)
   34f4c:	10000226 	beq	r2,zero,34f58 <altera_avalon_lcd_16207_init+0x4c>
   34f50:	e0bffe0b 	ldhu	r2,-8(fp)
   34f54:	00000106 	br	34f5c <altera_avalon_lcd_16207_init+0x50>
   34f58:	00800044 	movi	r2,1
   34f5c:	e0fffe0b 	ldhu	r3,-8(fp)
   34f60:	1009883a 	mov	r4,r2
   34f64:	180b883a 	mov	r5,r3
   34f68:	000e9040 	call	e904 <xQueueCreateCountingSemaphore>
   34f6c:	e0fffd17 	ldw	r3,-12(fp)
   34f70:	18800015 	stw	r2,0(r3)
   * the BUSY bit in the status register doesn't work until the display
   * has been reset three times.
   */

  /* Wait for 15 ms then reset */
  usleep(15000);
   34f74:	010ea604 	movi	r4,15000
   34f78:	00124300 	call	12430 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
   34f7c:	e0bffc17 	ldw	r2,-16(fp)
   34f80:	00c00c04 	movi	r3,48
   34f84:	10c00035 	stwio	r3,0(r2)

  /* Wait for another 4.1ms and reset again */
  usleep(4100);  
   34f88:	01040104 	movi	r4,4100
   34f8c:	00124300 	call	12430 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
   34f90:	e0bffc17 	ldw	r2,-16(fp)
   34f94:	00c00c04 	movi	r3,48
   34f98:	10c00035 	stwio	r3,0(r2)

  /* Wait a further 1 ms and reset a third time */
  usleep(1000);
   34f9c:	0100fa04 	movi	r4,1000
   34fa0:	00124300 	call	12430 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
   34fa4:	e0bffc17 	ldw	r2,-16(fp)
   34fa8:	00c00c04 	movi	r3,48
   34fac:	10c00035 	stwio	r3,0(r2)

  /* Setup interface parameters: 8 bit bus, 2 rows, 5x7 font */
  lcd_write_command(sp, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT | LCD_CMD_TWO_LINE);
   34fb0:	e13fff17 	ldw	r4,-4(fp)
   34fb4:	01400e04 	movi	r5,56
   34fb8:	00341700 	call	34170 <lcd_write_command>
  
  /* Turn display off */
  lcd_write_command(sp, LCD_CMD_ONOFF);
   34fbc:	e13fff17 	ldw	r4,-4(fp)
   34fc0:	01400204 	movi	r5,8
   34fc4:	00341700 	call	34170 <lcd_write_command>

  /* Clear display */
  lcd_clear_screen(sp);
   34fc8:	e13fff17 	ldw	r4,-4(fp)
   34fcc:	00342f40 	call	342f4 <lcd_clear_screen>
  
  /* Set mode: increment after writing, don't shift display */
  lcd_write_command(sp, LCD_CMD_MODES | LCD_CMD_MODE_INC);
   34fd0:	e13fff17 	ldw	r4,-4(fp)
   34fd4:	01400184 	movi	r5,6
   34fd8:	00341700 	call	34170 <lcd_write_command>

  /* Turn display on */
  lcd_write_command(sp, LCD_CMD_ONOFF | LCD_CMD_ENABLE_DISP);
   34fdc:	e13fff17 	ldw	r4,-4(fp)
   34fe0:	01400304 	movi	r5,12
   34fe4:	00341700 	call	34170 <lcd_write_command>

  sp->esccount = -1;
   34fe8:	e0bfff17 	ldw	r2,-4(fp)
   34fec:	00ffffc4 	movi	r3,-1
   34ff0:	10c00905 	stb	r3,36(r2)
  memset(sp->escape, 0, sizeof(sp->escape));
   34ff4:	e0bfff17 	ldw	r2,-4(fp)
   34ff8:	10800a04 	addi	r2,r2,40
   34ffc:	1009883a 	mov	r4,r2
   35000:	000b883a 	mov	r5,zero
   35004:	01800204 	movi	r6,8
   35008:	00042e80 	call	42e8 <memset>

  sp->scrollpos = 0;
   3500c:	e0bfff17 	ldw	r2,-4(fp)
   35010:	10000945 	stb	zero,37(r2)
  sp->scrollmax = 0;
   35014:	e0bfff17 	ldw	r2,-4(fp)
   35018:	10000985 	stb	zero,38(r2)
  sp->active = 0;
   3501c:	e0bfff17 	ldw	r2,-4(fp)
   35020:	100009c5 	stb	zero,39(r2)
   35024:	00800134 	movhi	r2,4
   35028:	109f0c04 	addi	r2,r2,31792
   3502c:	10800017 	ldw	r2,0(r2)

  sp->period = alt_ticks_per_second() / 10; /* Call every 100ms */
   35030:	1007883a 	mov	r3,r2
   35034:	00800284 	movi	r2,10
   35038:	1885203a 	divu	r2,r3,r2
   3503c:	1007883a 	mov	r3,r2
   35040:	e0bfff17 	ldw	r2,-4(fp)
   35044:	10c00715 	stw	r3,28(r2)

  alt_alarm_start(&sp->alarm, sp->period, &alt_lcd_16207_timeout, sp);
   35048:	e0bfff17 	ldw	r2,-4(fp)
   3504c:	10c00104 	addi	r3,r2,4
   35050:	e0bfff17 	ldw	r2,-4(fp)
   35054:	10800717 	ldw	r2,28(r2)
   35058:	1809883a 	mov	r4,r3
   3505c:	100b883a 	mov	r5,r2
   35060:	018000f4 	movhi	r6,3
   35064:	31939804 	addi	r6,r6,20064
   35068:	e1ffff17 	ldw	r7,-4(fp)
   3506c:	003c3d00 	call	3c3d0 <alt_alarm_start>
}
   35070:	e037883a 	mov	sp,fp
   35074:	dfc00117 	ldw	ra,4(sp)
   35078:	df000017 	ldw	fp,0(sp)
   3507c:	dec00204 	addi	sp,sp,8
   35080:	f800283a 	ret

00035084 <altera_avalon_lcd_16207_write_fd>:
extern int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp,
  const char* ptr, int count, int flags);

int 
altera_avalon_lcd_16207_write_fd(alt_fd* fd, const char* buffer, int space)
{
   35084:	defffa04 	addi	sp,sp,-24
   35088:	dfc00515 	stw	ra,20(sp)
   3508c:	df000415 	stw	fp,16(sp)
   35090:	df000404 	addi	fp,sp,16
   35094:	e13ffd15 	stw	r4,-12(fp)
   35098:	e17ffe15 	stw	r5,-8(fp)
   3509c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_lcd_16207_dev* dev = (altera_avalon_lcd_16207_dev*) fd->dev; 
   350a0:	e0bffd17 	ldw	r2,-12(fp)
   350a4:	10800017 	ldw	r2,0(r2)
   350a8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_lcd_16207_write(&dev->state, buffer, space,
   350ac:	e0bffc17 	ldw	r2,-16(fp)
   350b0:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
   350b4:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_lcd_16207_write_fd(alt_fd* fd, const char* buffer, int space)
{
    altera_avalon_lcd_16207_dev* dev = (altera_avalon_lcd_16207_dev*) fd->dev; 

    return altera_avalon_lcd_16207_write(&dev->state, buffer, space,
   350b8:	10800217 	ldw	r2,8(r2)
   350bc:	1809883a 	mov	r4,r3
   350c0:	e17ffe17 	ldw	r5,-8(fp)
   350c4:	e1bfff17 	ldw	r6,-4(fp)
   350c8:	100f883a 	mov	r7,r2
   350cc:	00349340 	call	34934 <altera_avalon_lcd_16207_write>
      fd->fd_flags);
}
   350d0:	e037883a 	mov	sp,fp
   350d4:	dfc00117 	ldw	ra,4(sp)
   350d8:	df000017 	ldw	fp,0(sp)
   350dc:	dec00204 	addi	sp,sp,8
   350e0:	f800283a 	ret

000350e4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   350e4:	defffe04 	addi	sp,sp,-8
   350e8:	dfc00115 	stw	ra,4(sp)
   350ec:	df000015 	stw	fp,0(sp)
   350f0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   350f4:	00800134 	movhi	r2,4
   350f8:	1095d904 	addi	r2,r2,22372
   350fc:	10800017 	ldw	r2,0(r2)
   35100:	10000526 	beq	r2,zero,35118 <alt_get_errno+0x34>
   35104:	00800134 	movhi	r2,4
   35108:	1095d904 	addi	r2,r2,22372
   3510c:	10800017 	ldw	r2,0(r2)
   35110:	103ee83a 	callr	r2
   35114:	00000206 	br	35120 <alt_get_errno+0x3c>
   35118:	00800134 	movhi	r2,4
   3511c:	109ebe04 	addi	r2,r2,31480
}
   35120:	e037883a 	mov	sp,fp
   35124:	dfc00117 	ldw	ra,4(sp)
   35128:	df000017 	ldw	fp,0(sp)
   3512c:	dec00204 	addi	sp,sp,8
   35130:	f800283a 	ret

00035134 <alt_avalon_sgdma_do_async_transfer>:
 * - 0 for success, or various errors defined in <errno.h>
 */
int alt_avalon_sgdma_do_async_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
   35134:	defffc04 	addi	sp,sp,-16
   35138:	df000315 	stw	fp,12(sp)
   3513c:	df000304 	addi	fp,sp,12
   35140:	e13ffe15 	stw	r4,-8(fp)
   35144:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
   35148:	e0bffe17 	ldw	r2,-8(fp)
   3514c:	10800317 	ldw	r2,12(r2)
   35150:	10800037 	ldwio	r2,0(r2)
   35154:	1080040c 	andi	r2,r2,16
   35158:	10000226 	beq	r2,zero,35164 <alt_avalon_sgdma_do_async_transfer+0x30>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
   3515c:	00bffc04 	movi	r2,-16
   35160:	00003906 	br	35248 <alt_avalon_sgdma_do_async_transfer+0x114>
  }

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
   35164:	e0bffe17 	ldw	r2,-8(fp)
   35168:	10800317 	ldw	r2,12(r2)
   3516c:	10800404 	addi	r2,r2,16
   35170:	e0fffe17 	ldw	r3,-8(fp)
   35174:	18c00317 	ldw	r3,12(r3)
   35178:	18c00404 	addi	r3,r3,16
   3517c:	19000037 	ldwio	r4,0(r3)
   35180:	00fff7c4 	movi	r3,-33
   35184:	20c6703a 	and	r3,r4,r3
   35188:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
   3518c:	e0bffe17 	ldw	r2,-8(fp)
   35190:	10800317 	ldw	r2,12(r2)
   35194:	00c03fc4 	movi	r3,255
   35198:	10c00035 	stwio	r3,0(r2)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
   3519c:	e0bffe17 	ldw	r2,-8(fp)
   351a0:	10800317 	ldw	r2,12(r2)
   351a4:	10800804 	addi	r2,r2,32
   351a8:	e0ffff17 	ldw	r3,-4(fp)
   351ac:	10c00035 	stwio	r3,0(r2)
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
   351b0:	e0bffe17 	ldw	r2,-8(fp)
   351b4:	10800917 	ldw	r2,36(r2)
   351b8:	10001126 	beq	r2,zero,35200 <alt_avalon_sgdma_do_async_transfer+0xcc>
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   351bc:	e0bffe17 	ldw	r2,-8(fp)
   351c0:	10800317 	ldw	r2,12(r2)
   351c4:	10800404 	addi	r2,r2,16
   351c8:	10800037 	ldwio	r2,0(r2)
   351cc:	e0bffd15 	stw	r2,-12(fp)

    control |= (dev->chain_control                          |
   351d0:	e0bffe17 	ldw	r2,-8(fp)
   351d4:	10c00b17 	ldw	r3,44(r2)
   351d8:	e0bffd17 	ldw	r2,-12(fp)
   351dc:	1884b03a 	or	r2,r3,r2
   351e0:	10801814 	ori	r2,r2,96
   351e4:	e0bffd15 	stw	r2,-12(fp)
                ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK  );

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   351e8:	e0bffe17 	ldw	r2,-8(fp)
   351ec:	10800317 	ldw	r2,12(r2)
   351f0:	10800404 	addi	r2,r2,16
   351f4:	e0fffd17 	ldw	r3,-12(fp)
   351f8:	10c00035 	stwio	r3,0(r2)
   351fc:	00001106 	br	35244 <alt_avalon_sgdma_do_async_transfer+0x110>
   *   - Run
   *   - Stop on an error with any particular descriptor
   *   - Disable interrupt generation
   */
  else {
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   35200:	e0bffe17 	ldw	r2,-8(fp)
   35204:	10800317 	ldw	r2,12(r2)
   35208:	10800404 	addi	r2,r2,16
   3520c:	10800037 	ldwio	r2,0(r2)
   35210:	e0bffd15 	stw	r2,-12(fp)

    control |= (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
   35214:	e0bffd17 	ldw	r2,-12(fp)
   35218:	10801814 	ori	r2,r2,96
   3521c:	e0bffd15 	stw	r2,-12(fp)
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK );
    control &= ~ALTERA_AVALON_SGDMA_CONTROL_IE_GLOBAL_MSK;
   35220:	e0fffd17 	ldw	r3,-12(fp)
   35224:	00bffbc4 	movi	r2,-17
   35228:	1884703a 	and	r2,r3,r2
   3522c:	e0bffd15 	stw	r2,-12(fp)

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   35230:	e0bffe17 	ldw	r2,-8(fp)
   35234:	10800317 	ldw	r2,12(r2)
   35238:	10800404 	addi	r2,r2,16
   3523c:	e0fffd17 	ldw	r3,-12(fp)
   35240:	10c00035 	stwio	r3,0(r2)

  /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
  return 0;
   35244:	0005883a 	mov	r2,zero
}
   35248:	e037883a 	mov	sp,fp
   3524c:	df000017 	ldw	fp,0(sp)
   35250:	dec00104 	addi	sp,sp,4
   35254:	f800283a 	ret

00035258 <alt_avalon_sgdma_do_sync_transfer>:
 * - status: Content of SGDMA status register.
 */
alt_u8 alt_avalon_sgdma_do_sync_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
   35258:	defffc04 	addi	sp,sp,-16
   3525c:	df000315 	stw	fp,12(sp)
   35260:	df000304 	addi	fp,sp,12
   35264:	e13ffe15 	stw	r4,-8(fp)
   35268:	e17fff15 	stw	r5,-4(fp)
  alt_u8 status;

  /* Wait for any pending transfers to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
   3526c:	0001883a 	nop
   35270:	e0bffe17 	ldw	r2,-8(fp)
   35274:	10800317 	ldw	r2,12(r2)
   35278:	10800037 	ldwio	r2,0(r2)
   3527c:	1080040c 	andi	r2,r2,16
   35280:	103ffb1e 	bne	r2,zero,35270 <alt_avalon_sgdma_do_sync_transfer+0x18>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );


  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
   35284:	e0bffe17 	ldw	r2,-8(fp)
   35288:	10800317 	ldw	r2,12(r2)
   3528c:	10800404 	addi	r2,r2,16
   35290:	e0fffe17 	ldw	r3,-8(fp)
   35294:	18c00317 	ldw	r3,12(r3)
   35298:	18c00404 	addi	r3,r3,16
   3529c:	19000037 	ldwio	r4,0(r3)
   352a0:	00fff7c4 	movi	r3,-33
   352a4:	20c6703a 	and	r3,r4,r3
   352a8:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
   352ac:	e0bffe17 	ldw	r2,-8(fp)
   352b0:	10800317 	ldw	r2,12(r2)
   352b4:	00c03fc4 	movi	r3,255
   352b8:	10c00035 	stwio	r3,0(r2)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
   352bc:	e0bffe17 	ldw	r2,-8(fp)
   352c0:	10800317 	ldw	r2,12(r2)
   352c4:	10800804 	addi	r2,r2,32
   352c8:	e0ffff17 	ldw	r3,-4(fp)
   352cc:	10c00035 	stwio	r3,0(r2)
   * Set up SGDMA controller to:
   * - Disable interrupt generation
   * - Run once a valid descriptor is written to controller
   * - Stop on an error with any particular descriptor
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
   352d0:	e0bffe17 	ldw	r2,-8(fp)
   352d4:	10800317 	ldw	r2,12(r2)
   352d8:	10800404 	addi	r2,r2,16
   352dc:	e0fffe17 	ldw	r3,-8(fp)
   352e0:	18c00317 	ldw	r3,12(r3)
   352e4:	18c00404 	addi	r3,r3,16
   352e8:	18c00037 	ldwio	r3,0(r3)
   352ec:	18c01814 	ori	r3,r3,96
   352f0:	10c00035 	stwio	r3,0(r2)
    (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK |
     ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK | 
     IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base)) );

  /* Wait for the descriptor (chain) to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
   352f4:	0001883a 	nop
   352f8:	e0bffe17 	ldw	r2,-8(fp)
   352fc:	10800317 	ldw	r2,12(r2)
   35300:	10800037 	ldwio	r2,0(r2)
   35304:	1080040c 	andi	r2,r2,16
   35308:	103ffb1e 	bne	r2,zero,352f8 <alt_avalon_sgdma_do_sync_transfer+0xa0>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
   3530c:	e0bffe17 	ldw	r2,-8(fp)
   35310:	10800317 	ldw	r2,12(r2)
   35314:	10800404 	addi	r2,r2,16
   35318:	e0fffe17 	ldw	r3,-8(fp)
   3531c:	18c00317 	ldw	r3,12(r3)
   35320:	18c00404 	addi	r3,r3,16
   35324:	19000037 	ldwio	r4,0(r3)
   35328:	00fff7c4 	movi	r3,-33
   3532c:	20c6703a 	and	r3,r4,r3
   35330:	10c00035 	stwio	r3,0(r2)
    (IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) &
     ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK) );

  /* Get & clear status register contents */
  status = IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base);
   35334:	e0bffe17 	ldw	r2,-8(fp)
   35338:	10800317 	ldw	r2,12(r2)
   3533c:	10800037 	ldwio	r2,0(r2)
   35340:	e0bffd05 	stb	r2,-12(fp)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
   35344:	e0bffe17 	ldw	r2,-8(fp)
   35348:	10800317 	ldw	r2,12(r2)
   3534c:	00c03fc4 	movi	r3,255
   35350:	10c00035 	stwio	r3,0(r2)

  return status;
   35354:	e0bffd03 	ldbu	r2,-12(fp)
}
   35358:	e037883a 	mov	sp,fp
   3535c:	df000017 	ldw	fp,0(sp)
   35360:	dec00104 	addi	sp,sp,4
   35364:	f800283a 	ret

00035368 <alt_avalon_sgdma_construct_mem_to_mem_desc>:
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
   35368:	defff404 	addi	sp,sp,-48
   3536c:	dfc00b15 	stw	ra,44(sp)
   35370:	df000a15 	stw	fp,40(sp)
   35374:	df000a04 	addi	fp,sp,40
   35378:	e13ffb15 	stw	r4,-20(fp)
   3537c:	e17ffc15 	stw	r5,-16(fp)
   35380:	e1bffd15 	stw	r6,-12(fp)
   35384:	e1fffe15 	stw	r7,-8(fp)
   35388:	e0800217 	ldw	r2,8(fp)
   3538c:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
   35390:	e0bfff0b 	ldhu	r2,-4(fp)
   35394:	d8800015 	stw	r2,0(sp)
   35398:	e0800317 	ldw	r2,12(fp)
   3539c:	d8800115 	stw	r2,4(sp)
   353a0:	e0800417 	ldw	r2,16(fp)
   353a4:	d8800215 	stw	r2,8(sp)
   353a8:	d8000315 	stw	zero,12(sp)
   353ac:	d8000415 	stw	zero,16(sp)
   353b0:	e13ffb17 	ldw	r4,-20(fp)
   353b4:	e17ffc17 	ldw	r5,-16(fp)
   353b8:	e1bffd17 	ldw	r6,-12(fp)
   353bc:	e1fffe17 	ldw	r7,-8(fp)
   353c0:	00353d80 	call	353d8 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>
    write_addr, length, read_fixed, write_fixed, 0, 0);
}
   353c4:	e037883a 	mov	sp,fp
   353c8:	dfc00117 	ldw	ra,4(sp)
   353cc:	df000017 	ldw	fp,0(sp)
   353d0:	dec00204 	addi	sp,sp,8
   353d4:	f800283a 	ret

000353d8 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>:
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
   353d8:	defff204 	addi	sp,sp,-56
   353dc:	dfc00d15 	stw	ra,52(sp)
   353e0:	df000c15 	stw	fp,48(sp)
   353e4:	df000c04 	addi	fp,sp,48
   353e8:	e13ffb15 	stw	r4,-20(fp)
   353ec:	e17ffc15 	stw	r5,-16(fp)
   353f0:	e1bffd15 	stw	r6,-12(fp)
   353f4:	e1fffe15 	stw	r7,-8(fp)
   353f8:	e0800217 	ldw	r2,8(fp)
   353fc:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
   35400:	e0bfff0b 	ldhu	r2,-4(fp)
   35404:	d8800015 	stw	r2,0(sp)
   35408:	d8000115 	stw	zero,4(sp)
   3540c:	e0800317 	ldw	r2,12(fp)
   35410:	d8800215 	stw	r2,8(sp)
   35414:	e0800417 	ldw	r2,16(fp)
   35418:	d8800315 	stw	r2,12(sp)
   3541c:	e0800517 	ldw	r2,20(fp)
   35420:	d8800415 	stw	r2,16(sp)
   35424:	e0800617 	ldw	r2,24(fp)
   35428:	d8800515 	stw	r2,20(sp)
   3542c:	d8000615 	stw	zero,24(sp)
   35430:	e13ffb17 	ldw	r4,-20(fp)
   35434:	e17ffc17 	ldw	r5,-16(fp)
   35438:	e1bffd17 	ldw	r6,-12(fp)
   3543c:	e1fffe17 	ldw	r7,-8(fp)
   35440:	00359440 	call	35944 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    write_fixed,
    read_burst,
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in mem-to-mem mode
}
   35444:	e037883a 	mov	sp,fp
   35448:	dfc00117 	ldw	ra,4(sp)
   3544c:	df000017 	ldw	fp,0(sp)
   35450:	dec00204 	addi	sp,sp,8
   35454:	f800283a 	ret

00035458 <alt_avalon_sgdma_construct_stream_to_mem_desc>:
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
   35458:	defff804 	addi	sp,sp,-32
   3545c:	dfc00715 	stw	ra,28(sp)
   35460:	df000615 	stw	fp,24(sp)
   35464:	df000604 	addi	fp,sp,24
   35468:	e13ffc15 	stw	r4,-16(fp)
   3546c:	e17ffd15 	stw	r5,-12(fp)
   35470:	e1bffe15 	stw	r6,-8(fp)
   35474:	3805883a 	mov	r2,r7
   35478:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
   3547c:	e0bfff0b 	ldhu	r2,-4(fp)
   35480:	e0c00217 	ldw	r3,8(fp)
   35484:	d8c00015 	stw	r3,0(sp)
   35488:	d8000115 	stw	zero,4(sp)
   3548c:	e13ffc17 	ldw	r4,-16(fp)
   35490:	e17ffd17 	ldw	r5,-12(fp)
   35494:	e1bffe17 	ldw	r6,-8(fp)
   35498:	100f883a 	mov	r7,r2
   3549c:	00354b40 	call	354b4 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>
    length_or_eop, write_fixed, 0);
}
   354a0:	e037883a 	mov	sp,fp
   354a4:	dfc00117 	ldw	ra,4(sp)
   354a8:	df000017 	ldw	fp,0(sp)
   354ac:	dec00204 	addi	sp,sp,8
   354b0:	f800283a 	ret

000354b4 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>:
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
   354b4:	defff304 	addi	sp,sp,-52
   354b8:	dfc00c15 	stw	ra,48(sp)
   354bc:	df000b15 	stw	fp,44(sp)
   354c0:	df000b04 	addi	fp,sp,44
   354c4:	e13ffc15 	stw	r4,-16(fp)
   354c8:	e17ffd15 	stw	r5,-12(fp)
   354cc:	e1bffe15 	stw	r6,-8(fp)
   354d0:	3805883a 	mov	r2,r7
   354d4:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
   354d8:	e0bfff0b 	ldhu	r2,-4(fp)
   354dc:	d8800015 	stw	r2,0(sp)
   354e0:	d8000115 	stw	zero,4(sp)
   354e4:	d8000215 	stw	zero,8(sp)
   354e8:	e0800217 	ldw	r2,8(fp)
   354ec:	d8800315 	stw	r2,12(sp)
   354f0:	d8000415 	stw	zero,16(sp)
   354f4:	e0800317 	ldw	r2,12(fp)
   354f8:	d8800515 	stw	r2,20(sp)
   354fc:	d8000615 	stw	zero,24(sp)
   35500:	e13ffc17 	ldw	r4,-16(fp)
   35504:	e17ffd17 	ldw	r5,-12(fp)
   35508:	000d883a 	mov	r6,zero
   3550c:	e1fffe17 	ldw	r7,-8(fp)
   35510:	00359440 	call	35944 <alt_avalon_sgdma_construct_descriptor_burst>
    0x0,            // Read fixed: N/A in stream-to-mem mode
    write_fixed,
    0,              // Read_burst : N/A in stream-to-mem mode
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in stream-to-mem mode
}
   35514:	e037883a 	mov	sp,fp
   35518:	dfc00117 	ldw	ra,4(sp)
   3551c:	df000017 	ldw	fp,0(sp)
   35520:	dec00204 	addi	sp,sp,8
   35524:	f800283a 	ret

00035528 <alt_avalon_sgdma_construct_mem_to_stream_desc>:
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
   35528:	defff404 	addi	sp,sp,-48
   3552c:	dfc00b15 	stw	ra,44(sp)
   35530:	df000a15 	stw	fp,40(sp)
   35534:	df000a04 	addi	fp,sp,40
   35538:	e13ffb15 	stw	r4,-20(fp)
   3553c:	e17ffc15 	stw	r5,-16(fp)
   35540:	e1bffd15 	stw	r6,-12(fp)
   35544:	3805883a 	mov	r2,r7
   35548:	e0c00517 	ldw	r3,20(fp)
   3554c:	e0bffe0d 	sth	r2,-8(fp)
   35550:	e0ffff05 	stb	r3,-4(fp)
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
   35554:	e0bffe0b 	ldhu	r2,-8(fp)
   35558:	e0ffff03 	ldbu	r3,-4(fp)
   3555c:	e1000217 	ldw	r4,8(fp)
   35560:	d9000015 	stw	r4,0(sp)
   35564:	e1000317 	ldw	r4,12(fp)
   35568:	d9000115 	stw	r4,4(sp)
   3556c:	e1000417 	ldw	r4,16(fp)
   35570:	d9000215 	stw	r4,8(sp)
   35574:	d8000315 	stw	zero,12(sp)
   35578:	d8c00415 	stw	r3,16(sp)
   3557c:	e13ffb17 	ldw	r4,-20(fp)
   35580:	e17ffc17 	ldw	r5,-16(fp)
   35584:	e1bffd17 	ldw	r6,-12(fp)
   35588:	100f883a 	mov	r7,r2
   3558c:	00355a40 	call	355a4 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>
    length, read_fixed, generate_sop, generate_eop, 0, atlantic_channel);

}
   35590:	e037883a 	mov	sp,fp
   35594:	dfc00117 	ldw	ra,4(sp)
   35598:	df000017 	ldw	fp,0(sp)
   3559c:	dec00204 	addi	sp,sp,8
   355a0:	f800283a 	ret

000355a4 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>:
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
   355a4:	defff204 	addi	sp,sp,-56
   355a8:	dfc00d15 	stw	ra,52(sp)
   355ac:	df000c15 	stw	fp,48(sp)
   355b0:	df000c04 	addi	fp,sp,48
   355b4:	e13ffb15 	stw	r4,-20(fp)
   355b8:	e17ffc15 	stw	r5,-16(fp)
   355bc:	e1bffd15 	stw	r6,-12(fp)
   355c0:	3805883a 	mov	r2,r7
   355c4:	e0c00617 	ldw	r3,24(fp)
   355c8:	e0bffe0d 	sth	r2,-8(fp)
   355cc:	e0ffff05 	stb	r3,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
   355d0:	e0fffe0b 	ldhu	r3,-8(fp)
   355d4:	e0bfff03 	ldbu	r2,-4(fp)
   355d8:	d8c00015 	stw	r3,0(sp)
   355dc:	e0c00417 	ldw	r3,16(fp)
   355e0:	d8c00115 	stw	r3,4(sp)
   355e4:	e0c00217 	ldw	r3,8(fp)
   355e8:	d8c00215 	stw	r3,8(sp)
   355ec:	e0c00317 	ldw	r3,12(fp)
   355f0:	d8c00315 	stw	r3,12(sp)
   355f4:	e0c00517 	ldw	r3,20(fp)
   355f8:	d8c00415 	stw	r3,16(sp)
   355fc:	d8000515 	stw	zero,20(sp)
   35600:	d8800615 	stw	r2,24(sp)
   35604:	e13ffb17 	ldw	r4,-20(fp)
   35608:	e17ffc17 	ldw	r5,-16(fp)
   3560c:	e1bffd17 	ldw	r6,-12(fp)
   35610:	000f883a 	mov	r7,zero
   35614:	00359440 	call	35944 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    generate_sop,
    read_burst,
    0,                 // Write_burst : N/A in mem-to-stream mode
    atlantic_channel);
}
   35618:	e037883a 	mov	sp,fp
   3561c:	dfc00117 	ldw	ra,4(sp)
   35620:	df000017 	ldw	fp,0(sp)
   35624:	dec00204 	addi	sp,sp,8
   35628:	f800283a 	ret

0003562c <alt_avalon_sgdma_register_callback>:
void alt_avalon_sgdma_register_callback(
  alt_sgdma_dev *dev,
  alt_avalon_sgdma_callback callback,
  alt_u32 chain_control,
  void *context)
{
   3562c:	defffb04 	addi	sp,sp,-20
   35630:	df000415 	stw	fp,16(sp)
   35634:	df000404 	addi	fp,sp,16
   35638:	e13ffc15 	stw	r4,-16(fp)
   3563c:	e17ffd15 	stw	r5,-12(fp)
   35640:	e1bffe15 	stw	r6,-8(fp)
   35644:	e1ffff15 	stw	r7,-4(fp)
  dev->callback         = callback;
   35648:	e0bffc17 	ldw	r2,-16(fp)
   3564c:	e0fffd17 	ldw	r3,-12(fp)
   35650:	10c00915 	stw	r3,36(r2)
  dev->callback_context = context;
   35654:	e0bffc17 	ldw	r2,-16(fp)
   35658:	e0ffff17 	ldw	r3,-4(fp)
   3565c:	10c00a15 	stw	r3,40(r2)
  dev->chain_control    = chain_control;
   35660:	e0bffc17 	ldw	r2,-16(fp)
   35664:	e0fffe17 	ldw	r3,-8(fp)
   35668:	10c00b15 	stw	r3,44(r2)
}
   3566c:	e037883a 	mov	sp,fp
   35670:	df000017 	ldw	fp,0(sp)
   35674:	dec00104 	addi	sp,sp,4
   35678:	f800283a 	ret

0003567c <alt_avalon_sgdma_start>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct.
 */
void alt_avalon_sgdma_start(alt_sgdma_dev *dev)
{
   3567c:	defffd04 	addi	sp,sp,-12
   35680:	df000215 	stw	fp,8(sp)
   35684:	df000204 	addi	fp,sp,8
   35688:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   3568c:	e0bfff17 	ldw	r2,-4(fp)
   35690:	10800317 	ldw	r2,12(r2)
   35694:	10800404 	addi	r2,r2,16
   35698:	10800037 	ldwio	r2,0(r2)
   3569c:	e0bffe15 	stw	r2,-8(fp)
  control |= ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
   356a0:	e0bffe17 	ldw	r2,-8(fp)
   356a4:	10800814 	ori	r2,r2,32
   356a8:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   356ac:	e0bfff17 	ldw	r2,-4(fp)
   356b0:	10800317 	ldw	r2,12(r2)
   356b4:	10800404 	addi	r2,r2,16
   356b8:	e0fffe17 	ldw	r3,-8(fp)
   356bc:	10c00035 	stwio	r3,0(r2)
}
   356c0:	e037883a 	mov	sp,fp
   356c4:	df000017 	ldw	fp,0(sp)
   356c8:	dec00104 	addi	sp,sp,4
   356cc:	f800283a 	ret

000356d0 <alt_avalon_sgdma_stop>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct
 */
void alt_avalon_sgdma_stop(alt_sgdma_dev *dev)
{
   356d0:	defffd04 	addi	sp,sp,-12
   356d4:	df000215 	stw	fp,8(sp)
   356d8:	df000204 	addi	fp,sp,8
   356dc:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   356e0:	e0bfff17 	ldw	r2,-4(fp)
   356e4:	10800317 	ldw	r2,12(r2)
   356e8:	10800404 	addi	r2,r2,16
   356ec:	10800037 	ldwio	r2,0(r2)
   356f0:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
   356f4:	e0fffe17 	ldw	r3,-8(fp)
   356f8:	00bff7c4 	movi	r2,-33
   356fc:	1884703a 	and	r2,r3,r2
   35700:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   35704:	e0bfff17 	ldw	r2,-4(fp)
   35708:	10800317 	ldw	r2,12(r2)
   3570c:	10800404 	addi	r2,r2,16
   35710:	e0fffe17 	ldw	r3,-8(fp)
   35714:	10c00035 	stwio	r3,0(r2)
}
   35718:	e037883a 	mov	sp,fp
   3571c:	df000017 	ldw	fp,0(sp)
   35720:	dec00104 	addi	sp,sp,4
   35724:	f800283a 	ret

00035728 <alt_avalon_sgdma_check_descriptor_status>:
 * - 0 if the descriptor is error-free, not "owned by hardware", or
 *   a previously requested transfer has appeared to have completed
 *   normally. Or, various error conditions defined in <errno.h>
 */
int alt_avalon_sgdma_check_descriptor_status(alt_sgdma_descriptor *desc)
{
   35728:	defffe04 	addi	sp,sp,-8
   3572c:	df000115 	stw	fp,4(sp)
   35730:	df000104 	addi	fp,sp,4
   35734:	e13fff15 	stw	r4,-4(fp)
  /* Errors take precedence */
  if( IORD_8DIRECT(&desc->status, 0) &
   35738:	e0bfff17 	ldw	r2,-4(fp)
   3573c:	10800784 	addi	r2,r2,30
   35740:	10800023 	ldbuio	r2,0(r2)
   35744:	10803fcc 	andi	r2,r2,255
   35748:	10801fcc 	andi	r2,r2,127
   3574c:	10000226 	beq	r2,zero,35758 <alt_avalon_sgdma_check_descriptor_status+0x30>
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
   35750:	00bffec4 	movi	r2,-5
   35754:	00000906 	br	3577c <alt_avalon_sgdma_check_descriptor_status+0x54>
  }

  if( IORD_8DIRECT(&desc->control, 0) &
   35758:	e0bfff17 	ldw	r2,-4(fp)
   3575c:	108007c4 	addi	r2,r2,31
   35760:	10800023 	ldbuio	r2,0(r2)
   35764:	10803fcc 	andi	r2,r2,255
   35768:	1080200c 	andi	r2,r2,128
   3576c:	10000226 	beq	r2,zero,35778 <alt_avalon_sgdma_check_descriptor_status+0x50>
      ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK) {
    return -EINPROGRESS;
   35770:	00bfe244 	movi	r2,-119
   35774:	00000106 	br	3577c <alt_avalon_sgdma_check_descriptor_status+0x54>
  }

    return 0;
   35778:	0005883a 	mov	r2,zero
}
   3577c:	e037883a 	mov	sp,fp
   35780:	df000017 	ldw	fp,0(sp)
   35784:	dec00104 	addi	sp,sp,4
   35788:	f800283a 	ret

0003578c <alt_avalon_sgdma_open>:
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
   3578c:	defffc04 	addi	sp,sp,-16
   35790:	dfc00315 	stw	ra,12(sp)
   35794:	df000215 	stw	fp,8(sp)
   35798:	df000204 	addi	fp,sp,8
   3579c:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
   357a0:	e13fff17 	ldw	r4,-4(fp)
   357a4:	d1601a04 	addi	r5,gp,-32664
   357a8:	003c8ac0 	call	3c8ac <alt_find_dev>
   357ac:	e0bffe15 	stw	r2,-8(fp)

  if (NULL == dev) {
   357b0:	e0bffe17 	ldw	r2,-8(fp)
   357b4:	1000031e 	bne	r2,zero,357c4 <alt_avalon_sgdma_open+0x38>
    ALT_ERRNO = ENODEV;
   357b8:	00350e40 	call	350e4 <alt_get_errno>
   357bc:	00c004c4 	movi	r3,19
   357c0:	10c00015 	stw	r3,0(r2)
  }

  return dev;
   357c4:	e0bffe17 	ldw	r2,-8(fp)
}
   357c8:	e037883a 	mov	sp,fp
   357cc:	dfc00117 	ldw	ra,4(sp)
   357d0:	df000017 	ldw	fp,0(sp)
   357d4:	dec00204 	addi	sp,sp,8
   357d8:	f800283a 	ret

000357dc <alt_avalon_sgdma_construct_descriptor>:
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
   357dc:	defff104 	addi	sp,sp,-60
   357e0:	dfc00e15 	stw	ra,56(sp)
   357e4:	df000d15 	stw	fp,52(sp)
   357e8:	df000d04 	addi	fp,sp,52
   357ec:	e13ffa15 	stw	r4,-24(fp)
   357f0:	e17ffb15 	stw	r5,-20(fp)
   357f4:	e1bffc15 	stw	r6,-16(fp)
   357f8:	e1fffd15 	stw	r7,-12(fp)
   357fc:	e0c00217 	ldw	r3,8(fp)
   35800:	e0800617 	ldw	r2,24(fp)
   35804:	e0fffe0d 	sth	r3,-8(fp)
   35808:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
   3580c:	e0fffe0b 	ldhu	r3,-8(fp)
   35810:	e0bfff03 	ldbu	r2,-4(fp)
   35814:	d8c00015 	stw	r3,0(sp)
   35818:	e0c00317 	ldw	r3,12(fp)
   3581c:	d8c00115 	stw	r3,4(sp)
   35820:	e0c00417 	ldw	r3,16(fp)
   35824:	d8c00215 	stw	r3,8(sp)
   35828:	e0c00517 	ldw	r3,20(fp)
   3582c:	d8c00315 	stw	r3,12(sp)
   35830:	d8000415 	stw	zero,16(sp)
   35834:	d8000515 	stw	zero,20(sp)
   35838:	d8800615 	stw	r2,24(sp)
   3583c:	e13ffa17 	ldw	r4,-24(fp)
   35840:	e17ffb17 	ldw	r5,-20(fp)
   35844:	e1bffc17 	ldw	r6,-16(fp)
   35848:	e1fffd17 	ldw	r7,-12(fp)
   3584c:	00359440 	call	35944 <alt_avalon_sgdma_construct_descriptor_burst>
    write_addr, length_or_eop, generate_eop, read_fixed, write_fixed_or_sop, 
    0, 0, atlantic_channel);
}
   35850:	e037883a 	mov	sp,fp
   35854:	dfc00117 	ldw	ra,4(sp)
   35858:	df000017 	ldw	fp,0(sp)
   3585c:	dec00204 	addi	sp,sp,8
   35860:	f800283a 	ret

00035864 <alt_avalon_sgdma_enable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_enable_desc_poll(alt_sgdma_dev *dev, alt_u32 frequency)
{
   35864:	defffc04 	addi	sp,sp,-16
   35868:	df000315 	stw	fp,12(sp)
   3586c:	df000304 	addi	fp,sp,12
   35870:	e13ffe15 	stw	r4,-8(fp)
   35874:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   35878:	e0bffe17 	ldw	r2,-8(fp)
   3587c:	10800317 	ldw	r2,12(r2)
   35880:	10800404 	addi	r2,r2,16
   35884:	10800037 	ldwio	r2,0(r2)
   35888:	e0bffd15 	stw	r2,-12(fp)
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
   3588c:	e0fffd17 	ldw	r3,-12(fp)
   35890:	00a00434 	movhi	r2,32784
   35894:	10bfffc4 	addi	r2,r2,-1
   35898:	1884703a 	and	r2,r3,r2
   3589c:	e0bffd15 	stw	r2,-12(fp)
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
   358a0:	e0bfff17 	ldw	r2,-4(fp)
   358a4:	1004953a 	slli	r2,r2,20
   358a8:	10dffc2c 	andhi	r3,r2,32752

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
   358ac:	e0bffd17 	ldw	r2,-12(fp)
   358b0:	1884b03a 	or	r2,r3,r2
   358b4:	10800134 	orhi	r2,r2,4
   358b8:	e0bffd15 	stw	r2,-12(fp)
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   358bc:	e0bffe17 	ldw	r2,-8(fp)
   358c0:	10800317 	ldw	r2,12(r2)
   358c4:	10800404 	addi	r2,r2,16
   358c8:	e0fffd17 	ldw	r3,-12(fp)
   358cc:	10c00035 	stwio	r3,0(r2)
  
  return;
   358d0:	0001883a 	nop
}
   358d4:	e037883a 	mov	sp,fp
   358d8:	df000017 	ldw	fp,0(sp)
   358dc:	dec00104 	addi	sp,sp,4
   358e0:	f800283a 	ret

000358e4 <alt_avalon_sgdma_disable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_disable_desc_poll(alt_sgdma_dev *dev)
{
   358e4:	defffd04 	addi	sp,sp,-12
   358e8:	df000215 	stw	fp,8(sp)
   358ec:	df000204 	addi	fp,sp,8
   358f0:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   358f4:	e0bfff17 	ldw	r2,-4(fp)
   358f8:	10800317 	ldw	r2,12(r2)
   358fc:	10800404 	addi	r2,r2,16
   35900:	10800037 	ldwio	r2,0(r2)
   35904:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK;
   35908:	e0fffe17 	ldw	r3,-8(fp)
   3590c:	00bfff34 	movhi	r2,65532
   35910:	10bfffc4 	addi	r2,r2,-1
   35914:	1884703a 	and	r2,r3,r2
   35918:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
   3591c:	e0bfff17 	ldw	r2,-4(fp)
   35920:	10800317 	ldw	r2,12(r2)
   35924:	10800404 	addi	r2,r2,16
   35928:	e0fffe17 	ldw	r3,-8(fp)
   3592c:	10c00035 	stwio	r3,0(r2)
  
  return;
   35930:	0001883a 	nop
}
   35934:	e037883a 	mov	sp,fp
   35938:	df000017 	ldw	fp,0(sp)
   3593c:	dec00104 	addi	sp,sp,4
   35940:	f800283a 	ret

00035944 <alt_avalon_sgdma_construct_descriptor_burst>:
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
   35944:	defff804 	addi	sp,sp,-32
   35948:	dfc00715 	stw	ra,28(sp)
   3594c:	df000615 	stw	fp,24(sp)
   35950:	df000604 	addi	fp,sp,24
   35954:	e13ffa15 	stw	r4,-24(fp)
   35958:	e17ffb15 	stw	r5,-20(fp)
   3595c:	e1bffc15 	stw	r6,-16(fp)
   35960:	e1fffd15 	stw	r7,-12(fp)
   35964:	e0c00217 	ldw	r3,8(fp)
   35968:	e0800817 	ldw	r2,32(fp)
   3596c:	e0fffe0d 	sth	r3,-8(fp)
   35970:	e0bfff05 	stb	r2,-4(fp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
   35974:	e0bffb17 	ldw	r2,-20(fp)
   35978:	108007c4 	addi	r2,r2,31
   3597c:	e0fffb17 	ldw	r3,-20(fp)
   35980:	18c007c3 	ldbu	r3,31(r3)
   35984:	19003fcc 	andi	r4,r3,255
   35988:	00ffdfc4 	movi	r3,-129
   3598c:	20c6703a 	and	r3,r4,r3
   35990:	10c00025 	stbio	r3,0(r2)
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
   35994:	e0bffa17 	ldw	r2,-24(fp)
   35998:	e0fffc17 	ldw	r3,-16(fp)
   3599c:	18c03fcc 	andi	r3,r3,255
   359a0:	11000003 	ldbu	r4,0(r2)
   359a4:	2008703a 	and	r4,r4,zero
   359a8:	20c6b03a 	or	r3,r4,r3
   359ac:	10c00005 	stb	r3,0(r2)
   359b0:	e0fffc17 	ldw	r3,-16(fp)
   359b4:	1806d23a 	srli	r3,r3,8
   359b8:	18c03fcc 	andi	r3,r3,255
   359bc:	11000043 	ldbu	r4,1(r2)
   359c0:	2008703a 	and	r4,r4,zero
   359c4:	20c6b03a 	or	r3,r4,r3
   359c8:	10c00045 	stb	r3,1(r2)
   359cc:	e0fffc17 	ldw	r3,-16(fp)
   359d0:	1806d43a 	srli	r3,r3,16
   359d4:	18c03fcc 	andi	r3,r3,255
   359d8:	11000083 	ldbu	r4,2(r2)
   359dc:	2008703a 	and	r4,r4,zero
   359e0:	20c6b03a 	or	r3,r4,r3
   359e4:	10c00085 	stb	r3,2(r2)
   359e8:	e0fffc17 	ldw	r3,-16(fp)
   359ec:	1806d63a 	srli	r3,r3,24
   359f0:	110000c3 	ldbu	r4,3(r2)
   359f4:	2008703a 	and	r4,r4,zero
   359f8:	20c6b03a 	or	r3,r4,r3
   359fc:	10c000c5 	stb	r3,3(r2)
  desc->write_addr               = write_addr;
   35a00:	e0bffa17 	ldw	r2,-24(fp)
   35a04:	e0fffd17 	ldw	r3,-12(fp)
   35a08:	18c03fcc 	andi	r3,r3,255
   35a0c:	11000203 	ldbu	r4,8(r2)
   35a10:	2008703a 	and	r4,r4,zero
   35a14:	20c6b03a 	or	r3,r4,r3
   35a18:	10c00205 	stb	r3,8(r2)
   35a1c:	e0fffd17 	ldw	r3,-12(fp)
   35a20:	1806d23a 	srli	r3,r3,8
   35a24:	18c03fcc 	andi	r3,r3,255
   35a28:	11000243 	ldbu	r4,9(r2)
   35a2c:	2008703a 	and	r4,r4,zero
   35a30:	20c6b03a 	or	r3,r4,r3
   35a34:	10c00245 	stb	r3,9(r2)
   35a38:	e0fffd17 	ldw	r3,-12(fp)
   35a3c:	1806d43a 	srli	r3,r3,16
   35a40:	18c03fcc 	andi	r3,r3,255
   35a44:	11000283 	ldbu	r4,10(r2)
   35a48:	2008703a 	and	r4,r4,zero
   35a4c:	20c6b03a 	or	r3,r4,r3
   35a50:	10c00285 	stb	r3,10(r2)
   35a54:	e0fffd17 	ldw	r3,-12(fp)
   35a58:	1806d63a 	srli	r3,r3,24
   35a5c:	110002c3 	ldbu	r4,11(r2)
   35a60:	2008703a 	and	r4,r4,zero
   35a64:	20c6b03a 	or	r3,r4,r3
   35a68:	10c002c5 	stb	r3,11(r2)
  desc->next                     = (alt_u32 *) next;
   35a6c:	e0bffa17 	ldw	r2,-24(fp)
   35a70:	e0fffb17 	ldw	r3,-20(fp)
   35a74:	18c03fcc 	andi	r3,r3,255
   35a78:	11000403 	ldbu	r4,16(r2)
   35a7c:	2008703a 	and	r4,r4,zero
   35a80:	20c6b03a 	or	r3,r4,r3
   35a84:	10c00405 	stb	r3,16(r2)
   35a88:	e0fffb17 	ldw	r3,-20(fp)
   35a8c:	1806d23a 	srli	r3,r3,8
   35a90:	18c03fcc 	andi	r3,r3,255
   35a94:	11000443 	ldbu	r4,17(r2)
   35a98:	2008703a 	and	r4,r4,zero
   35a9c:	20c6b03a 	or	r3,r4,r3
   35aa0:	10c00445 	stb	r3,17(r2)
   35aa4:	e0fffb17 	ldw	r3,-20(fp)
   35aa8:	1806d43a 	srli	r3,r3,16
   35aac:	18c03fcc 	andi	r3,r3,255
   35ab0:	11000483 	ldbu	r4,18(r2)
   35ab4:	2008703a 	and	r4,r4,zero
   35ab8:	20c6b03a 	or	r3,r4,r3
   35abc:	10c00485 	stb	r3,18(r2)
   35ac0:	e0fffb17 	ldw	r3,-20(fp)
   35ac4:	1806d63a 	srli	r3,r3,24
   35ac8:	110004c3 	ldbu	r4,19(r2)
   35acc:	2008703a 	and	r4,r4,zero
   35ad0:	20c6b03a 	or	r3,r4,r3
   35ad4:	10c004c5 	stb	r3,19(r2)
  desc->read_addr_pad            = 0x0;
   35ad8:	e0bffa17 	ldw	r2,-24(fp)
   35adc:	10c00103 	ldbu	r3,4(r2)
   35ae0:	1806703a 	and	r3,r3,zero
   35ae4:	10c00105 	stb	r3,4(r2)
   35ae8:	10c00143 	ldbu	r3,5(r2)
   35aec:	1806703a 	and	r3,r3,zero
   35af0:	10c00145 	stb	r3,5(r2)
   35af4:	10c00183 	ldbu	r3,6(r2)
   35af8:	1806703a 	and	r3,r3,zero
   35afc:	10c00185 	stb	r3,6(r2)
   35b00:	10c001c3 	ldbu	r3,7(r2)
   35b04:	1806703a 	and	r3,r3,zero
   35b08:	10c001c5 	stb	r3,7(r2)
  desc->write_addr_pad           = 0x0;
   35b0c:	e0bffa17 	ldw	r2,-24(fp)
   35b10:	10c00303 	ldbu	r3,12(r2)
   35b14:	1806703a 	and	r3,r3,zero
   35b18:	10c00305 	stb	r3,12(r2)
   35b1c:	10c00343 	ldbu	r3,13(r2)
   35b20:	1806703a 	and	r3,r3,zero
   35b24:	10c00345 	stb	r3,13(r2)
   35b28:	10c00383 	ldbu	r3,14(r2)
   35b2c:	1806703a 	and	r3,r3,zero
   35b30:	10c00385 	stb	r3,14(r2)
   35b34:	10c003c3 	ldbu	r3,15(r2)
   35b38:	1806703a 	and	r3,r3,zero
   35b3c:	10c003c5 	stb	r3,15(r2)
  desc->next_pad                 = 0x0;
   35b40:	e0bffa17 	ldw	r2,-24(fp)
   35b44:	10c00503 	ldbu	r3,20(r2)
   35b48:	1806703a 	and	r3,r3,zero
   35b4c:	10c00505 	stb	r3,20(r2)
   35b50:	10c00543 	ldbu	r3,21(r2)
   35b54:	1806703a 	and	r3,r3,zero
   35b58:	10c00545 	stb	r3,21(r2)
   35b5c:	10c00583 	ldbu	r3,22(r2)
   35b60:	1806703a 	and	r3,r3,zero
   35b64:	10c00585 	stb	r3,22(r2)
   35b68:	10c005c3 	ldbu	r3,23(r2)
   35b6c:	1806703a 	and	r3,r3,zero
   35b70:	10c005c5 	stb	r3,23(r2)
  desc->bytes_to_transfer        = length_or_eop;
   35b74:	e0bffa17 	ldw	r2,-24(fp)
   35b78:	e0fffe0b 	ldhu	r3,-8(fp)
   35b7c:	18c03fcc 	andi	r3,r3,255
   35b80:	11000603 	ldbu	r4,24(r2)
   35b84:	2008703a 	and	r4,r4,zero
   35b88:	20c6b03a 	or	r3,r4,r3
   35b8c:	10c00605 	stb	r3,24(r2)
   35b90:	e0fffe0b 	ldhu	r3,-8(fp)
   35b94:	1806d23a 	srli	r3,r3,8
   35b98:	18ffffcc 	andi	r3,r3,65535
   35b9c:	11000643 	ldbu	r4,25(r2)
   35ba0:	2008703a 	and	r4,r4,zero
   35ba4:	20c6b03a 	or	r3,r4,r3
   35ba8:	10c00645 	stb	r3,25(r2)
  desc->actual_bytes_transferred = 0;
   35bac:	e0bffa17 	ldw	r2,-24(fp)
   35bb0:	10c00703 	ldbu	r3,28(r2)
   35bb4:	1806703a 	and	r3,r3,zero
   35bb8:	10c00705 	stb	r3,28(r2)
   35bbc:	10c00743 	ldbu	r3,29(r2)
   35bc0:	1806703a 	and	r3,r3,zero
   35bc4:	10c00745 	stb	r3,29(r2)
  desc->status                   = 0x0;
   35bc8:	e0bffa17 	ldw	r2,-24(fp)
   35bcc:	10000785 	stb	zero,30(r2)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
   35bd0:	e0800617 	ldw	r2,24(fp)
   35bd4:	1007883a 	mov	r3,r2
   35bd8:	e0bffa17 	ldw	r2,-24(fp)
   35bdc:	10c00685 	stb	r3,26(r2)
  desc->write_burst              = write_burst;
   35be0:	e0800717 	ldw	r2,28(fp)
   35be4:	1007883a 	mov	r3,r2
   35be8:	e0bffa17 	ldw	r2,-24(fp)
   35bec:	10c006c5 	stb	r3,27(r2)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
   35bf0:	e0800317 	ldw	r2,12(fp)
   35bf4:	10000226 	beq	r2,zero,35c00 <alt_avalon_sgdma_construct_descriptor_burst+0x2bc>
   35bf8:	00ffe044 	movi	r3,-127
   35bfc:	00000106 	br	35c04 <alt_avalon_sgdma_construct_descriptor_burst+0x2c0>
   35c00:	00ffe004 	movi	r3,-128
   35c04:	e0800417 	ldw	r2,16(fp)
   35c08:	10000226 	beq	r2,zero,35c14 <alt_avalon_sgdma_construct_descriptor_burst+0x2d0>
   35c0c:	00800084 	movi	r2,2
   35c10:	00000106 	br	35c18 <alt_avalon_sgdma_construct_descriptor_burst+0x2d4>
   35c14:	0005883a 	mov	r2,zero
   35c18:	1884b03a 	or	r2,r3,r2
   35c1c:	1007883a 	mov	r3,r2
   35c20:	e0800517 	ldw	r2,20(fp)
   35c24:	10000226 	beq	r2,zero,35c30 <alt_avalon_sgdma_construct_descriptor_burst+0x2ec>
   35c28:	00800104 	movi	r2,4
   35c2c:	00000106 	br	35c34 <alt_avalon_sgdma_construct_descriptor_burst+0x2f0>
   35c30:	0005883a 	mov	r2,zero
   35c34:	1884b03a 	or	r2,r3,r2
   35c38:	1007883a 	mov	r3,r2
   35c3c:	e0bfff03 	ldbu	r2,-4(fp)
   35c40:	10000426 	beq	r2,zero,35c54 <alt_avalon_sgdma_construct_descriptor_burst+0x310>
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_GENERATE_EOP_MSK : 0x0)        |
    (read_fixed ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_READ_FIXED_ADDRESS_MSK : 0x0)  |
    (write_fixed_or_sop ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_WRITE_FIXED_ADDRESS_MSK : 0x0) |
    (atlantic_channel ? ( (atlantic_channel & 0x0F) << 3) : 0)
   35c44:	e0bfff03 	ldbu	r2,-4(fp)
   35c48:	108003cc 	andi	r2,r2,15
   35c4c:	100490fa 	slli	r2,r2,3
   35c50:	00000106 	br	35c58 <alt_avalon_sgdma_construct_descriptor_burst+0x314>
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
   35c54:	0005883a 	mov	r2,zero
   35c58:	1884b03a 	or	r2,r3,r2
   35c5c:	1007883a 	mov	r3,r2
   35c60:	e0bffa17 	ldw	r2,-24(fp)
   35c64:	10c007c5 	stb	r3,31(r2)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to
   */
  alt_remap_uncached(desc, sizeof(alt_sgdma_descriptor));
   35c68:	e13ffa17 	ldw	r4,-24(fp)
   35c6c:	01400804 	movi	r5,32
   35c70:	003d0200 	call	3d020 <alt_remap_uncached>
}
   35c74:	e037883a 	mov	sp,fp
   35c78:	dfc00117 	ldw	ra,4(sp)
   35c7c:	df000017 	ldw	fp,0(sp)
   35c80:	dec00204 	addi	sp,sp,8
   35c84:	f800283a 	ret

00035c88 <alt_avalon_sgdma_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_sgdma_irq(void *context)
#else
static void alt_avalon_sgdma_irq(void *context, alt_u32 id)
#endif
{
   35c88:	defff804 	addi	sp,sp,-32
   35c8c:	dfc00715 	stw	ra,28(sp)
   35c90:	df000615 	stw	fp,24(sp)
   35c94:	df000604 	addi	fp,sp,24
   35c98:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev *dev = (alt_sgdma_dev *) context;
   35c9c:	e0bfff17 	ldw	r2,-4(fp)
   35ca0:	e0bffa15 	stw	r2,-24(fp)
   * Note: This is explicitly done before calling user interrupt-handling
   * code rather than after; if user ISR code initiates another SGDMA
   * transfer which completes quickly, reading the control register after
   * the callback routine may result in a lost interrupt.
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
   35ca4:	e0bffa17 	ldw	r2,-24(fp)
   35ca8:	10800317 	ldw	r2,12(r2)
   35cac:	10800404 	addi	r2,r2,16
   35cb0:	e0fffa17 	ldw	r3,-24(fp)
   35cb4:	18c00317 	ldw	r3,12(r3)
   35cb8:	18c00404 	addi	r3,r3,16
   35cbc:	18c00037 	ldwio	r3,0(r3)
   35cc0:	18e00034 	orhi	r3,r3,32768
   35cc4:	10c00035 	stwio	r3,0(r2)
    IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) | 0x80000000);
  
  /* Dummy read to ensure IRQ is negated before the ISR returns */
  IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
   35cc8:	e0bffa17 	ldw	r2,-24(fp)
   35ccc:	10800317 	ldw	r2,12(r2)
   35cd0:	10800404 	addi	r2,r2,16
   35cd4:	10800037 	ldwio	r2,0(r2)
   * Other interrupts are explicitly disabled if callbacks
   * are registered because there is no guarantee that they are 
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
   35cd8:	e0bffa17 	ldw	r2,-24(fp)
   35cdc:	10800917 	ldw	r2,36(r2)
   35ce0:	10001d26 	beq	r2,zero,35d58 <alt_avalon_sgdma_irq+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   35ce4:	0005303a 	rdctl	r2,status
   35ce8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   35cec:	e0fffc17 	ldw	r3,-16(fp)
   35cf0:	00bfff84 	movi	r2,-2
   35cf4:	1884703a 	and	r2,r3,r2
   35cf8:	1001703a 	wrctl	status,r2
  
  return context;
   35cfc:	e0bffc17 	ldw	r2,-16(fp)
    cpu_sr = alt_irq_disable_all();
   35d00:	e0bffb15 	stw	r2,-20(fp)
    (dev->callback)(dev->callback_context);
   35d04:	e0bffa17 	ldw	r2,-24(fp)
   35d08:	10c00917 	ldw	r3,36(r2)
   35d0c:	e0bffa17 	ldw	r2,-24(fp)
   35d10:	10800a17 	ldw	r2,40(r2)
   35d14:	1009883a 	mov	r4,r2
   35d18:	183ee83a 	callr	r3
   35d1c:	e0bffb17 	ldw	r2,-20(fp)
   35d20:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   35d24:	0005303a 	rdctl	r2,status
   35d28:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   35d2c:	e0fffe17 	ldw	r3,-8(fp)
   35d30:	00bfff84 	movi	r2,-2
   35d34:	1884703a 	and	r2,r3,r2
   35d38:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   35d3c:	e0bffd17 	ldw	r2,-12(fp)
   35d40:	1080004c 	andi	r2,r2,1
   35d44:	e0fffe17 	ldw	r3,-8(fp)
   35d48:	1884b03a 	or	r2,r3,r2
   35d4c:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
   35d50:	e0bffe17 	ldw	r2,-8(fp)
   35d54:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(cpu_sr);
  }
}
   35d58:	e037883a 	mov	sp,fp
   35d5c:	dfc00117 	ldw	ra,4(sp)
   35d60:	df000017 	ldw	fp,0(sp)
   35d64:	dec00204 	addi	sp,sp,8
   35d68:	f800283a 	ret

00035d6c <alt_avalon_sgdma_init>:
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
   35d6c:	defffa04 	addi	sp,sp,-24
   35d70:	dfc00515 	stw	ra,20(sp)
   35d74:	df000415 	stw	fp,16(sp)
   35d78:	df000404 	addi	fp,sp,16
   35d7c:	e13ffd15 	stw	r4,-12(fp)
   35d80:	e17ffe15 	stw	r5,-8(fp)
   35d84:	e1bfff15 	stw	r6,-4(fp)

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
   35d88:	e0bffd17 	ldw	r2,-12(fp)
   35d8c:	10800317 	ldw	r2,12(r2)
   35d90:	10800404 	addi	r2,r2,16
   35d94:	00c00074 	movhi	r3,1
   35d98:	10c00035 	stwio	r3,0(r2)
    ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
   35d9c:	e0bffd17 	ldw	r2,-12(fp)
   35da0:	10800317 	ldw	r2,12(r2)
   35da4:	10800404 	addi	r2,r2,16
   35da8:	00c00074 	movhi	r3,1
   35dac:	10c00035 	stwio	r3,0(r2)

  /*
   * Disable interrupts, halt future descriptor processing,
   * and clear status register content
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 0x0);
   35db0:	e0bffd17 	ldw	r2,-12(fp)
   35db4:	10800317 	ldw	r2,12(r2)
   35db8:	10800404 	addi	r2,r2,16
   35dbc:	0007883a 	mov	r3,zero
   35dc0:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
   35dc4:	e0bffd17 	ldw	r2,-12(fp)
   35dc8:	10800317 	ldw	r2,12(r2)
   35dcc:	00c03fc4 	movi	r3,255
   35dd0:	10c00035 	stwio	r3,0(r2)

  /* Register this instance of the SGDMA controller with HAL */
  alt_dev_llist_insert((alt_dev_llist*) dev, &alt_sgdma_list);
   35dd4:	e13ffd17 	ldw	r4,-12(fp)
   35dd8:	d1601a04 	addi	r5,gp,-32664
   35ddc:	003c80c0 	call	3c80c <alt_dev_llist_insert>

  /* Install IRQ handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(ic_id, irq, alt_avalon_sgdma_irq, dev, 0x0);
   35de0:	d8000015 	stw	zero,0(sp)
   35de4:	e13ffe17 	ldw	r4,-8(fp)
   35de8:	e17fff17 	ldw	r5,-4(fp)
   35dec:	018000f4 	movhi	r6,3
   35df0:	31972204 	addi	r6,r6,23688
   35df4:	e1fffd17 	ldw	r7,-12(fp)
   35df8:	003bd080 	call	3bd08 <alt_ic_isr_register>
#else
  alt_irq_register(irq, dev, alt_avalon_sgdma_irq);
#endif  
}
   35dfc:	e037883a 	mov	sp,fp
   35e00:	dfc00117 	ldw	ra,4(sp)
   35e04:	df000017 	ldw	fp,0(sp)
   35e08:	dec00204 	addi	sp,sp,8
   35e0c:	f800283a 	ret

00035e10 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
   35e10:	defff904 	addi	sp,sp,-28
   35e14:	dfc00615 	stw	ra,24(sp)
   35e18:	df000515 	stw	fp,20(sp)
   35e1c:	df000504 	addi	fp,sp,20
   35e20:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
   35e24:	0007883a 	mov	r3,zero
   35e28:	e0bfff17 	ldw	r2,-4(fp)
   35e2c:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
   35e30:	e0bfff17 	ldw	r2,-4(fp)
   35e34:	10800104 	addi	r2,r2,4
   35e38:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   35e3c:	0005303a 	rdctl	r2,status
   35e40:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   35e44:	e0fffc17 	ldw	r3,-16(fp)
   35e48:	00bfff84 	movi	r2,-2
   35e4c:	1884703a 	and	r2,r3,r2
   35e50:	1001703a 	wrctl	status,r2
  
  return context;
   35e54:	e0bffc17 	ldw	r2,-16(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
   35e58:	e0bffb15 	stw	r2,-20(fp)
  alt_tick ();
   35e5c:	003d1240 	call	3d124 <alt_tick>
   35e60:	e0bffb17 	ldw	r2,-20(fp)
   35e64:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   35e68:	0005303a 	rdctl	r2,status
   35e6c:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   35e70:	e0fffe17 	ldw	r3,-8(fp)
   35e74:	00bfff84 	movi	r2,-2
   35e78:	1884703a 	and	r2,r3,r2
   35e7c:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   35e80:	e0bffd17 	ldw	r2,-12(fp)
   35e84:	1080004c 	andi	r2,r2,1
   35e88:	e0fffe17 	ldw	r3,-8(fp)
   35e8c:	1884b03a 	or	r2,r3,r2
   35e90:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
   35e94:	e0bffe17 	ldw	r2,-8(fp)
   35e98:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
   35e9c:	e037883a 	mov	sp,fp
   35ea0:	dfc00117 	ldw	ra,4(sp)
   35ea4:	df000017 	ldw	fp,0(sp)
   35ea8:	dec00204 	addi	sp,sp,8
   35eac:	f800283a 	ret

00035eb0 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
   35eb0:	defff804 	addi	sp,sp,-32
   35eb4:	dfc00715 	stw	ra,28(sp)
   35eb8:	df000615 	stw	fp,24(sp)
   35ebc:	df000604 	addi	fp,sp,24
   35ec0:	e13ffc15 	stw	r4,-16(fp)
   35ec4:	e17ffd15 	stw	r5,-12(fp)
   35ec8:	e1bffe15 	stw	r6,-8(fp)
   35ecc:	e1ffff15 	stw	r7,-4(fp)
   35ed0:	e0bfff17 	ldw	r2,-4(fp)
   35ed4:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
   35ed8:	00800134 	movhi	r2,4
   35edc:	109f0c04 	addi	r2,r2,31792
   35ee0:	10800017 	ldw	r2,0(r2)
   35ee4:	1000041e 	bne	r2,zero,35ef8 <alt_avalon_timer_sc_init+0x48>
  {
    _alt_tick_rate = nticks;
   35ee8:	00800134 	movhi	r2,4
   35eec:	109f0c04 	addi	r2,r2,31792
   35ef0:	e0fffb17 	ldw	r3,-20(fp)
   35ef4:	10c00015 	stw	r3,0(r2)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
   35ef8:	e0bffc17 	ldw	r2,-16(fp)
   35efc:	10800104 	addi	r2,r2,4
   35f00:	00c001c4 	movi	r3,7
   35f04:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
   35f08:	d8000015 	stw	zero,0(sp)
   35f0c:	e13ffd17 	ldw	r4,-12(fp)
   35f10:	e17ffe17 	ldw	r5,-8(fp)
   35f14:	018000f4 	movhi	r6,3
   35f18:	31978404 	addi	r6,r6,24080
   35f1c:	e1fffc17 	ldw	r7,-16(fp)
   35f20:	003bd080 	call	3bd08 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
   35f24:	e037883a 	mov	sp,fp
   35f28:	dfc00117 	ldw	ra,4(sp)
   35f2c:	df000017 	ldw	fp,0(sp)
   35f30:	dec00204 	addi	sp,sp,8
   35f34:	f800283a 	ret

00035f38 <no_printf>:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void no_printf (char *fmt, ...) {}
   35f38:	defffb04 	addi	sp,sp,-20
   35f3c:	df000115 	stw	fp,4(sp)
   35f40:	df000104 	addi	fp,sp,4
   35f44:	e1400115 	stw	r5,4(fp)
   35f48:	e1800215 	stw	r6,8(fp)
   35f4c:	e1c00315 	stw	r7,12(fp)
   35f50:	e13fff15 	stw	r4,-4(fp)
   35f54:	e037883a 	mov	sp,fp
   35f58:	df000017 	ldw	fp,0(sp)
   35f5c:	dec00404 	addi	sp,sp,16
   35f60:	f800283a 	ret

00035f64 <tse_mac_initTransInfo2>:

alt_32 tse_mac_initTransInfo2( tse_mac_trans_info *mi,
                                        alt_u32 mac_base,
                                        alt_32 tx_sgdma,
                                        alt_32 rx_sgdma,
                                        alt_32 cfgflags) {
   35f64:	defffb04 	addi	sp,sp,-20
   35f68:	df000415 	stw	fp,16(sp)
   35f6c:	df000404 	addi	fp,sp,16
   35f70:	e13ffc15 	stw	r4,-16(fp)
   35f74:	e17ffd15 	stw	r5,-12(fp)
   35f78:	e1bffe15 	stw	r6,-8(fp)
   35f7c:	e1ffff15 	stw	r7,-4(fp)
                                              
        mi->base     = (np_tse_mac*)mac_base;
   35f80:	e0fffd17 	ldw	r3,-12(fp)
   35f84:	e0bffc17 	ldw	r2,-16(fp)
   35f88:	10c00015 	stw	r3,0(r2)
        mi->tx_sgdma = (alt_sgdma_dev *)tx_sgdma;
   35f8c:	e0fffe17 	ldw	r3,-8(fp)
   35f90:	e0bffc17 	ldw	r2,-16(fp)
   35f94:	10c00115 	stw	r3,4(r2)
        mi->rx_sgdma = (alt_sgdma_dev *)rx_sgdma;
   35f98:	e0ffff17 	ldw	r3,-4(fp)
   35f9c:	e0bffc17 	ldw	r2,-16(fp)
   35fa0:	10c00215 	stw	r3,8(r2)
        mi->cfgflags = cfgflags;     
   35fa4:	e0c00117 	ldw	r3,4(fp)
   35fa8:	e0bffc17 	ldw	r2,-16(fp)
   35fac:	10c00415 	stw	r3,16(r2)
        return SUCCESS;
   35fb0:	0005883a 	mov	r2,zero
}
   35fb4:	e037883a 	mov	sp,fp
   35fb8:	df000017 	ldw	fp,0(sp)
   35fbc:	dec00104 	addi	sp,sp,4
   35fc0:	f800283a 	ret

00035fc4 <tse_mac_sTxWrite>:
  * @param txDesc           Pointer to the transmit SGDMA descriptor
  * @return actual bytes transferred if ok, else error (-1)
  */
alt_32 tse_mac_sTxWrite( tse_mac_trans_info *mi, 
                       alt_sgdma_descriptor *txDesc)   
{ 
   35fc4:	defffa04 	addi	sp,sp,-24
   35fc8:	dfc00515 	stw	ra,20(sp)
   35fcc:	df000415 	stw	fp,16(sp)
   35fd0:	df000404 	addi	fp,sp,16
   35fd4:	e13ffe15 	stw	r4,-8(fp)
   35fd8:	e17fff15 	stw	r5,-4(fp)

  alt_32 timeout;
  alt_u8 result = 0;
   35fdc:	e03ffd05 	stb	zero,-12(fp)
  alt_u16 actualBytesTransferred;
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
   35fe0:	e03ffc15 	stw	zero,-16(fp)
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
   35fe4:	00000e06 	br	36020 <tse_mac_sTxWrite+0x5c>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
           if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
   35fe8:	e0fffc17 	ldw	r3,-16(fp)
   35fec:	008003f4 	movhi	r2,15
   35ff0:	10909004 	addi	r2,r2,16960
   35ff4:	1885003a 	cmpeq	r2,r3,r2
   35ff8:	e0fffc17 	ldw	r3,-16(fp)
   35ffc:	18c00044 	addi	r3,r3,1
   36000:	e0fffc15 	stw	r3,-16(fp)
   36004:	10803fcc 	andi	r2,r2,255
   36008:	10000526 	beq	r2,zero,36020 <tse_mac_sTxWrite+0x5c>
            tse_dprintf(4, "WARNING : TX SGDMA Timeout\n");
   3600c:	01000134 	movhi	r4,4
   36010:	2105a004 	addi	r4,r4,5760
   36014:	00045340 	call	4534 <puts>
            return ENP_RESOURCE;  // avoid being stuck here
   36018:	00bffa84 	movi	r2,-22
   3601c:	00001c06 	br	36090 <tse_mac_sTxWrite+0xcc>
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
   36020:	e0bffe17 	ldw	r2,-8(fp)
   36024:	10800117 	ldw	r2,4(r2)
   36028:	10800317 	ldw	r2,12(r2)
   3602c:	10800037 	ldwio	r2,0(r2)
   36030:	1080040c 	andi	r2,r2,16
   36034:	103fec1e 	bne	r2,zero,35fe8 <tse_mac_sTxWrite+0x24>
           }
  }

  // Set up the SGDMA
  // Clear the status and control bits of the SGDMA descriptor
  IOWR_ALTERA_AVALON_SGDMA_CONTROL (mi->tx_sgdma->base, 0);
   36038:	e0bffe17 	ldw	r2,-8(fp)
   3603c:	10800117 	ldw	r2,4(r2)
   36040:	10800317 	ldw	r2,12(r2)
   36044:	10800404 	addi	r2,r2,16
   36048:	0007883a 	mov	r3,zero
   3604c:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS (mi->tx_sgdma->base, 0xFF);
   36050:	e0bffe17 	ldw	r2,-8(fp)
   36054:	10800117 	ldw	r2,4(r2)
   36058:	10800317 	ldw	r2,12(r2)
   3605c:	00c03fc4 	movi	r3,255
   36060:	10c00035 	stwio	r3,0(r2)
  
  // Start SGDMA (blocking call)
  result = alt_avalon_sgdma_do_sync_transfer(
                mi->tx_sgdma, 
   36064:	e0bffe17 	ldw	r2,-8(fp)
  // Clear the status and control bits of the SGDMA descriptor
  IOWR_ALTERA_AVALON_SGDMA_CONTROL (mi->tx_sgdma->base, 0);
  IOWR_ALTERA_AVALON_SGDMA_STATUS (mi->tx_sgdma->base, 0xFF);
  
  // Start SGDMA (blocking call)
  result = alt_avalon_sgdma_do_sync_transfer(
   36068:	10800117 	ldw	r2,4(r2)
   3606c:	1009883a 	mov	r4,r2
   36070:	e17fff17 	ldw	r5,-4(fp)
   36074:	00352580 	call	35258 <alt_avalon_sgdma_do_sync_transfer>
   36078:	e0bffd05 	stb	r2,-12(fp)
                mi->tx_sgdma, 
                (alt_sgdma_descriptor *) &txDesc[0]);
  
  /* perform cache save read to obtain actual bytes transferred for current sgdma descriptor */
  actualBytesTransferred = IORD_ALTERA_TSE_SGDMA_DESC_ACTUAL_BYTES_TRANSFERRED(&txDesc[0]);
   3607c:	e0bfff17 	ldw	r2,-4(fp)
   36080:	10800704 	addi	r2,r2,28
   36084:	10800037 	ldwio	r2,0(r2)
   36088:	e0bffd8d 	sth	r2,-10(fp)

  return actualBytesTransferred;
   3608c:	e0bffd8b 	ldhu	r2,-10(fp)
}
   36090:	e037883a 	mov	sp,fp
   36094:	dfc00117 	ldw	ra,4(sp)
   36098:	df000017 	ldw	fp,0(sp)
   3609c:	dec00204 	addi	sp,sp,8
   360a0:	f800283a 	ret

000360a4 <tse_mac_aRxRead>:
  *        the actual bytes transferred for current descriptor
  */
alt_32 tse_mac_aRxRead( 
  tse_mac_trans_info *mi,       
  alt_sgdma_descriptor *rxDesc)  
{
   360a4:	defffa04 	addi	sp,sp,-24
   360a8:	dfc00515 	stw	ra,20(sp)
   360ac:	df000415 	stw	fp,16(sp)
   360b0:	df000404 	addi	fp,sp,16
   360b4:	e13ffe15 	stw	r4,-8(fp)
   360b8:	e17fff15 	stw	r5,-4(fp)
  alt_32 timeout;
  
  alt_u8 result = 0;
   360bc:	e03ffd05 	stb	zero,-12(fp)
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
   360c0:	e03ffc15 	stw	zero,-16(fp)
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
   360c4:	00000e06 	br	36100 <tse_mac_aRxRead+0x5c>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
   360c8:	e0fffc17 	ldw	r3,-16(fp)
   360cc:	008003f4 	movhi	r2,15
   360d0:	10909004 	addi	r2,r2,16960
   360d4:	1885003a 	cmpeq	r2,r3,r2
   360d8:	e0fffc17 	ldw	r3,-16(fp)
   360dc:	18c00044 	addi	r3,r3,1
   360e0:	e0fffc15 	stw	r3,-16(fp)
   360e4:	10803fcc 	andi	r2,r2,255
   360e8:	10000526 	beq	r2,zero,36100 <tse_mac_aRxRead+0x5c>
        tse_dprintf(4, "WARNING : RX SGDMA Timeout\n");
   360ec:	01000134 	movhi	r4,4
   360f0:	2105a704 	addi	r4,r4,5788
   360f4:	00045340 	call	4534 <puts>
        return ENP_RESOURCE;  // avoid being stuck here
   360f8:	00bffa84 	movi	r2,-22
   360fc:	00000d06 	br	36134 <tse_mac_aRxRead+0x90>
  alt_u8 result = 0;
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
   36100:	e0bffe17 	ldw	r2,-8(fp)
   36104:	10800217 	ldw	r2,8(r2)
   36108:	10800317 	ldw	r2,12(r2)
   3610c:	10800037 	ldwio	r2,0(r2)
   36110:	1080040c 	andi	r2,r2,16
   36114:	103fec1e 	bne	r2,zero,360c8 <tse_mac_aRxRead+0x24>
  }

 
  // SGDMA operation invoked for RX (non-blocking call)
  result = alt_avalon_sgdma_do_async_transfer(
                mi->rx_sgdma, 
   36118:	e0bffe17 	ldw	r2,-8(fp)
    }
  }

 
  // SGDMA operation invoked for RX (non-blocking call)
  result = alt_avalon_sgdma_do_async_transfer(
   3611c:	10800217 	ldw	r2,8(r2)
   36120:	1009883a 	mov	r4,r2
   36124:	e17fff17 	ldw	r5,-4(fp)
   36128:	00351340 	call	35134 <alt_avalon_sgdma_do_async_transfer>
   3612c:	e0bffd05 	stb	r2,-12(fp)
                mi->rx_sgdma, 
                (alt_sgdma_descriptor *) &rxDesc[0]);

 
  return SUCCESS;
   36130:	0005883a 	mov	r2,zero
}
   36134:	e037883a 	mov	sp,fp
   36138:	dfc00117 	ldw	ra,4(sp)
   3613c:	df000017 	ldw	fp,0(sp)
   36140:	dec00204 	addi	sp,sp,8
   36144:	f800283a 	ret

00036148 <tse_mac_SwReset>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_SwReset(np_tse_mac *pmac) 
{
   36148:	defffc04 	addi	sp,sp,-16
   3614c:	df000315 	stw	fp,12(sp)
   36150:	df000304 	addi	fp,sp,12
   36154:	e13fff15 	stw	r4,-4(fp)
	alt_32 timeout;
	alt_32 cc;
        
    cc = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
   36158:	e0bfff17 	ldw	r2,-4(fp)
   3615c:	10800204 	addi	r2,r2,8
   36160:	10800037 	ldwio	r2,0(r2)
   36164:	e0bffe15 	stw	r2,-8(fp)
    
    // set reset and Gig-Speed bits to make sure we have an incoming clock on
    // tx side. If there is a 10/100 PHY, we will still have a valid clock on
    // tx_clk no matter what setting we have here, but on a Gig phy the
    // MII clock may be missing.
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,(ALTERA_TSEMAC_CMD_SW_RESET_MSK | ALTERA_TSEMAC_CMD_ETH_SPEED_MSK));
   36168:	e0bfff17 	ldw	r2,-4(fp)
   3616c:	10800204 	addi	r2,r2,8
   36170:	00c80204 	movi	r3,8200
   36174:	10c00035 	stwio	r3,0(r2)

    
    // wait for completion with fallback in case there is no PHY or it is
    // not connected and hence might not provide any clocks at all.
    timeout=0;
   36178:	e03ffd15 	stw	zero,-12(fp)
    while( (IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac) & ALTERA_TSEMAC_CMD_SW_RESET_MSK) != 0 && timeout < ALTERA_TSE_SW_RESET_TIME_OUT_CNT) timeout++;
   3617c:	00000306 	br	3618c <tse_mac_SwReset+0x44>
   36180:	e0bffd17 	ldw	r2,-12(fp)
   36184:	10800044 	addi	r2,r2,1
   36188:	e0bffd15 	stw	r2,-12(fp)
   3618c:	e0bfff17 	ldw	r2,-4(fp)
   36190:	10800204 	addi	r2,r2,8
   36194:	10800037 	ldwio	r2,0(r2)
   36198:	1088000c 	andi	r2,r2,8192
   3619c:	10000326 	beq	r2,zero,361ac <tse_mac_SwReset+0x64>
   361a0:	e0bffd17 	ldw	r2,-12(fp)
   361a4:	1089c410 	cmplti	r2,r2,10000
   361a8:	103ff51e 	bne	r2,zero,36180 <tse_mac_SwReset+0x38>
   
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,cc); // Restore
   361ac:	e0bfff17 	ldw	r2,-4(fp)
   361b0:	10800204 	addi	r2,r2,8
   361b4:	e0fffe17 	ldw	r3,-8(fp)
   361b8:	10c00035 	stwio	r3,0(r2)
    return SUCCESS;
   361bc:	0005883a 	mov	r2,zero
}
   361c0:	e037883a 	mov	sp,fp
   361c4:	df000017 	ldw	fp,0(sp)
   361c8:	dec00104 	addi	sp,sp,4
   361cc:	f800283a 	ret

000361d0 <tse_mac_setMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_setMIImode(np_tse_mac *pmac)
{
   361d0:	defffd04 	addi	sp,sp,-12
   361d4:	df000215 	stw	fp,8(sp)
   361d8:	df000204 	addi	fp,sp,8
   361dc:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
   361e0:	e0bfff17 	ldw	r2,-4(fp)
   361e4:	10800204 	addi	r2,r2,8
   361e8:	10800037 	ldwio	r2,0(r2)
   361ec:	e0bffe15 	stw	r2,-8(fp)
  helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK; 
   361f0:	e0fffe17 	ldw	r3,-8(fp)
   361f4:	00bffdc4 	movi	r2,-9
   361f8:	1884703a 	and	r2,r3,r2
   361fc:	e0bffe15 	stw	r2,-8(fp)
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
   36200:	e0bfff17 	ldw	r2,-4(fp)
   36204:	10800204 	addi	r2,r2,8
   36208:	e0fffe17 	ldw	r3,-8(fp)
   3620c:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
   36210:	0005883a 	mov	r2,zero
}
   36214:	e037883a 	mov	sp,fp
   36218:	df000017 	ldw	fp,0(sp)
   3621c:	dec00104 	addi	sp,sp,4
   36220:	f800283a 	ret

00036224 <tse_mac_setGMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
 */
alt_32 tse_mac_setGMIImode(np_tse_mac *pmac)
{
   36224:	defffd04 	addi	sp,sp,-12
   36228:	df000215 	stw	fp,8(sp)
   3622c:	df000204 	addi	fp,sp,8
   36230:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
   36234:	e0bfff17 	ldw	r2,-4(fp)
   36238:	10800204 	addi	r2,r2,8
   3623c:	10800037 	ldwio	r2,0(r2)
   36240:	e0bffe15 	stw	r2,-8(fp)
  helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
   36244:	e0bffe17 	ldw	r2,-8(fp)
   36248:	10800214 	ori	r2,r2,8
   3624c:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
   36250:	e0bfff17 	ldw	r2,-4(fp)
   36254:	10800204 	addi	r2,r2,8
   36258:	e0fffe17 	ldw	r3,-8(fp)
   3625c:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
   36260:	0005883a 	mov	r2,zero
}
   36264:	e037883a 	mov	sp,fp
   36268:	df000017 	ldw	fp,0(sp)
   3626c:	dec00104 	addi	sp,sp,4
   36270:	f800283a 	ret

00036274 <alt_tse_phy_add_profile>:
 * @param  phy  pointer to alt_tse_phy_profile structure describing PHY registers
 * @return      index of PHY added in PHY profile on success, else return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 * PHY which are currently supported by default :  Marvell 88E1111, Marvell Quad PHY 88E1145, National DP83865, and National DP83848C
 */
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
   36274:	defffb04 	addi	sp,sp,-20
   36278:	dfc00415 	stw	ra,16(sp)
   3627c:	df000315 	stw	fp,12(sp)
   36280:	dc000215 	stw	r16,8(sp)
   36284:	df000204 	addi	fp,sp,8
   36288:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
   3628c:	e03ffe15 	stw	zero,-8(fp)
   36290:	00002906 	br	36338 <alt_tse_phy_add_profile+0xc4>
    {
        if(pphy_profiles[i]->oui == phy->oui && pphy_profiles[i]->model_number == phy->model_number)
   36294:	00c001f4 	movhi	r3,7
   36298:	18ed1304 	addi	r3,r3,-19380
   3629c:	e0bffe17 	ldw	r2,-8(fp)
   362a0:	1085883a 	add	r2,r2,r2
   362a4:	1085883a 	add	r2,r2,r2
   362a8:	1885883a 	add	r2,r3,r2
   362ac:	10800017 	ldw	r2,0(r2)
   362b0:	10c01417 	ldw	r3,80(r2)
   362b4:	e0bfff17 	ldw	r2,-4(fp)
   362b8:	10801417 	ldw	r2,80(r2)
   362bc:	18801b1e 	bne	r3,r2,3632c <alt_tse_phy_add_profile+0xb8>
   362c0:	00c001f4 	movhi	r3,7
   362c4:	18ed1304 	addi	r3,r3,-19380
   362c8:	e0bffe17 	ldw	r2,-8(fp)
   362cc:	1085883a 	add	r2,r2,r2
   362d0:	1085883a 	add	r2,r2,r2
   362d4:	1885883a 	add	r2,r3,r2
   362d8:	10800017 	ldw	r2,0(r2)
   362dc:	10c01503 	ldbu	r3,84(r2)
   362e0:	e0bfff17 	ldw	r2,-4(fp)
   362e4:	10801503 	ldbu	r2,84(r2)
   362e8:	18c03fcc 	andi	r3,r3,255
   362ec:	10803fcc 	andi	r2,r2,255
   362f0:	18800e1e 	bne	r3,r2,3632c <alt_tse_phy_add_profile+0xb8>
        {
            tse_dprintf(4, "WARNING : PHY OUI 0x%06x, PHY Model Number 0x%02x already exist in PHY profile\n", (int) phy->oui, phy->model_number);
   362f4:	e0bfff17 	ldw	r2,-4(fp)
   362f8:	10801417 	ldw	r2,80(r2)
   362fc:	1007883a 	mov	r3,r2
   36300:	e0bfff17 	ldw	r2,-4(fp)
   36304:	10801503 	ldbu	r2,84(r2)
   36308:	10803fcc 	andi	r2,r2,255
   3630c:	01000134 	movhi	r4,4
   36310:	2105ae04 	addi	r4,r4,5816
   36314:	180b883a 	mov	r5,r3
   36318:	100d883a 	mov	r6,r2
   3631c:	00044740 	call	4474 <printf>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
   36320:	01000134 	movhi	r4,4
   36324:	2105c204 	addi	r4,r4,5896
   36328:	00045340 	call	4534 <puts>
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
   3632c:	e0bffe17 	ldw	r2,-8(fp)
   36330:	10800044 	addi	r2,r2,1
   36334:	e0bffe15 	stw	r2,-8(fp)
   36338:	d0a94703 	ldbu	r2,-23268(gp)
   3633c:	10803fcc 	andi	r2,r2,255
   36340:	e0fffe17 	ldw	r3,-8(fp)
   36344:	18bfd316 	blt	r3,r2,36294 <alt_tse_phy_add_profile+0x20>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
        }
    }

    /* Allocate memory space to store the profile */    
    pphy_profiles[phy_profile_count] = (alt_tse_phy_profile *) malloc(sizeof(alt_tse_phy_profile));
   36348:	d0a94703 	ldbu	r2,-23268(gp)
   3634c:	14003fcc 	andi	r16,r2,255
   36350:	01001904 	movi	r4,100
   36354:	003f1fc0 	call	3f1fc <malloc>
   36358:	1007883a 	mov	r3,r2
   3635c:	010001f4 	movhi	r4,7
   36360:	212d1304 	addi	r4,r4,-19380
   36364:	8405883a 	add	r2,r16,r16
   36368:	1085883a 	add	r2,r2,r2
   3636c:	2085883a 	add	r2,r4,r2
   36370:	10c00015 	stw	r3,0(r2)
    if(!pphy_profiles[phy_profile_count]) {
   36374:	d0a94703 	ldbu	r2,-23268(gp)
   36378:	10803fcc 	andi	r2,r2,255
   3637c:	00c001f4 	movhi	r3,7
   36380:	18ed1304 	addi	r3,r3,-19380
   36384:	1085883a 	add	r2,r2,r2
   36388:	1085883a 	add	r2,r2,r2
   3638c:	1885883a 	add	r2,r3,r2
   36390:	10800017 	ldw	r2,0(r2)
   36394:	1000081e 	bne	r2,zero,363b8 <alt_tse_phy_add_profile+0x144>
        tse_dprintf(1, "ERROR   : Unable to allocate memory for pphy_profile[%d]\n", phy_profile_count);
   36398:	d0a94703 	ldbu	r2,-23268(gp)
   3639c:	10803fcc 	andi	r2,r2,255
   363a0:	01000134 	movhi	r4,4
   363a4:	2105da04 	addi	r4,r4,5992
   363a8:	100b883a 	mov	r5,r2
   363ac:	00044740 	call	4474 <printf>
        return ALTERA_TSE_MALLOC_FAILED;
   363b0:	00bfffc4 	movi	r2,-1
   363b4:	00002206 	br	36440 <alt_tse_phy_add_profile+0x1cc>
    }

    /* Store PHY information */
    *pphy_profiles[phy_profile_count] = *phy;
   363b8:	d0a94703 	ldbu	r2,-23268(gp)
   363bc:	10803fcc 	andi	r2,r2,255
   363c0:	00c001f4 	movhi	r3,7
   363c4:	18ed1304 	addi	r3,r3,-19380
   363c8:	1085883a 	add	r2,r2,r2
   363cc:	1085883a 	add	r2,r2,r2
   363d0:	1885883a 	add	r2,r3,r2
   363d4:	10c00017 	ldw	r3,0(r2)
   363d8:	e0bfff17 	ldw	r2,-4(fp)
   363dc:	1809883a 	mov	r4,r3
   363e0:	1007883a 	mov	r3,r2
   363e4:	00801904 	movi	r2,100
   363e8:	180b883a 	mov	r5,r3
   363ec:	100d883a 	mov	r6,r2
   363f0:	00041f00 	call	41f0 <memcpy>
    strcpy(pphy_profiles[phy_profile_count]->name, phy->name);
   363f4:	d0a94703 	ldbu	r2,-23268(gp)
   363f8:	10803fcc 	andi	r2,r2,255
   363fc:	00c001f4 	movhi	r3,7
   36400:	18ed1304 	addi	r3,r3,-19380
   36404:	1085883a 	add	r2,r2,r2
   36408:	1085883a 	add	r2,r2,r2
   3640c:	1885883a 	add	r2,r3,r2
   36410:	10800017 	ldw	r2,0(r2)
   36414:	1007883a 	mov	r3,r2
   36418:	e0bfff17 	ldw	r2,-4(fp)
   3641c:	1809883a 	mov	r4,r3
   36420:	100b883a 	mov	r5,r2
   36424:	00046a40 	call	46a4 <strcpy>
    
    phy_profile_count++;
   36428:	d0a94703 	ldbu	r2,-23268(gp)
   3642c:	10800044 	addi	r2,r2,1
   36430:	d0a94705 	stb	r2,-23268(gp)
    
    return phy_profile_count - 1;
   36434:	d0a94703 	ldbu	r2,-23268(gp)
   36438:	10803fcc 	andi	r2,r2,255
   3643c:	10bfffc4 	addi	r2,r2,-1
}
   36440:	e037883a 	mov	sp,fp
   36444:	dfc00217 	ldw	ra,8(sp)
   36448:	df000117 	ldw	fp,4(sp)
   3644c:	dc000017 	ldw	r16,0(sp)
   36450:	dec00304 	addi	sp,sp,12
   36454:	f800283a 	ret

00036458 <alt_tse_system_add_sys>:
alt_32 alt_tse_system_add_sys(
	alt_tse_system_mac					*psys_mac,
	alt_tse_system_sgdma				*psys_sgdma,
	alt_tse_system_desc_mem				*psys_mem,
	alt_tse_system_shared_fifo			*psys_shared_fifo,
	alt_tse_system_phy 					*psys_phy ) {
   36458:	defff204 	addi	sp,sp,-56
   3645c:	dfc00d15 	stw	ra,52(sp)
   36460:	df000c15 	stw	fp,48(sp)
   36464:	dc000b15 	stw	r16,44(sp)
   36468:	df000b04 	addi	fp,sp,44
   3646c:	e13ffc15 	stw	r4,-16(fp)
   36470:	e17ffd15 	stw	r5,-12(fp)
   36474:	e1bffe15 	stw	r6,-8(fp)
   36478:	e1ffff15 	stw	r7,-4(fp)

	int i;
	int loop_end;
	
	alt_tse_system_mac					*pmac	= psys_mac;
   3647c:	e0bffc17 	ldw	r2,-16(fp)
   36480:	e0bffb15 	stw	r2,-20(fp)
	alt_tse_system_sgdma				*psgdma	= psys_sgdma;
   36484:	e0bffd17 	ldw	r2,-12(fp)
   36488:	e0bff715 	stw	r2,-36(fp)
	alt_tse_system_desc_mem				*pmem	= psys_mem;
   3648c:	e0bffe17 	ldw	r2,-8(fp)
   36490:	e0bff815 	stw	r2,-32(fp)
	alt_tse_system_shared_fifo			*pfifo	= psys_shared_fifo;
   36494:	e0bfff17 	ldw	r2,-4(fp)
   36498:	e0bff915 	stw	r2,-28(fp)
	alt_tse_system_phy 					*pphy	= psys_phy;
   3649c:	e0800317 	ldw	r2,12(fp)
   364a0:	e0bffa15 	stw	r2,-24(fp)
	
	static alt_8 tse_system_count = 0;
	
	/* Determine number of loop */
	/* Run at least one for non-multi-channel MAC */
	if(pmac->tse_num_of_channel == 0) {
   364a4:	e0bffb17 	ldw	r2,-20(fp)
   364a8:	10800303 	ldbu	r2,12(r2)
   364ac:	10803fcc 	andi	r2,r2,255
   364b0:	1000031e 	bne	r2,zero,364c0 <alt_tse_system_add_sys+0x68>
		loop_end = 1;
   364b4:	00800044 	movi	r2,1
   364b8:	e0bff615 	stw	r2,-40(fp)
   364bc:	00000e06 	br	364f8 <alt_tse_system_add_sys+0xa0>
	}
	else if(pmac->tse_num_of_channel > 0) {
   364c0:	e0bffb17 	ldw	r2,-20(fp)
   364c4:	10800303 	ldbu	r2,12(r2)
   364c8:	10803fcc 	andi	r2,r2,255
   364cc:	10000526 	beq	r2,zero,364e4 <alt_tse_system_add_sys+0x8c>
		loop_end = pmac->tse_num_of_channel; 
   364d0:	e0bffb17 	ldw	r2,-20(fp)
   364d4:	10800303 	ldbu	r2,12(r2)
   364d8:	10803fcc 	andi	r2,r2,255
   364dc:	e0bff615 	stw	r2,-40(fp)
   364e0:	00000506 	br	364f8 <alt_tse_system_add_sys+0xa0>
	}
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
   364e4:	01000134 	movhi	r4,4
   364e8:	2105e904 	addi	r4,r4,6052
   364ec:	00045340 	call	4534 <puts>
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
   364f0:	00bfffc4 	movi	r2,-1
   364f4:	00025106 	br	36e3c <alt_tse_system_add_sys+0x9e4>
	}

	for(i = 0; i < loop_end; i++) {
   364f8:	e03ff515 	stw	zero,-44(fp)
   364fc:	00024b06 	br	36e2c <alt_tse_system_add_sys+0x9d4>
		
		/* Make sure the boundary of array is not exceeded */
		if(tse_system_count >= MAXNETS) {
   36500:	d0a947c3 	ldbu	r2,-23265(gp)
   36504:	10803fcc 	andi	r2,r2,255
   36508:	1080201c 	xori	r2,r2,128
   3650c:	10bfe004 	addi	r2,r2,-128
   36510:	10800210 	cmplti	r2,r2,8
   36514:	10000c1e 	bne	r2,zero,36548 <alt_tse_system_add_sys+0xf0>
			tse_dprintf(2, "ERROR   : Number of TSE System added exceed the size of array!\n");
   36518:	01000134 	movhi	r4,4
   3651c:	2105f504 	addi	r4,r4,6100
   36520:	00045340 	call	4534 <puts>
			tse_dprintf(2, "ERROR   : Size of array = %d, Number of TSE System = %d\n", MAXNETS, tse_system_count);
   36524:	d0a947c3 	ldbu	r2,-23265(gp)
   36528:	10803fcc 	andi	r2,r2,255
   3652c:	1080201c 	xori	r2,r2,128
   36530:	10bfe004 	addi	r2,r2,-128
   36534:	01000134 	movhi	r4,4
   36538:	21060504 	addi	r4,r4,6164
   3653c:	01400204 	movi	r5,8
   36540:	100d883a 	mov	r6,r2
   36544:	00044740 	call	4474 <printf>
		}

		/* Add MAC info to alt_tse_system_info structure */
		if(pmac == 0) {
   36548:	e0bffb17 	ldw	r2,-20(fp)
   3654c:	1000081e 	bne	r2,zero,36570 <alt_tse_system_add_sys+0x118>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
   36550:	01000134 	movhi	r4,4
   36554:	21061404 	addi	r4,r4,6224
   36558:	00045340 	call	4534 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys()\n");
   3655c:	01000134 	movhi	r4,4
   36560:	21061e04 	addi	r4,r4,6264
   36564:	00045340 	call	4534 <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
   36568:	00bfffc4 	movi	r2,-1
   3656c:	00023306 	br	36e3c <alt_tse_system_add_sys+0x9e4>
		}		
		
		tse_mac_device[tse_system_count].tse_mac_base 					= pmac->tse_mac_base + (i * 0x400);
   36570:	d0a947c3 	ldbu	r2,-23265(gp)
   36574:	10803fcc 	andi	r2,r2,255
   36578:	1080201c 	xori	r2,r2,128
   3657c:	10bfe004 	addi	r2,r2,-128
   36580:	e0fffb17 	ldw	r3,-20(fp)
   36584:	19000017 	ldw	r4,0(r3)
   36588:	e0fff517 	ldw	r3,-44(fp)
   3658c:	180692ba 	slli	r3,r3,10
   36590:	20c7883a 	add	r3,r4,r3
   36594:	01000134 	movhi	r4,4
   36598:	21152c04 	addi	r4,r4,21680
   3659c:	10801224 	muli	r2,r2,72
   365a0:	2085883a 	add	r2,r4,r2
   365a4:	10c00015 	stw	r3,0(r2)
		tse_mac_device[tse_system_count].tse_tx_depth 					= pmac->tse_tx_depth;
   365a8:	d0a947c3 	ldbu	r2,-23265(gp)
   365ac:	10803fcc 	andi	r2,r2,255
   365b0:	1080201c 	xori	r2,r2,128
   365b4:	10bfe004 	addi	r2,r2,-128
   365b8:	e0fffb17 	ldw	r3,-20(fp)
   365bc:	18c0010b 	ldhu	r3,4(r3)
   365c0:	01000134 	movhi	r4,4
   365c4:	21152c04 	addi	r4,r4,21680
   365c8:	10801224 	muli	r2,r2,72
   365cc:	2085883a 	add	r2,r4,r2
   365d0:	10800104 	addi	r2,r2,4
   365d4:	10c0000d 	sth	r3,0(r2)
		tse_mac_device[tse_system_count].tse_rx_depth 					= pmac->tse_rx_depth;
   365d8:	d0a947c3 	ldbu	r2,-23265(gp)
   365dc:	10803fcc 	andi	r2,r2,255
   365e0:	1080201c 	xori	r2,r2,128
   365e4:	10bfe004 	addi	r2,r2,-128
   365e8:	e0fffb17 	ldw	r3,-20(fp)
   365ec:	18c0018b 	ldhu	r3,6(r3)
   365f0:	01000134 	movhi	r4,4
   365f4:	21152c04 	addi	r4,r4,21680
   365f8:	10801224 	muli	r2,r2,72
   365fc:	2085883a 	add	r2,r4,r2
   36600:	10800104 	addi	r2,r2,4
   36604:	10c0008d 	sth	r3,2(r2)
		tse_mac_device[tse_system_count].tse_use_mdio 					= pmac->tse_use_mdio;
   36608:	d0a947c3 	ldbu	r2,-23265(gp)
   3660c:	10803fcc 	andi	r2,r2,255
   36610:	1080201c 	xori	r2,r2,128
   36614:	10bfe004 	addi	r2,r2,-128
   36618:	e0fffb17 	ldw	r3,-20(fp)
   3661c:	18c00203 	ldbu	r3,8(r3)
   36620:	01000134 	movhi	r4,4
   36624:	21152c04 	addi	r4,r4,21680
   36628:	10801224 	muli	r2,r2,72
   3662c:	2085883a 	add	r2,r4,r2
   36630:	10800204 	addi	r2,r2,8
   36634:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_en_maclite 				= pmac->tse_en_maclite;
   36638:	d0a947c3 	ldbu	r2,-23265(gp)
   3663c:	10803fcc 	andi	r2,r2,255
   36640:	1080201c 	xori	r2,r2,128
   36644:	10bfe004 	addi	r2,r2,-128
   36648:	e0fffb17 	ldw	r3,-20(fp)
   3664c:	18c00243 	ldbu	r3,9(r3)
   36650:	01000134 	movhi	r4,4
   36654:	21152c04 	addi	r4,r4,21680
   36658:	10801224 	muli	r2,r2,72
   3665c:	2085883a 	add	r2,r4,r2
   36660:	10800204 	addi	r2,r2,8
   36664:	10c00045 	stb	r3,1(r2)
		tse_mac_device[tse_system_count].tse_maclite_gige 				= pmac->tse_maclite_gige;
   36668:	d0a947c3 	ldbu	r2,-23265(gp)
   3666c:	10803fcc 	andi	r2,r2,255
   36670:	1080201c 	xori	r2,r2,128
   36674:	10bfe004 	addi	r2,r2,-128
   36678:	e0fffb17 	ldw	r3,-20(fp)
   3667c:	18c00283 	ldbu	r3,10(r3)
   36680:	01000134 	movhi	r4,4
   36684:	21152c04 	addi	r4,r4,21680
   36688:	10801224 	muli	r2,r2,72
   3668c:	2085883a 	add	r2,r4,r2
   36690:	10800204 	addi	r2,r2,8
   36694:	10c00085 	stb	r3,2(r2)
		tse_mac_device[tse_system_count].tse_multichannel_mac 			= pmac->tse_multichannel_mac;
   36698:	d0a947c3 	ldbu	r2,-23265(gp)
   3669c:	10803fcc 	andi	r2,r2,255
   366a0:	1080201c 	xori	r2,r2,128
   366a4:	10bfe004 	addi	r2,r2,-128
   366a8:	e0fffb17 	ldw	r3,-20(fp)
   366ac:	18c002c3 	ldbu	r3,11(r3)
   366b0:	01000134 	movhi	r4,4
   366b4:	21152c04 	addi	r4,r4,21680
   366b8:	10801224 	muli	r2,r2,72
   366bc:	2085883a 	add	r2,r4,r2
   366c0:	10800204 	addi	r2,r2,8
   366c4:	10c000c5 	stb	r3,3(r2)
		tse_mac_device[tse_system_count].tse_num_of_channel 			= pmac->tse_num_of_channel;
   366c8:	d0a947c3 	ldbu	r2,-23265(gp)
   366cc:	10803fcc 	andi	r2,r2,255
   366d0:	1080201c 	xori	r2,r2,128
   366d4:	10bfe004 	addi	r2,r2,-128
   366d8:	e0fffb17 	ldw	r3,-20(fp)
   366dc:	18c00303 	ldbu	r3,12(r3)
   366e0:	01000134 	movhi	r4,4
   366e4:	21152c04 	addi	r4,r4,21680
   366e8:	10801224 	muli	r2,r2,72
   366ec:	2085883a 	add	r2,r4,r2
   366f0:	10800304 	addi	r2,r2,12
   366f4:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_mdio_shared 				= pmac->tse_mdio_shared;
   366f8:	d0a947c3 	ldbu	r2,-23265(gp)
   366fc:	10803fcc 	andi	r2,r2,255
   36700:	1080201c 	xori	r2,r2,128
   36704:	10bfe004 	addi	r2,r2,-128
   36708:	e0fffb17 	ldw	r3,-20(fp)
   3670c:	18c00343 	ldbu	r3,13(r3)
   36710:	01000134 	movhi	r4,4
   36714:	21152c04 	addi	r4,r4,21680
   36718:	10801224 	muli	r2,r2,72
   3671c:	2085883a 	add	r2,r4,r2
   36720:	10800304 	addi	r2,r2,12
   36724:	10c00045 	stb	r3,1(r2)
		tse_mac_device[tse_system_count].tse_number_of_mac_mdio_shared	= pmac->tse_number_of_mac_mdio_shared;
   36728:	d0a947c3 	ldbu	r2,-23265(gp)
   3672c:	10803fcc 	andi	r2,r2,255
   36730:	1080201c 	xori	r2,r2,128
   36734:	10bfe004 	addi	r2,r2,-128
   36738:	e0fffb17 	ldw	r3,-20(fp)
   3673c:	18c00383 	ldbu	r3,14(r3)
   36740:	01000134 	movhi	r4,4
   36744:	21152c04 	addi	r4,r4,21680
   36748:	10801224 	muli	r2,r2,72
   3674c:	2085883a 	add	r2,r4,r2
   36750:	10800304 	addi	r2,r2,12
   36754:	10c00085 	stb	r3,2(r2)
		tse_mac_device[tse_system_count].tse_pcs_ena 					= pmac->tse_pcs_ena;
   36758:	d0a947c3 	ldbu	r2,-23265(gp)
   3675c:	10803fcc 	andi	r2,r2,255
   36760:	1080201c 	xori	r2,r2,128
   36764:	10bfe004 	addi	r2,r2,-128
   36768:	e0fffb17 	ldw	r3,-20(fp)
   3676c:	18c003c3 	ldbu	r3,15(r3)
   36770:	01000134 	movhi	r4,4
   36774:	21152c04 	addi	r4,r4,21680
   36778:	10801224 	muli	r2,r2,72
   3677c:	2085883a 	add	r2,r4,r2
   36780:	10800304 	addi	r2,r2,12
   36784:	10c000c5 	stb	r3,3(r2)
		tse_mac_device[tse_system_count].tse_pcs_sgmii 					= pmac->tse_pcs_sgmii;
   36788:	d0a947c3 	ldbu	r2,-23265(gp)
   3678c:	10803fcc 	andi	r2,r2,255
   36790:	1080201c 	xori	r2,r2,128
   36794:	10bfe004 	addi	r2,r2,-128
   36798:	e0fffb17 	ldw	r3,-20(fp)
   3679c:	18c00403 	ldbu	r3,16(r3)
   367a0:	01000134 	movhi	r4,4
   367a4:	21152c04 	addi	r4,r4,21680
   367a8:	10801224 	muli	r2,r2,72
   367ac:	2085883a 	add	r2,r4,r2
   367b0:	10800404 	addi	r2,r2,16
   367b4:	10c00005 	stb	r3,0(r2)
		
		/* Add SGDMA info to alt_tse_system_info structure */
		if(psgdma == 0) {
   367b8:	e0bff717 	ldw	r2,-36(fp)
   367bc:	10000d1e 	bne	r2,zero,367f4 <alt_tse_system_add_sys+0x39c>
			tse_dprintf(2, "ERROR   : SGDMA system structure == NULL\n");
   367c0:	01000134 	movhi	r4,4
   367c4:	21063004 	addi	r4,r4,6336
   367c8:	00045340 	call	4534 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys() for tse_mac_device[%d]\n", tse_system_count);
   367cc:	d0a947c3 	ldbu	r2,-23265(gp)
   367d0:	10803fcc 	andi	r2,r2,255
   367d4:	1080201c 	xori	r2,r2,128
   367d8:	10bfe004 	addi	r2,r2,-128
   367dc:	01000134 	movhi	r4,4
   367e0:	21063b04 	addi	r4,r4,6380
   367e4:	100b883a 	mov	r5,r2
   367e8:	00044740 	call	4474 <printf>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
   367ec:	00bfffc4 	movi	r2,-1
   367f0:	00019206 	br	36e3c <alt_tse_system_add_sys+0x9e4>
		}
		
		tse_mac_device[tse_system_count].tse_sgdma_tx = (char *) malloc(strlen(psgdma->tse_sgdma_tx) + 1);
   367f4:	d0a947c3 	ldbu	r2,-23265(gp)
   367f8:	14003fcc 	andi	r16,r2,255
   367fc:	8400201c 	xori	r16,r16,128
   36800:	843fe004 	addi	r16,r16,-128
   36804:	e0bff717 	ldw	r2,-36(fp)
   36808:	10800017 	ldw	r2,0(r2)
   3680c:	1009883a 	mov	r4,r2
   36810:	0004d9c0 	call	4d9c <strlen>
   36814:	10800044 	addi	r2,r2,1
   36818:	1009883a 	mov	r4,r2
   3681c:	003f1fc0 	call	3f1fc <malloc>
   36820:	1007883a 	mov	r3,r2
   36824:	01000134 	movhi	r4,4
   36828:	21152c04 	addi	r4,r4,21680
   3682c:	80801224 	muli	r2,r16,72
   36830:	2085883a 	add	r2,r4,r2
   36834:	10800504 	addi	r2,r2,20
   36838:	10c00015 	stw	r3,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_tx) {
   3683c:	d0a947c3 	ldbu	r2,-23265(gp)
   36840:	10803fcc 	andi	r2,r2,255
   36844:	1080201c 	xori	r2,r2,128
   36848:	10bfe004 	addi	r2,r2,-128
   3684c:	00c00134 	movhi	r3,4
   36850:	18d52c04 	addi	r3,r3,21680
   36854:	10801224 	muli	r2,r2,72
   36858:	1885883a 	add	r2,r3,r2
   3685c:	10800504 	addi	r2,r2,20
   36860:	10800017 	ldw	r2,0(r2)
   36864:	10000a1e 	bne	r2,zero,36890 <alt_tse_system_add_sys+0x438>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_tx\n", tse_system_count);
   36868:	d0a947c3 	ldbu	r2,-23265(gp)
   3686c:	10803fcc 	andi	r2,r2,255
   36870:	1080201c 	xori	r2,r2,128
   36874:	10bfe004 	addi	r2,r2,-128
   36878:	01000134 	movhi	r4,4
   3687c:	21065304 	addi	r4,r4,6476
   36880:	100b883a 	mov	r5,r2
   36884:	00044740 	call	4474 <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
   36888:	00bfffc4 	movi	r2,-1
   3688c:	00016b06 	br	36e3c <alt_tse_system_add_sys+0x9e4>
	    }   
		strcpy(tse_mac_device[tse_system_count].tse_sgdma_tx, psgdma->tse_sgdma_tx);
   36890:	d0a947c3 	ldbu	r2,-23265(gp)
   36894:	10803fcc 	andi	r2,r2,255
   36898:	1080201c 	xori	r2,r2,128
   3689c:	10bfe004 	addi	r2,r2,-128
   368a0:	00c00134 	movhi	r3,4
   368a4:	18d52c04 	addi	r3,r3,21680
   368a8:	10801224 	muli	r2,r2,72
   368ac:	1885883a 	add	r2,r3,r2
   368b0:	10800504 	addi	r2,r2,20
   368b4:	10c00017 	ldw	r3,0(r2)
   368b8:	e0bff717 	ldw	r2,-36(fp)
   368bc:	10800017 	ldw	r2,0(r2)
   368c0:	1809883a 	mov	r4,r3
   368c4:	100b883a 	mov	r5,r2
   368c8:	00046a40 	call	46a4 <strcpy>
		
		tse_mac_device[tse_system_count].tse_sgdma_rx = (char *) malloc(strlen(psgdma->tse_sgdma_rx) + 1);
   368cc:	d0a947c3 	ldbu	r2,-23265(gp)
   368d0:	14003fcc 	andi	r16,r2,255
   368d4:	8400201c 	xori	r16,r16,128
   368d8:	843fe004 	addi	r16,r16,-128
   368dc:	e0bff717 	ldw	r2,-36(fp)
   368e0:	10800117 	ldw	r2,4(r2)
   368e4:	1009883a 	mov	r4,r2
   368e8:	0004d9c0 	call	4d9c <strlen>
   368ec:	10800044 	addi	r2,r2,1
   368f0:	1009883a 	mov	r4,r2
   368f4:	003f1fc0 	call	3f1fc <malloc>
   368f8:	1007883a 	mov	r3,r2
   368fc:	01000134 	movhi	r4,4
   36900:	21152c04 	addi	r4,r4,21680
   36904:	80801224 	muli	r2,r16,72
   36908:	2085883a 	add	r2,r4,r2
   3690c:	10800604 	addi	r2,r2,24
   36910:	10c00015 	stw	r3,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_rx) {
   36914:	d0a947c3 	ldbu	r2,-23265(gp)
   36918:	10803fcc 	andi	r2,r2,255
   3691c:	1080201c 	xori	r2,r2,128
   36920:	10bfe004 	addi	r2,r2,-128
   36924:	00c00134 	movhi	r3,4
   36928:	18d52c04 	addi	r3,r3,21680
   3692c:	10801224 	muli	r2,r2,72
   36930:	1885883a 	add	r2,r3,r2
   36934:	10800604 	addi	r2,r2,24
   36938:	10800017 	ldw	r2,0(r2)
   3693c:	10000a1e 	bne	r2,zero,36968 <alt_tse_system_add_sys+0x510>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_rx\n", tse_system_count);
   36940:	d0a947c3 	ldbu	r2,-23265(gp)
   36944:	10803fcc 	andi	r2,r2,255
   36948:	1080201c 	xori	r2,r2,128
   3694c:	10bfe004 	addi	r2,r2,-128
   36950:	01000134 	movhi	r4,4
   36954:	21066604 	addi	r4,r4,6552
   36958:	100b883a 	mov	r5,r2
   3695c:	00044740 	call	4474 <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
   36960:	00bfffc4 	movi	r2,-1
   36964:	00013506 	br	36e3c <alt_tse_system_add_sys+0x9e4>
	    }
	    strcpy(tse_mac_device[tse_system_count].tse_sgdma_rx, psgdma->tse_sgdma_rx);
   36968:	d0a947c3 	ldbu	r2,-23265(gp)
   3696c:	10803fcc 	andi	r2,r2,255
   36970:	1080201c 	xori	r2,r2,128
   36974:	10bfe004 	addi	r2,r2,-128
   36978:	00c00134 	movhi	r3,4
   3697c:	18d52c04 	addi	r3,r3,21680
   36980:	10801224 	muli	r2,r2,72
   36984:	1885883a 	add	r2,r3,r2
   36988:	10800604 	addi	r2,r2,24
   3698c:	10c00017 	ldw	r3,0(r2)
   36990:	e0bff717 	ldw	r2,-36(fp)
   36994:	10800117 	ldw	r2,4(r2)
   36998:	1809883a 	mov	r4,r3
   3699c:	100b883a 	mov	r5,r2
   369a0:	00046a40 	call	46a4 <strcpy>
	    
		tse_mac_device[tse_system_count].tse_sgdma_rx_irq = psgdma->tse_sgdma_rx_irq;
   369a4:	d0a947c3 	ldbu	r2,-23265(gp)
   369a8:	10803fcc 	andi	r2,r2,255
   369ac:	1080201c 	xori	r2,r2,128
   369b0:	10bfe004 	addi	r2,r2,-128
   369b4:	e0fff717 	ldw	r3,-36(fp)
   369b8:	18c0020b 	ldhu	r3,8(r3)
   369bc:	01000134 	movhi	r4,4
   369c0:	21152c04 	addi	r4,r4,21680
   369c4:	10801224 	muli	r2,r2,72
   369c8:	2085883a 	add	r2,r4,r2
   369cc:	10800704 	addi	r2,r2,28
   369d0:	10c0000d 	sth	r3,0(r2)
		
		/* Add descriptor memory info to alt_tse_system_info structure */
		if(pmem == 0) {
   369d4:	e0bff817 	ldw	r2,-32(fp)
   369d8:	1000151e 	bne	r2,zero,36a30 <alt_tse_system_add_sys+0x5d8>
			tse_mac_device[tse_system_count].ext_desc_mem	= TSE_INT_DESC_MEM;
   369dc:	d0a947c3 	ldbu	r2,-23265(gp)
   369e0:	10803fcc 	andi	r2,r2,255
   369e4:	1080201c 	xori	r2,r2,128
   369e8:	10bfe004 	addi	r2,r2,-128
   369ec:	00c00134 	movhi	r3,4
   369f0:	18d52c04 	addi	r3,r3,21680
   369f4:	10801224 	muli	r2,r2,72
   369f8:	1885883a 	add	r2,r3,r2
   369fc:	10800704 	addi	r2,r2,28
   36a00:	10000085 	stb	zero,2(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= TSE_INT_DESC_MEM;
   36a04:	d0a947c3 	ldbu	r2,-23265(gp)
   36a08:	10803fcc 	andi	r2,r2,255
   36a0c:	1080201c 	xori	r2,r2,128
   36a10:	10bfe004 	addi	r2,r2,-128
   36a14:	00c00134 	movhi	r3,4
   36a18:	18d52c04 	addi	r3,r3,21680
   36a1c:	10801224 	muli	r2,r2,72
   36a20:	1885883a 	add	r2,r3,r2
   36a24:	10800804 	addi	r2,r2,32
   36a28:	10000015 	stw	zero,0(r2)
   36a2c:	00001806 	br	36a90 <alt_tse_system_add_sys+0x638>
		}
		else {
			tse_mac_device[tse_system_count].ext_desc_mem	= pmem->ext_desc_mem;
   36a30:	d0a947c3 	ldbu	r2,-23265(gp)
   36a34:	10803fcc 	andi	r2,r2,255
   36a38:	1080201c 	xori	r2,r2,128
   36a3c:	10bfe004 	addi	r2,r2,-128
   36a40:	e0fff817 	ldw	r3,-32(fp)
   36a44:	18c00003 	ldbu	r3,0(r3)
   36a48:	01000134 	movhi	r4,4
   36a4c:	21152c04 	addi	r4,r4,21680
   36a50:	10801224 	muli	r2,r2,72
   36a54:	2085883a 	add	r2,r4,r2
   36a58:	10800704 	addi	r2,r2,28
   36a5c:	10c00085 	stb	r3,2(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= pmem->desc_mem_base;
   36a60:	d0a947c3 	ldbu	r2,-23265(gp)
   36a64:	10803fcc 	andi	r2,r2,255
   36a68:	1080201c 	xori	r2,r2,128
   36a6c:	10bfe004 	addi	r2,r2,-128
   36a70:	e0fff817 	ldw	r3,-32(fp)
   36a74:	18c00117 	ldw	r3,4(r3)
   36a78:	01000134 	movhi	r4,4
   36a7c:	21152c04 	addi	r4,r4,21680
   36a80:	10801224 	muli	r2,r2,72
   36a84:	2085883a 	add	r2,r4,r2
   36a88:	10800804 	addi	r2,r2,32
   36a8c:	10c00015 	stw	r3,0(r2)
		}
		
		/* Add shared fifo info to alt_tse_system_info structure */
		if(pfifo == 0) {
   36a90:	e0bff917 	ldw	r2,-28(fp)
   36a94:	1000471e 	bne	r2,zero,36bb4 <alt_tse_system_add_sys+0x75c>
			tse_mac_device[tse_system_count].use_shared_fifo                = TSE_NO_SHARED_FIFO;
   36a98:	d0a947c3 	ldbu	r2,-23265(gp)
   36a9c:	10803fcc 	andi	r2,r2,255
   36aa0:	1080201c 	xori	r2,r2,128
   36aa4:	10bfe004 	addi	r2,r2,-128
   36aa8:	00c00134 	movhi	r3,4
   36aac:	18d52c04 	addi	r3,r3,21680
   36ab0:	10801224 	muli	r2,r2,72
   36ab4:	1885883a 	add	r2,r3,r2
   36ab8:	10800904 	addi	r2,r2,36
   36abc:	10000005 	stb	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= TSE_NO_SHARED_FIFO;
   36ac0:	d0a947c3 	ldbu	r2,-23265(gp)
   36ac4:	10803fcc 	andi	r2,r2,255
   36ac8:	1080201c 	xori	r2,r2,128
   36acc:	10bfe004 	addi	r2,r2,-128
   36ad0:	00c00134 	movhi	r3,4
   36ad4:	18d52c04 	addi	r3,r3,21680
   36ad8:	10801224 	muli	r2,r2,72
   36adc:	1885883a 	add	r2,r3,r2
   36ae0:	10800a04 	addi	r2,r2,40
   36ae4:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= TSE_NO_SHARED_FIFO;
   36ae8:	d0a947c3 	ldbu	r2,-23265(gp)
   36aec:	10803fcc 	andi	r2,r2,255
   36af0:	1080201c 	xori	r2,r2,128
   36af4:	10bfe004 	addi	r2,r2,-128
   36af8:	00c00134 	movhi	r3,4
   36afc:	18d52c04 	addi	r3,r3,21680
   36b00:	10801224 	muli	r2,r2,72
   36b04:	1885883a 	add	r2,r3,r2
   36b08:	10800b04 	addi	r2,r2,44
   36b0c:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = TSE_NO_SHARED_FIFO;
   36b10:	d0a947c3 	ldbu	r2,-23265(gp)
   36b14:	10803fcc 	andi	r2,r2,255
   36b18:	1080201c 	xori	r2,r2,128
   36b1c:	10bfe004 	addi	r2,r2,-128
   36b20:	00c00134 	movhi	r3,4
   36b24:	18d52c04 	addi	r3,r3,21680
   36b28:	10801224 	muli	r2,r2,72
   36b2c:	1885883a 	add	r2,r3,r2
   36b30:	10800c04 	addi	r2,r2,48
   36b34:	10000015 	stw	zero,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= TSE_NO_SHARED_FIFO;
   36b38:	d0a947c3 	ldbu	r2,-23265(gp)
   36b3c:	10803fcc 	andi	r2,r2,255
   36b40:	1080201c 	xori	r2,r2,128
   36b44:	10bfe004 	addi	r2,r2,-128
   36b48:	00c00134 	movhi	r3,4
   36b4c:	18d52c04 	addi	r3,r3,21680
   36b50:	10801224 	muli	r2,r2,72
   36b54:	1885883a 	add	r2,r3,r2
   36b58:	10800d04 	addi	r2,r2,52
   36b5c:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= TSE_NO_SHARED_FIFO;
   36b60:	d0a947c3 	ldbu	r2,-23265(gp)
   36b64:	10803fcc 	andi	r2,r2,255
   36b68:	1080201c 	xori	r2,r2,128
   36b6c:	10bfe004 	addi	r2,r2,-128
   36b70:	00c00134 	movhi	r3,4
   36b74:	18d52c04 	addi	r3,r3,21680
   36b78:	10801224 	muli	r2,r2,72
   36b7c:	1885883a 	add	r2,r3,r2
   36b80:	10800e04 	addi	r2,r2,56
   36b84:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = TSE_NO_SHARED_FIFO;
   36b88:	d0a947c3 	ldbu	r2,-23265(gp)
   36b8c:	10803fcc 	andi	r2,r2,255
   36b90:	1080201c 	xori	r2,r2,128
   36b94:	10bfe004 	addi	r2,r2,-128
   36b98:	00c00134 	movhi	r3,4
   36b9c:	18d52c04 	addi	r3,r3,21680
   36ba0:	10801224 	muli	r2,r2,72
   36ba4:	1885883a 	add	r2,r3,r2
   36ba8:	10800f04 	addi	r2,r2,60
   36bac:	10000015 	stw	zero,0(r2)
   36bb0:	00005406 	br	36d04 <alt_tse_system_add_sys+0x8ac>
		}
		else {
			tse_mac_device[tse_system_count].use_shared_fifo                = pfifo->use_shared_fifo;
   36bb4:	d0a947c3 	ldbu	r2,-23265(gp)
   36bb8:	10803fcc 	andi	r2,r2,255
   36bbc:	1080201c 	xori	r2,r2,128
   36bc0:	10bfe004 	addi	r2,r2,-128
   36bc4:	e0fff917 	ldw	r3,-28(fp)
   36bc8:	18c00003 	ldbu	r3,0(r3)
   36bcc:	01000134 	movhi	r4,4
   36bd0:	21152c04 	addi	r4,r4,21680
   36bd4:	10801224 	muli	r2,r2,72
   36bd8:	2085883a 	add	r2,r4,r2
   36bdc:	10800904 	addi	r2,r2,36
   36be0:	10c00005 	stb	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= pfifo->tse_shared_fifo_tx_ctrl_base;
   36be4:	d0a947c3 	ldbu	r2,-23265(gp)
   36be8:	10803fcc 	andi	r2,r2,255
   36bec:	1080201c 	xori	r2,r2,128
   36bf0:	10bfe004 	addi	r2,r2,-128
   36bf4:	e0fff917 	ldw	r3,-28(fp)
   36bf8:	18c00117 	ldw	r3,4(r3)
   36bfc:	01000134 	movhi	r4,4
   36c00:	21152c04 	addi	r4,r4,21680
   36c04:	10801224 	muli	r2,r2,72
   36c08:	2085883a 	add	r2,r4,r2
   36c0c:	10800a04 	addi	r2,r2,40
   36c10:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= pfifo->tse_shared_fifo_tx_stat_base;
   36c14:	d0a947c3 	ldbu	r2,-23265(gp)
   36c18:	10803fcc 	andi	r2,r2,255
   36c1c:	1080201c 	xori	r2,r2,128
   36c20:	10bfe004 	addi	r2,r2,-128
   36c24:	e0fff917 	ldw	r3,-28(fp)
   36c28:	18c00217 	ldw	r3,8(r3)
   36c2c:	01000134 	movhi	r4,4
   36c30:	21152c04 	addi	r4,r4,21680
   36c34:	10801224 	muli	r2,r2,72
   36c38:	2085883a 	add	r2,r4,r2
   36c3c:	10800b04 	addi	r2,r2,44
   36c40:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = pfifo->tse_shared_fifo_tx_depth;
   36c44:	d0a947c3 	ldbu	r2,-23265(gp)
   36c48:	10803fcc 	andi	r2,r2,255
   36c4c:	1080201c 	xori	r2,r2,128
   36c50:	10bfe004 	addi	r2,r2,-128
   36c54:	e0fff917 	ldw	r3,-28(fp)
   36c58:	18c00317 	ldw	r3,12(r3)
   36c5c:	01000134 	movhi	r4,4
   36c60:	21152c04 	addi	r4,r4,21680
   36c64:	10801224 	muli	r2,r2,72
   36c68:	2085883a 	add	r2,r4,r2
   36c6c:	10800c04 	addi	r2,r2,48
   36c70:	10c00015 	stw	r3,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= pfifo->tse_shared_fifo_rx_ctrl_base;
   36c74:	d0a947c3 	ldbu	r2,-23265(gp)
   36c78:	10803fcc 	andi	r2,r2,255
   36c7c:	1080201c 	xori	r2,r2,128
   36c80:	10bfe004 	addi	r2,r2,-128
   36c84:	e0fff917 	ldw	r3,-28(fp)
   36c88:	18c00417 	ldw	r3,16(r3)
   36c8c:	01000134 	movhi	r4,4
   36c90:	21152c04 	addi	r4,r4,21680
   36c94:	10801224 	muli	r2,r2,72
   36c98:	2085883a 	add	r2,r4,r2
   36c9c:	10800d04 	addi	r2,r2,52
   36ca0:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= pfifo->tse_shared_fifo_rx_stat_base;
   36ca4:	d0a947c3 	ldbu	r2,-23265(gp)
   36ca8:	10803fcc 	andi	r2,r2,255
   36cac:	1080201c 	xori	r2,r2,128
   36cb0:	10bfe004 	addi	r2,r2,-128
   36cb4:	e0fff917 	ldw	r3,-28(fp)
   36cb8:	18c00517 	ldw	r3,20(r3)
   36cbc:	01000134 	movhi	r4,4
   36cc0:	21152c04 	addi	r4,r4,21680
   36cc4:	10801224 	muli	r2,r2,72
   36cc8:	2085883a 	add	r2,r4,r2
   36ccc:	10800e04 	addi	r2,r2,56
   36cd0:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = pfifo->tse_shared_fifo_rx_depth;
   36cd4:	d0a947c3 	ldbu	r2,-23265(gp)
   36cd8:	10803fcc 	andi	r2,r2,255
   36cdc:	1080201c 	xori	r2,r2,128
   36ce0:	10bfe004 	addi	r2,r2,-128
   36ce4:	e0fff917 	ldw	r3,-28(fp)
   36ce8:	18c00617 	ldw	r3,24(r3)
   36cec:	01000134 	movhi	r4,4
   36cf0:	21152c04 	addi	r4,r4,21680
   36cf4:	10801224 	muli	r2,r2,72
   36cf8:	2085883a 	add	r2,r4,r2
   36cfc:	10800f04 	addi	r2,r2,60
   36d00:	10c00015 	stw	r3,0(r2)
		}
		
		/* Add PHY info to alt_tse_system_info structure */
		if(pphy == 0) {
   36d04:	e0bffa17 	ldw	r2,-24(fp)
   36d08:	1000161e 	bne	r2,zero,36d64 <alt_tse_system_add_sys+0x90c>
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= TSE_PHY_AUTO_ADDRESS;
   36d0c:	d0a947c3 	ldbu	r2,-23265(gp)
   36d10:	10803fcc 	andi	r2,r2,255
   36d14:	1080201c 	xori	r2,r2,128
   36d18:	10bfe004 	addi	r2,r2,-128
   36d1c:	00c00134 	movhi	r3,4
   36d20:	18d52c04 	addi	r3,r3,21680
   36d24:	10801224 	muli	r2,r2,72
   36d28:	1885883a 	add	r2,r3,r2
   36d2c:	10801004 	addi	r2,r2,64
   36d30:	00ffffc4 	movi	r3,-1
   36d34:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= 0;
   36d38:	d0a947c3 	ldbu	r2,-23265(gp)
   36d3c:	10803fcc 	andi	r2,r2,255
   36d40:	1080201c 	xori	r2,r2,128
   36d44:	10bfe004 	addi	r2,r2,-128
   36d48:	00c00134 	movhi	r3,4
   36d4c:	18d52c04 	addi	r3,r3,21680
   36d50:	10801224 	muli	r2,r2,72
   36d54:	1885883a 	add	r2,r3,r2
   36d58:	10801104 	addi	r2,r2,68
   36d5c:	10000015 	stw	zero,0(r2)
   36d60:	00001806 	br	36dc4 <alt_tse_system_add_sys+0x96c>
		}
		else {
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= pphy->tse_phy_mdio_address;
   36d64:	d0a947c3 	ldbu	r2,-23265(gp)
   36d68:	10803fcc 	andi	r2,r2,255
   36d6c:	1080201c 	xori	r2,r2,128
   36d70:	10bfe004 	addi	r2,r2,-128
   36d74:	e0fffa17 	ldw	r3,-24(fp)
   36d78:	18c00017 	ldw	r3,0(r3)
   36d7c:	01000134 	movhi	r4,4
   36d80:	21152c04 	addi	r4,r4,21680
   36d84:	10801224 	muli	r2,r2,72
   36d88:	2085883a 	add	r2,r4,r2
   36d8c:	10801004 	addi	r2,r2,64
   36d90:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= pphy->tse_phy_cfg;
   36d94:	d0a947c3 	ldbu	r2,-23265(gp)
   36d98:	10803fcc 	andi	r2,r2,255
   36d9c:	1080201c 	xori	r2,r2,128
   36da0:	10bfe004 	addi	r2,r2,-128
   36da4:	e0fffa17 	ldw	r3,-24(fp)
   36da8:	18c00117 	ldw	r3,4(r3)
   36dac:	01000134 	movhi	r4,4
   36db0:	21152c04 	addi	r4,r4,21680
   36db4:	10801224 	muli	r2,r2,72
   36db8:	2085883a 	add	r2,r4,r2
   36dbc:	10801104 	addi	r2,r2,68
   36dc0:	10c00015 	stw	r3,0(r2)
		}
		
		/* Point to next structure */
		psgdma++;
   36dc4:	e0bff717 	ldw	r2,-36(fp)
   36dc8:	10800304 	addi	r2,r2,12
   36dcc:	e0bff715 	stw	r2,-36(fp)
		if(pmem) pmem++;
   36dd0:	e0bff817 	ldw	r2,-32(fp)
   36dd4:	10000326 	beq	r2,zero,36de4 <alt_tse_system_add_sys+0x98c>
   36dd8:	e0bff817 	ldw	r2,-32(fp)
   36ddc:	10800204 	addi	r2,r2,8
   36de0:	e0bff815 	stw	r2,-32(fp)
		if(pfifo) pfifo++;
   36de4:	e0bff917 	ldw	r2,-28(fp)
   36de8:	10000326 	beq	r2,zero,36df8 <alt_tse_system_add_sys+0x9a0>
   36dec:	e0bff917 	ldw	r2,-28(fp)
   36df0:	10800704 	addi	r2,r2,28
   36df4:	e0bff915 	stw	r2,-28(fp)
		if(pphy) pphy++;
   36df8:	e0bffa17 	ldw	r2,-24(fp)
   36dfc:	10000326 	beq	r2,zero,36e0c <alt_tse_system_add_sys+0x9b4>
   36e00:	e0bffa17 	ldw	r2,-24(fp)
   36e04:	10800204 	addi	r2,r2,8
   36e08:	e0bffa15 	stw	r2,-24(fp)
		
		tse_system_count++;
   36e0c:	d0a947c3 	ldbu	r2,-23265(gp)
   36e10:	10800044 	addi	r2,r2,1
   36e14:	d0a947c5 	stb	r2,-23265(gp)
		max_mac_system = tse_system_count;
   36e18:	d0a947c3 	ldbu	r2,-23265(gp)
   36e1c:	d0a01c05 	stb	r2,-32656(gp)
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
	}

	for(i = 0; i < loop_end; i++) {
   36e20:	e0bff517 	ldw	r2,-44(fp)
   36e24:	10800044 	addi	r2,r2,1
   36e28:	e0bff515 	stw	r2,-44(fp)
   36e2c:	e0fff517 	ldw	r3,-44(fp)
   36e30:	e0bff617 	ldw	r2,-40(fp)
   36e34:	18bdb216 	blt	r3,r2,36500 <alt_tse_system_add_sys+0xa8>
		
		tse_system_count++;
		max_mac_system = tse_system_count;
	}
	
	return SUCCESS;
   36e38:	0005883a 	mov	r2,zero
	
}
   36e3c:	e037883a 	mov	sp,fp
   36e40:	dfc00217 	ldw	ra,8(sp)
   36e44:	df000117 	ldw	fp,4(sp)
   36e48:	dc000017 	ldw	r16,0(sp)
   36e4c:	dec00304 	addi	sp,sp,12
   36e50:	f800283a 	ret

00036e54 <alt_tse_sys_enable_mdio_sharing>:
 * @param		number_of_mac  number of MAC sharing MDIO block
 * @return      SUCCESS on success
 * 				ALTERA_TSE_SYSTEM_DEF_ERROR if definition of system incorrect or pointer == NULL
 * Multi-channel MAC not supported
 */
alt_32 alt_tse_sys_enable_mdio_sharing(alt_tse_system_mac **psys_mac_list, alt_u8 number_of_mac) {
   36e54:	defff904 	addi	sp,sp,-28
   36e58:	dfc00615 	stw	ra,24(sp)
   36e5c:	df000515 	stw	fp,20(sp)
   36e60:	df000504 	addi	fp,sp,20
   36e64:	e13ffe15 	stw	r4,-8(fp)
   36e68:	2805883a 	mov	r2,r5
   36e6c:	e0bfff05 	stb	r2,-4(fp)
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
   36e70:	e03ffb15 	stw	zero,-20(fp)
   36e74:	00004706 	br	36f94 <alt_tse_sys_enable_mdio_sharing+0x140>
		psys_mac = psys_mac_list[i];
   36e78:	e0bffb17 	ldw	r2,-20(fp)
   36e7c:	1085883a 	add	r2,r2,r2
   36e80:	1085883a 	add	r2,r2,r2
   36e84:	e0fffe17 	ldw	r3,-8(fp)
   36e88:	1885883a 	add	r2,r3,r2
   36e8c:	10800017 	ldw	r2,0(r2)
   36e90:	e0bffd15 	stw	r2,-12(fp)
		
		if(psys_mac == 0) {
   36e94:	e0bffd17 	ldw	r2,-12(fp)
   36e98:	1000081e 	bne	r2,zero,36ebc <alt_tse_sys_enable_mdio_sharing+0x68>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
   36e9c:	01000134 	movhi	r4,4
   36ea0:	21061404 	addi	r4,r4,6224
   36ea4:	00045340 	call	4534 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
   36ea8:	01000134 	movhi	r4,4
   36eac:	21067904 	addi	r4,r4,6628
   36eb0:	00045340 	call	4534 <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
   36eb4:	00bfffc4 	movi	r2,-1
   36eb8:	00003a06 	br	36fa4 <alt_tse_sys_enable_mdio_sharing+0x150>
		}
		
		for(j = 0; j < max_mac_system; j++) {
   36ebc:	e03ffc15 	stw	zero,-16(fp)
   36ec0:	00002d06 	br	36f78 <alt_tse_sys_enable_mdio_sharing+0x124>
			
			if(psys_mac->tse_mac_base == tse_mac_device[j].tse_mac_base) {
   36ec4:	e0bffd17 	ldw	r2,-12(fp)
   36ec8:	10c00017 	ldw	r3,0(r2)
   36ecc:	01000134 	movhi	r4,4
   36ed0:	21152c04 	addi	r4,r4,21680
   36ed4:	e0bffc17 	ldw	r2,-16(fp)
   36ed8:	10801224 	muli	r2,r2,72
   36edc:	2085883a 	add	r2,r4,r2
   36ee0:	10800017 	ldw	r2,0(r2)
   36ee4:	1880211e 	bne	r3,r2,36f6c <alt_tse_sys_enable_mdio_sharing+0x118>
				if(tse_mac_device[j].tse_multichannel_mac) {
   36ee8:	00c00134 	movhi	r3,4
   36eec:	18d52c04 	addi	r3,r3,21680
   36ef0:	e0bffc17 	ldw	r2,-16(fp)
   36ef4:	10801224 	muli	r2,r2,72
   36ef8:	1885883a 	add	r2,r3,r2
   36efc:	10800204 	addi	r2,r2,8
   36f00:	108000c3 	ldbu	r2,3(r2)
   36f04:	10803fcc 	andi	r2,r2,255
   36f08:	10000826 	beq	r2,zero,36f2c <alt_tse_sys_enable_mdio_sharing+0xd8>
					tse_dprintf(2, "ERROR   : MDIO sharing supported by default for Multi-channel MAC\n");
   36f0c:	01000134 	movhi	r4,4
   36f10:	21068d04 	addi	r4,r4,6708
   36f14:	00045340 	call	4534 <puts>
					tse_dprintf(2, "ERROR   : Do not include Multi-channel MAC in the MAC List\n");
   36f18:	01000134 	movhi	r4,4
   36f1c:	21069e04 	addi	r4,r4,6776
   36f20:	00045340 	call	4534 <puts>
					return ALTERA_TSE_SYSTEM_DEF_ERROR;
   36f24:	00bfffc4 	movi	r2,-1
   36f28:	00001e06 	br	36fa4 <alt_tse_sys_enable_mdio_sharing+0x150>
				}
				
				tse_mac_device[j].tse_mdio_shared = 1;
   36f2c:	00c00134 	movhi	r3,4
   36f30:	18d52c04 	addi	r3,r3,21680
   36f34:	e0bffc17 	ldw	r2,-16(fp)
   36f38:	10801224 	muli	r2,r2,72
   36f3c:	1885883a 	add	r2,r3,r2
   36f40:	10800304 	addi	r2,r2,12
   36f44:	00c00044 	movi	r3,1
   36f48:	10c00045 	stb	r3,1(r2)
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
   36f4c:	00c00134 	movhi	r3,4
   36f50:	18d52c04 	addi	r3,r3,21680
   36f54:	e0bffc17 	ldw	r2,-16(fp)
   36f58:	10801224 	muli	r2,r2,72
   36f5c:	1885883a 	add	r2,r3,r2
   36f60:	10800304 	addi	r2,r2,12
   36f64:	e0ffff03 	ldbu	r3,-4(fp)
   36f68:	10c00085 	stb	r3,2(r2)
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
		}
		
		for(j = 0; j < max_mac_system; j++) {
   36f6c:	e0bffc17 	ldw	r2,-16(fp)
   36f70:	10800044 	addi	r2,r2,1
   36f74:	e0bffc15 	stw	r2,-16(fp)
   36f78:	d0a01c03 	ldbu	r2,-32656(gp)
   36f7c:	10803fcc 	andi	r2,r2,255
   36f80:	e0fffc17 	ldw	r3,-16(fp)
   36f84:	18bfcf16 	blt	r3,r2,36ec4 <alt_tse_sys_enable_mdio_sharing+0x70>
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
   36f88:	e0bffb17 	ldw	r2,-20(fp)
   36f8c:	10800044 	addi	r2,r2,1
   36f90:	e0bffb15 	stw	r2,-20(fp)
   36f94:	e0bfff03 	ldbu	r2,-4(fp)
   36f98:	e0fffb17 	ldw	r3,-20(fp)
   36f9c:	18bfb616 	blt	r3,r2,36e78 <alt_tse_sys_enable_mdio_sharing+0x24>
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
			}
		}	
	}
	
	return SUCCESS;
   36fa0:	0005883a 	mov	r2,zero
}
   36fa4:	e037883a 	mov	sp,fp
   36fa8:	dfc00117 	ldw	ra,4(sp)
   36fac:	df000017 	ldw	fp,0(sp)
   36fb0:	dec00204 	addi	sp,sp,8
   36fb4:	f800283a 	ret

00036fb8 <alt_tse_mac_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Public
 * @param pmac          Pointer to the TSE MAC Control Interface Base address
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_mac_get_common_speed(np_tse_mac *pmac) {
   36fb8:	defffc04 	addi	sp,sp,-16
   36fbc:	dfc00315 	stw	ra,12(sp)
   36fc0:	df000215 	stw	fp,8(sp)
   36fc4:	df000204 	addi	fp,sp,8
   36fc8:	e13fff15 	stw	r4,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
   36fcc:	e13fff17 	ldw	r4,-4(fp)
   36fd0:	00371a00 	call	371a0 <alt_tse_get_mac_info>
   36fd4:	10800317 	ldw	r2,12(r2)
   36fd8:	e0bffe15 	stw	r2,-8(fp)
    return alt_tse_phy_get_common_speed(pmac_group);
   36fdc:	e13ffe17 	ldw	r4,-8(fp)
   36fe0:	003a3240 	call	3a324 <alt_tse_phy_get_common_speed>
}
   36fe4:	e037883a 	mov	sp,fp
   36fe8:	dfc00117 	ldw	ra,4(sp)
   36fec:	df000017 	ldw	fp,0(sp)
   36ff0:	dec00204 	addi	sp,sp,8
   36ff4:	f800283a 	ret

00036ff8 <alt_tse_mac_set_common_speed>:
 * @API Type:               Public
 * @param pmac              Pointer to the TSE MAC Control Interface Base address
 *        common_speed      common speed supported by all PHYs
 * @return                  common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_mac_set_common_speed(np_tse_mac *pmac, alt_32 common_speed) {
   36ff8:	defffb04 	addi	sp,sp,-20
   36ffc:	dfc00415 	stw	ra,16(sp)
   37000:	df000315 	stw	fp,12(sp)
   37004:	df000304 	addi	fp,sp,12
   37008:	e13ffe15 	stw	r4,-8(fp)
   3700c:	e17fff15 	stw	r5,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
   37010:	e13ffe17 	ldw	r4,-8(fp)
   37014:	00371a00 	call	371a0 <alt_tse_get_mac_info>
   37018:	10800317 	ldw	r2,12(r2)
   3701c:	e0bffd15 	stw	r2,-12(fp)
    return alt_tse_phy_set_common_speed(pmac_group, common_speed);
   37020:	e13ffd17 	ldw	r4,-12(fp)
   37024:	e17fff17 	ldw	r5,-4(fp)
   37028:	003a64c0 	call	3a64c <alt_tse_phy_set_common_speed>
}
   3702c:	e037883a 	mov	sp,fp
   37030:	dfc00117 	ldw	ra,4(sp)
   37034:	df000017 	ldw	fp,0(sp)
   37038:	dec00204 	addi	sp,sp,8
   3703c:	f800283a 	ret

00037040 <alt_tse_get_system_index>:
/* @Function Description: Get the index of alt_tse_system_info structure in tse_mac_device[]
 * @API Type:        Internal
 * @param psys_info  Pointer to the alt_tse_system_info structure
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
   37040:	defffd04 	addi	sp,sp,-12
   37044:	df000215 	stw	fp,8(sp)
   37048:	df000204 	addi	fp,sp,8
   3704c:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
   37050:	e03ffe15 	stw	zero,-8(fp)
   37054:	00000c06 	br	37088 <alt_tse_get_system_index+0x48>
        if(psys_info == &tse_mac_device[i]) {
   37058:	e0bffe17 	ldw	r2,-8(fp)
   3705c:	10c01224 	muli	r3,r2,72
   37060:	00800134 	movhi	r2,4
   37064:	10952c04 	addi	r2,r2,21680
   37068:	1887883a 	add	r3,r3,r2
   3706c:	e0bfff17 	ldw	r2,-4(fp)
   37070:	1880021e 	bne	r3,r2,3707c <alt_tse_get_system_index+0x3c>
            return i;
   37074:	e0bffe17 	ldw	r2,-8(fp)
   37078:	00000806 	br	3709c <alt_tse_get_system_index+0x5c>
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
   3707c:	e0bffe17 	ldw	r2,-8(fp)
   37080:	10800044 	addi	r2,r2,1
   37084:	e0bffe15 	stw	r2,-8(fp)
   37088:	d0a01c03 	ldbu	r2,-32656(gp)
   3708c:	10803fcc 	andi	r2,r2,255
   37090:	e0fffe17 	ldw	r3,-8(fp)
   37094:	18bff016 	blt	r3,r2,37058 <alt_tse_get_system_index+0x18>
        if(psys_info == &tse_mac_device[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
   37098:	00bfffc4 	movi	r2,-1
}
   3709c:	e037883a 	mov	sp,fp
   370a0:	df000017 	ldw	fp,0(sp)
   370a4:	dec00104 	addi	sp,sp,4
   370a8:	f800283a 	ret

000370ac <alt_tse_get_mac_group_index>:
/* @Function Description: Get the index of alt_tse_mac_group structure in pmac_groups[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_group structure
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
   370ac:	defffd04 	addi	sp,sp,-12
   370b0:	df000215 	stw	fp,8(sp)
   370b4:	df000204 	addi	fp,sp,8
   370b8:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   370bc:	e03ffe15 	stw	zero,-8(fp)
   370c0:	00000e06 	br	370fc <alt_tse_get_mac_group_index+0x50>
        if(pmac_group == pmac_groups[i]) {
   370c4:	00c001f4 	movhi	r3,7
   370c8:	18ed0b04 	addi	r3,r3,-19412
   370cc:	e0bffe17 	ldw	r2,-8(fp)
   370d0:	1085883a 	add	r2,r2,r2
   370d4:	1085883a 	add	r2,r2,r2
   370d8:	1885883a 	add	r2,r3,r2
   370dc:	10c00017 	ldw	r3,0(r2)
   370e0:	e0bfff17 	ldw	r2,-4(fp)
   370e4:	1880021e 	bne	r3,r2,370f0 <alt_tse_get_mac_group_index+0x44>
            return i;
   370e8:	e0bffe17 	ldw	r2,-8(fp)
   370ec:	00000806 	br	37110 <alt_tse_get_mac_group_index+0x64>
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
   370f0:	e0bffe17 	ldw	r2,-8(fp)
   370f4:	10800044 	addi	r2,r2,1
   370f8:	e0bffe15 	stw	r2,-8(fp)
   370fc:	d0a94743 	ldbu	r2,-23267(gp)
   37100:	10803fcc 	andi	r2,r2,255
   37104:	e0fffe17 	ldw	r3,-8(fp)
   37108:	18bfee16 	blt	r3,r2,370c4 <alt_tse_get_mac_group_index+0x18>
        if(pmac_group == pmac_groups[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
   3710c:	00bfffc4 	movi	r2,-1
}
   37110:	e037883a 	mov	sp,fp
   37114:	df000017 	ldw	fp,0(sp)
   37118:	dec00104 	addi	sp,sp,4
   3711c:	f800283a 	ret

00037120 <alt_tse_get_mac_info_index>:
/* @Function Description: Get the index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_info structure
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
   37120:	defffd04 	addi	sp,sp,-12
   37124:	df000215 	stw	fp,8(sp)
   37128:	df000204 	addi	fp,sp,8
   3712c:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   37130:	e03ffe15 	stw	zero,-8(fp)
   37134:	00000f06 	br	37174 <alt_tse_get_mac_info_index+0x54>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
   37138:	e0bfff17 	ldw	r2,-4(fp)
   3713c:	10c00317 	ldw	r3,12(r2)
   37140:	e0bffe17 	ldw	r2,-8(fp)
   37144:	10800044 	addi	r2,r2,1
   37148:	1085883a 	add	r2,r2,r2
   3714c:	1085883a 	add	r2,r2,r2
   37150:	1885883a 	add	r2,r3,r2
   37154:	10c00017 	ldw	r3,0(r2)
   37158:	e0bfff17 	ldw	r2,-4(fp)
   3715c:	1880021e 	bne	r3,r2,37168 <alt_tse_get_mac_info_index+0x48>
            return i;
   37160:	e0bffe17 	ldw	r2,-8(fp)
   37164:	00000a06 	br	37190 <alt_tse_get_mac_info_index+0x70>
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
   37168:	e0bffe17 	ldw	r2,-8(fp)
   3716c:	10800044 	addi	r2,r2,1
   37170:	e0bffe15 	stw	r2,-8(fp)
   37174:	e0bfff17 	ldw	r2,-4(fp)
   37178:	10800317 	ldw	r2,12(r2)
   3717c:	10800003 	ldbu	r2,0(r2)
   37180:	10803fcc 	andi	r2,r2,255
   37184:	e0fffe17 	ldw	r3,-8(fp)
   37188:	18bfeb16 	blt	r3,r2,37138 <alt_tse_get_mac_info_index+0x18>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
            return i;
        }
    }
    
    return ALTERA_TSE_NO_INDEX_FOUND;
   3718c:	00bfffc4 	movi	r2,-1
}
   37190:	e037883a 	mov	sp,fp
   37194:	df000017 	ldw	fp,0(sp)
   37198:	dec00104 	addi	sp,sp,4
   3719c:	f800283a 	ret

000371a0 <alt_tse_get_mac_info>:
/* @Function Description: Get the pointer of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac        Pointer to the TSE MAC Control Interface Base address
 * @return            Pointer to alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_tse_mac_info *alt_tse_get_mac_info(np_tse_mac *pmac) {
   371a0:	defffa04 	addi	sp,sp,-24
   371a4:	df000515 	stw	fp,20(sp)
   371a8:	df000504 	addi	fp,sp,20
   371ac:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
   371b0:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_mac_info *pmac_info = 0;
   371b4:	e03ffe15 	stw	zero,-8(fp)
    
    for(i = 0; i < mac_group_count; i++) {
   371b8:	e03ffb15 	stw	zero,-20(fp)
   371bc:	00002506 	br	37254 <alt_tse_get_mac_info+0xb4>
        pmac_group = pmac_groups[i];
   371c0:	00c001f4 	movhi	r3,7
   371c4:	18ed0b04 	addi	r3,r3,-19412
   371c8:	e0bffb17 	ldw	r2,-20(fp)
   371cc:	1085883a 	add	r2,r2,r2
   371d0:	1085883a 	add	r2,r2,r2
   371d4:	1885883a 	add	r2,r3,r2
   371d8:	10800017 	ldw	r2,0(r2)
   371dc:	e0bffd15 	stw	r2,-12(fp)
        for(j = 0; j < pmac_group->channel; j++) {
   371e0:	e03ffc15 	stw	zero,-16(fp)
   371e4:	00001306 	br	37234 <alt_tse_get_mac_info+0x94>
            pmac_info = pmac_group->pmac_info[j];
   371e8:	e0fffd17 	ldw	r3,-12(fp)
   371ec:	e0bffc17 	ldw	r2,-16(fp)
   371f0:	10800044 	addi	r2,r2,1
   371f4:	1085883a 	add	r2,r2,r2
   371f8:	1085883a 	add	r2,r2,r2
   371fc:	1885883a 	add	r2,r3,r2
   37200:	10800017 	ldw	r2,0(r2)
   37204:	e0bffe15 	stw	r2,-8(fp)
            if(((np_tse_mac *) pmac_info->psys_info->tse_mac_base) == pmac) {
   37208:	e0bffe17 	ldw	r2,-8(fp)
   3720c:	10800217 	ldw	r2,8(r2)
   37210:	10800017 	ldw	r2,0(r2)
   37214:	1007883a 	mov	r3,r2
   37218:	e0bfff17 	ldw	r2,-4(fp)
   3721c:	1880021e 	bne	r3,r2,37228 <alt_tse_get_mac_info+0x88>
                return pmac_info;
   37220:	e0bffe17 	ldw	r2,-8(fp)
   37224:	00001006 	br	37268 <alt_tse_get_mac_info+0xc8>
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
        pmac_group = pmac_groups[i];
        for(j = 0; j < pmac_group->channel; j++) {
   37228:	e0bffc17 	ldw	r2,-16(fp)
   3722c:	10800044 	addi	r2,r2,1
   37230:	e0bffc15 	stw	r2,-16(fp)
   37234:	e0bffd17 	ldw	r2,-12(fp)
   37238:	10800003 	ldbu	r2,0(r2)
   3723c:	10803fcc 	andi	r2,r2,255
   37240:	e0fffc17 	ldw	r3,-16(fp)
   37244:	18bfe816 	blt	r3,r2,371e8 <alt_tse_get_mac_info+0x48>
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
   37248:	e0bffb17 	ldw	r2,-20(fp)
   3724c:	10800044 	addi	r2,r2,1
   37250:	e0bffb15 	stw	r2,-20(fp)
   37254:	d0a94743 	ldbu	r2,-23267(gp)
   37258:	10803fcc 	andi	r2,r2,255
   3725c:	e0fffb17 	ldw	r3,-20(fp)
   37260:	18bfd716 	blt	r3,r2,371c0 <alt_tse_get_mac_info+0x20>
                return pmac_info;
            }
        }        
    }
    
    return 0;
   37264:	0005883a 	mov	r2,zero
}
   37268:	e037883a 	mov	sp,fp
   3726c:	df000017 	ldw	fp,0(sp)
   37270:	dec00104 	addi	sp,sp,4
   37274:	f800283a 	ret

00037278 <alt_tse_mac_set_speed>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param speed 2 = 1000 Mbps, 1 = 100 Mbps, 0 = 10 Mbps
 * @return ENP_PARAM if invalid speed specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_speed(np_tse_mac *pmac, alt_u8 speed)
{
   37278:	defffc04 	addi	sp,sp,-16
   3727c:	df000315 	stw	fp,12(sp)
   37280:	df000304 	addi	fp,sp,12
   37284:	e13ffe15 	stw	r4,-8(fp)
   37288:	2805883a 	mov	r2,r5
   3728c:	e0bfff05 	stb	r2,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
   37290:	e0bffe17 	ldw	r2,-8(fp)
   37294:	10800204 	addi	r2,r2,8
   37298:	10800037 	ldwio	r2,0(r2)
   3729c:	e0bffd15 	stw	r2,-12(fp)
  
  /* 1000 Mbps */
  if(speed == TSE_PHY_SPEED_1000) {
   372a0:	e0bfff03 	ldbu	r2,-4(fp)
   372a4:	10800098 	cmpnei	r2,r2,2
   372a8:	1000091e 	bne	r2,zero,372d0 <alt_tse_mac_set_speed+0x58>
    helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
   372ac:	e0bffd17 	ldw	r2,-12(fp)
   372b0:	10800214 	ori	r2,r2,8
   372b4:	e0bffd15 	stw	r2,-12(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
   372b8:	e0fffd17 	ldw	r3,-12(fp)
   372bc:	00bf8034 	movhi	r2,65024
   372c0:	10bfffc4 	addi	r2,r2,-1
   372c4:	1884703a 	and	r2,r3,r2
   372c8:	e0bffd15 	stw	r2,-12(fp)
   372cc:	00001906 	br	37334 <alt_tse_mac_set_speed+0xbc>
  }
  /* 100 Mbps */
  else if(speed == TSE_PHY_SPEED_100) {
   372d0:	e0bfff03 	ldbu	r2,-4(fp)
   372d4:	10800058 	cmpnei	r2,r2,1
   372d8:	10000a1e 	bne	r2,zero,37304 <alt_tse_mac_set_speed+0x8c>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
   372dc:	e0fffd17 	ldw	r3,-12(fp)
   372e0:	00bffdc4 	movi	r2,-9
   372e4:	1884703a 	and	r2,r3,r2
   372e8:	e0bffd15 	stw	r2,-12(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
   372ec:	e0fffd17 	ldw	r3,-12(fp)
   372f0:	00bf8034 	movhi	r2,65024
   372f4:	10bfffc4 	addi	r2,r2,-1
   372f8:	1884703a 	and	r2,r3,r2
   372fc:	e0bffd15 	stw	r2,-12(fp)
   37300:	00000c06 	br	37334 <alt_tse_mac_set_speed+0xbc>
  }
  /* 10 Mbps */
  else if(speed == TSE_PHY_SPEED_10) {
   37304:	e0bfff03 	ldbu	r2,-4(fp)
   37308:	1000081e 	bne	r2,zero,3732c <alt_tse_mac_set_speed+0xb4>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
   3730c:	e0fffd17 	ldw	r3,-12(fp)
   37310:	00bffdc4 	movi	r2,-9
   37314:	1884703a 	and	r2,r3,r2
   37318:	e0bffd15 	stw	r2,-12(fp)
	helpvar |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
   3731c:	e0bffd17 	ldw	r2,-12(fp)
   37320:	10808034 	orhi	r2,r2,512
   37324:	e0bffd15 	stw	r2,-12(fp)
   37328:	00000206 	br	37334 <alt_tse_mac_set_speed+0xbc>
  }  
  else {
    return ENP_PARAM;
   3732c:	00bffd84 	movi	r2,-10
   37330:	00000506 	br	37348 <alt_tse_mac_set_speed+0xd0>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
   37334:	e0bffe17 	ldw	r2,-8(fp)
   37338:	10800204 	addi	r2,r2,8
   3733c:	e0fffd17 	ldw	r3,-12(fp)
   37340:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
   37344:	0005883a 	mov	r2,zero
}
   37348:	e037883a 	mov	sp,fp
   3734c:	df000017 	ldw	fp,0(sp)
   37350:	dec00104 	addi	sp,sp,4
   37354:	f800283a 	ret

00037358 <alt_tse_mac_set_duplex>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param duplex 1 = Full Duplex, 0 = Half Duplex
 * @return ENP_PARAM if invalid duplex specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_duplex(np_tse_mac *pmac, alt_u8 duplex)
{
   37358:	defffc04 	addi	sp,sp,-16
   3735c:	df000315 	stw	fp,12(sp)
   37360:	df000304 	addi	fp,sp,12
   37364:	e13ffe15 	stw	r4,-8(fp)
   37368:	2805883a 	mov	r2,r5
   3736c:	e0bfff05 	stb	r2,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
   37370:	e0bffe17 	ldw	r2,-8(fp)
   37374:	10800204 	addi	r2,r2,8
   37378:	10800037 	ldwio	r2,0(r2)
   3737c:	e0bffd15 	stw	r2,-12(fp)
  
  /* Half Duplex */
  if(duplex == TSE_PHY_DUPLEX_HALF) {
   37380:	e0bfff03 	ldbu	r2,-4(fp)
   37384:	1000041e 	bne	r2,zero,37398 <alt_tse_mac_set_duplex+0x40>
    helpvar |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
   37388:	e0bffd17 	ldw	r2,-12(fp)
   3738c:	10810014 	ori	r2,r2,1024
   37390:	e0bffd15 	stw	r2,-12(fp)
   37394:	00000a06 	br	373c0 <alt_tse_mac_set_duplex+0x68>
  } 
  /* Full Duplex */
  else if(duplex == TSE_PHY_DUPLEX_FULL) {
   37398:	e0bfff03 	ldbu	r2,-4(fp)
   3739c:	10800058 	cmpnei	r2,r2,1
   373a0:	1000051e 	bne	r2,zero,373b8 <alt_tse_mac_set_duplex+0x60>
    helpvar &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
   373a4:	e0fffd17 	ldw	r3,-12(fp)
   373a8:	00beffc4 	movi	r2,-1025
   373ac:	1884703a 	and	r2,r3,r2
   373b0:	e0bffd15 	stw	r2,-12(fp)
   373b4:	00000206 	br	373c0 <alt_tse_mac_set_duplex+0x68>
  }
  else {
    return ENP_PARAM;
   373b8:	00bffd84 	movi	r2,-10
   373bc:	00000506 	br	373d4 <alt_tse_mac_set_duplex+0x7c>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
   373c0:	e0bffe17 	ldw	r2,-8(fp)
   373c4:	10800204 	addi	r2,r2,8
   373c8:	e0fffd17 	ldw	r3,-12(fp)
   373cc:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
   373d0:	0005883a 	mov	r2,zero

}
   373d4:	e037883a 	mov	sp,fp
   373d8:	df000017 	ldw	fp,0(sp)
   373dc:	dec00104 	addi	sp,sp,4
   373e0:	f800283a 	ret

000373e4 <getPHYSpeed>:
  	(((speed == TSE_PHY_SPEED_1000) ? 1 : 0) << 1) |   \
	(((speed == TSE_PHY_SPEED_100) ? 1 : 0) << 2) |     \
	(((speed == TSE_PHY_SPEED_10) ? 1 : 0) << 3) |      \
	((speed == TSE_PHY_SPEED_INVALID) ? ALT_TSE_E_INVALID_SPEED : 0))
  
alt_32 getPHYSpeed(np_tse_mac *pmac) {
   373e4:	defff404 	addi	sp,sp,-48
   373e8:	dfc00b15 	stw	ra,44(sp)
   373ec:	df000a15 	stw	fp,40(sp)
   373f0:	df000a04 	addi	fp,sp,40
   373f4:	e13fff15 	stw	r4,-4(fp)

	alt_u8 speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
   373f8:	00800044 	movi	r2,1
   373fc:	e0bff705 	stb	r2,-36(fp)
	alt_u8 duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;     /* 1 = full ; 0 = half*/
   37400:	00800044 	movi	r2,1
   37404:	e0bff745 	stb	r2,-35(fp)
	alt_32 result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
   37408:	e0bff743 	ldbu	r2,-35(fp)
   3740c:	10c0004c 	andi	r3,r2,1
   37410:	e0bff703 	ldbu	r2,-36(fp)
   37414:	10800098 	cmpnei	r2,r2,2
   37418:	1000021e 	bne	r2,zero,37424 <getPHYSpeed+0x40>
   3741c:	00800084 	movi	r2,2
   37420:	00000106 	br	37428 <getPHYSpeed+0x44>
   37424:	0005883a 	mov	r2,zero
   37428:	1886b03a 	or	r3,r3,r2
   3742c:	e0bff703 	ldbu	r2,-36(fp)
   37430:	10800058 	cmpnei	r2,r2,1
   37434:	1000021e 	bne	r2,zero,37440 <getPHYSpeed+0x5c>
   37438:	00800104 	movi	r2,4
   3743c:	00000106 	br	37444 <getPHYSpeed+0x60>
   37440:	0005883a 	mov	r2,zero
   37444:	1886b03a 	or	r3,r3,r2
   37448:	e0bff703 	ldbu	r2,-36(fp)
   3744c:	1000021e 	bne	r2,zero,37458 <getPHYSpeed+0x74>
   37450:	00800204 	movi	r2,8
   37454:	00000106 	br	3745c <getPHYSpeed+0x78>
   37458:	0005883a 	mov	r2,zero
   3745c:	1886b03a 	or	r3,r3,r2
   37460:	e0bff703 	ldbu	r2,-36(fp)
   37464:	108000d8 	cmpnei	r2,r2,3
   37468:	1000021e 	bne	r2,zero,37474 <getPHYSpeed+0x90>
   3746c:	00800074 	movhi	r2,1
   37470:	00000106 	br	37478 <getPHYSpeed+0x94>
   37474:	0005883a 	mov	r2,zero
   37478:	1884b03a 	or	r2,r3,r2
   3747c:	e0bff815 	stw	r2,-32(fp)
    
    alt_tse_phy_info *pphy = 0;
   37480:	e03ff915 	stw	zero,-28(fp)
    alt_tse_mac_info *pmac_info = 0;
   37484:	e03ffa15 	stw	zero,-24(fp)
    alt_tse_mac_group *pmac_group = 0;
   37488:	e03ffb15 	stw	zero,-20(fp)
    alt_tse_system_info *psys = 0;
   3748c:	e03ffc15 	stw	zero,-16(fp)
    
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
   37490:	e03ffd05 	stb	zero,-12(fp)
    alt_8 mac_group_index = 0;
   37494:	e03ffd45 	stb	zero,-11(fp)
    
    /* initialized PHYs only once */
    static alt_u8 is_init = 0;
    if(is_init == 0) {
   37498:	d0a94783 	ldbu	r2,-23266(gp)
   3749c:	10803fcc 	andi	r2,r2,255
   374a0:	1000031e 	bne	r2,zero,374b0 <getPHYSpeed+0xcc>
        alt_tse_phy_init();
   374a4:	00393a80 	call	393a8 <alt_tse_phy_init>
        is_init = 1;
   374a8:	00800044 	movi	r2,1
   374ac:	d0a94785 	stb	r2,-23266(gp)
    }
    
    /* Look for pmac_group and pmac_info structure based on pmac or iface */
    pmac_info = alt_tse_get_mac_info(pmac);
   374b0:	e13fff17 	ldw	r4,-4(fp)
   374b4:	00371a00 	call	371a0 <alt_tse_get_mac_info>
   374b8:	e0bffa15 	stw	r2,-24(fp)
    
    if(pmac_info == 0) {
   374bc:	e0bffa17 	ldw	r2,-24(fp)
   374c0:	1000491e 	bne	r2,zero,375e8 <getPHYSpeed+0x204>
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
   374c4:	00800044 	movi	r2,1
   374c8:	e0bff705 	stb	r2,-36(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
   374cc:	00800044 	movi	r2,1
   374d0:	e0bff745 	stb	r2,-35(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PMAC_FOUND;
   374d4:	e0bff743 	ldbu	r2,-35(fp)
   374d8:	10c0004c 	andi	r3,r2,1
   374dc:	e0bff703 	ldbu	r2,-36(fp)
   374e0:	10800098 	cmpnei	r2,r2,2
   374e4:	1000021e 	bne	r2,zero,374f0 <getPHYSpeed+0x10c>
   374e8:	00800084 	movi	r2,2
   374ec:	00000106 	br	374f4 <getPHYSpeed+0x110>
   374f0:	0005883a 	mov	r2,zero
   374f4:	1886b03a 	or	r3,r3,r2
   374f8:	e0bff703 	ldbu	r2,-36(fp)
   374fc:	10800058 	cmpnei	r2,r2,1
   37500:	1000021e 	bne	r2,zero,3750c <getPHYSpeed+0x128>
   37504:	00800104 	movi	r2,4
   37508:	00000106 	br	37510 <getPHYSpeed+0x12c>
   3750c:	0005883a 	mov	r2,zero
   37510:	1886b03a 	or	r3,r3,r2
   37514:	e0bff703 	ldbu	r2,-36(fp)
   37518:	1000021e 	bne	r2,zero,37524 <getPHYSpeed+0x140>
   3751c:	00800204 	movi	r2,8
   37520:	00000106 	br	37528 <getPHYSpeed+0x144>
   37524:	0005883a 	mov	r2,zero
   37528:	1886b03a 	or	r3,r3,r2
   3752c:	e0bff703 	ldbu	r2,-36(fp)
   37530:	108000d8 	cmpnei	r2,r2,3
   37534:	1000021e 	bne	r2,zero,37540 <getPHYSpeed+0x15c>
   37538:	00800074 	movhi	r2,1
   3753c:	00000106 	br	37544 <getPHYSpeed+0x160>
   37540:	0005883a 	mov	r2,zero
   37544:	1884b03a 	or	r2,r3,r2
   37548:	10802034 	orhi	r2,r2,128
   3754c:	e0bff815 	stw	r2,-32(fp)
        tse_dprintf(2, "ERROR   : [getPHYSpeed] pmac not found from list of pmac_info[]! Speed = %s Mbps, Duplex = %s\n", speed == TSE_PHY_SPEED_1000 ? "1000" :
   37550:	e0bff703 	ldbu	r2,-36(fp)
   37554:	108000a0 	cmpeqi	r2,r2,2
   37558:	10000f1e 	bne	r2,zero,37598 <getPHYSpeed+0x1b4>
   3755c:	e0bff703 	ldbu	r2,-36(fp)
   37560:	10800060 	cmpeqi	r2,r2,1
   37564:	1000081e 	bne	r2,zero,37588 <getPHYSpeed+0x1a4>
   37568:	e0bff703 	ldbu	r2,-36(fp)
   3756c:	1000031e 	bne	r2,zero,3757c <getPHYSpeed+0x198>
   37570:	00800134 	movhi	r2,4
   37574:	1086ad04 	addi	r2,r2,6836
   37578:	00000206 	br	37584 <getPHYSpeed+0x1a0>
   3757c:	00800134 	movhi	r2,4
   37580:	1086ae04 	addi	r2,r2,6840
   37584:	00000206 	br	37590 <getPHYSpeed+0x1ac>
   37588:	00800134 	movhi	r2,4
   3758c:	1086b004 	addi	r2,r2,6848
   37590:	1007883a 	mov	r3,r2
   37594:	00000206 	br	375a0 <getPHYSpeed+0x1bc>
   37598:	00c00134 	movhi	r3,4
   3759c:	18c6b104 	addi	r3,r3,6852
   375a0:	e0bff743 	ldbu	r2,-35(fp)
   375a4:	10800058 	cmpnei	r2,r2,1
   375a8:	1000031e 	bne	r2,zero,375b8 <getPHYSpeed+0x1d4>
   375ac:	00800134 	movhi	r2,4
   375b0:	1086b304 	addi	r2,r2,6860
   375b4:	00000206 	br	375c0 <getPHYSpeed+0x1dc>
   375b8:	00800134 	movhi	r2,4
   375bc:	1086b504 	addi	r2,r2,6868
   375c0:	01000134 	movhi	r4,4
   375c4:	2106b704 	addi	r4,r4,6876
   375c8:	180b883a 	mov	r5,r3
   375cc:	100d883a 	mov	r6,r2
   375d0:	00044740 	call	4474 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        tse_dprintf(2, "ERROR   : [getPHYSpeed] Please define tse_mac_device[] correctly\n");
   375d4:	01000134 	movhi	r4,4
   375d8:	2106cf04 	addi	r4,r4,6972
   375dc:	00045340 	call	4534 <puts>
        return result;
   375e0:	e0bff817 	ldw	r2,-32(fp)
   375e4:	00021406 	br	37e38 <getPHYSpeed+0xa54>
    }
    
    pphy = pmac_info->pphy_info;
   375e8:	e0bffa17 	ldw	r2,-24(fp)
   375ec:	10800117 	ldw	r2,4(r2)
   375f0:	e0bff915 	stw	r2,-28(fp)
    pmac_group = pmac_info->pmac_group;
   375f4:	e0bffa17 	ldw	r2,-24(fp)
   375f8:	10800317 	ldw	r2,12(r2)
   375fc:	e0bffb15 	stw	r2,-20(fp)
    psys = pmac_info->psys_info;
   37600:	e0bffa17 	ldw	r2,-24(fp)
   37604:	10800217 	ldw	r2,8(r2)
   37608:	e0bffc15 	stw	r2,-16(fp)
    
    mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   3760c:	e13ffa17 	ldw	r4,-24(fp)
   37610:	00371200 	call	37120 <alt_tse_get_mac_info_index>
   37614:	e0bffd05 	stb	r2,-12(fp)
    mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   37618:	e13ffb17 	ldw	r4,-20(fp)
   3761c:	00370ac0 	call	370ac <alt_tse_get_mac_group_index>
   37620:	e0bffd45 	stb	r2,-11(fp)
         
    /* MDIO is not used */
    if (pmac_group->pmac_info[0]->psys_info->tse_use_mdio == 0)
   37624:	e0bffb17 	ldw	r2,-20(fp)
   37628:	10800117 	ldw	r2,4(r2)
   3762c:	10800217 	ldw	r2,8(r2)
   37630:	10800203 	ldbu	r2,8(r2)
   37634:	10803fcc 	andi	r2,r2,255
   37638:	10005a1e 	bne	r2,zero,377a4 <getPHYSpeed+0x3c0>
    {
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
   3763c:	00800044 	movi	r2,1
   37640:	e0bff705 	stb	r2,-36(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
   37644:	00800044 	movi	r2,1
   37648:	e0bff745 	stb	r2,-35(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_MDIO;
   3764c:	e0bff743 	ldbu	r2,-35(fp)
   37650:	10c0004c 	andi	r3,r2,1
   37654:	e0bff703 	ldbu	r2,-36(fp)
   37658:	10800098 	cmpnei	r2,r2,2
   3765c:	1000021e 	bne	r2,zero,37668 <getPHYSpeed+0x284>
   37660:	00800084 	movi	r2,2
   37664:	00000106 	br	3766c <getPHYSpeed+0x288>
   37668:	0005883a 	mov	r2,zero
   3766c:	1886b03a 	or	r3,r3,r2
   37670:	e0bff703 	ldbu	r2,-36(fp)
   37674:	10800058 	cmpnei	r2,r2,1
   37678:	1000021e 	bne	r2,zero,37684 <getPHYSpeed+0x2a0>
   3767c:	00800104 	movi	r2,4
   37680:	00000106 	br	37688 <getPHYSpeed+0x2a4>
   37684:	0005883a 	mov	r2,zero
   37688:	1886b03a 	or	r3,r3,r2
   3768c:	e0bff703 	ldbu	r2,-36(fp)
   37690:	1000021e 	bne	r2,zero,3769c <getPHYSpeed+0x2b8>
   37694:	00800204 	movi	r2,8
   37698:	00000106 	br	376a0 <getPHYSpeed+0x2bc>
   3769c:	0005883a 	mov	r2,zero
   376a0:	1886b03a 	or	r3,r3,r2
   376a4:	e0bff703 	ldbu	r2,-36(fp)
   376a8:	108000d8 	cmpnei	r2,r2,3
   376ac:	1000021e 	bne	r2,zero,376b8 <getPHYSpeed+0x2d4>
   376b0:	00800074 	movhi	r2,1
   376b4:	00000106 	br	376bc <getPHYSpeed+0x2d8>
   376b8:	0005883a 	mov	r2,zero
   376bc:	1884b03a 	or	r2,r3,r2
   376c0:	10801034 	orhi	r2,r2,64
   376c4:	e0bff815 	stw	r2,-32(fp)
        usleep(ALTERA_NOMDIO_TIMEOUT_THRESHOLD);
   376c8:	010003f4 	movhi	r4,15
   376cc:	21109004 	addi	r4,r4,16960
   376d0:	00124300 	call	12430 <usleep>
        if(psys->tse_phy_cfg) {
   376d4:	e0bffc17 	ldw	r2,-16(fp)
   376d8:	10801117 	ldw	r2,68(r2)
   376dc:	10000d26 	beq	r2,zero,37714 <getPHYSpeed+0x330>
        	tse_dprintf(4, "WARNING : PHY[%d.%d] - MDIO not enabled! Running user configuration...\n", mac_group_index, mac_info_index);
   376e0:	e0fffd47 	ldb	r3,-11(fp)
   376e4:	e0bffd07 	ldb	r2,-12(fp)
   376e8:	01000134 	movhi	r4,4
   376ec:	2106e004 	addi	r4,r4,7040
   376f0:	180b883a 	mov	r5,r3
   376f4:	100d883a 	mov	r6,r2
   376f8:	00044740 	call	4474 <printf>
        	result = psys->tse_phy_cfg(pmac);
   376fc:	e0bffc17 	ldw	r2,-16(fp)
   37700:	10801117 	ldw	r2,68(r2)
   37704:	e13fff17 	ldw	r4,-4(fp)
   37708:	103ee83a 	callr	r2
   3770c:	e0bff815 	stw	r2,-32(fp)
   37710:	00002206 	br	3779c <getPHYSpeed+0x3b8>
        }
        else {
        	tse_dprintf(4, "WARNING : MAC Group[%d] - MDIO not enabled! Speed = %s, Duplex = %s\n", mac_group_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
   37714:	e17ffd47 	ldb	r5,-11(fp)
   37718:	e0bff703 	ldbu	r2,-36(fp)
   3771c:	108000a0 	cmpeqi	r2,r2,2
   37720:	10000f1e 	bne	r2,zero,37760 <getPHYSpeed+0x37c>
   37724:	e0bff703 	ldbu	r2,-36(fp)
   37728:	10800060 	cmpeqi	r2,r2,1
   3772c:	1000081e 	bne	r2,zero,37750 <getPHYSpeed+0x36c>
   37730:	e0bff703 	ldbu	r2,-36(fp)
   37734:	1000031e 	bne	r2,zero,37744 <getPHYSpeed+0x360>
   37738:	00800134 	movhi	r2,4
   3773c:	1086ad04 	addi	r2,r2,6836
   37740:	00000206 	br	3774c <getPHYSpeed+0x368>
   37744:	00800134 	movhi	r2,4
   37748:	1086ae04 	addi	r2,r2,6840
   3774c:	00000206 	br	37758 <getPHYSpeed+0x374>
   37750:	00800134 	movhi	r2,4
   37754:	1086b004 	addi	r2,r2,6848
   37758:	1007883a 	mov	r3,r2
   3775c:	00000206 	br	37768 <getPHYSpeed+0x384>
   37760:	00c00134 	movhi	r3,4
   37764:	18c6b104 	addi	r3,r3,6852
   37768:	e0bff743 	ldbu	r2,-35(fp)
   3776c:	10800058 	cmpnei	r2,r2,1
   37770:	1000031e 	bne	r2,zero,37780 <getPHYSpeed+0x39c>
   37774:	00800134 	movhi	r2,4
   37778:	1086b304 	addi	r2,r2,6860
   3777c:	00000206 	br	37788 <getPHYSpeed+0x3a4>
   37780:	00800134 	movhi	r2,4
   37784:	1086b504 	addi	r2,r2,6868
   37788:	01000134 	movhi	r4,4
   3778c:	2106f204 	addi	r4,r4,7112
   37790:	180d883a 	mov	r6,r3
   37794:	100f883a 	mov	r7,r2
   37798:	00044740 	call	4474 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        }
        return result;
   3779c:	e0bff817 	ldw	r2,-32(fp)
   377a0:	0001a506 	br	37e38 <getPHYSpeed+0xa54>

    /* Not running simulation */
    #ifndef ALT_SIM_OPTIMIZE
	
		/* These variables declaration are here to avoid "warning: unused variable" message when compile for simulation */
		np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   377a4:	e0bffb17 	ldw	r2,-20(fp)
   377a8:	10800117 	ldw	r2,4(r2)
   377ac:	10800217 	ldw	r2,8(r2)
   377b0:	10800017 	ldw	r2,0(r2)
   377b4:	e0bffe15 	stw	r2,-8(fp)
    
        /* if no PHY connected to the MAC */
        if(pphy == 0) {
   377b8:	e0bff917 	ldw	r2,-28(fp)
   377bc:	1000471e 	bne	r2,zero,378dc <getPHYSpeed+0x4f8>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
   377c0:	00800044 	movi	r2,1
   377c4:	e0bff705 	stb	r2,-36(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
   377c8:	00800044 	movi	r2,1
   377cc:	e0bff745 	stb	r2,-35(fp)
            result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY;
   377d0:	e0bff743 	ldbu	r2,-35(fp)
   377d4:	10c0004c 	andi	r3,r2,1
   377d8:	e0bff703 	ldbu	r2,-36(fp)
   377dc:	10800098 	cmpnei	r2,r2,2
   377e0:	1000021e 	bne	r2,zero,377ec <getPHYSpeed+0x408>
   377e4:	00800084 	movi	r2,2
   377e8:	00000106 	br	377f0 <getPHYSpeed+0x40c>
   377ec:	0005883a 	mov	r2,zero
   377f0:	1886b03a 	or	r3,r3,r2
   377f4:	e0bff703 	ldbu	r2,-36(fp)
   377f8:	10800058 	cmpnei	r2,r2,1
   377fc:	1000021e 	bne	r2,zero,37808 <getPHYSpeed+0x424>
   37800:	00800104 	movi	r2,4
   37804:	00000106 	br	3780c <getPHYSpeed+0x428>
   37808:	0005883a 	mov	r2,zero
   3780c:	1886b03a 	or	r3,r3,r2
   37810:	e0bff703 	ldbu	r2,-36(fp)
   37814:	1000021e 	bne	r2,zero,37820 <getPHYSpeed+0x43c>
   37818:	00800204 	movi	r2,8
   3781c:	00000106 	br	37824 <getPHYSpeed+0x440>
   37820:	0005883a 	mov	r2,zero
   37824:	1886b03a 	or	r3,r3,r2
   37828:	e0bff703 	ldbu	r2,-36(fp)
   3782c:	108000d8 	cmpnei	r2,r2,3
   37830:	1000021e 	bne	r2,zero,3783c <getPHYSpeed+0x458>
   37834:	00800074 	movhi	r2,1
   37838:	00000106 	br	37840 <getPHYSpeed+0x45c>
   3783c:	0005883a 	mov	r2,zero
   37840:	1884b03a 	or	r2,r3,r2
   37844:	10800834 	orhi	r2,r2,32
   37848:	e0bff815 	stw	r2,-32(fp)
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - No PHY connected! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
   3784c:	e17ffd47 	ldb	r5,-11(fp)
   37850:	e1bffd07 	ldb	r6,-12(fp)
   37854:	e0bff703 	ldbu	r2,-36(fp)
   37858:	108000a0 	cmpeqi	r2,r2,2
   3785c:	10000e1e 	bne	r2,zero,37898 <getPHYSpeed+0x4b4>
   37860:	e0bff703 	ldbu	r2,-36(fp)
   37864:	10800060 	cmpeqi	r2,r2,1
   37868:	1000081e 	bne	r2,zero,3788c <getPHYSpeed+0x4a8>
   3786c:	e0bff703 	ldbu	r2,-36(fp)
   37870:	1000031e 	bne	r2,zero,37880 <getPHYSpeed+0x49c>
   37874:	00800134 	movhi	r2,4
   37878:	1086ad04 	addi	r2,r2,6836
   3787c:	00000206 	br	37888 <getPHYSpeed+0x4a4>
   37880:	00800134 	movhi	r2,4
   37884:	1086ae04 	addi	r2,r2,6840
   37888:	00000206 	br	37894 <getPHYSpeed+0x4b0>
   3788c:	00800134 	movhi	r2,4
   37890:	1086b004 	addi	r2,r2,6848
   37894:	00000206 	br	378a0 <getPHYSpeed+0x4bc>
   37898:	00800134 	movhi	r2,4
   3789c:	1086b104 	addi	r2,r2,6852
   378a0:	e0fff743 	ldbu	r3,-35(fp)
   378a4:	18c00058 	cmpnei	r3,r3,1
   378a8:	1800031e 	bne	r3,zero,378b8 <getPHYSpeed+0x4d4>
   378ac:	00c00134 	movhi	r3,4
   378b0:	18c6b304 	addi	r3,r3,6860
   378b4:	00000206 	br	378c0 <getPHYSpeed+0x4dc>
   378b8:	00c00134 	movhi	r3,4
   378bc:	18c6b504 	addi	r3,r3,6868
   378c0:	d8c00015 	stw	r3,0(sp)
   378c4:	01000134 	movhi	r4,4
   378c8:	21070404 	addi	r4,r4,7184
   378cc:	100f883a 	mov	r7,r2
   378d0:	00044740 	call	4474 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
            return result;
   378d4:	e0bff817 	ldw	r2,-32(fp)
   378d8:	00015706 	br	37e38 <getPHYSpeed+0xa54>
        }

		/* Small MAC */
		if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
   378dc:	e0bffa17 	ldw	r2,-24(fp)
   378e0:	10800003 	ldbu	r2,0(r2)
   378e4:	10803fcc 	andi	r2,r2,255
   378e8:	10800058 	cmpnei	r2,r2,1
   378ec:	1000071e 	bne	r2,zero,3790c <getPHYSpeed+0x528>
			alt_tse_phy_set_adv_1000(pphy, 0);
   378f0:	e13ff917 	ldw	r4,-28(fp)
   378f4:	000b883a 	mov	r5,zero
   378f8:	0039d780 	call	39d78 <alt_tse_phy_set_adv_1000>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
   378fc:	e13ff917 	ldw	r4,-28(fp)
   37900:	015d4c04 	movi	r5,30000
   37904:	00394c00 	call	394c0 <alt_tse_phy_restart_an>
   37908:	00000e06 	br	37944 <getPHYSpeed+0x560>
		}
		else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
   3790c:	e0bffa17 	ldw	r2,-24(fp)
   37910:	10800003 	ldbu	r2,0(r2)
   37914:	10803fcc 	andi	r2,r2,255
   37918:	10800098 	cmpnei	r2,r2,2
   3791c:	1000091e 	bne	r2,zero,37944 <getPHYSpeed+0x560>
			alt_tse_phy_set_adv_100(pphy, 0);
   37920:	e13ff917 	ldw	r4,-28(fp)
   37924:	000b883a 	mov	r5,zero
   37928:	0039f340 	call	39f34 <alt_tse_phy_set_adv_100>
			alt_tse_phy_set_adv_10(pphy, 0);
   3792c:	e13ff917 	ldw	r4,-28(fp)
   37930:	000b883a 	mov	r5,zero
   37934:	003a17c0 	call	3a17c <alt_tse_phy_set_adv_10>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
   37938:	e13ff917 	ldw	r4,-28(fp)
   3793c:	015d4c04 	movi	r5,30000
   37940:	00394c00 	call	394c0 <alt_tse_phy_restart_an>
		}
		
		/* check link connection for this PHY */
		if(alt_tse_phy_check_link(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD) == TSE_PHY_AN_NOT_COMPLETE) {
   37944:	e13ff917 	ldw	r4,-28(fp)
   37948:	015d4c04 	movi	r5,30000
   3794c:	00396840 	call	39684 <alt_tse_phy_check_link>
   37950:	10bfffd8 	cmpnei	r2,r2,-1
   37954:	1000471e 	bne	r2,zero,37a74 <getPHYSpeed+0x690>
			speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
   37958:	00800044 	movi	r2,1
   3795c:	e0bff705 	stb	r2,-36(fp)
			duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
   37960:	00800044 	movi	r2,1
   37964:	e0bff745 	stb	r2,-35(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_AN_NOT_COMPLETE;
   37968:	e0bff743 	ldbu	r2,-35(fp)
   3796c:	10c0004c 	andi	r3,r2,1
   37970:	e0bff703 	ldbu	r2,-36(fp)
   37974:	10800098 	cmpnei	r2,r2,2
   37978:	1000021e 	bne	r2,zero,37984 <getPHYSpeed+0x5a0>
   3797c:	00800084 	movi	r2,2
   37980:	00000106 	br	37988 <getPHYSpeed+0x5a4>
   37984:	0005883a 	mov	r2,zero
   37988:	1886b03a 	or	r3,r3,r2
   3798c:	e0bff703 	ldbu	r2,-36(fp)
   37990:	10800058 	cmpnei	r2,r2,1
   37994:	1000021e 	bne	r2,zero,379a0 <getPHYSpeed+0x5bc>
   37998:	00800104 	movi	r2,4
   3799c:	00000106 	br	379a4 <getPHYSpeed+0x5c0>
   379a0:	0005883a 	mov	r2,zero
   379a4:	1886b03a 	or	r3,r3,r2
   379a8:	e0bff703 	ldbu	r2,-36(fp)
   379ac:	1000021e 	bne	r2,zero,379b8 <getPHYSpeed+0x5d4>
   379b0:	00800204 	movi	r2,8
   379b4:	00000106 	br	379bc <getPHYSpeed+0x5d8>
   379b8:	0005883a 	mov	r2,zero
   379bc:	1886b03a 	or	r3,r3,r2
   379c0:	e0bff703 	ldbu	r2,-36(fp)
   379c4:	108000d8 	cmpnei	r2,r2,3
   379c8:	1000021e 	bne	r2,zero,379d4 <getPHYSpeed+0x5f0>
   379cc:	00800074 	movhi	r2,1
   379d0:	00000106 	br	379d8 <getPHYSpeed+0x5f4>
   379d4:	0005883a 	mov	r2,zero
   379d8:	1884b03a 	or	r2,r3,r2
   379dc:	10800234 	orhi	r2,r2,8
   379e0:	e0bff815 	stw	r2,-32(fp)
			tse_dprintf(3, "WARNING : PHY[%d.%d] - Auto-Negotiation not completed! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
   379e4:	e17ffd47 	ldb	r5,-11(fp)
   379e8:	e1bffd07 	ldb	r6,-12(fp)
   379ec:	e0bff703 	ldbu	r2,-36(fp)
   379f0:	108000a0 	cmpeqi	r2,r2,2
   379f4:	10000e1e 	bne	r2,zero,37a30 <getPHYSpeed+0x64c>
   379f8:	e0bff703 	ldbu	r2,-36(fp)
   379fc:	10800060 	cmpeqi	r2,r2,1
   37a00:	1000081e 	bne	r2,zero,37a24 <getPHYSpeed+0x640>
   37a04:	e0bff703 	ldbu	r2,-36(fp)
   37a08:	1000031e 	bne	r2,zero,37a18 <getPHYSpeed+0x634>
   37a0c:	00800134 	movhi	r2,4
   37a10:	1086ad04 	addi	r2,r2,6836
   37a14:	00000206 	br	37a20 <getPHYSpeed+0x63c>
   37a18:	00800134 	movhi	r2,4
   37a1c:	1086ae04 	addi	r2,r2,6840
   37a20:	00000206 	br	37a2c <getPHYSpeed+0x648>
   37a24:	00800134 	movhi	r2,4
   37a28:	1086b004 	addi	r2,r2,6848
   37a2c:	00000206 	br	37a38 <getPHYSpeed+0x654>
   37a30:	00800134 	movhi	r2,4
   37a34:	1086b104 	addi	r2,r2,6852
   37a38:	e0fff743 	ldbu	r3,-35(fp)
   37a3c:	18c00058 	cmpnei	r3,r3,1
   37a40:	1800031e 	bne	r3,zero,37a50 <getPHYSpeed+0x66c>
   37a44:	00c00134 	movhi	r3,4
   37a48:	18c6b304 	addi	r3,r3,6860
   37a4c:	00000206 	br	37a58 <getPHYSpeed+0x674>
   37a50:	00c00134 	movhi	r3,4
   37a54:	18c6b504 	addi	r3,r3,6868
   37a58:	d8c00015 	stw	r3,0(sp)
   37a5c:	01000134 	movhi	r4,4
   37a60:	21071504 	addi	r4,r4,7252
   37a64:	100f883a 	mov	r7,r2
   37a68:	00044740 	call	4474 <printf>
																			 speed == TSE_PHY_SPEED_100 ? "100" :
																			 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
																			 duplex == 1 ? "Full" : "Half");
			return result;
   37a6c:	e0bff817 	ldw	r2,-32(fp)
   37a70:	0000f106 	br	37e38 <getPHYSpeed+0xa54>
		}

        IOWR(&pmac_group_base->MDIO_ADDR1, 0, pphy->mdio_address);
   37a74:	e0bffe17 	ldw	r2,-8(fp)
   37a78:	10801004 	addi	r2,r2,64
   37a7c:	e0fff917 	ldw	r3,-28(fp)
   37a80:	18c00003 	ldbu	r3,0(r3)
   37a84:	18c03fcc 	andi	r3,r3,255
   37a88:	10c00035 	stwio	r3,0(r2)
        /* To enable PHY loopback */
        #if ENABLE_PHY_LOOPBACK
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Putting PHY in loopback\n", mac_group_index, mac_info_index);
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 1);   // enable PHY loopback
		#else
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
   37a8c:	d8000015 	stw	zero,0(sp)
   37a90:	e13ff917 	ldw	r4,-28(fp)
   37a94:	000b883a 	mov	r5,zero
   37a98:	01800384 	movi	r6,14
   37a9c:	01c00044 	movi	r7,1
   37aa0:	0037eec0 	call	37eec <alt_tse_phy_wr_mdio_reg>
        #endif
       
        /* if PHY not found in profile */
        if(pphy->pphy_profile == 0) {
   37aa4:	e0bff917 	ldw	r2,-28(fp)
   37aa8:	10800517 	ldw	r2,20(r2)
   37aac:	10002b1e 	bne	r2,zero,37b5c <getPHYSpeed+0x778>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not found in PHY profile\n", mac_group_index, mac_info_index);
   37ab0:	e0fffd47 	ldb	r3,-11(fp)
   37ab4:	e0bffd07 	ldb	r2,-12(fp)
   37ab8:	01000134 	movhi	r4,4
   37abc:	21072904 	addi	r4,r4,7332
   37ac0:	180b883a 	mov	r5,r3
   37ac4:	100d883a 	mov	r6,r2
   37ac8:	00044740 	call	4474 <printf>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
   37acc:	00800044 	movi	r2,1
   37ad0:	e0bff705 	stb	r2,-36(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
   37ad4:	00800044 	movi	r2,1
   37ad8:	e0bff745 	stb	r2,-35(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY_PROFILE;
   37adc:	e0bff743 	ldbu	r2,-35(fp)
   37ae0:	10c0004c 	andi	r3,r2,1
   37ae4:	e0bff703 	ldbu	r2,-36(fp)
   37ae8:	10800098 	cmpnei	r2,r2,2
   37aec:	1000021e 	bne	r2,zero,37af8 <getPHYSpeed+0x714>
   37af0:	00800084 	movi	r2,2
   37af4:	00000106 	br	37afc <getPHYSpeed+0x718>
   37af8:	0005883a 	mov	r2,zero
   37afc:	1886b03a 	or	r3,r3,r2
   37b00:	e0bff703 	ldbu	r2,-36(fp)
   37b04:	10800058 	cmpnei	r2,r2,1
   37b08:	1000021e 	bne	r2,zero,37b14 <getPHYSpeed+0x730>
   37b0c:	00800104 	movi	r2,4
   37b10:	00000106 	br	37b18 <getPHYSpeed+0x734>
   37b14:	0005883a 	mov	r2,zero
   37b18:	1886b03a 	or	r3,r3,r2
   37b1c:	e0bff703 	ldbu	r2,-36(fp)
   37b20:	1000021e 	bne	r2,zero,37b2c <getPHYSpeed+0x748>
   37b24:	00800204 	movi	r2,8
   37b28:	00000106 	br	37b30 <getPHYSpeed+0x74c>
   37b2c:	0005883a 	mov	r2,zero
   37b30:	1886b03a 	or	r3,r3,r2
   37b34:	e0bff703 	ldbu	r2,-36(fp)
   37b38:	108000d8 	cmpnei	r2,r2,3
   37b3c:	1000021e 	bne	r2,zero,37b48 <getPHYSpeed+0x764>
   37b40:	00800074 	movhi	r2,1
   37b44:	00000106 	br	37b4c <getPHYSpeed+0x768>
   37b48:	0005883a 	mov	r2,zero
   37b4c:	1884b03a 	or	r2,r3,r2
   37b50:	10800134 	orhi	r2,r2,4
   37b54:	e0bff815 	stw	r2,-32(fp)
   37b58:	00009406 	br	37dac <getPHYSpeed+0x9c8>
        }
        // retrieve duplex information from PHY
		else
		{
			if(pphy->pphy_profile->link_status_read)
   37b5c:	e0bff917 	ldw	r2,-28(fp)
   37b60:	10800517 	ldw	r2,20(r2)
   37b64:	10801817 	ldw	r2,96(r2)
   37b68:	10002626 	beq	r2,zero,37c04 <getPHYSpeed+0x820>
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
   37b6c:	e0bff917 	ldw	r2,-28(fp)
   37b70:	10800517 	ldw	r2,20(r2)
   37b74:	10801817 	ldw	r2,96(r2)
   37b78:	e13ffe17 	ldw	r4,-8(fp)
   37b7c:	103ee83a 	callr	r2
   37b80:	e0bff815 	stw	r2,-32(fp)
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
   37b84:	e0bff817 	ldw	r2,-32(fp)
   37b88:	1080008c 	andi	r2,r2,2
   37b8c:	10000c1e 	bne	r2,zero,37bc0 <getPHYSpeed+0x7dc>
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
   37b90:	e0bff817 	ldw	r2,-32(fp)
   37b94:	1080010c 	andi	r2,r2,4
		else
		{
			if(pphy->pphy_profile->link_status_read)
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
   37b98:	1000071e 	bne	r2,zero,37bb8 <getPHYSpeed+0x7d4>
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
   37b9c:	e0bff817 	ldw	r2,-32(fp)
   37ba0:	1080020c 	andi	r2,r2,8
		else
		{
			if(pphy->pphy_profile->link_status_read)
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
   37ba4:	10000226 	beq	r2,zero,37bb0 <getPHYSpeed+0x7cc>
   37ba8:	0005883a 	mov	r2,zero
   37bac:	00000106 	br	37bb4 <getPHYSpeed+0x7d0>
   37bb0:	008000c4 	movi	r2,3
   37bb4:	00000106 	br	37bbc <getPHYSpeed+0x7d8>
   37bb8:	00800044 	movi	r2,1
   37bbc:	00000106 	br	37bc4 <getPHYSpeed+0x7e0>
   37bc0:	00800084 	movi	r2,2
   37bc4:	e0bff705 	stb	r2,-36(fp)
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
				duplex = (result & 0x01) ? TSE_PHY_DUPLEX_FULL : TSE_PHY_DUPLEX_HALF;
   37bc8:	e0bff817 	ldw	r2,-32(fp)
   37bcc:	1080004c 	andi	r2,r2,1
   37bd0:	1004c03a 	cmpne	r2,r2,zero
   37bd4:	e0bff745 	stb	r2,-35(fp)
				
				if(result & ALT_TSE_E_INVALID_SPEED)
   37bd8:	e0bff817 	ldw	r2,-32(fp)
   37bdc:	1080006c 	andhi	r2,r2,1
   37be0:	10007226 	beq	r2,zero,37dac <getPHYSpeed+0x9c8>
				{
					tse_dprintf(3, "WARNING : PHY[%d.%d] - Invalid speed read from PHY\n", mac_group_index, mac_info_index);
   37be4:	e0fffd47 	ldb	r3,-11(fp)
   37be8:	e0bffd07 	ldb	r2,-12(fp)
   37bec:	01000134 	movhi	r4,4
   37bf0:	21073704 	addi	r4,r4,7388
   37bf4:	180b883a 	mov	r5,r3
   37bf8:	100d883a 	mov	r6,r2
   37bfc:	00044740 	call	4474 <printf>
   37c00:	00006a06 	br	37dac <getPHYSpeed+0x9c8>
				}
			}
			else if(pphy->pphy_profile->status_reg_location == 0)
   37c04:	e0bff917 	ldw	r2,-28(fp)
   37c08:	10800517 	ldw	r2,20(r2)
   37c0c:	10801583 	ldbu	r2,86(r2)
   37c10:	10803fcc 	andi	r2,r2,255
   37c14:	10002b1e 	bne	r2,zero,37cc4 <getPHYSpeed+0x8e0>
	        {
	            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY Specific Status register information not provided in profile\n", mac_group_index, mac_info_index);
   37c18:	e0fffd47 	ldb	r3,-11(fp)
   37c1c:	e0bffd07 	ldb	r2,-12(fp)
   37c20:	01000134 	movhi	r4,4
   37c24:	21074404 	addi	r4,r4,7440
   37c28:	180b883a 	mov	r5,r3
   37c2c:	100d883a 	mov	r6,r2
   37c30:	00044740 	call	4474 <printf>
	            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
   37c34:	00800044 	movi	r2,1
   37c38:	e0bff705 	stb	r2,-36(fp)
	            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
   37c3c:	00800044 	movi	r2,1
   37c40:	e0bff745 	stb	r2,-35(fp)
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_PROFILE_INCORRECT_DEFINED;
   37c44:	e0bff743 	ldbu	r2,-35(fp)
   37c48:	10c0004c 	andi	r3,r2,1
   37c4c:	e0bff703 	ldbu	r2,-36(fp)
   37c50:	10800098 	cmpnei	r2,r2,2
   37c54:	1000021e 	bne	r2,zero,37c60 <getPHYSpeed+0x87c>
   37c58:	00800084 	movi	r2,2
   37c5c:	00000106 	br	37c64 <getPHYSpeed+0x880>
   37c60:	0005883a 	mov	r2,zero
   37c64:	1886b03a 	or	r3,r3,r2
   37c68:	e0bff703 	ldbu	r2,-36(fp)
   37c6c:	10800058 	cmpnei	r2,r2,1
   37c70:	1000021e 	bne	r2,zero,37c7c <getPHYSpeed+0x898>
   37c74:	00800104 	movi	r2,4
   37c78:	00000106 	br	37c80 <getPHYSpeed+0x89c>
   37c7c:	0005883a 	mov	r2,zero
   37c80:	1886b03a 	or	r3,r3,r2
   37c84:	e0bff703 	ldbu	r2,-36(fp)
   37c88:	1000021e 	bne	r2,zero,37c94 <getPHYSpeed+0x8b0>
   37c8c:	00800204 	movi	r2,8
   37c90:	00000106 	br	37c98 <getPHYSpeed+0x8b4>
   37c94:	0005883a 	mov	r2,zero
   37c98:	1886b03a 	or	r3,r3,r2
   37c9c:	e0bff703 	ldbu	r2,-36(fp)
   37ca0:	108000d8 	cmpnei	r2,r2,3
   37ca4:	1000021e 	bne	r2,zero,37cb0 <getPHYSpeed+0x8cc>
   37ca8:	00800074 	movhi	r2,1
   37cac:	00000106 	br	37cb4 <getPHYSpeed+0x8d0>
   37cb0:	0005883a 	mov	r2,zero
   37cb4:	1884b03a 	or	r2,r3,r2
   37cb8:	108000b4 	orhi	r2,r2,2
   37cbc:	e0bff815 	stw	r2,-32(fp)
   37cc0:	00003a06 	br	37dac <getPHYSpeed+0x9c8>
	        }
	        else
	        {
	            /* extract connection speed and duplex information */
	        	speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
   37cc4:	e0bff917 	ldw	r2,-28(fp)
   37cc8:	10800517 	ldw	r2,20(r2)
   37ccc:	10801583 	ldbu	r2,86(r2)
   37cd0:	10c03fcc 	andi	r3,r2,255
   37cd4:	e0bff917 	ldw	r2,-28(fp)
   37cd8:	10800517 	ldw	r2,20(r2)
   37cdc:	108015c3 	ldbu	r2,87(r2)
   37ce0:	10803fcc 	andi	r2,r2,255
   37ce4:	e13ff917 	ldw	r4,-28(fp)
   37ce8:	180b883a 	mov	r5,r3
   37cec:	100d883a 	mov	r6,r2
   37cf0:	01c00084 	movi	r7,2
   37cf4:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   37cf8:	e0bff705 	stb	r2,-36(fp)
	            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
   37cfc:	e0bff917 	ldw	r2,-28(fp)
   37d00:	10800517 	ldw	r2,20(r2)
   37d04:	10801583 	ldbu	r2,86(r2)
   37d08:	10c03fcc 	andi	r3,r2,255
   37d0c:	e0bff917 	ldw	r2,-28(fp)
   37d10:	10800517 	ldw	r2,20(r2)
   37d14:	10801603 	ldbu	r2,88(r2)
   37d18:	10803fcc 	andi	r2,r2,255
   37d1c:	e13ff917 	ldw	r4,-28(fp)
   37d20:	180b883a 	mov	r5,r3
   37d24:	100d883a 	mov	r6,r2
   37d28:	01c00044 	movi	r7,1
   37d2c:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   37d30:	e0bff745 	stb	r2,-35(fp)
				
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
   37d34:	e0bff743 	ldbu	r2,-35(fp)
   37d38:	10c0004c 	andi	r3,r2,1
   37d3c:	e0bff703 	ldbu	r2,-36(fp)
   37d40:	10800098 	cmpnei	r2,r2,2
   37d44:	1000021e 	bne	r2,zero,37d50 <getPHYSpeed+0x96c>
   37d48:	00800084 	movi	r2,2
   37d4c:	00000106 	br	37d54 <getPHYSpeed+0x970>
   37d50:	0005883a 	mov	r2,zero
   37d54:	1886b03a 	or	r3,r3,r2
   37d58:	e0bff703 	ldbu	r2,-36(fp)
   37d5c:	10800058 	cmpnei	r2,r2,1
   37d60:	1000021e 	bne	r2,zero,37d6c <getPHYSpeed+0x988>
   37d64:	00800104 	movi	r2,4
   37d68:	00000106 	br	37d70 <getPHYSpeed+0x98c>
   37d6c:	0005883a 	mov	r2,zero
   37d70:	1886b03a 	or	r3,r3,r2
   37d74:	e0bff703 	ldbu	r2,-36(fp)
   37d78:	1000021e 	bne	r2,zero,37d84 <getPHYSpeed+0x9a0>
   37d7c:	00800204 	movi	r2,8
   37d80:	00000106 	br	37d88 <getPHYSpeed+0x9a4>
   37d84:	0005883a 	mov	r2,zero
   37d88:	1886b03a 	or	r3,r3,r2
   37d8c:	e0bff703 	ldbu	r2,-36(fp)
   37d90:	108000d8 	cmpnei	r2,r2,3
   37d94:	1000021e 	bne	r2,zero,37da0 <getPHYSpeed+0x9bc>
   37d98:	00800074 	movhi	r2,1
   37d9c:	00000106 	br	37da4 <getPHYSpeed+0x9c0>
   37da0:	0005883a 	mov	r2,zero
   37da4:	1884b03a 	or	r2,r3,r2
   37da8:	e0bff815 	stw	r2,-32(fp)
        /* for simulation purpose, default to gigabit mode */
        speed = 1;
        duplex = 1;
    #endif

    tse_dprintf(5, "INFO    : PHY[%d.%d] - Speed = %s, Duplex = %s\n",  mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
   37dac:	e17ffd47 	ldb	r5,-11(fp)
   37db0:	e1bffd07 	ldb	r6,-12(fp)
   37db4:	e0bff703 	ldbu	r2,-36(fp)
   37db8:	108000a0 	cmpeqi	r2,r2,2
   37dbc:	10000e1e 	bne	r2,zero,37df8 <getPHYSpeed+0xa14>
   37dc0:	e0bff703 	ldbu	r2,-36(fp)
   37dc4:	10800060 	cmpeqi	r2,r2,1
   37dc8:	1000081e 	bne	r2,zero,37dec <getPHYSpeed+0xa08>
   37dcc:	e0bff703 	ldbu	r2,-36(fp)
   37dd0:	1000031e 	bne	r2,zero,37de0 <getPHYSpeed+0x9fc>
   37dd4:	00800134 	movhi	r2,4
   37dd8:	1086ad04 	addi	r2,r2,6836
   37ddc:	00000206 	br	37de8 <getPHYSpeed+0xa04>
   37de0:	00800134 	movhi	r2,4
   37de4:	1086ae04 	addi	r2,r2,6840
   37de8:	00000206 	br	37df4 <getPHYSpeed+0xa10>
   37dec:	00800134 	movhi	r2,4
   37df0:	1086b004 	addi	r2,r2,6848
   37df4:	00000206 	br	37e00 <getPHYSpeed+0xa1c>
   37df8:	00800134 	movhi	r2,4
   37dfc:	1086b104 	addi	r2,r2,6852
   37e00:	e0fff743 	ldbu	r3,-35(fp)
   37e04:	18c00058 	cmpnei	r3,r3,1
   37e08:	1800031e 	bne	r3,zero,37e18 <getPHYSpeed+0xa34>
   37e0c:	00c00134 	movhi	r3,4
   37e10:	18c6b304 	addi	r3,r3,6860
   37e14:	00000206 	br	37e20 <getPHYSpeed+0xa3c>
   37e18:	00c00134 	movhi	r3,4
   37e1c:	18c6b504 	addi	r3,r3,6868
   37e20:	d8c00015 	stw	r3,0(sp)
   37e24:	01000134 	movhi	r4,4
   37e28:	21075b04 	addi	r4,r4,7532
   37e2c:	100f883a 	mov	r7,r2
   37e30:	00044740 	call	4474 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");

    return result;
   37e34:	e0bff817 	ldw	r2,-32(fp)
}
   37e38:	e037883a 	mov	sp,fp
   37e3c:	dfc00117 	ldw	ra,4(sp)
   37e40:	df000017 	ldw	fp,0(sp)
   37e44:	dec00204 	addi	sp,sp,8
   37e48:	f800283a 	ret

00037e4c <alt_tse_phy_rd_mdio_addr>:
/* @Function Description: Read MDIO address from the MDIO address1 register of first MAC within MAC group
 * @API Type:    Internal
 * @param pmac   Pointer to the alt_tse_phy_info structure
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_rd_mdio_addr(alt_tse_phy_info *pphy) {
   37e4c:	defffd04 	addi	sp,sp,-12
   37e50:	df000215 	stw	fp,8(sp)
   37e54:	df000204 	addi	fp,sp,8
   37e58:	e13fff15 	stw	r4,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   37e5c:	e0bfff17 	ldw	r2,-4(fp)
   37e60:	10800617 	ldw	r2,24(r2)
   37e64:	10800317 	ldw	r2,12(r2)
   37e68:	10800117 	ldw	r2,4(r2)
   37e6c:	10800217 	ldw	r2,8(r2)
   37e70:	10800017 	ldw	r2,0(r2)
   37e74:	e0bffe15 	stw	r2,-8(fp)
    return IORD(&pmac_group_base->MDIO_ADDR1, 0);
   37e78:	e0bffe17 	ldw	r2,-8(fp)
   37e7c:	10801004 	addi	r2,r2,64
   37e80:	10800037 	ldwio	r2,0(r2)
}
   37e84:	e037883a 	mov	sp,fp
   37e88:	df000017 	ldw	fp,0(sp)
   37e8c:	dec00104 	addi	sp,sp,4
   37e90:	f800283a 	ret

00037e94 <alt_tse_phy_wr_mdio_addr>:
 * @API Type:           Internal
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
   37e94:	defffc04 	addi	sp,sp,-16
   37e98:	df000315 	stw	fp,12(sp)
   37e9c:	df000304 	addi	fp,sp,12
   37ea0:	e13ffe15 	stw	r4,-8(fp)
   37ea4:	2805883a 	mov	r2,r5
   37ea8:	e0bfff05 	stb	r2,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   37eac:	e0bffe17 	ldw	r2,-8(fp)
   37eb0:	10800617 	ldw	r2,24(r2)
   37eb4:	10800317 	ldw	r2,12(r2)
   37eb8:	10800117 	ldw	r2,4(r2)
   37ebc:	10800217 	ldw	r2,8(r2)
   37ec0:	10800017 	ldw	r2,0(r2)
   37ec4:	e0bffd15 	stw	r2,-12(fp)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
   37ec8:	e0bffd17 	ldw	r2,-12(fp)
   37ecc:	10801004 	addi	r2,r2,64
   37ed0:	e0ffff03 	ldbu	r3,-4(fp)
   37ed4:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
   37ed8:	0005883a 	mov	r2,zero
}
   37edc:	e037883a 	mov	sp,fp
   37ee0:	df000017 	ldw	fp,0(sp)
   37ee4:	dec00104 	addi	sp,sp,4
   37ee8:	f800283a 	ret

00037eec <alt_tse_phy_wr_mdio_reg>:
  * @param  bit_length       number of bits to be written to the register.
  * @param  data             data to be written to the register at specific bit location of register.
  * @return SUCCESS 
  */
alt_32 alt_tse_phy_wr_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length, alt_u16 data)
{
   37eec:	defff604 	addi	sp,sp,-40
   37ef0:	df000915 	stw	fp,36(sp)
   37ef4:	df000904 	addi	fp,sp,36
   37ef8:	e13ffb15 	stw	r4,-20(fp)
   37efc:	2809883a 	mov	r4,r5
   37f00:	3007883a 	mov	r3,r6
   37f04:	3805883a 	mov	r2,r7
   37f08:	e1400117 	ldw	r5,4(fp)
   37f0c:	e13ffc05 	stb	r4,-16(fp)
   37f10:	e0fffd05 	stb	r3,-12(fp)
   37f14:	e0bffe05 	stb	r2,-8(fp)
   37f18:	e17fff0d 	sth	r5,-4(fp)
    
    alt_u16 temp_data;
    alt_u16 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   37f1c:	e0bffb17 	ldw	r2,-20(fp)
   37f20:	10800617 	ldw	r2,24(r2)
   37f24:	10800317 	ldw	r2,12(r2)
   37f28:	10800117 	ldw	r2,4(r2)
   37f2c:	10800217 	ldw	r2,8(r2)
   37f30:	10800017 	ldw	r2,0(r2)
   37f34:	e0bff915 	stw	r2,-28(fp)
    
    bit_mask = 0x00;
   37f38:	e03ff70d 	sth	zero,-36(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
   37f3c:	e03ff815 	stw	zero,-32(fp)
   37f40:	00000906 	br	37f68 <alt_tse_phy_wr_mdio_reg+0x7c>
    {
        bit_mask <<= 1;
   37f44:	e0bff70b 	ldhu	r2,-36(fp)
   37f48:	1085883a 	add	r2,r2,r2
   37f4c:	e0bff70d 	sth	r2,-36(fp)
        bit_mask |= 0x01;        
   37f50:	e0bff70b 	ldhu	r2,-36(fp)
   37f54:	10800054 	ori	r2,r2,1
   37f58:	e0bff70d 	sth	r2,-36(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
   37f5c:	e0bff817 	ldw	r2,-32(fp)
   37f60:	10800044 	addi	r2,r2,1
   37f64:	e0bff815 	stw	r2,-32(fp)
   37f68:	e0bffe03 	ldbu	r2,-8(fp)
   37f6c:	e0fff817 	ldw	r3,-32(fp)
   37f70:	18bff416 	blt	r3,r2,37f44 <alt_tse_phy_wr_mdio_reg+0x58>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* shifting mask to left by bit_num */
    bit_mask <<= lsb_num;
   37f74:	e0fff70b 	ldhu	r3,-36(fp)
   37f78:	e0bffd03 	ldbu	r2,-12(fp)
   37f7c:	1884983a 	sll	r2,r3,r2
   37f80:	e0bff70d 	sth	r2,-36(fp)

    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
   37f84:	e0bff917 	ldw	r2,-28(fp)
   37f88:	10c0a004 	addi	r3,r2,640
   37f8c:	e0bffc03 	ldbu	r2,-16(fp)
   37f90:	1085883a 	add	r2,r2,r2
   37f94:	1085883a 	add	r2,r2,r2
   37f98:	1885883a 	add	r2,r3,r2
   37f9c:	10800037 	ldwio	r2,0(r2)
   37fa0:	e0bffa0d 	sth	r2,-24(fp)
    
    /* clear bits to be written */
    temp_data &= ~bit_mask;
   37fa4:	e0bff70b 	ldhu	r2,-36(fp)
   37fa8:	0084303a 	nor	r2,zero,r2
   37fac:	1007883a 	mov	r3,r2
   37fb0:	e0bffa0b 	ldhu	r2,-24(fp)
   37fb4:	1884703a 	and	r2,r3,r2
   37fb8:	e0bffa0d 	sth	r2,-24(fp)
    
    /* OR-ed together corresponding bits data */
    temp_data |= ((data << lsb_num) & bit_mask);    
   37fbc:	e0ffff0b 	ldhu	r3,-4(fp)
   37fc0:	e0bffd03 	ldbu	r2,-12(fp)
   37fc4:	1884983a 	sll	r2,r3,r2
   37fc8:	1007883a 	mov	r3,r2
   37fcc:	e0bff70b 	ldhu	r2,-36(fp)
   37fd0:	1884703a 	and	r2,r3,r2
   37fd4:	1007883a 	mov	r3,r2
   37fd8:	e0bffa0b 	ldhu	r2,-24(fp)
   37fdc:	1884b03a 	or	r2,r3,r2
   37fe0:	e0bffa0d 	sth	r2,-24(fp)
    
    /* write data to MDIO register */
    IOWR(&pmac->mdio1, reg_num, temp_data);
   37fe4:	e0bff917 	ldw	r2,-28(fp)
   37fe8:	10c0a004 	addi	r3,r2,640
   37fec:	e0bffc03 	ldbu	r2,-16(fp)
   37ff0:	1085883a 	add	r2,r2,r2
   37ff4:	1085883a 	add	r2,r2,r2
   37ff8:	1885883a 	add	r2,r3,r2
   37ffc:	e0fffa0b 	ldhu	r3,-24(fp)
   38000:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
   38004:	0005883a 	mov	r2,zero
    
}
   38008:	e037883a 	mov	sp,fp
   3800c:	df000017 	ldw	fp,0(sp)
   38010:	dec00104 	addi	sp,sp,4
   38014:	f800283a 	ret

00038018 <alt_tse_phy_rd_mdio_reg>:
 * @param  bit_length       number of bits to be read from the register.
 * @return data read from MDIO register 
 */

alt_u32 alt_tse_phy_rd_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length)
{
   38018:	defff704 	addi	sp,sp,-36
   3801c:	df000815 	stw	fp,32(sp)
   38020:	df000804 	addi	fp,sp,32
   38024:	e13ffc15 	stw	r4,-16(fp)
   38028:	2809883a 	mov	r4,r5
   3802c:	3007883a 	mov	r3,r6
   38030:	3805883a 	mov	r2,r7
   38034:	e13ffd05 	stb	r4,-12(fp)
   38038:	e0fffe05 	stb	r3,-8(fp)
   3803c:	e0bfff05 	stb	r2,-4(fp)
    alt_u16 temp_data;
    alt_u32 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   38040:	e0bffc17 	ldw	r2,-16(fp)
   38044:	10800617 	ldw	r2,24(r2)
   38048:	10800317 	ldw	r2,12(r2)
   3804c:	10800117 	ldw	r2,4(r2)
   38050:	10800217 	ldw	r2,8(r2)
   38054:	10800017 	ldw	r2,0(r2)
   38058:	e0bffa15 	stw	r2,-24(fp)
    
    bit_mask = 0x00;
   3805c:	e03ff815 	stw	zero,-32(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
   38060:	e03ff915 	stw	zero,-28(fp)
   38064:	00000906 	br	3808c <alt_tse_phy_rd_mdio_reg+0x74>
    {
        bit_mask <<= 1;
   38068:	e0bff817 	ldw	r2,-32(fp)
   3806c:	1085883a 	add	r2,r2,r2
   38070:	e0bff815 	stw	r2,-32(fp)
        bit_mask |= 0x01;        
   38074:	e0bff817 	ldw	r2,-32(fp)
   38078:	10800054 	ori	r2,r2,1
   3807c:	e0bff815 	stw	r2,-32(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
   38080:	e0bff917 	ldw	r2,-28(fp)
   38084:	10800044 	addi	r2,r2,1
   38088:	e0bff915 	stw	r2,-28(fp)
   3808c:	e0bfff03 	ldbu	r2,-4(fp)
   38090:	e0fff917 	ldw	r3,-28(fp)
   38094:	18bff416 	blt	r3,r2,38068 <alt_tse_phy_rd_mdio_reg+0x50>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
   38098:	e0bffa17 	ldw	r2,-24(fp)
   3809c:	10c0a004 	addi	r3,r2,640
   380a0:	e0bffd03 	ldbu	r2,-12(fp)
   380a4:	1085883a 	add	r2,r2,r2
   380a8:	1085883a 	add	r2,r2,r2
   380ac:	1885883a 	add	r2,r3,r2
   380b0:	10800037 	ldwio	r2,0(r2)
   380b4:	e0bffb0d 	sth	r2,-20(fp)
    
    /* shifting read data */
    temp_data >>= lsb_num;
   380b8:	e0fffb0b 	ldhu	r3,-20(fp)
   380bc:	e0bffe03 	ldbu	r2,-8(fp)
   380c0:	1885d83a 	sra	r2,r3,r2
   380c4:	e0bffb0d 	sth	r2,-20(fp)
    
    return (temp_data & bit_mask);
   380c8:	e0fffb0b 	ldhu	r3,-20(fp)
   380cc:	e0bff817 	ldw	r2,-32(fp)
   380d0:	1884703a 	and	r2,r3,r2
}
   380d4:	e037883a 	mov	sp,fp
   380d8:	df000017 	ldw	fp,0(sp)
   380dc:	dec00104 	addi	sp,sp,4
   380e0:	f800283a 	ret

000380e4 <alt_tse_phy_add_profile_default>:
 * @param pmac  N/A
 * @return      Number of PHY in profile
 * 
 * User might add their own PHY by calling alt_tse_phy_add_profile()
 */
alt_32 alt_tse_phy_add_profile_default() {
   380e4:	deff9a04 	addi	sp,sp,-408
   380e8:	dfc06515 	stw	ra,404(sp)
   380ec:	df006415 	stw	fp,400(sp)
   380f0:	df006404 	addi	fp,sp,400
        
    /* ------------------------------ */
    /* Marvell PHY on PHYWORKX board  */
    /* ------------------------------ */
    
    alt_tse_phy_profile MV88E1111 = {"Marvell 88E1111",      /* Marvell 88E1111                                  */
   380f4:	e0ff9c04 	addi	r3,fp,-400
   380f8:	00801904 	movi	r2,100
   380fc:	1809883a 	mov	r4,r3
   38100:	000b883a 	mov	r5,zero
   38104:	100d883a 	mov	r6,r2
   38108:	00042e80 	call	42e8 <memset>
   3810c:	009d9cb4 	movhi	r2,30322
   38110:	10985344 	addi	r2,r2,24909
   38114:	e0bf9c15 	stw	r2,-400(fp)
   38118:	00881b34 	movhi	r2,8300
   3811c:	109b1944 	addi	r2,r2,27749
   38120:	e0bf9d15 	stw	r2,-396(fp)
   38124:	008c5174 	movhi	r2,12613
   38128:	108e0e04 	addi	r2,r2,14392
   3812c:	e0bf9e15 	stw	r2,-392(fp)
   38130:	00800c74 	movhi	r2,49
   38134:	108c4c44 	addi	r2,r2,12593
   38138:	e0bf9f15 	stw	r2,-388(fp)
   3813c:	e0ffa004 	addi	r3,fp,-384
   38140:	00801004 	movi	r2,64
   38144:	1809883a 	mov	r4,r3
   38148:	000b883a 	mov	r5,zero
   3814c:	100d883a 	mov	r6,r2
   38150:	00042e80 	call	42e8 <memset>
   38154:	009410c4 	movi	r2,20547
   38158:	e0bfb015 	stw	r2,-320(fp)
   3815c:	00800304 	movi	r2,12
   38160:	e0bfb105 	stb	r2,-316(fp)
   38164:	00800084 	movi	r2,2
   38168:	e0bfb145 	stb	r2,-315(fp)
   3816c:	00800444 	movi	r2,17
   38170:	e0bfb185 	stb	r2,-314(fp)
   38174:	00800384 	movi	r2,14
   38178:	e0bfb1c5 	stb	r2,-313(fp)
   3817c:	00800344 	movi	r2,13
   38180:	e0bfb205 	stb	r2,-312(fp)
   38184:	00800284 	movi	r2,10
   38188:	e0bfb245 	stb	r2,-311(fp)
   3818c:	00800134 	movhi	r2,4
   38190:	10aac004 	addi	r2,r2,-21760
   38194:	e0bfb315 	stw	r2,-308(fp)
    
    /* ---------------------------------- */
    /* Marvell Quad PHY on PHYWORKX board */
    /* ---------------------------------- */
    
    alt_tse_phy_profile MV88E1145 = {"Marvell Quad PHY 88E1145",      /* Marvell 88E1145                                  */
   38198:	e0ffb504 	addi	r3,fp,-300
   3819c:	00801904 	movi	r2,100
   381a0:	1809883a 	mov	r4,r3
   381a4:	000b883a 	mov	r5,zero
   381a8:	100d883a 	mov	r6,r2
   381ac:	00042e80 	call	42e8 <memset>
   381b0:	009d9cb4 	movhi	r2,30322
   381b4:	10985344 	addi	r2,r2,24909
   381b8:	e0bfb515 	stw	r2,-300(fp)
   381bc:	00881b34 	movhi	r2,8300
   381c0:	109b1944 	addi	r2,r2,27749
   381c4:	e0bfb615 	stw	r2,-296(fp)
   381c8:	00991874 	movhi	r2,25697
   381cc:	109d5444 	addi	r2,r2,30033
   381d0:	e0bfb715 	stw	r2,-292(fp)
   381d4:	00965234 	movhi	r2,22856
   381d8:	10940804 	addi	r2,r2,20512
   381dc:	e0bfb815 	stw	r2,-288(fp)
   381e0:	00914e34 	movhi	r2,17720
   381e4:	108e0804 	addi	r2,r2,14368
   381e8:	e0bfb915 	stw	r2,-284(fp)
   381ec:	008d4d34 	movhi	r2,13620
   381f0:	108c4c44 	addi	r2,r2,12593
   381f4:	e0bfba15 	stw	r2,-280(fp)
   381f8:	e03fbb15 	stw	zero,-276(fp)
   381fc:	e03fbc15 	stw	zero,-272(fp)
   38200:	e03fbd15 	stw	zero,-268(fp)
   38204:	e03fbe15 	stw	zero,-264(fp)
   38208:	e03fbf15 	stw	zero,-260(fp)
   3820c:	e03fc015 	stw	zero,-256(fp)
   38210:	e03fc115 	stw	zero,-252(fp)
   38214:	e03fc215 	stw	zero,-248(fp)
   38218:	e03fc315 	stw	zero,-244(fp)
   3821c:	e03fc415 	stw	zero,-240(fp)
   38220:	e03fc515 	stw	zero,-236(fp)
   38224:	e03fc615 	stw	zero,-232(fp)
   38228:	e03fc715 	stw	zero,-228(fp)
   3822c:	e03fc815 	stw	zero,-224(fp)
   38230:	009410c4 	movi	r2,20547
   38234:	e0bfc915 	stw	r2,-220(fp)
   38238:	00800344 	movi	r2,13
   3823c:	e0bfca05 	stb	r2,-216(fp)
   38240:	00800084 	movi	r2,2
   38244:	e0bfca45 	stb	r2,-215(fp)
   38248:	00800444 	movi	r2,17
   3824c:	e0bfca85 	stb	r2,-214(fp)
   38250:	00800384 	movi	r2,14
   38254:	e0bfcac5 	stb	r2,-213(fp)
   38258:	00800344 	movi	r2,13
   3825c:	e0bfcb05 	stb	r2,-212(fp)
   38260:	00800284 	movi	r2,10
   38264:	e0bfcb45 	stb	r2,-211(fp)
   38268:	00800134 	movhi	r2,4
   3826c:	10aac004 	addi	r2,r2,-21760
   38270:	e0bfcc15 	stw	r2,-208(fp)
                      
    /* ------------------------------ */
    /* National PHY on PHYWORKX board */
    /* ------------------------------ */  
    
    alt_tse_phy_profile DP83865 = {"National DP83865",     /* National DP83865                                 */
   38274:	e0ffce04 	addi	r3,fp,-200
   38278:	00801904 	movi	r2,100
   3827c:	1809883a 	mov	r4,r3
   38280:	000b883a 	mov	r5,zero
   38284:	100d883a 	mov	r6,r2
   38288:	00042e80 	call	42e8 <memset>
   3828c:	009a5d34 	movhi	r2,26996
   38290:	10985384 	addi	r2,r2,24910
   38294:	e0bfce15 	stw	r2,-200(fp)
   38298:	009b1874 	movhi	r2,27745
   3829c:	109b9bc4 	addi	r2,r2,28271
   382a0:	e0bfcf15 	stw	r2,-196(fp)
   382a4:	008e1434 	movhi	r2,14416
   382a8:	10910804 	addi	r2,r2,17440
   382ac:	e0bfd015 	stw	r2,-192(fp)
   382b0:	008d4db4 	movhi	r2,13622
   382b4:	108e0cc4 	addi	r2,r2,14387
   382b8:	e0bfd115 	stw	r2,-188(fp)
   382bc:	e03fd215 	stw	zero,-184(fp)
   382c0:	e0ffd304 	addi	r3,fp,-180
   382c4:	00800f04 	movi	r2,60
   382c8:	1809883a 	mov	r4,r3
   382cc:	000b883a 	mov	r5,zero
   382d0:	100d883a 	mov	r6,r2
   382d4:	00042e80 	call	42e8 <memset>
   382d8:	00800234 	movhi	r2,8
   382dc:	108005c4 	addi	r2,r2,23
   382e0:	e0bfe215 	stw	r2,-120(fp)
   382e4:	008001c4 	movi	r2,7
   382e8:	e0bfe305 	stb	r2,-116(fp)
   382ec:	00800284 	movi	r2,10
   382f0:	e0bfe345 	stb	r2,-115(fp)
   382f4:	00800444 	movi	r2,17
   382f8:	e0bfe385 	stb	r2,-114(fp)
   382fc:	008000c4 	movi	r2,3
   38300:	e0bfe3c5 	stb	r2,-113(fp)
   38304:	00800044 	movi	r2,1
   38308:	e0bfe405 	stb	r2,-112(fp)
   3830c:	00800084 	movi	r2,2
   38310:	e0bfe445 	stb	r2,-111(fp)
                      
    /* -------------------------------------- */
    /* National 10/100 PHY on PHYWORKX board  */
    /* -------------------------------------- */ 
                      
    alt_tse_phy_profile DP83848C = {"National DP83848C",  /* National DP83848C                                          */
   38314:	00800134 	movhi	r2,4
   38318:	10876704 	addi	r2,r2,7580
   3831c:	e13fe704 	addi	r4,fp,-100
   38320:	1007883a 	mov	r3,r2
   38324:	00801904 	movi	r2,100
   38328:	180b883a 	mov	r5,r3
   3832c:	100d883a 	mov	r6,r2
   38330:	00041f00 	call	41f0 <memcpy>
						   0,                              /* No function pointer configure National DP83848C            */
						   &DP83848C_link_status_read      /* Function pointer to read from PHY specific status register */           
                          };
                      
    /* add supported PHY to profile */                          
    alt_tse_phy_add_profile(&MV88E1111);
   38334:	e13f9c04 	addi	r4,fp,-400
   38338:	00362740 	call	36274 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&MV88E1145);
   3833c:	e0bfb504 	addi	r2,fp,-300
   38340:	1009883a 	mov	r4,r2
   38344:	00362740 	call	36274 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83865);
   38348:	e0bfce04 	addi	r2,fp,-200
   3834c:	1009883a 	mov	r4,r2
   38350:	00362740 	call	36274 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83848C);
   38354:	e0bfe704 	addi	r2,fp,-100
   38358:	1009883a 	mov	r4,r2
   3835c:	00362740 	call	36274 <alt_tse_phy_add_profile>
    
    
    return phy_profile_count;
   38360:	d0a94703 	ldbu	r2,-23268(gp)
   38364:	10803fcc 	andi	r2,r2,255
}
   38368:	e037883a 	mov	sp,fp
   3836c:	dfc00117 	ldw	ra,4(sp)
   38370:	df000017 	ldw	fp,0(sp)
   38374:	dec00204 	addi	sp,sp,8
   38378:	f800283a 	ret

0003837c <alt_tse_phy_print_profile>:
/* @Function Description: Display PHYs available in profile
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      Number of PHY in profile
 */
alt_32 alt_tse_phy_print_profile() {
   3837c:	defffd04 	addi	sp,sp,-12
   38380:	dfc00215 	stw	ra,8(sp)
   38384:	df000115 	stw	fp,4(sp)
   38388:	df000104 	addi	fp,sp,4
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
   3838c:	d0a94703 	ldbu	r2,-23268(gp)
   38390:	10803fcc 	andi	r2,r2,255
   38394:	01000134 	movhi	r4,4
   38398:	21078004 	addi	r4,r4,7680
   3839c:	100b883a 	mov	r5,r2
   383a0:	0035f380 	call	35f38 <no_printf>
    
    for(i = 0; i < phy_profile_count; i++)
   383a4:	e03fff05 	stb	zero,-4(fp)
   383a8:	00006d06 	br	38560 <alt_tse_phy_print_profile+0x1e4>
    {
        tse_dprintf(6, "Profile No.%2d   :\n", i);
   383ac:	e0bfff07 	ldb	r2,-4(fp)
   383b0:	01000134 	movhi	r4,4
   383b4:	21078f04 	addi	r4,r4,7740
   383b8:	100b883a 	mov	r5,r2
   383bc:	0035f380 	call	35f38 <no_printf>
        tse_dprintf(6, "PHY Name        : %s\n", pphy_profiles[i]->name);
   383c0:	e0bfff07 	ldb	r2,-4(fp)
   383c4:	00c001f4 	movhi	r3,7
   383c8:	18ed1304 	addi	r3,r3,-19380
   383cc:	1085883a 	add	r2,r2,r2
   383d0:	1085883a 	add	r2,r2,r2
   383d4:	1885883a 	add	r2,r3,r2
   383d8:	10800017 	ldw	r2,0(r2)
   383dc:	01000134 	movhi	r4,4
   383e0:	21079404 	addi	r4,r4,7760
   383e4:	100b883a 	mov	r5,r2
   383e8:	0035f380 	call	35f38 <no_printf>
   
        tse_dprintf(6, "PHY OUI         : 0x%06x\n", (int)pphy_profiles[i]->oui);
   383ec:	e0bfff07 	ldb	r2,-4(fp)
   383f0:	00c001f4 	movhi	r3,7
   383f4:	18ed1304 	addi	r3,r3,-19380
   383f8:	1085883a 	add	r2,r2,r2
   383fc:	1085883a 	add	r2,r2,r2
   38400:	1885883a 	add	r2,r3,r2
   38404:	10800017 	ldw	r2,0(r2)
   38408:	10801417 	ldw	r2,80(r2)
   3840c:	01000134 	movhi	r4,4
   38410:	21079a04 	addi	r4,r4,7784
   38414:	100b883a 	mov	r5,r2
   38418:	0035f380 	call	35f38 <no_printf>
        tse_dprintf(6, "PHY Model Num.  : 0x%02x\n", pphy_profiles[i]->model_number);
   3841c:	e0bfff07 	ldb	r2,-4(fp)
   38420:	00c001f4 	movhi	r3,7
   38424:	18ed1304 	addi	r3,r3,-19380
   38428:	1085883a 	add	r2,r2,r2
   3842c:	1085883a 	add	r2,r2,r2
   38430:	1885883a 	add	r2,r3,r2
   38434:	10800017 	ldw	r2,0(r2)
   38438:	10801503 	ldbu	r2,84(r2)
   3843c:	10803fcc 	andi	r2,r2,255
   38440:	01000134 	movhi	r4,4
   38444:	2107a104 	addi	r4,r4,7812
   38448:	100b883a 	mov	r5,r2
   3844c:	0035f380 	call	35f38 <no_printf>
        tse_dprintf(6, "PHY Rev. Num.   : 0x%02x\n", pphy_profiles[i]->revision_number);
   38450:	e0bfff07 	ldb	r2,-4(fp)
   38454:	00c001f4 	movhi	r3,7
   38458:	18ed1304 	addi	r3,r3,-19380
   3845c:	1085883a 	add	r2,r2,r2
   38460:	1085883a 	add	r2,r2,r2
   38464:	1885883a 	add	r2,r3,r2
   38468:	10800017 	ldw	r2,0(r2)
   3846c:	10801543 	ldbu	r2,85(r2)
   38470:	10803fcc 	andi	r2,r2,255
   38474:	01000134 	movhi	r4,4
   38478:	2107a804 	addi	r4,r4,7840
   3847c:	100b883a 	mov	r5,r2
   38480:	0035f380 	call	35f38 <no_printf>
        
        tse_dprintf(6, "Status Register : 0x%02x\n", pphy_profiles[i]->status_reg_location); 
   38484:	e0bfff07 	ldb	r2,-4(fp)
   38488:	00c001f4 	movhi	r3,7
   3848c:	18ed1304 	addi	r3,r3,-19380
   38490:	1085883a 	add	r2,r2,r2
   38494:	1085883a 	add	r2,r2,r2
   38498:	1885883a 	add	r2,r3,r2
   3849c:	10800017 	ldw	r2,0(r2)
   384a0:	10801583 	ldbu	r2,86(r2)
   384a4:	10803fcc 	andi	r2,r2,255
   384a8:	01000134 	movhi	r4,4
   384ac:	2107af04 	addi	r4,r4,7868
   384b0:	100b883a 	mov	r5,r2
   384b4:	0035f380 	call	35f38 <no_printf>
        
        tse_dprintf(6, "Speed Bit       : %d\n", pphy_profiles[i]->speed_lsb_location);
   384b8:	e0bfff07 	ldb	r2,-4(fp)
   384bc:	00c001f4 	movhi	r3,7
   384c0:	18ed1304 	addi	r3,r3,-19380
   384c4:	1085883a 	add	r2,r2,r2
   384c8:	1085883a 	add	r2,r2,r2
   384cc:	1885883a 	add	r2,r3,r2
   384d0:	10800017 	ldw	r2,0(r2)
   384d4:	108015c3 	ldbu	r2,87(r2)
   384d8:	10803fcc 	andi	r2,r2,255
   384dc:	01000134 	movhi	r4,4
   384e0:	2107b604 	addi	r4,r4,7896
   384e4:	100b883a 	mov	r5,r2
   384e8:	0035f380 	call	35f38 <no_printf>
        
        tse_dprintf(6, "Duplex Bit      : %d\n", pphy_profiles[i]->duplex_bit_location);
   384ec:	e0bfff07 	ldb	r2,-4(fp)
   384f0:	00c001f4 	movhi	r3,7
   384f4:	18ed1304 	addi	r3,r3,-19380
   384f8:	1085883a 	add	r2,r2,r2
   384fc:	1085883a 	add	r2,r2,r2
   38500:	1885883a 	add	r2,r3,r2
   38504:	10800017 	ldw	r2,0(r2)
   38508:	10801603 	ldbu	r2,88(r2)
   3850c:	10803fcc 	andi	r2,r2,255
   38510:	01000134 	movhi	r4,4
   38514:	2107bc04 	addi	r4,r4,7920
   38518:	100b883a 	mov	r5,r2
   3851c:	0035f380 	call	35f38 <no_printf>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
   38520:	e0bfff07 	ldb	r2,-4(fp)
   38524:	00c001f4 	movhi	r3,7
   38528:	18ed1304 	addi	r3,r3,-19380
   3852c:	1085883a 	add	r2,r2,r2
   38530:	1085883a 	add	r2,r2,r2
   38534:	1885883a 	add	r2,r3,r2
   38538:	10800017 	ldw	r2,0(r2)
   3853c:	10801643 	ldbu	r2,89(r2)
   38540:	10803fcc 	andi	r2,r2,255
   38544:	01000134 	movhi	r4,4
   38548:	2107c204 	addi	r4,r4,7944
   3854c:	100b883a 	mov	r5,r2
   38550:	0035f380 	call	35f38 <no_printf>
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
    
    for(i = 0; i < phy_profile_count; i++)
   38554:	e0bfff03 	ldbu	r2,-4(fp)
   38558:	10800044 	addi	r2,r2,1
   3855c:	e0bfff05 	stb	r2,-4(fp)
   38560:	e0ffff07 	ldb	r3,-4(fp)
   38564:	d0a94703 	ldbu	r2,-23268(gp)
   38568:	10803fcc 	andi	r2,r2,255
   3856c:	18bf8f16 	blt	r3,r2,383ac <alt_tse_phy_print_profile+0x30>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
 
    }
    
    return phy_profile_count;
   38570:	d0a94703 	ldbu	r2,-23268(gp)
   38574:	10803fcc 	andi	r2,r2,255
}
   38578:	e037883a 	mov	sp,fp
   3857c:	dfc00117 	ldw	ra,4(sp)
   38580:	df000017 	ldw	fp,0(sp)
   38584:	dec00204 	addi	sp,sp,8
   38588:	f800283a 	ret

0003858c <alt_tse_mac_group_init>:
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      return SUCCESS
 *              return ALTERA_TSE_SYSTEM_DEF_ERROR if alt_tse_system_info structure definition error
 */
alt_32 alt_tse_mac_group_init() {
   3858c:	defffa04 	addi	sp,sp,-24
   38590:	dfc00515 	stw	ra,20(sp)
   38594:	df000415 	stw	fp,16(sp)
   38598:	df000404 	addi	fp,sp,16
    
	alt_8 i;
	alt_8 j;
    
    alt_tse_mac_group *pmac_group = 0;
   3859c:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_mac_info *pmac_info = 0;
   385a0:	e03ffe15 	stw	zero,-8(fp)
    alt_tse_system_info *psys = 0;
   385a4:	e03fff15 	stw	zero,-4(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
   385a8:	d0294745 	stb	zero,-23267(gp)
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
   385ac:	e03ffc05 	stb	zero,-16(fp)
   385b0:	00019306 	br	38c00 <alt_tse_mac_group_init+0x674>
        psys = &tse_mac_device[i];
   385b4:	e0bffc07 	ldb	r2,-16(fp)
   385b8:	10c01224 	muli	r3,r2,72
   385bc:	00800134 	movhi	r2,4
   385c0:	10952c04 	addi	r2,r2,21680
   385c4:	1885883a 	add	r2,r3,r2
   385c8:	e0bfff15 	stw	r2,-4(fp)

        if((psys->tse_sgdma_tx != 0) && (psys->tse_sgdma_rx != 0)) {    	
   385cc:	e0bfff17 	ldw	r2,-4(fp)
   385d0:	10800517 	ldw	r2,20(r2)
   385d4:	10018726 	beq	r2,zero,38bf4 <alt_tse_mac_group_init+0x668>
   385d8:	e0bfff17 	ldw	r2,-4(fp)
   385dc:	10800617 	ldw	r2,24(r2)
   385e0:	10018426 	beq	r2,zero,38bf4 <alt_tse_mac_group_init+0x668>
            tse_dprintf(5, "INFO    : TSE MAC %d found at address 0x%08x\n", mac_group_count, (int) psys->tse_mac_base);
   385e4:	d0a94743 	ldbu	r2,-23267(gp)
   385e8:	10c03fcc 	andi	r3,r2,255
   385ec:	e0bfff17 	ldw	r2,-4(fp)
   385f0:	10800017 	ldw	r2,0(r2)
   385f4:	01000134 	movhi	r4,4
   385f8:	2107c804 	addi	r4,r4,7968
   385fc:	180b883a 	mov	r5,r3
   38600:	100d883a 	mov	r6,r2
   38604:	00044740 	call	4474 <printf>
            
            /* Allocate memory for the structure */
            pmac_group = (alt_tse_mac_group *) malloc(sizeof(alt_tse_mac_group));
   38608:	01000904 	movi	r4,36
   3860c:	003f1fc0 	call	3f1fc <malloc>
   38610:	e0bffd15 	stw	r2,-12(fp)
            if(!pmac_group) {
   38614:	e0bffd17 	ldw	r2,-12(fp)
   38618:	1000081e 	bne	r2,zero,3863c <alt_tse_mac_group_init+0xb0>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]\n", mac_group_count);
   3861c:	d0a94743 	ldbu	r2,-23267(gp)
   38620:	10803fcc 	andi	r2,r2,255
   38624:	01000134 	movhi	r4,4
   38628:	2107d404 	addi	r4,r4,8016
   3862c:	100b883a 	mov	r5,r2
   38630:	00044740 	call	4474 <printf>
                return ALTERA_TSE_MALLOC_FAILED;
   38634:	00bfffc4 	movi	r2,-1
   38638:	00017606 	br	38c14 <alt_tse_mac_group_init+0x688>
            }
           
            /* Non-multi-channel MAC considered as 1 channel */
            if(psys->tse_multichannel_mac) {
   3863c:	e0bfff17 	ldw	r2,-4(fp)
   38640:	108002c3 	ldbu	r2,11(r2)
   38644:	10803fcc 	andi	r2,r2,255
   38648:	10001226 	beq	r2,zero,38694 <alt_tse_mac_group_init+0x108>
                pmac_group->channel = psys->tse_num_of_channel;
   3864c:	e0bfff17 	ldw	r2,-4(fp)
   38650:	10c00303 	ldbu	r3,12(r2)
   38654:	e0bffd17 	ldw	r2,-12(fp)
   38658:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = Yes\n");
   3865c:	01000134 	movhi	r4,4
   38660:	2107e204 	addi	r4,r4,8072
   38664:	0035f380 	call	35f38 <no_printf>
                tse_dprintf(6, "INFO    : Number of channel        = %d\n", pmac_group->channel);
   38668:	e0bffd17 	ldw	r2,-12(fp)
   3866c:	10800003 	ldbu	r2,0(r2)
   38670:	10803fcc 	andi	r2,r2,255
   38674:	01000134 	movhi	r4,4
   38678:	2107ed04 	addi	r4,r4,8116
   3867c:	100b883a 	mov	r5,r2
   38680:	0035f380 	call	35f38 <no_printf>
            	tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
   38684:	01000134 	movhi	r4,4
   38688:	2107f804 	addi	r4,r4,8160
   3868c:	0035f380 	call	35f38 <no_printf>
   38690:	00001f06 	br	38710 <alt_tse_mac_group_init+0x184>
            }
            else if(psys->tse_mdio_shared) {
   38694:	e0bfff17 	ldw	r2,-4(fp)
   38698:	10800343 	ldbu	r2,13(r2)
   3869c:	10803fcc 	andi	r2,r2,255
   386a0:	10001226 	beq	r2,zero,386ec <alt_tse_mac_group_init+0x160>
                pmac_group->channel = psys->tse_number_of_mac_mdio_shared;
   386a4:	e0bfff17 	ldw	r2,-4(fp)
   386a8:	10c00383 	ldbu	r3,14(r2)
   386ac:	e0bffd17 	ldw	r2,-12(fp)
   386b0:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
   386b4:	01000134 	movhi	r4,4
   386b8:	21080304 	addi	r4,r4,8204
   386bc:	0035f380 	call	35f38 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
   386c0:	01000134 	movhi	r4,4
   386c4:	2107f804 	addi	r4,r4,8160
   386c8:	0035f380 	call	35f38 <no_printf>
                tse_dprintf(6, "INFO    : Number of MAC Share MDIO = %d\n", pmac_group->channel);
   386cc:	e0bffd17 	ldw	r2,-12(fp)
   386d0:	10800003 	ldbu	r2,0(r2)
   386d4:	10803fcc 	andi	r2,r2,255
   386d8:	01000134 	movhi	r4,4
   386dc:	21080e04 	addi	r4,r4,8248
   386e0:	100b883a 	mov	r5,r2
   386e4:	0035f380 	call	35f38 <no_printf>
   386e8:	00000906 	br	38710 <alt_tse_mac_group_init+0x184>
            }
            else {
                pmac_group->channel = 1;
   386ec:	e0bffd17 	ldw	r2,-12(fp)
   386f0:	00c00044 	movi	r3,1
   386f4:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
   386f8:	01000134 	movhi	r4,4
   386fc:	21080304 	addi	r4,r4,8204
   38700:	0035f380 	call	35f38 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
   38704:	01000134 	movhi	r4,4
   38708:	21081904 	addi	r4,r4,8292
   3870c:	0035f380 	call	35f38 <no_printf>
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
   38710:	e03ffc45 	stb	zero,-15(fp)
   38714:	00012006 	br	38b98 <alt_tse_mac_group_init+0x60c>
                /* Allocate memory for the structure */
                pmac_info = (alt_tse_mac_info *) malloc(sizeof(alt_tse_mac_info));
   38718:	01000404 	movi	r4,16
   3871c:	003f1fc0 	call	3f1fc <malloc>
   38720:	e0bffe15 	stw	r2,-8(fp)
                if(!pmac_info) {
   38724:	e0bffe17 	ldw	r2,-8(fp)
   38728:	10000a1e 	bne	r2,zero,38754 <alt_tse_mac_group_init+0x1c8>
                    tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]->pmac_info[%d]\n", mac_group_count, j);
   3872c:	d0a94743 	ldbu	r2,-23267(gp)
   38730:	10c03fcc 	andi	r3,r2,255
   38734:	e0bffc47 	ldb	r2,-15(fp)
   38738:	01000134 	movhi	r4,4
   3873c:	21082404 	addi	r4,r4,8336
   38740:	180b883a 	mov	r5,r3
   38744:	100d883a 	mov	r6,r2
   38748:	00044740 	call	4474 <printf>
                    return ALTERA_TSE_MALLOC_FAILED;
   3874c:	00bfffc4 	movi	r2,-1
   38750:	00013006 	br	38c14 <alt_tse_mac_group_init+0x688>
                }
                
                pmac_info->pmac_group = pmac_group;
   38754:	e0bffe17 	ldw	r2,-8(fp)
   38758:	e0fffd17 	ldw	r3,-12(fp)
   3875c:	10c00315 	stw	r3,12(r2)
                
                pmac_info->pphy_info = 0;
   38760:	e0bffe17 	ldw	r2,-8(fp)
   38764:	10000115 	stw	zero,4(r2)
                
                pmac_info->psys_info = &tse_mac_device[i + j];
   38768:	e0fffc07 	ldb	r3,-16(fp)
   3876c:	e0bffc47 	ldb	r2,-15(fp)
   38770:	1885883a 	add	r2,r3,r2
   38774:	10c01224 	muli	r3,r2,72
   38778:	00800134 	movhi	r2,4
   3877c:	10952c04 	addi	r2,r2,21680
   38780:	1887883a 	add	r3,r3,r2
   38784:	e0bffe17 	ldw	r2,-8(fp)
   38788:	10c00215 	stw	r3,8(r2)
                
                /* check to make sure the alt_tse_system_info defined correctly or has been defined */
                if((pmac_info->psys_info->tse_sgdma_tx == 0) || (pmac_info->psys_info->tse_sgdma_rx == 0)){                	
   3878c:	e0bffe17 	ldw	r2,-8(fp)
   38790:	10800217 	ldw	r2,8(r2)
   38794:	10800517 	ldw	r2,20(r2)
   38798:	10000426 	beq	r2,zero,387ac <alt_tse_mac_group_init+0x220>
   3879c:	e0bffe17 	ldw	r2,-8(fp)
   387a0:	10800217 	ldw	r2,8(r2)
   387a4:	10800617 	ldw	r2,24(r2)
   387a8:	1000091e 	bne	r2,zero,387d0 <alt_tse_mac_group_init+0x244>
                    tse_dprintf(2, "ERROR   : tse_mac_device[%d] does not defined correctly!\n", i + j);
   387ac:	e0fffc07 	ldb	r3,-16(fp)
   387b0:	e0bffc47 	ldb	r2,-15(fp)
   387b4:	1885883a 	add	r2,r3,r2
   387b8:	01000134 	movhi	r4,4
   387bc:	21083604 	addi	r4,r4,8408
   387c0:	100b883a 	mov	r5,r2
   387c4:	00044740 	call	4474 <printf>
                    return ALTERA_TSE_SYSTEM_DEF_ERROR;
   387c8:	00bfffc4 	movi	r2,-1
   387cc:	00011106 	br	38c14 <alt_tse_mac_group_init+0x688>
                }
                
                /* MAC type detection */
                if(pmac_info->psys_info->tse_en_maclite) {
   387d0:	e0bffe17 	ldw	r2,-8(fp)
   387d4:	10800217 	ldw	r2,8(r2)
   387d8:	10800243 	ldbu	r2,9(r2)
   387dc:	10803fcc 	andi	r2,r2,255
   387e0:	10000d26 	beq	r2,zero,38818 <alt_tse_mac_group_init+0x28c>
                    if(pmac_info->psys_info->tse_maclite_gige) {
   387e4:	e0bffe17 	ldw	r2,-8(fp)
   387e8:	10800217 	ldw	r2,8(r2)
   387ec:	10800283 	ldbu	r2,10(r2)
   387f0:	10803fcc 	andi	r2,r2,255
   387f4:	10000426 	beq	r2,zero,38808 <alt_tse_mac_group_init+0x27c>
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_1000;
   387f8:	e0bffe17 	ldw	r2,-8(fp)
   387fc:	00c00084 	movi	r3,2
   38800:	10c00005 	stb	r3,0(r2)
   38804:	00000606 	br	38820 <alt_tse_mac_group_init+0x294>
                    }
                    else {
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_10_100;
   38808:	e0bffe17 	ldw	r2,-8(fp)
   3880c:	00c00044 	movi	r3,1
   38810:	10c00005 	stb	r3,0(r2)
   38814:	00000206 	br	38820 <alt_tse_mac_group_init+0x294>
                    }
                }
                else {
                    pmac_info->mac_type = ALTERA_TSE_FULL_MAC;                    
   38818:	e0bffe17 	ldw	r2,-8(fp)
   3881c:	10000005 	stb	zero,0(r2)
                }
                
                if((pmac_info->psys_info->tse_mdio_shared) && (!pmac_info->psys_info->tse_multichannel_mac)){
   38820:	e0bffe17 	ldw	r2,-8(fp)
   38824:	10800217 	ldw	r2,8(r2)
   38828:	10800343 	ldbu	r2,13(r2)
   3882c:	10803fcc 	andi	r2,r2,255
   38830:	10006526 	beq	r2,zero,389c8 <alt_tse_mac_group_init+0x43c>
   38834:	e0bffe17 	ldw	r2,-8(fp)
   38838:	10800217 	ldw	r2,8(r2)
   3883c:	108002c3 	ldbu	r2,11(r2)
   38840:	10803fcc 	andi	r2,r2,255
   38844:	1000601e 	bne	r2,zero,389c8 <alt_tse_mac_group_init+0x43c>
                	tse_dprintf(6, "INFO    : MAC %2d Address           = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
   38848:	e0fffc47 	ldb	r3,-15(fp)
   3884c:	e0bffe17 	ldw	r2,-8(fp)
   38850:	10800217 	ldw	r2,8(r2)
   38854:	10800017 	ldw	r2,0(r2)
   38858:	01000134 	movhi	r4,4
   3885c:	21084504 	addi	r4,r4,8468
   38860:	180b883a 	mov	r5,r3
   38864:	100d883a 	mov	r6,r2
   38868:	0035f380 	call	35f38 <no_printf>
                    tse_dprintf(6, "INFO    : MAC %2d Device            = tse_mac_device[%d]\n", j, i + j);
   3886c:	e0fffc47 	ldb	r3,-15(fp)
   38870:	e13ffc07 	ldb	r4,-16(fp)
   38874:	e0bffc47 	ldb	r2,-15(fp)
   38878:	2085883a 	add	r2,r4,r2
   3887c:	01000134 	movhi	r4,4
   38880:	21085104 	addi	r4,r4,8516
   38884:	180b883a 	mov	r5,r3
   38888:	100d883a 	mov	r6,r2
   3888c:	0035f380 	call	35f38 <no_printf>
                    
                	switch(pmac_info->mac_type) {
   38890:	e0bffe17 	ldw	r2,-8(fp)
   38894:	10800003 	ldbu	r2,0(r2)
   38898:	10803fcc 	andi	r2,r2,255
   3889c:	10c00060 	cmpeqi	r3,r2,1
   388a0:	18000c1e 	bne	r3,zero,388d4 <alt_tse_mac_group_init+0x348>
   388a4:	10c000a0 	cmpeqi	r3,r2,2
   388a8:	1800021e 	bne	r3,zero,388b4 <alt_tse_mac_group_init+0x328>
   388ac:	10001126 	beq	r2,zero,388f4 <alt_tse_mac_group_init+0x368>
   388b0:	00001806 	br	38914 <alt_tse_mac_group_init+0x388>
                        case ALTERA_TSE_MACLITE_1000:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "1000 Mbps Small MAC");
   388b4:	e0bffc47 	ldb	r2,-15(fp)
   388b8:	01000134 	movhi	r4,4
   388bc:	21086004 	addi	r4,r4,8576
   388c0:	100b883a 	mov	r5,r2
   388c4:	01800134 	movhi	r6,4
   388c8:	31886b04 	addi	r6,r6,8620
   388cc:	0035f380 	call	35f38 <no_printf>
                            break;
   388d0:	00001706 	br	38930 <alt_tse_mac_group_init+0x3a4>
                        case ALTERA_TSE_MACLITE_10_100:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100 Mbps Small MAC");
   388d4:	e0bffc47 	ldb	r2,-15(fp)
   388d8:	01000134 	movhi	r4,4
   388dc:	21086004 	addi	r4,r4,8576
   388e0:	100b883a 	mov	r5,r2
   388e4:	01800134 	movhi	r6,4
   388e8:	31887004 	addi	r6,r6,8640
   388ec:	0035f380 	call	35f38 <no_printf>
                            break;
   388f0:	00000f06 	br	38930 <alt_tse_mac_group_init+0x3a4>
                        case ALTERA_TSE_FULL_MAC:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100/1000 Ethernet MAC");
   388f4:	e0bffc47 	ldb	r2,-15(fp)
   388f8:	01000134 	movhi	r4,4
   388fc:	21086004 	addi	r4,r4,8576
   38900:	100b883a 	mov	r5,r2
   38904:	01800134 	movhi	r6,4
   38908:	31887604 	addi	r6,r6,8664
   3890c:	0035f380 	call	35f38 <no_printf>
                            break;
   38910:	00000706 	br	38930 <alt_tse_mac_group_init+0x3a4>
                        default :
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "Unknown");
   38914:	e0bffc47 	ldb	r2,-15(fp)
   38918:	01000134 	movhi	r4,4
   3891c:	21086004 	addi	r4,r4,8576
   38920:	100b883a 	mov	r5,r2
   38924:	01800134 	movhi	r6,4
   38928:	3186ae04 	addi	r6,r6,6840
   3892c:	0035f380 	call	35f38 <no_printf>
                    }
                    
                    if(pmac_info->psys_info->tse_pcs_ena) {
   38930:	e0bffe17 	ldw	r2,-8(fp)
   38934:	10800217 	ldw	r2,8(r2)
   38938:	108003c3 	ldbu	r2,15(r2)
   3893c:	10803fcc 	andi	r2,r2,255
   38940:	10008a26 	beq	r2,zero,38b6c <alt_tse_mac_group_init+0x5e0>
                        tse_dprintf(6, "INFO    : PCS %2d Enable            = %s\n", j, pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
   38944:	e0fffc47 	ldb	r3,-15(fp)
   38948:	e0bffe17 	ldw	r2,-8(fp)
   3894c:	10800217 	ldw	r2,8(r2)
   38950:	108003c3 	ldbu	r2,15(r2)
   38954:	10803fcc 	andi	r2,r2,255
   38958:	10000326 	beq	r2,zero,38968 <alt_tse_mac_group_init+0x3dc>
   3895c:	00800134 	movhi	r2,4
   38960:	10887d04 	addi	r2,r2,8692
   38964:	00000206 	br	38970 <alt_tse_mac_group_init+0x3e4>
   38968:	00800134 	movhi	r2,4
   3896c:	10887e04 	addi	r2,r2,8696
   38970:	01000134 	movhi	r4,4
   38974:	21087f04 	addi	r4,r4,8700
   38978:	180b883a 	mov	r5,r3
   3897c:	100d883a 	mov	r6,r2
   38980:	0035f380 	call	35f38 <no_printf>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
   38984:	e0fffc47 	ldb	r3,-15(fp)
   38988:	e0bffe17 	ldw	r2,-8(fp)
   3898c:	10800217 	ldw	r2,8(r2)
   38990:	10800403 	ldbu	r2,16(r2)
   38994:	10803fcc 	andi	r2,r2,255
   38998:	10000326 	beq	r2,zero,389a8 <alt_tse_mac_group_init+0x41c>
   3899c:	00800134 	movhi	r2,4
   389a0:	10887d04 	addi	r2,r2,8692
   389a4:	00000206 	br	389b0 <alt_tse_mac_group_init+0x424>
   389a8:	00800134 	movhi	r2,4
   389ac:	10887e04 	addi	r2,r2,8696
   389b0:	01000134 	movhi	r4,4
   389b4:	21088a04 	addi	r4,r4,8744
   389b8:	180b883a 	mov	r5,r3
   389bc:	100d883a 	mov	r6,r2
   389c0:	0035f380 	call	35f38 <no_printf>
                            break;
                        default :
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "Unknown");
                    }
                    
                    if(pmac_info->psys_info->tse_pcs_ena) {
   389c4:	00006906 	br	38b6c <alt_tse_mac_group_init+0x5e0>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
                    }
                }
                else {
                	/* display only once for all MAC, except shared MDIO MACs */
	                if(j == 0) {
   389c8:	e0bffc47 	ldb	r2,-15(fp)
   389cc:	1000411e 	bne	r2,zero,38ad4 <alt_tse_mac_group_init+0x548>
	                    switch(pmac_info->mac_type) {
   389d0:	e0bffe17 	ldw	r2,-8(fp)
   389d4:	10800003 	ldbu	r2,0(r2)
   389d8:	10803fcc 	andi	r2,r2,255
   389dc:	10c00060 	cmpeqi	r3,r2,1
   389e0:	18000a1e 	bne	r3,zero,38a0c <alt_tse_mac_group_init+0x480>
   389e4:	10c000a0 	cmpeqi	r3,r2,2
   389e8:	1800021e 	bne	r3,zero,389f4 <alt_tse_mac_group_init+0x468>
   389ec:	10000d26 	beq	r2,zero,38a24 <alt_tse_mac_group_init+0x498>
   389f0:	00001206 	br	38a3c <alt_tse_mac_group_init+0x4b0>
	                        case ALTERA_TSE_MACLITE_1000:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "1000 Mbps Small MAC");
   389f4:	01000134 	movhi	r4,4
   389f8:	21089504 	addi	r4,r4,8788
   389fc:	01400134 	movhi	r5,4
   38a00:	29486b04 	addi	r5,r5,8620
   38a04:	0035f380 	call	35f38 <no_printf>
	                            break;
   38a08:	00001106 	br	38a50 <alt_tse_mac_group_init+0x4c4>
	                        case ALTERA_TSE_MACLITE_10_100:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100 Mbps Small MAC");
   38a0c:	01000134 	movhi	r4,4
   38a10:	21089504 	addi	r4,r4,8788
   38a14:	01400134 	movhi	r5,4
   38a18:	29487004 	addi	r5,r5,8640
   38a1c:	0035f380 	call	35f38 <no_printf>
	                            break;
   38a20:	00000b06 	br	38a50 <alt_tse_mac_group_init+0x4c4>
	                        case ALTERA_TSE_FULL_MAC:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100/1000 Ethernet MAC");
   38a24:	01000134 	movhi	r4,4
   38a28:	21089504 	addi	r4,r4,8788
   38a2c:	01400134 	movhi	r5,4
   38a30:	29487604 	addi	r5,r5,8664
   38a34:	0035f380 	call	35f38 <no_printf>
	                            break;
   38a38:	00000506 	br	38a50 <alt_tse_mac_group_init+0x4c4>
	                        default :
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "Unknown");
   38a3c:	01000134 	movhi	r4,4
   38a40:	21089504 	addi	r4,r4,8788
   38a44:	01400134 	movhi	r5,4
   38a48:	2946ae04 	addi	r5,r5,6840
   38a4c:	0035f380 	call	35f38 <no_printf>
	                    }
	                    
	                    if(pmac_info->psys_info->tse_pcs_ena) {
   38a50:	e0bffe17 	ldw	r2,-8(fp)
   38a54:	10800217 	ldw	r2,8(r2)
   38a58:	108003c3 	ldbu	r2,15(r2)
   38a5c:	10803fcc 	andi	r2,r2,255
   38a60:	10001c26 	beq	r2,zero,38ad4 <alt_tse_mac_group_init+0x548>
	                        tse_dprintf(6, "INFO    : PCS Enable               = %s\n", pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
   38a64:	e0bffe17 	ldw	r2,-8(fp)
   38a68:	10800217 	ldw	r2,8(r2)
   38a6c:	108003c3 	ldbu	r2,15(r2)
   38a70:	10803fcc 	andi	r2,r2,255
   38a74:	10000326 	beq	r2,zero,38a84 <alt_tse_mac_group_init+0x4f8>
   38a78:	00800134 	movhi	r2,4
   38a7c:	10887d04 	addi	r2,r2,8692
   38a80:	00000206 	br	38a8c <alt_tse_mac_group_init+0x500>
   38a84:	00800134 	movhi	r2,4
   38a88:	10887e04 	addi	r2,r2,8696
   38a8c:	01000134 	movhi	r4,4
   38a90:	2108a004 	addi	r4,r4,8832
   38a94:	100b883a 	mov	r5,r2
   38a98:	0035f380 	call	35f38 <no_printf>
	                        tse_dprintf(6, "INFO    : PCS SGMII Enable         = %s\n", pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");	                        
   38a9c:	e0bffe17 	ldw	r2,-8(fp)
   38aa0:	10800217 	ldw	r2,8(r2)
   38aa4:	10800403 	ldbu	r2,16(r2)
   38aa8:	10803fcc 	andi	r2,r2,255
   38aac:	10000326 	beq	r2,zero,38abc <alt_tse_mac_group_init+0x530>
   38ab0:	00800134 	movhi	r2,4
   38ab4:	10887d04 	addi	r2,r2,8692
   38ab8:	00000206 	br	38ac4 <alt_tse_mac_group_init+0x538>
   38abc:	00800134 	movhi	r2,4
   38ac0:	10887e04 	addi	r2,r2,8696
   38ac4:	01000134 	movhi	r4,4
   38ac8:	2108ab04 	addi	r4,r4,8876
   38acc:	100b883a 	mov	r5,r2
   38ad0:	0035f380 	call	35f38 <no_printf>
	                    }
	                }
	                
                	if(pmac_info->psys_info->tse_multichannel_mac) {
   38ad4:	e0bffe17 	ldw	r2,-8(fp)
   38ad8:	10800217 	ldw	r2,8(r2)
   38adc:	108002c3 	ldbu	r2,11(r2)
   38ae0:	10803fcc 	andi	r2,r2,255
   38ae4:	10001326 	beq	r2,zero,38b34 <alt_tse_mac_group_init+0x5a8>
                		tse_dprintf(6, "INFO    : Channel %2d Address       = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
   38ae8:	e0fffc47 	ldb	r3,-15(fp)
   38aec:	e0bffe17 	ldw	r2,-8(fp)
   38af0:	10800217 	ldw	r2,8(r2)
   38af4:	10800017 	ldw	r2,0(r2)
   38af8:	01000134 	movhi	r4,4
   38afc:	2108b604 	addi	r4,r4,8920
   38b00:	180b883a 	mov	r5,r3
   38b04:	100d883a 	mov	r6,r2
   38b08:	0035f380 	call	35f38 <no_printf>
	                    tse_dprintf(6, "INFO    : Channel %2d Device        = tse_mac_device[%d]\n", j, i + j);
   38b0c:	e0fffc47 	ldb	r3,-15(fp)
   38b10:	e13ffc07 	ldb	r4,-16(fp)
   38b14:	e0bffc47 	ldb	r2,-15(fp)
   38b18:	2085883a 	add	r2,r4,r2
   38b1c:	01000134 	movhi	r4,4
   38b20:	2108c204 	addi	r4,r4,8968
   38b24:	180b883a 	mov	r5,r3
   38b28:	100d883a 	mov	r6,r2
   38b2c:	0035f380 	call	35f38 <no_printf>
   38b30:	00000e06 	br	38b6c <alt_tse_mac_group_init+0x5e0>
	            	}                
	                else {
	                    tse_dprintf(6, "INFO    : MAC Address              = 0x%08x\n", (int) pmac_info->psys_info->tse_mac_base);
   38b34:	e0bffe17 	ldw	r2,-8(fp)
   38b38:	10800217 	ldw	r2,8(r2)
   38b3c:	10800017 	ldw	r2,0(r2)
   38b40:	01000134 	movhi	r4,4
   38b44:	2108d104 	addi	r4,r4,9028
   38b48:	100b883a 	mov	r5,r2
   38b4c:	0035f380 	call	35f38 <no_printf>
	                    tse_dprintf(6, "INFO    : MAC Device               = tse_mac_device[%d]\n", i + j);
   38b50:	e0fffc07 	ldb	r3,-16(fp)
   38b54:	e0bffc47 	ldb	r2,-15(fp)
   38b58:	1885883a 	add	r2,r3,r2
   38b5c:	01000134 	movhi	r4,4
   38b60:	2108dd04 	addi	r4,r4,9076
   38b64:	100b883a 	mov	r5,r2
   38b68:	0035f380 	call	35f38 <no_printf>
	                }
                }
                
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
   38b6c:	e0bffc47 	ldb	r2,-15(fp)
   38b70:	e0fffd17 	ldw	r3,-12(fp)
   38b74:	10800044 	addi	r2,r2,1
   38b78:	1085883a 	add	r2,r2,r2
   38b7c:	1085883a 	add	r2,r2,r2
   38b80:	1885883a 	add	r2,r3,r2
   38b84:	e0fffe17 	ldw	r3,-8(fp)
   38b88:	10c00015 	stw	r3,0(r2)
                pmac_group->channel = 1;
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
   38b8c:	e0bffc43 	ldbu	r2,-15(fp)
   38b90:	10800044 	addi	r2,r2,1
   38b94:	e0bffc45 	stb	r2,-15(fp)
   38b98:	e0fffc47 	ldb	r3,-15(fp)
   38b9c:	e0bffd17 	ldw	r2,-12(fp)
   38ba0:	10800003 	ldbu	r2,0(r2)
   38ba4:	10803fcc 	andi	r2,r2,255
   38ba8:	18bedb16 	blt	r3,r2,38718 <alt_tse_mac_group_init+0x18c>
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
            }
            
            /* store the pointer in global variable */
            pmac_groups[mac_group_count] = pmac_group;
   38bac:	d0a94743 	ldbu	r2,-23267(gp)
   38bb0:	10803fcc 	andi	r2,r2,255
   38bb4:	00c001f4 	movhi	r3,7
   38bb8:	18ed0b04 	addi	r3,r3,-19412
   38bbc:	1085883a 	add	r2,r2,r2
   38bc0:	1085883a 	add	r2,r2,r2
   38bc4:	1885883a 	add	r2,r3,r2
   38bc8:	e0fffd17 	ldw	r3,-12(fp)
   38bcc:	10c00015 	stw	r3,0(r2)
            
            mac_group_count++;
   38bd0:	d0a94743 	ldbu	r2,-23267(gp)
   38bd4:	10800044 	addi	r2,r2,1
   38bd8:	d0a94745 	stb	r2,-23267(gp)

            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
   38bdc:	e0bffd17 	ldw	r2,-12(fp)
   38be0:	10c00003 	ldbu	r3,0(r2)
   38be4:	e0bffc03 	ldbu	r2,-16(fp)
   38be8:	1885883a 	add	r2,r3,r2
   38bec:	10bfffc4 	addi	r2,r2,-1
   38bf0:	e0bffc05 	stb	r2,-16(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
   38bf4:	e0bffc03 	ldbu	r2,-16(fp)
   38bf8:	10800044 	addi	r2,r2,1
   38bfc:	e0bffc05 	stb	r2,-16(fp)
   38c00:	e0fffc07 	ldb	r3,-16(fp)
   38c04:	d0a01c03 	ldbu	r2,-32656(gp)
   38c08:	10803fcc 	andi	r2,r2,255
   38c0c:	18be6916 	blt	r3,r2,385b4 <alt_tse_mac_group_init+0x28>
            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
                        
        }
    }
    return SUCCESS;
   38c10:	0005883a 	mov	r2,zero
}
   38c14:	e037883a 	mov	sp,fp
   38c18:	dfc00117 	ldw	ra,4(sp)
   38c1c:	df000017 	ldw	fp,0(sp)
   38c20:	dec00204 	addi	sp,sp,8
   38c24:	f800283a 	ret

00038c28 <alt_tse_mac_get_phy>:
/* @Function Description: Store information of all the PHYs connected to MAC to phy_list
 * @API Type:         Internal
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @return            Number of PHY not in profile, return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 */
alt_32 alt_tse_mac_get_phy(alt_tse_mac_group *pmac_group) {
   38c28:	deffed04 	addi	sp,sp,-76
   38c2c:	dfc01215 	stw	ra,72(sp)
   38c30:	df001115 	stw	fp,68(sp)
   38c34:	df001104 	addi	fp,sp,68
   38c38:	e13fff15 	stw	r4,-4(fp)
    
	alt_32 phyid; 
	alt_32 phyid2 = 0;
   38c3c:	e03ff515 	stw	zero,-44(fp)
    alt_u8 revision_number;

    alt_32 i;

    alt_u8 is_phy_in_profile;
    alt_32 return_value = 0;
   38c40:	e03ff315 	stw	zero,-52(fp)
    
    alt_8 phy_info_count = 0;
   38c44:	e03ff405 	stb	zero,-48(fp)
    
    alt_tse_phy_info *pphy = 0;
   38c48:	e03ff615 	stw	zero,-40(fp)
    alt_tse_mac_info *pmac_info = 0;
   38c4c:	e03ff715 	stw	zero,-36(fp)
    alt_tse_system_info *psys = 0;
   38c50:	e03ff815 	stw	zero,-32(fp)
    
    np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   38c54:	e0bfff17 	ldw	r2,-4(fp)
   38c58:	10800117 	ldw	r2,4(r2)
   38c5c:	10800217 	ldw	r2,8(r2)
   38c60:	10800017 	ldw	r2,0(r2)
   38c64:	e0bff915 	stw	r2,-28(fp)
            
    /* Record previous MDIO address, to be restored at the end of function */
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
   38c68:	e0bff917 	ldw	r2,-28(fp)
   38c6c:	10801004 	addi	r2,r2,64
   38c70:	10800037 	ldwio	r2,0(r2)
   38c74:	e0bffa15 	stw	r2,-24(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   38c78:	e13fff17 	ldw	r4,-4(fp)
   38c7c:	00370ac0 	call	370ac <alt_tse_get_mac_group_index>
   38c80:	e0bffb05 	stb	r2,-20(fp)
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x00; phyadd < 0x20; phyadd++)
   38c84:	e03ff005 	stb	zero,-64(fp)
   38c88:	0000c906 	br	38fb0 <alt_tse_mac_get_phy+0x388>
    {        
        IOWR(&pmac_group_base->MDIO_ADDR1, 0, phyadd);
   38c8c:	e0bff917 	ldw	r2,-28(fp)
   38c90:	10801004 	addi	r2,r2,64
   38c94:	e0fff003 	ldbu	r3,-64(fp)
   38c98:	10c00035 	stwio	r3,0(r2)
        phyid = IORD(&pmac_group_base->mdio1.PHY_ID1,0);     // read PHY ID
   38c9c:	e0bff917 	ldw	r2,-28(fp)
   38ca0:	1080a204 	addi	r2,r2,648
   38ca4:	10800037 	ldwio	r2,0(r2)
   38ca8:	e0bffc15 	stw	r2,-16(fp)
        phyid2 = IORD(&pmac_group_base->mdio1.PHY_ID2,0);     // read PHY ID
   38cac:	e0bff917 	ldw	r2,-28(fp)
   38cb0:	1080a304 	addi	r2,r2,652
   38cb4:	10800037 	ldwio	r2,0(r2)
   38cb8:	e0bff515 	stw	r2,-44(fp)
        
        /* PHY found */
        if (phyid != phyid2)
   38cbc:	e0fffc17 	ldw	r3,-16(fp)
   38cc0:	e0bff517 	ldw	r2,-44(fp)
   38cc4:	1880b726 	beq	r3,r2,38fa4 <alt_tse_mac_get_phy+0x37c>
        {
            pphy = (alt_tse_phy_info *) malloc(sizeof(alt_tse_phy_info));
   38cc8:	01000704 	movi	r4,28
   38ccc:	003f1fc0 	call	3f1fc <malloc>
   38cd0:	e0bff615 	stw	r2,-40(fp)
            if(!pphy) {
   38cd4:	e0bff617 	ldw	r2,-40(fp)
   38cd8:	1000091e 	bne	r2,zero,38d00 <alt_tse_mac_get_phy+0xd8>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for phy_info[%d.%d]\n", mac_group_index, phy_info_count);
   38cdc:	e0fffb07 	ldb	r3,-20(fp)
   38ce0:	e0bff407 	ldb	r2,-48(fp)
   38ce4:	01000134 	movhi	r4,4
   38ce8:	2108ec04 	addi	r4,r4,9136
   38cec:	180b883a 	mov	r5,r3
   38cf0:	100d883a 	mov	r6,r2
   38cf4:	00044740 	call	4474 <printf>
                return ALTERA_TSE_MALLOC_FAILED;
   38cf8:	00bfffc4 	movi	r2,-1
   38cfc:	0000cb06 	br	3902c <alt_tse_mac_get_phy+0x404>
            }
            
            /* store PHY address */
            pphy->mdio_address = phyadd;
   38d00:	e0bff617 	ldw	r2,-40(fp)
   38d04:	e0fff003 	ldbu	r3,-64(fp)
   38d08:	10c00005 	stb	r3,0(r2)

            /* get oui, model number, and revision number from PHYID and PHYID2 */
            oui = (phyid << 6) | ((phyid2 >> 10) & 0x3f);
   38d0c:	e0bffc17 	ldw	r2,-16(fp)
   38d10:	100691ba 	slli	r3,r2,6
   38d14:	e0bff517 	ldw	r2,-44(fp)
   38d18:	1005d2ba 	srai	r2,r2,10
   38d1c:	10800fcc 	andi	r2,r2,63
   38d20:	1884b03a 	or	r2,r3,r2
   38d24:	e0bffd15 	stw	r2,-12(fp)
            model_number = (phyid2 >> 4) & 0x3f;
   38d28:	e0bff517 	ldw	r2,-44(fp)
   38d2c:	1005d13a 	srai	r2,r2,4
   38d30:	10800fcc 	andi	r2,r2,63
   38d34:	e0bffe05 	stb	r2,-8(fp)
            revision_number = phyid2 & 0x0f;
   38d38:	e0bff517 	ldw	r2,-44(fp)
   38d3c:	108003cc 	andi	r2,r2,15
   38d40:	e0bffe45 	stb	r2,-7(fp)
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
   38d44:	e03ff205 	stb	zero,-56(fp)
            for(i = 0; i < phy_profile_count; i++) {
   38d48:	e03ff115 	stw	zero,-60(fp)
   38d4c:	00003306 	br	38e1c <alt_tse_mac_get_phy+0x1f4>
                
                /* if PHY match with PHY in profile */
                if((pphy_profiles[i]->oui == oui) && (pphy_profiles[i]->model_number == model_number))
   38d50:	00c001f4 	movhi	r3,7
   38d54:	18ed1304 	addi	r3,r3,-19380
   38d58:	e0bff117 	ldw	r2,-60(fp)
   38d5c:	1085883a 	add	r2,r2,r2
   38d60:	1085883a 	add	r2,r2,r2
   38d64:	1885883a 	add	r2,r3,r2
   38d68:	10800017 	ldw	r2,0(r2)
   38d6c:	10c01417 	ldw	r3,80(r2)
   38d70:	e0bffd17 	ldw	r2,-12(fp)
   38d74:	1880261e 	bne	r3,r2,38e10 <alt_tse_mac_get_phy+0x1e8>
   38d78:	00c001f4 	movhi	r3,7
   38d7c:	18ed1304 	addi	r3,r3,-19380
   38d80:	e0bff117 	ldw	r2,-60(fp)
   38d84:	1085883a 	add	r2,r2,r2
   38d88:	1085883a 	add	r2,r2,r2
   38d8c:	1885883a 	add	r2,r3,r2
   38d90:	10800017 	ldw	r2,0(r2)
   38d94:	10801503 	ldbu	r2,84(r2)
   38d98:	10c03fcc 	andi	r3,r2,255
   38d9c:	e0bffe03 	ldbu	r2,-8(fp)
   38da0:	18801b1e 	bne	r3,r2,38e10 <alt_tse_mac_get_phy+0x1e8>
                {
                    pphy->pphy_profile = pphy_profiles[i];
   38da4:	00c001f4 	movhi	r3,7
   38da8:	18ed1304 	addi	r3,r3,-19380
   38dac:	e0bff117 	ldw	r2,-60(fp)
   38db0:	1085883a 	add	r2,r2,r2
   38db4:	1085883a 	add	r2,r2,r2
   38db8:	1885883a 	add	r2,r3,r2
   38dbc:	10c00017 	ldw	r3,0(r2)
   38dc0:	e0bff617 	ldw	r2,-40(fp)
   38dc4:	10c00515 	stw	r3,20(r2)
                    
                    /* PHY found, add it to phy_list */
                    tse_dprintf(5, "INFO    : PHY %s found at PHY address 0x%02x of MAC Group[%d]\n", pphy_profiles[i]->name, phyadd, mac_group_index);
   38dc8:	00c001f4 	movhi	r3,7
   38dcc:	18ed1304 	addi	r3,r3,-19380
   38dd0:	e0bff117 	ldw	r2,-60(fp)
   38dd4:	1085883a 	add	r2,r2,r2
   38dd8:	1085883a 	add	r2,r2,r2
   38ddc:	1885883a 	add	r2,r3,r2
   38de0:	10800017 	ldw	r2,0(r2)
   38de4:	100b883a 	mov	r5,r2
   38de8:	e0fff003 	ldbu	r3,-64(fp)
   38dec:	e0bffb07 	ldb	r2,-20(fp)
   38df0:	01000134 	movhi	r4,4
   38df4:	2108fb04 	addi	r4,r4,9196
   38df8:	180d883a 	mov	r6,r3
   38dfc:	100f883a 	mov	r7,r2
   38e00:	00044740 	call	4474 <printf>
                    is_phy_in_profile = 1;
   38e04:	00800044 	movi	r2,1
   38e08:	e0bff205 	stb	r2,-56(fp)
                    break;
   38e0c:	00000706 	br	38e2c <alt_tse_mac_get_phy+0x204>
            model_number = (phyid2 >> 4) & 0x3f;
            revision_number = phyid2 & 0x0f;
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
            for(i = 0; i < phy_profile_count; i++) {
   38e10:	e0bff117 	ldw	r2,-60(fp)
   38e14:	10800044 	addi	r2,r2,1
   38e18:	e0bff115 	stw	r2,-60(fp)
   38e1c:	d0a94703 	ldbu	r2,-23268(gp)
   38e20:	10803fcc 	andi	r2,r2,255
   38e24:	e0fff117 	ldw	r3,-60(fp)
   38e28:	18bfc916 	blt	r3,r2,38d50 <alt_tse_mac_get_phy+0x128>
                    is_phy_in_profile = 1;
                    break;
                }
            }
            /* PHY not found in PHY profile */
            if(is_phy_in_profile == 0) {
   38e2c:	e0bff203 	ldbu	r2,-56(fp)
   38e30:	10000f1e 	bne	r2,zero,38e70 <alt_tse_mac_get_phy+0x248>
                pphy->pphy_profile = 0;
   38e34:	e0bff617 	ldw	r2,-40(fp)
   38e38:	10000515 	stw	zero,20(r2)
                tse_dprintf(3, "WARNING : Unknown PHY found at PHY address 0x%02x of MAC Group[%d]\n", phyadd, mac_group_index);
   38e3c:	e0fff003 	ldbu	r3,-64(fp)
   38e40:	e0bffb07 	ldb	r2,-20(fp)
   38e44:	01000134 	movhi	r4,4
   38e48:	21090b04 	addi	r4,r4,9260
   38e4c:	180b883a 	mov	r5,r3
   38e50:	100d883a 	mov	r6,r2
   38e54:	00044740 	call	4474 <printf>
                tse_dprintf(3, "WARNING : Please add PHY information to PHY profile\n");
   38e58:	01000134 	movhi	r4,4
   38e5c:	21091c04 	addi	r4,r4,9328
   38e60:	00045340 	call	4534 <puts>
                return_value++;
   38e64:	e0bff317 	ldw	r2,-52(fp)
   38e68:	10800044 	addi	r2,r2,1
   38e6c:	e0bff315 	stw	r2,-52(fp)
            }
            
            tse_dprintf(6, "INFO    : PHY OUI             =  0x%06x\n", (int) oui);
   38e70:	e0bffd17 	ldw	r2,-12(fp)
   38e74:	01000134 	movhi	r4,4
   38e78:	21092904 	addi	r4,r4,9380
   38e7c:	100b883a 	mov	r5,r2
   38e80:	0035f380 	call	35f38 <no_printf>
            tse_dprintf(6, "INFO    : PHY Model Number    =  0x%02x\n", model_number);
   38e84:	e0bffe03 	ldbu	r2,-8(fp)
   38e88:	01000134 	movhi	r4,4
   38e8c:	21093404 	addi	r4,r4,9424
   38e90:	100b883a 	mov	r5,r2
   38e94:	0035f380 	call	35f38 <no_printf>
            tse_dprintf(6, "INFO    : PHY Revision Number =  0x%01x\n", revision_number);
   38e98:	e0bffe43 	ldbu	r2,-7(fp)
   38e9c:	01000134 	movhi	r4,4
   38ea0:	21093f04 	addi	r4,r4,9468
   38ea4:	100b883a 	mov	r5,r2
   38ea8:	0035f380 	call	35f38 <no_printf>
            
            /* map the detected PHY to connected MAC */
            if(alt_tse_mac_associate_phy(pmac_group, pphy) == TSE_PHY_MAP_SUCCESS) {
   38eac:	e13fff17 	ldw	r4,-4(fp)
   38eb0:	e17ff617 	ldw	r5,-40(fp)
   38eb4:	00390400 	call	39040 <alt_tse_mac_associate_phy>
   38eb8:	1000341e 	bne	r2,zero,38f8c <alt_tse_mac_get_phy+0x364>
            	
            	pmac_info = pphy->pmac_info;
   38ebc:	e0bff617 	ldw	r2,-40(fp)
   38ec0:	10800617 	ldw	r2,24(r2)
   38ec4:	e0bff715 	stw	r2,-36(fp)
            	psys = pmac_info->psys_info;
   38ec8:	e0bff717 	ldw	r2,-36(fp)
   38ecc:	10800217 	ldw	r2,8(r2)
   38ed0:	e0bff815 	stw	r2,-32(fp)
            	
            	/* Disable PHY loopback to allow Auto-Negotiation completed */
    	        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
   38ed4:	d8000015 	stw	zero,0(sp)
   38ed8:	e13ff617 	ldw	r4,-40(fp)
   38edc:	000b883a 	mov	r5,zero
   38ee0:	01800384 	movi	r6,14
   38ee4:	01c00044 	movi	r7,1
   38ee8:	0037eec0 	call	37eec <alt_tse_phy_wr_mdio_reg>
				
				/* Reset auto-negotiation advertisement */
				alt_tse_phy_set_adv_1000(pphy, 1);
   38eec:	e13ff617 	ldw	r4,-40(fp)
   38ef0:	01400044 	movi	r5,1
   38ef4:	0039d780 	call	39d78 <alt_tse_phy_set_adv_1000>
				alt_tse_phy_set_adv_100(pphy, 1);
   38ef8:	e13ff617 	ldw	r4,-40(fp)
   38efc:	01400044 	movi	r5,1
   38f00:	0039f340 	call	39f34 <alt_tse_phy_set_adv_100>
				alt_tse_phy_set_adv_10(pphy, 1);
   38f04:	e13ff617 	ldw	r4,-40(fp)
   38f08:	01400044 	movi	r5,1
   38f0c:	003a17c0 	call	3a17c <alt_tse_phy_set_adv_10>
            	            	
	            /* check link connection for this PHY */
	            alt_tse_phy_restart_an(pphy, ALTERA_CHECKLINK_TIMEOUT_THRESHOLD);
   38f10:	e13ff617 	ldw	r4,-40(fp)
   38f14:	0149c404 	movi	r5,10000
   38f18:	00394c00 	call	394c0 <alt_tse_phy_restart_an>
	            
	            /* Perform additional setting if there is any */
	            /* Profile specific */
	            if(pphy->pphy_profile) {
   38f1c:	e0bff617 	ldw	r2,-40(fp)
   38f20:	10800517 	ldw	r2,20(r2)
   38f24:	10000f26 	beq	r2,zero,38f64 <alt_tse_mac_get_phy+0x33c>
		            if(pphy->pphy_profile->phy_cfg) {
   38f28:	e0bff617 	ldw	r2,-40(fp)
   38f2c:	10800517 	ldw	r2,20(r2)
   38f30:	10801717 	ldw	r2,92(r2)
   38f34:	10000b26 	beq	r2,zero,38f64 <alt_tse_mac_get_phy+0x33c>
		                tse_dprintf(6, "INFO    : Applying additional PHY configuration of %s\n", pphy->pphy_profile->name);
   38f38:	e0bff617 	ldw	r2,-40(fp)
   38f3c:	10800517 	ldw	r2,20(r2)
   38f40:	01000134 	movhi	r4,4
   38f44:	21094a04 	addi	r4,r4,9512
   38f48:	100b883a 	mov	r5,r2
   38f4c:	0035f380 	call	35f38 <no_printf>
		                pphy->pphy_profile->phy_cfg(pmac_group_base);
   38f50:	e0bff617 	ldw	r2,-40(fp)
   38f54:	10800517 	ldw	r2,20(r2)
   38f58:	10801717 	ldw	r2,92(r2)
   38f5c:	e13ff917 	ldw	r4,-28(fp)
   38f60:	103ee83a 	callr	r2
		            }
	            }
	            
	            /* Initialize PHY, call user's function pointer in alt_tse_system_info structure */
	            /* Individual PHY specific */
            	if(psys->tse_phy_cfg) {
   38f64:	e0bff817 	ldw	r2,-32(fp)
   38f68:	10801117 	ldw	r2,68(r2)
   38f6c:	10000726 	beq	r2,zero,38f8c <alt_tse_mac_get_phy+0x364>
            		tse_dprintf(6, "INFO    : Applying additional user PHY configuration\n");
   38f70:	01000134 	movhi	r4,4
   38f74:	21095804 	addi	r4,r4,9568
   38f78:	0035f380 	call	35f38 <no_printf>
            		psys->tse_phy_cfg(pmac_group_base);
   38f7c:	e0bff817 	ldw	r2,-32(fp)
   38f80:	10801117 	ldw	r2,68(r2)
   38f84:	e13ff917 	ldw	r4,-28(fp)
   38f88:	103ee83a 	callr	r2
            	}
            }
            
            tse_dprintf(6, "\n");
   38f8c:	01000134 	movhi	r4,4
   38f90:	21096604 	addi	r4,r4,9624
   38f94:	0035f380 	call	35f38 <no_printf>
	            
            phy_info_count++;
   38f98:	e0bff403 	ldbu	r2,-48(fp)
   38f9c:	10800044 	addi	r2,r2,1
   38fa0:	e0bff405 	stb	r2,-48(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x00; phyadd < 0x20; phyadd++)
   38fa4:	e0bff003 	ldbu	r2,-64(fp)
   38fa8:	10800044 	addi	r2,r2,1
   38fac:	e0bff005 	stb	r2,-64(fp)
   38fb0:	e0bff003 	ldbu	r2,-64(fp)
   38fb4:	10800830 	cmpltui	r2,r2,32
   38fb8:	103f341e 	bne	r2,zero,38c8c <alt_tse_mac_get_phy+0x64>
            phy_info_count++;
        }
    }
    
    /* check to verify the number of connected PHY match the number of channel */
    if(pmac_group->channel != phy_info_count) {
   38fbc:	e0bfff17 	ldw	r2,-4(fp)
   38fc0:	10800003 	ldbu	r2,0(r2)
   38fc4:	10c03fcc 	andi	r3,r2,255
   38fc8:	e0bff407 	ldb	r2,-48(fp)
   38fcc:	18801226 	beq	r3,r2,39018 <alt_tse_mac_get_phy+0x3f0>
        if(phy_info_count == 0) {
   38fd0:	e0bff407 	ldb	r2,-48(fp)
   38fd4:	1000061e 	bne	r2,zero,38ff0 <alt_tse_mac_get_phy+0x3c8>
            tse_dprintf(2, "ERROR   : MAC Group[%d] - No PHY connected!\n", mac_group_index);
   38fd8:	e0bffb07 	ldb	r2,-20(fp)
   38fdc:	01000134 	movhi	r4,4
   38fe0:	21096704 	addi	r4,r4,9628
   38fe4:	100b883a 	mov	r5,r2
   38fe8:	00044740 	call	4474 <printf>
   38fec:	00000a06 	br	39018 <alt_tse_mac_get_phy+0x3f0>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Group[%d] - Number of PHY connected is not equal to the number of channel, Number of PHY : %d, Channel : %d\n", mac_group_index, phy_info_count, pmac_group->channel);
   38ff0:	e17ffb07 	ldb	r5,-20(fp)
   38ff4:	e0fff407 	ldb	r3,-48(fp)
   38ff8:	e0bfff17 	ldw	r2,-4(fp)
   38ffc:	10800003 	ldbu	r2,0(r2)
   39000:	10803fcc 	andi	r2,r2,255
   39004:	01000134 	movhi	r4,4
   39008:	21097304 	addi	r4,r4,9676
   3900c:	180d883a 	mov	r6,r3
   39010:	100f883a 	mov	r7,r2
   39014:	00044740 	call	4474 <printf>
        }
    }
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
   39018:	e0bff917 	ldw	r2,-28(fp)
   3901c:	10801004 	addi	r2,r2,64
   39020:	e0fffa17 	ldw	r3,-24(fp)
   39024:	10c00035 	stwio	r3,0(r2)
    
    return return_value;
   39028:	e0bff317 	ldw	r2,-52(fp)
}
   3902c:	e037883a 	mov	sp,fp
   39030:	dfc00117 	ldw	ra,4(sp)
   39034:	df000017 	ldw	fp,0(sp)
   39038:	dec00204 	addi	sp,sp,8
   3903c:	f800283a 	ret

00039040 <alt_tse_mac_associate_phy>:
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @param pphy        Pointer to the TSE PHY info structure which hold information of PHY
 * @return            return TSE_PHY_MAP_ERROR if mapping error
 *                    return TSE_PHY_MAP_SUCCESS otherwise
 */
alt_32 alt_tse_mac_associate_phy(alt_tse_mac_group *pmac_group, alt_tse_phy_info *pphy) {
   39040:	defff604 	addi	sp,sp,-40
   39044:	dfc00915 	stw	ra,36(sp)
   39048:	df000815 	stw	fp,32(sp)
   3904c:	df000804 	addi	fp,sp,32
   39050:	e13ffe15 	stw	r4,-8(fp)
   39054:	e17fff15 	stw	r5,-4(fp)
    
	alt_32 i;
	alt_32 return_value = TSE_PHY_MAP_SUCCESS;
   39058:	e03ff915 	stw	zero,-28(fp)
    
	alt_u8 is_mapped;

    alt_tse_system_info *psys = 0;
   3905c:	e03ffb15 	stw	zero,-20(fp)
    alt_tse_mac_info *pmac_info = 0;
   39060:	e03ffc15 	stw	zero,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
   39064:	e03ffd05 	stb	zero,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   39068:	e13ffe17 	ldw	r4,-8(fp)
   3906c:	00370ac0 	call	370ac <alt_tse_get_mac_group_index>
   39070:	e0bffd45 	stb	r2,-11(fp)
    alt_8 sys_info_index = 0;
   39074:	e03ffd85 	stb	zero,-10(fp)
    
    is_mapped = 0;
   39078:	e03ffa05 	stb	zero,-24(fp)
    
    for(i = 0; i < pmac_group->channel; i++) {
   3907c:	e03ff815 	stw	zero,-32(fp)
   39080:	00002b06 	br	39130 <alt_tse_mac_associate_phy+0xf0>
        pmac_info = pmac_group->pmac_info[i];
   39084:	e0fffe17 	ldw	r3,-8(fp)
   39088:	e0bff817 	ldw	r2,-32(fp)
   3908c:	10800044 	addi	r2,r2,1
   39090:	1085883a 	add	r2,r2,r2
   39094:	1085883a 	add	r2,r2,r2
   39098:	1885883a 	add	r2,r3,r2
   3909c:	10800017 	ldw	r2,0(r2)
   390a0:	e0bffc15 	stw	r2,-16(fp)
        psys = pmac_info->psys_info;
   390a4:	e0bffc17 	ldw	r2,-16(fp)
   390a8:	10800217 	ldw	r2,8(r2)
   390ac:	e0bffb15 	stw	r2,-20(fp)
       
        /* map according to the PHY address in alt_tse_system_info.h */
        if(psys->tse_phy_mdio_address == pphy->mdio_address) {
   390b0:	e0bffb17 	ldw	r2,-20(fp)
   390b4:	10c01017 	ldw	r3,64(r2)
   390b8:	e0bfff17 	ldw	r2,-4(fp)
   390bc:	10800003 	ldbu	r2,0(r2)
   390c0:	10803fcc 	andi	r2,r2,255
   390c4:	1880171e 	bne	r3,r2,39124 <alt_tse_mac_associate_phy+0xe4>
        	mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   390c8:	e13ffc17 	ldw	r4,-16(fp)
   390cc:	00371200 	call	37120 <alt_tse_get_mac_info_index>
   390d0:	e0bffd05 	stb	r2,-12(fp)
	        sys_info_index = alt_tse_get_system_index(psys);
   390d4:	e13ffb17 	ldw	r4,-20(fp)
   390d8:	00370400 	call	37040 <alt_tse_get_system_index>
   390dc:	e0bffd85 	stb	r2,-10(fp)
	        
            pmac_info->pphy_info = pphy;
   390e0:	e0bffc17 	ldw	r2,-16(fp)
   390e4:	e0ffff17 	ldw	r3,-4(fp)
   390e8:	10c00115 	stw	r3,4(r2)
            pphy->pmac_info = pmac_info;
   390ec:	e0bfff17 	ldw	r2,-4(fp)
   390f0:	e0fffc17 	ldw	r3,-16(fp)
   390f4:	10c00615 	stw	r3,24(r2)
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Explicitly mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
   390f8:	e17ffd47 	ldb	r5,-11(fp)
   390fc:	e0fffd07 	ldb	r3,-12(fp)
   39100:	e0bffd87 	ldb	r2,-10(fp)
   39104:	01000134 	movhi	r4,4
   39108:	21099204 	addi	r4,r4,9800
   3910c:	180d883a 	mov	r6,r3
   39110:	100f883a 	mov	r7,r2
   39114:	00044740 	call	4474 <printf>
            is_mapped = 1;
   39118:	00800044 	movi	r2,1
   3911c:	e0bffa05 	stb	r2,-24(fp)
            break;
   39120:	00000806 	br	39144 <alt_tse_mac_associate_phy+0x104>
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    alt_8 sys_info_index = 0;
    
    is_mapped = 0;
    
    for(i = 0; i < pmac_group->channel; i++) {
   39124:	e0bff817 	ldw	r2,-32(fp)
   39128:	10800044 	addi	r2,r2,1
   3912c:	e0bff815 	stw	r2,-32(fp)
   39130:	e0bffe17 	ldw	r2,-8(fp)
   39134:	10800003 	ldbu	r2,0(r2)
   39138:	10803fcc 	andi	r2,r2,255
   3913c:	e0fff817 	ldw	r3,-32(fp)
   39140:	18bfd016 	blt	r3,r2,39084 <alt_tse_mac_associate_phy+0x44>
            break;
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
   39144:	e0bffa03 	ldbu	r2,-24(fp)
   39148:	10003c1e 	bne	r2,zero,3923c <alt_tse_mac_associate_phy+0x1fc>
        for(i = 0; i < pmac_group->channel; i++) {
   3914c:	e03ff815 	stw	zero,-32(fp)
   39150:	00003506 	br	39228 <alt_tse_mac_associate_phy+0x1e8>
            pmac_info = pmac_group->pmac_info[i];
   39154:	e0fffe17 	ldw	r3,-8(fp)
   39158:	e0bff817 	ldw	r2,-32(fp)
   3915c:	10800044 	addi	r2,r2,1
   39160:	1085883a 	add	r2,r2,r2
   39164:	1085883a 	add	r2,r2,r2
   39168:	1885883a 	add	r2,r3,r2
   3916c:	10800017 	ldw	r2,0(r2)
   39170:	e0bffc15 	stw	r2,-16(fp)
            psys = pmac_info->psys_info;
   39174:	e0bffc17 	ldw	r2,-16(fp)
   39178:	10800217 	ldw	r2,8(r2)
   3917c:	e0bffb15 	stw	r2,-20(fp)
            
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
   39180:	e0bffb17 	ldw	r2,-20(fp)
   39184:	10800517 	ldw	r2,20(r2)
   39188:	10002326 	beq	r2,zero,39218 <alt_tse_mac_associate_phy+0x1d8>
   3918c:	e0bffb17 	ldw	r2,-20(fp)
   39190:	10800617 	ldw	r2,24(r2)
   39194:	10002026 	beq	r2,zero,39218 <alt_tse_mac_associate_phy+0x1d8>
            	continue;
            }
            
            if(psys->tse_phy_mdio_address == TSE_PHY_AUTO_ADDRESS) {
   39198:	e0bffb17 	ldw	r2,-20(fp)
   3919c:	10801017 	ldw	r2,64(r2)
   391a0:	10bfffd8 	cmpnei	r2,r2,-1
   391a4:	10001d1e 	bne	r2,zero,3921c <alt_tse_mac_associate_phy+0x1dc>
                mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   391a8:	e13ffc17 	ldw	r4,-16(fp)
   391ac:	00371200 	call	37120 <alt_tse_get_mac_info_index>
   391b0:	e0bffd05 	stb	r2,-12(fp)
                sys_info_index = alt_tse_get_system_index(psys);
   391b4:	e13ffb17 	ldw	r4,-20(fp)
   391b8:	00370400 	call	37040 <alt_tse_get_system_index>
   391bc:	e0bffd85 	stb	r2,-10(fp)
                
                pmac_info->pphy_info = pphy;
   391c0:	e0bffc17 	ldw	r2,-16(fp)
   391c4:	e0ffff17 	ldw	r3,-4(fp)
   391c8:	10c00115 	stw	r3,4(r2)
                pphy->pmac_info = pmac_info;
   391cc:	e0bfff17 	ldw	r2,-4(fp)
   391d0:	e0fffc17 	ldw	r3,-16(fp)
   391d4:	10c00615 	stw	r3,24(r2)
                psys->tse_phy_mdio_address = pphy->mdio_address;
   391d8:	e0bfff17 	ldw	r2,-4(fp)
   391dc:	10800003 	ldbu	r2,0(r2)
   391e0:	10c03fcc 	andi	r3,r2,255
   391e4:	e0bffb17 	ldw	r2,-20(fp)
   391e8:	10c01015 	stw	r3,64(r2)
                tse_dprintf(5, "INFO    : PHY[%d.%d] - Automatically mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
   391ec:	e17ffd47 	ldb	r5,-11(fp)
   391f0:	e0fffd07 	ldb	r3,-12(fp)
   391f4:	e0bffd87 	ldb	r2,-10(fp)
   391f8:	01000134 	movhi	r4,4
   391fc:	2109a204 	addi	r4,r4,9864
   39200:	180d883a 	mov	r6,r3
   39204:	100f883a 	mov	r7,r2
   39208:	00044740 	call	4474 <printf>
                is_mapped = 1;
   3920c:	00800044 	movi	r2,1
   39210:	e0bffa05 	stb	r2,-24(fp)
                break;
   39214:	00000906 	br	3923c <alt_tse_mac_associate_phy+0x1fc>
            pmac_info = pmac_group->pmac_info[i];
            psys = pmac_info->psys_info;
            
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
            	continue;
   39218:	0001883a 	nop
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
        for(i = 0; i < pmac_group->channel; i++) {
   3921c:	e0bff817 	ldw	r2,-32(fp)
   39220:	10800044 	addi	r2,r2,1
   39224:	e0bff815 	stw	r2,-32(fp)
   39228:	e0bffe17 	ldw	r2,-8(fp)
   3922c:	10800003 	ldbu	r2,0(r2)
   39230:	10803fcc 	andi	r2,r2,255
   39234:	e0fff817 	ldw	r3,-32(fp)
   39238:	18bfc616 	blt	r3,r2,39154 <alt_tse_mac_associate_phy+0x114>
            }
        }
    }
    
    /* Still cannot find any matched MAC-PHY */
    if(is_mapped == 0) {
   3923c:	e0bffa03 	ldbu	r2,-24(fp)
   39240:	1000091e 	bne	r2,zero,39268 <alt_tse_mac_associate_phy+0x228>
    	pphy->pmac_info = 0;
   39244:	e0bfff17 	ldw	r2,-4(fp)
   39248:	10000615 	stw	zero,24(r2)
        tse_dprintf(2, "WARNING : PHY[%d.X] - Mapping of PHY to MAC failed! Make sure the PHY address is defined correctly in tse_mac_device[] structure, and number of PHYs connected is equivalent to number of channel\n", mac_group_index);
   3924c:	e0bffd47 	ldb	r2,-11(fp)
   39250:	01000134 	movhi	r4,4
   39254:	2109b304 	addi	r4,r4,9932
   39258:	100b883a 	mov	r5,r2
   3925c:	00044740 	call	4474 <printf>
        return_value = TSE_PHY_MAP_ERROR;
   39260:	00bfffc4 	movi	r2,-1
   39264:	e0bff915 	stw	r2,-28(fp)
    }
    
    return return_value;
   39268:	e0bff917 	ldw	r2,-28(fp)
}
   3926c:	e037883a 	mov	sp,fp
   39270:	dfc00117 	ldw	ra,4(sp)
   39274:	df000017 	ldw	fp,0(sp)
   39278:	dec00204 	addi	sp,sp,8
   3927c:	f800283a 	ret

00039280 <alt_tse_phy_cfg_pcs>:
/* @Function Description: Configure operating mode of Altera PCS if available
 * @API Type:           Internal
 * @param pmac_info     pointer to MAC info variable
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_cfg_pcs(alt_tse_mac_info *pmac_info) {
   39280:	defff804 	addi	sp,sp,-32
   39284:	dfc00715 	stw	ra,28(sp)
   39288:	df000615 	stw	fp,24(sp)
   3928c:	df000604 	addi	fp,sp,24
   39290:	e13fff15 	stw	r4,-4(fp)
    
    alt_tse_system_info *psys = pmac_info->psys_info;
   39294:	e0bfff17 	ldw	r2,-4(fp)
   39298:	10800217 	ldw	r2,8(r2)
   3929c:	e0bffa15 	stw	r2,-24(fp)
    np_tse_mac *pmac = (np_tse_mac *) psys->tse_mac_base;
   392a0:	e0bffa17 	ldw	r2,-24(fp)
   392a4:	10800017 	ldw	r2,0(r2)
   392a8:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   392ac:	e0bfff17 	ldw	r2,-4(fp)
   392b0:	10800317 	ldw	r2,12(r2)
   392b4:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   392b8:	e13fff17 	ldw	r4,-4(fp)
   392bc:	00371200 	call	37120 <alt_tse_get_mac_info_index>
   392c0:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   392c4:	e13ffc17 	ldw	r4,-16(fp)
   392c8:	00370ac0 	call	370ac <alt_tse_get_mac_group_index>
   392cc:	e0bffd45 	stb	r2,-11(fp)

    if(psys->tse_pcs_ena) {
   392d0:	e0bffa17 	ldw	r2,-24(fp)
   392d4:	108003c3 	ldbu	r2,15(r2)
   392d8:	10803fcc 	andi	r2,r2,255
   392dc:	10002c26 	beq	r2,zero,39390 <alt_tse_phy_cfg_pcs+0x110>
        tse_dprintf(5, "INFO    : PCS[%d.%d] - Configuring PCS operating mode\n", mac_group_index, mac_info_index);
   392e0:	e0fffd47 	ldb	r3,-11(fp)
   392e4:	e0bffd07 	ldb	r2,-12(fp)
   392e8:	01000134 	movhi	r4,4
   392ec:	2109e404 	addi	r4,r4,10128
   392f0:	180b883a 	mov	r5,r3
   392f4:	100d883a 	mov	r6,r2
   392f8:	00044740 	call	4474 <printf>
        
        alt_32 data = IORD(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE); 
   392fc:	e0bffb17 	ldw	r2,-20(fp)
   39300:	10808004 	addi	r2,r2,512
   39304:	10801404 	addi	r2,r2,80
   39308:	10800037 	ldwio	r2,0(r2)
   3930c:	e0bffe15 	stw	r2,-8(fp)
        
        if(psys->tse_pcs_sgmii) {
   39310:	e0bffa17 	ldw	r2,-24(fp)
   39314:	10800403 	ldbu	r2,16(r2)
   39318:	10803fcc 	andi	r2,r2,255
   3931c:	10000e26 	beq	r2,zero,39358 <alt_tse_phy_cfg_pcs+0xd8>
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode enabled\n", mac_group_index, mac_info_index);
   39320:	e0fffd47 	ldb	r3,-11(fp)
   39324:	e0bffd07 	ldb	r2,-12(fp)
   39328:	01000134 	movhi	r4,4
   3932c:	2109f204 	addi	r4,r4,10184
   39330:	180b883a 	mov	r5,r3
   39334:	100d883a 	mov	r6,r2
   39338:	00044740 	call	4474 <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data | 0x03);
   3933c:	e0bffb17 	ldw	r2,-20(fp)
   39340:	10808004 	addi	r2,r2,512
   39344:	10801404 	addi	r2,r2,80
   39348:	e0fffe17 	ldw	r3,-8(fp)
   3934c:	18c000d4 	ori	r3,r3,3
   39350:	10c00035 	stwio	r3,0(r2)
   39354:	00000e06 	br	39390 <alt_tse_phy_cfg_pcs+0x110>
            }
        else {
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode disabled\n", mac_group_index, mac_info_index);
   39358:	e0fffd47 	ldb	r3,-11(fp)
   3935c:	e0bffd07 	ldb	r2,-12(fp)
   39360:	01000134 	movhi	r4,4
   39364:	2109fe04 	addi	r4,r4,10232
   39368:	180b883a 	mov	r5,r3
   3936c:	100d883a 	mov	r6,r2
   39370:	00044740 	call	4474 <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data & ~0x03);
   39374:	e0bffb17 	ldw	r2,-20(fp)
   39378:	10808004 	addi	r2,r2,512
   3937c:	10801404 	addi	r2,r2,80
   39380:	e13ffe17 	ldw	r4,-8(fp)
   39384:	00ffff04 	movi	r3,-4
   39388:	20c6703a 	and	r3,r4,r3
   3938c:	10c00035 	stwio	r3,0(r2)
        }
    }
    
    return SUCCESS;
   39390:	0005883a 	mov	r2,zero
}
   39394:	e037883a 	mov	sp,fp
   39398:	dfc00117 	ldw	ra,4(sp)
   3939c:	df000017 	ldw	fp,0(sp)
   393a0:	dec00204 	addi	sp,sp,8
   393a4:	f800283a 	ret

000393a8 <alt_tse_phy_init>:
/* @Function Description: Detect and initialize all the PHYs connected
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      SUCCESS
 */
alt_32 alt_tse_phy_init() {
   393a8:	defffb04 	addi	sp,sp,-20
   393ac:	dfc00415 	stw	ra,16(sp)
   393b0:	df000315 	stw	fp,12(sp)
   393b4:	df000304 	addi	fp,sp,12
	alt_8 i = 0;
   393b8:	e03ffd05 	stb	zero,-12(fp)
	alt_8 j = 0;
   393bc:	e03ffd45 	stb	zero,-11(fp)
    
    alt_tse_mac_group *pmac_group = 0;
   393c0:	e03ffe15 	stw	zero,-8(fp)
    alt_tse_mac_info *pmac_info = 0;
   393c4:	e03fff15 	stw	zero,-4(fp)
    
    /* add supported PHYs */
    alt_tse_phy_add_profile_default();
   393c8:	00380e40 	call	380e4 <alt_tse_phy_add_profile_default>
    
    /* display PHY in profile */
    alt_tse_phy_print_profile();
   393cc:	003837c0 	call	3837c <alt_tse_phy_print_profile>
    
    alt_tse_mac_group_init();
   393d0:	003858c0 	call	3858c <alt_tse_mac_group_init>
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
   393d4:	e03ffd05 	stb	zero,-12(fp)
   393d8:	00002f06 	br	39498 <alt_tse_phy_init+0xf0>
        pmac_group = pmac_groups[i];
   393dc:	e0bffd07 	ldb	r2,-12(fp)
   393e0:	00c001f4 	movhi	r3,7
   393e4:	18ed0b04 	addi	r3,r3,-19412
   393e8:	1085883a 	add	r2,r2,r2
   393ec:	1085883a 	add	r2,r2,r2
   393f0:	1885883a 	add	r2,r3,r2
   393f4:	10800017 	ldw	r2,0(r2)
   393f8:	e0bffe15 	stw	r2,-8(fp)
        
        if(pmac_group->pmac_info[0]->psys_info->tse_use_mdio) {
   393fc:	e0bffe17 	ldw	r2,-8(fp)
   39400:	10800117 	ldw	r2,4(r2)
   39404:	10800217 	ldw	r2,8(r2)
   39408:	10800203 	ldbu	r2,8(r2)
   3940c:	10803fcc 	andi	r2,r2,255
   39410:	10000326 	beq	r2,zero,39420 <alt_tse_phy_init+0x78>
            
        	/* get connected PHYs */
            alt_tse_mac_get_phy(pmac_group);
   39414:	e13ffe17 	ldw	r4,-8(fp)
   39418:	0038c280 	call	38c28 <alt_tse_mac_get_phy>
   3941c:	00000706 	br	3943c <alt_tse_phy_init+0x94>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
   39420:	e0fffd07 	ldb	r3,-12(fp)
   39424:	e0bffd47 	ldb	r2,-11(fp)
   39428:	01000134 	movhi	r4,4
   3942c:	210a0a04 	addi	r4,r4,10280
   39430:	180b883a 	mov	r5,r3
   39434:	100d883a 	mov	r6,r2
   39438:	00044740 	call	4474 <printf>
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
   3943c:	e03ffd45 	stb	zero,-11(fp)
   39440:	00000d06 	br	39478 <alt_tse_phy_init+0xd0>
            pmac_info = pmac_group->pmac_info[j];
   39444:	e0bffd47 	ldb	r2,-11(fp)
   39448:	e0fffe17 	ldw	r3,-8(fp)
   3944c:	10800044 	addi	r2,r2,1
   39450:	1085883a 	add	r2,r2,r2
   39454:	1085883a 	add	r2,r2,r2
   39458:	1885883a 	add	r2,r3,r2
   3945c:	10800017 	ldw	r2,0(r2)
   39460:	e0bfff15 	stw	r2,-4(fp)
            
            alt_tse_phy_cfg_pcs(pmac_info);
   39464:	e13fff17 	ldw	r4,-4(fp)
   39468:	00392800 	call	39280 <alt_tse_phy_cfg_pcs>
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
   3946c:	e0bffd43 	ldbu	r2,-11(fp)
   39470:	10800044 	addi	r2,r2,1
   39474:	e0bffd45 	stb	r2,-11(fp)
   39478:	e0fffd47 	ldb	r3,-11(fp)
   3947c:	e0bffe17 	ldw	r2,-8(fp)
   39480:	10800003 	ldbu	r2,0(r2)
   39484:	10803fcc 	andi	r2,r2,255
   39488:	18bfee16 	blt	r3,r2,39444 <alt_tse_phy_init+0x9c>
    
    alt_tse_mac_group_init();
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
   3948c:	e0bffd03 	ldbu	r2,-12(fp)
   39490:	10800044 	addi	r2,r2,1
   39494:	e0bffd05 	stb	r2,-12(fp)
   39498:	e0fffd07 	ldb	r3,-12(fp)
   3949c:	d0a94743 	ldbu	r2,-23267(gp)
   394a0:	10803fcc 	andi	r2,r2,255
   394a4:	18bfcd16 	blt	r3,r2,393dc <alt_tse_phy_init+0x34>
            
            alt_tse_phy_cfg_pcs(pmac_info);
        }
    }
                
    return SUCCESS;
   394a8:	0005883a 	mov	r2,zero
}
   394ac:	e037883a 	mov	sp,fp
   394b0:	dfc00117 	ldw	ra,4(sp)
   394b4:	df000017 	ldw	fp,0(sp)
   394b8:	dec00204 	addi	sp,sp,8
   394bc:	f800283a 	ret

000394c0 <alt_tse_phy_restart_an>:
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *                              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_restart_an(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
   394c0:	defff704 	addi	sp,sp,-36
   394c4:	dfc00815 	stw	ra,32(sp)
   394c8:	df000715 	stw	fp,28(sp)
   394cc:	df000704 	addi	fp,sp,28
   394d0:	e13ffe15 	stw	r4,-8(fp)
   394d4:	e17fff15 	stw	r5,-4(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
   394d8:	e0bffe17 	ldw	r2,-8(fp)
   394dc:	10800617 	ldw	r2,24(r2)
   394e0:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   394e4:	e0bffb17 	ldw	r2,-20(fp)
   394e8:	10800317 	ldw	r2,12(r2)
   394ec:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   394f0:	e13ffb17 	ldw	r4,-20(fp)
   394f4:	00371200 	call	37120 <alt_tse_get_mac_info_index>
   394f8:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   394fc:	e13ffc17 	ldw	r4,-16(fp)
   39500:	00370ac0 	call	370ac <alt_tse_get_mac_group_index>
   39504:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
   39508:	e13ffe17 	ldw	r4,-8(fp)
   3950c:	0037e4c0 	call	37e4c <alt_tse_phy_rd_mdio_addr>
   39510:	e0bffd85 	stb	r2,-10(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
   39514:	e0bffe17 	ldw	r2,-8(fp)
   39518:	10800003 	ldbu	r2,0(r2)
   3951c:	10803fcc 	andi	r2,r2,255
   39520:	e13ffe17 	ldw	r4,-8(fp)
   39524:	100b883a 	mov	r5,r2
   39528:	0037e940 	call	37e94 <alt_tse_phy_wr_mdio_addr>
    
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
   3952c:	e13ffe17 	ldw	r4,-8(fp)
   39530:	01400044 	movi	r5,1
   39534:	018000c4 	movi	r6,3
   39538:	01c00044 	movi	r7,1
   3953c:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   39540:	10000d1e 	bne	r2,zero,39578 <alt_tse_phy_restart_an+0xb8>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
   39544:	e0fffd47 	ldb	r3,-11(fp)
   39548:	e0bffd07 	ldb	r2,-12(fp)
   3954c:	01000134 	movhi	r4,4
   39550:	210a2004 	addi	r4,r4,10368
   39554:	180b883a 	mov	r5,r3
   39558:	100d883a 	mov	r6,r2
   3955c:	00044740 	call	4474 <printf>
        
		/* Restore previous MDIO address */
		alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   39560:	e0bffd83 	ldbu	r2,-10(fp)
   39564:	e13ffe17 	ldw	r4,-8(fp)
   39568:	100b883a 	mov	r5,r2
   3956c:	0037e940 	call	37e94 <alt_tse_phy_wr_mdio_addr>
		
		return TSE_PHY_AN_NOT_CAPABLE;
   39570:	00bfff84 	movi	r2,-2
   39574:	00003e06 	br	39670 <alt_tse_phy_restart_an+0x1b0>
    }
    
    /* enable Auto-Negotiation */    
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_AN_ENA, 1, 1);
   39578:	00800044 	movi	r2,1
   3957c:	d8800015 	stw	r2,0(sp)
   39580:	e13ffe17 	ldw	r4,-8(fp)
   39584:	000b883a 	mov	r5,zero
   39588:	01800304 	movi	r6,12
   3958c:	01c00044 	movi	r7,1
   39590:	0037eec0 	call	37eec <alt_tse_phy_wr_mdio_reg>
    
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
   39594:	00800044 	movi	r2,1
   39598:	d8800015 	stw	r2,0(sp)
   3959c:	e13ffe17 	ldw	r4,-8(fp)
   395a0:	000b883a 	mov	r5,zero
   395a4:	01800244 	movi	r6,9
   395a8:	01c00044 	movi	r7,1
   395ac:	0037eec0 	call	37eec <alt_tse_phy_wr_mdio_reg>
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
   395b0:	e0fffd47 	ldb	r3,-11(fp)
   395b4:	e0bffd07 	ldb	r2,-12(fp)
   395b8:	01000134 	movhi	r4,4
   395bc:	210a3004 	addi	r4,r4,10432
   395c0:	180b883a 	mov	r5,r3
   395c4:	100d883a 	mov	r6,r2
   395c8:	00044740 	call	4474 <printf>
    
    alt_32 timeout = 0;
   395cc:	e03ffa15 	stw	zero,-24(fp)
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
   395d0:	00001506 	br	39628 <alt_tse_phy_restart_an+0x168>
        if(timeout++ > timeout_threshold) {
   395d4:	e0bffa17 	ldw	r2,-24(fp)
   395d8:	e0ffff17 	ldw	r3,-4(fp)
   395dc:	1885803a 	cmpltu	r2,r3,r2
   395e0:	e0fffa17 	ldw	r3,-24(fp)
   395e4:	18c00044 	addi	r3,r3,1
   395e8:	e0fffa15 	stw	r3,-24(fp)
   395ec:	10803fcc 	andi	r2,r2,255
   395f0:	10000d26 	beq	r2,zero,39628 <alt_tse_phy_restart_an+0x168>
           tse_dprintf(4, "WARNING : PHY[%d.%d] - Auto-Negotiation FAILED\n", mac_group_index, mac_info_index);
   395f4:	e0fffd47 	ldb	r3,-11(fp)
   395f8:	e0bffd07 	ldb	r2,-12(fp)
   395fc:	01000134 	movhi	r4,4
   39600:	210a4204 	addi	r4,r4,10504
   39604:	180b883a 	mov	r5,r3
   39608:	100d883a 	mov	r6,r2
   3960c:	00044740 	call	4474 <printf>
		   
		   /* Restore previous MDIO address */
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   39610:	e0bffd83 	ldbu	r2,-10(fp)
   39614:	e13ffe17 	ldw	r4,-8(fp)
   39618:	100b883a 	mov	r5,r2
   3961c:	0037e940 	call	37e94 <alt_tse_phy_wr_mdio_addr>
           
		   return TSE_PHY_AN_NOT_COMPLETE;
   39620:	00bfffc4 	movi	r2,-1
   39624:	00001206 	br	39670 <alt_tse_phy_restart_an+0x1b0>
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
    
    alt_32 timeout = 0;
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
   39628:	e13ffe17 	ldw	r4,-8(fp)
   3962c:	01400044 	movi	r5,1
   39630:	01800144 	movi	r6,5
   39634:	01c00044 	movi	r7,1
   39638:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   3963c:	103fe526 	beq	r2,zero,395d4 <alt_tse_phy_restart_an+0x114>
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
           
		   return TSE_PHY_AN_NOT_COMPLETE;
        }
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Auto-Negotiation PASSED\n", mac_group_index, mac_info_index);
   39640:	e0fffd47 	ldb	r3,-11(fp)
   39644:	e0bffd07 	ldb	r2,-12(fp)
   39648:	01000134 	movhi	r4,4
   3964c:	210a4e04 	addi	r4,r4,10552
   39650:	180b883a 	mov	r5,r3
   39654:	100d883a 	mov	r6,r2
   39658:	00044740 	call	4474 <printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   3965c:	e0bffd83 	ldbu	r2,-10(fp)
   39660:	e13ffe17 	ldw	r4,-8(fp)
   39664:	100b883a 	mov	r5,r2
   39668:	0037e940 	call	37e94 <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE;
   3966c:	0005883a 	mov	r2,zero
}
   39670:	e037883a 	mov	sp,fp
   39674:	dfc00117 	ldw	ra,4(sp)
   39678:	df000017 	ldw	fp,0(sp)
   3967c:	dec00204 	addi	sp,sp,8
   39680:	f800283a 	ret

00039684 <alt_tse_phy_check_link>:
 * @param pphy                  Pointer to the alt_tse_phy_info structure
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 */
alt_32 alt_tse_phy_check_link(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
   39684:	defff904 	addi	sp,sp,-28
   39688:	dfc00615 	stw	ra,24(sp)
   3968c:	df000515 	stw	fp,20(sp)
   39690:	df000504 	addi	fp,sp,20
   39694:	e13ffe15 	stw	r4,-8(fp)
   39698:	e17fff15 	stw	r5,-4(fp)

    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
   3969c:	e0bffe17 	ldw	r2,-8(fp)
   396a0:	10800617 	ldw	r2,24(r2)
   396a4:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   396a8:	e0bffb17 	ldw	r2,-20(fp)
   396ac:	10800317 	ldw	r2,12(r2)
   396b0:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   396b4:	e13ffb17 	ldw	r4,-20(fp)
   396b8:	00371200 	call	37120 <alt_tse_get_mac_info_index>
   396bc:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group); 
   396c0:	e13ffc17 	ldw	r4,-16(fp)
   396c4:	00370ac0 	call	370ac <alt_tse_get_mac_group_index>
   396c8:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
   396cc:	e13ffe17 	ldw	r4,-8(fp)
   396d0:	0037e4c0 	call	37e4c <alt_tse_phy_rd_mdio_addr>
   396d4:	e0bffd85 	stb	r2,-10(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
   396d8:	e0bffe17 	ldw	r2,-8(fp)
   396dc:	10800003 	ldbu	r2,0(r2)
   396e0:	10803fcc 	andi	r2,r2,255
   396e4:	e13ffe17 	ldw	r4,-8(fp)
   396e8:	100b883a 	mov	r5,r2
   396ec:	0037e940 	call	37e94 <alt_tse_phy_wr_mdio_addr>
    /* Issue a PHY reset here and wait for the link
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
   396f0:	e0fffd47 	ldb	r3,-11(fp)
   396f4:	e0bffd07 	ldb	r2,-12(fp)
   396f8:	01000134 	movhi	r4,4
   396fc:	210a5a04 	addi	r4,r4,10600
   39700:	180b883a 	mov	r5,r3
   39704:	100d883a 	mov	r6,r2
   39708:	00044740 	call	4474 <printf>
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
   3970c:	e13ffe17 	ldw	r4,-8(fp)
   39710:	000b883a 	mov	r5,zero
   39714:	01800384 	movi	r6,14
   39718:	01c00044 	movi	r7,1
   3971c:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   39720:	1000061e 	bne	r2,zero,3973c <alt_tse_phy_check_link+0xb8>
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
   39724:	e13ffe17 	ldw	r4,-8(fp)
   39728:	01400044 	movi	r5,1
   3972c:	01800144 	movi	r6,5
   39730:	01c00044 	movi	r7,1
   39734:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
   39738:	1000191e 	bne	r2,zero,397a0 <alt_tse_phy_check_link+0x11c>
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
        
        tse_dprintf(5, "INFO    : PHY[%d.%d] - Link not yet established, restart auto-negotiation...\n", mac_group_index, mac_info_index);
   3973c:	e0fffd47 	ldb	r3,-11(fp)
   39740:	e0bffd07 	ldb	r2,-12(fp)
   39744:	01000134 	movhi	r4,4
   39748:	210a6504 	addi	r4,r4,10644
   3974c:	180b883a 	mov	r5,r3
   39750:	100d883a 	mov	r6,r2
   39754:	00044740 	call	4474 <printf>
        /* restart Auto-Negotiation */
        /* if Auto-Negotiation still cannot complete, then go to next PHY */
        if(alt_tse_phy_restart_an(pphy, timeout_threshold) == TSE_PHY_AN_NOT_COMPLETE) {
   39758:	e13ffe17 	ldw	r4,-8(fp)
   3975c:	e17fff17 	ldw	r5,-4(fp)
   39760:	00394c00 	call	394c0 <alt_tse_phy_restart_an>
   39764:	10bfffd8 	cmpnei	r2,r2,-1
   39768:	10000d1e 	bne	r2,zero,397a0 <alt_tse_phy_check_link+0x11c>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - Link could not established\n", mac_group_index, mac_info_index);
   3976c:	e0fffd47 	ldb	r3,-11(fp)
   39770:	e0bffd07 	ldb	r2,-12(fp)
   39774:	01000134 	movhi	r4,4
   39778:	210a7904 	addi	r4,r4,10724
   3977c:	180b883a 	mov	r5,r3
   39780:	100d883a 	mov	r6,r2
   39784:	00044740 	call	4474 <printf>
			
			/* Restore previous MDIO address */
			alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   39788:	e0bffd83 	ldbu	r2,-10(fp)
   3978c:	e13ffe17 	ldw	r4,-8(fp)
   39790:	100b883a 	mov	r5,r2
   39794:	0037e940 	call	37e94 <alt_tse_phy_wr_mdio_addr>
	
            return TSE_PHY_AN_NOT_COMPLETE;
   39798:	00bfffc4 	movi	r2,-1
   3979c:	00000c06 	br	397d0 <alt_tse_phy_check_link+0x14c>
        }            
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Link established\n", mac_group_index, mac_info_index);
   397a0:	e0fffd47 	ldb	r3,-11(fp)
   397a4:	e0bffd07 	ldb	r2,-12(fp)
   397a8:	01000134 	movhi	r4,4
   397ac:	210a8604 	addi	r4,r4,10776
   397b0:	180b883a 	mov	r5,r3
   397b4:	100d883a 	mov	r6,r2
   397b8:	00044740 	call	4474 <printf>
            
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   397bc:	e0bffd83 	ldbu	r2,-10(fp)
   397c0:	e13ffe17 	ldw	r4,-8(fp)
   397c4:	100b883a 	mov	r5,r2
   397c8:	0037e940 	call	37e94 <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE; 
   397cc:	0005883a 	mov	r2,zero
}
   397d0:	e037883a 	mov	sp,fp
   397d4:	dfc00117 	ldw	ra,4(sp)
   397d8:	df000017 	ldw	fp,0(sp)
   397dc:	dec00204 	addi	sp,sp,8
   397e0:	f800283a 	ret

000397e4 <alt_tse_phy_get_cap>:
 * @param pmac  Pointer to the alt_tse_phy_info structure
 * @return      return TSE_PHY_AN_COMPLETE if success
 *              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_get_cap(alt_tse_phy_info *pphy) {
   397e4:	defff904 	addi	sp,sp,-28
   397e8:	dfc00615 	stw	ra,24(sp)
   397ec:	df000515 	stw	fp,20(sp)
   397f0:	df000504 	addi	fp,sp,20
   397f4:	e13fff15 	stw	r4,-4(fp)
	alt_32 return_value = TSE_PHY_AN_COMPLETE;
   397f8:	e03ffb15 	stw	zero,-20(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
   397fc:	e0bfff17 	ldw	r2,-4(fp)
   39800:	10800617 	ldw	r2,24(r2)
   39804:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   39808:	e0bffc17 	ldw	r2,-16(fp)
   3980c:	10800317 	ldw	r2,12(r2)
   39810:	e0bffd15 	stw	r2,-12(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   39814:	e13ffc17 	ldw	r4,-16(fp)
   39818:	00371200 	call	37120 <alt_tse_get_mac_info_index>
   3981c:	e0bffe05 	stb	r2,-8(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);    
   39820:	e13ffd17 	ldw	r4,-12(fp)
   39824:	00370ac0 	call	370ac <alt_tse_get_mac_group_index>
   39828:	e0bffe45 	stb	r2,-7(fp)
        
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
   3982c:	e13fff17 	ldw	r4,-4(fp)
   39830:	0037e4c0 	call	37e4c <alt_tse_phy_rd_mdio_addr>
   39834:	e0bffe85 	stb	r2,-6(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
   39838:	e0bfff17 	ldw	r2,-4(fp)
   3983c:	10800003 	ldbu	r2,0(r2)
   39840:	10803fcc 	andi	r2,r2,255
   39844:	e13fff17 	ldw	r4,-4(fp)
   39848:	100b883a 	mov	r5,r2
   3984c:	0037e940 	call	37e94 <alt_tse_phy_wr_mdio_addr>
            
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
   39850:	e13fff17 	ldw	r4,-4(fp)
   39854:	01400044 	movi	r5,1
   39858:	018000c4 	movi	r6,3
   3985c:	01c00044 	movi	r7,1
   39860:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   39864:	10000d1e 	bne	r2,zero,3989c <alt_tse_phy_get_cap+0xb8>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
   39868:	e0fffe47 	ldb	r3,-7(fp)
   3986c:	e0bffe07 	ldb	r2,-8(fp)
   39870:	01000134 	movhi	r4,4
   39874:	210a2004 	addi	r4,r4,10368
   39878:	180b883a 	mov	r5,r3
   3987c:	100d883a 	mov	r6,r2
   39880:	00044740 	call	4474 <printf>
        
        /* Restore previous MDIO address */
        alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   39884:	e0bffe83 	ldbu	r2,-6(fp)
   39888:	e13fff17 	ldw	r4,-4(fp)
   3988c:	100b883a 	mov	r5,r2
   39890:	0037e940 	call	37e94 <alt_tse_phy_wr_mdio_addr>
        
        return TSE_PHY_AN_NOT_CAPABLE;
   39894:	00bfff84 	movi	r2,-2
   39898:	00013206 	br	39d64 <alt_tse_phy_get_cap+0x580>
    }
    
    /* check whether link has been established */
    alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
   3989c:	e13fff17 	ldw	r4,-4(fp)
   398a0:	015d4c04 	movi	r5,30000
   398a4:	00394c00 	call	394c0 <alt_tse_phy_restart_an>
    
    if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0) {
   398a8:	e13fff17 	ldw	r4,-4(fp)
   398ac:	01400044 	movi	r5,1
   398b0:	01800144 	movi	r6,5
   398b4:	01c00044 	movi	r7,1
   398b8:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   398bc:	1000021e 	bne	r2,zero,398c8 <alt_tse_phy_get_cap+0xe4>
        return_value = TSE_PHY_AN_NOT_COMPLETE;
   398c0:	00bfffc4 	movi	r2,-1
   398c4:	e0bffb15 	stw	r2,-20(fp)
    }
    
    /* get PHY capabilities */
    pphy->link_capability.cap_1000_base_x_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_FULL, 1);
   398c8:	e13fff17 	ldw	r4,-4(fp)
   398cc:	014003c4 	movi	r5,15
   398d0:	018003c4 	movi	r6,15
   398d4:	01c00044 	movi	r7,1
   398d8:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   398dc:	1007883a 	mov	r3,r2
   398e0:	e0bfff17 	ldw	r2,-4(fp)
   398e4:	10c00045 	stb	r3,1(r2)
    pphy->link_capability.cap_1000_base_x_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_HALF, 1);
   398e8:	e13fff17 	ldw	r4,-4(fp)
   398ec:	014003c4 	movi	r5,15
   398f0:	01800384 	movi	r6,14
   398f4:	01c00044 	movi	r7,1
   398f8:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   398fc:	1007883a 	mov	r3,r2
   39900:	e0bfff17 	ldw	r2,-4(fp)
   39904:	10c00085 	stb	r3,2(r2)
    pphy->link_capability.cap_1000_base_t_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1);
   39908:	e13fff17 	ldw	r4,-4(fp)
   3990c:	014003c4 	movi	r5,15
   39910:	01800344 	movi	r6,13
   39914:	01c00044 	movi	r7,1
   39918:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   3991c:	1007883a 	mov	r3,r2
   39920:	e0bfff17 	ldw	r2,-4(fp)
   39924:	10c000c5 	stb	r3,3(r2)
    pphy->link_capability.cap_1000_base_t_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
   39928:	e13fff17 	ldw	r4,-4(fp)
   3992c:	014003c4 	movi	r5,15
   39930:	01800304 	movi	r6,12
   39934:	01c00044 	movi	r7,1
   39938:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   3993c:	1007883a 	mov	r3,r2
   39940:	e0bfff17 	ldw	r2,-4(fp)
   39944:	10c00105 	stb	r3,4(r2)
    
    pphy->link_capability.cap_100_base_t4      = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
   39948:	e13fff17 	ldw	r4,-4(fp)
   3994c:	01400044 	movi	r5,1
   39950:	018003c4 	movi	r6,15
   39954:	01c00044 	movi	r7,1
   39958:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   3995c:	1007883a 	mov	r3,r2
   39960:	e0bfff17 	ldw	r2,-4(fp)
   39964:	10c00145 	stb	r3,5(r2)
    pphy->link_capability.cap_100_base_x_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
   39968:	e13fff17 	ldw	r4,-4(fp)
   3996c:	01400044 	movi	r5,1
   39970:	01800384 	movi	r6,14
   39974:	01c00044 	movi	r7,1
   39978:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   3997c:	1007883a 	mov	r3,r2
   39980:	e0bfff17 	ldw	r2,-4(fp)
   39984:	10c00185 	stb	r3,6(r2)
    pphy->link_capability.cap_100_base_x_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
   39988:	e13fff17 	ldw	r4,-4(fp)
   3998c:	01400044 	movi	r5,1
   39990:	01800344 	movi	r6,13
   39994:	01c00044 	movi	r7,1
   39998:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   3999c:	1007883a 	mov	r3,r2
   399a0:	e0bfff17 	ldw	r2,-4(fp)
   399a4:	10c001c5 	stb	r3,7(r2)
    pphy->link_capability.cap_100_base_t2_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_FULL, 1);
   399a8:	e13fff17 	ldw	r4,-4(fp)
   399ac:	01400044 	movi	r5,1
   399b0:	01800284 	movi	r6,10
   399b4:	01c00044 	movi	r7,1
   399b8:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   399bc:	1007883a 	mov	r3,r2
   399c0:	e0bfff17 	ldw	r2,-4(fp)
   399c4:	10c00205 	stb	r3,8(r2)
    pphy->link_capability.cap_100_base_t2_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_HALF, 1);
   399c8:	e13fff17 	ldw	r4,-4(fp)
   399cc:	01400044 	movi	r5,1
   399d0:	01800244 	movi	r6,9
   399d4:	01c00044 	movi	r7,1
   399d8:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   399dc:	1007883a 	mov	r3,r2
   399e0:	e0bfff17 	ldw	r2,-4(fp)
   399e4:	10c00245 	stb	r3,9(r2)
    pphy->link_capability.cap_10_base_t_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
   399e8:	e13fff17 	ldw	r4,-4(fp)
   399ec:	01400044 	movi	r5,1
   399f0:	01800304 	movi	r6,12
   399f4:	01c00044 	movi	r7,1
   399f8:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   399fc:	1007883a 	mov	r3,r2
   39a00:	e0bfff17 	ldw	r2,-4(fp)
   39a04:	10c00285 	stb	r3,10(r2)
    pphy->link_capability.cap_10_base_t_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
   39a08:	e13fff17 	ldw	r4,-4(fp)
   39a0c:	01400044 	movi	r5,1
   39a10:	018002c4 	movi	r6,11
   39a14:	01c00044 	movi	r7,1
   39a18:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   39a1c:	1007883a 	mov	r3,r2
   39a20:	e0bfff17 	ldw	r2,-4(fp)
   39a24:	10c002c5 	stb	r3,11(r2)
    
    /* get link partner capability */
    pphy->link_capability.lp_1000_base_t_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_FULL_ADV, 1);
   39a28:	e13fff17 	ldw	r4,-4(fp)
   39a2c:	01400284 	movi	r5,10
   39a30:	018002c4 	movi	r6,11
   39a34:	01c00044 	movi	r7,1
   39a38:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   39a3c:	1007883a 	mov	r3,r2
   39a40:	e0bfff17 	ldw	r2,-4(fp)
   39a44:	10c00305 	stb	r3,12(r2)
    pphy->link_capability.lp_1000_base_t_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_HALF_ADV, 1);
   39a48:	e13fff17 	ldw	r4,-4(fp)
   39a4c:	01400284 	movi	r5,10
   39a50:	01800284 	movi	r6,10
   39a54:	01c00044 	movi	r7,1
   39a58:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   39a5c:	1007883a 	mov	r3,r2
   39a60:	e0bfff17 	ldw	r2,-4(fp)
   39a64:	10c00345 	stb	r3,13(r2)
    
    pphy->link_capability.lp_100_base_t4       = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1);
   39a68:	e13fff17 	ldw	r4,-4(fp)
   39a6c:	01400144 	movi	r5,5
   39a70:	01800244 	movi	r6,9
   39a74:	01c00044 	movi	r7,1
   39a78:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   39a7c:	1007883a 	mov	r3,r2
   39a80:	e0bfff17 	ldw	r2,-4(fp)
   39a84:	10c00385 	stb	r3,14(r2)
    pphy->link_capability.lp_100_base_tx_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1);
   39a88:	e13fff17 	ldw	r4,-4(fp)
   39a8c:	01400144 	movi	r5,5
   39a90:	01800204 	movi	r6,8
   39a94:	01c00044 	movi	r7,1
   39a98:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   39a9c:	1007883a 	mov	r3,r2
   39aa0:	e0bfff17 	ldw	r2,-4(fp)
   39aa4:	10c003c5 	stb	r3,15(r2)
    pphy->link_capability.lp_100_base_tx_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1);
   39aa8:	e13fff17 	ldw	r4,-4(fp)
   39aac:	01400144 	movi	r5,5
   39ab0:	018001c4 	movi	r6,7
   39ab4:	01c00044 	movi	r7,1
   39ab8:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   39abc:	1007883a 	mov	r3,r2
   39ac0:	e0bfff17 	ldw	r2,-4(fp)
   39ac4:	10c00405 	stb	r3,16(r2)
    pphy->link_capability.lp_10_base_tx_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1);
   39ac8:	e13fff17 	ldw	r4,-4(fp)
   39acc:	01400144 	movi	r5,5
   39ad0:	01800184 	movi	r6,6
   39ad4:	01c00044 	movi	r7,1
   39ad8:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   39adc:	1007883a 	mov	r3,r2
   39ae0:	e0bfff17 	ldw	r2,-4(fp)
   39ae4:	10c00445 	stb	r3,17(r2)
    pphy->link_capability.lp_10_base_tx_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1);
   39ae8:	e13fff17 	ldw	r4,-4(fp)
   39aec:	01400144 	movi	r5,5
   39af0:	01800144 	movi	r6,5
   39af4:	01c00044 	movi	r7,1
   39af8:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   39afc:	1007883a 	mov	r3,r2
   39b00:	e0bfff17 	ldw	r2,-4(fp)
   39b04:	10c00485 	stb	r3,18(r2)
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Capability of PHY :\n", mac_group_index, mac_info_index);
   39b08:	e0fffe47 	ldb	r3,-7(fp)
   39b0c:	e0bffe07 	ldb	r2,-8(fp)
   39b10:	01000134 	movhi	r4,4
   39b14:	210a9104 	addi	r4,r4,10820
   39b18:	180b883a 	mov	r5,r3
   39b1c:	100d883a 	mov	r6,r2
   39b20:	0035f380 	call	35f38 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Full Duplex = %d\n", pphy->link_capability.cap_1000_base_x_full);
   39b24:	e0bfff17 	ldw	r2,-4(fp)
   39b28:	10800043 	ldbu	r2,1(r2)
   39b2c:	10803fcc 	andi	r2,r2,255
   39b30:	01000134 	movhi	r4,4
   39b34:	210a9c04 	addi	r4,r4,10864
   39b38:	100b883a 	mov	r5,r2
   39b3c:	0035f380 	call	35f38 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Half Duplex = %d\n", pphy->link_capability.cap_1000_base_x_half);
   39b40:	e0bfff17 	ldw	r2,-4(fp)
   39b44:	10800083 	ldbu	r2,2(r2)
   39b48:	10803fcc 	andi	r2,r2,255
   39b4c:	01000134 	movhi	r4,4
   39b50:	210aa604 	addi	r4,r4,10904
   39b54:	100b883a 	mov	r5,r2
   39b58:	0035f380 	call	35f38 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.cap_1000_base_t_full);
   39b5c:	e0bfff17 	ldw	r2,-4(fp)
   39b60:	108000c3 	ldbu	r2,3(r2)
   39b64:	10803fcc 	andi	r2,r2,255
   39b68:	01000134 	movhi	r4,4
   39b6c:	210ab004 	addi	r4,r4,10944
   39b70:	100b883a 	mov	r5,r2
   39b74:	0035f380 	call	35f38 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.cap_1000_base_t_half);
   39b78:	e0bfff17 	ldw	r2,-4(fp)
   39b7c:	10800103 	ldbu	r2,4(r2)
   39b80:	10803fcc 	andi	r2,r2,255
   39b84:	01000134 	movhi	r4,4
   39b88:	210aba04 	addi	r4,r4,10984
   39b8c:	100b883a 	mov	r5,r2
   39b90:	0035f380 	call	35f38 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.cap_100_base_t4);
   39b94:	e0bfff17 	ldw	r2,-4(fp)
   39b98:	10800143 	ldbu	r2,5(r2)
   39b9c:	10803fcc 	andi	r2,r2,255
   39ba0:	01000134 	movhi	r4,4
   39ba4:	210ac404 	addi	r4,r4,11024
   39ba8:	100b883a 	mov	r5,r2
   39bac:	0035f380 	call	35f38 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Full Duplex  = %d\n", pphy->link_capability.cap_100_base_x_full);
   39bb0:	e0bfff17 	ldw	r2,-4(fp)
   39bb4:	10800183 	ldbu	r2,6(r2)
   39bb8:	10803fcc 	andi	r2,r2,255
   39bbc:	01000134 	movhi	r4,4
   39bc0:	210ace04 	addi	r4,r4,11064
   39bc4:	100b883a 	mov	r5,r2
   39bc8:	0035f380 	call	35f38 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Half Duplex  = %d\n", pphy->link_capability.cap_100_base_x_half);
   39bcc:	e0bfff17 	ldw	r2,-4(fp)
   39bd0:	108001c3 	ldbu	r2,7(r2)
   39bd4:	10803fcc 	andi	r2,r2,255
   39bd8:	01000134 	movhi	r4,4
   39bdc:	210ad804 	addi	r4,r4,11104
   39be0:	100b883a 	mov	r5,r2
   39be4:	0035f380 	call	35f38 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Full Duplex = %d\n", pphy->link_capability.cap_100_base_t2_full);
   39be8:	e0bfff17 	ldw	r2,-4(fp)
   39bec:	10800203 	ldbu	r2,8(r2)
   39bf0:	10803fcc 	andi	r2,r2,255
   39bf4:	01000134 	movhi	r4,4
   39bf8:	210ae204 	addi	r4,r4,11144
   39bfc:	100b883a 	mov	r5,r2
   39c00:	0035f380 	call	35f38 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Half Duplex = %d\n", pphy->link_capability.cap_100_base_t2_half);
   39c04:	e0bfff17 	ldw	r2,-4(fp)
   39c08:	10800243 	ldbu	r2,9(r2)
   39c0c:	10803fcc 	andi	r2,r2,255
   39c10:	01000134 	movhi	r4,4
   39c14:	210aec04 	addi	r4,r4,11184
   39c18:	100b883a 	mov	r5,r2
   39c1c:	0035f380 	call	35f38 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Full Duplex   = %d\n", pphy->link_capability.cap_10_base_t_full);
   39c20:	e0bfff17 	ldw	r2,-4(fp)
   39c24:	10800283 	ldbu	r2,10(r2)
   39c28:	10803fcc 	andi	r2,r2,255
   39c2c:	01000134 	movhi	r4,4
   39c30:	210af604 	addi	r4,r4,11224
   39c34:	100b883a 	mov	r5,r2
   39c38:	0035f380 	call	35f38 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Half Duplex   = %d\n", pphy->link_capability.cap_10_base_t_half);
   39c3c:	e0bfff17 	ldw	r2,-4(fp)
   39c40:	108002c3 	ldbu	r2,11(r2)
   39c44:	10803fcc 	andi	r2,r2,255
   39c48:	01000134 	movhi	r4,4
   39c4c:	210b0004 	addi	r4,r4,11264
   39c50:	100b883a 	mov	r5,r2
   39c54:	0035f380 	call	35f38 <no_printf>
    tse_dprintf(6, "\n");
   39c58:	01000134 	movhi	r4,4
   39c5c:	21096604 	addi	r4,r4,9624
   39c60:	0035f380 	call	35f38 <no_printf>
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Link Partner Capability :\n", mac_group_index, mac_info_index);
   39c64:	e0fffe47 	ldb	r3,-7(fp)
   39c68:	e0bffe07 	ldb	r2,-8(fp)
   39c6c:	01000134 	movhi	r4,4
   39c70:	210b0a04 	addi	r4,r4,11304
   39c74:	180b883a 	mov	r5,r3
   39c78:	100d883a 	mov	r6,r2
   39c7c:	0035f380 	call	35f38 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.lp_1000_base_t_full);
   39c80:	e0bfff17 	ldw	r2,-4(fp)
   39c84:	10800303 	ldbu	r2,12(r2)
   39c88:	10803fcc 	andi	r2,r2,255
   39c8c:	01000134 	movhi	r4,4
   39c90:	210ab004 	addi	r4,r4,10944
   39c94:	100b883a 	mov	r5,r2
   39c98:	0035f380 	call	35f38 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.lp_1000_base_t_half);
   39c9c:	e0bfff17 	ldw	r2,-4(fp)
   39ca0:	10800343 	ldbu	r2,13(r2)
   39ca4:	10803fcc 	andi	r2,r2,255
   39ca8:	01000134 	movhi	r4,4
   39cac:	210aba04 	addi	r4,r4,10984
   39cb0:	100b883a 	mov	r5,r2
   39cb4:	0035f380 	call	35f38 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.lp_100_base_t4);
   39cb8:	e0bfff17 	ldw	r2,-4(fp)
   39cbc:	10800383 	ldbu	r2,14(r2)
   39cc0:	10803fcc 	andi	r2,r2,255
   39cc4:	01000134 	movhi	r4,4
   39cc8:	210ac404 	addi	r4,r4,11024
   39ccc:	100b883a 	mov	r5,r2
   39cd0:	0035f380 	call	35f38 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Full Duplex = %d\n", pphy->link_capability.lp_100_base_tx_full);
   39cd4:	e0bfff17 	ldw	r2,-4(fp)
   39cd8:	108003c3 	ldbu	r2,15(r2)
   39cdc:	10803fcc 	andi	r2,r2,255
   39ce0:	01000134 	movhi	r4,4
   39ce4:	210b1704 	addi	r4,r4,11356
   39ce8:	100b883a 	mov	r5,r2
   39cec:	0035f380 	call	35f38 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Half Duplex = %d\n", pphy->link_capability.lp_100_base_tx_half);
   39cf0:	e0bfff17 	ldw	r2,-4(fp)
   39cf4:	10800403 	ldbu	r2,16(r2)
   39cf8:	10803fcc 	andi	r2,r2,255
   39cfc:	01000134 	movhi	r4,4
   39d00:	210b2104 	addi	r4,r4,11396
   39d04:	100b883a 	mov	r5,r2
   39d08:	0035f380 	call	35f38 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Full Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_full);
   39d0c:	e0bfff17 	ldw	r2,-4(fp)
   39d10:	10800443 	ldbu	r2,17(r2)
   39d14:	10803fcc 	andi	r2,r2,255
   39d18:	01000134 	movhi	r4,4
   39d1c:	210b2b04 	addi	r4,r4,11436
   39d20:	100b883a 	mov	r5,r2
   39d24:	0035f380 	call	35f38 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Half Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_half);
   39d28:	e0bfff17 	ldw	r2,-4(fp)
   39d2c:	10800483 	ldbu	r2,18(r2)
   39d30:	10803fcc 	andi	r2,r2,255
   39d34:	01000134 	movhi	r4,4
   39d38:	210b3504 	addi	r4,r4,11476
   39d3c:	100b883a 	mov	r5,r2
   39d40:	0035f380 	call	35f38 <no_printf>
    tse_dprintf(6, "\n");
   39d44:	01000134 	movhi	r4,4
   39d48:	21096604 	addi	r4,r4,9624
   39d4c:	0035f380 	call	35f38 <no_printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   39d50:	e0bffe83 	ldbu	r2,-6(fp)
   39d54:	e13fff17 	ldw	r4,-4(fp)
   39d58:	100b883a 	mov	r5,r2
   39d5c:	0037e940 	call	37e94 <alt_tse_phy_wr_mdio_addr>
    
    return return_value;
   39d60:	e0bffb17 	ldw	r2,-20(fp)
    
}
   39d64:	e037883a 	mov	sp,fp
   39d68:	dfc00117 	ldw	ra,4(sp)
   39d6c:	df000017 	ldw	fp,0(sp)
   39d70:	dec00204 	addi	sp,sp,8
   39d74:	f800283a 	ret

00039d78 <alt_tse_phy_set_adv_1000>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_1000(alt_tse_phy_info *pphy, alt_u8 enable) {
   39d78:	defff804 	addi	sp,sp,-32
   39d7c:	dfc00715 	stw	ra,28(sp)
   39d80:	df000615 	stw	fp,24(sp)
   39d84:	df000604 	addi	fp,sp,24
   39d88:	e13ffe15 	stw	r4,-8(fp)
   39d8c:	2805883a 	mov	r2,r5
   39d90:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
   39d94:	e0bffe17 	ldw	r2,-8(fp)
   39d98:	10800617 	ldw	r2,24(r2)
   39d9c:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   39da0:	e0bffb17 	ldw	r2,-20(fp)
   39da4:	10800317 	ldw	r2,12(r2)
   39da8:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   39dac:	e13ffb17 	ldw	r4,-20(fp)
   39db0:	00371200 	call	37120 <alt_tse_get_mac_info_index>
   39db4:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   39db8:	e13ffc17 	ldw	r4,-16(fp)
   39dbc:	00370ac0 	call	370ac <alt_tse_get_mac_group_index>
   39dc0:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
   39dc4:	e13ffe17 	ldw	r4,-8(fp)
   39dc8:	0037e4c0 	call	37e4c <alt_tse_phy_rd_mdio_addr>
   39dcc:	e0bffd85 	stb	r2,-10(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
   39dd0:	e0bffe17 	ldw	r2,-8(fp)
   39dd4:	10800003 	ldbu	r2,0(r2)
   39dd8:	10803fcc 	andi	r2,r2,255
   39ddc:	e13ffe17 	ldw	r4,-8(fp)
   39de0:	100b883a 	mov	r5,r2
   39de4:	0037e940 	call	37e94 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
   39de8:	e0bfff03 	ldbu	r2,-4(fp)
   39dec:	10002b26 	beq	r2,zero,39e9c <alt_tse_phy_set_adv_1000+0x124>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1); 
   39df0:	e13ffe17 	ldw	r4,-8(fp)
   39df4:	014003c4 	movi	r5,15
   39df8:	01800344 	movi	r6,13
   39dfc:	01c00044 	movi	r7,1
   39e00:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   39e04:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, cap);
   39e08:	e0bffdc3 	ldbu	r2,-9(fp)
   39e0c:	d8800015 	stw	r2,0(sp)
   39e10:	e13ffe17 	ldw	r4,-8(fp)
   39e14:	01400244 	movi	r5,9
   39e18:	01800244 	movi	r6,9
   39e1c:	01c00044 	movi	r7,1
   39e20:	0037eec0 	call	37eec <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
   39e24:	e17ffd47 	ldb	r5,-11(fp)
   39e28:	e0fffd07 	ldb	r3,-12(fp)
   39e2c:	e0bffdc3 	ldbu	r2,-9(fp)
   39e30:	01000134 	movhi	r4,4
   39e34:	210b3f04 	addi	r4,r4,11516
   39e38:	180d883a 	mov	r6,r3
   39e3c:	100f883a 	mov	r7,r2
   39e40:	0035f380 	call	35f38 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
   39e44:	e13ffe17 	ldw	r4,-8(fp)
   39e48:	014003c4 	movi	r5,15
   39e4c:	01800304 	movi	r6,12
   39e50:	01c00044 	movi	r7,1
   39e54:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   39e58:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, cap);
   39e5c:	e0bffdc3 	ldbu	r2,-9(fp)
   39e60:	d8800015 	stw	r2,0(sp)
   39e64:	e13ffe17 	ldw	r4,-8(fp)
   39e68:	01400244 	movi	r5,9
   39e6c:	01800204 	movi	r6,8
   39e70:	01c00044 	movi	r7,1
   39e74:	0037eec0 	call	37eec <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
   39e78:	e17ffd47 	ldb	r5,-11(fp)
   39e7c:	e0fffd07 	ldb	r3,-12(fp)
   39e80:	e0bffdc3 	ldbu	r2,-9(fp)
   39e84:	01000134 	movhi	r4,4
   39e88:	210b5204 	addi	r4,r4,11592
   39e8c:	180d883a 	mov	r6,r3
   39e90:	100f883a 	mov	r7,r2
   39e94:	0035f380 	call	35f38 <no_printf>
   39e98:	00001c06 	br	39f0c <alt_tse_phy_set_adv_1000+0x194>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, 0);
   39e9c:	d8000015 	stw	zero,0(sp)
   39ea0:	e13ffe17 	ldw	r4,-8(fp)
   39ea4:	01400244 	movi	r5,9
   39ea8:	01800244 	movi	r6,9
   39eac:	01c00044 	movi	r7,1
   39eb0:	0037eec0 	call	37eec <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
   39eb4:	e0fffd47 	ldb	r3,-11(fp)
   39eb8:	e0bffd07 	ldb	r2,-12(fp)
   39ebc:	01000134 	movhi	r4,4
   39ec0:	210b3f04 	addi	r4,r4,11516
   39ec4:	180b883a 	mov	r5,r3
   39ec8:	100d883a 	mov	r6,r2
   39ecc:	000f883a 	mov	r7,zero
   39ed0:	0035f380 	call	35f38 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, 0);
   39ed4:	d8000015 	stw	zero,0(sp)
   39ed8:	e13ffe17 	ldw	r4,-8(fp)
   39edc:	01400244 	movi	r5,9
   39ee0:	01800204 	movi	r6,8
   39ee4:	01c00044 	movi	r7,1
   39ee8:	0037eec0 	call	37eec <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement 1000 Base-T half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
   39eec:	e0fffd47 	ldb	r3,-11(fp)
   39ef0:	e0bffd07 	ldb	r2,-12(fp)
   39ef4:	01000134 	movhi	r4,4
   39ef8:	210b6504 	addi	r4,r4,11668
   39efc:	180b883a 	mov	r5,r3
   39f00:	100d883a 	mov	r6,r2
   39f04:	000f883a 	mov	r7,zero
   39f08:	0035f380 	call	35f38 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);    
   39f0c:	e0bffd83 	ldbu	r2,-10(fp)
   39f10:	e13ffe17 	ldw	r4,-8(fp)
   39f14:	100b883a 	mov	r5,r2
   39f18:	0037e940 	call	37e94 <alt_tse_phy_wr_mdio_addr>

    return SUCCESS;
   39f1c:	0005883a 	mov	r2,zero
}
   39f20:	e037883a 	mov	sp,fp
   39f24:	dfc00117 	ldw	ra,4(sp)
   39f28:	df000017 	ldw	fp,0(sp)
   39f2c:	dec00204 	addi	sp,sp,8
   39f30:	f800283a 	ret

00039f34 <alt_tse_phy_set_adv_100>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_100(alt_tse_phy_info *pphy, alt_u8 enable) {
   39f34:	defff804 	addi	sp,sp,-32
   39f38:	dfc00715 	stw	ra,28(sp)
   39f3c:	df000615 	stw	fp,24(sp)
   39f40:	df000604 	addi	fp,sp,24
   39f44:	e13ffe15 	stw	r4,-8(fp)
   39f48:	2805883a 	mov	r2,r5
   39f4c:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
   39f50:	e0bffe17 	ldw	r2,-8(fp)
   39f54:	10800617 	ldw	r2,24(r2)
   39f58:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   39f5c:	e0bffb17 	ldw	r2,-20(fp)
   39f60:	10800317 	ldw	r2,12(r2)
   39f64:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   39f68:	e13ffb17 	ldw	r4,-20(fp)
   39f6c:	00371200 	call	37120 <alt_tse_get_mac_info_index>
   39f70:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   39f74:	e13ffc17 	ldw	r4,-16(fp)
   39f78:	00370ac0 	call	370ac <alt_tse_get_mac_group_index>
   39f7c:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
   39f80:	e13ffe17 	ldw	r4,-8(fp)
   39f84:	0037e4c0 	call	37e4c <alt_tse_phy_rd_mdio_addr>
   39f88:	e0bffd85 	stb	r2,-10(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
   39f8c:	e0bffe17 	ldw	r2,-8(fp)
   39f90:	10800003 	ldbu	r2,0(r2)
   39f94:	10803fcc 	andi	r2,r2,255
   39f98:	e13ffe17 	ldw	r4,-8(fp)
   39f9c:	100b883a 	mov	r5,r2
   39fa0:	0037e940 	call	37e94 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
   39fa4:	e0bfff03 	ldbu	r2,-4(fp)
   39fa8:	10004026 	beq	r2,zero,3a0ac <alt_tse_phy_set_adv_100+0x178>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
   39fac:	e13ffe17 	ldw	r4,-8(fp)
   39fb0:	01400044 	movi	r5,1
   39fb4:	018003c4 	movi	r6,15
   39fb8:	01c00044 	movi	r7,1
   39fbc:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   39fc0:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, cap);
   39fc4:	e0bffdc3 	ldbu	r2,-9(fp)
   39fc8:	d8800015 	stw	r2,0(sp)
   39fcc:	e13ffe17 	ldw	r4,-8(fp)
   39fd0:	01400104 	movi	r5,4
   39fd4:	01800244 	movi	r6,9
   39fd8:	01c00044 	movi	r7,1
   39fdc:	0037eec0 	call	37eec <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, cap);
   39fe0:	e17ffd47 	ldb	r5,-11(fp)
   39fe4:	e0fffd07 	ldb	r3,-12(fp)
   39fe8:	e0bffdc3 	ldbu	r2,-9(fp)
   39fec:	01000134 	movhi	r4,4
   39ff0:	210b7704 	addi	r4,r4,11740
   39ff4:	180d883a 	mov	r6,r3
   39ff8:	100f883a 	mov	r7,r2
   39ffc:	0035f380 	call	35f38 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
   3a000:	e13ffe17 	ldw	r4,-8(fp)
   3a004:	01400044 	movi	r5,1
   3a008:	01800384 	movi	r6,14
   3a00c:	01c00044 	movi	r7,1
   3a010:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   3a014:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, cap);
   3a018:	e0bffdc3 	ldbu	r2,-9(fp)
   3a01c:	d8800015 	stw	r2,0(sp)
   3a020:	e13ffe17 	ldw	r4,-8(fp)
   3a024:	01400104 	movi	r5,4
   3a028:	01800204 	movi	r6,8
   3a02c:	01c00044 	movi	r7,1
   3a030:	0037eec0 	call	37eec <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
   3a034:	e17ffd47 	ldb	r5,-11(fp)
   3a038:	e0fffd07 	ldb	r3,-12(fp)
   3a03c:	e0bffdc3 	ldbu	r2,-9(fp)
   3a040:	01000134 	movhi	r4,4
   3a044:	210b8704 	addi	r4,r4,11804
   3a048:	180d883a 	mov	r6,r3
   3a04c:	100f883a 	mov	r7,r2
   3a050:	0035f380 	call	35f38 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
   3a054:	e13ffe17 	ldw	r4,-8(fp)
   3a058:	01400044 	movi	r5,1
   3a05c:	01800344 	movi	r6,13
   3a060:	01c00044 	movi	r7,1
   3a064:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   3a068:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, cap);
   3a06c:	e0bffdc3 	ldbu	r2,-9(fp)
   3a070:	d8800015 	stw	r2,0(sp)
   3a074:	e13ffe17 	ldw	r4,-8(fp)
   3a078:	01400104 	movi	r5,4
   3a07c:	018001c4 	movi	r6,7
   3a080:	01c00044 	movi	r7,1
   3a084:	0037eec0 	call	37eec <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
   3a088:	e17ffd47 	ldb	r5,-11(fp)
   3a08c:	e0fffd07 	ldb	r3,-12(fp)
   3a090:	e0bffdc3 	ldbu	r2,-9(fp)
   3a094:	01000134 	movhi	r4,4
   3a098:	210b9a04 	addi	r4,r4,11880
   3a09c:	180d883a 	mov	r6,r3
   3a0a0:	100f883a 	mov	r7,r2
   3a0a4:	0035f380 	call	35f38 <no_printf>
   3a0a8:	00002a06 	br	3a154 <alt_tse_phy_set_adv_100+0x220>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, 0);
   3a0ac:	d8000015 	stw	zero,0(sp)
   3a0b0:	e13ffe17 	ldw	r4,-8(fp)
   3a0b4:	01400104 	movi	r5,4
   3a0b8:	01800244 	movi	r6,9
   3a0bc:	01c00044 	movi	r7,1
   3a0c0:	0037eec0 	call	37eec <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, 0);
   3a0c4:	e0fffd47 	ldb	r3,-11(fp)
   3a0c8:	e0bffd07 	ldb	r2,-12(fp)
   3a0cc:	01000134 	movhi	r4,4
   3a0d0:	210b7704 	addi	r4,r4,11740
   3a0d4:	180b883a 	mov	r5,r3
   3a0d8:	100d883a 	mov	r6,r2
   3a0dc:	000f883a 	mov	r7,zero
   3a0e0:	0035f380 	call	35f38 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, 0);
   3a0e4:	d8000015 	stw	zero,0(sp)
   3a0e8:	e13ffe17 	ldw	r4,-8(fp)
   3a0ec:	01400104 	movi	r5,4
   3a0f0:	01800204 	movi	r6,8
   3a0f4:	01c00044 	movi	r7,1
   3a0f8:	0037eec0 	call	37eec <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
   3a0fc:	e0fffd47 	ldb	r3,-11(fp)
   3a100:	e0bffd07 	ldb	r2,-12(fp)
   3a104:	01000134 	movhi	r4,4
   3a108:	210b8704 	addi	r4,r4,11804
   3a10c:	180b883a 	mov	r5,r3
   3a110:	100d883a 	mov	r6,r2
   3a114:	000f883a 	mov	r7,zero
   3a118:	0035f380 	call	35f38 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, 0);
   3a11c:	d8000015 	stw	zero,0(sp)
   3a120:	e13ffe17 	ldw	r4,-8(fp)
   3a124:	01400104 	movi	r5,4
   3a128:	018001c4 	movi	r6,7
   3a12c:	01c00044 	movi	r7,1
   3a130:	0037eec0 	call	37eec <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
   3a134:	e0fffd47 	ldb	r3,-11(fp)
   3a138:	e0bffd07 	ldb	r2,-12(fp)
   3a13c:	01000134 	movhi	r4,4
   3a140:	210b9a04 	addi	r4,r4,11880
   3a144:	180b883a 	mov	r5,r3
   3a148:	100d883a 	mov	r6,r2
   3a14c:	000f883a 	mov	r7,zero
   3a150:	0035f380 	call	35f38 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);  
   3a154:	e0bffd83 	ldbu	r2,-10(fp)
   3a158:	e13ffe17 	ldw	r4,-8(fp)
   3a15c:	100b883a 	mov	r5,r2
   3a160:	0037e940 	call	37e94 <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
   3a164:	0005883a 	mov	r2,zero
}
   3a168:	e037883a 	mov	sp,fp
   3a16c:	dfc00117 	ldw	ra,4(sp)
   3a170:	df000017 	ldw	fp,0(sp)
   3a174:	dec00204 	addi	sp,sp,8
   3a178:	f800283a 	ret

0003a17c <alt_tse_phy_set_adv_10>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_10(alt_tse_phy_info *pphy, alt_u8 enable) {
   3a17c:	defff504 	addi	sp,sp,-44
   3a180:	dfc00a15 	stw	ra,40(sp)
   3a184:	df000915 	stw	fp,36(sp)
   3a188:	df000904 	addi	fp,sp,36
   3a18c:	e13ffe15 	stw	r4,-8(fp)
   3a190:	2805883a 	mov	r2,r5
   3a194:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
   3a198:	e0bffe17 	ldw	r2,-8(fp)
   3a19c:	10800617 	ldw	r2,24(r2)
   3a1a0:	e0bff815 	stw	r2,-32(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
   3a1a4:	e0bff817 	ldw	r2,-32(fp)
   3a1a8:	10800317 	ldw	r2,12(r2)
   3a1ac:	e0bff915 	stw	r2,-28(fp)
    
    /* get index of the pointers in pointer array list */
    int mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   3a1b0:	e13ff817 	ldw	r4,-32(fp)
   3a1b4:	00371200 	call	37120 <alt_tse_get_mac_info_index>
   3a1b8:	e0bffa15 	stw	r2,-24(fp)
    int mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   3a1bc:	e13ff917 	ldw	r4,-28(fp)
   3a1c0:	00370ac0 	call	370ac <alt_tse_get_mac_group_index>
   3a1c4:	e0bffb15 	stw	r2,-20(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    int mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
   3a1c8:	e13ffe17 	ldw	r4,-8(fp)
   3a1cc:	0037e4c0 	call	37e4c <alt_tse_phy_rd_mdio_addr>
   3a1d0:	e0bffc15 	stw	r2,-16(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
   3a1d4:	e0bffe17 	ldw	r2,-8(fp)
   3a1d8:	10800003 	ldbu	r2,0(r2)
   3a1dc:	10803fcc 	andi	r2,r2,255
   3a1e0:	e13ffe17 	ldw	r4,-8(fp)
   3a1e4:	100b883a 	mov	r5,r2
   3a1e8:	0037e940 	call	37e94 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
   3a1ec:	e0bfff03 	ldbu	r2,-4(fp)
   3a1f0:	10002926 	beq	r2,zero,3a298 <alt_tse_phy_set_adv_10+0x11c>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
   3a1f4:	e13ffe17 	ldw	r4,-8(fp)
   3a1f8:	01400044 	movi	r5,1
   3a1fc:	01800304 	movi	r6,12
   3a200:	01c00044 	movi	r7,1
   3a204:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   3a208:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, cap);
   3a20c:	e0bffd03 	ldbu	r2,-12(fp)
   3a210:	d8800015 	stw	r2,0(sp)
   3a214:	e13ffe17 	ldw	r4,-8(fp)
   3a218:	01400104 	movi	r5,4
   3a21c:	01800184 	movi	r6,6
   3a220:	01c00044 	movi	r7,1
   3a224:	0037eec0 	call	37eec <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
   3a228:	e0bffd03 	ldbu	r2,-12(fp)
   3a22c:	01000134 	movhi	r4,4
   3a230:	210bad04 	addi	r4,r4,11956
   3a234:	e17ffb17 	ldw	r5,-20(fp)
   3a238:	e1bffa17 	ldw	r6,-24(fp)
   3a23c:	100f883a 	mov	r7,r2
   3a240:	0035f380 	call	35f38 <no_printf>
    
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
   3a244:	e13ffe17 	ldw	r4,-8(fp)
   3a248:	01400044 	movi	r5,1
   3a24c:	018002c4 	movi	r6,11
   3a250:	01c00044 	movi	r7,1
   3a254:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   3a258:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, cap);
   3a25c:	e0bffd03 	ldbu	r2,-12(fp)
   3a260:	d8800015 	stw	r2,0(sp)
   3a264:	e13ffe17 	ldw	r4,-8(fp)
   3a268:	01400104 	movi	r5,4
   3a26c:	01800144 	movi	r6,5
   3a270:	01c00044 	movi	r7,1
   3a274:	0037eec0 	call	37eec <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
   3a278:	e0bffd03 	ldbu	r2,-12(fp)
   3a27c:	01000134 	movhi	r4,4
   3a280:	210bc004 	addi	r4,r4,12032
   3a284:	e17ffb17 	ldw	r5,-20(fp)
   3a288:	e1bffa17 	ldw	r6,-24(fp)
   3a28c:	100f883a 	mov	r7,r2
   3a290:	0035f380 	call	35f38 <no_printf>
   3a294:	00001806 	br	3a2f8 <alt_tse_phy_set_adv_10+0x17c>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, 0);
   3a298:	d8000015 	stw	zero,0(sp)
   3a29c:	e13ffe17 	ldw	r4,-8(fp)
   3a2a0:	01400104 	movi	r5,4
   3a2a4:	01800184 	movi	r6,6
   3a2a8:	01c00044 	movi	r7,1
   3a2ac:	0037eec0 	call	37eec <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
   3a2b0:	01000134 	movhi	r4,4
   3a2b4:	210bad04 	addi	r4,r4,11956
   3a2b8:	e17ffb17 	ldw	r5,-20(fp)
   3a2bc:	e1bffa17 	ldw	r6,-24(fp)
   3a2c0:	000f883a 	mov	r7,zero
   3a2c4:	0035f380 	call	35f38 <no_printf>
    
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, 0);
   3a2c8:	d8000015 	stw	zero,0(sp)
   3a2cc:	e13ffe17 	ldw	r4,-8(fp)
   3a2d0:	01400104 	movi	r5,4
   3a2d4:	01800144 	movi	r6,5
   3a2d8:	01c00044 	movi	r7,1
   3a2dc:	0037eec0 	call	37eec <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
   3a2e0:	01000134 	movhi	r4,4
   3a2e4:	210bc004 	addi	r4,r4,12032
   3a2e8:	e17ffb17 	ldw	r5,-20(fp)
   3a2ec:	e1bffa17 	ldw	r6,-24(fp)
   3a2f0:	000f883a 	mov	r7,zero
   3a2f4:	0035f380 	call	35f38 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
   3a2f8:	e0bffc17 	ldw	r2,-16(fp)
   3a2fc:	10803fcc 	andi	r2,r2,255
   3a300:	e13ffe17 	ldw	r4,-8(fp)
   3a304:	100b883a 	mov	r5,r2
   3a308:	0037e940 	call	37e94 <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
   3a30c:	0005883a 	mov	r2,zero
}
   3a310:	e037883a 	mov	sp,fp
   3a314:	dfc00117 	ldw	ra,4(sp)
   3a318:	df000017 	ldw	fp,0(sp)
   3a31c:	dec00204 	addi	sp,sp,8
   3a320:	f800283a 	ret

0003a324 <alt_tse_phy_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Internal
 * @param pmac_group    Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_phy_get_common_speed(alt_tse_mac_group *pmac_group) {
   3a324:	defff604 	addi	sp,sp,-40
   3a328:	dfc00915 	stw	ra,36(sp)
   3a32c:	df000815 	stw	fp,32(sp)
   3a330:	df000804 	addi	fp,sp,32
   3a334:	e13fff15 	stw	r4,-4(fp)
    
	alt_32 i;
	alt_u8 common_1000 = 1;
   3a338:	00800044 	movi	r2,1
   3a33c:	e0bff905 	stb	r2,-28(fp)
	alt_u8 common_100 = 1;
   3a340:	00800044 	movi	r2,1
   3a344:	e0bff945 	stb	r2,-27(fp)
	alt_u8 common_10 = 1;
   3a348:	00800044 	movi	r2,1
   3a34c:	e0bff985 	stb	r2,-26(fp)
    
	alt_32 common_speed;
    
	alt_u8 none_an_complete = 1;
   3a350:	00800044 	movi	r2,1
   3a354:	e0bffb05 	stb	r2,-20(fp)
    
    alt_tse_mac_info *pmac_info = 0;
   3a358:	e03ffc15 	stw	zero,-16(fp)
    alt_tse_phy_info *pphy = 0;
   3a35c:	e03ffd15 	stw	zero,-12(fp)
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   3a360:	e13fff17 	ldw	r4,-4(fp)
   3a364:	00370ac0 	call	370ac <alt_tse_get_mac_group_index>
   3a368:	e0bffe05 	stb	r2,-8(fp)
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
   3a36c:	e03ff815 	stw	zero,-32(fp)
   3a370:	00001c06 	br	3a3e4 <alt_tse_phy_get_common_speed+0xc0>
        pmac_info = pmac_group->pmac_info[i];
   3a374:	e0ffff17 	ldw	r3,-4(fp)
   3a378:	e0bff817 	ldw	r2,-32(fp)
   3a37c:	10800044 	addi	r2,r2,1
   3a380:	1085883a 	add	r2,r2,r2
   3a384:	1085883a 	add	r2,r2,r2
   3a388:	1885883a 	add	r2,r3,r2
   3a38c:	10800017 	ldw	r2,0(r2)
   3a390:	e0bffc15 	stw	r2,-16(fp)
        pphy = pmac_info->pphy_info;
   3a394:	e0bffc17 	ldw	r2,-16(fp)
   3a398:	10800117 	ldw	r2,4(r2)
   3a39c:	e0bffd15 	stw	r2,-12(fp)
        
        /* run only if PHY connected */
        if(pphy) {
   3a3a0:	e0bffd17 	ldw	r2,-12(fp)
   3a3a4:	10000926 	beq	r2,zero,3a3cc <alt_tse_phy_get_common_speed+0xa8>
            alt_tse_phy_set_adv_1000(pphy, 1);
   3a3a8:	e13ffd17 	ldw	r4,-12(fp)
   3a3ac:	01400044 	movi	r5,1
   3a3b0:	0039d780 	call	39d78 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
   3a3b4:	e13ffd17 	ldw	r4,-12(fp)
   3a3b8:	01400044 	movi	r5,1
   3a3bc:	0039f340 	call	39f34 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
   3a3c0:	e13ffd17 	ldw	r4,-12(fp)
   3a3c4:	01400044 	movi	r5,1
   3a3c8:	003a17c0 	call	3a17c <alt_tse_phy_set_adv_10>
        }
        tse_dprintf(6, "\n");
   3a3cc:	01000134 	movhi	r4,4
   3a3d0:	21096604 	addi	r4,r4,9624
   3a3d4:	0035f380 	call	35f38 <no_printf>
    alt_tse_phy_info *pphy = 0;
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
   3a3d8:	e0bff817 	ldw	r2,-32(fp)
   3a3dc:	10800044 	addi	r2,r2,1
   3a3e0:	e0bff815 	stw	r2,-32(fp)
   3a3e4:	e0bfff17 	ldw	r2,-4(fp)
   3a3e8:	10800003 	ldbu	r2,0(r2)
   3a3ec:	10803fcc 	andi	r2,r2,255
   3a3f0:	e0fff817 	ldw	r3,-32(fp)
   3a3f4:	18bfdf16 	blt	r3,r2,3a374 <alt_tse_phy_get_common_speed+0x50>
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
   3a3f8:	e03ff815 	stw	zero,-32(fp)
   3a3fc:	00005606 	br	3a558 <alt_tse_phy_get_common_speed+0x234>

        pmac_info = pmac_group->pmac_info[i];
   3a400:	e0ffff17 	ldw	r3,-4(fp)
   3a404:	e0bff817 	ldw	r2,-32(fp)
   3a408:	10800044 	addi	r2,r2,1
   3a40c:	1085883a 	add	r2,r2,r2
   3a410:	1085883a 	add	r2,r2,r2
   3a414:	1885883a 	add	r2,r3,r2
   3a418:	10800017 	ldw	r2,0(r2)
   3a41c:	e0bffc15 	stw	r2,-16(fp)
        pphy = pmac_info->pphy_info;
   3a420:	e0bffc17 	ldw	r2,-16(fp)
   3a424:	10800117 	ldw	r2,4(r2)
   3a428:	e0bffd15 	stw	r2,-12(fp)
        
        /* if no PHY connected */
        if(!pphy) {
   3a42c:	e0bffd17 	ldw	r2,-12(fp)
   3a430:	10004326 	beq	r2,zero,3a540 <alt_tse_phy_get_common_speed+0x21c>
            continue;
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
   3a434:	e13ffd17 	ldw	r4,-12(fp)
   3a438:	00397e40 	call	397e4 <alt_tse_phy_get_cap>
   3a43c:	1000421e 	bne	r2,zero,3a548 <alt_tse_phy_get_common_speed+0x224>
            continue;
        }
        
        none_an_complete = 0;
   3a440:	e03ffb05 	stb	zero,-20(fp)
        
        /* Small MAC */
        if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
   3a444:	e0bffc17 	ldw	r2,-16(fp)
   3a448:	10800003 	ldbu	r2,0(r2)
   3a44c:	10803fcc 	andi	r2,r2,255
   3a450:	10800058 	cmpnei	r2,r2,1
   3a454:	1000021e 	bne	r2,zero,3a460 <alt_tse_phy_get_common_speed+0x13c>
            common_1000 = 0;
   3a458:	e03ff905 	stb	zero,-28(fp)
   3a45c:	00000706 	br	3a47c <alt_tse_phy_get_common_speed+0x158>
        }
        else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
   3a460:	e0bffc17 	ldw	r2,-16(fp)
   3a464:	10800003 	ldbu	r2,0(r2)
   3a468:	10803fcc 	andi	r2,r2,255
   3a46c:	10800098 	cmpnei	r2,r2,2
   3a470:	1000021e 	bne	r2,zero,3a47c <alt_tse_phy_get_common_speed+0x158>
            common_100 = 0;
   3a474:	e03ff945 	stb	zero,-27(fp)
            common_10 = 0;            
   3a478:	e03ff985 	stb	zero,-26(fp)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
   3a47c:	e0bffd17 	ldw	r2,-12(fp)
   3a480:	10c000c3 	ldbu	r3,3(r2)
   3a484:	e0bffd17 	ldw	r2,-12(fp)
   3a488:	10800303 	ldbu	r2,12(r2)
   3a48c:	1884703a 	and	r2,r3,r2
   3a490:	1007883a 	mov	r3,r2
   3a494:	e0bff903 	ldbu	r2,-28(fp)
   3a498:	1884703a 	and	r2,r3,r2
   3a49c:	e0bff905 	stb	r2,-28(fp)
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
   3a4a0:	e0bffd17 	ldw	r2,-12(fp)
   3a4a4:	10c00183 	ldbu	r3,6(r2)
   3a4a8:	e0bffd17 	ldw	r2,-12(fp)
   3a4ac:	108003c3 	ldbu	r2,15(r2)
   3a4b0:	1884703a 	and	r2,r3,r2
   3a4b4:	1007883a 	mov	r3,r2
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
   3a4b8:	e0bffd17 	ldw	r2,-12(fp)
   3a4bc:	110001c3 	ldbu	r4,7(r2)
   3a4c0:	e0bffd17 	ldw	r2,-12(fp)
   3a4c4:	10800403 	ldbu	r2,16(r2)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
   3a4c8:	2084703a 	and	r2,r4,r2
   3a4cc:	1884b03a 	or	r2,r3,r2
   3a4d0:	1007883a 	mov	r3,r2
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
   3a4d4:	e0bffd17 	ldw	r2,-12(fp)
   3a4d8:	11000143 	ldbu	r4,5(r2)
   3a4dc:	e0bffd17 	ldw	r2,-12(fp)
   3a4e0:	10800383 	ldbu	r2,14(r2)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
   3a4e4:	2084703a 	and	r2,r4,r2
   3a4e8:	1884b03a 	or	r2,r3,r2
   3a4ec:	1007883a 	mov	r3,r2
   3a4f0:	e0bff943 	ldbu	r2,-27(fp)
   3a4f4:	1884703a 	and	r2,r3,r2
   3a4f8:	e0bff945 	stb	r2,-27(fp)
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
        common_10 &= ((pphy->link_capability.cap_10_base_t_full & pphy->link_capability.lp_10_base_tx_full) |
   3a4fc:	e0bffd17 	ldw	r2,-12(fp)
   3a500:	10c00283 	ldbu	r3,10(r2)
   3a504:	e0bffd17 	ldw	r2,-12(fp)
   3a508:	10800443 	ldbu	r2,17(r2)
   3a50c:	1884703a 	and	r2,r3,r2
   3a510:	1007883a 	mov	r3,r2
                        (pphy->link_capability.cap_10_base_t_half & pphy->link_capability.lp_10_base_tx_half));
   3a514:	e0bffd17 	ldw	r2,-12(fp)
   3a518:	110002c3 	ldbu	r4,11(r2)
   3a51c:	e0bffd17 	ldw	r2,-12(fp)
   3a520:	10800483 	ldbu	r2,18(r2)
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
        common_10 &= ((pphy->link_capability.cap_10_base_t_full & pphy->link_capability.lp_10_base_tx_full) |
   3a524:	2084703a 	and	r2,r4,r2
   3a528:	1884b03a 	or	r2,r3,r2
   3a52c:	1007883a 	mov	r3,r2
   3a530:	e0bff983 	ldbu	r2,-26(fp)
   3a534:	1884703a 	and	r2,r3,r2
   3a538:	e0bff985 	stb	r2,-26(fp)
   3a53c:	00000306 	br	3a54c <alt_tse_phy_get_common_speed+0x228>
        pmac_info = pmac_group->pmac_info[i];
        pphy = pmac_info->pphy_info;
        
        /* if no PHY connected */
        if(!pphy) {
            continue;
   3a540:	0001883a 	nop
   3a544:	00000106 	br	3a54c <alt_tse_phy_get_common_speed+0x228>
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
            continue;
   3a548:	0001883a 	nop
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
   3a54c:	e0bff817 	ldw	r2,-32(fp)
   3a550:	10800044 	addi	r2,r2,1
   3a554:	e0bff815 	stw	r2,-32(fp)
   3a558:	e0bfff17 	ldw	r2,-4(fp)
   3a55c:	10800003 	ldbu	r2,0(r2)
   3a560:	10803fcc 	andi	r2,r2,255
   3a564:	e0fff817 	ldw	r3,-32(fp)
   3a568:	18bfa516 	blt	r3,r2,3a400 <alt_tse_phy_get_common_speed+0xdc>
                        (pphy->link_capability.cap_10_base_t_half & pphy->link_capability.lp_10_base_tx_half));

    }
    
    /* get common speed based on capabilities */
    if(none_an_complete == 1) {
   3a56c:	e0bffb03 	ldbu	r2,-20(fp)
   3a570:	10800058 	cmpnei	r2,r2,1
   3a574:	1000081e 	bne	r2,zero,3a598 <alt_tse_phy_get_common_speed+0x274>
        common_speed = TSE_PHY_SPEED_NO_COMMON;
   3a578:	00bfffc4 	movi	r2,-1
   3a57c:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - None of the PHYs Auto-Negotiation completed!\n", mac_group_index);
   3a580:	e0bffe07 	ldb	r2,-8(fp)
   3a584:	01000134 	movhi	r4,4
   3a588:	210bd304 	addi	r4,r4,12108
   3a58c:	100b883a 	mov	r5,r2
   3a590:	00044740 	call	4474 <printf>
   3a594:	00002706 	br	3a634 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_1000) {
   3a598:	e0bff903 	ldbu	r2,-28(fp)
   3a59c:	10000926 	beq	r2,zero,3a5c4 <alt_tse_phy_get_common_speed+0x2a0>
        common_speed = TSE_PHY_SPEED_1000;
   3a5a0:	00800084 	movi	r2,2
   3a5a4:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 1000);
   3a5a8:	e0bffe07 	ldb	r2,-8(fp)
   3a5ac:	01000134 	movhi	r4,4
   3a5b0:	210be504 	addi	r4,r4,12180
   3a5b4:	100b883a 	mov	r5,r2
   3a5b8:	0180fa04 	movi	r6,1000
   3a5bc:	00044740 	call	4474 <printf>
   3a5c0:	00001c06 	br	3a634 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_100) {
   3a5c4:	e0bff943 	ldbu	r2,-27(fp)
   3a5c8:	10000926 	beq	r2,zero,3a5f0 <alt_tse_phy_get_common_speed+0x2cc>
        common_speed = TSE_PHY_SPEED_100;
   3a5cc:	00800044 	movi	r2,1
   3a5d0:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 100);
   3a5d4:	e0bffe07 	ldb	r2,-8(fp)
   3a5d8:	01000134 	movhi	r4,4
   3a5dc:	210be504 	addi	r4,r4,12180
   3a5e0:	100b883a 	mov	r5,r2
   3a5e4:	01801904 	movi	r6,100
   3a5e8:	00044740 	call	4474 <printf>
   3a5ec:	00001106 	br	3a634 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_10) {
   3a5f0:	e0bff983 	ldbu	r2,-26(fp)
   3a5f4:	10000826 	beq	r2,zero,3a618 <alt_tse_phy_get_common_speed+0x2f4>
        common_speed = TSE_PHY_SPEED_10;
   3a5f8:	e03ffa15 	stw	zero,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 10);
   3a5fc:	e0bffe07 	ldb	r2,-8(fp)
   3a600:	01000134 	movhi	r4,4
   3a604:	210be504 	addi	r4,r4,12180
   3a608:	100b883a 	mov	r5,r2
   3a60c:	01800284 	movi	r6,10
   3a610:	00044740 	call	4474 <printf>
   3a614:	00000706 	br	3a634 <alt_tse_phy_get_common_speed+0x310>
    }
    else {
        common_speed = TSE_PHY_SPEED_NO_COMMON;
   3a618:	00bfffc4 	movi	r2,-1
   3a61c:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - No common speed at all!\n", mac_group_index);    }
   3a620:	e0bffe07 	ldb	r2,-8(fp)
   3a624:	01000134 	movhi	r4,4
   3a628:	210bf204 	addi	r4,r4,12232
   3a62c:	100b883a 	mov	r5,r2
   3a630:	00044740 	call	4474 <printf>

    return common_speed;
   3a634:	e0bffa17 	ldw	r2,-24(fp)
}
   3a638:	e037883a 	mov	sp,fp
   3a63c:	dfc00117 	ldw	ra,4(sp)
   3a640:	df000017 	ldw	fp,0(sp)
   3a644:	dec00204 	addi	sp,sp,8
   3a648:	f800283a 	ret

0003a64c <alt_tse_phy_set_common_speed>:
 * @API Type:               Internal
 * @param pmac_group        Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 *        common_speed      common speed supported by all PHYs
 * @return      common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_phy_set_common_speed(alt_tse_mac_group *pmac_group, alt_32 common_speed) {
   3a64c:	defff004 	addi	sp,sp,-64
   3a650:	dfc00f15 	stw	ra,60(sp)
   3a654:	df000e15 	stw	fp,56(sp)
   3a658:	dc400d15 	stw	r17,52(sp)
   3a65c:	dc000c15 	stw	r16,48(sp)
   3a660:	df000c04 	addi	fp,sp,48
   3a664:	e13ffe15 	stw	r4,-8(fp)
   3a668:	e17fff15 	stw	r5,-4(fp)
	alt_u8 speed;
	alt_u8 duplex;
    
	alt_u8 gb_capable;
    
    alt_tse_phy_info *pphy = 0;
   3a66c:	e03ff715 	stw	zero,-36(fp)
    alt_tse_mac_info *pmac_info = 0;
   3a670:	e03ff815 	stw	zero,-32(fp)
    alt_tse_system_info *psys = 0;
   3a674:	e03ff915 	stw	zero,-28(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
   3a678:	e03ffa05 	stb	zero,-24(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
   3a67c:	e13ffe17 	ldw	r4,-8(fp)
   3a680:	00370ac0 	call	370ac <alt_tse_get_mac_group_index>
   3a684:	e0bffa45 	stb	r2,-23(fp)
         
    /* Record previous MDIO address, to be restored at the end of function */
    np_tse_mac *pmac_group_base = (np_tse_mac *)pmac_group->pmac_info[0]->psys_info->tse_mac_base;
   3a688:	e0bffe17 	ldw	r2,-8(fp)
   3a68c:	10800117 	ldw	r2,4(r2)
   3a690:	10800217 	ldw	r2,8(r2)
   3a694:	10800017 	ldw	r2,0(r2)
   3a698:	e0bffb15 	stw	r2,-20(fp)
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
   3a69c:	e0bffb17 	ldw	r2,-20(fp)
   3a6a0:	10801004 	addi	r2,r2,64
   3a6a4:	10800037 	ldwio	r2,0(r2)
   3a6a8:	e0bffc15 	stw	r2,-16(fp)
    
    if((common_speed < TSE_PHY_SPEED_10) || (common_speed > TSE_PHY_SPEED_1000)) {
   3a6ac:	e0bfff17 	ldw	r2,-4(fp)
   3a6b0:	10000316 	blt	r2,zero,3a6c0 <alt_tse_phy_set_common_speed+0x74>
   3a6b4:	e0bfff17 	ldw	r2,-4(fp)
   3a6b8:	108000d0 	cmplti	r2,r2,3
   3a6bc:	10000c1e 	bne	r2,zero,3a6f0 <alt_tse_phy_set_common_speed+0xa4>
        tse_dprintf(2, "ERROR   : MAC Group[%d] - Invalid common speed specified! common speed = %d\n", mac_group_index, (int)common_speed);
   3a6c0:	e0bffa47 	ldb	r2,-23(fp)
   3a6c4:	01000134 	movhi	r4,4
   3a6c8:	210bff04 	addi	r4,r4,12284
   3a6cc:	100b883a 	mov	r5,r2
   3a6d0:	e1bfff17 	ldw	r6,-4(fp)
   3a6d4:	00044740 	call	4474 <printf>
		/* Restore previous MDIO address */
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
   3a6d8:	e0bffb17 	ldw	r2,-20(fp)
   3a6dc:	10801004 	addi	r2,r2,64
   3a6e0:	e0fffc17 	ldw	r3,-16(fp)
   3a6e4:	10c00035 	stwio	r3,0(r2)
        return TSE_PHY_SPEED_NO_COMMON;
   3a6e8:	00bfffc4 	movi	r2,-1
   3a6ec:	0000fd06 	br	3aae4 <alt_tse_phy_set_common_speed+0x498>
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
   3a6f0:	e03ff515 	stw	zero,-44(fp)
   3a6f4:	0000db06 	br	3aa64 <alt_tse_phy_set_common_speed+0x418>
        pmac_info = pmac_group->pmac_info[i];
   3a6f8:	e0fffe17 	ldw	r3,-8(fp)
   3a6fc:	e0bff517 	ldw	r2,-44(fp)
   3a700:	10800044 	addi	r2,r2,1
   3a704:	1085883a 	add	r2,r2,r2
   3a708:	1085883a 	add	r2,r2,r2
   3a70c:	1885883a 	add	r2,r3,r2
   3a710:	10800017 	ldw	r2,0(r2)
   3a714:	e0bff815 	stw	r2,-32(fp)
        mac_info_index = alt_tse_get_mac_info_index(pmac_info);
   3a718:	e13ff817 	ldw	r4,-32(fp)
   3a71c:	00371200 	call	37120 <alt_tse_get_mac_info_index>
   3a720:	e0bffa05 	stb	r2,-24(fp)

        pphy = pmac_info->pphy_info;
   3a724:	e0bff817 	ldw	r2,-32(fp)
   3a728:	10800117 	ldw	r2,4(r2)
   3a72c:	e0bff715 	stw	r2,-36(fp)
        
        /* if no PHY connected */
        if(!pphy) {
   3a730:	e0bff717 	ldw	r2,-36(fp)
   3a734:	1000c726 	beq	r2,zero,3aa54 <alt_tse_phy_set_common_speed+0x408>
            continue;
        }
        
        psys = pmac_info->psys_info; 
   3a738:	e0bff817 	ldw	r2,-32(fp)
   3a73c:	10800217 	ldw	r2,8(r2)
   3a740:	e0bff915 	stw	r2,-28(fp)
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
   3a744:	e0bff717 	ldw	r2,-36(fp)
   3a748:	10800003 	ldbu	r2,0(r2)
   3a74c:	10803fcc 	andi	r2,r2,255
   3a750:	e13ff717 	ldw	r4,-36(fp)
   3a754:	100b883a 	mov	r5,r2
   3a758:	0037e940 	call	37e94 <alt_tse_phy_wr_mdio_addr>

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
   3a75c:	e0bff717 	ldw	r2,-36(fp)
   3a760:	108000c3 	ldbu	r2,3(r2)
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
   3a764:	10803fcc 	andi	r2,r2,255
   3a768:	10000c1e 	bne	r2,zero,3a79c <alt_tse_phy_set_common_speed+0x150>
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
   3a76c:	e0bff717 	ldw	r2,-36(fp)
   3a770:	10800103 	ldbu	r2,4(r2)
   3a774:	10803fcc 	andi	r2,r2,255
   3a778:	1000081e 	bne	r2,zero,3a79c <alt_tse_phy_set_common_speed+0x150>
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
   3a77c:	e0bff717 	ldw	r2,-36(fp)
   3a780:	10800043 	ldbu	r2,1(r2)
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
   3a784:	10803fcc 	andi	r2,r2,255
   3a788:	1000041e 	bne	r2,zero,3a79c <alt_tse_phy_set_common_speed+0x150>
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
   3a78c:	e0bff717 	ldw	r2,-36(fp)
   3a790:	10800083 	ldbu	r2,2(r2)
   3a794:	10803fcc 	andi	r2,r2,255
   3a798:	10000226 	beq	r2,zero,3a7a4 <alt_tse_phy_set_common_speed+0x158>
   3a79c:	00800044 	movi	r2,1
   3a7a0:	00000106 	br	3a7a8 <alt_tse_phy_set_common_speed+0x15c>
   3a7a4:	0005883a 	mov	r2,zero
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
   3a7a8:	e0bffd05 	stb	r2,-12(fp)
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
        
        /* if PHY does not supports 1000 Mbps, and common speed is 1000 Mbps */
        if((!gb_capable) && (common_speed == TSE_PHY_SPEED_1000)) {
   3a7ac:	e0bffd03 	ldbu	r2,-12(fp)
   3a7b0:	1000101e 	bne	r2,zero,3a7f4 <alt_tse_phy_set_common_speed+0x1a8>
   3a7b4:	e0bfff17 	ldw	r2,-4(fp)
   3a7b8:	10800098 	cmpnei	r2,r2,2
   3a7bc:	10000d1e 	bne	r2,zero,3a7f4 <alt_tse_phy_set_common_speed+0x1a8>
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - PHY does not support 1000 Mbps, please specify valid common speed\n", mac_group_index, mac_info_index);
   3a7c0:	e0fffa47 	ldb	r3,-23(fp)
   3a7c4:	e0bffa07 	ldb	r2,-24(fp)
   3a7c8:	01000134 	movhi	r4,4
   3a7cc:	210c1304 	addi	r4,r4,12364
   3a7d0:	180b883a 	mov	r5,r3
   3a7d4:	100d883a 	mov	r6,r2
   3a7d8:	00044740 	call	4474 <printf>
			/* Restore previous MDIO address */
			IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
   3a7dc:	e0bffb17 	ldw	r2,-20(fp)
   3a7e0:	10801004 	addi	r2,r2,64
   3a7e4:	e0fffc17 	ldw	r3,-16(fp)
   3a7e8:	10c00035 	stwio	r3,0(r2)
            return TSE_PHY_SPEED_NO_COMMON;
   3a7ec:	00bfffc4 	movi	r2,-1
   3a7f0:	0000bc06 	br	3aae4 <alt_tse_phy_set_common_speed+0x498>
        }
        
        /* if PHY is not Auto-Negotiation capable */
        if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
   3a7f4:	e13ff717 	ldw	r4,-36(fp)
   3a7f8:	01400044 	movi	r5,1
   3a7fc:	018000c4 	movi	r6,3
   3a800:	01c00044 	movi	r7,1
   3a804:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   3a808:	1000141e 	bne	r2,zero,3a85c <alt_tse_phy_set_common_speed+0x210>
            
            /* if PHY supports 1000 Mbps, write msb of speed */
            if(gb_capable) {
   3a80c:	e0bffd03 	ldbu	r2,-12(fp)
   3a810:	10000926 	beq	r2,zero,3a838 <alt_tse_phy_set_common_speed+0x1ec>
                alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_MSB, 1, common_speed >> 1);
   3a814:	e0bfff17 	ldw	r2,-4(fp)
   3a818:	1005d07a 	srai	r2,r2,1
   3a81c:	10bfffcc 	andi	r2,r2,65535
   3a820:	d8800015 	stw	r2,0(sp)
   3a824:	e13ff717 	ldw	r4,-36(fp)
   3a828:	000b883a 	mov	r5,zero
   3a82c:	01800184 	movi	r6,6
   3a830:	01c00044 	movi	r7,1
   3a834:	0037eec0 	call	37eec <alt_tse_phy_wr_mdio_reg>
            }
            /* write lsb of speed */
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_LSB, 1, common_speed);
   3a838:	e0bfff17 	ldw	r2,-4(fp)
   3a83c:	10bfffcc 	andi	r2,r2,65535
   3a840:	d8800015 	stw	r2,0(sp)
   3a844:	e13ff717 	ldw	r4,-36(fp)
   3a848:	000b883a 	mov	r5,zero
   3a84c:	01800344 	movi	r6,13
   3a850:	01c00044 	movi	r7,1
   3a854:	0037eec0 	call	37eec <alt_tse_phy_wr_mdio_reg>
            
            /* continue to next PHY */
            continue;
   3a858:	00007f06 	br	3aa58 <alt_tse_phy_set_common_speed+0x40c>
        }
        
        /* set Auto-Negotiation advertisement based on common speed */
        if(common_speed == TSE_PHY_SPEED_1000) {
   3a85c:	e0bfff17 	ldw	r2,-4(fp)
   3a860:	10800098 	cmpnei	r2,r2,2
   3a864:	10000a1e 	bne	r2,zero,3a890 <alt_tse_phy_set_common_speed+0x244>
            alt_tse_phy_set_adv_1000(pphy, 1);
   3a868:	e13ff717 	ldw	r4,-36(fp)
   3a86c:	01400044 	movi	r5,1
   3a870:	0039d780 	call	39d78 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
   3a874:	e13ff717 	ldw	r4,-36(fp)
   3a878:	01400044 	movi	r5,1
   3a87c:	0039f340 	call	39f34 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
   3a880:	e13ff717 	ldw	r4,-36(fp)
   3a884:	01400044 	movi	r5,1
   3a888:	003a17c0 	call	3a17c <alt_tse_phy_set_adv_10>
   3a88c:	00002206 	br	3a918 <alt_tse_phy_set_common_speed+0x2cc>
        }
        else if(common_speed == TSE_PHY_SPEED_100) {
   3a890:	e0bfff17 	ldw	r2,-4(fp)
   3a894:	10800058 	cmpnei	r2,r2,1
   3a898:	10000a1e 	bne	r2,zero,3a8c4 <alt_tse_phy_set_common_speed+0x278>
            alt_tse_phy_set_adv_1000(pphy, 0);
   3a89c:	e13ff717 	ldw	r4,-36(fp)
   3a8a0:	000b883a 	mov	r5,zero
   3a8a4:	0039d780 	call	39d78 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
   3a8a8:	e13ff717 	ldw	r4,-36(fp)
   3a8ac:	01400044 	movi	r5,1
   3a8b0:	0039f340 	call	39f34 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
   3a8b4:	e13ff717 	ldw	r4,-36(fp)
   3a8b8:	01400044 	movi	r5,1
   3a8bc:	003a17c0 	call	3a17c <alt_tse_phy_set_adv_10>
   3a8c0:	00001506 	br	3a918 <alt_tse_phy_set_common_speed+0x2cc>
        }    
        else if(common_speed == TSE_PHY_SPEED_10) {
   3a8c4:	e0bfff17 	ldw	r2,-4(fp)
   3a8c8:	10000a1e 	bne	r2,zero,3a8f4 <alt_tse_phy_set_common_speed+0x2a8>
            alt_tse_phy_set_adv_1000(pphy, 0);
   3a8cc:	e13ff717 	ldw	r4,-36(fp)
   3a8d0:	000b883a 	mov	r5,zero
   3a8d4:	0039d780 	call	39d78 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
   3a8d8:	e13ff717 	ldw	r4,-36(fp)
   3a8dc:	000b883a 	mov	r5,zero
   3a8e0:	0039f340 	call	39f34 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
   3a8e4:	e13ff717 	ldw	r4,-36(fp)
   3a8e8:	01400044 	movi	r5,1
   3a8ec:	003a17c0 	call	3a17c <alt_tse_phy_set_adv_10>
   3a8f0:	00000906 	br	3a918 <alt_tse_phy_set_common_speed+0x2cc>
        }
        else {
            alt_tse_phy_set_adv_1000(pphy, 0);
   3a8f4:	e13ff717 	ldw	r4,-36(fp)
   3a8f8:	000b883a 	mov	r5,zero
   3a8fc:	0039d780 	call	39d78 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
   3a900:	e13ff717 	ldw	r4,-36(fp)
   3a904:	000b883a 	mov	r5,zero
   3a908:	0039f340 	call	39f34 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 0);
   3a90c:	e13ff717 	ldw	r4,-36(fp)
   3a910:	000b883a 	mov	r5,zero
   3a914:	003a17c0 	call	3a17c <alt_tse_phy_set_adv_10>
        }
        
        /* if PHY Auto-Negotiation is completed */
        if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 1) {
   3a918:	e13ff717 	ldw	r4,-36(fp)
   3a91c:	01400044 	movi	r5,1
   3a920:	01800144 	movi	r6,5
   3a924:	01c00044 	movi	r7,1
   3a928:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   3a92c:	10800058 	cmpnei	r2,r2,1
   3a930:	10003a1e 	bne	r2,zero,3aa1c <alt_tse_phy_set_common_speed+0x3d0>
            
            /* read both msb and lsb of speed bits if PHY support 1000 Mbps */
            if(gb_capable) {
   3a934:	e0bffd03 	ldbu	r2,-12(fp)
   3a938:	10000f26 	beq	r2,zero,3a978 <alt_tse_phy_set_common_speed+0x32c>
        
                /* get speed information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
   3a93c:	e0bff717 	ldw	r2,-36(fp)
   3a940:	10800517 	ldw	r2,20(r2)
   3a944:	10801583 	ldbu	r2,86(r2)
   3a948:	10c03fcc 	andi	r3,r2,255
   3a94c:	e0bff717 	ldw	r2,-36(fp)
   3a950:	10800517 	ldw	r2,20(r2)
   3a954:	108015c3 	ldbu	r2,87(r2)
   3a958:	10803fcc 	andi	r2,r2,255
   3a95c:	e13ff717 	ldw	r4,-36(fp)
   3a960:	180b883a 	mov	r5,r3
   3a964:	100d883a 	mov	r6,r2
   3a968:	01c00084 	movi	r7,2
   3a96c:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   3a970:	e0bff605 	stb	r2,-40(fp)
   3a974:	00000e06 	br	3a9b0 <alt_tse_phy_set_common_speed+0x364>
            }
            
            /* read lsb of speed only if PHY support only 10/100 Mbps */
            else {
                /* get speed and link information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 1);
   3a978:	e0bff717 	ldw	r2,-36(fp)
   3a97c:	10800517 	ldw	r2,20(r2)
   3a980:	10801583 	ldbu	r2,86(r2)
   3a984:	10c03fcc 	andi	r3,r2,255
   3a988:	e0bff717 	ldw	r2,-36(fp)
   3a98c:	10800517 	ldw	r2,20(r2)
   3a990:	108015c3 	ldbu	r2,87(r2)
   3a994:	10803fcc 	andi	r2,r2,255
   3a998:	e13ff717 	ldw	r4,-36(fp)
   3a99c:	180b883a 	mov	r5,r3
   3a9a0:	100d883a 	mov	r6,r2
   3a9a4:	01c00044 	movi	r7,1
   3a9a8:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   3a9ac:	e0bff605 	stb	r2,-40(fp)
            }
            
            /* if current speed != common speed, then restart Auto-Negotiation */
            if(speed != common_speed) {
   3a9b0:	e0fff603 	ldbu	r3,-40(fp)
   3a9b4:	e0bfff17 	ldw	r2,-4(fp)
   3a9b8:	18800326 	beq	r3,r2,3a9c8 <alt_tse_phy_set_common_speed+0x37c>
                alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
   3a9bc:	e13ff717 	ldw	r4,-36(fp)
   3a9c0:	015d4c04 	movi	r5,30000
   3a9c4:	00394c00 	call	394c0 <alt_tse_phy_restart_an>
            }
            
            /* get speed information after Auto-Negotiation */
            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
   3a9c8:	e0bff717 	ldw	r2,-36(fp)
   3a9cc:	10800517 	ldw	r2,20(r2)
   3a9d0:	10801583 	ldbu	r2,86(r2)
   3a9d4:	10c03fcc 	andi	r3,r2,255
   3a9d8:	e0bff717 	ldw	r2,-36(fp)
   3a9dc:	10800517 	ldw	r2,20(r2)
   3a9e0:	10801603 	ldbu	r2,88(r2)
   3a9e4:	10803fcc 	andi	r2,r2,255
   3a9e8:	e13ff717 	ldw	r4,-36(fp)
   3a9ec:	180b883a 	mov	r5,r3
   3a9f0:	100d883a 	mov	r6,r2
   3a9f4:	01c00044 	movi	r7,1
   3a9f8:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   3a9fc:	e0bffd45 	stb	r2,-11(fp)
            
            /* Set MAC duplex register */
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
   3aa00:	e0bff917 	ldw	r2,-28(fp)
   3aa04:	10800017 	ldw	r2,0(r2)
   3aa08:	1007883a 	mov	r3,r2
   3aa0c:	e0bffd43 	ldbu	r2,-11(fp)
   3aa10:	1809883a 	mov	r4,r3
   3aa14:	100b883a 	mov	r5,r2
   3aa18:	00373580 	call	37358 <alt_tse_mac_set_duplex>
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
   3aa1c:	e47ffa47 	ldb	r17,-23(fp)
   3aa20:	e43ffa07 	ldb	r16,-24(fp)
   3aa24:	e13ff717 	ldw	r4,-36(fp)
   3aa28:	01400044 	movi	r5,1
   3aa2c:	000d883a 	mov	r6,zero
   3aa30:	01c00404 	movi	r7,16
   3aa34:	00380180 	call	38018 <alt_tse_phy_rd_mdio_reg>
   3aa38:	01000134 	movhi	r4,4
   3aa3c:	210c2a04 	addi	r4,r4,12456
   3aa40:	880b883a 	mov	r5,r17
   3aa44:	800d883a 	mov	r6,r16
   3aa48:	100f883a 	mov	r7,r2
   3aa4c:	00044740 	call	4474 <printf>
   3aa50:	00000106 	br	3aa58 <alt_tse_phy_set_common_speed+0x40c>

        pphy = pmac_info->pphy_info;
        
        /* if no PHY connected */
        if(!pphy) {
            continue;
   3aa54:	0001883a 	nop
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
        return TSE_PHY_SPEED_NO_COMMON;
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
   3aa58:	e0bff517 	ldw	r2,-44(fp)
   3aa5c:	10800044 	addi	r2,r2,1
   3aa60:	e0bff515 	stw	r2,-44(fp)
   3aa64:	e0bffe17 	ldw	r2,-8(fp)
   3aa68:	10800003 	ldbu	r2,0(r2)
   3aa6c:	10803fcc 	andi	r2,r2,255
   3aa70:	e0fff517 	ldw	r3,-44(fp)
   3aa74:	18bf2016 	blt	r3,r2,3a6f8 <alt_tse_phy_set_common_speed+0xac>
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
    }
    tse_dprintf(5, "INFO    : MAC Group[%d] - All PHYs set to common speed : %d Mbps\n", mac_group_index, (common_speed == TSE_PHY_SPEED_1000) ? 1000 : ((common_speed == TSE_PHY_SPEED_100) ? 100 : 10));
   3aa78:	e0fffa47 	ldb	r3,-23(fp)
   3aa7c:	e0bfff17 	ldw	r2,-4(fp)
   3aa80:	108000a0 	cmpeqi	r2,r2,2
   3aa84:	1000071e 	bne	r2,zero,3aaa4 <alt_tse_phy_set_common_speed+0x458>
   3aa88:	e0bfff17 	ldw	r2,-4(fp)
   3aa8c:	10800058 	cmpnei	r2,r2,1
   3aa90:	1000021e 	bne	r2,zero,3aa9c <alt_tse_phy_set_common_speed+0x450>
   3aa94:	00801904 	movi	r2,100
   3aa98:	00000106 	br	3aaa0 <alt_tse_phy_set_common_speed+0x454>
   3aa9c:	00800284 	movi	r2,10
   3aaa0:	00000106 	br	3aaa8 <alt_tse_phy_set_common_speed+0x45c>
   3aaa4:	0080fa04 	movi	r2,1000
   3aaa8:	01000134 	movhi	r4,4
   3aaac:	210c3604 	addi	r4,r4,12504
   3aab0:	180b883a 	mov	r5,r3
   3aab4:	100d883a 	mov	r6,r2
   3aab8:	00044740 	call	4474 <printf>

    /* Set MAC speed register */
    alt_tse_mac_set_speed(pmac_group_base, common_speed);
   3aabc:	e0bfff17 	ldw	r2,-4(fp)
   3aac0:	10803fcc 	andi	r2,r2,255
   3aac4:	e13ffb17 	ldw	r4,-20(fp)
   3aac8:	100b883a 	mov	r5,r2
   3aacc:	00372780 	call	37278 <alt_tse_mac_set_speed>
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
   3aad0:	e0bffb17 	ldw	r2,-20(fp)
   3aad4:	10801004 	addi	r2,r2,64
   3aad8:	e0fffc17 	ldw	r3,-16(fp)
   3aadc:	10c00035 	stwio	r3,0(r2)
        
    return common_speed;
   3aae0:	e0bfff17 	ldw	r2,-4(fp)
}
   3aae4:	e037883a 	mov	sp,fp
   3aae8:	dfc00317 	ldw	ra,12(sp)
   3aaec:	df000217 	ldw	fp,8(sp)
   3aaf0:	dc400117 	ldw	r17,4(sp)
   3aaf4:	dc000017 	ldw	r16,0(sp)
   3aaf8:	dec00404 	addi	sp,sp,16
   3aafc:	f800283a 	ret

0003ab00 <marvell_phy_cfg>:

/* @Function Description: Additional configuration for Marvell PHY
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address of MAC group
 */
alt_32 marvell_phy_cfg(np_tse_mac *pmac) {
   3ab00:	defffc04 	addi	sp,sp,-16
   3ab04:	dfc00315 	stw	ra,12(sp)
   3ab08:	df000215 	stw	fp,8(sp)
   3ab0c:	df000204 	addi	fp,sp,8
   3ab10:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat;
    
    /* If there is no link yet, we enable auto crossover and reset the PHY */
    if((IORD(&pmac->mdio1.STATUS, 0) & PCS_ST_an_done) == 0) {
   3ab14:	e0bfff17 	ldw	r2,-4(fp)
   3ab18:	1080a104 	addi	r2,r2,644
   3ab1c:	10800037 	ldwio	r2,0(r2)
   3ab20:	1080080c 	andi	r2,r2,32
   3ab24:	1000161e 	bne	r2,zero,3ab80 <marvell_phy_cfg+0x80>
        tse_dprintf(5, "MARVELL : Enabling auto crossover\n");
   3ab28:	01000134 	movhi	r4,4
   3ab2c:	210c4704 	addi	r4,r4,12572
   3ab30:	00045340 	call	4534 <puts>
        IOWR(&pmac->mdio1.CONTROL, 16, 0x0078);
   3ab34:	e0bfff17 	ldw	r2,-4(fp)
   3ab38:	1080a004 	addi	r2,r2,640
   3ab3c:	10801004 	addi	r2,r2,64
   3ab40:	00c01e04 	movi	r3,120
   3ab44:	10c00035 	stwio	r3,0(r2)
        tse_dprintf(5, "MARVELL : PHY reset\n");
   3ab48:	01000134 	movhi	r4,4
   3ab4c:	210c5004 	addi	r4,r4,12608
   3ab50:	00045340 	call	4534 <puts>
        dat = IORD(&pmac->mdio1.CONTROL, 0); 
   3ab54:	e0bfff17 	ldw	r2,-4(fp)
   3ab58:	1080a004 	addi	r2,r2,640
   3ab5c:	10800037 	ldwio	r2,0(r2)
   3ab60:	e0bffe0d 	sth	r2,-8(fp)
        IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);        
   3ab64:	e0bfff17 	ldw	r2,-4(fp)
   3ab68:	1080a004 	addi	r2,r2,640
   3ab6c:	e13ffe0b 	ldhu	r4,-8(fp)
   3ab70:	00e00004 	movi	r3,-32768
   3ab74:	20c6b03a 	or	r3,r4,r3
   3ab78:	18ffffcc 	andi	r3,r3,65535
   3ab7c:	10c00035 	stwio	r3,0(r2)
    }
    
    return 0;
   3ab80:	0005883a 	mov	r2,zero
}
   3ab84:	e037883a 	mov	sp,fp
   3ab88:	dfc00117 	ldw	ra,4(sp)
   3ab8c:	df000017 	ldw	fp,0(sp)
   3ab90:	dec00204 	addi	sp,sp,8
   3ab94:	f800283a 	ret

0003ab98 <marvell_cfg_gmii>:

/* @Function Description: Change operating mode of Marvell PHY to GMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_gmii(np_tse_mac *pmac) {
   3ab98:	defffc04 	addi	sp,sp,-16
   3ab9c:	dfc00315 	stw	ra,12(sp)
   3aba0:	df000215 	stw	fp,8(sp)
   3aba4:	df000204 	addi	fp,sp,8
   3aba8:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
   3abac:	e0bfff17 	ldw	r2,-4(fp)
   3abb0:	1080bb04 	addi	r2,r2,748
   3abb4:	10800037 	ldwio	r2,0(r2)
   3abb8:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
   3abbc:	e0fffe0b 	ldhu	r3,-8(fp)
   3abc0:	00bffc04 	movi	r2,-16
   3abc4:	1884703a 	and	r2,r3,r2
   3abc8:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to GMII to copper mode\n");
   3abcc:	01000134 	movhi	r4,4
   3abd0:	210c5504 	addi	r4,r4,12628
   3abd4:	00045340 	call	4534 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xf);
   3abd8:	e0bfff17 	ldw	r2,-4(fp)
   3abdc:	1080bb04 	addi	r2,r2,748
   3abe0:	e0fffe0b 	ldhu	r3,-8(fp)
   3abe4:	18c003d4 	ori	r3,r3,15
   3abe8:	18ffffcc 	andi	r3,r3,65535
   3abec:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
   3abf0:	01000134 	movhi	r4,4
   3abf4:	210c6104 	addi	r4,r4,12676
   3abf8:	00045340 	call	4534 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
   3abfc:	e0bfff17 	ldw	r2,-4(fp)
   3ac00:	1080b404 	addi	r2,r2,720
   3ac04:	10800037 	ldwio	r2,0(r2)
   3ac08:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
   3ac0c:	e0fffe0b 	ldhu	r3,-8(fp)
   3ac10:	00bfdf44 	movi	r2,-131
   3ac14:	1884703a 	and	r2,r3,r2
   3ac18:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
   3ac1c:	e0bfff17 	ldw	r2,-4(fp)
   3ac20:	1080b404 	addi	r2,r2,720
   3ac24:	e0fffe0b 	ldhu	r3,-8(fp)
   3ac28:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
   3ac2c:	01000134 	movhi	r4,4
   3ac30:	210c5004 	addi	r4,r4,12608
   3ac34:	00045340 	call	4534 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
   3ac38:	e0bfff17 	ldw	r2,-4(fp)
   3ac3c:	1080a004 	addi	r2,r2,640
   3ac40:	10800037 	ldwio	r2,0(r2)
   3ac44:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
   3ac48:	e0bfff17 	ldw	r2,-4(fp)
   3ac4c:	1080a004 	addi	r2,r2,640
   3ac50:	e13ffe0b 	ldhu	r4,-8(fp)
   3ac54:	00e00004 	movi	r3,-32768
   3ac58:	20c6b03a 	or	r3,r4,r3
   3ac5c:	18ffffcc 	andi	r3,r3,65535
   3ac60:	10c00035 	stwio	r3,0(r2)
    
    return 1;
   3ac64:	00800044 	movi	r2,1
}
   3ac68:	e037883a 	mov	sp,fp
   3ac6c:	dfc00117 	ldw	ra,4(sp)
   3ac70:	df000017 	ldw	fp,0(sp)
   3ac74:	dec00204 	addi	sp,sp,8
   3ac78:	f800283a 	ret

0003ac7c <marvell_cfg_sgmii>:

/* @Function Description: Change operating mode of Marvell PHY to SGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_sgmii(np_tse_mac *pmac) {
   3ac7c:	defffc04 	addi	sp,sp,-16
   3ac80:	dfc00315 	stw	ra,12(sp)
   3ac84:	df000215 	stw	fp,8(sp)
   3ac88:	df000204 	addi	fp,sp,8
   3ac8c:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
   3ac90:	e0bfff17 	ldw	r2,-4(fp)
   3ac94:	1080bb04 	addi	r2,r2,748
   3ac98:	10800037 	ldwio	r2,0(r2)
   3ac9c:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
   3aca0:	e0fffe0b 	ldhu	r3,-8(fp)
   3aca4:	00bffc04 	movi	r2,-16
   3aca8:	1884703a 	and	r2,r3,r2
   3acac:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to SGMII without clock with SGMII Auto-Neg to copper mode\n");
   3acb0:	01000134 	movhi	r4,4
   3acb4:	210c6b04 	addi	r4,r4,12716
   3acb8:	00045340 	call	4534 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0x4);
   3acbc:	e0bfff17 	ldw	r2,-4(fp)
   3acc0:	1080bb04 	addi	r2,r2,748
   3acc4:	e0fffe0b 	ldhu	r3,-8(fp)
   3acc8:	18c00114 	ori	r3,r3,4
   3accc:	18ffffcc 	andi	r3,r3,65535
   3acd0:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
   3acd4:	01000134 	movhi	r4,4
   3acd8:	210c6104 	addi	r4,r4,12676
   3acdc:	00045340 	call	4534 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
   3ace0:	e0bfff17 	ldw	r2,-4(fp)
   3ace4:	1080b404 	addi	r2,r2,720
   3ace8:	10800037 	ldwio	r2,0(r2)
   3acec:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
   3acf0:	e0fffe0b 	ldhu	r3,-8(fp)
   3acf4:	00bfdf44 	movi	r2,-131
   3acf8:	1884703a 	and	r2,r3,r2
   3acfc:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
   3ad00:	e0bfff17 	ldw	r2,-4(fp)
   3ad04:	1080b404 	addi	r2,r2,720
   3ad08:	e0fffe0b 	ldhu	r3,-8(fp)
   3ad0c:	10c00035 	stwio	r3,0(r2)

    tse_dprintf(5, "MARVELL : PHY reset\n");
   3ad10:	01000134 	movhi	r4,4
   3ad14:	210c5004 	addi	r4,r4,12608
   3ad18:	00045340 	call	4534 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
   3ad1c:	e0bfff17 	ldw	r2,-4(fp)
   3ad20:	1080a004 	addi	r2,r2,640
   3ad24:	10800037 	ldwio	r2,0(r2)
   3ad28:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
   3ad2c:	e0bfff17 	ldw	r2,-4(fp)
   3ad30:	1080a004 	addi	r2,r2,640
   3ad34:	e13ffe0b 	ldhu	r4,-8(fp)
   3ad38:	00e00004 	movi	r3,-32768
   3ad3c:	20c6b03a 	or	r3,r4,r3
   3ad40:	18ffffcc 	andi	r3,r3,65535
   3ad44:	10c00035 	stwio	r3,0(r2)
    
    return 1;
   3ad48:	00800044 	movi	r2,1
}
   3ad4c:	e037883a 	mov	sp,fp
   3ad50:	dfc00117 	ldw	ra,4(sp)
   3ad54:	df000017 	ldw	fp,0(sp)
   3ad58:	dec00204 	addi	sp,sp,8
   3ad5c:	f800283a 	ret

0003ad60 <marvell_cfg_rgmii>:

/* @Function Description: Change operating mode of Marvell PHY to RGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_rgmii(np_tse_mac *pmac) {
   3ad60:	defffc04 	addi	sp,sp,-16
   3ad64:	dfc00315 	stw	ra,12(sp)
   3ad68:	df000215 	stw	fp,8(sp)
   3ad6c:	df000204 	addi	fp,sp,8
   3ad70:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
   3ad74:	e0bfff17 	ldw	r2,-4(fp)
   3ad78:	1080bb04 	addi	r2,r2,748
   3ad7c:	10800037 	ldwio	r2,0(r2)
   3ad80:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
   3ad84:	e0fffe0b 	ldhu	r3,-8(fp)
   3ad88:	00bffc04 	movi	r2,-16
   3ad8c:	1884703a 	and	r2,r3,r2
   3ad90:	e0bffe0d 	sth	r2,-8(fp)
    
    tse_dprintf(5, "MARVELL : Mode changed to RGMII/Modified MII to Copper mode\n");
   3ad94:	01000134 	movhi	r4,4
   3ad98:	210c8004 	addi	r4,r4,12800
   3ad9c:	00045340 	call	4534 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xb);
   3ada0:	e0bfff17 	ldw	r2,-4(fp)
   3ada4:	1080bb04 	addi	r2,r2,748
   3ada8:	e0fffe0b 	ldhu	r3,-8(fp)
   3adac:	18c002d4 	ori	r3,r3,11
   3adb0:	18ffffcc 	andi	r3,r3,65535
   3adb4:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Enable RGMII Timing Control\n");
   3adb8:	01000134 	movhi	r4,4
   3adbc:	210c8f04 	addi	r4,r4,12860
   3adc0:	00045340 	call	4534 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0);
   3adc4:	e0bfff17 	ldw	r2,-4(fp)
   3adc8:	1080b404 	addi	r2,r2,720
   3adcc:	10800037 	ldwio	r2,0(r2)
   3add0:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
   3add4:	e0fffe0b 	ldhu	r3,-8(fp)
   3add8:	00bfdf44 	movi	r2,-131
   3addc:	1884703a 	and	r2,r3,r2
   3ade0:	e0bffe0d 	sth	r2,-8(fp)
    dat |= 0x82;
   3ade4:	e0bffe0b 	ldhu	r2,-8(fp)
   3ade8:	10802094 	ori	r2,r2,130
   3adec:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);    
   3adf0:	e0bfff17 	ldw	r2,-4(fp)
   3adf4:	1080b404 	addi	r2,r2,720
   3adf8:	e0fffe0b 	ldhu	r3,-8(fp)
   3adfc:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
   3ae00:	01000134 	movhi	r4,4
   3ae04:	210c5004 	addi	r4,r4,12608
   3ae08:	00045340 	call	4534 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
   3ae0c:	e0bfff17 	ldw	r2,-4(fp)
   3ae10:	1080a004 	addi	r2,r2,640
   3ae14:	10800037 	ldwio	r2,0(r2)
   3ae18:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
   3ae1c:	e0bfff17 	ldw	r2,-4(fp)
   3ae20:	1080a004 	addi	r2,r2,640
   3ae24:	e13ffe0b 	ldhu	r4,-8(fp)
   3ae28:	00e00004 	movi	r3,-32768
   3ae2c:	20c6b03a 	or	r3,r4,r3
   3ae30:	18ffffcc 	andi	r3,r3,65535
   3ae34:	10c00035 	stwio	r3,0(r2)
    
    return 1;
   3ae38:	00800044 	movi	r2,1
    
}
   3ae3c:	e037883a 	mov	sp,fp
   3ae40:	dfc00117 	ldw	ra,4(sp)
   3ae44:	df000017 	ldw	fp,0(sp)
   3ae48:	dec00204 	addi	sp,sp,8
   3ae4c:	f800283a 	ret

0003ae50 <DP83848C_link_status_read>:

/* @Function Description: Read link status from PHY specific status register of DP83848C
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_u32 DP83848C_link_status_read(np_tse_mac *pmac) {
   3ae50:	defffc04 	addi	sp,sp,-16
   3ae54:	df000315 	stw	fp,12(sp)
   3ae58:	df000304 	addi	fp,sp,12
   3ae5c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 link_status = 0;
   3ae60:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 reg_status = IORD(&pmac->mdio1.reg10, 0);
   3ae64:	e0bfff17 	ldw	r2,-4(fp)
   3ae68:	1080b004 	addi	r2,r2,704
   3ae6c:	10800037 	ldwio	r2,0(r2)
   3ae70:	e0bffe15 	stw	r2,-8(fp)
	
	/* If speed == 10 Mbps */
	if(reg_status & 0x2) {
   3ae74:	e0bffe17 	ldw	r2,-8(fp)
   3ae78:	1080008c 	andi	r2,r2,2
   3ae7c:	10000426 	beq	r2,zero,3ae90 <DP83848C_link_status_read+0x40>
		link_status |= 0x8;
   3ae80:	e0bffd17 	ldw	r2,-12(fp)
   3ae84:	10800214 	ori	r2,r2,8
   3ae88:	e0bffd15 	stw	r2,-12(fp)
   3ae8c:	00000306 	br	3ae9c <DP83848C_link_status_read+0x4c>
	}
	/* Else speed = 100 Mbps */
	else {
		link_status |= 0x4;
   3ae90:	e0bffd17 	ldw	r2,-12(fp)
   3ae94:	10800114 	ori	r2,r2,4
   3ae98:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* If duplex == Full */
	if(reg_status & 0x4) {
   3ae9c:	e0bffe17 	ldw	r2,-8(fp)
   3aea0:	1080010c 	andi	r2,r2,4
   3aea4:	10000326 	beq	r2,zero,3aeb4 <DP83848C_link_status_read+0x64>
		link_status |= 0x1;
   3aea8:	e0bffd17 	ldw	r2,-12(fp)
   3aeac:	10800054 	ori	r2,r2,1
   3aeb0:	e0bffd15 	stw	r2,-12(fp)
	}
	
	return link_status;
   3aeb4:	e0bffd17 	ldw	r2,-12(fp)
}
   3aeb8:	e037883a 	mov	sp,fp
   3aebc:	df000017 	ldw	fp,0(sp)
   3aec0:	dec00104 	addi	sp,sp,4
   3aec4:	f800283a 	ret

0003aec8 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
   3aec8:	defffa04 	addi	sp,sp,-24
   3aecc:	dfc00515 	stw	ra,20(sp)
   3aed0:	df000415 	stw	fp,16(sp)
   3aed4:	df000404 	addi	fp,sp,16
   3aed8:	e13ffd15 	stw	r4,-12(fp)
   3aedc:	e17ffe15 	stw	r5,-8(fp)
   3aee0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
   3aee4:	e0bffd17 	ldw	r2,-12(fp)
   3aee8:	10800017 	ldw	r2,0(r2)
   3aeec:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
   3aef0:	e0bffc17 	ldw	r2,-16(fp)
   3aef4:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
   3aef8:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 

    return altera_avalon_uart_read(&dev->state, buffer, space,
   3aefc:	10800217 	ldw	r2,8(r2)
   3af00:	1809883a 	mov	r4,r3
   3af04:	e17ffe17 	ldw	r5,-8(fp)
   3af08:	e1bfff17 	ldw	r6,-4(fp)
   3af0c:	100f883a 	mov	r7,r2
   3af10:	003b4780 	call	3b478 <altera_avalon_uart_read>
      fd->fd_flags);
}
   3af14:	e037883a 	mov	sp,fp
   3af18:	dfc00117 	ldw	ra,4(sp)
   3af1c:	df000017 	ldw	fp,0(sp)
   3af20:	dec00204 	addi	sp,sp,8
   3af24:	f800283a 	ret

0003af28 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
   3af28:	defffa04 	addi	sp,sp,-24
   3af2c:	dfc00515 	stw	ra,20(sp)
   3af30:	df000415 	stw	fp,16(sp)
   3af34:	df000404 	addi	fp,sp,16
   3af38:	e13ffd15 	stw	r4,-12(fp)
   3af3c:	e17ffe15 	stw	r5,-8(fp)
   3af40:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
   3af44:	e0bffd17 	ldw	r2,-12(fp)
   3af48:	10800017 	ldw	r2,0(r2)
   3af4c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
   3af50:	e0bffc17 	ldw	r2,-16(fp)
   3af54:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
   3af58:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 

    return altera_avalon_uart_write(&dev->state, buffer, space,
   3af5c:	10800217 	ldw	r2,8(r2)
   3af60:	1809883a 	mov	r4,r3
   3af64:	e17ffe17 	ldw	r5,-8(fp)
   3af68:	e1bfff17 	ldw	r6,-4(fp)
   3af6c:	100f883a 	mov	r7,r2
   3af70:	003b76c0 	call	3b76c <altera_avalon_uart_write>
      fd->fd_flags);
}
   3af74:	e037883a 	mov	sp,fp
   3af78:	dfc00117 	ldw	ra,4(sp)
   3af7c:	df000017 	ldw	fp,0(sp)
   3af80:	dec00204 	addi	sp,sp,8
   3af84:	f800283a 	ret

0003af88 <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
   3af88:	defffc04 	addi	sp,sp,-16
   3af8c:	dfc00315 	stw	ra,12(sp)
   3af90:	df000215 	stw	fp,8(sp)
   3af94:	df000204 	addi	fp,sp,8
   3af98:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
   3af9c:	e0bfff17 	ldw	r2,-4(fp)
   3afa0:	10800017 	ldw	r2,0(r2)
   3afa4:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
   3afa8:	e0bffe17 	ldw	r2,-8(fp)
   3afac:	10c00a04 	addi	r3,r2,40
   3afb0:	e0bfff17 	ldw	r2,-4(fp)
   3afb4:	10800217 	ldw	r2,8(r2)
   3afb8:	1809883a 	mov	r4,r3
   3afbc:	100b883a 	mov	r5,r2
   3afc0:	003b3d40 	call	3b3d4 <altera_avalon_uart_close>
}
   3afc4:	e037883a 	mov	sp,fp
   3afc8:	dfc00117 	ldw	ra,4(sp)
   3afcc:	df000017 	ldw	fp,0(sp)
   3afd0:	dec00204 	addi	sp,sp,8
   3afd4:	f800283a 	ret

0003afd8 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
   3afd8:	defff404 	addi	sp,sp,-48
   3afdc:	dfc00b15 	stw	ra,44(sp)
   3afe0:	df000a15 	stw	fp,40(sp)
   3afe4:	df000a04 	addi	fp,sp,40
   3afe8:	e13ffd15 	stw	r4,-12(fp)
   3afec:	e17ffe15 	stw	r5,-8(fp)
   3aff0:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
   3aff4:	e0bffd17 	ldw	r2,-12(fp)
   3aff8:	10800017 	ldw	r2,0(r2)
   3affc:	e0bff715 	stw	r2,-36(fp)
 * HAL.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_no_error (void)
{
  return 0;
   3b000:	0005883a 	mov	r2,zero
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
   3b004:	10002e1e 	bne	r2,zero,3b0c0 <altera_avalon_uart_init+0xe8>
   3b008:	e0bffd17 	ldw	r2,-12(fp)
   3b00c:	10800704 	addi	r2,r2,28
   3b010:	e0bff915 	stw	r2,-28(fp)
   3b014:	00800044 	movi	r2,1
   3b018:	e0bffa0d 	sth	r2,-24(fp)
   3b01c:	e0bffa0b 	ldhu	r2,-24(fp)
   3b020:	10000226 	beq	r2,zero,3b02c <altera_avalon_uart_init+0x54>
   3b024:	e0bffa0b 	ldhu	r2,-24(fp)
   3b028:	00000106 	br	3b030 <altera_avalon_uart_init+0x58>
   3b02c:	00800044 	movi	r2,1
   3b030:	e0fffa0b 	ldhu	r3,-24(fp)
   3b034:	1009883a 	mov	r4,r2
   3b038:	180b883a 	mov	r5,r3
   3b03c:	000e9040 	call	e904 <xQueueCreateCountingSemaphore>
   3b040:	e0fff917 	ldw	r3,-28(fp)
   3b044:	18800015 	stw	r2,0(r3)
	return *sem ? 0 : -1;
   3b048:	e0bff917 	ldw	r2,-28(fp)
   3b04c:	10800017 	ldw	r2,0(r2)
   3b050:	10000226 	beq	r2,zero,3b05c <altera_avalon_uart_init+0x84>
   3b054:	0005883a 	mov	r2,zero
   3b058:	00000106 	br	3b060 <altera_avalon_uart_init+0x88>
   3b05c:	00bfffc4 	movi	r2,-1
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
   3b060:	1000171e 	bne	r2,zero,3b0c0 <altera_avalon_uart_init+0xe8>
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);
   3b064:	e0bffd17 	ldw	r2,-12(fp)
   3b068:	10800804 	addi	r2,r2,32
   3b06c:	e0bffb15 	stw	r2,-20(fp)
   3b070:	00800044 	movi	r2,1
   3b074:	e0bffc0d 	sth	r2,-16(fp)
 * alt_sem_create() is a wrapper for xSemaphoreCreateCounting(). The return value is 0 if 
 * the semaphore has been successfully created, or non-zero otherwise.
 */
static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (xSemaphoreHandle* sem, alt_u16 value)
{
	*sem = xSemaphoreCreateCounting(value ? value : 1, value);
   3b078:	e0bffc0b 	ldhu	r2,-16(fp)
   3b07c:	10000226 	beq	r2,zero,3b088 <altera_avalon_uart_init+0xb0>
   3b080:	e0bffc0b 	ldhu	r2,-16(fp)
   3b084:	00000106 	br	3b08c <altera_avalon_uart_init+0xb4>
   3b088:	00800044 	movi	r2,1
   3b08c:	e0fffc0b 	ldhu	r3,-16(fp)
   3b090:	1009883a 	mov	r4,r2
   3b094:	180b883a 	mov	r5,r3
   3b098:	000e9040 	call	e904 <xQueueCreateCountingSemaphore>
   3b09c:	e0fffb17 	ldw	r3,-20(fp)
   3b0a0:	18800015 	stw	r2,0(r3)
	return *sem ? 0 : -1;
   3b0a4:	e0bffb17 	ldw	r2,-20(fp)
   3b0a8:	10800017 	ldw	r2,0(r2)
   3b0ac:	10000226 	beq	r2,zero,3b0b8 <altera_avalon_uart_init+0xe0>
   3b0b0:	0005883a 	mov	r2,zero
   3b0b4:	00000106 	br	3b0bc <altera_avalon_uart_init+0xe4>
   3b0b8:	00bfffc4 	movi	r2,-1
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
   3b0bc:	10000226 	beq	r2,zero,3b0c8 <altera_avalon_uart_init+0xf0>
   3b0c0:	00800044 	movi	r2,1
   3b0c4:	00000106 	br	3b0cc <altera_avalon_uart_init+0xf4>
   3b0c8:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
   3b0cc:	e0bff815 	stw	r2,-32(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
   3b0d0:	e0bff817 	ldw	r2,-32(fp)
   3b0d4:	10000f1e 	bne	r2,zero,3b114 <altera_avalon_uart_init+0x13c>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
   3b0d8:	e0bffd17 	ldw	r2,-12(fp)
   3b0dc:	00c32004 	movi	r3,3200
   3b0e0:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
   3b0e4:	e0bff717 	ldw	r2,-36(fp)
   3b0e8:	10800304 	addi	r2,r2,12
   3b0ec:	e0fffd17 	ldw	r3,-12(fp)
   3b0f0:	18c00117 	ldw	r3,4(r3)
   3b0f4:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
   3b0f8:	d8000015 	stw	zero,0(sp)
   3b0fc:	e13ffe17 	ldw	r4,-8(fp)
   3b100:	e17fff17 	ldw	r5,-4(fp)
   3b104:	01800134 	movhi	r6,4
   3b108:	31ac4a04 	addi	r6,r6,-20184
   3b10c:	e1fffd17 	ldw	r7,-12(fp)
   3b110:	003bd080 	call	3bd08 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
   3b114:	e037883a 	mov	sp,fp
   3b118:	dfc00117 	ldw	ra,4(sp)
   3b11c:	df000017 	ldw	fp,0(sp)
   3b120:	dec00204 	addi	sp,sp,8
   3b124:	f800283a 	ret

0003b128 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
   3b128:	defffa04 	addi	sp,sp,-24
   3b12c:	dfc00515 	stw	ra,20(sp)
   3b130:	df000415 	stw	fp,16(sp)
   3b134:	df000404 	addi	fp,sp,16
   3b138:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
   3b13c:	e0bfff17 	ldw	r2,-4(fp)
   3b140:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
   3b144:	e0bffc17 	ldw	r2,-16(fp)
   3b148:	10800017 	ldw	r2,0(r2)
   3b14c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
   3b150:	e0bffd17 	ldw	r2,-12(fp)
   3b154:	10800204 	addi	r2,r2,8
   3b158:	10800037 	ldwio	r2,0(r2)
   3b15c:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
   3b160:	e0bffd17 	ldw	r2,-12(fp)
   3b164:	10800204 	addi	r2,r2,8
   3b168:	0007883a 	mov	r3,zero
   3b16c:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
   3b170:	e0bffd17 	ldw	r2,-12(fp)
   3b174:	10800204 	addi	r2,r2,8
   3b178:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
   3b17c:	e0bffe17 	ldw	r2,-8(fp)
   3b180:	1080200c 	andi	r2,r2,128
   3b184:	10000326 	beq	r2,zero,3b194 <altera_avalon_uart_irq+0x6c>
  {
    altera_avalon_uart_rxirq(sp, status);
   3b188:	e13ffc17 	ldw	r4,-16(fp)
   3b18c:	e17ffe17 	ldw	r5,-8(fp)
   3b190:	003b1c00 	call	3b1c0 <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
   3b194:	e0bffe17 	ldw	r2,-8(fp)
   3b198:	1081100c 	andi	r2,r2,1088
   3b19c:	10000326 	beq	r2,zero,3b1ac <altera_avalon_uart_irq+0x84>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
   3b1a0:	e13ffc17 	ldw	r4,-16(fp)
   3b1a4:	e17ffe17 	ldw	r5,-8(fp)
   3b1a8:	003b2980 	call	3b298 <altera_avalon_uart_txirq>
  }
  

}
   3b1ac:	e037883a 	mov	sp,fp
   3b1b0:	dfc00117 	ldw	ra,4(sp)
   3b1b4:	df000017 	ldw	fp,0(sp)
   3b1b8:	dec00204 	addi	sp,sp,8
   3b1bc:	f800283a 	ret

0003b1c0 <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
   3b1c0:	defffc04 	addi	sp,sp,-16
   3b1c4:	df000315 	stw	fp,12(sp)
   3b1c8:	df000304 	addi	fp,sp,12
   3b1cc:	e13ffe15 	stw	r4,-8(fp)
   3b1d0:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
   3b1d4:	e0bfff17 	ldw	r2,-4(fp)
   3b1d8:	108000cc 	andi	r2,r2,3
   3b1dc:	1000291e 	bne	r2,zero,3b284 <altera_avalon_uart_rxirq+0xc4>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
   3b1e0:	e0bffe17 	ldw	r2,-8(fp)
   3b1e4:	10800317 	ldw	r2,12(r2)
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
   3b1e8:	e0bffe17 	ldw	r2,-8(fp)
   3b1ec:	10800317 	ldw	r2,12(r2)
   3b1f0:	10800044 	addi	r2,r2,1
   3b1f4:	10800fcc 	andi	r2,r2,63
   3b1f8:	e0bffd15 	stw	r2,-12(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
   3b1fc:	e0bffe17 	ldw	r2,-8(fp)
   3b200:	10800317 	ldw	r2,12(r2)
   3b204:	e0fffe17 	ldw	r3,-8(fp)
   3b208:	18c00017 	ldw	r3,0(r3)
   3b20c:	18c00037 	ldwio	r3,0(r3)
   3b210:	e13ffe17 	ldw	r4,-8(fp)
   3b214:	2085883a 	add	r2,r4,r2
   3b218:	10800904 	addi	r2,r2,36
   3b21c:	10c00005 	stb	r3,0(r2)

  sp->rx_end = next;
   3b220:	e0bffe17 	ldw	r2,-8(fp)
   3b224:	e0fffd17 	ldw	r3,-12(fp)
   3b228:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
   3b22c:	e0bffe17 	ldw	r2,-8(fp)
   3b230:	10800317 	ldw	r2,12(r2)
   3b234:	10800044 	addi	r2,r2,1
   3b238:	10800fcc 	andi	r2,r2,63
   3b23c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
   3b240:	e0bffe17 	ldw	r2,-8(fp)
   3b244:	10c00217 	ldw	r3,8(r2)
   3b248:	e0bffd17 	ldw	r2,-12(fp)
   3b24c:	18800e1e 	bne	r3,r2,3b288 <altera_avalon_uart_rxirq+0xc8>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
   3b250:	e0bffe17 	ldw	r2,-8(fp)
   3b254:	10c00117 	ldw	r3,4(r2)
   3b258:	00bfdfc4 	movi	r2,-129
   3b25c:	1886703a 	and	r3,r3,r2
   3b260:	e0bffe17 	ldw	r2,-8(fp)
   3b264:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
   3b268:	e0bffe17 	ldw	r2,-8(fp)
   3b26c:	10800017 	ldw	r2,0(r2)
   3b270:	10800304 	addi	r2,r2,12
   3b274:	e0fffe17 	ldw	r3,-8(fp)
   3b278:	18c00117 	ldw	r3,4(r3)
   3b27c:	10c00035 	stwio	r3,0(r2)
   3b280:	00000106 	br	3b288 <altera_avalon_uart_rxirq+0xc8>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
   3b284:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
   3b288:	e037883a 	mov	sp,fp
   3b28c:	df000017 	ldw	fp,0(sp)
   3b290:	dec00104 	addi	sp,sp,4
   3b294:	f800283a 	ret

0003b298 <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
   3b298:	defffd04 	addi	sp,sp,-12
   3b29c:	df000215 	stw	fp,8(sp)
   3b2a0:	df000204 	addi	fp,sp,8
   3b2a4:	e13ffe15 	stw	r4,-8(fp)
   3b2a8:	e17fff15 	stw	r5,-4(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
   3b2ac:	e0bffe17 	ldw	r2,-8(fp)
   3b2b0:	10c00417 	ldw	r3,16(r2)
   3b2b4:	e0bffe17 	ldw	r2,-8(fp)
   3b2b8:	10800517 	ldw	r2,20(r2)
   3b2bc:	18803026 	beq	r3,r2,3b380 <altera_avalon_uart_txirq+0xe8>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
   3b2c0:	e0bffe17 	ldw	r2,-8(fp)
   3b2c4:	10800617 	ldw	r2,24(r2)
   3b2c8:	1080008c 	andi	r2,r2,2
   3b2cc:	10000326 	beq	r2,zero,3b2dc <altera_avalon_uart_txirq+0x44>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
   3b2d0:	e0bfff17 	ldw	r2,-4(fp)
   3b2d4:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
   3b2d8:	10001b26 	beq	r2,zero,3b348 <altera_avalon_uart_txirq+0xb0>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
   3b2dc:	e0bffe17 	ldw	r2,-8(fp)
   3b2e0:	10800417 	ldw	r2,16(r2)
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
   3b2e4:	e0bffe17 	ldw	r2,-8(fp)
   3b2e8:	10800017 	ldw	r2,0(r2)
   3b2ec:	10800104 	addi	r2,r2,4
   3b2f0:	e0fffe17 	ldw	r3,-8(fp)
   3b2f4:	18c00417 	ldw	r3,16(r3)
   3b2f8:	e13ffe17 	ldw	r4,-8(fp)
   3b2fc:	20c7883a 	add	r3,r4,r3
   3b300:	18c01904 	addi	r3,r3,100
   3b304:	18c00003 	ldbu	r3,0(r3)
   3b308:	18c03fcc 	andi	r3,r3,255
   3b30c:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
   3b310:	e0bffe17 	ldw	r2,-8(fp)
   3b314:	10800417 	ldw	r2,16(r2)
   3b318:	10800044 	addi	r2,r2,1
   3b31c:	e0fffe17 	ldw	r3,-8(fp)
   3b320:	18800415 	stw	r2,16(r3)
   3b324:	10c00fcc 	andi	r3,r2,63
   3b328:	e0bffe17 	ldw	r2,-8(fp)
   3b32c:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
   3b330:	e0bffe17 	ldw	r2,-8(fp)
   3b334:	10800117 	ldw	r2,4(r2)
   3b338:	10c01014 	ori	r3,r2,64
   3b33c:	e0bffe17 	ldw	r2,-8(fp)
   3b340:	10c00115 	stw	r3,4(r2)
   3b344:	00000e06 	br	3b380 <altera_avalon_uart_txirq+0xe8>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
   3b348:	e0bffe17 	ldw	r2,-8(fp)
   3b34c:	10800017 	ldw	r2,0(r2)
   3b350:	10800204 	addi	r2,r2,8
   3b354:	10800037 	ldwio	r2,0(r2)
   3b358:	e0bfff15 	stw	r2,-4(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
   3b35c:	e0bfff17 	ldw	r2,-4(fp)
   3b360:	1082000c 	andi	r2,r2,2048
   3b364:	1000061e 	bne	r2,zero,3b380 <altera_avalon_uart_txirq+0xe8>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
   3b368:	e0bffe17 	ldw	r2,-8(fp)
   3b36c:	10c00117 	ldw	r3,4(r2)
   3b370:	00bfefc4 	movi	r2,-65
   3b374:	1886703a 	and	r3,r3,r2
   3b378:	e0bffe17 	ldw	r2,-8(fp)
   3b37c:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
   3b380:	e0bffe17 	ldw	r2,-8(fp)
   3b384:	10c00417 	ldw	r3,16(r2)
   3b388:	e0bffe17 	ldw	r2,-8(fp)
   3b38c:	10800517 	ldw	r2,20(r2)
   3b390:	1880061e 	bne	r3,r2,3b3ac <altera_avalon_uart_txirq+0x114>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
   3b394:	e0bffe17 	ldw	r2,-8(fp)
   3b398:	10c00117 	ldw	r3,4(r2)
   3b39c:	00beefc4 	movi	r2,-1089
   3b3a0:	1886703a 	and	r3,r3,r2
   3b3a4:	e0bffe17 	ldw	r2,-8(fp)
   3b3a8:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
   3b3ac:	e0bffe17 	ldw	r2,-8(fp)
   3b3b0:	10800017 	ldw	r2,0(r2)
   3b3b4:	10800304 	addi	r2,r2,12
   3b3b8:	e0fffe17 	ldw	r3,-8(fp)
   3b3bc:	18c00117 	ldw	r3,4(r3)
   3b3c0:	10c00035 	stwio	r3,0(r2)
}
   3b3c4:	e037883a 	mov	sp,fp
   3b3c8:	df000017 	ldw	fp,0(sp)
   3b3cc:	dec00104 	addi	sp,sp,4
   3b3d0:	f800283a 	ret

0003b3d4 <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
   3b3d4:	defffd04 	addi	sp,sp,-12
   3b3d8:	df000215 	stw	fp,8(sp)
   3b3dc:	df000204 	addi	fp,sp,8
   3b3e0:	e13ffe15 	stw	r4,-8(fp)
   3b3e4:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
   3b3e8:	00000506 	br	3b400 <altera_avalon_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
   3b3ec:	e0bfff17 	ldw	r2,-4(fp)
   3b3f0:	1090000c 	andi	r2,r2,16384
   3b3f4:	10000226 	beq	r2,zero,3b400 <altera_avalon_uart_close+0x2c>
      return -EWOULDBLOCK; 
   3b3f8:	00bffd44 	movi	r2,-11
   3b3fc:	00000606 	br	3b418 <altera_avalon_uart_close+0x44>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
   3b400:	e0bffe17 	ldw	r2,-8(fp)
   3b404:	10c00417 	ldw	r3,16(r2)
   3b408:	e0bffe17 	ldw	r2,-8(fp)
   3b40c:	10800517 	ldw	r2,20(r2)
   3b410:	18bff61e 	bne	r3,r2,3b3ec <altera_avalon_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
   3b414:	0005883a 	mov	r2,zero
}
   3b418:	e037883a 	mov	sp,fp
   3b41c:	df000017 	ldw	fp,0(sp)
   3b420:	dec00104 	addi	sp,sp,4
   3b424:	f800283a 	ret

0003b428 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   3b428:	defffe04 	addi	sp,sp,-8
   3b42c:	dfc00115 	stw	ra,4(sp)
   3b430:	df000015 	stw	fp,0(sp)
   3b434:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   3b438:	00800134 	movhi	r2,4
   3b43c:	1095d904 	addi	r2,r2,22372
   3b440:	10800017 	ldw	r2,0(r2)
   3b444:	10000526 	beq	r2,zero,3b45c <alt_get_errno+0x34>
   3b448:	00800134 	movhi	r2,4
   3b44c:	1095d904 	addi	r2,r2,22372
   3b450:	10800017 	ldw	r2,0(r2)
   3b454:	103ee83a 	callr	r2
   3b458:	00000206 	br	3b464 <alt_get_errno+0x3c>
   3b45c:	00800134 	movhi	r2,4
   3b460:	109ebe04 	addi	r2,r2,31480
}
   3b464:	e037883a 	mov	sp,fp
   3b468:	dfc00117 	ldw	ra,4(sp)
   3b46c:	df000017 	ldw	fp,0(sp)
   3b470:	dec00204 	addi	sp,sp,8
   3b474:	f800283a 	ret

0003b478 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
   3b478:	deffed04 	addi	sp,sp,-76
   3b47c:	dfc01215 	stw	ra,72(sp)
   3b480:	df001115 	stw	fp,68(sp)
   3b484:	df001104 	addi	fp,sp,68
   3b488:	e13ffc15 	stw	r4,-16(fp)
   3b48c:	e17ffd15 	stw	r5,-12(fp)
   3b490:	e1bffe15 	stw	r6,-8(fp)
   3b494:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u32         next;
  alt_u8          read_would_block = 0;
   3b498:	e03fef05 	stb	zero,-68(fp)
  int             count = 0;
   3b49c:	e03ff015 	stw	zero,-64(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
   3b4a0:	e0bfff17 	ldw	r2,-4(fp)
   3b4a4:	1090000c 	andi	r2,r2,16384
   3b4a8:	1005003a 	cmpeq	r2,r2,zero
   3b4ac:	10803fcc 	andi	r2,r2,255
   3b4b0:	e0bff115 	stw	r2,-60(fp)
  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */

  ALT_SEM_PEND (sp->read_lock, 0);
   3b4b4:	e0bffc17 	ldw	r2,-16(fp)
   3b4b8:	10800717 	ldw	r2,28(r2)
   3b4bc:	e0bff415 	stw	r2,-48(fp)
   3b4c0:	e03ff50d 	sth	zero,-44(fp)
 * converted into the functions return value.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (xSemaphoreHandle sem, alt_u16 timeout)
{
	return xSemaphoreTake(sem, timeout) ? 0 : -1;
   3b4c4:	e0bff50b 	ldhu	r2,-44(fp)
   3b4c8:	e13ff417 	ldw	r4,-48(fp)
   3b4cc:	000b883a 	mov	r5,zero
   3b4d0:	100d883a 	mov	r6,r2
   3b4d4:	000f883a 	mov	r7,zero
   3b4d8:	000ebd80 	call	ebd8 <xQueueGenericReceive>
   3b4dc:	0001883a 	nop
  /*
   * Calculate which slot in the circular buffer is the next one to read
   * data from.
   */

  next = (sp->rx_start + 1) & ALT_AVALON_UART_BUF_MSK;
   3b4e0:	e0bffc17 	ldw	r2,-16(fp)
   3b4e4:	10800217 	ldw	r2,8(r2)
   3b4e8:	10800044 	addi	r2,r2,1
   3b4ec:	10800fcc 	andi	r2,r2,63
   3b4f0:	e0bff215 	stw	r2,-56(fp)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
   3b4f4:	00001906 	br	3b55c <altera_avalon_uart_read+0xe4>
    {
      count++;
   3b4f8:	e0bff017 	ldw	r2,-64(fp)
   3b4fc:	10800044 	addi	r2,r2,1
   3b500:	e0bff015 	stw	r2,-64(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
   3b504:	e0bffc17 	ldw	r2,-16(fp)
   3b508:	10800217 	ldw	r2,8(r2)
   3b50c:	e0fffc17 	ldw	r3,-16(fp)
   3b510:	1885883a 	add	r2,r3,r2
   3b514:	10800904 	addi	r2,r2,36
   3b518:	10800003 	ldbu	r2,0(r2)
   3b51c:	1007883a 	mov	r3,r2
   3b520:	e0bffd17 	ldw	r2,-12(fp)
   3b524:	10c00005 	stb	r3,0(r2)
   3b528:	e0bffd17 	ldw	r2,-12(fp)
   3b52c:	10800044 	addi	r2,r2,1
   3b530:	e0bffd15 	stw	r2,-12(fp)
      
      sp->rx_start = (++sp->rx_start) & ALT_AVALON_UART_BUF_MSK;
   3b534:	e0bffc17 	ldw	r2,-16(fp)
   3b538:	10800217 	ldw	r2,8(r2)
   3b53c:	10c00044 	addi	r3,r2,1
   3b540:	e0bffc17 	ldw	r2,-16(fp)
   3b544:	10c00215 	stw	r3,8(r2)
   3b548:	e0bffc17 	ldw	r2,-16(fp)
   3b54c:	10800217 	ldw	r2,8(r2)
   3b550:	10c00fcc 	andi	r3,r2,63
   3b554:	e0bffc17 	ldw	r2,-16(fp)
   3b558:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
   3b55c:	e0fff017 	ldw	r3,-64(fp)
   3b560:	e0bffe17 	ldw	r2,-8(fp)
   3b564:	1880050e 	bge	r3,r2,3b57c <altera_avalon_uart_read+0x104>
   3b568:	e0bffc17 	ldw	r2,-16(fp)
   3b56c:	10c00217 	ldw	r3,8(r2)
   3b570:	e0bffc17 	ldw	r2,-16(fp)
   3b574:	10800317 	ldw	r2,12(r2)
   3b578:	18bfdf1e 	bne	r3,r2,3b4f8 <altera_avalon_uart_read+0x80>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
   3b57c:	e0bff017 	ldw	r2,-64(fp)
   3b580:	10002f1e 	bne	r2,zero,3b640 <altera_avalon_uart_read+0x1c8>
   3b584:	e0bffc17 	ldw	r2,-16(fp)
   3b588:	10c00217 	ldw	r3,8(r2)
   3b58c:	e0bffc17 	ldw	r2,-16(fp)
   3b590:	10800317 	ldw	r2,12(r2)
   3b594:	18802a1e 	bne	r3,r2,3b640 <altera_avalon_uart_read+0x1c8>
    {
      if (!block)
   3b598:	e0bff117 	ldw	r2,-60(fp)
   3b59c:	1000061e 	bne	r2,zero,3b5b8 <altera_avalon_uart_read+0x140>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
   3b5a0:	003b4280 	call	3b428 <alt_get_errno>
   3b5a4:	00c002c4 	movi	r3,11
   3b5a8:	10c00015 	stw	r3,0(r2)
        read_would_block = 1;
   3b5ac:	00800044 	movi	r2,1
   3b5b0:	e0bfef05 	stb	r2,-68(fp)
        break;
   3b5b4:	00002606 	br	3b650 <altera_avalon_uart_read+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   3b5b8:	0005303a 	rdctl	r2,status
   3b5bc:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   3b5c0:	e0fff617 	ldw	r3,-40(fp)
   3b5c4:	00bfff84 	movi	r2,-2
   3b5c8:	1884703a 	and	r2,r3,r2
   3b5cc:	1001703a 	wrctl	status,r2
  
  return context;
   3b5d0:	e0bff617 	ldw	r2,-40(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
   3b5d4:	e0bff315 	stw	r2,-52(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
   3b5d8:	e0bffc17 	ldw	r2,-16(fp)
   3b5dc:	10800117 	ldw	r2,4(r2)
   3b5e0:	10c02014 	ori	r3,r2,128
   3b5e4:	e0bffc17 	ldw	r2,-16(fp)
   3b5e8:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
   3b5ec:	e0bffc17 	ldw	r2,-16(fp)
   3b5f0:	10800017 	ldw	r2,0(r2)
   3b5f4:	10800304 	addi	r2,r2,12
   3b5f8:	e0fffc17 	ldw	r3,-16(fp)
   3b5fc:	18c00117 	ldw	r3,4(r3)
   3b600:	10c00035 	stwio	r3,0(r2)
   3b604:	e0bff317 	ldw	r2,-52(fp)
   3b608:	e0bff715 	stw	r2,-36(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   3b60c:	0005303a 	rdctl	r2,status
   3b610:	e0bff815 	stw	r2,-32(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   3b614:	e0fff817 	ldw	r3,-32(fp)
   3b618:	00bfff84 	movi	r2,-2
   3b61c:	1884703a 	and	r2,r3,r2
   3b620:	e0bff815 	stw	r2,-32(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   3b624:	e0bff717 	ldw	r2,-36(fp)
   3b628:	1080004c 	andi	r2,r2,1
   3b62c:	e0fff817 	ldw	r3,-32(fp)
   3b630:	1884b03a 	or	r2,r3,r2
   3b634:	e0bff815 	stw	r2,-32(fp)
  
  NIOS2_WRITE_STATUS (status);
   3b638:	e0bff817 	ldw	r2,-32(fp)
   3b63c:	1001703a 	wrctl	status,r2
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
   3b640:	e0bff017 	ldw	r2,-64(fp)
   3b644:	1000021e 	bne	r2,zero,3b650 <altera_avalon_uart_read+0x1d8>
   3b648:	e0bffe17 	ldw	r2,-8(fp)
   3b64c:	103fc31e 	bne	r2,zero,3b55c <altera_avalon_uart_read+0xe4>
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
   3b650:	e0bffc17 	ldw	r2,-16(fp)
   3b654:	10800717 	ldw	r2,28(r2)
   3b658:	1009883a 	mov	r4,r2
   3b65c:	000b883a 	mov	r5,zero
   3b660:	000d883a 	mov	r6,zero
   3b664:	000f883a 	mov	r7,zero
   3b668:	000e95c0 	call	e95c <xQueueGenericSend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   3b66c:	0005303a 	rdctl	r2,status
   3b670:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   3b674:	e0fff917 	ldw	r3,-28(fp)
   3b678:	00bfff84 	movi	r2,-2
   3b67c:	1884703a 	and	r2,r3,r2
   3b680:	1001703a 	wrctl	status,r2
  
  return context;
   3b684:	e0bff917 	ldw	r2,-28(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
   3b688:	e0bff315 	stw	r2,-52(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
   3b68c:	e0bffc17 	ldw	r2,-16(fp)
   3b690:	10800117 	ldw	r2,4(r2)
   3b694:	10c02014 	ori	r3,r2,128
   3b698:	e0bffc17 	ldw	r2,-16(fp)
   3b69c:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
   3b6a0:	e0bffc17 	ldw	r2,-16(fp)
   3b6a4:	10800017 	ldw	r2,0(r2)
   3b6a8:	10800304 	addi	r2,r2,12
   3b6ac:	e0fffc17 	ldw	r3,-16(fp)
   3b6b0:	18c00117 	ldw	r3,4(r3)
   3b6b4:	10c00035 	stwio	r3,0(r2)
   3b6b8:	e0bff317 	ldw	r2,-52(fp)
   3b6bc:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   3b6c0:	0005303a 	rdctl	r2,status
   3b6c4:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   3b6c8:	e0fffb17 	ldw	r3,-20(fp)
   3b6cc:	00bfff84 	movi	r2,-2
   3b6d0:	1884703a 	and	r2,r3,r2
   3b6d4:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   3b6d8:	e0bffa17 	ldw	r2,-24(fp)
   3b6dc:	1080004c 	andi	r2,r2,1
   3b6e0:	e0fffb17 	ldw	r3,-20(fp)
   3b6e4:	1884b03a 	or	r2,r3,r2
   3b6e8:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
   3b6ec:	e0bffb17 	ldw	r2,-20(fp)
   3b6f0:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
   3b6f4:	e0bfef03 	ldbu	r2,-68(fp)
   3b6f8:	10000226 	beq	r2,zero,3b704 <altera_avalon_uart_read+0x28c>
    return -EWOULDBLOCK;
   3b6fc:	00bffd44 	movi	r2,-11
   3b700:	00000106 	br	3b708 <altera_avalon_uart_read+0x290>
  }
  else {
    return count;
   3b704:	e0bff017 	ldw	r2,-64(fp)
  }
}
   3b708:	e037883a 	mov	sp,fp
   3b70c:	dfc00117 	ldw	ra,4(sp)
   3b710:	df000017 	ldw	fp,0(sp)
   3b714:	dec00204 	addi	sp,sp,8
   3b718:	f800283a 	ret

0003b71c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   3b71c:	defffe04 	addi	sp,sp,-8
   3b720:	dfc00115 	stw	ra,4(sp)
   3b724:	df000015 	stw	fp,0(sp)
   3b728:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   3b72c:	00800134 	movhi	r2,4
   3b730:	1095d904 	addi	r2,r2,22372
   3b734:	10800017 	ldw	r2,0(r2)
   3b738:	10000526 	beq	r2,zero,3b750 <alt_get_errno+0x34>
   3b73c:	00800134 	movhi	r2,4
   3b740:	1095d904 	addi	r2,r2,22372
   3b744:	10800017 	ldw	r2,0(r2)
   3b748:	103ee83a 	callr	r2
   3b74c:	00000206 	br	3b758 <alt_get_errno+0x3c>
   3b750:	00800134 	movhi	r2,4
   3b754:	109ebe04 	addi	r2,r2,31480
}
   3b758:	e037883a 	mov	sp,fp
   3b75c:	dfc00117 	ldw	ra,4(sp)
   3b760:	df000017 	ldw	fp,0(sp)
   3b764:	dec00204 	addi	sp,sp,8
   3b768:	f800283a 	ret

0003b76c <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
   3b76c:	deffee04 	addi	sp,sp,-72
   3b770:	dfc01115 	stw	ra,68(sp)
   3b774:	df001015 	stw	fp,64(sp)
   3b778:	df001004 	addi	fp,sp,64
   3b77c:	e13ffc15 	stw	r4,-16(fp)
   3b780:	e17ffd15 	stw	r5,-12(fp)
   3b784:	e1bffe15 	stw	r6,-8(fp)
   3b788:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
   3b78c:	e0bffe17 	ldw	r2,-8(fp)
   3b790:	e0bff015 	stw	r2,-64(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
   3b794:	e0bfff17 	ldw	r2,-4(fp)
   3b798:	1090000c 	andi	r2,r2,16384
   3b79c:	e0bff115 	stw	r2,-60(fp)
  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
   3b7a0:	e0bffc17 	ldw	r2,-16(fp)
   3b7a4:	10800817 	ldw	r2,32(r2)
   3b7a8:	e0bff415 	stw	r2,-48(fp)
   3b7ac:	e03ff50d 	sth	zero,-44(fp)
   3b7b0:	e0bff50b 	ldhu	r2,-44(fp)
   3b7b4:	e13ff417 	ldw	r4,-48(fp)
   3b7b8:	000b883a 	mov	r5,zero
   3b7bc:	100d883a 	mov	r6,r2
   3b7c0:	000f883a 	mov	r7,zero
   3b7c4:	000ebd80 	call	ebd8 <xQueueGenericReceive>
   3b7c8:	10004726 	beq	r2,zero,3b8e8 <altera_avalon_uart_write+0x17c>
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
   3b7cc:	00004606 	br	3b8e8 <altera_avalon_uart_write+0x17c>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
   3b7d0:	e0bffc17 	ldw	r2,-16(fp)
   3b7d4:	10800517 	ldw	r2,20(r2)
   3b7d8:	10800044 	addi	r2,r2,1
   3b7dc:	10800fcc 	andi	r2,r2,63
   3b7e0:	e0bff215 	stw	r2,-56(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
   3b7e4:	e0bffc17 	ldw	r2,-16(fp)
   3b7e8:	10c00417 	ldw	r3,16(r2)
   3b7ec:	e0bff217 	ldw	r2,-56(fp)
   3b7f0:	18802c1e 	bne	r3,r2,3b8a4 <altera_avalon_uart_write+0x138>
    {
      if (no_block)
   3b7f4:	e0bff117 	ldw	r2,-60(fp)
   3b7f8:	10000426 	beq	r2,zero,3b80c <altera_avalon_uart_write+0xa0>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
   3b7fc:	003b71c0 	call	3b71c <alt_get_errno>
   3b800:	00c002c4 	movi	r3,11
   3b804:	10c00015 	stw	r3,0(r2)
        break;
   3b808:	00003906 	br	3b8f0 <altera_avalon_uart_write+0x184>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   3b80c:	0005303a 	rdctl	r2,status
   3b810:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   3b814:	e0fff617 	ldw	r3,-40(fp)
   3b818:	00bfff84 	movi	r2,-2
   3b81c:	1884703a 	and	r2,r3,r2
   3b820:	1001703a 	wrctl	status,r2
  
  return context;
   3b824:	e0bff617 	ldw	r2,-40(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
   3b828:	e0bff315 	stw	r2,-52(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
   3b82c:	e0bffc17 	ldw	r2,-16(fp)
   3b830:	10800117 	ldw	r2,4(r2)
   3b834:	10c11014 	ori	r3,r2,1088
   3b838:	e0bffc17 	ldw	r2,-16(fp)
   3b83c:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
   3b840:	e0bffc17 	ldw	r2,-16(fp)
   3b844:	10800017 	ldw	r2,0(r2)
   3b848:	10800304 	addi	r2,r2,12
   3b84c:	e0fffc17 	ldw	r3,-16(fp)
   3b850:	18c00117 	ldw	r3,4(r3)
   3b854:	10c00035 	stwio	r3,0(r2)
   3b858:	e0bff317 	ldw	r2,-52(fp)
   3b85c:	e0bff715 	stw	r2,-36(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   3b860:	0005303a 	rdctl	r2,status
   3b864:	e0bff815 	stw	r2,-32(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   3b868:	e0fff817 	ldw	r3,-32(fp)
   3b86c:	00bfff84 	movi	r2,-2
   3b870:	1884703a 	and	r2,r3,r2
   3b874:	e0bff815 	stw	r2,-32(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   3b878:	e0bff717 	ldw	r2,-36(fp)
   3b87c:	1080004c 	andi	r2,r2,1
   3b880:	e0fff817 	ldw	r3,-32(fp)
   3b884:	1884b03a 	or	r2,r3,r2
   3b888:	e0bff815 	stw	r2,-32(fp)
  
  NIOS2_WRITE_STATUS (status);
   3b88c:	e0bff817 	ldw	r2,-32(fp)
   3b890:	1001703a 	wrctl	status,r2
          ALT_FLAG_PEND (sp->events, 
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
   3b894:	e0bffc17 	ldw	r2,-16(fp)
   3b898:	10c00417 	ldw	r3,16(r2)
   3b89c:	e0bff217 	ldw	r2,-56(fp)
   3b8a0:	18bffc26 	beq	r3,r2,3b894 <altera_avalon_uart_write+0x128>
      }
    }

    count--;
   3b8a4:	e0bff017 	ldw	r2,-64(fp)
   3b8a8:	10bfffc4 	addi	r2,r2,-1
   3b8ac:	e0bff015 	stw	r2,-64(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
   3b8b0:	e0bffc17 	ldw	r2,-16(fp)
   3b8b4:	10800517 	ldw	r2,20(r2)
   3b8b8:	e0fffd17 	ldw	r3,-12(fp)
   3b8bc:	18c00003 	ldbu	r3,0(r3)
   3b8c0:	e13ffc17 	ldw	r4,-16(fp)
   3b8c4:	2085883a 	add	r2,r4,r2
   3b8c8:	10801904 	addi	r2,r2,100
   3b8cc:	10c00005 	stb	r3,0(r2)
   3b8d0:	e0bffd17 	ldw	r2,-12(fp)
   3b8d4:	10800044 	addi	r2,r2,1
   3b8d8:	e0bffd15 	stw	r2,-12(fp)
    sp->tx_end = next;
   3b8dc:	e0bffc17 	ldw	r2,-16(fp)
   3b8e0:	e0fff217 	ldw	r3,-56(fp)
   3b8e4:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
   3b8e8:	e0bff017 	ldw	r2,-64(fp)
   3b8ec:	103fb81e 	bne	r2,zero,3b7d0 <altera_avalon_uart_write+0x64>
  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
   3b8f0:	e0bffc17 	ldw	r2,-16(fp)
   3b8f4:	10800817 	ldw	r2,32(r2)
   3b8f8:	1009883a 	mov	r4,r2
   3b8fc:	000b883a 	mov	r5,zero
   3b900:	000d883a 	mov	r6,zero
   3b904:	000f883a 	mov	r7,zero
   3b908:	000e95c0 	call	e95c <xQueueGenericSend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   3b90c:	0005303a 	rdctl	r2,status
   3b910:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   3b914:	e0fff917 	ldw	r3,-28(fp)
   3b918:	00bfff84 	movi	r2,-2
   3b91c:	1884703a 	and	r2,r3,r2
   3b920:	1001703a 	wrctl	status,r2
  
  return context;
   3b924:	e0bff917 	ldw	r2,-28(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
   3b928:	e0bff315 	stw	r2,-52(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
   3b92c:	e0bffc17 	ldw	r2,-16(fp)
   3b930:	10800117 	ldw	r2,4(r2)
   3b934:	10c11014 	ori	r3,r2,1088
   3b938:	e0bffc17 	ldw	r2,-16(fp)
   3b93c:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
   3b940:	e0bffc17 	ldw	r2,-16(fp)
   3b944:	10800017 	ldw	r2,0(r2)
   3b948:	10800304 	addi	r2,r2,12
   3b94c:	e0fffc17 	ldw	r3,-16(fp)
   3b950:	18c00117 	ldw	r3,4(r3)
   3b954:	10c00035 	stwio	r3,0(r2)
   3b958:	e0bff317 	ldw	r2,-52(fp)
   3b95c:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   3b960:	0005303a 	rdctl	r2,status
   3b964:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   3b968:	e0fffb17 	ldw	r3,-20(fp)
   3b96c:	00bfff84 	movi	r2,-2
   3b970:	1884703a 	and	r2,r3,r2
   3b974:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   3b978:	e0bffa17 	ldw	r2,-24(fp)
   3b97c:	1080004c 	andi	r2,r2,1
   3b980:	e0fffb17 	ldw	r3,-20(fp)
   3b984:	1884b03a 	or	r2,r3,r2
   3b988:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
   3b98c:	e0bffb17 	ldw	r2,-20(fp)
   3b990:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
   3b994:	e0fffe17 	ldw	r3,-8(fp)
   3b998:	e0bff017 	ldw	r2,-64(fp)
   3b99c:	1885c83a 	sub	r2,r3,r2
}
   3b9a0:	e037883a 	mov	sp,fp
   3b9a4:	dfc00117 	ldw	ra,4(sp)
   3b9a8:	df000017 	ldw	fp,0(sp)
   3b9ac:	dec00204 	addi	sp,sp,8
   3b9b0:	f800283a 	ret

0003b9b4 <VIC_0_VECTOR_TABLE>:

    .section .text, "xa"
    .align 2
    .globl VIC_0_VECTOR_TABLE
VIC_0_VECTOR_TABLE:
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3b9b4:	0030e03a 	nextpc	et
   3b9b8:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3b9c4:	0030e03a 	nextpc	et
   3b9c8:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3b9d4:	0030e03a 	nextpc	et
   3b9d8:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3b9e4:	0030e03a 	nextpc	et
   3b9e8:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3b9f4:	0030e03a 	nextpc	et
   3b9f8:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3ba04:	0030e03a 	nextpc	et
   3ba08:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3ba14:	0030e03a 	nextpc	et
   3ba18:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3ba24:	0030e03a 	nextpc	et
   3ba28:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3ba34:	0030e03a 	nextpc	et
   3ba38:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3ba44:	0030e03a 	nextpc	et
   3ba48:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3ba54:	0030e03a 	nextpc	et
   3ba58:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3ba64:	0030e03a 	nextpc	et
   3ba68:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3ba74:	0030e03a 	nextpc	et
   3ba78:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3ba84:	0030e03a 	nextpc	et
   3ba88:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3ba94:	0030e03a 	nextpc	et
   3ba98:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3baa4:	0030e03a 	nextpc	et
   3baa8:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3bab4:	0030e03a 	nextpc	et
   3bab8:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3bac4:	0030e03a 	nextpc	et
   3bac8:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3bad4:	0030e03a 	nextpc	et
   3bad8:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3bae4:	0030e03a 	nextpc	et
   3bae8:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3baf4:	0030e03a 	nextpc	et
   3baf8:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3bb04:	0030e03a 	nextpc	et
   3bb08:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3bb14:	0030e03a 	nextpc	et
   3bb18:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3bb24:	0030e03a 	nextpc	et
   3bb28:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3bb34:	0030e03a 	nextpc	et
   3bb38:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3bb44:	0030e03a 	nextpc	et
   3bb48:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3bb54:	0030e03a 	nextpc	et
   3bb58:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3bb64:	0030e03a 	nextpc	et
   3bb68:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3bb74:	0030e03a 	nextpc	et
   3bb78:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3bb84:	0030e03a 	nextpc	et
   3bb88:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3bb94:	0030e03a 	nextpc	et
   3bb98:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...
     ALT_SHADOW_NON_PREEMPTIVE_INTERRUPT    16
   3bba4:	0030e03a 	nextpc	et
   3bba8:	003bbb41 	jmpi	3bbb4 <alt_shadow_non_preemptive_interrupt>
	...

0003bbb4 <alt_shadow_non_preemptive_interrupt>:
    .section ALTERA_VIC_DRIVER_LINKER_SECTION
    .set nobreak
    .globl alt_shadow_non_preemptive_interrupt
alt_shadow_non_preemptive_interrupt:

    ldw r16, 4(et)               /* load ISR pointer */
   3bbb4:	c4000117 	ldw	r16,4(et)

     /*
      * Get SP from previous register set.
      */

    rdprs sp, sp, 0
   3bbb8:	dec00038 	rdprs	sp,sp,0
  /*
   * Notify the operating system that we are at interrupt level.
   */
    ALT_OS_INT_ENTER_ASM

    ldw r4, 8(et)               /* load isr_context */
   3bbbc:	c1000217 	ldw	r4,8(et)
    callr r16                   /* call ISR */
   3bbc0:	803ee83a 	callr	r16
    /*
     * Notify the operating system that interrupt processing is complete.
     */
    ALT_OS_INT_EXIT_ASM

    addi ea, ea, -4             /* instruction that caused exception */
   3bbc4:	ef7fff04 	addi	ea,ea,-4
    eret
   3bbc8:	ef80083a 	eret

0003bbcc <alt_vic_irq_init>:
  * @API Type:              Internal
  * @param pdev             pointer of type alt_vic_dev, main Device Structure.
  * @return                 None
  */
void alt_vic_irq_init (alt_vic_dev* pdev)
{
   3bbcc:	defffd04 	addi	sp,sp,-12
   3bbd0:	df000215 	stw	fp,8(sp)
   3bbd4:	df000204 	addi	fp,sp,8
   3bbd8:	e13fff15 	stw	r4,-4(fp)
    alt_u32 i;
    static const int VEC_SIZE_ARRAY[]={4, 8, 16, 32, 64, 128, 256, 512};

    /* Stores the VIC instance to list */
    alt_vic_dev_list[pdev->intr_controller_id] = pdev;
   3bbdc:	e0bfff17 	ldw	r2,-4(fp)
   3bbe0:	10800117 	ldw	r2,4(r2)
   3bbe4:	1085883a 	add	r2,r2,r2
   3bbe8:	1087883a 	add	r3,r2,r2
   3bbec:	d0a94804 	addi	r2,gp,-23264
   3bbf0:	1885883a 	add	r2,r3,r2
   3bbf4:	e0ffff17 	ldw	r3,-4(fp)
   3bbf8:	10c00015 	stw	r3,0(r2)

    /* Disables all interrupts */
    IOWR_ALTERA_VIC_INT_ENABLE_CLR(pdev->base, 0xFFFFFFFF);
   3bbfc:	e0bfff17 	ldw	r2,-4(fp)
   3bc00:	10800017 	ldw	r2,0(r2)
   3bc04:	10802204 	addi	r2,r2,136
   3bc08:	00ffffc4 	movi	r3,-1
   3bc0c:	10c00035 	stwio	r3,0(r2)

    /* Initialize INT_CONFIG for all interrupts in this VIC */
    for(i = 0; i < pdev->num_of_intr_ports; i++)
   3bc10:	e03ffe15 	stw	zero,-8(fp)
   3bc14:	00001106 	br	3bc5c <alt_vic_irq_init+0x90>
    {
        IOWR_ALTERA_VIC_INT_CONFIG(pdev->base, i, pdev->int_config[i]);
   3bc18:	e0bfff17 	ldw	r2,-4(fp)
   3bc1c:	10c00017 	ldw	r3,0(r2)
   3bc20:	e0bffe17 	ldw	r2,-8(fp)
   3bc24:	1085883a 	add	r2,r2,r2
   3bc28:	1085883a 	add	r2,r2,r2
   3bc2c:	1887883a 	add	r3,r3,r2
   3bc30:	e13fff17 	ldw	r4,-4(fp)
   3bc34:	e0bffe17 	ldw	r2,-8(fp)
   3bc38:	108001c4 	addi	r2,r2,7
   3bc3c:	1085883a 	add	r2,r2,r2
   3bc40:	1085883a 	add	r2,r2,r2
   3bc44:	2085883a 	add	r2,r4,r2
   3bc48:	10800017 	ldw	r2,0(r2)
   3bc4c:	18800035 	stwio	r2,0(r3)

    /* Disables all interrupts */
    IOWR_ALTERA_VIC_INT_ENABLE_CLR(pdev->base, 0xFFFFFFFF);

    /* Initialize INT_CONFIG for all interrupts in this VIC */
    for(i = 0; i < pdev->num_of_intr_ports; i++)
   3bc50:	e0bffe17 	ldw	r2,-8(fp)
   3bc54:	10800044 	addi	r2,r2,1
   3bc58:	e0bffe15 	stw	r2,-8(fp)
   3bc5c:	e0bfff17 	ldw	r2,-4(fp)
   3bc60:	10800217 	ldw	r2,8(r2)
   3bc64:	e0fffe17 	ldw	r3,-8(fp)
   3bc68:	18bfeb36 	bltu	r3,r2,3bc18 <alt_vic_irq_init+0x4c>
    {
        IOWR_ALTERA_VIC_INT_CONFIG(pdev->base, i, pdev->int_config[i]);
    }

    /* Set vector size and disable/enable daisy-chained input */
    for(i = 0; i < sizeof(VEC_SIZE_ARRAY)/sizeof(VEC_SIZE_ARRAY[0]); i++)
   3bc6c:	e03ffe15 	stw	zero,-8(fp)
   3bc70:	00001806 	br	3bcd4 <alt_vic_irq_init+0x108>
    {
        if(VEC_SIZE_ARRAY[i] == pdev->vec_size)
   3bc74:	00c00134 	movhi	r3,4
   3bc78:	18cca104 	addi	r3,r3,12932
   3bc7c:	e0bffe17 	ldw	r2,-8(fp)
   3bc80:	1085883a 	add	r2,r2,r2
   3bc84:	1085883a 	add	r2,r2,r2
   3bc88:	1885883a 	add	r2,r3,r2
   3bc8c:	10800017 	ldw	r2,0(r2)
   3bc90:	1007883a 	mov	r3,r2
   3bc94:	e0bfff17 	ldw	r2,-4(fp)
   3bc98:	10800517 	ldw	r2,20(r2)
   3bc9c:	18800a1e 	bne	r3,r2,3bcc8 <alt_vic_irq_init+0xfc>
        {
            IOWR_ALTERA_VIC_CONFIG(pdev->base,
   3bca0:	e0bfff17 	ldw	r2,-4(fp)
   3bca4:	10800017 	ldw	r2,0(r2)
   3bca8:	10802804 	addi	r2,r2,160
   3bcac:	e0ffff17 	ldw	r3,-4(fp)
   3bcb0:	18c00417 	ldw	r3,16(r3)
   3bcb4:	180890fa 	slli	r4,r3,3
   3bcb8:	e0fffe17 	ldw	r3,-8(fp)
   3bcbc:	20c6b03a 	or	r3,r4,r3
   3bcc0:	10c00035 	stwio	r3,0(r2)
                (i | (pdev->daisy_chain_present << ALTERA_VIC_CONFIG_DC_OFST)));
            break;
   3bcc4:	00000606 	br	3bce0 <alt_vic_irq_init+0x114>
    {
        IOWR_ALTERA_VIC_INT_CONFIG(pdev->base, i, pdev->int_config[i]);
    }

    /* Set vector size and disable/enable daisy-chained input */
    for(i = 0; i < sizeof(VEC_SIZE_ARRAY)/sizeof(VEC_SIZE_ARRAY[0]); i++)
   3bcc8:	e0bffe17 	ldw	r2,-8(fp)
   3bccc:	10800044 	addi	r2,r2,1
   3bcd0:	e0bffe15 	stw	r2,-8(fp)
   3bcd4:	e0bffe17 	ldw	r2,-8(fp)
   3bcd8:	10800230 	cmpltui	r2,r2,8
   3bcdc:	103fe51e 	bne	r2,zero,3bc74 <alt_vic_irq_init+0xa8>
            break;
        }
    }

    /* Set vector table base address */
    IOWR_ALTERA_VIC_VEC_TBL_BASE(pdev->base,((alt_u32)pdev->vec_addr));
   3bce0:	e0bfff17 	ldw	r2,-4(fp)
   3bce4:	10800017 	ldw	r2,0(r2)
   3bce8:	10802a04 	addi	r2,r2,168
   3bcec:	e0ffff17 	ldw	r3,-4(fp)
   3bcf0:	18c00617 	ldw	r3,24(r3)
   3bcf4:	10c00035 	stwio	r3,0(r2)
}
   3bcf8:	e037883a 	mov	sp,fp
   3bcfc:	df000017 	ldw	fp,0(sp)
   3bd00:	dec00104 	addi	sp,sp,4
   3bd04:	f800283a 	ret

0003bd08 <alt_ic_isr_register>:
int alt_ic_isr_register(alt_u32 ic_id,
                        alt_u32 irq,
                        alt_isr_func isr,
                        void *isr_context,
                        void* flags)
{
   3bd08:	defff504 	addi	sp,sp,-44
   3bd0c:	df000a15 	stw	fp,40(sp)
   3bd10:	df000a04 	addi	fp,sp,40
   3bd14:	e13ffc15 	stw	r4,-16(fp)
   3bd18:	e17ffd15 	stw	r5,-12(fp)
   3bd1c:	e1bffe15 	stw	r6,-8(fp)
   3bd20:	e1ffff15 	stw	r7,-4(fp)
    alt_vic_dev *pdev;
    alt_u32 *offset;
    alt_irq_context status;

    if(ic_id >= ALT_NUM_EXTERNAL_INTERRUPT_CONTROLLERS)
   3bd24:	e0bffc17 	ldw	r2,-16(fp)
   3bd28:	10000226 	beq	r2,zero,3bd34 <alt_ic_isr_register+0x2c>
        return -1;
   3bd2c:	00bfffc4 	movi	r2,-1
   3bd30:	00004706 	br	3be50 <alt_ic_isr_register+0x148>

    /* Get VIC handle */
    pdev = alt_vic_dev_list[ic_id];
   3bd34:	00c00134 	movhi	r3,4
   3bd38:	18df0404 	addi	r3,r3,31760
   3bd3c:	e0bffc17 	ldw	r2,-16(fp)
   3bd40:	1085883a 	add	r2,r2,r2
   3bd44:	1085883a 	add	r2,r2,r2
   3bd48:	1885883a 	add	r2,r3,r2
   3bd4c:	10800017 	ldw	r2,0(r2)
   3bd50:	e0bff615 	stw	r2,-40(fp)

    if(irq < pdev->num_of_intr_ports)
   3bd54:	e0bff617 	ldw	r2,-40(fp)
   3bd58:	10800217 	ldw	r2,8(r2)
   3bd5c:	e0fffd17 	ldw	r3,-12(fp)
   3bd60:	18803a2e 	bgeu	r3,r2,3be4c <alt_ic_isr_register+0x144>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   3bd64:	0005303a 	rdctl	r2,status
   3bd68:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   3bd6c:	e0fff917 	ldw	r3,-28(fp)
   3bd70:	00bfff84 	movi	r2,-2
   3bd74:	1884703a 	and	r2,r3,r2
   3bd78:	1001703a 	wrctl	status,r2
  
  return context;
   3bd7c:	e0bff917 	ldw	r2,-28(fp)
    {
        /* Disable all interrupts */
        status = alt_irq_disable_all ();
   3bd80:	e0bff715 	stw	r2,-36(fp)

        /* Get table offset */
        offset = pdev->vec_addr + (irq * pdev->vec_size);
   3bd84:	e0bff617 	ldw	r2,-40(fp)
   3bd88:	10c00617 	ldw	r3,24(r2)
   3bd8c:	e0bff617 	ldw	r2,-40(fp)
   3bd90:	11000517 	ldw	r4,20(r2)
   3bd94:	e0bffd17 	ldw	r2,-12(fp)
   3bd98:	2085383a 	mul	r2,r4,r2
   3bd9c:	1885883a 	add	r2,r3,r2
   3bda0:	e0bff815 	stw	r2,-32(fp)

        /* Write ISR and ISR context to vector table */
        ALT_VECTOR_TABLE_WRITE(offset+2, isr);
   3bda4:	e0bff817 	ldw	r2,-32(fp)
   3bda8:	10800204 	addi	r2,r2,8
   3bdac:	e0fffe17 	ldw	r3,-8(fp)
   3bdb0:	10c00015 	stw	r3,0(r2)
        ALT_VECTOR_TABLE_WRITE(offset+3, isr_context);
   3bdb4:	e0bff817 	ldw	r2,-32(fp)
   3bdb8:	10800304 	addi	r2,r2,12
   3bdbc:	e0ffff17 	ldw	r3,-4(fp)
   3bdc0:	10c00015 	stw	r3,0(r2)

        if(isr)
   3bdc4:	e0bffe17 	ldw	r2,-8(fp)
   3bdc8:	10000826 	beq	r2,zero,3bdec <alt_ic_isr_register+0xe4>
        {
            /* Enable this IRQ on the VIC */
            IOWR_ALTERA_VIC_INT_ENABLE_SET(pdev->base, 1 << irq);
   3bdcc:	e0bff617 	ldw	r2,-40(fp)
   3bdd0:	10800017 	ldw	r2,0(r2)
   3bdd4:	10802104 	addi	r2,r2,132
   3bdd8:	e0fffd17 	ldw	r3,-12(fp)
   3bddc:	01000044 	movi	r4,1
   3bde0:	20c6983a 	sll	r3,r4,r3
   3bde4:	10c00035 	stwio	r3,0(r2)
   3bde8:	00000706 	br	3be08 <alt_ic_isr_register+0x100>
        }
        else
        {
            /* Disable this IRQ on the VIC */
            IOWR_ALTERA_VIC_INT_ENABLE_CLR(pdev->base, 1 << irq);
   3bdec:	e0bff617 	ldw	r2,-40(fp)
   3bdf0:	10800017 	ldw	r2,0(r2)
   3bdf4:	10802204 	addi	r2,r2,136
   3bdf8:	e0fffd17 	ldw	r3,-12(fp)
   3bdfc:	01000044 	movi	r4,1
   3be00:	20c6983a 	sll	r3,r4,r3
   3be04:	10c00035 	stwio	r3,0(r2)
   3be08:	e0bff717 	ldw	r2,-36(fp)
   3be0c:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   3be10:	0005303a 	rdctl	r2,status
   3be14:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   3be18:	e0fffb17 	ldw	r3,-20(fp)
   3be1c:	00bfff84 	movi	r2,-2
   3be20:	1884703a 	and	r2,r3,r2
   3be24:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   3be28:	e0bffa17 	ldw	r2,-24(fp)
   3be2c:	1080004c 	andi	r2,r2,1
   3be30:	e0fffb17 	ldw	r3,-20(fp)
   3be34:	1884b03a 	or	r2,r3,r2
   3be38:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
   3be3c:	e0bffb17 	ldw	r2,-20(fp)
   3be40:	1001703a 	wrctl	status,r2
        }

        /* Re-enable all interrupts */
        alt_irq_enable_all(status);

        return 0;
   3be44:	0005883a 	mov	r2,zero
   3be48:	00000106 	br	3be50 <alt_ic_isr_register+0x148>
    }

    return -1;
   3be4c:	00bfffc4 	movi	r2,-1
}
   3be50:	e037883a 	mov	sp,fp
   3be54:	df000017 	ldw	fp,0(sp)
   3be58:	dec00104 	addi	sp,sp,4
   3be5c:	f800283a 	ret

0003be60 <__env_lock>:
xSemaphoreHandle alt_envsem;

/* __env_lock needs to provide recursive mutex locking */

void __env_lock ( struct _reent *_r )
{
   3be60:	defffd04 	addi	sp,sp,-12
   3be64:	dfc00215 	stw	ra,8(sp)
   3be68:	df000115 	stw	fp,4(sp)
   3be6c:	df000104 	addi	fp,sp,4
   3be70:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
   3be74:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   3be78:	1000041e 	bne	r2,zero,3be8c <__env_lock+0x2c>
		return;
   3be7c:	00000b06 	br	3beac <__env_lock+0x4c>

	// wait for the mutex to be released
	while (xSemaphoreTakeRecursive(alt_envsem, 10) != pdTRUE)
		vTaskDelay(1);
   3be80:	01000044 	movi	r4,1
   3be84:	000f8c00 	call	f8c0 <vTaskDelay>
   3be88:	00000106 	br	3be90 <__env_lock+0x30>
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
		return;

	// wait for the mutex to be released
	while (xSemaphoreTakeRecursive(alt_envsem, 10) != pdTRUE)
   3be8c:	0001883a 	nop
   3be90:	d0a94917 	ldw	r2,-23260(gp)
   3be94:	1009883a 	mov	r4,r2
   3be98:	01400284 	movi	r5,10
   3be9c:	000e8640 	call	e864 <xQueueTakeMutexRecursive>
   3bea0:	10800058 	cmpnei	r2,r2,1
   3bea4:	103ff61e 	bne	r2,zero,3be80 <__env_lock+0x20>
		vTaskDelay(1);

#endif /* OS_THREAD_SAFE_NEWLIB */
	return;
   3bea8:	0001883a 	nop
}
   3beac:	e037883a 	mov	sp,fp
   3beb0:	dfc00117 	ldw	ra,4(sp)
   3beb4:	df000017 	ldw	fp,0(sp)
   3beb8:	dec00204 	addi	sp,sp,8
   3bebc:	f800283a 	ret

0003bec0 <__env_unlock>:

/* __env_unlock needs to provide recursive mutex unlocking */

void __env_unlock ( struct _reent *_r )
{
   3bec0:	defffd04 	addi	sp,sp,-12
   3bec4:	dfc00215 	stw	ra,8(sp)
   3bec8:	df000115 	stw	fp,4(sp)
   3becc:	df000104 	addi	fp,sp,4
   3bed0:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
   3bed4:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   3bed8:	10000426 	beq	r2,zero,3beec <__env_unlock+0x2c>
		return;
	  
	xSemaphoreGiveRecursive(alt_envsem);
   3bedc:	d0a94917 	ldw	r2,-23260(gp)
   3bee0:	1009883a 	mov	r4,r2
   3bee4:	000e7dc0 	call	e7dc <xQueueGiveMutexRecursive>
   3bee8:	00000106 	br	3bef0 <__env_unlock+0x30>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
		return;
   3beec:	0001883a 	nop
	  
	xSemaphoreGiveRecursive(alt_envsem);
#endif /* OS_THREAD_SAFE_NEWLIB */
}
   3bef0:	e037883a 	mov	sp,fp
   3bef4:	dfc00117 	ldw	ra,4(sp)
   3bef8:	df000017 	ldw	fp,0(sp)
   3befc:	dec00204 	addi	sp,sp,8
   3bf00:	f800283a 	ret

0003bf04 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
   3bf04:	defffe04 	addi	sp,sp,-8
   3bf08:	df000115 	stw	fp,4(sp)
   3bf0c:	df000104 	addi	fp,sp,4
   3bf10:	e13fff15 	stw	r4,-4(fp)
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
   3bf14:	e0bfff17 	ldw	r2,-4(fp)
   3bf18:	10c00204 	addi	r3,r2,8
   3bf1c:	e0bfff17 	ldw	r2,-4(fp)
   3bf20:	10c00115 	stw	r3,4(r2)

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
   3bf24:	e0bfff17 	ldw	r2,-4(fp)
   3bf28:	00ffffc4 	movi	r3,-1
   3bf2c:	10c00215 	stw	r3,8(r2)

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
   3bf30:	e0bfff17 	ldw	r2,-4(fp)
   3bf34:	10c00204 	addi	r3,r2,8
   3bf38:	e0bfff17 	ldw	r2,-4(fp)
   3bf3c:	10c00315 	stw	r3,12(r2)
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
   3bf40:	e0bfff17 	ldw	r2,-4(fp)
   3bf44:	10c00204 	addi	r3,r2,8
   3bf48:	e0bfff17 	ldw	r2,-4(fp)
   3bf4c:	10c00415 	stw	r3,16(r2)

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
   3bf50:	e0bfff17 	ldw	r2,-4(fp)
   3bf54:	10000015 	stw	zero,0(r2)
}
   3bf58:	e037883a 	mov	sp,fp
   3bf5c:	df000017 	ldw	fp,0(sp)
   3bf60:	dec00104 	addi	sp,sp,4
   3bf64:	f800283a 	ret

0003bf68 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
   3bf68:	defffe04 	addi	sp,sp,-8
   3bf6c:	df000115 	stw	fp,4(sp)
   3bf70:	df000104 	addi	fp,sp,4
   3bf74:	e13fff15 	stw	r4,-4(fp)
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
   3bf78:	e0bfff17 	ldw	r2,-4(fp)
   3bf7c:	10000415 	stw	zero,16(r2)
}
   3bf80:	e037883a 	mov	sp,fp
   3bf84:	df000017 	ldw	fp,0(sp)
   3bf88:	dec00104 	addi	sp,sp,4
   3bf8c:	f800283a 	ret

0003bf90 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
   3bf90:	defffc04 	addi	sp,sp,-16
   3bf94:	df000315 	stw	fp,12(sp)
   3bf98:	df000304 	addi	fp,sp,12
   3bf9c:	e13ffe15 	stw	r4,-8(fp)
   3bfa0:	e17fff15 	stw	r5,-4(fp)

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
   3bfa4:	e0bffe17 	ldw	r2,-8(fp)
   3bfa8:	10800117 	ldw	r2,4(r2)
   3bfac:	e0bffd15 	stw	r2,-12(fp)

	pxNewListItem->pxNext = pxIndex->pxNext;
   3bfb0:	e0bffd17 	ldw	r2,-12(fp)
   3bfb4:	10c00117 	ldw	r3,4(r2)
   3bfb8:	e0bfff17 	ldw	r2,-4(fp)
   3bfbc:	10c00115 	stw	r3,4(r2)
	pxNewListItem->pxPrevious = pxList->pxIndex;
   3bfc0:	e0bffe17 	ldw	r2,-8(fp)
   3bfc4:	10c00117 	ldw	r3,4(r2)
   3bfc8:	e0bfff17 	ldw	r2,-4(fp)
   3bfcc:	10c00215 	stw	r3,8(r2)
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
   3bfd0:	e0bffd17 	ldw	r2,-12(fp)
   3bfd4:	10800117 	ldw	r2,4(r2)
   3bfd8:	e0ffff17 	ldw	r3,-4(fp)
   3bfdc:	10c00215 	stw	r3,8(r2)
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
   3bfe0:	e0bffd17 	ldw	r2,-12(fp)
   3bfe4:	e0ffff17 	ldw	r3,-4(fp)
   3bfe8:	10c00115 	stw	r3,4(r2)
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
   3bfec:	e0bffe17 	ldw	r2,-8(fp)
   3bff0:	e0ffff17 	ldw	r3,-4(fp)
   3bff4:	10c00115 	stw	r3,4(r2)

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
   3bff8:	e0bfff17 	ldw	r2,-4(fp)
   3bffc:	e0fffe17 	ldw	r3,-8(fp)
   3c000:	10c00415 	stw	r3,16(r2)

	( pxList->uxNumberOfItems )++;
   3c004:	e0bffe17 	ldw	r2,-8(fp)
   3c008:	10800017 	ldw	r2,0(r2)
   3c00c:	10c00044 	addi	r3,r2,1
   3c010:	e0bffe17 	ldw	r2,-8(fp)
   3c014:	10c00015 	stw	r3,0(r2)
}
   3c018:	e037883a 	mov	sp,fp
   3c01c:	df000017 	ldw	fp,0(sp)
   3c020:	dec00104 	addi	sp,sp,4
   3c024:	f800283a 	ret

0003c028 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
   3c028:	defffb04 	addi	sp,sp,-20
   3c02c:	df000415 	stw	fp,16(sp)
   3c030:	df000404 	addi	fp,sp,16
   3c034:	e13ffe15 	stw	r4,-8(fp)
   3c038:	e17fff15 	stw	r5,-4(fp)
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
   3c03c:	e0bfff17 	ldw	r2,-4(fp)
   3c040:	10800017 	ldw	r2,0(r2)
   3c044:	e0bffd15 	stw	r2,-12(fp)
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
   3c048:	e0bffd17 	ldw	r2,-12(fp)
   3c04c:	10bfffd8 	cmpnei	r2,r2,-1
   3c050:	1000041e 	bne	r2,zero,3c064 <vListInsert+0x3c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
   3c054:	e0bffe17 	ldw	r2,-8(fp)
   3c058:	10800417 	ldw	r2,16(r2)
   3c05c:	e0bffc15 	stw	r2,-16(fp)
   3c060:	00000c06 	br	3c094 <vListInsert+0x6c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
   3c064:	e0bffe17 	ldw	r2,-8(fp)
   3c068:	10800204 	addi	r2,r2,8
   3c06c:	e0bffc15 	stw	r2,-16(fp)
   3c070:	00000306 	br	3c080 <vListInsert+0x58>
   3c074:	e0bffc17 	ldw	r2,-16(fp)
   3c078:	10800117 	ldw	r2,4(r2)
   3c07c:	e0bffc15 	stw	r2,-16(fp)
   3c080:	e0bffc17 	ldw	r2,-16(fp)
   3c084:	10800117 	ldw	r2,4(r2)
   3c088:	10800017 	ldw	r2,0(r2)
   3c08c:	e0fffd17 	ldw	r3,-12(fp)
   3c090:	18bff82e 	bgeu	r3,r2,3c074 <vListInsert+0x4c>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
   3c094:	e0bffc17 	ldw	r2,-16(fp)
   3c098:	10c00117 	ldw	r3,4(r2)
   3c09c:	e0bfff17 	ldw	r2,-4(fp)
   3c0a0:	10c00115 	stw	r3,4(r2)
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
   3c0a4:	e0bfff17 	ldw	r2,-4(fp)
   3c0a8:	10800117 	ldw	r2,4(r2)
   3c0ac:	e0ffff17 	ldw	r3,-4(fp)
   3c0b0:	10c00215 	stw	r3,8(r2)
	pxNewListItem->pxPrevious = pxIterator;
   3c0b4:	e0bfff17 	ldw	r2,-4(fp)
   3c0b8:	e0fffc17 	ldw	r3,-16(fp)
   3c0bc:	10c00215 	stw	r3,8(r2)
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
   3c0c0:	e0bffc17 	ldw	r2,-16(fp)
   3c0c4:	e0ffff17 	ldw	r3,-4(fp)
   3c0c8:	10c00115 	stw	r3,4(r2)

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
   3c0cc:	e0bfff17 	ldw	r2,-4(fp)
   3c0d0:	e0fffe17 	ldw	r3,-8(fp)
   3c0d4:	10c00415 	stw	r3,16(r2)

	( pxList->uxNumberOfItems )++;
   3c0d8:	e0bffe17 	ldw	r2,-8(fp)
   3c0dc:	10800017 	ldw	r2,0(r2)
   3c0e0:	10c00044 	addi	r3,r2,1
   3c0e4:	e0bffe17 	ldw	r2,-8(fp)
   3c0e8:	10c00015 	stw	r3,0(r2)
}
   3c0ec:	e037883a 	mov	sp,fp
   3c0f0:	df000017 	ldw	fp,0(sp)
   3c0f4:	dec00104 	addi	sp,sp,4
   3c0f8:	f800283a 	ret

0003c0fc <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
   3c0fc:	defffd04 	addi	sp,sp,-12
   3c100:	df000215 	stw	fp,8(sp)
   3c104:	df000204 	addi	fp,sp,8
   3c108:	e13fff15 	stw	r4,-4(fp)
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
   3c10c:	e0bfff17 	ldw	r2,-4(fp)
   3c110:	10800117 	ldw	r2,4(r2)
   3c114:	e0ffff17 	ldw	r3,-4(fp)
   3c118:	18c00217 	ldw	r3,8(r3)
   3c11c:	10c00215 	stw	r3,8(r2)
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
   3c120:	e0bfff17 	ldw	r2,-4(fp)
   3c124:	10800217 	ldw	r2,8(r2)
   3c128:	e0ffff17 	ldw	r3,-4(fp)
   3c12c:	18c00117 	ldw	r3,4(r3)
   3c130:	10c00115 	stw	r3,4(r2)
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
   3c134:	e0bfff17 	ldw	r2,-4(fp)
   3c138:	10800417 	ldw	r2,16(r2)
   3c13c:	e0bffe15 	stw	r2,-8(fp)

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
   3c140:	e0bffe17 	ldw	r2,-8(fp)
   3c144:	10c00117 	ldw	r3,4(r2)
   3c148:	e0bfff17 	ldw	r2,-4(fp)
   3c14c:	1880041e 	bne	r3,r2,3c160 <vListRemove+0x64>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
   3c150:	e0bfff17 	ldw	r2,-4(fp)
   3c154:	10c00217 	ldw	r3,8(r2)
   3c158:	e0bffe17 	ldw	r2,-8(fp)
   3c15c:	10c00115 	stw	r3,4(r2)
	}

	pxItemToRemove->pvContainer = NULL;
   3c160:	e0bfff17 	ldw	r2,-4(fp)
   3c164:	10000415 	stw	zero,16(r2)
	( pxList->uxNumberOfItems )--;
   3c168:	e0bffe17 	ldw	r2,-8(fp)
   3c16c:	10800017 	ldw	r2,0(r2)
   3c170:	10ffffc4 	addi	r3,r2,-1
   3c174:	e0bffe17 	ldw	r2,-8(fp)
   3c178:	10c00015 	stw	r3,0(r2)
}
   3c17c:	e037883a 	mov	sp,fp
   3c180:	df000017 	ldw	fp,0(sp)
   3c184:	dec00104 	addi	sp,sp,4
   3c188:	f800283a 	ret

0003c18c <prvReadGp>:
#define portINITIAL_ESTATUS     ( portSTACK_TYPE ) 0x01 

/*-----------------------------------------------------------*/

static inline void prvReadGp( unsigned long *ulValue )
{
   3c18c:	defffe04 	addi	sp,sp,-8
   3c190:	df000115 	stw	fp,4(sp)
   3c194:	df000104 	addi	fp,sp,4
   3c198:	e13fff15 	stw	r4,-4(fp)
	asm volatile ( "stw gp, (%0)" : : "r"(ulValue) );
   3c19c:	e0bfff17 	ldw	r2,-4(fp)
   3c1a0:	16800015 	stw	gp,0(r2)
}
   3c1a4:	e037883a 	mov	sp,fp
   3c1a8:	df000017 	ldw	fp,0(sp)
   3c1ac:	dec00104 	addi	sp,sp,4
   3c1b0:	f800283a 	ret

0003c1b4 <enh_alt_irq_disable_all>:
/*-----------------------------------------------------------*/

static volatile alt_irq_context lastContext;

void enh_alt_irq_disable_all()
{
   3c1b4:	defffd04 	addi	sp,sp,-12
   3c1b8:	df000215 	stw	fp,8(sp)
   3c1bc:	df000204 	addi	fp,sp,8
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   3c1c0:	0005303a 	rdctl	r2,status
   3c1c4:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   3c1c8:	e0ffff17 	ldw	r3,-4(fp)
   3c1cc:	00bfff84 	movi	r2,-2
   3c1d0:	1884703a 	and	r2,r3,r2
   3c1d4:	1001703a 	wrctl	status,r2
  
  return context;
   3c1d8:	e0bfff17 	ldw	r2,-4(fp)
	alt_irq_context ctxt = alt_irq_disable_all();
   3c1dc:	e0bffe15 	stw	r2,-8(fp)
	lastContext |= ctxt;
   3c1e0:	d0e94a17 	ldw	r3,-23256(gp)
   3c1e4:	e0bffe17 	ldw	r2,-8(fp)
   3c1e8:	1884b03a 	or	r2,r3,r2
   3c1ec:	d0a94a15 	stw	r2,-23256(gp)
}
   3c1f0:	e037883a 	mov	sp,fp
   3c1f4:	df000017 	ldw	fp,0(sp)
   3c1f8:	dec00104 	addi	sp,sp,4
   3c1fc:	f800283a 	ret

0003c200 <enh_alt_irq_enable_all>:

void enh_alt_irq_enable_all()
{
   3c200:	defffc04 	addi	sp,sp,-16
   3c204:	df000315 	stw	fp,12(sp)
   3c208:	df000304 	addi	fp,sp,12
	alt_irq_context restore = lastContext;
   3c20c:	d0a94a17 	ldw	r2,-23256(gp)
   3c210:	e0bffd15 	stw	r2,-12(fp)
	lastContext = 0;
   3c214:	d0294a15 	stw	zero,-23256(gp)
   3c218:	e0bffd17 	ldw	r2,-12(fp)
   3c21c:	e0bffe15 	stw	r2,-8(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   3c220:	0005303a 	rdctl	r2,status
   3c224:	e0bfff15 	stw	r2,-4(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   3c228:	e0ffff17 	ldw	r3,-4(fp)
   3c22c:	00bfff84 	movi	r2,-2
   3c230:	1884703a 	and	r2,r3,r2
   3c234:	e0bfff15 	stw	r2,-4(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   3c238:	e0bffe17 	ldw	r2,-8(fp)
   3c23c:	1080004c 	andi	r2,r2,1
   3c240:	e0ffff17 	ldw	r3,-4(fp)
   3c244:	1884b03a 	or	r2,r3,r2
   3c248:	e0bfff15 	stw	r2,-4(fp)
  
  NIOS2_WRITE_STATUS (status);
   3c24c:	e0bfff17 	ldw	r2,-4(fp)
   3c250:	1001703a 	wrctl	status,r2
	alt_irq_enable_all(restore);
}
   3c254:	e037883a 	mov	sp,fp
   3c258:	df000017 	ldw	fp,0(sp)
   3c25c:	dec00104 	addi	sp,sp,4
   3c260:	f800283a 	ret

0003c264 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{    
   3c264:	defff904 	addi	sp,sp,-28
   3c268:	dfc00615 	stw	ra,24(sp)
   3c26c:	df000515 	stw	fp,20(sp)
   3c270:	df000504 	addi	fp,sp,20
   3c274:	e13ffd15 	stw	r4,-12(fp)
   3c278:	e17ffe15 	stw	r5,-8(fp)
   3c27c:	e1bfff15 	stw	r6,-4(fp)
portSTACK_TYPE *pxFramePointer = pxTopOfStack - 1;
   3c280:	e0bffd17 	ldw	r2,-12(fp)
   3c284:	10bfff04 	addi	r2,r2,-4
   3c288:	e0bffb15 	stw	r2,-20(fp)
portSTACK_TYPE xGlobalPointer;

    prvReadGp( &xGlobalPointer ); 
   3c28c:	e0bffc04 	addi	r2,fp,-16
   3c290:	1009883a 	mov	r4,r2
   3c294:	003c18c0 	call	3c18c <prvReadGp>

    /* End of stack marker. */
    *pxTopOfStack = 0xdeadbeef;
   3c298:	e0bffd17 	ldw	r2,-12(fp)
   3c29c:	00f7abb4 	movhi	r3,57006
   3c2a0:	18efbbc4 	addi	r3,r3,-16657
   3c2a4:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
   3c2a8:	e0bffd17 	ldw	r2,-12(fp)
   3c2ac:	10bfff04 	addi	r2,r2,-4
   3c2b0:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = ( portSTACK_TYPE ) pxFramePointer;
   3c2b4:	e0fffb17 	ldw	r3,-20(fp)
   3c2b8:	e0bffd17 	ldw	r2,-12(fp)
   3c2bc:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
   3c2c0:	e0bffd17 	ldw	r2,-12(fp)
   3c2c4:	10bfff04 	addi	r2,r2,-4
   3c2c8:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = xGlobalPointer; 
   3c2cc:	e0fffc17 	ldw	r3,-16(fp)
   3c2d0:	e0bffd17 	ldw	r2,-12(fp)
   3c2d4:	10c00015 	stw	r3,0(r2)
    
    /* Space for R23 to R16. */
    pxTopOfStack -= 9;
   3c2d8:	e0bffd17 	ldw	r2,-12(fp)
   3c2dc:	10bff704 	addi	r2,r2,-36
   3c2e0:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = ( portSTACK_TYPE ) pxCode;
   3c2e4:	e0fffe17 	ldw	r3,-8(fp)
   3c2e8:	e0bffd17 	ldw	r2,-12(fp)
   3c2ec:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
   3c2f0:	e0bffd17 	ldw	r2,-12(fp)
   3c2f4:	10bfff04 	addi	r2,r2,-4
   3c2f8:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = portINITIAL_ESTATUS;
   3c2fc:	e0bffd17 	ldw	r2,-12(fp)
   3c300:	00c00044 	movi	r3,1
   3c304:	10c00015 	stw	r3,0(r2)

    /* Space for R15 to R5. */
    pxTopOfStack -= 12;
   3c308:	e0bffd17 	ldw	r2,-12(fp)
   3c30c:	10bff404 	addi	r2,r2,-48
   3c310:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = ( portSTACK_TYPE ) pvParameters;
   3c314:	e0ffff17 	ldw	r3,-4(fp)
   3c318:	e0bffd17 	ldw	r2,-12(fp)
   3c31c:	10c00015 	stw	r3,0(r2)

    /* Space for R3 to R1, muldiv and RA. */
    pxTopOfStack -= 5;
   3c320:	e0bffd17 	ldw	r2,-12(fp)
   3c324:	10bffb04 	addi	r2,r2,-20
   3c328:	e0bffd15 	stw	r2,-12(fp)

    /* Initialize stack pointer to prevent debugger crash. */
    *pxTopOfStack = ( portSTACK_TYPE ) xPortStartScheduler;
   3c32c:	00c00134 	movhi	r3,4
   3c330:	18f0d504 	addi	r3,r3,-15532
   3c334:	e0bffd17 	ldw	r2,-12(fp)
   3c338:	10c00015 	stw	r3,0(r2)

    return pxTopOfStack;
   3c33c:	e0bffd17 	ldw	r2,-12(fp)
}
   3c340:	e037883a 	mov	sp,fp
   3c344:	dfc00117 	ldw	ra,4(sp)
   3c348:	df000017 	ldw	fp,0(sp)
   3c34c:	dec00204 	addi	sp,sp,8
   3c350:	f800283a 	ret

0003c354 <xPortStartScheduler>:

/* 
 * See header file for description. 
 */
portBASE_TYPE xPortStartScheduler( void )
{
   3c354:	deffff04 	addi	sp,sp,-4
   3c358:	df000015 	stw	fp,0(sp)
   3c35c:	d839883a 	mov	fp,sp
   3c360:	00800034 	movhi	r2,0
	// Just load the task which is currently revered to by TCB
    asm volatile (  " movia r2, restore_sp_from_pxCurrentTCB        \n"
   3c364:	10803604 	addi	r2,r2,216
   3c368:	1000683a 	jmp	r2
                    " jmp r2                                          " );

    // This should never be reached
    return 0;
   3c36c:	0005883a 	mov	r2,zero
}
   3c370:	e037883a 	mov	sp,fp
   3c374:	df000017 	ldw	fp,0(sp)
   3c378:	dec00104 	addi	sp,sp,4
   3c37c:	f800283a 	ret

0003c380 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
   3c380:	deffff04 	addi	sp,sp,-4
   3c384:	df000015 	stw	fp,0(sp)
   3c388:	d839883a 	mov	fp,sp
	// It is unlikely that the NIOS2 port will require this function as there is nothing to return to.
}
   3c38c:	e037883a 	mov	sp,fp
   3c390:	df000017 	ldw	fp,0(sp)
   3c394:	dec00104 	addi	sp,sp,4
   3c398:	f800283a 	ret

0003c39c <vPortSysTickHandler>:
/*-----------------------------------------------------------*/

void vPortSysTickHandler( void )
{
   3c39c:	defffe04 	addi	sp,sp,-8
   3c3a0:	dfc00115 	stw	ra,4(sp)
   3c3a4:	df000015 	stw	fp,0(sp)
   3c3a8:	d839883a 	mov	fp,sp
	// only make ticks if the scheduler has been started.
	if ( xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED )
   3c3ac:	0010ebc0 	call	10ebc <xTaskGetSchedulerState>
   3c3b0:	10000226 	beq	r2,zero,3c3bc <vPortSysTickHandler+0x20>
	{
		// Increment the Kernel Tick.
		vTaskIncrementTick();
   3c3b4:	001024c0 	call	1024c <vTaskIncrementTick>

		// If using preemption, also force a context switch.
#if configUSE_PREEMPTION == 1
		vTaskSwitchContext();
   3c3b8:	00103c00 	call	103c0 <vTaskSwitchContext>
#endif
	}
}
   3c3bc:	e037883a 	mov	sp,fp
   3c3c0:	dfc00117 	ldw	ra,4(sp)
   3c3c4:	df000017 	ldw	fp,0(sp)
   3c3c8:	dec00204 	addi	sp,sp,8
   3c3cc:	f800283a 	ret

0003c3d0 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
   3c3d0:	defff404 	addi	sp,sp,-48
   3c3d4:	df000b15 	stw	fp,44(sp)
   3c3d8:	df000b04 	addi	fp,sp,44
   3c3dc:	e13ffc15 	stw	r4,-16(fp)
   3c3e0:	e17ffd15 	stw	r5,-12(fp)
   3c3e4:	e1bffe15 	stw	r6,-8(fp)
   3c3e8:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
   3c3ec:	e03ff515 	stw	zero,-44(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
   3c3f0:	00800134 	movhi	r2,4
   3c3f4:	109f0c04 	addi	r2,r2,31792
   3c3f8:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
   3c3fc:	10004a26 	beq	r2,zero,3c528 <alt_alarm_start+0x158>
  {
    if (alarm)
   3c400:	e0bffc17 	ldw	r2,-16(fp)
   3c404:	10004626 	beq	r2,zero,3c520 <alt_alarm_start+0x150>
    {
      alarm->callback = callback;
   3c408:	e0bffc17 	ldw	r2,-16(fp)
   3c40c:	e0fffe17 	ldw	r3,-8(fp)
   3c410:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
   3c414:	e0bffc17 	ldw	r2,-16(fp)
   3c418:	e0ffff17 	ldw	r3,-4(fp)
   3c41c:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   3c420:	0005303a 	rdctl	r2,status
   3c424:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   3c428:	e0fff717 	ldw	r3,-36(fp)
   3c42c:	00bfff84 	movi	r2,-2
   3c430:	1884703a 	and	r2,r3,r2
   3c434:	1001703a 	wrctl	status,r2
  
  return context;
   3c438:	e0bff717 	ldw	r2,-36(fp)
 
      irq_context = alt_irq_disable_all ();
   3c43c:	e0bff615 	stw	r2,-40(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
   3c440:	00800134 	movhi	r2,4
   3c444:	109f0d04 	addi	r2,r2,31796
   3c448:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
   3c44c:	e0bff515 	stw	r2,-44(fp)
      
      alarm->time = nticks + current_nticks + 1; 
   3c450:	e0fffd17 	ldw	r3,-12(fp)
   3c454:	e0bff517 	ldw	r2,-44(fp)
   3c458:	1885883a 	add	r2,r3,r2
   3c45c:	10c00044 	addi	r3,r2,1
   3c460:	e0bffc17 	ldw	r2,-16(fp)
   3c464:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
   3c468:	e0bffc17 	ldw	r2,-16(fp)
   3c46c:	10c00217 	ldw	r3,8(r2)
   3c470:	e0bff517 	ldw	r2,-44(fp)
   3c474:	1880042e 	bgeu	r3,r2,3c488 <alt_alarm_start+0xb8>
      {
        alarm->rollover = 1;
   3c478:	e0bffc17 	ldw	r2,-16(fp)
   3c47c:	00c00044 	movi	r3,1
   3c480:	10c00405 	stb	r3,16(r2)
   3c484:	00000206 	br	3c490 <alt_alarm_start+0xc0>
      }
      else
      {
        alarm->rollover = 0;
   3c488:	e0bffc17 	ldw	r2,-16(fp)
   3c48c:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
   3c490:	e0bffc17 	ldw	r2,-16(fp)
   3c494:	00c00134 	movhi	r3,4
   3c498:	18d5dc04 	addi	r3,r3,22384
   3c49c:	e0fff815 	stw	r3,-32(fp)
   3c4a0:	e0bff915 	stw	r2,-28(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
   3c4a4:	e0bff917 	ldw	r2,-28(fp)
   3c4a8:	e0fff817 	ldw	r3,-32(fp)
   3c4ac:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
   3c4b0:	e0bff817 	ldw	r2,-32(fp)
   3c4b4:	10c00017 	ldw	r3,0(r2)
   3c4b8:	e0bff917 	ldw	r2,-28(fp)
   3c4bc:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
   3c4c0:	e0bff817 	ldw	r2,-32(fp)
   3c4c4:	10800017 	ldw	r2,0(r2)
   3c4c8:	e0fff917 	ldw	r3,-28(fp)
   3c4cc:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
   3c4d0:	e0bff817 	ldw	r2,-32(fp)
   3c4d4:	e0fff917 	ldw	r3,-28(fp)
   3c4d8:	10c00015 	stw	r3,0(r2)
   3c4dc:	e0bff617 	ldw	r2,-40(fp)
   3c4e0:	e0bffa15 	stw	r2,-24(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   3c4e4:	0005303a 	rdctl	r2,status
   3c4e8:	e0bffb15 	stw	r2,-20(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   3c4ec:	e0fffb17 	ldw	r3,-20(fp)
   3c4f0:	00bfff84 	movi	r2,-2
   3c4f4:	1884703a 	and	r2,r3,r2
   3c4f8:	e0bffb15 	stw	r2,-20(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   3c4fc:	e0bffa17 	ldw	r2,-24(fp)
   3c500:	1080004c 	andi	r2,r2,1
   3c504:	e0fffb17 	ldw	r3,-20(fp)
   3c508:	1884b03a 	or	r2,r3,r2
   3c50c:	e0bffb15 	stw	r2,-20(fp)
  
  NIOS2_WRITE_STATUS (status);
   3c510:	e0bffb17 	ldw	r2,-20(fp)
   3c514:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
   3c518:	0005883a 	mov	r2,zero
   3c51c:	00000306 	br	3c52c <alt_alarm_start+0x15c>
    }
    else
    {
      return -EINVAL;
   3c520:	00bffa84 	movi	r2,-22
   3c524:	00000106 	br	3c52c <alt_alarm_start+0x15c>
    }
  }
  else
  {
    return -ENOTSUP;
   3c528:	00bfde84 	movi	r2,-134
  }
}
   3c52c:	e037883a 	mov	sp,fp
   3c530:	df000017 	ldw	fp,0(sp)
   3c534:	dec00104 	addi	sp,sp,4
   3c538:	f800283a 	ret

0003c53c <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
   3c53c:	defffb04 	addi	sp,sp,-20
   3c540:	df000415 	stw	fp,16(sp)
   3c544:	df000404 	addi	fp,sp,16
   3c548:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
   3c54c:	008000c4 	movi	r2,3
   3c550:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
   3c554:	e0fffd17 	ldw	r3,-12(fp)
   3c558:	008003f4 	movhi	r2,15
   3c55c:	10909004 	addi	r2,r2,16960
   3c560:	1885383a 	mul	r2,r3,r2
   3c564:	00c17db4 	movhi	r3,1526
   3c568:	18f84004 	addi	r3,r3,-7936
   3c56c:	1885203a 	divu	r2,r3,r2
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
   3c570:	00e00034 	movhi	r3,32768
   3c574:	18ffffc4 	addi	r3,r3,-1
   3c578:	1885203a 	divu	r2,r3,r2
   3c57c:	e0ffff17 	ldw	r3,-4(fp)
   3c580:	1885203a 	divu	r2,r3,r2
   3c584:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
   3c588:	e0bffe17 	ldw	r2,-8(fp)
   3c58c:	10002526 	beq	r2,zero,3c624 <alt_busy_sleep+0xe8>
  {
    for(i=0;i<big_loops;i++)
   3c590:	e03ffc15 	stw	zero,-16(fp)
   3c594:	00001406 	br	3c5e8 <alt_busy_sleep+0xac>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
   3c598:	00a00034 	movhi	r2,32768
   3c59c:	10bfffc4 	addi	r2,r2,-1
   3c5a0:	10bfffc4 	addi	r2,r2,-1
   3c5a4:	103ffe1e 	bne	r2,zero,3c5a0 <alt_busy_sleep+0x64>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
   3c5a8:	e0fffd17 	ldw	r3,-12(fp)
   3c5ac:	008003f4 	movhi	r2,15
   3c5b0:	10909004 	addi	r2,r2,16960
   3c5b4:	1885383a 	mul	r2,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
   3c5b8:	00c17db4 	movhi	r3,1526
   3c5bc:	18f84004 	addi	r3,r3,-7936
   3c5c0:	1885203a 	divu	r2,r3,r2
   3c5c4:	00e00034 	movhi	r3,32768
   3c5c8:	18ffffc4 	addi	r3,r3,-1
   3c5cc:	1885203a 	divu	r2,r3,r2
   3c5d0:	e0ffff17 	ldw	r3,-4(fp)
   3c5d4:	1885c83a 	sub	r2,r3,r2
   3c5d8:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
   3c5dc:	e0bffc17 	ldw	r2,-16(fp)
   3c5e0:	10800044 	addi	r2,r2,1
   3c5e4:	e0bffc15 	stw	r2,-16(fp)
   3c5e8:	e0fffc17 	ldw	r3,-16(fp)
   3c5ec:	e0bffe17 	ldw	r2,-8(fp)
   3c5f0:	18bfe916 	blt	r3,r2,3c598 <alt_busy_sleep+0x5c>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
   3c5f4:	e0fffd17 	ldw	r3,-12(fp)
   3c5f8:	008003f4 	movhi	r2,15
   3c5fc:	10909004 	addi	r2,r2,16960
   3c600:	1885383a 	mul	r2,r3,r2
   3c604:	00c17db4 	movhi	r3,1526
   3c608:	18f84004 	addi	r3,r3,-7936
   3c60c:	1887203a 	divu	r3,r3,r2
   3c610:	e0bfff17 	ldw	r2,-4(fp)
   3c614:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
   3c618:	10bfffc4 	addi	r2,r2,-1
   3c61c:	103ffe1e 	bne	r2,zero,3c618 <alt_busy_sleep+0xdc>
   3c620:	00000b06 	br	3c650 <alt_busy_sleep+0x114>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
   3c624:	e0fffd17 	ldw	r3,-12(fp)
   3c628:	008003f4 	movhi	r2,15
   3c62c:	10909004 	addi	r2,r2,16960
   3c630:	1885383a 	mul	r2,r3,r2
   3c634:	00c17db4 	movhi	r3,1526
   3c638:	18f84004 	addi	r3,r3,-7936
   3c63c:	1887203a 	divu	r3,r3,r2
   3c640:	e0bfff17 	ldw	r2,-4(fp)
   3c644:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
   3c648:	10bfffc4 	addi	r2,r2,-1
   3c64c:	00bffe16 	blt	zero,r2,3c648 <alt_busy_sleep+0x10c>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
   3c650:	0005883a 	mov	r2,zero
}
   3c654:	e037883a 	mov	sp,fp
   3c658:	df000017 	ldw	fp,0(sp)
   3c65c:	dec00104 	addi	sp,sp,4
   3c660:	f800283a 	ret

0003c664 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   3c664:	defffe04 	addi	sp,sp,-8
   3c668:	dfc00115 	stw	ra,4(sp)
   3c66c:	df000015 	stw	fp,0(sp)
   3c670:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   3c674:	00800134 	movhi	r2,4
   3c678:	1095d904 	addi	r2,r2,22372
   3c67c:	10800017 	ldw	r2,0(r2)
   3c680:	10000526 	beq	r2,zero,3c698 <alt_get_errno+0x34>
   3c684:	00800134 	movhi	r2,4
   3c688:	1095d904 	addi	r2,r2,22372
   3c68c:	10800017 	ldw	r2,0(r2)
   3c690:	103ee83a 	callr	r2
   3c694:	00000206 	br	3c6a0 <alt_get_errno+0x3c>
   3c698:	00800134 	movhi	r2,4
   3c69c:	109ebe04 	addi	r2,r2,31480
}
   3c6a0:	e037883a 	mov	sp,fp
   3c6a4:	dfc00117 	ldw	ra,4(sp)
   3c6a8:	df000017 	ldw	fp,0(sp)
   3c6ac:	dec00204 	addi	sp,sp,8
   3c6b0:	f800283a 	ret

0003c6b4 <alt_close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
   3c6b4:	defffb04 	addi	sp,sp,-20
   3c6b8:	dfc00415 	stw	ra,16(sp)
   3c6bc:	df000315 	stw	fp,12(sp)
   3c6c0:	df000304 	addi	fp,sp,12
   3c6c4:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
   3c6c8:	e0bfff17 	ldw	r2,-4(fp)
   3c6cc:	10000616 	blt	r2,zero,3c6e8 <alt_close+0x34>
   3c6d0:	e0bfff17 	ldw	r2,-4(fp)
   3c6d4:	10c00324 	muli	r3,r2,12
   3c6d8:	00800134 	movhi	r2,4
   3c6dc:	108f5b04 	addi	r2,r2,15724
   3c6e0:	1885883a 	add	r2,r3,r2
   3c6e4:	00000106 	br	3c6ec <alt_close+0x38>
   3c6e8:	0005883a 	mov	r2,zero
   3c6ec:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
   3c6f0:	e0bffd17 	ldw	r2,-12(fp)
   3c6f4:	10001826 	beq	r2,zero,3c758 <alt_close+0xa4>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
   3c6f8:	e0bffd17 	ldw	r2,-12(fp)
   3c6fc:	10800017 	ldw	r2,0(r2)
   3c700:	10800417 	ldw	r2,16(r2)
   3c704:	10000626 	beq	r2,zero,3c720 <alt_close+0x6c>
   3c708:	e0bffd17 	ldw	r2,-12(fp)
   3c70c:	10800017 	ldw	r2,0(r2)
   3c710:	10800417 	ldw	r2,16(r2)
   3c714:	e13ffd17 	ldw	r4,-12(fp)
   3c718:	103ee83a 	callr	r2
   3c71c:	00000106 	br	3c724 <alt_close+0x70>
   3c720:	0005883a 	mov	r2,zero
   3c724:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
   3c728:	e13fff17 	ldw	r4,-4(fp)
   3c72c:	00122c80 	call	122c8 <alt_release_fd>
    if (rval < 0)
   3c730:	e0bffe17 	ldw	r2,-8(fp)
   3c734:	1000060e 	bge	r2,zero,3c750 <alt_close+0x9c>
    {
      ALT_ERRNO = -rval;
   3c738:	003c6640 	call	3c664 <alt_get_errno>
   3c73c:	e0fffe17 	ldw	r3,-8(fp)
   3c740:	00c7c83a 	sub	r3,zero,r3
   3c744:	10c00015 	stw	r3,0(r2)
      return -1;
   3c748:	00bfffc4 	movi	r2,-1
   3c74c:	00000606 	br	3c768 <alt_close+0xb4>
    }
    return 0;
   3c750:	0005883a 	mov	r2,zero
   3c754:	00000406 	br	3c768 <alt_close+0xb4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
   3c758:	003c6640 	call	3c664 <alt_get_errno>
   3c75c:	00c01444 	movi	r3,81
   3c760:	10c00015 	stw	r3,0(r2)
    return -1;
   3c764:	00bfffc4 	movi	r2,-1
  }
}
   3c768:	e037883a 	mov	sp,fp
   3c76c:	dfc00117 	ldw	ra,4(sp)
   3c770:	df000017 	ldw	fp,0(sp)
   3c774:	dec00204 	addi	sp,sp,8
   3c778:	f800283a 	ret

0003c77c <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
   3c77c:	defffd04 	addi	sp,sp,-12
   3c780:	df000215 	stw	fp,8(sp)
   3c784:	df000204 	addi	fp,sp,8
   3c788:	e13ffe15 	stw	r4,-8(fp)
   3c78c:	e17fff15 	stw	r5,-4(fp)
  {
    ALT_FLUSH_DATA(i);
  }

#endif /* NIOS2_DCACHE_SIZE > 0 */
}
   3c790:	e037883a 	mov	sp,fp
   3c794:	df000017 	ldw	fp,0(sp)
   3c798:	dec00104 	addi	sp,sp,4
   3c79c:	f800283a 	ret

0003c7a0 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
   3c7a0:	deffff04 	addi	sp,sp,-4
   3c7a4:	df000015 	stw	fp,0(sp)
   3c7a8:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
   3c7ac:	e037883a 	mov	sp,fp
   3c7b0:	df000017 	ldw	fp,0(sp)
   3c7b4:	dec00104 	addi	sp,sp,4
   3c7b8:	f800283a 	ret

0003c7bc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   3c7bc:	defffe04 	addi	sp,sp,-8
   3c7c0:	dfc00115 	stw	ra,4(sp)
   3c7c4:	df000015 	stw	fp,0(sp)
   3c7c8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   3c7cc:	00800134 	movhi	r2,4
   3c7d0:	1095d904 	addi	r2,r2,22372
   3c7d4:	10800017 	ldw	r2,0(r2)
   3c7d8:	10000526 	beq	r2,zero,3c7f0 <alt_get_errno+0x34>
   3c7dc:	00800134 	movhi	r2,4
   3c7e0:	1095d904 	addi	r2,r2,22372
   3c7e4:	10800017 	ldw	r2,0(r2)
   3c7e8:	103ee83a 	callr	r2
   3c7ec:	00000206 	br	3c7f8 <alt_get_errno+0x3c>
   3c7f0:	00800134 	movhi	r2,4
   3c7f4:	109ebe04 	addi	r2,r2,31480
}
   3c7f8:	e037883a 	mov	sp,fp
   3c7fc:	dfc00117 	ldw	ra,4(sp)
   3c800:	df000017 	ldw	fp,0(sp)
   3c804:	dec00204 	addi	sp,sp,8
   3c808:	f800283a 	ret

0003c80c <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
   3c80c:	defffa04 	addi	sp,sp,-24
   3c810:	dfc00515 	stw	ra,20(sp)
   3c814:	df000415 	stw	fp,16(sp)
   3c818:	df000404 	addi	fp,sp,16
   3c81c:	e13ffe15 	stw	r4,-8(fp)
   3c820:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
   3c824:	e0bffe17 	ldw	r2,-8(fp)
   3c828:	10000326 	beq	r2,zero,3c838 <alt_dev_llist_insert+0x2c>
   3c82c:	e0bffe17 	ldw	r2,-8(fp)
   3c830:	10800217 	ldw	r2,8(r2)
   3c834:	1000051e 	bne	r2,zero,3c84c <alt_dev_llist_insert+0x40>
  {
    ALT_ERRNO = EINVAL;
   3c838:	003c7bc0 	call	3c7bc <alt_get_errno>
   3c83c:	00c00584 	movi	r3,22
   3c840:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
   3c844:	00bffa84 	movi	r2,-22
   3c848:	00001306 	br	3c898 <alt_dev_llist_insert+0x8c>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
   3c84c:	e0bffe17 	ldw	r2,-8(fp)
   3c850:	e0ffff17 	ldw	r3,-4(fp)
   3c854:	e0fffc15 	stw	r3,-16(fp)
   3c858:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
   3c85c:	e0bffd17 	ldw	r2,-12(fp)
   3c860:	e0fffc17 	ldw	r3,-16(fp)
   3c864:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
   3c868:	e0bffc17 	ldw	r2,-16(fp)
   3c86c:	10c00017 	ldw	r3,0(r2)
   3c870:	e0bffd17 	ldw	r2,-12(fp)
   3c874:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
   3c878:	e0bffc17 	ldw	r2,-16(fp)
   3c87c:	10800017 	ldw	r2,0(r2)
   3c880:	e0fffd17 	ldw	r3,-12(fp)
   3c884:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
   3c888:	e0bffc17 	ldw	r2,-16(fp)
   3c88c:	e0fffd17 	ldw	r3,-12(fp)
   3c890:	10c00015 	stw	r3,0(r2)

  return 0;  
   3c894:	0005883a 	mov	r2,zero
}
   3c898:	e037883a 	mov	sp,fp
   3c89c:	dfc00117 	ldw	ra,4(sp)
   3c8a0:	df000017 	ldw	fp,0(sp)
   3c8a4:	dec00204 	addi	sp,sp,8
   3c8a8:	f800283a 	ret

0003c8ac <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
   3c8ac:	defffa04 	addi	sp,sp,-24
   3c8b0:	dfc00515 	stw	ra,20(sp)
   3c8b4:	df000415 	stw	fp,16(sp)
   3c8b8:	df000404 	addi	fp,sp,16
   3c8bc:	e13ffe15 	stw	r4,-8(fp)
   3c8c0:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
   3c8c4:	e0bfff17 	ldw	r2,-4(fp)
   3c8c8:	10800017 	ldw	r2,0(r2)
   3c8cc:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
   3c8d0:	e13ffe17 	ldw	r4,-8(fp)
   3c8d4:	0004d9c0 	call	4d9c <strlen>
   3c8d8:	10800044 	addi	r2,r2,1
   3c8dc:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   3c8e0:	00000d06 	br	3c918 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
   3c8e4:	e0bffc17 	ldw	r2,-16(fp)
   3c8e8:	10c00217 	ldw	r3,8(r2)
   3c8ec:	e0bffd17 	ldw	r2,-12(fp)
   3c8f0:	1809883a 	mov	r4,r3
   3c8f4:	e17ffe17 	ldw	r5,-8(fp)
   3c8f8:	100d883a 	mov	r6,r2
   3c8fc:	003f2240 	call	3f224 <memcmp>
   3c900:	1000021e 	bne	r2,zero,3c90c <alt_find_dev+0x60>
    {
      /* match found */

      return next;
   3c904:	e0bffc17 	ldw	r2,-16(fp)
   3c908:	00000706 	br	3c928 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
   3c90c:	e0bffc17 	ldw	r2,-16(fp)
   3c910:	10800017 	ldw	r2,0(r2)
   3c914:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   3c918:	e0fffc17 	ldw	r3,-16(fp)
   3c91c:	e0bfff17 	ldw	r2,-4(fp)
   3c920:	18bff01e 	bne	r3,r2,3c8e4 <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
   3c924:	0005883a 	mov	r2,zero
}
   3c928:	e037883a 	mov	sp,fp
   3c92c:	dfc00117 	ldw	ra,4(sp)
   3c930:	df000017 	ldw	fp,0(sp)
   3c934:	dec00204 	addi	sp,sp,8
   3c938:	f800283a 	ret

0003c93c <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
   3c93c:	defffb04 	addi	sp,sp,-20
   3c940:	dfc00415 	stw	ra,16(sp)
   3c944:	df000315 	stw	fp,12(sp)
   3c948:	df000304 	addi	fp,sp,12
   3c94c:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
   3c950:	00800134 	movhi	r2,4
   3c954:	1095c404 	addi	r2,r2,22288
   3c958:	10800017 	ldw	r2,0(r2)
   3c95c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
   3c960:	00003106 	br	3ca28 <alt_find_file+0xec>
  {
    len = strlen(next->name);
   3c964:	e0bffd17 	ldw	r2,-12(fp)
   3c968:	10800217 	ldw	r2,8(r2)
   3c96c:	1009883a 	mov	r4,r2
   3c970:	0004d9c0 	call	4d9c <strlen>
   3c974:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
   3c978:	e0bffd17 	ldw	r2,-12(fp)
   3c97c:	10c00217 	ldw	r3,8(r2)
   3c980:	e0bffe17 	ldw	r2,-8(fp)
   3c984:	10bfffc4 	addi	r2,r2,-1
   3c988:	1885883a 	add	r2,r3,r2
   3c98c:	10800003 	ldbu	r2,0(r2)
   3c990:	10803fcc 	andi	r2,r2,255
   3c994:	1080201c 	xori	r2,r2,128
   3c998:	10bfe004 	addi	r2,r2,-128
   3c99c:	10800bd8 	cmpnei	r2,r2,47
   3c9a0:	1000031e 	bne	r2,zero,3c9b0 <alt_find_file+0x74>
    {
      len -= 1;
   3c9a4:	e0bffe17 	ldw	r2,-8(fp)
   3c9a8:	10bfffc4 	addi	r2,r2,-1
   3c9ac:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
   3c9b0:	e0bffe17 	ldw	r2,-8(fp)
   3c9b4:	e0ffff17 	ldw	r3,-4(fp)
   3c9b8:	1885883a 	add	r2,r3,r2
   3c9bc:	10800003 	ldbu	r2,0(r2)
   3c9c0:	10803fcc 	andi	r2,r2,255
   3c9c4:	1080201c 	xori	r2,r2,128
   3c9c8:	10bfe004 	addi	r2,r2,-128
   3c9cc:	10800be0 	cmpeqi	r2,r2,47
   3c9d0:	1000081e 	bne	r2,zero,3c9f4 <alt_find_file+0xb8>
   3c9d4:	e0bffe17 	ldw	r2,-8(fp)
   3c9d8:	e0ffff17 	ldw	r3,-4(fp)
   3c9dc:	1885883a 	add	r2,r3,r2
   3c9e0:	10800003 	ldbu	r2,0(r2)
   3c9e4:	10803fcc 	andi	r2,r2,255
   3c9e8:	1080201c 	xori	r2,r2,128
   3c9ec:	10bfe004 	addi	r2,r2,-128
   3c9f0:	10000a1e 	bne	r2,zero,3ca1c <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
   3c9f4:	e0bffd17 	ldw	r2,-12(fp)
   3c9f8:	10c00217 	ldw	r3,8(r2)
   3c9fc:	e0bffe17 	ldw	r2,-8(fp)
   3ca00:	1809883a 	mov	r4,r3
   3ca04:	e17fff17 	ldw	r5,-4(fp)
   3ca08:	100d883a 	mov	r6,r2
   3ca0c:	003f2240 	call	3f224 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
   3ca10:	1000021e 	bne	r2,zero,3ca1c <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
   3ca14:	e0bffd17 	ldw	r2,-12(fp)
   3ca18:	00000806 	br	3ca3c <alt_find_file+0x100>
    }
    next = (alt_dev*) next->llist.next;
   3ca1c:	e0bffd17 	ldw	r2,-12(fp)
   3ca20:	10800017 	ldw	r2,0(r2)
   3ca24:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
   3ca28:	e0fffd17 	ldw	r3,-12(fp)
   3ca2c:	00800134 	movhi	r2,4
   3ca30:	1095c404 	addi	r2,r2,22288
   3ca34:	18bfcb1e 	bne	r3,r2,3c964 <alt_find_file+0x28>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
   3ca38:	0005883a 	mov	r2,zero
}
   3ca3c:	e037883a 	mov	sp,fp
   3ca40:	dfc00117 	ldw	ra,4(sp)
   3ca44:	df000017 	ldw	fp,0(sp)
   3ca48:	dec00204 	addi	sp,sp,8
   3ca4c:	f800283a 	ret

0003ca50 <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
   3ca50:	defffc04 	addi	sp,sp,-16
   3ca54:	dfc00315 	stw	ra,12(sp)
   3ca58:	df000215 	stw	fp,8(sp)
   3ca5c:	df000204 	addi	fp,sp,8
   3ca60:	e13fff15 	stw	r4,-4(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
   3ca64:	e13fff17 	ldw	r4,-4(fp)
   3ca68:	d1601e04 	addi	r5,gp,-32648
   3ca6c:	003c8ac0 	call	3c8ac <alt_find_dev>
   3ca70:	e0bffe15 	stw	r2,-8(fp)

  if ((dev) && dev->open)
   3ca74:	e0bffe17 	ldw	r2,-8(fp)
   3ca78:	10000926 	beq	r2,zero,3caa0 <alt_flash_open_dev+0x50>
   3ca7c:	e0bffe17 	ldw	r2,-8(fp)
   3ca80:	10800317 	ldw	r2,12(r2)
   3ca84:	10000626 	beq	r2,zero,3caa0 <alt_flash_open_dev+0x50>
  {
    return dev->open(dev, name);
   3ca88:	e0bffe17 	ldw	r2,-8(fp)
   3ca8c:	10800317 	ldw	r2,12(r2)
   3ca90:	e13ffe17 	ldw	r4,-8(fp)
   3ca94:	e17fff17 	ldw	r5,-4(fp)
   3ca98:	103ee83a 	callr	r2
   3ca9c:	00000106 	br	3caa4 <alt_flash_open_dev+0x54>
  }

  return dev;
   3caa0:	e0bffe17 	ldw	r2,-8(fp)
}
   3caa4:	e037883a 	mov	sp,fp
   3caa8:	dfc00117 	ldw	ra,4(sp)
   3caac:	df000017 	ldw	fp,0(sp)
   3cab0:	dec00204 	addi	sp,sp,8
   3cab4:	f800283a 	ret

0003cab8 <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
   3cab8:	defffd04 	addi	sp,sp,-12
   3cabc:	dfc00215 	stw	ra,8(sp)
   3cac0:	df000115 	stw	fp,4(sp)
   3cac4:	df000104 	addi	fp,sp,4
   3cac8:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
   3cacc:	e0bfff17 	ldw	r2,-4(fp)
   3cad0:	10000726 	beq	r2,zero,3caf0 <alt_flash_close_dev+0x38>
   3cad4:	e0bfff17 	ldw	r2,-4(fp)
   3cad8:	10800417 	ldw	r2,16(r2)
   3cadc:	10000426 	beq	r2,zero,3caf0 <alt_flash_close_dev+0x38>
  {
    fd->close(fd);
   3cae0:	e0bfff17 	ldw	r2,-4(fp)
   3cae4:	10800417 	ldw	r2,16(r2)
   3cae8:	e13fff17 	ldw	r4,-4(fp)
   3caec:	103ee83a 	callr	r2
  }
  return;
   3caf0:	0001883a 	nop
}
   3caf4:	e037883a 	mov	sp,fp
   3caf8:	dfc00117 	ldw	ra,4(sp)
   3cafc:	df000017 	ldw	fp,0(sp)
   3cb00:	dec00204 	addi	sp,sp,8
   3cb04:	f800283a 	ret

0003cb08 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
   3cb08:	defff904 	addi	sp,sp,-28
   3cb0c:	dfc00615 	stw	ra,24(sp)
   3cb10:	df000515 	stw	fp,20(sp)
   3cb14:	df000504 	addi	fp,sp,20
   3cb18:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
   3cb1c:	00bffa04 	movi	r2,-24
   3cb20:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
   3cb24:	00800134 	movhi	r2,4
   3cb28:	109ed504 	addi	r2,r2,31572
   3cb2c:	10800017 	ldw	r2,0(r2)
   3cb30:	e0bffd15 	stw	r2,-12(fp)
   3cb34:	e03ffe0d 	sth	zero,-8(fp)
   3cb38:	e0bffe0b 	ldhu	r2,-8(fp)
   3cb3c:	e13ffd17 	ldw	r4,-12(fp)
   3cb40:	000b883a 	mov	r5,zero
   3cb44:	100d883a 	mov	r6,r2
   3cb48:	000f883a 	mov	r7,zero
   3cb4c:	000ebd80 	call	ebd8 <xQueueGenericReceive>
   3cb50:	0001883a 	nop
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
   3cb54:	e03ffb15 	stw	zero,-20(fp)
   3cb58:	00001d06 	br	3cbd0 <alt_get_fd+0xc8>
  {
    if (!alt_fd_list[i].dev)
   3cb5c:	00c00134 	movhi	r3,4
   3cb60:	18cf5b04 	addi	r3,r3,15724
   3cb64:	e0bffb17 	ldw	r2,-20(fp)
   3cb68:	10800324 	muli	r2,r2,12
   3cb6c:	1885883a 	add	r2,r3,r2
   3cb70:	10800017 	ldw	r2,0(r2)
   3cb74:	1000131e 	bne	r2,zero,3cbc4 <alt_get_fd+0xbc>
    {
      alt_fd_list[i].dev = dev;
   3cb78:	00c00134 	movhi	r3,4
   3cb7c:	18cf5b04 	addi	r3,r3,15724
   3cb80:	e0bffb17 	ldw	r2,-20(fp)
   3cb84:	10800324 	muli	r2,r2,12
   3cb88:	1885883a 	add	r2,r3,r2
   3cb8c:	e0ffff17 	ldw	r3,-4(fp)
   3cb90:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
   3cb94:	00800134 	movhi	r2,4
   3cb98:	1095c804 	addi	r2,r2,22304
   3cb9c:	10c00017 	ldw	r3,0(r2)
   3cba0:	e0bffb17 	ldw	r2,-20(fp)
   3cba4:	1880040e 	bge	r3,r2,3cbb8 <alt_get_fd+0xb0>
      {
        alt_max_fd = i;
   3cba8:	00800134 	movhi	r2,4
   3cbac:	1095c804 	addi	r2,r2,22304
   3cbb0:	e0fffb17 	ldw	r3,-20(fp)
   3cbb4:	10c00015 	stw	r3,0(r2)
      }
      rc = i;
   3cbb8:	e0bffb17 	ldw	r2,-20(fp)
   3cbbc:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
   3cbc0:	00000606 	br	3cbdc <alt_get_fd+0xd4>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
   3cbc4:	e0bffb17 	ldw	r2,-20(fp)
   3cbc8:	10800044 	addi	r2,r2,1
   3cbcc:	e0bffb15 	stw	r2,-20(fp)
   3cbd0:	e0bffb17 	ldw	r2,-20(fp)
   3cbd4:	10800810 	cmplti	r2,r2,32
   3cbd8:	103fe01e 	bne	r2,zero,3cb5c <alt_get_fd+0x54>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
   3cbdc:	00800134 	movhi	r2,4
   3cbe0:	109ed504 	addi	r2,r2,31572
   3cbe4:	10800017 	ldw	r2,0(r2)
   3cbe8:	1009883a 	mov	r4,r2
   3cbec:	000b883a 	mov	r5,zero
   3cbf0:	000d883a 	mov	r6,zero
   3cbf4:	000f883a 	mov	r7,zero
   3cbf8:	000e95c0 	call	e95c <xQueueGenericSend>

  return rc;
   3cbfc:	e0bffc17 	ldw	r2,-16(fp)
}
   3cc00:	e037883a 	mov	sp,fp
   3cc04:	dfc00117 	ldw	ra,4(sp)
   3cc08:	df000017 	ldw	fp,0(sp)
   3cc0c:	dec00204 	addi	sp,sp,8
   3cc10:	f800283a 	ret

0003cc14 <gettimeofday>:
 */
 

#if defined (__GNUC__) && (__GNUC__ >= 4)
int ALT_GETTIMEOFDAY (struct timeval  *ptimeval, void *ptimezone_vptr)
{
   3cc14:	defff804 	addi	sp,sp,-32
   3cc18:	dfc00715 	stw	ra,28(sp)
   3cc1c:	df000615 	stw	fp,24(sp)
   3cc20:	dc000515 	stw	r16,20(sp)
   3cc24:	df000504 	addi	fp,sp,20
   3cc28:	e13ffe15 	stw	r4,-8(fp)
   3cc2c:	e17fff15 	stw	r5,-4(fp)
  struct timezone *ptimezone = (struct timezone*)ptimezone_vptr;
   3cc30:	e13fff17 	ldw	r4,-4(fp)
   3cc34:	e13ffb15 	stw	r4,-20(fp)
   3cc38:	01000134 	movhi	r4,4
   3cc3c:	211f0d04 	addi	r4,r4,31796
   3cc40:	21000017 	ldw	r4,0(r4)
#else
int ALT_GETTIMEOFDAY (struct timeval  *ptimeval, struct timezone *ptimezone)
{
#endif
  
  alt_u32 nticks = alt_nticks (); 
   3cc44:	e13ffc15 	stw	r4,-16(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
   3cc48:	01000134 	movhi	r4,4
   3cc4c:	211f0c04 	addi	r4,r4,31792
   3cc50:	21000017 	ldw	r4,0(r4)
  alt_u32 tick_rate = alt_ticks_per_second ();
   3cc54:	e13ffd15 	stw	r4,-12(fp)
   * non-zero system clock rate. If the system clock is not running, an error
   * is generated and the contents of "ptimeval" and "ptimezone" are not
   * updated.
   */

  if (tick_rate)
   3cc58:	e13ffd17 	ldw	r4,-12(fp)
   3cc5c:	20006526 	beq	r4,zero,3cdf4 <gettimeofday+0x1e0>
  {
    ptimeval->tv_sec  = alt_resettime.tv_sec  + nticks/tick_rate;
   3cc60:	d1294d17 	ldw	r4,-23244(gp)
   3cc64:	200b883a 	mov	r5,r4
   3cc68:	e23ffc17 	ldw	r8,-16(fp)
   3cc6c:	e13ffd17 	ldw	r4,-12(fp)
   3cc70:	4109203a 	divu	r4,r8,r4
   3cc74:	2909883a 	add	r4,r5,r4
   3cc78:	200b883a 	mov	r5,r4
   3cc7c:	e13ffe17 	ldw	r4,-8(fp)
   3cc80:	21400015 	stw	r5,0(r4)
    ptimeval->tv_usec = alt_resettime.tv_usec +
   3cc84:	01000134 	movhi	r4,4
   3cc88:	211f0a04 	addi	r4,r4,31784
   3cc8c:	21000017 	ldw	r4,0(r4)
   3cc90:	2021883a 	mov	r16,r4
     (alt_u32)(((alt_u64)nticks*(ALT_US/tick_rate))%ALT_US);
   3cc94:	e1bffc17 	ldw	r6,-16(fp)
   3cc98:	000f883a 	mov	r7,zero
   3cc9c:	014003f4 	movhi	r5,15
   3cca0:	29509004 	addi	r5,r5,16960
   3cca4:	e13ffd17 	ldw	r4,-12(fp)
   3cca8:	2909203a 	divu	r4,r5,r4
   3ccac:	2005883a 	mov	r2,r4
   3ccb0:	0007883a 	mov	r3,zero
   3ccb4:	3009883a 	mov	r4,r6
   3ccb8:	380b883a 	mov	r5,r7
   3ccbc:	100d883a 	mov	r6,r2
   3ccc0:	180f883a 	mov	r7,r3
   3ccc4:	000dd480 	call	dd48 <__muldi3>
   3ccc8:	100f883a 	mov	r7,r2
   3cccc:	1811883a 	mov	r8,r3
   3ccd0:	380b883a 	mov	r5,r7
   3ccd4:	400d883a 	mov	r6,r8
   3ccd8:	008003f4 	movhi	r2,15
   3ccdc:	10909004 	addi	r2,r2,16960
   3cce0:	0007883a 	mov	r3,zero
   3cce4:	2809883a 	mov	r4,r5
   3cce8:	300b883a 	mov	r5,r6
   3ccec:	100d883a 	mov	r6,r2
   3ccf0:	180f883a 	mov	r7,r3
   3ccf4:	000c94c0 	call	c94c <__umoddi3>
   3ccf8:	1009883a 	mov	r4,r2
   3ccfc:	180b883a 	mov	r5,r3
   3cd00:	2005883a 	mov	r2,r4
   3cd04:	2807883a 	mov	r3,r5
   */

  if (tick_rate)
  {
    ptimeval->tv_sec  = alt_resettime.tv_sec  + nticks/tick_rate;
    ptimeval->tv_usec = alt_resettime.tv_usec +
   3cd08:	8085883a 	add	r2,r16,r2
   3cd0c:	1007883a 	mov	r3,r2
   3cd10:	e0bffe17 	ldw	r2,-8(fp)
   3cd14:	10c00115 	stw	r3,4(r2)
     (alt_u32)(((alt_u64)nticks*(ALT_US/tick_rate))%ALT_US);
      
    while(ptimeval->tv_usec < 0) {
   3cd18:	00001506 	br	3cd70 <gettimeofday+0x15c>
      if (ptimeval->tv_sec <= 0)
   3cd1c:	e0bffe17 	ldw	r2,-8(fp)
   3cd20:	10800017 	ldw	r2,0(r2)
   3cd24:	00800616 	blt	zero,r2,3cd40 <gettimeofday+0x12c>
      {
          ptimeval->tv_sec = 0;
   3cd28:	e0bffe17 	ldw	r2,-8(fp)
   3cd2c:	10000015 	stw	zero,0(r2)
          ptimeval->tv_usec = 0;
   3cd30:	e0bffe17 	ldw	r2,-8(fp)
   3cd34:	10000115 	stw	zero,4(r2)
          break;
   3cd38:	0001883a 	nop
          ptimeval->tv_sec--;
          ptimeval->tv_usec += ALT_US;
      }
    }
    
    while(ptimeval->tv_usec >= ALT_US) {
   3cd3c:	00001c06 	br	3cdb0 <gettimeofday+0x19c>
          ptimeval->tv_usec = 0;
          break;
      }
      else
      {
          ptimeval->tv_sec--;
   3cd40:	e0bffe17 	ldw	r2,-8(fp)
   3cd44:	10800017 	ldw	r2,0(r2)
   3cd48:	10ffffc4 	addi	r3,r2,-1
   3cd4c:	e0bffe17 	ldw	r2,-8(fp)
   3cd50:	10c00015 	stw	r3,0(r2)
          ptimeval->tv_usec += ALT_US;
   3cd54:	e0bffe17 	ldw	r2,-8(fp)
   3cd58:	10c00117 	ldw	r3,4(r2)
   3cd5c:	008003f4 	movhi	r2,15
   3cd60:	10909004 	addi	r2,r2,16960
   3cd64:	1887883a 	add	r3,r3,r2
   3cd68:	e0bffe17 	ldw	r2,-8(fp)
   3cd6c:	10c00115 	stw	r3,4(r2)
  {
    ptimeval->tv_sec  = alt_resettime.tv_sec  + nticks/tick_rate;
    ptimeval->tv_usec = alt_resettime.tv_usec +
     (alt_u32)(((alt_u64)nticks*(ALT_US/tick_rate))%ALT_US);
      
    while(ptimeval->tv_usec < 0) {
   3cd70:	e0bffe17 	ldw	r2,-8(fp)
   3cd74:	10800117 	ldw	r2,4(r2)
   3cd78:	103fe816 	blt	r2,zero,3cd1c <gettimeofday+0x108>
          ptimeval->tv_sec--;
          ptimeval->tv_usec += ALT_US;
      }
    }
    
    while(ptimeval->tv_usec >= ALT_US) {
   3cd7c:	00000c06 	br	3cdb0 <gettimeofday+0x19c>
      ptimeval->tv_sec++;
   3cd80:	e0bffe17 	ldw	r2,-8(fp)
   3cd84:	10800017 	ldw	r2,0(r2)
   3cd88:	10c00044 	addi	r3,r2,1
   3cd8c:	e0bffe17 	ldw	r2,-8(fp)
   3cd90:	10c00015 	stw	r3,0(r2)
      ptimeval->tv_usec -= ALT_US;
   3cd94:	e0bffe17 	ldw	r2,-8(fp)
   3cd98:	10c00117 	ldw	r3,4(r2)
   3cd9c:	00bffc74 	movhi	r2,65521
   3cda0:	10af7004 	addi	r2,r2,-16960
   3cda4:	1887883a 	add	r3,r3,r2
   3cda8:	e0bffe17 	ldw	r2,-8(fp)
   3cdac:	10c00115 	stw	r3,4(r2)
          ptimeval->tv_sec--;
          ptimeval->tv_usec += ALT_US;
      }
    }
    
    while(ptimeval->tv_usec >= ALT_US) {
   3cdb0:	e0bffe17 	ldw	r2,-8(fp)
   3cdb4:	10800117 	ldw	r2,4(r2)
   3cdb8:	00c003f4 	movhi	r3,15
   3cdbc:	18d08fc4 	addi	r3,r3,16959
   3cdc0:	18bfef16 	blt	r3,r2,3cd80 <gettimeofday+0x16c>
      ptimeval->tv_sec++;
      ptimeval->tv_usec -= ALT_US;
    }
      
    if (ptimezone)
   3cdc4:	e0bffb17 	ldw	r2,-20(fp)
   3cdc8:	10000826 	beq	r2,zero,3cdec <gettimeofday+0x1d8>
    { 
      ptimezone->tz_minuteswest = alt_timezone.tz_minuteswest;
   3cdcc:	d0e94b17 	ldw	r3,-23252(gp)
   3cdd0:	e0bffb17 	ldw	r2,-20(fp)
   3cdd4:	10c00015 	stw	r3,0(r2)
      ptimezone->tz_dsttime     = alt_timezone.tz_dsttime;
   3cdd8:	00800134 	movhi	r2,4
   3cddc:	109f0804 	addi	r2,r2,31776
   3cde0:	10c00017 	ldw	r3,0(r2)
   3cde4:	e0bffb17 	ldw	r2,-20(fp)
   3cde8:	10c00115 	stw	r3,4(r2)
    }

    return 0;
   3cdec:	0005883a 	mov	r2,zero
   3cdf0:	00000106 	br	3cdf8 <gettimeofday+0x1e4>
  }

  return -ENOTSUP;
   3cdf4:	00bfde84 	movi	r2,-134
}
   3cdf8:	e037883a 	mov	sp,fp
   3cdfc:	dfc00217 	ldw	ra,8(sp)
   3ce00:	df000117 	ldw	fp,4(sp)
   3ce04:	dc000017 	ldw	r16,0(sp)
   3ce08:	dec00304 	addi	sp,sp,12
   3ce0c:	f800283a 	ret

0003ce10 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
   3ce10:	defffe04 	addi	sp,sp,-8
   3ce14:	dfc00115 	stw	ra,4(sp)
   3ce18:	df000015 	stw	fp,0(sp)
   3ce1c:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
   3ce20:	0009883a 	mov	r4,zero
   3ce24:	01440004 	movi	r5,4096
   3ce28:	003f1140 	call	3f114 <alt_icache_flush>
#endif
}
   3ce2c:	e037883a 	mov	sp,fp
   3ce30:	dfc00117 	ldw	ra,4(sp)
   3ce34:	df000017 	ldw	fp,0(sp)
   3ce38:	dec00204 	addi	sp,sp,8
   3ce3c:	f800283a 	ret

0003ce40 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
   3ce40:	defffe04 	addi	sp,sp,-8
   3ce44:	df000115 	stw	fp,4(sp)
   3ce48:	df000104 	addi	fp,sp,4
   3ce4c:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
   3ce50:	e0bfff17 	ldw	r2,-4(fp)
   3ce54:	10bffe84 	addi	r2,r2,-6
   3ce58:	10c00428 	cmpgeui	r3,r2,16
   3ce5c:	18001b1e 	bne	r3,zero,3cecc <alt_exception_cause_generated_bad_addr+0x8c>
   3ce60:	1085883a 	add	r2,r2,r2
   3ce64:	1087883a 	add	r3,r2,r2
   3ce68:	00800134 	movhi	r2,4
   3ce6c:	10b39f04 	addi	r2,r2,-12676
   3ce70:	1885883a 	add	r2,r3,r2
   3ce74:	10800017 	ldw	r2,0(r2)
   3ce78:	1000683a 	jmp	r2
   3ce7c:	0003cebc 	xorhi	zero,zero,3898
   3ce80:	0003cebc 	xorhi	zero,zero,3898
   3ce84:	0003cecc 	andi	zero,zero,3899
   3ce88:	0003cecc 	andi	zero,zero,3899
   3ce8c:	0003cecc 	andi	zero,zero,3899
   3ce90:	0003cebc 	xorhi	zero,zero,3898
   3ce94:	0003cec4 	movi	zero,3899
   3ce98:	0003cecc 	andi	zero,zero,3899
   3ce9c:	0003cebc 	xorhi	zero,zero,3898
   3cea0:	0003cebc 	xorhi	zero,zero,3898
   3cea4:	0003cecc 	andi	zero,zero,3899
   3cea8:	0003cebc 	xorhi	zero,zero,3898
   3ceac:	0003cec4 	movi	zero,3899
   3ceb0:	0003cecc 	andi	zero,zero,3899
   3ceb4:	0003cecc 	andi	zero,zero,3899
   3ceb8:	0003cebc 	xorhi	zero,zero,3898
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
   3cebc:	00800044 	movi	r2,1
   3cec0:	00000306 	br	3ced0 <alt_exception_cause_generated_bad_addr+0x90>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
   3cec4:	0005883a 	mov	r2,zero
   3cec8:	00000106 	br	3ced0 <alt_exception_cause_generated_bad_addr+0x90>

  default:
    return 0;
   3cecc:	0005883a 	mov	r2,zero
  }
}
   3ced0:	e037883a 	mov	sp,fp
   3ced4:	df000017 	ldw	fp,0(sp)
   3ced8:	dec00104 	addi	sp,sp,4
   3cedc:	f800283a 	ret

0003cee0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   3cee0:	defffe04 	addi	sp,sp,-8
   3cee4:	dfc00115 	stw	ra,4(sp)
   3cee8:	df000015 	stw	fp,0(sp)
   3ceec:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   3cef0:	00800134 	movhi	r2,4
   3cef4:	1095d904 	addi	r2,r2,22372
   3cef8:	10800017 	ldw	r2,0(r2)
   3cefc:	10000526 	beq	r2,zero,3cf14 <alt_get_errno+0x34>
   3cf00:	00800134 	movhi	r2,4
   3cf04:	1095d904 	addi	r2,r2,22372
   3cf08:	10800017 	ldw	r2,0(r2)
   3cf0c:	103ee83a 	callr	r2
   3cf10:	00000206 	br	3cf1c <alt_get_errno+0x3c>
   3cf14:	00800134 	movhi	r2,4
   3cf18:	109ebe04 	addi	r2,r2,31480
}
   3cf1c:	e037883a 	mov	sp,fp
   3cf20:	dfc00117 	ldw	ra,4(sp)
   3cf24:	df000017 	ldw	fp,0(sp)
   3cf28:	dec00204 	addi	sp,sp,8
   3cf2c:	f800283a 	ret

0003cf30 <alt_read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
   3cf30:	defff904 	addi	sp,sp,-28
   3cf34:	dfc00615 	stw	ra,24(sp)
   3cf38:	df000515 	stw	fp,20(sp)
   3cf3c:	df000504 	addi	fp,sp,20
   3cf40:	e13ffd15 	stw	r4,-12(fp)
   3cf44:	e17ffe15 	stw	r5,-8(fp)
   3cf48:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   3cf4c:	e0bffd17 	ldw	r2,-12(fp)
   3cf50:	10000616 	blt	r2,zero,3cf6c <alt_read+0x3c>
   3cf54:	e0bffd17 	ldw	r2,-12(fp)
   3cf58:	10c00324 	muli	r3,r2,12
   3cf5c:	00800134 	movhi	r2,4
   3cf60:	108f5b04 	addi	r2,r2,15724
   3cf64:	1885883a 	add	r2,r3,r2
   3cf68:	00000106 	br	3cf70 <alt_read+0x40>
   3cf6c:	0005883a 	mov	r2,zero
   3cf70:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
   3cf74:	e0bffb17 	ldw	r2,-20(fp)
   3cf78:	10002026 	beq	r2,zero,3cffc <alt_read+0xcc>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
   3cf7c:	e0bffb17 	ldw	r2,-20(fp)
   3cf80:	10800217 	ldw	r2,8(r2)
   3cf84:	108000cc 	andi	r2,r2,3
   3cf88:	10800060 	cmpeqi	r2,r2,1
   3cf8c:	1000171e 	bne	r2,zero,3cfec <alt_read+0xbc>
        (fd->dev->read))
   3cf90:	e0bffb17 	ldw	r2,-20(fp)
   3cf94:	10800017 	ldw	r2,0(r2)
   3cf98:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
   3cf9c:	10001326 	beq	r2,zero,3cfec <alt_read+0xbc>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
   3cfa0:	e0bffb17 	ldw	r2,-20(fp)
   3cfa4:	10800017 	ldw	r2,0(r2)
   3cfa8:	10c00517 	ldw	r3,20(r2)
   3cfac:	e0bfff17 	ldw	r2,-4(fp)
   3cfb0:	e13ffb17 	ldw	r4,-20(fp)
   3cfb4:	e17ffe17 	ldw	r5,-8(fp)
   3cfb8:	100d883a 	mov	r6,r2
   3cfbc:	183ee83a 	callr	r3
   3cfc0:	e0bffc15 	stw	r2,-16(fp)
   3cfc4:	e0bffc17 	ldw	r2,-16(fp)
   3cfc8:	1000060e 	bge	r2,zero,3cfe4 <alt_read+0xb4>
        {
          ALT_ERRNO = -rval;
   3cfcc:	003cee00 	call	3cee0 <alt_get_errno>
   3cfd0:	e0fffc17 	ldw	r3,-16(fp)
   3cfd4:	00c7c83a 	sub	r3,zero,r3
   3cfd8:	10c00015 	stw	r3,0(r2)
          return -1;
   3cfdc:	00bfffc4 	movi	r2,-1
   3cfe0:	00000a06 	br	3d00c <alt_read+0xdc>
        }
        return rval;
   3cfe4:	e0bffc17 	ldw	r2,-16(fp)
   3cfe8:	00000806 	br	3d00c <alt_read+0xdc>
      }
      else
      {
        ALT_ERRNO = EACCES;
   3cfec:	003cee00 	call	3cee0 <alt_get_errno>
   3cff0:	00c00344 	movi	r3,13
   3cff4:	10c00015 	stw	r3,0(r2)
   3cff8:	00000306 	br	3d008 <alt_read+0xd8>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
   3cffc:	003cee00 	call	3cee0 <alt_get_errno>
   3d000:	00c01444 	movi	r3,81
   3d004:	10c00015 	stw	r3,0(r2)
  }
  return -1;
   3d008:	00bfffc4 	movi	r2,-1
}
   3d00c:	e037883a 	mov	sp,fp
   3d010:	dfc00117 	ldw	ra,4(sp)
   3d014:	df000017 	ldw	fp,0(sp)
   3d018:	dec00204 	addi	sp,sp,8
   3d01c:	f800283a 	ret

0003d020 <alt_remap_uncached>:
 * Convert a pointer to a block of cached memory, into a block of
 * uncached memory.
 */

volatile void* alt_remap_uncached (void* ptr, alt_u32 len)
{
   3d020:	defffc04 	addi	sp,sp,-16
   3d024:	dfc00315 	stw	ra,12(sp)
   3d028:	df000215 	stw	fp,8(sp)
   3d02c:	df000204 	addi	fp,sp,8
   3d030:	e13ffe15 	stw	r4,-8(fp)
   3d034:	e17fff15 	stw	r5,-4(fp)
  alt_dcache_flush (ptr, len);
   3d038:	e13ffe17 	ldw	r4,-8(fp)
   3d03c:	e17fff17 	ldw	r5,-4(fp)
   3d040:	003c77c0 	call	3c77c <alt_dcache_flush>
  return (volatile void*) (((alt_u32) ptr) | BYPASS_DCACHE_MASK);
   3d044:	e0bffe17 	ldw	r2,-8(fp)
   3d048:	10a00034 	orhi	r2,r2,32768
}
   3d04c:	e037883a 	mov	sp,fp
   3d050:	dfc00117 	ldw	ra,4(sp)
   3d054:	df000017 	ldw	fp,0(sp)
   3d058:	dec00204 	addi	sp,sp,8
   3d05c:	f800283a 	ret

0003d060 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
   3d060:	defff904 	addi	sp,sp,-28
   3d064:	df000615 	stw	fp,24(sp)
   3d068:	df000604 	addi	fp,sp,24
   3d06c:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   3d070:	0005303a 	rdctl	r2,status
   3d074:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   3d078:	e0fffb17 	ldw	r3,-20(fp)
   3d07c:	00bfff84 	movi	r2,-2
   3d080:	1884703a 	and	r2,r3,r2
   3d084:	1001703a 	wrctl	status,r2
  
  return context;
   3d088:	e0bffb17 	ldw	r2,-20(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
   3d08c:	e0bffa15 	stw	r2,-24(fp)
  alt_llist_remove (&alarm->llist);
   3d090:	e0bfff17 	ldw	r2,-4(fp)
   3d094:	e0bffc15 	stw	r2,-16(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
   3d098:	e0bffc17 	ldw	r2,-16(fp)
   3d09c:	10800017 	ldw	r2,0(r2)
   3d0a0:	e0fffc17 	ldw	r3,-16(fp)
   3d0a4:	18c00117 	ldw	r3,4(r3)
   3d0a8:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
   3d0ac:	e0bffc17 	ldw	r2,-16(fp)
   3d0b0:	10800117 	ldw	r2,4(r2)
   3d0b4:	e0fffc17 	ldw	r3,-16(fp)
   3d0b8:	18c00017 	ldw	r3,0(r3)
   3d0bc:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
   3d0c0:	e0bffc17 	ldw	r2,-16(fp)
   3d0c4:	e0fffc17 	ldw	r3,-16(fp)
   3d0c8:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
   3d0cc:	e0bffc17 	ldw	r2,-16(fp)
   3d0d0:	e0fffc17 	ldw	r3,-16(fp)
   3d0d4:	10c00015 	stw	r3,0(r2)
   3d0d8:	e0bffa17 	ldw	r2,-24(fp)
   3d0dc:	e0bffd15 	stw	r2,-12(fp)
{
#if (NIOS2_NUM_OF_SHADOW_REG_SETS > 0) || (defined NIOS2_EIC_PRESENT) || \
    (defined NIOS2_MMU_PRESENT) || (defined NIOS2_MPU_PRESENT)
  alt_irq_context status;
  
  NIOS2_READ_STATUS (status);
   3d0e0:	0005303a 	rdctl	r2,status
   3d0e4:	e0bffe15 	stw	r2,-8(fp)
  
  status &= ~NIOS2_STATUS_PIE_MSK;
   3d0e8:	e0fffe17 	ldw	r3,-8(fp)
   3d0ec:	00bfff84 	movi	r2,-2
   3d0f0:	1884703a 	and	r2,r3,r2
   3d0f4:	e0bffe15 	stw	r2,-8(fp)
  status |= (context & NIOS2_STATUS_PIE_MSK);
   3d0f8:	e0bffd17 	ldw	r2,-12(fp)
   3d0fc:	1080004c 	andi	r2,r2,1
   3d100:	e0fffe17 	ldw	r3,-8(fp)
   3d104:	1884b03a 	or	r2,r3,r2
   3d108:	e0bffe15 	stw	r2,-8(fp)
  
  NIOS2_WRITE_STATUS (status);
   3d10c:	e0bffe17 	ldw	r2,-8(fp)
   3d110:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
   3d114:	e037883a 	mov	sp,fp
   3d118:	df000017 	ldw	fp,0(sp)
   3d11c:	dec00104 	addi	sp,sp,4
   3d120:	f800283a 	ret

0003d124 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
   3d124:	defffb04 	addi	sp,sp,-20
   3d128:	dfc00415 	stw	ra,16(sp)
   3d12c:	df000315 	stw	fp,12(sp)
   3d130:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
   3d134:	d0a02017 	ldw	r2,-32640(gp)
   3d138:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
   3d13c:	d0a95117 	ldw	r2,-23228(gp)
   3d140:	10800044 	addi	r2,r2,1
   3d144:	d0a95115 	stw	r2,-23228(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
   3d148:	00002e06 	br	3d204 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
   3d14c:	e0bffd17 	ldw	r2,-12(fp)
   3d150:	10800017 	ldw	r2,0(r2)
   3d154:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
   3d158:	e0bffd17 	ldw	r2,-12(fp)
   3d15c:	10800403 	ldbu	r2,16(r2)
   3d160:	10803fcc 	andi	r2,r2,255
   3d164:	10000426 	beq	r2,zero,3d178 <alt_tick+0x54>
   3d168:	d0a95117 	ldw	r2,-23228(gp)
   3d16c:	1000021e 	bne	r2,zero,3d178 <alt_tick+0x54>
    {
      alarm->rollover = 0;
   3d170:	e0bffd17 	ldw	r2,-12(fp)
   3d174:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
   3d178:	e0bffd17 	ldw	r2,-12(fp)
   3d17c:	10800217 	ldw	r2,8(r2)
   3d180:	d0e95117 	ldw	r3,-23228(gp)
   3d184:	18801d36 	bltu	r3,r2,3d1fc <alt_tick+0xd8>
   3d188:	e0bffd17 	ldw	r2,-12(fp)
   3d18c:	10800403 	ldbu	r2,16(r2)
   3d190:	10803fcc 	andi	r2,r2,255
   3d194:	1000191e 	bne	r2,zero,3d1fc <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
   3d198:	e0bffd17 	ldw	r2,-12(fp)
   3d19c:	10c00317 	ldw	r3,12(r2)
   3d1a0:	e0bffd17 	ldw	r2,-12(fp)
   3d1a4:	10800517 	ldw	r2,20(r2)
   3d1a8:	1009883a 	mov	r4,r2
   3d1ac:	183ee83a 	callr	r3
   3d1b0:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
   3d1b4:	e0bfff17 	ldw	r2,-4(fp)
   3d1b8:	1000031e 	bne	r2,zero,3d1c8 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
   3d1bc:	e13ffd17 	ldw	r4,-12(fp)
   3d1c0:	003d0600 	call	3d060 <alt_alarm_stop>
   3d1c4:	00000d06 	br	3d1fc <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
   3d1c8:	e0bffd17 	ldw	r2,-12(fp)
   3d1cc:	10c00217 	ldw	r3,8(r2)
   3d1d0:	e0bfff17 	ldw	r2,-4(fp)
   3d1d4:	1887883a 	add	r3,r3,r2
   3d1d8:	e0bffd17 	ldw	r2,-12(fp)
   3d1dc:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
   3d1e0:	e0bffd17 	ldw	r2,-12(fp)
   3d1e4:	10c00217 	ldw	r3,8(r2)
   3d1e8:	d0a95117 	ldw	r2,-23228(gp)
   3d1ec:	1880032e 	bgeu	r3,r2,3d1fc <alt_tick+0xd8>
        {
          alarm->rollover = 1;
   3d1f0:	e0bffd17 	ldw	r2,-12(fp)
   3d1f4:	00c00044 	movi	r3,1
   3d1f8:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
   3d1fc:	e0bffe17 	ldw	r2,-8(fp)
   3d200:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
   3d204:	e0fffd17 	ldw	r3,-12(fp)
   3d208:	d0a02004 	addi	r2,gp,-32640
   3d20c:	18bfcf1e 	bne	r3,r2,3d14c <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
   3d210:	003c39c0 	call	3c39c <vPortSysTickHandler>
}
   3d214:	e037883a 	mov	sp,fp
   3d218:	dfc00117 	ldw	ra,4(sp)
   3d21c:	df000017 	ldw	fp,0(sp)
   3d220:	dec00204 	addi	sp,sp,8
   3d224:	f800283a 	ret

0003d228 <alt_uncached_malloc>:
/*
 * Allocate a block of uncached memory.
 */

volatile void* alt_uncached_malloc (size_t size)
{
   3d228:	defffc04 	addi	sp,sp,-16
   3d22c:	dfc00315 	stw	ra,12(sp)
   3d230:	df000215 	stw	fp,8(sp)
   3d234:	df000204 	addi	fp,sp,8
   3d238:	e13fff15 	stw	r4,-4(fp)
  void* ptr;

  ptr = malloc (size);
   3d23c:	e13fff17 	ldw	r4,-4(fp)
   3d240:	003f1fc0 	call	3f1fc <malloc>
   3d244:	e0bffe15 	stw	r2,-8(fp)

  alt_dcache_flush (ptr, size);
   3d248:	e13ffe17 	ldw	r4,-8(fp)
   3d24c:	e17fff17 	ldw	r5,-4(fp)
   3d250:	003c77c0 	call	3c77c <alt_dcache_flush>

  return ptr ? (volatile void*) (((alt_u32) ptr) | BYPASS_DCACHE_MASK) : NULL;
   3d254:	e0bffe17 	ldw	r2,-8(fp)
   3d258:	10000326 	beq	r2,zero,3d268 <alt_uncached_malloc+0x40>
   3d25c:	e0bffe17 	ldw	r2,-8(fp)
   3d260:	10a00034 	orhi	r2,r2,32768
   3d264:	00000106 	br	3d26c <alt_uncached_malloc+0x44>
   3d268:	0005883a 	mov	r2,zero
}
   3d26c:	e037883a 	mov	sp,fp
   3d270:	dfc00117 	ldw	ra,4(sp)
   3d274:	df000017 	ldw	fp,0(sp)
   3d278:	dec00204 	addi	sp,sp,8
   3d27c:	f800283a 	ret

0003d280 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
   3d280:	defffe04 	addi	sp,sp,-8
   3d284:	dfc00115 	stw	ra,4(sp)
   3d288:	df000015 	stw	fp,0(sp)
   3d28c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
   3d290:	00800134 	movhi	r2,4
   3d294:	1095d904 	addi	r2,r2,22372
   3d298:	10800017 	ldw	r2,0(r2)
   3d29c:	10000526 	beq	r2,zero,3d2b4 <alt_get_errno+0x34>
   3d2a0:	00800134 	movhi	r2,4
   3d2a4:	1095d904 	addi	r2,r2,22372
   3d2a8:	10800017 	ldw	r2,0(r2)
   3d2ac:	103ee83a 	callr	r2
   3d2b0:	00000206 	br	3d2bc <alt_get_errno+0x3c>
   3d2b4:	00800134 	movhi	r2,4
   3d2b8:	109ebe04 	addi	r2,r2,31480
}
   3d2bc:	e037883a 	mov	sp,fp
   3d2c0:	dfc00117 	ldw	ra,4(sp)
   3d2c4:	df000017 	ldw	fp,0(sp)
   3d2c8:	dec00204 	addi	sp,sp,8
   3d2cc:	f800283a 	ret

0003d2d0 <alt_write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
   3d2d0:	defff904 	addi	sp,sp,-28
   3d2d4:	dfc00615 	stw	ra,24(sp)
   3d2d8:	df000515 	stw	fp,20(sp)
   3d2dc:	df000504 	addi	fp,sp,20
   3d2e0:	e13ffd15 	stw	r4,-12(fp)
   3d2e4:	e17ffe15 	stw	r5,-8(fp)
   3d2e8:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
   3d2ec:	e0bffd17 	ldw	r2,-12(fp)
   3d2f0:	10000616 	blt	r2,zero,3d30c <alt_write+0x3c>
   3d2f4:	e0bffd17 	ldw	r2,-12(fp)
   3d2f8:	10c00324 	muli	r3,r2,12
   3d2fc:	00800134 	movhi	r2,4
   3d300:	108f5b04 	addi	r2,r2,15724
   3d304:	1885883a 	add	r2,r3,r2
   3d308:	00000106 	br	3d310 <alt_write+0x40>
   3d30c:	0005883a 	mov	r2,zero
   3d310:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
   3d314:	e0bffb17 	ldw	r2,-20(fp)
   3d318:	10001f26 	beq	r2,zero,3d398 <alt_write+0xc8>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
   3d31c:	e0bffb17 	ldw	r2,-20(fp)
   3d320:	10800217 	ldw	r2,8(r2)
   3d324:	108000cc 	andi	r2,r2,3
   3d328:	10001726 	beq	r2,zero,3d388 <alt_write+0xb8>
   3d32c:	e0bffb17 	ldw	r2,-20(fp)
   3d330:	10800017 	ldw	r2,0(r2)
   3d334:	10800617 	ldw	r2,24(r2)
   3d338:	10001326 	beq	r2,zero,3d388 <alt_write+0xb8>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
   3d33c:	e0bffb17 	ldw	r2,-20(fp)
   3d340:	10800017 	ldw	r2,0(r2)
   3d344:	10c00617 	ldw	r3,24(r2)
   3d348:	e0bfff17 	ldw	r2,-4(fp)
   3d34c:	e13ffb17 	ldw	r4,-20(fp)
   3d350:	e17ffe17 	ldw	r5,-8(fp)
   3d354:	100d883a 	mov	r6,r2
   3d358:	183ee83a 	callr	r3
   3d35c:	e0bffc15 	stw	r2,-16(fp)
   3d360:	e0bffc17 	ldw	r2,-16(fp)
   3d364:	1000060e 	bge	r2,zero,3d380 <alt_write+0xb0>
      {
        ALT_ERRNO = -rval;
   3d368:	003d2800 	call	3d280 <alt_get_errno>
   3d36c:	e0fffc17 	ldw	r3,-16(fp)
   3d370:	00c7c83a 	sub	r3,zero,r3
   3d374:	10c00015 	stw	r3,0(r2)
        return -1;
   3d378:	00bfffc4 	movi	r2,-1
   3d37c:	00000a06 	br	3d3a8 <alt_write+0xd8>
      }
      return rval;
   3d380:	e0bffc17 	ldw	r2,-16(fp)
   3d384:	00000806 	br	3d3a8 <alt_write+0xd8>
    }
    else
    {
      ALT_ERRNO = EACCES;
   3d388:	003d2800 	call	3d280 <alt_get_errno>
   3d38c:	00c00344 	movi	r3,13
   3d390:	10c00015 	stw	r3,0(r2)
   3d394:	00000306 	br	3d3a4 <alt_write+0xd4>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
   3d398:	003d2800 	call	3d280 <alt_get_errno>
   3d39c:	00c01444 	movi	r3,81
   3d3a0:	10c00015 	stw	r3,0(r2)
  }
  return -1;
   3d3a4:	00bfffc4 	movi	r2,-1
}
   3d3a8:	e037883a 	mov	sp,fp
   3d3ac:	dfc00117 	ldw	ra,4(sp)
   3d3b0:	df000017 	ldw	fp,0(sp)
   3d3b4:	dec00204 	addi	sp,sp,8
   3d3b8:	f800283a 	ret

0003d3bc <low_level_init>:
 * @param netif the already initialized lwip network interface structure
 *        for this ethernetif
 */
static void
low_level_init(struct netif *netif)
{
   3d3bc:	defffc04 	addi	sp,sp,-16
   3d3c0:	dfc00315 	stw	ra,12(sp)
   3d3c4:	df000215 	stw	fp,8(sp)
   3d3c8:	df000204 	addi	fp,sp,8
   3d3cc:	e13fff15 	stw	r4,-4(fp)
	struct ethernetif *ethernetif = netif->state;
   3d3d0:	e0bfff17 	ldw	r2,-4(fp)
   3d3d4:	10800917 	ldw	r2,36(r2)
   3d3d8:	e0bffe15 	stw	r2,-8(fp)

	/* set MAC hardware address length */
	netif->hwaddr_len = ETHARP_HWADDR_LEN;
   3d3dc:	e0bfff17 	ldw	r2,-4(fp)
   3d3e0:	00c00184 	movi	r3,6
   3d3e4:	10c00c85 	stb	r3,50(r2)

	/* maximum transfer unit */
	netif->mtu = IP_FRAG_MAX_MTU;
   3d3e8:	e0bfff17 	ldw	r2,-4(fp)
   3d3ec:	00c17704 	movi	r3,1500
   3d3f0:	10c00c0d 	sth	r3,48(r2)

	/* device capabilities */
	/* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
	netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
   3d3f4:	e0bfff17 	ldw	r2,-4(fp)
   3d3f8:	00c00c84 	movi	r3,50
   3d3fc:	10c00e45 	stb	r3,57(r2)

	tse_mac_init(netif->num, ethernetif);
   3d400:	e0bfff17 	ldw	r2,-4(fp)
   3d404:	10800f03 	ldbu	r2,60(r2)
   3d408:	10803fcc 	andi	r2,r2,255
   3d40c:	1009883a 	mov	r4,r2
   3d410:	e17ffe17 	ldw	r5,-8(fp)
   3d414:	001a4840 	call	1a484 <tse_mac_init>
}
   3d418:	e037883a 	mov	sp,fp
   3d41c:	dfc00117 	ldw	ra,4(sp)
   3d420:	df000017 	ldw	fp,0(sp)
   3d424:	dec00204 	addi	sp,sp,8
   3d428:	f800283a 	ret

0003d42c <low_level_input>:
 * @return a pbuf filled with the received packet (including MAC header)
 *         NULL on memory error
 */
static struct pbuf *
low_level_input(struct netif *netif)
{
   3d42c:	defffa04 	addi	sp,sp,-24
   3d430:	dfc00515 	stw	ra,20(sp)
   3d434:	df000415 	stw	fp,16(sp)
   3d438:	df000404 	addi	fp,sp,16
   3d43c:	e13fff15 	stw	r4,-4(fp)
	struct ethernetif *ethernetif = netif->state;
   3d440:	e0bfff17 	ldw	r2,-4(fp)
   3d444:	10800917 	ldw	r2,36(r2)
   3d448:	e0bffd15 	stw	r2,-12(fp)
	struct pbuf *p, *nextPkt;

	if(ethernetif->lwipRxCount <= 0)
   3d44c:	e0bffd17 	ldw	r2,-12(fp)
   3d450:	10801517 	ldw	r2,84(r2)
   3d454:	00800216 	blt	zero,r2,3d460 <low_level_input+0x34>
		return NULL;
   3d458:	0005883a 	mov	r2,zero
   3d45c:	00004a06 	br	3d588 <low_level_input+0x15c>

	//  Dump current packet if there is no memory for the next packet.
	//  The lwipRxPbuf must contain pointers to pbufs at all times.
	nextPkt = pbuf_alloc(PBUF_RAW,  PBUF_POOL_BUFSIZE, PBUF_POOL);
   3d460:	010000c4 	movi	r4,3
   3d464:	01417b04 	movi	r5,1516
   3d468:	018000c4 	movi	r6,3
   3d46c:	0022fa00 	call	22fa0 <pbuf_alloc>
   3d470:	e0bffe15 	stw	r2,-8(fp)
	if(nextPkt == NULL)
   3d474:	e0bffe17 	ldw	r2,-8(fp)
   3d478:	1000101e 	bne	r2,zero,3d4bc <low_level_input+0x90>
	{
		LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("no pbuf available\n"));

		LINK_STATS_INC(link.memerr);
   3d47c:	008001f4 	movhi	r2,7
   3d480:	10ac6e04 	addi	r2,r2,-20040
   3d484:	10800617 	ldw	r2,24(r2)
   3d488:	10c00044 	addi	r3,r2,1
   3d48c:	008001f4 	movhi	r2,7
   3d490:	10ac6e04 	addi	r2,r2,-20040
   3d494:	10c00615 	stw	r3,24(r2)
		LINK_STATS_INC(link.drop);
   3d498:	008001f4 	movhi	r2,7
   3d49c:	10ac6e04 	addi	r2,r2,-20040
   3d4a0:	10800317 	ldw	r2,12(r2)
   3d4a4:	10c00044 	addi	r3,r2,1
   3d4a8:	008001f4 	movhi	r2,7
   3d4ac:	10ac6e04 	addi	r2,r2,-20040
   3d4b0:	10c00315 	stw	r3,12(r2)
		return NULL;
   3d4b4:	0005883a 	mov	r2,zero
   3d4b8:	00003306 	br	3d588 <low_level_input+0x15c>
	}

	nextPkt = (void *) alt_remap_uncached(nextPkt,sizeof *nextPkt);
   3d4bc:	e13ffe17 	ldw	r4,-8(fp)
   3d4c0:	01400404 	movi	r5,16
   3d4c4:	003d0200 	call	3d020 <alt_remap_uncached>
   3d4c8:	e0bffe15 	stw	r2,-8(fp)
	nextPkt->payload = (void *) alt_remap_uncached(nextPkt->payload, PBUF_POOL_BUFSIZE);
   3d4cc:	e0bffe17 	ldw	r2,-8(fp)
   3d4d0:	10800117 	ldw	r2,4(r2)
   3d4d4:	1009883a 	mov	r4,r2
   3d4d8:	01417b04 	movi	r5,1516
   3d4dc:	003d0200 	call	3d020 <alt_remap_uncached>
   3d4e0:	e0fffe17 	ldw	r3,-8(fp)
   3d4e4:	18800115 	stw	r2,4(r3)

	enh_alt_irq_disable_all();
   3d4e8:	003c1b40 	call	3c1b4 <enh_alt_irq_disable_all>

	p = ethernetif->lwipRxPbuf[ethernetif->lwipRxIndex];
   3d4ec:	e0bffd17 	ldw	r2,-12(fp)
   3d4f0:	10801417 	ldw	r2,80(r2)
   3d4f4:	e0fffd17 	ldw	r3,-12(fp)
   3d4f8:	108001c4 	addi	r2,r2,7
   3d4fc:	1085883a 	add	r2,r2,r2
   3d500:	1085883a 	add	r2,r2,r2
   3d504:	1885883a 	add	r2,r3,r2
   3d508:	10800017 	ldw	r2,0(r2)
   3d50c:	e0bffc15 	stw	r2,-16(fp)
	ethernetif->lwipRxPbuf[ethernetif->lwipRxIndex] = nextPkt;
   3d510:	e0bffd17 	ldw	r2,-12(fp)
   3d514:	10801417 	ldw	r2,80(r2)
   3d518:	e0fffd17 	ldw	r3,-12(fp)
   3d51c:	108001c4 	addi	r2,r2,7
   3d520:	1085883a 	add	r2,r2,r2
   3d524:	1085883a 	add	r2,r2,r2
   3d528:	1885883a 	add	r2,r3,r2
   3d52c:	e0fffe17 	ldw	r3,-8(fp)
   3d530:	10c00015 	stw	r3,0(r2)
	if(++ethernetif->lwipRxIndex >= LWIP_RX_ETH_BUFFER)
   3d534:	e0bffd17 	ldw	r2,-12(fp)
   3d538:	10801417 	ldw	r2,80(r2)
   3d53c:	10800044 	addi	r2,r2,1
   3d540:	e0fffd17 	ldw	r3,-12(fp)
   3d544:	18801415 	stw	r2,80(r3)
   3d548:	10800310 	cmplti	r2,r2,12
   3d54c:	1000021e 	bne	r2,zero,3d558 <low_level_input+0x12c>
		ethernetif->lwipRxIndex = 0;
   3d550:	e0bffd17 	ldw	r2,-12(fp)
   3d554:	10001415 	stw	zero,80(r2)

	--ethernetif->lwipRxCount;
   3d558:	e0bffd17 	ldw	r2,-12(fp)
   3d55c:	10801517 	ldw	r2,84(r2)
   3d560:	10ffffc4 	addi	r3,r2,-1
   3d564:	e0bffd17 	ldw	r2,-12(fp)
   3d568:	10c01515 	stw	r3,84(r2)

	enh_alt_irq_enable_all();
   3d56c:	003c2000 	call	3c200 <enh_alt_irq_enable_all>

	LWIP_ASSERT("low_level_input: pbuf in rx buffer is NULL", p != NULL );
	LWIP_ASSERT("low_level_input: pbuf->len in rx buffer is 0", p->len != 0 );

	if( p->len == 0 )
   3d570:	e0bffc17 	ldw	r2,-16(fp)
   3d574:	1080028b 	ldhu	r2,10(r2)
   3d578:	10bfffcc 	andi	r2,r2,65535
   3d57c:	1000011e 	bne	r2,zero,3d584 <low_level_input+0x158>
		p = NULL;
   3d580:	e03ffc15 	stw	zero,-16(fp)

	return p;
   3d584:	e0bffc17 	ldw	r2,-16(fp)
}
   3d588:	e037883a 	mov	sp,fp
   3d58c:	dfc00117 	ldw	ra,4(sp)
   3d590:	df000017 	ldw	fp,0(sp)
   3d594:	dec00204 	addi	sp,sp,8
   3d598:	f800283a 	ret

0003d59c <ethernetif_input>:
 *
 * @param netif the lwip network interface structure for this ethernetif
 */
int
ethernetif_input(struct netif *netif)
{
   3d59c:	defffa04 	addi	sp,sp,-24
   3d5a0:	dfc00515 	stw	ra,20(sp)
   3d5a4:	df000415 	stw	fp,16(sp)
   3d5a8:	df000404 	addi	fp,sp,16
   3d5ac:	e13fff15 	stw	r4,-4(fp)
	struct ethernetif *ethernetif;
	struct eth_hdr *ethhdr;
	struct pbuf *p;

	ethernetif = netif->state;
   3d5b0:	e0bfff17 	ldw	r2,-4(fp)
   3d5b4:	10800917 	ldw	r2,36(r2)
   3d5b8:	e0bffc15 	stw	r2,-16(fp)

	/* move received packet into a new pbuf */
	p = low_level_input(netif);
   3d5bc:	e13fff17 	ldw	r4,-4(fp)
   3d5c0:	003d42c0 	call	3d42c <low_level_input>
   3d5c4:	e0bffd15 	stw	r2,-12(fp)

	/* no packet could be read, silently ignore this */
	if (p == NULL) return -1;
   3d5c8:	e0bffd17 	ldw	r2,-12(fp)
   3d5cc:	1000021e 	bne	r2,zero,3d5d8 <ethernetif_input+0x3c>
   3d5d0:	00bfffc4 	movi	r2,-1
   3d5d4:	00002b06 	br	3d684 <ethernetif_input+0xe8>

	/* points to packet payload, which starts with an Ethernet header */
	ethhdr = p->payload;
   3d5d8:	e0bffd17 	ldw	r2,-12(fp)
   3d5dc:	10800117 	ldw	r2,4(r2)
   3d5e0:	e0bffe15 	stw	r2,-8(fp)

	LINK_STATS_INC(link.recv);
   3d5e4:	008001f4 	movhi	r2,7
   3d5e8:	10ac6e04 	addi	r2,r2,-20040
   3d5ec:	10800117 	ldw	r2,4(r2)
   3d5f0:	10c00044 	addi	r3,r2,1
   3d5f4:	008001f4 	movhi	r2,7
   3d5f8:	10ac6e04 	addi	r2,r2,-20040
   3d5fc:	10c00115 	stw	r3,4(r2)
		pbuf_free(p);
		p = NULL;
		break;
	}
#else
	switch (htons(ethhdr->type)) {
   3d600:	e0bffe17 	ldw	r2,-8(fp)
   3d604:	10c00383 	ldbu	r3,14(r2)
   3d608:	108003c3 	ldbu	r2,15(r2)
   3d60c:	1004923a 	slli	r2,r2,8
   3d610:	10c4b03a 	or	r2,r2,r3
   3d614:	10bfffcc 	andi	r2,r2,65535
   3d618:	1004d23a 	srli	r2,r2,8
   3d61c:	10ffffcc 	andi	r3,r2,65535
   3d620:	e0bffe17 	ldw	r2,-8(fp)
   3d624:	11000383 	ldbu	r4,14(r2)
   3d628:	108003c3 	ldbu	r2,15(r2)
   3d62c:	1004923a 	slli	r2,r2,8
   3d630:	1104b03a 	or	r2,r2,r4
   3d634:	10bfffcc 	andi	r2,r2,65535
   3d638:	1004923a 	slli	r2,r2,8
   3d63c:	10bfffcc 	andi	r2,r2,65535
   3d640:	1884b03a 	or	r2,r3,r2
   3d644:	10c20020 	cmpeqi	r3,r2,2048
   3d648:	1800021e 	bne	r3,zero,3d654 <ethernetif_input+0xb8>
   3d64c:	108201a0 	cmpeqi	r2,r2,2054
   3d650:	10000626 	beq	r2,zero,3d66c <ethernetif_input+0xd0>
#if PPPOE_SUPPORT
	/* PPPoE packet? */
	case ETHTYPE_PPPOEDISC:
	case ETHTYPE_PPPOE:
#endif /* PPPOE_SUPPORT */
		netif->input(p, netif);
   3d654:	e0bfff17 	ldw	r2,-4(fp)
   3d658:	10800417 	ldw	r2,16(r2)
   3d65c:	e13ffd17 	ldw	r4,-12(fp)
   3d660:	e17fff17 	ldw	r5,-4(fp)
   3d664:	103ee83a 	callr	r2
		break;
   3d668:	00000406 	br	3d67c <ethernetif_input+0xe0>

	default:
		pbuf_free( p );
   3d66c:	e13ffd17 	ldw	r4,-12(fp)
   3d670:	00237600 	call	23760 <pbuf_free>
		p = NULL;
   3d674:	e03ffd15 	stw	zero,-12(fp)
		break;
   3d678:	0001883a 	nop
	}
#endif

	// return the waiting packet count
	return ethernetif->lwipRxCount;
   3d67c:	e0bffc17 	ldw	r2,-16(fp)
   3d680:	10801517 	ldw	r2,84(r2)
}
   3d684:	e037883a 	mov	sp,fp
   3d688:	dfc00117 	ldw	ra,4(sp)
   3d68c:	df000017 	ldw	fp,0(sp)
   3d690:	dec00204 	addi	sp,sp,8
   3d694:	f800283a 	ret

0003d698 <ethernetif_init>:
 *         ERR_MEM if private data couldn't be allocated
 *         any other err_t on error
 */
err_t
ethernetif_init(struct netif *netif)
{
   3d698:	defff904 	addi	sp,sp,-28
   3d69c:	dfc00615 	stw	ra,24(sp)
   3d6a0:	df000515 	stw	fp,20(sp)
   3d6a4:	df000504 	addi	fp,sp,20
   3d6a8:	e13fff15 	stw	r4,-4(fp)
	err_t tse_mac_raw_send(struct netif *netif, struct pbuf *p);
	char *tmpptr;

	LWIP_ASSERT("netif != NULL", (netif != NULL));

	ethernetif = mem_malloc(sizeof(struct ethernetif));
   3d6ac:	01001804 	movi	r4,96
   3d6b0:	0021e680 	call	21e68 <mem_malloc>
   3d6b4:	e0bffc15 	stw	r2,-16(fp)
	if (ethernetif == NULL) {
   3d6b8:	e0bffc17 	ldw	r2,-16(fp)
   3d6bc:	1000021e 	bne	r2,zero,3d6c8 <ethernetif_init+0x30>
		LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("ethernetif_init: out of memory\n"));
		return ERR_MEM;
   3d6c0:	00bfffc4 	movi	r2,-1
   3d6c4:	00006206 	br	3d850 <ethernetif_init+0x1b8>
	}

#if LWIP_NETIF_HOSTNAME
	/* Initialize interface hostname */
	if (get_hostname(netif->num, (const char**)&tmpptr) == ERR_OK)
   3d6c8:	e0bfff17 	ldw	r2,-4(fp)
   3d6cc:	10800f03 	ldbu	r2,60(r2)
   3d6d0:	10c03fcc 	andi	r3,r2,255
   3d6d4:	e0bffe04 	addi	r2,fp,-8
   3d6d8:	1809883a 	mov	r4,r3
   3d6dc:	100b883a 	mov	r5,r2
   3d6e0:	00030c40 	call	30c4 <get_hostname>
   3d6e4:	1000041e 	bne	r2,zero,3d6f8 <ethernetif_init+0x60>
		netif->hostname = tmpptr;
   3d6e8:	e0fffe17 	ldw	r3,-8(fp)
   3d6ec:	e0bfff17 	ldw	r2,-4(fp)
   3d6f0:	10c00b15 	stw	r3,44(r2)
   3d6f4:	00000406 	br	3d708 <ethernetif_init+0x70>
	else
		netif->hostname = "lwip";
   3d6f8:	e0bfff17 	ldw	r2,-4(fp)
   3d6fc:	00c00134 	movhi	r3,4
   3d700:	18cca904 	addi	r3,r3,12964
   3d704:	10c00b15 	stw	r3,44(r2)
	 * of bits per second.
	 */
	NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, LINK_SPEED_OF_YOUR_NETIF_IN_BPS);

	// pointer abuse, don't worry ;)
	netif->state = ethernetif;
   3d708:	e0bfff17 	ldw	r2,-4(fp)
   3d70c:	e0fffc17 	ldw	r3,-16(fp)
   3d710:	10c00915 	stw	r3,36(r2)
	if (get_iface_name(netif->num, (char*)&tmpptr) == ERR_OK) {
   3d714:	e0bfff17 	ldw	r2,-4(fp)
   3d718:	10800f03 	ldbu	r2,60(r2)
   3d71c:	10c03fcc 	andi	r3,r2,255
   3d720:	e0bffe04 	addi	r2,fp,-8
   3d724:	1809883a 	mov	r4,r3
   3d728:	100b883a 	mov	r5,r2
   3d72c:	00030fc0 	call	30fc <get_iface_name>
   3d730:	1000081e 	bne	r2,zero,3d754 <ethernetif_init+0xbc>
		netif->name[0] = ((char*)&tmpptr)[0];
   3d734:	e0bffe04 	addi	r2,fp,-8
   3d738:	10c00003 	ldbu	r3,0(r2)
   3d73c:	e0bfff17 	ldw	r2,-4(fp)
   3d740:	10c00e85 	stb	r3,58(r2)
		netif->name[1] = ((char*)&tmpptr)[1];
   3d744:	e0fffe43 	ldbu	r3,-7(fp)
   3d748:	e0bfff17 	ldw	r2,-4(fp)
   3d74c:	10c00ec5 	stb	r3,59(r2)
   3d750:	00000606 	br	3d76c <ethernetif_init+0xd4>
	} else {
		netif->name[0] = 'e';
   3d754:	e0bfff17 	ldw	r2,-4(fp)
   3d758:	00c01944 	movi	r3,101
   3d75c:	10c00e85 	stb	r3,58(r2)
		netif->name[1] = 't';
   3d760:	e0bfff17 	ldw	r2,-4(fp)
   3d764:	00c01d04 	movi	r3,116
   3d768:	10c00ec5 	stb	r3,59(r2)

	/* We directly use etharp_output() here to save a function call.
	 * You can instead declare your own function an call etharp_output()
	 * from it if you have to do some checks before sending (e.g. if link
	 * is available...) */
	netif->output = etharp_output;
   3d76c:	e0bfff17 	ldw	r2,-4(fp)
   3d770:	00c000f4 	movhi	r3,3
   3d774:	18c2f004 	addi	r3,r3,3008
   3d778:	10c00515 	stw	r3,20(r2)
	netif->linkoutput = tse_mac_raw_send;
   3d77c:	e0bfff17 	ldw	r2,-4(fp)
   3d780:	00c000b4 	movhi	r3,2
   3d784:	18eb8404 	addi	r3,r3,-20976
   3d788:	10c00615 	stw	r3,24(r2)

	ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
   3d78c:	e0bfff17 	ldw	r2,-4(fp)
   3d790:	10c00cc4 	addi	r3,r2,51
   3d794:	e0bffc17 	ldw	r2,-16(fp)
   3d798:	10c00015 	stw	r3,0(r2)

	/* initialize the rx buffer for access by the TSE ISR */
	for(idx = 0; idx < LWIP_RX_ETH_BUFFER; ++idx)
   3d79c:	e03ffb15 	stw	zero,-20(fp)
   3d7a0:	00001f06 	br	3d820 <ethernetif_init+0x188>
	{
		p = pbuf_alloc(PBUF_RAW, PBUF_POOL_BUFSIZE, PBUF_POOL);
   3d7a4:	010000c4 	movi	r4,3
   3d7a8:	01417b04 	movi	r5,1516
   3d7ac:	018000c4 	movi	r6,3
   3d7b0:	0022fa00 	call	22fa0 <pbuf_alloc>
   3d7b4:	e0bffd15 	stw	r2,-12(fp)
		if (p == NULL)
   3d7b8:	e0bffd17 	ldw	r2,-12(fp)
   3d7bc:	1000021e 	bne	r2,zero,3d7c8 <ethernetif_init+0x130>
			return ERR_MEM;
   3d7c0:	00bfffc4 	movi	r2,-1
   3d7c4:	00002206 	br	3d850 <ethernetif_init+0x1b8>
		p = (void *) alt_remap_uncached(p,sizeof *p);
   3d7c8:	e13ffd17 	ldw	r4,-12(fp)
   3d7cc:	01400404 	movi	r5,16
   3d7d0:	003d0200 	call	3d020 <alt_remap_uncached>
   3d7d4:	e0bffd15 	stw	r2,-12(fp)
		p->payload = (void *) alt_remap_uncached(p->payload,PBUF_POOL_BUFSIZE);
   3d7d8:	e0bffd17 	ldw	r2,-12(fp)
   3d7dc:	10800117 	ldw	r2,4(r2)
   3d7e0:	1009883a 	mov	r4,r2
   3d7e4:	01417b04 	movi	r5,1516
   3d7e8:	003d0200 	call	3d020 <alt_remap_uncached>
   3d7ec:	e0fffd17 	ldw	r3,-12(fp)
   3d7f0:	18800115 	stw	r2,4(r3)
		ethernetif->lwipRxPbuf[idx] = p;
   3d7f4:	e0fffc17 	ldw	r3,-16(fp)
   3d7f8:	e0bffb17 	ldw	r2,-20(fp)
   3d7fc:	108001c4 	addi	r2,r2,7
   3d800:	1085883a 	add	r2,r2,r2
   3d804:	1085883a 	add	r2,r2,r2
   3d808:	1885883a 	add	r2,r3,r2
   3d80c:	e0fffd17 	ldw	r3,-12(fp)
   3d810:	10c00015 	stw	r3,0(r2)
	netif->linkoutput = tse_mac_raw_send;

	ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);

	/* initialize the rx buffer for access by the TSE ISR */
	for(idx = 0; idx < LWIP_RX_ETH_BUFFER; ++idx)
   3d814:	e0bffb17 	ldw	r2,-20(fp)
   3d818:	10800044 	addi	r2,r2,1
   3d81c:	e0bffb15 	stw	r2,-20(fp)
   3d820:	e0bffb17 	ldw	r2,-20(fp)
   3d824:	10800310 	cmplti	r2,r2,12
   3d828:	103fde1e 	bne	r2,zero,3d7a4 <ethernetif_init+0x10c>
			return ERR_MEM;
		p = (void *) alt_remap_uncached(p,sizeof *p);
		p->payload = (void *) alt_remap_uncached(p->payload,PBUF_POOL_BUFSIZE);
		ethernetif->lwipRxPbuf[idx] = p;
	}
	ethernetif->lwipRxCount = 0;
   3d82c:	e0bffc17 	ldw	r2,-16(fp)
   3d830:	10001515 	stw	zero,84(r2)
	ethernetif->lwipRxIndex = 0;
   3d834:	e0bffc17 	ldw	r2,-16(fp)
   3d838:	10001415 	stw	zero,80(r2)
	ethernetif->lwipRxIndexIsr = 0;
   3d83c:	e0bffc17 	ldw	r2,-16(fp)
   3d840:	10001315 	stw	zero,76(r2)

	/* initialize the low level hardware */
	low_level_init(netif);
   3d844:	e13fff17 	ldw	r4,-4(fp)
   3d848:	003d3bc0 	call	3d3bc <low_level_init>

	return ERR_OK;
   3d84c:	0005883a 	mov	r2,zero
}
   3d850:	e037883a 	mov	sp,fp
   3d854:	dfc00117 	ldw	ra,4(sp)
   3d858:	df000017 	ldw	fp,0(sp)
   3d85c:	dec00204 	addi	sp,sp,8
   3d860:	f800283a 	ret

0003d864 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
   3d864:	defff304 	addi	sp,sp,-52
   3d868:	dfc00c15 	stw	ra,48(sp)
   3d86c:	df000b15 	stw	fp,44(sp)
   3d870:	df000b04 	addi	fp,sp,44
   3d874:	e13ffe15 	stw	r4,-8(fp)
   3d878:	e17fff15 	stw	r5,-4(fp)
#endif /* LWIP_DEBUG */
  struct icmp_echo_hdr *iecho;
  struct ip_hdr *iphdr;
  s16_t hlen;

  ICMP_STATS_INC(icmp.recv);
   3d87c:	008001f4 	movhi	r2,7
   3d880:	10ac6e04 	addi	r2,r2,-20040
   3d884:	10803117 	ldw	r2,196(r2)
   3d888:	10c00044 	addi	r3,r2,1
   3d88c:	008001f4 	movhi	r2,7
   3d890:	10ac6e04 	addi	r2,r2,-20040
   3d894:	10c03115 	stw	r3,196(r2)
  snmp_inc_icmpinmsgs();


  iphdr = (struct ip_hdr *)p->payload;
   3d898:	e0bffe17 	ldw	r2,-8(fp)
   3d89c:	10800117 	ldw	r2,4(r2)
   3d8a0:	e0bff815 	stw	r2,-32(fp)
  hlen = IPH_HL(iphdr) * 4;
   3d8a4:	e0bff817 	ldw	r2,-32(fp)
   3d8a8:	10800003 	ldbu	r2,0(r2)
   3d8ac:	10803fcc 	andi	r2,r2,255
   3d8b0:	108003cc 	andi	r2,r2,15
   3d8b4:	1085883a 	add	r2,r2,r2
   3d8b8:	1085883a 	add	r2,r2,r2
   3d8bc:	e0bffa0d 	sth	r2,-24(fp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
   3d8c0:	e0bffa0b 	ldhu	r2,-24(fp)
   3d8c4:	0085c83a 	sub	r2,zero,r2
   3d8c8:	10bfffcc 	andi	r2,r2,65535
   3d8cc:	10a0001c 	xori	r2,r2,32768
   3d8d0:	10a00004 	addi	r2,r2,-32768
   3d8d4:	e13ffe17 	ldw	r4,-8(fp)
   3d8d8:	100b883a 	mov	r5,r2
   3d8dc:	00235b00 	call	235b0 <pbuf_header>
   3d8e0:	10803fcc 	andi	r2,r2,255
   3d8e4:	1001291e 	bne	r2,zero,3dd8c <icmp_input+0x528>
   3d8e8:	e0bffe17 	ldw	r2,-8(fp)
   3d8ec:	1080020b 	ldhu	r2,8(r2)
   3d8f0:	10bfffcc 	andi	r2,r2,65535
   3d8f4:	10800130 	cmpltui	r2,r2,4
   3d8f8:	1001241e 	bne	r2,zero,3dd8c <icmp_input+0x528>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
   3d8fc:	e0bffe17 	ldw	r2,-8(fp)
   3d900:	10800117 	ldw	r2,4(r2)
   3d904:	10800003 	ldbu	r2,0(r2)
   3d908:	e0bffa85 	stb	r2,-22(fp)
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
   3d90c:	e0bffa83 	ldbu	r2,-22(fp)
   3d910:	10011726 	beq	r2,zero,3dd70 <icmp_input+0x50c>
   3d914:	10800220 	cmpeqi	r2,r2,8
   3d918:	10010626 	beq	r2,zero,3dd34 <icmp_input+0x4d0>
       (as obviously, an echo request has been sent, too). */
    break; 
  case ICMP_ECHO:
#if !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
    {
      int accepted = 1;
   3d91c:	00800044 	movi	r2,1
   3d920:	e0bff915 	stw	r2,-28(fp)
#if !LWIP_MULTICAST_PING
      /* multicast destination address? */
      if (ip_addr_ismulticast(&current_iphdr_dest)) {
   3d924:	00800134 	movhi	r2,4
   3d928:	109ee404 	addi	r2,r2,31632
   3d92c:	10800017 	ldw	r2,0(r2)
   3d930:	10803c0c 	andi	r2,r2,240
   3d934:	10803818 	cmpnei	r2,r2,224
   3d938:	1000011e 	bne	r2,zero,3d940 <icmp_input+0xdc>
        accepted = 0;
   3d93c:	e03ff915 	stw	zero,-28(fp)
      }
#endif /* LWIP_MULTICAST_PING */
#if !LWIP_BROADCAST_PING
      /* broadcast destination address? */
      if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
   3d940:	00800134 	movhi	r2,4
   3d944:	109ee404 	addi	r2,r2,31632
   3d948:	10800017 	ldw	r2,0(r2)
   3d94c:	1009883a 	mov	r4,r2
   3d950:	e17fff17 	ldw	r5,-4(fp)
   3d954:	001fa400 	call	1fa40 <ip4_addr_isbroadcast>
   3d958:	10803fcc 	andi	r2,r2,255
   3d95c:	10000126 	beq	r2,zero,3d964 <icmp_input+0x100>
        accepted = 0;
   3d960:	e03ff915 	stw	zero,-28(fp)
      }
#endif /* LWIP_BROADCAST_PING */
      /* broadcast or multicast destination address not acceptd? */
      if (!accepted) {
   3d964:	e0bff917 	ldw	r2,-28(fp)
   3d968:	10000a1e 	bne	r2,zero,3d994 <icmp_input+0x130>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
        ICMP_STATS_INC(icmp.err);
   3d96c:	008001f4 	movhi	r2,7
   3d970:	10ac6e04 	addi	r2,r2,-20040
   3d974:	10803a17 	ldw	r2,232(r2)
   3d978:	10c00044 	addi	r3,r2,1
   3d97c:	008001f4 	movhi	r2,7
   3d980:	10ac6e04 	addi	r2,r2,-20040
   3d984:	10c03a15 	stw	r3,232(r2)
        pbuf_free(p);
   3d988:	e13ffe17 	ldw	r4,-8(fp)
   3d98c:	00237600 	call	23760 <pbuf_free>
        return;
   3d990:	00011b06 	br	3de00 <icmp_input+0x59c>
      }
    }
#endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
   3d994:	e0bffe17 	ldw	r2,-8(fp)
   3d998:	1080020b 	ldhu	r2,8(r2)
   3d99c:	10bfffcc 	andi	r2,r2,65535
   3d9a0:	10800228 	cmpgeui	r2,r2,8
   3d9a4:	1000f826 	beq	r2,zero,3dd88 <icmp_input+0x524>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
   3d9a8:	e13ffe17 	ldw	r4,-8(fp)
   3d9ac:	003e7180 	call	3e718 <inet_chksum_pbuf>
   3d9b0:	10bfffcc 	andi	r2,r2,65535
   3d9b4:	10000a26 	beq	r2,zero,3d9e0 <icmp_input+0x17c>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
   3d9b8:	e13ffe17 	ldw	r4,-8(fp)
   3d9bc:	00237600 	call	23760 <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
   3d9c0:	008001f4 	movhi	r2,7
   3d9c4:	10ac6e04 	addi	r2,r2,-20040
   3d9c8:	10803417 	ldw	r2,208(r2)
   3d9cc:	10c00044 	addi	r3,r2,1
   3d9d0:	008001f4 	movhi	r2,7
   3d9d4:	10ac6e04 	addi	r2,r2,-20040
   3d9d8:	10c03415 	stw	r3,208(r2)
      snmp_inc_icmpinerrors();
      return;
   3d9dc:	00010806 	br	3de00 <icmp_input+0x59c>
    }
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
   3d9e0:	e13ffe17 	ldw	r4,-8(fp)
   3d9e4:	01400904 	movi	r5,36
   3d9e8:	00235b00 	call	235b0 <pbuf_header>
   3d9ec:	10803fcc 	andi	r2,r2,255
   3d9f0:	10002926 	beq	r2,zero,3da98 <icmp_input+0x234>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
   3d9f4:	e0bffa0f 	ldh	r2,-24(fp)
   3d9f8:	e13ffe17 	ldw	r4,-8(fp)
   3d9fc:	100b883a 	mov	r5,r2
   3da00:	00235b00 	call	235b0 <pbuf_header>
   3da04:	10803fcc 	andi	r2,r2,255
   3da08:	1000ea1e 	bne	r2,zero,3ddb4 <icmp_input+0x550>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
   3da0c:	e0bffe17 	ldw	r2,-8(fp)
   3da10:	1080020b 	ldhu	r2,8(r2)
   3da14:	10bfffcc 	andi	r2,r2,65535
   3da18:	01000084 	movi	r4,2
   3da1c:	100b883a 	mov	r5,r2
   3da20:	000d883a 	mov	r6,zero
   3da24:	0022fa00 	call	22fa0 <pbuf_alloc>
   3da28:	e0bffb15 	stw	r2,-20(fp)
      if (r == NULL) {
   3da2c:	e0bffb17 	ldw	r2,-20(fp)
   3da30:	1000e226 	beq	r2,zero,3ddbc <icmp_input+0x558>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
   3da34:	e13ffb17 	ldw	r4,-20(fp)
   3da38:	e17ffe17 	ldw	r5,-8(fp)
   3da3c:	0023afc0 	call	23afc <pbuf_copy>
   3da40:	10803fcc 	andi	r2,r2,255
   3da44:	1080201c 	xori	r2,r2,128
   3da48:	10bfe004 	addi	r2,r2,-128
   3da4c:	1000dd1e 	bne	r2,zero,3ddc4 <icmp_input+0x560>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
        goto memerr;
      }
      iphdr = (struct ip_hdr *)r->payload;
   3da50:	e0bffb17 	ldw	r2,-20(fp)
   3da54:	10800117 	ldw	r2,4(r2)
   3da58:	e0bff815 	stw	r2,-32(fp)
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
   3da5c:	e0bffa0b 	ldhu	r2,-24(fp)
   3da60:	0085c83a 	sub	r2,zero,r2
   3da64:	10bfffcc 	andi	r2,r2,65535
   3da68:	10a0001c 	xori	r2,r2,32768
   3da6c:	10a00004 	addi	r2,r2,-32768
   3da70:	e13ffb17 	ldw	r4,-20(fp)
   3da74:	100b883a 	mov	r5,r2
   3da78:	00235b00 	call	235b0 <pbuf_header>
   3da7c:	10803fcc 	andi	r2,r2,255
   3da80:	1000d21e 	bne	r2,zero,3ddcc <icmp_input+0x568>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
   3da84:	e13ffe17 	ldw	r4,-8(fp)
   3da88:	00237600 	call	23760 <pbuf_free>
      /* we now have an identical copy of p that has room for link headers */
      p = r;
   3da8c:	e0bffb17 	ldw	r2,-20(fp)
   3da90:	e0bffe15 	stw	r2,-8(fp)
   3da94:	00000506 	br	3daac <icmp_input+0x248>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
   3da98:	e13ffe17 	ldw	r4,-8(fp)
   3da9c:	017ff704 	movi	r5,-36
   3daa0:	00235b00 	call	235b0 <pbuf_header>
   3daa4:	10803fcc 	andi	r2,r2,255
   3daa8:	1000ca1e 	bne	r2,zero,3ddd4 <icmp_input+0x570>
    }
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = (struct icmp_echo_hdr *)p->payload;
   3daac:	e0bffe17 	ldw	r2,-8(fp)
   3dab0:	10800117 	ldw	r2,4(r2)
   3dab4:	e0bffc15 	stw	r2,-16(fp)
    ip_addr_copy(iphdr->src, *ip_current_dest_addr());
   3dab8:	00800134 	movhi	r2,4
   3dabc:	109ee404 	addi	r2,r2,31632
   3dac0:	10c00017 	ldw	r3,0(r2)
   3dac4:	e0bff817 	ldw	r2,-32(fp)
   3dac8:	19003fcc 	andi	r4,r3,255
   3dacc:	11400303 	ldbu	r5,12(r2)
   3dad0:	280a703a 	and	r5,r5,zero
   3dad4:	2908b03a 	or	r4,r5,r4
   3dad8:	11000305 	stb	r4,12(r2)
   3dadc:	1808d23a 	srli	r4,r3,8
   3dae0:	21003fcc 	andi	r4,r4,255
   3dae4:	11400343 	ldbu	r5,13(r2)
   3dae8:	280a703a 	and	r5,r5,zero
   3daec:	2908b03a 	or	r4,r5,r4
   3daf0:	11000345 	stb	r4,13(r2)
   3daf4:	1808d43a 	srli	r4,r3,16
   3daf8:	21003fcc 	andi	r4,r4,255
   3dafc:	11400383 	ldbu	r5,14(r2)
   3db00:	280a703a 	and	r5,r5,zero
   3db04:	2908b03a 	or	r4,r5,r4
   3db08:	11000385 	stb	r4,14(r2)
   3db0c:	1806d63a 	srli	r3,r3,24
   3db10:	110003c3 	ldbu	r4,15(r2)
   3db14:	2008703a 	and	r4,r4,zero
   3db18:	20c6b03a 	or	r3,r4,r3
   3db1c:	10c003c5 	stb	r3,15(r2)
    ip_addr_copy(iphdr->dest, *ip_current_src_addr());
   3db20:	00800134 	movhi	r2,4
   3db24:	109ee204 	addi	r2,r2,31624
   3db28:	10c00017 	ldw	r3,0(r2)
   3db2c:	e0bff817 	ldw	r2,-32(fp)
   3db30:	19003fcc 	andi	r4,r3,255
   3db34:	11400403 	ldbu	r5,16(r2)
   3db38:	280a703a 	and	r5,r5,zero
   3db3c:	2908b03a 	or	r4,r5,r4
   3db40:	11000405 	stb	r4,16(r2)
   3db44:	1808d23a 	srli	r4,r3,8
   3db48:	21003fcc 	andi	r4,r4,255
   3db4c:	11400443 	ldbu	r5,17(r2)
   3db50:	280a703a 	and	r5,r5,zero
   3db54:	2908b03a 	or	r4,r5,r4
   3db58:	11000445 	stb	r4,17(r2)
   3db5c:	1808d43a 	srli	r4,r3,16
   3db60:	21003fcc 	andi	r4,r4,255
   3db64:	11400483 	ldbu	r5,18(r2)
   3db68:	280a703a 	and	r5,r5,zero
   3db6c:	2908b03a 	or	r4,r5,r4
   3db70:	11000485 	stb	r4,18(r2)
   3db74:	1806d63a 	srli	r3,r3,24
   3db78:	110004c3 	ldbu	r4,19(r2)
   3db7c:	2008703a 	and	r4,r4,zero
   3db80:	20c6b03a 	or	r3,r4,r3
   3db84:	10c004c5 	stb	r3,19(r2)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
   3db88:	e0bffc17 	ldw	r2,-16(fp)
   3db8c:	10000005 	stb	zero,0(r2)
#if CHECKSUM_GEN_ICMP
    /* adjust the checksum */
    if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
   3db90:	e0bffc17 	ldw	r2,-16(fp)
   3db94:	10c00083 	ldbu	r3,2(r2)
   3db98:	108000c3 	ldbu	r2,3(r2)
   3db9c:	1004923a 	slli	r2,r2,8
   3dba0:	10c4b03a 	or	r2,r2,r3
   3dba4:	10bfffcc 	andi	r2,r2,65535
   3dba8:	10bffdf0 	cmpltui	r2,r2,65527
   3dbac:	1000161e 	bne	r2,zero,3dc08 <icmp_input+0x3a4>
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
   3dbb0:	e0bffc17 	ldw	r2,-16(fp)
   3dbb4:	10c00083 	ldbu	r3,2(r2)
   3dbb8:	108000c3 	ldbu	r2,3(r2)
   3dbbc:	1004923a 	slli	r2,r2,8
   3dbc0:	10c4b03a 	or	r2,r2,r3
   3dbc4:	10800244 	addi	r2,r2,9
   3dbc8:	1007883a 	mov	r3,r2
   3dbcc:	e0bffc17 	ldw	r2,-16(fp)
   3dbd0:	193fffcc 	andi	r4,r3,65535
   3dbd4:	21003fcc 	andi	r4,r4,255
   3dbd8:	11400083 	ldbu	r5,2(r2)
   3dbdc:	280a703a 	and	r5,r5,zero
   3dbe0:	2908b03a 	or	r4,r5,r4
   3dbe4:	11000085 	stb	r4,2(r2)
   3dbe8:	18ffffcc 	andi	r3,r3,65535
   3dbec:	1806d23a 	srli	r3,r3,8
   3dbf0:	18ffffcc 	andi	r3,r3,65535
   3dbf4:	110000c3 	ldbu	r4,3(r2)
   3dbf8:	2008703a 	and	r4,r4,zero
   3dbfc:	20c6b03a 	or	r3,r4,r3
   3dc00:	10c000c5 	stb	r3,3(r2)
   3dc04:	00001506 	br	3dc5c <icmp_input+0x3f8>
    } else {
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
   3dc08:	e0bffc17 	ldw	r2,-16(fp)
   3dc0c:	10c00083 	ldbu	r3,2(r2)
   3dc10:	108000c3 	ldbu	r2,3(r2)
   3dc14:	1004923a 	slli	r2,r2,8
   3dc18:	10c4b03a 	or	r2,r2,r3
   3dc1c:	10800204 	addi	r2,r2,8
   3dc20:	1007883a 	mov	r3,r2
   3dc24:	e0bffc17 	ldw	r2,-16(fp)
   3dc28:	193fffcc 	andi	r4,r3,65535
   3dc2c:	21003fcc 	andi	r4,r4,255
   3dc30:	11400083 	ldbu	r5,2(r2)
   3dc34:	280a703a 	and	r5,r5,zero
   3dc38:	2908b03a 	or	r4,r5,r4
   3dc3c:	11000085 	stb	r4,2(r2)
   3dc40:	18ffffcc 	andi	r3,r3,65535
   3dc44:	1806d23a 	srli	r3,r3,8
   3dc48:	18ffffcc 	andi	r3,r3,65535
   3dc4c:	110000c3 	ldbu	r4,3(r2)
   3dc50:	2008703a 	and	r4,r4,zero
   3dc54:	20c6b03a 	or	r3,r4,r3
   3dc58:	10c000c5 	stb	r3,3(r2)
#else /* CHECKSUM_GEN_ICMP */
    iecho->chksum = 0;
#endif /* CHECKSUM_GEN_ICMP */

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
   3dc5c:	e0bff817 	ldw	r2,-32(fp)
   3dc60:	00c01004 	movi	r3,64
   3dc64:	10c00205 	stb	r3,8(r2)
    IPH_CHKSUM_SET(iphdr, 0);
   3dc68:	e0bff817 	ldw	r2,-32(fp)
   3dc6c:	10c00283 	ldbu	r3,10(r2)
   3dc70:	1806703a 	and	r3,r3,zero
   3dc74:	10c00285 	stb	r3,10(r2)
   3dc78:	10c002c3 	ldbu	r3,11(r2)
   3dc7c:	1806703a 	and	r3,r3,zero
   3dc80:	10c002c5 	stb	r3,11(r2)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
   3dc84:	e13ff817 	ldw	r4,-32(fp)
   3dc88:	01400504 	movi	r5,20
   3dc8c:	003e6d40 	call	3e6d4 <inet_chksum>
   3dc90:	1007883a 	mov	r3,r2
   3dc94:	e0bff817 	ldw	r2,-32(fp)
   3dc98:	193fffcc 	andi	r4,r3,65535
   3dc9c:	21003fcc 	andi	r4,r4,255
   3dca0:	11400283 	ldbu	r5,10(r2)
   3dca4:	280a703a 	and	r5,r5,zero
   3dca8:	2908b03a 	or	r4,r5,r4
   3dcac:	11000285 	stb	r4,10(r2)
   3dcb0:	18ffffcc 	andi	r3,r3,65535
   3dcb4:	1806d23a 	srli	r3,r3,8
   3dcb8:	18ffffcc 	andi	r3,r3,65535
   3dcbc:	110002c3 	ldbu	r4,11(r2)
   3dcc0:	2008703a 	and	r4,r4,zero
   3dcc4:	20c6b03a 	or	r3,r4,r3
   3dcc8:	10c002c5 	stb	r3,11(r2)
#endif /* CHECKSUM_GEN_IP */

    ICMP_STATS_INC(icmp.xmit);
   3dccc:	008001f4 	movhi	r2,7
   3dcd0:	10ac6e04 	addi	r2,r2,-20040
   3dcd4:	10803017 	ldw	r2,192(r2)
   3dcd8:	10c00044 	addi	r3,r2,1
   3dcdc:	008001f4 	movhi	r2,7
   3dce0:	10ac6e04 	addi	r2,r2,-20040
   3dce4:	10c03015 	stw	r3,192(r2)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
   3dce8:	e0bffa0f 	ldh	r2,-24(fp)
   3dcec:	e13ffe17 	ldw	r4,-8(fp)
   3dcf0:	100b883a 	mov	r5,r2
   3dcf4:	00235b00 	call	235b0 <pbuf_header>
   3dcf8:	10803fcc 	andi	r2,r2,255
   3dcfc:	10001e1e 	bne	r2,zero,3dd78 <icmp_input+0x514>
      LWIP_ASSERT("Can't move over header in packet", 0);
    } else {
      err_t ret;
      /* send an ICMP packet, src addr is the dest addr of the curren packet */
      ret = ip_output_if(p, ip_current_dest_addr(), IP_HDRINCL,
   3dd00:	d8000015 	stw	zero,0(sp)
   3dd04:	00800044 	movi	r2,1
   3dd08:	d8800115 	stw	r2,4(sp)
   3dd0c:	e0bfff17 	ldw	r2,-4(fp)
   3dd10:	d8800215 	stw	r2,8(sp)
   3dd14:	e13ffe17 	ldw	r4,-8(fp)
   3dd18:	01400134 	movhi	r5,4
   3dd1c:	295ee404 	addi	r5,r5,31632
   3dd20:	000d883a 	mov	r6,zero
   3dd24:	01c01004 	movi	r7,64
   3dd28:	001f3080 	call	1f308 <ip_output_if>
   3dd2c:	e0bffd05 	stb	r2,-12(fp)
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
      }
    }
    break;
   3dd30:	00001106 	br	3dd78 <icmp_input+0x514>
  default:
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
   3dd34:	008001f4 	movhi	r2,7
   3dd38:	10ac6e04 	addi	r2,r2,-20040
   3dd3c:	10803817 	ldw	r2,224(r2)
   3dd40:	10c00044 	addi	r3,r2,1
   3dd44:	008001f4 	movhi	r2,7
   3dd48:	10ac6e04 	addi	r2,r2,-20040
   3dd4c:	10c03815 	stw	r3,224(r2)
    ICMP_STATS_INC(icmp.drop);
   3dd50:	008001f4 	movhi	r2,7
   3dd54:	10ac6e04 	addi	r2,r2,-20040
   3dd58:	10803317 	ldw	r2,204(r2)
   3dd5c:	10c00044 	addi	r3,r2,1
   3dd60:	008001f4 	movhi	r2,7
   3dd64:	10ac6e04 	addi	r2,r2,-20040
   3dd68:	10c03315 	stw	r3,204(r2)
   3dd6c:	00000306 	br	3dd7c <icmp_input+0x518>
#endif /* LWIP_DEBUG */
  switch (type) {
  case ICMP_ER:
    /* This is OK, echo reply might have been parsed by a raw PCB
       (as obviously, an echo request has been sent, too). */
    break; 
   3dd70:	0001883a 	nop
   3dd74:	00000106 	br	3dd7c <icmp_input+0x518>
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
      }
    }
    break;
   3dd78:	0001883a 	nop
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
   3dd7c:	e13ffe17 	ldw	r4,-8(fp)
   3dd80:	00237600 	call	23760 <pbuf_free>
  return;
   3dd84:	00001e06 	br	3de00 <icmp_input+0x59c>
    }
#endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
   3dd88:	0001883a 	nop
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  return;
lenerr:
  pbuf_free(p);
   3dd8c:	e13ffe17 	ldw	r4,-8(fp)
   3dd90:	00237600 	call	23760 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
   3dd94:	008001f4 	movhi	r2,7
   3dd98:	10ac6e04 	addi	r2,r2,-20040
   3dd9c:	10803517 	ldw	r2,212(r2)
   3dda0:	10c00044 	addi	r3,r2,1
   3dda4:	008001f4 	movhi	r2,7
   3dda8:	10ac6e04 	addi	r2,r2,-20040
   3ddac:	10c03515 	stw	r3,212(r2)
  snmp_inc_icmpinerrors();
  return;
   3ddb0:	00001306 	br	3de00 <icmp_input+0x59c>
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
        goto memerr;
   3ddb4:	0001883a 	nop
   3ddb8:	00000706 	br	3ddd8 <icmp_input+0x574>
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
      if (r == NULL) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
   3ddbc:	0001883a 	nop
   3ddc0:	00000506 	br	3ddd8 <icmp_input+0x574>
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
        goto memerr;
   3ddc4:	0001883a 	nop
   3ddc8:	00000306 	br	3ddd8 <icmp_input+0x574>
      }
      iphdr = (struct ip_hdr *)r->payload;
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
   3ddcc:	0001883a 	nop
   3ddd0:	00000106 	br	3ddd8 <icmp_input+0x574>
      p = r;
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
   3ddd4:	0001883a 	nop
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
memerr:
  pbuf_free(p);
   3ddd8:	e13ffe17 	ldw	r4,-8(fp)
   3dddc:	00237600 	call	23760 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
   3dde0:	008001f4 	movhi	r2,7
   3dde4:	10ac6e04 	addi	r2,r2,-20040
   3dde8:	10803a17 	ldw	r2,232(r2)
   3ddec:	10c00044 	addi	r3,r2,1
   3ddf0:	008001f4 	movhi	r2,7
   3ddf4:	10ac6e04 	addi	r2,r2,-20040
   3ddf8:	10c03a15 	stw	r3,232(r2)
  snmp_inc_icmpinerrors();
  return;
   3ddfc:	0001883a 	nop
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
}
   3de00:	e037883a 	mov	sp,fp
   3de04:	dfc00117 	ldw	ra,4(sp)
   3de08:	df000017 	ldw	fp,0(sp)
   3de0c:	dec00204 	addi	sp,sp,8
   3de10:	f800283a 	ret

0003de14 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
   3de14:	defffc04 	addi	sp,sp,-16
   3de18:	dfc00315 	stw	ra,12(sp)
   3de1c:	df000215 	stw	fp,8(sp)
   3de20:	df000204 	addi	fp,sp,8
   3de24:	e13ffe15 	stw	r4,-8(fp)
   3de28:	e17fff15 	stw	r5,-4(fp)
  icmp_send_response(p, ICMP_DUR, t);
   3de2c:	e0bfff17 	ldw	r2,-4(fp)
   3de30:	10803fcc 	andi	r2,r2,255
   3de34:	e13ffe17 	ldw	r4,-8(fp)
   3de38:	014000c4 	movi	r5,3
   3de3c:	100d883a 	mov	r6,r2
   3de40:	003de9c0 	call	3de9c <icmp_send_response>
}
   3de44:	e037883a 	mov	sp,fp
   3de48:	dfc00117 	ldw	ra,4(sp)
   3de4c:	df000017 	ldw	fp,0(sp)
   3de50:	dec00204 	addi	sp,sp,8
   3de54:	f800283a 	ret

0003de58 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
   3de58:	defffc04 	addi	sp,sp,-16
   3de5c:	dfc00315 	stw	ra,12(sp)
   3de60:	df000215 	stw	fp,8(sp)
   3de64:	df000204 	addi	fp,sp,8
   3de68:	e13ffe15 	stw	r4,-8(fp)
   3de6c:	e17fff15 	stw	r5,-4(fp)
  icmp_send_response(p, ICMP_TE, t);
   3de70:	e0bfff17 	ldw	r2,-4(fp)
   3de74:	10803fcc 	andi	r2,r2,255
   3de78:	e13ffe17 	ldw	r4,-8(fp)
   3de7c:	014002c4 	movi	r5,11
   3de80:	100d883a 	mov	r6,r2
   3de84:	003de9c0 	call	3de9c <icmp_send_response>
}
   3de88:	e037883a 	mov	sp,fp
   3de8c:	dfc00117 	ldw	ra,4(sp)
   3de90:	df000017 	ldw	fp,0(sp)
   3de94:	dec00204 	addi	sp,sp,8
   3de98:	f800283a 	ret

0003de9c <icmp_send_response>:
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
   3de9c:	defff504 	addi	sp,sp,-44
   3dea0:	dfc00a15 	stw	ra,40(sp)
   3dea4:	df000915 	stw	fp,36(sp)
   3dea8:	df000904 	addi	fp,sp,36
   3deac:	e13ffd15 	stw	r4,-12(fp)
   3deb0:	2807883a 	mov	r3,r5
   3deb4:	3005883a 	mov	r2,r6
   3deb8:	e0fffe05 	stb	r3,-8(fp)
   3debc:	e0bfff05 	stb	r2,-4(fp)
  /* we can use the echo header here */
  struct icmp_echo_hdr *icmphdr;
  ip_addr_t iphdr_src;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
   3dec0:	01000044 	movi	r4,1
   3dec4:	01400904 	movi	r5,36
   3dec8:	000d883a 	mov	r6,zero
   3decc:	0022fa00 	call	22fa0 <pbuf_alloc>
   3ded0:	e0bff915 	stw	r2,-28(fp)
                 PBUF_RAM);
  if (q == NULL) {
   3ded4:	e0bff917 	ldw	r2,-28(fp)
   3ded8:	10005d26 	beq	r2,zero,3e050 <icmp_send_response+0x1b4>
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
             (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = (struct ip_hdr *)p->payload;
   3dedc:	e0bffd17 	ldw	r2,-12(fp)
   3dee0:	10800117 	ldw	r2,4(r2)
   3dee4:	e0bffa15 	stw	r2,-24(fp)
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
   3dee8:	e0bff917 	ldw	r2,-28(fp)
   3deec:	10800117 	ldw	r2,4(r2)
   3def0:	e0bffb15 	stw	r2,-20(fp)
  icmphdr->type = type;
   3def4:	e0bffb17 	ldw	r2,-20(fp)
   3def8:	e0fffe03 	ldbu	r3,-8(fp)
   3defc:	10c00005 	stb	r3,0(r2)
  icmphdr->code = code;
   3df00:	e0bffb17 	ldw	r2,-20(fp)
   3df04:	e0ffff03 	ldbu	r3,-4(fp)
   3df08:	10c00045 	stb	r3,1(r2)
  icmphdr->id = 0;
   3df0c:	e0bffb17 	ldw	r2,-20(fp)
   3df10:	10c00103 	ldbu	r3,4(r2)
   3df14:	1806703a 	and	r3,r3,zero
   3df18:	10c00105 	stb	r3,4(r2)
   3df1c:	10c00143 	ldbu	r3,5(r2)
   3df20:	1806703a 	and	r3,r3,zero
   3df24:	10c00145 	stb	r3,5(r2)
  icmphdr->seqno = 0;
   3df28:	e0bffb17 	ldw	r2,-20(fp)
   3df2c:	10c00183 	ldbu	r3,6(r2)
   3df30:	1806703a 	and	r3,r3,zero
   3df34:	10c00185 	stb	r3,6(r2)
   3df38:	10c001c3 	ldbu	r3,7(r2)
   3df3c:	1806703a 	and	r3,r3,zero
   3df40:	10c001c5 	stb	r3,7(r2)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
   3df44:	e0bff917 	ldw	r2,-28(fp)
   3df48:	10800117 	ldw	r2,4(r2)
   3df4c:	10c00204 	addi	r3,r2,8
   3df50:	e0bffd17 	ldw	r2,-12(fp)
   3df54:	10800117 	ldw	r2,4(r2)
   3df58:	1809883a 	mov	r4,r3
   3df5c:	100b883a 	mov	r5,r2
   3df60:	01800704 	movi	r6,28
   3df64:	00041f00 	call	41f0 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  icmphdr->chksum = 0;
   3df68:	e0bffb17 	ldw	r2,-20(fp)
   3df6c:	10c00083 	ldbu	r3,2(r2)
   3df70:	1806703a 	and	r3,r3,zero
   3df74:	10c00085 	stb	r3,2(r2)
   3df78:	10c000c3 	ldbu	r3,3(r2)
   3df7c:	1806703a 	and	r3,r3,zero
   3df80:	10c000c5 	stb	r3,3(r2)
  icmphdr->chksum = inet_chksum(icmphdr, q->len);
   3df84:	e0bff917 	ldw	r2,-28(fp)
   3df88:	1080028b 	ldhu	r2,10(r2)
   3df8c:	10bfffcc 	andi	r2,r2,65535
   3df90:	e13ffb17 	ldw	r4,-20(fp)
   3df94:	100b883a 	mov	r5,r2
   3df98:	003e6d40 	call	3e6d4 <inet_chksum>
   3df9c:	1007883a 	mov	r3,r2
   3dfa0:	e0bffb17 	ldw	r2,-20(fp)
   3dfa4:	193fffcc 	andi	r4,r3,65535
   3dfa8:	21003fcc 	andi	r4,r4,255
   3dfac:	11400083 	ldbu	r5,2(r2)
   3dfb0:	280a703a 	and	r5,r5,zero
   3dfb4:	2908b03a 	or	r4,r5,r4
   3dfb8:	11000085 	stb	r4,2(r2)
   3dfbc:	18ffffcc 	andi	r3,r3,65535
   3dfc0:	1806d23a 	srli	r3,r3,8
   3dfc4:	18ffffcc 	andi	r3,r3,65535
   3dfc8:	110000c3 	ldbu	r4,3(r2)
   3dfcc:	2008703a 	and	r4,r4,zero
   3dfd0:	20c6b03a 	or	r3,r4,r3
   3dfd4:	10c000c5 	stb	r3,3(r2)
  ICMP_STATS_INC(icmp.xmit);
   3dfd8:	008001f4 	movhi	r2,7
   3dfdc:	10ac6e04 	addi	r2,r2,-20040
   3dfe0:	10803017 	ldw	r2,192(r2)
   3dfe4:	10c00044 	addi	r3,r2,1
   3dfe8:	008001f4 	movhi	r2,7
   3dfec:	10ac6e04 	addi	r2,r2,-20040
   3dff0:	10c03015 	stw	r3,192(r2)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_addr_copy(iphdr_src, iphdr->src);
   3dff4:	e0bffa17 	ldw	r2,-24(fp)
   3dff8:	10c00303 	ldbu	r3,12(r2)
   3dffc:	11000343 	ldbu	r4,13(r2)
   3e000:	2008923a 	slli	r4,r4,8
   3e004:	20c6b03a 	or	r3,r4,r3
   3e008:	11000383 	ldbu	r4,14(r2)
   3e00c:	2008943a 	slli	r4,r4,16
   3e010:	20c6b03a 	or	r3,r4,r3
   3e014:	108003c3 	ldbu	r2,15(r2)
   3e018:	1004963a 	slli	r2,r2,24
   3e01c:	10c4b03a 	or	r2,r2,r3
   3e020:	e0bffc15 	stw	r2,-16(fp)
  ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
   3e024:	e0bffc04 	addi	r2,fp,-16
   3e028:	d8000015 	stw	zero,0(sp)
   3e02c:	00c00044 	movi	r3,1
   3e030:	d8c00115 	stw	r3,4(sp)
   3e034:	e13ff917 	ldw	r4,-28(fp)
   3e038:	000b883a 	mov	r5,zero
   3e03c:	100d883a 	mov	r6,r2
   3e040:	01c01004 	movi	r7,64
   3e044:	001f8bc0 	call	1f8bc <ip_output>
  pbuf_free(q);
   3e048:	e13ff917 	ldw	r4,-28(fp)
   3e04c:	00237600 	call	23760 <pbuf_free>
}
   3e050:	e037883a 	mov	sp,fp
   3e054:	dfc00117 	ldw	ra,4(sp)
   3e058:	df000017 	ldw	fp,0(sp)
   3e05c:	dec00204 	addi	sp,sp,8
   3e060:	f800283a 	ret

0003e064 <lwip_standard_chksum>:
 * by Curt McDowell, Broadcom Corp. December 8th, 2005
 */

static u16_t
lwip_standard_chksum(void *dataptr, int len)
{
   3e064:	defff604 	addi	sp,sp,-40
   3e068:	df000915 	stw	fp,36(sp)
   3e06c:	df000904 	addi	fp,sp,36
   3e070:	e13ffe15 	stw	r4,-8(fp)
   3e074:	e17fff15 	stw	r5,-4(fp)
  u8_t *pb = (u8_t *)dataptr;
   3e078:	e0bffe17 	ldw	r2,-8(fp)
   3e07c:	e0bff715 	stw	r2,-36(fp)
  u16_t *ps, t = 0;
   3e080:	e03ffd0d 	sth	zero,-12(fp)
  u32_t *pl;
  u32_t sum = 0, tmp;
   3e084:	e03ffa15 	stw	zero,-24(fp)
  /* starts at odd byte address? */
  int odd = ((mem_ptr_t)pb & 1);
   3e088:	e0bff717 	ldw	r2,-36(fp)
   3e08c:	1080004c 	andi	r2,r2,1
   3e090:	e0bffc15 	stw	r2,-16(fp)

  if (odd && len > 0) {
   3e094:	e0bffc17 	ldw	r2,-16(fp)
   3e098:	10000d26 	beq	r2,zero,3e0d0 <lwip_standard_chksum+0x6c>
   3e09c:	e0bfff17 	ldw	r2,-4(fp)
   3e0a0:	00800b0e 	bge	zero,r2,3e0d0 <lwip_standard_chksum+0x6c>
    ((u8_t *)&t)[1] = *pb++;
   3e0a4:	e0bffd04 	addi	r2,fp,-12
   3e0a8:	10800044 	addi	r2,r2,1
   3e0ac:	e0fff717 	ldw	r3,-36(fp)
   3e0b0:	18c00003 	ldbu	r3,0(r3)
   3e0b4:	10c00005 	stb	r3,0(r2)
   3e0b8:	e0bff717 	ldw	r2,-36(fp)
   3e0bc:	10800044 	addi	r2,r2,1
   3e0c0:	e0bff715 	stw	r2,-36(fp)
    len--;
   3e0c4:	e0bfff17 	ldw	r2,-4(fp)
   3e0c8:	10bfffc4 	addi	r2,r2,-1
   3e0cc:	e0bfff15 	stw	r2,-4(fp)
  }

  ps = (u16_t *)pb;
   3e0d0:	e0bff717 	ldw	r2,-36(fp)
   3e0d4:	e0bff815 	stw	r2,-32(fp)

  if (((mem_ptr_t)ps & 3) && len > 1) {
   3e0d8:	e0bff817 	ldw	r2,-32(fp)
   3e0dc:	108000cc 	andi	r2,r2,3
   3e0e0:	10000f26 	beq	r2,zero,3e120 <lwip_standard_chksum+0xbc>
   3e0e4:	e0bfff17 	ldw	r2,-4(fp)
   3e0e8:	10800090 	cmplti	r2,r2,2
   3e0ec:	10000c1e 	bne	r2,zero,3e120 <lwip_standard_chksum+0xbc>
    sum += *ps++;
   3e0f0:	e0bff817 	ldw	r2,-32(fp)
   3e0f4:	1080000b 	ldhu	r2,0(r2)
   3e0f8:	10bfffcc 	andi	r2,r2,65535
   3e0fc:	e0fffa17 	ldw	r3,-24(fp)
   3e100:	1885883a 	add	r2,r3,r2
   3e104:	e0bffa15 	stw	r2,-24(fp)
   3e108:	e0bff817 	ldw	r2,-32(fp)
   3e10c:	10800084 	addi	r2,r2,2
   3e110:	e0bff815 	stw	r2,-32(fp)
    len -= 2;
   3e114:	e0bfff17 	ldw	r2,-4(fp)
   3e118:	10bfff84 	addi	r2,r2,-2
   3e11c:	e0bfff15 	stw	r2,-4(fp)
  }

  pl = (u32_t *)ps;
   3e120:	e0bff817 	ldw	r2,-32(fp)
   3e124:	e0bff915 	stw	r2,-28(fp)

  while (len > 7)  {
   3e128:	00001f06 	br	3e1a8 <lwip_standard_chksum+0x144>
    tmp = sum + *pl++;          /* ping */
   3e12c:	e0bff917 	ldw	r2,-28(fp)
   3e130:	10c00017 	ldw	r3,0(r2)
   3e134:	e0bffa17 	ldw	r2,-24(fp)
   3e138:	1885883a 	add	r2,r3,r2
   3e13c:	e0bffb15 	stw	r2,-20(fp)
   3e140:	e0bff917 	ldw	r2,-28(fp)
   3e144:	10800104 	addi	r2,r2,4
   3e148:	e0bff915 	stw	r2,-28(fp)
    if (tmp < sum) {
   3e14c:	e0fffb17 	ldw	r3,-20(fp)
   3e150:	e0bffa17 	ldw	r2,-24(fp)
   3e154:	1880032e 	bgeu	r3,r2,3e164 <lwip_standard_chksum+0x100>
      tmp++;                    /* add back carry */
   3e158:	e0bffb17 	ldw	r2,-20(fp)
   3e15c:	10800044 	addi	r2,r2,1
   3e160:	e0bffb15 	stw	r2,-20(fp)
    }

    sum = tmp + *pl++;          /* pong */
   3e164:	e0bff917 	ldw	r2,-28(fp)
   3e168:	10c00017 	ldw	r3,0(r2)
   3e16c:	e0bffb17 	ldw	r2,-20(fp)
   3e170:	1885883a 	add	r2,r3,r2
   3e174:	e0bffa15 	stw	r2,-24(fp)
   3e178:	e0bff917 	ldw	r2,-28(fp)
   3e17c:	10800104 	addi	r2,r2,4
   3e180:	e0bff915 	stw	r2,-28(fp)
    if (sum < tmp) {
   3e184:	e0fffa17 	ldw	r3,-24(fp)
   3e188:	e0bffb17 	ldw	r2,-20(fp)
   3e18c:	1880032e 	bgeu	r3,r2,3e19c <lwip_standard_chksum+0x138>
      sum++;                    /* add back carry */
   3e190:	e0bffa17 	ldw	r2,-24(fp)
   3e194:	10800044 	addi	r2,r2,1
   3e198:	e0bffa15 	stw	r2,-24(fp)
    }

    len -= 8;
   3e19c:	e0bfff17 	ldw	r2,-4(fp)
   3e1a0:	10bffe04 	addi	r2,r2,-8
   3e1a4:	e0bfff15 	stw	r2,-4(fp)
    len -= 2;
  }

  pl = (u32_t *)ps;

  while (len > 7)  {
   3e1a8:	e0bfff17 	ldw	r2,-4(fp)
   3e1ac:	10800208 	cmpgei	r2,r2,8
   3e1b0:	103fde1e 	bne	r2,zero,3e12c <lwip_standard_chksum+0xc8>

    len -= 8;
  }

  /* make room in upper bits */
  sum = FOLD_U32T(sum);
   3e1b4:	e0bffa17 	ldw	r2,-24(fp)
   3e1b8:	1006d43a 	srli	r3,r2,16
   3e1bc:	e0bffa17 	ldw	r2,-24(fp)
   3e1c0:	10bfffcc 	andi	r2,r2,65535
   3e1c4:	1885883a 	add	r2,r3,r2
   3e1c8:	e0bffa15 	stw	r2,-24(fp)

  ps = (u16_t *)pl;
   3e1cc:	e0bff917 	ldw	r2,-28(fp)
   3e1d0:	e0bff815 	stw	r2,-32(fp)

  /* 16-bit aligned word remaining? */
  while (len > 1) {
   3e1d4:	00000c06 	br	3e208 <lwip_standard_chksum+0x1a4>
    sum += *ps++;
   3e1d8:	e0bff817 	ldw	r2,-32(fp)
   3e1dc:	1080000b 	ldhu	r2,0(r2)
   3e1e0:	10bfffcc 	andi	r2,r2,65535
   3e1e4:	e0fffa17 	ldw	r3,-24(fp)
   3e1e8:	1885883a 	add	r2,r3,r2
   3e1ec:	e0bffa15 	stw	r2,-24(fp)
   3e1f0:	e0bff817 	ldw	r2,-32(fp)
   3e1f4:	10800084 	addi	r2,r2,2
   3e1f8:	e0bff815 	stw	r2,-32(fp)
    len -= 2;
   3e1fc:	e0bfff17 	ldw	r2,-4(fp)
   3e200:	10bfff84 	addi	r2,r2,-2
   3e204:	e0bfff15 	stw	r2,-4(fp)
  sum = FOLD_U32T(sum);

  ps = (u16_t *)pl;

  /* 16-bit aligned word remaining? */
  while (len > 1) {
   3e208:	e0bfff17 	ldw	r2,-4(fp)
   3e20c:	10800088 	cmpgei	r2,r2,2
   3e210:	103ff11e 	bne	r2,zero,3e1d8 <lwip_standard_chksum+0x174>
    sum += *ps++;
    len -= 2;
  }

  /* dangling tail byte remaining? */
  if (len > 0) {                /* include odd byte */
   3e214:	e0bfff17 	ldw	r2,-4(fp)
   3e218:	0080040e 	bge	zero,r2,3e22c <lwip_standard_chksum+0x1c8>
    ((u8_t *)&t)[0] = *(u8_t *)ps;
   3e21c:	e0bffd04 	addi	r2,fp,-12
   3e220:	e0fff817 	ldw	r3,-32(fp)
   3e224:	18c00003 	ldbu	r3,0(r3)
   3e228:	10c00005 	stb	r3,0(r2)
  }

  sum += t;                     /* add end bytes */
   3e22c:	e0bffd0b 	ldhu	r2,-12(fp)
   3e230:	10bfffcc 	andi	r2,r2,65535
   3e234:	e0fffa17 	ldw	r3,-24(fp)
   3e238:	1885883a 	add	r2,r3,r2
   3e23c:	e0bffa15 	stw	r2,-24(fp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  sum = FOLD_U32T(sum);
   3e240:	e0bffa17 	ldw	r2,-24(fp)
   3e244:	1006d43a 	srli	r3,r2,16
   3e248:	e0bffa17 	ldw	r2,-24(fp)
   3e24c:	10bfffcc 	andi	r2,r2,65535
   3e250:	1885883a 	add	r2,r3,r2
   3e254:	e0bffa15 	stw	r2,-24(fp)
  sum = FOLD_U32T(sum);
   3e258:	e0bffa17 	ldw	r2,-24(fp)
   3e25c:	1006d43a 	srli	r3,r2,16
   3e260:	e0bffa17 	ldw	r2,-24(fp)
   3e264:	10bfffcc 	andi	r2,r2,65535
   3e268:	1885883a 	add	r2,r3,r2
   3e26c:	e0bffa15 	stw	r2,-24(fp)

  if (odd) {
   3e270:	e0bffc17 	ldw	r2,-16(fp)
   3e274:	10000826 	beq	r2,zero,3e298 <lwip_standard_chksum+0x234>
    sum = SWAP_BYTES_IN_WORD(sum);
   3e278:	e0bffa17 	ldw	r2,-24(fp)
   3e27c:	10bfc00c 	andi	r2,r2,65280
   3e280:	1006d23a 	srli	r3,r2,8
   3e284:	e0bffa17 	ldw	r2,-24(fp)
   3e288:	1004923a 	slli	r2,r2,8
   3e28c:	10bfffcc 	andi	r2,r2,65535
   3e290:	1884b03a 	or	r2,r3,r2
   3e294:	e0bffa15 	stw	r2,-24(fp)
  }

  return (u16_t)sum;
   3e298:	e0bffa17 	ldw	r2,-24(fp)
}
   3e29c:	e037883a 	mov	sp,fp
   3e2a0:	df000017 	ldw	fp,0(sp)
   3e2a4:	dec00104 	addi	sp,sp,4
   3e2a8:	f800283a 	ret

0003e2ac <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       ip_addr_t *src, ip_addr_t *dest,
       u8_t proto, u16_t proto_len)
{
   3e2ac:	defff504 	addi	sp,sp,-44
   3e2b0:	dfc00a15 	stw	ra,40(sp)
   3e2b4:	df000915 	stw	fp,36(sp)
   3e2b8:	df000904 	addi	fp,sp,36
   3e2bc:	e13ffb15 	stw	r4,-20(fp)
   3e2c0:	e17ffc15 	stw	r5,-16(fp)
   3e2c4:	e1bffd15 	stw	r6,-12(fp)
   3e2c8:	3805883a 	mov	r2,r7
   3e2cc:	e0c00217 	ldw	r3,8(fp)
   3e2d0:	e0bffe05 	stb	r2,-8(fp)
   3e2d4:	e0ffff0d 	sth	r3,-4(fp)
  u32_t acc;
  u32_t addr;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
   3e2d8:	e03ff715 	stw	zero,-36(fp)
  swapped = 0;
   3e2dc:	e03ff905 	stb	zero,-28(fp)
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
   3e2e0:	e0bffb17 	ldw	r2,-20(fp)
   3e2e4:	e0bff815 	stw	r2,-32(fp)
   3e2e8:	00002606 	br	3e384 <inet_chksum_pseudo+0xd8>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
   3e2ec:	e0bff817 	ldw	r2,-32(fp)
   3e2f0:	10c00117 	ldw	r3,4(r2)
   3e2f4:	e0bff817 	ldw	r2,-32(fp)
   3e2f8:	1080028b 	ldhu	r2,10(r2)
   3e2fc:	10bfffcc 	andi	r2,r2,65535
   3e300:	1809883a 	mov	r4,r3
   3e304:	100b883a 	mov	r5,r2
   3e308:	003e0640 	call	3e064 <lwip_standard_chksum>
   3e30c:	10bfffcc 	andi	r2,r2,65535
   3e310:	e0fff717 	ldw	r3,-36(fp)
   3e314:	1885883a 	add	r2,r3,r2
   3e318:	e0bff715 	stw	r2,-36(fp)
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
   3e31c:	e0bff717 	ldw	r2,-36(fp)
   3e320:	1006d43a 	srli	r3,r2,16
   3e324:	e0bff717 	ldw	r2,-36(fp)
   3e328:	10bfffcc 	andi	r2,r2,65535
   3e32c:	1885883a 	add	r2,r3,r2
   3e330:	e0bff715 	stw	r2,-36(fp)
    if (q->len % 2 != 0) {
   3e334:	e0bff817 	ldw	r2,-32(fp)
   3e338:	1080028b 	ldhu	r2,10(r2)
   3e33c:	1080004c 	andi	r2,r2,1
   3e340:	10bfffcc 	andi	r2,r2,65535
   3e344:	10000c26 	beq	r2,zero,3e378 <inet_chksum_pseudo+0xcc>
      swapped = 1 - swapped;
   3e348:	e0bff903 	ldbu	r2,-28(fp)
   3e34c:	00c00044 	movi	r3,1
   3e350:	1885c83a 	sub	r2,r3,r2
   3e354:	e0bff905 	stb	r2,-28(fp)
      acc = SWAP_BYTES_IN_WORD(acc);
   3e358:	e0bff717 	ldw	r2,-36(fp)
   3e35c:	10bfc00c 	andi	r2,r2,65280
   3e360:	1006d23a 	srli	r3,r2,8
   3e364:	e0bff717 	ldw	r2,-36(fp)
   3e368:	1004923a 	slli	r2,r2,8
   3e36c:	10bfffcc 	andi	r2,r2,65535
   3e370:	1884b03a 	or	r2,r3,r2
   3e374:	e0bff715 	stw	r2,-36(fp)
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
   3e378:	e0bff817 	ldw	r2,-32(fp)
   3e37c:	10800017 	ldw	r2,0(r2)
   3e380:	e0bff815 	stw	r2,-32(fp)
   3e384:	e0bff817 	ldw	r2,-32(fp)
   3e388:	103fd81e 	bne	r2,zero,3e2ec <inet_chksum_pseudo+0x40>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
   3e38c:	e0bff903 	ldbu	r2,-28(fp)
   3e390:	10000826 	beq	r2,zero,3e3b4 <inet_chksum_pseudo+0x108>
    acc = SWAP_BYTES_IN_WORD(acc);
   3e394:	e0bff717 	ldw	r2,-36(fp)
   3e398:	10bfc00c 	andi	r2,r2,65280
   3e39c:	1006d23a 	srli	r3,r2,8
   3e3a0:	e0bff717 	ldw	r2,-36(fp)
   3e3a4:	1004923a 	slli	r2,r2,8
   3e3a8:	10bfffcc 	andi	r2,r2,65535
   3e3ac:	1884b03a 	or	r2,r3,r2
   3e3b0:	e0bff715 	stw	r2,-36(fp)
  }
  addr = ip4_addr_get_u32(src);
   3e3b4:	e0bffc17 	ldw	r2,-16(fp)
   3e3b8:	10800017 	ldw	r2,0(r2)
   3e3bc:	e0bffa15 	stw	r2,-24(fp)
  acc += (addr & 0xffffUL);
   3e3c0:	e0bffa17 	ldw	r2,-24(fp)
   3e3c4:	10bfffcc 	andi	r2,r2,65535
   3e3c8:	e0fff717 	ldw	r3,-36(fp)
   3e3cc:	1885883a 	add	r2,r3,r2
   3e3d0:	e0bff715 	stw	r2,-36(fp)
  acc += ((addr >> 16) & 0xffffUL);
   3e3d4:	e0bffa17 	ldw	r2,-24(fp)
   3e3d8:	1004d43a 	srli	r2,r2,16
   3e3dc:	e0fff717 	ldw	r3,-36(fp)
   3e3e0:	1885883a 	add	r2,r3,r2
   3e3e4:	e0bff715 	stw	r2,-36(fp)
  addr = ip4_addr_get_u32(dest);
   3e3e8:	e0bffd17 	ldw	r2,-12(fp)
   3e3ec:	10800017 	ldw	r2,0(r2)
   3e3f0:	e0bffa15 	stw	r2,-24(fp)
  acc += (addr & 0xffffUL);
   3e3f4:	e0bffa17 	ldw	r2,-24(fp)
   3e3f8:	10bfffcc 	andi	r2,r2,65535
   3e3fc:	e0fff717 	ldw	r3,-36(fp)
   3e400:	1885883a 	add	r2,r3,r2
   3e404:	e0bff715 	stw	r2,-36(fp)
  acc += ((addr >> 16) & 0xffffUL);
   3e408:	e0bffa17 	ldw	r2,-24(fp)
   3e40c:	1004d43a 	srli	r2,r2,16
   3e410:	e0fff717 	ldw	r3,-36(fp)
   3e414:	1885883a 	add	r2,r3,r2
   3e418:	e0bff715 	stw	r2,-36(fp)
  acc += (u32_t)htons((u16_t)proto);
   3e41c:	e0bffe03 	ldbu	r2,-8(fp)
   3e420:	1004923a 	slli	r2,r2,8
   3e424:	e0fff717 	ldw	r3,-36(fp)
   3e428:	1885883a 	add	r2,r3,r2
   3e42c:	e0bff715 	stw	r2,-36(fp)
  acc += (u32_t)htons(proto_len);
   3e430:	e0bfff0b 	ldhu	r2,-4(fp)
   3e434:	1004d23a 	srli	r2,r2,8
   3e438:	10ffffcc 	andi	r3,r2,65535
   3e43c:	e0bfff0b 	ldhu	r2,-4(fp)
   3e440:	1004923a 	slli	r2,r2,8
   3e444:	10bfffcc 	andi	r2,r2,65535
   3e448:	1884b03a 	or	r2,r3,r2
   3e44c:	e0fff717 	ldw	r3,-36(fp)
   3e450:	1885883a 	add	r2,r3,r2
   3e454:	e0bff715 	stw	r2,-36(fp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
   3e458:	e0bff717 	ldw	r2,-36(fp)
   3e45c:	1006d43a 	srli	r3,r2,16
   3e460:	e0bff717 	ldw	r2,-36(fp)
   3e464:	10bfffcc 	andi	r2,r2,65535
   3e468:	1885883a 	add	r2,r3,r2
   3e46c:	e0bff715 	stw	r2,-36(fp)
  acc = FOLD_U32T(acc);
   3e470:	e0bff717 	ldw	r2,-36(fp)
   3e474:	1006d43a 	srli	r3,r2,16
   3e478:	e0bff717 	ldw	r2,-36(fp)
   3e47c:	10bfffcc 	andi	r2,r2,65535
   3e480:	1885883a 	add	r2,r3,r2
   3e484:	e0bff715 	stw	r2,-36(fp)
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
   3e488:	e0bff717 	ldw	r2,-36(fp)
   3e48c:	0084303a 	nor	r2,zero,r2
}
   3e490:	e037883a 	mov	sp,fp
   3e494:	dfc00117 	ldw	ra,4(sp)
   3e498:	df000017 	ldw	fp,0(sp)
   3e49c:	dec00204 	addi	sp,sp,8
   3e4a0:	f800283a 	ret

0003e4a4 <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       ip_addr_t *src, ip_addr_t *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
   3e4a4:	defff404 	addi	sp,sp,-48
   3e4a8:	dfc00b15 	stw	ra,44(sp)
   3e4ac:	df000a15 	stw	fp,40(sp)
   3e4b0:	df000a04 	addi	fp,sp,40
   3e4b4:	e13ffa15 	stw	r4,-24(fp)
   3e4b8:	e17ffb15 	stw	r5,-20(fp)
   3e4bc:	e1bffc15 	stw	r6,-16(fp)
   3e4c0:	3805883a 	mov	r2,r7
   3e4c4:	e1000217 	ldw	r4,8(fp)
   3e4c8:	e0c00317 	ldw	r3,12(fp)
   3e4cc:	e0bffd05 	stb	r2,-12(fp)
   3e4d0:	e13ffe0d 	sth	r4,-8(fp)
   3e4d4:	e0ffff0d 	sth	r3,-4(fp)
  u32_t addr;
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
   3e4d8:	e03ff615 	stw	zero,-40(fp)
  swapped = 0;
   3e4dc:	e03ff805 	stb	zero,-32(fp)
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
   3e4e0:	e0bffa17 	ldw	r2,-24(fp)
   3e4e4:	e0bff715 	stw	r2,-36(fp)
   3e4e8:	00003006 	br	3e5ac <inet_chksum_pseudo_partial+0x108>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
   3e4ec:	e0bff717 	ldw	r2,-36(fp)
   3e4f0:	1080028b 	ldhu	r2,10(r2)
   3e4f4:	e0bff88d 	sth	r2,-30(fp)
    if (chklen > chksum_len) {
   3e4f8:	e0bff88b 	ldhu	r2,-30(fp)
   3e4fc:	e0ffff0b 	ldhu	r3,-4(fp)
   3e500:	1880022e 	bgeu	r3,r2,3e50c <inet_chksum_pseudo_partial+0x68>
      chklen = chksum_len;
   3e504:	e0bfff0b 	ldhu	r2,-4(fp)
   3e508:	e0bff88d 	sth	r2,-30(fp)
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
   3e50c:	e0bff717 	ldw	r2,-36(fp)
   3e510:	10c00117 	ldw	r3,4(r2)
   3e514:	e0bff88b 	ldhu	r2,-30(fp)
   3e518:	1809883a 	mov	r4,r3
   3e51c:	100b883a 	mov	r5,r2
   3e520:	003e0640 	call	3e064 <lwip_standard_chksum>
   3e524:	10bfffcc 	andi	r2,r2,65535
   3e528:	e0fff617 	ldw	r3,-40(fp)
   3e52c:	1885883a 	add	r2,r3,r2
   3e530:	e0bff615 	stw	r2,-40(fp)
    chksum_len -= chklen;
   3e534:	e0ffff0b 	ldhu	r3,-4(fp)
   3e538:	e0bff88b 	ldhu	r2,-30(fp)
   3e53c:	1885c83a 	sub	r2,r3,r2
   3e540:	e0bfff0d 	sth	r2,-4(fp)
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
   3e544:	e0bff617 	ldw	r2,-40(fp)
   3e548:	1006d43a 	srli	r3,r2,16
   3e54c:	e0bff617 	ldw	r2,-40(fp)
   3e550:	10bfffcc 	andi	r2,r2,65535
   3e554:	1885883a 	add	r2,r3,r2
   3e558:	e0bff615 	stw	r2,-40(fp)
    if (q->len % 2 != 0) {
   3e55c:	e0bff717 	ldw	r2,-36(fp)
   3e560:	1080028b 	ldhu	r2,10(r2)
   3e564:	1080004c 	andi	r2,r2,1
   3e568:	10bfffcc 	andi	r2,r2,65535
   3e56c:	10000c26 	beq	r2,zero,3e5a0 <inet_chksum_pseudo_partial+0xfc>
      swapped = 1 - swapped;
   3e570:	e0bff803 	ldbu	r2,-32(fp)
   3e574:	00c00044 	movi	r3,1
   3e578:	1885c83a 	sub	r2,r3,r2
   3e57c:	e0bff805 	stb	r2,-32(fp)
      acc = SWAP_BYTES_IN_WORD(acc);
   3e580:	e0bff617 	ldw	r2,-40(fp)
   3e584:	10bfc00c 	andi	r2,r2,65280
   3e588:	1006d23a 	srli	r3,r2,8
   3e58c:	e0bff617 	ldw	r2,-40(fp)
   3e590:	1004923a 	slli	r2,r2,8
   3e594:	10bfffcc 	andi	r2,r2,65535
   3e598:	1884b03a 	or	r2,r3,r2
   3e59c:	e0bff615 	stw	r2,-40(fp)
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
   3e5a0:	e0bff717 	ldw	r2,-36(fp)
   3e5a4:	10800017 	ldw	r2,0(r2)
   3e5a8:	e0bff715 	stw	r2,-36(fp)
   3e5ac:	e0bff717 	ldw	r2,-36(fp)
   3e5b0:	10000226 	beq	r2,zero,3e5bc <inet_chksum_pseudo_partial+0x118>
   3e5b4:	e0bfff0b 	ldhu	r2,-4(fp)
   3e5b8:	103fcc1e 	bne	r2,zero,3e4ec <inet_chksum_pseudo_partial+0x48>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
   3e5bc:	e0bff803 	ldbu	r2,-32(fp)
   3e5c0:	10000826 	beq	r2,zero,3e5e4 <inet_chksum_pseudo_partial+0x140>
    acc = SWAP_BYTES_IN_WORD(acc);
   3e5c4:	e0bff617 	ldw	r2,-40(fp)
   3e5c8:	10bfc00c 	andi	r2,r2,65280
   3e5cc:	1006d23a 	srli	r3,r2,8
   3e5d0:	e0bff617 	ldw	r2,-40(fp)
   3e5d4:	1004923a 	slli	r2,r2,8
   3e5d8:	10bfffcc 	andi	r2,r2,65535
   3e5dc:	1884b03a 	or	r2,r3,r2
   3e5e0:	e0bff615 	stw	r2,-40(fp)
  }
  addr = ip4_addr_get_u32(src);
   3e5e4:	e0bffb17 	ldw	r2,-20(fp)
   3e5e8:	10800017 	ldw	r2,0(r2)
   3e5ec:	e0bff915 	stw	r2,-28(fp)
  acc += (addr & 0xffffUL);
   3e5f0:	e0bff917 	ldw	r2,-28(fp)
   3e5f4:	10bfffcc 	andi	r2,r2,65535
   3e5f8:	e0fff617 	ldw	r3,-40(fp)
   3e5fc:	1885883a 	add	r2,r3,r2
   3e600:	e0bff615 	stw	r2,-40(fp)
  acc += ((addr >> 16) & 0xffffUL);
   3e604:	e0bff917 	ldw	r2,-28(fp)
   3e608:	1004d43a 	srli	r2,r2,16
   3e60c:	e0fff617 	ldw	r3,-40(fp)
   3e610:	1885883a 	add	r2,r3,r2
   3e614:	e0bff615 	stw	r2,-40(fp)
  addr = ip4_addr_get_u32(dest);
   3e618:	e0bffc17 	ldw	r2,-16(fp)
   3e61c:	10800017 	ldw	r2,0(r2)
   3e620:	e0bff915 	stw	r2,-28(fp)
  acc += (addr & 0xffffUL);
   3e624:	e0bff917 	ldw	r2,-28(fp)
   3e628:	10bfffcc 	andi	r2,r2,65535
   3e62c:	e0fff617 	ldw	r3,-40(fp)
   3e630:	1885883a 	add	r2,r3,r2
   3e634:	e0bff615 	stw	r2,-40(fp)
  acc += ((addr >> 16) & 0xffffUL);
   3e638:	e0bff917 	ldw	r2,-28(fp)
   3e63c:	1004d43a 	srli	r2,r2,16
   3e640:	e0fff617 	ldw	r3,-40(fp)
   3e644:	1885883a 	add	r2,r3,r2
   3e648:	e0bff615 	stw	r2,-40(fp)
  acc += (u32_t)htons((u16_t)proto);
   3e64c:	e0bffd03 	ldbu	r2,-12(fp)
   3e650:	1004923a 	slli	r2,r2,8
   3e654:	e0fff617 	ldw	r3,-40(fp)
   3e658:	1885883a 	add	r2,r3,r2
   3e65c:	e0bff615 	stw	r2,-40(fp)
  acc += (u32_t)htons(proto_len);
   3e660:	e0bffe0b 	ldhu	r2,-8(fp)
   3e664:	1004d23a 	srli	r2,r2,8
   3e668:	10ffffcc 	andi	r3,r2,65535
   3e66c:	e0bffe0b 	ldhu	r2,-8(fp)
   3e670:	1004923a 	slli	r2,r2,8
   3e674:	10bfffcc 	andi	r2,r2,65535
   3e678:	1884b03a 	or	r2,r3,r2
   3e67c:	e0fff617 	ldw	r3,-40(fp)
   3e680:	1885883a 	add	r2,r3,r2
   3e684:	e0bff615 	stw	r2,-40(fp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
   3e688:	e0bff617 	ldw	r2,-40(fp)
   3e68c:	1006d43a 	srli	r3,r2,16
   3e690:	e0bff617 	ldw	r2,-40(fp)
   3e694:	10bfffcc 	andi	r2,r2,65535
   3e698:	1885883a 	add	r2,r3,r2
   3e69c:	e0bff615 	stw	r2,-40(fp)
  acc = FOLD_U32T(acc);
   3e6a0:	e0bff617 	ldw	r2,-40(fp)
   3e6a4:	1006d43a 	srli	r3,r2,16
   3e6a8:	e0bff617 	ldw	r2,-40(fp)
   3e6ac:	10bfffcc 	andi	r2,r2,65535
   3e6b0:	1885883a 	add	r2,r3,r2
   3e6b4:	e0bff615 	stw	r2,-40(fp)
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
   3e6b8:	e0bff617 	ldw	r2,-40(fp)
   3e6bc:	0084303a 	nor	r2,zero,r2
}
   3e6c0:	e037883a 	mov	sp,fp
   3e6c4:	dfc00117 	ldw	ra,4(sp)
   3e6c8:	df000017 	ldw	fp,0(sp)
   3e6cc:	dec00204 	addi	sp,sp,8
   3e6d0:	f800283a 	ret

0003e6d4 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
   3e6d4:	defffc04 	addi	sp,sp,-16
   3e6d8:	dfc00315 	stw	ra,12(sp)
   3e6dc:	df000215 	stw	fp,8(sp)
   3e6e0:	df000204 	addi	fp,sp,8
   3e6e4:	e13ffe15 	stw	r4,-8(fp)
   3e6e8:	2805883a 	mov	r2,r5
   3e6ec:	e0bfff0d 	sth	r2,-4(fp)
  return ~LWIP_CHKSUM(dataptr, len);
   3e6f0:	e0bfff0b 	ldhu	r2,-4(fp)
   3e6f4:	e13ffe17 	ldw	r4,-8(fp)
   3e6f8:	100b883a 	mov	r5,r2
   3e6fc:	003e0640 	call	3e064 <lwip_standard_chksum>
   3e700:	0084303a 	nor	r2,zero,r2
}
   3e704:	e037883a 	mov	sp,fp
   3e708:	dfc00117 	ldw	ra,4(sp)
   3e70c:	df000017 	ldw	fp,0(sp)
   3e710:	dec00204 	addi	sp,sp,8
   3e714:	f800283a 	ret

0003e718 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
   3e718:	defffa04 	addi	sp,sp,-24
   3e71c:	dfc00515 	stw	ra,20(sp)
   3e720:	df000415 	stw	fp,16(sp)
   3e724:	df000404 	addi	fp,sp,16
   3e728:	e13fff15 	stw	r4,-4(fp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
   3e72c:	e03ffc15 	stw	zero,-16(fp)
  swapped = 0;
   3e730:	e03ffe05 	stb	zero,-8(fp)
  for(q = p; q != NULL; q = q->next) {
   3e734:	e0bfff17 	ldw	r2,-4(fp)
   3e738:	e0bffd15 	stw	r2,-12(fp)
   3e73c:	00002606 	br	3e7d8 <inet_chksum_pbuf+0xc0>
    acc += LWIP_CHKSUM(q->payload, q->len);
   3e740:	e0bffd17 	ldw	r2,-12(fp)
   3e744:	10c00117 	ldw	r3,4(r2)
   3e748:	e0bffd17 	ldw	r2,-12(fp)
   3e74c:	1080028b 	ldhu	r2,10(r2)
   3e750:	10bfffcc 	andi	r2,r2,65535
   3e754:	1809883a 	mov	r4,r3
   3e758:	100b883a 	mov	r5,r2
   3e75c:	003e0640 	call	3e064 <lwip_standard_chksum>
   3e760:	10bfffcc 	andi	r2,r2,65535
   3e764:	e0fffc17 	ldw	r3,-16(fp)
   3e768:	1885883a 	add	r2,r3,r2
   3e76c:	e0bffc15 	stw	r2,-16(fp)
    acc = FOLD_U32T(acc);
   3e770:	e0bffc17 	ldw	r2,-16(fp)
   3e774:	1006d43a 	srli	r3,r2,16
   3e778:	e0bffc17 	ldw	r2,-16(fp)
   3e77c:	10bfffcc 	andi	r2,r2,65535
   3e780:	1885883a 	add	r2,r3,r2
   3e784:	e0bffc15 	stw	r2,-16(fp)
    if (q->len % 2 != 0) {
   3e788:	e0bffd17 	ldw	r2,-12(fp)
   3e78c:	1080028b 	ldhu	r2,10(r2)
   3e790:	1080004c 	andi	r2,r2,1
   3e794:	10bfffcc 	andi	r2,r2,65535
   3e798:	10000c26 	beq	r2,zero,3e7cc <inet_chksum_pbuf+0xb4>
      swapped = 1 - swapped;
   3e79c:	e0bffe03 	ldbu	r2,-8(fp)
   3e7a0:	00c00044 	movi	r3,1
   3e7a4:	1885c83a 	sub	r2,r3,r2
   3e7a8:	e0bffe05 	stb	r2,-8(fp)
      acc = SWAP_BYTES_IN_WORD(acc);
   3e7ac:	e0bffc17 	ldw	r2,-16(fp)
   3e7b0:	10bfc00c 	andi	r2,r2,65280
   3e7b4:	1006d23a 	srli	r3,r2,8
   3e7b8:	e0bffc17 	ldw	r2,-16(fp)
   3e7bc:	1004923a 	slli	r2,r2,8
   3e7c0:	10bfffcc 	andi	r2,r2,65535
   3e7c4:	1884b03a 	or	r2,r3,r2
   3e7c8:	e0bffc15 	stw	r2,-16(fp)
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
   3e7cc:	e0bffd17 	ldw	r2,-12(fp)
   3e7d0:	10800017 	ldw	r2,0(r2)
   3e7d4:	e0bffd15 	stw	r2,-12(fp)
   3e7d8:	e0bffd17 	ldw	r2,-12(fp)
   3e7dc:	103fd81e 	bne	r2,zero,3e740 <inet_chksum_pbuf+0x28>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
   3e7e0:	e0bffe03 	ldbu	r2,-8(fp)
   3e7e4:	10000826 	beq	r2,zero,3e808 <inet_chksum_pbuf+0xf0>
    acc = SWAP_BYTES_IN_WORD(acc);
   3e7e8:	e0bffc17 	ldw	r2,-16(fp)
   3e7ec:	10bfc00c 	andi	r2,r2,65280
   3e7f0:	1006d23a 	srli	r3,r2,8
   3e7f4:	e0bffc17 	ldw	r2,-16(fp)
   3e7f8:	1004923a 	slli	r2,r2,8
   3e7fc:	10bfffcc 	andi	r2,r2,65535
   3e800:	1884b03a 	or	r2,r3,r2
   3e804:	e0bffc15 	stw	r2,-16(fp)
  }
  return (u16_t)~(acc & 0xffffUL);
   3e808:	e0bffc17 	ldw	r2,-16(fp)
   3e80c:	0084303a 	nor	r2,zero,r2
}
   3e810:	e037883a 	mov	sp,fp
   3e814:	dfc00117 	ldw	ra,4(sp)
   3e818:	df000017 	ldw	fp,0(sp)
   3e81c:	dec00204 	addi	sp,sp,8
   3e820:	f800283a 	ret

0003e824 <lwip_chksum_copy>:
 * For architectures with big caches, data might still be in cache when
 * generating the checksum after copying.
 */
u16_t
lwip_chksum_copy(void *dst, const void *src, u16_t len)
{
   3e824:	defffb04 	addi	sp,sp,-20
   3e828:	dfc00415 	stw	ra,16(sp)
   3e82c:	df000315 	stw	fp,12(sp)
   3e830:	df000304 	addi	fp,sp,12
   3e834:	e13ffd15 	stw	r4,-12(fp)
   3e838:	e17ffe15 	stw	r5,-8(fp)
   3e83c:	3005883a 	mov	r2,r6
   3e840:	e0bfff0d 	sth	r2,-4(fp)
  MEMCPY(dst, src, len);
   3e844:	e0bfff0b 	ldhu	r2,-4(fp)
   3e848:	e13ffd17 	ldw	r4,-12(fp)
   3e84c:	e17ffe17 	ldw	r5,-8(fp)
   3e850:	100d883a 	mov	r6,r2
   3e854:	00041f00 	call	41f0 <memcpy>
  return LWIP_CHKSUM(dst, len);
   3e858:	e0bfff0b 	ldhu	r2,-4(fp)
   3e85c:	e13ffd17 	ldw	r4,-12(fp)
   3e860:	100b883a 	mov	r5,r2
   3e864:	003e0640 	call	3e064 <lwip_standard_chksum>
}
   3e868:	e037883a 	mov	sp,fp
   3e86c:	dfc00117 	ldw	ra,4(sp)
   3e870:	df000017 	ldw	fp,0(sp)
   3e874:	dec00204 	addi	sp,sp,8
   3e878:	f800283a 	ret

0003e87c <alt_program_amd>:
 * then writes Addr, Data Addr, Data etc.
 */
int alt_program_amd(alt_flash_dev* flash_info, int block_offset, 
                int offset, const void* src_addr, 
                int length)
{
   3e87c:	defff704 	addi	sp,sp,-36
   3e880:	dfc00815 	stw	ra,32(sp)
   3e884:	df000715 	stw	fp,28(sp)
   3e888:	df000704 	addi	fp,sp,28
   3e88c:	e13ffc15 	stw	r4,-16(fp)
   3e890:	e17ffd15 	stw	r5,-12(fp)
   3e894:	e1bffe15 	stw	r6,-8(fp)
   3e898:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
   3e89c:	e03ffa15 	stw	zero,-24(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
   3e8a0:	e0bffc17 	ldw	r2,-16(fp)
   3e8a4:	e0bffb15 	stw	r2,-20(fp)
  
  
  ret_code = alt_flash_program_block( flash, offset, src_addr, length, 
   3e8a8:	00800134 	movhi	r2,4
   3e8ac:	10bb0404 	addi	r2,r2,-5104
   3e8b0:	d8800015 	stw	r2,0(sp)
   3e8b4:	e13ffb17 	ldw	r4,-20(fp)
   3e8b8:	e17ffe17 	ldw	r5,-8(fp)
   3e8bc:	e1bfff17 	ldw	r6,-4(fp)
   3e8c0:	e1c00217 	ldw	r7,8(fp)
   3e8c4:	0031e9c0 	call	31e9c <alt_flash_program_block>
   3e8c8:	e0bffa15 	stw	r2,-24(fp)
                                    alt_write_word_amd);
  return ret_code;
   3e8cc:	e0bffa17 	ldw	r2,-24(fp)
}
   3e8d0:	e037883a 	mov	sp,fp
   3e8d4:	dfc00117 	ldw	ra,4(sp)
   3e8d8:	df000017 	ldw	fp,0(sp)
   3e8dc:	dec00204 	addi	sp,sp,8
   3e8e0:	f800283a 	ret

0003e8e4 <alt_erase_block_amd>:
 * alt_erase_block_amd
 * 
 * Erase the selected erase block
 */
int alt_erase_block_amd(alt_flash_dev* flash_info, int block_offset)
{
   3e8e4:	defff804 	addi	sp,sp,-32
   3e8e8:	dfc00715 	stw	ra,28(sp)
   3e8ec:	df000615 	stw	fp,24(sp)
   3e8f0:	df000604 	addi	fp,sp,24
   3e8f4:	e13ffe15 	stw	r4,-8(fp)
   3e8f8:	e17fff15 	stw	r5,-4(fp)
  int   ret_code = 0;
   3e8fc:	e03ffa15 	stw	zero,-24(fp)
  int   timeout;
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
   3e900:	e0bffe17 	ldw	r2,-8(fp)
   3e904:	e0bffc15 	stw	r2,-16(fp)
  volatile alt_u8  value;

  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
   3e908:	e0bffc17 	ldw	r2,-16(fp)
   3e90c:	10c03317 	ldw	r3,204(r2)
   3e910:	e0bffc17 	ldw	r2,-16(fp)
   3e914:	10800a17 	ldw	r2,40(r2)
   3e918:	1009883a 	mov	r4,r2
   3e91c:	01415544 	movi	r5,1365
   3e920:	01802a84 	movi	r6,170
   3e924:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
   3e928:	e0bffc17 	ldw	r2,-16(fp)
   3e92c:	10c03317 	ldw	r3,204(r2)
   3e930:	e0bffc17 	ldw	r2,-16(fp)
   3e934:	10800a17 	ldw	r2,40(r2)
   3e938:	1009883a 	mov	r4,r2
   3e93c:	0140aa84 	movi	r5,682
   3e940:	01801544 	movi	r6,85
   3e944:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0x80);
   3e948:	e0bffc17 	ldw	r2,-16(fp)
   3e94c:	10c03317 	ldw	r3,204(r2)
   3e950:	e0bffc17 	ldw	r2,-16(fp)
   3e954:	10800a17 	ldw	r2,40(r2)
   3e958:	1009883a 	mov	r4,r2
   3e95c:	01415544 	movi	r5,1365
   3e960:	01802004 	movi	r6,128
   3e964:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
   3e968:	e0bffc17 	ldw	r2,-16(fp)
   3e96c:	10c03317 	ldw	r3,204(r2)
   3e970:	e0bffc17 	ldw	r2,-16(fp)
   3e974:	10800a17 	ldw	r2,40(r2)
   3e978:	1009883a 	mov	r4,r2
   3e97c:	01415544 	movi	r5,1365
   3e980:	01802a84 	movi	r6,170
   3e984:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
   3e988:	e0bffc17 	ldw	r2,-16(fp)
   3e98c:	10c03317 	ldw	r3,204(r2)
   3e990:	e0bffc17 	ldw	r2,-16(fp)
   3e994:	10800a17 	ldw	r2,40(r2)
   3e998:	1009883a 	mov	r4,r2
   3e99c:	0140aa84 	movi	r5,682
   3e9a0:	01801544 	movi	r6,85
   3e9a4:	183ee83a 	callr	r3

  (*flash->write_native)((alt_u8*)flash->dev.base_addr+block_offset, 0x30);
   3e9a8:	e0bffc17 	ldw	r2,-16(fp)
   3e9ac:	10c03517 	ldw	r3,212(r2)
   3e9b0:	e0bffc17 	ldw	r2,-16(fp)
   3e9b4:	11000a17 	ldw	r4,40(r2)
   3e9b8:	e0bfff17 	ldw	r2,-4(fp)
   3e9bc:	2085883a 	add	r2,r4,r2
   3e9c0:	1009883a 	mov	r4,r2
   3e9c4:	01400c04 	movi	r5,48
   3e9c8:	183ee83a 	callr	r3

  /*
   * Delay to meet AM29LV065D timing requirements
   */
  usleep(10000);
   3e9cc:	0109c404 	movi	r4,10000
   3e9d0:	00124300 	call	12430 <usleep>
  
  /*
   * Bit 3 indicates that the erase command has been accepted
   * this last 50S
   */
  timeout = 50;   
   3e9d4:	00800c84 	movi	r2,50
   3e9d8:	e0bffb15 	stw	r2,-20(fp)
  do 
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
   3e9dc:	e0bffc17 	ldw	r2,-16(fp)
   3e9e0:	10c00a17 	ldw	r3,40(r2)
   3e9e4:	e0bfff17 	ldw	r2,-4(fp)
   3e9e8:	1885883a 	add	r2,r3,r2
   3e9ec:	10800023 	ldbuio	r2,0(r2)
   3e9f0:	10803fcc 	andi	r2,r2,255
   3e9f4:	e0bffd05 	stb	r2,-12(fp)
    usleep(1000);
   3e9f8:	0100fa04 	movi	r4,1000
   3e9fc:	00124300 	call	12430 <usleep>
    timeout--;
   3ea00:	e0bffb17 	ldw	r2,-20(fp)
   3ea04:	10bfffc4 	addi	r2,r2,-1
   3ea08:	e0bffb15 	stw	r2,-20(fp)
  }while(!(value & 0x8) && (timeout > 0));
   3ea0c:	e0bffd03 	ldbu	r2,-12(fp)
   3ea10:	10803fcc 	andi	r2,r2,255
   3ea14:	1080020c 	andi	r2,r2,8
   3ea18:	1000021e 	bne	r2,zero,3ea24 <alt_erase_block_amd+0x140>
   3ea1c:	e0bffb17 	ldw	r2,-20(fp)
   3ea20:	00bfee16 	blt	zero,r2,3e9dc <alt_erase_block_amd+0xf8>


  timeout = flash->erase_timeout;
   3ea24:	e0bffc17 	ldw	r2,-16(fp)
   3ea28:	10803117 	ldw	r2,196(r2)
   3ea2c:	e0bffb15 	stw	r2,-20(fp)
  
  /*
   *  Bit 7 goes low until the block is erased if bit 5 goes to 
   *  1 it's an error
   */
  while (timeout > 0)
   3ea30:	00001506 	br	3ea88 <alt_erase_block_amd+0x1a4>
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
   3ea34:	e0bffc17 	ldw	r2,-16(fp)
   3ea38:	10c00a17 	ldw	r3,40(r2)
   3ea3c:	e0bfff17 	ldw	r2,-4(fp)
   3ea40:	1885883a 	add	r2,r3,r2
   3ea44:	10800023 	ldbuio	r2,0(r2)
   3ea48:	10803fcc 	andi	r2,r2,255
   3ea4c:	e0bffd05 	stb	r2,-12(fp)
    if ((value & 0x80) || (value &0x20))
   3ea50:	e0bffd03 	ldbu	r2,-12(fp)
   3ea54:	10803fcc 	andi	r2,r2,255
   3ea58:	1080201c 	xori	r2,r2,128
   3ea5c:	10bfe004 	addi	r2,r2,-128
   3ea60:	10000b16 	blt	r2,zero,3ea90 <alt_erase_block_amd+0x1ac>
   3ea64:	e0bffd03 	ldbu	r2,-12(fp)
   3ea68:	10803fcc 	andi	r2,r2,255
   3ea6c:	1080080c 	andi	r2,r2,32
   3ea70:	1000071e 	bne	r2,zero,3ea90 <alt_erase_block_amd+0x1ac>
    {
      break;
    }
    usleep(1000);
   3ea74:	0100fa04 	movi	r4,1000
   3ea78:	00124300 	call	12430 <usleep>
    timeout -= 1000;
   3ea7c:	e0bffb17 	ldw	r2,-20(fp)
   3ea80:	10bf0604 	addi	r2,r2,-1000
   3ea84:	e0bffb15 	stw	r2,-20(fp)
  
  /*
   *  Bit 7 goes low until the block is erased if bit 5 goes to 
   *  1 it's an error
   */
  while (timeout > 0)
   3ea88:	e0bffb17 	ldw	r2,-20(fp)
   3ea8c:	00bfe916 	blt	zero,r2,3ea34 <alt_erase_block_amd+0x150>
    }
    usleep(1000);
    timeout -= 1000;
  }
  
  if (timeout <= 0)
   3ea90:	e0bffb17 	ldw	r2,-20(fp)
   3ea94:	00800316 	blt	zero,r2,3eaa4 <alt_erase_block_amd+0x1c0>
  {
    ret_code = -ETIMEDOUT;
   3ea98:	00bfe304 	movi	r2,-116
   3ea9c:	e0bffa15 	stw	r2,-24(fp)
   3eaa0:	00000e06 	br	3eadc <alt_erase_block_amd+0x1f8>
  }
  else
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
   3eaa4:	e0bffc17 	ldw	r2,-16(fp)
   3eaa8:	10c00a17 	ldw	r3,40(r2)
   3eaac:	e0bfff17 	ldw	r2,-4(fp)
   3eab0:	1885883a 	add	r2,r3,r2
   3eab4:	10800023 	ldbuio	r2,0(r2)
   3eab8:	10803fcc 	andi	r2,r2,255
   3eabc:	e0bffd05 	stb	r2,-12(fp)
    if (!(value & 0x80))
   3eac0:	e0bffd03 	ldbu	r2,-12(fp)
   3eac4:	10803fcc 	andi	r2,r2,255
   3eac8:	1080201c 	xori	r2,r2,128
   3eacc:	10bfe004 	addi	r2,r2,-128
   3ead0:	10000216 	blt	r2,zero,3eadc <alt_erase_block_amd+0x1f8>
    {
      ret_code = -EIO;
   3ead4:	00bffec4 	movi	r2,-5
   3ead8:	e0bffa15 	stw	r2,-24(fp)
    }
  }    
  
  return ret_code;
   3eadc:	e0bffa17 	ldw	r2,-24(fp)
}
   3eae0:	e037883a 	mov	sp,fp
   3eae4:	dfc00117 	ldw	ra,4(sp)
   3eae8:	df000017 	ldw	fp,0(sp)
   3eaec:	dec00204 	addi	sp,sp,8
   3eaf0:	f800283a 	ret

0003eaf4 <alt_wait_for_command_to_complete_amd>:
 */
 
int alt_wait_for_command_to_complete_amd(alt_flash_cfi_dev* flash,
                                         int offset, 
                                          alt_u8 data)
{
   3eaf4:	defff804 	addi	sp,sp,-32
   3eaf8:	dfc00715 	stw	ra,28(sp)
   3eafc:	df000615 	stw	fp,24(sp)
   3eb00:	df000604 	addi	fp,sp,24
   3eb04:	e13ffd15 	stw	r4,-12(fp)
   3eb08:	e17ffe15 	stw	r5,-8(fp)
   3eb0c:	3005883a 	mov	r2,r6
   3eb10:	e0bfff05 	stb	r2,-4(fp)
  volatile alt_u8  value;
  int timeout = flash->write_timeout * 100;
   3eb14:	e0bffd17 	ldw	r2,-12(fp)
   3eb18:	10803017 	ldw	r2,192(r2)
   3eb1c:	10801924 	muli	r2,r2,100
   3eb20:	e0bffa15 	stw	r2,-24(fp)
  int ret_code = 0;
   3eb24:	e03ffb15 	stw	zero,-20(fp)
  
  value = IORD_8DIRECT(flash->dev.base_addr, offset);
   3eb28:	e0bffd17 	ldw	r2,-12(fp)
   3eb2c:	10c00a17 	ldw	r3,40(r2)
   3eb30:	e0bffe17 	ldw	r2,-8(fp)
   3eb34:	1885883a 	add	r2,r3,r2
   3eb38:	10800023 	ldbuio	r2,0(r2)
   3eb3c:	10803fcc 	andi	r2,r2,255
   3eb40:	e0bffc05 	stb	r2,-16(fp)
  while (timeout > 0)
   3eb44:	00001606 	br	3eba0 <alt_wait_for_command_to_complete_amd+0xac>
  {
    if (((value & 0x80 ) == (data &0x80)) ||
   3eb48:	e0bffc03 	ldbu	r2,-16(fp)
   3eb4c:	10c03fcc 	andi	r3,r2,255
   3eb50:	e0bfff03 	ldbu	r2,-4(fp)
   3eb54:	1884f03a 	xor	r2,r3,r2
   3eb58:	1080200c 	andi	r2,r2,128
   3eb5c:	10001226 	beq	r2,zero,3eba8 <alt_wait_for_command_to_complete_amd+0xb4>
        (value & 0x20))
   3eb60:	e0bffc03 	ldbu	r2,-16(fp)
   3eb64:	10803fcc 	andi	r2,r2,255
   3eb68:	1080080c 	andi	r2,r2,32
  int ret_code = 0;
  
  value = IORD_8DIRECT(flash->dev.base_addr, offset);
  while (timeout > 0)
  {
    if (((value & 0x80 ) == (data &0x80)) ||
   3eb6c:	10000e1e 	bne	r2,zero,3eba8 <alt_wait_for_command_to_complete_amd+0xb4>
        (value & 0x20))
    {
      break;
    }
    usleep (1);
   3eb70:	01000044 	movi	r4,1
   3eb74:	00124300 	call	12430 <usleep>
    timeout--;
   3eb78:	e0bffa17 	ldw	r2,-24(fp)
   3eb7c:	10bfffc4 	addi	r2,r2,-1
   3eb80:	e0bffa15 	stw	r2,-24(fp)
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
   3eb84:	e0bffd17 	ldw	r2,-12(fp)
   3eb88:	10c00a17 	ldw	r3,40(r2)
   3eb8c:	e0bffe17 	ldw	r2,-8(fp)
   3eb90:	1885883a 	add	r2,r3,r2
   3eb94:	10800023 	ldbuio	r2,0(r2)
   3eb98:	10803fcc 	andi	r2,r2,255
   3eb9c:	e0bffc05 	stb	r2,-16(fp)
  volatile alt_u8  value;
  int timeout = flash->write_timeout * 100;
  int ret_code = 0;
  
  value = IORD_8DIRECT(flash->dev.base_addr, offset);
  while (timeout > 0)
   3eba0:	e0bffa17 	ldw	r2,-24(fp)
   3eba4:	00bfe816 	blt	zero,r2,3eb48 <alt_wait_for_command_to_complete_amd+0x54>
    usleep (1);
    timeout--;
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
  }
  
  if (timeout == 0)
   3eba8:	e0bffa17 	ldw	r2,-24(fp)
   3ebac:	1000031e 	bne	r2,zero,3ebbc <alt_wait_for_command_to_complete_amd+0xc8>
  {
    ret_code = -ETIMEDOUT;
   3ebb0:	00bfe304 	movi	r2,-116
   3ebb4:	e0bffb15 	stw	r2,-20(fp)
   3ebb8:	00000f06 	br	3ebf8 <alt_wait_for_command_to_complete_amd+0x104>
  }
  else
  {
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
   3ebbc:	e0bffd17 	ldw	r2,-12(fp)
   3ebc0:	10c00a17 	ldw	r3,40(r2)
   3ebc4:	e0bffe17 	ldw	r2,-8(fp)
   3ebc8:	1885883a 	add	r2,r3,r2
   3ebcc:	10800023 	ldbuio	r2,0(r2)
   3ebd0:	10803fcc 	andi	r2,r2,255
   3ebd4:	e0bffc05 	stb	r2,-16(fp)
    if ((value & 0x80) != (data&0x80))
   3ebd8:	e0bffc03 	ldbu	r2,-16(fp)
   3ebdc:	10c03fcc 	andi	r3,r2,255
   3ebe0:	e0bfff03 	ldbu	r2,-4(fp)
   3ebe4:	1884f03a 	xor	r2,r3,r2
   3ebe8:	1080200c 	andi	r2,r2,128
   3ebec:	10000226 	beq	r2,zero,3ebf8 <alt_wait_for_command_to_complete_amd+0x104>
    {
      ret_code = -EIO;
   3ebf0:	00bffec4 	movi	r2,-5
   3ebf4:	e0bffb15 	stw	r2,-20(fp)
    }
  }    
  return ret_code;
   3ebf8:	e0bffb17 	ldw	r2,-20(fp)
}
   3ebfc:	e037883a 	mov	sp,fp
   3ec00:	dfc00117 	ldw	ra,4(sp)
   3ec04:	df000017 	ldw	fp,0(sp)
   3ec08:	dec00204 	addi	sp,sp,8
   3ec0c:	f800283a 	ret

0003ec10 <alt_write_word_amd>:

static int alt_write_word_amd(  alt_flash_cfi_dev* flash, 
                                const int offset, 
                                const alt_u8* src_addr)
{
   3ec10:	defff904 	addi	sp,sp,-28
   3ec14:	dfc00615 	stw	ra,24(sp)
   3ec18:	df000515 	stw	fp,20(sp)
   3ec1c:	df000504 	addi	fp,sp,20
   3ec20:	e13ffd15 	stw	r4,-12(fp)
   3ec24:	e17ffe15 	stw	r5,-8(fp)
   3ec28:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
   3ec2c:	e03ffb15 	stw	zero,-20(fp)
  alt_u8 value;
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
   3ec30:	e0bffd17 	ldw	r2,-12(fp)
   3ec34:	10c03317 	ldw	r3,204(r2)
   3ec38:	e0bffd17 	ldw	r2,-12(fp)
   3ec3c:	10800a17 	ldw	r2,40(r2)
   3ec40:	1009883a 	mov	r4,r2
   3ec44:	01415544 	movi	r5,1365
   3ec48:	01802a84 	movi	r6,170
   3ec4c:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
   3ec50:	e0bffd17 	ldw	r2,-12(fp)
   3ec54:	10c03317 	ldw	r3,204(r2)
   3ec58:	e0bffd17 	ldw	r2,-12(fp)
   3ec5c:	10800a17 	ldw	r2,40(r2)
   3ec60:	1009883a 	mov	r4,r2
   3ec64:	0140aa84 	movi	r5,682
   3ec68:	01801544 	movi	r6,85
   3ec6c:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xA0);
   3ec70:	e0bffd17 	ldw	r2,-12(fp)
   3ec74:	10c03317 	ldw	r3,204(r2)
   3ec78:	e0bffd17 	ldw	r2,-12(fp)
   3ec7c:	10800a17 	ldw	r2,40(r2)
   3ec80:	1009883a 	mov	r4,r2
   3ec84:	01415544 	movi	r5,1365
   3ec88:	01802804 	movi	r6,160
   3ec8c:	183ee83a 	callr	r3
  
  value = *src_addr;
   3ec90:	e0bfff17 	ldw	r2,-4(fp)
   3ec94:	10800003 	ldbu	r2,0(r2)
   3ec98:	e0bffc05 	stb	r2,-16(fp)

  alt_write_value_to_flash(flash, offset, src_addr);
   3ec9c:	e13ffd17 	ldw	r4,-12(fp)
   3eca0:	e17ffe17 	ldw	r5,-8(fp)
   3eca4:	e1bfff17 	ldw	r6,-4(fp)
   3eca8:	0031d440 	call	31d44 <alt_write_value_to_flash>
  
  ret_code = alt_wait_for_command_to_complete_amd(flash, 
   3ecac:	e0bffc03 	ldbu	r2,-16(fp)
   3ecb0:	e13ffd17 	ldw	r4,-12(fp)
   3ecb4:	e17ffe17 	ldw	r5,-8(fp)
   3ecb8:	100d883a 	mov	r6,r2
   3ecbc:	003eaf40 	call	3eaf4 <alt_wait_for_command_to_complete_amd>
   3ecc0:	e0bffb15 	stw	r2,-20(fp)
                                                  offset,
                                                  value);
  return ret_code;
   3ecc4:	e0bffb17 	ldw	r2,-20(fp)
  
}
   3ecc8:	e037883a 	mov	sp,fp
   3eccc:	dfc00117 	ldw	ra,4(sp)
   3ecd0:	df000017 	ldw	fp,0(sp)
   3ecd4:	dec00204 	addi	sp,sp,8
   3ecd8:	f800283a 	ret

0003ecdc <alt_program_intel>:
 * Program a block (or part of one)
 */
int alt_program_intel(alt_flash_dev* flash_info, int block_offset, 
                int offset, const void* src_addr, 
                int length)
{
   3ecdc:	defff704 	addi	sp,sp,-36
   3ece0:	dfc00815 	stw	ra,32(sp)
   3ece4:	df000715 	stw	fp,28(sp)
   3ece8:	df000704 	addi	fp,sp,28
   3ecec:	e13ffc15 	stw	r4,-16(fp)
   3ecf0:	e17ffd15 	stw	r5,-12(fp)
   3ecf4:	e1bffe15 	stw	r6,-8(fp)
   3ecf8:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
   3ecfc:	e03ffa15 	stw	zero,-24(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
   3ed00:	e0bffc17 	ldw	r2,-16(fp)
   3ed04:	e0bffb15 	stw	r2,-20(fp)
  
   /*
  * If this block is locked then unlock it
  */
  ret_code = alt_unlock_block_intel(flash, block_offset);
   3ed08:	e13ffb17 	ldw	r4,-20(fp)
   3ed0c:	e17ffd17 	ldw	r5,-12(fp)
   3ed10:	003eec40 	call	3eec4 <alt_unlock_block_intel>
   3ed14:	e0bffa15 	stw	r2,-24(fp)

  if (!ret_code)
   3ed18:	e0bffa17 	ldw	r2,-24(fp)
   3ed1c:	1000091e 	bne	r2,zero,3ed44 <alt_program_intel+0x68>
  {

    ret_code = alt_flash_program_block( flash, offset, src_addr, length, 
   3ed20:	00800134 	movhi	r2,4
   3ed24:	10bc1004 	addi	r2,r2,-4032
   3ed28:	d8800015 	stw	r2,0(sp)
   3ed2c:	e13ffb17 	ldw	r4,-20(fp)
   3ed30:	e17ffe17 	ldw	r5,-8(fp)
   3ed34:	e1bfff17 	ldw	r6,-4(fp)
   3ed38:	e1c00217 	ldw	r7,8(fp)
   3ed3c:	0031e9c0 	call	31e9c <alt_flash_program_block>
   3ed40:	e0bffa15 	stw	r2,-24(fp)
                                        alt_write_word_intel);
  }
  
  return ret_code;
   3ed44:	e0bffa17 	ldw	r2,-24(fp)
}
   3ed48:	e037883a 	mov	sp,fp
   3ed4c:	dfc00117 	ldw	ra,4(sp)
   3ed50:	df000017 	ldw	fp,0(sp)
   3ed54:	dec00204 	addi	sp,sp,8
   3ed58:	f800283a 	ret

0003ed5c <alt_erase_block_intel>:
 * alt_erase_block_intel
 * 
 * Erase the selected erase block
 */
int alt_erase_block_intel(alt_flash_dev* flash_info, int block_offset)
{
   3ed5c:	defff804 	addi	sp,sp,-32
   3ed60:	dfc00715 	stw	ra,28(sp)
   3ed64:	df000615 	stw	fp,24(sp)
   3ed68:	df000604 	addi	fp,sp,24
   3ed6c:	e13ffe15 	stw	r4,-8(fp)
   3ed70:	e17fff15 	stw	r5,-4(fp)
  int   ret_code = 0;
   3ed74:	e03ffa15 	stw	zero,-24(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
   3ed78:	e0bffe17 	ldw	r2,-8(fp)
   3ed7c:	e0bffc15 	stw	r2,-16(fp)
  volatile alt_u8  status;
  int   timeout = flash->erase_timeout;
   3ed80:	e0bffc17 	ldw	r2,-16(fp)
   3ed84:	10803117 	ldw	r2,196(r2)
   3ed88:	e0bffb15 	stw	r2,-20(fp)

  /*
  * If this block is locked then unlock it
  */
  ret_code = alt_unlock_block_intel(flash, block_offset);
   3ed8c:	e13ffc17 	ldw	r4,-16(fp)
   3ed90:	e17fff17 	ldw	r5,-4(fp)
   3ed94:	003eec40 	call	3eec4 <alt_unlock_block_intel>
   3ed98:	e0bffa15 	stw	r2,-24(fp)

  if (!ret_code)
   3ed9c:	e0bffa17 	ldw	r2,-24(fp)
   3eda0:	1000421e 	bne	r2,zero,3eeac <alt_erase_block_intel+0x150>
  {

    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x20);
   3eda4:	e0bffc17 	ldw	r2,-16(fp)
   3eda8:	10c03517 	ldw	r3,212(r2)
   3edac:	e0bffc17 	ldw	r2,-16(fp)
   3edb0:	11000a17 	ldw	r4,40(r2)
   3edb4:	e0bfff17 	ldw	r2,-4(fp)
   3edb8:	2085883a 	add	r2,r4,r2
   3edbc:	1009883a 	mov	r4,r2
   3edc0:	01400804 	movi	r5,32
   3edc4:	183ee83a 	callr	r3
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xD0);
   3edc8:	e0bffc17 	ldw	r2,-16(fp)
   3edcc:	10c03517 	ldw	r3,212(r2)
   3edd0:	e0bffc17 	ldw	r2,-16(fp)
   3edd4:	11000a17 	ldw	r4,40(r2)
   3edd8:	e0bfff17 	ldw	r2,-4(fp)
   3eddc:	2085883a 	add	r2,r4,r2
   3ede0:	1009883a 	mov	r4,r2
   3ede4:	01403404 	movi	r5,208
   3ede8:	183ee83a 	callr	r3

    do
    {
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
   3edec:	e0bffc17 	ldw	r2,-16(fp)
   3edf0:	10c00a17 	ldw	r3,40(r2)
   3edf4:	e0bfff17 	ldw	r2,-4(fp)
   3edf8:	1885883a 	add	r2,r3,r2
   3edfc:	10800023 	ldbuio	r2,0(r2)
   3ee00:	10803fcc 	andi	r2,r2,255
   3ee04:	e0bffd05 	stb	r2,-12(fp)
      if (status & 0x80)
   3ee08:	e0bffd03 	ldbu	r2,-12(fp)
   3ee0c:	10803fcc 	andi	r2,r2,255
   3ee10:	1080201c 	xori	r2,r2,128
   3ee14:	10bfe004 	addi	r2,r2,-128
   3ee18:	10000816 	blt	r2,zero,3ee3c <alt_erase_block_intel+0xe0>
      {
        break;
      }
      usleep(1000);
   3ee1c:	0100fa04 	movi	r4,1000
   3ee20:	00124300 	call	12430 <usleep>
      timeout -= 1000;
   3ee24:	e0bffb17 	ldw	r2,-20(fp)
   3ee28:	10bf0604 	addi	r2,r2,-1000
   3ee2c:	e0bffb15 	stw	r2,-20(fp)
    }while(timeout > 0);
   3ee30:	e0bffb17 	ldw	r2,-20(fp)
   3ee34:	00bfed16 	blt	zero,r2,3edec <alt_erase_block_intel+0x90>
   3ee38:	00000106 	br	3ee40 <alt_erase_block_intel+0xe4>
    do
    {
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
      if (status & 0x80)
      {
        break;
   3ee3c:	0001883a 	nop
      }
      usleep(1000);
      timeout -= 1000;
    }while(timeout > 0);
    
    if (timeout <= 0)
   3ee40:	e0bffb17 	ldw	r2,-20(fp)
   3ee44:	00800316 	blt	zero,r2,3ee54 <alt_erase_block_intel+0xf8>
    {
      ret_code = -ETIMEDOUT;
   3ee48:	00bfe304 	movi	r2,-116
   3ee4c:	e0bffa15 	stw	r2,-24(fp)
   3ee50:	00000d06 	br	3ee88 <alt_erase_block_intel+0x12c>
    }
    else if (status & 0x7f)
   3ee54:	e0bffd03 	ldbu	r2,-12(fp)
   3ee58:	10803fcc 	andi	r2,r2,255
   3ee5c:	10801fcc 	andi	r2,r2,127
   3ee60:	10000926 	beq	r2,zero,3ee88 <alt_erase_block_intel+0x12c>
    {
      /* If we have an error of some kind bomb out */
      ret_code = -EIO;
   3ee64:	00bffec4 	movi	r2,-5
   3ee68:	e0bffa15 	stw	r2,-24(fp)
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
   3ee6c:	e0bffc17 	ldw	r2,-16(fp)
   3ee70:	10c00a17 	ldw	r3,40(r2)
   3ee74:	e0bfff17 	ldw	r2,-4(fp)
   3ee78:	1885883a 	add	r2,r3,r2
   3ee7c:	10800023 	ldbuio	r2,0(r2)
   3ee80:	10803fcc 	andi	r2,r2,255
   3ee84:	e0bffd05 	stb	r2,-12(fp)
    }

    /* Put the device back into read array mode */
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xFF);
   3ee88:	e0bffc17 	ldw	r2,-16(fp)
   3ee8c:	10c03517 	ldw	r3,212(r2)
   3ee90:	e0bffc17 	ldw	r2,-16(fp)
   3ee94:	11000a17 	ldw	r4,40(r2)
   3ee98:	e0bfff17 	ldw	r2,-4(fp)
   3ee9c:	2085883a 	add	r2,r4,r2
   3eea0:	1009883a 	mov	r4,r2
   3eea4:	01403fc4 	movi	r5,255
   3eea8:	183ee83a 	callr	r3
  }
  
  return ret_code;
   3eeac:	e0bffa17 	ldw	r2,-24(fp)
}
   3eeb0:	e037883a 	mov	sp,fp
   3eeb4:	dfc00117 	ldw	ra,4(sp)
   3eeb8:	df000017 	ldw	fp,0(sp)
   3eebc:	dec00204 	addi	sp,sp,8
   3eec0:	f800283a 	ret

0003eec4 <alt_unlock_block_intel>:
/*
* Private Intel specific functions
*/

static int alt_unlock_block_intel(alt_flash_cfi_dev* flash, int block_offset)
{
   3eec4:	defff904 	addi	sp,sp,-28
   3eec8:	dfc00615 	stw	ra,24(sp)
   3eecc:	df000515 	stw	fp,20(sp)
   3eed0:	df000504 	addi	fp,sp,20
   3eed4:	e13ffe15 	stw	r4,-8(fp)
   3eed8:	e17fff15 	stw	r5,-4(fp)
  alt_u8  locked;
  alt_u8  status;
  int ret_code = 0;
   3eedc:	e03ffb15 	stw	zero,-20(fp)
  int timeout = flash->write_timeout * 100;
   3eee0:	e0bffe17 	ldw	r2,-8(fp)
   3eee4:	10803017 	ldw	r2,192(r2)
   3eee8:	10801924 	muli	r2,r2,100
   3eeec:	e0bffc15 	stw	r2,-16(fp)


  /*
  * Is this block locked?
  */
  flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x90);
   3eef0:	e0bffe17 	ldw	r2,-8(fp)
   3eef4:	10c03517 	ldw	r3,212(r2)
   3eef8:	e0bffe17 	ldw	r2,-8(fp)
   3eefc:	11000a17 	ldw	r4,40(r2)
   3ef00:	e0bfff17 	ldw	r2,-4(fp)
   3ef04:	2085883a 	add	r2,r4,r2
   3ef08:	1009883a 	mov	r4,r2
   3ef0c:	01402404 	movi	r5,144
   3ef10:	183ee83a 	callr	r3
  locked = IORD_8DIRECT(flash->dev.base_addr, block_offset + 4);
   3ef14:	e0bffe17 	ldw	r2,-8(fp)
   3ef18:	10c00a17 	ldw	r3,40(r2)
   3ef1c:	e0bfff17 	ldw	r2,-4(fp)
   3ef20:	10800104 	addi	r2,r2,4
   3ef24:	1885883a 	add	r2,r3,r2
   3ef28:	10800023 	ldbuio	r2,0(r2)
   3ef2c:	10803fcc 	andi	r2,r2,255
   3ef30:	e0bffd05 	stb	r2,-12(fp)
  if (locked & 0x1)
   3ef34:	e0bffd03 	ldbu	r2,-12(fp)
   3ef38:	1080004c 	andi	r2,r2,1
   3ef3c:	10003126 	beq	r2,zero,3f004 <alt_unlock_block_intel+0x140>
  {
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x60);
   3ef40:	e0bffe17 	ldw	r2,-8(fp)
   3ef44:	10c03517 	ldw	r3,212(r2)
   3ef48:	e0bffe17 	ldw	r2,-8(fp)
   3ef4c:	11000a17 	ldw	r4,40(r2)
   3ef50:	e0bfff17 	ldw	r2,-4(fp)
   3ef54:	2085883a 	add	r2,r4,r2
   3ef58:	1009883a 	mov	r4,r2
   3ef5c:	01401804 	movi	r5,96
   3ef60:	183ee83a 	callr	r3
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xD0);
   3ef64:	e0bffe17 	ldw	r2,-8(fp)
   3ef68:	10c03517 	ldw	r3,212(r2)
   3ef6c:	e0bffe17 	ldw	r2,-8(fp)
   3ef70:	11000a17 	ldw	r4,40(r2)
   3ef74:	e0bfff17 	ldw	r2,-4(fp)
   3ef78:	2085883a 	add	r2,r4,r2
   3ef7c:	1009883a 	mov	r4,r2
   3ef80:	01403404 	movi	r5,208
   3ef84:	183ee83a 	callr	r3

    do
    {
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
   3ef88:	e0bffe17 	ldw	r2,-8(fp)
   3ef8c:	10c00a17 	ldw	r3,40(r2)
   3ef90:	e0bfff17 	ldw	r2,-4(fp)
   3ef94:	1885883a 	add	r2,r3,r2
   3ef98:	10800023 	ldbuio	r2,0(r2)
   3ef9c:	10803fcc 	andi	r2,r2,255
   3efa0:	e0bffd45 	stb	r2,-11(fp)
      if (status & 0x80)
   3efa4:	e0bffd43 	ldbu	r2,-11(fp)
   3efa8:	10803fcc 	andi	r2,r2,255
   3efac:	1080201c 	xori	r2,r2,128
   3efb0:	10bfe004 	addi	r2,r2,-128
   3efb4:	10000816 	blt	r2,zero,3efd8 <alt_unlock_block_intel+0x114>
      {
        break;
      }
      timeout--;
   3efb8:	e0bffc17 	ldw	r2,-16(fp)
   3efbc:	10bfffc4 	addi	r2,r2,-1
   3efc0:	e0bffc15 	stw	r2,-16(fp)
      usleep(1);
   3efc4:	01000044 	movi	r4,1
   3efc8:	00124300 	call	12430 <usleep>
    }while(timeout > 0);
   3efcc:	e0bffc17 	ldw	r2,-16(fp)
   3efd0:	00bfed16 	blt	zero,r2,3ef88 <alt_unlock_block_intel+0xc4>
   3efd4:	00000106 	br	3efdc <alt_unlock_block_intel+0x118>
    do
    {
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
      if (status & 0x80)
      {
        break;
   3efd8:	0001883a 	nop
      }
      timeout--;
      usleep(1);
    }while(timeout > 0);

    if (timeout == 0)
   3efdc:	e0bffc17 	ldw	r2,-16(fp)
   3efe0:	1000031e 	bne	r2,zero,3eff0 <alt_unlock_block_intel+0x12c>
    {
      ret_code = -ETIMEDOUT;
   3efe4:	00bfe304 	movi	r2,-116
   3efe8:	e0bffb15 	stw	r2,-20(fp)
   3efec:	00000506 	br	3f004 <alt_unlock_block_intel+0x140>
    }
    else if (status & 0x7f)
   3eff0:	e0bffd43 	ldbu	r2,-11(fp)
   3eff4:	10801fcc 	andi	r2,r2,127
   3eff8:	10000226 	beq	r2,zero,3f004 <alt_unlock_block_intel+0x140>
    {
      /* If we have an error of some kind bomb out */
      ret_code = -EIO;
   3effc:	00bffec4 	movi	r2,-5
   3f000:	e0bffb15 	stw	r2,-20(fp)
  }

  /*
  * Back to Read Array mode
  */
  flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xFF);
   3f004:	e0bffe17 	ldw	r2,-8(fp)
   3f008:	10c03517 	ldw	r3,212(r2)
   3f00c:	e0bffe17 	ldw	r2,-8(fp)
   3f010:	11000a17 	ldw	r4,40(r2)
   3f014:	e0bfff17 	ldw	r2,-4(fp)
   3f018:	2085883a 	add	r2,r4,r2
   3f01c:	1009883a 	mov	r4,r2
   3f020:	01403fc4 	movi	r5,255
   3f024:	183ee83a 	callr	r3

  return ret_code;
   3f028:	e0bffb17 	ldw	r2,-20(fp)
}
   3f02c:	e037883a 	mov	sp,fp
   3f030:	dfc00117 	ldw	ra,4(sp)
   3f034:	df000017 	ldw	fp,0(sp)
   3f038:	dec00204 	addi	sp,sp,8
   3f03c:	f800283a 	ret

0003f040 <alt_write_word_intel>:
 * offset bytes into the flash
 */
 
int alt_write_word_intel( alt_flash_cfi_dev* flash, 
                                  const int offset, const alt_u8* src_addr)
{ 
   3f040:	defff904 	addi	sp,sp,-28
   3f044:	dfc00615 	stw	ra,24(sp)
   3f048:	df000515 	stw	fp,20(sp)
   3f04c:	df000504 	addi	fp,sp,20
   3f050:	e13ffd15 	stw	r4,-12(fp)
   3f054:	e17ffe15 	stw	r5,-8(fp)
   3f058:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
   3f05c:	e03ffb15 	stw	zero,-20(fp)
  alt_u8 status;
  (*flash->write_native)((alt_u8*)flash->dev.base_addr+offset, 0x40);
   3f060:	e0bffd17 	ldw	r2,-12(fp)
   3f064:	10c03517 	ldw	r3,212(r2)
   3f068:	e0bffd17 	ldw	r2,-12(fp)
   3f06c:	11000a17 	ldw	r4,40(r2)
   3f070:	e0bffe17 	ldw	r2,-8(fp)
   3f074:	2085883a 	add	r2,r4,r2
   3f078:	1009883a 	mov	r4,r2
   3f07c:	01401004 	movi	r5,64
   3f080:	183ee83a 	callr	r3
  alt_write_value_to_flash(flash, offset, src_addr);
   3f084:	e13ffd17 	ldw	r4,-12(fp)
   3f088:	e17ffe17 	ldw	r5,-8(fp)
   3f08c:	e1bfff17 	ldw	r6,-4(fp)
   3f090:	0031d440 	call	31d44 <alt_write_value_to_flash>

  do
  {
    status = IORD_8DIRECT(flash->dev.base_addr, offset);
   3f094:	e0bffd17 	ldw	r2,-12(fp)
   3f098:	10c00a17 	ldw	r3,40(r2)
   3f09c:	e0bffe17 	ldw	r2,-8(fp)
   3f0a0:	1885883a 	add	r2,r3,r2
   3f0a4:	10800023 	ldbuio	r2,0(r2)
   3f0a8:	10803fcc 	andi	r2,r2,255
   3f0ac:	e0bffc05 	stb	r2,-16(fp)
  }while(!(status & 0x80));
   3f0b0:	e0bffc03 	ldbu	r2,-16(fp)
   3f0b4:	10803fcc 	andi	r2,r2,255
   3f0b8:	1080201c 	xori	r2,r2,128
   3f0bc:	10bfe004 	addi	r2,r2,-128
   3f0c0:	103ff40e 	bge	r2,zero,3f094 <alt_write_word_intel+0x54>

  /* If we have an error of some kind bomb out */
  if (status & 0x7f)
   3f0c4:	e0bffc03 	ldbu	r2,-16(fp)
   3f0c8:	10801fcc 	andi	r2,r2,127
   3f0cc:	10000226 	beq	r2,zero,3f0d8 <alt_write_word_intel+0x98>
  {
    ret_code = -EIO;
   3f0d0:	00bffec4 	movi	r2,-5
   3f0d4:	e0bffb15 	stw	r2,-20(fp)
  }

  /* Put the device back into read array mode */
  flash->write_native((alt_u8*)flash->dev.base_addr + offset, 0xFF);
   3f0d8:	e0bffd17 	ldw	r2,-12(fp)
   3f0dc:	10c03517 	ldw	r3,212(r2)
   3f0e0:	e0bffd17 	ldw	r2,-12(fp)
   3f0e4:	11000a17 	ldw	r4,40(r2)
   3f0e8:	e0bffe17 	ldw	r2,-8(fp)
   3f0ec:	2085883a 	add	r2,r4,r2
   3f0f0:	1009883a 	mov	r4,r2
   3f0f4:	01403fc4 	movi	r5,255
   3f0f8:	183ee83a 	callr	r3
  
  return ret_code;
   3f0fc:	e0bffb17 	ldw	r2,-20(fp)
}
   3f100:	e037883a 	mov	sp,fp
   3f104:	dfc00117 	ldw	ra,4(sp)
   3f108:	df000017 	ldw	fp,0(sp)
   3f10c:	dec00204 	addi	sp,sp,8
   3f110:	f800283a 	ret

0003f114 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
   3f114:	defffb04 	addi	sp,sp,-20
   3f118:	df000415 	stw	fp,16(sp)
   3f11c:	df000404 	addi	fp,sp,16
   3f120:	e13ffe15 	stw	r4,-8(fp)
   3f124:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
   3f128:	e0bfff17 	ldw	r2,-4(fp)
   3f12c:	10840070 	cmpltui	r2,r2,4097
   3f130:	1000021e 	bne	r2,zero,3f13c <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
   3f134:	00840004 	movi	r2,4096
   3f138:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
   3f13c:	e0fffe17 	ldw	r3,-8(fp)
   3f140:	e0bfff17 	ldw	r2,-4(fp)
   3f144:	1885883a 	add	r2,r3,r2
   3f148:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
   3f14c:	e0bffe17 	ldw	r2,-8(fp)
   3f150:	e0bffc15 	stw	r2,-16(fp)
   3f154:	00000506 	br	3f16c <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
   3f158:	e0bffc17 	ldw	r2,-16(fp)
   3f15c:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
   3f160:	e0bffc17 	ldw	r2,-16(fp)
   3f164:	10800804 	addi	r2,r2,32
   3f168:	e0bffc15 	stw	r2,-16(fp)
   3f16c:	e0fffc17 	ldw	r3,-16(fp)
   3f170:	e0bffd17 	ldw	r2,-12(fp)
   3f174:	18bff836 	bltu	r3,r2,3f158 <alt_icache_flush+0x44>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
   3f178:	e0bffe17 	ldw	r2,-8(fp)
   3f17c:	108007cc 	andi	r2,r2,31
   3f180:	10000226 	beq	r2,zero,3f18c <alt_icache_flush+0x78>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
   3f184:	e0bffc17 	ldw	r2,-16(fp)
   3f188:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
   3f18c:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
   3f190:	e037883a 	mov	sp,fp
   3f194:	df000017 	ldw	fp,0(sp)
   3f198:	dec00104 	addi	sp,sp,4
   3f19c:	f800283a 	ret

0003f1a0 <atexit>:
   3f1a0:	200b883a 	mov	r5,r4
   3f1a4:	000d883a 	mov	r6,zero
   3f1a8:	0009883a 	mov	r4,zero
   3f1ac:	000f883a 	mov	r7,zero
   3f1b0:	003f4a81 	jmpi	3f4a8 <__register_exitproc>

0003f1b4 <__errno>:
   3f1b4:	00800134 	movhi	r2,4
   3f1b8:	1095bf04 	addi	r2,r2,22268
   3f1bc:	10800017 	ldw	r2,0(r2)
   3f1c0:	f800283a 	ret

0003f1c4 <exit>:
   3f1c4:	defffe04 	addi	sp,sp,-8
   3f1c8:	000b883a 	mov	r5,zero
   3f1cc:	dc000015 	stw	r16,0(sp)
   3f1d0:	dfc00115 	stw	ra,4(sp)
   3f1d4:	2021883a 	mov	r16,r4
   3f1d8:	003f5d80 	call	3f5d8 <__call_exitprocs>
   3f1dc:	00800134 	movhi	r2,4
   3f1e0:	1095be04 	addi	r2,r2,22264
   3f1e4:	11000017 	ldw	r4,0(r2)
   3f1e8:	20800f17 	ldw	r2,60(r4)
   3f1ec:	10000126 	beq	r2,zero,3f1f4 <exit+0x30>
   3f1f0:	103ee83a 	callr	r2
   3f1f4:	8009883a 	mov	r4,r16
   3f1f8:	003f7780 	call	3f778 <_exit>

0003f1fc <malloc>:
   3f1fc:	00800134 	movhi	r2,4
   3f200:	1095bf04 	addi	r2,r2,22268
   3f204:	200b883a 	mov	r5,r4
   3f208:	11000017 	ldw	r4,0(r2)
   3f20c:	0009a0c1 	jmpi	9a0c <_malloc_r>

0003f210 <free>:
   3f210:	00800134 	movhi	r2,4
   3f214:	1095bf04 	addi	r2,r2,22268
   3f218:	200b883a 	mov	r5,r4
   3f21c:	11000017 	ldw	r4,0(r2)
   3f220:	0008e741 	jmpi	8e74 <_free_r>

0003f224 <memcmp>:
   3f224:	01c000c4 	movi	r7,3
   3f228:	3980192e 	bgeu	r7,r6,3f290 <memcmp+0x6c>
   3f22c:	2904b03a 	or	r2,r5,r4
   3f230:	11c4703a 	and	r2,r2,r7
   3f234:	10000f26 	beq	r2,zero,3f274 <memcmp+0x50>
   3f238:	20c00003 	ldbu	r3,0(r4)
   3f23c:	28800003 	ldbu	r2,0(r5)
   3f240:	1880151e 	bne	r3,r2,3f298 <memcmp+0x74>
   3f244:	31bfff84 	addi	r6,r6,-2
   3f248:	01ffffc4 	movi	r7,-1
   3f24c:	00000406 	br	3f260 <memcmp+0x3c>
   3f250:	20c00003 	ldbu	r3,0(r4)
   3f254:	28800003 	ldbu	r2,0(r5)
   3f258:	31bfffc4 	addi	r6,r6,-1
   3f25c:	18800e1e 	bne	r3,r2,3f298 <memcmp+0x74>
   3f260:	21000044 	addi	r4,r4,1
   3f264:	29400044 	addi	r5,r5,1
   3f268:	31fff91e 	bne	r6,r7,3f250 <memcmp+0x2c>
   3f26c:	0005883a 	mov	r2,zero
   3f270:	f800283a 	ret
   3f274:	20c00017 	ldw	r3,0(r4)
   3f278:	28800017 	ldw	r2,0(r5)
   3f27c:	1880041e 	bne	r3,r2,3f290 <memcmp+0x6c>
   3f280:	31bfff04 	addi	r6,r6,-4
   3f284:	21000104 	addi	r4,r4,4
   3f288:	29400104 	addi	r5,r5,4
   3f28c:	39bff936 	bltu	r7,r6,3f274 <memcmp+0x50>
   3f290:	303fe91e 	bne	r6,zero,3f238 <memcmp+0x14>
   3f294:	003ff506 	br	3f26c <memcmp+0x48>
   3f298:	1885c83a 	sub	r2,r3,r2
   3f29c:	f800283a 	ret

0003f2a0 <_snprintf_r>:
   3f2a0:	deffe604 	addi	sp,sp,-104
   3f2a4:	dc401815 	stw	r17,96(sp)
   3f2a8:	dc001715 	stw	r16,92(sp)
   3f2ac:	dfc01915 	stw	ra,100(sp)
   3f2b0:	3021883a 	mov	r16,r6
   3f2b4:	2023883a 	mov	r17,r4
   3f2b8:	30001e16 	blt	r6,zero,3f334 <_snprintf_r+0x94>
   3f2bc:	00808204 	movi	r2,520
   3f2c0:	d880030d 	sth	r2,12(sp)
   3f2c4:	d9400015 	stw	r5,0(sp)
   3f2c8:	d9400415 	stw	r5,16(sp)
   3f2cc:	3000141e 	bne	r6,zero,3f320 <_snprintf_r+0x80>
   3f2d0:	0005883a 	mov	r2,zero
   3f2d4:	380d883a 	mov	r6,r7
   3f2d8:	d8800215 	stw	r2,8(sp)
   3f2dc:	d8800515 	stw	r2,20(sp)
   3f2e0:	8809883a 	mov	r4,r17
   3f2e4:	00bfffc4 	movi	r2,-1
   3f2e8:	d80b883a 	mov	r5,sp
   3f2ec:	d9c01a04 	addi	r7,sp,104
   3f2f0:	d880038d 	sth	r2,14(sp)
   3f2f4:	0004f600 	call	4f60 <___vfprintf_internal_r>
   3f2f8:	00ffffc4 	movi	r3,-1
   3f2fc:	10c00a16 	blt	r2,r3,3f328 <_snprintf_r+0x88>
   3f300:	80000226 	beq	r16,zero,3f30c <_snprintf_r+0x6c>
   3f304:	d8c00017 	ldw	r3,0(sp)
   3f308:	18000005 	stb	zero,0(r3)
   3f30c:	dfc01917 	ldw	ra,100(sp)
   3f310:	dc401817 	ldw	r17,96(sp)
   3f314:	dc001717 	ldw	r16,92(sp)
   3f318:	dec01a04 	addi	sp,sp,104
   3f31c:	f800283a 	ret
   3f320:	30bfffc4 	addi	r2,r6,-1
   3f324:	003feb06 	br	3f2d4 <_snprintf_r+0x34>
   3f328:	00c022c4 	movi	r3,139
   3f32c:	88c00015 	stw	r3,0(r17)
   3f330:	003ff306 	br	3f300 <_snprintf_r+0x60>
   3f334:	008022c4 	movi	r2,139
   3f338:	20800015 	stw	r2,0(r4)
   3f33c:	00bfffc4 	movi	r2,-1
   3f340:	003ff206 	br	3f30c <_snprintf_r+0x6c>

0003f344 <snprintf>:
   3f344:	deffe504 	addi	sp,sp,-108
   3f348:	dc001715 	stw	r16,92(sp)
   3f34c:	2821883a 	mov	r16,r5
   3f350:	dfc01915 	stw	ra,100(sp)
   3f354:	dc401815 	stw	r17,96(sp)
   3f358:	d9c01a15 	stw	r7,104(sp)
   3f35c:	00800134 	movhi	r2,4
   3f360:	1095bf04 	addi	r2,r2,22268
   3f364:	14400017 	ldw	r17,0(r2)
   3f368:	28001d16 	blt	r5,zero,3f3e0 <snprintf+0x9c>
   3f36c:	00c08204 	movi	r3,520
   3f370:	d8c0030d 	sth	r3,12(sp)
   3f374:	d9000015 	stw	r4,0(sp)
   3f378:	d9000415 	stw	r4,16(sp)
   3f37c:	2800131e 	bne	r5,zero,3f3cc <snprintf+0x88>
   3f380:	0007883a 	mov	r3,zero
   3f384:	11000017 	ldw	r4,0(r2)
   3f388:	d80b883a 	mov	r5,sp
   3f38c:	00bfffc4 	movi	r2,-1
   3f390:	d9c01a04 	addi	r7,sp,104
   3f394:	d8c00215 	stw	r3,8(sp)
   3f398:	d8c00515 	stw	r3,20(sp)
   3f39c:	d880038d 	sth	r2,14(sp)
   3f3a0:	0004f600 	call	4f60 <___vfprintf_internal_r>
   3f3a4:	00ffffc4 	movi	r3,-1
   3f3a8:	10c00a16 	blt	r2,r3,3f3d4 <snprintf+0x90>
   3f3ac:	80000226 	beq	r16,zero,3f3b8 <snprintf+0x74>
   3f3b0:	d8c00017 	ldw	r3,0(sp)
   3f3b4:	18000005 	stb	zero,0(r3)
   3f3b8:	dfc01917 	ldw	ra,100(sp)
   3f3bc:	dc401817 	ldw	r17,96(sp)
   3f3c0:	dc001717 	ldw	r16,92(sp)
   3f3c4:	dec01b04 	addi	sp,sp,108
   3f3c8:	f800283a 	ret
   3f3cc:	28ffffc4 	addi	r3,r5,-1
   3f3d0:	003fec06 	br	3f384 <snprintf+0x40>
   3f3d4:	00c022c4 	movi	r3,139
   3f3d8:	88c00015 	stw	r3,0(r17)
   3f3dc:	003ff306 	br	3f3ac <snprintf+0x68>
   3f3e0:	008022c4 	movi	r2,139
   3f3e4:	88800015 	stw	r2,0(r17)
   3f3e8:	00bfffc4 	movi	r2,-1
   3f3ec:	003ff206 	br	3f3b8 <snprintf+0x74>

0003f3f0 <strncpy>:
   3f3f0:	2906b03a 	or	r3,r5,r4
   3f3f4:	18c000cc 	andi	r3,r3,3
   3f3f8:	2005883a 	mov	r2,r4
   3f3fc:	1800261e 	bne	r3,zero,3f498 <strncpy+0xa8>
   3f400:	02c000c4 	movi	r11,3
   3f404:	200f883a 	mov	r7,r4
   3f408:	59800f2e 	bgeu	r11,r6,3f448 <strncpy+0x58>
   3f40c:	02bfbff4 	movhi	r10,65279
   3f410:	52bfbfc4 	addi	r10,r10,-257
   3f414:	01202074 	movhi	r4,32897
   3f418:	21202004 	addi	r4,r4,-32640
   3f41c:	28c00017 	ldw	r3,0(r5)
   3f420:	00d2303a 	nor	r9,zero,r3
   3f424:	1a91883a 	add	r8,r3,r10
   3f428:	4a10703a 	and	r8,r9,r8
   3f42c:	4110703a 	and	r8,r8,r4
   3f430:	4000051e 	bne	r8,zero,3f448 <strncpy+0x58>
   3f434:	38c00015 	stw	r3,0(r7)
   3f438:	31bfff04 	addi	r6,r6,-4
   3f43c:	39c00104 	addi	r7,r7,4
   3f440:	29400104 	addi	r5,r5,4
   3f444:	59bff536 	bltu	r11,r6,3f41c <strncpy+0x2c>
   3f448:	30001226 	beq	r6,zero,3f494 <strncpy+0xa4>
   3f44c:	29000007 	ldb	r4,0(r5)
   3f450:	31bfffc4 	addi	r6,r6,-1
   3f454:	38c00044 	addi	r3,r7,1
   3f458:	39000005 	stb	r4,0(r7)
   3f45c:	29400044 	addi	r5,r5,1
   3f460:	20000726 	beq	r4,zero,3f480 <strncpy+0x90>
   3f464:	30000e26 	beq	r6,zero,3f4a0 <strncpy+0xb0>
   3f468:	29c00007 	ldb	r7,0(r5)
   3f46c:	18c00044 	addi	r3,r3,1
   3f470:	31bfffc4 	addi	r6,r6,-1
   3f474:	19ffffc5 	stb	r7,-1(r3)
   3f478:	29400044 	addi	r5,r5,1
   3f47c:	383ff91e 	bne	r7,zero,3f464 <strncpy+0x74>
   3f480:	198b883a 	add	r5,r3,r6
   3f484:	30000726 	beq	r6,zero,3f4a4 <strncpy+0xb4>
   3f488:	18000005 	stb	zero,0(r3)
   3f48c:	18c00044 	addi	r3,r3,1
   3f490:	197ffd1e 	bne	r3,r5,3f488 <strncpy+0x98>
   3f494:	f800283a 	ret
   3f498:	200f883a 	mov	r7,r4
   3f49c:	003fea06 	br	3f448 <strncpy+0x58>
   3f4a0:	f800283a 	ret
   3f4a4:	f800283a 	ret

0003f4a8 <__register_exitproc>:
   3f4a8:	defffa04 	addi	sp,sp,-24
   3f4ac:	00800134 	movhi	r2,4
   3f4b0:	1095be04 	addi	r2,r2,22264
   3f4b4:	dc000315 	stw	r16,12(sp)
   3f4b8:	14000017 	ldw	r16,0(r2)
   3f4bc:	dc400415 	stw	r17,16(sp)
   3f4c0:	dfc00515 	stw	ra,20(sp)
   3f4c4:	80805217 	ldw	r2,328(r16)
   3f4c8:	2023883a 	mov	r17,r4
   3f4cc:	10003e26 	beq	r2,zero,3f5c8 <__register_exitproc+0x120>
   3f4d0:	10c00117 	ldw	r3,4(r2)
   3f4d4:	020007c4 	movi	r8,31
   3f4d8:	40c0180e 	bge	r8,r3,3f53c <__register_exitproc+0x94>
   3f4dc:	00800134 	movhi	r2,4
   3f4e0:	10bc7f04 	addi	r2,r2,-3588
   3f4e4:	1000061e 	bne	r2,zero,3f500 <__register_exitproc+0x58>
   3f4e8:	00bfffc4 	movi	r2,-1
   3f4ec:	dfc00517 	ldw	ra,20(sp)
   3f4f0:	dc400417 	ldw	r17,16(sp)
   3f4f4:	dc000317 	ldw	r16,12(sp)
   3f4f8:	dec00604 	addi	sp,sp,24
   3f4fc:	f800283a 	ret
   3f500:	01006404 	movi	r4,400
   3f504:	d9400015 	stw	r5,0(sp)
   3f508:	d9800115 	stw	r6,4(sp)
   3f50c:	d9c00215 	stw	r7,8(sp)
   3f510:	003f1fc0 	call	3f1fc <malloc>
   3f514:	d9400017 	ldw	r5,0(sp)
   3f518:	d9800117 	ldw	r6,4(sp)
   3f51c:	d9c00217 	ldw	r7,8(sp)
   3f520:	103ff126 	beq	r2,zero,3f4e8 <__register_exitproc+0x40>
   3f524:	80c05217 	ldw	r3,328(r16)
   3f528:	10000115 	stw	zero,4(r2)
   3f52c:	10c00015 	stw	r3,0(r2)
   3f530:	80805215 	stw	r2,328(r16)
   3f534:	10006215 	stw	zero,392(r2)
   3f538:	10006315 	stw	zero,396(r2)
   3f53c:	10c00117 	ldw	r3,4(r2)
   3f540:	88000d1e 	bne	r17,zero,3f578 <__register_exitproc+0xd0>
   3f544:	19000084 	addi	r4,r3,2
   3f548:	2109883a 	add	r4,r4,r4
   3f54c:	18c00044 	addi	r3,r3,1
   3f550:	2109883a 	add	r4,r4,r4
   3f554:	1109883a 	add	r4,r2,r4
   3f558:	10c00115 	stw	r3,4(r2)
   3f55c:	0005883a 	mov	r2,zero
   3f560:	21400015 	stw	r5,0(r4)
   3f564:	dfc00517 	ldw	ra,20(sp)
   3f568:	dc400417 	ldw	r17,16(sp)
   3f56c:	dc000317 	ldw	r16,12(sp)
   3f570:	dec00604 	addi	sp,sp,24
   3f574:	f800283a 	ret
   3f578:	02400044 	movi	r9,1
   3f57c:	12806217 	ldw	r10,392(r2)
   3f580:	48d2983a 	sll	r9,r9,r3
   3f584:	19000804 	addi	r4,r3,32
   3f588:	18d1883a 	add	r8,r3,r3
   3f58c:	2109883a 	add	r4,r4,r4
   3f590:	4211883a 	add	r8,r8,r8
   3f594:	2109883a 	add	r4,r4,r4
   3f598:	1109883a 	add	r4,r2,r4
   3f59c:	1211883a 	add	r8,r2,r8
   3f5a0:	5254b03a 	or	r10,r10,r9
   3f5a4:	21c02215 	stw	r7,136(r4)
   3f5a8:	41802215 	stw	r6,136(r8)
   3f5ac:	12806215 	stw	r10,392(r2)
   3f5b0:	01000084 	movi	r4,2
   3f5b4:	893fe31e 	bne	r17,r4,3f544 <__register_exitproc+0x9c>
   3f5b8:	11006317 	ldw	r4,396(r2)
   3f5bc:	2252b03a 	or	r9,r4,r9
   3f5c0:	12406315 	stw	r9,396(r2)
   3f5c4:	003fdf06 	br	3f544 <__register_exitproc+0x9c>
   3f5c8:	008001f4 	movhi	r2,7
   3f5cc:	10ad1b04 	addi	r2,r2,-19348
   3f5d0:	80805215 	stw	r2,328(r16)
   3f5d4:	003fbe06 	br	3f4d0 <__register_exitproc+0x28>

0003f5d8 <__call_exitprocs>:
   3f5d8:	00800134 	movhi	r2,4
   3f5dc:	1095be04 	addi	r2,r2,22264
   3f5e0:	10800017 	ldw	r2,0(r2)
   3f5e4:	defff304 	addi	sp,sp,-52
   3f5e8:	df000b15 	stw	fp,44(sp)
   3f5ec:	d8800015 	stw	r2,0(sp)
   3f5f0:	10805204 	addi	r2,r2,328
   3f5f4:	dd400815 	stw	r21,32(sp)
   3f5f8:	dfc00c15 	stw	ra,48(sp)
   3f5fc:	ddc00a15 	stw	r23,40(sp)
   3f600:	dd800915 	stw	r22,36(sp)
   3f604:	dd000715 	stw	r20,28(sp)
   3f608:	dcc00615 	stw	r19,24(sp)
   3f60c:	dc800515 	stw	r18,20(sp)
   3f610:	dc400415 	stw	r17,16(sp)
   3f614:	dc000315 	stw	r16,12(sp)
   3f618:	d9000115 	stw	r4,4(sp)
   3f61c:	2839883a 	mov	fp,r5
   3f620:	d8800215 	stw	r2,8(sp)
   3f624:	057fffc4 	movi	r21,-1
   3f628:	d8800017 	ldw	r2,0(sp)
   3f62c:	ddc00217 	ldw	r23,8(sp)
   3f630:	14805217 	ldw	r18,328(r2)
   3f634:	90001726 	beq	r18,zero,3f694 <__call_exitprocs+0xbc>
   3f638:	94400117 	ldw	r17,4(r18)
   3f63c:	8c3fffc4 	addi	r16,r17,-1
   3f640:	80001116 	blt	r16,zero,3f688 <__call_exitprocs+0xb0>
   3f644:	8c400044 	addi	r17,r17,1
   3f648:	8427883a 	add	r19,r16,r16
   3f64c:	8c63883a 	add	r17,r17,r17
   3f650:	95802204 	addi	r22,r18,136
   3f654:	9ce7883a 	add	r19,r19,r19
   3f658:	8c63883a 	add	r17,r17,r17
   3f65c:	b4e7883a 	add	r19,r22,r19
   3f660:	9463883a 	add	r17,r18,r17
   3f664:	e0001726 	beq	fp,zero,3f6c4 <__call_exitprocs+0xec>
   3f668:	8c87c83a 	sub	r3,r17,r18
   3f66c:	b0c7883a 	add	r3,r22,r3
   3f670:	18c01e17 	ldw	r3,120(r3)
   3f674:	1f001326 	beq	r3,fp,3f6c4 <__call_exitprocs+0xec>
   3f678:	843fffc4 	addi	r16,r16,-1
   3f67c:	9cffff04 	addi	r19,r19,-4
   3f680:	8c7fff04 	addi	r17,r17,-4
   3f684:	857ff71e 	bne	r16,r21,3f664 <__call_exitprocs+0x8c>
   3f688:	00800134 	movhi	r2,4
   3f68c:	10bc8404 	addi	r2,r2,-3568
   3f690:	10002a1e 	bne	r2,zero,3f73c <__call_exitprocs+0x164>
   3f694:	dfc00c17 	ldw	ra,48(sp)
   3f698:	df000b17 	ldw	fp,44(sp)
   3f69c:	ddc00a17 	ldw	r23,40(sp)
   3f6a0:	dd800917 	ldw	r22,36(sp)
   3f6a4:	dd400817 	ldw	r21,32(sp)
   3f6a8:	dd000717 	ldw	r20,28(sp)
   3f6ac:	dcc00617 	ldw	r19,24(sp)
   3f6b0:	dc800517 	ldw	r18,20(sp)
   3f6b4:	dc400417 	ldw	r17,16(sp)
   3f6b8:	dc000317 	ldw	r16,12(sp)
   3f6bc:	dec00d04 	addi	sp,sp,52
   3f6c0:	f800283a 	ret
   3f6c4:	91000117 	ldw	r4,4(r18)
   3f6c8:	88c00017 	ldw	r3,0(r17)
   3f6cc:	213fffc4 	addi	r4,r4,-1
   3f6d0:	24001526 	beq	r4,r16,3f728 <__call_exitprocs+0x150>
   3f6d4:	88000015 	stw	zero,0(r17)
   3f6d8:	183fe726 	beq	r3,zero,3f678 <__call_exitprocs+0xa0>
   3f6dc:	00800044 	movi	r2,1
   3f6e0:	1408983a 	sll	r4,r2,r16
   3f6e4:	91406217 	ldw	r5,392(r18)
   3f6e8:	95000117 	ldw	r20,4(r18)
   3f6ec:	214a703a 	and	r5,r4,r5
   3f6f0:	28000b26 	beq	r5,zero,3f720 <__call_exitprocs+0x148>
   3f6f4:	91406317 	ldw	r5,396(r18)
   3f6f8:	2148703a 	and	r4,r4,r5
   3f6fc:	20000c1e 	bne	r4,zero,3f730 <__call_exitprocs+0x158>
   3f700:	99400017 	ldw	r5,0(r19)
   3f704:	d9000117 	ldw	r4,4(sp)
   3f708:	183ee83a 	callr	r3
   3f70c:	90c00117 	ldw	r3,4(r18)
   3f710:	1d3fc51e 	bne	r3,r20,3f628 <__call_exitprocs+0x50>
   3f714:	b8c00017 	ldw	r3,0(r23)
   3f718:	1cbfd726 	beq	r3,r18,3f678 <__call_exitprocs+0xa0>
   3f71c:	003fc206 	br	3f628 <__call_exitprocs+0x50>
   3f720:	183ee83a 	callr	r3
   3f724:	003ff906 	br	3f70c <__call_exitprocs+0x134>
   3f728:	94000115 	stw	r16,4(r18)
   3f72c:	003fea06 	br	3f6d8 <__call_exitprocs+0x100>
   3f730:	99000017 	ldw	r4,0(r19)
   3f734:	183ee83a 	callr	r3
   3f738:	003ff406 	br	3f70c <__call_exitprocs+0x134>
   3f73c:	90c00117 	ldw	r3,4(r18)
   3f740:	1800071e 	bne	r3,zero,3f760 <__call_exitprocs+0x188>
   3f744:	90c00017 	ldw	r3,0(r18)
   3f748:	18000926 	beq	r3,zero,3f770 <__call_exitprocs+0x198>
   3f74c:	9009883a 	mov	r4,r18
   3f750:	b8c00015 	stw	r3,0(r23)
   3f754:	003f2100 	call	3f210 <free>
   3f758:	bc800017 	ldw	r18,0(r23)
   3f75c:	003fb506 	br	3f634 <__call_exitprocs+0x5c>
   3f760:	90c00017 	ldw	r3,0(r18)
   3f764:	902f883a 	mov	r23,r18
   3f768:	1825883a 	mov	r18,r3
   3f76c:	003fb106 	br	3f634 <__call_exitprocs+0x5c>
   3f770:	0007883a 	mov	r3,zero
   3f774:	003ffb06 	br	3f764 <__call_exitprocs+0x18c>

0003f778 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
   3f778:	defffc04 	addi	sp,sp,-16
   3f77c:	df000315 	stw	fp,12(sp)
   3f780:	df000304 	addi	fp,sp,12
   3f784:	e13fff15 	stw	r4,-4(fp)
   3f788:	e0bfff17 	ldw	r2,-4(fp)
   3f78c:	e0bffd15 	stw	r2,-12(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  int r2 = exit_code;
   3f790:	e0bffd17 	ldw	r2,-12(fp)
   3f794:	e0bffe15 	stw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "D02"(r2), "D03"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
   3f798:	e0bffe17 	ldw	r2,-8(fp)
   3f79c:	10000226 	beq	r2,zero,3f7a8 <_exit+0x30>
    ALT_SIM_FAIL();
   3f7a0:	002af070 	cmpltui	zero,zero,43969
   3f7a4:	00000106 	br	3f7ac <_exit+0x34>
  } else {
    ALT_SIM_PASS();
   3f7a8:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
   3f7ac:	003fff06 	br	3f7ac <_exit+0x34>
